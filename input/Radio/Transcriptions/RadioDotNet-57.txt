0.00 11.60 "Анатолий Кулаков" Приветствую вас, дорогие друзья, в эфире Radio.net, выпуск номер 57.
11.60 15.04 "Анатолий Кулаков" И сегодня в студии Анатолий Кулаков.
15.04 16.36 "Игорь Лабутин" И Игорь Лaбутин, всем привет.
16.36 17.36 "Анатолий Кулаков" Да, да.
17.36 25.88 "Анатолий Кулаков" Большое спасибо за помощь нашим постоянным помогаторам Александр Сергеев, Владислав, Алексей, Шевченко, Антон, Илья и Гурий Самарин.
25.88 32.96 "Анатолий Кулаков" Вот, почему мы их… Для тех, кто не знает, у нас есть сайт Технобустик, где можно помочь любимому подкасту любой посильной суммой.
32.96 44.96 "Анатолий Кулаков" Мы будем всему рады и, соответственно, рады всегда вашим и комментариям, и замечаниям, поэтому пишите нам больше комментариев, присылайте нам письма, делитесь полезными статейками, которые вы находите.
44.96 50.96 "Анатолий Кулаков" Мы их обязательно обсудим, посмотрим и, если что-то интересное донесем в подкасте всем, всем неравнодушным.
50.96 56.80 "Анатолий Кулаков" Так, давно мы с вами не виделись, давай посмотрим, что у нас сегодня накопилось в бэклоге.
56.80 64.64 "Анатолий Кулаков" И, наверное, прежде всего хочется поговорить о ДотНете, который не останавливается никак в своем развитии и продолжает улучшать перформанс.
64.64 65.64 "Анатолий Кулаков" Все улучшает, улучшает.
65.64 68.72 "Анатолий Кулаков" Что он там сейчас, ну, сейчас, получал уже?
68.72 76.04 "Игорь Лабутин" Получал он настолько, что стало все очень быстро, ну, как сказать… Так было вроде немедленно, знаешь, как-то.
76.04 77.56 "Игорь Лабутин" Ну, а станет еще быстрее.
77.56 87.08 "Игорь Лабутин" Смотрите, да, Стивен Таум выпустил свою классическую статью к релизу с перечислением всех-всех-всех перформанс-импрувментов, которые вошли в ДотНет 7.
87.08 95.76 "Игорь Лабутин" Всего, на самом деле, в релиз на данный момент попало порядка 7 тысяч pull-requests, согласно статистике GitHub.
95.76 100.56 "Игорь Лабутин" Из них примерно тысяча как-то влияют на перформанс.
100.56 104.00 "Игорь Лабутин" Правда не говорил, в какую сторону, но будем надеяться, что в лучшую.
104.00 107.08 "Игорь Лабутин" В статью вошли порядка 500.
107.08 112.28 "Игорь Лабутин" Вроде как точное число 510 pull-requests, то есть в статье есть ссылки на 510 pull-requests.
112.28 124.20 "Игорь Лабутин" Сам Стивен говорит, что он, когда ревьюет тот или иной код, а судя по всему он ревьюет все эти pull-requests хоть как-то, он себе в отдельный документик складывает собственно ссылочку на PR, чтобы потом он вошел в эту статью.
124.20 133.68 "Игорь Лабутин" Я не знаю, какое нужно терпение и организация, так сказать, всех этих записей, но вот в итоге мы получаем такую большую статью, которую он тоже пишет, наверное, не знаю, месяц.
133.68 134.68 "Игорь Лабутин" Коко.
134.68 149.04 "Игорь Лабутин" В целом, надо сказать, что в ДотНете производительность и вообще, как всегда, и удобство, но производительность это самое главное для всего стэка на самом деле.
149.04 154.68 "Игорь Лабутин" И джит, и рантайм, и библиотеки, они все в том числе сфокусированы на производительности.
154.68 160.68 "Игорь Лабутин" И поэтому неудивительно, что одна седьмая релиза это практически только pull-requests про перформанс.
160.68 169.36 "Игорь Лабутин" Сам пост, он огромный, у меня получилось, по-моему, вдумчивого его чтения, ну час минимум, а то и полтора, мне кажется.
169.36 171.60 "Игорь Лабутин" Целей у этого поста на самом деле два.
171.60 179.48 "Игорь Лабутин" Во-первых, просто рассказать, что поменялось, то есть какие изменения были сделаны, что теперь будет работать быстрее, но это не главная цель.
179.48 212.32 "Игорь Лабутин" Главная цель это пошарить некоторые внутренние знания про то, как команда принимает решения, какие pull-requests взять, какие не взять, почему те или иные pull-requests были взяты, хотя они могут казаться очень нишевыми, но и в pull-requests, и в самой статье есть огромное количество рассуждений, как дотнет устроен изнутри, и как различные его кусочки тем или иным способом аффектят, или наоборот сами аффектятся разными изменениями, и казалось бы, изменения в одном месте внезапно могут повлиять на перформанс в другом или вообще на всей платформе.
212.32 224.32 "Игорь Лабутин" И конечно же, никакие перформанс улучшения невозможно без трейдов, то есть где-то мы что-то улучшили, наверняка мы что-то где-то ухудшили, то есть мы, может быть, что-то ускорили, ну например, увеличили размер экзешника, или там размер илилькода, или еще что-нибудь.
224.32 233.60 "Игорь Лабутин" Эти трейдов тоже важны, и для каждого случая всегда каким-то образом анализируются и принимаются решения, хотим мы их принимать или не хотим.
233.60 253.88 "Игорь Лабутин" Вот ради всего этого знания имеет смысл почитать статью, если вам интересно, как живет такой большой проект, если вам интересно, как дотнет-команда пытается решить эти проблемы, потому что pull-requests много, и не все pull-requests из команды, много pull-requests на самом деле внешних контрибьюторов, за которыми нужно тоже внимательно следить и понимать, что они там поменяли.
253.88 263.08 "Игорь Лабутин" Но давайте перейдем уже, собственно, к основному перечислению всех-всех-всех performance-улучшений.
263.08 273.16 "Игорь Лабутин" Статья очень подробная, в статье есть большое количество бенчмарков, графиков, примеров того, что куда улучшилось, почему улучшилось, какие-то частные случаи рассмотрены.
273.16 283.64 "Игорь Лабутин" Я не буду во все эти детали лезть, потому что на слух такое очень сложно воспринимать, ну там, зачитывать таблички Benchmark.net, наверное, вы прекрасно знаете, что смысла особого нет.
283.64 292.04 "Игорь Лабутин" Поэтому я кратенько пробегусь по всем разделам, которые есть в статье, и постараюсь подсветить то, что мне показалось интересным или важным.
292.04 307.36 "Игорь Лабутин" Возможно, я пропущу какие-то мелкие детали, поэтому если вас интересует особенно какая-то область, то не поленитесь сходить в статью, посмотрите и детальные бенчмарки, и можно их самим запустить, там есть подробная инструкция, и может быть какие-то мелочи, которые я пропустил.
307.36 310.84 "Игорь Лабутин" Ну и самое главное, это конечно JIT.
310.84 314.40 "Игорь Лабутин" Точнее, не самое главное, но кажется, что там довольно много изменений.
314.40 317.60 "Игорь Лабутин" Статистика это, кстати, подтверждает.
317.60 319.04 "Игорь Лабутин" Про статистику в конце немножко скажу.
319.04 325.96 "Игорь Лабутин" JIT, первая фича, которая туда добавилась, это даже не про перформанс, это про диагностику.
325.96 343.60 "Игорь Лабутин" Мы знаем, что у нас есть в Benchmark.net, например, атрибут называется disassembly_diagnoser, который позволяет вам выдать после бенчмарка еще и ассемблерный код, который выполнялся, чтобы, если вам очень внимательно нужно посмотреть на perf, то там будет все подробно написано уже в ассемблере.
343.60 346.76 "Игорь Лабутин" Подробнее уже некуда, или более низкого уровня.
346.76 350.20 "Игорь Лабутин" В принципе, теперь есть возможность сделать это по-другому.
350.20 362.20 "Игорь Лабутин" Теперь можно использовать переменное окружение .NET подчеркивая JIT disassembly, и она была доступна раньше, но она была доступна раньше только в так называемых checked билдах, то есть нужно было собрать дебажную версию runtime, и в ней тогда можно было ее использовать.
362.20 364.00 "Игорь Лабутин" Теперь можно использовать в релизных билдах.
364.00 369.64 "Игорь Лабутин" В этой переменной вы указываете имя и метод, на который вы хотите получить, и исполняете вашу программу.
369.64 372.00 "Игорь Лабутин" Ну, бенчмарк, тест, что угодно.
372.00 384.16 "Игорь Лабутин" После чего у вас на диске появится, по-моему, на диске, может, в output попадет, не помню точно, появится, собственно, дезассемблерный код, дезассемблированный код этого метода.
384.16 403.88 "Игорь Лабутин" Чтобы узнать, как называется ваш метод, который вы хотите, потому что там формат немножко специфический, можно сначала задать переменную .NET подчеркивая JIT disassembly summary, и тогда каждый раз, когда метод будет компилироваться JIT-ом новый, в standard output будет писаться одна строчка, что вот такой-то метод скомпилирован, там как раз можно подсмотреть имя.
403.88 411.76 "Игорь Лабутин" Вот будьте аккуратны, на больших проектах там понятно, что будут компилироваться сотни, тысячи методов, сколько их у вас там есть.
411.76 417.16 "Игорь Лабутин" Вторая штука важная про performance - это onStackReplacement.
417.16 432.28 "Игорь Лабутин" Мы подробно разбирали эту штуку в одном из прошлых выпусков, и по сути смысл в том, что теперь циклы инструментируются, и для каждого цикла runtime считает, сколько было итераций.
432.28 446.48 "Игорь Лабутин" И если превышен некоторый лимит, по умолчанию это 1000, но через специальное переменное окружение это можно переопределить, то тогда метод дополнительно оптимизируется и может быть заменен прямо на стэке.
446.48 455.40 "Игорь Лабутин" Ну, по факту на стэке, конечно, менять ничего не надо, только убедиться, что там ничего не нарушилось с точки зрения локальных переменных.
455.40 460.88 "Игорь Лабутин" Но тело метода подменяется прямо в процессе выполнения, и следующая итерация цикла будет выполняться уже более оптимизированно.
460.88 477.60 "Игорь Лабутин" Это позволяет всякие долгоживущие методы, типа каких-нибудь event loops и так далее, которые выполняются, ну, по сути начинают выполняться при старте приложения, и там еще нет его оптимизированной версии с помощью compilation или еще чего-то в таком духе, позволяет подменить метод на более оптимальный.
477.60 507.72 "Игорь Лабутин" И сюда же как раз тоже относится так называемый dynamic pgo, profile guided optimization, то есть если вы в csproj напишите "tired pgo true" такой элемент, ну, xml, либо используете переменное окружение dotnet.patch_organized_here.pgo, присвоите единичку, то будет работать profile guided optimization, который будет пытаться оптимизировать ваш код согласно собранному профилю того, как программа работает.
507.72 514.64 "Игорь Лабутин" Дальше туда ввезли в JIT, конечно, всякие оптимизации цикла, фекторизацию, inline, поддержку arm64, там тоже куча оптимизаций.
514.64 516.88 "Игорь Лабутин" В общем, очень-очень много всего.
516.88 523.24 "Игорь Лабутин" Мне кажется, что раздел про JIT, он занимает, ну, если не треть, то четверть уж точно статьи.
523.24 526.52 "Игорь Лабутин" Там очень много бенчмарков и всего остального.
526.52 527.52 "Игорь Лабутин" Дальше garbage collector.
527.52 532.20 "Игорь Лабутин" Тут на самом деле не так много, в основном это регионы, мы тоже про это говорили.
532.20 537.52 "Игорь Лабутин" Раньше в garbage collector были сегменты, это были большие куски по несколько сотен мегабайт.
537.52 544.32 "Игорь Лабутин" В одном таком куске жило всегда нулевое + первое поколение, во всех остальных, соответственно, второе поколение + large object heap.
544.32 551.04 "Игорь Лабутин" Теперь у нас по дефолту включены регионы, это более скромные по размеру куски, то есть 4-мегабайтные, например, или 8-мегабайтные.
551.04 561.88 "Игорь Лабутин" И они все одинакового размера, и поколение может состоять из кучи таких кусков, они там как-то друг с другом связываются в разные цепочки и представляют таким образом разные поколения.
561.88 565.28 "Игорь Лабутин" Причем эти куски могут переиспользоваться между разными поколениями туда-сюда.
565.28 574.92 "Игорь Лабутин" Должно, по идее, как-то снижать расход памяти, потому что мы не лоцируем больше огромные-большие куски, в контейнерах это, например, должно быть более приятно.
574.92 576.68 "Игорь Лабутин" Native out there.
576.68 580.80 "Игорь Лабутин" Подробно не буду останавливаться, это довольно занудные бенчмарки.
580.80 585.28 "Игорь Лабутин" Посмотрите, в mono были какие-то улучшения.
585.28 587.52 "Игорь Лабутин" Reflection, вот с Reflection интересно.
587.52 593.92 "Игорь Лабутин" Казалось бы, и Talk это сам отвечает, что кто бы мог подумать, что в статье о performance improvement будет Reflection.
593.92 598.32 "Игорь Лабутин" И это не случайно.
598.32 606.44 "Игорь Лабутин" Как вы, может быть, знаете, у класса метод Info есть метод Invoke, который, собственно, позволяет вызвать метод через Reflection.
606.44 619.84 "Игорь Лабутин" Но эта штука довольно медленная, она вот туда передает все параметры, это список objects, там вот это все, это все нужно там забоксить, не забоксить, но это мелочь, потому что сама диспетчеризация довольно долгая.
619.84 627.44 "Игорь Лабутин" И более быстрый метод — это на самом деле скомпилировать делегат и после этого использоваться компилированный делегат.
627.44 638.36 "Игорь Лабутин" Но это делать такое не всегда возможно, поэтому теперь метод Invoke сделан таким образом, что он сам на самом деле внутри будет автоматически создавать делегат и кэшировать его.
638.36 646.16 "Игорь Лабутин" Это займет чуть-чуть больше времени при первом вызове, но зато во всех остальных утверждается, что примерно пятикратный рост скорости.
646.16 652.68 "Игорь Лабутин" То есть если вы что-то вызывали через Reflection, то просто обновившись на седьмой .NET, вы скорее всего получите хороший прирост скорости.
652.68 661.08 "Игорь Лабутин" С Interop все просто, там добавили новый атрибут library import, о котором чуть ли не в прошлом или в позапрошлом подкасте про него рассказывали.
661.08 665.04 "Игорь Лабутин" Это замена для delimport с помощью source-генераторов.
665.04 675.28 "Игорь Лабутин" И бонус в performance заключается в том, что поскольку мы генерируем source-генератором код, мы на самом деле можем сгенерировать чуть более оптимальный код маршаллинга данных.
675.28 685.04 "Игорь Лабутин" То есть там всякие fixed-буферы и вот это все, они будут более оптимально работать, опять же по бенчмаркам, и хороший выигрыш получается.
685.04 689.60 "Игорь Лабутин" Хотя казалось бы, мы просто меняем атрибут один на другой.
689.60 695.40 "Игорь Лабутин" В трейдинге продолжается движение в сторону, так сказать, fully-managed кода.
695.40 705.24 "Игорь Лабутин" То есть раньше у нас в прошлом релизе Threadpool переписали на полностью менеджер реализацию, а вот IOpool все еще использовал операционную систему, теперь он тоже fully-managed.
705.24 713.56 "Игорь Лабутин" И таймер, который system.threading.timer, тоже теперь fully-managed, он теперь не использует API операционки, он теперь полностью использует только менеджер функции.
713.56 717.80 "Игорь Лабутин" Так, пойдем дальше.
717.80 718.80 "Игорь Лабутин" Примитивные типы.
718.80 721.92 "Игорь Лабутин" Там довольно много всяких разных улучшений.
721.92 743.68 "Игорь Лабутин" Побыстрее стал работа с гуидами, побыстрее стал парсинг флотов и даблов, ну и я не знаю, насколько это связано с generic math, но там как бы вот именно в основном вокруг парсинга всяких тут стрингов довольно много всяких разных мелочей, мелких довольно улучшений, но они приятные, будут приятно работать, поскольку мы все парсим стринги, точнее числа из стрингов, должно стать побыстрее.
743.68 749.72 "Игорь Лабутин" Так, array, string, span.
749.72 784.48 "Игорь Лабутин" Тут добавилась пачка API всяких разных, казалось бы, куда уж там API, но тем не менее они есть, векторизацию добавили и куча performance improvements на тему работы со спанами, string builder внутри чуть-чуть поэффективнее стал работать и string concat тоже, там они сравнялись и по-моему сейчас в итоге string concat, я вот не помню, кто из них быстрее стал друг друга, но в общем, если вы как-то используете string builder, по-моему для одной двух-трех строчек склеить, то concat в общем по-моему сейчас стал гораздо более эффективным, чем был раньше, можете посмотреть на него тоже.
784.48 815.52 "Игорь Лабутин" Regex, тут мы очень подробно все рассказывали в одном пэдже из прошлых выпусков, это добавление non-backtracking флага, то есть если мы точно знаем, что у нас регулярное выражение не требует backtracking, то мы можем выбрать такой режим работы и тогда regex будет не использовать более сложный рекурсивный дефолтный интерпретатор, а пойдет в не-backtracking, алгоритм, который прям хорошо и быстро работает.
815.52 844.28 "Игорь Лабутин" Дальше, интересная мысль, они сказали, что нам нужно было добавить в regex apishku со спанами, но тут проблема в чем, что у нас есть внутренняя стоит машинка, которая собственно оборачивает ссылочку на то, что мы парсим, а спан это нельзя положить, ссылку на спан нельзя положить в объект, который будет лежать в куче, и поэтому им пришлось довольно много всего поменять внутри, прям огромное количество изменений, и это все само по себе вот такое переписывание принесло довольно хороший performance boost.
844.28 856.60 "Игорь Лабутин" И надо понимать, что теперь в дотнете на самом деле, когда вы, несмотря на то, что вы пользуетесь просто классом regex, у вас получается есть в дотнете 4 движка, которые могут этот regex парсить.
856.60 861.76 "Игорь Лабутин" У нас есть дефолтный интерпретатор, который будет использоваться, если вы ничего другого не сделали, просто сказали regex.create.
861.76 872.92 "Игорь Лабутин" У нас есть compiled, это если вы указали слово, опцию compiled, то он в рантайме сгенерит какой-то код, ну скомпилирует это в код и заимитит его.
872.92 881.52 "Игорь Лабутин" У нас есть non-backtracking, это вообще отдельная штука, и есть source generator, если вы атрибутиком разметили, он еще source generator, сгенерит код для regex.
881.52 886.12 "Игорь Лабутин" Короче, 4 разных варианта, думайте над вашими regex, думайте, что лучше всего использовать.
886.12 896.36 "Анатолий Кулаков" Они же не противоречат, если я захочу откомпилировать non-backtracking, source-генерированный regex engine, то что мне делать?
896.36 900.64 "Игорь Лабутин" Хороший вопрос, я, честно говоря, не пробовал их совмещать.
900.64 908.48 "Игорь Лабутин" Ну то есть, source-генератор у тебя по дефолту откомпилируется, то есть там опция compile, ну она no operation, он у тебя по-любому будет компилированный.
908.48 913.08 "Анатолий Кулаков" Но он не скомпилирует тот, который умеет non-backtracking или backtracking?
913.08 917.80 "Игорь Лабутин" Нет, если ты поставил source-генератор, то он по-дефолту будет.
917.80 922.24 "Игорь Лабутин" Да, то есть как только ты использовал атрибут source-генератором, у тебя точно уже будет компилированный код.
922.24 923.76 "Игорь Лабутин" Ну хорошо, что насчет backtracking?
923.76 927.08 "Игорь Лабутин" Вот с backtracking непонятно, надо посмотреть, я не помню точно.
927.08 936.56 "Анатолий Кулаков" По идее он же, наверное, во время source-генерации способен проанализировать regex и понять, есть там вообще backtracking или нет backtracking, и автоматически тот или иной движок подставить.
936.56 938.72 "Игорь Лабутин" Там не совсем так.
938.72 943.04 "Игорь Лабутин" Ты не всегда по regex можешь точно понять, нужен ли тебе backtracking.
943.04 947.36 "Анатолий Кулаков" Интересно, мне казалось, ну это какой-то конкретный шаблон, который заглядывает назад или вперед.
947.36 951.52 "Игорь Лабутин" Не-не-не, backtracking это же про другое, backtracking это про то, как мы ищем.
951.52 957.84 "Игорь Лабутин" То есть, если у тебя есть точка-звездочка, то non-backtracking там сожрет всё вперёд и всё.
957.84 960.40 "Анатолий Кулаков" Ну это жадно-нежадно, ты имеешь в виду.
960.40 962.48 "Анатолий Кулаков" В том числе, да, жадность-нежадность.
962.48 969.92 "Анатолий Кулаков" Мне казалось, backtracking это наоборот, когда ты заглядываешь в предыдущий матч, который находил 10 степов назад и сравниваешь его с текущим.
969.92 990.84 "Игорь Лабутин" Нет, в их терминологии, по крайней мере, то, что я помню, backtracking это именно логика, алгоритма внутри, которая говорит про то, что если мы типа вот мачем, мачем, мачем, мачем, допустим, там был, пусть даже не жадный, а там какой-нибудь, не знаю, с явным указанием, да, плюсик от двух до трёх элементов, допустим.
990.84 993.96 "Игорь Лабутин" Ну, там типа две буквы А или три буквы А.
993.96 997.80 "Игорь Лабутин" Вот ты сначала попробуешь с двумя буквами, с тремя буквами А, не получится.
997.80 1002.04 "Игорь Лабутин" Ты тогда откатишься назад, возьмёшь две буквы А и попробуешь заново мачать хвост.
1002.04 1003.04 "Игорь Лабутин" Вот это backtracking.
1003.04 1009.60 "Игорь Лабутин" А non-backtracking это значит, что ты по шаблону RegEx всегда идёшь только вперёд, то есть ты по строке.
1009.60 1027.52 "Игорь Лабутин" Ты никогда не откатываешься назад по шаблону-строке, то есть ты не пытаешься вот в этих повторах, там где звёздочки и плюсики, взять, допустим, меньшее количество элементов или большее количество элементов, а всегда твёрдо берёшь, один раз решаешь, сколько ты берёшь, и ровно столько пытаешься взять.
1027.52 1035.00 "Игорь Лабутин" Для некоторых входных данных, то есть это нужно понимать, какой у тебя RegEx плюс какие у тебя типы входных данных.
1035.00 1036.80 "Игорь Лабутин" Ну, в таком случае, да, понятно.
1036.80 1039.72 "Игорь Лабутин" То есть ещё нужно хорошо думать.
1039.72 1042.08 "Игорь Лабутин" Дальше, коллекции.
1042.08 1045.04 "Игорь Лабутин" Там какие-то совсем мелочи.
1045.04 1047.96 "Игорь Лабутин" LinkU тоже какие-то мелочи, там векторизацию добавили.
1047.96 1051.96 "Игорь Лабутин" И отдельный специальный хендлинг для массивов примитивных типов.
1051.96 1077.52 "Игорь Лабутин" То есть теперь, если у вас, допустим, в inumerable, это лист на самом деле, в котором лежит коллекция int, то даже если вы передадите его в какой-нибудь, не знаю, Max, как inumerable, то Max сообразит, что внутри лежит, по сути, массив int, и будет его операцию векторизовывать с ним.
1077.52 1083.08 "Игорь Лабутин" Даже, например, на то, что это inumerable, он сможет достать внутренний массив и на нём прогнать векторные операции.
1083.08 1086.24 "Игорь Лабутин" Вот хитрюки как, абстракции протекли.
1086.24 1090.36 "Игорь Лабутин" Вообще, внутри протекают, но снаружи ты этого не видишь.
1090.36 1091.36 "Игорь Лабутин" Так что тут как раз нормально.
1091.36 1095.48 "Игорь Лабутин" Так, вот вывод файловый.
1095.48 1102.32 "Игорь Лабутин" Тут в основном вся работа велась по уменьшению количества syscalls.
1102.32 1106.20 "Игорь Лабутин" В основном это касалось Linux, насколько я понял, но на винде тоже что-то досталось.
1106.20 1110.28 "Игорь Лабутин" Больше всяких разных оверлоудов, куда можно cancellation токен передать.
1110.28 1127.36 "Игорь Лабутин" Ну и два метода, про которые мы говорили, это у стрима появились два новых метода readExactly и readAtleast, когда вам нужно прочитать либо точное количество байт, либо хотя бы 100 кодобайт, то теперь это можно делать явно без вот этих вот файлов, пока там операция чтения не вернёт ноль или вот это всё.
1127.36 1140.80 "Игорь Лабутин" В сжатии добавились улучшения в Brotli и в Zip, то есть просто скорость опять же, и немножко поменяли дефолт, насколько я понимаю, в Brotli, что такое константа под названием optimal, или как-то так.
1140.80 1149.28 "Игорь Лабутин" В прошлых версиях, я так понял, optimal это всегда было созвучно с максимальной компрессией, что как бы нифига не optimal с точки зрения времени.
1149.28 1154.76 "Игорь Лабутин" Networking, сокеты, SSL-стрим и HTTP-хеддеры заимпровели.
1154.76 1173.44 "Игорь Лабутин" Забавно, что в HTTP-хеддерах отказались от словаря, то есть раньше HTTP-хеддеры в HTTP-клиенте хранились в словарике, ну, то есть они не в самом HTTP-клиенте, они там немножко в внутреннем классе, но неважно, они хранились в словаре, где ключом выступал название хеддера, а значением — значение хеддера.
1173.44 1179.16 "Игорь Лабутин" Если у вас в запросе хеддеров меньше 64-х, они теперь хранятся просто тупо в плоском списке.
1179.16 1183.68 "Игорь Лабутин" Выяснилось, что в нем искать быстрее, чем в словаре.
1183.68 1186.84 "Анатолий Кулаков" Ну да, на маленьких массивах массив быстрее на поиск.
1186.84 1196.00 "Игорь Лабутин" Да, ну вот меня удивила константа 64, я не знаю, что-то у меня на практике редко встречались ситуации, когда мне нужно больше 64-х хеддеров, ну, наверное,
1196.00 1201.44 "Анатолий Кулаков" бывает. Да, для хеддеров это не сказать, что это маленький список, обычно 64-х хеддеры это какой-то огромный,
1201.44 1204.68 "Игорь Лабутин" может быть забросили ответ. Да, поэтому непонятно.
1204.68 1214.88 "Игорь Лабутин" С Джейсоном там куча перформанс-импровментов, но они такие маленькие, но тем не менее, гора фич всяких разных, там где сериализация, сериализация, мы про это говорили отдельно, не буду углубляться.
1214.88 1224.20 "Игорь Лабутин" Как ни странно, затронули XML, XML-сериалайзер улучшился, и там в основном улучшили работу с памятью.
1224.20 1239.88 "Игорь Лабутин" Но там были такие довольно очевидные ошибки, то есть там, например, выделялся массив чаров на 60 тысяч, что очевидно занимало, у нас чар относит 2 байта, соответственно, это было 120 тысяч байтов, то есть здравствуй, large object heap.
1239.88 1243.80 "Игорь Лабутин" Его сделали в 2 раза меньше, ну, всё, стало хорошо сразу.
1243.80 1247.08 "Игорь Лабутин" Сразу оно уже везло на любом первом поколении, и всё,
1247.08 1252.32 None замечательно. Не обошли вниманием в криптографии то же самое, улучшили набор локейшенов.
1252.32 1268.44 "Игорь Лабутин" В диагностике, ну, то есть в namespace-е diagnostics, в классе процесс сильно улучшили некоторые методы с точки зрения работы memory, точнее с точки зрения работы CPU и объёма потребляемой памяти.
1268.44 1278.84 "Игорь Лабутин" Там вот, может помните, был разговор, что там процесс с точки зрения current_process очень дорогая, или как-то так, она там типа тянет всю информацию обо всех процессах, а потом возвращает только свой, ну, в таком духе.
1278.84 1292.48 "Игорь Лабутин" Вот, короче, там сейчас некоторые методы стали гораздо более дешёвыми, и улучшили activity_class, ну, потому что он нужен для local_telemetry, соответственно, там ведётся работа над ним довольно активно, чтобы он хорошо себя вёл с точки зрения performance.
1292.48 1299.88 "Игорь Лабутин" В exceptions добавили throw_helper, может быть вы видели, там, argument_null_exception.throw_if_null, там, в таком духе.
1299.88 1301.24 "Игорь Лабутин" Вот таких побольше стало.
1301.24 1326.76 "Игорь Лабутин" Реестр тоже, как бы, место, которое я не ожидал увидеть в performance improvements, но тем не менее выяснилось, что на старте, ну, как выяснилось, это было известно всегда, но стало важным, что на старте приложения в традиционной винде довольно много читается реестра, там, получаются всякие культуры, там, вот это всякая такая информация, которая в винде хранится в реестре.
1326.76 1334.84 "Игорь Лабутин" И поэтому оптимизация registry_key.get_value, она прям хорошо влияет на стартап, то есть стартап стал быстрее.
1334.84 1354.52 "Игорь Лабутин" Ну и для завершения, для полировки добавили с некоторой количеством аналайзеров, то есть теперь, например, для internal и private классов аналайзер будет рекомендовать сделать его sealed, потому что g2 это лучше, ну и вообще, как бы, розлину понимать, что наследников быть не может.
1354.52 1358.96 "Игорь Лабутин" Ну и g2 тоже, потому что можно тогда не имитировать virtual call, а прям конкретные call.
1358.96 1370.44 "Игорь Лабутин" Наконец-таки завезли аналайзер, который будет проверять классическую схему, там, if dictionary.contains_key, потом обращение по индексу и предлагать заменить на track_get_value.
1370.44 1377.32 "Игорь Лабутин" Ну и аналайзеры вокруг regex'овых и library_import, source_generators и attributes, но это мы уже обсуждали в соответствующих темах.
1377.32 1378.64 "Игорь Лабутин" Вот примерно так.
1378.64 1392.12 "Игорь Лабутин" Я еще обещал про статистику, Егор Абакатов в твиттере выложил, значит, картиночку, где, ну короче, проанализирована вот эта статья с точки зрения количества PR'ов от каждого из авторов.
1392.12 1396.08 "Игорь Лабутин" Ну и на первом месте там, конечно же, как ты думаешь, кто?
1396.08 1397.08 "Игорь Лабутин" Егор Абакатов?
1397.08 1398.08 "Игорь Лабутин" Нет, Стивен Тауп.
1398.08 1399.08 "Игорь Лабутин" Тауп все еще жив.
1399.08 1402.52 "Игорь Лабутин" Да, то есть он не только собирает, он еще и сам кучу фигачит.
1402.52 1407.96 "Игорь Лабутин" Причем там с хорошим отрывом, потому что типа из 510 PR'ов 140 что ли от Тауба.
1407.96 1417.24 "Анатолий Кулаков" Я вот как раз думал, что он ушел там каким-нибудь менеджером из статьи писателей и уже меньше кода коммитит, а оказывается нет, еще с такой же производительностью
1417.24 1422.48 "Игорь Лабутин" все чаще. Нет, он очень крут, да, в этом смысле, а вот на втором месте, по-моему, Егор как раз с 50 с чем-то.
1422.48 1432.64 "Игорь Лабутин" Ну то есть, опять же, надо понимать, что тут количество PR'ов это такая метрика странная, потому что там один PR, грубо говоря, может быть на строчку, а другой там полдотмента переписать.
1432.64 1445.08 "Анатолий Кулаков" Ну да, и там до PR'а нужно было еще провести огромную аналитическую работу, там исследований всяких, анализов, там же, если вы заглянете на GitHub, просто так PR'ы, а тем более в JIT, а тем более по первому-то их просто так не берут.
1445.08 1459.12 "Анатолий Кулаков" Ты там должен сначала доказать, что он ничего не ухудшает, как он оптимизирует, куда повлияет, как у него совместимость на всех платформах, как на больших приложениях все поведет, там на текущих приложениях все поведет, там столько нужно доказать, что ты не козел, прежде чем как бы закоммитишь, что ого.
1459.12 1474.12 "Игорь Лабутин" Да, у вас обязательно попадают тесты, потому что он будет разбираться, это случайно упало или это из-за вас, вот, и тесты скажут, ого-го, у нас там у трех методов увеличился размер в байтах, и там надо будет получить одобрение большого, так сказать, руководства, что да, можно.
1474.12 1481.16 "Игорь Лабутин" Ну в общем, PR'ы это очень разные штуки, поэтому такая статистика это чисто для фана.
1481.16 1484.48 "Игорь Лабутин" Но тем не менее, 500 PR'ов про performance, это прям круто в статье.
1484.48 1489.56 "Игорь Лабутин" Ну что, давай пойдем дальше, performance у нас не ограничивается, давай про язык поговорим.
1489.56 1499.36 "Анатолий Кулаков" Давай, в принципе, меня радует, что мы практически все основные фичи языка за этот год обсуждали, и я думаю, что для наших постоянных слушателей никаких новшеств не будет.
1499.36 1520.00 "Анатолий Кулаков" Вот, ну здесь появился Билл Вагнер, это большой начальник, соответственно большой дядька, который очень умный, уважаемый и все такое, и он подсветил некоторые фичи C# 11, которые ему почему-то захотелось выделить, вот мы не могли пройти мимо и решили еще раз все-таки повторить, а что именно понравилось товарищу Биллу Вагнеру.
1520.00 1541.64 "Анатолий Кулаков" Итак, в 11-м C#, как вы знаете, наверное 11-й C# и вообще вся весь фреймворк сейчас на финишной прямой, у них там уже начинается пререлизное тестирование, пререлизные финализации и всячески готовится основная финальная версия, которую они выкатят уже в конце этого года.
1541.64 1564.96 "Анатолий Кулаков" Прежде всего Биллу понравился required keyword, это, напомню, специальная штука, которую можно применить к свойствам или филдам классов, а также структур, то есть вы его добавляете к вашим классам, то есть к вашим свойствам, и они приобретают магическое свойство инициализироваться только во время создания этого класса.
1564.96 1574.72 "Анатолий Кулаков" Тут, наверное, полезно немножко в историю углубиться, изначально у нас были обычные свойства, если вы себе представите, что у вас есть, это будет string firstname, у которого есть public get и public set.
1574.72 1581.44 "Анатолий Кулаков" Нормальные, понятные свойства, но затем людям захотелось странного, они захотели использовать set только во время создания классика.
1581.44 1590.68 "Анатолий Кулаков" И все, и больше с set не пользоваться, вот такие вот, более-менее иммьютабельные классы эмулировать.
1590.68 1599.12 "Анатолий Кулаков" И появился недавно такое ключевое слово как init, то есть вместо set можно написать firstname get .init.
1599.12 1608.76 "Анатолий Кулаков" Вот, init это, конечно, хорошо, но init он был необязательный, то есть вы его можете в начале инициализации класса присвоить, а можете не присваивать.
1608.76 1612.48 "Анатолий Кулаков" Компилятор никак вас не заставляет что-то сделать.
1612.48 1616.48 "Анатолий Кулаков" Дальше странные люди захотели еще более странного.
1616.48 1625.60 "Анатолий Кулаков" Они захотели, чтобы все-таки у нас был обязательный init, чтобы какие-то свойства, которые есть у класса, которые обязаны быть проинициализированы, можно было инициализировать.
1625.60 1630.08 "Анатолий Кулаков" И тогда они придумали добавить еще одно ключевое слово, которое называется required.
1630.08 1632.36 "Анатолий Кулаков" И теперь это стало выглядеть следующим образом.
1632.36 1637.04 "Анатолий Кулаков" Required string firstname и в скобочках get .init.
1637.04 1653.68 "Анатолий Кулаков" Это компилятор сразу говорит, что при создании класса вызывающая сторона обязана проинициализировать это свойство, обязана это сделать в момент создания, и если вдруг она это не сделала, то не компились и быстренько падай и заставь всех разработчиков обязательно что-нибудь записать.
1653.68 1659.52 "Анатолий Кулаков" Соответственно, как я уже упоминал, required может быть не только для свойств, но и для филдов.
1659.52 1666.24 "Анатолий Кулаков" И вы вполне можете проинициализировать это поле null, если вдруг вам тип позволяет это сделать, но главное, чтобы вы проинициализировали.
1666.24 1669.16 "Анатолий Кулаков" То есть вы ответственно заявляете, что да, я туда что-то записал.
1669.16 1676.64 "Анатолий Кулаков" Фича довольно спорная, спорно реализованная и в комментариях выделяют основные проблемы.
1676.64 1697.72 "Анатолий Кулаков" То есть почему вообще признак того, что нужно класс инициализировать только во время создания объекта, вот эту фичу показали с помощью ключевого слова init, а то, что обязательно нужно инициализировать, добавили еще одно слово required.
1697.72 1701.40 "Анатолий Кулаков" При том, что слово required не может существовать в свойстве, если нет init.
1701.40 1704.36 "Анатолий Кулаков" То есть init обязателен для required.
1704.36 1707.60 "Анатолий Кулаков" Раз он обязателен, то никакого смысла вообще два слова делать не было.
1707.60 1713.32 "Анатолий Кулаков" Могли бы вместо init придумать еще какое-нибудь ключевое слово, например, born или let или еще что-нибудь.
1713.32 1720.88 "Анатолий Кулаков" Короче, что-то, что показывает, что можно, то есть нужно обязательно присвоить этому свойству значение во время создания.
1720.88 1724.72 "Анатолий Кулаков" В общем, и init, это можно значение присвоить этому свойству.
1724.72 1726.60 "Анатолий Кулаков" Необязательно было заводить разные слова.
1726.60 1735.52 "Анатолий Кулаков" Также непонятно, почему его сделали ключевым словом в начале, потому что логичнее, может быть, было бы написать string first name get required init.
1735.52 1743.48 "Анатолий Кулаков" То есть перенести были больше к init, потому что это слово required не относится, в общем, ко всему свойству, ни к типу, ни к названию, ни к get.
1743.48 1745.48 "Анатолий Кулаков" А вот как раз только последний частик init.
1745.48 1748.32 "Анатолий Кулаков" В общем, очень много было каких-то споров.
1748.32 1757.28 "Анатолий Кулаков" И я так понял, что если уже в таком виде они дошли до, тащили его до релиза, то все-таки, скорее всего, устаканили именно данное представление.
1757.28 1769.24 "Анатолий Кулаков" Ну что ж, довольно… А, ну еще можно ответить странность в том, что мы и так уже имели возможность проинициализировать класс обязательными какими-то свойствами или обязательными филдами.
1769.24 1771.72 "Анатолий Кулаков" И такое магическое свойство называлось конструктор.
1771.72 1774.12 "Анатолий Кулаков" Конструктор существовал в дотнете с первой версии.
1774.12 1779.84 "Анатолий Кулаков" И если вам обязательно нужно было принять какой-то аргумент и проинициализировать свойства, вы могли его объявить в конструкторе.
1779.84 1782.08 "Анатолий Кулаков" Вот, такая чудесная вещь.
1782.08 1785.48 "Анатолий Кулаков" И почему-то многим людям ее не хватало.
1785.48 1797.00 "Анатолий Кулаков" Аргументы были следующие, что мы не хотим это инициализировать в конструкторе, так как там в конструкторе, если много параметров, то не очень понятно, какой параметр что обозначает.
1797.00 1799.80 "Анатолий Кулаков" В общем, после этого появились вроде как именованные аргументы.
1799.80 1803.64 "Анатолий Кулаков" С помощью именованных аргументов вы можете написать имя в конструкторе.
1803.64 1813.80 "Анатолий Кулаков" Потом эти люди начали говорить, что имя, конечно, мы написать можем, но там они пишут, эти имена пишутся в CamelCase, а нам хочется все-таки сдавать в PascalCase, как это есть в свойствах.
1813.80 1832.56 "Анатолий Кулаков" Поэтому, по сути, если вы опишете required свойства, если вы опишете required свойства в этом классе, то инициализатор будет выглядеть практически точно так же, как если бы вы их описали в конструкторе, только вместо CamelCase будет PascalCase, и вместо круглых скобочек будут фигурные скобочки.
1832.56 1835.12 "Анатолий Кулаков" Вот, в принципе, и все, что поменяла данная фишка.
1835.12 1843.52 "Анатолий Кулаков" Но при этом она потратила ключевое слово, при этом она утяжелила синтексис, потому что больше мусора, теперь у нас больше ключевых слов по проперти.
1843.52 1848.36 "Анатолий Кулаков" И я бы не сказал, что она дала какой-то большой буст или какой-то большой профит.
1848.36 1856.96 "Анатолий Кулаков" Но, опять же, какие-то любители у этой фичи есть, потому что везде почему-то находятся некоторые люди, которые кричат, что они этого давно ждали и жить без этого не могли.
1856.96 1860.84 "Анатолий Кулаков" Если вы понимаете, почему вы жить без этого не можете, напишите нам в комментариях.
1860.84 1865.00 "Анатолий Кулаков" Очень интересно понять ваши юзкизы, зачем вам не хватало конструктора.
1865.00 1879.16 "Анатолий Кулаков" И если вдруг вы не можете использовать последнюю версию компилятора, который понимает это ключевое слово, есть маленький workaround, вы можете использовать метод, который называется setsRequiredMembers, который вы навешиваете прямо над конструктором.
1879.16 1893.56 "Анатолий Кулаков" И этот метод декларирует, что все возможные аргументы, которые должны обязательно быть пронициализированы в вашем классе и пронициализированы именно в свойства или в field, их конструктор, вот данный конструктор, который помечен атрибутом, он их инициализирует.
1893.56 1900.04 "Анатолий Кулаков" Тогда компилятор это тоже пронициализирует, подхватит, и вы можете использовать вот этот новомодный синтаксис без ключевого слова.
1900.04 1902.00 "Анатолий Кулаков" Тут тоже такой workaround есть.
1902.00 1905.52 "Анатолий Кулаков" Вот, это первая фича.
1905.52 1910.48 "Анатолий Кулаков" Вторая фича, которая понравилась Биллу Вагнеру, это generic math support, безусловно.
1910.48 1917.56 "Анатолий Кулаков" Мы generic math разбирали в недавнем выпуске, там была большая интересная статейка про ней, кому интересно попереслушайте.
1917.56 1923.92 "Анатолий Кулаков" Вкратце, это довольно специфичный сценарий, может быть даже большинство разработчиков с ним никогда не столкнется в повседневной жизни.
1923.92 1938.24 "Анатолий Кулаков" Эта возможность очень необходима там, где мы пишем всякие алгоритмы, глубоко учимся с математикой, с искусственным интеллектом и вообще где много используем различные цифры, различные номеры.
1938.24 1955.28 "Анатолий Кулаков" И в этой фиче она также оптимизируется в рантайме очень хорошо и ее очень плотно использует сам фреймворк, поэтому даже если вы никак не используете ее у себя в программе, то знайте, что в фреймворке она очень сильно помогла и там очень много улучшилось различных вещей.
1955.28 1973.48 "Анатолий Кулаков" Основана она, или в частности связаны с ней такие странные антонимы, как статические абстрактные методы, виртуальные методы в интерфейсах и вот это вот прочая дичь, как раз все делалось специально для generic math.
1973.48 1980.36 "Анатолий Кулаков" С помощью generic math вы можете переопределять, то есть с помощью статических абстрактных методов вы можете переопределять операторы.
1980.36 1983.04 "Анатолий Кулаков" Теперь можно сделать операторы практически для всего.
1983.04 1998.48 "Анатолий Кулаков" И здесь очень интересно заметить, что в отличие от стандартного механизма с виртуальными методами, вот эти виртуальные методы в интерфейсах и статические абстрактные методы, они раскрываются компилятором в момент непосредственно самой компиляции.
1998.48 2010.56 "Анатолий Кулаков" И компилятор included все операторы прямо в compile time, то есть никакого там virtual dispatch ничего в этом уже не будет.
2010.56 2018.84 "Анатолий Кулаков" То есть особенность, несмотря на то, что называется abstract virtual и прочие вот эти слова, никаких виртуальных вызовов здесь не будет.
2018.84 2031.12 "Анатолий Кулаков" И из интересного здесь у нас еще появились сокращения, то есть специальные сокращенные кейворд типы для int ptr и unsigned int ptr.
2031.12 2034.72 "Анатолий Кулаков" Соответственно, nint и nuint.
2034.72 2048.92 "Анатолий Кулаков" Вот такие короткие названия у этих типов теперь можно будет использовать и соответственно анализаторы, которые будут советовать теперь преобразовать это все в названия типов, тоже поставляются из коробки.
2048.92 2055.04 "Анатолий Кулаков" И третья маленькая фича – это импрувменты в nameof.
2055.04 2061.08 "Анатолий Кулаков" Наверное, самое весомое, самое значимое, потому что nameof – это хорошо, я nameof люблю, применяю.
2061.08 2063.52 "Анатолий Кулаков" В общем, и чем больше мы начнем применять, тем лучше.
2063.52 2071.52 "Анатолий Кулаков" И вот соответственно один из таких расширенных возможностей nameof, мы теперь можем его применять там, где декларируем параметры методов.
2071.52 2072.88 "Анатолий Кулаков" Допустим, в атрибутах.
2072.88 2080.04 "Анатолий Кулаков" Сам, ну, очень частый случай, когда нам нужно в атрибуте просто обозначить каким-то образом имя аргумента, который принимает метод.
2080.04 2095.12 "Анатолий Кулаков" Например, типичным примером является атрибут not null if not null, который помогает системе анализа нулябельных типов понять, каким образом тот параметр, который передается сейчас в методах, зависит от результата, который вернет метод.
2095.12 2097.96 "Анатолий Кулаков" И для этого нужно в атрибуте указать имя этого параметра.
2097.96 2104.40 "Анатолий Кулаков" Вот раньше nameof не мог это осилить, потому что имя параметра декларировалось ниже, чем декларировался сам атрибут.
2104.40 2111.76 "Анатолий Кулаков" А теперь он умный, он понимает, что nameof от атрибута тоже можно использовать, соответственно, чтобы описать этот атрибут.
2111.76 2115.24 "Анатолий Кулаков" Вот, такие вещи подсветил Билл.
2115.24 2121.56 "Анатолий Кулаков" На этом, наверное, C# 11 превью фичи, самое главное, от Билла Вагнера заканчивается.
2121.56 2130.24 "Анатолий Кулаков" Я думаю, что больше фич мы увидим в будущем, и, соответственно, наверное, мы с ними со всеми так уже знакомы, будем просто повторять, чтобы не забыть.
2131.24 2134.84 "Игорь Лабутин" Ну, лучшее повторение, как известно, попробовать.
2134.84 2146.32 "Игорь Лабутин" Я надеюсь, что очень скоро выйдет релиз кандидат, ну, уже можно брать какую-нибудь превью, но либо берите релиз кандидата и пробуйте новые фичи прямо сразу, пишите свою математику, если есть время, должно быть прикольно.
2146.32 2147.32 "Игорь Лабутин" Пойдем дальше.
2147.32 2154.68 "Игорь Лабутин" Мы довольно давно не обращались к JetBrainsRider или Sharper, на самом деле есть пара поводов.
2154.68 2157.44 "Игорь Лабутин" За август произошло два события.
2157.44 2174.84 "Игорь Лабутин" За прошедший август, во-первых, решат, решат, SharperRider исполнилось пять лет, и по этом поводу вышла статья, где написана такая вот кратенькая история, которую я что-то подзабыл уже, поэтому давайте немножко быстренько вспомним, как это все еще рождалось.
2174.84 2181.28 "Игорь Лабутин" Значит, в январе 2016 года было анонсировано, что в принципе JetBrains будет заниматься такой вот EDE для дотнета.
2181.28 2192.20 "Игорь Лабутин" Я так понимаю, что примерно в это же время было анонсировано private preview, и дальше была стандартная процедура для JetBrains, это были EAP.
2192.20 2194.80 "Игорь Лабутин" Как ты думаешь, сколько было EAP у Rider?
2194.80 2195.80 "Игорь Лабутин" Штук 10.
2195.80 2196.80 "Игорь Лабутин" Мало.
2196.80 2201.24 "Игорь Лабутин" У Rider было 24 EAP и один релиз-кандидат.
2201.24 2205.04 "Игорь Лабутин" Видимо, часть EAP были такие релиз-кандидатами уже.
2205.04 2209.20 "Анатолий Кулаков" Да, да, с релиз-кандидатами как-то не совсем маловато по сравнению особенно с EAP.
2209.20 2224.44 "Игорь Лабутин" Ну, в общем, так или иначе, в августе 2017 года, то есть заняло полтора года получается, да, с момента первого анонсмента до собственно релиза, вышла в свет версия 2017.1 Rider, и это была первая версия.
2224.44 2232.12 "Игорь Лабутин" Вот соответственно в августе 2022 года мы отмечаем 5 лет Rider, который в общем-то неплохо подрос за это время.
2232.12 2238.80 "Игорь Лабутин" При этом надо понимать, что ReSharper примерно в это же время, несколько недель назад, исполнилось 18 лет.
2238.80 2244.96 "Игорь Лабутин" ReSharper очень древний, а прям, не знаю, столько не живут, и столько не программируют.
2244.96 2253.60 "Анатолий Кулаков" Ну да, ReSharper появился, блин, как только, что-то я себя помню, это вот прям самый первый плагин еще для самых первых студий, которые только начали поддерживать плагины был.
2253.60 2262.88 "Игорь Лабутин" Да, ну вот как раз в статье там было сказано, что уже в те времена были задумки как бы сделать нам IDE из этого, и там были даже попытки в эту сторону.
2262.88 2272.40 "Игорь Лабутин" Потом это все родилось, всякие разные проекты, типа Dot Peak так родился, этот декомпилятор, да, то есть там есть кусочек логики ReSharper по анализу и так далее.
2272.40 2278.72 "Игорь Лабутин" То есть, и потом вот уже полноценный райдер на смеси ReSharper и IDE.
2278.72 2282.08 "Игорь Лабутин" Так что получилась вот такая штука.
2282.08 2298.20 "Игорь Лабутин" При этом вот за прошедший месяц еще произошло одно событие, это вышел очередной релиз ReSharper и райдера 2022.2, не ошибся, где ну тоже довольно много интересных изменений или неинтересных, а посмотреть.
2298.20 2300.16 "Игорь Лабутин" Значит давайте пробежимся по ним быстренько.
2300.16 2303.96 "Игорь Лабутин" В ReSharper, соответственно, появился 11 C#.
2303.96 2308.24 "Игорь Лабутин" Это тот самый required keyword, про который Толя рассказал чуть выше.
2308.24 2321.84 "Игорь Лабутин" Это raw string support, помните мы рассказывали про стринги, которые могут быть многострочными и там нужно поставить минимум три кавычки, а можно больше, и тогда, соответственно, число кавычек внутри будет тоже считаться нормальными кавычками.
2321.84 2323.60 "Игорь Лабутин" Это теперь поддержано в райдере.
2323.60 2326.20 "Игорь Лабутин" В pattern matching поддержали list patterns.
2326.20 2331.48 "Игорь Лабутин" Ну в общем-то и все, по 11 C# пока больше каких-то новостей нету.
2331.48 2342.40 "Игорь Лабутин" Это довольно сильно оптимизировали использование памяти, если вы используете solution-wide analysis, так что если вы его не использовали из-за того, что студия как-то очень много кушала, попробуйте включить заново.
2342.40 2349.64 "Игорь Лабутин" Он действительно хорошее улучшение, типа там в том примере, который показан в статье, 300 мегабайт упало до 60, по-моему.
2349.64 2353.64 "Игорь Лабутин" То есть прям, ну, пять раз существенное улучшение.
2353.64 2357.88 "Игорь Лабутин" В код анализах тоже добавилось интересное несколько штук.
2357.88 2375.56 "Игорь Лабутин" Во-первых, появился такой improvement, можно теперь сказать to explicit program class, то есть если вы сгенерили шаблончик или у вас достался код, в котором нету программ класса, а есть только top-level statement, и можно сказать теперь to explicit и решарка конвертнет в старый добрый привычный вид.
2375.56 2379.04 "Игорь Лабутин" Ну и есть обратное преобразование, конверт в top-level.
2379.04 2388.76 "Игорь Лабутин" Мы переработали немножко inotify property changed, соответственно оно теперь чуть как-то по-лучше, по-правильному, более качественно анализируется.
2388.76 2391.88 "Игорь Лабутин" Интересная фича называется virtual formatting.
2391.88 2403.12 "Игорь Лабутин" Мне на самом деле интересно, почему ее не было нигде раньше и почему до нее никто не додумался, или я просто не знаю, что она где-то была раньше и до нее уже все додумались, а просто в этом мире она не применяется.
2403.12 2425.36 "Игорь Лабутин" Короче, теперь вы можете смотреть код в решарпере в том виде, как вы его хотите, то есть вы настраиваете свои настройки, размеры отступов, табы, не знаю, правила переноса скобочек, переноса аргументов, и в студии вы видите его код ровно так, как вы захотели, независимо от того, как оно на диске.
2425.36 2428.88 "Игорь Лабутин" То есть он его переформатирует налито в нужный вам вид.
2428.88 2430.52 "Игорь Лабутин" И при этом не сохраняет.
2430.52 2431.52 "Игорь Лабутин" Не сохраняет.
2431.52 2432.52 "Игорь Лабутин" Это только представление.
2432.52 2433.52 "Игорь Лабутин" Это только представление.
2433.52 2444.00 "Игорь Лабутин" Я не очень понимаю, надо детально вчитываться и проверять, что будет, если, например, у вас, ну, не знаю, представим вызов функции, где у вас там 10 аргументов в одну строчку на диске, а решарпер вам их показывает в виде 10 строчек.
2444.00 2447.60 "Игорь Лабутин" Там же есть такая настройка, каждый аргумент на своей строчке.
2447.60 2451.48 "Игорь Лабутин" Вот что будет, если вы в этом месте добавите 11 аргумент отдельной строчкой?
2451.48 2456.68 "Игорь Лабутин" Он тогда, наверное, вынужден будет сохранить как раз таки уже 10 строчек, ну, как иначе.
2456.68 2461.92 "Анатолий Кулаков" Ну, или возьмет настройки из текущего EditorConfig и отформатирует так, как положено в EditorConfig.
2461.92 2462.92 "Анатолий Кулаков" Ну, например.
2462.92 2467.56 "Анатолий Кулаков" То есть и сохранит уже в том виде, в котором положено сохранять, несмотря на то, что ты видишь в своем любимом виде.
2467.56 2471.28 "Игорь Лабутин" Да, ну, в общем, вообще фича как бы интересная.
2471.28 2475.28 "Игорь Лабутин" Мне кажется, возможно, она прекратит спорта, были пробелы.
2475.28 2478.56 "Анатолий Кулаков" Потому что каждый будет видеть свое, то, что ему нравится.
2478.56 2481.98 "Игорь Лабутин" Да, и слайд-скриншотики незнакомого кода со соседем по команде.
2481.98 2489.72 "Игорь Лабутин" Типа смотри, значит, вот в этом вызове ты такой смотришь свой код, а у тебя нет такого вызова, потому что он отформатирован по-другому и код не угадывается вообще.
2489.72 2490.72 "Игорь Лабутин" Ну, то есть, интересно.
2490.72 2496.12 "Игорь Лабутин" На самом деле, интересная фича должна сильно помочь в тех командах, где нету какого-нибудь строгого форматирования.
2496.12 2508.76 "Игорь Лабутин" Либо же, на самом деле, она может еще помочь, например, если я на ноутбуке с маленьким экраном, допустим, переформатирую весь код, чтобы действительно у меня, например, все аргументы были по строчкам разбиты.
2508.76 2512.12 "Игорь Лабутин" А на большом рабочем мониторе мне пофигу, пусть оно будет в одну строку.
2512.12 2515.80 "Игорь Лабутин" То есть, может быть, даже так будет полезно использовать.
2515.80 2518.12 "Игорь Лабутин" Не с точки зрения там разных форматов, а просто из-за
2518.12 2523.96 "Анатолий Кулаков" окружения. Ну, мне кажется, да, если у вас в команде нет единого формата, то возьмите и придите к единому формату.
2523.96 2527.24 "Анатолий Кулаков" Отформатируйте все один раз, залейте и все, договоритесь.
2527.24 2532.48 "Анатолий Кулаков" Да, ну, то есть, это, наверное, все-таки не фича, которая пытается побрать разные форматы.
2532.48 2538.24 "Анатолий Кулаков" А вот с мобильника посмотреть, с ноутбука посмотреть, с большого экрана, с проектора.
2538.24 2539.84 "Анатолий Кулаков" Может быть, может быть.
2539.84 2543.80 "Игорь Лабутин" Ну, в общем, посмотрим, что скажет комьюнити, посмотрим, как это будет применяться.
2543.80 2553.76 "Игорь Лабутин" И еще одна опция, если вы замечали, если вы смотрели на ваш диск, особенно если у вас какой-нибудь небольшой диск на ноутбуке, вы знаете, что ReSharper оставляет довольно большое количество разных кэшей.
2553.76 2557.84 "Игорь Лабутин" Он кэширует информацию о салюшнах, которые вы открывали и так далее.
2557.84 2566.76 "Игорь Лабутин" И если, например, это салюшн, который вы там, не знаю, склонировали из соседнего проекта, посмотрели и больше вообще никогда его не откроете, его давно уже удалили, кэш все равно остается.
2566.76 2578.68 "Игорь Лабутин" Так вот, теперь в ReSharper есть прям новый раздел в опции, где можно настроить, где можно посмотреть все пути к кэшам и для каждого настроить, сколько дней там хранить максимум инфу.
2578.68 2581.76 "Игорь Лабутин" И он автоматически будет очищать все старое.
2581.76 2585.96 "Игорь Лабутин" Ну и можно рукой нажать кнопочку, типа почистить сейчас.
2585.96 2588.72 "Игорь Лабутин" Вот это прям мне кажется очень хорошей опцией на ноутбуке.
2588.72 2607.40 "Игорь Лабутин" У меня там, ну прям не задачка записана, но я примерно раз в 3-4 месяца запускаю какой-нибудь там, как он там зовется, короче, утилитку для просмотра, чем у меня занято место на диске и кэши ReSharper Raider обычно там довольно большие.
2607.40 2608.88 "Игорь Лабутин" Приходится их чистить.
2608.88 2615.24 "Анатолий Кулаков" Я, к сожалению, нахожу тоже артефакты ReSharper Raider, но мне кажется, что это не кэши.
2615.24 2625.80 "Анатолий Кулаков" Например, очень легко можно найти кэш старой инсталляции Raider, который почему-то хранит их несколько для того, чтобы быстренько переключиться, если вдруг новая инсталляция не задалась.
2625.80 2628.20 "Анатолий Кулаков" В общем, такая глупость у него по умолчанию включена.
2628.20 2634.04 "Анатолий Кулаков" Это тоже надо отключать и потом тоже какие-то странные сборки, какие-то странные, ну, гетпакеты он там кэширует.
2634.04 2635.68 "Анатолий Кулаков" В общем, то, что не относится к проекту.
2635.68 2641.80 "Анатолий Кулаков" То есть, кэши проекта можно куда-то настроить на одну папочку, допустим, в темпах, постоянно в систему складывать и там их легко чистить.
2641.80 2646.88 "Анатолий Кулаков" То вот такие вот системные странные вещи, довольно непонятно, как очищать правильно.
2646.88 2655.44 "Игорь Лабутин" Ну, у меня это частично, да, я тоже смотрел руками, но на самом деле вот последний Toolbox, RedBrain Toolbox, по-моему, там все хорошо с этим, там все это настраивается.
2655.44 2661.84 "Анатолий Кулаков" Ну, как хорошо, там все это настраивается, но по дефолту там две копии другого приложения, которые вы устанавливаете.
2661.84 2665.60 "Анатолий Кулаков" Если у вас там стоит и ReSharper, и Raider, и еще по парочку
2665.60 2675.40 "Игорь Лабутин" дотпиков, то это довольно веселое место. А если вы ставили, допустим, какой-нибудь Raider не через Toolbox, а потом поставили через Toolbox, то у вас будет два Raider.
2675.40 2676.40 "Анатолий Кулаков" Ну, в 17.
2676.40 2680.48 "Анатолий Кулаков" Это вообще, блин, верх безумия, я не понимаю, кто до этого додумался.
2680.48 2684.20 "Игорь Лабутин" Ну, я в итоге вот поддался и у меня все через Toolbox поставлено сейчас.
2684.20 2693.28 "Анатолий Кулаков" Да, мне так пришлось тоже все вычищать, как бы ставить через Toolbox, потому что сам он не подхватывал, Raider не видит, что у нас тут Raider.
2693.28 2694.28 "Игорь Лабутин" Ну, ладно.
2694.28 2704.12 "Игорь Лабутин" Соответственно, вместе с ReSharper и Raider мы обновили все .NET-тулы, то есть .MEMORY, .PIC, .COVER, поэтому если вы им пользуетесь, посмотрите, там тоже есть улучшения.
2704.12 2710.32 "Игорь Лабутин" Что касательно Raider, там те же самые C# 11 фичи, которые мы обсудили.
2710.32 2731.84 "Игорь Лабутин" Из интересного, там завезли Performance, значит, на винде весь бэкэнд теперь смигрирован на шестой .NET, поэтому все те улучшения, которые мы обсуждали, ну, не сегодня, мы обсуждали уже седьмые, но и до этого было довольно много улучшений, они все теперь попали в Raider и утверждается, что теперь Solution открываются на 40% быстрее.
2731.84 2734.60 "Игорь Лабутин" На каких-то Solution это было померяно.
2734.60 2742.24 "Игорь Лабутин" Точно так же как в ReSharper оптимизировали использование памяти для Solution Wide Analysis, так что используйте.
2742.24 2751.68 "Игорь Лабутин" Непонятно мне, в Raider добавили Unreal Engine Support, я что-то не знал, что для Unreal можно .NET разрабатывать, но говорят можно.
2751.68 2753.68 "Игорь Лабутин" Даже специальный вид проекта есть, UProject.
2753.68 2757.88 "Игорь Лабутин" Короче, не знаю, но если вы занимаетесь Unreal, наверное, вы что-то про это знаете.
2757.88 2769.88 "Игорь Лабутин" Интересно, что добавили MAUI Support, пока это все early preview, это только для Android и iOS, но тем не менее, если вы хотите попробовать MAUI, вот теперь в Raider это уже можно.
2769.88 2797.80 "Игорь Лабутин" И теперь можно еще сделать такую клевую штуку, как Default Settings for All Solutions, то есть если вы хотите зафиксировать один и тот же layout всех окошек для всех Сolution, а Raider по дефолту их будет в каждом Сolution по-своему располагать, ну в смысле, это запоминается Per Solution, то теперь можно сказать, типа, применяй это все ко всем Сolution всегда, и зафиксировать свой один любимый layout, независимо от того, что вы там открываете.
2797.80 2822.80 "Игорь Лабутин" И последнее, если вы хотите анализировать память, работать с Dot Memory, то Raider теперь в Dot Memory по сути встроен, то есть если вы, например, в студии знаете, вот есть такие окошечки, по умолчанию начинаете отладку в студии, там по дефолту открывается этот Performance кусочек, где там ползет потребление памяти, видны garbage collection, и вот теперь примерно такая же штука можно будет сделать в Raider, Dot Memory там теперь включен по сути в него.
2822.80 2832.36 "Игорь Лабутин" Вот, это соответственно то, что нам выдали в августе на ReSharper Raider 2022.2, можно не забывать.
2832.36 2835.36 "Игорь Лабутин" Так что ждем, что будет дальше.
2835.36 2850.88 "Игорь Лабутин" Ну, фичи как бы не какие-то такие супер большие, то есть понятно, что выглядит это пока все довольно так и как экстенсивное развитие, добавление новых фич языка и так далее, но посмотрим, что будет дальше, будут какие-то прорывные новые фичи или нет.
2850.88 2851.88 "Анатолий Кулаков" Пойдем дальше.
2851.88 2855.64 "Анатолий Кулаков" Да, давай немножко отличимся от лзо, поговорим про жизнь.
2855.64 2857.40 "Анатолий Кулаков" В общем, есть метод и одно.
2857.40 2859.88 "Анатолий Кулаков" Статейка такая, как раз-таки расслабиться и поболтать.
2859.88 2868.92 "Анатолий Кулаков" Статейка интересная про то, каким образом команда Azure App Services переезжала на Kestrel и YARP.
2868.92 2892.20 "Анатолий Кулаков" В общем, как мы знаем, что .NET 6 это LTS, он включает в себя очень много всяких фич по перформансу и огромное число команд, проектов, экосистем, сейчас на него мигрирует, ну то есть не сейчас, а давно уже начали мигрировать и вот одна из таких команд как раз-таки поделилась отчетом, что у нее случилось и как она вообще дошла до жизни такой.
2892.20 2893.20 "Анатолий Кулаков" Давайте немножко посмотрим.
2893.20 2912.20 "Анатолий Кулаков" Особенностью Azure App Services является в том, что это довольно критический компонент для самого Azure, у него есть там миллионы, миллиарды, секси-лиарды запросов там в секунду и у него подписаны SLA с кастомерами, поэтому просто так вронять эту платформу нельзя.
2912.20 2937.40 "Анатолий Кулаков" И вот в далеком 2021 году инженеры из различных команд, которые включают в себя как .NET команду, так и Azure команду, собрались вместе и решили переписать, мигрировать, транспилировать и вообще перенести App Service вообще со всеми своими прибабахами на новомодный фреймворк, который включал бы в себя прежде всего Kestrel и YARP.
2937.40 2960.76 "Анатолий Кулаков" И после 6 месяцев непрерывной работы им это всё-таки удалось, и вот они запустили там какие-то первые, даже не первые машины, потому что они уже все машины перевели, уже всю инфраструктуру перевели, и сейчас они уже собирают первые метрики после полного перехода, и вот решили такой отчётик своеобразный выпустить.
2960.76 2962.00 "Игорь Лабутин" Прежде всего давайте поближе.
2962.00 2972.56 "Игорь Лабутин" Надо сказать, и я надеюсь, ты про это расскажешь, что ты много говоришь про перевели, перенесли, надо понимать, что в 2022 году они работали на ИИС.
2972.56 2976.12 "Анатолий Кулаков" Да, ну и работали довольно-таки неплохо.
2976.12 2982.80 "Анатолий Кулаков" Вообще давай про историю поговорим, что это такое, потому что я думаю, что у нас с Azure мало работают людей, и может многие не сталкивались с тем, что
2982.80 3009.44 "Игорь Лабутин" это такое. Ну даже, я тебе могу сказать, что даже те, кто работают, я например, для меня было сюрпризом, знаешь, в какой-то момент, что там внутри старый добрый ИИС, что-то по СИС, вот это всё, и если нужно, в какой-то момент нам нужно было очень тонко настраивать App Service, и там действительно пришлось лезть в детали того, как это настраивалось в ИИС, специальные ключики в App Config прописывать, которые только для ИИСа нужны, точнее в App Config, как там это правильно называлось-то?
3009.44 3011.44 "Игорь Лабутин" Ну да-да, веб-конфиг какой-то.
3011.44 3025.12 "Игорь Лабутин" Да, вот я прям вспомнил, не знаю, времена 5-6-8 летней давности, а год вроде 21-22 был, так что ИИС до сих пор жив.
3025.12 3054.08 "Анатолий Кулаков" Ну да, чтобы вы понимали, зачем там ИИС и где там ИИС, то есть прежде всего это специальная система, специальное приложение, которое принимает HTTP, HTTPS трафик из различных виртуальных адресов, также занимается терминейтингом SSL-сессии, если это вдруг нужно, оно отвечает за то, чтобы определить непосредственно самих воркеров, куда нужно передать работу, и роутит вот эти запросы, которые мы приняли, к этим, соответственно, воркерам.
3054.08 3063.00 "Анатолий Кулаков" И это, кстати, такой чисто инфраструктурный блок, который скейлится на каждый юнит, где это нужно для того, чтобы как раз вот эти все запросы обрабатывать.
3063.00 3075.92 "Анатолий Кулаков" Как я уже правильно сказал, это работало на Винде с ИИСом, HTTP-сайсом, и у него был application request routing, RR небезызвестный в качестве, соответственно, форвардинга, который опирался на Вин-HTTP.
3075.92 3085.56 "Анатолий Кулаков" По всем этим словам, вы, скорее всего, поняли, что это вообще глубоко завязано в Винду, и оторвать его от Винды было практически нереально, без полного переписывания всего и всяк.
3085.56 3096.40 "Анатолий Кулаков" И нужно признать, что это довольно высоконагруженный компонент, он ходит в топ-3 самых нагруженных сервисов в Azure, вот этот вот штучка.
3096.40 3119.32 "Анатолий Кулаков" App-сервисам уже 10 лет, они пропускают через себя 160 миллионов в день HTTP-реквестов, 14 миллионов хост неймов резолвят, масштабируется на 1500 скейл-юнитов, и плюс еще 10 тысяч каких-то выделенных скейл-юнитов.
3119.32 3123.00 "Анатолий Кулаков" Не знаю, что это такое именно, но звучит довольно внушительно.
3123.00 3125.68 "Анатолий Кулаков" В общем, недаром его зовут одним из самых больших.
3125.68 3133.00 "Анатолий Кулаков" Еще из примечательного, вот этот самый компонент, который отвечает за все эти HTTP, redirect, SSL, он называется front-end role.
3133.00 3139.80 "Анатолий Кулаков" То есть, когда нормальные разработчики, хардкорные разработчики говорят про front-end, они имеют в виду как раз-таки вот это.
3139.80 3154.56 "Анатолий Кулаков" То есть, это точка, которая принимает запросы, redirected, SSL, шифрование, резолв доменных имен, вот это front-end, а не то, что вы там подумали всякие, не знаю, что там, ангуляры, реакты и прочая вот эта чушь с кнопочками красненькими и синенькими.
3154.56 3156.24 "Анатолий Кулаков" То не front-end, то так себе, рюшечки.
3156.24 3160.88 "Анатолий Кулаков" В общем, поговорим о нормальных фронт-эндах для нормальных разработчиков.
3160.88 3171.28 "Анатолий Кулаков" Ну, естественно, как вы поняли, что чтобы избавиться от Windows сервера, от ISA, HTTP-sites и вот этих прочих плагинов к ISA, нужно переходить на нормальные кроссплатформенные тулзы.
3171.28 3174.16 "Анатолий Кулаков" И вот этими как раз тулзами и являются Kestrel и YARP.
3174.16 3176.48 "Анатолий Кулаков" В общем, они замаячены на горизонте.
3176.48 3188.68 "Анатолий Кулаков" И давайте вообще же немножко вспомним, что Kestrel это веб-сервер прежде всего, open-source, кроссплатформенный, мега-быстрый, там рвал бенчмарки и продолжает рвать только в путь.
3188.68 3197.16 "Анатолий Кулаков" У него performance – это просто ключевая штука, там об этом заботятся, там на это смотрят, там это оптимизируется с каждым новым релизиком.
3197.16 3199.56 "Анатолий Кулаков" И он очень фичастый, в принципе.
3199.56 3202.32 "Анатолий Кулаков" Kestrel сейчас очень много всего имеет и умеет.
3202.32 3219.56 "Анатолий Кулаков" И были ключевыми моменты для последнего Kestrel, который заимпровил поддержку HTTP/2, то есть там очень много performance-улучшений всяких было, HTTP/2, добавил поддержку HTTP/3, который тоже не был необходим, соответственно, ребятам из App-сервисов.
3219.56 3232.60 "Анатолий Кулаков" И вообще много-много сделал импрувментов, особенно для систем с несколькими процессорами, с несколькими ядрами, что тоже было актуально.
3232.60 3238.40 "Анатолий Кулаков" И YARP, соответственно, это Yet Another Reverse Proxy, мы о нем тоже много говорили, часто упоминаем.
3238.40 3246.96 "Анатолий Кулаков" Это open-source Reverse Proxy Toolkit, то есть такой SDK, на основании которого вы можете построить свой собственный очень быстрый прокси-сервер.
3246.96 3258.04 "Анатолий Кулаков" Он располагается поверх ISPnet, то есть все привычные там middleware, практики, уже какие-то знания, они пригождаются, они на месте.
3258.04 3260.64 "Анатолий Кулаков" Это не какой-то новый непонятный сервис.
3260.64 3266.32 "Анатолий Кулаков" Он, соответственно, сфокусирован на TOPS, чтобы дать максимальную гибкость.
3266.32 3273.80 "Анатолий Кулаков" У него есть куча настроек, каким образом все весь этот трафик конфигурировать, перенаправлять, терминейтить, циклить, собирать и прочее.
3273.80 3279.88 "Анатолий Кулаков" Это можно делать через файлики, через C# код, через какие-то лямбды, в общем, через все, что вам только заблагорассудится.
3279.88 3283.92 "Анатолий Кулаков" И, естественно, у него есть уже поддержка HTTP/2 и HTTP/3.
3283.92 3295.44 "Анатолий Кулаков" В общем, и вот эти вот ключевые моменты, эти два компонента было решено взять и заменить вот эту старую устаревшую платформу, которую они пользовались.
3295.44 3298.56 "Анатолий Кулаков" Итак, для чего они это сделали?
3298.56 3311.04 "Анатолий Кулаков" Прежде всего им хотелось поднять сильно перформанс, потому что тот же самый .NET, тот же Kestrel, тот же YARP, у них перформанс результаты увеличивается с каждым релизом.
3311.04 3322.72 "Анатолий Кулаков" Недаром вот тут и статейки пишутся огроменные про то, сколько там improvements и в GT, и в GC, и непосредственно в Runtime, и где только нет, и в BCL.
3322.72 3325.32 "Анатолий Кулаков" То есть все постоянно импровьмится, все постоянно улучшается.
3325.32 3333.04 "Анатолий Кулаков" Поэтому, если даже просто перейти на Kestrel и YARP и просто обновляться до последних версий, по идее, должно все летать.
3333.04 3335.32 "Анатолий Кулаков" Летать с каждым релизом быстрее и быстрее.
3335.32 3342.20 "Анатолий Кулаков" В общем, их эта перспектива радовала, им этого хотелось, и безусловно к этому они стремились.
3342.20 3352.00 "Анатолий Кулаков" Также им хотелось большей гибкости, то есть, как вы знаете, IS, он, конечно, гибкий, но в пределах тех плагинов, которые под него уже написали.
3352.00 3358.00 "Анатолий Кулаков" Это совсем не то, что, например, закастомизировать YARP или дописать какие-то расширения для Kestrel.
3358.00 3360.20 "Анатолий Кулаков" То есть это делается намного легче.
3360.20 3367.08 "Анатолий Кулаков" Поэтому гибкость, гибкость должна была им эта платформа дать намного больше, чем они имели сейчас.
3367.08 3375.52 "Анатолий Кулаков" Также им хотелось поддержать новомодные протоколы, которые сильно просили кастомеры.
3375.52 3380.00 "Анатолий Кулаков" В частности, это HTTP/3 и gRPC, и вот импругменты в HTTP/2.
3380.00 3387.92 "Анатолий Кулаков" Это почему-то очень многие хотели, и у них в баклаге стоял на это блокер до тех пор, пока они не перешли на такую связку.
3387.92 3394.62 "Анатолий Кулаков" Естественно, им хотелось отказаться от платформы зависимых IS, HTTP/3, IRR и вот этих всех глупостей.
3394.62 3410.00 "Анатолий Кулаков" Потому что для такой высоконагруженной вещи тащить винду, делать вот эти пробросы в нативный код, там заниматься маршаллингом - все это не то, чтобы быстро, не то, чтобы безбажно, не то, чтобы вообще удобно читабельно и поддерживаемо.
3410.00 3414.80 "Анатолий Кулаков" И в принципе, Kestrel и YARP решают все эти проблемы прекрасно.
3414.80 3420.88 "Анатолий Кулаков" Итак, прежде всего, какие перед ними стояли вызовы, которые нужно было решить.
3420.88 3434.24 "Анатолий Кулаков" Как я уже говорил, на вот эту связку, там Kestrel и YARP переходили довольно много сервисов, и такие большие, известные, красивые, как Bing, Azure Active Directory, Dynamic 365, все они перешли.
3434.24 3436.40 "Анатолий Кулаков" Про всех про них есть отдельные статейки.
3436.40 3443.44 "Анатолий Кулаков" Там тоже хорошие цифры, все хвалят, все радуются, как все стало хорошо.
3443.44 3451.56 "Анатолий Кулаков" Но все эти сервисы, которые уже перешли, у них было одно интересное свойство - они писались с Microsoft для Microsoft.
3451.56 3463.12 "Анатолий Кулаков" И там особых проблем с тем, чтобы как-то кастомеры как-то напрягутся или что-то у кастомеров сломается, там таких забот не было особенно.
3463.12 3466.80 "Анатолий Кулаков" А вот об сервисах, тут ситуация немножко другая.
3466.80 3483.76 "Анатолий Кулаков" По сути, это площадка, платформа, это хостинг для неких приложений кастомеров, непосредственно кастомеров, которые эти приложения написаны на разных языках программирования, на разных платформах, у них разные требования к качеству, у них разные требования к SLA и прочие вещи.
3483.76 3488.68 "Анатолий Кулаков" То есть тут проблем ошибиться должно быть, возможности ошибиться должно быть намного меньше.
3488.68 3500.00 "Анатолий Кулаков" Ну и, соответственно, несовместимостей тоже должно быть намного больше, потому что очень большое разнообразие всей этой инфраструктуры, и несовместимости там могут быть вообще на каждом шагу.
3500.00 3505.40 "Анатолий Кулаков" Абсолютно непонятно, что там эти оголтелые кастомеры засунут на наш любимый App Service.
3505.40 3511.00 "Анатолий Кулаков" Дальше у них стала проблема в том определить вообще, что такое хорошая и удачная миграция.
3511.00 3512.48 "Анатолий Кулаков" То есть, что это такое?
3512.48 3523.04 "Анатолий Кулаков" Потому что если у своего собственного приложения вы можете померить какие-то там метрики, которые понятные, которые вы выставляете, то у чужого приложения вы не знаете, хорошо это или плохо.
3523.04 3525.20 "Анатолий Кулаков" Допустим, банальные штитки без опроса.
3525.20 3537.24 "Анатолий Кулаков" Если вы меряете, что успешные штитки без опросов там у вас 100%, неуспешных там 0%, ну или более там ситуация приближенная к жизни, успешных там 90% и неуспешных 10%.
3537.24 3543.40 "Анатолий Кулаков" И вы считаете, что, соответственно, это плохо, потому что успешные должны быть 100%.
3543.40 3546.92 "Анатолий Кулаков" В общем, такие метрики можно было накладывать, если бы это было ваше собственное приложение.
3546.92 3555.40 "Анатолий Кулаков" Но у кастомерских приложений вполне может быть такая ситуация, когда неуспешные запросы – это неплохо, это как бы часть бизнес-процесса.
3555.40 3558.48 "Анатолий Кулаков" В общем, они и так работают, у них такие коды, они вот так вот обмениваются.
3558.48 3567.64 "Анатолий Кулаков" Поэтому здесь пришли к выводу, что нужно мерить не абсолютные величины, сколько 99% или 100% успешных запросов, а нужно мерить относительно.
3567.64 3577.00 "Анатолий Кулаков" То есть, сколько у этого сервера, сколько обычно он принимает хороших запросов, то есть, сколько обычно он отдает хороших ответов, так правильно говорить.
3577.00 3580.48 "Анатолий Кулаков" И, соответственно, сколько он отдает обычно плохих ответов и каких плохих ответов.
3580.48 3583.92 "Анатолий Кулаков" И после того, как они переехали, они сравнивали именно вот эти показатели.
3583.92 3587.44 "Анатолий Кулаков" Не то, что все хорошо и все ответы должны быть саксесные.
3587.44 3594.60 "Анатолий Кулаков" А в том, какое количество, какое процентное соотношение было до переезда на Kestrel и YARP и после переезда.
3594.60 3596.68 "Анатолий Кулаков" Вот такой показатель довольно сильно помог.
3596.68 3616.76 "Анатолий Кулаков" Дальше, так как клиенты были довольно чувствительные, так как у нас там был SLA, у них была очень большая подготовительная работа к тому, чтобы, если вдруг механизм не сработает, вот этот Kestrel и YARP почему-то на каком-то Kestrel-клиенте, у которого там какие-то страшные конфигурации, можно было легко это все откатить.
3616.76 3620.40 "Анатолий Кулаков" Можно было откатить обратно на знакомый и добрый ISA и HTTP/SYS.
3620.40 3626.12 "Анатолий Кулаков" И естественно, откачивать они все это хотели не для всего кластера там огромного, а вот конкретно для юнита.
3626.12 3628.56 "Анатолий Кулаков" То есть, это должна быть поддержка per unit.
3628.56 3632.32 "Анатолий Кулаков" В общем, эта ситуация у них тоже хорошо получилась.
3632.32 3636.88 "Анатолий Кулаков" И соответственно, в процессе переезда они нашли большое количество багов.
3636.88 3641.92 "Анатолий Кулаков" Ну тут даже не багов, а опять же, особенностей конфигурации у различных кастомеров.
3641.92 3660.32 "Анатолий Кулаков" Например, один из интересных багов это в том, что в начале каждого запроса, обычного HTTP запроса, там должен быть HTTP верб типа GET, SLASH и HTTP, номер протокола там 1.1 обычно и дальше уже заголовки и все такое.
3660.32 3668.04 "Анатолий Кулаков" В общем, но некоторые кастомеры присылали в начале не слово GET, не глагол, а перенос строки.
3668.04 3674.24 "Анатолий Кулаков" И только после этого уже шла первая строка непосредственно HTTP протокола.
3674.24 3678.12 "Анатолий Кулаков" На самом деле, ну и ИС с этим успешно жил.
3678.12 3683.28 "Анатолий Кулаков" У ИСа все хорошо, он это как-то переваривал и позволял таким запросам существовать.
3683.28 3690.16 "Анатолий Кулаков" Кестерл же писался с учетом на перформанс и с учетом на более строгое соответствие протоколам.
3690.16 3692.96 "Анатолий Кулаков" И поэтому у него это сразу в бета HTTP request exception.
3692.96 3694.12 "Анатолий Кулаков" Тут даже вообще без разговоров.
3694.12 3705.64 "Анатолий Кулаков" И соответственно, так как команды внутри Microsoft, они просто зашли в соседний отдел, взяли чашечку чая и сказали, ребята из Кестерла, давайте как-нибудь договоримся.
3705.64 3710.00 "Анатолий Кулаков" Типа нам хочется, чтобы Кестерл был не такой суровый, дайте нам как-нибудь его там поднастроить.
3710.00 3712.68 "Анатолий Кулаков" И в конце концов договорились, поднастроили.
3712.68 3722.16 "Анатолий Кулаков" Кестерл теперь умеет воспринимать такие запросы, ну потому что это жизнь, это реальность, в некоторые фармворки такое посылают и с этим надо уметь работать, потому что кастомер всегда прав.
3722.16 3729.32 "Анатолий Кулаков" В общем, сделали Кестерл более-менее толерантным, который идет на вот такие вот компромиссы и пропускает какие-то вещи.
3729.32 3733.64 "Анатолий Кулаков" Например, такая ситуация была с тем, чтобы поддержать табы внутри хедеров.
3733.64 3738.92 "Анатолий Кулаков" Это тоже по спецификации не предусмотрено, можно даже сказать запрещено.
3738.92 3745.40 "Анатолий Кулаков" В общем, но клиенты такую штуку присылают и мы как грамотные разработчики должны уметь такие вещи обрабатывать.
3745.40 3752.96 "Анатолий Кулаков" В общем, взаимодействие команд там было в полный рост, там оптимизировали как на уровне .NET, так как на уровне Azure, так на уровне самого Кестерла разработчики.
3752.96 3755.72 "Анатолий Кулаков" В итоге удачно переехали.
3755.72 3759.88 "Анатолий Кулаков" Как выглядит удачный переезд?
3759.88 3765.36 "Анатолий Кулаков" В продакшене они получили улучшение в пропускной способности где-то на 80%.
3765.36 3767.00 "Анатолий Кулаков" Это на их перформанс-тестах.
3767.00 3772.24 "Анатолий Кулаков" То есть понятно, что тесты специальные, синтетические, но они более-менее должны отражать то, что происходит на самом деле.
3772.24 3779.52 "Анатолий Кулаков" Также они очень сильно заметили, что снизилась утилизация CPU.
3779.52 3786.48 "Анатолий Кулаков" Прям сильно снизилась так, что они это даже увидели на каких-то счетах за электричество и вот эти прочие мелочи.
3786.48 3796.48 "Анатолий Кулаков" Также у них появилась поддержка новомодных протоколов, таких как HTTP3, JRPC, которых сильно-сильно просили их кастомеры, их пользователи.
3796.48 3807.88 "Анатолий Кулаков" И все еще они находятся на ранних этапах мониторинга, то есть в будущем мы увидим больше интересных цифр, но вот первые буквально снятые как пирожки из продакшена результаты вот такие.
3807.88 3812.52 "Анатолий Кулаков" Ну и плюс ко всему это дало огромные перспективы и заделы на будущее.
3812.52 3819.68 "Анатолий Кулаков" Прежде всего в будущем они могут съехать на Linux с таким платформой, с такими характеристиками, больше их на винде ничего не держат.
3819.68 3822.40 "Анатолий Кулаков" Соответственно Kestrel и YARP они кроссплатформенные.
3822.40 3829.40 "Анатолий Кулаков" Также они могут теперь отказаться от Nginx, который тоже выполнял определенные функции, который сейчас может взять на себя Kestrel.
3829.40 3831.36 "Анатолий Кулаков" Nginx теперь тоже абсолютно не нужен.
3831.36 3843.12 "Анатолий Кулаков" Ну и плюс они уже могут собрать все эти наработки, которые они писали там обычно все-таки на дотнете и как-то их использовать уже в этой новой инфраструктуре и гибче ее настраивать.
3843.12 3848.08 "Анатолий Кулаков" И теперь они получили ту самую заветную гибкость и скорость и управляемость.
3848.08 3860.16 "Анатолий Кулаков" И все это со знакомым понятным инструментом, который полностью там менеджмебл, управляемым, дебагебл и имеет кучу всяких диагностических тулзов и улучшений каждый релиз.
3860.16 3866.84 "Анатолий Кулаков" В общем такая саксистория, очень большой такой команда, очень большого такого продукта как Azure App Services.
3866.84 3870.56 "Игорь Лабутин" Ну и такого может быть небольшого, но полезного продукта как YARP.
3870.56 3881.68 "Анатолий Кулаков" Ну YARP тоже, да, хорошая вещь, мне кажется его прям в микрософте очень начали везде засовывать, везде использовать, прям будем надеяться, что он зацветет и запахнет.
3881.68 3886.40 "Игорь Лабутин" Мы его использовали на одном из продуктов и в принципе неплохо получилось, да.
3886.40 3891.56 "Игорь Лабутин" Там не такие конечно нагрузки, но тем не менее простенько и быстренько подняли простой Reverse Proxy.
3891.56 3892.56 "Игорь Лабутин" Давай пойдем дальше.
3892.56 3896.96 "Игорь Лабутин" Дальше у нас, как ты говорил, тема на поговорить, совсем расслабиться.
3896.96 3903.08 "Игорь Лабутин" Здесь тема еще больше расслабиться и поговорить вообще практически не про программирование, а про то, что происходит вокруг.
3903.08 3904.96 "Игорь Лабутин" И это про .NET Foundation.
3904.96 3920.48 "Игорь Лабутин" Если кто-то еще помнит, что это такое, потому что кажется, что это все дело немножко ушло на задний план и вообще как-то исчезло с радаров, но тем не менее там происходят небольшие события, давайте немножко вспомним, что происходило и что происходит сейчас.
3920.48 3923.64 "Игорь Лабутин" Вообще, что такое .NET Foundation, зачем он задумывался?
3923.64 3941.56 "Игорь Лабутин" Насколько я понял, это организация, которая была задумана там пообщенным-то Microsoft для того, чтобы всячески помогать open-source проектам с точки зрения юридической поддержки, какой-то рекламы, продвижения, ну и технической поддержки, там предоставлять сертификаты, репозитории, вот это все.
3941.56 3945.52 "Игорь Лабутин" Это был план, но что-то пошло не так.
3945.52 3954.64 "Игорь Лабутин" Значит, к ним заджойнилось довольно много проектов, попытаться, ну чтобы что-то получить, какие-то бонусы и так далее.
3954.64 3962.68 "Игорь Лабутин" Но вот то, что нас подвигло сейчас про это поговорить, это то, что в этом году из фундейшн как-то проекты начали линять.
3962.68 3974.04 "Анатолий Кулаков" Ну то есть, то, что они туда пачками заходят, это было известно уже много лет, там они рассылают и письма, у них есть специальный радар, и там действительно все именитые проекты, которые вы могли бы услышать, они точно там есть.
3974.04 3979.68 "Анатолий Кулаков" Но вот чтобы оттуда выходили, вот этого я давно не знал, не помнил, не видел, и вот вдруг началось.
3980.24 3994.08 "Игорь Лабутин" Да, причем я знаю точно два проекта, которые вы покинули, это призм и мартон, это штука для подгрейскуэля, которая позволяет использовать его как такую документную базу данных, если я правильно помню.
3994.08 4004.32 "Игорь Лабутин" Но интересный факт состоит в том, что когда первый проект пришел и сказал, давайте я хочу покинуть, выяснилось, что нет процедуры покидания.
4004.32 4007.60 "Игорь Лабутин" То есть, ну как-то не предусмотрели в документах, как выйти.
4007.60 4009.88 "Игорь Лабутин" Так выйти можно, а выйти нельзя.
4009.88 4010.88 "Игорь Лабутин" Напоминает Brexit.
4010.88 4014.20 "Игорь Лабутин" Да, и они, соответственно, сколько-то месяцев эту процедуру готовили, но сделали.
4014.20 4017.68 "Игорь Лабутин" И в итоге, да, проекты покинули.
4017.68 4027.48 "Игорь Лабутин" Значит, почему на самом деле все это началось, давайте я про это где-то, наверное, что-нибудь рассказывал, но просто чтобы все были в курсе, мало ли, что будет интересное происходить, давайте быстренько расскажу.
4027.48 4047.68 "Игорь Лабутин" Значит, действительно много проектов заджойнилось, они там получили какие-то плюшки, то есть на гитхабе, соответственно, фундейшн предоставлял им бота, который позволял для всех новых контрибьюторов сначала просить подписание лайсенс-агремента, contribution-лайсенс-агремента, и это было прямо очень удобно, мейн-тренеры очень радовались.
4047.68 4059.68 "Игорь Лабутин" Второе, что предоставляла DotNet Foundation, это сертификаты для подписывания Nuget-пакетов, ну то есть не нужно было там платить денег, ничего, а как бы вот вам давали сертификаты и подписывайте ваши Nuget-ы.
4059.68 4108.80 "Игорь Лабутин" Вот, и было все хорошо и замечательно, до тех пор, когда не случилось нечто в, как я понимаю, это было, по-моему, в прошлом году, где-то в районе ноября, октября, не помню точно, но примерно так, в 21-м году, когда в каком-то из проектов внезапно обнаружилось, что, а это как раз в призме, по-моему, и было, что, мол, какой-то из мейн-тренеров, причем, который давно уже не занимался особо активным проектом, запушил принудительно коммит, который назывался там типа "нам нужно быть compliant с политикой reproducible builds" на Tenet Foundation, а это требовало внедрения некоторой зависимости, ну короче, получения новой зависимости на новый Nuget-пакетик.
4108.80 4125.80 "Игорь Лабутин" Активные мейн-тренеры пришли и сказали "не, ну погодите, надо же как бы превьюить, вообще мы не, у нас политика такая, что мы не берем лишнюю зависимость и как бы вот это вот нам нафиг не сдалось", на что тот, кто коммитировал, сказал "нет, политика выдают на Тенет Фондейшн, поэтому коммит нужно быть".
4125.80 4136.32 "Игорь Лабутин" В общем, это подняло довольно большую волну, прям огромную волну обсуждения, и народ пошел смотреть вообще, как бы, что происходит в репозиториях.
4136.32 4146.08 "Игорь Лабутин" И тут, в данном случае, как бы коммитер действительно имел права мейн-тренеры, и поэтому как бы мог запушить коммит прямо сразу, но тут начало выясняться интересное.
4146.08 4159.20 "Игорь Лабутин" Для того, чтобы вот этот CLI-бот, да, Contribution License Agreement-бот имел возможность нормально работать, этому боту должны были быть выданы, вроде как этому боту должны были быть выданы админские права в репозитории.
4159.20 4170.72 "Игорь Лабутин" Ну, чтобы он на самом деле после подписания имел право у пользователя поменять, я так понимаю, статус на коммитера, да, и дать ему возможность, собственно, закоммитить код, pull-requests.
4170.72 4197.60 "Игорь Лабутин" И тут началось, выяснилось, что используя этого бота, Donut Foundation, часть проектов, все они, все не знаю, но по крайней мере часть, тех если аппы перенес, во-первых, в новую организацию, в типа GitHub Enterprise, ну и как бы начал, да, местами пушить какие-то правила, там типа коммитить что-то, ну в общем, всячески использовать админские права вообще совсем не для того, зачем их давали.
4197.60 4201.84 "Игорь Лабутин" Вот это подняло новую волну, большого, значит, гнева.
4201.84 4238.28 "Игорь Лабутин" И ко всему этому еще добавилась статья бывшего представителя, ну как, члена совета директоров, наверное, или как там это называется, все у них это выборная организация, там выбирается несколько человек, board of members, или board of directors, точнее это называется, то есть типа директора по разным направлениям, и вот один из них ушел раньше срока и написал статью, где как бы немножко рассказал про внутреннюю кухню, про то, что все на самом деле глухо, там никаких как бы каких-то инициатив и действий изнутри предпринять тоже не получается, короче, такая непонятная организация, непонятно вообще зачем существует.
4238.28 4251.84 "Игорь Лабутин" В общем, такие вопросы стали задавать вообще все, то есть, например, тот же, там, хорошую статью написал Aaron Standard, у которого Akka.net тоже в фундейшн, насколько я помню, про то, что ну вообще, а зачем вы тогда нужны, там вот это все.
4251.84 4260.92 "Игорь Лабутин" Ну и вся эта конструкция потихонечку начинала как-то куда-то рушиться, главный значит, подобный фундейшн ушел в итоге со своего поста после всех этих событий.
4260.92 4269.00 "Игорь Лабутин" Я так понимаю, что какого-то прям вот суперглавного так до сих пор и не назначено, то есть совет директоров там есть, но не более того.
4269.00 4281.44 "Игорь Лабутин" И дальше начался процесс про то, что мол, ну ладно, окей, давайте попробуем быть более открытыми и попытаться, собственно, добиться того, чего от нас хочет комьюнити, вообще зачем мы создавались.
4281.44 4299.88 "Игорь Лабутин" Было даже организовано несколько видео встреч, где можно было поговорить напрямую с представителями DotNet Foundation, а вообще она такая достаточно закрытая организация с точки зрения, что непонятно, что делают, но периодически там раз в месяц, раз в два месяца публикуют какой-нибудь отчет, где написано, ну, мы работаем над этим, примерно так.
4299.88 4302.80 "Игорь Лабутин" То есть там какой-то сильно большой конкретики так и нету.
4302.80 4310.84 "Игорь Лабутин" Вот, то есть такое ощущение, что это такая большая бюрократическая организация, которая занимается только большой бюрократической работой, какой-то полезной деятельности особо не делает.
4310.84 4321.16 "Игорь Лабутин" Вот, я в целиком эти видосики не смотрел, но там комменты на ютубе, которые я видел, и комменты в твиттере по поводу этих встреч были про то, что как бы, ну, бесполезные по сути.
4321.16 4322.88 "Игорь Лабутин" То есть ничего принципиально нового мы так и не узнали.
4322.88 4339.20 "Игорь Лабутин" Вот, и в результате вот этот весь набор действий, то есть по сути есть некоторая организация, где есть некоторый совет директоров, причем по правилам один из этих директоров обязательно назначается Microsoft, и мы обязаны быть сотрудниками Microsoft.
4339.20 4360.76 "Игорь Лабутин" То есть, ну, очевидно, что Microsoft нужно какое-то влияние, какой-то практически пользы она непонятно приносит ли, то есть сертификаты, ну да, но по отзывам народ пишет, что там по месяцу могли лежать как бы все эти GitHub actions, которые правильно подписывают, и просто быть недоступными, и ты не можешь ничего релизить.
4360.76 4384.88 "Игорь Лабутин" Вот, народ посчитал даже какой-то проект, что мол, за те там три года, которые, или четыре года, которые они были в фондейшне, короче, они выпустили релизов, ну, грубо говоря, за срок как бы три года, то есть по статистике то, что они раньше выпускали три года по количеству, по объему фич и так далее, сейчас они стали выпускать за четыре, потому что там периодически на месяц, на два ложится полностью инфраструктура выпуска собственной версии.
4384.88 4407.08 "Игорь Лабутин" Вот, и поэтому все это, собственно, сейчас потихонечку как-то, то есть про тот фондейшн я, честно говоря, давно не слышал в каком-то паблик пространстве, то есть там периодически какие-то новости где-то проскакивают, но не более того, какой-то движухи от них особо и не видно, и даже, так сказать, всю бюрократическую организацию показывает забавный факт.
4407.08 4424.36 "Игорь Лабутин" Наступил сентябрь, у них был на их сайте, вот если вы сейчас пойдете на dotnet foundation, ну, может быть, к моменту выпуска подкаста они уже что-то пофиксили, ну вот, если я буквально вчера перед записью подкаста заходил, прошла уже неделя сентября, у них сертификат на сайте, что-то повязанное, был до 31 августа.
4424.36 4427.80 "Игорь Лабутин" Им где-то 1 или 2 сентября написали, чуваки, у вас вообще сертификат протух.
4427.80 4430.40 "Игорь Лабутин" Они такие, о да, мы работаем над этим.
4430.40 4433.44 "Игорь Лабутин" Вот 7-8 сентября они до сих пор работали над этим.
4433.44 4445.56 "Игорь Лабутин" Хотя, казалось бы, если у вас есть инфраструктура, подписи, вы предоставляете сертификаты, куча проектов, ну как бы положить TPS сертификат на сайт статически, кажется, небольшая забота.
4445.56 4448.60 "Игорь Лабутин" Но до сих пор работают над этим.
4448.60 4452.16 "Игорь Лабутин" Сайт все еще нормально не открывается, пожалуй, на TPS.
4452.16 4459.80 "Игорь Лабутин" Также такая вот история, попытки как-то поддержать open-source в дотнет-мире пока непонятно.
4459.80 4464.32 "Игорь Лабутин" Двигаются куда-то не туда именно те, которыми руководит Майкрософт.
4464.32 4478.12 "Игорь Лабутин" То есть понятно, что отдельные проекты как-то пытаются за счет GitHub sponsorship, за счет Патреона, за счет лицензий платных для больших компаний, смотри, там, Identity Server и Duendo, то, что они превратились.
4478.12 4485.92 "Игорь Лабутин" Как-то пытаются монетизировать то, что они делают, а вот дотнет фаундейшн пока, кажется, не очень летит.
4485.92 4498.96 "Анатолий Кулаков" Ну да, очень обидно, потому что когда эта вся штука зарождалась, проект был довольно амбициозный, там, кучковались и продвигали его в первые годы вообще очень такие знаменитые люди, там, и Хансельманы, и прочие такие микрософтовские лица.
4498.96 4508.80 "Анатолий Кулаков" И не только, кстати, микрософтовские, активные open-source комьюнити лица, там, тот же самый Akinjin претендовал на директорство в дотнет фаундейшне.
4508.80 4511.32 "Анатолий Кулаков" В общем, было очень много всего интересного.
4511.32 4517.84 "Анатолий Кулаков" И с той волной, как затягивалось туда всякие различные крутые проекты, казалось, что направление было выбрано правильно.
4517.84 4520.84 "Анатолий Кулаков" Но здесь случилось что-то странное, что-то не то.
4520.84 4523.08 "Анатолий Кулаков" В общем, обидно, обидно, безусловно.
4523.08 4534.32 "Анатолий Кулаков" Но с другой стороны, может быть, как раз-таки на руинах Микрософта вот это сообщество, которое видит, что объединяться можно и это какие-то бенефиты может давать, может оно построить свою организацию.
4534.32 4541.72 "Анатолий Кулаков" И мне кажется, такой формат был бы намного интереснее, когда сообщество построило свою организацию, а Микрософт тупо туда бы донатил, если бы он хотел.
4541.72 4559.76 "Анатолий Кулаков" И уже непосредственно структурой, деньгами, помощью, еще какими-то другими ресурсами распоряжалось уже то активное сообщество, те активные люди, которые это уже построили, которые понимают, как это нужно работать и что нужно упортить с проектом, что нужно авторам, что они вообще хотят от такой организации.
4559.76 4563.32 "Игорь Лабутин" Да, посмотрим, появится ли когда-нибудь такое.
4563.32 4564.32 "Игорь Лабутин" Будем надеяться.
4564.32 4575.84 "Анатолий Кулаков" К сожалению, у нас в Дотнете как-то с опенсорсом все очень плохо, если это не Микрософт, поэтому будем надеяться, что все-таки мы консолидируемся, заберемся и прорвемся.
4575.84 4587.40 "Игорь Лабутин" Ну, у нас с опенсорсом не то, что прям плохо, он у нас есть, он у нас хорошо живет, в смысле, что есть проекты, которые хорошо живут, но он, да, он как бы очень раздробленный.
4587.40 4602.64 "Анатолий Кулаков" Ну, вот давай я тебе тогда еще одну статьечку добросим, чтобы примерно у меня есть немножко контраргумент на твое утверждение, ну, чтобы просто так не растекаться, нам нужна для этого хорошая статья.
4602.64 4611.16 "Анатолий Кулаков" И хорошая статья у меня есть, потому что Микрософт анонсировала новую интересную толзень, про которую обязательно мы должны знать, куда же без этого.
4611.16 4617.84 "Анатолий Кулаков" Анонсировала она встроенную поддержку контейнеров прямо в Дотнет СДК, что бы это могло значить?
4617.84 4618.84 "Анатолий Кулаков" Давайте разбираться.
4618.84 4639.00 "Анатолий Кулаков" Итак, контейнеры - это такая клевая штука, многим она известна под названием докер-контейнеры, но докер - это не единственный движок, который умеет запускать контейнеры, и даже больше того, более того, это может быть самый популярный, самый старый движок, и от него многие продукты уже в последнее время сильно-сильно отказываются.
4639.00 4641.80 "Анатолий Кулаков" По особым причинам, может, разберем их как-нибудь в другой раз.
4641.80 4642.80 "Анатолий Кулаков" Контейнеры.
4642.80 4655.92 "Анатолий Кулаков" Но куда бы мы ни пошли, что контейнеры на данный момент - это сейчас самый удобный, самый простой, самый масштабируемый и самый поддерживаемый способ для распространения вашего приложения, в частности в клауд.
4655.92 4667.84 "Анатолий Кулаков" Ну, не обязательно в клауд, можно куда угодно, но это такой формат по сути дистрибутива, инсталлятора современного для ваших приложений, который позволяет решить множество проблем.
4667.84 4671.24 "Анатолий Кулаков" Опять же, это все тема про контейнеры, не будем ее здесь дотрагиваться.
4671.24 4695.16 "Анатолий Кулаков" .NET, в принципе, прекрасно поддерживает контейнеры, там буквально год назад у него был большой импруманс по C-групп-лимитам, мы его тоже обсуждали, и вообще, в принципе, .NET очень сильно смотрит на контейнеры, очень умеет учитывать все вот эти ограничения, применять динамических garbage-коллекторов, изменять хипы под нужды там памяти и прочее, прочее, прочее.
4695.16 4697.16 "Анатолий Кулаков" Здесь все у нас хорошо.
4697.16 4702.68 "Анатолий Кулаков" Дальше, на данный момент, что же все-таки изобрел Microsoft?
4702.68 4711.12 "Анатолий Кулаков" Он позволяет вашему приложению создать контролируемую версию, то есть создать Docker Image с помощью одной единственной команды, .NET Publish.
4711.12 4718.36 "Анатолий Кулаков" Но эта штука требует .NET 7, Preview 7 или выше, то есть это совсем свежачок, если вы захотите попробовать.
4718.36 4720.12 "Анатолий Кулаков" Как это все выглядит?
4720.12 4722.48 "Анатолий Кулаков" Прямо можно из командной строки продемонстрировать.
4722.48 4730.44 "Анатолий Кулаков" Во-первых, как всегда, вы делаете .NET U, допустим, MPC проект, создаете это, все из командной строки выполняется, создается новое MPC приложение.
4730.44 4739.68 "Анатолий Кулаков" Дальше вам необходимо добавить .NET Add Package, Microsoft.NET Build Containers, это специальная библиотека, в которую вы временно можете добавить в свой проект.
4739.68 4752.20 "Анатолий Кулаков" И следующая команда, вы можете сделать просто-напросто .NET Publish, указать там операционную систему Linux, указать архитектуру x86 и указать специальный флажок профиля.
4752.20 4757.42 "Анатолий Кулаков" И в этом профиле специальное название, которое называется Default Container.
4757.42 4769.84 "Анатолий Кулаков" Как только .NET Publish почувствует название вот этого профиля, он автоматически запустит вот этот новый фишку, новый инструмент, который соберет для вас Docker Container абсолютно прозрачно.
4769.84 4791.68 "Анатолий Кулаков" И уже следующей командой, через несколько секунд, вы можете делать Docker Run и запускать непосредственно свой контейнер с названием вашего приложения у себя на машине и после этого зайти на Localhost, на порт, который вы определили и в браузере убедиться, что ваше MVC-приложение, которое вы создали буквально 5 секунд назад, работает и отображается, и запущено, и прекрасно себя чувствует.
4791.68 4801.84 "Анатолий Кулаков" Вот такая полная интеграция, немножко еще допилили вот эту последнюю часть, когда мы можем запаблишить контейнер и сразу же его попробовать в деле.
4801.84 4802.84 "Анатолий Кулаков" Это очень удобно.
4802.84 4809.08 "Анатолий Кулаков" Теперь давайте подробнее разберемся, зачем все это было нужно, как все это реализовано и куда все это движется.
4809.08 4811.52 "Анатолий Кулаков" Прежде всего, поглубже, зачем это было нужно.
4811.52 4818.40 "Анатолий Кулаков" Как я уже сказал в начале, контейнеры – это сейчас самый великолепный путь, который есть для того, чтобы поставлять ваше приложение.
4818.40 4832.72 "Анатолий Кулаков" Не сказать, что он там оптимален для всех случаев и все такое, но, к сожалению, индустрия сложилась именно так, что выигрывают часто не самые оптимальные, самые красивые, самые понятные, а самые спопсованные и маркетологами обласканные.
4832.72 4836.20 "Анатолий Кулаков" Docker и, соответственно, вместе с ним контейнеры – это как раз тот ситуаций.
4836.20 4851.00 "Анатолий Кулаков" Ну, нужно сказать, что результат не самый плохой, не самый страшный с того, что могло бы быть, поэтому контейнеры мы ругать сегодня не будем, а просто подробнее разберемся, как они работают на том уровне понимания, достаточном для обсуждения этой фишки.
4851.00 4857.52 "Анатолий Кулаков" Итак, самым популярным способом писания контейнера является Dockerfile.
4857.52 4870.20 "Анатолий Кулаков" Это файл специального формата, который рассказывает, каким образом вам собрать этот контейнер, откуда взять ресурсы для его наполнения, с какими-то дополнительными библиотеками установить в этот контейнер, как запускать ваше приложение.
4870.20 4872.40 "Анатолий Кулаков" В общем, все это описано в Dockerfile.
4872.40 4883.92 "Анатолий Кулаков" Для того, чтобы получить из Dockerfile непосредственно сам Docker Image, который будет запускаться, вам необходимо еще произвести операцию Docker Build, то есть собрать.
4883.92 4888.96 "Анатолий Кулаков" Для того, чтобы собрать Docker контейнер, у него есть такое понятие, как Docker Build Context.
4888.96 4901.36 "Анатолий Кулаков" На самом деле, Docker Build Context – это довольно примитивная фишка, то есть это можно представить в виде папочки, в которой лежит в основном Dockerfile, а если быть точным, то в котором собирается этот Dockerfile.
4901.36 4914.64 "Анатолий Кулаков" В этой папочке обычно, например, в .NET очень часто складывают прямо в root Dockerfile, и рядом с этим Dockerfile складывают там папочку sources, какие-нибудь проекты, SLN.
4914.64 4918.32 "Анатолий Кулаков" В общем, это все является по сути Docker Build Context.
4918.32 4931.32 "Анатолий Кулаков" Но если вдруг Dockerfile лежит не в той папочке, в которой лежит solution, или вы билдите не из той папочки, в которой лежит solution, то здесь у вас уже могут быть кое-какие спецэффекты.
4931.32 4941.68 "Анатолий Кулаков" Например, если Dockerfile положить чуть пониже, например, в какой-нибудь проект в вашем solution и заставить его оттуда билдиться, то уже могут быть артефакты.
4941.68 4958.40 "Анатолий Кулаков" В частности, например, может не подтянуться директорий props, который лежит у вас на уровне выше, потому что на уровне выше его там ищут всякие .NET тулзы, а вот Docker Build он будет искать только в той папочке, в которой мы сказали билдить.
4958.40 4966.84 "Анатолий Кулаков" Также на уровнях выше у вас могут находиться NuGet конфиги, там же могут у вас находиться Editor конфиги, Git конфиги.
4966.84 4973.40 "Анатолий Кулаков" В общем, любая эротичная структура конфигов, которая подразумевает нахождение не на одном уровне, а возможность перетирания на нескольких уровнях.
4973.40 4978.16 "Анатолий Кулаков" Соответственно, билд ваш будет зависеть от этого уровня.
4978.16 4984.28 "Анатолий Кулаков" Docker Build не такой умный, он не ходит по всем уровням и не ищет все возможные конфиги, которые существуют в мире.
4984.28 4986.56 "Анатолий Кулаков" Это не его задача, он этого делать не собирается.
4986.56 4999.20 "Анатолий Кулаков" И вот это несоответствие между тем, как ведет себя настоящий .NET билд, который все-таки ходит и ищет определенные конфиги, которые он знает, и вот этот билд-контекст в самом докере может породить кучу проблем.
4999.20 5004.00 "Анатолий Кулаков" В сложных проектах это довольно-таки нередкая штука.
5004.00 5011.64 "Анатолий Кулаков" Проблемы эти обидны, потому что вся та информация, которая нужна для того, чтобы правильно все-таки собрать Docker Image, она уже есть в .NET билде.
5011.64 5019.72 "Анатолий Кулаков" То есть .NET билд, он умеет все эти зависимости, все эти конфиги подтягивать, собирать, анализировать, вытаскивать из них правильную информацию.
5019.72 5026.96 "Анатолий Кулаков" И единственное, что нужно было просто сделать, это каким-то образом передать это рантайму контейнера, который весь этот билд непосредственно производит.
5026.96 5030.40 "Анатолий Кулаков" То есть более гибкую связь между ними настроить.
5030.40 5039.44 "Анатолий Кулаков" И именно вот эта мотивация и послужила тем, что разработчики захотели встроить внутрь SDK нативное понимание именно Docker контейнера.
5039.44 5044.36 "Анатолий Кулаков" Как его создавать, как его собирать, какие перемены туда можно передать, а какие передать нельзя.
5044.36 5047.40 "Анатолий Кулаков" Что же у них в итоге получилось?
5047.40 5052.20 "Анатолий Кулаков" На самом деле контейнер состоит из двух основных частей, уже собранных.
5052.20 5056.12 "Анатолий Кулаков" Вот контейнер, после того, как его собрали, состоит из двух основных частей.
5056.12 5061.64 "Анатолий Кулаков" Первая часть – это JSON-конфигурация, которая включает в себя мета-информацию об этом контейнере.
5061.64 5067.88 "Анатолий Кулаков" Когда он был создан, кем был создан, через какие-то хэши, что там версии у него еще, с помощью которого какого-нибудь SDK он собирался.
5067.88 5071.08 "Анатолий Кулаков" В общем, такую техническую мета-информацию.
5071.08 5073.24 "Анатолий Кулаков" Это все засовывается в отдельный JSON-файл.
5073.24 5080.64 "Анатолий Кулаков" И вторая часть – это список Torbol архивов, которые как раз-таки воспроизводят файловую систему.
5080.64 5093.92 "Анатолий Кулаков" Потому что, по сути, это всего лишь навсего, если вы встречались с виртуальными машинами, то вся виртуальная машина – это просто-напросто диск, который лежит где-то у вас в виде файлика, его нужно просто-напросто запустить.
5093.92 5095.48 "Анатолий Кулаков" Такая же самая ситуация и здесь.
5095.48 5097.80 "Анатолий Кулаков" Всего лишь навсего – это файловая система в Torbol.
5097.80 5103.16 "Анатолий Кулаков" Это Docker Image, который просто лежит, и вот мета-информация, которая помогает его запустить.
5103.16 5104.16 "Анатолий Кулаков" Больше ничего.
5104.16 5108.28 "Анатолий Кулаков" Это такое упрощенное представление виртуальной машинки, грубо говоря.
5108.28 5125.64 "Анатолий Кулаков" И два этих потрясающих факта связывают нас с прошлым выпуском, где я напоминал вам, что в .NET 7 добавилась поддержка TAR-файлов и улучшилась поддержка TAR-стримов, которые позволяют с этими TAR-файлами оперировать.
5125.64 5143.68 "Анатолий Кулаков" И именно в этом формате как раз-таки и хранится весь Docker Image, что вообще открывает дверь для того, чтобы манипулировать имиджами, контейнерами с помощью софта, то есть программно, без всяких там специальных тулзов.
5143.68 5150.20 "Анатолий Кулаков" И, соответственно, уже в мире есть большое количество инструментов, которые это делают.
5150.20 5152.36 "Анатолий Кулаков" Правда, в других языках.
5152.36 5161.80 "Анатолий Кулаков" Возвращаясь к нашему примеру, например, подобный инструмент в языке Go на GitHub содержит несколько десятков тысяч лайков.
5161.80 5165.96 "Анатолий Кулаков" Там подобный инструмент на Java тоже зашкаливает у него лайков.
5165.96 5178.32 "Анатолий Кулаков" А такой же инструмент для .NET, который позволяет манипулировать контейнерами, который позволяет создавать их, правильно пушить и все в этом духе, на данный момент насобирал всего-навсего 38 звездочек.
5178.32 5182.24 "Анатолий Кулаков" То есть сравните там десятки тысяч лайков и вот 38.
5182.24 5186.80 "Анатолий Кулаков" Это примерно говорит о блеске и нищете open-source в .NET, как мне кажется.
5186.80 5189.20 "Анатолий Кулаков" Потому что по функциональности они довольно сравнимы.
5189.20 5194.12 "Анатолий Кулаков" По крайней мере, те базовые штуки, которые нужны, есть для всех платформ.
5194.12 5197.96 "Анатолий Кулаков" Но давайте немножко поближе.
5197.96 5201.44 "Анатолий Кулаков" Другой инструмент, про который я говорил на .NET, это называется Connet.
5201.44 5215.88 "Анатолий Кулаков" Это специальный инструмент командной строки, это global tool для .NET, который умеет манипулировать контейнерами для докера и очень глубоко связан и нежно понимает .NET приложение, естественно.
5215.88 5222.12 "Анатолий Кулаков" Его преимуществом является в том, что он может собирать локальные бинарники без установленного докера.
5222.12 5224.68 "Анатолий Кулаков" То есть для того, чтобы создать докер-имидж, ему докер вообще не нужен.
5224.68 5231.68 "Анатолий Кулаков" Он это делает сам вручную, зная его правильный формат и собирая сам все эти слои.
5231.68 5233.40 "Анатолий Кулаков" Также интересная у него штука.
5233.40 5247.20 "Анатолий Кулаков" Бывает, что вам нужно, если у вас большой какой-то проект, большое приложение, то изменения в одной библиотеке вы можете протолкнуть в отдельный слой докер-имиджа, не меняя при этом все остальные слои.
5247.20 5254.44 "Анатолий Кулаков" И это может занимать гораздо меньше времени и в определенных ситуациях, опять же, когда у вас огромные проекты, это очень-очень существенно.
5254.44 5262.40 "Анатолий Кулаков" Он может сократить выкладку, допустим, квик-фикса, не часы, может быть, дни его делать, а вот просто за секунды.
5262.40 5268.72 "Анатолий Кулаков" Потому что вы всего лишь на все модифицируете тот слой, где вот этот баг или где этот баг есть, или где этот квик-фикс нужен.
5268.72 5270.44 "Анатолий Кулаков" Тоже интересная вещь.
5270.44 5274.80 "Анатолий Кулаков" И на самом деле ему не нужны докер-файлы для того, чтобы собирать докер-имиджи.
5274.80 5279.60 "Анатолий Кулаков" Он берет всю информацию из проекта .NET, поэтому он хорошо понимает .NET.
5279.60 5285.24 "Анатолий Кулаков" В общем, и вот такие толзеньки, они есть и есть в каждом языке, есть в каждой платформе.
5285.24 5299.32 "Анатолий Кулаков" И Microsoft в своем стиле решил, опять же, убить эту ветку развития open-source в .NET, оно решило выпустить в SDK свою версию вот этой толзеньки, о которой мы сейчас с вами говорим.
5299.32 5315.36 "Анатолий Кулаков" И вот, соответственно, в .NET SDK у нас появилось вот такое решение, которое позволяет, прежде всего, бесшовно проинтегрироваться между существующей логикой построения вашего контейнера и текущим приложением.
5315.36 5325.60 "Анатолий Кулаков" Естественно, это все написано на C# и, естественно, прекрасно интегрируется со всем .NET SDK, потому что пилит его как раз таки команда самого непосредственно SDK.
5325.60 5336.12 "Анатолий Кулаков" Как же можно кастомизировать тот имидж, который получится в результате паблиша вашего приложения, если у нас нет все-таки докер-файла?
5336.12 5342.68 "Анатолий Кулаков" В обычной старой жизни докер-файл у нас, конечно, есть, и там он внутри себя обычно содержит кучу полезных параметров, которые можно настраивать.
5342.68 5344.00 "Анатолий Кулаков" Здесь докер-файла нет.
5344.00 5345.72 "Анатолий Кулаков" Откуда же браться с настройками?
5345.72 5349.36 "Анатолий Кулаков" Ну, например, вообще базовый имидж, из которого мы должны свой имидж собирать.
5349.36 5351.48 "Анатолий Кулаков" Непонятно, откуда брать теги?
5351.48 5352.48 "Анатолий Кулаков" Тоже непонятно.
5352.48 5355.08 "Анатолий Кулаков" Команда пошла незамысловатым путем.
5355.08 5363.20 "Анатолий Кулаков" Она берет все эти настройки, а оттуда же, откуда берет настройки все SDK команды из MSBuild.
5363.20 5366.56 "Анатолий Кулаков" MSBuild - это XML-файлик, в котором есть свойства.
5366.56 5368.04 "Анатолий Кулаков" Эти свойства очень гибкие.
5368.04 5369.56 "Анатолий Кулаков" Туда можно запихнуть все, что угодно.
5369.56 5373.40 "Анатолий Кулаков" У него уже понятна система расширений, у него понятна система переиспользований.
5373.40 5379.52 "Анатолий Кулаков" И вот, естественно, это самый прекрасный путь, к которому уже привыкли, куда засовывать эти настройки.
5379.52 5389.24 "Анатолий Кулаков" Например, если вам нужно поменять базовый образ, вы можете воспользоваться переменной, которую можно записать в C-proj файл, и базовый образ поменяется.
5389.24 5394.04 "Анатолий Кулаков" Кстати, по дефолту там стоят довольно умные базовые образы.
5394.04 5404.08 "Анатолий Кулаков" Например, он различает для ISP.NET, а там подставляет .NET ISP, ISP.NET, имидж для self-contained runtime debs, для всех остальных приложений просто .NET runtime.
5404.08 5408.48 "Анатолий Кулаков" Берет имиджи с сервера Microsoft, подставляет и обычно это работает.
5408.48 5421.60 "Анатолий Кулаков" Все эти имиджи по дефолту основаны на Debian операционной системе, которая самая совместимая, самая стабильная, ну, считается самая официальная из всех официальных имиджей, которые есть.
5421.60 5426.64 "Анатолий Кулаков" Естественно, если вы захотите, то подставьте Alpine или Ubuntu, то такие имиджи тоже Microsoft опубликуются.
5426.64 5436.64 "Анатолий Кулаков" Вам достаточно будет всего лишь навсего поменять переменку в вашем C-proj файле или, соответственно, в любом месте, которое подтягивается для переопределения свойств ваших MSBuild свойств.
5436.64 5438.84 "Анатолий Кулаков" Такая же ситуация, например, с имиджнеймом.
5438.84 5450.08 "Анатолий Кулаков" Он по дефолту берется из AssemblyName, но вы можете задать в MSBuild свойствах контейнер ImageName, и оно подставится в ImageName.
5450.08 5457.92 "Анатолий Кулаков" Точно так же версию, она берется по умолчанию из версии непосредственно проекта, который вы собираете, но легко переопределяется, если вам вдруг это нужно.
5457.92 5461.64 "Анатолий Кулаков" Очень много всего не хватает.
5461.64 5470.48 "Анатолий Кулаков" Безусловно, например, не все свойства таким образом можно выставить через MSBuild.
5470.48 5477.96 "Анатолий Кулаков" Пока нельзя поставить Entry Point, нельзя выставить переменные окружения, нельзя сделать лейблы, которые тоже очень часто используются в экосистеме докера.
5477.96 5486.80 "Анатолий Кулаков" И, соответственно, команда планирует это добавить в ближайшее время, то есть это все есть у них в родмапе, они над этим работают.
5486.80 5497.64 "Анатолий Кулаков" Но в первый preview просто это не вошло, поэтому если вы полноценно захотите почему-то заиспользовать этот инструмент, учтите, что поддерживается не все, поэтому потестить – да, использовать в продакшене – пока погодите.
5497.64 5500.20 "Анатолий Кулаков" Когда это вообще можно использовать?
5500.20 5510.92 "Анатолий Кулаков" Ну, во-первых, если вы занимаетесь локальной разработкой, то есть вам нужно локально запустить ваше приложение, и оно запускается почему-то там сложно с какими-то страшными аргументами, еще что-то.
5510.92 5530.16 "Анатолий Кулаков" Вы можете с помощью вот этих переменных достроить для себя вот это окружение, и с помощью одной единственной команды, там Publish, Linux, Arch64, Default Container – это все забилдить и получить локально понятный контейнер, который запускается одной командой или распространяется, если нужно, друзьям, отправляется по почте.
5530.16 5535.64 "Анатолий Кулаков" В общем, удобно для локальной отладки, для локального тестирования, удобно, прекрасно.
5535.64 5558.76 "Анатолий Кулаков" Если вас смущает вот эта команда Publish, OS, Linux, Arch64 и прочие вот эти вещи, то, опять же, в директоре build/props можно забить дефолтный профиль, дефолтную архитектуру, дефолтную операционную систему, и дальше с помощью простой команды .NET Publish, если вы хотите по умолчанию публиковать докер-имиджи, она у вас будет работать, она будет по умолчанию создавать вам имиджи, что тоже довольно удобно.
5558.76 5575.88 "Анатолий Кулаков" Естественно, это прекрасно встраиваться в любой CI-пайплайн, потому что любой CI-пайплайн в наше время поддерживает эту командную строку, и все, что можно изинтегрировать с помощью командной строки, соответственно, туда, везде, и попадает вот этот билд, потому что он полностью основан на командной строке.
5575.88 5586.12 "Анатолий Кулаков" Есть уже примеры, например, для GitHub Actions Workflow, есть уже примеры, как это внедрять в некоторые популярные, соответственно, CI, с этим тоже проблем быть не должно.
5586.12 5589.24 "Анатолий Кулаков" Что еще не доделано?
5589.24 5602.04 "Анатолий Кулаков" Как я уже говорил, это Initial Preview, это вообще первая версия, которую видела мир, соответственно, можно наблюдать за репозиториями, можно создавать issue, можно там участвовать, каким-то образом, скорее всего, в обсуждениях или, может, даже в разработках.
5602.04 5607.56 "Анатолий Кулаков" На данный момент поддерживается только Linux 64 инфраструктура, 64 имиджи.
5607.56 5614.60 "Анатолий Кулаков" Если вы захотите для Windows или вдруг не 64 архитектуру, то с этим пока подождите, это пока мы не умеем.
5614.60 5621.68 "Анатолий Кулаков" Дальше не поддерживается публикация в удаленной репозитории, потому что еще не заимплементировали поддержку аутентификации.
5621.68 5625.80 "Анатолий Кулаков" Аутентификацию сейчас можно эмулировать с помощью докера.
5625.80 5635.84 "Анатолий Кулаков" Если у вас там локально установлен докер, вы можете там сделать докер-логин, и, в общем, вот эта тулза, она подхватит конфигурационные файлы докера и сможет их использовать.
5635.84 5651.24 "Анатолий Кулаков" Но если вдруг у вас докер не установлен, а это, в принципе, тот сценарий, на который рассчитан этот инструмент, то есть оперировать с имиджами, а в частности, собирать их, паблишить их, каким-то образом модифицировать без установленного докера, то есть этот сценарий еще полностью не поддерживается.
5651.24 5652.96 "Анатолий Кулаков" Но вот какие-то части еще остались.
5652.96 5677.56 "Анатолий Кулаков" И, соответственно, те переменки, которые еще не поддерживаются, которые позволяют вам лучше настраивать образ, более гибко задавать переменные окружения, entry point, и лейблы, и вот дополнительные там какие-то еще аргументы, которые мы обычно привыкли видеть в докер-файле, то есть их многих нет, они все в планах, они обязательно будут и, скорее всего, к релизу нас ждет более или менее уже какой-то подтянутый, понятный инструмент.
5677.56 5683.32 "Анатолий Кулаков" В общем, ну и таким образом, да, будем внедрять больше докер-контейнеров в наши пайплайны и приложения.
5683.32 5698.48 "Игорь Лабутин" Звучит здорово, мне интересно, как обычно, когда мы что-то пишем в csproj файл, как это будет работать, когда у меня solutions куча csproj, то есть нужно ли мне, ну, скорее всего, буду просто паблишить один, и там он по зависимости подтянет все остальное, но…
5698.48 5708.44 "Анатолий Кулаков" Ну, если тебе нужно, тогда, ты же понимаешь, что теперь тесная интеграция с дотным билдом есть, то есть он способен понять все зависимости, которые там есть, как-то их скопировать, нужно переместить и как-то их учесть.
5708.44 5715.00 "Анатолий Кулаков" В общем, а если не нужно, то смотря на какой уровень ты его, этот докер-файл, где ты его создашь.
5715.00 5717.24 "Анатолий Кулаков" Может, в корне ты его создашь, он будет подтягивать вообще
5717.24 5721.24 "Игорь Лабутин" все проекты. Не, погоди, докер-файлик, мы же договорились, что докер-файл нам теперь не нужен.
5721.24 5734.32 "Игорь Лабутин" Сейчас-то как раз у нас используется, ну, условно говоря, solution, в нем десяток проектов, один из них – это главный вебапи, и в докер-файле понятно, что берется просто результат паблиша этого вебапи.
5734.32 5740.88 "Анатолий Кулаков" Ну, да, ты прав, если мы именно говорим про командную строку, то там нам, скорее всего, важен только solution.
5740.88 5743.20 "Игорь Лабутин" Вот, поэтому, ну, в общем, интересно посмотреть.
5743.20 5765.04 "Игорь Лабутин" Ладно, давай мы уже довольно долго сидим сегодня, мы закончим последней темой, я ее бы назвал короткой новостью, не знаю, у нас периодически встречаются всякие такие новости, которые не тянут на отдельный кусочек, но их тоже интересно быстренько обозреть, поэтому вот сегодня попробуем, посмотрим, как пойдет, напишите, чего вы про это думаете.
5765.04 5785.40 "Игорь Лабутин" Новость номер раз, дотнет кор 3.1, если вы все еще до сих пор на нем, а это LTS, помните, что в декабре 22 года он перестанет быть поддерживаемым, и единственной поддерживаемой версией станет дотнет 6, поэтому у вас есть еще там 3-4 месяца, чтобы выразиться на дотнет 6 в поддерживаемый период.
5785.40 5788.40 "Игорь Лабутин" Ну, а дальше уже… Ну, то есть, поддерживаемый единственным LTS, да?
5788.40 5791.68 "Игорь Лабутин" Да, единственным LTS, так а, ну, а все остальное…
5791.68 5796.68 "Анатолий Кулаков" Все только поддерживаемое, все остальное тоже поддерживаемое, то есть не на такой большой временной промежуток.
5796.68 5809.44 "Игорь Лабутин" Ну, правильно, поэтому у пятерки он уже закончится, а ну хорошо, с семерки будет поддержан пока еще, да, можно на семерку сразу апгрейдиться, а потом уже на восьмерку, так что… Но если LTS, то шестерка.
5809.44 5820.84 "Игорь Лабутин" Вот, дальше, Maui, если вам интересно Maui, то посмотрите новую книжку, на Docs.Microsoft.com вышла новая книжка, которая гордо называется The Enterprise Application Patterns Using Dotnet Maui.
5820.84 5822.84 "Игорь Лабутин" Это… Естественно, бесплатно.
5822.84 5825.84 "Игорь Лабутин" Есть PDF, есть не PDF.
5825.84 5829.88 "Игорь Лабутин" Это, по сути, некоторый гайд про то, как пользоваться Maui.
5829.88 5841.84 "Игорь Лабутин" Они взяли приложение eShop and Containers, которое мы уже много раз упоминали, и не только мы, ну, это популярный, так сказать, референсный пример сейчас, и там есть три референсных фронтенда.
5841.84 5857.84 "Игорь Лабутин" Один стандартный на MVC, SPNetCore, один это SPA на Angular, и вот добавился третий, это теперь Maui приложение, которое поддерживает iOS, Android, macOS и Windows 10 и 11 в качестве клиентского приложения.
5857.84 5864.60 "Игорь Лабутин" Поэтому посмотрите, там прям, ну, обычно eShop and Containers написано довольно неплохо, так что, скорее всего, Maui и часть она тоже неплохая.
5864.60 5868.72 "Игорь Лабутин" Ну и в книжке, скорее всего, тоже много чего полезного.
5868.72 5869.72 "Игорь Лабутин" Дальше.
5869.72 5874.12 "Игорь Лабутин" Новость номер следующая — это .NET и Ubuntu.
5874.12 5914.84 "Игорь Лабутин" Если вам нужно было поставить .NET на Ubuntu, нужно было либо добавлять источники, ну, микрософтские репозитории в качестве источников для APT, либо как-то просто качать там zipчик, ну, или не zip, а tar.gz, понятное дело, то теперь можно, начиная с Ubuntu 2.04, можно просто сказать apt install .NET 6, и вам поставится настоящий натуральный .NET из родного, так сказать, источника самой Ubuntu, где Canonical тщательно следит за всякими секьюритами, патчами и так далее, и обновляет все это дело параллельно с Microsoft, насколько я понимаю, в своем репозитории.
5914.84 5921.36 "Игорь Лабутин" Также доступны, в том числе, оптимизированные имиджи с Ubuntu.
5921.36 5926.08 "Игорь Лабутин" Пока все только и на это x64, но ARM64 тоже скоро будет.
5926.08 5933.72 "Игорь Лабутин" Так что, если вы разрабатываете на Ubuntu, то прям, или деплойте туда, то apt install теперь вам в помощь.
5933.72 5935.56 "Игорь Лабутин" И последняя новость — это Visual Studio.
5935.56 5939.36 "Игорь Лабутин" Мы уже рассказывали про Visual Studio 17.3 для винды.
5939.36 5955.24 "Игорь Лабутин" Как-то новость про такую же студию, про Mac вышла чуть-чуть позднее, чем мы записывали подкаст, поэтому она не попала в выпуск, но мы вот наверстываем упущенное и рассказываем, что вышла Visual Studio for Mac 17.3, и это не ошибка.
5955.24 5958.88 "Игорь Лабутин" Версий 17.1 и 17.2 их не было и не будет.
5958.88 5963.60 "Игорь Лабутин" Сделано это для того, чтобы синхронизировать версии, иначе большая путаница возникает.
5963.60 5973.08 "Игорь Лабутин" Там завезли поддержку User Secrets, это на самом деле мне кажется важно, если вы разрабатываете какое-нибудь ASP приложение или любое другое приложение, где вам нужны секреты.
5973.08 5979.80 "Игорь Лабутин" User Secrets — это удобный механизм для работы с ними, чтобы не закомитить случайно ничего в репозитории.
5979.80 5989.64 "Игорь Лабутин" Добавились новые CodeFixes, еще немножко окошечек переписали на NativeUI, добавили, они это называют Initial Support for Individual Apple Developer Account.
5989.64 5998.06 "Игорь Лабутин" Я не занимаюсь разработкой PDA и iOS, поэтому деталей не скажу, но тем не менее.
5998.06 6018.64 "Игорь Лабутин" Параллельно с 17.3 вышла 17.4 Preview 1, там есть MAUI Support, там есть Scaffolder для Minimal API, там есть очень прикольная штука, это такой визарт, где можно сказать, я хочу значит приложеньку с авторизацией, слоем репозиториев и моделями, или там без слоя репозиториев.
6018.64 6026.88 "Игорь Лабутин" Дальше он спросит, а как назвать типа, или куда положить классы, значит репозитория в классы моделей и контроллеров, и после чего сгенерит вам проект.
6026.88 6032.76 "Игорь Лабутин" Прям ну такой под креншотиком удобная штука, не знаю, надо пробовать.
6032.76 6049.32 "Игорь Лабутин" И последнее — это в дебаге развезли и ModulesView, тоже полезная кстати вьюшка, когда нужно посмотреть, какие длейли загрузились, ручками прогрузить символы например, или понять, почему символы не грузятся, это все через ModulesView можно делать в большой студии, вот теперь можно и в маковской версии.
6049.32 6056.96 "Игорь Лабутин" Ну вот примерно так, 4 небольших новости, так что на этом мы будем на сегодня заканчивать.
6056.96 6082.00 "Игорь Лабутин" Мы сегодня посмотрели на Performance Improvements, на C# 11, на Rider2022.2, на то, как мы переезжаем с Ease на Kestrel C#, узнали, что такое .NET Foundation и почему оттуда все валят, как мы теперь будем собирать Docker-контейнеры для .NET, то есть с помощью .NET SDK и немножко коротких новостей про Ubuntu, .NET и MAUI.
6082.00 6096.36 "Анатолий Кулаков" Отлично, вроде хорошо все покрыли, если у вас тут есть интересные темки, присылайте нам, пишите комментарии в ютубчике, распространяйте нас, шарьте своим друзьям и вообще всячески помогайте и любите нас, мы это хвалим, любим и ждем непосредственно.
6096.36 6101.80 "Анатолий Кулаков" На этом все, давай завершаться, всем спасибо, всем пока, с вами был Анатолий Кулаков.
6101.80 6104.88 "Игорь Лабутин" И Игорь Лабутин, это был 57-й выпуск радио .NET.
6104.96 6105.48 "Игорь Лабутин" Пока.
6105.48 6120.48 None [музыка]
