0.00 11.28 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер 115.
11.28 13.96 "Анатолий Кулаков" В студии я постоянно ведущий – Анатолий Кулаков.
13.96 14.96 "Игорь Лабутин" И Игорь Лабутин.
14.96 15.96 "Игорь Лабутин" Всем привет.
15.96 18.96 "Анатолий Кулаков" А также нас поддерживают наши блестящие помогаторы.
18.96 19.96 "Анатолий Кулаков" Представляю.
19.96 30.84 "Анатолий Кулаков" Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Шевченко Антон, Ольга Сергеевна Бондаренко, которая слушает наши выпуски только исходя из названия.
30.84 34.12 "Анатолий Кулаков" Я вообще не знал, что их кто-то читает, оказывается, есть и такие люди.
34.12 44.60 "Анатолий Кулаков" А также Сергей Краснов, Константин Ушаков, Постарнаков Андрей, Дмитрий Сорокин, Дмитрий Павлов, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Лазарев Илья, Тимофей и Виталий.
44.60 46.92 "Анатолий Кулаков" Спасибо большое, друзья, что поддерживаете наш
46.92 47.92 "Игорь Лабутин" подкаст.
47.92 55.20 "Игорь Лабутин" А нас продолжает поддерживать компания Altenar, которая разрабатывает масштабируемые надежные решения, которыми используются по всему миру.
55.20 70.88 "Игорь Лабутин" В компании, конечно же, используются дотнеты C#, и все это для того, чтобы работал высоконагруженный риэлтайм приложение, ну или квазириэлтайм, понятное дело, что же мы еще пишем на C#.
70.88 83.08 "Игорь Лабутин" В компании используется английский язык, потому что компания международная, вы можете попробовать различные облачные платформы, если вам это интересно, поработать даже, может быть, в европейском офисе.
83.08 98.76 "Игорь Лабутин" Кроме того, ребята делятся опытом, проводят митапы, и вот буквально скоро, 29 мая, в Питере будет митап, где мы обсудим логирование в лице серилога и аппровал тесты, чтобы это не значило, приходите посмотреть.
98.76 110.04 "Игорь Лабутин" Если вы не в СПБ, то есть возможность посмотреть все онлайн, ссылка для регистрации будет в описании, ну и ссылка на телеграм-канал тоже, конечно же, будет в описании.
110.04 119.40 "Анатолий Кулаков" Ну что ж, как-то мы запраздновались, в принципе, да, майские праздники были, немножко мы отвалились, ну и пользуясь случаем, всем с Днем Великой Победы.
119.40 122.56 "Анатолий Кулаков" Отдохнули, наели шашлычков, надышались весенним воздухом.
122.56 125.76 "Анатолий Кулаков" Пора бы посмотреть, что нас там порадовало в мире дотнета.
125.76 134.52 "Игорь Лабутин" Да, Microsoft не спали, Microsoft работали, пока мы отдыхали, и выкатили нам дотнет превью 4, дотнет 10, конечно же, превью 4.
134.52 142.52 "Игорь Лабутин" Как обычно, пробежимся по разным всяким кусочкам, но их не так много для того, чтобы делать какой-то супер большой обзор.
142.52 144.60 "Игорь Лабутин" Тоже, видимо, немножко отдыхали.
144.60 146.24 "Игорь Лабутин" Поехали, как обычно, по порядку.
146.24 147.24 "Игорь Лабутин" Библиотеки.
147.24 165.88 "Игорь Лабутин" В основном, там два, по сути, больших изменения, одно изменение касается Activity, то есть, напомню, что это механизм, который позволяет вам работать со всякими спанами и всячески ассоциировать какие-то выполняемые кусочки кода с некоторыми ивентами, метриками и чем угодно.
165.88 188.12 "Игорь Лабутин" Теперь есть такая штука, как Out of Proc Trace Support, то есть, позволяет, вы можете на самом деле собирать и отправлять трейсы как бы out of process, то есть, они собираются в одном процессе, а дальше, вот когда они обрабатываются out of proc, вы туда теперь можете допихивать еще ивенты и линки.
188.12 196.12 "Игорь Лабутин" Что бы это ни значило, я что-то как-то с линками никогда не работал, поэтому, если интересно, посмотрите в описании в деталях.
196.12 199.20 "Игорь Лабутин" Опять же, не забывайте, что это превью, и все может еще куда-нибудь откатиться.
199.20 210.16 "Игорь Лабутин" И в Trace Sampling теперь можно сделать Rate Limiting, ограничить количество корневых Activity в секунду, если вам почему-то не хочется трейсить все подряд.
210.16 232.92 "Игорь Лабутин" А второе большое изменение — это в API-шках работы с zip-ами, там теперь добавилось, почти для всех методов добавились async-версии, то есть, всякие create from directory async, extract to directory async, create async, extract to file async, в общем, все-все-все-все, оно теперь есть async, что, в общем, логично, потому что это работа с I/O, странно, что они не были асинхронными раньше.
232.92 235.92 "Игорь Лабутин" Это то, что касается библиотек.
235.92 265.80 "Игорь Лабутин" В Runtime продолжается работа над escape-анализом, добавили теперь следующую штуку, если у вас есть структура, значит, напомню, если у вас были структуры, и у вас структуры состояли из примитивных условных типов, то есть какие-нибудь int, double и прочее, то есть не ссылки на какие-то классы, на референсные типы, то JIT умел, научился разделять такую структуру и раскладывать ее по регистрам стека, не задействуя heap никак вообще.
265.80 277.48 "Игорь Лабутин" А также, что, впрочем, это не так сложно, потому что это структура, как известно, структуры хранятся на стеке, но то же самое он научился делать с классами, вот.
277.48 297.92 "Игорь Лабутин" Но теперь можно сделать так, что если у вас есть структура, у которой есть ссылки на классы, но есть доказательство, что это все никуда не утечет, то такие классы тоже могут быть разложены по стеку, по полям и не аллоксироваться в heap.
297.92 310.92 "Игорь Лабутин" Короче, потихонечку escape-анализ улучшается, улучшается и улучшается, и надо будет все-таки собраться с мыслями и обозреть какую-нибудь нормальную статью на эту систему, у нас есть в запасе, но что-то у меня не доходят руки нормально в это все вчитаться.
310.92 316.04 "Игорь Лабутин" Кроме того, поменялись немножко правила inlining.
316.04 334.24 "Игорь Лабутин" Опять же, мы со времен старого-старого доброго .NET, фреймворка, не помню уж каких версий, знаем и твердо помним, что если у вас метод очень большой, то он, скорее всего, не заинлайнится, если в вашем методе есть выбор с исключением, какой-нибудь try_finally, то он точно не заинлайнится, ну и так далее.
334.24 368.52 "Игорь Лабутин" Так вот, теперь за счет того, что, во-первых, если у нас метод, который возвращает массив, допустим, небольшой, раньше по каким-то там эвристикам не inlined, то сейчас может иметь смысл его заинлайнить, потому что джит научился какому-никакому на escape-анализу, и поэтому из-за этого может быть выгодно, на самом деле, заинлайнить метод и return value тогда не класть в heap, а смочь обработать прямо на стэке.
368.52 380.72 "Игорь Лабутин" Поэтому эвристики немножко подкрутили, и теперь лучше инлайнятся методы, которые возвращают небольшие массивы, как раз таки, чтобы заиспользовать бенефиты, которые принес нам escape-анализ.
380.72 382.16 "Игорь Лабутин" Это с одной стороны.
382.16 401.64 "Игорь Лабутин" С другой стороны сделали изменения, которые теперь позволяют inlining методы try_finally, и так что это не сильно раздувает, ну и усложняет вызывающий метод, потому что обработка исключения теперь туда очень как-то гладко встраивается в обработку исключений вызывающего метода.
401.64 407.20 "Игорь Лабутин" В общем, try_finally теперь не препятствует для inlining.
407.20 408.20 "Анатолий Кулаков" Вот.
408.20 413.84 "Анатолий Кулаков" Теперь непонятно вообще, что на собеседованиях спрашивать, а тем более как на них отвечать с этими новыми нововведениями.
413.84 419.24 "Игорь Лабутин" Да, теперь надо это… как будет работать джит вообще непонятно.
419.24 432.76 "Игорь Лабутин" Кстати, джит раньше делал такую штуку, что если он понимал по каким-то своим юристикам, что этот метод не будет заинлайнен, то он его, ну, условно-виртуально помечал атрибутиком no_inlining для себя, чтобы потом больше на него не смотреть.
432.76 433.76 "Игорь Лабутин" Вот.
433.76 445.52 "Игорь Лабутин" Но на самом деле сейчас это становится, опять же, неактуальным из-за escape-анализа, потому что то место, откуда вызывается, может влиять на то, надо ли inlining этот метод.
445.52 448.64 "Игорь Лабутин" Ну, что делается с возвращаемым значением, например.
448.64 463.32 "Игорь Лабутин" И поэтому теперь джит поменен так, что если он на метод смотрит, но даже если он считает, что его inlining в этом конкретном месте не надо, он его не помечает теперь, условно-виртуально, атрибутиком no_inlining и будет на него смотреть еще раз потом, если вдруг зачем-то это потребуется.
463.32 475.92 "Игорь Лабутин" Так что, да, джит становится все более умным, это хорошо, но действительно наши веками накопленные знания про то, как ведет себя платформа .NET, становятся потихонечку неактуальными.
475.92 481.32 "Игорь Лабутин" Ну а мы как раз пытаемся их обновлять нашими рассказиками.
481.32 485.88 "Анатолий Кулаков" Да ужасно, но с каждым выпуском… что мы обновляем, что?
485.88 490.16 "Анатолий Кулаков" В некоторых случаях когда-нибудь это может случиться, а может и не случиться.
490.16 491.60 "Анатолий Кулаков" Как это можно отвечать на собеседованиях?
491.60 494.48 "Анатолий Кулаков" Не, ну мы добежим еще до какой-нибудь монументальной
494.48 502.68 "Игорь Лабутин" статьи, там можно… ну нет, если ты знаешь на собеседовании все юристики джита, ну, наверное, ты работал в команде компилятора джита.
502.68 508.52 "Анатолий Кулаков" Да, ты достойный для того, чтобы перекладывать джессоны как бы с места на место, да?
508.52 509.52 "Игорь Лабутин" Типа того.
509.52 512.32 "Игорь Лабутин" Вот это очень важно знать, как ты там работаешь.
512.32 523.52 "Игорь Лабутин" Мне тут попалась, кстати, статья, да, типа «как использовать CPU… а, как учитывать CPU каширование 1 или 2 при программировании на дотнете».
523.52 524.52 "Игорь Лабутин" Такой, что?
524.52 528.00 "Игорь Лабутин" Для еще более быстрого перекладывания джессонов.
528.00 542.52 "Анатолий Кулаков" Не, ну я вот вспоминаю, как бы дотнеты времен Акинчинов, Штейнов, Кокос, мы загонялись такими вещами, мы там смотрели, а этот код попадет в L1 кэш или в L2 кэш или что с ним будет, какие там тайминги, ну то есть люди смотрели, радовались, аплодировали.
542.52 545.28 "Анатолий Кулаков" Да, но использовали ли потом в работе, что-то я не уверен.
545.28 552.24 "Игорь Лабутин" Если ты не пишешь какой-нибудь супер-пупер там, не знаю, ну даже не high-load, я бы сказал, а какое-нибудь там число дробилки.
552.24 553.24 "Игорь Лабутин" Ну да ладно.
553.24 574.72 "Игорь Лабутин" Возвращаясь к джессоноперекладыванию SPNet, в SPNet Core и Blazor, на самом деле половина новостей вокруг SPNet про Blazor, то есть Blazor развивается, в нем довольно много чего изменяется, но для начала давайте пройдемся по тому, что не относится к Blazor, а именно System Text JSON обрел поддержку JSON-патчей.
574.72 593.36 "Игорь Лабутин" Теперь есть новый пакет, он называется Microsoft SPNet Core JSON-patch, вот это я кстати, что-то я сейчас вот смотрю на свои заметки, я не уверен, это я правильно скопировал или нет, но у меня записано, что он называется Microsoft SPNet Core JSON-patch System Text JSON, ну git package, может так и называется, фиг знает.
593.36 609.52 "Игорь Лабутин" Ну короче, в нем есть класс, который называется JSON-patch document от типа T, и у него есть ключевой метод, который называется apply_to, который собственно, ну, применяет то, что содержится в этом документе к объекту типа T.
609.52 645.40 "Игорь Лабутин" Вот не совсем полноценная замена тому JSON-patch, той JSON-patch поддержки, которая есть в Newton-софте, если вы ей пользуетесь, ну там всякие динамические типа не поддержаны, не знаю, кто этим пользуется, но возможно для сериализации JSON кто-то этим пользуется, но если вы хотите использовать, то вы делаете следующее, вы у JSON-сериалайзера вызываете метод deserialize, передаетесь туда JSON-patch document от нужного вам типа, и после этого говорите полученному patch-документу точка apply_to и передаете объекту, к которому нужно применить, он соответственно заапплает.
645.40 648.96 "Игорь Лабутин" В принципе, в минимальных примерах выглядит удобно, как это будет на практике, надо смотреть.
648.96 658.68 "Анатолий Кулаков" Слушай, ну вообще JSON-patch такая довольно страшная штука, потому что она отписана по-разному везде, а реализована еще более по-разному везде.
658.68 686.24 "Анатолий Кулаков" В общем, и как универсальный протокол обмена, которым себя позиционирует HTTP, внедрять туда JSON-patch всегда было довольно страшно, и во всех проектах, в которых я участвовал, мы игнорировали JSON-patch, то есть никогда его не реализовывали как раз по этой причине, что непонятно, что там тебе та сторона передаст, тем более, что она написана на другом приложении, и как ты у себя это применишь, а потом, когда ты обновишь у себя библиотеки или та сторона обновит у себя библиотеки, что после этого произойдет?
686.24 689.36 "Анатолий Кулаков" В общем, слишком много вопросов, чтобы на практике это юзать.
689.36 690.36 "Анатолий Кулаков" Понимаешь?
690.36 691.36 "Анатолий Кулаков" Поэтому не знаю, ты когда-нибудь это использовал?
691.36 715.52 "Игорь Лабутин" Да, у нас был пример, мы использовали JSON-patch в API, это была наша внутренняя API между двумя сервисами, по крайней мере, ну или между фронтом и сервисом, но там просто была суперсложная структура данных, которую либо надо было писать миллион методов для того, чтобы ее обновлять, каждый раз пересылать было достаточно долго и много, поэтому ради эксперимента запихали туда JSON-patch.
715.52 727.84 "Игорь Лабутин" В принципе, работало, но надо понимать, что мы контролировали обе стороны, сами же писали этот код, и поэтому это чисто такая вариация, по сути, нашего какого-то собственного протокола.
727.84 729.62 "Игорь Лабутин" Вот один раз было.
729.62 739.12 "Анатолий Кулаков" Да, если ты сам себе пишешь обе стороны, то там все равно, что ты выберешь, или JSON-patch, или свой собственный какой-то апплайер, да, тут, наверное, без разницы.
739.12 746.00 "Игорь Лабутин" Но это действительно был единственный раз, когда мы это использовали, когда я, по крайней мере, это использовал.
746.00 749.76 "Игорь Лабутин" Дальше, в minimal API добавили валидацию для рекордов.
749.76 752.52 "Игорь Лабутин" А чего, раньше не было, что ли?
752.52 755.36 "Игорь Лабутин" Чуть-чуть прям странно, но допустим.
755.36 761.70 "Игорь Лабутин" Внутри, да, в OpenAPI, с поддержкой OpenAPI Spec, добавилось некоторое количество фич.
761.70 779.64 "Игорь Лабутин" Напомню, что OpenAPI — это некоторые описания вашей API, которые вы можете разметить код, там, атрибутами, либо явным образом, там, как-то методы повызывать на minimal API описательные, и вам будет генерироваться автоматически Spec.
779.64 785.32 "Игорь Лабутин" Но, возможно, вам Spec в том автоматическом виде не полностью подходит, и тогда ее можно трансформировать.
785.32 791.96 "Игорь Лабутин" Это существует концепция трансформеров внутри библиотеки, которая отвечает за всю эту генерацию.
791.96 796.12 "Игорь Лабутин" Так вот, теперь из этих трансформеров можно догенерить кусочек прямо схемы.
796.12 797.12 "Игорь Лабутин" Именно прям генерить.
797.12 799.88 "Игорь Лабутин" Не обязательно трансформировать существующую, можно сгенерить новую.
799.88 802.28 "Игорь Лабутин" Ну, не знаю, зачем об этом, может быть, надо, но можно.
802.28 807.64 "Игорь Лабутин" А вот для этого есть метод, который называется get_create_schema_async.
807.64 815.00 "Игорь Лабутин" Ну и, соответственно, вы либо получаете какую-то готовую схему и ее трансформируете, либо вы просто генерите новую.
815.00 818.24 "Игорь Лабутин" Или вы ее дотрансформируете до того состояния, которое вам нужно.
818.24 836.80 "Игорь Лабутин" А, ну и еще добавилась улучшилась, точнее, поддержка XML-документации в том смысле, что OpenAPI теперь чуть лучше утаскивает, кто-то вообще интересно, как они это делают, XML-документацию к себе.
836.80 841.80 "Игорь Лабутин" Ну, видимо, source-генератор это умеет делать, поэтому да.
841.80 848.12 "Анатолий Кулаков" Да, наверное, так же, как и раньше, просто берут файлик XML из документации, который лежит возле проекта, да и все.
848.12 849.12 "Анатолий Кулаков" Ну, кстати, может быть, да.
849.12 854.40 "Игорь Лабутин" Ну, либо source-генератор, можно это сделать прямо во время компиляции, даже без XML-файлика рядом.
854.40 861.96 "Игорь Лабутин" А также добавили в генератор поддержку пропуска, как у них называется, problematic complex types.
861.96 875.40 "Игорь Лабутин" Короче, если вы наворотили какой-то такой тип, который OpenAPI генератор не в состоянии разобрать, то раньше он тупо падал и у вас не генерировалось вообще ничего, а теперь у вас генерится хоть что-то, но просто те кусочки метаданных, которые он не смог как-то обработать, ну, будут пропущены.
875.40 883.28 "Игорь Лабутин" Поэтому работать он будет на вид лучше, генерировать будет как бы схему чаще, но проверяйте, что он там нагенерил.
883.28 905.44 "Игорь Лабутин" Так, можно теперь внутри кода iSpend-приложения прямо заинжектировать к себе в куда-нибудь из DI, iOpenAPIDocumentProvider, такой интерфейсик, и доступаться к OpenAPI-документу прямо изнутри приложения как бы через нормальный DI.
905.44 933.92 "Игорь Лабутин" Так, что еще… А дальше пошли всякие Blazor-ные изменения, JavaScript Interop для конструктора пропертей, можно на JavaScript-овые функции ссылаться через IGS Object Reference, в Blazor WebAssembly добавили runtime-диагностики, то есть можно теперь прямо из… ну, не из, а для Blazor WebAssembly Applications собрать там performance-профайл, memory-дамп и runtime-метрики, вот это все.
933.92 968.44 "Игорь Лабутин" Для этого нужно заинсталить специальный workload, .NET Workload Install WASM-Defice-Tools, внутри вашего проекта поставить MSBuild-проперти, которые вам нужны, либо WASM-Perf-Tracing, либо WASM-Perf-Instrumentation, там Event-Source-Support, либо Metrics-Support, а дальше поиспользовать JavaScript-овый API для того, чтобы собрать эту самую runtime-диагностику, которую потом можно загрузить в виде NetTrace-файла, который либо посмотреть так, либо конвертнуть через .NET GC-Dump-Convert командочку в обычный GC-Dump-файл, который уже там студия умеет открывать, либо другие тулы.
968.44 993.56 "Игорь Лабутин" А также можно заиспользовать браузерный performance-профайлер, поскольку WASM у нас работает в том числе в браузере, а там есть свой собственный профайлер, для этого нужно поставить другие MSBuild-проперти, в WASM Profilers поставить значение Browser, там еще две штучки в статье написаны, я уж сейчас не буду так диктовать, все равно вряд ли это с голоса записываете, и потом попрофайлить прямо из браузера.
993.56 1018.48 "Игорь Лабутин" Дальше уже пошли какие-то совсем, ну давай так скажем, специфичные UI-ные изменения, типа там QuickGridMethodRenamedTo что-то там другой метод, PreloadBlazorFrameworkStaticAssets, чтобы чуть-чуть побыстрее грузилось, ну и так далее, в общем, все такое для по мелочи улучшения, но тем не менее улучшение.
1018.48 1033.40 "Игорь Лабутин" Вот EF, в EF в основном все изменения вокруг Azure Cosmos DB и поиска в нем, то есть там гибридный серч, Vector Similarity Search, если пользуетесь космосом, посмотрите, если нет, ну скорее всего, конечно, что-то пофиксили и помимо этого, но в анонсе только эти фичи.
1033.40 1039.92 "Игорь Лабутин" В MAUI тоже что-то по контролу, чуть-чуть только модернизация и больше ничего.
1039.92 1046.56 "Игорь Лабутин" .NET for Android, там по мелочи, опять дальше продолжают работать над уменьшением размера бандлов.
1046.56 1060.28 "Игорь Лабутин" Ну и в WPF продолжают опять же унифицировать код для работы с клейбортом, напомню, то место, где у нас использовался binary, как он, форматер, serializer, короче, этот самый, который задеприкейтили.
1060.28 1061.28 "Игорь Лабутин" Форматер, да вроде.
1061.28 1078.84 "Игорь Лабутин" Да, который задеприкейтили, и они, в общем, все это все еще унифицируют, вынесли в общую какую-то сборку, вот это все, ну, performance improvement и все дела, короче, из всех как бы таких десктопно-дотнетных штук же, внутри Microsoft, мне кажется, только WPF нормально куда-то двигается, судя по релиз-ноутсу.
1078.84 1087.04 "Игорь Лабутин" Ну вот и все, это все, что есть в превью 4, ничего такого суперреволюционного, мне кажется, кроме очередного эскейп-анализа.
1087.04 1093.68 "Анатолий Кулаков" Ну потихонечку, потихонечку идем, в принципе, хороший нормальный превью, ничего не ломающий, ничего не страшающий.
1093.68 1094.68 "Анатолий Кулаков" Это да.
1094.68 1104.28 "Анатолий Кулаков" А я тут недавно в статике видел про то, что Open Silver, помнишь, мы несколько раз уже обсуждали, вот он там рулит иби-бикой, сейчас портировался на мобилке, теперь на мобилках с помощью него можно писать.
1104.28 1107.60 "Анатолий Кулаков" Так что не только WPF, там еще Open Silver ему наступает на пятки.
1107.60 1113.56 "Игорь Лабутин" Ну он все-таки не входит, как мне кажется, в внутренние продукты Microsoft, это же какие-то внешние ребята теперь поддерживают.
1113.56 1116.64 "Игорь Лабутин" Так-то и Avalonia живет, разве нет?
1116.64 1121.72 "Анатолий Кулаков" Ну да, но, по-моему, Avalonia еще не умеет веб, и я чуть не помню, как она себя на мобилках чувствует.
1121.72 1134.92 "Игорь Лабутин" Ну вроде был какой-то, как минимум превью какой-то был, мне кажется, ну и какие-то там типа бета, не бета, в общем, я не пробовал Avalonia на мобилках, только чуть-чуть на десктопе, поэтому ничего не скажу, не слежу.
1134.92 1138.52 "Анатолий Кулаков" Можно позвать специалистов по Avalonia и обсудить эту тему как-то основательно.
1138.52 1140.92 "Анатолий Кулаков" И, Вайка, я думаю, мы еще займемся.
1140.92 1164.46 "Анатолий Кулаков" Давай про все-таки C# еще останемся, мы в прошлом, на прошлом выпуске или в одном из прошлых выпусков как раз анонсировали, что главной фишкой этого релиза C# большого, когда он выйдет, зарелизится, станут экстеншн-мембры, штука, которую многие ждали, я даже могу сказать, не десяток лет просто, в общем, очень важная, классная штука.
1164.46 1177.04 "Анатолий Кулаков" И вот про нее хотелось бы поговорить более подробно, потому что так, не только в виде там анонса, а вот прям разобраться в условиях синтексиса, какие подводные камни стояли перед создателями, почему они на них остановились и прочее-прочее.
1177.04 1182.04 "Анатолий Кулаков" Вот про это мне нашлась отдельная статейка, предлагаю ее и разобрать.
1182.04 1183.04 "Анатолий Кулаков" Погнали.
1183.04 1186.60 "Анатолий Кулаков" Итак, как вы, наверное, уже поняли, поговорим, наверное, про экстеншн-мембры.
1186.60 1191.04 "Анатолий Кулаков" Это новая штука, которая заедет к нам в C# 14.
1191.04 1195.48 "Анатолий Кулаков" Кстати, ее обещали уже в прошлом C# и отменили, она не заехала.
1195.48 1198.28 "Анатолий Кулаков" Поэтому будем надеяться, что зайдет она в C# 14.
1198.28 1201.76 "Анатолий Кулаков" Это новый синтексис, который позволяет вам расширять любые члены.
1201.76 1206.28 "Анатолий Кулаков" Если вы помните, раньше мы могли расширять только методы.
1206.28 1213.40 "Анатолий Кулаков" И в принципе, даже самого этого факта, что мы могли расширять только методы, нам хватило, чтобы построить целую кучу новых направлений.
1213.40 1219.56 "Анатолий Кулаков" Например, если вы знаете, что такое линку, то это не больше, не меньше, а набор просто методов расширения.
1219.56 1225.84 "Анатолий Кулаков" То есть, вот у нас линку появился только потому, что мы всего лишь навсего придумали какие-то жалкие расширения методов.
1225.84 1236.48 "Анатолий Кулаков" Такая простая нововведения позволила нам многие-многие годы жить счастливо, весело, в принципе, и мало какой язык, особенно в то время, мог похвастаться таким нововведением, такой фичей.
1236.48 1247.08 "Анатолий Кулаков" В общем, и поэтому очень многие десятилетия команда .NET мечтала и планировала, как бы нам надо расширять не только методы, но и все остальное.
1247.08 1252.28 "Анатолий Кулаков" Но прежде, чем до этого дойти, давайте посмотрим, что же у нас было.
1252.28 1254.64 "Анатолий Кулаков" Extension методы – это довольно удобная штука.
1254.64 1266.12 "Анатолий Кулаков" Это специальный синтексис, который позволяет вам расширить уже существующие какие-то классы, если у вас нет доступа к их коду или к их интерфейсам.
1266.12 1271.04 "Анатолий Кулаков" В общем, и вы можете каким-то образом обогатить их новыми методами.
1271.04 1274.20 "Анатолий Кулаков" Мы могли обогатить раньше только инстансы этих классов и только методами.
1274.20 1281.48 "Анатолий Кулаков" В общем, это были такие довольно существенные ограничения, хотя они покрывали, я думаю, 80% всех надобностей, которые стояли перед программистами.
1281.48 1286.62 "Анатолий Кулаков" Но всегда хотелось больше, и вот больше у нас начинает появляться.
1286.62 1291.44 "Анатолий Кулаков" Это как раз новый синтексис, который называется не Extension метод, а Extension Members, поэтому не путайте.
1291.44 1295.48 "Анатолий Кулаков" Итак, что же нам предлагает Extension Members?
1295.48 1301.12 "Анатолий Кулаков" На данном этапе реализации он нам предлагает возможность реализовать не только методы, но еще и свойства.
1301.12 1306.04 "Анатолий Кулаков" Более того, не только свойства, но еще и статические свойства, а еще статические методы.
1306.04 1310.08 "Анатолий Кулаков" То есть вот такие три новые сущности на данный момент он привнесет.
1310.08 1315.20 "Анатолий Кулаков" Ну, естественно, команда его разрабатывает таким образом, чтобы в будущем можно было засунуть еще что-нибудь.
1315.20 1317.64 "Анатолий Кулаков" Например, что нам еще может понадобиться?
1317.64 1324.48 "Анатолий Кулаков" Конструкторы, наследование, например, мы можем пронаследовать какой-то существующий класс от каких-то внешних интерфейсов и так далее.
1324.48 1331.36 "Анатолий Кулаков" То есть это все нас ждет в будущем, пока мы говорим какие-то о более приземленных вещах, это свойства методы и статические свойства методы.
1331.36 1337.56 "Анатолий Кулаков" Итак, немножко вспомним, как у нас раньше задавались методы расширения.
1337.56 1341.52 "Анатолий Кулаков" Для этого вам нужно было создать статический класс.
1341.52 1345.20 "Анатолий Кулаков" Внутри статического класса нужно было создать статический метод.
1345.20 1353.04 "Анатолий Кулаков" И первым параметром этого статического метода необходимо было записать тот тип, который вы хотите расширить, префиксовав его с ключевым словом this.
1353.04 1362.32 "Анатолий Кулаков" И после этого можно реализовывать метод таким образом, каким бы вы хотели, чтобы он был в оригинальном тайпе, в оригинальном типе.
1362.32 1375.00 "Анатолий Кулаков" И в принципе все, вот такой простой синтаксис, когда у вас тип, который вы хотите расширять, передается первым параметром, все остальные параметры, которые вы хотите передать в метод, просто передаются всеми остальными параметрами.
1375.00 1383.28 "Анатолий Кулаков" В общем, гениальность всего этого подхода, всего синтаксиса была как раз в том, что было очень понятно, что собственно происходит.
1383.28 1389.08 "Анатолий Кулаков" То есть по ключевому слову this мы догадывались, что здесь происходит какая-то магия, просто она просто компиляторная.
1389.08 1403.24 "Анатолий Кулаков" А вот статические свойства у класса и у метода помогали нам понять, что это действительно не метод того класса, это просто какая-то оберточка, которая сравни статическому методу.
1403.24 1409.24 "Анатолий Кулаков" Который просто вызывается без лишних каких-то контекстов, кроме тех, которые передались непосредственно в параметры этого метода.
1409.24 1420.64 "Анатолий Кулаков" В общем, человеку, который никогда раньше не был знаком с методами расширения, но понимал, что такое статические методы, показывая эту реализацию, было довольно понятно, что происходит и во что она раскладывается.
1420.64 1424.44 "Анатолий Кулаков" А раскладывается она как раз-таки просто-напросто вся эта магия во время компиляции.
1424.44 1429.08 "Анатолий Кулаков" То есть никаких методов расширения или еще где-то в рантайме их не существует.
1429.08 1452.24 "Анатолий Кулаков" Просто-напросто компилятор, когда компилирует ваш вот этот код, он убирает вызов метода непосредственно из какого-то оригинального класса и превращает их в вызов статического метода от вашего статического класса, передав как раз исходный тип первым аргументам и переписав все остальные аргументы следом за ним.
1452.24 1457.12 "Анатолий Кулаков" В общем, решение довольно элегантное, довольно красивое, довольно интуитивное, понятное.
1457.12 1460.48 "Анатолий Кулаков" В принципе, все были счастливы.
1460.48 1469.68 "Анатолий Кулаков" Для того, чтобы реализовать вот такой метод расширения, нам необходимо было обеспечить компилятора информацией о двух направлениях.
1469.68 1475.64 "Анатолий Кулаков" Во-первых, это так называемый ресивер, это как раз тот исходный тип, который мы хотим расширять.
1475.64 1479.88 "Анатолий Кулаков" И параметры, которые необходимо передать в этот метод.
1479.88 1494.48 "Анатолий Кулаков" И старый синтаксис в принципе решал обе эти задачи, то есть передавал информацию об обоих этих направлениях через лист параметров, то есть через список тех параметров, которые у нас передавались в метод.
1494.48 1497.48 "Анатолий Кулаков" Мы туда же передавали и ресивер, и параметры.
1497.48 1500.24 "Анатолий Кулаков" Ресивер префиксуя, обозначая ключевым словом this.
1500.24 1503.24 "Анатолий Кулаков" Именно так компилятор понимал, кто из них ресивер, а кто из них параметр.
1503.24 1507.32 "Анатолий Кулаков" Новый синтаксис предлагает нам немножко другой подход.
1507.32 1513.64 "Анатолий Кулаков" Он разделяет такие понятия, как ресивер и параметры.
1513.64 1515.04 "Анатолий Кулаков" Разделяет их прямо так явно.
1515.04 1530.64 "Анатолий Кулаков" Если мы хотим написать extension member, extension method, тот же самый допустим, в новом синтаксисе, то нам необходимо будет выделить отдельный блок, который называется extension block, то есть блок расширения, и в этом extension блоке уже описать полностью ресивер.
1530.64 1535.56 "Анатолий Кулаков" Какого он типа, как мы его назовем, какие у него атрибуты, какие у него restrictions и так далее.
1535.56 1545.96 "Анатолий Кулаков" И уже отдельно после того, как мы описали ресивер, мы уже внутри этого extension блока описываем непосредственно сами методы, которые мы хотим добавить к ресиверу.
1545.96 1561.72 "Анатолий Кулаков" Таким образом мы получаем возможность не просто повторить тот синтаксис, который мы имели в extension методах, но и новый синтаксис, в котором, например, мы можем объявить свойства.
1561.72 1563.88 "Анатолий Кулаков" То есть те методы, у которых нет никаких параметров.
1563.88 1574.92 "Анатолий Кулаков" Так как у нас ресивер сейчас отделен, нам не нужно выдавать первое слово, и поэтому без параметров и свойств вполне мы можем объявить, что, в принципе, хорошо.
1574.92 1587.88 "Анатолий Кулаков" Другими плюсами данного подхода являются то, что у нас теперь все extension методы будут явно группироваться с помощью вот этого extension блока.
1587.88 1604.48 "Анатолий Кулаков" И, например, если у вас у ресивера есть какие-то ключевые параметры, ну, допустим, вам нужно было раньше написать 10 методов к enumerable от t, вам бы пришлось писать 10 extension методов, в каждом из них писать enumerable от t, enumerable от t, enumerable от t.
1604.48 1610.88 "Анатолий Кулаков" А если бы к этому t еще необходимо было наложить какие-нибудь constraints, типа что t — это только структура, допустим.
1610.88 1613.96 "Анатолий Кулаков" Опять эта информация дублировалась бы у вас в десяти местах.
1613.96 1622.00 "Анатолий Кулаков" То благодаря вот такой группировке, которая появилась в новом синтаксисе, вам достаточно это написать всего-навсего в одном единственном месте, в extension блоке.
1622.00 1637.04 "Анатолий Кулаков" И этот extension блок расшаривает не только тип ресивера, но еще и имя ресивера, его generic параметры, его constraints, которые вы накладываете к параметрам, атрибуты, которые вы туда можете навесить, любые модификаторы, которые есть.
1637.04 1639.60 "Анатолий Кулаков" То есть все это вы пишете один раз для всей группы этого extension.
1639.60 1646.64 "Анатолий Кулаков" Поэтому это такой неочевидный, но довольно интересный плюс.
1646.64 1661.04 "Анатолий Кулаков" Следующим плюсом авторы заявляют, что в новом синтаксисе вы будете писать extension методы практически так же, как они выглядели бы в настоящем классе, в том как раз ресивер классе, если бы вы его реализовывали в исходном коде.
1661.04 1667.20 "Анатолий Кулаков" То есть методы здесь похожи на методы без всяких вот этих this-ов дурацких, которые на первом месте стоят.
1667.20 1668.92 "Анатолий Кулаков" То есть не нужно думать ни о какой магии.
1668.92 1672.52 "Анатолий Кулаков" Метод выглядит как методы, пишете свойства, он выглядит как свойства, не поверите.
1672.52 1677.20 "Анатолий Кулаков" В общем, все довольно интуитивно и довольно понятно, как только мы начинаем отделять ресивера отдельно.
1677.20 1703.96 "Анатолий Кулаков" И также команда рассказала, что в принципе она посмотрела, прежде чем реализовать такую группировку, она посмотрела в открытые исходники, посмотрела, как разработчики этим пользуются, и в частности на GitHub, и убедилась, что самым популярным способом использования extension методов является вынесение отдельного статического класса, и в этом статическом классе группировать, собирать все extension методы относительно какого-то одного типа.
1703.96 1712.68 "Анатолий Кулаков" Ну, допустим, классы наверняка у вас есть такие как string extension, какой-нибудь int extension, list extension и так далее.
1712.68 1718.84 "Анатолий Кулаков" В общем, и внутри этого класса как раз собираются все extension методы, относящиеся к какому-то одному конкретному ресиверу.
1718.84 1733.20 "Анатолий Кулаков" Вот они поняли, что в принципе у нас уже есть группировка по имени класса string extension, у нас уже есть файлик, который называется string extension, давайте еще туда добавим extension блок, в котором тоже напишем string extension.
1733.20 1737.04 "Анатолий Кулаков" В общем, такая вот тройная группировочку они нам подарили.
1737.04 1740.84 "Анатолий Кулаков" В общем, они поняли, что группировка – это хорошо, и поэтому продолжили группировать.
1740.84 1746.44 "Анатолий Кулаков" И так, насчет вызова, который ставили перед командой.
1746.44 1757.92 "Анатолий Кулаков" Как я уже сказал, как только появились extension методы, и даже, наверное, раньше, как только начали придумывать и проектировать extension методы, когда они даже еще не появились, у команды уже было желание как бы расширять абсолютно все.
1757.92 1765.96 "Анатолий Кулаков" Ну, очевидно, что если мы расширили методы, то хочется расширять все-все-все, и на это ушло многие-многие годы.
1765.96 1780.24 "Анатолий Кулаков" И единственная проблема, почему мы получили это только сейчас, через многие десятилетия после существования дотнета, как бы то, что не существует идеального синтаксиса для того, чтобы реализовать такую штуку.
1780.24 1786.48 "Анатолий Кулаков" В общем, не было каких проблем ее сделать, очевидно же, что если мы сделали методы, то все остальное тоже элементарно.
1786.48 1793.24 "Анатолий Кулаков" Была огромная проблема придумать, а как это красиво, идеоматично, в стиле C# это реализовать.
1793.24 1795.12 "Анатолий Кулаков" И вот эту они проблему решали.
1795.12 1811.00 "Анатолий Кулаков" Ну, и как мы увидели на сегодняшний день, проблему эту они не решили, потому что они честно создаются, что идеального синтаксиса не существует, эту фичу бесполезно решать как бы в идеальном синтаксисе, поэтому пришлось городить костыли.
1811.00 1845.24 "Анатолий Кулаков" Ну, в частности, вводить такое понятие, как extension block, абсолютно чуждое вообще C#, вводить вообще ключевое слово extension, которое в принципе тоже можно было избежать, имея ключевое слово this при этом, вводить отдельный синтаксис для ресивера, потому что его можно писать теперь не только типом, но и типом без имени, а иногда с именем, ну, в общем, extension block это такой довольно громоздкий, уродливый и часто не поддающийся логическому описанию костыли.
1845.24 1854.68 "Анатолий Кулаков" С этим как бы все смирились в команде, и поэтому сказали, да, вы или не увидите эту фичу никогда, или будете довольствоваться тем, что есть.
1854.68 1863.32 "Анатолий Кулаков" Ну, решили, что давайте довольствоваться тем, что мы в данный момент родили, тем, что получается, но зато у нас как бы будет такая мощная интересная фича.
1863.32 1867.16 "Анатолий Кулаков" Ну, хорошо, допустим, допустим это так.
1867.16 1871.08 "Анатолий Кулаков" Какие проблемы они еще решали, кроме красивого синтаксиса?
1871.08 1875.80 "Анатолий Кулаков" Прежде всего нужно понимать, что extension методы очень плотно и очень глубоко вошли в экосистему.
1875.80 1877.64 "Анатолий Кулаков" Ими пользуются абсолютно все.
1877.64 1884.76 "Анатолий Кулаков" Естественно, сама экосистема .NET, сам фреймворк просто пропитанными со всех сторон.
1884.76 1891.56 "Анатолий Кулаков" Поэтому здесь нужно было новый синтаксис выдумывать таким образом, чтобы он был полностью совместим со старым синтаксисом.
1891.56 1906.72 "Анатолий Кулаков" А также, чтобы те разработчики, которые использовали extension методы и которые будут использовать новый синтаксис extension методов, как для создания, так и для вызова, они тоже чувствовали себя нормально, то есть у них не коробило ничего.
1906.72 1912.68 "Анатолий Кулаков" Поэтому пытались все-таки каким-то образом удовлетворить и тех, и тех.
1912.68 1923.64 "Анатолий Кулаков" Также необходимо было сделать так, чтобы конвертация на новый синтаксис, если мы будем переписывать старые extension методы на новый синтаксис, она была без каких-то либо breaking changes.
1923.64 1936.92 "Анатолий Кулаков" Также хотелось, чтобы ресивер мог поддержать расширение не только тех методов, у которых есть параметры, которые в старом синтаксисе были, но и нового подхода, когда у некоторых методов параметров нет.
1936.92 1940.36 "Анатолий Кулаков" Допустим, мы говорим про property, property тоже там каким-то образом поддерживались.
1940.36 1949.80 "Анатолий Кулаков" И они всегда в голове держали такой компромисс, что extension методы вызываются намного чаще, чем создаются или изменяются.
1949.80 1959.00 "Анатолий Кулаков" Поэтому если нужно будет идти на какие-то компромиссы, то компромиссы должны быть внутри декларации, в синтаксисе создания, но ни в коем случае не в синтаксисе вызовов.
1959.00 1966.12 "Анатолий Кулаков" Ну, в принципе, они на 100% получили, потому что вызов никак не отличается, ничем не отличается, а вот создание немножко покоребило.
1966.12 1970.88 "Анатолий Кулаков" Итак, давайте же разберемся, как эта штука работает.
1970.88 1978.56 "Анатолий Кулаков" Прежде всего, я уже упоминал выше, что на самом деле extension методы – это магия на уровне компилятора.
1978.56 1983.16 "Анатолий Кулаков" Компилятор при компиляции вашего кода просто-напросто вызывает статический метод, тот, который вы написали.
1983.16 1992.84 "Анатолий Кулаков" Вот это ключевое слово, вот здесь просто-напросто метаинформация для него, и в конечном или коде его не существует, слово this, да, существует просто статический метод, который вызывается.
1992.84 1994.72 "Анатолий Кулаков" Все довольно понятно и просто.
1994.72 2007.40 "Анатолий Кулаков" Компилятор использует слово this для того, чтобы передать просто ресивер, понять, каким параметрам его передавать, и понять просто, что это extension метод, и остальные параметры тоже передаются следом.
2007.40 2014.12 "Анатолий Кулаков" И ограничением старого подхода было то, что мы поддерживали только методы, мы не поддерживали проперти.
2014.12 2018.52 "Анатолий Кулаков" И новые extension-мемберы могут решить эту проблему с помощью код-блока.
2018.52 2023.72 "Анатолий Кулаков" Что делает компилятор теперь, если мы используем новые синтаксис?
2023.72 2029.60 "Анатолий Кулаков" Если мы говорим про старый синтаксис, то, в принципе, компилятор там работает довольно тривиально.
2029.60 2035.00 "Анатолий Кулаков" Он не трогал практически сам extension-метод, ну, кроме выбрасывания ключевого слова this, оно там бесполезно.
2035.00 2039.72 "Анатолий Кулаков" Он всего лишь навсего переделывал вызов, т.е. изменялся только место вызова.
2039.72 2046.84 "Анатолий Кулаков" Новый компилятор немножко умнее, потому что ему необходимо поднимать новый синтаксис extension-блока.
2046.84 2062.04 "Анатолий Кулаков" Он берет этот синтаксис extension-блока и на самом деле переделывает, слепливает обратно, можно сказать, extension-блок, плюс те методы, которые были объявлены внутри него, слепливает их в статические методы.
2062.04 2066.48 "Анатолий Кулаков" И эти статические методы вызывает точно так же, как и вызывал ранее.
2066.48 2074.12 "Анатолий Кулаков" Т.е. он приводит практически эти методы к синтаксису-эквивалентному тому, которые были с этим параметром.
2074.12 2077.48 "Анатолий Кулаков" При этом компилятор дает нам гарантии.
2077.48 2081.84 "Анатолий Кулаков" Он дает гарантии, что оба синтаксиса работают одинаково.
2081.84 2089.00 "Анатолий Кулаков" И старый синтаксис для мемберов и новый синтаксис для методов, в случае, они будут работать одинаково.
2089.00 2101.12 "Анатолий Кулаков" Также он дает нам гарантии, что при вызове с помощью обычного статического класса, статического метода, этот вызов эквивалентен вызову с помощью метода расширения.
2101.12 2108.72 "Анатолий Кулаков" И также немаловажная гарантия, он дает нам полную совместимость между исходным кодом и бинарным уровнем.
2108.72 2126.48 "Анатолий Кулаков" Т.е. если вы, например, старый экстеншн метод решили переделать на новый синтаксис и больше ничего не меняете, просто сконвертировали на новый синтаксис с помощью экстеншн-мемберов, то ваша библиотека сохраняет 100% совместимость на бинарном уровне.
2126.48 2129.60 "Анатолий Кулаков" Ну и естественно на API уровне тоже.
2129.60 2132.56 "Анатолий Кулаков" Т.е. вызывающая сторона никаким образом не пострадает.
2132.56 2136.92 "Анатолий Кулаков" Вы можете бинарничек подложить в новой библиотеке и вызывающая сторона будет по-прежнему работать.
2136.92 2142.36 "Анатолий Кулаков" Потому что, как я уже говорил, вызывающая сторона точно так же переделывается просто-напросто вызов статического класса.
2142.36 2146.68 "Анатолий Кулаков" Т.е. вот эта магия, вот эта технология работает вся по-прежнему.
2146.68 2156.64 "Анатолий Кулаков" Более того, когда я говорю, что вот этот экстеншн-блок схлопывается вместе с методами, соответственно возникает вопрос, а как же он схлопывается, например, для свойств?
2156.64 2164.68 "Анатолий Кулаков" Потому что раньше-то невозможно было написать с помощью старого синтаксиса с вот этим this параметром.
2164.68 2167.48 "Анатолий Кулаков" Невозможно было написать метод расширения для свойств.
2167.48 2172.08 "Анатолий Кулаков" Схлопывается очень красиво и, если честно, довольно предсказуемо, как это должно было бы быть.
2172.08 2181.00 "Анатолий Кулаков" Если вы когда-нибудь рассматривали, что такое свойства внутри иль-кода или там старого синтаксиса .NET, нет, какого старого?
2181.00 2182.00 "Анатолий Кулаков" Да, все-таки на иль-коде.
2182.00 2184.88 "Анатолий Кулаков" То на самом деле любое свойство – это два метода.
2184.88 2189.80 "Анатолий Кулаков" Это get-свойство, get-подчеркивание имя-свойства и set-подчеркивание имя-свойства.
2189.80 2192.30 "Анатолий Кулаков" Вот оно раскладывается, вызов двух этих методов.
2192.30 2195.40 "Анатолий Кулаков" А property – это всего лишь синтаксический сахар.
2195.40 2206.60 "Анатолий Кулаков" Ну так вот, зная эту магию, очевидно предположить, что экстеншн-метод для свойства будет точно таким же методом, у которого будет начинаться слово get-подчеркивание имя-свойства.
2206.60 2210.88 "Анатолий Кулаков" И первым параметром через this будет принимать ресивер.
2210.88 2212.36 "Анатолий Кулаков" Вот и все.
2212.36 2217.16 "Анатолий Кулаков" И вот и решилась проблема с вот этими свойствами, которые мы так долго, много десятилетий ждали.
2217.16 2239.88 "Анатолий Кулаков" И более того, мне кажется, что если бы команда Microsoft предложила бы нам вот этот синтаксис, уродский пусть, get с маленькой буквы, подчеркивание, this для свойств, то есть для расширения свойств, то я думаю, что в принципе это было бы решение не хуже, чем замутить вот этот новый экстеншн-блок.
2239.88 2247.60 "Анатолий Кулаков" Потому что экстеншн был настолько уродливый, что вот расширение для свойств в виде get-подчеркивания выглядит вполне себе прилично.
2247.60 2253.20 "Анатолий Кулаков" Поэтому, может быть, на этом синтаксисе стоило остановиться, не нужно было мудрить всю вот эту магию с экстеншн-блоками.
2253.20 2258.72 "Анатолий Кулаков" Но, в принципе, решение сделано, поэтому будем жить с этим.
2258.72 2262.28 "Анатолий Кулаков" Итак, давайте поговорим немножко про устранение неоднозначности.
2262.28 2271.08 "Анатолий Кулаков" Вот эту штуку, о которой я вам говорил, что компилятор вызывает статические методы через статический класс, которая нам, в принципе, нужна не только компилятором.
2271.08 2280.48 "Анатолий Кулаков" Иногда бывает такая вещь, что из разных библиотек есть экстеншн-методы с одним и тем же именем, и может быть, даже с одной и той же сигнатурой.
2280.48 2284.08 "Анатолий Кулаков" Такое, на самом деле, на практике встречается довольно часто.
2284.08 2294.08 "Анатолий Кулаков" Иногда можно, конечно, этого избежать, выключив ненужные namespaces, но иногда избегать не получается, и нам нужен способ решения этой проблемы.
2294.08 2295.28 "Анатолий Кулаков" И такой способ есть.
2295.28 2299.88 "Анатолий Кулаков" Это явный вызов статического метода через статический класс.
2299.88 2306.56 "Анатолий Кулаков" У класса можно полностью указать namespace, если это нужно, и указать, а какой именно статический метод мы хотели бы вызвать.
2306.56 2313.20 "Анатолий Кулаков" То есть не в виде синтаксиса метода расширения, а в виде синтаксиса обычного статического вызова.
2313.20 2319.80 "Анатолий Кулаков" Соответственно, новый синтаксис экстеншн-метода поддерживает точно такое же свойство.
2319.80 2330.48 "Анатолий Кулаков" Как и традиционные методы, он точно также может быть вызван, новый синтаксис, через статический класс, в который внутривизированы экстеншн-методы.
2330.48 2342.12 "Анатолий Кулаков" Это может быть немножко неочевидно, по той самой причине, что у нас есть некий экстеншн-блок, и все методы внутри этого экстеншн-блока не принимают первым параметром ресивер.
2342.12 2344.28 "Анатолий Кулаков" Поэтому, как их вызывать, не очень ясно.
2344.28 2347.24 "Анатолий Кулаков" Но на самом деле интеллисенс довольно умный.
2347.24 2359.72 "Анатолий Кулаков" Интеллисенс понимает, что если мы обращаемся к этим методам через статический класс, то он нам подставляет уже не те методы, которые на самом деле у нас декларированы в C# коде, а те методы, которые получатся в результате компиляции.
2359.72 2370.68 "Анатолий Кулаков" То есть мы можем там же найти через точку метод, который называется get подчеркивение имя-свойство вышеупомянутый, и вызвать его напрямую прямо вот так.
2370.68 2371.68 "Анатолий Кулаков" Отлично.
2371.68 2372.68 "Анатолий Кулаков" С этим вроде разобрались.
2372.68 2379.08 "Анатолий Кулаков" Теперь, как же нам все-таки сделать свойство в новом синтаксисе?
2379.08 2380.08 "Анатолий Кулаков" Мы все это обсуждали.
2380.08 2381.08 "Анатолий Кулаков" Методы, методы.
2381.08 2382.08 "Анатолий Кулаков" А как же, собственно, декларируется свойство?
2382.08 2383.08 "Анатолий Кулаков" Очень просто.
2383.08 2390.32 "Анатолий Кулаков" В extension блоке, где мы обычно пишем ресивера, описываем ресивера, мы обычно описываем тип ресивера и его имя.
2390.32 2395.36 "Анатолий Кулаков" Так вот, если вам нужно вызвать свойства, то никакого имени ресивера нам не нужно.
2395.36 2396.36 "Анатолий Кулаков" Нам нужен только его тип.
2396.36 2406.28 "Анатолий Кулаков" Допустим, мы хотим сделать у листа новое свойство, и соответственно указываем только лист, и все, и у него пишем те свойства, которые нам нужны.
2406.28 2412.08 "Анатолий Кулаков" Также мы можем сделать статические методы и статические свойства.
2412.08 2417.24 "Анатолий Кулаков" Здесь, опять же, нам не нужно имя ресивера, нам достаточно знать просто его тип.
2417.24 2427.72 "Анатолий Кулаков" Допустим, если мы у листа хотим сделать метод create, то мы внутри extension блока пишем обычный синтаксис, как бы мы писали для создания статического метода.
2427.72 2429.16 "Анатолий Кулаков" Public, static, list, create.
2429.16 2430.16 "Анатолий Кулаков" Вот и все.
2430.16 2436.92 "Анатолий Кулаков" Теперь у листа будет статический метод create, который возвращает, допустим, что-то, чтобы решили какой-нибудь массив по умолчанию.
2436.92 2439.60 "Анатолий Кулаков" Немножко про дженерики.
2439.60 2454.72 "Анатолий Кулаков" Если мы говорим про дженерик-параметры, то у нового синтаксиса, естественно, точно так же, как и у старого, с полной совместимостью поддерживаются open дженерики, то есть лист от t, и конкретные дженерики, допустим, лист от nt или лист от stroke.
2454.72 2461.88 "Анатолий Кулаков" Также поддерживаются constraints, то есть вы можете написать там какое-то ограничение на struct или на enum или еще на что-то.
2461.88 2465.76 "Анатолий Кулаков" Ну и в частности поддерживается, например, constraint на новые интерфейсы inumber.
2465.76 2478.36 "Анатолий Кулаков" Если кто помнит наши выпуски по дженерик-математику, то inumber позволяет вам делать, например, в ваших лямбдах такую штуку, как сравнить переданный параметр с помощью оператора больше, меньше, равно и так далее.
2478.36 2482.12 "Анатолий Кулаков" Ну и много других интересных штук, которые вы бы ожидали, допустим, от цифр видеть.
2482.12 2487.24 "Анатолий Кулаков" Сравнение, там, инициализация нулем и так далее.
2487.24 2490.40 "Анатолий Кулаков" Здесь есть еще один интересный момент.
2490.40 2494.24 "Анатолий Кулаков" Дженерик-параметры могут быть, естественно, у ресивера.
2494.24 2496.88 "Анатолий Кулаков" Мы хотим расширить лист от t, это нормально.
2496.88 2499.56 "Анатолий Кулаков" А также могут быть у методов.
2499.56 2516.00 "Анатолий Кулаков" Допустим, если метод принимает какой-нибудь селектор и в качестве результата возвращает результат, вспомним то же самое linq-select, в общем, то результат – это будет часть как раз метода внутри extension блока.
2516.00 2521.92 "Анатолий Кулаков" Поэтому дженерик-параметры могут быть и там, и там, и это нормально, это хорошо, это ожидаемо.
2521.92 2531.24 "Анатолий Кулаков" Но с этим есть небольшие подводные камни, и подводные камни называются, а не все методы старого синтаксиса можно сконвертировать в новый синтаксис.
2531.24 2534.00 "Анатолий Кулаков" Разберем парочку интересных моментов.
2534.00 2536.40 "Анатолий Кулаков" Представьте себе дженерик-метод.
2536.40 2539.44 "Анатолий Кулаков" Допустим, тот же самый лист мы расширяем с помощью метода select.
2539.44 2547.00 "Анатолий Кулаков" И вот мы расширяем лист от t и пишем ему метод select, который принимает t и возвращает результат.
2547.00 2549.52 "Анатолий Кулаков" В принципе, здесь все хорошо.
2549.52 2555.84 "Анатолий Кулаков" Мы можем написать его в старом синтаксисе без проблем, мы можем написать его в новом синтаксисе сконвертировать, даже в новый синтаксис тоже без особых проблем.
2555.84 2558.80 "Анатолий Кулаков" А вот теперь представьте следующую ситуацию.
2558.80 2565.04 "Анатолий Кулаков" Если бы этот метод select, который принимает t и возвращает результат, делал бы немножко обратную ситуацию.
2565.04 2571.24 "Анатолий Кулаков" Если бы он первым параметром принимал результат, а вторым параметром принимал бы t.
2571.24 2577.96 "Анатолий Кулаков" Вот такой метод вы вполне можете описать старым синтаксисом, но никак не можете описать его новым синтаксисом.
2577.96 2590.40 "Анатолий Кулаков" Потому что в новом синтаксисе кальпилятор сначала берет generic параметры от extension блока и потом к ним добавляет generic параметры, следом за ними добавляет generic параметры от самих методов.
2590.40 2593.48 "Анатолий Кулаков" То есть сначала обязан быть t и только потом результат.
2593.48 2597.96 "Анатолий Кулаков" Если у вас наоборот, то такой синтаксис вы сконвертировать не сможете.
2597.96 2602.04 "Анатолий Кулаков" Также на данный момент есть еще одно ограничение.
2602.04 2617.92 "Анатолий Кулаков" Вы не можете сконвертировать из старого синтаксиса в новый ситуацию, когда у ресивера есть constraint, который зависит от типа параметра в методе в самом.
2617.92 2628.72 "Анатолий Кулаков" В общем, тоже понятно почему, потому что у нас в extension блоке, когда мы описываем ресивер, мы никак не можем зависеть от методов, которые внутри этого extension блока.
2628.72 2633.20 "Анатолий Кулаков" Потому что если мы будем зависеть от одного метода, непонятно, что сделать с другими методами.
2633.20 2644.72 "Анатолий Кулаков" Команда думает, может быть, они это ограничение еще в будущем смогут побороть, но пока нет и не очень-то сильно хотят, потому что они считают, что это довольно редкие ситуации, и вот, в общем, на них сильно полагаться не надо.
2644.72 2650.36 "Анатолий Кулаков" Поэтому если вдруг мы в прот выйдем с такими ограничениями, наверное, никто сильно не обидится.
2650.36 2653.48 "Анатолий Кулаков" Ну, наверное, да, в принципе, как-то можно немножко пережить.
2653.48 2658.64 "Анатолий Кулаков" В принципе, это все, что касается официального анонса.
2658.64 2664.20 "Анатолий Кулаков" Единственное, что хотелось бы добавить, наверное, какой-нибудь практический пример всей этой блатологии, которая тут была.
2664.20 2674.24 "Анатолий Кулаков" Очень часто мы, наверное, вы встречаете в программах метод parse, который есть практически у любого встроенного типа, допустим, в платформы.
2674.24 2680.48 "Анатолий Кулаков" Int parse, DateTime parse, IP address parse, т.е. когда мы из строки пытаемся выпарсить конкретное имя.
2680.48 2685.68 "Анатолий Кулаков" В общем, и довольно привычный, довольно хороший синтексис, довольно хороший паттерн, подход и так далее.
2685.68 2690.70 "Анатолий Кулаков" И, к сожалению, кто был обделен этим синтексисом, это enum.
2690.70 2695.12 "Анатолий Кулаков" Всегда хотелось конкретный enum запарсить, и этого сделать было нельзя.
2695.12 2706.04 "Анатолий Кулаков" Вы можете вызвать статический метод у класса enum, передав ему в качестве generic параметра ваш конкретный enum и передав ему строку, которую вы хотите распарсить.
2706.04 2707.84 "Анатолий Кулаков" Но все это выглядит как-то слишком костыльно.
2707.84 2712.56 "Анатолий Кулаков" Хочется взять ваш конкретный enum и вызвать у него .parse, передав строку.
2712.56 2714.48 "Анатолий Кулаков" Этого раньше было сделать нельзя.
2714.48 2722.80 "Анатолий Кулаков" Как вы догадываетесь, с помощью новых extension методов, которые позволяют нам писать статические методы расширения, мы такую штуку сделать можем.
2722.80 2739.80 "Анатолий Кулаков" Мы можем написать enum extension и в качестве расширяемого класса сделать t, обозначив constraint, что t – это должен быть enum, и сделав внутри этого extension блока статический метод parse, принимающий строку.
2739.80 2740.80 "Анатолий Кулаков" И все.
2740.80 2745.64 "Анатолий Кулаков" И с этих самых пор у вашего конкретного enum появляется метод parse.
2745.64 2750.36 "Анатолий Кулаков" В принципе, у всех ваших конкретных enum во всем вашем приложении благодаря этому одному методу расширения появляется метод parse.
2750.36 2760.92 "Анатолий Кулаков" Вот такой еще небольшой практический кейс, который вам помогает примерно хотя бы понимать, где это можно на практике уже сейчас употребить уже в существующих ваших приложениях.
2760.92 2761.92 UNKNOWN Интересное, да.
2761.92 2762.92 "Игорь Лабутин" Написание.
2762.92 2767.48 "Игорь Лабутин" Больше всего мне, конечно, понравилось, что не существует идеального способа.
2767.48 2780.28 "Игорь Лабутин" Везде балансы, да, везде надо думать и как-то проектировать решение так, чтобы оно было еще живо многие-многие-многие годы.
2780.28 2789.90 "Игорь Лабутин" И что-то мне кажется, что это будет не единственный способ, как мы можем заюзать эти экстенджеры, наверняка придумают еще пять вариантов, как же написать эти пропертии.
2789.90 2790.90 "Анатолий Кулаков" Да, наверное.
2790.90 2818.40 "Анатолий Кулаков" Просто видишь, как интересно, что когда раньше конструировали язык, планировали синтексис, ну мы же спрашивали у Рихтера, как вот дженерики делались, и у многих других людей, вот со Стамбом разговаривали о каких-то костылях, и когда они говорили о тех костылях, которые им пришлось делать для дженерик-констрейнтов, для методов расширения, для еще чего-то, все так морщились и говорили, да, да, конечно, криво-криво, ну ладно, сойдет, чего что.
2818.40 2825.48 "Анатолий Кулаков" Вот они не видели экстенджер-блоки, блин, вот после экстенджер-блоков все, что было до этого в C#, кажется просто манной небесной.
2825.48 2828.36 "Анатолий Кулаков" В общем, кажется, что тогда люди думали как-то получше.
2828.36 2836.32 "Анатолий Кулаков" В общем, я не знаю, как это еще выразить, позвали бы старого архитектора языка, и он бы, может, им подсказал что-то получше.
2836.32 2842.00 "Игорь Лабутин" Интересно, кстати, нигде не встречал никаких интервью Андерса.
2842.00 2855.84 "Игорь Лабутин" Андерс-то как бы жив-здоров, сидит там, проектирует TypeScript или что он там сейчас еще делает, может, это как-то он, интересно, что он думает про современность C#, надо бы поискать, может, есть какие-нибудь интервью.
2855.84 2860.24 "Анатолий Кулаков" Да, было бы неплохо, может, написать ему даже письмецо, может, как-то ответит, прокомментирует блок-пост.
2860.24 2863.52 "Игорь Лабутин" Какого черта вы так проектируете?
2863.52 2866.40 "Игорь Лабутин" Поговори там с Мэтсом, чтобы нормально было.
2866.40 2867.40 "Игорь Лабутин" Да.
2867.40 2875.20 "Анатолий Кулаков" Ну я думаю, они с ним советуются, но вряд ли он сильно вникает или хочет вникать в это все, что они там делают.
2875.20 2876.84 "Игорь Лабутин" Ну да, может быть и так.
2876.84 2879.52 "Игорь Лабутин" Ладно, давай дальше пойдем.
2879.52 2892.60 "Игорь Лабутин" Мы в прошлое или в какой-то из разов обсуждали трет на Reddit на тему того, чем же так хорош .NET, почему выбирают .NET, для всяких разных… или какие компании выбирают .NET.
2892.60 2912.24 "Игорь Лабутин" А тут мне попался тоже трет про то, что… про немножко нестандартный, может быть, переход, то есть у нас сейчас, у нас в целом в мире, и много где слышно про переходы там из C# в какой-нибудь Go или там другие более хайповые языки.
2912.24 2946.36 "Игорь Лабутин" А тут чувак переходил из Go в C#, в обратном направлении, то есть он три года попрограммировал на Go, много чему научился, а потом пошел в C#, причем у него был в принципе опыт C#, но опыт C# у него был Unity, это такой довольно специфический C# все-таки, надо понимать, и он был довольно давно, поэтому он был, ну, так скажем, не то что прям новичком в C#, но все-таки, можно сказать, в современный .NET погрузился практически с нуля и рассказывает про собственные впечатления.
2946.36 2951.16 "Игорь Лабутин" И вот интересно, да, посмотреть, что его впечатлило.
2951.16 2977.08 "Игорь Лабутин" Ну, во-первых, первым пунктом идет Entity Framework, т.е. понятно, что он, судя по тому, что он переключался с Go на C#, это скорее всего веб-сервисы, то есть речь идет про наши стандартные JSON-а, что-нибудь перекладыватели, и EF там, по сути, первым пунктом, он считает, что это вообще один из самых краеугольных столпов экосистемы .NET, без EF жизни нет, и вот это все, и короче, хороший ORM, это прям здорово.
2977.08 2980.52 "Анатолий Кулаков" Ну, после Go, неудивительно, там же нет никаких ORM.
2980.52 2984.28 "Анатолий Кулаков" Посмотрели бы мы, чтобы он после Java сказал там какого-нибудь Hibernate и Spring.
2984.28 2993.40 "Игорь Лабутин" Ну, да, после Hibernate EF чуть менее фичастым кажется, это правда, но да, нормально.
2993.40 3007.56 "Игорь Лабутин" Дальше SP.NET, ну про SP.NET он говорит, нормально, короче, нормальный, стабильный кусочек фреймворка, и минимум API попробовал хорошо, и контроллер попробовал хорошо, и самая сложная часть SP.NET, знаешь, какая?
3007.56 3008.56 "Анатолий Кулаков" Не знаем.
3008.56 3010.56 "Анатолий Кулаков" Маппер, валидация, роутинг.
3010.56 3067.72 "Игорь Лабутин" Аутентификация, настройка аутентификации, это самое сложное и самое непонятное, что есть в .NET, и мне кажется, что я даже видел какие-то, ну, если не статьи, то какие-то отзывы, мнения в Твиттере, что ли, от чуть ли не самих разрабов из команды .NET, про то, что да, с аутентификацией что-то надо делать, она, блин, сложная, там довольно много всяких разных странных, ладно, не странных, странно названных концепций, проблема в том, одна из проблем, как я понимаю, в том, что есть, грубо говоря, ну, условный OAuth 2.0, в котором есть своя терминология, а в .NET уже другая, ну, исторически так сложилось, и ты каждый раз, когда пытаешься настроить условную обычную там авторизацию по токенам в .NET, тебе приходится дружить с двумя мирами терминологии, одна стандартная OAuth, и вторая внутри .NET, вот, и, в общем, это сложно, да.
3067.72 3083.40 "Игорь Лабутин" Про C#, он говорит, ну, нормальный язык, как бы, в нем есть некоторое количество, как он это назвал, legacy baggage, то есть всякой старья, которая, как бы, ну, тянется просто потому, что он legacy, ну, обратная совместимость, вот это все.
3083.40 3093.76 "Игорь Лабутин" Он жалуется на длинные кейворды, и что, что их надо писать много, ну, видимо, после Go, там все покороче, там фэнтом, лет, вот это все.
3093.76 3094.76 "Игорь Лабутин" Да?
3094.76 3096.60 "Анатолий Кулаков" Люди не сбалованы интеллисенсом, и доешь.
3096.60 3097.60 "Игорь Лабутин" Это же в Go, да?
3097.60 3098.60 "Игорь Лабутин" Да.
3098.60 3102.76 "Игорь Лабутин" Наверное, я, может, что-то упутаю сейчас с каким-нибудь Котлином еще, с чем-нибудь, или с Джорджесом, ну, неважно.
3102.76 3117.00 "Игорь Лабутин" В C# точно длинные ключевые слова, это правда, их бывает много там, ну, про read-only, read-only, да, там, вот это все, даже сама .NET комьюнити прикалывается, поэтому, наверное, валидные замечания, хотя да, прям что-то интеллисенс помогает, а LLM-ки тем более современные.
3117.00 3121.12 "Анатолий Кулаков" Погоди, ну, какие длинные слова ты пишешь вот каждый день?
3121.12 3122.12 "Анатолий Кулаков" Класс?
3122.12 3123.12 "Анатолий Кулаков" Да никаких.
3123.12 3124.12 "Игорь Лабутин" Никаких я не пишу каждый день.
3124.12 3127.96 "Игорь Лабутин" Ну, паблик, да, private, каждый раз приходится писать, прям вот.
3127.96 3130.56 "Анатолий Кулаков" Ну, их там можно, допустим, опускать.
3130.56 3131.56 "Игорь Лабутин" Read-only.
3131.56 3134.36 "Анатолий Кулаков" По умолчанию хватает, ну, read-only, опять же.
3134.36 3138.96 "Анатолий Кулаков" Наверное, легочнику можно опускать, они про имитабелити ничего не знают.
3138.96 3185.40 "Игорь Лабутин" Ну, в общем, понятно, что это такое, да, как бы, я могу сказать, что вот у меня был такой забавный эффект, ну, там все знают, что, например, Java там, в Java, все же прикалываются, да, про этих имен методов, про factory, bin, что-нибудь там, еще одна factory, еще одна factory, вот это все, enterprise там слово должно быть где-нибудь, но в дотнете у нас как-то покороче методы назывались, но я могу сказать, что я не знаю, что на это влияет, но как только я пошел писать на Java, методы действительно почему-то там называются длинно, ну, в смысле, ты сам их пишешь как-то, то ли подстраиваешься под окружающие библиотеки, то ли еще как-то, поэтому это может быть просто, да, такой эффект, типа нога все коротенькая, на C# подлиннее, вот он и подмечает это.
3185.40 3186.80 "Игорь Лабутин" В целом дело привычки.
3186.80 3200.80 "Игорь Лабутин" Да, но зато он отмечает неплохое решение для null safety, которые смогли строить язык, оно не идеально, понятное дело, но в целом неплохо, неплохо, если ты используешь библиотеки, которые размечены, понятное дело, тем самым null safety.
3200.80 3202.88 "Игорь Лабутин" А сейчас уже все размечено.
3202.88 3210.16 "Игорь Лабутин" Ну, наверняка найдется какая-нибудь, что-то неразмеченное, ты ж не только, ну, понятно, что основной мейнстрим весь размечен.
3210.16 3224.80 "Игорь Лабутин" Дальше он отмечает штуку под названием development culture и говорит, что это вообще самый controversial topic, самый такой противоречивый и, наверное, самое большое различие между C# и Go, это именно культура с точки зрения разработки.
3224.80 3252.36 "Игорь Лабутин" В Go, понятно, значит, все за простоту, если что-то можно сделать просто, то мы не будем делать универсально, мы сделаем тупо и просто, чисто чтобы было достаточно для решения одной конкретной задачи, а в Дотнете, у него есть ощущение, по крайней мере, что в Дотнете все такие сфокусированы на гибкости и на расширяемости, то есть если мы пишем, так мы пишем так, чтобы эту библиотеку можно было использовать миллион способов всеми возможными клиентами, ну, в смысле, клиентами-потребителями,
3252.36 3258.96 "Анатолий Кулаков" а не так, что… Ну, а в Дотнете-то, да, не три с половиной калеки пишут на Дотнете, там полмира пишут, всех надо удовлетворить, конечно.
3258.96 3265.04 "Игорь Лабутин" Ну, даже если ты это делаешь внутри своего проекта, ты все равно напишешь универсально, а вдруг, вдруг через два года потребуется.
3265.04 3268.60 "Анатолий Кулаков" Конечно, ты же амбициозный разработчик, ты хочешь завоевать мир.
3268.60 3269.60 "Анатолий Кулаков" Конечно.
3269.60 3270.60 "Анатолий Кулаков" Даже пока если ты для самого себя пишешь.
3270.60 3271.60 "Игорь Лабутин" Да-да-да.
3271.60 3283.88 "Игорь Лабутин" Но при этом он отмечает, что в принципе C# язык такой разносторонний, поэтому если ты очень хочешь, ты можешь писать на C# в го-стиле, да, кратенько все это, ну, только ключевые слова длинные, а так как бы никто не мешает.
3283.88 3302.52 "Игорь Лабутин" Понятно, что там есть разница с точки зрения то, как реализованный интерфейс, да, вот эта вся типизация, ты не сможешь написать на C# так, как это пишется на Go, где интерфейсы объявляются, ну, по месту, грубо говоря, да, и класс не пишется, что он явно реализует интерфейс, а он реализует, если он подходит по форме.
3302.52 3308.60 "Игорь Лабутин" Но, да, в целом можно писать коды кратко.
3308.60 3309.96 "Игорь Лабутин" Дальше там были комментарии.
3309.96 3322.16 "Игорь Лабутин" В комментариях народ сказал, ну, конечно, там много кто отметил LingQ, там прям отдельный большой тред про LingQ, про то, что это вообще the best и без LingQ как бы все плохо.
3322.16 3323.16 "Игорь Лабутин" Вот.
3323.16 3332.72 "Игорь Лабутин" А дальше была отдельная ветка комментариев про то, что вообще C# изменяется, изменяется очень быстро, и это быстро — это типа плохо.
3332.72 3346.00 "Игорь Лабутин" То есть количество изменений в C#, оно сейчас довольно велико, ну, мы с одной стороны ругаемся, что их мало, с другой стороны, их много, но они все довольно узкоспециализированные.
3346.00 3347.00 "Игорь Лабутин" Вот.
3347.00 3356.04 "Игорь Лабутин" И вот это вот, может быть, немножко мешает восприятию языка, да, и как бы легкости его обучения, не знаю, переключения на него.
3356.04 3357.04 "Игорь Лабутин" Ну вот.
3357.04 3375.12 "Игорь Лабутин" А еще один интересный момент, который подметили, и я как-то не задумывался об этом, но действительно, наверное, соглашусь с этим трендом, что почему-то именно на дотнете много кто форсит вот это все вокруг там чистой архитектуры, DDD и прочего.
3375.12 3389.68 "Игорь Лабутин" Я ни в одном другом стеке, хотя я там статьи и всякие тематические кусочки читаю по разным стекам, ни в одном другом стеке я не видел такого количества статей вокруг там, как построить DDD на там Java или на Python, или еще на чем-нибудь.
3389.68 3393.04 "Игорь Лабутин" А вот на дотнете полно, почему-то.
3393.04 3399.92 "Анатолий Кулаков" У меня есть этому объяснение, потому что во всех других языках разработчики думают о том, как с этим говном жить.
3399.92 3414.60 "Анатолий Кулаков" А у нас, так как великолепный язык, великолепный фреймворк, великолепная поддержка, мы начинаем загоняться о более, знаешь, высокоуровневых вещах, то есть мы не как корку хлеба доесть, а как бы испечь пироженки и наслаждаясь лимонадом под солнышком и красиво съесть.
3414.60 3422.80 "Анатолий Кулаков" Вот DDD вот эти все и прочие высокоуровневые загоны, это про это, про чистую архитектуру, это вот с жиру бесимся называется.
3422.80 3426.16 "Анатолий Кулаков" Потому что все, что ниже лежащее, у нас и так прекрасно.
3426.16 3427.16 "Игорь Лабутин" Вот оно что.
3427.16 3428.16 "Игорь Лабутин" Вот оно.
3428.16 3430.16 "Игорь Лабутин" Все, я понял, я понял.
3430.16 3433.48 "Игорь Лабутин" Именно поэтому у нас на дотнете всяких таких докладов полно.
3433.48 3439.32 "Игорь Лабутин" Хотя посмотри на какой-нибудь Gpoint или там еще что-нибудь, там почти нет докладов про архитектуру DDD вот именно в таком понимании.
3439.32 3446.32 "Анатолий Кулаков" Так там зато множество докладов типа различите, что выполнит код, и нет, вы не угадали.
3446.32 3449.24 "Анатолий Кулаков" Такие доклады уже идут 10 лет, и они все время не повторяются.
3449.24 3454.76 "Анатолий Кулаков" Потому что в Java огромное количество как бы непредсказуемого поведения, дыр, багов, что там только нет.
3454.76 3456.16 "Анатолий Кулаков" В общем и про это можно делать доклады.
3456.16 3458.72 "Анатолий Кулаков" Дотнете сложно про это делать доклады, он прекрасен.
3458.72 3463.28 "Игорь Лабутин" Ну с одной стороны да, может быть просто с другой стороны мы не знаем всех этих дыр, багов и так далее.
3463.28 3467.52 "Игорь Лабутин" И кто-нибудь из команды разработчиков дотнета может такой доклад сделать, просто не хочет.
3467.52 3475.48 "Игорь Лабутин" Но с другой стороны у нас в дотнете нет там огромного количества докладов вида там выбери Quarkus, Micronaut, Spring или любой другой S.P.N.E.D.
3475.48 3476.48 "Игорь Лабутин" Фреймворк.
3476.48 3483.48 "Игорь Лабутин" У нас все берут S.P.N.E.D., потому что все остальные ну почти померли.
3483.48 3489.68 "Игорь Лабутин" Было какое-то количество назад времени хоть какие-то попытки, альтернативы сделать, но сейчас мне кажется кроме S.P.N.E.D.
3489.68 3490.68 "Игорь Лабутин" никто ничего не берёт.
3490.68 3491.68 "Игорь Лабутин" Поэтому...
3491.68 3501.08 "Анатолий Кулаков" Слушай, ну это же прекрасно, что у тебя есть какой-то дефолтный инструмент, который тебя удовлетворяет на 80%, но если ты хочешь, можно пойти посмотреть по сторонам и там куча всего ты можешь найти.
3501.08 3504.84 "Анатолий Кулаков" Не так, что везде по 10, да, у тебя вот есть 80.
3504.84 3512.20 "Анатолий Кулаков" Тебе понятно, что учить, допустим, если хочешь устроиться на работу, тебе понятно, что будет востребовано через 5 лет, если ты хочешь сюда вкладываться.
3512.20 3515.84 "Анатолий Кулаков" Тебе понятно, что использовать, если ты по дефолту какой-то проект хочешь.
3515.84 3516.84 "Игорь Лабутин" Ну, наверное, да.
3516.84 3522.48 "Игорь Лабутин" В США, в принципе, примерно так тоже есть, то есть условный спринг, я думаю, там тоже занимает огромное количество процентов.
3522.48 3523.48 "Игорь Лабутин" В ГО, я, кстати, не знаю.
3523.48 3530.44 "Игорь Лабутин" А в ГО, например, я не уверен, что есть какой-то дефолтный, условно говоря, там фреймворк в стиле S.P.N.E.D.
3530.44 3531.44 "Игорь Лабутин" Или что-то такого.
3531.44 3536.00 "Игорь Лабутин" Ну опять же, с их подходом к простоте, они там наверняка есть, но у каждого свой.
3536.00 3541.88 "Анатолий Кулаков" У них же ещё подход не только к простоте, но и про отсутствие фреймворков максимальное.
3541.88 3542.88 "Анатолий Кулаков" Ну да.
3542.88 3547.36 "Анатолий Кулаков" Они, наоборот, пытаются не вводить фреймворки, не вводить какие-то общие библиотеки.
3547.36 3550.96 "Анатолий Кулаков" У них больше концепция "копируй, если тебе надо, и изменяй под себя".
3550.96 3551.96 "Игорь Лабутин" Да.
3551.96 3555.80 "Игорь Лабутин" Это авторы языка, скорее, ну и такой как бы мейнстрим.
3555.80 3561.44 "Игорь Лабутин" Наверняка есть те, кто перешёл туда с какой-нибудь джавы, ну или с того же S.P.N.E.D., да, и хочет тоже фреймворк.
3561.44 3564.40 "Игорь Лабутин" Я думаю, что там наверняка есть такое на GitHub, если
3564.40 3565.40 "Анатолий Кулаков" поискать.
3565.40 3570.04 "Анатолий Кулаков" Мне кажется, их комьюнити очень быстро осадят, потому что от авторов языка идёт весь вайп на комьюнити.
3570.04 3576.92 "Анатолий Кулаков" И как бы основная масса сообщества смотрит, молится на авторов, как бы, и следует тому же самому пути.
3576.92 3577.92 "Игорь Лабутин" Может быть.
3577.92 3578.92 "Игорь Лабутин" Может быть.
3578.92 3579.92 "Игорь Лабутин" Ну, в общем, вот.
3579.92 3586.60 "Игорь Лабутин" Если вы вдруг почему-то слушаете нас, пишете на копии, ходите на дотнет или на C#, то тут прикольно.
3586.60 3592.84 "Игорь Лабутин" Можно, как говорит Толя, лежать, потягивать, что вы там будете потягивать, и думать про DDD.
3592.84 3595.60 "Игорь Лабутин" Давай, наверное, пойдём дальше.
3595.60 3598.40 "Игорь Лабутин" У нас ещё тут есть о чём поговорить.
3598.40 3603.20 "Анатолий Кулаков" Да, у нас есть про надёжность наших приложений.
3603.20 3614.76 "Анатолий Кулаков" Опять же, к тому же, если язык работает прекрасно, фрейворк работает прекрасно, нам приходится бороться с тем миром, который построили криворукие разработчики с других языков вокруг нас.
3614.76 3621.24 "Анатолий Кулаков" И поэтому мир не идеален, поэтому нам нужно как-то подстраиваться по тому, что у них там что-то падает.
3621.24 3634.16 "Анатолий Кулаков" И существует у нас такая хорошая статья, которая называется «А как построить устойчивые приложения на дотнете?» «Building Resilient Client Application with .NET».
3634.16 3639.28 "Анатолий Кулаков" Написал его Милан Йович, поэтому хороший автор, мы его уже не раз упоминали.
3639.28 3641.40 "Анатолий Кулаков" Давайте немножко пройдёмся по его советам.
3641.40 3646.96 "Анатолий Кулаков" Итак, в устойчивости приложений, зачем нам вообще нужны устойчивые приложения?
3646.96 3655.20 "Анатолий Кулаков" Ну, как я уже сказал, нетворк написан не идеально и не нами, поэтому иногда он падает.
3655.20 3659.32 "Анатолий Кулаков" Прерываются коннекты, иногда пропадает связь с другими серверами.
3659.32 3670.52 "Анатолий Кулаков" А другие сервера тоже могут быть написаны на всяких дурацких языках, которые иногда перегружаются, иногда у них бывают какие-то ошибки, поэтому сервера тоже выходят из строя.
3670.52 3678.52 "Анатолий Кулаков" Ну и вообще какие-то случайные ошибки могут встречаться в наших приложениях, особенно если мы выходим за рамки своего идеально написанного кода и пытаемся общаться с внешним миром.
3678.52 3691.12 "Анатолий Кулаков" В общем, и для того, чтобы общаться с внешним миром было более удобно и наши приложения работали более устойчиво, как раз и была придумана система различных Resilence стратегий.
3691.12 3716.48 "Анатолий Кулаков" То есть это такие приложения, которые считаются устойчивыми, они имеют возможность восстанавливаться после небольших сбоев, небольших каких-то перебоев или небольшого отказа тех ресурсов, к которым они обращаются, и продолжать функционировать по возможности, насколько это возможно, а после того, как эти ресурсы снова стали доступными.
3716.48 3737.08 "Анатолий Кулаков" Здесь интересно отметить, что устойчивые приложения, они должны именно проектироваться устойчивыми, то есть очень сложно потом какому-нибудь приложению, которое было написано без как бы думания о великом, без думания об устойчивости к разным нагрузкам, потом к нему прилепить каким-то образом всякие Resilence стратегии.
3737.08 3739.52 "Анатолий Кулаков" Возможно, но муторно и сложно.
3739.52 3750.04 "Анатолий Кулаков" Намного легче, если вы с самого начала, когда пишете свое приложение, уже задумываетесь о том, что мир не идеален, сеть не идеальная, любая коммуникация с какими-то сторонними сервисами может привести ваше приложение в крах.
3750.04 3751.60 "Анатолий Кулаков" Поэтому нужно что-то с этим делать.
3751.60 3755.64 "Анатолий Кулаков" Итак, давайте же посмотрим, а что с этим делать.
3755.64 3759.80 "Анатолий Кулаков" Ну, прежде всего, нас должны интересовать, наверное, HTTP-реквесты.
3759.80 3764.04 "Анатолий Кулаков" Это самая частая, самая распространенная форма общения, которая только существует.
3764.04 3771.00 "Анатолий Кулаков" Как я уже сказал, сеть падает, сервисы отмирают, и иногда узлы и роуты моргают.
3771.00 3772.72 "Анатолий Кулаков" В общем, с этим надо совсем нам что-то делать.
3772.72 3783.08 "Анатолий Кулаков" И Microsoft, и в частности, библиотека, на которую она опирается, поле предлагает несколько различных Resilence стратегий.
3783.08 3785.64 "Анатолий Кулаков" Ну, самые частые из них давайте рассмотрим.
3785.64 3786.92 "Анатолий Кулаков" Во-первых, это retry.
3786.92 3812.56 "Анатолий Кулаков" То есть, это хороший способ, например, если у вас отвалился какой-то внешний узел, к которому вы обращаетесь, к которым у вас складывают ресурсы, вам необходимо не просто сразу выдавать exception с криками «А, я ничего не могла, ничего не нашла», вам необходимо все-таки немножко подождать, попробовать еще раз, не получилось, может быть, еще раз попробовать, и так какое-то разумное число повторений, в зависимости от того, к какому ресурсу вы обращаетесь, попробовать несколько раз.
3812.56 3815.68 "Анатолий Кулаков" Еще одна интересная стратегия является timeout.
3815.68 3821.48 "Анатолий Кулаков" Timeout – это когда вы отменяете какую-то долгую операцию, если она вдруг не завершилась за какое-то разумное время.
3821.48 3831.52 "Анатолий Кулаков" То есть, вы не можете отправить свой реквест к какому-то серверу, и этот сервер будет что-то там делать долгие часы, дни и так далее.
3831.52 3839.68 "Анатолий Кулаков" Вам все-таки нужно иметь какой-то разумный баланс, на котором вы сошлетесь, сказав, что «нет, счет слишком долго, давайте не будем этого делать».
3839.68 3848.24 "Анатолий Кулаков" Следующей стратегией является fallback, когда вы возвращаете какой-то альтернативный результат операции, если вдруг она не смогла выполниться по плану.
3848.24 3854.28 "Анатолий Кулаков" Может быть, какая-то заглушка, какой-то пустой список, скажет пользователю, что типа «сорян, не смогла».
3854.28 3871.00 "Анатолий Кулаков" Еще одна интересная стратегия, которую можно применить – это выключатели, он же circle breakers – это специальный подход к проектированию, который позволяет вам отключить немножко сервер, на который сейчас идет слишком большая нагрузка, он не может вам, например, адекватно отвечать.
3871.00 3877.64 "Анатолий Кулаков" В общем, ваша задача – не давать ему еще больше нагрузки, чтобы он еще больше не мог вам адекватно ответить.
3877.64 3878.64 "Анатолий Кулаков" Для этого есть переключатели.
3878.64 3888.56 "Анатолий Кулаков" То есть, вы просто-напросто говорите, раз сервер немножко не здоров, давайте мы не будем на него немножко слать запросы, а просто попробуем подождать и после этого, может быть, еще раз отправим несколько запросиков.
3888.56 3903.84 "Анатолий Кулаков" Чтобы управлять различными вот этими стратегиями ресайлнса, в дотнете всегда существовала такая библиотека, как Polly, и наверняка, если вы хоть раз задавались этим вопросом, вы с этой библиотекой сталкивались.
3903.84 3909.40 "Анатолий Кулаков" И начиная с дотнет 8 появился новый интерфейс для общения с Полли.
3909.40 3919.44 "Анатолий Кулаков" Потому что там была Полли переписана прямо очень сильно и переписана была не просто так, а переписана была в содружестве с командой Майкрософта.
3919.44 3925.80 "Анатолий Кулаков" Майкрософт выпустил два новых пакета, которые называются Microsoft Extension Resilence и Microsoft Extension HTTP Resilence.
3925.80 3943.76 "Анатолий Кулаков" И, в общем, команда, которая писала о два этих пакета и команда Полли вместе работали очень-очень плотно для того, чтобы предоставить нам хороший, красивый, проверенный стандартный фреймворк, который мы можем просто использовать и не думая ни о чем плохом, как бы не загоняясь каким-то дурацким выбором.
3943.76 3951.60 "Анатолий Кулаков" Здесь все работает, все хорошо, прекрасные стратегии, коммуникацию они между собой сами настроили и все друг с другом сдружились.
3951.60 3961.92 "Анатолий Кулаков" Примечательно тот факт, что Полли прямо в версии 8 переделала все свои интерфейсы просто на мега breaking changes, то есть это практически другой фреймворк стал.
3961.92 3966.28 "Анатолий Кулаков" То есть очень хорошо прогнулась под Майкрософт для того, чтобы удовлетворить вот этим библиотекам.
3966.28 3975.20 "Анатолий Кулаков" Но результат, нужно сказать, довольно хорош, поэтому наверно спасибо обоим этим командам, что они договорились и мы как пользователи от этого только выиграли.
3975.20 3986.56 "Анатолий Кулаков" Если же вы используете предыдущую обертку над Полли, это Microsoft Extension HTTP Polly, которая называлась, то крайне рекомендуется всеми сторонами перейти на два вышеупомянутых пакета.
3986.56 3994.16 "Анатолий Кулаков" В общем, это новый итог развития, это правильное использование Полли и вот оно будет дальше развиваться.
3994.16 3996.56 "Анатолий Кулаков" Поэтому со старых интерфейсов лучше понемножку слезать.
3996.56 4002.84 "Анатолий Кулаков" Итак, как же нам построить наше отказоустойчивое приложение?
4002.84 4007.60 "Анатолий Кулаков" Прежде всего, нам необходимо сначала соорудить стратегию устойчивости.
4007.60 4011.48 "Анатолий Кулаков" Для этого нам нужно построить pipeline.
4011.48 4017.84 "Анатолий Кулаков" Pipeline состоит из различных стратегий, примерно из которых я описал выше, какие стратегии у нас могли бы быть.
4017.84 4027.12 "Анатолий Кулаков" Также нужно обязательно помнить о порядке следования этих стратегий, потому что от этого зависит именно в какой последовательности они будут применяться, ну и соответственно результат, который вы получите.
4027.12 4038.64 "Анатолий Кулаков" Для того, чтобы в коде построить вам вот этот ResilientPipeline, вам необходимо создать класс ResilientPipelineBuilder и ему уже назначить различные стратегии.
4038.64 4047.88 "Анатолий Кулаков" Ну, допустим, как мы выше упомянули, если мы хотим какую-то retry стратегию, которая повторяет наш запрос несколько раз до тех пор, пока ресурс не станет доступным.
4047.88 4056.84 "Анатолий Кулаков" Для этого необходимо вызвать метод addRetry у этого билдера и передать ему параметры, с которыми этот retry должен происходить.
4056.84 4067.54 "Анатолий Кулаков" Ну, например, у параметров есть свойство, которое называется ShootHandle, которое может определить, на какие exceptions мы должны реагировать для того, чтобы этот retry запускать.
4067.54 4072.36 "Анатолий Кулаков" У нас есть, мы можем настроить, например, delay, то есть сколько нужно ждать.
4072.36 4076.20 "Анатолий Кулаков" Мы можем выбрать стратегию ожидания, например, ждать экспоненциально.
4076.20 4094.44 "Анатолий Кулаков" Мы можем выбрать, а сколько раз мы должны подождать, сколько раз мы должны попытаться, в общем, настроить вот эту политику retry, политику повторов, довольно гибко и, я думаю, можно выразить абсолютно любую стратегию, которую вы хотите, вот прямо с помощью этих параметров.
4094.44 4103.26 "Анатолий Кулаков" Если вдруг у вас это не получится, то всегда можно подменить на свою стратегию и реализовать абсолютно любой алгоритм повтора, который только вам из головы взбредет.
4103.26 4123.32 "Анатолий Кулаков" Следующим элементом этого pipeline, следующей стратегией уже может стать, например, элемент timeout, то есть, допустим, если вдруг запрос не закончился за какое-то разумное время, мы должны прервать нашу операцию, никакого смысла как бы дальше ждать, скорее всего, нет, это может быть просто завис в каком-нибудь нетворке.
4123.32 4128.84 "Анатолий Кулаков" Timeout заканчивается с помощью выбрасывания исключения timeout, reject, exception, в общем, это надо иметь в виду.
4128.84 4133.64 "Анатолий Кулаков" В общем, и вот таких вот блоков можно наградить сколько вашей душеньке угодно.
4133.64 4146.48 "Анатолий Кулаков" В конце, после того, как вы закончили забрасывать вашу стратегию, вам необходимо у pipeline вызвать метод build и он вернет вам resilient pipeline, то есть уже готовый pipeline, на основании которого вы можете делать свои запуски.
4146.48 4147.60 "Анатолий Кулаков" Как это применяется?
4147.60 4155.44 "Анатолий Кулаков" Вы берете pipeline, вызываете у него метод execute и в этот метод execute передаете некий делегат, который должен отработать.
4155.44 4166.16 "Анатолий Кулаков" В частности, обычно туда передают http client с каким-нибудь методом get_async, допустим, для того, чтобы просто достать url по http методу get.
4166.16 4177.28 "Анатолий Кулаков" Если этот url просто таки красиво достается с первого раза, то никаких проблем нет, pipeline как бы ничего делать не будет, просто вернет вам результат, работает это в http client и все будут счастливы.
4177.28 4201.08 "Анатолий Кулаков" Но если вдруг результат работы вашего http клиента начнет бросать какие-то exceptions, начнет выдавать какие-то проблемы с сетью или с недоступным ресурсом на конечной точке, то в этот момент включится resilient pipeline, включатся все его стратегии, которые вы законфигурировали и в этот момент пойдут делаться все эти retry, timeout, cancel и прочее, прочее, прочее.
4201.08 4206.52 "Анатолий Кулаков" В общем, вот такая вот интересная оберточка, грубо говоря, на http клиентам у нас получилась.
4206.52 4231.56 "Анатолий Кулаков" В принципе, хорошая вещь, но в старом подходе, когда вы вот такие оберточки начинали делать, они довольно некрасиво расползались по всему вашему приложению и непонятно было, в общем, вам нужно построить какой-то пайплайн и обычно, в принципе, этот пайплайн вполне может быть для какой-то группы ваших запросов, допустим, для какого-то конкретного сервера, к которому вы обращаетесь, он вполне может быть одинаковый для всех его запросов.
4231.56 4239.84 "Анатолий Кулаков" Но в каком классе его хранить, как его распространять, где его настраивать, в общем, все это было довольно муторно, все это собиралось в какие-то статические классы, какие-то статические группы.
4239.84 4247.48 "Анатолий Кулаков" В общем, не по-человечески, нет, не должно быть в таком прекрасном языке, такие дурацкие подходы.
4247.48 4257.40 "Анатолий Кулаков" В ПК должно быть в прекрасном языке, а в прекрасном языке должен быть DI-контейнер, который хранит всякие классики, которые вы можете использовать во всяких других классиках.
4257.40 4276.24 "Анатолий Кулаков" Вот в восьмом дотнете у нас появились новые экстеншн-методы к сервис-коллекшену, которые называются AddResilientPipeline, и как раз этот метод позволяет вам настроить и зарегистрировать и настроить вот этот ResilientPipeline с учетом всех dependency-injections, которые у вас есть.
4276.24 4282.56 "Анатолий Кулаков" То есть настройки делаются таким же точным образом, как я описал выше, но только они уже настраиваются непосредственно к сервис-коллекшену.
4282.56 4294.24 "Анатолий Кулаков" Из тонкостей, когда вы настраиваете какой-то pipeline, вы должны задать ему какой-то уникальный ключ, какой-то строковой уникальный ключ, по которому вы будете его потом из контейнера запрашивать.
4294.24 4325.84 "Анатолий Кулаков" Для того, чтобы заиспользовать вот этот настроенный в контейнере pipeline, вам необходимо в вашем классе запросить зависимость, которая называется AddResilientPipelineProvider, вызвать у провайдера метод getPipeline, передать в getPipeline тот самый уникальный ключ, под которым вы настроили ваш pipeline, и таким образом вы получите pipeline, у которого есть уже упомянутый метод executeAsync, в который мы можем передать уже упомянутый делегат с HTTP-клиентом и работать так же, как мы привыкли раньше.
4325.84 4332.32 "Анатолий Кулаков" Но теперь мы не следим, куда положить эти классики, а все настраивается и хранится удобно в нашем контейнере.
4332.32 4335.92 "Анатолий Кулаков" Плюс там же все зависимости, плюс там же все конфигурации.
4335.92 4339.84 "Анатолий Кулаков" В общем, довольно удобно и красиво все получается.
4339.84 4344.44 "Анатолий Кулаков" Давайте еще раз посмотрим на стратегии, которые есть у Поли.
4344.44 4348.96 "Анатолий Кулаков" Вообще, все эти Resilient стратегии, это такие ключевые компоненты Поли.
4348.96 4360.72 "Анатолий Кулаков" И они очень хорошо расписаны у него на сайте, они очень хорошо описаны в документации, в мануалах во всяких, в Stack Overflow, в видосиках, в общем, очень мощные и очень хорошо описанные стратегии.
4360.72 4363.52 "Анатолий Кулаков" Если вам нужно, то обязательно посмотрите и почитайте.
4363.52 4371.96 "Анатолий Кулаков" Итак, эти стратегии все, они могут не только включаться в pipeline, как я описал, эти стратегии могут еще и работать просто как компонент.
4371.96 4377.28 "Анатолий Кулаков" В общем, вам надо поретрайить, вы просто взяли ретрай стратегию, запустили ее без всякого pipeline и пошли ретрайтить.
4377.28 4386.16 "Анатолий Кулаков" В общем, ну, конечно, вся их сила возникает, когда вы их объединяете вместе, в общем, в один такой хороший, понятный, линейный pipeline.
4386.16 4391.16 "Анатолий Кулаков" Поли внутри себя выделяет две категории подобных стратегий.
4391.16 4401.64 "Анатолий Кулаков" Это реактивные стратегии, это которые обрабатывают специфические exceptions или результаты и упреждающие, проактивные стратегии.
4401.64 4412.64 "Анатолий Кулаков" Это которые могут отменять какие-то запросы, лимитировать или каким-то образом другим ограничивать выполнение этих запросов.
4412.64 4420.32 "Анатолий Кулаков" В поле встроено много всяких стратегий по умолчанию в библиотеку.
4420.32 4422.60 "Анатолий Кулаков" Давайте посмотрим, какие есть самые используемые.
4422.60 4433.56 "Анатолий Кулаков" Ну, прежде всего, это ретрай, про который мы уже не раз вспоминали, выключатель, который помогает сделать так, чтобы система не умерла еще больше и дать ей время на восстановление.
4433.56 4439.98 "Анатолий Кулаков" Фуллбэк, который предоставляет результат, какой-то безопасный результат.
4439.98 4450.52 "Анатолий Кулаков" Если вдруг у вас основной метод, который должен был доставить данные, завершился с ошибкой, то в фуллбэке вы можете дать какой-то результат, который удовлетворит ваших потребителей.
4450.52 4451.52 "Анатолий Кулаков" Хеджирование.
4451.52 4458.92 "Анатолий Кулаков" Это интересная стратегия, когда, допустим, у вас есть несколько сервисов, которые могут отдать вам данные, одни и те же данные.
4458.92 4464.48 "Анатолий Кулаков" И вы делаете несколько запросов во все эти сервисы одновременно.
4464.48 4472.22 "Анатолий Кулаков" И тот сервис, который вернет вам ответ первым, вот тот ответ вы и забираете, а все остальные ответы просто игнорируете.
4472.22 4476.96 "Анатолий Кулаков" То есть, по сути, вы размениваете ресурсы, которые есть в вашей сети, и вы размениваете на скорость.
4476.96 4479.56 "Анатолий Кулаков" Очень часто это бывает довольно оправданным.
4479.56 4489.96 "Анатолий Кулаков" Вы ставите там 10 серверов, 9 из этих серверов может быть в данный момент нагружены, а вот 10 вполне может вам ответить быстро из какого-нибудь горячего кэша, и вот он первым отвечает.
4489.96 4498.80 "Анатолий Кулаков" И, в принципе, вам все равно, что у вас там 9 других серверов продолжают выполнять ваш запрос, вам главное, что 10 ответил, вы быстренько можете клиенту вернуть ответ.
4498.80 4503.40 "Анатолий Кулаков" То есть хеджирование тоже очень частый такой паттерн, который используется.
4503.40 4516.02 "Анатолий Кулаков" Стратегия timeout, которая как раз способна предотвратить долгие зависания, долгие какие-то реквесты и оборвать запрос, который выполняется непомерно долго.
4516.02 4529.64 "Анатолий Кулаков" А rate limiter, который позволяет каким-то образом троттлить реквесты и предотвратить, например, необузданную нагрузку на сервер, каким-то образом сгруппировать там эти запросы, допустим, по какому-нибудь троттлингу.
4529.64 4534.36 "Анатолий Кулаков" В общем, вот такие основные стратегии, которые вы скорее всего можете использовать.
4534.36 4556.92 "Анатолий Кулаков" Для неискушенного зрителя, который никогда не вникал во всякие resilience проблемы, там и всякие проблемы с нетворками, с клиентами, с сервисами, это все может звучать довольно сложно, но сделать ваше приложение устойчивым к сбоям, в принципе, это хорошее валидное желание любого разработчика.
4556.92 4567.64 "Анатолий Кулаков" И вот как раз для тех разработчиков, которые сильно вникать не хотят, но хотят, чтобы было хорошо и красиво, Microsoft и выпустила пакет, который называется Microsoft Extension HTTP Resilience.
4567.64 4583.36 "Анатолий Кулаков" Это библиотека, в которой собраны уже готовые к употреблению пайплайны, уже настроенные профессионалами, уже протестированные микрософтами, уже одобренными сообществами и просто запихнутые в красивый пакетик для HTTP-реквестов.
4583.36 4594.04 "Анатолий Кулаков" Например, вы можете в сервисах настроить свой HTTP-клайнт, как вы обычно настраиваете с помощью метода addHTTPClient и вызвать еще один метод здесь же, который называется addStandardResilenceHandler.
4594.04 4601.56 "Анатолий Кулаков" Вот так вот незамысловато, просто добавьте мне стандартный пожалуйста ресайлент и все, больше ничего знать не хочу.
4601.56 4628.48 "Анатолий Кулаков" И вот этот standardResilenceHandler, он добавляет специальные обработчики, вот этот специальный пайплайн, который подходит для большинства случаев, у него там есть и ретрай, у него там есть и тайм-ауты, в общем, практически все те стратегии, которые мы описали, которые я описал, они там довольно хорошо сконфигурированы с некими дефолтами в среднем, которые подходят по больнице.
4628.48 4646.72 "Анатолий Кулаков" Если вам какие-то средние дефолты по больнице не очень подходят и вы хотите их подконфигурить, тоже никаких проблем нет, это делается с помощью настройки HttpStandardResilentOptions, просто в опциях выставляете какие-то флажочки, которые вам нужны и стандартный ResilenceHandler уже ведет себя немножко по-другому.
4646.72 4660.56 "Анатолий Кулаков" Если же вы хотите прям тонкую настройку под количество ретраев, под время тайм-аутов и так далее, то для этого вот вышеупомянутый абзац, настраивайте свои пайплайны, как вам ваше душе угодно.
4660.56 4670.72 "Анатолий Кулаков" Если же вы хотите просто и быстро и красиво, то вот есть стандартные уже приконфигурированные Microsoft рекомендации, их вполне можно не думая включать и смотреть что получится.
4670.72 4672.20 "Анатолий Кулаков" Скорее всего хуже точно не будет.
4672.20 4686.24 "Анатолий Кулаков" В общем так, делайте свои приложения устойчивыми, пишите надежный код как раз, чтобы мы могли думать о DDD, чистых архитектурах и прочем безобразии, а не вспоминать о том, как плохо работают сети и окружающие нас сервера.
4686.24 4693.80 "Игорь Лабутин" Но в дотнете они будут работать идеально, они же знают, что к ним обращаются дотнетчики и сразу будут вести себя как положено.
4693.80 4702.28 "Игорь Лабутин" Ну а вообще да, тема нужная и важная, и хорошо, что в этом направлении делают так, чтобы было поудобнее все это дело.
4702.28 4711.92 "Игорь Лабутин" Так, давай пойдем на нашу любимую тему, кратко-разную, в этот раз у нас, наверное, достаточно кратко, но довольно много о чем разном.
4711.92 4718.32 "Игорь Лабутин" Во-первых, вышла Uno платформ, обновилась, новый релиз, релиз 6.0.
4718.32 4724.32 "Игорь Лабутин" И это довольно важный релиз, потому что вместе с релизом они релизят свою Uno Platform Studio.
4724.32 4733.76 "Игорь Лабутин" Напомню, что Uno Platform — это такой кроссплатформенный UI-фреймворк, который позволяет писать всякие штуки для Windows, ну короче, десктопа и не только десктопа.
4733.76 4748.92 "Игорь Лабутин" И сам по себе Uno Platform открытый, он open-source, под лицензией Apache 2.0, но при этом у них есть их не open-source как раз продукт Studio, который General Availability достиг таки, и вот он платный.
4748.92 4755.28 "Игорь Лабутин" То есть если вы хотите визуальный дизайнер по Uno Platform, ну тогда нужно заплатить им сколько-то денег за студию, вот эту самую их.
4755.28 4771.08 "Игорь Лабутин" А иначе, в принципе, абсолютно бесплатный, причем у них позиция такая, что тулинг как бы за деньги, все компоненты, то есть у них, ну как у нас обычно было, если ты помнишь, старые десктопные времена, там типа все хорошие гриды и прочее, они были платными, да, DevExpress, там вот это все, наборы контролов.
4771.08 4791.80 "Игорь Лабутин" У этих ребят позиция такая, что мы стараемся сделать все контроллы бесплатными, то есть всякие там гриды и прочее у них все есть, ну насколько они там крутые, я уж не знаю, но есть, входят в стандартный open-source пакет, а вот тулинг в виде удобного дизайнера, да, ну он как бы за деньги, ну в принципе нормально, вроде живет.
4791.80 4795.72 "Игорь Лабутин" Если вдруг вам нужен кроссплатформенный UI, в принципе тоже вариант.
4795.72 4806.72 "Игорь Лабутин" А вторая новость заключается в том, что мы в этом выпуске еще ни разу не упомянули .NET Aspire, и кажется пришла пора это сделать.
4806.72 4862.84 "Игорь Лабутин" Дэвид Фаулер опубликовал гист, он вернулся от статей к медиуму, на медиуме, к своему любимому формату гистов, и там появился гист под названием Aspire Resource Model Concept, Design and Authoring Guidance, то есть это такой довольно краткий экранов на 15 гайд, где в довольно сжатой форме описана собственно модель Aspire, с точки зрения ресурсной модели, и примеры того, как правильно ее конфигурировать, как правильно ее использовать из C# кода, и на самом деле эта штука, она написана не просто как дополнение к документации, у Aspire в принципе неплохая документация, она написана с одной простой и понятной целью, этот MD файлик, напомню, это просто гист, там один MD файлик, можно тупо закинуть в LLM, после чего LLM знает, как работать с Aspire, то есть это уже как бы такое дистиллированное знание, которое можно вот эзыз запихнуть в LLM, если вы хотите.
4862.84 4865.04 "Анатолий Кулаков" Он писал реально с этой целью, да?
4865.04 4866.04 "Анатолий Кулаков" Да, да-да-да.
4866.04 4867.04 "Анатолий Кулаков" Прикольно.
4867.04 4883.48 "Игорь Лабутин" То есть кажется, что это вот, ну, по крайней мере, я не знаю уж прям только ли с этой целью, но прям он, по-моему, сам в Твиттере это публиковал, если вам нужно что-то в LLM-ке рассказать про Aspire, вот вам гист, его закидывайте, там вся информация про ресурс модель.
4883.48 4895.16 "Анатолий Кулаков" Слушай, мне, знаешь, у Aspire с Fowler сложилось такое впечатление, что на Medium его загоняют менеджеры, потому что все статьи, которые он пишет там, они такие довольно короткие и довольно поверхностные, в общем, ничего там глубокого никогда нет.
4895.16 4902.56 "Анатолий Кулаков" А вот в гисты, если залазишь, там вот реально на 15 экранов такие код, диаграммы, стрелочки, ссылочки, прям хочется сидеть и читать.
4902.56 4907.60 "Игорь Лабутин" Ну, видимо, потому что их действительно как-то удобнее писать, не знаю, приятнее.
4907.60 4913.64 "Игорь Лабутин" Или не нужно, да, всяким заниматься оптимизацией маркетинговых показателей или еще что-нибудь в таком духе.
4913.64 4923.72 "Анатолий Кулаков" При том, что существует огромное количество тилзов, которые могут там из GitHub Pages, из гистов тебе экспортировать хоть в Medium, хоть в WordPress, хоть куда угодно, настроить там 5 минут.
4923.72 4930.88 "Игорь Лабутин" И еще и переписать по пути лолэмкой в нормальный вид, типа сделай это нормальной большой статьей и так далее.
4930.88 4932.64 "Игорь Лабутин" Она еще и чат ГПТД пишет.
4932.64 4935.88 "Анатолий Кулаков" Да нет, у нее нормальные статьи в гистах, в принципе, они довольно полноценные.
4935.88 4942.64 "Игорь Лабутин" Ну, видимо, на Medium, может, такое не зайдет, слишком технично будет, я не знаю, наверное, там есть свои особенности.
4942.64 4954.04 "Игорь Лабутин" Вот, и последняя ссылочка, которую на сегодня я хочу поделиться, это видосик, ну, это называется Meetup или подкастом, я бы это не назвал ни тем, ни тем.
4954.04 4971.40 "Игорь Лабутин" Короче, компания Evron занимается сейчас, тема одна из ее, ну, публичных, по крайней мере, видов деятельности, то, что она проводит такие микро, ну не микро, там больше часа разговора на тему всех, плюс-минус всех современных платформ.
4971.40 5046.88 "Игорь Лабутин" То есть у них был такой микро-митап с представителями джава-платформы, про битон они разговаривали, про GOPA они разговаривали, и вот настала очередь дотнета, и, соответственно, там видео, называется это DotNet 2025 с Андреем Парамоновым и Марком Шевченко, наверное, небезызвестными людьми в дотнет-комьюнити, где они обсуждают вообще состояние дел в дотнете в 2025 году, обсудили, насколько там как бы рейтинг языка, куда он идет, вверх-вниз, насколько хорошо учить C# как первый язык, затронули тему той самой любительства DDDM, про которую мы сегодня уже говорили, поговорили о том, чего в принципе не хватает, конечно же упомянули Discriminated Union, ну куда же без него, поговорили про ниши, поговорили про другие языки на платформе, которых в общем-то нету, ну и поговорили про развитие C#, в принципе, посмотрели и со стороны как бы и что хорошо, и что не очень хорошо, то есть такой довольно, ну неплохой обзор современного состояния дотнета, как мне показалось, по крайней мере, возможно, вы посмотрите и скажете, что там все не так, и вообще все я не прав, и если я не прав, то оставьте там под видео комментарии, будет интересно почитать.
5046.88 5047.88 "Игорь Лабутин" Вот.
5047.88 5063.36 "Анатолий Кулаков" Ну, я еще не смотрел, но в принципе Андрей и Марк, это довольно известные специалисты в сообществе, я уверен, что наговорили немного всего хорошего, поэтому я думаю, нам надо загнать и поставить хороший комментарий у людей, не зря старались.
5063.36 5066.68 "Анатолий Кулаков" Так, у меня тут тоже что-то было, да?
5066.68 5067.68 "Анатолий Кулаков" Сейчас проверим.
5067.68 5140.28 "Анатолий Кулаков" Да, один из наших слушателей, за что ему огромное спасибо, принес нам интересную тулзу, которая называется медиатор, это как раз хорошая замена медиатору Богорта, которую мы обсуждали пару выпусков назад, замена прекрасна тем, что она генерит реализацию всех вот этих, как там называется, пайплайнов или хендлеров, пайплайнов по-моему, пайплайнов, которые оригинальный богортовский медиатор делает через рефлекшн, вот это делает с помощью сорс-генераторов, и генерирует она их довольно точно и довольно совместимо с богортовским, то есть как вещи для перехода в принципе прекрасно, более того, не только для перехода лишь, потому что все эти сгенерированные пайплайны, они хорошо исследуются кодом, хорошо исследуются интеллисенсом, и вы можете посмотреть как бы, что внутри делается и какой хендлер вызывается, поэтому просто даже пользоваться приятно, даже на повседневной основе, даже если вы не хотите переходить, а просто хотите использовать какую-то замену для медиатора, в общем, инструмент интересный, обязательно на него посмотрите.
5140.28 5202.24 "Анатолий Кулаков" Следующий ресурс, который нам принесли наши слушатели в чатике, это ByteByGo System Design, существует такая конторка ByteByGo, я в принципе на нее подписан уже много-много лет, сейчас расскажу зачем подписан, в общем, прежде всего мы вам дадим ссылочку на GitHub репозиторий, и в этом репозитории лежит куча различных их статей, у них есть блог, и в этом блоге они выкладывают разные статьи, чтобы вы понимали, это статейки, очень полезные статьи, которые описывают различные алгоритмы, системы, еще что-то, и статьи буквально на 1-2 минуты, они очень простые, и самое главное, они очень наглядные, т.е. как любая их статья в основном упирает на визуализацию, т.е. очень много картиночек, стрелочек, очень часто много анимации, поэтому если вы мега-ленивый, ну как я, например, мега-ленивый, и вам хочется тратить каждый день, допустим, 1-2 минуты и изучать, устаканивать или вспоминать какую-то технологию, то вот это идеальный ресурс, который вам позволит это сделать.
5202.24 5211.24 "Анатолий Кулаков" Что у них есть, ну, вообще, в принципе, все, невозможно ни словом описать, что у них есть про IT, в общем, для IT-разработчиков, вообще все.
5211.24 5229.08 "Анатолий Кулаков" Например, есть статьи, допустим, как работает load balancer, что такое gRPC, какие полисы есть для traffic routing, что такое reverse proxy, чем он отличается от API gateway и load balancing, top 12 API security советов.
5229.08 5254.96 "Анатолий Кулаков" Также у них есть обзоры различных компаний больших, как они работают, например, как устроен связь и Devubery, какой текст-тек используется в Твиттере, как юзают базы данных в Нетфликсе и, в общем, например, по архитектуре различных решений, например, как устроены базы данных, чем там базы данных реляционные отличаются от документных, от векторных и прочего там.
5254.96 5263.80 "Анатолий Кулаков" Различные разделы под security архитектуру, всякие security, security, clean architecture, DDD там, все вот это там есть.
5263.80 5272.92 "Анатолий Кулаков" Devtools и продуктивность, дата структуры алгоритмы, DevOps, ACI, security, в общем, это все только заголовки разделов.
5272.92 5275.36 "Анатолий Кулаков" На самом деле статей там, не знаю, сотни.
5275.36 5283.56 "Анатолий Кулаков" Я не представляю, какая команда там все это пишет, видно там только одного человека, я надеюсь, что не один все это делает, потому что работа там действительно гигантская.
5283.56 5292.88 "Анатолий Кулаков" А, и как я это использую, я уже несколько лет просто подписан на их newsletter, у них есть такая рассылочка интересная, которая присылает вам с периодичностью там какое-то письмецо.
5292.88 5299.28 "Анатолий Кулаков" И в этом письме там, опять же, на одну-две минутки описывается несколько вот подобных тем.
5299.28 5306.96 "Анатолий Кулаков" Например, как устроена там пирамидальная сортировка плюс уберовский стэк и плюс оптимизации в Load Balancer.
5306.96 5316.38 "Анатолий Кулаков" И вот там даются такие три темки, буквально две минутки ты глазами пробегаешь, и уже в голове как-то мысли зашевелились, уже как бы чай с утра хочется пить гораздо бодрее.
5316.38 5318.64 "Анатолий Кулаков" В общем, это как один из use-кейсов.
5318.64 5324.20 "Анатолий Кулаков" Если же вы просто хотите зайти и поискать какие-то интересные темы, вот просто зайдите на GitHub и посмотрите на этот список.
5324.20 5327.72 "Анатолий Кулаков" Я думаю, парочку тем, на которые вам захочется тыкнуть, вы обязательно найдете.
5327.72 5328.72 "Игорь Лабутин" Следующий ресурс.
5328.72 5340.08 "Игорь Лабутин" Сейчас, я еще хочу добавить, что вот тот чувак, который, как ты говоришь, который ты видишь, это тот самый Алекс Ксю, который написал книжку про систем дизайн, которую в подкасте обсуждали.
5340.08 5345.36 "Анатолий Кулаков" Мы его обсуждали в подкасте закрытого клуба, ты имеешь в виду?
5345.36 5346.36 "Анатолий Кулаков" Нет, это который обсуждали…
5346.36 5347.36 "Игорь Лабутин" В этом подкасте мы не обсуждали.
5347.36 5351.84 "Игорь Лабутин" Не в этом подкасте, а в другом подкасте, про книжный клуб.
5351.84 5356.76 "Игорь Лабутин" Как раз таки систем дизайн, Алекс Ксю, это вот тот самый чувак, который… Точно, точно.
5356.76 5369.52 "Анатолий Кулаков" Мы заводили кучу подкастов, поэтому не забывайте, у нас есть книжный клуб с систем дизайном, у нас есть наши закрытые подкасты, доступные на Boosty, мы там тоже обсуждали интервью с систем дизайном, Алексом Ксю в частности.
5369.52 5370.52 "Анатолий Кулаков" Ну и в принципе, да.
5370.52 5379.28 "Анатолий Кулаков" Этот чувак – это он, поэтому неудивительно, что он много всего интересного знает и вот таким образом делится сообществом такими интересными статейчиками и визуализацией.
5379.28 5386.00 "Анатолий Кулаков" Но я все еще надеюсь, что ему тут помогает, что он не один, потому что иначе мне его жалко просто.
5386.00 5390.92 "Анатолий Кулаков" Давай, следующие ресурсы – это парочка ресурсов по визуализации алгоритмов.
5390.92 5400.72 "Анатолий Кулаков" Опять же, алгоритмы бывают сложно воспринимать на слух, может быть, сложно воспринимать в коде, но обычно алгоритмы довольно легко воспринимаются визуально.
5400.72 5415.24 "Анатолий Кулаков" Поэтому если вы захотите посмотреть, например, как работает сортировочка пузырьком на YouTube в виде видосика или, может быть, в виде анимированного какого-то графика, то вот есть специализированные сайты, и я расскажу про парочку из них.
5415.24 5416.96 "Анатолий Кулаков" Это, например, Visual Go.
5416.96 5427.08 "Анатолий Кулаков" Там есть много интересных алгоритмов, которые можно визуализировать, потрогать, подтюнить, работать с массивами, связанными списками, графами, сортировки, как работает префиксное дерево.
5427.08 5430.72 "Анатолий Кулаков" В общем, очень наглядно, в принципе, и познавательно просто так.
5430.72 5440.12 "Анатолий Кулаков" Если не нужно вам изучить какой-то алгоритм, а просто потыкать и посмотреть на классную анимацию, вот это тоже нормальный стимул туда зайти, а там, глядишь, может, что-то и хорошее получится.
5440.12 5449.56 "Анатолий Кулаков" Он показывает, например, алгоритмы на псевдоязыке, поэтому независимо от того, на каком языке вы пишете или знаете, в общем, там все довольно можно легко разобраться.
5449.56 5453.04 "Анатолий Кулаков" Минус этого сайта в том, что алгоритмов довольно мало.
5453.04 5457.16 "Анатолий Кулаков" Есть еще алгоритм-визуалайзер сайт, это тоже самое, но на JavaScript.
5457.16 5459.80 "Анатолий Кулаков" Там больше алгоритмов, но на JavaScript.
5459.80 5463.60 "Анатолий Кулаков" Там есть возможность редактировать примеры, там писать свои, но, к сожалению, только на JavaScript.
5463.60 5468.32 "Анатолий Кулаков" Ну, в общем, те, которые уже есть, в принципе, довольно можно смотреть.
5468.32 5476.76 "Анатолий Кулаков" В общем, много существует таких сайтов с алгоритмами, но я лишний раз просто хочу вам напомнить, опять же, если вдруг нечего делать, зайдите, потыкайте, посмотрите.
5476.76 5478.52 "Анатолий Кулаков" Это вполне залипательная штука.
5478.52 5485.20 "Анатолий Кулаков" Я даже встречал на YouTube ролики, как алгоритмы сортировки выразить с помощью танца.
5485.20 5492.36 "Анатолий Кулаков" То есть люди танцуют в сортировке пузырьков там или танцуют Bin Research, тоже довольно прикольно.
5492.36 5498.88 "Анатолий Кулаков" Если вы знаете какие-то еще интересные сайты про визуализацию алгоритмов, то пишите в комментариях.
5498.88 5499.88 "Анатолий Кулаков" Про SICK.
5499.88 5501.76 "Анатолий Кулаков" Вышел, наконец, SICK Clustering.
5501.76 5508.60 "Анатолий Кулаков" В общем, SICK – это сервер, который может агрегировать в себе логи, метрики, трассировки.
5508.60 5516.68 "Анатолий Кулаков" Довольно крутецкий сервер, я бы сказал, что это самый удобный сервер логов, который я просто знаю, и я знаю очень много людей, которые используют именно поэтому.
5516.68 5521.16 "Анатолий Кулаков" Хочется упомянуть эту новость, потому что SICK Clustering ждали многие-многие годы.
5521.16 5524.68 "Анатолий Кулаков" Это, в общем, большое событие.
5524.68 5537.88 "Анатолий Кулаков" High availability, scale out, индексирование между всеми нодами и запросы можно делать всеми нодами, то есть запросы практически линейно как бы масштабируются, если вы поднимаете новых нод.
5537.88 5539.32 "Анатолий Кулаков" В общем, классное достижение.
5539.32 5550.12 "Анатолий Кулаков" Единственное, что довольно-таки поздновато, если бы как раз вышел он во времена, когда Grafana становилась, когда ELCASTEC становился, то, может быть, мы сейчас бы имели совсем других лидеров на рынке.
5550.12 5553.32 "Анатолий Кулаков" Но, к сожалению, я думаю, что довольно поздновато.
5553.32 5558.40 "Анатолий Кулаков" Но, опять же, тем людям, кто пользуется SICK, я знаю, таких много, в общем, всем радоваться.
5558.40 5566.44 "Анатолий Кулаков" Еще хочется упомянуть, мы, по-моему, в прошлом выпуске обсуждали статью Эндрю Лока про то, как сделать свой lifetime.
5566.44 5573.08 "Анатолий Кулаков" И там мы как раз обсуждали Timed Lifetime, который живет там относительно какой-то промежуток времени.
5573.08 5587.24 "Анатолий Кулаков" Вот, Эндрю Лок собирался написать еще два Lifetime, и вот второй он написал, это Lifetime Pulled, то есть когда вы объекты не создаете, а берете из какого-то пула, а потом возвращаете в этот пул.
5587.24 5596.56 "Анатолий Кулаков" Например, так делает EFDB Context, так делает с многими какими объектами сам ISP, в общем, очень много кто так делает.
5596.56 5605.12 "Анатолий Кулаков" Особенно, если у вас вдруг вы упелись в какие-то high performance, high load и прочие-прочие, high-high, то вот там без пула вам никак не обойтись.
5605.12 5614.60 "Анатолий Кулаков" В общем, и, может быть, как один из извращенных вариантов вы захотите делать пул сразу из DI-контейнера, но почему бы и нет.
5614.60 5623.00 "Анатолий Кулаков" Как это самому реализовать, где применить, с кодом, описаниями, подводными камнями, в общем, это я предлагаю почитать самим.
5623.00 5628.32 "Анатолий Кулаков" Пересказать эту статью, опять же, особого смысла нет, потому что она сильно похожа на прошлую, а прошлую мы довольно конкретно обсудили.
5628.32 5636.56 "Анатолий Кулаков" Так, кажется, это кратко подошло к концу, надеюсь, на сегодня ничего не забыли, но, если что, в следующий выпуск мы обязательно вернемся.
5636.56 5645.16 "Анатолий Кулаков" А вы, кстати, приносите нам новые библиотеки, новые статьи и новые интересные какие-нибудь замечательные фишки, которые мы тоже сможем упомянуть в наших выпусках.
5645.16 5654.84 "Игорь Лабутин" Обязательно, иначе будем грузить вас какими-то сложными статьями, скучными, которые найдем в интернете сами, а вы приносите веселые и задорные.
5654.84 5666.76 "Игорь Лабутин" Итак, сегодня мы посмотрели на .NET 10 Preview 4, внимательно еще раз рассмотрели, как дизайнили экстенджен-мемберы для C# 14 и какие проблемы и трудности были с этим.
5666.76 5680.84 "Игорь Лабутин" Посмотрели, обсудили, как переходят из Go на C# и узнали, как же на .NET писать настоящие устойчивые приложения, устойчивые облачные приложения, конечно же, хорошо не микросервисы.
5680.84 5686.24 "Игорь Лабутин" Вот, на сегодня, наверное, все, будем прощаться.
5686.24 5694.24 "Анатолий Кулаков" Ну да, всем до новых встреч, пишите нам побольше комментариев, шарьте репосты, лайкайте, не забывайте про наш густи, всем пока.
5694.24 5694.74 "Игорь Лабутин" Всем пока.
