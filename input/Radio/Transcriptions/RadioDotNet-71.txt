0.00 11.44 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Radiono.net, выпуск номер 71.
11.44 14.56 "Анатолий Кулаков" И в эфире, как всегда, Анатолий Кулаков.
14.56 17.20 "Анатолий Кулаков" И Игорь Лабутин.
17.20 27.72 "Анатолий Кулаков" Прежде всего хочется поблагодарить наших самых больших помогаторов – Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Илья, Гурий, Самойлин, Виктор, Руслан Артамонов.
27.72 34.76 "Анатолий Кулаков" Если вы хотите попасть в этот благородный список, заходите на наш сайт на Boosty и посмотрите, что там интересного мы для вас приготовили.
34.76 50.36 "Анатолий Кулаков" Кстати, сегодня мы провели предмайскую чистку, и у нас на Boosty образуется постик, где мы расскажем о тех айтемах, которые пролежали у нас долго-долго в бэклоге к нашему подкасту, но так и не вошли в эфир по тем или иным причинам.
50.36 60.96 "Анатолий Кулаков" Если вы хотите посмотреть, что же у нас там все-таки осталось и про что мы больше никогда не расскажем, вот это тоже можно посмотреть на нашем сайте на Boosty.
60.96 82.00 "Игорь Лабутин" Да, думали мы, что к этому выпуску выйдет у нас какая-нибудь очередная превьюшка, мы тут будем сидеть, смотреть, что же там Microsoft нового нам сделал, четвертая же, по-моему, да, должна быть превью уже, но пока нету, и поэтому сегодня будет выпуск почти не совсем про Microsoft или совсем не про Microsoft, в общем.
82.00 90.56 "Игорь Лабутин" Покопались мы действительно в наших старых архивах, смотрели всякие разные старые статьи, смотрели смежные статьи и много чего у нас сегодня в новостях.
90.56 101.44 "Анатолий Кулаков" Ну действительно, не каждую неделю тебе при релизе выпускать, ну и вообще, если будем рассказывать только про Microsoft, это будет скучновато, полезно по сторонам еще посмотреть, и по-моему, сегодняшний выпуск так довольно хорошо смотрят по сторонам.
101.44 132.96 "Игорь Лабутин" Да, начнем смотреть по сторонам мы с одной темы, которую мы частично затрагивали в прошлый раз, это были так называемые rootless контейнеры, то есть Microsoft выпустил новость, что начиная с 8.0.net у нас все контейнеры, которые они генерят для .NET будут поддерживать вариант rootless, и мы в частности закончили, ну не то чтобы закончили, одна из тем, которую мы обсуждали в прошлый раз была вообще, зачем эти rootless контейнеры нужны, как они работают, в чем, собственно, проблема, где бывает root, где не root и что со всем этим делать.
132.96 135.24 "Анатолий Кулаков" Ты разобрался в вопросе, насколько я понимаю, и вернулся
135.24 141.76 "Игорь Лабутин" с ответом. Я хоть нашел умную статью, почитал, забыл, но ссылочка могу поделиться, что называется, читайте сами.
141.76 180.16 "Игорь Лабутин" Если кратко, смотрите, у RedHat есть отличнейшая статья, которая рассматривает со всех сторон вопрос root и rootless контейнеров, причем надо понимать, что у нас root и не root, пользователь может быть снаружи контейнера и внутри контейнера, то есть мы можем сам контейнер запускать от имени либо root, либо какого-то пользователя на вашем хосте, который не является root, и также внутри этого контейнера у вас может приложение исполняться с правами root либо с правами же не root, какого-то тоже пользователя и что с этим дальше делать.
180.16 197.68 "Игорь Лабутин" Значит, если кратко, насколько я это понял, опять же, мое понимание может быть далеко от истины, смысл заключается в том, что поскольку все, что мы запускаем в контейнере, по факту, в процесс сам по себе, он все равно запускается на хостовую операционную систему, просто в некотором сэндбоксе, да, там вот это cgroup, namespace и вот это все.
197.68 219.68 "Игорь Лабутин" И смысл в том, что если вы, например, каким-то образом сможете суровыми хакерскими методами добиться того, чтобы вы вылезли за пределы вот этих cgroup и чего-нибудь, то ваш код будет исполняться с теми правами, которые выданы пользователю в хостовой операционной системе.
219.68 246.48 "Игорь Лабутин" Соответственно, в случае, если это docker daemon, docker daemon по дефолту, ну в большинстве инсталляций, да, он исполняется от имени root, и поэтому если вы запускаете дефолтный контейнер, в котором в дефолтном контейнере у вас пользователь root, в docker daemon, который тоже от root, то если вдруг у вас какой-то злонамеренный код сможет выбраться наружу из этих всяких уровней изоляции linux и прочего, то он сможет получить доступ как root.
246.48 247.48 "Игорь Лабутин" Это нехорошо.
247.48 250.16 "Игорь Лабутин" Поэтому его можно пытаться закрыть.
250.16 256.52 "Игорь Лабутин" С одной стороны, вы можете его закрыть снаружи, вы можете запустить контейнер не как root.
256.52 258.24 "Игорь Лабутин" То есть указать.
258.24 268.60 "Игорь Лабутин" А снаружи вы можете не docker daemon запустить, а вот в статье конкретно рассматривается подман, который может вам запустить контейнер просто как обычный юзер.
268.60 277.12 "Анатолий Кулаков" Логично, да, даже если гостевая система вылезет в хостовую наружу, то она получит максимум привилегий этого юзера, который легко ограничивается.
277.12 278.12 "Игорь Лабутин" Все так.
278.12 286.40 "Игорь Лабутин" Она действительно получит привилегии этого юзера, но она получит доступ ко всем тем местам, куда имеет доступ этот конкретный юзер.
286.40 291.76 "Анатолий Кулаков" То есть если… Просто как у этого юзера должен быть доступ ко всем, грубо говоря, подам, которые он запускает, это тоже немало.
291.76 292.76 "Игорь Лабутин" Да.
292.76 302.00 "Игорь Лабутин" Поэтому если вы… Что происходит, если вы контейнер запускаете как rootless внутри, в смысле внутри контейнера, используете пользователя, которые не root.
302.00 319.24 "Игорь Лабутин" В этом случае на самом деле у операционки вашей, в которой все это исполняется на самом деле, с каждым пользователем, то есть вот когда вы добавляете пользователя в систему, там вы добавляете пользователя Игорь, ему дается там какой-нибудь IDшник, UID, который там 1000 по-моему дает по дефолту, начинается с 1000 или 1001, не помню.
319.24 321.92 "Игорь Лабутин" Там в разных линуксах по-разному немножко.
321.92 334.72 "Игорь Лабутин" На самом деле сейчас как раз ровно для целей всяких rootless контейнеров и прочих уровней изоляции появилась такая штука, которая называется, по-моему это называется sub-ID, sub-UID точнее.
334.72 343.08 "Игорь Лабутин" То есть вместе с вашим обычным UIDшником вам резервируется еще 65 тысяч UIDшников в специальном диапазоне.
343.08 365.76 "Игорь Лабутин" И как раз когда вы запускаете нерутовый образ в контейнере, то вам будет, несмотря на то, что там вы будете тоже запускаться, например, по дюйм-серверу Игорь, у него уже не будет тот UID, который у вас во внешней системе, он будет замаплен в свой собственный UID, который для внешней системы, для хостовой он как бы связан с вашим аккаунтом, но формально им не является.
365.76 373.88 "Игорь Лабутин" И даже если вы теперь вылезете наружу из этого контейнера, у вас будет какой-нибудь IDшник, не знаю, 100 тысяч 5, а вот у него уже прав нифига нет ни на что.
373.88 379.24 "Анатолий Кулаков" Потому что он… То есть в хостовой системе он почти, ну практически не существует.
379.24 380.24 "Игорь Лабутин" Да.
380.24 386.68 "Игорь Лабутин" Она про него знает, что он является вот этим вот, он есть в этой правильном файлике sub-UID, где-то c/sub-UID, например.
386.68 387.68 "Игорь Лабутин" Вот.
387.68 396.92 "Игорь Лабутин" Но у него, допустим, в правах на файлы написано, естественно, ваш нормальный обычный там у юзера Игоря, его нормальный там 1000, да, IDшник UID.
396.92 400.68 "Игорь Лабутин" И соответственно вы не сможете никуда добраться нормально.
400.68 402.32 "Игорь Лабутин" То есть это еще больше такая типа изоляция.
402.32 411.72 "Анатолий Кулаков" Ну то есть я правильно понимаю, что теперь можно даже докер-демона этого запускать под рутом, потому что даже если ты из-под рута этого вылезешь, то все равно у тебя IDшник будет нерутовый.
411.72 413.28 "Игорь Лабутин" Да, у тебя IDшник будет нерутовый.
413.28 423.96 "Игорь Лабутин" Вот как раз статья Red Hat, она чем хороша, там прям показано на простых примерах, что вот смотрите, мы запустили так, то вот тут как бы задампили юзер ID, вот он такой.
423.96 426.88 "Игорь Лабутин" А вот запустили так, и там прям таблички, знаешь, это 2 на 2.
426.88 436.12 "Игорь Лабутин" Рут инсайт, рут аутсайт, юзер инсайт, юзер аутсайт, и там всякие различные примеры прописаны и рассказана как раз вся эта механика со всякими сабью ID и прочим работает.
436.12 440.20 "Анатолий Кулаков" Интересно, а как они вылазили, чтобы вот такую табличку сделать?
440.20 442.20 "Анатолий Кулаков" То есть они же должны были вылезти, чтобы эту команду исполнить.
442.20 446.24 "Игорь Лабутин" Так ты же можешь внутрь зайти и внутри докера исполнить command line, почему нет?
446.24 454.40 "Анатолий Кулаков" Внутри хорошо, а как вылезти из контейнера, чтобы понять, что мой внутренний IDшник снаружи с хостовой системы будет не распознаваться, а как рут?
454.40 460.20 "Игорь Лабутин" Ты снаружи можешь это видеть через /proc, насколько я понимаю.
460.20 461.20 "Анатолий Кулаков" Ну, в смысле, если я…
461.20 468.36 "Игорь Лабутин" Ну, допустим. Я рут, ты рутовым пользователем можешь посмотреть, что у каждого процесса, ну, кто является владельцем процесса.
468.36 481.08 "Игорь Лабутин" То есть ты не можешь изнутри процесса сказать, кто ты, ну, в смысле, ты, ну, как сказать, короче, свой IDшник ты внутри процесса знаешь, то есть задача была просто показать, под каким ID работает каждый из процессов.
481.08 487.44 "Анатолий Кулаков" Нет, это окей, а вот что будет, если этот процесс вылезет из докер-демона в хостовую систему?
487.44 489.48 "Анатолий Кулаков" Вот какой у него там будет IDшник?
489.48 491.48 "Анатолий Кулаков" Так такой же и будет.
491.48 497.44 "Анатолий Кулаков" Ну, окей, но просто раньше, если бы он вылез, у него был бы IDшник рута, потому что под рутом запущен демон.
497.44 501.88 "Игорь Лабутин" И под рутом запущен демон, и под рутом исполняется контейнер.
501.88 503.36 "Игорь Лабутин" И под рутом исполняется контейнер, да.
503.36 504.36 "Игорь Лабутин" Вот.
504.36 508.84 "Игорь Лабутин" Поэтому да, везде рута, единичка или нолик, все такое.
508.84 517.24 "Игорь Лабутин" Сложно очень с этим всем, честно говоря, рассказывать, учитывая то, что я не являюсь всем этим мастером кубернетов, докеров и прочего.
517.24 521.16 "Игорь Лабутин" Вот, поэтому очень сложно так рассказывать на словах мне, по крайней мере.
521.16 524.44 "Игорь Лабутин" Я это знаю на уровне как бы, rootless лучше.
524.44 526.96 "Игорь Лабутин" Вот, и пользуясь подмодом.
526.96 532.68 "Игорь Лабутин" Но на самом деле даже докер-демон, начиная, по-моему, с 20-й версии, если я правильно помню статью, тоже поддерживает rootless режим.
532.68 538.92 "Игорь Лабутин" То есть, в принципе, там есть, правда, ограничения при этом.
538.92 548.00 "Игорь Лабутин" То есть, понятно, что как только вы запускаете докер-демона в rootless, вы уже не сможете байдниться на какой-нибудь там 84.4.3, потому что это только рутам можно, все, что меньше 1024.
548.00 549.36 "Игорь Лабутин" И вот это все.
549.36 562.04 "Игорь Лабутин" То есть, у вас начнутся такие ограничения, если вам нужно слушать на 80-м, все-таки какой-то процесс, типа какой-нибудь там Nginx на входе, все равно придется ставить в root-варианте, чтобы он мог байдиться на нижние порты.
562.04 567.44 "Анатолий Кулаков" Ну там, скорее всего, можно выдать просто какие-нибудь привилегии на порт, при этом не поднимая весь контейнер как root.
567.44 568.44 "Анатолий Кулаков" Ну, такое же должно быть.
568.44 569.80 "Игорь Лабутин" Я вот не помню, честно говоря.
569.80 579.32 "Игорь Лабутин" Мне казалось в Linux, что если нужно байдиться к чему-то ниже чем 1024, то я обязан быть root, но опять же, спецом не буду говорить, не моя область.
579.32 584.56 "Анатолий Кулаков" Ну так смотри, так как и в easy, то есть под easy, ты же тоже 80-й порт просто так не откроешь.
584.56 593.00 "Анатолий Кулаков" Но ты можешь зарезервировать байдинг из-под рута, сказать, что да, это приложение, я ему доверяю, оно может на 80-м порту подняться.
593.00 596.04 "Анатолий Кулаков" И после этого приложение уже без рута поднимается на 80-м.
596.04 597.04 "Анатолий Кулаков" А там же, по-моему, ниже.
597.04 598.04 "Игорь Лабутин" Там же есть.
598.04 601.20 "Игорь Лабутин" Там не приложение, там же в easy слушают, а что-то по sys всегда.
601.20 602.56 "Игорь Лабутин" Ну да, да, ты говоришь sys, конечно.
602.56 606.36 "Игорь Лабутин" Да, а он дальше внутри, там по, на самом деле, name pipe, он все это маппит.
606.36 611.52 "Анатолий Кулаков" Ну приложение тоже, смотри, всякие нетворки, c-группы, они же тоже как отдельная сущность.
611.52 626.72 "Игорь Лабутин" Ну, наверное, да, но, в общем, насколько я помню, скажу так, у меня нет такого большого опыта в rootless'ах с точки зрения, прям вот выставлять там 80, 40, 40, 30 или какие-нибудь другие штуки, которые требуют доступа к чему-то обычному
626.72 630.36 "Анатолий Кулаков" обычно рутовому. Ну ладно, оставь это все красноглазиком.
630.36 635.88 "Анатолий Кулаков" Нам-то важно, что теперь как бы восьмые дотнеты по умолчанию будут использовать как раз rootless контейнеры.
635.88 641.32 "Игорь Лабутин" Да, нет, не по умолчанию, по умолчанию нет, но они все могут быть сконфигурены.
641.32 663.12 "Игорь Лабутин" То есть вы, когда используете base image, ну, восьмидотнетные образы, вы можете после этого в вашем докерфайле, который основан на восьмерке, указать конструкцию юзера, в $app, по-моему, подчеркиваю не UID, это рекомендованный способ, и в этой константе точно будет вот тот UID, под которым как раз восьмерка готова исполняться.
663.12 665.76 "Игорь Лабутин" Почему по умолчанию это в базовом имидже не прописано?
665.76 667.40 "Игорь Лабутин" Нет, по умолчанию он будет root'овым.
667.40 668.40 "Анатолий Кулаков" То есть нужно вот эту юзерку написать.
668.40 669.40 "Игорь Лабутин" Почему, есть причины?
669.40 670.40 "Игорь Лабутин" Зачем нам это?
670.40 671.40 "Игорь Лабутин" А так принято, как я понимаю.
671.40 678.20 "Игорь Лабутин" То есть принято, я так понимаю, что если они пропишут туда юзер, то дальше ты уже не сможешь это отменить.
678.20 680.12 "Анатолий Кулаков" Так я, может, и не хочу.
680.12 683.20 "Анатолий Кулаков" Не, ну я второй команду юзеров там какой-нибудь сделаю.
683.20 685.84 "Игорь Лабутин" Не знаю, я не видел, честно говоря, такого, чтобы базовый
685.84 689.28 "Анатолий Кулаков" был всегда root'лес. Ну, блин, как-то странно.
689.28 694.92 "Анатолий Кулаков" Вроде и докер переходит со своим еваном на root'лес, и я так думал, что и контейнеры все тоже перейдут помолчать
694.92 701.32 "Игорь Лабутин" не менее на root'лес. Мне не кажется, что докер переходит, мне кажется, что он типа может устанавливаться, но по дефолту опять же ставится в root'овом варианте все равно.
701.32 702.32 "Игорь Лабутин" Так странно, зачем?
702.32 703.88 "Анатолий Кулаков" Никому же не нужен root по дефолту.
703.88 704.88 "Анатолий Кулаков" Это же какой-то подшоп в 1995.
704.88 705.88 "Анатолий Кулаков" Это же удобно.
705.88 708.88 "Анатолий Кулаков" Ну, хуй изнетит удобно.
708.88 718.12 "Анатолий Кулаков" Ладно, давай оставим это на совесть микрософта, просто тогда запомним, что все разработчики не забывайте переводить свои контейнеры в root'лес режим.
718.12 737.24 "Игорь Лабутин" Да, и надо сказать, что по крайней мере как-то это в статье прозвучало очень кратенько, но вроде Microsoft утверждает, что они решили проблемы со всякими dotnet-мониторами и прочим, а dotnet-монитор, понятно, им уже нужны всякие как раз коннекты ко всяким сокетам, вот это все для того, чтобы подключаться к тому приложению, которое они мониторят.
737.24 747.64 "Игорь Лабутин" Вроде все проблемы решены с root'лес-контейнерами, и dotnet-монитор, контейнер тоже поддерживается, так что его там каким-нибудь сайдкаром можно запускать к вашему основному дотнетному контейнеру и все будет работать.
747.64 758.68 "Анатолий Кулаков" Слушай, а вот тут уже как-то звучит опасно, что у тебя есть некий контейнер, который не обладает root'овыми привилегиями и при этом может дотянуться просто до всей твоей подноготной, ну то есть до подноготной соседского контейнера,
758.68 767.28 "Игорь Лабутин" вытащить из него все венты, все профили. Ты же сайдкаром его запускаешь сам, не просто так, а все-таки сайдкаром, то есть это твое осознанное действие.
767.28 771.36 "Анатолий Кулаков" Ну ладно, будем рассчитывать на то, что администратор все-таки осознает, что он делает.
771.36 783.76 "Игорь Лабутин" То есть это не просто, что дотнетмонитр может достучаться до любого дотнетконтейнера, который исполняется у тебя на этом хосте, нет, только там где ты явно сайдкаром его закинул, ну в этом поте, если мы про кубернетис конкретно говорим.
783.76 794.40 "Игорь Лабутин" Так что вот, и да, сама статья от Майкрософт, она как раз там с примерчиками про то, как это все сделать в кубернетисе, чтобы значит все это запускалось, поэтому если вы пользуетесь, посмотрите.
794.40 799.16 "Игорь Лабутин" Пересказывать все эти конфигы кубернетиса как-то странно, голосом, мне кажется.
799.16 806.12 "Игорь Лабутин" Вот такое дело, я надеюсь, что стало может быть чуть понятнее, хотя я очень в этом сильно не уверен про rootless.
806.12 811.40 "Игорь Лабутин" А мы пойдем дальше к еще одной теме, которую мы по-моему вообще ни разу никогда не затрагивали.
811.40 816.96 "Анатолий Кулаков" Ну мы как-то касались различных тестирований, но… Да, ладно.
816.96 817.96 "Анатолий Кулаков" Наверное, да.
817.96 821.72 "Анатолий Кулаков" Продолжая эту тему контейнеров, кстати, смотри.
821.72 829.84 "Анатолий Кулаков" Вышла статья, как примечательно, на хабре, которая нам рассказывает про то, каким образом нам делать интеграционные тестирования.
829.84 837.68 "Анатолий Кулаков" И постепенно автор проходится от самых примитивных способов до более или менее юзабельного и рабочего в продакшене.
837.68 843.80 "Анатолий Кулаков" Статья называется «Еще раз про интеграционное тестирование SPnetCore с TestServer и TestContainers».
843.80 857.96 "Анатолий Кулаков" Давайте пробежимся, потому что, мне кажется, это типичные шаги, которые совершают все разработчики, ну по крайней мере, лично я тоже их проходил, поэтому хочется понять, а где сейчас находится тестирование и в каком виде его можно применять на практике.
857.96 862.88 "Анатолий Кулаков" Тут сразу стоит оговориться, что речь в статье идет только про интеграционное тестирование.
862.88 869.20 "Анатолий Кулаков" Там всякие юнит-тесты и функциональные тесты, еще каким-то образом они называются тесты, они оставлены в стороне.
869.20 871.52 "Анатолий Кулаков" Мы говорим только про интеграционные.
871.52 875.52 "Анатолий Кулаков" Итак, автор задался вопросом, что хотел бы сделать себе интеграционное тестирование.
875.52 884.48 "Анатолий Кулаков" Как бы модульные тесты пишутся разработчиками, все счастливы, а вот интеграционные тесты обычно оставляют на своеобразных отделах тестирования.
884.48 893.96 "Анатолий Кулаков" И туда же end-to-end тесты идут и так далее, когда система тестируется полностью с настоящими зависимостями и с настоящими данными.
893.96 895.80 "Анатолий Кулаков" Потому что для разработчиков это слишком сложно.
895.80 903.08 "Анатолий Кулаков" Разработчики понимают юниты, понимают, как их мокать, понимают систему без каких-то зависимостей, без каких-то эффектов и умеют с ними работать.
903.08 906.76 "Анатолий Кулаков" Но не полную систему, где у вас есть база данных.
906.76 919.48 "Анатолий Кулаков" В этой базе данных есть данные, которые используются различными запросами, различными тенентами, может быть даже параллельно, у вас там есть какая-нибудь очередь, в которой тоже непонятно консюмеры, какой из консюмеров их законсюмит.
919.48 926.72 "Анатолий Кулаков" В общем, там есть какое-то состояние, которое крутится и которое будет, естественно, мешать тестам, если они начнут исполняться, допустим, параллельно.
926.72 931.16 "Анатолий Кулаков" В общем, это все сложно, поэтому разработчики стараются этого всего избегать.
931.16 937.12 "Анатолий Кулаков" Давайте же посмотрим, каким образом все-таки можно этого не избегать, а более или менее начать с этим работать.
937.12 952.12 "Анатолий Кулаков" Ну, самый простой способ, опять же, если у вас есть типичная ситуация, когда у вас есть какой-то сервис, у этого сервиса есть база данных, у этого сервиса обычно есть какая-нибудь шинка, там, Ruby2B, mq или кавка, и с этим нужно каким-то образом взаимодействовать.
952.12 961.44 "Анатолий Кулаков" А еще этот сервис обычно не один, так как у нас везде микросервисы, у него еще есть там 40 зависимостей, которые нужны для того, чтобы оно более или менее работало.
961.44 967.16 "Анатолий Кулаков" Самое первое, что можно сделать, и, наверное, что все делают, это выделяют некий тестовый стенд.
967.16 986.40 "Анатолий Кулаков" На этом тестовом стенде поднимают все сервисы, все зависимости, там же бежит настоящая база данных, там же бежит Revit, прописывают урлы к этому сервису, и после подобной манипуляции вы даже локально уже сможете запустить ваш сервис, который вы хотите протестировать, но перенаправить все его запросы на этот тестовый стенд.
986.40 994.68 "Анатолий Кулаков" И вот таким образом можно какие-то простейшие сценарии уже проверять, кликать, и оно все будет работать.
994.68 997.24 "Анатолий Кулаков" Минусов у этого подхода полно.
997.24 1002.52 "Анатолий Кулаков" Во-первых, это уже такой процесс не для разработчиков.
1002.52 1006.40 "Анатолий Кулаков" Разработчики обычно сидят на своей личной локальной машинке и им все нравится.
1006.40 1015.68 "Анатолий Кулаков" А если там какой-то отдельный тестовый сервер, то опять же легче отдать команду тестирования, пусть она занимается тестированием и заморочками с этим тестовым стендом.
1015.68 1019.32 "Анатолий Кулаков" Также нужно не забывать, что у нас получаются общие данные.
1019.32 1026.08 "Анатолий Кулаков" Обычно такой тестовый сервер заводится один или несколько все-таки на несколько человек или на несколько процессов.
1026.08 1034.40 "Анатолий Кулаков" И когда один тестировщик будет использовать эти данные, прокликивать какие-то бизнес-кейсы, то другой в этот же момент может заняться тем же самым.
1034.40 1041.84 "Анатолий Кулаков" И они будут друг другу мешать, и соответственно там какие-то конфликты могут быть, какие-то общие данные могут покарабкаться.
1041.84 1043.52 "Анатолий Кулаков" Это страшно, это тяжело.
1043.52 1049.24 "Анатолий Кулаков" И еще один из минусов в том, что этот тестовый стенд его надо каким-то образом поддерживать.
1049.24 1057.00 "Анатолий Кулаков" У них там есть свои версии, свои программы, которые нужно обновлять, новые сервисы устанавливать, Rebit и апдейтить.
1057.00 1061.36 "Анатолий Кулаков" И это тоже какая-то работа, которая занимает время, и непонятно, кто этим должен заниматься.
1061.36 1070.12 "Анатолий Кулаков" И автор предлагает развить этот процесс, каким же образом нам сделать интеграционное все-таки тестирование.
1070.12 1078.56 "Анатолий Кулаков" Договоримся, что мы тестируем SPNet-приложение с контроллерами, с обычным CRUD, который использует Entity Framework и использует Postgres.
1078.56 1082.80 "Анатолий Кулаков" Ну и можно там для кучки добавить Rebit, не сильно важно.
1082.80 1084.68 "Анатолий Кулаков" Прежде всего наивный подход.
1084.68 1094.52 "Анатолий Кулаков" Как сделать разработчику… Прежде всего, чтобы разработчик начал всю эту штуку тестировать, мы должны сделать запуск всех этих тестов на Build-агенте.
1094.52 1112.68 "Анатолий Кулаков" Самый простой способ – это сделать доступ из Build-агента на тот самый стенд, который тестируется вручную, и запустить в нашем Build-агенте наше приложение, перенаправив все запросы к настоящей базе данных и ко всем внешним зависимостям на этот стенд.
1112.68 1114.84 "Анатолий Кулаков" И в принципе, этот способ работает.
1114.84 1128.08 "Анатолий Кулаков" Вам достаточно в тестовых проектах просто-напросто создать класс аппликейшена, настроить немножко DI, чтобы он увидел контроллеры из соседней сборки, из настоящего приложения, и запустить это приложение.
1128.08 1150.28 "Анатолий Кулаков" Здесь мы получаем из плюсов, соответственно, то, что мы можем запускать приложение, мы можем достучаться к настоящим сервисам, к настоящему DI-контейнеру нашего приложения, то есть оттуда мы можем забрать какие-то сервисы, замокать какие-то сервисы, или подтюнить, законфигурить какие-то сервисы, и делать настоящие HTTP-запросы.
1150.28 1167.20 "Анатолий Кулаков" Если поднимается восполнительное приложение, оно банится на порту Build-агента, мы можем сделать настоящие HTTP-запросы, тестировать API, который будет ходить в базе данных, как на стенде, и в принципе получим нормальные работающие тесты.
1167.20 1169.68 "Анатолий Кулаков" Здесь есть небольшие проблемы.
1169.68 1174.00 "Анатолий Кулаков" По-прежнему у нас остается реальная база данных, которые могут доступаться несколько человек.
1174.00 1182.64 "Анатолий Кулаков" Также к ней нужно передавать какие-то credentials, их можно засовывать в код, можно передавать переменными окружениями, но об этом нужно загоняться и каким-то образом об этом думать.
1182.64 1186.68 "Анатолий Кулаков" Тоже не очень хочется это делать для тестов.
1186.68 1191.44 "Анатолий Кулаков" По-хорошему, так как это тест, они должны для себя подготовить данные в начале и очистить данные в конце.
1191.44 1195.72 "Анатолий Кулаков" В общем, и этим тоже нужно загоняться, не забывать.
1195.72 1202.72 "Анатолий Кулаков" Опять же, если параллельно запускается несколько тестов или ручками, кто-то на этот стенд еще ходит, мы сталкиваемся с конфликтами и проблемами.
1202.72 1210.80 "Анатолий Кулаков" Ну и если мы поднимаем настоящий Kestrel-сервис на Build-агенте, то здесь нам нужно задуматься о порте приложения.
1210.80 1213.64 "Анатолий Кулаков" Во-первых, этот порт может быть тупо занят.
1213.64 1218.68 "Анатолий Кулаков" Допустим, если у нас два билда идут параллельно, они по-любому займут один и тот же порт.
1218.68 1225.68 "Анатолий Кулаков" Во-вторых, как уже было упомянуто выше игре, порт у нас может быть вполне не быть прав на то, чтобы забанить какой-нибудь порт 80-й.
1225.68 1228.32 "Анатолий Кулаков" В общем, об этом тоже нужно загоняться, нужно думать.
1228.32 1229.32 "Анатолий Кулаков" Это не очень хорошо.
1229.32 1234.84 "Анатолий Кулаков" Ну и я бы добавил, вообще необходимость наличия отдельного стенда, она остается.
1234.84 1238.20 "Анатолий Кулаков" То есть, его должен кто-то поддерживать, его должен кто-то версионировать.
1238.20 1242.12 "Анатолий Кулаков" Также у нас появляется опасность с общими данными, что они могут законфликтовать.
1242.12 1256.80 "Анатолий Кулаков" И сам по себе вариант, когда у нас из билд-агента доступен какой-то стенд, какой-то разработческий, какой-то тестировщический, не важно, там вполне могут быть нормальные какие-нибудь продовские данные.
1256.80 1263.00 "Анатолий Кулаков" В общем, когда у вас из билд-агента есть доступ в ваш рабочий контур, это тоже не секурно, это вообще плохо.
1263.00 1264.96 "Анатолий Кулаков" И таких способов нужно избегать.
1264.96 1269.20 "Анатолий Кулаков" То есть, нельзя билд-агенту открывать такие штуки, которые ему по идее не должны были быть нужны.
1269.20 1280.28 "Анатолий Кулаков" Ну и вообще, тут происходит немножко нарушение целостности приложения, потому что у нас есть возможность зайти в DI-контейнер, есть возможность его поменять.
1280.28 1292.28 "Анатолий Кулаков" А также в данном подходе мы вынуждены будем менять DI-контейнер, потому что нам нужно будет зарегистрировать дополнительные контейнеры, которые у нас теперь поднимаются из тестовой сборки, а не из оригинального приложения.
1292.28 1297.16 "Анатолий Кулаков" То есть, по факту это значит, что мы тестируем приложение, не то, которое будет работать у нас на продакшене.
1297.16 1305.64 "Анатолий Кулаков" Конечно, здесь место для багов довольно маленькое, но оно есть, оно ощутимое, и его тоже стоит избегать.
1305.64 1307.92 "Анатолий Кулаков" Теперь переходим к более цивилизованному варианту.
1307.92 1322.96 "Анатолий Кулаков" Если вы прям погуглите ISPNet Integration Testing, то вам, скорее всего, в первых строках своего письма вывалится ссылка на клевую микрософтовскую статью, которая рассказывает о кем образом делать интеграционное тестирование ISPNet Core вместе даже с Entity Framework и всего такого.
1322.96 1327.88 "Анатолий Кулаков" И волшебное ключевое слово, которое здесь есть, это Test Servers.
1327.88 1332.00 "Анатолий Кулаков" Test Server - это такая интересная задумка.
1332.00 1335.12 "Анатолий Кулаков" Это МОК, который, по сути, подменяет настоящий Kestrel.
1335.12 1336.12 "Анатолий Кулаков" То есть, что делает Kestrel?
1336.12 1344.04 "Анатолий Кулаков" Он всего лишь навсего, грубо говоря, открывает вам порт HTTP, принимает соединение на сокетах и передает его дальше по пайплайну.
1344.04 1347.28 "Анатолий Кулаков" Но нам открывать порт не столь нужно.
1347.28 1353.72 "Анатолий Кулаков" Нам достаточно взять HTTP запросы и передать их в ISPNet пайплайн.
1353.72 1356.56 "Анатолий Кулаков" И вот это может сделать Test Server.
1356.56 1361.16 "Анатолий Кулаков" Мы, соответственно, избавляемся от того, что нам нужно регать порт, что он может быть кем-то занят.
1361.16 1362.60 "Анатолий Кулаков" И вообще это долго.
1362.60 1366.36 "Анатолий Кулаков" Поднимать сервер, мапить порт, следить и принимать все коннекшены.
1366.36 1373.04 "Анатолий Кулаков" Мы можем сразу перехватить все коннекшены, которые к нам приходят из HTTP клиента и перебросить их в ISPNet пайплайн.
1373.04 1376.72 "Анатолий Кулаков" И технически этот тест довольно четко отражает реальную картину.
1376.72 1383.84 "Анатолий Кулаков" То есть, очень сложно представить себе ситуацию, когда он бы вам не покрыл тест кейсов, которые вы хотите тестировать.
1383.84 1394.52 "Анатолий Кулаков" Конечно, если там загнаться какими-нибудь WebSockets, несколькими параллельными коннекциями с прерыванием к закрытию TCP соединений, тогда вам такой кейс не подойдет.
1394.52 1398.44 "Анатолий Кулаков" Но если вы тестируете API, то честно можете на это забить.
1398.44 1401.56 "Анатолий Кулаков" Для API это все в порядке будет.
1401.56 1404.32 "Анатолий Кулаков" Делаются подобные тест кейсы очень-очень легко.
1404.32 1407.68 "Анатолий Кулаков" Вам достаточно сделать наследника от класса WebApplicationFactory.
1407.68 1410.04 "Анатолий Кулаков" И в принципе все.
1410.04 1415.28 "Анатолий Кулаков" И дальше вы получаете доступ и к настройкам того сервиса, который хотите запустить.
1415.28 1420.12 "Анатолий Кулаков" И самое главное, вы получаете доступ к волшебному HTTP-клиенту.
1420.12 1425.00 "Анатолий Кулаков" Именно через этот HTTP-клиент вы должны ходить к своим API.
1425.00 1433.00 "Анатолий Кулаков" Напомню, что настоящий TCP-порт не открывается, и поэтому обычный снова созданный красивый HTTP-клиент не сможет найти ваш сервис.
1433.00 1439.88 "Анатолий Кулаков" А вот этот магический волшебный, у которого прописан специальный хендлер с правильным перенаправлением всех запросов, вот он сможет.
1439.88 1450.04 "Анатолий Кулаков" В общем, вы его должны просто-напросто сохранить и передавать инъекции во все тесты, которые дальше будут тестировать ваш API, ваше тестовое приложение.
1450.04 1451.80 "Анатолий Кулаков" Все тесты, в принципе, не изменяются.
1451.80 1453.16 "Анатолий Кулаков" Они работают так, как и раньше.
1453.16 1459.12 "Анатолий Кулаков" Вам нужно изменить только момент старта вашей сборки тестирования и момент погасания.
1459.12 1462.08 "Анатолий Кулаков" Вы в конце должны, соответственно, все это задиспользовать, все это закрыть.
1462.08 1464.92 "Анатолий Кулаков" Из плюсов, как я уже сказал, не запускается кэстрол.
1464.92 1470.20 "Анатолий Кулаков" Это меньше жрет памяти, это меньше жрет ресурсов, и это самое главное, быстрее работает.
1470.20 1476.68 "Анатолий Кулаков" Скорость работы, получается, только вся в памяти происходит.
1476.68 1479.92 "Анатолий Кулаков" Поэтому все запросы начинают бегать тоже намного быстрее.
1479.92 1486.04 "Анатолий Кулаков" У нас по-прежнему есть доступ к нашей конфигурации, к нашему основному приложению, который можно поднастроить.
1486.04 1489.80 "Анатолий Кулаков" Из минусов, ну, в принципе, минусы со стендом остаются на месте.
1489.80 1495.30 "Анатолий Кулаков" То есть, самая большая проблема, что стенд есть, конфликты данных есть, расшаренные данные есть, они никуда не ушли.
1495.30 1500.52 "Анатолий Кулаков" Мы просто-напросто научились запускать наш сервис немножко более удобно и немножко более красиво.
1500.52 1518.20 "Анатолий Кулаков" И нужно сказать, что если у вас нет какого-то стенда, а если вы хотите сделать, допустим, интеграционные тесты, которые не зависят от внешней базы данных, но при этом тестируют все внутри самого себя, внутри целого приложения, то вот это тот шаг, на который вам стоит остановиться.
1518.20 1522.52 "Анатолий Кулаков" То есть, это отличное решение, его можно использовать.
1522.52 1526.20 "Анатолий Кулаков" Как в той же самой документации Microsoft, они на вот этом шаге остановились.
1526.20 1528.68 "Анатолий Кулаков" Вот, допустим, как избавиться от базы данных?
1528.68 1529.68 "Анатолий Кулаков" Очень просто.
1529.68 1535.84 "Анатолий Кулаков" У Entity Framework есть несколько способов для тестирования Entity Framework.
1535.84 1538.64 "Анатолий Кулаков" Во-первых, это In-Memory Entity Framework.
1538.64 1545.72 "Анатолий Кулаков" Это специальная эмуляция базы данных, но на самом деле там нет никакой базы данных, там просто объекты хранятся в памяти и достаются из памяти.
1545.72 1552.40 "Анатолий Кулаков" Если у вас примитивная работа, вы там работаете типичными запросами, то этого вам должно хватить.
1552.40 1558.08 "Анатолий Кулаков" Почему вам не хватит, это когда у вас сложная работа с базой данных, потому что реально там никакого преобразования в SQL даже нет.
1558.08 1569.52 "Анатолий Кулаков" То есть, если вы допустили какую-то мега ошибку и преобразовали свой запрос в какой-то мега сложный SQL, или использовать какую-нибудь специфику SQL, то этот способ вам не подойдет.
1569.52 1580.20 "Анатолий Кулаков" Более практичный способ – это использование вместо типичной вашей базы данных типа Postgres, использовать SQLite.
1580.20 1583.24 "Анатолий Кулаков" Это настоящая база данных.
1583.24 1592.00 "Анатолий Кулаков" Она умеет подниматься в InMemory, и в отличие от предыдущего варианта, к ней пойдут настоящие транслейты в SQL синтексис.
1592.00 1594.56 "Анатолий Кулаков" У вас будет работать практически весь pipeline.
1594.56 1604.04 "Анатолий Кулаков" Но тут нужно понимать, что если вдруг ваши запросы почему-то настроены жестко на Postgres какой-нибудь или на MS SQL, то SQLite может быть их не воспримет.
1604.04 1608.24 "Анатолий Кулаков" Допустим, если вы там JSON-B используете какой-нибудь из Postgres, то вам этот вариант уже не подойдет.
1608.24 1613.68 "Анатолий Кулаков" Но опять же, если у вас запросы довольно примитивные, то этот вариант вам тоже подойдет.
1613.68 1619.76 "Анатолий Кулаков" Соответственно, вы получаете полное интеграционное тестирование вашего приложения, но при этом вам не нужны какие-то внешние стенды.
1619.76 1625.16 "Анатолий Кулаков" Вы можете базу данных где-то у себя локально держать или в памяти замокать или на диск на локальный положить.
1625.16 1628.36 "Анатолий Кулаков" Не важно где, главное, что не нужны никакие внешние стенды.
1628.36 1632.32 "Анатолий Кулаков" И тогда это прекрасный подход для интеграционного тестирования.
1632.32 1644.16 "Анатолий Кулаков" Но автор не сдался, потому что ему нужен настоящий Postgres, ему нужен настоящий RabbitMQ, и ему нужны настоящие тысячи, какие-то 10 тысячи зависимости, которые он хочет все-таки поднимать независимо.
1644.16 1645.80 "Анатолий Кулаков" И он пошел дальше.
1645.80 1649.16 "Анатолий Кулаков" И дальше она встречает проект, который называется TestContainers.
1649.16 1654.00 "Анатолий Кулаков" Это проект, который был специально создан для подобных ситуаций.
1654.00 1660.76 "Анатолий Кулаков" Он предоставляет легковестные одноразовые экземпляры внешних зависимостей в виде докер-контейнеров.
1660.76 1667.36 "Анатолий Кулаков" Проект работает поверх Docker Remote API, то есть по сути это .NET библиотека, которая взаимодействует с докером.
1667.36 1669.52 "Анатолий Кулаков" У нее очень много интересных возможностей.
1669.52 1675.72 "Анатолий Кулаков" Например, она может построить вам какую-нибудь виртуальную сеть, по которой ваши контейнеры смогут взаимодействовать.
1675.72 1686.40 "Анатолий Кулаков" И по факту она и позволяет вам подключать к вашему приложению контейнеры из абсолютно любых образов, для того чтобы использовать их в тестах.
1686.40 1695.76 "Анатолий Кулаков" Например, если наше приложение зависит от Postgres, мы всего лишь навсего сделаем контейнер-билдер из этого пакета TestContainers.
1695.76 1699.68 "Анатолий Кулаков" Говорим, что мы хотим подключить Postgres, мы хотим подключить его такой-то версии.
1699.68 1704.48 "Анатолий Кулаков" Тут же мы можем передать ему какие-то переменные окружения, которые там должны у него быть.
1704.48 1709.84 "Анатолий Кулаков" Например, пароль, где должна размещаться его база данных, какие ключи ему передать.
1709.84 1714.24 "Анатолий Кулаков" Все это задается прямо в C# без всяких ямлов и прочего безобразия.
1714.24 1716.56 "Анатолий Кулаков" И говорим просто запустись.
1716.56 1729.00 "Анатолий Кулаков" Эта библиотека идет в репозиторий, просит докера, естественно, скачать все контейнеры, запускает его и отдает вам все необходимые данные для работы.
1729.00 1741.80 "Анатолий Кулаков" Например, она замапит контейнер на случайном порту и отдаст вам в приложение адрес этого порта, куда вы можете наторвить настоящий HTTP или TCP клиент.
1741.80 1746.56 "Анатолий Кулаков" Она сама сгенерит имена, которые не будут пересекаться, порты, которые не будут пересекаться.
1746.56 1751.08 "Анатолий Кулаков" Она сама вам отдаст connection string, по которому доступен, например, этот Postgres.
1751.08 1767.64 "Анатолий Кулаков" То есть вам не нужно об этом ни о чем думать, она сама все это вам составит и отдаст в клиентский код, и вы даже можете уже стандартный какой-нибудь Postgres connection делать или TCP connection делать, или HTTP request посылать уже по готовым адресам.
1767.64 1773.48 "Анатолий Кулаков" То есть вот эта основная инфраструктурная всю проблема, как скачать, запустить, настроить, она берет полностью на себя.
1773.48 1779.24 "Анатолий Кулаков" И вот там главное ее преимущество, главная ее фишка в том, что она позволяет вам абстрагироваться от всех этих замесивостей.
1779.24 1782.64 "Анатолий Кулаков" Вы просто говорите, хочу Postgres и все.
1782.64 1805.72 "Анатолий Кулаков" Естественно, что она поддерживает ожидания, то есть типичная ситуация, когда Postgres нужно не только поднять, его нужно наполнить данными, подождать пока он наполнится, проверить, что он жив, допустим, все это, естественно, поддерживается через стандартные health-чеки докера или же вы можете написать свою собственную стратегию, которая расскажет, как нужно правильно ждать именно конкретно вашу зависимость, что там у нее должно быть, и она его дождется.
1805.72 1840.20 "Анатолий Кулаков" Также в тексте контейнеров есть классная штука, это пренастроенные контейнеры, то есть вам не нужно догадываться, какой там скрипт конфигурации нужно запустить вначале для того, чтобы заработало, какие переменные окружения обязательно передать, как проверить работоспособность, все это уже написано за вас и для многих типичных зависимостей, таких как Postgres, Kafka, Rebit, до тысячи их там, Redis и всякие, а уже все принастроено, то есть вы запускаете просто одной строчкой и у вас это все работает.
1840.20 1845.00 "Анатолий Кулаков" Естественно, если захотите поменять, это можно поменять, но по умолчанию для тестов и так сгодится, и так пойдет.
1845.00 1873.84 "Анатолий Кулаков" Еще один интересный особенность у этого проекта, это ресурс Reaper, то есть если вдруг ваше приложение в процессе тестирования или зависнет, или контейнер потеряет коннекцию с вашим управляющим докером, то есть если он вдруг почему-то каким-то образом у вас сам не выключится, то есть специальный процесс Reaper, который пройдет и все-таки все ресурсы, которые вы там наделали, он 100% завершит.
1873.84 1894.24 "Анатолий Кулаков" Вот это нас спасает от того, что если у нас на Buildagente запустится 10 тысяч неправильных тестов, у вас не будет какая-то утечка ресурсов, которая типично произойдет, когда вы забудете кильнуть какой-то процесс, который сами же запустили, а есть специальный Reaper, который пойдет и за вами все это почистит, это тоже приятная плюшка.
1894.24 1904.84 "Анатолий Кулаков" Ну и если у вас все-таки Graceful Shutdown происходит в приложении, то конечно вы же должны все эти контейнеры задиспользовать, закрыть и опять же все пространство очистится, все будет ясными и шелковистыми.
1904.84 1924.12 "Анатолий Кулаков" Вот теперь благодаря такому подходу, благодаря тест-контейнерам мы полностью убрали зависимость от любых стендов, у нас теперь нет никаких стендов, мы все вот эти сервисы, от которых мы зависим, сторонние, мы таскаем с собой, грубо говоря, мы их поднимаем, мы сами заполняем их теми данными, которые нам нужны для тестирования, никто эти данные кроме нас не поменяет.
1924.12 1932.76 "Анатолий Кулаков" Мы их используем и мы сами уже можем за собой их почистить или можем на это забить, так как это докеры, они просто-напросто уйдут из памяти и про эти данные никто больше не вспомнит.
1932.76 1942.88 "Анатолий Кулаков" У нас нет никакой настройки внешних зависимостей, никакой поддержки версионирования этих подрисов, мы просто сказали контейнер, какой версии мы хотим и все.
1942.88 1948.52 "Анатолий Кулаков" Никто это не должен ни администрировать, ни поддерживать, ни обновлять, ни настраивать, мы просто обо всем этом забыли.
1948.52 1957.60 "Анатолий Кулаков" Наша задача просто оставить на билд-агенте .NET SDK и Docker daemon и все остальное тест-контейнер сделают сами.
1957.60 1966.44 "Анатолий Кулаков" И также мы получили, благодаря всем этим комбинациям, что мы внутри себя содержим всю логику, которая нужна для работы, мы получили хорошую переносимость.
1966.44 1970.60 "Анатолий Кулаков" Теперь мы полностью не зависим ни от стенда, который где-то рядом находится, ни даже от билд-агента.
1970.60 1978.20 "Анатолий Кулаков" Мы можем взять наше приложение, запустить его где угодно, на любом другом CI, например, перенести его на GitHub Actions, запустить точно так же.
1978.44 1986.48 "Анатолий Кулаков" И так как GitHub Actions поддерживает Docker на хостовой системе, то без проблем все наши тесты точно так же пройдут.
1986.48 1990.16 "Анатолий Кулаков" Это тоже такая автономность, приятный бонус, приятный плюс этого подхода.
1990.16 2000.20 "Анатолий Кулаков" Вот таким образом можно сделать полноценное интеграционное тестирование для SPNetCore даже с реальными зависимостями, с реальными баз данными, с реальными Rebit.
2000.20 2011.64 "Анатолий Кулаков" И при этом остаться все-таки в парадигме того, что вы никому не мешаете, ваши тесты изолированы и легко воспроизводимы, так как и вам тоже никто не мешает и никаких конфликтов у вас не будет.
2011.64 2012.64 "Анатолий Кулаков" Вот такая статья.
2012.64 2018.80 "Анатолий Кулаков" Большое спасибо автору, что просветил, собрал у нас все это воедино и написал хорошенькую статейку.
2018.80 2031.52 "Игорь Лабутин" Ну, действительно, штука удобная, я этим пользовался проектом, в смысле библиотекой тест-контейнер на одном из прошлых проектов было весьма удобно.
2031.52 2036.24 "Игорь Лабутин" Так что рекомендую попробовать и посмотреть, поприменять
2036.24 2045.00 "Анатолий Кулаков" у себя. Да, мы тоже запускали на нескольких проектах, библиотека показала себя прекрасно, заинтегрировалась за 2 секунды, работает очень быстро.
2045.00 2048.24 "Анатолий Кулаков" В общем, все отлично, все нравится, все прекрасно.
2048.24 2051.48 "Игорь Лабутин" Ну и хорошо, прикольно, когда библиотеки нравятся.
2051.48 2052.48 "Игорь Лабутин" Пойдем дальше.
2052.48 2055.40 "Игорь Лабутин" Немножко вернемся к дотнету таки.
2055.40 2072.40 "Игорь Лабутин" Попалась статеечка, да, даже не статеечка, Стивен Клери, Стефан Клери, который у нас выступал на конференциях неоднократно и вообще является таким довольно-таки значимым авторитетным в мире дотнета, когда дело касается всякой асинхронщины.
2072.40 2083.24 "Игорь Лабутин" У него в блоге отличное количество статей, отличного качества на тему всяких тасков, асинков и прочих смежных тем.
2083.24 2103.20 "Игорь Лабутин" Он выпустил, я говорю, даже не за меточку, он просто твитнул свой репозиторий, который называется Structured Operations, и он, я не знаю, насколько это прям полезно с точки зрения продакшн использования, но, как мне кажется, репозиторий интересный с точки зрения посмотреть, а что можно делать с тасками и как к работе с ними подходить.
2103.20 2108.08 "Игорь Лабутин" А эта штука называется Task Groups, то есть в чем смысл?
2108.08 2118.00 "Игорь Лабутин" Мы уже сейчас можем запустить, влезть, например, несколько тасочков, запустить, натравить на них waitAll и по сути дождаться, когда у вас все таски закончатся.
2118.00 2119.76 "Игорь Лабутин" Казалась бы простая операция.
2119.76 2128.12 "Игорь Лабутин" Его задачка была сделать штуку, чтобы в эту Task Group можно было, например, добавлять задачки по мере необходимости.
2128.12 2135.96 "Игорь Лабутин" То есть вы закидываете сюда, например, пару задачек, они там что-то работают и по пути докидывают в эту же Task Group еще задачек.
2135.96 2138.40 "Игорь Лабутин" А внешний код дожидается, когда все задачки закончатся.
2138.40 2144.24 "Игорь Лабутин" Ну, то есть такой продвинутый waitAll, по сути.
2144.24 2151.64 "Игорь Лабутин" И в принципе, вот библиотечка ради этого написана, можно посмотреть, как там с этим все работает, потому что там есть интересное поведение.
2151.64 2165.16 "Игорь Лабутин" Если там одна задачка, один task фейлится, то тогда всех остальных нужно заканцелить и дождаться, когда они все заканцелились, и потом выкинуть соответствующий exception, когда ты заэвейтишь всю Task Group.
2165.16 2170.28 "Игорь Лабутин" Если таски канцелятся, то там это игнорится, соответственно, ну заканцелилось и заканцелилось.
2170.28 2182.76 "Игорь Лабутин" При этом в эту же Task Group можно зарегать дополнительно просто какие-нибудь ресурсы в виде idisposable, ну точнее в виде классов, которые реализует idisposable, и тогда когда Task Group закомплетится или зафейлится целиком, они тоже все будут освобождены.
2182.76 2189.64 "Игорь Лабутин" И самое интересное, ну не то чтобы самое интересное, но довольно интересный паттерн, там поддерживается так называемая гонка.
2189.64 2206.20 "Игорь Лабутин" Как я сказал, в большинстве случаев вам нужно закинуть какой-то объем работы и дождаться, когда она вся будет выполнена, но иногда нужно сделать обратную задачку, закинуть несколько параллельных task, и как только выполнится первая, на остальные забить, ну в смысле их заканцелить.
2206.20 2214.72 "Игорь Лабутин" Например, вы ждете ответа от самого быстрого сервера, вам не важно какой сервер ответит, важно чтобы ответил кто-то один, а все остальные ответы после этого не нужны.
2214.72 2217.20 "Игорь Лабутин" Вот соответственно там есть специальный режим для этого.
2217.20 2234.48 "Игорь Лабутин" Так что пока там все на очень ранней стадии, то есть это буквально где-то 3-4 недельки назад появилось, там даже правда уже какой-то ищу есть, что мол, шедулеры кастомные не поддержаны, там прям народ уже сразу все это самое.
2234.48 2254.76 "Игорь Лабутин" Какие-то видимо ребята пришли попробовать, может быть хотят попробовать, и шедулеров не хватает, но вообще если вы работаете с тасками, посмотрите на этот код, особенно если вы пишете какую-то такую инфраструктуру вокруг тасок, там очень аккуратненько все написано с точки зрения работы со всякими cancellation, и фолтами, и прочим добром, чтобы все работало корректно.
2254.76 2273.68 "Анатолий Кулаков" Ну знаю Клэрри, неудивительно, что народ набежал, потому что у него всегда библиотеки отличного качества, и он их не первые годы как бы уже практики поддерживает, и поэтому я думаю, что даже эту штуку, которую он выпустил, ну судя по виду у нее уже классный API, то есть классные возможности, и я думаю, что внутри он тоже там довольно долго и тщательно все протестировал.
2273.68 2285.16 "Игорь Лабутин" Да, и надо сказать, что несмотря на то, что библиотечка такая видимо, не знаю, может им и для работы была нужна, или еще для чего, у нее очень хорошо написано readme, где как бы все аккуратненько расписано, понятно, так что прям прекрасно.
2285.16 2298.56 "Игорь Лабутин" А связанная с этим тема, давайте сразу на нее тоже посмотрим, заодно мы натолкнулись на статейку под названием useful extension methods для класса Tasker.
2298.56 2302.28 "Игорь Лабутин" И вот она такая немножко спорная, мне кажется, то
2302.28 2304.08 "Анатолий Кулаков" есть там автор… То есть полезные методы,
2304.08 2310.68 "Игорь Лабутин" да, которыми можно Task расширить? Ну да, типа написать extension методы, которые, конечно же, в вашем проекте они точно пригодятся.
2310.68 2314.32 "Игорь Лабутин" С первым я, может быть, даже согласен.
2314.32 2338.64 "Игорь Лабутин" Первый это fire and forget, то есть если у вас есть task, у которого вам не важны результаты, вам не нужно дожидаться его исполнения, и вам более-менее пофигу, чем он там закончится, ну, соответственно, если вы просто его напишете, то там, если у вас в проекте включены соответствующие аналайзеры, то вам скажут, вот, вы должны выйти в эту штуку, ну, типа, метод уже возвращает task, а вы его просто вызвали, ну, короче, как-то будет неаккуратненько.
2338.64 2344.24 "Анатолий Кулаков" Ну, в обычном коде это действительно признак того, что вы совершили ошибку, вы забыли подождать task, обычно люди такого
2344.24 2382.04 "Игорь Лабутин" не хотят. Да, поэтому вот напишите метод fire and forget, который внутри аккуратненько вызовет эту штуку, и опционально можно передать, так называемую, ну, просто лямбдочку, которая будет выполнена, если будет что-то фолтиться внутри, внутри он тупо делает там, условно, task run, да, и await внутри вашего task, и try catch вокруг, если, а, нет, стоп, вру, он делает continue with с флажком only on faulted, ну, и, соответственно, если он зафолт, task заполнился исходное, ну, тогда, соответственно, вызовется ваш хендлер, если вы его передали.
2382.04 2392.40 "Анатолий Кулаков" Это… Ну, я с тобой согласен, потому что, ну, что этот метод юзабельный, потому что я вот на нескольких своих проектах прямо его писал, да, то есть это реально на практике у меня такой метод часто есть.
2392.40 2395.04 "Игорь Лабутин" Вот, с ним как бы окей.
2395.04 2399.52 "Игорь Лабутин" Второй метод спорный, я не знаю, мне никогда не требовался, называется retry.
2399.52 2411.32 "Игорь Лабутин" Метод заключается тупо в том, что он в цикле вызывает вашу task, ну, в смысле пытается ее вызвать, выясняет, что она там, не знаю, зафейлилась, и снова вызывает заданное количество раз.
2411.32 2415.36 "Игорь Лабутин" Я не очень понимаю, зачем прям такой метод, мне кажется,
2415.36 2431.36 "Анатолий Кулаков" это… Ну, смотри, допустим, тебе нужно достучаться до какого-то веб-сервиса, этот веб-сервис там сейчас в этот момент обновляется, и ты, наверное, можешь получить первый раз fail, пока он в шотдауне, но тебе нужно попробовать еще разок через какой-то дилей, и после этого этот сервис уже поднимется и вернет тебе твой JSON-любимый ответ.
2431.36 2442.32 "Игорь Лабутин" Да, но тогда я бы все-таки ожидал, что дилей будет как-нибудь, ну, вот как там, poly делать, увеличивающийся, или еще что-нибудь в таком духе, здесь он просто фиксированный через task delay и все.
2442.32 2453.24 "Анатолий Кулаков" Ну, конечно, это же слишком сложнее, если там через poly и все такое, массив каких-нибудь дилеев, какой-нибудь функция по нарастанию дилеев, а тут примитивные экстеншн-методы, которые вот пишутся в тые строчки.
2453.24 2466.76 "Игорь Лабутин" Ну, да, ну, не знаю, мне все-таки это кажется такой, и я, может быть, не прав, но я это все-таки больше рассматриваю почти как бизнес-логику, скажем так, и прятать это в какой-то такой экстеншн-метод, ну, не знаю, не знаю.
2466.76 2473.88 "Игорь Лабутин" По мне спорное решение, мне кажется, лучше более явно это писать прямо там, где нужно, а не просто универсальный экстеншн-метод.
2473.88 2474.88 "Игорь Лабутин" Ну, ладно.
2474.88 2488.60 "Игорь Лабутин" Допустим, следующий, еще интереснее, это метод называется onFailure, он, короче, выйдет task и ловит любые экстеншн, которые произошли вокруг, и если экстеншн пойман, он вызывает хендлер, который вы передали.
2488.60 2498.60 "Игорь Лабутин" Ну, то есть вы пишете, не знаю, ваш какой-нибудь метод, который асинковый, ставите после него точечку, говорите, а onFailure вызови мне вот эту лямточку.
2498.60 2507.56 "Игорь Лабутин" И самое главное, вы дальше продолжаете код, то есть этот метод, он не делает там никакого выкидывания экстеншн заново, он просто продолжит ваш код дальше.
2507.56 2520.08 "Игорь Лабутин" То есть типа, выполни вот эту функцию, ну, в смысле, выполни async-метод, если он зафейлился, выполни какой-то альтернативный вариант в виде вашей лямбды и идем дальше выполнять исходный метод.
2520.08 2528.64 "Игорь Лабутин" Мне кажется, это очень странная методика, обычно если что-то упало, ну, вам, наверное, все-таки что-то надо как-то и в вызывающем коде сделать по-другому.
2528.64 2533.48 "Анатолий Кулаков" Да, наверное, автор писал, для того, чтобы просто залагировать эту ошибку и пойти дальше работать.
2533.48 2548.96 "Анатолий Кулаков" Но видишь, тут как-то интересно, что он возвращает простой таск, не генериковый, поэтому он даже результат никак не обрабатывает, поэтому ему, скорее всего, все равно получилось, не получилось, типа, знаешь, такое что-то типа file_forget, но плюс ты хочешь еще залагировать, что случилось.
2548.96 2551.00 "Игорь Лабутин" И пойти дальше исполнять в этом же методе.
2551.00 2562.96 "Игорь Лабутин" Ну, короче, мне странно, то есть я редко писал код такой, что как бы вот я вызывал, у меня какой-то длинный метод, я вызвал какой-то метод, он мне что-то кинул эксцепшн, я его просто там, не знаю, залагировал и пошел дальше, как будто не вызывал.
2562.96 2565.60 "Игорь Лабутин" Ну, может бывает такое, но это как-то странно выглядит.
2565.60 2567.60 "Игорь Лабутин" Тогда же проще file_forget, действительно.
2567.60 2579.16 "Анатолий Кулаков" Я думаю, вся проблема с вот этими эксценшнами, мы не понимаем, в каком контексте автор их любит использовать, потому что, естественно, есть куча тонкостей, куча нюансов, иначе бы они все были в стандартной библиотеке BCL.
2579.16 2587.64 "Игорь Лабутин" Да, и вот следующий, кстати, это из такого самого, из таких категорий, из такой категории, это timeout.
2587.64 2608.36 "Игорь Лабутин" Метод называется timeout, и он реализуется классическим способом, мне кажется, даже, не знаю, на собеседование может не спрашивать, но это классический паттерн, когда вы делаете task_delay, берете вот этот созданный task, берете ваш task, которого нужно дождаться, и делаете when_any, ну, кто первый завершился, ну и в конце проверяете, естественно, кто там первый сработал, delay или ваш task.
2608.36 2622.36 "Анатолий Кулаков" Ну, не очень христианомативный вариант, потому что здесь проблема в том, что как только ваш delay первым освободится, а task продолжит долго-долго выполняться, то этот долго-долго выполняющийся task даже никто не отменит, обидно, ресурсы жрутся, а ты его уже не ждёшь.
2622.36 2635.80 "Игорь Лабутин" Да, его нужно действительно cancelить, и наоборот, если task закончился, а delay ещё не закончился, там тоже есть тонкости, что там task_delay же внутри на таймерах, там короче тоже, если вы много раз это будете дёргать, там не бесплатное это дело.
2635.80 2640.08 "Анатолий Кулаков" Да, тема с таймерами вообще заслуживает отдельной статьи, ну, мне кажется, она у нас даже и была пророком.
2640.08 2645.24 "Игорь Лабутин" Где это было, да, ты мне в прошлый раз же, по-моему, перечислял эти 5 таймеров, которые бывают в дотнете, или 6, сколько их там было.
2645.24 2646.24 "Игорь Лабутин" Да-да-да.
2646.24 2653.84 "Игорь Лабутин" Вот, но вот это API действительно очень частая, и поэтому с 6 дотнета у нас есть wait_async, куда можно передать timeout, и он будет аккуратно всё делать сам.
2653.84 2657.76 "Игорь Лабутин" Вот, поэтому тут как раз подумал Microsoft.
2657.76 2680.84 "Игорь Лабутин" И последний метод, который предлагает автор, это fallback, он тоже как-то немножко, ну, не знаю, мне тоже, по-моему, ни разу не требовался, хотя, может быть, можно про это подумать, значит, мы вызываем async метод, await'им его, ждём какого-нибудь exception, и если прилетел exception, то мы вместо результата этого метода возвращаем дефолтное значение, которое было передано в этот самый fallback.
2680.84 2686.56 "Игорь Лабутин" Ну, то есть, типа, вызови какой-то async метод, и если он навернётся, вот, используй этот fallback value.
2686.56 2696.00 "Игорь Лабутин" Ну, в принципе, наверное, можно найти какое-то применение этому методу, хотя мне тоже кажется, что это уже какой-то кусок а-ля бизнес-логики в каком-то смысле.
2696.00 2712.56 "Анатолий Кулаков" Мне кажется, тут та же проблема, что и с методом on_fail, который мы обсуждали, то есть автор не очень любит кетчи писать, а try_catch для него это, похоже, слишком длинное всё такое, и он пытается это в более функциональный такой стиль перевести, когда у тебя на кетч вызывается просто напросто какая-то обрабатывающая лямбда, какой-то action.
2712.56 2717.52 "Игорь Лабутин" Ну, может быть, да, может быть, действительно, так привычнее.
2717.52 2736.28 "Игорь Лабутин" Вот, но есть ещё одна большая проблема со всеми этими методами, которые он предлагает, в них не поддерживаются никакие consolation токены, поэтому вы не сможете туда ничего передать, то есть если вы хотите что-то подобное писать, нужно аккуратненько всё это писать с использованием consolation токенов, чтобы они учитывали… Кастомные шедулеры, как ты сказал уже.
2736.28 2745.04 "Игорь Лабутин" Ну, ладно, кастомные шедулеры, наверное, ладно, но consolation токены точно нужно, потому что они везде, нужно уметь менять кооперативно вот это вот всё.
2745.04 2761.20 "Игорь Лабутин" И второй момент, что, например, вот эти самые try_catch, они не учитывают отдельный operation_canceled_exception, как известно, когда таска консолится, она выкидывает operation_canceled_exception, и собственно объемлющий код может понять, что она заканцелилась.
2761.20 2771.52 "Игорь Лабутин" И вот они не обрабатываются отдельно, и поэтому если вы честно заканцелили таску, там она может вам… может показаться, что она на самом деле зафолтилась.
2771.52 2775.48 "Игорь Лабутин" Это, конечно, может быть и норм в случае, например, каких-нибудь там fallbacks.
2775.48 2780.28 "Игорь Лабутин" Вам не важно, она зафейлилась или она заканцелилась, вы всё равно возвращаете fallback.
2780.28 2793.56 "Игорь Лабутин" Но в некоторых случаях это может быть важно, и поэтому когда вы ловите exception от таски, помните, что вам может пролететь operation_canceled_exception, и это совсем не означает падение, это значит, что её кто-то сознательно заканцелил.
2793.56 2800.32 "Игорь Лабутин" Ну или она там сознательно спросила у cancellation_token, что как там throw_if_canceled.
2800.32 2801.32 "Игорь Лабутин" Такие дела.
2801.32 2814.40 "Игорь Лабутин" Поэтому статейка в show_notes будет, можете на неё посмотреть, но применяйте с умом, думайте, нужно ли это в вашем случае, не надо всё закидывать горой extension методов, как мне кажется, бездумно.
2814.40 2825.44 "Игорь Лабутин" А лучше подумать, зачем вам это надо, и действительно, если есть повторяющийся паттерн, который повторяется вообще везде в вашей бизнес-логике, то вполне можно тогда, конечно, применить extension метод.
2825.44 2833.04 "Анатолий Кулаков" Ну и описать его, собственно, для вашего конкретного проекта, в вашем конкретном случае, потому что универсальных случаев найти очень сложно.
2833.04 2836.16 "Анатолий Кулаков" Если они есть, то Клир их уже нашёл и описал в своей
2836.16 2859.60 "Игорь Лабутин" библиотеке. И, кстати, может быть назвать по-нормальному, потому что если вы назовёте ваш метод timeout, extension метод у Task, то как бы, ну это, наверное, здорово, но лучше всё-таки там, я бы его называл как-то более говоряще, типа там return что-нибудь onTimeout или, ну, короче, handleTimeout, ну, я не могу сейчас придумать, потому что вот это нужно прям по проектному вашему именованию смотреть.
2859.60 2869.56 "Игорь Лабутин" Но я бы избегал таких очень дженериковых имён, когда вы экстендите такой класс, как Task, потому что Task везде, и он всё время будет вам тогда попадаться.
2869.56 2872.16 "Анатолий Кулаков" Это точно.
2872.16 2875.00 "Анатолий Кулаков" Ну что ж, продолжаем рубрику «Расширяй горизонты».
2875.00 2877.92 "Анатолий Кулаков" Хотелось бы вам рассказать ещё об одном новом инструменте.
2877.92 2885.88 "Анатолий Кулаков" Ну, не то чтобы новом, он у нас есть уже довольно давно, просто о нём мало говорится, мало слышится, в общем, и мы, по-моему, даже про него ни разу не рассказывали.
2885.88 2889.00 "Анатолий Кулаков" Хотим исправиться, инструмент прекрасный, хотим вам про него рассказать.
2889.00 2892.00 "Анатолий Кулаков" А инструмент – это ноутбуки.
2892.00 2911.08 "Анатолий Кулаков" И совсем недавно, вот с предыдущим релизом .NET, некий интерактив C#, то есть такая интерактивная оболочка, в которой можно писать на C#, преобразовалась, заребрендилась и дала направление новым разработкам в Микрософте под именем Polyglot Notebooks.
2911.08 2918.20 "Анатолий Кулаков" Те, кто не знаком ещё с ноутбуками, давайте немножко нырнём в эту терминологию, в этот мир и рассмотрим поподробнее.
2918.20 2923.04 "Анатолий Кулаков" Ноутбуки – это такой специальный инструмент для интерактивного программирования.
2923.04 2931.60 "Анатолий Кулаков" Они прекрасны тем, что это обычный отдельный файлик, который программируется и который описывается с помощью специального синтексиса.
2931.60 2935.88 "Анатолий Кулаков" Этот файлик поддерживает не несколько секций, секции различных типов.
2935.88 2942.88 "Анатолий Кулаков" В основном это секции в виде кода, в которых вы прямо пишете настоящий код на определённом языке программирования.
2942.88 2948.40 "Анатолий Кулаков" И после выполнения этого кода у вас возникает секция с каким-то результатом.
2948.40 2954.68 "Анатолий Кулаков" Этот результат может быть визуализирован в виде графиков, диаграмм, картинок и чего угодно ещё.
2954.68 2962.16 "Анатолий Кулаков" И также типичным представителем секций в таких файликах является обычный текст, который вы что-то описываете.
2962.16 2965.08 "Анатолий Кулаков" Легче всего это представить в виде интерактивной документации.
2965.08 2969.84 "Анатолий Кулаков" Представляете, вы читаете MSDN, что вот это строки, они используются вот так вот.
2969.84 2975.68 "Анатолий Кулаков" А теперь если сложить две строки и начинается блок кода, то вы получите такое-то значение.
2975.68 2984.52 "Анатолий Кулаков" И этот блок кода можно нажать специальный магический квадратик «выполнить», треугольничек скорее всего, зелёненький треугольничек «выполнить» и он реально выполнится.
2984.52 2987.32 "Анатолий Кулаков" Как настоящая программа.
2987.32 2996.52 "Анатолий Кулаков" Таким образом вы можете совместить вместе документацию и живой код, который никогда не устареет, потому что он компилируется и выполняется прямо в этом документике.
2996.52 2999.72 "Анатолий Кулаков" Подобная схема называется как раз-таки ноутбуки.
2999.72 3010.48 "Анатолий Кулаков" Она позволяет коду выполняться и не просто выполнять весь код, который там есть в этом листинге, то есть это не просто какой-то отдельный скрипт, а выполнять его именно по отдельным сегментам.
3010.48 3018.04 "Анатолий Кулаков" Если вы в отдельный сегмент написали одну строчку, написали туда целый метод, значит выполнит метод.
3018.04 3020.20 "Анатолий Кулаков" Написали туда тысячу строк, значит будет выполнен тысяча.
3020.20 3033.80 "Анатолий Кулаков" То есть вы можете вот эти сегменты таким образом дробить и поэтому ваши примеры могут с той или иной точностью выдавать те или иные результаты, что бывает очень удобно.
3033.80 3039.28 "Анатолий Кулаков" Этот термин придумал и популяризовал юпитер-ноутбуки.
3039.28 3048.04 "Анатолий Кулаков" Это такой open-source проект, который изначально был создан для дата-сантистов и любой дата-сантист безумно любит этот инструмент.
3048.04 3050.00 "Анатолий Кулаков" Это является прям рабочим его инструментом.
3050.00 3057.72 "Анатолий Кулаков" Как мы открываем с утра Visual Studio или Rider, то дата-сантисты открывают юпитер-ноутбуки и начинают там свои сантистские делишки делать.
3057.72 3064.20 "Анатолий Кулаков" И в естественном юпитер-ноутбуке дата-сантисты и там все пишется на питоне.
3064.20 3075.84 "Анатолий Кулаков" Нормальным людям о питоне ораться не сильно хочется, поэтому как раз-таки Microsoft начал думать в сторону того, чтобы изобразить что-то на более приличных языках.
3075.84 3079.80 "Анатолий Кулаков" И таким образом родился как раз-таки Polyglot Notebooks.
3079.80 3088.24 "Анатолий Кулаков" С помощью Polyglot Notebooks вы можете прекрасно учиться или наоборот обучать новому языку программирования.
3088.24 3089.24 "Анатолий Кулаков" То есть это...
3089.24 3091.56 "Анатолий Кулаков" Или что-нибудь быстренько запрототипировать.
3091.56 3094.48 "Анатолий Кулаков" Нужно вам там узнать, каким образом форматируются даты или гуиды.
3094.48 3100.96 "Анатолий Кулаков" В общем, это хорошее место, где вы можете просто-напросто написать в легковесном редакторе, в легковесном файлике.
3100.96 3104.60 "Анатолий Кулаков" Просто одну строчку нажать, волшебный треугольничек и все выполнится.
3104.60 3108.72 "Анатолий Кулаков" То есть это удобно для обучения, для показывания, для прототипирования, для тестирования.
3108.72 3109.92 "Анатолий Кулаков" Вообще мега удобная штука.
3109.92 3113.28 "Анатолий Кулаков" Так, теперь поближе к Polyglot.
3113.28 3114.28 "Анатолий Кулаков" Почему же он Polyglot?
3114.28 3117.88 "Анатолий Кулаков" А потому что Microsoft решил не ориентироваться на какой-то один язык.
3117.88 3120.76 "Анатолий Кулаков" Вот как юпитер-ноутбук, они и были только про питона.
3120.76 3125.92 "Анатолий Кулаков" Естественно, клоны юпитер-ноутбуков делались и есть и существуют на абсолютно любых языках.
3125.92 3135.52 "Анатолий Кулаков" В общем, Microsoft пошел немножко шире, и он решил написать именно систему, инфраструктуру под абсолютно любые языки, которых можно добавлять сколько угодно много.
3135.52 3141.28 "Анатолий Кулаков" В частности, сейчас юпитер-ноутбуки поддерживают language-сервисы, то есть language-сервер.
3141.28 3145.32 "Анатолий Кулаков" Language-сервер – это штука, которая была изобретена вместе с Visual Studio Code.
3145.32 3155.04 "Анатолий Кулаков" То есть, грубо говоря, практически все языки, которые поддерживаются в Visual Studio Code, а это практически все языки, могут потенциально быть поддержаны в юпитер-ноутбуке.
3155.04 3157.96 "Анатолий Кулаков" Там есть тонкости с тем, что такое поддержка.
3157.96 3160.96 "Анатолий Кулаков" Сейчас мы об этом поговорим чуть попозже.
3160.96 3169.00 "Анатолий Кулаков" И список этих языков на данный момент составляет такой немаленький наборчик.
3169.00 3180.32 "Анатолий Кулаков" Это C#, F#, PowerShell, JavaScript, HTML, MermaID – это для рисования диаграммок с помощью текста, SQL и Kusto – query language, KSQL.
3180.32 3184.80 "Анатолий Кулаков" Это, по-моему, какой-то язык запросов к ажурским всяким сервисам.
3184.80 3188.80 "Анатолий Кулаков" Это на старте, Microsoft отмечает, что в будущем будет больше, будем добавлять и всего такое.
3188.80 3203.60 "Анатолий Кулаков" И самое интересное, что раньше, в принципе, никакие ноутбуки не предоставляли, они там, может быть, и поддерживали несколько языков, но самое интересное, что никто из них раньше не предоставлял расшаривания данных между различными языками.
3203.60 3209.08 "Анатолий Кулаков" То есть, между вот этими секциями, где вы описываете часть программы, данные, естественно, шарятся.
3209.08 3213.52 "Анатолий Кулаков" Вы можете сначала выполнить одно действие, потом на основании его результата выполнить другое действие.
3213.52 3235.00 "Анатолий Кулаков" Но вот чтобы вы начало первое действие сделали на C#, там, допустим, создали SQL-коннекцию на C#, сходили к MS SQL сервису, затащили оттуда данные, преобразовали эти данные, отдали в JavaScript, JavaScript сделал между ними визуальный маппинг и отдал какой-то визуализатор, который нарисовал вам красивый чарт.
3235.00 3242.60 "Анатолий Кулаков" Вот это все можно сделать в одном единственном инструменте, в одном единственном файлике с помощью Polyglot ноутбука.
3242.60 3245.80 "Анатолий Кулаков" Раньше такое было сделать довольно-таки сложно.
3245.80 3251.24 "Анатолий Кулаков" И вот как раз-таки Polyglot ноутбук предоставляет вот эту фишку – расшаривание переменных между различными языками.
3251.24 3256.56 "Анатолий Кулаков" Ну и, соответственно, расшаривание какого-то workflow, который может эти переменные мутировать.
3256.56 3260.28 "Анатолий Кулаков" Технически Polyglot ноутбук представляет из себя плагин для VS-кода.
3260.28 3275.40 "Анатолий Кулаков" Поэтому, если у вас есть код, VS-код, то за 3 секунды к нему ставится плагин, который под капотом имеет дотное интерактив, как я уже говорил, и вы получаете всю вот эту мощь, всю вот эту красивость, всю вот эту прелесть.
3275.40 3278.40 "Анатолий Кулаков" Итак, language services.
3278.40 3285.44 "Анатолий Кулаков" Как я уже сказал, что поддержка language services есть, но language services вам не дают обмена вот этими универсальными данными.
3285.44 3292.60 "Анатолий Кулаков" То есть формат, протокол взаимодействия для того, чтобы шарить переменные между языками программирования, он все-таки требует отдельной проработки.
3292.60 3297.56 "Анатолий Кулаков" Вот для объявленных языков он уже сделан, а для других языков пока нет.
3297.56 3309.88 "Анатолий Кулаков" Но зато, если у вас есть языки, которые поддерживаются language services, вы бесплатно из коробки получаете различные плюшки типа автокомплита, подсвечивания синтаксов, всяких примитивных анализов и базовых рефакторингов.
3309.88 3315.00 "Анатолий Кулаков" То есть это у вас уже есть, потому что вы используете language services.
3315.00 3318.20 "Анатолий Кулаков" Из интересного.
3318.20 3323.16 "Анатолий Кулаков" Код, естественно, можно писать в одну строчку на C# или на любом поддерживаемом языке в несколько строчек.
3323.16 3327.32 "Анатолий Кулаков" Можно запускать кнопочку секции, можно там Ctrl+Enter нажать и он запустится.
3327.32 3333.76 "Анатолий Кулаков" Можно панипулировать с кодом и показывать, как он взаимодействует в тех сценариях, которые вы описали.
3333.76 3335.16 "Анатолий Кулаков" Очень легко, очень непринужденно.
3335.16 3340.88 "Анатолий Кулаков" И это все, как я уже сказал, обычно обрамляется кучей текста, кучей поясняющей документации.
3340.88 3355.32 "Анатолий Кулаков" Документация поддерживается в Markdown, естественно, со всеми расширениями типа GitHub-овских всяких расширений и стандартные базовые там хидра, параграфы, ссылки, листы, вставление картинок, все это тоже есть.
3355.32 3362.36 "Анатолий Кулаков" Также поддерживается использование, установка пакетов из NuGet.
3362.36 3374.44 "Анатолий Кулаков" Вы вполне можете зареферентировать в какой-нибудь Microsoft ML библиотечку и начать творить, уже экспериментировать с какими-то ML данными, строить какие-то модели и выводить какие-то графики.
3374.44 3388.76 "Анатолий Кулаков" Кстати, вот графики, визуализация - это отдельная штука, которую стоит упомянуть, потому что, наверное, это самая воодушевляющая вещь, которая здесь есть, потому что реально код смешанный с документацией - это, конечно, прикольно, но это более-менее представимо.
3388.76 3407.76 "Анатолий Кулаков" А вот когда у тебя из этого кода ты там собрал какие-то точки, как-то их сегрегировал, как-то выделил из них какую-нибудь статистику и все это показал прямо в этом же документе на красивой диаграмме, которая динамически изменяется, если вдруг у тебя поменялись данные, вот это действительно вызывает такой хороший, интересный вау-эффект.
3407.76 3412.44 "Анатолий Кулаков" Поэтому на Polyglot ноутбуке лучше всего, конечно, посмотреть.
3412.44 3425.28 "Анатолий Кулаков" И чтобы посмотреть, у нас для вас тоже есть прекрасная штука, потому что недавно совсем у нас прошел митап, на котором выступал Антон Шевченко и рассказывал как раз про Polyglot ноутбуки и как интерактивно с ними взаимодействовать.
3425.28 3437.92 "Анатолий Кулаков" Поэтому те, кто больше любит смотреть лекции, приглашаем вас, видосик не очень длинный, но зато очень познавательный, очень интересный для того, чтобы познакомиться с новым инструментом, вот сам этого.
3437.92 3440.76 "Анатолий Кулаков" Ссылочки тоже будут у нас в шоу-ноутах.
3440.76 3446.36 "Игорь Лабутин" Ну, прекрасно, я так и не попробовал, к сожалению, как-то мне всю руку не доходит, никакие ноутбуки.
3446.36 3447.72 "Игорь Лабутин" Ну, сама идея прекрасна.
3447.72 3456.80 "Игорь Лабутин" Идея прекрасна, не спорю, так что, может быть, надо будет тоже добраться, на самом деле видосик пересмотреть и глянуть, чем это может быть полезно.
3456.80 3461.60 "Анатолий Кулаков" Мне кажется, это хорошая замена линкопаду, например, а вот линкопадом я пользуюсь практически каждый день.
3461.60 3462.60 "Анатолий Кулаков" Да, я тоже.
3462.60 3465.32 "Анатолий Кулаков" И это примерно вот где-то там рядом стоит.
3465.32 3480.16 "Игорь Лабутин" Ну да, только есть возможность смешивать и вот графики, потому что в линкопаде всё-таки ограничено тем, что придумал автор, грубо говоря, ну либо то, что ты сам написал какие-нибудь там плагины, не знаю, визуализацию, там в принципе в pdf можно любое писать, но это же надо писать, и в pdf всё-таки.
3480.16 3484.24 "Анатолий Кулаков" Ну и там ты замкнул только внутри там C#, то есть внутри кода.
3484.24 3488.92 "Анатолий Кулаков" А здесь прекрасно, что и Markdown всё это можешь описать ещё и плюс, да, графики построить разные.
3488.92 3494.64 "Игорь Лабутин" Ну да, так что интересно, интересно, наверняка есть какие-то хорошие практически применения.
3494.64 3503.00 "Игорь Лабутин" Пойдём дальше, дальше у нас вообще тема, которая очень широкая, где мы можем уйти вообще неизвестно куда, посмотрим, насколько далеко и куда мы сможем уйти.
3503.00 3504.00 "Игорь Лабутин" Это техрадар.
3504.00 3544.08 "Игорь Лабутин" Техрадар вообще штука, технологерадар, если быть полностью это называть, штука довольно популярная, она популярная в разных компаниях, то есть разные компании такое делают, кто-то публично, кто-то приватно внутри, и по сути она нужна для того, чтобы понимать взгляд этой самой компании или набора людей внутри этой компании на современные технологии, тулы и вообще всякие штуки, которые относятся к их деятельности с точки зрения, что применять, что не применять, что выкинуть, что заменить, а на что, к чему присмотреться, потому что может быть будет полезно в будущих проектах.
3544.08 3554.12 "Игорь Лабутин" И много таких компаний, много компаний делают такие техрадары, но один техрадар от компании ThoughtWorks, он наверное самый известный, наверное именно с него всё началось.
3554.12 3557.00 "Анатолий Кулаков" Да, самый старейший, самый каноничный.
3557.00 3559.84 "Игорь Лабутин" Ну да, и самый, так сказать… Самый авторитетный.
3559.84 3561.76 "Игорь Лабутин" Ну да, давай назовём это так.
3561.76 3569.68 "Игорь Лабутин" И вот вышел в апреле уже 28 выпуск, я не помню, они его выпускают два раза в год или четыре раза в год?
3569.68 3572.36 "Анатолий Кулаков" По-моему, да, я тоже боюсь соврать, не помню.
3572.36 3579.24 "Анатолий Кулаков" А, ну ты ещё не сказал, что за всем этим техрадаром и собственно за ThoughtWorks, если кто не знает, стоит Мартин Фаулер.
3579.24 3591.28 "Игорь Лабутин" Ну и не только Мартин Фаулер, там есть много разных других интересных и довольно знаменитых людей, то есть если вы занимаетесь хоть как-то архитектурой, вам наверное известно имя Нила Форда.
3591.28 3596.28 "Игорь Лабутин" Это тоже… Вот это человек, который написал прям отличные книжки по всей архитектуре.
3596.28 3607.08 "Игорь Лабутин" И действительно там набор всяких разных таких консалтеров, которые… Основная работа которых на самом деле консультировать всякие разные, разные, очень разные компании.
3607.08 3614.44 "Игорь Лабутин" И за счёт этого у них появляется, во-первых, с одной стороны большой кругозор на всяких… Про всякие технологии, тулы и прочее.
3614.44 3618.72 "Игорь Лабутин" А с другой стороны небольшая практика того, как это на самом деле работает в разных компаниях.
3618.72 3626.52 "Игорь Лабутин" У них складывается некоторое мнение на тему разных штук, и они его пытаются сформулировать в виде такого довольно компактного документа.
3626.52 3638.56 "Игорь Лабутин" Документ всего на 47 страничек, где разделены… Про каждую значит технологию, тул или ещё какую-нибудь штуку, она отнесена к четырём… К одной из четырёх категорий.
3638.56 3647.60 "Игорь Лабутин" Соответственно, одна это называется Adopt, это значит всё, точно, вы как бы это пробовали много раз, можно использовать, точно берите, скорее всего не прогадаете.
3647.60 3656.40 "Игорь Лабутин" Есть категория Trial, это скорее всего будет полезно, можно попробовать, даже если вы большой интерпрайс, где как бы сложно внедрять новые штуки.
3656.40 3670.64 "Игорь Лабутин" Но если у вас есть какой-нибудь проект, где можно там чуть-чуть порисковать, допустим, ну то есть там тащить сразу в какую-нибудь процессинговую систему для банка, наверное, не стоит, но какой-нибудь там внешний портал написать на какой-нибудь новой технологии, почему бы нет, если она в разделе Trial.
3670.64 3674.96 "Игорь Лабутин" Попробуйте посмотреть, как оно проживётся в вашем конкретном стеке, в вашей компании.
3674.96 3682.56 "Игорь Лабутин" Есть категория Assess, это значит, ну так, присмотреться, но непонятно, насколько оно полетит.
3682.56 3693.84 "Игорь Лабутин" Ну и последняя категория Hold, это то, что, возможно, не стоит уже трогать, либо потому что оно устаревшее, либо потому что практика показала, что как-то не очень хорошо работает.
3693.84 3721.36 "Анатолий Кулаков" Я вот помню, что свои первые техрадары я прямо ещё находил на компакт-дисках журнала Хакера, в общем, там ещё имя зачитывалось, и меня вот с самых первых выпусков смущало вот эти четыре названия, я ещё тогда очень плохо знал английский, и вот никак не мог просоцировать вот эти названия с тем, что они за собой стоят, а вот сейчас я английский уже получше знаю, но всё равно вот эти названия уродские, которые мне подобрали, не могли что-нибудь покрасивше сделать, а?
3721.36 3723.36 "Игорь Лабутин" Ну как это, use, don't use.
3723.36 3725.36 "Игорь Лабутин" Да, вот понятно человечеству.
3725.36 3727.36 "Анатолий Кулаков" Вот это не use, это три ласси.
3727.36 3733.00 "Анатолий Кулаков" В общем, сложно, сложно, ну да, через это надо пережагнуть,
3733.00 3790.20 "Игорь Лабутин" запомнить и принять. Да, при этом надо понимать, что всякие разные тулы, технологии и прочие штуки, которые они, кстати, называют внутри blips, если я правильно помню, какое-то у них такое очень смешное слово, они могут мигрировать, то есть в каждом техрадаре вещь может, ну в смысле вот такая технология там может, например, перемещаться, казалось бы, она аналогично должна перемещаться там из assess в trial и в adopt со временем, но на самом деле некоторые могут прыгать сразу в adopt, некоторые могут вообще рандомно прыгать между ними, а некоторые исчезают, но это не значит, что всё, про них надо забыть и больше не использовать, это просто означает, что скорее всего каких-то существенных изменений нет в этой технологии, вы просто ищите последний техрадар, куда оно было включено и смотрите там, в какой категории она была, потому что pdf не резиновый, хочется это всё-таки как-то ну хоть как-то ограничивать по времени и размеру, и поэтому влезает не всё.
3790.20 3811.44 "Игорь Лабутин" Вот сейчас в этом техрадаре 107 пунктов, 107 различных либо технологий, либо всяких штук, причём большинство традиционно находится в разделе trial и assess, вот я сейчас смотрю общую диаграмму, в adopt находится всего 10 штук из 107, а в hold 4, а всё остальное равномерно размазано между trial и assess.
3811.44 3824.80 "Анатолий Кулаков" Ну тут нужно сказать ещё, что они иногда выбрасывают технологии с предыдущих радаров, не помещая их, например, в hold, что наверное логично было бы думать, что сначала, прежде чем выкинуть технологию, они её захолдят, но нет, они иногда просто прям из adopt её могут выкинуть.
3824.80 3852.60 "Игорь Лабутин" Ну я так понимаю, что в hold попадает прям вот такое то, что всем казалось, что точно надо использовать, но на практике оказалось очень стрёмно или там не работает, и тогда прям надо явно заменшить, что вот hold, hold и типа не трогайте это, ну или там подумайте и может быть, это не значит, что нельзя трогать и всё, надо срочно прекратить и пользоваться, скорее всего, это значит, что надо задуматься и понять, что наверное комьюнити как-то что-то в ней нашла, что может быть не очень хорошо.
3852.60 3855.36 "Игорь Лабутин" Ну ладно, давай к сути, есть что-нибудь интересное?
3855.36 3856.36 "Игорь Лабутин" Да, давай к сути.
3856.36 3870.60 "Игорь Лабутин" Во-первых, есть в техрадаре сначала начинается так называемый раздел, у них это по-английски называется themes, то есть такие основные темы, да, потому что эти 107 как бы это не просто 107 рандомных тулов каких-то, они всё-таки как-то сгруппированы примерно по тему.
3870.60 3882.80 "Игорь Лабутин" И ну первая тема, ну понятное дело, это искусственный интеллект, чат gpte, копайлот и вот это всё вокруг всякого аи, там если почитать, по-моему там треть техрадара посвящена тулзам вокруг аи.
3882.80 3898.20 "Игорь Лабутин" Вторая большая тема это accessibility, тоже довольно много всего вокруг дизайна, accessibility, тестирования этого дела, даже юнит тестирования accessibility, очень мне странно представлять, что это такое, но тем не менее.
3898.20 3905.44 "Игорь Лабутин" Отдельный большой хайп вокруг лямбд, у нас сейчас есть и там есть интересные паттерны и антипаттерны, которые упоминаются.
3905.44 3936.84 "Игорь Лабутин" И последний раздел это декларатив, ну скажем так, разница между декларативным подходом и императивным подходом, то есть либо вы делаете, условно говоря, какую-нибудь декларативную штуку для там вашего дипломента, что я хочу, чтобы мои там не знаю сервера выглядели так, а дальше тулинг сам добивается того, что нужно, либо вы пишите прям скрипту, скриптуете, как нужно модернизировать ваш environment, чтобы стало как надо.
3936.84 3943.04 "Игорь Лабутин" И вот есть всякие разные тулы, подходы вокруг этого дела.
3943.04 3953.60 "Игорь Лабутин" Это темы большие, мы не будем рассматривать вообще всё, потому что 107 пунктов и детально по ним пробегаться, это PDF на 47 страниц, но это всё равно 40 страниц этих штук.
3953.60 3966.48 "Игорь Лабутин" Я для себя какие-то интересные, те, которые мне было интересно почитать, за что зацепился глаз, выписал, так скажем, и вот сейчас по ним пробежимся, если у тебя есть что-то интересное, то добавляю.
3966.48 3977.72 "Игорь Лабутин" Первых в Adopt, на первый раз делал это техники, техникс по-английски, то есть это всякие разные такие, больше организационные, нежели чем тузовые штуки.
3977.72 3991.60 "Игорь Лабутин" И одна из штук в разделе Adopt называется dependency pruning, то есть это потратьте время, точнее тратьте время регулярным процессом на то, чтобы выкидывать все dependencies, которые вам не нужны.
3991.60 4015.04 "Игорь Лабутин" Мы про это говорили уже несколько раз в подкасте, про всякие supply chain attack и вот это вот всё, и видимо эта штука настолько сейчас стала популярной и рискованной, в смысле несёт в себе довольно много рисков, что вот это прям этот процесс как dependency pruning заслужил место в разделе Adopt, то есть регулярно проходите по списку ваших зависимостей и выкидывайте нафиг всё, что вам там не нужно.
4015.04 4027.24 "Анатолий Кулаков" Странно, почему не всегда добавили там допустим dependency updating, то есть это не меньше, а мне кажется даже больше, более важно, чем просто их удалять, потому что наверняка ты много удалить ты не сможешь, а апдейтить ты должен постоянно.
4027.24 4039.36 "Игорь Лабутин" Ну, возможно, зависит от, так скажем, платформы, может быть на самом деле в Дотнете у нас нет такой проблемы с удалить много и не сможешь, может быть во фронте, например, есть, когда ты там притаскиваешь миллион фреймворков, а
4039.36 4042.76 "Анатолий Кулаков" потом забываешь удалить. Лучше удалить и новый поставить, чем апдейтить.
4042.76 4050.60 "Игорь Лабутин" Да, ну то есть я не знаю, откуда это действительно как бы глядя с колокольни Дотнета, вроде как и не очень важно, но тем не менее.
4050.60 4060.84 "Игорь Лабутин" Вторая штука в Adopt это run cost as architecture fitness function, то есть когда вы планируете архитектуру, подумайте над тем, сколько будет стоить запускать это всё.
4060.84 4075.92 "Анатолий Кулаков" Да, потому что сейчас всё запускается на клаудах, на всяких облаках, и там довольно-таки важно о том, как ваше приложение будет запускаться, потребляет ли оно процессоры, потребляет ли оно диски, требует ли много памяти, сколько вообще инстансов нужно.
4075.92 4081.20 "Анатолий Кулаков" И в зависимости от того, как вы продумаете архитектуру, у вас выстраивается цена этой фичи.
4081.20 4088.04 "Анатолий Кулаков" И в зависимости от цены бизнес вполне может решить, что она вам или не нужна, или нужна в не в том объеме, или давайте подумаем ещё как-нибудь.
4088.04 4098.00 "Игорь Лабутин" Ну, в общем, это довольно популярная рекомендация, если вы начинающий стартап и так далее, кидаете всё, просто не надо там градить свою собственную инфраструктуру в большом объёме и юзайте клауд, это нормально.
4098.00 4105.96 "Игорь Лабутин" Там всё будет, там будет, это стоит денег, но это вам сэкономит кучу времени, но вот с самого раннего начала вы не торчите, сколько это вам стоит.
4105.96 4112.44 "Игорь Лабутин" А то может быть неприятный сюрприз потом, если вы поймёте, что ваша архитектура не позволяет сделать что-то дёшево.
4112.44 4113.44 "Игорь Лабутин" Дальше раздел "трайл".
4113.44 4152.20 "Игорь Лабутин" В трайл меня привлекла только одна штука, называется "Demo from Tens for API-only products", то есть если вы пишете продукт, который чистая пишка, не могу так сходу представить, но наверное есть такие продукты, почему нет, то техника, которая рекомендуется попробовать, говорит про то, что даже если вы пишете по TZ, у вас как бы сказано сделать API-only продукт, напишите к нему фронтенд простой, наколеночный, потому что типа пост он показывает заказчикам или какого-нибудь свакер, да, Open API, это типа не круто, а вот как бы даже простой наколеночный фронтенд типа даст вам гораздо больше очков, чем вы потратите время на его написание, даже если у вас команда чистых бэкендеров.
4152.20 4157.16 "Игорь Лабутин" Сейчас есть технологии, которые позволяют это, ну довольно просто сделать простой фронтенд поверх
4157.16 4161.28 "Анатолий Кулаков" Рестапи. Мне кажется, может все-таки обойтись обычным свагером.
4161.28 4166.04 "Анатолий Кулаков" Ну… То есть мини-фронтенд такой, забросик сделать сможешь.
4166.04 4167.04 "Анатолий Кулаков" Да, наверное.
4167.04 4168.04 "Игорь Лабутин" Да, смотреть сможешь.
4168.04 4180.08 "Игорь Лабутин" Опять же, видишь, тут видимо их рекомендация как ребят, которые довольно много всего продают, каким-нибудь там стартапом, в смысле продают стартапы, например, помогают им какие-нибудь там раунды инвестиций поднять перед инвесторами или еще чего-нибудь.
4180.08 4184.48 "Анатолий Кулаков" Там можно действительно… Кажется, тебе нужно продемонстрировать работу кому-то стороннему, да, наверное.
4184.48 4185.48 "Игорь Лабутин" Красивая картинка будет прикольнее.
4185.48 4187.48 "Игорь Лабутин" Хотя… Ну конечно.
4187.48 4191.48 "Игорь Лабутин" Хотя при этом, я же говорю, сделайте силами бэкендеров, ну там будет, да, очень красивая картинка.
4191.48 4192.48 "Анатолий Кулаков" Может наоборот.
4192.48 4193.48 "Игорь Лабутин" Да, ну ладно.
4193.48 4200.48 "Игорь Лабутин" В разделе ассес есть три интересных момента, которые меня привлекли.
4200.48 4217.72 "Игорь Лабутин" Во-первых, тул, который я себе записал посмотреть, тулоклогсекью, это, короче, какой-то team knowledge management штука, похожая на obsidian в каком-то смысле, если вы слышали такое слово.
4217.72 4228.56 "Анатолий Кулаков" Это тул… Я посмотрел, это, в принципе, такой движок, где вы можете там заводить вики, там же можете таски себе делать, задания ставить, какими-то идеями делиться, в общем, движок по управлению знаниями.
4228.56 4234.56 "Анатолий Кулаков" И плюс эти знания не только вы сами можете управлять, но и шарить их между командами, упоминать, меншинить, и так далее.
4234.56 4237.84 "Анатолий Кулаков" Что-то сведение между конфлюенсом сюда же приплести.
4237.84 4243.00 "Анатолий Кулаков" Ну, в общем, это действительно такая популярная тема, obsidian это тоже из этой сферы.
4243.00 4245.60 "Анатолий Кулаков" Но obsidian больше персональный, мне кажется.
4245.60 4249.76 "Анатолий Кулаков" Да, скорее всего это персонально, а вот это уже больше с командой.
4249.76 4255.96 "Анатолий Кулаков" Мне все равно кажется, что чего-то здесь не хватает, в общем, все еще нет хорошего инструмента, который позволит занять эту нишу.
4255.96 4257.96 "Анатолий Кулаков" А ниша хорошая, нишу прям я жду.
4257.96 4267.92 "Игорь Лабутин" Ну вот эту штуку видно, что… Я не знаю, я сейчас читаю только сам радар, я не смотрел на сам клуб, видно, что, видимо, делали программисты, потому что у него написано, что это git-based storage, то есть, короче, все для программистов.
4267.92 4272.00 "Игорь Лабутин" Никак там в конфлюенсе невероятно, что там в бекенде просто пользуешься фронтом.
4272.00 4275.48 "Игорь Лабутин" А здесь прям, и все это в gitе, короче, ну не знаю.
4275.48 4280.56 "Анатолий Кулаков" Да, там простые markdown файлы, то есть ты их можешь посмотреть, зачекинить, а я, соответственно, история, бранч, и все как
4280.56 4283.56 "Игорь Лабутин" положено. Ну, в общем, программистам будет удобно, всем остальным не факт.
4283.56 4286.56 "Игорь Лабутин" Тут как обычно, ладно.
4286.56 4292.92 "Игорь Лабутин" И интересный раздел, интересный кусочек называется tracking health over debt.
4292.92 4306.56 "Игорь Лабутин" Мы очень много говорим, ну вообще, в проектах, продуктах про технический долг, technical debt, а здесь ссылки на пару статей на тему того, что надо говорить не про technical debt, а про, так сказать, product health.
4306.56 4320.52 "Игорь Лабутин" И тогда у вас, естественным образом, будет… То есть не просто смотреть на ваш долг и думать, что вы из этого долга нам пофиксите, а это способ подумать, а что же вам нужно пофиксить, чтобы, так сказать, здоровье вашего приложения, да, product health, он улучшился.
4320.52 4327.52 "Игорь Лабутин" Долг-то долг, но долг он плохой только если это как-то сильно влияет на ваше приложение, а не потому что вам, как программистам, кажется, что надо что-то срочно фиксить.
4327.52 4332.40 "Игорь Лабутин" Так что тут вот интересно просто чисто поменять взгляд.
4332.40 4340.32 "Игорь Лабутин" И вот в техниках есть одна штука, которая, даже две на самом деле, которую хочется упомянуть в разделе hold.
4340.32 4357.76 "Игорь Лабутин" Первая эта штука это lambda pinball, и это… Смотрите, когда мы делаем монолит, то мы грозимся, ну классический сейчас пример, когда обсуждают все архитектуры, мы превращаем монолит в big ball of mud, да, когда там все связано со всем, и это, короче, непонятно что.
4357.76 4376.48 "Игорь Лабутин" Когда мы говорим микросервисов, часто приводят в качестве такого убер-штуки, во что это может превратиться, как раз микросервисы убера, когда там сколько у них там, несколько тысяч же, да, по-моему, если не десятков тысяч микросервисов, которые играют там такой типа, это нифига непонятно зависимости, все там, все со всеми, вот это все тоже плохо.
4376.48 4402.24 "Игорь Лабутин" И когда все сейчас идет к тому, что лямбда архитектуры становится довольно популярным, это когда ваши микросервисы уменьшены настолько, что они являются лямбдами, то все это может превратиться в то, что ребята назвали лямбда pinball architecture, то есть когда ваш лямбд, ну в смысле, какой-то кусочек логики пинается между вашими лямбдами, ну примерно как мячик в пинболле, между этими препятствиями туда-сюда.
4402.24 4407.36 "Игорь Лабутин" Может быть он свалится куда вам нужно вниз, а может и не свалится, в смысле, может ваш форклоуд дойдет до конца, а может не дойдет.
4407.36 4418.64 "Игорь Лабутин" Поэтому смотрите внимательно на лямбды, лямбды это конечно хорошо, серверлесс это прекрасно, но смотрите внимательно на то, как у вас работает код и так далее.
4418.64 4426.36 "Игорь Лабутин" И связанная с этим штука следующая, это про planning for full utilization, и это надо прекратить.
4426.36 4441.44 "Игорь Лабутин" То есть когда мы планируем спринты, то есть full utilization можно подумать, что это про ресурсы, так сказать, компов, нет, это про команды.
4441.44 4443.52 "Игорь Лабутин" Типа не надо планировать на полный спринт.
4443.52 4450.08 "Игорь Лабутин" Я думал, что это, в общем, очевидная штука, но она прям почему-то заслужила отдельного холда в аше-техродаве.
4450.08 4454.76 "Игорь Лабутин" Непонятно, почему видимо кто-то до сих пор планирует полные спринты, работы.
4454.76 4463.04 "Анатолий Кулаков" Ну, мне кажется, любые программисты, они тебе всегда говорят оптимистичные сроки, за сколько они выполнят это в идеальных часах, и на полный спринт, конечно.
4463.04 4464.60 "Анатолий Кулаков" И еще время останется.
4464.60 4468.20 "Анатолий Кулаков" Ну, я же под натуру, сделаю быстрее, еще время останется.
4468.20 4469.20 "Игорь Лабутин" Ладно, да.
4469.20 4470.20 "Игорь Лабутин" Еще тех долг успею сюда засунуть.
4470.20 4477.08 "Игорь Лабутин" Планируете 25-50% написано в статье, но в техрадаре, и не больше, все равно вылезете за пределы.
4477.08 4478.08 "Игорь Лабутин" Ладно, пойдем дальше.
4478.08 4486.64 "Игорь Лабутин" Следующий раздел это платформы, он такой, в основном это скорее, ну, как бы я не знаю, платформы, не платформы, платформы, фреймворки, много чего такого.
4486.64 4492.20 "Игорь Лабутин" И здесь интересно, что в адопт пролезли гитхаб экшнс.
4492.20 4495.08 "Игорь Лабутин" Как это они часто используют, да, гитхаб для своих проектов?
4495.08 4496.08 "Игорь Лабутин" Ну, видимо, да.
4496.08 4502.12 "Игорь Лабутин" Мне казалось, что они уже давно должны были быть в адопте, но как-то вот, что-то не было, видимо.
4502.12 4511.20 "Игорь Лабутин" А в адопте появился, по-моему, не было к3с, это такой, кубернет, легковесный кубернет.
4511.20 4518.96 "Игорь Лабутин" То есть легковесный полностью, так сказать, совместимый по API с обычным кубернетом, но который требует не так много ресурсов.
4518.96 4523.00 "Игорь Лабутин" То есть он там не использует всякие etcd и так далее.
4523.00 4530.52 "Игорь Лабутин" И плюс он поддерживает, сейчас теперь стал поддерживать WASM, если вам нужно, то есть можно теперь прямо там запускать VBSM лифтклоуды.
4530.52 4533.72 "Игорь Лабутин" Короче, штука интересная, если вам не хочется тащить полновесный кубернет.
4533.72 4534.72 "Игорь Лабутин" Можно посмотреть.
4534.72 4541.28 "Игорь Лабутин" В триалки залезла интересная штука под названием ARMA в облаках.
4541.28 4546.60 "Игорь Лабутин" То есть мы традиционно все исполняем на x64, да, ну обычно в большинстве своем.
4546.60 4550.56 "Игорь Лабутин" Но вот в триалки залезла попробуйте ваш код на ARMA.
4550.56 4563.12 "Игорь Лабутин" Они более энергоэффективные, они, как правило, медленнее, но с точки зрения баланса стоимости и ресурсов они выгоднее, получается, в некоторых случаях.
4563.12 4570.92 "Игорь Лабутин" Поэтому можно посмотреть, попробовать, пособирать ваши, например, клоды в ARMA и запускать это в виде ARMA.
4570.92 4576.24 "Игорь Лабутин" Они сейчас поддержаны везде, во всех трех лидирующих облаках, да, VS Azure и Google.
4576.24 4580.00 "Анатолий Кулаков" Странно, что триал, мне казалось, это уже такая тоже давно тренд.
4580.00 4587.76 "Игорь Лабутин" Ну, видимо, пока еще все-таки триал, видимо, не все поддержано, не везде все хорошо, не знаю.
4587.76 4588.76 "Игорь Лабутин" Пока триал.
4588.76 4590.08 "Игорь Лабутин" Видимо, тоже только начали пробовать.
4590.08 4600.04 "Игорь Лабутин" В Assess залезло несколько интересных штук, тут прям много, ну очень много всяких разных, в основном вокруг email и так далее.
4600.04 4611.92 "Игорь Лабутин" Но вот Dapr, мне кажется, про Dapr мы слушали доклады еще на оффлайновых доковидных .next, это же там 18-19 год какой-нибудь
4611.92 4616.56 "Анатолий Кулаков" был. Да, да, было дело, и тогда прям он очень популярный был, там на хайпе только появился.
4616.56 4619.32 "Игорь Лабутин" И вот он до сих пор, он только сейчас в Assess.
4619.32 4623.40 "Анатолий Кулаков" То есть, типа… Тут надо понять, он все еще или уже?
4623.40 4625.68 "Анатолий Кулаков" Может, его, наоборот, назад начали двигать?
4625.68 4626.68 "Анатолий Кулаков" Ну, непонятно, непонятно.
4626.68 4629.96 "Анатолий Кулаков" Потому что в последнее время я про Dapr меньше слышу.
4629.96 4630.96 "Игорь Лабутин" Ну, может быть.
4630.96 4632.96 "Игорь Лабутин" Можно, кстати, посмотреть, это несложно сейчас.
4632.96 4633.96 "Игорь Лабутин" Давай я быстро гляну.
4633.96 4638.48 "Игорь Лабутин" Мне, например, кажется, что я, наоборот, побольше стал слышать о платформах.
4638.48 4641.76 "Игорь Лабутин" Да, про Dapr у нас был 36-ой, сейчас мы посмотрим.
4641.76 4643.88 "Игорь Лабутин" Не, он просто остался.
4643.88 4647.40 "Игорь Лабутин" А, не, он new, он появился сразу в Assess.
4647.40 4650.48 "Анатолий Кулаков" Ну, хорошо, может, дозрел до какого-нибудь состояния.
4650.48 4657.88 "Игорь Лабутин" Ну, типа, где-то, либо они просто попользовались им на нескольких проектах, и вот получилось теперь типа, о, клевая туда, давай допишем вас в этот самый.
4657.88 4669.16 "Игорь Лабутин" Мэтр, штука, ну, это стандарт, и это скорее не про программирование, как мне кажется, но это больше будет полезно тем, кто любит всякие умные дома и так далее.
4669.16 4672.32 "Игорь Лабутин" Вы знаете, что есть там куча разных стандартов, ZigBee и прочее.
4672.32 4675.48 "Игорь Лабутин" Так вот теперь это… Как там?
4675.48 4676.48 "Игорь Лабутин" Это новый стандарт.
4676.48 4681.64 "Игорь Лабутин" Да, я как раз хотел сказать, ситуация изменяема, у нас есть 14 стандартов, ну, сделаем еще один новый.
4681.64 4691.84 "Игорь Лабутин" Ну, тут, короче, объединились ZigBee, Comcast, Google, Apple и Amazon, чтобы сделать новый стандарт, Open for Smart Home Technology.
4691.84 4693.92 "Игорь Лабутин" Посмотрим, насколько получится.
4693.92 4695.48 "Игорь Лабутин" Не знаю.
4695.48 4698.84 "Игорь Лабутин" Так, что у нас еще?
4698.84 4700.20 "Игорь Лабутин" Неон, неон, неон.
4700.20 4715.52 "Игорь Лабутин" А, да, если вы пользуетесь iOS'ом Aurora, это iOS Aurora Progress SQL, там Cloud Native, Analytical, Database, в общем, короче, всякое такое, ну, короче, в iOS'е вот теперь есть неон, это open-source-ная альтернатива.
4715.52 4722.04 "Игорь Лабутин" Если вам зачем-то не хочется жить в iOS'е, то можно, соответственно, попробовать это у себя поставить и посмотреть.
4722.04 4725.88 "Игорь Лабутин" Зачем-то, может быть, вам это пригодится.
4725.88 4726.88 "Игорь Лабутин" Pathcase.
4726.88 4736.24 "Игорь Лабутин" Вот Pathcase, это, кстати, тоже становится популярной штука, то есть движение на тему отказа от паролей.
4736.24 4742.44 "Игорь Лабутин" То есть, и эту штуку поддерживает Apple, Google и Microsoft.
4742.44 4756.04 "Игорь Лабутин" Смысл в том, что все это основывается на асимметричной криптографии, то есть вместо логина и пароля у вас есть, ну, в каком-то смысле, как SSH-ключи, да, работают, у вас есть private ключик, вы, соответственно, сайту отдаете public ключик, и он там может проверить, что это действительно вы.
4756.04 4770.00 "Игорь Лабутин" Вот это все, ну, вокруг этого в SSH понятно, что есть инфраструктура, но для обычных сайтов там, как бы, надо еще пока придумать всю эту инфраструктуру, как это все аккуратно хранить, передавать и так далее.
4770.00 4779.44 "Игорь Лабутин" Вот, наверняка кто-то захочет это все хранить на железных ключиках, как-то это нужно дружить с телефонами, QR-коды, Bluetooth, вот это все.
4779.44 4786.88 "Игорь Лабутин" Но, возможно, это наше будущее, когда мы забьем на пароль и будем все только private, public ключами оперировать.
4786.88 4797.68 "Игорь Лабутин" Вот, и последняя штука под названием SPIN, open source платформа для того, чтобы запускать микросервисы на Wasm.
4797.68 4811.16 "Игорь Лабутин" В принципе, WebAssembly вообще сейчас, ну, на таком относительном хайпе, его пытаются применять в разных видах, формах и так далее, в форме контейнеров, там, микросервисов, вот этого всего.
4811.16 4822.76 "Игорь Лабутин" Мы, по-моему, уже обсуждали где-то, я не помню, в подкасте или где-то просто отдельно мы обсуждали тему, что можно теперь собирать там имиджи в формате WebAssembly, и, по-моему, Docker уже начал их поддерживать или как-то так.
4822.76 4829.48 "Игорь Лабутин" Вот, ну, в общем, еще одна платформа по возможности запуска, можно посмотреть, может быть, зачем-то вам пригодится.
4829.48 4835.56 "Игорь Лабутин" И последний раздел тузы, а нет, не последний, привет последний, с тузами.
4835.56 4851.28 "Игорь Лабутин" В тузах все довольно скучно, там довольно много всяких разных тузов вокруг и DevOps, и вот прочих таких там реестров, контейнеров и так далее, довольно много тузов вокруг ML, понятное дело, без них никак.
4851.28 4867.64 "Игорь Лабутин" Я бы хотел упомянуть тул под названием Fossa, это тул для проверок лицензии, то есть если вы тащите к себе что-то open-source, возможно, вы работаете в такой компании, где нужно что-то точно проверять.
4867.64 4875.72 "Игорь Лабутин" Какие там лицензии и так далее, для этого есть разные тузы, ну вот одна из них попала в техрадар, посмотрите, может, зачем-то вам пригодится.
4875.72 4887.52 "Игорь Лабутин" GitLicks, штука, которая тоже open-source, и Static Analysis, которая позволяет по любым репозиториям искать API-ключики, которые вы там потеряли.
4887.52 4895.72 "Игорь Лабутин" Ну, GitHub, в принципе, это и так умеет, но если вы это хотите на ваших private репозиториях, то может быть, тоже пригодится запускаться.
4895.72 4901.84 "Игорь Лабутин" Helmfile, open-source тул для того, чтобы работать с Helm-чартами.
4901.84 4909.40 "Игорь Лабутин" Никогда особо с ними не работал, только правила готовые, поэтому ничего не могу сказать, насколько это полезно в жизни, но в принципе может быть.
4909.40 4918.88 "Игорь Лабутин" Это все было в разделе Trial, в разделе Assess, тоже внезапно, то есть Assess это так, типа, посмотреть, потрогать, может быть, но еще пока не в разделе Trial.
4918.88 4927.52 "Игорь Лабутин" Находится, соответственно, Chat.jpg, находится GitHub Copilot, находится Obsidian, тот же самый, который мы уже сегодня упоминали.
4927.52 4951.04 "Игорь Лабутин" То есть, в общем, какой-то немножко странноватый набор, мне кажется, Copilot уже можно вполне спокойно использовать, хотя, видимо, они упоминают здесь, он находится в Assess, потому что там пока есть непонятки с точки зрения лицензирования, а точнее, ну, такой security типа, вы же для того, чтобы, ну, по сути, вы Copilot-у скармливаете кусочки, возможно, вашего кода, да, со словами "допиши мне, пожалуйста".
4951.04 4963.28 "Игорь Лабутин" И вот тут вопрос, можете ли вы скармливать кусочки вашего кода, это же все-таки ваш код, куда он там попадает, на серверы Microsoft, ну, в общем, такие вопросы непонятные.
4963.28 4978.08 "Анатолий Кулаков" Ну, кажется, что с Enterprise Copilot, который Copilot-X новый, GitHub декларировал, что он закрыл этот вопрос, то есть, этот обучался чисто на исходниках, которые разрешают подобные действия, и с ними не должно быть никаких корпоративных лицензионных проблем.
4978.08 5002.36 "Игорь Лабутин" Да, они это упоминают, что Copilot-X вроде, ну, когда они это писали, Copilot-X он в превью, ну, по-моему, сейчас до сих пор в превью, мне кажется, там, по-моему, еще не полностью финальный, видим, когда зафиналится, и там будет уже как раз нормальный, у них тут написано, что офферинг, который for business для Enterprises, и, видимо, там все будет чуть более четенько и понятно.
5002.36 5037.08 "Игорь Лабутин" Давай последний раздел, чтобы долго не задерживаться, это Languages and Frameworks, обычно он такой самый интересный для меня, но тут тоже прям какие-то очень странные JS, GPT и прочие, относящиеся к этому штоги, я могу сказать, мне удивило в каком-то смысле, если вы там как-то знаете Java мир, что они прям так занесли в Gradle Kotlin DSL в Adopt, сейчас мне даже интересно, он прям сразу, а нет, он переехал из Trial, окей, мне сейчас казалось, что его не было, то есть, если вы пишете на Java, теперь православно собирать не Maven, а Gradle Kotlin.
5037.08 5045.36 "Анатолий Кулаков" То есть трудно можно найти людей, которые пишут на Kotlin, еще меньше на Gradle, а чтобы вместе было еще и Gradle Kotlin DSL, это вообще ужасно.
5045.36 5049.16 "Игорь Лабутин" Ну, в общем, да, ну что, выучить, не грови же учить.
5049.16 5068.48 "Игорь Лабутин" Так, штука, которую я очень хочу, чтобы все прям за Adoptили, но которые почему-то не Adopt, это касается мобильных приложений, хочется, чтобы в каждом приложении можно выбрать нормальный язык было, потому что многие приложения на мобильниках, они дефолтятся на тот язык, который у тебя выбран в телефоне.
5068.48 5080.12 "Игорь Лабутин" А у меня всегда английский выбран, например, а некоторые приложения я принципиально хочу на русском, а нельзя, они дефолтятся на английский, никак не сделать иначе, меня это бесит, хочу, чтобы все так делали.
5080.12 5085.40 "Анатолий Кулаков" Потому что у них просто нету ленгвиджа для того, чего ты хочешь, для русского.
5085.40 5093.16 "Игорь Лабутин" Нет, если я меняю интерфейс телефона на русский, оно становится на русском, я знаю, что у них есть русский, но нет переключалки в настройках.
5093.16 5095.16 "Анатолий Кулаков" Ну тогда действительно это странное решение.
5095.16 5101.48 "Игорь Лабутин" И вот эта штука она в трайле почему-то, может быть это кому-то не понравится, я короче не понимаю, почему это в трайле.
5101.48 5113.12 "Игорь Лабутин" В общем, странно, не знаю, может быть там есть какие-то тонкости внутри именно фреймворка, но у самого андроида плохо, что так нельзя, например, делать,
5113.12 5117.00 "Анатолий Кулаков" я не знаю. Может не положено сразу в Adopt пускать, надо пройти все ступени ада.
5117.00 5125.28 "Игорь Лабутин" И в Assess есть две интересных технологии, которые мы наверное закончим обзор техрадара.
5125.28 5126.68 "Игорь Лабутин" Это .NET 7.
5126.68 5132.28 "Игорь Лабутин" И это прям интересно, это действительно штука, которую нужно поассессировать.
5132.28 5142.56 "Игорь Лабутин" Там все довольно пока, ну не сказать сыро, мы много раз про это говорили, там разные есть трудности с тем, чтобы запускать ваш .NET код в Аоти, Reflection, там вот это все.
5142.56 5167.20 "Игорь Лабутин" Single File Publishing и прочие штуки, которые обязаны быть, и которые возможно сделают так, что ваш код не очень заработает, но зато если вы сможете ваш код сделать на эти Аоти, то он будет там, у вас не будет проблемы с прогревом всяких там лямбд, если вы пользуетесь серверлессом, если у вас в Коммант Лайне все запускается, то будет все очень быстро и так далее.
5167.20 5175.76 "Игорь Лабутин" И поэтому, в общем, если все взлетит и будет хорошо, я надеюсь, что эта штука переедет в адопт рано или поздно.
5175.76 5180.04 "Игорь Лабутин" А вот второе в ассесс это .NET Maui.
5180.04 5186.04 "Игорь Лабутин" Мне вот интересно, они действительно поюзали Maui на своих проектах или...
5186.04 5189.24 "Анатолий Кулаков" Ну слушай, просто так по-моему они не добавляют.
5189.24 5192.12 "Анатолий Кулаков" Это реально вещи, которые они поиспользовали и им понравилось.
5192.12 5193.12 "Игорь Лабутин" Ну вот да, непонятно.
5193.12 5218.40 "Игорь Лабутин" Хотя вот у них последнее предложение звучит с различным образом, что если у вас используется Xamarin уже, ну наверное вы можете попробовать Maui как потенциальную замену, но если вы не пишете на C# и Xamarin сейчас, то короче, давайте подождем, пока технология будет более широко распространена и докажет свое место на рынке.
5218.40 5221.32 "Игорь Лабутин" То есть короче, он такой ассесс, но очень такой с надеждой.
5221.32 5226.36 "Анатолий Кулаков" Да, если вы и так на Xamarin сидите и терять вам больше все равно нечего, то почему бы не попробовать?
5226.36 5227.36 "Игорь Лабутин" Да.
5227.36 5252.08 "Игорь Лабутин" В общем вот, на какой бы технологии вы ни писали, просто мы там не касались, я сознательно не касался всяких фронтендов, всяких того, что связано с JavaScript и TypeScript, а там довольно много всего про эту тему, поэтому если вы этого как-то касаетесь, посмотрите, почитайте, он довольно хорошо читается, там буквально по одному-два абзаца на каждый тут, это не какой-то там огромный 500-страничный PDF, буквально за пару часов вы его целиком прочтете внимательно, вдумчиво.
5252.08 5258.76 "Анатолий Кулаков" Ну и при этом он весь интересный, то есть там буквально действительно один абзац вы прочитали, и новый инструмент какой-то уже узнали о его существовании.
5258.76 5279.20 "Анатолий Кулаков" У меня обычно после радара там десятки открытых новых страниц, после него я хожу, изучаю новые инструменты, как они работают, что предлагают, как выглядят, всё это безумно интересно, документ полон ссылочек, пруфов каких-то интересных историй, как этот инструмент был добавлен, как он прогрессировал, в общем, прекрасное чтиво, занимательное.
5279.20 5280.20 "Анатолий Кулаков" Да.
5280.20 5281.20 "Игорь Лабутин" Я не рекомендую.
5281.20 5286.36 "Игорь Лабутин" Ну что, давай пойдём дальше, у нас есть одна большая статейка, но мне кажется, мы должны успеть её рассмотреть.
5286.36 5291.08 "Анатолий Кулаков" Подожди, ещё у меня такое предложение есть, в принципе, довольно обидно, что Дотнета всё-таки мало.
5291.08 5304.60 "Анатолий Кулаков" Ну, надо понимать, что компания с Дотнетом работает мало, так чуть-чуть совсем, в основном её направление это там Руби, Джава и фронтенды всякие безобразные, и очевидно, что Фроу Фокс – это не про Дотнет.
5304.60 5313.24 "Анатолий Кулаков" Вот, но я знаю, что как раз технологические радары, они есть во многих компаниях, вот особенно в таких больших, таких солидных, красивых и всё такое.
5313.24 5327.68 "Анатолий Кулаков" В общем, если у вас в компании есть радар Дотнетовский, именно Дотнетовский радар интересует, ну или вокруг Дотнета что-то там, то присылайте нам, расшарьте, если это возможно официально, если невозможно официально, можно анонимно прислать.
5327.68 5334.76 "Анатолий Кулаков" И покажите, интересно просто, что действительно в Дотнет-мире используется на самом деле в настоящих компаниях.
5334.76 5340.32 "Анатолий Кулаков" Мне кажется, это была бы хорошая статистика, мы её как-нибудь соберём и про неё тоже расскажем.
5340.32 5349.76 "Анатолий Кулаков" Если такого радара мы не найдём, то, не знаю, можно попробовать самим собрать, самим сделать, и вот с помощью там слушателей или с помощью там митапов поддержать его актуальность.
5349.76 5365.76 "Анатолий Кулаков" Потому что вот действительно хочется прям сесть, посмотреть технологии и понять, на чём сейчас делать новый проект, что можно там попробовать поэкспериментировать, что взять стабильное и бросить как бы там джуналам какими-нибудь, которые приходят и спрашивают то же самое перед каждым проектом.
5365.76 5367.64 "Анатолий Кулаков" Мне кажется, полезная была бы штука.
5367.64 5368.64 "Игорь Лабутин" Да, действительно.
5368.64 5378.28 "Игорь Лабутин" Нас вот, ну, мы не делаем, то есть мы едем по накатным рельсам, узнаём всё новое из конференций, подкастов и прочего, и иногда затаскиваем в проекты.
5378.28 5385.00 "Игорь Лабутин" Мы как-то так систематически не подходим к этому, поэтому действительно, если есть что-то такое интересное, давайте посмотрим, подсуждаем.
5385.00 5389.16 "Анатолий Кулаков" Да, присылайте или публичные ссылки, или там приватные, можно письмами заслать.
5389.16 5396.96 "Анатолий Кулаков" Если вы знаете уже открытые проекты Дотнет-радаров, я почему-то так быстро не нашёл, то тоже присылайте.
5396.96 5400.04 "Анатолий Кулаков" Давай к следующей, успеем ещё хорошенькую C#-ную тему
5400.04 5402.04 "Игорь Лабутин" тронуть. Да, я думаю, да.
5402.04 5405.04 "Игорь Лабутин" Мы что там, полтора часа сидим, как раз до двух часов добьём.
5405.04 5410.12 "Анатолий Кулаков" Хорошо, можно постараться побыстрее, потому что не тронуть её просто невозможно.
5410.12 5414.80 "Анатолий Кулаков" Это ещё одна прекрасная статья от нашего любимого Владимира Хорикова.
5414.80 5420.84 "Анатолий Кулаков" Хориков никогда не подводит, у него все статьи глубокие, интересные и основательные.
5420.84 5428.16 "Анатолий Кулаков" Поэтому давайте ещё раз разберёмся с одной из последних работ великого автора, называется она, Storing Information in its Highest Form.
5428.16 5432.60 "Анатолий Кулаков" Я не знаю, Highest Form нормально, как это, наивысшая форма?
5432.60 5437.04 "Анатолий Кулаков" Или там, знаешь, как с формами, с функциями высшего порядка,
5437.04 5439.04 "Игорь Лабутин" там какой-то специальный термин есть. Типа того, да.
5439.04 5448.64 "Игорь Лабутин" Я как-то вот, ну, я на русском языке наивысшая форма не встречал, то есть я бы сказал её наиболее, не знаю, неестественной.
5448.64 5449.64 "Игорь Лабутин" Тут сложно, да-да-да.
5449.64 5450.64 "Игорь Лабутин" Да, не знаю, как перевести.
5450.64 5460.60 "Анатолий Кулаков" У тебя, насколько я понимаю, это даже и в английском языке не то чтобы устоявшийся термин, потому что там в комментариях разворачивается ещё спор насчёт терминологии, и там видно, что автор его практически придумал.
5460.60 5461.60 "Анатолий Кулаков" Ну, хорошо.
5461.60 5464.80 "Анатолий Кулаков" Ну, давай адаптируем как высшая форма, да?
5464.80 5467.16 "Анатолий Кулаков" Высшая форма, ладно, окей, давай.
5467.16 5470.12 "Анатолий Кулаков" Ну попробуем, сейчас как по тексту пойдёт, если что, мне поправлять.
5470.12 5477.44 "Анатолий Кулаков" Итак, давайте же посмотрим, что же такое информация высшей формы и каким же образом её сохранять, и самое главное, зачем вообще нам это нужно.
5477.44 5480.64 "Анатолий Кулаков" И начнём с тривиального примера.
5480.64 5486.84 "Анатолий Кулаков" Допустим, мы строим какой-то онлайн кинотеатр, и нам необходимо сохранить время, продолжительность какого-то фильма.
5486.84 5499.44 "Анатолий Кулаков" И заказчик к нам пришёл и говорит, хочу, чтобы на фронте это отображалось как 1 час, то есть 1 че 47 ме, типа продолжительность фильма 1 час 47 минут.
5499.44 5516.36 "Анатолий Кулаков" И, внимание, вопрос самым большим интеллектуалам, каким образом это всё хранить в базе данных, и какого типа вообще должна быть вот эта штука, потому что очевидно, что самым примитивным, самым простым способом, если мы берём, то мы храним это в виде строки.
5516.36 5519.76 "Анатолий Кулаков" Строка, которая называется 1 че пробел 47 ме.
5519.76 5522.56 "Анатолий Кулаков" Стоит ли нам хранить это в виде строки?
5522.56 5539.20 "Анатолий Кулаков" Наверное, не очень, потому что в следующий раз заказчик может прийти и сказать, я передумал, я там локализовал наши анонсы на другие языки, допустим, и теперь нам нужно это хранить в формате 1:47, или может быть просто в минутах, 107 минут.
5539.20 5540.96 "Анатолий Кулаков" Давай мне теперь покажи это так.
5540.96 5559.16 "Анатолий Кулаков" И в этом случае нам придётся распаршивать всю нашу базу данных, распаршивать всю эту строку, конвертировать в этот формат, а в принципе в какой этот непонятно, потому что если мы уже видим, что заказчик их часто меняет, то может быть в разных местах нужно показывать разные форматы, в одной стране один, в другой другой.
5559.16 5564.84 "Анатолий Кулаков" И поэтому хранить это всё в виде вот такой вот строки, которую мы видим на UI, это довольно странно.
5564.84 5567.24 "Анатолий Кулаков" В общем, так делать не надо.
5567.24 5575.12 "Анатолий Кулаков" Правильно это сохранить в той форме, из которой мы можем легко конвертировать в любую форму, которая нам понадобится в будущем.
5575.12 5579.42 "Анатолий Кулаков" Не важно, вопрос без заказчика или по каким-то локализованным нуждам.
5579.42 5587.76 "Анатолий Кулаков" И в нашем примере это может быть, например, сконвертировать в количество минут и хранить как Integer количество минут.
5587.76 5594.04 "Анатолий Кулаков" И с помощью вот этого количества минут мы их можем показать потом на UI в любой форме.
5594.04 5602.08 "Анатолий Кулаков" Хоть 1.47, хоть 1.47, хоть 107 минут, как вам только взбрендит, как угодно можем показать.
5602.08 5607.80 "Анатолий Кулаков" И вот именно вот это Владимир называет наивысшей формой представления информации.
5607.80 5615.08 "Анатолий Кулаков" В данном случае информации о продолжительности какого-то сериала или продолжительности какого-то фильма.
5615.08 5625.80 "Анатолий Кулаков" То есть наивысшая форма это та форма, сохранив которую вы можете ее преобразовать в то, что вам в будущем возможно понадобится.
5625.80 5637.32 "Анатолий Кулаков" То есть это самая гибкая форма, которая в будущем вам может быть представлена в абсолютно любых форматах, в абсолютно любых представлениях, которые только вам может понадобиться.
5637.32 5641.60 "Анатолий Кулаков" И она может быть представлена в разных форматах, естественно.
5641.60 5648.60 "Анатолий Кулаков" Ну тут бы я поправил, наверное, все-таки в .NET принята продолжительность хранить в виде TimeSpan, а не Integer.
5648.60 5651.32 "Анатолий Кулаков" То есть я бы все-таки, наверное, остановился на TimeSpan.
5651.32 5655.64 "Игорь Лабутин" Ну дальше возник вопрос, как ты это сложишь в базу данных.
5655.64 5659.48 "Игорь Лабутин" Не каждая база данных поддерживает прям TimeSpan и прям тип есть.
5659.48 5665.52 "Игорь Лабутин" Все равно ты все сконвертнишь в какой-нибудь там 2 миллисекунд или что-нибудь в таком духе.
5665.52 5669.68 "Анатолий Кулаков" Ну да, просто у нас Entity Framework это все прозрачно делает для всех популярных базы данных.
5669.68 5675.36 "Анатолий Кулаков" Но если мы говорим, что без Entity Framework, то может быть Integer это хороший вариант, согласен с тобой.
5675.36 5681.20 "Анатолий Кулаков" Естественно, это очевидное решение.
5681.20 5688.84 "Анатолий Кулаков" Каждый из наших слушателей, надеюсь, понимает, что продолжительность нужно хранить в чем-то таком виде Int или в виде TimeSpan, но ни в коем случае не в виде строки.
5688.84 5693.16 "Анатолий Кулаков" Это все слишком очевидно для того, чтобы для этого вообще можно было писать статью или обсуждать.
5693.16 5696.08 "Анатолий Кулаков" Но, естественно, как и всегда, это только базис.
5696.08 5699.12 "Анатолий Кулаков" Это только начало, чтобы вы понимали, что такое вообще наивысшая форма.
5699.12 5701.00 "Анатолий Кулаков" А теперь давайте подвинемся дальше.
5701.00 5706.68 "Анатолий Кулаков" Давайте пойдем к более интересным примерам и разовьем эту мысль немножко более глубоко.
5706.68 5710.04 "Анатолий Кулаков" Для этого вам нужно будет представить класс кастомера.
5710.04 5714.04 "Анатолий Кулаков" У нас есть некий пользователь, у которого есть система лояльности.
5714.04 5718.00 "Анатолий Кулаков" То есть он может зарабатывать некие баллы, а потом эти баллы тратить.
5718.00 5723.28 "Анатолий Кулаков" И вот есть у нас некий кастомер, у которого есть сейчас на данный момент два метода.
5723.28 5735.20 "Анатолий Кулаков" Когда кастомер заработал баллы, у него есть метод addLoyaltyPoints, который принимает в качестве аргумента баллы и прибавляет это к нашему приватному филду, который называется points.
5735.20 5736.96 "Анатолий Кулаков" Соответственно, баллы заработались.
5736.96 5743.68 "Анатолий Кулаков" И второй метод, когда мы списываем эти баллы в счет какой-то покупки, допустим, он может баллами оплатить какую-то покупку.
5743.68 5751.16 "Анатолий Кулаков" Этот метод называется redeemLoyaltyPoints и принимает количество баллов, которые мы хотим списать в счет покупки.
5751.16 5759.48 "Анатолий Кулаков" Но здесь есть одно важное бизнес-условие, что мы можем списать эти баллы только если у нас их больше 250.
5759.48 5762.76 "Анатолий Кулаков" Вот накопился такой большой, толстый, жирный, золотой пользователь.
5762.76 5765.16 "Анатолий Кулаков" И вот только тогда мы можем начинать их списывать.
5765.16 5767.08 "Анатолий Кулаков" Иначе бросается exception.
5767.08 5775.00 "Анатолий Кулаков" Если же их все-таки больше 250, то от points отнимается то количество баллов, которые передали.
5775.00 5777.48 "Анатолий Кулаков" Вот такие два метода у нашего кастомера есть.
5777.48 5782.24 "Анатолий Кулаков" Теперь мы это все разработали, это все работает замечательно, хорошо.
5782.24 5783.24 "Анатолий Кулаков" К нам поступает новое требование.
5783.24 5800.24 "Анатолий Кулаков" Если пользователь добавил в корзину какой-то товар, за которым ему начислили дополнительные бонусные баллы, а потом из этой корзины товар удалил, то естественно мы должны и начисленные баллы лояльности тоже удалить.
5800.24 5802.36 "Игорь Лабутин" Тут даже интереснее.
5802.36 5803.36 "Игорь Лабутин" Из корзины ты удалил.
5803.36 5805.36 "Игорь Лабутин" Ладно, мы же начисляем.
5805.36 5809.00 "Игорь Лабутин" Вряд ли от того факта, что ты положил в корзину, тут хуже пример.
5809.00 5814.76 "Игорь Лабутин" Когда ты вернул этот товар в магазин, тебе его доставили, ты на него посмотрел и вернул.
5814.76 5818.20 "Игорь Лабутин" Тут как бы из тебя нужно те самые баллы вычесть.
5818.20 5819.20 "Игорь Лабутин" Что тебе их давать-то?
5819.20 5820.20 "Игорь Лабутин" Ты же товар вернул.
5820.20 5823.36 "Игорь Лабутин" А то я накидаю себе баллов.
5823.36 5825.36 "Анатолий Кулаков" Соответственно баллов тебе больше не надо.
5825.36 5828.28 "Анатолий Кулаков" И перед разработчиком стоит вариант, а что делать?
5828.28 5829.52 "Анатолий Кулаков" Как реализовать это?
5829.52 5832.04 "Анатолий Кулаков" Просто вернул товар и баллы теперь нужно снова отнять.
5832.04 5833.52 "Анатолий Кулаков" Ну, можно в лоб.
5833.52 5835.52 "Анатолий Кулаков" То есть несколько вариантов в лоб.
5835.52 5837.32 "Анатолий Кулаков" Давайте рассмотрим самые лобовые варианты.
5837.32 5842.20 "Анатолий Кулаков" То есть самый простой вариант – это сделать вычитание.
5842.20 5853.12 "Анатолий Кулаков" То есть на самом деле просто вызвать метод redeem loyalty points, который у нас уже есть для того, чтобы списывать баллы.
5853.12 5860.08 "Анатолий Кулаков" То есть взять и списать с него эти баллы, которые якобы он не должен был получить.
5860.08 5867.92 "Анатолий Кулаков" Но здесь мы натыкаемся на то, что у нас есть бизнес-условие, при котором меньше 250 баллов бросит исключение.
5867.92 5875.44 "Анатолий Кулаков" Мы этого сделать не можем, потому что мы не можем в этот момент, когда мы возвращаем товар и снимаем баллы, которые он не заслужил бросать исключение.
5875.44 5877.08 "Анатолий Кулаков" Этот способ нам не подходит.
5877.08 5878.76 "Анатолий Кулаков" Дальше еще есть хак.
5878.76 5882.72 "Анатолий Кулаков" Так как мы программисты, мы в принципе знаем о отрицательных числах.
5882.72 5887.32 "Анатолий Кулаков" И мы можем воспользоваться методом, который называется add loyalty point.
5887.32 5895.12 "Анатолий Кулаков" То есть добавить ему баллов, но добавить ему не положительных баллов, как обычно делает метод добавления баллов, а отрицательных.
5895.12 5902.72 "Анатолий Кулаков" Поэтому добавляя отрицательные баллы в наше приватное свойство points, запишется уже баллы с минусом.
5902.72 5907.20 "Анатолий Кулаков" И мы в принципе скорректируем то, что мы хотим.
5907.20 5914.08 "Анатолий Кулаков" Таким образом тоже поступать не стоит, потому что на самом деле по бизнес-логике баллы не могут быть отрицательными.
5914.08 5922.48 "Анатолий Кулаков" И если мы вдруг случайно уйдем в минус, то это нарушит наш один из основных принципов вообще проектирования.
5922.48 5925.60 "Анатолий Кулаков" Это то, что доменная модель должна быть всегда валидной.
5925.60 5927.36 "Анатолий Кулаков" И доменная модель должна быть всегда валидной.
5927.36 5933.68 "Анатолий Кулаков" И сами баллы должны быть всегда валидными, потому что клиент не может занимать баллы у нашего магазина.
5933.68 5935.28 "Анатолий Кулаков" Поэтому баллы не могут быть отрицательными.
5935.28 5940.72 "Анатолий Кулаков" Это нарушает немножко всю доменную логику, всю валидность доменной логики.
5940.72 5942.08 "Анатолий Кулаков" Поэтому этим путем мы тоже не пойдем.
5942.08 5946.68 "Анатолий Кулаков" Ну и наверное уже самый отчаянный метод, который у нас существует.
5946.68 5949.08 "Анатолий Кулаков" Давайте в конце концов добавим новый метод.
5949.08 5959.28 "Анатолий Кулаков" Новый метод, который будет отнимать баллы от существующих поинтов, назовем его Substract Loyalty Points.
5959.28 5963.64 "Анатолий Кулаков" И там уже у нас не будет никаких проверок на вот это минимальные 250.
5963.64 5967.84 "Анатолий Кулаков" Там уже мы просто отнимем без всяких условий и все будет честно, все будет красиво.
5967.84 5973.24 "Анатолий Кулаков" К сожалению, с этим подходом тоже есть несколько проблем.
5973.24 5978.52 "Анатолий Кулаков" Во-первых, у нас появляются два метода, которые умеют отнимать баллы.
5978.52 5982.12 "Анатолий Кулаков" Один Redim, который проверяет на лимит 250.
5982.12 5985.80 "Анатолий Кулаков" А другой обычный Substract, который просто списывает без всяких условий.
5985.80 5995.32 "Анатолий Кулаков" И для использующего кода, для другого программиста, который будет юзать наш класс, нашу доменную модель, вообще ни разу не очевидно, а какой из этих методов вызвать.
5995.32 5997.20 "Анатолий Кулаков" Или даже наоборот.
5997.20 6000.60 "Анатолий Кулаков" Скорее всего очевидно, что он вызовет тот метод, с которым будет меньше проблем.
6000.60 6003.88 "Анатолий Кулаков" Тот, который не бросает эксепшены про всякие дурацкие лимитные условия.
6003.88 6007.24 "Анатолий Кулаков" То есть он вызовет тот метод, который не должен был вызывать.
6007.24 6024.20 "Анатолий Кулаков" Ну и вообще, если мы должны заглянуть внутрь для того, чтобы определить, какой метод нам вызвать, если мы не можем по сигнатуре понять, если мы можем по названию понять, какой метод нам нужно вызывать, то это на самом деле большой красный флаг того, что мы сделаем что-то не так.
6024.20 6027.52 "Анатолий Кулаков" Того, что мы раскрываем им логику имплементации.
6027.52 6032.32 "Анатолий Кулаков" В общем, этот подход тоже довольно плохой с точки зрения дизайна вашего класса.
6032.32 6033.88 "Анатолий Кулаков" Что же, собственно, выбрать?
6033.88 6036.04 "Анатолий Кулаков" Куда пойти, куда податься?
6036.04 6038.04 "Анатолий Кулаков" Давайте рассмотрим поподробнее.
6038.04 6041.08 "Анатолий Кулаков" Итак, мы на самом деле зашли в тупик.
6041.08 6050.20 "Анатолий Кулаков" И в тупик мы зашли не просто так, а потому что мы пытались бороться с той ситуацией, что на данный момент у нас есть неправильный дизайн нашего класса.
6050.20 6055.04 "Анатолий Кулаков" И в рамках этого неправильного дизайна хорошо решить поставленную задачу не получится.
6055.04 6057.20 "Анатолий Кулаков" Нам нужно переделать наш дизайн.
6057.20 6061.56 "Анатолий Кулаков" И этому как раз-таки поможет наша наивысшая форма хранения.
6061.56 6064.08 "Анатолий Кулаков" Что же в данном случае будет наивысшей формой?
6064.08 6078.60 "Анатолий Кулаков" В терминах этой наивысшей формы мы должны сохранять не результат работы, то есть не вот эта отрендеренная продолжительность времени фильма, а источник данных, из которого мы можем получить этот результат.
6078.60 6089.16 "Анатолий Кулаков" И в нашем случае результатом этих данных, которые мы пытались оперировать, это количество баллов лояльности, которые сейчас есть у нашего кастомера, у нашего пользователя.
6089.16 6090.88 "Анатолий Кулаков" Вот это уже результат.
6090.88 6094.32 "Анатолий Кулаков" Этот результат на самом деле состоит из двух источников.
6094.32 6101.32 "Анатолий Кулаков" Во-первых, сколько баллов он заработал, и во-вторых, сколько баллов он потратил, сколько баллов мы с него списали.
6101.32 6103.32 "Анатолий Кулаков" И мы сейчас храним просто сумму.
6103.32 6105.16 "Анатолий Кулаков" Сумму вот этих двух источников.
6105.16 6111.96 "Анатолий Кулаков" Вот с этим подходом, это неправильный подход, с этим подходом данную поставленную задачу не решить.
6111.96 6115.60 "Анатолий Кулаков" Вместо этого мы должны сохранить два поля.
6115.60 6122.04 "Анатолий Кулаков" Мы должны сохранить поле, сколько наш кастомер заработал баллов и сколько наш кастомер баллов потратил.
6122.04 6128.04 "Анатолий Кулаков" А вопрос, сколько у него баллов сейчас, мы можем вычислить на ритул, с помощью обычного вычисляемого свойства.
6128.04 6130.52 "Анатолий Кулаков" И тогда наш кастомер приобретает следующий вид.
6130.52 6139.04 "Анатолий Кулаков" Хранит он у себя PointEarned и PointRedempt, два приватных свойства, в которых хранятся соответствующее количество баллов.
6139.04 6146.96 "Анатолий Кулаков" У него должен быть метод increaseEarnedPoint, то есть те баллы, которые он заработал, к нему прибавились.
6146.96 6160.76 "Анатолий Кулаков" ReduceEarnedPoint, то есть те баллы, которые мы с него хотим списать за какие-то возврат товаров, мы списываем именно из тех баллов, которые он заработал, а не от суммы его баллов или от каких-то других баллов.
6160.76 6169.52 "Анатолий Кулаков" Именно те, которые он заработал, мы ему за товар прибавили и за отдачу товара, за возврат товара, мы их отняли из этого единственного свойства.
6169.52 6172.52 "Анатолий Кулаков" И у нас остается прекрасный метод, который RedeemPoint.
6172.52 6182.04 "Анатолий Кулаков" Это метод, который прибавляет те баллы, которые он потратил, мы с него списали, которые он отдал в счет товара.
6182.04 6184.60 "Анатолий Кулаков" Он их прибавляет во второе поле.
6184.60 6189.92 "Анатолий Кулаков" Соответственно, благодаря такому разделению на два поля у нас уже нет двойного трактования.
6189.92 6202.52 "Анатолий Кулаков" Мы убрали вот этот избыточный метод SubstractLoyaltyPoint, то есть мы уже, когда мы не знали, какой метод вызвать для того, чтобы правильно учесть баллы за возврат товара.
6202.52 6213.28 "Анатолий Кулаков" Метод, который просто удаляет заработанные или метод, который добавляет потраченные.
6213.28 6220.40 "Анатолий Кулаков" Сейчас это очевидно, какой метод мы здесь вызовем, потому что когда товар возвращается, естественно, мы никакой Redeem не делаем.
6220.40 6222.68 "Анатолий Кулаков" Мы просто убираем заработанные баллы.
6222.68 6232.96 "Анатолий Кулаков" Это понятно по сигнатуре, это понятно по названию и теперь этот класс можно безошибочно юзать из наших каких-то других сценариев.
6232.96 6254.48 "Анатолий Кулаков" И здесь интересно, что в обоих случаях, когда мы разбирали продолжительность фильма и здесь, когда мы разбирали баллы лояльности, мы изменили наши классы таким образом, что теперь мы можем представлять данные в более широком формате, чем от нас требует текущее задание.
6254.48 6263.08 "Анатолий Кулаков" То есть там мы могли длину фильма показать в любом формате, в любом языке, соответственно, на любом UI.
6263.08 6278.12 "Анатолий Кулаков" И здесь мы можем показать, например, баллы лояльности уже не просто так, сколько сейчас у клиентов баллов лояльности, как было раньше, но мы можем, например, показать ему, сколько всего баллов лояльности клиент, допустим, потратил.
6278.12 6281.76 "Анатолий Кулаков" То есть сколько он сэкономил, допустим, за какой-то период времени.
6281.76 6291.80 "Анатолий Кулаков" И это его может быть больше воодушевить на покупке, что не только у вас сейчас там 20 баллов, но и в этом месяце вы потратили, допустим, 200 баллов лояльности, то есть вы, по сути, сэкономили каких-то 200 денег.
6291.80 6299.32 "Анатолий Кулаков" В общем, то есть если к нам заказчик придет с таким требованием, мы его уже в рамках данного разделения полей уже сможем реализовать.
6299.32 6306.64 "Анатолий Кулаков" То есть нам вот это представление в наивысшей форме числа дает немножко больше возможностей на будущее.
6306.64 6307.64 "Анатолий Кулаков" Пойдем дальше.
6307.64 6313.60 "Анатолий Кулаков" Итак, мы разделили кастомера на два поля – заработанные баллы и потраченные баллы.
6313.60 6320.80 "Анатолий Кулаков" Но на самом деле кастомеру принадлежит только одно поле, то есть только одно поле, за которое оно отвечает.
6320.80 6325.60 "Анатолий Кулаков" Это поле – баллы, которые потратил кастомер.
6325.60 6328.64 "Анатолий Кулаков" То есть это кастомер и он тратит свои баллы.
6328.64 6331.48 "Анатолий Кулаков" Естественно, это поле принадлежит кастомеру, мы про него знаем.
6331.48 6337.56 "Анатолий Кулаков" А вот второе поле – баллы, которые кастомер заработал, на самом деле зависят от заказа.
6337.56 6352.66 "Анатолий Кулаков" То есть чем больше кастомер сделал заказов, тем больше там в этом заказе какая-то скидка или какие-то дополнительные бонусные баллы предоставлены, тем больше вот это поле – баллы заработанные, которое сейчас хранится у нас вторым полем внутри кастомера.
6352.66 6360.08 "Анатолий Кулаков" На самом деле мы можем это поле приватное внутри кастомера убрать и заменить его на список ордеров.
6360.08 6364.44 "Анатолий Кулаков" Да, просто заменить кастомер на список ордеров.
6364.44 6373.04 "Анатолий Кулаков" И вот это поле – заработанные баллы вычислять, как сумма по всем ордерам всех заработанных баллов этого кастомера.
6373.04 6376.40 "Анатолий Кулаков" При этом мы получаем большой-большой профит.
6376.40 6390.16 "Анатолий Кулаков" Во-первых, у нас эта информация не может разъехаться с официальными ордерами, то есть не может по какой-то ошибке, по какой-то причине у нас кастомеру заработаться больше, чем есть в ордерах.
6390.16 6394.22 "Анатолий Кулаков" Во-вторых, мы больше не нуждаемся в двух целых методах.
6394.22 6398.72 "Анатолий Кулаков" Нам не нужно больше increase заработанных баллов и reduce заработанных баллов.
6398.72 6399.72 "Анатолий Кулаков" Вот эти два метода.
6399.72 6404.40 "Анатолий Кулаков" Они нам больше не нужны, потому что мы заработанные баллы вычисляем динамически, прямо сразу из ордеров.
6404.40 6406.36 "Анатолий Кулаков" Что, собственно, упрощает наш класс.
6406.36 6408.76 "Анатолий Кулаков" Не это ли прекрасно?
6408.76 6422.00 "Анатолий Кулаков" И, соответственно, мы можем оставить только баллы списанные данным пользователям, а все остальное вычислять с помощью суммы или с помощью различных вычислительных полей.
6422.00 6436.76 "Анатолий Кулаков" Если мы продолжим дальше таким образом размышлять, то мы в принципе можем и поле, которое у нас называется списанные баллы у данного кастомера, мы его сейчас храним в виде просто значения, сколько баллов мы списали.
6436.76 6441.44 "Анатолий Кулаков" На самом деле это тоже можно разложить, потому что это уже представление информации.
6441.44 6448.12 "Анатолий Кулаков" Это представление информации о нескольких попытках, от нескольких списаний баллов.
6448.12 6453.80 "Анатолий Кулаков" То есть на самом деле мы можем хранить массив всех списаний, которые были у этого кастомера.
6453.80 6457.60 "Анатолий Кулаков" А количество списанных, естественно, определять с помощью суммы по этому массиву.
6457.60 6470.24 "Анатолий Кулаков" И тогда у нас это тоже будет как бы Highest, наивысшая форма хранения, когда мы будем сохранить изначальный источник, то есть когда мы списывали, а не только сумму.
6470.24 6484.52 "Анатолий Кулаков" И вот если мы продолжим дальше эту шарманку крутить, если мы продолжим дальше все эти поля расписывать, кто откуда взялся, кто его источник этих данных, то мы непосредственно придем к такой концепции, к такому понятию как Even Sourcing.
6484.52 6499.44 "Анатолий Кулаков" Архитектурный подход Even Sourcing - это как раз таки и есть кульминация вот этого самого высокого формата хранения данных, которое описывается полностью для всей информации, которая есть в системе.
6499.44 6509.24 "Анатолий Кулаков" Even Sourcing как раз таки и подразумевает то, что мы вообще не храним результирующие данные, мы храним только изначальную форму, то есть изначально то, что к нам пришло в систему.
6509.24 6515.48 "Анатолий Кулаков" Вот списали один раз баллы, вот мы один раз захранили эту информацию, второй раз списали, второй раз сохранили.
6515.48 6527.00 "Анатолий Кулаков" А ту информацию, которая нам нужна, например сколько сейчас у кастомера находится баллов, она вычисляется динамически из тех данных, из тех ивентов, которые у нас есть, которые мы записали.
6527.00 6532.36 "Анатолий Кулаков" Вот к Even Sourcing как раз и ведет вся вот эта концепция.
6532.36 6542.44 "Анатолий Кулаков" И соответственно из Even Sourcing мы можем представить абсолютно любой формат, абсолютно любое представление тех данных, которые кастомер захочет в будущем.
6542.44 6546.24 "Анатолий Кулаков" Это самая гибкая система, из которой только возможно представить.
6546.24 6562.58 "Анатолий Кулаков" Если кастомер завтра придет и скажет, я хочу узнать сколько на Новый год клиенты там тратили баллов, а сколько на следующий день зарабатывали, мы это элементарно делаем с помощью Even Sourcing и абсолютно невозможно это сделать, если мы говорим про прошлые заслуги клиентов из любой другой системы.
6562.58 6569.92 "Анатолий Кулаков" Ну так что, нужно использовать Even Sourcing везде, всегда, на любых данных, на любых программах.
6569.92 6571.36 "Анатолий Кулаков" Здесь очень важно соблюдать баланс.
6571.36 6581.28 "Анатолий Кулаков" И в принципе довольно примитивный совет, типа соблюдайте везде баланс, но вот здесь он очень-очень важен.
6581.28 6594.00 "Анатолий Кулаков" Потому что ответить на вопрос, нужен вам здесь Even Sourcing или не нужен, и насколько далеки он нужен или насколько он далеки и не нужен, это полностью зависит от требований к вашему проекту.
6594.00 6597.24 "Анатолий Кулаков" И невозможно делать какое-то универсальное решение.
6597.24 6606.28 "Анатолий Кулаков" В данной ситуации, когда мы разбирали баллы лояльности, например, то достаточно остановиться на двух полях.
6606.28 6609.88 "Анатолий Кулаков" На двух приватных полях сколько баллов заработано было и сколько баллов потрачено.
6609.88 6614.08 "Анатолий Кулаков" Это решает абсолютно все наши требования, которые на данный момент мы имеем.
6614.08 6623.36 "Анатолий Кулаков" Как только мы можем решить все требования, которые у нас есть, на этом шаге нужно перестать раскладывать дальше в наивысшую форму представления информации.
6623.36 6635.36 "Анатолий Кулаков" Если вдруг мы уже не можем с нашими текущими данными решить проблему, а нам нужно дальше раскладывать, то можно, соответственно, продолжить данные и увлечение Even Sourcing.
6635.36 6638.88 "Анатолий Кулаков" И тут нужно четко понимать, чем нам это грозит.
6638.88 6645.48 "Анатолий Кулаков" Как я уже сказал, Even Sourcing он мегагибкий, он может представить вам данные в абсолютно любой форме, которым только возможность.
6645.48 6650.72 "Анатолий Кулаков" Гибкость - это главная фишка вот этого подхода, когда мы стремимся к Even Sourcing.
6650.72 6653.04 "Анатолий Кулаков" Но у него есть куча проблем.
6653.04 6663.20 "Анатолий Кулаков" И одни из главных - это, во-первых, большая требовательность к сториджу, потому что мы должны хранить обычно больше информации, чем нам нужно.
6663.20 6670.04 "Анатолий Кулаков" Не какой-то агрегат, который в конце концов сойдется, а все источники, все события, которые были до этого.
6670.04 6672.08 "Анатолий Кулаков" Далее - это сложность.
6672.08 6677.56 "Анатолий Кулаков" Это сложность кода, это сложность понимания, это сложность сопровождения, сложность миграций.
6677.56 6683.64 "Анатолий Кулаков" И очень много возникает других сложностей, когда мы начинаем работать с Event'ами и со структурами данных, которые это все хранят.
6683.64 6686.28 "Анатолий Кулаков" И в-третьих, это, конечно же, перформанс.
6686.28 6689.60 "Анатолий Кулаков" Мы теперь не можем просто так выдать сразу пользователя, сколько баллов у него есть.
6689.60 6701.88 "Анатолий Кулаков" Мы сначала должны пройтись по всем его Event'ам, посчитать все ордеры за всю историю, которые когда-то у него были, сложить это все, отнять, учесть там какие-то налоги, еще что-то, списание, праздники, подарки.
6701.88 6708.80 "Анатолий Кулаков" Естественно, существует куча способов, как это все дело закэшировать, но опять же, мы ударяемся в том, что это становится намного сложнее.
6708.80 6713.28 "Анатолий Кулаков" Мы ударяемся в том, что, конечно, надо инвалидировать, как-то это хранить и так далее.
6713.28 6718.08 "Анатолий Кулаков" В общем, все равно в перформанс, стораж и комплексы мы упремся.
6718.08 6729.60 "Анатолий Кулаков" Поэтому чем более гибкое приложение у вас есть, тем больше проблем вы будете испытывать с дополнительным сторажем, с дополнительной сложностью вашего кода или с производительностью.
6729.60 6732.88 "Анатолий Кулаков" И именно поэтому очень важно здесь беречь баланс.
6732.88 6746.36 "Анатолий Кулаков" Беречь баланс между тем, чтобы код у вас остался понимабельным, читабельным, тестируемым и между тем, чтобы давать всю необходимую информацию для того, чтобы реализовать все ваши бизнес-требования.
6746.36 6760.64 "Анатолий Кулаков" Вот таким интересным способом можно пройти от самого банального рассуждения, каким образом хранить время продолжительности какого-то фильма в базе данных, до кульминации, до полностью even sourcing.
6760.64 6765.34 "Анатолий Кулаков" И найти этот баланс, эту точку в вашем приложении довольно важно.
6765.34 6778.20 "Анатолий Кулаков" Важно понимать, где остановиться и ни в коем случае не писать изначально все на even sourcing или не писать все изначально на каких-то забитых костылях, которые дальше уже невозможно никак крутить, развивать и представлять в различных формах.
6778.20 6789.80 "Игорь Лабутин" Да, это все действительно выглядело, ну так, может звучать довольно теоретически, но вот так я смотрю на свои -700 баллов в озоне и понимаю, что проблема-то имеет практическое
6789.80 6794.60 None значение. Люди вовремя не задумались об этой проблеме.
6794.60 6802.44 "Игорь Лабутин" Нет, может быть это действительно итоговая сумма и внутри хранится как два числа, но как бы -700 баллов и как бы да.
6802.44 6803.44 "Игорь Лабутин" Интересно.
6803.44 6807.20 "Игорь Лабутин" Возможно, это бизнес сценарий вполне нормальный.
6807.20 6809.32 "Игорь Лабутин" Давай будем потихонечку заканчивать.
6809.32 6816.56 "Игорь Лабутин" У нас остался последний раздел, кратко о разном, не знаю, насколько получится кратко, ссылок сегодня довольно много.
6816.56 6827.24 "Игорь Лабутин" Мне на этой неделе попадалось довольно много всяких разных ссылок на библиотечки, которыми я не пользовался, но они мне показались интересными, поэтому я их сюда включил.
6827.24 6831.96 "Игорь Лабутин" Может быть вам покажется интересно, может только ты чем-то пользовался.
6831.96 6851.28 "Игорь Лабутин" Смотрите, во-первых, библиотечка под названием Distributed Log, штука, которая, ну не знаю, наверное, нужна не очень часто, но иногда может быть вам нужен какой-нибудь Distributed Mutex, либо Read/Write Log, либо вообще Sima4, причем он настолько distributed, что у него куча всяких разных бекендов, он может работать на кучу разных бекендов.
6851.28 6862.24 "Игорь Лабутин" Использование его тривиальное, это просто wait_using и внутри там, acquire_a_sync от какого-то именованного Distributed Log, но у него есть много разных бекендов.
6862.24 6877.88 "Игорь Лабутин" Бекенды у него могут быть на SQL, на Postgres, на MySQL, на Oracle, на Redis, на Azure с использованием Azure Blobs, на ZooKeeper, на файловой системе или если вы на винде работаете, то на wait_handle, которые глобальны в рамках одной винды.
6877.88 6894.24 "Игорь Лабутин" То есть в общем штука, которая, ну особенно если вы это делаете на базе данных, то может быть полезно такой довольно простой API, вокруг довольно, ну в каком-то смысле сложной концепции, правильно реализовать Sima4 довольно все-таки может быть сложновато, или там Read/Write Log.
6894.24 6898.64 "Игорь Лабутин" Поддерживаются async, поддерживаются всякие timeout, cancellation и все дела.
6898.64 6910.32 "Игорь Лабутин" У для сечки порядка 1000 всего звездочек, не так много, при этом уже 130 форков, это мне прямо интересно, кто ее так нафоркал, либо народ там под себя как-то допиливает.
6910.32 6929.48 "Игорь Лабутин" При этом там есть понятное дело всякие тонкости, что например если вы делаете какой-нибудь Sima4 или любой лог, вы держите лог, а у вас отвалился connection Gbd, ну как бы лог вы потеряли, а с другой стороны может быть даже потеряли слот, и Sima4 будет вечно золочен этим вашим логом.
6929.48 6945.12 "Игорь Лабутин" На эту тему там есть отдельная статейка у них в Readme, то есть если будете использовать, почитайте, посмотрите все тонкости, но вообще концепция интересная, нужно делать с осторожностью, но может быть если вам действительно нужно дистрибьютировать логи, берите, пользуйтесь.
6945.12 6967.92 "Анатолий Кулаков" Ну да, я такую концепцию несколько лет назад реализовал в одном из приложений, мне хватило файл системы, в общем у меня был distributed log на файловой системе, я съел очень много интересных моментов, edge cases, и вот после этого я нашел эту библиотеку, мне больше всего удовольствие конечно доставило просто посмотреть на имплементацию, как там все реализовано на различных провайдерах, потому что нужно понимать, что у каждого есть свои интересные тонкости.
6967.92 6976.76 "Анатолий Кулаков" Кода там немного, в общем так, 5 минут перед сном почитать самое то, поэтому для любознательных тоже рекомендую просто исследить и посмотреть.
6976.76 7034.56 "Игорь Лабутин" Вторая библиотечка это WorldSharp, если вы используете хашкорповский волд для хранения секретов, то вам возможно нужно к нему зачем-то наступаться из датанетовского кода, нативно соответственно к волду, и тогда берете библиотечку WorldSharp, она какая-то не очень большая, в смысле что у нее всего 400 с небольшим звездочек, она при этом довольно давняя, я так посмотрел, что с 2021 года по крайней мере история у нее есть, и у нее в ридме, у нее отличный шикарный ридме, прям все очень подробно расписано, и там написано, что это наиболее полная кроссплатформенная библиотечка, которая поддерживает dotnet standards 1.3, классический framework 4.5, то есть, а поскольку она поддерживает dotnet standards 1.3, то там она и на mono заведется, и на examore, и на uvp, короче везде где dotnet работает практически, она будет работать, разве что вы на какой-нибудь там 4.0 сидите, но наверное вы тогда hashigor, может быть, не пользуетесь, потому что это все-таки больше про всякие микросервисы и прочее, мне кажется.
7034.56 7058.76 "Игорь Лабутин" Не пользовался ни разу, но если верить, так скажем, тексту, и она причем довольно активно живет, там какие-то иши пишутся, все дела фиксятся, так что тоже посмотрите, может быть будет полезно, если вам зачем-то надо, если вы не принимаете секреты каким-то там простым способом, если вы через переменное окружение охотите, например, в волт, то может быть это то, что вам нужно.
7058.76 7093.88 "Игорь Лабутин" Так, еще одна библиотечка, это уже от Microsoft, называется она scriptdom, и она предназначена для парсинга tsql, то есть если вы зачем-то хотите парсить sql-файлики, в смысле sql-язык, именно tsql, то вот эта библиотека, можно ее использовать, она теперь open-source, на middle лицензии, и все дела, позволяет преобразовать sql в abstract syntax tree и дальше с ним что угодно делать, там что-нибудь проверять, компилировать куда-нибудь, что-нибудь менять, проверять, в смысле какие-нибудь аналайзеры писать, в общем, будет полезно.
7093.88 7102.20 "Игорь Лабутин" Раньше она была доступна, но у нее не было доступных исходники, теперь она вместе со исходниками, так что можно форму себе и что-нибудь поменять, если надо.
7102.20 7166.64 "Игорь Лабутин" И последняя библиотечка, которая мне попадалась, это linq, ну то есть мне попалась статья, которая называется linq on steroids, и там автор рассказывает про то, как можно сделать simd операции в таком linq-стайл API для коллекций, то есть поиск там суммы или average элементов, которые поддерживают, спасибо generic математике, какой-нибудь там inumber и idivision оператор с помощью simd-ов и классов типа вектора, t и так далее, тоже интересно скорее посмотреть на концепции, как это делается, потому что там есть куча ограничений, ну например результат idivision, грубо говоря, он параметризуется собственно одним и тем же типом, то есть если вы вычисляете средний из int-ов, вы не можете из такого extension-метода вернуть double, вы обязаны вернуть int, и соответственно средний из int-ов считать в int, ну наверное, не очень интересно, но как факт, если вам вдруг нужно зачем-то какими-нибудь такими number-like типами делать векторные операции в generic виде, посмотрите, как пример будет, мне кажется, очень полезно.
7166.64 7197.28 "Анатолий Кулаков" Я хочу сообщить, что библиотека, которая называется image-sharp-web достигла версии 3.0, и это ни много ни мало, а 8 месяцев упорной разработки, ребята выпустили ее в совместимое с dotnet 6, потому что это последний LTS, они пообещали, что будут рубить в новых версиях, то есть оставлять только последний LTS, а все остальные будут отрубать, но предыдущая версия, естественно, поддерживается, если вдруг вы еще не перешли, то в этом нет никаких проблем.
7197.28 7218.04 "Анатолий Кулаков" Самое главное, что позволило им сие дерзкое правило сделать, это удалить все старые API, все совместимости со старыми фреймворками, которые у них были, и это действие улучшило performance, естественно, улучшило читабельность, и в общем библиотеку позволило сделать свежий, красивый и привлекательный.
7218.04 7227.32 "Анатолий Кулаков" Обязательно стоит упомянуть, что теперь она полностью покрывает весь свой API с помощью nullable reference types, поэтому nullable reference types цветут и пахнут.
7227.32 7232.80 "Анатолий Кулаков" Ну и самое главное введение – это добавление tech helper, который для ASP.
7232.80 7237.96 "Анатолий Кулаков" Он нужен для того, чтобы использовать в ASP tech helper.
7237.96 7251.36 "Анатолий Кулаков" То есть это в языке разметки вы можете писать в различные такие элементы специальные, системные, которые на самом деле раскладываются с помощью ASP renderer, и у этих элементов есть очень много положительных различных свойств.
7251.36 7260.44 "Анатолий Кулаков" Во-первых, они очень легко и красиво читаются, они уменьшают сложность, а сложность в ImageSharp была огромная, например, с работы с картинками.
7260.44 7264.44 "Анатолий Кулаков" В общем, с помощью tech helper это довольно становилось очевидным и красивым.
7264.44 7270.48 "Анатолий Кулаков" У них есть там строгая типизация для специальных tech helper и ASP компонентов.
7270.48 7279.64 "Анатолий Кулаков" Существуют понятные стандартные подходы для тестирования, соответственно, вы теперь можете это тестировать и переиспользовать, так как это стандартный ASP компонент, вы можете их теперь переиспользовать.
7279.64 7282.64 "Анатолий Кулаков" И что это значит?
7282.64 7289.96 "Анатолий Кулаков" Это значит, что картинку вы можете в своем tech helper переуказать какую-то картинку и добавить ей динамически различных свойств.
7289.96 7304.52 "Анатолий Кулаков" Например, изменить высоту, изменить ширину картинки, каким-то образом сделать resize с помощью какого-то алгоритма, заполнить каким-то цветом и добавить еще хэш-сумму с помощью HMAC, в котором HMAC, короче.
7304.52 7310.04 "Анатолий Кулаков" HMAC-сумму добавить и все это с помощью одной строчки там красивого tech helper.
7310.04 7313.36 "Анатолий Кулаков" И это, наверное, самое главное изменение всего.
7313.36 7318.76 "Анатолий Кулаков" В будущем ребята сосредоточатся на imageSharp Drawing и imageSharp Fonts.
7318.76 7327.36 "Анатолий Кулаков" В общем, я знаю, что многие наши слушатели ждут, когда же, собственно, Drawing станет low-cost платформенным.
7327.36 7329.48 "Анатолий Кулаков" Я думаю, что вот это ваш шанс.
7329.48 7339.56 "Анатолий Кулаков" Вот скоро релизится imageSharp Drawing и с помощью него вы можете ваше приложение попробовать перенести на абсолютно другие платформы или может даже воспользоваться новым .NET Core.
7339.56 7349.68 "Игорь Лабутин" Ну да, звучит интересно и действительно это может быть один из вариантов использования этого дела, в смысле Drawing плюс-минус cross-платформенно.
7349.68 7353.40 "Игорь Лабутин" Напоследок хочу рассказать про одну статью.
7353.40 7365.08 "Игорь Лабутин" Она у нас давно лежит в backlog, я честно ждал, что у нее выйдет там хотя бы вторая часть, а может быть третья, потому что она называется Choosing .NET Memory Profiler in Visual Studio Part 1.
7365.08 7372.72 "Игорь Лабутин" И я ждал, может выйдет Part 2, она так и не вышла, поэтому чтобы не потерялась, давайте мы уже кратенько про нее расскажем.
7372.72 7377.60 "Игорь Лабутин" Это на самом деле довольно подробный гайд про то, какие профайлеры есть в Visual Studio с точки зрения памяти.
7377.60 7382.36 "Игорь Лабутин" Их как минимум два, это .NET Object Allocation Tracking Tool.
7382.36 7393.84 "Игорь Лабутин" Штука позволяет сказать сколько инстансов, каких типов были заанонсированы и какого размера это все, сколько это все занимает и из каких методов это все аллоцируется.
7393.84 7400.76 "Игорь Лабутин" То есть такой как бы точечный поиск того, какие там месты и по каких сценариях у вас в чем где аллоцируют.
7400.76 7406.80 "Игорь Лабутин" А второй это Memory Usage Tool, это больше про heap snapshot и понимание, какие объекты живы в том или ином виде.
7406.80 7413.36 "Игорь Лабутин" То есть Object Allocation Tracking, то есть объекты может быть там, их много аллоцируется, но много же и собирается garbage collector.
7413.36 7420.00 "Игорь Лабутин" И в dumpах, в смысле в heap snapshot они будут не видны, потому что garbage collector будет успевать собирать.
7420.00 7425.44 "Игорь Лабутин" И тогда вам нужен .NET Object Allocation Tracking Tool, чтобы понимать, а где же вы аллоцируете.
7425.44 7433.40 "Игорь Лабутин" Это еще иногда называется Memory Traffic Analysis, чтобы видеть, сколько вы всего аллоцируете в вашей программе, независимо от того, как отправляется garbage collector.
7433.40 7439.12 "Игорь Лабутин" Если же вам нужно понимать, почему у вас там какой-нибудь memory leak, то здесь скорее будет более важен Memory Usage Tool.
7439.12 7446.24 "Игорь Лабутин" И вот статья как раз аккуратненько проходится про то, как это все используют Visual Studio со сканшотиками, с примерами, с примером приложения, которое утекает.
7446.24 7455.32 "Игорь Лабутин" И соответственно можно прям четенько разложить, объясняются какие колонки, на что смотреть, как интерпретировать результаты.
7455.32 7464.96 "Игорь Лабутин" То есть если вы не пользовались или хотите научиться пользоваться профайлером Visual Studio, в принципе годная статья, в качестве такой вводной инструкции вполне подойдет.
7464.96 7473.40 "Анатолий Кулаков" Отлично, ну что ж, хорошо посидели, даже без микрософтовских анонсов кажется, что всех лимита выбились, давай закругляться.
7473.40 7474.56 "Игорь Лабутин" Да, давай закругляться.
7474.56 7482.00 "Игорь Лабутин" Мы сегодня опять, наверное, выглядели действительно за пару часов, наши подкасты становятся все длиннее и длиннее.
7482.00 7484.92 "Игорь Лабутин" Ну ладно, будем где-то вокруг двух часов, наверное, так и крутиться.
7484.92 7491.80 "Игорь Лабутин" Сегодня поговорили про rootless контейнеры еще разок, вспомнили, что это такое, зачем это надо.
7491.80 7518.32 "Игорь Лабутин" Обсудили тест контейнера к применению к .NET, поговорили про таски в формате библиотечки таскгрупп от Стивена Клири и методов расширения для тасков, посмотрели на полиглот ноутбука для .NET, детально обсудили техрадар, детально обсудили, как нам же хранить информацию и надо ли всем ударять за вариант сорсинг, или все-таки можно пока подождать и не бежать туда.
7518.32 7525.72 "Игорь Лабутин" Ну и обсудили кучку разных библиотечек полезных, которые могут оказаться полезными или, может быть, просто интересными, чтобы в них посмотреть.
7525.72 7538.48 "Анатолий Кулаков" На этом все, большое спасибо, друзья, что нас слушали, шарили пост колокольчики и все такое, распространите нас, любите, слушайте, мы это тоже очень-очень любим и ценим вас.
7538.48 7541.08 "Анатолий Кулаков" Всем счастливо, с вами был Анатолий Кулаков.
7541.08 7544.62 "Игорь Лабутин" И Игорь Лабутин, это был 71 выпуск радио .NET, всем пока.
7544.62 7552.22 None [музыка]
