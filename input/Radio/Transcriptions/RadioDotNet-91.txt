0.00 11.32 SPEAKER_01 Здравствуйте, дорогие друзья, в эфире Радио Дотнет, выпуск номер 91.
11.32 14.80 SPEAKER_01 И с вами, как всегда, в студии Анатолий Кулаков.
14.80 15.80 SPEAKER_01 И Игорь Лабутин.
15.80 16.80 SPEAKER_01 Всем привет.
16.80 17.80 SPEAKER_01 Неизменной фамилии.
17.80 19.76 SPEAKER_01 А кто еще неизменный?
19.76 20.76 SPEAKER_01 Да нет.
20.76 23.92 SPEAKER_01 Расширяемый и добавляемый – это наши помогаторы.
23.92 27.16 SPEAKER_01 Поэтому, друзья, огромное большое спасибо всем, кто помогает подкасту.
27.16 40.64 SPEAKER_01 В частности, Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов и Константин Ушаков.
40.64 42.92 SPEAKER_01 Спасибо большое, друзья, что нам помогаете.
42.92 48.76 SPEAKER_01 И также всем тем, кто наш распространяет, советует друзьям, лайкает, комментирует.
48.76 55.64 SPEAKER_01 В общем, всем большое спасибо, что помогаете сделать наш подкаст популярнее, востребованнее и этим самым интереснее.
55.64 61.04 SPEAKER_01 Так, сики, ну что, пойдём посмотрим, что у нас случилось за эти две недели.
61.04 64.20 SPEAKER_01 Мне кажется, мы целых две недели уже не упоминали Aspire.
64.20 65.20 SPEAKER_01 Не стоит ли нам исправиться?
65.20 82.20 SPEAKER_01 Да, именно с него мы сегодня и начнём, потому что Майкрософт выпустила новую версию, ну, новый превью .NET Aspire, .NET Aspire Preview 5, и в нём, по хорошей традиции, есть довольно большое количество всяких разных ломающих изменений.
82.20 89.04 SPEAKER_01 Тут Aspire – это такой продукт, в котором действительно каждый превью что-нибудь ломают и переделывают опишку заново.
89.04 99.56 SPEAKER_01 Делают это всё, конечно же, из лучших побуждений, чтобы всё это выглядело красиво и хорошо работало, и было правильно структурировано, поэтому давайте пробежимся по всем изменениям.
99.56 103.56 SPEAKER_01 Ну, ещё учитывают фидбэк, который даёт люди, пока тестируют.
103.56 107.36 SPEAKER_01 Ну, это хорошо, потому что в бете когда они ещё смогут поломать, если не в бете, правда же?
107.36 108.36 SPEAKER_01 Ну, да.
108.36 109.36 SPEAKER_01 Пока нет релиза.
109.36 114.60 SPEAKER_01 И даже несмотря на то, что ломают, народ довольно положительно в целом отзывается о том, что происходит.
114.60 115.60 SPEAKER_01 Ну, правильно.
115.60 130.96 SPEAKER_01 Во-первых, немножко поменялся пэкэджинг, то, что они называют, то есть набор модулей, то есть набор нугет-пакетов, в которые запакован Aspire, немножко поменялся, они вынесли Azure отдельно и разделили Aspire Hosting и Aspire Hosting Azure.
130.96 143.16 SPEAKER_01 Раньше всё это жило в одном, потому что, собственно, было нацелено только на Azure, но они справедливо решили, что, наверное, Azure часть, она немножко отдельно и для стендалон-сценариев Azure не так и нужен.
143.16 159.72 SPEAKER_01 Теперь это два разных компонента, так скажем, что даёт хорошую гибкость, плюс чётко задаёт границы, чтобы Azure функциональность там не ползала в какое-нибудь ядро Aspire, где она будет потом мешаться, когда мы будем работать не на Azure.
159.72 167.36 SPEAKER_01 Также сильно довольно поменялось то, что они называют Application Model, то есть некоторое внутреннее логическое представление.
167.36 179.56 SPEAKER_01 По сути, Application Model, она как бы в центре всего Aspire и представляет собой набор некоторых абстракций, через которые вы как раз и задаёте всякие разные компоненты, с которыми Aspire потом работает.
179.56 183.48 SPEAKER_01 А также эта модель задаёт то, как эти компоненты между собой общаются.
183.48 203.12 SPEAKER_01 Во-первых, теперь в 5 превью, если вы, например, законфигурите Application Url как просто HTTP-транспорт, то есть не секьюрный, то в 5 превью ваше приложение тупо закрашится, всё должно быть секьюрно, и вот это всё.
203.12 225.12 SPEAKER_01 Для того, чтобы теперь это дело разрешить, то есть специальное переменное окружение, называется Aspire Allow Unsecured Transport, тогда можно использовать обычное HTTP, то есть они стремятся, чтобы не было случайно того, что вы что-то подебажили локально на HTTP и в таком же виде задеплоили напрот, я напоминаю, что в Aspire предполагается, что довольно легко задеплоить дальше напрот.
225.12 230.08 SPEAKER_01 И если вы настроили всё с HTTP, ну, такое же HTTP полетит напрот.
230.08 231.08 SPEAKER_01 Видимо, для этого и сделали, чтобы было нельзя.
231.08 244.16 SPEAKER_01 Слушай, а как же вот эта концепция, что cloud-ready приложения, прежде всего, они там всё равно крутятся где-то за каким-то, за какой-то проксивой, да, и внутри HTTPS нафиг не нужен, чтобы между сервисами ходить?
244.16 246.72 SPEAKER_01 Это хороший пойнт, не знаю.
246.72 255.96 SPEAKER_01 То есть, действительно, если вы деплоите всё в ваш приватный нетворк, то вам HTTPS, вероятно, может быть, даже и не нужен.
255.96 264.80 SPEAKER_01 С другой стороны, многие используют, как же это называется, я забыл слово, правильно, ну, короче, Zero Trust Network.
264.80 274.32 SPEAKER_01 Zero Trust, когда мы считаем, что мы не в своём личной сети и даже между сервисами всё равно нужно HTTPS, там взаимная аутентификация и вот это всё.
274.32 280.36 SPEAKER_01 Ну, может, это когда в публичных облаках оно имеет смысл, но если ты на локальном кубе перекрутишься, то зачем тебе это Zero Trust?
280.36 289.80 SPEAKER_01 У тебя там есть какой-нибудь Nginx, который их HTTPS делает и всё, а внутри должно всё, то есть, может всё летать вполне по открытому HTTP протоколу.
289.80 296.96 SPEAKER_01 Ну, вот, видимо, для этого этот самый спайр-аллаун секьюрит-транспорт и ввели, чтобы можно было, по крайней мере, сделать так, чтобы оно работало.
296.96 309.80 SPEAKER_01 Но они помнят и знают, что на самом деле в большинстве случаев есть некоторая праксия перед этим, поэтому следующее изменение, оно про то, что по дефолту для дотнетных проектов включены теперь форвардинг-хедеров.
309.80 331.64 SPEAKER_01 То есть они прекрасно понимают, что если вы в ваш спайр добавляете дотнетный проект и в этом проекте есть какие-то endpoints, ну в смысле вы определяете, что они есть, то автоматически проставляется переменное окружение под названием ExpandedCoreForwardedHeadersEnabled, которое приводит к тому, что хедера начинают форвардиться.
331.64 338.26 SPEAKER_01 Дальше, в следующие эти самые, то куда ваш трафик дальше идет.
338.26 351.14 SPEAKER_01 Они утверждают, что это, ну потому что вот это все из-за того, что спайр это в основном таргетится на контейнерное окружение, а там очень часто есть тот самый реверс-прокси, ну в общем, все то, что ты рассказывал.
351.14 354.14 SPEAKER_01 Ну да, но почему-то ж ТТПСа не требуют обязательно.
354.14 360.18 SPEAKER_01 Ну вот, и при этом это можно поведение отключить, если в спайр-конфигурации вызвать метод DisableForwardedHeaders.
360.18 364.26 SPEAKER_01 Такой экстренный метод есть, и тогда хедера не будут форвардиться.
364.26 369.62 SPEAKER_01 Дальше, в DashBoard поддержали так называемые кастомные ресурсы.
369.62 399.94 SPEAKER_01 То есть можно реализовать, точнее даже не реализовать, в DI-контейнере у вас есть два хука, по сути да, вам нужно зарегистрировать в DI-контейнере сервисы, которые реализуют ResourceNotificationService и ResourceLoggerService, и тогда вы сможете использовать эти два сервиса, а какие-то кастомные ваши ресурсы сообщать о них DashBoard и что-нибудь там логировать, например, из них.
399.94 411.42 SPEAKER_01 Они говорят, что это очень полезно для каких-то очень кастомных клаудных ресурсов, для которых у них нет поддержки, а вот с помощью таких вот хуков вы можете какой-то совершенно кастомный клаудный ресурс туда запихать.
411.42 419.66 SPEAKER_01 Ну в принципе, может, полезно это будет пользоваться, либо это будут использовать для дальнейшего развития структуры компонентов, набора компонентов, с которыми они работают.
419.66 433.34 SPEAKER_01 С volume получше стало работать, теперь можно не только withDataVolume использовать, но еще и withBindDataVolume, то есть когда вы bindите что-то существующее и таким образом у вас персистенс между запусками сохраняется.
433.34 451.86 SPEAKER_01 В RabbitMQ добавили ManagementUI, я напомню, мы уже в прошлом или позапрошлом превью у них добавилась штука, что можно для основных там популярных вещей, типа Postgre, например, есть extension метод, который добавляет соответствующий WebUI к нему, ну вот теперь такое есть для Rabbit.
451.86 465.98 SPEAKER_01 Есть новая фича Automatic Password Generation, то есть новая API, которая использует ресурс-билдер и позволяет таким образом автоматически генерить юзернеймы и пароли.
465.98 479.86 SPEAKER_01 Понятно, что это удобно для каких-то случайных аккаунтов и для тех самых автогенерируемых креденшелов, которые нужны при каждом запуске, как они это говорят.
479.86 491.38 SPEAKER_01 DockerBuildArgs поддержано, то есть теперь можно, когда вы используете метод PublishAsDockerFile, туда передать дополнительные DockerBuildArgs и, соответственно, это будет использоваться для DockerBuild.
491.38 500.42 SPEAKER_01 Ну и самое, наверное, такое важное в этой аппликейшн-модели, что они добавили отложенное исполнение StringInterpolation.
500.42 511.78 SPEAKER_01 То есть, как вы помните, у нас есть штука под названием C# StringInterpolation, в которой пишется $ перед строчечкой и внутри в фигурных скобках указываете какие-то, например, переменные.
511.78 518.06 SPEAKER_01 И это означает, что эти переменные, на них будет вызван метод ToString, и результат будет подставлен.
518.06 534.78 SPEAKER_01 Так вот, если вы такую строчку передаете параметрам функцию, то у вас функция может принимать, вы можете написать функцию, которая принимает строку, и тогда, конечно же, эта строка интерполяции будет сразу преобразована в обычную строку.
534.78 548.98 SPEAKER_01 А можете принять, по-моему, это называется FormatAbleString, если я правильно помню, и тогда вы сможете доступаться к элементам, собственно, этой строки, то есть отдельно описанию формата и отдельно к объектам, которые туда были переданы.
548.98 557.50 SPEAKER_01 Вот они как раз сделали второй случай, и это позволяет эвалюетить всякие разные, например, endpoints и прочие порты после того, как всё будет стартовано.
557.50 566.78 SPEAKER_01 То есть вы можете использовать, например, endpoint, который вы взяли у какого-то контейнера, но пока контейнер не запустился, вы, понятия не имеете, какой там будет порт, например, потому что он будет выбран случайно.
566.78 576.18 SPEAKER_01 А если вы это делаете эвалюейшн уже потом, то в момент, когда эта строчка потребуется, она заэвалюетится и там уже будет нормальный порт.
576.18 590.26 SPEAKER_01 Ну, вроде разумно, хорошо и красиво, блин, но кажется, что дело держится на таком неочевидном, как бы ненадёжном принципе, что в любой чих может сломать залетевшего воробья.
590.26 600.06 SPEAKER_01 Ну, посмотрим, да, как это будет, напоминаю, что это превью, они, возможно, в следующем превью ещё что-нибудь сломают, поменяют, так что посмотрим.
600.06 606.42 SPEAKER_01 Значит, всё это касалось application model, то есть основного API, концепции вокруг и вот этого всего.
606.42 611.54 SPEAKER_01 Вторая большая часть Aspire, это, конечно же, дэшборд.
611.54 626.06 SPEAKER_01 В дэшборде они, честно, написали, что наш основной фокус был, значит, на всяких, ну, нефункциональных требованиях, то есть там security, performance, то есть там каких-то прорывных фич и больших визуальных изменений не ждите, но тем не менее.
626.06 641.26 SPEAKER_01 Они поменяли немножко то, как отображаются структурированные логи, там немножко сгруппировали поля, раньше они просто единой перстенёй выводились, теперь отдельные поля — это контекст, отдельная группа ресурсов, отдельная группа общих, значит, каких-то софт, типа timestamp и прочего.
641.26 686.30 SPEAKER_01 Для трейс-месседжинга, то есть когда вы посылаете что-то в какую-то очередь и принимаете, теперь есть красивые иконочки в трейсах, времена теперь отображаются в локальной тайм-зоне браузера, добавили некоторое количество security апдейтов, то есть вы в дэшборде либо вы должны явно сконфигурить аутентификацию, либо явно от неё отказаться со словами dotnet-dashboard-unsecured-law-anonymous, такой сеттинг, и это всё сделано пока временно для превью-5, потому что они планируют чуть дальше сделать уже нормальный, хороший, легко используемый, как они говорят, механизм для того, чтобы авторизовываться в дэшборд, то есть дэшборд будет с авторизацией.
686.30 709.06 SPEAKER_01 Дальше open-ceilament-endpoint тоже добавили security, туда можно накинуть либо клиентский сертификат, либо apk, в дэшборд собственно authentication добавили настройку возможности подключения какого-нибудь open id-connect провайдера, в ресурс-сервере тоже endpoint security, там тельклайн сертификаты поддержаны, ну и всяческие разные performance-improvement.
709.06 743.50 SPEAKER_01 В шаблонах менялось то, что у них теперь по дефолту https, смотри выше, http теперь по дефолту нельзя, и в сервис discovery это как раз одни из тех самых breaking-changes тоже в апишке именно, раньше был метод use-service-discovery, теперь метод add-service-discovery, причем сервис discovery теперь автоматически поддерживает поиск нужной схемы протокола, то есть он будет сначала пытаться https, если не получилось, то будет пытаться http подобрать, короче все там более-менее удобно и работает.
743.50 756.86 SPEAKER_01 С точки зрения developer-туллов, улучшили поддержку в s-кодном C# DevKit-туллинге, ну в экстеншоне, вижу у студии там в основном про Ажур, всякие разные публикации в Ажур, вот это все улучшилось.
756.86 771.58 SPEAKER_01 По ресурсам и компонентам, добавилось три новых компонента, это Azure Event Hubs, это NADs и это SEC, то есть SEC теперь полноценный компонент в Aspire, можно его использовать для просмотра логов.
771.58 775.58 SPEAKER_01 А понятно уже, кто это добавляет, то есть это сам Microsoft или?
775.58 781.46 SPEAKER_01 Я не смотрел pull-реквесты, но, по-моему, если я правильно помню статью, это какие-то community contributions.
781.46 794.14 SPEAKER_01 В общем, насколько я тоже пока не видел, как это вообще у них предполагается, как это должно быть, кто это должен добавлять, поддерживать, меняться, было бы вот интересно найти какую-нибудь рекомендацию или хотя бы сложившуюся практику.
794.14 806.78 SPEAKER_01 Ну я так понимаю, сейчас это pull-реквесты в основной репозитории Aspire, то есть создать pull-реквест может кто угодно, добавить, а дальше это уже в репозитории Aspire, то есть поддерживается Майкрософтом дальше.
806.78 814.42 SPEAKER_01 Не, ну общие репозитории, где собираются все, грубо говоря, пакеты или плагины, это окей, это там много проектов так живут.
814.42 818.90 SPEAKER_01 Более интересно, а кто может в этой репозитории законтрибьюдить и кто может в это заапровить.
818.90 822.66 SPEAKER_01 Не, ну заапровить только команда Aspire, понятное дело, пока.
822.66 825.02 SPEAKER_01 Потому что это в основной репозитории самого Aspire.
825.02 838.30 SPEAKER_01 Ну тогда вопрос, насколько сложно, то есть если обычный человек с улицы пришёл, какой-нибудь компонент туда налобал, насколько это всё примется, или будут какие-то припоны, что автором обязан быть, или как-то запрулен автором должен быть, или ещё что-нибудь.
838.30 859.06 SPEAKER_01 Ну либо непонятно, например, условно говоря, для какого-нибудь сека, ну окей, да, или для нации, это довольно популярные широкоизвестные штуки, а если я приду и создам компонент, ну я не знаю, для чего-нибудь такого редкого, что-то я не могу сейчас придумать, для Динеса, во, придумал.
859.06 863.66 SPEAKER_01 Ну ты нашёл редкую, конечно, программу, действительно её в мире вообще не найти, как бы.
863.66 870.10 SPEAKER_01 Да, ну с точки зрения как бы Майкрософта, да, и тех, кто будет это апровить, это как бы неизвестная редкая хрень.
870.10 884.98 SPEAKER_01 Она может быть действительно полезна большому количеству народу, но в целом она редкая, и вот как бы, ну и таких наверняка много, да, каких-то нишевых каких-нибудь очередей, нишевых баз данных, которые используются в полутора проектах.
884.98 894.06 SPEAKER_01 С точки зрения каталога плагинов, как бы им наплевать, редко или нередко, им чего, зажалка там имени, что ли, или 3 байта написания файлика, мне кажется, в этом не должно быть проблем.
894.06 896.22 SPEAKER_01 Мне, знаешь, другой ещё аспект интересует.
896.22 915.90 SPEAKER_01 Вот, допустим, захотел я туда сделать компонент того же самого SICK, и сделал его очень-очень плохо, таким образом, что все пользователи SICK через Aspire автоматически будут думать о том, что, допустим, SICK глючит, к нему не доходят сообщения, он там мегакривой, мегаплохой, это всё только потому, что я сделал для него компонент очень кривой.
915.90 917.94 SPEAKER_01 А на самом деле SICK прекрасен и всё такое.
917.94 923.90 SPEAKER_01 Ну т.е. я могу сделать так, что репутационные какие-то издержки того производителя, они будут уничтожены.
923.90 932.98 SPEAKER_01 Допустим, SICK он маленький, ладно, а вот приду, я компонент для AWS сделаю, сделаю я компонент для AWS ненадлежащего качества, допустим.
932.98 942.30 SPEAKER_01 Как вот это будут контролировать, т.е. когда для коммерческой программы делают какой-то компонент, когда на окон может быть поставлено её имя или даже бабки какие-то.
942.30 947.22 SPEAKER_01 Ну вот непонятно, да, не знаю, не знаю.
947.22 954.06 SPEAKER_01 Причём я вот вижу, что SICK, Split, Espire, Hosting, Uphost, я прямо сейчас вот смотрю на GitHub, не знаю.
954.06 958.22 SPEAKER_01 Ну в общем получается так, что добавить может видимо кто угодно.
958.22 965.94 SPEAKER_01 Дальше как бы насколько это отлавливается Майкрософтом или остальными комьюнити, тут я не знаю.
965.94 973.06 SPEAKER_01 Не комьюнити, а как это называется-то, авторами этих библиотек, фреймворков и т.д.
973.06 977.36 SPEAKER_01 Как раз если вы хотите законтрибутировать компоненты 1С, у вас сейчас отличная возможность.
977.36 981.26 SPEAKER_01 Да, пока имя не заняли.
981.26 1011.14 SPEAKER_01 По компонентам есть ещё тоже breaking change, был такой confusion, что можно было, когда вы добавляете Redis, вы можете сказать, что вот эта штука использует Redis, в смысле что нам нужна серверная у хоста добавить, addRedis, означало, что нужно поднять Redis как бы контейнер например, а у проекта говорилось добавить Redis, означало, что это нужно добавить, ну по сути ссылка на ноги от Redis клиента, ну чтобы они друг к другу могли работать соответственно.
1011.14 1030.10 SPEAKER_01 Так вот теперь всё, что относится к клиентам, методы теперь называются addRedisClient, и соответственно это breaking change в том смысле, что экстеншн методы были тупо переименованы и поэтому если у вас раньше на билдере вызывался addRedis, теперь вы должны вызывать addRedisClient, пока они поменяются и не скомпилируются.
1030.10 1058.02 SPEAKER_01 Azure Improvement и там что-то про Azure Provision Library добавили, добавили возможность использования C# Object Model для того, чтобы оперировать Azure ресурсами, окей, помнишь я говорил, что в планах, по-моему 2 выпуска назад или 3 мы говорили, что планов по Google Cloud и AWS нету, короче теперь AWS Support есть.
1058.02 1062.16 SPEAKER_01 Официально от Микрософта?
1062.16 1072.18 SPEAKER_01 Не смотрел откуда, честно скажу, но это отдельный NuGet пакет, Aspire Hosting AWS, там CloudFormation поддержан, вот это все дела.
1072.18 1076.98 SPEAKER_01 Ну я сейчас не пойду в GitHub смотреть от кого это, но есть.
1076.98 1077.98 SPEAKER_01 Теперь короче AWS.
1077.98 1083.06 SPEAKER_01 Ну там может из Google занялись, Джон Скитт прибежал там, да.
1083.06 1084.06 SPEAKER_01 Кто-то принес.
1084.06 1096.58 SPEAKER_01 По большому счету там модель известна, вот это расширяемо все дела, поэтому написать провайдеров почему нет, и если Микрософт сказал, что у нас планов нет поддерживать, ну AWS чуваки может решили, мы сами тогда напишем, логично, да.
1096.58 1102.34 SPEAKER_01 Как мы говорили, AWS довольно часто бывает впереди Майкрософт с точки зрения поддержки каких-то дотунетных штук.
1102.34 1107.50 SPEAKER_01 И последнее, ну поменялось, собственно, в манифесты.
1107.50 1118.18 SPEAKER_01 Манифесты, я вам напомню, это некоторые текстовые описания того, что же вы там наконфигурили, вы можете из вашего C# кода в Aspire проекте изгенерить, собственно там ямлик или JSON, описание конфигурации.
1118.18 1127.42 SPEAKER_01 Ну вот я там рассказывал, что добавилась возможность настройки докер билда аргументов, там с волей работа по-другому идет.
1127.42 1133.34 SPEAKER_01 Ну вот эти все изменения как раз были отражены в манифесте и дополнительно добавили отдельным пунктом статью.
1133.34 1153.78 SPEAKER_01 В общем так, на самом деле Aspire Preview 5 прям хорошо обновился, много чего поменялось, вот, и посмотрим, посмотрим, что из этого получится, сколько превьюшек они успеют выпустить до, так сказать, следующего, до релиза.
1153.78 1157.82 SPEAKER_01 И что войдет в финальный релиз, тут прям интересно.
1157.82 1184.86 SPEAKER_01 Времени еще много, я думаю, как раз будут до осени пилить, как бы еще лето есть, ну и так как команда движется такими большими шагами, кажется, что все еще складывается впечатление, что они там единственные работают, потому что у нас еще вышел .NET 9 Preview 3, т.е. очередной превью вообще всей платформы, я думаю, что со всей платформы наскрести изменений получится намного меньше, чем у нас одна команда Aspire заделала.
1184.86 1189.50 SPEAKER_01 Ну, пойдемте посмотрим, что же у нас такого в Preview 3 есть.
1189.50 1201.74 SPEAKER_01 Опять же, никаких прорывных интересных фич нет, все мелкие какие-то оптимизации, доделки, припинки, в общем, пока нас не радует ничем, что можно было бы поставить как флагмана девятого .NET.
1201.74 1215.86 SPEAKER_01 В частности, в TimeSpan From добавился интересный override метод, если раньше у него был метод TimeSpan From, который принимает дабл-значение в качестве числа, в качестве значения.
1215.86 1224.94 SPEAKER_01 Я напомню, что TimeSpan – это какой-то промежуток времени, и все промежутки времени лучше указывать как раз-таки в TimeSpan, а не в каких-нибудь секундах, минутах или еще в чем-то.
1224.94 1229.86 SPEAKER_01 А он внутри себя уже конвертит в то, во что вам надо и из того главное, что вам нужно.
1229.86 1236.78 SPEAKER_01 И вот как раз-таки есть у него на перегрузочке один фабричный метод, который создает TimeSpan из дабла.
1236.78 1244.68 SPEAKER_01 И этот дабл интерпретировался как… Целая часть – это были секунды, а дробная часть – это якобы были миллисекунды.
1244.68 1246.60 SPEAKER_01 Но есть небольшая тонкость.
1246.60 1252.74 SPEAKER_01 Дело в том, что дабл – это не точное значение, это некоторые цифры в нем обозначаются приблизительными значениями.
1252.74 1263.06 SPEAKER_01 Ну, например, если вы задали значение 101.832, то в дабле такое число представляется приближенно.
1263.06 1278.90 SPEAKER_01 У вас создастся дабл, у которого будет 101 секунда, и при этом 831 миллисекунда, но не просто, а 831.99, и там дальше приближенные цифры, которые примерно вас приближают к тому значению, которое якобы попросил пользователь.
1278.90 1285.30 SPEAKER_01 Но пользователь явно передавал 832, и он надеялся где-то там в глубине души, что миллисекунд будет 832.
1285.30 1298.26 SPEAKER_01 И этот API, он сильно как бы настораживал пользователя и иногда даже приводил к багам, которые Microsoft в конце концов надоели, они приняли pull request от стороннего разработчика, который сделал нормальную понятную сигнатуру.
1298.26 1319.58 SPEAKER_01 Когда вы в TimeSpan, в метод fromSeconds, например, явно задаете параметрами, что вы хотите принять, т.е. сейчас вы можете указать первым параметром секунды – это 101, поставить запятую и, как положено, нормально, без всяких даблов и прочей глупости принять еще один int – это миллисекунды.
1319.58 1325.90 SPEAKER_01 И вот так с помощью двух параметров была решена эта мегаэпическая бага.
1325.90 1332.18 SPEAKER_01 Вот такие перегрузки есть не только для fromSeconds, но там и для дней, и для минут, и в принципе для всего остального тоже есть.
1332.18 1334.42 SPEAKER_01 Очень полезные перезагрузки.
1334.42 1350.58 SPEAKER_01 Из еще интересного у нас добавился наконец persistent assembly builder, он является сейчас в данный момент наследником от assembly builder, т.е. там вынесли некоторые методы из assembly builder, чтобы основную библиотечку не пачкать, в общем он теперь в отдельной библиотеке, а для чего эта штука?
1350.58 1360.86 SPEAKER_01 Штука, с помощью которой вы можете, используя пространство system reflection emit, можете динамически генерить сборку в рантайме.
1360.86 1366.18 SPEAKER_01 Т.е. если вы хотите собрать сборку, например, написать свой компилятор дотнет языка, почему бы и нет.
1366.18 1380.62 SPEAKER_01 Вы можете в памяти сделать сборку, иметь туда динамически какого-нибудь или кода, сделать запускаемый файл, сохранить его на диске и у вас получится нормальный экзешник с IL кодом, в который можно входить, выходить.
1380.62 1396.14 SPEAKER_01 В общем, для того, чтобы делать сборку, необходимы те же самые интерфейсы, которые у нас еще были в большом фреймворке, define_dynamic_module, define_type, define_method, write_IL и прочие стандартные type-builder, которые, наверное, всем, кто интересуется темой уже знакомы.
1396.14 1406.38 SPEAKER_01 В принципе, требовали довольно-таки давно эту штуку, прямо с самых первых версий dotnet core, как появился, но сделали именно только сейчас.
1406.38 1429.78 SPEAKER_01 Каких-то массовых использований, примеров использований наверное придумать так и не получится, но только если вы действительно пишете свой язык или пытаетесь в памяти сгенерить какой-нибудь оптимизированный метод или оптимизированный еще что-то, и при этом вам недостаточно генерации, то есть какие-то данные, которые у вас появляются только в рантайме, в compile-time вы их не знаете.
1429.78 1435.34 SPEAKER_01 В общем, может быть для таких каких-то извращенных вещей нужно это.
1435.34 1445.14 SPEAKER_01 Так дальше, улучшили работу с create_instance, да, у нас есть замечательный метод, активатор utils, у которого есть метод create_instance.
1445.14 1453.10 SPEAKER_01 В общем, этот create_instance знаменитен кроме того, что он очень медленный, он еще знаменит тем, что он умеет использовать специальный атрибут.
1453.10 1470.82 SPEAKER_01 В общем, представляете, у вас классик, у этого классика есть несколько конструкторов, и над одним из конструкторов можно повесить специальный атрибут, который называется activate_utilities_constructor, то есть теоретически подразумевается, что когда вы сделаете активатор create_instance, вызовется именно этот конструктор, который помечен атрибутом.
1470.82 1482.70 SPEAKER_01 Но это только в теории, в практике происходило совсем какое-то чудо, то есть мог вызваться не тот конструктор, который помечен атрибутом, а мог вызваться вообще конструктор без атрибута при соблюдении некоторых условий.
1482.70 1492.82 SPEAKER_01 Условие первое, у конструктора без атрибутов должно быть больше параметров, чем тот, который помечен атрибутом, и он должен по порядку находиться ниже после того конструктора, который помечен атрибутом.
1492.82 1499.82 SPEAKER_01 Вот, то есть вообще полностью какая-то магия, больше, конечно, похоже на багу, что кто-то линк в запрос по выбору конструкторов неправильно написал.
1499.82 1509.26 SPEAKER_01 И вот это поведение исправили, теперь, если помечен конструктор специальным атрибутом, то будет вызываться он и без всяких там дурацких как бы исключений.
1509.26 1519.86 SPEAKER_01 И, о, чудо, сие маленький эффикса ускорило в два раза создание объекта с помощью вызова метода Create Instance.
1519.86 1525.26 SPEAKER_01 Причем всего-навсего объекту, у которого три конструктора, на микробичмарках он показал ускорение в два раза.
1525.26 1527.46 SPEAKER_01 В общем, вот так вот оптимизируют люди.
1527.46 1539.54 SPEAKER_01 Секция Runtime тоже не плещет разнообразием, но зато тут есть такие хорошенькие прям оптимизации, хорошие изменения.
1539.54 1549.54 SPEAKER_01 Во-первых, улучшили, даже не улучшили, а перешли на новый подход к обработке исключений для Core CLR.
1549.54 1555.98 SPEAKER_01 И данный переход помог улучшить производительность от двух до четырех раз.
1555.98 1564.34 SPEAKER_01 Этот подход, новый подход к исключениям, он уже был опробирован в предыдущих превью, но вот как раз в третьем превью его включили по дефолту.
1564.34 1575.50 SPEAKER_01 То есть третий превью будет играть на всех исключениях, на всех сценариях, по какому-то новому подходу, который тоже мега-быстрый, мега-хороший и мега-своими стимс-нативо-аутом.
1575.50 1590.46 SPEAKER_01 Если вдруг это приводит к каким-то ошибкам, то есть у вас как-то приложение будет вести себя по-другому, можно, естественно, свитчнуться обратно, переключиться на старый, на Legacy Exception Handler.
1590.46 1601.58 SPEAKER_01 Другая интересная фича – это специальный инлайнинг для Shared Generic Methods.
1601.58 1605.24 SPEAKER_01 Сложно попытаться на это на словах описать, но давайте попробуем.
1605.24 1619.22 SPEAKER_01 Вообще нужно понимать, что инлайнинг для Рюджита – это самая эффективная оптимизация, которая сейчас есть, и поэтому команда Microsoft старается всеми возможными средствами найти какие-то общие шаблоны, которые используют разработчики для того, чтобы правильно их заинлайнить.
1619.22 1622.66 SPEAKER_01 И это дает самый большой буст, который только можно себе представить.
1622.66 1626.60 SPEAKER_01 И вот один из таких шаблонов был недавно поддержан.
1626.60 1634.90 SPEAKER_01 Этот шаблон интересен тем, что он использует для себя дженерики, и его дженерики там непросто было раньше инлайнить.
1634.90 1658.46 SPEAKER_01 Как типичный случай, если у нас вызывается какой-нибудь метод тест от T, то есть дженериковый метод, который внутри себя просто-напросто пилия направляет вызов на метод коли от T, а этот метод коли от T просто проверяет, что type of T равен, допустим, type от Int, то есть он сравнивает, действительно ли нам передали Int или не действительно нам передали Int.
1658.46 1668.42 SPEAKER_01 Во время компиляции такую штуку прооптимизировать сложно, наверное, потому что чему будет равен T, мы не знаем, мы это узнаем только, когда нас будут вызывать.
1668.42 1673.30 SPEAKER_01 И сейчас Рюджит научился такую штуку инлайнить.
1673.30 1674.30 SPEAKER_01 Что это значит?
1674.30 1685.22 SPEAKER_01 Это значит, что в севдокоде вот этот первый метод тест, он будет теперь вызывать не вложенный метод коли, а его содержимое в себя вставит.
1685.22 1694.90 SPEAKER_01 То есть, по сути, если мы вызовем тест от стринги, то есть тест от строки, его боди будет реализован как type of string = type of Int.
1694.90 1704.02 SPEAKER_01 И это значит, что вот это выражение type of string = type of Int, в этот момент Runtime его способен вычислить и он его способен упростить.
1704.02 1711.82 SPEAKER_01 Таким образом, он этот метод свернет в более простую операцию, что метод тест от стринг у нас будет просто возвращать false.
1711.82 1715.62 SPEAKER_01 Потому что он знает, что type of string никогда не будет равен type Int.
1715.62 1723.58 SPEAKER_01 И таким образом, вот этот inlining, в частности, он может просто заинлайнить и прооптимизировать, а иногда он может вычислить значения.
1723.58 1727.42 SPEAKER_01 И это, естественно, дает самую максимальную оптимизацию, то есть он просто возвращает константу.
1727.42 1732.74 SPEAKER_01 В общем, это тоже довольно частый случай и на практике реально используется.
1732.74 1741.46 SPEAKER_01 И что показали там страшные битчмарки, которых Микрософт держит целую кучу, что действительно во многих кейсах данная оптимизация увеличивает производительность довольно существенно.
1741.46 1759.38 SPEAKER_01 В SDK, то есть те инструменты, которыми пользуемся для билда, разработки и всего прочего, завезли в логер, в консольный, небольшой самурайзер, который в конце показывает сколько количества ошибок и количества варнингов было во время билда.
1759.38 1760.82 SPEAKER_01 Такая мелочь, но приятная.
1760.82 1776.42 SPEAKER_01 А SPNetCore добавил строго типизированные TypeResults, это когда мы говорим про Minimal API, помните, там есть MapGet и подобные Map методы, они могут возвращать результат из классика TypeResults.
1776.42 1787.10 SPEAKER_01 В этот TypeResults добавили InternalServerError, который вы теперь можете точно так же возвращать, если хотите зафиксировать какую-то ошибку внутри вашего приложения.
1787.10 1790.34 SPEAKER_01 В общем, такая тоже удобная маленькая мелочь.
1790.34 1795.58 SPEAKER_01 Немножко улучшили страницу с метаданными, страницу, которая называется Developer Exception Page.
1795.58 1815.38 SPEAKER_01 Это страница, которую вы, наверное, видели, если вдруг под дебагом у вас не возникало никакое исключение, и открывается такая приятная беленькая страничка, в которой вы можете потыкать, посмотреть Stack Trace, посмотреть там какой-нибудь логи, посмотреть какие-то дополнительные информации о вашем запущенном сервисе, в общем, каким-то образом первую диагностическую информацию получить.
1815.38 1825.62 SPEAKER_01 Так вот, у этой странички появился дополнительный раздел, который описывает Endpoint, то есть тот, по сути, Endpoint, который был вызван.
1825.62 1838.06 SPEAKER_01 На этом Endpoint часто разработчики навешивают какие-то вспомогательные атрибуты, описывающие метадату, например, producedResponseType, какой-нибудь route могут описать, или openAPI.Operation описать как-то подробнее в атрибутах.
1838.06 1848.58 SPEAKER_01 В общем, теперь на этой странице все вот эти метаданные, все вот эти атрибутики, они там показаны, чему они равны, потому что визуально тоже можно быстренько найти ошибку.
1848.58 1858.74 SPEAKER_01 Если вы добавили вдруг туда какой-то неправильный ResponseType, или почему-то у вас openAPI.Operation мог свалиться, то это тоже вам покажет быстренько, в чем могла бы быть проблема.
1858.74 1862.82 SPEAKER_01 Ну, для сладки, наверное, в некоторых ситуациях может быть полезно.
1862.82 1865.34 SPEAKER_01 Перейдем к команде Entity Framework.
1865.34 1879.58 SPEAKER_01 Здесь был добавлен auto-compilated modules, это такой режим Entity Framework, который позволяет вам автоматически регенерировать и оптимизировать модель, когда ваша модель меняется.
1879.58 1891.62 SPEAKER_01 То есть раньше вам нужно было перезапускать команду .NET EF DB Context Optimize каждый раз после того, как EF модель менялась.
1891.62 1897.94 SPEAKER_01 В общем, теперь этого делать не нужно, теперь EF такой умный, что он сам понимает, что модель поменялась, надо переоптимизировать.
1897.94 1904.18 SPEAKER_01 И добавился синтоксически сахар вокруг Hierarchy ID.
1904.18 1912.42 SPEAKER_01 Это в MS SQL отличный классик, который умеет представлять иерархические структуры данных в реляционной таблице.
1912.42 1920.18 SPEAKER_01 Так вот, у этого Hierarchy ID теперь можно более легко создавать новых челдов в вашей древовидной структуре.
1920.18 1922.90 SPEAKER_01 В общем, тоже такой приятный довольно-таки бонусик.
1922.90 1925.38 SPEAKER_01 Ну, вот как-то вот так вот.
1925.38 1930.82 SPEAKER_01 По мелочам наскребли на какой-то превью-3, в общем, нельзя сказать, что здесь что-то интересное, большое и важное.
1930.82 1933.42 SPEAKER_01 Ну, пока оптимизируют, добавляют, генерят.
1933.42 1942.06 SPEAKER_01 В основном, это, конечно, pull-реквесты были от сообщества, то есть ничего такого глобального Microsoft пока свой тренд, куда он направит девятку, нам не показал.
1942.06 1950.58 SPEAKER_01 В общем, ну, будем надеяться, так как это pull-реквесты от сообщества, будем надеяться, что настоящие разработчики Microsoft заняты чем-то большим и интересным, что нам в ближайшее время покажет.
1950.58 1959.58 SPEAKER_01 Да, мне вот всё больше и больше, с каждым новым превью мне всё больше складывается ощущение, что действительно команда работает над чем-то, что пока не показывает.
1959.58 1961.90 SPEAKER_01 Над чем, непонятно, но посмотрим.
1961.90 1962.90 SPEAKER_01 Может быть.
1962.90 1965.50 SPEAKER_01 С другой стороны, непонятно, а почему не показывают?
1965.50 1969.10 SPEAKER_01 Ну, то есть чего такого страшного, тут же нет никакой коммерческой тайны или ещё чего-то.
1969.10 1976.78 SPEAKER_01 Смотри, может быть, они работают над чем-то условно, ну, давай скажем так, вот был эксперимент про Async, про Green3D, помнишь?
1976.78 1977.78 SPEAKER_01 Решили, что делать не будем.
1977.78 1978.78 SPEAKER_01 Угу, да.
1978.78 1986.66 SPEAKER_01 Был эксперимент, мы в самом начале, так сказать, сезона DotNet 9 рассказывали про Async 2, то есть попытка сделать Async на уровне рантайма.
1986.66 1989.54 SPEAKER_01 Помнишь, да, поддержать их получше на уровне рантайма?
1989.54 1990.98 SPEAKER_01 Да, тоже хорошая идея.
1990.98 2003.22 SPEAKER_01 То есть, может быть, они сейчас над этим работают, просто это как бы не на две недели работы и показать что-то промежуточное просто невозможно, то есть им нужно как бы перебрелить пол рантайма и таки сделать, чтобы оно заработало.
2003.22 2008.26 SPEAKER_01 И когда заработает, ух, там к июлю, например, покажут, не знаю.
2008.26 2027.30 SPEAKER_01 Ну да, я согласен, что там дуракам пол работы не показывают, но всё же, знаешь, хотелось бы хоть какую-то статейку, мы занимаемся, мы думаем, мы туда планируем, если у вас там есть идеи, допустим, принесите, скажите, тоже было бы неплохо, потому что уже, блин, четвёртый месяц половина прошла, то есть уже через полгода релиз, а у нас как бы ноль практически новых фич.
2027.30 2029.30 SPEAKER_01 Ну да, интересно, непонятно.
2029.30 2030.30 SPEAKER_01 Ну, посмотрим.
2030.30 2059.74 SPEAKER_01 Тем не менее, помимо DotNet, обновилась Visual Studio, причём как-то обновилась тихо, без статьи, до 17.10 Preview 3, там особо больших изменений нет, какие-то улучшения вокруг Copilot, добавили штуку под названием Copilot Generated Breakpoint Conditions, то есть теперь, когда вы создаёте Condition Breakpoint, Copilot пытается угадать, с каким условием вы хотите его создать, смотря на код вокруг, может и угадывает.
2059.74 2077.42 SPEAKER_01 В SQL там что-то немножко улучшилось, если вы открываете какой-то большой солюшен и поняли, что вам он не нужен, ну не знаю, не на тот солюшен кликнули, то теперь можно отменить загрузку солюшена, там теперь работает, она по-моему, не помню, была или нет, но короче теперь работает кнопка cancel при загрузке солюшена.
2077.42 2097.66 SPEAKER_01 И самое, наверное, интересное, что появилось в Preview 3, но что почему-то не попало даже в официальный ченджлок, ну вот с неё, да, релиз ноутс, как хотите, на сайте Майкрософта, это такая супер превью фича, но видосик с ней я нашёл.
2097.66 2106.82 SPEAKER_01 Это называется, фича называется SLNX, то есть Майкрософт подступается к тому, чтобы изменить формат солюшен файла, значит.
2106.82 2114.14 SPEAKER_01 Вот это давно пора, блин, наконец-то, ну сколько можно-то, лет столько, и формат ужасный, терпим-терпим, а всё никак.
2114.14 2129.38 SPEAKER_01 Для того, чтобы включить эту фичу, нужно сходить, ну как обычно в настройки, там есть раздел Preview Features, она называется Use Solution File Persistence Model, вот как бы не догадаешься, что это про другой формат солюшен файла.
2129.38 2131.42 SPEAKER_01 Не, ну ты её там подбирать наугад и не должен.
2131.42 2132.42 SPEAKER_01 Ну да.
2132.42 2133.68 SPEAKER_01 То есть документацию от ключей наверняка возьмёшь.
2133.68 2144.10 SPEAKER_01 Дальше, соответственно, ты идёшь, ну как обычно в меню файл, говоришь Save As для солюшена, там можно сказать Save, можно Save As теперь, и выбрать… Только не говори, что JSON.
2144.10 2145.10 SPEAKER_01 Нет, XML.
2145.10 2146.10 SPEAKER_01 Ох, слава богам.
2146.10 2176.70 SPEAKER_01 Выбрать пункт, который называется XML Solution File, в результате у вас получается файлик, который называется SLNX, и вот в видосике, который я смотрел, там, соответственно, солюшен из трёх csproj, который в дефолтном варианте солюшен файла, ну так как он вот, все мы привыкли к этому странному формату, занимает, по-моему, строчек ну 30 минимум, в XML-ке он занимает ровно 5, на первый открывающий тег, а потом три строчки, значит, там, условно там.
2176.70 2182.14 SPEAKER_01 C# Project, и ссылочка на csproj, да, три раза повтори, и потом закрывающий тег.
2182.14 2183.14 SPEAKER_01 Всё.
2183.14 2189.74 SPEAKER_01 Больше там нет ничего, никаких там вот этого дебаг-релиз конфигурации, вот это всё, это всё сложность, ну, видимо, она дефолтная, да, она убрана.
2189.74 2196.70 SPEAKER_01 Понятно, что если ты всё там перенастроишь, то, скорее всего, это всё как-то появится, но пока этого ничего в видео не показали.
2196.70 2201.62 SPEAKER_01 Это, как они говорят, very-very-very first preview, прям very-very.
2201.62 2206.26 SPEAKER_01 Ну, поэтому, наверное, в чрезвычайных логах его нет, чтобы люди, как бы, раньше времени не радовались.
2206.26 2213.74 SPEAKER_01 Да, но при этом написано, в конце видео сказано, ну, Microsoft очень ждёт вашего фидбэка, поэтому расскажите нам.
2213.74 2215.42 SPEAKER_01 Very-very, ну вы с чем-нибудь скажите.
2215.42 2224.34 SPEAKER_01 В смысле, very-very мы в чрезвычайных логах не включим, но вот если вам случайно попалось видео на ютубе, то, как бы, расскажите нам фидбэк про это дело, ну, посмотрим.
2224.34 2230.94 SPEAKER_01 Не, ну, вообще это, конечно, безобразие просто, когда вводили новые csproj файлы, которые стали великолепны.
2230.94 2237.04 SPEAKER_01 Вспомним, что было раньше, когда мы там перечисляли все именно файлы, которые были только у нас в проекте, они же были ужасны.
2237.04 2241.44 SPEAKER_01 Опять же, мержи, конфликты, вот эти бранчи, это же, блин, куча ада было.
2241.44 2263.52 SPEAKER_01 И непонятно, почему они не затронули sln файл, потому что sln файл ещё ужаснее был даже в то время, да, потому что если там хоть какой-то xml был, хоть как-то это можно было семантически мержить и как-то с ним работать, то sln файл – это просто какое-то чудо, которое досталось нам из самых первых версий студии, и поэтому давно пора, давно пора, конечно, надо было сделать.
2263.52 2267.52 SPEAKER_01 Ну вот первый подход сделали, может, глядишь, и к девятке выпустят, нормально.
2267.52 2272.44 SPEAKER_01 Я чувствую, это будет наша самая большая киллер фича девятки.
2272.44 2273.44 SPEAKER_01 Возможно.
2273.44 2304.88 SPEAKER_01 А что ещё, зарелизилось громко сказать, но вышло в превью, и даже не в превью, а в бете версии 0.99, это некая штука под названием pl/.net, или pl/.net, и да, вы наверное правильно предположили, что если это pl/ что-нибудь, то это напоминает там всякий pl/sql, и вот это всё, и это действительно поддержка .net в качестве языка хранимых процедур в постгре.
2304.88 2319.44 SPEAKER_01 Неправильно сказал, не .net, а как языка .net, это не язык .net, это платформа, и это не зря, потому что в pl.net поддержано полностью c# и f# в качестве языка хранимых процедур.
2319.44 2322.92 SPEAKER_01 Ну, по идее, любой дотент, наверное, Visual Basic тоже там может затащить.
2322.92 2334.88 SPEAKER_01 Ну, наверное, я не уверен, что там компилятор просто есть правильный, то есть тут непонятно, я не настолько глубоко закапывался, как они там всё это компилируют и так далее, но в целом, может быть, может быть.
2334.88 2342.72 SPEAKER_01 Значит, это паблик бета-релиз, то есть он паблик, но он всё-таки бета, в прот пока тащить, наверное, не стоит.
2342.72 2347.76 SPEAKER_01 При этом он на вид, я не пробовал сам, но по описанию он довольно-таки развесистый.
2347.76 2366.72 SPEAKER_01 Они поддерживают все, соответственно, плюс-минус, ну почти все, так скажем, операции для хранимых функций, процедуры, всякие триггеры, рекорды, аут-ин-аут, тейбл-фанкшнс, то есть можно писать всякие тейбл-вэлют, фанкшнс, вот это всё.
2366.72 2375.32 SPEAKER_01 Они нативно поддерживают 40 из 46 стандартных юзер-тайпов в пазгре.
2375.32 2401.84 SPEAKER_01 Эта штука полностью NPG SQL-компатибл, NPG SQL, напомню, это довольно популярный драйвер для пазгре SQL на дутнете, и по сути, как я понимаю, эта штука просто построена на базе NPG SQL, то есть они наружу вставляют тот же интерфейс, что выставляет NPG SQL, то есть вы по сути можете всё, что работает через NPG SQL спокойно использовать с этой штукой.
2401.84 2421.44 SPEAKER_01 А внутри они перехватывают вызовы NPG SQL, то есть то, что раньше NPG SQL делал собственно через connection к пазгре, здесь они его перехватывают, громко сказано, там написана соответствующая проксия, я так понимаю, которая делает уже нативные просто вызовы прямо внутри пазгре, вот, и всё прекрасно работает.
2421.44 2435.88 SPEAKER_01 Значит, по их бенчмаркам C# и F# сейчас являются наиболее быстрыми языками для написания хранимых процедур на пазгре, так что если вам нужна производительная хранимая процедура, пишите на C# и F#, но напоминаю, вправду пока не надо.
2435.88 2450.96 SPEAKER_01 Дальше очень забавная фраза, что все фичи, даже в английском это читать, что all features are fully tested for both C# и F# с помощью, как ты думаешь, скольких юнит тестов?
2450.96 2452.48 SPEAKER_01 Не знаю, 10?
2452.48 2453.48 SPEAKER_01 Ну, 1013.
2453.48 2458.68 SPEAKER_01 Для всего 1000, ну, в принципе, нормальное число, почему нет?
2458.68 2482.64 SPEAKER_01 Ну, не знаю, ну как-то вот, когда они говорят, что мы поддерживаем, и там functions and procedures, DO, SPI, triggers, records, SRF, out and out, table functions, 40 из 46 стендарт юзертайпов, там на одни юзертайпы, мне кажется, легко там 200-300 юнит тестов можно набрать, вот, и при этом типа all features fully tested для двух языков, всего на 1000 юнит тестов, ну не знаю, не знаю, как-то.
2482.64 2492.00 SPEAKER_01 Ну посмотрите, я же надеюсь, там вряд ли там всю пропаздглю перетестировали, ведь у нее же там, ну, у нее есть стандартный способ для того, чтобы подключать языки программирования.
2492.00 2493.00 SPEAKER_01 Это понятно, да.
2493.00 2496.88 SPEAKER_01 Скорее всего, там просто этот адаптер перетестировали, да и все.
2496.88 2497.88 SPEAKER_01 Да, ну все равно, как-то много.
2497.88 2500.72 SPEAKER_01 Не, ну с другой стороны, понятно, что как бы прикольно.
2500.72 2513.86 SPEAKER_01 Плюс они, я так понимаю, переиспользовали как раз юнит тесты из NPG SQL, то есть у нас же есть тесты на NPG SQL, что если бы ты там, не знаю, создал команду, выполнил релекс, условно говоря, то тебе вернулось то-то и то-то.
2513.86 2516.64 SPEAKER_01 А теперь у тебя тот же тест, только он работает уже внутри PassGrid.
2516.64 2521.64 SPEAKER_01 Ну и тем более, если NPG SQL хватило, значит и этой штуки вполне должно хватить.
2521.64 2523.48 SPEAKER_01 Ну может быть, может быть.
2523.48 2527.92 SPEAKER_01 По лицензии это стопроцентный фри софтвер под PassGrid лицензии.
2527.92 2532.94 SPEAKER_01 Так, так, так, так, NPG SQL, все такое, максимум компатибилити.
2532.94 2536.28 SPEAKER_01 Да, кроме… Но это не Microsoft, да?
2536.28 2542.24 SPEAKER_01 Не, не, это не Microsoft, это какие-то другие ребята PassGrid, я так понимаю, где-то вокруг PassGrid.
2542.24 2556.08 SPEAKER_01 NPG SQL, кроме вот этого перехвата, собственно, вызова, был не модифицирован, и вот они говорят, что we imported NPG SQL test suite as stored procedures, то есть, короче, все юнит тесты — это тоже хранимые процедуры.
2556.08 2558.00 SPEAKER_01 На дотнете.
2558.00 2560.60 SPEAKER_01 На дотнете, да.
2560.60 2569.72 SPEAKER_01 И, короче, тестируют в том числе весь test suite внутри PassGrid, как хранимые процедуры, но прикольно.
2569.72 2570.72 SPEAKER_01 Ну, нормально, нормально.
2570.72 2571.72 SPEAKER_01 Прикольно.
2571.72 2581.04 SPEAKER_01 Вот они пишут, что у нас не поддержаны пока multi-range и NAMI, и Composite Table Types, но мы надеемся, что мы скоро их добавим.
2581.04 2598.52 SPEAKER_01 Короче, надо последить, я, конечно, не знаю, насколько там много народу будет программировать на дотнете внутри PassGrid, но это интересная ниша, особенно, если там действительно хорошая производительность, хотя, наверное, по старинке, много кто на SQL будет просто писать.
2598.52 2600.32 SPEAKER_01 Ну, наверное, да.
2600.32 2610.16 SPEAKER_01 Мы программировали, кстати, на дотнете и под MS SQL, да, те, кто знают, что в MS SQL такая поддержка появилась, я не знаю, наверное, с первых дотнетов, вот где-то там в циферах версий.
2610.16 2625.76 SPEAKER_01 Да, там был поддержан dotnet 3.5, и он так и был поддержан очень долгое время, там у нас был кусочек кодек, по-моему, три сборки, которые специально компилировались в 3.5 ради этого, потому что только 3.5 был поддержан на той версии SQL, на которой мы исполнялись.
2625.76 2650.44 SPEAKER_01 Ну вот, и это не такая безумная идея, как может показаться, потому что в дотнете очень много полезных вещей, там те же самые, если криптографию вам нужно встроить куда-нибудь из сохранимых процедур вызывать, или, например, мы некоторые функции переделывали, не SQL функции вызывали, а именно дотнеты функции, например, там соединить строку, посчитать хэш, еще что-нибудь, потому что на дотнете это выходило там в тысячу раз быстрее, чем ту же самую бодягу наводять на SQL.
2650.44 2691.84 SPEAKER_01 Мы считали хэши, и мы на самом деле на таких вот простых процедурах писали свое версионирование, то есть мы принимали некоторые объектики, да, и там гораздо проще было написать вот эти все, там, если объект присутствует, то, типа, создай новую версию, значит, инкрементив там колоночку вершин, да, старую пометь, что она абсолютная, а вот эту теперь пометь, что она последняя, ну, короче, там было некоторое количество нетривиальной логики, что можно было сделать, а еще, типа, скопируй дочерние таблички, чтобы у них было теперь, значит, тоже traceability, вот это все, чтобы старые значения остались, в общем, там была довольно, да, развесистая логика вот этого умного версионирования.
2691.84 2705.16 SPEAKER_01 Ну, то есть, смотри, как минимум две ниши мы нашли, да, если у вас какая-то сложная логика, которую вы почему-то хотите затащить в таблице, и если вам нужен перформанс, то даже нативные SQL-функции есть смысл попробовать переписать на дотнет, и это вполне может быть быстрее.
2705.16 2716.04 SPEAKER_01 Ну, то есть, ниша вполне хорошая, опять же, но не нужно забывать, что это хранимые процедуры, и хранить логику в хранимых процедурах – всё ещё плохая практика.
2716.04 2718.56 SPEAKER_01 Поэтому здесь нужно внимательно соблюсти баланс.
2718.56 2719.56 SPEAKER_01 Ну да.
2719.56 2724.40 SPEAKER_01 Но начинание интересное, последим, насколько это будет пользоваться хоть какой-нибудь популярностью.
2724.40 2736.08 SPEAKER_01 Да-да, приятно, что эта каталза есть, ну, то есть, это намного лучше, чем если бы её не было, потому что иногда действительно возникают какие-то случаи, когда надо что-то сделать, и вот, когда у тебя есть возможность, это прекрасно.
2736.08 2737.08 SPEAKER_01 Отлично.
2737.08 2738.08 SPEAKER_01 Ну давай дальше.
2738.08 2741.92 SPEAKER_01 Так, дальше я бы хотел рассмотреть технологию радар.
2741.92 2753.20 SPEAKER_01 В общем, такая немножко необычная тема в нашем подкасте, потому что технология радар раньше довольно много всего писала про дотнет, в общем, там какие-то лохматые времена, там половина фреймворка были про дотнет.
2753.20 2762.24 SPEAKER_01 Но я так понимаю, что компания Throatworks, которая выпускает этот обзор, этот радар, она уже от дотнета давно ушла.
2762.24 2774.04 SPEAKER_01 Но тем не менее, если мы не сосредоточимся на каких-то языковых инструментах, там всегда можно почерпнуть чего-то полезного и интересного.
2774.04 2778.72 SPEAKER_01 Вот я предлагаю нырнуть и посмотреть, а что же такого для нас там может быть полезного.
2778.72 2789.88 SPEAKER_01 Если кто не знает, то технология радар – это специальный отчёт, который компания Throatworks выпускает дважды в год.
2789.88 2804.60 SPEAKER_01 И она рассказывает про какие-то технологии, платформы, языки, фреймворки, которые сейчас или в тренде, или уже давно используются этой компанией, или, может быть, эта компания уже отказывается от них, считая какие-то подходы легоси.
2804.60 2811.92 SPEAKER_01 И приятно смотреть, потому что компания у них очень большая, она знаменита тем, что там работают Мартин Фаулер и Нил Форд.
2811.92 2817.04 SPEAKER_01 И очень полезно смотреть на те инструменты, которыми они используются.
2817.04 2823.32 SPEAKER_01 И хотя бы для развития кругозора, мне кажется, каждому полезно хотя бы обзорно посмотреть на те названия, которые там есть.
2823.32 2828.44 SPEAKER_01 И вот в апреле вышел как раз очередной отчёт, и давайте же посмотрим, что там в нём есть интересного.
2828.44 2834.60 SPEAKER_01 Традиционно этот журнал делится на несколько секций, и первая секция – это техникс.
2834.60 2844.12 SPEAKER_01 В этой секции собраны инструменты, которые рассказывают о том, какие полезные практики можно было бы внедрить или использовать в ваших командах.
2844.12 2847.68 SPEAKER_01 И одна из таких практик – это Continuous Compliance.
2847.68 2863.48 SPEAKER_01 Continuous Compliance – это как раз такие предположения о том, что различные регуляторные какие-то правила и секьюрити-стандарты смотреть время от времени – это плохая практика.
2863.48 2870.64 SPEAKER_01 Когда к вам пришёл какой-нибудь секьюрити-аудитор раз в год, выдал вам какой-то отчёт, и вы радостно его там пофиксили, и ещё на целый год забыли.
2870.64 2877.52 SPEAKER_01 В общем, это не очень правильно, потому что приводит к замедлению разработки.
2877.52 2886.48 SPEAKER_01 То есть разработчики начинают всё-таки после того, как они все дырки пофиксили, они начинают писать снова эти дырки, и они снова появляются.
2886.48 2890.66 SPEAKER_01 И таким образом вы вносите, опять же, секьюрити-уязвимость в ваш код.
2890.66 2891.96 SPEAKER_01 В общем, это плохо.
2891.96 2897.36 SPEAKER_01 А потом, когда приходит аудит, вам приходится напрягать разработчиков для того, чтобы они эти дыры фиксили.
2897.36 2901.82 SPEAKER_01 Поэтому получается уменьшение скорости разработки в эти моменты.
2901.82 2914.44 SPEAKER_01 И подход Continuous Compliance подразумевает то, что мы можем подойти к секьюрити всяким аудитам, как мы подошли к нашим обычным пайплайнам, как мы подошли к тестам.
2914.44 2915.44 SPEAKER_01 Что мы сделали?
2915.44 2927.04 SPEAKER_01 Мы просто-напросто в пайплайн засунули специальные инструменты, которые проверяют у нас, что код хорошо отформатирован, что там соблюдены все правила анализаторов, что у нас там проходят тесты и так далее, и так далее.
2927.04 2932.76 SPEAKER_01 То есть это нас доляет весь пайплайн Continuous, который не позволяет нам просто-напросто залить плохой код.
2932.76 2936.16 SPEAKER_01 И таким образом мы и решаем стандартно подобные проблемы.
2936.16 2946.40 SPEAKER_01 Вот то же самое Continuous Compliance предлагает делать и для секьюрити аудитов, и для каких-то регуляторных правил, и для прочих стандартов, которым должны соответствовать ваш код.
2946.40 2973.48 SPEAKER_01 И хорошими входными точками для того, чтобы ваш код сделать более прекрасным, это является поддержка СБОМа, это Software Bill of Materials, то есть специальные отчеты, которые рассказывают о том, от каких версий и от чего вообще зависит ваше программное обеспечение, и САЛЬЦА – это Supplying Chain Level of Software Artifacts, в общем тоже есть такие два стандарта, в принципе о них подробнее, полно материала в интернете, можно почитать.
2973.48 2981.72 SPEAKER_01 В общем полезно в вашем коде сделать такой пайплайн, который будет эти отчеты поддерживать, генерировать и какими-то тулзами следить за их соответствием.
2981.72 2986.76 SPEAKER_01 Далее, полезная практика, еще одна – это секьюрити чемпионы.
2986.76 3020.36 SPEAKER_01 Это такая интересная идея, что в команде очень полезно заводить специальных людей, которые интересуются безопасностью, которые могут с точки зрения хоть технической безопасности, хоть не технической, не суть важна, которые очень хорошо понимают все какие-нибудь гайдлайны, которые понимают все секьюрити и реквайерменты, и которые могут командам во время разработки изнутри все это доносить, то есть там почему похоронить пароли в открытом виде – это плохо, почему вот HTTP выставлять наружу – это плохо, HTTPS – хорошо, в общем все это внутри команды доносить.
3020.36 3027.04 SPEAKER_01 Тут важно отметить, что это не какая-то отдельная роль, чтобы вы опять это не переслал в какой-нибудь девопс или в чем-то в этом духе.
3027.04 3032.52 SPEAKER_01 Это тот же самый разработчик, который сидит в команде, но просто в сферу интересов входит еще и секьюрити.
3032.52 3048.84 SPEAKER_01 В общем, и есть очень много практик, как рождать внутри команд вот таких секьюрити чемпионов, и чем они могут как бы помочь команде – тем, что они повышают как раз безопасность каждого компонента, который разрабатывает команда.
3048.84 3056.92 SPEAKER_01 Именно следите за этими аспектами, они будут лекции какие-то внутри команды читать, которые расскажут, почему секьюрити – это хорошо и так далее, и так далее.
3056.92 3061.68 SPEAKER_01 Это тоже отличная практика, вводить таких секьюрити чемпионов внутри команды, взращивать их или леять.
3061.68 3064.72 SPEAKER_01 Следующая секция – это платформы.
3064.72 3066.72 SPEAKER_01 Что же у нас интересного есть среди платформ?
3066.72 3074.28 SPEAKER_01 Я выделил несколько инструментов, в частности это Cloud Events, мы уже немножко упоминали о них, если вы слушаете наши подкасты.
3075.16 3089.00 SPEAKER_01 Тот issue на GitHub, который взбудоражил все open-source-сообщество, когда Microsoft заявил, что хочет переписать все мастранзиты и сервис-басы, и рэббиты, но на самом деле нет, это как раз был про Cloud Events.
3089.00 3101.56 SPEAKER_01 Это спецификация, которая описывает, каким образом вы можете описать события, передаваемые между разными там сервисами, платформами, системами, то есть это такой стандарт для передачи событий.
3101.56 3119.60 SPEAKER_01 Очень давно нашей индустрии такого стандарта не хватало, были попытки еще в самые времена эти стандарты описать, но они были слишком сложными, как бы не соответствуют современным веням, когда хипстеры не способны осилить 10 строчек в XML, им нужно 50 строчек в JSON.
3119.60 3137.56 SPEAKER_01 В общем, и вот этот стандарт как раз про них, как описать доменные ивенты, что там должно быть, какие поля, как принимать, как посылать, и кажется, что это очень крутая штука, потому что она как раз способна помирить вот эти все миры со всякими кавками, рейбитами, нацами и прочими ивент-дривен подходами.
3137.56 3145.56 SPEAKER_01 Как это, наверное, в свое время сделал HTTP, даже не HTTP, а REST API, как это сделал REST API?
3145.56 3189.40 SPEAKER_01 Многие его ругают, и мы в том числе в нашем подкасте обсуждали его плюсы и минусы, но нельзя отрицать главного, он ввел некий стандарт, поэтому даже там какой-нибудь самый заходолый сайтик, самый заходолый сервис или приложение, соответствующее этому стандарту, уже воспринимается как манна небесная, потому что вы можете этот сервис вызвать, вы можете какими-то понятными заголовками обменяться, какую-то непонятную идентификацию произвести, и вот такого стандарта как раз не хватает для обмена сообщениями, и вот Cloud Events, кажется, что это именно то, что нам нужно, это именно такой стандарт, он настолько прекрасен, что его можно применять даже не общением между сервисами и платформами, а как доменные ивенты, то есть даже внутри общения одного приложения между своими различными компонентами.
3189.40 3195.40 SPEAKER_01 В общем, будем следить за этим стандартом, я думаю, мы еще не раз про него поговорим.
3195.40 3221.96 SPEAKER_01 Следующий прекрасный инструмент – это Pulumi, очень неновый инструмент, в принципе, отличная тула, она помогает вам сделать альтернативу терраформу, она помогает вам определить вашу инфраструктуру как код, то есть вы прямо в коде пишете, чего вам нужно, какую инфраструктуру, кого поднять, как зарегистрировать, куда сходить, и вот это вот все описываете на стандартном коде.
3221.96 3245.52 SPEAKER_01 Ну, самое прекрасное в коде в коде в коде в том, что этот код может быть на различных языках программирования, в частности, на C#, то есть там такая интересная инфраструктура, когда вы пишете на C#, он все вызовы вашего C# интерпретирует и складывает в какую-то целевую платформу, а целевая платформа может быть практически абсолютно любая, то есть она поддерживает все клауд-платформы, которые там существуют.
3245.52 3266.48 SPEAKER_01 Немножко похоже на Aspire, когда вы на Aspire пишете C# код, а он вам потом это выдает или в конфиг-файле для Kubernetes, или для AWS, или для Azure, вот, в принципе, почти то же самое делает и Polymer, но Polymer это делает более низкоуровневым, то есть более на уровне инфраструктуры.
3266.48 3272.72 SPEAKER_01 В общем, тоже классная вещь, надо тоже по ней как-нибудь подробнее поговорить.
3272.72 3287.16 SPEAKER_01 Еще стоит упомянуть, что Docker Desktop сменил лицензию, не то чтобы совсем сейчас, но так как отчет выпускается раз в полгода, то как раз сейчас мы застали этот момент в этом отчете, в радаре.
3287.16 3322.16 SPEAKER_01 Docker Desktop сменил лицензию не очень дружелюбно для коммерческих компаний, поэтому многие компании от Docker Desktop отказываются, и как раз авторы советуют отказываться в сторону Rancher Desktop, это open-source приложение полностью свободное, с нормальной лицензией, запускается точно так же на рабочих столах под всеми операционными системами, и практически интерфейс там слабо отличима от Docker Desktop, то есть как бы запустить контейнерники, посмотреть логи и вообще глянуть, что творится в вашей системе с точки зрения контейнеров, в нем точно так же визуально красиво можно легко и просто.
3322.16 3348.12 SPEAKER_01 Следующая секция – это инструменты, и в инструментах хочется отметить Bruna, мы как раз, по-моему, в прошлом подкасте его упоминали, это open-source Desktop-альтернатива для Postman и Insomnia, как раз Postman тоже сменил лицензию, сейчас у нас какой-то обвальный шквал смены лицензии с хороших на плохие, но, слава богам, появляются как бы новые open-source-альтернативы, и вот как раз Bruna – это хорошая open-source-альтернатива для Postman.
3348.12 3375.96 SPEAKER_01 Кратко напомню, что это инструмент для тестирования и отладки API, но в отличие, например, от всех вот этих новомодных Postman, он не пытается засунуть в вас свое облако и не хранит там какие-то свои запросы, все запросы хранятся локально в вашей файловой системе, и прелесть этого подхода в том, что вы можете использовать гид, т.е. для всех ваших запросов есть профессионирование, брончевание, ревью и т.д. по списку, в общем, это, мне кажется, самое идеальное решение, храните все на файловой системе, все остальное сделают сторонние инструменты.
3375.96 3406.68 SPEAKER_01 Еще из Tools хочется упомянуть, это Microsoft XBOM Tool, это вот, как я раньше говорил про Security Compliance, полезно нам хранить, т.е. полезно генерировать и проверять на соответствии всяким Tools of Material, и вот как раз Microsoft выпустила Open Source инструмент, который может генерировать вот этот формат, в частности SPDX, совместимый формат для XBOM.
3406.68 3423.64 SPEAKER_01 Он поддерживает различные Package Managers, т.е. вы можете там и питоновские, точно так же проекты проанализировать и NPM-овские и много чего еще, т.е. они не заточены под какой-то один отдельный язык, он все зависимости прекрасно воспринимает.
3423.64 3435.52 SPEAKER_01 И он может легко быть встроен в ваш CI/CD pipeline, т.е. вот это как раз тот инструмент, с помощью которого можно попробовать выполнить рекомендации по Continuous Compliance.
3435.52 3479.80 SPEAKER_01 Еще хочется упомянуть, что про OLAMU, тоже, по-моему, в одном из последних выпусков мы обсуждали, что если вы вдруг хотите настроить себе Large Language Model какой-нибудь, неважно для чего, для генерации картинок или для IntelliSense в коде, или для генерации Blazor-компонентов, которые как раз были нашим примером в прошлом выпуске, в общем, и вы не хотите завязываться на какой-то Cloud или на какого-то коммерческого провайдера, вы можете на своих ресурсах организовать подобную систему, и этому как раз помогает OLAMU, это специальный engine, который разворачивается там, где вы скажете, хоть на локальной машине, и он поддерживает множество популярных моделей, таких моделей там сотни просто.
3479.80 3491.20 SPEAKER_01 Это является такой оболочкой над этими моделями, эти модели легко подключаются, и вы можете любую из них использовать в зависимости от того, сколько у вас там есть свободных памяти и процессора.
3491.20 3501.60 SPEAKER_01 Как только вы поставили OLAMU, вы к ней можете обращаться с помощью командной строки, API или SDK для того, чтобы общаться каким-то образом с этими моделями, в общем, все доступные способы там есть.
3501.60 3530.96 SPEAKER_01 Я выбрал вот один единственный инструмент, который касается artificial intelligence, машин леарнинга, но на самом деле там, не знаю, наверное, уже больше 50%, наверное, 70% всего технологии радара пестрит в том или ином виде AI-шными всякими абзацами, т.е. там уже пробраться нормальному, хардкорному разработчику без каких-нибудь AI-моделей, генерейтед и всего прочего, в общем, пробраться по радару уже становится сложно.
3530.96 3539.72 SPEAKER_01 Но вот некоторые такие инструменты, которые могут быть полезны вам в обычной работе, я все-таки нашел, выцепил, надеюсь, кому-то пригодится.
3539.72 3547.84 SPEAKER_01 Так а там еще раньше была секция languages, frameworks, там у нас какие, никаких модных, новых, правильных языков?
3547.84 3548.84 SPEAKER_01 Нет?
3548.84 3549.84 SPEAKER_01 Нет?
3549.84 3550.84 SPEAKER_01 Ничего такого?
3550.84 3557.76 SPEAKER_01 Секция languages, frameworks, они остались, но ничего интересного для C# там нет, потому что там в основном Rust, Go, Python и вот эти прочие вещи.
3557.76 3568.28 SPEAKER_01 И они, так как это секция languages, в основном нацелены на то, как удобно разработчикам из этих языков как бы чувствовать себя в этой экосистеме, ну нам там в принципе делать нечего.
3568.28 3569.28 SPEAKER_01 Понятно.
3569.28 3570.28 SPEAKER_01 Ну ладно, хорошо.
3570.28 3579.32 SPEAKER_01 Посмотрим, может быть, какой-нибудь Gartnet, про который мы говорили в прошлый раз, или еще кто-нибудь пробьется когда-нибудь от Microsoft туда.
3579.32 3587.96 SPEAKER_01 Ну может быть, может, тем более там Redis такую лицензию плохую сделал, так что должен радар как-нибудь это обозреть.
3587.96 3588.96 SPEAKER_01 Да.
3588.96 3605.40 SPEAKER_01 Ну давайте уже, собственно, сегодня будем потихонечку сворачиваться, у нас осталось еще 2 таких, 2 таких небольших темки, это, во-первых, кратко о разном, тут хочется рассказать про, с моей стороны, про 3 новости, новость номер 1.
3605.40 3621.22 SPEAKER_01 Мы много раз говорили за время, там, семерки и до Дотнета восьмерки, про то, что Canonical активно работает с Microsoft для того, чтобы собирать свой собственный Дотнет, вот это все из исходников, несколько раз обсуждали Reproducible Pills и вообще как оно все собирается.
3621.22 3635.26 SPEAKER_01 Так вот, начиная с мая 24 года, для снапов, то есть это способ, как распространяются Дотнет-дистрибутивы в Canonical, собирать Дотнет будет сам Canonical.
3635.26 3673.30 SPEAKER_01 То есть, Microsoft больше туда не будет ничего собирать, Canonical сам будет брать исходнички, все собирать и все такое, есть единственные ограничения, два ограничения, во-первых, Canonical не собирает, так скажем, патч-версии SDK, то есть, напомню, что первая версия SDK всегда выходит с постфиксом точку 100, ну или там 100 что-нибудь, а вот дальше фича-патчи всякие, 200 что-нибудь, 300 что-нибудь, вот они туда не будут пока, по крайней мере, попадать, а второе туда не будут попадать Дотнет-9 превью, то есть, туда пока только стабильные версии восьмерка попадать будут.
3673.30 3678.14 SPEAKER_01 Ну, посмотрим, по крайней мере, это некоторый первый шаг к тому, чтобы Дотнет SDK собирался не Майкрософтом.
3678.14 3683.50 SPEAKER_01 Ну то есть, уже какой-то понятный инварьмент они для этого подготовили, я имею в виду Майкрософт, да?
3683.50 3684.50 SPEAKER_01 Да.
3684.50 3686.50 SPEAKER_01 Чтобы сторонняя какая-то компания могла без зрения совести стабильно это все забирать.
3686.50 3694.86 SPEAKER_01 Да, напомню, это все живет в репозитории dotnet/dotnet, если я правильно помню, там как раз-таки единая система сборки для всего.
3694.86 3740.26 SPEAKER_01 Дальше, мы довольно давно не обсуждали всякие планы райдера или шарпера, ну там какие-то такие инкрементальные изменения, какие-то UI что-то фиксит, ну то есть, не попадалось просто на глаза и в выпуске не попадало, но тут попалась статья, вышел EAP, какой-то очередной EAP райдер и там появилась штука, которая может быть интересной и полезной, это monitoring tool, если вы когда-нибудь запускали ваш код Visual Studio, вы видели, что справа автоматически появляется такое окошечко, где ползет memory usage вашего приложения, там эти флажки exception вставятся, CPU usage, можно посмотреть, вот такая же штука теперь есть в райдере, плюс она позволяет снапшота создавать, который сразу же откроется там в dotmemory/dottrace, так что если вы пользуетесь райдером, гляньте последний EAP, там довольно приятно эта штука работает.
3740.26 3785.62 SPEAKER_01 Ну и последняя, третья новость, это MSTSSDK, несмотря на то, что NUnit и XUnit в целом наверное, ну наверное будет правильно сказать доминируют, но если я помню правильно просто такое overflow, то 4% в 15-20 было все еще за MSTest, хотя может быть я преувеличиваю значимость MSTest, но в общем теперь есть штука под названием MSTest, MSTest SDK, которая позволяет вам гораздо более просто создавать юнит тестовые проекты и гораздо проще их запускать, используя штуку, которую они тоже недавно заинтродировали под названием MSTest Runner, это стендаловое приложение, которое позволяет либо запустить ваши тесты, либо скомпилировать ваши тесты в стендаловом приложении.
3785.62 3793.62 SPEAKER_01 В общем, если вы все еще почему-то по какой-то причине до сих пор сидите на MSTest, ну мало ли так сложилось, посмотрите, может быть вы здесь что-то полезное себе найдете.
3793.62 3818.94 SPEAKER_01 Слушай, я тебе могу сказать причину, потому что MSTest это чуть ли не единственное приложение, которое позволяет писать тесты для native auto, и для этого есть там отдельная статья, то есть у MSTest отлично тестируют native auto, также он умеет делать код coverage для него, и там все это делается в несколько флажочков, там естественно поддержано все не полностью, но… Подожди, а в чем смысл тестирования native auto?
3818.94 3831.06 SPEAKER_01 Ну, не native auto ты тестируешь, а код, который компилируется под native auto, потому что он нативный, у него нет reflection, ты не можешь оббежать там все файлики, допустим, собрать, например, с помощью атрибутов там какие-нибудь.
3831.06 3833.82 SPEAKER_01 А, ну типа тест-классы, да, не можешь.
3833.82 3834.82 SPEAKER_01 Да, тест-классы.
3834.82 3835.82 SPEAKER_01 Согласен.
3835.82 3853.48 SPEAKER_01 А плюс ты, наверное, еще, да, я понял, где еще может быть полезно, потому что в native auto, как известно, у нас там может не работать какой-нибудь тот же reflection, да, либо еще что-нибудь, код генерации, и это способ проверить, что, например, во всех ваших, ну всех, понятно, может быть не покроете, но в основных ваших путях нет таких фич.
3853.48 3856.74 SPEAKER_01 Ну что, приложение действительно заработает из native auto?
3856.74 3877.90 SPEAKER_01 Да, вот еще интересная фишка есть у этого тестирования native auto, что если ты заскипал тест, то генерируемый код должен понять, что данный, в данном приложении данный код никем не используется, да, то есть он используется из-за внутри теста, который заскипан, значит, он никем не используется, значит, его триммер может заоптимизировать и вообще выкинуть из приложения.
3877.90 3879.74 SPEAKER_01 Вот такие фишки еще может поддерживать.
3879.74 3880.74 SPEAKER_01 Прикольно.
3880.74 3881.74 SPEAKER_01 Ну да.
3881.74 3901.90 SPEAKER_01 В общем, там много всяких хаков интересненьких, да, вот в общем, как бы вот так, от xunit я такой поддержки не слышал, не знаю, насколько она там есть живая или разрабатывается, а, ну разрабатывается она точно, я с прошлого года видел ishi, но, по-моему, ishi еще открыт, и поэтому, опять же, насколько там это полно или не полно, непонятно.
3901.90 3903.58 SPEAKER_01 Ну и наличие ishi не означает, что оно разрабатывается.
3903.58 3906.18 SPEAKER_01 Ну ладно, по крайней мере, авторы не знают.
3906.18 3907.86 SPEAKER_01 Ну да, в общем, так.
3907.86 3908.86 SPEAKER_01 Хорошо.
3908.86 3917.56 SPEAKER_01 Действительно, надо покопать, а насколько нужна какая-то поддержка отдельная NetEva Auto, ну, в общем, некоторые фишки, которые NetEva Auto предоставляет, действительно, нужно специально поддерживать.
3917.56 3922.10 SPEAKER_01 Но может быть это какая-то блашь, и, может, давайте все полнее без нее.
3922.10 3923.10 SPEAKER_01 Окей.
3923.10 3925.66 SPEAKER_01 Но у меня все в этой части.
3925.66 3946.10 SPEAKER_01 Тогда я еще вброшу один интересный github репозиторий я нашел, который называется JSON Everything, это замечательная задумка, автор делает различные JSON надстройки над стандартным системтех-джессоном, который нам выдал Microsoft, чего не хватает стандартному системтех-джессону.
3946.10 3951.42 SPEAKER_01 На самом деле, очень много всего, если мы выйдем за рамки простой стилизации и дистилизации.
3951.42 3954.66 SPEAKER_01 Самое главное, чего обычно людям не хватает, это джессон-схемы.
3954.66 3960.46 SPEAKER_01 Если вы родом из XML, то вы знаете, что одна из самых крупнейших фич в XML – это была XML-схема.
3960.46 3966.26 SPEAKER_01 Так вот, эти хипстеры в джессоне, они до сих пор там уже 20 лет не могут никак договориться о стандарте джессон-схемы.
3966.26 3971.90 SPEAKER_01 Есть 10 драфтов там каких-то, в общем, и примерно к этим драфтам пытаются присобачить различные инструменты.
3971.90 3979.86 SPEAKER_01 В частности, если вам очень сильно припекло и вы готовы использовать все, что угодно, лишь бы оно работало, то существует, в принципе, какой-то там драфт джессон-схемы.
3979.86 3991.38 SPEAKER_01 То есть вы можете вашу джессоновскую модельку провалидировать на предмет того, что там именно те поля, которые вы ожидаете, именно с такими значениями, именно с таком диапазоне и так далее, и так далее.
3991.38 3994.94 SPEAKER_01 То есть каким-то образом провалидировать джессоны, которыми вы оперируете.
3994.94 3999.90 SPEAKER_01 Например, это полезно, когда вы валидируете контракты между различными приложениями.
3999.90 4016.70 SPEAKER_01 Если у вас два дотнетах-приложения, вам, скорее всего, удобнее провалидировать классики, но если вы общаетесь с каким-нибудь пайтоном или еще какими-нибудь маркабесью, то там уже просто-напросто провалидировать классики вам не получится, вам нужен уже какой-то контракт.
4016.70 4033.62 SPEAKER_01 И вот джессон-схема – это отличный претендент на то, чтобы описывать контракты, и можно его поставить прямо в тестах на вход и на выход в ваше приложение, и даже не выпускать те респонсы, которые не соответствуют джессон-схеме, или не впускать те реквесты, которые джессон-схеме также точно не соответствуют.
4033.62 4044.26 SPEAKER_01 В общем, это стандартный способ валидирования объектов, который был всегда в XML, и вот развивается, более-менее пытается выкарабкаться наружу на свет в джессоне.
4044.26 4046.50 SPEAKER_01 Вот эта библиотека, в частности, его поддерживает.
4046.50 4056.70 SPEAKER_01 Также она поддерживает джессон-дата-дженерейшн, то есть когда у вас есть схема, это чудо способно с помощью богуса нагенерировать туда каких-нибудь рандомных данных, очень полезно для тестирования, например.
4056.70 4070.78 SPEAKER_01 Когда у вас есть схема какого-то сервиса, с которым вы должны общаться, но самого этого сервиса нет, он, допустим, еще не заимплементировался, тогда вы цепляете вот этот генератор, бросаете ему какой-нибудь стандартный запрос, а он вам в ответ генерирует стандартный ответ.
4070.78 4083.38 SPEAKER_01 Естественно, никакого логического, здравого приложения вы на этом не построите, но вот контракты, обмену, сериализация/децерализация вы уже сможете вполне тестировать, не ждя, пока другая команда такой сервис заимплементировает.
4083.38 4105.26 SPEAKER_01 Также есть поддержка JSON Path, то есть это способ выбрать какие-то подэлементы JSON, если кто работал с xPath в XML, то это оно, то есть вы можете сделать какое-то выражение, которое поможет вам достать тот или иной блок откуда-то, из иерархии всего огромного JSON.
4105.26 4126.98 SPEAKER_01 JSON Patch – это способ как раз-таки упомянутый нами, когда мы обсуждали HTTP методы, которые там могут путить, могут патчить, могут гетить, постить, в общем вот этот инструмент как раз-таки один из немногих, кто умеет по стандартной спецификации патчей накладывать на объект какие-то изменения.
4126.98 4138.34 SPEAKER_01 Также есть поддержка JSON Pointer, это универсальный способ указания на какой-то конкретный участок кода в JSON-документе, не кода, а именно элемента.
4138.34 4161.54 SPEAKER_01 Есть такая прекрасная штука, как JSON Logic, это специальный engine для построения всяких сложных рулов, то есть вы можете какие-то сделать правила, правила, например, для фильтров, правила для каких-нибудь вычислений, для формулов, все реализовать это в JSON и, например, расшарить между back-end и front-end, если вам, допустим, нужно шарить какие-то между ними правила, в общем, для этого и существует тоже специальный формат.
4161.54 4186.70 SPEAKER_01 Еще один из интересных форматов – это JSON-E, это специальная штука, ближе всего она находится к темплейтам, то есть когда вы задаете с помощью JSON-а темплейт и с помощью JSON-а задаете некий контекст, а потом говорите, вот тебе темплейт, вот тебе контекст, ну-ка соедини их, и темплейт рендерится с учетом тех данных, которые есть переданы были в этом контексте, тоже полезная штука.
4186.70 4192.70 SPEAKER_01 И также эта библиотека поддерживает трансформацию между YAML-ом и JSON-ом, туда и обратно, что тоже часто бывает довольно полезным.
4192.70 4206.06 SPEAKER_01 В общем, такая клевенькая толза, самое прекрасное, что мне не нравится, это то, что она не запретает какой-нибудь свои JSON-ноды, как грешат все остальные, а именно делает это все поверх систем тех JSON-а микрософтовского.
4206.06 4212.50 SPEAKER_01 В общем, и очень хорошо ее, соответственно, можно вписать в практически вообще существующие современные приложения.
4212.50 4222.02 SPEAKER_01 Так что если вам нужно вдруг делать с JSON-ом что-то извращенное и большое, то посмотрите, наверняка она это уже умеет делать.
4222.02 4223.02 SPEAKER_01 Отлично.
4223.02 4239.22 SPEAKER_01 Ну и последнее, что хотелось сказать, у меня накопился большой буквак подкастов, я их потихонечку слушаю, и давным-давно мы ничего не рекомендовали, а тут я прям хочу порекомендовать три подкаста подлодки, которые я недавно прослушал.
4239.22 4253.58 SPEAKER_01 Два технических, это про рендеринг текста 342 и даты и время 364, в обоих подкастах гостями был Никита Прокопов, небезызвестный автор "Феррокод", поэтому он кое-что знает про рендеринг текста.
4253.58 4265.62 SPEAKER_01 Ну и темы сами по себе, знаешь, такие, когда вы обсуждаете, как интернет сломан, это, наверное, первое, что приходит на ум, это дата и время, ну и юникоды всякие, рендеринги текстов.
4265.62 4272.50 SPEAKER_01 Да, то есть если вы вдруг почему-то не знаете, какие интересные штуки там встречаются, послушайте оба выпуска, это прикольно.
4272.50 4288.54 SPEAKER_01 А третий, это вообще не технический, если вам было интересно, как, так сказать, работает стендап, как эти шутки пишутся, как это всё происходит, 341 выпуск с Денисом Чужим, дело… А ты имеешь в виду не вот этот утренний митинг, да, стендап 15 минут, а другой?
4288.54 4294.18 SPEAKER_01 Да-да-да, вот со сцены с микрофоном, и когда все смеются или не смеются, вот.
4294.18 4299.70 SPEAKER_01 Там есть своя теория, свои приколы, свои, так сказать, приёмы.
4299.70 4307.54 SPEAKER_01 Довольно, ну скажем так, полезно-познавательный выпуск, практически без единой шутки, так скажем.
4307.54 4310.06 SPEAKER_01 Интересный выпуск про стендап без единой шутки.
4310.06 4317.94 SPEAKER_01 Да, т.е. серьёзно рассмотрено довольно много тем вокруг этого дела, так что если вам интересно, ну как это, посмотреть на это с обратной стороны, то послушайте.
4317.94 4320.82 SPEAKER_01 В принципе, я так с удовольствием послушал.
4320.82 4323.58 SPEAKER_01 Вот примерно всё, как у тебя, Толя, с подкастами сейчас.
4323.58 4330.54 SPEAKER_01 Тоже разгребаю завалы, скоро доберусь до подлодки, у меня там где-то выпусков 20 есть, надо послушать.
4330.54 4332.26 SPEAKER_01 Осталось там, лежит в очереди.
4332.26 4333.26 SPEAKER_01 Да, осталось.
4333.26 4343.06 SPEAKER_01 Слушаю очень много, да, интересных, но пока порекомендовать вам нечего, кроме того, что мы уже с Игорем вам много раз рекомендовали, в общем, как, в общем, авторов, они до сих пор продолжают писать, продолжают писать хорошо, поэтому слушайте.
4343.06 4352.02 SPEAKER_01 Дотнетные подкасты, которые я слушаю, ну и такие, околотехнические, они все пока что-то в основном про всякие облокады AI, пока там особо тоже порекомендовать нечего.
4352.02 4354.34 SPEAKER_01 Ну всё, на этом тогда будем завершаться.
4354.34 4358.54 SPEAKER_01 Да, да, давай посмотрим, что мы сегодня всё-таки узнали.
4358.54 4364.34 SPEAKER_01 Узнали, узнали мы, что Майкрософт не очень торопится, по крайней мере.
4364.34 4366.78 SPEAKER_01 Ну это мы знали уже давно, наверное, да, с Игоря уже сидим.
4366.78 4391.18 SPEAKER_01 На самом деле нам кажется, что не торопится, может быть, действительно, мы там через 2 недели увидим что-то вау, но тем не менее, пока мы узнали, что выпустился дотнет эспайр превью 5, дотнет 9 превью 3, вижуал студия 20, 22, 17, 10 превью 3, больше чисел, посмотрели, что теперь в Полгарис Коэль, пока ещё в бете, но уже можно писать на C# и F# внутри, мне кажется, что теперь можно, а интересно, можно туда запихнуть Aspire Core?
4391.18 4394.94 SPEAKER_01 Да, твой антикий фреймворк, пусть сам себя вызывает.
4394.94 4396.62 SPEAKER_01 Да, и будет прикольно.
4396.62 4405.66 SPEAKER_01 Не, ну смотри, если ты антикий фреймворк запихнёшь к базам данных, выставишь это всё через Aspire Core, то тебе вообще как бы хостинг не нужен, в ПГ будет всё хостить.
4405.66 4406.66 SPEAKER_01 Да, прям в базе хостятся, всё так.
4406.66 4408.10 SPEAKER_01 Через ПГ баунсеры вперёд.
4408.10 4409.10 SPEAKER_01 Прикольно.
4409.10 4410.10 SPEAKER_01 Да, отличная идея.
4410.10 4414.90 SPEAKER_01 А если учитывать, что на C# есть возможность запустить любой WebAssembly?
4414.90 4419.54 SPEAKER_01 Ну, смотри, мы изобрели с собой Serverless и Lambda Function.
4419.54 4420.54 SPEAKER_01 Да?
4420.54 4421.54 SPEAKER_01 Внутри базы данных.
4421.54 4424.10 SPEAKER_01 Ну если у тебя нет сервера, но есть база данных, это ж Serverless, правда?
4424.10 4425.10 SPEAKER_01 Ну не того.
4425.10 4426.10 SPEAKER_01 Да.
4426.10 4439.90 SPEAKER_01 Посмотрели на юбилейный, вообще говоря, 30-ый технологий радар и немножко по мелочи поговорили о всяких односрочных, так скажем, новостях и небольшой подборкой выпусков подкастов.
4439.90 4448.78 SPEAKER_01 Всё, чё, 91-ый выпуск, чуть больше часа, наверное, получится после монтажа, но в целом тоже не очень длинный.
4448.78 4464.62 SPEAKER_01 Отлично, пишите комментарии, заходите к нам в ютубчик, рассказывайте, что вам понравилось, что не понравилось, может быть, какие-то интересные темы, статьи мы пропускаем, обязательно нам про них расскажите, и мы срочно донесём их общественности, а также рассказывайте друзьям, шаря, репосты, ну вы знаете, там колокольчики, всякие подписки.
4464.62 4468.40 SPEAKER_01 Поддерживайте любимый подкаст и до скорой встречи через пару недель.
4468.40 4469.40 SPEAKER_01 Пока!
4469.40 4469.42 SPEAKER_01 Да, всем пока!
4469.42 4485.74 SPEAKER_01 *музыка*
