0.00 9.80 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net, выпуск 42.
9.80 11.96 "Анатолий Кулаков" И как всегда, с вами Анатолий Кулаков.
11.96 13.60 "Анатолий Кулаков" И Игорь Лабутин, привет.
13.60 27.72 "Анатолий Кулаков" Большое спасибо всем, кто нас слушает, кто нам помогает распространяться, кто всячески поддерживает нас словом, делом и прочими хорошими вещами, и в частности, Александру, Сергею и Владиславу наше огромное большое спасибо.
27.72 35.44 "Анатолий Кулаков" Ну что ж, так как у нас тут осталось совсем немножко до Нового года, я думаю, тянуть уже дальше смысла нет.
35.44 40.80 "Анатолий Кулаков" Давайте посмотрим, что же у нас тут за новости вышли на последних неделях, буквально праздничных.
40.80 50.40 "Анатолий Кулаков" Посмотрим, что интересного было и произошло, а все остальное, а также кое-что, что мы не успели обсудить в прошлом году, уже перенесем на следующий год.
50.40 63.56 "Анатолий Кулаков" Там, мне кажется, у нас будет времени побольше, получше подготовимся, получше выучим, позовем интересных, хороших гостей, потому что у нас есть шикарные темы, которые ждут своих гостей, в общем, мы про них не забыли, они будут, но всему свое время.
63.56 67.32 "Анатолий Кулаков" А сейчас посмотрим, есть что-нибудь у нас от Микрософта для начала?
67.32 68.32 "Игорь Лабутин" Конечно, есть.
68.32 75.12 "Игорь Лабутин" Понятно, что действительно в предрождественское время новостей не так много, но на самом деле есть довольно важные штуки.
75.12 84.00 "Игорь Лабутин" Начнем мы, как ни странно, с Entity Framework сегодня, потому что по основному тут на эту новостей практически нет, но в Entity Framework есть две важных новости.
84.00 111.32 "Игорь Лабутин" Важная новость номер один, вышел патч на шестую версию 6.0.1 и он довольно важный, там пофикшено примерно 15 довольно важных багов, всякие эксепшены, неподдерживаемые операторы и еще какая-то проблема и штуки, которые внезапно прокрались в релиз, поэтому если вы пользуетесь Entity Framework Core 6.0, команда настоятельно рекомендует обновиться на 6.0.1, вы скорее всего что-нибудь да пофиксите у себя.
111.32 126.84 "Игорь Лабутин" А помимо этого, команда анонсировала планы на 7-ой Entity Framework Core на ближайший год, это пока только планы, это никакой не коммитмент, все может поменяться, но планы вообще говоря очень интересные и давайте на них посмотрим.
126.84 157.72 "Игорь Лабутин" Начинается все с JSON columns, то есть у нас есть поддержка JSON колонок в разных базах данных и в Postgres и в SQL Server, в Ruby и вообще говоря в других тоже, и поэтому Entity Framework собирается их еще лучше поддержать, то есть сохранять и загружать, но не сами колонки, а делать именно кверки, возможно даже внутрь каких-то JSON-based этих самых колонок, чтобы их можно было более эффективно доставать из базы или там фильтровать по их значению внутри.
157.72 167.48 "Игорь Лабутин" Короче, поскольку популяризация JSON и хранение JSON в том числе в реализационных базах довольно высока, то вот Entity Framework команда будет этим заниматься.
167.48 174.12 "Игорь Лабутин" Дальше bulk updates, то есть такие massive updates.
174.12 185.56 "Игорь Лабутин" Проблема сейчас в том, что когда мы хотим что-то обновить, скажем так, оптом, то нам приходится сначала загрузить все это в память, обновить, ну а потом уже сказать save changes.
185.56 195.52 "Игорь Лабутин" А команда хочет сделать метод, который позволит, скажем так, сделать это прямо внутри базы, не загружая все это в память.
195.52 201.04 "Игорь Лабутин" То есть по какому-то притекату найти нужные записи и именно в них обновить только то, что нужно.
201.04 215.48 "Игорь Лабутин" Следующий пункт называется Lifecycle Hooks, то есть Entity Framework собирается предоставить ряд хуков, куда вы можете подключиться и каким-то образом может быть даже влиять на то, что происходит внутри Entity Framework по мере того, как он исполняет ваш запрос.
215.48 220.36 "Игорь Лабутин" Это немножко похоже на то, что делал WCF, где было огромное количество точек расширения.
220.36 227.04 "Игорь Лабутин" Не знаю, будут ли они повторять опыт WCF и генерить столько же точек расширения, но посмотрим.
227.04 234.32 "Игорь Лабутин" Собираются улучшить поддержку хранения иерархии объектов в табличках.
234.32 240.80 "Игорь Лабутин" То есть есть же разные способы хранения иерархии, там все кидается в одну табличку, табличка на тип и так далее.
240.80 248.40 "Игорь Лабутин" Вот как раз таки табличка на конкретный тип, вариант такого маппинга, улучшения в этом подходе и будут сделаны.
248.40 251.12 "Игорь Лабутин" Так, давайте посмотрим, что у нас дальше.
251.12 253.16 "Игорь Лабутин" Дальше у нас вот что.
253.16 265.80 "Игорь Лабутин" Сейчас, когда мы делаем, соответственно, create, read, update, delete, мы пишем это в виде link.io или еще как-то, то соответственно Entity Framework транслирует это в нормальный обычный SQL команды.
265.80 275.60 "Игорь Лабутин" Но иногда, допустим, update или delete или create делается с помощью специальных хранимых процедур, где у вас есть какая-нибудь, например, дополнительная логика, которую нужно сделать в базе.
275.60 284.20 "Игорь Лабутин" Так вот теперь можно будет, если это будет сделано, create, update и delete замапить прямо на конкретные хранимые процедуры, вместо того, чтобы генерить SQL.
284.20 286.24 "Игорь Лабутин" Возможно, будет полезно.
286.24 292.44 "Игорь Лабутин" Для любителей DDD появится поддержка value-объектов и улучшатся value-конверторы.
292.44 326.64 "Игорь Лабутин" Для тех, кто не любит почему-то маппить типы в Entity Framework и использовать его по-настоящему, полноценно, а использует его чисто как такой простой маппер, то можно будет выполнять обычные SQL-квейки, когда вы пишете там from SQL, но на, скажем так, большее количество таких кверек можно будет исполнять, различные типы будут поддержаны, так что возможно это такой шаг в сторону, не знаю, меньшего использования addon.net или там dupper или еще кого-нибудь из таких обычных мапперов.
326.64 337.72 "Анатолий Кулаков" Ну и часто кричат, что если вам нужна только read модель, вам только читать, от Entity Framework вам не нужен, он у вас избыточен, он у вас будет медленный, вот теперь есть, что таким говорным ответить.
337.72 342.28 "Игорь Лабутин" Но мы посмотрим конкретно, что будет сделано, мы пока не знаем, но глядим.
342.28 360.40 "Игорь Лабутин" И то, что они называют scaffolding templates, то есть то, что вы делаете, когда вы говорите .NET EF database scaffold, то есть когда генеряется db-контекст, ну и всякие такие штуки, то теперь там все это можно будет очень круто кастомизировать, но что конкретно, пока не знаю, посмотрим.
360.40 370.56 "Игорь Лабутин" При этом, поскольку сам .NET тоже будет развиваться и .NET 7 наверняка будет иметь много клевых и интересных фич, то Entity Framework тоже не отстает.
370.56 376.56 "Игорь Лабутин" И одна из фич, про которую мы поговорим, наверное, в одном из следующих выпусков, это дистрибьютод транзакции.
376.56 380.48 "Игорь Лабутин" Пользуешь ли ты когда-нибудь дистрибьютод транзакциями в .NET Framework?
380.48 396.76 "Анатолий Кулаков" Мне что-то в юные годы приходила в голову такая мысль, но мне воспитатели в детском садике еще отбили все желание об этом думать, словами, что это все запрещено, об этом думать нельзя, потому что это медленно, это ненадежно, это ужасно и потенциально даже в идеальном мире работать
396.76 407.68 "Игорь Лабутин" не будет. Ну вот я тебе могу рассказать, что у нас дистрибьютод транзакций были в продакшене, соответственно, на SQL-сервере, для этого еще нужна была отдельная служба, называлась MSDTC, возможно, ты про такое слышал.
407.68 408.68 "Игорь Лабутин" Да, конечно.
408.68 410.60 "Игорь Лабутин" Дистрибьютод транзакций координатор.
410.60 423.60 "Игорь Лабутин" Но с момента, когда мы, и Microsoft, стали переезжать на .NET Core, туда эта штука спортирована не была, то есть поддержки распределенных транзакций никак не было, потому что MSDTC это чисто рендовая штука.
423.60 438.64 "Игорь Лабутин" Так вот теперь MSDTC в седьмом .NET, точнее не так, вроде как я понимаю, уже сейчас MSDTC то ли уже полностью готова, то ли практически готова, порт его под Linux и поддержка в SQL-сервере на Linux.
438.64 445.96 "Игорь Лабутин" Соответственно, никто тебе не мешает делать теперь распределенные транзакции между Windows и Linux, например, если это один и тот же SQL-сервер.
445.96 453.38 "Анатолий Кулаков" Интересно, а как вы в своем приложении проблему решили, вы портировали без дистрибьютод транзакций или все-таки ждете, пока он появится?
453.38 487.96 "Игорь Лабутин" Нет, мы смогли сделать так, что нам не… переписали приложение так, что нам не нужно дистрибьютод транзакций действительно, но видимо мы относимся, возможно, к меньшинству или еще как-то, но довольно много народу видимо хотело этого, потому что в .NET 7 распределенные транзакции вернутся в .NET, то есть в седьмом фреймворке, ой, тьфу, все фреймворки, в седьмом .NET Microsoft возродит обратно дистрибьютод транзакции, а Entity Framework, соответственно, их поддержит, и вы сможете ваше .NET Framework приложение с какого-нибудь там 4Х перенести на .NET 7 с поддержкой распределенных
487.96 496.92 "Анатолий Кулаков" транзакций. Ну отлично, я тогда начинаю искать хорошую подборочку статей, почему дистрибьютод транзакций это плохо, чтоб мы как бы в одном выпуске обсудили плюсы и минусы
496.92 510.08 "Игорь Лабутин" этого подхода. Там есть GitHub-иши, если вы откройте GitHub-иши про Entity Framework как раз таки 7 и вот эту поддержку дистрибьютод транзакций, там примерно половина комментариев типа «да, наконец-то, давно пора», а вторая половина «не делайте это, это медленно, тормозно и бажено».
510.08 519.52 "Игорь Лабутин" Короче, там да, идет такая, ну не то что война, но довольно активное обсуждение, зачем это надо, почему это надо и так далее, и как это будет сделано.
519.52 549.40 "Анатолий Кулаков" Да, видишь, к сожалению, это из той серии, когда тебе дают там золотой молоток, и ты начинаешь все подряд и им бить, и оно вроде менее, более или менее на первый взгляд работает, а потом когда у тебя уже получается сильно нагруженный какой-нибудь продакшен, и ты хочешь от этого как-то уже отказаться, а отказаться от этого уже невозможно без тотального переписывания как бы всего, поэтому это такой сладкий молоток на начало вашего продукта, но потом в конце обычно люди об этом жалеют, и вот те опытные, они стараются предупредить уже новеньких.
549.40 555.52 "Игорь Лабутин" Ну, тем не менее, новенькие победили, да, пока по крайней мере побеждают.
555.52 556.52 "Игорь Лабутин" Ну их большинство.
556.52 562.28 "Игорь Лабутин" Ну непонятно, насколько большинство, возможно их там может быть не большинство, но они довольно ключевые, например, для Майкрософта.
562.28 573.36 "Анатолий Кулаков" Я думаю, и сам Майкрософт использует и в своих легасе приложений дистрибьютор транзакций, и в каких-нибудь новых больших как бы использует, поэтому, прежде всего, он писал для себя.
573.36 574.36 "Игорь Лабутин" Возможно.
574.36 577.80 "Игорь Лабутин" Я, кстати, не читал еще .NET, именно ищусь на эту тему, почему они решили их вернуть.
577.80 580.20 "Игорь Лабутин" Надо будет почитать, посмотреть.
580.20 581.20 "Игорь Лабутин" Поехали дальше.
581.20 596.72 "Игорь Лабутин" Будет, конечно, большое количество улучшений вокруг тулинга, то есть все, что относится к команде .NET EF, оно все будет улучшено, расширено, углублено, и будет более, скажем так, просто в использовании, эффективнее работать, ну и так далее.
596.72 614.80 "Игорь Лабутин" Дальше есть какие-то попытки сделать, подружить точнее, Entity Framework и графические приложения, ну то есть это примерно как раньше на WinForms можно было кинуть грид к нему, привязать базу, и оно само работало, то вот видимо что-то подобное хотят сделать с Entity Framework.
614.80 620.60 "Игорь Лабутин" Не знаю пока в каком виде, как только будет фича в каком-то виде, но хоть как-то готово, будем смотреть, следить и вам рассказывать.
620.60 645.08 "Игорь Лабутин" Дальше есть некоторое количество планируемых улучшений вокруг провайдеров и вообще доступа к базе, то есть есть такой пакет SQL Server.Core, ну не пакет, а технология набора пакетов, про то, как правильно доступаться к SQL Server, сейчас вместо нативных SQL Server серверных драйверов, такой нормальная дотанная таберточка над ними, Cosmos DB Provider будет улучшен.
645.08 652.48 "Игорь Лабутин" Для ADO.NET провайдеров сделают поддержку опыт телеметрии, про которую мы говорили в прошлом выпуске.
652.48 669.12 "Игорь Лабутин" В System Data тоже добавят улучшения, то есть это совсем низкий уровень доступа к данным, то есть это то, на чем основаны всякие провайдеры, как правило, и там же живет ADO.NET, там будет куча улучшений для того, чтобы все было быстрее, лучше и красивее.
669.12 694.36 "Игорь Лабутин" LinkView, поскольку в LinkView добавилось некоторое количество новых функций операторов, возможно их нужно поддержать соответственно при генерации SQL, также нужно поддержать возможно новые фичи из GCC#, потому что вы же можете теперь в каком-нибудь LinkView написать какой-нибудь паттерн-матчинг, и было бы прикольно его если получится смапить в SQL, ну там где получится, конечно.
694.36 706.60 "Игорь Лабутин" Не забудут про trimming, чтобы можно было отрезать все лишнее, то есть видимо как-то разметят свои дл, чтобы из них можно было бы отрезать все лишнее, ну и как обычно, так сказать.
706.60 726.60 "Игорь Лабутин" Последний пункт, он такой, с одной стороны он, мне кажется, часы для галочки, с другой стороны может быть из этого вылезет что-то интересное, называется это "Research Data Access for Cloud Native", то есть как бы нам так сделать Data Access для Cloud Native приложений, микросервисов этого всего, чтобы было прям вот вах, не знаю, что из этого получится, но что-то получится, наверное.
726.60 731.96 "Анатолий Кулаков" Да, еще непонятно, что это за проблема такая, в чем проблема сейчас использовать в клауде entity framework?
731.96 757.16 "Игорь Лабутин" Да ни в чем, наверное, но как бы просто вот они пишут, что типа "This research will help drive future investments in Data Access Technologies", то есть это скорее просто поизучать какие, ну скажем так, традиционные паттерны есть, что народ в среднем пишет и может быть как-то именно сфокусировано пытаться решать проблемы тех, кто сейчас пишет на entity framework для микросервисов.
757.16 767.76 "Анатолий Кулаков" Ну обычно такую штуку пишут, когда хотят из менеджеров на будущий год бюджета выбить и вроде ничего сказать, а как бы куда-то время заинвестигейтить и деньги куда-то вложить охота.
767.76 770.40 "Анатолий Кулаков" Вот они и пишут, что "Research для будущих Cloud Native Blockchain"
770.40 775.88 "Игорь Лабутин" и вперед. Ну либо так, либо наоборот пришли менеджеры и сказали, нам нужно что-нибудь для Cloud Native.
775.88 777.64 "Игорь Лабутин" И такие, ну хорошо, поресерчим.
777.64 778.64 "Игорь Лабутин" Ну будут, посмотрим.
778.64 799.24 "Игорь Лабутин" Ну и конечно, performance, performance, performance, техэмпауэр не дремлет, нужно догонять, обгонять и перегонять даппер во много-много-много раз и еще entity framework довольно много поработал в прошедшем релизе, в шестом, над вопросом перформанса селектов, но там есть еще много куда расти с точки зрения инсертов и апдейтов.
799.24 801.40 "Игорь Лабутин" И вот над этим они тоже собираются поработать.
801.40 802.92 "Игорь Лабутин" Вот, ну примерно так.
802.92 806.96 "Анатолий Кулаков" Хорошее обещание, хороший должен быть релиз, будем посмотреть.
806.96 816.84 "Анатолий Кулаков" Так, а у меня тоже новости есть с шестого дотнета, продолжает нас догонять остаточные зоны, которые мы еще не покрыли в предыдущих выпусках.
816.84 825.80 "Анатолий Кулаков" И один из самых интересных аспектов нового фреймворка это улучшение в нетворке, в сети и в сетевом взаимодействии.
825.80 833.64 "Анатолий Кулаков" Многие мы уже упоминали в предыдущих выпусках, ну давайте посмотрим, что осталось и может быть немножко вспомним о том, о чем уже говорили.
833.64 844.44 "Анатолий Кулаков" Один из основных, наверное это можно даже сказать bugfix или таких больших недоделок это windows scaling во штете tp втором.
844.44 857.64 "Анатолий Кулаков" Как вы наверное многие знаете, что http 2 стал очень популярен с тех пор, как на хайп поднялось gRPC, многие хотят gRPC и gRPC очень хорошо используется, http 2.
857.64 860.00 "Анатолий Кулаков" Поэтому все ринулись его поддерживать со всех сторон.
860.00 874.20 "Анатолий Кулаков" И .NET был не исключением, там давно уже поддержали http 2 с помощью сокета http хендлера, но надоедливые кастомеры нашли одну неприятную багу.
874.20 890.08 "Анатолий Кулаков" Если у вас есть какой-то канал, у которого очень большие задержки, то есть канал очень и очень медленный, то сокет http хендлера выдавал очень маленькую скорость, где-то в 5-10 раз меньше чем конкуренты.
890.08 898.96 "Анатолий Кулаков" Например, курл на подобных сетях мог достичь скорости 10 мегабайт в секунду, а наш хендлер выдавал всего на всего 2,5 мегабайта.
898.96 918.92 "Анатолий Кулаков" Соответственно, разработчики полезли внутрь, начали разбираться и поняли, что одна из самых главных проблем, из-за которой все это начало происходить, это фиксированное окно, с помощью которого как раз-таки протокол собирает пакеты, которое очень сильно влияет на каналы с большой задержкой.
918.92 921.04 "Анатолий Кулаков" Окно там было по умолчанию 64 килобайта.
921.04 928.92 "Анатолий Кулаков" И этого оказалось слишком мало даже для того, чтобы поймать специальный фрейм, который называется Windows Update, для того, чтобы расширить фрейм и сделать окно побольше.
928.92 931.92 "Анатолий Кулаков" В общем, этого тоже не хватало.
931.92 934.32 "Анатолий Кулаков" Перед разработчиками стояло несколько вариантов фикса.
934.32 944.16 "Анатолий Кулаков" Это или сделать по умолчанию большое окно, что приводило бы к тому, что иногда зря расходовалась бы память, ненужное видео выделялось и никак бы не использовалось.
944.16 947.48 "Анатолий Кулаков" Или как-то по-другому подкрутить это дело.
947.48 950.92 "Анатолий Кулаков" В общем, они пошли самым правильным путем, самым сложным и самым правильным.
950.92 958.92 "Анатолий Кулаков" Они изобрели свой алгоритм, который позволяет динамически расширять это окно, как в принципе сделано, например, в TCP.
958.92 964.20 "Анатолий Кулаков" И кажется, что это решило все их проблемы и позволило достичь максимального перформанса.
964.20 967.20 "Анатолий Кулаков" На этом месте, в принципе, это все.
967.20 981.48 "Анатолий Кулаков" Единственное, что меня как-то смутило, что все вот эти проблемы типа динамического окна, подстраивания под медленные каналы, подстраивания под разрывающиеся постоянно каналы, все эти грабли уже были давным-давно собраны в TCP.
981.48 991.56 "Анатолий Кулаков" И мне почему-то казалось, что люди, строящие HTTP/2 и HTTP/3, тем более, они должны были бы все эти наработки, все, что-то есть в TCP взять, переосмыслить и внедрить.
991.56 1003.48 "Анатолий Кулаков" А тут оказывается, что HTTP/2 уже, так сказать, зрелый, давнежний протокол по современным меркам, натыкается на такие элементарные банальные баги, которые уже давно всем известны и давно у всех пройдены.
1003.48 1004.92 "Анатолий Кулаков" Вот это, конечно, странно.
1004.92 1013.60 "Игорь Лабутин" Ну подожди, скорее всего это потому, что, ну где-то используют GCP обычно, между своими сервисами внутри своего, там, не знаю, дата-центра или облака, правильно?
1013.60 1018.60 "Игорь Лабутин" Мы же практически никогда не можем выставить GRPC наружу, там, для клиентов, ну с редким исключением.
1018.60 1025.08 "Игорь Лабутин" А внутри у тебя облако, у тебя стабильные, хорошие сети или внутри дата-центра с низким лейтенси.
1025.08 1036.48 "Игорь Лабутин" И поэтому вот то, что ты говоришь, типа, когда у тебя на очень плохих каналах, это на самом деле, видимо, возросшая популярность GRPC дошла до того, что его начали использовать на таких каналах.
1036.48 1038.68 "Игорь Лабутин" Ну а до этого просто никто на них не тестировал.
1038.68 1043.32 "Игорь Лабутин" Или может и знали, но решали, что ну не будем в это вкладывать, потому что все равно используются на хороших сетях.
1043.32 1050.48 "Анатолий Кулаков" Ну а на каких-нибудь мобилках, которые там работают из большой, из большой, там, глубокой пещеры, неужто никто GRPC не использует?
1050.48 1055.40 "Игорь Лабутин" Ну я, честно говоря, не знаю, я не являюсь мобильным разработчиком, наверное, используют, но фиг его знает.
1055.40 1061.24 "Анатолий Кулаков" Так, кто сталкивался с мобилками, напишите нам в комментах, если там GRPC популярен, или он используется там.
1061.24 1065.84 "Анатолий Кулаков" Ну потому что большая задержка, это вот прежде всего прерогатива мобильных устройств.
1065.84 1067.72 "Анатолий Кулаков" Хорошо, пойдем дальше.
1067.72 1081.32 "Анатолий Кулаков" Там еще большие изменения и большие улучшения с HTTP/3 к WIC, в частности, еще в .NET 5, в прошлой версии была введена экспериментальная поддержка к WIC и HTTP/3.
1081.32 1085.36 "Анатолий Кулаков" Но для того, чтобы его там включить, нужны были очень большие танцы с бубном.
1085.36 1088.32 "Анатолий Кулаков" Там доинсталлировать, поднять, подключить, подкрутить.
1088.32 1095.68 "Анатолий Кулаков" В общем, в .NET 6 поддержка все еще осталась экспериментальной, ее не включили по дефолту, но очень сильно упростили настройку.
1095.68 1102.44 "Анатолий Кулаков" Теперь настроить это гораздо легче, понятнее на всех операционных системах, поддерживается и красиво работает.
1102.44 1110.68 "Анатолий Кулаков" Еще стоит отметить, что HTTP/3 использует QUIC вместо TCP, как раз-таки на транспортном уровне.
1110.68 1117.32 "Анатолий Кулаков" И в .NET выделили специальный namespace, который теперь будет называться System.NET QUIC.
1117.32 1122.56 "Анатолий Кулаков" Это менеджментный уровень над нативной имплементацией, над MS QUIC.
1122.56 1128.16 "Анатолий Кулаков" Это микрософтская библиотека, которая используется там абсолютно всем Windows, чтобы поддержать QUIC.
1128.16 1132.56 "Анатолий Кулаков" И она кроссплатформенная, под Linux она тоже есть.
1132.56 1138.56 "Анатолий Кулаков" Так вот, вот этот namespace, его хотят в перспективе сделать публичным.
1138.56 1155.04 "Анатолий Кулаков" Но на данный момент еще слишком мало потестировали разработчики имплементацию QUIC, а также они подразумевают, что этот QUIC может использоваться не только в HTTP/3, потому что это вот реальная замена транспортного уровня.
1155.04 1162.16 "Анатолий Кулаков" Это как TCP, его можно использовать в большом количестве вообще различных протоколов прикладного уровня.
1162.16 1166.84 "Анатолий Кулаков" А сейчас он по-хорошему оттестирован только на логике, на сценариях HTTP/3.
1166.84 1171.16 "Анатолий Кулаков" Поэтому пока они его сделали приватным и тоже наружу не выставляют.
1171.16 1176.92 "Анатолий Кулаков" Но он там есть, он сейчас тестируется, проходит там какие-то дополнительные спецификации, проверки и прочее.
1176.92 1189.04 "Анатолий Кулаков" Может быть в будущем уже можно будет строить свои реальные протоколы прикладного уровня на QUIC, который обещает быть побыстрее, постабильнее и так далее со всеми прочими плюшками HTTP/3.
1189.04 1193.20 "Анатолий Кулаков" Наконец-то добавилась поддержка SocksProxy.
1193.20 1197.92 "Анатолий Кулаков" Если верить GitHub, то ее начали просить еще с 2016 года.
1197.92 1200.44 "Анатолий Кулаков" То есть это уже там прочи 5-6 лет.
1200.44 1206.00 "Анатолий Кулаков" Микрософт каким-то образом знает про это, может быть имплементировала бы это, может быть хотела бы это, но нет.
1206.00 1208.24 "Анатолий Кулаков" Не хотела, не знала, не имплементировала.
1208.24 1220.20 "Анатолий Кулаков" Поэтому пришел человек из комьюнити и забацал свою поддержку Socks, которая довольно-таки хороша, потому что она включает поддержку как Socks4, так и Socks4a, ну и конечно Socks5.
1220.20 1223.44 "Анатолий Кулаков" В общем, теперь все вот эти прокси тоже поддерживаются.
1223.44 1228.04 "Анатолий Кулаков" Socks - это довольно интересный и гибкий протокол для проксирования.
1228.04 1231.08 "Анатолий Кулаков" Например, на его основе можно легко сделать VPN.
1231.08 1236.24 "Анатолий Кулаков" Также Socks является основным подключением для TOR.
1236.24 1240.68 "Анатолий Кулаков" То есть анонимная сеть TOR, вот она очень широко используется.
1240.68 1259.08 "Анатолий Кулаков" Ну и вообще, в принципе, если вы каким-то образом используете какие-нибудь VPN, какие-нибудь сети, которые сосредоточены на секьюрити, на том, чтобы скрыть ваши персональные данные, еще что-то, всю информацию о том, где вы путешествуете, то обычно они выбирают как раз-таки протокол Socks.
1259.08 1262.12 "Анатолий Кулаков" Удивительно, почему так долго, опять же, не было этого в дот-нете.
1262.12 1274.08 "Анатолий Кулаков" Опять же, наверное, сказывается какая-то корпоративная направленность, где все это может быть не так актуально, но для бытейских нужд, для покачать, для посмотреть, для попутешествовать, в общем, это отличная вещь.
1274.08 1279.08 "Анатолий Кулаков" Соответственно, теперь вы можете ваш ТП-клайнт передать прокси, как обычно.
1279.08 1283.04 "Анатолий Кулаков" Единственное, что теперь вам этот прокси нужно создавать со схемой, которая называется Socks 5.
1283.04 1289.96 "Анатолий Кулаков" И, соответственно, указываете там полностью адрес и порт того прокси, которому вы хотите подсокситься.
1289.96 1294.96 "Анатолий Кулаков" Дальше, After Use Port Range для Windows появился.
1294.96 1303.16 "Анатолий Кулаков" Это проблема, с которой, наверное, многие из вас смогли сталкиваться, когда вы начинаете очень интенсивно параллельно использовать коннекции.
1303.16 1312.40 "Анатолий Кулаков" И где-то примерно просто из 16 тысяч параллельных коннекций Windows может вам радостно сообщить, что теперь она новые коннекции открывать не будет и идите вы лесом.
1312.40 1326.24 "Анатолий Кулаков" Вот, это происходит потому, что вы исчерпываете весь динамический пул портов, который объявлен для TCP и находится где-то в пределах от 49 152 до 65 535.
1326.24 1327.80 "Анатолий Кулаков" Ну, то есть до макса.
1327.80 1333.16 "Анатолий Кулаков" В общем, и этот пул, конечно, настраивается, но в большинстве случаев это вот так.
1333.16 1337.48 "Игорь Лабутин" Надо сказать, что это не обязательно прям 16 тысяч именно прям concurrent connections.
1337.48 1352.84 "Игорь Лабутин" Достаточно сделать эти 16 тысяч connections в течение 30 секунд, потому что даже если вы закрыли соединение на Windows по дефолту, оно еще 30 секунд будет висеть в специальном состоянии и ждать не придет ли там еще вдруг какой-нибудь пакетик, на который нужно будет чем-нибудь ответить.
1352.84 1360.76 "Игорь Лабутин" Поэтому если ваше приложение очень часто делает много connections, то вы можете это встретить, даже не обязательно их делать именно строго параллельно.
1360.76 1365.56 "Анатолий Кулаков" Ну да, concurrent здесь такая растяжимое в 30 секундах окно получается.
1365.56 1366.56 "Игорь Лабутин" Да.
1366.56 1377.72 "Игорь Лабутин" Причем эти 30 секунд настраиваются на самом деле и на некоторых хостах, то есть мы, например, на наших каких-то серверных хостах по, скажем так, определенным причинам иногда настраивали это время аж до 2 минут.
1377.72 1381.04 "Игорь Лабутин" И тогда это дело растягивается аж на 2 минуты.
1381.04 1399.24 "Игорь Лабутин" Поэтому в общем следите внимательно и ключевые слова для поиска, если вдруг что, это называется close wait, по-моему, state, если я правильно помню, которое как раз таки состояние сокета, в котором он ждет тех самых завершений всего того, чего надо.
1399.24 1417.36 "Анатолий Кулаков" Именно так, когда у вас перестают создаваться новые подключения, вы зайдите в ваш netstat, в командной строке наберите состояние текущей сети, это можно сделать или через процесс explorer, или через еще кучу вещей и сразу увидите, что у вас открыта куча-куча портов в определенном странном состоянии с wait.
1417.36 1420.12 "Анатолий Кулаков" И по вот этому статусу вы легко нагуглите проблему.
1420.12 1436.96 "Анатолий Кулаков" Вот, чтобы немножко нивелировать такую ситуацию, как раз был введен, даже не введен, а немножко вернули, потому что раньше он был, но его немножко поломали и переделали, такое понятие как порт редюсинг, то есть теперь порты можно переиспользовать.
1436.96 1443.76 "Анатолий Кулаков" И все нужно, чтобы эта же технология заработала, все, что вам нужно, это обеспечить всего-навсего пару простых правил.
1443.76 1463.04 "Анатолий Кулаков" Во-первых, это все четыре составляющих должны быть уникальны, из которых четыре составляющих это локальный порт, локальный адрес, удаленный порт и удаленный адрес, в общем, если они уникальны, и если на вашей машине, например, включена поддержка автореюза, то у вас эта технология заработает.
1463.04 1475.72 "Анатолий Кулаков" Дальше некоторые кастомеры столкнулись с ситуацией, когда у них плохо работал дуал мод на IP6 и IP4.
1475.72 1481.96 "Анатолий Кулаков" Я напомню, что начиная с .NET 5, мы могли использовать дуал мод для сокетов.
1481.96 1487.24 "Анатолий Кулаков" Это означает, что на одном и том же сокете мы могли слушать и IPv4 трафик, и IPv6 трафик.
1487.24 1491.24 "Анатолий Кулаков" То есть вы открываете IPv6 сокет и он принимает и 6 и 4 трафик.
1491.24 1498.00 "Анатолий Кулаков" Вот это вроде работает нормально для тех ситуаций, когда у вас IP6 поддерживается и клиентом, и сервером.
1498.00 1511.84 "Анатолий Кулаков" Но кастомеры столкнулись с проблемой, что, например, некоторые VPN-туннели не поддерживают IP6 протокол, и в этом случае при использовании дуал мода выдают ошибки.
1511.84 1522.72 "Анатолий Кулаков" Поэтому команда решила сделать прекрасный флаг, который называется просто-напросто Disable IPv6 глобально для всех ваших .NET 6 процессов.
1522.72 1530.96 "Анатолий Кулаков" В общем, если у вас вдруг такая ситуация случилась, то вы можете вырубить просто-напросто IPv6 для всех ваших .NET процессов, и она, по идее, должна уйти.
1530.96 1534.28 "Анатолий Кулаков" Также были сделаны некоторые изменения в URI.
1534.28 1537.76 "Анатолий Кулаков" Соответственно, какая была проблема?
1537.76 1561.44 "Анатолий Кулаков" Проблема была в том, что некоторым клиентам иногда очень сильно хотелось в HTTP-клайнт передавать URL со специальными символами, которые, по идее, не должны быть передаваться через URI, и, соответственно, хороший и прилежный URI их скейпил.
1561.44 1576.24 "Анатолий Кулаков" То есть он приводил URL к так называемому канонизированному состоянию, где все недопустимые символы скейпились, и, соответственно, можно было передавать, и все клиенты, все серверы могли это безбоятельно отрабатывать.
1576.24 1588.20 "Анатолий Кулаков" Но случилось так, что у некоторых кастомеров они получали URL в таком состоянии, что если они заэскепят эти значения, то это будет совершенно уже другой URL.
1588.20 1591.36 "Анатолий Кулаков" И логика в том, что они никак этот URL не обрабатывали.
1591.36 1592.80 "Анатолий Кулаков" Им не нужно было его не процессить, ничего.
1592.80 1595.00 "Анатолий Кулаков" То есть он не должен был быть для них валидным.
1595.00 1602.28 "Анатолий Кулаков" Вся задача у них состояла только лишь напросто передать его другому какому-то серверу, который уже знает, как с этим поступить.
1602.28 1608.48 "Анатолий Кулаков" Такой довольно специфичный случай, непонятный, наверное, для большинства из нас.
1608.48 1615.52 "Анатолий Кулаков" Именно поэтому такая ситуация не была обработана раньше, а обрабатывалась только сейчас.
1615.52 1624.88 "Анатолий Кулаков" Для этого как раз таки и был введен специальный параметр, который вы можете передать в URL Creation Options.
1624.88 1630.00 "Анатолий Кулаков" Параметр называли очень знаково, очень красиво.
1630.00 1634.68 "Анатолий Кулаков" Dangerous Disable Path and Query Canonization.
1634.68 1640.00 "Анатолий Кулаков" Со слова Dangerous начинать параметры, которыми не советуют просто так пользоваться, это очень интересный прием.
1640.00 1641.84 "Анатолий Кулаков" В общем, вот такой Dangerous.
1641.84 1652.36 "Анатолий Кулаков" Если вас не смущает, и вы его примените к вашему URI при его создании, то не будет производиться никакой канонизации, не будет производиться валидации, не трансформации, ничего не производится.
1652.36 1655.44 "Анатолий Кулаков" Его просто возьмут и передадут куда нужно.
1655.44 1660.72 "Анатолий Кулаков" Соответственно, например, HTTP Client его может использовать и тоже по нем что-то попытаться запросить.
1660.72 1662.68 "Анатолий Кулаков" Но здесь будьте очень внимательны.
1662.68 1671.40 "Анатолий Кулаков" Просто так включать эту штуку нельзя, потому что очень много сервисов на другом конце просто-напросто не будут работать в таком URI.
1671.40 1674.40 "Анатолий Кулаков" То есть вам нужно четко понимать, что вы делаете и зачем вы это делаете.
1674.40 1684.08 "Анатолий Кулаков" Ну и как side effect, раз этот URI стал невалидным, то с ним недоступны многие трансформации и многие полезные операторы.
1684.08 1691.20 "Анатолий Кулаков" То есть вы не можете, например, запросить фрагменты из этого URI как напрямую, так и косвенно из тех методов, которые неявно используют фрагменты.
1691.20 1696.32 "Анатолий Кулаков" То есть там разделить, например, на хост, на квери, запросить параметры, распарсить из этого URI.
1696.32 1698.28 "Анатолий Кулаков" В общем, это уже все у вас не получится.
1698.28 1711.32 "Анатолий Кулаков" И, соответственно, да, будьте осторожны, потому что это может покарабкать ваш HTTP-реквест, потому что в этот момент вы можете передавать зарезервированные символы, которые передавать не рекомендуется.
1711.32 1718.68 "Анатолий Кулаков" Вот, наверное, с основными вещами по нетворкингу это все, остальное, в принципе, мы с вами уже обсуждали.
1718.68 1724.84 "Игорь Лабутин" Ну, а тогда пойдем в сторону наших любимых тулов, а именно IDE-шек.
1724.84 1727.20 "Игорь Лабутин" Начнем мы с Visual Studio 2022.
1727.20 1732.76 "Игорь Лабутин" Сейчас пока не вышло никаких-то новых превьюшек, насколько я знаю.
1732.76 1747.16 "Игорь Лабутин" Но так же вышла статья, где рассказывается про то, какие же на самом деле улучшения произошли в самой Visual Studio и что вы можете потрогать с точки зрения продуктивити во время дотнет-разработки или для дотнет-разработки.
1747.16 1749.72 "Игорь Лабутин" И на самом деле подборка довольно интересная.
1749.72 1758.60 "Игорь Лабутин" Во-первых, появилась нормальная Source Link Navigation, то есть по F12, если у вас есть Source Link информация, то откроется именно эта штука.
1758.60 1764.00 "Игорь Лабутин" Я не очень понимаю, почему она не была сделана в самом начале, но потому что вроде как, имея Source Link, логичнее идти в него.
1764.00 1769.44 "Игорь Лабутин" Ну, видимо, не хватало времени, сейчас наконец-таки это сделали к релизу, получается, 22 студии.
1769.44 1776.80 "Игорь Лабутин" Дальше появилась интересная штука, она, в принципе, понятное дело, была в Райдере или в ReSharper, это называется Stack Trace Explorer.
1776.80 1791.68 "Игорь Лабутин" То есть если вы теперь посмотрите на Stack Trace, откуда-то его скопировав, то имена в этом Stack Trace, если студия может их распознать, они становятся кликабельными, вы можете по нему навигироваться и, соответственно, будут открываться соответствующие куски кода.
1791.68 1814.84 "Игорь Лабутин" Дальше есть интересная фича, называется Track Value Source, то есть вы можете райт-кликнуть на любой переменной, поле и так далее, и студия автоматически вам подсветит и соберет в отдельном, я так понимаю, окошечке, я еще не пробовал, те места, откуда значение в той строчке, где вы кликнули, может технически получиться, то есть по сути она вытащит все места, где эта переменная присваивается или как-то используется и покажет вам в компактном виде.
1814.84 1826.80 "Игорь Лабутин" Иногда мне кажется, это будет довольно полезно, чтобы так вот одним взглядом охватить вообще все места в какой-нибудь сложной функции или сложной даже последовательности вызова функции, где та или иная переменная могла быть изменена.
1826.80 1829.64 "Игорь Лабутин" Да, если это будет работать хорошо, мне кажется, это будет очень полезно.
1829.64 1837.76 "Игорь Лабутин" Вот, я все хочу попробовать, у меня стоит 22 студия релиз, как раз таки, я не видел, может быть это в превьюшке, правда, и тогда нужно превью ставить, посмотрю.
1837.76 1871.12 "Игорь Лабутин" Фича из этой же примерно серии, команда считает, что довольно часто бывает проблема, что мы как бы переприсваиваем одну и ту же переменную, вместо того, чтобы на самом деле завести другую, новую или делаем это по ошибке, и поэтому теперь можно в опциях в настройках включить, что те переменные, значения которых переприсваивается так или иначе, они будут теперь подчеркиваться, ну, типа прям таким андерлайном, как обычный подчеркнутый стиль, таким образом выделяя их среди, допустим, не знаю, там, ридон или полей класса, которые один раз всего присваиваются, и вы можете быть уверенным, что они не меняются.
1871.12 1878.24 "Игорь Лабутин" Тоже может быть полезно для анализа, наверное, какой-нибудь алгоритмов, когда вы пытаетесь понять, вообще это переменная может поменяться или не может поменяться в этом контексте.
1878.24 1884.08 "Анатолий Кулаков" Интересно, это в принципе такая ридон или переменная получается, что звучит даже странно, если она переменная.
1884.08 1893.48 "Игорь Лабутин" Не, ну почему, если это аргумент функции, например, бывает такое, встречал код, когда ты принимаешь какой-нибудь параметр функции, а потом ты ему же присваиваешь что-то после какого-то куска функции.
1893.48 1904.68 "Анатолий Кулаков" Да, да, я тоже такое часто встречал, даже иногда такое делал, когда мне очень было лень придумать какое-то новое имя, там стоит банальная проверка как бы на null, и мне достаточно всего лишь создать новое значение в одну строчку.
1904.68 1907.04 "Анатолий Кулаков" Тоже был греш.
1907.04 1915.92 "Игорь Лабутин" Ну вот да, не то чтобы я это часто видел, но бывает, и когда ты анализируешь какой-нибудь сложный алгоритм, наверное, интересно внутри функции понимать, эта переменная могла быть поменена или не могла.
1915.92 1919.64 "Игорь Лабутин" Типа если есть подчеркивание, значит могла быть, если нет подчеркивания, значит точно не могла.
1919.64 1920.64 "Игорь Лабутин" Ну посмотрим.
1920.64 1939.28 "Игорь Лабутин" Дальше развивается интеллисенс, заводится то, что в райдере шарпере есть всякие постфиксные штуки, то есть вы теперь можете написать там какому-нибудь там file.read_all_lines_async, дальше круглые скобочки, дальше .await, и это автоматически принесет await в начало.
1939.28 1946.64 "Игорь Лабутин" Ты пользовался когда-нибудь этими постфиксными через точку в решарь при райдере, когда там можно написать .if, .while и прочие такие штуки?
1946.64 1959.96 "Анатолий Кулаков" Да, да, немногими, в принципе, когда я пишу условия, я еще догоняю, что можно и в начале поставить, но вот, например, когда пишешь return, вполне у меня часто срабатывает рефлекс, что я сначала пишу что, я хочу ретурнить, а потом вспоминаю, что надо было ключевое слово слева на позу написать.
1959.96 1968.48 "Анатолий Кулаков" И вот для ретурна, может быть, для, наверное, присваивания и для некоторых таких вот нескольких вещей это довольно удобно, особенно когда знаешь и привыкаешь к этому.
1968.48 1979.76 "Игорь Лабутин" Ну вот мне кажется для await это вообще полезная штука, потому что ты не можешь знать заранее, у тебя там awaitable штука или не awaitable, если особенно ты держишь в какой-нибудь сторонней API, а будет асинхронный там вызов или синхронный.
1979.76 1990.92 "Игорь Лабутин" Вот если ты видишь, что он асинхронный, теперь интеллисенс там пишет в дропдауне, что он awaitable, например, пока он показывает подсказочку в дропдауне, он там будет написан, что он awaitable.
1990.92 1994.40 "Игорь Лабутин" Увидев эту подсказку, ты можешь написать точкой await и он сразу станет с awaitом в начале.
1994.40 1995.40 "Игорь Лабутин" Ну красиво.
1995.40 1997.52 "Игорь Лабутин" Да, да, прекрасно.
1997.52 2012.20 "Игорь Лабутин" Дальше, соответственно, улучшили editor-config-ui, то есть в студии есть свой собственный editor-config, теперь там можно редактировать нормально имена стилей, то есть раньше там были, ой, не имена стилей, эти, стиль наименования, неправильно перевел.
2012.20 2018.96 "Игорь Лабутин" Соответственно, раньше можно было редактировать только обычные опции, которые там true, false, ну и там включить-выключить и какое-то среднее состояние.
2018.96 2025.68 "Игорь Лабутин" А эти вот самые naming styles, они были более сложными, но, соответственно, теперь их тоже можно редактировать.
2025.68 2040.60 "Игорь Лабутин" Завезли кучу новых кофиксов-рефакторингов, в частности, один из них это sync namespaces, то есть можно теперь right-кликнуть на там в своем проекте или папочке внутри solution explorer, сказать синхронизировать namespace и во всех файликах namespace будут поменены в соответствии с иерархией папочек.
2040.60 2058.08 "Игорь Лабутин" Ну такая, не знаю, я не уверен, что я бы пользовался такой фичей, кажется, она довольно опасная, менять так за раз много файлов, но может быть и норм, когда ты твердо знаешь, что ты действительно перенес, например, что-то в новый, не знаю, проект, переименовал полностью свой csproj либо root namespace и тогда действительно удобно.
2058.08 2074.32 "Анатолий Кулаков" Я в ReSharper, ну ReSharper такая штука есть всегда и давно, в общем, я пользуюсь довольно часто, в общем, на моих кейсах это очень частый кейс, когда я там переношу файлики, переименовываю их, папочки там обзываю как-нибудь более логично, не так, как я думал в начале, в общем, я пользуюсь довольно часто, ни разу еще меня не подводило.
2074.32 2076.92 "Анатолий Кулаков" Ну естественно, это все зависит от качества имплементации.
2076.92 2091.16 "Игорь Лабутин" Ну да, ну ладно, вот примерно такие дела в 22 студии, это то, что, собственно, уже либо зарелизлено, либо в 17 превью, соответственно, вставьте превьюшную версию и там будет больше фич и больше багов, вот.
2091.16 2097.68 "Игорь Лабутин" А пока пойдем в другую половину дотнет спектра EDE-шек и поговорим про ReSharper Rider.
2097.68 2106.28 "Анатолий Кулаков" Да, потому что у них тоже был релиз, ReSharper Rider достигли версии 2021.3, что-то мне подсказывает, что в 2021 это все.
2106.28 2113.92 "Анатолий Кулаков" В общем, посмотрим, чем же мы закрываем год, какие новые фишки нас ждут и чем мы будем начинать, соответственно, свой следующий год в этой прекрасной EDE.
2113.92 2126.60 "Анатолий Кулаков" Прежде всего, самая, наверное, важная и главная новость всего этого года в том, что Visual Studio стала 64-битной и, соответственно, эта версия ReSharper полностью поддерживает 64-битную студию тоже.
2126.60 2127.60 "Анатолий Кулаков" Что это значит?
2127.60 2134.56 "Анатолий Кулаков" Соответственно, это значит, что больше никакого лимита по максимально лоцируемой памяти нет, как с хорошей, так и с плохой стороны.
2134.56 2148.32 "Анатолий Кулаков" То есть с хорошей, потому что ReSharper теперь можно много памяти, студии можно много памяти, они теоретически перестанут тормозить, а с плохой, потому что на вашем компьютере теперь должно быть много памяти, иначе ее займут всю и ее станет не хватать.
2148.32 2152.44 "Анатолий Кулаков" А всю память занимать эти товарищи вдвоем умеют.
2152.44 2161.16 "Анатолий Кулаков" Поэтому готовьте больше памяти на вашей компьютере, потому что теперь ваши EDE могут и захотят, соответственно, больше и больше ее пожрать.
2161.16 2170.12 "Анатолий Кулаков" Ну, и также есть плюсов, что ReSharper действительно стал работать намного быстрее, он уже не ужимается в эти жалкие килобайты, которые ему давали для работы.
2170.12 2175.80 "Анатолий Кулаков" В общем, теперь он может работать на полную катушку и говорят, что, в общем, теперь даже ReSharper совсем не тормозит.
2175.80 2181.88 "Анатолий Кулаков" Но посмотрим, посмотрим на фидбэки, посмотрим на следующие доклады, отзывы, действительно ли это помогло.
2181.88 2187.72 "Анатолий Кулаков" Потому что самое главное оправдание ReSharper в том, что они тормозят только по причине того, что Visual Studio 32-битная.
2187.72 2195.64 "Анатолий Кулаков" В общем, теперь его нет, посмотрим, чем компания будет оправдываться дальше, если вдруг кто-то застукает ее тормозящий момент.
2195.64 2197.96 "Анатолий Кулаков" Ну, и по существенным вещам.
2197.96 2213.84 "Анатолий Кулаков" Соответственно, больше поддержки C# 10, поддержанный скоптный Namespaces, это когда вы можете делать Namespaces и при этом не забивать идент, то есть не использовать фигурные скопочки и отступ, продолжать писать класс дальше на том же самом уровне.
2213.84 2222.40 "Анатолий Кулаков" Global usings, соответственно, когда вы можете объявить юзинки в каком-то одном файле, и оно будет распространяться на весь ваш проект или в некоторых случаях даже на Solution.
2222.40 2243.32 "Анатолий Кулаков" Interpolated string handlers — это специальная возможность, которая позволяет написать вам свои собственные хендлеры, которые будут каким-то особым специфичным образом обрабатывать string interpolation, то есть вот эти переменные, которые прямо в стручечку инжектируются и в обычном случае форматируются с помощью string формата, а в необычном с ними можно сделать всего очень много интересного.
2243.32 2251.40 "Анатолий Кулаков" Например, если это SQL-запрос, то сделать какой-нибудь SQL-Escape, чтобы не внедряли никакие плохие штучки в ваши запросы.
2251.40 2260.60 "Анатолий Кулаков" И много других интересных импровизаций, конечно, в C# 10 поддержано практически все, что там можно поддержать и должно работать замечательно.
2260.60 2278.28 "Анатолий Кулаков" Отдельной строкой идет поддержка Nullable reference types, как Framework, как Microsoft, так и JetBrains продолжают работать в этом направлении, потому что это действительно одна из самых крутых фич последних C#, последних .NET, это как раз-таки введение null reference types.
2278.28 2295.72 "Анатолий Кулаков" Во-первых, теперь ReSharper может красиво вставлять скопипастченный код, например, откуда-нибудь из T-Coverflow в ваш EDE и при этом учитывать, включен ли у вас null reference type и писался ли тот код, который вы скопипастили с учетом null reference types.
2295.72 2299.88 "Анатолий Кулаков" Соответственно, и он может то, что вы вставляете, подделать под ваш текущий environment.
2299.88 2307.48 "Анатолий Кулаков" То есть там, где надо вставить вопросики, там, где не надо вставить специальные атрибуты для совместимости со старыми версиями и так далее.
2307.48 2311.20 "Анатолий Кулаков" Все это работает довольно мило и заботливо.
2311.20 2322.36 "Анатолий Кулаков" Также добавилось много новых quickfixes, например, вы можете пофиксить использование переменной в зависимости от того, какой у нее там constraint стоит.
2322.36 2332.76 "Анатолий Кулаков" Что если там выбран, что переменная может быть null и вы ее не проверяете на null, с помощью быстрых quickfixes в эту проверку можно добавить или наоборот убрать, если она не нужна.
2332.76 2347.08 "Анатолий Кулаков" Еще одно интересное выведение это bulk quickfix, когда вы видите, что параметр проверяется в каком-то одном методе, то есть он вполне может быть null или после этого метода он может быть не null и дальше передается в какие-то методы по цепочке.
2347.08 2353.96 "Анатолий Кулаков" В общем, и вы хотите исправить это поведение, вы хотите, чтобы он дальше там, допустим, везде продвигался, как не null был объект.
2353.96 2356.92 "Анатолий Кулаков" В общем, все это вы можете сделать одним quickfix.
2356.92 2368.40 "Анатолий Кулаков" Ари Шарпи вычислит всю иерархию вызовов, вычислит какие проверки там где были и изменит ваш код таким образом, чтобы у вас или не было лишних проверок или наоборот эти проверки добавились.
2368.40 2373.40 "Анатолий Кулаков" В общем, звучит довольно хорошо, звучит как магия, но посмотрим, как это заработает на практике.
2373.40 2376.80 "Анатолий Кулаков" Дальше немного интересных quickfixes.
2376.80 2381.76 "Анатолий Кулаков" Это, во-первых, мы теперь научились анализировать static local и анонимные функции.
2381.76 2392.44 "Анатолий Кулаков" Мы теперь можем узнать, что они захватывают какие-то переменные, что приводит, соответственно, к какому-нибудь лишнему расходу памяти или даже в деградации перформанса.
2392.44 2395.96 "Анатолий Кулаков" Ири Шарпи может помочь вам эту проблему зафиксить.
2395.96 2405.52 "Анатолий Кулаков" Он может переделать это в static local функции или убрать замыкание, переделать это в аргумент вызывающей функции.
2405.52 2414.48 "Анатолий Кулаков" Вот, дальше у нас появилась конвертация классов в рекорды, при том мы теперь можем конвертить с учетом primary конструктора.
2414.48 2420.08 "Анатолий Кулаков" Можно просто сделать primary конструктор, что существенно сократит количество того кода, который у вас уже есть.
2420.08 2428.92 "Анатолий Кулаков" В UI появились интересные новые иконочки, которые позволяют вам навигироваться по использованию этого класса.
2428.92 2438.72 "Анатолий Кулаков" Например, если вы слева увидите букву I со стрелочкой вверх, то это означает, что вы кликнув на нее мышечкой, можете перейти на интерфейс, от которого пронаследован этот класс.
2438.72 2451.16 "Анатолий Кулаков" А если вы хотите перейти на наследников или на тех, кто заверадил какие-то определенные методы, то рядом с этой буковкой еще будет буква O со стрелочками, соответственно, или вверх, или вниз.
2451.16 2453.28 "Анатолий Кулаков" Но новые иконки, не пугайтесь.
2453.28 2462.76 "Анатолий Кулаков" Еще из обновлений поддержано немножко больше language injections.
2462.76 2468.40 "Анатолий Кулаков" Теперь их можно передавать в параметры полей или в свойствах, они тоже могут встречаться.
2468.40 2479.44 "Анатолий Кулаков" Language injections, напомню, это специальные колдунчики у ReSharper, когда у вас в строках, на самом деле, может внутри себя содержать какой-то другой тип.
2479.44 2485.64 "Анатолий Кулаков" Например, внутри строки может быть написан валидный CSS, HTML, JavaScript, JSON или, может быть, даже XML.
2485.64 2494.84 "Анатолий Кулаков" В общем, для C# это все обычный string, но ReSharper умеет иногда соображать, что это не просто string, а, например, те типы, которые я выше перечислил.
2494.84 2496.88 "Анатолий Кулаков" Это называется language injection.
2496.88 2502.60 "Анатолий Кулаков" Иногда он их сам может понимать, иногда вам нужно помочь ему, написав определенный атрибут из JetBrains Annotations.
2502.60 2510.50 "Анатолий Кулаков" И он сделает вам IntelliSense туда, он сделает вам подсветку синтаксиса и, может быть, какие-то базовые ошибки тоже сможет найти.
2510.50 2519.16 "Анатолий Кулаков" Тоже очень удобная вещь, особенно если вы часто используете и работаете с вот этими подмножествами строк.
2519.16 2524.40 "Анатолий Кулаков" В Ryder, соответственно, все то же самое, ну и плюс еще некоторые свои фишки.
2524.40 2528.72 "Анатолий Кулаков" Безусловно, это .NET 6 и добавился hot reload.
2528.72 2534.36 "Анатолий Кулаков" Hot reload у Ryder сделан тоже по-своему, специфично.
2534.36 2537.60 "Анатолий Кулаков" Я надеюсь, что мы сегодня успеем про него отдельно поговорить.
2537.60 2541.68 "Анатолий Кулаков" Вышла официальная поддержка F# 6.
2541.68 2547.36 "Анатолий Кулаков" Был произведен редизайн главного тулбара, тот, которого вы видите в самом верху.
2547.36 2557.32 "Анатолий Кулаков" Действительно, он стал более похож на Visual Studio, и поэтому те, кто переходит с Visual Studio, теперь могут встретить какие-то более понятные, более знакомые кнопочки.
2557.32 2559.28 "Анатолий Кулаков" Может быть, не так страшно будет.
2559.28 2570.56 "Анатолий Кулаков" Вверх перенеслись у нас, то есть вверху появились у нас navigation buttons, то есть можно там входить влево-вправо, кнопочки сбилдить, запустить, отдебажить.
2570.56 2578.16 "Анатолий Кулаков" И вот, что я, в принципе, совсем не ждал увидеть, это кнопочки управления VCS, ну, грубо говоря, GIT.
2578.16 2587.20 "Анатолий Кулаков" То есть вы там можете теперь переключить бранчи, создать новые репозитории, и всё это вот на быстром доступе в главном тулбаре.
2587.20 2593.16 "Анатолий Кулаков" Игорь, тебе часто приходилось переключать бранчи и создавать новые GIT-репозитории, чтобы выносить это в такое видное
2593.16 2596.04 "Игорь Лабутин" место? Не, ну, создавать GIT-репозитории точно нет.
2596.04 2597.40 "Игорь Лабутин" Это действительно странно.
2597.40 2600.48 "Игорь Лабутин" Переключать бранчи, мне кажется, почему нет, вполне да.
2600.48 2612.48 "Игорь Лабутин" У меня это довольно частый кейс, когда я работаю над каким-то своим бранчом, потом надо быстренько переключиться на общий, ну, там, главный мастер бранч, чтобы посмотреть, что там, кому-то что-то показать, потом снова на свой.
2612.48 2615.08 "Игорь Лабутин" Ну, то есть это я могу ещё объяснить.
2615.08 2616.72 "Игорь Лабутин" Зачем создавать GIT-репозитории, не знаю.
2616.72 2625.24 "Игорь Лабутин" А вот то, что вынесли наверх всякие navigation buttons, это прям очень приятно, я прям вот чувствую, прям это мой был фидбэк, когда я попытался пользоваться райдером.
2625.24 2632.84 "Игорь Лабутин" Один из фидбэков, который я писал команде, был про то, что ну, как бы клавиатурой понятно, control-minus, control-plus, ну, не плюс, а control равно фактически.
2632.84 2634.84 "Игорь Лабутин" А как это делать мышью?
2634.84 2637.32 "Игорь Лабутин" Потому что иногда, представь, я пользуюсь райдером мышью.
2637.32 2648.00 "Анатолий Кулаков" Ну, иногда, когда исследуешь код, когда там по нему лазишь, ещё когда-то что-то делаешь, то есть есть кейсы, когда я тоже предпочитаю переходить в мышиный режим и тоже этими кнопками активно пользуюсь, в общем.
2648.00 2651.68 "Анатолий Кулаков" И действительно, не только этих кнопок, очень много у райдера не хватает поддержки мыши.
2651.68 2654.96 "Анатолий Кулаков" Сразу видно, что разработчики райдера, они больше предпочитают клавиатуры.
2654.96 2657.00 "Анатолий Кулаков" В общем, это есть, это нет-нет.
2657.00 2670.88 "Анатолий Кулаков" Хорошо, допустим, да, допустим, бранчей кто-то там быстро переключает, наверное, это не мой use-кейс, я часто так не делаю, а если и делаю, то через, чуть-чуть больше предпочитаю консольку, наверное, чтобы примерно понимать, какие у меня там изменения остались, какие ещё нужно было застешить.
2670.88 2671.88 "Анатолий Кулаков" Вот, ну ладно.
2671.88 2683.48 "Анатолий Кулаков" А как тебе вот другой WTF, который у меня вызвался, это Search Everywhere, они перенесли в Main Button, то есть мне кажется, что даже в студии им никогда никто не пользовался.
2683.48 2692.56 "Анатолий Кулаков" Это как раз то поле, которое вы можете кликнуть и найти там всё, что угодно, вбить от настроек до вашего имени класса и до имени файла, и он вам найдёт всё, что угодно.
2692.56 2701.36 "Анатолий Кулаков" То, что нормальные люди вызывают через Ctrl+T в ReSharper, неужели вот ты тоже кликаешь мышкой в правый верхний угол для того, чтобы что-то отыскать на клавиатуре, вбивая после этого имя?
2701.36 2705.08 "Игорь Лабутин" Нет, да, действительно, даже если я навигируюсь мышью, всё равно Ctrl+T.
2705.08 2714.44 "Анатолий Кулаков" Ну да, потому что после того, как ты сделал фокус на этом поле, ты в любом случае будешь использовать клавиатуру и там что-то какое-то писать текст, тебе бессмысленно мышкой это делать.
2714.44 2715.44 "Анатолий Кулаков" Ну да.
2715.44 2717.08 "Анатолий Кулаков" Поэтому у них сейчас сразу переключится на Ctrl+T.
2717.08 2718.08 "Игорь Лабутин" Всё так.
2718.08 2719.08 "Игорь Лабутин" Ну ладно.
2719.08 2724.44 "Игорь Лабутин" Непонятно, зачем, ну, наверное, просили, то есть в принципе же это всё фидбэки, то есть, наверное, кто-то пользует это в таком варианте.
2724.44 2729.04 "Анатолий Кулаков" Наверное, ну опять же, никто не мешает вам это всё настроить под вас и как вам будет удобно, безусловно.
2729.04 2733.20 "Анатолий Кулаков" Самое, наверное, приятное, что здесь есть, это новый дебаг-экспириенс.
2733.20 2746.84 "Анатолий Кулаков" Наконец-то переделали этот ужасный, непонятный, неочевидный дебаг окна, которые были у райдера, которые достались, наверняка, с предыдущих реинкарнаций ID.
2746.84 2750.68 "Анатолий Кулаков" Теперь это более или менее всё похоже, опять же, на Visual Studio.
2750.68 2751.68 "Анатолий Кулаков" Новая дебаг-винда у нас ждёт.
2751.68 2770.32 "Анатолий Кулаков" У нас будут такие табики, как треды, переменные, дебаг-аутпут, консоль-аутпут, то есть то, что в принципе мы и ожидали из Visual Studio, но они были в райдере, но они были не там, не под теми кнопочками.
2770.32 2776.36 "Анатолий Кулаков" То есть они были какими-то левыми кнопками, они немножко, некоторые объединялись, некоторые наоборот разносились.
2776.36 2785.60 "Анатолий Кулаков" В общем, теперь эти кнопочки сделаны вверху, теперь эти вкладочки правильно сделаны, теперь они как-то с друг другом более соотносятся, так как все привыкли в Visual Studio.
2785.60 2789.56 "Анатолий Кулаков" Ну, наверное, уже не все, но большинство стартпёров привыкло видеть это в Visual Studio.
2789.56 2793.28 "Анатолий Кулаков" Игорь, ты ждал обновлённого дебаг-винду?
2793.28 2795.52 "Игорь Лабутин" Да, обновлённый дебаг-винду однозначно.
2795.52 2806.52 "Игорь Лабутин" Я хочу посмотреть, я буду обновлять райдер, когда у меня будут свободные руки, потому что это была тоже одна из, так скажем, ну не то что претензий, но довольно таких больших болей.
2806.52 2826.80 "Игорь Лабутин" Больше всего, мне кажется, я искал кнопочку, знаешь, вот когда ты там, не знаю, у тебя эксепшн произошёл, ну или даже не эксепшн, а ты просто остановился где-то по брэкпойнту, а потом ты пошёл что-то по коду навигироваться, там Ctrl+T я понажимал, мышкой покликал куда-нибудь, там на какие-нибудь наследники, вызывающие, ну в общем, куда-то далеко ушёл, и хочешь вернуться в то место, где ты сейчас находишься.
2826.80 2830.28 "Игорь Лабутин" Где, собственно, вот остановка-то произошла, эту жёлтую стрелочку найти обратно.
2830.28 2831.28 "Игорь Лабутин" Ну тебе стэктрейс нужно.
2831.28 2846.00 "Игорь Лабутин" Мне даже не, ну да, либо нужно идти в стэктрейс и кликнуть на верхний фрейм, либо, ну в студии была там такая кнопочка со стрелочкой, вот в дебажном тулбаре, по-моему, самое левое, если я правильно помню, ну короче, она как-то визуально помнится, ты на неё кликаешь и ты всегда в это место приходишь.
2846.00 2848.52 "Игорь Лабутин" В райдере я её обыскался.
2848.52 2858.48 "Игорь Лабутин" Ну то есть, во-первых, я нашёл шорткат, да, Alt+Numpad*, но у меня на ноутбуке нет нумпада, его даже как бы не включить, поэтому не работает, вот.
2858.48 2860.80 "Игорь Лабутин" А во-вторых, кнопку я в итоге нашёл.
2860.80 2882.56 "Игорь Лабутин" Кнопка выглядит, я не знаю, ты помнишь или нет, райдер русский дебаггер, выглядела, возможно, сейчас они это обновили, я посмотрю, как вот такая, знаешь, стандартная типа какая-нибудь андроидная менюшка из трёх горизонтальных чёрточек, где средняя чёрточка, она немножко другого цвета, ну как бы подразумевая, что вот как бы именно на неё тебя и переведут, это оказывается кнопка перехода, я считал, что это меню и я туда не нажимал, вот.
2882.56 2885.80 "Игорь Лабутин" Но потом выяснилось, что всё-таки не меню и нажал, значит, нашёл.
2885.80 2900.64 "Игорь Лабутин" Поэтому да, layout окна дебага вот этих всех тулбан, ну наших, да, маленьких дебага, он был какой-то странный, с кучей тулбаров, там же был тулбар сверху, тулбар слева, ну хорошо, не было тулбара снизу и справа,
2900.64 2905.44 "Анатолий Кулаков" вот. Я думаю, это настраивается, мы могли бы тебе сделать и тулбар левый, и справа.
2905.44 2908.92 "Игорь Лабутин" Возможно, ну короче, он какой-то такой, да, нелогичный немножко для меня.
2908.92 2912.56 "Анатолий Кулаков" Да-да, он просто не под наш опыт, мы учились на других тулбарах.
2912.56 2922.48 "Анатолий Кулаков" Слушай, а мне ещё сильно не хватает очень quick view, я иногда, когда нужно рассмотреть глубокую переменную, я люблю её открыть прям в отдельном большом quick view и начать там копать, фильтровать, смотреть, ещё что-то сделать.
2922.48 2929.12 "Анатолий Кулаков" В общем, мне кажется, до сих пор не появилось, поэтому тоже хотелось бы, чтобы они как-то этот дебаг-экспириенс получали.
2929.12 2933.56 "Игорь Лабутин" Сейчас, подожди, quick view, ты что имеешь в виду?
2933.56 2943.00 "Анатолий Кулаков" Окошко, когда ты можешь в одном окошке просто вбить переменную, и он тебе откроет её просто посреди твоего из студии в отдельном окне, ну с возможностью плюсиков
2943.00 2947.44 "Игорь Лабутин" и копания вглубь. Прикольно, ты мне рассказал новую фичу студии, которую я не знал.
2947.44 2949.56 "Игорь Лабутин" Ну или может я знал, но как-то не пользовался.
2949.56 2965.08 "Игорь Лабутин" Я в watch, соответственно, смотрю, и максимум, что я делаю на всяких строчках и так далее, можно же ткнуть на вот рядом с value иконочкой и открыть её в отдельном окошке, но это именно прям посмотреть контент, например, большой строки или какой-нибудь большой xml в строке и так далее.
2965.08 2966.08 "Анатолий Кулаков" Это единственное.
2966.08 2969.16 "Анатолий Кулаков" Это ты только для одной строки можешь посмотреть, действительно.
2969.16 2970.16 "Анатолий Кулаков" Да.
2970.16 2971.16 "Анатолий Кулаков" Вот.
2971.16 2975.72 "Анатолий Кулаков" Также точно ты можешь сделать quick view, грубо говоря, и ты посмотришь одну эту переменную в отдельном окошечке.
2975.72 2976.72 "Анатолий Кулаков" Окей.
2976.72 2991.04 "Анатолий Кулаков" Что бывает нужно, знаешь, когда у тебя там какая-то, не знаю, большая перемена, она внутри содержит десяток каких-то препертитов, например, http-request ты рассматриваешь, какие там у тебя пришли хидра, какое там пришло body, кто там постраивался в идентике, где барьеры, где что.
2991.04 3001.16 "Анатолий Кулаков" Тебе это надо рассмотреть, и в одном маленьком дебак, вот этом окошечке, который занимает 10-20% всего нижнего тулбарчика, это рассмотреть обычно довольно тяжело.
3001.16 3007.76 "Анатолий Кулаков" Поэтому открываешь просто на весь экран или на полэкрана и начинаешь вглубь её копать, смотреть, раскрывать.
3007.76 3008.76 "Анатолий Кулаков" Очень полезная штука.
3008.76 3009.76 "Игорь Лабутин" Прикольно, попробую.
3009.76 3011.92 "Игорь Лабутин" Видишь, что-то полезное из подкаста вынес.
3011.92 3012.92 "Игорь Лабутин" Класс.
3012.92 3013.92 "Игорь Лабутин" На каком?
3013.92 3014.92 "Игорь Лабутин" В 42-м выпуске.
3014.92 3015.92 "Игорь Лабутин" Нормально?
3015.92 3017.72 "Анатолий Кулаков" Да, не зря начали.
3017.72 3023.20 "Анатолий Кулаков" Надо ещё джедбрендсов сообщить, может, они тоже никогда не пользовались, поэтому я зря жду, надо намекнуть,
3023.20 3025.20 "Игорь Лабутин" что оно есть. Нормально.
3025.20 3028.12 "Игорь Лабутин" Ну хорошо, в общем, debugging experience, надеюсь, улучшился.
3028.12 3033.76 "Игорь Лабутин" Когда поставлю новый райдер, я сейчас довольно много работаю именно в райдере, проверю, посмотрю.
3033.76 3041.84 "Анатолий Кулаков" Вот, ещё появился новый problem view window, это, в общем, тоже, наверное, в студии уже такая штука была или примерно к этому была.
3041.84 3049.48 "Анатолий Кулаков" В общем, это окно, где вы можете посмотреть ворнинги и эрроры просто со всего подряд, начиная от текущего файла и заканчивая вообще всем солюшеном.
3049.48 3056.72 "Анатолий Кулаков" И там будут собираться не только проблемы вашего кода, но и проблемы, например, всего тулинга и всего инваридента, который есть снаружи.
3056.72 3068.20 "Анатолий Кулаков" Допустим, если NuGet не смог что-то восстановить или не смог вам выдать какие-то пакеты, не смог проверить версию или наоборот проверил, а эта версия security уязвимая, в общем, всё это вы увидите в новом problem view window.
3068.20 3072.52 "Анатолий Кулаков" Тоже, кажется, такая полезная точка для того, чтобы туда чаще за чаще поглядывать.
3072.52 3073.52 "Анатолий Кулаков" Другие апдейты.
3073.52 3085.48 "Анатолий Кулаков" Это улучшилась language injection, в частности, как раз-таки SQL language injection появился, поддержка Apple Silicon процессоров.
3085.48 3093.44 "Анатолий Кулаков" Ещё одна интересная фишка появилась, которой мне давно не хватало, это переформатирование и cleanup в момент сейва.
3093.44 3100.04 "Анатолий Кулаков" То есть, как только ваш файлик сохраняется, к нему автоматически применяются все те правила, которые вы хотите, и он форматируется красиво.
3100.04 3103.88 "Анатолий Кулаков" Ставятся правильные отступы, ставятся правильные скобочки и всё как положено.
3103.88 3106.76 "Анатолий Кулаков" В общем, тоже для педантов отличная вещь.
3106.76 3113.32 "Анатолий Кулаков" Если сделать её ещё вместе с каким-нибудь автосейвом, который автоматически происходит, то вообще красота будет.
3113.32 3120.60 "Анатолий Кулаков" И, естественно, обновился весь зоопарк tools, .cover, .memory, .pick, .trace, вот все вот эти парни, которые помогают нам ежедневно.
3120.60 3127.36 "Анатолий Кулаков" У них тоже появились новые какие-то фишечки, ну и самое заметное из них просто это поддержка Apple Silicon процессоров.
3127.36 3133.08 "Анатолий Кулаков" Это, в принципе, во всём этом релизе поддержано практически всем, где можно это поддержать.
3133.08 3134.08 "Игорь Лабутин" Ну, прекрасно.
3134.08 3144.20 "Игорь Лабутин" А если мы говорим про Apple Silicon, то мы не можем не сказать про, собственно, Mac-версию Visual Studio, которая тоже обновилась, Visual Studio 22 Mac Preview 4.
3144.20 3153.92 "Игорь Лабутин" И там не так много изменений, как, собственно, в основной студии это обычно происходит, но они тоже такие интересные, и давайте быстренько по ним пробежимся.
3153.92 3160.88 "Игорь Лабутин" Во-первых, UI-чик маковской студии всячески пытается быть похожим на UI-чик обычной студии Windows.
3160.88 3173.28 "Игорь Лабутин" И теперь там, наконец-таки, можно все вот эти вот мелкие окошечки типа Solution Explorer и всего остального, наконец-таки, таскать по всему окну и докать их, как вы любите.
3173.28 3178.52 "Игорь Лабутин" То есть, как вы могли в студии там докнуть их влево, вправо, вверх, вниз, с учетом ширины, без учета ширины.
3178.52 3182.08 "Игорь Лабутин" Теперь все это можно сделать и в маковской студии.
3182.08 3190.08 "Игорь Лабутин" Дальше в окошке поиска, ну, точнее, все расчерезало тогда, когда вы что-то там поискали, какой-то usage в коде и так далее.
3190.08 3193.64 "Игорь Лабутин" Теперь есть разные группировки по файлам, по проектам и так далее.
3193.64 3200.36 "Игорь Лабутин" Тоже удобная штука периодически, например, нужно поискать все, но кроме тестов, то группировка по проекту сильно помогает.
3200.36 3227.68 "Игорь Лабутин" Дальше продолжается работа над тем, чтобы UI-чик был нативный и они в комментах к этому посту написали, что внутри они используют Xamarin Mac для этого, то есть Visual Studio 2022 for Mac, она по сути написана на Xamarin, ну, и используют, соответственно, дальше уже Xamarin-овские нативные штуки, там, native binding, control, чтобы показывать это красиво на Mac OS 7.
3227.68 3241.72 "Игорь Лабутин" При этом в студии для Mac до сих пор нет полноценной поддержки M1, я так понимаю, что там все еще работает через эмуляцию, но они над этим работают и в ближайшем либо не в ближайшем превью завезут уже полноценную, вроде как обещают поддержку M1.
3241.72 3246.20 "Игорь Лабутин" Так что ждем, должно стать, ну как, быстрее и все такое, как-то так.
3246.20 3251.76 "Игорь Лабутин" Пойдем дальше, ты обещался про Hot Reload, что-нибудь попробовать в райдере, поговорить подробнее?
3251.76 3257.88 "Анатолий Кулаков" Да, вышла прекрасная статичка, которая называется о том, как же все-таки в райдере работает Hot Reload под капотом.
3257.88 3263.64 "Анатолий Кулаков" Интересно разобрать, потому что много, много есть нюансов.
3263.64 3266.40 "Анатолий Кулаков" Во-первых, давайте поговорим о Hot Reload.
3266.40 3273.08 "Анатолий Кулаков" Hot Reload настоящий такой большой, понятный, который более или менее нормально работает, привнесли с .NET 6.
3273.08 3284.52 "Анатолий Кулаков" И, соответственно, он вам помогает в тот момент, когда вы сделали какие-то изменения в вашем коде, и в данный момент ваше приложение работает, внедрить эти изменения в коде в ваше работающее приложение.
3284.52 3292.60 "Анатолий Кулаков" Без явной перекомпиляции, без пауз, без остановки вашего приложения, просто оно на лету подхватывает ваши изменения, прямо как магия.
3292.60 3305.56 "Анатолий Кулаков" Если вы как-нибудь верстали странички, допустим, вы могли с этим часто встречаться, потому что обычно браузер очень легко и очень быстро перезапрашивает те странички, которые, например, лежат у вас на диске.
3305.56 3309.88 "Анатолий Кулаков" Если вы там аж тумэль поменяли, то браузер это мгновенно способен подхватить и вам отобразить.
3309.88 3321.96 "Анатолий Кулаков" И вообще эта технология, она очень распространилась благодаря UI, потому что вы визуально можете понять, что у вас изменилось с точки зрения UI пользователя, юзабилити и так далее.
3321.96 3327.00 "Анатолий Кулаков" Но, естественно, и без UI в этой технологии полно плюсов.
3327.00 3343.88 "Анатолий Кулаков" Соответственно, она очень популярна была, если вдруг вы пользовались такой фишкой Visual Studio, как Debug and Continue, когда вы под дебагом могли поменять какой-то прям код, и этот код автоматически студия подхватывала, перекомпилировала и внедряла непосредственно в ваше приложение, и ваше приложение продолжало работать.
3343.88 3348.32 "Анатолий Кулаков" Я, например, сталкивался с таким, когда приложение очень долго запускалось.
3348.32 3354.36 "Анатолий Кулаков" Например, ему там для старта нужно было 10 минут, и просто так перезапускать каждый раз его было очень проблематично.
3354.36 3363.88 "Анатолий Кулаков" И вот там разработчики сильно любили вот такие вот подобные хаки, которые позволяли немножко менять логику, немножко отлаживать, немножко что-то добавлять, убавлять без полной перекомпиляции.
3363.88 3380.76 "Анатолий Кулаков" И вот, соответственно, в Raider в последних версиях введена поддержка ход релоуда, соответственно, у Visual Studio тоже, и, наверное, если вы помните наш выпуск про релиз вообще DotNet 6, ход релоуда теперь просто есть везде.
3380.76 3387.20 "Анатолий Кулаков" Все про него пишут, все про него галдят, все его поддерживают, в том числе там командные строки и так далее.
3387.20 3390.64 "Анатолий Кулаков" Фактически, визуально это выглядит следующим образом.
3390.64 3402.84 "Анатолий Кулаков" Вы меняете код, и если этот код способен за ход релоудиться, то у Raider появляется плашка сверху и всплывающая лампочка слева, которая называется "применить изменения".
3402.84 3407.04 "Анатолий Кулаков" Вообще, вы жмакаете "применить изменения", и в этот момент происходит магия.
3407.04 3415.92 "Анатолий Кулаков" Весь ваш код перекомпилируется в памяти, в сборке, и внедряется непосредственно в работающее приложение.
3415.92 3419.28 "Анатолий Кулаков" Внедряется как и сам IL, так и PDB-шки.
3419.28 3424.00 "Анатолий Кулаков" То есть, вся отладочная информация тоже никуда не теряется, все это у вас есть.
3424.00 3426.80 "Анатолий Кулаков" Соответственно, как это делает Visual Studio?
3426.80 3428.84 "Анатолий Кулаков" Она использует компайлер WorkSpaces.
3428.84 3446.96 "Анатолий Кулаков" Это специальный API из Рослина, который умеет парсить синтоксическое дерево, из него извлекать блоки компиляции, добавлять какие-то мета-референсы и, используя вот эту информацию, потом уже дальше каким-то образом прокидывать это в запущенное приложение.
3446.96 3454.16 "Анатолий Кулаков" Прелесть MS Build WorkSpaces заключается в том, что он уже за вас делает много низкоуровневых вещей.
3454.16 3461.68 "Анатолий Кулаков" То есть, вы оперируете такими понятиями, как Solution, дай мне перечисление проектов, сделай мне компиляцию и все в этом духе.
3461.68 3467.16 "Анатолий Кулаков" Вы уже не заморачиваетесь ни о том, какой там исходный код, какие там референсы, какие там зависимости, ну, где ты.
3467.16 3468.16 "Анатолий Кулаков" В общем, это все делается под капотом.
3468.16 3475.40 "Анатолий Кулаков" Соответственно, вы легко можете перекомпилировать любой проект и найти его PDB-шки, зависимости, все что угодно.
3475.40 3487.56 "Анатолий Кулаков" Но ReSharper не использует MS Build WorkSpaces, потому что у ReSharper есть своя модель Solution, и держать в памяти нескольких моделей это довольно-таки разночительно.
3487.56 3491.68 "Анатолий Кулаков" Поэтому у них есть свой Rider WorkSpace.
3491.68 3506.20 "Анатолий Кулаков" Rider WorkSpace использует IEditInContinueWorkSpaceService, специальный хук, который позволяет ему дальше из той информации, которую он скомпилировал, прокинуть весь этот скомпилированный или PDB-шки в работающее приложение.
3506.20 3520.84 "Анатолий Кулаков" Соответственно, давайте же рассмотрим, каким образом происходит непосредственно применение того нового приложения, которое только что Rider скомпилировал и готов каким-то образом в наше приложение внедрить.
3520.84 3522.36 "Анатолий Кулаков" Как же это происходит?
3522.36 3523.72 "Анатолий Кулаков" Вообще есть две технологии.
3523.72 3529.84 "Анатолий Кулаков" Во-первых, если вы запустились под дебаггером, для вас сработает JIT с помощью JITA.
3529.84 3537.88 "Анатолий Кулаков" У него есть специальные методы, которые как раз-таки используются в EditInContinue, который умеет под дебаггером все это делать.
3537.88 3545.12 "Анатолий Кулаков" Если вы запустились не под дебаггером, то используется специальный .NET 6 API, который тоже умеет применять изменения.
3545.12 3556.76 "Анатолий Кулаков" Итак, если мы берем EditInContinue, то там вся информация, которая собирается компилятором во время перекомпиляции, передается JIT, у которого есть специальный I-CoreDebugModule2.
3556.76 3560.76 "Анатолий Кулаков" И у него есть метод, который называется ApplyChanges.
3560.76 3568.60 "Анатолий Кулаков" Вот в этот метод и передаются все новые откомпилированные байтики, все новые откомпилированные значения, PDB-шки.
3568.60 3571.68 "Анатолий Кулаков" И он их применяет просто-напросто на приложение.
3571.68 3576.80 "Анатолий Кулаков" Нужно отметить, что этот способ EditInContinue, он поддерживается только в Windows.
3576.80 3583.04 "Анатолий Кулаков" Поэтому ход reload в райдере под дебагом сейчас работает и сейчас доступен только в Windows.
3583.04 3594.36 "Анатолий Кулаков" Более универсальный подход, соответственно, без дебаггера, без Windows, без EditInContinue, это как раз таки ход reload с помощью нового API.
3594.36 3595.36 "Анатолий Кулаков" МетодataUpdater.update.
3595.36 3598.36 "Анатолий Кулаков" Что происходит в этом случае?
3598.36 3603.64 "Анатолий Кулаков" В этом случае к вам в приложение подсаживается специальный ход reload агент.
3603.64 3607.36 "Анатолий Кулаков" Подсаживается он с помощью метод hook.
3607.36 3609.12 "Анатолий Кулаков" Ход reload агент - это обычная сборка.
3609.12 3614.16 "Анатолий Кулаков" Соответственно, с помощью hook вы можете подгрузить вообще любую сборку.
3614.16 3617.24 "Анатолий Кулаков" Мы обсуждали их под темой host startup hook.
3617.24 3621.20 "Анатолий Кулаков" В общем, с помощью такого hook загружается любая сборка.
3621.20 3624.20 "Анатолий Кулаков" И, соответственно, райдер такую сборку внедряет в ваше приложение.
3624.20 3628.44 "Анатолий Кулаков" И вот этот агент общается с помощью райдера через NameItPipe.
3628.44 3640.08 "Анатолий Кулаков" Соответственно, передает ему всю нужную информацию и забирает из райдера тот райдеровый workspace, который он откомпилировал, который пользователь изменил.
3640.08 3646.64 "Анатолий Кулаков" В общем, всю ту бинарную информацию, уже откомпилированную, которую вы только что поменяли.
3646.64 3651.52 "Анатолий Кулаков" Забирает ее и передает ее в метод data updater, в метод applyUpdates.
3651.52 3659.92 "Анатолий Кулаков" Это, опять же, новый метод, который просто-напросто принимает всю бинарную информацию и применяет ее к текущему процессу.
3659.92 3669.80 "Анатолий Кулаков" Он умеет принимать, соответственно, сборку, которая была изменена, какие-то метаданные по этой сборке и pdb.
3669.80 3673.48 "Анатолий Кулаков" В общем, соответственно, тоже, чтобы отладочную информацию не потерять.
3673.48 3679.32 "Анатолий Кулаков" Вот так вот легко вы можете проапдейтить практически все, захотрелодить практически все.
3679.32 3688.52 "Анатолий Кулаков" Практически потому, что все-таки есть некоторые ограничения и у edit and continue, и в метод data updater все-таки есть ограничения.
3688.52 3693.20 "Анатолий Кулаков" То есть, некоторые методы он не может таким образом заинлайнить, заапдейтить.
3693.20 3696.76 "Анатолий Кулаков" Если вам интересно, есть подробный список в репозитории Рослина.
3696.76 3702.36 "Анатолий Кулаков" На что стоит принципиально обратить внимание, это он не сможет зареплейсить те методы, которые уже выполняются.
3702.36 3717.84 "Анатолий Кулаков" То есть, если, допустим, у вас написан какой-то бесконечный цикл, и в этом цикле вы выводите какую-то переменную в консоль, и после этого вы пытаетесь каким-то образом обновить вывод этой переменной у себя в коде, то у вас ничего не получится.
3717.84 3722.12 "Анатолий Кулаков" Потому что как раз именно в этот момент, вот этот метод, он будет выполняться.
3722.12 3724.28 "Анатолий Кулаков" Потому что цикл у вас бесконечный, он выполняется всегда.
3724.28 3738.88 "Анатолий Кулаков" Элементарный хак, просто выносите в ride переменной в новый метод, и уже такой метод может найти маленькую лазейку, когда как раз call stack выйдет из этого метода, его уже, соответственно, можно будет подменить.
3738.88 3748.88 "Анатолий Кулаков" В общем, такие маленькие хитрости, если вы хотите писать код уже нацеленный на то, чтобы всегда можно было использовать hot reload, вот вам о них нужно знать.
3748.88 3753.28 "Анатолий Кулаков" Подробности, соответственно, вы можете почитать в прекрасной статье от компании JetBrains.
3753.28 3762.20 "Игорь Лабутин" Но мне кажется, вряд ли вы будете писать прямо код нацеленный на hot reload, потому что hot reload это все-таки штука для разработчиков, она никак не относится к продакшену.
3762.20 3775.56 "Игорь Лабутин" И удобно, конечно, писать такой отлаживаемый код, но на самом деле не стоит знать, что он зацикливается, просто нужно эти ограничения знать, когда вы именно разрабатываете и пытаетесь применить этот hot reload в процессе именно разработки.
3775.56 3799.80 "Игорь Лабутин" И второй момент, который я хотел отметить, ты сказал, что Rider использует специальный compiler hook через интерфейс IEdit and continue в Workspace Service, так вот если вы посмотрите, этот интерфейс, он на самом деле internal в Roslin, и Rider на самом деле используется в собственный fork Roslin и кастомный билд, где поменены исходники Roslin, чтобы нужные типы были public.
3799.80 3804.00 "Игорь Лабутин" Поэтому там такой очень кастомный Roslin используется с некоторыми изменениями.
3804.00 3806.88 "Игорь Лабутин" Не знаю, зачем вы об этом знаете, но мне показалось забавным.
3806.88 3807.88 "Игорь Лабутин" Ну что, пойдем дальше.
3807.88 3808.88 "Игорь Лабутин" Есть у нас еще что-нибудь?
3808.88 3817.32 "Анатолий Кулаков" Да, и не просто что-нибудь, а, наверное, я не знаю, какая у нас на памяти еще русскоязычные статички прилетали.
3817.32 3818.48 "Анатолий Кулаков" Мне кажется, уже давно не было.
3818.48 3820.72 "Анатолий Кулаков" Ты помнишь, когда у нас были русскоязычные статьи?
3820.72 3821.72 "Анатолий Кулаков" Нет.
3821.72 3822.72 "Анатолий Кулаков" Да, я тоже.
3822.72 3826.56 "Анатолий Кулаков" Надо поднять как бы статистику и проверить к новогоднему выпуску, посмотреть.
3826.56 3836.16 "Анатолий Кулаков" Но на самом деле мы не берем русские статьи не потому, что мы ненавидим русский язык и все в этом духе, а просто потому, что мало достойного появляется, в общем.
3836.16 3847.36 "Анатолий Кулаков" И в принципе эту статичку я наверняка бы пропустил, потому что все затронутые в ней технологии мы обсуждали, но она прекрасна тем, что очень правильные и полезные технологии были соединены вместе.
3847.36 3853.60 "Анатолий Кулаков" И я говорю сейчас про структурное логирование и интерполирование строк в C# 10.
3853.60 3858.60 "Анатолий Кулаков" И самая прекрасная вещь, что сам Блумхард не знал о том, что так можно делать.
3858.60 3863.88 "Анатолий Кулаков" И, в общем, после того, как мне на GitHub Блумхард ответил, нифига себе, я даже об этом так не задумывался.
3863.88 3874.56 "Анатолий Кулаков" То есть сам человек, который, можно сказать, придумал и популяризировал структурное логирование, не знал, что вот так вот можно сделать структурное логирование, я решил все-таки отдать должное автору и осветить статичку.
3874.56 3879.04 "Анатолий Кулаков" Итак, поприветствуем нечастый гость в нашем подкасте HUBR.
3879.04 3881.80 "Анатолий Кулаков" Структурное логирование на интерполированных строках в C# 10.
3881.80 3889.52 "Анатолий Кулаков" Как вы, наверное, знаете, из наших выпусков мы обсуждали очень много и структурное логирование, и интерполирование строк.
3889.52 3893.64 "Анатолий Кулаков" И в 10 C# появилась интересная фишка, которую я уже сегодня упоминал.
3893.64 3896.72 "Анатолий Кулаков" Это как раз написание своих собственных interpolated string handlers.
3896.72 3906.84 "Анатолий Кулаков" То есть вы можете просто написать строку, поставить перед ней значок вопроса, который будет говорить, что это интерполируемая строка, и внутри использовать переменную из контекста.
3906.84 3912.56 "Анатолий Кулаков" Обычно вы ожидаетесь, что просто-напросто эти переменные отформатируются в эту строку и превратятся в обычную строчку.
3912.56 3916.28 "Анатолий Кулаков" И до 6.NET как раз таки так и было.
3916.28 3918.84 "Анатолий Кулаков" Практически ничего другого мы от этого и не ожидали.
3918.84 3921.44 "Анатолий Кулаков" Но теперь вы можете делать свои handlers.
3921.44 3926.18 "Анатолий Кулаков" И это очень удобная точка расширения для многих-многих интересных задач.
3926.18 3930.84 "Анатолий Кулаков" Потому что строка на самом деле, она внутри себя имеет очень часто каких-то семантических подтипы.
3930.84 3936.56 "Анатолий Кулаков" Например, те, которые я уже сообщал, и JSON, и HTML, и еще что-то, Regex там внутри можно передавать.
3936.56 3943.20 "Анатолий Кулаков" Или, например, типичный случай, когда вы в строку пытаетесь с помощью строки пытаетесь отформатировать SQL.
3943.20 3946.76 "Анатолий Кулаков" У SQL есть одна очень большая проблема, в нем нелегко сделать injection.
3946.76 3959.52 "Анатолий Кулаков" То есть если вы пользовательский вот просто так запихиваете в строчку, то это значит, что ваше приложение очень легко хакнуть и вытащить абсолютно любую информацию, которая есть в вашей базе данных, или просто ее напросто удалить.
3959.52 3969.92 "Анатолий Кулаков" Чтобы такого не происходило, опять же, есть у Entity Framework специальные методы, которые позволяют безопасно вам пользовательски вот добавлять при формировании SQL внутри ваших запросов.
3969.92 3981.88 "Анатолий Кулаков" Или вы можете просто-напросто использовать специальные магические interpolated string handlers, которые перед тем, как добавить вот эту переменную в вашу SQL query, возьмут его из Escaped.
3981.88 3985.84 "Анатолий Кулаков" И таких примеров можно произвести большое-большое количество.
3985.84 3989.68 "Анатолий Кулаков" В частности, у нас есть прекрасное структурное логирование.
3989.68 4004.16 "Анатолий Кулаков" И структурное логирование оно специфично тем, что вы должны указывать внутри строки, внутри месседжа, который вы пишете, название переменных и плюс потом отдельным параметром передавать ту же самую переменную.
4004.16 4015.84 "Анатолий Кулаков" С самых первых версий на GitHub существуют issues для всех подряд и к Serilog, и к Microsoft, и ко всем подряд, что давайте мы как-то вот это дублирование кода уберем.
4015.84 4025.28 "Анатолий Кулаков" То есть нам не хочется и название переменной в message template в строке сообщать и соответственно саму переменную потом другим параметрам туда передавать.
4025.28 4038.08 "Анатолий Кулаков" Но до этого момента ничего практически сделать было невозможно, потому что C# не давал возможности в интерполированных строках узнать имя той переменной, которую туда передают.
4038.08 4044.52 "Анатолий Кулаков" Была возможность отдельно получить значение, но вот имя, под которым пришла туда эта строка получить было нереально.
4044.52 4056.48 "Анатолий Кулаков" И в принципе все вот эти миллиардные дискуссии, которые разворачивались в основном с участием Николаса Блумхарта, они сталкивались непосредственно в это, что имя зарезуловить нельзя, все, message template работать не будет.
4056.48 4064.20 "Анатолий Кулаков" Все остальное это какие-то суровые хаки, на которые message template не рассчитаны и ничего хорошего из этого не будет.
4064.20 4065.20 "Анатолий Кулаков" На этом и решили.
4065.20 4072.76 "Анатолий Кулаков" Но соответственно пришел новый .NET и принес нам custom interpolated string handler.
4072.76 4073.76 "Анатолий Кулаков" Что это значит?
4073.76 4082.16 "Анатолий Кулаков" Соответственно теперь у нас есть некая структурка, которая умеет не просто-напросто принимать в себя интерполированную строку, но принимать ее по частям.
4082.16 4086.32 "Анатолий Кулаков" Одна отдельно может принять шаблон, отдельно может принять каждую переменную.
4086.32 4092.12 "Анатолий Кулаков" Ситуация изменилась еще потому, что у нас появился один замечательный атрибут, который называется color argument expression.
4092.12 4101.76 "Анатолий Кулаков" Он позволяет вам получить в виде строки тот expression, который передал вызывающая строка в этот аргумент.
4101.76 4119.88 "Анатолий Кулаков" Ну если проще говорить, что если вы вызвали метод с параметром, который помечен таким атрибутом, и передали туда просто переменную, которая называется user, то соответственно этот метод может получить не только значение user, но и имя этой переменной, и имя этого юзера.
4119.88 4126.92 "Анатолий Кулаков" Соответственно это немножко как раз таки и подвигает вот эту идею, что мы теперь не можем получать имена переменной просто так из интерполированной строки.
4126.92 4127.92 "Анатолий Кулаков" Немножко дальше.
4127.92 4152.96 "Анатолий Кулаков" То есть, если мы пишем extension метод для iLogger, который принимает интерполированную строку, эту строку разбирает с помощью custom interpolated string handler, и у этого custom interpolated string handler на методе, который принимает набор переменных установлен атрибут color argument expression, соответственно мы автоматически получаем не только значение этой переменной, но и имя этой переменной.
4152.96 4161.92 "Анатолий Кулаков" Соответственно мы можем сформировать полноценный message template в терминах, опять же, серилога и в терминах вообще всего структурного логирования.
4161.92 4187.72 "Анатолий Кулаков" Именно вот эти магические новые классы, атрибуты, а также оптимизации, потому что у нас, например, string builder теперь тоже научился работать с interpolated string handler, и он их напрямую может в себя впитывать для того, чтобы там как-то без лишней буферизации, без лишнего боксинга внутри себя кэшировать и материализовывать.
4187.72 4201.48 "Анатолий Кулаков" В общем, с вот такими тонкими оптимизациями автор реализовал как раз POG, как раз концепцию, что это теперь можно сделать, это теперь нормально выглядит, и самое главное, на бенчмарках это теперь дает отличные результаты.
4201.48 4224.16 "Анатолий Кулаков" Вот, каким образом это, соответственно, в статье, каким образом это можно было сделать, соответственно, написано подробно в статье, если вы хотите повторить, есть код на GitHub, и если вы хотите присоединиться к дискуссии для серилога, чтобы этот подход внедрить непосредственно в официальную серилог-библиотеку, то тоже можете это сделать.
4224.16 4230.96 "Анатолий Кулаков" В общем, ознакомьтесь, статейка интересная, особенно если вы раньше не слышали про вот эти новые нововведения, может быть, ещё где-то вам в жизни понадобится.
4230.96 4245.00 "Игорь Лабутин" Ну да, я её почитал и вижу, что вполне прикольный пример, и на самом деле прям явно видно, довольно просто, но показать на примере, что можно сделать с этими новыми interpolated string handlers и как их использовать.
4245.00 4250.32 "Игорь Лабутин" Возможно, вы найдёте их применение в своих каких-то проектах, может быть, даже не связанном с логированием.
4250.32 4260.84 "Анатолий Кулаков" Ну видишь, опять же, с другой стороны, это уже сильно посмахивает на магию, когда ты просто-просто передаёшь строчку и не понимаешь, что у неё там под капотом будет происходить, а она там начинает творить, ого,
4260.84 4278.16 "Игорь Лабутин" чего? Ну это для разработчиков библиотек важно, то есть если у тебя, например, написан правильный extension метод для всех своих логирований, ну если мы говорим про логию внутри проекта большого, то какая в конце концов разница, как он работает под капотом, если для использования ты всё равно пишешь логер.loginformation или там лог что-нибудь?
4278.16 4279.16 "Анатолий Кулаков" Ну может быть, может быть.
4279.16 4282.88 "Анатолий Кулаков" Ну в общем, это сейчас пошёл разбор таких экстеншенов на уровне магии.
4282.88 4302.04 "Анатолий Кулаков" В общем, наверняка в вашей повседневной жизни они не понадобятся, а вот действительно разработчикам каких-то интересных библиотек, таких вообще принятых, как логирование, как SQL, как форматирование JSON, работа с XML, в общем, там это всё может понадобиться и тоже вылиться в интересные какие-то магические находки и удобные врапперы.
4302.04 4304.72 "Игорь Лабутин" Ну и хорошо, я думаю, что на сегодня нам хватит.
4304.72 4312.32 "Игорь Лабутин" Мы сегодня начали немножко заглядывать в седьмой .NET, посмотрев на планы команды Unity Framework Core.
4312.32 4318.56 "Игорь Лабутин" Мы сегодня вспомнили, что же такое улучшили в сетевых поддержках сетей в шестом .NET.
4318.56 4323.40 "Игорь Лабутин" Посмотрели на Visual Studio 2022, чем там стало лучше с точки зрения .NET Productivity.
4323.40 4328.68 "Игорь Лабутин" Узнали довольно много и нового интересного про ReSharper и Ryder 2021.3.
4328.68 4336.36 "Игорь Лабутин" Выяснили, что Visual Studio 2022 Format Preview 4 потихонечку улучшается, но пока ещё не такими темпами, как основная.
4336.36 4349.12 "Игорь Лабутин" Глянули более детально на реализацию ход релоуда в Райдере и на то, как вы, может быть, захотите использовать интерполированные строки, структурное логирование и прочие нововведения, всякие хитрые атрибуты C# 10.
4349.12 4359.24 "Игорь Лабутин" Так что вот так, тем не так много, но близится Новый год, все потихонечку празднуют или готовятся праздновать, поэтому ждём января, где, скорее всего, будет много новых интересных тем.
4359.24 4375.16 "Анатолий Кулаков" Я надеюсь, мы ещё до января запишем какой-нибудь новогодний выпуск, поэтому если вы хотите улучшить своё праздничное настроение и провести время в неформальной обстановке, в общем, подключайтесь ещё к нашему праздничному выпуску, который мы в этом году ещё планируем выпустить, но в принципе как, получится, посмотрим.
4375.16 4382.32 "Игорь Лабутин" Не, ну мы его точно выпустим, вопрос в этом или в следующем, но как бы где-то вокруг Нового года, я думаю, что можно попытаться его ожидать.
4382.32 4400.16 "Анатолий Кулаков" А если в этом году наш подкаст был вам более-менее полезен, интересен или вы почерпнули оттуда что-то нового и что-то для себя интересного, то не забывайте нас шарить, репостить, рассказывать друзьям, писать комменты и всячески популяризировать подкаст.
4400.16 4401.92 "Анатолий Кулаков" В общем, нам будет очень-очень приятно.
4401.92 4404.64 "Игорь Лабутин" И на этом мы заканчиваем 42-й выпуск, с вами были
4404.64 4407.98 "Анатолий Кулаков" Игорь Лабутин и Анатолий Кулаков, всем пока. Пока.
