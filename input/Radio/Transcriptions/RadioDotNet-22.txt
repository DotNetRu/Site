0.00 8.88 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net, выпуск номер 22.
8.88 12.00 "Анатолий Кулаков" И сегодня с вами будут Анатолий Кулаков.
12.00 13.60 "Игорь Лабутин" И Игорь Лабутин, как обычно.
13.60 21.22 "Анатолий Кулаков" Прежде всего нам хотелось бы поблагодарить наших патронов, которые поддерживают нас на Boost и Patreon, и в частности Александра.
21.22 24.48 "Анатолий Кулаков" Будь как Александр, поддерживай свой любимый подкаст.
24.48 32.72 "Игорь Лабутин" И начать мы сегодня хотим с того, что вспомнить, что скоро, ну относительно скоро, будет конференция .NEXT и уже открыт Call for Papers.
32.72 44.28 "Игорь Лабутин" То есть если вы считаете, что вы в силе рассказать доклад, а даже если считаете, что вы не в силе, все равно поддавайтесь с идеями, будем с вами работать и делать хорошие доклады и хорошие конференции.
44.28 51.84 "Анатолий Кулаков" Но пока кто-то готовит доклады, в это время команда Visual Studio не зевает и уже начинает выпускать первые превью в этом году.
51.84 57.36 "Анатолий Кулаков" Вышел превью третий Visual Studio 2019, версии 16.9.
57.36 68.04 "Игорь Лабутин" И как ни странно, первое и самое, такое ощущение, важное нововведение - это добавилась возможность настраивать звуки на момент окончания запуска ваших юнит-тестов.
68.04 76.80 "Игорь Лабутин" То есть теперь вполне официально можно в Visual Studio настроить звук на конец работы юнит-тестов в Successful варианте и на случай, если ваши тесты упали.
76.80 84.56 "Игорь Лабутин" Соответственно, два разных звука, вам Visual Studio будет голосом в наушники говорить "Вернись в меня, все упало" или "Наташа, мы все уронили".
84.56 94.40 "Игорь Лабутин" Но, скажем так, эта новость почему-то заняла довольно большой кусочек статьи про нововведение, хотя казалось бы, что тут такого.
94.40 106.96 "Игорь Лабутин" Есть более серьезные изменения, есть изменения в визуальном, там чуть улучшили high contrast тему, то есть если вы используете high contrast или по разным причинам, посмотрите, должно было все улучшиться.
106.96 114.88 "Игорь Лабутин" Много улучшений вокруг C++, но мы же про .NET, поэтому в .NET появилось несколько не очень больших вещей.
114.88 117.40 "Игорь Лабутин" Во-первых, теперь preprocessor умеет complete.
117.40 130.20 "Игорь Лабутин" То есть, если вы наберете решетку if, то Visual Studio начнет подставлять вам те символы, которые она видит и знает, и вы сможете их автодополнять и не бегать каждый раз с свойствами CSProject, посмотреть, как же оно там называется, или в MSDN.
130.20 146.36 "Игорь Лабутин" Для source-генераторов появилась некоторая визуализация, их можно найти в разделе Analyzer, и при этом все файлики, которые каждый конкретный source-генератор сгенерировал, будут там же видны в виде, соответственно, .generator.cs, например, или как-то так.
146.36 152.56 "Игорь Лабутин" И последнее, что там сделано с точки зрения .NET Productivity, это улучшили поведение функций goToAll.
152.56 159.24 "Игорь Лабутин" Там довольно часто появляются дубликаты всяких функций или еще чего-то, если в вашем проекте было несколько таргетов.
159.24 166.08 "Игорь Лабутин" То есть, например, netStandard и какой-нибудь net451 или еще что-то, такие штуки появлялись тогда в двойном экземпляре.
166.08 169.96 "Игорь Лабутин" Сейчас это все дедублицировано и будет каждая функция появляться в единственном экземпляре.
169.96 173.24 "Игорь Лабутин" Ну, а также завезли немножко улучшений в XMLE.
173.24 174.24 "Игорь Лабутин" В общем-то, все.
174.24 175.24 "Анатолий Кулаков" Ну, неплохо, неплохо.
175.24 178.92 "Анатолий Кулаков" Звуки, звуки на тесты, это я считаю 5.
178.92 181.80 "Анатолий Кулаков" Этого мы должны были ждать несколько десятков лет.
181.80 184.40 "Анатолий Кулаков" Не отстает компания JetBrains.
184.40 190.88 "Анатолий Кулаков" Она выпустила roadmap со своими новыми продуктами ReSharper и Rider 2021.1.
190.88 195.72 "Анатолий Кулаков" Давайте посмотрим, чем же бибикает ReSharper в момент окончания юнит-тестов.
195.72 197.80 "Анатолий Кулаков" Итак, прежде всего, это roadmap.
197.80 201.20 "Анатолий Кулаков" Это нужно принимать планы на будущий релиз.
201.20 204.32 "Анатолий Кулаков" Команда планирует продолжить работу над out-of-process.
204.32 206.24 "Анатолий Кулаков" Может быть, даже завершить его.
206.24 213.84 "Анатолий Кулаков" Для тех, кто не в курсе, напоминаю, что ReSharper сейчас усиленно работает над тем, чтобы вынести себя из процесса Visual Studio.
213.84 219.08 "Анатолий Кулаков" Процесс Visual Studio 32-битный, и поэтому все плагины там очень сильно аютятся.
219.08 222.52 "Анатолий Кулаков" Да и сама студия очень сильно там аютится, ей этого места уже давно не хватает.
222.52 225.04 "Анатолий Кулаков" И студия пошла по пути непереписывания.
225.04 232.52 "Анатолий Кулаков" Все на 64-разрядную студию, а вынесение своих компонентов, в частности, рослина, в отдельные процессы.
232.52 235.00 "Анатолий Кулаков" Этим же путем и двигается ReSharper.
235.00 237.52 "Анатолий Кулаков" И уже сделано очень много работы.
237.52 241.48 "Анатолий Кулаков" Уже можно это с помощью специальных флажков попробовать, посмотреть.
241.48 245.80 "Анатолий Кулаков" Но все-таки еще остается над тем, где поработать.
245.80 249.40 "Анатолий Кулаков" И вот собираются этот процесс наконец-то завершить.
249.40 258.64 "Анатолий Кулаков" Также будет много improvement по поддержке новых синтаксисов языка C# 9 и даже C# 10, разработка которого уже началась, уже есть первые пропозлы.
258.64 263.08 "Анатолий Кулаков" И ReSharper собирается поддерживать все эти вещи еще на ранних этапах.
263.08 265.04 "Анатолий Кулаков" Планирую добавить интересный анализатор.
265.04 268.32 "Анатолий Кулаков" Это анализатор Entity Framework N+1.
268.32 278.12 "Анатолий Кулаков" Для тех, кто не знает, N+1-проблема - это довольно частая распространенная штука во всяких ORM-ках, когда вы загружаете какую-то одну сущность за один запрос к базе.
278.12 285.56 "Анатолий Кулаков" А затем загружаете какие-нибудь связанные сущности или, например, семью челдов, и на это у вас уходит еще N запросов к базе.
285.56 287.36 "Анатолий Кулаков" Получается N+1 запросов.
287.36 289.80 "Анатолий Кулаков" Хотя, казалось бы, это можно было сделать за один раз.
289.80 294.32 "Анатолий Кулаков" Проблема довольно часто распространена, она не так очевидна в большом коде, как кажется.
294.32 297.44 "Анатолий Кулаков" И вот ReSharper хочет сделать для нее анализ.
297.44 300.48 "Анатолий Кулаков" И насколько я понял, он у них уже есть в прототипе.
300.48 302.48 "Анатолий Кулаков" Это как раз работа одного из интернов.
302.48 305.56 "Анатолий Кулаков" И соответственно должен быть фикс для Entity Framework.
305.56 308.12 "Анатолий Кулаков" То есть не только анализ, но и фикс.
308.12 316.32 "Анатолий Кулаков" Мне кажется, довольно интересное заявление, потому что раньше настолько, наверное, глубоких алгоритмических анализов я у ReSharper как-то, наверное, не припомню.
316.32 327.56 "Анатолий Кулаков" То есть чтобы проанализировать Entity Framework на его include, на его референсы и еще помочь сделать tweak fix на это, чтобы правильно переписать, по-моему, очень такой большой рефактор.
327.56 329.88 "Анатолий Кулаков" Вот примеров существующих я не знаю.
329.88 335.96 "Игорь Лабутин" Да, но при этом надо помнить, что Entity Framework сам по себе тоже работает в этом направлении.
335.96 346.28 "Игорь Лабутин" Не с точки зрения tweak fixes, а с точки зрения того, что они решают n+1 проблему со своей стороны и пытаются оптимизировать запросы максимально, чтобы их не случалось.
346.28 349.88 "Игорь Лабутин" Так что тут, в общем, со всех сторон у нас есть улучшение.
349.88 353.16 "Анатолий Кулаков" Наверное, самый оптимальный запрос - это тот, которого нет.
353.16 356.12 "Анатолий Кулаков" Поэтому подход ReSharper как-то кажется более перспективным.
356.12 361.60 "Анатолий Кулаков" Хотя, безусловно, он не исключит всех ситуаций, и там уже Entity Framework должны сработать как нужно.
361.60 364.40 "Анатолий Кулаков" Еще одно интересное направление.
364.40 368.76 "Анатолий Кулаков" JetBrains решили взяться сильно за ISP net-routes.
368.76 377.12 "Анатолий Кулаков" Потому что действительно мы используем наши роуты практически каждый день в IP-контроллерах, и это сейчас является обычными строчками, не нагруженной никакой семантикой.
377.12 380.84 "Анатолий Кулаков" Но это по правде ложь, это уже далеко не строчки.
380.84 387.48 "Анатолий Кулаков" Они имеют под собой довольно понятную сигнатуру, довольно ожидаемое поведение и прочее, прочее, прочее.
387.48 397.00 "Анатолий Кулаков" Поэтому ReSharper решил посмотреть на роуты не как на строчки, как на полноценные end-points, и попытаться что-то из этого вытянуть, какую-то полезную функциональность.
397.00 398.00 "Анатолий Кулаков" А что же можно вытянуть?
398.00 413.16 "Анатолий Кулаков" А можно, например, построить вам дерево end-points и посмотреть, как запрос роутится, через какие точки проходит, какая у каждой точки есть сигнатура, может быть, какие есть глаголы, и все это отобразить в виде интересного графа, в виде интересного дерева.
413.16 423.76 "Анатолий Кулаков" Также можно добавить эти роуты в IntelliSense, чтобы ReSharper вам мог их комплетить, когда вы пытаетесь указать какой-нибудь контроллер или сделать какой-нибудь реквест.
423.76 426.32 "Анатолий Кулаков" Можно, естественно, будет искать find-user жпани.
426.32 431.08 "Анатолий Кулаков" В общем, довольно интересная штука, которая должна тоже помочь в повседневной жизни.
431.08 432.84 "Анатолий Кулаков" Это что касается ReSharper.
432.84 448.04 "Анатолий Кулаков" В ДотПике планируют улучшить декомпиляцию, соответственно, будут поддержаны новые структуры данных, такие как рекорды, async-стримы, и самая главная фича, которую в принципе я давно жду, это форматирование декомпилированного кода.
448.04 462.40 "Анатолий Кулаков" Сейчас все форматирование за хардкожено в ДотПике, и вы видите тот формат, который, я так понимаю, предпочитает команда самого ReSharper, потому что я на практике больше не встречал больших проектов, которые используют два пробела для отступов.
462.40 464.52 "Анатолий Кулаков" И ДотПик форматирует именно так.
464.52 470.96 "Анатолий Кулаков" Есть надежда, что в будущем релизе ДотПик научится форматировать с тем стилем, который у вас настроен в Visual Studio.
470.96 471.96 "Анатолий Кулаков" И это прекрасно.
471.96 487.16 "Анатолий Кулаков" И все это не только планы, потому что уже на данный момент вышел 2021.1 Early Access Preview ReSharper Tools, то есть некоторые из этих фичей вы уже можете скачать и непосредственно попробовать.
487.16 489.96 "Игорь Лабутин" Ну, два пробела используют разные проекты.
489.96 494.94 "Игорь Лабутин" Мы, например, используем довольно строго везде два пробела, так что это не такая уж совсем непопулярная
494.94 499.20 None штука. Ну ладно, ReSharper, конечно же есть райдер.
499.20 503.20 "Игорь Лабутин" Если вам не хватает 32-битной студии, идите в 64-битный райдер.
503.20 504.20 "Игорь Лабутин" Или что с райдером?
504.20 510.60 "Анатолий Кулаков" Да, младший брат не отстает, как и положено, он тоже выпустил E-App, его тоже уже можно скачать и посмотреть.
510.60 512.36 "Анатолий Кулаков" И давайте обсудим его роудмап.
512.36 516.04 "Анатолий Кулаков" Прежде всего, конечно, чего так много ждут, это код Vim.
516.04 530.92 "Анатолий Кулаков" Мы уже говорили про эту функциональность, она позволяет нескольким разработчикам приконектиться к некоему хосту, к некоей студии, к окошку райдера и вместе там подебажить, поредактировать, поработать над проектом, над солюшеном в райдере.
530.92 536.52 "Анатолий Кулаков" Эту поддержку получили все IDE на основе IDE, кроме райдера.
536.52 546.40 "Анатолий Кулаков" У райдера была слишком сложная инфраструктура, вот это в этом, .NET и все прочее в этом духе, поэтому потребовалось немножко больше времени для того, чтобы код Vim заработал на райдере.
546.40 554.08 "Анатолий Кулаков" И вот мы будем надеяться, что в будущих релизах это все заработает и мы с вами сможем насладиться полностью этой новой интересной фичей.
554.08 562.80 "Анатолий Кулаков" Следующим идет Welcome Screen, то есть JetBrains настолько крутые, что работают над оптимизацией Welcome Screen.
562.80 570.04 "Анатолий Кулаков" Теперь райдер сможет оттачиться к запущенным процессам без того, чтобы создавать какой-то фиктивный солюшен или проект.
570.04 578.08 "Анатолий Кулаков" Довольно странная проблема, странная оптимизация, ну допустим, допустим, это нужно, это важно.
578.08 591.68 "Анатолий Кулаков" Будет улучшен перформанс загрузки солюшена, то есть не нужно будет ждать, когда солюшен прогрузит всю историю, все символы в вашем проекте для того, чтобы отобразить вам деревце.
591.68 597.20 "Анатолий Кулаков" Дерево фаликом должно появляться быстро, без глюков и не ждать всего остального.
597.20 599.04 "Анатолий Кулаков" Над этим тоже будет кипеть работа.
599.04 610.64 "Анатолий Кулаков" Новое окно Problems View - это специальное место, где будут собраны все возможные проблемы, проблемы с каким-то environment, с Nuget пакетами, все инспекции и так далее.
610.64 617.00 "Анатолий Кулаков" То есть, одна новая точка, где будет вас ждать все возможные места, на которые вам стоит обратить внимание.
617.00 618.92 "Анатолий Кулаков" ML Code Completion.
618.92 622.92 "Анатолий Кулаков" Наконец-то, машинленник добрался к нашу Code Completion.
622.92 632.92 "Анатолий Кулаков" Будет заимпровелен стандартный алгоритм по подсказке в Intellisense вам и теперь будут с помощью машинленнинга предлагаться различные варианты.
632.92 638.32 "Анатолий Кулаков" Я думаю, сюда еще подключат блокчейн и artificial intelligence или без этого иначе никак.
638.32 657.56 "Анатолий Кулаков" На самом деле, довольно ожидаемая штука, довольно таки хочется мне ее сильно, потому что, когда я, например, набираю в своей программе банальную команду, консоль, я выбираю точку и пишу буквы WL в надежде распечатать строку.
657.56 664.60 "Анатолий Кулаков" Ну, потому что я очень часто пользуюсь решаперской фичей, которая по первым нескольким буквам позволяет вам подсказать метод.
664.60 671.96 "Анатолий Кулаков" Вот, Игорь, если бы у тебя у консоли попросили бы метод, который за главными буквами имеет WL, ты бы какой метод предложил?
671.96 674.92 "Игорь Лабутин" А я что-то у консоли, кроме RightLine, ты не помнишь ничего?
674.92 675.92 "Игорь Лабутин" Там еще что-то есть?
675.92 677.84 "Игорь Лабутин" А, ReadKey обычно еще есть.
677.84 680.20 "Анатолий Кулаков" Вот, в принципе, мне больше ничего не надо.
680.20 682.24 "Анатолий Кулаков" Я хочу, чтобы она мне в RightLine предложила.
682.24 684.56 "Анатолий Кулаков" Знаешь, что мне предлагает мой любезный решапер?
684.56 686.60 "Анатолий Кулаков" Он мне предлагает Windows Left.
686.60 690.76 "Анатолий Кулаков" Твою мать, я за 20 лет карьеры никогда в жизни не использовал Windows Left.
690.76 691.76 "Анатолий Кулаков" Почему он мне его предлагает?
691.76 694.32 "Анатолий Кулаков" У меня вообще в проекте этого упоминания нет.
694.32 695.92 "Анатолий Кулаков" Хотя в RightLine там полно.
695.92 705.96 "Анатолий Кулаков" Вот неужели так сложно, товарищи джетбрейнерцы, хотя бы немножко посмотреть на часточность использования того, что у нас есть в проекте, и предлагать более-менее осознанные варианты.
705.96 707.56 "Анатолий Кулаков" Без, пока, машинленинга.
707.56 710.28 "Анатолий Кулаков" Но, надеюсь, с машинленингом все будет еще лучше.
710.28 714.08 "Анатолий Кулаков" Итак, будет добавлена интеграция с ISPNet scaffolding.
714.08 721.84 "Анатолий Кулаков" Это специальный набор инструментов, который позволяет вам быстренько сгенерить вьюшки, контроллеры, некие идентики.
721.84 733.20 "Анатолий Кулаков" Вот, будет добавлено окошко с созданием нового элемента, где вы сможете это визуально выбрать и, соответственно, генерить себе непосредственно ваш проект контекстно-зависимых контроллеров.
733.20 735.56 "Анатолий Кулаков" Тоже интересная интеграция с третисторонним проектом.
735.56 736.56 "Анатолий Кулаков" Посмотрим, как полетит.
736.56 738.56 "Анатолий Кулаков" Дап-EF превью.
738.56 741.96 "Анатолий Кулаков" То есть, будет переработан превью дап-EF.
741.96 746.24 "Анатолий Кулаков" И будут поддерживаны кастомные всякие расширения маркапа.
746.24 749.60 "Анатолий Кулаков" Скорее всего, это связано с поддержкой Avalon'a, наверное.
749.60 751.72 "Анатолий Кулаков" Она любит там всякие кастомные маркапы вставлять.
751.72 756.96 "Анатолий Кулаков" Будут поддержаны темплейты, field party контролы и ресурсы в отдельных файлах.
756.96 761.32 "Анатолий Кулаков" Будет проработана, улучшена поддержка F#.
761.32 765.60 "Анатолий Кулаков" Будет добавлено больше quickfixes и refactoring для F#.
765.60 771.44 "Анатолий Кулаков" И будет вестись работа над вынесением type-провайдеров в отдельный процесс.
771.44 774.24 "Анатолий Кулаков" Я пока не очень понимаю, какую проблему этим решается.
774.24 779.20 "Анатолий Кулаков" Я думаю, в будущем мы созвонимся с коллегами и обсудим, что они хотят этим добиться.
779.20 782.36 "Анатолий Кулаков" Продолжается импрувмент для Unity.
782.36 785.60 "Анатолий Кулаков" Райдер настойчиво хочет стать лучшей IDE для геймдева.
785.60 788.88 "Анатолий Кулаков" И, мне кажется, ему это сейчас с успехом удается.
788.88 792.80 "Анатолий Кулаков" То есть, Unity и Unreal Engine довольно хорошо и комфортно себя чувствуют в райдере.
792.80 796.84 "Анатолий Кулаков" Я напомню, что япп уже вышел, для тех, кто сильно интересуется, можно посмотреть.
796.84 799.64 "Игорь Лабутин" Так, еще что-нибудь интересненького от JetBrains?
799.64 801.76 "Анатолий Кулаков" Да, недавно прошла их сессия на Reddit.
801.76 803.76 "Анатолий Кулаков" Они довольно много об этом вещали, говорили.
803.76 807.40 "Анатолий Кулаков" Сессия называется "Спросите меня, что хотите".
807.40 813.80 "Анатолий Кулаков" И как раз-таки JetBrains отвечал на все вопросы, которые задавали читатели Reddit.
813.80 817.32 "Анатолий Кулаков" Я выбрал парочку, которые могут быть интересны нашим слушателям.
817.32 821.88 "Анатолий Кулаков" Например, спрашивали, планируется ли ReSharper для Visual Studio for Mac.
821.88 823.60 "Анатолий Кулаков" Решил, что пока не планируется.
823.60 827.56 "Анатолий Кулаков" В принципе, если вы хотите кроссплатформенные IDE, то смотрите на райдер.
827.56 832.24 "Анатолий Кулаков" ReSharper никакого смысла к этой Visual Studio выпускать не имеет.
832.24 834.32 "Анатолий Кулаков" Тем более, что это не настоящая Visual Studio.
834.32 839.60 "Анатолий Кулаков" Это мимикрация Monodevelop, под которой у него другая инфраструктура, другая система плагинов.
839.60 842.96 "Анатолий Кулаков" То есть, никакого шанса портировать.
842.96 843.96 "Анатолий Кулаков" Просто оттуда ничего нет.
843.96 844.96 "Анатолий Кулаков" Это надо переписывать все с нуля.
844.96 849.44 "Анатолий Кулаков" Такой же вопрос будет ли ReSharper для Visual Studio Code.
849.44 852.60 "Анатолий Кулаков" Так же точно для Visual Studio Code не планируется ReSharper.
852.60 862.24 "Анатолий Кулаков" Наверное, по тем же самым причинам, что, в принципе, бессмысленно есть кроссплатформенные IDE, есть устоявшаяся система плагинов в виде ReSharper, и этого должно хватать всем.
862.24 868.16 "Анатолий Кулаков" Про перформанс, конечно же, спрашивали, когда ReSharper перестанет тормозить, что такое, почему студия с ReSharper все время тормозит.
868.16 876.68 "Анатолий Кулаков" Здесь, наверное, главная работа, как я уже сказал, ведется в том, что Visual Studio 32-битная, и ReSharper выносят в отдельный процесс.
876.68 890.16 "Анатолий Кулаков" По идее, это должно убрать все те тормоза, которые остались, но, в принципе, перформанс улучшается с каждым релизом, и мы с каждым релизом видим, как ReSharper становится все быстрее и быстрее даже в тех сложных условиях, в которых он работает.
890.16 891.44 "Анатолий Кулаков" По райдеру.
891.44 894.32 "Анатолий Кулаков" Интересовались, будет ли райдер Community Edition.
894.32 910.72 "Анатолий Кулаков" Я напоминаю, что в системе, в семействе JetBrains IDEA обычно присутствует некая Community Edition среда, которая позволяет довольно комфортно разрабатывать, довольно комфортно работать с каким-то языком, с каким-то стеком технологий и бесплатно.
910.72 914.44 "Анатолий Кулаков" Если вы хотите уже каких-то больше наворотов, то тогда покупаете уже платную версию.
914.44 926.72 "Анатолий Кулаков" С райдером такой фишки нет у JetBrains, но, в принципе, есть очень много бесплатных лицензий для open-source проектов, есть помощь студентам, есть помощь преподавателям.
926.72 932.28 "Анатолий Кулаков" Если вам сильно хочется, то посмотрите в сторону поддержки как раз-таки всяких open-source проектов и студенческих проектов.
932.28 938.00 "Анатолий Кулаков" Там довольно лояльные условия, мы пользуемся некоторыми из ними и довольно вольготно себя чувствуем.
938.00 942.72 "Анатолий Кулаков" Будет ли использовать райдер .NET Core на бэкэнде?
942.72 944.40 "Анатолий Кулаков" Да, это планируется.
944.40 948.52 "Анатолий Кулаков" Райдер планирует полностью перейти на .NET Core и это планируют сделать в этом году.
948.52 951.80 "Анатолий Кулаков" Будет ли кроссплатформенный .MEMORY и .TRACE?
951.80 958.24 "Анатолий Кулаков" Сейчас ситуация такая, что профайлить вы сейчас уже можете кроссплатформенно, с этим никаких проблем нет.
958.24 960.52 "Анатолий Кулаков" А вот UI кроссплатформенная сейчас активно разрабатывается.
960.52 966.44 "Анатолий Кулаков" Игорь, как ты думаешь, какой выбрали фреймворк для того, чтобы визуализировать кроссплатформенный UI?
966.44 969.88 "Игорь Лабутин" Мы недавно обсуждали Avalonia, так что, скорее всего, Avalonia.
969.88 970.88 "Анатолий Кулаков" Больше ничего нет.
970.88 972.76 "Анатолий Кулаков" Безусловно, безальтернативно.
972.76 977.48 "Анатолий Кулаков" Avalonia захватывает наши умы, Avalonia будет теперь и у JetBrains.
977.48 986.64 "Анатолий Кулаков" UI-ку для .MEMORY и .TRACE пишут в сотрудничестве с Avalonia Community и, наверное, это тоже будет еще один интересный проект, в который Avalonia добавит в свой портфолио.
986.64 988.92 "Анатолий Кулаков" Apple M1 поддержку.
988.92 993.64 "Анатолий Кулаков" В принципе, со стороны JetBrains никаких препятствий к этому нет.
993.64 999.60 "Анатолий Кулаков" Они только ждут лишь .NET 6, где официально обещали поддержать M1 чипсет.
999.60 1002.88 "Анатолий Кулаков" Со стороны Java уже все давно готово, уже все давно поддержано.
1002.88 1011.64 "Анатолий Кулаков" Но JetBrains, в принципе, оставляет шанс, что они не будут ждать осени, когда выйдет официально .NET 6.
1011.64 1019.84 "Анатолий Кулаков" Они вполне могут собрать какой-нибудь свой кастомный билд и уже выпустить специальную сборку для Apple M1, уже кастомную под себя.
1019.84 1027.88 "Анатолий Кулаков" У них очень много с этим опыта, они очень много из Java таскают с собой кастомного, они используют какие-то официальные SDK.
1027.88 1032.60 "Анатолий Кулаков" Поэтому, может быть, им намного легче будет освоить свою сборку .NET.
1032.60 1035.40 "Анатолий Кулаков" Интересный вопрос был про команду.
1035.40 1038.36 "Анатолий Кулаков" Насколько большая сейчас команда .NET?
1038.36 1041.88 "Анатолий Кулаков" В JetBrains .NET всего занимается 131 человек.
1041.88 1048.12 "Анатолий Кулаков" Это включая разработчиков, тестировщиков, маркетинг, адвокатов и всех-всех-всех в округе.
1048.12 1049.12 "Анатолий Кулаков" 131 человек.
1049.12 1052.88 "Анатолий Кулаков" Как тебе кажется, Игорь, это большая или маленькая команда для такого продукта?
1052.88 1053.88 "Анатолий Кулаков" Или в самый раз?
1053.88 1055.16 "Игорь Лабутин" Мне кажется, что в самый раз.
1055.16 1061.44 "Игорь Лабутин" На самом деле, у меня были какие-то числа в памяти, возможно, многолетней давности, что их там гораздо меньше.
1061.44 1064.64 "Игорь Лабутин" У меня почему-то были числа порядка 70-80 человек.
1064.64 1069.36 "Игорь Лабутин" Но действительно, тогда шла речь в основном про ReSharper и Ryder еще не было.
1069.36 1071.20 "Игорь Лабутин" Или он был на очень ранней стадии.
1071.20 1076.68 "Игорь Лабутин" Поэтому, наверное, сейчас, с учетом наличия и ReSharper, и Ryder, наверное, разумная команда.
1076.68 1077.68 "Игорь Лабутин" Да, да.
1077.68 1078.68 "Анатолий Кулаков" Хорошее количество.
1078.68 1079.68 "Анатолий Кулаков" Кстати, про Avalonio.
1079.68 1082.28 "Анатолий Кулаков" Я слышал, у него там тоже какие-то релизы намечаются?
1082.28 1088.20 "Игорь Лабутин" Не то, что намечаются, он вышел непосредственно перед Новым годом, 29 декабря вышел релиз 0.10.0.
1088.20 1093.84 "Игорь Лабутин" Не то, чтобы там много прорывных изменений, но тем не менее какие-то интересные штуки есть.
1093.84 1095.48 "Игорь Лабутин" Кратенько пробежимся по ним.
1095.48 1099.80 "Игорь Лабутин" Во-первых, они поддерживают теперь новую тему в UI, называется Fluent.
1099.80 1103.60 "Игорь Лабутин" Также завезли, ну все это вообще выглядит покрасивее,
1103.60 1106.84 None чем выглядело раньше. Завезли некоторое количество новых контролов.
1106.84 1113.64 "Игорь Лабутин" Есть нативные Date/Time пикеры, есть Toggle Switch, который вам должен быть хорошо знаком по стандартным сеттингам винда десятки.
1113.64 1116.48 "Игорь Лабутин" Такая голубая штука, влево-вправо передвигающаяся.
1116.48 1118.00 None И появились лейблы.
1118.00 1135.12 None Мне очень немножко это странно, ведь кажется, что лейбл это довольно основополагающий контрол, но тем не менее вот есть теперь правильные лейблы, причем которые умеют правильно биндиться к, скажем так, рядом находящимся, например, текстблоксам, чтобы их аккуратно активировать по всяким горячим клавишам.
1135.12 1139.32 "Игорь Лабутин" Но они работают над перфомансом, поэтому у них появилась штука под названием Compiled Bindings.
1139.32 1154.36 "Игорь Лабутин" Ну, вы, наверное, если программировали на WPF, знаете, что вы можете прямо в XAML указать имя, например, какой-то property из вашей View-модельки, и WPF будет считывать значение этой property и, соответственно, показывать его в UI.
1154.36 1161.08 "Игорь Лабутин" В принципе, это основной нормальный способ взаимодействия View-моделей и XAML, и UI, собственно, представления View-шки.
1161.08 1168.04 "Игорь Лабутин" Проблема в том, что поскольку там указывается имя property, то для того, чтобы достать значение, по большому счету нужно использовать reflection.
1168.04 1174.00 "Игорь Лабутин" А Волония добавила такую штуку под названием Compiled Binding, которая делает это дело в compile-time.
1174.00 1180.36 "Игорь Лабутин" То есть это все происходит в compile-time, создаются нужные делегаты, и никакого reflection в run-time уже не происходит.
1180.36 1186.08 "Игорь Лабутин" Понятно, что там есть некоторые ограничения, что туда можно прописать, но в целом, наверное, штука полезная.
1186.08 1192.64 "Игорь Лабутин" Улучшилась поддержка Unicode, добавили всяких UI-ных фишечек, типа там Tue кнопочек и так далее.
1192.64 1203.88 "Игорь Лабутин" Существенно улучшилась experience для разработчиков, то есть теперь есть встроенная консоль с Roslyn Scripting, куда вы можете прямо во время отладки писать какой-нибудь код и он будет выполняться.
1203.88 1208.20 None Такой аналог Intermediate Window, ой, Immediate Window в Visual Studio.
1208.20 1218.00 None Можно редактировать значения property, улучшилось все отображение всяких разных property у контролов, ну и много-много-много чего другого.
1218.00 1229.32 "Игорь Лабутин" Так, завезли еще то, что называется Typed Property Change Notification, то есть нестандартный наш On Property Change со строчечкой внутри с именем Полечка, а можно сделать его типизированным.
1229.32 1234.64 "Игорь Лабутин" Понятно, что там меньше боксинга, хотя при чем тут боксинг, но по-моему что-то там про боксинг было.
1234.64 1239.88 "Игорь Лабутин" Так что, в общем, все вокруг перформанса, по сути, и удобства программирования, и меньше ошибок.
1239.88 1248.64 "Игорь Лабутин" Так что так, если вы пользуетесь Avalon'ей, то, наверное, этот релиз однозначно стоит того, чтобы его взобрать и начать использовать в своей работе.
1248.64 1257.08 "Анатолий Кулаков" Отлично, наткнулся на статистику Джимми Боггарда, у него отличный блог, если кто не знает, обязательно посмотрите, пористайте, наверняка вам понравится.
1257.08 1262.92 "Анатолий Кулаков" Вот, не знаю, по-моему, очень необычная для него тема, довольно-таки лайтовая, на первый взгляд.
1262.92 1266.44 "Анатолий Кулаков" Он рассуждал про сервис lifetime.
1266.44 1280.84 "Анатолий Кулаков" Но я, в принципе, задумался, что с тех пор, как появился контейнер, стандартный контейнер в ISP.NET Core, для многих разработчиков только открылась эта область, только открылись контейнеры, dependency injection, сервис lifetime.
1280.84 1289.80 "Анатолий Кулаков" И действительно, когда ты только начинаешь работать с контейнерами, наверное, единственная проблема, которая может перед тобой возникнуть, а какой lifetime должен быть у моего сервиса.
1289.80 1296.64 "Анатолий Кулаков" Потому что раньше, когда создавались все эти сервисы ручками через оператор new, никаких вопросов не возникало.
1296.64 1299.20 "Анатолий Кулаков" А здесь Microsoft советует нам лезть в контейнер.
1299.20 1304.12 "Анатолий Кулаков" Поэтому давайте все-таки разберемся, какой же lifetime должен быть у вашего сервиса.
1304.12 1313.04 "Анатолий Кулаков" Прежде всего, сервис lifetime - это специальный способ, который позволяет вам заботиться о состоянии вашего сервиса.
1313.04 1320.00 "Анатолий Кулаков" То есть, то, какое время жизни должно быть у вашего сервиса, прежде всего, наверное, зависит от его состояния.
1320.00 1326.20 "Анатолий Кулаков" Итак, первое, самый распространенный, наверное, самый обычный, самый понятный lifetime - это Singleton.
1326.20 1333.84 "Анатолий Кулаков" Уже в его названии проявшего оскомину и наверняка многие разработчики понимают, что это такое.
1333.84 1347.88 "Анатолий Кулаков" Singleton вы могли встретить в своем проекте, когда заводили глобальные статические переменные или глобальные лезги переменные и пытались записать туда какой-то объект, который будет жить все время, пока живет приложение.
1347.88 1354.76 "Анатолий Кулаков" Именно этот lifetime эмулирует lifetime, который так и называется Singleton.
1354.76 1365.68 "Анатолий Кулаков" Поэтому, если вы зарегистрируете в контейнере ваш сервис с lifetime Singleton, он будет жить в единственном экземпляре в вашем контейнере до тех пор, пока живет приложение.
1365.68 1375.28 "Анатолий Кулаков" Второй, наверное, самый сложный сервис, то есть самый сложный lifetime, который предлагается обсудить, это как раз-таки lifetime scoped.
1375.28 1381.68 "Анатолий Кулаков" Обычно lifetime scoped встречаются, когда у вас есть какой-то логический workflow, отделенный от всего процесса.
1381.68 1393.32 "Анатолий Кулаков" Например, request в SP Net Core, например, action какой-нибудь в workflow foundation, activity или может быть unit of work или transaction в вашей базе данных или в ORM.
1393.32 1394.96 "Анатолий Кулаков" Все это некие scopes.
1394.96 1400.64 "Анатолий Кулаков" И вот, допустим, вам нужно сделать объект, который будет жить только в рамках этого scope.
1400.64 1404.12 "Анатолий Кулаков" Например, request в вашем ISP Net Controller.
1404.12 1407.20 "Анатолий Кулаков" Он должен жить до тех пор, пока обрабатывается запрос.
1407.20 1413.60 "Анатолий Кулаков" После того, как запрос отработал, респонс сформировался, никакого смысла в этом реквесте нет и его можно безболезненно удалить.
1413.60 1425.20 "Анатолий Кулаков" Вот на такое поведение, на такую стратегию и рассчитывает контейнер, когда вы регистрируете в нем сервис под lifetime scoped.
1425.20 1428.56 "Анатолий Кулаков" И третий, довольно-таки легкий, довольно понятный уровень - это transient.
1428.56 1433.80 "Анатолий Кулаков" Его легче всего описать словами "да, мне все равно, создавайте как хотите, я вообще не беспокоюсь".
1433.80 1441.80 "Анатолий Кулаков" То есть, те сервисы, которые вы обычно создавали оператором U и вам было все равно, сколько он живет, где он живет.
1441.80 1447.08 "Анатолий Кулаков" Вот именно эти сервисы и стоит регистрировать под lifetime transient.
1447.08 1454.52 "Анатолий Кулаков" Так как я уже сказал, на разных ресурсах очень много возникает вопросов, а какой же сервис lifetime мне использовать.
1454.52 1456.68 "Анатолий Кулаков" Давайте рассмотрим парочку best practices.
1456.68 1464.28 "Анатолий Кулаков" Прежде всего, самый безопасный lifetime scoped, который должен использоваться по дефолту - это transient.
1464.28 1466.08 "Анатолий Кулаков" Для тех сервисов, у которых нет стейта.
1466.08 1469.88 "Анатолий Кулаков" То есть, если у вас нет стейта, то значит transient - это ваш выбор.
1469.88 1481.80 "Анатолий Кулаков" Это значит, что ваш сервис будет создаваться каждый раз, как только его кто-то запросит и он должен быть легковесным, то есть в конструкторе не делать каких-нибудь страшных вещей и должен быть полностью stateless.
1481.80 1483.20 "Анатолий Кулаков" Тогда у вас не будет никаких проблем.
1483.20 1487.16 "Анатолий Кулаков" Если же в вашем сервисе есть какой-то стейт, то здесь нужно решать.
1487.16 1491.00 "Анатолий Кулаков" Если стейт должен храниться глобально, то ваш выбор это singleton.
1491.00 1498.76 "Анатолий Кулаков" Если же стейт должен зависеть от какого-то scoped, он живет в какое-то время, он зависит от какого-то workflow, то это уже скорее всего scoped.
1498.76 1504.32 "Игорь Лабутин" Да, прекрасная рекомендация, но мне хочется здесь добавить во-первых одно уточнение.
1504.32 1508.32 "Игорь Лабутин" Ты все время говоришь сервис, сервис - это ваш сервис, вы зависите от другого сервиса.
1508.32 1518.32 "Игорь Лабутин" Может быть, тут надо чуть-чуть напомнить терминологию, что в данном случае, когда мы говорим сервис, мы не имеем в виду ваш целиком, а ispnet core service, как целое приложение.
1518.32 1526.36 "Игорь Лабутин" Сервис - это термин именно в контексте DI контейнера, Dependent Injection контейнера, и это по сути любая зависимость, которую вы регистрируете в контейнер.
1526.36 1537.08 "Игорь Лабутин" Это не обязательно сервис, это могут быть репозитории, это могут быть DB контексты, это может быть все, что угодно, но вот в терминологии именно Dependency Injection контейнера это называется сервисом.
1537.08 1539.48 "Игорь Лабутин" Именно поэтому мы все время упоминаем слово сервис.
1539.48 1542.48 "Игорь Лабутин" Очень, блин, такой многозначный термин у нас в индустрии.
1542.48 1555.52 "Игорь Лабутин" И несмотря на огромное количество рекомендаций, которые Толя кратенько привел чуть выше, есть правила, которыми иногда кто-то пользуется, но при этом которые не совсем корректны.
1555.52 1563.88 "Игорь Лабутин" Во-первых, кто-то может сказать, что вообще у меня объект stateless, сервис, и поэтому зачем я его вообще создавать больше одного раза?
1563.88 1566.28 "Игорь Лабутин" Он же stateless, как бы, что такого?
1566.28 1569.12 "Игорь Лабутин" Создадим один раз, зарегистрируем в singleton и все.
1569.12 1577.24 "Игорь Лабутин" Это по сути предварительная оптимизация, вы не знаете, как оно в этом может поменяться в процессе разработки, он перестанет быть stateless.
1577.24 1587.20 "Игорь Лабутин" И если у вас этот объект тащит в себя какие-то зависимости, другие сервисы, то там есть некоторые тонкости, и это может привести к ошибкам, мы чуть позже к этому придем.
1587.20 1590.00 "Игорь Лабутин" Второй аргумент, ну окей, ладно, пусть будет не с
1590.00 1602.40 None singleton, но давайте все-таки сделаем его scoped. То есть он, он у меня stateless, фиг с ним, не будем мы его делать с singleton на все приложение, давайте сделаем его хотя-бы scoped на время реквеста, или какого-то action, или какого-то activity.
1602.40 1604.64 "Игорь Лабутин" Но здесь проблема в другом.
1604.64 1612.04 "Игорь Лабутин" Проблема не в том, что тут могут быть какие-то проблемы с зависимостями или ошибки, скорее всего, проблем особых не будет.
1612.04 1622.80 "Игорь Лабутин" Но если вы регистрируете в коде ваш сервис, вашу зависимость с lifetime scope, то это, скажем так, намек будущим читателям кода, что скорее всего сервис
1622.80 1628.28 None все-таки имеет какой-то state внутри. Не зря же вы его зарегистрировали с lifetime scope.
1628.28 1632.00 "Игорь Лабутин" Поэтому если state нет, не надо использовать scope.
1632.00 1652.72 "Игорь Лабутин" И последний аргумент, любители performance про него очень много говорят, про то, что ну как же, если будет transient, это же по сути сколько раз я создаю объект за время жизни одного реквеста, а то и вообще, мне много реквестов приходит, как же быть, столько памяти израсходуется зря, garbage collector там все умрет и так далее.
1652.72 1661.60 "Игорь Лабутин" На самом деле это может быть, но это нужно доказывать, то есть нужно брать профайлер, нужно показывать, что действительно создание миллионов, миллиардов зависимости от ваших сервисов,
1661.60 1678.00 None таких объектов приносит какие-то проблемы с производительностью, и тогда сознательно действительно регистрируйте его, либо скопт, либо синглтоном, с соответствующими комментариями в коде и в work items или в багах в вашей мыши трекере.
1678.00 1682.92 "Анатолий Кулаков" На первый взгляд кажется, что тема DI, контейнеров и зависимости она довольно-таки простая.
1682.92 1686.60 "Анатолий Кулаков" Ну то есть вам действительно нужно всего лишь на все выучить, как регистрировать сервисы.
1686.60 1690.52 "Анатолий Кулаков" Для этого достаточно ориентироваться в данных трех lifetime.
1690.52 1700.88 "Анатолий Кулаков" Но на самом деле это очень большая область, у нее очень много подводных камней, у нее написано куча контейнеров, все они хороши по-своему, у всех есть минусы.
1700.88 1707.88 "Анатолий Кулаков" И, например, самый частый случай ошибок, который хотелось бы тоже немножко затронуть, называется Capture Dependency.
1707.88 1716.24 "Анатолий Кулаков" Это смысл в том, что вы можете ненароком продлить время жизни того сервиса, который продлевать не хотели.
1716.24 1736.40 "Анатолий Кулаков" Приведем пример, допустим, если вы хотите сделать какой-то глобальный кэш, который должен жить во время всего вашего приложения, и вы точно знаете, что заполните его один раз при первом вращении на старте и потом никогда чистить не будете, то, скорее всего, вы захотите в такой сервис кэша передать в качестве зависимости DB Context.
1736.40 1758.04 "Анатолий Кулаков" И вот здесь у вас происходит очень большая ошибка, потому что кэш будет иметь уровень lifetime Singleton, потому что он живет все время, пока живет приложение, а вот DB Context обычно имеет уровень lifetime Transient, то есть он живет в тот момент, пока существует какой-то реквест или пока существует какая-то транзакция.
1758.04 1778.60 "Анатолий Кулаков" Таким образом, если вы создадите подобный класс с данной зависимостью, вы продлите время DB Context, а продление времени - это очень страшная штука, из-за нее могут быть memory leak, из-за нее могут быть resource leak и очень много других побочных эффектов, которые вы будете дебажить с большими круглыми глазами.
1778.60 1786.16 "Анатолий Кулаков" То есть поведение вашего сервиса может кардинально измениться, если вдруг DB Context начнет жить все время, пока живет приложение.
1786.16 1789.04 "Анатолий Кулаков" Подобных штук довольно-таки много.
1789.04 1797.60 "Анатолий Кулаков" Некоторые контейнеры умеют разрешать и тестировать свои контейнеры и позволяют не допускать подобных опечаток.
1797.60 1798.60 "Анатолий Кулаков" Некоторые - нет.
1798.60 1801.68 "Анатолий Кулаков" У некоторых есть специальные инструменты, о которых нужно знать.
1801.68 1804.88 "Анатолий Кулаков" Для некоторых нужно специально регистрировать сервисы, чтобы это знать.
1804.88 1807.72 "Анатолий Кулаков" В общем, тема довольно-таки интересная, глобальная.
1807.72 1814.08 "Анатолий Кулаков" И я рекомендую статью Марка Симона, если вы хотите глубже изучить кардинальные зависимости.
1814.08 1825.76 "Анатолий Кулаков" А если вы хотите полностью погрузиться вообще в DI, в контейнеры, в Inversion of Control, то обязательно посмотрите на книгу Марка Симона.
1825.76 1829.52 "Анатолий Кулаков" Это лучшая работа, которая есть по теме, которая когда-либо издавалась.
1829.52 1831.80 "Анатолий Кулаков" Сейчас, кстати, второе издание у нее готовится.
1831.80 1836.72 "Анатолий Кулаков" И Марк - это наиболее крутой специалист в этой области.
1836.72 1852.96 "Анатолий Кулаков" Он вам расскажет не только, как правильно работать с контейнерами, но и полностью всю философию, как подходить к инверсии зависимостей, как внедрять контейнеры в свои программы, нужны вам вообще контейнеры или не нужны, как обойтись без них, какие стратегии выбрать и много-много всего интересного есть в его книге.
1852.96 1853.96 "Игорь Лабутин" Да, тема важная.
1853.96 1864.00 "Игорь Лабутин" И на самом деле мы неоднократно напарывались на эти самые проблемы с Captive Dependencies, когда в Singleton залезает dependency со scope lifetime и долго живет.
1864.00 1874.92 "Игорь Лабутин" Это были и DB-контексты, и всякие достаточно большие объекты, которые потом удивленно рассматриваешь в дампах памяти и пытаешься понять, почему он все еще тут, хотя должен был убиться еще на старте приложения.
1874.92 1877.48 "Игорь Лабутин" Так что да, смотрите внимательно.
1877.48 1882.44 "Игорь Лабутин" И встроенный контейнер ASP.NET Core, насколько я помню, не имеет никаких средств отладки этого.
1882.44 1884.68 "Игорь Лабутин" То есть он вас не будет никак предупреждать.
1884.68 1885.68 "Анатолий Кулаков" Да, именно так.
1885.68 1888.16 "Анатолий Кулаков" У него нет никаких средств тестирования.
1888.16 1898.44 "Анатолий Кулаков" И даже когда вы запросите один сервис из скопа другого сервиса, которые не должны были пересекаться, он не выдаст никаких ошибок, хотя тоже мог бы, потому что у него вся эта информация есть.
1898.44 1905.44 "Анатолий Кулаков" А я еще хочу добавить, что в принципе существует такой способ как тестирование подобных зависимостей.
1905.44 1909.76 "Анатолий Кулаков" И официального метода для тестирования автофака нет.
1909.76 1911.64 "Анатолий Кулаков" Я в основном используюсь именно им.
1911.64 1916.32 "Анатолий Кулаков" Но я написал свой собственный, который теперь ношу с собой с проекта в проект.
1916.32 1924.08 "Анатолий Кулаков" И уже давно не встречаю таких проблем, потому что весь мой контейнер тестируется на Captive Dependency в момент интеграционных тестов.
1924.08 1925.68 "Анатолий Кулаков" И надо сказать, это отличное решение.
1925.68 1930.00 "Анатолий Кулаков" Поэтому если вы хотите себе такой метод заполучить, приходите в комментарии.
1930.00 1931.00 "Анатолий Кулаков" Будем делиться.
1931.00 1935.56 "Игорь Лабутин" Да, а потом перепишите его для того, чтобы он работал для стандартного дизайнного контейнера Microsoft.
1935.56 1936.56 "Игорь Лабутин" И всем будет счастье.
1936.56 1937.56 "Игорь Лабутин" Так, погнали дальше.
1937.56 1947.68 "Игорь Лабутин" Дальше у нас тема, которую я на самом деле, честно, довольно долго откладывал, потому что она сложная и замороченная, но мне показалась она довольно интересной.
1947.68 1950.80 "Игорь Лабутин" И я таки въехал в нее и попытался разобраться.
1950.80 1953.32 "Игорь Лабутин" Это про то, как же собирается .NET.
1953.32 1955.20 "Анатолий Кулаков" То есть мы все знаем...
1955.20 1961.28 "Анатолий Кулаков" Погоди, погоди, там разве не просто .NET Run, .NET Build и все, и .NET Pack, Artifact и в Docker?
1961.28 1968.16 "Игорь Лабутин" Да, примерно так делается большинство, там 95%, не знаю, 90% всех приложений, которые пишем мы.
1968.16 1976.52 "Игорь Лабутин" Но вот как вот эти GitHub репозитории, которых на самом деле несколько, в итоге складываются в единый .NET Core SDK, который инсталлеры я могу скачать с сайта Microsoft.
1976.52 1978.24 "Игорь Лабутин" Для меня было некоторой загадкой.
1978.24 1987.44 "Игорь Лабутин" То есть было понятно, что есть некоторая кухня вокруг этого, огромное количество, наверное, скриптов, там не знаю чего, но как это все собирается, непонятно.
1987.44 2001.20 "Игорь Лабутин" Тем более, что я по работе иногда смотрю в код .NET, причем именно в код, который у меня просто склонирован с GitHub, и я понимаю, что даже когда я ищу что-то, я натыкаюсь на этот код то в одном репозитории, то в другом репозитории,
2001.20 2005.36 None и как это все работает было непонятно. Теперь более-менее стало понятно.
2005.36 2008.04 "Игорь Лабутин" Не до самого конца, но давайте попробуем разобраться.
2008.04 2010.64 None Во-первых, какие есть цели у .NET?
2010.64 2014.04 "Игорь Лабутин" У .NET платформы, в смысле с точки зрения сборки.
2014.04 2019.48 "Игорь Лабутин" Во-первых, цель собрать все то, про что я говорил, в единый пакет.
2019.48 2022.60 "Игорь Лабутин" То есть куча репозиториев, но все это собирается в единый пакет.
2022.60 2025.36 "Игорь Лабутин" И надо сказать, на самом деле не один пакет.
2025.36 2030.80 "Игорь Лабутин" Сборка .NET не заканчивается тем, что мы получаем там .NET SDK инсталлер.
2030.80 2041.52 "Игорь Лабутин" Есть же еще кусочки, которые уходят в Visual Studio, типа розлина, есть кусочки, которые как-то паблишатся отдельно в виде .NET пакетов, это же все тоже нужно как-то собирать.
2041.52 2043.84 "Игорь Лабутин" Вторая цель - это security patches.
2043.84 2047.08 "Игорь Лабутин" С ними отдельная история, мы про них чуть дальше детально поговорим.
2047.08 2054.92 "Игорь Лабутин" Security patches нужно делать, но делать их правильно, не нарушая основной процесс разработки, на самом деле не такая тривиальная штука.
2054.92 2060.84 "Игорь Лабутин" И третье - это провалидировать все то, что мы подготовили к релизу, но на самом деле готовы к релизу.
2060.84 2062.96 "Игорь Лабутин" Там есть тоже некоторое количество тонкостей, я
2062.96 2068.36 None про них постараюсь рассказать. Итак, основные принципы, которым следует Microsoft.
2068.36 2076.44 "Игорь Лабутин" Основная команда разработчиков, то есть в обычной жизни, в большинстве случаев, вся разработка .NET ведется на GitHub.
2076.44 2082.60 "Игорь Лабутин" И Roslyn, и CLR, и основная библиотека .NET, все-все-все-все живет на GitHub.
2082.60 2088.72 "Игорь Лабутин" И в этом смысле они абсолютно прозрачны, то есть в принципе каждый может взять и разобраться, как это все работает.
2088.72 2090.16 "Игорь Лабутин" Но есть проблема с патчами.
2090.16 2106.68 "Игорь Лабутин" Если нашли какую-то уязвимость, security уязвимость, то было бы странно работать над ее исправлением на GitHub, где все открыто, и таким образом рассказать всему миру о том, что вот тут есть уязвимость, мы пока еще работаем над ее закрытием, и как бы мы еще не готовы, то бишь можно пользоваться уязвимостью.
2106.68 2112.48 "Игорь Лабутин" Это нехорошо, поэтому работа над уязвимостью на GitHub не ведется, она ведется отдельно.
2112.48 2114.68 "Игорь Лабутин" Перейдем к основным трудностям.
2114.68 2119.32 "Игорь Лабутин" Трудность первая - огромное количество репозиториев и огромное количество зависимости между ними.
2119.32 2132.92 "Игорь Лабутин" К счастью, их сейчас не такое огромное количество, их стало поменьше, и как раз таки в этой статье указано, что одна из причин уменьшения количества репозиториев стала дикая сложность графа зависимости, и время просто
2132.92 2144.64 None на сборку стало катастрофически огромным, поэтому их немножко уменьшили, сгруппировали, но все равно сгруппировать все в один-единые репозитории так просто не получится, там есть свои ограничения и по размеру, и по логике работы.
2144.64 2148.84 "Игорь Лабутин" Каждый репозиторий может зависеть от других каких-то репозиториев.
2148.84 2152.28 "Игорь Лабутин" И при этом таких зависимостей может быть несколько видов.
2152.28 2155.96 "Игорь Лабутин" Зависимость вида номер один - это просто зависит от public API.
2155.96 2168.04 "Игорь Лабутин" Ну, как пример, он почти везде во всей статье приводится, это Logging Abstractions, это просто public API, какие там логеры и так далее, никому не важно, но вот конкретно от логеров зависят все.
2168.04 2176.44 "Игорь Лабутин" Вторая зависимость - это использовать специфическую версию какого-то конкретного кусочка дотнета из соседнего репозитория.
2176.44 2191.40 "Игорь Лабутин" Такое нужно, когда идет сработа например какой-то фичи и в каком-то конкретном бранче соседнего репозитория эта фича уже сделана и вам нужно в вашем репозитории тоже использовать тот соседний репозиторий с этой готовой фичей.
2191.40 2197.56 "Игорь Лабутин" То есть вам нужен конкретный бранч конкретного репозитория, а не просто его, так сказать, публичная мейн-ветка.
2197.56 2221.84 "Игорь Лабутин" И третий вариант - это то, что я говорил, иногда зависимости получаются не совсем тривиальными, потому что например у нас есть пакет Microsoft Extensions Logging, он с одной стороны вроде как независимый и он собирается в NuGet, а с другой стороны он в виде исходничков по сути забирается внутри AspNet Core Framework и поставляется вместе с ним.
2221.84 2226.92 "Игорь Лабутин" И тут получается странная зависимость от исходного кода.
2226.92 2241.04 "Игорь Лабутин" И иногда на самом деле зависимости от исходного кода прям сборка собирается, это очень частая штука, потому что для бинарных дистрибутивов, например на Linux, там все сильно зависит от архитектуры и там часто все собирается только из исходников.
2241.04 2258.68 "Игорь Лабутин" Это все хорошо, но когда у нас получается такой огромная куча зависимостей, причем разнородных, нет уверенности, что при сборке проекта у нас вообще все зависимости сойдутся, то бишь тот же, допустим, Microsoft Extensions Logging будет одной единой версией на весь продукт, а было бы неплохо этого добиться.
2258.68 2261.00 None Это цель, которую нужно добиться.
2261.00 2263.56 "Игорь Лабутин" И по сути все зависимости в итоге образует граф.
2263.56 2272.84 "Игорь Лабутин" Сейчас для .NET 5 максимальная глубина этого графа это 6 уровней, то есть от репозитория с рантаймом, это самый такой, то от чего зависит много чего.
2272.84 2276.24 "Игорь Лабутин" От рантайма зависит WinForms, от WinForms зависит WPF.
2276.24 2285.16 "Игорь Лабутин" Как ни странно, я считал, что это два независимых репозитория, но нет, WPF зависит от WinForms, от WPS, от WPF зависит Windows Desktop, от него SDK и от него Installer.
2285.16 2286.40 "Игорь Лабутин" Ну, вроде логично.
2286.40 2291.12 None Пока вроде все не сложно, ну просто есть много репозиториев, они как-то между собой зависят.
2291.12 2292.12 "Игорь Лабутин" Теперь детали.
2292.12 2293.12 "Игорь Лабутин" Как?
2293.12 2297.56 "Игорь Лабутин" В каждом репозитории, если вы пойдете, посмотрите, есть файлик под названием version.details.xml.
2297.56 2301.68 "Игорь Лабутин" Это все находится в папочке ng, сокращение от ng.
2301.68 2309.96 "Игорь Лабутин" И в этом файлике написаны имена, версии, конкретный commit, конкретный репозиторий того, от чего зависит этот репозиторий.
2309.96 2317.80 "Игорь Лабутин" То есть если он там зависит от какого-нибудь Microsoft Extensions Logging, то будет написано, что он зависит от такого-то репозитория, такого-то бранча, такого-то коммита.
2317.80 2331.04 "Игорь Лабутин" И поскольку там есть в этом файлике и репозиторий, и коммит, то по большому счету можно для произвольно взятого коммита в любом репозитории построить полное дерево зависимости для сборки этого конкретного коммита.
2331.04 2332.04 "Игорь Лабутин" А зависимости бывает двух видов.
2332.04 2335.44 None Бывают продуктовые зависимости, это, собственно, то, что идет в финальный продукт.
2335.44 2341.00 "Игорь Лабутин" И с ними все строго, то есть это как раз та часть, которая пойдет в финальный продукт к конечному пользователю.
2341.00 2347.68 "Игорь Лабутин" А есть toolset зависимости, это всякие тесты, подготовка скриптов, сборка инсталлеров, ну то есть такие штуки, которые
2347.68 2354.20 None вроде как в конечный продукт не идут, но тоже важные. С ними чуть проще в плане зависимости, их можно там немножко расслаблять.
2354.20 2363.00 "Игорь Лабутин" Теперь смотрите, получается, что у нас есть дерево зависимости и по сути зависимости прописаны внутри репозитория прямо в коде, ну в XML файлик.
2363.00 2365.96 "Игорь Лабутин" Что делать, если нам нужно обновить зависимость?
2365.96 2377.52 "Игорь Лабутин" Представьте, что я, разработчик, поменял что-то в каком-нибудь там, не знаю, .NET Runtime и теперь я хочу, чтобы эта зависимость у меня каким-то образом проверилась в, ну не знаю, в WPF.
2377.52 2394.12 "Игорь Лабутин" Как мы помним, до WPF нужно пройти через WinForms еще, то есть мне нужно пойти и руками обновить WinForms, создать веточку там, обновить там, потом пойти в WPF, создать веточку там, обновить там, или даже не создавая веточки, а просто пусть даже это будет main ветка, обновить там все эти файлики.
2394.12 2396.12 "Игорь Лабутин" Кажется, слишком много ручной работы.
2396.12 2398.08 "Игорь Лабутин" Помножьте это на количество репозиторий, в коих там
2398.08 2404.52 None штук 20 по-моему. Поэтому Microsoft поступила просто, если у нас есть ручная работа, ее надо автоматизировать.
2404.52 2407.40 "Игорь Лабутин" Поэтому они написали сервис, который называется Maestro.
2407.40 2409.88 "Игорь Лабутин" Он по сути занимается следующей штукой.
2409.88 2416.64 None Он помнит из какого репозитория, из каких коммитов, что было собрано, так сказать, за всю историю.
2416.64 2418.08 "Игорь Лабутин" В итоге получается следующее.
2418.08 2432.00 "Игорь Лабутин" Каждый билд на самом деле репортит один из шагов билда, это зарепортить в Maestro, что только что собрался такой-то билд из такого-то репозитория, из такой-то ветки с таким-то, ну, этим самым git-коммитша, с самым чиксумой.
2432.00 2438.40 "Игорь Лабутин" После этого внутри Maestro можно строить связи результатов билдов с дальнейшими действиями.
2438.40 2440.36 None Для этого используются две концепции.
2440.36 2449.92 "Игорь Лабутин" Есть концепция ченнелов, но по сути она, эта концепция указывает, а что, для чего в принципе предназначен тот или иной билд.
2449.92 2453.60 "Игорь Лабутин" И вы, соответственно, аутпут любого билда можете проассоциировать с ченнелом.
2453.60 2460.24 "Игорь Лабутин" Точнее, вы ассоциируете pipeline с ченнелом, и в итоге все билды, которые валятся из этого pipeline будут падать в соответствующий ченнел.
2460.24 2466.80 "Игорь Лабутин" А дальше, да, примером ченнела может являться, например, Visual Studio 16.9 Preview 3.
2466.80 2481.52 "Игорь Лабутин" То есть это ченнел, это как бы intent, то, что они называют по-английски, то есть некоторое намерение с точки зрения продуктового, то есть это какой-то продукт, например, или версия продукта, или тестовая фича, или тестовый билд какой-нибудь internal и так далее.
2481.52 2497.44 "Игорь Лабутин" А дальше есть понятие subscriptions, когда вы можете сказать, что, "Маэстро, если в таком-то репозитории и таком-то ченнеле появился какой-то новый билд, то, пожалуйста, сходи вон в другой репозиторий и обнови там зависимость".
2497.44 2505.24 "Игорь Лабутин" Но причем это делается не совсем автоматически, Маэстро просто создает pull request, его все еще нужно замерзнуть руками, но, по крайней мере, pull request создается автоматически.
2505.24 2522.44 "Игорь Лабутин" Таким образом, в моем примере получается, что Маэстро просто настроил, что если из .NET Runtime собирается что-то, и допустим, это из main бранча, то автоматически в .NET WinForms репозитории создастся pull request со словами "Давай обновимся", в том референсе, последнюю правильную версию Runtime.
2522.44 2536.80 "Игорь Лабутин" Мы можем знать, что, например, там что-то сильно не готово, и не будем обновлять, но в процессе сборки pull request он соберется и поймет, что, например, там в Runtime что-то сломали, и мы тогда подождем, пока не пофиксит Runtime, либо мы можем сказать "Да, окей" и замерзнуть это тело.
2536.80 2543.88 "Игорь Лабутин" Таким образом, мы как бы proactive, по сути, получается автоматически обновляем версии полуавтоматически в последующих репозиториях, зависимо.
2543.88 2548.60 "Игорь Лабутин" Ченнелы, кстати, также еще определяют, нужно ли вообще хоть что-то куда-то паблишить, паблишить результаты.
2548.60 2557.28 "Игорь Лабутин" То есть можно, например, сказать, что этот ченнел там тестовые билды или там pull request билды, по результатам pull request билда результат собственного билда не надо никуда паблишить.
2557.28 2559.16 "Игорь Лабутин" Он просто сваливается в никуда и все.
2559.16 2563.76 "Игорь Лабутин" Ну или в каком-нибудь хранилище, чтобы просто посмотреть на результаты тестов, если надо, и все.
2563.76 2567.32 "Игорь Лабутин" А официальные билды, например, куда-то валятся дальше, во внутренние NuGet фиды.
2567.32 2588.20 "Игорь Лабутин" И тут есть такая штука, что поскольку зависимости много и они могут по большому счету образовывать, ну не циклы, но получается как бы одна и та же зависимость может разными путями приходить в конечный продукт, то технически может быть ситуация, что в одной и той же зависимости есть несколько версий, которые входят в один и тот же продукт в один момент времени.
2588.20 2596.80 "Игорь Лабутин" То есть через там WinForms вы получили одну версию логинг-абстракшнс, а через рантайм другую версию логинг-абстракшнс, потому что WinForms ссылается на другую версию рантайма.
2596.80 2597.80 "Игорь Лабутин" Так сложилось.
2597.80 2601.04 "Игорь Лабутин" И команда Microsoft считает, что это нормально.
2601.04 2626.44 "Игорь Лабутин" То есть в целом они приемляют риск того, что что-то будет не работать, где-то будут получаться какие-то не совсем совместимые версии, но это позволяет им все-таки двигаться нормально вперед и не тупить, ожидая пока там любое минорное изменение в каком-нибудь очень сильно внутреннем репозитории, типа рантайма, будет раскопировано по всем дальнейшим зависимым репозиториям, прежде чем все остальные могут продолжить работу.
2626.44 2627.44 "Игорь Лабутин" Поэтому да.
2627.44 2629.44 "Анатолий Кулаков" Наверное, с минорным вопросов никаких нет.
2629.44 2631.68 "Анатолий Кулаков" А что делать, если изменение мажорное?
2631.68 2637.76 "Игорь Лабутин" Если изменение мажорное, то соответственно, Маэстро автоматически создаст pull request в зависимой репозитории.
2637.76 2642.08 "Игорь Лабутин" Ну и скорее всего, если оно мажорное, там что-то сломали, что-нибудь не соберется.
2642.08 2650.52 "Игорь Лабутин" Тогда придет, так сказать, разработчик и в рамках этого pull request будет фиксить, условно говоря, WinForms-репозиторий, чтобы он соответствовал новому рантайму.
2650.52 2654.12 "Анатолий Кулаков" И соответственно обновит референс на новый репозиторий, на новый коммит.
2654.12 2655.12 "Игорь Лабутин" Да.
2655.12 2663.28 "Игорь Лабутин" И вместе с этой штукой, он вместе с обновлением вершин XML, он обновит, туда же закоммитит нужные изменения в CSS, для примера.
2663.28 2667.32 "Игорь Лабутин" То есть это некоторая ручная работа, но все-таки таких прям ломающих изменений не так много.
2667.32 2668.32 "Игорь Лабутин" Объектив.
2668.32 2669.32 "Игорь Лабутин" По крайней мере, как они говорят.
2669.32 2678.00 "Игорь Лабутин" А то, что могут приехать две разных минорные версии, то есть там приедет какая-нибудь 503 и 504 от Logging Abstractions, ну скорее всего там какие-нибудь мелочи изменились.
2678.00 2682.92 "Игорь Лабутин" И в 90% кода всего остального, скорее всего, вы разницы не почувствуете.
2682.92 2685.56 "Игорь Лабутин" Наверняка где-нибудь что-нибудь сломается, но в целом разницы этого не почувствую.
2685.56 2686.84 "Игорь Лабутин" А то, что сломалось, можно пойти по фичам.
2686.84 2691.72 "Игорь Лабутин" Но для релиза, конечно, нужно, чтобы все собралось вместе и пришло к единой версии.
2691.72 2692.72 "Игорь Лабутин" Для этого есть свой процесс.
2692.72 2695.76 "Игорь Лабутин" А как раз-таки про это сейчас поговорим.
2695.76 2696.76 None Релиз продукта.
2696.76 2713.52 None По сути, по сути, система вот эта вот, Maestro, устроена так, что рано или поздно, если вы закончили менять код, именно вот фичи писать, то рано или поздно, по мере закрывания всех pull-requests, система придет в абсолютно то, что они называют, когерентное состояние.
2713.52 2721.64 "Игорь Лабутин" Все билды в итоге пройдут, все pull-requests будут закрыты, то есть все зависимости будут ссылаться на последнюю финальную хорошую версию.
2721.64 2723.56 "Игорь Лабутин" Это как бы цель для релиза.
2723.56 2726.96 "Игорь Лабутин" Поэтому что делается обычно, когда нужно зарелизить .NET?
2726.96 2732.08 "Игорь Лабутин" То, что мы видим, когда происходит превью-релиз и обычный релиз тоже, происходит примерно следующий цикл.
2732.08 2739.00 "Игорь Лабутин" Во-первых, делается некая подготовка, то есть создаются бранчи, создаются там правильные версии, ну, с точки зрения
2739.00 2751.40 None тегов и так далее. Дальше туда, понятно, что коммитятся всякие изменения, все баги, и все это повторяется до тех пор, пока не стабилизируется, то есть пока не пофиксятся все баги, которые выбраны для этого превью или для релиза.
2751.40 2755.52 "Игорь Лабутин" После этого не пройдут все билды, билды не запушат все, что куда нужно.
2755.52 2765.32 "Игорь Лабутин" После этого обновится вся версия зависимых репозиториев, там тоже все pull-requests закоммитятся и так далее, пока все это не доберется до репозитория с инсталлером, которая будет зависеть от каких-то версий, которые, собственно,
2765.32 2767.32 None нужно зарелизить. Это мы все зарелизили.
2767.32 2770.72 "Игорь Лабутин" После этого, не зарелизили, в смысле, это мы все собрали.
2770.72 2773.84 "Игорь Лабутин" После этого есть еще такой репозиторий, называется
2773.84 2792.12 None .NET/SourceBuild, SourceDeficeBuild. Это на самом деле некоторая копия исходников .NET, можно сказать, то есть это репозиторий, который позволяет собрать .NET гарантированно, независимо от внутренних майкрософтских ресурсов, каких-нибудь внутренних, ну, GetFeed.
2792.12 2796.40 "Игорь Лабутин" Внутренних, там, не знаю, артефактов, лежащих где-то в HDWOPS.
2796.40 2798.52 None Ну, то есть, короче, абсолютно снаружи.
2798.52 2799.52 None Зачем?
2799.52 2805.32 None Это нужно, потому что есть некоторые партнеры, например, RedHat, как выясняется, которые собирают .NET сами.
2805.32 2813.96 None Ну, то есть, если у вас есть, например, в RedHat пакетный менеджер, и вы хотите оттуда поставить .NET, то вот тот .NET собирается самим RedHat из вот этих исходников.
2813.96 2815.96 "Игорь Лабутин" Это не Microsoft его собирает.
2815.96 2831.52 "Игорь Лабутин" Поэтому, как только у вас все стабилизировалось, подготавливается вот этот вот .NET/SourceBuild, а также с помощью Maestro собирается огромная пачка всех вещей, которые, собственно, нужно зарелизить в некую финальную папочку, откуда это все будет сделано.
2831.52 2840.60 "Игорь Лабутин" Дальше то, что собралось, все эти артефакты проверяются некоторыми integration тестами, то есть, например, проверяется, что все это заведется вместе с Visual Studio.
2840.60 2845.72 "Игорь Лабутин" То есть, тест вместе с Visual Studio — это не тот тест, который можно сделать в рамках GitHub'овских pull-requests.
2845.72 2850.36 "Игорь Лабутин" Там запускается только unit-тест, а полноценные integration-тесты делаются уже непосредственно перед релизом.
2850.36 2851.88 "Игорь Лабутин" Возможно, фиксится баги.
2851.88 2856.40 "Игорь Лабутин" Дальше все это, соответственно, повторяется, повторяется, повторяется, пока все не пофикшено.
2856.40 2863.80 "Игорь Лабутин" Параллельно с этим, вот эти вот .NET'овский source build — результат, посылается партнерам, чтобы они у себя проверили, что все собирается.
2863.80 2865.68 "Игорь Лабутин" И тоже все фиксится, фиксится, повторяется.
2865.68 2871.08 "Игорь Лабутин" Короче, пока вот это все не стабилизируется, все просто повторяется, а как только все стабилизировалось, все готово.
2871.08 2872.08 "Анатолий Кулаков" Релиз.
2872.08 2874.20 "Анатолий Кулаков" Каким образом расшаривается security уязвимости?
2874.20 2881.76 "Анатолий Кулаков" Ты упоминал, что их нельзя publish'ить, а, соответственно, что для того, чтобы их получил Red Hat, я вынужден их положить в публичный репозиторий.
2881.76 2883.92 "Анатолий Кулаков" Ух, тут все сложно.
2883.92 2887.52 None Значит, я так понимаю, что Red Hat их не получит до того, как не пофиксит их официально.
2887.52 2901.84 "Игорь Лабутин" Microsoft и они не будут зарелизлены официально, но проблема тут скорее не в Red Hat, а проблема в том, что я, как Microsoft, не хочу видеть, точнее, я не хочу, чтобы другие видели, какие конкретные изменения в коде я делаю, чтобы работать над уязвимостью.
2901.84 2907.40 "Игорь Лабутин" Потому что это означает, что эту уязвимость можно очень хорошо эксплуатировать, пока я ее не пофиксил.
2907.40 2913.56 "Игорь Лабутин" Поэтому на GitHub их делать нельзя, у Microsoft поэтому есть такая процедура, заключающаяся в следующем.
2913.56 2922.16 "Игорь Лабутин" Помимо GitHub, на котором ведется вся основная разработка, у Microsoft есть свой собственный Azure DevOps сервер внутри, где содержится полная копия GitHub.
2922.16 2927.08 None Ну, насколько я понял, конкретно тех бранчей, которые как бы сейчас активны на GitHub.
2927.08 2931.60 None Понятно, что бранчи, которые уже не очень активны, которых закончилась поддержка, можно не держать.
2931.60 2943.48 "Игорь Лабутин" Ну, допустим, вот сейчас у нас вышел релиз 5.0, поэтому на GitHub есть веточка "release/5.0", и в Azure DevOps тоже есть веточка "release/5.0", и они между собой автоматически синхронизируются.
2943.48 2947.04 "Игорь Лабутин" Как только вы что-то коммитите на GitHub, оно автоматом переносится в Azure DevOps.
2947.04 2955.92 "Игорь Лабутин" Понятно, что до тех пор, пока вы не коммитите ничего в Azure DevOps, это по сути просто fast-forward merge, никаких конфликтов там не будет, и все работает автоматически.
2955.92 2963.60 "Игорь Лабутин" Помимо этого, в Azure DevOps есть веточка "internal/release/5.0", куда тоже все мержится автомат.
2963.60 2973.68 "Игорь Лабутин" И вот если у вас есть какая-то работа, которую нужно сделать для Security Fix, она делается в Azure DevOps внутри Microsoft, невидимой никому, кроме Microsoft, в этой самой internal ветке.
2973.68 2977.56 "Игорь Лабутин" С точки зрения системы Maestro, эта internal ветка, она
2977.56 2989.04 None точно такая же ветка, тоже в Git. Единственное, что на ней просто указывается, что она зависит не от public GitHub веток, а она зависит от internal веток внутри вот этого version.xml файлика.
2989.04 2998.76 "Игорь Лабутин" И поэтому, в принципе, для нее работают все абсолютно те же механизмы про автоматическую сборку, автоматические pull-requests на update version.xml и так далее.
2998.76 3003.96 "Игорь Лабутин" То есть, весь тот процесс, который работает на GitHub, также работает и на внутренних ветках.
3003.96 3010.56 "Игорь Лабутин" Поэтому Security Fix делается в internal ветке, это все проверяется, тестируется, мержится и так далее.
3010.56 3017.60 "Игорь Лабутин" Как только готово все к релизу, в этот момент содержимое internal ветки мержится обратно в public ветку.
3017.60 3019.88 "Игорь Лабутин" Ну и, соответственно, все готово.
3019.88 3030.00 "Игорь Лабутин" Релиз при этом происходит из internal ветки, то есть, он выкладывается сначала для распространения, а уже после этого это все выкатывается обратно на GitHub и становится видимым всем.
3030.00 3047.60 "Игорь Лабутин" Единственный момент, что поскольку там много всего, и в этот момент могут быть конфликты, то там есть техника про то, что пока идут всякие internal-релизы, в тот день, когда все работают над internal-релизом и делается релиз, то выключается вся эта flow для public ветки.
3047.60 3052.44 "Игорь Лабутин" И наоборот, пока internal-релизов нет, для internal-релизов нет, не работает maestro.
3052.44 3070.52 "Игорь Лабутин" С этим они что-то делают и подумают, как это все чуть-чуть улучшить, потому что конфликтов на самом деле очень много может быть, если в internal ветках был security commit, который не перенесен, а в public ветках работа все еще идет, и там уже никакого fast-forward не получается, как с этим быть, они пока думают.
3070.52 3072.96 "Игорь Лабутин" Это про security fixes.
3072.96 3078.56 "Игорь Лабутин" И это все касается, естественно, допустим, SDK-инсталлеров и так далее, но есть еще Nuget.
3078.56 3084.88 "Игорь Лабутин" Понятно, что есть еще какое-то количество вещей, которые Microsoft просто паблишит официально на nuget.org, и с ними тоже
3084.88 3089.24 None надо что-то делать. Microsoft все это сделал следующим образом.
3089.24 3094.32 "Игорь Лабутин" У них есть три набора nuget-фидов абсолютно идентичных.
3094.32 3101.76 "Игорь Лабутин" Во-первых, то, что называется shipping feeds, это внутренние результаты сборки, скажем так, основных веток, типа
3101.76 3109.44 None там, релиз 5.0 или мейна, но они доступны всем. Если хочется, у Microsoft есть свой собственный nuget-сервер, который можно туда посмотреть.
3109.44 3113.32 "Игорь Лабутин" Они прописаны в nuget-конфигах в репозиториях дот-нета,
3113.32 3116.80 None и автоматически оттуда все тянется. Дальше есть non-shipping feeds.
3116.80 3118.96 "Игорь Лабутин" Это второй набор nuget-фидов.
3118.96 3126.16 "Игорь Лабутин" Они используются только для всяких private-фичеведок, там, pull-request-builds, и они не прописаны в nuget-конфиге,
3126.16 3129.64 None но они туда автоматом подставляются при сборке, в момент начала сборки.
3129.64 3131.88 "Игорь Лабутин" Есть еще такая же концепция, как isolated feeds.
3131.88 3133.36 "Игорь Лабутин" Это очень странная концепция.
3133.36 3141.60 "Игорь Лабутин" Они создают фиды по мере необходимости, включая туда аж прям хэш-код комита, чтобы убедиться, что это точно гарантированно уникальный фид.
3141.60 3154.60 "Игорь Лабутин" И это они делают для того, чтобы в момент сборки релиза быть уверенным, что релиз соберется из чистых nuget-фидов, не подтянув какие-нибудь старые закэшированные внутренние сборки или еще что-нибудь в таком духе.
3154.60 3156.68 "Игорь Лабутин" В общем, такая странная концепция.
3156.68 3158.08 "Игорь Лабутин" Но, тем не менее, работает.
3158.08 3161.56 "Игорь Лабутин" Ну и дальше, собственно, финальный релиз, как я говорил.
3161.56 3180.32 "Игорь Лабутин" То есть, маэстро системе берет нужный комит из репозитория dotnet-инсталлер, обходит все дерево, собирает все, ну вообще по этому дереву было сгенерено, ну все дейлельки, релиз, артефакты и так далее, в одну большую директорию.
3180.32 3198.84 "Игорь Лабутин" Дальше есть специальный пайплайн в Azure DevOps, его нет в GitHub никак, который делает некоторые финальные проверки, то есть он проверяет, что все nugety правильно подписаны, все дейлельки правильно подписаны, запихивает этот результат сборки в пайплайны для Visual Studio, чтобы когда она будет собираться туда, все это попало.
3198.84 3203.20 None Он проверяет какие-то баги, ну и все это дальше лежит и ждет дня релиза.
3203.20 3225.60 "Игорь Лабутин" В день релиза это все запушивается на всякие сайтики dot.net, на nuget, в docker, репозитория тегаются, в этот момент как раз-таки internal бранчи все мержатся обратно в public-release бранчи, если это был security-release, и весь релизный код, который был зарелижен, пабличится pull-request к dotnet-source-build репозиторию, чтобы он там тоже остался.
3225.60 3226.60 "Игорь Лабутин" Ну и все.
3226.60 3231.52 "Игорь Лабутин" Дальше можно продолжать работу в main-бранчи, поменять версию на следующую и погнали следующий релиз делать.
3231.52 3241.80 "Игорь Лабутин" Короче, после прочтения этой статьи, она такая, нифигово длинная, я ее читал три раза, прежде чем я примерно хоть как-то уложил в памяти и в голове, как это все работает.
3241.80 3246.28 "Игорь Лабутин" То есть кажется, что Microsoft с одной стороны построил какую-то охрененно сложную структуру для того, чтобы
3246.28 3252.68 None все это работало нормально и при этом было public, но при этом оно, видимо, действительно работает, dotnet выходит довольно регулярно.
3252.68 3254.24 "Анатолий Кулаков" Да, и работает хорошо.
3254.24 3268.08 "Анатолий Кулаков" Но насколько я понимаю, что у любой большой корпорации есть такой продукт, там у Google есть свой вообще сборочный тул, даже эта сборочная инфраструктура, у Facebook есть, у JetBrains написан свой, но то есть, скорее всего, без этого никак.
3268.08 3285.64 "Игорь Лабутин" Да, в шоу-ноутах будут ссылочки, во-первых, на список всех репозиториев dotnet, ну на саму статью, понятно, на список всех репозиториев, из которых собирается dotnet, а также вот эта вся система maestro, про которую я упоминал, она тоже open-source, она лежит на GitHub-е Microsoft, так что можно на нее посмотреть, как она устроена, как она работает.
3285.64 3293.04 "Анатолий Кулаков" Отлично, а мне, в принципе, вспомнился доклад Михаила Филиппова с dotnext Москвы 2020.
3293.04 3299.68 "Анатолий Кулаков" Я думаю, докладик мы тоже приложим, там он как раз рассказывал про инфраструктуру, как у них в JetBrains работает.
3299.68 3304.00 "Анатолий Кулаков" И там тоже нагорожено довольно много оптимизации, довольно много интересных решений.
3304.00 3307.60 "Анатолий Кулаков" Если тема вам нравится, то обязательно посмотрите Михаила Филиппова.
3307.60 3308.60 "Анатолий Кулаков" Окей.
3308.60 3314.16 "Анатолий Кулаков" Интересно, а с какого раза слушатели смогут прослушать вот этот топик в твоем исполнении, если ты статью читал только три раза?
3314.16 3318.84 "Анатолий Кулаков" То есть получилось довольно-таки глобальное, монументальное как прямо сага про супергероев.
3318.84 3326.80 "Игорь Лабутин" Я, честно говоря, собираюсь сам переслушать это, когда это выйдет уже в обработанном виде, чтобы понять вообще, насколько подробно я все это объяснил, насколько понятно.
3326.80 3331.84 "Игорь Лабутин" Потому что у меня есть большой риск, что я сам это не пойму, когда послушаю сам себя.
3331.84 3340.88 "Игорь Лабутин" Кстати, да, если будут какие-то отзывы, было понятно, было непонятно, было слишком быстро, медленно, подробно-неподробно, вы там напишите в комментах, мне будет интересно почитать.
3340.88 3347.04 "Анатолий Кулаков" Да, и вообще не забывайте писать нам отзывы, мы все обязательно читаем, все обязательно применяем и вообще рады любому фидбэку.
3347.04 3348.80 "Анатолий Кулаков" Поэтому пишите нам что-нибудь.
3348.80 3354.72 "Анатолий Кулаков" Давай, ты пока отдохни, сейчас я достану какую-нибудь слабенькую тему, чтобы разгрузить наших слушателей и плюс тебе отдышаться.
3354.72 3356.88 "Анатолий Кулаков" Вот, например, WebAssembly.
3356.88 3365.80 "Анатолий Кулаков" Наткнулся недавно на интересную статейку, которая просто-напросто расставляет ключевые точки над тем, что такое WebAssembly и что его ждет в будущем.
3365.80 3367.08 "Анатолий Кулаков" Давайте немножко вспомним.
3367.08 3370.48 "Анатолий Кулаков" Я думаю, что WebAssembly вошел в нашу жизнь прочно и надолго.
3370.48 3381.52 "Анатолий Кулаков" Блейзер зарелизился, уна везде и каждому, и поэтому необходимо каждому разработчику хотя бы понимать, хотя бы знать, что вокруг него творится в плане WebAssembly.
3381.52 3382.96 "Анатолий Кулаков" Итак, что же такое?
3382.96 3387.36 "Анатолий Кулаков" Я повторил это слово уже много-много раз и, может быть, не все с ним знакомы.
3387.36 3388.56 "Анатолий Кулаков" Давайте разберемся.
3388.56 3404.16 "Анатолий Кулаков" Прежде всего, WebAssembly - это такой низкоуровневый стандарт языка, который разрабатывался специально для того, чтобы быть безопасным, быстрым, компактным и портабельным, чтобы его можно было легко переносить между различными платформами и легко интерпретировать.
3404.16 3410.72 "Анатолий Кулаков" Прежде всего, этот язык создавался не для того, чтобы на нем писали руками, ну как и обычный ассемблер.
3410.72 3413.48 "Анатолий Кулаков" Не зря здесь есть какая-то ассоциация с ассемблером.
3413.48 3431.20 "Анатолий Кулаков" Язык создавался для того, чтобы в него компилировались, транслировались инструкции из более высокоуровневых языков, такие, которые уже популярны в мире, и он должен быть с ними хорошо совместим и обеспечивать единую и быструю платформу.
3431.20 3436.72 "Анатолий Кулаков" Но, несмотря на название, WebAssembly ограничен не только браузером.
3436.72 3441.80 "Анатолий Кулаков" То есть, есть стереотипы, что WebAssembly справедливости только для браузера и только там должен запускаться.
3441.80 3451.20 "Анатолий Кулаков" На самом деле, в 2019 году появился новый стандарт, который называется WebAssembly System Interface, или сокращенно WASI.
3451.20 3460.28 "Анатолий Кулаков" Это как раз-таки стандарт, который описывает, каким образом можно безопасно, прежде всего, встроить и исполнять WebAssembly вне браузера.
3460.28 3468.76 "Анатолий Кулаков" Благодаря нему вы можете запустить код, который написан для WebAssembly на вашем десктоп-приложении, на ваших серверах и вообще где только вам вздумается.
3468.76 3477.28 "Анатолий Кулаков" Поэтому это получается такой кроссплатформенный ассемблер, который не зависит ни от операционной системы, ни от процессора, ни от типа памяти и вообще ни от чего.
3477.28 3483.04 "Анатолий Кулаков" Звучит довольно идеалистически, но он пока со всей своей этой функцией довольно хорошо справляется.
3483.04 3488.36 "Анатолий Кулаков" Итак, что же у нас уже произошло с WebAssembly в 2020 году?
3488.36 3494.76 "Анатолий Кулаков" Прежде всего, добавились такие интересные вещи, как Reference Type, Bulk Memory Operations.
3494.76 3502.68 "Анатолий Кулаков" На WebAssembly были официально зарелижены такие продукты, как Google Earth и всем известный Zoom.
3502.68 3505.68 "Анатолий Кулаков" Тоже используют WebAssembly для своего Web-клиента.
3505.68 3510.20 "Анатолий Кулаков" Uno Platform проанонсировала поддержку Visual Studio и Code.
3510.20 3515.08 "Анатолий Кулаков" Свою визуальную часть она собирается делать на WebAssembly.
3515.08 3529.08 "Анатолий Кулаков" Конечно же, зарелизился Blazor WebAssembly вместе с .NET 3.1 Core, который позволяет C# разработчикам писать Single Page Application на C#, не заморачиваясь с JavaScript.
3529.08 3535.56 "Анатолий Кулаков" В будущем году, то есть уже в текущем году, в 2021, нас ждут следующие улучшения.
3535.56 3538.76 "Анатолий Кулаков" Прежде всего, планируют сделать модуль Linking.
3538.76 3543.48 "Анатолий Кулаков" Это специальная система, которая позволяет слинковать два модуля в рантайме.
3543.48 3547.76 "Анатолий Кулаков" Модули могут быть написаны на разных языках и абсолютно различаться друг от друга.
3547.76 3550.88 "Анатолий Кулаков" Но теперь мы должны будем уметь это делать.
3550.88 3551.88 "Анатолий Кулаков" Interface Types.
3551.88 3557.04 "Анатолий Кулаков" На самом деле, WebAssembly довольно-таки примитивный язык, на то он ассемблер.
3557.04 3559.80 "Анатолий Кулаков" Чтобы вы понимали, он поддерживает всего 4 типа данных.
3559.80 3581.20 "Анатолий Кулаков" Это 32-битный int и 64-битный int, 32-битный float, 64-бит float и вот этот пропозал на Interface Types как раз-таки позволяет нам немножко наградить больше типов, больше высокоуровневых типов, которые базируются на этих четырех, чтобы их понимали разные языки.
3581.20 3587.76 "Анатолий Кулаков" Чтобы разные языки могли скомпилировать какие-то более сложные структуры, более сложные классы.
3587.76 3596.24 "Анатолий Кулаков" Таким образом, чтобы на WebAssembly линкер и WebAssembly модули их поняли, разобрали и состыковали между различными платформами.
3596.24 3603.32 "Анатолий Кулаков" Планируется улучшить дебаггинг, потому что сейчас весь дебаггинг заключается в том, что вы можете писать месседжи в консоль.
3603.32 3606.40 "Анатолий Кулаков" Решили остановиться на стандарте дебаггинга DWARF.
3606.40 3610.36 "Анатолий Кулаков" Это такой специальный дебаг-формат, который довольно хорошо распространен.
3610.36 3619.52 "Анатолий Кулаков" Также активно Unoplatform работает вместе с Microsoft и вместе с онлайн-комьюнити на том, чтобы улучшить WebAssembly для .NET платформ.
3619.52 3627.92 "Анатолий Кулаков" И у них есть очень много вклада в performance, в визуальные редакторы, и в рекламу, и в маркетинг.
3627.92 3634.08 "Анатолий Кулаков" В общем, все, чтобы C# разработчики получили еще один WebAssembly фреймворк.
3634.08 3636.12 "Анатолий Кулаков" Я напомню, что у нас уже есть релиз Blazor.
3636.12 3640.64 "Анатолий Кулаков" Чтобы у нас был выбор, чтобы мы могли сами понимать, что из этого мы хотим выбрать.
3640.64 3643.28 "Анатолий Кулаков" Кстати, Unoplatform довольно-таки хорошо светится.
3643.28 3647.36 "Анатолий Кулаков" Мы в своих обзорах ее довольно часто игнорировали.
3647.36 3652.60 "Анатолий Кулаков" Наверное, в будущем мы устраним эту неприятность и обратим на нее более пристальное внимание.
3652.60 3659.28 "Анатолий Кулаков" Из наиболее распространенных заблуждений, которые существуют с WebAssembly, хотелось бы подчеркнуть security.
3659.28 3667.88 "Анатолий Кулаков" Многие говорят, что это ассемблер, он будет доступен на моей машине, а также он закачивается из веба, из веба могут прийти вирусы.
3667.88 3669.48 "Анатолий Кулаков" И вот стандартная мешанина.
3669.48 3676.88 "Анатолий Кулаков" Здесь хочется обозначить, что WebAssembly - это прежде всего язык, который всегда будет исполняться внутри сэндбокса.
3676.88 3679.76 "Анатолий Кулаков" И разрабатывался он с пристальным вниманием на security.
3679.76 3685.12 "Анатолий Кулаков" То есть там изоляция практически как у JavaScript, а в некоторых местах даже и больше.
3685.12 3690.36 "Анатолий Кулаков" То есть ограничения на security там довольно-таки жесткие.
3690.36 3693.76 "Анатолий Кулаков" И никто с помощью этого кода никогда ваш компьютер не испортит.
3693.76 3700.84 "Анатолий Кулаков" Поэтому не волнуйтесь, это возможно только из-за каких-нибудь страшных дыр в сэндбоксах, о которых, в принципе, я еще не слышал.
3700.84 3701.84 "Анатолий Кулаков" Ну, поживем - увидим.
3701.84 3711.36 "Анатолий Кулаков" Еще одно интересное заблуждение - это в том, что WebAssembly сильно похож на Silverlight и поэтому должен через пару лет закончиться.
3711.36 3735.96 "Анатолий Кулаков" Хочется обозначить, что WebAssembly, в отличие от Silverlight, поддерживается не компанией Microsoft, не только компанией Microsoft, а прежде всего это стандарт, который поддерживается всеми большими игроками браузеров, который уже проник на мобильные браузеры, естественно, на десктопы, который уже получил стандартизацию на то, чтобы запускаться вообще вне браузера.
3735.96 3749.00 "Анатолий Кулаков" То есть это большой стандарт, который поддерживают все игроки, с помощью которого они оптимизируют свои браузеры, с помощью которого уже пишутся графические редакторы, музыкальные редакторы, трехмерные редакторы.
3749.00 3756.64 "Анатолий Кулаков" И за ним стоит не одна какая-то большая компания, а множество всех лидеров индустрии и маленьких компаний.
3756.64 3764.88 "Анатолий Кулаков" Поэтому если даже какая-то одна большая компания полностью откажется от этого стандарта, то ничего не умрет, браузер продолжит работать, программа продолжит запускаться.
3764.88 3770.24 "Анатолий Кулаков" Жизнь у него должна быть намного дольше, намного интереснее, намного веселее, чем у Silverlight.
3770.24 3772.68 None Вот как-то такие новости у нас про WebAssembly.
3772.68 3776.28 None Посмотрим, как все это будет адаптиться дальше.
3776.28 3783.00 "Игорь Лабутин" Будем освещать все новости, которые будут происходить вокруг Blazor и всех остальных тулов на WebAssembly.
3783.00 3784.76 "Игорь Лабутин" Итак, поехали дальше.
3784.76 3787.56 "Игорь Лабутин" Снова немножко в техническую тему.
3787.56 3792.56 "Игорь Лабутин" Попалась статья Андрю Лока про introduction to the data protection system in the S/P/Net Core.
3792.56 3799.84 "Игорь Лабутин" И честно говоря, до этой статьи я как-то не считал, что где-то в S/P/Net Core есть такая отдельная система, называемая data protection.
3799.84 3800.84 "Игорь Лабутин" Что там протектить-то?
3800.84 3804.16 "Игорь Лабутин" Как бы мои данные я сам их в базу кладу и все протекчу.
3804.16 3806.40 "Игорь Лабутин" Оказалось, нет, есть что.
3806.40 3813.44 "Игорь Лабутин" Фактически в S/P/Net Core на самом деле есть некоторое количество данных, про которые вы может быть даже не задумываетесь, но их надо протектить.
3813.44 3822.04 "Игорь Лабутин" А именно, если вы пользуетесь стандартным S/P/Net Core Identity, то вы с ненулевой вероятностью используете то, что называется
3822.04 3841.12 None authentication cookies. То есть это просто некоторое выглядит как строчка более или менее произвольная, которая отсылается клиенту в ответ на авторизацию и дальше клиент с помощью нее авторизуется обратно, чтобы не проходить повторно процедуру логина и не присылать логин, пароль в каждом сообщении, что не очень безопасно.
3841.12 3858.36 "Игорь Лабутин" В cookies этих хранится не только логин ваш, но возможно еще хранятся какие-то клеймы, то есть по сути права ваши по отношению к этому приложению и было бы неплохо их как-то защищать, чтобы вы как клиент или ваш клиент мог быть уверенным, что эти права невозможно подделать.
3858.36 3865.00 "Игорь Лабутин" Ну и сам клиент не подделывал бы эти права, добавляя себе какие-то клеймы, которые вы бы не хотели, чтобы он их добавлял или которые у него нет прав.
3865.00 3873.12 "Игорь Лабутин" Поэтому на самом деле вот эта строчка authentication cookie, она инкриптится с помощью некоторых ключей, перед
3873.12 3876.92 None тем как послать пользователю и дегриптится, когда получается от пользователя.
3876.92 3879.72 "Игорь Лабутин" Вопрос, а где ключи-то?
3879.72 3881.44 None То есть откуда берутся ключи?
3881.44 3886.56 None А если есть ключи, то естественно возникает следующий вопрос, а как мы их ротейтим?
3886.56 3891.68 "Игорь Лабутин" Потому что если у нас есть ключи, то правило хорошо, то она говорит, что эти ключи нужно периодически менять.
3891.68 3893.96 "Игорь Лабутин" Ну и что делать?
3893.96 3900.40 "Игорь Лабутин" Фактически как раз таки система Aspen@Core Data Protection этим и занимается.
3900.40 3907.88 "Игорь Лабутин" Она более или менее абстрагирует все это от вашего взгляда и если вам туда не надо лезть, то вы даже не заметите, что оно там работает.
3907.88 3914.64 "Игорь Лабутин" Внутри она использует симметрическое шифрование, и поскольку нужно шифровать несколько разных видов данных, то
3914.64 3927.80 None один из них я сказал, это authentication cookies, но если вы например используете стандартный UI-чик Aspen@Core Identity, то там есть формочка паспорт ресета и тогда вам приходят некоторые уникальные токены, по которым вы можете сбросить пароль.
3927.80 3930.00 "Игорь Лабутин" Они тоже шифруются и так далее.
3930.00 3938.56 "Игорь Лабутин" И вот все эти штуки очень бы желательно шифровать разными ключами, чтобы не было соблазна, если вы вдруг берете ключ к одному, но использовать для всего остального.
3938.56 3941.12 "Игорь Лабутин" Поэтому делается фактически следующим образом.
3941.12 3947.16 None Есть некоторый мастер ключ, который как раз таки хранится и который секретный и все такое.
3947.16 3954.44 "Игорь Лабутин" И дальше из него можно создать дочерние ключи, указав purpose, то есть предназначение этих ключей.
3954.44 3965.80 "Игорь Лабутин" Это просто строчка, которая по сути скомбинированная с мастер ключом выдает уникальный дочерний ключ, причем имея только мастер ключ и строчку, дочерний ключ можно заново получить.
3965.80 3968.56 "Игорь Лабутин" Таким образом, дочерние ключи в принципе хранить не обязательно даже.
3968.56 3972.80 "Игорь Лабутин" От дочерних ключей можно наследовать дальше, если очень нужно.
3972.80 3974.96 "Игорь Лабутин" В принципе ничего не ограничивает.
3974.96 3986.20 "Игорь Лабутин" До того, как родился ASP.NET Core и вся вот эта подсистема, вы наверное слышали про такую штуку, как Moshitkey, была такая опция в XML-ном конфике, старого DotNet Framework.
3986.20 3992.92 "Игорь Лабутин" И там можно указать некоторые ключики, которые как раз таки использовались для того, чтобы ASP все шифровал.
3992.92 4003.88 "Игорь Лабутин" Но есть некоторые проблемы, поскольку это конфигурируется на уровне всей машины, то во-первых, оно глобально, во-вторых, возникает вопрос, а как это все синхронизировать между разными машинками.
4003.88 4018.44 "Игорь Лабутин" Если, например, у вас есть кластер, и нужно быть уверенным, что токен или куки выдан на одной машине будет распознан и правильно интерпретирован на другой машине, они должны шарить общий ключ, а если он прописан где-то в конфигах, то не очень понятно, как это делать.
4018.44 4021.52 "Игорь Лабутин" С новой системой в S/P/Nad Core эта проблема можно решить.
4021.52 4030.72 "Игорь Лабутин" По дефолту эти ключики живут 90 дней и абсолютно автоматически ратируются каждые 90 дней, вы про это даже не будете знать.
4030.72 4050.72 "Игорь Лабутин" Для использования оно полностью автоматически, если вы это делаете через S/P/Nad Core Identity, и если же вы хотите с этим поработать вручную, например, использовать это дело для того, чтобы что-нибудь зашифровать самим, то есть интерфейс, называется IData Protection Provider, у него есть метод Create Protector, который принимает ту самую строчку Purpose.
4050.72 4061.24 None Указав Purpose, вы получите instance объекта Protector, у которого есть два метода, Protect и Unprotect, которые, соответственно, принимают строчку и возвращают ту же строчку, зашифровывая и расшифровывая.
4061.24 4082.76 "Игорь Лабутин" Нужно особо отметить, что это не система, скажем так, шифрования, которую нужно использовать для хранения долговременных данных, это именно система шифрования, предназначенная для краткосрочного шифрования, чтобы что-нибудь послать, например, клиенту, клиент про это не смог ничего узнать и вам бы прислал обратно, то есть Content Cookies, шифровать, ну такие вот штуки.
4082.76 4096.00 "Игорь Лабутин" И нужно пытаться класть это в базу, потому что никто не гарантирует, что ключики будут живы, если вы потеряете такой ключик, потому что, например, автоматически ратируется, то вы не сможете уже ничего расшифровать.
4096.00 4109.84 "Игорь Лабутин" Для того, чтобы это конфигурить, есть две области, которые можно подменять, то есть вот этот вот IData Protection это, скажем так, точка входа, вы можете делать плагинчики
4109.84 4120.60 None в двух местах. Во-первых, можете настраивать, где же хранятся ключи, то есть по дефолту это папочка Local AppData, SPNet Data Protection Keys.
4120.60 4128.32 "Игорь Лабутин" И второе, что вы можете настраивать, нужно ли шифровать, скажем так, эти ключики, когда они хранятся на диске.
4128.32 4132.80 "Игорь Лабутин" Под Windows они шифруются, под Linux они, кстати, не шифруются.
4132.80 4155.88 "Игорь Лабутин" И вот то, что я говорил, почему вам, может быть, нужно это будет, тогда туда заходить и что-то делать, это как раз таки сценарий, когда вы работаете в кластере, то есть если у вас есть много машин, они все вместе как-то должны обслуживать единую сервис, и у вас может случиться так, что куки будет выдан одной машиной, а придет от клиента другая машина, в этом случае вам нужны общие ключи.
4155.88 4178.08 "Игорь Лабутин" В этом случае вы как раз таки подменяете persistence на какой-нибудь, ну, условно общий кэш, там храните их, ну пусть там не в Redis, но если вы в Azure, то есть специальный Azure Key Vault, либо ставите специальный Vault, соответственно, там, того же HashiCorp или еще что-нибудь, в общем, какое-нибудь секьюрное хранилище, куда SPNet Core будет ходить за ключиками.
4178.08 4187.64 "Игорь Лабутин" И, соответственно, все машинки, все инстансы вашего сервиса будут вставить в единый ключ, при этом все будет автоматически ротироваться, все как надо, вы даже про это можете не заморачиваться.
4187.64 4192.72 "Игорь Лабутин" Так что для большинства сценариев, наверное, про это нужно просто знать из любопытства.
4192.72 4199.28 "Игорь Лабутин" В малом числе сценариев может потребоваться что-то зажифровать при отправке клиенту в качестве информации и процессии.
4199.28 4201.28 "Игорь Лабутин" Можете использовать IData Protection Provider.
4201.28 4215.56 "Игорь Лабутин" И в еще более мелком количестве случаев, когда у вас в кластере нужно шарить такие вещи, вы можете переопределить то, где ключики хранятся, и сделать так, чтобы они хранились в каком-то общем месте для всех инстанций вашего сервиса.
4215.56 4217.08 "Игорь Лабутин" Вот такая вот картинка.
4217.08 4223.88 "Анатолий Кулаков" Прелестно, живешь, живешь и не знаешь, что по правде добрые люди о тебе там уже побеспокоились и за спиной делают тебе security.
4223.88 4225.12 "Анатолий Кулаков" Это всегда приятно.
4225.12 4227.60 "Анатолий Кулаков" Тем более, когда люди знающие.
4227.60 4228.60 "Анатолий Кулаков" Поехали дальше.
4228.60 4237.60 "Анатолий Кулаков" Итак, напомню, что у нас в последнем релизе дотнета зарелизилась такая прекрасная штука, как Source Generator.
4237.60 4241.68 "Анатолий Кулаков" И для Source Generator в основном зарелизилась именно сама платформа.
4241.68 4256.84 "Анатолий Кулаков" И вот уже полетели первые ласточки, то есть первые генераторы начали появляться на GitHub, которые такие эту платформу используют и которые позволяют нам насладиться новой функциональностью, которая доселе была неведома дотнет-разработчикам.
4256.84 4258.32 "Анатолий Кулаков" Давайте же посмотрим.
4258.32 4263.28 "Анатолий Кулаков" Я за это время накопил парочку Source Generator интересных и хотелось бы с вами поделиться.
4263.28 4274.44 "Анатолий Кулаков" Может быть кто-то из вас найдет для себя какой-то интересный инструмент, а может для кого-то это будет отличная база для того, чтобы посмотреть на Source Code и уже сделать непосредственный генератор под свой проект.
4274.44 4278.64 "Анатолий Кулаков" Начать хотелось бы с медиатор SecureOS генератора.
4278.64 4283.24 "Анатолий Кулаков" Для этого мне кратко нужно описать, что из себя представляет медиатор.
4283.24 4295.24 "Анатолий Кулаков" В тот момент медиатор - это специальный инструмент, разработанный Джимми Боггартом, который позволяет вам общаться вашему API-контроллеру с вашей бизнес-логикой и при этом не делать высокую связанность.
4295.24 4299.08 "Анатолий Кулаков" То есть как выглядит типичный проект с использованием медиатора и SecureOS?
4299.08 4308.16 "Анатолий Кулаков" У вас есть API-контроллер, который принимает некую команду или query на вход, передает ее медиатору, а у медиатора уже есть хендлеры, которые на него подписаны.
4308.16 4312.04 "Анатолий Кулаков" То есть которые подписаны на конкретную команду или конкретной query.
4312.04 4319.92 "Анатолий Кулаков" Эти хендлеры уже обрабатывают ваш запрос или вашу команду, исполняют непосредственную бизнес-логику и если нужно отдают ответ.
4319.92 4324.80 "Анатолий Кулаков" Вот такой незамысловатый pipeline вырисовывается при использовании этого фреймворка.
4324.80 4331.72 "Анатолий Кулаков" То есть у вас есть HTTP-команды, которые передаются медиатору и кусок бизнес-логики, который исполняется.
4331.72 4340.12 "Анатолий Кулаков" Если для вас это архитектура нова, то рекомендую посмотреть доклад Макса Ашинова, который называется "Быстрорастворимое проектирование".
4340.12 4350.68 "Анатолий Кулаков" Там он в течение часа очень подробно вам рассказывает о плюсах и минусах этого подхода, о том, как его использовать и о том, какие инструменты у нас сейчас есть на рынке для того, чтобы это сделать.
4350.68 4361.04 "Анатолий Кулаков" Смысл в том, что архитектура получается довольно-таки гибкая, довольно-таки децентрализованная и ее очень удобно использовать на различных проектах, как на больших, так и маленьких.
4361.04 4362.80 "Анатолий Кулаков" Где же здесь место генератору?
4362.80 4365.28 "Анатолий Кулаков" А генератор здесь нацелился на IP-контроллер.
4365.28 4379.12 "Анатолий Кулаков" Как только у вас вся логика, весь маппинг, все возможные бизнес-правила ушли из IP-контроллера, а я напоминаю, что IP-контроллер всего лишь навсего принимает входные HTTP-команды и передает их медиатору.
4379.12 4380.56 "Анатолий Кулаков" Это все, что он должен делать.
4380.56 4383.96 "Анатолий Кулаков" В этот момент ваши IP-контроллеры остаются безумно тупыми.
4383.96 4390.68 "Анатолий Кулаков" Единственное, что у них есть, это роутинг, название команды, тип команды и в принципе все.
4390.68 4395.00 "Анатолий Кулаков" Это все, что нужно для того, чтобы отдать медиатору правильную команду.
4395.00 4399.64 "Анатолий Кулаков" Поэтому писать такие контроллеры ручками довольно-таки уморительно.
4399.64 4406.04 "Анатолий Кулаков" Поэтому появился Source-генератор, который позволяет вам генерить вот такие контроллеры.
4406.04 4408.36 "Анатолий Кулаков" Он анализирует ваши команды.
4408.36 4413.56 "Анатолий Кулаков" Ваши команды можно проаннотировать, понимаются Data Annotation и XML-документация.
4413.56 4426.28 "Анатолий Кулаков" После того, как вы проаннотировали команду, этой информации достаточно для того, чтобы сгенерировать строго типизированный контроллер, который примет эту команду на вход из понятного роутинга и отдаст ее заинжекционному медиатору.
4426.28 4430.96 "Анатолий Кулаков" Зачем нужны Data Annotation и XML-документации?
4430.96 4445.60 "Анатолий Кулаков" Для того, чтобы все эти аннотации проверил ISP.NET Core и если вдруг модель невалидная, он сразу вернул пользователю сообщение с ошибкой понятное и даже в вашу бизнес-логику эти команды не прилетали.
4445.60 4448.88 "Анатолий Кулаков" А XML-документация используется с свэш-баклом.
4448.88 4465.28 "Анатолий Кулаков" Свэш-бакл - это специальный инструмент, который реализует OpenAPI или также известен как Swagger и позволяет вам с помощью XML-документации уже нарисовать к вашим контроллерам красивенький WebUI-интерфейс, с помощью которого вы можете потестировать ваши endpoints.
4465.28 4477.44 "Анатолий Кулаков" Вот такой интересный генератор позволит вам ускорить время разработки вашего приложения, если вдруг вы используете медиатор и API-контроллеры для поступающих команд и кверей.
4477.44 4481.76 "Анатолий Кулаков" Еще один интересный Source-генератор называется Disassembly.
4481.76 4489.60 "Анатолий Кулаков" Это специальный генератор, который делает строго типизированные данные и вытаскивает их из уровня Assembly.
4489.60 4499.88 "Анатолий Кулаков" Например, он вам может вытащить title, версию и все это сделает строго типизированно, без всяких рефлекшенов, вкомпилив всю эту информацию в процессе билда.
4499.88 4506.24 "Анатолий Кулаков" Из проекта он может вытаскивать такие вещи, как версия языка, namespace, используемый framework.
4506.24 4520.88 "Анатолий Кулаков" Это часто может быть нужно, например, если вы захотите залогировать какую-нибудь диагностическую информацию о вашем приложении, то есть какая версия была собрана, как называется текущая дл, какой framework она использует и все в прочем этом духе.
4520.88 4524.88 "Анатолий Кулаков" Обычно вам для этого нужно было свою сборку исследовать с помощью рефлекшена.
4524.88 4531.96 "Анатолий Кулаков" С помощью этого генератора вы можете сгенерировать строго типизированный классик, который позволяет к этой информации доступиться легко и непринужденно.
4531.96 4554.56 "Анатолий Кулаков" Также в рамках проекта AdS Assembly есть специальный генератор, который во время компиляции порождает ресурс strings, то есть те переводы, если вы используете несколько локалей, которые вы задаете в файле ресурсов, к ним теперь можно удобно доступаться с помощью строго типизированных классиковых свойств, что тоже очень удобно.
4554.56 4559.96 "Анатолий Кулаков" Следующий генератор сделал Сергей Тепляков, называется OnStruct Record Generator.
4559.96 4562.80 "Анатолий Кулаков" Это специальные утилиты для работы со структурами.
4562.80 4568.76 "Анатолий Кулаков" Например, многие из нас еще до выхода в рекордов мечтали, что рекорды будут основаны на структурах.
4568.76 4573.04 "Анатолий Кулаков" После релиза мы узнали, что они сейчас сделаны именно на классах.
4573.04 4580.08 "Анатолий Кулаков" Если же вам не терпится и вы хотите получить рекорды на структурах, то вот этот генератор соответственно вам может их сделать без проблем.
4580.08 4584.68 "Анатолий Кулаков" Еще одна интересная часть есть это переопределение метода ToString.
4584.68 4585.68 "Анатолий Кулаков" ToString генератор.
4585.68 4593.48 "Анатолий Кулаков" В отличие от обычного ToString, который генерируется, допустим, на рекордах, этот более функциональный.
4593.48 4603.80 "Анатолий Кулаков" Он умеет принтить коллекции, он умеет делать кучу настроек, задавать какие-то кастомные символы разделения строк и так далее.
4603.80 4611.44 "Анатолий Кулаков" В общем, если вы захотите себе красивый ToString и при этом не хотите тратить много сил, посмотрите на OnStruct Record Generator.
4611.44 4618.88 "Анатолий Кулаков" Дальше довольно-таки очевидным генераторам, которые были обязаны появиться, и вот среди них есть Mapping Generator.
4618.88 4621.12 "Анатолий Кулаков" Наверняка многие из вас слышали про Automapper.
4621.12 4630.08 "Анатолий Кулаков" Это специальный инструмент, который позволяет вам переложить данные из одного класса в другой класс, если эти классы довольно хорошо совпадают по свойствам.
4630.08 4635.48 "Анатолий Кулаков" Или вы написали специальные маппинги, которые рассказывают, каким образом эти свойства соотносятся друг с другом.
4635.48 4647.52 "Анатолий Кулаков" Например, если к вам пришла какая-то входящая DTOшка и вы хотите переложить ее в бизнес-объект, довольно муторно это делать ручками, особенно если такие DTOшки у вас сотни тысяч и их всех нужно поддерживать и помнить, где каждая куда перекладывается.
4647.52 4651.72 "Анатолий Кулаков" Для этого существуют автоматизированные средства, самым популярным из которых является Automapper.
4651.72 4657.40 "Анатолий Кулаков" Делает он все, естественно, с помощью Reflection, Expression Trees и прочих таких хаков.
4657.40 4671.36 "Анатолий Кулаков" Он намного быстрее работает, чем если бы вы сами Reflection перекладывали бы эти данные, но все же намного медленнее, чем автоматически изгенерированный код, который делает абсолютно то же самое.
4671.36 4689.32 "Анатолий Кулаков" В частности, Inline Mapper, который генерирует вам маппер наподобие Automapper, занимает 11 нс по сравнению с тем, что Automapper на тех же самых данных, на небольших классиках, занимает 132 нс.
4689.32 4691.64 "Анатолий Кулаков" То есть, это больше, чем на порядок.
4691.64 4698.16 "Анатолий Кулаков" Еще один из очевидных генераторов, которые обязаны были появиться, это Strong Inject.
4698.16 4708.36 "Анатолий Кулаков" Это dependency injector, который собирает ваши зависимости и внедряет ваши зависимости в ваши классики без Reflection.
4708.36 4725.40 "Анатолий Кулаков" То есть, он собирает все зависимости, строит карту внедрений на момент компиляции, что тоже вам позволяет довольно-таки сильно ускорить время старта приложения, особенно если приложение очень большое, и, конечно же, скорость создания и скорость уничтожения ваших компонентов.
4725.40 4730.40 "Анатолий Кулаков" Проект еще довольно-таки новый, но в принципе довольно многообещающий.
4730.40 4734.88 "Анатолий Кулаков" Еще один интересный генератор у меня тут завалялся, называется ROX.
4734.88 4735.88 "Анатолий Кулаков" Это генератор моков.
4735.88 4750.84 "Анатолий Кулаков" Если раньше вы могли создавать моки с помощью динамиков, Castle Proxy, с помощью специальных библиотек моков, то сейчас вы можете просто все эти моки сгенерировать в Compile Time и уже в рантайме ничем этим не беспокоиться.
4750.84 4756.88 "Анатолий Кулаков" Хочется также отметить официальный стандартный генератор, который сейчас разрабатывается для System Text JSON.
4756.88 4761.84 "Анатолий Кулаков" Мы уже говорили про него в прошлом выпуске, но здесь он вполне пришелся в тему.
4761.84 4775.36 "Анатолий Кулаков" То есть сам Microsoft использует генератор по очень даже хорошему назначению для того, чтобы ускорить вашу сериализацию, для того, чтобы не платить в рантайме накладными расходами на Reflection и на прочий обход дерева и на прочие глупости.
4775.36 4787.76 "Анатолий Кулаков" То есть это официальный, нацеленный на Performance, на оптимизацию сериализатор, который уже можно посмотреть, и может быть сделать свой сериализатор для вашего протокола или для ваших структур данных.
4787.76 4792.08 "Анатолий Кулаков" Вот такой наборчик интересных генераторов у меня сейчас скопился.
4792.08 4798.00 "Анатолий Кулаков" Будем следить за этой темой дальше, может быть что-то в будущем еще будет интересного, обязательно вам расскажем.
4798.00 4802.80 "Игорь Лабутин" Да, звучит все это прикольно и генераторы потихонечку начинают появляться.
4802.80 4807.24 "Игорь Лабутин" И один из примеров это тема, про которую сейчас хочу рассказать я.
4807.24 4808.24 "Игорь Лабутин" Это Painvoke.
4808.24 4822.08 "Игорь Лабутин" Когда нам нужно из дотнета позвать код на C++ или когда нам нужно позвать какую-то стандартную API-шку винды, например, которые почему-то не существуют аналогов дотнете, мы используем Painvoke.
4822.08 4837.84 "Игорь Лабутин" И существовали раньше сайты, поддерживаемые энтузиастами, где можно было найти нужную тебе сигнатуру для того, как написать правильно Painvoke, чтобы вызвать какой-нибудь там Create File или еще что-нибудь из нативного винапи.
4837.84 4846.52 "Игорь Лабутин" Проблема с ними в том, что они поддерживаются вручную, они не полны, они возможно поддерживают только самые популярные API, а какие-нибудь очень редкие не поддерживают
4846.52 4854.32 None и с этим надо что-то делать. Microsoft решила, что в принципе это не очень здорово и сделала несколько шагов в нужном направлении.
4854.32 4867.04 "Игорь Лабутин" Во-первых, они создали проект на GitHub, называется Win32Metadata и это по сути полное описание Windows API в формате WinMD.
4867.04 4880.72 "Игорь Лабутин" Это, я так понимаю, метадата формат для UVP приложений, очень похожий на формат сборок CLR, он e7e335 compliant, практически то же самое, что DLL-ки дотнета, там чуть-чуть
4880.72 4893.56 None по-другому метадата структурирована, но смысл в том, что по сути он описывает некоторый практически дотнет-комплайнт набор API, которые полностью соответствуют тому, что представляет виндамп.
4893.56 4896.16 "Игорь Лабутин" Все это запаковано в виде нукета и лежит на нукеторке.
4896.16 4902.68 "Игорь Лабутин" Но в таком виде он мало применим для дотнета и требовался следующий шаг и он тоже сделал.
4902.68 4914.60 "Игорь Лабутин" Шаг этот лежит тоже на GitHub в проекте cs_win32 и тоже запакуется в нукет microsoft.windows.cs_win32 и по сути является source-генератором.
4914.60 4917.84 "Игорь Лабутин" Как оно работает с точки зрения пользователя?
4917.84 4934.52 None Вы в вашем проекте референсите вот этот самый нукет, добавляете в файлик native-methods.txt и пишете в этом файлике те методы API-шек винды, которые вы хотите, чтобы появились у вас в виде дотнет-методов.
4934.52 4942.96 "Игорь Лабутин" И после чего в момент компиляции у вас срабатывает source-генератор и получается классик под названием painvog, это статический
4942.96 4946.68 None класс, где сгенерены только те методы, которые вы указали в native-methods.txt.
4946.68 4953.40 "Игорь Лабутин" То есть со всеми нужными enum, флагами, все что нужно, но все есть в нужных сборках.
4953.40 4958.76 "Игорь Лабутин" Соответственно в том месте, где нужно использовать, вы просто добавляете usr_microsoft.windows.sdk, это тот namespace, где лежит этот
4958.76 4966.00 None класс и можете использовать painvog. и дальше те методы, которые вы указали в native-methods.txt.
4966.00 4978.96 "Игорь Лабутин" Microsoft не собирается на этом останавливаться и помимо этого генератора, который генерирует C# кусочки, есть сейчас такой же генератор для RASTA и ведется работа для C++.
4978.96 4994.12 "Игорь Лабутин" На 2021 год планы сейчас на данный момент заявлены в том, что на Nuget.org должны появиться правильные пакеты с метаданными для всех возможных Windows SDK, которые поддержаны на данный момент.
4994.12 4998.80 "Игорь Лабутин" Сейчас, я так понимаю, берется только последний, но будут взяты все поддержанные.
4998.80 5002.64 "Игорь Лабутин" Есть эти генераторы для C#, PLUSLOW и RASTA.
5002.64 5006.12 "Игорь Лабутин" И для C# они планируют, что все это будет таргетиться
5006.12 5016.80 None на DotNet 5, то есть Nuget, который будет явиться, source-генератор, понятно, что он поскольку требует последнего C# 9, то все это будет таргетиться на DotNet 5.
5016.80 5023.28 "Игорь Лабутин" Особенно хочется заметить, что все это делается в сотрудничестве с товарищем, который, собственно, вот этот добровольный painvog сайт поддерживал многие годы.
5023.28 5032.80 "Игорь Лабутин" Он, так сказать, влился в эту команду, не знаешь, как индивидуальны контрибьюторы в составе Microsoft и вот вместе с ними билд всю эту машинерию, чтобы все это работало теперь автоматически.
5032.80 5044.24 "Игорь Лабутин" Так что тем, кому нужен painvog, смотрите на эту штуку пристально, кажется, что это самый легкий будет способ использовать painvog теперь в коде на C#, если вам нужно имя называть Windows API.
5044.24 5057.28 "Игорь Лабутин" Понятно, что если вы зовете вашу кастомную API, то, наверное, будет чуть сложнее, но, может быть, идеи, которые использованы в этом генераторе, позволят вам почерпнуть какие-то идеи, как, может быть, упростить вашу работу, если вы много работаете с C++ и с C#.
5057.28 5058.28 "Анатолий Кулаков" Прекрасно.
5058.28 5071.96 "Анатолий Кулаков" Всегда радуюсь вот этим историям, когда все-таки open-source активисты, они как бы вливаются в Microsoft и продолжают работать над своими любимыми проектами, ну так, как у нас было с Newtonsoft, так как у нас с вот этим painvogger случилось.
5071.96 5089.00 "Анатолий Кулаков" Попадаются, конечно, истории, когда open-source авторы жалуются на то, что их проекты были загублены Microsoft, украдены Microsoft и сделали нечестную конкуренцию со стороны Microsoft, но, как видим, не все, не все такие попадаются, все-таки те, с кем Microsoft может договориться.
5089.00 5095.72 "Игорь Лабутин" Да, ну, я думаю, что на этом стоит потихонечку сворачиваться, мы, как обычно, говорим довольно долго.
5095.72 5098.88 "Игорь Лабутин" Давайте вспомним, что мы сегодня прошли и обсудили.
5098.88 5112.20 "Игорь Лабутин" Начали мы, как обычно, с тулинга и поговорили, что у нас вышла новая версия Visual Studio 2019, версия 16.9 Preview 3, с некоторыми небольшими изменениями, основное, видимо, звуки в конце юнит-тестов.
5112.20 5113.36 "Игорь Лабутин" Наташа, мы все сломали.
5113.36 5122.24 "Игорь Лабутин" JetBrains не отстает и выпустил roadmap про ReSharper, Ryder, а также EAP-версии, и Avalonia зарелизилась.
5122.24 5135.28 "Игорь Лабутин" Дальше, касательно технических статей, мы посмотрели на то, как правильно выбирать Service Lifetime в dependency injection фреймворке от Microsoft, но по большому счету все те же принципы применимы к любому dependency injection фреймворку.
5135.28 5142.32 "Игорь Лабутин" Посмотрели на механизмы, как собирается наш .NET, то, что мы в итоге качаем с сайта Microsoft.
5142.32 5148.00 "Игорь Лабутин" Очень советую почитать, если вам интересна тема сборки, посмотреть внимательные скрипты, там прям много чего интересного.
5148.00 5161.00 "Игорь Лабутин" Пообсудили состояние дела в VBSymbl, вспомнили немножко историю, как это все начиналось и во что превратилось сейчас, какие есть библиотеки, как это все поддержано, кем поддержано и как предположительно будет развиваться.
5161.00 5169.64 "Игорь Лабутин" Посмотрели, что такое Data Protection System в S/P/Nad Core, возможно, кто-то не знал, что оно существует и зачем оно вообще используется и может быть полезно вам с точки зрения кастомного кода.
5169.64 5181.36 "Игорь Лабутин" И посмотрели на то, какие начали появляться Source генераторы и, в частности, глянули, как теперь можно попроще работать с framework на C# в случае, когда вы обращаетесь к Windows API.
5181.36 5183.20 "Игорь Лабутин" На этом на сегодня все.
5183.20 5185.72 "Анатолий Кулаков" Да, мы действительно так хорошо прошлись.
5185.72 5187.68 "Анатолий Кулаков" Давай закругляться.
5187.68 5197.68 "Анатолий Кулаков" Друзья, я напоминаю, что мы очень ждем вашей поддержки, поэтому расшарьте нас между своими друзьями, лайкайте, репостайте и обязательно слушайте нас в будущем.
5197.68 5205.00 "Анатолий Кулаков" Чем больше у нас будет слушателей, тем интереснее будет наша армия и тем больше у нас будет, наверное, интересных новостей для них выходить.
5205.00 5214.84 "Анатолий Кулаков" Поэтому помогите нам распространяться, а если вы хотите помочь нам материально, то заходите на наши сервисы на Boosty и Patreon и присоединяйтесь к нашему приватному чатику.
5214.84 5216.16 "Игорь Лабутин" Да, а на этом все.
5216.16 5217.76 "Игорь Лабутин" С вами был Игорь Лобутин.
5217.76 5218.76 "Анатолий Кулаков" И Анатолий Кулаков.
5218.76 5219.76 "Анатолий Кулаков" Всем пока.
5219.76 5220.26 "Анатолий Кулаков" Пока.
5220.26 5221.26 None Пока.
5221.26 5222.26 None Пока.
5222.26 5228.38 None [музыка]
