0.00 9.30 "Анатолий Кулаков" Всем привет, дорогие друзья, в эфире Radio.net, выпуск номер 39.
9.30 11.94 "Анатолий Кулаков" И с вами сегодня будут Анатолий Кулаков.
11.94 12.94 "Анатолий Кулаков" И Игорь Лабутин.
12.94 13.94 "Анатолий Кулаков" Привет.
13.94 16.90 "Анатолий Кулаков" Большое спасибо всем, кто помогает нам на Patreon и Boosty.
16.90 20.86 "Анатолий Кулаков" Если вы все еще не знаете, о ком мы говорим и о чем мы говорим, обязательно заходите.
20.86 26.42 "Анатолий Кулаков" У нас там есть еще интересные прешоу, интересное обсуждение и много другого всего интересного.
26.42 29.78 "Анатолий Кулаков" И отдельное спасибо Александру, Сергею и Владиславу.
29.78 32.66 "Анатолий Кулаков" Большое спасибо, друзья, что поддерживаете нас.
32.66 34.54 "Анатолий Кулаков" Ну что ж, приступим непосредственно к темам.
34.54 36.10 "Анатолий Кулаков" Что у нас сегодня интересного?
36.10 53.30 "Игорь Лабутин" У нас не так много новенького с точки зрения релиз-кандидатов или каких-то новинок, поэтому мы немножко вернемся назад, можно сказать, и посмотрим на часть .06, которую мы на самом деле несколько последних выпусков не то чтобы забывали, но про них ничего не выходило.
53.30 54.30 "Игорь Лабутин" Про эту часть.
54.30 56.22 "Игорь Лабутин" А это Entity Framework Core.
56.22 75.58 "Игорь Лабутин" То есть мы много раз говорили, что вышел релиз-кандидат такой, вышел релиз-кандидат секо, для дотнета, для сп-нета, но про Entity Framework была полная тишина, потому что, как я понимаю, практически все там было готово, они дофикшивали последние баги или какие-то мелкие улучшения доделывали, и поэтому, собственно, никаких особых новостей в релиз-кандидатах это и не было.
75.58 85.50 "Игорь Лабутин" Тем не менее, хотелось бы напомнить, какую огромную работу проделала команда Entity Framework за прошедший год и пробежаться быстренько по всем изменениям, которые там произошли.
85.50 104.22 "Игорь Лабутин" Понятно, что мы не сможем обозреть абсолютно все, там довольно много изменений, но какие-то основные вещи я постараюсь напомнить, и если вам будет интересно, читайте большую статью What's New, там все подробно со ссылками на GitHub, где можно все точно узнать, как, что сделано и в каком виде.
104.22 114.98 "Игорь Лабутин" И начнем сначала, это SQL Server Temporal Tables, это такие специальные таблички в SQL Server, которые автоматически умеют хранить все данные, которые когда-либо в этой таблице сохранялись.
114.98 127.58 "Игорь Лабутин" То есть, если вы делаете апдейт записи, то старая запись переносится в специальную параллельную табличку с историей, а то, что вы обновили, оно появляется на новом месте, как и должно быть в обычной таблице SQL Server.
127.58 144.14 "Игорь Лабутин" И вот эта вот параллельная табличка истории, она позволяет в себя посмотреть, можно из нее, допустим, восстановить какое-то значение, если вы его случайно удалили или обновили, плюс в этой табличке запоминаются интервалы, когда то или иное значение было в основной таблице живо.
144.14 148.18 "Игорь Лабутин" И эта штука теперь поддержана в Entity Framework Cora.
148.18 153.58 "Игорь Лабутин" Вы можете создавать такие таблички с использованием миграции, там есть соответствующий Fluent API для этого.
153.58 172.22 "Игорь Лабутин" Можно трансформировать существующую табличку в такую штуку, можно писать кверки для того, чтобы получать исторические данные, и Entity Framework будет знать, когда нужно идти в историческую табличку, когда в основную, и более того, можно восстановить запись за конкретный момент времени.
172.22 178.66 "Игорь Лабутин" Для того, чтобы все это работало, в Fluent API для Entity Framework добавили новые методы.
178.66 183.14 "Игорь Лабутин" Это всякие штуки, начинающиеся со слова temporal.
183.14 194.02 "Игорь Лабутин" То есть можно сказать temporal all, например, db.context, ваша коллекция, .temporalall, и она вам вернет вообще все данные, которые когда-либо были в этой таблице, с интервалами.
194.02 199.22 "Игорь Лабутин" У каждой Entity будет еще две пропертии, где будет написано, с какого по какой она была валидна.
199.22 210.54 "Игорь Лабутин" И есть разные вариации, типа temporal from, temporal after, и можно заресторить какую-то запись, сказав temporal as of, и дальше передать туда конкретный timestamp.
210.54 213.22 "Игорь Лабутин" И таким образом оно все сохранится.
213.22 221.10 "Игорь Лабутин" Потом сказать save context, и оно сохранит в основную табличку нужную запись из нужного элемента времени, из прошлого.
221.10 226.90 "Игорь Лабутин" Прикольная фича, мы такое все сделаем руками на самом деле, но только без нативной поддержки Entity Framework.
226.90 230.58 "Игорь Лабутин" Вторая большая фича, которую они очень сильно пиарили, это migration bundles.
230.58 240.74 "Игорь Лабутин" То есть вы знаете, что вы можете создать миграции, вы можете сказать .NET EF migrations app или еще что-нибудь в таком духе, чтобы применить миграции.
240.74 258.54 "Игорь Лабутин" Но это не очень удобно, и теперь есть возможность, если вам нужен standalone штука, например, вы хотите обновлять вашу базу данных независимо от вашего приложения, допустим, предварительно накатить все миграции, то вы теперь можете накидать миграции, как раньше .NET EF EDD, а потом сказать .NET EF migration bundle.
258.54 266.38 "Игорь Лабутин" И вы получите в результате файлик по дефолту, называется EF bundle.exe, запустив который ваша база данных собственно обновится.
266.38 271.74 "Игорь Лабутин" Там есть некоторое количество опций, которые позволяют вам кастомизировать, что получится, какой дебагинтекст использовать и так далее.
271.74 278.26 "Игорь Лабутин" Но в целом там все довольно просто, добавляете миграции и говорите команду .BUNDLE, получите .EXE.
278.26 282.42 "Игорь Лабутин" Третья большая фича, это pre-convention model configuration.
282.42 301.46 "Игорь Лабутин" То есть раньше, если у вас был какой-то, например, тип данных, который вы хотели как-то очень, ну, назовем это, обособленно обрабатывать, то есть, например, если вы хотели какую-то особую обработку для дейттаймов, мы, например, такое делали, чтобы им всем проставлять дейттайм, кайнт, UTC всегда, потому что мы знаем, что в нашей базе лежат только UTC данные.
301.46 307.06 "Игорь Лабутин" А по дефолту проставлялся дейттайм, как он там, unspecified, по-моему называется.
307.06 310.26 "Анатолий Кулаков" Ну или local, наверное, если вы локальных генерили.
310.26 318.90 "Игорь Лабутин" Нет, там вот именно есть три варианта, там есть UTC, есть local, а есть типа вот, то ли unknown, то ли unspecified, я не помню как называется.
318.90 319.90 "Игорь Лабутин" Unspecified.
319.90 325.18 "Игорь Лабутин" Да, ну вот, короче, по дефолту нам вот эта штука, по-моему, entity framework генерил, какой-то из стареньких, 3x, по-моему.
325.18 328.42 "Игорь Лабутин" Вот, нам это было неудобно, нам нужно было, чтобы там стояло явно UTC.
328.42 337.50 "Игорь Лабутин" Вот, мы, соответственно, это нужно было писать во всех определениях модельки, нужно было писать, что вот тут, пожалуйста, pre-convert, использую, вот такое, вот тут, вот так, вот так вот.
337.50 354.54 "Игорь Лабутин" Теперь это можно навесить, не навесить атрибутиком, это можно задать прямо при конфигурации модели целиком, сказать, что для всех там date/time используй вот такой конвертер, или там вот такую вот конфигурацию mapping на самом деле, и он тогда будет использовать ее для всех пропертий такого типа.
354.54 358.74 "Игорь Лабутин" В моделях это не единственное улучшение, появились так называемые compiled models.
358.74 373.10 "Игорь Лабутин" Это штука, которая позволяет ускорить старт приложения для больших моделей, когда Entity Framework команда говорит больших, они имеют в виду где-то от 100 до 1000, от сотен до тысяч, точнее типов Entity.
373.10 385.78 "Игорь Лабутин" То есть если у вас очень много типов Entity и отношений, то тогда разбор вот такой модели, построение in-memory какой-то модели по ним, по которым потом Entity Framework быстро работает, занимает определенное время на старте.
385.78 412.78 "Игорь Лабутин" Можно сейчас теперь сказать в Entity Framework 6 командочку .NET EFDB Context Optimize, и в результате создастся некоторый файлик бинарный, который вы должны будете подключить к вашему коде, там специально, эта же командочка выдаст вам кусочек C#, который нужно вставить в ваш код, и после этого при старте это бинарное представление будет загружено в память и будет использовано для работы с вашей моделью, что как бы не тратит время на построение ее еще раз.
412.78 415.26 "Игорь Лабутин" Естественно, если вы поменяли модель, нужно перегенерить.
415.26 424.02 "Игорь Лабутин" Кроме того, есть некоторый ряд ограничений, не все фичи, которые вы можете определить в модели, там поддержаны, внимательно посмотрите список исключений.
424.02 492.14 "Игорь Лабутин" Вообще в целом работа над Entity Framework Core 6 была с одной стороны над тем, чтобы фиксим баги, а с другой стороны и про performance, то есть есть такой известный тест на performance как тех Empower Fortunes, и там была такая штука, что в общем-то в .NET есть несколько мапперов из популярных это Entity Framework и Dapper, и Entity Framework как-то довольно сильно отставал, даже и 5.0, и до этого было еще хуже, и в результате сейчас после всех улучшений, которые сделали в EF Core 6 получилось, что по сравнению с EF Core 5 производительность увеличилась на 70%, причем это не только за счет изменений в самом EF Core, это за счет изменений в рантайме, и в бичмарке, и вообще везде-везде-везде, в базовой библиотеке классов, сам по себе EF Core в этих 70% влияет на 31%, то есть вот непосредственно исполнение запросов примерно на 31% быстрее.
492.14 502.54 "Игорь Лабутин" При этом они еще улучшили работу с памятью, потому что хипа теперь требуется на 43% меньше для исполнения запросов, там они довольно агрессивно все кэшируют и стараются, и это помогает.
502.54 507.86 "Анатолий Кулаков" Ну то есть в принципе даппер на новом фрейворке тоже стал работать намного быстрее, а как у них сравнение с
507.86 519.54 "Игорь Лабутин" даппером? Да, даппер тоже стал быстрее, если я правильно помню, там отставание было типа 55%, то есть EF Core был, ну условно, минимум в 2 раза медленнее, а то и больше, сейчас у них разница между ними в 5%.
519.54 522.86 "Анатолий Кулаков" Ну это естественно без трекинга и всего вот этого, что у даппера нет.
522.86 527.02 "Игорь Лабутин" Да, конечно, то есть это чисто исполнение untracked queries типа селектов.
527.02 530.78 "Анатолий Кулаков" Ну отлично, мне в принципе кажется, что довольно неплохо.
530.78 542.42 "Игорь Лабутин" Да, то есть даппер, насколько я помню, создавался как простой незатейливый фреймворк, чисто как для маппинга результатов запросов, в принципе EF Core практически для этого уже тоже нормально подходит с точки зрения перформанса.
542.42 549.14 "Анатолий Кулаков" Ну и прежде всего быстрый фреймворк, да, когда мы говорим, что EF там отстает на 5%, уже не кажется, что даппер быстрый.
549.14 557.82 "Игорь Лабутин" Ну опять, это синтетический все-таки бенчмарк, надо смотреть на реальных сценариях, возможно есть сценарий, где EF Core все еще будет тормозить, возможно есть сценарий, где даппер будет тормозить.
557.82 569.30 "Игорь Лабутин" Я немного пользовался даппером, только в каких-то таких, скажем так, в проектах типа песочницы попробовать что-нибудь, поэтому в продакшене его ни разу не использовал, не могу ничего сказать.
569.30 581.02 "Анатолий Кулаков" Ну а я хотел бы добавить, что в принципе даппер был интересным прецедентом, потому что он задал саму идею вот этих мини-фреймворков, мини-орм-ок, и сейчас есть уже орм-ки, которые намного быстрее даппера.
581.02 587.66 "Анатолий Кулаков" И даппер, несмотря на всю его сейчас тормознутость, является просто самым популярным, поэтому на него все равняются.
587.66 600.38 "Анатолий Кулаков" Но если вы хотите действительно очень быстрого и очень микро-фреймворка со всеми теми же преимуществами, но еще более быстрого, еще более удобного, то посмотрите вокруг, там есть отличные кандидаты.
600.38 611.98 "Игорь Лабутин" Да, дальше пошли уже улучшения такие, не такие глобальные, но тем не менее по областям тоже довольно интересные, могут быть полезные, если вы это используете.
611.98 622.18 "Игорь Лабутин" Если вы используете Cosmos DB, то там прям какое-то огромное количество улучшений, там завели поддержку собственно стейтмента FromSQL, раньше нельзя было использовать.
622.18 629.86 "Игорь Лабутин" Гораздо больше функций, которые вы пишете в LinkU, мапятся теперь нормально на встроенные функции Cosmos DB, это прям хорошо.
629.86 640.62 "Игорь Лабутин" Улучшили гораздо больше драйвер и логирование, в том смысле, что там теперь гораздо более правильные логи пишутся в большом количестве, можно понять вообще, что работает не так, если что.
640.62 650.98 "Игорь Лабутин" И Cosmos DB специфичная фича, можно теперь конфигурировать throughput и time to live для записей прямо через Fluent API, это прямо полезно.
650.98 686.46 "Игорь Лабутин" Из дженериковых улучшений завезли более, ну легкое что ли, scaffolding из существующей базы данных, то есть она теперь использует нормально полноценный nullable reference type, и если у вас, например, non-nullable колонка, то она будет генерировать соответственно non-nullable property, иначе nullable property, и гораздо более легкое many-to-many, соответственно на описании relations будет, не нужно там сильно заморачиваться, EF course довольно много всего будет, но умеет теперь понимать.
686.46 761.34 "Игорь Лабутин" В LinkU стало гораздо лучше, тут довольно много таких мелких улучшений, заимпровили поддержку groupby, string concat с несколькими аргументами теперь тоже поддержан нормально и будет транслирован нормально SQL, если вы пользуетесь на SQL-сервере поиском по тексту, то там есть теперь тоже улучшения в этом месте, транслируется некоторое количество функций из LinkU чуть лучше в SQL, как например EF functions random, или isNuller whitespace для стринга теперь нормально все это транслируется, и такая интересная фича, которую я как любитель всячески правильного логирования и максимального прозрачного понимания, где что исполняется, мне бы она понравилась, пока не пробовал, это фича, которая позволяет вам теперь тегать кверки с использованием имени файла и номера строчки, то есть при генерации SQL в этот SQL вставляется SQL-ный комментарий, где написано из какого C# файла этот кусочек конкретно сгенерирован, и если у вас видимо какой-то большой набор iQuery был в который раскидан по всему коду, то результирующий SQL будет пестреть комментариями, этот кусочек мы взяли из этого C#, из этого C#, ну и так далее.
761.34 767.58 "Анатолий Кулаков" Мне кажется, очень удобная штука для отладки, но в общем странно, почему раньше этого не сделали, кажется, что все для этого было.
767.58 772.62 "Анатолий Кулаков" Комментарии в сиквеле были, и номер строчки текущий тоже у них давно был.
772.62 774.10 "Игорь Лабутин" Ну, в общем, да, сделали.
774.10 802.90 "Игорь Лабутин" На самом деле, если посмотреть на вот эту статью, кажется, что где-то, ну я не знаю, четверть минимума этих улучшений, если не больше их часть, добавлена с помощью ресурсов комьюнити, то есть довольно много разделов этой статьи заканчиваются тем, что благодарностями тому или иному контрибьютеру на GitHub, а не силами команды, поэтому, ну вот, у команды руки не добирались, если там неоптимально исполняются квери, знаешь, лагировать имя файла, ну, может, не самое важное.
802.90 817.34 "Анатолий Кулаков" Ну, да, это очень похоже на вот те фишечки, которые я обычно добавляю во время генерации, в общем, которые просто сделают жизнь удобнее и отладку быстрее, может, действительно, Microsoft это не нужно было, а кто-то пришел уже с больной практикой и добавил.
817.34 841.38 "Игорь Лабутин" Да, добавили некоторое количество атрибутов для маппинга, то есть теперь можно указывать, хотите ли вы n-varchar колонку или, может быть, varchar, если вам принципиально не хочется Unicode хранить в базе данных, есть теперь специальный атрибутик Unicode для типов decimal, например, в SQL Server вы можете указывать precision с помощью атрибутов, ну и еще некоторое количество атрибутов завезли, посмотрите, попроще немножко размечать поля стали.
841.38 887.06 "Игорь Лабутин" С model binding, model building, простите, с построением модели стало тоже чуть лучше, поддержаны SQL Server sparse columns, так называемые, нужно меньше, я уже упоминал, это для scaffolding, но здесь это тоже, когда вы определяете модель entity framework, сам поймет, где нужно вставить many-to-many relation, основываясь на именах, если вы правильно будете называть ваши коллекции, то он сам сообразит, что там many-to-many relation, и некоторым конверторам теперь дозволено конвертировать null значения из базы, там довольно большой раздел этому посвящен, почитайте в статье, я не буду сильно углубляться в совсем уж детали того, где и как конвертятся базоданческие нулы и во что они превращаются, и почему они раньше были запрещены, а теперь разрешены, в смысле конвертации.
887.06 935.94 "Игорь Лабутин" В db.context.factory завезли такие несколько, ну, скажем так, полезных, с моей точки зрения, улучшений, то есть, во-первых, когда вы добавляете, используете extension метод add db.context.factory, то для регистрации вашей factory автоматически добавляется регистрация scoped db.context, таким образом вы можете либо получить factory и создавать свои db.context, либо просто, как обычно, заинжексить db.context, он вам создастся в scoped варианте, то есть это вот автоматически вам сделали, чтобы можно было использовать и так и этак, кроме того, сделали public класс под названием pooled db.context.factory, соответственно, позволяет использовать pooling db.context даже если вы не используете dependency injection, а самим заинстанцировать, например, pooled db.context.factory и оттуда забирать db.context, которые poolятся внутри.
935.94 965.26 "Игорь Лабутин" Ну и последнее, это довольно большое количество мелких улучшений, это поддержка всяких порядка колонок с помощью атрибутика column attribute.order, поддержка minimal API, то есть вот эти методы расширения, которые добавляли entity, которые нужно было вызывать в configure services, чтобы добавить entity framework, теперь позволяют практически добавить entity framework, единственные строчки сразу указать и connection string и все просто аргументом, не надо через options лямбдочку это делать.
965.26 979.46 "Игорь Лабутин" Breaking в каком-то смысле изменения в save changes async, эта штука, они внутри реализации save changes async убрали configure wait false, то есть save changes async будет сохранять вам синхронизационный контекст.
979.46 986.18 "Игорь Лабутин" Они решили, что это довольно важно, потому что этот метод часто вызывается из UI, и поэтому надо, чтобы он сохранял.
986.18 1009.82 "Игорь Лабутин" Потом, так-так-так, добавили, точнее улучшили немножко поддержку так называемых temporary values, то есть когда вы добавляете какой-то элемент в коллекцию для будущего сохранения, entity framework на самом деле назначает ему некоторый временный idшник, обычно какой-нибудь не очень валидный, сильно отрицательный, но просто чтобы ему трекать внутри себя, кто там с кем связан, кто кому ребенок и так далее.
1009.82 1015.46 "Игорь Лабутин" При реальном сохранении эти idшники будут действительно выкинуты и заменены на нормальные из базы.
1015.46 1022.02 "Игорь Лабутин" Вот теперь есть некоторая чуть более хорошая API для того, чтобы с ними работать, если вам это зачем-то надо.
1022.02 1028.66 "Игорь Лабутин" Вообще с ними обычно работать не надо, но иногда есть кейсы, когда с ними приходится поработать, теперь с ними чуть более удобно.
1028.66 1043.06 "Игорь Лабутин" Ну и весь entity framework напоследок был полностью проанонсирован nullable reference type, так что теперь, когда вы используете fcore 6, смело включайте nullable reference type в своем коде, и вам entity framework будет аккуратно подсказывать везде, что null не null.
1043.06 1050.94 "Анатолий Кулаков" Хотелось бы надеяться, что все остальные проекты у всех наших слушателей тоже уже давно проанатычны и ждут только выхода entity framework нового.
1050.94 1052.66 "Игорь Лабутин" Я могу сказать за себя, у меня нет.
1052.66 1053.66 "Игорь Лабутин" К сожалению.
1053.66 1061.66 "Анатолий Кулаков" Ну что ж, давай посмотрим вокруг и посмотрим, что у нас такого горяченького происходит в ход релоудю.
1061.66 1075.66 "Анатолий Кулаков" Интересная тема, что когда в дотнете, о дотнете начинают говорить другие подкасты, никак не связанные с нашей платформой, это обязательно какая-нибудь непонятная фигня, которая творится внутри фаундейшн и внутри гитхаба.
1075.66 1080.98 "Анатолий Кулаков" И в частности, одной из такой непонятной фигни был в этом сезоне ход релоуд.
1080.98 1090.86 "Анатолий Кулаков" О нем говорили абсолютно все и в радиоте эта тема прозвучала, и в твиттере бурлила, и на хабре печатали, и где только про него не рассуждали.
1090.86 1100.54 "Анатолий Кулаков" Но, наверное, это одна из тех как раз-таки ситуаций, когда, если долго сидеть на берегу реки, то рано или поздно труп врага проплывет мимо.
1100.54 1112.02 "Анатолий Кулаков" Поэтому мы немножко подождали, и подождали окончание этой истории, и теперь можем вам все-таки рассказать в пяти строчках буквально, что уж такого страшного, бурлящего и ужасного произошло.
1112.02 1125.06 "Анатолий Кулаков" Ну, если начинать сначала, то все началось с того, что Microsoft удалила открытый исходный код функции ход релоуд, который был в дотнете 6 RC1, удалила из утилиты .NET Watch.
1125.06 1134.82 "Анатолий Кулаков" Вот, этот код подписался в принципе в открытую на гитхабе, исходники все были, комьюнити активно участвовало, все как полагается, но Microsoft взял его и одним коммитом удалил.
1134.82 1161.50 "Игорь Лабутин" Надо сказать, что важный тут момент в том, что, во-первых, код выглядел уже практически прям готовым-готовым, и им все активно пользовались, его довольно активно пиарили, и второй момент, что он действительно был удален из RC1, удален без каких-либо комментариев, то есть просто пул реквест, запругленный с заблоченными комментариями, и не то что это утилита .NET Watch, это полное удаление из всего SDK.
1161.50 1162.50 "Игорь Лабутин" Да, именно так.
1162.50 1171.50 "Анатолий Кулаков" Если кто-то не помнит, что как раз .NET Watch и делает возможность ход релоуда, то есть обновлять ваше приложение без его перезапуска.
1171.50 1182.82 "Анатолий Кулаков" Это немножко похоже на функцию Edit and Continue, которая давно уже есть в Visual Studio, но только намного более гибкую и более рабочую.
1182.82 1194.70 "Анатолий Кулаков" То есть вы можете писать код непосредственно в вашем редакторе, и в этот момент ваш проект автоматически обновляется и подхватывает все те изменения, которые вы только что в редакторе наколбасили.
1194.70 1201.14 "Анатолий Кулаков" Естественно, есть там какие-то ограничения, не все он может подхватить, не всегда, но в принципе в большинстве случаев это работает.
1201.14 1223.28 "Анатолий Кулаков" И я сам в принципе на этом немного работал, но в принципе люди, которые пишут на других языках, в которых эта функция есть, например, на JavaScript, Flutter, еще где-то, они утверждают, что это просто жизненно необходимая штука и вот без нее они никак жить не могут и пользуются каждый день и это делает шикарные бенефиты в их повседневной работе.
1223.28 1229.86 "Анатолий Кулаков" Ну нет, никаких оснований мне верить, наверное, действительно для тех, кому это нужна вещь.
1229.86 1241.66 "Анатолий Кулаков" И по этому поводу очень большой орех поднялся и начали писать, как я уже упоминал, статьи, все петиции, кричать, стучать, что Microsoft опять стал злым и все такое.
1241.66 1247.10 "Анатолий Кулаков" А злость Microsoft заключается в том, что эта фича все-таки осталась в Visual Studio 2022.
1247.10 1263.14 "Анатолий Кулаков" И обоснованный вывод журналисты сделали, что Microsoft как раз таки удалил из общего SDK для того, чтобы пропихнуть Visual Studio 2022, чтобы ее лучше покупали, чтобы там такая клевая крутая фича была только там и никому больше не досталось.
1263.14 1273.22 "Анатолий Кулаков" К сожалению, Visual Studio 2022 может быть и была бы хорошим коммерческим решением этой проблемы, но к сожалению ее нет под Mac OS и Linux.
1273.22 1278.74 "Анатолий Кулаков" И там люди остаются вообще без hot reload, а раньше они им пользовались.
1278.74 1282.42 "Анатолий Кулаков" То есть в DotNet Watch это работало кросс-платформенно и между всеми редакторами.
1282.42 1283.66 "Анатолий Кулаков" А здесь получается, что нет.
1283.66 1287.10 "Анатолий Кулаков" И даже свой собственный Visual Studio код Microsoft этого не обещал завести.
1287.10 1297.46 "Игорь Лабутин" Ну и да, надо понимать, что RC1 это, если вы помните наш прошлый выпуск или позапрошлый, мы говорили, что это уже production quality, то есть Microsoft его официально поддерживает в продакшене.
1297.46 1302.34 "Игорь Лабутин" И как бы удаление кода из прямо production на production это как-то совсем уже не очень.
1302.34 1307.74 "Игорь Лабутин" И это было бы нормально воспринято, но это все-таки релиз-кандидат, если бы там, например, было бы огромное количество багов.
1307.74 1310.70 "Игорь Лабутин" Но их там особо не было, все прекрасно работало.
1310.70 1321.02 "Анатолий Кулаков" Ну и плюс этот SDK будет релизиться вместе со студией, практически там 2022 и спихивать все на огромное количество недоделок, наверное, уже было бы не очень красиво.
1321.02 1331.90 "Анатолий Кулаков" Соответственно, очень быстро появился на GitHub pull request, который откатывает, ревертит это изменение, который возвращает ее обратно, Microsoft, естественно, не спешил этот pull request применять.
1331.90 1346.98 "Анатолий Кулаков" Под этим pull request развернулась большая дискуссия, очень много людей туда пришли, поставили approve в ревьюверы, поставили тысячи людей, поставили какие-то эмоции, эмоджи, все как-то отреагировали.
1346.98 1364.34 "Анатолий Кулаков" В общем, постепенно толпа вот этого всего недовольства дошла и до Microsoft, там люди внутри что-то пообсуждали, что-то поделали и в конце концов решили все-таки вернуть эту фичу обратно, в .NET watch будет в новом SDK, будет кроссплатформенный, будет как обычно.
1364.34 1373.94 "Анатолий Кулаков" И в принципе Microsoft опять же сказал, что извините, все было не так, мы немножко поспешили, немножко не так друг друга все поняли.
1373.94 1378.26 "Анатолий Кулаков" В общем, мы все возвращаем обратно и давайте жить дальше дружно и счастливо.
1378.26 1385.34 "Игорь Лабутин" Ну, посмотрим, это не первый, не последний наверняка такой момент вокруг Microsoft, будем следить.
1385.34 1398.82 "Игорь Лабутин" Причем сложилось впечатление, что при этом сама команда .NET разработки, в смысле те ребята, которые непосредственно девелопят .NET и в том числе эту фичу, они как-то были не сильно за то, чтобы это все выпиливать.
1398.82 1406.66 "Игорь Лабутин" То есть опять же журналисты делают вывод, что это скорее всего какие-то более высокопоставленные ребята из Microsoft приняли такое решение.
1406.66 1411.98 "Игорь Лабутин" И дальше посмотрим, куда это все будет двигаться с точки зрения open-source.
1411.98 1414.50 "Игорь Лабутин" Тяжелая open-source разработка, все сразу видно.
1414.50 1417.98 "Анатолий Кулаков" Да, действительно, был бы Microsoft закрытый и об этом скорее всего даже бы никто и не узнал.
1417.98 1420.30 "Анатолий Кулаков" Ну, мало ли, что там в релиз комедий дать выпилили.
1420.30 1429.42 "Анатолий Кулаков" А здесь и разработчики начали что-то твитить, и даже менеджеры, там тоже самый Скотт Хансельман активно более или менее, насколько он мог, возмущался таким поведением.
1429.42 1435.78 "Анатолий Кулаков" Ну, и кажется, что они не последнюю роль во всем этом сыграли, то есть не только внешняя волна, но еще какие-то внутренние настроения тоже.
1435.78 1436.78 "Игорь Лабутин" Ну, вот да.
1436.78 1441.02 "Игорь Лабутин" Ладно, пойдем к следующей теме.
1441.02 1447.46 "Игорь Лабутин" Ну, вот штука интересная, но тем не менее, давай мы все-таки про более техническую часть тоже поговорим.
1447.46 1451.78 "Игорь Лабутин" Вернемся теперь к ISP.net Core.
1451.78 1456.50 "Игорь Лабутин" Там конечно же главная новость, это minimal APIs, которые много где кто обсуждают.
1456.50 1461.54 "Игорь Лабутин" Дэвид Фаулер ее прям очень сильно пиарит, говорит, что это наше будущее и по-другому жить нельзя.
1461.54 1465.34 "Игорь Лабутин" И может быть он действительно прав, может быть все попривыкнуты, так и будут пользоваться со временем.
1465.34 1468.50 "Игорь Лабутин" Но тем не менее, сейчас мы находимся в довольно интересном месте.
1468.50 1479.02 "Игорь Лабутин" Если вы создаете новый проект на темплейте .NET 5, то вы получите старый добрый программ CS, стартап CS, в нем две функции Configure Services и Configure.
1479.02 1484.46 "Игорь Лабутин" Ну и весь тот темплейт, который вы очень хорошо знаете за многие годы работы с ISP.net Core.
1484.46 1490.66 "Игорь Лабутин" Если же вы будете создавать новый проект на шестом .NET ISP.net Core темплейте, то вы получите minimal API.
1490.66 1504.74 "Игорь Лабутин" Это top-level statement, global usings и те самые там 4 строчки кода, которые вам генерят hello world программку, в которой на первый взгляд вообще непонятно куда подступиться, чтобы начать собственно все конфигурить так же, как вы это умели делать раньше.
1504.74 1534.62 "Игорь Лабутин" И вот Дэвид Фаулер в своей манере выпустил, ну не сказать даже, что это статья, это GIST на GitHub, про который он затвитил, но в котором содержатся очень полезные и подробные рекомендации вообще как поступать с этой новой моделью хостинга, как с ней работать и что делать, если вы пришли из мира, где вы работали раньше по-другому, а хотите что-то делать в новой модели или наоборот, если вы сгенерили новую модель и хотите ее привести немножко обратно к старому виду.
1534.62 1538.46 "Игорь Лабутин" Вот, я давайте немножко пробегусь по этой статье.
1538.46 1558.02 "Игорь Лабутин" У нее две части, первая это такая больше теоретическая с точки зрения, что поменялось и как к этому надо относиться, а вторая это прям практически читшит, где написано, что если вы хотите там сделать то-то, то вот пишите такой код, если вы хотите сделать это, то напишите такой код.
1558.02 1561.38 "Игорь Лабутин" Прям подробно с примерами все совершенно замечательно.
1561.38 1575.02 "Игорь Лабутин" Очень рекомендую, если вам интересно, как вообще эти minimal API использовать, может быть вы найдете какую-то интересную комбинацию из новой этой хостинг модели и при этом не использовать старый стартап, кто знает.
1575.02 1600.18 "Игорь Лабутин" Итак, в новой, напомню, что новая хостинг модель приводит к тому, что свежесозданные проектики выглядят как четыре строчки, сначала мы создаем билдер с помощью вызова webapplication.createbuilder, потом мы из этого билдера с помощью вызова builder.build создаем приложение, на приложении мы вызываем mapget рутового пути, с помощью лямбда возвращаем строчку hello world, ну и говорим map.run, чтобы все это запустилось.
1600.18 1606.66 "Игорь Лабутин" То есть три простых действия, создали билдер, создали приложение, приложению сказали вот твой урл и запустите приложение.
1606.66 1629.82 "Игорь Лабутин" По мнению Дэвида Фауля, это в принципе более-менее должно практически механически переноситься из пятого .NET, то есть если у вас есть какой-то проект на пятом .NET, где есть какой-то навороченный services и метод configure с вашим pipeline, он практически один в один с помощью простых механических преобразований должен преобразоваться в новый темплейт по определенным правилам.
1629.82 1649.82 "Игорь Лабутин" Все что у вас было в методе configure services, который принимала service collection напоминаю, теперь вы сможете взять из вашего билдера, вернее у билдера есть property services, вы в нее можете точно так же писать как вы обычно пишете все ваши extension методы, это тот же самый service collection.
1649.82 1673.74 "Игорь Лабутин" Все что вы умели делать в configure, там вам выдавался application builder, если вы помните аргументом, то здесь для этого у вас есть тот самый класс application, для которого вызываются mapget и другие такие подобные функции, вы можете взять тоже самый ваш extension метод для регистрации middleware и всего такого вполне спокойно использовать, то есть в принципе замена практически один в один.
1673.74 1690.90 "Игорь Лабутин" Но есть и разница, по дефолту теперь, во-первых, если у вас окружение development, за вас теперь framework сам будет подсовывать developer exception page middleware, самое начало пайплайна, чтобы если что писать к вам красивый exception, но только если вы в development.
1690.90 1700.74 "Игорь Лабутин" Имя приложения по дефолту будет fullname, то есть в который был entry point, это можно переопределить, но по дефолту оно теперь такое.
1700.74 1716.34 "Игорь Лабутин" И соответственно не нужно использовать use routing, теперь вызов потому что endpoint routing middleware, она как бы в себя включает весь тот pipeline, который вы определите, так что routing у вас автоматически включен по сути.
1716.34 1736.58 "Игорь Лабутин" Полный pipeline теперь запускается до того, как запускается, точнее не запускается, а полный pipeline создается до того, как использован хотя бы один из стартап-фильтров, поэтому если у вас раньше была какая-то надежда, что стартап-фильтр может исполниться еще до, нет, теперь сначала полностью создается pipeline, потом уже только стартап-фильтры.
1736.58 1748.58 "Игорь Лабутин" Когда вы создали web application builder, уже ничего нельзя менять в нем, то есть никаких хост-сеттингов типа application name, окружения, контент-рута, этого все менять нельзя, меняйте это до того, как создаете web application builder.
1748.58 1760.62 "Игорь Лабутин" И нельзя написать use startup и на халяву использовать стартап-класс, такое теперь тоже не поддержано, use startup, kind of exception, потому что в minimal API-варианте оно так не работает.
1760.62 1783.86 "Игорь Лабутин" И последний момент, если вы помните, раньше, когда методы configure services, configure host и вот это вот все, они вызывались слегка отложенно, сейчас это все вызывается прям на месте, то есть по мере того, как вы исполняете вашу программу, вы можете ходить в этот service collection, там все будет на самом деле зарегистрировано и использовано.
1783.86 1798.82 "Игорь Лабутин" При этом, если вы пишете библиотеки для SP net core, то для вас ничего по идее не должно поменяться, вы точно также используете i-host builder, i-webhost builder, i-application builder и i-endpoint root-helm builder и никаких для вас изменений быть не должно.
1798.82 1802.98 "Игорь Лабутин" По API все осталось абсолютно совместимым.
1802.98 1826.82 "Игорь Лабутин" По мнению Дэвида, новая модель хостинга, она примерно на 98% соответствует старой, в смысле, что она поддерживает 98% того, что можно было сделать на старой и есть 2% исключений, это в основном всякие воркеры и такие штуки, которые, ну все-таки новая модель, она была преимущественно сделана для SP net, не для воркеров, для воркеров скорее всего можно пока использовать старую.
1826.82 1831.98 "Игорь Лабутин" Можно ли считать, что старая модель померла или теперь она депрекрейтнулась?
1831.98 1850.42 "Игорь Лабутин" Нет, ни в коем случае, опять же по мнению Дэвида, по его информации, точнее, а не по мнению, я надеюсь, что это официальная информация практически от самой команды разработки, это просто альтернативная модель и обе они продолжат жить независимо и вечно, ну насколько это может быть вечно, возможно до следующего мажорного релиза, кто знает.
1850.42 1853.82 "Игорь Лабутин" Нужно ли обязательно мигрировать в новую хостинг модель?
1853.82 1862.42 "Игорь Лабутин" Нет, не обязательно, то есть кажется, что это проще, ну она более простая, но если у вас есть старый работающий код, пусть он дальше продолжит работать, ничего с ним не будет.
1862.42 1865.14 "Игорь Лабутин" Нужно ли использовать топ-левел стейтменты?
1865.14 1874.46 "Игорь Лабутин" Нет, опять же, ни в коем случае, это не обязательно, вы можете точно так же использовать минимал-апи, но внутри вашего мейна, никаких вопросов, это не обязательно.
1874.46 1876.50 "Игорь Лабутин" Что делать с тестированием?
1876.50 1883.38 "Игорь Лабутин" То есть, если вы знаете, можно сп над кору, там контроллеры и всякие такие штуки, потестировать с помощью web application factory либо тест сервера.
1883.38 1889.34 "Игорь Лабутин" Новая модель дружит с web application factory, так что используйте ее и сможете тогда писать ваши тесты.
1889.34 1896.98 "Игорь Лабутин" Можно, как я уже сказал, использовать custom dependency injection container, можно использовать custom logger.
1896.98 1913.02 "Игорь Лабутин" Если вы хотите старую, так сказать, модификацию с классом startup, это тоже можно сделать, но только там придется чуть-чуть приседать и вот эту конвеншн на тему того, что вызов конфигер сервиса, а потом конфигер, сделать его по сути явным и заимплементировать самому.
1913.02 1929.82 "Игорь Лабутин" На все эти рекомендации есть в читшите, это вторая половина этого гиста, статьи, и там прямо на конкретных примерах написано, что нужно делать, как добавить серилок, как добавить какой-нибудь, не помню, по-моему, аутофак там добавляли, если я правильно помню, в качестве di-контейнера.
1929.82 1942.22 "Игорь Лабутин" То есть, в общем, я, прочитав все это, более-менее практически нашел ответы на все те вопросы, которые у меня могли бы возникнуть, переноси я наш, допустим, проект на новую minimal API модель, на новый хостинг точнее.
1942.22 1949.02 "Анатолий Кулаков" Ну то есть я правильно понимаю, что если я возьму просто свой старый проект и захочу его откомпилировать под новый S/P/NET, у меня ничего не получится.
1949.02 1950.02 "Игорь Лабутин" Нет, наоборот.
1950.02 1956.46 "Игорь Лабутин" Если ты возьмешь старый проект, откомпилируешь его с шестым SDK, затаргетишь шестой .NET, то все будет работать.
1956.46 1961.42 "Анатолий Кулаков" Ты сказал, что если мы хотим все-таки вот эти старые стартапы и так далее, нам нужно будет поприседать.
1961.42 1964.74 "Игорь Лабутин" Нет, старые стартапы, если ты начал использовать новые хостбилдеры.
1964.74 1967.82 "Игорь Лабутин" В твоем старом проекте используются старые хостбилдеры.
1967.82 1973.62 "Игорь Лабутин" Ну вот этот createDefaultHostBuilder, да, или createDefaultBuilder, как там называлась эта функция в стандартном темплейте.
1973.62 1980.04 "Игорь Лабутин" Это все работает по-старому, то есть они сделали новые методы, новые билдеры для того, чтобы поддержать новые minimal API.
1980.04 1986.42 "Анатолий Кулаков" Хорошо, то есть если я не хочу вот этих новых minimal API, то у меня никаких проблем не будет, я откомпилируюсь и поеду дальше.
1986.42 1988.10 "Анатолий Кулаков" Тогда вопрос, а почему я должен их хотеть?
1988.10 1989.74 "Анатолий Кулаков" Есть хоть какая-нибудь одна причина?
1989.74 1994.06 "Анатолий Кулаков" Ну кроме того, что это по-хипстерски красиво и все в одном файлике без numspace.
1994.06 2001.70 "Игорь Лабутин" Я думаю, что если у тебя большой развесистый проект с огромным количеством контроллеров и так далее, то наверное смысла в этом нет.
2001.70 2023.06 "Игорь Лабутин" А если же у тебя какой-то простой, относительно, не знаю там, простая пишка на пару контроллеров, небольшое количество endpoints, то может быть, отказавшись от контроллеров, переписав все на вот эти вот map.get, да, непосредственно на лямбточки с вызовом прямо вот этих самых, от конкретных маршрутов, может быть ты сэкономишь немножко кода.
2023.06 2029.98 "Игорь Лабутин" Но это все-таки чуть больше, чем просто перенести на новых моделей хостинга, это все-таки отказаться от контроллеров или еще что-то в таком духе.
2029.98 2039.10 "Игорь Лабутин" Тебе никто не мешает написать usemvc или как там usecontrollers, да, usemvc это старое, usecontrollers и продолжить использовать все контроллеры.
2039.10 2045.42 "Игорь Лабутин" Но прям выгоды, ну, Майкрософт считает, что конфигурация всего в одном файле это типа прикольнее и более явное.
2045.42 2050.86 "Игорь Лабутин" По старинке кажется, что естественно привычнее старый вариант, но старый вариант всегда привычнее на самом деле.
2050.86 2059.38 "Анатолий Кулаков" Ну не знаю, мои старые варианты, они там на много сотен строчек кода разъезжаются и там как бы в один файлик я это точно запихивать бы не хотел.
2059.38 2064.34 "Игорь Лабутин" Ну вот я думаю, что твой кейс вряд ли, скажем так, цель для минимал-APIs.
2064.34 2065.34 "Игорь Лабутин" Это хорошо.
2065.34 2069.50 "Анатолий Кулаков" Ну, особенно хорошо, что мой кейс продолжит работать, это самое главное.
2069.50 2070.50 "Анатолий Кулаков" Давай дальше.
2070.50 2092.38 "Анатолий Кулаков" Хорошо, у нас практически ни одного выпуска не выходит без Source Generator, и сегодня тоже не хотелось сделать исключение, поговорим про еще один замечательный Source Generator, который нам в этот раз расписал Andrew Locke, наш один из самых любимых авторов, и в этом своем блог-посте он нам рассказал, каким можно образом улучшить ваше логирование с помощью Source Generator.
2092.38 2105.02 "Анатолий Кулаков" В принципе, у логирования огромные перспективы, и почему эти перспективы очень часто не реализовывались в последних проектах, как раз таки в основном из-за Boulder Plate Code, про который мы сегодня и поговорим.
2105.02 2113.26 "Анатолий Кулаков" Итак, прежде всего мы будем разговаривать про новый Logger Message Source Generator, который будет в новом SDK.
2113.26 2125.46 "Анатолий Кулаков" Этот Source Generator позволит вам упростить методы вашего логирования, то есть убрать из них некоторые проблемы, а также поможет увеличить производительность ваших методов логирования.
2125.46 2136.86 "Анатолий Кулаков" Для высоконагруженных приложений, в принципе, такая проблема очень часто встает, что тормозят логи, и не всегда это связано только с дисковой файловой системой ввода-вывода.
2136.86 2141.34 "Анатолий Кулаков" Здесь еще есть море точек для оптимизации, но об этом мы поговорим чуть попозже.
2141.34 2153.46 "Анатолий Кулаков" И также мы сможем уменьшить с помощью этого Source Generator количество возможных ошибок, которые разработчики могли бы допустить, явно пользуясь большим количеством строчек для логирования.
2153.46 2158.98 "Анатолий Кулаков" Давайте же вспомним, Source Generator, прежде всего, к нам поступили в продакшен в .NET 5.
2158.98 2167.38 "Анатолий Кулаков" Но в .NET 5 они, в принципе, были задекларированы, но большой интеграции с фреймворком все еще не получили, потому что это была новая штука, новая фишка.
2167.38 2171.30 "Анатолий Кулаков" Всем дали попробовать, особенно плагинописателям и прочим людям.
2171.30 2177.62 "Анатолий Кулаков" И шестой .NET это, наконец-то, тот фреймворк, который выходит с глубокой интеграцией генераторов.
2177.62 2188.14 "Анатолий Кулаков" Не в том смысле, что они начали какие-то новые фишки магические получили, а в том смысле, что сама команда Microsoft начала их непосредственно использовать в своих проектах.
2188.14 2191.54 "Анатолий Кулаков" А проектов, где их можно использовать, огромное число.
2191.54 2195.38 "Анатолий Кулаков" Например, неоднократно нами упомянутый уже System Text JSON.
2195.38 2205.54 "Анатолий Кулаков" Там с помощью Source Generator был уменьшен overhead на сериализацию в стартап-время, уменьшена локация и прочие бенефиты.
2205.54 2211.30 "Анатолий Кулаков" Также Blazor и Razor компиляторы сейчас активно используют Source Generator.
2211.30 2217.90 "Анатолий Кулаков" Event Source Generator - это еще один представитель, который помогает легче создавать классы с Event Source.
2217.90 2225.02 "Анатолий Кулаков" И в принципе миллион-миллион других, как внутри самой команды .NET, так и в принципе сторонних.
2225.02 2232.90 "Анатолий Кулаков" Если вы следите за нашим подкастом, вы наверняка натыкались уже на кучу всяких интересных идей и реализаций Source Generator.
2232.90 2236.18 "Анатолий Кулаков" Итак, а теперь посмотрим, что же у нас творится с логированием.
2236.18 2242.34 "Анатолий Кулаков" В принципе, с логированием, начиная с Core Framework, стало намного лучше.
2242.34 2249.62 "Анатолий Кулаков" Ну, в том плане, что у нас теперь появился общий класс, общий интерфейс, даже который называется iLogger.
2249.62 2256.30 "Анатолий Кулаков" И он объединил себе все это многообразие, весь этот зоопарк логеров, которые существуют вокруг платформы .NET.
2256.30 2260.74 "Анатолий Кулаков" Обычно iLogger инжектируется в конструктор с помощью специального контейнера.
2260.74 2268.62 "Анатолий Кулаков" Внутри вы можете iLogger сохранить в какое-нибудь приватное поле и с помощью него писать сообщение, в принципе, куда он настроен.
2268.62 2271.34 "Анатолий Кулаков" Все довольно интуитивно, все довольно-таки просто.
2271.34 2279.50 "Анатолий Кулаков" И единственное нововведение, которое, может быть, было непривычным большинству народа, было это введение в .NET Core структурного логирования.
2279.50 2284.90 "Анатолий Кулаков" Раньше логеры не очень хвастались структурным логированием, буквально кроме серилога.
2284.90 2292.70 "Анатолий Кулаков" А здесь же их всех практически заставили посмотреть на эту тему как минимум, а желательно вообще еще и поддержать.
2292.70 2297.74 "Анатолий Кулаков" Структурное логирование, да и логирование в общем, налагает несколько правил.
2297.74 2308.10 "Анатолий Кулаков" Эти правила у структурного логирования, они намного жестче, в том плане, что вы получите намного больше проблем, если не будете их соблюдать.
2308.10 2313.06 "Анатолий Кулаков" Поэтому неплохо бы их повторить и заодно, может быть, кому-то и узнать.
2313.06 2326.90 "Анатолий Кулаков" А во-первых, никогда нельзя использовать интерполированные строки, когда вы логируете в .NET Core, то есть, когда вы используете структурное логирование, то есть, когда вы используете вот этот iLogger класс, потому что он как раз-таки на это и нацелен.
2326.90 2329.50 "Анатолий Кулаков" Почему вредны интерполированные строки?
2329.50 2335.66 "Анатолий Кулаков" Безусловно, они в любом другом случае прекрасны, мы их давно ждали, мы их все любим, но только не в логировании.
2335.66 2354.10 "Анатолий Кулаков" Если будете использовать их для записи в лог, то вы непосредственно потеряете само структурное логирование, то есть, саму структуру лога в ней утеряется, ибо все эти строки отформатируются, преобразуются в рантайме и конечный движок, конечный провайдер никакой структуры не получит.
2354.10 2357.46 "Анатолий Кулаков" Он получит просто plain строку, с которой ничего абсолютно сделать не сможет.
2357.46 2370.74 "Анатолий Кулаков" Также очень четко нужно следить за тем, чтобы не потерять константность message-темплейта, то есть, того сообщения, которое непосредственно идет строкой в ваше логирование, в ваше сообщение.
2370.74 2380.90 "Анатолий Кулаков" Его неизменяемость очень важна для многих вещей, ну и в частности, по ней генерируется так называемый event ID, то есть, уникальный идентификатор этого сообщения.
2380.90 2390.06 "Анатолий Кулаков" Если строка будет изменяемой, то как минимум вы потеряете event ID, а как максимум у вас будут огромное количество проблем с вашим хранилищем логов.
2390.06 2392.82 "Анатолий Кулаков" Об этом не будем углубляться, может как-нибудь потом поговорим.
2392.82 2408.94 "Анатолий Кулаков" И дальше, если вы используете string interpolation в вашем коде, то вы всю работу по форматированию этой строки и вообще по созданию этой строки по локации памяти для этой строки производите в момент вызова метода write.
2408.94 2412.02 "Анатолий Кулаков" Ну то есть, чем это может быть плохо?
2412.02 2419.58 "Анатолий Кулаков" А плохо это может быть тем, что у нас тот уровень логирования, под которым вы пытаетесь записать эту строку, может быть сейчас выключен.
2419.58 2430.34 "Анатолий Кулаков" То есть, довольно частая ситуация, когда разработчики пишут очень подробные логи под уровнем debug, но на продакшене этот уровень debug обычно никому не нужен и его выключают.
2430.34 2434.50 "Анатолий Кулаков" То есть повышают до information, error и так далее.
2434.50 2449.70 "Анатолий Кулаков" И так как большинство все-таки сообщений будут писаться под debug, потому что это самый подробный уровень, самый низкий уровень, получается, что зря будут форматироваться строки, зря будут аллоцироваться строки и на это все будут тратиться какие-никакие ресурсы компьютера.
2449.70 2453.34 "Анатолий Кулаков" Поэтому здесь string interpolation тоже очень сильно вредит.
2453.34 2464.22 "Анатолий Кулаков" Дальше еще одно правило, которое мы в принципе вскользь затронули, это то, что по-хорошему нужно бы проверять тот уровень логирования, под которым вы собираетесь писать сейчас логи.
2464.22 2470.70 "Анатолий Кулаков" Безусловно, где-то внутри он там проверится, но прежде чем он проверится, у вас уже будут какие-то аллокации.
2470.70 2477.50 "Анатолий Кулаков" И если мы говорим про частый debug, частые месседжи в дебаге, то этих аллокаций может быть очень и очень много.
2477.50 2487.86 "Анатолий Кулаков" Более правильный подход это все-таки вставлять проверку if log level такой-то разрешен, то тогда давайте писать, давайте уже начинать аллоцировать.
2487.86 2503.02 "Анатолий Кулаков" Безусловно, очень практически никто никогда так не делает, потому что добавляется куча некрасивого boilerplate, уже вместо одной строчки логер записать какую-то информацию, у вас уже появляется там 4 строчки.
2503.02 2511.10 "Анатолий Кулаков" То есть вам надо if проверить, что уровень включен, вам надо скобочки там поставить и непосредственно выполнить сам лог.
2511.10 2518.14 "Анатолий Кулаков" Это некрасиво, длинно, немодно и поэтому практически ни в каких проектах этим не пользуется.
2518.14 2526.38 "Анатолий Кулаков" Соглашаются с тем, что это даст какие-то performance penalty, ну тех кто знает, и забивают.
2526.38 2533.18 "Анатолий Кулаков" Еще одна проблема с тем, что нам нужно писать вот этот if, это в том, что у нас лишнее место для ошибки появляется.
2533.18 2540.94 "Анатолий Кулаков" Мы можем в if вполне проверить один уровень для логирования, а на самом деле в логере записать под другим уровнем логирования.
2540.94 2548.82 "Анатолий Кулаков" Это часто бывает, когда например разработчик хочет поменять уже существующий уровень, он меняет его в одном месте, а во втором месте забывает.
2548.82 2554.82 "Анатолий Кулаков" Вот тоже такие баги довольно неприятные, мелкие, но опять же лишнее место для ошибок это плохо всегда.
2554.82 2562.06 "Анатолий Кулаков" Третье правило, которое хочется рассмотреть, это то, что вы должны очень тщательно проверять количество параметров.
2562.06 2579.48 "Анатолий Кулаков" Потому что если вы вдруг попытаетесь записать некорректное число параметров, то в лучшем случае вы не увидите нужной вам информации, а в худшем случае вы получите runtime error, который скажет, что там количество параметров не соответствует ожидаемому, не могу что-то там у себя найти.
2579.48 2590.12 "Анатолий Кулаков" Эту проблему более или менее научились решать анализаторы, но опять тоже не всегда для всех логеров они есть, не всегда корректно проверяют, но в принципе анализаторы хорошо покрывают эту штуку.
2590.12 2598.28 "Анатолий Кулаков" Четвертое и самая наверное недооцененная фишка локирования это то, что мы можем прооптимизировать темплейты.
2598.28 2599.96 "Анатолий Кулаков" А зачем же их нужно вообще оптимизировать?
2599.96 2610.88 "Анатолий Кулаков" Ну представьте себе структурное логирование, вы туда передаете строчку, которая как раз таки задает тот темплейт логирования, под которым будут как раз форматироваться все сообщения.
2610.88 2624.64 "Анатолий Кулаков" И для того, чтобы эту строчку как-то преобразовать в структуру, необходимо распарстить ее, необходимо применить токенайзер, необходимо выделить оттуда какие-то специальные именованные секции и получить вот как раз таки то описание структуры, которое есть.
2624.64 2630.56 "Анатолий Кулаков" И к сожалению это может понадобиться делать каждый раз, когда вы эту строчку передаете.
2630.56 2636.24 "Анатолий Кулаков" Вы надеетесь, что эта строчка вам просто куда-то там выведется на консоли или просто сохранится куда-то в память, но нет.
2636.24 2643.56 "Анатолий Кулаков" Ее нужно там распарсить, ее нужно децерализовать и с ней нужно провернуть очень много всяких сравнительно тяжелых операций.
2643.56 2646.44 "Анатолий Кулаков" Безусловно первое, что хочется сделать это закэшировать.
2646.44 2658.56 "Анатолий Кулаков" И на самом деле настоящий iLogger текущий, который есть у Микрософта, он кэширует все эти распаршенные темплейты и кэш этот, он не бесконечен.
2658.56 2663.56 "Анатолий Кулаков" В данном случае сейчас он занимает всего-навсего 1024 сообщений.
2663.56 2669.80 "Анатолий Кулаков" Можете посчитать сколько разных сообщений есть в вашем приложении, если их там 1024, то вы вполне справляетесь с поставленной задачей.
2669.80 2677.20 "Анатолий Кулаков" Если же их больше, то постепенно кэш начнет чиститься и постепенно у вас перформанс начнет деградировать на строчках с логированием.
2677.20 2684.48 "Анатолий Кулаков" Если же вы знаете, что логи пишутся довольно часто в этом месте, в каком-то конкретном месте в вашем коде, вы можете этот кусочек кода прооптимизировать.
2684.48 2691.36 "Анатолий Кулаков" Вы можете сделать свой собственный уже распаршенный темплейт.
2691.36 2696.64 "Анатолий Кулаков" Для этого есть специальный метод, который находится в лог месседжа, называется он define.
2696.64 2713.08 "Анатолий Кулаков" Вызывая метод define и передав туда все нужные аргументы, вы все расходы, касающиеся сериализации, токенизации, парса вот этого месседж темплейта, вы переложите в метод define.
2713.08 2719.32 "Анатолий Кулаков" То есть вы можете в один раз его вызвать и дальше пользоваться результатом его работы постоянно в вашем приложении.
2719.32 2721.76 "Анатолий Кулаков" А результатом его работы будет являться некий экшен.
2721.76 2730.44 "Анатолий Кулаков" Экшен, который внутрь себя принимает все, все те зависимости, все те параметры, которые вы могли бы передать в ваш логер.
2730.44 2743.04 "Анатолий Кулаков" И таким образом, переложив всю нагрузку в одну точку, в точку define, и используя экшен в своем коде, вы очень сильно улучшите перформанс вот этого участка.
2743.04 2752.36 "Анатолий Кулаков" Внутри этого экшена уже будет проверка на необходимый уровень логирования, уже будет вызов с правильным уровнем логирования, который вы там задали во время define.
2752.36 2771.00 "Анатолий Кулаков" И в принципе, кроме увеличения перформанса, он также вам проверит корректность передаваемых аргументов и взгенерит, даже вернет, вернет экшен, в котором все эти аргументы будут в правильном типе, и у вас уже будет меньше шансов что-то забыть или что-то там промазать.
2771.00 2777.32 "Анатолий Кулаков" И плюс, кроме того, этот define позволяет вам уменьшить аллокации.
2777.32 2781.36 "Анатолий Кулаков" То есть теперь ваше логирование не будет приводить абсолютно никаким аллокациям.
2781.36 2784.80 "Анатолий Кулаков" Это будет и быстро, и по памяти очень эффективно.
2784.80 2791.24 "Анатолий Кулаков" То есть желательно, особенно в очень перформанс-критикал местах, всегда использовать define.
2791.24 2798.64 "Анатолий Кулаков" То есть определять явно message-темплейты, и после этого уже пользоваться непосредственно результатом их работы.
2798.64 2803.08 "Анатолий Кулаков" Но, к сожалению, практически никто, опять же, так не делает.
2803.08 2812.12 "Анатолий Кулаков" Не делает он потому, что это, опять же, очень много boilerplate, очень много церемоний, что-то надо где-то задефайнить, что-то надо не забыть, куда-то передать.
2812.12 2815.00 "Анатолий Кулаков" Намного легче взять логер и записать туда строчку.
2815.00 2819.96 "Анатолий Кулаков" И вот как раз-таки здесь отличная точка для того, чтобы у нас появились генераторы.
2819.96 2828.40 "Анатолий Кулаков" Генераторы как раз-таки и нужны в тех местах, где у вас получается куча какого-то однообразного boilerplate, и вам просто не хочется его писать.
2828.40 2829.96 "Анатолий Кулаков" Но писать его по-хорошему надо.
2829.96 2833.76 "Анатолий Кулаков" Как же генераторы решают нашу проблему?
2833.76 2849.20 "Анатолий Кулаков" На сцену выходит log.message.source.generator, который как раз-таки и позволяет неявно вызвать вот этот log.message.define, который проамптимизирует ваши message-темплейты для логирования.
2849.20 2858.36 "Анатолий Кулаков" Для того, чтобы им воспользоваться, вам достаточно создать partial метод, на этот метод навесить атрибут, который называется logger.message, и в принципе все.
2858.36 2859.36 "Анатолий Кулаков" Этого достаточно.
2859.36 2876.80 "Анатолий Кулаков" В этом partial методе вы просто-напросто определяете те переменные, которые хотите передать внутрь вашего логгера, а в атрибуте вы определяете все константные значения, например, log.level, под которым вы хотите логировать, например, message.template, под которым вы хотите писать и так далее.
2876.80 2882.76 "Анатолий Кулаков" И все, что не меняется, уходит в log.message, и оно сгенерируется константно за один раз в момент компиляции.
2882.76 2891.44 "Анатолий Кулаков" Все, что меняется, например, какие-то параметры, атрибуты, все, что вы хотите передать в логгер, оно будет приниматься в этом partial методе.
2891.44 2902.36 "Анатолий Кулаков" Source.generator пройдется по вашим полям, найдет в вашем поле классик, который наследуется от iLogger, и, соответственно, будет использовать именно его.
2902.36 2913.64 "Анатолий Кулаков" И также поддерживается динамический уровень логирования, если вы хотите в каких-то случаях данную строчку логировать под дебагом, под каких-то информацией, это все тоже поддерживается.
2913.64 2923.16 "Анатолий Кулаков" Также, если вам не нужен метод instance, вы хотите сделать статический define, то есть определить статический метод логирования, это тоже можно сделать с помощью этого атрибута.
2923.16 2953.60 "Анатолий Кулаков" И с помощью уже существующего код аналайзера у вас нет никаких шансов перепутать параметры, то есть все, что вы объявили в темплейте обязательно будет проверяться непосредственно в вашем экшене, в вашем partial методе, то есть все те проблемы, которые мы рассмотрели, включая то, что вы не можете перепутать параметры, так как в этом методе они будут в правильном порядке, и они будут с правильными типами, то есть все те проблемы, которые мы рассмотрели, они довольно легко и довольно красиво уходят.
2953.60 2960.28 "Анатолий Кулаков" Ну и плюс кажется, что это не настолько уж много кода писать, чем одну строчку.
2960.28 2973.52 "Анатолий Кулаков" Раньше действительно все-таки одна строчка была легче, потому что вы этот message template писали непосредственно в том месте, где вы начинали логировать, а здесь в данном подходе вам эту строчку, этот message template все-таки необходимо будет вынести в поле.
2973.52 2986.92 "Анатолий Кулаков" Но если вы все-таки загоняетесь перформансом, если вы все-таки знаете, что это место часто вызывается, то это тем минимальные действия, тем минимальные шаги, которые уже должно быть не так больно выполнять.
2986.92 2998.24 "Анатолий Кулаков" И кажется, что с вот этим подходом, с вот этим генератором мы наконец-то начнем логировать оптимально, правильно, особенно в перформанс критикал приложениях.
2998.24 3013.72 "Анатолий Кулаков" Мы тут много упоминали уже про перформанс и прочее, поэтому Андрей Лок нам сделал тестики, в которых с помощью benchmark.net доказывает действительно правоту и вот этих подходов.
3013.72 3018.40 "Анатолий Кулаков" Из этих тестиков можно увидеть, что действительно string interpolation просто ужасен.
3018.40 3027.28 "Анатолий Кулаков" Он дает там кучу просадок по памяти, кучу просадок по перформансу и использовать его просто абсолютно никогда нельзя и просто запрещается даже в текущем вашем коде.
3027.28 3031.36 "Анатолий Кулаков" Если вы так делали, срочно сожгите все и переделайте.
3031.36 3049.80 "Анатолий Кулаков" Дальше он нам показывает, что если использовать проверку для разрешения того, доступен ли данный уровень логирования сейчас или не доступен, это действительно работает быстрее и этим действительно можно загоняться, если код требует какого-то большого перформанса.
3049.80 3055.32 "Анатолий Кулаков" Ну и безусловно показывает, что logMessageDefine - это тот метод, который спасает просто от всего.
3055.32 3062.40 "Анатолий Кулаков" Он дает не только прирост производительности, но еще и делает полностью allocation-free модель, то есть никаких аллокаций у вас не будет.
3062.40 3070.80 "Анатолий Кулаков" И в некоторых кейсах, с учетом включенности и выключенности методов, с учетом define-ов, не define-ов, разница в перформансе достигает примерно 100 раз.
3070.80 3090.20 "Анатолий Кулаков" То есть для тех программ, которые смотрят на перформанс, можно вот эти строчки даже без обращения к файловой системе, даже без обращения к каким-то провайдерам сетевым, можно просто на вызове строчки с логированием убрать значительное количество тормозов.
3090.20 3095.36 "Анатолий Кулаков" Вот такой интересный новый генератор у нас появляется еще в нашем арсенале.
3095.36 3099.52 "Анатолий Кулаков" Надеюсь, его больше народу будет использовать, больше народу будет юзать.
3099.52 3105.56 "Анатолий Кулаков" Вообще оптимизация логирования, перформанс правильного логирования - это огромная богатая тема.
3105.56 3109.92 "Анатолий Кулаков" Надеюсь, мы к ней еще как-нибудь вернемся, если будут интересные статички.
3109.92 3126.44 "Игорь Лабутин" Мне кажется, я вот смотрю на все это, и задается мне, что это будет до некоторой степени похоже на ситуацию с minimal APIs, потому что все-таки тут, конечно, меньше приседаний нужно делать по сравнению со старым вариантом, когда нужно было кэшировать и logger message define писать.
3126.44 3132.16 "Игорь Лабутин" Но все равно это нужно определить методно, разметить атрибут, строчек куда-то вынести в атрибут.
3132.16 3138.24 "Игорь Лабутин" И думаю, что 99% народу будет все делать по старинке.
3138.24 3143.72 "Игорь Лабутин" Ну да, в перформанс критичном коде, конечно, теперь проще поюзать генератор будет, это правда.
3143.72 3146.16 "Анатолий Кулаков" Да, скорее всего, этому народу оно и не нужно.
3146.16 3153.60 "Анатолий Кулаков" То есть те, кто никогда не профайлер, не запускал профайлер и не упирался в то, что у него тормозит логирование, наверное, это ему и не нужно.
3153.60 3156.04 "Анатолий Кулаков" У них есть как бы другие места для оптимизации.
3156.04 3165.28 "Анатолий Кулаков" Но я просто знаю, что у меня много проектов, которые в общем мечтали о такой фиче и руками делали все эти define, и это было действительно не самое приятное занятие.
3165.28 3172.28 "Игорь Лабутин" Понятно, я никогда не сталкивался с тем, чтобы у меня тормозил именно логин, но, наверное, это не значит, что такого не бывает.
3172.28 3185.40 "Игорь Лабутин" Ладно, давай на самом деле вернемся чуть-чуть назад, потому что мы поговорили про ход reload и как Microsoft доблестно выпиливал его из релиз кандидата 1 из dotnetwatch и из SDK.
3185.40 3192.60 "Игорь Лабутин" Но на самом деле это не единственное, что произошло недавно, о чем говорили, скажем так, сообщества и журналисты вокруг Microsoft и dotnet.
3192.60 3206.60 "Игорь Лабутин" И давай, прежде чем мы дальше пойдем в какие-нибудь сложные технические темы опять, немножко все-таки вынырнем в журналистику и что происходит в мире вокруг дотнета, а именно вокруг dotnet foundation.
3206.60 3216.20 "Игорь Лабутин" Ты вообще, вот скажем так, если не брать вот эти последние события последнего месяца вокруг dotnet foundation, ты про него что-нибудь слышал в последнее время?
3216.20 3217.56 "Анатолий Кулаков" Да, абсолютно нет.
3217.56 3226.28 "Анатолий Кулаков" В принципе, тот момент, когда он появлялся, как-то много рекламировался, тот момент, когда были первые выборы, в общем тоже как-то демонстрировалась явно его открытость.
3226.28 3237.52 "Анатолий Кулаков" После того, как там что-то произошло, опять же появлялись эти выборы, но они были довольно-таки унылые, опять же появлялись какие-то проекты, которые добавлялись в foundation, но опять же не очень понятно, зачем они то добавлялись.
3237.52 3242.12 "Анатолий Кулаков" Ну в общем, все довольно тихо, уныло, и я бы не сказал, что там что-то про это можно рассказывать.
3242.12 3244.72 "Анатолий Кулаков" Именно поэтому, может, он в наших новостях никогда и не мелькал.
3244.72 3261.80 "Игорь Лабутин" Да, то есть действительно до событий последнего месяца выглядело это все так, что действительно раз в год там проходят какие-то выборы, они выбирают некоторое количество народа, и после чего весь этот народ, ну видимо участвует в каких-то совещаниях, но результатов этого вообще никак снаружи не видно.
3261.80 3267.40 "Игорь Лабутин" А вот за последний месяц наконец-таки какая-то видимость движухи вокруг dotnet foundation создалась, да еще какая.
3267.40 3275.40 "Игорь Лабутин" В общем, краткая история того, что произошло, если вы вдруг не следили, но чтобы вы знали, что может быть что-то будет меняться.
3275.40 3288.12 "Игорь Лабутин" Значит, dotnet foundation действительно такая организация, которая как бы вроде пытается, значит, убедить проекты open-source в нее вступить, потому что это, значит, этим проектам выгодно, тем или иным способом.
3288.12 3305.36 "Игорь Лабутин" И действительно оно, ну какие-то вещи упрощает, то есть они действительно упростили немножко и предоставили тулинг, которым сам Microsoft пользуется, например, для менеджмента сертификатов, которые нужны для подписывания, я так понимаю, NuGet пакетов для выкладки на NuGet.org.
3305.36 3317.44 "Игорь Лабутин" Потом они завели специального бота или не бота, который позволяет правильно настраивать автоматическое принятие кода в контакт для внешних коммиттеров, для внешних контрибютеров в проекты.
3317.44 3322.24 "Игорь Лабутин" То есть, в принципе, какие-то мелкие удобные штуки вроде как предоставляют.
3322.24 3331.28 "Игорь Лабутин" И это, пожалуй, единственное, где было видно ну хоть какое-то внешнее влияние dotnet foundation.
3331.28 3337.48 "Игорь Лабутин" Мне, например, как человеку, который не является мейн-тренером проекта, и поэтому вроде как я непосредственно с ними не общаюсь.
3337.48 3343.52 "Игорь Лабутин" Однако же последние несколько месяцев копилась всякая разная информация.
3343.52 3356.00 "Игорь Лабутин" Во-первых, из прошлого, так скажем, созыва директоров один из них ушел раньше, чем закончились его полномочия, и как-то там была очень странная переписка на тему, почему он ушел.
3356.00 3382.32 "Игорь Лабутин" То есть, dotnet foundation прямо явно написал, что вот в связи с семейными обстоятельствами и все такое, на что как бы этот товарищ, это Rodney Littles, разразился большой статьей на тему, что вообще это ни разу не family причины, а соответственно мне типа, ну как-то там было сформулировано такая круглая, что я типа не разделяю то, как работает или куда движется dotnet foundation.
3382.32 3390.72 "Игорь Лабутин" То есть никакой прямой конкретики, но тем не менее явно было его недовольство, видно было его недовольство работать с dotnet foundation.
3390.72 3404.56 "Игорь Лабутин" Потом в какой-то момент dotnet foundation, это действительно было так, они где-то в каких-то из своих статьях или анонсов публиковали, что мол, ребята, было бы здорово, если бы проекты, которые входят в dotnet foundation, там, включили у себя reproducible билды.
3404.56 3407.56 "Игорь Лабутин" Ну, как бы, было бы здорово.
3407.56 3409.96 "Игорь Лабутин" Месседж такой был, был, ну и ладно.
3409.96 3412.32 "Игорь Лабутин" Может кто-то включил, кто-то нет, не важно.
3412.32 3417.44 "Игорь Лабутин" Но один из проектов, я сейчас уже не вспомню какой, ну это не так принципиально.
3417.44 3429.92 "Игорь Лабутин" Короче, в один из проектов главный директор dotnet foundation, это Клэр Навотне, она и когда-то была мейн-тренером этого проекта, давным-давно, лет 5 назад, и с тех пор особо в нем ничего не делала.
3429.92 3444.44 "Игорь Лабутин" Она создала pull-request, который как раз-таки enable, нужно там добавлять нужные зависимости, чтобы за-enable все эти reproducible билды, и грубо говоря, закоммитила этот pull-request без какого-либо ревью и без консультации с текущими мейн-тренерами этого проекта.
3444.44 3448.88 "Игорь Лабутин" Потому что у нее типа админские права есть, она же мейн-тренер была 5 лет назад.
3448.88 3470.08 "Игорь Лабутин" Вокруг этого поднялась некоторая буча, и как-то на фоне всего этого народ стал смотреть вообще, что происходит, и выяснилось, что оказывается, очень многих проектов, которые вошли в dotnet foundation, их внезапно в github передвинули на другой, ну то, что называется, в другую организацию, не в смысле вот github organization, а в смысле с точки зрения биллинга.
3470.08 3476.44 "Игорь Лабутин" То есть передвинули на github enterprise server под, соответственно, dotnet foundation.
3476.44 3482.72 "Игорь Лабутин" А надо сказать, что сделать это может только админ проекта, и стали выяснять, как это сделано.
3482.72 3489.56 "Игорь Лабутин" Выяснилось, что это было сделано через юзера, который как раз-таки был нужен для вот того самого code of conduct автоматического принятия.
3489.56 3504.16 "Игорь Лабутин" Для того, чтобы он это, видимо, умел делать и умел назначать пользователя, который принял этот code of conduct в правильную группу, там, коммитеров, допустим, чтобы ему разрешались создать pull-request или закоммитить такие pull-request, то он имел админские права.
3504.16 3508.76 "Игорь Лабутин" Соответственно, через этого пользователя, имеющего админского права, эти проекты были перемещены.
3508.76 3512.20 "Игорь Лабутин" Это все прям как-то довольно сильно взорвало в комьюнити.
3512.20 3522.36 "Игорь Лабутин" Огромное количество народу написало там посты в твиттере, в блогах и везде на тему того, что вообще что происходит, где же, как бы, что творит dotnet foundation.
3522.36 3528.24 "Игорь Лабутин" Особо активно этим занимался iron standard, который мейн-тренер сайдснаки.net.
3528.24 3540.48 "Игорь Лабутин" Она входит в dotnet foundation, но он как раз-таки не использовал какие-то фичи, то есть, короче, не так активно взаимодействовал с dotnet foundation, потому что довольно скептически относился к тому, что он там творит.
3540.48 3555.64 "Игорь Лабутин" В итоге, в общем, там все завертелось, Клэр, соответственно, извинилась, написал такой извиняющий пост на тему сорян, значит, что-то я как-то это, да, не того, неправильно сделал, что, значит, не спросил о мейн-тренеров, вот это все.
3555.64 3562.52 "Игорь Лабутин" И, значит, после того, как он поста, твиттер, так сказать, забраковал со словами, что-то это не выглядит, как извинение.
3562.52 3577.16 "Игорь Лабутин" В итоге, через недельку примерно, или через несколько дней вышел новый пост про то, что я в итоге, типа, Клэр написал, что типа, ладно, короче, что-то какая-то фигня творится, я ухожу, значит, с поста директора, значит, потому что, как бы, да, все то, что происходит, это типа нехорошо.
3577.16 3604.44 "Игорь Лабутин" И надо сказать, что все это произошло через примерно недельку после того, как выбрали новый совет, значит, этих самых директоров, ну, тех, кто участвует в обсуждении деятельности .net foundation, и они, в общем, да, эти ребята получили довольно интересное наследство, в смысле, что сейчас они, как я понимаю, довольно активно там митингуют и пытаются сообразить, что с этим делать, как переориентировать, возможно, .net foundation в нужную, так сказать, комьюнити сторону.
3604.44 3635.72 "Игорь Лабутин" Вот, и как раз таки вот та история, на этом, как бы, пока все более-менее заканчивается, то есть прошло несколько митингов, видео, они стримились на ютубе, можете найти их, где как раз таки .net foundation, вот эти вот директора, спрашивали у народа, у майнтренеров, как бы, ребят, а что вы хотели бы, то есть, типа, что вас не устраивает, что бы вы хотели, как бы вы хотели поменять, и по этим результатам, видимо, будут пытаться принимать какие-то действия.
3635.72 3645.92 "Игорь Лабутин" Посмотрим, во что это выльется, и станет ли .net foundation как-то с чем-то полезным для сообщества, потому что сейчас это пока выглядит как довольно бесполезная организация.
3645.92 3664.04 "Анатолий Кулаков" Ну, если я вспомню там предыдущие созывы, то там были, ну, огромные гиганты, то есть, там раньше в этот список претендовали, ну, в том числе, Андрей Тинчин, безусловно, в общем, ну и много-много других таких популярных open source людей, которые, мне кажется, действительно могли бы что-то сделать.
3664.04 3673.60 "Анатолий Кулаков" Но вот этот список, он уже несколько сезонов довольно уныл, и мне кажется, вот те люди, которые сейчас там у руля, они не смогут делать абсолютно ничего интересного.
3673.60 3674.60 "Анатолий Кулаков" Вот туда стендарда надо.
3674.60 3676.16 "Анатолий Кулаков" Вот он бы им там показал кузькину мать.
3676.16 3694.56 "Игорь Лабутин" Тут, да, с одной стороны, ты прав, потому что, например, одним из первых этих самых вот ребят, которые были в борде, был Мигель Дейказа, и он как раз-таки туда приходил, чтобы попытаться построить нормальное open source community, потому что у него был опыт этого построения, вокруг, соответственно, того, что он делал в Linux мире.
3694.56 3708.68 "Игорь Лабутин" Надо сказать, что я не смотрел полностью список того, кто сейчас там во главе, но несколько ребят, ну, скажем так, то, как они реагировали в твиттере и в своих блогах и так далее, мне, в принципе, понравилось, как они писали.
3708.68 3718.88 "Игорь Лабутин" А есть, по крайней мере, ощущение, что они умеют что-то делать с точки зрения именно вот менеджмента как бы людей, community и так далее.
3718.88 3730.64 "Игорь Лабутин" Так что, может быть, несмотря на то, что может быть, они для нас действительно не какие-то крутые там чуваки, которые прямо имена-имена, может быть, на самом деле они неплохие и смогут что-то сделать.
3730.64 3740.16 "Игорь Лабутин" Просто тут, видишь, у DotNet Foundation есть, кажется, две слегка несовместимых, может быть, цели.
3740.16 3759.84 "Игорь Лабутин" Ну, если это можно назвать целью, хорошо, даже не целью, а, наверное, какого-то ожидания со стороны community состоит в том, что DotNet Foundation будет сильно помогать community каким-то образом, а ожидания Microsoft от DotNet Foundation, потому что, в конце концов, Microsoft их основала, заключается в том, что DotNet Foundation как-то будет помогать Microsoft.
3759.84 3773.60 "Игорь Лабутин" И вот все эти подвижки типа перенести все на GitHub сервер, зафорсить какие-то reproducible билды, они, кажется, больше, вот похоже на историю с Hot Reload, когда это какое-то менеджерское решение сверху со стороны Microsoft.
3773.60 3778.40 "Игорь Лабутин" И эти два направления весьма сильно конфликтуют, кажется.
3778.40 3789.84 "Анатолий Кулаков" Ну, да, на решение здравого человека это вообще не похоже, типа взять другой репозиторий через ботов, которые случайно ему дали админские права и перенести их под какой-то другой организацию.
3789.84 3794.32 "Анатолий Кулаков" Ну, то есть здравомылие никто делать бы не стал, то есть это явная большая там security дырка или что-то
3794.32 3810.32 "Игорь Лабутин" в этом духе. Это с одной стороны, но с другой стороны, если мы говорим про людей, какие бы крутые, то есть будь там даже тот же Мигель, хотя Мигель сейчас в Майкрософте, ну уровня люди Мигели, но извне Майкрософта, тут возможно есть некоторый конфликт как бы Майкрософта и всех остальных.
3810.32 3818.16 "Игорь Лабутин" Поэтому какие бы крутыми они не были, скорее всего им нужно будет как-то договариваться с Майкрософтом, и я предполагаю, что именно это сейчас как-то происходит, собственно.
3818.16 3829.80 "Игорь Лабутин" Как же переориентировать ДотНет Фаундейшн на опен сурс, не при этом не навредив каким-то целям внутреннего Майкрософта по там распространению, продвижению, использованию, зарабатыванию денег с опен сурса, я уже не знаю.
3829.80 3838.92 "Анатолий Кулаков" А есть уже какие-то идеи, которые сообщество предложило изменить в ДотНет Фаундейшне, и оно согласилось это сделать или не согласилось, то есть вообще что люди хотят от
3838.92 3847.60 "Игорь Лабутин" Фаундейшна? Я пока с тех пор, как это всё произошло, никаких каких-то таких конкретных постов на эту тему не видел.
3847.60 3871.84 "Игорь Лабутин" То есть я знаю, что хотели как бы в моменте, в моменте понятно хотели откатить нафиг все эти перемещения в GitHub, значит более чётко прописать правила того, во что собственно получает проект, когда он вступает в ДотНет Фаундейшн, кому какие права отходят, ну и так далее, потому что там звучали неоднозначные правила на тему кому принадлежит проект, да, кто там оунер, ну вот это всё.
3871.84 3880.84 "Игорь Лабутин" Вот, то есть, но это больше именно было в моменте, я так понимаю, больше для какого-то понимания статус кво, то есть, а где мы сейчас?
3880.84 3905.84 "Игорь Лабутин" Вот, дальше понятно, что там есть некоторые идеи, там тоже Аарона есть статья на тему, как бы он видел полезную деятельность ДотНет Фаундейшн, то есть таких статьй я видел много, но типа, как бы нам хотелось, что бы было, но это именно их такие абстрактные хотелки, я не знаю, что высказывалось на этих митингах, они в принципе на ютубе есть, можно пересмотреть, наверное там что-то полезное было, наверняка там есть какие-то идеи, как раз таки то, что ты хочешь узнать.
3905.84 3921.04 "Игорь Лабутин" Вот, у меня просто не было времени, ну и я скорее жду вот именно какого-то, ну, что смотреть, что народ хочет, интересно посмотреть, что произойдет, вот, и как на это все отреагируют, в принципе по реакции будет понятно, получилось то, что хотели или не получилось.
3921.04 3930.12 "Анатолий Кулаков" Ну, ладно, мы будем следить, а если вы вдруг каким-то образом участвуете во всей этой вуханали или в курсе, приходите в гости, расскажите нам, что там изнутри происходит.
3930.12 3934.92 "Игорь Лабутин" Да, а если вы из Майкрософта, то будет, наверное, вообще прикольно, но вряд ли кто-то придет к нам.
3934.92 3944.20 "Анатолий Кулаков" Слушай, страшные у тебя темы, какие-то большие, менеджерские, глобальные, что-то хочется так, ну, да, не очень приятное, хочется чего-то такого маленького, уютного, тепленького.
3944.20 3946.04 "Анатолий Кулаков" Есть у меня тут маленькая статеечка.
3946.04 3948.80 "Анатолий Кулаков" Пошли обратно в технику, да.
3948.80 3951.48 "Анатолий Кулаков" Давай поговорим вот про date-only, time-only.
3951.48 3966.80 "Анатолий Кулаков" У нас добавились такие милые структурчики в наш уютный дотнетчик, вот, у нас давно, в принципе, не было каких-то добавлений, вот таких корневых вещей, корневых классов, которые, вот, кажется, что каждый день будут использоваться, поэтому давайте остановимся на них подробнее.
3966.80 3980.00 "Анатолий Кулаков" Мы уже обсуждали, как только они были задеконолорированы где-то, наверное, весной, да, весной мы про них уже говорили, но, в принципе, можно повторить и заодно посмотреть, к чему мы сейчас пришли, то есть, какая реализация будет на данный момент.
3980.00 3989.04 "Анатолий Кулаков" Итак, напомню, что у нас в дотнете есть прекрасный тип date-time, который включает в себя, как не парадоксально, время и дату.
3989.04 3995.64 "Анатолий Кулаков" Плохо в этом классе то, что он включает время и дату, даже если мы этого не хотели.
3995.64 3999.44 "Анатолий Кулаков" То есть, даже если нам нужна только дата, нам приходится таскать со собой date-time.
3999.44 4003.48 "Анатолий Кулаков" Даже если нам нужно только время, мы опять же таскаем собой полный date-time.
4003.48 4009.32 "Анатолий Кулаков" И обычно никто не загоняется во время всей реализации, что нам нужно передать только дату или только время.
4009.32 4013.24 "Анатолий Кулаков" Обычно обнуляют какое-то поле из этих и передают непосредственно date-time.
4013.24 4020.12 "Анатолий Кулаков" Ну, потому что это удобно, форматеры есть, парсеры есть, структурка готова есть, давайте таскать именно ее.
4020.12 4036.60 "Игорь Лабутин" А потом у нас был такой опыт, и дальше начинаются всякие забавные штуки, типа тебе нужно передать только время, ты ставишь какое-нибудь там 1 января какого-нибудь 2000 года или что-нибудь какого-нибудь нулевого года, не помню, можно ли или нет, по-моему нет, и передаешь только время.
4036.60 4044.56 "Игорь Лабутин" Потом оно внезапно конвертится, случайно совершенно, из какого-нибудь local в UTC, и вместо там 23.00 ты получаешь там 02.00, ну или наоборот.
4044.56 4048.44 "Игорь Лабутин" И у себя уже вроде бы и время, но уже какое-то странное.
4048.44 4053.88 "Анатолий Кулаков" Вроде бы уже дату просто так не отбросишь, потому что она уже не первая, там не говоря, вполне может быть второй.
4053.88 4071.84 "Игорь Лабутин" Да, да, а потом меняются правила перехода между тайм зонами, и там с учетом летнее и зимнее, ну в общем, короче, хранить время, чисто хранить дату внутри дайт тайма еще как-то можно, у нас особых проблем не было, а вот хранить чистое время внутри дайт тайма мы прям отказались от этого.
4071.84 4076.00 "Анатолий Кулаков" Именно так, есть много костылей и еще больше проблем с этими костылями.
4076.00 4111.56 "Анатолий Кулаков" Для времени, казалось бы, у нас еще есть такая штука как тайм спан, но нужно четко отличать, что тайм спан это все-таки промежуток, какой-то промежуток времени, какой-то duration, это не то же самое, что время в этом дне, то есть это не то же самое, что тайм онли, потому что тайм онли может быть там только от нуля часов и только до нуля часов, а тайм спан может быть насколько угодно большим и обозначать абсолютно не то, поэтому никогда не путайте тайм спан и тайм онли.
4111.56 4118.16 "Анатолий Кулаков" И все-таки наконец в дотнет 6 у нас появится дейт онли структурка и тайм онли структурка.
4118.16 4131.36 "Анатолий Кулаков" Создаются они как и ожидалось, принимая в конструктор параметры год, месяц, день для дейт онли и часы, минуты, секунды и так далее для тайм онли.
4131.36 4148.56 "Анатолий Кулаков" Также у них есть куча всяких других возможностей для создания, например метод from date time, в который вы можете передать наш уже привычный дейт тайм и оттуда заэкстрактиться незамысловатым способом эти структурки, кому что нужно.
4148.56 4170.32 "Анатолий Кулаков" Если рассмотреть подробнее, то в принципе они не сильно отличаются от дейт тайма, например структура дейт онли, у нее точно также есть методы at days, at month, at years, который соответственно может прибавить количество дней к текущей дате и метод try parse, безусловно куда же без него, который может из строки запарсить вам дату.
4170.32 4182.20 "Анатолий Кулаков" Внутри эта структурка сохраняет количество дней в формате в поле integer и нолик в этом integer обозначает 1 января первого года.
4182.20 4184.28 "Анатолий Кулаков" Кстати странно, почему нет нулевого года.
4184.28 4186.48 "Анатолий Кулаков" Ну допустим, это были какие-то причины.
4186.48 4190.64 "Анатолий Кулаков" В общем самая минимальная дата, которую вы можете сохранить это 1 января первого года.
4190.64 4198.48 "Анатолий Кулаков" Получить вот этот номер, количество тех самых дней можно с помощью свойства day number.
4198.48 4207.16 "Анатолий Кулаков" Это свойство возвращает соответственно int и также точно вы можете создать date only from day number, передав ему какой-то int.
4207.16 4215.72 "Анатолий Кулаков" Это создает вам структурку, которая будет как раз таки отражать количество дней и дату того номера, который в нее передали.
4215.72 4218.68 "Анатолий Кулаков" Все довольно логично и понятно.
4218.68 4225.60 "Анатолий Кулаков" Time only структурка внутри себя тоже хранит одно единственное поле, но это поле уже long и записываются туда тики.
4225.60 4229.56 "Анатолий Кулаков" Тик это 100 нс, начиная с полночи.
4229.56 4233.48 "Анатолий Кулаков" Ну то есть с 0 часов, 0 минут, 0 секунд.
4233.48 4244.84 "Анатолий Кулаков" Это поле можно считать легко с помощью свойства ticks у структурки time only и можно создать структуру time only передав ей вот эти тики.
4244.84 4247.80 "Анатолий Кулаков" И соответственно мы восстановим эту структуру.
4247.80 4254.32 "Анатолий Кулаков" Как видите очень легко из нее доставлять значения из их обоих и в принципе создавать заново.
4254.32 4258.76 "Анатолий Кулаков" У time only также поддерживаются математические операции, которые в результате возвращают спан.
4258.76 4263.76 "Анатолий Кулаков" Например можно вычислить из одного времени, вычесть другое время и как раз таки вернется time span.
4263.76 4267.76 "Анатолий Кулаков" То есть как раз промежуток между какими-то двумя временными отрезками.
4267.76 4272.68 "Анатолий Кулаков" Также появился метод, которого по-моему нет сейчас до сих пор в date time.
4272.68 4273.68 "Анатолий Кулаков" Это метод из between.
4273.68 4282.48 "Анатолий Кулаков" То есть вы можете сравнить попадает ли какое-то текущее значение в промежуток между временем 1 и временем 2.
4282.48 4290.32 "Анатолий Кулаков" Тоже полезная штука для того, чтобы как раз найти попадает ли промежуток между определенными временами.
4290.32 4292.44 "Анатолий Кулаков" Также теперь time only можно сравнивать.
4292.44 4297.76 "Анатолий Кулаков" Например узнать меньше ли текущее время, какое-то заданное время или нет.
4297.76 4303.16 "Анатолий Кулаков" Ну в общем то, что вы привыкли, то что вы ожидаете, то что вы хотите бы видеть.
4303.16 4308.36 "Анатолий Кулаков" В общем такие довольно милые структурки с предсказуемым поведением, не то что дотнет фаундейшн.
4308.36 4313.24 "Анатолий Кулаков" Здесь все хорошо, предсказуемо, мило и оптимизировано.
4313.24 4317.28 "Анатолий Кулаков" В общем ждем этих прекрасных малышей в нашем новом коде.
4317.28 4325.36 "Анатолий Кулаков" Нужно отметить, что с ними уже синтегрировался entity framework, все реализаторы и все возможные инфраструктурные слои вокруг.
4325.36 4332.68 "Анатолий Кулаков" Все умеют их прекрасно мапить, понимать, оптимизировать, строить по ним какие-то индексы, генерировать и в общем и так далее.
4332.68 4336.12 "Анатолий Кулаков" В общем структуры полностью вольются в нашу экосистему.
4336.12 4340.56 "Игорь Лабутин" Мы будем знать, эти выглядят действительно более привлекательно.
4340.56 4346.08 "Игорь Лабутин" Давай дальше, у нас осталось немножко статей, еще успеем их быстренько осмотреть, осветить.
4346.08 4352.36 "Анатолий Кулаков" Я думаю да, тем более что следующая статейка, которую хочу рассказать, касается немножко про minimal API, о которой ты упомянул.
4352.36 4368.68 "Анатолий Кулаков" Вот здесь хочется развернуть немножко minimal API в более в архитектурную среду и понять какие же там плюсы он может принести все-таки в нашем сложном коде, более чем вот эти hello world, которые пишут обычно для всяких демок.
4368.68 4374.08 "Анатолий Кулаков" Итак, в ISP.NET 6 у нас будет новая фича, которая называется endpoints.
4374.08 4379.72 "Анатолий Кулаков" Это как раз таки те вещи, которые Игорь упоминал, когда говорил про map route.
4379.72 4384.28 "Анатолий Кулаков" Мы можем замапить route на какой-то request делегат.
4384.28 4393.24 "Анатолий Кулаков" Эти делегаты способны обрабатывать входящие реквесты, входящие запросы из самого ISP.NET.
4393.24 4409.96 "Анатолий Кулаков" Здесь автор предлагает немножко рассмотреть ваше приложение с точки зрения во-первых изменения его архитектуры, то есть не архитектуры, а его расположения, его слоев, расположения его классиков.
4409.96 4424.44 "Анатолий Кулаков" Мы уже когда-то обсуждали два подхода, один из которых называется разделение ISP.NET модулей по техническим свойствам и второй – это vertical slice свойством.
4424.44 4442.76 "Анатолий Кулаков" По техническим свойствам вы сейчас, наверное, можете наблюдать в любом ISP.NET приложении, когда у вас есть какая-то папочка с контроллерами, там лежат контроллеры ко всем бизнес-сущностям, есть папочка с моделями, там лежат все модели, есть еще папочка с каким-то слоем доступа к данным и там все лежит про доступ к данным.
4442.76 4446.20 "Анатолий Кулаков" То есть делится по технической функциональности.
4446.20 4454.72 "Анатолий Кулаков" Существует другой подход, который широко пропагандируется, это Jimmy Bogart, если вы хотите подробнее про это узнать, почитайте в его блоге.
4454.72 4458.16 "Анатолий Кулаков" Этот подход называется vertical slice архитектура.
4458.16 4471.84 "Анатолий Кулаков" Это тот момент, когда мы пытаемся все наши модели, все наши контроллеры, все наши другие мапперы, утилиты и серилизаторы хранить вместе по их доменному признаку.
4471.84 4482.76 "Анатолий Кулаков" Допустим, у нас есть юзер и мы делаем какой-то юзер модуль, какую-то папочку для юзеров и в этот модуль с юзером складываем абсолютно все, что его касается.
4482.76 4489.80 "Анатолий Кулаков" Юзер контроллер, юзер маппер, юзер сериалайзер, юзер модели, юзер дтошки, все будет лежать в этой папочке с юзерами.
4489.80 4499.00 "Анатолий Кулаков" Это очень часто удобно, когда, например, можно всю эту папочку выкинуть и практически элементарно избавиться вообще от юзеров во всем вашем приложении.
4499.00 4505.80 "Анатолий Кулаков" Или точно так же добавить или разрабатывать, или искать ошибки, где вы видите все, что связано с юзером в одной папке.
4505.80 4514.00 "Анатолий Кулаков" Можно бегать по всему вашему приложению и искать, а где там мапятся сериализаторы, а где там мапятся какие-то контроллеры, где там еще что-то регистрируется.
4514.00 4515.28 "Анатолий Кулаков" Вот все в этой папке.
4515.28 4526.64 "Анатолий Кулаков" Такая архитектура довольно интересна и на больших проектах она очень часто используется, потому что это делает код намного предсказуемее, намного гибче и намного чище.
4526.64 4530.68 "Анатолий Кулаков" Давайте рассмотрим, как же выглядят сейчас наши контроллеры.
4530.68 4535.42 "Анатолий Кулаков" Прежде всего, это класс контроллер, неважно с атрибутиками или с каким-то наследованием.
4535.42 4543.16 "Анатолий Кулаков" Внутри этого контроллера появляется куча методов, например, GetCustomer, SaveCustomer, UpdateCustomer, еще там что-то делать с кастомеров.
4543.16 4560.84 "Анатолий Кулаков" В конструктор у этих контроллеров обычно рекомендуют передавать огромную кучу зависимостей от репозиториев, валидаторов, мапперов, еще очень много там всяких доменных сервисов и каждый метод использует какое-то подмножество этих зависимостей и что-то там с этим делает.
4560.84 4567.96 "Анатолий Кулаков" Такой подход, он довольно быстро превращает ваши контроллеры в огромную кучу грязи.
4567.96 4574.72 "Анатолий Кулаков" У вас, если доменная область более или менее сложна, у этого контроллера появляется очень много методов.
4574.72 4579.28 "Анатолий Кулаков" Все методы нужны, может быть разные сервисы.
4579.28 4588.56 "Анатолий Кулаков" Вот конструктор, соответственно, очень быстро разрастается и появляется такой огромный кусок грязного контроллера, огромный кусок грязи в виде контроллера.
4588.56 4593.80 "Анатолий Кулаков" Вот такую проблему решают чаще всего с помощью медиатора.
4593.80 4599.76 "Анатолий Кулаков" Медиатор - это специальный фреймворк, который позволяет вам у контроллера иметь всего на всего одну зависимость.
4599.76 4612.92 "Анатолий Кулаков" Одну зависимость - это как раз таки есть тот самый медиатор и просто-напросто перемапливать входящий реквест, http-реквест, перемапливать в какую-то новую команду или query и отправлять в этот медиатор.
4612.92 4617.00 "Анатолий Кулаков" Дальше уже на этот медиатор он представляет такую из себя in-memo решинку.
4617.00 4619.08 "Анатолий Кулаков" На эту решинку подписаны обработчики.
4619.08 4626.72 "Анатолий Кулаков" Обработчики ловят только те события, которые им нужны, только те команды, только те query, которые им нужны и каким-то образом на них реагируют.
4626.72 4639.04 "Анатолий Кулаков" Это позволяет сделать слабую связанность между роутингом самого контроллера и имплементацией, то есть бизнес-логики, имплементацией обработки того реквеста, который пришел.
4639.04 4640.88 "Анатолий Кулаков" Слабая связанность - это всегда хорошо.
4640.88 4649.92 "Анатолий Кулаков" То есть мы получаем более чистую, более предсказуемую логику, более качественное разделение и, естественно, меньше ошибок и меньше проблем, меньше каких-то вопросов.
4649.92 4654.08 "Анатолий Кулаков" Также эти хендлеры можно вводить независимо от каких-то других.
4654.08 4664.72 "Анатолий Кулаков" То есть у нас уже обработчик события изменит кастомер, апдейт кастомер и обработчик события делит кастомер, они уже никак между собой не зависят.
4664.72 4672.60 "Анатолий Кулаков" У них нет каких-то общих сервисов, которые шарит конструктор, у них нет общих полей, у них нет каких-то общих пересекающихся методов.
4672.60 4676.56 "Анатолий Кулаков" Вот все это довольно красиво разделено и друг на друга никак не влияет.
4676.56 4683.68 "Анатолий Кулаков" Это что у нас уже есть сейчас и как люди используют ISPnet, MVC в своих текущих проектах.
4683.68 4687.56 "Анатолий Кулаков" Что же мы можем сделать с помощью новых endpoints?
4687.56 4698.52 "Анатолий Кулаков" Помните, что новые endpoints позволяют нам прямо в том самом стартап-классе Minimal API замапить роутинг на какой-то реквест-делегат.
4698.52 4715.12 "Анатолий Кулаков" То есть мы можем написать map у переменной app, вызвать метод map.get, передать туда роут и передать туда вторым аргументом как раз-таки делегат, который вызовется в тот момент, когда какой-то запрос придет на этот роут.
4715.12 4731.96 "Анатолий Кулаков" Интересная особенность заключается в том, что в этот делегат мы можем задекларировать распаршенные роуты, прежде всего, которые будут вытащены непосредственно с самой строки запроса, которые будут вытащены из боди, если вдруг нам что-то нужно оттуда дистрилизовать.
4731.96 4737.48 "Анатолий Кулаков" А также мы там можем объявить те сервисы, которые нам нужны из нашего контейнер-зависимости.
4737.48 4744.72 "Анатолий Кулаков" То есть контейнер-зависимости тоже подключается к этому реквест-хендлеру и подставляет те сервисы, которые ему нужны.
4744.72 4759.08 "Анатолий Кулаков" И, соответственно, таким образом мы можем очень красиво, очень компактно, вообще не используя контроллеров, объявить метод обработки наших кастомеров прямо внутри нашего стартап-класса.
4759.08 4763.32 "Анатолий Кулаков" Естественно, никто в больших приложениях так делать не будет, потому что таких хендлеров много.
4763.32 4768.16 "Анатолий Кулаков" Стартап-класс 1 - это абсолютно неюзабельная конструкция будет.
4768.16 4776.24 "Анатолий Кулаков" Но мы можем вынести этот обработчик, опять же, внутрь наших хендлеров, которые у нас появляются при использовании медиатора.
4776.24 4781.48 "Анатолий Кулаков" То есть у нас появляется какой-то классик, например, классик про апдейт кастомера.
4781.48 4787.12 "Анатолий Кулаков" У этого классика есть хендлер, который принимает в аргументах все необходимые ему зависимости.
4787.12 4798.80 "Анатолий Кулаков" И этот хендлер мы вполне можем легко зарегистрировать в этом методе, в методе map_get, map_post, map_delete и так далее.
4798.80 4799.80 "Анатолий Кулаков" Не суть важно.
4799.80 4802.44 "Анатолий Кулаков" То есть любой роут мы можем запапить на этот метод.
4802.44 4808.88 "Анатолий Кулаков" А эти роуты, так как их очень много, естественно, мы можем разбить на модули, эти модули засунуть внутрь нашего домена.
4808.88 4816.80 "Анатолий Кулаков" То есть все, что касается кастомеров, там будет кастомер-модуль, который регистрирует у аппликейшена все роуты, касающиеся этого кастомера.
4816.80 4820.36 "Анатолий Кулаков" И перенаправляет все эти роуты на наши хендлеры.
4820.36 4822.36 "Анатолий Кулаков" Что это нам дает?
4822.36 4831.28 "Анатолий Кулаков" Прежде всего нам дает эту понятную, гибкую и уже привычную структуру, которая у нас появляется при использовании медиатора.
4831.28 4834.96 "Анатолий Кулаков" То есть у нас отдельно лежат хендлеры, у нас отдельно к ним мапятся роуты.
4834.96 4838.72 "Анатолий Кулаков" Это все вместе не связано, мы не получаем огромных грязных контроллеров.
4838.72 4843.24 "Анатолий Кулаков" Во-вторых, мы вообще избавляемся от контроллеров, их больше у нас нет.
4843.24 4847.64 "Анатолий Кулаков" Здесь получается какая-то более простая модель.
4847.64 4851.76 "Анатолий Кулаков" Мы избавляемся от сущности, которая нам абсолютно не нужна.
4851.76 4853.20 "Анатолий Кулаков" Поэтому модель упрощается.
4853.20 4864.64 "Анатолий Кулаков" А также, как показали тесты TechEmpower, JSON-бичмарка, мы очень сильно можем ускорить наше приложение, используя минимум API.
4864.64 4876.36 "Анатолий Кулаков" Потому что, если мы, например, используем контроллеры, то JSON-бичмарк тест показывал около 500 тысяч РПСов на простых запросах.
4876.36 4890.04 "Анатолий Кулаков" Если мы используем тот же самый код, но вместо контроллера мы используем endpoints, то есть мапим напрямую роут на хендлер, тот же самый бичмарк уже поднимается до 800 тысяч РПСов.
4890.04 4895.52 "Анатолий Кулаков" В общем, довольно такая ощутимая производительность, опять же, если вы вдруг случайно в это упираетесь.
4895.52 4901.84 "Анатолий Кулаков" И еще один интересный плюсик.
4901.84 4904.76 "Анатолий Кулаков" Нам не нужен теперь здесь медиатор вообще.
4904.76 4908.84 "Анатолий Кулаков" То есть этот код работает чисто на endpoints, на стандартных ASP.
4908.84 4922.12 "Анатолий Кулаков" И если вы раньше вдруг использовали медиатор только для того, чтобы взять из контроллера какой-то реквест, перемапить его и пробросить дальше к хендлерам, то здесь вы с чистой совестью можете полностью выкинуть медиатор.
4922.12 4924.32 "Анатолий Кулаков" Он вам больше ни для чего не нужен.
4924.32 4930.56 "Анатолий Кулаков" Но в принципе на самом деле в больших приложениях медиатор используется еще много чего, для чего и для куда.
4930.56 4933.60 "Анатолий Кулаков" Но это уже не тема данной статьи.
4933.60 4944.08 "Анатолий Кулаков" В принципе, если вам нужен медиатор только для этого и контроллеры нужны только для того, чтобы пробросить хендлеры дальше в бизнес-логику, вы вполне можете избавиться от большого числа лишних сущностей.
4944.08 4946.92 "Анатолий Кулаков" Вот такой интересный хак у нашего нового автора.
4946.92 4947.92 "Игорь Лабутин" Интересно.
4947.92 4956.72 "Игорь Лабутин" Как обычно, когда Microsoft придумывает какую-нибудь фичу, то всегда находится кто-нибудь, кто начнет ее использовать возможно так.
4956.72 4962.12 "Игорь Лабутин" Ну в данном случае не совсем, прям не предполагали, что ее так будут использовать.
4962.12 4970.44 "Игорь Лабутин" Я думаю, что какое-то такое использование предполагалось, но действительно интересные последствия и какие-то библиотеки действительно в определенных сценариях могут стать ненужными.
4970.44 4975.60 "Игорь Лабутин" А вот наша следующая статья, это прям совсем интересно.
4975.60 4979.24 "Игорь Лабутин" Я не думал, что когда-нибудь мы в подкасте будем рассказывать про Silverlight.
4979.24 4986.88 "Игорь Лабутин" Я на нем вообще никогда не писал, я про него только слышал, на нем что-то запускал, ну в смысле использовал какие-то продукты на нем, но сам никогда не писал.
4986.88 4995.76 "Анатолий Кулаков" То есть это как раз тот случай, когда те библиотеки, которые стали ненужными, вдруг, нечаянно начали быть нужными, спустя 10 лет.
4995.76 4996.76 "Анатолий Кулаков" Похоже на это?
4996.76 4998.24 "Игорь Лабутин" Ну типо того, наверное.
4998.24 4999.24 "Игорь Лабутин" Не знаю.
4999.24 5006.16 "Анатолий Кулаков" Ну давай объясним, в чем суть истории, потому что я не удивлюсь, если даже многие разработчики не знали никогда, что такое Silverlight.
5006.16 5012.92 "Анатолий Кулаков" Вообщем, а Silverlight это в принципе такая революционно-фундаментально мега-прорывная штука была.
5012.92 5016.68 "Анатолий Кулаков" Как минимум ее планировали такой сделать для своего времени.
5016.68 5018.16 "Анатолий Кулаков" Идея была проста, как мир.
5018.16 5021.08 "Анатолий Кулаков" Хотелось запускать .NET код прямо в браузере.
5021.08 5028.44 "Анатолий Кулаков" И не просто .NET код, а еще и с формочками, потому что раньше .NET напрямую ассоциировался очень сильно с формочками.
5028.44 5034.64 "Анатолий Кулаков" И формочки не простые были, а уже на тот момент XAML, то есть уже какой-то собрат .DF.
5034.64 5042.52 "Анатолий Кулаков" В общем мы брали практически .DF, писали бизнес-логику на C# и запускали это все в браузере.
5042.52 5044.00 "Анатолий Кулаков" Ну звучит как сказка, правда?
5044.00 5047.52 "Анатолий Кулаков" Это еще до HTML5, до всяких .VPS, или вообще до этого всего.
5047.52 5050.52 "Анатолий Кулаков" Тогда еще господствовал Flash везде абсолютно.
5050.52 5055.56 "Анатолий Кулаков" И Silverlight это был один из главных, позиционировался как один из главных конкурентов Flash.
5055.56 5060.04 "Анатолий Кулаков" Но умерли они вместе, поэтому непонятно, кто в конце концов выиграл.
5060.04 5061.04 "Анатолий Кулаков" Наверное все-таки никто.
5061.04 5066.72 "Анатолий Кулаков" Вот, мне посчастливилось немножко пописать на Silverlight и должен сказать, что ощущения были довольно приятные.
5066.72 5072.48 "Анатолий Кулаков" В принципе как от всего .DF, мне XAML очень импонирует как некий UI.
5072.48 5079.12 "Анатолий Кулаков" В общем мне кажется, что идеи, которые заложены там в XAML, они довольно крутые, довольно прорывные.
5079.12 5083.04 "Анатолий Кулаков" Особенно сравните с тем убожеством, которое есть в HTML и CSS.
5083.04 5091.52 "Анатолий Кулаков" То есть HTML - это язык, который существует многие десятилетия, у которого нет нормального лейаутинга.
5091.52 5096.04 "Анатолий Кулаков" И там каждый месяц изобретаются какие-то уродливые костыли, которые нифига не работают для лейаутинга.
5096.04 5098.92 "Анатолий Кулаков" То есть казалось бы, как можно делать UI без лейаутинга.
5098.92 5103.48 "Анатолий Кулаков" Вот, а нам Silverlight, DPF, это все приносили прямо из коробки.
5103.48 5107.00 "Анатолий Кулаков" Прекрасные лейауты, отличные контролы, прекрасная прорисовка.
5107.00 5108.68 "Анатолий Кулаков" Вот, ну естественно не без минусов.
5108.68 5112.76 "Анатолий Кулаков" Одним из главных минусов было то, что вам нужно было ставить плагин.
5112.76 5115.96 "Анатолий Кулаков" Обычно плагины к браузерам люди не очень любят.
5115.96 5119.88 "Анатолий Кулаков" Особенно такие тяжеловесные, которые там рисуют вам сложный какой-то UI.
5119.88 5122.56 "Анатолий Кулаков" Ну и много других причин.
5122.56 5127.12 "Анатолий Кулаков" В принципе, если разбираться, почему умер Silverlight, вы можете откопать огромные статьи.
5127.12 5131.84 "Анатолий Кулаков" В том числе там будут упомянуты заговоры внутри Microsoft и так далее.
5131.84 5135.56 "Анатолий Кулаков" В общем, это огромная интересная тема для обсуждений, но про неё не сейчас.
5135.56 5143.36 "Анатолий Кулаков" Сейчас нам очень важно то, что 12 октября 2021 года прекращается поддержка Silverlight.
5143.36 5146.36 "Анатолий Кулаков" Игорь, ты вот по этому поводу ты страдаешь?
5146.36 5155.28 "Игорь Лабутин" Я говорю, нет, Silverlight, есть по-моему один или два сайта во внутреннем корпоративном интернете, где явно видно, что это Silverlight.
5155.28 5162.36 "Игорь Лабутин" И вот прям туда требуется ходить интернет-экспложером ещё, потому что по-другому просто не работает.
5162.36 5166.44 "Игорь Лабутин" Но в остальном я особо не касался Silverlight.
5166.44 5178.04 "Анатолий Кулаков" Ну, я вообще удивился, что у него только сейчас кончается поддержка, потому что действительно я Silverlight не видел, не совру, если там лет, наверное, 5 точно, а может даже и все 10.
5178.04 5181.60 "Анатолий Кулаков" Ну, то есть после того, как умер Flash, в принципе о Silverlight очень быстро все забыли.
5181.60 5184.12 "Анатолий Кулаков" Но оказывается не все.
5184.12 5198.72 "Анатолий Кулаков" Оказывается существует очень много, как ты сказал уже, внутренних корпоративных порталов, внутренних корпоративных приложений, которые были сделаны 15 лет назад, они прекрасно работают до сих пор, ну, относительно, да, то есть люди счастливы, люди довольны.
5198.72 5203.92 "Анатолий Кулаков" И с ними надо что-то делать, ну, то есть их хочется поддерживать, с ними хочется дальше пользоваться.
5203.92 5205.52 "Анатолий Кулаков" Переписать их не вариант.
5205.52 5214.48 "Анатолий Кулаков" По предварительным там опросам среднее приложение, которое сейчас на работе на Silverlight требует 1 или 2 года переписки в одну из компаний.
5214.48 5216.28 "Анатолий Кулаков" Вот, а таких приложений там много.
5216.28 5221.76 "Анатолий Кулаков" Ну, то есть тратить просто 2 года впустую на то, чтобы переписать одно к одному многие компании не готовы.
5221.76 5237.28 "Анатолий Кулаков" Да, хорошо, если вы вовремя мигрировали, но нужно все-таки осознавать, что в мире существует огромное число всяких больших компаний, которые не готовы тратить просто так разработческие часы, если приложение и так работает.
5237.28 5240.00 "Анатолий Кулаков" Но, что же мы все-таки должны сделать?
5240.00 5248.20 "Анатолий Кулаков" Ну, если Microsoft заканчивает поддержку, нам бы эти приложения поддерживать нужно, то нужно пилить в наше время Open Source Fork.
5248.20 5252.00 "Анатолий Кулаков" И вот как раз-таки такая Open Source реализация появилась.
5252.00 5258.92 "Анатолий Кулаков" Наверное, даже fork сказать неправильно, потому что все-таки никаких исходников открытых для fork, мне кажется, не было.
5258.92 5261.76 "Анатолий Кулаков" Все-таки люди взяли и переписали это все с нуля, насколько я понимаю.
5261.76 5262.76 "Анатолий Кулаков" Могу ошибаться.
5262.76 5269.56 "Анатолий Кулаков" Но, к фактам, вышел проект OpenSilver, зарелизилась первая версия.
5269.56 5275.40 "Анатолий Кулаков" OpenSilver - это бесплатная, плагин-фри, Open Source, реализация Silverlight.
5275.40 5280.52 "Анатолий Кулаков" То есть теперь не нужно ставить никаких плагинов, не нужно заглядывать в закрытые сортцы.
5280.52 5288.24 "Анатолий Кулаков" Все это в GitHub прозрачно разрабатывается, поддерживается сообществом и активно развивается во все направления.
5288.24 5292.44 "Анатолий Кулаков" Прежде всего у нас есть компилятор, который преобразует XAML в C# код.
5292.44 5303.96 "Анатолий Кулаков" И с помощью такого преобразования, плюс с помощью небольшой пачки генераторов, которые управляют HTML, CSS и JS, у нас выполняется трансляция, а затем и компиляция WebAssembly.
5303.96 5312.84 "Анатолий Кулаков" И с помощью WebAssembly и Blazor для каких-то основных вещей мы получаем то, что мы всегда и хотели.
5312.84 5315.64 "Анатолий Кулаков" Это C# код, который запускается в браузере.
5315.64 5322.60 "Анатолий Кулаков" То, что у нас есть уже с Blazor, но с одним замечательным свойством.
5322.60 5325.40 "Анатолий Кулаков" Там мы можем писать UI на XAML.
5325.40 5328.56 "Анатолий Кулаков" И это прекрасно.
5328.56 5339.16 "Анатолий Кулаков" Этот подход используется во всех современных браузерах, соответственно кроссплатформенный, включая iOS, Android, то есть мобильные клиенты и также большие Windows, macOS и Linux.
5339.16 5343.48 "Анатолий Кулаков" То есть все там довольно хорошо с транскомпиляберностью.
5343.48 5347.44 "Анатолий Кулаков" Ну а почему быть плохо, потому что WebAssembly сейчас поддерживается абсолютно везде.
5347.44 5353.16 "Анатолий Кулаков" И выбрав уже эту платформу, они обрекли себя на большую кроссплатформенность.
5353.16 5360.96 "Анатолий Кулаков" Это тоже очень радует, потому что оригинальный Silverlight был только под Windows, только на E11, на последнем он работал.
5360.96 5366.04 "Анатолий Кулаков" Были какие-то попытки с помощью Moonlight перенести это на альтернативные браузеры.
5366.04 5372.60 "Анатолий Кулаков" И может быть худо-бедно как-то иногда заводилось, но опять же это не идет ни какое сравнение с WebAssembly.
5372.60 5373.60 "Анатолий Кулаков" Поэтому здесь все хорошо.
5373.60 5378.00 "Анатолий Кулаков" Как я уже и сказал, проект активно работает, там очень много разработчиков.
5378.00 5388.08 "Анатолий Кулаков" Есть даже компания, которая выделила большую команду на то, чтобы в фулл тайме, за деньги развивать этот проект.
5388.08 5392.08 "Анатолий Кулаков" Как раз это одна из тех компаний, у которой внутри было написано очень много всего на Silverlight.
5392.08 5398.64 "Анатолий Кулаков" И ей чисто коммерчески невыгодно это все переписывать, чтобы выгонить сделать свой Silverlight.
5398.64 5400.80 "Анатолий Кулаков" Основные Core компоненты уже давно перенесены.
5400.80 5407.24 "Анатолий Кулаков" То есть если у вас приложение обычное, простенькое, не использует никакие инстравагантные библиотеки, то оно вас точно заработает.
5407.24 5411.40 "Анатолий Кулаков" И также уже перенесено огромное количество сторонних библиотек.
5411.40 5417.76 "Анатолий Кулаков" Частично портирован Telerik UI, это один из самых популярных UI компонентов был для Silverlight.
5417.76 5422.28 "Анатолий Кулаков" Prism, Mev, Unity, OData, MVM Lite, Newtonsoft, JSON, .NET.
5422.28 5427.00 "Анатолий Кулаков" Все это уже транскомпилировано для OpenSilver.
5427.00 5432.28 "Анатолий Кулаков" И в принципе все приложения, которые используют эти библиотеки, тоже без проблем перенесутся.
5432.28 5436.60 "Анатолий Кулаков" Если вы захотите свой проект такой перенести, вам необходимо будет пересобрать проект.
5436.60 5439.96 "Анатолий Кулаков" То есть нужны будут и исходники.
5439.96 5441.32 "Анатолий Кулаков" Разработка активно ведется на GitHub.
5441.32 5444.68 "Анатолий Кулаков" Все pull-requests приветствуются, новые контрибьюторы тоже приветствуются.
5444.68 5447.76 "Анатолий Кулаков" Если вдруг есть у вас Legacy проекты, то добро пожаловать.
5447.76 5456.24 "Анатолий Кулаков" Добро пожаловать в новый интересный мир, когда можно воссоздать технологии Microsoft с помощью сообщества и может быть не только воссоздать, но даже в чем-то и превзойти.
5456.24 5469.00 "Анатолий Кулаков" Интересная фишка этого проекта является в том, что авторы не настаивают на том, что это чисто замена вашего Legacy устаревшего, который используется внутри ваших корпоративных систем.
5469.00 5478.20 "Анатолий Кулаков" Если посмотреть на этот проект немножко с другой стороны, то по сути мы получаем .NET приложение, которое работает под веб.
5478.20 5489.76 "Анатолий Кулаков" Любой .NET разработчик, который знаком с UI, с тем же самым .DPF, без проблем сможет программировать на XAML того подмножества, которое используется внутри OpenSilver.
5489.76 5496.20 "Анатолий Кулаков" То есть все разработчики с более-менее каким-то Desktop Experience получают уже знакомую среду.
5496.20 5499.92 "Анатолий Кулаков" То есть UI под веб на XAML, на C#.
5499.92 5503.32 "Анатолий Кулаков" Никакие знания JS, HTML, CSS абсолютно не нужны.
5503.32 5505.96 "Анатолий Кулаков" Это огромный плюс по сравнению с Blazor.
5505.96 5513.32 "Анатолий Кулаков" И вы можете использовать современные языки, такие там как C# 9, 10, .NET Framework 5, 6.
5513.32 5514.32 "Анатолий Кулаков" Все это поддерживается.
5514.32 5516.00 "Анатолий Кулаков" Вы ни в чем себя не граничиваете.
5516.00 5517.44 "Анатолий Кулаков" Современные инструменты, платформы.
5517.44 5521.48 "Анатолий Кулаков" Вы попадаете соответственно под проект, который активно разрабатывается.
5521.48 5526.68 "Анатолий Кулаков" В этот проект вливают деньги понятные компании.
5526.68 5530.16 "Анатолий Кулаков" То есть он не должен загнуться в ближайшее время.
5530.16 5534.64 "Анатолий Кулаков" Вы получаете довольно большую команду на фуллтайме, которая это все поддерживает.
5534.64 5543.68 "Анатолий Кулаков" И соответственно у вас возникает довольно-таки современная интересная альтернатива кроссплатформенного UI в браузере.
5543.68 5548.08 "Анатолий Кулаков" Поэтому может быть об OpenSilver мы еще не раз услышим.
5548.08 5555.44 "Анатолий Кулаков" Потому что он позиционирует себя теперь не только как замена Silverlight, по-моему с этой темой он уже хорошо справился.
5555.44 5562.56 "Анатолий Кулаков" Но и как новый UI-фреймворк кроссплатформенный, красивый, сочетанный на эксамбле для всех дотнет разработчиков.
5562.56 5566.32 "Анатолий Кулаков" Поэтому смотри, Игорь, может теперь уже столкнешься с новой реконвенцией Silverlight.
5566.32 5571.80 "Игорь Лабутин" Не, ну если он там такой современный, с девятым C# и все дела, то почему бы не пописать на таком?
5571.80 5574.64 "Игорь Лабутин" Вдруг это действительно простой способ теперь написать правильный UI.
5574.64 5576.64 "Анатолий Кулаков" Ну да, да, почему и нет.
5576.64 5578.84 "Анатолий Кулаков" У нас есть еще одна интересная темка.
5578.84 5587.52 "Анатолий Кулаков" Наверное слушатели, которые с нами уже давно, может быть помнят, что мы делаем не только подкасты, мы еще участвуем в куче других активностей.
5587.52 5590.20 "Анатолий Кулаков" В частности под эмблемой dotnet.ru.
5590.20 5601.04 "Анатолий Кулаков" И вот под dotnet.ru одно из направлений, в котором мы активно работаем с сообществом, это переводы классных, крутых, культовых может быть в будущем книг на русский язык.
5601.04 5605.48 "Анатолий Кулаков" Одна из таких книг в прошлом году у нас вышла для Конрада Кокоса.
5605.48 5610.24 "Анатолий Кулаков" Его замечательный труд про Garbage Collector.
5610.24 5625.08 "Анатолий Кулаков" Мы помогали адаптировать ее к русскому языку и помогали всячески рекламировать и продвигать и кажется, что эта книга отлично зашла в массы и по некоторым предварительным итогам очень нравится читателям.
5625.08 5627.52 "Анатолий Кулаков" Поэтому мы решили не останавливаться на достигнутом.
5627.52 5637.80 "Анатолий Кулаков" Мы решили еще посотрудничать в плане переводов, соответственно с издательским домом и перевели еще одну книгу.
5637.80 5647.96 "Анатолий Кулаков" Это книга Эндрю Лока, который мы очень сильно любим в нашем подкасте, очень любим его статьи, глубокие разборы, качественное описание.
5647.96 5654.84 "Анатолий Кулаков" Книга Эндрю Лока, которая называется ISP.NET Core в действии.
5654.84 5660.52 "Анатолий Кулаков" Книга вышла недавно и в принципе мы только недавно закончили русский перевод.
5660.52 5667.20 "Анатолий Кулаков" Она сейчас уже доступна к покупке и у нас есть промокод, который вы найдете в шоу-нотах.
5667.20 5673.76 "Анатолий Кулаков" Пройдя по нашей ссылке и введя промокод от .NET.RU, вы получите 25% скидку на эту книгу.
5673.76 5677.76 "Анатолий Кулаков" Можно приобрести как бумажную, так и электронную.
5677.76 5688.44 "Анатолий Кулаков" Книга замечательная, очень тщательно ISP.NET Core в ней раскрыт, прямо как Эндрю делает в своем блоге, скурпулезно, интересно.
5688.44 5696.72 "Анатолий Кулаков" Наверное, больше про это сможет рассказать Игорь, потому что он непосредственно участвовал как раз-таки в переводе, вычитке и в управлении всей этой безобразией.
5696.72 5698.00 "Анатолий Кулаков" Игорь, что ты можешь сказать про книгу?
5698.00 5701.92 "Игорь Лабутин" Ну, с книжкой Эндрю была ситуация следующая.
5701.92 5746.40 "Игорь Лабутин" Если с Конрадом мы понимали, что основная сложность в вычитке и переводе этой книги, это все-таки ее сложность, потому что не каждый день мы работаем с внутренностями гарбыч-коллектора и по большому счету мы во многом просто заново изучали тот материал, по сути читали книгу, потому что многие из нас просто не знали, что там происходит внутри гарбыч-коллектора и как это все называется, и поэтому приходилось для некоторых терминов, прям не то чтобы придумывать русские названия, но довольно-таки креативно подходить к тому, как это называется, потому что в английском они назывались довольно кратко и емко, и в русском языке было сложно найти подходящую аналогию.
5746.40 5792.24 "Игорь Лабутин" С книжкой Эндрю ситуация немножко другая, то есть она действительно очень хороша в том, что она последовательно проводит вас по всем этапам создания обычного классического, так скажем, веб-приложения с использованием S Pen and Core, контроллеров, рейзера, есть отдельная глава, посвященная API-эндпоинтам, то есть Эндрю на самом деле довольно подробно рассматривает все более детально, детально, детально, как построить такое приложение, а потом третья часть книжки полностью посвящена, скажем так, различным аспектам, которые, ну не привязаны прямо к этому сквозному примеру, но на довольно понятных, хороших примерах разбирают другие полезные вещи, типа там доступа к базе, авторизации, аутентификации, логирования и всяким таким вещам.
5792.24 5808.64 "Игорь Лабутин" То есть в принципе эту книжку можно рекомендовать и тем, кто хочет писать прямо вот непосредственно веб-приложение, так и вообще говоря, кто хоть как-то трогает ASP, будь то API-эндпойнт, даже если вам не нужен рейзер, книжка там на три четверти все равно остается полезной.
5808.64 5813.96 "Игорь Лабутин" Но с этим, в этом точнее, крылась и сложность.
5813.96 5828.72 "Игорь Лабутин" Дело в том, что ASP.NET Core и вообще веб-приложение это, понятно, очень популярная тема, и она настолько популярна, что она довольно прочно вошла в нашу русско-англоязычную жизнь с уже определенными терминами.
5828.72 5844.96 "Игорь Лабутин" Мы не задумываясь говорим middleware, мы не задумываясь там говорим какие-нибудь там endpoints и всякие такие вещи, то есть вполне себе английские слова, но которые как бы все разработчики более-менее понимают, даже если они не знают, может быть, английский.
5844.96 5853.08 "Игорь Лабутин" К сожалению, по там разным причинам не всегда получаются ровно такие термины, англицизм используется в переводе, это все-таки перевод.
5853.08 5864.88 "Игорь Лабутин" И это большая проблема, потому что говорим мы на таком смеси русского и английского, а кто-то говорит вообще практически только на английском на работе, но в книжке нужно выражаться по-русски.
5864.88 5875.48 "Игорь Лабутин" И вот выразить свои мысли и помнить, что middleware это не middleware, а программное обеспечение промежуточной точки, нет, промежуточное программное обеспечение.
5875.48 5877.40 "Игорь Лабутин" Вот, endpoint это конечная точка.
5877.40 5880.28 "Игорь Лабутин" Вроде бы очевидный перевод, но никто же не называет его конечной точкой.
5880.28 5910.44 "Игорь Лабутин" Это вот самая такая большая сложность, помнить все это аккуратно, не забывать и подбирать правильные переводы, чтобы с одной стороны все это все еще звучало нормально и понятно всем программистам, даже если они используют английский в своей жизни и в работе, а с другой стороны позволяло использованием русскоязычных терминов пойти в Google или там Яндекс и все-таки найти что-то полезное по этому запросу и релевантное, а не попасть на какой-то странный автоперевод в стиле Алиэкспресса.
5910.44 5913.84 "Анатолий Кулаков" Да, действительно, задача стояла отнюдь непростая.
5913.84 5928.80 "Анатолий Кулаков" Вот, если вдруг среди наших слушателей найдутся люди, которые родили за русский язык, хотят как-то поучаствовать в такой движухе, то мы всегда открыты к новым переводчикам, к новым вычитывальщикам, просто к новым филологам.
5928.80 5935.88 "Анатолий Кулаков" Здесь необязательно иногда быть погруженным в тему, главное просто хотеть позаниматься и посмотреть, как это все выглядит.
5935.88 5941.24 "Анатолий Кулаков" Присоединяйтесь к нашему дружному чатику в Телеграммчике, все ссылки вы найдете в наших шоу-нотах.
5941.24 5964.52 "Анатолий Кулаков" А всем тем, кто просто хочет узнать про ISP.NET Core, как-то систематизировать свои знания или может быть изучить с нуля, книга крайне рекомендуется, автор проверенный уже много лет и мне кажется, что это сейчас наиболее авторитетный и наиболее сведущий, прошаренный автор по ISP.NET Core, который у нас сейчас есть в современности.
5964.52 5967.64 "Анатолий Кулаков" По крайней мере, я не могу назвать того, кто бы составил ему конкуренцию.
5967.64 5971.84 "Анатолий Кулаков" Ну, безусловно, кроме команды Microsoft, которая все это сама разрабатывала.
5971.84 5974.84 "Игорь Лабутин" Ну, а на этой замечательной ноте, я думаю, что мы будем двигаться к концу.
5974.84 5976.92 "Игорь Лабутин" Давайте вспомним, о чем мы поговорили.
5976.92 5985.56 "Игорь Лабутин" Это был обзор новинок Entity Framework Core 6.0 за прошедший год, что нас ждет в релизе по сравнению с пятым EF Core.
5985.56 6001.84 "Игорь Лабутин" Посмотрели на то, как мигрировать на DotNet 6 новые, значит, minimal APIs и что делать, если вы используете minimal APIs, но хотите получить хоть какой-то кусочек практики, в смысле кода, как это было раньше.
6001.84 6015.36 "Игорь Лабутин" Посмотрели на сурс-генераторы для логинка, которые заедут в 6.0 DotNet и позволят использовать более полноценные логеры и более оптимально, что ли, если для вас важен перформанс.
6015.36 6031.92 "Игорь Лабутин" Заглянули в DateOnly и TimeOnly типа и посмотрели, как же можно эти самые minimal APIs заиспользовать вместо контроллеров и тем самым, возможно, упростить код и отказаться от библиотеки Mediator.
6031.92 6049.84 "Игорь Лабутин" Посмотрели на OpenSilver, реинкарнацию Silverlight, ну и, опять же, пообсуждали, что происходит в мире DotNet и DotNet Foundation с точки зрения всяких перипетий и драм, которые там происходят из-за лишения Microsoft или каких-то других событий, которые как-то влияют на комьюнити.
6049.84 6054.96 "Анатолий Кулаков" Да, мне показалось, довольно такой насыщенный и большой интересный выпуск получился.
6054.96 6057.04 "Анатолий Кулаков" Давайте поможем ему продвинуться, друзья.
6057.04 6061.36 "Анатолий Кулаков" Разыграем-ка мы еще три лицензии от JetBrains на любой их продукт.
6061.36 6063.52 "Анатолий Кулаков" Итак, кратко напомню условия.
6063.52 6071.44 "Анатолий Кулаков" Одну лицензию получит автор из того списка, который расшарит этот пост в ВКонтакте в нашей группе DotNet.ru.
6071.44 6079.88 "Анатолий Кулаков" Один автор получит из того списка, который ретвитнит этот анонс этого подкаста в Twitter группе DotNet.ru.
6079.88 6093.88 "Анатолий Кулаков" И автор, один автор получит из YouTube, те, кто оставит свой комментарий верхнего уровня под этим выпуском в нашем YouTube-канале DotNet.ru под выпуском этого подкаста.
6093.88 6099.28 "Анатолий Кулаков" В принципе, неважно, что вы напишете, нам просто интересно собрать какую-то народную статистику.
6099.28 6107.08 "Анатолий Кулаков" Напишите нам, откуда вы слушаете, когда вы слушаете этот подкаст, что вам нравится, что не нравится, откуда вы это делаете.
6107.08 6113.92 "Анатолий Кулаков" В общем, абсолютно все нам интересно о наших слушателях, что мы, в принципе, никак не можем получить другим способом.
6113.92 6122.64 "Анатолий Кулаков" Поэтому оставляйте свой фидбэк, ставьте колокольчики, подписывайтесь на пальчики вверх и прочее, что там нужно сделать.
6122.64 6136.96 "Анатолий Кулаков" Поможем этому выпуску очутиться ближе к остальным людям, которые никогда про него не услышали и, может быть, благодаря вам подпишутся на наше радио и будут в курсе всех самых интересных новостей и статей из мира ДотНета.
6136.96 6139.56 "Игорь Лабутин" Супер, а на этом будем прощаться.
6139.56 6141.20 "Игорь Лабутин" Это был 39-й выпуск Радио.нет.
6141.20 6144.60 "Игорь Лабутин" С вами были Игорь Лабутин и Анатолий Кулаков.
6144.60 6145.60 "Анатолий Кулаков" Всем пока.
6145.60 6146.10 "Анатолий Кулаков" Пока.
