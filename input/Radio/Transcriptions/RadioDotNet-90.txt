0.00 10.88 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио Тотнет, выпуск номер 90.
10.88 14.32 "Анатолий Кулаков" И сегодня, как всегда, в студии Анатолий Кулаков.
14.32 17.00 "Игорь Лабутин" И Игорь Лабутин, всем привет.
17.00 21.48 "Анатолий Кулаков" А также большое спасибо за помощь нашим постоянным помогаторам.
21.48 32.12 "Анатолий Кулаков" Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин и Сергей Краснов.
32.12 33.12 "Анатолий Кулаков" Спасибо, друзья.
33.12 34.64 "Анатолий Кулаков" Спасибо всем, кто нам помогает.
34.64 41.04 "Анатолий Кулаков" Если вы хотите присоединиться к этой бравой компании, заходите на наш сайт на Boosty и посмотрите, что там у нас интересненько творится.
41.04 44.08 "Анатолий Кулаков" Так, вроде все, да?
44.08 46.80 "Анатолий Кулаков" А каких-то официальных объявлений у нас больше нет?
46.80 47.80 "Анатолий Кулаков" Пойдем сразу к темам?
47.80 48.80 "Игорь Лабутин" Да, пошли к темам.
48.80 54.32 "Игорь Лабутин" Тем более их у нас сегодня есть, у нас прям сегодня плотненький выпуск, но почти без новостей от Майкрософт.
54.32 63.56 "Анатолий Кулаков" Ну да, Майкрософт как-то, ну, по крайней мере, команда C# совсем не работает, или что они там делают, это вообще пока непонятно, может, готовят нам какой-то большой сюрпризик.
63.56 66.20 "Анатолий Кулаков" Но немножко какие-то ошмётки от Майкрософта достаются.
66.20 71.76 "Анатолий Кулаков" Я думаю, что самой большой новостью прошедших недель – это был релиз Гарнета.
71.76 76.88 "Анатолий Кулаков" Если вы упустили, то как раз мы сейчас вам и расскажем, что же за чудо такое.
76.88 85.08 "Игорь Лабутин" В общем, Майкрософт… А вот, подождите, мы начнем рассказывать, это прям релиз-релиз, или это какое-то там превью-непревью, в каком оно сейчас состоянии?
85.08 92.00 "Анатолий Кулаков" Слушай, а вот это вот хорошее какое-то замечание, у них нигде, по крайней мере, нету, что это бета-превью или что-то такое.
92.00 94.96 "Анатолий Кулаков" Знаешь, когда обычно выпускают, они пишут это практически в каждой строчке.
94.96 95.96 "Анатолий Кулаков" Ага.
95.96 98.36 "Анатолий Кулаков" Здесь просто называют Гарнет, типа, high performance и всё такое.
98.36 100.92 "Игорь Лабутин" Ну просто выложили какую-то штуку в каком-то состоянии.
100.92 105.20 "Игорь Лабутин" Ну я видел, даже у них там есть какой-то roadmap, ну, видимо, да.
105.20 107.28 "Игорь Лабутин" То есть пока непонятное состояние, окей.
107.28 109.84 "Игорь Лабутин" Ну ладно, давай расскажем, что же это такое.
109.84 116.64 "Анатолий Кулаков" Ну смотри, по крайней мере, версия у него 1.0.2, т.е. как бы намекает, что версия 1.0, значит, может быть уже какой-то релиз.
116.64 117.64 "Анатолий Кулаков" Production-ready.
117.64 121.92 "Анатолий Кулаков" Ну уже production-ready, да хотя бы там не 0.587.
121.92 124.16 "Анатолий Кулаков" Для тех, кто не в курсе-то, давай объясним.
124.16 129.84 "Анатолий Кулаков" Гарнет, Microsoft выложила новое приложение, можно назвать это так, в open-source, на GitHub, всё как положено.
129.84 140.02 "Анатолий Кулаков" И это Remote Cache Store, ну т.е. по сути, обычный Remote Cache, который вам, скорее всего, знаком, если вы сталкивались с Redis, или Memcached, или вот что-нибудь такое.
140.02 148.56 "Анатолий Кулаков" Т.е. обычный, примитивный KVL-U-Cache, ну не то, чтобы совсем примитивный, но с той функциональностью, которую вы ожидаете от Redis.
148.56 150.60 "Анатолий Кулаков" Что интересно в этом продукте?
150.60 157.00 "Анатолий Кулаков" Прежде всего то, что он вышел из Microsoft Research, ну есть надежда, там сидят какие-то умные парни, которые чего-то там хорошего написали.
157.00 168.00 "Анатолий Кулаков" Также он был сосредоточен на high-performance, безусловно, т.е. как на том, чтобы выдавать очень большой author-опыт, так и на том, чтобы выдавать очень маленькое latency.
168.00 170.12 "Анатолий Кулаков" Мне кажется, что всё это им удалось.
170.12 178.32 "Анатолий Кулаков" Прежде всего, это масштабируемый продукт, т.е. можно поставить его в нескольких инстанциях, он там будет сам подниматься, сам опускаться.
178.32 188.08 "Анатолий Кулаков" У него есть хороший persistence, т.е. все данные можно держать не только в памяти, но и скидывать на диск, если вам почему-то еще нужен персистентный кэш.
188.08 196.32 "Анатолий Кулаков" Хорошая стратегия восстановления от сбоев, поддерживается кластер Sharding, т.е. вы можете разложить все ваши данные на шарды.
196.32 200.56 "Анатолий Кулаков" Есть специальная функциональность для миграции ключей, т.е.
200.56 204.76 "Анатолий Кулаков" можно делать какие-то сложные схемы и при этом мигрировать все ваши кэши почему-то куда-то.
204.76 208.20 "Анатолий Кулаков" Есть репликация, куда же без этого.
208.20 219.92 "Анатолий Кулаков" Ну и, наверное, самая такая забавная, занимательная фича – это в том, что он построен внешне, наружу выдаёт протокол редиса, т.е. все существующие редис-клиенты смогут работать с гарнетом.
219.92 231.64 "Игорь Лабутин" Я так понимаю, что это, на самом деле, довольно популярная фича среди таких альтернатив редису, т.е. и тот же Dragonfly, KDB, насколько я помню, тоже поддерживает редис-лайк протокол.
231.64 243.28 "Анатолий Кулаков" Да, это прямо открытый протокол, при том, что самое, что интересно, это протокол очень простой, т.е. реализовать его никакого сложности нет, ну и плюс редис – это самый популярный кэш.
243.28 250.20 "Анатолий Кулаков" Поэтому если вы почему-то делаете кэш, то реализовать редисовский протокол – это первое, что должно вам прийти на ум.
250.20 262.72 "Анатолий Кулаков" Потому что автоматически, опять же, вы поддерживаетесь всеми клиентами, которые есть, вас можно, например, заменить очень безболезненно уже в существующих продуктах и попробовать, как минимум, посмотреть, насколько вы действительно составляете конкуренцию.
262.72 265.24 "Анатолий Кулаков" Поэтому все редис-клиенты подходят и для гарнета.
265.24 273.44 "Анатолий Кулаков" Еще из интересного – он базируется на еще одном проекте из Microsoft Research, который называется FASTER.
273.44 284.44 "Анатолий Кулаков" Это быстрое, опять же, персистентное, т.е. какое-то хранилище кей-вэлью значений с поддержкой рековери-лога.
284.44 287.92 "Анатолий Кулаков" И, по-моему, гиперлог-лог – это тоже у него от FASTER пронаследовалось.
287.92 294.16 "Анатолий Кулаков" И все это на C#, т.е. это такое кей-вэлью хранилище на C#, очень быстрое, очень оптимизированное и все такое.
294.16 296.08 "Анатолий Кулаков" И на основании его вот уже сделан гарнет.
296.08 300.12 "Анатолий Кулаков" В общем, Toolzane очень мощная, по крайней мере, для первого релиза.
300.12 304.04 "Анатолий Кулаков" Прям и кластеры, и шардинги, и рековери, и персистентность, и хай-перформанс.
304.04 308.20 "Анатолий Кулаков" Короче, напихали туда много всего, т.е. кажется, что люди ее готовили.
308.20 313.80 "Анатолий Кулаков" Ну, более того, есть, в отличие от остального Microsoft Research, более-менее вменяемая документация, такой сайтик, документация.
313.80 320.48 "Анатолий Кулаков" Т.е. кажется, что это не просто проект, который выложен на «посмотрите, как я могу», а может быть, даже который будет сопровождаться.
320.48 348.64 "Анатолий Кулаков" В roadmap'ах также много всего интересного, ну и в частности хотелось бы видеть это in-process-embedded режим, т.е. когда вы можете не поднимать свой отдельный какой-то сервер там где-то далеко в кубере, в докере, а просто в текущее приложение встроить себе кэш, может быть, даже в несколько своих инстансов, чтобы этот кэш автоматически синхронизировался между разными инстансами, и таким образом вы получите какой-то вот самоподдерживаемый кэш с автоудалением и все такое.
348.64 349.64 "Анатолий Кулаков" В общем, тоже звучит довольно интересно.
349.64 369.44 "Анатолий Кулаков" Также и хотят сделать extension, т.е. сделать хуки, и на эти хуки можно будет повесить различные языки, различные языки программирования, т.е. функции на различных языках программирования, для того, чтобы через хуки можно было бы какую-то расширябельность сделать, например, какую-то свою собственную логику шифрования, преобразования, трансформации, оптимизации и прочего-прочего.
369.44 379.96 "Анатолий Кулаков" Также хотят сделать текстовый поиск, т.е. индекс по текстовому поиску, векторный поиск и поддержку джессонов в каком-то где-то месте.
379.96 383.72 "Анатолий Кулаков" Сейчас там все на dictionary, насколько я помню, где сделано, но вот хотят джессонов тоже.
383.72 385.72 "Анатолий Кулаков" В общем, перспективы тоже хорошие.
385.72 391.00 "Анатолий Кулаков" Ну и самое главное, зачем же нам сделать еще один Redis, ну ради перформанса, безусловно.
391.00 394.48 "Анатолий Кулаков" Бичмарки тоже есть, бичмарки вроде все открытые, вроде даже правдивые.
394.48 401.20 "Анатолий Кулаков" В бичмарках сравнивали Garnetas, прежде всего, с Redis, с KDB и с Dragonfly.
401.20 414.96 "Анатолий Кулаков" Все эти друзья поддерживают Redis протокол, поэтому были одни и те же данные, один и тот же протокол, и там кажется, что вопросов не должно никакие быть, все их проверяли на одних и тех же данных.
414.96 422.24 "Анатолий Кулаков" Проверяли throw, latency, в том числе, большие какие-то сложные структуры данных загоняли, а не просто какую-то одну строчечку.
422.24 433.40 "Анатолий Кулаков" В общем, мучили со всех сторон, подробные графики вы увидите на сайте, но когда я первый раз зашел, я, в принципе, офигел, потому что Garnet был в два раза больше Redis.
433.40 448.88 "Анатолий Кулаков" А потом я присмотрелся и понял, что это логарифмическая шкала, поэтому на самом деле Garnet в 100 раз больше Redis, т.е. лучше Redis практически по всем показателям, и по пропускной способности, и latency у него ниже, и все в этом духе, т.е. звучит просто как сказка какая-то.
448.88 492.80 "Анатолий Кулаков" Как они этого добились, притом на чистом C# было, в принципе, непонятно, поэтому я полез внутрь и немножко как-то мой оптимизм сошел на нет, и в частности Евгений Пешков, знаменитый наш эксперт по перформансу в своем блоге, кстати, если вы еще не подписаны, то советуем, в своем блоге тоже заметил этот проект и пошел разбираться, что там внутри творится, и, к сожалению, внутри там не все так радужно, как снаружи, т.е. я там надеялся на последний C#, последние его новинки, достижения и все такое, векторизацию, может быть, там еще какие-то хаки, при том, что они через каждый абзац приговаривают, что мы латест, ленгвич, C#, агностик, проект, в общем, все вот эти фишки.
492.80 495.56 "Анатолий Кулаков" Но на самом деле, ну, действительно, они там используют последний
495.56 496.56 "Игорь Лабутин" C#.
496.56 499.20 "Игорь Лабутин" Мне кажется, что хаков ты там как раз нашел.
499.20 547.92 "Анатолий Кулаков" Хаков я там слишком много нашел, потому что, когда смотришь на исходный код, там существует очень много unsafe кода, там даже написан custom manager нативной памяти, для того, чтобы не пользоваться стандартным C# ГЦ, и видно, что код писался ради перформанса, т.е. там жесткие хаки, unsafe код, в общем, перформанс со всех сторон, разные оптимизации, работа там напрямую с указателями, и на самом деле, несмотря на их рекламки, все это можно назвать как полное игнорирование возможности современного .NET, потому что на самом деле современный .NET, особенно если мы возьмем рантайм и оптимизация рантайма, он очень умный, т.е. он видит ваши стандартные куски кода, которые вы пишете, и может их очень грамотно оптимизировать.
547.92 570.14 "Анатолий Кулаков" Мои наблюдения подтвердил Егор Богатов, это как раз разработчик, который сейчас работает в команде рантайма, и он сказал, что да, действительно, если посмотреть, то кажется, что если бы они переписали этот код в идиоматичный C#, то код был бы намного быстрее, чем тот, который они пытаются байтиками и указателями управлять самостоятельно.
570.14 574.76 "Анатолий Кулаков" И также они там нашли несколько даже ГЦ-холл багов, т.е.
574.76 582.16 "Анатолий Кулаков" это когда в программе образуется ссылка на объект, который уже был собран гарбеж-коллектором или перемещен в какое-нибудь другое место.
582.16 593.36 "Анатолий Кулаков" В общем, т.е. даже такие баги есть как раз из-за того, что они игнорируют все достижения современного дотнета, а пытаются вручную выжимать последние байтики из того, что имеют.
593.36 621.20 "Игорь Лабутин" Ну и надо сказать, что такие баги, они почему проблемные, потому что если у вас такое есть в программе, оно может стрелять внезапно, и оно будет не просто обычным каким-нибудь красивым дотнет эксепшеном, про то, что вот у вас тут налпойнтер или что-нибудь в подобном духе, а у вас будет, скорее всего, самый натуральный нативный access violation эксепшен с каким-то непонятным доступом к непонятной памяти, которой фиг отладишь.
621.20 628.36 "Анатолий Кулаков" Да, ну я думаю, что эти вещи они должны в ближайшее время пофиксить, по крайней мере, те, которые знают.
628.36 662.52 "Анатолий Кулаков" И все-таки есть большая надежда, что они немножко попробуют довериться рентайму и уберут некоторые из своих костылей в пользу как раз-таки нативного современного C#, и где мы с честной совестью сможем доказать, что современный C# способен выжимать такие же реальные цифры, как и Unsave C#, но в принципе, знаешь, как просто посмотреть на проект, который, с одной стороны, умеет выжимать огромный перформанс даже быстрее, чем плюсы, по-моему, в редис там или на сях, или на плюсах же он написан, а нет, наоборот, DragonFly – это как раз переписка многопоточности на C.
662.52 670.28 "Анатолий Кулаков" Вот, и способен выжимать не хуже, а даже в сто раз лучше, естественно, он обгоняет всех DragonFly в том числе.
670.28 692.56 "Анатолий Кулаков" В общем, это интересный такой прецедент, ну и плюс интересный прецедент, что действительно Микрософт выпустил нормальный продукт, потому что в нашей инфраструктуре, если мы возьмем вот дотнетную инфраструктуру, то у нас огромная проблема со всякими базами данных, с CRM, конвертерами, редакторами, короче, любыми инструментами, которые пользуются конечные потребители, конечные пользователи, если не про программистов говорить.
692.56 694.84 "Анатолий Кулаков" В общем, с дотнетом здесь большая проблема.
694.84 707.92 "Анатолий Кулаков" Ну и вот это приложение, оно более или менее ближе… Не сказать, что к конечным пользователям, конечно, но хотя бы хоть что-то, чтобы показать, что на дотнете можно писать продукты, хорошие, быстрые, удобные продукты.
707.92 714.56 "Игорь Лабутин" Ну хотя там, да, дотнет пока там еще не совсем прям стандартный-стандартный, но посмотрим, действительно, может быть, приведут к чему-то хорошему.
714.56 722.32 "Анатолий Кулаков" В общем, будем всячески следить, интересный проект, посмотрим, надеюсь, что он взлетит, получит хорошую adoption и, может быть, разойдется по рынку.
722.32 746.88 "Игорь Лабутин" Да, посмотрим, тем более, что Redis, если вы вдруг не в курсе, поменял лицензию, он теперь dual-license, это так, сбоку немножко новость, и если вы предоставляете Redis как SaaS, то вам теперь нужно платить денег, вот, поэтому всякие как раз форки и клоуны Redis вполне могут расцвести, но… А тут надо опять же упомянуть, здесь мит-лицензия.
746.88 747.88 "Игорь Лабутин" Все хорошо.
747.88 748.88 "Игорь Лабутин" Все прекрасно.
748.88 753.60 "Игорь Лабутин" Пока, по крайней мере, у Redis тоже была хорошая лицензия до определенного момента.
753.60 754.60 "Игорь Лабутин" Наверное, пока, да?
754.60 755.60 "Игорь Лабутин" Да.
755.60 756.60 "Игорь Лабутин" Ну, ладно, посмотрим.
756.60 757.60 "Игорь Лабутин" Пойдем дальше.
757.60 767.84 "Игорь Лабутин" Дальше у нас статеечка от Andrew Locke, даже не одна статеечка, серия из трех статей, внезапно про структуру данных.
767.84 791.12 "Игорь Лабутин" Мы довольно давно, если вообще когда-либо погружались в какие-то описания структур данных, деталей вот этого всего, наверное, когда-нибудь это было в подкасте, а здесь прям конкретная статья про структуру данных под названием heap, а если быть более точным, min-heap, а если быть еще более точным, то на основе этого самого min-heap обычно строят очереди приоритетов priority_queue.
791.12 809.12 "Игорь Лабутин" И разговор этот весь пошел потому, что в девятом дотнете у нас обновился класс дотнета под названием priority_queue, в нем появилось некоторое количество новых фич, и Andrew плавненько тремя статьями подводит, вообще говоря, зачем это все, и сдалось, и почему это появилось именно в девятом дотнете.
809.12 816.04 "Игорь Лабутин" Точнее, почему это появилось в дотнете наконец-таки, а не именно в девятом, в девятом, потому что руки дошли, очевидно, только сейчас.
816.04 818.08 "Игорь Лабутин" Итак, начнем с самого начала.
818.08 819.76 "Игорь Лабутин" Во-первых, что такое heap?
819.76 840.76 "Игорь Лабутин" Ну, heap это мы знаем, что это manage_heap, в дотнете слово heap мы произносим, наверное, почти каждый подкаст, но в данном случае heap это не совсем тот же самый manage_heap, это, как я сказал, обычно подразумевается либо min_heap, либо max_heap, это некоторая структура данных, обычно в виде дерева, которая обладает, которое дерево обладает одним, в общем-то, свойством.
840.76 847.76 "Игорь Лабутин" В данном случае min_heap, это значит, что в каком-то узле значение этого узла меньше, чем значение любого из детей, все, собственно.
847.76 853.16 "Игорь Лабутин" То есть это значит, что корень у вас - это минимальное число, а листья - это там где-то, видимо, максимальный плюс-минус.
853.16 864.40 "Игорь Лабутин" Причем между собой дети одного, одной вершины никак не связаны никаким отношением, главное, чтобы все дети были больше, чем родители, вот и все.
864.40 881.24 "Игорь Лабутин" При этом надо понимать, что хоть это и дерево, обычно оно все равно реализуется в виде массива, и в конце, собственно, первой статьи Эндрю задается простым вопросом, ну как бы это все, конечно, здорово, такая теория, все дела, ну а нафига, то есть нам-то какое до этого дело.
881.24 888.48 "Игорь Лабутин" А дело нам до этого, что именно на основе этой структуры данных обычно реализуется штука под названием priority queue, то есть очередь с приоритетами.
888.48 905.84 "Игорь Лабутин" Нормальная очередь, как я напомню, это FIFO - first in, first out, то есть кого первому положили в очередь, тот первым будет из очереди доставаться, а вот приорити нет, вместе с элементами, которые вы кладете в очередь, вы кладете некоторую чиселку приоритета, ну чиселку либо какую-то другую сущность, которую можно друг с другом сравнить.
905.84 911.92 "Игорь Лабутин" И достаете вы в порядке приоритета, например, самые маленькие идут первыми.
911.92 941.16 "Игорь Лабутин" В дотнете долгое время не было такого типа, ну наверняка были какие-нибудь сторонние библиотеки, которые это реализовывали, но начиная с шестого дотнета появился встроенный тип под названием priority queue, и он как раз использует внутри этот самый min heap, который сделан на основе массива, причем в данном случае массив, в смысле дерево, ну логическое дерево, на основе которого это сделано имеет 4 ребенка, то есть у каждой вершины 4 ребенка.
941.16 971.20 "Игорь Лабутин" 4 было выбрано не случайно, потому что с одной стороны это позволяет держать массив достаточно компактным, а с другой стороны 2 это мало с точки зрения оптимальности доступа к памяти, вы слишком часто бегаете туда-сюда, а 4 это такое плюс-минус похоже на оптимальное число, по мнению по крайней мере разработчиков дотнета нашей библиотеки стандартной, с точки зрения оптимальности использования кэшей.
971.20 985.88 "Игорь Лабутин" В очереди есть, она типизирована двумя типами, это priority, это собственно приоритет, над которым все сверхи сравнения делаются, ну и the-элемент, это понятно, что просто элемент, который там лежит, что угодно.
985.88 988.52 "Игорь Лабутин" Какие бывают операции над очередью?
988.52 1022.16 "Игорь Лабутин" Самая первая и самая простая операция это, даже это не над очередью, это внутри очереди, во-первых, когда все это разложено в массиве, вы можете подумать, что какая-то сложная логика со следующими индексами, с предыдущими индексами, но нет, если у нас d, чиселка d это на самом деле количество детей у элемента, то найти родителя у задного ребенка легко, надо из индекса ребенка вычесть единичку и все это поделить на d целочисленный, получишь индекс родителя, а найти первого ребенка у задного родителя надо просто умножить индекс на d и добавить единичку.
1022.16 1032.08 "Игорь Лабутин" Вообще простейшая математика, элементарно можно бегать по массиву из детей к родителям и обратно, так что тут все как бы просто и легко.
1032.08 1036.12 "Игорь Лабутин" Самая простая операция над очередью это найти дерево.
1036.12 1041.36 "Игорь Лабутин" Она очевидно элементарная, она всегда от единицы сложность, потому что это всегда первый элемент массива.
1041.36 1045.44 "Игорь Лабутин" По определению дерева самый маленький элемент всегда лежит в корне.
1045.44 1051.80 "Игорь Лабутин" А вот если мы хотим его удалить, то есть например вытащить его из очереди, то нужно дерево перебалансировать.
1051.80 1066.28 "Игорь Лабутин" Наверное из какой-нибудь, если кто-то изучал всякую алгоритму и прочее, балансировки дерева, обычно это самое сложное, то самое кручение деревьев, покрутить туда, покрутить сюда, чтобы все это ребалансировать.
1066.28 1079.80 "Игорь Лабутин" В случае с вот этим мин-деревом, поскольку нету никаких соотношений, взаимоотношений между детьми одного родителя, на них не определяется никакая очередность, то перебалансировка делается довольно просто.
1079.80 1107.36 "Игорь Лабутин" То есть если мы убрали корень дерева, мы берем самый последний элемент в этом дереве, кидаем его как будто бы в корень виртуально и дальше начинаем аккуратно спускать его по дереву в какого-нибудь из детей, точнее выбирая самого маленького из детей, дитё помещаем наверх, соответственно большой элемент идёт вниз, ну и так далее, потихонечку его спускаем вниз до момента пока он не достигнет, собственно, дна, ну или того места где он должен быть.
1107.36 1108.36 "Игорь Лабутин" Вот.
1108.36 1113.16 "Игорь Лабутин" Операция в среднем можно посчитать будет от log n.
1113.16 1128.08 "Игорь Лабутин" Если мы добавляем элемент в очередь, в принципе делается то же самое, только делается наоборот, мы добавляем его в конец и потом таким же более-менее способом, обмениваясь родителем, передвигаем нужное место в дереве, тоже log n.
1128.08 1136.84 "Игорь Лабутин" На основе этого всего, это всё, конечно, хорошо, это всё прекрасно, и наконец-таки в третьей статье Эндрю приводит, собственно, непосредственно практический пример, нафига это нужно.
1136.84 1145.60 "Игорь Лабутин" А это нужно, например, для алгоритма Дейкстра, если кто-то помнит, как он работает, это здорово, значит это вообще про что?
1145.60 1158.28 "Игорь Лабутин" Это про поиск кратчайшего пути в графе между вершинами зная веса рёбер, и он, единственное, что требует, он требует уметь обновлять приоритет у элемента в очереди, т.е.
1158.28 1182.48 "Игорь Лабутин" мы закидываем что-то в очередь, мы всегда берём в алгоритм Дейкстра самый первый, самый маленький элемент, но мы пока его обсчитываем, у нас могут поменяться веса других элементов в очереди, и для того чтобы правильно он работал, этот алгоритм, нам нужно внутри очереди приоритетов, уже положенных туда элементов уметь обновлять приоритет, и вот до девятого дотнета такой операции не было, невозможно было так сделать.
1182.48 1197.80 "Игорь Лабутин" Более того, невозможно было сделать даже никакой workaround, потому что единственная операция, по сути, которую можно было сделать с очередью, с точки зрения забирания оттуда элементов, это забрать самый первый, ну как у любой очереди, с очереди вообще тяжело забирать из середины.
1197.80 1223.06 "Игорь Лабутин" И вот в девятом дотнете подумали и решили, что делать операцию update приоритета, которую в принципе можно было бы сделать за логарифм от времени, они делать не будут, сложно там вот это все, но зато они сделают операцию remove, которая просто берет элемент и удаляет его из очереди, перебалансируя дерево соответственно.
1223.06 1230.50 "Игорь Лабутин" Вот и тогда для такого алгоритма типа Дейкстра можно было сделать remove и потом обратно положить элемент в очередь, но уже с новым приоритетом.
1230.50 1243.06 "Игорь Лабутин" Проблема в том, что remove должен найти этот элемент сначала и поиск делается самым простым из возможных способов, это просто пробежаться по массиву от начала до конца и найти элемент, то есть он просто линейный.
1243.06 1250.22 "Игорь Лабутин" Ну и потом понятно, что надо удалить, перебалансировать, но там уже логарифм, поэтому линейный плюс логарифм тоже считаем все равно линейный.
1250.22 1269.86 "Игорь Лабутин" И соответственно после этого уже можно реализовать Дейкстру, я пожалуй сейчас не буду рассказывать как работает Дейкстра, про то, что там берем вершинку, находим все расстояния, закидываем все расстояния до соседних в очередь, берем минимальную вершинку с ближайшим, посчитываем для нее, пересчитываем остальные расстояния, вот это все.
1269.86 1285.10 "Игорь Лабутин" То есть можно посмотреть в статью Andrew Locke, там красивые картинки, все это визуализировано, он попытался даже показать как будут вести себя это дерево, ну в смысле очередь, с приоритетами по мере продвижения на примере значит определенных городов и расстояний между ними.
1285.10 1300.94 "Игорь Лабутин" Так что если вы хотите погрузиться, так сказать, в такой немножко компьютер-сайенс, да, алгоритмы, вот это все, структура данных, очень рекомендую эту серию статей, вполне себе, прекрасно описывает, причем не скучно и с применением к современному дотнету.
1300.94 1301.94 "Игорь Лабутин" Прям приятно.
1301.94 1312.46 "Анатолий Кулаков" Да, мне даже понравились статьи тем, что визуально красиво и хорошим языком описано, поэтому если кто-то давно интересовался или хочет в память поднять, Andrew Locke как всегда прекрасен.
1312.46 1324.22 "Игорь Лабутин" Да, но помимо Andrew Locke у нас есть еще второй автор, у которого мы обозревали прям большую серию статей, это Джимми Богорд, и кажется пришло время второй части.
1324.22 1353.62 "Анатолий Кулаков" Да, если кто помнит, у нас была большая эпопея, это Tales from .NET Migration, это история Джимми Богорда, как он портировал большое старое Legacy приложение с 4.6 фреймворка на последнюю версию .NET Core, и мы эту эпопею начинали еще в 86 выпуске, поэтому если вдруг вам эта тема интересна, советую переслушать 86 выпуск, как раз вы найдете там эту тему.
1353.62 1359.30 "Анатолий Кулаков" А здесь как раз вторая часть, здесь мы продолжим наш рассказ о том, как же все-таки этот процесс происходит.
1359.30 1370.78 "Анатолий Кулаков" Кратко напомню, что в первой части мы рассмотрели вообще каким образом подходить к миграции Legacy проектов, какие .NET фреймворки можно выбирать, какие версии выбирать, каким образом вообще происходит этот процесс.
1370.78 1400.58 "Анатолий Кулаков" В частности, рассмотрели шаблон проектирования Ficus-душитель, у Microsoft есть хорошая большая статья про него, которая рассказывает подробно, в каких библиотеках и с какими картинками все это вы должны переносить, то есть это примерно вы создаете новое приложение, пустое, Core-приложение отдельно, ставите в него YARP, Reverse Proxy, и этот Reverse Proxy перенаправляет все ваши запросы из Core-приложения в старое приложение, в старое .NET приложение.
1400.58 1419.78 "Анатолий Кулаков" Таким образом вы можете немножко переносить логику постепенно, немножко переносить контроллеров и всяких своих классиков в Core-приложение, и при этом, если вы полностью закрыли какую-то функциональность какого-то контроллера, то на YARP просто отключаете перенаправление в старое приложение, оставляете его на .NET Core.
1419.78 1453.14 "Анатолий Кулаков" Также в прошлом выпуске мы обсудили, как это переносить, то есть как нужно выделить Shared Libraries, в которые вы будете постепенно переносить те классы, которые используются в обоих приложениях, и соответственно обсудили, как поднять вот этот пустой Empty Proxy, который пока у нас не делает ничего, но уже умеет перенаправлять запросы, и таким образом на себя замкнул весь пользовательский трафик, и при этом обеспечил полноценную функциональность через старое приложение с помощью YARP.
1453.14 1465.94 "Анатолий Кулаков" И вот сегодняшняя серия статей начинается с того, что мы наконец-то начинаем переносить код, вообще всю эту инфраструктурную подготовку мы закончили, и сегодня мы займемся нашим самым первым контроллером.
1465.94 1474.86 "Анатолий Кулаков" Эндрю решил, что необходимо переносить один контроллер за раз, чтобы как раз не нагромождать кучу ошибок, и при том, что эта функциональность обычно хорошо параллелится.
1474.86 1496.82 "Анатолий Кулаков" В прошлой серии мы обсудили, каким образом он там собрал бэклог со всеми тасками и швюзами, как он проанализировал все контроллеры, middleware, поэтому у него есть такой понятный список действий, что нужно сделать, и для первого раза он решил выбрать такой средненький контроллер, у которого обязательно будет какой-то фронтенд, и у которого минимум бизнес-логики, чтобы просто оценить, как переносятся вообще сами контроллеры.
1496.82 1510.50 "Анатолий Кулаков" И идеально на эту позицию подошел home-контроллер, у которого есть какая-то базовая вьюшка, которая отображает банальное приветствие, и из зависимости у него нет практически ничего, там буквально одна маленькая зависимость.
1510.50 1535.28 "Анатолий Кулаков" Тут стоит упомянуть, что есть такой инструмент как бутнет апгрейд ассистанс, это набор различных рефакторингов, которые помогают вам в подобном переносе, подобной миграции на новый .NET Core, и все, чем ему смог помочь этот ассистанс, это он при клике на контроллер выдавал заманчивое меню, апгрейд контроллер, как обновить контроллер.
1535.28 1558.90 "Анатолий Кулаков" Единственное, что он делал, он просто менял систем веб MVC, на Microsoft S/P/NET Core MVC, вот как бы и вся работа этого апгрейд ассистанса, т.е. совместимость между контроллерами большая, но пользы довольно мало от какой-то автоматизации, поэтому Эндрю просто-напросто брал все контроллеры и переносил их с помощью cut-and-paste, т.е.
1558.90 1572.14 "Анатолий Кулаков" просто берешь контроллер, переносишь его вот в этот шарит library, который потом можно переиспользовать между разными вот этими нашими аппликейшенами, и просто фиксишь namespace, и это все, что в принципе нужно было для того, чтобы оно заработало, чтобы сами
1572.14 1573.14 "Игорь Лабутин" контроллеры заработали.
1573.14 1579.14 "Игорь Лабутин" Давай я тебя чуть-чуть поправлю, ты его уже два раза назвал Эндрю, ну давай мы все-таки будем называть его Джимми.
1579.14 1582.74 "Анатолий Кулаков" Да, да, давайте больше не будем Джимми называть Эндрю.
1582.74 1583.74 "Анатолий Кулаков" Действительно, да.
1583.74 1588.42 "Игорь Лабутин" Хотя вы, наверное, понимаете, о ком мы говорим, поэтому да, транслируйте в уме.
1588.42 1593.02 "Анатолий Кулаков" Да, да, конвертируйте в Джимми Болгарда, конечно же.
1593.02 1602.82 "Анатолий Кулаков" Так, но в принципе сами контроллеры-то перенести тут никакой проблемы нет, теперь, когда мы подходим к зависимостям этого контроллера, вот там уже начинает подниматься огромный пласт проблем.
1602.82 1608.06 "Анатолий Кулаков" Во-первых, у нас есть зависимость, чтобы эта зависимость к нам попала, нам нужен DI-контейнер.
1608.06 1617.06 "Анатолий Кулаков" DI-контейнер настраивает там в том числе ORM, и наша бизнес-логика часто опирается именно на ORM, у нас используется Entity Framework, например.
1617.06 1644.38 "Анатолий Кулаков" Потом есть какие-то middlewari, есть какие-то, для того чтобы отобразить нашу вьюшку, есть какие-то HTML-хелперы, есть джава-скрипты, есть CSS-стили, ну и в конце концов сама же бизнес-логика, ее тоже нужно переносить, и такие банальные вещи, например, как новый Microsoft логгер появился, то есть тоже встает дилемма, зачем нам переносить всю бизнес-логику, допустим, со старым логгером, если у нас есть новый красивый универсальный абстрактный, стоит ли вообще лезть в эту пучину.
1644.38 1653.70 "Анатолий Кулаков" В принципе, все эти вопросы не имеют какого-то одного понятного решения, каждый этот пункт нужно рассматривать по отдельности и принимать какие-то решения, что мы будем с ними делать.
1653.70 1674.86 "Анатолий Кулаков" Ну вот, в частности, если рассмотреть самую популярную проблему, это как раз DI-контейнер, в проекте Andrew использовался медиатор, поэтому первое, что он столкнулся, это что его home-контроллер в конструктор требует i-медиатор, и медиатор, естественно, регистрировался через DI-контейнер.
1674.86 1689.06 "Анатолий Кулаков" DI-контейнер у нас использовался StructureMap, и у StructureMap нет прямого наследника на новый фреймворк, то есть он не поддерживается в новом фреймворке, но есть его идеологический преемник, так называемый Lomar.
1689.06 1692.46 "Анатолий Кулаков" Можно считать, что Lomar – это и есть StructureMap для .NET Core.
1692.46 1699.54 "Анатолий Кулаков" В принципе, он полностью на 100% весь API поддерживает специально для того, чтобы было удобно мигрировать и все такое.
1699.54 1705.10 "Анатолий Кулаков" Почему не был выбран стандартный микрософтовский DI, который появился в .NET Core?
1705.10 1723.10 "Анатолий Кулаков" Потому что у StructureMap использовалось очень много автоматических регистраций, то есть сканирование сборок, например, найди мне все классы в сборке, которые реализует интерфейс iModuleBinder и зарегистрируй все эти классы в DI-контейнере.
1723.10 1727.34 "Анатолий Кулаков" И вот подобные выражения было очень много у Джимми.
1727.34 1735.74 "Анатолий Кулаков" Поэтому он решил не переделывать DI-контейнер, а взял Lomar, перенес код, как есть, и все, и, в принципе, на этом и сошлись.
1735.74 1747.98 "Анатолий Кулаков" Далее бизнес-логика – вся прелесть, одна из прелестей медиатора в том, что он заставляет вас всю бизнес-логику сосредоточить в хендлере, а в хендлере он довольно ничего не зависит, ну, кроме самого медиатора.
1747.98 1766.22 "Анатолий Кулаков" Поэтому в хендлере было довольно легко перенести, то есть тоже обычной копипастой нас выручило, то есть никаких там особых зависимостей между .NET Framework и .NET Core здесь не проследовало, кроме зависимости на EF6, но насколько я понял, EF6 он тоже перенес как бы без проблем.
1766.22 1795.02 "Анатолий Кулаков" Дальше, если мы разговариваем про Vue, то там есть небольшие таких breaking changes, например, у .NET Core нет больше встроенного bundling in и минификации, то есть это специальные инструменты, которые во время билда минифицировали ваши стили или JavaScript для того, чтобы они сжимались, по сути, и занимали меньше трафика при передаче.
1795.02 1802.38 "Анатолий Кулаков" А также не только сжимали, но и собирали из разных файликов для того, чтобы передавать, допустим, один файлик, чтобы экономить коннекции.
1802.38 1806.02 "Анатолий Кулаков" В общем, есть там такие хаки на фронтенде, глупые, с которыми приходится сталкиваться.
1806.02 1809.38 "Анатолий Кулаков" И вот раньше был хороший пакет, который все это умел делать.
1809.38 1823.30 "Анатолий Кулаков" Теперь этого пакета нет, в .NET Core этого пакета больше нет, но у Microsoft есть большая хорошая статья, которая называется типа «А как же нам теперь минифицировать и какую стратегию минификации нам выбрать?» Из этой статьи можно почерпнуть, что существует два основных подхода.
1823.30 1837.14 "Анатолий Кулаков" Во-первых, это перейти на идейный преемник подхода вот этого оптимизатора, который был раньше, который называется WebOptimizer, который точно так же можно брать несколько файликов, слепливать их один, оптимизировать, сжимать и все такое.
1837.14 1846.94 "Анатолий Кулаков" И второй подход, это говорят, что если у вас современный Single Page Application, Angular, React и все такое, то берите Webpack, там уже все для фронтендеров есть.
1846.94 1864.54 "Анатолий Кулаков" У Джимми как бы ему нужно с минимальными усилиями перейти, поэтому он взял WebOptimizer, который умеет делать практически то же, что было раньше, но, к сожалению, без поддержки старого синтексиса, поэтому синтексис немножко изменился, но вся диалогия осталась, поэтому технически ничего сложного не было перенести в юхи.
1864.54 1879.18 "Анатолий Кулаков" Другой интересный перенос миграции – это SessionState, то есть это специальные пользовательские данные, так сказать, пользовательский кэш, который зависит от текущей сессии, сессии пользователя, сессии клиента.
1879.18 1910.06 "Анатолий Кулаков" Он может храниться в различных хранилищах, в том же распределенном кэше, в базе данных, очень часто в куках его просто-напросто хранят, но сессия – это такой довольно популярный шаблон проектирования, и счастье заключается в том, что .NET Core поддерживает сессии прямо с самых, практически своих первых версий, но плохая новость заключается в том, что совместимости между сессиями новыми и сессиями старыми никакой нет, там все полностью переписали и в том числе даже API изменили, поэтому просто так перенести не получится.
1910.06 1914.94 "Анатолий Кулаков" Здесь есть пара подходов, как это можно сделать.
1914.94 1927.42 "Анатолий Кулаков" Во-первых, можно, прежде всего, отказаться от сессий, потому что так тоже очень часто делают, делают стейтлес приложение и все такое, а во-вторых, это завести второе приложение.
1927.42 1936.22 "Анатолий Кулаков" Второе приложение здесь будет работать по очень интересным алгоритмам, давайте рассмотрим его поподробнее.
1936.22 1954.66 "Анатолий Кулаков" Смысл в том, что нам нужно оставить сессии, которые будут работать и на первом приложении, то есть на Application Core приложении, и на втором приложении, это в большом .NET Framework, и заставить сессии подружиться и там, и там, то есть новую версию на Core и старую версию на старом приложении.
1954.66 1964.18 "Анатолий Кулаков" Подружиться нам помогает уже упомянутая в первой части это библиотечка System Web Adapters, она очень много всего умеет, и в том числе творить вот такие хуки между сервисами.
1964.18 1969.78 "Анатолий Кулаков" Как же предлагается нам строить адаптеры для того, чтобы сделать прозрачной сессию?
1969.78 1973.02 "Анатолий Кулаков" Существует тут же тоже два подхода.
1973.02 1985.94 "Анатолий Кулаков" Во-первых, мы можем просто-напросто запустить в раппер, который у нас возьмет старую сессию и предоставит ей адаптер к новому интерфейсу.
1985.94 2007.22 "Анатолий Кулаков" А можем поступить чуть хитрее, если ваша сессия хранится в каком-то специфичном месте, в какой-то специфичной базе и может быть используют какие-то middlewari или какие-то другие хуки, которые в эту сессию каким-то образом модифицируют или как-то на нее влияют, то простым в раппером вы не сможете воспользоваться, насколько бы это заманчиво вам не казалось.
2007.22 2009.18 "Анатолий Кулаков" Для этого существует второй интересный способ.
2009.18 2014.22 "Анатолий Кулаков" Это, как я уже сказал, запустить сессию сразу на двух приложениях.
2014.22 2015.66 "Анатолий Кулаков" Схема очень простая.
2015.66 2025.30 "Анатолий Кулаков" Старое приложение на .NET Framework выставляет у себя специальные endpoints, которые позволяют записывать сессию и считывать сессию.
2025.30 2033.78 "Анатолий Кулаков" А новое приложение просто-напросто, когда у него просят дать пользовательскую сессию, идет к старому приложению и говорит, товарищ старое приложение, дай-ка мне сессию.
2033.78 2042.22 "Анатолий Кулаков" И старое приложение возвращает это через обычный HTTP запрос, а новое приложение уже децентрализует это в свой новый интерфейс.
2042.22 2052.34 "Анатолий Кулаков" Таким образом, даже если вы храните вашей сессии в какой-то там message scale базе, которую вы еще не перевели на .NET Core, допустим, вы можете уже поддержать пользовательские сессии.
2052.34 2054.94 "Анатолий Кулаков" Просто remote application call такой своеобразный.
2054.94 2065.22 "Анатолий Кулаков" В общем, и .NET Adapters позволяет вам поддержать оба этих сценария, что, в принципе, радует, что Microsoft даже на таких мелочах подумал.
2065.22 2072.62 "Анатолий Кулаков" Следующее, что и Джимми, сорян, хотелось перенести, это Handfire.
2072.62 2077.74 "Анатолий Кулаков" Это очень популярная библиотека, поэтому можно на ней остановиться отдельно.
2077.74 2083.78 "Анатолий Кулаков" Handfire – это легкий способ для того, чтобы запускать всякие background-таски, background-процессы, какие-нибудь background-джобы.
2083.78 2088.54 "Анатолий Кулаков" Их можно вставить по крону, то есть запускать по какому-то расписанию.
2088.54 2096.46 "Анатолий Кулаков" Эти джобы поддерживают персистентное хранилище, то есть можно там их куда-то сохранять, каким-то образом мигрировать, что-то с ним еще делать.
2096.46 2104.82 "Анатолий Кулаков" И у них также, они популярны тем, что у них есть красивый дешборд, на котором вы можете посмотреть статусы этих джобов, когда они выполнялись, с каким расписанием.
2104.82 2107.14 "Анатолий Кулаков" Все довольно красиво, с графиками и так далее.
2107.14 2114.14 "Анатолий Кулаков" Ну, поэтому библиотека получила такую хорошую популярность, потому что довольно часто идёт такой юзкейс и очень хорошо, красиво, удобно был сделан.
2114.14 2119.78 "Анатолий Кулаков" Опять же, правда заключается в том, что Handfire поддерживает оба фреймворка.
2119.78 2129.38 "Анатолий Кулаков" Поэтому вообще без ломания какого-то API вы можете запускать ваши Handfire-джобы как на одном приложении, так и на другом приложении.
2129.38 2132.78 "Анатолий Кулаков" Но есть нюансы.
2132.78 2134.94 "Анатолий Кулаков" Нюансы заключаются в следующем.
2134.94 2139.30 "Анатолий Кулаков" Handfire использует для сториджа, в случае Jimmy, SQL-сервер.
2139.30 2144.14 "Анатолий Кулаков" Ну, им нужен какой-то сторидж, где все эти задания, все эти бэкграунд-джобы будут храниться со своим расписанием.
2144.14 2148.14 "Анатолий Кулаков" И есть такая концепция, как очередь.
2148.14 2159.14 "Анатолий Кулаков" То есть мы джоб закладываем в какую-то очередь, он уходит, сохраняется в базу и потом в какое-то время, допустим, через 2 часа или в 3.00 он подымается и начинает выполнять свою работу.
2159.14 2167.62 "Анатолий Кулаков" И на самом деле запланировать такую работу можно абсолютно из любой части вашего приложения, хоть из контроллера, хоть из сервиса.
2167.62 2171.98 "Анатолий Кулаков" И мы рассматриваем нами приложения, очень часто этим пользовались.
2171.98 2177.30 "Анатолий Кулаков" То есть нельзя было найти какого-то одного места, джобы просто складывались отовсюду, откуда только можно складываться.
2177.30 2187.26 "Анатолий Кулаков" Например, джобы у них отправляли e-mail, отправляли SMS, чтобы не делать это в основном потоке, чтобы отпустить пользовательский реквест, это легко можно сделать в бэкграунд-джобе.
2187.26 2190.50 "Анатолий Кулаков" И для этого идеально подходит как раз-таки Handfire.
2190.50 2193.22 "Анатолий Кулаков" В чем же здесь проблема?
2193.22 2208.06 "Анатолий Кулаков" Проблема заключается в следующем, что если мы просто-напросто замигрируем все джобы как есть, то мы получим функциональность, в котором у нас джобы будут выполняться в двух приложениях.
2208.06 2217.22 "Анатолий Кулаков" То есть у нас старое фреймворк приложения возьмет джобы и начнет их выполнять, и новое приложение тоже попытается эти джобы выполнить.
2217.22 2219.02 "Анатолий Кулаков" И, к сожалению, не сможет.
2219.02 2229.06 "Анатолий Кулаков" В принципе, сам Handfire подразумевает, что у него может быть несколько там выполнятелей, несколько консюмеров, но проблема немножко не в этом.
2229.06 2238.70 "Анатолий Кулаков" Проблема в том, что сам джоб из себя представляет просто-напросто, грубо говоря, ссылку на какой-то контроллер или на какой-то класс, где хранится код, который ему нужно запустить.
2238.70 2263.30 "Анатолий Кулаков" И, допустим, если мы этот класс, например, класс-процессор перенесли уже в .NET Core, а вызывается этот класс, ну вот, отправки смски, вызывается класс отправки смски из старого приложения, то джоб, который запустится на старом приложении, он просто-напросто не найдет класса отправляющего смс-сообщения, потому что этот класс мы уже перенесли как бы в новое Core-приложение.
2263.30 2265.90 "Анатолий Кулаков" То есть он, по сути, не найдет, а что же ему запускать.
2265.90 2275.94 "Анатолий Кулаков" И так же точно с другой стороны, если мы в Core-приложении дернем какой-то джоб, реализация которого находится в старом приложении, то мы тоже ничего не сможем сделать.
2275.94 2278.78 "Анатолий Кулаков" Здесь у нас есть два выхода.
2278.78 2282.18 "Анатолий Кулаков" Первый выход – это просто-напросто взять все джобы и перенести за один раз.
2282.18 2285.10 "Анатолий Кулаков" То есть не только джобы, но и все те места, которые вызывают эти джобы.
2285.10 2289.54 "Анатолий Кулаков" Это, кажется, слишком большое изменение, за раз такое сделать невозможно.
2289.54 2294.22 "Анатолий Кулаков" То есть джобов у нас много, места размазаны, как я уже сказал, по всем контроллерам, по всем сервисам.
2294.22 2295.98 "Анатолий Кулаков" В общем, это практически нереально.
2295.98 2303.14 "Анатолий Кулаков" Поэтому есть второй выход – это переносить их постепенно, по чуть-чуть, но для этого нужно немножко ухитриться.
2303.14 2305.86 "Анатолий Кулаков" Необходимо создать две очереди.
2305.86 2313.26 "Анатолий Кулаков" Первая очередь, которая будет консумить core-приложение, вторая очередь, которая будет консумить старое приложение.
2313.26 2328.54 "Анатолий Кулаков" И джобы, то есть даже не джобы, а вот именно инициатор, то есть тот код, который планирует отправить смс, он должен знать, в какой очереди, по сути, лежит обработчик.
2328.54 2331.46 "Анатолий Кулаков" То есть обработчик у нас уже перенесен на .NET Core или не перенесен.
2331.46 2340.70 "Анатолий Кулаков" Если обработчик находится в том же самом хосте, в котором мы сейчас пытаемся запланировать очередь, то мы просто добавляем в одну очередь.
2340.70 2347.46 "Анатолий Кулаков" Если обработчик находится абсолютно в другом приложении, то мы уже планируем этот джоб в другую очередь.
2347.46 2351.06 "Анатолий Кулаков" Это немножко добавляет ненужной связанности.
2351.06 2357.76 "Анатолий Кулаков" То есть теперь у нас инициатор джобы обязан знать, а где эта джоба будет обрабатываться, в первой очереди или во второй очереди.
2357.76 2364.26 "Анатолий Кулаков" Но хорошая новость состоит в том, что это всего лишь временная такая трудность.
2364.26 2368.46 "Анатолий Кулаков" То есть, когда мы перенесем весь код, мы, естественно, все эти очереди сможем удалить.
2368.46 2375.74 "Анатолий Кулаков" И вот эта зависимость, вот это знание инициатора, где у нас обрабатывается, на каком хосту джобы, мы его тоже удалим.
2375.74 2378.10 "Анатолий Кулаков" Поэтому на время переноса это довольно хороший компромисс.
2378.10 2385.98 "Анатолий Кулаков" Поэтому у нас получается, соответственно, две ситуации.
2385.98 2393.18 "Анатолий Кулаков" Если у нас инициатор, который планирует джоб, находится в том же самом хосте, где и обработчик, то, в принципе, ничего делать не надо.
2393.18 2398.34 "Анатолий Кулаков" Он засунет это все в ту очередь, в свою собственную очередь, где хендфайер его подхватит.
2398.34 2412.36 "Анатолий Кулаков" Если же инициатор находится в другом хосте, то ему необходимо указать ту очередь, куда необходимо положить все-таки вот этот джоб, чтобы другой хост мог ее, этот джоб потом обработать.
2412.36 2420.14 "Анатолий Кулаков" Ну и после того, как мы замигрируем весь код, мы всего лишь на все возьмем и вот эту другую очередь, переименуем.
2420.14 2432.62 "Анатолий Кулаков" То есть, вот эти две очереди переименуем в одну, в дефолт очередь и подождем, пока все ивенты из старой очереди просто-напросто обработаются, а все новые ивенты уже будут складываться в вот эту одну единую очередь.
2432.62 2439.34 "Анатолий Кулаков" И поэтому этот код довольно легко удаляется и чистится все вот эти ненужные связанности, ненужные знания.
2439.34 2443.34 "Анатолий Кулаков" В общем, тоже такой довольно интересный юзкейс, необычный.
2443.34 2455.74 "Анатолий Кулаков" Мы до этого рассматривали все переезды, все методы и все сложности, которыми сталкивались при миграции, когда нам нет необходимости было знать текущего пользователя, его привилегии, роли и так далее.
2455.74 2463.50 "Анатолий Кулаков" Но, опять же, жизнь сурова и обычно нам нужна аутентификация, авторизация и прочее-прочее.
2463.50 2479.06 "Анатолий Кулаков" И вот с аутентификацией мы разберемся с вами в следующей части, потому что серия вышла довольно большая, поэтому даже второй части недостаточно для того, чтобы обозреть все трудности, с которыми сталкиваются обычные авторы, которые переводятся со старого фреймворка на новый фреймворк.
2479.06 2487.74 "Анатолий Кулаков" Поэтому ждите третью часть, посмотрим, насколько Джимми Богарт будет у нас продуктивен в плане писания, и как только он ее выпустит, мы обязательно расскажем, что же было дальше.
2487.74 2495.66 "Игорь Лабутин" Да, пишет он их нечасто, видимо, особенно сейчас кажется, что стало сложно что-то делать, ну в смысле что.
2495.66 2500.14 "Игорь Лабутин" Видимо, авторизация и аутентификация заняли довольно много времени, потому что пока статьи от него нету.
2500.14 2504.14 "Игорь Лабутин" Но подождем, может быть просто не складывается.
2504.14 2513.42 "Игорь Лабутин" Пойдем дальше, зато складывается у Аарона Стандарта, который написал очередную свою статью вокруг темы Майкрософта и опенсорса.
2513.42 2520.32 "Анатолий Кулаков" Ну, надо признать, что это автор, который очень любит тему рассуждать, опенсорса, и тем более Майкрософта здесь.
2520.32 2524.94 "Анатолий Кулаков" Да, у него очень много таких статей, у него очень много там инструментов, то же самое маркетплей для опенсорса.
2524.94 2525.94 "Анатолий Кулаков" Да.
2525.94 2529.54 "Анатолий Кулаков" Хорошо по этой теме пишет, знаток, это не просто какой-то хрен со стороны.
2529.54 2579.18 "Игорь Лабутин" Да, и поводом для этого послужило обсуждение, которое мы уже затрагивали чуть-чуть, по-моему, пару выпусков назад, если я правильно помню, это про то, что Майкрософт думает о том, чтобы, точнее, Майкрософт у себя в Гитхабе завела эпик под названием Eventing Framework in .NET 9, и все как бы прибежали, мы рассказывали про то, что все прибежали, сказали, вау, все, Майкрософт, короче, пишет свой собственный Eventing Framework, никакие там масс-транзиты, ничего другого больше будет не нужно, все, выкинуть на свалку, и все такое прочее, на что Майкрософт сказал, ну-ну-ну-ну, ну погодите, мы же не про то, мы же только про то, что вот мы тут быстренько для Azure Web Jobs сделаем, больше ни для чего нам это не нужно, все остальные как бы библиотеки, не пугайтесь, короче, мы ничего такого не планируем.
2579.18 2639.40 "Игорь Лабутин" Но, вроде как сказали, но тем не менее, вот этот эпик на Гитхабе вызвал довольно большой поток критики со стороны комьюнити, так скажем, про то, что вот Майкрософт опять, значит, не любит OSS, переписывает все сама и все такое прочее, и Аарон пишет, что типа, ну вообще-вообще кажется, что состояние open-source, точнее, быть автором open-source в дотнете, это сейчас довольно такая интересная штука, и не то что состояние, а в общем мысли его формулируются таким образом, что если как бы Майкрософту достаточно прийти и сказать, что я буду переписывать теперь эту библиотеку сам, да, или писать некоторую похожую функциональность на уже своем фреймворке, и этот шаг Майкрософта начисто убивает ваш бизнес, значит, вы что-то были не очень креатив, потому что как бы надо быть готовым, что Майкрософт придет и перепишет.
2639.40 2676.92 "Игорь Лабутин" Но Майкрософт говорит, что да, вот эту штуку мы пишем только для вебджобсов, и вообще, в общем, не переживайте, там mass transit, медиатор, wolverine, вот это все, не переживайте, вы в безопасности, но Аарон говорит, ну а зачем тогда это обзывать эпиком, потому что это понятно, что эпик это, наверное, гитхабовский термин, ну типа, что просто объединение нескольких как бы связанных ишлюсов, потому что в гитхабе нет понятия иерархии ишлюсов и, собственно, через эпик Майкрософт все делает, но, конечно, это стриггерило немножко комьюнити, потому что эпик подразумевает, что что-то очень большое, вот.
2676.92 2686.64 "Игорь Лабутин" И Аарон говорит, что ну, в принципе, как бы, ладно, вот как бы поведение Майкрософт, как бы поведение Майкрософт, что его особенно удивило, это поведение, собственно, комьюнити.
2686.64 2729.52 "Игорь Лабутин" И здесь у него есть удивление по поводу того, что, в принципе, есть часть комьюнити, которая, ну конкретно вот в этом, наверное, ишлю, активно голосует за то, что надо выкинуть такие мастранзит, медиатры, вот это вот всё, потому что, если у нас есть в экосистеме несколько, несколько, ключевое слово, даже хорошо поддерживаемых тулов, да, то есть, которые хорошие, которые как бы качественные, это очень неудобно, потому что, ну, надо же выбирать, это же как бы сложно, гораздо удобнее, да?
2729.52 2730.52 "Игорь Лабутин" Ну, надо думать-то.
2730.52 2732.52 "Игорь Лабутин" Да, когда у тебя есть один тул, вот.
2732.52 2743.04 "Игорь Лабутин" И он говорит, что похоже, что .NET комьюнити, ну, наверное, как и любое комьюнити, просто в .NET комьюнити, ну, как в тот, в котором он варится побольше, это прям очень сильно заметно.
2743.04 2750.40 "Игорь Лабутин" Ну и, возможно, это заметно, потому что Майкрософт тут такой единоличный игрок, да, на фоне всех остальных комьюнити.
2750.40 2780.56 "Игорь Лабутин" Что у нас есть две как бы большие группы, или он их называет когорты, да, .NET девелоперов, одна – это те, которые поддерживают такую диверсификацию, что там много вариантов, это хорошо, потому что я могу выбрать разные трейдов, да, ну вот тот самый Redis, да, Dragonfly, KDB, вот это все, или Garnet, ты можешь повыбирать, да, Redis там более проверенное временем и так далее, Dragonfly – и однопоточен, там Dragonfly многопоточен, там на другом языке, возможно, с какими-то другими гарантиями, ну и вот так далее.
2780.56 2806.08 "Игорь Лабутин" А другая половинка, ну, не половинка, а другая группа девелоперов, говорит, что нет, диверсификация – это плохо, нам нужен единый стандарт про то, как мы все делаем, вот, и типа, если Microsoft вот этот самый единый стандарт поддерживает, ну типа мы вообще в шоколаде, все здорово, он будет лучше задокументирован, поддержан и все остальное, и как бы нам нужно всю экосистему строить вокруг такого стандарта, вот.
2806.08 2843.92 "Игорь Лабутин" Ну и, соответственно, он говорит, что вот если посмотреть более детально на аргументы, что первая группа, которая за диверсификацию говорит, ну, как бы соревнования – это всегда было хорошо, то есть то, что Microsoft приходит в этот как бы соревнования таких вот фреймворков, ну здорово, пусть приходит, как бы будет не 3, а 4, условно, и это же прекрасно, чем больше фреймворков, тем больше шансов, что, например, там те же датанет разработчики такие попробуют написать что-то на, в виде там event-based системы, да, ну когда их там много, ну как бы здорово, вот.
2843.92 2867.48 "Игорь Лабутин" Второй момент, ну даже не второй, а еще один момент про то, что когда у вас есть выбор, это значит, что вы можете повыбирать, в том числе с точки зрения стоимости, потому что, ну как бы Microsoft бесплатно, но зато, как бы возможно с какими-то другими дробаками, а там, не знаю, возьмите тот же Mastransit с какой-нибудь платной поддержкой, если она там есть, ну как бы денег тратите, но зато получаете те фичи, которые вы хотите от Mastransit.
2867.48 2887.04 "Игорь Лабутин" Ну в общем, как бы эта часть разработчиков его как бы, он относится как раз к ней, и она его, понятно, что он там сильно подробно не останавливается, а вот другая часть разработчиков, это прям его очень сильно удивляет, что насколько они боятся, тут на это open-source проектов, вот.
2887.04 2900.64 "Игорь Лабутин" Он говорит, что довольно многие в твиттере ссылаются, ну типа, блин, это же наши юристы заставили нас выбрать этот стек технологии, он говорит, ну это примерно как моя собака съела мое домашнее задание, вот.
2900.64 2939.20 "Игорь Лабутин" Из этой же области, вот, и он говорит, что как раз вот это, пожалуй, одна из основных проблем, которой должна была решать .NET Foundation, то есть если библиотека типа есть в .NET Foundation, это значит, что, или продукт, что вот у нее точно нормальная лицензия, и любой корпорат может спокойно брать ее как бы в использовании, не заморачиваясь на какие-то юридические проблемы, вот, и кажется, что, ну вот он говорит, что именно поэтому акка в .NET Foundation, не знаю, говорит, насколько нам это помогло, но типа вот в этой части хочется верить, что .NET Foundation таки будет работать, не знаю, насколько сейчас работает.
2939.20 2950.20 "Анатолий Кулаков" Ну было бы замечательно, но кажется, что да, .NET Foundation как-то не решает, потому что юристы, прежде всего, смотрят на лицензию в первую очередь, а .NET Foundation не декларирует, какую лицензию обязан использовать фреймворк.
2950.20 2957.92 "Игорь Лабутин" А вот я, кстати, не уверен, я не уверен, может быть, ты не сможешь вступить, если у тебя будет какая-нибудь проприетар на что-нибудь, черт его знает.
2957.92 2958.92 "Анатолий Кулаков" Может быть, может быть.
2958.92 2966.24 "Анатолий Кулаков" Ну, кстати, то, что мы с тобой об этом не знаем, это значит, что как минимум .NET Foundation не кричит про это со всех сторон, а действительно мог бы и должен был бы.
2966.24 2978.44 "Игорь Лабутин" Ну, с одной стороны, да, с другой стороны, мы всё-таки не юристы, да, и я, по крайней мере, не подходил с точки зрения такого анализа к .NET продуктам, ну и библиотеку, которую мы используем, поэтому не знаю.
2978.44 2985.72 "Анатолий Кулаков" Ну вот смотри, я как раз-таки подходил, да, я исследовал все наши репозитории в компании на легитимной лицензии.
2985.72 3007.68 "Анатолий Кулаков" Ну, опять же, уже много раз нами упомянуты продукты, которые меняются в лицензии с красивых на совсем некрасивые для корпораций, и очень легко можно понять тех людей, которые боятся всего, кроме Microsoft, потому что Microsoft тебе дал какой-нибудь .NET Framework, ASP, Entity Framework, вот этот Blazer и всё такое, и ты понимаешь, что у него нормальная, постоянно стабильная лицензия.
3007.68 3015.36 "Анатолий Кулаков" Если мы сидим на Microsoft стеке, то всё, Blazer не закроют, как бы не потребует у нас денег с него, Microsoft на такое ни разу не ходил, у нас нет прецедентов.
3015.36 3028.40 "Анатолий Кулаков" А вот если мы начинаем использовать какие-то сторонние компоненты или библиотеки, то к IT-библиотеке могут прийти завтра и сказать, да, мы поменяли лицензию, как бы всё, или выпиливаете, тратите полгода, выпиливаете нашу библиотеку из всех своих приложений или платите много бабла.
3028.40 3031.16 "Анатолий Кулаков" В общем, здесь опасение рынка вполне понятное.
3031.16 3035.20 "Игорь Лабутин" Ну вот, да, наверное, здесь достаточно фондейшн могла бы поработать получше, не знаю.
3035.20 3085.64 "Игорь Лабутин" И он говорит, что ещё есть такой момент, что кажется, что, ну это опять вокруг того самого принятия решения, что если как бы у нас есть несколько опций или нет опции выбрать Microsoft, ну надо, приходится выбирать, короче, принимать какие-то решения, тут как бы можно просто сказать, берём Microsoft, да, типа, никто, как это, есть же поговорка, что-то мне в нескольких подкастах она уже встретилась, когда-то давно, да, было, ну не поговорка, присказковое выражение, что никто не был уволен за то, что выбрал Oracle или IBM, ну в общем, кого-то из этих крупняков в Америке, ну просто потому что это индустриальный стандарт, да, как бы мы купили лучший продукт, лучшую коробку, а то, что она не работает, ну как бы, сорян, она же лучшая, разве IBM может сделать что-то плохое?
3085.64 3087.64 "Анатолий Кулаков" Т.е. так же и Microsoft здесь.
3087.64 3093.88 "Анатолий Кулаков" Она типа никуда не денется, через год, через два она как была, так и останется, в каком-нибудь случае повысит цены, но как бы на месте она останется.
3093.88 3096.76 "Игорь Лабутин" Со звёздочкой, со звёздочкой, сейчас к этому Aaron тоже придёт.
3096.76 3114.64 "Игорь Лабутин" Дальше он говорит, что да, есть ещё point, что типа, нет, ну они там long term не будут, все эти сторонние проекты не будут поддержаны long term, а Microsoft типа они, как у него написано, safe by default, вот, типа безопасно по умолчанию.
3114.64 3129.80 "Игорь Лабутин" Третье-сторонние библиотеки не могут быть такого же качества, как Microsoft делает, смотрим на гарноты и значит это странный код, который внутри, который как бы там джесси холл и всё остальное, но тем не менее, но в таком духе.
3129.80 3140.48 "Игорь Лабутин" Ну то есть он говорит, что кажется, что вот эта вторая группа, она просто заменяет своё как бы критическое мышление и возможность выбирать на как бы просто веру в то, что Microsoft всё делает хорошо.
3140.48 3174.52 "Игорь Лабутин" И вот тут он говорит, что на самом деле не совсем всё так, то есть говорит, коробка-то коробка и Microsoft-то коробка, но посмотрите, где сейчас там Silverlight, он говорит, лучший пример, который я всем привожу это WCF, говорит, WCF появился, он говорит, примерно в 2006, вот, Mass Transit появился в 2007, ну и где говорит МВЦФ от Microsoft, надёжный и проверенный, и где Mass Transit, который до сих пор поддерживается и работает.
3174.52 3200.76 "Игорь Лабутин" То есть понятно, что это тоже, наверное, типа там хорошо, если 1% библиотек таких, да, которые столько много давно и долго поддерживаются в экосистеме, потому что понятно, что 99% действительно померло с 2006 года, потому что они не обновились на последний .NET, они не обновились ещё на что-нибудь, или они даже обновились на .NET Core, но не обновились потом на совсем последнюю, 5, 6, 8.
3200.76 3223.00 "Игорь Лабутин" Но тем не менее, какая-то доля логики у него есть, то есть, ну нету этого действительно почти ни в одной и другом системе, то есть никто не бегает за Oracle со словами дайте нам единственно правильный там, не знаю, HTTP-клиент этих, HTTP-клиента в том же Java, их там, ну не тысячи, но десятки наверняка в таком духе, то есть только в .NET-стакоре
3223.00 3224.00 "Анатолий Кулаков" есть.
3224.00 3238.92 "Анатолий Кулаков" Тут тоже шлуковая статистика, потому что, опять же, Microsoft, ну пусть Microsoft 1% своих продуктов закопал, но если мы возьмём, а сколько open-source библиотек, которые мынили себя конкурентами Microsoft сдохло, ну это умирает 99%.
3238.92 3239.92 "Анатолий Кулаков" Ну я и говорю.
3239.92 3241.72 "Анатолий Кулаков" То есть естественно, там везде управляние рисками.
3241.72 3253.64 "Игорь Лабутин" Да, то есть нет, это понятно, что, скорее всего, давай так, решение от Microsoft, наверное, проживёт гарантированно несколько лет, вот так скажем.
3253.64 3271.84 "Игорь Лабутин" Гарантируя, что оно проживёт там десятки, я бы не брался сейчас, то есть беря любую библиотеку от Microsoft, я бы планировал, что, даже видно по тому же ASP, что за то время, пока он стал кором, а потом, а современным ASP тоже были некоторые калисты breaking change, которые нужно как бы… Конечно.
3271.84 3273.92 "Игорь Лабутин" За которыми нужно следить и делать, вот.
3273.92 3287.16 "Игорь Лабутин" То есть также понятно, что со сторонними библиотеками ясно, что когда у тебя 10 разных HTTP клиентов, да, то понятно, что у тебя в 10 раз больше шансов, что они изогнутся в той или иной степени, вот.
3287.16 3296.04 "Игорь Лабутин" То есть вера в то, что, ну действительно, взять клиента от вендора, ну в смысле любую библиотеку, это, конечно, прикольная идея.
3296.04 3299.44 "Игорь Лабутин" Но с другой стороны, конкуренция, это же хорошо.
3299.44 3307.60 "Анатолий Кулаков" Ну конкуренция, конечно, хорошо, но посмотри тот же самый ASP.NET, сколько он сожрал других веб-фреймворков, сколько сдохло, да практически все.
3307.60 3314.88 "Анатолий Кулаков" Тот же самый Entity Framework, несмотря на Hibernate, 9Hibernate, вполне достойную конкурентную библиотеку, ну где она сейчас?
3314.88 3315.88 "Анатолий Кулаков" Ну практически сдохла.
3315.88 3318.56 "Анатолий Кулаков" В общем, Microsoft всё равно в лонг терме он побеждает.
3318.56 3328.60 "Анатолий Кулаков" То есть если по дефолту тебе дают какую-то левую подсоцную библиотеку, и по дефолту тебе что-то предоставляет Microsoft, то как бы 80%, что Microsoft выживет, и по дефолту ты возьмёшь именно его.
3328.60 3335.56 "Анатолий Кулаков" Здесь вряд ли стоит пинать на то, что люди не хотят выбирать или не могут выбирать, ну не знаю, не в этом проблема.
3335.56 3336.56 "Анатолий Кулаков" Опять же, как выбирать?
3336.56 3346.24 "Анатолий Кулаков" Когда у тебя там один вендор, который завтра заболеет или уйдёт на пенсию, и у тебя библиотека загнётся, или когда у тебя целая корпорация, которая может заменять людей, если реально видит, что технология востребована.
3346.24 3348.64 "Игорь Лабутин" То есть совсем другой разговор идёт.
3348.64 3365.20 "Игорь Лабутин" С этой точки зрения я согласен, но с другой точки зрения, ну то есть если мы будем всё время так делать, то всё скатится ко временам .NET фреймворка, когда есть только .NET фреймворк, да и почти никакого опен-соруса.
3365.20 3373.92 "Анатолий Кулаков" Да, безусловно, я полностью согласен, что огромная проблема в этом есть, её обязательно надо решать, но решения пока не видно.
3373.92 3386.96 "Игорь Лабутин" Вот непонятно, с какой стороны решать, потому что даже если у тебя появляется миллион, грубо говоря, сторонних библиотек, у тебя всё равно есть те, кто, ну как бы, или их может быть даже будет большинство, которые по привычке будут говорить, берём Майкрософт.
3386.96 3391.00 "Игорь Лабутин" Даже если он там хуже, не знаю, по каким-то параметрам и ещё что-то.
3391.00 3393.20 "Игорь Лабутин" Ну типа неудобненько, но зато вот Майкрософт.
3393.20 3399.40 "Анатолий Кулаков" Смотри, тут вспоминается очень интересная дискуссия, которая была во времена становления общего DI-контейнера.
3399.40 3404.52 "Анатолий Кулаков" Помнишь, у нас же не было раньше общего DI-контейнера, если кто-то застал ещё эти времена, общего логера не было.
3404.52 3406.88 "Анатолий Кулаков" Всё это было как бы разведочной компанией.
3406.88 3417.08 "Анатолий Кулаков" И вот когда… И вот, наверное, DI-контейнер – это вот первая такая ласточка в тот момент, что Майкрософт будет заходить в каждую область и вот как-то, как слон посудной лавки, замещать с собой.
3417.08 3424.08 "Анатолий Кулаков" И там пришли очень много людей с очень много… с разных сторон, которые понимали, к чему всё это движется.
3424.08 3431.32 "Анатолий Кулаков" Если сейчас Майкрософт выпустит свой DI-контейнер, то она пойдёт по этому пути и дальше, и как бы все, рано или поздно, все библиотеки уже под ней подомнутся.
3431.32 3440.04 "Анатолий Кулаков" И там пришёл, в частности, Николас Блумхардт, который был автором «Автофака», да, и он туда поэтому вот так в тему вписался.
3440.04 3446.56 "Анатолий Кулаков" И у него была, мне кажется, такая хорошая идея, типа «Да, давайте сначала, наверное, посмотрим, к чему это привело».
3446.56 3457.04 "Анатолий Кулаков" Да, у нас DI-контейнер у Майкрософта появилось, и там Майкрософт говорил, что это, типа, дефолтный контейнер, естественно, он будет всеми замещаться, естественно, там будет очень много альтернатив, где сейчас ваши альтернативы?
3457.04 3467.20 "Анатолий Кулаков" Вот практически никто никогда не реплейсит дефолтный контейнер ничем, поэтому я думаю, что вот путь всех альтернативных контейнеров, он куда-нибудь в могилу.
3467.20 3475.96 "Анатолий Кулаков" Если у вас там есть какой-то старый, поражённый сеньор, который сидит уже 20 лет, помнит, что такое «Автофак», наверное, он в новом проекте затащит вам «Автофак».
3475.96 3482.56 "Анатолий Кулаков" Но те новые люди, которые приходят и создают новые проекты, им никакого смысла тащить какие-то новые контейнеры вообще нет, вот ни разу.
3482.56 3484.60 "Анатолий Кулаков" Вот к чему это привело, да.
3484.60 3489.52 "Анатолий Кулаков" А теперь возвращаемся назад, в тот момент, когда обсуждали, а что будет, и почему, и как, и так далее.
3489.52 3499.56 "Анатолий Кулаков" У Блумхарта было классное, по моему мнению, предложение, он говорил, что да, не будут по дефолту никто менять, это убьёт как бы рынок всех DIY-контейнеров альтернативных.
3499.56 3510.04 "Анатолий Кулаков" Как бы ты хорошо как бы на этом рынке себя не чувствовал, как бы у тебя, как Арен сказал, насколько бы у тебя там креатив не работал, как бы невозможно победить дефолтный DIY-контейнер.
3510.04 3518.56 "Анатолий Кулаков" Предложение, да, возвращаемся, он предложил следующую идею, что Микрософт реализует именно протокол и именно стандарт.
3518.56 3520.72 "Анатолий Кулаков" Микрософт реализует только интерфейс.
3520.72 3523.96 "Анатолий Кулаков" Каким образом все остальные библиотеки должны регистрироваться.
3523.96 3527.92 "Анатолий Кулаков" То есть, вот iService Collection, предоставьте нам iService Collection.
3527.92 3530.32 "Анатолий Кулаков" Таким образом вы 100% решите все свои проблемы.
3530.32 3538.28 "Анатолий Кулаков" То есть, вы сможете и ISP там зарегистрировать, и Middle Ware зарегистрировать, и сторонние библиотеки, которые подключаются, у них будет понятный интерфейс, как им регистрироваться.
3538.28 3539.56 "Анатолий Кулаков" То есть, для этого же был DIY-контейнер придумал.
3539.56 3550.56 "Анатолий Кулаков" То есть, iService Collection нам достаточно, но не давайте саму имплементацию DIY-контейнера, пусть пользователь обязательно пойдет и выберет сам тот DIY-контейнер, который он хочет.
3550.56 3555.32 "Анатолий Кулаков" Тот же самый StructureMap, AutoFag, NNJACT, до тысячи их было, хороших и прекрасных.
3555.32 3562.72 "Анатолий Кулаков" И таким образом вы как бы и стандартизируете рынок, то есть, у вас будет стандарт, у вас не будет вот этой ваханалии, где каждый свои интерфейсы изобретает.
3562.72 3565.12 "Анатолий Кулаков" И не убьете все альтернативы.
3565.12 3570.00 "Анатолий Кулаков" И такая же тема с логером, как бы дайте нам просто интерфейс iLogger, который будут все юзать, и все.
3570.00 3571.56 "Анатолий Кулаков" А вот не давайте имплементацию.
3571.56 3575.64 "Игорь Лабутин" Я так понимаю же, что это примерно в каком-то смысле путь Джавы.
3575.64 3579.00 "Игорь Лабутин" У тебя есть там спецификация JPA, да?
3579.00 3585.24 "Игорь Лабутин" Джава, что там, Persistence, забыл про что там, а.
3585.24 3586.24 "Игорь Лабутин" Вот.
3586.24 3588.76 "Игорь Лабутин" То есть, и у тебя есть Hibernate, который его реализует.
3588.76 3597.52 "Игорь Лабутин" То есть, Hibernate это просто, по сути, реализация некоторого стандарта, который записан в JPE, который все аккуратненько сформулирован и так далее.
3597.52 3601.76 "Игорь Лабутин" Но, то есть, спецификация говорит, что репозитории должны выглядеть так.
3601.76 3605.24 "Игорь Лабутин" Как вы их реализуете внутри, это как бы дело ваше.
3605.24 3606.24 "Игорь Лабутин" Вот.
3606.24 3610.40 "Анатолий Кулаков" Ну вот тебе не кажется, что это хороший баланс между стандартом и альтернативами?
3610.40 3611.40 "Игорь Лабутин" Да.
3611.40 3612.72 "Игорь Лабутин" Но здесь возникнет вопрос.
3612.72 3620.24 "Игорь Лабутин" Вот Майкрософт у себя пишет ASP, ему внутри у себя тоже нужно что-то использовать.
3620.24 3623.40 "Игорь Лабутин" Какой DI-контейнер они внутри себя будут использовать?
3623.40 3631.28 "Анатолий Кулаков" Ну, вплоть от того, что как бы написать свой internal и никому его наружу не выставлять, и до того, что пусть возьмут какой-нибудь с рынка, почему бы и нет.
3631.28 3638.56 "Игорь Лабутин" Ну вот с рынка они, видишь, долгое время жили, на самом деле, с Ньютон Софтом же, пока не наняли к себе.
3638.56 3641.68 "Игорь Лабутин" Легче было купить с Ньютон Софтом.
3641.68 3647.68 "Игорь Лабутин" Да, и переписали, не его со всеми руками, конечно, но близко к нему, написали систем текст Джейсон.
3647.68 3648.68 "Игорь Лабутин" Вот.
3648.68 3653.24 "Игорь Лабутин" Ну, как бы, да, интерфейсы хорошо, но у Майкрософта слишком большой.
3653.24 3660.44 "Игорь Лабутин" То есть, в отличии от той же Джавы, потому что с Джавой как, у тебя же есть стандартная библиотека, да, джавская.
3660.44 3661.44 "Игорь Лабутин" Вот.
3661.44 3668.28 "Игорь Лабутин" И все, то есть, там тебе как раз, вот там тебе не нужен никакой GPA, ничего-ничего-ничего не нужно, у тебя просто стандартная библиотека.
3668.28 3676.24 "Игорь Лабутин" У тебя различные веб-фреймворки пишут и поставляют опять же различные компании, Spring одно, там не знаю, какие-то другие, другое.
3676.24 3677.24 "Анатолий Кулаков" Вот.
3677.24 3678.24 "Анатолий Кулаков" И просто Spring одно, все.
3678.24 3683.52 "Игорь Лабутин" Ну нет, там есть альтернативы, но тем не менее, всякие микронавты и прочее вот это вот.
3683.52 3691.04 "Игорь Лабутин" То есть, штука в том, что у тебя нет вот этого единой точки, которой нужно все это, ну, затащить вместе.
3691.04 3715.00 "Игорь Лабутин" То есть, у нас есть Microsoft, которому нужно, чтобы у него и свой DI был, причем реализации именно, да, потому что ты же не можешь сказать, смотри, для того, чтобы написать hello world аспшные дотнеты, тебе нужно сказать dotnet new, а потом выбрать, каким блогером ты будешь пользоваться, каким DI контейнером ты будешь пользоваться, иначе без этого извини, не заведется.
3715.00 3716.00 "Игорь Лабутин" Ну, это же как-то.
3716.00 3723.36 "Анатолий Кулаков" Ну, то же самое, что Spring Boot делает, да, когда он тебе позволяет совместимые между собой библиотеки, совместимых версий каким-то образом скомбинировать, чтобы это все не упало.
3723.36 3748.60 "Игорь Лабутин" Да, потому что в Java была эта проблема, я сейчас, когда в Java скеймирку гружаюсь, там до сих пор такая, ну, как бы вот для меня пока, имерим, может быть, те, кто в Java варится постоянно, это для них не проблема, а для меня проблема, что ты берешь, типа, окей, надо обновить эту версию зависимости, оп, там, минорную даже патч-версию поднял, опа, уже что-то несовместимо с чем-то, и сидишь, как бы думаешь, да, проще через Spring Boot Parent, конечно, как бы, потому что там все тщательно подобрано, и обновляешь целиком весь Spring Boot Parent зависимости.
3748.60 3769.96 "Анатолий Кулаков" Ну, я с тобой полностью согласен, что это, как бы, не идеальное решение со всех сторон, но если мы говорим про то, что надо комьюнити раскачивать, комьюнити у нас сейчас действительно очень слабые, то, может быть, стоило бы попробовать пойти на эти ухищрения и решить, как бы, лучшие последствия этих проблем, чем вот допускать того, что все будут бояться, как бы, новый Open Source делать и сваливать сюда при лече Майкрософта.
3769.96 3776.28 "Игорь Лабутин" Ну, а вот тут возникает вопрос, нужно ли это комьюнити Майкрософту, или ему нужно, чтобы ему в ажур приходили на чём угодно?
3776.28 3787.96 "Анатолий Кулаков" Ну, конечной целью, конечно, чтобы в ажур приходили, чтобы Майкрософту было удобно это всё сделать, и чтобы у тебя все библиотеки по дефолту работали, но без комьюнити, надо понимать, это же игра в долгую, без комьюнити всё это загнётся.
3787.96 3790.40 "Анатолий Кулаков" Не, ну без комьюнити… Получится dotnet framework.
3790.40 3801.20 "Игорь Лабутин" Ну, так и пусть, если на нём работает единственный софт в мире под названием ажур, а на ажур все пишут, не знаю, на Джаве и деплойт контейнеры на Джаве в ажур, а Майкрософт собирает деньги с ажура, так и хорошо.
3801.20 3807.56 "Анатолий Кулаков" Ну, опять же, платформа не развивается, идей не появляются, разработчики не приходят, кто этот ажур поддерживать-то будет?
3807.56 3811.56 "Игорь Лабутин" Ну, там в Майкрософте много народу, кто-нибудь да поддержит.
3811.56 3822.40 "Анатолий Кулаков" Ну, ладно, в принципе, хорошая тема, хорошего решения нет, если вы знаете, что нам делать, как раскачать комьюнити, или куда надо свернуть, или что сделать,
3822.40 3824.08 "Игорь Лабутин" приходите в комменты, с радостью обсудим.
3824.08 3836.36 "Игорь Лабутин" А лучше приходите в комменты Майкрософту и скажите, что делать Майкрософту, потому что кажется, что без какого-то желания и движения со стороны Майкрософта вряд ли что-то будет происходить, ну, есть такое ощущение,
3836.36 3837.36 "Анатолий Кулаков" не знаю.
3837.36 3840.56 "Анатолий Кулаков" Ну что, пойдем постепенно к следующей теме, тем более, что она немножко пересекается.
3840.56 3841.56 "Анатолий Кулаков" Давай.
3841.56 3851.04 "Анатолий Кулаков" Хочется с вами, дорогие друзья, поговорить о генерации сваггера, не просто с генерацией, а в билд-тайме генерации.
3851.04 3866.60 "Анатолий Кулаков" Для тех, кто немножко в танке, сваггер, он же Open API Specification, это такой мощненький инструмент, мощненький стандарт на рынке, который позволяет вам в JSON или в YAML-документе описывать структуру вашего API.
3866.60 3883.76 "Анатолий Кулаков" Он там описывает endpoints, которыми нужно обратиться, какие там query-параметры передать, полностью модели реквеста и респонса, что там в них должно быть, всякие security ключи, типа авторизации, токены, барьеры, вот это все в этом JSON или YAML-документе отписано.
3883.76 3886.98 "Анатолий Кулаков" И это очень такая полезная, хорошая толзень.
3886.98 3905.84 "Анатолий Кулаков" И существует очень много библиотек, ну в частности самые популярные – это Swashbuckle, ISP.NET Core и NSwag, которые позволяют вам этот документ создать, т.е. они рефлекшеном обходят ваши контроллеры, собирают всю информацию и вот в стандартном таком протоколе выставляют ее наружу.
3905.84 3913.72 "Анатолий Кулаков" На этот стандартный протокол обычно навешивается сваггер.UI, и вы получаете вот такую удобную тестилку и просмотрщиков вашего API.
3913.72 3923.08 "Анатолий Кулаков" Т.е. для того, чтобы протестировать и посмотреть на ваш API, вам уже не нужно писать какую-то UI, у вас есть стандартный сваггер.UI, который в принципе довольно функциональный и хорошенький.
3923.08 3927.96 "Анатолий Кулаков" Теперь, какую проблему хочется решить?
3927.96 3938.48 "Анатолий Кулаков" Вся вот эта генерация на NSwag и Swashbuckle происходит в рантайме, т.е. для того, чтобы получить вот этот выходной сваггер.документ, вам необходимо ваше приложение запустить.
3938.48 3942.48 "Анатолий Кулаков" И просто как вы запустили его, там можно с ним уже что-то сделать.
3942.48 3945.96 "Анатолий Кулаков" Но очень часто хочется получить вот этот документ в build-тайме.
3945.96 3950.12 "Анатолий Кулаков" Т.е. вы сбилдили и получили вот этот файлик.
3950.12 3953.72 "Анатолий Кулаков" Зачем мы его получили, это мы обсудим немножко позже.
3953.72 3955.96 "Анатолий Кулаков" Пока нужно принять за факт, что хочется.
3955.96 3959.64 "Анатолий Кулаков" И чтобы это делать, существовало много разных подходов.
3959.64 3982.56 "Анатолий Кулаков" Я, например, всегда писал свой интеграционный тест, который делается на стандартном i-сервере, т.е. как он там называется, test-web-application-factory, в общем, который поднимают через web-application-factory тестовое приложение, в это тестовое приложение просто-напросто дергает URL, по которому живет сваггер-документ, и вот, из теста его складывал прямо на диск, а потом дальше с ним что-то делал.
3982.56 3996.80 "Анатолий Кулаков" В общем, ну, опять же, практически то же самое, но Microsoft сделал это немножко удобнее, он запаковал ту же самую практически функциональность в удобный пакетик, который теперь называется Microsoft Extension API Description Server.
3996.80 4009.40 "Анатолий Кулаков" И этот пакетик позволяет вам как раз-таки то, что мы и обсуждали, генерировать OpenAPI спецификацию, т.е. вот этот сваггер-джессонный документ прямо из кода в тот момент, когда вы билдите свой проект.
4009.40 4036.58 "Анатолий Кулаков" Для того, чтобы сие чудо заработало, вам необходимо, ну, на примере, допустим, создать новый API проект, добавить туда вышеупомянутый пакет, и в csproj файл добавить парочку элементов, это OpenAPI Document Directory, обозначает папочку, в которой будет сохраняться выходной файл, и элемент OpenAPI GenerateDocumentOnBuild в true, который как раз-таки и включает вот эту функциональность, чтобы этот документ генерился.
4036.58 4046.82 "Анатолий Кулаков" Когда вы вызовете .NET Build, после успешной компиляции вашего проекта, создаться JSON-файл в папочке, в которой вы указали.
4046.82 4049.22 "Анатолий Кулаков" Вот так все просто, красиво и понятно.
4049.22 4088.54 "Анатолий Кулаков" Поддерживается Minimal API, поддерживается MVC, в общем, все это есть, и как раз буквально пару недель назад на GitHub появилась интересный EPIC, который называется Buildings – сделаем встроенную поддержку OpenAPI документации в .NET, и эта встроенная поддержка подразумевает собой не просто вот генерацию на лету, ну и прежде всего не только генерацию на лету, а именно вот этот контракт OpenAPI хочется встроить прямо в ASP.NET, то есть, чтобы весь ASP.NET знал об этих структурах хотя бы.
4088.54 4093.14 "Анатолий Кулаков" Ну, то есть, как описывать контроллеры, как описывать методы, чтобы это можно было, допустим, из кода все описать.
4093.14 4115.78 "Анатолий Кулаков" И несмотря на то, что ищу потом, чтобы давайте сделаем ASP.NET Core OpenAPI Package, появилась, как я уже сказал, буквально пару недель назад, я посмотрел на пакет, который умеет генерить документацию во время билда, и этот пакет начинает публиковаться в наггете с 2019 года, середины 2019 года.
4115.78 4122.46 "Анатолий Кулаков" Ну, то есть, там буквально уже 5 лет он публикуется, и почему-то ищу анативной поддержки появилась только сейчас.
4122.46 4123.46 "Анатолий Кулаков" Ну, это какая-то там, не знаю.
4123.46 4126.58 "Анатолий Кулаков" Большая интересная для меня загадка, как это все работает.
4126.58 4134.58 "Анатолий Кулаков" Притом в этой ищу написано, давайте, пожалуйста, реализуем пакет, который будет называться API Description Server, который будет генерить во время билда.
4134.58 4139.30 "Анатолий Кулаков" Ну, вот он есть, как бы уже 6 лет публикуется, и это совершенно открыто.
4139.30 4143.38 "Анатолий Кулаков" Я бы понял, чтобы они закрыли там или дали ссылку, сказали, уже есть.
4143.38 4144.38 "Анатолий Кулаков" Ну, нет, нет.
4144.38 4145.38 "Анатолий Кулаков" В общем, там какой-то бардак творится.
4145.38 4162.50 "Анатолий Кулаков" Но нас этот бардак не интересует, нас больше интересует сам факт, что Microsoft движется в ту сторону, чтобы стандартные структуры OpenAPI заместить своими, встроенными в ASP.NET, и это им позволяет как раз-таки делать много разных фич, например, в частности, генерить вот такие файлы в билд-тайме.
4162.50 4165.26 "Анатолий Кулаков" Теперь давайте вернемся к нашему изначальному вопросу.
4165.26 4168.02 "Анатолий Кулаков" Зачем вот эти свагер-файлы в билд-тайме нужны?
4168.02 4175.22 "Анатолий Кулаков" А нужны они как раз для наших сорс-генераторов, например, потому что на основе вот этих файлов очень часто что-нибудь генерится.
4175.22 4177.70 "Анатолий Кулаков" Самый типичный пример – это HTTP-клайенты.
4177.70 4190.34 "Анатолий Кулаков" В общем, писать вручную стандартные HTTP-клайенты, которыми мы будем передавать строчки в виде урлов, строчки в виде query-стрингов, строчки в виде body – вот это все довольно утомительно и тяжко.
4190.34 4202.22 "Анатолий Кулаков" Намного легче взять свагер-спецификацию и по ней сгенерить вам все урлы, все query строго типизированные, потому что мы знаем про типы, все body, все реквесты, всю авторизацию, все респонсы – все это в свагер-спецификации есть.
4202.22 4206.46 "Анатолий Кулаков" То есть, генераторы творят там много интересных чудесных дел.
4206.46 4207.94 "Анатолий Кулаков" И таких генераторов их полно на рынке.
4207.94 4220.46 "Анатолий Кулаков" Ну, в частности, например, прекрасный генератор есть Microsoft Kyoto – это новый HTTP-клайнт-генератор, я думаю, про него я расскажу отдельно, потому что классная тема, очень много интересных находок.
4220.46 4221.46 "Анатолий Кулаков" Поговорим.
4221.46 4226.42 "Анатолий Кулаков" NSWAG-генератор очень популярный на рынке, наверное, самый популярный вот генератор HTTP-клиентов.
4226.42 4238.94 "Анатолий Кулаков" Потом еще эти файлики можно использовать для библиотеки ASP.API.Versions, которая позволяет вам поддерживать версии в различных нотациях, в урле, в кедре и так далее.
4238.94 4245.22 "Анатолий Кулаков" В общем, это тоже каким-то образом библиотека может взаимодействовать с помощью этой спецификации или, наоборот, спецификации с этой библиотекой.
4245.22 4269.70 "Анатолий Кулаков" Каким-то образом этот файл нужен для OpenAPI-плагинов, потому что OpenAPI-плагин – это такая обалденная система интеграции, которая не требует от вас написания точных вызовов HTTP-методов, то есть OpenAPI-плагины пишутся не с помощью того, когда вы указываете в какой урл нужно заслать какую строчку и какую строчку оттуда распарсить, нет.
4269.70 4271.70 "Анатолий Кулаков" Там пишутся практически на естественном языке.
4271.70 4286.22 "Анатолий Кулаков" Типа создание пользователя с таким-то именем, и OpenAPI умеет… ой, OpenAI, извините, OpenAI – это наш искусственный интеллект который, он умеет понимать, что если мы хотим создать юзера, значит нужно пойти и поискать endpoint, который называется юзер.
4286.22 4298.28 "Анатолий Кулаков" Если мы хотим создать, надо поискать метод POST, и в этом методе POST где-то в одном из реквестов, в CreateUserRequest найти поле, которое называется name и заполнить его то, чем мы сказали.
4298.28 4299.98 "Анатолий Кулаков" То есть он работает на основании вот таких терминов.
4299.98 4307.70 "Анатолий Кулаков" Поэтому OpenAI-плагины – это тоже очень хорошая точка для потребления вот этой свайгер-спецификации, которая по сути ему весь вот этот дикшнери описывает.
4307.70 4324.46 "Анатолий Кулаков" Тот же самый свайгер UI, который у нас предоставляет UI-ку удобную, он тоже потребляет эти файлы, Postman, Redock, в общем очень много таких тестовых инструментов, которые позволяют тестировщикам каким-то образом просить свою работу, автоматизировать тесты, написать какую-то документацию на ваш API.
4324.46 4331.98 "Анатолий Кулаков" В общем, все эти инструменты, которые вокруг вот этого стандарта построены, они все хотят свайгер-спецификацию, это их контракт взаимодействия.
4331.98 4338.54 "Анатолий Кулаков" И чем раньше она у нас появится, например, на билд-тайме, тем лучше, чем бы и нет.
4338.54 4340.90 "Анатолий Кулаков" Теперь посмотрим, как это все работает внутри.
4340.90 4344.26 "Анатолий Кулаков" Внутри это работает практически так, как я сказал, как наши деды делали.
4344.26 4360.70 "Анатолий Кулаков" На самом деле запускается во время билда специальная command-line-тулза, которая называется .NET GET DOCUMENT, эта тулза находит вашу сборку, вы ей обязаны указать уже скомпилированную сборку, то есть сборка должна быть валидная, скомпилированная и так далее.
4360.70 4366.30 "Анатолий Кулаков" Это не анализ исходного кода, это не какие-то анализаторы, это именно поднятие настоящей сборки.
4366.30 4389.34 "Анатолий Кулаков" Там находится entry point, то есть ваш мейн, находится ISERVERIMPLEMENTATION, то есть это стандартный наш хост, он имплементирует R-сервер, через DI-контейнер достается некий документ-провайдер, и этот документ-провайдер с помощью рефлекшена, с помощью стандартного IP-explorer и так далее, то есть в итоге с помощью рефлекшена анализирует все ваши контроллеры, все ваши методы и возвращает вам, генерит и возвращает вам вот этот документ.
4389.34 4395.46 "Анатолий Кулаков" В принципе, такое всегда можно было сделать с помощью тестов, но вот в билд-тайме и отдельной тулзой, которая запускается, это немножко удобнее.
4396.46 4397.66 "Анатолий Кулаков" Планы про эту библиотеку.
4397.66 4408.66 "Анатолий Кулаков" В будущем собираются добавить YAML-спецификацию, то есть поддержка свайгер-спецификации в виде YAML, это два таких популярных формата JSON и YAML, которые обычно поддерживаются параллельно.
4408.66 4424.86 "Анатолий Кулаков" В общем, у Microsoft сейчас поддерживается только JSON, планируют засунуть туда JSON-схему, JSON-схема это тоже такая очень большая тема, которая нужна для того, чтобы как раз таки указывать, какие параметры, какого они типа, обязательный или необязательный, как они могут друг друга замещать, ну в общем, то, чтобы работать нормально с типами.
4424.86 4427.90 "Анатолий Кулаков" Чем JSON-схема интересна?
4427.90 4439.04 "Анатолий Кулаков" Тем, что она, тема реализовать JSON-схему, она, скорее всего, по глобальности не меньше, чем реализовать свой собственный JSON-сериализатор, который System Tech JSON Microsoft переделал.
4439.04 4450.54 "Анатолий Кулаков" Не зря у нас в стандартном сериализаторе почему-то сразу не сделали схему, ну потому что это довольно такая большая, хорошая работа, и кажется, что это вот новая такая большая библиотека в стане JSON-ов, которая может к нам добавиться.
4450.54 4462.26 "Анатолий Кулаков" Также интеграцию хотят сделать с XML-комментариями, потому что, естественно, когда у нас генерируется свагер-документ, у него есть поле description, в котором описывается человеческим языком, зачем тот или иной метод нужен.
4462.26 4471.06 "Анатолий Кулаков" И обычно для свагера эту информацию берут из XML-комментариев над методами контроллера, сейчас это не поддержано, тоже хотят вставить.
4471.06 4481.66 "Анатолий Кулаков" И, соответственно, они хотят заместить в том числе не только в билдтайме генерацию этого свагера, в спецификации, но если они ее умеют генерить, очень глупо останавливаться только на билдтайме.
4481.66 4486.50 "Анатолий Кулаков" Естественно, очень много инструментов и фреймворков рассчитывает на то, что она всегда есть в рантайме.
4486.50 4493.74 "Анатолий Кулаков" То есть, в общем, в рантайме они тоже хотят сделать метод mapOpenAPI и выдавать этот документ.
4493.74 4499.86 "Анатолий Кулаков" Чем, собственно, немножко уже топчется на поле свэшбакла и эндсвага.
4499.86 4503.22 "Анатолий Кулаков" И также они хотят сделать Aspire Dashboard.
4503.22 4510.22 "Анатолий Кулаков" Вы, наверное, от нас много наслышаны про Aspire Dashboard и надеялись, что в этом выпуске мы про Aspire ничего не скажем.
4510.22 4511.22 "Анатолий Кулаков" Но нет.
4511.22 4512.22 "Анатолий Кулаков" Aspire, Aspire, Aspire.
4512.22 4515.18 "Анатолий Кулаков" Это, наверное, единственная тема про Aspire, которая у нас сегодня будет, но все же это она.
4515.18 4517.86 "Анатолий Кулаков" Aspire Dashboard, он же красив, да?
4517.86 4523.86 "Анатолий Кулаков" Там у него есть графики, у него там есть метрики, у него там есть логи, у него там есть, в общем, список просто подов.
4523.86 4527.66 "Анатолий Кулаков" То есть он красиво сообщает там полностью всю информацию о приложении.
4527.66 4548.74 "Анатолий Кулаков" А как было бы прекрасно, если бы он вам еще и сообщал список всех API-контроллеров, которые у вас там торчат, всех API-эндпоинтов, которые у вас есть, и не просто сообщал, а давал бы, допустим, способ их вызвать, вбить какие-то данные, вбить какой-нибудь боди, авторизоваться, может быть, и вызвать, и посмотреть, что ваше приложение реагирует, работает на API-контроллеры.
4548.74 4553.38 "Анатолий Кулаков" Короче, сделать такой тестовый API, то есть тестовый UI для тестирования API.
4553.38 4560.86 "Анатолий Кулаков" В общем, стопроцентное замещение Swagger UI, тоже популярного инструмента.
4560.86 4567.50 "Анатолий Кулаков" Как это будет сделано, как бы, или Microsoft свой Swagger UI напишет, или возьмет стандартную библиотеку Swagger UI, пока неизвестно.
4567.50 4580.58 "Анатолий Кулаков" Но, глядя на текущий дэшборд, где Microsoft не взял там ни Grafana, ни Prometheus, ни Seek, ни кого-то еще, а переписал все сам с нуля, что-то меня терзают спутные сомнения, что Swagger UI тоже нужно задуматься о своем месте на рынке.
4580.58 4588.86 "Анатолий Кулаков" И как там, индивидуальность вот эту по андрелоку перепроверить, а точно ли у вас библиотека красивая, индивидуальная и с оригинальной идеей.
4588.86 4603.30 "Игорь Лабутин" Да, не знаю, я, честно говоря, давно уже Swagger UI именно не пользовался для тестирования, то есть, как-то все обычно другие клиенты, либо всякие .http, либо то, что в райдере там в идее и прочих есть поддержка .http файлов.
4603.30 4605.26 "Игорь Лабутин" Ну, Postman, куда он денется, хотя.
4605.26 4611.46 "Анатолий Кулаков" Ну, ты тестировщикам заходил, там каким-нибудь, или писателям документации, они же не будут тебе райдер пользоваться.
4611.46 4613.34 "Анатолий Кулаков" Ну, Postman, Postman, хотя.
4613.34 4620.02 "Анатолий Кулаков" Postman, да, Postman хорошо отожрал рынок, хотя, опять же, мы загоняемся, если мы посмотрим на лицензии и стоимости,
4620.02 4621.02 "Игорь Лабутин" не самый лучший инструмент.
4621.02 4640.42 "Игорь Лабутин" Да, у Postman, кстати, тоже вдруг вы не в курсе, но легкий автоп появилась альтернатива под названием Bruna, погуглите, оффлайновый клиент, ну, в смысле, что он хранит всё оффлайн, типа, в файликах своих, без вот этого монструозного единого файла из Postman, экспортирования коллекции, вот, и при этом вроде как это самое.
4640.42 4644.78 "Игорь Лабутин" Я не смотрел ещё, просто слышал где-то, лежит в закладках, нужно будет проверить.
4644.78 4650.02 "Игорь Лабутин" Я пока пользую инсомнию, если вы вдруг тоже не слышали.
4650.02 4658.14 "Игорь Лабутин" Да, свашбакл, свашбакл, что-то я хотел сказать, а, да, про свашбакл.
4658.14 4664.30 "Игорь Лабутин" Забавный факт, в принципе, эта новость у меня была отложена для кратко о разном, но на самом деле могу рассказать сейчас.
4664.30 4689.26 "Игорь Лабутин" Соседние GitHub issues, в смысле, буквально +1 от того, о котором рассказывал Толя, это про то, что новость, что Майкрософт собирается отказываться от свашбакла, т.е. у Майкрософта была такая, ну, коллаборация, не сказать коллаборация, в общем, они использовали свашбакл в S/P/Not-Core для того, чтобы как раз генерить тот самый OpenAPI, не OpenAPI, да, что у нас свашбакл генерирует.
4689.26 4690.26 "Игорь Лабутин" Ну, свайгер спецификацию.
4690.26 4694.70 "Игорь Лабутин" Ну да, по сути, как бы свайгер спецификацию в OpenAPI, проблема
4694.70 4705.06 "Анатолий Кулаков" в том, что… Кстати, смотри, ещё один пример коллаборации Майкрософта, это, наверное, второй, когда они использовали Newtonsoft, и свашбакл, по-моему, две единственные библиотеки, которые использовали Майкрософт на S/P/Not-Core.
4705.06 4706.06 "Анатолий Кулаков" Нет, Identity ещё.
4706.06 4707.78 "Анатолий Кулаков" Identity, он ещё, по-моему, тогда микрософтовский какой-то
4707.78 4708.78 "Игорь Лабутин" был.
4708.78 4711.98 "Игорь Лабутин" Нет, Identity-сервер, но внешний, который, четвёрочка-то была же.
4711.98 4714.50 "Игорь Лабутин" Ну, хорошо, да, допустим, Identity тоже.
4714.50 4734.06 "Игорь Лабутин" Да, вот Identity ещё был, ну вот, короче, S/P/Not-Core свашбакл или свашбакл S/P/Not-Core пакет, как он там назывался, он, в общем, давно не поддерживается достаточно, т.е. там последний коммит, ещё в 22-м году, его никто давно уже не обновляет, автор, как бы, по-моему, разместил иши про то, что, ну, как бы, я, это, буду счастлив его кому-нибудь отдать, если кто-то займётся.
4734.06 4752.22 "Игорь Лабутин" И поэтому, ну, как бы тут вроде бы, ну, обоснованное решение со стороны Майкрософта, окей, такую библиотеку вроде как странно уже использовать, хотя даже в этот иши прибежали ребята со словами, что ага, а чё же вы не законтрибьюете ли туда, давайте, вы теперь будете её поддерживать, всё такое.
4752.22 4756.46 "Игорь Лабутин" Майкрософт такой, ну, как бы, ну, а нам-то это, как бы, зачем.
4756.46 4770.14 "Анатолий Кулаков" Ну, смотри, я бы с тобой согласился, что этот ишью был продиктован тем, что эту библиотеку никто не поддерживает, если бы Майкрософт от Свешбакла перешёл, например, на Эллен Цвак, который прекрасно поддерживается.
4770.14 4774.38 "Анатолий Кулаков" Но он-то не перешёл, он написал своё, кажется, что это была не причина, это был повод.
4774.38 4784.78 "Игорь Лабутин" Ну, возможно, возможно, да, т.е. ну, как, занять своих их написать на современном, правильном, этим самым, не зависеть.
4784.78 4791.62 "Игорь Лабутин" Видишь, зависимость от сторонних тоже, как бы, непонятно, потому что нет никаких гарантий, что ты захочешь что-нибудь сделать, а они, типа, не захотят.
4791.62 4793.98 "Анатолий Кулаков" Ну и чё ты будешь делать?
4793.98 4797.26 "Анатолий Кулаков" Ну, безусловно, конкурентный рынок имеет свои минусы, как бы монополия были.
4797.26 4800.14 "Игорь Лабутин" А вот тебе нужно там для Ажура обязательно вот что-то там сделать.
4800.14 4808.06 "Игорь Лабутин" И у тебя план, график, вот это всё, а у тебя пул реквест сторонний не принимает эта библиотека, чё ты будешь делать?
4808.06 4809.06 "Игорь Лабутин" Не, ну минусы есть, есть, я согласен.
4809.06 4812.46 "Игорь Лабутин" Я бы хотел свешбакл настолько гибкий, что там можно из него делать вообще абсолютно всё, что угодно.
4812.46 4818.46 "Игорь Лабутин" Да нет, понятно, что есть, да, и понятно, что можно было бы просто форкнуть библиотеку к себе и держать её в Майкрософте, например, а не переписывать.
4818.46 4821.38 "Игорь Лабутин" Ну, как бы, решили, что так, ладно, посмотрим.
4821.38 4825.14 "Игорь Лабутин" Ну давай, поехали дальше, у нас есть ещё немножко новостей.
4825.14 4829.14 "Игорь Лабутин" Даже не новостей, а статей.
4829.14 4835.62 "Игорь Лабутин" Одна из статей – это про довольно древнюю тему, которую мы довольно давно не затрагивали, а именно про лилизм, ченнелы и так далее.
4835.62 4838.66 "Игорь Лабутин" Когда мы последний раз упоминали ченнелы в этом подкасте?
4838.66 4847.86 "Анатолий Кулаков" Ну, наверное, как они только появились, какой-то очень большой популярности почему-то не получили, т.е. я не вижу их там ни в статьях, ни в докладах, ни где, они почему-то не мелькают.
4847.86 4853.74 "Анатолий Кулаков" Ну, хотя по бенчмаркам должны были прям хорошая замена, чего не будет стать.
4853.74 4854.74 "Игорь Лабутин" Ну, нет, не стали.
4854.74 4865.18 "Игорь Лабутин" Да, они, видимо, довольно такая узкая нишевая штука, кому надо, они используют, кому не надо, ну, значит, видимо, не используют, либо действительно они настолько прямолинейные и просты, что просто берём и используем.
4865.18 4873.14 "Игорь Лабутин" Так вот, статья, она довольно давняя, полгода ей, ну, в общем, это не настолько давняя, чтобы про неё не поговорить.
4873.14 4879.42 "Игорь Лабутин" Автор задумался о следующей штуке, ну, там, с некоторой предысторией, но смысл задачки сводится к этому.
4879.42 4901.50 "Игорь Лабутин" У нас есть ряд задачек, каждый из задачек это какие-то, там, не знаю, операции с базой данных, например, вызовы, опишек и так далее, т.е. какие-то не только CPU задачки, а там, в том числе, есть what would, и нам нужно сделать n таких задачек, да, плюс-минус, как-то параллельно, возможно, не очень параллельно, но по возможности как можно быстрее.
4901.50 4922.58 "Игорь Лабутин" И если бы мы жили, там, не знаю, много лет назад, то было бы понятно, что, скорее всего, TPL, да, Parallel For Each, вот это всё, закинуть это всё в какой-нибудь concurrent bank, и потихонечку каждый из тасков оттуда тянет, что бы сделать, и аккуратненько через Parallel For Each выполняется.
4922.58 4929.46 "Игорь Лабутин" И он как раз подумал, что, ну, может быть, это как раз задачка для чаннелов, выглядит как бы прям идеально, можно сказать.
4929.46 4934.78 "Игорь Лабутин" И дальше вся статья, собственно, про это, она не такая большая, но основные мысли расскажу.
4934.78 4952.34 "Игорь Лабутин" Значит, во-первых, в TPL, да, то есть Task Parallel Library, то что Parallel For Each, вот это всё, есть такая опция под названием Max Degree of Parallelism, которой можно не указывать, но если вы её указываете, то вы таким образом ограничиваете количество тасков, которые будут одновременно исполняться.
4952.34 4962.18 "Игорь Лабутин" Ну, довольно жёсткое ограничение, все остальные будут поставлены в очередь, пока не освободится, соответственно, место для выполнения следующих.
4962.18 4978.66 "Игорь Лабутин" И понятно, что если ваши ворклоуды, то есть те таски, которые вы выполняете, в себя включают какой-то I/O, то есть обращение к вазе данных или обращение к сети, то, скорее всего, в этот момент таски будут висеть, ничего не делать, но поскольку таска не закончена формально, то TPL-ная логика не будет давать выполнять следующие таски.
4978.66 5004.02 "Игорь Лабутин" В результате он набросал некоторый тестик, то есть небольшой ворклоуд на сотню, по-моему, айтемов, некоторые рандомные дилеи внутри каждого айтема, чтобы симулировать какой-то I/O, и попробовал потестировать через Channel, через ParallelForEach для четырёх, ну, с ограничением в четыре, ParallelForEachAsync тоже с ограничением в четыре, чтобы понять разницу между синхронной и асинхронной версией.
5004.02 5013.42 "Игорь Лабутин" Потом попробовал увеличить ForEachAsync до сорока, то есть десять раз больше сделать, и попробовал сделать ForEachAsync без явного указания Макс Дегриева в параллелизм.
5013.42 5059.02 "Игорь Лабутин" И получилось следующее, что ченнелы, ну, реализация на ченнелах, которая довольно топорная, просто все таски в ченнелы закидывает и аккуратненько экзеквютирует их подряд, ну, подряд с галочкой, сейчас со звёздочкой объясню, почему уж не совсем подряд, заняла 68 миллисекунд на его, значит, компе, версия ParallelForEach с четырьмя, с ограничением в четыре, заняла 800 миллисекунд, ForEachAsync на таких же объёме занял 754, то есть, считайте, столько же времени, ForEachAsync на сорока, это 100 миллисекунд уже, приближается к ченнелам, но и ForEachAsync с дефолтным вариантом, когда вы не указываете явно Макс Дегриева в параллелизм, и он, вероятно, сам считается в зависимости от количества ядер, которые у вас есть, он занял 380 миллисекунд, то есть такая серединка на половинку.
5059.02 5062.74 "Игорь Лабутин" И дальше он делает из этого следующие выводы.
5062.74 5087.06 "Игорь Лабутин" Систем трейдинг ченнел, то что он, ну, быстрее чем ParallelForEach на четырёх, с Дегриева в параллелизм в четыре, ну, тут, как бы, это вообще не сюрприз, потому что, поскольку у нас есть в тасках тот самый I/O, ну или рандомный дилей, да, в данном случае, то понятно, что все остальные таски просто ждут в очереди, пока оно выполнится.
5087.06 5105.58 "Игорь Лабутин" Даже если вы увеличиваете до сорока элементов, всё равно понятно, почему это чуть-чуть медленнее, чем ченнелов, ну, потому что по факту у вас сорок тасков начинает исполняться, ну и шестьдесят всё равно всё ещё ждут, пока первые сорок поочерёдно начнут завершаться в зависимости от размера дилея.
5105.58 5114.76 "Игорь Лабутин" А при этом он говорит, что забавно, надо понимать, что это всё ещё параллелизм на тасках, а не на потоках, потому что в его измерениях количество потоков ни разу не превышало девятнадцать.
5114.76 5117.46 "Игорь Лабутин" Такое волшебное число, не больше девятнадцати потоков всегда создавалось.
5117.46 5134.34 "Игорь Лабутин" И понятно, почему систем трейдинг ченнел таки быстрый, потому что фактически эта логика, которая у него была написана, она по сути никак не ограничивает параллелизм, она просто берёт все таски из ченнела и бодро их закидывает на исполнение.
5134.34 5141.34 "Игорь Лабутин" И чем быстрее они, ну по сути они все начинают выполняться одновременно, так или иначе.
5141.34 5157.74 "Игорь Лабутин" И с этим есть проблема, потому что если у вас там, например, обращение к API или к базе данных, где у вас там есть лимитированные ресурсы в виде количества коннекшенов, или API сторонний не может переживать такое количество обращений, то у вас проблемы, и тогда таки нужно ограничить параллелизм.
5157.74 5160.90 "Игорь Лабутин" Ну и тогда возвращайтесь в Forge Async.
5160.90 5176.78 "Игорь Лабутин" Но при этом ченнелы сильно упрощают вот эту модель программирования, то есть она по сути у вас становится линейной, вы можете считать, что вам результаты из ченнела возвращаются плюс-минус последовательно, в отличие от TPL, который завершается там совершенно непонятным образом.
5176.78 5189.18 "Игорь Лабутин" Там надписи всякие, VNL, там вот это все по таскам, ну и всякую такую мультипоточную, ну даже может быть не многопоточную, но некоторую магию на тасках творить.
5189.18 5224.94 "Игорь Лабутин" И основной, пожалуй, вывод, который он делает в этой статье, если вы вдруг используете, то есть если вам нужно ограничить параллелизм, используйте Forge Async, но обязательно указывайте maxDegree в параллелизм, потому что иначе это будет выбрано некоторое число, возможно оно будет плюс-минус оптимально, но оно будет такое средненькое, то есть с одной стороны вы не ограничиваете вот это вот количество одновременно параллельных какой-то вам известной величиной, то есть вы не знаете, может при одном запуске у вас будет, не знаю, 4 таски одновременно выполняются максимум, а при другом 40, и ваша внешняя пишка, к которой вы, например, стучите, будет не очень счастлива.
5224.94 5225.94 "Игорь Лабутин" То есть лучше явно задавать.
5225.94 5238.98 "Игорь Лабутин" А с другой стороны, если вы ограничиваете слишком сильно, то, ну так получится, что ограничивается слишком сильно, то вы, может быть, сами того не зная, ограничиваете себе пропускную способность.
5238.98 5259.46 "Игорь Лабутин" То есть, как и всегда, долго-долго длинная статья, ну не очень длинная, но тем не менее, много-много чиселок разных и так далее, сравнений и всего такого, но в конце один естественный простой вывод, который можно сделать практически для каждой статьи про performance – измеряйте ваш кейс, понимайте ваши ограничения.
5259.46 5260.90 "Игорь Лабутин" Вот так вот.
5260.90 5264.66 "Игорь Лабутин" Скучно, хочется как бы ченнел и в 10 раз быстрее.
5264.66 5280.50 "Игорь Лабутин" Ченнел – это в том-то и дело, что в 10 раз быстрее, но проблема в том, что если ты там дёргаешь опишку, которая не скушает в 10 раз быстрее, а вернёт тебе типа retry later, то ты на эти 10 раз быстрее ченнелов вернёшь поле с быков, и как бы она для оно.
5280.50 5283.30 "Анатолий Кулаков" Ну хуже-то не будет, я в любом случае поле наверну.
5283.30 5285.06 "Анатолий Кулаков" Как разница над чем?
5285.06 5288.86 "Анатолий Кулаков" А вот если опишка скушает, тогда будет прирост производительности.
5288.86 5291.10 "Игорь Лабутин" Ну когда-нибудь, когда её пофиксят, да?
5291.10 5292.10 "Игорь Лабутин" Когда-нибудь.
5292.10 5293.10 "Игорь Лабутин" Да, когда пофиксят.
5293.10 5299.78 "Игорь Лабутин" Или на BD сервер накинут там ресурсов, и вон внезапно станет в 2 раза больше connections обрабатывать.
5299.78 5301.70 "Игорь Лабутин" Ну может быть, может быть, не знаю.
5301.70 5307.94 "Анатолий Кулаков" Ну вот смотри, как гарнет, его просто запустили, он на любых по объёмах, на любых данных всё показывает в 100 раз быстрее.
5307.94 5308.94 "Анатолий Кулаков" Вот это нормально работает.
5308.94 5313.06 "Игорь Лабутин" Точно, подменяешь radius container на такую штуку и сразу зашибись.
5313.06 5314.06 "Анатолий Кулаков" И сразу в ГЦ-холл.
5314.06 5318.58 "Игорь Лабутин" Ну это уж как получится, да, куда ж без дырок-то.
5318.58 5327.70 "Игорь Лабутин" Ну вот такие дела, короче, посмотрите на чаннелы, на самом деле действительно штука, я тоже по-моему один раз в жизни что-то написал на чаннелах, где-то они так хорошо легли.
5327.70 5329.94 "Игорь Лабутин" В логику, в остальном, что-то особо не надо.
5329.94 5334.18 "Игорь Лабутин" Ну может быть, потому что я пишу в основном в бизнес-логику, где особо чаннелы как-то не сильно нужны.
5334.18 5342.62 "Анатолий Кулаков" Да, ну я по-моему ни разу нормальную логику на чаннелах не писал, ну то есть нормальную инфраструктуру, у меня всё время почему-то хватало чего-то другого.
5342.62 5349.82 "Анатолий Кулаков" Только такие игральные проекты, которые чисто попробовать, чисто потестить что-нибудь, тоже обидно как бы.
5349.82 5352.82 "Игорь Лабутин" Может, мы с тобой старее, знаешь, много в бизнес-логике пишем.
5352.82 5364.98 "Игорь Лабутин" Вот я как раз хотел сказать это, потому что мы старые, и у нас достаточно, кстати, руки помнят, как писать всё условно на TPL, и как бы, ну на чаннелах, наверное, побыстрее, но оно же достаточно хорошо работает на TPL, пусть работает на TPL.
5364.98 5372.70 "Анатолий Кулаков" Да, ну если у вас есть опыт работы с чаннелами, и вам понравилось, то приходите, расскажите, а в каких ситуациях, в каких проектах это следовало бы использовать.
5372.70 5381.34 "Игорь Лабутин" Да, а если вы уже недостаточно старый или ещё недостаточно старый, то, наверное, вам понравится следующая тема про искусственный интеллект.
5381.34 5384.54 "Игорь Лабутин" Мы очень редко говорим про искусственный интеллект.
5384.54 5385.54 "Анатолий Кулаков" Захайпили вообще.
5385.54 5389.02 "Анатолий Кулаков" Здесь соединилась две просто темы, про которые мы редко говорим.
5389.02 5393.50 "Анатолий Кулаков" Ну, во-первых, искусственный интеллект - это какой-то грёбаный хайп, который непонятно в какие ворота вставлять.
5393.50 5406.02 "Анатолий Кулаков" А во-вторых, это UI, да, мы про UI, ну, пытаемся много говорить в виде мою я и так далее, но у нас плохо получается, потому что в UI сейчас вообще какая-то стагнация, дырка бездна и всё такое.
5406.02 5408.90 "Анатолий Кулаков" И UI-фреймворки катятся куда-то не туда.
5408.90 5424.86 "Анатолий Кулаков" И вот, чтобы хоть как-то вот эти темы, блин, поднять и что-то в этом духе, я нашёл интересную статью, которая как раз называется «Introduction.net Smart Components», т.е. которая соединяет в себе как раз и UI, и Artificial Intelligence контролы.
5424.86 5432.10 "Анатолий Кулаков" Я думал, что, опять же, это какой-то проходной базворд, но, почитав статью, действительно захотелось с вами о ней поделиться.
5432.10 5466.94 "Анатолий Кулаков" Во-первых, там есть текст, а, во-вторых, есть видео, и видео представляет не кто иной, а автор, Стив Сандерсон, он автор не только смарт-компонентов, он автор ещё Blazor, автор и много такой энтузиаст в WebAssembly вообще, он там писал какой-то Headless web-браузер, оптимизированный под WebAssembly, какие-то там компоненты на сервер, на кубернетах себе пишет для WebAssembly, в общем, отличный эксперт, признанный чувак, и он много таких вот вбросов делает, и, в частности, вот один из его вбросов – это смарт-компоненты.
5466.94 5484.90 "Анатолий Кулаков" Кратце попробуем вам рассказать, но если есть возможность, посмотрите или видео, или посмотрите статью, в статье прямо гифки, красивые рисунки, которые примерно дадут вам понимание того, чего я сейчас попытаюсь передать словами, потому что это довольно интересный пользовательский опыт.
5484.90 5496.66 "Анатолий Кулаков" В общем, чем меня статья зацепила, что это не какие-то банальные улучшения скролла или плавности прокрутки, а что-то новое, что можно донести пользователю, интересно и программистам, и пользователю.
5496.66 5502.62 "Анатолий Кулаков" Он нам представил несколько вот таких смарт-компонентов для Blazor.
5502.62 5508.66 "Анатолий Кулаков" Первый из них – это Smart Paste, то есть это специальная кнопка, которая позволяет вам сделать умную вставку.
5508.66 5510.14 "Анатолий Кулаков" Что это значит?
5510.14 5528.98 "Анатолий Кулаков" Допустим, типичный пример, когда у вас есть страничка доставки товара, и в этой страничке вы обычно должны заполнить такие поля, как ваше имя, фамилия, номер телефона, страна доставки, почтовый номер, улица, дом, в общем, очень много таких довольно примитивных, понятных полей.
5528.98 5534.90 "Анатолий Кулаков" Заполнять их все подряд довольно муторно и тяжко, тем более есть возможность ошибиться.
5534.90 5549.22 "Анатолий Кулаков" С помощью всего-навсего одной строчки, когда мы меняем обычный button на Smart Paste button в Blazor, который используют, естественно, смарт-компоненты, у нас появляется такая возможность, что на этой форме появляется специальная кнопочка Smart Paste.
5549.22 5573.58 "Анатолий Кулаков" Когда пользователь ее нажимает, перед ним открывается такой текстовый окошко, куда в произвольной форме он может вставить абсолютно любой текст, например, меня зовут Вася, я живу в России, мой город такой-то, мой код такой-то, улица такая и так далее, то есть обычный какой-то произвольный текст, который вы можете выдрать, допустим, из какого-нибудь почтового рассылки или еще откуда-то, или просто из сайта, или своей биографии на сайте скопировать, вот его и вставить.
5573.58 5576.06 "Анатолий Кулаков" Абсолютно неважен формат, вот что интересно.
5576.06 5591.46 "Анатолий Кулаков" И вот эта умная сволочь, она этот весь текст понимает, анализирует сущности, понимает, кто из них first name, кто last name, кто из них телефон, кто такой country и на какой улице вы живете, по какому номеру дома, и вставляет это все в каждое свое поле.
5591.46 5604.66 "Анатолий Кулаков" При этом ничего абсолютно размечать не нужно, какими-то определенными тегами, не надо говорить в каком поле у меня хранится телефон, он сам догадывается по тем лейблам, по тем переплейс текстам, которые у вас уже есть на контроллах.
5604.66 5606.74 "Анатолий Кулаков" То есть он способен сам все это проанализировать.
5606.74 5609.42 "Анатолий Кулаков" В общем, выглядит довольно интересно.
5609.42 5611.98 "Анатолий Кулаков" Следующий компонент – это Smart Text Area.
5611.98 5622.90 "Анатолий Кулаков" Здесь use case подразумевается такой, что вы, например, часто пишете какие-нибудь письма или отвечаете в каком-нибудь, например, саппорте на какие-то тикеты, вот что-то в этом духе.
5622.90 5641.86 "Анатолий Кулаков" Например, представьте, что если вы выполняете роль HR-специалиста, который, например, у которого задали вопрос «А могу ли я пойти в отпуск?», и вы должны написать такое хорошее письмо, типа «Здравствуйте, дорогой мой сотрудник, я вас очень люблю, у вас там осталось только отпуска» и так далее.
5641.86 5649.66 "Анатолий Кулаков" В общем, эти письма все писают довольно муторно, потому что они все довольно однотипные и отличаются какими-то довольно мелочами.
5649.66 5663.14 "Анатолий Кулаков" Просто так шаблон вставить однотипный у вас не получится, потому что у каждого сотрудника различное, допустим, количество отпусков осталось, или вы поприветствовать его должны по-разному, или покланяться в другую сторону, но 80% – это template.
5663.14 5666.14 "Анатолий Кулаков" А что подразумевается в таком случае?
5666.14 5677.70 "Анатолий Кулаков" Подразумевается заменить ваш текст-эре на smart-текст-эре, это специальный текст-бокс, в котором вам искусственный интеллект помогает дополнять этот текст.
5677.70 5679.14 "Анатолий Кулаков" Каким образом он дополняет?
5679.14 5704.38 "Анатолий Кулаков" Точно так же вы должны дать ему небольшую базу текста в произвольном, ну, произвольного текста, абсолютно никак не структурировано, в котором вы напишите, что я там работаю в такой-то компании, обычно у наших сотрудников 28 дней отпуска оплачиваемо, подробнее прочитать о том, как расходуется ваш отпуск, можно по такому-то урлу, сайт компании такой-то, если есть вопросы, пишите на e-mail HR-департмента, на вот такой-то.
5704.38 5719.22 "Анатолий Кулаков" И дальше вы начинаете, когда уже сам специалист начинает с этим текстом работать, ему, грубо говоря, возникает вот такой интеллисенс, но интеллисенс, который полностью в том контексте, что он сейчас пишет.
5719.22 5725.18 "Анатолий Кулаков" Если он пишет там «Хай, дорогой сотрудник», он там подразумевает стандартную, вставляется под стандартную фразу приветствия.
5725.18 5729.30 "Анатолий Кулаков" Вы, естественно, можете ее применить, немножко поменять, немножко подделать под ситуацию.
5729.30 5745.14 "Анатолий Кулаков" Когда вы пишете «У вас осталось», и он вам подставляет сразу 28 дней оплачиваемого отпуска, потому что по такому урлу написано «Наши полисы компании», «Урл компании», если есть вопросы, напишите по такому-то e-mail, то есть вот эти все тексты, вот эти все текстовые блоки он вам подставляет.
5745.14 5765.16 "Анатолий Кулаков" И вот кажется, что если ваша задача состоит в том, чтобы или часто отвечать на письма, или заполнять какие-то формы, которые более-менее действуют по стандартным шаблонам, но имеют вот небольшие какие-то ответвления, то вот это идеальный просто компонент, потому что он умеет подстраиваться под ваши текущие желания и в то же время обладает всей базой данных по сути вашей компании.
5765.16 5780.06 "Анатолий Кулаков" То есть вы из этой базы данных с помощью того текста, который сейчас набираете, он вам сразу подставляет уже готовые значения, то есть, например, урлы, стандартные цифры, стандартные e-mail, номер телефона директора вам достаточно просто намекнуть на то, что вы собираетесь это выводить.
5780.06 5788.22 "Анатолий Кулаков" И вам не нужно где-то искать какие-то ранбуки, там лезть куда-то в вашу Вики, оттуда что-то копировать, вот эта вся Вики у вас просто на кончиках пальца появляется.
5788.22 5794.10 "Анатолий Кулаков" Еще один компонент, наверное, это уже последний, это смарт-комбо-бокс.
5794.10 5803.98 "Анатолий Кулаков" Ну, думаю, стандартный комбо-бокс вы все себе представляете, это текст, и у него есть выпадающий список с какими-то предложениями, которые вы можете выбрать.
5803.98 5817.82 "Анатолий Кулаков" Проблема обычного комбо-бокса заключается в том, что вы для того, чтобы… Представим, что он огромный, что он большой, не знаю, там, города, страны, что-нибудь такое более-менее реальное, но большое, и вот вы пытаетесь оттуда что-то выбрать.
5817.82 5829.34 "Анатолий Кулаков" Для того, чтобы что-нибудь там написать в этом комбо-боксе, чтобы быстрее выбрать, вам необходимо обязательно знать о наличии такого слова в этом подставляемом списке.
5829.34 5834.58 "Анатолий Кулаков" Т.е. вы обязаны знать, как называется город, если вы там хотите его поискать, или обязаны знать, как он пишется.
5834.58 5835.58 "Анатолий Кулаков" Или страну.
5835.58 5856.42 "Анатолий Кулаков" Ну, город и страну, наверное, уже все знают, а если вы приходите на какой-то сайт, допустим, создаете ишью на Гитхабе, и вас просят из комбо-бокса указать категорию, которая относится к этой ищи, да я понятия не имею, какие у этого сайта, у этого приложения, у этой библиотеки там есть категории, какие они там забили, я не знаю.
5856.42 5863.26 "Анатолий Кулаков" И вот мне приходится весь этот комбо-бокс открывать, как-то мотать, как-то подставлять, это обычно бывает очень неудобно.
5863.26 5870.86 "Анатолий Кулаков" Вот Smart Combo Box позволяет вам, опять же, заменить стандартной одной строчкой обычный комбо-бокс, и он позволяет вам делать семантический матч.
5870.86 5873.42 "Анатолий Кулаков" Что это значит?
5873.42 5891.54 "Анатолий Кулаков" Это значит, что вы, например, если введете в этом комбо-боксе слово "самолет", но при этом в выпадающем списке, которое предлагает вам UI, слова "самолет" нет, но там есть что-то семантически похожее, например, "путешествие" или "публичный транспорт", он вам предложит выбрать из вот этих слов.
5891.54 5895.82 "Анатолий Кулаков" То есть по слову "самолет" он выведет "путешествие" или "публичный транспорт", и вы уже можете что-то ввести.
5895.82 5923.82 "Анатолий Кулаков" Возвращаясь к моему примеру с ищью, если вы пришли на какую-то библиотечку и хотите там, допустим, попросить автора поддержать мобилку, вы вводите слово "мобайл", и в комбо-боксе вам выскакивают уже подсказки в виде "андроид", "Айос", "мобайл секьюрити", "мобайл аксессабилити", ну то есть такой семантический матчинг, он знает, что "андроид" относится к мобайлам, он знает, что "Айос" относится к мобайлам, может быть, вы хотели как-то выйти на вот это.
5923.82 5930.06 "Анатолий Кулаков" То есть он вам помогает вводить вот такие сложные, большие, подбирать значения в таких больших-больших комбо-боксах.
5930.06 5933.78 "Анатолий Кулаков" Прелесть этого компонента в отличие от предыдущих в том, что его не надо ничем обучать.
5933.78 5943.10 "Анатолий Кулаков" Все вот этот семантический матчинг, то есть как слова соотносятся друг с другом, кто в кого входит и где где входит, это уже включено в ту модель, которую он юзает для того, чтобы это все работало.
5943.10 5950.98 "Анатолий Кулаков" Как вы, наверное, догадались, все это работает на какой-то Artificial Intelligence модели, то есть вам нужен какой-то бэкэнд обученный.
5950.98 5959.74 "Анатолий Кулаков" И там поддерживается Open API бэкэнд, Open AI бэкэнд.
5959.74 5960.74 "Анатолий Кулаков" Ужас.
5960.74 5964.14 "Анатолий Кулаков" Столько много похожих слов с Open AI и Open API.
5964.14 5965.70 "Анатолий Кулаков" Короче, Open AI бэкэнд.
5965.70 5966.70 "Анатолий Кулаков" Что это значит?
5966.70 5971.26 "Анатолий Кулаков" Это стандартный протокол, по которому подставляется, допустим, чат GPT.
5971.26 5973.62 "Анатолий Кулаков" Это стандартный протокол Open AI.
5973.62 5977.62 "Анатолий Кулаков" Казалось бы, мы все завязаны на Open AI, но на самом деле нет.
5977.62 5987.50 "Анатолий Кулаков" Потому что вот этот протокол Open AI, он уже на самом деле стал стандартным для всего рынка, потому что все другие модели, которые выпускаются, им абсолютно несложно поддержать свой стандарт Open AI.
5987.50 5995.46 "Анатолий Кулаков" Ситуация похожая, например, с Redis, когда уже выходит у тебя какой-то новый кэш, ему совсем несложно, а даже полезно поддержать протокол Redis.
5995.46 5996.86 "Анатолий Кулаков" Тут такая же точная ситуация.
5996.86 6004.02 "Анатолий Кулаков" То есть, поддерживается абсолютно любая модель, абсолютно любой движок даже, который умеет Open AI протокол.
6004.02 6005.02 "Анатолий Кулаков" Например, OLAMO.
6005.02 6012.50 "Анатолий Кулаков" OLAMO – это такой… Это не один движок, это такой бэкэнд, который поддерживает на себя очень-очень много моделей.
6012.50 6013.50 "Анатолий Кулаков" Там у них, блин, больше десятка.
6013.50 6015.82 "Анатолий Кулаков" Я думаю, там к сотне уже приближается количество моделей.
6015.82 6020.74 "Анатолий Кулаков" Это открытые модели, какие-то другие модели, оптимизированные по то, оптимизированные по все.
6020.74 6022.30 "Анатолий Кулаков" Если интересно, просто зайдите, посмотрите.
6022.30 6029.06 "Анатолий Кулаков" То есть, на самом деле, чтобы эта штука у вас заработала, вам не обязательно пользоваться каким-то страшным онлайновым Open AI бэкэндом.
6029.06 6036.14 "Анатолий Кулаков" Вы вполне можете на OLAMO поднять у себя где-то локально какую-нибудь модель, которая вам подходит, и вполне юзать ее.
6036.14 6039.26 "Анатолий Кулаков" То есть, любой API, который совместим с Open AI.
6039.26 6066.34 "Анатолий Кулаков" Вот такие интересные компоненты, которые хоть как-то вносят в индустрию поменьше хайпа насчет искусственного интеллекта и побольше интереса уже к устаревшим UI-компонентам, и которые как-то способны оживить вообще всю пользовательский экспириенс, который сейчас мы все имеем вот в таких скучных каких-то местах типа заполнения форм или написания там issues, или написания писем, или вот таких вот вещей, которые не хочется обычно заниматься.
6066.34 6078.10 "Игорь Лабутин" Да, было бы прикольно, заходишь в какую-нибудь жирку, говоришь, создай новую issue, туда пастишь call stack, а он такой сразу, а вот ты делал то, возникло то, проблема такая-то, а фикс такой-то.
6078.10 6079.10 "Игорь Лабутин" Вот pull request.
6079.10 6084.06 "Анатолий Кулаков" Да, вот тебе сразу патч, вот pull request, иди его проверь, одобри как бы, и все, мы его замежем сразу в мастер.
6084.06 6085.74 "Игорь Лабутин" Да-да-да, было бы конечно прикольно, но…
6085.74 6087.98 "Анатолий Кулаков" Ну я думаю, к этому и идем, почему нет-то, ну?
6087.98 6092.38 "Игорь Лабутин" Ну поведение все-таки, сценарий-то ты не узнаешь из call stack скорее всего, как ты до этого дошел.
6092.38 6098.54 "Анатолий Кулаков" Ну ты узнаешь call stack, в этом call stack-е наверняка у тебя нет проверки на null, а это уже как бы 80% всех багов.
6098.54 6100.58 "Игорь Лабутин" Ну типа того, да, наверное так.
6100.58 6113.38 "Игорь Лабутин" Ну что, давай потихонечку двигаться к концу, у нас есть на самом деле секция кратко о разном, где действительно сегодня особо разного нет, потому что про свашбакл я уже рассказал, поэтому там всего лишь одна единственная новость, и это очень краткая.
6113.38 6123.62 "Анатолий Кулаков" Я просто-напросто хотел вам напомнить, что на самом деле дотнет 7, хоть и появился, наверное, недавно по нашим меркам, поддержка от дотнет 7 уже прекращается.
6123.62 6129.98 "Анатолий Кулаков" 14 мая микрософт прекратит официальную поддержку, ну и нужно напомнить, что это был не LTS, поэтому он прожил так недолго.
6129.98 6144.34 "Анатолий Кулаков" А вот LTS – это дотнет 8, и поэтому всем рекомендуется с 7 переходить на дотнет 8, который проживёт недолго немало до 10 ноября 26 года.
6144.34 6149.98 "Анатолий Кулаков" Поэтому если вдруг вы на 7, то, наверное, пора уже озаботиться о том, чтобы перейти на более свежую и стабильную версию.
6149.98 6193.18 "Игорь Лабутин" Да, ну и на этом мы уже точно будем завершать сегодня, мы смогли поговорить о Microsoft Garnet, узнали про то, что добавится Priority Queue в 9 дотнете, пообсуждали опыт Джимми Бомбард на про-перенос старых дотнет-фреймворк приложений на новый дотнет, узнали как страдает комьюнити Майкрософт, потому что Майкрософт либо делает слишком много, либо наоборот не пишет уникальные единые стандартные библиотеки для всего, посмотрели на то, как Майкрософт собирается генерировать Open Apps пики в билд-тайме, вспомнили, что есть такая штука System Threading Channels и немножко сравнились с TPL, ну и посмотрели на новые смарт-компоненты в Blazor.
6193.18 6196.30 "Игорь Лабутин" На этом у нас, наверное, на сегодня все.
6196.30 6197.78 "Анатолий Кулаков" Да, да, точно все.
6197.78 6203.78 "Анатолий Кулаков" Ну вы тоже там не забывайте, комментарии, репосты, шары, рассказывайте друзьям и все такое, вы знаете где нас найти.
6203.78 6205.34 "Анатолий Кулаков" Всем до новых встреч, всем пока.
6205.34 6205.90 "Анатолий Кулаков" Всем пока.
6205.90 6215.90 "Анатолий Кулаков" [музыка]
