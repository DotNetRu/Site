0.00 11.28 "Анатолий Кулаков" Здравствуйте, дорогие слушатели, в эфире Радио.нет выпуск номер 113.
11.28 14.88 "Анатолий Кулаков" И в студии его постоянные ведущие Анатолий Кулаков
14.88 15.88 "Игорь Лабутин" и Игорь Лабутин.
15.88 16.88 "Игорь Лабутин" Всем привет.
16.88 20.34 "Анатолий Кулаков" А также нам помогают замечательные наши помогаторы.
20.34 21.34 "Анатолий Кулаков" Представляем.
21.34 40.80 "Анатолий Кулаков" Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Постарнаков Андрей, Дмитрий Сорокин, Дмитрий Павлов, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Лазарев Илья, Тимофей.
40.80 44.80 "Анатолий Кулаков" Спасибо, друзья, а также всем, кто нас поддерживает и пожалуй, остаться неизвестными.
44.80 47.64 "Анатолий Кулаков" А кто не поддерживает, заходите и поддерживайте, чего вы
47.64 48.64 "Игорь Лабутин" там ждете.
48.64 51.60 "Игорь Лабутин" А также у нас продолжает поддерживать компания Altenar.
51.60 58.20 "Игорь Лабутин" Ребята разрабатывают высоконагруженные продукты для индустрии спортивных данных и имеют офисы разработки в России и Европе.
58.20 68.12 "Игорь Лабутин" А еще участвуют в митапах и 18 апреля их разработчик Алексей Драйпольский расскажет, как ускорялся реализацию на нашем очередном митапе SPB.NET в Питере.
68.12 72.48 "Игорь Лабутин" А 21 апреля Altenar организует свой первый .NET митап в Нижнем Новгороде.
72.48 77.04 "Игорь Лабутин" В программе три интересных доклада, а тем, кто не сможет прийти, будет доступна трансляция.
77.04 80.44 "Игорь Лабутин" Все подробности о встрече доступны по ссылке в описании.
80.44 83.88 "Анатолий Кулаков" Ну что ж, начнем под нашей доброй традицией новостями от Майкрософта.
83.88 86.84 "Анатолий Кулаков" Нас Майкрософт чем-нибудь порадовал к этому выпуску?
86.84 94.40 "Игорь Лабутин" Да, Майкрософт нас порадовал, конкретно прямо к новостям мы перейдем чуть-чуть позднее, а нас порадовал Дэвид Фаулер.
94.40 102.22 "Игорь Лабутин" Дэвид Фаулер довольно, ну я слежу за ним плюс-минус в Твиттере, чтобы быть в курсе, так сказать, всех новостей.
102.22 125.72 "Игорь Лабутин" Конечно же, Донатэ Спайр, которым он сейчас занимается довольно активно, и тут он за последние несколько недель, можно сказать, разродился аж тремя статьями на Медиуме, что за ним, ну я не знаю сколько, мне кажется, уже лет не было замечено, он писал какие-то иногда небольшие заметки в виде гитхаговских гистов, а тут прямо аж три нормальных статьи на Медиуме.
125.72 128.64 "Анатолий Кулаков" Может, мажорный релиз какой-нибудь Испайра, наконец?
128.64 144.12 "Игорь Лабутин" Нет, как объясняется, не мажорный, сейчас я про это все расскажу, и часовой с небольшим видео с ником Чарлзом про то, вообще все эти статьи, про то, либо как устроен Испайр, либо вообще каково его предназначение, либо куда все это движется.
144.12 161.96 "Игорь Лабутин" Вот, давайте я попробую это все описать плюс-минус каким-то единым таким, единым описанием, что ли, постараться смиксовать все эти статьи и видео, могу где-то, может быть, повториться, где-то что-то забыть, но, в общем, если интересно, почитайте, там прям довольно подробно все расписано.
161.96 166.84 "Игорь Лабутин" В общем, в чем была вообще основная идея, когда начинался Испайр?
166.84 175.80 "Игорь Лабутин" Основная идея была про то, что нам нужно уметь клауднейти в приложении, легко запускать и деплоить.
175.80 212.76 "Игорь Лабутин" Это была первая идея, ради которой Испайр появился, но после того, как начали его использовать, выяснилось, что вообще-то, ну, исходная идея про запускать и деплоить, она, конечно, хороша, но кажется, что идея про запускать локально и сделать максимальный inner loop, то, что называется, то есть то, что разработчик делает в своей ежедневной жизни, много раз нажимает F5, там запускает, меняет код, снова запускает или там ход релоуд как-то работает, нужно сделать его максимально эффективным, а только потом уже думать про деплой.
212.76 219.84 "Игорь Лабутин" И в итоге все это сместилось, фокус сместился на максимально эффективный вот этот самый inner loop.
219.84 244.56 "Игорь Лабутин" И в итоге получилось, что Испайр, это как у него вот этот самый F5, то, что называется, это основной главный сценарий, который нужно прямо отполировать, отполировать, чтобы в нем было максимально все идеально, и только потом медленно, аккуратненько начинать подводить пользователей к каким-то следующим шагам.
244.56 254.88 "Игорь Лабутин" И не то, чтобы подводить, в смысле, что Microsoft лучше всех знает, куда этих пользователей везти, а смотреть, чем пользователи начнут пользоваться, что они будут просить и так далее.
254.88 283.64 "Игорь Лабутин" В результате Испайр, в том виде, как он зарелизился в первой и, в общем-то, последующих версиях, выглядел как то, что это в каком-то смысле рантайм, можно сказать, то есть для локальной разработки, но также в некотором смысле компилятор из вот этой модели приложения, которая в обхосте написана, в некоторое внешнее представление для всех остальных, для дипломента, по сути.
283.64 318.48 "Игорь Лабутин" Единственное, что было поддержано в виде дипломента, это Azure Command Line, то есть это, естественно, нативный, так сказать, майкрософтовский стэк для диплоя в Ажур, но правда, жизнь состоит в том, что по факту в больших компаниях, в общем-то, никто так не диплоит, ну, редко ты диплоишь из Command Line напрямую в Pro, там, как правило, всякие CI/CD пайплайны, вот это все, довольно много всякой сложности, как все это собрать, как все это проверить, удостовериться, что образы правильные, там, что-нибудь покшировать посерединке, и вот это все.
318.48 333.60 "Игорь Лабутин" И вот в этой части Aspire сейчас предоставляет довольно мало, то есть вы можете сгенерить JSON-чик, или ям, или уже не было, JSON, по-моему, из модели вашего приложения, но что дальше с ним делать, в общем-то, не очень понятно.
333.60 374.92 "Игорь Лабутин" И, в целом, сейчас процесс Aspire с точки зрения планов заключается в следующем, что команда, а Дэвид Фаулер неоднократно в видео подчеркнул, что команда там сплошит с принципа инженеров, короче, там прям суперзвезды, не только он работает, но там прям, я так понимаю, суперзвездная команда с точки зрения разработки, они пилят, значит, 9х версии, 9.1, 9.2, 9.3, мы сегодня поговорим немножко еще про это, а он уже работает на 10-й версии, то есть что будет в некотором будущем, видимо, ближе, ну, считаем, к концу года, то есть на горизонте 1 год, что там будет.
374.92 401.08 "Игорь Лабутин" И основной фокус, основная идея — это как раз-таки больше развивать диплоймент-часть Aspire, то есть локальная часть, она вот в этих инкрементальных релизах 9х будет потихонечку двигаться, а диплоймент надо прям как-то капитально развивать, то есть сделать его нормальным, плагабл, не то, что сгнили GSON, а дальше отвори с ним что хочешь, ну, как-то надо делать по-другому.
401.08 441.44 "Игорь Лабутин" Возникает вопрос, что есть вообще-то всякие уже продукты типа Aspire 8, которые берут этот самый GSON и генерят из него, например, кубернет с манифесты или там докер компо с манифесты, и казалось бы, ага, Microsoft в очередной раз убивает, значит, open source и вот это все, про это сегодня тоже еще немножко поговорим, но в данном случае нет, в данном случае автор Aspire 8 активно помогает Aspire, основной команде Aspire, с тем, чтобы сделать вот этот нормальный плагабл штуку для диплойментов, чтобы вероятно свой тул иметь не как отдельная настройка над каким-то там GSON, а возможно как-то вклиниться в сам Aspire в виде какого-то очередного интегрейшена, вот.
441.44 470.64 "Игорь Лабутин" Это все, вот эта вся история про диплоймент, она начнет появляться в этом году, и глядя на то, как говорил Дэвид в видосике, что it will come this year, то есть звучало это так, что в ближайшее время этого не будет, но мы увидим, что вот уже сейчас на самом деле немножко этот диплоймент можно начинать трогать будет, пока в превью, пока в очень таком приоритетном состоянии, но он уже начинает появляться.
470.64 507.76 "Игорь Лабутин" Что касается остальных релизов, мы сегодня будем говорить, что вышел 9.2, а еще не очень давно мы говорили, что вышел 9.1, а 9 вышел собственно вместе с основным релизом дотнета, то есть кажется, что они релизятся очень часто, и это их прям цель, у них цель сейчас релизиться примерно раз в месяц, чтобы как можно быстрее адаптировать и фиксить всякие мелочи, которые находятся пользователями, чтобы как раз этот inner def loop был максимально отполирован, максимально идеально сделан, прежде чем они переключатся уже на более длительные, долгие цели с точки зрения паблишинга.
507.76 548.04 "Игорь Лабутин" И второй момент, который Дэвид тоже подчеркнул, что в отличие от основного дотнета, который там подчиняется модели long-term support, short-term support, да, у нас там каждые нечетные релизы, соответственно, это short-term support, четные релизы это long-term support, которые по 3 года поддерживаются, здесь они осознанно, пока не стабилизируют это все в какой-то вид, которым они будут довольны и будут понимать, что там 99% каких-то пожеланий базовых разработчиков удовлетворены, они не хотят переходить на модель long-term support, и сейчас каждый релиз поддерживается ровно до выхода следующего релиза.
548.04 565.52 "Игорь Лабутин" Поэтому с одной стороны, ну вроде как не то, что ожидаешь там от корпораций, да, если они ориентируются на какие-то бизнес-кастомеры, с другой стороны, если основная цель это inner loop сейчас, то это простые разработчики, и там не так важен, возможно, тот самый LTS, не LTS признак.
565.52 566.52 "Игорь Лабутин" Ну вот.
566.52 580.16 "Игорь Лабутин" Еще интересный момент, что Ник Чапсос, который интервьюировал Дэвида, подсветил в видосике, это то, что кажется нам не хватает нормального тулинга с точки зрения команд-лайна.
580.16 592.20 "Игорь Лабутин" То есть сейчас все завязано на том, что либо ты пишешь просто код в Абхазте, либо ты что-то делаешь, возможно, как-то там в Дашбарде или еще что-нибудь.
592.20 597.68 "Игорь Лабутин" То есть нету какого-то нормального тулинга, а очень хочется что-нибудь, какой-нибудь там .NET Aspire, и так далее.
597.68 607.20 "Игорь Лабутин" Ну, в общем, наверное, с этим тоже что-то будут менять, но Дэвид сказал, что пока не очень понятно, что делать с тулингом.
607.20 609.96 "Игорь Лабутин" Там есть много открытых вопросов, но посмотрим.
609.96 623.76 "Игорь Лабутин" Вот это то, что было в основном в видео, а три статьи, которые я упоминал, они немножко все это разворачивают и углубляют, так скажем.
623.76 632.20 "Игорь Лабутин" То, что касается про инфраструктуру, про платформу и вообще про то, чем же является Aspire.
632.20 642.40 "Игорь Лабутин" В статье как раз говорится, что в принципе мы знаем, как собирать переиспользуемые системы, то есть как собирать системы из переиспользуемых компонентов.
642.40 655.56 "Игорь Лабутин" У компонентов есть интерфейс, мы знаем, как все это собрать вместе, мы умеем инкапсулировать сложность, выставлять какие-то простые интерфейсы, все замечательно, все прекрасно и круто до сих пор, пока вы не идете в мир CI/CD.
655.56 695.00 "Игорь Лабутин" Там, конечно, есть тоже какие-то реюзабельные компоненты, но во многом там это Shell скрипты, YAML файлы и вот это все, которое копируется из интернета туда-сюда, и уже не так все здорово, и вот как раз Aspire это попытка сделать с этим что-нибудь, то есть Aspire представляет собой некоторую систему, которая позволяет моделировать и само приложение с точки зрения того, как оно живет и кто от кого зависит, но и весь по сути software engineering, life cycle, цикл, грубо говоря, то есть то, как оно и деплоится и так далее.
695.00 737.24 "Игорь Лабутин" Именно поэтому все крутится вокруг ресурсов, то есть ресурсы в Aspire имеют четкий интерфейс и четкое поведение, их можно там вместе собирать и так далее, и вот дальше тут возникает как раз этот момент, что их можно исполнять в тот момент, когда вы это работаете все на компе, либо вы можете из них что-то наружу выдавать в момент паблиша или дипломента, и все эти ресурсы более-менее потихонечку сейчас начинают называться, даже не так, ресурсы это минимальные единицы того, чего может быть в Aspire.
737.24 756.08 "Игорь Лабутин" Когда ресурсы объединяются вместе, они начинают называться интегрейшнами, то есть это в некотором смысле пэкеджи, интераналог, ну, get-пэкеджи, грубо говоря, потому что в интегрейшн у вас попадает сам ресурс, какие-то его дефолты, то, чем Aspire в общем-то довольно активно промоутировал в самом начале.
756.08 777.84 "Игорь Лабутин" Сейчас, кстати, про это очень мало говорят, про то, что это не просто способ собрать ваше приложение из каких-то базовых блоков, но и способ эти базовые блоки настроить с очень неплохими дефолтами, которые проверены, грубо говоря, в боях, и вам не нужно задумываться о том, как там какой-нибудь poly или какой-нибудь radius настраивать, Aspire сделает за вас какую-то дефолтную настройку самостоятельно.
777.84 792.88 "Игорь Лабутин" Все это, естественно, хорошо работает из-за того, что все это описано в коде, строгая типизация, вот это все, и одна из целей тоже, которую ставит себе Aspire, это, они это называют from documentation to encapsulation.
792.88 817.04 "Игорь Лабутин" Мне кажется, что проблема в том, что обычно вся информация о том, как и что деплоить, она, конечно, там инфраструктура с кодом, все дела, но очень много где во многих количествах проектов все равно не избавится от каких-то документов, описания, что где куда, как нужно прописать, какие ключи, какие command line, где запустить, чтобы, значит, весь продукт в итоге куда-то поднять, вот.
817.04 821.40 "Игорь Лабутин" Хочется это все закинуть в код, и так и делать.
821.40 840.72 "Игорь Лабутин" При этом, Дэвид, кстати, отмечает, что, ну соглашается точнее с Ником, про то, что, ну да, документация по Aspire в части деплоймента, то есть в части того, что можно делать дальше с вашим приложением, поскольку вы его смогли позапускать, на самом деле очень пока слабенькая, и вот эта часть тоже они довольно активно будут работать.
840.72 841.72 "Игорь Лабутин" Вот.
841.72 888.40 "Игорь Лабутин" И, соответственно, я уже несколько раз повторил, что Aspire, по мнению Дэвида, это в некотором смысле там рантайм, не рантайм, а с другой стороны можно рассматривать Aspire как компилятор, то есть одна из статей называется Aspire compiler, и это не про то, что там есть реальный компилятор, это про то, что на самом деле Aspire работает по сути своей примерно как компилятор, то есть компиляторы у нас всегда, ну точнее традиционно берут некоторый ваш исходный код, преобразуют его в некоторое промежуточное представление, да, intermediate representation, и потом из этого представления отдельный кусочек компилятора выплевывают уже там машинный код или какой-то еще код, который будет дальше исполняться целевой архитектурой.
888.40 915.40 "Игорь Лабутин" Aspire делает по сути на самом деле то же самое, то есть у нас есть application model, это некоторый высокоуровневый язык, Aspire внутри себя это все мапит на какие-то более низкоуровневые конструкции промежуточные, дальше publisher, это вторая часть по сути компилятора, из всего этого собирает нужные кусочки для будущего deployment, ямли, какие-то там json или что угодно, docker-compose, вот это все.
915.40 930.12 "Игорь Лабутин" В результате это позволяет все, конечно, много где проверять, задавать кучу валидаций, поддерживать кучу таргетов и позволяет самое главное встраиваться во всю эту цепочку практически в каждом месте.
930.12 954.28 "Игорь Лабутин" Поэтому если вам вдруг нужно, например, как-то встроиться, вклиниться в процесс того, что делает Aspire, перед тем как запустить ваше приложение, на самом деле почти, ну не все, но очень многие стадии они расширяемые, если вы в нужном месте правильно подоткнете нужную реализацию интерфейса какого-нибудь, то Aspire прекрасно заработает.
954.28 973.36 "Игорь Лабутин" Кстати, в каком-то смысле была интересная аналогия где-то, я ее видел, то ли в видео звучало, то ли я просто где-то на просторах интернета видел, что кажется, что ну можно провести такую аналогию, что Aspire это в некотором смысле какого-то рода Spring Boot из Java, но для .NET.
973.36 986.08 "Игорь Лабутин" Потому что Spring Boot это как раз в каком-то смысле та же самая идея сделать легко доступные пэкэджи, у которых конфигурация согласована друг с другом и которые имеют какие-то разумные дефолты.
986.08 991.28 "Игорь Лабутин" В этом смысле похоже на Spring Boot.
991.28 1043.64 "Игорь Лабутин" И интересная часть, это, собственно, будущее, и как мы выяснили, что, ну, конечно, Aspire хочет там быть и innerloop, и хочет все это делать, хочет все это делать с точки зрения деплоймента, но перед тем, как перейти к future, собственно, в статье рассматривается такая роль, как Platform Engineer, и про него говорится следующее, что берем, вот если вы разработаете какой-то продукт, даже если вы деплойте там в Azure, в AWS, в Google Cloud, и вообще куда угодно на самом деле, свой собственный хостинг, вы очень редко используете вообще все, что есть в Azure, т.е. вы не садитесь там для каждого вашего продукта и не думаете, а как бы мне сейчас сконфигурить там какой-нибудь Azure Managed Progress или еще что-нибудь, нет.
1043.64 1174.60 "Игорь Лабутин" На самом деле, конечно, у вас есть обычно, если вы маленький, то у вас нет такого разнообразия деплойментов, а если вы большой, то у вас есть скорее всего некоторая команда или некоторые принципы того, как вы используете облачные ресурсы, и у вас появляется некоторая своя такая подмножество что ли некоторых ресурсов, принципов работы с облаком и так далее, которые выведены либо опытом, либо умными инженерами заранее, и все желательно им должны следовать для того, чтобы было проще все это отслеживать, соответственно, есть некоторые способы как это описать, да, есть всякие тузы, которые позволяют вам легко конфигурировать облака, терраформы всякие, если мы говорим про Azure, то там есть Bicep, можно взять какой-нибудь Pulumi и так далее, и с этим вроде, ну, более-менее инфраструктура, все дела, все хорошо и нормально, а вот дальше есть интересный момент, что это все, конечно, здорово, т.е. вам платформенный инженер может все это легко развернуть и так далее, с помощью всяких терраформов, но как вот это все донести до разработчика приложения, ему-то что использовать, как ему подключиться к этой всей прекрасной, отлично развернутой инфраструктуре, оно тут непонятно как, потому что из .NET в терраформ, ну, не зайдешь, и в Pulumi, впрочем, тоже, несмотря на то, что на C# там можно писать, и вот это как раз то, где Aspire пытается заполнить нишу, т.е. они как разработчики тулза пытаются сделать так, чтобы вы как разработчики приложения не задумывались о том вообще, что у вас там, какая у вас там менедж пазгря, или в какой подсети она находится и так далее, т.е. платформенный инженер что-то генерирует, и также они же, например, предоставляют вам как разработчикам готовые интегрейшены, Aspire интегрейшены, в которых вся эта же конфигурация уже описана, грубо говоря, и вы просто в ваше приложение его подключаете, ее конфигурацию, эти интегрейшены, и она просто работает задеплойной в ваше же стандартное облако со стандартным подмножеством тех фич, которые вы используете.
1174.60 1199.60 "Игорь Лабутин" При этом они говорят, что нет, мы не пытаемся все-таки зайти на территорию того же Terraform, мы не будем пытаться описывать именно инфраструктуру, это не наше дело, мы не про то, мы только про описание именно приложений и их зависимости и того, как они зависят от инфраструктуры.
1199.60 1201.60 "Игорь Лабутин" Куда идет Aspire?
1201.60 1237.20 "Игорь Лабутин" Сейчас, как я уже сказал, они занимаются внутренним development loop, но в будущем план состоит в том, что нам нужно уметь описывать поведение или конфигурацию тех или иных систем внешних зависимостей, причем, вот я, кстати, не помню, есть ли это сейчас в Aspire, но цель, видимо, сейчас это в целях, то скорее всего этого сейчас в явном виде или в полноценной реализации нет, в многих случаях на самом деле разница должна быть, что такое допустим девелоперский стенд, припродовый стенд и продакшн стенд.
1237.20 1251.24 "Игорь Лабутин" Конфигурации, настройки там всяких таймаутов, не знаю, ретраев или еще чего-либо могут быть довольно разными, и этого сейчас в явном виде, как я помню, в Aspire нет, а это тоже должно появиться рано или поздно.
1251.24 1275.52 "Игорь Лабутин" Дальше, генерации, соответственно, каких-нибудь диплойментов из аппликейшн-модели, ну и пайплайнов сборки, тоже тут они упоминаются, хотя непонятно, пайплайн сборки вроде как не сильно связан с зависимостями, но посмотрим, что они там пытаются сюда вписать.
1275.52 1309.08 "Игорь Лабутин" В общем, вот такое видение, то есть, грубо говоря, сейчас у нас Aspire это больше про красивый дешборд, логи, графики и так далее, но в будущем это штука, которая позволит вам не только нормально запускать у себя локально, но и каким-то образом в вашей платформенной команде описывать интегрейшн, которые позволят прямо изнутри Aspire генерить правильные манифесты, что угодно, хелмчарты и все такое прочее, для того, чтобы диплоить в вашей инфраструктуре.
1309.08 1316.32 "Игорь Лабутин" Какие-то такие слова про Aspire у нас от Майкрософта Дэвида Фаулера, точнее, в четырех разных источниках.
1316.32 1325.64 "Анатолий Кулаков" Ну, интересно, интересно, потому что я сейчас пока не очень осознаю ту проблему, которую они пытаются решить, или она слишком маленькая, или одно из двух.
1325.64 1340.56 "Анатолий Кулаков" В общем, посмотрим, что Майкрософт сделает из этого чуда, потому что с самого начала было понятно, что слишком мелка та ниша, что покрывает собой Aspire, если сравнить ее с теми ресурсами, которые в нее вкладываются.
1340.56 1342.72 "Анатолий Кулаков" Поэтому ему необходимо найти себе что-то действительно достойное.
1342.72 1345.28 "Анатолий Кулаков" Может быть, это одно из правильных направлений.
1345.28 1359.80 "Игорь Лабутин" Ну да, поглядим, поглядим, и радует, что они работают с нужными ребятами, то есть они не просто стали писать интеграцию с Кубером или с Докер Компоузом, а поговорили со Спирейтом, и, видимо, как-то с ними взаимодействует хорошо.
1359.80 1360.80 "Игорь Лабутин" Посмотрим.
1360.80 1363.72 "Игорь Лабутин" Что у нас еще есть интересненького на сегодня?
1363.72 1372.24 "Анатолий Кулаков" Ну, у нас прошедшая неделя символизировалась собой кучей всяких драматических новостей, вот я думаю, парочку из них мы сегодня и обсудим.
1372.24 1379.88 "Анатолий Кулаков" Ну, одно из самых громких новостей — это в том, что автомапер и медиатор теперь станут платными.
1379.88 1393.72 "Анатолий Кулаков" Об этом нам сообщила Джимми Боггард, как раз автор всех замечательных инструментов, и сделан это 2 апреля, явно в статье намекнув, что если бы я это сказал 1 апреля, никто бы мне не поверил, но на самом деле я еще придумал это тогда.
1393.72 1399.04 "Анатолий Кулаков" Поэтому 2 апреля, поэтому это не шутка, это все проверенные достоверные источники, другими мы не пользуемся.
1399.04 1404.00 "Анатолий Кулаков" Вот, Джимми рассказал, что все, вот теперь эти библиотеки будут платными.
1404.00 1410.28 "Анатолий Кулаков" Ну, давайте попробуем разобраться, что же двигало авторам, и что нас, собственно, ожидает.
1410.28 1413.44 "Анатолий Кулаков" Во-первых, что, собственно, происходило изначально.
1413.44 1418.36 "Анатолий Кулаков" Ну, изначально Джимми написал эти библиотеки, когда работал в одной из больших компаний.
1418.36 1426.96 "Анатолий Кулаков" Он там работал долго, успешно, и смысл был в том, что эта компания оплачивала непосредственно его работу над open source проектами.
1426.96 1439.20 "Анатолий Кулаков" Вот почему как бы Медиатор и Автомаппер так хорошо и быстро стартанули, качественно развивались, и много про них не писалось, потому что Джимми в это вкладывался за бабки.
1439.20 1448.64 "Анатолий Кулаков" Ну, где-то лет 5 назад, в 2020 году, Джимми решил уйти из этой компании и открыть консалтинговое дело.
1448.64 1486.92 "Анатолий Кулаков" Как он признался, консалтинг идет очень хорошо, там ему платят деньги, у него на это уходит много времени, но минус данной ситуации заключается в том, что на open source проекты совершенно не хватает времени, а точнее, если разобраться, то, по сути, не хватает денег, потому что никто ему не платит за open source проекты, и в результате, если посмотреть на историю гитхаба этих проектов и пересечь ее с историей коммитов Джимми, получается так, что у него не было в последнее время никаких коммитов в этих репозиториях, он не участвовал в обсуждениях вышью, в пул реквестах, в дискуссиях, то есть его там вообще нет практически.
1486.92 1506.20 "Анатолий Кулаков" И вот до него дошло через 5 лет, что в принципе OSS-модель это не самая хорошая модель, если мы вдруг хотим поговорить о том, как бы нам сделать такой качественный, долгоиграющий продукт, который будет все время развиваться, приносить какую-то пользу, ну и качественно поддерживаться авторами.
1506.20 1508.68 "Анатолий Кулаков" И в общем, OSS-модель не отвечает на эти вопросы.
1508.68 1518.12 "Анатолий Кулаков" Вот почему он решил задуматься, что, скорее всего, он хотел бы сделать OSS, ну, open source проекты частью своей собственной работы.
1518.12 1523.40 "Анатолий Кулаков" То есть хотелось бы, чтобы за них ему платили, как это было и на его первой работе.
1523.40 1531.48 "Анатолий Кулаков" И когда за open source проекты платят, то в принципе и разработка, и улучшение их идет довольно качественно и стабильно.
1531.48 1539.00 "Анатолий Кулаков" Вот почему он решил сделать свои проекты под коммерческой лицензией выпустительной.
1539.00 1546.80 "Анатолий Кулаков" А как это будет выглядеть в будущем, то есть как будет выглядеть коммерциализация данных продуктов, он не знает.
1546.80 1550.88 "Анатолий Кулаков" Он просто хочет, чтобы за open source продукты ему платили.
1550.88 1563.36 "Анатолий Кулаков" Как это будет в каких-то там лицензиях или отчислениях или еще что-то, он пока не уверен, но сейчас об этом размышляет и думает.
1563.36 1581.84 "Анатолий Кулаков" Его главная цель это в том, чтобы он стал больше времени тратить, своего дорогого платного времени, больше тратить на эти open source проекты и мог бы вернуться к тем вещам, которые его уже давно, многие годы просят в вышесах добавить какие-то фичи, прооптимизировать какие-то места, устранить какие-то баги.
1581.84 1585.96 "Анатолий Кулаков" В общем все это он мог бы сделать, если бы его время оплачивалось.
1585.96 1595.64 "Анатолий Кулаков" И в принципе вот это главный посыл в его статье.
1595.64 1607.64 "Анатолий Кулаков" Дальше давайте рассмотрим альтернативы, как бы никакого смысла оставаться на этих инструментах больше нет, поэтому альтернатив вокруг полно.
1607.64 1610.92 "Анатолий Кулаков" Прежде всего для автомапера.
1610.92 1619.44 "Анатолий Кулаков" Самый лучший способ, который как бы советуют на каждом углу, когда вы начнете искать самый лучший автомапер, то этот способ называется ручной маппинг.
1619.44 1650.04 "Анатолий Кулаков" Действительно, все те проблемы, которые автомапер нагонял на нас, как рассказывал и показывал, что вот смотрите, как легко вам будет 10 полей перемапить в рантайме с помощью нашей библиотеки, на самом деле на практике не такие уж и страшные, намного проще один раз все эти 10 полей записать ручками в вашем коде, перемапить их явно без всякой магии, с compile time проверками, с понятными комментариями может быть и все, и забыть про это один раз и на всю жизнь.
1650.04 1660.84 "Анатолий Кулаков" Чем при каждом билде, при каждом тесте, при каждом рантайме, при каждом изменении вашей DTO-шки сталкиваться с возможностью рантайм проблем, которые бросит вам автомапер каких-нибудь эксепшенов.
1660.84 1675.44 "Анатолий Кулаков" Автомапер как раз бросает большинство эксепшенов именно в рантайме, поэтому здесь самый прекрасный способ - это просто сделать какой-нибудь метод toResponse допустим у вашего объекта и смапить его просто ручками DTO-шку.
1675.44 1695.48 "Анатолий Кулаков" У Ника Чапсоса есть, опять же, упомянутый уже сегодня, есть прекрасный видосик, который называется "Stop Using Automapper", который как раз-таки рассказывает, что хватит стартать ерундой и напишите уже две строчки маппинга самостоятельно, а не тащите для этого какую-то мега заоптимизированную библиотеку с кучей как бы эверайдов или с кучей непонятного чего.
1695.48 1706.84 "Анатолий Кулаков" Ну, допустим, если вы вдруг пишете приложение, у которого вам нужно очень много маппить, все маппинги очень предсказуемые, да просто перекладываете DTO-шки из одной в другую с одинаковыми именами.
1706.84 1710.76 "Анатолий Кулаков" Допустим, вот такое высокоинтеллектуальное восприложение и все-таки маппинг вам нужен.
1710.76 1715.84 "Анатолий Кулаков" И даже здесь можно найти что-то более элегантное, более интересное, более правильное.
1715.84 1732.96 "Анатолий Кулаков" Наверное, стоит начать как раз-таки с самому близкому к времени разработки плагину, то есть мы говорили, что маппингер бросает эксепшены в ран тайме, это вообще стыд и позор, нужно подвигать выявление ошибок как можно раньше.
1732.96 1739.90 "Анатолий Кулаков" И самое раннее, куда мы можем подвинуть выявление ошибок, это дизайн тайм, то есть в тот момент, когда вы пишете код.
1739.90 1743.28 "Анатолий Кулаков" Есть такой прекрасный плагин для Visual Studio, который называется маппинг-генератор.
1743.28 1761.80 "Анатолий Кулаков" Маппинг-генератор позволяет вам просто нажать Alt+Enter на вашем каком-нибудь там объектике и сгенерировать маппинг, тот, который вам нужен, тот, который вы представляете себе, когда вспоминаете автомаппер, то есть там все поля маппятся, но только явно прямо сейчас в вашем коде.
1761.80 1767.68 "Анатолий Кулаков" И так как это плагин, естественно, никаких зависимостей в ран тайме там у него не будет, то есть то, что вы сейчас сгенерировали, то у вас и остается.
1767.68 1779.24 "Анатолий Кулаков" Этот плагин не стоило бы упоминания, наверное, если бы не его богатое обилие различных опций, то есть как он может маппить, как он там может селектить, как он может конвертеры подставлять, что он может использовать.
1779.24 1788.56 "Анатолий Кулаков" Ну, то есть опции, я думаю, у него не меньше, чем у автомаппера, но только они, эти опции проставляются не в ран тайме, а прямо в прекрасном UI, который здесь же перед вами вылазит.
1788.56 1795.08 "Анатолий Кулаков" Хотя бы просто пройдите по ссылочке и посмотрите на скриншоты окна диалогового настроек этого маппера.
1795.08 1802.12 "Анатолий Кулаков" Я думаю, вы найдете для себя парочку интересных кейсов, о которых вы не задумывались, что их можно и нужно оптимизировать.
1802.12 1808.00 "Анатолий Кулаков" В общем, довольно много удобных интересных ситуаций автор покрыл этим инструментом.
1808.00 1810.84 "Анатолий Кулаков" Далее в приоритетах у нас стоит Mapperly.
1810.84 1817.80 "Анатолий Кулаков" Mapperly – это такой же смысл, как автомаппер, но только работает он на сорс-генераторах.
1817.80 1829.68 "Анатолий Кулаков" У нас уже появились сорс-генераторы, зачем нам падать в ран тайме, если мы можем в compile-time все сгенерить, компилятор нам это точно так же проверит и сгенерит какие-нибудь символы для того, чтобы это можно было дебажить и все такое.
1829.68 1836.04 "Анатолий Кулаков" Ну, то есть прекрасная идея – генерить мапперы с помощью сорс-генераторов и проверять их в билд-тайме.
1836.04 1846.12 "Анатолий Кулаков" Соответственно, так как у нас тут тоже сорс-генераторы, никаких ран-тайм зависимостей у нас нет, никакого рефлекшена не используется, все прямо красиво напрямую в вашем коде.
1846.12 1847.86 "Анатолий Кулаков" Тоже прекрасный инструмент.
1847.86 1859.00 "Анатолий Кулаков" Если вдруг вам все-таки хочется в ран-тайме все этим образом маппить или что-то проджектить или какие-то там динамики-линки строить, то есть мапстер.
1859.00 1867.76 "Анатолий Кулаков" Мапстер кажется, что это вот по функциональности самый близкий, приближенный к автомаперу родственник.
1867.76 1872.38 "Анатолий Кулаков" В общем, библиотек, которые способны маппить – миллион.
1872.38 1877.34 "Анатолий Кулаков" Поэтому, опять же, платить за такую простую функциональность особо смысла никакого нет.
1877.34 1895.54 "Анатолий Кулаков" Ну, может быть, если вы там завезли в каком-то Легосе, где там у вас миллиарды этих автомаппер-правил уже написанных, и переписывать их довольно сложно и муторно, ну, не знаю, тоже нужно будет считать, сколько будет стоить эта лицензия, потому что сейчас автор не знает ни сколько стоит, ни как продавать, ни на сколько мест.
1895.54 1896.54 "Анатолий Кулаков" В общем, все это неизвестно.
1896.54 1903.06 "Анатолий Кулаков" Такое же бредятина, как с флюидто-сердцем случится, когда за одного разработчика просят миллиарды долларов.
1903.06 1908.74 "Анатолий Кулаков" Поэтому, может быть, уже сейчас стоит вам смотреть на какое-нибудь переписывание или на альтернативы.
1908.74 1918.02 "Анатолий Кулаков" Что же касается медиатора, то, в принципе, эта библиотечка может быть немножко сложнее, чем автомаппер, но не сильно.
1918.02 1921.14 "Анатолий Кулаков" На самом деле, задача медиатора довольно проста.
1921.14 1926.74 "Анатолий Кулаков" Возьми мне команду Эликвери, достань хендлер и запусти-ка хендлер с этой командой Эликвери.
1926.74 1928.34 "Анатолий Кулаков" Вот, в принципе, и все.
1928.34 1932.06 "Анатолий Кулаков" Если немножко так подумать, то ту же самую задачу сделает контейнер.
1932.06 1937.94 "Анатолий Кулаков" То есть вам нужно из контейнера достать просто по определенному типу хендлер и вызвать этот хендлер.
1937.94 1940.20 "Анатолий Кулаков" Вот как бы и все.
1940.20 1948.30 "Анатолий Кулаков" Автомаппер, сорян, медиатор действительно добавляет каких-нибудь пайплайнов, бихевер, которые 99% людей никогда не используют.
1948.30 1950.98 "Анатолий Кулаков" Поэтому, возможно, оно вам не нужно.
1950.98 1957.10 "Анатолий Кулаков" А даже если нужно, то их проэмулировать тоже довольно легко и просто, можно буквально десятью строчками кода.
1957.10 1961.30 "Анатолий Кулаков" В общем, если разобраться, то медиатор в основном не нужен.
1961.30 1965.82 "Анатолий Кулаков" У нас даже на Дотнексте было несколько докладов про эту тему, что медиатор вам не нужен.
1965.82 1976.14 "Анатолий Кулаков" Но бывают ситуации, когда он вам нужен, и для этих ситуаций есть тоже куча подходов, как сделать свой медиатор или взять уже готовый.
1976.14 1982.38 "Анатолий Кулаков" То есть очень много таких in-memory message bus, коим по сути является медиатор, существует на рынке.
1982.38 1990.34 "Анатолий Кулаков" Многие приложения, как FastAPI, как Wolverine, просто из коробки предоставляют это как часть своей функциональности.
1990.34 1996.02 "Анатолий Кулаков" В общем, найти замену альтернативы медиатору или просто написать свою никаких проблем нет.
1996.02 2007.74 "Анатолий Кулаков" Я, в принципе, в одном из ближайших проектов, который делал, когда мне понадобилась действительно такая подобная шинка для медиатора, естественно, не стал его тащить из-за своей монструозности.
2007.74 2015.66 "Анатолий Кулаков" Просто за один вечер написал свой медиатор с практически аналогичной функциональностью, с behavior'ами и с подобным.
2015.66 2020.90 "Анатолий Кулаков" В общем, это не составляет каких-то особых проблем, опять же, никакого rocket science здесь нет.
2020.90 2023.50 "Анатолий Кулаков" Поэтому желание, наверное, похвальное.
2023.50 2032.98 "Анатолий Кулаков" Разработчики все-таки open-source проектов должны как-то зарабатывать, но кажется, что должны они зарабатывать как-то более честно, более достойно, чем на подобных вещах.
2032.98 2045.20 "Анатолий Кулаков" Ну, а если вы какой-то огромный фанат медиатора и автомапера, таких тоже у нас полно, я знаю, то, может быть, вы подумаете, что вам удобнее заплатить и поддержать автора и продолжить пользоваться этими продуктами.
2045.20 2047.28 "Анатолий Кулаков" Посмотрим, посмотрим, что скажет ценовая политика.
2047.28 2048.28 "Анатолий Кулаков" А пока так.
2048.28 2065.04 "Игорь Лабутин" Да, я так понимаю, что пока совершенно непонятно, какая эта самая политика будет, поэтому сложно пока рассуждать, насколько там все плохо-неплохо и готовы ли будут, и какая там будет типа лицензии, не знаю, может, на каждого разработчика нужно будет платить по много долларов в год.
2065.04 2066.04 "Игорь Лабутин" Именно так.
2066.04 2067.04 "Игорь Лабутин" Ну, посмотрим.
2067.04 2068.04 "Игорь Лабутин" Да.
2068.04 2077.44 "Анатолий Кулаков" У нас существует очень много проектов, которые принципиально не связываются с любыми намеками на коммерциализацию, например, АПП-фреймворк, всеми известный.
2077.44 2094.52 "Анатолий Кулаков" В общем, он говорит, что мы изначально чистые, красивые, остаемся open-source, и, к сожалению, используем автомапер, поэтому у них уже есть тишью, которая говорит о том, что давайте избавимся от него, переведем на что-то другое, в общем, поэтому большинство проектов, опять же, начнут от него просто избавляться.
2094.52 2107.44 "Игорь Лабутин" Ну, я так понимаю, что там как раз-таки и сказано в этой иши, что мы ждем хоть каких-то деталей на тему того, какая будет лицензия и сколько это все будет стоить, и после этого мы в этом ише обновим и скажем, что вам делать, как пользователям.
2107.44 2109.68 "Игорь Лабутин" Ну да.
2109.68 2125.24 "Игорь Лабутин" Ладно, пойдем дальше, вернемся к Aspire, как я сказал, что в Aspire у нас теперь месячные релизы, так что по идее каждый второй выпуск мы должны хоть что-то рассказывать примерно про Aspire, потому что мы тоже выходим примерно пару раз в месяц.
2125.24 2127.16 "Анатолий Кулаков" Да, мы каждый первый рассказываем.
2127.16 2163.00 "Игорь Лабутин" Да вот, да, в этом выпуске прям много Aspire, но действительно я не собирался рассказывать про релиз, но релиз вышел внезапно, за час до того, как мы сели писать выпуск, я увидел новость, но быстренько добавил эту новость тоже, раз уж у нас выпуск наполовину про Aspire, потому что, как я сказал в обзоре будущего, казалось бы, всякие паблишеры, диплойменты и прочее, это выглядит как цель на какой-нибудь Aspire 10, над которым думает Дэвид Фаулер с точки зрения как это красиво сделать, но нет, в 9.2 уже появился новый тип интегрейшенов, который называется паблишеры.
2163.00 2168.88 "Игорь Лабутин" Вот, но до них мы дойдем, сначала несколько других новостей по поводу этого релиза.
2168.88 2183.84 "Игорь Лабутин" Во-первых, тут еще на днях, ну как на днях, на самом деле где-то в начале недели, вышел очередной техрадар от ThoughtWorks, не знаю, будем ли мы его как-то отдельно обозревать или нет, посмотрим, я его еще не читал, но там есть Aspire.
2183.84 2190.56 "Игорь Лабутин" Помнишь, мы много раз обозревали техрадар, и как-то там было мало чего-либо про .NET.
2190.56 2193.76 "Анатолий Кулаков" Ну да-да, всегда на это жаловались.
2193.76 2195.44 "Игорь Лабутин" Вот теперь Aspire там.
2195.44 2197.20 "Анатолий Кулаков" Не знаю, правда.
2197.20 2198.20 "Анатолий Кулаков" Хотя бы что-то одно, да?
2198.20 2199.20 "Анатолий Кулаков" Да-да-да.
2199.20 2200.72 "Анатолий Кулаков" Все равно все еще мало, но хотя бы вот.
2200.72 2207.56 "Игорь Лабутин" Не знаю пока в каком статусе, вероятно, в каком-нибудь SS, скорее всего, или Trial, как он там называется, не помню, но в общем.
2207.56 2216.24 "Анатолий Кулаков" И интересно, как они его применят, у них же там тоже не то чтобы много .NET, кто у него, Distributed Log Viewer или что они с него будут, как они его используют.
2216.24 2217.24 "Игорь Лабутин" Не знаю.
2217.24 2229.48 "Игорь Лабутин" Я пока не читал, не смотрел, может быть, в следующем разу посмотрю, прочитаю, у меня были планы для себя посмотреть на техрадар, что-то новенького, заодно может, если что-то новенькое увижу, расскажу в подкасте.
2229.48 2236.40 "Игорь Лабутин" Кроме этого, в релизе, как я говорил, основная цель это inner loop, поэтому у нас очередные фичи в дашборде.
2236.40 2266.56 "Игорь Лабутин" Во-первых, появился ресурс-граф, то есть напомню, что у нас можно посмотреть список ресурсов в дашборде, было какое-никакое дерево, как я понимаю, но там, судя по комментариям к ютубу нашему выпуску, где я про это рассказывал, не очень, так сказать, прям продвинутое дерево, но теперь есть еще режим графа, когда у вас все зависимости между вашими компонентами показываются в виде красивого, или не очень красивого графа, в зависимости от того, какие у вас зависимости, в зависимости от зависимостей, да.
2266.56 2291.56 "Игорь Лабутин" Дальше можно для ресурсов добавлять кастомные урлы, то есть вы создаете какой-нибудь там ваш ресурс, и дальше в него просто в коде пишите with URL, with URL, with URL, эти урлы, Aspire ничего с ним не будет делать, как бы он не будет там дополнительно ничего конфигурировать, но эти урлы будут дополнительно видны на дашборде, и на них можно будет кликнуть, грубо говоря, и перейти к этому ресурсу.
2291.56 2400.26 "Игорь Лабутин" Дальше есть такое понятие ресурс диплинкинг, эта штука заключается в следующем, если у вас есть какой-то ресурс, например, не знаю, Redis, и вы говорите, а вот мое приложение использует Redis, это просто линкинг, да, вы просто из одного ресурса сослались на другой, а может быть другое, то есть у вас есть ресурс под названием сервер Postgres, от этого ресурса вы создаете дочерний ресурс под названием база данных Postgres, и именно на этот дочерний ресурс вы делаете зависимость, это называется диплинкинг, оно было поддержано только для некоторого количества баз данных и одной или двух, по-моему, интегрейшенов для ресурсов в ажуре, сейчас это дело расширили еще на 5-6 ресурсов в ажуре, соответственно, если вы пользуетесь ажуром, вот можно теперь прям более красиво пользоваться, а если же вы не пользуетесь ажуром, или пользуетесь чем-то другим, или вообще вам это все не интересно, то есть теперь тоже интересная штука, называется CustomHttpCommands, в которой теперь они встроены, значит есть новая API, это WithHttpCommand, и судя по всему это, я так понимаю, что было раньше в какой-то библиотеке, в compile toolkit или еще где-то, потому что это штука, которая позволяет вам сделать некоторую команду, которая показывается как команда кнопка на дашборде, но делает посылать кастомный, потому что это по реквесту вашему приложению, то есть вы можете, не знаю, сделать кнопку сбросить кэши, которая дернет специальный endpoint, по которому ваше приложение сбросит кэши, в принципе, наверное, удобно, особенно для локальной разработки вообще должно быть прекрасно.
2400.26 2413.92 "Игорь Лабутин" Вот, это то, что касается дашборда, а теперь то, что касается интегрейшенов новых, которые называются паблишинги, и первый, который появился, это Docker Compose.
2413.92 2509.84 "Игорь Лабутин" Значит, паблишеры вообще определяют, как я уже говорил, про то, как ваше приложение будет запаковано и задеплоено куда-либо еще, они, значит, поработали со спирейтом, с автором спирейта, напомню, что это тул, который позволяет вам из JSON схемы получить либо кубернетовский, соответственно, как там его называют, слово вылетело из головы, короче, скрипт для кубера, грубо говоря, да, конфиг, либо же Docker Compose конфиг, вот, в данном случае сейчас поддержан паблиш докер композ, все это пока в превью, и выглядит это следующим образом, для того, чтобы это сделать, нужно в вашем апхасте, во-первых, сослаться на aspire-hosting-docker-nuget-packet, дальше внутри, в апхасте, в коде написать builder.add-docker-compose-publisher, то есть добавить паблишер в качестве такого интегрейшна, ну и потом добавить тот самый command-line-interface, то есть вы делаете .net-tool-install-aspire.cli - -pre-release, то есть есть pre-release command-line-tool, и дальше у вас появляется командочка aspire-publish, то есть вы в вашем папочке, где у вас есть ваш aspire проект, говорите aspire-publish, и у вас рядом появляется docker-compose-yaml вместе с .env файликом, в котором описаны все нужные переменные, так чтобы ваши приложения правильно друг от друга зависели.
2509.84 2514.68 "Игорь Лабутин" И таким образом вы дальше можете сказать docker-compose-up, и все должно заработать.
2514.68 2525.52 "Игорь Лабутин" Максимально просто, так сказать, максимально встроенный экспириенс, не нужны никакие внешние теперь плагины, так скажем, в виде аспирейта, чтобы это все заработало.
2525.52 2529.64 "Игорь Лабутин" В общем, первый маленький шажочек к тому, чтобы что-то делать с дипломентом.
2529.64 2555.10 "Игорь Лабутин" В дальнейших планах, понятное дело, расширение всего этого до кубера, то есть Дэвид в видео упоминал, что вообще говоря цель поддержать нативно паблишинг в кубернетис, но тут еще, я так понимаю, довольно долго к этому всему идти, потому что docker-compose это простая штука, кубернетис штука сложная, и все манифесты для него писать это прям, видимо, надо сильно поработать.
2555.10 2558.94 "Игорь Лабутин" Ну аспирайт справился, значит и aspire тоже справится.
2558.94 2562.50 "Игорь Лабутин" Такие дела, на этом, наверное, про aspire на сегодня все.
2562.50 2563.50 "Игорь Лабутин" Я надеюсь.
2563.50 2565.66 "Игорь Лабутин" Да, ну не может быть.
2565.66 2567.82 "Игорь Лабутин" Ну я постараюсь удержаться.
2567.82 2574.86 "Анатолий Кулаков" Я думаю, норму про aspire мы сегодня выполнили, но хотя я не удивлюсь, если где-то там всплывет у нас.
2574.86 2580.50 "Анатолий Кулаков" Слушай, но у меня драмы не кончаются, ведь у нас еще одна драма случилась, и как ни странно, того же 2 апреля.
2580.50 2585.10 "Анатолий Кулаков" Мастранзит теперь тоже становится коммерческим и закрытым продуктом.
2585.10 2588.62 "Анатолий Кулаков" Давайте немножко разбираться.
2588.62 2608.54 "Анатолий Кулаков" Так, мастранзит, об этом объявил Крис Паттерсон, также известный как Fatboy, и написал он в своем блоге тоже оправдательный пост, типа, что случится, но там уже более основательно видно, что человек лучше работает с энтерпрайзом, лучше понимает, как этот рынок устроен, и лучше расписал, а что же он все-таки ожидает.
2608.54 2610.98 "Анатолий Кулаков" Поэтому давайте все-таки посмотрим.
2610.98 2622.26 "Анатолий Кулаков" Итак, для тех, кто не знает, мастранзит – это, наверное, действительно, лидер среди опенсорсных решений для организации месседжинга.
2622.26 2630.28 "Анатолий Кулаков" Многие тысячи разработчиков и различных компаний используют его для построения различных масштабируемых распределенных приложений.
2630.28 2640.50 "Анатолий Кулаков" Этот фреймворк позволяет вам как раз-таки абстрагироваться над различными брокерами сообщений и обмениваться непосредственно сообщениями.
2640.50 2654.02 "Анатолий Кулаков" Он поддерживает различные базы данных, очень много интересных стратегий распределенных, например, у него там из коробки Saga есть, routing slips, также он поддерживает отложенные сообщения, скедулинг отложенных сообщений.
2654.02 2664.62 "Анатолий Кулаков" В общем, очень-очень фичастый фреймворк, и он таким фичастым был, не знаю, лет десять, я помню, назад познакомился еще с мастранзитом, и уже тогда в нем практически все эти фичи были.
2664.62 2685.50 "Игорь Лабутин" И мне тут кажется, что, вот сейчас сформулирую, здесь, в отличие от автомаппера и медиатора, здесь прям именно во фреймворке есть смысл, то есть он же абстрагирует тебя от того, что там у тебя внутри под капотом с точки зрения месседжинга, и это очень сильно помогает.
2685.50 2692.74 "Игорь Лабутин" Особенно в случаях, когда ты используешь какой-нибудь месседжинг, который ты не можешь локально поднять у себя, например, какой-нибудь ажурный, раньше не был.
2692.74 2698.78 "Анатолий Кулаков" Да, да, и плюс у него между разными облаками, ажурами, авсами, гуглами, у него тоже вся эта абстракция есть.
2698.78 2703.78 "Анатолий Кулаков" Абстракции у него очень много, и над базами, и над брокерами, и над облаками, в общем, как я уже сказал.
2703.78 2713.34 "Анатолий Кулаков" И кроме абстракции, он еще очень много интересных стратегий различных добавляет, которые тоже, если реализовать самому, то очень нетривиально, и 100% добудет кучу ошибок.
2713.34 2721.18 "Анатолий Кулаков" В общем, такой фреймворк большой, развесистый, узнаваемый, все его любят, все его знают, но он решил поменяться.
2721.18 2723.14 "Анатолий Кулаков" Что же, собственно, изменится?
2723.14 2734.10 "Анатолий Кулаков" Изменится в том, что он хочет, в принципе, как и Джимми, больше времени и больше качества уделять своему фреймворку.
2734.10 2748.82 "Анатолий Кулаков" Крис, Крис хочет выделить каких-то разработчиков на полное время, для того, чтобы они лучше уживались с теми багами и фичами, которые от них просит сообщество.
2748.82 2751.66 "Анатолий Кулаков" Ну, в данном случае, наверное, уже будет не сообщество, а какие-то большие компании.
2751.66 2773.86 "Анатолий Кулаков" Он хочет предоставлять настоящий enterprise support и гарантии по стабильности продукта, и он хочет выработать стабильную модель привлечения финансов для того, чтобы предсказуемо внедрять какие-то инновации, исследовать новые технологии и внедрять их в этот продукт, ну, то есть, по сути, развивать.
2773.86 2778.46 "Анатолий Кулаков" В общем, как же он это себе видит, как мы планируем поступить?
2778.46 2784.74 "Анатолий Кулаков" А планируется выпустить новую версию Мастер Анзита под версию 9, сейчас, я напомню, стабильная версия 8.
2784.74 2791.62 "Анатолий Кулаков" В общем, планируется выпустить версию 9, и эта версия 9 сразу изначально будет только под коммерческой лицензией.
2791.62 2810.70 "Анатолий Кулаков" Все новые фичи, которые будут выходить, все перфоманс, улучшения, всякие интерпрайс фишки, которые он планировал, всякие SLA и различные гарантии, и различные поддержки, все они будут эксклюзивно добавляться только в девятую ветку, то есть, в девятую версию.
2810.70 2825.14 "Анатолий Кулаков" Версия восьмая, которая сейчас существует, останется навсегда опенсорсной, она будет доступна под теми же лицензиями, под которыми есть сейчас, и у нее останется комьюнити саппорт, поддержка от сообщества.
2825.14 2833.74 "Анатолий Кулаков" Также все критические секьюрити патчи и критические баги будут в восьмую ветку внедряться тоже.
2833.74 2836.94 "Анатолий Кулаков" То есть, кажется, что без секьюрити фиксов нас не оставят.
2836.94 2849.14 "Анатолий Кулаков" И также команда торжественно пообещала, что переход с восьмерки на девятку они будут делать максимально безболезненной и плавной, ну то есть, если вы захотели заплатить, то вам переход практически ничего не стоил.
2849.14 2853.14 "Анатолий Кулаков" Интересно, если обратно, наверное, вряд ли.
2853.14 2868.34 "Анатолий Кулаков" Если подробнее разложить по датам, то где-то в третьем квартале 2025 года планируется выпустить при релизе девятой ветки, девятой версии, для того, чтобы как раз early адаптеры начали уже как-то с этим играться.
2868.34 2874.74 "Анатолий Кулаков" В первом квартале 2026 года уже планируется официальный релиз девятки, под коммерческой лицензией сразу.
2874.74 2881.98 "Анатолий Кулаков" В это время восьмая версия будет получать секьюрити патчи, как и обещалось, и поддержку от сообщества.
2881.98 2888.42 "Анатолий Кулаков" И после 2026 года они планируют прекратить официальную поддержку Мастранзита 8.
2888.42 2898.02 "Анатолий Кулаков" То есть, восьмая версия, она, конечно, останется навсегда с вами и все такое, но после 2026 года туда не будут сыпаться даже секьюрити патчи и критикал бэкфиксы.
2898.02 2905.42 "Анатолий Кулаков" Ну, то есть, можно считать, что ветка, скорее всего, станет бесполезной, если, опять же, кто-то ее не форкнет и не начнет разрабатывать рядышком.
2905.42 2921.34 "Анатолий Кулаков" Интересные вопросы, да, если у вас остались вопросы там по переходу или по ценовой политике, то можно пройти по ссылочке, там есть статья, и там обсуждаются более подробно все это.
2921.34 2928.02 "Анатолий Кулаков" Ну, в частности, ценовую политику я не озвучивал, она там продолжает меняться, я заходил недавно, и там по-прежнему добавляются какие-то изменения.
2928.02 2937.02 "Анатолий Кулаков" Но Крис рассказывает, что у него не будет каких-то там глупых, заковыристых, интересных per-development-seeds лицензий.
2937.02 2951.62 "Анатолий Кулаков" Лицензия будет очень простая, он поделит все компании на маленькие, средние и большие, выдаст там какую-то вполне адекватную сумму, там что-то около 400 баксов в месяц, по-моему, что-то в этом духе.
2951.62 2963.38 "Анатолий Кулаков" Одно из интересных тоже улучшений, которое было, он изначально планировал выдавать лицензию, которая в рантайме проверяла бы, не истек ли ее срок, и если истек, то предложение прекращало бы работать.
2963.38 2981.02 "Анатолий Кулаков" Но ему интересно намекнули, что типа MasterNZ это настолько крутая штука, что она используется где-то в медицине, в финансах, в транспорте, в общем, в критикал местах просто, которые если вдруг почему-то админ проспал и лицензию не обновил, и они рухнут, эти места, то станет плохо там нескольким городам сразу.
2981.02 2995.26 "Анатолий Кулаков" Поэтому эта часть, например, буквально недавно изменилась, он говорит, что хорошо, сделаем лицензию другую, сделаем лицензию так, что если ты с ней задеплоил, она будет работать вечно, но если ты хочешь новый деплой сделать, тебе нужна новая лицензия.
2995.26 3011.54 "Анатолий Кулаков" Какие-то у него сейчас такие вот рассуждения, но в общем, человек разумный, человек правильный, опять же, он много лет в бизнесе, очень много и качественно ведет этот продукт, поэтому я думаю, что у него, в отличие от остальных ребят, в общем, с новой полиникой все будет хорошо и все будет прекрасно.
3011.54 3020.98 "Анатолий Кулаков" И еще один интересный вопрос, которым постоянно задают, вы с Джимми синхронизировались, чтобы 2 апреля оба выпустить этот анонс?
3020.98 3032.14 "Анатолий Кулаков" На что он ответил, нет, нет, это действительно чистая случайность как бы, но вот так получилось, что хотели 1 апреля, но не стали, и поэтому получилось второго.
3032.14 3109.90 "Анатолий Кулаков" Теперь давайте подумаем, вот у нас случилась там куча каких-то коммерциализаций, возможно, мы в будущем еще их увидим, целую большую кучу, вот у нас был там fluent association, мы его обсуждали, автомапер, медиатор, масс-транзит, и вот кажется, что в принципе все едино, берет какая-то open source библиотека, закрывается коммерческая лицензия, все сваливают на что-то другое, но вот масс-транзит здесь действительно очень сильно выделяется, потому что если там fluent association, где мы просто ивчик какой-то с красивым сообщением, захотелось нас денег задрать, с автомапером, где-то мы просто парочку полей друг-друга переложили, с медиатором, который разрезал фабрику и вызвал там хендлер, это все звучало как-то смешно, но если мы посмотрим на масс-транзит, то тут Игорь действительно правильно упомянул, здесь отличный слой абстракции, шикарная поддержка разных облаков, разных провайдеров, шикарная реализация дистрибьюта всяких очередей, и это сделано не просто на коленке, это сделано командой нормальных профессионалов, здесь реально есть за что заплатить, поэтому в отличие от остальных проектов, мне кажется, что у этого единственного пока на данный момент из тех, которые мы обсуждали, есть шанс не умереть, а выйти на какую-то понятную прибыльную ветку.
3109.90 3133.18 "Анатолий Кулаков" Также Крис не исключил, что в принципе в будущем девятая версия может стать open-source, то есть он код к ней может открыть, она по-прежнему останется под коммерческой лицензией, но может быть код будет открыт, также он может рассмотреть какие-то нон-профит лицензии и так далее, но пока об этом говорить рано, в общем пока это все такое в состоянии договоренности и стабильности.
3133.18 3135.70 "Анатолий Кулаков" Куда же бежать с Мастранзитом?
3135.70 3148.62 "Анатолий Кулаков" Как ни удивительно, нормальных open-source, настолько мощных развесистых фрейдворков их нет, вот почему Мастранзит приобрел такую большую популярность, потому что если мы берем open-source, то это реальный лидер.
3148.62 3185.30 "Анатолий Кулаков" Вы можете найти какие-то там абстракции на какой-то конкретный транспорт, на 2, на 3 транспорта, но может у него не будет каких-то distributed алгоритмов, может он не будет поддерживать всех клауды, в общем с какими-то ограничениями может быть отыскать можно, но вот такого полноценного, если вы полностью, знаете, продались в Мастранзиту, то наверное выбора у вас не особо много, но вот зато если мы пойдем все-таки в коммерческие предложения, то там Мастранзиту может быть не так одиноко, потому что уже давно существует nServiceBus, это очень успешная поделка от тоже неглупых людей, и она там зарабатывает довольно хорошо и довольно стабильно, в общем там посмотрим, как он будет с ними тягаться.
3185.30 3199.50 "Анатолий Кулаков" Я думаю обо всех этих новостях, о сравнении с другими конкурентами и о том, куда это все пойдет, мы с вами еще не раз поговорим, в общем поэтому не переключайтесь, оставайтесь с нами, все это мы еще предстоит в будущем разобраться.
3199.50 3209.38 "Игорь Лабутин" Да, будут новости, будем дальше рассказывать, примерно так же, как мы рассказываем про новости, которых довольно давно не было.
3209.38 3220.22 "Игорь Лабутин" Появилась статья JetBrains про ReSharper out of process, как ты думаешь, когда мы в последний раз трогали тему про то, что ReSharper собирается быть out of process?
3220.22 3228.18 "Анатолий Кулаков" Мне кажется там когда Rider выходил, ну типа они сделали out of process и казалось, что там взяли от Rider и прицепили к студии, вот тебе ReSharper.
3228.18 3259.98 "Игорь Лабутин" Ну типа того, да, казалось действительно, что все должно быть так просто, потом у нас был, по-моему даже на dotnext был доклад про их клевый протокол, общение между собственно back-end и front-end, этот Rd который, где-то короче было про него обязательно, регулярно было 5 или 6 статей про то, как значит ReSharper двигается в out of process, у меня было полное впечатление, что там, ну хоть что-то уже работает, в смысле что в реальном ReSharper уже так, оказалось нет.
3259.98 3287.02 "Игорь Лабутин" Ну не раз мы это трогали, в июле 24 года была статья про то, что они сделали асинхронный тайпинг, то есть то, что тайпится, оно асинхронно закидывается в back и там в зависимости от разных условий как-то процессится, ну в общем короче вышла новая статья, она кстати вышла 1 апреля, но вроде бы, я всячески искал подвох, но вроде все нормально, подвоха нету или я не нашел, расскажите мне, если я что-то не заметил.
3287.02 3292.94 "Игорь Лабутин" Статья такая довольно монументальная в том плане, что она опять начинается с начала, а нафига она вообще out of process.
3292.94 3319.86 "Игорь Лабутин" Ну там понятное рассуждение про то, что ReSharper живет внутри Visual Studio, Visual Studio все-таки это один процесс, как-то нам нужно очень сильно поменять архитектуру, чтобы все-таки основные проблемы перформанса полечить, много чего жило на главном потоке окна, соответственно если ReSharper начинала заниматься чем-то, то окна визуально начинали тормозить, в смысле ваш, отзывчивость основных окошек.
3319.86 3328.66 "Игорь Лабутин" Плюс, соответственно, garbage collector, вот это все, и поэтому надо делать все-таки out of process.
3328.66 3348.06 "Игорь Лабутин" Значит, как же к этому подходили, ну самый большой челлендж это сделать out of process, при этом поддерживая backward compatibility для фич внутренних, в том плане, что нельзя остановиться и перестать поддерживать новые фичи языка, пока мы делаем, переписываем на out of process вариант.
3348.06 3378.06 "Игорь Лабутин" С другой стороны, потратить ресурсы и писать полностью второй ReSharper рядом тоже как-то странно, поэтому пришлось сделать по-живому, соответственно для каждой, грубо говоря, функциональной области внутри ReSharper есть переключалка, которая говорит, где же оно должно работать, соответственно, в студии или во внешнем процессе, в зависимости от этого, немножко меняется то, как с этими компонентами общаются, как они общаются друг с другом.
3378.06 3392.26 "Игорь Лабутин" Ну и в итоге это привело к тому, что каждая такая компонента может быть отдельно, независимо протестирована, убедиться, что она работает нормально в новом окружении, в старом окружении, ну и потом потихонечку все больше и больше компонентов таким образом переводить в out of process режим.
3392.26 3408.90 "Игорь Лабутин" Как я уже сказал, в out of process режиме нужно с этим самым внешним процессом или процессами коммуницировать, для этого используется RD, это open source протокол, который между, соответственно, двумя или больше процессами работает.
3408.90 3416.46 "Игорь Лабутин" И с UI-паузами есть, как я сказал, три проблемы.
3416.46 3442.82 "Игорь Лабутин" Во-первых, в .NET, в оконных фреймворках, как и во многих других местах, приходится часть работы делать обязательно на потоке главного окна, и, соответственно, чем больше вы там делаете работы, тем менее отзывчивым будет интерфейс, а понятное дело, что анализ исходного кода по мере того, как вы пишете код, это прямо отнимает некоторое время, перестраивать все эти внутренние модели, поэтому это одно.
3442.82 3455.90 "Игорь Лабутин" Второе, в ReSharper'е был Global некоторый лог, под которым обновлялась модель, и из-за этого были некоторые проблемы с тем, как на этом логе собирались очереди.
3455.90 3473.10 "Игорь Лабутин" Ну и Garbage Collector, как я сказал, понятно, что чем больше вот эта вся модель весит и постоянно обновляется в памяти само Visual Studio, тем Garbage Collector от .NET, соответственно, сильно на нее влияет на общую производительность.
3473.10 3487.18 "Игорь Лабутин" Это все, конечно, здорово, но и говорить, что вот, мы улучшим, углубим, расширим и так далее, нам было бы здорово все-таки их как-то измерить.
3487.18 3559.70 "Игорь Лабутин" Они сделали, в итоге провели некоторые тесты, то, что называется Real-World Typing Responsiveness, и в итоге попробовали 6 разных видов тестирования, грубо говоря, у них есть ключевые названия всякие, no delay, no overlap, то есть когда мы быстро печатаем, но каждый клавиши ждет, пока результат предыдущий будет от процесса, то есть, как говорится, ReSharper обработал все, что можно было обработать после нажатия прошлой клавиши, нажимаем следующее автоматически, соответственно, дальше есть некоторые паузы между такими нажатиями, дополнительно к тому, что все обработано, дальше, соответственно, фиксированные интервалы между нажатиями, без дожидания, и дальше еще пара режимов, когда время между нажатиями как-то варьируется, эмулирует, тем самым, реальное печатание мы все-таки не печатаем с какой-то фиксированной скоростью нажатия, мы где-то задумываемся, где-то больше задумываемся, где-то меньше задумываемся, вот, соответственно, эти все тесты как-то показывают.
3559.70 3830.10 "Игорь Лабутин" Ну и в наиболее реалистичном тайпинг сценарию они говорят, что средняя медианная скорость, медианная latency, точнее, которая заметна, упала за 26 мс до 16 мс, что в абсолютных числах вроде бы и было-то немного, но стало, ну если не в 10, то почти, ой, не в 2, то почти в 2 раза лучше, ну, хороший результат, это как бы примерно 37% в тайпинг latency, и в принципе это заметно, что кажется, что такой более то, что называется smoother, как-то сказать, более плавный экспириенс, дальше, если посмотреть внимательно на паузы, которые случались в UI трейде и взять только те, которые занимали больше 100 мс, то, посчитав вот их количество, то в том режиме, как сейчас работает ReSharper, там вынесены далеко не все еще ваутов в процесс, но даже этого хватает, чтобы количество таких пауз уменьшить на 600%, то есть в 6, сейчас, уменьшить на 100% это в 2 раза, да, 600% это что у нас получается, в общем во много больше раз, вот, уменьшить, то есть длинных пауз стало существенно меньше, и 99% вот этого самого респонс тайма упал с 316 мс, а это уже прям заметная задержка на самом деле, когда вы печатаете, до 41 мс в out-of-process режиме, в общем, по числам получается прям вообще супер должно быть хорошо, и все должно прекрасно и быстро теперь работать, но работает далеко не все, значит, что уже точно работает в out-of-process режиме, это всякое, ну, фишки, которые, так скажем, основные, то есть навигация, completion, рефакторинги, код анализис, всякие улучшатели редакторов, то есть typing assistant, и параметры инфотеки, хинты и прочее, весь код мейнтенанс, то есть cleanup, форматинг, quick fix, generation, управление проектами, solution builder, запуск, tool window все могут быть вынесены в out-of-process, unit testing, но без дебаггинга, и c++, кусочек решапера тоже работает, вот, есть проблемы еще пока известные, над которыми работают, если у вас установлен запущен dot memory, dot trace или dot cover, то out-of-process режим пока не работает, то есть в этом случае надо их либо отключать, либо еще что-то делать, чтобы out-of-process режим заработал, вот, и есть некоторые фичи, которые, так скажем, сломаны, так скажем, вот, которые пока еще требуют некоторой работы, это всякая интеграция с искусственным интеллектом, часть фичей дебаггера, всякие спеллчеки, редактор шаблонов, search replace, который структурный, regexp и диаграмминг, вот это все пока не работает в out-of-process режиме, надо все это фиксить, но это все хорошо, мы уже таких статьей видели немало, хотя с таким объемом подробностей не было, пожалуй, мне кажется, вот, но что дальше-то, что, когда-когда-когда, мне казалось, что все это уже работает, и те, кто пользуется решарпером, могут уже все это испытывать на себе, но оказалось, что нет, то есть статья говорит, что после многих лет работы и месяцев внутреннего тестирования мы наконец-таки почти приблизились к моменту, когда мы можем это все выкатить в паблик тестирования, вот, мы почти готовы выпустить такой билд для вас в течение нескольких месяцев, ну и если вам это прям очень интересно, вы супер этого ждете, там, значит, есть в статье ссылочка на issue на u-треке, которая позволит следить за тем, там точно будет опубликовано, что да, вышел какой-нибудь там, не знаю, превью, яб, еще кто-нибудь, который поддерживает этот самый out-of-process режим, и вы можете его попробовать, в общем, пока нету, но мы ждем ближайшие месяцы, как выйдет, мы, естественно, ждем. Такие дела, большая работа проделана, видимо, за несколько месяцев нужно доделать еще некоторые кусочки, чтобы все это было совсем уж прям гладенько и прекрасно. Ну, смотри, я проверил, релиз
3830.10 3871.50 "Анатолий Кулаков" райдера состоялся в 2017 году, то есть это получается сколько у нас, 7 лет, 7 лет назад, у райдера уже был как бы отцепленный движок решарпера, ну то есть как раз там наша мысль, что раз у райдера отцепили, значит и в Visual Studio там тоже отцепить, пару месяцев как раз нам осталось до этого дождаться, то есть 7 лет ребята что-то колбасили. Мне вот интересно, а как это изменение пропихивается вот всяким продукт-тонером и менеджером, то есть а нафига, где здесь value, какой профит они от этого получат с точки зрения нашего пользователя, который за этим сидит, что у него тайпинг улучшится, вот 7 лет работать на то, чтобы он тайпил побыстрее?
3871.50 3919.98 "Игорь Лабутин" Ну, непонятно, непонятно. То есть с одной стороны, я тоже думал про то, что окей, райдер сделали, соответственно решарпер точно умеет работать в отдельном процессе, но видимо надо понимать, что райдер это все-таки, грубо говоря, интеллиджейный фронтенд, плюс-минус с решарперным бэкэндом, то есть тут все-таки не нужно дружить всякие тул-окна и прочее, да, и студийные прямочки, то есть я так подозреваю, что здесь была чуть более простая задача, тебе нужно было просто весь решарпер вынести наружу, вот, а в студии надо все-таки его попилить где-то в серединке, потому что половина решарпера это всякие окошки настроек, да, всякие хинты, подсказки и прочее, это же все тоже часть решарпера, и вот тут нужно поделить его где-то в серединке, видимо
3919.98 3929.50 "Анатолий Кулаков" это сложно. Ну да, понятно, что эти процессы одинаковые только для тех, кто не соображает, потому что внутри там абсолютно все разное, им надо много
3929.50 3936.18 "Игорь Лабутин" всего переделывать. Да, а вот как этим заниматься так долго? Ну слушай, может там сидит один-два человека, которые этим неспешно занимаются, ну и нормально.
3936.18 3953.06 "Анатолий Кулаков" Да, ну посмотри там список фэнксов в конце статьи, там не то чтобы два, ну так пяток, при том знатных фамилий, то есть грамотных людей сидело. Ну ладно, чего, делают и делают, хорошо, может еще через семь дождемся.
3953.06 3959.34 "Игорь Лабутин" Ну несколько месяцев осталось, несколько месяцев. Там правда в комментах к статье уже написано, типа блин, вы бы лучше фиксили там остальные штуки.
3959.34 3971.84 "Анатолий Кулаков" Да, да, там такие баги есть, что как бы я не знаю, зачем они этим занимаются. Ну будет интересно посмотреть, вот их наверно аналог какой-то большой будет, как они будут подносить эту фичу людям, то есть они что-то обещают.
3971.84 3976.04 "Анатолий Кулаков" Будет быстро, будет быстро, ну ReSharper тормозит, подожди,
3976.04 3990.78 "Игорь Лабутин" сколько я пользуюсь как бы ReSharper, сколько я пользовался, ну сейчас не пользуюсь, но до сих пор вижу везде там в чатах и везде, типа ReSharper тормозит. Типа я отключил и ReSharper Studio стал летать. Не знаю, слушай, у меня
3990.78 3999.30 "Анатолий Кулаков" давно тонна оперативки, SSD, и после этого никогда оно мне не тормозило последние годы, поэтому не знаю. Меня больше баги раздражают. У тебя просто проекты маленькие.
3999.30 4001.90 "Игорь Лабутин" Ты ничего не понимаешь. Может быть это кстати тоже
4001.90 4009.94 "Анатолий Кулаков" один из способов. Включите голову, блин, и делайте проекты по 400 салюшенов, по 400 проектов. Делайте нормальные проекты
4009.94 4021.02 "Игорь Лабутин" и никто вас тормозить не будет. Ну в общем вот, такие дела. Посмотрим-посмотрим, ждём с интересом. Давай, есть у нас что-нибудь ещё сегодня? Ну давай, у меня
4021.02 4024.40 "Анатолий Кулаков" есть таки статичка такая большая про как раз бестпрактисы,
4024.40 4027.52 "Игорь Лабутин" кодирование и всё такое. Давай попробуем, что мы
4027.52 4069.72 "Анатолий Кулаков" всё час сидим. Вообще прекрасно. Действительно. В общем, статичка от Дениса Думина, от Дениска решил нам рассказать, как надо правильно кодировать. И это не просто обычный Денис Каспериулка, это автор Fluent Assertion. Ну несмотря на то, что да, Fluent Assertion уже себя замарал глупыми коммерческими лицензиями, несмотря на это, Денис – это довольно опытный, знаменитый, хороший, интересный архитектор, поэтому у него есть интересный блог, где он там тоже иногда что-то попадается существенное. И я нашёл у него статью, которая называется типа «10 уроков качества», которые он у себя усвоил за больше, чем 30 лет софтвер-девелопмента.
4069.72 4098.12 "Анатолий Кулаков" И уроки такие попадаются не совсем банальные, заезженные, тривиальные, как в обычных статьях. Вот почему она мне понравилась. Действительно, здесь какие-то вещи, какие-то моменты, которые я просто до сих пор наблюдаю на работе каждый день. В общем, хотелось бы донести публике, что так делать не стоит. Ну, погнали. У нас 10 пунктов, и первый пункт – это вам необходимо понимать разницу между внутренним качественным и внешним качеством кода.
4098.12 4101.36 "Анатолий Кулаков" Что же такое внешнее качество, по его мнению, по его терминологии?
4101.36 4230.04 "Анатолий Кулаков" Это как раз то качество, о чём заботятся менеджеры и всякие продуктовнеры. То есть они обычно заботятся о том, чтобы интерфейсик был красивый, чтобы пользователю удобно было работать с ним, какой-то отзывчивость интерфейса как раз, чтобы решарпер не тормозил, чтобы баги быстрые закрывались, чтобы пользователи были довольны и счастливы. Вот это внешнее качество, которое видно снаружи. А что же такое настоящее внутреннее наше прожжённое качество? Это то, чтобы у тебя код был написан по домену, чтобы там DDD везде был из каждого угла, чтобы нейминг правильный, чтобы инкапсуляция была хорошая, чтобы DI-контейнер и DI-контейнер длинили и резолвили. Вот это внутреннее качество кода. И обычно мы всё время жалуемся о том, что менеджеры хотят только каких-то внешних фич, а мы хотим рефакторить всякие долги и внутреннее качество улучшать. И вот менеджеры не видят этих проблем. Поэтому Денис придумал такое название, такой подход, как выражение внутренних проблем через внешние возможности. И вот таких внешних возможностей он привёл несколько штук, которые будут понятны менеджеру и через которые можно объяснить необходимость внутренних каких-то переделок. Например, Readability. С помощью Readability можно объяснить, что данный код должен делать и как он это должен делать, то есть как он на самом деле должен работать. Вы приходите и говорите, если у вас проблемы с тем, что Readability хромает, что, допустим, новые члены команды не понимают, как этот код работает, что он должен делать, вы это объясняете менеджеру через Readability и он вроде должен как-то сообразить. Далее это Stability. То есть это то, что этот код делает те функции, на которые он изначально был запланирован. Что эти функции не пострадали, и в принципе тоже получается довольно важная бизнес-фича, что функции остаются на месте. Изоляция. Изоляцией можно объяснить, что вы можете поменять этот код и при этом у вас всё остальное не рухнет вокруг этого кода. То есть у вас код и методы хорошо изолированы и при изменении одной фичи другие фичи не страдают.
4230.04 4250.44 "Анатолий Кулаков" Discoverability. Это когда становится понятным, где расположено необходимое нам поведение. То есть если что-то нужно найти, вы однозначно понимаете, а где это искать. Или если что-то сломалось, вы однозначно понимаете, а где это сломалось.
4250.44 4254.08 "Анатолий Кулаков" Такая предсказуемость кода. Тоже очень важное свойство.
4254.08 4283.92 "Анатолий Кулаков" Traceability. Почему эти изменения были сделаны. И не только в коде, но и в архитектуре, и в общем дизайне вашего проекта. То есть вам необходимо знать причину, по которой они появились. И вот представляя такие внутренние проблемы через линзу внешнего качества, которые уже понятны порт-документам и менеджерам, он говорит, что добился очень многого в этом. Практически во всех проектах это работает.
4283.92 4306.24 "Анатолий Кулаков" Поэтому и нам советуют, если у вас вдруг проблемы с вашими менеджерами, попробуйте предоставлять ваши проблемы через язык менеджеров. Ну пойдемте дальше. Второй пункт. Сделайте ваш код более тестируемым с помощью автотестов. Сделайте больше автотестов, если по-простому.
4306.24 4327.76 "Анатолий Кулаков" Представьте, что вы редактируете незнакомый код. И у этого кода вы не очень знаете, что он в общем делает. Ну вот какой-то кусочек происследовали, который вам нужно отредактировать и все. А вот что вокруг этого кусочка творится вы не очень знаете. Но вы точно знаете, что у вас хорошее качественное тестовое покрытие. Поэтому если вы вдруг что-то сделаете не так, то тесты вас защитят.
4327.76 4334.28 "Анатолий Кулаков" Вот такой код редактировать довольно уверенно. Я думаю, каждый из вас с этим сталкивался. То есть очень комфортно.
4334.28 4342.20 "Анатолий Кулаков" Вы отредактировали, запустили тесты, посмотрели, если что-то упало, починили. А если не упало, вы вполне чувствуете, что все хорошо. Этим можно пользоваться.
4342.20 4349.68 "Анатолий Кулаков" А теперь представьте обратную ситуацию, что, допустим, у вас есть код, который вы более или менее понимаете.
4349.68 4438.88 "Анатолий Кулаков" Это даже ваш собственный код. Но при этом у него вообще нет тестов. Он вообще никак не покрыт. И автор приводит такое сравнение и говорит, что в принципе я бы с большим удовольствием редактировал бы код, который я не знаю, но он покрыт тестами. Чем код, который я сам написал, но в котором тестов нет. Потому что это вообще звучит страшно. Я бы к такому коду даже не прикоснулся и ничего бы с ними сделал. Из этого делается вывод, что тесты очень важная штука. Может быть, даже важнее, чем ваш собственный код. Потому что тесты как раз таки проверяют, что он действительно работает. А код ваш практически ничего не гарантирует. Он так как-то существует и как-то делает свою функциональность. Поэтому, чтобы чувствовать себя комфортным в будущем и может быть даже в настоящем, обязательно инвестируйте больше времени в автоматизированные тесты. Ваши тесты должны стать полноценным, полноправным членом вашего проекта. Где-то если у вас есть 40-50% в коде занимают тесты, то это хороший показатель. Значит, вы все делаете правильно. И в принципе не стоит откладывать такую штуку, как я напишу тесты потом. Очень часто бывает ситуация, когда мы пишем код, потому что надо срочно выпустить что-нибудь в продакшн. Фича требует, ее надо потестить ручными тестировщиками. А вот автоматизированные тесты мы, может быть, напишем когда-то потом. Вот когда она выйдет, когда пользователю понравится, тогда, может быть, скажем, что теперь на нее нужны тесты. Или еще какие-то дурацкие отговорки. В общем, обычно это не работает.
4438.88 4508.32 "Анатолий Кулаков" Такие тесты или не пишутся, или пишутся после этого плохие тесты, или забываются. Поэтому лучше всего тесты писать непосредственно сразу с кодом. Отдельные экстремалы пишут сначала тесты, потом код. Некоторые пишут сначала код, потом тесты. Не суть. Важно. Наверное, в данной ситуации. Главное, чтобы тесты были. Начнем хотя бы с этого. Третье. Никогда не принимайте флаки-тесты. Флаки-тесты – это тесты, которые работают нестабильно. То есть их результат нестабилен. Иногда он может быть зеленым, иногда может быть красным в зависимости от погоды на Марсе. Это может зависеть от операционной системы, от локали, от параллельно запущенных других тестов или вообще других процессов на этом компьютере. В общем, бывает всякое. Насмотрелись. Знали. Видели. Это очень плохие тесты. На них нельзя положиться. Ну а что? Хуже тестов, на которые нельзя положиться. Какой смысл в них вообще? И обычно люди, просто-напросто разработчики, которые видят, например, покрасневший тест в CICD просто перезапускают. В надежде на то, что в этот раз повезет.
4508.32 4518.20 "Анатолий Кулаков" В этот раз это, наверное, пройдет. И если тесты там длинные, долго выполнялись, то это вообще самый частый способ их починки. Просто перезапустите. Так вот.
4518.20 4571.60 "Анатолий Кулаков" Автор советует никогда так не делать. Относитесь к тестам не как к какому-то техническому долгу, который возможно пофиксить когда-нибудь потом. Относитесь к Flaky тестам как к продакшн баге. Это продакшн бага с высоким приоритетом. Фиксить ее надо немедленно. Выделяете на него специального человека, пусть он анализирует, понимает, почему тест моргает и каким-то образом фиксит это. Помните, что наличие Flaky тестов, оно съедает огромное количество времени у многих разработчиков. Скорее всего, у всех разработчиков, которые работают с этими проектами, рано или поздно они с этими Flaky тестами столкнутся, потратят на это какую-нибудь кучу времени и это вылезет в какие-нибудь дополнительные деньги от того, что эти разработчики могли бы сделать что-то полезное вместо того, чтобы смотреть за моргающими тестами. Поэтому относитесь нетерпимо к Flaky тестам.
4571.60 4601.48 "Анатолий Кулаков" Второй пункт. Пишите код, который вы можете поддерживать с уверенностью. Мейнтейнабилити код еще называется. Если погуглите мейнтейнабилити код, найдется куча всяких определений. Но в общем случае, самое правильное определение, которое можно этому дать, это возможность менять код уверенно, сделав изменения в котором вы точно знаете, что не нарушите никакие другие функциональности.
4601.48 4638.56 "Анатолий Кулаков" То есть тот код, который вы поменяли, с ним будет все хорошо, но ничего другого не отвалится. Вот это мейнтейнабилити код. И для него, для этого мейнтейнабилити кода тоже есть несколько рекомендаций. Давайте несколько из них обсудим. Во-первых, автор говорит, что ваш код нужно читать как книгу. То есть члены класса должны находиться в том порядке, в котором они исполняются, чтобы можно было так сверху вниз просматривать, читать книгу и осознавать ее постепенно, спускаясь вниз. Весь код в методе должен быть на том же самом уровне абстракции.
4638.56 4643.92 "Анатолий Кулаков" Это кстати очень хорошее правило, которое я редко вижу во всяких книгах с рекомендациями почему-то.
4643.92 4678.32 "Анатолий Кулаков" Очень часто люди мешают в одном методе разные уровни абстракции. Например, они могут оперировать в одном методе и с репозиторием, и с сервисом, и с сервисбасом и при этом какие-то байтики с файлика вычитывать. Вот такая мешанина происходит. А если пытаются что-то разбить на разные методы, то это просто получается те же самые разные уровни абстракции, разбитые, смиксованные между разными методами. В общем, это всегда показатель того, что вы делаете что-то неправильно. Это как раз хорошая лакмусовая бумажка, хороший кодсмейл. В одном методе уровни абстракции должны быть одинаковыми.
4678.32 4729.32 "Анатолий Кулаков" Дальше, если у вас члены класса больше, чем 15 строк кода, то это обычно плохие члены класса. На данном случае имеются в виду, конечно же, методы. Не держите методы в пределах 15 строк. Такая спарная штука. Всегда, когда пытаешься навязать методом какую-то общую длину, обычно это ничем хорошим не увенчается. Всегда будут исключения, когда больше 15 строк, это нормально. Поэтому рекомендация такая, может быть, для начинающих. Имя методов должно быть функциональным. То есть должно выражать какую-то функциональную ответственность того, что они делают, а не рассказывать про имплементацию. То есть очень часто пытаются в имени выразить то, как внутри этот метод реализован.
4729.32 4746.24 "Анатолий Кулаков" Или какие параметры этот метод принимает. Или в имя параметра зашить то, каким типом они являются, а не кто семантически представляет этот параметр. То есть это тоже очень важная штука, особенно если мы хотим добиться читабельного и поддерживаемого кода.
4746.24 4802.72 "Анатолий Кулаков" Инлайн-комменты – это комментарии, срочные комментарии в одну строчку. Это тоже нормально, если они добавляют какого-то контекста. Мне кажется, да, комментарии можно, если они нужны, почему бы и нет. Вот еще странное какое-то утверждение для читабельности. Звучит оно так. Возвращайтесь из метода или в самом начале, или в самом конце, но не из середины. Видимо, намек на то, что вы можете вначале проверить какие-то аргументы, которые вам нужны, и вернуться, если это аргументы плохие. Или дойти до конца и в конце вернуть какой-то результат. Хороший или плохой, но это уже будет результат. Но если вы вываливаетесь где-то с середины метода, наверное, автор считает, что это будет неявный выход или не слишком очевидный выход. В общем, я такой рекомендации никогда не встречал и на практике никаких проблем с этим не испытывал. Поэтому, если у вас будут какие-то хорошие примеры, которые доказывают нужность этого подхода, пишите в комментариях.
4802.72 4850.60 "Анатолий Кулаков" Избегайте boolean-параметров. Вместо них лучше использовать enum или отдельные методы. Ну, на boolean-параметры, мне кажется, наезжают все, что это не очень очевидно, не очень читабельно, что такое true или false, которые вы передаете в методах. Немножко лучше стала ситуация, когда у вас появились именованные параметры, когда вы можете указать возле имени, что это. Ну, может быть, не всегда это очевидно и более приятным будет enum. Особенно, если вы делаете какие-то внешние контракты или тем более межпроцессорные контракты, то enum там более показателен в любом случае. Не вводите слой абстракции только ради dependency injection. То есть, опять наезжает на наши интерфейсики, которые мы делаем только для того, чтобы протестировать классик или даже внедрить зависимость.
4850.60 4864.48 "Анатолий Кулаков" Ну, тут тоже есть масса исключений. В общем, утверждение не абсолютное. Группируйте код по функциональному признаку вместо технической структуры для лучшей читабельности.
4864.48 4895.00 "Анатолий Кулаков" Такие примеры я тоже очень часто встречал, когда начинают выделять отдельную папочку, которую называют interfaces и складывают туда все интерфейсисы. Отдельную папочку realizations складывают туда realizations. А иногда туда отдельную папочку есть enums, складывают все enums. И вот такими глупостями занимаются, которые просто по техническому какому-то признаку начинают группировать файлы. То есть, вообще никак не связано, нелогично. Но зато очень интуитивно.
4895.00 4899.16 "Анатолий Кулаков" Понятно, у вас нет вопросов, куда положить enum с цветами.
4899.16 4904.44 "Анатолий Кулаков" Вы знаете, что это enum, отлично, идет папочка с enum. И не надо думать, что цвета там относятся к какой-то палитре.
4904.44 4923.64 "Анатолий Кулаков" И вот надо папочку с палитрой создавать. В общем, это довольно легкий и понятный путь. Вот почему по нему многие идут. Делать так не стоит, это плохо. Вам необходимо все-таки какую-то функциональность видеть в ваших классах. Вам необходимо понимать, зачем вы эти классы делаете и группировать уже непосредственно по функциональности.
4923.64 4934.00 "Анатолий Кулаков" Придерживайтесь хорошего кодового покрытия. Автор считает, что 80% покрытия тестами – это хорошо. 90% – это прямо великолепно. А 95% – это уже какой-то перебор.
4934.00 4938.16 "Анатолий Кулаков" Наверное, вполне приемлемые цифры, почему бы и нет.
4938.16 4970.44 "Анатолий Кулаков" Не тестируйте очень маленькие кусочки. Вы должны тестировать внутренние границы у ваших тестовых классов, то есть у ваших классов, которые вы тестируете. Но при этом не тестируйте Implementation Details, то есть детали реализации, которые находятся внутри этого класса. В общем, это тоже на практике легко сказать и не всегда легко сделать. Поэтому утверждение тоже довольно поверхностное.
4970.44 5012.76 "Анатолий Кулаков" Из пунктов, которые улучшают наш Maintainability – поддерживаемость кода – это все. Переходим к следующему пункту общей статьи. Это пятый пункт, который называется «Это никогда не случится, кроме этого раза». Пункт заключается в наших одноразовых всяких подъелках и костылях. Для примера, когда-нибудь была ли у вас ситуация, когда вы писали какой-то скриптик на скорую руку для того, чтобы его один раз выполнить и забыть, но встречались с тем, что начинаете переиспользовать его все чаще и чаще, больше и больше, и с каждым днем в нем он никуда не умирает, никуда не девается, а просто используется и используется.
5012.76 5017.96 "Анатолий Кулаков" У меня, например, таких скриптиков много. К сожалению, использую уже их не только я, но и члены моей команды.
5017.96 5106.84 "Анатолий Кулаков" Поэтому бывает, да. Или вот, например, если вы сделали какой-нибудь Proof of Concept, который вас попросили быстренько там набросать, в общем, чисто вот, чтобы попробовать, работает оно или не работает. А потом замечаете, что ваш POC используется где-то в продакшн-коде. И вот в продакшн он прекрасно работает, и все-все знают, все любят и всех хвалят. В общем, такой тоже вот одноразовая какая-то вещь, которая должна была выкинуться сразу, почему-то осталась. Или тоже связанная практически с этим штука – это баг. Баг, который есть, вы его иногда встречаете, но как только начинаете отлаживать или тестировать, он исчезает. А вот на продакшне, когда вы запускаете, он опять появляется. В общем, автор сносит это все вот в одну группу такую, которая называется вот как раз таки «Одноразовые недоделанные костыли». Ну, типа хорошо делай – хорошо будет. В общем, он рекомендует, что никогда не используйте вот таких вот одноразовых черновых костылей, кроме MVP проектов. Но если вы вдруг решили сделать MVP проект, то обязательно сразу выделите время, сделайте задачу, выделите на нее какой-то тайм-слот, в котором будет написано, когда вы этот MVP замените на какой-то стабильный фикс. В общем, никогда не оставляйте вот таких костылей без надзора, то есть без определенного времени, когда вы их зафиксите или вообще не делайте, если вы не планируете их фиксить.
5106.84 5226.64 "Анатолий Кулаков" В общем, никогда не соглашайтесь на такие фиксы и всегда разбирайтесь с причиной проблемы. Это, мне кажется, тоже очень правильная рекомендация, которая так затесалась где-то в конце, но очень важная. Очень много ситуаций, когда вы просто видите наведенку от проблемы, когда вы видите, что, собственно, произошло, факт, сам проблемы, и тогда гораздо легче там или кетчблок поставить, или какой-нибудь флажок неведомый передать, который вы не понимаете, зачем вы передали, или еще каким-то таким костылем закрыть ситуацию, при этом не разобравшись в сути проблемы. И это очень плохо, особенно на ранних стадиях, когда вы только там обучаетесь языку, когда вы только изучаете фреймворк, потому что подобные разбирательства в вашей голове всегда будут откладывать знания. И эти знания вам в будущем преградятся еще сотни миллионов раз. Поэтому лучше потратить лишний час времени, разобраться, почему эта сволочь падает. Может быть, параллельно освоить профайлер, дебаггер, илл, ассемблер и документацию микрософта, скачать исходники. Может быть, это и нужно будет сделать, несмотря на то, что это звучит страшно и тяжело, но зато, если вы научитесь это делать, вы станете специалистом в 10-20 раз превосходящим самого себя вчерашнего дня. Поэтому все это те челленджи, которые сделают из обычного кодера хорошего качественного разработчика. Поэтому никогда не бросайте проблему на том, какие у нее появились наведенки. Всегда разбирайтесь в сути проблемы, что привело, чтобы вы точно понимали, из-за чего она возникла, и тогда вы точно поймете, а как правильно ее фиксить, и какие можно применить сюда какие-то заплатки, инструменты. Может быть, поискать у авторов какая-то новая версия вышла, может быть, новую библиотеку обновить, может быть, какую-то конфигурацию подставить. То есть вы уже будете со знанием дела подходить к решению проблемы, и точно будете знать, а в следующий раз выстрелит она вас на пруде или не выстрелит. И если выстрелит, то по какой причине.
5226.64 5256.80 "Анатолий Кулаков" Поэтому, если вы начнете так разбираться и понимать, как каждый такой фикс понимать, то будущее вы обязательно скажет спасибо вашему прошлому за такие прекрасные разбирательства и правильные фиксы. Шестой пункт. Избавьтесь от ручных действий во время диплоймента. Автор прыгает так там между кодом, диплойментом и так далее, потому что FullStack имеет право. В общем, к диплойменту переходим.
5256.80 5278.28 "Анатолий Кулаков" Итак, возможность задеплоить хороший качественный протест, протестированный код и проверсионированный код, какие-то проверсионированные модули про стабильную систему и задеплоить это автоматизировано. Это вообще хороший индикатор зрелости команды, зрелости проекта и зрелости компании.
5278.28 5326.44 "Анатолий Кулаков" Вот на заре моего юношества, когда я ходил еще джинном по собеседованиям, там как раз был один из признаков того, хорошая у вас компания, когда вы собеседуете или нет. Можно спросить, а вы как диплоите? Если они говорят, нажимаем кнопочку, оно все само диплоится, это хорошая компания. А если рассказывают, как он их с админы подключается по SSH и запускает какие-то кастомные скрипты, вот это плохая компания. В общем, это признак примерно того же, что если у вас весь диплой происходит под одной кнопочкой, то это все хорошо. Значит, вы на правильном пути, у вас хорошая компания. Если же вам необходимы какие-то ручные действия, то это потенциальные проблемы, потенциальные ошибки. Все люди ошибаются, заболевают или еще что-нибудь делают, и это всегда может выстрелить.
5326.44 5331.96 "Анатолий Кулаков" Поэтому такие места должны быть автоматизированы.
5331.96 5386.56 "Анатолий Кулаков" Хорошо продуманный pipeline диплоймента обязательно включает в себя не только непосредственно диплой кода, но и много других полезных вещей, таких стандартных как компиляция исходного кода, запуск код анализов, проведение автоматизированных тестов, версионирование и диплой артефактов, настройка инфраструктуры, миграция обновления базы данных, схемы базы данных, диплой на стейдж, проверка здоровья того, что вы задиплоили и переключение стейдж на прот. В общем, вот такой хорошенький pipeline обычно должен у вас быть. И все это, самое главное, без расшаривания всяких продовских паролей, без расшаривания продовских сертификатов, без доступа к персональным данным, которые хранятся на проте, в общем, ко всему этому, человеки не получают никакого доступа. И это очень важно. Особенно если вы начнете проходить какие-то сертификации, это первым делом спросят.
5386.56 5431.76 "Анатолий Кулаков" Если у вас кто-то лазит через Connection на прот, там что-то руками меняет, скрипты запускает, то это сразу гибель, это сразу страшно. Седьмой пункт. Вам необходимо относиться к вашему pipeline сборки и диплоймента как к коду. То есть обычно люди представляют себе диплоймент pipeline, который я описал, как сборище каких-то примитивных тасков. Вот такая задачка, пойди сбил, пойди задиплои, пойди проверсионируй. Но на самом деле, если мы начнем разбираться, это все довольно сложные задачи. Как там правильно определить версию, как необходимо собрать артефакты, под какие операционные системы, под какие контейнеры.
5431.76 5448.00 "Анатолий Кулаков" В общем, там необходимо принимать очень много разных важных задач. И так как у вас там становится много разных задач, то постепенно этот код, который у вас вырождается в тазочках, он очень сильно усложняется.
5448.00 5486.84 "Анатолий Кулаков" Ну, в банальном случае, вы обычно используете для ваших диплойментов таких пайплайнов, это файлы в разметке YAML. Да, если мы берем вот самые популярные GitLab, GitHub, Azure DevOps, те же самые GitHub Actions, там используется YAML. YAML - это такой язык JSON-подобный. И выражать в нем сложные конструкции, сложные операнды с различными взаимодействиями - довольно страшно. Если вы видели GitHub Actions, то примитивные GitHub Actions, они простые, понятные, и, наверное, в этом их плюс.
5486.84 5490.60 "Анатолий Кулаков" То есть, они получили популярность как раз именно поэтому.
5490.60 5577.60 "Анатолий Кулаков" Но как только вы переносите эту концепцию в настоящий интерпрайс, где таких простых пайплайнов не бывает, у каждого бывают какие-то свои собственные навороты, какие-то свои собственные патчи, миграции и еще что-то, там этот YAML становится большим минусом, чем плюсом. Поэтому в интерпрайзе у нас появляются уже какие-то скрипты. Обычно это PowerShell и Bash. То есть, вот эта вот смесь на PowerShell, Bash и YAML начинает жить своей жизнью, половина из них переписывается, половина дублируется, половину не дописывается. И так как это живой, по сути, процесс, который необходимо подстраивать под новые продукты, под новые стандарты, его необходимо рефакторить, документировать, каким-то образом тестировать в конце-то концов. Естественно, ни с YAML, ни с Bash, ни с PowerShell, конечно, можно. Ни с YAML, ни с Bash это не сделать. PowerShell еще более или менее, но тоже не фонтан. Но, слава богам, в мире есть более прекрасные альтернативы, чем такой подход. Это как раз таки альтернатива заключается в том, что вы можете относиться к пайплайну, как к обычной кодовой базе, и сопровождать его на том языке, с которым вам более комфортно это делать, с которым вы, например, работаете каждый день, например, на C#. Есть такой прекрасный инструмент, который называется Nuke. Nuke позволяет вам на C# писать пайплайны, которые делают все, что я перечислил. Компилируют, версионируют, деплоят, проверяют, анализируют, вот это все.
5577.60 5598.92 "Анатолий Кулаков" Это пишется на чистом, красивейшем C#. Плюс очевидно, у вас есть навигация по всему, рефакторинг, дебаггинг, и одна из просто киллер фич – это тестирование. Вы можете тестировать пайплайн у себя локально, вы можете тестировать, а как эта штука сработает где-то там на Azure DevOps. Потестируйте себя на локальной машине без всяких production credentials, допустим.
5598.92 5601.96 "Анатолий Кулаков" В общем, прекрасная тема, прекрасный инструмент.
5601.96 5657.60 "Анатолий Кулаков" Пункт 8. После того, как вы зарелизили версию 1.0, вам необходимо быть более ответственным. Действительно, когда пакет повысился до 1.0, то это время быть взрослым уже разработчиком и отвечать за все изменения, которые вы делаете. А юзеры в этот момент очень сильно будут страдать, если вы вдруг сделаете изменения какие-то странные, непредсказуемые, рушащие полностью их мир. Поэтому вам необходимо думать о пользователях, вам необходимо соблюдать контракт в вашей библиотеке и выдавать его стабильно и качественно. Прежде всего, вам необходимо определиться с стратегией релизов. Вы можете выпускать регулярные релизы или, допустим, делать какие-то фичи, фичи, фичи, а потом вдруг вам понадобился релиз и в этот момент вы его выпускаете. Следующим образом вам необходимо обязательно применять семантическое версионирование.
5657.60 5662.60 "Анатолий Кулаков" Это довольно простая концепция, довольно давно известная.
5662.60 5687.60 "Анатолий Кулаков" Я думаю, каждый из вас с ней сталкивался. Например, Nougat пытается ее придерживаться. Всякие Nougat пакеты, которые по умолчанию в Nougat публикуются, стараются придерживаться семантических версий. Концепция довольно простая, то есть мажорную версию вы увеличиваете на breaking changes, минорную версию вашего пакета на новые фичи и патч-версию увеличиваете, когда фиксите какие-то баги, которые не приводят к breaking changes.
5687.60 5700.60 "Анатолий Кулаков" Кстати, о breaking changes. Необходимо как можно сильнее избегать breaking changes, то есть старайтесь не breaking change. Это важно, потому что у вас есть пользователи после первой версии и они опять же на что-то рассчитывают.
5700.60 5721.60 "Анатолий Кулаков" Если вдруг вам что-то пришлось поменять в библиотеке, необходимо предоставить хорошее описание того, что вы поменяли, на что это необходимо заменить и какие альтернативы вы можете предложить вашим пользователям, чтобы они перешли со старой за депрекереченной версией. Но обязательно не забывайте документацию.
5721.60 5729.60 "Анатолий Кулаков" Документация - это важно. Девятый пункт. Следите за организацией истории в системе контроля версий.
5729.60 5744.60 "Анатолий Кулаков" Тоже вещь, на которую многие забивают, то есть в commit месседжах и pull request месседжах пишут абсолютно любую чушь с надеждой на то, что это никому не нужно, никто это не прочитает, нигде это не используется.
5744.60 5762.60 "Анатолий Кулаков" На самом деле это не так. Вообще commit message довольно полезная штука. Ну, например, представьте, что случилась у вас бага и вы пытаетесь понять, почему у вас кто-то увеличил время тайм-аута в SQL запросе до 60 секунд.
5762.60 5780.60 "Анатолий Кулаков" Бывает такая штука. И у вас нет никаких инструментов, никаких использователей, никаких способов, кроме того, как пойти в историю ГИТА и посмотреть, куда привязан этот commit, какое там сообщение и что там случилось. И вот вы находите тот commit, в котором случилось это изменение на 60 секунд тайм-аут.
5780.60 5783.60 "Анатолий Кулаков" И там написаны замечательные сообщения.
5783.60 5808.60 "Анатолий Кулаков" "Увеличил SQL тайм-аут". Это сообщение нам говорит о том, что было сделано. Но, к сожалению, оно никак не объясняет проблему, которую решал разработчик в то время, когда это сделал. А что, собственно, было причиной этого изменения? Что произошло? Зачем мы это сделали? Другая ситуация, немножко отличающаяся от предыдущей, но тоже сводится к тому же самому.
5808.60 5814.60 "Анатолий Кулаков" Допустим, у вас есть pull request, который содержит смесь рефакторинга и значимых изменений.
5814.60 5832.60 "Анатолий Кулаков" То есть, представьте, у вас там изменилось 300 файлов, и значимые изменения, которые должны были выйти срочно в продакшен, являются где-то в 2-3 файлах среди этой сотни. Это тоже неправильное общение с системой контроля версии. Так тоже делать нельзя.
5832.60 5843.60 "Анатолий Кулаков" Как же, собственно, делать нужно? Нужно, во-первых, писать понятный месседж, комментарий, который объясняет, какую проблему вы решали, а не что вы сделали.
5843.60 5846.60 "Анатолий Кулаков" Что вы сделали, в принципе, можно посмотреть по коду.
5846.60 5880.60 "Анатолий Кулаков" Если там кода много, то можно всегда натравить какого-нибудь ассистента, который соберет все эти изменения и расскажет в самый кратко, что вы, собственно, сделали. А вот почему вы это сделали, не всегда очевидно. Если мы говорим про pull request, необходимо разделять pull request на рефакторинг и отдельно pull request с фичами. Лучше их заводить отдельно. Вам необходимо следить за историей вашей системы контроля версии. Желательно держать ее красивой, понятной и читабельной, чтобы легко было понять, открыв историю, что, собственно, поменялось, в каком месте, когда, почему и зачем.
5880.60 5887.60 "Анатолий Кулаков" И так же точно, если вы будете разбивать pull request, если вы будете писать правильные сообщения, это сильно поможет коллегам делать код ревью.
5887.60 5893.60 "Анатолий Кулаков" Не самое сильное помочь, конечно, в код ревью, но, конечно, с этим лучше, чем без этого.
5893.60 5902.60 "Анатолий Кулаков" И последний, десятый пункт. Не бойтесь отметать большие pull request, которые сложно ревьюрить.
5902.60 5911.60 "Анатолий Кулаков" Представьте себе ситуацию, к вам приходит pull request, там больше ста файлов, и вам обязательно его нужно посмотреть. Что вы делаете?
5911.60 5925.60 "Анатолий Кулаков" Обычно, если вы не сильно усидчивый, вы их скроллите просто вниз, у вас голова перегружается всем контентом, который невозможно загрузить вам в голову, и вы ставите типа approve, что, окей, допустим, человек знает, что он делал.
5925.60 5928.60 "Анатолий Кулаков" Это плохой подход. Так делать не нужно.
5928.60 5940.60 "Анатолий Кулаков" Подобные pull request, в которые приходят сотни файлов, их нужно режектить. Почему? Потому что качество код ревью, который вы будете проводить на таких pull request, оно полностью нивелируется.
5940.60 5946.60 "Анатолий Кулаков" То есть невозможно привести качественно хорошее код ревью, если у вас очень много изменений.
5946.60 5949.60 "Анатолий Кулаков" Поэтому смысла в таком код ревью никакого нет.
5949.60 5957.60 "Анатолий Кулаков" А раз смысла в код ревью нет, значит и pull request допускать нельзя, иначе он может привести к каким-то негативным последствиям в вашем ходе.
5957.60 5963.60 "Анатолий Кулаков" Какое решение? Попросите разработчиков разбить ваш pull request на несколько, чуть поменьше.
5963.60 5988.60 "Анатолий Кулаков" Отдельных, сфокусированных на какой-то задаче, множество мелких pull request. Тогда их легко ревьюить, и они будут хорошо, быстренько забегать в мастер. Запомните, маленькие pull request - это более лучшее код ревью, и соответственно выше будет повышаться у вас качество кода от хороших код ревью.
5988.60 6000.60 "Анатолий Кулаков" Вот такие 10 советов. В принципе, какие-то из них полезные, какие-то не очень, но я думаю, что каждый из вас смог найти какие-то интересные вещи, которые вы сможете применить в своей практической работе.
6000.60 6004.60 "Игорь Лабутин" Однозначно, и советы действительно звучат вполне нормально.
6004.60 6014.60 "Игорь Лабутин" Понятно, что не везде, может быть, им получится следовать, но я бы тщательно подумал про каждый из них, и хотя бы часть из них к себе заносил.
6014.60 6024.60 "Игорь Лабутин" Я там не уверен, что всем нужно быстро бежать на нюк какой-нибудь с C#, но это не значит, что все остальные советы плохие, их надо почему-то игнорировать.
6024.60 6028.60 "Игорь Лабутин" Хорошая статья, мне понравилась, мне понравилось.
6028.60 6032.60 "Игорь Лабутин" Так, ну давай будем потихонечку заканчивать.
6032.60 6035.60 "Игорь Лабутин" У нас есть еще небольшая секция, кратко о разном.
6035.60 6042.60 "Игорь Лабутин" В ней я хотел бы немножечко рассказать про следующие штуки.
6042.60 6045.60 "Игорь Лабутин" Во-первых, интересная задачка.
6045.60 6058.60 "Игорь Лабутин" Вот представьте, что у нас есть EF Core, представьте, что у нас есть какая-то модель, у нас есть объект с кучей полей, и нам нужно сделать запрос в базу, при том, что набор колонок, который возвращается, пользуется пользователем.
6058.60 6064.60 "Игорь Лабутин" Ну, например, приходит в запросе какая-нибудь такая динамическая табличка типа «Хотим только вот эти колонки из этого объекта».
6064.60 6066.60 "Игорь Лабутин" Как такое можно сделать?
6066.60 6075.60 "Игорь Лабутин" Ну, можно, вариант, написать switch case какой-нибудь, который там в зависимости от запрашиваемых полей какие-то разные запросы сделает.
6075.60 6085.60 "Игорь Лабутин" Можно сделать через expressions, но это прям такое нетривиальное приседание и упражнение, чтобы с expressions все заработало.
6085.60 6097.60 "Игорь Лабутин" А самое главное, что expressions не транслируются в SQL, поэтому это все будет все равно, все колонки будут затянуты select, а потом вы expressions, естественно, хорошо вытащите только нужные в ответ.
6097.60 6114.60 "Игорь Лабутин" Но если вам вдруг такая задачка прям очень актуальна, то можно посмотреть на библиотечку system.link.u/dynamic/core, которая позволяет вам сделать select и в этом select указать название колонок прямо строчками.
6114.60 6117.60 "Игорь Лабутин" И, соответственно, тогда запрос формируется правильно.
6117.60 6122.60 "Игорь Лабутин" Там написан соответствующий код, который правильно будет формировать запрос select.
6122.60 6127.60 "Игорь Лабутин" Наверное, это очень узкая область применения, но, тем не менее, почему нет.
6127.60 6135.60 "Анатолий Кулаков" Ну и тут нужно только не заблуждаться, что на namespace system.link.u это не микрософтовская официальная библиотека с dotnet, это вообще левый проект.
6135.60 6138.60 "Игорь Лабутин" Левый проект, но, тем не менее, почему нет.
6138.60 6142.60 "Игорь Лабутин" Либо, по крайней мере, посмотреть, может быть, как он написан, тоже может быть интересное упражнение.
6142.60 6147.60 "Игорь Лабутин" Всегда полезно посмотреть, как написаны другие библиотеки, может чему-то научиться.
6147.60 6167.60 "Игорь Лабутин" Дальше, если вы уже путаетесь в том, где какие фичи и в каком C# появились, если вам зачем-то это надо, то у Steven Gil вышел блокпост, в котором он обновил свою mindmapping со всеми версиями и фичами C#, где все фичи C# раскиданы по версиям.
6167.60 6174.60 "Игорь Лабутин" Если вам зачем-то вдруг надо быстро вспоминать, в какой версии эта или иная фича появилась, то вот эта штука удобная.
6174.60 6180.60 "Игорь Лабутин" Причем есть svg-версия, где каждая фича является линком на официальную документацию по этой фиче.
6180.60 6187.60 "Игорь Лабутин" В этом смысле, может быть, это как-то удобно в качестве референса, если вы, например, этого начинаете изучать или преподаете, или еще что-нибудь.
6187.60 6190.60 "Игорь Лабутин" Вот, тоже интересная, полезная штука.
6190.60 6200.60 "Игорь Лабутин" Ну и еще, это пока еще не фича, но появилось про нее некоторое пропоузол, а именно возможность запускать cs-файлы.
6200.60 6203.60 "Игорь Лабутин" То есть сейчас мы можем...
6203.60 6213.60 "Игорь Лабутин" Мы не можем запускать просто cs-файлы, ну, можем, точнее, в виде cs-скриптов, но мы не можем сказать dotnet run file.cs, program.cs.
6213.60 6219.60 "Игорь Лабутин" Вот, появился пропоузол, как это сделать со всеми деталями техническими, вот это все.
6219.60 6224.60 "Игорь Лабутин" То есть, как минимум, можно будет написать dotnet run program.cs, и оно все запустит.
6224.60 6230.60 "Игорь Лабутин" При этом там можно будет сначала написать стандартный вот этот шибанг, который...
6230.60 6239.60 "Игорь Лабутин" Решетка-всказательный знак, чтобы, если вы запускаетесь на операционке, которая это умеет, она сама поймет, что нужно сделать dotnet run этому файлу.
6239.60 6244.60 "Игорь Лабутин" Это будет поддерживать импорты, ну, get-пакеты через специальную решетку импорта.
6244.60 6264.60 "Игорь Лабутин" И самое главное, это на самом деле довольно важная штука, что если вы поняли, что ваш проект в виде одного файла почему-то уже разросся и хочет теперь много файлов, то будет спецкоманда dotnet project convert, которая из этого одного файла сгенерит csproj, и, соответственно, сделает уже более-менее полноценный проект.
6264.60 6266.60 "Игорь Лабутин" Короче, пропоузол интересный, ждем.
6266.60 6269.60 "Игорь Лабутин" Это еще более упростит всякое скриптование на C#.
6269.60 6272.60 "Анатолий Кулаков" — Да-да, а самое главное, зачем?
6272.60 6275.60 "Игорь Лабутин" — Ну, посмотрим, посмотрим.
6275.60 6277.60 "Анатолий Кулаков" — Вдруг пригодится это.
6277.60 6279.60 "Анатолий Кулаков" C# скрипт же есть уже.
6279.60 6282.60 "Игорь Лабутин" — Ну, есть, но подожди, есть ли он везде?
6282.60 6284.60 "Игорь Лабутин" Я вот что-то не уверен.
6284.60 6288.60 "Игорь Лабутин" Подожди, C# скрипт, виндовый точно, а есть ли он на каком-нибудь маке или линуксе?
6288.60 6290.60 "Игорь Лабутин" Чего-то вот я не уверен.
6290.60 6294.60 "Анатолий Кулаков" — Ну, надо посмотреть, но опять же, я не вижу особых проблем, чтобы поддержать.
6294.60 6296.60 "Игорь Лабутин" — Я вот не уверен.
6296.60 6300.60 "Игорь Лабутин" Ну, как это, проблем поддержать может и нет, вопрос, поддержано ли сейчас.
6300.60 6302.60 "Игорь Лабутин" Кажется, что не очень, а dotnet run...
6302.60 6304.60 "Игорь Лабутин" Ну, опять же, Java сделала, почему мы не можем?
6304.60 6306.60 "Игорь Лабутин" Нам тоже надо.
6306.60 6308.60 "Анатолий Кулаков" — Не очень понятно, зачем это в стандартной...
6308.60 6310.60 "Анатолий Кулаков" Почему бы Microsoft этим заниматься?
6310.60 6314.60 "Анатолий Кулаков" Ну, есть энтузиасты, пусть сделают вполне оторванную функциональность.
6314.60 6318.60 "Игорь Лабутин" — Да нет, не совсем ты не можешь это вклинить в dotnet run.
6318.60 6320.60 "Игорь Лабутин" Потому что это Microsoft поддерживается в кусочек.
6320.60 6324.60 "Анатолий Кулаков" — Нет, ну, dotnet команда прекрасно расширяется плагинами.
6324.60 6326.60 "Анатолий Кулаков" — Ну, типа dotnet какой-то.
6326.60 6328.60 "Игорь Лабутин" — Ранскрипт, сделаю команду.
6328.60 6330.60 "Игорь Лабутин" — Да, ранскрипт, ну, может быть, может быть.
6330.60 6332.60 "Игорь Лабутин" Ну, в общем, что-то Microsoft сами в это решили вложиться.
6332.60 6334.60 "Игорь Лабутин" Там пропоузл от...
6334.60 6336.60 "Игорь Лабутин" От, от, от...
6336.60 6338.60 "Игорь Лабутин" От, от... Сейчас я даже скажу, от кого.
6338.60 6344.60 "Игорь Лабутин" От кого-то из команды, по-моему, команды из Microsoft.
6344.60 6346.60 "Игорь Лабутин" Чувак, вроде как.
6346.60 6348.60 "Игорь Лабутин" C# and Razer, сейчас я тебе скажу, кто это.
6348.60 6350.60 "Игорь Лабутин" C# and Razer Compiler Developer.
6350.60 6352.60 "Игорь Лабутин" Во.
6352.60 6354.60 "Игорь Лабутин" Вот.
6354.60 6360.60 "Игорь Лабутин" Видимо, им, может быть, надо зачем-то всякие тулинги писать для компиляторов. Не знаю.
6360.60 6362.60 "Игорь Лабутин" Не знаю, короче.
6362.60 6364.60 "Игорь Лабутин" Ну, пропоузл есть, опять же, это еще не значит, что его реализуют.
6364.60 6368.60 "Игорь Лабутин" Пропоузл — это написать дело одно, а дальше найти ресурсы, все это реализовать. Поглядим.
6368.60 6376.60 "Анатолий Кулаков" Так, а я хотел рассказать, что у нас вышел, вышла стабильная версия гибрид кэша.
6376.60 6380.60 "Анатолий Кулаков" У нас недавно мелькал гибрид кэш в одном из выпусков.
6380.60 6382.60 "Анатолий Кулаков" Мы довольно подробно про него рассказывали.
6382.60 6390.60 "Анатолий Кулаков" В чем его плюсы, минусы, имплементации, особенности. Так вот, зарелизился, наконец. Он обещал выйти вместе с версией фреймворка, но не осилили.
6390.60 6396.60 "Анатолий Кулаков" Поэтому сейчас финальная стабильная версия, если вы ждали, то вот она. Можете забирать.
6396.60 6414.60 "Анатолий Кулаков" Ну и напоследок, такая новость, праздник, что 4 апреля 1975 года Microsoft был образован некими товарищами Билл Гейтс и Пол Аллен. Поэтому у Microsoft круглая дата, 50 лет.
6414.60 6432.60 "Анатолий Кулаков" Поэтому с праздником, с праздником компанию, которая всем нам подарила работу, практически можно сказать. И за наше счастливое детство, язык UCSharp, .NET, Windows и всем ее пиратским копиям и играм, тоже большая-большая слава. Все.
6432.60 6442.60 "Анатолий Кулаков" На этом, если вдруг вам захочется каким-то образом отпраздновать этот день или может быть этот год весь, или месяц хотя бы, то вы теперь знаете, за что можно выпить бутылку кефира.
6442.60 6446.60 "Игорь Лабутин" Ну, а мы на этом будем завершаться.
6446.60 6466.60 "Игорь Лабутин" Сегодня мы почти 2 часа поговорили о том, что происходит с Espire, куда он идет, про то, куда идут автомайпер с медиатором в коммерциализацию, про вышедший .NET Espire 9.2 и про то, как там начали появляться дипломент фич, фишки.
6466.60 6472.60 "Игорь Лабутин" Masternzit, который тоже стремится в коммерциализацию, ReSharper out of process.
6472.60 6476.60 "Игорь Лабутин" Осталось чуть-чуть, еще буквально несколько месяцев подождать и, может быть, на это будет потрогать.
6476.60 6490.60 "Игорь Лабутин" Подчитали большую длинную статью про 10 принципов качественного кода, не кода, но в общем, обеспечения качества того, что вы пишете, ну и пробежались по кратко разным.
6490.60 6492.60 "Игорь Лабутин" На этом, наверное, на сегодня все.
6492.60 6494.60 "Анатолий Кулаков" Да, всем спасибо. До новых встреч.
6494.60 6500.60 "Анатолий Кулаков" Приходите на Boosty, пишите комментарии, шарьте, репосты, лайкайте все, что вы любите и что любимы.
6500.60 6502.60 "Анатолий Кулаков" Всем пока.
6502.60 6504.60 "Игорь Лабутин" Всем пока.
