0.00 11.40 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер 81.
11.40 14.40 "Анатолий Кулаков" И в студии, как всегда, Анатолий Кулаков.
14.40 15.40 "Анатолий Кулаков" И Игорь Лабутин.
15.40 16.40 "Анатолий Кулаков" Всем привет.
16.40 21.92 "Анатолий Кулаков" А также наши дорогие помогаторы, которые поддерживают свой любимый подкаст на Boosty.
21.92 27.00 "Анатолий Кулаков" Если вы еще не среди них, то заходите, смотрите, подписывайтесь и заносите.
27.00 37.72 "Анатолий Кулаков" Поэтому, в частности, хотелось бы поблагодарить наших золотых и любимых помогаторов в лице.
37.72 47.28 "Анатолий Кулаков" Александр, Сергей, Владислав, Шевченко, Антон, Лазарев, Ильяк, Гурий, Самарин, Виктор, Руслан Артамонов, Александр Ярыгин, Сергей Безенко и Александр Лапердин.
47.28 50.12 "Анатолий Кулаков" Всего вам большое спасибо, друзья.
50.12 54.08 "Анатолий Кулаков" Спасибо, что помогаете и спасибо, что поддерживаете подкаст.
54.08 59.16 "Анатолий Кулаков" Так, из неофициальных вроде у нас никаких объявлений нет.
59.16 60.16 "Анатолий Кулаков" Пойдем сразу к выпускам.
60.16 61.16 "Анатолий Кулаков" Как там Microsoft теперь там?
61.16 62.16 "Анатолий Кулаков" Ой, к выпускам, к новостям.
62.16 63.16 "Анатолий Кулаков" Microsoft о нас пожаловал, пожаловал.
63.16 68.44 "Игорь Лабутин" Да, Microsoft довольно тихо, надо сказать, зарелизил релиз Кандидат 2.
68.44 73.04 "Игорь Лабутин" То есть я про него узнал только уже из каких-то дайджестов и подборок в Твиттере.
73.04 74.64 "Игорь Лабутин" Что-то как-то у меня все прошло.
74.64 79.12 "Игорь Лабутин" Может, правда, это Твиттер, так теперь работает, что рекомендуется всем не то, что я обычно читаю.
79.12 80.12 "Игорь Лабутин" Но ладно.
80.12 82.96 "Игорь Лабутин" Вышел дотнет релиз Кандидат 2.
82.96 87.48 "Игорь Лабутин" Это, видимо, уже последний, наверное, релиз Кандидат перед релизом.
87.48 88.76 "Игорь Лабутин" Релиз будет 14 ноября.
88.76 96.08 "Игорь Лабутин" Так что, ну, с одной стороны, время еще есть, но с другой стороны, видимо, все-таки, наверное, не будет больше релиз Кандидата.
96.08 98.44 "Игорь Лабутин" Сейчас дофиксят последние баги и можно уже в релиз.
98.44 101.04 "Игорь Лабутин" Они же планировали 2, насколько я помню.
101.04 106.04 "Игорь Лабутин" Да, они всегда делают 2, поэтому мне просто… Если не находят что-нибудь интересного.
106.04 110.20 "Игорь Лабутин" Да, ну мне казалось, что 2 выходил попоздней, но может быть, мне уже память подводит.
110.20 116.60 "Игорь Лабутин" В общем, ждем 14 ноября, релизы, там, подарочные ленточки, вот это все, красивые коробочки и все такое прочее.
116.60 126.88 "Игорь Лабутин" И тем не менее, несмотря на то, что это релиз Кандидата 2, мне казалось бы, в нем нужно, ну что там, баги полировать, да, так сказать, учитывать фидбэк от релиз Кандидата 1, но нет.
126.88 127.88 "Игорь Лабутин" Перформанс стабилизировать.
127.88 128.88 "Игорь Лабутин" Ну, перформанс улучшать.
128.88 129.88 "Игорь Лабутин" Что стабилизировать его?
129.88 130.88 "Игорь Лабутин" Его надо улучшать.
130.88 133.88 "Игорь Лабутин" Нам не нужен стабильный, нам нужен хороший.
133.88 135.88 "Игорь Лабутин" Стабильное улучшение перформанса должно быть.
135.88 140.40 "Игорь Лабутин" Да, но на самом деле даже тут умудрились закинуть некоторое количество новых вещей.
140.40 141.80 "Игорь Лабутин" Давайте по ним пробежимся быстренько.
141.80 149.28 "Игорь Лабутин" Во-первых, сделали не такую, ну, вещь, которая не относится ни к перформансу, ни к коду, ни к чему, но в общем полезную.
149.28 162.48 "Игорь Лабутин" У многих пэкэджей, а вы знаете, что часть, так скажем, стандартной библиотеки, да, она поставляется отдельными Nuget пакетами, которые нужно подключать, и вот у этих пакетов, там довольно обширный список в статье, обновили Redmi.
162.48 169.00 "Игорь Лабутин" C4 лишь обновили Redmi, но теперь, заходя на такой пакет на Nuget.org, вы хоть будете видеть вообще о чем он, зачем он нужен, и что в нем ждать.
169.00 177.08 "Игорь Лабутин" Это полезно на самом деле, чтобы не надо было бегать в GitHub с Nuget и смотреть, а для чего же этот пакет нужен.
177.08 188.80 "Анатолий Кулаков" По-хорошему это вообще должно быть частью документации, потому что, видишь, на MSDN они обычно не забывают там все обновлять, там статейки пишут и так далее, а вот такие примитивные вещи, как Redmi, почему-то забывают.
188.80 191.88 "Анатолий Кулаков" Но это же вообще самая первая документация, с которой сталкивается разработчик.
191.88 193.72 "Анатолий Кулаков" Почему-то да.
193.72 197.44 "Игорь Лабутин" Ну вот, перед релизом поработали, дописали документацию.
197.44 210.48 "Игорь Лабутин" Вторая фича это MSBuild, точнее не сам MSBuild, конечно, а штука под названием Simple CLI Based Project Evaluation.
210.48 211.48 "Игорь Лабутин" Смысл в чем?
211.48 224.48 "Игорь Лабутин" MSBuild давно и хорошо умеет использовать другие тулы, то есть любой тул, который умеет работать из командлайна, можно в MSBuild легко затащить и там повызывать, что-нибудь как-нибудь поработать с ним.
224.48 232.68 "Игорь Лабутин" Но если вы хотите MSBuild откуда-то поиспользовать, то есть например из MSBuild что-то достать, то вы это простым способом не сделаете.
232.68 238.96 "Игорь Лабутин" Вам нужно, ну, не знаю, в MSBuild добавлять таску, которая запишет файл, вы потом этот файл прочтете, ну и так далее.
238.96 260.44 "Игорь Лабутин" Теперь, соответственно, появился новый набор опций у MSBuild, который, он же переехал на .NET Tool, и вы теперь, например, можете вызвать .NET пробел, Publish пробел, --GetProperty, двоеточие Output Path, и вам на экранчик выведет Bin релиз NAT 8.0, например.
260.44 277.64 "Игорь Лабутин" То есть можно позвать MSBuild и попросить его выдать наружу какие-то свои внутренние детали в простом текстовом виде без всяких там XML и прочего шелухи вокруг, то есть что потом можно легко прочитать в какую-нибудь переменную и дальше использовать зачем-то.
277.64 286.64 "Игорь Лабутин" То есть не надо парсить там CessProvouch, не надо парсить еще что-нибудь, а можно прямо вот узнать у MSBuild куда ты, например, собираешься положить Publish артефакты.
286.64 298.04 "Анатолий Кулаков" То есть он реально прогонит весь pipeline MSBuild, соберет абсолютно все перемены, смержит их, как положено, склеит, перепишет, и результирующий набор уже тебе может выдать.
298.04 304.60 "Игорь Лабутин" Да, то есть это вот отдельный момент, который мне не очень понятен, потому что, например, ну давай я сейчас расскажу кусочек.
304.60 313.44 "Игорь Лабутин" Во-первых, можно попросить несколько пропертей, тогда вам уже в ответ выдастся JSON, ну чтобы их как-то различать, вот такой вот JSON, имя property, его значение, простой типа такой, ключ значения.
313.44 327.00 "Игорь Лабутин" Можно попросить его getItem, а не getProperty, и указать вот этот itemType, который у вас CessProje, и получить, соответственно, все items, то есть, например, все файлы, которые были скомпилированы, или там все ресурсные файлы, или что-нибудь в таком духе.
327.00 338.96 "Игорь Лабутин" Более того, можно сказать getTargetResults и указать имя таргета, и тогда вы получите в качестве output'а набор output'ов этого target'а, то есть что этот target произвел.
338.96 351.40 "Игорь Лабутин" И ты прав, что написано, по крайней мере, в статье, что он реально делает то, что вы попросили, и дополнительно по результатам этого действия выдает те property, или те там target'ы, или items, которые вы попросили.
351.40 358.12 "Игорь Лабутин" Но мне, например, тогда непонятно, куда пишутся логи, то есть по дефолту же MSBuild много чего пишет в консоль, собственно, логи по дефолту пишутся в консоль.
358.12 366.68 "Игорь Лабутин" Вероятно, указав эти property, ну я попробовал у себя, он просто выдает мне, ну, путь.
366.68 375.68 "Игорь Лабутин" Он никуда не пишет логи, то есть, вероятно, нужно все-таки вызывать его тогда с еще дополнительной опцией, что типа логирую заодно файл, и тогда логи будут в файле, иначе вы эти логи нигде не увидите.
375.68 378.72 "Анатолий Кулаков" То есть по дефолту консольный логер у него отключается,
378.72 386.16 "Игорь Лабутин" да? Похоже на то, то есть я вот себе поставил RC2, и кажется, что это так себя ведет, но я могу ошибаться, сильно много не экспериментировал.
386.16 397.96 "Анатолий Кулаков" Слушай, ну тут еще, кажется, надо быть осторожным, потому что некоторые свойства рассчитываются с side-эффектами, то есть MSBuild никогда не был заточен на то, чтобы рассчиталось свойства, и никакого side-эффекта при этом не производило.
397.96 406.64 "Анатолий Кулаков" Поэтому если вы можете просто так output, паф, и попросите, но при этом он вам может там скомпилить, отформатировать, сжать в архивчик и отправить попозже что-нибудь.
406.64 415.92 "Игорь Лабутин" Все так, то есть вот я так понимаю, что действительно сделано просто как способ из результата операции просто что-то получить, то есть операция все равно делается.
415.92 437.24 "Игорь Лабутин" То есть это скорее, видимо, в каких-нибудь build-скриптах, то есть когда вы все равно в build-скрипте что-то делаете, и вот вам нужно, например, разобрать, откуда это output, то, значит, традиционным способом было либо мы это хардкодим, мы знаем, что оно соберется в min-релиз чего-нибудь, либо мы это снаружи передаем в property, которые MSBuild внутри использует, чтобы туда сложить, либо вообще отдельным copy-task'ом это сделать.
437.24 441.96 "Игорь Лабутин" А сейчас можно от него получить, куда же ты положил, в зависимости, например, от конфигурации, в которой собирали.
441.96 442.96 "Игорь Лабутин" В общем, вот.
442.96 446.20 "Анатолий Кулаков" Ну полезная, полезная, да, штука хорошая, интересная.
446.20 462.20 "Анатолий Кулаков" Опять же, надо ее попробовать все-таки, знаешь, обычно хочется проанализировать свой проект, типа узнать, какой проект, допустим, под какой версией собирается дотлета, и не всегда это пишется как бы в csproj файле, потому что очень часто заводится какой-нибудь common MSBuild в руте, и там как-нибудь склеиваются фреймворки.
462.20 466.64 "Анатолий Кулаков" В общем, и просто так его не узнать до тех пор, пока не запустишь MSBuild.
466.64 474.52 "Анатолий Кулаков" Но непонятно, с каким таргетом его тогда в таком случае запускать, чтобы как можно меньше повредить, и как можно больше выдать output значений.
474.52 477.16 "Анатолий Кулаков" В общем, хорошее поле для экспериментов.
477.16 482.56 "Игорь Лабутин" Нужен ключик, знаешь, типа dry run, то есть типа вот ты делаешь все, но не пиши файлики в итоге.
482.56 490.84 "Анатолий Кулаков" Ну видишь, он же запускает в основном эти внешние тулзы, то же самое компилятор, но он же не знает, как компилятор пишет, не пишет, как бы он же это все не контролирует.
490.84 493.92 "Анатолий Кулаков" А пока компилятор не запустишь, дальше не пройдешь, грубо
493.92 502.60 "Игорь Лабутин" говоря. С другой стороны, фичу только так, сейчас в релиз кандидат 2 включили, будут всю девятку допиливать еще, нормально, может все хорошее и получится в результате.
502.60 505.80 "Игорь Лабутин" Даже так уже в принципе юзабельно в нормальных блескриптах.
505.80 506.80 "Игорь Лабутин" И посмотрим.
506.80 507.80 "Игорь Лабутин" Дальше пошли.
507.80 508.80 "Игорь Лабутин" SDK container publish.
508.80 513.24 "Игорь Лабутин" Мы эту тему затрагивали в каком-то из превью, когда это было добавлено.
513.24 527.08 "Игорь Лабутин" Напомню, что вы можете с помощью dotnet SDK собирать контейнеры и паблишить их в локальный докер, соответственно, либо куда-нибудь в удаленный реестр, типа на мажор, амазон, докер хаба, ну таких вещей.
527.08 534.40 "Игорь Лабутин" Но выяснилось, что некоторые команды, прежде чем сделать пуш, хотят провести некоторый аудит того, что собралось.
534.40 541.48 "Игорь Лабутин" Например, взять образ, посмотреть, что получилось внутри, проверить, что он соответствует каким-то политикам компании, только после этого сказать пуш.
541.48 570.32 "Игорь Лабутин" Поэтому теперь, если мы при паблише этого докер-контейнера добавим property в command line под названием container.archive.output.path и там укажем путь к файлику с расширением tar.gz, ну какой угодно можно указать, но по факту там будет tar.gz.archive, то тогда он не будет его пушить, он просто весь полученный докер-образ запакует в этот файлик и можете его анализировать сколько хочете, просто обычный архив с файловой системой.
570.32 580.96 "Игорь Лабутин" А когда это нужно будет потом уже таки закинуть в докер, ну тогда делаете docker load и стандартная команда докера, ну и дальше с ним уже делаете, что хотите, пуш там, просто используете локально.
580.96 583.48 "Игорь Лабутин" То есть нужно не забыть ручками его потом запушить?
583.48 584.48 "Игорь Лабутин" Ну да, конечно.
584.48 590.00 "Игорь Лабутин" Но если у вас есть какие-то стыпы, которые вы хотите руками обрабатывать, ну как бы вы, наверное, не забудете.
590.00 600.88 "Игорь Лабутин" То есть это скорее опять же в пайплайне, то есть вы делаете в пайплайне сначала паблиш в такой архив, потом натравливаете какие-то анализаторы на этот архив, которые там проверят, что это правильный докер, например, и после этого делаете docker push.
600.88 607.72 "Анатолий Кулаков" Да, просто странно, что это шаг паблиша, они складывают в архив в шаге паблиша.
607.72 613.56 "Анатолий Кулаков" Было бы лучше какую-нибудь команду новую добавить, типа забилди мне контейнер, а потом паблишить как бы наверх.
613.56 614.56 "Игорь Лабутин" Да, непонятно.
614.56 615.56 "Игорь Лабутин" Ну в общем, так сделали.
615.56 619.00 "Игорь Лабутин" С другой стороны, миллиард команд тоже может, не знаю.
619.00 623.48 "Игорь Лабутин" То есть он же паблишит их, в смысле, что, ну да, билд наверное все-таки правильнее.
623.48 624.48 "Игорь Лабутин" Ладно.
624.48 633.80 "Игорь Лабутин" Дальше у нас добавили некоторое количество новых API в библиотеку классов, к счастью, не совсем стандартные, но это все-таки в отдельном нуге от пакетики.
633.80 645.04 "Игорь Лабутин" Называется tensor primitives, то есть это штуки, которые позволяют более оптимально писать код, который вам нужен, если вы занимаетесь каким-нибудь там искусственным интеллектом, машин лернингом и прочим всем таким.
645.04 647.52 "Игорь Лабутин" Не знаю, кто этим занимается на тот момент, но наверное кто-то занимается.
647.52 650.52 "Анатолий Кулаков" Ну чего ты прям, ну занимаются, наверное, что-нибудь.
650.52 655.96 "Игорь Лабутин" Ну наверное занимаются, но все-таки в основном, мне кажется, таким занимаются на компьютерчике и чего-нибудь другом.
655.96 657.96 "Игорь Лабутин" Ну то есть… Есть же разные сценарии.
657.96 658.96 "Игорь Лабутин" Наверное, наверное.
658.96 663.36 "Игорь Лабутин" Ну в общем, вот есть, наверное, все-таки если бы совсем не было клиентов, не делали бы, наверное, кто-то попросил.
663.36 666.68 "Анатолий Кулаков" Конечно, и на журе там очень много сервисов, которые как бы под это заточены.
666.68 667.68 "Анатолий Кулаков" Ну да, да.
667.68 668.68 "Игорь Лабутин" Может аж ужасно сами для себя делали.
668.68 686.92 "Игорь Лабутин" Короче, штука эта, это в некотором смысле, так скажем, эволюция вот этих номериков для AI, то есть отдельный пакет, подназывается system numeric tensors, и он будет стабильным в восьмёрке, то есть его добавили вот только-только, но уже обещали, что это будет с table API в dotnet 8.
686.92 700.96 "Игорь Лабутин" И там, по сути, это просто набор викторизованных операций, всяких там типа hypertangents, ну как, не, как называется этот, не гипер, я забыл весь матанализ уже, ребята, ладно.
700.96 706.56 "Игорь Лабутин" Короче, всякая разная тригонометрия, которая, видимо, нужна для правильных операций.
706.56 711.12 "Анатолий Кулаков" Вот это мне нравится, смотри, cosine similarity.
711.12 724.12 "Игорь Лабутин" Ну да, похожесть по косинусу, ну хорошо, наверное, это есть правильный математический термин, но мы не являемся правильными ребятами для этого, поэтому простите меня, мои учителя матанализа, я всё забыл, и матстатистики.
724.12 728.08 "Игорь Лабутин" Прошло уже больше, почти 20 лет прошло с этого момента, так что ладно.
728.08 730.08 "Анатолий Кулаков" И вот она наконец-то пригодилась.
730.08 731.08 "Анатолий Кулаков" Пригодилась, блин, да.
731.08 736.16 "Анатолий Кулаков" Когда-то тригоносинус, тригонокосинус тебе пригодятся, вот видишь, а оказывается, пригодились бы, если бы ты хорошо учился.
736.16 737.16 "Игорь Лабутин" Да.
737.16 742.60 "Игорь Лабутин" Ладно, на этом, собственно, в основном, на сегодня всё, дальше у нас ASP.NET Core.
742.60 747.40 "Игорь Лабутин" Тут не так много изменений, таких важных и больших, но тем не менее.
747.40 775.56 "Игорь Лабутин" Во-первых, у нас есть HTTP логин к Middleware, напомню, стандартный Middleware от Microsoft, который умеет логировать запросы и ответы, и там добавили некоторые поля, то есть там такой есть enum, который, флаговый enum, насколько я помню, который задаёт, собственно, о чём надо логировать, и туда добавили несколько вещей, несколько флагов, туда добавили duration, который будет писать вам новый лог-месседж в конце запроса, где будет написано, сколько всё это заняло.
775.56 784.48 "Игорь Лабутин" Можно указать опцию combine logs, и тогда все вот эти вот логи, которые включены вот этими флажками, будут написаны один раз в самом конце, в одном месседже.
784.48 787.12 "Игорь Лабутин" Это может быть удобно.
787.12 804.04 "Игорь Лабутин" И добавили интерфейс под названием IHTTP Logging Interceptor, и если вы его реализуете и закинете в контейнер, в DI-контейнер, то тогда там есть callback, который будет вызываться на каждый request-response, и вы можете кастомизировать, что логирует.
804.04 812.64 "Игорь Лабутин" Ну типа там, если это request-housecheck, то не логирует ничего, а если это request какой-нибудь важный, то он логирует всё, а если это authorization, то не логирует запросы, потому что там пароль.
812.64 813.64 "Игорь Лабутин" Ну в таком духе.
813.64 816.40 "Игорь Лабутин" Можно будет кастомизировать, если хотите.
816.40 820.36 "Анатолий Кулаков" Мне нравится больше Middleware, который поставляет Serialoc с SPNet пакет.
820.36 824.60 "Анатолий Кулаков" В общем, у неё точно такая же есть Middleware, но на замену микрософтовской.
824.60 829.16 "Анатолий Кулаков" В общем, посмотрите, у неё там и настройки поприятнее, и вообще она работает покрасивше.
829.16 834.72 "Игорь Лабутин" Ну и она, скорее всего, логирует всё правильно и, так сказать,
834.72 840.44 "Анатолий Кулаков" структурно. Ну микрософтовская тоже структурно логирует, там же структурный логер, ты от этого никуда не денешься.
840.44 843.64 "Анатолий Кулаков" Ну например, то же самое Duration и CombineLog у них были довольно-таки давно.
843.64 849.72 "Анатолий Кулаков" А ещё она прекрасна тем, что её можно там легко скопировать, говоря, и прям под ваш собственный проект закастомизировать.
849.72 853.28 "Анатолий Кулаков" Без всяких вот этих флажков, enumов, интерцепторов и прочей ерундистики.
853.28 855.48 "Анатолий Кулаков" Просто нормальным кодом, там буквально 100 строчек.
855.48 864.56 "Игорь Лабутин" Ну да, у нас тоже, по-моему, в проекте была своя откуда-то скопипачена, может, кстати, даже из Serialoc или просто сами написаны по мотивам.
864.56 871.20 "Игорь Лабутин" Дальше, Identity Model обновились до Identity Model 7x, чтобы это не значило.
871.20 872.20 "Игорь Лабутин" В статье так и написано.
872.20 874.80 "Игорь Лабутин" Вероятно, в 7 раз быстрее и в 7 раз лучше.
874.80 890.40 "Игорь Лабутин" Но там обновился JSON Web Token Handler, это что, которое ответственно, собственно, за обработку JVT, и появилась полная nativeout совместимость, то есть теперь S/Panet Core ещё ближе к полному nativeout.
890.40 894.04 "Игорь Лабутин" Form файлы теперь поддержаны в Minimal API.
894.04 898.16 "Игорь Лабутин" Раньше были поддержаны только, собственно, Form Binding, и теперь можно прям Form файлы туда засылать.
898.16 904.16 "Игорь Лабутин" SignalR TypeScript Client Stateful Reconnect Support.
904.16 911.16 "Игорь Лабутин" Из TypeScript теперь он будет сам реконнектиться к SignalR хосту, соответственно, прозрачно для вас.
911.16 914.08 "Игорь Лабутин" В Blazor очень много изменений традиционно.
914.08 916.08 "Игорь Лабутин" Global Interactivity.
916.08 919.60 "Игорь Лабутин" Штука довольно интересная и полезная.
919.60 942.92 "Игорь Лабутин" Если вы помните, была такая штука, называется Interactive Render Mode, которую можно было включить для отдельных страничек, и она делала следующее, то есть когда вы загружаете страничку, он сначала рендерил её серверсайдом, отдавал вам HTML, грубо говоря, и пока вы там на не net.html смотрите, он в граунде грузил полноценную уже webass, вот это всё, чтобы потом в браузере начать то же самое делать.
942.92 947.64 "Игорь Лабутин" Теперь это можно включить прям вообще на всё приложение, включая раутер и лейаутинг.
947.64 958.40 "Игорь Лабутин" В общем, посмотрите, детально я Blazor особо не пользуюсь, поэтому не могу вам сильно детально рассказать, но может, Толя что-то знает на эту тему про Interactivity
958.40 969.48 "Анатолий Кулаков" штуку. Нет, я давно уже Blazor не пользовался, поэтому если у вас есть специалисты по Blazor, приходите, нам как раз нужно сайтик написать на чего-нибудь новомодном, я имею в виду для подкаста, так что заходите.
969.48 981.72 "Игорь Лабутин" Да, в WebAssembly Template Updates шаблончики обновили, там просто навели порядок, мне кажется, то есть есть теперь у нас Blazor WebApp Template, который полностью один и покрывает все варианты.
981.72 997.04 "Игорь Лабутин" Иногда вам нужно хостить Blazor внезапно без ASP.NET Core, ну то есть традиционный майкрософтский подход, что вам ASP.NET Core нужен, но технически вы можете захостить Blazor Up, например, в GitHub Pages, ну потому что Blazor Up просто WebAssembly, в который файлик с этой статикой загружается.
997.04 1008.96 "Игорь Лабутин" И поэтому теперь у нас есть WebAssembly Standalone App, там соответственно как раз будет этот самый без ASP.NET Core, и можно его использовать, если вам надо.
1008.96 1017.32 "Игорь Лабутин" И удалили из-за этого Blazor WebAssembly App Empty Project Template, и короче было очень много, теперь их стало 2, WebAssembly и WebAssembly Standalone.
1017.32 1022.44 "Анатолий Кулаков" Ну там по идее еще должен какой-нибудь MAU подключиться, который может хостить Blazor, может мобилки.
1022.44 1025.76 "Игорь Лабутин" Ну да, но вот про MAU тут как-то ничего не было в этом
1025.76 1028.76 "Анатолий Кулаков" контексте. Ну по нем да, или хорошо, или ничего.
1028.76 1045.36 "Игорь Лабутин" Да, дальше соответственно про Blazor, там много-много-много разных мелочей, типа там всякие разные, что-то по контексту можно теперь доступаться, как Cascading Manager, Component State можно персистить, DI поддерживает те самые Keyed Services, которые с зависимостью по именам.
1045.36 1052.80 "Игорь Лабутин" В общем много чего изменилось, пишите на Blazor, посмотрите статью, наверняка знаете лучше даже нас, что там поменялось.
1052.80 1073.36 "Игорь Лабутин" И в Identity появился еще одна штука, буквально мы недавно обсуждали ASP.NET Core Identity Endpoints, или как они там правильно называются, Endpoints, да, которые по сути пришли на замену стандартному Identity UI, который был на Razer, и если вам Razer UI не подходил, то вот вам теперь набор Endpoints, который значит вам все будет делать.
1073.36 1075.56 "Игорь Лабутин" Но проблема в том, что у вас теперь нет UI.
1075.56 1102.76 "Игорь Лабутин" Так вот, начиная с Release Candidate 2, у вас теперь есть UI, он немножко обрезанный, он на Blazor, называется Blazor Identity UI, поддерживает он только индивидуальные аккаунты, то есть там сейчас не будет работать всякая федерация там, Shared, как там это, Single Sign-On и вот это все, но они работают над этим, и вероятно к следующим каким-нибудь релизам у нас будет нормальный Identity UI.
1102.76 1110.40 "Игорь Лабутин" С нормальной возможностью кастомизации, встраивания во всякие Single Page Application Framework, типа там React, Angular и прочего.
1110.40 1114.76 "Анатолий Кулаков" То есть мы удалили Razer UI для того, чтобы преподнести Blazor UI.
1114.76 1115.76 "Игорь Лабутин" Типа того.
1115.76 1118.12 "Игорь Лабутин" Причем не полный, не абсолютно функциональный.
1118.12 1119.88 "Анатолий Кулаков" Ну не настолько функциональный.
1119.88 1124.00 "Анатолий Кулаков" Ну, написали его между двумя релиз-кандидатами, ну побойся
1124.00 1126.00 "Игорь Лабутин" бы. Ну, видимо, да, обыскный пудок.
1126.00 1127.76 "Игорь Лабутин" Файл остался, мало репозиторий, надо добавить.
1127.76 1148.96 "Игорь Лабутин" Так, ну и для Single Page Application, если вы внезапно пишете свой фронтенд к дотнету на Angular или React, у dotnet.run появилась опция launch profile.tps, которая автоматически запустит и серверы, и фронтенд, как я понял, не пробовал, там что-то мутное написано.
1148.96 1156.60 "Игорь Лабутин" Автоматически, а ну да, автоматически стартует JavaScript Development Server написано.
1156.60 1158.16 "Игорь Лабутин" Ну, как бы, ладно.
1158.16 1168.88 "Игорь Лабутин" Видимо, если мы понимаем, что у вас в проекте есть еще и условный фронтенд какой-то, он автоматически запустит вам тот сервер, который будет сервить вам JavaScript часть.
1168.88 1169.88 "Игорь Лабутин" На этом все в Aspire.core.
1169.88 1173.88 "Игорь Лабутин" Evecore тоже выпустил статью про релиз-кандидат.
1173.88 1182.08 "Игорь Лабутин" Ну, как обычно, они, это не то, что из них не сделали релиз-кандидат, это они так хайлайтят то, что было сделано потихонечку во время релиза.
1182.08 1185.76 "Игорь Лабутин" Вот, как мне кажется, может я ошибаюсь.
1185.76 1189.48 "Игорь Лабутин" Из интересных вещей добавили следующие штуки.
1189.48 1204.96 "Игорь Лабутин" Во-первых, Entity Framework поддерживает штуку под названием sentinel values, то есть если у колонки есть дефолтное значение, то в принципе Entity Framework понимает, что если значение в поле совпадает с дефолтным значением колонки, то можно эту колонку в базу не посылать.
1204.96 1207.32 "Игорь Лабутин" Ну, зачем лишний трафик гонять.
1207.32 1216.08 "Игорь Лабутин" Но проблема в том, что обычно раньше использовали для этого то, что называется default value.
1216.08 1222.96 "Игорь Лабутин" То есть Entity Framework всегда считал, что единственная возможная sentinel value — это default, в смысле null, там ноль и так далее.
1222.96 1228.96 "Игорь Лабутин" Теперь можно это задавать, то есть можно, например, сказать, что для вот этой колонки дефолтное sentinel value — это -1.
1228.96 1234.60 "Игорь Лабутин" И если в этой колонке будет -1, то Evecore не будет ее посылать в BD.
1234.60 1238.98 "Игорь Лабутин" Может быть полезно для каких-нибудь странных ваших дефолтов.
1238.98 1253.60 "Игорь Лабутин" Execute, Update и Execute, Delete там получили улучшение в случае, когда там есть owned type, которые, как известно, содержатся в той же таблице, что и основной item, основная сущность.
1253.60 1256.48 "Игорь Лабутин" Вот раньше они там не очень хорошо работали, теперь работают нормально.
1256.48 1273.56 "Игорь Лабутин" Если у нас есть contains оператора в linq, который вы используете внутри в вашей сабквере, то тогда теперь будет генерироваться в SQL оператор in вместо exist, потому что это позволяет сделать, обычно позволяет сделать чуть более оптимальный SQL.
1273.56 1289.84 "Игорь Лабутин" Еще одна штука, которая довольно специфическая, я не знаю, кому это может быть надо, но SQL Client у нас экспоузит штуку под названием row_version, это работает только для ажурного SQL, ну либо SQL Server.
1289.84 1292.52 "Игорь Лабутин" Зачем вам, может быть, row_version нужен?
1292.52 1297.92 "Игорь Лабутин" Ну например, для призвала каких-нибудь конфликтов при коммитах, еще чего-нибудь.
1297.92 1313.60 "Игорь Лабутин" Так вот по дефолту это byte_array, но в EF8 теперь вы можете замапить эту штуку куда угодно, в long, в oolong и так далее, конвертнуть и с ней нормально работать как с чиселкой, а не с массивом byte.
1313.60 1317.12 "Игорь Лабутин" Видимо какая-то нишевая штука, я как-то с row_version особо никогда не работал.
1317.12 1324.96 "Анатолий Кулаков" Слушай, я работал с row_version очень много, и он мне был мега полезен, я ему мега радовался, но я забыл зачем.
1324.96 1340.04 "Игорь Лабутин" Вот я помню, единственное, где я с ним встречался, это когда тебе, именно с entity framework, когда тебе он кидал, как же там это называется, conflict exception, когда он не может закоммитить, потому что понимает, что оптимистик конкуренции не сработает.
1340.04 1346.16 "Игорь Лабутин" А вот concurrency violation exception вспомнил, и вот там по row_version можно было что-то разрулить в том числе, чтобы понять.
1346.16 1351.24 "Анатолий Кулаков" По-моему да, это же автоматическая версия каждой записи в ms_sql.
1351.24 1352.24 "Анатолий Кулаков" А, ну тогда да, тогда decaf_parent.
1352.24 1353.24 "Анатолий Кулаков" Вот, ну вот теперь ее можно.
1353.24 1354.24 "Анатолий Кулаков" То, что надо.
1354.24 1364.52 "Игорь Лабутин" Можно прям как бы завести proper_to, обозвать ее там longom или ulongom, и entity framework будет туда мапить.
1364.52 1380.56 "Игорь Лабутин" SQL-генерация тоже чуть-чуть улучшилась в том плане, что он теперь генерирует меньше скобочек, раньше он там аккуратно расставлял скобочки вообще почти вокруг каждого логического выражения, теперь он чуть более умный, понимает, где их нужно поменьше, потому что читалось действительно иногда слишком много.
1380.56 1382.84 "Анатолий Кулаков" Где-то lisp заплакал в сторонке.
1382.84 1386.04 "Игорь Лабутин" Да, да, да, ну и много еще разных всяких мелких фич.
1386.04 1407.60 "Игорь Лабутин" Ну и помимо этих троих наших основных ребят, конечно же, выпустили свою статью Maui, где у них улучшение качества, догадайся, они конечно же улучшили performance, они пофиксили контроллы, они сделали некоторое количество платформ-специфик фиксов без каких-то сильных деталей, насколько я помню, статью, по крайней мере себе я не выписывал никаких деталей.
1407.60 1417.92 "Игорь Лабутин" Ну и в качестве бонуса некоторые из этих фиксов, они были забэкпорчены в .NET 7, самые такие memorelicia и так далее.
1417.92 1434.52 "Игорь Лабутин" Ну и бонус 2, как написано в статье, это теперь у нас есть поддержка Xcode 15, если вы хотите писать под самую последнюю 17-ю iOS, ну и Android API 34, это видимо какой-то тоже самый последний Android API, но для этого вам нужна студия Preview 3.
1434.52 1447.24 "Игорь Лабутин" Ну вот такие дела у нас с релиз-кандидатом, прям прорывных фич нет, пожалуй вот MS Build только штука, это самое такое видимое, что поменялось, все остальное какие-то такие мелкие улучшения, полировки и добавки.
1447.24 1454.32 "Анатолий Кулаков" Ну нормально, я вообще удивляюсь, что в релиз-кандидате хоть что-то кроме performance улучшений нам поставляют, так что уже хорошо.
1454.32 1458.20 "Игорь Лабутин" Да, ну что, давай дальше, что у нас есть еще сегодня.
1458.20 1466.76 "Анатолий Кулаков" Еще у нас Microsoft и в частности Richard Lander запустили интересную серию статей, которая называется "Удобство в Дотнете".
1466.76 1479.04 "Анатолий Кулаков" Это мы с тобой помнишь упоминали какую-то серию типа "Дотнет для начинающих, зачем использовать Дотнет" и все такое, вот они как-то ее туда прицепили, чтобы показать, как Дотнет заботится об удобстве.
1479.04 1484.40 "Анатолий Кулаков" В общем, несмотря на вот эту попсовую линейку, попсовый форм, статья вышла довольно интересная.
1484.40 1487.72 "Анатолий Кулаков" Поэтому давайте мы с вами немножко познакомимся, что такое удобство вообще.
1487.72 1494.52 "Анатолий Кулаков" И прежде всего, товарищ Ричард сообщает, что к удобству нельзя относиться как к какому-то бинарному флагу.
1494.52 1496.56 "Анатолий Кулаков" Есть удобство или нет удобства?
1496.56 1505.64 "Анатолий Кулаков" На самом деле, когда мы говорим о такой широкой штуке, как Дотнет, который должен в принципе удовлетворять абсолютно всех на любых уровнях, то там удобство это некий спектр.
1505.64 1510.36 "Анатолий Кулаков" Спектр, который способен удовлетворить все потребности на всех уровнях.
1510.36 1514.64 "Анатолий Кулаков" Ну, лучше всего это видно, например, на API для работы с файлами.
1514.64 1526.28 "Анатолий Кулаков" Вы можете файл прочесть с помощью одного единственного метода, который называется, например, readAllText, передав ему имя файла и получив строку, которая олицетворяет собой контент этого файла.
1526.28 1528.04 "Анатолий Кулаков" Как бы просто, понятно и все такое.
1528.04 1540.96 "Анатолий Кулаков" А можете сделать это очень гибко, например, через файл openHandle, контролируя полностью флажки доступа, расшаренность ресурсов, асинхронность чтения, различные рандомные точки доступа к этому файлу.
1540.96 1545.96 "Анатолий Кулаков" В общем, получить полную максимальную гибкость, которая только возможна на уровне операционной системы.
1545.96 1548.12 "Анатолий Кулаков" И вроде тоже, как бы, прочитали файлик.
1548.12 1555.72 "Анатолий Кулаков" В принципе, и там, и там вы справились, и там, и там решили свои потребности, но абсолютно разными затратами и с абсолютно разной эффективностью.
1555.72 1559.52 "Анатолий Кулаков" Но нужен и тот, и тот уровень, естественно, тоже.
1559.52 1561.00 "Анатолий Кулаков" И, например, с жессоном.
1561.00 1566.64 "Анатолий Кулаков" Может, файлики в наше время уже люди не так часто читают, как в моей молодости.
1566.64 1568.80 "Анатолий Кулаков" Но вот с жессоном, я думаю, каждый из нас работал.
1568.80 1572.00 "Анатолий Кулаков" В общем, с жессоном тоже можно работать на куче разных уровней.
1572.00 1580.80 "Анатолий Кулаков" Вы можете воспользоваться UTF-жессон-ридером и через пайпы, и через спаны, и через мемори таскать к себе какие-то там страшные байтики.
1580.80 1588.56 "Анатолий Кулаков" А можете, как нормальный человек, в одну строчку jessons-сериалайзер и засунуть туда строку, или получить строку и нормально себя чувствовать при этом.
1588.56 1597.52 "Анатолий Кулаков" Поэтому, когда мы говорим об удобстве, нам нужно понимать, что у каждого удобства свое, и .NET должен покрыть абсолютно все надобности, которые только есть.
1597.52 1603.24 "Анатолий Кулаков" И вот первая статья в этом цикле про удобства как раз-таки и касается jessons-сериализатора.
1603.24 1612.56 "Анатолий Кулаков" И мы с вами сейчас посмотрим вообще, какие есть способы доступа к jesson в современном .NET и что они себе представляют.
1612.56 1622.24 "Анатолий Кулаков" В общем, прежде всего нужно упомянуть, что у .NET-овского jesson есть знаменитый предок.
1622.24 1623.96 "Анатолий Кулаков" Это Newton Soft Jesson.
1623.96 1627.60 "Анатолий Кулаков" Автор которого, кстати, сейчас работает в Microsoft.
1627.60 1631.08 "Анатолий Кулаков" И этот Newton Soft, он довольно популярный.
1631.08 1642.32 "Анатолий Кулаков" Все еще до сих пор есть огромное количество приложений, которые когда-то использовали Newton Soft и до сих пор не смогут с него свезть, потому что написали каких-нибудь своих кастомных конвертеров и всего такого.
1642.32 1646.48 "Анатолий Кулаков" Поэтому новые проекты обычно на Newton Soft не пишут, но старые поддерживаются.
1646.48 1651.80 "Анатолий Кулаков" И в принципе библиотека тоже довольно стабильная, она все еще поддерживается, и никто ее забрасывать не собирается.
1651.80 1659.32 "Анатолий Кулаков" И там мигрировать срочно, наверное, никакого смысла нет, если вы не гонитесь просто за эстетикой.
1659.32 1666.68 "Анатолий Кулаков" В общем, рассмотрим, что есть в современном .NET, и плюс сравним немножко с Newton Soft Jesson, который как бы уже был, но все еще с нами.
1666.68 1677.32 "Анатолий Кулаков" Прежде всего, самый верхнеуровневый интерфейс, это самый верхний уровень, с которым вы можете общаться, это jesson-сериалайзер.
1677.32 1684.64 "Анатолий Кулаков" То есть это специальный класс, специальная обертка, которая решает очень много, огромную кучу различных вопросов автоматически.
1684.64 1691.92 "Анатолий Кулаков" У нее есть автоматические опции, какие-то автоматические конвертеры, которые вы больше всего ожидаете, какие-то автоматические распознавалки.
1691.92 1697.24 "Анатолий Кулаков" В общем, она пытается одной строчкой удовлетворить абсолютно всех, и в большинстве случаев у нее это даже неплохо получается.
1697.24 1709.08 "Анатолий Кулаков" У нее же есть source-генераторы, которые появились, наверное, в одном из первых компонентов, которые были в Microsoft, вот появились они как раз в jesson-сериалайзере, потому что такой довольно важный компонент.
1709.08 1711.44 "Анатолий Кулаков" И у нее есть там куча всяких дефолтных поведений.
1711.44 1718.24 "Анатолий Кулаков" Это должен быть ваш выбор по дефолту, если вы захотите что-то засериализовать или что-то десериализовать.
1718.24 1720.12 "Анатолий Кулаков" Берете в первую очередь jesson-сериалайзер.
1720.12 1724.60 "Анатолий Кулаков" И вот если вам его почему-то не хватает, вот тогда уже рассматривайте другие варианты.
1724.60 1727.32 "Анатолий Кулаков" Что можно предложить из других вариантов?
1727.32 1730.92 "Анатолий Кулаков" Например, jesson-документ и jesson-нод.
1730.92 1736.80 "Анатолий Кулаков" Это своеобразная дом, дом-модель вашего jesson-документа.
1736.80 1743.32 "Анатолий Кулаков" Она вам может пригодиться, например, когда у вас нет строгого типа, под который вы могли бы это все десериализовать.
1743.32 1747.40 "Анатолий Кулаков" Так пусть к вам приходит какой-то jesson-документ, и вы понятия не имеете, какие там поля.
1747.40 1749.72 "Анатолий Кулаков" Вам нужно взять этот документ и по нему просто полазить.
1749.72 1754.60 "Анатолий Кулаков" Отсканировать там эти поля, посмотреть, какие там значения есть, каких нет, как-нибудь походить по нему.
1754.60 1758.88 "Анатолий Кулаков" Вот всю эту тему решает как раз jesson-документ и его jesson-нод-модель.
1758.88 1768.60 "Анатолий Кулаков" Вы будете с этим документом оперировать не DTO-шками, потому что у вас, соответственно, нет DTO-шек, которых вы можете предсказать, а узлами.
1768.60 1770.48 "Анатолий Кулаков" И эти узлы там будут различного типа.
1770.48 1771.48 "Анатолий Кулаков" jesson-object, jesson-array, jesson-value.
1771.48 1779.88 "Анатолий Кулаков" И в зависимости от анализа каждого типа, каждого этого узла, можно с этим документом делать что-то следующее, другое.
1779.88 1783.04 "Анатолий Кулаков" Очень сильно похоже на XML-дом, если вы с ним работали.
1783.04 1790.32 "Анатолий Кулаков" Очень сильно похоже на Roslyn-дом, если вы парсили там C# файлы, допустим, или писали C# анализаторы.
1790.32 1793.72 "Анатолий Кулаков" В общем, работа с домом, она в принципе везде одинакова.
1793.72 1796.68 "Анатолий Кулаков" И вот в jesson-е вы тоже можете с ним таким образом работать.
1796.68 1807.40 "Анатолий Кулаков" В общем, для того, чтобы программно писать и читать jesson, особенно если у вас нет какой-то строгой модели, которую вы можете предсказать и засунуть в сериализатор.
1807.40 1815.28 "Анатолий Кулаков" И самый низкий уровень, на который вы только можете опуститься, это UTF-8 jesson-reader или -writer.
1815.28 1817.48 "Анатолий Кулаков" Это самый базовый компонент.
1817.48 1826.00 "Анатолий Кулаков" Вообще, ручное управление памятью, стрингами, спанами, лайтами, вообще закат солнца вручную делается специально с помощью него.
1826.00 1836.00 "Анатолий Кулаков" И в принципе все те компоненты, которые мы с вами выше обсудили, они под капотом, естественно, построены на основе вот этого UTF-8 jesson-reader или -writer.
1836.00 1839.20 "Анатолий Кулаков" То есть это базовый блок, базовая конструкция для всего.
1839.20 1846.04 "Анатолий Кулаков" Он вам дает максимум гибкости, вы с ним можете творить абсолютно все, что угодно, читать абсолютно все, что угодно.
1846.04 1855.68 "Анатолий Кулаков" У него очень низкоуровневый API, у него очень низкоуровневые концепции работы с памятью, работы с рандомным доступом, с синхронностью к битам, к байтам.
1855.68 1864.40 "Анатолий Кулаков" В общем, очень низко, очень хардкодно и в нормальной жизни вы, наверное, не хотите с этим сталкиваться и вряд ли должны с этим сталкиваться.
1864.40 1877.88 "Анатолий Кулаков" Но если у вас есть какая-то большая специфика или вам нужно очень срочно разобрать какие-то огромные файлы, при этом читая через строчку или записывая через букву, то, наверное, вам придется сюда, к этому интерфейсику и обратиться.
1877.88 1883.76 "Анатолий Кулаков" Итак, автор решил посравнивать немножко эти все подходы.
1883.76 1889.04 "Анатолий Кулаков" Прежде всего, так как концепции у них одинаковые, у них различаются просто подходы.
1889.04 1899.12 "Анатолий Кулаков" Вы должны понимать, что чем уровень ниже, тем сложнее работать с этими концепциями и тем больше кода вам нужно написать для того, чтобы хоть как-то что-то здесь делать.
1899.12 1907.32 "Анатолий Кулаков" Поэтому есть демопроект, в котором он попытался заиспользовать эти сериализаторы, эти подходы в нескольких примерах.
1907.32 1912.20 "Анатолий Кулаков" И вот для того, чтобы заиспользовать JSON-сериализатор, ему пришлось за им приметить 84 строчки.
1912.20 1917.04 "Анатолий Кулаков" Он решил помериться с строчками для того, чтобы показать общую сложность данного подхода.
1917.04 1925.60 "Анатолий Кулаков" Newtonsoft у него обошелся в 94 строки, а вот JSON-нода уже заняла немножко больше, в 2 раза больше места.
1925.60 1931.68 "Анатолий Кулаков" Это 155, но больше всех поразил, конечно, низкоуровневый UTF-8 JSON Reader и Writer.
1931.68 1934.32 "Анатолий Кулаков" Ему понадобилось 660 строчек.
1934.32 1944.68 "Анатолий Кулаков" То есть это где-то больше чем в 6-7 раз строчек больше нужно написать для того, чтобы вот этим низкоуровневым API-м поработать с JSON-документом.
1944.68 1957.96 "Анатолий Кулаков" Дальше он пошел мерить, бенчмаркать скорости, но бенчмаркер из него ни разу не талб, потому что как-то его понесло.
1957.96 1964.44 "Анатолий Кулаков" Лендер прежде всего сюда учел Network, то есть он начал сюда зачем-то TypeClient переплетать.
1964.44 1971.92 "Анатолий Кулаков" Там на самом деле, конечно, есть специфика некая у JSON, что он может из TypeClient асинхронно дистрибьюзовать, что он может асинхронно использовать.
1971.92 1977.72 "Анатолий Кулаков" Но кажется, что это не так интересно, как сравнить бы вообще скорость этих подходов.
1977.72 1990.24 "Анатолий Кулаков" К сожалению, это повлияло на сравнение скорости, потому что он взял прежде всего самый маленький документ, который он нашел, это 900 байт всего-навсего, и пошел сравнивать.
1990.24 1995.44 "Анатолий Кулаков" И в принципе в попугаях все эти сериализаторы показали одно и то же число.
1995.44 2000.36 "Анатолий Кулаков" Они говорят, да в принципе у тебя дистрибьюзуются за одно и то же время.
2000.36 2003.68 "Анатолий Кулаков" Если разобраться, то там 90% этого времени как раз занимал Network.
2003.68 2008.92 "Анатолий Кулаков" И вот после этого он пошел отключил Network, но опять же, значения остались примерно на том же самом уровне.
2008.92 2012.92 "Анатолий Кулаков" Потому что накладные расходы на данном уровне, они почти константы.
2012.92 2017.12 "Анатолий Кулаков" А эти 900 байт прочитать можно всем чем угодно, с одной и той же скоростью.
2017.12 2020.08 "Анатолий Кулаков" Больше интересно, конечно, большие документы.
2020.08 2023.60 "Анатолий Кулаков" И вот, к сожалению, большой документ для него это 1 мегабайт.
2023.60 2025.88 "Анатолий Кулаков" Ну, как бы 1 мегабайт это вообще ни разу не большой документ.
2025.88 2028.92 "Анатолий Кулаков" Бывали и больше.
2028.92 2030.32 "Анатолий Кулаков" Почему 1 мегабайт это мало?
2030.32 2031.72 "Анатолий Кулаков" Ну, потому что разницы тоже плохо видны.
2031.72 2039.88 "Анатолий Кулаков" Вот если мы берем самый наш Performance, UTF-8, Low Level и все такое, он выдает у нас примерно 46 попугаев.
2039.88 2043.52 "Анатолий Кулаков" Дальше у нас идет JSON-сериалайзер, это 111 попугаев.
2043.52 2044.80 "Анатолий Кулаков" Ну ладно, пусть в два раза больше.
2044.80 2050.12 "Анатолий Кулаков" JSON-ноду, если мы возьмем, это 120 попугаев, примерно столько же.
2050.12 2053.32 "Анатолий Кулаков" Newtonsoft где-то возле JSON-ноды 116 попугаев.
2053.32 2057.84 "Анатолий Кулаков" И, в принципе, вот картина такая не очень ясная.
2057.84 2064.32 "Анатолий Кулаков" Мы знаем, что наш самый быстрый API работает в два раза быстрее всех остальных, а вот остальные не сильно между собой расходятся.
2064.32 2067.56 "Анатолий Кулаков" На самом деле разница должна все-таки быть побольше и получше.
2067.56 2071.16 "Анатолий Кулаков" Поэтому хотелось бы документы еще больше взять, но почему-то товарищ не взял.
2071.16 2073.32 "Анатолий Кулаков" Что здесь хочется отметить?
2073.32 2075.12 "Анатолий Кулаков" Против всего две вещи.
2075.12 2078.16 "Анатолий Кулаков" По памяти.
2078.16 2084.04 "Анатолий Кулаков" По памяти Newtonsoft жрет немножко больше, чем вот этот System Text JSON наш в любом из подходов.
2084.04 2087.80 "Анатолий Кулаков" И вторая вещь, Newtonsoft по-прежнему довольно конкурентен.
2087.80 2093.56 "Анатолий Кулаков" То есть вы представляете, у нас Microsoft последний, сколько он, 5 лет в этот System Text JSON вкладывался.
2093.56 2097.60 "Анатолий Кулаков" Каждый релиз кричал, что он в 10 раз заоптимизировал и все такое.
2097.60 2102.88 "Анатолий Кулаков" И все равно старина Newtonsoft в принципе довольно не отстает.
2102.88 2105.68 "Анатолий Кулаков" Вполне конкурентно, вполне поддерживает.
2105.68 2111.72 "Анатолий Кулаков" Пусть немножко памяти жрет, пусть немножко дольше себя реализует, но вполне на уровне, на достойном.
2111.72 2113.84 "Анатолий Кулаков" Что тоже может не радовать.
2113.84 2121.48 "Анатолий Кулаков" Лишний раз подтверждает, что если у вас Newtonsoft глубоко вшит в ваше приложение, то может никакого смысла его пока менять и нет.
2121.48 2131.44 "Игорь Лабутин" Да, даже если не глубоко, мне кажется, тоже пока вы не… Ну только если вы бенчмаркаете и поймете, что да, стало как бы в разы лучше, ну тогда как бы окей.
2131.44 2136.12 "Анатолий Кулаков" Ну фишка, кажется, что бенчмаркет тебе этого не докажет, потому что по бенчмаркам он довольно хорош.
2136.12 2145.72 "Игорь Лабутин" Нет, ну в смысле, когда я говорю по бенчмаркете, в данном контексте вы-то, вы там, не знаю, сделайте тестовую сборку вашего проекта, где вы замените и посмотрите, как это влияет на ваши реальные бизнес-кейсы.
2145.72 2149.32 "Игорь Лабутин" Ну вот тебе надо все переписать, а какой смысл в этом доставить?
2149.32 2167.88 "Игорь Лабутин" Да погоди, я же не начал, если ты говоришь, ты сказал, что типа если у вас все глубоко вшито, я говорю, даже если не глубоко вшито, не надо бежать менять, ну просто если не глубоко, если действительно этот сервизатор вам легко поменять, вы можете попробовать, но не надо менять, от того, что у вас легко поменять, просто так менять не надо, мне кажется, работайте, не трогай.
2167.88 2180.88 "Анатолий Кулаков" Я бы в первую очередь смотрел все-таки на риск того, что он рано или поздно сдохнет, ну по крайней мере система TxJson проживет дольше, и вот может быть с этой точки зрения надо постепенно уже начинать его менять.
2180.88 2194.92 "Игорь Лабутин" Тогда с этой точки зрения нужно действительно, если он у вас глубоко зашит, можно пытаться его как-то оттуда выковыривать, а вот если он не зашит и вы можете, вы понимаете, что вы можете достаточно спокойно поменять сервизатор практически в любое время, ну пока и не надо.
2194.92 2202.40 "Игорь Лабутин" Я думаю, что пол интернета будет говорить о том, что Newtonsoft надо срочно менять, если что-то будет с ним случаться.
2202.40 2209.48 "Анатолий Кулаков" С другой стороны, что может случиться, формат JSON стабилизирован и Newtonsoft умеет практически все, что должен уметь.
2209.48 2225.40 "Игорь Лабутин" Ну мне кажется, если какие-нибудь эти самые security дырки найдут большие, знаешь, как в Log4j нашли, вот если что-нибудь в сервизаторе найдут, ну вот как бы, наверное, надо будет либо его патчить, да, и если его не запатчат такой дырки, ну тогда придется менять.
2225.40 2231.40 "Анатолий Кулаков" Ну кажется, что автор довольно ответственный и он следит за продуктом, поэтому мне кажется, что запатчат в любом случае.
2231.40 2232.40 "Анатолий Кулаков" Это хорошо.
2232.40 2243.88 "Анатолий Кулаков" Так, ну ладно, у нас в принципе по бенчмарке это все, как я уже сказал, бенчмарки не поражают, но сам подход, который нам рассказывает о том, какие вещи есть, когда кого нужно использовать и все такое, довольно приятный.
2243.88 2245.64 "Анатолий Кулаков" Поэтому вот такая статейка.
2245.64 2248.20 "Игорь Лабутин" Ну и прекрасно, давай дальше пойдем.
2248.20 2260.64 "Игорь Лабутин" Дальше у нас снова про performance, ну мы же отслеживались кандидат 2, все становится быстрее, лучше, выше и сильнее, поэтому отдельная статья вышла про то, какие же у нас performance improvements в SP.net core.
2260.64 2265.96 "Игорь Лабутин" Я, кстати, даже не посмотрел, кто автор, интересно, нет, какой-то Брэнон Конрой, не знаю, кто такой, и даже
2265.96 2269.20 "Анатолий Кулаков" это не талб. То есть даже не талб, поэтому можно хотя бы до конца это
2269.20 2283.40 "Игорь Лабутин" читать, да? Да, она не очень большая действительно, и довольно толковая в плане, что, ну там какие-то нормальные числа приведены без каких-либо там огромных бенчмарков, просто довольно приятная статья, почитать, что же там сделали.
2283.40 2286.08 "Игорь Лабутин" Улучшения касаются нескольких вещей.
2286.08 2288.44 "Игорь Лабутин" Во-первых, то, что касается серверов.
2288.44 2295.24 "Игорь Лабутин" Надо напомнить, что серверов у SP.net core 3, это Kestrel, это HTTPS и Ease, ну два последних, естественно, только виндовые.
2295.24 2300.92 "Игорь Лабутин" И в Kestrel улучшили штуку по чтению хедеров.
2300.92 2304.00 "Игорь Лабутин" Значит, что было, в чем была проблема?
2304.00 2318.00 "Игорь Лабутин" Если у нас хедер, мы хедера читаем, естественно, в некоторые временные буферы, байтбуферы, которые там аллокетятся из pool, вот это все, и если у вас хедер целиком помещается в такой байтбуфер, то все прекрасно, все хорошо.
2318.00 2321.20 "Игорь Лабутин" Вы его можете прочитать без особых копирований и так далее.
2321.20 2330.16 "Игорь Лабутин" А вот если он внезапно, ну так получилось, делится между парой байтбуферов, или хедер такой большой, что у нас на несколько залезает, то прям проблема.
2330.16 2334.32 "Игорь Лабутин" Была, ну как проблема, в смысле, что там было лишнее копирование, вот это все.
2334.32 2347.56 "Игорь Лабутин" Теперь сделали так, видимо, магией спанов и всего остального, что нету теперь локейшенов в таком случае, и получили в результате улучшение перформанса аж на 18%.
2347.56 2354.96 "Игорь Лабутин" Ну понятно, что это пустой endpoint, который ничего не делает, который только парсит хедера, но вот такой код на 18% быстрее.
2354.96 2358.00 "Игорь Лабутин" Нашли еще где какие-то проценты, надо быть.
2358.00 2361.08 "Игорь Лабутин" В реале жизни это будут микросекунды, понятное дело, можете не париться.
2361.08 2369.00 "Игорь Лабутин" Дальше у них было довольно много кастомного векторного кода, но теперь у нас есть класс под названием ASCII.
2369.00 2378.60 "Игорь Лабутин" Если вы много работаете именно с ASCII строчками, посмотрите туда, вот там есть куча всяких стандартных векторизованных операций, которые работают именно над ASCII символами, которые под них оптимизированы.
2378.60 2383.16 "Игорь Лабутин" Если вы знаете, что вам приходит только ASCII, то берите его.
2383.16 2400.44 "Игорь Лабутин" В HTTPS добавили интересную штуку под названием Kernel Mode Response Buffering, то есть раньше на уровне ядра, то есть в драйвере вашей таблицы не было буферизации, она не была включена по дефолту, теперь она включена по дефолту.
2400.44 2411.88 "Игорь Лабутин" И при тестовом приложении, которое тестировал автор, это был upload 212 мегабайтного файла, вот ты хотел большие документы, вот тебе.
2411.88 2416.44 "Игорь Лабутин" Берите сетку с задержкой в 200 миллисекунд, в смысле latency сетки.
2416.44 2421.60 "Игорь Лабутин" Без вот этой включенной опции это занимает 11 минут, с включенной опцией 30 секунд.
2421.60 2428.88 "Игорь Лабутин" Потому что понятно, что ядро там, ну в силу особенности протокола TCP, из-за большой latency TCP работает очень медленно и с маленькими буферами.
2428.88 2434.28 "Игорь Лабутин" А если вы буферизуете сами по себе, то это все сильно, сильно-сильно-сильно ускоряет.
2434.28 2449.48 "Игорь Лабутин" Дальше они проделали большую работу с GC Handles, это, напомню, некоторый объект дотнетный, который позволяет вам держать хендлы на, так скажем, unmanaged ресурсы, давайте так скажем, грубо говоря.
2449.48 2469.72 "Игорь Лабутин" И если раньше было много memory pinning и много этих хендлов, а много это значит, что на каждый реквест вы из четырех хедеров, вы аллокейтили 8 GC Handles обязательно, плюс на каждый дополнительный хедер еще по 2 GC Handles, то в восьмерке у вас теперь всегда только 4 GC Handles, независимо от количества хедеров.
2469.72 2472.08 "Игорь Лабутин" И в общем, стал работать быстрее.
2472.08 2476.40 "Игорь Лабутин" Может быть, там даже есть какие-то числа, я не записывал себе в заметке, поэтому не скажу.
2476.40 2480.36 "Игорь Лабутин" В nativeout, nativeout, пожалуй, самая интересная секция.
2480.36 2485.52 "Игорь Лабутин" Значит, смотрите, если мы, во-первых, давайте начнем сначала.
2485.52 2489.60 "Игорь Лабутин" Значит, первонаперво, когда мы говорим nativeout, мы точно подразумеваем trimming.
2489.60 2510.60 "Игорь Лабутин" Мы уже много раз рассказывали, что nativeout приложение при компиляции обязательно включает trimming, потому что если trimming не включить, то туда в разных DLL, типа того же BCL, находится столько кода, который на самом деле не используется, что если весь его оттранслировать в нативный код, то у вас получатся огромнейшие бинарники, поэтому обязательно нужно trimming.
2510.60 2520.92 "Игорь Лабутин" И если мы затримим стандартный hello world, условный, на семерке, то мы получим 28,9 мегабайта, а на восьмерке 17,3.
2520.92 2533.36 "Игорь Лабутин" То есть мы срезали почти половину, на самом деле, потому что больше библиотек теперь проаннотированы всякими разными, типа нужен ли рефлекшн, не нужен ли рефлекшн, и вот это все.
2533.36 2538.04 "Игорь Лабутин" Мы уже говорили тоже в каких-то подкастах про то, что мы добавили новых билдеров.
2538.04 2543.76 "Игорь Лабутин" Раньше у нас был просто create builder, теперь можно создать slim builder, еще можно создать empty builder.
2543.76 2545.36 "Игорь Лабутин" Это тоже влияет на размер.
2545.36 2556.08 "Игорь Лабутин" С create builder у нас приложение получается 17,3, как я сказал, с slim builder 15,5, с empty builder 13,7, то есть примерно по 2 мегабайта с каждого варианта кушается.
2556.08 2561.96 "Игорь Лабутин" Но empty builder неинтересный, потому что там уже даже кестрила нет, если добавить кестрил обратно, то получится 15.
2561.96 2564.96 "Игорь Лабутин" Ну вот примерно с этим, я так понимаю, он дальше и работает.
2564.96 2576.40 "Игорь Лабутин" Если мы говорим уже дальше, ходов в тайм, компиляцию, напоминаю, что мы берем семерочку, триммим ее и получаем 28,9 мегабайт.
2576.40 2585.28 "Игорь Лабутин" Если мы не будем триммить на семерке, то мы получим 88,4 мегабайта, в смысле не триммить и не аотить.
2585.28 2596.44 "Игорь Лабутин" А если мы аотим, то мы из 29,9 мегабайтного файлика на дотнете получаем 40 мегабайтный аот имидж, аот приложение, которое уже готово к работе.
2596.44 2601.00 "Игорь Лабутин" А на восьмерке то же самое, получается 12,5 мегабайт.
2601.00 2602.68 "Игорь Лабутин" Мы в 3 раза уменьшили размер.
2602.68 2604.68 "Игорь Лабутин" Ну неплохо, прям хорошо.
2604.68 2610.72 "Игорь Лабутин" Ну понятно, что это hello world и понятно, что это в основной уменьшение размера за счет библиотеки классов.
2610.72 2615.72 "Игорь Лабутин" То есть если у вас там много вашего кода, то размер будет уже не так сильно уменьшаться, понятное дело.
2615.72 2616.96 "Игорь Лабутин" Но в любом случае полезно.
2616.96 2627.96 "Игорь Лабутин" А второе полезняшко в том, что вот эти 40 мегабайта для семерки, для того чтобы их сгенерить требовалось 71 секунда, а для того чтобы сгенерить 12,5 мегабайт на восьмерке требуется 22 секунды.
2627.96 2629.92 "Игорь Лабутин" Тоже в общем-то в 3 раза быстрее.
2629.92 2633.00 "Игорь Лабутин" А ну да, размер в 3 раза меньше, скорость в 3 раза быстрее, логично же.
2633.00 2637.04 "Игорь Лабутин" Логично, дальше надо так же идти.
2637.04 2638.04 "Игорь Лабутин" Да.
2638.04 2646.00 "Игорь Лабутин" Так, если мы говорим про билдеры, вот этот самый dotnet 8, который 12 мегабайтиков, это полноценный большой билдер.
2646.00 2649.64 "Игорь Лабутин" Если мы возьмем empty builder, который вообще пустой, то там получается приложение с 5,7 мегабайта.
2649.64 2651.60 "Игорь Лабутин" Это, пожалуй, самое маленькое, что вы можете сделать.
2651.60 2654.92 "Игорь Лабутин" То есть это минимальный dotnet runtime с минимальным количеством библиотек.
2654.92 2667.36 "Игорь Лабутин" И дальше вы туда, то есть если вы, например, пишете не asp.net, а просто какую-то command line тулу, берите create empty builder, докидываете туда нужные вам там минимально необходимые компоненты, и у вас будет маленькое приложение там на 6-7 мегабайт.
2667.36 2668.36 "Игорь Лабутин" Мне кажется, прекрасно.
2668.36 2669.36 "Игорь Лабутин" В аот-варианте.
2669.36 2670.36 "Игорь Лабутин" Startup time.
2670.36 2680.64 "Игорь Лабутин" Тут я не буду приводить много чисел, там посмотрите статью, потому что там сравнивается и working set по памяти, и request per second, и всякое такое.
2680.64 2682.60 "Игорь Лабутин" Здесь сказать нужно вот что.
2682.60 2691.72 "Игорь Лабутин" В варианте с аотом у нас гораздо лучший startup time, он примерно на глаз раз в 5 лучше, чем без аота.
2691.72 2698.92 "Игорь Лабутин" А working set тоже раз в 8 лучше, но и rps проседает.
2698.92 2701.60 "Игорь Лабутин" Проседает процентов на 10 приблизительно.
2701.60 2708.00 "Игорь Лабутин" Почему так происходит?
2708.00 2715.84 "Игорь Лабутин" Потому что для того, чтобы добиться вот этого самого маленького working set включается опция под названием dynamically adapting to application size.
2715.84 2731.44 "Игорь Лабутин" Мы рассказывали про статью Маони пару выпусков назад, про то, как мы там подгоняем количество куч на лету под требования приложения, и за счет этого мы получаем гораздо меньший объем памяти, но за счет этого мы как раз получаем меньший rps.
2731.44 2744.32 "Игорь Лабутин" Если эту штуку выключить, ее можно выключить принудительно, то working set у нас обратно взлетает до 400 мегабайт, мы перестаем хоть что-то экономить на памяти, rps взлетает обратно, но не до конца.
2744.32 2770.80 "Игорь Лабутин" То есть аот приложение все еще медленнее немножко с точки зрения rps, ну немножко, в смысле не 762 000 запроса, а 830 000, то есть 1,5% в 5 получается меньше, но все равно, вроде как странно, аот там нет джета, там нет ничего, там все оптимально, вообще все оптимально, а оно все равно меньше.
2770.80 2785.08 "Игорь Лабутин" Но дело в том, что есть еще такая опция optimization preference, вы можете указать при сборке, при паблише, optimization preference равно speed, и тогда у вас возрастает размер приложения, потому что по дефолту стоит size, но зато rps возрастает побольше.
2785.08 2789.24 "Игорь Лабутин" Так что можно там, у аот режима куча опций, с которыми можно играться в этом смысле.
2789.24 2793.68 "Игорь Лабутин" Так, что еще?
2793.68 2797.64 "Игорь Лабутин" Runtime API, что тут?
2797.64 2818.96 "Игорь Лабутин" Ну, заюзали frozen dictionary, заиспользовали memoryextensions.split вместо string.split, то есть смотрите, string.split вообще популярная тема при работе с http, потому что вам нужно, не знаю, там хедра парсить, которые видят ключ значения, параметры парсить из строки запроса и так далее.
2818.96 2823.00 "Игорь Лабутин" String.split в этом смысле прям полезная штука, но проблема в том, что string.split он allocated.
2823.00 2846.68 "Игорь Лабутин" Так вот теперь есть метод memoryextensions.split, который берет вероятно memory или span и возвращает вам коллекцию вероятно span или memory, кто там, memory, а memory по-моему типа так же и называется, да, memory просто, который уже не allocated соответственно и за счет этого при этом все равно splitted, можно выиграть по скорости и сократить расходы памяти.
2846.68 2872.48 "Игорь Лабутин" Ну и всячески разные другие улучшения, performance в regex, в аналайзерах, в stringbuilder, в общем в runtime много чего поменяли, в смысле, заюзали, да, то есть regex оптимизировали и добавили где нужно всякие non-backtracking опции или source генераторы, аналайзеры, которые анализируют ваше не совсем оптимальное использование APIs и подсказывают правильное.
2872.48 2880.68 "Игорь Лабутин" Ну и stringbuilder соответственно тоже поменяли на эти interpolated stringhandlers, которые тоже могут работать чуть быстрее за счет код генерации, source генерации.
2880.68 2900.96 "Игорь Лабутин" И в общем в итоге, ну по числам видно, что стало быстрее, стало меньше к размерам, так что дело движется вперед к еще более быстрому коду, ну опять же, бенчмарки синтетические, надо понимать, поэтому это не значит, что ваш код станет в три раза медленнее и на 20% быстрее, хорошо если процентов на 5, но все равно приятно.
2900.96 2906.64 "Анатолий Кулаков" Ну да, ведь на халяву просто взял перекомпилил и все это в приложении ускорилось, красота же.
2906.64 2912.64 "Игорь Лабутин" Да, тем более breaking change обычно довольно мало и практически безопасно просто перекомпиливать под восьмерку, мне кажется.
2912.64 2916.52 "Игорь Лабутин" Не пробовал еще пока, поэтому не знаю.
2916.52 2920.04 "Анатолий Кулаков" Будем надеяться, что так же как и всегда, перейдем безболезненно.
2920.04 2926.68 "Игорь Лабутин" Давай дальше, C#, C#, давай, у нас релизится, что у нас есть по C# новому?
2926.68 2935.92 "Анатолий Кулаков" К сожалению, по новому C# у нас нет ничего, поэтому пришлось как бы смахнуть скупую мужскую слезу и пойти подумать и посмотреть, а что бы собственно хотелось.
2935.92 2939.52 "Анатолий Кулаков" И как раз тут совпало несколько интересных факторов.
2939.52 2950.76 "Анатолий Кулаков" Я увидел, что некоторые в статьях требуют уже много-много лет как бы discrimination union, и к ним приходят некоторые люди и спрашивают, а что такое discrimination union и зачем они нужны?
2950.76 2955.52 "Анатолий Кулаков" И вот тут я понял, что мы тоже их часто приговаривали, ни разу не рассказывали, а что это.
2955.52 2967.24 "Анатолий Кулаков" И другое интересное событие в том, что Microsoft сам практически их завязал в своем коде и дал нам отличный пример для того, чтобы как бы на настоящем примере, на современном API обсудить и рассмотреть, а что же это такое.
2967.24 2972.36 "Анатолий Кулаков" Поэтому давайте все-таки вспомним, что такое discrimination union и почему всякие стартеры его так сильно хотят.
2972.36 2981.48 "Анатолий Кулаков" Во-первых, этот issue, да, эта просьба, пропозал завели еще в 2017 году.
2981.48 2988.80 "Анатолий Кулаков" Но я, если честно, надеялся, что даже раньше, потому что 2017 это всего 6 лет, не так уж давно.
2988.80 2992.32 "Анатолий Кулаков" Мне казалось, должно было быть сразу, как только F# вышел.
2992.32 3000.44 "Анатолий Кулаков" Потому что в F# юзеры довольно-таки давно уже наслаждаются discrimination union и радуются, и пишут на них код, и кричат, как все это хорошо и удобно.
3000.44 3002.40 "Анатолий Кулаков" Мы же в C# до сих пор не можем этого дождаться.
3002.40 3014.80 "Анатолий Кулаков" В общем, оттуда все из функционалей языков, из F#, из алгебрических типов данных, вот приползают к нам какие-то красноглазики и просят вот в C# тоже добавить.
3014.80 3031.80 "Анатолий Кулаков" Прежде всего discrimination union можно охарактеризовать таким образом, что это тип данных, который позволяет вам задекларировать некий набор типов, который не может выходить за вот этот ограниченный, предефайнутый набор значений.
3031.80 3039.16 "Анатолий Кулаков" Наверное, на слух понимать это довольно-таки сложно, но на самом деле концепция довольно тривиальная.
3039.16 3049.12 "Анатолий Кулаков" То есть у вас есть, представьте, как будто у вас есть какая-то определенная иерархия классов, и у этой иерархии строго определенное число наследников.
3049.12 3052.56 "Анатолий Кулаков" Вот в принципе можно свести все к такой концепции.
3052.56 3059.48 "Анатолий Кулаков" Ну более того, даже F#, discrimination union, они к этой концепции в конце концов сводятся при компиляции в ИЛЬ-код.
3059.48 3062.48 "Анатолий Кулаков" Они просто в коде выглядят более красиво.
3062.48 3073.28 "Анатолий Кулаков" У них есть такой синтаксический сахар, который позволяет декларировать вот эту иерархию очень связанно, то есть в одном месте вы можете задекларировать абсолютно всю иерархию классов, грубо говоря.
3073.28 3078.48 "Анатолий Кулаков" И у каждого из этих классов есть свои собственные атрибуты, свои собственные свойства, методы и так далее.
3078.48 3080.72 "Анатолий Кулаков" Все это можно записать в одну строчку.
3080.72 3085.80 "Анатолий Кулаков" Но главная фишка не в том, как она удобно и компактно декларируется.
3085.80 3104.08 "Анатолий Кулаков" Фишка в том, что это новый концептуальный тип, который понимает и компилятор, и весь инструментарий вокруг компилятора, в частности и DE, и анализаторы, и прочие-прочие другие тулинги, которые помогают вам строить код более понятно, гибко и самое главное надежно.
3104.08 3107.80 "Анатолий Кулаков" Ну зачем это может понадобиться?
3107.80 3109.92 "Анатолий Кулаков" Самый типичный пример – это возвращаемые значения.
3109.92 3122.56 "Анатолий Кулаков" Представьте, у вас есть метод, который называется RegistryUser, то есть метод, который регистрирует пользователя, и этот метод в зависимости от того, получилось у него или не получилось, может, например, вернуть три разных результата.
3122.56 3126.36 "Анатолий Кулаков" Ну, во-первых, если все хорошо, он вам вернет пользователя, которого он зарегистрировал.
3126.36 3137.96 "Анатолий Кулаков" Во-вторых, если в пользователе не прошел валидацию, он вам, например, может вернуть какой-нибудь invalid username validation error, в котором будет написано, что не получилось, что ему не нравится, как не прошло.
3137.96 3150.88 "Анатолий Кулаков" Ну и в-третьих, может вернуть, например, db unavailable, какое-нибудь исключение, потому что база данных недоступна, пользователя не могу записать в эту базу данных, не знаю, что делать, internal server error, работать не могу.
3150.88 3156.76 "Анатолий Кулаков" Вот примерно три стандартных состояния, которые обычно хочется вернуть практически из любого метода.
3156.76 3169.04 "Анатолий Кулаков" И самое интересное, подчеркну, что эти на самом классике, хотя я вам и говорил про иерархию, в общем случае, все эти три результата, они друг от друга никак там не наследуются, у них нет общей иерархии.
3169.04 3175.56 "Анатолий Кулаков" Это нужно для того, чтобы вы могли подставлять сюда абсолютно любые типы, они не обязаны наследоваться от чего-то там.
3175.56 3180.40 "Анатолий Кулаков" Просто абсолютно любые типы, которые у вас есть в приложении, вы должны мочь сюда подставить.
3180.40 3183.68 "Анатолий Кулаков" Зачем нам обычно хочется их вот таких три возвращать?
3183.68 3188.64 "Анатолий Кулаков" Самый частый случай это, когда вы пишете ISPnetController для того, чтобы вернуть разные код ошибок.
3188.64 3201.44 "Анатолий Кулаков" Например, если вам вернули юзера, вы хотите 200 отдать, если у вас не прошла ошибка валидации юзернейма, вы хотите bad request отдать или internal server error, если вдруг у вас почему-то отвалилась база данных.
3201.44 3205.64 "Анатолий Кулаков" То есть на каком-то верхнем уровне немножко как-то поиграться с этими значениями.
3205.64 3209.04 "Анатолий Кулаков" Может быть там retry запустить, может влог записать, может еще что-то сделать.
3209.04 3214.04 "Анатолий Кулаков" Ну то есть в зависимости от того, что вам вернули, обычно у вас делится дальнейшая логика.
3214.04 3223.40 "Анатолий Кулаков" Что мы дальше с этой информацией будем делать, как ее отдадим, как отформатируем результат, все это зависит от того, кто вернул метод регистрации пользователя.
3223.40 3235.64 "Анатолий Кулаков" И соответственно хочется, чтобы на уровне компилятора мы могли вот эту всю иерархию, что может вернуть метод, задать очень компактно и красиво.
3235.64 3238.16 "Анатолий Кулаков" Вот как раз этим и занимаются discrimination union.
3238.16 3241.76 "Анатолий Кулаков" Они вам описывают вот такой своеобразный результат, который можно вернуть.
3241.76 3244.72 "Анатолий Кулаков" Более того, у каждого этого результата будут разные свойства.
3244.72 3249.80 "Анатолий Кулаков" Например, если мы вернули успешно зарегистрированного пользователя, то естественно мы к этому пользователю хотим получить доступ.
3249.80 3253.44 "Анатолий Кулаков" У нас должно быть свойство быть юзеру, у которого будет записан этот юзер.
3253.44 3260.56 "Анатолий Кулаков" Если мы вернули, что какая-то проверка не прошла, то нам хочется узнать, в каком поле не прошла проверка, с каким сообщением об ошибке и так далее.
3260.56 3262.20 "Анатолий Кулаков" У каждого этого результата должны быть свои поля.
3262.20 3269.20 "Анатолий Кулаков" И еще одна интересная фишка, которую предоставляют discrimination union, это полнота всех типов.
3269.20 3270.20 "Анатолий Кулаков" Я ее уже упоминал.
3270.20 3271.20 "Анатолий Кулаков" Что это значит?
3271.20 3296.36 "Анатолий Кулаков" Это значит, что если мы завтра захотим добавить туда какой-то четвертый результат, то компилятор должен нам подсказать во всех местах, где мы анализируем эти три результата и в зависимости от типа одного из этих трех результатов идем по одному или другому пути, возвращаем какие-то ошибки, то компилятор должен нам найти все эти места и сказать, что там, где ты ветвление проверяешь, у тебя не учтен новый четвертый тип.
3296.36 3302.80 "Анатолий Кулаков" В общем, и это считается самым великим настижением discrimination union, самым главным и самым мощным.
3302.80 3310.20 "Анатолий Кулаков" И вот, к сожалению, в C# возможно сделать все, что касается discrimination union, кроме вот этого последнего шага.
3310.20 3325.04 "Анатолий Кулаков" То есть, пока у нас, к сожалению, компилятор не умеет понимать полноту вот этой иерархии, которая должна быть закончена во всех местах, где анализируется наш возвращаемый тип.
3325.04 3328.28 "Анатолий Кулаков" Интересный факт произошел в minimal API.
3328.28 3345.32 "Анатолий Кулаков" Microsoft завезла туда новый тип, который называется Results, это дженериковый тип, а также завезла кучу различных врапперов, которые вам помогают вот этот Results генерить в зависимости от того, что в вашем minimal API происходит.
3345.32 3366.36 "Анатолий Кулаков" Ну, например, вернемся к нашему методу, и допустим, у нас есть пользователь, который входит в систему, и вам нужно написать minimal API обработчик как бы этого пользователя, чтобы пользователь вошел, например, поприветствовать его или вернуть ему unauthorized ошибку, если вдруг он не авторизирован в вашей системе.
3366.36 3370.76 "Анатолий Кулаков" Как это будет выглядеть в minimal API?
3370.76 3383.08 "Анатолий Кулаков" Там вы можете объявить лямбду, и в качестве результата этой лямбды указать вот этот новый Results генерик тип, и в результате вы можете указать те возможные типы, которые ваш метод может вернуть.
3383.08 3385.92 "Анатолий Кулаков" Ну, в нашем случае, допустим, это юзер и некий unauthorized.
3385.92 3390.08 "Анатолий Кулаков" То есть, два вот этих типа мы можем указать в виде генерик аргументов.
3390.08 3399.68 "Анатолий Кулаков" А в самом методе в имплементацию включить, соответственно, в wrapper, который помогает нам эти типы билдить.
3399.68 3401.72 "Анатолий Кулаков" В нашем случае он называется typeResults.
3401.72 3406.92 "Анатолий Кулаков" TypeResults, и у него есть метод .oc, который принимает юзера.
3406.92 3414.16 "Анатолий Кулаков" И метод .op, который принимает юзера, возвращает как раз таки результат от одного из этих генерик аргументов, в нашем случае от юзера.
3414.16 3422.44 "Анатолий Кулаков" Если вдруг у нас бы юзер не прошел бы проверку на аутентификацию, ему вернулся бы вместо .oc юзера, вернулся бы unauthorized какой-то классик.
3422.44 3425.44 "Анатолий Кулаков" Unauthorized класс, который бы рассказал, почему у него не получилась авторизация.
3425.44 3434.00 "Анатолий Кулаков" И вот на самом деле вот этот Results генериковый от двух типов, это и является типичным примером discrimination union.
3434.00 3440.00 "Анатолий Кулаков" То есть, это и является тем файликом, который описывает вот эту иерархию возвращаемого результата.
3440.00 3442.60 "Анатолий Кулаков" И когда я говорю иерархию, я не имею в виду наследование.
3442.60 3446.60 "Анатолий Кулаков" Я в данном случае имею в виду законченную композицию, закрытую композицию типов.
3446.60 3452.04 "Анатолий Кулаков" Естественно, Results может быть не только от двух генерик аргументов.
3452.04 3454.68 "Анатолий Кулаков" У него есть переопределение, по-моему, то ли до 6, то ли до 7.
3454.68 3458.80 "Анатолий Кулаков" То есть, начиная от 1 и кончая там десятком.
3458.80 3460.00 "Анатолий Кулаков" Поэтому возвращайте сколько угодно.
3460.00 3468.12 "Анатолий Кулаков" У обычного discrimination union, естественно, вы можете задавать их в compile time сколько угодно.
3468.12 3475.96 "Анатолий Кулаков" Но здесь у нас C# строго типизированный, вот криво типизированный, поэтому Microsoft пришлось сгенерить 10 результатов.
3475.96 3480.64 "Анатолий Кулаков" Но с другой стороны, это типичный discrimination union.
3480.64 3487.08 "Анатолий Кулаков" Более того, как я уже говорил, в discrimination union есть фишки в том, что их понимают компиляторы, IDE, анализаторы и так далее.
3487.08 3488.92 "Анатолий Кулаков" И Results в этом случае не исключение.
3488.92 3494.04 "Анатолий Кулаков" То, что он возвращает, Entity Framework, соответственно, может проанализировать.
3494.04 3497.76 "Анатолий Кулаков" То есть, Entity Framework теперь знает, какие типы у вас может вернуть метод.
3497.76 3501.92 "Анатолий Кулаков" Обычно у нас это было что-то более примитивное.
3501.92 3508.64 "Анатолий Кулаков" То есть, вы могли бы вернуть какую-то определенную DTO из контроллера или вы могли вернуть action result какой-нибудь от типа.
3508.64 3512.28 "Анатолий Кулаков" То есть, мы знали, что если этот тип выстрелит, то значит это окей.
3512.28 3516.84 "Анатолий Кулаков" Или иначе в action result можно было точно так же сделать authorization, bad request и так далее.
3516.84 3519.64 "Анатолий Кулаков" Но уже про них Framework ничего не знал.
3519.64 3523.76 "Анатолий Кулаков" Он знал только про successный результат, то есть, про success path.
3523.76 3526.12 "Анатолий Кулаков" А вот про ошибки он ничего не знал.
3526.12 3527.44 "Анатолий Кулаков" Какие ошибки может вернуть ваш метод?
3527.44 3539.68 "Анатолий Кулаков" В данном случае ASP.NET из Minimal API может проанализировать этот результат и знает, какие ошибки и каких пользователей, какие объекты может вернуть ваш метод.
3539.68 3544.72 "Анатолий Кулаков" Более того, у Swagger был специальный атрибут, есть специальный атрибут.
3544.72 3548.36 "Анатолий Кулаков" С помощью вот этого костыля вы вынуждены были ваши контроллеры примечать.
3548.36 3556.32 "Анатолий Кулаков" Специально для Swagger, чтобы сказать ему, какие типы еще может вернуть наш метод или какие выбросит исключение.
3556.32 3559.24 "Анатолий Кулаков" С какими кодами эти исключения.
3559.24 3560.72 "Анатолий Кулаков" Тоже такой атрибутик был.
3560.72 3566.12 "Анатолий Кулаков" Он тоже был не от хорошей жизни, он как раз был от того, что у нас не было вот такого резалса.
3566.12 3567.24 "Анатолий Кулаков" Теперь этот резалс есть.
3567.24 3579.16 "Анатолий Кулаков" Соответственно, Swagger из него может всю эту метаинформацию доставать и вам в Swagger протокол наружу паблишить для ваших потребителей, для вашей документации.
3579.16 3586.32 "Анатолий Кулаков" То есть, вот эта связка, она на самом деле порождает очень много интересных вещей.
3586.32 3590.48 "Анатолий Кулаков" Интересных вещей, в частности, связанных с фреймворком, с анализаторами и с компиляторами.
3590.48 3601.72 "Анатолий Кулаков" Если же мы заглянем в source code вот этого резалта, discrimination union, то там мы увидим типичный generic class от различного количества параметров, как я уже сказал, от одного до десятка.
3601.72 3611.44 "Анатолий Кулаков" Но самая интересная фишка, которая у нас здесь есть, это то, каким же образом этот резалт внутрь себя инкапсулирует все стипы.
3611.44 3612.44 "Анатолий Кулаков" То есть, все возможные.
3612.44 3613.44 "Анатолий Кулаков" У него же нет какой-то одной иерархии.
3613.44 3616.72 "Анатолий Кулаков" Не будет же он какой-то object хранить.
3616.72 3631.80 "Анатолий Кулаков" В общем, на самом деле, для того, чтобы сконвертить любой произвольный тип, который вы будете возвращать из вашего minimal API, вот этот резалт, у резалта переопределено множество implicit операторов конвертации.
3631.80 3638.20 "Анатолий Кулаков" То есть, он на лету умеет неявно конвертировать те типы, которые вы ему указали в генериках.
3638.20 3642.24 "Анатолий Кулаков" Это довольно интересный, хороший подход, который делает код очень чистым.
3642.24 3648.60 "Анатолий Кулаков" Соответственно, как он это может сделать код очень чистым?
3648.60 3651.84 "Анатолий Кулаков" Допустим, у вас есть метод, который должен вернуть какие-то данные.
3651.84 3657.04 "Анатолий Кулаков" И вы говорите, что этот метод может вернуть резалт одного из трех типов.
3657.04 3659.16 "Анатолий Кулаков" Int, bool или string.
3659.16 3668.88 "Анатолий Кулаков" Естественно, вам неудобно будет создавать такой generic classic с тремя generic аргументами, как-то его инкапсулировать, выбирать какой-то один из типов.
3668.88 3670.92 "Анатолий Кулаков" В общем, все это довольно муторно.
3670.92 3674.40 "Анатолий Кулаков" Поэтому вы можете использовать класс резалт, позволяя вам сделать следующую вещь.
3674.40 3676.68 "Анатолий Кулаков" Вы просто пишите return и строчку.
3676.68 3677.96 "Анатолий Кулаков" Return hello world.
3677.96 3684.72 "Анатолий Кулаков" И эта строчка неявно прикастится как раз к этому резалту int bool string, трех generic типов.
3684.72 3692.04 "Анатолий Кулаков" Вот этот неявный каст помогает вам писать такой минималистичный, да хорошо читаемый и легко поддерживаемый код.
3692.04 3705.56 "Анатолий Кулаков" И самое интересное, что если вы попытаетесь вернуть какой-то тип, который не задан в этих трех, в нашем случае, generic аргументов, то это у вас компилятор сразу ругнется.
3705.56 3708.76 "Анатолий Кулаков" То есть это все будет проверяться на уровне компиляции, что тоже прекрасно.
3708.76 3711.92 "Анатолий Кулаков" Вам не нужно в runtime падать, например, как в action result.
3711.92 3717.76 "Анатолий Кулаков" То есть в action result вы можете вернуть любую чушь и в runtime, если эта чушь не пройдет, вы в runtime упадете только.
3717.76 3718.76 "Анатолий Кулаков" Здесь нет.
3718.76 3723.80 "Анатолий Кулаков" Здесь вы будете падать в compile time с понятным сообщением ошибки, с красивым компилятором и так далее.
3723.80 3724.88 "Анатолий Кулаков" Идем дальше.
3724.88 3732.88 "Анатолий Кулаков" Немаловажным частью discrimination union является то, что с ними очень прекрасно надо работать с помощью pattern matching.
3732.88 3745.28 "Анатолий Кулаков" И слава богам, в C# pattern matching движется огромными шагами уже очень давно и умеет понимать абсолютно страшные синтексисы, которых, наверное, уже в голове у всех разработчиков не удерживается.
3745.28 3748.60 "Анатолий Кулаков" Но в частности он умеет матчить по типам.
3748.60 3762.80 "Анатолий Кулаков" То есть если вы обратитесь к этому результату, вот этого резалта, который выдал нам наш метод, то этот результат можно свичнуть, то есть можно с помощью pattern matching сразу разложить по типам.
3762.80 3767.44 "Анатолий Кулаков" И вы можете по этому результату спросить, а какого типа у меня по правде там лежит результат?
3767.44 3768.44 "Анатолий Кулаков" In, bool, string.
3768.44 3771.64 "Анатолий Кулаков" И в зависимости от типа, как я уже сказал, сделать вот это ветвление.
3771.64 3779.60 "Анатолий Кулаков" То есть развести по разным сторонам какую-то логику, которая будет работать в зависимости от того, какой из этих трех типов генериковых к вам вернулся.
3779.60 3783.24 "Анатолий Кулаков" То есть pattern matching тоже у нас шикарно выглядит.
3783.24 3785.24 "Анатолий Кулаков" Какие же есть минусы у этого подхода?
3785.24 3788.24 "Анатолий Кулаков" Минус, как я уже говорил, в самом последнем шаге.
3788.24 3803.24 "Анатолий Кулаков" То есть если мы захотим вместо вот таких трех генерик типов, in, bool, string, добавить там четвертый decimal, то компилятор нам, конечно, скажет, иди там и переделай результат вместо трех генериков в четвертый генерик.
3803.24 3806.32 "Анатолий Кулаков" Но мы хотим не этого, мы хотим, чтобы наш pattern matching упал.
3806.32 3810.48 "Анатолий Кулаков" Мы хотим, чтобы pattern matching показал, что мы не обработали все возможные типы.
3810.48 3813.04 "Анатолий Кулаков" Мы хотим иметь закрытую композицию типов.
3813.04 3815.40 "Анатолий Кулаков" То есть композицию типов, которые всегда права.
3815.40 3817.56 "Анатолий Кулаков" Иначе мы получим runtime исключение.
3817.56 3819.88 "Анатолий Кулаков" Мы хотим это все свести к compile-time исключению.
3819.88 3824.32 "Анатолий Кулаков" Мы хотим, чтобы pattern matching проверял, что все четыре типа у нас взаимприменчаны.
3824.32 3826.16 "Анатолий Кулаков" Иначе выдавал бы ошибку компиляции.
3826.16 3832.36 "Анатолий Кулаков" К сожалению, сейчас этого происходить не будет и никак мы этого сделать стандартными красивыми способами не можем.
3832.36 3838.80 "Анатолий Кулаков" Но именно поэтому discrimination union в нас сильно всешарпан.
3838.80 3839.80 "Анатолий Кулаков" Типы не появлялись.
3839.80 3842.68 "Анатолий Кулаков" Но вот появился вот этот результат.
3842.68 3848.44 "Анатолий Кулаков" Спросите же вы, а как же Microsoft пренебрег вот этим главным принципом?
3848.44 3858.36 "Анатолий Кулаков" Внедрил, грубо говоря, тот же самый discrimination union и забил болт на самый важный принцип, на полноту типов?
3858.36 3859.84 "Анатолий Кулаков" На самом деле нет.
3859.84 3867.40 "Анатолий Кулаков" Microsoft специально сделал результат не общим типом, не вынес его куда-то в system result или куда-то туда, чтобы все его везде могли использовать.
3867.40 3877.60 "Анатолий Кулаков" Microsoft положил его в специальную сборку с SPNet, навесил его еще на namespace http и тем самым явно подчеркнул, что этот результат нужен только http only.
3877.60 3884.08 "Анатолий Кулаков" То есть это результат только работы minimal API, то есть работы любого endpoint.
3884.08 3885.44 "Анатолий Кулаков" Почему это важно?
3885.44 3889.80 "Анатолий Кулаков" Потому что он как раз вот этот четвертый параметр полноты типов обошел с другой стороны.
3889.80 3897.60 "Анатолий Кулаков" Он заимплементировал внутри вот этого результат метод, который называется execute_async, который принимает http контекст.
3897.60 3904.64 "Анатолий Кулаков" То есть теперь все, кто имплементирует результат, должны каким-то образом заимплементировать http, обработку http контекста.
3904.64 3914.40 "Анатолий Кулаков" В нашем случае каким-то образом отформатировать того же юзера, unauthorized, invalid type, то есть заимплементировать это и вернуть результат.
3914.40 3921.48 "Анатолий Кулаков" Таким образом мы всегда получаем полноту типов, потому что в данном случае полнота типов гарантируется имплементация этого интерфейса.
3921.48 3934.60 "Анатолий Кулаков" То есть это не честный discrimination union, но зато Microsoft смог с помощью вот этого хака затащить сюда хоть какое-то подобие, которое дало ему другие преимущества, которые у нас есть в discrimination union, кроме последнего.
3934.60 3945.16 "Анатолий Кулаков" Если вы захотите в своем коде сделать свои собственные типы, то человечество уже давным-давно старается в C# это сделать.
3945.16 3948.64 "Анатолий Кулаков" Как только у нас появился линк, мы пытались сделать discrimination union на линке.
3948.64 3961.24 "Анатолий Кулаков" Как только появились Roslyn анализаторы, мы попытались вот эту полноту, композицию типов проанализировать с помощью анализаторов и тем самым внести вот этот последний фактор, который очень важен.
3961.24 3967.60 "Анатолий Кулаков" Такие анализаторы тоже существуют, которые на стандартный свитч накладывают дополнительные ограничения на счет полноты.
3967.60 3978.36 "Анатолий Кулаков" Как только у нас появились source генераторы, мы начали генерить иерархию типов и генерить специальные методы, которые с помощью матча позволяют вам обязательно задать всю иерархию этой полноты.
3978.36 3980.80 "Анатолий Кулаков" В общем разработчики извращаются как могут.
3980.80 3990.84 "Анатолий Кулаков" Пока они не имеют у себя в руках нормального discrimination union, они используют абсолютно все новые технологии, которые только выходят для того, чтобы сделать себе более-менее удобный discrimination union.
3990.84 3998.52 "Анатолий Кулаков" Поэтому если вы вдохновились и в своем коде хотите discrimination union поиметь, то существует очень много сторонних библиотек.
3998.52 4001.60 "Анатолий Кулаков" У них у всех разные принципы, разные синтаксисы.
4001.60 4012.48 "Анатолий Кулаков" Но в целом идея именно такая, что он вам позволяет делать тип с перечисления возможных значений и обязательно еще где-то в соответствии с полнотой типов.
4012.48 4014.64 "Анатолий Кулаков" В проверке, где-то в матчинге.
4014.64 4019.00 "Анатолий Кулаков" Поэтому библиотечки есть, в частности автор статьи рекомендует одну из них.
4019.00 4025.92 "Анатолий Кулаков" Я какую-то одну рекомендовать не рискну, потому что абсолютно все они с косяками и только от вас зависит на какие косяки вы готовы пойти.
4025.92 4035.40 "Анатолий Кулаков" В общем поэтому данную статью, данный подход от Микрософта с результатами очень интересно посмотреть в нескольких аспектах.
4035.40 4039.80 "Анатолий Кулаков" Во-первых это в том, как хорошо и красиво используется implicit convert.
4039.80 4046.72 "Анатолий Кулаков" Вообще очень редко нам в работе приходится переопределять неявный cast, то есть вот эту неявную конвертацию.
4046.72 4048.68 "Анатолий Кулаков" Но вот здесь она влилась просто отлично.
4048.68 4049.92 "Анатолий Кулаков" Посмотрите как пример.
4049.92 4059.56 "Анатолий Кулаков" Ну и также если вы раньше не сталкивались с discrimination union, посмотрите как пример вот этот result type, как им пользуются, как он конвертит, как его возвращают, как его анализируют.
4059.56 4065.88 "Анатолий Кулаков" Чтобы вы понимали, почему кто-то у Микрософта в следующий раз будет просить discrimination union, зачем это надо.
4065.88 4073.88 "Анатолий Кулаков" В общем посмотрите на микрософтовскую реализацию и примерно представьте, а что было бы если бы это была фича языка и она обладала бы еще и полнотой типов.
4073.88 4079.00 "Игорь Лабутин" Ну вот мне кажется как раз полнота типов это самое главное чего не хватает.
4079.00 4087.16 "Игорь Лабутин" То есть все эти библиотеки, они будут вам выдавать полноту типов либо там через какие-нибудь source генераторы, либо через там передачу правильного набора лямбд куда-нибудь.
4087.16 4089.68 "Игорь Лабутин" И это все конечно не то, нужно фича языка.
4089.68 4091.80 "Игорь Лабутин" Но я надеюсь сделаю когда-нибудь.
4091.80 4093.44 "Анатолий Кулаков" Да что-то не похоже.
4093.44 4099.72 "Анатолий Кулаков" Мы в прошлый раз ждали, в этот раз не дождались и что-то на следующий тоже никаких анонсов нету, поэтому я уже что-то боюсь.
4099.72 4100.72 "Игорь Лабутин" Будем посмотреть.
4100.72 4102.72 "Игорь Лабутин" Давай пока пойдем дальше.
4102.72 4108.08 "Игорь Лабутин" У нас вышла еще Visual Studio 17.8 Preview 3, там очень мало всего.
4108.08 4123.72 "Игорь Лабутин" Раздел productivity содержит целую одну новость, а именно что теперь если у вас есть обновление для студии, которое вы еще не скачали, то у вас в тазгабаре будет показана иконочка поверх собственно иконочки Visual Studio, что вас ждет апдейт.
4123.72 4125.24 "Игорь Лабутин" Это в разделе productivity.
4125.24 4126.24 "Игорь Лабутин" Не знаю почему.
4126.24 4128.64 "Анатолий Кулаков" Это теперь очень продуктивно, теперь это будет отвлекать
4128.64 4131.64 "Игорь Лабутин" меня от работы. Да, в общем вот.
4131.64 4136.92 "Игорь Лабутин" Но правда справедливости ради, эта иконочка будет включена только если у вас включена опция update and close.
4136.92 4140.00 "Игорь Лабутин" Если не включена, видимо не будет вам сообщать, что надо обновиться.
4140.00 4144.48 "Игорь Лабутин" Или может как раз предупреждать будет, что типа не закрывай студию, я пойду обновлять.
4144.48 4147.60 "Анатолий Кулаков" По сути да, она предупреждает, что закрывайся, сейчас я пойду обновляться.
4147.60 4150.84 "Анатолий Кулаков" Там еще reboot, restart, fix bug, и можно даже не загрузить
4150.84 4152.84 "Игорь Лабутин" все. Короче, заваривай кофе и иди на обед.
4152.84 4153.84 "Игорь Лабутин" А лучше на ночи спать.
4153.84 4160.80 "Игорь Лабутин" Сиквельс плюсных каких-то улучшений, вот их кстати немало, просто понятно, что мы их особо подробно не рассматриваем.
4160.80 4168.92 "Игорь Лабутин" Ну и внутренний data client, SQL, обновили до пятерки в SQL Server Data Tools.
4168.92 4172.72 "Игорь Лабутин" Там какие-то правильные, поддержанные новые бинарные форматы, протоколы и так далее.
4172.72 4175.08 "Игорь Лабутин" Короче, с последним SQL Server будет работать лучше.
4175.08 4180.08 "Игорь Лабутин" В общем-то и все, в 17.8 больше никаких таких серьезных улучшений нет.
4180.08 4197.92 "Игорь Лабутин" Зато, давай возвращаясь немножко к языкам, на конференции, по-моему это был Дотланд Девелопер Дэйс в Варшаве недавно, недельки 2-3 назад, выступил Мэтт Сторгерсон с, ну как, конечно про C#, с рассказом про то, что нас ждет в 12 и дальше.
4197.92 4200.12 "Анатолий Кулаков" Где-то 2/3… Когда мы увидим дискриминацию
4200.12 4212.20 "Игорь Лабутин" в юнион и все такое. Нет, про дискриминацию там как раз не было ничего, где-то 2/3 доклада это было про всякие фичи C# от 12 и вообще в целом про процесс развития языка.
4212.20 4220.08 "Игорь Лабутин" Мы про это много раз рассказывали, про всякие там комьюнити, вот эти вот API Review и прочее, прочее, прочее, систему с репозиториями, C#, все такое прочее.
4220.08 4223.08 "Игорь Лабутин" А вот последняя треть доклада, она довольно интересна.
4223.08 4233.16 "Игорь Лабутин" Он рассказывал про, во-первых, про то, с какими проблемами они сталкиваются с точки зрения ломания обратной совместимости.
4233.16 4235.48 "Игорь Лабутин" На примере про 100 фичи.
4235.48 4247.68 "Игорь Лабутин" Есть такая фича, она планировалась к 8.12 C#, но ее не стали делать, потому что столкнулись с проблемой поддержки обратной совместимости.
4247.68 4248.68 "Игорь Лабутин" В чем вопрос?
4248.68 4250.16 "Игорь Лабутин" Фича называется Field Keyword.
4250.16 4261.84 "Игорь Лабутин" Вы знаете, что в пропертиях у нас можно в Setter Property использовать, например, специальное ключевое слово value, и это ключевое слово обозначает то значение, которое вы присваиваете в эту property.
4261.84 4269.80 "Игорь Лабутин" И внутри Setter, естественно, вы с ним можете работать таким образом, там, в Fields, проверить сначала, провалидировать, сохранить Field или еще что-нибудь сделать.
4269.80 4280.80 "Игорь Лабутин" Но если вам это нужно делать, то есть если вам нужен какой-то нетривиальный getter или нетривиальный setter, вы обязаны завести нормальное обычное private poly, да, и так далее.
4280.80 4296.20 "Игорь Лабутин" Было предложение, фича, собственно, состоит в том, что давайте мы, poly все равно будет как в автопропертиферции заводиться автоматом, но мы помимо ключевого слова value будем еще иметь ключевое слово field, которое, собственно, будет ссылаться с ссылкой, по сути, на то самое private poly.
4296.20 4309.28 "Игорь Лабутин" Все бы хорошо, но фактически введя такое ключевое слово, а field это все-таки довольно, ну, я не знаю, наверное, может быть не очень популярное, но наверняка есть кодовые базы, где field это название, собственно, филда.
4309.28 4310.80 "Игорь Лабутин" Ну вполне могло бы быть, да.
4310.80 4311.80 "Игорь Лабутин" В вашем классе.
4311.80 4317.68 "Игорь Лабутин" То есть в принципе это, наверное, очень странно field называть field, но какой-нибудь в wrapper объект, почему бы нет?
4317.68 4318.68 "Игорь Лабутин" Ну вдруг.
4318.68 4324.92 "Игорь Лабутин" Как раз-таки в wrapper с какими-нибудь, там, не знаю, дополнительными навешанными свойствами, которые обращаются к этому private field.
4324.92 4331.20 "Игорь Лабутин" И как только вы добавляете это ключевое слово, у вас ничего не ломается в компиляции, но семантика меняется сразу же.
4331.20 4340.20 "Игорь Лабутин" И возникает эта проблема, именно из-за этого они не стали делать эту фичу в 12 C# и стали думать, что делать.
4340.20 4343.44 "Анатолий Кулаков" Ну то есть опять обратная совместимость лишила нас прекрасных фич.
4343.44 4344.44 "Анатолий Кулаков" Да.
4344.44 4346.32 "Игорь Лабутин" Надо ломать все к чертовой матери.
4346.32 4352.84 "Игорь Лабутин" Вот к чертовой матери они не хотят, но Мэттс произнес следующую фразу, сейчас я попробую ее на лету перевести на русский.
4352.84 4368.28 "Игорь Лабутин" Мы хотим причинять неудобства сейчас вместо того, чтобы причинять их бесконечно, и при этом мы хотим эти самые неудобства причинять как можно меньшему числу народа, чем большому числу народа.
4368.28 4370.88 "Игорь Лабутин" Что это означает?
4370.88 4380.88 "Игорь Лабутин" Значит, начиная, собственно, вот они планируют это, я так понимаю, вроде как в восьмерке это сделать, и соответственно в девятке это позволит эту фичу выкатить, что будет происходить?
4380.88 4399.64 "Игорь Лабутин" Если, в большинстве случаев, как они понимают по своей статистике, если вы берете новое SDK, ну например, вот вы возьмете и проапгрейдитесь на восьмерку, обычно вы апгрейдите новое SDK, но вы одновременно с апгрейдом SDK прямо сразу, вот в тот же момент не переключаетесь на последнюю версию языка и вот это все.
4399.64 4410.64 "Игорь Лабутин" То есть обычно вы сначала берете SDK, проверяете, что все соберется, ну вот это все, если у нас собралось, там прошло какие-то тесты, ну дальше вы говорите, окей, ладно, теперь давайте, значит, это завязаем, все, дальше.
4410.64 4412.84 "Игорь Лабутин" Так вот теперь поведение компилятора будет такое.
4412.84 4424.20 "Игорь Лабутин" Если вы взяли, вот конкретно с филдом, например, если вы возьмете в dotnet 8 SDK, я вот не очень понял, вписано ли это в восьмерку или это будет только в девятке уже, но тем не менее.
4424.20 4439.36 "Игорь Лабутин" Допустим, это есть в восьмерке, если вы возьмете восьмое SDK и компилятор, и скомпилируете код, у которого target SDK семерка, и при этом там есть филды, которые называются field, то это будет warning компиляции.
4439.36 4457.28 "Игорь Лабутин" Ну то есть типа компилятор, если он понимает, что он компилирует ленгвержен предыдущий, то компилятор будет знать, какие паттерны в текущем коде могут быть потенциально breaking, если вы обновите версию поддерживаемого языка и компилятор начнет field рассматривать как ключевое слово.
4457.28 4460.56 "Игорь Лабутин" И, соответственно, он про эти штуки все будут предупреждать.
4460.56 4468.24 "Анатолий Кулаков" А если я, соответственно, ленг повышу, то он будет считать это нормальным моим самостоятельным действием и никакого warning не будет.
4468.24 4469.24 "Анатолий Кулаков" Да, именно так.
4469.24 4476.36 "Анатолий Кулаков" Слушай, меня не подмянут, потому что настоящие пацаны в моем лице всегда держат ленг латест.
4476.36 4483.28 "Игорь Лабутин" Ну вот тебе не повезло, но ты, наверное, хорошо знаешь свою кодовую базу и правильно называешь свои эти самые.
4483.28 4487.48 "Анатолий Кулаков" Да, я стараюсь на такие вещи не попадать, но все же.
4487.48 4488.48 "Игорь Лабутин" Понятно.
4488.48 4503.32 "Игорь Лабутин" И, соответственно, кажется, что это разумный компромисс между никогда ничего не ломать и всячески быть очень аккуратным и бездумно вводить новые ключевые слова или менять поведение существующих и так далее.
4503.32 4507.60 "Игорь Лабутин" То есть это некоторый разумный компромисс, который можно пытаться нести в массы словами.
4507.60 4520.08 "Игорь Лабутин" Ребята, если вы обновляете, обновите сначала так, поставьте ленгвершен ваш текущий, посмотрите, какие warning вам выдадут, ну вдруг, да, а потом только обновляйте ленгвершен.
4520.08 4530.80 "Анатолий Кулаков" Слушай, у них же есть куча всяких анализаторов мигратора на новые версии и все такое, почему это явно не всунуть в какую-нибудь тулзу, не сделать тулзу, которая приготовляет ваш проект к миграции на новый фреймворк.
4530.80 4537.76 "Анатолий Кулаков" И вот она пусть анализирует все, что хочет явно, потому что вот эта штука, она действительно слишком неявная, очень много людей на нее не попадутся, вот как я.
4537.76 4543.88 "Игорь Лабутин" Ну, слушай, а с другой стороны, насколько много людей будут прям сознательно запускать какую-то отдельную тулзу?
4543.88 4552.04 "Анатолий Кулаков" Я думаю, что… Ну, вот так пару breaking changes они введут, которые зарушат их приложение, и будут запускать на каждом билде, я тебе уверяю.
4552.04 4556.32 "Игорь Лабутин" Ну и ты с ленгвершен лейтест уйдешь, если тебя сломают.
4556.32 4561.68 "Игорь Лабутин" Ну короче, это по крайней мере некоторый шаг вперед.
4561.68 4577.24 "Игорь Лабутин" А вот да, я вижу по заметкам, что это все будет в компиляторе к 9 дотунету, в 8 этого не будет, к 9 дотунету они это сделают, потому что, ну, по сути, это получается, что нужно иметь разное поведение компилятора, типа считать это ключевым словом или не ключевым словом, в зависимости от версии языка.
4577.24 4583.24 "Игорь Лабутин" Ну это, вероятно, какие-то изменения, новые анализаторы, новые штуки и так далее.
4583.24 4585.88 "Анатолий Кулаков" То есть филд мы получим через две версии.
4585.88 4586.88 "Анатолий Кулаков" Видимо.
4586.88 4588.92 "Анатолий Кулаков" В 9 они этот флажок сделают, компилятор научат, а в
4588.92 4591.72 "Игорь Лабутин" 10 они, наконец-то, филд введут. Нет, ну и, соответственно, в 9 сразу можно добавлять.
4591.72 4599.88 "Игорь Лабутин" Компилятор в 9 сможет предупредить, что, сорян, чувак, у тебя как бы, компилируя 8, ну, дотунет 8, он скажет, у тебя тут филд неправильный.
4599.88 4603.52 "Анатолий Кулаков" А почему они в 8 компилятор не успели это сделать?
4603.52 4604.52 "Игорь Лабутин" Ну, видимо, не успели.
4604.52 4605.52 "Игорь Лабутин" Видимо, поздно пришло.
4605.52 4606.52 "Анатолий Кулаков" Просто не успели.
4606.52 4607.52 "Анатолий Кулаков" О, такая светлая идея.
4607.52 4608.52 "Анатолий Кулаков" Да, может, еще и передумают что-то.
4608.52 4610.20 "Анатолий Кулаков" Она, как я говорю, не очень светлая.
4610.20 4619.52 "Игорь Лабутин" Ну, нет, мне кажется, нормальная идея, то есть понятно, что отдельный тул там и так далее, может быть, это потом тоже сделают, оформят в виде какого-нибудь флажка специально.
4619.52 4620.52 "Анатолий Кулаков" Не знаю.
4620.52 4623.56 "Анатолий Кулаков" Да нормальная, но как-то все равно уже, ну, похоже на костыль, в общем.
4623.56 4629.72 "Анатолий Кулаков" Но хотелось бы более концептуально, потому что наверняка же им в будущем понадобятся и ключевое слово property, и ключевое слово еще какое-нибудь.
4629.72 4632.12 "Анатолий Кулаков" Ну, то есть ключевых слов мало не бывает.
4632.12 4635.16 "Игорь Лабутин" Ну, да, конечно, давайте зарезервируем сразу.
4635.16 4638.52 "Игорь Лабутин" Нельзя делать идентификаторы, короче, 15 символов.
4638.52 4639.52 "Анатолий Кулаков" Было бы неплохо.
4639.52 4640.52 "Анатолий Кулаков" Да, да.
4640.52 4641.52 "Анатолий Кулаков" И будет нормально.
4641.52 4648.60 "Анатолий Кулаков" При том, что они же в этот… Лучше бы они зарезервировали себе какой-нибудь символ, начиная сейчас с доллара, только для Микрософта, или начиная сейчас с собачки.
4648.60 4649.60 "Анатолий Кулаков" Ну, вот как компилятор.
4649.60 4650.60 "Анатолий Кулаков" С буквы А.
4650.60 4655.56 "Анатолий Кулаков" Потому что в компиляторе на самом деле можно задавать именно полей, такие, какие нельзя задавать в C#.
4655.56 4657.12 "Анатолий Кулаков" И это прекрасный выход.
4657.12 4661.44 "Анатолий Кулаков" Он на себе генерирует кучу разных свойств и беды не знает.
4661.44 4667.68 "Анатолий Кулаков" Вот нормальное решение, как бесконечно можно плодить ключевые слова и при этом не ломать обратную совместимость.
4667.68 4670.24 "Игорь Лабутин" Ну, может быть, может быть.
4670.24 4671.24 "Игорь Лабутин" Не знаю.
4671.24 4673.00 "Игорь Лабутин" Короче, много думали, придумали такое.
4673.00 4674.00 "Игорь Лабутин" Посмотрим.
4674.00 4684.04 "Игорь Лабутин" А вторая фича, которую он очень кратенько, минут за пять затронул в этом докладе, но кажется, что над ней-таки идет работа, это штука под названием extension everything.
4685.04 4687.40 "Игорь Лабутин" То есть в C# у нас есть extension методы.
4687.40 4696.12 "Игорь Лабутин" Они, как сказал Мэтс, они вышли в превью через два месяца, как я пришел работать в Microsoft, то есть 18 лет назад.
4696.12 4698.24 "Игорь Лабутин" И с тех пор у нас нет никаких других extension.
4698.24 4704.48 "Игорь Лабутин" Мы не можем экстендить property, мы не можем экстендить эти самые static методы, например, и так далее.
4704.48 4714.40 "Игорь Лабутин" Ну, все потому что, ну, в каком-то смысле одна из причин, потому что для выражения того факта, что это является extension, мы используем ключевое слово c, да, оттуда передаем instance объекта.
4714.40 4718.84 "Игорь Лабутин" Как это делать с property, ну, либо нужно как-то методы было, странно будет называть, либо еще как-то.
4718.84 4725.92 "Игорь Лабутин" Короче, это не очень позволяет легко сделать property и все остальное, но мы хотим, очень хотим.
4725.92 4742.88 "Игорь Лабутин" И кажется, что эта фича имеет какой-то хороший прогресс, по крайней мере, по-моему, по сравнению со старыми докладами и выступлениями Мэтса, он, по крайней мере, уже показывает какой-то плюс-минус код, он еще не компилируется и не работает, но это, по крайней мере, выглядит уже более-менее целостно.
4742.88 4746.92 "Анатолий Кулаков" То есть у нас… А есть понимание, как раз property будут выглядеть?
4746.92 4747.92 "Игорь Лабутин" Да-да-да.
4747.92 4748.92 "Игорь Лабутин" Могли бы выглядеть?
4748.92 4749.92 "Игорь Лабутин" Да-да-да, смотри.
4749.92 4752.40 "Игорь Лабутин" Значит, у нас будет возможность сделать следующее.
4752.40 4757.88 "Игорь Лабутин" Можно будет написать там класс, не знаю, давай сейчас что-нибудь придумаем.
4757.88 4764.24 "Игорь Лабутин" У нас есть класс user, ну, какой-нибудь, да, который тебе прилетел из льбы какой-нибудь, ну, из NuGet.
4764.24 4765.32 "Игорь Лабутин" Ты с ним ничего делать не можешь.
4765.32 4768.84 "Игорь Лабутин" Значит, что ты можешь делать?
4768.84 4772.80 "Игорь Лабутин" Во-первых, ты хочешь для этого юзера, например, просто объявлять extension методы.
4772.80 4774.16 "Игорь Лабутин" Вот как ты сейчас объявляешь, да?
4774.16 4775.44 "Игорь Лабутин" Что для этого нужно сейчас делать?
4775.44 4790.68 "Игорь Лабутин" Объявить класс, в нем написать статический метод, в нем написать, соответственно, первым аргументом this user, ну и название аргумента, ну и дальше любые твои нужные аргументы, это будет метод, который тебе будет интеллисенсом показываться, если ты нажмешь точечку на этом классе, на объекте этого класса.
4790.68 4792.00 "Игорь Лабутин" Что будет теперь?
4792.00 4793.92 "Игорь Лабутин" Теперь можно будет сделать следующее.
4793.92 4809.24 "Игорь Лабутин" Теперь ты сможешь сказать класс, не знаю, user, не знаю, давай не user, класс authenticated user, extents или extension of, или extension forward, я сейчас не помню точно, синтаксис, user.
4809.24 4810.24 "Игорь Лабутин" И дальше открываешь фигурноскобочку.
4810.24 4811.24 "Анатолий Кулаков" То есть как будто наследование, да?
4811.24 4812.24 "Анатолий Кулаков" Как будто наследование, но как extension.
4812.24 4816.24 "Игорь Лабутин" Открываешь фигурноскобочку и пишешь, что хочешь.
4816.24 4822.00 "Игорь Лабутин" Статический класс, статические методы, пропертии, instance методы, что хочешь.
4822.00 4829.60 "Игорь Лабутин" И дальше есть еще разница между implicit extension методами и explicit extension методами.
4829.60 4862.00 "Игорь Лабутин" То есть там штука в следующем, что explicit extension позволяет, как я понял, это что-то как раз типа наследования, но ты, ну по сути, как будто ты отнаследовался от базового класса и добавил какие-то специфические методы в наследников, а implicit это как раз то самое, что вы получите, например, вот этот propertue прямо на стринге или на плодьюзере, том же самом.
4862.00 4868.32 "Игорь Лабутин" То есть вот эта разница между implicit и explicit, она надо видео посмотреть тщательно, там есть, я вот сейчас ее немножко не помню.
4868.32 4871.72 "Анатолий Кулаков" Ну и ты можешь просто пронаследоваться, если ты так хочешь.
4871.72 4906.24 "Игорь Лабутин" Ну а он может быть sealed, он может быть там, там всячески короче есть тонкости, я так понимаю, что они везде доступны на наследование, плюс не забывай, у тебя там это все-таки extension и наследование, ну короче, вот ладно, давай не буду врать, не помню зачем там выбрали explicit extension, implicit точно понятно зачем, это вот те самые extension методы, плюс также можно будут property и эти статические методы туда добавлять, а вот для explicit посмотрите последние 10 минут видео, которые будут в шоу-ноутах, там все более-менее понятно.
4906.24 4913.44 "Анатолий Кулаков" Ну я думаю легче дождаться уже каких-нибудь панонцев, чтобы примерно понимать, куда она идет, может они еще после этого видео что-то поменяют.
4913.44 4917.72 "Игорь Лабутин" Ну конечно, могут сразу все поменять, но интересно же следить, как это все изменяется.
4917.72 4956.60 "Игорь Лабутин" Ну в общем примерно так, и Мэтт сказал, что уже сейчас соответственно ведется работа, довольно активная работа над четырьмя, по сути, фичами для следующего C#, но, сейчас я даже попробую быстро найти, вот это semi-auto properties, это парамзы в span-ах и stack-a-lock-ах, это default в deconstruction и те самые rows extensions, они прямо в in-progress, так что ждем их, прямо ждем.
4956.60 4964.44 "Анатолий Кулаков" Ну все-таки что-то опять на следующий релиз ничего такого концептуального большого интересного нет.
4964.44 4966.76 "Анатолий Кулаков" Ну extensions ладно, это довольно практически полезная штука.
4966.76 4972.20 "Игорь Лабутин" Экстеншнс это будет очень концептуально, погоди, если такое сделать, то это будет прям очень концептуально.
4972.20 4981.84 "Анатолий Кулаков" Но опять же, не сказать, что это очень сильно мешает нашему коду, это тебе позволит сделать код немножко читетабельнее, немножко приятнее, то есть это все будет работать на уровне синтаксического сахара.
4981.84 4995.80 "Анатолий Кулаков" Конечно оно будет использоваться очень часто и очень многими, каждый день и все такое, но большого профита от этого не будет, никто тебе не мешает тот же самый статический класс там создать или класс утилс или прочую вот эту чушь, которую мы делаем.
4995.80 4997.92 "Анатолий Кулаков" То есть это немножко причешет наш код.
4997.92 5051.76 "Игорь Лабутин" Ну это синтаксический сахар, ну подожди, ну а C# язык с историей 20+ лет, да, и что ты туда можешь прям суперконцептуально нового, если не выходить за рамки, ну плюс-минус такой типа, я не хочу говорить не функциональный парадигмы, потому что фасерапия дофига функционального, но он все-таки такой скорее плюс-минус императивный, объектно-ориентированный, чуть-чуть функциональный, ну что ты туда начнешь, ну вот я так понимаю, что Мэтт же говорил, что одна из причин, почему они не так активно, может быть, прям пытаются затащить дискриминацию универс, потому что это в чистом виде фича из функционального мира, в общем то, где на этом много чего построено, они прям, ну это одна из причин, они не хотят C#, это не функциональный язык, вот поэтому что ты туда концептуального прям добавишь, концептуального.
5051.76 5058.44 "Анатолий Кулаков" Вот смотри, они затащили линк, они затащили паттерн-матчинг, они затащили рекорды, да это все функциональщина, вот чистой воды.
5058.44 5061.40 "Анатолий Кулаков" Даже в функциональных языках меньше функциональщины сейчас, чем в C#.
5061.40 5062.96 "Анатолий Кулаков" И чего нам не хватает?
5062.96 5066.96 "Анатолий Кулаков" Нам всего лишь, нам вообще не хватает полноты типов, полноты иерархии.
5066.96 5072.16 "Анатолий Кулаков" Вот полнота типов, она не тянет на чисто функциональную проблему, правда же?
5072.16 5087.20 "Анатолий Кулаков" Ну это… У нас в C# есть иерархия, у нас в C# есть там те же самые свитчи, у нас в C# есть паттерн-матчинги, у нас даже есть специальный эксепшн, который называется out of range exception, который нам намекает, что как бы еще давно было задумано, что мы понимаем, что как бы весь свитч наш неполный.
5087.20 5092.56 "Анатолий Кулаков" То есть это все есть, и как бы я не вижу здесь функциональщины вообще ни в одном виде.
5092.56 5095.56 "Анатолий Кулаков" Ну что это, какая-то мега-концептуальная функциональность?
5095.56 5099.76 "Анатолий Кулаков" Как только они в лямбды нам ввели, как только они паттерн-матчинги сделали, все как бы.
5099.76 5103.64 "Игорь Лабутин" Да ладно, ладно, ладно, сказал слово лямбда, уже функциональщик, я понял.
5103.64 5113.56 "Анатолий Кулаков" Да ну грубо говоря, да, в нормальных джавах как бы лямбд не было очень даже долго, и вот там действительно не было никакой функциональщины, а здесь… Ну да.
5113.56 5118.16 "Анатолий Кулаков" Поэтому я не вижу причин, почему бы это не вводить, и отмазки какие-то довольно левые.
5118.16 5122.08 "Игорь Лабутин" Ну не знаю, не знаю, почему-то так.
5122.08 5125.96 "Игорь Лабутин" Ладно, с этим, наверное, все, что у нас.
5125.96 5128.20 "Игорь Лабутин" Я вижу, у нас еще осталась одна большая статья.
5128.20 5129.20 "Игорь Лабутин" Успеем?
5129.20 5131.80 "Анатолий Кулаков" Ну не то чтобы большая, но такая разносторонняя.
5131.80 5135.20 "Анатолий Кулаков" Мы хотим поговорить про async/await.
5135.20 5137.72 "Анатолий Кулаков" Еще одна мега-новая фича, правда?
5137.72 5140.24 "Анатолий Кулаков" Давно не говорили, да.
5140.24 5143.00 "Анатолий Кулаков" Давно не говорили про async/await, почему бы и нет.
5143.00 5151.52 "Анатолий Кулаков" Интересная статья, которой автор собрал всякие best practices и самое главное анализаторы, которые позволяют вам эти best practices поддерживать, про async/await.
5151.52 5157.48 "Анатолий Кулаков" Очень много существует разных мифов, предубеждений и всего такого с async/await.
5157.48 5160.76 "Анатолий Кулаков" Много автор покрыл, много еще не покрыл.
5160.76 5168.56 "Анатолий Кулаков" В общем, наверное, все покрыть невозможно в рамках одного выпуска или одного какого-нибудь доклада.
5168.56 5173.96 "Анатолий Кулаков" То есть, может быть, наверное, все объемлющие книги от Стефана Клери и спасут вас.
5173.96 5180.16 "Анатолий Кулаков" Но хотелось бы просто краткую какую-то выжимку дать best practices, которые существуют в C# мире.
5180.16 5186.96 "Анатолий Кулаков" Может быть, или кто-то не сталкивался, или кто-то, наоборот, сталкивался и делает неправильно, и почему-то продолжает так делать.
5186.96 5197.60 "Анатолий Кулаков" Поэтому давайте кратенько пробежимся и рассмотрим, что же такого плохопахнущего может быть в вашем асинхронном коде.
5197.60 5204.44 "Анатолий Кулаков" И в данном случае, в том числе, автор собрал анализаторы, которые позволяют это все анализировать и фиксить.
5204.44 5214.44 "Анатолий Кулаков" В общем, если вам вдруг захотите автоматически исправлять все эти ошибки, можно обратиться к таблице автора, где он расскажет, какие анализаторы вам нужны.
5214.44 5220.92 "Анатолий Кулаков" А мы же пойдем и посмотрим, что нам эти анализаторы и эти best practices предлагают.
5220.92 5231.20 "Анатолий Кулаков" Порядок здесь довольно-таки странный, но будем его придерживаться, потому что там в зависимости от одних анализаторов получается, нужно говорить и как раз про другие.
5231.20 5236.72 "Анатолий Кулаков" Начнем с… Во-первых, почему-то на первом месте, но допустим.
5236.72 5237.72 "Анатолий Кулаков" Избыточный async/await.
5237.72 5247.08 "Анатолий Кулаков" То есть очень часто у нас бывают методы, в которых async/await можно не писать, несмотря на то, что методы вызываются асинхронные.
5247.08 5249.08 "Анатолий Кулаков" Почему этого можно не делать?
5249.08 5255.52 "Анатолий Кулаков" Во-первых, потому что каждый из вас должен знать, что результатом того, что вы написали async/await, будет state машина.
5255.52 5260.36 "Анатолий Кулаков" И не просто state машина, а это state машина требует под себя выделение памяти.
5260.36 5268.72 "Анатолий Кулаков" То есть как только вы пишете async/await, сразу знаете, что компилятор для вас генерирует кое-что с state машиной, которое в рантайме будет выделять память.
5268.72 5274.88 "Анатолий Кулаков" То есть априори это не то чтобы плохо, но если вы этого избежите, будет намного лучше.
5274.88 5277.20 "Анатолий Кулаков" Поэтому желательно не писать async/await.
5277.20 5280.16 "Анатолий Кулаков" И дело в том, что мы можем так делать.
5280.16 5299.44 "Анатолий Кулаков" Если в вашем методе вызов асинхронного метода только один, или вызов этого асинхронного метода является самым последним стейтментом, допустим вы пишете куда-нибудь в баску асинхронно и метод saveAsync, вы можете его завейтить saveAsync и сделать ретурн из метода.
5299.44 5303.44 "Анатолий Кулаков" А можете сразу ретурнить таску, которая возвращает saveAsync.
5303.44 5307.00 "Анатолий Кулаков" Таким образом не писать ни await, ни async у этого метода.
5307.00 5310.68 "Анатолий Кулаков" И этого достаточно для того, чтобы компилятор вам не генерил state машину.
5310.68 5313.20 "Анатолий Кулаков" В общем и рекомендация соответственно такая.
5313.20 5317.04 "Анатолий Кулаков" Если вы можете так делать, не пишите async/await.
5317.04 5319.76 "Анатолий Кулаков" То есть избегайте его, если он вам не нужен.
5319.76 5325.60 "Анатолий Кулаков" К сожалению, это очень хорошее правило, но к сожалению у него есть несколько концептуальных исключений.
5325.60 5330.18 "Анатолий Кулаков" Во-первых, это юсинги, о которых мы поговорим чуть ниже.
5330.18 5334.12 "Анатолий Кулаков" Дальше есть тонкости работы с эксепшенами, асинклоками и так далее.
5334.12 5338.80 "Анатолий Кулаков" Подробно все эти тонкости рассмотрены в статье Стефана Клэри.
5338.80 5348.08 "Анатолий Кулаков" Ну и вообще, если вы там сталкиваетесь с асинхронностью, с тасками, с параллельностью, вам обязательно нужен блог Стефана Клэри, еще лучше книга.
5348.08 5353.44 "Анатолий Кулаков" Но в блоге у него очень много расписано про всякие таски.
5353.44 5357.40 "Анатолий Кулаков" Очень понятно, очень доступно, пишет он про них давно, качественно до сих пор.
5357.40 5363.08 "Анатолий Кулаков" В общем обязательно обратите внимание на блог Стефана Клэри, если вы раньше о нем не слышали.
5363.08 5374.48 "Анатолий Кулаков" Итак, следующий код смел, который у нас есть, это когда у вас есть две пары методов, синхронный и асинхронный, то нужно предпочитать вызывать асинхронный метод.
5374.48 5378.72 "Анатолий Кулаков" То есть это часто можно видеть на наших старых API, когда там есть, например, файл.
5378.72 5383.28 "Анатолий Кулаков" Вы из файла можете считать контент синхронно, а можете считать асинхронно.
5383.28 5386.84 "Анатолий Кулаков" То есть синхронный метод был еще введен, когда асинков не было.
5386.84 5393.88 "Анатолий Кулаков" Поэтому он все еще остался для обратной совместимости, но все же если есть асинхронный товарищ, асинхронный брат, то нужно обязательно пользоваться именно им.
5393.88 5400.92 "Анатолий Кулаков" Следующий код смел - это избегайте вайдовых асинхронных методов.
5400.92 5402.84 "Анатолий Кулаков" Для этого есть две причины.
5402.84 5414.84 "Анатолий Кулаков" Во-первых, если вы объявите асинхронный войд, к сожалению компилятор это позволяет сделать, в общем, если вы объявите асинхронный войд, то код, который будет вызывать ваш метод, не сможет дождаться результата.
5414.84 5418.24 "Анатолий Кулаков" Потому что у него будет войд, а результат надо дождать на таске.
5418.24 5426.68 "Анатолий Кулаков" И во-вторых, что он не сможет сделать, это никто не сможет обработать exception, который может у вас возникнуть в этой таске, которая происходит из-за асинквойда.
5426.68 5429.40 "Анатолий Кулаков" Поэтому никогда нельзя использовать асинквойд.
5429.40 5433.40 "Анатолий Кулаков" Постарайтесь всегда вместо него использовать асинхронный таск.
5433.40 5441.44 "Анатолий Кулаков" Почему же компилятор просто не запретил такую штуку делать вообще на уровне компиляции?
5441.44 5445.24 "Анатолий Кулаков" Есть некоторые случаи, когда вам это точно нужно сделать.
5445.24 5448.40 "Анатолий Кулаков" И здесь, как всегда, поднагадили винформы.
5448.40 5456.48 "Анатолий Кулаков" И потому что у них есть ивенты, на эти ивенты нужно подписываться, и ивенты по определению должны возвращать войд.
5456.48 5461.20 "Анатолий Кулаков" И, к сожалению, в этих ивентах часто люди запускают асинхронный код.
5461.20 5462.20 "Анатолий Кулаков" И вот у нас здесь получается асинквойд.
5462.20 5470.08 "Анатолий Кулаков" Ну, то есть в ивентах вам приходится все-таки спуститься, и там нет никакого красивого лайфхака для того, чтобы это обойти.
5470.08 5472.08 "Анатолий Кулаков" Вам придется спуститься на уровень вот этого кодсмела.
5472.08 5477.16 "Анатолий Кулаков" Но здесь вас просят хотя бы гарантировать одну единственную вещь.
5477.16 5481.24 "Анатолий Кулаков" Сделайте так, чтобы из вашего ивента никуда не вылетали исключения.
5481.24 5488.52 "Анатолий Кулаков" То есть обычно, если вам приходится так делать, то ивенты оборачиваясь сразу в глобальный трейткетч, уже дальше начинают в ивентах что-то делать.
5488.52 5496.24 "Анатолий Кулаков" Потому что в некоторых фрейворках, если вылетало необработанное исключение в этот момент, приложение полностью крашилось.
5496.24 5503.88 "Анатолий Кулаков" В общем, сейчас это кажется не так, но все равно упущены исключения, то есть о которых вы ничего не знаете, это довольно плохая ситуация.
5503.88 5509.68 "Анатолий Кулаков" Следующий кодсмел – это неподдержимые асинкделегаты.
5509.68 5514.28 "Анатолий Кулаков" Довольно сложная на слух воспринимается конструкция.
5514.28 5523.00 "Анатолий Кулаков" Когда вы в какой-нибудь callback, который у вас не поддерживает асинхронный делегат, асинхронную лямбду, вы передаете асинхронную лямбду.
5523.00 5527.60 "Анатолий Кулаков" То есть делаете async, две скобочки, стрелочку и там внутри пишите асинхронную функцию.
5527.60 5528.60 "Анатолий Кулаков" Что это значит?
5528.60 5535.04 "Анатолий Кулаков" Это по правде, что код не рассчитан на прием асинхронного делегата, а вы ему асинхронный делегат отдаете.
5535.04 5539.56 "Анатолий Кулаков" И по сути это все сводится к нашему предыдущему пункту, что у вас получается async void.
5539.56 5543.60 "Анатолий Кулаков" То есть код, который хочет void, вы ему отдаете асинхронный метод.
5543.60 5546.88 "Анатолий Кулаков" Решение данной проблемы существует два.
5546.88 5553.36 "Анатолий Кулаков" Если вы можете, то измените вот этот метод на func принимающий таску.
5553.36 5558.00 "Анатолий Кулаков" Тогда вы сможете передать туда что-то, что возвращает таску и полноценно его вызвать.
5558.00 5565.00 "Анатолий Кулаков" Если же вы не можете изменить сигнатуру метода, то тогда вы должны все-таки пользоваться асинхронным делегатом.
5565.00 5569.72 "Анатолий Кулаков" Не надо использовать асинхронный делегат, если тот код не умеет их принимать.
5569.72 5571.80 "Анатолий Кулаков" Выкручивайтесь как-нибудь по-другому.
5571.80 5577.92 "Анатолий Кулаков" Следующий код смел - это как раз заключается в специфике использования тасков вместе с юзингом.
5577.92 5584.64 "Анатолий Кулаков" Очень часто, когда вы используете юзинг, вы вполне можете забыть ключевое слово await.
5584.64 5585.64 "Анатолий Кулаков" Почему это возможно?
5585.64 5590.52 "Анатолий Кулаков" Потому что на самом деле, когда вы вызываете асинхронный метод, асинхронный метод возвращает вам таск.
5590.52 5594.36 "Анатолий Кулаков" А таск имплементирует, реализует интерфейс idisposable.
5594.36 5596.36 "Анатолий Кулаков" То есть компилятор здесь вам ничего не подскажет.
5596.36 5599.96 "Анатолий Кулаков" Компилятор видит, что вы хотите в юзинге задиспользовать таск.
5599.96 5600.96 "Анатолий Кулаков" Ну в принципе валидная операция.
5600.96 5604.20 "Анатолий Кулаков" Но на самом деле обычно такого делать никогда не нужно.
5604.20 5607.12 "Анатолий Кулаков" То есть это должен быть анализатор на уровень выше.
5607.12 5614.12 "Анатолий Кулаков" Поэтому когда вы делаете юзинг, вам нужно прежде всего внутри юзинга написать await и вызвать асинхронный метод.
5614.12 5615.12 "Игорь Лабутин" Вот это будет правильным.
5615.12 5625.88 "Игорь Лабутин" Я хочу тут добавить, что если создаваемый объект реализует idispose async, ну точнее dispose async внутри, то нужно использовать не юзинг, а await using.
5625.88 5632.48 "Игорь Лабутин" Поэтому вы можете написать конструкцию await using await и креить что-нибудь.
5632.48 5636.20 "Анатолий Кулаков" Более того, с disposeable async есть другая проблема.
5636.20 5639.84 "Анатолий Кулаков" Сейчас мы дойдем до конфигура wait и там о ней еще поговорим.
5639.84 5640.84 "Анатолий Кулаков" Окей.
5640.84 5653.08 "Анатолий Кулаков" А пока мы не дошли, еще одна интересная бага с юзингом, которая часто бывает, это когда вы создаете некий сервис, допустим тот же самый файл открываете, и вам нужно прочитать контент из этого файла.
5653.08 5658.96 "Анатолий Кулаков" И вы читаете контент из файла асинхронно и сразу делаете ретурн этой таски, которая прочитала.
5658.96 5661.48 "Анатолий Кулаков" Что в этот момент происходит?
5661.48 5667.72 "Анатолий Кулаков" Когда вы делаете ретурн без await, вы не дожидаясь результата, сразу возвращаете его.
5667.72 5670.48 "Анатолий Кулаков" Когда вы делаете ретурн, вы покидаете метод.
5670.48 5674.16 "Анатолий Кулаков" Когда вы покидаете метод, когда вы покидаете scope, срабатывает юзинг.
5674.16 5679.92 "Анатолий Кулаков" То есть юзинг закрывает этот файл, не дожидаясь того, когда вы закончите из него чтение.
5679.92 5695.40 "Анатолий Кулаков" И по факту принимающая сторона, когда примет ваш таск и захочет дождаться его окончания, то есть захочет дождаться окончания чтения из файла, из сокета, из базы, неважно, она не сможет этого сделать, потому что файл закрыт, база закрыта, сокет уже в этот момент закрыт.
5695.40 5697.56 "Анатолий Кулаков" Это тоже довольно часто ошибка.
5697.56 5707.92 "Анатолий Кулаков" Поэтому если вы читаете асинхронно внутри юзинга, то есть внутри какого-то ресурса, который у меня диспозится, вам необходимо обязательно дождаться результата.
5707.92 5712.60 "Анатолий Кулаков" В общем, тоже ошибка довольно частая.
5712.60 5721.80 "Анатолий Кулаков" Следующий космел, который у вас есть, это когда вы забываете о том, что у вас вызывается асинхронный метод, то есть забываете про его таск.
5721.80 5722.80 "Анатолий Кулаков" Как это можно сделать?
5722.80 5723.80 "Анатолий Кулаков" Очень легко.
5723.80 5726.84 "Анатолий Кулаков" Вызвать метод и при этом не вызвать await.
5726.84 5735.68 "Анатолий Кулаков" То есть метод уйдет куда-то работать, и результат никуда не сохранится, и дождаться не будет, и ничего происходить с ним не будет.
5735.68 5741.40 "Анатолий Кулаков" То есть по сути это немножко похоже на async/void.
5741.40 5747.00 "Анатолий Кулаков" Поэтому всегда рекомендуется писать ключевое слово await, если вы все-таки вызываете асинхронный класс.
5747.00 5748.40 "Анатолий Кулаков" Не надо его оставлять просто так.
5748.40 5755.32 "Анатолий Кулаков" Это одно из немногих, по-моему, единственное космел, который ловит компилятор.
5755.32 5757.12 "Анатолий Кулаков" Но и то он его ловит не всегда.
5757.12 5760.00 "Анатолий Кулаков" Поэтому все-таки дополнительные анализаторы вам нужны.
5760.00 5761.48 "Анатолий Кулаков" Что же тут нужно сделать?
5761.48 5769.64 "Анатолий Кулаков" Это во-первых, да, или добавить ключевое слово await, или все-таки результат сохранить в какую-то переменную, если вы хотите, допустим, проанализировать ее позже.
5769.64 5773.36 "Анатолий Кулаков" Можно таску засунуть в переменную и попозже посмотреть, там завершилась она или не завершилась.
5773.36 5775.36 "Анатолий Кулаков" Но просто так методы запускать нельзя.
5775.36 5778.48 "Анатолий Кулаков" Следующий довольно часто используемый…
5778.48 5785.56 "Игорь Лабутин" Погоди секунду. А еще, кстати, вот такая штука, что ты думаешь еще о следующем вещи.
5785.56 5793.88 "Игорь Лабутин" Иногда конструкцию переменной присвоить, что-то там async используют для выполнения, грубо говоря, начала какого-то бэкграундной работы.
5793.88 5801.64 "Игорь Лабутин" То есть вот у тебя идет метод, и ты такой, ну мне, короче, надо запустить какую-нибудь там, не знаю, отсылку почты, мне плевать, закончится она хорошо или не хорошо.
5801.64 5810.08 "Игорь Лабутин" Я пишу там подчеркивание, task подчеркивание равно и, значит, send mail async, ну и передаю какие-то аргументы.
5810.08 5812.68 "Игорь Лабутин" И, в общем, забиваю на это подчеркивание.
5812.68 5815.44 "Игорь Лабутин" Оно потом когда-нибудь соберется в garbage collector.
5815.44 5820.88 "Анатолий Кулаков" Здесь все-таки, смотри, ты все-таки теряешь обработку ошибок.
5820.88 5828.40 "Анатолий Кулаков" Потому что если у тебя случится исключение при твоей отсылке, то, грубо говоря, ты ничего не сделаешь.
5828.40 5835.00 "Анатолий Кулаков" Понятное действие, что нам, в принципе, наплевать, но все-таки в случае ошибки нам хотелось бы, наверное, хотя бы его залогировать.
5835.00 5846.84 "Анатолий Кулаков" Поэтому нам все-таки хотелось бы сделать какой-нибудь continuation, в этом continuation проанализировать, как минимум, успешно таска выполнилась или не успешно, и если не успешно, записать влог.
5846.84 5852.60 "Анатолий Кулаков" То есть обычно вот такой подход, он более распространен, что мы хотя бы анализируем ошибки, хотя бы анализируем
5852.60 5865.56 "Игорь Лабутин" exception. Ну то есть тогда, если вы делаете так, то пишите вот в этот самый вызов метода, потом точка continue with и ставьте туда флажок unfailure, там есть прям отдельная, которая будет выполнена только если оно действительно закончилось неуспешно.
5865.56 5869.20 "Игорь Лабутин" Ну и внутри там, да, хотя бы залогируете что-нибудь.
5869.20 5870.20 "Анатолий Кулаков" Да, да.
5870.20 5875.52 "Анатолий Кулаков" Ну обычно, чтобы не заморачиваться с этим флажками unfailure, делают extension метод, там fire and forget, допустим.
5875.52 5880.64 "Анатолий Кулаков" И внутри этого extension метода уже анализируют continuation, failure и все такое, логи.
5880.64 5883.00 "Анатолий Кулаков" В общем, да, есть такой подход тоже.
5883.00 5888.08 "Анатолий Кулаков" И он в принципе довольно, не то чтобы сильно распространен, но довольно применим.
5888.08 5894.96 "Анатолий Кулаков" Это довольно хорошая такая система, когда вам все-таки нужно что-то выполнить и не дожидаться результата.
5894.96 5899.08 "Анатолий Кулаков" Пойдем к следующему кодсмейлу, тоже частая штука.
5899.08 5901.76 "Анатолий Кулаков" Многие делают ее от безысходности.
5901.76 5907.32 "Анатолий Кулаков" Это синхронный wait, синхронное ожидание асинхронного метода.
5907.32 5913.20 "Анатолий Кулаков" Наверное, самая распространенная ошибка или даже проблема, потому что для нее нет какого-то хорошего решения.
5913.20 5926.48 "Анатолий Кулаков" Если в вашем коде есть какой-нибудь синхронный метод, и при этом вам нужно почему-то вызвать асинхронный метод из него, то у вас не так уж и много выборов, что можно сделать.
5926.48 5933.28 "Анатолий Кулаков" Во-первых, можно сделать fire and forget, как мы обсуждали выше, типа запульнись и работай там, как хочешь, меня это не интересует.
5933.28 5937.92 "Анатолий Кулаков" Но очень часто вам нужен результат работы этого синхронного метода.
5937.92 5940.48 "Анатолий Кулаков" И тогда такой подход не работает.
5940.48 5941.48 "Анатолий Кулаков" Fire and forget не работает.
5941.48 5953.00 "Анатолий Кулаков" В этом случае можно сделать метод wait, то есть подождать синхронно, когда завершится task.
5953.00 5962.08 "Анатолий Кулаков" Можно обратиться к точке результат, и обращение к результату будет точно так же ждать, когда завершится task.
5962.08 5971.00 "Анатолий Кулаков" Можно сделать чуть хитроумнее, вызвать getAwaiter, getResult методы, или якобы чем-то лучше.
5971.00 5979.08 "Анатолий Кулаков" Но смысл всех этих танцев один единственный – синхронно дождаться завершения асинхронного метода.
5979.08 5981.92 "Анатолий Кулаков" И вот это очень опасная штука.
5981.92 5985.80 "Анатолий Кулаков" Она, конечно, не всегда, но очень часто приводит к дедлокам.
5985.80 5991.36 "Анатолий Кулаков" И те, кто с этим сталкивался, стараются очень сильно избегать такого подхода.
5991.36 5994.28 "Анатолий Кулаков" В общем, здесь хорошего решения нет.
5994.28 5998.20 "Анатолий Кулаков" Хорошее решение – пытайтесь каким-то образом избегать этих ситуаций.
5998.20 6004.20 "Анатолий Кулаков" В общем, хорошего решения ждать асинхронно, то есть дождать асинхронных методов, его не существует.
6004.20 6017.84 "Анатолий Кулаков" Можно навесить там кучу всяких проверок, атрибутов, хаков, более-менее без дедлоков чего-то там дождаться, но все это довольно скользкая дорожка, которая зависит от кучи факторов.
6017.84 6027.60 "Анатолий Кулаков" Подробнее об этом хорошо расписывал Дэвид Фаулер в своей статье «Диагностик сценарии для асинхронных рекомендаций».
6027.60 6031.92 "Анатолий Кулаков" В общем, тоже обалденная статейка у него на GitHub есть, может мы ее даже отдельно обсудим.
6031.92 6035.60 "Анатолий Кулаков" Там тоже есть очень много рекомендаций, как работать с асинхронным кодом.
6035.60 6041.96 "Анатолий Кулаков" Они там обычно глубже, больше и нуднее, но очень полезные.
6041.96 6052.84 "Анатолий Кулаков" Поэтому, если вам вдруг понравится наш вот этот обзорчик, если вы поймете то, что мы словами пытаемся описать асинхронный код, то пишите комментарии, Фаулера мы тоже обсудим.
6052.84 6055.00 "Анатолий Кулаков" У него тоже отличный набор.
6055.00 6056.00 "Анатолий Кулаков" Погнали дальше.
6056.00 6059.84 "Анатолий Кулаков" Дальше у нас уже прям идут пункты для эстетов.
6059.84 6062.32 "Анатолий Кулаков" Отсутствующий конфигур Await.
6062.32 6066.44 "Анатолий Кулаков" Тоже один из самых спорных блоков.
6066.44 6067.44 "Анатолий Кулаков" Давайте поподробнее.
6067.44 6082.20 "Анатолий Кулаков" По дефолту, когда вы вызываете асинхронный метод и await его, во время вызова асинхронного метода замыкается синхронизация контекст или Task Scheduler.
6082.20 6089.24 "Анатолий Кулаков" Для того, чтобы когда этот асинхронный метод закончил свою работу, управление вернулось в тот же самый поток, из которого его вызывали.
6089.24 6096.96 "Анатолий Кулаков" И, к сожалению, это поведение по умолчанию сделано было, но было еще для WinForms или для других UI Framework.
6096.96 6097.96 "Анатолий Кулаков" Не суть, важно.
6097.96 6103.08 "Анатолий Кулаков" Для нас важно то, что по умолчанию синхронизация контекста капчурится.
6103.08 6107.16 "Анатолий Кулаков" А это значит, что это немножко влияет на перформанс.
6107.16 6114.64 "Анатолий Кулаков" То есть, мы могли бы наши вызовы асинхронные сделать быстрее, если бы он не капчурил вот эти штуки.
6114.64 6122.08 "Анатолий Кулаков" И вторая проблема в том, что это первый, по-моему, даже единственный способ получить дедлок на ровном месте.
6122.08 6127.68 "Анатолий Кулаков" То есть, это самый главный, там 99%, когда в C# можно получить дедлок, это именно из-за этой штуки.
6127.68 6133.12 "Анатолий Кулаков" Из-за того, что у вас как раз таки замыкается синхронизация контекст, в который вам нужно потом обратно вернуться.
6133.12 6141.92 "Анатолий Кулаков" Поэтому для того, чтобы избежать дедлоков, для того, чтобы избежать перформанс кастов, существует конфигур await false.
6141.92 6147.36 "Анатолий Кулаков" То есть, специальная дописка к вашему await асинхронному методу.
6147.36 6150.52 "Анатолий Кулаков" И бест практисом является всегда и везде его использовать.
6150.52 6158.36 "Анатолий Кулаков" Здесь, конечно же, есть большой-большой минус в том, что код становится менее читабельным, в нем появляется вот этот мусор.
6158.36 6164.76 "Анатолий Кулаков" И этот мусор появляется не в одном каком-то атрибуте на уровне сборки, а прямо в каждом методе, который вы вызываете.
6164.76 6171.96 "Анатолий Кулаков" И вот, кстати, может быть, вот это для нового фреймворка была бы мега-крутая фича, которую могли бы завести, вместо того, чтобы всякими глупостями заниматься.
6171.96 6174.56 "Игорь Лабутин" В общем, давно люди просят убрать эту фичу.
6174.56 6177.60 "Игорь Лабутин" Слушай, слушай, слушай, у меня два дополнения.
6177.60 6178.60 "Игорь Лабутин" Одно дополнение, одна мысль.
6178.60 6179.60 "Игорь Лабутин" Дополнение первое.
6179.60 6191.96 "Игорь Лабутин" Как только мы получим дотнет восьмой, напоминаю, что конфигур await поменялся, то есть не поменялся, а добавилась новая перегрузка, теперь туда можно писать не просто true и false, а прямо там есть флаговый num с четырьмя значениями.
6191.96 6198.00 "Игорь Лабутин" И можно писать configure await, сколько открылось, configure await options.continue uncaptured context.
6198.00 6201.44 "Анатолий Кулаков" Да, но это не поможет решить нашу проблему.
6201.44 6203.00 "Анатолий Кулаков" Это так, ее расширит немножко.
6203.00 6211.16 "Игорь Лабутин" Нет, в смысле, что это будет не configure await false, а прям в смысле, а, да, получается.
6211.16 6213.12 "Игорь Лабутин" Configure await options.none нужно писать.
6213.12 6214.44 "Игорь Лабутин" Вот, я что-то не то говорю.
6214.44 6215.44 "Анатолий Кулаков" None нужно писать.
6215.44 6218.64 "Анатолий Кулаков" Нет, none, да ладно, я тебе говорю про то, что нам бы хотелось вообще ничего не писать.
6218.64 6219.64 "Игорь Лабутин" Вот, вот, вот.
6219.64 6220.64 "Игорь Лабутин" А про вообще ничего не писать?
6220.64 6221.64 "Игорь Лабутин" Ничего не писать.
6221.64 6241.40 "Игорь Лабутин" Тут я подумал, а не получится ли здесь написать source generator, который с помощью интерсепторов, мы же можем проанализировать весь код, найти точные места, где у нас вызваны соответствующие места и дописать, а блин, мы же только заменяем вызовы.
6241.40 6242.40 "Игорь Лабутин" Мы не можем.
6242.40 6245.92 "Анатолий Кулаков" Да, интерсепторы тебе прям на метод накладываются, а здесь на вызов.
6245.92 6246.92 "Игорь Лабутин" Да, а здесь на вызов.
6246.92 6250.60 "Игорь Лабутин" Нет, ну интерсепторы, подожди, ты не прав.
6250.60 6256.40 "Игорь Лабутин" Интерсептор, да, он накладывается на метод в нужной точке вызова, а здесь нету точки вызова.
6256.40 6260.64 "Игорь Лабутин" Вот, ну да, ну да.
6260.64 6261.64 "Игорь Лабутин" Пока не получается.
6261.64 6264.00 "Игорь Лабутин" Черт, была такая хорошая идея.
6264.00 6266.60 "Игорь Лабутин" Ну ладно, давай дальше по проблему.
6266.60 6267.60 "Анатолий Кулаков" Давай дальше.
6267.60 6270.92 "Анатолий Кулаков" Ну и кстати, да, тут надо давай сразу с противоположной лагерей рассматривать.
6270.92 6281.56 "Анатолий Кулаков" Некие эстеты кричат, что это слишком мусорно, мы не используем нигде синхронизация контексты, мы winform не юзаем, webf не юзаем, spnet не юзаем, в общем, нам это ничего не нужно.
6281.56 6290.68 "Анатолий Кулаков" Здесь как бы можно долго дискутировать, но факт в том, что вы никогда не знаете, когда у вас появится синхронизация контекста точно так же, как когда он от вас ушел.
6290.68 6306.16 "Анатолий Кулаков" Например, в новом модном Blazor у нас есть синхронизация контекст, в том же самом XUnity, который используется практически везде, тоже есть синхронизация контекст, поэтому всем товарищам-экспертам всегда проставляйте конфигурацию WhiteFalls.
6306.16 6313.80 "Анатолий Кулаков" Дальше, return null из как раз методов, которые должны возвращать таску.
6313.80 6320.16 "Анатолий Кулаков" Так как таск – это reference type был, то оттуда вполне можно было бы заретурнить null.
6320.16 6334.24 "Анатолий Кулаков" Но так как обычно уважающий себя код, который вызывает асинхронные методы, ожидает тасков, которые оттуда придут, но он никогда не ожидает, что оттуда придут null и никогда такой проверки никто не добавлял.
6334.24 6347.96 "Анатолий Кулаков" Поэтому, естественно, хорошим тоном считается не возвращать null, если в сигнатуре вашего кода есть таска, а все-таки писать с помощью вспомогательных методов, например, task.completeTask или task.fromResult.
6347.96 6352.44 "Анатолий Кулаков" Если вам нужно прямо вернуть null, значит task.fromResult.null делаете.
6352.44 6356.32 "Анатолий Кулаков" Это тоже нормально, но не напрямую null.
6356.32 6360.96 "Анатолий Кулаков" Дальше, асинхронные методы должны всегда заканчиваться на суффикс async.
6360.96 6363.80 "Анатолий Кулаков" Это тоже проблема эстетов.
6363.80 6372.72 "Анатолий Кулаков" Они думают, что если мы берем суффикс async, то мы так мега сэкономим кода, и он станет более красивым, более читабельным, и давайте так делать.
6372.72 6377.20 "Анатолий Кулаков" Считается, что это убирает мусор.
6377.20 6385.72 "Анатолий Кулаков" Но на самом деле, если вы будете писать все методы без асинхронной методы, то это очень сильно усложнит понимание кода.
6385.72 6403.44 "Анатолий Кулаков" То есть, когда мы читаем код, допустим, на том же самом ревью, и видим, что у нас асинхронный код, который кончается на async, слева не имеет await, мы сразу на ревью можем сказать, чувак, у тебя здесь один из код смайлов, который мы вверху обсуждали.
6403.44 6407.28 "Анатолий Кулаков" Асинхронные методы нужно обязательно дожидаться или результат складывать в переменку.
6407.28 6408.28 "Анатолий Кулаков" У тебя здесь ничего нет.
6408.28 6419.32 "Анатолий Кулаков" Если же мы идем по пути того, что мы уменьшаем якобы шум и делаем методы без async суффикса, то на ревью мы этого никогда не увидим.
6419.32 6425.36 "Анатолий Кулаков" Если мы без async суффикса еще и забудем await, то никакой ревью вам не поможет.
6425.36 6428.68 "Анатолий Кулаков" Вы будете видеть просто вызов очередного метода.
6428.68 6432.68 "Игорь Лабутин" То есть, в расчет только на анализаторы получается.
6432.68 6444.96 "Игорь Лабутин" Да, при этом мне кажется, я в каких-то статьях Microsoft видел, не то что в статьях, рекомендациях, мне казалось, что я уже видел не такое однозначное, прям, обязательно надо окончиться на async.
6444.96 6450.12 "Игорь Лабутин" То есть, у меня в голове есть какая-то мысль, что Microsoft уже не так реально это рекомендует.
6450.12 6458.88 "Игорь Лабутин" Возможно, потому что действительно, как бы, такие проблемы, как ты говоришь, не должны находиться на ревью, они должны находиться, конечно, на анализаторах.
6458.88 6464.24 "Игорь Лабутин" Потому что это довольно несложно, по идее, должно быть найти такой анализатор.
6464.24 6474.72 "Игорь Лабутин" Поэтому я вот не отношусь к тем, что прям строго хочет и просит везде добавлять async суффикс, но стараемся добавлять анализаторы.
6474.72 6479.52 "Анатолий Кулаков" Видишь, тут, к сожалению, не только анализаторы дело.
6479.52 6489.56 "Анатолий Кулаков" То есть, даже если ты разбираешь код, который работает, в голове тебе удобнее разбирать, когда ты знаешь, асинхронит этот метод или нет.
6489.56 6493.12 "Анатолий Кулаков" А ты не всегда можешь это увидеть по async.
6493.12 6511.04 "Игорь Лабутин" Ну, знаешь, если… Нет, я согласен, что если там какой-то суперсложный код, типа мы вызовем параллельно 20 async методов, соберем их тасками, кто первый победит, тот и выиграл, значит, остальные мы за концелем, то да, конечно, в таком коде нужно знать, кто там асинхронный, кто синхронный и так далее.
6511.04 6514.48 "Игорь Лабутин" Где там async локалы передаются, где не передаются, это я согласен.
6514.48 6522.72 "Игорь Лабутин" В остальном я вот не ощущал какой-то большой проблемы от того, что я не видел async суффиксов, было ли у нас некоторые кодовые базы, где мы такими не использовали.
6522.72 6538.40 "Игорь Лабутин" То есть я бы сказал, что, наверное, конечно, явное лучше неявного, и понятно, что если async суффикс написан, то, наверное, это будет лучше, но я не сильно строго топлю за это при наличии аналайзеров.
6538.40 6539.76 "Игорь Лабутин" Я вот так скажу.
6539.76 6544.80 "Игорь Лабутин" Если у вас аналайзеров при этом ещё и нет, ну тогда да, тогда может пойти всё что угодно не так.
6544.80 6553.32 "Анатолий Кулаков" Ну, видишь, с аналайзерами тоже такая штука, у меня уже там, по-моему, три аналайзера, которых я использовал для асинхронного кода, отвалились, потому что их авторы переставали поддерживать.
6553.32 6561.60 "Анатолий Кулаков" Поэтому пока, наверное, это не войдёт в какую-нибудь стандартную коробку, и пока не будет какой-то хорошей поддержки, сложно на анализатор сильно рассчитывать.
6561.60 6562.60 "Анатолий Кулаков" Ну, тоже согласен.
6562.60 6566.36 "Игорь Лабутин" Ну, в общем, это всегда такой трейдов всего и вся.
6566.36 6570.68 "Игорь Лабутин" Красоты, не знаю, краткости, договорённости команды, опять же, и так далее.
6570.68 6573.88 "Анатолий Кулаков" Да, примерно такая же ситуация, как и с конфигурацией false.
6573.88 6580.64 "Анатолий Кулаков" Он вроде как бы необязательный, и в большинстве случаев он не нужен, но вот когда он понадобится, вам будет плохо.
6580.64 6585.60 "Анатолий Кулаков" Когда вы в паре случаев прозеваете, вам, скорее всего, будет плохо, но в большинстве случаев, возможно, этого вам и не надо.
6585.60 6587.16 "Анатолий Кулаков" Ну ладно, давай дальше.
6587.16 6590.48 "Анатолий Кулаков" Поэтому здесь мы боремся между шумом и функциональностью.
6590.48 6592.44 "Анатолий Кулаков" Кому что важнее, выбираете уже сами.
6592.44 6604.48 "Анатолий Кулаков" Так, у нас вот предыдущий пункт был, что мы можем асинхронных методов писать или не писать, но Microsoft рекомендует его всегда писать.
6604.48 6610.44 "Анатолий Кулаков" А второй, более интересный, я, в принципе, даже такого анализатора как-то встречал, наверное, но не задумывался, что он нужен.
6610.44 6622.00 "Анатолий Кулаков" Когда наоборот, когда у вас есть обычный синхронный код, ну, представляете, который там void возвращает, int возвращает, вот такие бывательные синхронные коды, он имеет суффикс async.
6622.00 6623.92 "Анатолий Кулаков" Ты видел такое когда-нибудь?
6623.92 6634.52 "Игорь Лабутин" Ну какие-нибудь старые дотнетные API, там, из времён TPL, send socket async принимающий какой-нибудь, а я async резал, вот это всё помнишь?
6634.52 6637.12 "Анатолий Кулаков" Ну он хотя бы пытается быть асинхронным.
6637.12 6638.12 "Анатолий Кулаков" Ну да, согласен, ладно.
6638.12 6639.12 "Игорь Лабутин" В каком-то месте.
6639.12 6647.64 "Игорь Лабутин" Пытается, нет, такого, чтоб прям синхронный метод, но был при этом async, если только async у вас нет, ну как бы как доменной сущности, но это вряд ли.
6647.64 6655.88 "Анатолий Кулаков" Ну вот и к моему большому удивлению, прямо много анализаторов поддерживает эту штуку, то есть наверняка в мире какие-то проблемы с этим были.
6655.88 6656.88 "Анатолий Кулаков" Почему так не надо делать?
6656.88 6666.72 "Анатолий Кулаков" Ну прежде всего, потому что этот код вводит в заблуждение, когда у вас синхронный код, называется async, вы от него немножко не того ожидаете, не того поведения, вы сразу начнёте кричать, а где здесь его void?
6666.72 6668.52 "Анатолий Кулаков" А он там по правде не нужен.
6668.52 6673.72 "Анатолий Кулаков" И автор говорит, что такие вещи обычно остаются после рефакторинга.
6673.72 6679.20 "Анатолий Кулаков" Когда вы отрефакторили метод, сделали его синхронным, но при этом забыли переименовать и оставили суффикс async.
6679.20 6682.40 "Анатолий Кулаков" Вот тогда вас может встретить такая кракозебра.
6682.40 6688.20 "Анатолий Кулаков" Так, следующий код смейл – это обязательное передавание cancellation токена.
6688.20 6699.20 "Анатолий Кулаков" Опять же, здесь борьба с функциональностью и многословностью, потому что передача cancellation токена опять же увеличивает вызов вашего асинхронного метода, делает его более большим.
6699.20 6700.88 "Анатолий Кулаков" Зачем это нужно?
6700.88 6707.80 "Анатолий Кулаков" Потому что обычно асинхронные методы – это какие-нибудь долго выполняющиеся методы или методы, требующие обращения к блокным устройствам.
6707.80 6719.16 "Анатолий Кулаков" И поэтому очень полезно им выдавать cancellation токен, который позволит им отменять свою какую-то долгую, длинную, тяжелую, жирную операцию как можно раньше.
6719.16 6728.00 "Анатолий Кулаков" Ну, например, если ваше приложение сейчас начало стопаться, а вы в этот момент начинаете формировать там какой-то годовой отчет, асинхронно, конечно же, а в общем.
6728.00 6735.00 "Анатолий Кулаков" И чтобы этот годовой отчет все-таки прервать и застопать приложение, допустим, там его перезапустить надо, в общем, для этого есть cancellation токены.
6735.00 6737.16 "Анатолий Кулаков" Поэтому им очень удобно пользоваться.
6737.16 6740.04 "Анатолий Кулаков" Также cancellation токены очень хорошо спасают от pull-servation.
6740.04 6745.92 "Анатолий Кулаков" В тот момент, когда у вас огромное количество веб-запросов, эти веб-запросы отменяются.
6745.92 6762.84 "Анатолий Кулаков" Очень часто существуют такие атаки, которые начинают запрашивать ресурсы с вашего веб-сервиса, но для того, чтобы не тратить свои собственные ресурсы, они вам кидают только начало коннекта, но при этом сразу закрывают коннект и не дожидаются ответа.
6762.84 6767.36 "Анатолий Кулаков" А в этот момент какое-нибудь сложное построение годового отчета начинает делаться.
6767.36 6774.84 "Анатолий Кулаков" В общем, это тоже способ, как избежать истощения тредов в вашем приложении.
6774.84 6779.24 "Анатолий Кулаков" Поэтому рекомендация, в общем, всегда передавайте cancellation токены.
6779.24 6791.88 "Анатолий Кулаков" Обычно анализаторы довольно умные, то есть они смотрят, что если в вашем скопе есть cancellation токен, и асинхронный метод, который вы вызываете, поддерживает прием cancellation токена, то тогда они вам советуют его передать.
6791.88 6798.80 "Анатолий Кулаков" Но есть более жесткие анализаторы, они всегда заставляют вас найти где угодно cancellation токен, но передай его туда.
6798.80 6800.96 "Анатолий Кулаков" В общем, заставляют вас найти cancellation токен.
6800.96 6802.80 "Анатолий Кулаков" Тоже такой забавный момент был.
6802.80 6820.72 "Игорь Лабутин" Ну и если вам таки действительно его неоткуда взять по какой-то причине или вы там точно не хотите, ну в общем, разные ситуации бывают, никогда не передавайте туда, ну null, cancellation токен структуру, null вы туда особо не передадите, всегда есть правильно передавать cancellation token .none.
6820.72 6831.28 "Игорь Лабутин" То есть если вам вдруг действительно его не нужно, в тестах, например, еще в чем-нибудь, то нужно протестить метод с cancellation токеном, использовать cancellation token none.
6831.28 6836.40 "Анатолий Кулаков" Ну еще нужно учесть, что cancellation token none, он является дефолтом.
6836.40 6843.04 "Анатолий Кулаков" Так как это структура, вы вполне можете объявить опциональный параметр, сделав ему по умолчанию поведение default.
6843.04 6846.48 "Анатолий Кулаков" И тогда в тестах вам вообще ничего не надо будет передавать.
6846.48 6853.00 "Игорь Лабутин" Я бы так не делал, потому что как только параметр опциональный, есть шанс его забыть и в продакшн-коде.
6853.00 6858.48 "Анатолий Кулаков" Ну вот как раз для тех людей, которые, как и ты, полностью рассчитывают на анализаторы, анализаторы тебе подскажут.
6858.48 6860.04 "Анатолий Кулаков" Ну хорошо, ладно.
6860.04 6863.12 "Анатолий Кулаков" Тут надо определиться, уж ты или крестик наденешь, то есть и с ними.
6863.12 6865.84 "Анатолий Кулаков" Я правильные анализаторы только выберу.
6865.84 6874.12 "Анатолий Кулаков" Еще одна интересная тема с cancellation токеном и очередной код смейл - это про async enumerables.
6874.12 6882.96 "Анатолий Кулаков" Есть у нас такая прекрасная тема async enumerables, которые нам добавили еще async for each и вот эти прочие такие космические вещи.
6882.96 6884.88 "Анатолий Кулаков" Но у них специфика другая.
6884.88 6890.48 "Анатолий Кулаков" У них специфика в том, что тебе в этот enumerable каким-то образом тоже нужно передать cancellation token.
6890.48 6894.28 "Анатолий Кулаков" Что бывает непросто, потому что здесь у тебя нет какого-то явного вызова метода.
6894.28 6898.56 "Анатолий Кулаков" Здесь у тебя есть готовый async enumerable интерфейс, который надо прокручивать.
6898.56 6906.44 "Анатолий Кулаков" И вот для того, чтобы async enumerable передать cancellation token, у него есть специальный метод, который называется VIV cancellation token.
6906.44 6911.08 "Анатолий Кулаков" И хорошие анализаторы умеют в том числе учитывать его так же точно.
6911.08 6923.56 "Анатолий Кулаков" Вот, я еще обещал подсказать еще один интересный код смейл, который может привести к большим количествам ошибок, я их ловил, и которого здесь нет.
6923.56 6925.32 "Анатолий Кулаков" Это про async disposable.
6925.32 6926.84 "Анатолий Кулаков" Помнишь, ты говорил?
6926.84 6938.32 "Анатолий Кулаков" Вот когда люди юзают async disposable вместе с асинхронным методом, они обычно пишут using, await и вызывают метод.
6938.32 6940.04 "Анатолий Кулаков" Например, openfile.
6940.04 6946.16 "Анатолий Кулаков" И если этот openfile будет возвращать не просто idisposable, тогда все у вас будет хорошо.
6946.16 6954.60 "Анатолий Кулаков" А вот если этот openfile будет возвращать async disposable, то здесь есть небольшая хитрость.
6954.60 6963.96 "Анатолий Кулаков" Как я уже сказал, любой await должен сопровождаться конфигурой await false, иначе вы захватите синхронизацию контекста, и это может привести к дедлокам.
6963.96 6972.60 "Анатолий Кулаков" Вот, грамотные люди, когда вас будут открывать файл, они напишут using await openfile, конфигура await false.
6972.60 6978.80 "Анатолий Кулаков" Вот когда этот метод возвращает просто idisposable, все будет хорошо.
6978.80 6992.68 "Анатолий Кулаков" А вот когда он будет возвращать async disposable, то все будет плохо, потому что ваш конфигура await false применится только к открытию файла, но он не применится к асинхронному диспозу.
6992.68 6998.76 "Анатолий Кулаков" Для того, чтобы он применился к асинхронному диспозу, к сожалению, синтоксический сахар стандартом C# не помогает.
6998.76 7011.20 "Анатолий Кулаков" Вам нужно будет сохранить результат в переменку, при том результат нужно получить с помощью конфигура await false, а потом взять эту переменку и обернуть в scope_using.
7011.20 7017.44 "Анатолий Кулаков" И когда вы будете оборачивать scope_using, то уже у этой переменки появится метод конфигура await false.
7017.44 7020.36 "Анатолий Кулаков" То есть, у вас будет два await'а.
7020.36 7023.84 "Анатолий Кулаков" Первый await на вызове метода, второй await на dispose.
7023.84 7027.48 "Анатолий Кулаков" И значит, у вас должно быть два конфигура await false.
7027.48 7032.60 "Анатолий Кулаков" Один конфигур false, соответственно, на вызове метода, и другой конфигур false на dispose.
7032.60 7036.68 "Анатолий Кулаков" Чтобы он задиспозился, в том числе и без дедлока.
7036.68 7039.84 "Анатолий Кулаков" Потому что это мега-мега-сложный дедлок, короче.
7039.84 7042.96 "Анатолий Кулаков" Я его когда ловил, я понять не мог, почему он происходит.
7042.96 7046.60 "Анатолий Кулаков" Потому что я же при вызове говорю, конфигура await false, откуда там дедлок появляется.
7046.60 7053.16 "Анатолий Кулаков" Оказывается, что при вызове-то я говорю, а при диспозе, при неявном, который запускает асинхронный юзинг, я не говорю.
7053.16 7056.00 "Анатолий Кулаков" Потому что это асинхронный юзинг неявно его запускает.
7056.00 7059.64 "Анатолий Кулаков" Вот такая недоработка, можно сказать, баг просто в асинхронном юзинге у нас есть.
7059.64 7063.44 "Анатолий Кулаков" И никто его чинить не собирается, потому что это якобы фича.
7063.44 7064.44 None Ну, удобно, что.
7064.44 7065.44 "Игорь Лабутин" Назови фичей.
7065.44 7066.44 "Игорь Лабутин" Ну, действительно, наверное.
7066.44 7073.20 "Игорь Лабутин" Слушай, не знаю, насколько много народу с этим может столкнуться.
7073.20 7081.32 "Игорь Лабутин" Я пока еще, честно говоря, асинх диспозу почти не видел, но это не значит, что их нет.
7081.32 7082.32 "Игорь Лабутин" Давай к аналайзерам.
7082.32 7083.32 "Игорь Лабутин" Есть у нас аналайзеры?
7083.32 7084.32 "Игорь Лабутин" Ты же наверняка много чего пьюзал.
7084.32 7089.64 "Игорь Лабутин" Да, да, аналайзер много чего пьюзал, но видишь,
7089.64 7104.00 "Анатолий Кулаков" к сожалению, с аналайзерами у нас есть огромная проблема. Автор в данной статье нашел их целых семь штук, и ни один из этих семи штук не покрывает, блин, даже хотя бы 50% всех описанных проблем.
7104.00 7113.80 "Анатолий Кулаков" То есть, он говорит, что мне для того, чтобы более-менее жить спокойно, то есть не 100% покрыть случаев, а там ближе к 80%, нужно три анализатора.
7113.80 7116.00 "Анатолий Кулаков" Представляешь, три, Карл.
7116.00 7123.52 "Анатолий Кулаков" В общем, он остановился на AsyncFicture, VSTrading и MizzantowAnalyzer.
7123.52 7128.04 "Анатолий Кулаков" Это тоже там большой автор, мы его часто в статье берем, он тоже написал свой анализатор.
7128.04 7133.36 "Анатолий Кулаков" В общем, ссылки на все анализаторы будут в статье, если вам интересно, лучше пройти по ним.
7133.36 7135.80 "Анатолий Кулаков" И также в этой статье есть прекрасная табличка.
7135.80 7153.76 "Анатолий Кулаков" В этой табличке собраны 14 наших кодсмейлов, которые мы сегодня рассмотрели, и по другому измерению собраны 7 анализаторов, и там расписано, какой анализатор, какой кодсмейл ловит, и даже есть ли для него фикс, автоматический фикс для этого или нет для этого автоматического фикса.
7153.76 7160.92 "Анатолий Кулаков" В общем, можете тоже на эту табличку посмотреть, в зависимости от того, какие анализы именно важны вам, выбрать анализаторы, которые вам нужны.
7160.92 7164.84 "Анатолий Кулаков" Или может быть обойдетесь меньшим числом, не тремя.
7164.84 7179.68 "Анатолий Кулаков" Также интересно, что в комментарии прибежал автор из SonarCube и говорит, что у нас в SonarCube есть тоже открытый анализатор C#, и он там, судя по описанию, поддерживает довольно много интересных вещей и очень много того, чего не было у нас здесь обсуждено.
7179.68 7186.60 "Анатолий Кулаков" Потому что, как я уже сказал, здесь довольно не все кодсмейлы, просто какие-то 14 одни из самых популярных.
7186.60 7198.72 "Анатолий Кулаков" Есть очень специфические вещи, например, ты знал, что нельзя проверять по-хорошему входные аргументы на null, допустим, и исполнять асинхронный код в одном и том же методе.
7198.72 7200.60 "Анатолий Кулаков" По-хорошему тебе нужно делать.
7200.60 7208.04 "Игорь Лабутин" Да, нужно разделять, потому что иначе у тебя эта проверка будет выполнена только уже в момент, ну потом когда-нибудь.
7208.04 7210.36 "Игорь Лабутин" Когда вызовется таск.
7210.36 7211.36 "Игорь Лабутин" Да, да, да.
7211.36 7213.36 "Игорь Лабутин" А не в момент, собственно, вызова.
7213.36 7219.24 "Игорь Лабутин" Мы это обсуждали год до полтора, мне кажется, назад, где-то в подкасте, я помню.
7219.24 7221.04 "Анатолий Кулаков" Да, да, да, была такая тема.
7221.04 7227.52 "Анатолий Кулаков" В общем, много открытий чудных готовят вам таски, поэтому хорошо, что большинство людей с такими открытиями не сталкивается.
7227.52 7244.96 "Анатолий Кулаков" Ну, по крайней мере, вот с теми, с которыми, когда вы столкнетесь, у вас будут какие-нибудь рантайм дедлоки или мега ошибки, вот лучше всё-таки предусмотреть заранее и напустить анализаторы, потому что когда у тебя ошибка бросится не в начале метода, а там, где ты заявэйтишь, это, наверное, не так страшно.
7244.96 7246.52 "Анатолий Кулаков" Как бы всё равно.
7246.52 7251.92 "Анатолий Кулаков" А вот когда ты забыл конфигуровать и поймаешь себя на дедлоке при асинге способе, это уже страшновато.
7251.92 7262.76 "Игорь Лабутин" Да, а ещё надо помнить, что там бывают всякие интересные штуки типа async-локалов, которые правильно передаются внутрь асинков, но не наружу асинков.
7262.76 7263.92 "Игорь Лабутин" Короче, там много всего.
7263.92 7266.68 "Игорь Лабутин" В общем, тема интересная, тема глубокая.
7266.68 7276.88 "Игорь Лабутин" Я вот сейчас поглядел на вот ту самую статью Фауля, и она обновлена буквально 2 месяца назад, так что я думаю, что надо будет её тоже затронуть и посмотреть.
7276.88 7287.62 "Игорь Лабутин" Надо сказать, что вот те статьи, которые мы обсуждали в этом выпуске сейчас, они относительно старые и, возможно, в аналайзерах, в той табличке что-то уже поменялось.
7287.62 7289.04 "Игорь Лабутин" То есть нужно посмотреть.
7289.04 7290.04 "Игорь Лабутин" Аналайзеры тоже не стоят на месте.
7290.04 7295.52 "Игорь Лабутин" И может быть так, что какие-то из них стали более крутыми, ну или какие-то новые появились.
7295.52 7303.60 "Анатолий Кулаков" Я тебе даже более добавлю, не только новые появились, но и старые отвалились, потому что лидер всех рейтингов асинг-фикчер уже там 3 года как не обновляется.
7303.60 7306.76 "Анатолий Кулаков" Ну вот, поэтому… Другую сторону тоже работает.
7306.76 7315.60 "Игорь Лабутин" Следите, посмотрите, то есть может быть какие-то из них обрели наконец-таки полноценные фичи, может быть, Сунар Куб хорош, аналайзер от Сунар Куба.
7315.60 7321.48 "Игорь Лабутин" В общем, смотрите, а к фаулеру мы ещё точно вернёмся, там явно что-то новенькое появилось, надо будет посмотреть.
7321.48 7323.48 "Анатолий Кулаков" Да, да, так точно.
7323.48 7326.40 "Анатолий Кулаков" Ну что ж, на сегодня, наверное, хватит.
7326.40 7333.20 "Игорь Лабутин" Ну кратко о разном, давай пробежимся, у нас есть ещё такие кратенькие новости, сейчас я их найду и открою.
7333.20 7335.68 "Игорь Лабутин" Так, что у нас есть?
7335.68 7339.60 "Игорь Лабутин" А, во-первых, появилась штука под названием C# Repel.
7339.60 7365.08 "Игорь Лабутин" Это ещё один способ интерактивно выполнять C#, такой command-line стайл, причём очень прикольно, я себе поставил этот dotnet tool, заменяет в каком-то смысле command-line, и дальше вы там можете писать C#, причём у вас появляется такой интеллисенс, прям рисуется в консольке окошечками, дропдаунами, все дела, считается, ну короче, интересно для развлечений, если вам нужно что-то быстро рассчитать, может быть интересная штука, попробуйте.
7365.08 7367.72 "Игорь Лабутин" Мне в каком-то смысле понравилось.
7367.72 7374.24 "Игорь Лабутин" А MongoDB, ребята, выложили в public preview провайдер для Entity Framework.
7374.24 7394.36 "Игорь Лабутин" Я, честно говоря, не очень понимал, как Entity Framework совместим с Mongo, которая документная база данных, но вот уже сейчас обещано, что он поддерживает код first, то есть вы прям объявляете какие-то модели у себя в коде, и на основе этого провайдер будет понимать, как это всё сохранить в BD, ну очевидно в виде джойсона, наверное, но тем не менее.
7394.36 7435.60 "Игорь Лабутин" Есть базовая поддержка CRUD, поддержанные операторы над строковыми и числовыми типами, embedded documents, чтобы это не значило, я в Mongo особо не работаю, поэтому не знаю, linq, change tracking, и единственное, как бы специфические уши от Mongo, которые явно торчат в ваших объектах, это то, что у вас id объектов, то есть у вас в тех классах, которые вы мапите через Entity Framework, должно быть, ну я не уверен, на счёт «должно быть», но скорее всего точно, если вы сохраняете, то однозначно должно быть поле с типом object id, которое берётся как раз из этого монговского пакета драйвера, провайдера.
7435.60 7442.00 "Игорь Лабутин" Ну потому что чтобы у каждого документа есть уникальный id код в Mongo, и вот именно для этого.
7442.00 7452.36 "Анатолий Кулаков" Слушай, у нас же когда запускался Core, у него же был провайдер Mongo, как концепция того, что EF Core может работать и с объектно-ориентированными базами данных, поэтому что тебя удивляет?
7452.36 7456.80 "Анатолий Кулаков" И там, и там есть юзеры, и там, и там их можно достать, отсортировать, отфильтровать, какая разница?
7456.80 7459.24 "Анатолий Кулаков" На уровне EF, который сам по себе объектно-ориентированный.
7459.24 7462.72 "Игорь Лабутин" Ну, с другой стороны, он маппер, да, какая ему разница?
7462.72 7465.88 "Игорь Лабутин" Сложил просто не в набор табличек, а в JSON в один.
7465.88 7466.88 "Игорь Лабутин" Ну в принципе, да.
7466.88 7472.92 "Анатолий Кулаков" Поэтому да, мне кажется, что EF в принципе должен подойти для документа ориентированных баз, не хуже, чем для религиозных.
7472.92 7482.28 "Анатолий Кулаков" И концепция уже была, такой же драйвер Mongo, он же был там чуть ли не в первых версиях EF именно Core, и её потом выкинули, потому что то ли не допилили, то ли не удалили, то ли ещё что-то.
7482.28 7490.88 "Игорь Лабутин" Ну там будут, скорее всего, проблемы с реализацией полноценного всего LinkU, да, то есть какие-нибудь джойны и прочее, наверное, сложно сделать по разным
7490.88 7496.36 "Анатолий Кулаков" коллекциям. Ну, скорее всего, не сложнее, чем в обычной реализационной модели какая-то разница.
7496.36 7501.64 "Игорь Лабутин" Не, ну подожди, в реализационной модели ты джойнишь на уровне BD, а Mongo позволяет джойны прямо делать между коллекциями
7501.64 7504.04 "Анатолий Кулаков" разных документов? А, ты именно джойны хочешь?
7504.04 7507.04 "Анатолий Кулаков" Там есть aggregation framework, который, грубо говоря,
7507.04 7514.24 "Игорь Лабутин" можно… Не то, чтобы я хочу. Я говорю, что я с Mongo не работаю, поэтому нет, не хочу, но предполагаю, что с этим могут быть проблемы.
7514.24 7527.12 "Игорь Лабутин" Да, я знаю про aggregation framework, ну можно что-то вверх него сделать, ну слушай, даже хотя бы базовый крут, типа прочитать найти там, что-нибудь поменять и сохранить, уже, я думаю, что покроет, не знаю, 50% работы.
7527.12 7535.32 "Анатолий Кулаков" Слушай, мне кажется, как раз-таки да, что ты как бы, если базовые вещи покроешь, то тебе вот эти вот джойны, ну когда ты последний раз джойны писал?
7535.32 7536.32 "Анатолий Кулаков" Сегодня.
7536.32 7542.24 "Анатолий Кулаков" Не, на реализационной, конечно, ты писал, но я имею в виду, если это у тебя документная база данных, то кому не нужны там эти джойны?
7542.24 7550.56 "Игорь Лабутин" Ну я в моих текущих проектах, если это не реализационка, то это какой-нибудь Redis с key value и там вообще всё просто.
7550.56 7556.12 "Анатолий Кулаков" Ну вот представь, да, что когда ты последний раз в Redis и хотелось тебе заджойнить как бы два разных ключа,
7556.12 7559.40 "Игорь Лабутин" ну наверное, никогда. Ну оно и смысла не имеет, поэтому да.
7559.40 7566.72 "Анатолий Кулаков" Так а в Mongo все документы так проектируются, чтобы не имело смысла их джойнить, они внутри себя включают абсолютно всю информацию, которая нужна.
7566.72 7575.60 "Игорь Лабутин" Ну короче, посмотрим, пока я никаких вообще ни отзывов, ни фидбэков, ни статей ничего не видел, подождем, посмотрим, когда выйдет до реализа.
7575.60 7595.68 "Игорь Лабутин" И еще одну вещь, про которую хотелось бы сказать, Andrew Locke выпустил очередную статью обзора того, чего добавили в восьмой .NET, и там на самом деле добавили штуку, которую мне кажется, я вот что-то не помню, чтобы у нас где-то светилось в обзорах, то есть как-то мы мимо нее прошли или я может быть невнимательно где-то что-то читал или слушал.
7595.68 7598.88 "Игорь Лабутин" Называется Short Circuit Endpoint Routing.
7598.88 7602.44 "Игорь Лабутин" К вечеру я уже говорю, мне очень здорово.
7602.44 7607.04 "Игорь Лабутин" Смысл в следующем, что обычно у нас middleware выполняются каким образом?
7607.04 7621.40 "Игорь Лабутин" У нас есть routing middleware, который решает по маршруту, параметрам, глаголу, вербу, get, post и так далее, какой endpoint нужно будет выполнить, а потом у нас есть endpoint middleware, который собственно выполняет этот endpoint.
7621.40 7636.28 "Игорь Лабутин" А между ними есть куча других middleware, авторизация, force и вот это все, которые знают, какой маршрут будет выбран, на основании этого применяют свои различные политики и правила, но имеют возможность выполниться до того, как собственно выполнился endpoint.
7636.28 7651.64 "Игорь Лабутин" И начиная с восьмерка, с восьмого .NET, у нас есть возможность теперь после какого-нибудь app.map.get, если мы в minimal API варианте говорим, написать точку Short Circuit или даже прямо написать app.map.shortcircuit и указать маршрутик или амбуточку, которую нужно выполнить.
7651.64 7660.64 "Игорь Лабутин" И тогда, если так сделано, то для таких маршрутов раутинг middleware сразу выполнит ваш endpoint.
7660.64 7663.44 "Игорь Лабутин" Не пойдет ни в какие авторизации, course, никуда дальше.
7663.44 7666.24 "Игорь Лабутин" Раутинг, как только он понял, какой он выполняется, тут же его выполнит.
7666.24 7679.92 "Игорь Лабутин" Утверждается, что это, скажем так, полезно для всяких известных, так скажем, url-ов, типа там health-чеков, статических файлов и всего того, что мы обычно и так в самом начале вывешиваем.
7679.92 7691.12 "Игорь Лабутин" Плюс состоит в том, что мы точно не будем инсансировать там весь большой pipeline всех этих middleware, в смысле выполнять его и не тратить время.
7691.12 7718.16 "Игорь Лабутин" А во-вторых, штука эта довольно безопасна в том плане, что если раутинг middleware понимает, что ей нужно сделать, так сказать, быстрое выполнение, но при этом по своим внутренним методам, она понимает, что вообще-то этот запрос требует авторизации курсов или еще чего-нибудь, то она кинет exception, скажет, что у тебя в конфиге не то, типа посмотри внимательно, вроде endpoints авторизации, а ты что-то его сказал, это выполни прямо сейчас.
7718.16 7719.16 "Игорь Лабутин" Нехорошо.
7719.16 7727.60 "Игорь Лабутин" Короче, интересная может быть фича для каких-то таких типа health-чеков, может быть будет использоваться, посмотрим, для тех, кто minimal API использует.
7727.60 7729.88 "Игорь Лабутин" У меня все на этом.
7729.88 7737.68 "Анатолий Кулаков" Может мы ее поэтому и пропустили, что там minimal API, и мы его так подробно, ну по методам его разбирать не интересно было.
7737.68 7743.60 "Анатолий Кулаков" Так, а я нашел для себя, внезапно обнаружил, что Ник Чапсас еще и подкаст ведет.
7743.60 7746.60 "Анатолий Кулаков" Кстати, я даже не помню, мы рассказывали про Чапсаса или нет.
7746.60 7756.68 "Игорь Лабутин" Слушай, у нас были какие-то, мы упоминали его точно про в связи с каким, а, я знаю в связи с чем, мы его упоминали в связи с MockU и всей историей с лицензиями.
7756.68 7760.76 "Анатолий Кулаков" Слушай, ну мне кажется, как бы все-таки центр MockU далеко от Чапсаса.
7760.76 7770.76 "Игорь Лабутин" Ну не, мы точно, у него были какие-то видосики на эту тему, но, наверное, вот там мы его, наверное, упоминали, ну может быть еще где-то, но в среднем нет, мы его почти не пробовали.
7770.76 7788.24 "Анатолий Кулаков" Конечно, вот да, не лишним будет рассказать, что на Ютубе есть прекрасный автор, называется Ник Чапсас, он делает коротенькие видео, там буквально по 10 минуток, очень интересно рассказывает, очень много тем подымает, и мне больше всего нравится в том, что он успевает за эти 10 минут закупаться довольно-таки глубоко.
7788.24 7808.12 "Анатолий Кулаков" То есть его будет удобно смотреть и начинающим джунам, которые просто осваивают всю ту область, которая есть в дотнете, и даже может быть сеньорам, вот для себя там увидят пару интересных моментов, например, как внутри, это все реализовано, он часто рассказывает, как авторы, что на форумах отвечает, часто рассказывает, в общем, такие довольно интересные инсайтики получаются.
7808.12 7817.80 "Анатолий Кулаков" Делает это все весело, непринужденно, с клевыми примерами, обязательно любит бенчмарки дотнеты запускать, ну то есть все делает правильно, красиво, как и положено делать.
7817.80 7832.48 "Анатолий Кулаков" Еще из интересного, он не native speaker, у него есть немножко акцент, но мне кажется, вот те темы, которые он говорит, и тем языком, которым он рассказывает, довольно неплохо подходят для обучения, например, джунам английскому языку.
7832.48 7842.88 "Анатолий Кулаков" Если вам нужно просто практиковать слух и практиковать понимание, то вот такие 10-минутные видео должны зайти вот как такие уроки, плюс полезная практика по C# вообще замечательная.
7842.88 7851.52 "Анатолий Кулаков" Но разговор сейчас не про его видосики, хотя на видосики все прекрасны, зайдите и обязательно посмотрите, наверняка найдете какие-нибудь темы, которые вас заинтересуют.
7851.52 7860.88 "Анатолий Кулаков" Я тут недавно узнал, что он нам конкуренцию решил сделать, видишь, ему не дает покоя наша слава и всемирная популярность, поэтому у нас новый конкурент.
7860.88 7871.40 "Анатолий Кулаков" Он завел себе подкаст, и в подкаст пришли прям сразу с ходу так спинка в дверь Мэтт Торгессон, Стивен Тауп, Дэвид Фаулер, Дэмион Эдвардс, в общем, такие огромные пупки.
7871.40 7873.56 "Анатолий Кулаков" Там пару YouTube звезд он еще пригласил.
7873.56 7881.60 "Анатолий Кулаков" Болтают они не только о технических темах, там и о жизни болтают, и о конференциях болтают, и, естественно, о технологиях, о C#.
7881.60 7888.56 "Анатолий Кулаков" Стараются все-таки держать планку на IT, но в основном много воды, конечно, льется.
7888.56 7895.60 "Анатолий Кулаков" Интересные люди, интересные ведущие, хорошие темы поднимаются, поэтому обратите внимание, может быть, подкаст для вас будет полезен.
7895.60 7924.44 "Игорь Лабутин" Ну а может быть и наш подкаст чем-то вам полезен, и если полезно, мы сегодня посмотрели на восьмой релиз Кандидат 2, посмотрели, что старый Ньютонсон Джессон все еще подходит и вполне им можно пользоваться, а не бежать на новомодный систем текст Джессон, посмотрели, как улучшился перформанс в Splitcore восьмом и почему, подумали над тем, что же нам делать при отсутствии дискриминтед юнионов в C# и чем их можно было бы заменить.
7924.44 7930.64 "Игорь Лабутин" Вижу, Studio 17.8 Preview 3 совершенно проходной релиз, мне кажется, можно вообще не трогать пока.
7930.64 7948.12 "Игорь Лабутин" Мэтт Сторгерсон поделился своими, так скажем, не то чтобы планами, а мыслями на тему того, куда может быть подвинется C# в следующей версии, какие фичи мы можем в нем увидеть, подробно и детально обсудили ассинк код с Меллы, ну и узнали какие-то краткие новости во всяком разном вокруг.
7948.12 7970.80 "Анатолий Кулаков" Ну а на этом все, друзья, не забывайте шарить, репостить, рассказывайте о нас друзьям, ставьте там пятерочки, звездочки, лайки, где найдете, в каких социальных сетях слушаете, присылайте комментарии, может какие-то статьи интересные найдете, может какие-то анализаторы, наконец, хорошие, вы знаете об асинхронности, которой репродюсировать абсолютно все ошибки, которые только возможны.
7970.80 7979.20 "Анатолий Кулаков" В общем, пишите, пишите нам больше и чаще, мы все будем учитывать и вашу информацию будем тоже распространять и доносить окружающим.
7979.20 7982.44 "Анатолий Кулаков" Давай прощаться, всем до свидания, всем до новых встреч, всем пока.
7982.44 7989.40 "Игорь Лабутин" Да, всем пока, 81 выпуск получился, вероятно, длинным, я думаю, но надеюсь, что все еще полезным.
7989.40 7991.44 "Игорь Лабутин" А это потому, что давно не виделись.
7991.44 7997.44 "Игорь Лабутин" Да, будем… Ну мы всегда стараемся выходить примерно одинаково и регулярно, но получается как получается.
7997.44 8000.04 "Игорь Лабутин" Так что ждите следующих выпусков и всем пока.
