0.00 14.60 "Анатолий Кулаков" Здравствуйте дорогие друзья, в эфире Радио Дотнет выпуск номер 114 и в студии ее постоянный ведущий Анатолий Кулаков
14.60 16.92 "Игорь Лабутин" и Игорь Лабутин, всем привет.
16.92 39.48 "Анатолий Кулаков" А также с нами наши гордые друзья-помогаторов Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Пастарнаков Андрей, Дмитрий Сорокин, Дмитрий Павлов, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Лазарев Илья, Тимофей и Виталий.
39.48 51.12 "Анатолий Кулаков" Большое спасибо друзья, что поддерживаете нас, напоминаю, что это можно сделать на бусте, заходите и смотрите наши тарифы, они довольно все скромные, поэтому надеюсь вы тоже когда-нибудь присоединитесь к этой когорте.
51.12 58.84 "Игорь Лабутин" А нас по-прежнему поддерживает компания Altenar, разработчик масштабируемых и надежных решений для индустрии спортивных данных.
58.84 64.76 "Игорь Лабутин" Как вы догадываетесь, дотнеты C# используются в компании очень обширно, причем для высоконагруженных проектов.
64.76 72.04 "Игорь Лабутин" Кроме того, суть бизнеса заключается в том числе в обработке данных в практически реал тайме, что добавляет интереса.
72.04 83.68 "Игорь Лабутин" Компания Altenar гражданородная, поэтому вы как разработчик сможете использовать принятые во всем мире EDE и облака, а также прокачивать ваш английский для общения и может быть даже сможете продолжить карьеру в европейском офисе.
83.68 87.68 "Игорь Лабутин" Следите за новостями компании можно в ее телеграм-канале.
87.68 93.90 "Анатолий Кулаков" Ну что ж, мы наконец дождались превью третьего, наконец-то там появилось что-то такое, чего стоило ждать.
93.90 107.32 "Игорь Лабутин" Да, а превью вышло на самом деле практически примерно одновременно с записью прошлого подкаста, но мы уже не успевали его включить, поэтому включаем сейчас, хотя вы наверное уже две недели как пишете на новом дотнете, когда мы отстаем.
107.32 110.64 "Анатолий Кулаков" Да-да, все на превью резко приходят, да?
110.64 111.64 "Игорь Лабутин" Конечно, конечно.
111.64 116.16 "Игорь Лабутин" Ха, лузеры, они еще не успели обозреть, а мы уже код пишем на нем.
116.16 121.56 "Игорь Лабутин" Но тем не менее, давайте посмотрим, на чем вы пишете, тем более здесь есть интересные штуки, которые можно попробовать потрогать.
121.56 125.44 "Игорь Лабутин" Ну не в проди, наверное, конечно, но для себя, по крайней мере.
125.44 135.44 "Игорь Лабутин" Начнем мы традиционно с библиотек, ну в том порядке, в котором дотнет-команда обычно публикует все статьи про новинки, про превью дотнета.
135.44 139.64 "Игорь Лабутин" Во-первых, добавили, как они это называют, AOT-сейф.
139.64 152.28 "Игорь Лабутин" Я все чаще и чаще встречаю этот термин, конструктор для класса ValidationContext, и это казалось бы, ну зачем, нам это потребуется чуть позднее, объясню зачем это попозже для ValidationContext.
152.28 170.56 "Игорь Лабутин" Дальше в ActivitySources и в метрах добавили поддержку телеметрии схемы URLs, если вам это зачем-то надо, а дальше я вот, когда эту новость из себе писал, заметки по ним, я понял, что ML и AI добрался даже до новинок библиотек в библиотек.
170.56 197.52 "Игорь Лабутин" Хорошо, пока не рантайма, потому что следующая новость звучит так, что они добавили ByteLevelSupport в BPE-токенайзер, а BPE-токенайзер это штука, которая доступна в пакете Microsoft ML-токенайзер давным-давно, и вот теперь она умеет с ByteLevel потоком работать, то есть это что-то очень важное для ML, а также вторая новость, тут даже LightGVMTrainer в дотнете получил возможность включать детерминистик опций.
197.52 205.36 "Игорь Лабутин" Короче, даже тут AI, видимо, есть в каких-то KPI-ах, поэтому превью 3, видимо, эти KPI выполняет.
205.36 207.76 "Анатолий Кулаков" А, ну и TensorFactors тоже туда же.
207.76 209.96 "Анатолий Кулаков" Смотри, это все-таки нестандартная библиотека, да?
209.96 213.52 "Анатолий Кулаков" То есть это не прям чистый дотнет, это Microsoft ML.
213.52 220.72 "Игорь Лабутин" Да, да, это Microsoft ML, но почему он при этом в дотнет превью третьем, ну то есть как-то, видимо, надо было как-то протянуть за уши.
220.72 225.60 "Анатолий Кулаков" Чтобы хайповалась новость, конечно, чтобы поисковики по ML-ю лучше статью индексировали.
225.60 226.60 "Игорь Лабутин" Конечно.
226.60 227.60 "Игорь Лабутин" Вот.
227.60 234.32 "Игорь Лабутин" В библиотеках на этом все, по крайней мере в новостях все понятно, что там есть куча мелочей, как обычно, которые просто не попадают в главный обзор.
234.32 235.32 "Игорь Лабутин" Дальше про рантайм.
235.32 236.76 "Игорь Лабутин" Про рантайм интереснее.
236.76 258.40 "Игорь Лабутин" В прошлых превью у нас появилась штука под названием Stack Allocation, для небольших массивов с Value типами они могли больше не лоцироваться на куче, а лоцироваться на стеке вместо кучи, чтобы сэкономить, соответственно, облегчить жильдинг, облегчить коллектору.
258.40 264.48 "Игорь Лабутин" В этом превью тоже самое включили теперь для значимых референсных типов.
264.48 271.56 "Игорь Лабутин" Это означает, что если вы, например, объявили какой-нибудь массив строчек у себя, константных, то он небольшой при этом.
271.56 276.12 "Игорь Лабутин" Что такое небольшой в новости умалчивается, надо пол-реквест смотреть.
276.12 288.60 "Игорь Лабутин" Но такой небольшой массив, он, скорее всего, уже не будет лоцирован на хипе, а спокойненько будет размещен в стеке и не будет никак нагружать гарбач коллектор.
288.60 289.60 "Игорь Лабутин" Шикарно стало.
289.60 295.24 "Игорь Лабутин" И вторая новость рантайма, это больше про JIT, ну, собственно, больше про JIT.
295.24 298.92 "Игорь Лабутин" Прошлое тоже про JIT, на самом деле, конечно, в каком-то смысле.
298.92 301.44 "Игорь Лабутин" А это точно про JIT, это про улучшенный код layout.
301.44 304.64 "Игорь Лабутин" Мне кажется, я про такое уже как-то рассказывал, но смысл в чем?
304.64 308.92 "Игорь Лабутин" Когда JIT компилирует ваш код в Intermediate Language, он лежит.
308.92 317.66 "Игорь Лабутин" Ну, не то чтобы сильно отличающийся от той последовательности и той структуры, которую задали вы, когда вы писали на C# или любом другом дотнет-языке.
317.66 329.28 "Игорь Лабутин" А вот когда JIT его собирает в уже выполнимый код на низком уровне, то там есть довольно много всяких разных оптимизаций.
329.28 346.24 "Игорь Лабутин" И для того, чтобы код работал побыстрее, с одной стороны, если, допустим, у вас есть два логических блока, один из которых выполняется после другого, логично их положить, собственно, в том же порядке в памяти, чтобы там предсказание, вот это все, последовательность теней резко ускоряла работу программы.
346.24 370.32 "Игорь Лабутин" С другой стороны, а ну и соответственно не нужны будут всякие джампы, а вы просто последовательно будете идти во блокам, с другой стороны, если у вас есть какие-то кусочки внутри функции, которые часто выполняются, то логично эти блоки тоже класть рядом между собой, потому что это значит, что вы, может быть, выиграете из-за кеширования данных в процессоре.
370.32 381.72 "Игорь Лабутин" И проблема в том, что вот эти две цели, они иногда, вообще говоря, ортогональны, то есть они независимы, а им могут даже мешаться друг с другом.
381.72 401.92 "Игорь Лабутин" Соответственно, JIT раньше что делал, JIT раньше использовал алгоритм, то, что они называют reverse post-order, то есть они брали программу, брали ее flow-graph и пытались трансформировать так, чтобы удовлетворить обе этих цели, дальше там понятно, что куча heuristic на тему того, какую из целей лучше удовлетворять и что будет быстрее.
401.92 443.52 "Игорь Лабутин" А теперь он делает, JIT делает по-другому, JIT делает работу над этим графом, по сути, решая в каком-то смысле проблему камевейджора, ну, как бы задача камевейджора JIT решать, вообще говоря, времени сильно нету, поэтому они используют то, что они называют 3-opt heuristic для поиска, соответственно, почти оптимального вот этого самого пути камевейджора, то есть они такую сложную математическую задачку пытаются приблизить и решать каким-то более оптимальным путем, получая тем самым гораздо более оптимальное расположение этих самых блоков.
443.52 445.60 "Игорь Лабутин" Что такое оптимальность?
445.60 477.56 "Игорь Лабутин" Оптимальность, это означает, почему все это сводится к задачке камевейджора, они пытаются найти такое расположение нод в графе, вот в этом flow-графе расположение блоков так, чтобы путь от начала функции до ее конца был бы максимально коротким, по какому бы пути не пошли, и, соответственно, это получается более плотная упаковка всяких ход-путей и так далее, ну и, в общем, поменьше бранчей и все такое прочее.
477.56 487.28 "Игорь Лабутин" В общем, вокруг этого, видим, там есть какая-то суровая или не очень суровая математика, которая экспериментально показывает, что такой алгоритм лучше, быстрее и так далее.
487.28 500.28 "Игорь Лабутин" Самое главное, генерирует более оптимальный код, но тем он быстрее нам сейчас особо не нужно, с учетом, что у нас есть SHIELD 2, который может спокойно там багграундить сколько угодно, компилировать и потом подменить функцию.
500.28 501.28 "Игорь Лабутин" Дальше SDK.
501.28 503.84 "Игорь Лабутин" В SDK, в CLI есть некоторое количество изменений.
503.84 528.00 "Игорь Лабутин" Во-первых, если вы когда-либо пользовались ключиком --interactive, это ключик, который включает или выключает необходимость в интерактивном режиме, то есть, если, например, вам зачем-то нужен будет пароль ввести, а вы его запустили с ключиком, что мы работаем не в интерактивном режиме, например, SIA, это команда, которая захочет пароль, но она понимает, что она не в интерактивном режиме, она просто зафейлится, с вами нет пароля.
528.00 535.92 "Игорь Лабутин" Они добавили некоторое количество евристик, соответственно, теперь скорее всего этот ключик нужно будет почти никогда не использовать.
535.92 559.64 "Игорь Лабутин" То есть, если они понимают, что мы не в контексте SIA, того, который им известно, вероятно, как-то по переменным окружениям они это определяют, что нас не перенаправили точнее аутпут наш и так далее, и поэтому, в общем, interactive, теперь этот ключик должен быть почти не нужен, CLI дотонетный стал сам по себе умнее.
559.64 566.50 "Игорь Лабутин" Дальше, если вы пользуетесь дотонет вот этими тулзой в коммодлайне, вам будет, наверное, интересны комплешины.
566.50 577.72 "Игорь Лабутин" Раньше, насколько я помню, был какой-то монструозный PowerShell скриптик, который, или что-то около того, для PowerShell, по крайней мере, который позволял эти комплешины включить.
577.72 587.56 "Игорь Лабутин" Теперь есть встроенная команда, называется dotnet completion generate, и дальше нужно указать какой-нибудь shell, и она для него сгенерит все нужные конфиги для того, чтобы работал комплешин.
587.56 606.68 "Игорь Лабутин" Сейчас поддержаны bash, phish, nushell, powershell и zsh, и для разных них немножко по-разному работает, где-то она обращается к дотнету для, к коммодлайну дотнета для того, чтобы сгенерить нужные подсказки, а где-то это все генерируется статически заранее на основе тех ворклоудов, которые у вас стоят.
606.68 618.12 "Игорь Лабутин" И последнее изменение в части CLI, это, ну хотя непонятно при чем здесь CLI, но почему-то запихнуто в CLI, это про то, что теперь можно ссылаться на локальную инсталляцию SDK.
618.12 631.44 "Игорь Лабутин" То есть напомню, что SDK можно поставить прям официальным инсталлером, а можно тупо распаковать zip архивчик или там собрать себе локально какой-нибудь из исходников, и как на него ссылаться из какого-то дотнетного проекта, вообще говоря, было не очень понятно.
631.44 632.44 "Игорь Лабутин" Теперь есть.
632.44 639.24 "Игорь Лабутин" Теперь вы можете в global.json файлике, есть такая секция SDK, и в ней есть два новых параметра.
639.24 650.88 "Игорь Лабутин" Один называется path, туда вы перечисляете просто через запятую, это JSON массив, строчек, где каждая строчка это просто путь к, соответственно, на месту, где лежит SDK.
650.88 658.00 "Игорь Лабутин" И второй параметр это error message, это то, что нужно вывести в консоль, если вдруг нигде не нашлось подходящего SDK.
658.00 667.92 "Игорь Лабутин" При этом в путях поддерживается специальный путь под названием $host$, который означает «возьмите тот SDK, из которого запустили дотнет.ткз, который сейчас работает».
667.92 672.16 "Игорь Лабутин" Так что прям удобно можно теперь локальные SDK гонять.
672.16 687.96 "Игорь Лабутин" В контейнерах не очень много изменений, теперь не надо ставить enable sdk container support для того, чтобы консольное приложение собирать в контейнеры, и теперь можно выбрать явно контейнер-имидж формата, он умеет либо докер, либо OCI.
687.96 696.44 "Игорь Лабутин" Соответственно, раньше выбирался, несмотря на либо мультиархитектурность, либо на базовый образ, теперь можно явно выбрать какой.
696.44 701.04 "Игорь Лабутин" Ну и для тестинга в dotnet tester поддерживает microsoft testing platform.
701.04 704.60 "Игорь Лабутин" В общем-то, в SDK части всё.
704.60 710.84 "Игорь Лабутин" Дальше идёт часть C#, и там есть две интересные новинки.
710.84 713.00 "Игорь Лабутин" Начнём с extension members.
713.00 721.80 "Игорь Лабутин" Теперь вы можете писать экстенджины на статические методы, property и статические property.
721.80 743.08 "Игорь Лабутин" Для обычных методов расширения, вы помните, что мы пишем, объявляем метод в отдельном классе, в нём объявляем параметр, и первый параметр, у которого есть специальный модификатор as this, он того типа, для которого вы, собственно, расширяете, и таким образом вы можете обращаться к объекту этого типа внутри вашего метода расширения.
743.08 753.52 "Игорь Лабутин" Но проблема с тем состоит в том, что в properties у вас же нет такого, некуда такой тип запихнуть или параметр или что-то.
753.52 761.60 "Игорь Лабутин" То есть вам нужен объект, у которого надо потрогать property, а его как бы нету, непонятно, что с ним делать.
761.60 769.24 "Игорь Лабутин" Поэтому для того чтобы решить эту проблему, в C# 14 появляется штука под названием extension blocks.
769.24 774.92 "Игорь Лабутин" То есть для того, чтобы их использовать, нужно сделать следующее.
774.92 786.36 "Игорь Лабутин" Вы точно так же пишете статический класс, в котором будут объявляться ваши экстенджины, и вместо того, чтобы писать метод, вы пишете ключевое слово extension в качестве аргумента этого экстенджина.
786.36 793.40 "Игорь Лабутин" Вы пишете тип, для которого вы расширяете, и название как бы параметра, то, перед чем вы раньше писали this.
793.40 795.32 "Игорь Лабутин" Здесь this уже писать не надо.
795.32 798.56 "Игорь Лабутин" Дальше открываете фигурную скобку, и внутри пишете все, что хотите.
798.56 803.72 "Игорь Лабутин" Хотите, пишите методы, в принципе, это альтернативный синтаксис для методов в том числе.
803.72 809.00 "Игорь Лабутин" Там уже тоже не нужен никакого this параметра, можно писать property.
809.00 811.80 "Игорь Лабутин" Подозреваю, что когда-нибудь сюда какие-нибудь конструкторы тоже заедут.
811.80 822.96 "Игорь Лабутин" И вот этот параметр, который объявлен после ключевого слова extension и типа, он, соответственно, является как будто бы объектом того типа, который вы расширяете.
822.96 825.96 "Игорь Лабутин" Поддерживаются дженерики, в общем, все как надо.
825.96 847.80 "Игорь Лабутин" Если вы хотите написать статический метод расширения, то у статического метода расширения, понятное дело, нет никакого объекта инстанса, поэтому для статических методов и статических свойств вы просто пишете extension, и в круглую скобочку указываете только тип, уже без каких либо названий параметров, так скажем.
847.80 854.80 "Игорь Лабутин" Дальше снова фигурные скобки, внутри пишите уже статические методы, естественно, ничего из типа, кроме самого типа вам будет недоступно.
854.80 863.20 "Игорь Лабутин" Вот такая вот штука, можно теперь через эти экстенджины писать и методы, и property, и статические методы, и статические property.
863.20 868.00 "Игорь Лабутин" Ну для статических вы обязаны их использовать и для property, а методы, ну как хотите.
868.00 885.56 "Анатолий Кулаков" Мне кажется здесь самое место рассказать о минусах этого подхода, я не могу молчать просто, потому что мы везде как бы избавляемся от этих вложенных скопов, на примере namespaces, а здесь нас заставляют как раз наоборот, сделать новый скоп, в который мы начинаем писать все эти extension методы.
885.56 893.24 "Анатолий Кулаков" То есть у нас мало того, что public класс скоп был, то теперь еще добавляется extension скоп.
893.24 915.04 "Анатолий Кулаков" Казалось бы, очень бы логичным было совместить декларацию класса и extension скоп, ну потому что все когда мы пишем extension методы, вот эта глупая декларация класса, public, static, class, extension, вот она нафиг никому не нужна, мы никогда по имени к этому классу не обращаемся, то есть оно совсем бесполезное, и вдруг тут нам необходим какой-то новый extension скоп.
915.04 930.04 "Анатолий Кулаков" Очень бы логично казалось взять бесполезную часть и совместить ее с полезной, ну то есть могли бы тоже самое extension слова ключевое внести вместо класса, например public extension class какой-нибудь ilist от t, и внутри пошли бы его расширять.
930.04 931.04 "Анатолий Кулаков" Вот что-нибудь такое.
931.04 941.56 "Анатолий Кулаков" Да, понятно, там есть какие-то небольшие конфликты с синтаксисом, но, мне кажется, они тут вполне все решаемы бы были, и получилось бы не так криво и не так многословно.
941.56 943.56 "Анатолий Кулаков" В общем, как тебе синтаксис?
943.56 961.64 "Игорь Лабутин" Слушай, я не очень люблю, да, такую лишнюю вложность, так скажу, но я понимаю, что если вынести это дело на уровень определения класса, то получится, что для пропертей, то есть с методами проблем нету, со статическими методами и статическими пропертями проблем нету.
961.64 965.84 "Игорь Лабутин" Я так понимаю, что основная проблема — это с инстанциальными пропертями.
965.84 974.04 "Игорь Лабутин" Нам где-то нужно для них определить вот это самое несчастное имя параметра, которое будет как бы this, да, которое будет… Ну, у нас же есть теперь
974.04 983.44 "Анатолий Кулаков" primary конструктор, то есть ты, грубо говоря, в декларации класса прямо можешь поставить те же самые круглые скобочки и там написать, а не numerable source, и вот тебе имя и тип всё есть.
983.44 991.68 "Игорь Лабутин" Да, а потом ты внутри определяешь статический метод, в котором тебе должно быть нельзя использовать эту, ну, короче…
991.68 998.56 "Анатолий Кулаков" Ну хорошо, не используй, компилятор подскажет, что нельзя в статическом методе использовать source, как он сейчас подсказывает, что нельзя this использовать в статическом методе.
998.56 1016.76 "Игорь Лабутин" Да, если ты помнишь, мне кажется, вот когда они первый раз анонсировали, мы же про экстенджены говорили, у них же была какая-то попытка к прошлому C# сделать экстенджены, или уже к позапрошлому… Помнишь, там было типа экстенджен… У меня почему-то интернал-экстернал, но мне кажется, там какие-то другие были слова про экстенджены.
1016.76 1020.96 "Игорь Лабутин" Короче, они же как раз были на уровне декларации классов, и что-то там пошло не так.
1020.96 1026.96 "Анатолий Кулаков" Да, выглядели они как-то более прилично, там всё равно ещё были вопросы, но не до такой степени, как сейчас.
1026.96 1030.24 "Анатолий Кулаков" И вот мне очень странно, что они сделали хуже, чем было.
1030.24 1034.96 "Анатолий Кулаков" То есть там действительно должно было что-то критичное быть, но я пока не смог понять, что именно.
1034.96 1042.80 "Игорь Лабутин" Ну, я не читал прям все истории обсуждения, там огромные гитхаловские иши, и надо в полуреквестах всё это почитать, в комментариях иногда.
1042.80 1051.40 "Игорь Лабутин" Немножко сейчас не до того, но да, я думаю, что найдутся, найдутся кто-нибудь, кто напишет какие-нибудь хорошие статьи в итоге, когда этот дизайн устаканится.
1051.40 1055.32 "Игорь Лабутин" Мы не забываем, не надо забывать, что это всё превью, и к следующему превью всё может поменяться.
1055.32 1061.00 "Анатолий Кулаков" Да, так что совет Игоря – это тащить всё в прот и пробовать, не воспринимать буквально.
1061.00 1063.68 "Игорь Лабутин" Да, просто тащить в прот, не пробуя.
1063.68 1100.76 "Игорь Лабутин" Вот, ладно, второе нововведение C#, которое мне кажется с одной стороны оно попроще и имеет больше шансов дожить до релиза, оно такое непонятное, я видел уже несколько комментариев на предмет, что это такое вообще, называется Null Conditional Assignment, штука заключается в следующем, то есть представьте что у вас есть объект, допустим, кастомер, у него есть поле age, и вы пишете какой-нибудь метод, который апдейтит вот этого кастомера, то есть проставляет ему какой-нибудь новый возраст age, если только кастомер не null.
1100.76 1105.00 "Игорь Лабутин" Ну, видимо, по какой-то причине вам может прийти null-овый кастомер.
1105.00 1114.16 "Игорь Лабутин" Раньше вы бы такой код написали, видно там, и в customer не равно null, фигурная скобка открылась, customer.age присвоить, соответственно, new age.
1114.16 1135.64 "Игорь Лабутин" Вместо всего этого теперь вы можете писать customer вопрос.age = new age, то есть так же, как мы обращаемся к пропертиям с точки зрения чтения их, с этим самым оператором, если хотя бы одно из полей в цепочке этих операторов является null, результат всего выражения будет null.
1135.64 1145.32 "Игорь Лабутин" Здесь, соответственно, наоборот, если вы эту конструкцию встречаете слева, то если какое-то из полей null, то результат присваивания ничего.
1145.32 1147.56 "Игорь Лабутин" Оно просто не выполняется.
1147.56 1148.56 "Игорь Лабутин" Часто так нужно было?
1148.56 1151.72 "Игорь Лабутин" Я не могу даже придумать кейса, когда мне такое было нужно.
1151.72 1166.76 "Игорь Лабутин" То есть я понимаю, наверное, это, наверное, знаешь, вот конструкция вида, ну, какой-нибудь такой fire and forget, да, то есть типа вот если ко мне прислали какой-то объект, ну давайте я в него что-нибудь поставлю, а если не прислали, да и фиг с ним, не буду ставить.
1166.76 1171.32 "Игорь Лабутин" Ну, вообще как-то прям непонятно, не понятно, зачем это надо
1171.32 1172.32 "Анатолий Кулаков" было.
1172.32 1178.44 "Анатолий Кулаков" Ну да, что-то такое очень расслабленное, очень из мира динамических языков, типа есть и хорошо, нет и плохо.
1178.44 1179.88 "Анатолий Кулаков" Обычно так не пишут, да.
1179.88 1183.08 "Анатолий Кулаков" Я помню, что у меня было таких пару моментов за всю мою практику.
1183.08 1187.36 "Анатолий Кулаков" В общем, я не обломался, как Таиф написал, но действительно кейс очень редкий.
1187.36 1192.04 "Игорь Лабутин" Ага, то есть, в общем, непонятно, непонятно.
1192.04 1197.44 "Игорь Лабутин" То есть надо будет потом почитать proposal, зачем вообще это самое.
1197.44 1200.88 "Игорь Лабутин" Вот я сейчас открыл по пути.
1200.88 1203.92 "Игорь Лабутин" В motivation написано прекрасно.
1203.92 1208.84 "Игорь Лабутин" A variety of motivating use cases can be found in the champion tissue, точка.
1208.84 1210.20 "Игорь Лабутин" Все, смотрите туда.
1210.20 1229.08 "Игорь Лабутин" Но есть 2 major motivation, одна это странная, звучит она как parity between properties and set methods, не очень понимаю, о какой parity идет речь, а вторая это прям major motivation attaching event handlers in UI code.
1229.08 1232.92 "Игорь Лабутин" Я так понимаю, что это чисто ради UI какой-то штуки, как
1232.92 1234.96 "Анатолий Кулаков" чуть поудобнее работать с ивентами.
1234.96 1237.84 "Анатолий Кулаков" Совсем чисто UI, ну, наверное, там такое часто нужно.
1237.84 1241.84 "Игорь Лабутин" Типа, если ивент не null, что-нибудь с ним сделай, подпишись на него.
1241.84 1245.16 "Игорь Лабутин" Знаешь, в таком духе, вот как бы, там же плюс-равно этих много.
1245.16 1252.16 "Игорь Лабутин" Мне интересно, кстати, в случае, если левая сторона null, выполняется ли evaluation правой, если туда присвоишь результат функции.
1252.16 1255.32 "Игорь Лабутин" Вот вызов функции будет произведен или нет, надо читать спеку детально.
1255.32 1256.32 "Анатолий Кулаков" Я вот не знаю.
1256.32 1259.24 "Анатолий Кулаков" Ну, наверное, там обычный if стоит, поэтому, скорее всего, идти не должен.
1259.24 1260.24 "Игорь Лабутин" Идти не должен.
1260.24 1261.24 "Игорь Лабутин" Да.
1261.24 1262.24 "Игорь Лабутин" Ну, в общем, интересно.
1262.24 1263.24 "Игорь Лабутин" Ну, ладно.
1263.24 1265.84 "Игорь Лабутин" Это, в общем, пока все, что в C# появилось.
1265.84 1266.84 "Игорь Лабутин" Пойдем дальше.
1266.84 1267.84 "Игорь Лабутин" sp.net core.
1267.84 1285.56 "Игорь Лабутин" В sp.net core довольно всякие нишевые мелкие штуки, то есть в Razor какие-то небольшие изменения, в Blazor можно теперь обращаться к этим ассетам, которые с фингерпринтом, то есть те, которые имеют в своем пути, в своем названии хэш после сборки.
1285.56 1287.84 "Игорь Лабутин" Понятно, что к ним надо как-то из кода обращаться.
1287.84 1290.32 "Игорь Лабутин" Там есть специальный синтекс, чтобы к ним обращаться.
1290.32 1300.20 "Игорь Лабутин" HttpClient теперь включен по дефолту, имеет включенный по дефолту ResponseStreaming в WebAssembly.
1300.20 1305.92 "Игорь Лабутин" Переименовали какой-то ContextSwitch, а вот, ValidationSupportMinimalAPI.
1305.92 1308.00 "Игорь Лабутин" Вот это, наверное, может быть интересно.
1308.00 1312.76 "Игорь Лабутин" То есть теперь вы можете написать builder.services.addValidation.
1312.76 1322.40 "Игорь Лабутин" Кроме того, в PropertyGroup нужно обязательно добавить свойство InterceptorsNamespaces почему-то, с нужным числом, ну допустим.
1322.40 1328.96 "Игорь Лабутин" Если вы туда добавляете namespace, возможно это потом уберется и будет как-то само работать, но пока надо.
1328.96 1342.28 "Игорь Лабутин" И после этого у вас появляется source-генерионный код, который будет валидировать все ваши модельки, которые используются в MinimalAPI с помощью стандартных, понятно, этих интерфейсов.
1342.28 1348.80 "Игорь Лабутин" Ну можно как обычно, короче, стандартные всякие интерфейсы используют для написания валидаторов, вот это все будет работать в MinimalAPI нормально теперь.
1348.80 1359.32 "Игорь Лабутин" Вот, видимо, для этого как раз всякие ValidationContexts.outFriendly, то с чего я начал, и нужны были, чтобы они стали нормально source-генериться и в MinimalAPI использоваться.
1359.32 1370.12 "Игорь Лабутин" OpenAPI по дефолту теперь поддержан, включен по дефолту на ExpandedCore.webAPI.native.out шаблоне.
1370.12 1395.80 "Игорь Лабутин" Ну и поддержанный server-side-event в MinimalAPI, ну не только в MinimalAPI, теперь есть в классе TypedResults, напомню, что это такой класс, который позволяет вам возвращать типизированные результаты из контроллеров или MinimalAPI, есть теперь метод, который называется server-side-sendEvents, который принимает IosyncEnumerable ивентов, ну и, соответственно, их засылает на клиента.
1395.80 1418.08 "Игорь Лабутин" Вот, и здесь как раз отличный пример, наверное, один из немногих, где я увидел в примерах Microsoft использование локальных функций, то есть вы пишете app.mapget, ну как обычно в MinimalAPI указываете путь к вашему endpoint, а дальше вам нужно передать лямбду, которая должна выполняться.
1418.08 1437.84 "Игорь Лабутин" Но из лямбды нужно вернуть server-side-event, тот самый, к которому передать IosyncEnumerable, и чтобы это сделать, внутри этой лямбды объявляется локальная osync-функция, которая возвращает IosyncEnumerable, и единственная строчка в самой лямбде — это return TypedResult.server-side-events от вызова вот этой локальной функции.
1437.84 1442.64 "Игорь Лабутин" Короче, во, я наконец увидел какой-то хороший пример использования локальных функций.
1442.64 1475.32 "Игорь Лабутин" Ну вот и все в этом на SPNetCore, больше никаких новостей по этой части нет, и в Core тоже очень мало, там что-то про Azure Cosmos DB for NoSQL с моделями чуть-чуть улучшилось, и какие-то мелкие улучшения, в UI-ной части вообще тишина и спокойствие, кроме Maui, которая там добавила немножко пропертий, какие-то API-ки задеприкейтила, добавила поддержку в Full Screen Video Playback, но только на Android, ну и как обычный Performance Improvements, правда в этот раз с бенчмарками.
1475.32 1485.28 "Игорь Лабутин" Они там сказали, что вот мы в 5 раз улучшили пропертий маппера, мы в 2 раза ускорили Collection View, и где-то в 2 раза ускорили рендеринг в лейблах формата Stroke на винде.
1485.28 1488.88 "Игорь Лабутин" Ну, наверное, не очень узкий кейс, но нормально.
1488.88 1491.84 "Игорь Лабутин" Вот, примерно, такие новости у нас про превью.
1491.84 1505.80 "Анатолий Кулаков" Ну, нормально, нормально, хотя бы начали какие-то минимы превью появляться, надеюсь, они все-таки синтез с экстеншенами изменят и прислушаются к комментариям, или подумают что-нибудь еще поумнее.
1505.80 1506.80 "Анатолий Кулаков" Погнали дальше.
1506.80 1516.60 "Анатолий Кулаков" У Андрю Лока вышла интересная статья, в которой он на практике показывает, каким образом можно добавить свой кастомный Lifetime к DIY-контейнеру.
1516.60 1524.46 "Анатолий Кулаков" Не то, чтобы каждый день мы этим занимаемся, но чисто практической точки зрения довольно интересная и забавная статья получилась.
1524.46 1526.12 "Анатолий Кулаков" Поэтому давайте ее подробнее разберем.
1526.12 1535.88 "Анатолий Кулаков" Называется она как раз-таки "Проходя вне стандартных Lifetimes типа Singleton, Scoped and Transient".
1535.88 1538.04 "Анатолий Кулаков" С чего все началось?
1538.04 1553.92 "Анатолий Кулаков" Началось все с того, что он подслушал в одном из подкастов, наверное, не в нашем все-таки, диалоги специалистов, которые мечтали, фантазировали о том, какие бы новые Lifetime Scope они хотели бы видеть в стандартном DIY-контейнере и зачем им это нужно.
1553.92 1557.32 "Анатолий Кулаков" И он так загорелся мыслью, что решил их реализовать.
1557.32 1562.40 "Анатолий Кулаков" Вот мы с вами как раз на одной из такой реализации и сегодня остановимся.
1562.40 1573.72 "Анатолий Кулаков" Прежде чем рассматривать реализацию какого-то нового Lifetime Scope, давайте рассмотрим, какие еще, то есть не какие еще, а какие вообще стандартные Lifetime есть у нас в микрософтовском DIY-контейнере.
1573.72 1583.28 "Анатолий Кулаков" Ну, в принципе, три стандартных Lifetime, которые не только наверное в микрософтовском, а если вы посмотрите, то в любом контейнере минимум они втроем будут.
1583.28 1587.28 "Анатолий Кулаков" Все остальное это какие-то навороты, но обычно хватает именно этих троих.
1587.28 1589.80 "Анатолий Кулаков" Это Transient, Singleton и Scoped.
1589.80 1602.20 "Анатолий Кулаков" И как раз они нужны для того, чтобы контролировать, когда и как порождаются новые экземпляры ваших сервисов, которые были зарегистрированы с помощью этих Lifetimes.
1602.20 1604.24 "Анатолий Кулаков" Кратенько пробежимся по их основным назначениям.
1604.24 1607.32 "Анатолий Кулаков" Ну, самый простой, самый понятный и самый первый это Transient.
1607.32 1614.48 "Анатолий Кулаков" Понять его очень легко, потому что он полностью соответствует семантике языка C#, то есть полностью соответствует оператору New.
1614.48 1625.88 "Анатолий Кулаков" То есть, когда у вас сервис зарегистрирован с помощью Scope Transient, вы можете это представить, что каждый раз, когда вам необходим этот сервис, просто-напросто вызывается оператор New.
1625.88 1626.88 "Анатолий Кулаков" Вот и все.
1626.88 1632.24 "Анатолий Кулаков" И каждый раз вы получаете новый инстанс, потому что новый оператор New возвращает вам новый инстанс.
1632.24 1637.16 "Анатолий Кулаков" Все довольно просто и понятно в пределах языка программирования C#.
1637.16 1640.96 "Анатолий Кулаков" Второй по сложности метод это Singleton.
1640.96 1654.36 "Анатолий Кулаков" В принципе, тоже довольно понятна его семантика в терминах языка, то есть вы заводите какое-нибудь статическое свойство или статическое поле, и в это статическое поле просто один и раз создаете инстанс какого-то объекта.
1654.36 1655.36 "Анатолий Кулаков" И все.
1655.36 1657.78 "Анатолий Кулаков" И вот у вас получается классический Singleton.
1657.78 1664.44 "Анатолий Кулаков" Мы сейчас опускаем там тему каких-то concurrency доступов, кросс-тредового доступа и так далее.
1664.44 1666.88 "Анатолий Кулаков" В общем, мы сейчас обсуждаем просто концепцию.
1666.88 1669.28 "Анатолий Кулаков" В концепции это обычное статическое поле.
1669.28 1671.80 "Анатолий Кулаков" То есть, какое у него поведение?
1671.80 1672.80 "Анатолий Кулаков" Поведение у него следующее.
1672.80 1675.00 "Анатолий Кулаков" Оно создается только один, единственный runs.
1675.00 1685.88 "Анатолий Кулаков" Максимум в приложении может быть только один инстанс этого Singleton, этого сервиса, который будет возвращаться всегда и переиспользоваться всегда, когда он будет кому-то необходим.
1685.88 1703.40 "Анатолий Кулаков" Более того, чтобы, может быть, лучше представить, как работает Singleton, вы при регистрации сервиса можете передать непосредственно уже созданный инстанс того класса, который вы хотите зарегистрировать, и везде теперь в вашем приложении из вашего контейнера будет использоваться именно этот инстанс.
1703.40 1713.64 "Анатолий Кулаков" То есть, контейнер даже не будет порождать какой-то новый экземпляр, потому что у него уже есть этот один-единственный, который никогда не повторяется и который всегда присутствует в вашем приложении.
1713.64 1722.68 "Анатолий Кулаков" И третий, наверное, самый загадочный, самый сложно понимаемый Lifetime – это как раз Scoped.
1722.68 1728.64 "Анатолий Кулаков" Самый сложно понимаемый, наверное, потому что у него нет какой-то прямой концепции в языке, в отличие от предыдущих двух.
1728.64 1734.68 "Анатолий Кулаков" Но, в принципе, понять его тоже не мудрено, потому что у него есть концепция во фреймворке.
1734.68 1735.88 "Анатолий Кулаков" Это WebRequest.
1735.88 1744.16 "Анатолий Кулаков" Вот WebRequest – это не то, что типичный Scope, это запрос, который порождает Scope.
1744.16 1750.28 "Анатолий Кулаков" То есть, вы можете примерно относиться к Scope, как к каким-то классам, порождаемых внутри WebRequest.
1750.28 1754.76 "Анатолий Кулаков" Давайте поподробнее разберемся с его свойствами, и, может быть, тогда вам станет более понятно.
1754.76 1763.68 "Анатолий Кулаков" В рамках Scope, одного Scope, всегда возвращается один и тот же экземпляр зарегистрированного сервиса.
1763.68 1772.16 "Анатолий Кулаков" Но как только у нас создается другой Scope, там уже начинает возвращаться другой экземпляр сервиса, которого мы зарегистрировали.
1772.16 1777.00 "Анатолий Кулаков" То есть, в рамках Scope они всегда одинаковые, но в рамках разных Scope эти инстанции всегда разные.
1777.00 1788.56 "Анатолий Кулаков" Как я уже сказал, ISPnetCore автоматически регистрирует, то есть, начинает Scope, когда начинается реквест, и заканчивает Scoped, когда реквест заканчивается.
1788.56 1798.48 "Анатолий Кулаков" То есть, внутри одного реквеста к Scoped-сервисам вы можете обращаться к одному и тому же инстанцу, но если реквест уже пошел какой-то другой выполняться, то там этот инстанц уже будет другой.
1798.48 1804.88 "Анатолий Кулаков" Для того, чтобы начать Scope вручную, у сервиса-провайдера можно вызвать специальный метод, который называется CreateScope.
1804.88 1810.92 "Анатолий Кулаков" Он возвращает DisposableScope, и в тот момент, когда его задиспоузили, соответственно, он заканчивается.
1810.92 1822.52 "Анатолий Кулаков" Начало и конец Scope – это довольно важные вещи, потому что именно начало определяет, когда у вас начинает возвращаться один и тот же инстанц, а Dispose определяет, когда заканчивается возвращаться один и тот же инстанц.
1822.52 1832.44 "Анатолий Кулаков" Ну и плюс Discope, Scope еще вызывает метод Dispose у всех сервисов, которые жили в рамках этого Scope, были созданы и возвращались.
1832.44 1835.60 "Анатолий Кулаков" То есть, это тоже важный такой ключевой момент, когда они все исчезают.
1835.60 1847.58 "Анатолий Кулаков" Вот когда реквест начинается, открывается Scope, и внутри него начинает создаваться куча разных полезных и не очень как бы сервисов, там DB-контекст, какой-нибудь юзер-провайдер и прочее, прочее, прочее.
1847.58 1854.42 "Анатолий Кулаков" Вот они создаются, создаются, там аллокедят какие-то ресурсы и начинают возвращаться и как-то обрабатываться внутри одного реквеста.
1854.42 1862.66 "Анатолий Кулаков" А после того, когда реквест завершается, вы весь ответ записали и, в принципе, всю работу прекратили, у всех этих классов вызывается метод Dispose.
1862.66 1871.66 "Анатолий Кулаков" Они могут освободить свои ресурсы, и таким образом реквест, который закончился, в большинстве случаев освобождает все ресурсы и ждет, когда Garbage Collector его тихенько и спокойненько соберет.
1871.66 1879.10 "Анатолий Кулаков" То есть, такая концепция временного, если угодно, в котором хранятся сервисы, а потом освобождается.
1879.10 1891.90 "Анатолий Кулаков" Соответственно, если у нас реквест Scope создает новый Scope Lifetime, то все использования, допустим, класса DB-контекст внутри реквеста будут вам возвращать один и тот же instance DB-контекста.
1891.90 1896.38 "Анатолий Кулаков" И как только у вас придет другой реквест, то у него, например, instance DB-контекст уже будет другой.
1896.38 1901.58 "Анатолий Кулаков" Вот, надеюсь, со стандартами все разобрались, все их понимают, все их знают.
1901.58 1907.34 "Анатолий Кулаков" Если что, есть у Microsoft шикарная документация, где все это поподробнее и красивее с картинками и примерами описано.
1907.34 1914.82 "Анатолий Кулаков" Давайте же вернемся к нашим гипотетическим новым Lifetime Scope, который можно было бы создать, который наши авторы предлагали создать.
1914.82 1921.86 "Анатолий Кулаков" Это три примера – Tenant Scope Service, Pooled Service и Time-Based Service.
1921.86 1955.66 "Анатолий Кулаков" Поподробнее, для Tenant Scope Service очень много в нашем мире встречается мультитенант-приложений, то есть это такие приложения, внутри которых у нас есть некий тенант, то есть какой-то наш потребитель, какой-то наш кастомер, какая-то наша инсталляция, можно это представить, внутри которого все данные должны быть изолированы, то есть кастомеры, тенанты между собой никак не должны быть связаны, у них не пересекается ничего, не должно пересекаться по крайней мере, ничего там, ни пользователей, ни ордеры, ни тикеты, ничего.
1955.66 1985.70 "Анатолий Кулаков" Можно, возможно, это представить как вот прям отдельные два контейнера вы подняли и в одном контейнере у вас только данные хранятся только от тенанта А, а в другом контейнере только от тенанта В, но только чтобы не тратить всякие накладные ресурсы на контейнеры, это все хранится внутри одного приложения, внутри одной базы данных, в общем такой легкий-легкий докер на минималках, который пытается разделить данные именно по таким логическим признакам, именно по признакам тенанта.
1985.70 1990.60 "Анатолий Кулаков" Что же в этом скоупе хочется иметь, Multi-Tenant Scope Lifetime?
1990.60 1998.58 "Анатолий Кулаков" Мы хотим поведение в принципе такое, как Singleton, но только не для всего приложения полностью, а для нашего выбранного конкретного тенанта.
1998.58 2007.22 "Анатолий Кулаков" Ну, как я уже сказал, что данные внутри тенанта не должны выходить никуда наружу, в общем, и это вполне соответствует Singleton, но только Singleton в рамках тенанта.
2007.22 2013.18 "Анатолий Кулаков" Как только мы обратились из другого тенанта к этому сервису, ему необходимо породить новый какой-то класс.
2013.18 2023.66 "Анатолий Кулаков" Таким образом, например, можно сделать какой-нибудь кэш, который актуален только в рамках одного тенанта, но из другого тенанта у него будет свой кэш, и к предыдущему кэшу он обратиться не сможет.
2023.66 2026.14 "Анатолий Кулаков" То есть такое идеальное вообще разделение тенантов.
2026.14 2027.14 "Анатолий Кулаков" Довольно полезная, кажется, штука.
2027.14 2033.78 "Анатолий Кулаков" Второй Lifetime, который предлагали, это Pooled Lifetime.
2033.78 2040.26 "Анатолий Кулаков" Он призван уменьшить аллокации в вашем приложении, аллокации сервисов.
2040.26 2048.58 "Анатолий Кулаков" То есть, допустим, чтобы не создавать сервисы каждый раз, когда они вам понадобились, а брать их из какого-то пула и в этот пул обратно возвращать, как только они нам больше не нужны.
2048.58 2063.10 "Анатолий Кулаков" Обычно такой Pooled подход, Pooled стратегия, она применяется в High Performance всяких сценариях, когда вам необходимо выжать максимум от производительности, уменьшить аллокацию памяти и в общем такой, довольно узкий кейс для всяких оптимизаций.
2063.10 2076.06 "Анатолий Кулаков" Ну, например, в Entity Framework Core сделали Pooled DB Context, который на бенчмарках показал шикарные результаты, особенно если мы говорим про аллокацию памяти.
2076.06 2082.54 "Анатолий Кулаков" То есть, например, DB Context, такая сложная операция, как подключение к базе данных, поддержка соединения и вот это вот все.
2082.54 2087.62 "Анатолий Кулаков" Их как раз удобно иметь в пуле и переузывать очень быстро и очень удобно.
2087.62 2089.22 "Анатолий Кулаков" Вот EF умеет это делать прозрачно.
2089.22 2099.74 "Анатолий Кулаков" Но тут необходимо быть внимательным, потому что в принципе не каждый объект готов к тому, чтобы использоваться через Pool.
2099.74 2104.42 "Анатолий Кулаков" Чтобы использовать объект в пуле, он должен соответствовать некоторым характеристикам.
2104.42 2108.54 "Анатолий Кулаков" В частности, он должен уметь очищаться, ресетиться.
2108.54 2119.10 "Анатолий Кулаков" То есть, когда его кто-то поиспользовал, записал какие-то данные и мы вернули его в Pool, Pool должен иметь возможность почистить его, чтобы от старых процессов в нем ничего не осталось.
2119.10 2128.14 "Анатолий Кулаков" Таким образом, чтобы безопасно какой-то новый процесс, в тот момент, когда он арендует этот объект, он мог этот объект заиспользовать и не наткнуться на какие-то старые данные.
2128.14 2135.50 "Анатолий Кулаков" Поэтому одно из требований в том, что объект должен поддерживать такой ресет.
2135.50 2142.50 "Анатолий Кулаков" Ну и плюс нужно понимать, что этот ресет должен быть довольно быстрым, потому что мы сейчас здесь экономим на создании объектов.
2142.50 2150.94 "Анатолий Кулаков" И если ресет будет проходить дольше, чем создание объекта и дольше, чем Garbage Collector после этого объекта, в таком пулинге вообще нет никакого смысла.
2150.94 2166.98 "Анатолий Кулаков" И последний гипотетический Lifetime Scope, который нам предлагалось реализовать, это Time-Based Scope, то есть это сервисы, instance-сервисы, который жил бы определенное время.
2166.98 2178.66 "Анатолий Кулаков" Это что-то среднее между Transient и Scoped, то есть у нас есть сервис, который мы получили, один раз создали и задали какой-то период времени, который он живет, допустим 30 секунд.
2178.66 2186.62 "Анатолий Кулаков" И пока эти 30 секунд не прошли, мы при резолве из контейнера должны получать один и тот же instance все время.
2186.62 2192.88 "Анатолий Кулаков" Как только 30 секунд прошли, мы все начинаем получать новый instance, следующие 30 секунд.
2192.88 2216.70 "Анатолий Кулаков" Это очень похоже, например, на кэш, то есть мы, например, хотели бы закэшировать какой-то сервис, получать из него какие-то данные, получать-получать, потом через 30 секунд сделать вид, как будто данные у нас протухли и пойти новый instance этого сервиса породить и уже с новыми данными, уже получать, например, новые данные.
2216.70 2223.66 "Анатолий Кулаков" Примерно такой юзкейс можно этому придумать, но даже в этом случае кэш лучше было бы реализовать немножко по-другому.
2223.66 2226.18 "Анатолий Кулаков" Для кэша обычно предменяет другой подход.
2226.18 2239.26 "Анатолий Кулаков" Регистрируется какой-нибудь синглтон, который держит кэш, например, в памяти, и этот синглтон резолвится всеми сервисами, которые необходимы, которые хотят его заиспользовать.
2239.26 2261.26 "Анатолий Кулаков" При этом каждый период времени, когда вам необходимо обновить данные, просто запускается какой-нибудь бэкграунд-тред, бэкграунд-поток, и обновляет данные прозрачно для всех остальных потребителей, он затаскивает новые данные и в этот синглтон эти данные записывает, и все сервисы начинают получать новые данные уже из этого синглтона.
2261.26 2265.90 "Анатолий Кулаков" Итак, бэкграунд-тред в какой-то период начинает эти данные перезаписывать.
2265.90 2271.02 "Анатолий Кулаков" Чем подход с бэкграунд-тредом лучше, чем использовать, допустим, тайм-бейст, вот такой лайфтайм?
2271.02 2290.14 "Анатолий Кулаков" Ну, тем, что как только у вас пройдет 30 секунд, и какой-то новый сервис захочет получить новые данные и запросит из контейнера тайм-бейст-сервис, ему необходимо будет подождать, пока этот тайм-бейст-сервис теперь сходит куда-нибудь в Баскву или в сеть, получит новые данные и начнет их использовать.
2290.14 2293.58 "Анатолий Кулаков" То есть у вас будет какой-то лаг, этот лаг непредсказуемый.
2293.58 2300.06 "Анатолий Кулаков" То есть один раз попали вы на 30 секунд рефреша, вы работаете медленно, второй раз не попали, вы работаете быстро.
2300.06 2302.82 "Анатолий Кулаков" То есть это не очень удобно, не очень предсказуемо и не очень отложимо.
2302.82 2308.98 "Анатолий Кулаков" Если же у вас бэкграунд-сервис, то у вас все потребители стабильно работают быстро, это идеальное преимущество.
2308.98 2315.42 "Анатолий Кулаков" А бэкграунд-сервис берет на себя все необходимые проволочки, касающиеся тяжести загрузки этих приложений.
2315.42 2323.98 "Анатолий Кулаков" Поэтому кэш сюда тоже не очень подходит и, как мы увидим в конце, автор так и не придумал какого-то хорошего примера, где мог бы быть полезен таймбэйд-сервис.
2323.98 2327.94 "Анатолий Кулаков" Но реализовать он решил именно его первым.
2327.94 2331.26 "Анатолий Кулаков" Поэтому мы сейчас рассмотрим, а как вот этот таймбэйд-сервис реализовать.
2331.26 2341.14 "Анатолий Кулаков" С практической точки зрения, наверное, если наш любопытный слушатель не придумает, где это можно завязать, с практической точки зрения это абсолютно бесполезная штука.
2341.14 2347.14 "Анатолий Кулаков" Но, как показала практика, довольно интересный код получается, довольно интересное рассуждение.
2347.14 2360.74 "Анатолий Кулаков" И вот если, знаешь, можно вывести это на тему собеседования, когда к тебе приходит какой-то претендент на вакансию, ему вполне можно задать такое задание – реализуйте таймбэйд-лайфтайм.
2360.74 2376.30 "Анатолий Кулаков" Он довольно небольшой получается, но в нем есть какие-то ключевые такие хитрости, которые применяются в каждодневной практике и очень хорошо показывают знание, способ мышления и прочее-прочее о собеседнике.
2376.30 2378.86 "Анатолий Кулаков" Давайте же мы с вами попробуем этот квест вместе пройти.
2378.86 2382.26 "Анатолий Кулаков" И так, что нам хочется?
2382.26 2383.26 "Анатолий Кулаков" Таймбэйд-лайфтайм.
2383.26 2397.78 "Анатолий Кулаков" Ну, хочется, чтобы в пределах одного скопа у нас все время возвращался один и тот же инстанс, то есть независимо от того, прошло время или не прошло время, внутри одного, допустим, ispnet-реквеста у нас инстанс всегда должен быть один.
2397.78 2405.82 "Анатолий Кулаков" Но если время прошло, то внутри уже другого реквеста мы уже порождаем новый инстанс, когда этот сервис нам необходим.
2405.82 2409.74 "Анатолий Кулаков" И если время не прошло, то возвращается тот же самый инстанс, который и у первого реквеста.
2409.74 2413.06 "Анатолий Кулаков" Такие простые парочку требований.
2413.06 2416.94 "Анатолий Кулаков" Реализовать это лучше всего через отдельный класс фабрику.
2416.94 2436.26 "Анатолий Кулаков" То есть нам нужна какая-то фабрика, которая нам будет возвращать, создавать прежде всего новый инстанс, если нужно кэшировать его, следить за временем, на который он закэширован, и сбрасывать время и создавать новый инстанс, если вдруг кэш нам необходимо сбросить.
2436.26 2443.62 "Анатолий Кулаков" Звучит в принципе несложно, у нас есть фабрика, у нее есть банальный кэш, который возвращает тебе какой-то инстанс определенного приложения.
2443.62 2447.42 "Анатолий Кулаков" Если вдруг время прошло, то создают новый инстанс и начинают возвращать его.
2447.42 2455.14 "Анатолий Кулаков" В общем, ничего сложного на самом деле, но есть парочка таких, как я уже сказал, мелких проблем, с которыми вы обязательно должны столкнуться.
2455.14 2461.06 "Анатолий Кулаков" Ну, во-первых, фабрика эта будет одна на все приложения, то есть она должна быть RedSafe.
2461.06 2469.02 "Анатолий Кулаков" Не забывайте, что у нас там идет миллион запросов RPS в секунду, и каждый реквест порождает свой скоп, и все они параллельно начинают обращаться к этой фабрике.
2469.02 2471.58 "Анатолий Кулаков" То есть она должна быть RedSafe.
2471.58 2481.14 "Анатолий Кулаков" И также по условиям задачи она не должна порождать больше, чем один инстанс каждого конкретного запрошенного объекта.
2481.14 2484.06 "Анатолий Кулаков" Как же такую штучку реализовать?
2484.06 2494.34 "Анатолий Кулаков" Ну, из ключевых моментов, представьте, класс фабрика, сейчас наша любимая рубрика начнется, как бы зачитывание кода ушами и ротиком, поэтому слушаем внимательно.
2494.34 2511.94 "Анатолий Кулаков" У нас есть класс фабрика, из ключевых моментов, ну, конечно, в настройках у нас есть TimeProvider, с которым будем брать время, у нас есть TimeSpan, который нам рассказывает, сколько нужно хранить инстанс, у нас передается фабрика, которая будет нам рассказывать, каким образом мы будем порождать объект, о фабрике чуть подробнее поговорим.
2511.94 2515.66 "Анатолий Кулаков" Ну, и одно, наверное, самое ключевое поле, это поле, которое называется Instance.
2515.66 2527.86 "Анатолий Кулаков" Это поле у нас будет хранить тот объект, который у нас сейчас порожден, если он есть, и плюс к нему будет еще хранить дату и время, до которого он валиден.
2527.86 2536.38 "Анатолий Кулаков" Да, этот инстанс может быть null, значит, мы еще ничего не порождали, или в нем может быть значение, значит, мы уже что-то породили, и это значение там хранится.
2536.38 2542.78 "Анатолий Кулаков" Оно может быть протухшим или не протухшим, это уже зависит от поля DateTime, которое там хранится.
2542.78 2544.42 "Анатолий Кулаков" Теперь подробнее разберем фабрику.
2544.42 2546.58 "Анатолий Кулаков" Как же должна выглядеть фабрика?
2546.58 2556.14 "Анатолий Кулаков" Ну, конечно, когда мы создаем эту фабрику, фабрика фабрики, когда мы создаем этот класс, у нас внутри мы ничего не знаем о том, как этот класс порождать.
2556.14 2562.58 "Анатолий Кулаков" Мы можем знать про сервис-провайдер, из которого мы можем брать зависимость, и плюс мы знаем про тип, который нам нужно породить.
2562.58 2564.58 "Анатолий Кулаков" Но каким образом порождать?
2564.58 2570.18 "Анатолий Кулаков" Тоже довольно, наверное, частая ситуация, относительно частая ситуация, но не самый простой ответ.
2570.18 2579.06 "Анатолий Кулаков" Вот у вас есть тип T, который не зарегистрирован в сервис-провайдере, и у вас есть сервис-провайдер, в котором зарегистрированы все его зависимости.
2579.06 2590.50 "Анатолий Кулаков" Каким образом вам создать тип T, при этом не регистрируя его в контейнере, но забрав из контейнера все необходимые зависимости, которые нужны этому типу T?
2590.50 2599.90 "Анатолий Кулаков" Оказывается, в активатор Utilities, который Create Instance от T, есть прекрасная перегрузка, которая принимает сервис-провайдер.
2599.90 2615.06 "Анатолий Кулаков" Поэтому одной единственной строчкой, наш привычный любимый Create Instance от T, с перегрузкой сервис-провайдера, можно получить себе фабрику, которая умеет создавать тип T со всеми зависимостями, которые у этого типа T есть, и которые возьмутся из сервис-провайдера.
2615.06 2620.82 "Анатолий Кулаков" Тоже один из прекрасных моментов, который не всегда приходит на ум, и не все о нем знают.
2620.82 2625.14 "Анатолий Кулаков" Дальше разберем самый главный метод, метод Get Instance в этой фабрике.
2625.14 2634.66 "Анатолий Кулаков" То есть тот самый метод, который будет каждый раз вызываться из множества потоков, помним, для того, чтобы вернуть там инстанс.
2634.66 2641.82 "Анатолий Кулаков" Прежде всего мы должны проверить, существует ли у нас уже сейчас текущий инстанс и подходит ли он по нашему времени.
2641.82 2645.14 "Анатолий Кулаков" То есть если не прошло, допустим, 30 секунд, то мы просто-напросто возвращаем его.
2645.14 2659.54 "Анатолий Кулаков" Для этого нам достаточно проверить наш field, наше поле Instance, проверить у него время, для которого он валидным, если оно меньше, чем сейчас, меньше, чем таймер на сейчас, то возвращаем и не загоняемся.
2659.54 2663.30 "Анатолий Кулаков" Самое интересное начинается дальше.
2663.30 2673.18 "Анатолий Кулаков" Дальше мы должны создать новый инстанс, то есть мы понимаем, что у нас или инстанса нет, или он протух, поэтому мы должны создать инстанс новый.
2673.18 2675.26 "Анатолий Кулаков" Каким образом мы это делаем?
2675.26 2681.42 "Анатолий Кулаков" Прежде всего мы должны позаботиться о том, чтобы фабрика нам не создавала просто так инстансы, если они нам не нужны.
2681.42 2689.98 "Анатолий Кулаков" А помним, что у нас приложение в несколько потоков идет, и поэтому мы не можем просто так вызвать фабрику, потому что параллельный поток опять же в этот момент может вызвать фабрику.
2689.98 2693.98 "Анатолий Кулаков" То есть нам нежелательно вызывать фабрику несколько раз.
2693.98 2700.82 "Анатолий Кулаков" Те из вас, кто пытался сделать concurrent dictionary, который не вызывает несколько раз фабрику, в принципе, знает этот трюк.
2700.82 2708.94 "Анатолий Кулаков" Трюк заключается в следующем, мы должны создать лейзи объект, в качестве аргумента которого мы передаем фабрику.
2708.94 2717.90 "Анатолий Кулаков" То есть у нас создастся лейзи, но до тех пор, пока мы его не вызовем, фабрика не зафайрится, то есть фабрика не начнет создавать новый инстанс.
2717.90 2723.10 "Анатолий Кулаков" Ну и также мы засечем время, на которое этот новый инстанс будет жить.
2723.10 2731.82 "Анатолий Кулаков" Следующим методом мы должны каким-то образом гарантировать себе, узнать наш инстанс стоит материализовать или не стоит.
2731.82 2736.42 "Анатолий Кулаков" То есть, по сути, получить эксклюзивный доступ к нашему инстанс полю.
2736.42 2754.52 "Анатолий Кулаков" Для этого можно воспользоваться interlocked compareExchange методом, который сходит в наш инстанс поле, и если вдруг в этом инстансе поле хранится старый инстанс, то он его подменит на наш новый инстанс, который мы только что создали.
2754.52 2767.74 "Анатолий Кулаков" Если же там хранится что-то другое, то есть какой-то другой поток смог успеть до нас создать новый инстанс, то он ничего нам не подменит, а он нам просто-напросто вернет результат того, что ничего не смог сделать.
2767.74 2785.92 "Анатолий Кулаков" Вот, и проверив дальше этот результат, мы понимаем, что если предыдущий инстанс равен тому инстансу, который мы установили, значит там уже старый поток не смог, то есть старый поток уже что-то сделал, что-то подменил, то есть сделал новый инстанс.
2785.92 2793.38 "Анатолий Кулаков" Таким образом, мы просто-напросто берем то, что сделал другой поток, то есть результат его работы, и возвращаем.
2793.38 2796.38 "Анатолий Кулаков" Можем просто вызвать, например, этот же метод рекурсивно.
2796.38 2798.58 "Анатолий Кулаков" Он сделает именно то, что нам нужно.
2798.58 2809.10 "Анатолий Кулаков" В общем, а если вдруг мы подменили этот инстанс именно нашим новым экземпляром, то тогда мы его можем материализовать, то есть наш Lazy.
2809.10 2820.26 "Анатолий Кулаков" Материализовываем, вызываем Lazy.value, и таким образом наша фабрика наконец-то создает тот самый заветный инстанс и возвращает его из этого метода.
2820.26 2838.74 "Анатолий Кулаков" Вот здесь, в этом классе, мы как бы научились и работать с контейнерами, и с зависимостями, и проверять правильно дату со временем, и использовать lock-free подход для multi-thread программ, то есть использовать interlocked exchange.
2838.74 2851.62 "Анатолий Кулаков" И плюс мы научились как через фабрику не создавать лишние объекты с помощью Lazy, и также точно мы поняли, каким образом нам обрабатывать результат взаимодействия между несколькими трейдами.
2851.62 2860.50 "Анатолий Кулаков" То есть буквально такой маленький метод, он если без комментариев, то буквально десяток строчек в нем будет, но рассказал нам очень много про автора.
2860.50 2875.90 "Анатолий Кулаков" Но также он рассказал нам про автора то, что автор любит слишком быстро бросаться в оптимизации, потому что весь этот код с Compile Exchange и так далее, я не знаю, вам наверно стоит задавать только какому-нибудь синьору, который приходит к вам на собеседование.
2875.90 2899.54 "Анатолий Кулаков" Если же у вас ваш собеседующий скажет, что какой-то здесь слишком overkill, и код абсолютно нечитабельный для простого джунатом или даже медла, и им надо предложить как-нибудь его упростить, то тоже стоит послушать такого человека, потому что может быть упрощенный код будет работать не сильно хуже, а вот понятнее точно.
2899.54 2901.30 "Анатолий Кулаков" Как же упростить этот код?
2901.30 2902.30 "Анатолий Кулаков" Очень просто.
2902.30 2911.30 "Анатолий Кулаков" Нужно все вот эти понты с лог-фри структурами и алгоритмами заменить на обычный банальный лог, потому что лог знают все, лог умеют все и понимают все.
2911.30 2914.86 "Анатолий Кулаков" То есть вот это то, что я вам пытался там рассказать и страшные слова говорить.
2914.86 2924.94 "Анатолий Кулаков" Достаточно обрамить структуру лог, внутри лога проверить еще раз, что инстанс все-таки валиден, что инстанс все-таки создан.
2924.94 2929.86 "Анатолий Кулаков" Такой дабл-чек, кстати, да, тоже один из шаблонов, который должны, наверное, все знать.
2929.86 2937.38 "Анатолий Кулаков" Дабл-чек лог делаем, и если там все хорошо, то есть мы должны создать новый инстанс, мы берем, создаем новый инстанс и возвращаем его.
2937.38 2940.66 "Анатолий Кулаков" В общем, в принципе, и все, и на этом все объяснение заканчивается.
2940.66 2942.22 "Анатолий Кулаков" То есть тоже валидный подход.
2942.22 2946.38 "Анатолий Кулаков" Эндрю говорит, что в принципе надо бы побенчмаркать, кто из них будет эффективнее работать.
2946.38 2954.50 "Анатолий Кулаков" Для того, чтобы ответить на вопрос, действительно, стоило оптимизировать или не стоило оптимизировать, я надеялся, что он, конечно, бенчмарк эти приложит, но он не приложил.
2954.50 2974.78 "Анатолий Кулаков" Но можем предположить, что, конечно же, лог-фри структура на большом потоке трейдов, скорее всего, выиграет, то есть у нее там будет поменьше каких-нибудь блокировочек, но вот уровень поднимания с обычным логом, он в миллион раз лучше, в миллион раз больше, поэтому, наверное, стоит смотреть от ваших необходимостей.
2974.78 2986.62 "Анатолий Кулаков" Теперь, после того, как мы изобрели новый так называемый скоп в виде фабрики, нам необходимо его каким-то образом прицепить к нашему сервис коллекшену, чтобы его удобно можно было использовать.
2986.62 3007.42 "Анатолий Кулаков" Ну и самый правильный способ – это экстеншн метод на сервис коллекшене, который называется add_timed, который в качестве параметра принимает параметром t, то есть тот экземпляр, тот тип сервиса, который мы должны зафиксировать на какое-то время, и, соответственно, duration – время, на которое он должен быть зафиксирован.
3007.42 3034.22 "Анатолий Кулаков" Как я уже сказал, фабрика у нас должна зарегистрироваться в виде синглтона, то есть мы в сервис права зарегистрируем в синглтон эту фабрику, а вот сам instance, сам тип этого сервиса мы должны зарегистрировать как скоп, для того, чтобы в рамках одного реквеста, одного скопа у нас возвращался один и тот же объект, независимо от того, как бы прошло время или не прошло время, поэтому регистрируем его как скоп.
3034.22 3037.74 "Анатолий Кулаков" Таким образом, мы получили выполнение наших изначальных требований.
3037.74 3050.54 "Анатолий Кулаков" Один и тот же экземпляр будет возвращаться в рамках реквеста, независимо от продолжительности жизни, но как только у тебя будет другой реквест и при этом продолжительность жизни у него иссякнет, будет возвращаться новый экземпляр.
3050.54 3056.66 "Анатолий Кулаков" Подход хороший, подход интересный, но у него есть парочка проблем.
3056.66 3057.66 "Анатолий Кулаков" Итак, первая проблема.
3057.66 3066.54 "Анатолий Кулаков" Это заключается в том, что мы никак не обрабатываем, мы неправильно обрабатываем сервис, сервисы, которые disposable.
3066.54 3073.70 "Анатолий Кулаков" То есть, если мы таким образом зарегистрируем в addTimeit сервис, который реализует интерфейс iDisposable, у нас начнутся проблемы.
3073.70 3075.46 "Анатолий Кулаков" Проблема заключается в следующем.
3075.46 3091.50 "Анатолий Кулаков" Как только diContainer видит disposable сервис, зарегистрированный в скоупе, именно в его scoped lifetime, а напомню, мы регистрируем именно в scoped lifetime, он вызывает метод dispose каждый раз, когда заканчивается скоуп.
3091.50 3100.38 "Анатолий Кулаков" То есть, когда у нас закончился webrequest, мы dispose-им наш сервис, потому что у нас заканчивается именно скоуп самого контейнера.
3100.38 3110.90 "Анатолий Кулаков" И для нас это проблема, потому что на самом деле мы не хотим dispose-ить сервис, когда заканчивается скоуп, мы хотим dispose-ить наш сервис, когда у нас заканчивается время, которое он должен жить.
3110.90 3118.62 "Анатолий Кулаков" Время может быть выставлено 2 часа, а скоуп и реквест там будут заканчиваться каждую секунду, допустим.
3118.62 3128.30 "Анатолий Кулаков" И, к сожалению, это никак не победить, то есть, это именно поведение стандартного контейнера, и с этим ничего не сделать.
3128.30 3142.98 "Анатолий Кулаков" Можно придумать какие-то врапперы, чтобы контейнер dispose-ил не наш объект, а только его враппер, который не будет передавать dispose оригинальным объектам, но все это слишком криво получается, и в общем, пока остается такой некрасиво решенной проблемой.
3142.98 3144.94 "Анатолий Кулаков" В общем, пока это проблема.
3144.94 3160.66 "Анатолий Кулаков" Также у нас еще есть проблема с уникальностью, то есть, не очень соблюдается изначальное правило, которое мы себе поставили, что в один момент времени у нас может жить только один единственный экземпляр нашего timed-сервиса.
3160.66 3168.90 "Анатолий Кулаков" У нас, к сожалению, могут появиться ситуации, когда несколько экземпляров одновременно будут жить в приложении и использоваться в приложении.
3168.90 3170.38 "Анатолий Кулаков" Как это может произойти?
3170.38 3171.38 "Анатолий Кулаков" Довольно просто.
3171.38 3186.26 "Анатолий Кулаков" Представьте, что у вас есть очень медленный запрос, очень медленный реквест, который открывает скоуп и создает сервис, например, instance A, и он очень медленно продолжает выполняться.
3186.26 3198.18 "Анатолий Кулаков" В это время он такой медленный, что у вас происходит уже протухание этого сервиса, и в этот момент к вам приходит второй реквест, который говорит, дайте мне тоже этот сервис.
3198.18 3205.90 "Анатолий Кулаков" И вы ему отдаете уже instance B, потому что у вас уже произошло протухание, вы по протоколу должны вернуть ему instance B.
3205.90 3213.98 "Анатолий Кулаков" И таким образом у нас первый запрос еще не закончился, второй не закончился, и первый работает с instance A, второй работает с instance B.
3213.98 3218.42 "Анатолий Кулаков" Таким образом, у нас оба instance в приложении живы.
3218.42 3235.10 "Анатолий Кулаков" Насколько это большая проблема или небольшая проблема в реальной жизни, сказать невозможно, потому что автор так и не придумал практического примера, где можно было бы употребить этот прекрасный тайм-бейст, lifetime скоуп для нашего контейнера.
3235.10 3264.10 "Анатолий Кулаков" В общем, такая поучительная история, иногда теоретически даже какие-то фантазийные выдуманные примеры приводят к очень интересным реализациям, поэтому необязательно что-то на практике пытаться себе такое выдумать для того, чтобы попрактиковаться, иногда полезно сделать себе какую-нибудь кату и попробовать реализовать в 10 строчек какой-нибудь выдуманный lifetime, который может быть покажет вам какие-то практические кейсы, которые в будущем вам пригодятся на настоящих проектах.
3264.10 3265.10 "Игорь Лабутин" Да, интересно.
3265.10 3266.10 "Игорь Лабутин" Интересно.
3266.10 3275.50 "Игорь Лабутин" Я тоже так рассказывал, пытался придумать, зачем такое может быть надо, и что-то не придумал, особенно действительно с пересечением с dispose, как-то непонятно, что с ним делать.
3275.50 3287.98 "Игорь Лабутин" Но Эндрю молодец, код красивый, можно посмотреть всякие кода, как реализовывать лог-фри, как реализовывать нормально с логами, можно хотя бы даже это вынести практическую пользу.
3287.98 3288.98 "Игорь Лабутин" Вполне понятно.
3288.98 3298.02 "Анатолий Кулаков" Да, такие практические примерчики всегда наталкивают на какие-то интересные мысли, при том там код очень хорошо откомментированный, поэтому если вам интересно, то посмотрите на оригинал.
3298.02 3306.34 "Игорь Лабутин" А мы пойдем дальше, пытаться рассказать еще одну техническую историю про то, как переписывали NuGet.
3306.34 3315.18 "Игорь Лабутин" В курсе ли вы, что NuGet буквально недавно переписали, точнее сам NuGet, конечно, а его алгоритм рестора, чтобы он был быстрее.
3315.18 3316.18 "Анатолий Кулаков" А зачем?
3316.18 3317.18 "Игорь Лабутин" Чем старый не угодил?
3317.18 3318.18 "Игорь Лабутин" Потому что он был медленный.
3318.18 3319.18 "Игорь Лабутин" Сейчас все расскажу.
3319.18 3330.38 "Игорь Лабутин" Жила-была команда внутри Майкрософта, их на самом деле было много, которые использовали .NET, NuGet, все дела.
3330.38 3335.46 "Игорь Лабутин" В рамках статьи эта команда называется TeamX, я про нее так буду ссылаться периодически.
3335.46 3346.86 "Игорь Лабутин" И все было у нее хорошо, но потихонечку ее жизнь, так сказать, стала плохой, потому что NuGet рестор занимал более получаса.
3346.86 3361.26 "Игорь Лабутин" Ну, ты понимаешь, да, это как бы расходы на CI, да, то есть только NuGet рестор занимает больше получаса, не говоря про все остальное, то есть там еще сбор, какие-нибудь там линдеры, чекеры, что-нибудь еще, security проверки.
3361.26 3366.58 "Анатолий Кулаков" Ну, что добавление локального кэша для пакетов, скорее всего, решило бы проблему.
3366.58 3371.14 "Игорь Лабутин" Это 30 минут при условии, что все пакеты скачаны лежат локально на диске.
3371.14 3373.34 "Анатолий Кулаков" А, это все локально уже, да?
3373.34 3374.34 "Анатолий Кулаков" Да.
3374.34 3375.34 "Анатолий Кулаков" Ну, ладно, давай дальше.
3375.34 3376.34 "Игорь Лабутин" Это, короче, не про сеть.
3376.34 3382.38 "Игорь Лабутин" Значит, в чем основная проблема?
3382.38 3410.66 "Игорь Лабутин" Основная проблема заключалась в том, что вот этот алгоритм рестора, он довольно медленный, он был написан, собственно, и практически не трогался более 10 лет, было всего несколько инженеров, которые хоть что-то понимали во всех правилах и всяких там edge-кейсах, которые там в этом алгоритме были, что-то мне это напоминает какой-нибудь garbage collector, знаешь, где там одна маони что-то могла делать долгое время, вот, и, в общем, надо было что-то с этим делать.
3410.66 3422.10 "Игорь Лабутин" Делать с этим надо было, понятно, что у нас NuGet написан на интернете, берем профайлер, профилируем, смотрим, что получилось, и фиксим проблемы.
3422.10 3426.70 "Игорь Лабутин" Ну, как бы сделали, пофиксили проблемы, получили ускорение в 2 раза.
3426.70 3430.98 "Игорь Лабутин" Это как бы 2 раза, это 2 раза, но 15 минут, это все еще 15 минут.
3430.98 3437.66 "Игорь Лабутин" И надо было с этим что-то сделать, короче, поняли, что надо все это переделать, как обычно, выкинуть, переписать будет.
3437.66 3449.46 "Игорь Лабутин" И когда эффект второй системы, вот это все, в общем, все это вылилось в полугодовой проект, в котором переписали алгоритм, логику алгоритма рестора полностью с нуля, вообще целиком.
3449.46 3457.14 "Игорь Лабутин" И в результате получилось, что из 32 минут стало 2, что уже как бы нормально.
3457.14 3458.14 "Игорь Лабутин" Красота.
3458.14 3459.14 "Игорь Лабутин" Да.
3459.14 3462.58 "Игорь Лабутин" Статья очень длинная, и начинается она с истории NuGet.
3462.58 3465.50 "Игорь Лабутин" Значит, как вообще NuGet появился и развивался.
3465.50 3476.18 "Игорь Лабутин" Первая версия была опубликована в 2011 году, и она, ну, как бы у нее была простая цель, понятно, доставлять пакеты в дотнете.
3476.18 3483.66 "Игорь Лабутин" При этом на тот момент у нас был, напомню, единственный фреймворк, у нас не было никакого мультитаргета.
3483.66 3488.82 "Игорь Лабутин" При этом необходимость вот этого резолва была нужна только в момент инсталляции пакета.
3488.82 3494.46 "Игорь Лабутин" Я напомню, мы это делали в Visual Studio, нужно было открыть Package Manager, найти пакет, сказать install.
3494.46 3523.66 "Игорь Лабутин" Именно в этот момент определялись все нужные зависимости, все эти штуки зависимости ставились куда нужно, и писалось это, ну, вставились, естественно, и плюс это все записывалось в packages.config, и поэтому в момент сборки, собственно, NuGet было достаточно прочитать packages.config и тупо, ну, либо скачать, либо достать из локального кэша все файлики, которые там перечислены, ну, пакеты, и все, никакого как бы сложного резолва зависимостей на тот момент не было.
3523.66 3524.66 "Игорь Лабутин" Вот.
3524.66 3551.86 "Игорь Лабутин" Все хорошо, все нормально, ну, и была проблема, что как только у вас количество проектов в Visual Studio начинало подрастать, то поддерживать все вот это разнообразие пакетов в каждом из проектов, да, напоминаю, что мы ставили, никакого там solution level, ничего такого не было, насколько я помню, мы ставили пакеты для каждого отдельного проекта по отдельности.
3551.86 3554.30 "Игорь Лабутин" Блин, сколько лет назад это уже было, я уже все забыл.
3554.30 3555.30 "Анатолий Кулаков" Прям ужасно.
3555.30 3558.10 "Анатолий Кулаков" Да-да, такие страшные вещи говоришь, как будто их никогда не бывало.
3558.10 3559.10 "Анатолий Кулаков" Да-да-да.
3559.10 3560.10 "Анатолий Кулаков" Как к хорошему-то быстро привыкаешь.
3560.10 3585.58 "Игорь Лабутин" И когда все это тело только-только делали, то есть, ну, в какие-то первые там несколько, возможно, лет или, по крайней мере, год после adoption, после того, как все это зарелизили, в статье написано, что там было, ну, что-то порядка 500 пакетов, как бы, в принципе, в целом, и поэтому не было каких-то супер глубоких зависимостей и так далее, но потихонечку жизнь стала меняться.
3585.58 3606.94 "Игорь Лабутин" Во-первых, появился новый Nubed, ну, новый в смысле, что его немножко дописали, для того, чтобы он был под .NET Core, а, напоминаю, .NET Core уже мог таргетить несколько фреймворков, как минимум, .NET Core и старый .NET Framework, и уже нужно было Nuget быть умным, чтобы уметь резолвить зависимости либо туда, либо сюда.
3606.94 3631.10 "Игорь Лабутин" Во-вторых, было принято решение, что не нужно теперь больше указывать для каждого проекта вообще все зависимости, все транзитивные, потому что потихонечку экосистема росла, пакеты друг от друга начинали зависеть все больше и больше и больше, и каждый раз держать там полный список зависимостей, это уже как-то не очень здорово.
3631.10 3635.62 "Игорь Лабутин" Давайте будем держать только зависимости непосредственные, а все остальное подтянется само транзитивно.
3635.62 3645.02 "Игорь Лабутин" Дальше, что происходило, когда происходил рестор?
3645.02 3691.38 "Игорь Лабутин" Поскольку мы теперь храним только прямые зависимости, то есть непосредственные зависимости, нужно было сходить за каждой, выяснить ее транзитивные зависимости, сходить за каждой из зависимостей, выяснить их транзитивные зависимости, все это свести в единое большое дерево, построить, это все в памяти или еще где-то, проверить, что нет коллизий в версии, я напоминаю, что версии мы можем задавать в зависимостях, ну и все это свестив в некоторые единый непротиворечивый граф, потому что каждая зависимость приносит свой кусочек под графом, и если все это свелось в нормальный непротиворечивый граф, то вот уже в этот момент можно наконец-таки копировать файлики в output, как часть процесса рестора.
3691.38 3695.02 "Игорь Лабутин" А почему с графом все сложно?
3695.02 3705.30 "Игорь Лабутин" Ну, потому что у нас зависимости могут задаваться в том числе интервалами, плюс вы можете зависеть от двух разных библиотек, каждый из которых зависит от третьей, но и той же.
3705.30 3725.48 "Игорь Лабутин" При этом требования к этой библиотеке разные у разных двух под графов получаются, и нужно все это сводить в некоторые единые пространства, проверять, пересекаются ли интервалы, осуществит ли версия, которая удовлетворяет обоим интервалам, обоим ограничениям двух, а хорошо если только двух библиотек, ну и в общем получается довольно сложная задачка.
3725.48 3729.72 "Игорь Лабутин" Как это все было реализовано?
3729.72 3737.38 "Игорь Лабутин" То есть первоначальный алгоритм, который долго-долго жил, вот я так понимаю до прошлого года, он жил следующим образом.
3737.38 3748.74 "Игорь Лабутин" По сути, он это рекурсивный алгоритм, по сути своей, обход дерева в глубину, и при этом идея заключалась в следующем.
3748.74 3766.60 "Игорь Лабутин" То есть мы берем какой-нибудь под граф, ну, какую-нибудь самую там далекую внутреннюю, нижнюю зависимость, строим для нее, собственно, непротиворечивое дерево зависимости, поднимаемся на уровень выше и пытаемся для родителя построить тоже непротиворечивое дерево зависимости.
3766.60 3779.92 "Игорь Лабутин" Понятное дело, что пока мы так вот поднимаемся, спускаемся по дереву, в какой-то момент мы можем получить родителя, в смысле какую-то ноду, у которой два ребенка или больше ребенков имеют какие-то противоречия.
3779.92 3795.64 "Игорь Лабутин" В этот момент мы как-то перерешиваем, выясняем, ага, значит зависимость вот какая-нибудь глубокая версии может быть только такой, но мы только что поменяли зависимость очень глубокой версии, следовательно нужно пересчитать все графы, которые зависят от этой глубокой зависимости.
3795.64 3799.32 "Игорь Лабутин" Ну и начинаем заново пересчет всех зафикшенных кусочков.
3799.32 3804.00 "Игорь Лабутин" Также рекурсивно ходим по дереву, вот это все.
3804.00 3823.28 "Игорь Лабутин" При этом алгоритм держит все дерево в памяти, и ну вот твое угадывание, вот той самой TeamX, у которой 30 минут занимало рестор, как ты думаешь, сколько вот этих вот вершинок было в графе зависимостей?
3823.28 3827.68 "Анатолий Кулаков" Ну я думаю не меньше сотни точно, там по тысяче должно
3827.68 3828.68 "Игорь Лабутин" быть.
3828.68 3829.68 "Игорь Лабутин" Полтора миллиона.
3829.68 3830.68 "Анатолий Кулаков" Ой, мамочка.
3830.68 3831.68 "Игорь Лабутин" Полтора миллиона, вот.
3831.68 3836.42 "Анатолий Кулаков" Что ж там за проект-то такой, мне кажется, у нас в Нугете столько не будет даже пакетов.
3836.42 3841.94 "Игорь Лабутин" Проект большой, нет, проблема в чем, я не сказал, что там пакетов полтора миллиона, там вершин полтора миллиона.
3841.94 3842.94 "Игорь Лабутин" То есть если, например.
3842.94 3845.22 "Анатолий Кулаков" То есть там разные версии у них настолько разопущены.
3845.22 3856.46 "Игорь Лабутин" Нет-нет-нет, если у тебя есть, например, библиотека А, ну вот твой проект, допустим, зависит от библиотеки А и Б, каждая из которых зависит от библиотеки С, то в дереве библиотека С будет двумя вершинами.
3856.46 3858.78 "Игорь Лабутин" Одна под А, а другая под Б.
3858.78 3875.30 "Игорь Лабутин" И понятно, что если у тебя есть какой-нибудь очень популярный пакет, условный Newtonsoft, который используется, не знаю, в десяти разных библиотеках, каждую из которых ты держишь, то Newtonsoft будет в десяти экземплярах, и все его зависимости будут тоже размножаться.
3875.30 3879.14 "Игорь Лабутин" Почему бы не свести было в одну вершину их?
3879.14 3882.30 "Игорь Лабутин" Ну вот потому что на ранней стадии показалось, что не нужно.
3882.30 3890.42 "Игорь Лабутин" Более того, дальше в этой стадии идет уточнение.
3890.42 3899.42 "Игорь Лабутин" А, да, кстати, вот эти полтора миллиона вершин – это для одного проекта в Солюшене, там вообще-то еще проектов было много в Солюшене.
3899.42 3902.10 "Анатолий Кулаков" Действительно, команда Икс.
3902.10 3911.90 "Игорь Лабутин" Наверное, все-таки в нескольких Солюшенах, потому что вот чуть дальше есть статистика, что это был one project out of 2500 проектов.
3911.90 3922.46 "Игорь Лабутин" Возможно, другие поменьше, и, может быть, какой-нибудь там мега-убер-проект и остальные поменьше, но, в общем, какая-то очень большая бинка они целиком взяли, я не знаю, кто это был.
3922.46 3923.46 "Игорь Лабутин" Не сказано.
3923.46 3924.46 "Игорь Лабутин" Ажура.
3924.46 3928.70 "Игорь Лабутин" Ну, в смысле, не Ажура, это как его, Azure DevOps, черт знает.
3928.70 3930.90 "Игорь Лабутин" Короче, огромные графы, все это держится в памяти.
3930.90 3950.38 "Игорь Лабутин" В общем, все сложно, и всю эту радостную полтора миллиона вершин мы обходим рекурсивно туда-сюда, туда-сюда, туда-сюда, начиная заново, если мы обновили какой-нибудь подграф, до момента, пока мы не убедимся, что дерево, корень дерева получается непротиворечивым.
3950.38 3952.54 "Игорь Лабутин" Ну, может и не получится.
3952.54 3963.06 "Игорь Лабутин" Короче, очень сложно, очень долго, и стало понятно, что с увеличением кодовых баз, в общем, он становится медленным.
3963.06 3971.22 "Игорь Лабутин" Понятно, что, наверное, 99-95% кода в мире этой проблеме не подвержены.
3971.22 3980.58 "Игорь Лабутин" Это, конечно, проблема больших кодовых баз, но, тем не менее, была настолько интересная инженерная задачка, что, опять же, Microsoft, ну, и для себя, как бы они, по сути, экономили довольно много всего.
3980.58 3989.98 "Игорь Лабутин" Ну, как мы работаем с оптимизацией, как я уже сказал, берем, профилируем, меряем, смотрим.
3989.98 3998.06 "Игорь Лабутин" Они взяли это дело, сказали, отлично, профилируем, попрофилировали, поняли, что жрет это все сотни гигабайт мемори-трафика.
3998.06 4008.58 "Игорь Лабутин" Не в смысле, что просто одновременно, но постоянно там аутсируются какие-то ноды, что-то там, какие-то промежуточные результаты, все это чистится, короче, там кучу времени занимало, короче, коллектор, ну, пошли оптимизировать.
4008.58 4009.58 "Игорь Лабутин" Что мы оптимизируем?
4009.58 4017.64 "Игорь Лабутин" Ну, конечно, на горячих путях убираем LinkU, убираем всякие такие места, где хоть какой-нибудь там микробоксинг есть и вот это все.
4017.64 4025.36 "Игорь Лабутин" Дальше был интересный момент, напоминаю, алгоритм рекурсивный, но он написан в лучших традициях современного C#, то есть с асинкэвэйтами.
4025.36 4027.56 "Игорь Лабутин" А напомню, что каждая асинкэвэйт - это что?
4027.56 4029.28 "Игорь Лабутин" Стоит машина.
4029.28 4034.60 "Игорь Лабутин" Соответственно, рекурсивные асинкэвэйт-вызовы, ну, могут приводить к интересным эффектам.
4034.60 4039.36 "Игорь Лабутин" К порождению, на самом деле, довольно большого количества стоит машинок.
4039.36 4068.00 "Игорь Лабутин" В результате они были вынуждены, как я сказал, LinkU и на ходпутях все это поубирать, и это все было хорошо, и в некоторых местах они вручную за, так скажем, симулировали работу стека в рекурсии через прям, типа, ну, коллекцию стека, вот это все, там, хранение промежуточного состояния, чтобы стоит машина, которая капчурирует состояние, поменьше уходило, или вообще от них отказаться в идеале.
4068.00 4073.00 "Игорь Лабутин" В результате всех этих оптимизаций по памяти, по всему, по всему, по всему сократили всего в два раза.
4073.00 4076.68 "Игорь Лабутин" Как я говорил, там, из 32 получилось 16 минут.
4076.68 4093.28 "Игорь Лабутин" Алгоритм при этом по сути своей экспоненциальный, то есть проблема была в том, что как бы мы молодцы, мы в два раза сэкономили, но на самом деле добавление еще немножко зависимости потенциально увеличивает время обратно экспоненциально, то есть до тех же 32 минут, а то и больше.
4093.28 4095.92 "Игорь Лабутин" Надо что-то совершенно новое.
4095.92 4109.08 "Игорь Лабутин" Поэтому они решили делать совершенно новое решение и попытаться понять вообще в чем основная проблема, потому что, как я говорил, алгоритм запутанный, он большой, черт его знает, что-то на самом деле медленно работает.
4109.08 4121.00 "Игорь Лабутин" То есть понятно, что вроде память живется, но может быть дело не в ней, может быть дело еще в чем-то, короче, они поняли, что можно для начала попытаться это все как-то формализовать и понять вообще, что происходит.
4121.00 4123.36 "Игорь Лабутин" Весь рестор можно разделить на несколько частей.
4123.36 4135.88 "Игорь Лабутин" Сначала рестор читает все инпуты, то есть для этого у нас есть, надо прочитать все csprog, надо прочитать всякие там directory build props, куда вы можете какие-то там global override и вот это все повставлять.
4135.88 4149.32 "Игорь Лабутин" Надо прочитать всякие закешированную информацию, которая лежит на диске в папочках, чтобы понять аутпуты, которые вы сгенерили в прошлый раз, может быть они уже достаточно и не надо ничего делать.
4149.32 4153.68 "Игорь Лабутин" После этого для каждого проекта, когда вы прочитали все, мы делаем три шага.
4153.68 4164.16 "Игорь Лабутин" Первый называется no_op_resolve, это попытка проверить, если это input=output, то рестор, по-моему, пишет что-то типа та уже все заресторено, короче, делать ничего не надо.
4164.16 4165.16 "Игорь Лабутин" Отличный.
4165.16 4176.88 "Игорь Лабутин" Второй шаг это собственно restore_resolver и третий шаг это запись всего-всего-всего-всего на диск, тоже не очень быстрая операция, но по сравнению с остальным конечно ни о чем.
4176.88 4184.52 "Игорь Лабутин" Дальше они попытались понять эмпирически сложность алгоритма.
4184.52 4222.12 "Игорь Лабутин" То есть понятно, что можно было чисто математически предсказать, что она, наверное, экспоненциальна, но они сделали это прям экспериментально, то есть они взяли некоторый искусственный набор csproj, ну ту лзу, которая умеет генерировать произвольный набор dependency на произвольного количестве csproj, все это померили, как рестор живет, и выяснили, что рестор примерно укладывается в 5 секунд до тех пор, пока у вас как бы до 200 примерно нод вот в этом графе зависимости, а дальше все начинается расти сильно экспоненциально и очень заметно становится.
4222.12 4262.36 "Игорь Лабутин" А дальше они провели еще один эксперимент и поняли, что сама по себе вот это вычисление по графу, какая же должна быть, как сказать, какой же должен быть конечный набор, сам по себе вот этот шаг вычисления по графу, он, короче, какой-то очень короткий и быстрый, не вот полный рекурсивный алгоритм, а какая-то его, значит, логическая небольшая часть, и это значит, что если мы избавимся от рекурсии, если мы избавимся, ну как-то чуть более интересно подойдем к организации этого графа, то будет гораздо быстрее.
4262.36 4272.00 "Игорь Лабутин" Ну в общем, дальше они, соответственно, этот RestoreGraph разделили на 8 стадий и сделали довольно, ну, правильную интересную штуку.
4272.00 4281.00 "Игорь Лабутин" Они эти стадии изолировали друг от друга, то есть написали код так, отрефакторили, не меняя пока сути алгоритма, так чтобы у каждой стадии был четкий вход и четкий выход.
4281.00 4290.80 "Игорь Лабутин" И дальше взяли одну стадию, называется BuildRestoreGraph, то есть тот самый граф построения, который в итоге занимал 92% собственно всего времени.
4290.80 4300.96 "Игорь Лабутин" Остальные восемь приходились там на чтение, запись, вот это все, но главное там делать RestoreGraph, что дало вот это разделение на 8 или 7 частей.
4300.96 4320.92 "Игорь Лабутин" То, что теперь у нас есть у каждой стадии четкий input, четкий output, и мы можем, допустим, взять результат шага перед BuildRestoreGraph, скормить этот результат и новому алгоритму, и старому алгоритму, и просто буквально задампить результат в текстовой файлике и сравнить дифом.
4320.92 4330.04 "Игорь Лабутин" В идеале они должны полностью совпадать, и это значит, что мы все правильно сделали, новый алгоритм работает абсолютно так же, как и старый.
4330.04 4363.44 "Игорь Лабутин" Все прекрасно, сделали большой, соответственно, тестовый набор всего этого дела, начали тестировать, новый алгоритм работает принципиально по-другому, то есть старый алгоритм все грузит в память, строит абсолютно полный граф, как я сказал, дублируя всякие разные вершины и потихонечку пытается, грубо говоря, то, что они называют это bubbling up, распространять эффект от самых нижних слоев к самому верхнему, пока не сойдется в самой верхней точке, в корне в вашем проекте.
4363.44 4386.48 "Игорь Лабутин" Новый алгоритм делает по-другому, он, по сути, делает в каком-то смысле то, что ты сказал, то есть он держит только одну ноду для каждой зависимости в памяти, и за счет этого он умеет правильно обновлять и понимать, какие кусочки надо пересчитать, если изменилась какая-то информация по каждой ноде в зависимости, в разных кусочках под графом.
4386.48 4390.32 "Игорь Лабутин" За счет этого можно его сделать довольно быстрым.
4390.32 4413.76 "Игорь Лабутин" Просто как они быстро накидали первый прототип, он смог пройти 60% тестов, на остальных 40, что-нибудь падло, потому что там были довольно интересные ограничения по версиям, сложные зависимости, где-то могли быть циклы, еще что-нибудь, потому что негативные тест-кейсы тоже должны быть.
4413.76 4424.08 "Игорь Лабутин" Но в общем, в итоге алгоритм в той реализации, которая более-менее прошла тесты, делал примерно следующую конструкцию.
4424.08 4444.16 "Игорь Лабутин" То есть он, если он находил какую-то проблему, то есть если он понимал, что вот та версия, которую он определил, она конфликтная, он сбрасывал состояние и начинал заново, но знал, что вот для этой библиотеки больше нельзя брать те или иные версии или диапазоны версий.
4444.16 4451.48 "Игорь Лабутин" Таким образом, заранее, на ранних стадиях, отсекая заведомо проблемные версии, приводящие к конфликтам.
4451.48 4453.88 "Игорь Лабутин" И это прямо очень хорошо себя показало.
4453.88 4466.96 "Игорь Лабутин" Новый алгоритм, который вот переписывался, вместо 16 минут стал занимать 4, это как бы прям уже хорошо, но внутренняя целевая метрика была бы 2 минуты.
4466.96 4476.64 "Игорь Лабутин" Ну и здесь как раз уже опять профайлер, все дела, и выяснилось, что самая дорогая операция – это внезапно сравнение строк.
4476.64 4482.80 "Игорь Лабутин" Как мы понимаем, восстановление зависимостей – это операция с огромным количеством имен пакетов.
4482.80 4492.16 "Игорь Лабутин" Мы, по большому счету, постоянно сравниваем имена пакетов, одни, другие, третий, содержится ли этот пакет в виде зависимости соседнего пакета и так далее.
4492.16 4495.04 "Игорь Лабутин" И здесь помогла простая, незамысловатая оптимизация.
4495.04 4501.72 "Игорь Лабутин" В момент загрузки всего этого в память, мы все имена пакетов заменяем на идентификаторы числовые, которые тут же генерятся на лету.
4501.72 4513.84 "Игорь Лабутин" То есть, грубо говоря, делаем один большой словарик, и при загрузке все строчки подменяем на числа, и это прям ускорило в 2 раза всю работу, потому что убрало практически полностью сравнение строк.
4513.84 4519.28 "Анатолий Кулаков" Хорошая оптимизация, кстати, тоже редко встречается, но довольно эффективная.
4519.28 4529.24 "Игорь Лабутин" Да, но она должна, реально, вы должны по профайлеру увидеть, что она вам поможет, что там действительно много работы в компариях строк, ну либо что строки жрут много памяти.
4529.24 4530.24 "Игорь Лабутин" Тоже, в принципе, помогает.
4530.24 4535.96 "Игорь Лабутин" Кстати, не только имена пакетов, но и версии тоже внезапно поменяли на IntegerID, и тоже нормально.
4535.96 4549.96 "Игорь Лабутин" В общем, получился алгоритм, который хорошо работает, все дела, ну и после первоначальных тестов, естественно, вокруг них все стали бегать со словами, ну что, когда в прот?
4549.96 4551.96 "Игорь Лабутин" Когда вы это уже включите в прот?
4551.96 4556.72 "Игорь Лабутин" Дотнадт-9 был в этот момент, были самые последние превью.
4556.72 4560.16 "Игорь Лабутин" Если я правильно помню, это получалось в какой-нибудь август, наверное.
4560.16 4569.12 "Игорь Лабутин" Насколько я помню, потому что в сентябре, по-моему, вышел, или в конце августа вышел релиз кандидата, или в начале сентября вышел релиз кандидата, мне кажется почему-то.
4569.12 4576.12 "Игорь Лабутин" Ну, в общем, где-то там это было уже, и надо было принимать решение, мы это вообще в девятку запихиваем или не запихиваем.
4576.12 4590.84 "Игорь Лабутин" Понятное дело, тот факт, что у нас есть какой-то тестовый набор, мы его как-то проходим, но непонятно насколько мы полно им соответствуем, вообще старому поведению алгоритма.
4590.84 4615.88 "Игорь Лабутин" Алгоритм это прошло много лет работал, там куча всяких разных edge cases и всего остального, но подумав, посчитав, сколько они вообще говоря экономят в той самой команде в год, то есть по сути сколько они потратят просто лишнего времени, если они не выпустят эту штуку, и ее придется делать в десятый тутнет, то есть через год, они решили, ну не, надо все-таки это попытаться впихнуть в девятку.
4615.88 4629.68 "Игорь Лабутин" И дальше стали понимать, что окей, вот этот вот самый тестовый набор, он в основном покрывал хэппи сценарий, то есть они были сложные, они были разнообразные, но в основном все-таки хэппи.
4629.68 4646.52 "Игорь Лабутин" Там было или почти не было, там было мало или почти не было всяких разных проблемных и ошибочных сценариев, как я говорил там, там же есть огромное количество всяких циклов, там не циклов, недоступности, несовместимости в версии, еще что-нибудь.
4646.52 4654.20 "Игорь Лабутин" И в общем нужно было аккуратненько, вот они пишут, что три основных момента, которые нужно было аккуратно сделать.
4654.20 4666.12 "Игорь Лабутин" Это конфликты версий, это циклы и это package downgrades, то есть когда в процессе рестора мы понимаем, что мы вообще говоря должны задаунгрейдить пакет по сравнению с тем, который был ранее.
4666.12 4681.24 "Игорь Лабутин" А еще не поддерживался transitive pinning, это фича относительно недавнего дотнет, когда вы можете запинить версию, которую вы непосредственно не ссылаетесь, но она где-то там далеко внизу по зависимостям есть.
4681.24 4691.08 "Игорь Лабутин" При этом они были готовы transitive pinning отложить на после 9-го дотнет, то есть в принципе оно могло выйти без transitive pinning.
4691.08 4707.76 "Игорь Лабутин" Но тут проблема в чем, еще одна, что качество вот этого процесса рестора, оно не только проблемное само по себе в том плане, что если у вас рестор там неправильно сработал, то вы будете получать какие-нибудь ошибки в момент рестора.
4707.76 4708.76 "Игорь Лабутин" Проблема не в этом.
4708.76 4724.48 "Игорь Лабутин" Если у вас рестор неправильно сработал, вы в теории можете получить ошибки уже только в рантайме, если вы например заресторите не ту версию, которая ресторилась раньше, но при этом она окажется бинарно совместимой, а по поведению будет другой.
4724.48 4736.36 "Игорь Лабутин" И поэтому это все надо было как можно тщательнее отладить, оттестировать, проверить и убедиться, что если ошибки какие-то и есть, то они вылезают на этапе самого рестора.
4736.36 4745.76 "Игорь Лабутин" И сказали, ну ладно, короче, нормально, что мы, не справимся что ли, давайте это самое попробуем.
4745.76 4766.64 "Игорь Лабутин" И запустили, как я понял, полный набор Nuget Automation тестов, к которым они все это подготовили и получили просто сотни ошибок, сотни проблем, решив, что ну все-таки мы будем пытаться все это запихнуть в девятку, давай разбираться потихонечку с этими самыми багами.
4766.64 4770.12 "Анатолий Кулаков" Какие-то отчаянные психи после сотни ошибок, а почему
4770.12 4772.12 "Игорь Лабутин" еще в девятку ходить-то?
4772.12 4773.12 "Игорь Лабутин" Да вообще.
4773.12 4811.68 "Игорь Лабутин" И в общем, начали потихонечку разбираться, где-то выяснялись проблемы, что тесты падали, потому что, допустим, пакет какой-то конкретный, в смысле, количество скачанных пакетов не совпадало с тем количеством, которое качал новый алгоритм, потому что как раз у него не было много нод одной и той же библиотеки, и выяснялось, что где-то может сэкономить, а они там несколько скачиваний одной и той же считали, ну считали как несколько, хотя по идее мы не должны качать одну и ту же версию несколько раз, но видимо в каких-то очень сложных сценариях могло быть.
4811.68 4829.04 "Игорь Лабутин" Потом новый алгоритм начал репортить какие-то странные новые ошибки, и выяснилось, что старый алгоритм вообще-то их тоже детектил, но не репортил, то есть он вместо них репортил какие-то, ну просто типа что-то пошло не так, а новый смог более точно понимать, что же идет не так.
4829.04 4855.04 "Игорь Лабутин" Ну в общем, много было разных интересных ошибок, и для того чтобы с этим всем получше, попроще работать, они начали с простого, первое, что нужно для простоты отладки — убери параллелизацию, ну потому что Nuget все-таки пытается что-то делать параллельно, когда понимает, что у вас есть какие-то независимые кусочки, но отлаживать такое совсем плохо и ужасно.
4855.04 4888.20 "Игорь Лабутин" Это все было отключено, это все отлаживалось, они поняли, что ну отлично, новый алгоритм работает прекрасно, шикарнейший, быстрее гораздо ресторит, если у вас то, что называется warm state, то есть вы уже ресторили, у вас все в кэшах, вот это все, а вот если вы делаете clean restore, то есть вы никогда на этом компьютере, например, ничего не ресторили, то новый алгоритм за счет того, что в нем отключена параллелизация и все остальное работает ну в общем раза в два медленнее, чем старый, просто за счет именно параллелизации.
4888.20 4892.36 "Игорь Лабутин" Ладно, включаем параллелизацию обратно, ловим баги на ней, фиксим.
4892.36 4933.40 "Игорь Лабутин" В общем, в итоге к сентябрю, то есть я так понимаю, что это заняло примерно месяцок, если я правильно понимаю вся вот эта история с багами и полным регрессом, алгоритм был в принципе готов и доступен для внутреннего использования, вот, и более того, он примерно начал, грубо говоря, быть дефолтом уже внутри компании, а к моменту релиза, релиз кандидата 1, они успели даже и трензитив пинг сделать и включить его даже, вот, так что они были уже к моменту релиза кандидата 1, были вполне уверены, что все, все заработает, все будет зашибись.
4933.40 4973.12 "Игорь Лабутин" На этом вся история не останавливается, в принципе там есть еще чем позаниматься, то есть есть будущая работа там, есть теперь в новом алгоритме еще опции, где еще теперь можно включить побольше параллелизма и еще побольше устроить интересностей, новый вот этот алгоритм пока не работает, если вы используете log файлы, можно, у нас есть package.json.log, по-моему, называется, если я правильно помню, или package.log.json, я уже забыл, давно не пользовался этой штукой, где вы можете зафиксировать версии, InnoGet должен с этим корректно работать, вот сейчас пока новый алгоритм не работает, он фоллбетчится на старый, и, в принципе, кстати, вы можете отключить этот новый через специальный msbuild.property, и она будет работать по-старому.
4973.12 4997.64 "Игорь Лабутин" Вот, ну и понятно, что из этой статьи там делаются всякие разные такие общечеловеческие выводы про то, что да, net performance это важно, значит, надо быть be brave, sometimes, и видим вот этот sometimes, это ключевое, надо угадать, когда можно быть brave, а когда все-таки лучше не пытаться угнаться совсем уже за супербустом производительности.
4997.64 5010.44 "Игорь Лабутин" Нужно таймбоксить это все дело, то есть не надо уходить на три года, пытаться все и дизайнить, то есть они за таймбоксили это и постарались в обозначенный срок что-то сделать.
5010.44 5127.20 "Игорь Лабутин" Дальше они говорят, что довольно интересным опытом было как раз таки привлечение сторонних, по сути, разработчиков, и над нугетом по сути работает три команды, получается, то есть это команда самого dotnet, самого нугета и visual study, вот, и как раз таки visual study они немножко больше как такие пользователи получаются, да, то есть они у себя там понятно, что у них должен быть package manager, все дела, но в корную функциональность нугета они особо не комментируют и ее не смотрят, и вот как раз таки эти инженеры, они понимая в принципе сам процесс рестора, да, понимая, что он должен делать, довольно много внесли нового, и они как раз вот и были инициаторами этого нового алгоритма, как я понял, вот, ну и да, следующий совет, не надо при этом привлекать очень много народу, вот, весь этот новый прототип запилили два человека всего, вот, понятно, что к моменту, когда выяснили, что мы не проходим тучу тестов, ну да, там просто уже нужно навалиться массой и все инженеры аккуратно сидят фиксит баги, все, кто доступен для этого проекта, но вот все это коверание прототипирования делать там большой толпой, больше потратите на координацию, чем на какую-то клевую идею прототипа, ну, либо делать это в формате хакатона, когда вы делаете несколько разных прототипов небольшими группами, дейлики внезапно очень полезно, и последний комментарий был про то, что не забудьте, не надо откладывать тестирование сложных сценариев на потом, ну, по принципу, ща мы сначала на простых программках все проверим, а вот потом, как запустим, как оно заработает, лучше проверьте сразу, как бы, начинайте проверять даже сложные сценарии в самом начале, потому что они могут показать какие-то ключевые проблемы вашим нового алгоритма или чего-то угодно подхода, до того, как вы инвестируете кучу времени и поймете, что на сложных-то оно вообще никак не работает, вот не получается.
5127.20 5133.92 "Игорь Лабутин" Вот такая вот история, теперь у нас есть быстрый клевый нугет уже, начиная в девятом дотнете, ты заметил, что он стал быстрее?
5133.92 5135.36 "Анатолий Кулаков" Нет, не приходилось.
5135.36 5136.68 "Анатолий Кулаков" Ну, у вас мало проектов.
5136.68 5143.44 "Анатолий Кулаков" Да, да, надо срочно проект подобрать какой-нибудь страшный и затащить туда пару миллионов пакетов.
5143.44 5153.56 "Игорь Лабутин" Вот-вот, мне уже даже интересно посмотреть, как выглядит такой проект, да, ну, видимо, это только где-то внутри Майкрософта можно увидеть, но такие дела, такая история с нугетом.
5153.56 5162.72 "Анатолий Кулаков" Хорошая, хорошая история, не знаю, главное не сделать здесь выводы, что типа 10 лет не трогайте свой проект, а потом за месяц до ключевого релиза переписывайте все к чертовой матери.
5162.72 5168.92 "Анатолий Кулаков" В общем, это неправильно не будет вывод, но в целом у ребят все получилось, и это хорошо.
5168.92 5179.80 "Игорь Лабутин" Справедливость-то ради начали они в марте, как я понимаю, если они говорят, что шесть месяцев они потратили, да, то есть я так рассказываю, там, вот, релиз на нас, SUBARU, все фиксить, но фактически это полгодовая работа.
5179.80 5192.00 "Анатолий Кулаков" Ну да, ну просто когда у тебя вываливаются ключевые ошибки, мне кажется, много-много-много ошибок, то это момент, когда нужно остановиться и подумать все-таки, может, не стоит торопиться.
5192.00 5195.48 "Игорь Лабутин" Все так, давай дальше.
5195.48 5197.84 "Анатолий Кулаков" Так, что хотелось бы рассмотреть.
5197.84 5207.44 "Анатолий Кулаков" Хочется продолжить нашу телегу про то, почему C# не используют, почему этот язык не так популярен, что какие предрассудки, какие тараканы у людей в голове живут.
5207.44 5211.24 "Анатолий Кулаков" Ну, потому что если не будем мы об этом говорить, то, наверное, никто не будет.
5211.24 5226.68 "Анатолий Кулаков" И очень, кстати, попалась статья на Reddit про эту тему, автор задался вопросом, что почему отношение к C# у интерпрайс-проектов и у стартап-проектов разное.
5226.68 5230.64 "Анатолий Кулаков" Вот давайте попробуем вместе там найти в комментариях ответы на этот вопрос.
5230.64 5235.84 "Анатолий Кулаков" Ну и краткая предыстория, откуда вообще у автора взялся такой посыл.
5235.84 5247.28 "Анатолий Кулаков" Он внезапно узнал, что в Tesla используют .NET, и в принципе нигде насильно об этом не афишируют и нигде не кричат, в отличие от всяких других фреймворков, которые на каждом углу встречаются и на каждом углу хайпуются.
5247.28 5248.28 "Анатолий Кулаков" Вот.
5248.28 5264.34 "Анатолий Кулаков" И он так проанализировал примеры рынка, и у него в голове сложилась картина, что интерпрайс-проекты такие все большие, мощные, которые уже там такие давнешние, надежные, они, в принципе, очень плотно сидят на .NET, и .NET там полно.
5264.34 5267.48 "Анатолий Кулаков" А вот всякие стартапы, они стесняются .NET.
5267.48 5279.36 "Анатолий Кулаков" И вот в стартапах .NET очень мало, и поэтому он сделал себе в голове вывод, что очень сильно разница в отношении к .NET делится между интерпрайзами и стартапом.
5279.36 5290.80 "Анатолий Кулаков" И он решил спросить типа, чуваки, вы типа здесь есть оттуда и отсюда, давайте вместе придумаем, почему такое отношение сложилось, в чем основные причины, проблемы и так далее.
5290.80 5302.62 "Анатолий Кулаков" В общем, мы там навалили много-много комментариев, я основные из них проанализировал и готов для вас донести мнение общественности, почему же все-таки стартапы не выбирают .NET, а большие интерпрайзные компании .NET выбирают.
5302.62 5333.30 "Анатолий Кулаков" Ну, наверное, для нас не очень интересно, почему большие .NET выбирают, потому что и так мы все знаем с вами, что там кроссплатформа, айот, надежность, стабильность, предсказуемость, безопасность, лучшие стандарты, лучшие практики, интеграция с чем угодно, а также большой красивый Microsoft за этим за всем стоит, который предоставляет нам самых лучших экспертов на рынке, которые все это разрабатывают, официальную документацию, какие-то платные поддержки в это все есть, в общем, дает нам самые прелести, самые ништяки, которые только существуют.
5333.30 5342.46 "Анатолий Кулаков" В общем, это все не так интересно, многое для нас интереснее, почему же стартапы избегают .NET проектов, ну, давайте потихонечку разбираться.
5342.46 5587.42 "Анатолий Кулаков" Начнем мы с пункта скорость разработки и гибкость, то есть очень многие комментаторы утверждают, что в принципе для порога входа в .NET довольно велик, то есть чтобы начать программировать на .NET вам нужны умные довольно разработчики, в общем просто так какой-нибудь там Васю из переулка взять не получится, а стартапы стремятся набрать как можно более дешевую силу, потому что никаких денег как бы платить хорошим специалистам у них нет, ну и плюс они стремятся к очень быстрому выводу продукта на рынок, это тоже один из ключевых показателей, для которых в принципе не важно там стабильность, надежность, стандарты, security, вот это все вообще не важно, для нормального стартапа важно выдать вчера как бы продукт, который уже можно попробовать на пользователя, может быть собрать в следующий фонд бабок с инвесторов и уже пойти как бы топтаться дальше, и в этом плане Python и JavaScript гораздо сильнее подходят для стартапа, потому что они вот такие динамически типизированные, у них есть Apple и они помогают очень быстро наваять прототип очень неквалифицированными кадрами, грубо говоря, в общем любой ломобот как бы сядет и быстренько что-нибудь на JavaScript вам наколбасит, очень легко и просто, также они имеют широкий выбор библиотек, то есть практически интеграция со всем, библиотеки для всего, все на свете есть и гораздо больше, чем в Nuget, тут уж не поспоришь, что может быть ключевой особенностью для того, чтобы вывести какой-то незнакомый стартап или незнакомый продукт на рынок, для которого там нужны много-много интеграции со всем подряд, как бы разбираться со всякими тонкостями строгих типов времени нет, поэтому ключевой момент, который мешает, это как раз вывод быстрого продукта на рынок, также к этому способствует, например, если мы берем JavaScript, то у нее есть нода, нода помогает писать бэкэнды в том числе, то есть у нас получается такой full stack разработчик, он может и на фронтовой аяте, и на бэке что-то сделать, и переиспользовать одну и ту же кодовую базу, что сокращает время выхода на рынок, и при этом у такого разработчика меньше сменяется контекст, когда он пишет и фронт, и бэк на одном и том же языке, и плюс он удовлетворяет как бы все свои хотелки на фронте, он полностью их может удовлетворить там и на бэке, ну то есть взаимодействия между командами, между сотрудниками никакого нет, никакого контекста свитча нет, садится один человек и полностью с нуля как бы реализует всю фичу, для небольших как бы опять прототипов и все такое, это работает в полный рост, вот почему как бы full stack, там допустим на джава скрипте, на ноде, он хорошо себя показывает, ну и если мы берем как бы современные тенденции, то интерактивное какое-то веб приложение, сингл пейдж аппликейшн, это очень важная часть практически любого стартапа, то есть если вы сделаете красивую морду, если эта красивая морда будет красивыми анимашками переливаться, то это поразит как бы самое сердечко любого инвестора, в общем это очень большая и важная часть, ну а морду вы конечно же будете делать на джава скрипте, но раз на джава скрипте, значит бэкэнд тоже надо на джава скрипте, потому что в full stack и пошло поехало вот это безобразие дальше, вот, можно было бы конечно рассмотреть blazer как full stack для дотнет разработчиков, но в комментариях очень много замечают что у blazer есть куча недостатков, то есть у него все еще много проблем, он плохо масштабируется и все равно не такая зрелая платформа, несмотря на все его там компоненты, которые тужатся и поставляют различные поставщики, все таки не такая зрелая платформа как допустим тот же самый реакт, у которого все равно намного больше компонентов, намного больше уже практики, книг, опытов, курсов и так далее, ну то есть реакт конечно выигрывает у всего что есть на рынке касательно юая, вот, поэтому полного full stack на дотнете получить у вас не выйдет, в общем и это тоже такой вот довольно заметный минус.
5587.42 5681.18 "Анатолий Кулаков" Следующее то что отмечают из минусов это стоимость и доступность, с дотнетом в головах людей мне кажется больше, есть какие-то дополнительные затраты, то есть они думают что им нужно будет приобретать полную лицензию на visual studio, им нужно будет приобретать какие-то лицензии от микрософта, может быть на mssql, может быть на windows, опять же вот эти вот странные предпосылки от того что где-то нужно платить деньги за дотнет, мне кажется это все опять же полная чушь, потому что если мы их, ну больше всего конечно ссылается на EDE, все EDE платные, они и проприетарные и нужно много денег для того чтобы начать программировать на дотнете, давайте вспомним что прежде всего у нас есть visual studio community edition, которая абсолютно бесплатная, у нас есть visual studio code, которая абсолютно бесплатная, у нас есть rider free, который абсолютно бесплатный, у нас вообще есть lsp server, который может подключить как бы к любому вашему практически редактору поддержку C#, пусть конечно не такую идеальную, как мы привыкли уже все видеть в решарпере, но все же, наверное по сравнению не хуже чем с другими языками, давайте так, и почему-то в комментариях утверждается, что вот для javascript и python все EDE бесплатные и у них с этим все хорошо, никаких проблем с лицензиями не возникает, но кажется что там бесплатные точно такие же EDE, которые или рассчитывают на lsp или какие-то community edition, но если вы захотите писать профессионально, то скорее всего за точечную идею вам наверное нужно будет заплатить.
5681.18 5714.74 "Игорь Лабутин" Ну вот кстати тут нет, тут как раз идея, то что в rider, который действительно фри, но только в он он коммерчил, в escode сейчас есть c# extension, он бесплатный, но если вы хотите чуть более продвинутый experience, это c# devkit, а у него модель лицензирования такая же, как у visual studio, то есть если вы хотите коммерческую разработку, то будьте добры платить, так же как за studio community, а вот с python, pycharm от jetbrains бесплатный для коммерческой разработки.
5714.74 5720.02 "Игорь Лабутин" Pycharm community edition называется, он бесплатный для коммерческой разработки любой.
5720.02 5731.42 "Игорь Лабутин" Есть pycharm pro или как-то так он называется, он уже платный, но он как бы, там просто больше фич, больше фреймворков подержанных, интеграции с фреймворками, вот это всё.
5731.42 5739.26 "Игорь Лабутин" Но на питончике можно писать в нормальный jetbrains kde бесплатно и при этом для продакшна, без каких-либо ограничений.
5739.26 5743.42 "Анатолий Кулаков" С вейс-кодом, на вейс-коде ты тоже можешь писать для продакшна бесплатно.
5743.42 5751.06 "Игорь Лабутин" Да, но в вейс-коде у тебя нету конечно всего того, что есть в kde от jetbrains.
5751.06 5752.62 "Игорь Лабутин" А впитывание есть?
5752.62 5753.62 "Игорь Лабутин" Да.
5753.62 5754.62 "Игорь Лабутин" Я писал.
5754.62 5760.82 "Анатолий Кулаков" Ну я имею в виду, что кроме интеллисенса, базового рефакторинга, подсветки, что тебе там ещё надо?
5760.82 5763.54 "Анатолий Кулаков" Ну дебаггер тоже есть, что тебе ещё надо?
5763.54 5767.62 "Игорь Лабутин" Ну давай так, по ощущениям от использования, pycharm гораздо приятнее.
5767.62 5783.78 "Игорь Лабутин" И теми же переходами, рефакторингами, юзеджами, особенно в динамически типизированных языках, это важно, потому что там где ты можешь вызвать методы по имени, это конечно не руби, где ты можешь написать хендлер на отсутствующий метод, но близко.
5783.78 5788.02 "Игорь Лабутин" Короче, pycharm приятнее гораздо, чем вейс-код, даже с питомцским расширением.
5788.02 5789.70 "Игорь Лабутин" Ну для меня было, по крайней мере.
5789.70 5790.70 "Игорь Лабутин" Ну хорошо.
5790.70 5801.54 "Игорь Лабутин" С JS не знаю, тут как бы ничего не скажу, про JS видимо идёт речь о том, что там базового вейс-кода чуть ли не достаточно, но тут не знаю.
5801.54 5805.18 "Анатолий Кулаков" Да, я, к сожалению, тоже не подскажу.
5805.18 5812.34 "Анатолий Кулаков" Ну тогда, по твоим сведениям, у нас получается, что нет какой-то достойной IDE, которая позволяет писать коммерческий код.
5812.34 5813.94 "Игорь Лабутин" Да, получается, что нет.
5813.94 5826.54 "Игорь Лабутин" То есть в VS-комьюнити там есть очень как бы, типа если вы меньше 5 человек, и при этом важен доход в год, то есть для какого-то стартапа, может, и подойдёт совсем маленького, грубо говоря, когда вас там очень мало.
5826.54 5834.98 "Игорь Лабутин" Но как только вы становитесь маломальски большими, технически либо здравствуй полный райдер, либо здравствуй полная лицензия Visual Studio.
5834.98 5843.14 "Игорь Лабутин" Не обязательно, понятно, у Ultimate сразу брать, но хотя бы Professional по-хорошему, если вы хотите удовлетворять требованиям лицензии, придётся.
5843.14 5847.38 "Игорь Лабутин" Либо C#, DevKit, но это та же самая по сути лицензия Visual Studio.
5847.38 5848.38 "Анатолий Кулаков" Вот.
5848.38 5851.82 "Анатолий Кулаков" Ну да, просто были классы кроссплатформенные, получается.
5851.82 5852.82 "Игорь Лабутин" Ну да, для VS-кода.
5852.82 5863.30 "Игорь Лабутин" То есть, короче, под .NET действительно для попробовать вариантов вообще, ну, большое количество, особенно когда вышел Rider3, без проблем.
5863.30 5867.70 "Игорь Лабутин" Начать вообще никаких проблем, но вот коммерческая разработка — это прям такое.
5867.70 5883.46 "Игорь Лабутин" Ну, надо сказать, что по той же Java как бы тоже, наверное, есть, наверное, те, кто пишет на бесплатном Eclipse до сих пор, но по большому счёту все берут идею, хотя опять же Community Edition идеей позволяет писать коммерческое ПО.
5883.46 5888.70 "Игорь Лабутин" Вот, если вы не хотите тратиться на полноценную большую идею.
5888.70 5898.62 "Игорь Лабутин" Так что такое, да, в .NET нету нормальной, полноценной, хоть какой-то адекватной IDE, в которой вы можете писать коммерческий код, с моей точки зрения.
5898.62 5899.62 UNKNOWN Угу.
5899.62 5904.54 "Анатолий Кулаков" Хорошо, ладно, учтём товарищей, пишущие IDE, пожалуйста, займитесь.
5904.54 5906.94 "Анатолий Кулаков" Займитесь этими делами, надо исправляться.
5906.94 5908.94 "Анатолий Кулаков" Хороший поинт для роста.
5908.94 5919.38 "Анатолий Кулаков" Ну и на последнем месте для минусов, для стартапов про .NET Framework — это же, конечно, культурные и исторические факторы.
5919.38 5947.74 "Анатолий Кулаков" Потому что стартапы, они как бы все за свободу, все за открытость, они предпочитают открытые, бесплатные технологии, они избегают решений, которые ассоциируются со всякими огромными и большими компаниями, в их числе, естественно, входит Microsoft, и .NET исторически ассоциируется с Microsoft, ассоциируется с Windows, ассоциируется с MS SQL, и все это до сих пор таким шлейфом тянется, как что-то закрытое, что-то страшное, что-то дорогое.
5947.74 5954.14 "Анатолий Кулаков" И, в принципе, это тоже все еще огромный шлейф такой предвзятости.
5954.14 6001.38 "Анатолий Кулаков" Ну, наверное, культурологические моменты мы уже много обсуждали и, наверное, пришли к выводу, что это все полная чушь, и они больше не соответствуют действительности, но первые два пункта, мне кажется, довольно-таки важны, и на них стоит обратить внимание, то есть Microsoft тоже много делает для того, чтобы и сам язык, сама платформа не казалась такими монструозными, и на них можно было бы начать такую быструю прототипиевную разработку, то есть у нас там есть уже .NET U, .NET Template, .NET Build, .NET Run, которые позволяют вам просто практически с пустым файликом, с одной строчки уже начинать колбасить проект, и уже есть какие-то, пусть не до конца, коммерчески доступные IDE, которые позволяют вам начать хотя бы в маленьких командах уже что-то понятное делать.
6001.38 6016.38 "Анатолий Кулаков" В общем, направление в эту сторону есть для того, чтобы покорить как бы рынок стартапов, но, как мы видим, все еще недостаточно, все еще есть у нас динамические языки, которые нас обгоняют, все еще есть IDE, которые более бесплатные для коммерческих продуктов, которые лучше на других языках.
6016.38 6019.18 "Анатолий Кулаков" В общем, есть куда работать, есть где стремиться.
6019.18 6026.54 "Игорь Лабутин" Будем работать, будем стремиться увеличивать популярность .NET, рассказывать про это, все, что мы можем сделать.
6026.54 6029.62 "Игорь Лабутин" А команда Microsoft, надеюсь, все исправит.
6029.62 6034.42 "Игорь Лабутин" Да, и будет много классных бесплатных IDE, было бы здорово.
6034.42 6052.26 "Игорь Лабутин" Ну, давай, дальше у нас осталась одна не очень большая статья от автора, которого, мне кажется, мы довольно много использовали на ранних этапах жизни подкаста, но в это время практически не слышим, и он в "Праведливости ради" выпускает малую статью, и речь о Джоне Скитте.
6052.26 6056.18 "Анатолий Кулаков" Ну, да, практически перестал писать-то, тем более про
6056.18 6057.18 "Игорь Лабутин" .NET.
6057.18 6073.62 "Игорь Лабутин" Да, но .NET он продолжает использовать, он сейчас, я так понимаю, больше, не знаю, там, консультирует, не консультирует, в общем, занимается какими-то своими проектами, и вот когда у него попадаются какие-то интересные около .NET, и не только около .NET размышления на тему программирования, он тогда пишет статью.
6073.62 6077.30 "Игорь Лабутин" Но в этот раз она прям чисто .NET, и поэтому она у нас в выпуске.
6077.30 6087.14 "Игорь Лабутин" Он попробовал поработать с рекордами и с коллекшенами из этих рекордов, и делает кое-какие выводы, что удобно, что неудобно.
6087.14 6089.58 "Игорь Лабутин" Для начала напомню, что же такое рекорды.
6089.58 6126.58 "Игорь Лабутин" Рекорды — это такой специальный вид класса, ну или структуры, если очень хочется, но в данном случае речь про классы, которые, по сути, вы просто перечисляете в проперти, которые вы хотите в формате первичного конструктора, то есть просто прямо после объявления, паблик, рекорд, название вашего рекорда, и внутри круглых объектов набор полей, они же аргументы конструктора, они же проперти становятся, и компилятор делает все остальное за вас, то есть он за вас генерирует getHashCode, он за вас генерирует equals, ну и так далее.
6126.58 6148.62 "Игорь Лабутин" Кроме того, у вас есть синтактический сахар в виде оператора кодов, который позволяет в рекорде создавать новый инстанс рекорда, основываясь на каком-то существующем инстансе, обновляя какие-то поля, ну типа рекорды в идеале делаются immutable, или они у нас в принципе immutable?
6148.62 6149.62 "Игорь Лабутин" Не.
6149.62 6150.62 "Игорь Лабутин" Да.
6150.62 6151.62 "Игорь Лабутин" Да, они в принципе immutable.
6151.62 6158.74 "Игорь Лабутин" Да, что-то я уже путаю с этими, я что-то про правильный конструктор тут недавно читал, и уже в голове все путается.
6158.74 6162.90 "Игорь Лабутин" А у скита они еще и sealed все обязательно, чтобы отнаследоваться нельзя было.
6162.90 6167.14 "Игорь Лабутин" И вот как раз таки с equality возникают некоторые проблемы.
6167.14 6182.98 "Игорь Лабутин" Смотрите, по дефолту, когда код генерится для рекордов, компилятор использует equality comparer от типа t.default для сравнения каждого из полей друг с другом, где t — это тип поля.
6182.98 6192.38 "Игорь Лабутин" Все бы хорошо, но только до тех пор, пока этот самый equality comparer.default — это ровно тот comparer, который вы хотите использовать для этих полей.
6192.38 6201.76 "Игорь Лабутин" И в принципе для большинства типов все будет хорошо, но у него такой немножко нетривиальный тип — это immutable.list.
6201.76 6223.14 "Игорь Лабутин" Вот почему-то ему захотелось работать с immutable.list, но проблема в том, что immutable.list не оверрайтит у себя никаких equals и getHashCode вообще, и по сути для него equality comparer.default использует чисто референсную семантику, то есть если две ссылки одинаковые, значит классы одинаковые, если две ссылки разные, значит классы разные, все.
6223.14 6243.02 "Игорь Лабутин" А хотелось бы в данном случае использовать equality comparer, который посмотрел бы на количество элементов и сверил бы элементы попарно, т.е. два листа равны, если у него все листы равны, и выясняется, что невозможно никак задать equality comparer для одного свойства внутри рекорда.
6243.02 6244.02 "Игорь Лабутин" Что можно сделать?
6244.02 6247.70 "Игорь Лабутин" Можно в принципе переопределить equals и getHashCode внутри рекорда.
6247.70 6277.34 "Игорь Лабутин" Это можно сделать, это допускается, но в этом случае вам нужно написать самому по сути их, ну или ешка, понятно, сгенерит, но написать-то ладно, а второй момент не забывать обновлять, когда вы добавляете новые пропертиз, ну или что-то меняете, и это прям как-то не здорово, т.е. было бы здорово иметь какой-нибудь атрибутик, который можно было бы пометить какую-нибудь пропертиз, сказать, что вот для нее я хочу equality comparer такой-то, но нету, нету.
6277.34 6298.34 "Игорь Лабутин" Дальше вторая часть статьи, она наоборот про reference equality, что иногда наоборот хочется вместо того, чтобы использовать внутреннеструктурный какой-нибудь equality использовать reference equality, т.е. там по логике кода у него есть некоторые объекты, которые, если ссылки разные, то объект точно разный.
6298.34 6335.62 "Игорь Лабутин" Все бы здорово, он там, часть статьи жалуется, что нет такого, пока ему в комментариях не пришли, не сказали, да вообще-то есть, просто штука эта, она не дженериковая, у вас под какой-то reference equality, то нету смысла ее делать дженериковой, потому что это же reference, они все к объекту приводятся и все, для reference equality этого достаточно, поэтому есть на самом деле такой класс под названием reference equality comparer, который можно для этого использовать, соответственно, но скит молодец, он обновил кусочек этой статьи, сказал, что да, я был не прав, он на самом деле есть, все здорово, тут как бы команда поработала.
6335.62 6367.70 "Игорь Лабутин" Дальше он тоже сказал, что еще один кейс, когда хотелось бы нормально где-то что-то override, это сравнивать строки с учетом ordinal, но тут как бы ничего интересного, он просто нафигачил еще десятка-полтора новых экстенджент-методов, типа order by ordinal, order by ordinal descending, then by ordinal, ну и так далее, там всякие to ordinal dictionary, to ordinal lookup, короче, везде передавая правильные comparer.
6367.70 6372.58 "Игорь Лабутин" Пришлось написать кучу boilerplate кода, но с другой стороны дальше потом код стал почище.
6372.58 6390.78 "Игорь Лабутин" И последний момент — это primary constructor, четвертая часть статьи, и про то, что primary constructor — это прикольная фича, она действительно там уменьшает количество кода и все дела, но, блин, она не работает с Visual Studio нормально, внезапно.
6390.78 6417.26 "Игорь Лабутин" То есть он говорит, что я пользуюсь довольно много функцией под названием call_hierarchy, то есть если вы в дефолтной Visual Studio раскладке встанете на какой-нибудь мембер и нажмете ctrl-к, ctrl-т, то у вас должно быть по идее вьюжка, в которой будет написано всех, кто вызывает этот мембер и всех, кого вызывает этот мембер, ну и дальше, короче, по иерархии, будет такое дерево вызовов туда и обратно.
6417.26 6435.78 "Игорь Лабутин" А для primary конструкторов и для параметров рекорда find_reference работает, вы можете посмотреть, кто его вызывает именно с точки зрения find_reference, но вот это call_hierarchy, которое по сути-то то же самое, не работает, и это неудобно.
6435.78 6449.46 "Игорь Лабутин" А более того, для рекордов вот эти параметры, они же property, то есть по-хорошему должно быть, можно встав на property посмотреть, кто ее вызывает, но тоже не работает.
6449.46 6462.58 "Игорь Лабутин" При этом можно взять и раскрыть, если вы знаете, для рекорда как бы можно в Solution Explorer раскрыть этот cs-файлик и там будут внутри собственно все эти property перечислены.
6462.58 6472.02 "Игорь Лабутин" Ну не только для рекордов, по-моему так много для чего работает, тут структурное содержимое файлика он показывает, и вот там поиск работает нормально.
6472.02 6485.86 "Игорь Лабутин" Короче прям очень неудобно, я не смог попробовать сейчас, что-то у меня сегодня винда не загрузилась, но хотел попробовать, потому что я когда-то действительно пользовался этой call_hierarchy и мне нравилось.
6485.86 6492.42 "Игорь Лабутин" Вот в общем не работает, вижу у студии, в общем надо, но неудобно.
6492.42 6508.90 "Игорь Лабутин" Короче фича хорошая, фича удобная и quality comparer надо делать, пишет John Skid для команды Microsoft, сделать так, чтобы можно было задавать custom и quality comparer, чтобы можно было использовать нормально вижу у студию, для того чтобы все нормально работало.
6508.90 6519.14 "Игорь Лабутин" В общем ждем очередного какого-нибудь ужасного, не знаю, отличного синтеза, как задать custom и quality comparer для каждого из свойств внутри рекорда.
6519.14 6527.48 "Игорь Лабутин" Я с ужасом представляю эту портинку property, где собственно название property будет вообще не видны за списком атрибутов, но поглядим-поглядим.
6527.48 6534.50 "Анатолий Кулаков" Да-да, то есть уменьшали-уменьшали все эти классы, а потом все равно к тому же самому размеру и придем в конце
6534.50 6535.50 "Игорь Лабутин" концов.
6535.50 6551.02 "Игорь Лабутин" Ну может быть действительно, если вам нужно прям такое кастомное, действительно проще написать свой кастомный класс, не использовать рекорды, хотя бы они, ну тогда придется не забывать переписывать equals и хэш-код, либо делать их через source-генераторы, ну это тоже как-то.
6551.02 6560.42 "Анатолий Кулаков" Source-генераторы в принципе, если вам позволят именно расширить то, как рекорды генерируются, в общем ты можешь расширить именно source-генераторы, а не сам рекорд.
6560.42 6561.42 "Игорь Лабутин" Вот и все.
6561.42 6562.42 "Игорь Лабутин" Ну да, кстати.
6562.42 6563.42 "Игорь Лабутин" Можно попробовать.
6563.42 6570.38 "Игорь Лабутин" Так, ну и на этом у нас вроде как статьи закончили, я хотел только вкратко разным одну маленькую ссылочку рассказать.
6570.38 6573.98 "Игорь Лабутин" Наткнулся на очередное творчество Скотта Хансельмана.
6573.98 6601.02 "Игорь Лабутин" Они в этот раз вместе с Марком Русиновичем, небезызвестным автором комплекта утилит Sysinternals и книжки Windows Internals обсуждают внезапно не Windows Internals, не Sysinternals и в общем-то даже местами не программирование, а в формате такого подкаста, где эпизодики по, ну вот сейчас они пришли к получасовым, некоторые по 15 минут, по 12, по 20, обсуждают вообще разные темы.
6601.02 6626.48 "Игорь Лабутин" То есть первая была про то, что influence without authority, потом ну понятно, use AI, куда без этого, pick programming language, find joy in hobbies, а называется это все с контент марк learn to, то есть вот это вот то, что я говорю, он типа learn to, там типа public speaking, system thinking, короче всякие такие общечеловеческие, ну и околопрограммистские темы.
6626.48 6640.60 "Игорь Лабутин" В принципе, если вам интересно послушать, они в общем двое умных чуваков, возможно там будут какие-то интересные идеи, которые можно к себе утащить, я так в фоне слушаю, когда чем-нибудь занимаюсь, действительно практически в формате подкаста, звучит прикольно.
6640.60 6645.84 "Анатолий Кулаков" Всегда интересно поговорить, когда умные дядьки общаются, то есть послушать.
6645.84 6646.84 "Игорь Лабутин" Да.
6646.84 6673.28 "Игорь Лабутин" Все на этом, наверное, мы сегодня обсудили десятый превью, третий превью, поговорили про несуществующие лайфтаймы и как реализовать лайфтайм, который никому не нужен, рассмотрели то, как переписывали Nuget Restore в девятом дотнете, посмотрели, почему дотнет не выбирают в стартапах и на этом на сегодня все.
6673.28 6674.28 "Игорь Лабутин" И про скита.
6674.28 6682.48 "Игорь Лабутин" Про скита, да, про скита тоже поговорили, но там какая-то такая короткая тема, я что-то про нее поэтому забыл.
6682.48 6684.56 "Игорь Лабутин" А вот теперь точно на этом все.
6684.56 6692.36 "Анатолий Кулаков" Теперь точно все, до новых встреч, друзья, подписывайтесь, шарьте, репостите, рассказывайте о нас своим друзьям и всем счастливо.
6692.36 6693.36 "Анатолий Кулаков" Всем до новых встреч, пока.
6693.36 6694.36 "Игорь Лабутин" Пока.
