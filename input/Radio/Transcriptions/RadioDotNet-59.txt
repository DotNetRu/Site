0.00 12.20 "Анатолий Кулаков" Приветствую вас, дорогие друзья, в эфире Радио.нет и выпуск номер 59.
12.20 15.32 "Анатолий Кулаков" В студии его бессменный ведущий Анатолий Кулаков.
15.32 17.16 "Анатолий Кулаков" И Игорь Лaбутин, привет.
17.16 26.32 "Анатолий Кулаков" Во-первых, в строках своего письма хочется поблагодарить наших постоянных помогаторов – Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья и Гурий Самарин.
26.32 30.16 "Анатолий Кулаков" Спасибо вам, друзья, а также всем тем, кто пожелал остаться неизвестными.
30.16 42.00 "Анатолий Кулаков" Мы вас любим, мы про вас помним и если кто-то не знает, про что мы говорим, заходите на наш сайтик на Boosty и посмотрите, что интересно вам может предложить нас подкастик вне его основной деятельности.
42.00 63.76 "Игорь Лабутин" А кроме того, сегодня есть еще одно объявление, в ближайшее время уже довольно скоро начнется конференция .next, 3-4 ноября состоится онлайн часть, 20 ноября состоится офлайн часть, но она тоже будет транслироваться онлайн, поэтому даже если вы не в Москве, а офлайн будет происходить в Москве, то ее можно будет послушать онлайн, посмотреть.
63.76 71.56 "Игорь Лабутин" И мы приглашаем всех, в шоуноутах будет скидка на персональный билет, зачитывать не буду, там потом посмотрите.
71.56 73.88 "Игорь Лабутин" Да, по буквам и по цифрам.
73.88 88.76 "Игорь Лабутин" Да, так что приходите, будет интересно, доклады уже там, не могу сказать, наверное, что прям большая часть, но большая часть уже на сайте, но будут еще добавляться, так что смотрите, покупайте билетики, приходите, встретимся, мы там с Толей должны быть.
88.76 100.28 "Анатолий Кулаков" Да, обязательно, уникальное действие в двух частях, 1 часть онлайн, 1 офлайн, мы будем на обоих, поэтому ловите, обращайтесь, спрашивайте, мы всегда будем рады.
100.28 104.44 "Анатолий Кулаков" По-моему, с официальной части у нас все, давай к
104.44 108.64 "Игорь Лабутин" темам. Давай к темам, .07, релиз кандидат 2.
108.64 112.52 "Анатолий Кулаков" Да, релиз кандидат 2, и не просто 2, а последний.
112.52 123.16 "Анатолий Кулаков" Как торжественно заявили микрософтовцы, что это наконец последний релиз кандидат, теоретически третьего не будет, но, наверное, посмотрим, насколько тестировщики справятся с ломанием второго, конечно.
123.16 133.84 "Игорь Лабутин" Пока не сдерживали обещания, по-моему, вот уже 2 раза они говорили, ну, в 6 и в 5 дотнетах говорилось, что вот релиз кандидат 2 это последний, и он действительно был последним.
133.84 147.08 "Анатолий Кулаков" Ну и судя по изменениям, по тем новостям, которые мы сейчас с вами обсудим, там действительно уже стараются ничего не модифицировать, не ломать, не добавлять, наверное, только там перформанс модерируют и все в этом духе.
147.08 148.44 "Анатолий Кулаков" Давайте посмотрим поподробнее.
148.44 153.68 "Анатолий Кулаков" Прежде всего, что необычно в этом релиз кандидате, он поддерживается в продакшене.
153.68 164.20 "Анатолий Кулаков" Интересная особенность, наверное, как раз для того, чтобы большие компании уже пробовали его на настоящих нагрузках, на настоящих условиях и давали какой-то фидбэк, что тоже, в принципе, замечательно.
164.20 169.84 "Анатолий Кулаков" Из новостей, прежде всего, хотелось бы поговорить о breaking changes.
169.84 175.44 "Анатолий Кулаков" В принципе, System Text JSON немножко сломал нам старое поведение, но не то чтобы совсем сильно.
175.44 179.52 "Анатолий Кулаков" И изначально он умел создавать дефолтный серилизатор.
179.52 198.20 "Анатолий Кулаков" Если вы вдруг запрашиваете у автосгенерированного серилизатора, который вы сделали с помощью Source Generator, какой-нибудь серилизатор какого-нибудь определенного типа, и этого типа у него нет, он раньше делал серилизатор на основании рефлекшена, то есть стандартный, который получается у вас обычно.
198.20 207.24 "Анатолий Кулаков" Теперь же он этого делать не будет, он не будет вам по-тихому подсовывать рефлекшен серилизатор, он вам будет выдавать чистосердечную ошибку.
207.24 217.88 "Анатолий Кулаков" Потому что вы не обламывались, иначе вы будете рассчитывать на сгенерированный серилизатор, а он вам подсудит очень медленно, и это может сильно ухудшить ваши какие-то показатели или ожидания.
217.88 226.64 "Анатолий Кулаков" Но если вам вдруг все-таки старое поведение нравится больше, то, соответственно, в AppContext есть флажочек, который можно включить, и старое поведение к вам магически вернется.
226.64 232.44 "Анатолий Кулаков" Также добавились новые анализаторы для GenericMath.
232.44 238.60 "Анатолий Кулаков" Они позволяют более удобно использовать его API.
238.60 249.04 "Анатолий Кулаков" И анализатор нацелен на специальную конструкцию, которая называется Curiously Recurring Template Pattern, или сокращенно CRTP.
249.04 254.04 "Анатолий Кулаков" За этим мега сложным замысловатым названием скрывается совсем простая концепция.
254.04 261.44 "Анатолий Кулаков" Это когда класс X наследуется от какого-то generic класса, использующего класс X как шаблонный параметр.
261.44 272.12 "Анатолий Кулаков" Я думаю, всем вам известно это какой-нибудь IEquatable AT, который обычно является базовым интерфейсом для непосредственно класса, который от него наследуется.
272.12 275.20 "Анатолий Кулаков" Вот это по-научному, по-умному называется CRTP.
275.20 283.36 "Анатолий Кулаков" Хорошее название, классный паттерн, я его часто встречаю в коде, поэтому всегда прекрасно узнать, что у него есть нормально выделенное название.
283.36 293.76 "Анатолий Кулаков" Так вот, теперь анализаторы умеют проверять для таких интерфейсов, которые ожидают в качестве generic параметра сам класс, который наследуется от этого интерфейса.
293.76 295.36 "Анатолий Кулаков" Вот такой есть теперь анализатор.
295.36 303.72 "Анатолий Кулаков" Если вы вдруг ошиблись и подставили в generic параметр какой-то другой классик, он вам напомнит, бросит warning и скажет, что больше так не делайте.
303.72 311.44 "Анатолий Кулаков" Это в принципе полезно не только для generic math, но ввели именно вместе с ними.
311.44 318.04 "Анатолий Кулаков" Дальше немножко изменилось поведение int ptr и uint ptr.
318.04 325.36 "Анатолий Кулаков" С ними можно было делать разные безумия, например, складывать к int ptr прибавлять 2, отнимать 10, в общем всякие цифры складывать.
325.36 328.92 "Анатолий Кулаков" Это для указателей нормально, это математика для указателей.
328.92 337.12 "Анатолий Кулаков" И раньше, если вдруг этот результат, который получился в итоге, выходил за границу ptr, то ничего не происходило.
337.12 342.16 "Анатолий Кулаков" Все тихо, молча как бы проваливалось, просто отсекался результат и все.
342.16 347.44 "Анатолий Кулаков" Теперь поведение более приведено к стандартному поведению остальных классов в дотнете.
347.44 357.56 "Анатолий Кулаков" То есть, если вы используете unchecked контекст, unchecked блок, то как и раньше все будет проваливаться, исчезать и никаких проблем у вас не будет.
357.56 362.60 "Анатолий Кулаков" Если же вы будете использовать обычный сейв-код, то будет выбрасываться соответствующее исключение.
362.60 369.52 "Анатолий Кулаков" Это позволит как раз таки вам следить за переполнением указателей.
369.52 381.48 "Анатолий Кулаков" Также немножко ужесточили в ту же сторону немного кастинг указателей, потому что если кто-то каст отбрасывал какие-то значения, которые не влезали в target-тип, раньше ничего не происходило.
381.48 387.28 "Анатолий Кулаков" Теперь все будет более явное, будет больше исключений на неправильных конструкциях, что в принципе хорошо.
387.28 392.88 "Анатолий Кулаков" И на этом основные нововведения самого большого фреймворка заканчиваются.
392.88 397.12 "Анатолий Кулаков" Давайте посмотрим, что же нам предлагают остальные товарищи вокруг него.
397.12 399.12 "Анатолий Кулаков" В частности, ISP.Net Core.
399.12 408.12 "Анатолий Кулаков" ISP.Net Core тоже обновился и одним из самых значимых его нововведений это было улучшение output-cache.
408.12 414.16 "Анатолий Кулаков" А улучшился он тем, что к нему добавили бинарный сериализатор и теперь это сериализатор по умолчанию.
414.16 419.28 "Анатолий Кулаков" То есть весь контент, который он сейчас кэширует, сериализуется бинарно.
419.28 422.20 "Анатолий Кулаков" До этого, напомню, он все делал в JSON.
422.20 432.40 "Анатолий Кулаков" То есть раньше использовался JSON, соответственно бинарный сериализатор более быстрый, он дает более компактный результат и на этом тоже кэш выигрывает.
432.40 439.24 "Анатолий Кулаков" Он будет быстрее, будет мельче и удобнее для потребления.
439.24 449.80 "Анатолий Кулаков" Следующее изменение в кэше это в том, что по дефолту кэш ассоциировался четко с определенным доменом, то есть с определенным именем домена.
449.80 453.76 "Анатолий Кулаков" И соответственно между различными доменами кэш расшарить было невозможно.
453.76 470.64 "Анатолий Кулаков" Вот многие пользователи просили, чтобы это поведение поменяли и вот теперь у нас появился новый параметр, новый метод, который называется set_worry_by_host_false и он заставляет кэш теперь игнорировать хост и кэш, соответственно, можно держать между различными хостами.
470.64 480.12 "Анатолий Кулаков" Если вдруг вам по стратегии кэширования эта ситуация подходит, то этот флажок сильно сократит вам ресурсы.
480.12 486.20 "Анатолий Кулаков" В этом же время кэш_request обзавелся новой интересной оптимизацией.
486.20 491.72 "Анатолий Кулаков" Это штука, которая использовалась в аутентификации Blazor WebAssembly.
491.72 494.32 "Анатолий Кулаков" Про Blazor WebAssembly мы уже упоминали в предыдущих выпусках.
494.32 510.96 "Анатолий Кулаков" У него есть возможность делать аутентификацию через OpenID Connect и соответственно там же у него есть какие-то продвинутые сценарии, которые он может использовать, какие-то новые параметры, которые он может добавлять, и наоборот передавать.
510.96 519.96 "Анатолий Кулаков" И теперь его перевели, вот этот весь процесс, который из Blazor WebAssembly перевели на библиотеку msal.js.
519.96 527.72 "Анатолий Кулаков" Не знаю, ни разу не сталкивался с этой библиотекой, но утверждается, что она используется для Microsoft Identity Platform.
527.72 534.60 "Анатолий Кулаков" Очень сильно оптимизирована, очень полезная и наверняка Blazor она сильно поможет.
534.60 540.80 "Анатолий Кулаков" Другая, наверное, самая более интересная фича, которая у нас есть в этом списке, но, к сожалению, она в ряду экспериментальных.
540.80 545.64 "Анатолий Кулаков" В релизе мы ее не увидим, но это WebAssembly Multithreading.
545.64 550.60 "Анатолий Кулаков" Теперь появилась возможность в WebAssembly использовать множество трейдов.
550.60 557.88 "Анатолий Кулаков" На самом деле под капотом трейда используют WebWorker, которые есть в любом браузере практически.
557.88 564.76 "Анатолий Кулаков" И релиз этой фичи ожидается уже в рамках .NET 8.
564.76 575.80 "Анатолий Кулаков" Для того, чтобы вам поэкспериментировать сейчас, вы можете взять текущий релиз кандидат, установить workload в Asm.Experimental и уже поиграться с настоящими трейдами.
575.80 581.64 "Анатолий Кулаков" То есть можно сделать new thread, можно сделать thread sleep и вот такие базовые функции.
581.64 585.56 "Анатолий Кулаков" И вы увидите реально в консоли, что код выполняется более менее параллельно.
585.56 595.16 "Анатолий Кулаков" Для того, чтобы вся эта магия была возможным, у нас появился снова синхронизейшн контекст.
595.16 597.92 "Анатолий Кулаков" Это штука, от которой многие избавлялись.
597.92 604.88 "Анатолий Кулаков" Напомню, что в большом дотент фреймворке в ASP.NET он был, в ASP.NET Core он исчез.
604.88 608.44 "Анатолий Кулаков" Но не всегда получается от него избавиться.
608.44 612.84 "Анатолий Кулаков" Например, во всех UI фреймворках синхронизейшн контекст все еще на месте.
612.84 618.12 "Анатолий Кулаков" И вот браузер у нас здесь стал таким своеобразным UI фреймворком.
618.12 620.52 "Анатолий Кулаков" Поэтому синхронизейшн контекст снова на месте.
620.52 630.76 "Анатолий Кулаков" А это значит, что вы должны не забывать в своем коде выставлять "configure_await_false", если вам нужно выполнить задачу вне главного потока.
630.76 643.24 "Анатолий Кулаков" А если же вы оставите "configure_await_true", то ваши действия будут синхронизироваться с главным потоком и все действия будут выполняться непосредственно на нем.
643.24 652.84 "Анатолий Кулаков" Точно так же, как и с всякой UI, главный поток нужен для того, чтобы взаимодействовать с домом.
652.84 666.12 "Анатолий Кулаков" И синхронизейшн контекст выступает главным контекстом для того, чтобы итерироваться по дому, для того, чтобы этот дом менять и вообще всячески взаимодействовать с JS-библиотеками.
666.12 672.32 "Анатолий Кулаков" Если вы захотите поинтерапиться в JS-мир, то вам тоже необходимо переключиться в главный тред.
672.32 675.60 "Анатолий Кулаков" Дальше JS-Import, JS-Export.
675.60 679.12 "Анатолий Кулаков" Они тоже работают только из так называемого главного треда браузера.
679.12 689.48 "Анатолий Кулаков" Здесь стоит уточнить, что вот эти потоки в Blazor, в WebAssembly, они не работают на данный момент в Firefox, потому что там существует какой-то баг.
689.48 692.60 "Анатолий Кулаков" Я надеюсь, что ближайшим будущим этот баг пофиксят.
692.60 698.68 "Анатолий Кулаков" Еще хочется отметить, что асинхронные операции всегда были доступны в Blazor.
698.68 700.68 "Анатолий Кулаков" Они там были с самого начала.
700.68 708.44 "Анатолий Кулаков" То есть вы всегда могли сделать task, всегда могли сделать await, всегда могли сделать async, но при этом там не было множества потоков.
708.44 714.60 "Анатолий Кулаков" Это как раз-таки хороший пример, когда вас спрашивают, о чем асинхронность отличается от параллельности.
714.60 727.56 "Анатолий Кулаков" Вот типичный пример, когда WebAssembly работал асинхронно уже многие-многие годы, десятилетия, но при этом у него не было множества потоков, при этом он не был параллельным.
727.56 731.16 "Анатолий Кулаков" То есть вполне возможно работать асинхронно, но при этом не параллельно.
731.16 737.52 "Анатолий Кулаков" Из .NET MAUI у нас тоже вышел релиз Candidate 2.
737.52 741.44 "Анатолий Кулаков" Там в принципе ничего такого интересного не обновилось.
741.44 746.96 "Анатолий Кулаков" Конечно же и performance подтюнили и накидали множество ресурсов.
746.96 754.24 "Анатолий Кулаков" Как начать, как приступить, как я могу сделать то или это, к какому сообществу подключиться, где задавать вопросы.
754.24 763.90 "Анатолий Кулаков" Если вас какой-то из этих пунктов волнует, то перейдя по ссылке вы соответственно увидите больше подробной информации и сможете для себя найти какие-то полезные ресурсы.
763.90 775.72 "Игорь Лабутин" Прекрасно, действительно, новостей не то чтобы много, но какие-то изменения все-таки все еще происходят и наверное даже в финальной релизе будет о чем поговорить, а не просто вспомнить, что же изменилось за год.
775.72 782.32 "Игорь Лабутин" Остался еще не упомянутым Entity Framework Core, в этот раз действительно завезли что-то интересное.
782.32 791.00 "Игорь Лабутин" Прям удивительно, что в течение превьюшек, там были превьюшки, где как бы не было каких-то громких фич, а тут прям Rc2 уже появилась фича.
791.00 794.24 "Игорь Лабутин" Понятно, что она готовилась долго, но только сейчас про нее рассказали.
794.24 796.92 "Игорь Лабутин" Это работа с JSON-колонками.
796.92 808.20 "Игорь Лабутин" То есть если мы берем реликционную базу, как например там Postgres или SQL Server, в ней сейчас почти во всех современных базах можно вполне хранить JSON в колонках, многие так делают.
808.20 812.60 "Игорь Лабутин" Делают такую типа no-sequel поверх SQL базы данных.
812.60 819.20 "Игорь Лабутин" Вместо того чтобы генерить кучу каких-то там датчерных табличек и кучи колонок.
819.20 832.08 "Игорь Лабутин" Обычно такие базы данных поддерживают всякие разные расширенные языки запросов, назовем это так, для того чтобы в эти JSON-колонки можно было посмотреть, по ним можно было сортировать, фильтровать, даже обновлять немножко.
832.08 839.60 "Игорь Лабутин" И теперь в Entity Framework 7 появилась некоторая поддержка этих колонок, но про нее очень загадочно написано.
839.60 851.92 "Игорь Лабутин" Написано, что она провайдер-агностик, что подразумевает, что провайдер-агностик должна работать везде и всюду и универсально, но при этом написано, что работа со стороны провайдера тоже нужна, и поэтому она поддержана не для всех баз данных.
851.92 860.84 "Игорь Лабутин" Я вот не очень понял эту комбинацию провайдер-агностик и при этом нужна работа со стороны провайдера, но, короче, как-то они странно сделали.
860.84 866.20 "Анатолий Кулаков" Я думаю, это обозначает, что среди тех провайдеров, которые поддерживают JSON-колонки, она агностик.
866.20 877.60 "Игорь Лабутин" Возможно, либо если база поддерживает более-менее стандартный JSON-синтекс, потому что, наверное, какие-то основные операции более-менее у всех одинаковые, но со всеми деталями могут отличаться.
877.60 883.52 "Игорь Лабутин" Я вот, например, не помню навскидку разницы в JSON-синтексе между Postgres и SQL Server, по-моему, есть.
883.52 901.84 "Игорь Лабутин" И, ну, F Core, как бы, хорошо бы… Ну, хотя это провайдер все равно занимается конвертацией этого дела в реальный SQL, поэтому, скорее всего, оно провайдер-агностик в смысле полного функционирования, но провайдер должен, естественно, реализовать трансляцию этих конструкций в, собственно, JSON.
901.84 910.48 "Анатолий Кулаков" Ну, так же, как и обычный SQL, у тебя же все функции там в зависимости от Postgres или MS SQL или Oracle, SQL разные получаются, и функции они разные у них.
910.48 911.48 "Игорь Лабутин" Да.
911.48 913.28 "Игорь Лабутин" Но, видимо, в этом смысле провайдер-агностик и есть.
913.28 922.12 "Игорь Лабутин" В смысле, что провайдеру не нужно знать прямо детали того, как что апдейтить, просто транслируй вот селектом в нужный JSON-селектом и так далее.
922.12 927.24 "Игорь Лабутин" Кроме селектов, собственно, поддержано на самом деле даже обновление и сохранение изменений в этих колонках.
927.24 929.32 "Игорь Лабутин" Сейчас поговорим про это чуть подробнее.
929.32 931.00 "Игорь Лабутин" Как вообще все это работает?
931.00 956.88 "Игорь Лабутин" Вообще, Entity Framework поддерживает такую штуку, которая на английском называется Owned Types, на русский, ну вот, мы это переводили как собственные типы, то есть вы объявляете тип, он является там пропертюой в вашем большом объекте, но если его правильно поместить как Owned Type, то все поля этого типа, они не будут сохраняться в отдельной табличке, а будут прямо вставлены в колонками в основную табличку того объекта, в котором эта пропертия лежит.
956.88 970.32 "Игорь Лабутин" Так, обычно, не знаю, удобно какой-нибудь адрес, например, заводить прям отдельную табличку с форенки EOM для того, чтобы хранить адрес, например, кого-то, может быть слишком overkill, ну потому что это лишний join, потом при выборках и так далее.
970.32 981.64 "Игорь Лабутин" Если у вас в этом объекте не очень много полей, то проще его отметить как Owned Type, и все эти поля будут просто являться колонками внутри основной большой таблицы.
981.64 998.84 "Игорь Лабутин" Так вот, можно на самом деле Entity Framework сказать, что нет, все-таки, хоть это и Owned Type, но пожалуйста, мап его в большую отдельную табличку, для этого через Builder вы указываете ему OwnedNavigationBuilder.toTable, и тогда он будет мапиться именно в табличку.
998.84 1008.88 "Игорь Лабутин" Так вот, теперь там появился новый метод расширения, там можно теперь сказать toJSON, и тогда все эти Owned типы, для тех, для кого указано toJSON, будут мапиться в JSON-колонке.
1008.88 1019.56 "Игорь Лабутин" То есть, если у вас, например, есть адрес, есть улица, дом какой-нибудь, индекс и город, то это не будут теперь 4 колонки, а одна колонка, где будет JSON-чик с 4 полями.
1019.56 1027.24 "Игорь Лабутин" Причем поддерживается произвольный уровень вложенности, то есть если у вас в том объекте есть еще Owned Type, они будут соответственно вложенными объектами в JSON, ну и так далее.
1027.24 1053.72 "Игорь Лабутин" При кверках вы теперь просто пишете, как обычные ваши linq кверки, поскольку это все нормальные пропертии, и вложенность нормальных объектов C# вы пишете абсолютно нормальные обычные linq квери без каких-либо специальных методов расширения, которые, ну знаете, есть там типа EF, там точка functions, да, специальные всякие namespaces, специальные классы, где статическими методами сделаны именно специальные функции.
1053.72 1056.64 "Игорь Лабутин" Здесь ничего такого не нужно, вы просто пишете обычный linq.
1056.64 1070.00 "Игорь Лабутин" А EF знает, что это за счет вот этих вот билдеров и методов toJSON, что оно лежит внутри JSON, и конкретно эти кусочки linq-запросов будут преобразованы в нужные JSON-операторы.
1070.00 1088.84 "Игорь Лабутин" При апдейтах, если entity framework поймет, что апдейт конкретный обновляет только кусочек вот всего JSON-дерева большого, то он генерирует код, который обновит только кусочек этого дерева, а не весь JSON-объект.
1088.84 1095.28 "Игорь Лабутин" То есть он прям, если база данных поддерживает частичное обновление JSON-колонки, то будет генерирован именно такой код.
1095.28 1104.24 "Игорь Лабутин" При этом это все еще пока, конечно, поскольку только-только запилили, там есть еще кучка ограничений, там что-то не работает на каких-то базах.
1104.24 1109.92 "Игорь Лабутин" Смотрите внимательно на GitHub issues, они, поскольку только-только все это зарелизили, то там регулярно что-то находится.
1109.92 1121.08 "Игорь Лабутин" Но вообще популярность этого подхода довольно велика, и поэтому, скорее всего, с учетом того, что в данном случае это прям поддержано в самом EF-коре без каких-либо экстендженов, наверное, это обретет какую-то популярность.
1121.08 1131.32 "Анатолий Кулаков" Интересно, а это только на резолюционной базе у них будет такая штука или на документно-ориентированной, там всякие монги, космосы, это тоже распространяется?
1131.32 1139.04 "Игорь Лабутин" На космос это точно должно распространяться, потому что космос entity framework поддерживает нативно, ну или там, понятно, есть, короче, провайдер.
1139.04 1147.36 "Игорь Лабутин" Я что-то, кстати, не знаю, у нас есть провайдер, я вот не помню, никогда не пробовал с монгой через EF работать, честно скажу.
1147.36 1149.00 None Я не уверен, есть вообще провайдер.
1149.00 1155.56 "Анатолий Кулаков" Я помню, что там был провайдер, когда только на кор переносили, потом его выпилили и сейчас, по-моему, все еще не доделали, то есть его как-то забросили.
1155.56 1187.40 "Игорь Лабутин" Ну, часть провайдеров, понятно, вернее, наверное, все, кроме SQL-сервера и, может быть, MySQL они сторонние же, потому что мне кажется, что команда в основном, сама команда EF-кора, ну понятно, что точно есть в Microsoft те, кто поддерживает SQL-серверный провайдер, и почти во всех статьях очень часто идет MySQL, потому что, видимо, он довольно простой, ну относительно, конечно, и как-то его провайдеры, мне кажется, тоже Microsoft к нему имеет отношение, но я могу ошибаться, тоже не работал с MySQL, из EF-кора никогда, из дотната в принципе.
1187.40 1203.88 "Игорь Лабутин" Но вот, ну понятно, что Postgres есть, потому что Шай Раянский, который в команде EF-кора, он же основной мейн-тренер NPG SQL, и тут как бы, ну очевидно, что он более-менее знает, что происходит в EF-коре, и тут же драйвер свой же, ну, провайдера своего подправляет.
1203.88 1208.88 "Игорь Лабутин" Вот, а остальные базы, я что-то как-то прям даже не знаю, что там с провайдерами.
1208.88 1226.96 "Анатолий Кулаков" Вообще странно, что они зарелизили поддержку такого важного штуки, как JSON в революционных базах, о которых там обычно трубят, а все трубы несколько лет подряд, как тот же самый Postgres, тот же самый MySQL взять, в общем, они зарелизили как последнее изменение в последнем релиз кандидате, и когда это все тестить, когда искать баги, когда
1226.96 1234.12 "Игорь Лабутин" репортить? Может, они весь год этим занимались, я по рекрестам не смотрел, насколько это давняя история, может быть, они весь год все это делали.
1234.12 1236.64 "Анатолий Кулаков" Сейчас просто анонс такой сделали, да?
1236.64 1238.68 "Игорь Лабутин" Да, может быть.
1238.68 1243.60 "Игорь Лабутин" Хорошо, давай пойдем дальше, дальше у нас будет…
1243.60 1259.48 "Анатолий Кулаков" Там интересный такой чувак всплыл, Adam Sittnick называется, который обычно перформансом занимается, и мне кажется, что сейчас он прооптимизировал самую главную функцию, которая всем нам мешала жить, которой все из нас, я уверен, упирались по перформансу, функция называется Console.readKey.
1259.48 1272.56 "Игорь Лабутин" Да, причем надо сказать, что, ну, сделано это было на самом деле еще в релиз кандидате 1, по правде, судя по статье, но статья просто… Да ладно, зачем он это сделал, ты скажи?
1272.56 1310.04 "Игорь Лабутин" Причем смотри, ну, Console.readKey – это действительно очень полезная функция, которую мы часто используем в наших тестовых консольных программах, чтобы дождаться энтера, прежде чем он, значит, что-нибудь выведет, но фишка в том, что основные проблемы с этой функцией были на Unix и Linux, и вот тут я как бы, ну, короче, изменить, наверное, хорошее и правильное, но ведь, ну, я не знаю, как бы, понятно, что у нас, наверное, большинство разработчиков с точки зрения работы, именно там, где ты запускаешь консольные программы, которые ждут Console.readKey, ты это делаешь либо на винде, на которой ты сидишь и разрабатываешь, либо на Маке, ну, если у тебя MacBook.
1310.04 1324.48 "Игорь Лабутин" Я вот не знаю про macOS, кстати, почти не было никаких упоминаний в статье, там чуть-чуть где-то упоминалось, но основная функция это Linux.unix, но на Linux.unix, когда я, видимо, уже в Prod, да, именно туда я обычно свой дотл.
1324.48 1334.76 "Игорь Лабутин" антенн.суф. в Prod, там мне как-то Console.readKey никогда не был нужен, но, видимо, мои сценарии какие-то не те, и есть те, кто на это много раз жаловался.
1334.76 1367.16 "Игорь Лабутин" Короче, жалобы были, и они были долгое время, Console.readKey это очень давняя функция, которая давным-давно не переписывалась, и когда .NET Core получил поддержку на Linux.unix, ну, туда была перенесена, конечно, частичная реализация из виндо-тотнета, но была добелена для Unix.linux, и, короче, там были прям дофига багов, прям на самом деле очень много, особенно были проблемы со всякими модифайерами и комбинациями, то есть вот нажал ты в терминале Ctrl+Alt+F3, и что с этим делать?
1367.16 1369.84 "Игорь Лабутин" Что возвращать через Console.readKey?
1369.84 1384.16 "Игорь Лабутин" Потому что штука эта должна вернуть именно кей-коды, то есть тебе должен вернуться, не знаю, флаговый еномчик, ну или массив, я не помню, в чем там возвращать точно, где будет написано, что ты нажал F3, и при этом были нажаты Ctrl+Alt, и вот с этим, короче, было много проблем.
1384.16 1396.04 "Игорь Лабутин" И, видимо, они решили, что ну окей, то ли делать было нечего, то ли, ну, как бы действительно проблем много накопилось, давайте это пофиксим, ну, давайте, хорошо, первый вопрос, а как мы это тестировать будем?
1396.04 1410.52 "Игорь Лабутин" Ну, то есть это Console.readKey, это штука, которая требует ввода пользователя, неплохо бы это как-то тестировать, желательно автоматически, потому что мы будем рефакторить, и очевидно, ну, все мы знаем, да, unit test - это лучший способ проверить, что мы зарефакторили правильно, непонятно как.
1410.52 1426.64 "Игорь Лабутин" Можно было бы что-нибудь замокать, ну, то есть внутри Console.readKey, да, заинжексить какой-нибудь интерфейсик, который в unit test будет override, или там подсовывается реализация, и туда будет, значит, впихиваться, ну, не реальный ввод пользователя, а, значит, фейковый, тестовый.
1426.64 1435.68 "Игорь Лабутин" Но проблема в том, что, во-первых, сейчас нет такой абстракции, куда это подсунуть, ну, нет в Console.readKey реализации такого места, куда можно что-то мокнуть.
1435.68 1457.40 "Игорь Лабутин" А второе, значит, их нужно было бы добавлять, если мы их добавим, то это, ну, до некоторой степени типа какой-то более-менее public API, пусть он будет internal, но это все-таки API, его надо поддерживать, и, по сути, в обычной работе у тебя появляется цена за, ну, за вызов, то есть это будет какой-то виртуальный вызов, это будет интерфейс.
1457.40 1466.92 "Игорь Лабутин" Да, у нас есть Tired Compilation, вот это все, или Tiered, Tiered, наверное, все-таки правильнее говорить, Tired — это очень уставшая компиляция, не надо так говорить, пусть будет Tiered.
1466.92 1482.36 "Игорь Лабутин" Компиляция, которая, понятно, что вам все это быстренько оптимизирует, если вы часто вызываете, но все равно, в общем, ради unit test чисто генерить какую-то mock на достаточно hotpath, опять же, я не знаю, где эти hotpath реализуются, но где-то, наверное, есть, не будем, не хотим.
1482.36 1485.16 "Игорь Лабутин" Короче, они сделали следующую штуку.
1485.16 1489.56 "Игорь Лабутин" Они написали приложенку, которая делает следующее.
1489.56 1501.44 "Игорь Лабутин" Она просит пользователя нажать определенную комбинацию, то есть она пишет на терминал буквально «нажми, пожалуйста, Ctrl+Alt+F3», после чего читает с терминала, что терминал тебе прислал.
1501.44 1511.44 "Игорь Лабутин" Но читает она это не через Console.idKey, а прямо через libc, то есть вот прям поток байтов, что там терминалка нам прислала, fastad.
1511.44 1522.48 "Игорь Лабутин" И понятно, что есть вот набор GitHub, и видим, каких-то их внутренних issues, где кастоверы на что-то жаловались, плюс они накидали туда еще сколько-то.
1522.48 1526.20 "Игорь Лабутин" В итоге у них получилось примерно 2000 тестов.
1526.20 1535.28 "Игорь Лабутин" То есть был где-то человечек, который сказал, который сел и аккуратненько 2000 раз нажал нужные комбинации клавиш.
1535.28 1536.28 "Игорь Лабутин" Бедный человечек.
1536.28 1542.48 "Игорь Лабутин" Но зато это сгенерилось, записалось, и на этом основе у тебя готовый набор тестовых данных.
1542.48 1545.80 "Игорь Лабутин" Надо сказать, что это не значит, что там было 2000 комбинаций.
1545.80 1548.80 "Игорь Лабутин" Комбинаций там было меньше, но их нужно было протестировать на разных терминалах.
1548.80 1555.68 "Игорь Лабутин" Они тестировали на Xterm, на Gnome, на Linux-консоли, на Windows-терминале, в котором ты по SSH заланимился в какой-то Linux.
1555.68 1565.80 "Игорь Лабутин" В терминале xut-unicode, я небольшой специалист по Linux, не знаю, что это такое, PuTTY, во, это мне знакомо.
1565.80 1568.32 "Игорь Лабутин" Причем с PuTTY там было много разных интересных моментов.
1568.32 1588.08 "Игорь Лабутин" Что в PuTTY ты можешь сказать, пожалуйста, эмулируй терминал Xterm, но при этом нужное переменное окружение, терм, которое будет очень важно дальше, запиши что-нибудь другое, что ты там в t100.
1588.08 1592.24 "Игорь Лабутин" И как бы вот эмулирует одно, а репортит что-то другое.
1592.24 1594.04 "Игорь Лабутин" И с этим тоже были определенные сложности.
1594.04 1598.36 "Игорь Лабутин" Ну и Tmux, который тоже популярен для одновременной работы в куче терминалов.
1598.36 1604.84 "Игорь Лабутин" Короче, все это запустили, сгенерировали, получились порядка двух тысяч тестов на основе этого дела.
1604.84 1616.56 "Игорь Лабутин" А, ну и дальше, соответственно, сделали такую штуку, то есть дальше понятно, что можно не сам readkey тестировать, а по сути только кусочек парсера, который берет этот поток байтов и из него получают кейкоды, которые потом возвращаются из readkey.
1616.56 1622.24 "Игорь Лабутин" Вот этот парсер, его можно, ну это просто отдельный функциональный блок, его потестировать.
1622.24 1625.64 "Игорь Лабутин" Короче, из этих двух тысяч тестов упали сразу тысячи.
1625.64 1628.92 "Игорь Лабутин" То есть вот на текущей реализации половина тестов просто не работает.
1628.92 1629.92 "Анатолий Кулаков" Неплохо, неплохо.
1629.92 1631.48 "Анатолий Кулаков" Видимо, этим никогда никто не пользовался.
1631.48 1639.28 "Игорь Лабутин" Нет, этим пользовались, половина, ну не половина, часть из этих тестов упали, потому что это были реальные извинения.
1639.28 1644.12 "Игорь Лабутин" То есть ты берешь git hub issue, в котором написано, чуваки, у вас не работает там control alt f12 в терминале.
1644.12 1645.12 "Игорь Лабутин" Ты такой, добавляешь этот тест?
1645.12 1646.68 "Игорь Лабутин" Ну да, не работает, тест падает.
1646.68 1651.44 "Игорь Лабутин" Как бы, ну, логично, что он упал, было бы странно, если бы он прошел.
1651.44 1652.44 "Игорь Лабутин" Вот.
1652.44 1659.24 "Игорь Лабутин" Но они пошли чуть дальше, они добавили каких-то своих, короче, комбинаций дополнительных, и вот они там тоже некоторые не работали.
1659.24 1664.48 "Игорь Лабутин" Ну, в общем, вот эта история, как мы это будем тестировать.
1664.48 1666.60 "Игорь Лабутин" Наша задача сделать так, чтобы две тысячи тестов прошли.
1666.60 1667.60 "Игорь Лабутин" Ну, задача Адама была.
1667.60 1674.68 "Игорь Лабутин" Это, на самом деле, конечно, интересно, когда ты берешь две тысячи тестов, у тебя тысяча падает, и ты такой, окей, понятно, что работа есть.
1674.68 1687.48 "Игорь Лабутин" И как бы есть тут точное понимание, как мне кажется, что здесь нет, знаешь, такое бывает, что типа у тебя там, не знаю, падает тысяча тестов, но ты понимаешь, что, типа, фиксив там что-то одно, у тебя там типа половина из них сразу станет паст.
1687.48 1699.44 "Игорь Лабутин" Вот тут, мне кажется, случай, когда ты понимаешь, что нет, у тебя там десять разных терминалов, миллионы разных комбинаций кодов, ну не миллионы, но сотни, и явно что-то тут, не что-то одно надо фиксить.
1699.44 1704.72 "Игорь Лабутин" Как это все работает внутри на самом деле, чтобы было понятно, что тут можно пытаться делать.
1704.72 1711.00 "Игорь Лабутин" Значит, когда вы что-то нажимаете на клавиатуре, понятно, что это все конвертируется в какие-то события при звонке.
1711.00 1712.00 "Игорь Лабутин" Ну, типа, внутри там.
1712.00 1720.64 "Игорь Лабутин" В принципе, это Windows Event, там VM, KDAW, KApp, вот это все.
1720.64 1724.00 "Игорь Лабутин" Значит, в других приземах там, соответственно, другие какие-то ивенты.
1724.00 1729.12 "Игорь Лабутин" Некоторые из этих событий обрабатываются самой операционкой.
1729.12 1732.48 "Игорь Лабутин" Перехватить Alt+F4 в Windows на самом деле довольно сложно.
1732.48 1735.44 "Игорь Лабутин" Ну или Ctrl+Alt+Del, да, известный всем.
1735.44 1741.04 "Игорь Лабутин" Наверное, на уровне драйвера где-нибудь очень низко уровнем его можно, но и то, по-моему, нельзя.
1741.04 1743.76 "Игорь Лабутин" Я уж не вспомню, давно драйверами не занимался.
1743.76 1748.44 "Игорь Лабутин" Некоторые, напоминаю, мы живем в терминале, да, некоторые будут хендлиться самим терминалом.
1748.44 1753.96 "Игорь Лабутин" Например, Ctrl+C или там Ctrl+Z очень часто в терминале хендлятся самим терминалом.
1753.96 1763.48 "Игорь Лабутин" В Linux это обычно просто посылка одного из сигналов, да, то есть это аналог того, чтобы сделали kill и там, послали какой-нибудь C-Hub, C-Term, вот это все.
1763.48 1766.08 "Игорь Лабутин" Все остальное, естественно, проводится в приложении.
1766.08 1767.08 "Игорь Лабутин" Дальше.
1767.08 1781.20 "Игорь Лабутин" Некоторые комбинации, ну то есть понятно, что ивент несет в себе не один там байтик, да, то есть если вы нажали букву А, ну окей, там будет один байтик, где будет код, ну какой там, 65, да, ASCII код, грубо говоря, буква А английской.
1781.20 1786.04 "Игорь Лабутин" Если нажали единичку, будет, не помню, какой единички код, но неважно сейчас.
1786.04 1792.00 "Игорь Лабутин" А вот если вы нажали там Ctrl+Alt+Shift, что-нибудь вот такое вот, то понятно, что будет набор байтов.
1792.00 1798.92 "Игорь Лабутин" И вот набор этих байтов, он сильно зависит, интерпретация этих байтов сильно зависит от того, что умеет терминал и операционка.
1798.92 1806.16 "Игорь Лабутин" И консоли редки, собственно, получают этот набор байтов из терминала и должны с ним что-то сделать, понять по этому набору байтов вообще, что тут написано.
1806.16 1807.16 "Игорь Лабутин" Вот.
1807.16 1815.68 "Игорь Лабутин" А терминал, соответственно, получает набор байтов от операционки, их как-то обрабатывает и пересылает какие-то коды, значит, уже в приложение.
1815.68 1817.36 "Игорь Лабутин" Что делала старая реализация?
1817.36 1822.76 "Игорь Лабутин" Старая реализация была, брала переменную терм для того, чтобы понять, в каком терминале мы работаем.
1822.76 1837.20 "Игорь Лабутин" Дальше в линуксе у тебя есть что-то под названием терм.инфо, это такая некоторая база данных, назовем это так, где собраны, на самом деле, просто известные input sequences, и там сказано, если вам пришли байты вот такие-такие-такие, это значит типа там control, alt и, значит, символ какой-то.
1837.20 1843.00 "Игорь Лабутин" Проблема, там не определены все комбинации, особенно со всеми модифиерами.
1843.00 1850.60 "Игорь Лабутин" И вторая проблема, которую я говорил выше, про пути, переменное окружение терм, ну, как бы, верить не всегда можно.
1850.60 1852.28 "Игорь Лабутин" Вы ее можете легко переопределить.
1852.28 1855.16 "Анатолий Кулаков" Интересно, а как другие framework обходят эту проблему?
1855.16 1861.64 "Анатолий Кулаков" Ну, это ж наверняка не первый раз, когда какой-то язык программирования решил считывать хоть-таки из консолей, из терминалов.
1861.64 1862.64 "Анатолий Кулаков" Не знаю.
1862.64 1875.56 "Игорь Лабутин" В статье про это не сказано, я небольшой специалист вот особенно в линукс-терминалах, не знаю, возможно, тоже там есть свои проблемы, а может быть, они используют то, что делает new implementation вот сейчас, которое, как бы, я расскажу.
1875.56 1878.56 "Игорь Лабутин" Значит, в чем состоял fix?
1878.56 1885.84 "Игорь Лабутин" fix, на самом деле, довольно, ну, как бы, я ожидал типа new implementation, сейчас мы все выкинули старое, сейчас мы все перепишем вообще с нуля, там, машинное.
1885.84 1889.44 "Анатолий Кулаков" Короче, pull request было сделать в терминал, чтобы там все
1889.44 1898.24 "Игорь Лабутин" комбинации были. Еще раз, в терминал будут все комбинации, но в пути ты не можешь гарантировать, что терм тебе описывает ровно тот терминал, в котором ты сейчас находишься.
1898.24 1901.60 "Анатолий Кулаков" Не, ну для пути можно сказать, что они сами дураки, раз они так поступают.
1901.60 1910.16 "Игорь Лабутин" Ну, короче, там, видимо, ну, операционок много, терминал ты везде не обновишь, вот.
1910.16 1913.08 "Игорь Лабутин" Особенно в линуксе, да, сколько там операционок разных.
1913.08 1915.80 "Игорь Лабутин" Да еще и на серверах, где не все будут обновляться на последнюю версию.
1915.80 1917.56 "Игорь Лабутин" Pull request ты можешь это сделать, да.
1917.56 1919.68 "Игорь Лабутин" Ну, лет через 10 дойдет, когда мы попробуем все.
1919.68 1921.68 "Игорь Лабутин" А они работают уже сейчас, нехорошо.
1921.68 1923.24 "Игорь Лабутин" Короче, новая реализация, она делает следующее.
1923.24 1926.44 "Игорь Лабутин" Сначала берем старый алгоритм и пытаемся по нему что-нибудь сделать.
1926.44 1931.16 "Игорь Лабутин" То есть, ну, как бы, верим терму, берем термоинфу, если там все написано и все совпало, ну, отлично, зашипись, все работает.
1931.16 1943.16 "Игорь Лабутин" А вот если не смогли, то мы берем вот этот набор байтов, который к нам пришел от терминала и пытаемся по тому, что оно к нам пришло, угадать, а что это за терминал.
1943.16 1952.52 "Игорь Лабутин" То есть там известно, что, например, я сейчас могу набрать, но условно известно, что xterm, все вот такие хитрые комбинации начинают со слова escape и заканчивают тильдой.
1952.52 1958.12 "Игорь Лабутин" А набор в серединке, это, собственно, вот описывает, какие клавиши были нажаты, какие к ним модификаторы нажаты.
1958.12 1967.08 "Игорь Лабутин" Ну, вот как бы, если вам пришел набор байтов, который подходит под паттерн escape и в конце тильдочка, давайте попробуем пропарсить это, как будто это xterm'овская комбинация.
1967.08 1971.60 "Игорь Лабутин" Если вдруг совпало, вау, супер, мы считаем, что мы угадали.
1971.60 1983.40 "Игорь Лабутин" Ну, если не совпало, ну, как бы мы тупо возвращаем весь этот набор байтиков, как будто это русские символы, то есть в терминал прямо будет написано escape, там квадратная скобочка, что там, не помню.
1983.40 1986.20 "Игорь Лабутин" Чиселка точка с запятой, по-моему, другая чиселка тильдочка.
1986.20 1997.60 "Игорь Лабутин" Вот вообще перед точкой с запятой это типа код основной клавиши, а после точкой с запятой это набор, это флаговый, короче, признак разных модификаторов, control, alt, shift, вот это все.
1997.60 1998.60 "Игорь Лабутин" Вот такой алгоритм.
1998.60 2007.88 "Игорь Лабутин" В статье, к сожалению, не сказано, все ли тысячи тестов, две тысячи тестов стали проходить после него, но вероятно, как бы раз статья написана, наверное, много стало.
2007.88 2011.40 "Игорь Лабутин" У метода все еще есть ограничения.
2011.40 2020.00 "Игорь Лабутин" Значит, проблема в том, что большинство терминалов по историческим причинам некоторые комбинации клавиш мапят в одно и то же.
2020.00 2026.36 "Игорь Лабутин" То есть большинство линуксовых терминалов, как я понял, например, control+h мапят всегда в backspace.
2026.36 2031.40 "Игорь Лабутин" Вот как бы невозможно в терминале нажать control+h, это всегда будет backspace, один и тот же код.
2031.40 2037.28 "Игорь Лабутин" То есть вам физически не придет тот факт, что был нажат control+h, вам придет был нажат backspace, и вы ничего с этим сделать не можете.
2037.28 2040.64 "Игорь Лабутин" И таких вещей довольно много.
2040.64 2049.88 "Игорь Лабутин" Некоторые терминалы, согласно статье, например, когда вы нажимаете control+цифры, то есть 1, 2, 3, 4, 5, да, и control+1, 2, 3, 4, 5, control вам присылаться не будет в этом случае.
2049.88 2052.04 "Игорь Лабутин" Ну вот так себя ведет терминал физически.
2052.04 2057.84 "Игорь Лабутин" Вот control+a пришлет, что это control+a, а control+1 все равно пришлет просто 1.
2057.84 2058.84 "Игорь Лабутин" Как ни крутите.
2058.84 2067.04 "Игорь Лабутин" Поэтому, скорее всего, конечно, часть тестов продолжила падать, но в целом стало лучше, раз уж прямо аж статья.
2067.04 2074.08 "Игорь Лабутин" И как всегда, Microsoft на самом деле сейчас довольно много делает, какую статью обозреваем, и везде есть compatibility mode.
2074.08 2085.96 "Игорь Лабутин" Мы уже сегодня какое-то упоминали про Assistant.exe с JSON, да, но там был breaking change, а здесь никаких breaking change нет, то есть старый алгоритм все еще работает, но если он не сработал, мы пытаемся еще что-то, какую-то логику навернуть.
2085.96 2104.84 "Игорь Лабутин" Тем не менее, если вам эта логика почему-то не нравится, вы можете вернуть старое поведение, поставьте в runtime.config.json файлик и настроечку system.console.usenet6compat_read_key в true, ну или переменное окружение, такую же dotnet.system.console.usenet6compat_read_key в единичку, и будет как раньше.
2104.84 2123.20 "Игорь Лабутин" Но эта штука, в флаг смысле, будет удалена в восьмерке до следующего 12, через год, так что если вы вдруг сталкивались с багами консоли ReadKey на Linux и Unix, попробуйте, что сделали в семерке, потестируйте, если все еще найдете баги, пишите в GitHub, в восьмерке пофиксят и уберут любую compatibility с прошлой версии.
2123.20 2124.20 "Игорь Лабутин" Как-то так.
2124.20 2125.20 "Анатолий Кулаков" Ну неплохо, неплохо.
2125.20 2134.56 "Анатолий Кулаков" Странно, конечно, что Adam этим занялся, он обычно там всякие performance настраивает, а тут вроде задача чисто техническая, пойти на всякие и поправить.
2134.56 2152.96 "Игорь Лабутин" Ну я так понимаю, что… ну да, тут скорее было, видимо, так, возможно, можно было бы придумать какой-нибудь алгоритм, где за счет потери performance можно было сделать более точное распознавание, здесь было интересно сделать… хотя, блин, все равно, они сначала одно, потом другое угадывают.
2152.96 2162.84 "Игорь Лабутин" То есть по сути они немножко добавили latency в каком-то смысле, да, реакции на клавиши, потому что если что-то не распознали, то мы двойную логику исполняем.
2162.84 2167.12 "Игорь Лабутин" С третьей стороны, ну блин, чтение с клавиатуры, мне кажется, не то место, где нужно за performance бороться.
2167.12 2181.36 "Анатолий Кулаков" Ну именно так, мне кажется, здесь больше такие интеграционные проблемы, то есть нужно было пойти по Linux, пойти по StaticDB, собрать информацию, как это у других работает, как-то это систематизировать, обработать, распространить, договориться.
2181.36 2183.80 "Анатолий Кулаков" То есть это не работа Адама, что он там делает-то?
2183.80 2186.20 "Анатолий Кулаков" Ну я понимаю, но полрекласс был от него.
2186.20 2192.20 "Анатолий Кулаков" Неужели же весь performance настолько вылизан, что всех перформансников заставляют интеграцию с Linux делать?
2192.20 2200.76 "Игорь Лабутин" Может быть он наоборот на своей перформансной работе так продвинулся во всех этих договориться, пойти, обсудить и так далее, что у него это хорошо получается, именно поэтому ему это дали.
2200.76 2201.76 "Игорь Лабутин" Переключился.
2201.76 2203.64 "Анатолий Кулаков" Ну может быть, может быть.
2203.64 2209.60 "Анатолий Кулаков" Ладно, пойдем посмотрим, у нас там еще один релиз Candidate 2 вышел, в этот раз не дотнета, а у райдера.
2209.60 2217.12 "Игорь Лабутин" Так, давай мы прежде чем уходить в райдер, закончим все-таки с дотнетом и поговорим про System Text.json.
2217.12 2220.40 "Игорь Лабутин" У нас еще System Text.json остался?
2220.40 2224.96 "Игорь Лабутин" Да, там тоже в дотнете 7, что-то там прям завезли, поменяли.
2224.96 2243.32 "Игорь Лабутин" Давай, по крайней мере, я не очень понял, это они в RC2 или… то есть вышла статья, what's new, это у нас вообще во всем 7 дотнете такое поменяли или это прям в последнем RC2 столько завезли, или это просто обзорная статья на тему, что у вас тут такого новенького?
2243.32 2259.28 "Анатолий Кулаков" Вот та статья, что такого новенького в System Text.json, она относится непосредственно к всему дотнет 7, то есть там много изменений, которые постепенно выпускали, постепенно интегрировали и с Source генераторами, и с Reflection, и с много еще чем.
2259.28 2261.20 "Анатолий Кулаков" Ну давай поподробнее, да.
2261.20 2266.96 "Анатолий Кулаков" Хочется вам рассказать о том, что же все-таки изменилось в System Text.json в новом дотнет 7.
2266.96 2270.64 "Анатолий Кулаков" Изменилось довольно-таки много в плане конфигурации, настраивания и гибкости.
2270.64 2290.44 "Анатолий Кулаков" System Text.json часто очень ругались за недостаточную гибкость, особенно те извращенцы, которые плотно подсели на Neutron Soft.json, который позволял настраивать абсолютно все в абсолютно любом месте, с кучей возможностей, перехватов, хуков, рефлекшенов, атрибутов, чего там так у него не было.
2290.44 2308.44 "Анатолий Кулаков" И когда ребята из Microsoft сели и захотели написать новый JSON сериализатор с нуля, который был бы мега быстрым, они сразу поняли, что всю вот эту кучу флексабилити подержать будет невозможно и сделали его максимально тупым, но мега быстрым и мега строгим.
2308.44 2317.28 "Анатолий Кулаков" То есть он вообще никак не терпел различные ошибки там в JSON, даже мельчайшие какие-то проблемы в синтаксисе.
2317.28 2319.60 "Анатолий Кулаков" Изначально это было мега быстро и мега строго.
2319.60 2323.88 "Анатолий Кулаков" И надо сказать, что в большинстве случаев именно так и надо работать.
2323.88 2324.88 "Анатолий Кулаков" Сериализатор должен быть тупым.
2324.88 2327.96 "Анатолий Кулаков" ДТОшки, которые он сериализует, должны быть мега тупыми.
2327.96 2328.96 "Анатолий Кулаков" На то они и ДТОшки.
2328.96 2338.12 "Анатолий Кулаков" На то это и выделен специальный отдельный класс, заведен специальный отдельный паттерн и сказано всем не суйте туда никакой логики, а дайте спокойно с сериализатором работать.
2338.12 2340.48 "Анатолий Кулаков" Но, к сожалению, люди не такие.
2340.48 2347.16 "Анатолий Кулаков" Люди хотят гибкости, кустомизабельности и использования сериализаторов всякими извращенными способами.
2347.16 2350.72 "Анатолий Кулаков" Поэтому постепенно системчик JSON начал обрастать всякой гибкостью.
2350.72 2362.32 "Анатолий Кулаков" И вот, наконец, в седьмой версии, мне кажется, он добился этого пика, когда вообще абсолютно все, что мне лично было нужно, он начал поддерживать.
2362.32 2364.96 "Анатолий Кулаков" Давайте разберемся, как он это сделает.
2364.96 2374.40 "Анатолий Кулаков" Во-первых, начнем с того, что сам сериализатор - это возможность записать в формате JSON абсолютно любой объект.
2374.40 2378.64 "Анатолий Кулаков" Ну, наверное, не любой все-таки, а тот, который специально подготовлен для того, чтобы его можно было сериализовать.
2378.64 2383.36 "Анатолий Кулаков" Представить его в виде JSON, а также обычно считать его из JSON.
2383.36 2386.84 "Анатолий Кулаков" И очень часто хочется настраивать, что мы там делаем.
2386.84 2388.08 "Анатолий Кулаков" Например, переименовать поля.
2388.08 2395.36 "Анатолий Кулаков" Если, допустим, в дотнете у нас повсеместно поля называются в Pascal кейсе, то в JSON обычно это не так.
2395.36 2400.32 "Анатолий Кулаков" Там чаще используется какой-нибудь CamelCase или KebabCase или еще какая-нибудь срань господня.
2400.32 2404.92 "Анатолий Кулаков" Но нам приходится с этим как-то заморачиваться.
2404.92 2414.12 "Анатолий Кулаков" Нам приходится подставлять какие-то алгоритмы, которые умеют транслировать и переводить из одного мира, из мира дотнета, в другой мир, в мир джаваскрипта.
2414.12 2416.36 "Анатолий Кулаков" У них свои контракты, у них свои атрибуты.
2416.36 2419.00 "Анатолий Кулаков" И вот этот процесс, он обычно настраивается.
2419.00 2424.34 "Анатолий Кулаков" И сейчас в текущем сериализаторе он настраивается с помощью атрибутов.
2424.34 2429.28 "Анатолий Кулаков" Не то чтобы совсем гибко, но для таких базовых повседневных вещей атрибутов вполне хватает.
2429.28 2432.60 "Анатолий Кулаков" В дотнет 7 завезли более интересный подход.
2432.60 2434.12 "Анатолий Кулаков" Это JSON TypeInfo.
2434.12 2439.80 "Анатолий Кулаков" То есть это специальный классик, который содержит себе мета-информацию, описывающую тип T.
2439.80 2449.00 "Анатолий Кулаков" Соответственно, вы можете уже тип T описать не просто какими-то атрибутами, а в коде задать специальные контракты, задать специальные делегаты.
2449.00 2455.68 "Анатолий Кулаков" То есть здесь у вас появляется намного больше гибкости и при этом как побочный эффект вы не вымазываете DTOшку.
2455.68 2460.80 "Анатолий Кулаков" Соответственно, вы можете, например, ее переязать в других сериализаторах или в других контрактах.
2460.80 2461.80 "Анатолий Кулаков" Но это мелочи.
2461.80 2463.24 "Анатолий Кулаков" Мы на этом не будем сейчас обращать внимания.
2463.24 2469.92 "Анатолий Кулаков" Как раз таки попробуем подробнее рассмотреть возможности вот этого нового мета-описания.
2469.92 2472.88 "Анатолий Кулаков" Надо сказать, что на самом деле этот тип не то чтобы совсем новый.
2472.88 2477.42 "Анатолий Кулаков" В предыдущих версиях фреймворка он используется внутри Source-генераторов.
2477.42 2487.88 "Анатолий Кулаков" И Source-генераторы как раз таки имели к нему доступ и с помощью него и генерили быстрый код, который у нас по перформансу рвет обычные сериализаторы.
2487.88 2505.16 "Анатолий Кулаков" Начиная с дотнет 7, соответственно, этот класс был выставлен наружу, его опубликовали и наделили всякими более полными точками расширения, которые теперь могут использовать не только Source-генераторы, но и абсолютно все пользователи, которые хотят соответственно им пользоваться.
2505.16 2513.48 "Анатолий Кулаков" Так, для того чтобы получить вот этот класс JSON-type-info, для того чтобы каким-то образом начать с ним работать, у нас есть некий провайдер.
2513.48 2519.12 "Анатолий Кулаков" Это JSON-type-info-resolver, у которого есть метод getTypeInfo, который возвращает непосредственно описатель.
2519.12 2520.36 "Анатолий Кулаков" Зачем нужен этот резолвер?
2520.36 2525.20 "Анатолий Кулаков" Он полезен очень для того, чтобы его использовать в различных источниках сериализаторов.
2525.20 2528.56 "Анатолий Кулаков" Как бы не было парадоксально, источников сериализатора может быть много.
2528.56 2530.88 "Анатолий Кулаков" Ну, во-первых, это, конечно же, Reflection.
2530.88 2544.16 "Анатолий Кулаков" Каждый из вас сталкивался с сериализатором, который построен на основании Reflection, который пробегается по всем полям, ищет по определенным значениям их свойства, getter и setter и работает с ним.
2544.16 2557.88 "Анатолий Кулаков" Второй интересный источник сериализатора у нас появился совсем недавно, это Source-генераторы, которые позволяют нам сделать строго типизированные, мега-быстрые, мега-оптимизированные, заточенные под конкретный тип сериализаторы, которые вы, соответственно, тоже можете использовать.
2557.88 2558.88 "Анатолий Кулаков" Это другой источник.
2558.88 2570.24 "Анатолий Кулаков" Ну и третий источник, никто не мешает вам написать свой собственный сериализатор, который может быть даже лучше любого генератора, ваш конкретный тип заоптимизирует и конкретно его запишет или считает.
2570.24 2591.28 "Анатолий Кулаков" И чтобы абстрагировать такую некую концепцию различных источников, откуда может взяться сериализатор, и был выдуман JSON-тайп InfoResolver с одним-единственным методом, который, соответственно, просто возвращает описание по определенному типу, возвращает описание метатипа, что непосредственно с этим типом нужно нам теперь делать.
2591.28 2597.28 "Анатолий Кулаков" И все это описание хранится в тайпе JSON-тайп Info.
2597.28 2609.86 "Анатолий Кулаков" Для того, чтобы больше точек гибкости, больше точек расширения дать, специально Resolver было добавлено несколько возможностей для расширения.
2609.86 2623.76 "Анатолий Кулаков" Во-первых, это возможность пронаследоваться от него и в наследниках переопределить различные типы, различные методы, различные свойства, каким-то образом вот так вот изменить поведение сериализатора.
2623.76 2649.36 "Анатолий Кулаков" Но более, кажется, современным, гибким и простым это коллекция, это специальные делегаты, которые принимают в качестве аргумента JSON-тайп Info, то есть вот это метаописание самого типа, и внутри этого делегата могут этот тайп Info произвольно менять, соответственно, таким образом подтюнивая, регулируя поведение сериализатора.
2649.36 2654.16 "Анатолий Кулаков" Например, очень легко внутри такого делегата изменить имя-свойство.
2654.16 2659.92 "Анатолий Кулаков" Если оно у вас называлось в Pascal-кейсе, вы легко можете его переделать в CamelCase.
2659.92 2667.80 "Анатолий Кулаков" Также элементарно с помощью этой техники заигнорировать свойства, то есть не писать их в JSON, не считывать их оттуда.
2667.80 2675.52 "Анатолий Кулаков" Можно даже создать свое собственное новое свойство, которым нет в объекте, но вы знаете, каким образом его получить, так называемые вычисляемые свойства.
2675.52 2681.92 "Анатолий Кулаков" Можете непосредственно сразу загнать в JSON-документ вычисляемые свойства, а оригинальные свойства, например, проигнорить.
2681.92 2683.76 "Анатолий Кулаков" Вот такой хак сделать.
2683.76 2696.72 "Анатолий Кулаков" Можно свой собственный конверт написать, если вы вдруг знаете, что именно то число, которое там хранится, оно должно перед сериализацией в JSON переобразоваться в строку или в дату или еще куда-нибудь.
2696.72 2699.00 "Анатолий Кулаков" Это делается с помощью кастомных конверторов.
2699.00 2707.52 "Анатолий Кулаков" Вы можете также переопределить сеттеры и геттеры или поменять, например, порядок, в котором в JSON-документе это поле в текстовом виде будут следовать.
2707.52 2710.36 "Анатолий Кулаков" В общем, абсолютно практически любую дичь можно творить.
2710.36 2718.08 "Анатолий Кулаков" И давайте на нескольких примерах посмотрим, что можно сделать с помощью изменения вот этого мета-описания типа.
2718.08 2725.76 "Анатолий Кулаков" Например, можно изобразить кастомные атрибуты, которых сейчас не входит в стандартную поставку System Text JSON.
2725.76 2735.80 "Анатолий Кулаков" Например, вам вполне могли достаться какие-нибудь Legacy классы, где все DTO-шки размечены специальным контрактом, Data Contract Serializer.
2735.80 2745.84 "Анатолий Кулаков" Он был очень популярен в древности, в древние времена, и, соответственно, очень много протоколов, базирующихся на основании его атрибутов.
2745.84 2752.48 "Анатолий Кулаков" Это атрибуты, которые точно так же показывали, каким образом класс должен превращаться в соответствующие протоколы и передаваться дальше.
2752.48 2757.60 "Анатолий Кулаков" Например, у него был свой собственный класс, который назывался IgnoreDataMemberAttribute.
2757.60 2761.76 "Анатолий Кулаков" Его стандартный JSON-сериализатор, естественно, не поддерживает.
2761.76 2763.64 "Анатолий Кулаков" Мы можем сделать так, чтобы он его поддерживал.
2763.64 2770.96 "Анатолий Кулаков" Можем завести свой модификатор, в котором проанализировать с помощью Reflection атрибуты, навешанные над этим свойством.
2770.96 2778.44 "Анатолий Кулаков" Если увидим атрибут из Data Contract Serializer, сделать ему соответствующую имплементацию в нашем модифайре.
2778.44 2779.96 "Анатолий Кулаков" Например, заигнорить это свойство.
2779.96 2786.56 "Анатолий Кулаков" Как я уже сказал, это все элементарно можно сделать с помощью JSON Type Info, с помощью одного из его свойств.
2786.56 2793.72 "Анатолий Кулаков" Например, еще одно из моих самых любимых свойств, которые мне всегда сильно не хватает и которые я люблю, это ShootSerialize.
2793.72 2801.72 "Анатолий Кулаков" ShootSerialize – это великолепный делегат, который в рантайме определяет, нужно ли сейчас это свойство сериализовать.
2801.72 2807.16 "Анатолий Кулаков" И определяет оно на основании того объекта и того значения, которое сейчас есть в этом поле.
2807.16 2814.84 "Анатолий Кулаков" Допустим, вы элементарно можете не сериализовать пустые массивы и пустые дикшенеры внутри JSON-документа.
2814.84 2825.44 "Анатолий Кулаков" Или вы можете не сериализовать значения номеров, int, у которых значение 0, потому что это значение и так будет по умолчанию.
2825.44 2841.44 "Анатолий Кулаков" С помощью такого нехитрого хака можно какую-нибудь DTO-шку из 100 полей в большинстве случаев, в 80% всех случаев превратить в DTO-шку из 5 полей, потому что эти 100 используются в какой-то определенной комбинации, благодаря таким дефолтам.
2841.44 2844.24 "Анатолий Кулаков" Соответственно, это тоже можно сделать.
2844.24 2851.68 "Анатолий Кулаков" Можно проигнорировать на основании какого-то значения и на основании значений из других полей можно проигнорировать запись этого поля.
2851.68 2856.16 "Анатолий Кулаков" Очень полезная на практике штука, особенно если вы заботитесь о красивых JSON-чиках.
2856.16 2864.44 "Анатолий Кулаков" Следующая вещь, которую можно сделать, это, например, засериализовать приватные филды, приватные поля.
2864.44 2874.24 "Анатолий Кулаков" Сразу нужно оговориться, что это крайне не рекомендуется делать, потому что это внутреннее дело самого класса, каким образом у него там приватные поля хранятся, называются и так далее.
2874.24 2878.84 "Анатолий Кулаков" Но если вы сильно хотите, то в принципе никто вас в этом ограничить не сможет.
2878.84 2880.76 "Анатолий Кулаков" Точно так же пишем модификатор.
2880.76 2886.24 "Анатолий Кулаков" С помощью Reflection пробегаемся по всем приватным полям, то есть со специальными флажками.
2886.24 2887.64 "Анатолий Кулаков" Создаем новое свойство.
2887.64 2890.48 "Анатолий Кулаков" Этому новому свойству выставляем getter и setter.
2890.48 2893.68 "Анатолий Кулаков" Точно так же с помощью Reflection мы элементарно можем это сделать.
2893.68 2896.36 "Анатолий Кулаков" Забрасываем новое свойство в таблицу properties.
2896.36 2906.76 "Анатолий Кулаков" И все, и у нас готово новое JSON-свойство, которое никак не фигурирует в самом классе, которого там никак нет, ни по имени, ни по чем, но зато у нас оно будет в JSON-документе.
2906.76 2911.60 "Анатолий Кулаков" И соответственно можно очень много таких примеров еще приводить.
2911.60 2924.96 "Анатолий Кулаков" Здесь стоит отметить, что как только вы начинаете создавать кучу таких модификаторов, кучу таких резолверов, вы рано или поздно столкнетесь с той проблемой, что у вас есть куча резолверов для кучи типов, а как их теперь объединить в нечто одно.
2924.96 2928.16 "Анатолий Кулаков" То, с чем можно управляться, то, что можно проставлять.
2928.16 2931.32 "Анатолий Кулаков" Некий такой один фасад, за которым они скроются все.
2931.32 2936.68 "Анатолий Кулаков" И для этого есть стандартный метод JSON-тайп инфорезолвер статический, который называется combine.
2936.68 2941.92 "Анатолий Кулаков" Он у себя в параметрах принимает несколько резолверов.
2941.92 2954.28 "Анатолий Кулаков" Например, как я уже сказал, вы можете парочку резолверов взять из source-генератора, парочку взять из reflection, а парочку написать самим и все это скомбинить в один JSON-тайп резолвер.
2954.28 2958.20 "Анатолий Кулаков" Он работает очень просто.
2958.20 2965.28 "Анатолий Кулаков" Если вы передали туда несколько резолверов, он их перебирает все последовательно в том порядке, в котором вы их передали.
2965.28 2972.96 "Анатолий Кулаков" И как только первый резолвер вернет мета-информацию о том типе, который хочется, перебор сразу же останавливается и используется эта мета-информация.
2972.96 2978.16 "Анатолий Кулаков" Так, что у нас еще заимпровелось в JSON-стерилизаторе?
2978.16 2980.80 "Анатолий Кулаков" Это полиморфная стерилизация наследования.
2980.80 2985.12 "Анатолий Кулаков" То есть мы теперь можем иерархию типов стерилизовать.
2985.12 2991.32 "Анатолий Кулаков" Тоже отдельный вопрос, насколько это является правильным, заводить DTO-шки с наследованием и сделать им иерархию.
2991.32 2993.08 "Анатолий Кулаков" Иногда бывает такая штука нужна.
2993.08 3000.28 "Анатолий Кулаков" То есть, допустим, если у вас есть базовый класс и от него наследуется еще несколько наследников.
3000.28 3008.68 "Анатолий Кулаков" И вот вы хотите понять, каким образом записать всех этих наследников, если у вас известен только абстрактный базовый класс.
3008.68 3010.60 "Анатолий Кулаков" А самое главное, как их оттуда считать.
3010.60 3018.40 "Анатолий Кулаков" В общем, вот эту проблему и как раз таки решили и улучшили в новой версии стерилизатора.
3018.40 3023.56 "Анатолий Кулаков" Соответственно, для того, чтобы просто-напросто записать базовый класс, то здесь нет ничего сложного.
3023.56 3031.48 "Анатолий Кулаков" Вы просто навешиваете дополнительный атрибут, который называется JSON-derived type attribute, указываете ему, какие есть наследники у базового класса.
3031.48 3041.88 "Анатолий Кулаков" И с этих пор вы можете просто абстрактный базовый класс передавать стерилизатор, стерилизатор поймет, что если на самом деле в рентайме там есть наследник, все его поля он тоже затащит.
3041.88 3043.68 "Анатолий Кулаков" В принципе, это несложно, это понятно.
3043.68 3047.56 "Анатолий Кулаков" А вот как только мы пытаемся десерилизовать, здесь уже становятся вопросы.
3047.56 3055.16 "Анатолий Кулаков" Ну, например, мы пытаемся десерилизовать базовый класс, базовый абстрактный класс, но в JSON у нас лежит уже конкретный класс.
3055.16 3060.60 "Анатолий Кулаков" Естественно, абстрактный класс мы создать не можем и записать туда те поля, которые хотя бы есть, мы тоже не можем.
3060.60 3066.68 "Анатолий Кулаков" Ну и это обычно бессмысленно, потому что мы все-таки хотим десерилизовать не базовый абстрактный, а настоящий конечный тип.
3066.68 3073.68 "Анатолий Кулаков" Но не всегда этот конечный тип известен в момент десерилизации и хочется иметь возможность управляться именно с базовым типом.
3073.68 3077.48 "Анатолий Кулаков" Это тоже можно делать, но с помощью добавления дискриминатора.
3077.48 3090.92 "Анатолий Кулаков" Дискриминатор – это так называемое специальное свойство, которое обычно выделяется как служебное свойство и в которое записывается тип непосредственно наследника, которого мы хотим десерилизовать.
3090.92 3099.20 "Анатолий Кулаков" Допустим, по умолчанию у нас запишется в JSON документ специальное свойство, которое называется $type.
3099.20 3106.48 "Анатолий Кулаков" В $type и его значением будет являться непосредственно значение дискриминатора, то есть, допустим, имя типа.
3106.48 3115.24 "Анатолий Кулаков" Это все становится возможным, как только мы навешаем атрибут JSON.derivate.type вместе с специальным указателем $type.discriminator.
3115.24 3123.04 "Анатолий Кулаков" И в этом $type.discriminator мы можем выбрать любую вэлью, которая подходит нам для того, чтобы уникально идентифицировать этого наследника.
3123.04 3128.12 "Анатолий Кулаков" Таким образом, мы теперь можем сделать полиморфическую десерилизацию, так называемую.
3128.12 3131.96 "Анатолий Кулаков" То есть, десерилизовать по базовому классу, десерилизовать наследников.
3131.96 3133.88 "Анатолий Кулаков" Вот такая магическая штука.
3133.88 3144.24 "Анатолий Кулаков" Всегда мне не нравилось в том, что обычно десерилизаторы оставляют на свое собственное усмотрение, как вот этот гнусный тип называется, вот этот $type.
3144.24 3145.24 "Анатолий Кулаков" Это же ужасно.
3145.24 3152.04 "Анатолий Кулаков" Если мы думаем о красивых JSON, то мы никогда не пойдем на то, чтобы вот этот $type оставить у нас в продакшене.
3152.04 3160.20 "Анатолий Кулаков" И слава богам, разработчики .NET тоже так решили, и поэтому они навесили еще один атрибут, который называется JSON polymorphic.
3160.20 3168.16 "Анатолий Кулаков" И в этом JSON polymorphic вы можете указать, в какой собственно свойства, под каким именем засунется type discriminator.
3168.16 3170.20 "Анатолий Кулаков" И вы соответственно можете его переопределить.
3170.20 3181.52 "Анатолий Кулаков" В большинстве случаев вам не нужны вот эти всякие $keys, $type, подчеркивание type, потому что в большинстве случаев у вас обычно есть некое поле, по которому вы уникально можете понять, что это за наследник.
3181.52 3185.72 "Анатолий Кулаков" И его можно записать просто как обычное красивое нормальное поле.
3185.72 3195.20 "Анатолий Кулаков" Ну если же нет, соответственно у вас есть, у вас развязаны все руки для того, чтобы самому определить какое-нибудь красивое название поля для type discriminator.
3195.20 3201.32 "Анатолий Кулаков" Естественно, все это вы можете сделать не просто атрибутами, а с помощью мета-описания JSON type info.
3201.32 3203.56 "Анатолий Кулаков" У него есть свойство polymorphic options.
3203.56 3206.76 "Анатолий Кулаков" Туда вы можете все то же самое записать, все то же самое сделать.
3206.76 3209.76 "Анатолий Кулаков" Улучшается поддержка required members.
3209.76 3214.52 "Анатолий Кулаков" Я напомню, что в C# 11 у нас появилось новое ключевое слово required.
3214.52 3220.80 "Анатолий Кулаков" И означает оно, что свойство должно быть обязательно заполнено в момент создания этого класса.
3220.80 3225.18 "Анатолий Кулаков" System Text JSON, соответственно, подключил к себе поддержку этого нового свойства.
3225.18 3239.62 "Анатолий Кулаков" И это означает, что если он встретит required свойства в DTO, и вдруг почему-то в JSON по какой-то причине не найдет соответствующего элементика, который можно было бы прибандить к этому свойству, будет exception.
3239.62 3247.14 "Анатолий Кулаков" Будет ошибка, он скажет, что свойство обязательно, в JSON документе вы мне его не прислали, я работать не могу.
3247.14 3251.66 "Анатолий Кулаков" Это вроде стандартное поведение, которое в принципе обычно и ожидают разработчики.
3251.66 3259.38 "Анатолий Кулаков" Если же у вас более ранняя версия языка, не C# 11, но вам тоже хочется такого поведения, в принципе оно было всегда.
3259.38 3262.30 "Анатолий Кулаков" Называется это JSON Required Attribute.
3262.30 3270.86 "Анатолий Кулаков" Вы легко навешиваете attribute required над свойством, и поведение будет такое же точно, как и required, как кейворд в C# 11.
3270.86 3278.54 "Анатолий Кулаков" Ну и естественно JSON Property Info предоставляет свойство isRequired, соответственно, вы можете это настраивать с помощью мета-описания.
3278.54 3284.78 "Анатолий Кулаков" Еще появился JSON Serializer Options Default.
3284.78 3291.90 "Анатолий Кулаков" Это свойство, которое является read-only static instance, свойств опции по умолчанию.
3291.90 3296.50 "Анатолий Кулаков" То есть JSON Serializer Options, какое-то по умолчанию дефолтное у вас всегда есть под рукой.
3296.50 3312.78 "Анатолий Кулаков" Это может быть полезно, когда вы пишете, например, свой собственный конвертер, и вдруг вам нужно обратиться к базовому конвертеру, который стандартный в системе, чтобы его не искать, и вы опять можете пойти к этому статическому свойству, запросить у него конвертер какого-нибудь стандартного типа и переиспользовать его в своем конвертере.
3312.78 3328.06 "Анатолий Кулаков" Или, может быть, у вас есть какая-то ситуация, где для вас JSON Options обязательно нужен, без него никак не обойтись, но от пользователя его просить невозможно, не нужно и как-то он не соответствует тому домену, где мы пытаемся его запросить.
3328.06 3336.34 "Анатолий Кулаков" Тогда же, опять, вы можете пойти в статический метод, статическое свойство, и оттуда взять какое-то стандартное поведение вашего JSON Serializer в системе.
3336.34 3339.34 "Анатолий Кулаков" Тоже бывает очень часто удобно.
3339.34 3344.94 "Анатолий Кулаков" Также добавились возможности сериализовать новых встроенных типов, которые есть в дотнете.
3344.94 3357.54 "Анатолий Кулаков" В частности, это IAsyncEnumerable, то есть теперь можно асинхронный денумератор внутри сериализатора прокрутить и правильно достать все его значения, что безумно полезно, конечно, бывает.
3357.54 3363.22 "Анатолий Кулаков" Также можно засериализовать теперь JSON-документ и новые наши типы, DateOnly и TimeOnly.
3363.22 3365.50 "Анатолий Кулаков" Теперь они тоже прекрасно поддерживаются сериализаторами.
3365.50 3372.66 "Анатолий Кулаков" Ну и, безусловно, куда же без этого, куча перформансов и прумансов, быстрее, надежнее, шире, глубже и все в этом духе.
3372.66 3375.46 "Анатолий Кулаков" Это тоже у нас все есть в новом System Text JSON.
3375.46 3395.26 "Игорь Лабутин" В общем, кажется, что даже если вы использовали NewtonSoft, то по мере развития System Text JSON там все больше и больше становится всяких фич кастомизации и может быть каких-то фич, которые у вас есть в NewtonSoft JSON по дефолту в System Text JSON и нет, но теперь вы их сможете добавить.
3395.26 3396.26 "Анатолий Кулаков" Кажется, что да.
3396.26 3397.98 "Анатолий Кулаков" Это, в принципе, даже интересно.
3397.98 3415.26 "Анатолий Кулаков" Друзья, если вам вдруг в новом System Text JSON не хватает каких-то кастомизаций, которые у вас есть, допустим, в NewtonSoft JSON, вы их сильно ждете и их нет, напишите, пожалуйста, в комментариях, потому что интересно, что же, собственно, еще осталось, что же не хватает-то.
3415.26 3418.90 "Анатолий Кулаков" Кажется, что покрыли абсолютно все возможности, которые только можно себе придумать.
3418.90 3423.34 "Игорь Лабутин" Ну, покрыли возможности кастомизации, но еще надо написать эту кастомизацию.
3423.34 3424.34 "Игорь Лабутин" Ждем оплату.
3424.34 3426.22 "Анатолий Кулаков" Ну, условно, написать вы это можете все сами.
3426.22 3429.18 "Анатолий Кулаков" Ну, вам хотя бы инструмент дали, хотя бы молоток теперь есть.
3429.18 3432.02 "Анатолий Кулаков" Ну что, теперь можно ждать плагинов к System Text JSON.
3432.02 3435.90 "Анатолий Кулаков" Как сделать стопроцентный совместимый по всем атрибутам с NewtonSoft, да?
3435.90 3446.10 "Игорь Лабутин" Да, да, да, такой плагин, типа заменяешь просто NuGetReference на два других, вместо NewtonSoft используешь System Text JSON и еще какой-нибудь, и у тебя все работает.
3446.10 3458.82 "Анатолий Кулаков" Но мне, кстати, кажется, что было бы такой плагин очень полезный, потому что очень много Legacy проектов сидит на NewtonSoft JSON, переводить их абсолютно нереально, там какие-то миллион контрактов, миллион вызовов, и мало ли кто там в какую сторону чихнет.
3458.82 3473.02 "Анатолий Кулаков" И вот поддержать стандартные атрибуты и стандартные настройки NewtonSoft по дефолту в System Text JSON, и при этом можно было бы заюзать для новых контрактов уже непосредственно всю мощь и все Source генераторы System Text JSON, мне кажется, это богатая идея.
3473.02 3475.06 "Игорь Лабутин" Ну, возможно, посмотрим, посмотрим.
3475.06 3476.74 "Игорь Лабутин" Так, поехали дальше.
3476.74 3479.74 "Игорь Лабутин" Вот теперь давай поговорим про райдер, который мы немножко упомянули.
3479.74 3491.22 "Игорь Лабутин" Вышел, мы буквально в прошлом выпуске обсуждали, что у нас EAP вышел, ну уже вышел второй EAP райдера, и, соответственно, здесь я кратенько пробегу, что туда завезли.
3491.22 3494.46 "Игорь Лабутин" Возможно, что-то из этого вас заинтересует, вы пойдете ставить новый EAP.
3494.46 3505.98 "Игорь Лабутин" Новый UI, вы, может быть, слышали много уже раз в интернете в разных местах про то, что там идея получила, новый UI, вот это вот все, наконец-таки это все дошло до райдера, насколько я понимаю.
3505.98 3519.78 "Игорь Лабутин" Теперь можно отдельно в новом EAP-чике включить новый UI, и говорят, что он прям такой чистенький, и прям большинству, кого я слушал про идею, ну и всех сопутствующих, понятно, и идеи бейс продуктов, всем нравится.
3519.78 3525.98 "Игорь Лабутин" Так что попробуйте, может быть, и в райдере зайдет, если вы готовы на EAP.
3525.98 3545.02 "Игорь Лабутин" Дальше улучшили результаты поиска Search Everywhere, что они более предсказуемы, в смысле, что они не… там был забавный эффект действительно, что ты что-нибудь набрал, он что-то показал первое, и если ты сидишь изучаешь, то по мере того, как он из индекса подтягивает какие-то новые данные, он список начинает обновлять.
3545.02 3548.70 "Игорь Лабутин" Вот, и ты как бы сидишь вроде изучаешь, а он тебе обновляется перед глазами.
3548.70 3557.34 "Игорь Лабутин" Вот, сейчас он стал более, ну, статичным что ли, то есть результаты обновляются, но не добавляются в конец, то есть пока ты изучаешь первую страничку, ну, как бы, тебе она не меняется постоянно.
3557.34 3560.66 "Игорь Лабутин" Вот, говорят, лучше стало.
3560.66 3569.38 "Игорь Лабутин" Теперь можно, если вы используете всякие плавающие окошки, то есть вы берете окошко файлика и утаскиваете его, например, на другой монитор, получается тем самым флоатинг окошка.
3569.38 3577.30 "Игорь Лабутин" Теперь к этому флоатинг окошку с эдитором можно задокать какие-нибудь tool window, то есть не только в основное окно райдера, но и в другое окно.
3577.30 3582.38 "Игорь Лабутин" То есть вы можете утащить редактор и к нему докнуть что-нибудь из tool window.
3582.38 3590.66 "Игорь Лабутин" Можно теперь переключаться между solution прямо с solution explorer, то есть прямо кликаете на solution name, говорите открыть другой solution, он прямо в этом откроется.
3590.66 3597.30 "Игорь Лабутин" А dot memory, как это у нас теперь стандартный профайлер в райдере, доступен теперь на linux и mac оси.
3597.30 3602.86 "Игорь Лабутин" Добавили поддержку c# 11, это file local type и литералы utf-8.
3602.86 3614.34 "Игорь Лабутин" Улучшили, ускорили unit test explorer, улучшили performance дебаггера за счет тонкости оптимизации всяких evaluation от того, что вы видите в watch и в других местах.
3614.34 3621.02 "Игорь Лабутин" Улучшили поддержки maui, можно теперь запускать и отлаживать winui 3 проекты.
3621.02 3629.42 "Игорь Лабутин" Внезапно в райдере добавили возможность конфигурить iis в качестве, так сказать, run configuration, прям нативно.
3629.42 3633.30 "Игорь Лабутин" Плюс поддержали iis, когда он указан в launch settings.json.
3633.30 3638.98 "Игорь Лабутин" Как это, ну в суде это можно сделать, там будет отдельный прям тип запуска в launch settings, называется iis.
3638.98 3642.98 "Игорь Лабутин" Вот теперь в райдере это тоже поддержка есть.
3642.98 3646.06 "Игорь Лабутин" Дальше не знаю, кто пользовался, нет.
3646.06 3655.50 "Игорь Лабутин" В райдере есть такая штука dynamic program analysis, то есть когда у вас приложение работает, райдер пытается понять, что с ним не так, и если что-то не так, он дает всякие разные советы.
3655.50 3668.38 "Игорь Лабутин" Вот теперь добавили большой блок поддержки работы с базами данных, то есть он теперь будет вас прям предупреждать, что у вас есть ли прерки долго исполняются, есть ли у вас слишком много connections открывается, есть ли у вас из каких-то запросов очень много записей обрабатывается.
3668.38 3679.62 "Игорь Лабутин" Единственный момент, что это сейчас доступно только для приложений, которые используют EF Core и обязательно .NET Data Provider for SQL Server, то есть видимо пока это работает через какие-то там инструментации, ЕТВ или еще что-нибудь подобное.
3679.62 3687.34 "Игорь Лабутин" ЕТВ наверное нет на Линуксе, ну там нет заменителей, наверное список будет расширяться.
3687.34 3698.50 "Игорь Лабутин" Ну и если вы каким-то образом относитесь к миру Unreal Engine или C++, там тоже есть улучшения в этом япе, посмотрите, почитайте блок внимательно, мы на этом подробно останавливаться не будем.
3698.50 3699.50 "Игорь Лабутин" Как-то так.
3699.50 3706.06 "Анатолий Кулаков" Ну отлично, хорошего введения не отстает от студии, что тоже радует.
3706.06 3709.78 "Анатолий Кулаков" Или в принципе студия от него, с какой стороны посмотреть.
3709.78 3714.42 "Игорь Лабутин" Да, смотря с какой стороны посмотреть и где ты сейчас находишься, и на чем ты пишешь.
3714.42 3717.42 "Игорь Лабутин" В смысле в какой IDE ты пишешь.
3717.42 3727.02 "Игорь Лабутин" Но тем не менее япа всегда были интересны, понятно, что у них может быть стабильность чуть пониже, получше, похуже, зато новый UI, может быть он перевесит.
3727.02 3728.82 "Анатолий Кулаков" Ну да, да.
3728.82 3735.58 "Анатолий Кулаков" Ладно, пойдем к теме, которая не зависит ни от UI, ни от платформы, ни от чего, а только от нашего любимого компилятора.
3735.58 3749.02 "Анатолий Кулаков" Andrew Locke разродился статьей, которая называется "Adding Validation to Strong Type Configuration Object", то есть он порассказывает нам каким образом можно добавить валидацию к нашей строго типизированной конфигурации.
3749.02 3758.14 "Анатолий Кулаков" И все что касается строго типизации, я обожаю безмерно, поэтому не мог пройти мимо этой статьи и спешу вас с ней тоже познакомить.
3758.14 3759.54 "Анатолий Кулаков" Давайте начнем сначала.
3759.54 3763.42 "Анатолий Кулаков" Прежде всего, что такое строго типизированная конфигурация?
3763.42 3775.42 "Анатолий Кулаков" У .NET еще, да я не знаю с какой их версии, с первых коров, наверное, не буду врать, но довольно таки давно есть такое понятие, как конфигурация.
3775.42 3789.42 "Анатолий Кулаков" Изначально она была представлена в виде интерфейса IConfiguration, который был по сути, если так грубо брать, обычным дикшенери, в котором могло под любым строковым ключом лежать любое непонятное значение.
3789.42 3798.20 "Анатолий Кулаков" Понятно, что жить с этим нельзя, нужно сделать что-то более гибкое, более понятное, а самое главное, более строго типизированное.
3798.20 3802.66 "Анатолий Кулаков" И мы сделали так называемые Microsoft Options.
3802.66 3811.98 "Анатолий Кулаков" Нужно сказать, что прежде всего Microsoft Options, они читаются из IConfiguration, а IConfiguration ее можно собрать из множества различных слоев.
3811.98 3819.34 "Анатолий Кулаков" Например, в типичном .NET приложении легко можно встречаться до нескольких слоев.
3819.34 3824.26 "Анатолий Кулаков" Опции вы, прежде всего, можете загружать из JSON файла, может быть, даже из YAML файла.
3824.26 3827.86 "Анатолий Кулаков" Обычно у вас еще есть переменные окружения, которые вы тоже хотите подтащить.
3827.86 3833.50 "Анатолий Кулаков" Часто у вас бывают какие-нибудь секреты, которые хранятся в каком-нибудь Vault, которые тоже хочется подтащить.
3833.50 3839.42 "Анатолий Кулаков" У вас есть также командная строка, которая тоже каким-то образом конфигурирует ваше приложение, это тоже хочется учесть.
3839.42 3850.34 "Анатолий Кулаков" И вот все вот эти слои непосредственно накапливаются и перетирают друг друга, если вдруг какие-то переменные встречаются больше, чем один раз.
3850.34 3852.38 "Анатолий Кулаков" Перетирают друг друга с определенным приоритетом.
3852.38 3857.10 "Анатолий Кулаков" У нас в конце концов собирается такая большая помойка под названием IConfiguration.
3857.10 3865.66 "Анатолий Кулаков" Там есть все, все в правильных форматах, там все, допустим, с правильными ключами, но из него очень сложно отчитать.
3865.66 3872.18 "Анатолий Кулаков" И для того, чтобы читать из него было легко, Microsoft изобрел Strongly Type Configuration.
3872.18 3876.70 "Анатолий Кулаков" На самом деле за этим замысловатым словом кроется довольно примитивная конструкция.
3876.70 3893.02 "Анатолий Кулаков" Это та же самая обычная DTO, тот же самый Poco класс, который мы, например, рассматривали в сериализации, то есть обычный классик, у которого есть поля, у которого есть филды с определенным именем, со строгим именем и с определенным типом.
3893.02 3894.02 "Анатолий Кулаков" Вот и все.
3894.02 3909.54 "Анатолий Кулаков" А дальше уже задача непосредственно фреймворка, взять из этого IConfiguration, найти свойства и найти значения, которые соответствуют имени этого свойства, попытаться их сконвертировать в тот тип, который свойства хочет принять и всему этому свойству непосредственно засетать.
3909.54 3923.42 "Анатолий Кулаков" И, соответственно, как все это настраивается, мы берем в самом начале в нашем Startup методе, объявляем все вот эти Poco объекты, все эти опции с помощью метода конфигур.
3923.42 3935.66 "Анатолий Кулаков" И когда нам непосредственно уже нужно потреблять эти опции, мы можем запросить несколько интерфейсов, несколько врапперов над опциями.
3935.66 3941.06 "Анатолий Кулаков" Например, стандартным интерфейсом является IOptions от каких-то сеттингов.
3941.06 3956.46 "Анатолий Кулаков" И вам конструктор заинжектирует загруженные уже ваши сеттинги, которые были проанализированы фреймворком, которые считали все возможные значения из IConfiguration.
3956.46 3959.34 "Анатолий Кулаков" Типы этих всех свойств скастились, соответственно.
3959.34 3965.30 "Анатолий Кулаков" И вы можете их использовать в классе, уже обращаясь непосредственно к строгим свойствам.
3965.30 3970.70 "Анатолий Кулаков" То есть обращаясь уже к value этого IOptions.
3970.70 3975.94 "Анатолий Кулаков" Там есть другие врапперы, например, iSnapshotOptions, iMonitorOptions, не суть важно.
3975.94 3979.74 "Анатолий Кулаков" В принципе, кому интересно, те почитают в основной документации.
3979.74 3982.30 "Анатолий Кулаков" Здесь как раз-таки нам интересно другое.
3982.30 3992.98 "Анатолий Кулаков" Что когда мы пытаемся найти соответствующие значения для этих свойств, под капотом происходит много интересной разной магии.
3992.98 3996.34 "Анатолий Кулаков" Ну, прежде всего, естественно, создается класс, этот класс сеттингов.
3996.34 4001.98 "Анатолий Кулаков" И пытаются найти ему свойства и пытаются сконвертировать свойства.
4001.98 4014.98 "Анатолий Кулаков" На самом деле, нужно сказать, что вот этот IOptions байндер, который есть, он очень плохо работает с nullble reference types.
4014.98 4020.90 "Анатолий Кулаков" То есть по непонятной причине Microsoft написал этот байндер не то чтобы плохо.
4020.90 4025.02 "Анатолий Кулаков" Знаете, плохо – это когда он не делает то, что должен делать.
4025.02 4029.38 "Анатолий Кулаков" А вот эта сволочь, она делает намного больше того, что делать не должен.
4029.38 4031.26 "Анатолий Кулаков" Ну, приведу типичный пример.
4031.26 4039.58 "Анатолий Кулаков" Если у вас есть свойство, у которого есть только getter, то есть у него нет сеттера, теоретически вы не хотите, чтобы в него писались никакие опции.
4039.58 4041.06 "Анатолий Кулаков" У него есть только getter.
4041.06 4043.78 "Анатолий Кулаков" А вот этот байндер все равно считывает это свойство.
4043.78 4045.74 "Анатолий Кулаков" То есть он это getter вызывает.
4045.74 4050.02 "Анатолий Кулаков" Непонятно зачем, потому что в итоге он все равно будет игнорировать дальше по коду.
4050.02 4054.06 "Анатолий Кулаков" Потому что по коду он дальше анализирует, что если сеттера нет, то выбрасываем то, что я считал.
4054.06 4055.82 "Анатолий Кулаков" Зачем он это считывает, не особо понятно.
4055.82 4060.10 "Анатолий Кулаков" Ну, и много еще подобного необъяснимого поведения.
4060.10 4067.66 "Анатолий Кулаков" В общем, писали его явно какой-то пьяный программист, у которого абсолютно необъяснимые вещи там творятся.
4067.66 4070.94 "Анатолий Кулаков" Ну, не будем про это, не будем про null-reference-type.
4070.94 4075.18 "Анатолий Кулаков" Давайте все-таки придумаем, что у нас сейчас нет null-reference-type, у нас есть обычные типы.
4075.18 4079.02 "Анатолий Кулаков" Что можно улучшить в этом поведении?
4079.02 4094.30 "Анатолий Кулаков" Прежде всего, многим разработчикам очень сильно не нравится, когда им в конструктор приходится инжектировать класс IOptions или IOptionMonitor.t или IOptions.at, если им нужно просто-напросто строго типизированные DTO-шку с их сеттингами.
4094.30 4098.98 "Анатолий Кулаков" Эта проблема, в принципе, решается довольно просто.
4098.98 4121.30 "Анатолий Кулаков" Вам достаточно всего лишь навсего зарегистрировать в вашем контейнере singleton, строго типизированный, то есть вот эту DTO-шку, которую вы хотите принять в конструктор, ее достаточно просто зарегистрировать в контейнере и в качестве источника, откуда ее взять, зарезолвить из существующего контекста IOptionsSettings и вызвать свойство .value.
4121.30 4129.58 "Анатолий Кулаков" Вот, в принципе, и вся хитрость, если вы так сделаете, если вы такую регистрацию напишите, то вы уже в конструкторах можете принимать нормальный, сырой ваш объект.
4129.58 4136.26 "Анатолий Кулаков" Это очень частая практика, многие так делают, в принципе, в этом нет никаких проблем.
4136.26 4143.22 "Анатолий Кулаков" А вот проблема начинается с того, когда встречаются два вот этих мира, нетипизированный и строго типизированный.
4143.22 4144.22 "Анатолий Кулаков" Что это значит?
4144.22 4153.86 "Анатолий Кулаков" Ну, например, банально в этих опциях, которые, допустим, у вас находятся в виде JSON-файликов, в виде JSON-формата, в этих опциях можно просто-напросто опечататься.
4153.86 4169.26 "Анатолий Кулаков" Например, Эндрю говорит, что у него было несколько раз, когда он просто имя ошибался и вводил неправильное имя-свойство или имя, допустим, всего класса, имя всей секции, которое было, и после этого ловил кучу багов.
4169.26 4175.50 "Анатолий Кулаков" Также интересный пример, что когда он работает под дебагом, у него есть некий секрет-стор.
4175.50 4184.86 "Анатолий Кулаков" И секреты обычно принято хранить во время разработки на машине разработчика, но не в той папке, которая находится непосредственно под версион-контролом.
4184.86 4191.42 "Анатолий Кулаков" Соответственно, когда на машине разработчика все работает, все хорошо, секреты подтягиваются, программа взлетает и успешно работает.
4191.42 4210.50 "Анатолий Кулаков" После этого идет чек-ин в репозиторий, соответственно, в репозитории уже никаких секретов нигде нет, программа деплоится на продакшн, и в продакшне он рассчитывал, что эти секреты возьмутся откуда-то, из какой-нибудь кей-волта, из ажур-кей-волта, из хашекорп кей-волта, не суть важна.
4210.50 4226.50 "Анатолий Кулаков" Но если кто-то забыл эти секреты положить в этот кей-волт, то программа попытается их загрузить, ничего там не найдет, и в качестве ключа, в качестве секретного пароля, в качестве лицензии она ставит null.
4226.50 4230.62 "Анатолий Кулаков" И единственный способ узнать, что там остался null, это упасть.
4230.62 4235.18 "Анатолий Кулаков" И упасть, к сожалению, не в какой-то предсказуемый момент, а когда мы к этому свойству обратимся.
4235.18 4243.42 "Анатолий Кулаков" Ну то есть представьте, у вас годовой отчет, который один раз в год поднимается, ему нужен пароль для того, чтобы обратиться к вашему секретному Excel серверу.
4243.42 4248.46 "Анатолий Кулаков" И вот он раз в год в самый главный момент поднялся и упал.
4248.46 4262.46 "Анатолий Кулаков" И вместо того, чтобы целый год это тестировать, проверять, перенакатывать, обновлять новые релизы, вы об этом не знали, потому что вы не знали, когда он поднимется и ваш самый главный отчет, который считает, какую премию вам в конце года выдать, он упал.
4262.46 4276.30 "Анатолий Кулаков" Это очень плохая практика, а в данной ситуации это еще плохо тем, что ошибка воспроизводится только на продакшене, допустим, только с определенными переменами окружения, только в определенных условиях, только в определенном времени.
4276.30 4281.42 "Анатолий Кулаков" В общем, этого очень сильно хочется избежать, потому что подобные ошибки встречаются очень часто.
4281.42 4292.28 "Анатолий Кулаков" Как я уже сказал, это банальная опечатка, как я уже сказал, это банальная, кто-то забыл добавить секретик, кто-то забыл добавить переменку, за этим может никто так строго не следить.
4292.28 4295.12 "Анатолий Кулаков" В общем, ошибка может быть просто на каждом шагу.
4295.12 4297.52 "Анатолий Кулаков" Это очень большая проблема.
4297.52 4307.36 "Анатолий Кулаков" Давайте посмотрим на поведение класса нашего с опциями, каким образом эти опции банятся при различных проблемах, при различных ошибках.
4307.36 4315.16 "Анатолий Кулаков" Например, если мы ошибемся в названии секции, по сути это мы ошибемся в названии той секции файла, куда будет загружаться весь класс.
4315.16 4331.44 "Анатолий Кулаков" Соответственно, класс, правильнее сказать, байндер, который связывает класс с файликом, он эту секцию вообще не найдет и он просто-напросто создаст пустой инстанс класса, не найдет ни одного свойства, которое нужно записать и вернет его обратно.
4331.44 4334.80 "Анатолий Кулаков" То есть, по факту все свойства у этого класса будут дефолтными.
4334.80 4338.40 "Анатолий Кулаков" То есть, там налы будут везде стоять, там или нолики где-то будут везде стоять.
4338.40 4352.80 "Анатолий Кулаков" В общем, класс абсолютно не юзабельный становится и при этом самое что обидное, никаких эксепшенов, никаких эрроров, никаких напоминаний, вордингов, чего-то еще, делегатов, хендлеров, ничего дергаться не будет, никак об этом мы не узнаем.
4352.80 4363.52 "Анатолий Кулаков" Узнаем, когда непосредственно пойдем обращаться к этому свойству и в твердой уверенности, что в конфиг файлах же она у нас прописана, не будем проверять его на нол и в этот момент мы рухнем.
4363.52 4368.16 "Анатолий Кулаков" Другой пример, когда мы просто-напросто ошиблись в написании самого свойства.
4368.16 4380.48 "Анатолий Кулаков" Это тоже частый случай, ошибка, опечатка, то есть все остальные свойства, кроме этого одного, скорее всего заполнятся правильно, а вот это одно, у него останется значение по умолчанию, допустим, нал.
4380.48 4391.60 "Анатолий Кулаков" Тоже никаких ошибок, никаких напоминаний, даже если вы проверите парочку свойств для того, чтобы перестраховаться, этого все равно недостаточно, проверять нужно все свойства, потому что не заполнены может быть даже одно свойство.
4391.60 4414.92 "Анатолий Кулаков" Если вдруг вы делаете себе пококласс и при этом надеясь, что байндер умеет общаться с приватными сеттерами, то есть оставили только геттеры у своего класса, так тоже бывает, то байндер, конечно, не умеет работать с только геттерами, то есть с ридонали свойствами, он работать не умеет и эти свойства тоже будут не заполнены.
4414.92 4417.76 "Анатолий Кулаков" Все эти свойства останутся с значениями по умолчанию.
4417.76 4421.04 "Анатолий Кулаков" Опять же, никаких ошибок, ничего у нас не будет.
4421.04 4432.44 "Анатолий Кулаков" Еще один интересный пример, это когда вы в своем классике, то есть в своем файле напишите значение JSON, которое не соответствует ожидаемому типу.
4432.44 4438.56 "Анатолий Кулаков" Например, поле у вас булевское, а вы туда напишите строку, какую-нибудь там "hello".
4438.56 4452.44 "Анатолий Кулаков" И когда байндер будет подгружать этот файлик, он найдет правильное значение свойства, он свойства смапит с тем, что находятся файлики, но в этот момент он попытается прочитать значение "hello" и прикастить его к Boolean.
4452.44 4454.48 "Анатолий Кулаков" И естественно у него ничего не получится.
4454.48 4462.32 "Анатолий Кулаков" В этот момент у вас сбросится формат "exception" с нормальной ошибкой, что типа не могу прикастить такую плохую строку к Boolean, что вы делаете, что вы творите.
4462.32 4482.88 "Анатолий Кулаков" В общем будет ошибка инициализации, приложение упадет и в принципе это хорошее поведение, потому что теперь вы четко понимаете, что вам подсунули плохой configuration файл и лучше на самом старте упасть, разобраться в чем была проблема, положить правильный файл, с которым вы точно знаете, что вы будете работать правильно и хорошо.
4482.88 4495.32 "Анатолий Кулаков" Намного конечно лучше, если бы эта ошибка была в compile time, но если подобные ошибки будут выявляться на старте приложения, это тоже в принципе нормально, это тоже в принципе терпимо.
4495.32 4502.12 "Анатолий Кулаков" И соответственно мы подходим к такому простому моменту, что нам нужна валидация.
4502.12 4510.04 "Анатолий Кулаков" Нам нужна валидация наших опций, в том, что там все загрузилось, что это все правильного типа, что мы все нашли и прочее, прочее, прочее.
4510.04 4515.52 "Анатолий Кулаков" Нам нужна такая же валидация, как например, наверное, каждый из вас делал в API-контроллерах.
4515.52 4529.60 "Анатолий Кулаков" Когда к нам приходит какая-то DTOшка, мы желательно хотим у нее убедиться, что в этой DTOшке заполнены определенные поля, что там соответствует каким-то регулярным выражениям, что там есть какая-то максимальная длина значения в поле и так далее.
4529.60 4534.44 "Анатолий Кулаков" То есть стандартные, привычные нам всем валидации над полями, над DTOшками.
4534.44 4540.36 "Анатолий Кулаков" И начиная с .NET Core 2.2, такая возможность более или менее появилась.
4540.36 4542.96 "Анатолий Кулаков" Появился метод validate у опций.
4542.96 4557.96 "Анатолий Кулаков" Более того, появился интересный метод validate data annotations, который позволяет нам навесить уже наши любимые стандартные обычные data annotation атрибуты, которые опять же на JSON мы обсуждали, которые бывают в entity framework.
4557.96 4558.96 "Анатолий Кулаков" Они тоже используются.
4558.96 4565.40 "Анатолий Кулаков" В общем, много где, когда мы работаем на границах приложения, много где используются вот эти data annotation атрибуты.
4565.40 4568.32 "Анатолий Кулаков" И в опциях они точно также поддерживаются.
4568.32 4576.28 "Анатолий Кулаков" Но здесь разработчики допустили следующее стратегическое решение.
4576.28 4585.84 "Анатолий Кулаков" Несмотря на то, что есть метод validate, несмотря на то, что мы можем навесить data annotation атрибуты, эти атрибуты не проверяются на старте приложения.
4585.84 4592.92 "Анатолий Кулаков" Они проверяются в тот момент, когда вы пытаетесь к себе заинжектить эти опции, зарезолвить эти опции.
4592.92 4594.20 "Анатолий Кулаков" Что это означает?
4594.20 4607.76 "Анатолий Кулаков" Что даже если мы ошибемся в написании, вспоминая наш отчет, который один раз в год поднимается в новогоднюю ночь, вот в этот момент он инжектируется к себе в конструктор опции и в этот момент он падает с exception.
4607.76 4623.72 "Анатолий Кулаков" Да, это конечно будет не тогда, когда он обращается к точке secret, но тогда, когда непосредственно резолвится сам хендлер и непосредственно когда резолвится сам класс опций, это будет на пару секунд раньше, наверное, но нам от этого не холодно и не жарко.
4623.72 4627.20 "Анатолий Кулаков" Это все равно происходит один раз в год и эту ошибку поймать будет очень-очень сложно.
4627.20 4636.32 "Анатолий Кулаков" В dotnet 6 сделали великую вещь, они добавили еще один метод, который называется validate on start к опциям.
4636.32 4645.36 "Анатолий Кулаков" Это означает, что во время старта приложения у нас запустится hosted service, который автоматически поднимет опции и провалидирует их.
4645.36 4648.76 "Анатолий Кулаков" И вот это уже в принципе то, что нам нужно.
4648.76 4660.76 "Анатолий Кулаков" То есть нам осталось всего лишь навсего разметить наши DTO-шки специальными dotnet attributes, required, string length, range, наверняка многие из вас их знают.
4660.76 4674.96 "Анатолий Кулаков" Следующее, нам нужно немножко поменять тот binding, который обычно мы делаем, то есть вместо configuration options нам нужно вызвать bind configuration с названием секции.
4674.96 4679.56 "Анатолий Кулаков" Этот bind configuration вернет специальный класс, который называется option builder.
4679.56 4684.84 "Анатолий Кулаков" И этот option builder это как раз тот классик, который умеет настраивать поведение наших опций.
4684.84 4690.08 "Анатолий Кулаков" То есть уже у него есть методы validate data annotations, мы можем подключить туда валидатор из data annotations.
4690.08 4697.52 "Анатолий Кулаков" У него уже есть опции validate on start, мы можем сказать, какие опции нужно валидировать во время старта, какие не нужно валидировать во время старта.
4697.52 4711.36 "Анатолий Кулаков" В общем и в принципе все, с помощью такой конфигурации, с помощью размеченных атрибутов на наших классиках, мы во время старта нашего приложения получим валидацию абсолютно всех опций, которые зарегистрированы в приложении.
4711.36 4721.72 "Анатолий Кулаков" И уже теперь, когда мы с ними начнем работать, мы будем четко уверены, что там находятся все обязательные опции, которые мы хотим, что были обязательные, что они с правильными типами, что они все нашлись.
4721.72 4729.12 "Анатолий Кулаков" А если вдруг не найдутся, то во время старта у нас будет option validation exception, и мы пойдем искать, в чем же проблема.
4729.12 4737.84 "Анатолий Кулаков" Откуда-то не загрузили, где-то опечатались или может быть неправильно что-то написали, но это все мы узнаем прямо сразу, как только приложение начнет стартовать.
4737.84 4742.56 "Анатолий Кулаков" Можно даже сделать такую проверку в тестах.
4742.56 4755.76 "Анатолий Кулаков" Если у вас есть какие-то интеграционные тесты или end-to-end тесты, то во время старта приложения оно автоматически проверит, что хотя бы в той среде, в которой оно запускается, есть хотя бы какие-то дефолтные опции, с которыми можно работать.
4755.76 4761.40 "Анатолий Кулаков" Ну и естественно, если вы запускаете это в продакшен, то там оно, там приложение тем более все проверит.
4761.40 4768.84 "Анатолий Кулаков" И интересно, что так как это проверяется в хостед-сервисе, у вас не будет выставлен health check.
4768.84 4780.80 "Анатолий Кулаков" То есть, допустим, если вы работаете с кубернетесом и если вы используете rolling deployments, то есть, когда вы новый instance, новую версию вашего сервиса деплойте на продакшен, при этом старую еще не гасите.
4780.80 4782.76 "Анатолий Кулаков" В этот момент происходит следующее.
4782.76 4789.56 "Анатолий Кулаков" Если в новой версии у вас есть ошибка, то есть, кто-то опечатался в конфигурационном файле, новая версия падает.
4789.56 4794.68 "Анатолий Кулаков" Она падает, health check не проходит и кубернетес старую версию приложения не убирает.
4794.68 4801.72 "Анатолий Кулаков" Он просто вам репортит куда-нибудь на вашу доску, что деплой новой версии прошел с ошибкой, сходите, разберитесь.
4801.72 4808.12 "Анатолий Кулаков" Но при этом старая версия работает, она продолжает принимать запросы, с ней все хорошо, пользователь все еще активен, он никуда не отваливается.
4808.12 4815.88 "Анатолий Кулаков" И такой способ довольно органично вписывается во все бестпрактисы современной разработки, что не может не радовать.
4815.88 4833.96 "Анатолий Кулаков" Как я уже упоминал, data annotations используются для проверки вот этих опций и это довольно часто используемая штука, ну, наверное, прежде всего потому, что она входит в стандартную поставку дотнет фреймворка и ее очень легко заюзать и поэтому ее практически все используют.
4833.96 4836.60 "Анатолий Кулаков" Но у data annotations есть минусы.
4836.60 4838.04 "Анатолий Кулаков" Они довольно слабы.
4838.04 4848.52 "Анатолий Кулаков" То есть если вам нужно проверить, что поле обязательное, если вам нужно проверить максимальную и минимальную длину строки и может быть даже сопоставить с регулярными выражениями, то все это вы можете сделать.
4848.52 4856.60 "Анатолий Кулаков" Более того, если вы захотите вдруг написать свой атрибут, который добавляет что-то, что не умеет стандартный набор, это тоже элементарно все делается.
4856.60 4865.24 "Анатолий Кулаков" Но в мире существуют более гибкие, более интересные и более удобные библиотеки, в частности такая штука как Fluent Validation.
4865.24 4868.40 "Анатолий Кулаков" Мы уже несколько раз в подкасте про нее рассказывали.
4868.40 4875.72 "Анатолий Кулаков" Но в принципе это классик, который позволяет вам с помощью Fluent Syntax, описать какие-то проверки над вашими классами.
4875.72 4888.80 "Анатолий Кулаков" Он более гибкий, он более такой многословный в правильном, в хорошем смысле этого слова, то есть код читать намного легче, а также у него выдаются более развернутые и понятные для обычного обывателя ошибки.
4888.80 4896.28 "Анатолий Кулаков" Поэтому очень часто люди хотят использовать именно его и здесь тоже нет никаких проблем.
4896.28 4903.20 "Анатолий Кулаков" Вы просто создаете свой класс Fluent Validation Options, который наследуется от специального системного интерфейса iValidateOptions.
4903.20 4912.96 "Анатолий Кулаков" Этот iValidateOptions, то есть этот класс наследник, хорошо подключается в нашем OptionBuilder, который мы упоминали выше с помощью всего лишь на все в одной строчке.
4912.96 4940.04 "Анатолий Кулаков" И после этого валидация всех опций может происходить не стандартным binding validation на основании дата атрибутов, а уже с помощью Fluent Validation, к синтаксис которого обычно многие люди уже знают, к нему привыкли, с его баги и проблемы тоже у них известны, или может даже уже настроены какие-то специальные библиотеки, которые позволяют вам окружить стандартные опции уже стандартными проверками.
4940.04 4954.20 "Анатолий Кулаков" В общем, если вы заинтересованы тем в том, чтобы подключить Fluent Validation к iOptions, здесь вам подойдет статья Андрю Лока, ссылку на которую вы найдете в шоу-нотах, вы просто можете подключить, посмотреть и порадоваться.
4954.20 4962.48 "Анатолий Кулаков" Вот такие возможности по улучшению стандартных iOptions предлагает нам Лок, и мне кажется, довольно полезная штука.
4962.48 4970.28 "Анатолий Кулаков" Я все-таки надеюсь, что они допилят в конце концов null reference type, и половину из всей этой чуши нам будет не нужна, но пока живем так.
4970.28 4975.48 "Игорь Лабутин" Ну и все-таки у тебя отпечаток и прочего это не спасет в конфигурации.
4975.48 4991.00 "Игорь Лабутин" Даже если у тебя null reference type и все хорошо, то есть ты хочешь сказать, что если конфигурация у тебя обозвана как не null поле, то типа runtime или библиотека сама проверит, что что-то попало не null.
4991.00 4992.00 "Анатолий Кулаков" Именно так.
4992.00 5007.64 "Анатолий Кулаков" Как мы обсуждали с тобой в GSON Serializer, который начал поддерживать required, ключевое слово, keyword required, он смотрит, что если там такое ключевое слово стоит, и он не нашел никакого значения, которое может сюда прибайндить, он должен падать.
5007.64 5018.12 "Анатолий Кулаков" Точно так же и здесь, если у тебя есть строго null reference type, и этот null reference type не поддерживает null, и значение не найдено, которое туда можно записать, все должно падать, все должно рухаться.
5018.12 5024.96 "Игорь Лабутин" Интересно, почему они не делали сейчас, потому что это в принципе уже можно сделать хоть сейчас, просто рук не хватает.
5024.96 5025.96 "Анатолий Кулаков" Да, да, можно.
5025.96 5028.52 "Анатолий Кулаков" Более того, я в своих проектах как бы так уже сделал.
5028.52 5032.92 "Анатолий Кулаков" Я переписал этот байндер, он небольшой, и в моих проектах именно так и есть.
5032.92 5036.48 "Анатолий Кулаков" Понятно, почему не стандартных это не делают, в стандартном байндере.
5036.48 5038.84 "Игорь Лабутин" А с какой pull request?
5038.84 5041.16 "Анатолий Кулаков" Будешь гордо говорить, что контрибьючу в рантайм?
5041.16 5047.76 "Анатолий Кулаков" Может быть, просто глядя на вот этот, я хотел так сделать, но глядя на вот этот пьяный байндер, который я упоминал уже выше, мне стало страшно.
5047.76 5057.72 "Анатолий Кулаков" То есть если у них существует человек, который это написал, если у них существуют люди, которые это прое-ре-вью-вили и пропустили как бы в мир, то мне просто страшно туда писать.
5057.72 5067.76 "Игорь Лабутин" Ну, оно же наверняка по чуть-чуть, это же он не за один раз сел и написал все сразу, сначала было просто, а потом две строчки плюс две строчки плюс две строчки, и так получился DTCPP.
5067.76 5074.20 "Анатолий Кулаков" Ну, да, может быть, сначала даже не CPP, наверное, на какой-нибудь COBOL или LISP.
5074.20 5087.04 "Анатолий Кулаков" Тут еще один такой момент, что мне кажется, что все вот эти строго типизированные проверки, которые мы цепляем обычно на DTOшки, на те же самые опции, может быть, даже на Entity Framework, на Entity Framework нет, у него другой подход.
5087.04 5091.52 "Анатолий Кулаков" Давай на DTOшки, на опции, мне кажется, что на самом деле там нужна только Required Attribute.
5091.52 5097.36 "Анатолий Кулаков" Required Attribute элементарно решается с помощью или null-reference-types, или ключевое слово required.
5097.36 5110.24 "Анатолий Кулаков" Желательно и то, и то, конечно, поддержать, и если мы сможем нормально работать на границах приложения с вот этими not null и null-требованиями, то все остальное - это мелочи.
5110.24 5123.36 "Анатолий Кулаков" Вот эти, там, длина строк, там, соответственно, с регулярным выражением, еще что-то - это все обычно уже идут какие-то бизнес-проверки, для которых есть свои подходы, свои валидаторы, свои паттерны и так далее.
5123.36 5127.76 "Анатолий Кулаков" В DTOшках единственное, что надо проверять - это существует значение или не существует.
5127.76 5128.76 "Анатолий Кулаков" Вот это все, что там нужно.
5128.76 5137.88 "Анатолий Кулаков" И вот этот вот маленький фикс, он просто убивает 80% всех проблем, мы с помощью него решим.
5137.88 5158.80 "Игорь Лабутин" Ну, будем надеяться, что потихонечку команды .NET отойдут руки, все это доделают, либо у кого-то из комьюнити дойдут руки, допилить, ну это не runtime, это по сути стандартная библиотека, да, SPNET, до состояния, что нам не придется писать все это самим.
5158.80 5161.76 "Игорь Лабутин" Давай пойдем дальше.
5161.76 5181.64 "Игорь Лабутин" Сообщество .NET.ru снова, назовем это, отличилось, и мы закончили перевод очередной книжки, и это John Smith Entity Framework Core в DST, то есть это Entity Framework Core in Action, очередная книжка из, в общем-то, довольно большой серии, там была SPNET Core от Андрю Лока как раз-таки.
5181.64 5192.08 "Игорь Лабутин" Для того, чтобы этот перевод состоялся, как обычно работала огромная команда переводчиков, большое всем спасибо, и я надеюсь, что это была не последняя книжка, которую мы сделали.
5192.08 5204.80 "Игорь Лабутин" А сейчас, так сказать, переурочек к выходу вот конкретно Entity Framework Core в действии, мы поговорили с одним из тех, кто нам помогал, с Сергеем Бензенко.
5204.80 5206.24 "Игорь Лабутин" Привет, Сергей!
5206.24 5207.24 "Игорь Лабутин" Привет!
5207.24 5219.88 "Игорь Лабутин" Смотри, давай начнем с представления тебя, расскажи вообще, кто ты такой и почему занялся, ну не то, что почему занялся .NET, где ты в .NET, чем занимаешься, чем интересуешься?
5219.88 5228.44 "Сергей Бензенко" Я разработчик, full-step, можно сказать, уже 15 лет работаю на одном месте.
5228.44 5239.88 "Сергей Бензенко" В .NET вошел не так давно, вместе с компанией, которая выразит свою систему.
5239.88 5259.08 "Сергей Бензенко" И вот уже почти 4 года назад решил создать свой телеграм-канал, писать о .NET, о том, как я изучаю его, о том, что нового нахожу, какие интересные вещи.
5259.08 5268.88 "Сергей Бензенко" И вот уже для .NET Core над второй книгой я работал, над первой не очень получилось, так много времени уделить над второй, вот побольше.
5268.88 5274.20 "Игорь Лабутин" Да, давай про каналчик я еще тебя спрошу пару вопросов позже, есть несколько интересных.
5274.20 5275.20 "Игорь Лабутин" Давай про книжку сначала.
5275.20 5284.84 "Игорь Лабутин" Вот мы сейчас закончили перевод книжки про Entity Framework Core in action, и вопрос такой.
5284.84 5287.64 "Игорь Лабутин" А зачем тебе вообще это?
5287.64 5299.52 "Игорь Лабутин" Я вижу, что у тебя телеграм-каналчик в основном на русском, это все здорово понятно на нашу аудиторию, но наверняка же ты документацию читаешь вполне на английском.
5299.52 5327.20 "Сергей Бензенко" Да, конечно, документацию читаю на английском, но интересно, в принципе, у меня даже и канал-то я в основном перевожу английские какие-то статьи, заметки, документацию или что-то такое и выкладываю это на русском, то есть фактически книжка это такая, фактически то же самое, что я и делал на канале.
5327.20 5344.48 "Сергей Бензенко" Поэтому интересно что-то давать русскоязычной публике, ну и самому соответственно изучая, делать какие-то заметки и одновременно помогать соотечественникам русскоговорящим.
5344.48 5358.56 "Игорь Лабутин" Ага, интересно, смотри, действительно ты упомянул, что в этой книжке прям получилось хорошо поучаствовать, тут действительно огромное спасибо, потому что фактически ты ее вычитал практически целиком, там за исключением каких-то очень маленьких кусочков.
5358.56 5369.64 "Игорь Лабутин" Вопрос, это Entity Framework такой привлекательный, книжка попалась такая интересная, сложная или наоборот легкая, или просто так звезды сошлись?
5369.64 5372.36 "Сергей Бензенко" Наверное все вместе.
5372.36 5407.32 "Сергей Бензенко" Про Entity Framework я немножко знал, на работе с ним не удается сильно работать, у нас АДО, как-то так вот получилось, сложилось, потому что была база уже готовая при переходе на .NET, поэтому интересно было и изучить, и что-то новое узнать, ну и одновременно, если хочешь расскажу, возникло просто, так звезды сложились, что возникло какое-то время, которое можно было использовать для перевода.
5407.32 5454.00 "Игорь Лабутин" Про время отдельно интересный вопрос, я как тоже человек, который вычитывает это все потом целиком и сводит финально в тот текст, который финально отправляется в издательство, интересно вопрос планирования, потому что это такая работа, которая с одной стороны, ну раскрою это, секрет не секрет, у нас заняло 4,5 месяца, если я правильно помню, могу сейчас ошибаться, плюс-минус полмесяца, но около того, то есть заранее было понятно, что это довольно долгая работа, и вот вопрос, как планировать такую, как бы, примерно 4-месячную занятость с непонятным, как бы, вообще говоря, выхлопом, потому что то пусто, то густо получается, то мы много читаем, то много свободного времени, то мало свободного времени, все заняты, особо читать нечего, как это происходило у тебя.
5454.00 5509.80 "Сергей Бензенко" А вот здесь как раз именно очень хорошо ты использовал фразу «звезды сошлись», у меня две дочери, которые ходят в компьютерную школу заниматься, это было по воскресеньям, и получалось, что она, школа в центре города, я их отвозил, и вот возникало где-то 3-4 часа такого времени, которое вроде как и не уедешь домой, что 40 минут до дома, потом 40 минут обратно, что вроде как это туда-сюда гонять было неудобно, и вроде как больше заняться особенно нечем, поэтому там, либо в машине, либо зимой, вот в холодное месяце, там в какой-нибудь кфс садился за столик и вычитывал.
5509.80 5515.68 "Сергей Бензенко" Получалось вот такое время, которое вроде бы и нечем занять, и в то же время с пользой.
5515.68 5530.76 "Игорь Лабутин" Кажется, что для такого вычитывания нужно два монитора, на одном английский оригинал, на другом русский текст, на третьем еще какой-нибудь браузер, где проверяешь терминологию, а оказывается можно и в походных условиях в машине.
5530.76 5531.76 "Игорь Лабутин" Интересно.
5531.76 5532.76 "Игорь Лабутин" Да, вполне.
5532.76 5535.32 "Игорь Лабутин" А смотри, это, соответственно, связанный вопрос.
5535.32 5544.20 "Игорь Лабутин" Как ты правильно сказал, ну в смысле, как ты рассказал, у тебя в телеграммчике довольно много именно тоже переводов каких-то новоязычных статей.
5544.20 5548.44 "Игорь Лабутин" Отличается ли это от вычитывания книжки?
5548.44 5550.92 "Сергей Бензенко" Нет, не очень на самом деле.
5550.92 5567.24 "Сергей Бензенко" В основном, ну сейчас, чего уж греха тоить, сейчас переводом вообще заниматься довольно просто, потому что Google Translate за последние лет пять, наверное, просто улетел в космос по качеству перевода.
5567.24 5576.20 "Сергей Бензенко" Я помню, еще когда я переводил по работе сайт на русский язык, тогда это было просто ужас.
5576.20 5599.52 "Сергей Бензенко" Тогда там никакие падежи ни с чем не совпадали, все слова переводились дословно, а сейчас ты просто берешь, закидываешь две страницы текста туда, и он тебе выдает практически идеальный русский текст, в котором в двух-трех местах можно поправить и просто выдавать это как написанный тобой и переведенный тобой.
5599.52 5614.00 "Сергей Бензенко" Поэтому в большинстве статей тоже такой вот обычный английский язык без каких-то выражений.
5614.00 5633.28 "Сергей Бензенко" Единственное, конечно, есть какие-то термины, которые да, нужно гуглить, нужно смотреть, как все-таки используется в русском переводе чаще всего, какое используется название, но это прям мелочи.
5633.28 5649.16 "Сергей Бензенко" И кстати, вот поэтому очень интересно из перевода, что самое сложное было и от чего многие, даже в нашем чате переводчики начали плеваться, это вступительное слово от Джулии Лермонда.
5649.16 5678.80 "Сергей Бензенко" В этой книжке проблема в том, что это вступительное слово написано более таким неформальным английским с использованием фразеологизмов каких-то, чисто английских, и оно не очень легло на машинный перевод, поэтому нужно было знать, что именно значит какой-то именно фразеологизм, чтобы донести до русскоязычных читателей его в точности.
5678.80 5692.00 "Сергей Бензенко" А почему многие сразу столкнулись с трудностями, потому что все-таки это не такой не очень формальный английский язык и сразу получились какие-то шероховатости.
5692.00 5709.36 "Сергей Бензенко" По-моему, это больше всего возникло вопросов по именно небольшому вступительному слову, а дальше мы только спорили о каких-то мелких терминах, какие лучше слова использовать в русском для какого-то слова или словосочетания.
5709.36 5722.40 "Игорь Лабутин" Ну да, я так понимаю, что у нас споры во многом вокруг, используем ли мы какой-нибудь устоявшийся неформальный термин или, возможно, менее популярный, но более официальный, который может быть даже у Microsoft используется.
5722.40 5724.16 "Игорь Лабутин" Да, да, да, это тоже.
5724.16 5737.28 "Игорь Лабутин" Хорошо, еще интересный такой вопрос, как у тебя это происходит, насколько ты берешь текст, он у нас по сути на русском, это Google Doc на русском языке, который нужно привести в нормальный вид, насколько ты часто сверяешься с английским текстом книжки?
5737.28 5750.44 "Игорь Лабутин" По большому счету, ведь читая русский, более-менее, ну особенно если ты представляешь предмет, о чем идет речь, не какую-то абсолютно для тебя новую область, можно же понять, как бы что имел в виду автор, и дальше просто переписать это на нормальный русский.
5750.44 5755.72 "Игорь Лабутин" Или все-таки приходится сверяться все время с английским, чтобы убедиться, что ничего не пропущено, например.
5755.72 5758.32 "Игорь Лабутин" У нас были случаи, когда были пропущены целиком абзацы даже.
5758.32 5779.52 "Сергей Бензенко" Да, в основном можно просчитать именно вот этот русский текст, но я лично возвращался к английскому, только если что-то сам не понимал, чувствую, что куда-то мысль уходит не туда, и что-то мне не совсем ясно, посмотрю-ка я, что там на самом деле было в оригинале.
5779.52 5798.88 "Сергей Бензенко" Ну или когда предложение как-то совсем не так построено, я вижу, ну я довольно много у меня практики общения с англичанами, и я вижу, что предложение можно по словам перевести обратно на английский, и тогда оно выстраивается, и обратно перевести, и тогда оно выстраивается в нормальный, то есть вот в таком.
5798.88 5804.88 "Сергей Бензенко" Чаще всего, когда я смотрел в английский вариант, оно именно вот так и было, как я его обратно перевел.
5804.88 5826.20 "Сергей Бензенко" Но в основном, да, в основном хватало русского текста, и там, где я вижу, что мысль выстроена, и что она правильная и полноценная, то в принципе я не заглядывал в английский вариант, то есть не сверялся вот прям слово-слово-слово-что.
5826.20 5837.12 "Игорь Лабутин" Это значит, что как раз-таки качество исходного перевода на самом деле довольно велико получается, потому что действительно почти… Более-менее, вот опять же,
5837.12 5843.68 "Сергей Бензенко" как я сказал, именно вот с вступительным словом больше всего было вопросов.
5843.68 5858.68 "Сергей Бензенко" А остальное текст, ну, больше на обычном формальном английском, тем более это обучающая книга, там довольно просто, должно быть просто и понятно, всё разъяснено, поэтому он довольно хорошо переводится на русский язык.
5858.68 5864.16 "Игорь Лабутин" Да, это не Конрад Кокосов с "Product of Memory", где, по-моему, первые две главы мы мучились, потому что там…
5864.16 5867.36 "Сергей Бензенко" Не довелось мне, к сожалению, поучаствовать, было бы
5867.36 5892.52 "Игорь Лабутин" очень интересно. Первые две главы, по-моему, две главы были, это история, собственно, условно говоря, компьютеростроения, про то, как там устроена память, всякие описания, как работает SDRAM, DDRAM, ну, короче, там прям такие всякие основы компьютер-сайенса с транзисторами, вот этим всем, и там был прям такой хороший, красивый английский с отсылками тоже во всякие эвфемизмы, это было сложно.
5892.52 5895.04 "Игорь Лабутин" Но остальная книжка, да, уже более техническая.
5895.04 5900.00 "Игорь Лабутин" Смотри, ты сказал интересную фразу про то, что это действительно обучающая штука.
5900.00 5904.00 "Игорь Лабутин" Вот мы переводили книжку, она, по сути, основана на EF Core 6.
5904.00 5918.92 "Игорь Лабутин" Сейчас уже анонсировали… Ну, то есть, вот предыдущая книжка, которую мы делали, это была SPNet, и он тоже был, по-моему, по шестерке, если я правильно помню, но сейчас Андрю Лок уже анонсировал, что он все, обгрейтит книжку до семерки.
5918.92 5932.56 "Игорь Лабутин" Насколько тебе кажется, книжки в этом смысле, ну, актуальны все еще, потому что понятно, что .NET и все сопутствующие вокруг технологии развиваются довольно быстро, и тот же C#.
5932.56 5937.92 "Игорь Лабутин" Прочитав C# через два года, я боюсь, что я могу что-то даже не понять, если я не буду следить за тем, как развивается C#.
5937.92 5939.00 "Игорь Лабутин" Сахара добавляют довольно много.
5939.00 5944.04 "Игорь Лабутин" Твое мнение на этот счет, что делать с книжками?
5944.04 5947.44 "Сергей Бензенко" Я вообще люблю книги, и именно печатные.
5947.44 5957.20 "Сергей Бензенко" Мне нравится читать именно напечатанные книги, не с экрана, потому что за экраном и так сидишь 8 часов, даже больше 10 часов в день.
5957.20 5993.36 "Сергей Бензенко" Что касается обновлений, да, есть, конечно, такая проблема, и она была даже, когда я еще начинал, а уж теперь-то с развитием, с нынешней скоростью развития технологий, тем более, когда новый .NET выходит каждый год, и написать английскую книгу по нему, потом еще ее перевести, это получается, что русское издание будет отставать уже даже от уже выпущенного .NET.
5993.36 6026.52 "Сергей Бензенко" Но в принципе, во-первых, есть какие-то вещи вечные, да, ну можно вспоминать там какой-нибудь «Мифический человеком месяц», хотя он тоже устарел довольно, Рихтера, например, можно вспомнить, но мне кажется, он все равно не устареет, то есть это какие-то основы, которые, при всем наличии сахара, все-таки основная логика все равно неизменна.
6026.52 6045.28 "Сергей Бензенко" Да, можно теперь заменить 10 строчек, которые были в примере Рихтера, на одну, которая теперь предоставляется в новой версии языка, но в принципе, какие-то базовые вещи они остаются.
6045.28 6060.00 "Сергей Бензенко" Что касается ASP.NET и EF Core, все равно все-таки добавляются какие-то не очень значительные функционалы.
6060.00 6100.52 "Сергей Бензенко" В основном, да, бывают какие-то прорывы, в C# можно выделить добавление какого-нибудь Async/Await, в пятой, по-моему, версии, но в принципе-то, между пятой и нынешней версией языка, все-таки добавлялись какие-то очень нишевые штуки, которые можно потом поучить по необходимости, по документации или по каким-то маленьким статьям, но все-таки книжка… Чем мне нравится книга, что она дает все-таки целостное представление.
6100.52 6109.04 "Сергей Бензенко" Если ты не знаешь технологию и ты хочешь ее изучить, все-таки по документации этого сделать практически невозможно.
6109.04 6138.12 "Сергей Бензенко" Все-таки книжка дает тебе и пример, и целостную какую-то картину всего, что ты можешь делать, что ты не можешь делать, а какие могут быть подводные камни вот здесь, вот здесь, вот здесь, с чем, кстати, эта книжка очень хорошо справилась и очень ясно, мне кажется, автор тут выделил в каждой теме какие-то подводные камни.
6138.12 6143.68 "Сергей Бензенко" То есть все равно, мне кажется, книги остаются пока еще востребованы.
6143.68 6144.68 "Сергей Бензенко" Угу.
6144.68 6150.52 "Игорь Лабутин" Слушай, и еще вот такой вопрос про книжки, я сейчас пока думал тоже про обучение.
6150.52 6165.76 "Игорь Лабутин" Вот я помню, когда я уже давным-давно учился, там лет 20 назад получается, по книжкам, очень много книжек было с условно говоря упражнениями в конце глав, типа там вот «а теперь сделайте то, то, то и то».
6165.76 6191.52 "Игорь Лабутин" Вот ты там говорил, что, например, я с EF Core, ну и вообще с антитифреймворком сейчас особо не работаешь, потому что там Аддонет, вот это все, при этом книжку почитать интересно, окей, что-то узнали теоретическое, я тоже не со всеми кусочками EF Core работал, и какие-то кусочки были для меня чисто теоретические, но без практики ведь скорее всего это все забудется или все-таки не забудется и как-то где-то под сознанием останется.
6191.52 6202.96 "Игорь Лабутин" То есть ты вот пытаешься как-то на практике применить, ну попробовать хотя бы то, что прочитал, или просто это, под сознание загрузил, потом когда-нибудь когда применится, знаю как найти.
6202.96 6210.64 "Сергей Бензенко" Иногда, конечно, пытаюсь, когда хватает времени и там может быть желание, да.
6210.64 6226.80 "Сергей Бензенко" Есть хорошее выражение, что по правилу 80/20, что ты прочитав книгу и запомнив оттуда хотя бы 20%, будешь знать на 80% больше того, кто ее не читал.
6226.80 6229.32 "Сергей Бензенко" Все-таки что-то откладывается все равно.
6229.32 6237.36 "Сергей Бензенко" Больше того, ты помнишь, где это ты читал и что вот в этой книжке ты можешь это найти.
6237.36 6258.20 "Сергей Бензенко" И довольно быстро, я довольно часто пользуюсь теми книгами, которые я купил, вот они у меня на полке стоят, допустим, и даже не лезв в интернет, я помню, что это было вот где-то вот в этой книге, какой-то вот такой пример, который мне сейчас нужен, я вот могу его оттуда взять и реализовать.
6258.20 6288.48 "Сергей Бензенко" И тем более, что большинство вот сейчас книг по новым технологиям, пусть не имеют у них каких-то примеров, но они в смысле, которые просят от тебя какой-то практики, но они все-таки построены на построении какого-то законченного приложения, в которое мы добавляем вот этот функционал, вот такой функционал, вот из этой главы мы вот это добавим, а вот в этой главе мы вот это добавим.
6288.48 6303.60 "Сергей Бензенко" Все-таки, да, но конечно, при прочтении все-таки, да, лучше как бы на практике это повторять, чтобы даже на пальцах память осталась, не только в голове.
6303.60 6324.60 "Сергей Бензенко" Но кстати, с другой стороны, еще перевод помогает запомнить больше, потому что ты же не просто пробегаешь глазами по строчкам, да, ты все-таки должен что-то где-то поправить, а что-то где-то посмотреть, а так ли это переведено, а что-то где-то погуглить, какой-то термин или что-то еще такое.
6324.60 6351.24 "Сергей Бензенко" А правильно ли эта фраза, от которой у тебя возникает вопрос, так ли она построена, если в печатной книжке ты уже доверяешь все-таки автору, что он что-то правильно сказал, то здесь все-таки сомнения возникают, и ты бежишь гуглить куда-то в документацию, а правильно ли это переведено и вообще правильно ли автор это выразил.
6351.24 6356.16 "Сергей Бензенко" То есть вот такие моменты все равно позволяют побольше запоминать, чем при простом прочтении.
6356.16 6372.64 "Игорь Лабутин" Да, действительно, кстати, об этом я что-то не думал, потому что получается, что ты пока код внимательно вычитываешь и так далее, ты по сути не можешь себе позволить пропустить то, что ты бы, может быть, пропустил в обычном чтении, потому что засыпаешь, торопишься, еще что-нибудь.
6372.64 6397.72 "Сергей Бензенко" Да, то же самое, кстати, если ты набираешь руками код, все-таки, даже при том, что книгу проверяют несколько человек, все равно там могут оставаться какие-то неточности, и именно на этом, когда ты набираешь код и ты сталкиваешься с какой-то ошибкой, и ты ее гуглишь и исправляешь, вот это, конечно, запоминается больше всего.
6397.72 6403.68 "Игорь Лабутин" Ну да, хорошо, посмотрим, что мы будем изучать в следующий раз, когда у нас будут дальнейшие книжки.
6403.68 6406.16 "Игорь Лабутин" Смотри, еще про телеграм-канальчик хотел тебя спросить.
6406.16 6414.72 "Игорь Лабутин" Вот я сейчас в него зашел, последний пост у тебя, собственно, с сегодняшнего числа, день 1351.
6414.72 6418.92 "Игорь Лабутин" Мне интересно, они вообще вот так прям без пропусков были или там все-таки бывают пропуски?
6418.92 6443.52 "Сергей Бензенко" Да, да, я сам себе поражаюсь, на самом деле, да, я как человек, который не может вообще что-то поддерживать, я все время постоянно что-то бросаю, ну как, наверное, многие из нас, вот это прямо моя самая длинная серия, это действительно канал-дневник, и он идет один пост один день, да, вот 1351 день без пропуска.
6443.52 6460.40 "Игорь Лабутин" Да, вообще прям супер, супер круто, это прям, сейчас мне даже интересно, то есть это получается 337, ну да, в общем, ну круто-круто, то есть почти 4 года, да, я так понимаю?
6460.40 6462.80 "Сергей Бензенко" Да, в конце января будет 4, наверное.
6462.80 6473.72 "Игорь Лабутин" Ага, и у тебя сейчас получается 2000, на момент записи, опять же, 2996 подписчиков, в общем, осталось чуть-чуть, может быть, после подкаста станет побольше, до 3000 как раз добьешься.
6473.72 6483.36 "Игорь Лабутин" А это еще, кстати, интересно, росла аудитория, она вот как-то так равномерно или были какие-то, не знаю, всплески про тебя, все узнали и набежали толпой?
6483.36 6485.16 "Игорь Лабутин" Каково это, вести свой телеграм-канал?
6485.16 6516.84 "Сергей Бензенко" Более-менее равномерно, я, все-таки в первую очередь это дневник, да, и то есть я туда пишу то, что я изучаю, да, конечно, это в какой-то момент уже превратилось в то, что да, вроде есть подписчики, и вроде уже как-то уже надо вроде, да, для них, раз решил каждый день писать, то пишу каждый день, но все-таки это не коммерческий проект какой-то, поэтому там нет такой массовой какой-то рекламы или что-то.
6516.84 6545.84 "Сергей Бензенко" Я, конечно, да, иногда выкладываю, прошу на каких-то каналах делать ссылку, но не то чтобы регулярно, не то чтобы часто, поэтому так постепенно, да, иногда растут, иногда кто-то находит меня и выкладывает ссылку, и оттуда прибегают какие-то, какой-то такой прирост в один день, но в принципе, в основном это просто равномерный рост такой.
6545.84 6555.40 "Игорь Лабутин" Прикольно, это действительно здоровое такое терпение и дисциплина, неудивительно, что получается и книжки хорошие.
6555.40 6557.40 "Игорь Лабутин" Сам себе поражаюсь, еще раз скажу, да.
6557.40 6570.44 "Игорь Лабутин" Супер, ну что, есть ли у тебя что-то еще сказать нашей аудитории на этот раз в качестве такого завершающего мотивационного, не знаю, любого, что-нибудь, есть что-нибудь?
6570.44 6575.20 "Сергей Бензенко" Читайте книжки, подпитывайтесь на канал.
6575.20 6578.20 "Сергей Бензенко" Ссылка будет, конечно, внизу.
6578.20 6593.32 "Сергей Бензенко" Развивайтесь, потому что мне кажется в программировании такая область, в которой относительно легко и дешево развиваться, получать новые знания.
6593.32 6595.84 "Сергей Бензенко" И самое главное, занимайтесь тем, что вам нравится.
6595.84 6609.36 "Сергей Бензенко" Если вам действительно нравится программирование, то занимайтесь этим, потому что, опять же, для русскоговорящей аудитории это особенно важно.
6609.36 6612.64 "Сергей Бензенко" Это хобби, которое приносит хорошие деньги.
6612.64 6618.36 "Сергей Бензенко" С чем, мне кажется, айтишникам очень повезло, как никому другому в России.
6618.36 6629.20 "Игорь Лабутин" И на этой прекрасной ноте мы тогда будем завершать этот кусочек про Дотнэтру и переводы книжек, и телеграм-каналы, и все остальное.
6629.20 6632.52 "Игорь Лабутин" Спасибо, Сергей, за разговор.
6632.52 6635.00 "Игорь Лабутин" Наверное, надеюсь, не последний раз.
6635.00 6636.96 "Игорь Лабутин" Переведем еще что-нибудь, позовем снова.
6636.96 6646.88 "Игорь Лабутин" Обсудить детали, обсудить впечатления, обсудить, куда движется книжная индустрия, и насколько Microsoft все круто меняет, что книжки приходится переводить очень быстро.
6646.88 6648.88 "Игорь Лабутин" Все, спасибо, пока.
6648.88 6649.88 "Игорь Лабутин" Пока.
6649.88 6654.20 "Игорь Лабутин" Спасибо, Сергею, за подключение к нашему подкасту.
6654.20 6666.56 "Игорь Лабутин" В шоу-ноутах будет ссылка на статью, в статье есть промокод на скидку на книжку, так что переходите, читайте впечатления тех, кто переводил, смотрите книжку, образовывайтесь, получайте новые знания.
6666.56 6694.92 "Анатолий Кулаков" Я бы добавил, что если вдруг вы хотите каким-то образом поучаствовать в будущих переводах, а мы уверены, что они все еще будут, также в статье вы найдете ссылочку на наш Telegram-чатик, подключайтесь к нашей команде, там мы обсуждаем будущие переводы, там мы обсуждаем то, что у нас получилось, и даже если вы не хотите переводить, просто хотите высказать нам свое мнение о том качестве материала, который получился, тоже заходите в чатик, мы с радостью любой фидео воспринимаем, в будущем его учитываем и все исправляем.
6694.92 6710.40 "Анатолий Кулаков" Ну, если вы просто захотите пообщаться на тему правильности русского языка в переведенных технических книгах, в переведенной литературе, вот тоже милости поворосим, у нас собрался уже такой довольно большой чатик с любителями русского технического перевода.
6710.40 6717.76 "Игорь Лабутин" А мы пойдем дальше к нашей становящейся уже традиционной рубрике про кратко о разном.
6717.76 6725.96 "Игорь Лабутин" И в этот раз тут… Тут прям получилось, наверное, кратко, но уж очень о разном.
6725.96 6730.12 "Игорь Лабутин" Давай пойдем подряд, сначала Мэтт Скристенсен, мы в прошлый раз упомянули сколько?
6730.12 6733.24 "Игорь Лабутин" Четыре, по-моему, разных экстенджина, да, которые он написал?
6733.24 6734.24 "Игорь Лабутин" По-моему, да, да.
6734.24 6735.24 "Игорь Лабутин" В этот раз еще два.
6735.24 6738.24 "Игорь Лабутин" Короче, по-моему, прям… Мэтт работает.
6738.24 6745.84 "Игорь Лабутин" Звук лок, короче, я жил в студии и хотелки всех, кто когда-либо что-либо хотел, и потихонечку начал пилить это в виде экстенджинов.
6745.84 6754.96 "Игорь Лабутин" На самом деле неплохой действительно вариант, просто посмотрите, как люди будут пользоваться, может быть это… А по поводу поставить не лениво, а вот пользоваться этим никто не будет, когда это выйдет реально.
6754.96 6758.00 "Игорь Лабутин" Поэтому это хороший способ проверить, нужно ли это включать в ядро.
6758.00 6760.76 "Игорь Лабутин" Так вот, экстенджин номер один, Comparing Files.
6760.76 6767.60 "Игорь Лабутин" Теперь вы можете просто сравнить два файлика в Solution Explorer, то есть выделяете два файлика в Solution Explorer, райт кликаете и говорите «Сравнить».
6767.60 6783.32 "Игорь Лабутин" Или можно сравнить файлик с… По файлику, если вы в редакторе тыкните, правая кнопка опять же появится, теперь там есть подменюшка Compare with, по-моему, называется или Compare to, там можно выбрать файлик на диске, либо можно сравнить файлик с клипбордом, это меня прям удивило.
6783.32 6793.64 "Игорь Лабутин" И можно сравнить файлик с его немодифицированной версией, то есть вы что-то там поредактировали, но не сохраняли, и можно сказать Compare с тем, что на диске, и увидеть, что вы поредактировали.
6793.64 6800.52 "Игорь Лабутин" Ну вот такие опции пришли в голову Мэтцу, возможно они есть там в исходном… в исходных просьбах где-то, возможно он тоже их как-то собирал, но тем не менее.
6800.52 6808.92 "Игорь Лабутин" Короче, если вы хотите или вам очень не хватало сравнивать файлов прямо в Visual Studio, попробуйте, может зайдет.
6808.92 6811.28 "Игорь Лабутин" Второй экстенджин называется Copy Nice.
6811.28 6816.36 "Игорь Лабутин" Мы про что-то подобное говорили, по-моему это был Райдер или Ришарпер, или они оба.
6816.36 6828.32 "Игорь Лабутин" Когда вы копируете код из Райдера Ришарпера, вы иногда хотите… ну если вы копируете какой-нибудь очень ложный кусочек, у вас будет скопировано много-много-много пробелов или табов в начале.
6828.32 6835.52 "Игорь Лабутин" И там была такая фича, что вот сколько вы… с какого места вы начнете выделение первой строчки, ровно столько пробелов и останется.
6835.52 6844.16 "Игорь Лабутин" То есть если вы берете какой-то очень ложный if, но курсорчик ставите в строке с if прямо перед и, то скопируется только соотступство самого if.
6844.16 6846.72 "Игорь Лабутин" А все пробелы слева будут убраны.
6846.72 6860.68 "Игорь Лабутин" В Studio теперь это примерно так же работает, но там не настолько гибко все, он просто берет и убирает все пробелы и табы, которые в начале, сохраняя естественные отступы, которые дальше в ложных структурах.
6860.68 6866.68 "Игорь Лабутин" Копируете из Studio, мне кажется штука полезна, она просто по дефолту будет работать, я так понимаю, когда копируете.
6866.68 6871.28 "Игорь Лабутин" Можно забандить на тот же shortcut и просто этим пользоваться.
6871.28 6880.96 "Игорь Лабутин" Мне особо никогда не нужно было, чтобы копировалось вот прям со всеми внешними отступами, поэтому это нормальное дефолтное поведение, кажется.
6880.96 6891.20 "Игорь Лабутин" Так, на самом деле две новости, которые здесь вкратко, мы чуть-чуть их упомянули в основном обзоре .NET 7, это .NET MAUI и Community Toolkit.
6891.20 6901.12 "Игорь Лабутин" Здесь чуть подробнее вышла версия 1.3, оказывается уже у MAUI есть Community Toolkit версии 1.3, то есть это прям как бы не 0, там точка что-нибудь, а уже 1.3.
6901.12 6904.28 "Игорь Лабутин" А тут сам MAUI недавно завелизился, а тут уже прям 1.3.
6904.28 6924.36 "Игорь Лабутин" Да, Community прям, не знаю, насколько там Community прям участвует, но зная, насколько много Community на самом деле участвует в разработке .NET и как часто во всех статьях Microsoft, вот про всякие релиз-кандидаты, указывается на самом деле прям, спасибо-спасибо куча Community-мемберов, то неудивительно, что и в MAUI это все есть.
6924.36 6931.96 "Игорь Лабутин" Там теперь можно ставить статус бары, поддержку Gravatar, еще пачку анимаций завезли и самое главное добавили Source Link.
6931.96 6935.08 "Игорь Лабутин" Теперь если вы используете Toolkit, у вас будет нормальный Source Link для отладки.
6935.08 6963.16 "Игорь Лабутин" И в MAUI же завезли поддержку Xcode 14 и iOS 16, я сначала не понял зачем, а потом, не то чтобы я сильно понял, но по описанию становится хоть немножко понятнее, задача перед Microsoft'ом стояла следующая, как бы нам девелопить под iOS с винды, ну то есть в Visual Studio ты пишешь код, а для iOS, ну как известно, для того чтобы делать под iOS нужен как бы Mac, ну так всегда было, вроде как.
6963.16 6965.72 "Игорь Лабутин" Ну чтобы компилировать, если вы начните.
6965.72 6970.84 "Игорь Лабутин" Да, но на самом деле теперь получается не совсем.
6970.84 6986.56 "Игорь Лабутин" Короче есть два способа, которые сейчас поддерживает Visual Studio, первый называется PR2Mac, ну и он очевидный, вы берете какой-нибудь Mac в вашей локалке, к нему значит, коннектитесь, ну и он за вас будет компилировать, там на нем это все будет запускаться, а вы удаленно это все будете отлаживать и как-то с этим работать.
6986.56 7002.96 "Игорь Лабутин" А второй называется Hot Restart, Hot Restart это вы напрямую подключаетесь к своему iOS или iPadOS, к телефончику или к iPad'у, девайсу прямо с винды, и Visual Studio умеет прямо в iOS или в iPadOS теперь кидать прям, короче, код.
7002.96 7005.32 "Игорь Лабутин" Да, полезная штука, хорошая вещь.
7005.32 7020.20 "Игорь Лабутин" То есть там не будет, вы не сможете таким образом подготовить полностью приложение для публикации в App Store, для этого вам все равно потребуется Mac, потому что там вот все эти кусочки про подпись, вот это все, оно требует нормального X-кода, но по крайней мере просто обычную разработку вы делать сможете по утверждениям Microsoft, так что смотрите.
7020.20 7024.16 "Игорь Лабутин" Может быть теперь стало попроще.
7024.16 7031.64 "Игорь Лабутин" Следующая интересная штука, я сначала не хотел включать, но потом решил, что это интересный кейс.
7031.64 7046.40 "Игорь Лабутин" Вообще в целом, может быть поговорить или просто в качестве такого образовательного кусочка, проект на GitHub'е называется Lombok for.net, если вы знакомы с миром Java, то вы наверняка слышали про проект Lombok для Java.
7046.40 7047.40 "Игорь Лабутин" Ты что-нибудь слышал?
7047.40 7052.68 "Анатолий Кулаков" Да, слышал, и эта гребанная дорога вот срочно закопает меня, не произносив слух.
7052.68 7062.76 "Игорь Лабутин" Не-не-не, нормально, в Java на самом деле она помогает, потому что в Java же, как известно, нету довольно большого количества синтоксического сахара, вам нужно писать вручную всякие GetSet методы, вот это все.
7062.76 7064.72 "Игорь Лабутин" Ну потому что Java отстой, говори прямо.
7064.72 7068.76 "Игорь Лабутин" Ну, Java язык с особенностями.
7068.76 7071.76 "Игорь Лабутин" Альтернативно одаренными, да.
7071.76 7087.04 "Игорь Лабутин" И поэтому там есть проект Lombok, который по сути в каком-то смысле такой полусорс-генератор, там это скорее compile-time-генератор, который позволяет вам просто повесить в атрибут на класс, автоматически, например, сгенерить все GetReset-поля.
7087.04 7096.64 "Игорь Лабутин" Очень удобно для каких-нибудь моделей, вы просто объявляете набор правил полей, потому что поля, очевидно, правилы, автоматически вам генерятся всякие конструкторы, GetReset-ер и так далее.
7096.64 7099.64 "Анатолий Кулаков" Здесь все правильно сравнить даже не с source-генератором, а с Foddy, с AOP-ом.
7099.64 7102.04 "Анатолий Кулаков" То есть он генерит как раз-таки ill.
7102.04 7109.32 "Игорь Лабутин" Ну да, вот я и говорю, поэтому он как бы, ну он да, он скорее генерит ill, согласен.
7109.32 7117.60 "Игорь Лабутин" Так вот, автор этого проекта решил, что ну как бы у нас теперь есть source-генераторы, и давайте попробуем сделать что-нибудь подобное на .NET.
7117.60 7128.96 "Игорь Лабутин" Он там умеет некоторое количество штук генерить, он знает всякие конструкторы, with-методы, singleton, lazy, автоматические async/overload для ваших синхронных методов, toString, iNotifyPropertyChange.
7128.96 7139.92 "Игорь Лабутин" И, наверное, вам это все вряд ли надо именно в production коде, но мне кажется, это неплохой источник посмотреть, как можно писать source-генераторы.
7139.92 7153.48 "Анатолий Кулаков" Лучше смотреть на другие экземплы, которые не предлагают вам настолько мерзких примеров, потому что каждый из них просто фиксится с помощью alt-enter в ReSharper, и легко тебе сделать и toString, и singleton, не дай бог, и with-метки, и
7153.48 7166.84 "Игорь Лабутин" вообще все. Это правда, но прелесть по мне вот таких вот примеров в том, что source-генераторы там довольно простые, то есть можно посмотреть, как например, на source-генератор jigspaw на .NET, но кажется, он не лучший для обучения.
7166.84 7170.12 "Анатолий Кулаков" Да не, ну source-генератор, там сейчас вообще целая куча репозиторий, где ты можешь увидеть.
7170.12 7177.28 "Игорь Лабутин" Ну целая куча, тем не менее, короче, если вы переходите с Jam и вам не хватает ламбока… Выходите тогда обратно.
7177.28 7182.68 "Игорь Лабутин" Ну да, либо допишите эту штуку как-нибудь, чтобы вам было очень все похоже, вам делились.
7182.68 7188.32 "Анатолий Кулаков" Друзья, если вы захотите перейти и посмотреть на этот проект, это только с той целью, чтобы как не надо делать.
7188.32 7189.32 "Анатолий Кулаков" Вот так делать не надо.
7189.32 7193.96 "Игорь Лабутин" Ну, возможно, не знаю.
7193.96 7198.40 "Игорь Лабутин" Я не так категорически настроен, но ладно, пойдем дальше тогда.
7198.40 7209.88 "Игорь Лабутин" Вторая, ну вторая, какая она по счету новость, она на самом деле не столько, насколько про Ажур, с которым я на время работал и немножко продолжаю.
7209.88 7230.36 "Игорь Лабутин" Там интересная штука, если вы пользовались Cosmos DB, про который мы сегодня уже упоминали, который хорошо и нативно поддержан в Entity Framework, там теперь появилась Cosmos DB, а это, как известно, такая база данных, которая одновременно там, у нее есть и реляционная API, и нереляционная API, и по-моему графовая API, и еще какая-то API, их там 4 было.
7230.36 7232.20 "Игорь Лабутин" Короче, теперь там завезли Postgres как бэкэнд.
7232.20 7240.36 "Игорь Лабутин" То есть если вам теперь нужен Postgres в Ажуре, то можно брать Cosmos DB, сказать, а вот мне в Cosmos DB дай Postgres, и у вас будет весь стандартный Postgres.
7240.36 7260.56 "Игорь Лабутин" При этом на бесплатном тарифе понятно, что он там как-то базово работает без всяких шардов и прочего, но если вы пойдете на небесплатный, если вы работаете в том бизнесе, где вы платите за Ажур, то там появляются всякие прям очень клевые фичи, там high availability, короче, автоматические всякие distribute таблицы, шардирование за вас, все это делается.
7260.56 7264.96 "Игорь Лабутин" Короче, если вам не хватало менедж Postgres в Ажуре, вот он появился, смотрите.
7264.96 7271.68 "Игорь Лабутин" Но давай вернемся к нашим, так сказать, низкоуровневым любимым штукам, и конкретно к дотнету.
7271.68 7281.20 "Игорь Лабутин" Мне что-то, я не знаю, не то чтобы мне попалось, а в последнюю неделю лёгкого того, несколько статей попалось на глаза про штуку под названием Unreachable Exception.
7281.20 7283.00 "Игорь Лабутин" Ты слышал про такое до этого?
7283.00 7284.68 "Игорь Лабутин" Нет, не приходилось.
7284.68 7295.80 "Игорь Лабутин" Короче, как выяснилось, было API Proposal, его долго обсуждали, так не странно, но в dotnet 7 rc1, то есть тоже это в прошлом релизе, не знаете, добавили специальный exception.
7295.80 7301.04 "Игорь Лабутин" У нас теперь есть exception под названием System Diagnostics Unreachable Exception.
7301.04 7302.04 "Игорь Лабутин" Так, подробнее.
7302.04 7312.88 "Игорь Лабутин" Который наследуется от обычного exception, и он предназначен для того, чтобы кидать его в тех местах, в которые код у тебя в принципе по определению дойти не должен.
7312.88 7318.88 "Игорь Лабутин" Ну, например, в pattern matching, то есть вот ты написал какой-нибудь там, не знаю, enum, да?
7318.88 7320.88 "Игорь Лабутин" Ну ладно, enum плохо.
7320.88 7330.68 "Игорь Лабутин" Ну хотя даже enum, окей, например, обработал все кейсы, но технически у тебя же может там в этой переменной лежать там назначение, которое не входит в валидный ренч enum.
7330.68 7331.68 "Игорь Лабутин" Out of range exception.
7331.68 7344.92 "Игорь Лабутин" В enum-ах да, а в более сложных паттерн-чём-нибудь, когда у тебя pattern matching там с кучей вложенных этих классов, пропертей, списков, end-ов, or-ов и прочего.
7344.92 7356.84 "Игорь Лабутин" Короче, эта штука, ну по замыслу автора, предполагается писать во всех этих fallback, типа когда нижняя подчёркива не пишешь последнюю опцию, fallback вот этого всего, вот там кидай, туда прийти не должно.
7356.84 7367.36 "Анатолий Кулаков" Ну, как-то мутно, потому что если у тебя есть какой-то монетный набор, в который ты не вписался, это обычно какой-нибудь out of range или bad format, или что-нибудь в этом духе.
7367.36 7368.36 "Игорь Лабутин" То есть это всё-таки неunreachable.
7368.36 7373.36 "Игорь Лабутин" Не всегда, и смотри, в чём тема.
7373.36 7380.44 "Игорь Лабутин" Как бы по замыслу автора, и на самом деле в рантайме они с этим согласны, они собираются в рантайме его некоторое количество использовать.
7380.44 7385.52 "Игорь Лабутин" С точки зрения обычного кидания, по большому счёту, да, тебе всё равно что кинуть.
7385.52 7389.32 "Игорь Лабутин" У меня на самом деле стандартный exception на эту тему, это всегда invalid operation.
7389.32 7392.44 "Игорь Лабутин" Не знаю, почему, я как-то invalid operation обычно всегда кидаю.
7392.44 7396.64 "Игорь Лабутин" Хотя там по замыслу это может быть и аргумент на самом деле какой-нибудь.
7396.64 7403.08 "Анатолий Кулаков" Да, я тоже более того, invalid operation по description не подходит в этих ситуациях, в читаться.
7403.08 7405.80 "Анатолий Кулаков" Но почему-то люди именно его бросают.
7405.80 7408.80 "Игорь Лабутин" Самый удобный, знаешь, не надо думать.
7408.80 7425.72 "Игорь Лабутин" Смысл этой штуки был в том, что у тебя, короче, этот exception можно пытаться, точнее, код, где выбрасывается этот exception, с точки зрения именно синтоксического, когда ты его анализируешь, синтоксические анализаторы, они его могут игнорить, например, с точки зрения какого-нибудь код кавериджа.
7425.72 7436.56 "Игорь Лабутин" Потому что писать тесты, которые покавырят вот эти конкретные строчки, выкидывание вот этих всех странных штук, ну не всегда разумно.
7436.56 7454.36 "Игорь Лабутин" То есть если у тебя действительно есть валидация, да, и вот этот вот аргумент out of range, ну то есть да, аргумент out of range действительно это событие, по которому ты там, не знаю, что-то ловишь в исходящем коде и на этом что-то основано в логике, да.
7454.36 7457.64 "Анатолий Кулаков" Ну ты тестируешь, как у тебя правильно отрабатывает валидация на плохих кейсах.
7457.64 7476.64 "Игорь Лабутин" Да, но если у тебя, ну то есть смотри, у тебя может быть реальная валидация сначала, правильно, а потом ты вызываешь метод, внутри которого pattern matching, и ты знаешь, что по твоей бизнес-логике, если валидация прошла, то у тебя не должно, ты не должен свалиться вот в этот вот дефолтный fallback вариант, короче, pattern matching, ну вот в бизнесу они так написаны.
7476.64 7484.00 "Игорь Лабутин" Но если всё-таки, то есть и это значит, что в нормальном коде, скорее всего, ты туда никогда не свалишься, если у тебя что-то где-то не синхронизировалось.
7484.00 7490.56 "Игорь Лабутин" Вот короче, они хотят, идея была добавить, чтобы можно было как-то это обрабатывать отдельно с точки зрения, что мы подчеркиваем, что код не аналитичный был.
7490.56 7504.96 "Игорь Лабутин" Это на самом деле костыль в отсутствии нормальной тех самых там алгебрических типов, вот этого всего, discriminated unions и всех таких, когда ты можешь просто, компилятор на уровне компиляции знает полный набор того, чего может произойти в pattern matching.
7504.96 7506.92 "Игорь Лабутин" У тебя всегда есть этот fallback вариант.
7506.92 7528.88 "Анатолий Кулаков" Да, я тоже такую штуку в своём школе использую, конечно, и я его применяю как раз-таки там, где я использую null reference типы, я очень жёстко и плотно сижу на null reference типах, и там, где ты каким-то образом где-то в код выше проверил, что там null быть не может, но компилятор по своей тупости всё ещё этого не понимает, вот там я ему бросаю, что здесь не null или брось мне здесь unreachable exception.
7528.88 7532.84 "Анатолий Кулаков" То есть это тот exception, который на практике никогда в жизни не бросится.
7532.84 7533.84 "Игорь Лабутин" Да.
7533.84 7537.44 "Игорь Лабутин" Ну и как бы, хорошо, никогда в жизни не должен бы броситься.
7537.44 7539.04 "Игорь Лабутин" Да, не должен бы, допустим.
7539.04 7544.36 "Анатолий Кулаков" То есть это больше подсказка компилятору, это как раз-таки отсутствие алгебраических типов больше в эту сторону,
7544.36 7562.92 "Игорь Лабутин" чем какой-то настоящий exception, который мы ожидаем. Но если у тебя какой-то проект, где, например, из-за каких-то требований, не знаю, заказчика или чего-нибудь, тебе требуется не знаю, 100% coverage, ну вот такое требование, то, блин, писать тест, который конкретно в твоих null reference вариантах таки прокинет туда null восклицательный знак, ну как-то странно.
7562.92 7571.80 "Игорь Лабутин" Ну это просто чисто как бы тест ради приседания вокруг компилятора, потому что компилятор что-то не имеет, а так, возможно, coverage tools будут там что-то понимать и игнорить его.
7571.80 7575.76 "Игорь Лабутин" Ну в общем, короче, возможно, вас это заинтересует.
7575.76 7580.36 "Игорь Лабутин" Последняя тема про внутренности дотнета — это greenthreads.
7580.36 7587.60 "Игорь Лабутин" Опять хочется сослаться на Java, да, где Project Loom и вот это все, и там это уже практически, я так понимаю, завезли.
7587.60 7591.84 "Игорь Лабутин" В дотнете, соответственно, эта работа пока только начинается, ну точнее не так.
7591.84 7601.12 "Игорь Лабутин" Дэвид Фаулер опубликовал твит, ну серию на самом деле небольших твитов на тему того, что вот мы тут экспериментируем с гринтредами, ссылка на твит есть, соответственно, на FlowMods.
7601.12 7610.08 "Игорь Лабутин" Там набежали комментов со словами, блин, мы же это все пробовали в 2004, там еще Эрик Липерт писал, что это нафиг никому не надо, все такое, что поменялось в мире, что нам теперь это надо.
7610.08 7618.56 "Игорь Лабутин" Там, в общем, интересно почитать, пока это все только очень ранние эксперименты в специальном репозитории, который называется Runtime Lab, там есть pool-реквестик, который их добавляет.
7618.56 7629.08 "Игорь Лабутин" В общем, если вам интересно о судьбах гринтредов в этом, то, видимо, может быть это какой-то очень early эксперименты и нет никаких гарантий, что они хоть куда-то войдут.
7629.08 7638.28 "Игорь Лабутин" У Java это заняло несколько лет, насколько я понимаю, чтобы Project Doom довести хоть до какого-то состояния, чтобы в формате превью начать добавлять его в релизы.
7638.28 7655.76 "Игорь Лабутин" Так что не то, чтобы мы ждем там гринтредов в 8-ом .NET, но судя по всему что-то в этом направлении команда делает и может быть сейчас как раз такое типа полузатишье перед релизом, какие-то прояснения планов на следующий .NET, может быть мы что-то увидим.
7655.76 7663.28 "Игорь Лабутин" Как только будет что-то более конкретное и более понятное, мы обязательно это, естественно, будем обозревать в качестве основной темы выпуска.
7663.28 7667.40 "Игорь Лабутин" Так, коротенько, очень у нас о разном.
7667.40 7686.76 "Игорь Лабутин" Да, Женя Пешков, небезызвестный вам по докладам на .NEXT, на митапах, да и вообще в принципе известный в комьюнити человек, он начал свой блог, у него он есть на гитхабе, у него есть телеграм-канальчик, ссылочка в описании, пишите, подписывайтесь, пишите, что вы хотите от него узнать.
7686.76 7704.52 "Игорь Лабутин" Он будет, он периодически, ну вот уже, по-моему, проводил, по крайней мере, опрос типа на какую тему вы хотите, чтобы я что-нибудь написал следующее, так что видимо у него есть какой-то набор идей, будет, если какие-то еще есть идеи, закидывайте ему, я думаю, что он сейчас будет, надеюсь, что он будет много туда писать.
7704.52 7760.40 "Анатолий Кулаков" Я еще встретил новость, что зарелизился OpenSilver 1.1, это проект, который обещает 99% совместимости с Silverlight, если вы помните такую штуку, Silverlight это, в принципе, был довольно популярный продукт, правда, недолго, он позволял вам запускать ваше .NET приложение в браузере, звучит, конечно, знакомо, и именно на этом и сыграли авторы OpenSilver, они сделали таким образом, что немножко улучшили эту концепцию, потому что Silverlight запускался с помощью специального плагина, плагины ставить в браузер для того, чтобы показывать кнопочки нынче не модно, типа никого вы сейчас Silverlight и Flash не соблазните, поэтому ребята из OpenSilver сделали по-другому, они взяли код Silverlight, то есть проектов, написанных на Silverlight и сконвертировали их под VBSsembly и HTML5, то есть то же самое, что сейчас делает Blazor.
7760.40 7776.36 "Анатолий Кулаков" И таким образом у нас появилась отличная совместимость без всяких плагинов на современных стэках, очень быстрая, с полной поддержкой всего того богатства, что раньше умел Silverlight, и самое интересное, что с поддержкой различных контролов.
7776.36 7791.40 "Анатолий Кулаков" Silverlight Toolkit Library Controls поддерживается, Telerik RedGridView поддерживается, Kalibur Micro, хороший тоже фреймворк, Microsoft Enterprise Library и в общем все большие вещи, которые вы знаете, там есть.
7791.40 7804.08 "Анатолий Кулаков" Лично для меня Silverlight прекрасен тем, что там можно было писать UI на нормальном XAML, а не на этом убогом обрубке, который называется HTML, CSS и не дай бог JavaScript.
7804.08 7821.36 "Анатолий Кулаков" В общем, в принципе идея богатая, и я думаю, что скорее всего новые приложения вам никогда не понадобится писать на этой совместимой платформе с Silverlight, но если вдруг у вас почему-то есть задача поддерживать старые приложения, то данный проект наверняка может дать вам вторую жизнь этим вашим приложением.
7821.36 7828.08 "Анатолий Кулаков" Уже как-то у нас коротко о разном получилось, совсем ни разу не коротко, как бы оно не перешло у нас в дайже с основного выпуска.
7828.08 7854.56 "Игорь Лабутин" Ну, мы будем стараться, чтобы не перешло, но вообще пишите, насколько вам там, насколько должно быть кратко, насколько о разном, если есть какие-то на самом деле темы, которые, по вашему мнению, было бы тоже интересно туда включать, можете какие-нибудь примерчики таких ссылок, не знаю, или заголовков нам кидать в комменты куда-нибудь на YouTube, там где вы нас комментируете, мы посмотрим.
7854.56 7863.12 "Игорь Лабутин" Скорее всего мы не будем сильно расширять эту часть, но вот то, сколько сегодня мы про нее поговорили, мне кажется, вот это примерно оптимальный объем.
7863.12 7872.40 "Анатолий Кулаков" Ну, также у нас есть почтовый ящик, радиособакадотнет.ру, в общем, туда можно тоже писать, и обязательно все это дойдет.
7872.40 7887.80 "Игорь Лабутин" Да, давайте напомним, что сегодня мы поговорили про .NET 7 Release Candidate 2, там и основной .NET, сильно много не поменялось, но тем не менее что-то поменялось, SPNET, EF, MAUI, в общем, .NET развивается и ширится.
7887.80 7895.00 "Игорь Лабутин" Консоли, теперь на Linux и Unix работают получше, распознают всякие хитрые комбинации клавиш.
7895.00 7905.76 "Игорь Лабутин" System Text JSON в .NET 7, сильно нового ничего не завезли, но, в смысле, прям вот в последнем Release Candidate, но мы вспомнили все, что с ним происходило за последний год.
7905.76 7922.36 "Игорь Лабутин" У райдера вышел EAP 2, обсудили статью Андрю Лока про то, как валидировать конфигурации, строго типизированные конфигурации объектов, это еще в .NET 6 доступно, так что вполне спокойно можно использовать.
7922.36 7927.68 "Игорь Лабутин" Правильный перевод John Smith, Entity Framework Core действий от команды .NET.
7927.68 7936.00 "Игорь Лабутин" И кратко о разном, куча всяких разных новостей про то, что вообще происходит в .NET и не только в .NET мире.
7936.00 7940.16 "Игорь Лабутин" На этом, наверное, все, это был 59 выпуск радио .NET.
7940.16 7942.56 "Анатолий Кулаков" И с вами был Анатолий Кулаков.
7942.56 7943.56 "Анатолий Кулаков" И Игорь Лaбутин.
7943.56 7944.56 "Анатолий Кулаков" Всем пока.
7944.56 7945.06 "Анатолий Кулаков" Счастливо.
7945.06 7946.06 "Анатолий Кулаков" Счастливо.
