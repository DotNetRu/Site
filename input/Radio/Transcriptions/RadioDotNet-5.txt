0.00 3.64 "Анатолий Кулаков" Здравствуйте, дорогие друзья.
3.64 7.08 "Анатолий Кулаков" Это Radio.net, и мы уже записываем пятый выпуск.
7.08 10.44 "Анатолий Кулаков" И в студии сегодня для вас работает Анатолий Кулаков.
10.44 12.08 "Игорь Лабутин" И Игорь Лабутин, привет.
12.08 14.48 "Анатолий Кулаков" Игорь, слышал, что с Dylan Beattie произошло?
14.48 19.68 "Игорь Лабутин" Ну, где-то в конце того года у него закрылась компания, которая он был.
19.68 28.92 "Игорь Лабутин" Он там всячески переживал на тему, как теперь жить и в плане компании, и работы, плюс одновременно с этим Англия, Brexit, вот это все.
28.92 30.68 "Игорь Лабутин" И было все очень неопределенно.
30.68 32.20 "Игорь Лабутин" Чем все закончилось сейчас?
32.20 36.04 "Анатолий Кулаков" Смотри, еще интересно ответить, что компания была не просто так, компания SkillMatter.
36.04 38.76 "Анатолий Кулаков" В принципе, это довольно известная штука.
38.76 41.36 "Анатолий Кулаков" Она делала всякие тренинги, курсы, видеозаписи какие-то.
41.36 44.96 "Анатолий Кулаков" Не сказать, чтобы она была очень популярная, но светилась много где.
44.96 47.92 "Игорь Лабутин" Да, и все, ее совсем нету?
47.92 49.60 "Анатолий Кулаков" Да, компания панкротилась.
49.60 54.60 "Анатолий Кулаков" Dylan Beattie не стал долго выдумывать что-то.
54.60 56.76 "Анатолий Кулаков" Он организовал свою собственную компанию.
56.76 60.16 "Анатолий Кулаков" Компания называется UrsaTile, если я правильно прочитал.
60.16 62.64 "Анатолий Кулаков" В общем, компания занимается абсолютно всем подряд.
62.64 70.44 "Анатолий Кулаков" Он предлагает делать тренинги, предлагает консультацию, предлагает какую-то разработку, заказную.
70.44 75.92 "Анатолий Кулаков" В общем, Дилон мастер на все руки, я думаю, все из вас, кто хоть раз был на его докладах в этом, могли убедиться.
75.92 79.68 "Анатолий Кулаков" И он решил все это свое мастерство пустить в дело.
79.68 81.28 "Анатолий Кулаков" И создал свою собственную компанию.
81.28 87.64 "Игорь Лабутин" И будет там один, или он там с кем-то? Непонятно пока.
87.64 89.16 "Анатолий Кулаков" Пока он там один.
89.16 95.12 "Анатолий Кулаков" У него есть сайт, у него есть твиттер, он зарегистрировал везде торговую марку, это официальная контора.
95.12 96.76 "Анатолий Кулаков" И пока он там работает один.
96.76 104.56 "Игорь Лабутин" Ну посмотрим, пожелаем удачи, потому что в принципе Дилон человек опытный и должен здорово всех учить.
104.56 111.72 "Игорь Лабутин" Но при этом я кстати сейчас зашел на сайт Skills Matter ради интереса посмотреть, как выглядит сайт компании, которая была обанкротилась.
111.72 117.76 "Игорь Лабутин" И там на самом деле есть единственная страничка фронтпейджа, где написано "We are happy to announce that Skills Matter is back".
117.76 123.16 "Игорь Лабутин" Они нашли видимо какого-то спонсора, который по крайней мере точно восстановит всю библиотеку всех видосиков, которые у них была.
123.16 126.80 "Игорь Лабутин" Но как это будет дальше, пока непонятно.
126.80 134.92 "Игорь Лабутин" То есть по крайней мере то, о чем сокрушалось сообщество на тему того, что все видео были утеряны, нет, они не утеряны, они будут обратно восстановлены.
134.92 136.12 "Игорь Лабутин" Это кажется здорово.
136.12 141.20 "Анатолий Кулаков" Да, да, видео там тоже в довольно интересные попадаются картины, поэтому хотелось бы их куда-то хотя бы выложить.
141.20 143.88 "Анатолий Кулаков" Но скорее всего Дилон Бити им уже не вернуть.
143.88 145.84 "Игорь Лабутин" Да, я думаю, что тоже.
145.84 150.52 "Игорь Лабутин" Хотя есть много разных вариантов и способов, да.
150.52 152.32 "Анатолий Кулаков" Хорошо, давай к темам.
152.32 158.72 "Анатолий Кулаков" Не будем забывать, что мы все-таки технический подкаст, и если смотреть в будущее, то в будущем нас ждет C# 9.
158.72 172.32 "Анатолий Кулаков" C# 9 еще в принципе довольно расплычат, еще не анонсированы его конкретные даты, но уже поступило очень много пропозов, очень много идей, очень много того, что бы нам хотелось бы добавить, что бы нам хотелось бы видеть в новом языке.
172.32 173.84 "Анатолий Кулаков" И там много всего интересного.
173.84 175.16 "Анатолий Кулаков" Давай пробежимся по списку.
175.16 176.16 "Игорь Лабутин" Давай пробуем.
176.16 183.40 "Игорь Лабутин" Надо сразу предупредить, что есть некоторая вероятность, что то, что мы сейчас озвучим, не будет реализовано в C# 9.
183.40 187.40 "Игорь Лабутин" И возможно даже большая часть из того, что мы озвучим, не будет реализована.
187.40 195.00 "Игорь Лабутин" Поэтому пока это только наметки и есть пропозлы по разным темам, разным вариантам реализации.
195.00 202.48 "Игорь Лабутин" И когда все это будет обсуждено и реализовано, тогда только мы будем понимать, какие же точно фичи войдут в C# 9.
202.48 207.08 "Игорь Лабутин" Но это не мешает нам обсудить их прямо сейчас и помечтать, что они все войдут.
207.08 210.92 "Анатолий Кулаков" Именно так. Хорошим подтверждением твоих слов являются рекорды.
210.92 213.72 "Анатолий Кулаков" Рекорды мы ждали еще в предыдущем C#.
213.72 218.88 "Анатолий Кулаков" Их уже почти заимплементили, почти внедрили, почти дотестировали, но в последний момент вырезали.
218.88 231.48 "Анатолий Кулаков" Там было на это несколько причин, но это хороший показатель того, что даже фича была проанонсирована, уже прообсуждена много раз во многих блогах, и все равно так и не доехала в конце концов в C# 8.
231.48 234.48 "Анатолий Кулаков" Но мы надеемся, что в C# 9 все-таки завезут.
234.48 236.00 "Анатолий Кулаков" Что же такое рекорды?
236.00 241.68 "Анатолий Кулаков" Рекорды - это способ намного быстрее и компактнее создавать наши классы.
241.68 252.28 "Анатолий Кулаков" В общем, ребята из Microsoft сели, проанализировали существующий код и нашли интересную зависимость, что очень-очень много классов в нашем коде мы пишем довольно примитивных.
252.28 258.64 "Анатолий Кулаков" Ни каких-то там больших, разносторонних, развесистых, в которых там блещет бизнес-логика изо всех узлов, и все такое.
258.64 267.28 "Анатолий Кулаков" А просто такие примитивные служебные классы, типа структурки, у которых есть конструкторы, у которых есть пару полей, которым мы их один раз проанализировали и дальше гоняем везде.
267.28 271.92 "Игорь Лабутин" Угу. И... так, ты сказал забавную штуку.
271.92 275.92 "Игорь Лабутин" Классы или структурки? Так рекорды - это будут классы или будут структурки?
275.92 283.00 "Анатолий Кулаков" Пока дискуссии не стихают, вроде даже хотят сделать какой-то атрибут, который способен менять это поведение, но пока это классы.
283.00 294.88 "Игорь Лабутин" Угу. Потому что, как мне кажется, на структурах это было бы вдвойне полезно, потому что если ты на классе сделал иммьютабл, добавил пару-тройку read-only-properties и конструктора - это одно.
294.88 307.08 "Игорь Лабутин" А на структурах нужно при этом не забыть правильно сделать всякий iEquatable, переопределить все нужные сравнения, правильно написать getHashCode и все такое прочее.
307.08 316.60 "Игорь Лабутин" То есть для структуры это гораздо более замороченная процедура, и получить вот такие рекорды структуры было бы, конечно, гораздо удобнее.
316.60 324.60 "Анатолий Кулаков" Да, но тут нужно помнить, что когда ты работаешь со структурами, существует огромное количество подводных камней, и может быть это осузило бы применимость данной фичи.
324.60 328.60 "Анатолий Кулаков" Потому что по зламыслу автора как раз рекорды должны быть очень применимы.
328.60 335.84 "Анатолий Кулаков" Угу. Потому что они, весь вот этот код, про который я говорил, все эти примитивные классики, могут сжать в одну строчку.
335.84 340.48 "Анатолий Кулаков" Всего лишь навсего в одну строку, в которой описываются все поля, все типы этих полей и все, что вам нужно.
340.48 352.52 "Анатолий Кулаков" И далее эта строка разворачивается уже в полноценный класс на этапе компиляции, и этот класс интересен тем, что он автоматически вам добавит те поля, которые вы написали в этой одной строке.
352.52 356.52 "Анатолий Кулаков" А строка выглядит, надо понимать, как primary конструктор.
356.52 360.52 "Анатолий Кулаков" Как конструктор, у которого есть, соответственно, параметры, которые он принимает.
360.52 367.76 "Анатолий Кулаков" Это значит, что под каждый этот параметр будет сгенерено поле, рекорды будут неизменяемыми, потому что это, в принципе, тренд.
367.76 376.76 "Анатолий Кулаков" Уже все поняли, что неизменяемый класс — это хорошо, и так как рекорды довольно примитивные и не содержат вообще никакой логики, для них неизменяемость — это как раз то, что доктор прописал.
376.76 382.24 "Анатолий Кулаков" Рекорды автоматически будут имплементить и quotable, который позволяет их сравнить путем сравнения каждого поля.
382.24 390.72 "Анатолий Кулаков" Там будет реализован автоматический деструктор и наверняка много полезных базовых имплементаций, которые есть в стандартных библиотеках.
390.72 399.72 "Анатолий Кулаков" Вот такими маленькими, но емкими классами Microsoft хочет приучить нас создавать более типизированные объекты и лучше играться с типами.
399.72 405.24 "Анатолий Кулаков" Рекорды — это как раз таки штука, которую Microsoft продолжает тянуть из функциональных языков.
405.24 415.52 "Анатолий Кулаков" В частности, как и многие фишки последних нескольких релизов, все это сначала опробовалось на F# и теперь качают к нам в C#.
415.52 440.12 "Игорь Лабутин" Ну, действительно, мне по такому описанию кажется, что рекорды как классы — это действительно удобный способ быстро создавать небольшие классы, а рекорды как структуры — это, пожалуй, самый хороший способ будет правильно создавать неизменяемые структуры, чтобы не ошибиться в реализации всех стандартных методов, которые нужно написать для хорошей неизменяемой структуры.
440.12 451.20 "Игорь Лабутин" И ты действительно сказал, что там много чего тащится из функционального программирования, из F# в частности, и следующая тема — это discriminated union, и, по-моему, я про них тоже слышал на этапе 8 C#.
451.20 457.96 "Анатолий Кулаков" Да, ну там их только обсуждали, и плюс по ним готовили pattern matching, потому что многие люди удивляются.
457.96 468.36 "Анатолий Кулаков" Там некий pattern matching, которым функциональщики пугали и восхищались уже многие 10 лет, и вот он пришел к нам в C#, и не сказать так, чтобы его часто пользовались.
468.36 473.96 "Анатолий Кулаков" Ну, то есть многие люди даже ни разу за все эти годы, когда внедрили себе новую версию языка, ни разу даже не использовали.
473.96 477.96 "Анатолий Кулаков" Такого злобного и страшного слова, как pattern matching, быть не должно.
477.96 481.20 "Анатолий Кулаков" Поэтому у многих встал в нем и вопрос, а неужели это все?
481.20 486.44 "Анатолий Кулаков" Неужели это все, что обещали нам большевики, вот это тот pattern matching, который мы сейчас имеем в C# 8?
486.44 490.92 "Анатолий Кулаков" По правде, это не все. По правде, это только вот даже не половинка.
490.92 494.72 "Анатолий Кулаков" Это маленькая заготовочка того, что умеет настоящий pattern matching.
494.72 502.84 "Анатолий Кулаков" И одна из самых глобальных вещей, с которыми он используется, и способна раскрыть полную мощь pattern matching, это как раз discrimination union.
502.84 512.40 "Анатолий Кулаков" И discrimination union объяснить ООПшнику без примера, без конкретного, который нельзя написать кодом или графически, довольно-таки сложно, по крайней мере мне.
512.40 531.12 "Игорь Лабутин" Не, ну, юнионы были в C++, я помню, что со времен своего программирования на C++ это была очень удобная тема, когда ты там писал юнионы из, не знаю, float и charat 4, да, массив из 4 байтов, и успешно либо работал с ними как с байтами, либо как с полноценным float.
531.12 538.52 "Анатолий Кулаков" Да, можно отталкиваться от представления юниона в C++, но настоящие discrimination юнионы очень далеко от этого ушли.
538.52 546.48 "Анатолий Кулаков" Это можно представить как строго типизированный discrimination union, но не просто так, а еще с богатой системой типов.
546.48 550.44 "Анатолий Кулаков" Может быть, вы когда-нибудь слышали такое выражение, как алгебраические типы данных.
550.44 562.00 "Анатолий Кулаков" Вот когда в C# появится discrimination union, это станет полноценным языком с алгебраическими типами данных, что, в принципе, не удосуживался пока еще ни один язык объектно-ориентированный.
562.00 565.12 "Анатолий Кулаков" Это был удел чисто функциональных языков.
565.12 569.48 "Анатолий Кулаков" Давайте попробуем на конкретных пальцах объяснить, что же это значит.
569.48 571.64 "Анатолий Кулаков" Например, представим себе способ оплаты.
571.64 575.40 "Анатолий Кулаков" Вы реализуете у себя в программе способ оплаты, который выбрал пользователь.
575.40 581.04 "Анатолий Кулаков" Пользователь может выбрать, например, заплатить деньгами, заплатить кредитной картой или, может быть, заплатить натурой.
581.04 584.92 "Анатолий Кулаков" Вам его выбор нужно сохранить в какую-то переменную.
584.92 595.20 "Анатолий Кулаков" Обычно эта переменная будет какой-то базовый класс способ оплаты, в нее темп 3 наследника, и один из конкретных реализаций наследника будет представлять то, что выбрал пользователь.
595.20 598.00 "Анатолий Кулаков" Этот подход имеет очень много минусов.
598.00 604.60 "Анатолий Кулаков" В частности, то, что вы не можете обратиться к общим полям, которые, например, будут у двух из этих классов, но у третьего их не будет.
604.60 611.96 "Анатолий Кулаков" Или, если вы вынесете эти общие поля в базовый класс, то третий класс, который не знает, как их заимплементировать, будет бросать какие-то исключения.
611.96 616.48 "Анатолий Кулаков" Или подобные штуки, которые на самом деле на практике встречаются очень-очень часто.
616.48 628.48 "Анатолий Кулаков" Exclamation Union позволяет вам создать такую структуру, которая в зависимости от того, что выбрал пользователь, то есть какой тип он туда засунул, может возвращать строго типизированный набор полей.
628.48 637.64 "Анатолий Кулаков" Если пользователь выбрал какой-нибудь оплатить кэшем, то, значит, у него будет сумма в этом строго типизированном типе, которая обозначает общее количество кэша.
637.64 643.64 "Анатолий Кулаков" Если пользователь выбрал оплатить кредитной картой, то там будет номер кредитной карты, дата ее окончания и имя владельца.
643.64 654.72 "Анатолий Кулаков" И вы к этим полям сможете строго типизированно обращаться и проверять, что вы обращаетесь к правильному классу, с правильной структурой, с правильными полями на уровне компиляции.
654.72 655.92 "Анатолий Кулаков" Это самое главное.
655.92 662.92 "Анатолий Кулаков" Потому что все шарпи это можно хоть как-то проэмулировать, но все эмуляции, все нестыковки, все ошибки у нас вылезут только в рантайме.
662.92 669.36 "Анатолий Кулаков" Мы все-таки язык строго типизированный, если бы мы хотели падать в рантайме, мы бы выбрали какой-нибудь богомерзкий питон.
669.36 674.56 "Анатолий Кулаков" А падать надо именно в compile-time, в этом есть вся мощь строго типизированных языков.
674.56 676.84 "Анатолий Кулаков" И эта структура отлично этому поможет.
676.84 693.28 "Игорь Лабутин" То есть, по сути, получается, что на уровне компиляции компилятор знает, что это переменная, может быть, ну, грубо говоря, может в себе хранить значение одного из двух, трех, четырех, пяти типов, которые мы описали в описании этого discriminated union.
693.28 700.56 "Игорь Лабутин" А в рантайме, соответственно, вместе с объектом тащится какой-то кусочек информации про то, что там на самом деле лежит сейчас.
700.56 715.40 "Игорь Лабутин" И на основе этого pattern matching сможет работать и понимать, что если в этом объекте лежит что-то типа там деньги, то одно делать, если лежит что-то типа кредитная карточка, делать что-то другое, если там лежит что-то третье, то делать что-то третье.
715.40 725.08 "Игорь Лабутин" И еще одна дополнительная, дополнительный бонус discriminated union в том, что известно, что ничего четвертого там лежать не может.
725.08 743.16 "Анатолий Кулаков" Да, именно так. То есть ты на уровне компиляции должен обработать все абсолютные результаты, которые могут быть лежать в этом типе, и, соответственно, это исключает возможность ошибки или исключает возможность то, что у тебя будет какое-то непредсказуемое состояние, которое ты не предполагал. Вот, об этом во всем тебя предупредит компилятор.
743.16 763.76 "Игорь Лабутин" Угу, ну да, здорово. Мне, конечно, с плюсовым бэкграундом немножко слово union в этом смысле не нравится, потому что для меня union - это способ прозрачно доступаться к одним и тем же бинарным данным, глядя на них то, как float, то, как массив байтов, но вроде как discriminated union - это устоявшийся термин, поэтому тут уж ладно.
763.76 767.40 "Анатолий Кулаков" Именно так, поэтому я и сказал, что в принципе от плюсов это довольно далеко.
767.40 767.92 "Анатолий Кулаков" Да.
767.92 772.56 "Анатолий Кулаков" И я тоже не сразу смачивал вообще, как это относится к плюсовым unionам, кроме того, что там одинаковое слово.
772.56 775.76 "Анатолий Кулаков" Вот, а также нужно понимать, что почему это алгебраические типы данных.
775.76 781.52 "Анатолий Кулаков" Алгебраические типы - это то, что вы можете сказать, что переменная может принимать сразу несколько типов.
781.52 792.32 "Анатолий Кулаков" Вот, например, переменная способ оплаты может иметь внутри себя значение класса способ оплаты кэш, способ оплаты кредитная карта и способ оплаты натура, например.
792.32 813.36 "Анатолий Кулаков" Но если разобраться чуть-чуть поглубже, то вы точно так же можете создать переменную, которая может внутри себя содержать типы данных, например, int и string одновременно, float, long и int, например, одновременно, создать такую переменную, задекларировать метод с такой сигнатурой, который может принимать любой из этих типов, и как-то научиться работать с этими данными.
813.36 816.56 "Анатолий Кулаков" А как с этим типом можно работать, как с этими переменными можно работать?
816.56 818.80 "Анатолий Кулаков" Вот это как раз делается через pattern matching.
818.80 832.00 "Анатолий Кулаков" Может быть, многие из вас, начитавшись статье по функциональному программированию, реализовывали такой класс как Option.att, это специальный класс, который явно показывает, что метод может вернуть тот объект, который вы в него запросили, или может не вернуть.
832.00 833.60 "Анатолий Кулаков" Типа такой опциональный результат.
833.60 835.68 "Игорь Лабутин" Ну, я иногда для этого использовал nullable.att.
835.68 839.68 "Анатолий Кулаков" Да, действительно, nullable - это хорошая штука, если бы они сами не могли быть null.
839.68 840.56 "Анатолий Кулаков" Это правда.
840.56 852.88 "Анатолий Кулаков" Вот, и, соответственно, Option.att, он в функциональных языках как раз и реализуется через discrimination union, то есть это тип, который может принимать два значения, значение типа "т" и значение типа "ничего".
852.88 862.32 "Анатолий Кулаков" Точно такой же тип есть result, который тоже внутри себя содержит или значение конкретное, которое он нашел, или exception, который случился, пока вы этот результат получали.
862.32 874.08 "Анатолий Кулаков" Вот, то есть такие вспомогательные утилитные классы, они реализуются теперь не так упогонь, не так уродски, как это могли делать раньше, а еще и плюс поддержка компиляции.
874.08 881.36 "Анатолий Кулаков" И это действительно крутейшая фича, очень мощная, и я очень сильно хотел бы, чтобы она, конечно, попала в релиз.
881.36 883.52 "Игорь Лабутин" Да, звучит действительно мощно.
883.52 889.68 "Игорь Лабутин" И кажется, что вот эти две больших фичи, они уже реально большие и жирные.
889.68 892.16 "Игорь Лабутин" У нас есть еще что-нибудь такого же масштаба?
892.16 894.40 "Анатолий Кулаков" Больших, жирных, наверное, нет.
894.40 896.72 "Анатолий Кулаков" Все остальное, в принципе, пока известно по мелочи.
896.72 900.88 "Анатолий Кулаков" Может, в будущем и появятся, но это две таких пробивных вещи.
900.88 904.72 "Игорь Лабутин" А все остальное - это больше просинтаксический сахар, который мы так любим.
904.72 907.20 "Анатолий Кулаков" И какого же сахара нам не хватало в повседневной жизни?
907.20 915.52 "Игорь Лабутин" Ну, во-первых, нам не хватало, скажем так, аналога VAR, но с другой стороны, от знака присваивания.
915.52 925.84 "Игорь Лабутин" То есть когда-то давным-давно, допустим, мы обязаны были писать dictionary от string string, присвоить new dictionary string string, круглые скобочки.
925.84 934.08 "Игорь Лабутин" Это всем надоело, и можно стало писать VAR что-то там, имя переменные, присвоить new dictionary string string, круглые скобочки.
934.08 937.20 "Игорь Лабутин" Все бы ничего, но оно как-то однобоко.
937.20 948.32 "Игорь Лабутин" Новая фича позволяет писать теперь, ну, пока еще не позволяет, но возможно позволит нам писать, наоборот, можно будет писать dictionary string string, имя переменной, присвоить new, круглые скобочки.
948.32 956.72 "Игорь Лабутин" То есть по типу переменной в левой части выражения будет выводиться тип того, что должно быть в new в правой части выражения.
956.72 958.96 "Игорь Лабутин" Что мне повторять одно и то же.
958.96 960.48 "Анатолий Кулаков" Да, да, это удобно.
960.48 963.92 "Анатолий Кулаков" А еще, оператор new, или это keyword?
963.92 965.28 "Анатолий Кулаков" Keyword, наверное, все-таки, да.
965.28 976.16 "Анатолий Кулаков" Все-таки, keyword new получил также мощность создавать вложенные типы, например, в dictionary или в массиве, то есть выводить типы.
976.16 986.08 "Анатолий Кулаков" Потому что раньше вы, в принципе, могли написать массив, который просто задается кейвордом new, квадратные скобочки и в фигурных скобках просто перечислить какие-то переменные.
986.08 988.56 "Анатолий Кулаков" И компилятор сам мог вывести, что же это у вас за массив.
988.56 991.12 "Анатолий Кулаков" С dictionary было все намного сложнее.
991.12 1002.40 "Анатолий Кулаков" Если внутри элемент у dictionary был каким-то сложным, то вам приходилось для десяти элементов dictionary десять раз писать new kvlupayer, new kvlupayer, new kvlupayer и так заполнять их.
1002.40 1013.28 "Анатолий Кулаков" Вот сейчас оператор new точно также может по левой части вычислить, какой тип не только от dictionary вы имеете в виду, но и какие типы внутри dictionary вы задекларировали в качестве дженериков.
1013.28 1016.48 "Анатолий Кулаков" И тоже их прозрачно и миленько так кратко создавать.
1016.48 1027.12 "Игорь Лабутин" Ну, в общем, то, что началось с var, что было наиболее логичным, дальше сейчас движется дальше и пытаемся все меньше и меньше дублировать одну и ту же информацию.
1027.12 1031.52 "Игорь Лабутин" Если тип в одном месте написан, его можно вывести, то почему бы это не сделать компилятору действительно.
1031.52 1034.80 "Анатолий Кулаков" Следующая фича, это какое-то мракописие, мне кажется.
1034.80 1037.28 "Анатолий Кулаков" null checking параметр.
1037.28 1039.76 "Игорь Лабутин" Наследие nullability?
1039.76 1045.36 "Анатолий Кулаков" Нет, смотри, у тебя обычно, когда ты принимаешь аргументы в методе, первым делом ты их проверяешь на null.
1045.36 1057.44 "Анатолий Кулаков" Вот если раньше мы это могли делать через обычное равно-равно, то с прошлой версией мы это можем делать через is, как стало почему-то модным и все предлагальщики начали это предлагать.
1057.44 1072.88 "Анатолий Кулаков" То есть мы также немножко смогли сократить свой код, потому что если раньше мы принимали аргумент, мы первой строчкой должны были проверить его на null, а второй строчкой присвоить его к нашему полю, теперь это можно писать в одну строчку и присвоить к полю, и проверить на null все одной строчкой.
1072.88 1076.16 "Анатолий Кулаков" Код в принципе стал намного меньше, в два раза меньше.
1076.16 1085.68 "Анатолий Кулаков" Это считается лучше, но не предельно хорошо, потому что ваше присвоение все-таки путается в этом огромном new argument, null exception, name of и так далее.
1085.68 1088.96 "Анатолий Кулаков" То есть пуля все-таки начинает в этом мусоре проверки на null путаться.
1088.96 1090.00 "Игорь Лабутин" И вот в C#...
1090.00 1091.36 "Игорь Лабутин" И надо же не забыть вот это.
1091.36 1093.84 "Игорь Лабутин" Меня во всем этом деле всегда бесил name of.
1093.84 1103.92 "Игорь Лабутин" Я уже один раз указал имя аргумента, как бы мне его не указывать в name of, потому что не раз встречалось, что name of был написан неправильно.
1103.92 1106.96 "Игорь Лабутин" Спасибо оператору name of, конечно, что хотя бы там не строчка.
1106.96 1107.92 "Анатолий Кулаков" Без него было бы еще хуже.
1107.92 1109.68 "Игорь Лабутин" Да, но тем не менее.
1109.68 1110.72 "Анатолий Кулаков" Именно так.
1110.72 1115.44 "Анатолий Кулаков" Опять же, Microsoft, за что мне нравится, это они молодцы за свою статистику.
1115.44 1125.52 "Анатолий Кулаков" То есть они собрали много кода, посмотрели, что это реально больное место, оно очень много повторяется, людям мозолит глаза, и решили еще заимпровить проверку на null.
1125.52 1127.52 "Анатолий Кулаков" Они предложили следующий синтаксис.
1127.52 1134.08 "Анатолий Кулаков" Когда вы объявляете переменные, которые принимает ваш метод, в конце поставьте восклицательный знак.
1134.08 1139.84 "Анатолий Кулаков" То есть у вас будет метод doSomething, string, имя переменной, и в конце восклицательный знак.
1139.84 1152.80 "Анатолий Кулаков" Это для компилятора будет обозначать, что эту переменную в самом начале метода нужно проверить на null, бросить правильный exception, прокинуть и этот правильный name of, и в принципе забыть вообще про то, что нужно что-то проверять.
1152.80 1154.80 "Анатолий Кулаков" Как тебе идея? Лучше так?
1154.80 1157.92 "Игорь Лабутин" Я бы сказал, что этот восклицательный знак будет сильно теряться.
1157.92 1179.44 "Игорь Лабутин" Ну то есть мне, во-первых, это визуально не очень видно, а во-вторых, мне кажется, есть некоторая проблема с фичей про nullability, где восклицательный знак после имени переменной означает "Да ладно, поверь мне, компилятор тут может, даже если ты не веришь, что тут не может быть null, он тут все равно может быть, в общем, не генери тут warning".
1179.44 1192.64 "Игорь Лабутин" То есть получается, что вроде как один и тот же синтаксис, имя переменной и восклицательный знак в конце в одних местах обозначает "компилятор, не надо тут ничего проверять, и верь мне", а в других "вот тут, пожалуйста, не верь, и тут проверь" на null.
1192.64 1197.36 "Игорь Лабутин" Мне кажется, что это немножко confusing будет, так, довольно-таки сильно.
1197.36 1202.40 "Игорь Лабутин" Хотя, конечно, тот факт, что не нужно писать if, бла-бла, не null, это как бы здорово.
1202.40 1205.52 "Игорь Лабутин" Но что-то я пока не уверен про вот синтаксис с восклицательным знаком.
1205.52 1215.28 "Игорь Лабутин" Я бы предпочел на самом деле просто атрибут в стиле nullability, там not null написано атрибутом, если передали null, выкинь exception, пожалуйста.
1215.28 1228.64 "Анатолий Кулаков" Да, мне тоже идея понравилась, но реализация не очень, потому что восклицательный знак, знаешь, превращает язык в какой-то перл, уже там, воспростительные, восклицательные знаки, решетки, собачки, слишком уже много какой-то непонятной невыразительной магии.
1228.64 1230.00 "Игорь Лабутин" Ну, посмотрим.
1230.00 1233.44 "Игорь Лабутин" Пока мы не начали называть переменные со знака доллара, все в порядке.
1233.44 1237.52 "Анатолий Кулаков" Мы уже строки начали называть со знака доллара, чтобы ставить форматирование.
1237.52 1239.28 "Игорь Лабутин" Это правда, да, первый шаг.
1239.28 1241.92 "Анатолий Кулаков" Ну и следующий наборчик из атрибутиков.
1241.92 1244.16 "Анатолий Кулаков" Какие полезные атрибуты нам предлагаются?
1244.16 1246.80 "Анатолий Кулаков" ColorExpressionAttribute.
1246.80 1253.84 "Анатолий Кулаков" Атрибут, который позволяет вам передать в вашу функцию то, что пользователь вставил в качестве аргумента.
1253.84 1259.92 "Анатолий Кулаков" То есть, если он вам передал не просто имя переменной, и все, это банально, это скучно вам передаться имя переменной.
1259.92 1268.16 "Анатолий Кулаков" А если он в аргументе этого метода написал какой-нибудь большой expression по типу, там, длина массива -1*9/5.
1268.16 1271.76 "Анатолий Кулаков" Вот весь этот expression в виде строки передастся в ваш метод.
1271.76 1279.28 "Анатолий Кулаков" Наверное, для каких-нибудь служебных интересных утилиток, типа логеров, парсеров, хендлеров, чекеров.
1279.28 1281.28 "Анатолий Кулаков" Это очень полезная штучка.
1281.28 1286.72 "Игорь Лабутин" Да, мне кажется, ну, вот эта штука полезна действительно во всяких эксепшенах.
1286.72 1296.40 "Игорь Лабутин" Потому что, когда ко мне пролетает какой-нибудь null reference exception, вообще было бы идеально туда вписать прям чуть ли не строчку кода, на чем оно выпало.
1296.40 1298.88 "Игорь Лабутин" И это было бы, да, большая подспорья в дебаггинге.
1298.88 1304.08 "Игорь Лабутин" Ну, посмотрим, может, действительно, потом это растащат по каким-нибудь полезным эксепшенам и внутри рантайма.
1304.08 1305.92 "Игорь Лабутин" Ну, в смысле, внутри стандартной библиотеки.
1305.92 1310.32 "Игорь Лабутин" И оттуда мы узнаем, как этим правильно и хорошо пользоваться, полезно.
1310.32 1311.84 "Игорь Лабутин" А еще что из атрибутиков?
1311.84 1316.00 "Анатолий Кулаков" Наконец-то добавили, хотят добавить, генерики к атрибутам.
1316.00 1318.00 "Анатолий Кулаков" Вообще непонятно, почему их так давно не было.
1318.00 1320.24 "Анатолий Кулаков" И почему их изначально сделали без генериков.
1320.24 1321.60 "Анатолий Кулаков" Ну, вот вроде дошли руки.
1321.68 1325.84 "Анатолий Кулаков" Тебе никогда не хотелось атрибуты указать какой-то конкретный тип генериков?
1325.84 1332.88 "Игорь Лабутин" Хотелось, потому что, как минимум, это часто используется во всяких юнит-тестовых фреймворках.
1332.88 1338.16 "Игорь Лабутин" Типа там указать тип, в котором лежит фабрика для генерации значений для этого тест-коллекции.
1338.16 1340.40 "Игорь Лабутин" Ну, когда у нас тест параметризованный.
1340.40 1349.20 "Игорь Лабутин" Там можно указать местами делегат, местами отдельный класс, у которого вызывается там, не помню что, метод какой-то правильный.
1349.20 1356.24 "Игорь Лабутин" И вот там было бы, конечно, удобнее не TypeOf писать, а просто Generic сделать и было бы красивее, чем TypeOf.
1356.24 1363.92 "Анатолий Кулаков" Да, конвертеры, валидаторы, мапперы, то есть все, где есть ссылка на какой-то сторонний класс, должны стать красивее.
1363.92 1365.52 "Анатолий Кулаков" Стыдно, что так давно не было.
1365.52 1369.68 "Анатолий Кулаков" Так, наконец-то разрешат ставить атрибуты на локальных функциях.
1369.68 1373.68 "Анатолий Кулаков" Вот это тоже какое-то мраковесие непонятное, почему сразу не сделали.
1373.68 1378.96 "Анатолий Кулаков" Даже наш любимый NotNull на локальных функциях поставить нельзя, потому что они почему-то локальные функции.
1378.96 1382.96 "Игорь Лабутин" Так кажется, что кроме там NotNull сильно-то по локальным функциям.
1382.96 1388.96 "Игорь Лабутин" Хотя всякие новые Inlining, может быть, тоже там будут полезные атрибутики, которые там компиляторные.
1388.96 1390.96 "Игорь Лабутин" Или AggressiveInlining наоборот.
1390.96 1396.96 "Анатолий Кулаков" Сейчас эти атрибуты с Null и без Null, они довольно популярными станут, поэтому на локальных функциях их очень хотелось бы тоже иметь.
1396.96 1398.96 "Анатолий Кулаков" Ну, сейчас сделают.
1398.96 1402.96 "Анатолий Кулаков" Наверное, было бы место налепить какой-нибудь полезный атрибут, всегда можно.
1402.96 1410.96 "Анатолий Кулаков" Есть полезные штуки с cancellation токеном, есть полезные штуки с обходом коллекции, что-то там такое в Proposal, о чем я читал.
1410.96 1412.96 "Анатолий Кулаков" Хороший пример есть, кроме Null.
1412.96 1424.96 "Игорь Лабутин" Окей. Но я пока смотрю, все то, что мы сейчас перечислили, оно находится в статусе In Progress либо Prototype, и, соответственно, ничего из этого пока нет в коде.
1424.96 1426.96 "Игорь Лабутин" В смысле, в готовом версии.
1426.96 1434.96 "Анатолий Кулаков" Сейчас все на уровне экспериментов, проп, имплементации, ну и даже после того, как они завершат саму разработку, не факт, что это еще появится в языке.
1434.96 1436.96 "Анатолий Кулаков" Поэтому, помните, это пока просто спекуляции.
1436.96 1438.96 "Анатолий Кулаков" Окей. Поехали дальше.
1438.96 1448.96 "Анатолий Кулаков" Наплел он отличную статью недавно под авторством Стефана Тауба. Тауб пишет, как всегда, глубоко, отлично и понятно. Поднял он интереснейший вопрос.
1448.96 1450.96 "Анатолий Кулаков" Configure Await Fug.
1450.96 1452.96 "Анатолий Кулаков" Казалось бы, банальная тема.
1452.96 1464.96 "Анатолий Кулаков" Await и Async у нас уже существуют с незапамятных времен, уже даже перелезли во все другие языки, кроме C#. Но до сих пор почему-то на собеседованиях не встречаются люди, которые не до конца понимают ни что там происходит, ни как это происходит.
1464.96 1466.96 "Анатолий Кулаков" И тема актуальная.
1466.96 1468.96 "Анатолий Кулаков" Давай немножко об этом поговорим.
1468.96 1470.96 "Игорь Лабутин" Давай. Configure Await.
1470.96 1472.96 "Игорь Лабутин" Тема прикольная и все, что с ней связано.
1472.96 1476.96 "Игорь Лабутин" Я даже не могу сказать, что я-то все про нее знаю.
1476.96 1480.96 "Игорь Лабутин" Ну, сейчас пообсуждаем, выясним, кто чего не знает. Поехали.
1480.96 1490.96 "Анатолий Кулаков" В принципе, статья довольно объемная, большая, и мы, наверное, много из этого пропустим. Поэтому, если вам действительно тема интересная и вы хотите подтянуться, то настоятельно рекомендую к прочтению.
1490.96 1496.96 "Анатолий Кулаков" Первым же абзацом ставится довольно-таки простой вопрос. Что такое Synchronization Context, что такое Task Scheduler и в чем они отличаются?
1496.96 1500.96 "Игорь Лабутин" И как они вообще соотносятся с Await?
1500.96 1514.96 "Игорь Лабутин" Отличаться-то они, может, чем-то отличаются, да, но на самом деле действительно среднестатистический пользователь, особенно в современном мире, который никогда не работал с WPF-ом или с Informs-ами, с Synchronization Context-ом не встречается никогда.
1514.96 1516.96 "Анатолий Кулаков" Именно так.
1516.96 1518.96 "Анатолий Кулаков" Давайте разбираться.
1518.96 1530.96 "Анатолий Кулаков" Synchronization Context - это всего лишь навсего в большинстве случаев, в подавляющем большинстве случаев, всего лишь навсего класс, у которого есть метод POST, и в этот метод вы можете поставить какую-то задачу.
1530.96 1540.96 "Игорь Лабутин" Да, в некотором смысле это метод сказать какой-то логике, которая от вас скрыта, "сделай, пожалуйста, вот эту работу".
1540.96 1546.96 "Игорь Лабутин" И логика сама будет в зависимости от того, что это за Synchronization Context, решать, как эту работу делать.
1546.96 1554.96 "Игорь Лабутин" Подряд все, один за одним, ваши задачки делать, закидывать в ThreadPool, или еще как-то хитро их выполнять.
1554.96 1560.96 "Анатолий Кулаков" В большинстве случаев дефолтная имплементация - просто добавлять новый item в ThreadPool, новый task в ThreadPool, в котором он успешно
1560.96 1598.96 "Игорь Лабутин" выполняется. Но есть как минимум две, которые я уже упомянул, это WinForms и WPF, которые весьма специальны по одной простой причине. В большинстве случаев вы, когда пишете код на UI, рано или поздно захотите обновить состояние каких-либо контролов на UI. И WinForms и WPF устроены так, что вы имеете право это делать только из того потока, в котором этот контрол был создан. А если быть чуть более точным, из того потока, где крутится MessagePump в WinForms, либо где живет WPF на Dispatcher.
1598.96 1608.96 "Игорь Лабутин" И поэтому Synchronization Context для этих двух UI-фреймворков они устроены так, что метод POST запоминает тот делегат, который вы хотите выполнить во внутреннюю очередь.
1608.96 1626.96 "Игорь Лабутин" И когда окно или контрол ничем не занят, они ему закидывают эту штуку, этот метод, этот делегат для выполнения. И он уже выполняется в контексте нужного потока и имеет полное право обновлять контролы и делать, что хотите с UI.
1626.96 1630.96 "Анатолий Кулаков" Да. А Scheduler - это как раз-таки имплементация Synchronization Context?
1630.96 1664.96 "Игорь Лабутин" Ну, не так, чтобы имплементация, то есть это кажется, что конкретный Scheduler для конкретно тасков. То есть у нас есть некое TPL, у нас есть понятие task, и его можно выполнить. То есть по сути task - это некоторый делегат, который можно выполнить, плюс обвес вокруг, типа Continuation, там, и чё как Handle, в смысле ошибок, там, Exceptions, Timeout и так далее.
1664.96 1666.96 "Игорь Лабутин" И Consolation.
1666.96 1674.96 "Игорь Лабутин" И, соответственно, TaskScheduler определяет, каким образом ваша task будет исполняться.
1674.96 1680.96 "Игорь Лабутин" Их можно подружить с Synchronization Context, их можно рассматривать независимо.
1680.96 1688.96 "Анатолий Кулаков" Да. Но в большинстве случаев эта парочка нужна как раз-таки для того, чтобы абстрактно, в зависимости от контекста, заскедулить вашу следующую работу.
1688.96 1704.96 "Игорь Лабутин" Да, то есть у TaskScheduler, у класса TaskScheduler есть в принципе метод FromHarandSynchronizationContext, который может взять и взять ваш текущий SynchronizationContext, его запомнить, и все ваши task будут кидаться для выполнения в этот SynchronizationContext.
1704.96 1710.96 "Игорь Лабутин" А как эти делегаты будут уже непосредственно выполняться SynchronizationContext, это уже дело SynchronizationContext. Немножко офф-топика.
1710.96 1718.96 "Анатолий Кулаков" В принципе, очень странная вещь, то что нельзя выставить системе какой-нибудь тефолтный текущий TaskScheduler, через который например будут запускаться все таски.
1718.96 1724.96 "Анатолий Кулаков" Мы на нашем проекте очень сильно хотели это сделать, у нас была специальная ситуация, где мы хотели контролировать количество запущенных тасков.
1724.96 1742.96 "Анатолий Кулаков" Мы это сделали в вакуумных условиях, то есть при условии, что всегда будет передаваться явно наш TaskScheduler во все run и во все await. Но это выглядело довольно убого. Хотелось бы переназначить для системы свой TaskScheduler и как-то контролировать постановку в очереди, все это делать.
1742.96 1746.96 "Анатолий Кулаков" К сожалению, почему-то такая штука была не предусмотрена абсолютно разработчиками.
1746.96 1748.96 "Анатолий Кулаков" И это очень грустно.
1748.96 1752.96 "Анатолий Кулаков" Потому что функциональность довольно интересная, и хотелось бы ее перекрывать для всей системы, но нет.
1752.96 1760.96 "Анатолий Кулаков" Я знаю о исследованиях Валерия Петрова, он залез в кишки TaskScheduler и как-то через Reflection все-таки добился такого поведения.
1760.96 1762.96 "Анатолий Кулаков" Вот, мне еще не дошли руки это проверить.
1762.96 1764.96 "Анатолий Кулаков" Я думаю, в скором времени попробовать.
1764.96 1766.96 "Анатолий Кулаков" Но все равно хотелось бы какого-то официального способа.
1766.96 1768.96 "Анатолий Кулаков" Так, пойдем дальше.
1768.96 1774.96 "Анатолий Кулаков" Что же собственно делать в конфигуре AwaitFalls, который в принципе все статьи рекомендует нам регулярно использовать или не использовать.
1774.96 1784.96 "Анатолий Кулаков" И хотелось бы разобраться, что это за такая магия, во что она открывается на времени компиляции, что позволяет вашей программе не захватывать синхронизейшн контексты.
1784.96 1798.96 "Игорь Лабутин" Ну да, во-первых, нужно пояснить, что тот самый Falls - это не магия, это не магическое заклинание, это просто аргумент, буллинский аргумент, который, если я правильно помню, называется UseSynchronizationContext.
1798.96 1806.96 "Игорь Лабутин" И все. Соответственно, поведение по умолчанию - это использовать синхронизейшн контекст, поведение не по умолчанию - не использовать.
1806.96 1812.96 "Игорь Лабутин" Именно поэтому никто никогда нигде не пишет ConfigureAwaitTrue, зато много кто пишет ConfigureAwaitFalls.
1812.96 1814.96 "Игорь Лабутин" И делает эта штука ровно одну вещь.
1814.96 1842.96 "Игорь Лабутин" Она возвращает специальный эвейтер, модифицированный от вашего таска, который для запуска вашего таска континейшена, по сути, то есть либо того, что написано в таске вашего эвейта, либо у самого таска не будет говорить CurrentSynchronizationContext.post, а будет обращаться, по сути, к threadpool, ну или к дефолтному у таска-скедулера, если быть более точным.
1842.96 1846.96 "Анатолий Кулаков" Да, он возьмет следующий сдачу таска-скедулера и не будет ему передавать синхронизейшн контекст.
1846.96 1848.96 "Анатолий Кулаков" Зачем вообще это может понадобиться?
1848.96 1874.96 "Анатолий Кулаков" Зачем вообще такую глупость писать? Ну, казалось бы, запустили таску, сделали ее эвейт, вот она исполнилась. Зачем ставить ConfigureAwaitFalls? Для этого есть несколько причин. Самая важная причина - это все-таки ускорение перформанса, потому что переключение контекстов - операция не сказать бы, чтобы очень дорогая, но заметная. Поэтому, если вы будете ставить везде falls, где вам это не нужно, а где нужно мы поговорим немножко позже, то это увеличит производительность вашей программы.
1874.96 1876.96 "Анатолий Кулаков" Именно поэтому все статьи настоятельно рекомендуют
1876.96 1884.96 "Игорь Лабутин" это делать. И еще одно... Но делать это не везде, на самом деле, и к этим рекомендациям нужно относиться достаточно аккуратно. Мы про это еще
1884.96 1916.96 "Анатолий Кулаков" поговорим. Да, надо понимать, что статья дает среднюю температуру по больнице. Здесь все очень-очень примерно, но это best practices. То есть в большинстве случаев вам нужно отталкиваться именно от этой информации, от этих решений, а дальше уже смотреть на свою конкретную частную ситуацию. И еще одна интересная штука, которая позволяет достичь ConfigureAwaitFalls - это избежать дедлоков. Очень часто бывает ситуация, особенно когда вы пишете UI, потому что в UI у вас всегда есть синхронизейшн контекст. Очень часто ситуация, когда неопытные пользователи, неопытные программисты наталкиваются на дедлоке.
1916.96 1940.96 "Анатолий Кулаков" Дедлок происходит, когда таск не может вернуться в свой синхронизейшн контекст, потому что синхронизейшн контекст занят очень важной задачей. Он ждет возвращения этой таски. Если вы никогда на это не натыкались, то погуглите. Проблема довольно-таки смешная, интересная, и о ней обязательно нужно знать. Теперь давай же все-таки подумаем. Если есть falls, значит должен быть и true. Все-таки ConfigureAwaitTrue. Когда его нужно использовать
1940.96 1982.96 "Игорь Лабутин" и когда он не нужен. Ну, как я сказал, поскольку дефолтное поведение - это захватывать синхронизейшн контекст и его использовать, то смысл от того, что вы обернете вашего вейтера в еще одну обертку, которая будет делать ровно то же самое, что оригинальный вейтер, - большого нет. Поэтому для семантических писать ConfigureAwaitTrue абсолютно бесполезно, разве что только вы не хотите показать будущим читателям вашего кода, что вы что-то знали и не захотели написать но, возможно, будущие читатели подумают, что вы здесь ошиблись и поправят true на false, потому что зачем кто-либо начал писать ConfigureAwaitTrue и это приведет к чему-то плохому. Поэтому, наверное, правильный ответ - вообще не надо писать ConfigureAwaitTrue. Слушай, а я вот здесь
1982.96 1990.96 "Анатолий Кулаков" с тобой поспорю, потому что я придерживаюсь совершенно другой партии. Я придерживаюсь тех людей, которые всегда явно пишут ConfigureAwait.
1990.96 2014.96 "Анатолий Кулаков" Это тоже я встречал такие рекомендации, как best practices, зачем это нужно. Потому что, когда приходит новый человек и видит, стоит обычный await какой-то таски и он не понимает, нужен здесь information context или не нужен здесь контекст, но он читал в статьях, что по правде, если поставить false, то код получится оптимальнее, скорость у вас получится больше и вообще тебя потом похвалят и выдадут в конце месяца премию.
2014.96 2022.96 "Анатолий Кулаков" А еще знаешь что? Сволочь, Desharper очень часто это подсказывает. И вот он с радостью ставит ConfigureAwaitFalse и у вас ломается вся программа.
2022.96 2026.96 "Анатолий Кулаков" И вот, чтобы такого не происходило, я стараюсь всегда явно ставить ConfigureAwaitTrue.
2026.96 2032.96 "Анатолий Кулаков" Это значит, что программист в этом месте подумал и явно решил, что синхронизатор контекст здесь нужен.
2032.96 2036.96 "Игорь Лабутин" Просто так его менять нельзя. Комментарий дописать обязательно рядом. Это я не ошибся, это я подумал.
2036.96 2048.96 "Анатолий Кулаков" Ага, в твой код есть комментарий, потому что если ты поставил true, значит у тебя для это были какие-то веские причины. А вот если ты ничего не поставил, это может значить две позиции. Ты или имел ввиду false, или про это просто забыл.
2048.96 2054.96 "Анатолий Кулаков" И это критически важно, что на самом деле происходило. Поэтому оставлять пустой await - это очень плохо. Это не читабельно.
2054.96 2056.96 "Анатолий Кулаков" Вот я в принципе такой код пишу.
2056.96 2068.96 "Игорь Лабутин" Угу. Ну, возможно, позиция имеет право на жизнь, мы такими не пользуемся. То есть у нас только в нужных местах конфигureAwaitFalse стоит и все. Да, наверное, действительно зависит от размера кодовой базы.
2068.96 2100.96 "Игорь Лабутин" И на самом деле, еще мне кажется, это очень сильно зависит от того, а много ли действительно мест, где нужно true. Ну, в смысле, что где нужно помнить о синхронизейшн контексте, а где не нужно. Потому что сейчас вот у нас например, там 95, наверное, процентов кода асинхронного это netcore-ные сервисы, где вообще никакого синхронизейшн-н-контекста в жизни никогда не будет. Ну, до икори пока Microsoft его туда не принесет. Потому что никакого vpf-информации нету, ISA там нету, ничего нету. То есть там все один сплошной thread-pool. И пиши там true, пиши false,
2100.96 2106.96 "Анатолий Кулаков" разницы никакой. О, подожди, до этого мы дойдем в конце. Здесь тоже есть best practice про твою ситуацию.
2106.96 2114.96 "Анатолий Кулаков" Давай сначала остановимся немножко на тех, на выводах, которые можно сделать из конфигура вейта все-таки. Когда нужно использовать true, когда false?
2114.96 2136.96 "Игорь Лабутин" Общая рекомендация такая, что если у вас код это именно приложение, то есть там, где вы скорее всего будете взаимодействовать с UI, или еще с какими-то местами, где может быть особенности а-ля vpf-ной или в-информ-зовой, где важен синхронизейшн-контекст, там вы не используете конфигура вейта false. Ну, и в таком случае, если вы следуете тому, что говорил Толя, вы пишете конфигура вейта true.
2136.96 2152.96 "Игорь Лабутин" Если же вы пишете общую библиотеку, то есть просто какой-то, ну, get-пакет, который вообще неизвестно, где будет использоваться, и в каком контексте. В контексте UI, или в контексте MySplanetCore, или еще где-то, то там вы пишете конфигура вейта false.
2152.96 2172.96 "Игорь Лабутин" Соответственно, все ваши внутренние вейты будут происходить без учета контекста, и только внешний вейт, когда вашу библиотеку уже асинхронный метод, ваши библиотеки позовутся вейтом. И если это сделают из application level кода, там поставят конфигура вейт true, и, соответственно, последний continuation, он таки вернется обратно в нужный синхронизацион контекст приложения.
2172.96 2174.96 "Анатолий Кулаков" Да, да, все именно так.
2174.96 2176.96 "Анатолий Кулаков" Теперь разберем несколько мифов.
2176.96 2184.96 "Анатолий Кулаков" Означает ли конфигура вейт, что твоя таска будет выполнена на другом потоке? Обязательно на другом потоке, не на этом, который сейчас происходит. Как ты считаешь?
2184.96 2186.96 "Анатолий Кулаков" Конфигура вейт true или false?
2186.96 2192.96 "Анатолий Кулаков" Конфигура вейт false. Который говорит, не надо синхронизацион контекст сохранять, и мы вернемся в другой поток.
2192.96 2196.96 "Игорь Лабутин" Нет, конечно, нет. Поток там вообще может быть всегда один,
2196.96 2200.96 "Анатолий Кулаков" и все. Хорошо, означает ли это, что мы вернемся в другую таску? Это мне напоминает,
2200.96 2214.96 "Игорь Лабутин" если мы скажем вейт, как там, thread slip от нуля, или что-нибудь в таком духе, типа переключится ли у нас поток исполнения, или что-нибудь в таком духе. Не, наверное, наверное не значит.
2214.96 2224.96 "Игорь Лабутин" Там же, там был какой-то странный handling, ну не странный, в смысле, а уже completed task при continuation, я не помню сейчас все детали, но что-то там было какое-то странное поведение.
2224.96 2232.96 "Анатолий Кулаков" Конфигура await говорит компилятору, что не обязательно возвращаться в тот же самый поток, в тот же самый контекст, но при этом не гарантирует, что этого не произойдет.
2232.96 2238.96 "Анатолий Кулаков" Например, если таска завершена, вы продолжите выполнение там же, где и были. Для этого вам не нужно ничего переключать, прыгать и так далее.
2238.96 2242.96 "Анатолий Кулаков" И runtime все это очень хорошо оптимизирует. Следующий миф.
2242.96 2256.96 "Анатолий Кулаков" Достаточно ли просто-напросто у первого таска вызвать конфигура вейт false, а все остальные и так будут выполняться хорошо, потому что первый таск отбросит текущий синхронизатор контекст, и мы избавимся от всех накладных расходов. Первый
2256.96 2274.96 "Игорь Лабутин" таск действительно отбросит, но зная, что конфигура await оборачивает эвейтер во что-то дополнительное, стандартный эвейтер, в смысле, наверное, если вы не используете ничего нестандартного, каких-нибудь кастомных эвейтеров, то все будет работать достаточно на первом, действительно.
2274.96 2280.96 "Игорь Лабутин" Но если вы используете кастомные эвейтеры, то тогда, ну, там вообще непонятно, что будет. Непонятно, что будет.
2280.96 2282.96 "Анатолий Кулаков" Хорошо, сейчас дойдем до кастомных эвейтеров.
2282.96 2284.96 "Игорь Лабутин" Не используйте кастомные эвейтеры.
2284.96 2286.96 "Игорь Лабутин" Их писать тяжело.
2286.96 2288.96 "Анатолий Кулаков" Как раз давай тогда обсудим с тобой.
2288.96 2306.96 "Анатолий Кулаков" Если ты 100% уверен, что никакого синхронизации контекста в твоей программе никогда не будет, можно ли не писать конфигура wait вообще, потому что синхронизации контекста нет, время на переключение никуда не тратится, и, в принципе, конфигура wait false вообще абсолютно нечего. Значит ли это, что не надо писать конфигура wait вообще?
2306.96 2308.96 "Игорь Лабутин" Ну, это то, про что я говорил.
2308.96 2310.96 "Игорь Лабутин" Это случай нашего кода dotnet core.
2310.96 2312.96 "Игорь Лабутин" Синхронизации контекста нет.
2312.96 2318.96 "Игорь Лабутин" Да, можно не писать, но, вероятно, внимательно следить, чтобы Microsoft не принесла синхронизации контекста.
2318.96 2324.96 "Анатолий Кулаков" Да, я бы здесь тоже немножко с автором поспорил и хочу сказать, что писать нужно всегда.
2324.96 2330.96 "Анатолий Кулаков" Потому что когда Microsoft принесет, когда принесет кто-то другой, вот об этом вы никогда в жизни не узнаете.
2330.96 2354.96 "Анатолий Кулаков" Приведу вам конкретный пример. Недавно как раз я наткнулся. Наверняка многие из вас не знали, но XUnit - сволочь, использует синхронизацию контекста. И поэтому тот код, который у меня в программе на сервере под ASP.NET Core работал отлично без всяких синхронизации контекста, без всяких конфигура wait, как только я его начал запускать под своими тестами, поведение его изменилось. Я понятия не имел, почему оно поменялось.
2354.96 2364.96 "Анатолий Кулаков" А поменялось оно потому, что у XUnit есть свой синхронизацию контекста. Казалось бы, никто этого не ожидал. Поэтому, мальчики и девочки, рекомендация - используйте всегда конфигура wait, желательно false.
2364.96 2368.96 "Игорь Лабутин" Не знал про XUnit на самом деле. Сейчас мне даже интересно.
2368.96 2376.96 "Анатолий Кулаков" Правда ли, что в .NET Core никогда больше не нужно использовать конфигура wait false, потому что там удалили все синхронизацию контекста?
2376.96 2378.96 "Анатолий Кулаков" Как ты можешь прокомментировать это утверждение?
2378.96 2386.96 "Игорь Лабутин" Я могу это прокомментировать утверждение так, что нет, не правда, потому что в .NET Core ты все равно можешь таргетить старый фреймворк.
2386.96 2394.96 "Игорь Лабутин" То есть, несмотря на то, что код написан в .NET Core, он может компилироваться в .NET Standard и тогда запускаться на нормальном фреймворке и там будут синхронизированные контексты.
2394.96 2426.96 "Анатолий Кулаков" Откуда пошел вообще этот миф? Миф пошел из ASP.NET Core, казалось бы. Дело в том, что большой ASP.NET Framework по правде использовал синхронизацию контекста. Он туда запихивал всякую информацию о текущей сессии, о PHP-контексте и прочие полезные данные. В .NET Core, в ASP.NET Core ушли от этого. Они из ASP.NET выкинули синхронизацию контекста. И там теперь больше не нужно использовать ConfigureAwait. А в старом нужно было. Вот поэтому у людей, которые писали много-много бэкэнда, в голове вот эти два факта смешались.
2426.96 2438.96 "Анатолий Кулаков" Они подумали, что раньше был большой фреймворк и там нужно было ConfigureAwait использовать, а вот теперь Core случился и не нужно этого ничего использовать. Это действительно миф. Так делать не надо. ConfigureAwait надо использовать всегда и везде.
2438.96 2452.96 "Анатолий Кулаков" Ну окей. Еще, казалось бы, мы возвращаемся к той же самой проблеме, что очень сильно замусовывается код с этим ConfigureAwait. И с этим сложно спорить. Действительно, код очень сильно замусоривается. Поэтому очень многие люди стараются не писать ConfigureAwait явно.
2452.96 2458.96 "Анатолий Кулаков" И очень много существует пропозал на GitHub, где Microsoft просит как-то решить эту проблему.
2458.96 2478.96 "Анатолий Кулаков" То есть каким-то образом сделать или синтаксический сахар, или какой-то механизм, который позволит на уровне DLL, на уровне приложения задать дефолтное поведение. То есть, если я точно знаю, что я пишу в библиотеку общего пользования, там мне ConfigureAwait в большинстве случаев будет ставить false. Мне бы хотелось указать это на уровне всей моей Assembly и не писать ручками везде false.
2478.96 2480.96 "Анатолий Кулаков" А там, где надо, я, может быть, перепишу себе true.
2480.96 2482.96 "Анатолий Кулаков" Microsoft ничего пока по этому поводу не решил.
2482.96 2492.96 "Анатолий Кулаков" Ничего не обещал. Но интересны сами пропозалы. То есть, интересны синтаксисы, интересны идеи, интересны как это реализовать. То есть, атрибут на уровне Assembly - это самая банальная штука.
2492.96 2512.96 "Анатолий Кулаков" Есть вообще бешеные идеи, типа сделать Await методом расширения и изменять его поведение, чтобы можно было подставить кастомные обработчики, в числе которых можно засунуть ConfigureAwait false или true и так далее. В общем, если хотите много интересного веселья, сходите, найдите пропозалы, посмотрите, там очень много интересного.
2512.96 2520.96 "Анатолий Кулаков" И, пользуясь случаем, хотел бы порекламировать замечательный плагин к студии, который пишет наш друг Игорь Мамай.
2520.96 2522.96 "Анатолий Кулаков" Плагин называется AsyncConverter.
2522.96 2528.96 "Анатолий Кулаков" Это замечательная штука, которая позволяет вам делать много классных рефакторингов над тасками.
2528.96 2558.96 "Анатолий Кулаков" В частности, ее, например, можно попросить, чтобы она всегда заставляла вас писать слово ConfigureAwait с false или true, вы потом определитесь. Чтобы вы таких моментов не пропустили, про которые я вам рассказывал. Дальше она может конвертировать вам методы, она может делать методы синхронными, делать методы асинхронными и следить за прочими best practices, которые приняты в асинковом мире. Почему-то это крайне полезно, обязательно поставьте и посмотрите, насколько ваша жизнь улучшится, и вы станете писать более понятный и более поддерживаемый код.
2558.96 2562.96 "Игорь Лабутин" Так ты сказал к студии, по-моему, все-таки к ReSharper. Так как я студию
2562.96 2566.96 "Анатолий Кулаков" без ReSharper уже себе не представляю, наверное, да, я мог ошибиться. Ну вот не знаю,
2566.96 2572.96 "Игорь Лабутин" я, на самом деле, например, в последнее время, после перехода на 19, ReSharper пока не ставил. Как-то живу без него.
2572.96 2574.96 "Анатолий Кулаков" Ну расскажешь, сколько ты смог протянуть.
2574.96 2582.96 "Игорь Лабутин" Да, можно будет где-нибудь через несколько месяцев попробовать посмотреть. На опыт могу поделиться. Отлично,
2582.96 2598.96 "Анатолий Кулаков" пойдем дальше. А дальше у нас Филипп Даблью, тоже отличный автор, очень много пишет про ASP, у него даже есть книжка про ASP.NET, очень мелкий, емкий и интересный статей. Не какая-то банальщина, а он очень много сам раскапывает, готовит и рассказывает.
2598.96 2602.96 "Анатолий Кулаков" И вот он поделился такой интересной новостью, как новый SDK.
2602.96 2610.96 "Анатолий Кулаков" Новый SDK в нашей Visual Studio, с помощью которого вы можете компилировать Assembly и писать внутри этого SDK как ты думаешь, на каком языке?
2610.96 2612.96 "Анатолий Кулаков" Вот новый .NET язык.
2612.96 2614.96 "Игорь Лабутин" Не знаю даже.
2614.96 2630.96 "Анатолий Кулаков" Не то, чтобы, конечно, совсем новый, потому что ничего нового не запитали, но на нем мы почему-то обычно писали. Ты можешь встретиться с разработчиком на C#, на F#, даже на WebNet, но почему-то многие люди игнорируют такую прекрасную вещь, как Common Intermediate Language.
2630.96 2634.96 "Анатолий Кулаков" Ведь это по правде же тоже .NET язык.
2634.96 2644.96 "Анатолий Кулаков" И самый, что ни на есть прекрасный .NET язык, потому что это Assembler. В .NET мире не было принято писать на Assembler, потому что у нас высоковыровневый код, и зачем же нам было бы опускаться до такого низкого уровня?
2644.96 2668.96 "Анатолий Кулаков" Но даже если бы вы захотели этого сделать, просто так у вас бы это не получилось, потому что нормальных тулзов, кроме какого-нибудь патча или после компиляции, или вставления Assembler-ных хаков с помощью хуков, или прочей ереси и глупости в мире не существовало. И вот появился вполне официальный SDK, с помощью которого вы можете в свой Solution добавить проект и в этом проекте писать на чистом .ILI.
2668.96 2670.96 "Игорь Лабутин" Зачем такое может быть нужно?
2670.96 2684.96 "Анатолий Кулаков" Очень часто во всяких оптимизациях, очень часто во всяких докладах, как мы вот здесь сделали маленький хачик, и теперь .ILI генерится более оптимальным, и это позволяет нам сэкономить кучу-кучу процессорных тактов.
2684.96 2696.96 "Анатолий Кулаков" Для оптимизации это самое первое, к чему он подходит. То есть теперь вам не нужно танцевать с пупном, теперь вам не нужно кастить кенту, как это делается в исходниках .NET.
2696.96 2704.96 "Анатолий Кулаков" Вам не нужно обходить массив с обратной стороны, чтобы компилятор мог предсказать вам границы массива и прочие вот такие вещи.
2704.96 2716.96 "Анатолий Кулаков" Кстати, про которые интересно рассказывал Егор Богатов, какие хаки существуют грязные в .NET мире, в .NET Core. Вот такие всякие вещи, вам не нужно этого делать с помощью непонятных каких-то магических знаков.
2716.96 2728.96 "Анатолий Кулаков" Вы можете просто взять, написать метод на .ILI, который вам нужно, и быть уверенным, что ваш код всегда, независимо от рантайма, от сборка, оптимизации, транскомпиляции и прочего, выполнится так,
2728.96 2754.96 "Игорь Лабутин" как вы этого ожидали. Мне кажется, ты тут все-таки не до конца прав, потому что, если я правильно помню, может быть это было не в докладе Егора, а где-то еще, что на самом деле, ROSLIN как компилятор, он не такой уж прям умный и очень клевый с точки зрения оптимизации, а как раз все основные оптимизации, они во время JIT'а, когда уже этот .ILI преобразуется в нормальный Assembler. То есть, например, тема с циклами в туда и в обратном порядке, это уровень JIT'а, мне казалось.
2754.96 2770.96 "Игорь Лабутин" И JIT будет пытаться вставлять туда проверки выхода за границу массива, потому что в .ILI, по-моему, нет операции, ну, то есть мы не пишем, компилятор, точнее, не генерирует прям вот код проверки выхода за границу массива, если это может быть только не дебаг мод компиляции.
2770.96 2794.96 "Игорь Лабутин" И в этом смысле .ILI-то тебе не слишком сильно поможет бороться с JIT'ом. Другое дело, что, насколько я помню, из истории .ILI исторически позволяет намного больше всяких штук делать, потому что, например, когда добавляли всякие reference-тракты, выяснилось, что .ILI вроде как их поддерживает чуть ли не с самого начала. И просто C# был такой недоделанный, что он их не поддерживал.
2794.96 2812.96 "Анатолий Кулаков" Да, действительно, в .ILI заложено очень много всего, например, перегрузка методов по возвращаемому типу, что до сих пор нет в C#, то есть мы можем перезагрузить методы по аргументам, когда метод с одинаковым именем принимает разный набор аргументов разного типа. Но .ILI по правде поддерживает еще перегрузку методов по возвращаемому типу.
2812.96 2816.96 "Анатолий Кулаков" И это тоже можно будет как-то заиспользовать.
2816.96 2820.96 "Анатолий Кулаков" Но намного интереснее, конечно, оптимизационные штуки.
2820.96 2840.96 "Анатолий Кулаков" И если вы хотите каких-нибудь примеров настоящих оптимизаций, то можете заглянуть в Namespace System Runtime Compiler Service Unsave. Там существует специальный набор методов для чтения, записи, копирования памяти, преобразования типа очень быстрых и без каких-либо проверок, определения размера указателей, преобразований между разными указателями.
2840.96 2846.96 "Анатолий Кулаков" То есть очень-очень много всего таких низкоуровневых интересных вещей, которые раньше было сделать практически невозможно.
2846.96 2854.96 "Анатолий Кулаков" Не знаю, зачем вам это может быть понадобится, но вещь интересная и в высокопроизводительном коде наверняка кому-то может понадобиться.
2854.96 2860.96 "Игорь Лабутин" Ну да, может быть, действительно, для таких совсем уж низкоуровневых штук работать с байтиками это будет полезно.
2860.96 2862.96 "Игорь Лабутин" Хорошо. Приятно, что такая штука есть.
2862.96 2876.96 "Анатолий Кулаков" Еще я недавно наткнулся на интересную толзу. Мне по работе очень часто приходится разбираться, какие сборки, откуда подгружаются, с какими версиями, какие зависимости у кого хотят. Ну и судя по докладу Пешкова на прошлом Next, эта проблема возникает не только у меня.
2876.96 2908.96 "Анатолий Кулаков" В принципе, вроде как бы Paget Brainstorm нужна и многим людям это тоже нужно. И обычно в таких вещах незаменимым инструментом является Fuzelog. Это утилита от Microsoft, который показывает вам, какие сборки ваше приложение ищет, от кого эти сборки зависят, какую версию они хотят, какая версия подставляется и где, в каком месте эту версию находится. Ну, то есть, позволяет более или менее примерно ориентироваться в том, что, какие сборки ваше приложение в конце концов будут загружены, какой версии и почему, самое главное, почему они будут именно такие загружены.
2908.96 2912.96 "Анатолий Кулаков" Это такая толза, родом из самых первых дотнетов.
2912.96 2914.96 "Анатолий Кулаков" Управлять ей довольно-таки непросто.
2914.96 2930.96 "Анатолий Кулаков" У нее есть куча всяких непонятных, непредсказуемых поведений. Например, здесь странные флажки, которые называются, например, Enable Immersive Logging. Есть непонятные дефолты, есть каталоги, из которых она иногда подцепляет нативной библиотеке, иногда не подцепляет.
2930.96 2936.96 "Анатолий Кулаков" Еще есть обидная штука, когда ее нужно выключать, потому что эта толза включается.
2936.96 2954.96 "Анатолий Кулаков" Для того, чтобы трассировать все эти запросы, замедляет ваше приложение, и поэтому в конце ее надо выключить. Очень многие забывают ее выключить. Это не только замедляет приложение, это еще и угрожает вашему диску, потому что любые обращения, любые загрузки сборок она старательно для вас локирует, и легко может забить вам весь диск.
2954.96 2964.96 "Игорь Лабутин" И надо понимать, что эта штука работает глобально на уровне всей системы, то есть она вам, любое приложение будет так себя вести после этого.
2964.96 2966.96 "Игорь Лабутин" Вообще во всей системе. Да.
2966.96 2970.96 "Анатолий Кулаков" И вот я наткнулся на интересный инструмент, который называется Fusion, и это альтернатива.
2970.96 2982.96 "Анатолий Кулаков" Альтернатива тому Fuse Log, который сделал Microsoft. Прежде всего, это, конечно, шикарный дизайн. Графички, подсветочки, табличечки, в общем, прям такой графановский дашборд тебе вылетает, который рассказывает про твои сборки.
2982.96 2986.96 "Анатолий Кулаков" Выглядит вообще потрясно. И во-вторых, конечно, она лишена всех вот этих глупостей.
2986.96 2994.96 "Анатолий Кулаков" Она сама включает наблюдение за сборками, когда вам это нужно, она сама его выключает, как только вы закрываете программу.
2994.96 3006.96 "Анатолий Кулаков" Она позволяет вам сохранять все отчеты в темповой, стандартной системной папке, в которой там винда ее может почистить с помощью регулярных джобов, и имеет много-много других интересных возможностей.
3006.96 3022.96 "Анатолий Кулаков" И самое главное, что она использует стандартные механизмы Fuse Log, то есть она не делает сама какого-то отслеживания, она не встраивается в ваше приложение, ничего такого. Она использует стандартные механизмы, которые уже есть во Fuse Log, просто-напросто рисует к этому красивый удобный UI и добавляет понятных, предсказуемых фич.
3022.96 3024.96 "Игорь Лабутин" Да, это...
3024.96 3028.96 "Игорь Лабутин" Ну, я пока еще не пользовался, она у меня сканчена, и...
3028.96 3050.96 "Игорь Лабутин" Ну, у нас пока, слава богу, в последнее время не было проблем с пешкой сборкой, и я пользуюсь случаем, этого у нас не было в темах, но хочу порекомендовать еще одну утилитку, тоже недавно наткнулся, и вот она была мне очень полезна. Есть у нас такая тема, тоже про нее Женя Пешков рассказывал, это вот Binding Redirect, и вообще всякая такая фигня может твориться в...
3050.96 3056.96 "Игорь Лабутин" с точки зрения, какие же сборки, какой же версии, каких сборок у вас реально приложение хочет.
3056.96 3078.96 "Игорь Лабутин" И в зависимости от того, какие компоненты, какие сторонние пакеты вы используете, у вас может быть в вашем output полный как бы микс всяких разных сборок, и не факт, что там будет лежать на самом деле последняя версия, потому что, возможно, последним собирался компонент, который использует, наоборот, не последнюю версию, и все работать будет не очень здорово, и там надо будет хорошо подумать, как написать Binding Redirect.
3078.96 3126.96 "Игорь Лабутин" Есть такая утилитка, называется ASM Spy, Assembly Spy, это простой command-line tool, который натравливается на папочку, и он на самом деле просто пишет отчет уровня, что вот у вас есть там System.NET HTTP, вот такой, такой, такой версии, и от них зависят такие-то, такие-то, такие-то библиотеки. То есть можно по сути, мы ее очень успешно использовали, понять вообще, какая сборная солянка версий у вас генерируется в результате билда в вашей output-директории, и постараться предсказать, не прибегая к Binding Redirect, вообще, что, возможно, вы используете где-то в этой библиотечке, либо что у вас будут проблемы, если вы не сгенерите правильный Binding Redirect. То есть она как-то очень сильно спасла, мы тоже ее закинем в список полезных линков.
3126.96 3128.96 "Игорь Лабутин" Я вот внезапно про нее вспомнил.
3128.96 3130.96 "Анатолий Кулаков" Обязательно прикрепляйте в шоу-ноты, все будет.
3130.96 3140.96 "Анатолий Кулаков" Следующая статейка меня очень сильно зацепила, функциональное программирование - это не то, что нам рассказывают за авторством Алексея, известного на Хабре, как PsyHaste.
3140.96 3142.96 "Анатолий Кулаков" Чем мне понравилась статья?
3142.96 3150.96 "Анатолий Кулаков" Тем, что она как раз открыла ту сущность, тот смысл, всю ту изюминку, которую я вижу в функциональном программировании.
3150.96 3176.96 "Анатолий Кулаков" Все вот эти глупости, которые вам рассказывают про ImmuneAbility, про акторов, про машинное обучение или еще какую-то странь приплетают сюда - вот это не самое главное. Вот это не самое то, что нужно. Это не та философия функционального программирования, которую она пытается донести. А философия у него совершенно другая. И для того, чтобы ее постичь, вам абсолютно не нужно писать на функциональных языках.
3176.96 3188.96 "Анатолий Кулаков" И многие книги по архитектуре, многие статьи, блоги про архитектуру - они в принципе доходят до этой философии и на обычных процедурных и объектно-ориентированных языках.
3188.96 3204.96 "Анатолий Кулаков" И мне очень приятно, что вот этот подход, он не просто выработался какой-то там непонятной практикой каких-то ООПшников, а этот подход, он был математически доказан, математически выверен и многолетним опытом проверен в функциональных языках.
3204.96 3222.96 "Анатолий Кулаков" Это как раз тот пример, когда спрашивают, зачем учить функциональные языки, если я на них все равно писать не буду, у нас production на них нет и все такое. Это как раз тот пример, когда функциональные языки просто-напросто раскрывают ваш образ мышления, позволяет вам мыслить по-другому даже в рамках тех проектов и тех языков, которые вы используете каждый день.
3222.96 3226.96 "Анатолий Кулаков" Вот. Что же такое функциональное программирование?
3226.96 3234.96 "Анатолий Кулаков" Основная идея функционального программирования, как утверждает автор, это далеко не лямбда, не мьютабилити и ничего в этом духе. Основная идея - это ссылочная прозрачность.
3234.96 3244.96 "Анатолий Кулаков" Ссылочная прозрачность - это специальное свойство кода, при котором замена выражения на вычисляемый результат этого выражения не изменяет желаемое свойство программы.
3244.96 3250.96 "Анатолий Кулаков" То есть вы можете любую функцию заменить на ее результат и ваша программа продолжит выполняться так же, как выполнялась раньше.
3250.96 3254.96 "Анатолий Кулаков" В принципе, эта мелочь, она имеет под собой очень много всяких выводов, которые можно из этого сделать.
3254.96 3280.96 "Анатолий Кулаков" Вот именно отсюда следует и мьютабилити, именно отсюда следует и наблюдаемость результата, именно отсюда следует много других интересных выводов. Но самое главное, что отсюда следует, это предсказуемость и читаемость программы. Как только вы закладываетесь на то, что программа внутри себя не может менять какое-то состояние, видимое внешним наблюдателем, это позволяет вам обрабатывать очень много интересных ситуаций, таких как параллелизм и прочие технические требедения.
3280.96 3284.96 "Анатолий Кулаков" Но с точки зрения архитектуры языка нам интересно другое свойство.
3284.96 3292.96 "Анатолий Кулаков" Это позволяет нам делать выразительные, понятные методы, выразительные, понятные классы и выразительные, понятные сигнатуры.
3292.96 3322.96 "Анатолий Кулаков" То есть, как только вы внутри себя перестанете делать какие-то изменения, которые затрагивает внешний мир, вы будете вынуждены все результаты вашей работы выражать через сигнатуры. То есть, метод будет что-то принимать на вход, и метод будет что-то возвращать. И по этим сигнатурам очень легко понимается в конце концов, что ваша программа делает. В частности, почему этот подход распространен больше в функциональных языках программирования, чем в объектно-ориентированных.
3322.96 3326.96 "Анатолий Кулаков" Потому что в функциональных языках система типов больше, система типов лучше.
3326.96 3330.96 "Анатолий Кулаков" Как раз те самые алгебраические типы данных, которые мы упоминали в начале выпуска.
3330.96 3342.96 "Анатолий Кулаков" Вот как только у вас скрещиваются вот эти миры, вы в принципе просто глядя на функции, можете понимать, что она делает. И когда вы оперируете тем фактом, что внутри себя никаких сайд-эффектов она не производит. Вот слушай,
3342.96 3364.96 "Игорь Лабутин" когда я много чего слушаю про функциональное программирование, я не сильно его сторонник, в смысле, что я, можно сказать, я писал когда-то на функциональных языках типа Acamlia, где-то давно в университете, компилятор из Pascal для .NET, в смысле в .NET Runtime. Я Pascal запускался на .NET Runtime.
3364.96 3380.96 "Игорь Лабутин" Но у меня всегда возникал вопрос, то есть то, что ты говоришь, что все там чистые функции, неизменяемость, состояние, ну от того, что мы заменили функцию, но и результат ее вычисления ничего не поменялось, и что мы никак не производим никаких сторонних эффектов.
3380.96 3400.96 "Игорь Лабутин" Но в реальном же бизнесе там куча сторонних эффектов, начиная от баз данных, да, из которых нужно записи, ну что-то прочитать, куда-то записать, заканчивая, ну хотя бы простым логинком, который я хочу видеть в некоторой сторонней системе. Это, я так понимаю, уже будет некоторый сайд-эффект работы функции, если я хочу что-то из нее залогировать.
3400.96 3402.96 "Игорь Лабутин" Как мы это будем все логировать-то тогда?
3402.96 3408.96 "Игорь Лабутин" Ну, то есть у меня не очень складывается картинка, как писать нормальный обычный бизнес-код на функциональном языке.
3408.96 3420.96 "Анатолий Кулаков" На самом деле все это, если мы говорим про функциональные языки, все это выходит в специальные монады, с помощью которых функционально объясняют абсолютно все, что только можно объяснить, и то, что они сами не могут объяснить.
3420.96 3422.96 "Анатолий Кулаков" И там происходит специальная интерпретация.
3422.96 3446.96 "Анатолий Кулаков" Но мне бы хотелось все-таки остаться в рамках, даже у самого C#, то есть не выходя на специальный функциональный уровень какого-то рантайма. В C# это сводится всего лишь навсего к той парадигме, что вы стараетесь в своем классе разделить методы. Отделить методы, которые делают бизнес-логику, отделить методы, которые что-то считают, что-то производят, что-то распараллеливают или делают какие-то ветвления, делать их неизменяемыми.
3446.96 3460.96 "Анатолий Кулаков" И рядом ставить методы, которые модифицируют внешнее состояние, так называемые грязные методы. Что это нам дает? Грязные методы никогда не содержат логики. Это значит, что грязные методы никогда не надо тестировать. А вот чистые методы, они содержат всю логику.
3460.96 3462.96 "Анатолий Кулаков" И это значит, что их очень легко тестировать.
3462.96 3472.96 "Анатолий Кулаков" Вам не нужны никакие моки, вам не нужно ничего, потому что нечего мокать, у вас нет никакого внешнего состояния. Все, что нужно, функция берет на вход. Все, что ей от вас не нужно, она их возвращает.
3472.96 3482.96 "Анатолий Кулаков" Поэтому программа, написанная с помощью такого подхода, отличается обалденной тестабельностью, если так можно выразиться.
3482.96 3494.96 "Анатолий Кулаков" А все те сайд-эффекты, о которых ты говоришь, точно так же собираются из этих чистых функций, собираются в грязную функцию, которой нет вообще никакой логики. И применяются, накатываются, пишутся, запрашиваются, отдаются и так далее.
3494.96 3502.96 "Игорь Лабутин" Угу, окей. То есть мы как бы делим их на те и на другие и таким образом оно... Ну, возможно.
3502.96 3508.96 "Игорь Лабутин" Возможно. Я не понимаю, как такое можно писать, но наверное, в этом что-то есть.
3508.96 3514.96 "Игорь Лабутин" Я, допустим, хорошо раскрываю твой взгляд на мир функционального программирования.
3514.96 3524.96 "Игорь Лабутин" А какой из этого всего вывод для нас, обычных ООПшников, которые вроде как пишут классики, логируют прямо из грязных функций, в базу лазают туда же прямо?
3524.96 3548.96 "Анатолий Кулаков" Если вы хотите, чтобы ваш код лучше тестировался, если вы хотите, чтобы ваш код переживал лучше параллельные вычисления, если вы хотите, чтобы ваш код был предсказуем и какие-то случайные перестановки или случайные рефакторинги не ломали его к чертовой матери и много-много чего еще, то старайтесь как можно чаще, как можно больше использовать неизменяемые типы данных и чистые функции.
3548.96 3566.96 "Анатолий Кулаков" Вот это разделение вашей программы на области чистые и немьютабельные и отдельно грязные, но без логики, оно дает огромное количество преимуществ. Если вы начнете так писать, вы постепенно увидите насколько легче, прекраснее и предсказуемее мир становится вокруг вас.
3566.96 3574.96 "Анатолий Кулаков" Безусловно, вы не добьетесь всей идеальности, которая существует в Haskell или что-то в этом духе, но уже вы приобретете очень-очень много всего
3574.96 3584.96 "Игорь Лабутин" полезного. Читаем статью, проникаемся, я смотрю, что к ней какое-то немеренейшее количество комментариев, около 700 с лишним, так что я думаю, что...
3584.96 3604.96 "Анатолий Кулаков" Да, статья вызвала реальное бурление, там и в комментариях пошли вопросы типа, как менять нам, как менять состояние, чем это отличается и так далее. То есть очень много интересных примеров разбирается в комментарии, и если вам эта тема вылезка, если вы хотите все-таки понять, разобраться и поучиться, то вот это одна из лучших статей.
3604.96 3608.96 "Анатолий Кулаков" Сказать бы про функциональное программирование, но нет.
3608.96 3612.96 "Анатолий Кулаков" Также 250+ сейчас на данный момент тоже довольно нехило.
3612.96 3614.96 "Игорь Лабутин" Да, нехило. Ну, хорошо, хорошо.
3614.96 3630.96 "Игорь Лабутин" То есть это действительно довольно скажем так, интересное описание для обычных объектно-ориентированных программистов, в отличие от других статей, где со второго абзаца начинается Monado и все такое.
3630.96 3632.96 "Игорь Лабутин" Здесь я смотрю, что слово Monado, по-моему, даже ни разу не употребляется.
3632.96 3634.96 "Игорь Лабутин" И это как бы... Да, да, именно так.
3634.96 3636.96 "Игорь Лабутин" И это, да, это большой плюс статьи.
3636.96 3638.96 "Игорь Лабутин" Хорошо.
3638.96 3648.96 "Игорь Лабутин" Приятная статья. Я на самом деле даже себе добавил закладочки, детально почитать, в том числе комментарии, чтобы ознакомиться как следует. Так, есть ли у нас сегодня что-нибудь еще обсудить?
3648.96 3650.96 "Анатолий Кулаков" А, набрал на статейку Скотта Хансельмана.
3650.96 3662.96 "Анатолий Кулаков" У него, в принципе, много статей. Вот это меня интересно зацепило. Я когда-то был большим фанатом Nancy. Если кто не знает, что раньше ISP.NET был большим, монструозным, тяжелым, на нем писали большие интерфейс-приложения.
3662.96 3676.96 "Анатолий Кулаков" И сообщество .NET хотело какого-то легковесного веб-сервера, который можно было быстренько набросать каких-то пару роутингов, запустить свои классики, запустить свои запросики и не заморачиваться с веб-инсталляциями, контроллерами и так далее.
3676.96 3680.96 "Анатолий Кулаков" И глотком этого свежего воздуха был проект NancyFX.
3680.96 3682.96 "Анатолий Кулаков" Обалденный проект.
3682.96 3684.96 "Анатолий Кулаков" Он внес много интересных концепций.
3684.96 3696.96 "Анатолий Кулаков" Он был вдохновлен таким фреймворком, как Sinatra. Это веб-сервер на рубях. И постарался принести его такой сообразной легкость синтаксис динамических языков.
3696.96 3710.96 "Анатолий Кулаков" То есть, вы могли там, например, объявить ваш роутинг, написать, проанализировать входные аргументы, написать ответ и все это сделать в одной строчке. Для этого вам не нужно было создавать там какие-то контроллеры, от кого-то наследоваться, ставить какие-то страшные атрибуты.
3710.96 3726.96 "Анатолий Кулаков" Тем более в те времена это было совсем очень многословно и очень много страшного. В общем, синтаксис тех, кто хоть раз пользовал Nancy или тех, кто раз видел его, синтаксис никого не ставит равнодушными. То есть, как создаются там так называемые роуты, модули.
3726.96 3738.96 "Анатолий Кулаков" И .NET Core принес нам такую ужасную для Nancy штуку, как ISP.NET Core, в котором люди пересмотрели подход к тому, как они делали раньше приложения.
3738.96 3752.96 "Анатолий Кулаков" Теперь уже даже от базового контроллера наследоваться не обязательно, теперь можно вообще класс делать без наследников. Теперь указывать кучу ненужных атрибутов не обязательно, теперь там какие-то удобные конвеншины есть и так далее. И необходимость в Nancy более-менее отпала.
3752.96 3766.96 "Анатолий Кулаков" И сам ISP, надо сказать, он стал намного шустрее, намного быстрее и намного легковеснее. Теперь его можно без опаски тащить даже в самые маленькие приложения. Это катастрофически сказалось на Nancy, сейчас проект больше мертв, чем жив.
3766.96 3774.96 "Анатолий Кулаков" Но все-таки, чего до сих пор ISP у нас не смог привнести, это как раз элегантный синтексис, элегантный синтексис задания роутов.
3774.96 3786.96 "Анатолий Кулаков" И Scott открыл библиотечку, которая называется Carter. Carter - это специальный метод расширения, специальный middleware, который помогает вам превратить ваш ISP, ISP Core в Nancy-подобный синтексис.
3786.96 3790.96 "Анатолий Кулаков" В общем, очень легкий и быстрый роты.
3790.96 3810.96 "Анатолий Кулаков" Если вам не нужно гордить какую-то большую логику в ваших контроллерах, а просто нужно куда-нибудь передиректить или быстренько ответить на какой-то запрос, например, просто на health check, то эта библиотечка вам очень сильно поможет сократить синтексис и сделать более читабельный ваш код, который отвечает именно за внешние запросы.
3810.96 3814.96 "Игорь Лабутин" Так, понял.
3814.96 3826.96 "Игорь Лабутин" Не понял, примерно как с CSC. То есть не ждет ли вот этой штуки судьба примерно так же, как с Nancy? Потому что, как ты сам говоришь, с развитием ISP-Ned Core сейчас надобность в Nancy вроде как отпала.
3826.96 3840.96 "Игорь Лабутин" То есть я не очень вижу применимость, потому что даже на ISP-Ned Core сейчас, в принципе, довольно просто набросать какую-то простую штуку даже без контроллеров. То есть можно прям в стартап CSC написать роутов и что они
3840.96 3854.96 "Анатолий Кулаков" возвращают, и все. Тут, прежде всего, надо понимать, что Nancy - это большой был фреймворк, и был прямым конкурентом ISP-Core, и конкуренция была не в его пользу. А здесь это всего лишь навсего библиотека с удобными расширениями, вот и все. Поэтому даже если...
3854.96 3856.96 "Анатолий Кулаков" То есть ей невозможно загнуться.
3856.96 3862.96 "Анатолий Кулаков" Она уже написана, она уже есть, там появляются какие-то баги, которые можно фиксить, и все. Загнуться здесь нечему.
3862.96 3872.96 "Анатолий Кулаков" Насчет того, что можно писать роуты и в стандартном ISP, дело в том, что они там пишут не настолько просто, не настолько элегантно.
3872.96 3882.96 "Анатолий Кулаков" Если ты сравнишь два этих синтексов, то Nancy-ский синтекс из картера, он позволяет тебе большую гибкость, больше код-конвеншинов, больше полезных методов расширения и так далее.
3882.96 3888.96 "Анатолий Кулаков" То есть суть ты уловил правильную, но эта штука позволяет тебе вывести вот эти однострочники просто на новый уровень.
3888.96 3904.96 "Анатолий Кулаков" То есть ты полноценно можешь заменять маленькие веб-сервера с помощью нее и не чувствовать каких-то проблем с хейтерами, например, с децертилизацией аргументов, пересылкой кастомных контент-тайпов и вот этого всего прочего.
3904.96 3906.96 "Анатолий Кулаков" То есть это чуть более такие мощные
3906.96 3938.96 "Игорь Лабутин" методы расширения. Все, понял. Ну тогда, да, тогда, наверное, действительно, если в... мне кажется, что use case тогда будет такое, что либо достаточно много таких штук нужно писать, потому что если нужно писать 1, 2, 3, то на самом деле, кажется, там ISP-нете проще это сделать. Если же нужно писать много и там команда, например, привыкнет, то действительно, почему нет? Библиотечка, которая за вас там будет делать много чего, а вы будете просто писать какие-то простые endpoints и минимальную реализацию для них.
3938.96 3946.96 "Игорь Лабутин" Ну, да, наверное, имеет право на жизнь. Тем более на ENSI все-таки это был полноценный фреймворк большой, который как бы отдельно нужно было затащить.
3946.96 3948.96 "Игорь Лабутин" Ну, небольшое неправильное слово, но тем не менее.
3948.96 3954.96 "Игорь Лабутин" То есть здесь это вроде как просто библиотечка, которую ну, где-то завязал и все.
3954.96 3968.96 "Игорь Лабутин" Может быть, у нее не такие там замашки, как у ENSI в плане, чтобы быть там альтернативным фреймворком ISP-нету, но органично дополнять ISP-нету в тех местах, где ISP-нета слишком тяжел. Да, наверное.
3968.96 3994.96 "Игорь Лабутин" Так, и я думаю, что нужно потихонечку переходить и даже, может быть, начинать закругляться. Мы уже почти час болтаем. И давай посмотрим на последнюю тему у нас в списке. Есть такая штука, как Modern Cloud Applications. Это там хайп и все такое. Мы сейчас все пишем Modern Cloud Applications и появляется вокруг куча тулов, которые позволяют нам это делать легче и проще.
3994.96 4002.96 "Игорь Лабутин" И в данном случае мы конкретно это позволяет не там писать приложения легче и проще, а деплойть их.
4002.96 4006.96 "Игорь Лабутин" Деплойть прямо на .NET Core. В смысле код деплоймента писать на .NET Core.
4006.96 4020.96 "Анатолий Кулаков" Да, новость заключается в том, что Jadafi за... релизил под C#, зарелизил от .NET свои биннинги от Pulumi. Здесь надо объяснить, что такое Pulumi. Pulumi - это очень классная идея.
4020.96 4030.96 "Анатолий Кулаков" Вы можете, например, знать такие штуки, как Ansible, Puppet, Chef, Terraform и так далее. То есть это специальные инструменты, которые позволяют вам подготовить инфраструктуру под ваши приложения.
4030.96 4040.96 "Анатолий Кулаков" Которые позволяют там развернуть машины, настроить окружение, поставить нужные библиотечки, запустить в конце концов ваше приложение и так далее.
4040.96 4084.96 "Анатолий Кулаков" И большая проблема всех этих тулзовин состоит в их языке конфигурации. Почти все они используют YAML. YAML в принципе прекрасен, когда вам нужно писать 10 строк конфигурации, но когда вы на них начинаете писать кубернетовские конфиги, которые выливаются в миллионы и миллионы строк YAML'а, на языке, который должен быть декларативным, из которого пытаются сделать какое-то императивщину, это становится больно, это становится ужасно и в принципе непонятно, зачем так делать. Зачем, если для настройки сложной инфраструктуры, для настройки сложных условий развертывания можно использовать настоящий императивный язык? И как ни странно, в принципе, конкурента на этом рынке не было, чтобы такую императивщину делать.
4084.96 4088.96 "Анатолий Кулаков" И Pulumi - это как раз тот инструмент, который вам это позволяет.
4088.96 4102.96 "Анатолий Кулаков" Это штука, которая умеет управлять абсолютно всеми модными клаудами, включая, естественно, Amazon, Azure и даже DigitalOcean, и Google и прочие вещи поменьше.
4102.96 4114.96 "Анатолий Кулаков" И она позволяет вам это делать, она позволяет вам писать конфигурацию не на каком-то странном YAML'е, а на обычных языках программирования. В частности, это можно сделать на C#. То есть вы на своем C# описываете ресурсы.
4114.96 4136.96 "Анатолий Кулаков" Вот я хочу создать какую-то ресурс-группу, хочу запустить в ней сервис Cosmos DB, например, хочу этот Cosmos DB распространить в таких-то дата-центрах, хочу, чтобы у меня там запустилась Azure Function, которая будет данные отсюда забирать, туда-то складывать и так далее. То есть вот эту всю инфраструктуру, все ваши приложения, все ваши зависимости вы можете описать в вашем C# коде.
4136.96 4166.96 "Анатолий Кулаков" И это, мне кажется, довольно интересный шаг, довольно интересные подвижки, которые позволяют вам не учить какой-то странный YAML'ок и синтаксис, а получить ваши конфиги уже на C#. То есть что это значит? Вы можете пользоваться вашими любимыми IDE с лицензами, с подсветками, ваша, корректность вашего кода в большинстве случаев проверить в компилятор, с понятными, строго типизированными типами. Вы можете ваш код тестировать. Все есть в полюме для тестирования инфраструктуры.
4166.96 4168.96 "Игорь Лабутин" Звучит вообще здорово.
4168.96 4180.96 "Анатолий Кулаков" Поддерживаются любые .NET языки, C#, F#, WebNet и все, что вам угодно. То есть, мне кажется, довольно классная штука, я обязательно на нее посмотрю и, может быть, поделюсь в будущих выпусках своими впечатлениями.
4180.96 4188.96 "Игорь Лабутин" На самом деле, тут, может быть, мы как-нибудь отдельно затронем эту тему, просто кратенько тогда расспомнилось.
4188.96 4200.96 "Игорь Лабутин" Было недавнее обсуждение в Twitter довольно бурное на тему того, что .NET как экосистема сильно, скажем так, страдает.
4200.96 4238.96 "Игорь Лабутин" Ну, не то, что страдает, но в ней нету практически никаких именно тулов, кроме языка программирования и фреймворков к нему, нету никаких сопутствующих тулов. То есть, если посмотреть, то весь DevOps, которым мы пользуемся, кубернет, тот же Pulumi и все остальное, оно все же написано не на .NET. Оно все там либо Go, либо там Java, все что угодно. То есть, у нас очень мало инфраструктурных штук на .NET написано. По разным причинам, и, наверное, сейчас мы не будем детально это обсуждать, ну вот, наверное, Pulumi - это один из шагов в сторону, так сказать, чуть больше близости этого всего
4238.96 4246.96 "Анатолий Кулаков" к .NET. Ну, обычно ты инфраструктурные инструменты просто используешь как уже готовые какие-то программы, и тебе в большинстве случаев наплевать, на чем они написаны.
4246.96 4248.96 "Анатолий Кулаков" Поэтому это не так важно там становится. Мне тоже
4248.96 4254.96 "Игорь Лабутин" так казалось, но почему-то это вызвало достаточно бурное обсуждение. Посмотрим, чем закончится. С интересом следим.
4254.96 4262.96 "Анатолий Кулаков" Я согласен, тема довольно интересная, я думаю, обсудить ее все-таки стоит. В общем, давайте забросим backlog. А сейчас у нас, по ходу, все. Супер! Ну,
4262.96 4282.96 "Игорь Лабутин" отлично, хорошо поговорили, обсудили какие-то новинки, какие-то старые штуки. Ждем большего, большей определенности по C#, потому что C# 8 уже вроде как везде, ну, может быть, не во всех кодовых базах, но во всех Visual Studio страны, и не только страны и мира. И нужно больше новостей.
4282.96 4284.96 "Игорь Лабутин" Так что, услышимся скоро
4284.96 4300.96 "Анатолий Кулаков" еще разок. Да. А на сегодня все. Все наши выпуски вы можете найти на сайте radio.dotnet.ru Писать можно туда же, radiosobaka.net.ru Также у нас есть промокод для грядущей конференции .NEXT, которая пройдет в Питере.
4300.96 4302.96 "Анатолий Кулаков" Ищите ее в шоу-ноутах.
4302.96 4304.96 "Анатолий Кулаков" И до скорых встреч. Всем пока!
4304.96 4306.96 "Анатолий Кулаков" Пока!
