0.00 8.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья.
8.36 11.60 "Анатолий Кулаков" В эфире Радио.нет выпуск номер 64.
11.60 14.88 "Анатолий Кулаков" И сегодня с вами, как всегда, Анатолий Кулаков.
14.88 15.88 "Игорь Лабутин" И Игорь Лабутин.
15.88 16.88 "Игорь Лабутин" Всем привет.
16.88 19.36 "Анатолий Кулаков" Прежде всего, большое спасибо нашим помогаторам.
19.36 25.04 "Анатолий Кулаков" Это славные парни Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Илья и Гурий Самарин.
25.04 26.04 "Анатолий Кулаков" Спасибо, друзья.
26.04 28.64 "Анатолий Кулаков" Этот выпуск выходит в частности благодаря вам.
28.64 36.12 "Анатолий Кулаков" Ну что ж, а мы с вами немножко сегодня обсудим .NET, посмотрим, что у нас интересно вышло, какие интересные статьи, какие интересные новости.
36.12 42.32 "Анатолий Кулаков" В общем, не пропустим ничего того, о чем нужно знать каждому разработчику, ну и не только.
42.32 48.80 "Анатолий Кулаков" И начать нам хотелось бы… Что, прямо с .NET 8, вот прямо тогда с порога, сразу в 8?
48.80 51.56 "Игорь Лабутин" Да, сразу в 8, сразу в порога.
51.56 58.68 "Игорь Лабутин" Вообще говоря, не было еще никаких анонсов про то, что у нас там появился первый превью или еще что-нибудь в таком духе.
58.68 60.80 "Игорь Лабутин" Что вообще .NET 8 будет?
60.80 65.68 "Игорь Лабутин" Да нет, ну быть-то он будет, это же LTS, иначе шестерка протухнет и чем мы будем пользоваться.
65.68 71.96 "Игорь Лабутин" Но первые превью 8 обещали где-то в начале февраля, если я правильно помню.
71.96 86.60 "Игорь Лабутин" Сейчас пока его нет, но энтузиасты уже потихонечку закапываются в GitHub .NET и различных репозиториях и пытаются понять вообще, что там происходит и какие интересные фишки уже можно найти и находят.
86.60 89.36 "Игорь Лабутин" Давайте про это и поговорим.
89.36 98.96 "Игорь Лабутин" Для начала, собственно, в сегодняшнем выпуске мы поговорим про такую штуку, как Frozen Collections, то есть замороженные коллекции.
98.96 109.24 "Игорь Лабутин" Казалось бы, зачем нам еще один вид коллекции, потому что у нас есть простые коллекции, у нас есть read-only коллекции, у нас есть immutable коллекции, вот теперь у нас еще и будут frozen коллекции.
109.24 113.52 "Игорь Лабутин" Мне кажется, очередной отличный пул вопросов на собеседовании почти готов.
113.52 116.16 "Игорь Лабутин" Чем эти штуки отличаются?
116.16 122.92 "Игорь Лабутин" И чтобы разобраться, что же на этих собеседованиях отвечать, давайте, собственно, разберемся, чем же они отличаются.
122.92 129.76 "Игорь Лабутин" Смотрите, значит, у нас есть просто обычные коллекции, например, списки словари и прочее, множество сетов.
129.76 138.68 "Игорь Лабутин" Есть их read-only версии, то есть у нас есть read-only dictionary, read-only list, есть у нас read-only list, что-то я уже не помню.
138.68 139.68 "Игорь Лабутин" Есть read-only list, конечно.
139.68 140.68 "Игорь Лабутин" Отлично, вот.
140.68 162.16 "Игорь Лабутин" А есть у нас, и read-only эта штука, это по сути некоторое read-only view вокруг коллекции, то есть когда вы создаете read-only коллекцию, вы ей передаете исходную коллекцию, и read-only это просто небольшая прокси, которая все запросы на чтение передает в нижележащую коллекцию, а все запросы на запись она откидывает как неверный.
162.16 166.28 "Игорь Лабутин" И если вы поменяете нижележащую коллекцию, то read-only коллекция увидит это изменение.
166.28 169.36 "Игорь Лабутин" У нас есть immutable коллекция.
169.36 178.28 "Анатолий Кулаков" Подожди, я хотел вот добавить, между прочим, это очень важная штука, и многие люди, вот я наблюдал даже на собеседованиях, не понимают разницы.
178.28 188.80 "Анатолий Кулаков" У многих людей в голове сложилась такая ситуация, что как только они видят read-only list, они думают, что этот лист навсегда будет такой, как они его увидели.
188.80 190.80 "Анатолий Кулаков" Но он же read-only, значит никто его поменять не может.
190.80 198.40 "Анатолий Кулаков" Вот на самом деле здесь кроется большая-большая заблуждение, потому что на самом деле read-only он для вас, для того потребителя, которому вы его дали.
198.40 203.16 "Анатолий Кулаков" Но источником вполне может быть настоящий лист, которому туда могут записать любой менеджер что угодно.
203.16 206.04 "Анатолий Кулаков" То есть он может поменяться, read-only листы умеют меняться.
206.04 209.80 "Анатолий Кулаков" И эта разница, она очень важная, особенно в некоторых интересных алгоритмах.
209.80 220.48 "Игорь Лабутин" Да, и если вам нужен прям совсем-совсем read-only, вот тот, который точно не сможет поменяться, то раньше нужно было использовать immutable коллекции.
220.48 226.80 "Игорь Лабутин" Это штука, которая внутри себя содержит данные, и вот эти данные вы уже точно никак не поменяете.
226.80 233.28 "Игорь Лабутин" Если у вас есть референс на какую-то коллекцию, она гарантированно 100% останется ровно в том виде, в котором она вам была передана.
233.28 235.28 "Игорь Лабутин" На то она immutable.
235.28 253.24 "Игорь Лабутин" Но мы все-таки иногда хотим модифицировать коллекции, и immutable коллекции, они могут модифицироваться за счет создания новых инстансов коллекции, которые там внутри хитро оптимизированы, чтобы доступаться к элементам, которые общие между двумя коллекциями.
253.24 261.32 "Игорь Лабутин" Потому что если вы добавляете, например, один элементик в какой-нибудь длинный-длинный список, то нет смысла копировать весь объем данных из старого списка в новый immutable список.
261.32 268.48 "Игорь Лабутин" На самом деле они шарят общие данные, и новый список просто содержит дельту, если очень грубо рассказывать.
268.48 270.16 "Игорь Лабутин" А теперь есть еще и frozen.
270.16 284.36 "Игорь Лабутин" Вот frozen как раз-таки не позволяет писать, позволяет читать, никак не имеет возможности себя изменять с точки зрения, нет понятия как в read-only коллекции источника, которая может поменяться.
284.36 294.16 "Игорь Лабутин" Но frozen, в отличие от immutable, не оптимизирован никак на добавление, то есть на создание новых frozen коллекций из другой frozen коллекции.
294.16 302.24 "Игорь Лабутин" Frozen оптимизирован на то, чтобы из него быстро читать, зная, что эта коллекция никогда не изменится.
302.24 308.24 "Игорь Лабутин" На данный момент у нас есть всего две таких коллекции, точнее есть два абстрактных класса.
308.24 311.56 "Игорь Лабутин" Это frozen set и frozen dictionary.
311.56 314.88 "Игорь Лабутин" Frozen-листа, например, нету, то есть есть только множество или словарик.
314.88 327.96 "Игорь Лабутин" И они абстрактные, при этом у них на самом деле конструктор объявлен как internal, то есть это значит, что свои собственные frozen set и frozen dictionary вы сделать не сможете.
327.96 352.44 "Игорь Лабутин" Сделано это для того, чтобы все-таки из всяких фабрик и прочих мест уметь возвращать обычный generic версии frozen set и frozen dictionary, а внутри runtime, как я понимаю, будет реализовывать более эффективные коллекции, что-нибудь типа frozen dictionary от стринга, реализуется отдельным классом, который позволит делать очень эффективную лукапы по стрингам, например, или по интам.
352.44 362.88 "Игорь Лабутин" То есть когда у нас известен тип ключа, понятное дело, что можно написать очень эффективную коллекцию с очень эффективным поиском, если ты заранее знаешь, что она по стрингам или по интам.
362.88 369.64 "Игорь Лабутин" Вот внутри runtime, для того чтобы наш runtime был еще более быстрым, будут использоваться вот такие штуки.
369.64 372.88 "Игорь Лабутин" Ну и мы можем тоже поиспользовать снаружи, если уж очень захотим.
372.88 377.32 "Игорь Лабутин" Уже появились некоторые первые бенчмарки.
377.32 382.24 "Игорь Лабутин" В статье, которая у нас будет приведена в шоу-ноутах, есть сравнение с листом.
382.24 392.56 "Игорь Лабутин" Ну с листом сравнивать бесполезно, потому что мы делаем не frozen list, а frozen set, поэтому там приведено сравнение между frozen set, hash set и immutable hash set.
392.56 402.56 "Игорь Лабутин" И если посмотреть на то, как долго выполняется метод contains, то есть у нас есть просто коллекция, допустим, интов, и мы на ней дергаем contains с каким-то значением.
402.56 411.72 "Игорь Лабутин" То на frozen set это занимает почти 2 микросекунды, на hash set почти 3 микросекунды, на immutable 15 микросекунд.
411.72 413.24 "Игорь Лабутин" То есть frozen set он самый быстрый.
413.24 418.72 "Игорь Лабутин" Уже сейчас это только первая версия, по сути как такая прототип написанная.
418.72 429.08 "Игорь Лабутин" То есть получается, что frozen set действительно очень быстро читается, но все-таки он читается очень быстро ценой довольно дорогого создания.
429.08 438.16 "Игорь Лабутин" Помним, что получается, что frozen set у нас читается почти за 2 микросекунды, а hash set обыкновенный самый за 3 микросекунды, то есть в полтора раза быстрее.
438.16 451.40 "Игорь Лабутин" Если же мы посмотрим на создание, то для того, чтобы создать hash set из 1000 интов, нам нужно примерно 6,5... нет, 6,6 микросекунд.
451.40 453.32 "Игорь Лабутин" То есть 6,6 микросекунд.
453.32 455.52 "Игорь Лабутин" Ну как бы нужно и нужно.
455.52 462.56 "Игорь Лабутин" Для frozen set нам нужно уже 57 микросекунд, то есть почти в 10 раз больше.
462.56 466.80 "Игорь Лабутин" А для immutable hash set нам нужно 200 микросекунд.
466.80 469.80 "Игорь Лабутин" То есть это еще в 4 раза больше, чем у frozen set.
469.80 476.32 "Игорь Лабутин" То есть ценой довольно дорогого создания мы получаем очень оптимизированную коллекцию на чтение.
476.32 480.16 "Игорь Лабутин" Тут как раз и кроется то, с чем runtime хочет работать.
480.16 487.40 "Игорь Лабутин" У них очень много словарей внутри и коллекции, которые создаются один раз за все время жизни runtime и только всегда читаются.
487.40 491.24 "Игорь Лабутин" Ну поэтому вот они это дело и оптимизируют.
491.24 494.84 "Игорь Лабутин" В общем вот такая штука у нас появилась во восьмом дотнете.
494.84 497.96 "Игорь Лабутин" Пока это очень ранний превью, там идут еще обсуждения, что как делать.
497.96 501.08 "Игорь Лабутин" Прототипная версия уже есть, ее вот народ бенчмаркает.
501.08 508.12 "Игорь Лабутин" Но понятно, что все может измениться к первому превью, все могут еще раз уж петь откатить, накатить, поменять и все такое прочее.
508.12 512.28 "Игорь Лабутин" Но начнем следить, что происходит во восьмом дотнете.
512.28 516.36 "Игорь Лабутин" Кажется, что перформанс не забыт и наш дотнет будет становиться еще быстрее.
516.36 533.16 "Анатолий Кулаков" Мне все-таки обидно, что они не дожали вот эту тему, потому что часто, опять же, на самом деле, если вы пишете такое высоконагруженное приложение, которое работает очень плотно с данными, с памятью, оптимизирует пересылку данных и прочее, прочее.
533.16 541.52 "Анатолий Кулаков" Очень часто в дотнете не хватает такого понятия, как действительно неизменяемые коллекции, которые не копируют данные.
541.52 548.04 "Анатолий Кулаков" Например, здесь не подходит какой-нибудь Redonly-лист, потому что на самом деле он является всего лишь навсего оберткой над настоящим листом.
548.04 551.64 "Анатолий Кулаков" Может являться, естественно, в общем случае.
551.64 554.96 "Анатолий Кулаков" Но так как он может являться, соответственно, для потребителя нет никаких гарантий.
554.96 556.80 "Анатолий Кулаков" А хочется гарантий для потребителя.
556.80 563.56 "Анатолий Кулаков" Нам здесь не подходит Immutable, потому что он очень медленный и все-таки он сделан не для того.
563.56 571.24 "Анатолий Кулаков" Он все-таки сделан в большинстве случаев для параллельного изменения, для того, чтобы безопасно сделать параллельные изменения.
571.24 580.20 "Анатолий Кулаков" А хочется именно такой классик, который ты один раз создал, может быть потратил много времени на его создание, но потом его каким-то образом зафиксировал.
580.20 585.24 "Анатолий Кулаков" И эти элементы, например элементы листа, больше никак и никогда ни кем не менялись.
585.24 590.04 "Анатолий Кулаков" И потребителю, который получает такой контракт, это будет сто процентов гарантировалось.
590.04 600.48 "Анатолий Кулаков" Вот кажется, что это что-то типа наших Frozen коллекций, то есть они полностью соответствуют тому, что я описываю, но позиционируются во всех исходниках, статьях, исшисах.
600.48 602.04 "Анатолий Кулаков" Они немножко не так.
602.04 606.96 "Анатолий Кулаков" Они немножко позиционируются, что это коллекции, оптимизированные под чтение.
606.96 613.96 "Анатолий Кулаков" А хочется не оптимизированные под чтение, а просто оптимизированные для того, чтобы гарантировать контракт неизменяемости, только читабельности.
613.96 621.68 "Анатолий Кулаков" И соответственно во многих приложениях, которые я сталкивался, мне приходилось самому такие коллекции писать.
621.68 635.40 "Анатолий Кулаков" И у нас в команде есть тоже, то есть была действительно библиотека, которая по чистой случайности, по чистому совпадению тоже называлась Frozen Collection, и там был Frozen Dictionary, Frozen List и так далее.
635.40 638.84 "Анатолий Кулаков" Я когда увидел эти микрософтские названия, чуть не проследился.
638.84 644.12 "Анатолий Кулаков" В общем, и практически вот она попала в то, что делали мы, но у нас немножко уклон в другую сторону был.
644.12 656.12 "Анатолий Кулаков" То есть мы не оптимизировали ее хранение, чтобы она специально хранила оптимизированное под чтение, мы просто давали такой строгий контракт, гарантирующий потребителю, что она будет только читаться, и никто ее никогда не поменяет.
656.12 662.40 "Анатолий Кулаков" Ну и соответственно удобные билдеры делали для того, чтобы это все без лишней локации памяти происходило.
662.40 668.32 "Игорь Лабутин" Ну надо сказать, что здесь с точки зрения контракта тут нет никакого упора на быстрое чтение.
668.32 673.40 "Игорь Лабутин" Быстрое чтение – это просто возможность реализовать вот эти абстрактные классы какой-то очень специальной коллекцией.
673.40 678.84 "Игорь Лабутин" И она быстрая, то есть это не какое-то специализированное хранение.
678.84 687.68 "Игорь Лабутин" Насколько я понимаю, сет все так же может хранить все это в массивчиках или в, ну как у нас, хеш-функция, то есть вопрос как бы как быстро ты будешь считать хеш-функцию.
687.68 714.20 "Игорь Лабутин" Вот, и просто если ты заранее знаешь, какие у тебя элементы в дикшенере, то можно, возможно, собрать более оптимальные, то есть смотри, допустим, создавая дикшенере, где ты знаешь, что ключ – это строка, так, ты можешь не считать, например, хеш-функцию, да, каждый раз от входящего ключа при чтении, а знать, что у тебя все строки, например, отличаются в пятом символе.
714.20 715.20 "Игорь Лабутин" Ну вот так сложилось.
715.20 731.24 "Игорь Лабутин" То есть в момент создания коллекции понять, что у тебя все строки отличаются в пятом символе, это значит, что в момент чтения тебе достаточно просто посмотреть на пятый символ, и ты будешь точно знать, какая это у тебя страна, какой бакет, грубо говоря, какое значение достать.
731.24 737.04 "Игорь Лабутин" Ну естественно, комперисон тебе нужен, чтобы проверить, что это точно тот ключ, а не просто какое-то слово, у которого совпало пятый символ.
737.04 749.76 "Игорь Лабутин" Но вот именно это, я так понимаю, позволяет им потенциально сделать очень быстрые словари, ну потому что если не нужно считать хэш, да, а просто взять какой-то символ или пару символов из строки, это прям будет, ух, круто.
749.76 769.84 "Анатолий Кулаков" Да, кстати, этот алгоритм часто в Microsoft применяется, мы обсуждали его уже, когда обсуждали Kestrel, такие штуки, например, когда хедеры, которые приходят в реквесте, они все с известными именами, то есть для Kestrel четкие понятные имена, которые он умеет обрабатывать, и там он сравнивает именно по вот такому алгоритму.
769.84 785.04 "Анатолий Кулаков" Ну и в тобой приведенном примере кажется, что, например, роуты - прекрасная вещь, которая один раз на поднятие приложения заполняется дикшенами с роутами, то есть ключ какой роут, и там делегат от минимума API, который нужно вызвать, допустим.
785.04 792.52 "Анатолий Кулаков" И действительно он редко, скорее всего, даже никогда не меняется в процессе жизни приложения, и там такие структуры вполне хорошо себя должны показать.
792.52 808.24 "Игорь Лабутин" Ну, в общем, до Net8 начинается прямо интересно, мне кажется, что я не помню ничего такого, чтобы еще до первого превью мы что-нибудь так детально обсуждали уже про новый дотнет, но ничего, посмотрим, что будет дальше.
808.24 811.76 "Игорь Лабутин" Давай пойдем дальше, следующая статья у нас пока все еще про семерку.
811.76 822.56 "Анатолий Кулаков" Ну да, да, про восьмерки еще мало новостей, но зато семерку мы еще до конца не распарсили, не разобрали, я думаю, еще много по ней статьи будет выходить, чему мы несказанно рады.
822.56 829.24 "Анатолий Кулаков" И сейчас хотелось бы с вами поговорить про улучшение в нетворкинге, которое у нас были в семерке.
829.24 836.36 "Анатолий Кулаков" О многих из них мы уже говорили, но вот эта статья, она тоже так немножко начинает подводить какие-то итоги, что было важного, что было интересного.
836.36 844.36 "Анатолий Кулаков" Давайте же посмотрим, что там с точки зрения авторов стоит упомянуть или еще раз повторить об Network Improvement, которые у нас были в dotnet 7.
844.36 854.92 "Анатолий Кулаков" Итак, прежде всего улучшилась оптимизация, которая позволяет устанавливать быстрее HTTP-коннекции, соответственно, TCP-коннекции.
854.92 863.92 "Анатолий Кулаков" И заключается она в таком маленьком хаке, как когда у вас приложение хочет создать новую коннекцию, естественно, оно первым делом идет искать ее в пуле.
863.92 872.36 "Анатолий Кулаков" Потому что создание коннекции, особенно если там у нас будет какое-нибудь шифрование, особенно если будет какой-нибудь обмен ключами, это довольно дорогостоящая операция.
872.36 873.92 "Анатолий Кулаков" И просто так ее не делают.
873.92 878.36 "Анатолий Кулаков" Поэтому ищется прежде всего в пуле уже готовая, горяченькая, свеженькая, коннекция уже разогретая.
878.36 889.28 "Анатолий Кулаков" И если вдруг ее там не нашлось, то уже начинается весь вот этот нудный процесс по конфигурации, по создании, по установке соединений, обмена сертификатами и прочее, прочее.
889.28 895.32 "Анатолий Кулаков" И вот в старом алгоритме работало все следующим образом.
895.32 902.16 "Анатолий Кулаков" Когда ваш реквест не находит в пуле коннекции, он идет это все дело долго-долго конфигурировать.
902.16 913.88 "Анатолий Кулаков" И даже если в момент конфигурации уже в пул пришла какая-нибудь коннекция, которую можно переиспользовать и которая уже готова к тому, чтобы ее переюзать, вот этот ваш реквест, он продолжает ждать.
913.88 917.76 "Анатолий Кулаков" Он продолжает ждать свою коннекцию, которую он сейчас конфигурирует.
917.76 927.40 "Анатолий Кулаков" Ну, не ждет, естественно, он ее там конфигурирует и активно участвует в этом процессе, но он бы вполне мог сейчас взять из пула в данный момент какую-нибудь готовую коннекцию и пойти ее использовать.
927.40 929.28 "Анатолий Кулаков" В общем, он этого не делал.
929.28 930.28 "Анатолий Кулаков" И начиная с дот.
930.28 931.84 "Анатолий Кулаков" недель шестого он начал так делать.
931.84 937.80 "Анатолий Кулаков" То есть он берет ту коннекцию, которая впервые появилась, или новая конфигуренная, или старая, которая вернулась в пул.
937.80 953.68 "Анатолий Кулаков" Но были проблемы с тем, что если вдруг он взял коннекцию из пула и в этот момент деконфигурировалась его коннекция, которую он новую создавал, вот эта деконфигуренная коннекция, она никуда не девалась.
953.68 960.20 "Анатолий Кулаков" Она просто-напросто пропадала, и по сути все ресурсы, которые были потрачены на ее обновление, на ее настройку, были потрачены зря.
960.20 961.20 "Анатолий Кулаков" В общем, в седьмом дот.
961.20 969.32 "Анатолий Кулаков" недель сделали, что теперь та в бэкграунде деконфигуренная, которая даже никому не нужна, она забрасывается в пул в надежде на то, что кому-нибудь пригодится.
969.32 974.40 "Анатолий Кулаков" Такая интересная оптимизация, которая тоже показала какие-то приросты на бичмарках.
974.40 986.16 "Анатолий Кулаков" Дальше оптимизацией, а точнее более сложные правила, коснулись HTTP-хедеров.
986.16 990.56 "Анатолий Кулаков" Наверное, мало кто задумывался, но коллекцией HTTP-хедеров никогда не была ThreadSafe.
990.56 996.80 "Анатолий Кулаков" То есть к ней нельзя доступаться из нескольких потоков на чтение на запись.
996.80 1000.32 "Анатолий Кулаков" И все потому, что она внутри себя использует отложенный парсинг.
1000.32 1005.80 "Анатолий Кулаков" То есть хедеры все парсят не тогда, когда ее создали, а тогда, когда они понадобились.
1005.80 1016.32 "Анатолий Кулаков" Потому что в большинстве случаев какие-нибудь сложные хедеры, к которым редко кто обращается, их и парсить не нужно, они никому не нужны.
1016.32 1018.32 "Анатолий Кулаков" Вот там поэтому встроен лэзи парсинг.
1018.32 1025.44 "Анатолий Кулаков" И дот.нет седьмой он сделал интерфейс более интуитивный, он сделал интерфейс более предсказуемый.
1025.44 1032.88 "Анатолий Кулаков" Теперь HTTP-хедер коллекция она строго декларирует, что у нее уровень доступа параллельности такой же, точно как и у дикшнере.
1032.88 1035.32 "Анатолий Кулаков" Что это значит?
1035.32 1044.56 "Анатолий Кулаков" Это значит, что несколько ридеров могут вполне параллельно ее читать до тех пор, пока она не модифицируется.
1044.56 1054.24 "Анатолий Кулаков" Если же мы хотим доступ на то, чтобы несколько ридеров ее читали и какие-то врайтеры туда писали, то мы должны сами гарантировать объект синхронизации.
1054.24 1060.52 "Анатолий Кулаков" То есть мы должны сами сделать какой-нибудь или лог, или что-нибудь в этом духе при доступе к этому HTTP-хедерцу.
1060.52 1071.80 "Анатолий Кулаков" В общем, такие гарантии должны были всегда, но раньше в некоторых методах данной коллекции это не поддерживалось.
1071.80 1084.68 "Анатолий Кулаков" И теперь у нас более четкая декларация, теперь она более четко показывает, что раз она дикшнере, значит она соответствует тем же самым уровням безопасности, которые есть у дикшнере.
1084.68 1091.36 "Анатолий Кулаков" Небольшие расширения коснулись у нас ошибок, которые возможны при HTTP/2, HTTP/3.
1091.36 1102.28 "Анатолий Кулаков" Дело в том, что протокол HTTP/2, HTTP/3 на очень низком уровне умеет обмениваться всякими эррор-кодами, если вдруг что-то пошло не так.
1102.28 1112.44 "Анатолий Кулаков" И в большинстве случаев нашим HTTP-клиентам, нашим HTTP-кестрелам, сервисам и так далее, вот эта лоу-левел информация об ошибках, она не нужна.
1112.44 1119.12 "Анатолий Кулаков" Поэтому разработчики изначально не вытаскивали ее наружу и найти ее никаким образом было практически невозможно.
1119.12 1137.12 "Анатолий Кулаков" Но узким клиентам, которые работали поверх этим протоколом и пытались оптимально выжать максимальную телепроизводительность или другие какие-то продвинутые сценарии использовали, например, gRPC.net, им вот эта мелкая информация о низкоуровневых ошибках, она была очень важна.
1137.12 1150.84 "Анатолий Кулаков" И теперь в фрейм-роке сделали новое исключение, которое называется HTTP Protocol Exception, в котором есть информация о низкоуровневых ошибках и в котором можно посмотреть в эррор-коде, что же там на самом деле происходило.
1150.84 1155.48 "Анатолий Кулаков" HTTP/3 тоже коснулись большие изменения.
1155.48 1157.32 "Анатолий Кулаков" Он теперь включен по дефолту.
1157.32 1160.64 "Анатолий Кулаков" Раньше он был только доступен по определенному фичи-флагу.
1160.64 1166.08 "Анатолий Кулаков" По дефолту это не значит, что теперь все ваши сообщения между клиентом и сервером будут работать по HTTP/3.
1166.08 1176.20 "Анатолий Кулаков" Это значит, что если вдруг клиент запросил, а сервер поддержал, то они могут повысить свой уровень общения, то есть повысить до протокола HTTP/3.
1176.20 1185.52 "Анатолий Кулаков" В общем, это теперь включено по дефолту, и если вдруг у вас такие клиенты наглые есть, то вполне можно такую… то есть не можно, такая трансформация, такой апгрейд он будет совершен.
1185.52 1190.96 "Анатолий Кулаков" Так, теперь немножко про улучшения в Квике.
1190.96 1196.08 "Анатолий Кулаков" Квик, я напомню, это новый низкоуровневый транспортный протокол.
1196.08 1202.24 "Анатолий Кулаков" Он отличается тем, что использует UDP как основной транспорт, и у него сразу встроенная поддержка TLS.
1202.24 1212.56 "Анатолий Кулаков" У него есть мультиплексинг, это означает, что несколько параллельных и независимых потоков данных он может обрабатывать, которые никак не влияют друг на друга.
1212.56 1230.44 "Анатолий Кулаков" Квик был заимплеменчен еще в Дотнет 5, но там он был чисто internal, то есть использовались наверх уже более высокоуровневые абстракции, то есть какие-то высокоуровневые протоколы, которые работали на нем, но разработчики доступ к самому низкоуровневому Квику не могли использовать.
1230.44 1233.12 "Анатолий Кулаков" И в Дотнет 7 наконец-то его сделали публичным.
1233.12 1241.68 "Анатолий Кулаков" Сделали публичный API, сделали публичный классик, и теперь с ним работать можно каждому, кто захочет реализовать свой собственный протокол.
1241.68 1251.24 "Анатолий Кулаков" Если мы говорим про кроссплатформенность, то Квик на каждой платформе использует свою имплементацию.
1251.24 1258.56 "Анатолий Кулаков" На Linux он использует libsquick, который нужно ручками устанавливать, если вы вдруг такую вещь сделаете.
1258.56 1260.72 "Анатолий Кулаков" И на Windows он использует msquick.
1260.72 1266.96 "Анатолий Кулаков" Это нативная библиотека для Windows, которая тоже там распространяется с Windows, скорее всего.
1266.96 1271.40 "Анатолий Кулаков" Все основные классики находятся в Namespace, которая называется system.net.quick.
1271.40 1280.96 "Анатолий Кулаков" И как я уже сказал, это низкоуровневый протокол, который создан в основном для того, чтобы на нем настраивались какие-то свои собственные высокоуровневые протоколы.
1280.96 1288.00 "Анатолий Кулаков" И для того, чтобы настраивать свои высокоуровневые протоколы, Microsoft предоставил несколько классов, самые базовые, основные из них три.
1288.00 1291.48 "Анатолий Кулаков" Это QuickListener, класс, который принимает входящее соединение.
1291.48 1299.12 "Анатолий Кулаков" Это QuickConnection, соответственно, абстракция над непосредственно самим сеансом, который происходит между клиентом и сервером.
1299.12 1307.20 "Анатолий Кулаков" И QuickStream, то есть это абстракция над потоками, которые могут, как я уже сказал, в несколько независимых потоков принимать и отдавать данные.
1307.20 1322.04 "Анатолий Кулаков" Так как не каждая система, не каждая платформа, не каждая еще framework поддерживает QUIC, у него есть хорошее свойство, которое называется isSupported у QuickListener и QuickConnection, которое нужно обязательно проверять, если вы вдруг хотите реализовать какие-то свои собственные протоколы.
1322.04 1329.32 "Анатолий Кулаков" Изменения также коснулись интересной темы про security, это Negotiation IP.
1329.32 1333.04 "Анатолий Кулаков" Наверное, многие из вас сталкивались с таким понятием, что это называется аутентификация.
1333.04 1341.72 "Анатолий Кулаков" Это очень полезная технология и очень сложная, которая позволяет вам аутентифицировать юзеров где-нибудь в одном месте.
1341.72 1365.92 "Анатолий Кулаков" Обычно это контроллер домена, то есть у вас есть какие-то доменные пользователи, какой-нибудь Active Directory, и пользователи уже в ваше приложение не должны вводить свой пароль и свое имя, а просто, обратившись к контроллеру домена и подтвердив, что сейчас в текущей операционной системе Windows залогинен именно тот самый пользователь, и если приложение этому контроллеру домена доверяет, оно может точно так же пустить этого пользователя в ваше приложение.
1365.92 1370.32 "Анатолий Кулаков" Очень удобная технология, часто используется, но у нее есть небольшие проблемы.
1370.32 1371.68 "Анатолий Кулаков" Как я уже сказал, она очень сложная.
1371.68 1382.64 "Анатолий Кулаков" У нее под компотом куча страшных алгоритмов, библиотек используется, протоколов и прочее, такие как Kerberos, NTLM, Negotiation Protocol и прочее.
1382.64 1407.20 "Анатолий Кулаков" И в высокоуровневых клиентах, такие как HTTP Client, SMTP Client, Negotiation Stream, SQL Server Client, то есть уже непосредственно тот, чем программисты пользуются, там Microsoft сделал все необходимые низкоуровневые операции для того, чтобы Windows Authentication прекрасно поддерживалась и общение с контроллером домена не доставляло вам вообще никаких проблем, вы о нем даже не задумываетесь в большинстве случаев.
1407.20 1421.36 "Анатолий Кулаков" Но если мы возьмем сторонние библиотеки, такие как библиотека для Postgres, например, для доступа к Postgres, MailKit, Apache Boot, вот там разработчикам приходилось городить свои собственные костыли.
1421.36 1433.04 "Анатолий Кулаков" Ну или вообще отказываться от этой идеи, или костылить что-то, что на низкоуровневом, на низкоуровневом каком-то алгоритме пыталось изобразить Windows Authentication.
1433.04 1437.68 "Анатолий Кулаков" Это, соответственно, для многих библиотек было препятствием.
1437.68 1445.68 "Анатолий Кулаков" То есть многие библиотеки просто отказывались реализовать такие вещи, потому что это сложно отлаживать, сложно поддерживать и вообще неизвестно, когда-то Microsoft что поменяет.
1445.68 1451.76 "Анатолий Кулаков" То есть в этот тяжелый путь пускались только действительно большие и крупные библиотеки.
1451.76 1454.48 "Анатолий Кулаков" И вот .NET 7 решил поменять эту ситуацию.
1454.48 1463.68 "Анатолий Кулаков" И в .NET 7 было введено новые low-level блоки для построения как раз-таки вот этой нативной централизованной аутентификации.
1463.68 1475.12 "Анатолий Кулаков" Естественно, эти блоки очень сильно зависят от операционной системы, так как у нас .NET кросс-платформенный, сразу все проектировалось для того, чтобы быть кросс-платформенным.
1475.12 1480.84 "Анатолий Кулаков" Поэтому под Windows используется низкоуровневая библиотека SSPI, а под Linux используется GSS API.
1480.84 1489.12 "Анатолий Кулаков" Под Linux, под Mac, под iOS, кто там поддерживает централизованные домены, если он есть, то такие библиотеки используются.
1489.12 1500.28 "Анатолий Кулаков" Если же это какой-нибудь Android или еще что-то в этом духе, у которого нет централизованного контроллера домена, то там только реализовать вручную какой-то ваш собственный протокол.
1500.28 1502.72 "Анатолий Кулаков" Естественно, Microsoft на стандартном уровне это поддержать не может.
1502.72 1521.00 "Анатолий Кулаков" Но то, что уже появились какие-то низкоуровневые блоки, с которых это можно все построить, это уже дает большую надежду на то, что будущие какие-то клиенты, будущие какие-нибудь протоколы уже будут более тесно интегрироваться с контроллером домена, и мы получим более комфортную для пользователя систему, в которой не нужно будет лишний раз вводить пароли.
1521.00 1526.36 "Анатолий Кулаков" WebSocket Handshake тоже был улучшен.
1526.36 1529.36 "Анатолий Кулаков" Там ситуация похожа на ту, что я описывал ранее.
1529.36 1539.16 "Анатолий Кулаков" Немножко не хватало в WebSocket внутренних скрытых всяких сообщений о том, каким образом это соединение было установлено, каким образом произошел Handshake.
1539.16 1547.80 "Анатолий Кулаков" Это в данном случае было важно как и для ошибок, так и для какого-то успешного применения, для того, чтобы включать какие-то более умные оптимизации.
1547.80 1566.68 "Анатолий Кулаков" И соответственно в .NET 7 была добавлена коллекция HTTP Response Details, которую можно включить в Client WebSocket Options, что позволяет после установки соединения уже понять, каким образом, с какими флагами Client WebSocket был установлен или наоборот не был установлен и почему.
1566.68 1568.92 "Анатолий Кулаков" То есть более детально разобраться в этих проблемах.
1568.92 1572.56 "Анатолий Кулаков" В общем тоже для отладки мега полезная вещь, наверное будет использоваться.
1572.56 1577.36 "Игорь Лабутин" Ну отлично, мне кажется, summary всего того, что произошло в нетворкинге.
1577.36 1586.28 "Игорь Лабутин" Мы это так или иначе затракивали в разных выпусках более ранних по мере того, как это выходило, но вот теперь будет еще место, где все это вместе собрано воедино.
1586.28 1590.60 "Игорь Лабутин" Если вам вдруг нужно будет вспомнить, что же сделали в 7 .NET про нетворкинг.
1590.60 1592.08 "Игорь Лабутин" А мы пойдем дальше.
1592.08 1595.52 "Игорь Лабутин" И дальше у нас Maoni и Garbage Collector.
1595.52 1607.32 "Игорь Лабутин" Давно у нас не было темы статьи от Maoni, тут она в очередной раз выпустила новенькую, про то, как же на самом деле понимать виноват ли Garbage Collector в том, что у вас все плохо.
1607.32 1622.32 "Игорь Лабутин" Ситуация следующая, вы берете ваш продукт, он работает на 6 .NET, вы обновляетесь на 7 .NET и у вас начинает ваш продукт кушать больше памяти или больше процессора нового времени GC или GC паузы становятся очень большими.
1622.32 1624.52 "Игорь Лабутин" И конечно же во всем виноват кто?
1624.52 1625.52 "Игорь Лабутин" Правильно, GC.
1625.52 1626.52 "Игорь Лабутин" Говорите вы.
1626.52 1629.88 "Игорь Лабутин" Опять Microsoft что-то там придумал не то.
1629.88 1641.84 "Игорь Лабутин" Но на самом деле, на самом деле, получается так, что ваш код вообще говоря зависит не только от GC, он зависит еще от всего рантайма, там это и JIT, и Interop, и все такое прочее.
1641.84 1644.04 "Игорь Лабутин" И еще от UCL от Base Class Library.
1644.04 1648.44 "Игорь Лабутин" И еще он зависит от кучи всяких разных других библиотек типа SP.NET.
1648.44 1655.36 "Игорь Лабутин" И поэтому, конечно же, когда вы обновляетесь с 6 .NET на 7, вы обновляете не только GC, вы обновляете вообще все вокруг.
1655.36 1662.00 "Игорь Лабутин" И тот факт, что ваш код вдруг, ваш продукт, ваше приложение стало внезапно кушать больше памяти еще ни о чем не говорит.
1662.00 1665.36 "Игорь Лабутин" Возможно кушать больше памяти стало SP или еще кто-то.
1665.36 1673.56 "Игорь Лабутин" Или вы используете такие паттерны или такие например какие-нибудь коллекции, которые почему-то в новом .NET стали кушать больше памяти именно с таким паттерном использования.
1673.56 1675.20 "Игорь Лабутин" Поэтому не все так просто.
1675.20 1682.12 "Игорь Лабутин" Но тем не менее, надо было, GC является одной из самых довольно сложных частей, можно сказать.
1682.12 1686.12 "Игорь Лабутин" Хотя наверное авторы JITA и других мест поспорят со мной.
1686.12 1688.64 "Игорь Лабутин" Но тем не менее, GC действительно довольно сложная штука.
1688.64 1701.84 "Игорь Лабутин" И для того, чтобы было проще анализировать, а что же там поменялось, точнее, повлияло ли GC на ваше приложение после того, как вы переползли на новый 7 .NET, есть теперь механизм.
1701.84 1718.72 "Игорь Лабутин" Теперь вместе с 7 .NET поставляется файлик под названием CLR_GC.dll, в котором на самом деле собран garbage collector из 6 .NET, то есть старая реализация на сегментах, а не новая на регионах.
1718.72 1721.96 "Игорь Лабутин" И алгоритм теперь действует такой.
1721.96 1732.80 "Игорь Лабутин" Если вы берете ваш продукт, ваше приложение, обновляетесь с 6 на 7 .NET, то есть ставите новый рентайм, собираете ваше приложение, новое МСДК, вот это все, запускаете кушать ног памяти.
1732.80 1737.76 "Игорь Лабутин" Берете, ну или там паузы в garbage collector или еще что-нибудь в таком духе.
1737.76 1753.28 "Игорь Лабутин" Берете, ставите переменное окружение .NET подчеркиваю GC_NAME в значение CLR_GC.dll, на самом деле туда можно указать любую .DLL, которая будет реализовывать нужные интерфейсы, и запускаете ваше приложение.
1753.28 1760.76 "Игорь Лабутин" Можно еще это сделать через RentimeConfig, тоже можно JSON-чик написать, который скажет поставьте эту опцию и загрузите нужные GC.
1760.76 1768.48 "Игорь Лабутин" В результате у вас запустится ваше приложение, которое будет использовать полностью седьмерку .NET, кроме garbage collector, которая будет взята с шестерки.
1768.48 1776.16 "Игорь Лабутин" В результате у вас может появиться три, так сказать, поведения, проявится три поведения вашего приложения.
1776.16 1782.48 "Игорь Лабутин" Во-первых, вся проблема с памятью куда-нибудь денутся и станет все по-старому, как было в шестерке.
1782.48 1787.64 "Игорь Лабутин" Значит, ну точно виноват garbage collector, срочно бегите создавать иши в GitHub.
1787.64 1794.28 "Игорь Лабутин" Возможно, ваше поведение не изменится и поведение приложения будет ровно таким же, как с дефолтным garbage collector в семерке.
1794.28 1798.12 "Игорь Лабутин" Это значит, что garbage collector не виновата вообще, а виновата что-то еще.
1798.12 1802.16 "Игорь Лабутин" Нужно выяснять, собственно, почему стала больше памяти и профилировать вот это все.
1802.16 1810.96 "Игорь Лабутин" Ну и может быть, например, там что-то частично уйдет, там какие-нибудь паузы станут в два раза поменьше, но не идеально такими же, как были в шестерке, ну и так далее.
1810.96 1837.16 "Игорь Лабутин" В первом и в третьем случае, то есть если у вас после замены garbage collector поменялось поведение, моя они рекомендуют в любом случае создать иши на GitHub в runtime репозитории, собрать информацию про garbage collector и CPU, там в статье есть линки, как это сделать, на инструкции на GitHub, и посмотреть, что скажет команда.
1837.16 1858.16 "Игорь Лабутин" Вообще говоря, вся эта работа для стендалового garbage collector была начата довольно давно, то есть он в том или ином виде потихонечку появлялся еще, начиная с dotnet core 2, но вот в нормальной версии он вошел только сейчас полноценно, когда уже сам Microsoft поставляет абсолютно отдельный garbage collector.
1858.16 1885.68 "Игорь Лабутин" Как я сказал, туда можно подключить на самом деле любую DLL, это понятно, что это C++ код, и там реализуются два комовских интерфейса, один, соответственно, вам предоставляется рантаймом, и это то, как garbage collector может тернуть рантайм, например, сказать "останови все потоки" или "запусти обратно все потоки" или "дай мне все руты на стеках потоков", то есть такие хелперные функции, так скажем, для того, чтобы garbage collector просто мог работать.
1885.68 1897.52 "Игорь Лабутин" А сама DLL в свою очередь должна предоставлять реализацию некоторого интерфейса, который, наоборот, рантайм ждет от garbage collector, с точки зрения того, что там нужно делать.
1897.52 1917.88 "Игорь Лабутин" Причем Microsoft не пишет, что не нужно на самом деле реализовать вообще все методы, там нужно реализовать только, так скажем, те, которые нужны для вашего сценария, поэтому если вы хотите написать свой собственный garbage collector, то теперь вот он вообще отдельный, с отлично специфицированными методами, интерфейсами, так что можно написать свой.
1917.88 1950.92 "Игорь Лабутин" И эта же штука была забекпорчена в .NET Framework 4.8, поэтому на 4.8 тоже можно технически подменять garbage collector, там понятно, подсовывать туда какой-нибудь шестой, наверное, смысла нет, возможно, там все не заведется, по крайней мере, Мауни про такое не пишет, но это удобная штука, которая позволяет команде Microsoft на самом деле подсовывать всякие специальные сборки garbage collector, то есть с каким-нибудь инструментированием или еще чем-то, если есть какие-то проблемы у заказчиков, наверное, для конечных потребителей нас с вами.
1950.92 1963.36 "Игорь Лабутин" Тот факт, что это все есть в .NET Framework и не так важно, ну а в .NET 7 это прям удобно, если вы вдруг действительно видите на вашем продукте какой-то регресс, по памяти подсуньте туда шестой garbage collector и посмотрите, что получится.
1963.36 1968.52 "Анатолий Кулаков" Интересно, зачем они все-таки откапывают стюардессу и тащат все в 4.8?
1968.52 1970.44 "Анатолий Кулаков" Что они там такого нашли?
1970.44 1982.48 "Игорь Лабутин" Я думаю, что заказчики, заказчики, то есть у них наверняка есть еще много заказчиков, которые живут на полном фреймворке и скорее всего им таким образом просто проще у них диагностику проводить, чем собирать кастомную версию фреймворка.
1982.48 2016.52 "Игорь Лабутин" Там еще в чем проблема, фреймворк же, он же ставится один раз на всю машину, то есть в современном .NET ты можешь просто взять, подменить длинку у себя в проекте, ну через переменные окружения, в смысле, и только в одном приложении будет работать свой собственный garbage collector, а в системе большой, новой новинде, когда ты подменяешь длинку в .NET Framework, все, у тебя все .NET приложения тут же начинают использовать твою, не знаю, специальную версию garbage collector с, не знаю, экстра-диагностикой, которая в ETV-шке там шлет огромное количество диагностических данных.
2016.52 2025.20 "Игорь Лабутин" Ну и ты потом сиди разбирай, кто там что назасылал из всего, ну из всех приложений на Винде, или если это сервер там, сколько чего там крутится.
2025.20 2032.20 "Игорь Лабутин" А так тебе есть возможность теперь подсовывать прям какие-то диагностические штуки, прям очень узко направленные для одного приложения.
2032.20 2035.32 "Анатолий Кулаков" Видимо для этого… Ну да, да, хорошая вещь.
2035.32 2044.52 "Анатолий Кулаков" Нам нужно по идее какая-нибудь стратегика или докладик, который глубоко копнет в эту штуку и научит нас правильные такие диагностики проводить, если вдруг они кому-то понадобятся.
2044.52 2068.60 "Игорь Лабутин" Ну может и появятся, потому что это… Маони в статье говорит, что это типа степ-один, то есть я подозреваю, что у нее еще есть в планах дальнейшее улучшение и упрощение всего этого дела, так что я думаю, что будем следить, что происходит в 8 .NET, и может быть к концу релиза 8 .NET, к следующему ноябрю, у нас появятся какие-нибудь еще интересные тулы для диагностики, или методы, или алгоритмы, не знаю, что-нибудь.
2068.60 2074.12 "Анатолий Кулаков" Отлично, и я надеюсь, что эти тулы будут встроены в наши ДЕшки, то есть время поговорить про ДЕшки.
2074.12 2081.04 "Анатолий Кулаков" У нас как раз в Visual Studio завезли довольно интересную штуку, давай про нее и поговорим.
2081.04 2086.76 "Анатолий Кулаков" Я хочу поговорить о DevTunnels, которые завезли в Visual Studio.
2086.76 2091.72 "Анатолий Кулаков" Итак, давайте подробнее рассмотрим, что это за зверь, как его едят и зачем он нужен.
2091.72 2100.28 "Анатолий Кулаков" Дело в том, что иногда нам требуется странного, нам нужно соединить две машины, которые находятся не на одном компьютере и может быть даже не в одной сети, а допустим вообще в разных сетях.
2100.28 2125.88 "Анатолий Кулаков" И сделать нам это хочется не после того, как мы опубликуем на свое серверное приложение куда-нибудь, на какой-нибудь публичный хост, куда к нему может кто-то стучаться, а прямо в Visual Studio, прямо под дебагом, для того, чтобы пройтись отладчиком, собрать диагностику, собрать какие-то метрики и сделать что-нибудь еще такое, чего обычно мы не делаем после того, как публикуем на публичные сервисы.
2125.88 2134.80 "Анатолий Кулаков" То есть, туннели помогают нам соединить две машины, которые не могут в обычной жизни друг к другу достучаться по тем или иным причинам.
2134.80 2141.32 "Анатолий Кулаков" Также возможно, вам вот эти туннели, они известны под другими именами, например, Port Forwarding или Web Tunneling.
2141.32 2146.16 "Анатолий Кулаков" Но вот Microsoft использует именно такой термин.
2146.16 2148.04 "Анатолий Кулаков" Например, когда вам это может быть нужно?
2148.04 2149.36 "Анатолий Кулаков" Ну, прежде всего это веб-хуки.
2149.36 2164.84 "Анатолий Кулаков" Допустим, у вас есть какой-то внешний сервис, тот же самый GitHub, и он вам хочет послать какой-то веб-хук о том, что у него произошел какой-то ивент, и он хочет вам об этом сообщить, и естественно ему для этого нужен какой-то публичный URL, который всегда доступен и который он сможет отправить этот запрос.
2164.84 2172.72 "Анатолий Кулаков" А вы хотите обработчик своего URL написать, вы хотите обработчик этого хука написать, и хотите его отладить под Visual Studio.
2172.72 2178.44 "Анатолий Кулаков" Естественно, отладить вы его хотите локально, то есть никакого внешнего публичного URL у вас по определению быть не может.
2178.44 2182.16 "Анатолий Кулаков" Вот в этом случае вам помогут как раз DevTunnel.
2182.16 2191.96 "Анатолий Кулаков" Другой типичный пример – это когда вы подцепляете какой-нибудь внешний девайс, какой-нибудь телефончик, сканер или что-нибудь посложнее, там 3D-принтер, еще что-то.
2191.96 2204.68 "Анатолий Кулаков" То есть какой-то девайс, которому тоже нужен какой-то внешний URL для того, чтобы общаться с каким-нибудь контрольным центром, но этот контрольный центр еще не запаблишен на внешний URL, вы его просто хотите отладить.
2204.68 2209.84 "Анатолий Кулаков" Запустите, посмотрите под отладщиком, а что же конкретно приходит и посмотреть непосредственно протокол.
2209.84 2211.48 "Анатолий Кулаков" Как же эта штука работает?
2211.48 2220.36 "Анатолий Кулаков" Если вы раньше работали с ngrok, или может быть слышали наш подкаст, когда мы рассказывали про работу ngrok, то это именно оно.
2220.36 2223.12 "Анатолий Кулаков" Это просто ngrok, изобретенный Microsoft.
2223.12 2225.80 "Анатолий Кулаков" Если же вы не слышали, то слушайте.
2225.80 2234.16 "Анатолий Кулаков" Прежде всего используется какой-нибудь третий узел, третий удаленный хост, который на себя берет функции проксирования.
2234.16 2241.36 "Анатолий Кулаков" То есть он генерирует вам уникальный магический URL, на который сможет прийти тот же самый webhook.
2241.36 2245.00 "Анатолий Кулаков" Этот URL будет публично доступен любому сервису в интернете.
2245.00 2248.56 "Анатолий Кулаков" И webhook уже сможет на этот уникальный URL зайти.
2248.56 2254.56 "Анатолий Кулаков" При этом этот URL проксирует абсолютно все запросы, которые к нему приходят, на вашу Visual Studio.
2254.56 2267.20 "Анатолий Кулаков" Ваша Visual Studio, запущенная под отладщиком, все те запросы, которые она получила от ngrok, делает вид, как будто они пришли к вам напрямую на локальном хосте, прямо в отладчик.
2267.20 2282.12 "Анатолий Кулаков" То есть на типичном примере, если вы вдруг запустите под DevTunnels вашу Visual Studio и откроете привычный свагер, вы увидите там не localhost в URL, а вы увидите там специальный адрес, который называется devtunnels.ms.
2282.12 2288.16 "Анатолий Кулаков" То есть это специальный хост от Microsoft, который служит только для того, чтобы перебрасывать вот такие вот запросы.
2288.16 2294.56 "Анатолий Кулаков" С магическим адресом и который, соответственно, получит вам все запросы в вашу локальную запущенную студию.
2294.56 2295.56 "Анатолий Кулаков" Вот в принципе и вся магия.
2295.56 2298.64 "Анатолий Кулаков" Ее очень легко включить.
2298.64 2313.76 "Анатолий Кулаков" Для этого вам нужно перейти в настройки Visual Studio, найти секцию Preview Features и там, так это фича еще в превью, она еще не зарелизлена, и там поставить галочку на противчик бокса Enable DevTunnels for Web Applications.
2313.76 2318.40 "Анатолий Кулаков" С этих самых пор у вас в меню запуска появится два интересных пункта.
2318.40 2322.76 "Анатолий Кулаков" Это выбрать активный туннель и создать новый туннель.
2322.76 2327.64 "Анатолий Кулаков" Для того, чтобы создать новый туннель, вам понадобится аккаунт, который использует Visual Studio.
2327.64 2333.12 "Анатолий Кулаков" То есть вы должны быть за логины в Microsoft Visual Studio аккаунт.
2333.12 2336.52 "Анатолий Кулаков" Без логина у вас ничего не получится.
2336.52 2339.56 "Анатолий Кулаков" Также вам нужно определиться с типом туннеля, который вы создаете.
2339.56 2341.08 "Анатолий Кулаков" Есть два типа.
2341.08 2343.08 "Анатолий Кулаков" Во-первых, это Persistent туннель.
2343.08 2347.20 "Анатолий Кулаков" Он использует один и тот же URL как можно дольше.
2347.20 2351.92 "Анатолий Кулаков" Он этот URL держит и между перезапусками приложения, между перезапусками студии.
2351.92 2362.52 "Анатолий Кулаков" Там есть примеры, когда этот URL может все-таки смениться или протухнуть, но создатели утверждают, что они такие случаи пытаются сильно-сильно минимизировать.
2362.52 2372.16 "Анатолий Кулаков" Как раз таки, если мы говорим про какие-то веб-хуки, где URL должен жить долго, может быть там дни, недели, месяцы, и он должен быть стабильным, то это ваш выбор.
2372.16 2376.84 "Анатолий Кулаков" Второй вариант - это временный тип туннелей.
2376.84 2381.00 "Анатолий Кулаков" У него URL генерится каждый раз новым, как только перезапускается Visual Studio.
2381.00 2390.00 "Анатолий Кулаков" То есть Visual Studio запустили, отладили, и в принципе он вам больше не нужен, и при следующем запуске вам все равно какой там будет URL, вы его снова запустите, отладите.
2390.00 2399.44 "Анатолий Кулаков" В общем, это позволяет не тратить лишний раз Persistent URL, а иметь более гибкий, более свободный режим.
2399.44 2404.00 "Анатолий Кулаков" И последняя конфигурация, которая вам нужна для создания туннеля, вы должны определиться с уровнем доступа.
2404.00 2410.24 "Анатолий Кулаков" Уровнем доступа бывает приватный, то есть к вашему туннелю может обратиться только тот же самый пользователь, который его создал.
2410.24 2416.76 "Анатолий Кулаков" Уровень организации, то есть вы должны быть в одной организации, то есть любой пользователь вашей организации может обратиться к этому туннелю.
2416.76 2422.96 "Анатолий Кулаков" И публичный, это вообще никакой аутентификации не нужно, кто угодно, когда угодно может к этому туннелю обратиться.
2422.96 2429.56 "Анатолий Кулаков" Соответственно, там работает принцип security by obscurity, то есть пока никто не знает, считаем, что нас никто не ломает.
2429.56 2434.00 "Анатолий Кулаков" Как бы для отладки все три способа валидны, все три способа годны.
2434.00 2436.76 "Анатолий Кулаков" В общем, здесь все нормально.
2436.76 2449.52 "Анатолий Кулаков" И с тонкостей хочется заметить, что при запуске Visual Studio, если вдруг у нее настроен туннелинг, она в переменное окружение добавляет специальную переменную - West Tunnel URL, где как раз таки указывает, к какому туннелю нужно ходить.
2449.52 2451.52 "Анатолий Кулаков" Все остальное для вас происходит прозрачно.
2451.52 2466.08 "Анатолий Кулаков" Вот такой удобный механизмик, который может позволить вам отлаживать ваше приложение в каких-нибудь страшных и нестандартных ситуациях, когда вам нужно доступиться до вашего клиента, понимающего только публичные URL и не могущего связаться с вами напрямую.
2466.08 2483.40 "Игорь Лабутин" Да, может быть действительно удобно, либо если вы, например, у вас локально запустили какой-нибудь хитрый, не знаю, ваш продукт, проект, а просите, не знаю, заказчика на вот этом вашем инстансе повторить, что же там у него не работает или еще что-нибудь в таком духе, а вы в этот момент смотрите вместо отладки прода.
2483.40 2484.40 "Анатолий Кулаков" Почему нет?
2484.40 2493.36 "Анатолий Кулаков" Да, действительно, заказчику можно дать от публичной и он увидит весь тот интерфейс, который должен увидеть, а у вас под отладкой все это будет запущено со всякими бряками и все такое.
2493.36 2495.96 "Игорь Лабутин" Главное не подключаться к продакшен базе, без отладчика.
2495.96 2496.96 "Игорь Лабутин" Это точно.
2496.96 2499.96 "Игорь Лабутин" Хотя, если ридонли, почему нет?
2499.96 2502.60 "Игорь Лабутин" Наверное, ну нет, не должно быть у вас доступа к продакшен
2502.60 2505.80 "Анатолий Кулаков" базе. Никто не будет тебе гарантировать, что там этот ридонли и все такое.
2505.80 2506.80 "Анатолий Кулаков" Ну да, да, да.
2506.80 2508.80 "Анатолий Кулаков" Там как повезет, поэтому лучше не надо, не рискуйте.
2508.80 2513.80 "Игорь Лабутин" Хорошо, по TULAM, действительно, у нас есть еще небольшая новость.
2513.80 2516.72 "Игорь Лабутин" Помнишь ли ты, что такое Project TIE?
2516.72 2517.72 "Анатолий Кулаков" Мы его когда-то обозревали.
2517.72 2518.72 "Анатолий Кулаков" Да, конечно.
2518.72 2522.24 "Анатолий Кулаков" Мы его обозревали несколько раз и в релизе, и когда он только появился.
2522.24 2525.92 "Анатолий Кулаков" Довольно интересный проект, но, к сожалению, мало по нему новостей выходит.
2525.92 2526.92 "Анатолий Кулаков" Да.
2526.92 2532.08 "Анатолий Кулаков" В основном его наработки, мне кажется, используются непосредственно в самих EDE или в других инструментах.
2532.08 2535.96 "Анатолий Кулаков" Ну то есть это такой экспериментальный проект, который дает много интересных идей.
2535.96 2537.32 "Игорь Лабутин" Да, действительно, это так.
2537.32 2545.32 "Игорь Лабутин" И тут даже недавно было то ли в Твиттере, то ли где-то тред на тему того, что народ что-то говорил, что типа "Тай, ну что-то подзагнулся, Тай-то как-то что-то не видно".
2545.32 2562.92 "Игорь Лабутин" И там, по-моему, Дэвид Фаулер пришел со словами "Ну да, Тай был экспериментальным проектом, мы на нем обкатывали какие-то идеи, и сейчас он... ну мы не то чтобы его забросили, но мы действительно немножко приостановили, ну притормозили, так скажем, работу и думаем, что с ним делать дальше, грубо говоря".
2562.92 2579.48 "Игорь Лабутин" Ну то есть напомню, что TIE - это штука, которая позволяет написать небольшой ямль файлик конфигурации и после чего запускать различные ваши сервисы вместе, ну типа такой как Docker Compose, только не для Докера, а для просто обычных приложений, назовем это так.
2579.48 2590.88 "Анатолий Кулаков" Причем он понимает как раз-таки и докерные файлы, и обычные CSS-проджи, и по-моему, и обычные DLL-ки, и обычные XH-ники, то есть его можно использовать как Docker Compose, такой только всеядный.
2590.88 2591.88 "Игорь Лабутин" Да-да-да.
2591.88 2592.88 "Игорь Лабутин" Он понимает очень много форматов.
2592.88 2599.00 "Игорь Лабутин" Причем он умеет, если вы укажете там CSS-продж, он будет автоматически собирать в нужных конфигурациях, все можно указать там тегами, короче.
2599.00 2611.84 "Игорь Лабутин" Такая удобная штука, когда нужно запускать коллекцию микросервисов, грубо говоря, локально, какие-то запускаются из Докера, какие-то запускаются из ваших рабочих проектов, какие-то запускаются вообще неизвестно откуда, просто экзешки.
2611.84 2615.76 "Игорь Лабутин" Ну в таком духе, то есть действительно удобная штука, мы пользовались на проекте, вообще прям замечательно работало.
2615.76 2649.16 "Игорь Лабутин" Вторая штука, которую он умеет делать, это деплоймент, то есть он умел деплоить все в Kubernetes в том или ином виде, этим я не пользовался, и вот как раз вокруг этого сейчас, я так понимаю, что у них есть некоторое политическое обсуждение, что делать вообще с этим тулом дальше, оставлять таким как бы только для локальной разработки, либо как-то его модифицировать с точки зрения деплоймента, я особо выше не ходил, но вот по каким-то кусочкам диалогов в Твиттере вроде как вот вокруг этого как-то строится сейчас дискуссия, но я так понимаю, что она внутренняя в Майкрософте и особо снаружи не видна.
2649.16 2675.00 "Игорь Лабутин" Ну вот, тем не менее, тул полезный, пользоваться им можно, и если вы… он на самом деле когда запускается, он генерирует некоторые простенькие веб-интерфейсы, где можно посмотреть в каком состоянии все ваши сервисы, сколько у них реплик, что с ними происходит, живо не живо, сколько там эксепшенов произошло, если они умеют репортить метрики согласно нужному протоколу, то там метрики можно посмотреть, такой мини, в общем, полезный UI, логи почитать.
2675.00 2686.24 "Игорь Лабутин" И теперь у нас есть экстенджер для Visual Studio кода, который нативно интегрируется с этим самым тайм, то есть все ваши сервисы тайские вы будете видеть в эксплорере в Visual Studio кода.
2686.24 2718.80 "Игорь Лабутин" Он, этот экстенджер, умеет подключаться, отлаживать разные сервисы, в том числе используя, ну, то, что мы знаем под .NET Watch, то есть, хот релоуд, ну да, хот релоуд, это все, то есть смотреть за приложенками, что там как-то предупускается, все это отлаживать, мониторить, и можно scaffolding новые таски, если вам нужно еще добавить к вашему тай конфигу еще что-то, можно с помощью этого экстенджера за scaffolding, что вам там нужно.
2718.80 2751.96 "Игорь Лабутин" Так что, если вы пользуетесь тайм, посмотрите на этот экстенджер, я обычно держу, то есть, когда я работаю над продуктом, где у нас используется тай, я держу вкладочку с открытым вот этим вот даже портом, но с ним проблема, что как только тай закрывается, там браузер говорит, ой, все сломалось, значит, ты потом рефрешишь страничку, надо заходить все заново, вот хочу попробовать, может быть, из Visual Studio Code, она все равно более-менее открыта почти всегда, будет удобнее чуть-чуть с помощью этого экстенджера нас мониторить и смотреть, не знаю пока, но вот может пригодиться кому.
2751.96 2761.80 "Анатолий Кулаков" Мне интересно, что они в Visual Studio в основной это не поддержали, то есть, обычно сначала Visual Studio в основной что-то такое интересненькое с плагином появляется, а потом как-то в код переносится, а тут прямо код почему-то первый.
2761.80 2773.68 "Игорь Лабутин" Возможно, из-за того, что туда было проще написать экстенджер, или не знаю, там Madskristen был занят в отпуске на каникулах, не знаю.
2773.68 2776.00 "Игорь Лабутин" 200 других экстенджеров в очереди стояло.
2776.00 2803.08 "Игорь Лабутин" Может быть, они сейчас его обкатают здесь и потом протанут в основную, или наоборот, они, может быть, позиционируют тай больше, как такой, ну, то есть, студия это все-таки больше про .NET в основном, ну, хорошо, все про C++, а тай он такой более межъязыковой что-ли, то есть, может быть, таким образом они пытаются чуть-чуть расширить штуку, что, в принципе, ты можешь тай использовать, не знаю, хоть если ты на питоне пишешь, не знаю зачем, но почему бы нет.
2803.08 2810.32 "Анатолий Кулаков" Не, ну, вообще это удобная штука, то есть, это такой, не знаю, мини-компост, мини-кубер, вот что-нибудь такое для локального запуска.
2810.32 2829.40 "Анатолий Кулаков" Я не удивлюсь, если он многим языкам будет полезен, мне просто казалось, что если бы они захотели так сделать, то они бы сначала поддержали какие-нибудь типы проектов для этих языков, потому что там, например, C++, он поддержан, и SLN, они поддержаны как нативные типы, вот, для что-нибудь такого для питона или для джаваскрипта, мне кажется, там не добавляли.
2829.40 2837.08 "Игорь Лабутин" Не, не добавляли, и для джава не добавляли, ну, прикинь, сюда добавить какой-нибудь там помаксом или для мавина, и он там при запуске будет тебе пересобирать полмира.
2837.08 2838.08 "Игорь Лабутин" Нет, нет, отказать.
2838.08 2841.08 "Игорь Лабутин" И такая же фигня с джаваскриптом, с NPM.
2841.08 2846.00 "Анатолий Кулаков" Наверное, поэтому и не добавляли, докер есть, все, компильте в докер, а там разберемся.
2846.00 2847.00 "Анатолий Кулаков" Ну, типа того.
2847.00 2848.00 "Анатолий Кулаков" Универсальный формат.
2848.00 2849.00 "Анатолий Кулаков" Пойдем дальше.
2849.00 2858.28 "Анатолий Кулаков" У меня здесь есть интересная статейка от Андрю Лока, он нам рассказывает про 5 новых фичей в .NET 7 для MVC.
2858.28 2863.28 "Анатолий Кулаков" Стало интересно, потому что действительно, что же там для MVC такого могли сделать целых 5 штук.
2863.28 2870.68 "Анатолий Кулаков" Оказалось, что не очень, не очень хорошие фичи, там половину натянута за уши, но парочку есть прямо интересных.
2870.68 2881.44 "Анатолий Кулаков" Давайте вспомним, прежде всего первая фича, это добавили IParseable и специальный интерфейс, который реализует статически абстрактные типы, там TriParse и Parse.
2881.44 2888.48 "Анатолий Кулаков" Это прекрасная вещь тем, что она сделала возможностью расширить баннинги в MVC.
2888.48 2897.92 "Анатолий Кулаков" Как наверное вы знаете, в MVC используют модель баннинга для того, чтобы получить данные о том запросе, который пришел к вам непосредственно в контроллер.
2897.92 2905.64 "Анатолий Кулаков" То есть вот этот маппинг между сырым HTTP запросом и теми классиками, которые вы получаете в контроллер, он осуществляется с помощью баннинг провайдеров.
2905.64 2911.28 "Анатолий Кулаков" Эти баннинг провайдеры, они довольно мощные.
2911.28 2920.20 "Анатолий Кулаков" Они например могут вам в методе контроллера, где у вас указаны всякие параметры, они могут эти параметры заполнять из различных мест.
2920.20 2925.36 "Анатолий Кулаков" Например из хедеров, из query, из body, там еще откуда-нибудь.
2925.36 2930.76 "Анатолий Кулаков" Это довольно хитрая, развесистая, хорошая, мощная система.
2930.76 2939.28 "Анатолий Кулаков" Соответственно проблема MVC баннингов заключается в том, что они были написаны довольно давно и довольно редко обновляются.
2939.28 2945.16 "Анатолий Кулаков" Например они очень хорошо работают с простыми типами, такими как decimal, data и время.
2945.16 2947.64 "Анатолий Кулаков" В общем стандартные, встроенные простыми типами.
2947.64 2950.76 "Анатолий Кулаков" Если же тип непростой, то ему нужен type-конвертер.
2950.76 2960.36 "Анатолий Кулаков" Естественно все системные типы type-конвертера реализуют и многие пользовательские классы тоже под этот теорем подстроились и тоже это все дело-дело реализуют.
2960.36 2974.56 "Анатолий Кулаков" И наконец, дотнет 7 хоть как-то размутил вот это болото, они добавили поддержку IParceable от T в вот эту систему баннингов, в баннинг провайдеры.
2974.56 2984.40 "Анатолий Кулаков" Это значит, что теперь вы можете написать свой тип и вместо конвертера пронаследовать его от интерфейса IParceable и реализовать методы try-parse.
2984.40 2997.28 "Анатолий Кулаков" Таким образом вы сможете из url доставать, ну не только из url, а из любого реквеста вы сможете доставать информацию, которая вам нужна и преобразовать ее в ваши сложные типы.
2997.28 3003.56 "Анатолий Кулаков" Более того, в отличие от type-конвертера IParceable имеет более мощную, более гибкую систему.
3003.56 3010.64 "Анатолий Кулаков" Например type-конвертер может преобразовать только свойства, например ключ-ключ значения.
3010.64 3023.36 "Анатолий Кулаков" Если вы хотите тип user запарсить и у вас в url передается username и userage через key-value разделенных знаком равно, то тогда type-конвертер вам подойдет.
3023.36 3031.56 "Анатолий Кулаков" Но если вы, например, задаете username-age, то уже type-конвертер с такой структурой не справится.
3031.56 3035.00 "Анатолий Кулаков" То есть когда нет key-value пэйера, type-конвертер уже не работает.
3035.00 3043.32 "Анатолий Кулаков" А IParceable может, потому что ему передается полностью там урл, полностью вот эта строка, и он эту строку может абсолютно по своим усмотрениям как хочет распарсить.
3043.32 3048.88 "Анатолий Кулаков" Если же вам эта фича почему-то не нравится, вы ее боитесь, ее можно легко выключить.
3048.88 3059.04 "Анатолий Кулаков" Для этого достаточно удалить метод, то есть удалить провайдер, который называется try-parse-model-binder-provider из mvc-опций, который там теперь по умолчанию добавлен.
3059.04 3068.72 "Анатолий Кулаков" Вторая штука, которую отмечает Android Lock, это в том, что mvc-контроллеры теперь могут не использовать attribute from service.
3068.72 3085.84 "Анатолий Кулаков" Я напомню, что mvc-контроллер может в методе get или post или любом другом action-методе, кроме непосредственно данных, которые к нему бандятся из провайдеров, из урлов, из реквестов, они могут запрашивать сервисы.
3085.84 3089.16 "Анатолий Кулаков" То есть вы можете делать сервис инжекшенов в метод.
3089.16 3104.96 "Анатолий Кулаков" Для того, чтобы такую штуку провернуть, то есть для того, чтобы mvc пришел к вам body, то есть сложный класс из body, или вы запрашиваете сервис настоящий из контейнера, чтобы он их различал, сервису раньше нужно было указывать специальный атрибут, который называется from-service.
3104.96 3108.28 "Анатолий Кулаков" В .NET 7 вы можете этот атрибут опустить.
3108.28 3115.32 "Анатолий Кулаков" mvc-фреймворк такой умный, что он теперь сам догадывается, что вам нужно заинжектировать метод service.
3115.32 3127.36 "Анатолий Кулаков" Это совет сомнительный, потому что никто из вменяемых людей не инжектирует сервисы в методы, если вас, естественно, не ограничить какой-нибудь blazor-фреймворк и прочие глупости.
3127.36 3130.08 "Анатолий Кулаков" Нормальный способ – это инжектировать сервисы только в конструктор.
3130.08 3131.08 "Анатолий Кулаков" Других не бывает.
3131.08 3148.08 "Анатолий Кулаков" Дальше, третье улучшение, третья фича, которую отмечает Эндрю, это то, что nullable аннотации теперь более тесно проникают в mvc-среду и тоже дают какие-то наведенные интересные эффекты.
3148.08 3164.08 "Анатолий Кулаков" Например, в action методе можно было передавать сложный тип, например, какой-нибудь body, структуру, описывающую body, там юзера, и говорить ему, что этот юзер должен десерилизоваться из body.
3164.08 3175.92 "Анатолий Кулаков" И если вдруг у вас есть такой метод, который обязательно юзера требуют из body, и в этот метод вызвали, но body никакой не передали, то, соответственно, будет исключение, потому что метод body ожидает, а body к нему не передали.
3175.92 3187.80 "Анатолий Кулаков" И если вы хотите, чтобы ваш метод работал и с body, и без body, то есть чтобы могли реквесты передать и не передать, там приходилось вертеть очень сложные настройки, атрибуты и прочая глупость.
3187.80 3196.68 "Анатолий Кулаков" Теперь же вы просто можете сделать nullable body, то есть обозначить тип как nullable, то есть необязательный, и mvc все поймет.
3196.68 3201.60 "Анатолий Кулаков" Если body нет, он вам передаст туда null, если body есть, он его десерилизует и тоже вам туда передаст.
3201.60 3205.40 "Анатолий Кулаков" Очень удобно и очень хорошо.
3205.40 3212.92 "Анатолий Кулаков" И такая же ситуация с dependency сервисом, который вы можете разрезать из контейнера, как я уже упоминал выше.
3212.92 3216.84 "Анатолий Кулаков" Некоторые извращенцы достают его с помощью action методов.
3216.84 3228.28 "Анатолий Кулаков" Вот раньше, если вы добавляли в action метод зависимость, которая from service, и эта зависимость вам была необязательной, то вы это никак не могли указать.
3228.28 3230.20 "Анатолий Кулаков" Только, опять же, это связывается с настройками и атрибутами.
3230.20 3234.44 "Анатолий Кулаков" Сейчас вы можете в этой зависимости просто поставить знак вопроса, что означает nullable тип.
3234.44 3242.00 "Анатолий Кулаков" И если такая зависимость в контейнере не найдена, вам туда передастся null и ваш метод способен дальше будет отработать.
3242.00 3249.64 "Анатолий Кулаков" Следующая интересная фича это iResult, который как раз таки немножко поддержали в mvc.
3249.64 3255.20 "Анатолий Кулаков" Мы как раз в одном из прошлых выпусков, я сомневался в том, что iResult поддержан в mvc.
3255.20 3260.16 "Анатолий Кулаков" Игорь, помнишь, ты говорил, что в mvc он все-таки поддержан, его можно использовать в action results.
3260.16 3261.16 "Анатолий Кулаков" Был такой.
3261.16 3262.16 "Анатолий Кулаков" Вот, был такой разговор.
3262.16 3265.36 "Анатолий Кулаков" Оказывается, и ты, и я, и правы, и нет.
3265.36 3266.36 "Анатолий Кулаков" Объясняю сущность.
3266.36 3272.64 "Анатолий Кулаков" Как вы знаете, в mvc контроллеры могут возвращать тип, который называется iActionResult или ActionResult.t.
3272.64 3281.12 "Анатолий Кулаков" То есть это такой максимально гибкий тип, который позволяет вам там и хедры указывать, и статус коды вставлять, и вообще делать абсолютно все с реквестом, что вы только хотите.
3281.12 3287.44 "Анатолий Кулаков" В minimal API есть другой интерфейс, который возвращает minimal API.
3287.44 3290.44 "Анатолий Кулаков" Он называется iResult или iValueHttpResult.t.
3290.44 3294.96 "Анатолий Кулаков" И эти два резалта, они были несовместимы между собой.
3294.96 3303.92 "Анатолий Кулаков" То есть mvc контроллер не понимал, если вы ему на выход даете returnResult.ok из minimal API.
3303.92 3312.52 "Анатолий Кулаков" Самое обидное, что имея сигнатуру iActionResult, контроллер воспринимал Result.ok как нормальный объект.
3312.52 3320.96 "Анатолий Кулаков" То есть, грубо говоря, у вас не было никаких варнингов во время компиляции, и у вас не будет никаких ошибок в рантайме.
3320.96 3330.92 "Анатолий Кулаков" Все, что произойдет в рантайме, это mvc framework возьмет этот результат, который вы ему создали, который .ok, и просто-напросто засериализует его в JSON.
3330.92 3333.68 "Анатолий Кулаков" И отдаст на выход, как нормальный сериализованный JSON.
3333.68 3344.28 "Анатолий Кулаков" И там будут куча всяких системных внутренних ненужных полей, как код, месседж и прочие глупости, которые, естественно, показывать нормальному пользователю не нужно.
3344.28 3351.36 "Анатолий Кулаков" И вот в 7 mvc сделали небольшую ограниченную поддержку iResult.
3351.36 3363.52 "Анатолий Кулаков" То есть, теперь, когда вы случайно передадите Result из minimal API, он будет сериализоваться в виде нормального JSON, то есть без вот этих системных полей, а только как обычный JSON.
3363.52 3371.04 "Анатолий Кулаков" Но насколько у него, то есть, когда вы ok передадите с объектом, то есть, будет все хорошо.
3371.04 3373.24 "Анатолий Кулаков" Примерно произойдет то, что вы ожидаете.
3373.24 3375.72 "Анатолий Кулаков" Но, скорее всего, там не поддерживаются другие резулты.
3375.72 3380.48 "Анатолий Кулаков" То есть, результат не ok, а какой-нибудь результат roar или результат redirect, они еще не поддерживаются.
3380.48 3383.52 "Анатолий Кулаков" То есть, поддерживаются только ok, которые нужно сериализовать в простой JSON.
3383.52 3385.76 "Анатолий Кулаков" Вот такая вот лимитированная поддержка.
3385.76 3392.32 "Анатолий Кулаков" Специально, наверное, для тех, кто забывается и применяет одни и те же классы в двух разных хипостасях.
3392.32 3406.12 "Анатолий Кулаков" И последняя штука, которую сделали, это дали возможность настраивать мета-дата-провайдер для того, чтобы предоставлять более гибко ответ о проблемах.
3406.12 3408.84 "Анатолий Кулаков" И немножко подробнее.
3408.84 3414.12 "Анатолий Кулаков" По время ошибок в MVC принято возвращать такой классик, который называется Problem Details.
3414.12 3423.88 "Анатолий Кулаков" Это специальный вклад, который описывает, в чем проблема, какие были поля заaffection, в чем у них проблема, description этих ошибок, которые произошли и так далее.
3423.88 3436.44 "Анатолий Кулаков" И здесь было некое разночтение, потому что в этом Problem Details, как я уже говорил, он и содержит названия полей, в которых произошла ошибка.
3436.44 3440.16 "Анатолий Кулаков" И названия полей эти записывались по скаль-кейсе, как и положено в нормальном C#.
3440.16 3446.92 "Анатолий Кулаков" Но в JSON, в JavaScript и прочем, там обычно используют CamelCase.
3446.92 3459.32 "Анатолий Кулаков" И именно вот такую ошибку, которая позволяет вам настроить, каким кейсом будет отображаться Problem Details, вот такую специальную настройку добавили в .NET 7.
3459.32 3465.60 "Анатолий Кулаков" Для этого есть специальный классик, который называется Model Metadata Detail Provider, в чем у которого это все настраивается.
3465.60 3475.68 "Анатолий Кулаков" Вот такие фичи, некоторые из них большие, интересные и серьезные, некоторые вот такие маленькие, лишь бы дотянуть до пяти, но мне кажется, некоторые очень даже полезные и будут использоваться в повседневной жизни.
3475.68 3483.58 "Игорь Лабутин" С другой стороны, мне кажется, видно, что основной убор был все-таки на Minimal API, и контроллеры обновили по стольку-поскольку.
3483.58 3492.52 "Игорь Лабутин" И по большому счету, в основном для совместимости с Minimal API, ну а там всякие from services завезли так по ходу дела, видимо, кому-то нужно было за Contributor.
3492.52 3496.72 "Анатолий Кулаков" Да-да, скорее всего, возможно, это даже какие-то внешние Contributor залили.
3496.72 3506.08 "Анатолий Кулаков" Вот, то есть, если вдруг вам кто-то скажет, что MVC не развивается, вот теперь вы можете честно ответить, что нет, развивается, какие-то там мелочи тоже есть.
3506.08 3509.80 "Анатолий Кулаков" Но, конечно, основной упор сейчас делается на Minimal API.
3509.80 3513.92 "Игорь Лабутин" Да, да, да, мы поглядим, куда придет восьмерка.
3513.92 3518.68 "Игорь Лабутин" Пойдем дальше, есть у нас что-нибудь еще?
3518.68 3526.08 "Анатолий Кулаков" Да, мы уже говорили с вами в прошлом выпуске про GitHub Actions, в общем, что это такое, основы и прочие-прочие вещи.
3526.08 3528.00 "Анатолий Кулаков" Если вы думали, что это конец, то вы ошибались.
3528.00 3536.24 "Анатолий Кулаков" Сегодняшняя статейчика – это как раз-таки продвинутый курс по GitHub Actions, а именно о том, как сделать свои собственные GitHub Actions.
3536.24 3549.28 "Анатолий Кулаков" Если вдруг вы не сталкивались с этими великими workflow и не знаете, что это такое, то смело можете переслушать наш прошлый выпуск, там мы подробно говорили, что это, как это использовать в своих проектах и зачем это нужно.
3549.28 3555.24 "Анатолий Кулаков" А теперь же рассмотрим более интересную тему о том, как написать свой GitHub Actions, ну, естественно, на дотнете.
3555.24 3556.80 "Анатолий Кулаков" Прежде всего, что это точнить?
3556.80 3564.24 "Анатолий Кулаков" Что Actions поддерживает несколько видов запускаемых форматов, назовем это так.
3564.24 3571.48 "Анатолий Кулаков" Во-первых, Action может быть докер-контейнером, то есть запускаться, как обычный докер, и внутри там, естественно, может происходить все, что угодно.
3571.48 3573.80 "Анатолий Кулаков" То есть все, что позволяет докер, вы можете внутри творить.
3573.80 3580.36 "Анатолий Кулаков" Action можно писать на чистом JavaScript или TypeScript, короче, все, что поддерживает Node.js.
3580.36 3584.96 "Анатолий Кулаков" И Action может быть так называемый тип compose.
3584.96 3587.84 "Анатолий Кулаков" Это то, что объединяет в себе несколько команд.
3587.84 3592.56 "Анатолий Кулаков" То есть независимо, какого типа, их может быть много.
3592.56 3596.08 "Анатолий Кулаков" .NET, естественно, совместим с типом докер-контейнеров.
3596.08 3600.68 "Анатолий Кулаков" То есть .NET-приложения обычно пишут с типом докера.
3600.68 3606.80 "Анатолий Кулаков" И, наверное, если вы не пишете на чем-то, что совместимо с JavaScript, то это тоже ваш выбор.
3606.80 3608.04 "Анатолий Кулаков" То есть вы тоже будете писать в виде докера.
3608.04 3615.64 "Анатолий Кулаков" В общем, здесь есть интересный пример, очень подробный и детально описанный, как он делается.
3615.64 3623.12 "Анатолий Кулаков" В сущности, это шаг, который собирает различные метрики для вашего репозитория, для вашего проекта.
3623.12 3625.24 "Анатолий Кулаков" То есть он собирает всякие код-анализы.
3625.24 3631.08 "Анатолий Кулаков" Он сканирует cs-proj и web-proj файлы в репозитории и анализирует их на какие-то стандартные метрики.
3631.08 3641.56 "Анатолий Кулаков" Например, цикломатическую сложность, maintainability index, глубина наследования, class coupling, количество строк, количество запускаемых строк.
3641.56 3644.60 "Анатолий Кулаков" То есть такие базовые метрики, на которые некоторые любят смотреть.
3644.60 3651.00 "Анатолий Кулаков" И после того, как он это все проанализировал, собрал, вот этот анализатор создает файл, который называется "code-metrics.md".
3651.00 3659.60 "Анатолий Кулаков" И в этом файлике все подробнейше описывает, как этот анализатор работает.
3659.60 3660.60 "Анатолий Кулаков" То есть как этот action работает.
3660.60 3662.76 "Анатолий Кулаков" По идее он должен работать следующим образом.
3662.76 3671.20 "Анатолий Кулаков" Если вы пушите какие-то изменения в ваш git-репозиторий, то должен запускаться вот этот action, который анализирует все возможные метрики.
3671.20 3679.36 "Анатолий Кулаков" После того, как он запустит и проанализирует метрики, он создает markdown-файл, в котором метрики всего вашего проекта будут обновлены и записаны.
3679.36 3682.24 "Анатолий Кулаков" Если их не было, они создадутся, если есть, они будут обновлены.
3682.24 3689.08 "Анатолий Кулаков" И если вдруг этот файлик обновился, они создадут pull-request, в котором будет этот новый файлик.
3689.08 3696.96 "Анатолий Кулаков" И вот этот "code-metricsmd" файл, он довольно-таки разувезистый для markdown.
3696.96 3708.56 "Анатолий Кулаков" То есть у него есть навигация, у него есть активные линки в каком методе, какая комплексит есть, сколько там линий есть.
3708.56 3712.28 "Анатолий Кулаков" Они сгруппированы, разбиты по namespaces, которые можно коллапсить и разворачивать.
3712.28 3718.96 "Анатолий Кулаков" По щелчку на методе можно перейти прямо в исходный код и посмотреть на него визуально и убедиться, страшный он или красивый.
3718.96 3724.84 "Анатолий Кулаков" Также он использует эмоджи для того, чтобы подсветить уровень ахтунга, который происходит с вашим кодом.
3724.84 3728.12 "Анатолий Кулаков" Например, если код комплексити маленький, он вам рисует зеленые галочки.
3728.12 3731.96 "Анатолий Кулаков" Если код комплексити большой, он вам рисует взрыв мозга.
3731.96 3736.80 "Анатолий Кулаков" То есть он получается довольно интерактивный, красочный и показательный.
3737.64 3755.40 "Анатолий Кулаков" Итак, что же нам нужно для того, чтобы превратить вот эту программу, которая просто умеет сканировать, собирать метрики и писать файлик, в GitHub Action, который могут пользоваться миллионы и миллиарды и переиспользоваться на GitHub.
3755.40 3764.48 "Анатолий Кулаков" Всего лишь навсего нам нужно в репозитории GitHub сделать один маленький файлик, который называется Action.yaml.
3764.48 3767.16 "Анатолий Кулаков" Не то чтобы маленький, но довольно стандартный.
3767.16 3770.56 "Анатолий Кулаков" Он легко копируется и легко подстраивается под ваш проект.
3770.56 3774.48 "Анатолий Кулаков" В этом Action.yaml вы описываете все взаимодействие с GitHub.
3774.48 3777.60 "Анатолий Кулаков" Файлик абсолютно декларативный, абсолютно интуитивно понятный.
3777.60 3784.44 "Анатолий Кулаков" В частности, вы можете написать название Action, который у вас будет, description, который видит разработчик, подключаясь к Action.
3784.44 3788.84 "Анатолий Кулаков" Выбрать иконку, сделать набор входных аргументов.
3788.84 3792.20 "Анатолий Кулаков" То есть, что нужно для того, чтобы ваш Action заработал.
3792.20 3794.12 "Анатолий Кулаков" Какие вам нужно передать параметры.
3794.12 3797.88 "Анатолий Кулаков" Может быть там репозиторий, или может быть файлик, куда это все писать.
3797.88 3802.00 "Анатолий Кулаков" Или может быть уровень логирования, уровень сбора метрик и прочие вещи.
3802.00 3806.16 "Анатолий Кулаков" Также вы можете из вашего Action дать какие-то output, какие-то выходные параметры.
3806.16 3810.52 "Анатолий Кулаков" Например, рассказать, все ли у вас хорошо, выдать какой-то процент покрытия и еще что-то.
3810.52 3813.76 "Анатолий Кулаков" Это тоже в этом Action.yaml можно задекларировать.
3813.76 3827.60 "Анатолий Кулаков" После того, как вы этот yaml файл зачекинили и подвели весь ваш репозиторий в формат Action, вы сможете найти ваш Action на Marketplace.
3827.60 3835.00 "Анатолий Кулаков" GitHub его автоматически индексирует и на GitHub Action Marketplace он там может появиться.
3835.00 3844.40 "Анатолий Кулаков" После того, как он появится на GitHub Action Marketplace, вы можете заиспользовать этот Action в любом проекте, который хостится на GitHub.
3844.40 3857.68 "Анатолий Кулаков" Чтобы это сделать, вы должны создать GitHub Workflow, как мы обсуждали в прошлом выпуске, и в этом репозитории в атрибуте uses написать полный путь до вашего Action.
3857.68 3862.40 "Анатолий Кулаков" После того, как GitHub о нем знает, он его легко может найти.
3862.40 3863.88 "Анатолий Кулаков" Вот это в принципе все.
3863.88 3875.16 "Анатолий Кулаков" В этом Action вы можете передать ему input параметры, которые вы декларировали в Action.yaml и настроить, когда он там будет запускаться при push, при pull и прочие триггеры, которые мы уже обсуждали.
3875.16 3885.80 "Анатолий Кулаков" Автор пошел немножко дальше и он вспомнил, что GitHub объявлял о поддержке векторный диаграмм, который называется Mermaid.
3885.80 3897.04 "Анатолий Кулаков" Мы с вами о ней говорили, это очень удобное средство для написания векторного диаграмма, который можно актуализировать и поддерживать, например, на каждый push.
3897.04 3899.40 "Анатолий Кулаков" Вот чем автор в принципе и занялся.
3899.40 3904.84 "Анатолий Кулаков" Он прикрутил к этому анализатору автоматическое создание диаграммы для каждого класса.
3904.84 3916.84 "Анатолий Кулаков" То есть теперь в этом файлике, который называется CodeMetrix, вы можете не только пройти на метод и посмотреть его код комплексити, вы можете нажать и посмотреть его класс-диаграмму.
3916.84 3918.84 "Анатолий Кулаков" Нормальную юмельную класс-диаграмму.
3918.84 3923.48 "Анатолий Кулаков" Еще он состоит из каких полей, от кого она следует, как соотносится и так далее.
3923.48 3928.80 "Анатолий Кулаков" И самое интересное, что эти класс-диаграммы будут обновляться автоматически при любом pull-request.
3928.80 3937.56 "Анатолий Кулаков" Кто бы вам ни сделал pull-request с любым файликом, с любыми изменениями, с любым рефакторингом, все эти класс-диаграммы автоматически обновятся с помощью вот этого GitHub Action.
3937.56 3945.88 "Анатолий Кулаков" И в вашем документации, в вашем файлике MD они всегда будут актуальны, если для вас почему-то это важно.
3945.88 3950.36 "Анатолий Кулаков" Реализация довольно тривиальная, там есть экстеншн метод, который называется ToMermoryClassDiagram.
3950.36 3957.56 "Анатолий Кулаков" И он довольно простой, потому что юмель-диаграммы на мерморе дестроятся просто и легко.
3957.56 3961.12 "Анатолий Кулаков" В общем, кому интересно, можно посмотреть, а кому не очень интересно, воспримите сам факт.
3961.12 3975.24 "Анатолий Кулаков" То есть вы можете на каждый pull-request обновлять документацию, диаграмму, обновлять все кодметрики, показывать это в виде красивого документа с нормальными линками на исходный код, с нормальными цифрами, которые отслеживаются, меняются и контролируются.
3975.24 3979.60 "Анатолий Кулаков" Можете также выдавать, так как это GitHub Action, какую-нибудь обратную связь.
3979.60 3986.56 "Анатолий Кулаков" Например, если у вас появился файлик, у которого код complexity зашкаливает, вы можете просто-напросто этот бранч запретить в Merged Master.
3986.56 3989.48 "Анатолий Кулаков" В общем, все это тоже настраивается и легко делается.
3989.48 4001.68 "Анатолий Кулаков" Вот таким незамысломатым образом можно каждый из вас сделать свой собственный action, опубликовать его на GitHub Marketplace и пользоваться в других проектах, и заставлять друзей или организацию тоже им пользоваться.
4001.68 4010.76 "Игорь Лабутин" Ну, звучит прям почти как готовый туториал, что нужно сделать, так сказать, прям на слух можно воспринять и все сделать.
4010.76 4016.72 "Анатолий Кулаков" Ну и в статейке там есть ссылка на более подробные исходники, документацию, примеры на GitHub.
4016.72 4023.08 "Анатолий Кулаков" Естественно, если вы вдруг захотите этим заняться, обязательно посмотрите, все ссылки будут у нас в заметках к выпуску.
4023.08 4024.08 "Игорь Лабутин" Отлично.
4024.08 4030.68 "Игорь Лабутин" Давай у нас последняя темка, в этот раз мы вернемся к нашему формату кратко о разном.
4030.68 4036.24 "Игорь Лабутин" Накопилось некоторое количество ссылочек на всякие мелочи, которые хочется озвучить.
4036.24 4043.12 "Игорь Лабутин" Во-первых, я внезапно узнал, что можно через Command Line добавлять проекты в Solution.
4043.12 4047.36 "Игорь Лабутин" Никогда не делал такого, я всегда открывал Visual Studio, говорил, там это Project, вот это все.
4047.36 4055.68 "Игорь Лабутин" Оказывается, можно сказать .net.slln.add и указать путь к CS Proj или к многим CS Proj и вам создаться в Solution с нужными проектами.
4055.68 4061.80 "Игорь Лабутин" Вероятно, это удобно, когда нужно создать Solution, например, из только под папочки какой-нибудь большой или что-нибудь в таком духе.
4061.80 4064.24 "Игорь Лабутин" Я как-то не знал, не пользовался.
4064.24 4065.64 "Игорь Лабутин" Может быть, пригодится когда-нибудь.
4065.64 4078.80 "Анатолий Кулаков" Да, я такую штуку делал, я это применял в основном для темплейтинга, когда мне нужен новый чистый был Solution делать и туда какие-то стандартные CS Proj забросать, им какие-то стандартные референсы, пакеты добавить, в общем, все это через Command Line отлично интегрируется
4078.80 4082.80 "Игорь Лабутин" и делает. В общем, старинкой мышкой в UI нормально.
4082.80 4103.08 "Игорь Лабутин" Дальше вижу, в студии есть, вот я, к сожалению, не понял какой версии, надо будет почитать поподробнее, но тем не менее, все мы знаем, наверное, те, кто работает по крайней мере с JVT токенами, JVT, JVT это токен содержит, ну по привычке все называют JVT токенами, сайт jvt.io, где можно посмотреть на содержимое токена.
4103.08 4111.68 "Игорь Лабутин" Вы туда закидываете этот B64, значит, через точечки формат, а он вам выдает красивый джерессончик, что там внутри лежит, какие клеймы, вот это все.
4111.68 4126.00 "Игорь Лабутин" Теперь, если вы находитесь в отладчике Visual Studio, то вы можете на строковой переменной посмотреть текст визуалайзера, и там теперь есть в дропдауне выбор, что этот токен, наверное, делает по сути то же самое.
4126.00 4131.84 "Игорь Лабутин" То есть, если вы получили токен где-то в отладке, то вы можете прямо в Visual Studio, не выходя из дебангера, глянуть на его содержимое.
4131.84 4141.64 "Анатолий Кулаков" Я могу добавить, что JVT.io мне сайт не нравится, он какой-то грязный, у него какие-то баннеры, реклама, еще какая-то чушь, а прекрасный сайт есть jvt.ms.
4141.64 4145.68 "Анатолий Кулаков" Чистенький, красивенький, с подсветочкой, в общем, я обычно пользуюсь им.
4145.68 4149.20 "Игорь Лабутин" Ага, отлично, хорошо, буду знать, буду пользоваться там.
4149.20 4159.44 "Игорь Лабутин" Дальше, мы уже рассказывали, скорее всего, это где-то звучало в выпуске, но хочу еще раз подчеркнуть, тут недавно где-то, прям, то ли статья мне попалась, то ли в Твиттере что-то попалось про транзитивные зависимости.
4159.44 4180.52 "Игорь Лабутин" Известно, что когда вы добавляете в какой-нибудь ваш проект ссылку на NuGet-пакет, а этот NuGet-пакет, например, ссылается на какие-то еще дальше NuGet-пакеты, то вот те самые еще NuGet-пакеты, они будут называться транзитивными зависимостями и будут в том числе подкачиваться в ваш output, да, при сборке и использоваться, собственно, в приложении, потому что они нужны пакету, которую используете вы.
4180.52 4204.44 "Игорь Лабутин" Начиная с Visual Studio 17.3, у нас появилась возможность в UI-чике Visual Studio прямо в Package Management смотреть на, собственно, список этих транзитивных зависимостей, промоутить их в Top-Level зависимости, если вам нужно, например, зафиксировать версию, либо вы можете мышкой навести на эту транзитивную зависимость и даже посмотреть, откуда она вообще появилась, то есть кто из Top-Level ваших зависимостей является причиной того, что эта транзитивная зависимость к вам по каким-то причине попала.
4204.44 4205.44 "Игорь Лабутин" Прямо удобно.
4205.44 4222.72 "Игорь Лабутин" Я еще не пользовался, но проблема транзитивных зависимостей, выяснение, какого, значит, лишего у нас тот или иной пакет вдруг оказался в output, ну или длить какого-то пакета, она периодически возникала, и вот теперь есть такой один из способов это дело порешать.
4222.72 4237.48 "Игорь Лабутин" Дальше, пока нету официальных никаких новостей про вижу у студию 2022 новые 17.5, то есть превьюшку, то есть напоминаю, что 17.4 это то, что вышло официально с поддержки седьмого дотнета, и сейчас привидится 17.5.
4237.48 4241.96 "Игорь Лабутин" И вот в превью 2 появилась фича под названием Sticky Scroll.
4241.96 4254.84 "Игорь Лабутин" Видимо, отдельных статей про превью нету, то ли потому что все в отпусках и никто не пишет статьи, либо там нет каких-то супер больших интересных фич, а только какие-то bugfixes, про которые статьи писать неинтересно.
4254.84 4261.68 "Игорь Лабутин" Но вот Sticky Scroll это прям супер вещь, я почти собрался поставить превью версию и попробовать эту штуку.
4261.68 4293.20 "Игорь Лабутин" Ее нужно включить в настройках, и дальше происходит следующее, как только вы начинаете скролить ваш файлик вниз, то как только у вас попадается строчка с объявлением namespace, класса, метода, или, ну грубо говоря, любой конструкции, которая начинает в лог, то есть if, for, else, while и вот это все, using, то такая строчка как бы приклеивается к верху окна редактора, и у вас получается такая лестница наверху из вложенных скопов, по сути, того, где вы сейчас находитесь.
4293.20 4311.20 "Игорь Лабутин" И штука эта поддерживает сейчас C#, XAML и JSON, и на эту лестницу в заголовке можно кликнуть, и кликнув на нужную строчку, то есть кликнув, допустим, на имя и функцию, вы в редакторе проскроетесь ровно на эту функцию, на начало ее, кликнув там на, не знаю, namespace, проскроетесь к самому началу.
4311.20 4334.04 "Игорь Лабутин" Кажется, что для каких-нибудь сложных штук типа XAML или JSON, не знаю, насколько это будет полезно в C#, в C# в среднем, наверное, ты более-менее помнишь, в каком классе ты находишься, потому что у тебя имя, имя файлика соответствует обычной имени класса, а вот в форматах типа JSON и XAML должно быть прям удобно, мне кажется, такое понимание, где же ты в этой иерархии сейчас находишься, вложенных тегов.
4334.04 4338.60 "Анатолий Кулаков" Да, возможно, ну и методы обычно в C# делают большими.
4338.60 4344.36 "Анатолий Кулаков" Мне, кстати, этой штуки не хватало, в общем, сильно в райдере после перехода с Visual Studio.
4344.36 4349.96 "Анатолий Кулаков" Штуки, которая висит наверху и показывает тебе, в каком namespace, в каком классе, в каком, главное, методе ты сейчас находишься.
4349.96 4368.08 "Анатолий Кулаков" В общем, в райдере такой штуки нету, и вот это, по-моему, sticky scroll, он вполне может ее заменить, потому что если метод короткий, то вот в каком-то классе это вообще не всегда очевидно, особенно если у тебя есть nested классы или еще что-то такое, и sticky scroll вполне
4368.08 4385.12 "Игорь Лабутин" это покажет. Ну, кстати, да, я согласен, про имя класса-то основного ты, в принципе, по имени файлика, то есть по названию таба можешь понять, ну, более-менее, где ты, а вот действительно, если есть nested классы, либо какой-нибудь там вложенный, четырехложенный using друг в друге, то это действительно может быть полезно.
4385.12 4393.28 "Игорь Лабутин" И двое последних новостей, которые я хотел озвучить, это следующее.
4393.28 4400.16 "Игорь Лабутин" Наверняка кто-то это слышал, если не слышал, посмотрите обязательно про такой формат хранения запросов, как .http файлы.
4400.16 4591.86 "Игорь Лабутин" То есть вы можете в этот текстовый файлик, куда вы можете в специальном текстовом формате а-ля Markdown, это очень отдаленно напоминает Markdown, но тем не менее, написать там в одной строчке, например, там get, дальше url, на следующей строчке все заголовки, которые нужно послать, таким образом сохранить там запрос, ну или в пост, соответственно, можно дайбоди передать, если нужно, а потом различные две ешки умеют это дело запускать, то есть в IntelliJ можно рядом с каждым запросом в таком файлике появляется кнопочка типа запустить его, если вы пользуетесь Visual Studio Code, там есть соответствующий экстенджин, который позволяет тоже запускать запросики и показывает рядом панельку с ответом, то есть в общем такая замена command line to lambda запуска запросов и замена чему-то тяжеловесному типа какого-то постмана для запуска этих самых раздопросов, и теперь у нас есть возможность в IntelliJ, точнее не так, команда IntelliJ предоставила теперь command line интерфейс для запуска этих штук, файликов, то есть вы можете скачать либо zip архивчик, либо docker image, в zip архивчик лежит javski, ну это jarnik по сути внутри там лежит, который позволяет запустить эти http файлики и получить ответы, причем пока поддержаны только http-реквесты, но потом там добавят новых, я так понимаю, что должны быть еще поддержаны http2, там графку или вот это все, потому что http файлики поддерживают, а вот command line интерфейс пока нет, а внутри этих http файлов можно писать простенькие тесты, я так понял на javascript пишется кусочек, ну можно там сверить респонсы, проверить что в респонсе пришло то, что надо, что ретурт код нужный и так далее, и вот этот самый command line интерфейс, ну tool, либо из zip либо из docker, умеет генерить репорт в формате gunit, который понимает все нормальные ci, и таким образом результаты таких тестов можно будет запихать прямо в ваш ci pipeline, в результаты pipeline, то есть по сути, если вот я например использовал http файлы в качестве хранения таких типа девелоперских запросов, они коммитятся в репозитории, все дела, и у всех разработчиков более-менее одинаковые запросы к разрабатываемой системе, удобно дергать ручками, все дела, теперь вы можете все такие же запросы дергать прямо на И второй тул на самом деле как-то две новости вышли более-менее одновременно, ну плюс-минус, там, поправка на то, когда мы их читаем, это тул под названием Hurl, то есть вы, наверное, знаете, есть такой command-line tool Hurl, да, c URL, и теперь есть h URL, это штука, которая позволяет написать запросы в формате похожем на .http файлы, они не совсем такие, они чуть-чуть по-другому пишутся, но очень похожи, я думаю, что они более-менее либо легко конвертируются один другу, либо может быть в результате таки зайдутся в единый формат, там тоже можно писать тесты, но там поддержаны JSON Path, XPath и прочие такие штуки, то есть тоже не совсем полный JavaScript, но тем не менее тесты можно писать, а assertion и duration проверять и так далее. Эта штука на Rust используется внутри libcurl и позволяет тоже, по сути, встраивать себя в CI и запускать вот эти самые запросы автоматически с генерацией каких-то отчетов, которые можно включить в CI.
4591.86 4598.02 "Игорь Лабутин" В общем, способов теперь запустить в .http запросы из CI будет больше, и это прикольно.
4598.02 4609.98 "Анатолий Кулаков" Да, ну, соответственно, не только CI, если, опять же, вам нужно это из IDE просто запускать для того, чтобы посмотреть, какие стандартные ответы вы дает ваш сервис, это удобно организовать в виде обычных файликов. Да, все так.
4609.98 4611.98 "Анатолий Кулаков" Можно добавлять их там даже в репозитории.
4611.98 4615.42 "Анатолий Кулаков" У меня тоже есть маленькая, маленькая заметочка.
4615.42 4621.98 "Анатолий Кулаков" Я хочу напомнить, а для тех, кто не знал, сказать, что у Андрю Лока выходит обновление его книги.
4621.98 4635.74 "Анатолий Кулаков" У него есть замечательная книга, которая прорассказывает про ASP во всех его проявлениях с различных сторон. Мы эту книгу обсуждали. Дело в том, что мы непосредственно принимали участие в ее переводе.
4635.74 4643.82 "Анатолий Кулаков" И выходит третья версия этой книги. Выход запланирован на июнь 2023 года.
4643.82 4650.46 "Анатолий Кулаков" Сейчас на сайте Manning доступен Early Access Program, то есть каждый из вас может зайти, посмотреть.
4650.46 4652.78 "Анатолий Кулаков" Обновлений достаточно много.
4652.78 4662.02 "Анатолий Кулаков" Во-первых, если старая книга была полностью построена на .NET Core 3.1, в новой книге он все переписал на 7.NET, на 7.SP.NET Core.
4662.02 4666.86 "Анатолий Кулаков" По дефолту во всех примерах используется Minimal Hosting, Minimal API.
4666.86 4673.10 "Анатолий Кулаков" Добавлена и улучшена секция про Razor Pages Server Rendering Applications.
4673.10 4676.66 "Анатолий Кулаков" Везде используются Options Builder, Configuration Manager.
4676.66 4683.06 "Анатолий Кулаков" В общем, все самые новомодные штуки, которые мы тут с вами обсуждаем, сейчас перенесены в книгу.
4683.06 4688.26 "Анатолий Кулаков" То есть там нет ничего старенького, там все новые технологии, все новые подходы, все самые клевые примеры.
4688.26 4689.74 "Анатолий Кулаков" В общем, туда уже перенесены.
4689.74 4692.66 "Анатолий Кулаков" Как я уже сказал, релиз будет в июне.
4692.66 4698.66 "Анатолий Кулаков" И русский издатель уже запланировал ее перевод.
4698.66 4702.18 "Анатолий Кулаков" То есть как только она выйдет, мы сразу же обновим русскую версию.
4702.18 4706.58 "Анатолий Кулаков" Поэтому, если кому-то интересно, ждите русскую адаптацию тоже, она будет.
4706.58 4713.70 "Анатолий Кулаков" И под шумок, раз уж мы заговорили про книги, хочется сделать еще один небольшой анонс.
4713.70 4719.70 "Анатолий Кулаков" Наша команда переводчиков, переводчиков .NET.RU, она работает над новой книгой сейчас.
4719.70 4725.30 "Анатолий Кулаков" Это книга Кристиана Уэнза, которая называется SP.NET Core Security.
4725.30 4731.78 "Анатолий Кулаков" Замечательная книга, к которой взята одна довольно узкая тема, это безопасность в SP.NET Core.
4731.78 4735.14 "Анатолий Кулаков" Но раскрыта она довольно хорошо с многих сторон.
4735.14 4738.46 "Анатолий Кулаков" И показано очень много примеров, очень много технологий.
4738.46 4744.18 "Анатолий Кулаков" В общем, книга не скучная абсолютно, даже если вас не интересует там security, безопасность и все такое.
4744.18 4746.18 "Анатолий Кулаков" То есть книга будет интересна каждому.
4746.18 4750.66 "Анатолий Кулаков" И плюс, если вас интересует, то вы как бы правы.
4750.66 4753.82 "Анатолий Кулаков" Потому что безопасность должна интересовать каждого разработчика.
4753.82 4760.30 "Анатолий Кулаков" Если вы даже не сталкиваетесь с ней все время, каждый день, то вам необходимо знать о каких-то базовых концептах, базовых аспектах.
4760.30 4763.42 "Анатолий Кулаков" И для этих людей данная книга тоже будет очень полезна.
4763.42 4767.98 "Игорь Лабутин" Да, мы потихонечку работаем над переводами.
4767.98 4771.26 "Игорь Лабутин" Надеюсь, что скоро сможем порадовать какими-то результатами.
4771.26 4773.98 "Игорь Лабутин" Ну а на сегодня мы будем заканчивать.
4773.98 4775.98 "Игорь Лабутин" Кажется, мы...
4775.98 4784.34 "Игорь Лабутин" Даже в отсутствии новостей, практически в отсутствии новостей о DotNet 8 появляется все равно что-то интересное периодически и уже даже про DotNet 8.
4784.34 4787.74 "Игорь Лабутин" Так что на новой выпуске в новом году точно хватит.
4787.74 4789.74 "Игорь Лабутин" Это последний выпуск уходящего года.
4789.74 4794.38 "Игорь Лабутин" Так что всех хочется поздравить с наступающим новым годом.
4794.38 4798.38 "Игорь Лабутин" 2023-м. Подкаст с вами точно остается.
4798.38 4806.94 "Игорь Лабутин" Ну и будем надеяться, что вы все так же остаетесь с DotNet, с 8, 7, 6, какой там у вас есть.
4806.94 4811.74 "Игорь Лабутин" И будете продолжать его использовать, а возможно и улучшать, и развивать.
4811.74 4819.86 "Игорь Лабутин" А сегодня мы посмотрели на новинки 8 DotNet, потихонечку откапываемые на GitHub в виде Frozen Collections.
4819.86 4828.50 "Игорь Лабутин" Вспомнили, что новенького и какие изменения завезли в сетевую подсистему 7 DotNet.
4828.50 4834.98 "Игорь Лабутин" Выяснили, что делать, если ваше приложение тормозит по памяти, точнее, кушает много памяти или тормозит в ГЦ на 7 DotNet.
4834.98 4837.90 "Игорь Лабутин" Что же делать и как проверить, виноват ли ГЦ.
4837.90 4841.54 "Игорь Лабутин" Узнали про фичу DevTunnels для Visual Studio.
4841.54 4845.58 "Игорь Лабутин" Узнали про экстенджен для Project TIE для Visual Studio Code.
4845.58 4851.14 "Игорь Лабутин" Посмотрели, что в MVC завезли в 7 DotNet, ну не так много фич, но какие-то все-таки есть.
4851.14 4859.38 "Игорь Лабутин" Посмотрели на туториал по созданию GitHub Actions на DotNet и разобрали кучу всяких мелочей вокруг DotNet, от узов и прочих других мест.
4859.38 4861.38 "Игорь Лабутин" Ну и книжки затронули.
4861.38 4867.42 "Анатолий Кулаков" Ну на этом все. Я хочу напомнить в конце, что у нас есть сайт Boosty, который делает нам безумно приятно.
4867.42 4871.10 "Анатолий Кулаков" И большое спасибо всем помогателям, которые нам там помогают.
4871.10 4880.02 "Анатолий Кулаков" Если вдруг вы захотите сделать подарок любимым подкасту, то смело рассказывайте о нас своим друзьям, шарьте, репостьте и всячески рекламируйте нам.
4880.02 4882.02 "Анатолий Кулаков" Безумно приятно от этого каждый раз.
4882.02 4884.86 "Анатолий Кулаков" Всех с наступающим, всех с Новым Годом.
4884.86 4888.22 "Анатолий Кулаков" В зависимости от того, когда вы нас будете слушать, всех с большим праздником.
4888.22 4890.22 "Анатолий Кулаков" Всем пока.
4890.22 4892.22 "Игорь Лабутин" Пока.
4892.22 4902.74 None [музыка]
