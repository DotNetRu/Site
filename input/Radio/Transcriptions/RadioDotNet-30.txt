0.00 12.32 "Анатолий Кулаков" Всем привет, дорогие друзья, с вами Радионотнет, выпуск №30, и в студии, как всегда, Анатолий Кулаков.
12.32 14.12 "Анатолий Кулаков" И Игорь Лабутин, всем привет.
14.12 21.68 "Анатолий Кулаков" Прежде всего хотелось бы поблагодарить наших патронов – Александр и Сергей, спасибо вам большое, а также всех тех, кто нас поддерживает.
21.68 24.40 "Анатолий Кулаков" Кстати, о поддержке.
24.40 37.60 "Анатолий Кулаков" У нас тут недавно записался интересный выпуск закрытый, где мы как раз-таки обсуждали вывод валюты, фриланс, всякие бусти, патреоны и прочие такие донейшн сервисы.
37.60 43.72 "Анатолий Кулаков" Как оказалось, один из наших патронов очень сведущ в этих вопросах человек, и получился довольно-таки интересный выпуск.
43.72 48.04 "Анатолий Кулаков" Поэтому, если вам эта тема интересна, то зайдите, послушайте, посмотрите.
48.04 54.84 "Анатолий Кулаков" Информация довольно уникальна, мы, в принципе, её пытались открыть много где, и, мне кажется, получился довольно занятный и интересный выпуск.
54.84 60.00 "Анатолий Кулаков" Всё это найдёте на наших сайтах для помощи, ссылки будут в шоу-нотах.
60.00 68.76 "Игорь Лабутин" А мы перейдём к основному выпуску, и на этой неделе, ну точнее, с момента последнего подкаста, произошло довольно много всего интересного.
68.76 83.44 "Игорь Лабутин" Во-первых, прошёл Microsoft Build 2021, и обычно на этом ивенте у нас довольно много всяких анонсов, в этот раз анонсов тоже было прилично, но так сложилось, что конкретно про .NET было очень мало.
83.44 105.20 "Игорь Лабутин" То есть, фактически можно сказать, что .NET 6 при U4 был анонсирован во время Microsoft Build, но на самом деле, после просмотра всего того, что там произошло, и всех выступлений, которые были на Microsoft Build, ну я-то по заголовкам, конечно, смотрел, большая часть конференции посвящена всё-таки Azure и всяким разным вокруг облачным вещам.
105.20 119.12 "Игорь Лабутин" Поэтому, если вам интересны Microsoft облака, использование Azure и всё вокруг этого, то рекомендую посмотреть, ссылочка будет в описании на подробный обзор всех докладов, всех, так сказать, новостей со ссылками.
119.12 125.00 "Игорь Лабутин" А мы перейдём всё-таки к тому, что нам интересно, а именно .NET 6 при U4.
125.00 132.00 "Игорь Лабутин" Большой-большой анонс, мы уже потихонечку приближаемся к ревизу .NET 6, который произойдёт в ноябре.
132.00 136.24 "Игорь Лабутин" Определены даты .NET Conf, конференции, когда будет анонсировано .NET 6.
136.24 145.68 "Игорь Лабутин" Финальный релиз это 9 и 11 ноября, с 9 по 11, так что ждём, осталось не так много, всего-то 5 месяцев.
145.68 149.44 "Игорь Лабутин" И за это время Microsoft должен успеть огромное количество новых фич запилить.
149.44 165.48 "Игорь Лабутин" Хотя надо сказать, что когда я открывал анонс .NET 6 при U4, я думал, ну, будет там очередной небольшой кусочек фич, но длина этого обзора меня как-то поразила и количество фич, которые они успели завести с момента при U3, оно прям какое-то огромное.
165.48 177.28 "Анатолий Кулаков" Мне кажется, Microsoft ускоряется просто с каждым превью и всё больше фич втаскивает, всё больше каких-то импрувментов делает, анонсов, пишет статей, ну, то есть команда у них там только разгоняется.
177.28 187.48 "Игорь Лабутин" Понятно, что если начать все фичи в начале, то в какой-то момент они все начнут потихонечку завершаться и понятно, почему в ранних превью мало фич, что там ещё просто не успели дописать.
187.48 191.68 "Игорь Лабутин" Ну вот, превью 4 это первый такой большой превью, в котором очень много всего.
191.68 202.04 "Игорь Лабутин" Я думаю, что там пятый, может быть, шестой превью будет, надеюсь, примерно такими же, а дальше начнется стабилизация и опять будет мало всего, потому что код фриз, он всё-таки неизбежен.
202.04 203.04 "Анатолий Кулаков" Ну ладно.
203.04 206.92 "Анатолий Кулаков" Хорошо, не тяни, давай подробнее, что там интересного у нас.
206.92 208.88 "Игорь Лабутин" Давай, .NET, как обычно, пойдём по разделам.
208.88 213.76 "Игорь Лабутин" .NET, System Text JSON, поддержка IOSync и Numeral.
213.76 233.84 "Игорь Лабутин" Теперь такая штука, можно, здесь реализация работает только на корневых массивах, то есть если у вас JSON.JSON, это массив и внутри кучка объектов одинаковых, то тогда вы можете асинхронно его десериализовывать, получать в ответ IOSync и Numeral, и он будет генериться лениво по мере того, как вы кончумите то, что там получилось.
233.84 244.40 "Игорь Лабутин" Это поможет, если вы получаете, например, какой-нибудь огромный JSON в PostBody и потихонечку его десериализуете по кусочкам, массив, который там есть.
244.40 269.76 "Игорь Лабутин" С сериализацией проще, сериализация просто возьмёт IOSync и Numeral, его аккуратненько упакует в список для Sony, как положено, но будет это работать только если вы вызываете serialize async или deserialize async, в других случаях, если вы используете просто обычный serialize and deserialize, вам сгинется unsupported exception, то есть IOSync и Numeral поддержан, ну что, более-менее логично, только в асинхронном сериализации.
269.76 310.08 "Игорь Лабутин" Это не единственное изменение в System Text JSON, они добавили фичу, которую мы уже обсуждали много подкастов назад, как планы, и действительно она теперь появилась, это writeable DOM, то есть если вы когда-нибудь использовали XML API, так скажем, .NET, то там была возможность собирать XML-ку из объектов, то есть там был XML Object, XML Node, то теперь есть JSON Object и JSON Node, там точнее был X Node и X Document, теперь есть JSON Object и JSON Node, из которых вы можете собрать по сути некоторую структуру вашего JSON документа, а потом вызвать один метод и получить уже его текстовое представление, если вам это надо.
310.08 318.24 "Игорь Лабутин" Поможет модифицировать или как-то оперировать JSON-деревом в памяти, если вам это надо, зачем-то, например, реплейсить какие-то ноды.
318.24 325.08 "Игорь Лабутин" Это все про System Text JSON, дальше улучшения у нас коснулись логинга, и туда пришли source-генераторы.
325.08 331.12 "Игорь Лабутин" Теперь можно сделать такую, несколько неочевидную, но тем не менее интересную штуку.
331.12 344.00 "Игорь Лабутин" Всегда и до этого момента можно было определить свои собственные лого-месседжи через метод define_message, и тогда для того, чтобы логировать такие месседжи, это было немножко более оптимально.
344.00 355.24 "Игорь Лабутин" Теперь можно сделать это все через source-генератор, то есть вы объявляете, допустим, класс log статический, и он обязательно должен быть partial, чтобы source-генератор мог дописать кусочек метода.
355.24 364.76 "Игорь Лабутин" В нем вы объявляете public static partial метод, в который передаете ilogger и какие-нибудь параметры, которые вы хотите добавить, вот, дополнительно.
364.76 373.20 "Игорь Лабутин" А на этот метод навешиваете атрибут logger_message, где указываете, какой это будет event_id, какой log_level у этого месседжа, и собственно, что за месседж.
373.20 377.80 "Игорь Лабутин" Ну и внутри этого месседжа вы можете использовать те параметры, которые переданы в метод.
377.80 389.36 "Игорь Лабутин" Source-генератор за вас сгенерит тело этого метода, причем так, что оно будет там правильно, оптимально, не будет логировать и не будет ничего эволюетить, если не нужны вам log_level и так далее.
389.36 404.24 "Игорь Лабутин" При этом можно это сделать не обязательно статиком, можно это сделать нон-статиком, и в этом случае метод будет ждать, что в этом же классе у вас есть private поле типа ilogger, чтобы именно к нему обращаться для того, чтобы писать непосредственно месседжи.
404.24 429.12 "Анатолий Кулаков" Тут хотелось бы уточнить, что это нужно именно для высокопроизводительного кода, то есть если вы раньше, наверное, сталкивались с проблемами тем, что у вас или логгер тормозит, или вы много слишком аллокейтите ненужных объектов, боксинга, анбоксинга, говорим, и логирования, то вы наверняка нашли бы страничку в Microsoft, где он рассказывает, каким образом делать логгинг для высоконагруженных приложений.
429.12 444.24 "Анатолий Кулаков" И там вот одна из техник была, это как раз-таки создание вот этого месседжа, который один раз создается внутри себя, инкапсулирует всякие log_level, непосредственно сам template и прочее, то есть всю статическую часть, которая не меняется, не зависит от ваших параметров.
444.24 469.84 "Анатолий Кулаков" И это предотвращает очень много локаций, это оптимизирует очень много всяких хот-патхов, и в принципе вы могли раньше это все сделать ручками, но это было очень муторно, то есть много всяких ключиков, каких-то надо передать, не забыть, сгенерить, по сравнению с тем, что написать один раз логгер в райт какой-нибудь или логгер инфа, никто этим практически не загонялся, если уж совсем припечёт.
469.84 476.72 "Анатолий Кулаков" И вот этот генератор, он как раз такими убирает вот эту всю рутину, которой раньше никто не хотел заниматься.
476.72 479.20 "Анатолий Кулаков" Вот, может быть, больше станет таких логгеров теперь.
479.20 496.16 "Игорь Лабутин" Да, и это позволяет вам уже в вашем коде не писать там logger.information от cannot_open_socket для такого-то такого-то порта, например, а вы будете писать там log.put_not_open_socket как вызов метода и передавать туда просто номер порта как аргумент, и всё.
496.16 510.96 "Игорь Лабутин" То есть, возможно, так чуть более читабельный текст и код становится, хотя с другой стороны, не знаю, я, например, привык больше видеть именно там, глаз сразу выцепляет метод дологирования за счёт того, что там обычно длинные строчки, и это как-то, ну, проще читать.
510.96 520.36 "Анатолий Кулаков" Да, действительно, оптимизированный вариант, он менее читабельный, кажется, может, менее привычный, но зато очень сильно помогает, если вам это действительно нужно.
520.36 521.36 "Игорь Лабутин" Да.
521.36 522.36 "Игорь Лабутин" Пошли дальше, linq.
522.36 542.60 "Игорь Лабутин" В linq завезли довольно большое количество изменений, они такие все мелкие, но тем не менее, первое самое забавное, и по-моему, это породило достаточно большое обсуждение, я это видел в твиттере, но, возможно, ещё где-то, про новые параметры для тейков, скипов и прочих всяких таких штук, туда можно теперь передавать ренжи.
542.60 559.48 "Игорь Лабутин" То есть, если вам нужно было взять элементы, допустим, со второго по пятый, точнее, с третьего по пятый в какой-то коллекции, то вы должны были раньше написать collection.take(5).skip(2), то есть первые два пропустили, третий, четвёртый и пятый забрали.
559.48 566.28 "Игорь Лабутин" Теперь это можно написать просто collection.take(2).5, ну и будет работать примерно так же.
566.28 586.60 "Игорь Лабутин" Поддержан весь необходимый синтекс ренжей, то есть там есть всякие типа ренжи с конца, вот это всё, полуоткрытые ренжи, так что, с одной стороны, клёво, с другой стороны, конечно, когда ты видишь collection.take(), крышечка 3, скобка закрылась, это надо просто вот знать, что это нужно, по сути, взять последних три элемента.
586.60 596.32 "Игорь Лабутин" То есть вот эти вот синтексы с индексированием с конца, которые начинаются с крышечки, меня как-то очень сильно путают, ну, опять же, вопрос привычки.
596.32 597.32 "Игорь Лабутин" Пока непривычно.
597.32 601.72 "Анатолий Кулаков" Да, меня тоже, как и крышечки с конца, довольно сильно пугают пока.
601.72 603.40 "Игорь Лабутин" Ну, посмотрим.
603.40 607.60 "Игорь Лабутин" Дальше есть такой клёвый метод, добавили, называется tryGetNonEnumeratedCount().
607.60 617.28 "Игорь Лабутин" Он пытается у IEnumerable получить количество элементов в этом IEnumerable, точно не начиная его энумерации.
617.28 629.44 "Игорь Лабутин" То есть понятно, что если у вас под IEnumerable скрывается лист или какой-нибудь там словарь или collection или там return или collection, в общем, что-нибудь конечного размера, то он, в принципе, знает свой count.
629.44 646.00 "Игорь Лабутин" И в BCL, внутри, в самом LinkU было очень много оптимизации на уровне, во всяких методах типа where или select или еще в чем-то, что типа если IEnumerable кастится к листу, то давай мы сделаем forEach или for по нему, а не будем честным итератором ходить.
646.00 663.40 "Игорь Лабутин" Так вот теперь такая возможность, не делая вот этих всех бесконечных кастов и проверок, является ли IEnumerable нужным типом, можно теперь вызвать метод tryGetNonEnumeratedCount(), и если он вернет вам какую-то чиселку, это значит, что в коллекции, которая за этим IEnumerable скрывается, вот ровно такое число элементов.
663.40 669.56 "Игорь Лабутин" Можно это использовать для того, чтобы, например, инициализировать какие-то ваши промежуточные коллекции нужным количеством элементов сразу.
669.56 673.00 "Анатолий Кулаков" Да, count это довольно важная штука во время оптимизации.
673.00 679.28 "Анатолий Кулаков" Мы как раз упоминали в прошлом выпуске, что если вы можете, обязательно count указывайте при инициализации коллекций, особенно больших.
679.28 682.16 "Анатолий Кулаков" Вот, и, наверное, это жест в эту сторону.
682.16 695.00 "Игорь Лабутин" Ну да, теперь если у вас даже, если метод принимает IEnumerable, все равно можете вызвать tryGetNonEnumeratedCount(), если он что-то вернул, используйте это что-то в качестве количества элементов для коллекции, если вы, например, один в один вырабатываете.
695.00 713.12 "Игорь Лабутин" Дальше, коллекция методов distinctBy, unionBy, intersectBy, exceptBy, то есть все операции над множествами, получила возможность не только сравнивать сами объекты, но и добавить специальную лямбдочку, чтобы сравнить по какому-то ключу, то есть, например, по одному полю из объекта, по сути, как бы селектор.
713.12 724.64 "Игорь Лабутин" То же самое добавили в maxBy и minBy, теперь можно там находить максимум из, там, не знаю, объектов типа прямоугольник по их площади, передав туда лямбдочку подсчета площади, ну что-нибудь в таком духе.
724.64 735.52 "Игорь Лабутин" Добавили интересный метод chunk, который по сути нарезает IEnumerable на кусочки фиксированной длины, но обычно он пишется более-менее самостоятельно, тоже несложно, но вот зачем-то потребовался.
735.52 741.32 "Игорь Лабутин" И в методы firstToDefault, lastToDefault и singleToDefault добавили возможность передать этот самый default.
741.32 747.88 "Игорь Лабутин" Раньше он всегда возвращал дефолтное, собственно, значение того типа, от которого коллекция, теперь туда можно передать какое-то другое.
747.88 757.64 "Игорь Лабутин" То есть если вас не устраивает дефолтный 0, например, длинтов, вы туда можете передать, например, 2, и вам будут возвращаться 2, если, допустим, firstToDefault ничего не нашел в коллекции.
757.64 765.52 "Анатолий Кулаков" Или если в reference type вы привыкли использовать null object в виде дефолта, а стандартный метод вам бы возвращал все время null.
765.52 768.16 "Анатолий Кулаков" Вот теперь можно это довольно красноречиво рассказать.
768.16 779.36 "Игорь Лабутин" Да, интересно, кстати, кто-то не проверял, поддерживает ли такие штуки типа firstToDefault для вот в случае, как ты говоришь, когда ты возвращаешь null object, по идее у тебя это значит, что firstToDefault никогда не вернет null.
779.36 784.08 "Игорь Лабутин" Интересно, как там null reference type замаплено, типа null is not null, вот это вот все.
784.08 795.68 "Анатолий Кулаков" Мне почему-то кажется, что это специально из-за них и сделали, потому что народ начал ругаться, типа я никогда не хочу получать null, я от них хочу избавляться от своей программы, а есть стандартные методы, которые это не позволяют сделать красиво.
795.68 800.40 "Анатолий Кулаков" Может быть, вот поэтому оно и появилось, потому что иначе я не вижу смысла в этих дефолтах.
800.40 802.40 "Игорь Лабутин" А, да, действительно, может быть, действительно и поэтому.
802.40 810.72 "Игорь Лабутин" Ну и метод zip, который собирает из двух коллекций одно, туплыми, соответственно, поэлементно, теперь умеет собирать, делать это на трех коллекциях.
810.72 814.84 "Игорь Лабутин" Тоже, видимо, для каких-то внутренних целей потребовалось, поэтому добавили overload для трех коллекций.
814.84 817.76 "Игорь Лабутин" Почему не для четырех, не для шести, не для десяти?
817.76 823.72 "Игорь Лабутин" Ну, видимо, вот нет таких сценариев внутри, не знаю, в ASP.NET Core, скорее всего, почему-то, мне кажется.
823.72 824.72 "Игорь Лабутин" Не знаю.
824.72 829.84 "Игорь Лабутин" Я не смотрел, можно, кстати, найти теоретический pull request, который ты добавлял, там наверняка есть какое-нибудь обоснование.
829.84 831.32 "Игорь Лабутин" Надо будет, может, посмотреть ради интереса.
831.32 833.64 "Игорь Лабутин" Файл стримы.
833.64 841.64 "Игорь Лабутин" Довольно много работали над файл стримами, работал никто иной, как Adam Sitnik над этим, очень много, небезызвестный наверняка нашим слушателям.
841.64 847.20 "Игорь Лабутин" И они сильно заимпровили всю performance файл стримов на винде.
847.20 858.28 "Игорь Лабутин" Теперь, если вы используете async, вот вывод, то есть, async методы поверх файл стримов, они действительно все полностью асинхронны и никогда нигде не заблочатся.
858.28 868.36 "Игорь Лабутин" То есть, это все асинхронно, максимально асинхронно передается внутрь винды, и сама винда тоже асинхронно отвечает, и вам это все асинхронно вернется в виде там continuation, wait, вот этого всего.
868.36 875.64 "Анатолий Кулаков" Ты что, хочешь сказать, что нам последние 5-10 лет врали, что async чтение из файлов было нечисто асинхронным?
875.64 884.72 "Игорь Лабутин" Ну, говорят, да, говорят, оно где-то внутри, то ли винапи, то ли еще где-то могло немножко заблочиться, сейчас точно не будет.
884.72 886.12 "Игорь Лабутин" Вот негодяйство какое.
886.12 902.88 "Игорь Лабутин" Да, вообще, но если тебе хочется этого негодяйства обратно, у нас есть специальный флажочек в конфиге, можно написать config properties в, соответственно, JSON конфигурации, и там написать system.io.usenet5.compat.file.stream.true, и вам вернется старое поведение.
902.88 907.68 "Анатолий Кулаков" То есть, если вам будет слишком асинхронно, слишком быстро, слишком хорошо, верните себя обратно.
907.68 931.24 "Игорь Лабутин" Ну, причина, почему добавили флажок, потому что, как я понимаю, они сильно поменяли внутреннюю структуру того, как это все работает, как файлстримы там работают и с операционной системой и так далее, и ввели некоторый слой абстракции, как я сказал, что сейчас все эти performance опробументы доступны на винде только, но теперь вот этот новый слой абстракции позволяет использовать такую штуку как IO_urink.
931.24 940.00 "Игорь Лабутин" Я не очень большой специалист в Линуксе, но эта штука, видимо, какое-то правильное IO позволяет в Линуксе, которое тоже будет полностью правильно асинхронным.
940.00 943.12 "Игорь Лабутин" Те, кто знает, наверное, знают, о чем я говорю.
943.12 949.08 "Игорь Лабутин" Вот, и теперь вот эту штуку можно автоматически, ну, полуавтоматически заюзать на дотнете, на Линуксе тоже.
949.08 953.40 "Игорь Лабутин" Они этого не обещают в шестом дотнете, но, видимо, как руки дойдут, так сделают.
953.40 958.44 "Игорь Лабутин" Так, таймзоны, точнее, дейт тайм и таймзоны.
958.44 963.16 "Игорь Лабутин" Ну, про date only, time only мы уже говорили в прошлый раз, да, Витя?
963.16 964.16 "Анатолий Кулаков" Да, так и есть.
964.16 977.68 "Анатолий Кулаков" Тут хочется добавить, что они теперь нативно мапятся на SQL-сервер, то есть date only пойдет мапиться в date, time only, соответственно, в time, что, в принципе, хорошо, интеграция пошла.
977.68 980.52 "Анатолий Кулаков" Я думаю, все остальные сервизаторы и фреймворки тоже подтянутся.
980.52 981.52 "Игорь Лабутин" Это приятно.
981.52 989.40 "Игорь Лабутин" Дальше улучшили перформанс одного из самых главных методов, точнее, пропертей в дотнете, это date time.utcnow, и там история такая.
989.40 1009.08 "Игорь Лабутин" На самом деле она работала довольно, ну, неплохо, так скажем, в дотнет фреймворке и в ранних дотнет корах, но в дотнет коре 2.x, в каком-то x, я не помню в каком, они сильно ухудшили перформанс этого проперти, потому что внезапно выяснилось, что надо учитывать правильно високосные секунды иногда.
1009.08 1020.52 "Игорь Лабутин" То есть, как известно, у нас в году там не строго определенное количество секунд, мало того, что у нас есть бывают високосные года, где у нас то 365, то 366 дней, у нас еще бывают високосные секунды.
1020.52 1033.40 "Игорь Лабутин" Иногда время корректируется на там чуть-чуть, и в этом случае, в винде, на самом деле, можно в таком случае получить время, когда у тебя 23 часа 59 минут 60 секунд.
1033.40 1035.44 "Игорь Лабутин" То есть в винапе такое умеет возвращать.
1035.44 1039.76 "Игорь Лабутин" А дотнет такого не умеет, в дотнете секунды всегда 59.
1039.76 1052.20 "Игорь Лабутин" И поэтому там была некоторая специальная поддержка, которая каждый раз этот файл тайм, который возвращает виндовая апп, и конвертила правильно в дотнетное время, при этом вот с учетом этой секунды.
1052.20 1056.84 "Игорь Лабутин" Надо было узнать у винды, вот включала она сейчас эту секунду или не включала.
1056.84 1061.32 "Игорь Лабутин" Всем известно, что это может быть включено только в момент перехода через сутки, то есть в районе нуля часов.
1061.32 1068.44 "Игорь Лабутин" И эта вот поддержка этой секунды, она требовала какого-то немеренного количества ресурсов, ну по сравнению с тем, сколько занимает UTC now.
1068.44 1084.76 "Игорь Лабутин" И это все было очень медленно, именно поэтому в дотнете 2х и 3х сейчас они это дело закэшировали, то есть поскольку они знают, что это может поменяться только в 0000, то вроде как тратить время в районе полудня, чтобы это делать, как бы смысла вроде нет.
1084.76 1092.80 "Игорь Лабутин" Поэтому там теперь есть хитрый кэш на 5 минуточек, и эта инфа будет браться только раз в 5 минут теперь.
1092.80 1115.24 "Игорь Лабутин" Дальше потихонечку дотнет начинает поддерживать нормальные таймзоны, под нормальными я имею в виду иана таймзоны, которые значит может быть вы видели там, как же они, europe/moscow, вот такого вида, который используется обычно там, когда мы например их используем во всяких API, потому что они универсально понимаемы на всех платформах.
1115.24 1124.76 "Анатолий Кулаков" Ну кроме виндовса, подожди, что значит универсально понимаемые, это в основном таймзоны, которые припонимались нам на маках, линуксах, юниксах и всех остальных, у винды это была своя база данных.
1124.76 1140.64 "Игорь Лабутин" Да, а еще в браузерах, то есть например фронтендеры не знают что такое виндовс таймзоны и как с ними работать, а вот иана они знают, и поэтому в API мы возвращаем именно такие таймзоны, там где нужны таймзоны, по какой-то причине, ну и конвертим естественно из винды внутри и так далее.
1140.64 1155.48 "Игорь Лабутин" Теперь это все поддержано и то и другое, и они прям напрямую пишут, в смысле что был такой nuget пакетик, такой nuget пакетик таймзон конвертер, который как раз таки позволяет конвертить из одной в другую, теперь он не нужен, теперь это все встроено в дотант 6 сразу.
1155.48 1182.64 "Анатолий Кулаков" Ну вот это кстати большой дел, потому что насколько дотант не заявлялся как кроссплатформенный и все такое, но работать одинаково на всех платформах с таймзонами он не мог, потому что под линуксом он по умолчанию использовал как раз таки вот эту базу данных, а под виндусом он использовал виндовую базу данных, там ходил в реестр, забирал оттуда виндовые таймзоны, и с этим были большие сложности, у меня там до сих пор висит где-то открытый божок, который ждет вот этого фикса, поэтому я очень рад.
1182.64 1192.88 "Анатолий Кулаков" Другой вопрос, что просто так одну таймзону в другую конвертить невозможно, для этого существует специальная open source база данных, я забыл как ее зовут, тут нигде не упоминается.
1192.88 1193.88 "Анатолий Кулаков" TZData.
1193.88 1226.68 "Анатолий Кулаков" Да, точно, TZData, вот, и она постоянно обновляется, потому что правительство там вводит смещение часовых поясов, если бы не понравилось, смещают их обратно, там бывает лишний день добавляют, лишнюю ночь убирают и все такое, то есть день, день, день, со временем они просто так не живут чисто и красиво, они меняются чуть ли ниже секунды, поэтому у этой базы постоянно куча, постоянные обновления идут, в общем, и как виндос эту базу будет с собой таскать, как он ее будет обновлять и на каких условиях, это довольно интересный вопрос.
1226.68 1331.24 "Игорь Лабутин" Согласен, непонятно, но давай мы сейчас не будем сильно углубляться, а то мы будем повторять доклады там с кита про date time и так далее, посмотрите, если вам интересно в этом покопаться, посмотрите доклады Джона Скита, он много говорит про эту тему и у него есть нода time, который пытается как-то правильно делать, ну а дот над 6 потихонечку все-таки идет в правильном направлении, по крайней мере теперь дот над 6 везде умеет нормально работать с иана тайм зонами и конвертить их в виндовы, если вы на винте, он теперь везде пытается показывать одинаковые дисплеи на имейте тайм зонам, потому что раньше это тоже было по-разному на разных платформах, но вот тут, к сожалению, кроме винды, линьда все еще использует то, что в реестре пока еще, и они так округло говорят, что this may be changed later, то есть может быть они это поменяют, может нет, возможно это сильно как-то к backward compatibility относится, но все-таки мало ли кто-то сохраняет тайм зоны по именам прямо, непонятно, ну ладно, давайте дальше пойдем, а то тут нам еще много всего, код ген, про код ген много говорить не буду, там оптимизация, оптимизация и еще раз оптимизации, не буду вдаваться в детали, диагностика, eventpipes, про eventpipes сильно много тоже ничего не рассказать, они немножко переписали внутренний движок, причем новость звучит так, что мы его переписали с C++ на C++ и теперь моно, его может использовать, моно-рунтайм, почему как бы C++ нельзя было, не знаю, но наверное нельзя было, и второе, они улучшили перформанс этого самого eventpipes, видимо пока переписывали, по сравнению с dotnet 5 все эти винтики могут закачаться со скоростью в 2 раза быстрее, чем было в dotnet 5, то есть если в 5 вы там могли протащить условно там не знаю, 10 тысяч event за определенный промежуток времени, теперь 20 тысяч сможете, так что мониторинг станет проще, в каком-то смысле будет меньше грузить вашу систему.
1331.24 1338.64 "Игорь Лабутин" Так, теперь пошли про single file publishing и всякие, или trimming и вот это вот все.
1338.64 1356.28 "Игорь Лабутин" Во-первых, давай напомним, что у нас есть такой ключик trim mode, ну ключик не ключик, режим тримминга, и это значит, что при сборке вашего приложения компилятор будет пытаться отрезать все ненужное, чтобы уменьшить размер, если вы таскаете SDK с собой, это важно, ну в смысле SDK вместе с вашей программой.
1356.28 1370.88 "Игорь Лабутин" По дефолту раньше был режим, что отрезаются только неиспользуемые сборки, то есть если компилятор видит, что какая-то сборка не используется, он эту сборку не будет класть в output, но сами сборки внутри он никак не резал, по дефолту.
1370.88 1392.52 "Игорь Лабутин" Есть ключик, который позволяет внутри сборок начать отрезать типы, то есть не писать их в output, то есть сборки будут меньше размером, это более рискованный вариант, потому что ну reflection еще можно отследить, когда ты загружаешь отдельную сборку, но если ты используешь типы сборки какой-то по-нормальному и reflection из нее же, то тут уже сложнее, нужно знать откуда, как вообще понять про такой тип.
1392.52 1406.60 "Игорь Лабутин" Но теперь они сделали дефолтный режим, это как раз таки link, то есть пытаться отрезать вообще все, что можно, unused members, там всякие неиспользуемые функции, типы, классы, вот и все.
1406.60 1419.28 "Игорь Лабутин" Но при этом по умолчанию включены warning, которые пытаются, анализируя вашу программку, понять, отрезав этот класс, там сломается что-нибудь, reflection или какая-нибудь регистрация в контейнерах по конвенциям, еще что-то.
1419.28 1425.72 "Игорь Лабутин" Насколько этот анализ хорош, пока непонятно, но будем посмотреть.
1425.72 1441.12 "Игорь Лабутин" А warning, которые генерятся, можно задезейблить, задав suppressed stream analysis warnings в true в вашем csproje, ну тогда соответственно никаких warning не будет, тогда вы сами отвечаете за то, что у вас там нет reflection и так далее.
1441.12 1467.88 "Игорь Лабутин" При этом это все еще коснулось single file publishing, во-первых, они затащили статический анализ, это примерно похожая штука на вот этот вот trim mode и отрезание, но здесь single file publishing анализ, он смотрит на то, и нет ли у вас каких-то кусочков в коде, которые точно влияют, на поведение которых повлияет тот факт, что ваше приложение переупаковано в один файл.
1467.88 1494.04 "Игорь Лабутин" То есть, если вы, например, по имени файла, который сейчас исполняется, или по имени сборки, там assembly.location вызываете или assembly.getexecuting.assembly, потом name от него берете и на этом строите как-то свою бизнес-логику, то вот такие места будут найдены и зарепорчены вам warningами при сборке, чтобы вообще говоря понять, можно ли применять к вам этот самый single file publishing.
1494.04 1525.00 "Игорь Лабутин" При этом есть атрибут, называет requires assembly files, который вы можете указать на какой-то из ваших там апишек в сборке, и тогда будет понятно, что окей, тут как бы вот тот класс, который помечен этим атрибутом, должен все-таки лежать в своей сборке, потому что, например, он там требует, я не знаю, отдельных файлов на диске дополнительно, требует ресурсов, видимо, сборки, ну, я детально не изучал этот вопрос, но, видимо, это как-то все дальше обрабатывает.
1525.00 1537.08 "Игорь Лабутин" Автоматически эта штука включена для EXE-проектов, когда publish single file вы задаете в командной строчке, что true, но при этом вы можете это вообще в любом проекте включить, просто указав setting enable single file analysis.
1537.08 1548.40 "Игорь Лабутин" А для того, чтобы уменьшить еще больше размер, который получается после single file publishing, Microsoft добавил новую опцию, теперь можно добавить cssproj enable compression in single file, и тогда будет еще compression.
1548.40 1551.96 "Анатолий Кулаков" Ну вот с этого и надо было начинать, сначала надо все зазиповать, а потом мерить.
1551.96 1577.28 "Игорь Лабутин" Но, блин, фигня в том, что время запуска вырастает, причем вырастает довольно существенно, особенно на Unix, ну на Linux, как они пишут, потому что, как я понимаю, на Linux там вообще очень клевая штука работает, они ничем вообще никуда не распаковывают, в смысле что они могут мапить кусочки вот этого запакованного большого бинарничка, как разные бинарнички в памяти, и их исполнять как будто это отдельные файлики на диске.
1577.28 1582.72 "Игорь Лабутин" А если все это запаковано, понятно, что так не получится, нужно сначала куда-то распаковать память отдельно.
1582.72 1589.76 "Игорь Лабутин" То есть, ну, время, короче, тратится, поэтому проверяйте ваше приложение, если вы этим пользуетесь, насколько у вас этот compression влияет.
1589.76 1614.12 "Игорь Лабутин" Ну и мы упоминали crossgen2 пару выпусков назад, соответственно теперь это дефолтная опция в ready to run сценариях, так что все эти умные оптимизации, которые были возможны за счет того, что crossgen2, напомню, может анализировать сразу несколько сборок вместе и за счет этого как-то оптимизировать, инлайнить код между сборками, то может быть, если вы используете ready to run, у вас будет какой-то boost по перформансу.
1614.12 1619.48 "Игорь Лабутин" Так, пойдем дальше, у меня аж даже мышь заснула, пока я тут все это болтал.
1619.48 1625.08 "Игорь Лабутин" SDK и все причитающееся вокруг, template и вот это все.
1625.08 1633.44 "Игорь Лабутин" Во-первых, добавили такую штуку, называется теперь workloads, то есть раньше, если вы ставили SDK, ну вы его как бы поставили в dotnet SDK, ну и поставили и все.
1633.44 1635.12 "Игорь Лабутин" Вот он у вас стоит.
1635.12 1645.44 "Игорь Лабутин" И если вы ставите visual studio, ну вот visual studio у вас есть workload, вы можете там в install выбрать, я хочу development c#, я хочу development f#, я еще хочу winforms, а еще я хочу там, не знаю, wcf.
1645.44 1657.56 "Игорь Лабутин" Ну а теперь такая же штука, возможно, в SDK, у dotnet теперь появилось новый, так сказать, tool подраздел, можно теперь написать dotnet workload install и поинсталить какой-нибудь из workloads.
1657.56 1675.20 "Игорь Лабутин" Туда будут потихонечку добавляться всякие разные workloads для разных стук, в частности туда, например, приедет maui когда-нибудь, но пока не рекомендую для него использовать специальный скрипт maui_check, который, видимо, проверяет на самом деле, что у вас есть все еще нужные там всякие превью версии всего чего только надо, чтобы maui завелся.
1675.20 1682.24 "Игорь Лабутин" Дальше, если вам было интересно, не пора ли вам обновлять ваш dotnet SDK, который у вас стоит, не вышел ли какой-нибудь новый патч.
1682.24 1694.28 "Игорь Лабутин" Теперь есть новая команда у dotnet, dotnet problem sdk problem check, и он для всех заинсталленных у вас SDK-шек напишет какой последний патч есть и позволит, соответственно, обновить.
1694.28 1699.76 "Игорь Лабутин" Можно ему сказать, вероятно, сразу обновить, ну или вы придется скачать самому с сайта.
1699.76 1729.96 "Игорь Лабутин" И в темплейтах теперь можно делать еще круче, можно теперь сказать dotnet new defuse-defuse search, и после этого ваш dotnet XA поищет новые темплейты, вообще доступны темплейты на nuget.org, вам все это покажет, там есть, можно поиск по имени еще как-то, а потом можно сказать для уже заинсталленных темплейтов - -update-check или - -update-apply, и тогда оно все автоматически обновится у вас и будут ваши последние версии темплейтов у вас.
1729.96 1739.36 "Игорь Лабутин" Короче, Microsoft движется к варианту примерно как с Visual Studio, можно сказать, выставить один раз, дальше можно command-line-ом это как-то немножко допиливать, обновлять, доставлять новые кусочки.
1739.36 1741.92 "Игорь Лабутин" Visual Studio из консоли, я бы сказал, да?
1741.92 1742.92 "Игорь Лабутин" Вообще замечательно.
1742.92 1743.92 "Игорь Лабутин" Да, да, почему нет.
1743.92 1749.36 "Игорь Лабутин" Это было все про dotnet, но у нас есть еще ispanet, и тут ну...
1749.36 1750.68 "Игорь Лабутин" Там тоже большая пачка.
1750.68 1751.68 "Игорь Лабутин" Ну, приличная.
1751.68 1779.24 "Игорь Лабутин" Если вы читаете хоть как-то и следите за твиттером, вы наверняка видели штуку под названием minimal API, типа это "напиши минимально работающий ispanet сервер в рамках одного твита", и в принципе теперь у народа это получается, потому что завезли новый routing API, там есть теперь новая пачка оверлоудов метода mapget, которая позволяет просто указать там строчку "пути к url" и лямбдочку, которую, значит, выполнить, когда этот url дергается.
1779.24 1780.24 "Игорь Лабутин" И все зашибись.
1780.24 1785.20 "Анатолий Кулаков" Ну вот, дожили, теперь в нашем синтаксе самоправляют дурацкие игры в твиттере.
1785.20 1792.20 "Игорь Лабутин" Ну, почти, да, но еще не до конца, потому что завезли часть C#-improvement для этого, пришлось, иначе бы не получилось.
1792.20 1794.64 "Игорь Лабутин" То есть вот как раз-таки всякие...
1794.64 1804.40 "Игорь Лабутин" Мы обсуждали это в прошлых выпусках, что там нужны еще, пока это не сделано, атрибуты на лямбдах, автоматический кастинг лямбд в action и fang.
1804.40 1814.72 "Игорь Лабутин" В общем, часть C#-improvement уже сделана, но часть еще ждет своей части, своей, так сказать, очереди, чтобы еще уменьшить размер кода.
1814.72 1824.48 "Игорь Лабутин" Так, теперь можно написать, заиспользовать, точнее, новый хостинг API, как раз-таки тоже сделан для вот этого минималистичного кода, можно сказать.
1824.48 1838.64 "Игорь Лабутин" То есть раньше мы должны были создать билдер, на нем можно сказать build, вот это все, теперь можно написать app.create, и потом app.mapget, и туда уже передавать ваш endpoint, и все как бы, и все работает.
1838.64 1848.16 "Игорь Лабутин" При этом у webapplication можно все равно сказать create builder, по-моему, и тогда вам дадут, как обычный билдер, вы на нем можете там все, как надо, побилдить все, что вам надо.
1848.16 1857.80 "Игорь Лабутин" Ну и performance, performance, еще раз, performance, а Splanet все еще стремится там всех опередить, хотя он и так уже много кого опережает, и очередные улучшения performance тоже завезли.
1857.80 1871.80 "Игорь Лабутин" Дальше, Async Streaming, это, соответственно, все тот же asyncEnumerable, если вы теперь возвращаете asyncEnumerable из вашего контроллера, то он будет асинхронно сериализироваться в JSON.
1871.80 1877.36 "Игорь Лабутин" Смотри выше про поддержку asyncEnumerable в System Text JSON, вот она, видим, ровно для этого и была сделана.
1877.36 1891.60 "Игорь Лабутин" Наконец-таки Microsoft добавил свою собственную Logging Middleware, теперь у вас есть стандартный Middleware, который позволяет логировать запросы или респонсы, причем он настраиваемый, можно настроить, что логировать, в каком объеме боте логировать, когда логировать и так далее.
1891.60 1897.88 "Игорь Лабутин" Мне лично это сильно интересно, потому что у нас написан свой, но хочу посмотреть, как написал Microsoft, может оттуда утащить пару идей.
1897.88 1901.80 "Игорь Лабутин" Пока, к сожалению, на Dotnet 6 перейти у нас не получится, но по крайней мере.
1901.80 1911.20 "Игорь Лабутин" Если у вас когда-нибудь стояла задача логировать HTTP запросы у себя в коде, посмотрите, как Microsoft сделала, я думаю, что они должны были сделать довольно оптимально.
1911.20 1913.88 "Игорь Лабутин" Так, что еще интересненького?
1913.88 1914.88 "Игорь Лабутин" О, Kestrel.
1914.88 1921.48 "Игорь Лабутин" Когда вы сейчас запускаете Visual Studio, у вас по дефолту обычно используется Ease, в Dotnet 6 наконец-таки будет использоваться Kestrel.
1921.48 1929.04 "Игорь Лабутин" Не знаю, зачем, почему это не сделали еще раньше, но теперь Ease все еще можно, если надо, но по дефолту теперь будет Kestrel.
1929.04 1937.60 "Игорь Лабутин" Улучшили темплейты для SPA, там чуть-чуть по-другому трафик парксируется, но я не буду вдаваться в детали.
1937.60 1940.20 "Игорь Лабутин" Завезли некоторое количество Hot Reload.
1940.20 1943.32 "Игорь Лабутин" Давайте про Hot Reload отдельно поговорим, у нас отдельное обсуждение будет.
1943.32 1948.12 "Игорь Лабутин" Куча улучшений в Razer, Blazer, будем подробно смотреть.
1948.12 1951.96 "Игорь Лабутин" Я думаю, что сильно не будем вдаваться, и так много времени уже потратили.
1951.96 1961.80 "Игорь Лабутин" Короче, если вы занимаетесь Razer, Blazer или пытаетесь присмотреться к MAUI, посмотрите на линки в шоуноутах, там все будет интересно и более подробно.
1961.80 1964.92 "Игорь Лабутин" И последнее, о чем хочется сказать, это EF Core.
1964.92 1977.40 "Игорь Лабутин" EF Core, они прямо называют этот превью-релиз, это прямо Performance Preview, они улучшились в Tech Empower Benchmark по сравнению с пятой версией EF Core на 70%.
1977.40 1983.20 "Игорь Лабутин" При этом это улучшение, оно за счет и того, что сам фреймворк улучшился, и самих изменений EF Core.
1983.20 1997.04 "Игорь Лабутин" Но они это честно признают, и поэтому говорят, что при этом за счет самого EF Core из этих 70, это примерно 30% за счет того, что они быстрее выполняют кверки и оптимизации исключительные внутри самого EF Core.
1997.04 2001.48 "Игорь Лабутин" Они улучшили локейшены на 40 с лишним процентов, то есть их теперь стало меньше.
2001.48 2016.20 "Игорь Лабутин" И если раньше у них была цель догнать и перегнать даппер в Tech Empower, и разница была в районе 55% в Dota 5, то сейчас это где-то в районе 5%, так что они почти выполнили свою цель догнать.
2016.20 2017.20 "Игорь Лабутин" Неплохо, неплохо.
2017.20 2027.12 "Анатолий Кулаков" Ну с учетом того, что даппер он довольно-таки примитивный, а у EF Core довольно много всего там нагружено, всякие атрибуты, рефлекшены, опять же там трекинги иногда проскакивают.
2027.12 2029.20 "Анатолий Кулаков" Интересно даже посмотреть, как они это сделали.
2029.20 2045.80 "Игорь Лабутин" Ну они говорили, как они это делали, там можно почитать более детально, там много чего добились за счет более оптимального логинга, то есть очень сильно обрезали и оптимизировали, когда нужно что-то писать, потому что EF Core имеет очень большой логинг, даже если он выключен, он давал довольно нехилый overhead.
2045.80 2048.64 "Игорь Лабутин" Вот я так понимаю, что это один из больших кусочков.
2048.64 2056.36 "Игорь Лабутин" Ну и внутри они писали, что по сути как бы как оптимизировать перформанс на дотнете, пулы, reuse и все такое прочее.
2056.36 2059.00 "Игорь Лабутин" Короче смотрите в то место и все будет нормально.
2059.00 2062.52 "Игорь Лабутин" Почитайте статью, там довольно все подробно расписано, что и как.
2062.52 2073.96 "Игорь Лабутин" Так что так, надо кстати сказать, если ты помнишь, когда мы начинали обсуждать шестой дотнет и EF Core команда говорила планы, помнишь они говорили типа у нас это цель, полный bug fix, фич не будет, вот это все.
2073.96 2075.56 "Анатолий Кулаков" Да-да-да, было дело.
2075.56 2081.76 "Игорь Лабутин" Надо сказать, что пока они следуют своим, так сказать, целям, фич по крайней мере мы особо многих действительно не видев.
2081.76 2082.76 "Игорь Лабутин" А какие баги-баги-то?
2082.76 2083.76 "Анатолий Кулаков" Сокращаются?
2083.76 2088.12 "Игорь Лабутин" Я не смотрел, честно говоря, надо будет посмотреть кстати на следующему разу, может что-то будет.
2088.12 2092.00 "Анатолий Кулаков" Знаешь, как бы делать так, чтобы фич не было, это не сложно.
2092.00 2094.40 "Анатолий Кулаков" А вот сократить все баги до нуля, вот это вот вызов.
2094.40 2095.40 "Игорь Лабутин" Это правда.
2095.40 2096.40 "Игорь Лабутин" Ладно, пошли дальше.
2096.40 2105.04 "Игорь Лабутин" Ну что, про дотнет 6 вроде как все, почти там, чуть-чуть про хатер лот мы поговорим попозднее.
2105.04 2106.04 "Игорь Лабутин" Давай про Visual Studio.
2106.04 2110.24 "Игорь Лабутин" Во-первых, у нас зарелизилось 16.10, у нас было очень много превьюшек ее.
2110.24 2113.16 "Игорь Лабутин" Все, 16.10 теперь полностью доступно.
2113.16 2117.12 "Игорь Лабутин" Там много чего завезли, во-первых, там много чего завезли в дете.
2117.12 2120.40 "Игорь Лабутин" То есть, если вы пользуетесь гитом из студии, то посмотрите.
2120.40 2124.36 "Игорь Лабутин" Там в каждой превьюшке они все улучшали, улучшали, улучшали.
2124.36 2130.88 "Игорь Лабутин" И если вы не пользовались превьюшками, а сразу переходите со старых 16.x на новые 16.10, возможно вы много чего заметите.
2130.88 2134.32 "Игорь Лабутин" Если интересно, что конкретно, смотрите в ссылке.
2134.32 2140.92 "Игорь Лабутин" Кроме того, добавили какое-то количество сеттингов вокруг гита, а точнее в обведении Visual Studio вокруг гита.
2140.92 2148.12 "Игорь Лабутин" То есть, если вы меняете репозиторий, нужно ли закрыть солюшен, открыть ли солюшен в другом репозитории или не надо, или открыть только фолдер, а не солюшен.
2148.12 2149.12 "Игорь Лабутин" В общем, посмотрите.
2149.12 2158.40 "Игорь Лабутин" Performance Profiler улучшился, они заиспользовали какой-то новый engine и, соответственно, теперь там на 40% рендерится все быстрее, считается все быстрее.
2158.40 2162.52 "Игорь Лабутин" И удивительная штука для меня, завезли SourceLink Support.
2162.52 2169.32 "Игорь Лабутин" Я что-то считал, что Microsoft SourceLink используют везде, но оказалось Performance Profiler его не было, теперь есть.
2169.32 2177.20 "Игорь Лабутин" Мы обсуждали в превьюшках, было много всяких изменений про .NET Productivity, то есть всякие новые hotfix и еще что-то, quickfixes, sorry.
2177.20 2186.32 "Игорь Лабутин" Но две вещи, которых мы, по-моему, не обсуждали, они касаются XAML, а если вы вдруг пишете на WPF и используете XAML, теперь везде прикольных штук.
2186.32 2196.80 "Игорь Лабутин" Во-первых, теперь когда вы рисуете контроллы, кидаете их в дизайнере, не надо теперь идти в Properties, у вас у контролла появляется такой bubble, где можно быстренько выбрать основные свойства, ну по идее должно ускорять работу.
2196.80 2215.92 "Игорь Лабутин" Во-вторых, можно теперь у контролла написать item source sample data, и вот это вот волшебное слово sample data, оно вам контролл накидает, короче, тестовых данных, которые будут автоматически генерироваться, как бы по виду похожие на ваши нормальные байдинги, то есть будто бы если бы вам возвращали нормальные данные.
2215.92 2220.32 "Игорь Лабутин" В общем, если вам, вы пользуетесь XAML, присмотритесь, может действительно удобнее будет.
2220.32 2224.88 "Анатолий Кулаков" Интересно, то есть они генератор встроили, генератор данных прямо в контроллы нативно, интересно.
2224.88 2232.52 "Игорь Лабутин" да, да, да, да, да, да, да. Причём он так, слегка настраивается, то есть если у вас список, то вы можете указать сколько вам штук нужно ну и так далее.
2232.52 2261.42 "Игорь Лабутин" Есть первый превью в одиннадцатой версии, там пока ничего сильно много нового, там как раз завёлся мауи, если вы занимаетесь мауи, то вам нужно ставить студию 16.11 превью один, и там есть хот релоад, но давай про хот релоад чуть позднее. Всё, про студию в этот раз сильно много нету, потому что релиз после кучи превью вроде обычно никогда не бывает таким прям клёвым, ну а 16.11 превью один пока только первый превью, будем смотреть дальше.
2261.42 2294.78 "Анатолий Кулаков" У меня есть новости про другой популярный редактор кода, вышел roadmap для решарпера 20.21.2, а также для райдера, и в принципе у него тоже там импрувменты, код анализы, сделали очень много для рейдера и блейзера, улучшили соответственно разметку, заимпровили там какие-то навигации, но хотелось бы выделить одну интересную штуку, это улучшения в nullblow reference types, они очень плотно входят в нашу жизнь, и поэтому чем больше умных анализов, чем больше умных фиксов, тем лучше.
2294.78 2314.46 "Анатолий Кулаков" И вот много таких хороших умных анализов появилось в новом решарпере, в частности еще они сделали такую вещь, как возможность конвертить jetbrains annotation атрибуты с помощью обычного quickfix в специальную нотацию, которую уже понимают новомодные nullblow reference types.
2314.46 2331.02 "Анатолий Кулаков" Напомню, что jetbrains annotations это специальные атрибутики, которые широко использовались для того, чтобы как раз таки размечать методы, всякие свойства с помощью атрибутов, размечать их как null и not null, как коллекции, содержащие нулябельные элементы и так далее.
2331.02 2339.96 "Анатолий Кулаков" То есть очень много тех вещей, которые только сейчас Microsoft внедряет, у jetbrains были уже довольно-таки давно, в принципе, сколько я себя помню, я ими пользуюсь.
2339.96 2348.16 "Анатолий Кулаков" И поэтому, мне кажется, размечено громадное количество библиотек, очень много третий-сторонних библиотек размечаются.
2348.16 2352.96 "Анатолий Кулаков" У них можно размечать их не только атрибутами, но и в виде отдельных xml-файлов.
2352.96 2368.96 "Анатолий Кулаков" Поэтому даже если автор сам не хотел размечать атрибутами своей библиотеки, очень много энтузиастов подкладывали отдельный xml-файл, в котором было тоже все размечено, и мы, соответственно, получали уже сведения о нулябельности типов.
2368.96 2386.96 "Анатолий Кулаков" И теперь весь этот багаж, все это счастье, можно быстренько конвертнуть в новые наши модные null-reference-тайпы, если это возможно, естественно, потому что функциональность jetbrains Foundation намного больше, намного шире и мощнее, чем пока поддерживают официальные рослины.
2386.96 2392.96 "Анатолий Кулаков" Но то, что можно, он вам конвертит, и это, в принципе, замечательно, потому что у нас практически все проекты размечены атрибутами.
2392.96 2396.96 "Анатолий Кулаков" Если он сможет грамотно их перевести, это будет большое счастье.
2396.96 2419.96 "Анатолий Кулаков" Также многие разработчики во время переходов, или во время быстрофиксов, или во время каких-то костыльных хаков часто использовали nullable warning suppression, это такой специальный восклицательный знак, который затыкал компилятор и велел ему не ругаться на те типы, которых, по ему мнению, должны были быть nullы, а вы к ними так без пардона обращались.
2419.96 2428.96 "Анатолий Кулаков" Это довольно опасная штука, мы говорили в прошлом подкасте, что надо стараться избегать этого восклицательного знака, этого suppression.
2428.96 2439.96 "Анатолий Кулаков" И в ReSharper был добавлен интересная функциональность, которая позволяет найти вам все эти suppression во всем солюшене.
2439.96 2450.96 "Анатолий Кулаков" То есть вы можете посмотреть все места, где используются восклицательный знак, и сделать вывод, стоит ли его там оставлять, или может быть он уже не актуален, можно уже начинать его убирать.
2450.96 2478.96 "Анатолий Кулаков" Он, кстати, может быть не актуален после того, как вы обновитесь на новый .NET, потому что Рослинн тоже становится умнее, у него появляются новые анализы, и тот код, который раньше он не мог распознать, что там никогда не может быть null, из-за каких-то сложных workflow, или сложных параллельных вычислений, какого-нибудь параллельного изменения состояния, то теперь многие кейсы он распознать способен, и вот этот восклицательный знак вам больше не нужен.
2478.96 2489.96 "Анатолий Кулаков" Естественно ReSharper вам его подсветит и скажет, что он вам больше не нужен, но если вы хотите во всем солюшене их найти, то вот это вот замечательная функциональность, найти все их в солюшене.
2489.96 2496.96 "Анатолий Кулаков" Ну и как всегда, много импрувментов, quickfixes, перформанса, код анализов, это подробнее можно посмотреть по ссылочкам.
2496.96 2520.96 "Анатолий Кулаков" Как я уже сказал, вместе с ReSharper вышел roadmap для райдера, вот да, это только roadmap, это не то, что уже есть, это только то, что планируется, но есть уже первый early access program, и там вы можете скачать уже 2021.2 ReSharper и посмотреть, что же в итоге получает своя команда, и поучаствовать в ней непосредственно в первых бета-тестах.
2520.96 2527.96 "Игорь Лабутин" Ну в общем-то все потихонечку развивают продукты, двигают под новые фичи, так что нормально.
2527.96 2556.96 "Игорь Лабутин" К новым фичам, я про тот hot reload, вот этот самый, я все говорил попозже, попозже, давай все-таки про hot reload, у нас есть отдельная статья конкретно про него, и смысл hot reload, мы тоже его уже много раз обсуждали, в том, что вы можете модифицировать исходники вашего приложения, ну менеджмент конечно исходники, пока приложение запущено, и при этом не надо его там и пересобирать, не даже на самом деле ставить на паузу, или там breakpoint останавливать, просто вы C# файлик модифицировали, у вас магическим образом поменялось приложение.
2556.96 2619.96 "Игорь Лабутин" Это поддержано Visual Studio 2019-16-11 preview 1, и пока требует подключенного дебаггера, то есть вы не можете просто так из Visual Studio это делать, вы должны именно отлаживать приложение, при этом должна быть выключена отладка native кода, то есть вы не можете это делать в микс моде, и после этого вы просто меняете ваш C# код, не надо ничего даже сохранять на диск, жмете кнопочку apply code changes, новая кнопочка такая появилась, и ваше приложение магическим образом начинает работать по-другому. То же самое можно сделать из command line, в этом случае вы должны использовать preview 4, свежевышедший, затаргетить приложение в dotnet 6, добавить в launch settings json строчку про hot reload profile, чтобы это было aspen-adcore, обязательно запустить проект с помощью dotnet watch, ну и соответственно проверить в output, что он написал, что да, все правильно, hot reload включен, и дальше меняете ваш код, тут уже придется файлики сохранять на диск, потому что dotnet watch именно за ними следит, ну и все будет работать.
2619.96 2630.96 "Игорь Лабутин" В принципе это будет работать и для blazor wasmo, и даже для winform, для winform придется все-таки launch settings json руками создать, потому что по дефолту он не создается.
2630.96 2635.96 "Игорь Лабутин" Пока это все, над чем он будет работать, но планы большие, это будет расширяться и так далее.
2635.96 2644.96 "Игорь Лабутин" Во-первых, они хотят сделать hot reload и для андроида, и для ios, и для mac os, а не только для винды.
2644.96 2649.96 "Игорь Лабутин" Потом хочется hot reload сделать для razor pages, сейчас это не работает, сейчас это работает только для c#.
2649.96 2660.96 "Игорь Лабутин" Хотят сделать так, чтобы в студии не требовался отладчик, и уменьшить количество вещей, которые нельзя делать так, чтобы это можно было за хот релоадить.
2660.96 2673.96 "Игорь Лабутин" Как я говорил когда-то в прошлых подкастах, эта штука очень похожа на edit and continue, если вы помните когда-нибудь пользователь этой фичи, вы там периодически что-нибудь поедите, он говорит, а нет, вот такой едит я не смогу, простите, в рантайм пропихнуть, короче, перезапускай приложение.
2673.96 2676.96 "Игорь Лабутин" Вот количество таких штук будет уменьшаться.
2676.96 2679.96 "Игорь Лабутин" Ну и для тех, кто пишет на f#, на f# такого не поддержано.
2679.96 2681.96 "Анатолий Кулаков" Только c#, пока.
2681.96 2689.96 "Анатолий Кулаков" Только hardcore. Ну, я надеюсь, что в будущем они это все причешут, и там уберется дебаггер, уберется вот эта кнопочка, уберется там какое-нибудь сохранение.
2689.96 2696.96 "Игорь Лабутин" Ну, кнопочку я бы оставил, потому что я не уверен, что любое изменение хочется сразу релоадить.
2696.96 2701.96 "Анатолий Кулаков" Мне кажется, если у тебя сборка может откомпилиться, то ее можно релоадить.
2701.96 2702.96 "Игорь Лабутин" Ну может быть, может быть, да.
2702.96 2711.96 "Анатолий Кулаков" По крайней мере большинство веб разработчиков работают именно в таком режиме, они фигачат код, и если этот код более-менее валидный, проходит там какие-нибудь линтеры, то значит его можно показать, почему бы и нет.
2711.96 2716.96 "Игорь Лабутин" Ну окей, давай попробуем так. Посмотрим, к чему приведет. Будем как хронтенд разработчики.
2716.96 2718.96 "Анатолий Кулаков" Ну-ну-ну, ты насильно там меня не оскорбляй.
2718.96 2721.96 "Анатолий Кулаков" Так, давай у нас пойдем еще про новинкам.
2721.96 2733.96 "Анатолий Кулаков" Одно из тоже таких новинок, очень сильно ожидаемых, в которые очень много вкладывается сил, новинок .NET 6 будет Profile Guided Optimization, или сокращенно называется PGO.
2733.96 2743.96 "Анатолий Кулаков" И вот недавно вышла статья, в которой одни из основных разработчиков этой волшебной магии пытаются нам рассказать, а что же это такое.
2743.96 2751.96 "Анатолий Кулаков" Наверное, в будущем, ближе к релизу, мы позовем какого-нибудь большого эксперта, но для начала давайте попробуем сами понять, что же это такое для нашей платформы.
2751.96 2757.96 "Анатолий Кулаков" В принципе, мы такого никогда не видели и никогда не знали, что так можно.
2757.96 2759.96 "Анатолий Кулаков" Но оказывается, так бывает.
2759.96 2763.96 "Анатолий Кулаков" Итак, прежде всего, PGO. Что же это такое?
2763.96 2771.96 "Анатолий Кулаков" Это специальная технология, набор различных алгоритмов, форматов, библиотек, компонентов, которые реализуют следующий подход.
2771.96 2779.96 "Анатолий Кулаков" Это специальная техника, которая помогает улучшить производительность вашей программы с помощью учета какой-то дополнительной информации.
2779.96 2783.96 "Анатолий Кулаков" Эта дополнительная информация собирается во время работы приложения.
2783.96 2797.96 "Анатолий Кулаков" Не только во время компиляции кода, как это делает, допустим, обычный компилятор, не только в рантайме, как это делает JIT, не только по тем данным, которые у него уже есть, а по тем данным в зависимости от того, как ваше приложение работает.
2797.96 2809.96 "Анатолий Кулаков" То есть на уровне компилятора компилятор думает, что весь возможный код, который вы написали, весь возможный workflow с ним, он может случиться, он обязательно может произойти.
2809.96 2816.96 "Анатолий Кулаков" В рантайме на самом деле происходит абсолютно не все под множество, а довольно-таки маленькое-маленькое.
2816.96 2824.96 "Анатолий Кулаков" Например, если вы бежите по массиву из целых чисел, то компилятор думает, что это целые числа могут быть от min и int до max int.
2824.96 2832.96 "Анатолий Кулаков" Но на самом деле, если вы прогоняете вашу программу и посмотрите, то по правде вы бежите по аргументным командам строки, и их там не может быть больше 256.
2832.96 2836.96 "Анатолий Кулаков" И на основании вот этих магических знаний можно строить дополнительные оптимизации.
2836.96 2851.96 "Анатолий Кулаков" Прежде всего PGO помогает компилятору, в данном случае это Regit, находить правильные решения, то есть каким образом Regit может правильно заоптимизировать подобные классы, подобный workflow.
2851.96 2859.96 "Анатолий Кулаков" То есть вот эта техника, она дает какое-то знание о возможности того, что может случиться.
2859.96 2871.96 "Анатолий Кулаков" Это как будто у компилятора появился такой своеобразный предсказыватель, который на каждую оптимизацию мог бы предсказать, а какой шанс того, что эта оптимизация сработает, и с какой вероятностью в процентах она сработает.
2871.96 2881.96 "Анатолий Кулаков" И, соответственно, компилятор может прооптимизировать вашу программу в зависимости от того, каким образом ваша программа работает и какие данные она в этот момент обрабатывает.
2881.96 2889.96 "Анатолий Кулаков" PGO работает на основании того, что анализирует поведение программы и, соответственно, те данные, с которыми программа общается.
2889.96 2897.96 "Анатолий Кулаков" Может быть вы, если сталкивались часто с алгоритмами, знаете, что существуют алгоритмы под определенные данные.
2897.96 2900.96 "Анатолий Кулаков" Например, те же самых алгоритмов сортировки, и их великое множество.
2900.96 2906.96 "Анатолий Кулаков" И какой из них самый лучший сказать сложно, потому что это зависит от того, а какие данные вы сортируете.
2906.96 2913.96 "Анатолий Кулаков" Если в этих данных дубликаты, насколько они разбросаны, может ли быть уже, например, массив отсортированный.
2913.96 2922.96 "Анатолий Кулаков" То есть, допустим, во многих алгоритмах, во многих системах выбирают те алгоритмы, которые могут очень быстро задетектировать уже отсортированный массив и не сортировать его заново.
2922.96 2931.96 "Анатолий Кулаков" Иногда эта проверка выполняется намного быстрее, и отсортированные массивы приходят намного чаще, чем если бы вы всегда его всортировали.
2931.96 2936.96 "Анатолий Кулаков" То есть, все эти алгоритмы, они зависят как раз от тех данных, которые в них засунуты.
2936.96 2940.96 "Анатолий Кулаков" В принципе, вот по похожему принципу и работает PGO.
2940.96 2956.96 "Анатолий Кулаков" То есть, он смотрит на те данные, на то поведение, на то workflow, которое обычно встречается в приложении, и в принципе подсказывает G2, каким образом быстрее провести компиляцию, какой алгоритм быстрее может сработать здесь.
2956.96 2961.96 "Анатолий Кулаков" И, соответственно, сам PGO затрагивает очень много компонентов.
2961.96 2970.96 "Анатолий Кулаков" То есть, это не только JIT, это не только компилятор, это не только статические анализы, это, в принципе, затрагивает практически весь фреймворк.
2970.96 2973.96 "Анатолий Кулаков" Подобная технология - это не какое-то ноу-хау или изобретение.
2973.96 2981.96 "Анатолий Кулаков" В принципе, все теоретические материалы еще были известны 30 лет назад, и во многих языках уже Profile Guide Optimization успешно работает.
2981.96 2989.96 "Анатолий Кулаков" Например, один из самых старых, самых проверенных, самых надежных PGO существует в MS-VC.
2989.96 2992.96 "Анатолий Кулаков" Это C-шный компилятор от Microsoft.
2992.96 3001.96 "Анатолий Кулаков" То есть, в плюсах он есть, естественно, он есть уже давно в JVM, в JavaScript очень много оптимизации на основании этого делается.
3001.96 3010.96 "Анатолий Кулаков" Ну, то есть, уже много-много проверенных алгоритмов, и Microsoft надеется не только содрать то, что уже есть, но и привести много своих ноу-хау.
3010.96 3014.96 "Анатолий Кулаков" Итак, давайте посмотрим, какие проблемы встали прежде всего перед разработчиками.
3014.96 3030.96 "Анатолий Кулаков" Прежде всего, это построение вот этого Data Pipeline, который собирает и передает данные между различными компонентами, и учитывает эти данные, которые были заколлекчены на одном запуске, он их может учитывать и для следующего запуска.
3030.96 3038.96 "Анатолий Кулаков" То есть, если ваше приложение натренировалось на одних данных, то при следующем запуске он уже будет для этих данных работать гораздо быстрее, теоретически.
3038.96 3044.96 "Анатолий Кулаков" Также перед разработчиками стала задача правильного представления формата.
3044.96 3053.96 "Анатолий Кулаков" То есть, этот формат должен был хорошо сохраняться, он должен был хорошо передаваться, а самое главное, что он должен был хорошо вести себя между различными версиями.
3053.96 3070.96 "Анатолий Кулаков" То есть, если ваш фреймворк проапгрейдился, или может быть даже изменился формат или еще что-нибудь, вот те данные, которые были наколлекчены, вот этот профиль, он старается сохраняться между версиями, старается не корраптиться.
3070.96 3084.96 "Анатолий Кулаков" Дальше было много копий Solomon O2 модель, с помощью которой можно представить вот такие оптимизированные workflow, каким образом эту модель можно применять, собирать и вообще использовать в наших алгоритмах.
3084.96 3089.96 "Анатолий Кулаков" Ну и огромная большая часть сложностей - это непосредственно сами алгоритмы.
3089.96 3096.96 "Анатолий Кулаков" То есть, что именно можно прооптимизировать, в каких компонентах это лучше всего сделать, как это передать, где это учесть.
3096.96 3105.96 "Анатолий Кулаков" И разработчики, честно признаются, что на улучшение этой части, то есть на алгоритмы, уйдут еще многие-многие годы.
3105.96 3113.96 "Анатолий Кулаков" Поэтому эти оптимизации будут нас радовать непосредственно, не только в момент релиза, но еще и во многих будущих релизах впереди.
3113.96 3117.96 "Анатолий Кулаков" Будем разбирать их, смотреть, что интересного смогут придумать для нас разработчики.
3117.96 3120.96 "Анатолий Кулаков" Итак, какие же бенефиты нас все-таки ждут на ближайшее время?
3120.96 3127.96 "Анатолий Кулаков" В ближайшее время, так называемый Dynamic PGO, он является расширением Tilet компиляции.
3127.96 3141.96 "Анатолий Кулаков" То есть, если ваше приложение уже использовало Tilet компиляцию, то вы при апдейте на .NET 6 получите уже бенефиты с помощью PGO и, может быть, получите где-то импругменты.
3141.96 3151.96 "Анатолий Кулаков" Прежде всего, разработчики говорят, что улучшится throwput, то есть на тех программах, которые уже просто переключатся на новый фреймворк.
3151.96 3153.96 "Анатолий Кулаков" Но PGO только этим не ограничивается.
3153.96 3155.96 "Анатолий Кулаков" У него есть огромное число возможностей.
3155.96 3166.96 "Анатолий Кулаков" В частности, в будущем они нам обещают сильно увеличить время старта вашей программы тоже с помощью вот такой вот магии Latency и размер файла.
3166.96 3170.96 "Анатолий Кулаков" Я пока не очень понимаю, каким образом они будут размер файла увеличивать.
3170.96 3179.96 "Анатолий Кулаков" Может быть, тоже найдут куски кода, которые никогда не выполняются официально в вашей программе, несмотря на то, что вы юзаете эти классы и как-то будут их вырезать.
3179.96 3180.96 "Анатолий Кулаков" Ну, посмотрим.
3180.96 3183.96 "Анатолий Кулаков" В общем, много-много такой магии можно сделать.
3183.96 3191.96 "Игорь Лабутин" Ты прямо это классно рассказываешь, но давай мы все-таки поправимся и скажем, что PGO будет уменьшать стартап тайм и пытаться уменьшать размер файла.
3191.96 3198.96 "Игорь Лабутин" А то увеличивать стартап тайм и увеличивать размер файла, я думаю, что PGO найдет, каким образом запихнуть еще десяток нужных далелек, и все будет норм.
3198.96 3204.96 "Игорь Лабутин" Но смотри, это все бенефиты, а есть ли какие-то, скажем так, недостатки, что ли?
3204.96 3215.96 "Игорь Лабутин" То есть, как только есть какая-то такая рантаймовая движуха, то есть, будь то джит, мы все знаем, как мы страдаем от гарбич коллектора, который внезапно может в неожиданное время начать работать и нам все испортить.
3215.96 3224.96 "Игорь Лабутин" Наверняка такая штука, как что-то там динамическое, что нам оптимизирует перформанс, тоже будет как-то, может влиять плохо.
3224.96 3228.96 "Игорь Лабутин" Есть какие-то рассуждения на тему, когда это может не работать или работать плохо?
3228.96 3231.96 "Анатолий Кулаков" Ну, разработчики не так пессимистичны, как ты.
3231.96 3240.96 "Анатолий Кулаков" А они все-таки рассчитывают на то, что их гениальные подходы, их прекрасные современные алгоритмы сделают так, что никаких вообще проблем у вас не будет.
3240.96 3247.96 "Анатолий Кулаков" То есть, во всех ситуациях, которые они знают, они никаких ухудшений не находят и обещают нам, что их вообще не будет.
3247.96 3254.96 "Анатолий Кулаков" Самая большая проблема, которая может случиться, это если ваш профиль натренировался на абсолютно других данных.
3254.96 3266.96 "Анатолий Кулаков" Ну, например, вам пришли какие-то одни данные, да, вы этот профиль запомнили, сохранили, заоптимизировали, а потом ваше приложение начало работать совершенно с другими данными, совершенно по другому алгоритму и совершенно по другому workflow пошло.
3266.96 3269.96 "Анатолий Кулаков" То есть, абсолютно не так, как оно натренировалось.
3269.96 3275.96 "Анатолий Кулаков" И даже при этом случае разработчики говорят, что никакого degradation of performance не будет.
3275.96 3285.96 "Анатолий Кулаков" То есть, у вас будут просто отсутствовать те оптимизации, у вас будут просто отсутствовать те ускорения, которые вы бы ожидали, но программа будет работать так же, как она работает у вас и сейчас.
3285.96 3287.96 "Анатолий Кулаков" То есть, хуже она работать от этого не станет.
3287.96 3290.96 "Анатолий Кулаков" Поэтому вот такая волшебная пилюля без каких-то побочных эффектов.
3290.96 3294.96 "Игорь Лабутин" Прикольно. Ну, ладно, будем смотреть, что из этого получится.
3294.96 3306.96 "Игорь Лабутин" Так, из анонсов у нас есть еще, уже много раз упоминавшись сегодня, Moe, новый кроссплатформенный framework от Microsoft, ну, как новый, Xamarin.Forms немножко переиначенный.
3306.96 3309.96 "Игорь Лабутин" Туда потихонечку допиливают новые фичи.
3309.96 3316.96 "Игорь Лабутин" В четвертом превью туда добавили Blazor WebView, то есть вы можете использовать компонент, который позволит отрендерить ваш Blazor.
3316.96 3321.96 "Игорь Лабутин" Кусочек вебовский внутри обычного, допустим, десктопного приложения.
3321.96 3324.96 "Игорь Лабутин" Добавили такой важный компонент, как SplashScreen.
3324.96 3327.96 "Игорь Лабутин" Теперь можно использовать прям SplashScreen при старте приложения.
3327.96 3332.96 "Игорь Лабутин" И добавили, наверное, более важную фичу под названием RawAssets.
3332.96 3350.96 "Игорь Лабутин" То есть теперь вы можете какие-то файлики, например, HTML, которые вы хотите отобразить в том же WebView или еще где-то, пометить как специальный asset, и она будет, ну, грубо говоря, правильно как-то заимбежана внутрь вашего кода, ваших дл, чтобы оно правильно работало.
3350.96 3352.96 "Анатолий Кулаков" Интересно, а чем это отличается от обычных ресурсов?
3352.96 3357.96 "Анатолий Кулаков" То есть мы могли всегда ресурсы пометить определенным атрибутикам, и они включались в dll?
3357.96 3360.96 "Игорь Лабутин" Это хороший вопрос, и у меня нет на него пока ответа. Не знаю.
3360.96 3369.96 "Игорь Лабутин" Надо изучать более детально, но я не работаю пока никак с MAUI, никак его не касаюсь, поэтому пока ничего не могу сказать на эту тему.
3369.96 3393.96 "Игорь Лабутин" Visual Studio Productivity. Действительно, при работе с кроссплатформенным UI раньше была такая проблема, что вам нужно было делать отдельный проект для Android, отдельный проект для iOS, отдельный проект еще для чего-нибудь, и запускать нужный вам кусочек, несмотря на то, что код-то, в общем-то, кроссплатформенный, если даже вы не используете какие-то нативных API, все равно нужно было иметь по одному проекту на каждую платформу.
3393.96 3404.96 "Игорь Лабутин" Теперь у вас есть один проект, это называется Single Project Run Feature, и у вас в меню Visual Studio появятся дополнительные подпункты для запуска на разных платформах.
3404.96 3407.96 "Игорь Лабутин" Ну и ход релод, куда же без него, тоже завезли.
3407.96 3443.96 "Игорь Лабутин" Кроме того, Microsoft говорит, это уже не относится напрямую к MAUI-релизу или превью, но потихонечку подтягиваются сторонние компоненты, то есть Telerik уже реализовал какие-то контроллы для MAUI, Syncfusion, DevExpress готовятся, у них, по-моему, есть какие-то даже то ли планы, то ли превьюшки, и фреймворки типа Prisma, то есть MVVM, различные фреймворки и прочие такие штуки, уже есть Early Preview, так что экосистема потихонечку готовится к тому, что MAUI выйдет в ноябре, и на нем можно будет уже нормально писать, я надеюсь.
3443.96 3464.96 "Анатолий Кулаков" Прекрасно, мы наконец получим наш кроссплатформенный UI, о котором так давно мечтали, официальный, естественно, неофициальных у нас уже было, вот теперь что-то будет официальное, посмотрим, к чему это приведет, может, наконец-то на Linux появятся нормальные desktop приложения, и Mac OS будет не такая некрасивая, привнесем в нее нотку нашей виндовой романтики.
3464.96 3467.96 "Игорь Лабутин" Да, квадратные кнопочки, Inform Style.
3467.96 3469.96 "Анатолий Кулаков" Да, да, и большие тормоза на GPU.
3469.96 3494.96 "Анатолий Кулаков" Так, давай смотри, под конец у меня тут есть интересная цифровая темка, здесь .NET Foundation запустила опросничек среди своих каналов, то есть она использовала социальные сети .NET Foundation, какие-то ленты рассылки, веб-сайты, ну то есть люди, которые непосредственно связаны с open-source, с .NET, вот они полностью профилированы, и собрала интересные вопросики.
3494.96 3498.96 "Анатолий Кулаков" Давай, я тут выбрал самые интересные из них, посмотрим немножко на циферки.
3498.96 3509.96 "Анатолий Кулаков" Прежде всего, это, наверное, такой первый большой глобальный опрос от .NET Foundation, она обещает, что будет делать его каждый год, и поэтому мы сможем наблюдать интересную динамику в циферках.
3509.96 3520.96 "Анатолий Кулаков" Был он от 1 ноября 2020 года до 31 марта 2021 года, и собрал 4500 ответов, что довольно-таки неплохо.
3520.96 3527.96 "Анатолий Кулаков" Вот, я сам в нем участвовал, много интересных диких вопросов там было, ну, давай не суть, не к этому.
3527.96 3528.96 "Анатолий Кулаков" Что у нас есть интересного?
3528.96 3531.96 "Анатолий Кулаков" Прежде всего, какие приложения вы пишете?
3531.96 3542.96 "Анатолий Кулаков" Нужно сказать, что это большинство случаев все-таки .NET разработчики, лояльно относящиеся к .NET, к C#, к Microsoft и так далее, то есть ничего такого вы не увидите особого.
3542.96 3545.96 "Анатолий Кулаков" Какие приложения пишут у нас .NET разработчики?
3545.96 3557.96 "Анатолий Кулаков" Можно было выбирать, естественно, несколько ответов, то есть обычно мы в мире не пишем какое-то одно приложение всю жизнь, а как-то распределяем свои задачи среди разных типов, поэтому на большие проценты не удивляйтесь.
3557.96 3566.96 "Анатолий Кулаков" Прежде всего, это большинство людей, большинство разработчиков пишут веб-сервисы и API-сервисы, это 80%, что довольно неплохо.
3566.96 3580.96 "Анатолий Кулаков" Дальше идут веб-приложения, консольные приложения пишут 58%, остальные часто затрагивают библиотеки, микросервисы, и вот интересная еще графа, это десктоп-приложения.
3580.96 3582.96 "Анатолий Кулаков" Десктопами занимается у нас 42%.
3582.96 3590.96 "Анатолий Кулаков" У незнающих слоев населения давно закрепилось такое ошибочное мнение, что .NET-чики в основном пишут информы для десктопчиков.
3590.96 3595.96 "Анатолий Кулаков" Ну вот, формы они все еще пишут, но буквально 42%.
3595.96 3601.96 "Анатолий Кулаков" То есть, основная задача все-таки это микросервисы, API-приложения и полноценные серверные приложения.
3601.96 3606.96 "Анатолий Кулаков" Мобилками занимается 24% опрошенных и всего 9% в играх.
3606.96 3613.96 "Анатолий Кулаков" Я надеялся, что на волне Unity эта цифра будет немножко больше, 9% как-то маловато.
3613.96 3617.96 "Игорь Лабутин" Мне кажется, что я бы сказал, что это довольно неплохо.
3617.96 3626.96 "Игорь Лабутин" Unity, оно конечно есть, но Unity не покрывает 100% геймдева, и это довольно узкий сегмент, как мне кажется.
3626.96 3630.96 "Игорь Лабутин" Мне кажется, что 9% уже неплохо.
3630.96 3631.96 "Игорь Лабутин" Одна десятая часть.
3631.96 3643.96 "Анатолий Кулаков" Я еще рискну предположить, что Unity не сильно общается именно с C-Sharper, с .NET, и может быть не очень следит за .NET Foundation, поэтому их в этом вопросе не слишком много.
3643.96 3645.96 "Анатолий Кулаков" Может быть, эта цифра нерепрезентативна.
3645.96 3653.96 "Игорь Лабутин" Да, а тем более, если мы посмотрим, например, на следующий раздел, про то, под какую версию .NET вы пишете, то тут меня очень удивили результаты.
3653.96 3656.96 "Игорь Лабутин" .NET 5 выбрали 62% человек.
3656.96 3660.96 "Анатолий Кулаков" И это при том, что .NET 5 появился не так уж давно.
3660.96 3663.96 "Анатолий Кулаков" Мне тоже кажется, что огромный уровень adoption.
3663.96 3666.96 "Анатолий Кулаков" Отлично, мне кажется, прекрасно.
3666.96 3671.96 "Анатолий Кулаков" На .NET Core 3.1 сидит практически 60%, тоже неплохо.
3671.96 3674.96 "Анатолий Кулаков" В принципе, на Core уже очень много народу переехало.
3674.96 3680.96 "Анатолий Кулаков" И старичок .NET Framework 4 покрывает где-то 42% всех разработчиков.
3680.96 3683.96 "Анатолий Кулаков" Тоже держит еще огромную долю рынка.
3683.96 3686.96 "Анатолий Кулаков" У Mono и Xamarin где-то 20%.
3686.96 3690.96 "Анатолий Кулаков" Доля, скорее всего, будет уменьшаться и уменьшаться.
3690.96 3694.96 "Анатолий Кулаков" А еще у нас есть один интересный пласт.
3694.96 3697.96 "Анатолий Кулаков" Это .NET Framework 3.5 и ранее.
3697.96 3698.96 "Анатолий Кулаков" Все, что меньше.
3698.96 3703.96 "Анатолий Кулаков" На нем сидит 6%, что в принципе довольно-таки мало, и это прекрасно.
3703.96 3712.96 "Анатолий Кулаков" То есть все-таки разработчики стараются хорошо мигрировать на новые версии и не задерживают свои продукты на старых уже морально уставевших фреймворках.
3712.96 3717.96 "Игорь Лабутин" Ты говорил, что мы много пишем вебапишек, и следующий раздел это подтверждает.
3717.96 3724.96 "Игорь Лабутин" SPnet вебапи используют 73%, при этом к ним в довесок есть еще SPnet MVC.
3724.96 3730.96 "Игорь Лабутин" Это 52%, и где-то между ними расположился Entity Framework с 60%.
3730.96 3737.96 "Игорь Лабутин" Это называлось .NET Application Module, что включает в себя довольно общий термин.
3737.96 3741.96 "Игорь Лабутин" Сложно отделить, может быть, MVC от Entity Framework.
3741.96 3746.96 "Игорь Лабутин" Оказалось, без разных областей, но тем не менее они попали в единую категорию.
3746.96 3748.96 "Игорь Лабутин" В единый вопрос.
3748.96 3752.96 "Игорь Лабутин" Есть WPF 30%, Blazor 28 внезапно.
3752.96 3754.96 "Игорь Лабутин" Для меня это был довольно большой результат.
3754.96 3756.96 "Игорь Лабутин" Практически догнал WPF среди опрошенных.
3756.96 3758.96 "Игорь Лабутин" Это удивительно.
3758.96 3768.96 "Анатолий Кулаков" Да, Blazor это тоже довольно взрывной рост показывает, что догнал самый популярный WPF, потому что WPF уже толкается много-много лет.
3768.96 3772.96 "Анатолий Кулаков" А Blazor это буквально за пару лет релиза практически догнал.
3772.96 3773.96 "Анатолий Кулаков" Меня другое удивило.
3773.96 3775.96 "Анатолий Кулаков" Ты видишь в ответах WinForms?
3775.96 3776.96 "Анатолий Кулаков" Нет, не вижу.
3776.96 3778.96 "Анатолий Кулаков" Вот WinForms совсем нет.
3778.96 3786.96 "Анатолий Кулаков" Я бы поверил, если бы WPF несколько раз перегнал, и WinForms было ничтожно мало, но ее вообще нет.
3786.96 3788.96 "Анатолий Кулаков" Она потерялась где-то там в Aversах.
3788.96 3790.96 "Анатолий Кулаков" И вот это удивительно.
3790.96 3792.96 "Анатолий Кулаков" Где все эти разработчики?
3792.96 3798.96 "Анатолий Кулаков" Например, у нас довольно много Legacy Enterprise приложений, которые с WinForms вообще никуда не уйдут.
3798.96 3804.96 "Игорь Лабутин" Это правда, причем даже Microsoft, как мы помним, WinForms дизайнер портировала на новые фреймворки.
3804.96 3809.96 "Игорь Лабутин" То есть Microsoft его сама не бросает, и странно было бы не включить этот вопрос.
3809.96 3811.96 "Игорь Лабутин" Или он был, но просто никто не ответил.
3811.96 3812.96 "Игорь Лабутин" Непонятно, не помню.
3812.96 3814.96 "Анатолий Кулаков" Может поснестялись люди, да?
3814.96 3821.96 "Анатолий Кулаков" К сожалению, дотнет-разработчикам в последнее время приходилось сталкиваться с SPA-фреймворками.
3821.96 3827.96 "Анатолий Кулаков" И в этот вопрос также включили, какие SPA-фреймворки вы используете, если используете.
3827.96 3829.96 "Анатолий Кулаков" И на первом месте был Angular.
3829.96 3832.96 "Анатолий Кулаков" Он завоевал где-то 30% опрошенных.
3832.96 3835.96 "Анатолий Кулаков" Но опять же, меня порадовало второе место.
3835.96 3837.96 "Анатолий Кулаков" Blazor - 28%.
3837.96 3843.96 "Анатолий Кулаков" То есть несмотря на то, что Angular нам заталкивает в глотку уже много-много лет, пришел Blazor и уверенно вообще рвется вперед.
3843.96 3846.96 "Анатолий Кулаков" Еще чуть-чуть и Angular обгонится.
3846.96 3848.96 "Игорь Лабутин" Ну они все три тут рядышком.
3848.96 3851.96 "Игорь Лабутин" Angular, Blazor, React - 30, 28, 27.
3851.96 3855.96 "Игорь Лабутин" То есть FrontEnd, по крайней мере, по этому вопросу, кажется, пишут на всем.
3855.96 3865.96 "Игорь Лабутин" Причем у меня есть какое-то такое впечатление, что вот связка React + .NET не так популярна, по крайней мере по разговорам, как связка Angular + .NET.
3865.96 3871.96 "Игорь Лабутин" Было бы такое мнение, что там каким-нибудь питончикам берут чаще React, а с .NET почему-то берут чаще Angular.
3871.96 3876.96 "Игорь Лабутин" То ли потому, что там язык, то хотят TypeScript и TypeScript, непонятно.
3876.96 3884.96 "Игорь Лабутин" Но действительно, Angular несколько лет назад, по крайней мере, казался более популярным, сейчас кажется, что все подравняется.
3884.96 3890.96 "Анатолий Кулаков" И 22% опрошенных из этого списка сказали, что они вообще не пишут Single Page Аппликейшены.
3890.96 3892.96 "Анатолий Кулаков" 22% держитесь, мужики, я с вами.
3892.96 3895.96 "Игорь Лабутин" Development Tools, Visual Studio - 90%.
3895.96 3898.96 "Игорь Лабутин" Подавляющее большинство народу пишет в Visual Studio.
3898.96 3901.96 "Анатолий Кулаков" Да, да, все-таки Visual Studio еще много.
3901.96 3905.96 "Анатолий Кулаков" Я надеялся, что немножко хотя бы позиции ее пошатнутся.
3905.96 3907.96 "Анатолий Кулаков" Но нет, 90% в Visual Studio.
3907.96 3911.96 "Анатолий Кулаков" На втором месте находится, кстати, Visual Studio Code - 78%.
3911.96 3918.96 "Анатолий Кулаков" То есть очень много разработчиков веб-приложений и API'ев использует Visual Studio Code.
3918.96 3921.96 "Анатолий Кулаков" Не самый удобный, надо сказать, инструмент для этих целей.
3921.96 3923.96 "Анатолий Кулаков" Не понимаем, почему у него такие большие позиции.
3923.96 3933.96 "Игорь Лабутин" Ну, возможно, если у тебя есть, грубо говоря, основной инструмент Visual Studio, тебе иногда нужно немножко поправить какой-нибудь фронтенд, то для этой цели сойдет Visual Studio Code.
3933.96 3941.96 "Игорь Лабутин" Если ты там профессиональный фронтенд-разработчик, понятно, что ты будешь искать какой-то более профессиональный фронтендерский инструмент от JetBrains или еще от кого.
3941.96 3950.96 "Анатолий Кулаков" Ну, кстати, да, нужно признаться, что для фронтенда, всяких для скриптовых языков, для какого-нибудь быстрофиксов Visual Studio Code сейчас является одним из самых популярных инструментов.
3950.96 3954.96 "Анатолий Кулаков" Если мы не говорим все-таки про C# и большие интерфейсные приложения.
3954.96 3958.96 "Игорь Лабутин" Ну, и тем и поэтому она и завоевала такую большую долю рынка.
3958.96 3964.96 "Игорь Лабутин" Дальше стоит GitHub, это тоже такой себе Development Tool, но тем не менее половина народа пользуется GitHub.
3964.96 3967.96 "Анатолий Кулаков" Да, интересно, что они имели в виду под Toolом GitHub.
3967.96 3970.96 "Анатолий Кулаков" Ну, наверное, да, люди пользуются GitHub, сложно отрицать.
3970.96 3980.96 "Игорь Лабутин" Нет, ну, GitHub в каком-то смысле это тоже майкрософтовский тул, можно сказать теперь, да, и было интересно, насколько им много народу пользуется.
3980.96 3983.96 "Игорь Лабутин" И райдеру достались 20%.
3983.96 3987.96 "Анатолий Кулаков" Да, 20%, в принципе, немного, но довольно хороший существенный кусок.
3987.96 3995.96 "Анатолий Кулаков" Мне кажется, среди моих знакомых, тех, кого я опрашивал, у райдера довольно больше фанатов, чем в этом вопросе.
3995.96 4017.96 "Игорь Лабутин" Ну, да, ну, то есть, опять же, вопрос о репрезентативности, и не проводилось, я так понимаю, никакой анализ этих, распределения ответов в зависимости от региона, еще от чего-то, от роли, насколько ты там джун, не джун, сеньор, не сеньор, что ты пишешь, реинформы, там, ВПФ или АПИшки, потому что…
4017.96 4031.96 "Анатолий Кулаков" Ну, да, это, наверное, слишком сложно, но, кстати, скорее всего, такие ответы можно вытащить, эти сырые данные, наверное, можно достать, я не видел ссылок, но так как это foundation, мне кажется, они должны предоставить открытый доступ к этим данным, можно попробовать проанализировать.
4031.96 4038.96 "Анатолий Кулаков" Смотри, следующая интересная штука, как из 100% опрошенных в интернете показали, что 100% пользуются интернетом.
4038.96 4043.96 "Анатолий Кулаков" Какой язык вы используете? C#, 95%, неудивительно?
4043.96 4045.96 "Анатолий Кулаков" Вообще неудивительно.
4045.96 4065.96 "Анатолий Кулаков" Вот, пойдем дальше, на втором месте JavaScript, все-таки людей заставляют писать на JavaScript, это 55%, и TypeScript 45%, вот, ну, я так подозреваю, все, кто использует TypeScript, они обязательно сталкиваются непосредственно с JavaScript, поэтому эти два пункта выбирали одинаково, ну и кто-то на чистом JavaScript тоже как-то мучается.
4065.96 4086.96 "Анатолий Кулаков" Вот, а на четвертом месте, в принципе, даже удивительно, там стоит Python, Python у .NET разработчиков занимает 18% всех разработчиков, которые участвовали в опросах, и это связано как раз-таки с популярностью ML, Artificial Intelligence и вот этих прочих машинно-лёрнинговых вещей.
4086.96 4089.96 "Игорь Лабутин" Ну и скриптики, может, какие-нибудь тоже дополнительные, чего-нибудь нет.
4089.96 4092.96 "Анатолий Кулаков" Да, да, скриптики автоманизации тоже на нем, наверное, хорошо пойдут.
4092.96 4096.96 "Анатолий Кулаков" Ну и уже после Python с 11% тянется F#.
4096.96 4104.96 "Игорь Лабутин" Опять же, 11% не так мало, мне кажется, наверное, F#-комьюнити хотела бы, чтобы это число было больше, возможно, но я думал, что будет меньше.
4104.96 4106.96 "Анатолий Кулаков" Ну, допустим.
4106.96 4116.96 "Анатолий Кулаков" Также .NET разработчики используют в своих работах C++, Visual Basic, Go, Rust, ну, в принципе, много других популярных языков, здесь нет ничего удивительного.
4116.96 4119.96 "Игорь Лабутин" Да, вот следующий момент был мне очень интересен, следующий пункт.
4119.96 4121.96 "Игорь Лабутин" Какие языки вам было бы интересно изучить?
4121.96 4128.96 "Игорь Лабутин" Как вы помните, 95% ответило, что они используют C#, и 38% сказала, что они хотели бы изучить C#.
4128.96 4136.96 "Анатолий Кулаков" Ну, мне кажется, что они просто хотят изучить его глубже, им нужно слушать наш подкаст, мы им расскажем о C# еще больше, абсолютно все.
4136.96 4137.96 "Игорь Лабутин" Наверное, да.
4137.96 4146.96 "Игорь Лабутин" Кроме этого, 33% почти столько же, как C#, хотят изучать Rust, TypeScript, примерно там же, и F#, все примерно там по ровну, 30-33%.
4146.96 4161.96 "Анатолий Кулаков" Нужно сказать, что Rust и F# входят по вопросам в Stack Overflow в языки, которые больше всего нравятся, больше всего привлекают, и там больше всего их хотелось бы поучить, в зависимости от формулировки.
4161.96 4169.96 "Анатолий Кулаков" Вот, TypeScript, скорее всего, ну, скорее всего, потому что в Web-фронтенда приходится делать еще много, и без TypeScript там вообще никуда.
4169.96 4175.96 "Игорь Лабутин" Ну, и не обошлось без Python, Go и JavaScript, но они так, где-то дальше, в хвосте.
4175.96 4177.96 "Анатолий Кулаков" Какие облака вы используете?
4177.96 4185.96 "Анатолий Кулаков" Не знаю, то есть и ожиданно, и неожиданно, но почему-то Microsoft тоже хотят использовать 70% опрошенных.
4185.96 4192.96 "Анатолий Кулаков" Может быть, потому что действительно Microsoft создал такую удобную, хорошую инфраструктуру, которая позволяет дотнет-разработчикам хорошо заинтегрироваться в Azure.
4192.96 4197.96 "Анатолий Кулаков" Ну, как-то мне всегда казалось, что это не сильно большой аргумент, но оказывается, на циферках сильно большой.
4197.96 4204.96 "Игорь Лабутин" Да, ну, дальше идет AWS с 32% и есть Google Cloud с 14%, туда тоже кто-то пользуется дотнетом.
4204.96 4210.96 "Анатолий Кулаков" Еще был вопрос, какие NuGet-пакеты у вас самые популярные в ваших проектах?
4210.96 4221.96 "Анатолий Кулаков" Вот там огромнейший список из разнообразных пакетов, но в пятерку первых входит Entity Framework, Core, Newtonsoft JSON, Dapper, Automapper и Serilog.
4221.96 4227.96 "Анатолий Кулаков" Приятно, что тут не только микрософтовские пакеты есть, но еще и опенсорсные сторонние.
4227.96 4237.96 "Игорь Лабутин" Ну, а в целом, особых сюрпризов нет, это действительно одни из самых, так скажем, часто звучащих NuGet-пакетов в .NET, так что особо без сюрпризов.
4237.96 4247.96 "Игорь Лабутин" Если говорить про опенсорс, то 90% опрошенных относят себя исключительно к консюмерам, то есть они только используют опенсорс, но никак в него не контрибьютят.
4247.96 4255.96 "Игорь Лабутин" Половина народу чуть больше даже контрибьютят, и за это им большое спасибо, потому что без этого опенсорса не будет.
4255.96 4264.96 "Игорь Лабутин" Четверть из опрошенных являются мейнтейнерами хотя бы каких-нибудь пакетов, но тоже вот это число меня удивило, я думал, что будет гораздо меньше.
4264.96 4267.96 "Анатолий Кулаков" Да, довольно большое количество людей.
4267.96 4281.96 "Игорь Лабутин" И при этом 8% спонсируют каким-то образом опенсорс, то есть либо через механизм GitHub спонсорс, либо еще каким-то образом помогают жить разработчикам опенсорсных пакетов, что тоже приятно.
4281.96 4283.96 "Анатолий Кулаков" Да, тоже неплохо.
4283.96 4286.96 "Анатолий Кулаков" И напоследок, какого вы пола.
4286.96 4292.96 "Анатолий Кулаков" 92% у нас оказывается мужчины в Дотнете, и всего лишь 3% женщины.
4292.96 4297.96 "Анатолий Кулаков" Милые девушки, где же вы есть, приходите пожалуйста в Дотнет, мы хорошие, добрые и уютные.
4297.96 4302.96 "Анатолий Кулаков" А также приходите в наш подкастик, у нас тут тоже хорошо, и девушкам мы тоже всегда рады.
4302.96 4305.96 "Игорь Лабутин" Ну и че, на этом наверное можно завершаться сегодня.
4305.96 4306.96 "Игорь Лабутин" Да, да.
4306.96 4311.96 "Игорь Лабутин" Мы сегодня не стали глубоко копать на какие-то особо большие темы, потому что новостей было очень много.
4311.96 4323.96 "Игорь Лабутин" Огромный список новостей в Dotnet 6 Preview 4, вместе с ним вышла соответственно Visual Studio 2019, 2016.10 и 2016.11 Preview 1.
4323.96 4328.96 "Игорь Лабутин" ReSharper Writer обновили свои Roadmap, посмотрим как пойдет Development.
4328.96 4336.96 "Игорь Лабутин" Чуть-чуть более подробно посмотрели на Dotnet Hot Reload, на Profile Guided Optimization и на MAUI Preview 4.
4336.96 4342.96 "Игорь Лабутин" И внимательно рассмотрели результаты опроса Dotnet Foundation в экосистеме Дотнета.
4342.96 4345.96 "Игорь Лабутин" Кто вообще пишет на Дотнете, зачем и чем пользуется.
4345.96 4349.96 "Анатолий Кулаков" Ну на этом все, всем спасибо, всем пока.
4349.96 4350.96 "Анатолий Кулаков" Услышимся, пока.
4350.96 4363.96 "Анатолий Кулаков" Обязательно шар, репост, лайк, ну все это вы знаете, рассказывайте о нас своим друзьям и приходите к нам, главное слушайте нас еще, у нас осталось очень много интересных статейчиков, о них мы поговорим с вами в следующем выпуске.
4363.96 4364.96 "Анатолий Кулаков" Пока.
4364.96 4365.96 "Анатолий Кулаков" Пока.
