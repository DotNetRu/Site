0.00 10.72 SPEAKER_01 Здравствуйте, дорогие друзья, в эфире Радио.нет выпуск номер 62.
10.72 13.20 SPEAKER_01 Сегодня в студии будет Анатолий Кулаков.
13.20 14.20 SPEAKER_01 И Игорь Лобутин.
14.20 15.20 SPEAKER_01 Всем привет.
15.20 25.36 SPEAKER_01 Сначала хотелось бы поблагодарить всех наших помогаторов – Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Илья и Гурий Самарин, а также всех тех, кто пожелал остаться неизвестными.
25.36 30.64 SPEAKER_01 Друзья, большое спасибо за помощь и эти выпуски выходят в частности благодаря вам.
30.64 38.72 SPEAKER_01 Сегодня у нас немножко необычный будет выпуск, и в том же самом смысле обычный, потому что будем говорить мы про .NET и про C#.
38.72 43.16 SPEAKER_01 Ну, в принципе, как и всегда в нашем подкасте мы обсуждаем именно это.
43.16 66.16 SPEAKER_01 Но сегодня мы поговорим как раз-таки про конференцию .NET Conf 2022, на котором было представлено в частности .NET 7, C# 11 и множество вокруг этого всего от лзов, технологий, какие-то новые библиотеки, планов и прочего-прочего.
66.16 80.64 SPEAKER_01 Наверное, стоит сразу на берегу оговориться, что подробно мы обсуждать каждую тему не будем, потому что этим мы как раз-таки и занимались целый год с прошлого релиза .NET, поэтому кому интересно, можете смело переслушивать наши подкасты там за последний год.
80.64 90.92 SPEAKER_01 Информация там практически вся актуальная, не устарела, и где мы в детальностях разобрали в принципе все те новинки, которые сейчас уже предстали перед нами.
90.92 105.56 SPEAKER_01 Цель нашего сегодняшнего выпуска, наверное, быстро пробежаться и в общем обозреть, что в итоге получилось, что у нас за релиз, что он за собой потащил, какие инструменты подтянулись и что он нам вообще готовит, чем мы на ближайший год будем пользоваться.
105.56 106.56 SPEAKER_01 Правильно я говорю?
106.56 107.84 SPEAKER_01 Да, все так.
107.84 120.60 SPEAKER_00 Мы попробуем, так скажем, рассказать про инструменты, тулзы, новинки, библиотеки, фреймворки, которые каким либо образом обновились.
120.60 126.08 SPEAKER_00 Действительно, наверное, 90%, если не больше, мы уже каким-то образом в этом подкасте упоминали.
126.08 142.36 SPEAKER_00 Но составить цельную картину, составить полное понимание, что же у нас такое .NET 7, возможно, это как-то проще запомнить, когда теперь оно свелось все в единый релизный .NET 7, теперь этим можно начинать пользоваться, продакшене, все такое.
142.36 145.44 SPEAKER_00 Так что как раз на этом мы все это и будем смотреть.
145.44 155.48 SPEAKER_01 Ну, я напоминаю, что следующий .NET, который через годик будет, он уже будет LTS, и вот там будет, наверное, уже и больше фич, и больше клиентов, и больше переводов.
155.48 157.28 SPEAKER_01 Ну, то есть LTS, он в Африке LTS.
157.28 173.92 SPEAKER_01 Вот, и чтобы не пропустить этот момент, чтобы, опять же, ушами не хлопать, когда выйдет релиз, смело подписывайтесь на наш подкаст, не теряйте ни одного выпуска, а мы, соответственно, будем вас практически каждый выпуск посвящать в те новинки, которые ждут на вас в LTS.
173.92 180.56 SPEAKER_01 Поэтому рассказывайте о нас своим друзьям, нам шарри, репост, сабскрайб, колокольчики, всеми возможными способами.
180.56 187.36 SPEAKER_01 Подписывайтесь, нам будет приятно, и следите за нашими выпусками, мы будем держать вас в курсе.
187.36 192.28 SPEAKER_00 Начнем, давай на самом деле, действительно, вот мы тут говорим LTS, не LTS, LTS, не LTS.
192.28 197.40 SPEAKER_00 У нас текущий релиз, это не LTS, как он правильно называется, знаешь?
197.40 198.40 SPEAKER_00 - СТС.
198.40 219.08 SPEAKER_00 - СТС, да, ну то есть он раньше назывался Current, теперь он должен называться STS, это LTS, это у нас Long Term Support, то есть релиз, который поддерживается три года с момента выпуска, а Current, который не LTS, или теперь он называется STS, он поддерживается полтора года, то есть ближайший год до ближайшего LTS и еще полгодика после этого, чтобы дать вам время перейти.
219.08 231.96 SPEAKER_00 STS это не Short Term Support, это Standard Term Support, чтобы вы понимали, но я никогда не видел практически, чтобы использовали термин Current, так что, скорее всего, STS тоже вряд ли сильно будут использовать и просто говорить LTS или Non-LTS.
231.96 253.80 SPEAKER_00 Релиз этот, который семерка, он большой, в него довольно много контрибьюшенов и Microsoft отдельно подчеркивает, что очень много всяких open-source внешних контрибьюшенов, то есть в этом релизе поучаствовало по каким-то замерам порядка 8900 внешних контрибьюторов, которые принесли 28000 контрибьютов.
253.80 266.60 SPEAKER_00 Конечно, там, скорее всего, распределение не такое, что все поровну, но почти 9000 внешних человек поучаствовали в том или ином виде в развитии этого релиза, и это прикольно.
266.60 295.56 SPEAKER_00 Дальше, основная цель команды это сделать более-менее унифицированный SDK, то есть чтобы вам не нужно было ставить там SDK такой, SDK секой, SDK эдакий, чтобы вы просто ставите .NET SDK и в нем добавляете, возможно, какие-то нужные части, мы говорили про такую тему как ворклоуды, то есть части SDK идут отдельно, они не ставятся сразу, их нужно добавить потом отдельно, и потом вы полученный, собственно, комплект тулов можете использовать для разработки для тех или иных платформ.
295.56 300.36 SPEAKER_00 И в частности, одной из платформ, над которой велась довольно большая работа, был ARM64.
300.36 328.84 SPEAKER_00 Эта штука, она сейчас трендовая, во-первых, она трендовая в лэптопах в каком-то смысле, потому что там потихонечку армы становятся популярные там, ну и на серверах тоже, дело не отстает, там в Амазоне есть соответствующие, как они, гравитоны, да, в Ажуре, по-моему, тоже что-то появилось, не помню как называется, Ажур Ампер, по-моему так.
328.84 356.40 SPEAKER_00 И Microsoft работает над тем, чтобы .NET на ARM64 работал ну с той же скоростью, как на x64, потому что в рекламе всегда говорится, что ARM процы вам будут дешевле, потому что они потребляют меньше энергии и всё такое, но при этом в старых версиях .NET, которые уже начинали поддерживать ARM64, они, конечно, потребляют меньше электричества, работают эффективнее, но .NET на них работал существенно медленнее, и поэтому хорошо, если тон оттуда и выйдет, а то и медленнее будет.
356.40 361.40 SPEAKER_00 Цель была добиться того, чтобы перформанс был похож на x64.
361.40 380.84 SPEAKER_00 Там были проблемы с атомиками, ARM64 до некоторой версии не поддерживал атомарные записи чтения, ну в смысле типа compare and swap, или load and store, не помню точно, но ещё какую-то из них он не поддерживал, в какой-то версии начал поддерживать, и в .NET это добавили.
380.84 402.12 SPEAKER_00 В векторизацию добавили, поддержку векторных операций, и в результате получили, не только эти два изменения, конечно, было много ещё других, получили, что сейчас по результатам замеров на .NET 7, перформанс подбирался и подбирался, подбирался по мере превьюшек к перформансу на x64, и наконец-таки сравнялся, и даже чуть-чуть превзошёл.
402.12 411.48 SPEAKER_00 Так что в общем-то можно сказать, что более-менее цель достигнута с точки зрения поддержки ARM64.
411.48 431.88 SPEAKER_00 Дальше вторая причина, проблема, не знаю, цель с Unified SDK в том, что этот SDK должен быть унифицирован вообще для всех платформ, куда мы ставимся, то есть работаем ли мы на Windows, работаем ли мы на Linux, на Mac, SDK, ну в смысле инсталлятор, конечно, разный, но с точки зрения того, что вы получаете, должно быть всё более-менее одинаково.
431.88 437.68 SPEAKER_00 В этом смысле есть довольно большая работа, которая делается для Linux, для Ubuntu.
437.68 454.24 SPEAKER_00 Начиная с шестёрки, там .NET поддерживается уже в прям в нативном менеджере пакетов, то есть не нужно качать инсталлятор, можно просто сказать "Up to install .NET 6", и начиная с этого релиза у нас есть прикольные компактные образы про Ubuntu, мы про них поговорим ближе к концу.
454.24 473.28 SPEAKER_00 С точки зрения таргетинга или одной из тоже целей .NET 7, конечно, является большое хайповое движение под названием Cloud Native, то есть всё, что мы пишем, если мы пишем для Web или ещё для чего-то, должно быть, конечно же, Cloud Native.
473.28 485.32 SPEAKER_00 И тут возникает несколько моментов, которых .NET был, ну не то чтобы прям медленный или неудобный, но который всегда можно было что-то улучшить, вот поулучшали.
485.32 488.12 SPEAKER_00 Во-первых, поулучшали поддержку контейнеров, поговорим попозже.
488.12 499.60 SPEAKER_00 Во-вторых, почему-то в анонсе именно в этом месте Microsoft упоминает такой фреймворк как Carlins, мы про Carlins тоже чуть дальше поговорим, почему он в Cloud Native находится, я не очень понял, но тем не менее.
499.60 503.76 SPEAKER_00 Зато там точно находится штука, которая должна быть, это работа с JSON.
503.76 512.84 SPEAKER_00 Пишите ли вы веб-сервисы, или может быть даже если вы пишете какие-то command-line тулы, как ни странно, или что-нибудь ещё, вы довольно много всегда работаете с JSON.
512.84 519.72 SPEAKER_00 И в Dota 7 JSON, стандартный JSON-сериализатор, получил довольно много улучшений и изменений.
519.72 535.68 SPEAKER_00 Во-первых, там теперь стала возможна поддержка полиморфных типов, вы можете указать на родительском типе специальный атрибутик JSON Derived Types и указать список, соответственно, дочерних типов, которые вы хотите уметь реализовывать.
535.68 540.80 SPEAKER_00 Это будет такая статическая полиморфиза, можно сделать динамически, чуть более сложно.
540.80 552.04 SPEAKER_00 И есть ещё специальный атрибут JSON Polymorphic, который позволяет настроить на самом деле то, как всё это работает, что делать, если встретился неизвестный тип, как вообще определять, что за тип.
552.04 559.12 SPEAKER_00 Это делается всё с помощью специального полидискриминатора, как его назвать, ну и в общем, вся кастомизация делается через него.
559.12 563.24 SPEAKER_00 А кроме этого ещё можно делать кастомизацию непосредственно контракта.
563.24 599.40 SPEAKER_00 То есть если, например, у вас есть какой-нибудь класс, может быть ваш, может быть из вообще сторонней библиотеки, в котором у вас нет исходников, но вы хотите либо ваш класс как-то очень хитро сериализовывать в JSON, либо вы хотите этот сторонний класс как-то хитро сериализовывать или десериализовывать из JSON, то теперь стало возможно написать специальный TypeResolver, который сериализатор будет дёргать в моменты, когда он сериализует объекты этого класса, и в этом резолвере определять вообще, что делать с объектом, причём там доступно значение самого объекта, то есть там можно намутить логику типа там "если поле объекта true, то два соседних поля сериализовывать не надо" или наоборот.
599.40 608.12 SPEAKER_00 То есть всякую сложную логику я думаю, что на этой штуке можно там практически полное поведение Newtonsoft'а воспроизвести, хотя на 100% понятно не уверен.
608.12 628.96 SPEAKER_00 А при апдейте .NET естественно обновляется core библиотека, BaseClass library, там довольно много, понятное дело, всяких довольно мелких улучшений, несколько штук были признаны достаточно значимыми, чтобы попасть в главный анонс про релиз .NET 7.
628.96 637.08 SPEAKER_00 Это nullable аннотации на весь namespace Microsoft Extensions, если вы что-то оттуда используете, знайте, теперь это что-то поддерживает nullable.
637.08 654.00 SPEAKER_00 В типы работы с датой и временем, то есть date/time и timeonly/timespan завезли поддержку micro и nanosecond, то есть раньше всё, что меньше, чем миллисекунды, нужно было оперировать тиками, теперь можно работать с микро и наносекундами, есть соответствующие API, ну и оверлоды конструкторов и так далее.
654.00 672.32 SPEAKER_00 В iMemoryCache завезли метрики, я вот на самом деле в своих проектах всё чаще и чаще замечаю, что мы кэшируем через iMemoryCache, и соответственно было бы здорово выставить метрики наружу, в какой-нибудь Prometheus или ещё куда-нибудь, чтобы следить вообще, в каком состоянии эти кэши, теперь это можно сделать.
672.32 683.28 SPEAKER_00 Класс, соответственно, ну интерфейсы класса имеют соответствующие методы, которые вы можете использовать, чтобы всё это выставить наружу в нормальный ваш коллектор-метрик.
683.28 695.68 SPEAKER_00 Ну и поддержка tar-архивов, понятно, что поддержка Linux должна быть, поэтому tar-архивы на Linux довольно популярны, вот оно там есть, плюс оно ещё потребовалось для докера, как оказалось.
695.68 701.92 SPEAKER_00 В SDK в целом изменений не так много, именно с точки зрения тулинга, вот .NET тулинга.
701.92 707.88 SPEAKER_00 Понятно, что там есть всякие разные изменения, типа .NET watch, там всякие смайлики завезли, это в одном из первых превьюшек, мне кажется, было.
707.88 710.64 SPEAKER_00 Hot reload, там вот теперь всякие иконочки рисуют.
710.64 723.32 SPEAKER_00 Появилась возможность нормального автодополнения в команде .NET new, там теперь какой-то более клёвый парсер и тап комплешн.
723.32 743.44 SPEAKER_00 Ну и темплетики, то есть шаблоны проектов, которые вы можете создавать в .NET new и которые вы можете, честно говоря, создавать сами, теперь можно создавать, появилось возможность ограничений, то есть можно сказать, что если вы там создаете в таком-то ворклоуде, то вот этот шаблон теперь неприменим, ну и так далее.
743.44 748.84 SPEAKER_00 Есть возможность какую-то условную, грубо говоря, доступность шаблонов организовать.
748.84 753.60 SPEAKER_00 Последняя секция в большой статье анонса — это про перформанс.
753.60 762.36 SPEAKER_00 Куда же без перформанса, мы весь год говорили про перформанс, по-моему, ни один превью у нас не был без новостей о перформансе, то ли иные штуки.
762.36 766.68 SPEAKER_00 Ну в перформансе три главных вещи, которые произошли.
766.68 768.56 SPEAKER_00 Во-первых, это онстайк реплейсмент.
768.56 796.60 SPEAKER_00 У нас был уже то, что называется tired compilation, ну и здесь, это было уже в шестом .NET, но проблема с ним была в том, что он не мог подменять функции, то есть смысл в чём, что если какая-то функция или какой-то кусок кода используется чаще, чем обычно, то есть количество вызовов этого кода превышает некоторый порог, то он перекомпилировался более оптимально и ссылка на него подменялась.
796.60 800.60 SPEAKER_00 Проблема в том, что если вы это сделали для функции, которая сейчас исполняется, ну как бы подменить её сложно.
800.60 801.60 SPEAKER_00 Вот теперь можно.
801.60 813.44 SPEAKER_00 .NET 7 умеет это делать, если у вас есть большой цикл в функции, то как раз .NET 7 умеет теперь перекомпилировать и подменять такие функции, даже пока они выполняются.
813.44 816.84 SPEAKER_00 File Guided Optimization туда же и Native OUT.
816.84 837.20 SPEAKER_00 Native OUT в семёрке получил прям очень хороший boost, он работает, ну как я понял, довольно неплохо для всяких разных таких классических ворклоудов типа консольных приложений, ASP.NET Core, а не, если ASP.NET Core как раз не работает, там Reflection сейчас много пока ещё, и про это ведутся активные разговоры, как бы так сделать, чтобы заработало.
837.20 840.80 SPEAKER_00 Но есть эксперименты по всяким WinForm и прочим.
840.80 856.76 SPEAKER_00 При этом Native OUT там работали довольно хорошо над всяким триммингом и прочим, пустая консольная приложенка, которая скомпилирована в Native OUT на винде, сейчас занимает 3,6 мегабайта, то есть в общем-то уже, ну, более-менее разумный размер.
856.76 871.00 SPEAKER_00 Но понятно, что как только вы начнёте тащить внутрь всякие зависимости, в зависимости от того, насколько хорошо для них определены настройки тримминга, размер может резко поползти наверх, потому что все эти зависимости будут упакованы в этот single file.
871.00 875.08 SPEAKER_00 Ну и говоря про performance, нельзя не сказать, конечно, про бенчмарки.
875.08 885.32 SPEAKER_00 Если вы посмотрите открывающий видосик с .NET Conf, там будет сказано, что .NET 7, он, короче, круче, крут-крут-крут, он круче Go, он круче Node.js, он круче кого?
885.32 886.32 SPEAKER_00 Java.
886.32 888.24 SPEAKER_00 Понятно, ну короче, мы круче всех.
888.24 902.16 SPEAKER_00 Это всё основано на техэмпауэре, верить ему надо с большими-большими оговорками, и там на самом деле несколько тестов на ASP.NET Core, смотреть надо только на некоторые, и смотря что вы хотите добиться, какую информацию вы хотите узнать.
902.16 918.16 SPEAKER_00 Про это есть отдельная большая статья, мы про неё, наверное, поговорим, постараемся в следующем выпуске, поэтому если вам интересно что-то узнать про техэмпауэр, и как Microsoft, и как вообще ASP.NET Core с ним справляется, дожидайтесь следующего выпуска, там мы постараемся всё подробнейшим образом рассказать.
918.16 922.24 SPEAKER_01 Слушай, а почему ты ничего про майонез, о легионах не сказал?
922.24 924.12 SPEAKER_01 Тоже большая работа была проделана, почему это не
924.12 928.40 SPEAKER_00 упомянули? Почему это не упомянули на главной странице, я даже не знаю.
928.40 934.24 SPEAKER_00 То есть, это действительно большая работа, в докладе, кстати, который я на dotnext читал, я про это упоминал.
934.24 951.48 SPEAKER_00 Про это, наверное, так в паре слов не расскажешь, но смысл в том, что да, у нас теперь регионы исключены по умолчанию, теперь у нас память выделяется не большими сегментами, а маленькими кусочками, по 4 или сколько-то мегабайт, и в теории на вас это повлиять должно только в лучшую сторону, но может быть и в худшую.
951.48 961.84 SPEAKER_00 Если я правильно помню наше рассуждение из каких-то превью, из статьи Маони, что на старте приложения теперь может потреблять побольше памяти, зато более агрессивно отдавать ее в процессе работы.
961.84 968.08 SPEAKER_00 Так что тестируйте ваше приложение на новых режимах работы ГЦ и смотрите, что получилось.
968.08 983.00 SPEAKER_01 Ну, я думаю, надеюсь, что все-таки там не так все плохо, Майонь обычно не ошибается, всегда делает на совесть, поэтому хорошее обновление, хорошие анонсики, но, наверное, самое интересное, чего все ждут, это, конечно же, изменения в языке.
983.00 985.40 SPEAKER_01 Что нас в C# 11 порадовало?
985.40 1005.60 SPEAKER_00 Да, в C# 11 у нас довольно много всего завезли, причем я боюсь, что я не буду сейчас еще раз все аккуратно рассказывать смысл всех фич, потому что их довольно много, их, по-моему, 14 или 15 штук, таких, которые оказались достойны упоминания во всяких статьях.
1005.60 1008.28 SPEAKER_00 И вот с нее, ну, кратенько давайте перечислим.
1008.28 1011.80 SPEAKER_00 Мы про них, про все уже говорили, на самом деле, много раз.
1011.80 1014.00 SPEAKER_00 Для начала начнем работать со строками.
1014.00 1029.36 SPEAKER_00 У нас теперь появились UTF-8 литералы, то есть если вам вдруг зачем-то нужны быстрые UTF-8 строки, вы теперь можете после обычного литерала C# дописать U8, и вы получите сущность, которая имеет тип не string, а тип read-only span от байтов.
1029.36 1043.44 SPEAKER_01 Ну, скорее всего, это вам нужно где-нибудь на границах приложения, например, если вам нужно быстро отдать в сокет какую-нибудь строку без лишних конвертаций между UTF-16 и UTF-8, наверное, полезная вещь, почему нет?
1043.44 1047.20 SPEAKER_00 Да, все так, вот ровно для этого это и было сделано, вероятно, поэтому...
1047.20 1050.80 SPEAKER_00 И на этом, кстати, основа техампа русский матчмарк, в частности.
1050.80 1053.72 SPEAKER_00 Дальше у нас появились raw string литералы.
1053.72 1058.40 SPEAKER_00 Мы могли раньше задать строку, в которой вы задаете, например, JSONчик.
1058.40 1062.28 SPEAKER_00 Но проблема в том, что JSON содержит много кавычек, вы должны их экранировать через бэкслэш.
1062.28 1076.08 SPEAKER_00 Можно было написать вначале строки символ "собаки", после чего вам не нужно было ничего экранировать, кроме, опять же, кавычек, потому что строка ограничена кавычками, но в этом случае нужно кавычки игнорировать двойной кавычкой, ну, в смысле, вместо одной писать две.
1076.08 1077.72 SPEAKER_00 И так и так неудобно.
1077.72 1086.64 SPEAKER_00 Теперь у нас появились raw string литералы, это вы можете начать строку с трех и более кавычек, написать внутри все что угодно и закончить таким же количеством кавычек.
1086.64 1094.32 SPEAKER_00 Любое количество кавычек меньше, чем использовано при открытии строки, считается простым литералом и не требует экранирования.
1094.32 1098.28 SPEAKER_00 Второй момент, они могут быть многострочными.
1098.28 1102.64 SPEAKER_00 В этом случае открывающие и закрывающие кавычки должны быть на своей отдельной строке.
1102.64 1112.04 SPEAKER_00 То есть вы объявляете переменную, пишете равно, там три кавычки, например, дальше со следующей строки начинаете текст, и потом в конце на отдельной строке закрываете тремя кавычками.
1112.04 1119.80 SPEAKER_00 Положение этих закрывающих трех кавычек тоже важно, в зависимости от этого компилятор будет откусывать лишние начальные пробелы у всех строк внутри.
1119.80 1130.08 SPEAKER_00 Внутри этих литералов можно использовать string interpolation, понятное дело, для этого вы перед этими тремя кавычками запихиваете нужное количество долларов, один, два, три и так далее.
1130.08 1136.28 SPEAKER_00 Чем больше долларов вы запихнете, тем больше последовательных фигурных скобок вам можно использовать внутри без того, чтобы это считалось подстановкой.
1136.28 1148.88 SPEAKER_00 Но для того, чтобы работала подстановка, то есть если вы, например, пишете строку с трех долларов и трех кавычек, то чтобы внутри string interpolation работал, нужно тремя фигурными скобками обозначать места, где будет string interpolation.
1148.88 1153.12 SPEAKER_00 Если у вас много interpolation, наверное, выгоднее поменьше долларов использовать.
1153.12 1166.12 SPEAKER_00 Но если у вас, грубо говоря, огромный JSON, куда подставляется два каких-нибудь поля, то может быть имеет смысл как раз использовать тройной такой доллар и в одном или двух местах указать три открывающихся фигурных скобки, а весь остальной JSON будет из обычных одинарных.
1166.12 1174.32 SPEAKER_01 На самом деле полезная штука, я в всяких скриптовых языках часто таким пользуюсь, где нужно организовать какие-то большие темплейты и еще что-то.
1174.32 1184.20 SPEAKER_01 Единственное, что меня до сих пор смущает, это вот эта безумная магия, когда нужно там три кавычки поставить с определенным отступом, если отступ другой, то поведение внутри меняется.
1184.20 1201.64 SPEAKER_01 Если вдруг вы поставили три кавычки и два вопросительных знака, это совсем не то, что один вопросительный знак, и вот эти всякие тонкости, они, конечно, я думаю, будут не один мозг еще убьют, но надо признать, что команда попыталась выжать максимум из этой фичи, попыталась сделать максимально удобно.
1201.64 1207.52 SPEAKER_01 Ну посмотрим, как на практике этот баланс сумели ли они соблюсти между понятностью и используемостью.
1207.52 1223.64 SPEAKER_00 Да, там на самом деле компилятор очень старается, если вы, например, поставите закрывающую кавычку, закрывающие три кавычки на последней строке слишком далеко вправо, и у вас нормальный контент начинается левее, то там компилятор, раз ошибка компиляции будет писать, что у вас кавычка не там стоит.
1223.64 1224.64 SPEAKER_00 Короче, они постарались.
1224.64 1227.84 SPEAKER_00 Дальше, про мемберы.
1227.84 1241.72 SPEAKER_00 Мемберы у нас теперь могут быть не только там static, readonly, вот это все, они не только могут быть там с getset или init этими модификаторами, но еще они могут теперь быть required.
1241.72 1251.16 SPEAKER_00 Required означает, что этот мембер должен быть обязательно интеллизирован либо через конструктор, либо через object initializer.
1251.16 1273.64 SPEAKER_00 Причем проблема состоит в том, что через конструктор оно как-то работает фигово, в том смысле, что если у вас есть конструктор, который принимает два поля, ну даже не два, допустим у вас есть пропертиа, которая обозвонка required, у вас есть конструктор, который принимает какой-то аргумент и проставляет в это поле, компилятор не поймет, что таким образом эта штука интеллизируется, если у вас есть пустой конструктор дополнительно.
1273.64 1279.56 SPEAKER_00 И нужно такой конструктор помещать дополнительным атрибутом setsRequiredMembers.
1279.56 1294.24 SPEAKER_00 Я попытался, вот после доклада меня спрашивали, зачем вообще такая штука, зачем нужен был атрибут, что-то я быстро не смог найти, надо читать всякие обсуждения, ну читать и слушать обсуждения именно API-дизайна, почему так было сделано.
1294.24 1302.08 SPEAKER_00 Не получилось у меня быстро понять, зачем вот таким атрибутом, почему компилятор нельзя было научить, что все на самом деле нормально работает.
1302.08 1306.88 SPEAKER_01 Но смысл в том… Ну по идее это сложный flow-анализ, у нас в компиляторе сейчас нигде нет flow-анализа.
1306.88 1321.16 SPEAKER_00 Ну сложный, не сложный, но в общем да, так или иначе это было сделано, в результате надо понимать, что если у вас есть requiredMembers и есть вот такой атрибутик на каком-то конструкторе, то у вас никто не гарантирует, что requiredMembers будут заполнены, к сожалению.
1321.16 1323.08 SPEAKER_00 Они могут остаться непроинтеллизированы.
1323.08 1328.52 SPEAKER_00 Дальше, про field'ы, у нас появились reffield'ы и scopedref'ы.
1328.52 1337.20 SPEAKER_00 Я не буду сейчас сильно углубляться, что это такое, но смысл такой, в общем-то это чисто для того, чтобы нормально поддержать спаны, потому что раньше они были поддержаны с некоторым хаком.
1337.20 1347.00 SPEAKER_00 А scopedref'ы это как раз тот самый flow-анализ, чтобы понять, куда какие ref'ы можно отдавать выше-ниже по стэку и понимать, можно ли нельзя отдавать.
1347.00 1353.80 SPEAKER_00 Там фича довольно сложная, надо вдумываться, чтобы понять, я на слух не смогу ее, наверное, объяснить.
1353.80 1355.68 SPEAKER_00 Про типы, что у нас еще есть?
1355.68 1367.84 SPEAKER_00 У нас появились filescoped-типы, то есть если перед классом или структуркой написать вместо слова public или internal слово file, то такой тип будет доступен только в рамках этого файла.
1367.84 1371.88 SPEAKER_00 Нужно это… И зачем на практике такая штука нужна?
1371.88 1395.56 SPEAKER_00 Я так понял, в основном такая штука используется для source-генераторов, то есть типа тот самый partial-класс, который генерится source-генератором, он же как бы в общем-то не нужен ни для чего, кроме как для того, чтобы вписать туда код этого самого непосредственно сгенеренного метода или там чего вы аннотируете вашим атрибутикам для source-генератора.
1395.56 1409.24 SPEAKER_00 И вот чтобы этот класс больше нигде не светился, ни в каких interessence-ах нигде, вот его, я так понимаю, можно сгенерить со scope-file, и тогда он будет виден только в рамках того файла, куда он подставлен.
1409.24 1411.28 SPEAKER_01 Интересно, а что там в ILLI получается?
1411.28 1414.88 SPEAKER_01 Ведь когда мы в assembly запихиваем все это дело, у нас уже нет никакого файла.
1414.88 1425.08 SPEAKER_00 Да, там генерится специальное имя, которое, оно конечно глобально видимо, то есть тот факт, что его не видно в namespace в подсказках, это чисто фича Visual Studio.
1425.08 1438.24 SPEAKER_00 Понятно, что в атрибутах там ничего такого нету, там просто имя, в которое включен hash SHA-256 от пути к файлу в компилятор с генерированным имя.
1438.24 1441.04 SPEAKER_01 Ну и namespace, конечно.
1441.04 1451.00 SPEAKER_01 Ну вообще если такая вещь, которая нужна чисто для IDE, типа скрыть от interessence, они раньше делались атрибутами, и кажется, что это более разумный и вменяемый способ, чем заводить новые кейворты.
1451.00 1453.52 SPEAKER_01 Зачем они нужны, если только студия должна не видеть
1453.52 1455.52 SPEAKER_00 это? Непонятно.
1455.52 1473.72 SPEAKER_00 Кстати, интересный момент, вот как раз про эту фичу есть на dotnet.conf видосик от Джаррида Парсонса, там 20 с копеечками минут, где он как раз рассказывает про дизайн такой фичи, то есть вообще у него видосик типа let's design language feature, где он показывает, про что команда думает, как она подходит к тому, как что задизайнить.
1473.72 1480.44 SPEAKER_00 Вот на примере файла этих скоп-тайпов можно посмотреть, как они что-нибудь делали.
1480.44 1481.44 SPEAKER_00 Давай дальше.
1481.44 1502.44 SPEAKER_00 Дальше у нас есть из мелочей nameof, которые теперь можно использовать снаружи методов, то есть если вы хотите, допустим, в атрибут указать имя параметра, а такое бывает надо для всяких там хитрых атрибутов, ну для вот nullability нужно, да, там not null if not null, когда вам нужно указать имя параметра какого-то.
1502.44 1511.24 SPEAKER_00 И для атрибутов, если вы хотите что-то про параметры тоже сказать, можно теперь использовать nameof, и можно использовать generic attribute.
1511.24 1520.32 SPEAKER_00 Ну и так, еще я забыл про лист паттерны, теперь есть у нас во всяких из выражениях можно указывать списки.
1520.32 1536.76 SPEAKER_00 Работает это немножко кривовато, то есть это хорошо работает на массивах, это не очень хорошо работает на списках, то есть там есть фича, которая позволяет, например, сказать, что этот массив из квадрата на скобках открывается там, не знаю, 0, точка, точка, var y.
1536.76 1541.80 SPEAKER_00 И вот в var y положится весь хвост массива, если первый элемент 0.
1541.80 1546.92 SPEAKER_00 То есть таким образом можно откусить нужный кусочек массива, серединку, там край, край.
1546.92 1552.60 SPEAKER_00 Но проблема в том, что это работает только на коллекции, где реализован range, ну индексатор от range.
1552.60 1556.96 SPEAKER_00 А листы такого не реализуют, поэтому на листах такое работать, к сожалению, не будет.
1556.96 1558.24 SPEAKER_00 Странно, а почему?
1558.24 1559.92 SPEAKER_00 У листа же есть индексатор.
1559.92 1564.08 SPEAKER_00 У листа есть индексатор от индекса, ну от int.
1564.08 1565.08 SPEAKER_00 От int, да.
1565.08 1566.08 SPEAKER_00 А нужно?
1566.08 1567.08 SPEAKER_00 А нужно от range.
1567.08 1568.08 SPEAKER_00 А, понятно.
1568.08 1571.48 SPEAKER_00 Чтобы ты мог написать там квадратные скобки, 2, точка, точка 5.
1571.48 1572.48 SPEAKER_00 Погоди, почему не реализовать-то?
1572.48 1573.48 SPEAKER_00 Ничего не мешает?
1573.48 1574.48 SPEAKER_00 Вот это интересный момент.
1574.48 1576.16 SPEAKER_00 Не знаю, почему не реализовали.
1576.16 1579.96 SPEAKER_00 Если хотите так работать с листами, пишите своего наследника листа.
1579.96 1581.56 SPEAKER_00 Не знаю, почему не сделали.
1581.56 1585.16 SPEAKER_01 Да нет, делайте pull request, настоящий лист, что это такое?
1585.16 1589.56 SPEAKER_00 Ну да, либо почитайте историю, может быть там будет написано, почему они так не сделали.
1589.56 1605.76 SPEAKER_00 И да, generic математика, мы про неё много раз говорили, статические абстрактные методы интерфейсов плюс generic математика, там несколько десятков интерфейсов в system numerix, которые теперь реализованы всеми стандартными примитивами, можно писать свою generic математику.
1605.76 1625.16 SPEAKER_00 Если вам интересно более детально посмотреть на всё это, потрогать руками, во-первых, есть официальные гайды от Microsoft, во-вторых, есть хорошая статья, ссылочка будет в описании, плюс есть GitHub репозиторий с некоторыми примерочками на седьмом linkpad, который я использовал для своего доклада на dootmxt, который недавно прошёл.
1625.16 1630.52 SPEAKER_00 Там тоже можно потрогать, там есть простые примеры почти на все фичи.
1630.52 1632.60 SPEAKER_00 Не абсолютно на все, но почти на все.
1632.60 1643.56 SPEAKER_01 Не забывайте уже про ранее упомянутый тобой dotnet.conf, там куча видосиков про фреймворк, по tool, по всяким фичам языка, там тоже много чего интересного можно посмотреть.
1643.56 1649.40 SPEAKER_00 По-моему, там, кстати, сам Matt Storgerson рассказывает про какие-то фичи по крайней мере языка.
1649.40 1657.28 SPEAKER_01 Может быть, ну соответственно у нас после языка C# есть ещё один самый главный язык, это всё-таки F#.
1657.28 1661.00 SPEAKER_01 Не Visual Basic, почему-то про Visual Basic в этот раз было совсем мало.
1661.00 1664.84 SPEAKER_01 Давайте посмотрим, что у нас такого интересного произошло в F#.
1664.84 1674.72 SPEAKER_01 В принципе, самая главная цель, на которую были направлены авторы в этом релизе, это сделать F# как можно ближе к народу, как можно более понятным, более простым.
1674.72 1685.48 SPEAKER_01 И кажется, что им это удалось, у них много было улучшений в инструментарии, особенно вокруг, в поддерживании EDE, ну и конечно же, перформанс, куда же без перформанса, всё улучшили.
1685.48 1692.40 SPEAKER_01 Ещё одним большим таким направлением по развитию это была интеграция с новыми фичами C#.
1692.40 1697.44 SPEAKER_01 В частности, уже упомянутый к ночи был Static Abstract Member в интерфейсах.
1697.44 1705.84 SPEAKER_01 Теперь в F# в седьмом это тоже поддерживается, это один из базовых концептов для того, чтобы делать Generic Math.
1705.84 1717.08 SPEAKER_01 И также поддерживает встроенные BCL-типы, которые реализуют всякие вот эти магические интерфейсы iNumber, iAdditional и прочее.
1717.08 1722.20 SPEAKER_01 В общем, F# это тоже умеет понимать и тоже применять к ним всякую математику.
1722.20 1742.92 SPEAKER_01 Мне вообще интересно, что сейчас спрашивают в Juno на собеседованиях, потому что после того, как Майоня там переделала всё, что только можно переделывать со всякими поколениями, после того, как у нас появились абстрактные статические методы в интерфейсах, после того, как уже нет никакой разницы между референсом и ref value, что вообще можно на собеседованиях спрашивать?
1742.92 1743.92 SPEAKER_01 Как Juno валят, интересно.
1743.92 1761.88 SPEAKER_00 Да спрашивать, наверное, всё то же самое, про поколения спрашивать можно всё так же, но вот если тебе Juno ответит, ну у нас теперь можно из нуля и во второе поколение, потому что у нас регионы, то ты знаешь, что это либо очень начитанный Juno, либо он слушает наш подкаст, либо он просто наоборот что-то где-то слышал и надо копать дальше.
1761.88 1763.92 SPEAKER_01 Или наоборот выпендривается, да.
1763.92 1767.40 SPEAKER_01 Хорошо, погнали дальше.
1767.40 1771.96 SPEAKER_01 Упростилась работа со Statical Result Type Parameters.
1771.96 1781.28 SPEAKER_01 Это такие специальные типы параметров, которые могут заменяться во время компиляции, в отличие от обычного случая, когда заменяются они в ран тайме.
1781.28 1790.80 SPEAKER_01 Тоже очень полезная штука для оптимизации, для скорости, в общем сейчас с ними стало работать намного удобнее и применяться они стали намного чаще.
1790.80 1802.08 SPEAKER_01 Также был поддержан Required Keyword, про который говорил Игорь, и нет Keyword в свойствах, которые позволяют инициализировать проперти в тех или иных условиях, это все тоже F# понимает.
1802.08 1819.88 SPEAKER_01 Также F# теперь умеет компилировать, то есть компилятор F# умеет генерировать reference assembly, это специальные сборки, которые содержат минимум информации, в которой есть по сути только metadata.
1819.88 1833.96 SPEAKER_01 Эта metadata покрывает только публичный API, что позволяет вам просто компилировать ваше приложение с какими-то сборками, зная, что там этот публичный API точно есть, но запускаться с ними вы естественно не можете.
1833.96 1849.00 SPEAKER_01 Почему это полезно, когда вы хотите например скомпилироваться на одной операционной системе, а запускаться будете на другой операционной системе, но для этого вам нужны какие-то API, которые будут на целевой естественной операционной системе, и вот как раз reference assembly в этом помогут.
1849.00 1854.32 SPEAKER_01 У нас тоже там была отдельная тема, большая тема в каком-то выпуске про reference assembly, если интересно, поищите.
1854.32 1875.60 SPEAKER_01 И F# уже давно умеет триммиться, он уже давно умеет запускаться под нативным кодом, ну то есть как нативный код, ну а теперь это сделали еще лучше, еще нативнее, еще триммленнее, в общем тоже nativeout и selfcontained deployment тоже проимпровили.
1875.60 1877.60 SPEAKER_01 Такие небольшие изменения.
1877.60 1888.32 SPEAKER_00 Там получше сделали разметку собственно, что можно триммить в стандартной библиотеке F# и F# core, за счет чего там, я так понимаю, более аккуратно выкидывается и приложение с большей вероятностью не будет падать.
1888.32 1896.60 SPEAKER_01 Да-да, именно так, в принципе, весь стриминг на это и завязан, насколько хорошо у вас про аннотированные библиотеки.
1896.60 1919.88 SPEAKER_00 Давай дальше, дальше у нас, наверное, одна из самых, ну, наверное, вторая по обсуждаемости часть дотнета это, конечно, sp.net core, которую мы много раз обсуждаем и которая всегда заслуживает довольно большой кусок подкаста по мере прихода каждого превью, поэтому в релизе наверняка в нем тоже много всего интересного.
1919.88 1934.20 SPEAKER_01 Да, насобирали большую интересную пачку, прежде всего хотелось бы отметить, что добавили стандартный rate limiting, это возможность каким-то образом ограничивать те входящие запросы, которые идут в ваш sp.net приложение.
1934.20 1948.76 SPEAKER_01 Из интересного есть огромное число алгоритмов, которые уже внедрили в стандартную поставку, в стандартную библиотеку, также еще большее число алгоритмов еще собираются написать или будут добавляться сторонними какими-то разработчиками.
1948.76 1953.60 SPEAKER_01 Очень гибко конфигурируется, там есть интересные полисы, которые позволяют вам настроить лимитинг.
1953.60 1968.12 SPEAKER_01 В общем, тема интересная, тема богатая, если кто-то хочет посмотреть поподробнее, кого это интересует, обязательно гляньте на официальную документацию, там уже много описано интересных специальных параметров для конфигурирования.
1968.12 1995.32 SPEAKER_01 Дальше у нас появился output caching, он в принципе уже у нас был, но сейчас он стал намного более производительнее и лучше настраивается, потому что теперь можно настроить в зависимости от более тонких опций вашего входящего запроса, что именно вам нужно, то есть исходящего, что нужно вам кэшировать, когда это там должно протухать, когда это должно обновлять, в общем, output caching тоже отлично заимпровили.
1995.32 2024.52 SPEAKER_00 Да, тут надо сказать, что он у нас был, но он был немножко другой, у нас был response caching, то есть у нас кэшировался уже готовый, грубо говоря, сериализованный ответ, а это завезли кэширование именно результата опишек, то есть то, что вы вернули какой-нибудь там ok result или там bad result, not found, кэшировать странно, поэтому, то есть короче json, еще даже не сериализованный в json объект, а именно прям вот c# объект, как он есть.
2024.52 2049.88 SPEAKER_00 И эта штука позволяет, во-первых, в отличие от response caching, позволяет использовать разные бэкэнды для кэширования, в смысле, что не только в памяти, вы можете положить это в Redis куда угодно, там есть точки расширения для этого, а во-вторых, поскольку это кэшируется у вас прямо в приложении, то там есть прям нативные хуки, чтобы, грубо говоря, пост-запрос тут же инвалидировал все закэшированные объекты для этого же IDшника внутри вашего кэша.
2049.88 2058.20 SPEAKER_00 Короче, прям гораздо более гибкий кэш, но ценой того, что это делается у вас в приложении, а не где-то на промежуточных там проксях.
2058.20 2060.08 SPEAKER_00 Вот, но штука мощная.
2060.08 2062.28 SPEAKER_01 Да, богатая тема.
2062.28 2082.04 SPEAKER_01 Еще к нам завезли декомпрессию, но декомпрессия респонса у нас уже была, вот сейчас мы теперь можем декомпрессить реквесты, то есть если к вам пришел какой-то входящий запрос, у которого контент как-то был сжат, то теперь его можно элементарно хорошо и прозрачно разжать.
2082.04 2092.32 SPEAKER_01 Включилась и поддержка HTTP/3, раньше она была в экспериментале, теперь это встроенная поддержка, то есть это последняя версия HTTP протокола, который основан на квике.
2092.32 2100.40 SPEAKER_01 Теперь его можно использовать в различных ваших каких-то случаях, если вам вдруг это нужно, то официальная зарелиженная поддержка.
2100.40 2114.64 SPEAKER_01 При этом у нас будет еще HTTP/2 WebSockets, это новый транспорт, который позволяет вам запускать WebSockets по уже отлаженному HTTP/2.
2114.64 2122.04 SPEAKER_01 И мы добавили, то есть ISP.NET команда добавила новый WebTransport, который называется WebTransport.
2122.04 2130.64 SPEAKER_01 Вот, специальный протокол общения, который построен на датограммах поверх HTTP/3, и он сейчас находится в глубоком эксперименте.
2130.64 2134.04 SPEAKER_01 Показывает цифры довольно интересные, но посмотрим, что там с ним будет.
2134.04 2146.04 SPEAKER_01 В общем, если вы хотите его включить, то уже в текущем релизе можете с помощью экспериментального флага переключить, включить поддержку WebTransport и потестировать, допустим, на своих нагрузках со своими данными, которые есть у вас.
2146.04 2155.24 SPEAKER_01 Очень много изменений коснулось минимум API, почему-то его все время улучшают очень активно, в отличие от стандартного MVC подхода.
2155.24 2164.04 SPEAKER_01 Что-то я боюсь, что с такой эффективностью, с таким рвением, Microsoft делает ставку на то, что MVC развиваться больше не будет.
2164.04 2167.88 SPEAKER_00 А про это у меня всегда есть что добавить.
2167.88 2193.16 SPEAKER_00 Про это можно посмотреть видосик в .NET Conf видео, есть отдельный видосик, называется Architects Panel, где Дамиан Эдвардс, Дэвид Фаулер и кто-то третий, я забыл кто, как раз обсуждают всякие штуки типа Minimal API, MVC, Green 3D, если вам интересно, Дэвид Фаулер сейчас с ними экспериментирует.
2193.16 2204.00 SPEAKER_00 Короче, это тоже полчасовое или около 40-минутное что-ли видео, посмотрите, тоже очень неплохо узнать, что думают главные ISP-NET архитекторы.
2204.00 2207.36 SPEAKER_01 Ну, посмотрим, да.
2207.36 2222.88 SPEAKER_01 Из Minimal API у нас добавились фильтры, с помощью которых можно организовать Cross-Cutting Concern Code, то есть можно запускать какие-то ваши хуки, какие-то ваши делегаты перед каждым роутом и после выполнения каждого роута.
2222.88 2234.08 SPEAKER_01 У нас появились типизированные результаты, это строго типизированный классик, который умеет возвращать результаты, умеет их грамотно кэшировать и красиво форматировать и все так далее.
2234.08 2240.96 SPEAKER_01 Вот казалось бы типичный пример, почему бы такие Type Result не сделать для MVC тоже, но они поддерживаются только в Minimal API.
2240.96 2245.16 SPEAKER_01 Никаким образом к Minimal API, грубо говоря, отношения не имеют.
2245.16 2250.68 SPEAKER_01 Мы везде хотим возвращать нормальные респонсы с какими-нибудь закэшированными, оптимизированными ответами.
2250.68 2252.88 SPEAKER_00 Почему это было не сделать для MVC, непонятно.
2252.88 2254.44 SPEAKER_00 По-моему, ты можешь их использовать в MVC.
2254.44 2259.00 SPEAKER_00 В MVC же ты же этот I-Action Result, насколько я помню, возвращаешь.
2259.00 2260.00 SPEAKER_01 Именно так.
2260.00 2262.88 SPEAKER_01 Насколько я знаю, что вот эти Strong Result, они не реализуют I-Action Result.
2262.88 2266.24 SPEAKER_01 То есть там нужен какой-нибудь конвертер делать или оберточку влечеть в этом духе.
2266.24 2267.24 SPEAKER_00 Почему бы не реализовать?
2267.24 2268.24 SPEAKER_00 По-моему, можно.
2268.24 2274.88 SPEAKER_00 По-моему, я вот, надо посмотреть мое тестовое приложение на GitHub, примерно там же, которое я делал для доклада.
2274.88 2286.60 SPEAKER_00 По-моему, я что-то там возвращал, такое достаточно строго типизированное, типа JSON Result точка, что-то там, или просто JSON скобочка, что-то там, и оно вполне возвращалось.
2286.60 2288.32 SPEAKER_00 Так что, может быть, они в семерке сделали, что реализуют.
2288.32 2290.20 SPEAKER_01 Ну, может быть.
2290.20 2294.60 SPEAKER_01 Будет хорошо, если так, чтобы они все-таки не делили мир на две несовместимые части.
2294.60 2298.84 SPEAKER_01 Было бы хорошо, чтобы если фичу можно поддержать и там, и там, ее поддерживали бы и там, и там.
2298.84 2301.84 SPEAKER_01 Поэтому от этого бы все только выиграли.
2301.84 2302.84 SPEAKER_01 Погнали дальше.
2302.84 2304.60 SPEAKER_01 У нас появились road-группы.
2304.60 2314.16 SPEAKER_01 То есть это специальный способ, когда можно ваши minimal API-хендлеры объединить в какую-то одну группу, ей можно дать какой-нибудь общий префикс.
2314.16 2321.20 SPEAKER_01 Ну вот, мы приходим к тому, что у нас появляются некие подобия контроллеров, от чего, собственно, и убегали.
2321.20 2322.92 SPEAKER_01 Другой большой раздел – это gRPC.
2322.92 2326.80 SPEAKER_01 В gRPC самым главным нововведением было JSON-транскодинг.
2326.80 2334.88 SPEAKER_01 Это специальный сервис, специальная схема, которая позволяет вам из вашего gRPC сервиса выставить наружу JSON-бейст API.
2334.88 2339.24 SPEAKER_01 То есть якобы, как будто это ваш REST API сервис.
2339.24 2349.36 SPEAKER_01 Вот таким образом мы пытаемся обмануть клиентов, которые не поддерживают новомодные протоколы, там, HTTP/3, gRPC, прочие компрессии и прочие глупости.
2349.36 2358.76 SPEAKER_01 Вот мы можем сделать какой-нибудь совместимый такой JSON-бейст API и с помощью него поддержать старых клиентов.
2358.76 2376.20 SPEAKER_01 Также интересная штука, что сверху на этот JSON-транскодинг можно нацепить OpenAPI, то есть сгенерить какую-нибудь свагер-спецификацию и действительно прикинуться, что это вообще настоящие JSON-бейст контроллеры, JSON-API.
2376.20 2378.40 SPEAKER_01 Вот, тоже забавная вещь.
2378.40 2380.92 SPEAKER_01 Также в gRPC у нас добавились health-чеки.
2380.92 2387.84 SPEAKER_01 Теперь можно там репортить, проверять, каким образом себя чувствует gRPC сервер.
2387.84 2391.48 SPEAKER_01 И JSON-API клиент научился добавлять credentials.
2391.48 2398.48 SPEAKER_01 То есть можно отсылать authentication request на сервер с помощью барьер-токена.
2398.48 2400.72 SPEAKER_01 Тоже полезная штука.
2400.72 2403.20 SPEAKER_01 Не отстает от всех этих красавцев Blazor.
2403.20 2412.40 SPEAKER_01 Он научился генерить custom-ные элементы для того, чтобы создать стандарт HTML custom-элемент.
2412.40 2421.32 SPEAKER_01 То есть это специальные такие компоненты, которые позволяют Blazor-ным компонентам прозрачно интегрироваться в Java-бейст приложения.
2421.32 2437.12 SPEAKER_01 В общем, он может подстраиваться под те существующие HTML-элементы и может быть даже как-то обманывать существующие фреймворки и интегрироваться вместе с ними.
2437.12 2446.48 SPEAKER_01 В общем, тоже полезная фишка, которая позволит более плотно юзать уже существующие Java UI-ные фреймворки и вот как-то подмешивать к нему Blazor.
2446.48 2450.72 SPEAKER_00 Давай только мы не будем использовать существующие Java UI-ные фреймворки, а хотя бы JavaScript-овые.
2450.72 2451.72 None Ну, да-да-да.
2451.72 2460.44 SPEAKER_00 Не, ну Java UI-ные тоже можно, возможно, это примерно одно и, так сказать, одного уровня проблемы.
2460.44 2468.08 SPEAKER_01 Я думаю, я просто уже морально смирился, что Java мертва, это имя уже свободно и можно для сокращения JavaScript
2468.08 2472.72 SPEAKER_00 сюда добавить. Я только сегодня разбирал проект на Java Server Pages и тут на фреймворке 33.5.
2472.72 2475.72 SPEAKER_01 Я думаю, что ты очень не радовался.
2475.72 2481.12 SPEAKER_00 Ничего, нормально, будем переводить на Blazor и .NET, что там, 7, 8.
2481.12 2484.28 SPEAKER_00 К тому времени, когда переведу, я думаю, что уже девятка может выйдет.
2484.28 2488.76 SPEAKER_01 Которая автоматически научится транскопировать, видишь, что сейчас модно все транскопировать.
2488.76 2491.44 SPEAKER_01 Да, в васм все это, в васм.
2491.44 2501.88 SPEAKER_01 Еще до Blazor хотелось добавить, это теперь появилась возможность наконец-то обрабатывать изменения у Location, то есть тот участок, куда вводится ваш адрес.
2501.88 2512.88 SPEAKER_01 То есть вы теперь можете перехватить изменения адреса и, соответственно, создать какой-то эффект, какой-то дополнительный User Experience в навигации.
2512.88 2518.04 SPEAKER_01 То есть или подменять адрес, или наоборот, навигироваться без подменения адреса, или как-то управлять историей.
2518.04 2525.76 SPEAKER_01 В общем, очень полезная штука, практически все UI и JavaScript фреймворки обязательно эту вещь используют.
2525.76 2528.72 SPEAKER_01 В общем, и с Blazor теперь тоже можно это удобно делать.
2528.72 2533.04 SPEAKER_00 Да, и это все было, как я понимаю, все-таки про Blazor сервер, вроде как?
2533.04 2537.12 SPEAKER_00 Или это, у нас же есть Blazor Wasm, надо же каждый раз говорить, кто из них кто.
2537.12 2541.36 SPEAKER_01 Я думаю, это общие вещи, которые поддерживаются и там, и там.
2541.36 2542.36 SPEAKER_00 Угу, хорошо.
2542.36 2547.96 SPEAKER_00 В васме тоже, на самом деле, появилось некоторое количество разных штук, прям специфичных для васма.
2547.96 2563.80 SPEAKER_00 То есть там теперь можно, вот я не помню, это в семерке появилось все-таки раньше, но сейчас точно улучшили, что теперь можно запихнуть это все в native варианте, то есть вы можете же в ваш Blazor Wasm приложение запихнуть в васм двумя способами.
2563.80 2572.24 SPEAKER_00 Либо положить C#, ну, или код, да, фактически, плюс интерпретатор, либо сразу его скомпилировать, так сказать, нативно в нативные васмовские обкоды.
2572.24 2589.84 SPEAKER_00 И вот если вы это делаете в нативный вариант, в native out, то у вас сразу, компилятор теперь знает про всякие CMD, exception handling нативный васмовский, и, конечно, ну и у вас приложение становится прям круче работать.
2589.84 2594.72 SPEAKER_00 Но это требует, понятно, native out компиляции, которая со своими ограничениями.
2594.72 2606.60 SPEAKER_00 И в качестве эксперимента в Blazor Wasm завезли поддержку многопоточности, то есть вы теперь все # коди пишете там new thread, ну, как вы обычно пишете на C#, хотя это, наверное, давно много кто не писал уже new thread, все на тасках.
2606.60 2621.32 SPEAKER_00 Но если вам вдруг именно нужен мультитрейдинг такой нормальный, то вы пишете в C# new thread, а внутри это в браузере будет нормально через worker обрабатываться, и все будет работать как будто это обычное многопоточное приложение.
2621.32 2622.80 SPEAKER_00 Хотя это браузер, который по определению не многопоточен.
2622.80 2631.84 SPEAKER_01 Слушай, нет, ну thread-то не обязательно писать, даже если ты будешь async/await-ами пользоваться, то они уже автоматически подхватят эти background полы и сделают
2631.84 2636.56 SPEAKER_00 тебе параллельность. Ну вот async/await, да, это, по-моему, и было.
2636.56 2642.56 SPEAKER_00 А вот если ты писал new thread, вот прям тебе нужно какую-то длинную бэкграундную работу зафигачить, вот этого раньше не было.
2642.56 2644.64 SPEAKER_00 New thread API вроде не была поддержана, теперь будет.
2644.64 2652.04 SPEAKER_01 Ну именно так, async/await были, но они запускались в одном потоке, а теперь async/await на месте же останутся, но теперь они будут запускаться в нескольких потоках.
2652.04 2656.84 SPEAKER_01 То есть вам достаточно перекомпилировать, грубо говоря, ваш код с async/await-ами, и все заработает уже параллельно.
2656.84 2663.24 SPEAKER_00 В общем, нам из вас мы делают такой полноценный рантайм, в котором можно делать вообще все, что вы обычно делаете.
2663.24 2665.76 SPEAKER_00 Останется только добавить какой-нибудь нормальный UI.
2665.76 2668.76 SPEAKER_00 Смотри, Maui, да, например.
2668.76 2675.68 SPEAKER_00 И можно будет, да, отказаться от JavaScript, наконец-таки может быть когда-нибудь, но не факт.
2675.68 2677.20 SPEAKER_00 Давай пойдем дальше.
2677.20 2685.72 SPEAKER_00 Третий наш большой кусок от документа, который мы всегда тоже отсматриваем, это Entity Framework.
2685.72 2689.64 SPEAKER_00 Работа с данными всегда важна, в Entity Framework тоже много изменений.
2689.64 2693.76 SPEAKER_00 Основной фокус шестого Entity Framework был на перформанс по чтению.
2693.76 2699.48 SPEAKER_00 Они там пытались догнать даппер, и, насколько я помню, если не догнали, то очень-очень близко приблизились.
2699.48 2706.36 SPEAKER_00 Фокус седьмого Entity Framework был на перформансе сохранения, то есть перформансе записи и всего, что с этим связано.
2706.36 2713.36 SPEAKER_00 Тем не менее, помимо сохранения, завелись и какое-то количество просто общих фич, про которые мы сначала и поговорим.
2713.36 2720.80 SPEAKER_00 Во-первых, это Table Per Concrete Type Mapping, то есть если вы иерархию объектов хотите хранить в байте, у вас есть три варианта.
2720.80 2735.16 SPEAKER_00 Либо всю иерархию храним в одной широкой таблице, либо мы храним кучку таблиц на каждый класс, включая все абстрактные и промежуточные классы, либо мы храним только листовые классы с конкретным набором полей уже.
2735.16 2738.28 SPEAKER_00 Каждая такая табличка будет включать набор всех, в том числе родителей.
2738.28 2740.20 SPEAKER_00 Вот третий вариант теперь поддерживается.
2740.20 2741.88 SPEAKER_00 Два предыдущих были поддержаны до этого.
2741.88 2751.80 SPEAKER_00 Все это можно настраивать в вашем OnModule, в модул-конфигураторе, и Entity Framework это все нативно теперь нормально поддерживает.
2751.80 2753.56 SPEAKER_00 Кроме того, поддержаны JSON-колонки.
2753.56 2775.84 SPEAKER_00 Причем JSON-колонки поддержаны хитрым образом, если он будет очень стараться, пытаться собрать именно SQL выражения, которые, например, при апдейте будут обновлять только кусочек JSON, значения JSON-колонки, а не просто перезаписывать целиком колонку заново, а прям генерить SQL, который обновит содержимое JSON внутри колонки, если SQL, понятно, база такое поддерживает.
2775.84 2782.44 SPEAKER_00 Доступ к этим JSON-колонкам делает через LinkU, и все это совершенно замечательно работает довольно нативно.
2782.44 2794.48 SPEAKER_00 Скорее всего это, конечно, супернативно работает именно на SQL-сервере как основной, понятное дело и первой, наверное, базе, на которой все обычно поддерживается в Entity Framework, но в FosgreSQL, скорее всего, тоже все хорошо работает.
2794.48 2797.44 SPEAKER_00 Про остальные базы сказать не могу.
2797.44 2823.52 SPEAKER_00 Entity Framework обрел поддержку bulk-updates и bulk-deletes, если вам, например, нужно было обновить пачку объектов по какому-то условию и поставить им всем определенное значение в какой-то поле, там, не знаю, флажок в бульоне, в колонке, то на старых фреймворках нужно было сказать сначала получить все это дело, то есть загрузить все это из базы, обновить, просто в обычном C# коде, и потом сказать save changes.
2823.52 2833.76 SPEAKER_00 Это накладывает некоторые ограничения на скорость, потому что включается object tracker, чтобы save changes нормально работал, в Entity Framework нужно потракить все изменения и так далее.
2833.76 2834.76 SPEAKER_00 Теперь появляется возможность сделать по-другому.
2834.76 2851.68 SPEAKER_00 Вы теперь пишете "ef.where...execute bulk-update", дальше пишете, что собственно нужно сделать с этим book'ом, лямдочку, и он на основе этого сгенерит правильный SQL, который прям сразу update where сделает, как надо.
2851.68 2853.60 SPEAKER_00 Такая же штука с delete'ом.
2853.60 2854.60 SPEAKER_00 Теперь работает.
2854.60 2857.40 SPEAKER_00 Save changes тоже стал быстрее.
2857.40 2873.56 SPEAKER_00 В save changes, по-моему, это был даже чуть ли не последний выпуск, ну последний выпуск был про dotnext, по-моему, перед этим выпуском мы обсуждали save changes довольно активно, про то, что там брали лишнее количество транзакций, то есть, например, если вы делали один-единственный insert, то это приводило к трем round trip'ам.
2873.56 2882.12 SPEAKER_00 Сначала скажи там begin transaction, потом выполни, потом скажи commit transaction, хотя на самом деле база и так все это сделает за вас, если вы делаете один-единственный insert.
2882.12 2887.28 SPEAKER_00 И всякие такие штуки, плюс batching по 42 элемента.
2887.28 2890.92 SPEAKER_00 В общем, save теперь стал работать тоже пошустрее.
2890.92 2896.76 SPEAKER_00 Из дополнительных таких фич еще появился маппинг на хранимые процедуры.
2896.76 2901.64 SPEAKER_00 Он был для select'ов, теперь можно для insert'ов, update'ов и delete'ов теперь тоже хранимки использовать.
2901.64 2919.84 SPEAKER_00 Если вы используете, генерите структуру ваших классов, моделей данных из базы данных, то есть то, что называется database first, то вы теперь можете специальной командой через .NET tool поставить себе темплейты в t4 темплейты внутрь проекта и их подкастомизировать как вам угодно.
2919.84 2938.64 SPEAKER_00 То есть, например, если у вас по дефолту entity framework коллекции поменяет как лист от t, если вам хочется observable collection какой-нибудь или ваш кастомный тип коллекции, то там это прям в t4 темплейте правите и когда вы будете генерить в следующий раз модели с базы, ну все будет уже согласно вашим темплейтам.
2938.64 2959.76 SPEAKER_00 Ну и если вы крутой чувак, который хорошо знает внутренности entity framework и всячески кастомизируете его или подписываетесь на его события или используете так называемые интерцепторы, то завезли некоторое количество новых штук, которые вызываются перед компиляцией запроса, после компиляции запроса, перед выполнением обращения к BD, после выполнения обращения к BD.
2959.76 2972.04 SPEAKER_00 Если вы это используете, то вот как раз смотрите туда, там появились новые штуки, которые возможно помогут вам сделать какие-нибудь еще крутые вещи на entity framework, как-то в его pipeline клинится.
2972.04 2975.80 SPEAKER_01 Ну что ж, пойдем посмотрим, что у нас здесь еще есть.
2975.80 2980.80 SPEAKER_01 У нас притаилась и такая неочевидная вещь для .NET, это как UI-ки.
2980.80 2984.28 SPEAKER_01 Давай посмотрим, UI-ков у нас много теперь.
2984.28 3004.32 SPEAKER_00 В UI-ке в .NET это какая-то такая странная немножко история, их действительно много, мы сегодня обсудим три, их на самом деле больше, потому что есть те, которые неофициальные и не от Microsoft, но UI в .NET это всегда какая-то такая штука, которая непонятно где работает, как работает, в каком она состоянии работает и чем вообще надо пользоваться.
3004.32 3007.80 SPEAKER_00 Я до сих пор беру Windows Forms, когда мне что-то надо по-быстренькому наклепать.
3007.80 3014.04 SPEAKER_01 Ну, нужно признать, что все было довольно понятно и просто, когда мы были только под виндой.
3014.04 3017.88 SPEAKER_01 Вот когда появились всякие Mac и Linux, и вот там началось разброты шатания.
3017.88 3020.96 SPEAKER_01 И куда надо шататься?
3020.96 3026.64 SPEAKER_01 До сих пор мы не имеем какого-то одного ответа, и я думаю, что сейчас вы по анонсам, примерно, поймете почему.
3026.64 3044.28 SPEAKER_01 Начнем, как всегда, с твоего любимого старичка, Windows Forms, который по-прежнему жив, и я вообще, если честно, удивился, найдя его анонс вместе с .NET 7, и еще больше удивился, когда прочитал его анонс, потому что происходит что-то странное, друзья, и поэтому предлагаю все вместе посудить.
3044.28 3046.16 SPEAKER_01 Давайте пробежимся по нововведениям.
3046.16 3055.96 SPEAKER_01 Прежде всего, улучшили accessibility в Windows Forms, то есть сделали много таких интересных вещей, которые помогают, например, в автоматизации.
3055.96 3063.80 SPEAKER_01 Ну, улучшили, например, Scream Reader и тот сервис, который известен под названием Narrator.
3063.80 3076.28 SPEAKER_01 Это штука, которая позволяет слабовидящим людям считывать с экрана различные надписи или элементы, и позволяет им каким-то образом общаться с UI.
3076.28 3078.80 SPEAKER_01 В общем, это все заулучшили.
3078.80 3096.44 SPEAKER_01 Далее был улучшен UI Automation, то есть это специальный фреймворк, который зашит Windows Forms, который помогает вам делать, например, автоматизированные тесты или с какой-то другой целью управлять UI автоматически, то есть использованием юзера.
3096.44 3101.20 SPEAKER_01 Тоже прекрасная штука, что-то улучшили.
3101.20 3120.28 SPEAKER_01 Далее подобрали более подходящие цвета для того, чтобы сделать как контрастные темы более контрастными, и соответственно для того, чтобы обычные темы сделать тоже немножко более контрастными, чтобы их лучше было разглядеть и удобнее было на них смотреть.
3120.28 3124.36 SPEAKER_01 Улучшили High DPI всякие режимы.
3124.36 3131.72 SPEAKER_01 Например, сделали поддержку High DPI на мультимониторингах более умную.
3131.72 3141.16 SPEAKER_01 Она начала лучше рендериться, начала качественнее увеличивать те контроллы, которые внутри формочки находятся.
3141.16 3162.84 SPEAKER_01 И так как все вот эти изменения довольно рискованные, потому что уже очень много у нас собралось всяких WinForm приложений, уже очень много настроено каких-то автоматизированных средств и всяких тестовых средств под этот фреймворк, в общем команда ввела возможность отключить все эти нововведения с помощью фичи-флагов.
3162.84 3173.60 SPEAKER_01 Мы уже с фичи-флагами часто сталкивались и уже знаем, если вдруг какие-то проблемы возникнут, то всегда вот эти вот настроечки, их можно отменить.
3173.60 3179.84 SPEAKER_01 Более интересное нововведение – это новые датабайдинги.
3179.84 3184.56 SPEAKER_01 WinForm завезли современные датабайдинги.
3184.56 3188.20 SPEAKER_01 То есть раньше в WinForm они и были, но там были довольно убогие.
3188.20 3194.36 SPEAKER_01 В общем назвать это датабайдингами даже язык не поворачивался, это вообще какой-то примитивный способ связывания.
3194.36 3212.92 SPEAKER_01 Сейчас же сюда завезли байдинги полноценные, практически такие, как были в .dpf, такие, как есть в .dpf, то есть с датаконтекстом, с поддержкой команд Pattern, то есть можно там команды делать, можно какие-то объекты в датаконтекст засовывать, их там разбирать с помощью ключей.
3212.92 3217.20 SPEAKER_01 В общем все то, что вы наверняка видели в .dpf.
3217.20 3224.28 SPEAKER_01 И в .dpf это была, наверное остается, это самая мощная штука, которая много релизов двигала .dpf вперед.
3224.28 3227.68 SPEAKER_01 Теперь все это может делать наш старичок в WinForms.
3227.68 3234.88 SPEAKER_01 И нужно это для того, чтобы естественно реализовать полноценный Model-View-Model, MVVM, так называемый, паттерн.
3234.88 3241.20 SPEAKER_01 MVVM – это очень крутецкая штука, она помогает вам очень сильно увеличивать переиспользование кода.
3241.20 3244.48 SPEAKER_01 И самое главное – это тестирование кода.
3244.48 3259.56 SPEAKER_01 Переиспользование кода, чтобы вы оценили, насколько она позволяет переиспользовать кода, что прямо в статье автор отмечает, что если вы перейдете на MVVM, то в принципе вы уже будете никак не ограничены WinForms.
3259.56 3269.32 SPEAKER_01 Если у вас будут View-модели, то вы без проблем сможете пересесть и на .dpf, и на UVP, и на WinUI, и как ни странно на MOYU тоже.
3269.32 3275.16 SPEAKER_01 В общем, может быть это такая стратегия Microsoft по миграции.
3275.16 3282.64 SPEAKER_01 То есть вам уже не нужно просто взять, выбрасывать ваши WinForms, переписывать все с нуля, а вы можете сделать более прозрачную штуку.
3282.64 3300.72 SPEAKER_01 Вы можете существующие WinForms проапгрейдить на новую версию, перевести постепенно все ваше приложение на MVVM, и после того, как вы это сделаете, выбрасывание WinForms и подставление туда MOYU, это будет просто элементарное действие практически.
3300.72 3308.12 SPEAKER_01 Таким образом может быть Microsoft планирует захватить наших старичков, которые до сих пор живут на WinForms и перевести их на новый MOYU.
3308.12 3320.24 SPEAKER_01 Но другой причиной так сильно импровидить дата баннинг, того чего мы не могли дождаться десятилетия, сейчас зачем этим заниматься, другого оправдания я найти не могу.
3320.24 3332.92 SPEAKER_01 Microsoft также отдельно подчеркивает, что никаких планов переводить приносить XAML в WinForms у них нет, то есть с помощью XAML мы все еще не сможем описывать WinForms.
3332.92 3338.24 SPEAKER_01 Это конечно грустно, но надо же до пифа хоть что-то ставить, хоть какую-то фишку.
3338.24 3341.04 SPEAKER_01 Иначе вообще не будет понятно, зачем он нужен.
3341.04 3346.20 SPEAKER_01 Следующий из больших разделов это Comvwrapper и Native IOT.
3346.20 3357.28 SPEAKER_01 С WinForms была большая проблема, к нему не мог прицепиться никак Native IOT и Trimming вместе с ним.
3357.28 3369.24 SPEAKER_01 И в этом релизе команда решила обновить Com-интеропы, которые как раз были главной причиной, заменила их с помощью Comvwrapper.
3369.24 3382.12 SPEAKER_01 Это специальная технология, которая теперь позволяет при определенной реализации всех Com-интерфейсов как надо избавиться от той проблемы, что мы не могли Trimming раньше и применять IOT сценарий.
3382.12 3392.00 SPEAKER_01 Теперь это можно сделать, теперь WinForms можно скомпилировать как Native IOT приложение и запускать как нормальное Native приложение.
3392.00 3410.60 SPEAKER_01 Эта стадия все еще в большом эксперименте, там еще возможны какие-то проблемы, там еще не все размечено, не все Com-интерфейсы переведены, но активная работа в этом направлении ведется и в принципе уже сейчас можно пробовать, если на каких-то ваших приложениях это критично или нужно, то я думаю, что уже можно поэкспериментировать.
3410.60 3417.40 SPEAKER_01 Вот такие глобальные, мне кажется, довольно большие мощные нововведения коснулись WinForms.
3417.40 3419.40 SPEAKER_01 Как, Игорь, тебя впечатлили?
3419.40 3431.96 SPEAKER_00 Да, я на самом деле хочу попробовать DataBinding, посмотреть что это такое, потому что может быть это еще больше ускорит то, как я быстренько клепаю приложение, когда мне нужно что-то очень простое и быстрое.
3431.96 3432.96 SPEAKER_00 Надо посмотреть.
3432.96 3444.80 SPEAKER_00 Я еще хотел сказать, что вот Comvwrapper и Native IOT, то есть ты сказал, что там команда работала, я так понимаю, что это работа в основном комьюнити, по большому счету.
3444.80 3450.60 SPEAKER_00 Там, конечно, команда что-то тоже помогала и содействовала, но основная работа была проведена силами комьюнити.
3450.60 3453.88 SPEAKER_00 То есть вся эта фишка с Comvwrapper и Native IOT.
3453.88 3455.56 SPEAKER_01 Да, вполне может быть.
3455.56 3458.64 SPEAKER_01 Ну что ж, пойдем дальше по возрастающей.
3458.64 3471.32 SPEAKER_01 После этого открывает DPF, я уже не знал чего ожидать, думал, может наконец-то перенесут его на кроссплатформу, запустят под Linux, завезут в виртуальную реальность, что-нибудь еще с ним сделают.
3471.32 3478.36 SPEAKER_01 Но изменения в DPF оказались намного более скромными и практически сводятся к секции Pro Performance.
3478.36 3492.00 SPEAKER_01 Конечно, там нашли очень много мест, где был ненужный анбоксинг-анбоксинг, перевели на спаны, там манипулирование со строками, там очень много было строк, все это тоже прооптимизировали.
3492.00 3501.00 SPEAKER_01 Улучшили локацию памяти, а точнее избавились от локации памяти, там где она была не нужна, там где она нужна ее максимально сократили.
3501.00 3510.04 SPEAKER_01 В общем, сильно профайлили память, улучшили потребление и использование памяти, соответственно, у нас DPF стал немножко меньше кушать.
3510.04 3524.84 SPEAKER_01 Улучшили рендеринг шрифтов, рендеринг шрифтов, кажется, это какая-то больная родовая травма, его там улучшают каждый релиз и все еще он как-то хреново иногда в некоторых ситуациях рендерится, но будем надеяться, что что-то наконец докрутили.
3524.84 3542.88 SPEAKER_01 И очень сильно почистили код, что тоже сделало возможность некоторые куски прям повыбрасывать, что положительно сказалось на перформансе, и некоторые плацдарм для будущих фич подготовить, потому что теперь код стал более читабельный, более консистентный, более красивый.
3542.88 3545.08 SPEAKER_01 Ну и там в аксессибилити тоже что-то завезли.
3545.08 3554.92 SPEAKER_01 В общем, как мы видим, такие дежурные исправления, какие-то дежурные работы над перформансом, никакого большого изменения, по сути, WPF не получил.
3554.92 3558.56 SPEAKER_01 Так стал немножко красивее, немножко быстрее и немножко
3558.56 3574.04 SPEAKER_00 получше. Там есть еще интересная тема, что, насколько я помню, в прошлом релизе он был, собственно, за open-source, то есть выложен его исходники в open-source, и в него можно контрибьютить, но проблема была в том, что не было выложено suite автоматических тестов для WPF.
3574.04 3581.44 SPEAKER_00 То есть вы могли что-нибудь закинуть, pull-request какой-нибудь, но проверить локально, что какой-то набор тестов проходит, вы, в общем-то, не могли.
3581.44 3595.04 SPEAKER_00 Вот штука, которую сделали в 7-м дотнете, это этот набор тестов тоже пушили на GitHub, ну или открыли его на GitHub, и настроили в основной репе WPF, насколько я понимаю, пайплайны, чтобы эти самые тесты запускались по pull-request.
3595.04 3605.60 SPEAKER_00 Все это выглядит, честно говоря, как то, что типа мы сильно WPF развивать не планируем, вот вам, как бы, наконец-таки тесты, теперь давайте несите ваши pull-requests, дорогой комьюнити.
3605.60 3606.80 SPEAKER_00 Мучаетесь с этими самыми.
3606.80 3611.16 SPEAKER_00 Ну, как бы, вам что-то надо в WPF, видите, правьте, а мы не хотим.
3611.16 3612.80 SPEAKER_00 Вот для меня пока это выглядит так.
3612.80 3614.28 SPEAKER_00 Не знаю, как на самом деле внутри.
3614.28 3628.12 SPEAKER_01 Ну, это ожидаемо, если они, в принципе, взяли себе направление на развитие MyUI, то тратиться на старые фреймворки, наверное, никакого смысла нет, кроме вот поддержки, улучшения, перформанса, рендеринга и так далее.
3628.12 3631.16 SPEAKER_01 Удивительно, вот почему они за WinForms взялись в этом
3631.16 3641.20 SPEAKER_00 контексте. Ну, тут, возможно, команда как-то, то есть, видимо, WinForms всё ещё действительно жив и популярен, и у команды нашлись ресурсы вот такое попробовать.
3641.20 3643.88 SPEAKER_00 Видимо, других улучшений особо не нужно было делать.
3643.88 3646.32 SPEAKER_00 Вот, попробовали, получилось что-то прикольное, видимо,
3646.32 3655.12 SPEAKER_01 надо пробовать. Да, в интерпрайзе такого не бывает, что у тебя нашлись ресурсы для того, чтобы принести баннинги, которые люди просили там десятилетиями, они раз и сделали.
3655.12 3659.04 SPEAKER_01 Там должна стоять какая-то более теория заговора.
3659.04 3662.56 SPEAKER_00 Может быть, мы что-то узнали, либо пришёл какой-нибудь большой кастер и рассказал нам очень надо.
3662.56 3664.12 SPEAKER_01 Ну да, может быть.
3664.12 3665.12 SPEAKER_01 Ладно, пойдём дальше.
3665.12 3677.36 SPEAKER_01 Вот, как я уже упоминал, всё у Microsoft нацелено на Moyu и вот открывая релиз ноутса Moyu, тут, конечно же, должна была быть огромная-огромная простыня всяких нововведений, но, опять же, нет, нифига.
3677.36 3681.32 SPEAKER_01 Единственное, что впечатляет у Moyu в том, что это General Availability.
3681.32 3683.24 SPEAKER_01 В принципе, и это всё.
3683.24 3690.56 SPEAKER_00 Ну, подожди, но он же был полгода назад объявлен, что он уже General Availability, нет?
3690.56 3693.52 SPEAKER_00 Или он там был просто, типа, релиз?
3693.52 3705.80 SPEAKER_01 Да, да, там его каким-то просто релизом обозвали, теперь сказали, что нам вот ещё немножко таймфрейм, пока мы подмачимся под наш новый DotNet 7, вот теперь они подмачиваются, теперь они смело кричат, что они наконец-то General Availability.
3705.80 3710.00 SPEAKER_01 В общем, не очень понятно статус, но вроде как зарелизилось.
3710.00 3712.96 SPEAKER_01 Ну, зарелизилось, можно пользоваться, хорошо.
3712.96 3713.96 SPEAKER_01 Типа того.
3713.96 3721.92 SPEAKER_01 Из мелочей улучшен Map Control, теперь, даже не улучшен, а добавлен, потому что раньше его вообще не было.
3721.92 3736.20 SPEAKER_01 Теперь вместе с DotMail.io поставляется Map Control, как всегда, это какой-то обновленный компонент от Xamarin.Forms, то есть это кроссплатформенная абстракция, которая нативно на конкретной операционной системе будет подцеплять нативный контроль.
3736.20 3743.52 SPEAKER_01 И там уже у вас будет и геокодирование, и позиционирование, и локации, и всё в этом духе.
3743.52 3764.40 SPEAKER_01 Улучшения для десктопа сводятся к банальным, типа, улучшили API для изменения размеров окна и его позиционирования, улучшили контекстное меню, тулт-типы, различные подсказки над контроллами, улучшили обработку правого клика.
3764.40 3769.68 SPEAKER_01 Ну, в общем, такие тоже какие-то мелочи, которые больше похожи на отмазки, чем на нормальный фичик релиза.
3769.68 3773.00 SPEAKER_00 Тут надо сказать, что слово "улучшили" неправильно.
3773.00 3794.60 SPEAKER_00 А если я правильно помню статью, смысл в том, что эти штуки добавили, MAUI настолько сильно концентрировался на всяких мобильных приложениях, ну а собственно с него, я так понимаю, всё начиналось, чтобы эта нативная кроплоформер работала на Android и iOS, что когда выяснилось, что вообще-то он должен работать в том числе на десктопе, оказалось, что, например, невозможно обработать right-click мыши.
3794.60 3796.76 SPEAKER_00 Ну нет, в телефоне right-кликов мыши.
3796.76 3798.84 SPEAKER_00 И поэтому такого API просто не было.
3798.84 3811.88 SPEAKER_00 И вот, поскольку к релизу нужно всё-таки, мы же релизим в том числе для десктопа, пришлось добавлять вот все эти API, про контекстные менюшки, про tooltip и вот всё то, что нужно на десктопе, чтобы с этим можно было в принципе работать.
3811.88 3822.84 SPEAKER_01 Ну, в целом про историю ты прав, единственное, что я не знаю, я не видел, добавили, я увидел везде там "улучшили", "заимпрувили" и "заинхэчмили" и всё в этом духе.
3822.84 3823.84 SPEAKER_00 Ну может быть.
3823.84 3827.40 SPEAKER_00 Ну не важно, но скорее всего, если оно работало фигово, можно считать, что его не было.
3827.40 3832.40 SPEAKER_00 Скорее всего, его действительно сильно не тестировали, потому что ну где ж ты там на телефоне будешь менять размер окна.
3832.40 3835.28 SPEAKER_00 Оно у тебя всегда одно и на весь экран.
3835.28 3836.28 SPEAKER_01 Да, да, может это.
3836.28 3850.56 SPEAKER_01 Ну смотри, вот глядя на вот эти три фреймворка, вот три анонса, которые мы сегодня с вами разобрали, у меня сложилось полное впечатление, что самый главный наш передовой UI фреймворк это WinForms, потому что во всех остальных это какие-то нелепые оправдания, а не анонсы.
3850.56 3853.16 SPEAKER_00 Ну, может тайной, не знаю.
3853.16 3860.12 SPEAKER_00 У Microsoft есть три команды, которые соревнуются, и вот WinForms это, вырывается вперёд, там долго сидели в засаде.
3860.12 3867.04 SPEAKER_01 Ну может быть, для нас, как для обычных разработчиков это вносит ещё больше путаницы, не более, не менее.
3867.04 3868.52 SPEAKER_01 А потом придёт Аполлония и всех победит.
3868.52 3878.24 SPEAKER_01 Да, скорее бы уже, может Microsoft наконец-то бы её купил там или задоптил, или ещё что-то с ней сделал, и наконец-то у нас был бы нормальный какой-то фреймворк, вместо десятка ненормальных.
3878.24 3883.00 SPEAKER_01 Ладно, хватит фантазировать и пойдём дальше, что у нас там есть.
3883.00 3884.68 SPEAKER_01 Машинное обучение, кажется, ещё рассказывали интересное.
3884.68 3885.68 SPEAKER_00 Ох, машинное обучение.
3885.68 3898.08 SPEAKER_00 Машинное обучение действительно рассказывали, я, честно говоря, не знаю, кто занимается машинным обучением прямо на дотнете, именно прямо не использованием сеточек, а созданием нейросеток, да, там типа вот это всё.
3898.08 3899.08 SPEAKER_00 Таксошников же.
3899.08 3908.96 SPEAKER_00 Нет, подожди, он занимается, конечно, в демо-примерах, но я не слышал ни разу, что этим занимались прямо в промышленном смысле.
3908.96 3911.44 SPEAKER_00 Но, может, действительно такие люди есть.
3911.44 3935.00 SPEAKER_00 Ну короче, есть ML.net, если кто не знает, это такая умотнученная штука, точнее это framework, кроссплатформенный для машин-лёрнинга, для дотнет-разработчиков, который, соответственно, позволяет вам вписать в ваше дотнет-приложение любые, в общем-то, какие-то модели, да, ML-ные, для их использования.
3935.00 3941.04 SPEAKER_00 Для этого есть ещё Extend, для Visual Studio 2022 есть Extension Model Builder, который позволяет, собственно, создавать эти штуки.
3941.04 3952.40 SPEAKER_00 И в этом релизе в 2.0 завезли новые API для работы с текстами, то есть теперь там есть classification поиск, по подобию, то, что они называют similarity API.
3952.40 3958.16 SPEAKER_00 И есть улучшение в штуке, которая называется AutoML, automated machine learning.
3958.16 3969.80 SPEAKER_00 Теперь вы можете автоматически перепроцессить нужные данные, как-то автоматически тренить всякие классификаторы, мультикласс классификаторы, регрессионные модели.
3969.80 3981.72 SPEAKER_00 Ну вот, кастомизировать гиперпараметры, это я сейчас вот прям статью читаю, тюнить алгоритмы для поиска оптимальных гиперпараметров, ты знаешь?
3981.72 3982.72 SPEAKER_00 Нет, к сожалению, не приходилось делать.
3982.72 3985.72 SPEAKER_00 И после того, как вы всё это закастомизируете, заоптимизируете, затюните, можно всё это заперсистить и, видимо, потом впихнуть в ваше дотнет-приложение, и оно будет оптимально работать.
3985.72 4009.36 SPEAKER_00 То есть, грубо говоря, вы действительно, видимо, можете на основе каких-то входных данных, например, включить какие-то модели, например, в какой-то модели, и из дотнет-приложения заиспользовать.
4009.36 4025.12 SPEAKER_00 Я не знаю практических применений этого, я не слышал, но я не интересуюсь особо этой областью, поэтому, если вы вдруг работаете на ML-дотнете и что-то про это знаете, на самом деле, напишите нам, мы вас позовём и с вами это обсудим, нам это тоже интересно.
4025.12 4035.96 SPEAKER_00 А если вы этим интересовались и вам интересно, вдруг что-то новенькое есть, ну загляните в ML-дотнет 2.0, может быть, вы там найдёте что-то интересное для вас.
4035.96 4040.40 SPEAKER_00 Наверное, вот это всё, что я могу рассказать про ML-дотнет, учитывая, что я им не занимаюсь.
4040.40 4041.40 SPEAKER_01 Ну, отлично.
4041.40 4046.44 SPEAKER_01 Я думаю, что если кто-то действительно занимается, приходите, пообсудим и поговорим.
4046.44 4055.12 SPEAKER_01 Я тоже не знаю ни одного живого человека, который на практике с этим сталкивался, поэтому даже представления не имею, как оно там всё живёт.
4055.12 4057.24 SPEAKER_01 Но, судя по анонсам, развиваются довольно бодренько.
4057.24 4063.80 SPEAKER_01 То есть, я бы сказал, что там какие-то громкие названия, громкие пункты и громкие импрувменты, они всё время встречаются.
4063.80 4070.00 SPEAKER_01 Не сказать бы, что оно мертво, наверное, где-то в какой-то индустрии, в какой-то стране кто-то этим пользуется.
4070.00 4074.64 SPEAKER_00 Давай про следующую технологию, которую тоже очень активно все пользуются, в кавычках.
4074.64 4078.72 SPEAKER_01 Да ничего не в кавычках, нормальная технология, чего ты наезжаешь.
4078.72 4081.76 SPEAKER_01 Речь у нас сейчас пойдёт про Microsoft Orleans.
4081.76 4093.68 SPEAKER_01 Это, для тех, кто не знает, Microsoft Orleans – это кроссплатформенный фреймворк для того, чтобы создавать различные сложные, масштабируемые, распределённые приложения.
4093.68 4095.52 SPEAKER_01 Звучит нормально, да?
4095.52 4097.20 SPEAKER_01 Возможно, многое насобирали.
4097.20 4100.88 SPEAKER_01 На самом деле, довольно популярная штука, довольно уже устоявшаяся.
4100.88 4108.00 SPEAKER_01 То есть, это не какой-то там молодняк, а это уже хорошо тестированное на больших продакшн-системах, в том числе внутри самого Microsoft.
4108.00 4112.00 SPEAKER_01 И много микрософтовских игр его используют, и Microsoft Bing его используют.
4112.00 4124.20 SPEAKER_01 Фреймворк построен на так называемой концепции акторов, на модели акторов, но у него есть свой собственный подход, своё собственное видение на модель, так называемые виртуальные акторы.
4124.20 4129.24 SPEAKER_01 В общем, если кто-то знаком с ACO.NET, то это, наверное, самое близкое, что можно представить.
4129.24 4134.40 SPEAKER_01 То есть, ACO.NET – это примерно примерный конкурент Orleans.
4134.40 4140.04 SPEAKER_01 У них есть общие концепции, у них есть концепции, которые расходятся.
4140.04 4142.88 SPEAKER_01 В общем, примерно это про одно и то же.
4142.88 4147.32 SPEAKER_01 Хороший фреймворк, как я уже сказал, интересный.
4147.32 4149.76 SPEAKER_01 Microsoft решила сделать следующий фильм душами.
4149.76 4153.40 SPEAKER_01 Она решила объединить команды Microsoft Orleans и ISP.NET Core.
4153.40 4156.48 SPEAKER_01 Ну и там даже не ISP.NET, а прямо самого .NET.
4156.48 4163.56 SPEAKER_01 В общем, там команда Orleans рассыпалась и по .NET, и по ISP.NET, или, может быть, это неправильно назвать, влилась.
4163.56 4167.16 SPEAKER_01 В общем, теперь они стали взаимодействовать намного ближе.
4167.16 4182.08 SPEAKER_01 И в результате этого взаимодействия появился новый релиз Microsoft Orleans 7.0, который прежде всего рассказывает нам про огромное число импрувментов, которые произошли в результате вот этого корпоративного слияния.
4182.08 4184.72 SPEAKER_01 Что же у нас там за импрувменты?
4184.72 4185.72 SPEAKER_01 Давайте посмотрим.
4185.72 4192.48 SPEAKER_01 Во-первых, нужно отметить, что в самом Orleans, прямо в его репозитории на GitHub есть огромное число клевых тестов.
4192.48 4200.24 SPEAKER_01 Прекрасны они тем, что тестируют очень различные сценарии, там сило-то сило, клиент-то сило.
4200.24 4210.60 SPEAKER_01 И у них есть различные симуляции различных инвайорментов на лэптопе, на десктопе, на виртуальных машинах, на различных серверах с различной масштабированностью, с различным количеством клиентов.
4210.60 4223.04 SPEAKER_01 В общем, все вот эти разнообразные сценарии и разнообразные взаимодействия, разнообразные инвайорменты, они очень плотно покрыты тестами и это прекрасно.
4223.04 4238.24 SPEAKER_01 Так вот, в результате того, что Orleans что-то там поимпрувили, заулучшили, у них по некоторым тестам производительность увеличилась от 40% до 170%.
4238.24 4249.08 SPEAKER_01 Такие хорошие, довольно качественные цифры, особенно с учетом того, что никаких глубоких примеров большого рефакторинга и чего-то такого они не приводят.
4249.08 4255.82 SPEAKER_01 То есть кажется, что это просто взаимодействие, плотное взаимодействие действительно с Untamed и прочими командами.
4255.82 4266.96 SPEAKER_01 И соответственно в результате Microsoft Orleans 7 может через себя пропускать 4,5 миллиона сообщений в секунду, что довольно-таки приличные цифры.
4266.96 4268.68 SPEAKER_01 4,5 миллиона – это прямо хорошо.
4268.68 4275.40 SPEAKER_01 Вот в принципе вот такими вот примерными понятиями оперируют данные фреймворки.
4275.40 4290.04 SPEAKER_01 Еще из-за того, что они стали взаимодействовать больше с людьми, с нормальными людьми, с нормальными потребителями, у них немножко изменился подход к тому, как они распространяют Nuget пакеты и в общем как организуют свой API.
4290.04 4300.20 SPEAKER_01 Например, в третьем Orleans для того, чтобы вам сделать какую-то кастомную штуку, вам нужно было подключить пакет, называющийся Orleans Code Generator MS Build.
4300.20 4306.76 SPEAKER_01 В общем, это довольно неочевидная вещь, которую в памяти держать сложно, но она вам нужна для практической генерации там силосовых клиентов.
4306.76 4318.00 SPEAKER_01 В новом 7 Orleans все это упростили, теперь вам достаточно подключить к вашему проекту просто MicrosoftOrleans.client пакет и вы получите клиента.
4318.00 4322.60 SPEAKER_01 Если вы подключите MicrosoftOrleans.server, не поверите, но вы получите сервер.
4322.60 4327.92 SPEAKER_01 И все это довольно стало таким человеческим языком, с человеческим лицом, теперь заработало.
4327.92 4345.04 SPEAKER_01 Вот в принципе все такие нововведения, которые стоит упомянуть для того, чтобы рассказать, что Orleans тоже примкнул к релизам .NET, к команде .NET, и теперь, скорее всего, будет как-то рядышком вместе с ним развиваться и тоже как-то улучшать свою общую инфраструктуру.
4345.04 4347.96 SPEAKER_00 Ну, неплохо.
4347.96 4360.52 SPEAKER_00 Наверное, это не тот фреймворк, который там прям широко распространен с точки зрения там среднего проекта, наверное, его не используют, но есть наверняка те, кому он нужен и интересен.
4360.52 4368.08 SPEAKER_00 И если вы уже его вдруг используете, то как раз обновиться на 7, кажется, однозначно нужно, получите бесплатный буст в перформансе.
4368.08 4375.24 SPEAKER_00 Давай пойдем дальше, мы много чего проговорили про всякие нововведения во фреймворках, теперь пора поговорить про тулы.
4375.24 4378.32 SPEAKER_00 А как же всем этим пользоваться?
4378.32 4389.36 SPEAKER_00 Понятное дело, что у нас есть SDK, который можно скачать и поставить, и вам ничего не нужно будет больше делать, но код где-то редактировать надо, и для этого у нас есть и DE.
4389.36 4399.60 SPEAKER_00 Для начала это Visual Studio 2022.17.4, официальная студия от Microsoft, последний стейбл-релиз, он поддерживает как раз .NET 7.
4399.60 4410.24 SPEAKER_00 Там есть много всяких разных улучшений помимо, собственно, самой поддержки .NET 7, мы про них рассказывали раньше, я на них не буду сильно прям останавливаться, хотя быстренько пробежимся.
4410.24 4422.76 SPEAKER_00 Мы говорили про то, что у нас теперь в студии появились звуки, то есть всякие штуки, которые срабатывают, когда происходят деленные события в студии, там когда у вас breakpoint сработал, или когда вы в поиске что-то сделали, или когда у вас билд закончился.
4422.76 4424.24 SPEAKER_00 Можно теперь настроить разные звуки.
4424.24 4425.24 SPEAKER_00 Датабейс визуал...
4425.24 4426.24 SPEAKER_00 Датабейс, дататейбл визуалайзер.
4426.24 4433.96 SPEAKER_00 Если у вас есть айнумерабл, либо что-то подобное, вы теперь в дебайгере можете посмотреть содержимое в красивом табличном виде.
4433.96 4439.52 SPEAKER_00 Ну и если у вас есть эксепшн, то у него появляется окошко, там теперь можно нормально посмотреть call stack.
4439.52 4440.52 SPEAKER_00 Прям удобно.
4440.52 4449.28 SPEAKER_00 Это те штуки, которые мы рассказывали до этого, там понятно, что перформанс улучшился, всячески разные тесты быстрее запускаются, вот это все.
4449.28 4458.56 SPEAKER_00 Помимо этого в последний, так сказать, вагон релиза успела запрыгнуть новая фича, которой не было в превьюшках, про которую мы не говорили, называется multi-repo-support, ну multi-repository-support.
4458.56 4465.36 SPEAKER_00 Эта штука позволяет вам иметь до 10 активных гид-репозиториев одновременно.
4466.24 4473.04 SPEAKER_00 То есть у вас, Microsoft говорит, например, если у вас есть солюшен, в котором есть больше, чем один репозиторий.
4473.04 4480.60 SPEAKER_00 Мне сложно представить, как у меня так есть солюшен, который распилен на много репозиторий, но наверное у Microsoft есть или у каких-то кастеров есть.
4480.60 4485.20 SPEAKER_01 То есть у тебя как репозиторий будут внутри репозиторий или рядом с репозиториями?
4485.20 4487.04 SPEAKER_01 Как это вообще технически это организовать?
4487.04 4500.40 SPEAKER_00 Ну у меня есть репозиторий, в котором лежит солюшен, который нужно склонировать, рядом склонировать репозиторий, допустим, с какими-то другими частями, а из солюшена, через какие-нибудь, знаешь, относительные пути, у меня будут ссылочки на CS Project.
4500.40 4504.56 SPEAKER_01 Да, но тогда у тебя получается, что структура не очень стандартная, да?
4504.56 4508.76 SPEAKER_01 Не когда у тебя солюшен лежит на верхнем уровне, а под низом там всякие папочки с проектами.
4508.76 4521.36 SPEAKER_00 И я согласен, поэтому фича выглядит немножко странной для солюшена, но написано, что можно это делать не только на солюшенах, но и просто открыть несколько гид-репозиторий из фолдера.
4521.36 4528.72 SPEAKER_00 Они приводят пример, что, ну например, вы работаете над каким-нибудь веб-проектом, и у вас часто там frontend и backend лежат в разных репозиториях.
4528.72 4532.04 SPEAKER_00 Но обычно это разные солюшены.
4532.04 4535.20 SPEAKER_00 Ну frontend это иногда вообще не солюшен.
4535.20 4536.20 SPEAKER_00 Давай начнем с этого.
4536.20 4540.80 SPEAKER_01 Ну в терминах нормальных людей, конечно же, это не солюшен, но скорее всего у них там есть какой-нибудь файл проекта.
4540.80 4555.72 SPEAKER_00 Ну вот, короче, по мнению Microsoft, теперь вы можете открыть одновременно и там, и там, и смысл фичи заключается в том, что когда вы будете говорить create branch, он будет создаваться одновременно во всех гид-репозиториях, когда вы будете говорить push, он будет вас спрашивать там в каком порядке запушить и пушить во все репозитории.
4555.72 4559.80 SPEAKER_00 Когда вы будете переключать branch, он будет переключаться во всех репозиториях одновременно.
4559.80 4569.52 SPEAKER_00 Что-то в этом есть, то есть мне иногда полезна фича, когда на нескольких гид-репозиториях нужно одновременно переключиться на мой какой-нибудь branch, на котором я работаю.
4569.52 4574.36 SPEAKER_00 Но как это будет работать в реальной жизни, пока непонятно.
4574.36 4579.60 SPEAKER_01 Ну да, с несколькими репозиториями это как-то выглядит довольно пока непонятно.
4579.60 4590.64 SPEAKER_00 Ну то есть у нас был кейс, у нас был проект, как-то действительно, ну там по сути получалось, что у тебя несколько сервисов живут, каждый в своем solution и каждый в своем репозитории.
4590.64 4598.12 SPEAKER_00 Плюс еще библиотечка какая-то была, которая тоже живет, ну типа Nuget свой, он тоже с отдельной solution, но в отдельном репозитории.
4598.12 4604.08 SPEAKER_00 Была необходимость работать с ними со всеми одновременно, создав везде один и тот же branch.
4604.08 4608.28 SPEAKER_01 Не, ну это окей, но скорее всего для этого используются обычно сабмодули.
4608.28 4610.12 SPEAKER_01 Нет, зачем сабмодули, почему?
4610.12 4615.76 SPEAKER_00 Я Nuget же solution собираю, он пабличится в Nuget, какой мне сабмодуль, зачем мне сабмодуль для Nuget?
4615.76 4620.48 SPEAKER_01 Нет, здесь же проблема не в Nuget solution, а именно в его физическом расположении.
4620.48 4630.96 SPEAKER_01 Nuget или не Nuget, это не важно, что ты соберешь, главное как ты его расположишь у себя на диске, то есть каким образом ты на диске себе сделаешь 10 репозиторий рядом и на них натравишь один solution.
4630.96 4639.00 SPEAKER_00 Вот у меня это были разные solution, это было 3 разных solution в 3 разных репозиториях, но мне хотелось с ними работать как бы одновременно, везде создавать один и тот же
4639.00 4641.00 SPEAKER_01 branch. Ну это окей, но кажется, что это не твой кейс.
4641.00 4642.00 SPEAKER_01 Вот непонятно.
4642.00 4645.92 SPEAKER_01 Они так смотрят, что у тебя обязан быть один solution, иначе студия его не откроет, она не поймет, что открывать.
4645.92 4651.08 SPEAKER_00 Я согласен, непонятно пока, как это работает и как это будет выглядеть, но я не пробовал ещё.
4651.08 4659.92 SPEAKER_00 У меня стоит, кстати, по-моему, 17.4 по идее, я обновлялся сразу после релиза, так что теоретически у меня это есть, можно проверить, надо будет попробовать, может быть проверю, расскажу.
4659.92 4664.72 SPEAKER_01 Ну проверить ты можешь, что оно работает, просто непонятно, как это применять на практике.
4664.72 4670.76 SPEAKER_00 Ну вот, может быть мы последим, если появятся статьи про то, что вау, как это круто, мы не знали.
4670.76 4674.20 SPEAKER_00 Или если такую штуку завезут в райдер, потому что в райдере по-моему такого нету.
4674.20 4676.60 SPEAKER_00 Значит, эта штука действительно полезная.
4676.60 4684.36 SPEAKER_00 Так, параллельно с 17.4 релизом, естественно, зарелизился 17.5, превью 1.
4684.36 4686.80 SPEAKER_00 Там появились интересные штуки.
4686.80 4692.04 SPEAKER_00 Это понятно, что это превью 1, там ничего супер крутого обычно не завозят, но тем не менее.
4692.04 4699.04 SPEAKER_00 У нас теперь можно расцвечивать табы через RegEx, вы можете взять RegEx для матчинга соответствующих цветов.
4699.04 4703.12 SPEAKER_00 Я не знаю, опять же, зачем, но нужно, видимо, кому-то.
4703.12 4705.24 SPEAKER_00 Markdown поддержку улучшили.
4705.24 4724.88 SPEAKER_00 Если вам надоело, что при запуске вашего ASP.NET-приложения у вас открывается консолька, отдельная, в которой output пишется, то начиная с Visual Studio 17.5 превью 1 этот output будет перехватываться и писаться в терминалке, что-то внутри, в Tool Window в студии, без отдельной консольки.
4724.88 4730.24 SPEAKER_01 Блин, это самая большая фишка, которая меня бесит в райдере, и вот и они тут даже.
4730.24 4731.24 SPEAKER_01 Ну что это такое?
4731.24 4732.24 SPEAKER_00 Возможно, это отключаемо, посмотрим.
4732.24 4733.24 SPEAKER_00 Ну, будем надеяться.
4733.24 4737.56 SPEAKER_00 Когда доберемся, я надеюсь, у нас будет какая-нибудь отдельная статья про превью 1, где мы подробно это рассмотрим.
4737.56 4746.04 SPEAKER_00 И еще в дебагере, я вот не знаю, эта фича появилась уже в 17.4, в дебагере есть такая штука под названием Managed Memory.
4746.04 4751.56 SPEAKER_00 Не, ну по идее она была и раньше, наверное, всегда можно было посмотреть memory по определенному адресу.
4751.56 4766.80 SPEAKER_00 Но здесь это именно фишка под названием Managed Memory, в которой есть Duplicate String Visualizer, то есть теперь есть таблочка, в которой можно посмотреть все аллоцированные за время приложения работы строки, со статистикой, какие строки, в каком количестве были зааллоцированы, и есть ли там повторение.
4766.80 4771.44 SPEAKER_00 То есть прямо вот конкретно про Duplicate String.
4771.44 4782.60 SPEAKER_00 Скорее всего они будут, видимо, эту штуку развивать дальше, и там полноценной dot memory, наверное, не получится, но может быть что-то близкое потихонечку начнет вырисовываться.
4782.60 4785.96 SPEAKER_00 Надо сказать, что про студию, наверное, это все.
4785.96 4793.32 SPEAKER_00 В райдере, соответственно, используйте YAPK, и только YAPK полноценно поддерживает седьмой .NET.
4793.32 4801.00 SPEAKER_00 Надо сказать, что за время, собственно, подкаста с момента прошлого релиза на шестого .NET мы все время про студию говорили в трех ключах.
4801.00 4808.52 SPEAKER_00 У нас была просто студия, у нас была студия для Mac'а, и у нас была студия для ARM64.
4808.52 4814.76 SPEAKER_00 Сейчас студия для ARM64 это уже, собственно, никакая не отдельная студия, это просто студия.
4814.76 4820.16 SPEAKER_00 Она есть, она вышла тоже в том числе, то есть версия 17.4 доступна для ARM.
4820.16 4826.36 SPEAKER_00 Там есть не все workloads, которые вы, может быть, хотели бы там видеть.
4826.36 4831.28 SPEAKER_00 Там есть поддержка .NET, Desktop Development, причем как .NET и так плюсов.
4831.28 4840.52 SPEAKER_00 Там есть ASP.NET, понятное дело, Web Development, UVP, экстенджеры можно девелопить, игрушки можно девелопить на C++ и на Node.js можно девелопить.
4840.52 4844.48 SPEAKER_00 Вот это только те workloads, которые поддержаны на студии на ARM64.
4844.48 4853.24 SPEAKER_00 Собирать при этом их можно, используя седьмой или шестой .NET и .NET Framework 481, которые, как мы помним, обновились для поддержки ARM64.
4853.24 4860.68 SPEAKER_00 MAUI не поддержана, так что если вы планируете работать с MAUI, то пока не используйте ARM64 в Visual Studio.
4860.68 4863.28 SPEAKER_00 В общем, это все, что можно сказать про ARM64.
4863.28 4871.64 SPEAKER_00 Я не думаю, что какие-то будут отдельные дальше у нас упоминания конкретно про ARM64, кроме если каких-то отдельных кейсов.
4871.64 4874.92 SPEAKER_00 Что же там такое интересное завезли про Mac?
4874.92 4878.28 SPEAKER_00 Кстати, тишина и ничего не сказали в момент релиза.
4878.28 4884.68 SPEAKER_00 Я, по крайней мере, не видел нигде в анонсах никаких упоминаний про Visual Studio for Mac.
4884.68 4896.64 SPEAKER_00 Зато в версии 17.4 появилась фича под названием Visual Studio for Mac Rollback, которая позволяет откатить Visual Studio к предыдущему состоянию.
4896.64 4904.04 SPEAKER_00 Но единственное, что она позволяет сделать, это откатить версию к предыдущей заинсталированной версии, которая у вас была до этого.
4904.04 4906.92 SPEAKER_00 Дальше там есть тонкости с тем, что останется, что будет удалено.
4906.92 4917.68 SPEAKER_00 Если у вас были всякие там темы, фонты, клавиатурные сокращения, которые вы настроили, или положение окон, это все будет сохранено.
4917.68 4932.48 SPEAKER_00 Если у вас были какие-то профайлы специальные или юзер-сеттинги, которые не входят в набор синхронизируемых сеттингов, я не знаю, как это сходу понять, входит или не входит, то такие штуки будут заресторены в дефолт.
4932.48 4946.76 SPEAKER_00 И при этом, если вы делаете роллбэк на прошлую версию, то всяческие компоненты, которые входят в Visual Studio, там всякие SDK, вот это все, все, что оунится в самой Visual Studio, они будут зароллбэтчены.
4946.76 4959.68 SPEAKER_00 Если же какие-то есть системные компоненты, ну как пример это Ease, который в студии может быть поставлен, но Ease это такая системная компонента, которой может быть только одна и соответственно ее роллбэтчить не будут.
4959.68 4967.80 SPEAKER_00 Экстенджены могут быть тоже заанинсталлены, которые юзер инсталлил, и нельзя откатываться совсем уж назад.
4967.80 4977.70 SPEAKER_00 То есть для версии 17.4 вы можете откатиться максимум на 17.0.10 или 17.1.7, а для превью ченнелы только на 17.2 превью один.
4977.70 4981.24 SPEAKER_00 Зароллбэтчиться можно через UI или через command line.
4981.24 4989.20 SPEAKER_00 Дальше, в общем звучит в принципе норм, хотя есть несколько интересных моментов.
4989.20 4999.96 SPEAKER_00 В обсуждении этой статьи, ну в комментах к этой статье про анонс, там написано типа "Ооо, кажется студию 17.4 ставить нельзя, если они вписали туда такую фичу, значит они не уверены в качестве студии".
4999.96 5005.20 SPEAKER_00 Вот, типа надо ждать превьюшек, ну не превьюшек, а типа сервиспака в дальнейших.
5005.20 5014.36 SPEAKER_00 Второй момент, что, представьте, у вас стояло там не знаю 17, кто у нас там был в прошлом, ну 3 видимо, или там 17.2.
5014.36 5017.00 SPEAKER_00 Вы поставили 17.4, попробовать.
5017.00 5019.44 SPEAKER_00 Ну релиз, там все дела, дот над 7 хочется.
5019.44 5022.40 SPEAKER_00 Там например что-то не работает.
5022.40 5032.80 SPEAKER_00 Вы подумали, интересно, а не исправлено ли это в последнем каком-нибудь хотфиксе, и ну вот пока вы там пробовали и ждали, вышел хотфикс какой-нибудь, да, 17.4.1.
5032.80 5038.48 SPEAKER_00 Вы поставили 17.4.1, выяснили, что ваш баг не пофикшен, который вам там мешает в содалей поведении.
5038.48 5040.12 SPEAKER_00 Вы хотите сделать роллбэк?
5040.12 5042.56 SPEAKER_00 Куда вы сможете сделать роллбэк?
5042.56 5046.08 SPEAKER_01 Ну зависит от того, сколько версий там она хранит и как она их хранит.
5046.08 5052.92 SPEAKER_00 Хранит она ровно одну, поэтому вы сможете сделать откат только на 17.4, хотя хотелось бы на 17.2.
5052.92 5055.00 SPEAKER_00 Понятное дело, на ту, которая была стабильная.
5055.00 5066.52 SPEAKER_00 На самом деле там тоже был вопрос, хранит ли она что-то, она не хранит, она хранит только мета-данные, то есть непосредственно бинарников ничего не хранится, она их заново из интернета скачает и как бы поставит.
5066.52 5069.68 SPEAKER_00 Просто она это сделает с восстановлением каких-то сеттингов.
5069.68 5070.68 SPEAKER_00 Ну смысл в том…
5070.68 5074.96 SPEAKER_01 Не, ну твои-то шоткаты и вот эти положения окон, как ты говорила, они уже все, наверняка должны
5074.96 5080.92 SPEAKER_00 охранить локально. Не-не-не, это-то понятно, она хранит, ну в смысле, что она это возьмет из вот текущей студии.
5080.92 5090.60 SPEAKER_00 Не в смысле, что она… если вы поставили, не знаю, использовали 17.2, там настроили окна, поставили 17.4, перенастроили окна, откатились на 17.2, настройки окон останутся новыми от 17.4.
5090.60 5094.80 SPEAKER_01 А, я как раз думал, что она в том числе сохраняет и старые настройки окон.
5094.80 5100.76 SPEAKER_00 Не-не-не, она именно в смысле, что она чисто обновит, ну бинарники, но постарается сохранить настройки.
5100.76 5113.52 SPEAKER_00 То есть, грубо говоря, ну как, я не знаю, винда с апдейтами, то есть ты типа от того, что ты перенастроил чуть-чуть винду, постольку накатились апдейты, если ты снесешь апдейт, если этот апдейт не касался конкретной настройки, ну ничего не поменяется, настройки-то сохранятся.
5113.52 5120.80 SPEAKER_01 Слушай, а какая разница, если я вот снесу 17.4 и поставлю, ну, себе дезербитива, поставлю ручками 17.2, 17.3, какая разница?
5120.80 5124.32 SPEAKER_00 Там, я так понимаю, что скорее всего с настройками будет, не все так хорошо.
5124.32 5128.40 SPEAKER_00 Хотя, если они синхронизируются и через какую-нибудь облако синхронизируются, то должно быть пофигу.
5128.40 5129.40 SPEAKER_00 Не знаю.
5129.40 5130.40 SPEAKER_00 Типа да.
5130.40 5146.16 SPEAKER_00 Ну вот народ написал в таких комментах, что ну блин, если вот в том сценарии, что я перечислил, да, попробовали поставить hotfix, не помогло, хочу теперь откатиться, а откатиться я теперь не могу, потому что я поставил hotfix, я могу откатиться только на основную версию, а на предыдущую безбажную не могу, кажется, проще снести и поставить.
5146.16 5152.56 SPEAKER_00 В общем, странная фича, непонятно зачем сделана, непонятно зачем именно в таком виде сделана.
5152.56 5160.36 SPEAKER_00 С другой стороны, ну то есть, тот же, допустим, тулбокс от JetBrains, он тоже позволяет делать rollback, но там можно настроить сколько старых версий ты хранишь.
5160.36 5164.12 SPEAKER_00 Одну, две, три, пять, я не помню, есть ли там лимит, ну понятно.
5164.12 5171.84 SPEAKER_00 Но там все понятно, там они каждый ставят свою папочку, ну вот он просто переключит вас на старую папочку и все будет работать.
5171.84 5175.64 SPEAKER_01 Ну, может быть, эту штуку тоже допилят, будет тебе 10 версий хранить.
5175.64 5180.28 SPEAKER_01 Теперь мы чистим свой диск, не только от JetBrains будем чистить, а будем чистить свой диск еще от Visual Studio.
5180.28 5181.28 SPEAKER_00 А почему нет?
5181.28 5182.28 SPEAKER_00 Вот.
5182.28 5183.28 SPEAKER_00 Действительно.
5183.28 5187.56 SPEAKER_00 Это Visual Studio, давай теперь поговорим про NuGet, там тоже есть что новенького.
5187.56 5197.00 SPEAKER_01 Да, давай, не то чтобы прям много всего интересного, но такие концептуальные вещи, которых мы, опять же, упоминали в течение года, в NuGet и новом тоже зарелизились.
5197.00 5205.84 SPEAKER_01 NuGet вышел 6.4, и самым главным лейтмотивом этой версии – это, конечно же, Central Package Manager.
5205.84 5217.16 SPEAKER_01 Это специальный файлик, который можно положить в вашем солюшене, и он способен обрабатывать информацию для нескольких проектов, ну то есть для всех проектов, которые есть в вашем солюшене.
5217.16 5230.00 SPEAKER_01 Файлик называется directory.package.props, и он внутри себя содержит наименование пакетов и версии этих пакетов, которые приняты в вашем солюшене.
5230.00 5240.12 SPEAKER_01 Это значит, что теперь непосредственно в проектах вы можете указывать только наименования, которые нужны, те пакеты, которые нужны вашему проекту, и без указания версий.
5240.12 5244.76 SPEAKER_01 Версии он возьмет из вот этого глобального package management файла.
5244.76 5248.48 SPEAKER_01 Прелесть этого подхода в том, что вам больше не нужно консолидировать версии.
5248.48 5253.32 SPEAKER_01 То есть во всех проектах у вас в Сибибиблиотеке будут одно и то же версии.
5253.32 5260.04 SPEAKER_01 Это позволяет избежать кучи ошибок, это хорошо, это правильно, и плюсов у этого громадное количество.
5260.04 5268.84 SPEAKER_01 Но в принципе такую штуку вы могли сделать и раньше ручками с помощью сложной системы props и target файлов.
5268.84 5272.08 SPEAKER_01 Плюс вот этого подхода в том, что он поддерживается инструментарием.
5272.08 5288.48 SPEAKER_01 То есть там всякие Visual Studio, Riders, Nuget консольные приложения, все они понимают этот файлик, и в отличие от того кастомного подхода с костылями, они будут нормально обновлять здесь эти пакеты, нормально везде пробрасывать, нормально интеллисенсом подхватывать, и в общем дело нужное.
5288.48 5296.76 SPEAKER_01 В качестве велосипеда она живет давно и наконец-то прекрасно, что она теперь поддерживается официально и инструментарий соответственно тоже подхватил всю эту штуку.
5296.76 5307.20 SPEAKER_01 Еще одно интересное нововведение, это возможность указать элемент в наших props файлах, который называется Global Package Reference.
5307.20 5316.20 SPEAKER_01 Это штука, которая позволяет вам указать имя и версию пакета, которая автоматически подключится во все другие проекты.
5316.20 5320.20 SPEAKER_01 Типичным примером есть у нас анализаторы.
5320.20 5324.04 SPEAKER_01 Анализаторы обычно подключают просто ко всем проектам, которые есть в Solution.
5324.04 5332.88 SPEAKER_01 Опять же, это можно было добиться с помощью старых props файлов, но здесь поддержка инструментария, интеллисенсов и прочие вещи тоже часто хромали.
5332.88 5345.04 SPEAKER_01 Теперь у нас есть официальные директивы, официальные файли, как это можно сделать, и можно соответственно подключить любую библиотеку с любой версией прозрачно и однако всем проектам, которые в вашем Solution есть.
5345.04 5351.72 SPEAKER_01 Естественно, вы можете обновлять теперь ее в одном месте, можете контролировать использование, можете ее подменять в одном месте.
5351.72 5353.72 SPEAKER_01 Тоже довольно удобная штука.
5353.72 5355.40 SPEAKER_01 Будем пользоваться.
5355.40 5362.40 SPEAKER_01 Из мелочей увеличили производительность отображения и загрузки списка пакетов в Visual Studio.
5362.40 5376.92 SPEAKER_01 Наверняка многие из вас заходили в Visual Studio на вкладку Management Nugget Packages и долгие минуты и часы ждали, пока прогрузятся все пакеты, пока обновятся их версии, пока проверятся и сигнатуры, подтянутся ряды.
5376.92 5381.24 SPEAKER_01 Вот это все увеличили, говорят, обещают, что на 66%.
5381.24 5386.12 SPEAKER_01 Циферка небольшая, но довольно приятная, особенно если для тех, кто часто заходит в это визуальное окошко.
5386.12 5389.44 SPEAKER_00 Да, действительно штука удобная.
5389.44 5396.88 SPEAKER_00 Мы такое костыляли с помощью директории, как там это называлось, что там тоже, Props, не помню что.
5396.88 5409.68 SPEAKER_00 И действительно там была проблема в том, что не было возможности, ну или по крайней мере мы не нашли каких-то простых костылей, как ограничить, ну как убедиться, что в конкретных проектах ты таки не указал случайно нужную версию.
5409.68 5415.56 SPEAKER_00 И если указал, то она использовалась вместо той, которая указана в центральном версии.
5415.56 5424.44 SPEAKER_00 Здесь это все контролируется, там теперь можно контролировать, можно ли оверрайдить версии, и они оверрайдятся специальным прям атрибутом, version override.
5424.44 5426.76 SPEAKER_00 Поэтому здесь действительно все будет удобно и хорошо.
5426.76 5434.60 SPEAKER_01 Да, старый подход, он там основывался на какой-то концепции, главное не чихайте на этот файл, иначе все развалится.
5434.60 5437.76 SPEAKER_01 В общем, с новым все довольно более стабильно.
5437.76 5445.48 SPEAKER_00 Ну и давай поговорим то, про что я обещал в самой первой новости, в самом начале этого выпуска, про поддержку контейнеров.
5445.48 5452.08 SPEAKER_01 Да, давай, в принципе это кажется единственной нашей статьей, которой нет Microsoft за весь сегодняшний выпуск.
5452.08 5467.00 SPEAKER_01 Но статья грамотная, она еще покрывает несколько интересных смежных тем, делает это правильно, с хорошими цифрами, поэтому мы решили ее добавить в выпуск, и поговорим мы как раз-таки о поддержке контейнеров, и что интересного на этой поприще есть в Дотэнт 7.
5467.00 5470.72 SPEAKER_01 Прежде всего хочется вас познакомить с таким понятием, как числт убунту контейнер.
5470.72 5477.32 SPEAKER_01 Это специальный контейнер, который очень маленький и очень секурный.
5477.32 5479.48 SPEAKER_01 Он поставляется официальным каноникалом.
5479.48 5487.20 SPEAKER_01 И его преимущество в том, что он где-то на 100% меньше обычной стандартной убунты.
5487.20 5494.24 SPEAKER_01 Если стандартная убунта у нас занимает 219 Мб, то числт контейнер занимает где-то 116 Мб.
5494.24 5498.52 SPEAKER_01 И так как он маленький, у этого есть много преимуществ.
5498.52 5503.48 SPEAKER_01 В частности, у нас очень сильно уменьшается площадь атаки.
5503.48 5510.24 SPEAKER_01 То есть у нас намного меньше инструментов, намного меньше утилит внутри контейнера содержится, намного меньше пакетов, которые могут быть атакованы.
5510.24 5516.00 SPEAKER_01 В которых могут найти баги, в которых могут найти уязвимости, какие-нибудь бэкдоры вам затянуть или еще что-то.
5516.00 5519.68 SPEAKER_01 В общем, чем меньше у вас зависимости, тем всегда это лучше.
5519.68 5525.24 SPEAKER_01 И вот это пример, когда попытались сделать вот такой минимальный контейнер по зависимости.
5525.24 5532.96 SPEAKER_01 Там нет пакетдж менеджера, там нет популярных пакетов предустановленных, которые обычно вы видите в своих контейнерах.
5532.96 5535.52 SPEAKER_01 Там вообще даже нет шела.
5535.52 5537.96 SPEAKER_01 И там нет рутового пользователя.
5537.96 5541.16 SPEAKER_01 Там обычный юзер без рута.
5541.16 5547.92 SPEAKER_01 Специфика этого контейнера заключается в том, что вы там даже не сможете выполнить баши, потому что там нет баши.
5547.92 5552.00 SPEAKER_01 Вы там не сможете даже выполнить команду ls, там показать список файлов, потому что там нет команды ls.
5552.00 5560.56 SPEAKER_01 То есть даже таких элементарных базовых утилит, с помощью которых вы обычно там навигируетесь по контейнеру и там ищите какие-нибудь проблемы, их там нет.
5560.56 5568.32 SPEAKER_01 Поэтому отлаживать, возможно, вам будет его немножко сложнее на первом этапе, но зато размер и, соответственно, площадь атаки очень сильно уменьшена.
5568.32 5575.56 SPEAKER_01 Вот такой контейнер, он сейчас официально поддерживается Майкрософтом, он лежит в репозитории Майкрософта с контейнерами.
5575.56 5579.84 SPEAKER_01 Соответственно, его можно легко и непринужденно завязать в ваших приложениях.
5579.84 5586.24 SPEAKER_00 Тут надо сказать, что он не то чтобы поддерживается Майкрософтом, он еще поддерживается Каноникалом, что тоже важно.
5586.24 5589.24 SPEAKER_00 То есть Каноникал это тот, кто дистрибьютирует и производит Ubuntu.
5589.24 5594.84 SPEAKER_00 То есть это не просто Майкрософт решила взять и что-нибудь там урезать, это прям Каноникал.
5594.84 5597.44 SPEAKER_00 Вместе с Майкрософтом сделали такую штуку совместную.
5597.44 5607.16 SPEAKER_01 Ну да, я подозреваю, что Каноникал сделал числот образ, а Майкрософт просто добавил туда зависимости для того, чтобы запускать там Дотнет.
5607.16 5608.16 SPEAKER_01 Скорее всего.
5608.16 5613.48 SPEAKER_01 Как всегда они, в принципе, на таком уровне взаимодействия у них идет.
5613.48 5623.84 SPEAKER_01 Вот, и еще одно нововведение, то есть это не еще одно нововведение, это нововведение, которое было сделано в Дотнет 7, которое мы уже тоже упоминали, это возможность генерировать докер-файлы.
5623.84 5631.36 SPEAKER_01 Как вы, наверное, все уже знаете, чтобы упаковать приложение в докер-контейнер, у нас есть так называемые докер-файлы.
5631.36 5636.08 SPEAKER_01 У них там свой синдекс, если они там каким-то образом описываются, думаю, что с этим вы уже все знакомы.
5636.08 5651.80 SPEAKER_01 Вот, и, соответственно, новинка Дотнет 7 SDK заключается в том, что теперь вам не обязательно делать отдельный рядышком стоящий докер-файл для того, чтобы сделать имидж, в котором лежит ваше приложение.
5651.80 5665.64 SPEAKER_01 Микрософт изобрел новый output type, то есть достаточно в Дотнет паблише указать специальные магические ключи и у вас в результате вашего паблиша получится уже полноценный докер-имидж без всякого докер-файла.
5665.64 5682.92 SPEAKER_01 Единственное, что вам нужно сделать, это подключить к вашему проекту специальный пакет, ну, get-пакет, который называется Microsoft.NET Build Containers, но это все на уровне пока разработки, и в будущем этого пакета тоже подключать не нужно будет, он будет входить в стандартные SDK Дотнета.
5682.92 5684.84 SPEAKER_01 Пока это так.
5684.84 5688.48 SPEAKER_01 В общем, если не нужно будет подключать никаких пакетов, это совсем прекрасно.
5688.48 5698.32 SPEAKER_01 Вот вы делаете команду dotnet-publish, указываете ей там, что хотите, опясываете систему Linux и передаете ее в специальный флажок, который называется publish-para-file и равняется он дефолт-контейнеру.
5698.32 5707.84 SPEAKER_01 И в результате чего в вашем распоряжении получается, как я уже сказал, докер-имидж, по дефолту его размер 216 или около того мегабайт.
5707.84 5714.00 SPEAKER_01 И этот имидж, его можно настраивать.
5714.00 5721.32 SPEAKER_01 Обычно мы настраиваем докер-контейнеры через докер-файл, так как у нас докер-файла нет, то мы можем настраивать через MS Build свойства.
5721.32 5734.12 SPEAKER_01 Через свойства наших MS-publish-файлов, props-файлов, targets-файлов, там можно указать имя контейнера, там можно указать теги и кучу-кучу других разных параметров, которые обычно вы указываете в дотнет-файле.
5734.12 5737.12 SPEAKER_01 В докер-файле.
5737.12 5738.12 SPEAKER_01 Извините.
5738.12 5739.12 SPEAKER_01 Вот.
5739.12 5742.64 SPEAKER_01 Это то нововведение, которое у нас есть в дотнет-7 SDK.
5742.64 5747.72 SPEAKER_01 Теперь, каким же образом нам теперь свести вместе два этих интересных новости?
5747.72 5748.72 SPEAKER_01 Свести их довольно просто.
5748.72 5753.40 SPEAKER_01 Как я уже сказал, в MS Build файле мы можем настраивать докер-контейнеры.
5753.40 5757.00 SPEAKER_01 Там есть специальный ключевой элемент, который называется container-base-image.
5757.00 5761.72 SPEAKER_01 И в качестве базового имиджа мы можем указать вот этот числт-образ.
5761.72 5776.04 SPEAKER_01 В результате чего мы набираем команду dotnet-publish и у нас уже появляется докер-имидж размером 112 мегабайт против наших 216, которые были буквально одну команду назад.
5776.04 5779.42 SPEAKER_01 Мы всего лишь навсего что и сделали, это поменяли базовый образ.
5779.42 5783.26 SPEAKER_01 То есть мы выиграли 104 мегабайта на пустом месте.
5783.26 5787.88 SPEAKER_01 Довольно неплохой результат, но в принципе можно сделать еще лучше и еще больше.
5787.88 5791.52 SPEAKER_01 В частности, мы можем сделать self-content.
5791.52 5799.48 SPEAKER_01 Насколько вы, наверное, уже в курсе, у нас дотнет умеет поставляться без дотнет-рантайма.
5799.48 5802.28 SPEAKER_01 Дотнет-рантайм ему не обязателен.
5802.28 5807.44 SPEAKER_01 Он может включить все библиотеки, которые нужны вашему приложению внутрь этого приложения.
5807.44 5813.64 SPEAKER_01 То есть тут вообще скопировать все ассембли, все дейдельки и все, что ему нужно, просто в одну папочку.
5813.64 5820.72 SPEAKER_01 Вот если мы воспользуемся этой функциональностью, сделаем self-content, тогда у нас появится такая возможность, как затримить наше приложение.
5820.72 5822.56 SPEAKER_01 То есть убрать все ненужное.
5822.56 5826.88 SPEAKER_01 То есть мы не должны тащить с собой весь огромный SDK, весь огромный рантайм.
5826.88 5835.76 SPEAKER_01 Мы можем проанализировать наше приложение и сказать, какие сборки нужны, какие не нужны.
5835.76 5839.12 SPEAKER_01 И вот флажок Trimton как раз это и делает.
5839.12 5855.72 SPEAKER_01 Если мы запустим теперь нашу сборку, наш паблиш вместе с усечением и вместе с self-content, то результирующий образ у нас будет всего лишь на 56 Мб.
5855.72 5864.72 SPEAKER_01 То есть сравнивая с предыдущими 112 Мб, мы сэкономили еще 55 Мб, что тоже довольно крутецкая оптимизация.
5864.72 5869.24 SPEAKER_01 Можно сделать еще немножко поменьше.
5869.24 5878.56 SPEAKER_01 Секрет заключается в том, что self-content приложение, которое внутри себя включает все, что ему нужно для запуска, его еще можно собрать в один единственный файлик.
5878.56 5885.84 SPEAKER_01 То есть у нас есть папочка, в которой было много сборок до этого, а теперь у нас будет папочка, в которой лежит всего лишь один единственный файл.
5885.84 5889.84 SPEAKER_01 Один бинарник и внутри этого бинарника зашиты все множество-множество сборок.
5889.84 5899.00 SPEAKER_01 Тут нужно уточнить, что у этого подхода есть некоторые ограничения и существует специальный сценарий, где такая штука работать не будет, где она не поддерживается.
5899.00 5905.04 SPEAKER_01 Но в общем, как потенциально возможная оптимизация, он существует.
5905.04 5912.68 SPEAKER_01 В результате такой махинации, в результате сингл-файла у нас появится один единственный файл размером 48 мегабайт.
5912.68 5918.64 SPEAKER_01 Сравнивая с предыдущими пятью, десятью, шестью, мы выиграли 8 мегабайт.
5918.64 5927.00 SPEAKER_01 Не то чтобы много, но в принципе на размерах, на размерах которых мы уже работаем, там в размерах 50 мегабайт, 8 мегабайт, это в принципе существенная часть.
5927.00 5930.76 SPEAKER_01 Поэтому тоже хорошая качественная оптимизация.
5930.76 5939.24 SPEAKER_01 Еще одна интересная оптимизация, которая существует в Дотнете, это штука, которая называется invariant globalization.
5939.24 5963.64 SPEAKER_01 То есть если в вашем приложении вы не используете никаким образом различные культуры, вы не форматируете, допустим, даты на русском языке, вы не сравниваете строки на греческом языке, в общем все вот эти штуки вам не нужны, а эта вероятность довольно большая, потому что большинство Дотнет-приложений это все-таки какие-нибудь серверные бэкэнды.
5963.64 5970.12 SPEAKER_01 И на серверных бэкэндах существует такая best practice, что вам там ни в коем случае не нужна никакая локализация.
5970.12 5973.00 SPEAKER_01 Там все должно быть в invariant и в UTC.
5973.00 5977.44 SPEAKER_01 То есть ни времен, ни локализации быть не должно и в помине.
5977.44 5986.00 SPEAKER_01 Локализация и времена, всякие часовые зоны вам нужны только там, где вы представляете уже непосредственно пользователя.
5986.00 5993.60 SPEAKER_01 То есть это или UI, или какие-нибудь отчеты, или какие-нибудь письма, то есть какое-нибудь уже конечное представление для пользователя.
5993.60 6003.56 SPEAKER_01 Если у вас чистый бэкэнд, который суровый, письма не шлет, с пользователем не взаимодействует, а чисто что-то там у себя крутит, вы вполне легко, скорее всего, можете этот флажок использовать.
6003.56 6016.04 SPEAKER_01 И это очень крутой флажок, когда вы говорите «удали мне все культуры, которые там у тебя есть, все транслейшн, которые у тебя есть, все ресурсы с переводами, которые у тебя есть, оставь только invariant globalization».
6016.04 6026.20 SPEAKER_01 Если вы такой флажок задаете, то обычно у вас тоже… у вас тоже огромный прирост в месте, то есть очень много места освобождается.
6026.20 6032.00 SPEAKER_01 В данном же случае автор попробовал сделать проверную такую штуку, и у него практически ничего не получилось.
6032.00 6038.32 SPEAKER_01 Из 48,4 мегабайта у него стало 48,3 мегабайта.
6038.32 6045.92 SPEAKER_01 То есть он удалил глобализацию только из своего конкретного приложения, которых и так было немного.
6045.92 6049.40 SPEAKER_01 А с фреймворка ничего не случилось.
6049.40 6050.68 SPEAKER_01 Секрет очень простой.
6050.68 6057.44 SPEAKER_01 Дело в том, что вот этот числ имидж, он уже внутри себя содержит вот эту функциональность.
6057.44 6065.60 SPEAKER_01 Он уже внутри себя, по сути, удалил всю глобализацию, все вот эти ресурсы, которые нужны для использования различных языков, ее там уже нет.
6065.60 6069.16 SPEAKER_01 Поэтому он такой компактный, большой и красивый.
6069.16 6074.16 SPEAKER_01 Проделав все эти возможные на данный момент оптимизации, которые у нас получились, давайте подведем итог.
6074.16 6077.00 SPEAKER_01 Изначальный имидж у нас был 216 мегабайт.
6077.00 6084.04 SPEAKER_01 Это, скорее всего, то, что имеет каждое дотальное приложение в ваших проектах.
6084.04 6097.60 SPEAKER_01 Это тот размер, который у вас будет по дефолту, если вы используете все дефолтные настройки, дефолтные контейнеры, дефолтные паблиши, вы примерно получите ваше приложение примерно в контейнере 216 мегабайт.
6097.60 6104.20 SPEAKER_01 И довольно элементарно, простыми действиями, его можно довести всего лишь навсего до 48 мегабайт.
6104.20 6109.12 SPEAKER_01 То есть, по факту, это 77% удалось нам ужать.
6109.12 6120.08 SPEAKER_01 Вот такими незамысловатыми способами, используя знания от, даже не знания, а имидж от Canonical с Microsoft и небольшие знания по оптимизации, по отримингу нашего приложения.
6120.08 6124.08 SPEAKER_01 То есть, сейчас у нас примерный имидж, минимальный имидж дотлнет приложения.
6124.08 6130.92 SPEAKER_01 Опять же, мы сейчас говорим не про какой-то экстремальный минимализм, а такой вполне бытовой, вполне рабочий, вполне повседневный.
6130.92 6133.52 SPEAKER_01 И это 48 мегабайт.
6133.52 6136.60 SPEAKER_00 Все было бы хорошо, если бы...
6136.60 6141.96 SPEAKER_00 Нет, ну все-таки мне кажется, что self-contained и trimming это пока еще не настолько популярная штука.
6141.96 6148.20 SPEAKER_00 Ну, self-contained популярная, а вот trimming, по-моему, пока еще не настолько популярная штука, тем более и паблишинг сингл файл.
6148.20 6159.16 SPEAKER_00 Это тоже отдельный вопрос, поэтому я бы сказал, что ну, наверное, справедливость ради не 48, а все-таки 56, если мы уберем сингл файл паблишинг.
6159.16 6167.12 SPEAKER_00 Ну и опять же, то, что мы уменьшили с 216, это если мы использовали стандартный ubuntu-овский обычный базовый имидж.
6167.12 6182.96 SPEAKER_00 Я же, например, ну у нас практически все живет на alpine, alpine поменьше, но с alpine есть как бы проблема, ну не то чтобы проблема, alpine это все-таки не distroless, насколько я помню, то есть там есть root, там есть вот все те самые баши и все такое прочее, то есть секьюрность у него все-таки поменьше.
6182.96 6190.56 SPEAKER_00 Поэтому тут надо выбирать, надо посмотреть, нельзя ли из alpine получить такую конструкцию урезанную, тут вот не знаю.
6190.56 6199.16 SPEAKER_01 Да, да, да, ты во всем прав, действительно хотелось бы от alpine тоже все отсечь ненужное и посмотреть, сколько он сможет выдать на таких размерах.
6199.16 6213.96 SPEAKER_00 Ну может кто-то где-то это уже сделал, если вдруг вы знаете какие-нибудь там правильные distroless базовые имиджи для дотонета и майкрософта, и alpine, расскажите нам в комментариях где-нибудь, мы это дело попробуем проверим, посмотрим.
6213.96 6218.20 SPEAKER_00 Может быть даже попробуем собрать какое-нибудь такое же приложение и посмотреть какого размера оно получается.
6218.20 6221.00 SPEAKER_00 Ну а на этом я думаю, что надо завершать.
6221.00 6228.32 SPEAKER_00 Мы собственно обозрели по-моему практически все, что было хоть как-то упомянуто на dotnet.conf.
6228.32 6235.32 SPEAKER_00 Понятно, что там был еще большой кусок, ну кстати не такой большой, как я ожидал, который был посвящен ажуру и прочим облакам.
6235.32 6238.80 SPEAKER_00 Там есть некоторое количество видео про эту тему, но не такое большое.
6238.80 6246.32 SPEAKER_00 Основное все-таки внимание было уделено действительно дотонету и всяким таким более фреймворк-ориентированным вещам.
6246.32 6265.84 SPEAKER_01 Как всегда в наших заметках к выпуску будет куча разных ссылок, в том числе ссылки на доклады, которые были непосредственно на dotnet.conf, поэтому проходите, читайте, смотрите, пробуйте сами, углубляйтесь в каждой темы, ходите по ссылкам глубже, переслушивайте наши выпуски, в общем тут поле для изучения довольно большое.
6265.84 6287.52 SPEAKER_00 Да, и часть ссылок ведет на learn.microsoft.com, который раньше был docs.com.msd, там прямо действительно сейчас очень хорошая документация, отличные статьи, которые не просто там описание класса и апишка, а именно прям вот хорошие учебные статьи, которые помогают очень сильно понять, как же все это работает вместе.
6287.52 6291.32 SPEAKER_00 Ну а на сегодня, наверное, будем завершаться.
6291.32 6311.20 SPEAKER_00 Мы отсмотрели все, мы отсмотрели dotnet.7, dotnet.conf, c#, f#, dotnet.conf, f#, f#, spanet, entity framework, ui, потрогали windows.forms, wpf, dotmall, потрогали экзотические вещи типа ml.net и arlinz, ну и посмотрели на tooling, visual studio в разных ее видах, nuget и поддержка контейнеров.
6311.20 6340.08 SPEAKER_00 В dotnet.7 новостей много, новости разные, будем следить теперь, что будет происходить, как будет адоптиться dotnet.7, какие будут выходить статьи на эту тему, и возможно какие-то ранние уже dotnet.8 штучки будут так или иначе появляться даже до первого превью, может быть нам что-нибудь попадется на глаза, мы начнем уже смотреть какие-то ранние, подсматривать я бы даже сказал, в ранние эксперименты команды на тему 8-го дотнета.
6340.08 6345.68 SPEAKER_01 Ну а на сегодня это достаточно, всем спасибо, кто дослушал до конца и до новых встреч, всем пока.
6345.68 6346.04 SPEAKER_00 Всем пока.
6346.04 6347.04 SPEAKER_00 С вами был я, Александр Малинин.
6347.04 6347.04 None И до новых встреч.
6347.04 6352.04 None Пока.
6352.04 6357.04 None Пока.
6357.04 6359.04 None *Субтитры делал DimaTorzok*
