0.00 8.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья.
8.36 11.24 "Анатолий Кулаков" В эфире Радио.нет выпуск номер 54.
11.24 14.16 "Анатолий Кулаков" И в студии сегодня будет Анатолий Кулаков.
14.16 15.16 "Игорь Лабутин" И Игорь Лабутин.
15.16 16.16 "Игорь Лабутин" Всем привет.
16.16 17.16 "Анатолий Кулаков" Отлично.
17.16 24.32 "Анатолий Кулаков" Давно уже не виделись, соскучились по всем, поэтому наконец-то выпуск, накопились новости.
24.32 29.44 "Анатолий Кулаков" Я напоминаю, что у нас есть сайт radio.net.ru.
29.44 34.96 "Анатолий Кулаков" Там можно переподписаться на новые РССК, если вдруг вы почему-то перестали нас слушать в вашем любимом плеере.
34.96 41.40 "Анатолий Кулаков" Также мы выкладываем свои виды в видео на YouTube, ВКонтакте и во всех подкастерских соцсетях, которые только возможно.
41.40 42.92 "Анатолий Кулаков" Я думаю, найдете нас без проблем.
42.92 47.76 "Анатолий Кулаков" А специально для тех людей, которые хотят нас поблагодарить, у нас есть сайт на Густи.
47.76 51.56 "Анатолий Кулаков" И список этих красавцев позвольте вам зачитать.
51.56 58.60 "Анатолий Кулаков" Прежде всего это Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья и Гурий Самарин.
58.60 64.20 "Анатолий Кулаков" Вот эти бравые ребята поддерживают нас уже много-много времени и большое им спасибо за это отдельное.
64.20 68.72 "Анатолий Кулаков" Ну что ж, чем мы сегодня займемся?
68.72 72.28 "Игорь Лабутин" Сегодня мы займемся тем же, чем занимаемся обычно.
72.28 75.04 "Игорь Лабутин" У нас есть кучка новостей от Microsoft.
75.04 79.40 "Игорь Лабутин" Новый, ну не то чтобы новый, обновленный Тулинг, обновленный .NET.
79.40 85.56 "Игорь Лабутин" Как обычно, затронем парочку или хотя бы одну статейку профита про общепрограммические вопросы.
85.56 90.88 "Игорь Лабутин" Так что сегодня самый обыкновенный, классический, я бы сказал, выпуск.
90.88 98.52 "Анатолий Кулаков" Прекрасно, и тинки хорошие, но давай перед разбегом сначала у меня для тебя есть интересная новость.
98.52 101.44 "Анатолий Кулаков" Представляем вам мир крутых IT решений.
101.44 105.96 "Анатолий Кулаков" Когда начинаешь думать о завтрашнем днём, приходит понимание всей индивидуальности.
105.96 110.80 "Анатолий Кулаков" Приходит время новых требований, мыслить масштабно, знать больше, видеть дальше.
110.80 113.08 "Анатолий Кулаков" Поэтому самое время заявить о себе.
113.08 119.00 "Анатолий Кулаков" Monopoly предлагает тебе создавать вместе платформы цифровой логистики на пике технологий.
119.00 124.40 "Анатолий Кулаков" IT-ландшафт компании разделён на продукты, востребованные клиентами и партнёрами.
124.40 131.28 "Анатолий Кулаков" Продукты, которые разрабатываются в современной Agile модели, опираясь на микросервисный подход с использованием актуального стека.
131.28 138.04 "Анатолий Кулаков" Если .NET, то Core, если интеграция, то на брокерах сообщений, если DeepLoyd, то в Kubernetes.
138.04 147.36 "Анатолий Кулаков" Это продукты для вечно востребованной отрасли транспортной логистики, собственных машин компаний и машин-партнёров, которые доставляют грузы по всей стране.
147.36 154.36 "Анатолий Кулаков" Уберизация грузовых перевозок - это направление актуальное и востребованное, что позволяет устойчиво держаться на рынке.
154.36 156.76 "Анатолий Кулаков" Внеси свой вклад в развитие цифровой логистики.
156.76 161.52 "Анатолий Кулаков" По ссылке в описании можно ознакомиться с более подробной информацией о ближайшем ярком будущем.
161.52 166.32 "Анатолий Кулаков" Слушай, как ты думаешь, когда уже пора переделывать .NET Core на просто .NET?
166.32 168.68 "Анатолий Кулаков" А то не очень понятно получается.
168.68 175.44 "Игорь Лабутин" Ну вообще уже конечно можно, потому что Microsoft везде прям пушит про то, что мы это всё теперь должны называть .NET.
175.44 180.28 "Игорь Лабутин" Есть конечно некое путанице среди тех, кто всё ещё использует .NET Framework одновременно.
180.28 182.72 "Игорь Лабутин" Да, да, не звучит.
182.72 188.60 "Игорь Лабутин" Не скажешь, что давай тут .NET, там .NET, потому что там .NET это Framework, а тут .NET это Core.
188.60 192.36 "Игорь Лабутин" Хотя, начиная с пятого, по-моему, да, у нас официально уже просто .NET?
192.36 193.36 "Анатолий Кулаков" Да, да, с пятого.
193.36 194.36 "Анатолий Кулаков" Как раз с LTS.
194.36 197.52 "Анатолий Кулаков" Ну, не с LTS, это с шестого и даже до LTS.
197.52 208.28 "Игорь Лабутин" Ну да, поэтому конечно надо потихонечку всё-таки переходить на .NET, а если мы говорим про старое, то прям явно указывать, типа там старый .NET Framework или что-нибудь в таком духе.
208.28 213.68 "Анатолий Кулаков" Ну насколько я видел документацию, как они переделали, они действительно называют это .NET Framework, просто .NET.
213.68 215.68 None Вот так они делят.
215.68 216.68 "Анатолий Кулаков" Общий деление.
216.68 222.24 "Игорь Лабутин" В документации хорошо, в разговоре не всегда понятно, потому что… Да, да, в разговоре всегда понятно.
222.24 224.24 "Игорь Лабутин" В разговоре ты часто используешь .NET или .NET, мало ли какой .NET.
224.24 225.24 "Игорь Лабутин" Я на .NET пишу давно.
225.24 232.68 "Анатолий Кулаков" Вообще интересно посмотреть на статистику, сколько вообще сейчас живых проектов на старом Framework и на новом .NET Core.
232.68 239.08 "Анатолий Кулаков" И вот когда мы увидим, что на старом их меньше или значительно меньше, тогда, наверное, можно про него как-то забывать.
239.08 244.28 "Игорь Лабутин" А вот я надеюсь, что… Не знаю, спойлер, не спойлер.
244.28 252.84 "Игорь Лабутин" Я надеюсь, что к следующему выпуску мы доберемся до обсуждения результатов голосовалок от Stack Overflow, может быть там будет ответ на этот вопрос в том числе.
252.84 254.40 "Анатолий Кулаков" Да, да, вполне вероятно.
254.40 260.48 None Так что не переключайтесь, несмотря на то, что статистику мы обсудим в следующем выпуске, об этом у нас тоже есть много о чем поговорить.
260.48 264.84 "Игорь Лабутин" Да, давай начнем потихонечку выпуск.
264.84 268.12 "Игорь Лабутин" И .NET у нас очередное превью.
268.12 269.96 "Игорь Лабутин" .NET 7, превью 5.
269.96 276.12 "Игорь Лабутин" Microsoft выпустила, как обычно у нас обновились все три больших компонента и много маленьких.
276.12 281.60 "Игорь Лабутин" И начнем мы по традиции с большого .NET, ну в смысле с основной части .NET.
281.60 286.60 "Игорь Лабутин" Для использования превью 5 вам нужна Visual Studio 17.3 превью 2.
286.60 297.72 "Игорь Лабутин" И в .NET вышло некоторое количество, как обычно, обновлений, то есть статья разбита на несколько разделов, про которые мы сейчас и пробежимся.
297.72 314.72 "Игорь Лабутин" Во-первых, если вы каким-то образом интересуетесь Observability и работаете с такими классами, как ActivityEvent или ActivityLink, то теперь у вас есть быстрый способ посмотреть на теги, которые есть внутри классов.
314.72 322.08 "Игорь Лабутин" То есть там есть коллекция тегов, и раньше, чтобы ее по-енумерейтить, нужно было, ну можно было использовать ForEach, но там не было нормального энумератора.
322.08 326.08 "Игорь Лабутин" То есть там был, грубо говоря, enumerable, который в итоге, если вы его энумерируете, то будет allocate.
326.08 331.24 "Игорь Лабутин" Сейчас там написали нормальный, хороший, быстрый энумератор, который структурка, ну в общем все как положено.
331.24 339.64 "Игорь Лабутин" И поэтому теперь, если вы каким-то образом реагируете на ивенты, и вам интересно, что там в тегах, то теперь это можно делать быстро и без аллокаций.
339.64 340.64 "Игорь Лабутин" Наверное, это хорошо.
340.64 341.64 "Игорь Лабутин" System.Text.JSON.
341.64 345.28 "Игорь Лабутин" Тут прям довольно много изменений.
345.28 352.20 "Игорь Лабутин" Во-первых, довольно часто я слышал, что System.Text.JSON ругают, что он не поддерживает полиморфной сериализации.
352.20 365.76 "Игорь Лабутин" То есть если у вас есть дерево классов, то вы не можете сериализовать, а потом десериализовать его, как допустим, ну если вы будете десериализовывать его, как там базовый класс, то вы его не десериализуете, как, ну все, дерево.
365.76 372.40 "Игорь Лабутин" Он действительно создаст базовый класс, потому что вы десериалайз передали тип базового класса.
372.40 376.28 "Игорь Лабутин" Наконец-таки нам завезли полиморфную сериализацию и десериализацию.
376.28 378.56 "Игорь Лабутин" Что для этого нужно сделать?
378.56 383.72 "Игорь Лабутин" На базовом классе нужно разметить все атрибутиками JSON.DerivedType.
383.72 390.00 "Игорь Лабутин" То есть вы на базовый класс вешаете атрибутик JSON.DerivedType, где вы указываете type of всех дочерних.
390.00 396.48 "Игорь Лабутин" Это немножко похоже на WCF, как они там назывались, known types, по-моему, это назывался атрибутик.
396.48 400.64 "Игорь Лабутин" То есть вы, около базового вам придется указать все явно дочерние.
400.64 402.72 "Игорь Лабутин" Пока, по крайней мере, так.
402.72 406.04 "Игорь Лабутин" После этого у вас будет работать нормальная сериализация.
406.04 413.16 "Игорь Лабутин" То есть если вы сериализовали что-то в JSON, то оно будет прекрасно сериализовываться, полиморфно, все дела.
413.16 415.88 "Игорь Лабутин" Все поля от всех дочерних типов корректно сериализуются.
415.88 422.88 "Игорь Лабутин" Но десериализация работать не будет, потому что когда вы читаете JSON, то там, вообще говоря, нет информации о типе.
422.88 429.36 "Игорь Лабутин" И .NET, Runtime понятия не имеет вообще, какой тип из возможных дочерних ему нужно создать.
429.36 432.60 "Игорь Лабутин" Особенно если вдруг вы сделали два дочерних класса, у которых одинаковый набор полей.
432.60 434.36 "Игорь Лабутин" Тогда вообще невозможно выбрать.
434.36 447.40 "Игорь Лабутин" Для того чтобы работала десериализация, вот в этом атрибутике JSON.DerivedType, когда вы указываете всех дочерних классов, нужно указать в конструкторе специальный параметр, называется discriminator.
447.40 448.96 "Игорь Лабутин" То есть какую-то строчку или число.
448.96 449.96 "Игорь Лабутин" А как эти типы отличать?
449.96 453.28 "Игорь Лабутин" То есть по сути вы руками именуете все дочерние классы.
453.28 457.20 "Игорь Лабутин" Можете именем этого класса, можете просто каким-то нужной строчкой.
457.20 469.64 "Игорь Лабутин" Если этот атрибутик есть, то при сериализации в JSON добавляется специальное поле под названием $type, типа оно системное, назовем это так.
469.64 474.40 "Игорь Лабутин" И именно его будет использовать десериализатор для того, чтобы нормально полиморфно десериализовать.
474.40 480.64 "Игорь Лабутин" То есть получится, что не любой JSON можно будет десериализовать, но по крайней мере round3 поработать будут.
480.64 484.16 "Игорь Лабутин" То есть если вы сериализовали вашим кодом, то десериализовать вашим же кодом вы сможете.
484.16 490.00 "Игорь Лабутин" Это, я так понимаю, относительно первый пробный подход к этой проблеме.
490.00 496.32 "Игорь Лабутин" Возможно, там будут какие-то изменения, но посмотрим на реакцию, посмотрим, как это будет использоваться.
496.32 500.84 "Игорь Лабутин" Продолжая тему JSON, у нас есть такой класс, называется UTF-8JSONReader.
500.84 513.16 "Игорь Лабутин" Это для быстрого чтения JSON, если вы уверены, что там UTF-8 строчка, то вы можете не парсить JSON через нормальный парсер, а читать его прямо из потока.
513.16 521.00 "Игорь Лабутин" И там был метод getString, который позволял вытащить строчку значения.
521.00 523.96 "Игорь Лабутин" Проблема в том, что он естественно лазерил строчку.
523.96 535.04 "Игорь Лабутин" Теперь появился метод copyString, который позволяет скопировать ту строчку, которую вы бы вытащили через getString в предоставленный вами же массив байтов, спан или еще куда-нибудь.
535.04 536.56 "Игорь Лабутин" Или массив чаров.
536.56 538.32 "Игорь Лабутин" Таким образом, без аллокаций.
538.32 542.64 "Игорь Лабутин" Так что теперь все можно парсить еще быстрее, еще с менее аллокациями.
542.64 557.76 "Игорь Лабутин" Source-генераторы зайпрувили вокруг JSON с реализацией, там добавили поддержку asyncEnumerable, типа JSONDocument, типа dateOnly и timeOnly, так что вокруг JSON опять какая-то довольно большая работа ведется.
557.76 564.24 "Игорь Лабутин" Интересное нововведение в классе System.io.String.
564.24 568.36 "Игорь Лабутин" Все кто когда-либо работал со стримами знают, что можно вызвать метод read.
568.36 574.64 "Игорь Лабутин" Он прочитает сколько-то байтов, ну или символов, в чем у вас там стрим.
574.64 578.48 "Игорь Лабутин" И байтов, конечно же, какие символы в стриме.
578.48 582.08 "Игорь Лабутин" Но он не гарантирует, что он вам прочитает ровно столько, сколько вы попросили.
582.08 591.32 "Игорь Лабутин" Даже если вы передали до буфера, не знаю, 4 килобайта, то он может прочитать 1 байт, он может прочитать 4 килобайта, то есть сколько-то, неизвестно сколько.
591.32 596.60 "Игорь Лабутин" И был классический паттерн, что вам нужно это делать в цикле, пока вы не прочитаете столько, сколько вам надо.
596.60 602.56 "Игорь Лабутин" Видимо, этот паттерн был настолько распространен, что теперь в System.io.String есть два новых метода.
602.56 606.36 "Игорь Лабутин" Один называется readExactly, второй называется readAtleast.
606.36 615.20 "Игорь Лабутин" Первый, соответственно, читает ровно столько байт, сколько вы передали, второй читает как минимум столько байт, сколько вы попросили до буфера.
615.20 620.68 "Игорь Лабутин" Оба метода, если поток закончится, кинет вам exception, endOfStreamException.
620.68 628.20 "Игорь Лабутин" Причем в методе readAtleast можно параметром передать флажок, что типа не надо кидать exception, я сам разберусь концом стрима.
628.20 632.96 "Игорь Лабутин" Почему именно это сделано только в readAtleast, я не знаю, но вот сделано ровно так.
632.96 639.24 "Игорь Лабутин" Так что если вы писали такой код, посмотрите на новый превью 5, если вы готовы на него перейти, там будет удобно.
639.24 642.68 "Игорь Лабутин" Хотя, скорее всего, у вас, конечно, написаны, может быть, уже такие хелперы в ваших библиотеках.
642.68 646.16 "Игорь Лабутин" Так, что у нас дальше?
646.16 665.24 "Игорь Лабутин" А, regex, вот, regex тоже получили некоторое количество обновлений, потому что, как мы знаем, regex частично были переписаны на, точнее, был написан source generator для regex, который гораздо более оптимальный код, там можно все соптимизировать, поотлаживать эти regex можно.
665.24 669.40 "Игорь Лабутин" И, в общем, завезли теперь аналайзер розлиновский и фиксер.
669.40 682.48 "Игорь Лабутин" То есть аналайзер теперь будет искать все юзеджи regex, класса regex, либо через конструктор, либо через статические методы, которые он знает, что он сможет конвертировать в regex-генератор, то есть с помощью source-генератора использовать regex.
682.48 687.56 "Игорь Лабутин" Ну, а codefixer, соответственно, делает это, если понимает, что может.
687.56 699.40 "Игорь Лабутин" Там есть некоторый ряд ограничений, типа там, константные compile-time-стройки, вот это все, но, в целом, штука полезная, если вы используете regex активно, гляньте на этот анализатор.
699.40 704.44 "Игорь Лабутин" Завезли нам generic math, очередную итерацию, но про нее мы поговорим отдельно.
704.44 714.96 "Игорь Лабутин" И новость, которая, кусочек новости, которую я не ожидал на самом деле увидеть, нам улучшили performance reflection для вызова методов.
714.96 733.36 "Игорь Лабутин" И если, логика там теперь такая, если вы вызываете метод, ну, хотя бы там два-три раза, то там на лету генерится динамический код вызова этого метода через il_emit и подставляется, собственно, вместо вот этого старого способа.
733.36 739.76 "Игорь Лабутин" В результате получается, что performance какой-то такой улучшения где-то в 3-4 раза.
739.76 750.60 "Игорь Лабутин" То есть, если вы какой-то метод будете дергать часто через reflection, то через несколько вызовов буквально у вас там автоматически в бэкграунде что-то перекомпилится, изгенерится более оптимальный вызов метода, прям на il-е написанный.
750.60 754.64 "Игорь Лабутин" Он потом заджитится, естественно, и у вас будет прям почти очень быстро.
754.64 757.56 "Анатолий Кулаков" Интересно, а почему это они против стольких лет
757.56 763.96 None такое очередное место только сейчас улучшили? Генераторы наступают полным ходом, а они решили reflection улучшать.
763.96 770.08 "Игорь Лабутин" Ну, возможно, они борются за какой-нибудь performance в очередных тестах.
770.08 788.76 "Игорь Лабутин" То есть, там прям вот в ishi, где это было исправлено, там прям объясняется, что вот в таких-таких-таких-таких сценариях оно не будет срабатывать, но мы знаем, что в стартапе такой reflection используется ровно один раз, например, а вот в таких-таких-таких мы точно будем улучшать performance.
788.76 804.04 "Игорь Лабутин" Это здорово, потому что там то ли на стартап они так работают, какой-нибудь, знаешь, там, не знаю, мобильный вот эти все, там, стартап таймы для сервера, типа, пофигу более-менее, а вот приложенки, десктопы, мау и вот это все, там, может быть, это очень важно.
804.04 807.12 "Анатолий Кулаков" Да, время запуска - это хороший кейс, согласен.
807.12 810.56 "Игорь Лабутин" Вот, может быть, поэтому и туда пошли.
810.56 822.08 "Игорь Лабутин" Код ген тоже улучшился, то есть улучшили поддержку ARP64, еще больше оптимизировали цикли, завезли какие-то оптимизации в x86 и x64, и важное изменение.
822.08 832.00 "Игорь Лабутин" Они немножко, они это называют английским словом "modernize JIT", то есть они его модернизировали вот в каком смысле.
832.00 837.88 "Игорь Лабутин" Короче, они говорят, мы что-то заметили, что довольно много народу внезапно хочет коммитить JIT.
837.88 840.36 "Игорь Лабутин" Так, интересный поворот.
840.36 870.12 "Игорь Лабутин" И как бы для того, чтобы сделать это дело проще, они, короче, как я понял, не знаю, читал только вот ищу, в смысле не ищу, а прям статью только, ищу не читал конкретно, но по их словам, они, короче, немножко перетряхнули внутреннюю структуру JIT, повыкидывали всякое старье ненужное, которое не используется, сделали более логичную внутреннюю, так сказать, организацию всего этого дела и, короче, теперь коммитить там одно удовольствие, по их словам, контраблюдить.
870.12 876.40 "Анатолий Кулаков" Но это хорошо, потому что, в принципе, JIT это как раз та часть, которая делает основную магию по перформансу.
876.40 887.36 "Анатолий Кулаков" Все-таки тот чувак, который как раз таки знает, где он запускается, как он запускается, какие там есть инструкции, как их можно прооптимизировать и может сделать очень-очень много всего полезного.
887.36 892.32 "Анатолий Кулаков" Поэтому, чем больше там будет людей и тем более такого разнообразного как сообщество, тем всем будет
892.32 903.48 "Игорь Лабутин" лучше. Да, поэтому теперь JIT, по идее, должно становиться контрабюдить легче и сайд-эффект того, что они там все перетряхнули и выкинули, ну что-то там переструктурировали, да, почистили код, JIT сам по себе стал быстрее.
903.48 906.68 "Анатолий Кулаков" Так всегда бывает, когда старье выбрасывали, да?
906.68 907.68 "Игорь Лабутин" Ну да, наверное.
907.68 911.20 "Игорь Лабутин" Выкини TraceLib и будет быстрее.
911.20 940.60 "Игорь Лабутин" Так, и последнее в разделе основного дотнета, это теперь можно на уровне CSS-проджа в вашей библиотеке, то есть если, например, пишете какую-нибудь библиотеку, то на уровне CSS-проджа вы можете добавить флажок из TrimAppleTrue, и после этого вам на вашу библиотеку розли аналайзеры, аналайзеры начнут ругаться, ну, warning-ами или error-ами для того, чтобы вам показать, какие места вашей библиотеки не дружественны к Trim.
940.60 952.40 "Игорь Лабутин" То есть чтобы потом, когда ваша библиотека попадет в какое-нибудь приложение, для которого будет вызвана опция Trim, чтобы ваша библиотека не сломалась, грубо говоря, а была подготовлена к этому.
952.40 963.20 "Игорь Лабутин" Поэтому если вы пишете библиотеки, которые потом предположительно будут использоваться в TrimAppleTrue, попробуйте поставить из TrimAppleTrue и посмотрите, что получится, какие warning-и будут.
963.20 967.68 "Игорь Лабутин" Это была часть про основной .NET, теперь давайте про ASP.NET.
967.68 977.24 "Игорь Лабутин" В ASP.NET тоже есть, на самом деле, по сути, два изменения, которые они захайлайтили, но одно, на самом деле, довольно интересное.
977.24 983.92 "Игорь Лабутин" Короче, они сказали, что, ну, как бы, не знаю, очень много народу использует JVT.
983.92 986.52 "Игорь Лабутин" Ну, и прочую аутентификацию вокруг этого.
986.52 991.04 "Игорь Лабутин" Точнее, аутентификацию на основе JVT и всех прочих претендентов вокруг.
991.04 997.16 "Игорь Лабутин" И надо сказать, что сетап всего этого добра в ASP.NET Core, он, конечно, очень гибкий, но очень замороченный.
997.16 1000.72 "Игорь Лабутин" Ну, то есть, просто так добавить авторизацию, это, на самом деле, не так просто.
1000.72 1001.72 "Игорь Лабутин" Вот.
1001.72 1005.40 "Игорь Лабутин" Короче, они теперь делают следующее.
1005.40 1011.04 "Игорь Лабутин" У нас теперь у билдера, то есть, когда вы делаете host builder, у него теперь есть пропертя.
1011.04 1013.68 "Игорь Лабутин" Она называется Authentication.
1013.68 1017.04 "Игорь Лабутин" На ней определены некоторое количество extension методов.
1017.04 1022.36 "Игорь Лабутин" То есть, например, можно сказать теперь просто в...
1022.36 1030.84 "Игорь Лабутин" Ну, они приводят, конечно, примеры minimal API, но, грубо говоря, вот в minimal API они пишут там builder.authentication.addJVTBear метод.
1030.84 1041.40 "Игорь Лабутин" Эта штука автоматически регистрирует все нужные вещи в dependency injection контейнере, а кроме того, автоматически добавляет все нужные middleware.
1041.40 1042.40 "Игорь Лабутин" Вот.
1042.40 1059.04 "Игорь Лабутин" И второе, что они сделали, что для того, чтобы, собственно, этот самый authentication знал, а что куда ходить, где у вас вообще сервер, где валидировать токены, какие они допустимы и так далее, все это дело теперь можно задать через App Settings, JSON.
1059.04 1067.44 "Игорь Лабутин" Там, вот как мы, например, задаем конфигурацию логинга, у нас логинг - это top-level элемент в JSON, дальше вы внутри всякие конфигурации логинга пишете.
1067.44 1079.52 "Игорь Лабутин" То теперь есть такой же top-level элемент под названием authentication и вы внутри расписываете там URL валидации такой-то, там ожидаемый, что там у нас там, аудиенс какой-нибудь такой-то, ну в таком духе.
1079.52 1081.52 "Игорь Лабутин" Короче, практически все можно задать декларативно.
1081.52 1111.92 "Игорь Лабутин" А дальше для endpoints, когда вы определяете конкретные endpoints, вы на них вешаете специальным методом, тоже решение, называется requireAuthorization и там вы просто, ну если просто зададите requireAuthorization, понятно будет, просто проверить, что есть токен, но там можно лямбдочкой передать любые сложные опции, какие вы хотите, policy, там вот это все, claim проверить и тогда он будет это дело проверять в рантайме на предмет соответствия запроса требованием авторизации.
1111.92 1122.24 "Игорь Лабутин" Короче, Microsoft, кажется, начала двигаться к тому, что будет сделать попроще весь framework авторизации, потому что он, конечно, ну непростой, надо сказать.
1122.24 1127.60 "Игорь Лабутин" Если разобраться, он понятный и гибкий, но нужно разобраться.
1127.60 1129.80 "Игорь Лабутин" А дальше есть логическое предложение.
1129.80 1135.44 "Игорь Лабутин" Вот допустим мы разобрались, или даже сделали вот это с новыми простыми свойствами, а как это тестить?
1135.44 1150.68 "Игорь Лабутин" То есть для того, чтобы у вас такое приложение протестить, вам нужно либо пользоваться вашим production каким-нибудь authentication сервером, либо поднимать себе локально какой-нибудь там тестовый небольшой сервер, ну условно какой-нибудь там identity server стандартный, либо еще что-нибудь.
1150.68 1151.68 "Игорь Лабутин" Вот.
1151.68 1153.88 "Игорь Лабутин" И это неудобно.
1153.88 1157.16 "Игорь Лабутин" Поэтому Microsoft сделала следующую штуку.
1157.16 1159.88 "Игорь Лабутин" У нас теперь есть новый global tool в .NET.
1159.88 1163.48 "Игорь Лабутин" Называется .NET User Defice JVTS.
1163.48 1166.16 "Игорь Лабутин" Ну типа, User JVTS.
1166.16 1168.16 "Игорь Лабутин" Или как правильно произносить?
1168.16 1169.16 "Игорь Лабутин" Jots.
1169.16 1170.16 "Игорь Лабутин" Может быть помним.
1170.16 1171.16 "Анатолий Кулаков" Это не правильно, а модно.
1171.16 1174.16 "Анатолий Кулаков" Они думают, что по транскрипции звучит именно так.
1174.16 1176.16 "Игорь Лабутин" Дело не в транскрипции.
1176.16 1185.84 "Игорь Лабутин" Дело в том, что там, где их придумали, на сайте автора прям четко написано, ну грубо говоря, на сайте, где стандарт описан, там прям в РФЦшке или где они там описаны, написано.
1185.84 1186.84 "Игорь Лабутин" И это читается так-то.
1186.84 1193.20 "Анатолий Кулаков" Слушайте, а не думают, что определенное сочетание латинских букв может тебе давать именно тот звук, который сам выдумал автор?
1193.20 1196.20 "Анатолий Кулаков" Скорее всего, есть какие-то правила, как они произносятся.
1196.20 1201.20 "Игорь Лабутин" Ну, короче, да, это, конечно, аббревиатура, поэтому вообще должно произноситься JWT, без вариантов.
1201.20 1203.72 "Игорь Лабутин" Но в коротком варианте это JOTS.
1203.72 1204.72 "Игорь Лабутин" Никто так, конечно, не произносит.
1204.72 1205.72 "Игорь Лабутин" Все произносят JVTS.
1205.72 1206.72 "Игорь Лабутин" В русском особенно.
1206.72 1209.84 "Игорь Лабутин" Но не важно, короче, у нас есть такой tool.
1209.84 1212.68 "Игорь Лабутин" Он использует под капотом User Secrets.
1212.68 1217.16 "Игорь Лабутин" Ну, то есть, если вы знаете, что такое User Secrets, то хорошо, если не знаете, то уволите.
1217.16 1225.88 "Игорь Лабутин" Короче, сначала нужно у себя проинциализировать эти User Secrets, то есть вы запускаете .NET, пробел User Secrets, User Defice Secrets, пробел Init.
1225.88 1229.28 "Игорь Лабутин" Это инциализирует User Secrets для вашего CSS-проджа.
1229.28 1239.36 "Игорь Лабутин" По сути, это означает, что просто в environment будут подтягиваться специальные секреты из специального секретного места, который хранится отдельно от вашего репозитория, ну, кода репозитория, и, соответственно, не попадет в git случайно.
1239.36 1241.16 "Игорь Лабутин" Но то они и секреты.
1241.16 1242.72 "Игорь Лабутин" А дальше вы делаете следующее.
1242.72 1246.56 "Игорь Лабутин" Вы говорите .NET, пробел User GVTS, пробел Create.
1246.56 1248.32 "Игорь Лабутин" И эта конструкция делает следующее.
1248.32 1251.32 "Игорь Лабутин" Она создает токен и записывает его в секреты.
1251.32 1253.92 "Игорь Лабутин" Вы потом можете отдельной командой показать его.
1253.92 1263.24 "Игорь Лабутин" А кроме того, она обновляет upsettings.development.json, вот ту самую секцию authentication, про которую я говорил выше, всеми правильными данными.
1263.24 1265.88 "Игорь Лабутин" То есть токен выпущен, естественно, каким-то issuer.
1265.88 1271.60 "Игорь Лабутин" Вот в upsettings.development.json будут ключики от этого issuer, чтобы можно было проверить валидность токена.
1271.60 1282.48 "Игорь Лабутин" И после этого, если вы с этим токеном делаете запрос к вашему локальному запущенному приложению, там в дебаге, не в дебаге, главное, чтобы в development конфигурации, то такой токен будет валидным.
1282.48 1290.40 "Игорь Лабутин" И вы можете, по сути, проверять, что вы хотите с вашей авторизацией без наличия нормального внешнего identity сервера какого-нибудь.
1290.40 1291.40 "Анатолий Кулаков" Хорошая штука.
1291.40 1294.40 "Анатолий Кулаков" Это такой mock для identity сервера получается.
1294.40 1295.40 "Игорь Лабутин" Да, да, да.
1295.64 1306.44 "Игорь Лабутин" То есть понятно, что эта штука работает только в плане, ну, как мне кажется, она будет работать только до тех пор, пока вы не сильно кастомизируете всю эту pipeline авторизации и аутентификации.
1306.44 1312.08 "Игорь Лабутин" То есть пока вот он стандартный и умеет читать все настройки только из upsettings.json, то он все будет работать.
1312.08 1320.56 "Игорь Лабутин" Понятно, что если вы там в вашей кастомной полисе идете, кастомно проверяете токены, то тут как бы ничего не сделаешь.
1320.56 1328.76 "Игорь Лабутин" Но, тем не менее, для простых сценариев, ну или, наверное, опять же, для большинства сценариев, давайте так, это полезное нововведение.
1328.76 1333.20 "Игорь Лабутин" И второе большое нововведение, которое они...
1333.20 1338.76 "Игорь Лабутин" Они это пушат для минимал-APIs, но мне кажется, что, может быть, это будет полезно не только для минимал-APIs.
1338.76 1341.28 "Игорь Лабутин" Короче, штука следующая.
1341.28 1342.28 "Игорь Лабутин" Раньше, если...
1342.28 1347.92 "Игорь Лабутин" Представьте себе, за броуз у вас есть, не знаю, query-параметры, их там 10 штук.
1347.92 1354.88 "Игорь Лабутин" Вы могли сделать эти query-параметры, ну, просто параметрами вашего, допустим, метода контроллера, и они туда пошли.
1354.88 1356.88 "Игорь Лабутин" А теперь можно сделать следующую штуку.
1356.88 1368.88 "Игорь Лабутин" Вы можете объявить класс, у которого будет 10 полей, в метод контроллера, ну или метод минимал-API лямбдочку, передать этот класс как аргумент, но пометить его атрибутиком s-parameters.
1368.88 1375.92 "Игорь Лабутин" И тогда фреймворк автоматически замапит все параметры, которые пришли в query, в поля этого класса.
1375.92 1382.60 "Игорь Лабутин" Таким образом можно попытаться для каких-то query, где у вас там дофигища параметров, свести все, ну, условно говоря, в класс.
1382.60 1389.92 "Игорь Лабутин" То есть такой моделька, которую обычно вы ожидаете, допустим, в body, да, и децерализуете из body.
1389.92 1393.16 "Игорь Лабутин" Но теперь вы можете вот так вот все параметры из query собрать в класс.
1393.16 1394.16 "Игорь Лабутин" Вот.
1394.16 1396.44 "Игорь Лабутин" Это то, что про SPNet.
1396.44 1403.88 "Игорь Лабутин" Больше ничего там особо, ну, там понятно, что много чего пофиксили, наверняка, если гитхаб посмотреть, но прям таких больших новостей вроде нет.
1403.88 1405.44 "Игорь Лабутин" И последнее - это EFcore.
1405.44 1412.52 "Игорь Лабутин" С EFcore там все просто, там есть одна большая фича, которую завезли, это tablePerConcreteType.
1412.52 1414.88 "Игорь Лабутин" Давайте напомним, что это такое.
1414.88 1419.16 "Игорь Лабутин" Представьте, что у вас есть иерархия классов, и вы хотите ее как-то сохранить в базу.
1419.16 1421.64 "Игорь Лабутин" У вас есть три способа это сделать.
1421.64 1427.56 "Игорь Лабутин" Первый способ - это tablePerHierarchy, то есть табличка на иерархию.
1427.56 1432.68 "Игорь Лабутин" Это значит, что все классы всей иерархии будут сохраниться в одной единственной табличке.
1432.68 1440.48 "Игорь Лабутин" То есть, по сути, это будет одна большая табличка, очень широкая, с кучей полей, где объединены все поля всех классов, но заполняются будут только нужные.
1440.48 1449.32 "Игорь Лабутин" Если для одного класса нужны одни пять полей, для другого другие пять полей, то у вас будет 10 колонок, где будут заполнены либо одни, либо другие.
1449.32 1453.80 "Игорь Лабутин" В EFcore 5 версии был добавлен tablePerType.
1453.80 1461.00 "Игорь Лабутин" То есть тут следующая штука, опять же, если у вас иерархия, то на каждый класс иерархии будет своя собственная табличка.
1461.00 1467.60 "Игорь Лабутин" Если у вас есть, допустим, какой-нибудь датерный класс, который наследуется от базового, то в базе данных это будет foreign key на табличку базового класса.
1467.60 1480.68 "Игорь Лабутин" Эта штука хороша, ну в смысле, что она занимает, наверное, наименьшее количество места, потому что нет никакого дублирования, только foreign key, но она очень, может быть, неэффективна для запросов, чуть дальше про это поговорим.
1480.68 1482.96 "Игорь Лабутин" И вот, наконец-таки, нам завезли tablePerConcreteType.
1482.96 1488.12 "Игорь Лабутин" То есть теперь у вас будет табличка только для неабстрактных классов иерархии.
1488.12 1496.04 "Игорь Лабутин" То есть если у вас есть какой-то базовый класс, который абстрактный, то для него таблички не будет, но его поля будут продублированы во всех табличках для конкретных типов.
1496.04 1498.48 "Игорь Лабутин" И опять же, никаких foreign key.
1498.48 1504.60 "Игорь Лабутин" Для того, чтобы эту штуку включить, для какой-то из этих трех вариантов, вы делаете следующее.
1504.60 1519.04 "Игорь Лабутин" Вы для каждого класса вашей иерархии задаете в коде ModelBuilder.Entity от имени вашего класса, .use, и дальше либо tph, либо tpt, либо tpc, mappingStrategy, соответственно, как ее мапить.
1519.04 1522.80 "Игорь Лабутин" Есть проблема с первичными ключами в этом случае.
1522.80 1533.16 "Игорь Лабутин" В случае stable_per_hierarchy, то есть на всю иерархию одна табличка, там вообще проблем нет, там просто используется identity, колоночка, если SQL Server, и все.
1533.16 1544.92 "Игорь Лабутин" В случае stable_per_type тоже все просто, потому что там есть все нужные foreign ключи, то есть у вас любой экземпляр любого типа обязательно будет иметь запись в табличке самого базового класса, и там все просто.
1544.92 1568.44 "Игорь Лабутин" А вот table_per_concrete_type, с ним все сложно, потому что с точки зрения логики entity framework, нельзя чтобы никакие два класса в иерархии имели одинаковые id, несмотря на то что это разные классы, потому что они могут лежать, например, в одной коллекции общего базового класса, а idшники должны быть разные, потому что иначе entity framework внутри трекки там не сможет все как надо.
1568.44 1571.68 "Игорь Лабутин" Но при этом таблички-то разные, и foreign key means между ними нету.
1571.68 1584.04 "Игорь Лабутин" И как добиться уникальных id с точки зрения, короче, уникальных не пересекающихся id для нескольких таблиц, это интересная задачка, которая будет решаться в зависимости от того, какую базу данных вы используете.
1584.04 1597.88 "Игорь Лабутин" В SQL Server это просто, там есть такая поддержка секвенсов, и они просто используют единую секвенс для такой проблемы, для других баз данных там в зависимости от драйвера будет решаться по-разному, как я понимаю.
1597.88 1633.20 "Игорь Лабутин" И тут же команда entity framework говорит следующей рекомендацией, что если у вас есть куча запросов, которые в основном запрашивают только конкретные типы, вот листовые, последние типы, причем по одному, то есть вам нужны либо какой-то один кусочек иерархии, либо всегда другой кусочек иерархии, то это как раз отличный способ для использования вот этой новой фичи, потому что каждый кусочек иерархии будет лежать в своей табличке, и если вам нужна только как раз одна табличка в среднем, то как бы ну вот только ее и трогайте.
1633.20 1664.84 "Игорь Лабутин" Если вы часто запрашиваете смесь разных классов, то есть типа получить вообще все классы во всей иерархии, используйте табличку на всю иерархию, а table per type используйте только если вам сказали использовать table per type, ну типа там не знаю, существующая база данных так работает или там какая-нибудь внешняя база данных, которую вы не контролируете, только тогда советуем использовать, в противном случае даже не думайте, он типа там имеет кучу проблем, ну с performance, потому что слишком много join надо делать и так далее, особенно если иерархия большая.
1664.84 1682.64 "Игорь Лабутин" Это вот основное изменение в entity framework, и там есть еще куча всяких мелких, там улучшили всякие, group by улучшили, теперь можно разметить поведение для for and key constraint, что делать, пределить, и прямо атрибутику можно разметить, не обязательно теперь писать это через fluent API.
1682.64 1690.84 "Игорь Лабутин" Короче, там порядка десятка всяких таких довольно мелких изменений, но table per concrete type это конечно самое большое.
1690.84 1722.28 "Игорь Лабутин" Вот примерно что нам завезли, на самом деле такой довольно таки существенный и интересный релиз, как мне кажется, потому что что в основном в дотнете, не какие-то там код гена only, да, изменения, а прям вот json, system.txt.json с полиморфными типами, system.io.stream с этими прикольными хелперами, rx-генераторы с аналайзерами, короче прям нормально, jwt авторизация в splnate, table per concrete type, wave query, прям такой суровый релиз.
1722.28 1733.64 "Анатолий Кулаков" Да, мне тоже кажется, что вполне видно, люди подходят на полпути к новому релизу, поэтому и фичи начинают появляться масштабные, интересные, и всякие оптимизации, и идеи.
1733.64 1737.68 "Анатолий Кулаков" Кстати, давай пока далеко не ушли, становимся подробнее на generic mafia.
1737.68 1752.48 "Анатолий Кулаков" То, что ты уже упоминал, это тоже одна из тех фич, которая кажется станет той самой, которая будет мейнстримом, наверное, всего этого релиза и на основании которой будут весь релиз продвигать.
1752.48 1757.16 "Анатолий Кулаков" Давайте же посмотрим, что это такое, кто этим будет пользоваться и кому оно вообще надо.
1757.16 1762.24 "Анатолий Кулаков" Итак, при u5 вышла такая фича, которая называется generic math.
1762.24 1771.68 "Анатолий Кулаков" Это, соответственно, некая комбинация между генериками и новой штукой, которая называется, вы не поверите, static virtual в интерфейсах.
1771.68 1780.00 "Анатолий Кулаков" То есть, мало того, что в интерфейсах что-то виртуальное появляется, так и еще это виртуальное статическое.
1780.00 1783.88 "Анатолий Кулаков" Мне почему-то, когда я вспоминаю свои ранние годы разработки,
1783.88 1788.88 None как раз-таки часто очень хотелось статических виртуальных методов поиспользовать.
1788.88 1794.64 "Анатолий Кулаков" Последнее время я себя уже не ловлю на этой мысли, но кажется, что это то, что нужно всем каждый день.
1794.64 1797.52 "Анатолий Кулаков" Поэтому давай подробнее разбираться, что же это такая штука.
1797.52 1807.76 "Анатолий Кулаков" На самом деле, с помощью статических виртуальных методов в интерфейсе и комбинации с генериками очень удобно объявлять различные операции.
1807.76 1824.76 "Анатолий Кулаков" Например, если мы представим типичную операцию сложения, то теперь с текущей фичей мы можем написать генерик метод add, который принимает в качестве параметра t левую и правую часть и может между ними, в соответственном реализации, сделать плюс.
1824.76 1831.20 "Анатолий Кулаков" То есть сложить левую часть и правую часть прямо через плюсик, через вот этот, который пересекаются две палочки.
1831.20 1836.72 "Анатолий Кулаков" Напомню, что раньше мы с генериками такого сделать не могли, потому что оператор плюс не был для них переопределен.
1836.72 1844.76 "Анатолий Кулаков" И вся эта магия стала доступна только потому, что теперь типу t можно указать в волшебный интерфейс iNumber.
1844.76 1849.24 "Анатолий Кулаков" То есть он совсем не волшебный, это нормальный интерфейс, да, это просто мы его раньше не видели.
1849.24 1851.72 "Анатолий Кулаков" То есть это нормальный интерфейс iNumber t, который
1851.72 1858.56 None как раз таки определяет то, что у этих элементов есть оператор плюс и теперь их можно складывать.
1858.56 1865.92 None И давайте посмотрим подробнее, что это вылилось, что этот интерфейс обозначает и как, и где это еще можно использовать.
1865.92 1871.40 "Анатолий Кулаков" Прежде всего, можно разобрать это на основании простого примера суммы.
1871.40 1883.00 "Анатолий Кулаков" Наверное, мы все сталкивались с методом sum, который дергается на iNumber из Namespace линку, который просто-напросто складывает все элементы, которые нам переданы в данном перечислении.
1883.00 1901.76 "Анатолий Кулаков" Соответственно, если мы будем реализовать метод sum с помощью вот этих наших новых generic math, у нас получится немножко не то, что мы видели до этого, а именно код получится более компактный, более прочитабельный и самое
1901.76 1911.80 None главное более дибкий. То есть теперь это можно передавать не какой-то конкретный именно тип, а более большой диапазон.
1911.80 1912.80 None Давайте посмотрим на примере.
1912.80 1925.40 "Анатолий Кулаков" Для того, чтобы прежде всего описать сигнатуру, у нас точно так же будет приниматься некое перечисление из t и возвращаться у нас будет tResult.
1925.40 1928.60 None Почему это не t, мы судим немножко попозже.
1928.60 1930.60 None То есть у нас будет два generic типа.
1930.60 1936.92 "Анатолий Кулаков" t - это спицок values, которые передаются, и tResult - это как раз-таки результат, который получается на выходе.
1936.92 1944.20 None Здесь мы сталкиваемся с несколькими интересными вызовами, которые можно сейчас подробно обсудить.
1944.20 1954.28 "Анатолий Кулаков" Благодаря тому, что у нас на вход получается как раз-таки один параметр, а возвращается другой, мы можем делать своеобразные расширения типов.
1954.28 1959.76 None То есть допустим, мы можем сделать сумму int элементов, а на выходе вернуть long.
1959.76 1972.84 "Анатолий Кулаков" Это дает нам возможность сложить большие числа, и если вдруг в int переполнится, то ничего страшного, на выходе все равно long, он сможет сохранить даже то число, которое не поместилось бы в обычный int.
1972.84 1980.52 "Анатолий Кулаков" Вот именно поэтому принимается на вход два generica, которые соответственно помогают делать такое преобразование.
1980.52 1986.00 "Анатолий Кулаков" Далее, для того, чтобы нам сделать сумму по элементам, нужно выполнить в принципе банальные действия.
1986.00 1993.88 "Анатолий Кулаков" Во-первых, мы заводим аккумулятор, некий сумматор, который хранит в себе значение, инициализируем его какими-нибудь ноликом.
1993.88 2002.96 "Анатолий Кулаков" Далее бежим по всем элементам, которые у нас переданы, складываем их и соответственно сумму возвращаем обратно.
2002.96 2020.12 "Анатолий Кулаков" Слышите, все очень просто, до тех пор, пока мы не понимаем, что элементы, которые у нас находятся в перечислении и результат, это все-таки generic типы, и для них базовые вещи, которые звучат вроде просто, оказываются недоступными в обычном мире, в предыдущих версиях.
2020.12 2030.24 "Анатолий Кулаков" Например, что такое объявить сумматор и проинциализировать его ноликом, а вдруг там не нолик, а вдруг там передано какое-то число, у которого ноль представляется чем-то другим.
2030.24 2033.76 "Анатолий Кулаков" Чтобы решить эту проблему, у t-резолта появилось статическое
2033.76 2042.36 None свойство, которое называется zero, то есть как раз-таки то значение, которое является ноликом у данного generic типа.
2042.36 2055.68 None Напоминаю, что t просто-напросто объявлен, специфизирован просто-напросто интерфейсом myNumber, и вот эта спецификация позволяет у этого типа вызвать статическое свойство.
2055.68 2062.80 "Анатолий Кулаков" И значение этого статического свойства как раз-таки будет зависеть от того, в зависимости от того, как этот тип реализован.
2062.80 2066.92 "Анатолий Кулаков" Вот здесь и проявляется вот эта статическая виртуальность.
2066.92 2076.92 "Анатолий Кулаков" То есть можно обратиться к статическому свойству, но при этом мы не знаем, какая реальная кальзагрузка будет использоваться до тех пор, пока уже не откопилируем этот generic и закроем его.
2076.92 2080.68 "Анатолий Кулаков" Соответственно, вот мы проинциализировали аккумулятор с помощью zero.
2080.68 2082.04 "Анатолий Кулаков" А сейчас перед нами стоит следующая задача.
2082.04 2088.28 "Анатолий Кулаков" Когда мы бежим по всем переменным, нам нужно как-то сложить все значения всех переменных в этот аккумулятор.
2088.28 2089.36 "Анатолий Кулаков" Что такое сложить?
2089.36 2092.88 "Анатолий Кулаков" Раньше тоже было довольно непросто ответить на этот вопрос.
2092.88 2101.96 "Анатолий Кулаков" Теперь же все довольно просто, потому что как только мы объявляем интерфейс myNumber, автоматически у этого значения, у этого типа появляется оператор плюсик.
2101.96 2107.68 "Анатолий Кулаков" Соответственно, мы можем легко брать и пользоваться плюсиком и складывать, соответственно, это все в аккумулятор.
2107.68 2113.60 "Анатолий Кулаков" Другое интересное свойство появилось, немножко новая какая-то концепция для дапмета.
2113.60 2116.96 "Анатолий Кулаков" Это метод, который называется create_checked.
2116.96 2122.64 "Анатолий Кулаков" Это возможность как раз-таки создать некий тип на основании
2122.64 2147.64 None другого типа. То есть, если мы, допустим, будем создавать результат в виде ланга, но при этом нам нужно сложить все числа int, то мы вызываем для t-резолта метод create_checked и передаем ему int и, соответственно, этот метод внутри себя проверяет, что int попадает в диапазон ланга, то есть он может его, грубо говоря, скастить и положить к себе и все хорошо.
2147.64 2152.24 "Анатолий Кулаков" Если же он скастить его не сможет, то бросается overflow_exception и мы все умираем.
2152.24 2154.32 "Анатолий Кулаков" Соответственно, этот метод весь умирает.
2154.32 2160.16 "Анатолий Кулаков" Такой каст, который более, наверное, красивый, грамотный и приличный, который еще можно переопределить.
2160.16 2161.16 "Анатолий Кулаков" Это тоже очень важно.
2161.16 2164.08 "Анатолий Кулаков" Получается у нас для того, чтобы это все дело заработало.
2164.08 2165.36 None В принципе, и все.
2165.36 2168.20 None Поэтому мы наш метод sum написали.
2168.20 2175.68 "Анатолий Кулаков" Написали его довольно универсально, то есть для всех чисел, для всех номеров, которые поддерживает интерфейс inNumber, он будет работать.
2175.68 2179.80 "Анатолий Кулаков" Независимо от того, int-ы они, float-ы, еще какие-нибудь
2179.80 2189.20 None странные циферки, все это будет работать, при этом будет работать на нормальных операторах, то есть на плюсиках, на равно, на разделить, если нам нужно, еще что-то.
2189.20 2192.68 "Анатолий Кулаков" То есть довольно читабельно, красиво и понятно.
2192.68 2212.84 "Анатолий Кулаков" Соответственно, если мы вдруг захотим реализовать какое-нибудь среднее число в свидетеле этого массива, нам всего лишь нужно будет воспользоваться нашим методом sum и, опять же, воспользоваться оператором разделить, который также включен в интерфейс inNumber, и разделить просто на count всех элементов, которые нам передали в параметрах.
2212.84 2222.08 "Анатолий Кулаков" Вот такие вот операторы у нас начинают появляться, как только мы начинаем использовать новую версию, и у дженериков, соответственно, они все будут.
2222.08 2233.40 "Анатолий Кулаков" Как вы уже, наверное, заметили, здесь все зависит от неких интерфейсов, магических интерфейсов, которые в то же самое время наделяют их владельцев некими свойствами.
2233.40 2238.92 None Вот еще один из таких интересных интерфейсов, который стоит упомянуть, это iFloatedPointer iiii754.
2238.92 2246.68 "Анатолий Кулаков" Это как раз-таки интерфейс, описывающий число с плавающей
2246.68 2252.72 None точкой по спецификации iiii754. В общем, тоже полезная штука.
2252.72 2257.36 "Анатолий Кулаков" Это, если вы еще не догадались, это табл и флоаты.
2257.36 2264.08 None Вот они наследуют этот интерфейс, они реализуют этот интерфейс и соответственно соответствуют этой спецификации.
2264.08 2267.32 "Анатолий Кулаков" Еще одним интересным методом, который у нас появляется
2267.32 2293.04 None у многих типов, и метод называется CreateSaturating. Этот метод принимает внутрь себя число, и в отличие от предыдущего метода, который я рассказывал, который CreateChecked, он не бросает overflow exception, как только число выходит из чистовой диапазона, который поддерживает данный тип, а наоборот, он его пытается привести к ближайшему разумному, ближайшему поддерживаемому числу.
2293.04 2312.60 "Анатолий Кулаков" Например, если вы у байта, у типа byte, вызовете метод CreateSaturation и передадите ему -1, то в результате получите 0, потому что байт - он беззнаковое число, у него минимальное значение - это 0, вот он притянул его к минимальному значению.
2312.60 2328.84 "Анатолий Кулаков" Если же наоборот, вы передадите 256 внутрь, то в результате разработа этого метода получится 255, потому что это максимальное число, которое он может себе принять, и соответственно этот метод немножко вашу амбицию умерил и вернул максимальное значение, которое только может.
2328.84 2333.08 "Анатолий Кулаков" Эти методы довольно полезны, особенно когда мы пишем какие-то абстрактные алгоритмы.
2333.08 2340.84 "Анатолий Кулаков" У нас в .NET 7, Preview 5, соответственно, будет 20 типов, которые имплементируют вот эти вот интерфейсики.
2340.84 2345.92 "Анатолий Кулаков" Это абсолютно все типы числовые, которые вы только можете себе представить.
2345.92 2352.88 "Анатолий Кулаков" Это int, long, float, double, single, в общем, все, что вы можете себе представить, все они, естественно, сейчас реализуют
2352.88 2359.40 None в различные вот эти интерфейсики, которые помогают как раз таки их использовать в различных джинельковых алгоритмах.
2359.40 2373.60 "Анатолий Кулаков" Более того, и это самый страшный пункт, команда .NET рассчитывает на то, что сообщество, соответственно, само адаптирует вот эти новые интерфейсы для своих типов и сделает их тоже
2373.60 2376.60 None вот такими универсальными, которые можно будет использовать в каких-то алгоритмах.
2376.60 2380.28 "Анатолий Кулаков" В общем, посмотрим, что из этого получится.
2380.28 2383.12 "Анатолий Кулаков" Обычно сообщество обладает слишком большой фантазией
2383.12 2387.88 None для таких узкоспециализированных и очень важных, и точно понимаемых операций.
2387.88 2396.96 "Анатолий Кулаков" Поэтому обычно в .NET таким не грешили, как переопределение различных операторов, как очень любят, например, делать в плюсах, там полная личность этим творится.
2396.96 2401.00 "Анатолий Кулаков" Но посмотрим, теперь мы, наверное, тоже можем это делать.
2401.00 2403.64 "Анатолий Кулаков" Итак, а еще под шумо к нам выпустили два новых типа.
2403.64 2407.08 None Это тип int 128 и uint 128.
2407.08 2417.04 "Анатолий Кулаков" Как вы уже могли догадаться из названия, это 120-битные инты, соответственно, один со знаком, другой без знака.
2417.04 2422.88 "Анатолий Кулаков" Они тоже реализовывают эти интерфейсики и, соответственно, тоже могут использоваться внутри алгоритмов.
2422.88 2426.80 "Анатолий Кулаков" У них есть одна интересная особенность, они еще не поддерживаются в compile-time.
2426.80 2429.04 "Анатолий Кулаков" Их можно создать только в run-time.
2429.04 2435.64 "Анатолий Кулаков" Не знаю, это будет фича или это временное решение, которое, наверное, закроют в будущих версиях.
2435.64 2437.80 "Анатолий Кулаков" Скорее всего, закроют.
2437.80 2441.92 None Из сокращенных типов, такие как int, long, мы для них тоже еще не придумали.
2441.92 2449.28 None Но если long у нас в два раза меньше, то интересно, что будет, как называется вот эта штука, наверное, long-long или еще что-то пострашнее.
2449.28 2457.84 "Анатолий Кулаков" Как я уже говорил, есть много волшебных интерфейсов, которые позволяют методам обладать, даже типам обладать
2457.84 2465.76 None теперь некими методами. Вот, хотелось бы отметить несколько методов, чтобы вы более четко могли понимать, что же вас ждет.
2465.76 2469.08 "Анатолий Кулаков" Например, у нас есть теперь интерфейс, который называется iBinaryInteger.
2469.08 2476.00 "Анатолий Кулаков" И у него есть такие методы, как leadingZeroCount, popCount, rotateLeft.
2476.00 2483.52 "Анатолий Кулаков" Это, соответственно, типы, которые могут обладать какой-то бинарной логикой и могут возвращать вам,
2483.52 2491.24 None например, количество нулей, которые есть в их бинарном представлении, количество единичек, которые выставлены в их бинарном представлении.
2491.24 2498.16 None Соответственно, сдвинуть влево, сдвинуть вправо и вот такие базовые операции с бинарным представлением, вот это все теперь можно поддерживать из коробки.
2498.16 2500.76 "Анатолий Кулаков" Дальше у нас есть iFloatingPoint.
2500.76 2510.36 None Соответственно, у них вы можете вызывать round, truncate, floor, то есть все то, что связано с округлением, допустим, с нечетким сравнением и так далее.
2510.36 2518.40 "Анатолий Кулаков" У классических numbers можно отметить clamp, max, min, sin, которые как раз возвращают там знак больше, меньше или ноль.
2518.40 2521.04 "Анатолий Кулаков" Вот, еще есть интересный интерфейс iNumberBase.
2521.04 2530.60 "Анатолий Кулаков" Это базовый интерфейс для многих числовых типов, который тоже дает общие всякие свойства для многих
2530.60 2541.20 None типов. Например, zero у него есть, возвращает вам нолик в конкретном представлении и абстрактное, некое как это начало в абстрактном представлении.
2541.20 2548.44 "Анатолий Кулаков" У него есть one, isNone, isNegative и вот такие базовые вещи, которые тоже, наверное, хочется бы видеть у каждого числа.
2548.44 2552.36 "Анатолий Кулаков" И интересные интерфейсы iAssignedNumber и iUnsignedNumber.
2552.36 2557.80 "Анатолий Кулаков" То есть это, соответственно, можно теперь определить знаковое это число или незнаковое.
2557.80 2560.76 "Анатолий Кулаков" Вот тоже для алгоритмов это нужно.
2560.76 2564.84 "Анатолий Кулаков" Также интересные интерфейсы это parsing and formatting.
2564.84 2573.00 None Интерфейсы, которые как раз таки позволяют в основном работать с пользовательским водом или с сервизованным водом или со сторожем, откуда-то данные загружать.
2573.00 2575.72 "Анатолий Кулаков" Один из них, соответственно, парсит, а другой форматит.
2575.72 2577.68 "Анатолий Кулаков" В общем, такие тоже интерфейсы теперь есть.
2577.68 2580.68 "Анатолий Кулаков" Formatable, они, в принципе, и раньше были.
2580.68 2594.72 "Анатолий Кулаков" Можно было их заменить или можно было как-то симулировать, но теперь они четко входят в эту иерархию математических интерфейсов и должны поддерживаться очень понятными какими-то
2594.72 2602.64 None числами. То есть Formatable, он умеет метод toString, который принимает в качестве параметра формат и формат-провайдер.
2602.64 2609.56 "Анатолий Кулаков" А parsable имеет методы parse и, по-моему, try-parse и, соответственно, тоже принимает форматable.
2609.56 2613.16 "Анатолий Кулаков" То есть он парсит в рамках локали или какого-то другого
2613.16 2620.24 None формата-провайдера, который у вас есть. Ну и, соответственно, ispanformatable и ispanparsable, даже мы без панов.
2620.24 2628.00 "Анатолий Кулаков" Вот, и последний блок интерфейсов, красивых, интересных интерфейсов это те интерфейсы, которые позволяют вам как раз таки и реализовать операторы.
2628.00 2635.52 "Анатолий Кулаков" Например, есть интерфейс additional operators, который как раз таки декларирует, что число поддерживает плюсик.
2635.52 2643.84 "Анатолий Кулаков" Если у вас какой-то тип пронаследован или специфицирован этим интерфейсом, то вы, соответственно, можете складывать его через плюсик и даже получать какой-то результат после этого.
2643.84 2655.12 "Анатолий Кулаков" Также у нас есть bitwise operators, ibitwise operators, который умеет работать с бинарными операциями, такими как binarnae_i, ilyc, xor, not и так далее.
2655.12 2661.48 "Анатолий Кулаков" Есть compression operators, которые меньше-больше, больше или равно поддерживают.
2661.48 2666.16 "Анатолий Кулаков" Decrement operators, соответственно, division, который позволяет вам делить.
2666.16 2667.16 "Анатолий Кулаков" Equality operator.
2667.16 2669.64 "Анатолий Кулаков" И один из интересных - это shift operator.
2669.64 2676.88 None То есть вы можете перекрыть теперь стрелочки, две стрелочки влево, две стрелочки вправо или даже три стрелочки вправо.
2676.88 2678.36 "Анатолий Кулаков" Чем интересен shift operator?
2678.36 2683.32 None Тем, что как раз его в плюсах перекрыли для того, чтобы делать консоль в redline.
2683.32 2691.56 "Анатолий Кулаков" Вот мне интересно, долго ли мы будем жить до того, когда нам тоже сделают вывод в консоль с помощью перекрытия вот этого shift operator?
2691.56 2698.80 "Игорь Лабутин" Ну, нет, я надеюсь, что мы не станем сюда плюсом, и все-таки shift operator будет только для шифтов.
2698.80 2703.48 "Игорь Лабутин" Хотя, кстати, непонятно, почему они это не сделали в binary.
2703.48 2710.24 "Игорь Лабутин" Ну, то есть типа, для кого мне нужно делать shift operator, если я не бинарный?
2710.24 2714.76 "Анатолий Кулаков" Интересный вопрос, но может быть как раз-таки для консоли аупыта.
2714.76 2715.76 "Игорь Лабутин" Надеюсь, что нет.
2715.76 2719.00 "Игорь Лабутин" Ну, главное, чтобы они это в стандартную библиотеку
2719.00 2723.12 None в биссерию куда-нибудь не толкали, а там сбоку пусть творят что хотят.
2723.12 2729.44 "Игорь Лабутин" Ну, ты же сказал, что там много-много типов уже, сколько, две сотни поддерживают, да, или около того?
2729.44 2732.12 "Анатолий Кулаков" Ну, 20 стандартных, это вот которые.
2732.12 2733.12 "Анатолий Кулаков" А, 20 стандартных.
2733.12 2734.12 "Анатолий Кулаков" Два базовые номера, да.
2734.12 2744.16 "Игорь Лабутин" Ну, я так понимаю, что там может быть очень много, базовых типов довольно много, то есть там может быть много чего там еще успеют поддержать, да, и задолкают эти операторы куда-нибудь.
2744.16 2745.16 "Игорь Лабутин" Ладно, посмотрим.
2745.16 2747.88 "Игорь Лабутин" Ну, фича действительно мощная, как бы глянем.
2747.88 2751.40 "Игорь Лабутин" Ну, и насколько я помню, ее очень давно просили,
2751.40 2756.76 None и в принципе уже давно начали к ней готовиться, собирать пропозлы, и люди ее действительно хотели.
2756.76 2763.40 "Игорь Лабутин" Не, ну она же вышла в шестом, даже в шестом ЛТС, пусть так превью, пусть ее надо явно включать, но тем не менее она вышла.
2763.40 2769.88 None Да, да, именно так, мы в принципе ее уже даже обсуждали, поэтому если кому-то интересно, можете поискать в прошлой выпуске.
2769.88 2770.88 "Игорь Лабутин" Да.
2770.88 2779.84 "Игорь Лабутин" Давай пойдем дальше, давай пойдем дальше, и посмотрим на UI-чик, Maui.
2779.84 2790.44 "Игорь Лабутин" Там выпустили статью, мы не будем в нее погружаться очень детально, но если вам нравятся статьи в стиле Стивена Тауба про performance improvements, то эта статья точно для вас.
2790.44 2792.44 "Игорь Лабутин" Значит, в чем была проблема?
2792.44 2805.48 "Игорь Лабутин" Проблема была, ну не проблема, а вообще с Maui performance, он немножко не такой как с вообще дотнепом в целом, и аспирнеткором в частности, потому что тут надо оптимизировать несколько вещей.
2805.48 2822.56 "Игорь Лабутин" Для Maui сделали несколько экспериментов, посмотрели на то, как она себя сейчас ведет, и выяснили, что для iOS, ну рассматриваем мобильные платформы в основном, для iOS в основном нужно уменьшать размер, а для Android нужно уменьшать startup time.
2822.56 2826.84 "Игорь Лабутин" Там размер был как-то поменьше, но зато startup time какой-то был не очень приличный.
2826.84 2837.20 "Игорь Лабутин" Вот, то есть, например, если говорить про размер, для пустого приложения iOS на Maui пустое приложение занимает 18 мегабайт, это как-то многовато для пустого приложения.
2837.20 2844.64 "Игорь Лабутин" Ну и опять же, эти 18 мегабайт, это значит, что все эти дллки нужно загрузить в память, все дела, это косвенно влияет в том числе на стартап.
2844.64 2861.40 "Игорь Лабутин" Поэтому была проведена большая работа по улучшению перформанса, и в этой статье, вот которую мы сейчас обсуждаем, приведены прям детальные примеры, бенчмарки, то, как они что делали, что конкретно, где какой, что выпиливали.
2861.40 2876.68 "Игорь Лабутин" Поэтому, если вдруг вам это все интересно, читайте детальную статью, мы, к сожалению, наверное, в формате такого подкаста не сможем прям все описать, но интересный кусочек там первый, в том числе, это тулинг.
2876.68 2890.04 "Игорь Лабутин" Потому что одно дело, как бы, спин-адкор на приложение, ну вы там, не знаю, дамб собрали, какие-нибудь перформанс-каунтиры, профайл запустили, или даже в конце концов запустили на своей локальной машинке, и студии подключились к дебаггерам посмотреть.
2890.04 2896.24 "Игорь Лабутин" А что ж там, например, жрет время на старте, то с мобильным приложением все сложнее, оно же на телефоне запускается.
2896.24 2899.16 "Игорь Лабутин" И тут надо профайлить прямо на самом телефоне.
2899.16 2907.40 "Игорь Лабутин" И вот тут как раз-таки нужно довольно специальное средство, это специальный .NET-тул, называется .NET Defice DS Router.
2907.40 2913.56 "Игорь Лабутин" Он позволяет делать следующее, он позволяет подключить обычный стандартный .NET Trace к мобильному приложению.
2913.56 2927.92 "Игорь Лабутин" То есть он имеет, видимо, некоторый агентик на телефончике и подключается к .NET Trace с одной стороны, а с другой стороны к приложению, и все эти метрики скачивается в .NET приложение в реал-тайме с другой стороны.
2927.92 2936.56 "Игорь Лабутин" В результате работы этого тула получается файл с разрешением Speedscope, который можно закинуть в приложение под названием speedscope.app.
2936.56 2939.92 "Игорь Лабутин" Это такое веб-приложение, которое позволяет анализировать.
2939.92 2946.96 "Игорь Лабутин" По сути это получается FlameGraph, если так уж он стройный FlameGraph, это коллекция просто сэмплов по стэкам.
2946.96 2950.76 "Игорь Лабутин" И дальше можно посмотреть, а где же там что тратится время на что.
2950.76 2961.44 "Игорь Лабутин" И вот по результатам этих измерений были проведены некоторые изменения в коде, где они улучшали последовательно много разных штук.
2961.44 2965.96 "Игорь Лабутин" Там примерно, ну штук по-моему 15 минимум разных оптимизаций.
2965.96 2970.00 "Игорь Лабутин" Некоторые из них помогали выиграть 20 мс, некоторые 30 мс.
2970.00 2975.16 "Игорь Лабутин" То есть там везде по чуть-чуть, но в результате там улучшения получились довольно приличные.
2975.16 2980.28 "Игорь Лабутин" Что-то типа с 900 до 600 мс что-ли снизили скорость или как-то так.
2980.28 2983.44 "Игорь Лабутин" Размер тоже довольно сильно улучшился.
2983.44 2987.36 "Игорь Лабутин" Значит не вдаваясь в детали, что они трогали.
2987.36 2995.80 "Игорь Лабутин" То есть если вам что-то вдруг интересно, посмотрите как они это делали, посмотрите конкретные command-lines, конкретные метрики и так далее.
2995.80 2999.36 "Игорь Лабутин" Во-первых они оптимизировали все вокруг рефлекшена.
2999.36 3003.16 "Игорь Лабутин" То есть если где-то был рефлекшен, то вот как раз таки тут было важно.
3003.16 3018.08 "Игорь Лабутин" Даже если мы на старте, если в Span and Core например на старте мы трогаем один раз что-то через рефлекшен, это абсолютно не страшно, потому что стартап в Span and Core делается, ну условно один раз, да, дальше ваше веб-приложение долго-долго счастливо работает, то в мобильном приложении это не так.
3018.08 3026.20 "Игорь Лабутин" Возможно тот самый рефлекшен на стартапе, он сильно повлияет на время старта приложения, а дальше пользователь быстренько закроет ваше приложение.
3026.20 3028.64 "Игорь Лабутин" Поэтому надо все это оптимизировать.
3028.64 3040.96 "Игорь Лабутин" Во-вторых, если мы живем на Android, то там приходится интервопиться с Java и там тоже довольно много всяких оптимизаций было вокруг спанов, использований и так далее, чтобы прям вызовы в Java были очень быстрые и хорошие.
3040.96 3055.12 "Игорь Лабутин" Поубирали всякие лишние библиотеки неиспользуемые, ну например там использовали какую-то библиотечку, которая в своих зависимостях тянула Newton Soft JSON, хотя сам Newton Soft JSON не нужен вот той функциональности, которая используется.
3055.12 3059.04 "Игорь Лабутин" Можно выпилить из готовой сборки и уменьшить размер.
3059.04 3061.44 "Игорь Лабутин" Также можно выпилить кусочки дотнета.
3061.44 3085.28 "Игорь Лабутин" То есть например если вы не используете ну скажем какую-нибудь там, ну ладно, локализацию в среднем мобильное приложение используют, в отличие от вебных, но насколько я помню, например было такое, что стандартный ISP надкорный идеальный контейнер он довольно тяжелый и для мобильного приложения обычно такой прям развесистой функциональности не нужно.
3085.28 3095.68 "Игорь Лабутин" Удобно было бы иметь DI-контейнер, но он не нужен прям такой мощный, поэтому там написано вместо стандартного такого микрософтовского написан другой микрософтовский полегче, а тот выкинут.
3095.68 3102.80 "Игорь Лабутин" Точно так же выкинут Generic Host, который обычно хостит, ну предполагалось, что он будет хостить вообще все приложения, но выяснилось, что абстракт.
3102.80 3113.28 "Игорь Лабутин" Он слишком абстрактен и это имеет свою цену с точки зрения стоимости запуска, там как раз таки довольно много рефлекшена, поэтому вместо Generic Host используют теперь другой.
3113.28 3127.00 "Игорь Лабутин" Кроме этого они активно заиспользовали Dreaming, ведь там можно почитать их опыт на тему того, как это все работает, и довольно много, особенно для iOS используется ходов тайм компиляция, и ее тоже можно профайлить.
3127.00 3134.72 "Игорь Лабутин" Ну в смысле можно профайлить, что получается в результате, можно понимать, как улучшить этот AOT-профиль и как ускорить еще больше приложения.
3134.72 3148.40 "Игорь Лабутин" Так что если вы вдруг пишете что-то на дотнете для мобильничков или вообще в таком домене, где вам важно, насколько быстро стартует приложение или его размер, очень рекомендую почитать статью, там довольно много разных техник и конкретных прям примеров.
3148.40 3152.84 "Игорь Лабутин" Вот это мы выпилили, это выпилили, вот это медленно было, вот на это мы заменили старым быстро.
3152.84 3160.76 "Анатолий Кулаков" И вообще хорошо, что загоняются производительности UI, потому что отзывчивый, красивый, просплатформенный UI - это довольно важно.
3160.76 3163.80 "Анатолий Кулаков" И наверное перформанс важен везде, ну и в частности
3163.80 3171.52 None это наверное вот когда пользователь с ним работает, когда он нужен, именно очень отзывчивый, важнее важных техник.
3171.52 3173.44 "Игорь Лабутин" Да ну че, поехали дальше.
3173.44 3182.20 None Давай, если ты упомянул специфику соответственно автора Тауба, как он пишет статьи, у меня для тебя есть еще один специфичный автор - Ричард Лендер.
3182.20 3191.00 "Анатолий Кулаков" Он тоже пишет довольно специфичные статьи, в частности как можно описать сообщение, которое говорит "мы улучшили диалог показа сообщений".
3191.00 3201.64 "Анатолий Кулаков" В общем это все было описано огромной статьей с кучей абзацев, выводов каких-то подводок, еще чего-то, вот просто ради того, чтобы посмотреть как наливать воду, вам нужно заглянуть в эту статью.
3201.64 3209.20 "Анатолий Кулаков" А кратко об ее сути вы узнаете довольно быстро, понятно, потому что я уже прострадал за вас и сделал эту краткую выжимку.
3209.20 3216.68 "Анатолий Кулаков" Если в общем, то суть заключается в том, что в Дотнете улучшили сообщения об ошибке в тот момент, когда сам Дотнет не найден.
3216.68 3225.72 "Анатолий Кулаков" Сам ронтайм, СДК или вообще библиотеки, поддерживающие ваше приложение, на основании которых оно может запускаться, оно в системе почему-то не найдено.
3225.72 3241.76 "Анатолий Кулаков" В общем, раньше это сообщение в некоторых случаях могло выглядело так, что просто писалось, произошла критическая ошибка, потому что необходимая библиотека хост fxr.dll не может быть найдена.
3241.76 3247.32 "Анатолий Кулаков" Безусловно, такое сообщение как бы вгонит в ступор кого-угодно, наверное, даже многих разработчиков.
3247.32 3257.52 "Анатолий Кулаков" А если мы говорим о неподготовленном пользователе, то у него, конечно, глаза вылезут на лоб и он не сможет пользоваться вашим приложением, более того, никогда в жизни больше не захочет пользоваться вашим приложением.
3257.52 3276.04 "Анатолий Кулаков" Поэтому данная часть очень важна, чтобы любой пользователь, который, например, скачал ваше приложение, тыкнул ее на рабочем столе мышкой, он должен увидеть понятное сообщение об ошибке, которое позволит ему каким-то образом все-таки запуститься и получить положительный опыт от использования вашего приложения.
3276.04 3278.48 "Анатолий Кулаков" Вот почему вот это диалоговое окно очень важно.
3278.48 3283.48 "Анатолий Кулаков" И нужно сказать, что почему возникает такая проблема.
3283.48 3303.76 "Анатолий Кулаков" Потому что .NET на самом деле запускается в большинстве слоев, если мы говорим про стандартный способ деплоя, он запускается с помощью нативного хоста, с помощью обычной нативной длл, которая подгружает .NET Runtime, загружает длл и каким-то образом дает старт вашему приложению, потому что без .NET Runtime ничего у вас, конечно же, работать не будет.
3303.76 3313.56 "Анатолий Кулаков" Соответственно, у нас уже было некое диалоговое окошко, и в этом диалоговом окошке даже была кнопочка скачать фреймворк, если у вас его нет.
3313.56 3322.96 "Анатолий Кулаков" И разработчики посмотрели, что на эту кнопочку кликают довольно часто, то есть и действительность скачивает довольно часто, поэтому постребованность среди пользователей есть.
3322.96 3332.44 "Анатолий Кулаков" Вот почему они решили наконец-то сделать какие-то улучшения в этом направлении и помочь каким-то образом еще больше пользователям, которые этим пользуются.
3332.44 3338.84 "Анатолий Кулаков" Эти все улучшения также были бы портированы в .NET 6.0.7, поэтому там они тоже есть.
3338.84 3342.56 None Давайте, соответственно, поймем, что все-таки изменилось.
3342.56 3349.48 "Анатолий Кулаков" Прежде всего, появилось намного больше информации о том, что было не найдено, почему не найдено и где вообще искалось.
3349.48 3372.36 None Например, если вообще никакого .NET в системе нет, то данное диалоговое окно выведет подробную информацию о том, какое приложение пыталось запуститься, какая у него архитектура, какую версию фреймворка оно ожидало найти и, соответственно, предложит ссылку на документацию, где можно подробнее почитать о том, что такое фреймворк, почему его там надо запускать и каким образом решать проблему, если у вас запустить не получилось.
3372.36 3380.96 None И, соответственно, будет кнопочка "Скачать прямо фреймворк той версии, которая вам нужна", под операционную систему, которая вам нужна, и установить его локально.
3380.96 3385.44 "Анатолий Кулаков" Кажется, довольно понятно и, соответственно, юзерфренли.
3385.44 3392.68 "Анатолий Кулаков" Еще одна интересная "use case" - это когда все-таки фреймворк есть на машине, но он не той версии.
3392.68 3402.48 "Анатолий Кулаков" Вот в этом случае у нас добавляется все-таки, какая версия была необходима, где мы искали фреймворки и, соответственно, какие фреймворки мы нашли там, где мы искали.
3402.48 3412.64 "Анатолий Кулаков" Это тоже интересно, потому что для пользователя очень часто фраза "Dotnet framework" уже установлен, подразумевается в том, что он как бы установлен и поддерживается любой версией.
3412.64 3417.48 "Анатолий Кулаков" На самом деле это не так, иногда нужна специфическая версия, иногда не меньше, иногда не больше.
3417.48 3426.92 "Анатолий Кулаков" В общем, из этого списка будет понятно, что у него стоит и какие версии стоят, и почему именно приложение вот это, ему такая старая версия, допустим, не подходит.
3426.92 3431.80 "Анатолий Кулаков" Другой особенностью, интересной для пользователя, являются различные архитектуры.
3431.80 3447.56 "Анатолий Кулаков" Если там, допустим, x64 и x86 каким-то образом можно понять, что это разные цифры, то пользователи, которые, например, запускают ARM64 приложение и при этом у них установлен Dotnet x64, они небольшой разницы в этом не видят.
3447.56 3456.84 "Анатолий Кулаков" Поэтому это тоже очень важный момент, который подсвечивает данные документации, данный диалог в окно, то есть на какой операционной системе, под какую архитектуру это все дело запускается.
3456.84 3459.16 "Анатолий Кулаков" Вот, в принципе, и все.
3459.16 3463.24 "Анатолий Кулаков" А, ну еще, соответственно, добавили какую-то расширенную информацию в Dotnet Info.
3463.24 3481.24 "Анатолий Кулаков" Напоминаю, что это консольная утилита, которая выводит вам базовую информацию об окружении, о тех же самых установленных фармворках, о различных версиях и, впрочем, вот о таком важном, что можно вывести такой диагностической команды для того, чтобы с первого взгляда попытаться понять, где мы запускаемся и чего нам может не хватать.
3481.24 3484.32 "Анатолий Кулаков" Там тоже все улучшили, расширили, углубили.
3484.32 3488.20 "Анатолий Кулаков" Теперь там намного больше полезной информации и намного лучше диагностику можно по ней проводить.
3488.20 3500.92 "Игорь Лабутин" Ну, наверное, будет действительно удобно для всяких десктопных приложений, когда ты кастомерам отдаешь приложение, а оно не хочет запускаться, потому что кастомер удалил Dotnet Framework, потому что посчитал, что он не нужен.
3500.92 3507.68 "Анатолий Кулаков" Ну, или ты на сервере, на каком запускаешь, я не знаю, на Azure, на AWS, вдруг у тебя слишком много версий, о которых они не понимают.
3507.68 3509.68 "Анатолий Кулаков" Ну, я не… Лишь надо как-то это слайдить, отловить.
3509.68 3515.52 "Игорь Лабутин" Я не думаю, что мне будет показываться окошко в терминале Linux, например, если я это на Linux в докере где-нибудь запускаю.
3515.52 3517.52 "Игорь Лабутин" Но если в докере, опять же, у меня runtime с собой, поэтому…
3517.52 3521.16 "Анатолий Кулаков" Нет, в докере это уже неактуально, в докере это слишком читерство.
3521.16 3532.64 None Ну, окошка нет, но вот Dotnet в консольную плузу, которая Dotnet.Net, которая Dotnet.Ramp в принципе делает, вот она тоже тебе выведет вот эту подробную информацию, если вдруг почему-то не сможет загрузить правильно runtime.
3532.64 3535.36 "Игорь Лабутин" Ну, это да, кстати, Dotnet.Info действительно будет полезно.
3535.36 3539.12 "Игорь Лабутин" Окей, давай посмотрим, что дальше.
3539.12 3540.12 "Игорь Лабутин" Дальше у нас Visual Studio.
3540.12 3542.76 "Игорь Лабутин" С Visual Studio у нас две новости.
3542.76 3546.76 "Игорь Лабутин" Первая это про Visual Studio for Mac 17.3 Preview 2.
3546.76 3555.80 "Игорь Лабутин" Мы буквально недавно говорили, что вышла таки Visual Studio for Mac с полным macOS, с нативным интерфейсом и все дела.
3555.80 3560.68 "Игорь Лабутин" И Microsoft начала собирать уже фидбэк на нее и начала фиксить баги.
3560.68 3563.92 "Игорь Лабутин" Багов довольно много накопилось.
3563.92 3572.28 "Игорь Лабутин" И там были забавные баги типа UI, то есть ты запускаешь отладку и у тебя исчезает все в UI, кроме того toolbar.
3572.28 3574.52 "Игорь Лабутин" По каким-то неведомым причинам пофиксили.
3574.52 3582.48 "Игорь Лабутин" Были проблемы с Git, с поддержкой Git, что там опять же бранчи не переключаются, файлики не коммитятся, вот это все тоже пофиксили.
3582.48 3585.92 "Игорь Лабутин" Были некоторые проблемы с MAUI.
3585.92 3590.24 "Игорь Лабутин" Напоминаю, что оно как бы официально зарелизили, то есть как бы должно работать.
3590.24 3595.36 "Игорь Лабутин" На Mac для этого нужно было ставить Preview 1, 17.3 Preview 1.
3595.36 3599.00 "Игорь Лабутин" Но вот нашли какие-то проблемы, в Preview 2 что-то пофиксили.
3599.00 3603.00 "Игорь Лабутин" Добавили некоторое количество новых шаблонов-файлов для MAUI.
3603.00 3614.28 "Игорь Лабутин" Ну и пофиксили, если вы разрабатываете для iOS, а если вы на Mac, то скорее всего вы для него разрабатываете, в том числе, то там теперь чуть упростили авторизацию к Apple.
3614.28 3619.52 "Игорь Лабутин" Там теперь есть прям отдельный пункт меню, типа задать мои Apple Developer Credentials.
3619.52 3621.16 "Игорь Лабутин" Короче, должно стать вам проще.
3621.16 3624.40 "Игорь Лабутин" Вот, это про Mac.
3624.40 3627.12 "Игорь Лабутин" И кроме этого у нас есть и Windows новости.
3627.12 3631.72 "Игорь Лабутин" С Windows новостями следующее.
3631.72 3645.76 "Игорь Лабутин" Мы 2 выпуска назад говорили, что Microsoft обещает ARM-овский тулинг качать больше.
3645.76 3651.64 "Игорь Лабутин" И вот наконец-таки у нас есть первая, так сказать, ласточка с точки зрения тулинга.
3651.64 3654.76 "Игорь Лабутин" Это ARM64 версия Visual Studio.
3654.76 3661.76 "Игорь Лабутин" Она имеет номер 17.3 Preview 2, она нативное ARM64 приложение для Windows 11.
3661.76 3668.48 "Игорь Лабутин" Пока там только включены ворклоуды, это Desktop Development с C++, и только для MS Build проектов.
3668.48 3675.04 "Игорь Лабутин" А также .NET Desktop с Informe WPF, причем как на .NET Framework, так и на новом .NET.
3675.04 3679.08 "Игорь Лабутин" Ну и, понятное дело, Web Development, который всегда везде, потому что это просто консольки.
3679.08 3687.72 "Игорь Лабутин" При этом это пока все еще Preview, и Microsoft обещает, что это будет General Availability где-то к концу года.
3687.72 3691.40 "Игорь Лабутин" Все это будет потихонечку тестироваться, отлаживаться и исправляться баги.
3691.40 3696.04 "Игорь Лабутин" Так что полноценную версию студии для ARM64 ждем к концу года.
3696.04 3705.48 "Игорь Лабутин" В .NET, который новый .NET, который шестой и новее, у нас есть нативная поддержка ARM64, поэтому там проблем нет.
3705.48 3712.68 "Игорь Лабутин" А вот с .NET Framework вы можете удивиться, как мы его поддерживаем, потому что он же давным-давно выпустился и там поддержки ARM нет.
3712.68 3725.72 "Игорь Лабутин" Ее действительно там не было, и именно поэтому будет выпущен Hotfix или Patch версия .NET Framework с версией 481, которая будет включать поддержку ARM64.
3725.72 3729.72 "Игорь Лабутин" Она будет доступна в следующем, соответственно, мажорном апдейте Windows 11.
3729.72 3742.88 "Игорь Лабутин" Ну и потом, попозже немножко, она будет выпущена в том числе для предыдущих операционок, то есть я подозреваю, что на десятке, если десятка может работать на ARM64, то .NET Framework будет обновлен так, чтобы он тоже работал на ARM64.
3742.88 3747.56 "Игорь Лабутин" Это все пока очень превью-версия.
3747.56 3752.96 "Игорь Лабутин" Там будут не работать, понятное дело, все экстенджины, которые там нативно завязаны на нативный код.
3752.96 3756.48 "Игорь Лабутин" Те, которые работают на .NET, им понятно, все равно.
3756.48 3760.20 "Игорь Лабутин" Они как работали на .NET, так и продолжат работать на .NET.
3760.20 3765.84 "Игорь Лабутин" Но потихонечку набор экстенджинов будет обновляться, видимо, и посмотрим, куда это приведет.
3765.84 3771.52 "Игорь Лабутин" Но тем не менее, вот у нас есть теперь ARM64 студия, осталось найти только какой-нибудь компьютер, на котором его можно запустить.
3771.52 3773.52 "Анатолий Кулаков" Ну, Raspberry Pi же, ну.
3773.52 3776.92 "Игорь Лабутин" Ну да, но там Windows 11 же.
3776.92 3782.92 "Анатолий Кулаков" Да ладно, Windows 11 во всех маркетинговых роликах запускали на Raspberry Pi, это поздная работа.
3782.92 3786.16 "Игорь Лабутин" Ну прекрасно, значит, у нас есть новая Development платформа, супер.
3786.16 3790.76 "Анатолий Кулаков" Да, можно теперь всем разработчикам раздавать 100-долларовые компьютеры и заставлять их работать.
3790.76 3794.12 "Анатолий Кулаков" А то кричат, что там все у них тормозит, тормозит.
3794.12 3801.08 "Анатолий Кулаков" Слушай, я так и не понял, все-таки она на базе Visual Studio большой или все-таки Visual Studio for Mac?
3801.08 3803.12 "Игорь Лабутин" Она на базе большой Visual Studio.
3803.12 3804.68 "Анатолий Кулаков" Неплохо, неплохо.
3804.68 3824.92 "Игорь Лабутин" Ну, судя по тому, что было сказано, что все существующие экстенджины, если они написаны на .NET, то они продолжат работать как работали, то это означает, что это скорее Windows студия, потому что, насколько я понимаю, маковская студия не поддерживает те же экстенджины, очевидно, потому что они основаны на .NET, просто всех этих опишут для плагинов.
3824.92 3841.44 "Анатолий Кулаков" Да, безусловно, там платформа от MonoDevelopment, абсолютно все другое, поэтому они очень легко различаются, но если их смогли запустить под ARM, то может быть там небольшой шаг все-таки запустить большую нормальную студию под Linux тоже удастся или под Mac?
3841.44 3843.28 "Игорь Лабутин" Я боюсь, там проблемы с UI все-таки.
3843.28 3847.28 "Анатолий Кулаков" Да, наверное, слишком много WinAPI функций вот этих, которые
3847.28 3849.28 "Игорь Лабутин" с игрушками работают. Да, да, да, да.
3849.28 3857.56 "Игорь Лабутин" Там, во-первых, UI, во-вторых, возможно, там до сих пор еще много какого-нибудь КАМА для общения компонент, и это тоже слабо портируемо.
3857.56 3861.80 "Анатолий Кулаков" Да, наверное, ARM-у КАМА не помеха, поэтому ARM все вытерпит.
3861.80 3864.80 "Игорь Лабутин" Ну, если винда на нем работает, значит, все уже сделано.
3864.80 3865.80 None Да, good.
3865.80 3878.56 "Анатолий Кулаков" Слушай, я вот на этом, напоследок, я думаю, уже пора загругляться, вот принес еще такую интересную тему, интересна она тем, что ей тут как раз практически недавно 10 лет исполнилось.
3878.56 3916.92 "Анатолий Кулаков" Есть такой замечательный автор, которого я не устаю все время хвалить, это Марк Симон, в общем, и до тех пор, когда его больно ударило функциональщиной, он был просто замечательным, шикарным архитектором, именно архитектором не тем чуваком, который квадратики рисует и рассказывает вам, как по схемам стрелочки перемещать, а настоящим архитектором кода, когда он рассказывал прекрасно, как правильно проектировать классы, как правильно проектировать методы, у него шикарная книга про dependency injection, у него шикарные есть статьи про тестирование и так далее, и так далее, то есть все те базовые вещи, которыми пользуются все разработчики каждый день.
3916.92 3924.32 "Анатолий Кулаков" И, соответственно, статьи шикарные, они никогда не устаревают, они прекрасны, и мне кажется, что было бы,
3924.32 3939.12 None наверное, интересно вспомнить об этих статьях, потому что они актуальны, и я очень часто натыкаюсь в код ревью или у коллег, что они допускают те ошибки, которые в этих статьях прекрасно описаны и рассказаны, что с ними делать.
3939.12 3950.20 "Анатолий Кулаков" Поэтому хочется провести такой небольшой эксперимент, хочется попробовать вам рассказать такие про архитектуру и про код звуком, это может быть не очень удобно, но я постараюсь.
3950.20 3952.20 "Анатолий Кулаков" В общем, а вы в комментариях сообщите, насколько мне
3952.20 3956.80 None удалось, и хотите ли вы дальше продолжать удобные статьи у нас видеть.
3956.80 3971.80 None У него есть, у Марка есть шикарная серия, которая называется "Пока йока дизайн", это как раз-таки тот дизайн, который нацелен на то, чтобы ваши классы были как можно более защищены от ошибок.
3971.80 3975.72 "Анатолий Кулаков" Там у него немного статей, но все они прекрасны, я все-таки
3975.72 3982.08 None надеюсь все с вами обсудить, и для сегодня вот как раз первую хочется и представить.
3982.08 3986.60 "Анатолий Кулаков" Давайте же, соответственно, начнем, чтобы вы, в принципе,
3986.60 4000.44 None поняли, про что я говорю, зачем все это большое прелюдие. Наверное, стоит начать с того, с такой базовой вещи, которая, наверное, каждому из вас известна, это то, что чем раньше мы ошибку выловим, тем меньше ее стоимость.
4000.44 4003.92 None Самый ранний этап, где можно выловить ошибку, это копиляция.
4003.92 4008.72 "Анатолий Кулаков" Копилятор это у нас самый главный помощник, самый главный друг, и как только он увидел ошибку, значит
4008.72 4014.04 None прекрасно. Дальше уже идут статические анализы, юнит тестирования, интеграционные тестирования и прочее остальное тестирование,
4014.04 4022.60 None которое нам уже менее интересно. То есть, у нас задача все-таки написать такой код, который будет работать правильно, и эту правильность будет подтверждать копилятор.
4022.60 4029.08 None Это самый гарантированный, самый правильный и самый быстрый метод, который дает нам фидбэк.
4029.08 4033.08 "Анатолий Кулаков" В общем, и соответственно, чем больше мы будем использовать
4033.08 4047.64 None эту прекрасную фичу копилятора, тем лучше. То есть, правильное проектирование классов, которое позволит копилятору подсказывать нам правильное поведение, это то, чем должен заниматься каждый разработчик перед тем, как написать хоть одну-единственную строчку кода.
4047.64 4050.44 None В общем, девиз, наверное, прост.
4050.44 4055.36 "Анатолий Кулаков" Думайте перед тем, как начать что-то делать, и, соответственно, все у вас будет хорошо.
4055.36 4058.60 "Анатолий Кулаков" Что же такое око-йоко дизайн?
4058.60 4066.36 "Анатолий Кулаков" Как я уже упомянул, это дизайн, который нацелен на то, чтобы сделать сложным неправильное использование ваших классов.
4066.36 4071.84 "Анатолий Кулаков" А, соответственно, неправильное использование вам должен подсказывать именно копилятор.
4071.84 4082.64 "Анатолий Кулаков" То есть, копилятор должен вам говорить, что неправильно плохо использовать эти классы вот так вот, а вот по-другому каким-то образом использовать их хорошо.
4082.64 4098.76 "Анатолий Кулаков" Если вы пытаетесь каким-то образом обмануть копилятор или написать неестественные синтексы для дунета или еще что-то сделать, то это, соответственно, еще одна подсказка того, что вы делаете что-то неправильно и попробуйте сделать намного проще, намного интуитивнее и нативнее, так как положено в этом языке.
4098.76 4113.68 "Анатолий Кулаков" И, соответственно, по око-йоко дизайну, вот эти принципы, они выбирают типичные ошибки, которые каждый разработчик допускает в своем коде и называют это как раз-таки запахом.
4113.68 4119.48 "Анатолий Кулаков" И вот эта серия статей, она и называется таким образом, что каким образом нам прийти от...
4119.48 4123.68 "Анатолий Кулаков" Как бы smell так перевести, чтобы не это...
4123.68 4125.08 None От вони к аромату.
4125.08 4132.08 "Анатолий Кулаков" From smell to fragrance.
4132.08 4148.20 "Анатолий Кулаков" И это очень хороший принцип, когда вы у себя в голове складываете какие-то небольшие шаблоны, какие-то небольшие паттерны, и как только вы их видите в коде, видите на ревью, видите где-нибудь в книгах у коллег, даже можете звуком услышать, вы четко сразу должны у себя в голове
4148.20 4154.64 None переключить флаг, который вам говорит, что это запах, это плохой код, можно его сделать лучше.
4154.64 4162.52 "Анатолий Кулаков" И в принципе собрав вот таких вот довольно небольшое количество таких вот запахов, очень сильно можно улучшить код.
4162.52 4169.64 "Анатолий Кулаков" Буквально 10 запахов, и ваш код будет прекрасен, потому что они покрывают основное большинство как бы частых ошибок, которые происходят.
4169.64 4174.52 "Анатолий Кулаков" И вот сегодня я вам предлагаю рассмотреть один из таких запахов, который называется temporal coupling.
4174.52 4182.48 "Анатолий Кулаков" Это очень важная вещь, очень часто встречается, и почему-то большинство разработчиков на нее не обращают внимания, считают, что это нормуль.
4182.48 4184.92 "Анатолий Кулаков" Что же такое temporal coupling?
4184.92 4190.68 "Анатолий Кулаков" Это неявная связь между двумя или более какими-то компонентами или функциями.
4190.68 4200.00 "Анатолий Кулаков" И эта связь говорит о том, что мы один метод, например, должны вызвать до или после второго метода.
4200.00 4203.92 None То есть temporal - это как раз таки от того, что они зависят по времени.
4203.92 4209.48 None Кого мы вызовем первым или вторым, в зависимости от этого меняется поведение класса, поведение метода.
4209.48 4215.84 "Анатолий Кулаков" И, соответственно, это получается у нас очень большая связанность, и эта связанность как раз таки в разрезе временном.
4215.84 4217.84 "Анатолий Кулаков" То есть это большая связанность в временном разрезе.
4217.84 4220.48 "Анатолий Кулаков" Как мы знаем, что большая связанность - это не очень хорошо.
4220.48 4225.60 "Анатолий Кулаков" Например, очень часто, например, каждый из вас наверняка
4225.60 4235.96 None присылал какие-нибудь API клиенты. И очень часто бывает так, что API клиенту сначала нужно залогиниться, например, получить какой-то JVT токен, Jot token, как нас научил Игорь.
4235.96 4241.88 "Анатолий Кулаков" В общем, и только после того, как он залогинился, появится смысл делать что-то другое, например, скачивать какой-то файл.
4241.88 4246.80 "Анатолий Кулаков" Если вы пойдете скачивать файл без токена, у вас 100% будет ошибка, что вы не авторизованы.
4246.80 4251.24 "Анатолий Кулаков" И, соответственно, вот мы видим временную связанность.
4251.24 4255.00 "Анатолий Кулаков" То есть вам обязательно нужно вызвать логин, метод
4255.00 4258.68 None логина у клиента, и только после этого вызвать метод даунлод.
4258.68 4264.64 "Анатолий Кулаков" Если вы поменяете их местами, сначала вы заявите даунлод, то у вас, скорее всего, точно будет exception.
4264.64 4271.52 "Анатолий Кулаков" Потому что мы пишем для конкретного сервиса, клиента, и мы точно знаем, что этот сервис не принимает на вход неавторизованные запросы.
4271.52 4273.52 "Анатолий Кулаков" Соответственно, у вас точно будет exception.
4273.52 4279.84 "Анатолий Кулаков" Вот таким образом мы получили, что у нас, у клиента спроектирован не очень правильно.
4279.84 4286.40 "Анатолий Кулаков" У клиента есть как раз-таки вот этот запах, temporal coupling.
4286.40 4292.84 "Анатолий Кулаков" Соответственно, в BCL очень много типов, которые позволяют
4292.84 4298.16 None себе такие вольности. Например, есть EndpointAdapterBuilder.
4298.16 4300.28 "Анатолий Кулаков" Тоже очень интересный класс.
4300.28 4306.80 "Анатолий Кулаков" Вы можете создать этот билдер и в следующей строчке, например, его сбилдить с помощью метода toEndpointAddress.
4306.80 4311.04 "Анатолий Кулаков" Как только вы вызовете метод toEndpointAddress, вы в рантайме получите исключение.
4311.04 4314.04 "Анатолий Кулаков" У вас это все скомпилируется, безусловно.
4314.04 4317.92 "Анатолий Кулаков" Вызвали конструктор, вызвали метод, все хорошо, но в рантайме вы получите исключение.
4317.92 4321.88 "Анатолий Кулаков" Как бы хватаетесь за голову, кричите, какого, почему.
4321.88 4329.84 "Анатолий Кулаков" А на самом деле этот класс нельзя вызывать, этот метод нельзя вызывать до тех пор, пока вы не присвоите свойство URI у этого класса.
4329.84 4348.68 "Анатолий Кулаков" То есть, как только вы в свойство, оно обязательное, как только вы в обязательное свойство присвоите какой-то начальный URI и после этого вызовете метод toEndpointAddress, у вас все прекрасно сработает, Endpoint построится, все будут счастливы, кроме банальной человеческой логики.
4348.68 4353.16 "Анатолий Кулаков" Никто, нигде явно не декларирует, что поле URI, оно обязательное.
4353.16 4367.20 "Анатолий Кулаков" И вот это магическое знание, что вы не можете вызвать метод build до того, как установите свойство URI, вот это магическое знание, оно и делает опять же вот этот смайл, temporal coupling.
4367.20 4382.00 "Анатолий Кулаков" Его основная фишка в том, что оно не явное, оно непонятное, разработчики про него не знают, напаруться могут в рантайме, в документации тоже не всегда это явно как-то описано, из IntelliSense непонятно, копилятор не подсказывает.
4382.00 4387.08 "Анатолий Кулаков" Это вот такая банальная штука, которая встречается очень-очень много где.
4387.08 4391.24 "Анатолий Кулаков" Если это все свести к какому-то общему шаблону, то обычно
4391.24 4397.16 None это встречается в виде метода initialize. Я уверен, что во многих ваших проектах, наверное, есть метод initialize.
4397.16 4415.72 "Анатолий Кулаков" То есть типичный класс, который должен вызывать вот этот запах, вот этот признак у вас, это класс, который внутри себя имеет метод initialize, который вы обязательно должны дернуть первым, и только после того, как вы его дернули, уже можете дергать все остальные методы этого класса.
4415.72 4424.72 "Анатолий Кулаков" Соответственно, давайте разберем, в чем же проблема этого шаблона, такого подобных классов.
4424.72 4431.08 "Анатолий Кулаков" Как я уже сказал, нет явного признака того, какой метод
4431.08 4435.00 None нужно дернуть первым, а каким не первым. Вы можете легко забыть, вы можете перепутать местами,
4435.00 4441.60 None тем более, если этот класс используется из нескольких методов, в нескольких потоках, вы понятия не имеете, кто из них чего первым дернет.
4441.60 4446.76 "Анатолий Кулаков" И поэтому городят всякие костыли в виде lazy, lock, прочей чуши.
4446.76 4453.84 "Анатолий Кулаков" В общем, это, опять же, как только вы видите непонятную сложность, которая нарастает, это первый признак того, что, скорее всего, что-то делать не так.
4453.84 4460.92 "Анатолий Кулаков" Дальше, копилятор никак нас не предупреждает о том, что этот метод нужно вызвать, и исключение будет именно в ранг тайме.
4460.92 4463.16 "Анатолий Кулаков" Это самое плохое, что может случиться, конечно.
4463.16 4465.24 "Анатолий Кулаков" Не анализаторы, ничего.
4465.24 4476.40 "Анатолий Кулаков" Вы, конечно, можете пройтись по всему этому безобразию тестами и тестами покрыть, но это тоже, соответственно, будет уже или поздно, или об этом надо знать, что
4476.40 4481.92 None его явно нужно покрыть, а те разработчики, которые ваш класс будут использовать, они все равно об этом каким-то образом не знают.
4481.92 4486.24 "Анатолий Кулаков" Им все равно нужна какая-то неявная документация или уже примеры использования.
4486.24 4498.16 "Анатолий Кулаков" Соответственно, то, что у нас класс требует для себя вызова какого-то определенного метода, до этого он не работает, это всего лишь навсего значит, что класс не защищает свои инварианты.
4498.16 4501.88 "Анатолий Кулаков" То есть он находится в том состоянии, в котором его невозможно использовать.
4501.88 4507.24 "Анатолий Кулаков" Это также обозначает, что у него сломанная инкапсуляция.
4507.24 4512.12 "Анатолий Кулаков" Именно инкапсуляция в том виде, в котором она должна работать.
4512.12 4518.68 "Анатолий Кулаков" Инкапсуляция - это по правде не спрятывание каких-то приватных филдов за публичными свойствами.
4518.68 4520.44 "Анатолий Кулаков" То есть это не инкапсуляция.
4520.44 4530.72 "Анатолий Кулаков" Настоящая инкапсуляция - это та, которая прячет сложную логику и при этом выставляет легкие ручки для того, чтобы с этим классом работать.
4530.72 4546.44 "Анатолий Кулаков" И как раз таки, как только вы эту сложную логику, пытаясь вытащить наружу, например, дернете метод меньше алайса, только потом работаете с классом, это приводит к тому, что у вас ломается инкапсуляция, соответственно, ломаются инварианты, и такие классы считаются плохо спроектированными.
4546.44 4553.32 "Анатолий Кулаков" Хорошо, я надеюсь, что всем уже понятно, что это плохо, давайте подумаем, как это можно дело пофиксить.
4553.32 4572.48 "Анатолий Кулаков" Соответственно, если представим себе ситуацию, опять же вот этот класс, который я выше задекларировал, то есть класс, у которого есть метод initialize, допустим, он принимает в качестве параметра какое-то свойство name, какой-то параметр name, и соответственно у него есть метод spread, который этот name возвращает.
4572.48 4579.32 "Анатолий Кулаков" Соответственно, до тех пор, пока мы не пронициализируем класс, возвращать ему нечего, и поэтому он будет падать в рантайме.
4579.32 4581.12 "Анатолий Кулаков" Что у нас здесь происходит?
4581.12 4587.72 "Анатолий Кулаков" Соответственно, если класс не может работать без этого свойства name, значит, это свойство name должно быть
4587.72 4593.32 None всегда ему доступно. Чтобы оно всегда ему было доступно, естественно, он должен принять его в конструкторе.
4593.32 4606.36 "Анатолий Кулаков" Как только мы принимаем это свойство name в конструкторе, у нас, соответственно, выпадает вот эта дилемма, что каким же образом нам вызвать метод spread, ведь name у нас нет, и в некоторых случаях его может не быть.
4606.36 4609.76 "Анатолий Кулаков" В общем, вот эта дилемма сразу выпадает.
4609.76 4617.60 "Анатолий Кулаков" Мы можем сделать специальный класс, который внутри себя принимает name, и у которого точно также есть метод spread, который этот name просто возвращает.
4617.60 4623.00 "Анатолий Кулаков" Так как name теперь всегда доступный у всех инстансов класса, никаких проблем у нас с этим нет.
4623.00 4627.44 "Анатолий Кулаков" Также у нас появилось два побочных положительных эффекта.
4627.44 4630.72 "Анатолий Кулаков" Во-первых, у нас уменьшилась циклотематическая сложность.
4630.72 4638.20 "Анатолий Кулаков" Нам уже не нужно внутри spread проверять, передали нам name, бросить exception, а если не exception, то может быть default или еще что-то.
4638.20 4639.76 "Анатолий Кулаков" То есть вот этой глупости уже больше нет.
4639.76 4643.80 "Анатолий Кулаков" У нас в конструкторе мы приняли имя, и в методе это имя вернули.
4643.80 4645.80 "Анатолий Кулаков" Все прекрасно, никакой сложности вообще нет.
4645.80 4647.68 "Анатолий Кулаков" И еще одно интересное побочное эффект.
4647.68 4653.72 "Анатолий Кулаков" Теперь у нас вот этот класс smell, он стал immutable, а, соответственно, он уже стал потокобезопасным.
4653.72 4656.68 "Анатолий Кулаков" Это тоже очень часто полезная фича.
4656.68 4660.56 "Анатолий Кулаков" Теперь мы, опять же, не боремся с вот этим эффектом.
4660.56 4666.48 "Анатолий Кулаков" Когда у нас несколько потоков заходят в класс, один из них пытается что-то проинциализировать, второй в это время пытается вызвать метод.
4666.48 4670.36 "Анатолий Кулаков" Все они как-то стоят на локах или уже стоят на deadlock, а как получится.
4670.36 4672.68 "Анатолий Кулаков" В общем, мы больше этой дилеммы не загоняемся.
4672.68 4681.44 "Анатолий Кулаков" Класс полностью immutable, класс получается полностью thread safe, инициализированный без, соответственно, дурацких ифов.
4681.44 4683.92 "Анатолий Кулаков" Получается чистый, красивый, понятный класс.
4683.92 4688.36 "Анатолий Кулаков" У этого подхода может быть парочка сложностей.
4688.36 4694.04 "Анатолий Кулаков" Допустим, бывает так, что вот это свойство name, оно известно только в runtime.
4694.04 4697.72 None То есть мы его в конструктор просто так передать не можем.
4697.72 4707.96 "Анатолий Кулаков" Или, может быть, мы не можем его каким-то образом создать явно, потому что работаем через интерфейсы и, соответственно, тоже доступа к никаким конструкторам у нас нет.
4707.96 4713.20 "Анатолий Кулаков" Или же еще более частый случай, когда, например, этот метод внешалась, является асинхронно.
4713.20 4716.04 "Анатолий Кулаков" Асинхронные конструкторы к нам пока еще не завезли.
4716.04 4717.64 None Надеюсь, все-таки не завезут.
4717.64 4720.60 "Анатолий Кулаков" В общем, но каким-то образом нам этот метод вызвать нужно.
4720.60 4725.20 "Анатолий Кулаков" И, соответственно, как быть, если предлагается все-таки использовать конструкторы?
4725.20 4726.88 "Анатолий Кулаков" А быть очень легко.
4726.88 4730.44 "Анатолий Кулаков" Для этого у нас есть еще один классик, который можно
4730.44 4745.28 None назвать Smell Factory. Этот Smell Factory, у него есть один единственный метод create, который принимает все зависимости, которые нужны нашему основному смеллу, то есть, например, свойство name, и внутри себя уже вызывает конструктор этого классика.
4745.28 4747.64 "Анатолий Кулаков" И он решает все вышеописанные свойства.
4747.64 4754.56 "Анатолий Кулаков" У него уже есть интерфейс, который вы можете там заинжектировать куда-нибудь в ваш контейнер, допустим, который уже можно дернуть.
4754.56 4755.96 "Анатолий Кулаков" Он уже может быть асинхронным без проблем.
4755.96 4759.40 "Анатолий Кулаков" И он точно так же создает внутри себя понятный класс
4759.40 4766.48 None Smell без каких-то, без каких-либо условий, без каких-либо проблем.
4766.48 4770.04 "Анатолий Кулаков" Соответственно, в результате мы получаем два чистых, равновесных класса.
4770.04 4774.80 "Анатолий Кулаков" Один из них Factory, другой из них Smell, которые защищают свои инварианты.
4774.80 4776.88 None У них уже нет разночтений.
4776.88 4779.60 None Они оба готовы работать в любом состоянии.
4779.60 4782.88 "Анатолий Кулаков" Factory способна владеть классы как не в себя.
4782.88 4788.84 "Анатолий Кулаков" Классы способны создаваться и сразу же возвращать неймы без каких-либо аифов, без каких-то условий.
4788.84 4793.48 "Анатолий Кулаков" И, соответственно, они никогда не могут быть в разъехавшемся, сломанном состоянии.
4793.48 4796.80 "Анатолий Кулаков" И таким образом мы добились нашей первоначальной цели.
4796.80 4802.60 None Теперь у нас компилятор именно подсказывает, каким образом использовать этот класс.
4802.60 4811.72 None То есть, заметьте, вы после того, как перешли на вот эту схему с Fabric и Smell, уже не можете просто так взять и вызвать некий метод, который упадет у вас в рантайме.
4811.72 4813.64 "Анатолий Кулаков" Такого метода физически не существует.
4813.64 4823.40 "Анатолий Кулаков" Если вы хотите вызвать метод Spread, для того чтобы получить имя, вы должны сначала взять Factory, создать у нее этот класс и у этого класса вызвать метод.
4823.40 4827.64 "Анатолий Кулаков" Если вы попытаетесь сделать что-то другое, то вам компилятор скажет, что это сделать невозможно.
4827.64 4833.60 "Анатолий Кулаков" Вам компилятор подскажет, вам интеллисенс подскажет, вам студия и прочие анализаторы подскажут, как работать
4833.60 4839.28 None с этим классом. Не нужно писать какую-то документацию, не нужно заставлять смотреть какие-то примеры или заглядывать в тесты.
4839.28 4841.52 "Анатолий Кулаков" У вас код будет интуитивно понятным.
4841.52 4850.12 "Анатолий Кулаков" Человек, который просто буквально пару секунд на него посмотрит, может быть, какой-то интеллисенс там вызовет, он сразу поймет, как с этим классом работать.
4850.12 4861.44 "Анатолий Кулаков" И если мы вспомним мой первый пример, когда мы обсуждали с вами API Client с методом логин и даунлод, соответственно, становится сразу понятно, кем же образом его пофиксить.
4861.44 4866.28 None Дело в том, что у API Client должен быть один-единственный метод, который называется логин.
4866.28 4869.48 "Анатолий Кулаков" Этот метод логин должен возвращать авторизованный
4869.48 4878.96 None клиент. То есть, если у него получилось правильно залогинить, он вам возвращает отдельный другой клиент, который уже показывает своим интерфейсом и своими методами, что это
4878.96 4883.20 None уже авторизированный клиент. С помощью него можно пытаться обратиться к файлам.
4883.20 4890.84 None И только у авторизованного клиента уже есть вот эти методы даунлод, которые позволяют скачать файл или обратиться к другому API.
4890.84 4895.76 "Анатолий Кулаков" Таким образом, вы подсказываете пользователю, что нельзя идти к моему сервису без вызова метода логина.
4895.76 4898.48 "Анатолий Кулаков" И он даже не сможет этого никак сделать, потому что
4898.48 4903.72 None только метод логин способен вернуть ему тот интерфейс, с помощью которого он пойдет уже к вашим сервисам.
4903.72 4906.76 "Анатолий Кулаков" В общем, такой простой техникой и таким довольно часто
4906.76 4917.24 None распространенным случаем можно закрыть огромное количество проблем с тестированием, с документацией, с какими-нибудь вещами, с введением в технологии и прочие-прочие вещи.
4917.24 4921.52 "Анатолий Кулаков" Закрывается буквально все небольшим перепроектированием классиков.
4921.52 4925.20 "Игорь Лабутин" Ну, звучит, да, звучит прекрасно.
4925.20 4933.44 "Игорь Лабутин" Как только я услышал про фабрики, сразу подумал про Java, но я надеюсь, мы не настолько будем создавать абстрактные фабрики и так далее.
4933.44 4936.76 "Игорь Лабутин" В реальной жизни действительно это хорошо помогает.
4936.76 4950.40 "Игорь Лабутин" Я не знаю, насколько это помогает прямо тестированию, но вот для конечных пользователей, для потребителей вашего API, оно прям сильно помогает, если вы предоставляете такой удобный интерфейс, структурированный.
4950.40 4953.88 "Игорь Лабутин" Тут я хочу немножко, да, про термин поговорить, вот тот самый Pocoyoke.
4953.88 4959.00 "Игорь Лабутин" Это из Toyota Production System, откуда у нас вырос kanban и прочие странные японские слова.
4959.00 4965.56 "Игорь Лабутин" Это японский термин, который на самом деле переводится как "предотвращение ошибок" по сути.
4965.56 4976.92 "Игорь Лабутин" Вот, и это действительно официальный термин, который говорит про то, что нужно строить систему так, чтобы вы физически не могли сделать что-то, что нельзя сделать.
4976.92 4985.36 "Анатолий Кулаков" Да, это хорошо как раз проекцируется на вот эту возможность компилятора подсказывать вам то, что так нельзя делать.
4985.36 4987.28 "Анатолий Кулаков" Так оно просто не скопилится.
4987.28 4998.68 "Игорь Лабутин" Да, из этой же разряда, в Toyota это, понятное дело, использовали для производства машин, вы там не можете завести машину с автоматической коробкой, пока не нажмете на педаль тормоза.
4998.68 4999.68 "Игорь Лабутин" Вот это то самое.
4999.68 5007.56 "Игорь Лабутин" То есть у вас есть только один интерфейс, да, вы можете делать что-то через один интерфейс и только потом вам возвращается другой интерфейс.
5007.56 5009.96 "Игорь Лабутин" А потом вы можете отпускать педаль тормоза и ехать.
5009.96 5010.96 None Вот это то да.
5010.96 5021.08 None Да, как я уже сказал, там есть еще несколько интересных примеров, напишите их в комментах или дайте знать о том, насколько вам удобно было все это слушать, насколько вам понравилась тема.
5021.08 5027.00 "Анатолий Кулаков" И я надеюсь, что в будущих наших выпусках мы разберем еще парочку статей, а может даже и больше.
5027.00 5030.48 "Игорь Лабутин" А на сегодня будем, я думаю, заканчивать.
5030.48 5042.20 "Игорь Лабутин" Мы сегодня обсудили новинки в DotNet 7 Preview 5, много всего интересного, особенно детально обсудили Generic Math, ну и вообще в Preview 5 очень много всяких интересных штук.
5042.20 5050.84 "Игорь Лабутин" Посмотрели на то без особых деталей, но тем не менее, как улучшали перформанс в DotNet Maui, почитайте, если вам это интересно.
5050.84 5063.32 "Игорь Лабутин" Узнали про очень важные изменения в сообщениях об ошибках, которые DotNet будет выдавать, если не нашли, ну то есть некоторые программы на DotNet будут выдавать, если не нашли DotNet Runtime на компьютере.
5063.32 5070.48 "Игорь Лабутин" Посмотрели на две новых Visual Studio, пока Preview, это Visual Studio for Maximax 3 Preview 2 и ARM64 Visual Studio.
5070.48 5077.52 "Игорь Лабутин" Ну и вспомнили хорошую статью Марка Симона про специальный дизайн так, чтобы уменьшать temporal coupling.
5077.52 5080.68 "Игорь Лабутин" На этом, видимо, все на сегодня.
5081.68 5082.68 "Анатолий Кулаков" Наверное, да.
5082.68 5095.00 "Анатолий Кулаков" Я напомню, что у нас есть сайт radio.dotnet.ru, но мы также принимаем письма по аналогичному адресу, поэтому пишите о ваших предложениях, может быть, интересных статьях, интересных идей, которые вы для себя нашли и хотите поделиться с миром.
5095.00 5099.52 "Анатолий Кулаков" Мы представлены практически на всех подкаст-площадках, на YouTube, в социальных сетях.
5099.52 5101.64 "Анатолий Кулаков" В общем, я думаю, найдете нас где угодно.
5101.64 5102.64 "Анатолий Кулаков" Шары, репост.
5102.64 5106.52 "Анатолий Кулаков" Те, кто сильно нас любит, можете приходить на наш сайт на Boosty.
5106.52 5110.88 "Анатолий Кулаков" Там у нас собралась отличная команда с донатерами.
5110.88 5118.96 "Анатолий Кулаков" В общем, у нас там есть закрытый чатик, там мы весело вместе общаемся и вообще всячески помогаем друг другу, приятно проводить время.
5118.96 5120.96 "Анатолий Кулаков" В общем, тоже заходите, там интересно.
5120.96 5124.04 "Игорь Лабутин" Ну, это был 54-й выпуск радио.dotnet.
5124.04 5126.12 "Игорь Лабутин" С вами были Игорь Лоботин.
5126.12 5127.40 "Анатолий Кулаков" И Анатолий Кулаков.
5127.40 5128.40 "Анатолий Кулаков" Всем пока.
5128.40 5128.90 "Игорь Лабутин" Всем пока.
5128.90 5130.90 None С вами был Игорь Лабутин.
5130.90 5137.78 None Всем пока.
5137.78 5142.66 None [музыка]
