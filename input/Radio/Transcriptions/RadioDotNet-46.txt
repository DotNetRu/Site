0.00 9.92 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер 46.
9.92 13.64 "Анатолий Кулаков" И сегодня с вами будут Анатолий Кулаков и Игорь Лабутин.
13.64 14.64 "Анатолий Кулаков" Привет.
14.64 22.04 "Анатолий Кулаков" Огромное спасибо нашим друзьям, Александру, Сергею Владиславу, Алексею, Шевченко Антону и Илье.
22.04 25.84 "Анатолий Кулаков" Большое спасибо за то, что помогаете нашему подкасту.
25.84 31.24 "Анатолий Кулаков" И давай сразу перейдем к темам, потому что первая тема у нас – юбилей.
31.24 43.76 "Анатолий Кулаков" Мы о нем уже говорили в прошлом выпуске, но в этом не грех и повториться, потому что юбилей большой, ибо ровно 20 лет назад, 13 февраля, вышла первая версия .NET.
43.76 47.16 "Анатолий Кулаков" Зарелизалась она вместе с Visual Studio .NET.
47.16 62.44 "Анатолий Кулаков" И в принципе это то величайшее событие, которое сплотило нас всех, создало наш подкаст, дало нам работу и подалило массу интересных впечатлений на конференциях и митапах и прочем, прочем, прочем.
62.44 68.12 "Анатолий Кулаков" То есть здесь эпохальная точка в истории как бы началась.
68.12 73.48 "Анатолий Кулаков" И за все это время, конечно же, случилось очень много с .NET.
73.48 85.08 "Анатолий Кулаков" Сначала он был закрытым, потом Microsoft начала его постепенно открывать исходные коды, потом она начала разрабатывать его в open-source, и в конце концов мы пришли вот к текущему моменту – 20 лет.
85.08 106.28 "Анатолий Кулаков" За это время можно похвалиться многими достижениями, например, .NET был признан как самая любимая Most Loved платформа в 2019, 2020 и в 2021 годах, согласно опросу Stock Overflow, где опрашивались много разработчиков и выбирались их предпочтения.
106.28 111.28 "Анатолий Кулаков" То есть мы с вами работаем за одну из самых любимых и милых и интересных платформ.
111.28 125.46 "Анатолий Кулаков" Безусловно, это заслуга не только .NET, но и инструмента вокруг него, языка C#, который с каждой версией становится все современнее, интереснее, инновационнее и никогда не устаревает.
125.46 128.56 "Анатолий Кулаков" Вот за что им тоже отдельный большой респект.
128.56 144.20 "Анатолий Кулаков" Также нужно сказать, что .NET репозитории получали микрософтовские такие награды, как топ-30 – самые быстро развивающиеся open-source проекты на GitHub, и они держатся в этом топ-30 с 2017 года.
144.20 151.52 "Анатолий Кулаков" Все мы прекрасно помним бетчмарки Tech Empower, где мы там были и то на первом месте, и то входили в топ.
151.52 155.76 "Анатолий Кулаков" Ну, в общем, занимали достойные позиции, за которые в принципе и не стыдно.
155.76 158.04 "Анатолий Кулаков" Можно и друзьям рассказать, и соседям показать.
158.04 164.92 "Анатолий Кулаков" Ну, GetOrg у нас уже содержит почти 30 тысяч разных пакетов.
164.92 175.04 "Анатолий Кулаков" У нас есть большое сообщество, это порядка 380 пользовательских юзер-групп в 68 странах, что тоже не можно и радовать.
175.04 180.08 "Игорь Лабутин" Я только хочу сказать, что ты чуть-чуть ошибся, не 30 тысяч, а 300 тысяч пакетов на Nuget.
180.08 186.52 "Игорь Лабутин" То есть, там это, ну если до миллиона нам еще далеко, но 300 тысяч – это уже немало.
186.52 198.96 "Анатолий Кулаков" Ну, мне кажется, да-да, ты прав, 300 тысяч, но это такой разумный предел, что лефтпады у нас еще не начались, и слава богам, что мы, надеюсь, все-таки до такого маразма не доживем, поэтому 300 тысяч – это норм.
198.96 201.96 "Анатолий Кулаков" Это и хватает, и какого-то избытка, и маразма тоже
201.96 205.80 "Игорь Лабутин" нет. Ну, может, лефтпады где-то и есть, просто их не используют активно.
205.80 210.64 "Игорь Лабутин" Пакеты-то наверняка какие-то похожие есть, просто они не находят популярности, и это хорошо на самом деле.
210.64 216.68 "Анатолий Кулаков" Да, если они не становятся популярными, значит, не будут клоны лефтпадов, и не будет плодиться ненужные непонятные пакеты.
216.68 227.64 "Анатолий Кулаков" Если говорить по годам, то примерно где-то в 2012 году Microsoft впервые выложил ASP.NET MVC Web Framework в открытый доступ.
227.64 240.20 "Анатолий Кулаков" Ну, раньше Microsoft тоже исходники выкладывал потихоньку, понемножку, но это, в принципе, наверное, вот самая такая большая, самый заметный и полноценный open-source проект Microsoft.
240.20 252.44 "Анатолий Кулаков" И в этом проекте он начал принимать contributions, то есть не просто показал там референс с ОРЦ, а реально начал принимать contributions, начал работать с сообществом и каким-то образом открыто ввести вот настоящий open-source проект.
252.44 271.76 "Анатолий Кулаков" А уже в 2014, буквально через два года, мы уже начали писать кроссплатформенный open-source .NET компилятор, который разрабатывался всем миром, и уже платформа .NET Core, известная нам, начала свое становление между различными операционными системами и различными рантаймами.
271.76 275.68 "Анатолий Кулаков" И что же у нас следующее?
275.68 287.76 "Анатолий Кулаков" Во-первых, недавно вообще зарелизился LTS .NET 6, буквально в ноябре 2021 года, и сейчас активно все внедряют его, переходят на новую LTS версию.
287.76 302.76 "Анатолий Кулаков" Впереди нас ждет .NET 7, сегодня мы еще о нем поговорим, уже есть первые превью, уже можно смотреть какие-то там планы, наметки, и мы обязательно будем держать вас в курсе всех развитий 7 .NET.
302.76 313.88 "Анатолий Кулаков" Конечно же ждали в прошлом году .NET MAMOWEE, это наш кроссплатформенный мультиплатформ UI, который должен победить все остальные кроссплатформенные мультиплатформ UI.
313.88 319.96 "Анатолий Кулаков" Но обещают, скоро времени обещают, также это будет часть .NET 7, будем ждать.
319.96 329.12 "Анатолий Кулаков" С помощью этого прекрасного фреймворка мы сможем писать нативные приложения под Windows, Mac, iOS, Android, и все это на единой кодовой базе.
329.12 334.48 "Анатолий Кулаков" Вот такое радостное будущее нам обещают пакетологи уже много-много лет, ну подождем, посмотрим.
334.48 374.08 "Анатолий Кулаков" Что ж, .NET продолжает развиваться, он сейчас работает на всех главных операционных системах, у него шикарная производительность, у него шикарный тулинг, прекрасные IDE, великолепный язык, на нем можно писать высокопроизводительные приложения для облаков, можно писать модные микросервисы, можно писать десктопные приложения, можно даже писать приложения для микроконтроллеров, и в принципе, наверное, нет какой-то ниши, куда мы бы еще не могли добраться, и покрыть ее хорошо, удобно, и как это положено в современном мире с классным тулингом вокруг.
374.08 387.64 "Игорь Лабутин" Да, и пусть .NET дальше развивается, open-source явно этому помогает, мне кажется, и подтверждение этого будет недалеко, сегодня в подкасте мы будем обсуждать, во что выливается тот факт, что Microsoft выкладывает все в open-source.
387.64 388.64 "Игорь Лабутин" Ну, посмотрим.
388.64 449.88 "Игорь Лабутин" А пока пойдем дальше по новостям, и я, честно говоря, когда мы готовился к этому подкасту, когда мы планировали запись, было впечатление, что как-то маловато новостей, но тут они как посыпались, так что будет сегодня довольно плотный выпуск по новостям, и начнем мы с .NET MAUI, который упомянул Толя, вышел в, прошу прощения, 13 превью, который доступен, вижу, в студии 17.2 превью 1, не запутайтесь в номерах превью, в основном это все quality improvements, команда говорит, что потихонечку сходит все к исключительно улучшениям качества, потому что релиз близится, но тем не менее, какие-то новые фичи все еще появляются, то есть они завезли в этот раз поддержку формата текста, то есть это такой XAML элемент внутри одного лейбла, если вам нужно сделать, допустим, какой-то очень хитрый лейбл с кучей разного шрифтов, например, вы теперь можете это использовать в одном лейбле, сделать элемент формата текста и внутри там дальше разметить его специальными тегами с разным форматированием, и будет все как надо.
449.88 465.60 "Игорь Лабутин" Улучшили кучку контролов, то есть ListView, RadioButton, там какие-то креши пофиксили, по-моему, перформанс улучшили, и одно из довольно, ну скажем так, не то чтобы значительных, но заметных изменений убрали использование Microsoft Extensions Hosting.
465.60 503.56 "Игорь Лабутин" Мы уже много раз обсуждали, что модель того, как вы строите MAUI-приложение, очень похожа на то, как вы строите S-Parent приложение, там тоже есть Program.CSS или что-то похожее, там тоже есть Startup.CSS или что-то похожее, и вот эту концепцию хостинга выяснилось, что она не сильно нужна MAUI-приложениям, но она при этом тормозит стартап, и за счет того, что убрали вот этот Microsoft Extensions Hosting, то допустим, они бенчмаркали Android-приложение, которое теперь стартует примерно на 13% быстрее, но на пустом приложении, понятно, что не пустой, оно будет тратить еще какое-то время на свою уже бизнес-логику, но в целом вот так.
503.56 522.28 "Игорь Лабутин" Важное нововведение или улучшение, касающееся как раз области вокруг стартапа, это называется Platform App Classes, то есть на каждой платформе есть теперь свой собственный нативный класс приложения, где, собственно, нужно делать то, что вы хотите делать специфично для платформы.
522.28 530.44 "Игорь Лабутин" То есть, как мы помним, MAUI - это единый код на все, но поскольку все-таки оно компилируется под разные платформы, вам может быть необходимо на каждой платформе сделать что-то свое.
530.44 552.32 "Игорь Лабутин" Ну и, соответственно, для Windows есть класс под названием WinUI Application, для Android - Main Application, для iOS и macOS называется AppDelegate, и если вам очень нужно, вы можете сделать операционную систему специфичную штуку в этих классах, но вообще Microsoft рекомендует, конечно, все делать в главном MAUI программ, потому что он общий для всех.
552.32 561.40 "Игорь Лабутин" Например, там вы будете конфигурировать ваш DI-контейнер, который там все поддерживается, то есть это некий такой аналог стартапа того, что вы знаете в iSpin and Core.
561.40 577.64 "Игорь Лабутин" Ну вот, примерно так, MAUI потихонечку движется к релизу, он все также обещается в General Availability во втором квартале 2022 года, что уже как бы через второй квартал начнется через пару месяцев, даже ближе, и посмотрим, когда будет релиз.
577.64 584.52 "Анатолий Кулаков" Ну, отлично, у нас, в принципе, еще сегодня много таких обещаний на будущее, и следующая тема как раз-таки тоже про будущее.
584.52 597.52 "Анатолий Кулаков" Был анонсирован .NET 7 Preview 1, так что если вдруг кто-то из вас хотел перелезть на шестерку или планировал это как-нибудь сделать или еще не успел это сделать, в общем, бросайте все это дело, сейчас модная семерка.
597.52 601.72 "Анатолий Кулаков" Все быстренько перелезаем на семерку, потому что уже вот новая молодежь.
601.72 604.00 "Анатолий Кулаков" Посмотрим, что же нас ждет в Preview 1.
604.00 613.12 "Анатолий Кулаков" Во-первых, конечно же .NET MAUI, который мы сегодня уже не раз упоминали, он войдет в семерку тоже.
613.12 619.60 "Анатолий Кулаков" Мы надеемся, что все-таки его релиз мы увидим при жизни шестого фреймворка, но в семерке он точно будет.
619.60 627.88 "Анатолий Кулаков" Для седьмого .NET вам понадобится Visual Studio 17.2 Preview 1, ничего другого не подходит, на Visual Studio for Mac она пока не запускается.
627.88 643.44 "Анатолий Кулаков" И самое главное, что мне понравился этот анонс, в том, что он наконец дал нам понимание, что такое Cloud Native Improvement and Performance Calibrity Containers и вот эти все прочие глупости, которые нам все время обещали про Cloud Native.
643.44 647.72 "Анатолий Кулаков" Давайте теперь же разберемся, что же Microsoft подразумевает под этим странным названием.
647.72 653.76 "Анатолий Кулаков" Прежде всего, естественно, наше приложение сейчас больше и больше погружается в контейнеры.
653.76 658.84 "Анатолий Кулаков" У нас уже есть по дефолту, в дефолтном шаблоне Visual Studio, студии билды в контейнере.
658.84 662.20 "Анатолий Кулаков" Мы уже приложение дистрибьютим с помощью контейнеров.
662.20 666.04 "Анатолий Кулаков" И тестируем даже в контейнерах.
666.04 669.08 "Анатолий Кулаков" В общем, контейнеры пришли к нам, похоже, далеко и надолго.
669.08 676.64 "Анатолий Кулаков" И поэтому Microsoft всячески пытается улучшить работу с контейнерами и в том числе с облаками.
676.64 682.60 "Анатолий Кулаков" Потому что большинство приложений как раз сейчас переезжает в облако, в частные или в публичные, неважно.
682.60 692.92 "Анатолий Кулаков" Главное, что везде есть какая-то инфраструктура, которая хорошо жонглирует контейнерами и нативно позволяет запускать вам ваше .NET приложение.
692.92 701.72 "Анатолий Кулаков" Прежде всего Microsoft планирует улучшить возможность настройки аутентификации и авторизации для таких контейнеризируемых приложений.
701.72 705.92 "Анатолий Кулаков" Пока без подробностей, что именно это обозначает и в каком виде это выразится.
705.92 710.44 "Анатолий Кулаков" Дальше планируется улучшить производительность непосредственно в самих контейнерах.
710.44 717.84 "Анатолий Кулаков" Это время старта контейнера и непосредственно сам рантайм, чтобы чувствовался в контейнере быстро, красиво и удобно.
717.84 728.68 "Анатолий Кулаков" Также интересная штука, что Microsoft планирует внедрить в MS Build, прямо в SDK MS Build, стандартные шаги по постройке контейнера.
728.68 734.96 "Анатолий Кулаков" Теперь это будет такая же очевидная вещь, как, например, скомпилировать Solution.
734.96 742.56 "Анатолий Кулаков" Планируется добавить большей телеметрии и больше наблюдаемости в контейнере, чтобы можно было их лучше контролировать и предсказывать их поведение.
742.56 748.84 "Анатолий Кулаков" Также мы нацелены на то, чтобы сделать контейнеры как можно меньше, как можно быстрее и как можно безопасней.
748.84 759.28 "Анатолий Кулаков" Microsoft отмечает, что в сообществе очень сильно есть спрос на rootless и distroless подходы.
759.28 761.36 "Анатолий Кулаков" Вкратце – rootless.
761.36 787.48 "Анатолий Кулаков" Это такой специальный режим, который позволяет запускать демона докера и контейнеры от лица пользователя без привилегий администратора, чтобы уменьшить риск потенциальной уязвимости, потому что была такая большая проблема, что всегда, когда у нас запускаются какие-то докеры, у нас обязательно должен быть администратор, обязательно должен быть root, чтобы выдавать вот эти изоляционные левелы.
787.48 796.16 "Анатолий Кулаков" Но сейчас докер поддерживает rootless режим, и это очень хорошо, потому что площадь атаки как раз-таки уменьшается.
796.16 805.24 "Анатолий Кулаков" И нужно, чтобы, соответственно, фреймворки, инструменты вокруг и все это тоже поддержали этот режим, чтобы они не требовали какой-то обязательно root.
805.24 808.84 "Анатолий Кулаков" И другой интересный запрос – это distroless.
808.84 816.24 "Анатолий Кулаков" Это специальный проект, который предлагает подборку базовых distroless образов.
816.24 819.64 "Анатолий Кулаков" Такие очень-очень маленькие образы, в которых убрано абсолютно все нужное.
819.64 832.64 "Анатолий Кулаков" Как бы, судя из названия, даже дистрибутив непосредственно операционной системы убран, и они не содержат вообще ни пакетов, ни менеджеров пакетов, ни оболочек, ни шелов, ни утилитов каких-то, которые нужны для установки или компиляции.
832.64 837.20 "Анатолий Кулаков" То есть, все, что вы привыкли видеть в нормальной операционной системе, вот там этого нет.
837.20 839.24 "Анатолий Кулаков" И, соответственно, есть такой подход.
839.24 842.36 "Анатолий Кулаков" Он направлен прежде всего на то, чтобы уменьшить размер дистрибутива.
842.36 847.52 "Анатолий Кулаков" Это касается не только того, чтобы быстрее грузить в память или быстрее качать по сети.
847.52 848.52 "Анатолий Кулаков" Это все мелочи.
848.52 852.28 "Анатолий Кулаков" Самое главное преимущество в том, что уменьшается опять же площадь атаки.
852.28 859.52 "Анатолий Кулаков" Чем меньше утилит, оболочек, пакетов вы используете, тем меньше каких-то security issues, каких-то проблем.
859.52 868.48 "Анатолий Кулаков" В общем, чем меньше движущихся частей остается у вас в контейнере, и тем реже нужно будет их обновлять, и тем стабильнее они будут работать.
868.48 874.44 "Анатолий Кулаков" Вот эти два направления, в принципе, Microsoft захотела прорабатывать в будущем релизе.
874.44 879.88 "Анатолий Кулаков" Еще и интересная утилитка .NET Upgrade Assistant.
879.88 890.08 "Анатолий Кулаков" В общем, в нее тоже будет очень много вкладываться для того, чтобы переход между разными версиями .NET, в том числе переход на седьмую версию .NET, был как можно более мягким.
890.08 893.88 "Анатолий Кулаков" Это утилита командной строки .NET Global Tools.
893.88 896.12 "Анатолий Кулаков" Вы прямо можете его заинсталлировать к себе в проект.
896.12 909.00 "Анатолий Кулаков" И у нее есть куча анализаторов, и в том числе код фиксеров, которая помогает вам автоматически переделать какие-то куски, которые уже устарели и в новом языке уже не рекомендуется.
909.00 911.00 "Анатолий Кулаков" В новом фреймворке не рекомендуется.
911.00 915.92 "Анатолий Кулаков" Он автоматически может переделать, переформатировать вам код и оставить его компилируем.
915.92 926.20 "Анатолий Кулаков" Это вся прелесть как раз таки Рослина, анализаторов и автоматических фиксеров вылезает здесь, что мы здесь автоматически можем фиксить наши Legacy приложения, переводить их на новые версии.
926.20 930.16 "Анатолий Кулаков" И интересно, что эта утилита поддерживает различные типы приложений.
930.16 935.40 "Анатолий Кулаков" То есть она различает и WinForm, и .DF, и .ISP, и все вот эти штуки.
935.40 940.80 "Анатолий Кулаков" То есть она сама понимает, какую технику миграции применить к тому или иному приложению.
940.80 949.48 "Анатолий Кулаков" И из еще интересных нововведений было проаннотировано с помощью Nullable Annotation огромное число сборок в Microsoft Extension.
949.48 954.88 "Анатолий Кулаков" В частности там же Dependency Injection, Logging и так далее.
954.88 967.48 "Анатолий Кулаков" Вместе с .NET Framework, то есть уже называется просто .NET, вместе с .NET Preview 1, также вышли ISP NetCore, 7 Preview 1 и Entity Framework.
967.48 973.52 "Анатолий Кулаков" В ISP NetCore у нас небольшие изменения в Minimal API.
973.52 985.00 "Анатолий Кулаков" Теперь мы можем с помощью Minimal API upload-ить файлы и с помощью специальных типов iFromFile и iFromFileCollection.
985.00 993.72 "Анатолий Кулаков" У нас появилось Binding Body из HTTP Request в Stream, или даже можно в PipeReader сразу засунуть.
993.72 997.00 "Анатолий Кулаков" Для SignalAero появились Source Generators.
997.00 1009.68 "Анатолий Кулаков" Теперь мы можем сгенерить строго типизированного клиента, который может отсылать и принимать различные месседжи не с помощью всяких строк и объектов, а прям как положено, с помощью строких типов с проверкой на этапе компиляции.
1009.68 1012.36 "Анатолий Кулаков" Ну и соответственно с увеличением скорости работы.
1012.36 1013.36 "Анатолий Кулаков" Куда же без этого.
1013.36 1023.48 "Анатолий Кулаков" И самая главная фишка этого делиза это большой импрувмент в консоли утилитки .NET Watch.
1023.48 1026.24 "Анатолий Кулаков" Кроме всего остального там были добавлены эмоджи.
1026.24 1036.80 "Анатолий Кулаков" Теперь когда вы запускаете .NET Watch, он вам не только пишет логи и какие-то служебные информации, но и красивыми картиночками все это вам подсвечивает, подкрашивает.
1036.80 1039.36 "Анатолий Кулаков" Естественно, если ваш терминал это поддерживает.
1039.36 1041.36 "Игорь Лабутин" Звучит прям замечательно.
1041.36 1043.60 "Игорь Лабутин" Слушай, а про Entity Framework что-нибудь известно?
1043.60 1048.96 "Анатолий Кулаков" У Entity Framework в принципе никаких изменений, которые стоило упоминать нет.
1048.96 1059.44 "Анатолий Кулаков" То есть они там что-то променавливали, что-то прооптимизировали, что-то улучшили, что-то убыстрили, какие-то планы составили, но как всегда что-то у них не очень насыщенный анонс, поэтому в превью первом ничего интересного
1059.44 1061.44 "Игорь Лабутин" нет. Понятно.
1061.44 1062.44 "Игорь Лабутин" Ну ладно, пойдем посмотрим.
1062.44 1065.76 "Игорь Лабутин" Когда будут уже нормальные превьюшки, будем знать, что там происходит.
1065.76 1067.96 "Игорь Лабутин" Ладно, давай пойдем дальше.
1067.96 1074.76 "Игорь Лабутин" И дальше у нас интересная тема потихонечку начинает вырисовываться, что же у нас будет в C# 11.
1074.76 1085.60 "Игорь Лабутин" И уже сейчас в C# 11 поддержана такая штука, как проверка на NULL с помощью оператора два восклицательных знака по-английски, по-моему они его называют bang-bang.
1085.60 1089.08 "Анатолий Кулаков" Погоди, это уже в мастере или только обсуждается?
1089.08 1119.14 "Игорь Лабутин" Короче, это уже в мастере и более того, это, собственно, недавно в Твиттере промелькнуло и в GitHub, ну как промелькнуло, прокатилась большая волна обсуждения этой фичи, потому что мало того, что она в мастере, в репозитории Runtime Assorty они взяли и полностью, собственно, поменяли все проверочки на NULL на, собственно, использование этого оператора.
1119.14 1121.14 "Игорь Лабутин" То есть, для начала давайте про оператор.
1121.14 1122.14 "Игорь Лабутин" Что это такое?
1122.14 1149.10 "Игорь Лабутин" Если у вас есть стандартная конструкция, которую вы обычно всегда проверяли на NULL, if argument не равен null, throw new argument null exception или более модный последний вариант это argument.throwifnull можно было писать, и это лучше, потому что если у вас функция не отсутствует в ней выброса и исключения, она с большими шансами, например, заинлайнится или еще что-нибудь оптимизатор с ней сможет сделать.
1149.10 1167.98 "Игорь Лабутин" Вот, то теперь вам достаточно прямо в описании метода написать вот там, где у вас, например, есть аргумент какой-то, string arg, достаточно написать string arg два восклицательных знака, и у вас автоматически к операторам будет добавлена проверка вот такая if argument не равен null, throw new argument null exception, ну и имя аргумента, естественно.
1167.98 1174.14 "Игорь Лабутин" Не путаться с одним восклицательным знаком, который обозначает nullability, точнее не используется для nullability.
1174.14 1176.62 "Игорь Лабутин" Так вот, собственно, эту фичу запилили.
1176.62 1183.90 "Игорь Лабутин" А эту фичу, на самом деле, они запилили давным-давно, но в 10 C# она не вошла, а вошла только в 11.
1183.90 1184.90 "Игорь Лабутин" Почему?
1184.90 1185.90 "Игорь Лабутин" Сейчас объясню.
1185.90 1186.90 "Игорь Лабутин" Что произошло в результате?
1186.90 1194.38 "Игорь Лабутин" То есть, Steven Taub, на самом деле, я так понимаю, что они сделали какой-то код фикс, ну или quick fix, который позволяет делать более-менее автоматически.
1194.38 1197.54 "Игорь Лабутин" Ну, то есть, открыл solution, применил фикс, и он как бы все сам заменил.
1197.54 1216.26 "Игорь Лабутин" Вот, в общем, они это сделали на runtime репозитории, на стандартной библиотеке, вот это все, и прямо там покатилось в сам этот pull request от Стивена, и отдельную ish'ю создали под названием "как вы, так сказать, предполагаете использовать этот оператор в репозитории C# blank".
1216.26 1234.90 "Игорь Лабутин" И, значит, пошло огромное число реакций, лайков, комментариев, там трады в GitHub по 500-700 сообщений, где народ говорил "блин, а почему не атрибутами, почему вот там не nullable reference type использовать для этого, вообще все это очень confusing, почему не специальное ключевое слово".
1234.90 1236.70 "Игорь Лабутин" Короче, начали накидывать кучу идей.
1236.70 1249.62 "Игорь Лабутин" В итоге, во-первых, майкрософтовцы провели, они периодически проводят, мы, по-моему, обсуждали уже, называется .net community day, по-моему, куда пришел Джерри Парсонс, и где-то полчаса объяснял, почему они сделали именно так.
1249.62 1250.62 "Игорь Лабутин" Вот.
1250.62 1256.82 "Игорь Лабутин" Потом, чтобы не пересматривать этот большой видосик и всем не кидать на него ссылку, он в одном из стритов GitHub написал прямо развернутый пост.
1256.82 1258.66 "Игорь Лабутин" Вот по нему сейчас немножко пробежимся.
1258.66 1271.18 "Игорь Лабутин" Во-первых, он сказал, что вот более простая валидация аргументов на null, а это, наверное, одна из самых частых валидаций в C#, ну, может быть, с ней соперничает только какой-нибудь там string null or empty для стрингов.
1271.18 1274.10 "Игорь Лабутин" Но в целом, это близкая штука.
1274.10 1275.34 "Игорь Лабутин" Просили ее очень давно.
1275.34 1277.90 "Игорь Лабутин" Ну, просили ее вообще, она задумывалась очень давно.
1277.90 1282.62 "Игорь Лабутин" Как выяснилось, она более-менее активно разрабатывается уже три года.
1282.62 1286.22 "Игорь Лабутин" Над ней работал там один фуллтайм товарищ и двое интернов.
1286.22 1293.34 "Игорь Лабутин" Ну, вот такой коматочка, они это три года по-разному пилили, процентипировали, смотрели, обсуждали, предлагали, обменяли и так далее.
1293.34 1296.10 "Анатолий Кулаков" Ну, казалось бы, слушай, в реализации же здесь...
1296.10 1297.62 "Анатолий Кулаков" Реализация абсолютно элементарная.
1297.62 1303.54 "Анатолий Кулаков" Тут немножко рослин порапачить, чтобы тебе это распознавало двадцатилетний знак и три строчки кода генерации.
1303.54 1304.54 "Анатолий Кулаков" Все правильно.
1304.54 1305.54 "Анатолий Кулаков" Где же здесь полтора года-то?
1305.54 1320.66 "Игорь Лабутин" Потому что, во-первых, хочется сделать синтакс достаточно понятным, во-вторых, хочется его сделать достаточно совместимым, потому что есть план расширить эту функциональность не только на аргументы функций, но и на вообще произвольные выражения.
1320.66 1335.62 "Игорь Лабутин" То есть, вместо того, чтобы там внутри тела где-нибудь писать там, что-нибудь там посчитали, вызвали функцию, там if эта функция вернула null, то там сделали что-нибудь, можно будет написать в конце вызова этой функции два восклицательных знака и, например, оно само проверит на null.
1335.62 1350.30 "Игорь Лабутин" Ну, то есть, это пока еще не задизайнено, ну, в смысле, что это будет обсуждаться, но если читать все прототипы, так сказать, все обсуждения, там было много всяких разных разговоров и обсуждений, почему вот так нельзя, этак нельзя, еще вот так тоже нельзя.
1350.30 1352.18 "Анатолий Кулаков" То есть, лютый ад только начинается.
1352.18 1353.18 "Игорь Лабутин" Да.
1353.18 1371.22 "Игорь Лабутин" Так вот, несмотря на то, что это все было сделано в C# 10, они специально не стали включать его в релиз C# 10, потому что если включишь, все, дальше дороги нет обратной, а подождали выхода, ну, релиза 10 C# и включили как можно раньше в 11 C#, чтобы собрать комьюнити фидбэк как раз-таки.
1371.22 1373.90 "Игорь Лабутин" Ну, мне кажется, свои цели они добились, фидбэк собрали.
1373.90 1374.90 "Игорь Лабутин" Вот.
1374.90 1389.54 "Игорь Лабутин" И они вообще говоря, как говорит Джаред, используют вот такие изменения в репозитории рентайма, в общем-то, для своих собственных целей, это некоторое то, что называется докфудинг, то есть попробовать фичу компилятора на своем же коде.
1389.54 1397.18 "Игорь Лабутин" Репозитория рентайма достаточно большой, на нем можно словить много багов и интересных поведений, возможно, каких-то косяков кода генерации, возможно, еще чего-то.
1397.18 1407.14 "Игорь Лабутин" То есть, это, в принципе, фича даже если она применена к рентайму репозитория в мастере, абсолютно не означает, что она войдет в релиз.
1407.14 1409.42 "Анатолий Кулаков" Неплохо, а как они потом, раз применят ее?
1409.42 1412.06 "Игорь Лабутин" Да, они ее потом раз применят, они к этому готовы.
1412.06 1416.10 "Игорь Лабутин" А иначе им не проверить, какой нормальный большой кодовый баг в реальной жизни.
1416.10 1420.82 "Анатолий Кулаков" Да, мне кажется, это такая большая фича, что это надо было так осторожно и тщательно проверять.
1420.82 1425.18 "Анатолий Кулаков" Скажи, в чем фидбэк в итоге вылился?
1425.18 1427.58 "Анатолий Кулаков" Нравится людям, не нравится?
1427.58 1433.70 "Игорь Лабутин" Людям, как идея, людям вроде как нравится, но людям совершенно не нравится синтекс из двух последовательных знаков.
1433.70 1451.50 "Игорь Лабутин" И Джаред как раз говорит, мы рассматривали огромное количество разных синтексов, атрибуты, ключевые слова, опция компилятора была даже, вариант, сейчас про нее пробежимся, но в итоге было два финальных варианта, либо имя аргумента и один восклицательный знак, либо имя аргумента и два восклицательных знака.
1451.50 1467.90 "Игорь Лабутин" А проблема с одним восклицательным знаком в том, что это уже существующий оператор в языке, его можно применить к любому выражению, как известно, и он тогда скажет, ну типа, простить того, что оно nullable и разрешит присвоить в non-nullable, применную.
1467.90 1473.54 "Игорь Лабутин" Поэтому два восклицательных знака были выбраны именно из расчета, что потом можно будет использовать их дальше где-нибудь.
1473.54 1476.66 "Игорь Лабутин" Почему не сделали это частью nullable reference type?
1476.66 1492.42 "Игорь Лабутин" Очень популярный аргумент от тех, кто писал комментарии про то, что ну блин, у вас уже есть nullable reference type, ну как бы сделайте так, что если у вас в вопросе написан в аргументах, ну как бы проверить на null, если не написано, не проверяем на null, ну как бы, блин, что такого-то?
1492.42 1493.42 "Игорь Лабутин" Вот.
1493.42 1502.22 "Игорь Лабутин" И здесь они сказали, что Джаред говорит, что на самом деле nullable reference type пока, к сожалению, еще не настолько применяется в реальной жизни.
1502.22 1507.18 "Игорь Лабутин" То есть очень маленький процент кастомеров хоть как-то их использует в достаточном количестве.
1507.18 1517.86 "Игорь Лабутин" И поэтому такой фичи, если они сделают ее на основе nullable reference type, смогут пользоваться не очень много народу, а им важно, чтобы каждая фича могла, в принципе, быть достаточно широко применена.
1517.86 1519.22 "Игорь Лабутин" Поэтому сделали независимой.
1519.22 1524.46 "Анатолий Кулаков" Ну или наоборот, эта фича толкнет использование nullable reference type еще больше в массы.
1524.46 1529.14 "Игорь Лабутин" Ну ты сам сказал, что Microsoft Extensions типа логинга проанонтировали только сейчас.
1529.14 1535.90 "Анатолий Кулаков" Ну зато весь фреймворк был проанонтирован еще в прошлой версии и, в принципе, этого уже достаточно для того, чтобы весь фреймворк заработал на этой штуке.
1535.90 1538.58 "Игорь Лабутин" Много ли народу на шестом этом самом дотнете?
1538.58 1541.78 "Игорь Лабутин" А эта штука не требует шестого дотнета, надо заметить.
1541.78 1545.46 "Игорь Лабутин" Она требует нового SDK, но ты можешь таргетить хотя бы любой старый дотнет.
1545.46 1551.78 "Анатолий Кулаков" Да-да, понятно, это так, но опять же, ты же nullable reference type, тоже не обязательно тебе шестой дотнет для этого.
1551.78 1552.78 "Анатолий Кулаков" Все правильно.
1552.78 1553.78 "Игорь Лабутин" Тебе нужен просто последний язык и все.
1553.78 1567.78 "Игорь Лабутин" Ну, в общем, я так понимаю, что Microsoft пытается как-то балансировать между, скажем так, пушением новых фич и все-таки каким-то, ну, максимальной поддержкой старого там SDK фреймворков, не знаю чего, вот, и делать штуки независимо.
1567.78 1574.70 "Игорь Лабутин" А еще была опция вообще сделать глобальный свитч, который будет просто, если поставили свитч, то добавляет аргумент null-чеки.
1574.70 1590.30 "Игорь Лабутин" Но это такая фиговая опция, потому что слишком много лишних null-чеков будет и главное, что читаемость кода меняется, потому что поведение может поменяться в зависимости от того, как вы файл компилируете, будет там аргумент null или не будет.
1590.30 1594.74 "Игорь Лабутин" И в довесок ко всему этому написал твит Сергей Тепляков.
1594.74 1603.70 "Игорь Лабутин" Твит на самом деле довольно полезный, потому что, несмотря на то, что там синтаксис, не синтаксис, к синтаксису, я думаю, что все более-менее привыкнут.
1603.70 1606.14 "Игорь Лабутин" Хотя посмотрим, может быть, Microsoft что-то будет менять.
1606.14 1614.18 "Игорь Лабутин" Но на самом деле он, фича как таковая, она чуть более хитрая, чем просто вставка argument null exception.
1614.18 1617.90 "Игорь Лабутин" Во-первых, она работает с in и ref параметрами.
1617.90 1620.42 "Игорь Лабутин" Тут вроде сюрприза нет, что такого.
1620.42 1622.38 "Игорь Лабутин" Она работает с анонимными методами.
1622.38 1631.70 "Игорь Лабутин" То есть, если вы пишете лямбдочку, вы в лямбдочке аргумент можете обозначить двумя восклицательными знаками, когда вы пишете там x стрелочка и что-нибудь с x делаете.
1631.70 1635.18 "Игорь Лабутин" У вас в лямбде автоматически проверится, что x не null.
1635.18 1637.90 "Игорь Лабутин" Оно прикольно работает с конструкторами.
1637.90 1645.10 "Игорь Лабутин" Как вы знаете, вы в C# можете вызвать из одного конструктора другой с помощью ключевого слова this, да, и дальше в скобочках аргумента передать.
1645.10 1647.54 "Игорь Лабутин" Ну, конструктор chaining, то что называется.
1647.54 1652.30 "Игорь Лабутин" Либо вы должны вызвать или можете вызвать конструктора базового класса через base.
1652.30 1662.78 "Игорь Лабутин" Так вот, если вы делаете вызов через base, ну там, двоеточие base, да, и все, то вы не можете вставить проверку на null перед вызовом base.
1662.78 1668.46 "Игорь Лабутин" И вам приходится городить там огород, если вам вдруг может прийти что-нибудь nullable в ваш конструктор.
1668.46 1674.54 "Игорь Лабутин" А если вы это аннотируете сейчас вот этим новым оператором, то проверка будет вставлена до вызова base конструктор.
1674.54 1678.50 "Игорь Лабутин" И у вас будет нормальный аргумент null вместо какой-нибудь null reference из base.
1678.50 1680.02 "Анатолий Кулаков" Ну, вот это тоже мило, да.
1680.02 1681.66 "Игорь Лабутин" То есть это полезно.
1681.66 1700.74 "Игорь Лабутин" И еще клевая штука, что если у вас есть async метод или у вас есть итератор блок, который метод с yield, да, то если вы помните, как работают async методы, что если вы внутри async метода напишите if что-то там throw null, да, то он вызовется только при начале итерирования.
1700.74 1709.58 "Игорь Лабутин" То есть когда таску начнут consume, ну в итераторах, соответственно, когда начнут consume, а и numberable, в async когда у таска что-то это самое сделают.
1709.58 1719.90 "Игорь Лабутин" И был такой паттерн, что нужно async метод разбивать на два, да, в первом методе, который просто он проверяет аргументы, а потом уже вызывает нормальное async поведение.
1719.90 1721.98 "Игорь Лабутин" В итератор блоках, кстати, такое точно было.
1721.98 1726.18 "Игорь Лабутин" Вот этот новый оператор, два восксветленных знака, он будет делать все правильно.
1726.18 1732.58 "Игорь Лабутин" То есть он выбросит вам null именно в момент вызова async метода без дожидания, грубо говоря, вейда.
1732.58 1733.94 "Игорь Лабутин" И пока там все выполнится.
1733.94 1735.50 "Игорь Лабутин" Вот, начнет выполняться.
1735.50 1738.86 "Игорь Лабутин" Так что, короче, оператор интересный.
1738.86 1746.74 "Игорь Лабутин" Это интересный кейс, действительно непонятно, что будет, если, например, сейчас Microsoft решит, что типа, ну окей, ладно, что-то как-то оператор неудачный.
1746.74 1752.38 "Игорь Лабутин" В смысле, два воскветленных знака выбраны неудачно, давайте что-нибудь поменяем, как это будет в рентайме делаться.
1752.38 1755.58 "Игорь Лабутин" Но, видимо, Stephen Taub все терпит и быстренько все поменяет еще разок.
1755.58 1756.94 "Анатолий Кулаков" Ну там же с помощью quickfix.
1756.94 1759.46 "Игорь Лабутин" Ну да, будут делать одноразовый quickfix.
1759.70 1769.46 "Анатолий Кулаков" Мне кажется, аргументы Теплякова, они как раз-таки доказывают то, что реализация идей, она полезная, она нужная, она хорошая и доказывает то, что говорит комьюнити.
1769.46 1771.46 "Анатолий Кулаков" Вот, синтексис хреновый.
1771.46 1776.90 "Игорь Лабутин" Ну да, и кстати, показывать, может быть, немножко отвечает на твой вопрос, почему так долго дизайнить.
1776.90 1781.66 "Игорь Лабутин" Это не просто три строчки генерации, вот там куча корнеркейсов, лямбды, конструкторы и так далее.
1781.66 1782.66 "Игорь Лабутин" Куда вставить вызов?
1782.66 1785.06 "Игорь Лабутин" До, после, во время и так далее.
1785.06 1787.06 "Игорь Лабутин" То есть там, видимо, не все так просто.
1787.06 1788.54 "Игорь Лабутин" C# сложен, стал.
1788.54 1789.54 "Анатолий Кулаков" Да, действительно такая.
1789.54 1795.70 "Анатолий Кулаков" Просто вставить проверку на чек аргументов на null и вылазит куча подводных камней.
1795.70 1796.70 "Анатолий Кулаков" Так и есть.
1796.70 1800.42 "Анатолий Кулаков" Ну что ж, я на прошлой неделе еще видел замечательную статейку от Джона Скита.
1800.42 1805.06 "Анатолий Кулаков" Неужели он нам что-то интересное про таймзоны начал снова поведать?
1805.06 1806.06 "Игорь Лабутин" Ну как да.
1806.06 1809.02 "Игорь Лабутин" Джон Скит, конечно же, нам поведает про таймзоны.
1809.02 1812.46 "Игорь Лабутин" И это связано с переходом на дотланд 6.
1812.46 1813.46 "Игорь Лабутин" История такая.
1813.46 1816.30 "Игорь Лабутин" В дотланд 6 появились два новых типа.
1816.30 1817.66 "Игорь Лабутин" Мы про них много говорили.
1817.66 1819.54 "Игорь Лабутин" Date only и time only.
1819.54 1840.42 "Игорь Лабутин" И нода time, это библиотечка, которую пишет Джон Скит для поддержки, соответственно, правильной поддержки таймзоны и вообще работы со временем и календарями, нужно было ее обновить для того, чтобы поддержать эти типы и сделать конверсии, конвертирование из таких же похожих типов нода time, это local date и local time, в эти типы дотландные.
1840.42 1846.18 "Игорь Лабутин" И для этого первое, что нужно сделать, обновить SDK, взять дотланд 6 SDK.
1846.18 1861.42 "Игорь Лабутин" Это было сделано, там вылезли некоторое количество nullable reference type warnings, но как бы нормально скомпилировалось, но упал CI на юнит тестах на линуксе и все падения были в тестах вокруг класса BCL DateTimeZone.
1861.42 1869.66 "Игорь Лабутин" Это, соответственно, класс, который отвечает за работу с таймзонами, когда он работает на dotnet base class library.
1869.66 1874.94 "Игорь Лабутин" Там в принципе на дотланд можно писать разные провайдеры, но вот один из провайдеров очевидно это сам dotnet.
1874.94 1881.86 "Игорь Лабутин" И тут Джон Скитт подумал, что надо бы что-нибудь сделать, ну в смысле надо что-то фиксить и начал писать статью.
1881.86 1893.42 "Игорь Лабутин" То есть эта статья, она про то, как Джон Скитт, это на самом деле один из видов статей, которые он очень любит писать, у него их таких несколько, как вообще отлаживать код.
1893.42 1898.62 "Игорь Лабутин" Вот у вас что-то упало, вы понятия не имеете, почему вы всего лишь обновили SDK, а что-то упало.
1898.62 1907.98 "Игорь Лабутин" Вот как жить дальше, как вообще действовать, в какие действия предпринимать и в какие тупики заходить в том числе, чтобы понять, что происходило.
1907.98 1919.90 "Игорь Лабутин" Там статья такая довольно длинная, он заранее предупреждает вначале, что типа я ее пишу по мере расследования, и вполне может быть, что часть статьи везет в тупик, не удивляйтесь, но в конце куда-то выведет, надеюсь.
1919.90 1920.90 "Игорь Лабутин" Ну и куда-то вывело.
1920.90 1939.10 "Игорь Лабутин" В общем, я не буду всю пересказывать статью, интересный кусочек, он на самом деле есть, то есть сама конечно последовательность действий тоже интересна, посмотрите, как мыслят люди, когда что-то отлаживают, как изолируют проблему, как повторяют ее, какие делают выводы, как ищут причины.
1939.10 1969.50 "Игорь Лабутин" Но в итоге, конечно, нашлась строчка в .NET 6 Release Notes, где было сказано, что ну мы поменяли TimeZoneInfoClass, и там так было написано забавно, что два других, так сказать, минорных улучшения были сделаны в области TimeZoneAdjustmentRules, это называется, то есть то, как мы вот аджастим время в летнее и не летнее время, сделано это было только на Non-Windows Operating System, вспомним, что тесты упали на Linux.
1969.50 1981.22 "Игорь Лабутин" Их самая отличная фраза, что это никак не влияет на внешнее поведение, кроме того, что код становится чуть более корректным в некоторых очень граничных случаях.
1981.22 1984.14 "Игорь Лабутин" Но в итоге попали тесты, но внешнее поведение не меняется.
1984.14 1990.34 "Игорь Лабутин" Поэтому, когда вы читаете Release Notes и там написано "They don't affect external behavior", вы перепроверите.
1990.34 1996.82 "Анатолий Кулаков" Я думаю, да, у Джона Скита есть много тестов на DayTime, которые будут падать при любых минорных, не ломающих
1996.82 2004.30 "Игорь Лабутин" изменениях. Да, он написал, что вот это минорное не ломающее изменение сломало ему 461 тест из 19 тысяч.
2004.30 2006.70 "Анатолий Кулаков" Вот, вот, я про это и говорю.
2006.70 2012.86 "Анатолий Кулаков" Кстати, очень хороший автор для того, чтобы действительно понять, как дебажить и понять, как надо и сколько надо писать тестов.
2012.86 2020.10 "Игорь Лабутин" Да, а еще, кстати, тоже важный вывод из статьи, проверяйте и дебаг версию, и релиз версию, потому что в дебаг версии падает в 4 раза больше тестов.
2020.10 2023.34 "Анатолий Кулаков" Это хорошо, было бы хуже, если бы наоборот.
2023.34 2031.78 "Игорь Лабутин" Ну, на CI-то гоняются релизные тесты часто, потому что там собирается релизная версия, а в дебаге гоняются другие тесты, и они поймали еще кое-что.
2031.78 2038.58 "Анатолий Кулаков" Да, это интересная идея, что до сих пор не факт, какие тесты нужно гонять на CI в релизе или в дебаге.
2038.58 2042.50 "Анатолий Кулаков" По-хорошему, конечно, оба варианта, но не каждый может себе это позволить.
2042.50 2048.74 "Игорь Лабутин" Это точно, то есть некоторые настолько долгие, но опять же, это нужно собрать две версии и еще сами тесты гонять.
2048.74 2050.22 "Игорь Лабутин" Может быть долго.
2050.22 2057.54 "Игорь Лабутин" Вот такие дела, так что бегите изучать очередную новинку от Джона Скита про то, что не так у нас со временем.
2057.54 2059.10 "Игорь Лабутин" Похоже, с ним у нас все всегда не так.
2059.10 2071.22 "Анатолий Кулаков" Ну что ж, мы с самого ноября, как зарелизился новый C#, уже много проговорили и про него, и про его синтаксис, и уже сегодня упоминали уже про следующие какие-то новомодные воскресательные знаки.
2071.22 2082.90 "Анатолий Кулаков" Но у нас же есть еще один отличный шикарный язык, называется он F#, и между прочим, рядом с C# зарелизился F# 6, и вот о нем сегодня хотелось бы и поговорить.
2082.90 2091.18 "Анатолий Кулаков" Прежде всего, 6 F# является частью .NET 6, никаких дополнительных вещей вам ставить не надо, это все входит в SDK.
2091.18 2096.86 "Анатолий Кулаков" Основная его цель этого релиза была сделать его как можно более простым, удобным и быстрым.
2096.86 2109.46 "Анатолий Кулаков" И это применительно ко всему, и к синтаксису языка, к дизайну языка самого, к библиотекам, к тулингу вокруг него и во всем-во всем, куда дотрагивается этот язык.
2109.46 2113.66 "Анатолий Кулаков" Он также включен по умолчанию в Visual Studio 2022.
2113.66 2123.22 "Анатолий Кулаков" Так как вы, наверное, знаете, мы с Игорем не очень большие эксперты в F#, и поэтому решили пригласить к нам гостя, который поможет нам разобраться в этом замечательном релизе.
2123.22 2125.74 "Анатолий Кулаков" И поприветствуйте в студию нас Влад.
2125.74 2131.54 "Анатолий Кулаков" Он работает в Microsoft и трудится непосредственно над самим F# и тулингом вокруг него.
2131.54 2132.54 "Анатолий Кулаков" Привет, Влад.
2132.54 2133.54 "Анатолий Кулаков" Всем привет.
2133.54 2137.22 "Анатолий Кулаков" Вроде бы ты нам поможешь более глубоко разобраться в релизе шестого F#?
2137.22 2145.50 "Анатолий Кулаков" И прежде всего расскажи, какие три фичи из нового релиза ты бы выделил как самые значительные именно для тебя и почему?
2145.50 2153.82 "Влад" Наверное, самая большая фича, которую все ждали это появление тасок, встроенных в F# Core и в компилятор.
2153.82 2155.02 "Влад" Почему она значимая?
2155.02 2163.94 "Влад" Ну, во-первых, мы теперь с коробками умеем работать с дотнетными тасками без вот этой вот всей кухни, которая раньше была через Async.
2163.94 2175.74 "Влад" И почему, наверное, эта фича одна из самых интересных, это она использует новую возможность, так скажем, компилятора из стандартной либы, которая называется Resumable State Machines.
2175.74 2185.34 "Влад" Она позволяет пользователям, точнее, даже авторам библиотек, она позволяет писать код, в частности, код Computational Expressions, как Resumable State Machine.
2185.34 2199.82 "Влад" То есть позволяет избегать аллокаций ненужных, позволяет код упростить именно с точки зрения кода генерации, хотя на самом деле, когда ты пишешь саму Computational Expressions, это может поначалу показаться немножко запутанным.
2199.82 2205.50 "Влад" У нас есть отличное видео, которое мы записывали с Доном Саймом, которое объясняет, как все работает.
2205.50 2207.62 "Влад" Я могу пошарить ссылку.
2207.62 2215.14 "Влад" Вторая, наверное, фича, которая мне очень нравится, и я ее использую очень часто, это Type-Directed Convergence.
2215.14 2217.62 "Влад" Это немного упрощает несколько вещей.
2217.62 2224.70 "Влад" То есть, во-первых, мы умеем теперь конвертировать типы, делать так называемые safe конвертации типов.
2224.70 2235.50 "Влад" То есть, например, когда у тебя функция принимает long, а у тебя есть int, теперь тебе не нужно ее значение конвертировать в long, а ты можешь передать int, компилятор все сделает за тебя.
2235.50 2246.34 "Влад" Это помогает в том числе, кстати, в тасках и в асинках, когда, например, у тебя есть task unit, а нужен не-generic task, автоматически это сконвертим.
2246.34 2249.50 "Влад" И, в принципе, правила работают как?
2249.50 2256.46 "Влад" То есть, у нас есть некий set well-known вещей, которые мы можем конвертить, как я сказал, например, int long.
2256.46 2263.62 "Влад" Мы можем конвертировать такие типы друг в друга с помощью Open Placid.
2263.62 2268.86 "Влад" Мне очень интересно посмотреть, как авторы библиотек это начнут использовать.
2268.86 2280.46 "Влад" И, соответственно, у нас есть еще один RFC, который сейчас in progress, который у нас будет позволять нам делать sRTP-констренты на extension-методы.
2280.46 2287.42 "Влад" И вот эти две фичи вместе, они могут очень интересные use cases дать нам.
2287.42 2304.26 "Влад" И третья фича, которая мне, наверное, интереснее, чем большинству пользователей, и она очень маленькая, это мы сделали синтекс из индексеров в F# немножко проще.
2304.26 2310.46 "Влад" То есть раньше в F# в пятом нужно было писать точка квадратной скобки для индексера.
2310.46 2317.18 "Влад" Это пережиток, ну, не пережиток, а это нотация, которая пришла из Acamla и подобных языков.
2317.18 2319.90 "Влад" Это немного было confusing для пользователей.
2319.90 2324.26 "Влад" Я поясню, почему мне эта фича очень нравится.
2324.26 2334.66 "Влад" Она была основополагающей в теме, так скажем, или в будущем F#.
2334.66 2342.34 "Влад" Потому что одна из вещей, на которых мы пытаемся сконцентрироваться сейчас и в будущем, это своем Simple F#.
2342.34 2344.02 "Влад" Мы пытаемся сделать язык проще.
2344.02 2347.94 "Влад" В первую очередь проще для людей, которые новые для языка.
2347.94 2362.50 "Влад" И проще я не имею в виду то, что мы хотим какие-то фичи убрать или какие-то фичи задеприкейтить, а проще то, что мы хотим компилятор сделать умнее, и чтобы он помогал пользователям писать на языке.
2362.50 2368.90 "Влад" То есть в том числе мы очень плотно сейчас занимаемся улучшением диагностинга компилятора.
2368.90 2380.18 "Влад" Мы пытаемся какие-то фичи, которые не очень понятны пользователям, которые пришли из других языков, мы пытаемся как-то их спрятать, что ли, и дать альтернативу.
2380.18 2404.98 "Влад" Вот индексер — это одна из таких альтернатив, потому что пользователи приходят с Python, пользователи приходят с C#, с других языков, и они пишут индексер, а им компилятор в ответ говорит, что это невалидный синтаксис, невозможно применить функцию, потому что он думает, что вот эти вот аргументы в квадратных скобочках — это аргументы функции, и то, что слева — это сама функция.
2404.98 2413.86 "Анатолий Кулаков" Да, я во многих статьях сталкиваюсь, что в принципе в каждом обзаде почти рассказывают, как F# стал проще, как его хотят сделать проще, и как он ориентирован на новых людей.
2413.86 2418.46 "Анатолий Кулаков" Приятно, что сообщества заботятся о таких недалеких новеньких людях.
2418.46 2429.78 "Анатолий Кулаков" Скажи, вот по Acamla, у меня из анонса сложилось такое впечатление, что прям сильно избавляются от Legacy Acamla, там какой-нибудь prefix dictionary, по-моему, тоже убрали, ну, то есть такие тоже акаламовские вещи.
2429.78 2440.18 "Анатолий Кулаков" Это как-нибудь связано с тем, что F# уходит от парадигмы Acamla, от его основных идей, или просто действительно Legacy вещи, которые не особо сейчас нужны?
2440.18 2453.90 "Влад" Я бы сказал второе, потому что мы, естественно, по причинам обратной совместимости, мы не можем взять все фичи Acamla и задеприкейтить их или удалить, да?
2453.90 2480.98 "Влад" Но F# с самого начала, почти с самого начала, у него была такая штука, как light syntax, и это вот то, что мы сейчас видим во всех экзамплах, во всех документациях, во всех примерах, это вот облегченный синтексис, который тебе не заставляет писать, например, class and, когда ты объявляешь тип, он не заставляет писать in-кейворд, когда ты пишешь биндинги и так далее.
2480.98 2487.18 "Влад" В принципе, большинство проектов, которые мы видим, они не используют старый синтексис.
2487.18 2507.10 "Влад" И старый синтексис, это как бы поддержка его, означает поддержка его в лексере, поддержка его в парсере, поддержка его там, грубо говоря, нам нужно будет поддерживать много старых тестов, писать тесты со старым синтексисом, когда мы вводим какую-то новую лексическую или синтаксическую фичу.
2507.10 2510.10 "Влад" Это как бы, можно очень много всего сломать.
2510.10 2517.42 "Влад" Ну и, соответственно, синтексис ML и Acamla, в частности, он более вербозный.
2517.42 2525.34 "Влад" Все-таки хочется простого синтексиса, но при этом мы не забираем фичи, не забираем фичи компилятора, не забираем фичи языка.
2525.34 2526.10 "Анатолий Кулаков" Отлично.
2526.10 2528.62 "Анатолий Кулаков" А еще про резину у StateMachines.
2528.62 2533.86 "Анатолий Кулаков" Насколько я понимаю, что TASCII – это как раз ее самое первое применение, довольно новая штука.
2533.86 2536.94 "Анатолий Кулаков" А какие еще можно на ней делать вещи в будущем?
2536.94 2538.82 "Анатолий Кулаков" Есть ли какие-нибудь уже идеи?
2538.82 2543.62 "Влад" В целом, как бы TASCII – это первая имплементация.
2543.62 2548.38 "Влад" Мы поймали некоторое количество багов на ней, уже пофиксили.
2548.38 2551.98 "Влад" В целом, можно писать такие вещи, как рутины на ней.
2551.98 2556.74 "Влад" Можно писать вещи, в принципе, их можно использовать где угодно.
2556.74 2568.70 "Влад" То есть, условно говоря, где есть большая локация, например, каллбеков, в режиме был StateMachines, это починит, и с ними будет проще писать код, который аллоцирует меньше.
2568.70 2575.14 "Влад" Я, честно, пока что не видел от комьюнити много примеров, где бы использовались режимы StateMachines.
2575.14 2583.06 "Влад" Я знаю, что автор Apply работает над переписыванием некоторых computational expressions на StateMachines.
2583.06 2588.26 "Влад" В целом, любой код можно писать с использованием StateMachines.
2588.26 2590.98 "Влад" Другой вопрос, будет ли от этого какой-то профит.
2590.98 2593.54 "Влад" Это уже зависит от use case.
2593.54 2594.54 "Анатолий Кулаков" Ну да, понятно.
2594.54 2596.34 "Анатолий Кулаков" Уточни еще по URU Async.
2596.34 2602.66 "Анатолий Кулаков" Насколько я понимаю, что раньше до шестого F# там был специальный Async блок, который позволял вам работать как-то с асинхронными тасками.
2602.66 2611.50 "Анатолий Кулаков" Но он был плохо совместим с основным C#, потому что там нужно было дополнительные методы вызывать.
2611.50 2613.50 "Анатолий Кулаков" Почему было так изначально сделано?
2613.50 2618.70 "Анатолий Кулаков" Это было потому, что Async придумали раньше, чем в C#, или по каким-то другим причинам.
2618.70 2621.46 "Анатолий Кулаков" Почему его так реализовали многословно и неудобно?
2621.46 2625.14 "Влад" Сам в себе Async, я бы не сказал, что он сильно многословный.
2625.14 2630.14 "Влад" Во-первых, это cold Async, то есть его нужно стартовать экспрессивно.
2630.14 2636.10 "Влад" Когда таск у тебя стартует сразу, только ты вызвал асинхронный метод, например.
2636.10 2643.58 "Влад" И он может потом, когда ты обращаешься к этому таску, у него может быть несколько стейтов, он все еще выполняется, он выполнился, есть результат и так далее.
2643.58 2647.42 "Влад" Async позволяет контролировать это самому.
2647.42 2654.26 "Влад" То есть ты создал Async, у тебя есть Async, который не запущен еще, его можно передавать, его можно композить со всем остальным и так далее.
2654.26 2660.54 "Влад" Я, если честно, не помню, раньше ли Async появился, чем таск, я думаю, скорее всего.
2660.54 2666.46 "Влад" Но, естественно, когда появились таски в C#, нам нужно было делать их совместимыми.
2666.46 2669.66 "Влад" В общем, совместимость получилась сделать многословно.
2669.66 2683.62 "Влад" То есть у нас до таска, который появился в F# 6, любая работа с .NET-ными тасками, это было то, что в Async-блоке ты вызываешь метод, который возвращает таску, и потом через Async-модуль ты говоришь ей "await task".
2683.62 2688.98 "Влад" Это было многословно, это было не очень по C#, это конфузило очень много людей.
2688.98 2698.74 "Влад" И поэтому были созданы такие либо как TaskBuilder, как Ply, и TaskBuilder, то он сам вдохновлялся, когда писал computation expression для таска.
2698.74 2711.46 "Влад" Сначала этот computation expression задумывался как один в один, условно говоря, копии этого TaskBuilder, чтобы из-за шарпного кода мы могли использовать таски нормально.
2711.46 2722.70 "Влад" То есть, грубо говоря, в TaskBlock, await их, условно говоря, let, кейворд, возвращать их, параллельно запускать и так далее.
2722.70 2744.70 "Влад" Проблема была в том, что это очень сильно по сравнению с C# портит долгу производительности, и поэтому было принято решение, что нам нужен какой-то механизм, который бы это все дело выполнял быстрее, который бы производительность тасков была бы сопоставима с тасками в C#.
2744.70 2752.02 "Влад" Дон написал механизм ResembleStateMachines, и таск — это первый computation expression, который позируется.
2752.02 2758.78 "Влад" Но если ответить на твой вопрос, то возвращаясь к твоему вопросу, я извиняюсь, что немножко в сторону ушел.
2758.78 2768.86 "Влад" В целом, async и task, хотя они решают во многих случаях похожие задачи, они разные в том плане, что один из них cold, один из них hot.
2768.86 2771.74 "Влад" И это, скорее, исторически так сложилось.
2771.74 2788.54 "Влад" То есть async был, я больше уверен, до task, и потом команда C# и .NET приняла решение сделать свою синхронную модель, которая была не совсем совместимой, нам вот пришлось, точнее, той команде, которая в то время работала, пришлось
2788.54 2805.70 "Анатолий Кулаков" делать какой-то слой совместимости. Да, вообще незавидная такая судьба была у F#, потому что он реально вводил какие-то новые концепции, которые C# потом тырил, и F# потом обратно приходилось вот ту совместимость соблюдать, которую как бы обратную, чтобы они более-менее были сопоставимы.
2805.70 2807.70 "Анатолий Кулаков" Так, пойдем дальше.
2807.70 2811.70 "Анатолий Кулаков" Я когда смотрю на функциональные языки, у меня прежде всего интересна такая тема, как зависимые типы.
2811.70 2818.98 "Анатолий Кулаков" И кажется, что вот это то мощное направление, куда наши строго типизированные языки должны дальше идти и развиваться.
2818.98 2821.66 "Анатолий Кулаков" Но почему-то у F# с анонсами ничего про это не слышно.
2821.66 2825.66 "Анатолий Кулаков" Планируется ли развитие этого направления, или знаешь ты что-нибудь про это?
2825.66 2835.42 "Влад" В целом, как бы система типов в F#, то есть есть там, грубо говоря, F#-вые типы, F#-вые компиляторы, есть у нас CLR, на котором все это исполняется.
2835.42 2843.98 "Влад" То есть, например, если мы говорим про такие фичи, как зависимые типы, у нас этого именно в планах, в бэклоге где-то нет.
2843.98 2852.22 "Влад" То есть мы наверняка об этом люди спрашивали, наверняка Don Simon, как дизайнер языка, отвечал.
2852.22 2860.34 "Влад" Проблема в том, что эта фича, зависимые типы, dependent types или refinement types, она очень нишевая.
2860.34 2866.66 "Влад" И это на самом деле будет непростая задача в компиляторе F# заимплементировать это.
2866.66 2870.66 "Влад" То есть, отвечая на твой вопрос, нет, пока не планируется.
2870.66 2874.66 "Влад" Причина для этого, эта нишевая вещь, она...
2874.66 2880.66 "Влад" Мы не уверены, насколько она даст профита по сравнению с другими вещами.
2880.66 2890.58 "Влад" То есть, например, у нас есть такие идеи, как extension everything, позволить тебе extension методы, операторы, property и так далее писать для любого типа.
2890.58 2902.18 "Влад" И в совокупности с ней есть условная фича, которая позволяет тебе писать F# вот эти constraints, sRTPs, для extension типов.
2902.18 2913.26 "Влад" И вот в совокупности эти две фичи, они, мне кажется, могут больше дать для прикладного такого программирования людям в F#, чем такая фича, как завтипы.
2913.26 2916.62 "Влад" Второй вопрос, это constraint, это C#.
2916.62 2926.26 "Влад" Потому что, грубо говоря, сейчас трейты или условные type-классы в F# заимплементировать не сильно сложно.
2926.26 2932.82 "Влад" Но, например, в то же самое время у нас нет поддержки со стороны CLR, и если F# в какой-то момент...
2932.82 2947.94 "Влад" Извиняюсь. Если C# в какой-то момент решат заимплементировать type-классы или как там у них есть пропоза на шейпы или roles, если они их заимплементят, нам потом придется вот эту вот совместимость поддерживать.
2947.94 2957.46 "Влад" То же самое с тасками. То есть это интересно, что ты ранее упомянул про то, что Roslyn имплементирует какие-то вещи, и они не всегда совместимы с F#.
2957.46 2974.38 "Влад" Одна из причин, почему мы как бы не делаем что-то, это то, что мы ждем, и когда это заимплементирует Roslyn, чтобы потом не писать вот этот вот лейер совместимости между двумя реализациями, если ты понимаешь, о чем я.
2974.38 2986.38 "Анатолий Кулаков" Да, смотри, но с другой стороны у меня раньше от F# складывалось такое впечатление, что это паровоз, который впереди планеты всей бежит, и какие-то новые фичи изобретают, которые мы увидим в C# только через 3-4 года.
2986.38 2994.38 "Анатолий Кулаков" А сейчас с каждым анонсом все меньше и меньше таких вещей, и язык становится не каким-то революционным, инновационным, а более прикладным. Тебя это не пугает?
2994.38 2996.38 "Анатолий Кулаков" Не смущает?
2996.38 3002.38 "Влад" Вроде ли нет, потому что я считаю, что по фичам в F# все хорошо.
3002.38 3014.38 "Влад" У нас теперь, условно говоря, есть TASC, у нас есть Async, у нас есть штуки, как те же Resumable State Machines, которые авторам библиотек предоставляют некоторые возможности.
3014.38 3018.38 "Влад" Ну и в принципе миллион других фичей.
3018.38 3030.38 "Влад" Мы могли бы улучшить очень многое в tooling, в том числе в F# Compiler Service, который используется в Raider, который используется в INID, который используется в той же студии.
3030.38 3036.38 "Влад" И на самом деле tooling, по моему мнению, очень важен для языка.
3036.38 3040.38 "Влад" Особенно с учетом того, что мы хотим сфокусироваться на Simple F#.
3040.38 3050.38 "Влад" И как бы ретерируя твой вопрос, я не думаю, что... Во-первых, я не думаю, что мы там закончили с фичами вообще.
3050.38 3066.38 "Влад" Естественно, есть такие вещи, как Availability, есть такие вещи, как условная поддержка фичей из C#, например, там INID Property или там будущие фичи, такие как Required Property, которые сейчас обсуждаются.
3066.38 3070.38 "Влад" Естественно, там мы со временем будем их поддерживать.
3070.38 3094.38 "Влад" Какие-то прям принципиально новые фичи, не знаю, наверное, тоже будут со временем, но я считаю, что очень важно сконцентрироваться на таких вещах, как Simple F# и на Tooling и просто делать улучшения для того же Compiler Services, для IntelliSense в студии, в INID и в Raider, которые будут работать лучше.
3094.38 3098.38 "Влад" Которые будут работать всегда, которые будут работать всегда хорошо.
3098.38 3100.38 "Влад" Я не уверен, ответил ли я на твой вопрос.
3100.38 3102.38 "Анатолий Кулаков" Да, да, я в принципе понял.
3102.38 3112.38 "Анатолий Кулаков" А если, в общем-то, говорить о планах на ближайшее, на долгосрочное будущее, вот кроме того, что ты сказал, Simple F#, Tooling, может, что-то еще ты не упомянул?
3112.38 3120.38 "Влад" Из фичей, наверное, хотелось бы закончить, наконец-то, с поддержкой Nullable, в частности в антеропе с C#.
3120.38 3126.38 "Влад" Simple F# я упоминал, Tooling я упоминал.
3126.38 3146.38 "Влад" Наверное, в целом улучшение компилятора в плане улучшения Compiler Messages, то есть мы смотрим сейчас на такие компиляторы языки, как Elm или Rust, как они помогают писать код. Наверное, это можно отнести в Simple F#, но в целом, наверное, вот это основные темы на обозримое ближайшее будущее.
3146.38 3170.38 "Влад" Ну и естественно, мы как мейнтейнеры хотим, чтобы пользователи компилятора, которым это интересно, чтобы они контрибьютили в компилятор фичи, багфиксы, какие-то исправления, которые бы они хотели видеть и так далее, но для этого нам нужно надо привести инфраструктуру, чтобы взять, сбилдить и начать дебажить компилятор было просто.
3170.38 3188.38 "Влад" То есть это такая ongoing тема, в которой мы постоянно пытаемся что-то делать. Например, мы пытаемся перенести старые тесты с перлового рана на XUnit, потому что их просто будет удобнее дебажить и удобнее ранить из райдера или студии.
3188.38 3194.38 "Анатолий Кулаков" Понятно. Слушай, я в принципе тоже жду и хочу, чтобы F# в нашем мире становилось больше и больше.
3194.38 3202.38 "Анатолий Кулаков" И как ты считаешь вообще, есть ли какие-то еще сферы, в которых F# сейчас реально недооценен, и в будущем он там может хорошо выстрелить?
3202.38 3228.38 "Влад" Я считаю, что, например, один из проектов, в которых используем F# достаточно много, это .NET Interactive. Наверняка слышал про него. Это по сути ноутбуки, это extension для Visual Studio и некий условный брекенд, сервер, который в общем-то реализует такую вещь, как полиглот кернала или полиглот языки, language servers.
3228.38 3234.38 "Влад" По сути это ноутбук, который очень extensible, для него можно писать плагины.
3234.38 3260.38 "Влад" Например, у меня есть плагин, который реализует IL-компилятор, то есть ты можешь там без коди в ноутбуке писать IL, шарить переменные между разными частями ноутбука. Я считаю, что в интерактивных сценариях F# используется не так много, как хотелось бы, потому что я считаю, что это отличный инструмент. У нас есть такие провайдеры, в которых мы планируем, хотим сделать ряд улучшений.
3260.38 3272.38 "Влад" Есть вся инфраструктура, вся экосистема .NET, то есть ты любую библиотеку можешь взять, подгрузить ее в сам интерактив и использовать, например, для Data Explorer.
3272.38 3288.38 "Влад" Но, естественно, оно не идеальное, и хочется сделать ряд улучшений, в частности, с вещами, как сам интерактив, .NET FSI или Ripple, сейчас, например, у него очень медленный стартап, не очень подходит для скриптинга.
3288.38 3316.38 "Влад" Я считаю, что почему мы, наверное, хотим немного больше сфокусироваться на Simple F#, это то, что люди, которые сейчас занимаются каким-то exploring даты условным или data science, я думаю, что F# с его синтаксисом, с его условной экосистемой, вместе с C#, с инструментами, как интерактив, как райдер, я думаю, что он хорошо подходит для этого.
3316.38 3324.38 "Влад" И мы хотим, чтобы людям было проще писать на этом, особенно если они знакомы с такими вещами, как Python или как там Julia.
3324.38 3342.38 "Анатолий Кулаков" Да, насколько я знаю, что у дата-сантистов и прочих вот этих людей, у них как раз ноутбуки — это основной рабочий инструмент, это как IDE для них, они там все в них делают, сохраняют, запускают, пробуют, обмениваются, шарят и так далее, поэтому да, я думаю, что как раз F# здесь может хорошо себя показать.
3342.38 3358.38 "Анатолий Кулаков" Влад, благодарю тебя за интересные развернутые ответы, всегда приятно услышать информацию из первых уст, как это все там двигается, планируется, живет и чувствуется вот на самом деле непосредственно в том ядре, где разрабатывается.
3358.38 3362.38 "Анатолий Кулаков" В общем, большое тебе спасибо, что зашел и пока.
3362.38 3364.38 "Анатолий Кулаков" Да, тебе спасибо, пока-пока.
3364.38 3394.38 "Анатолий Кулаков" Ну что ж, а я бы хотел упомянуть еще интересное нововведение, которое Влад не затронул, как мы уже сегодня услышали, у нас есть улучшения в тасках, они стали более быстрыми и более правильными, они легче дебажатся и лучше интегрируются в C# на версии. У нас появились implicit conversions, которые помогают меньше писать явных преобразований и которые интегрируются с op implicit из C#.
3394.38 3404.38 "Анатолий Кулаков" У нас появился новый синтаксис индексера и старый синтаксис, который через точку и квадратные скобки признан устаревшим.
3404.38 3406.38 "Анатолий Кулаков" Это то, что мы уже обсудили.
3406.38 3420.38 "Анатолий Кулаков" И что у нас есть еще интересного? Во-первых, у нас struct representation for active patterns появился, то есть в F# есть active patterns, которые позволяют вам делать удобные расширения для pattern matching.
3420.38 3438.38 "Анатолий Кулаков" И теперь вы можете просто-напросто навесить attribute value option на этот active pattern и он будет сгенерирован с помощью value типов, то есть даст меньше аллокаций в вашем приложении, если активно используются active patterns, то очень хорошо вам поможет.
3438.38 3442.38 "Анатолий Кулаков" Теперь мы можем обновлять immutable коллекции.
3442.38 3450.38 "Анатолий Кулаков" Появились новые операторы first_add, remove_add и update_add, которые работают по принципу copy and update.
3450.38 3458.38 "Анатолий Кулаков" То есть теперь immutable коллекции тоже можно с помощью пайплайна очень гибко и хорошо модифицировать, при этом оставляя их immutable.
3458.38 3462.38 "Анатолий Кулаков" Еще в F# есть такая интересная штука, которая называется units of measure.
3462.38 3472.38 "Анатолий Кулаков" Это возможность вам любому простому, например, числу рядом прибавить какой-то тег и уже число с этим тегом будет отличаться от всех других чисел.
3472.38 3482.38 "Анатолий Кулаков" Например, таким образом вы можете никогда не спутать вес, рост и какой-нибудь размер, потому что у каждого из этих понятий будут свои собственные теги.
3482.38 3488.38 "Анатолий Кулаков" Но раньше эти теги можно было налепить не ко всем номерик типам в предыдущих версиях.
3488.38 3492.38 "Анатолий Кулаков" Теперь же это исправили и добавили очень много других номериков типов.
3492.38 3506.38 "Анатолий Кулаков" Улучшился дебаггинг пайплайна в F#. Теперь можно на каждом шаге поставить точку останова, включить дебаггер, посмотреть переменные и так далее.
3506.38 3514.38 "Анатолий Кулаков" Теперь пайплайн идет не как одна большая операция, а разделен по каждому вызову, что в принципе у нас в F# давно есть и это очень удобно.
3514.38 3518.38 "Анатолий Кулаков" У нас это применяется часто на всяких цепочках линку преобразований.
3518.38 3526.38 "Анатолий Кулаков" Конечно же улучшили перформанс и скалабилити, как в самом компиляторе, так и в интеграции с IDE.
3526.38 3534.38 "Анатолий Кулаков" Больше анализов, но самая интересная импровизация, которая меня поразила - это улучшили время закрытия солюшена.
3534.38 3540.38 "Анатолий Кулаков" В определенных кейсах сократили время закрытия с 16 секунд до 1 секунды.
3540.38 3550.38 "Анатолий Кулаков" К сожалению, я не нашел тот pull request, чтобы понять, что там такое делалось. 16 секунд, но приложения теперь солюшены начнут у вас закрываться в вашей IDE намного быстрее на F#.
3550.38 3584.38 "Анатолий Кулаков" Еще одна интересная штука - это взаимодействие с C# проектами. То есть раньше для того, чтобы подтянуть в F# проект типы из C# проекта, их нужно было сохранить на диск, скомпилировать, и все это, как вы понимаете, занимало очень много времени. Теперь F# умеет непосредственно без сохранения и без компиляции партий C# проекта вытаскивать из них какую-то полезную мета-информацию. И что, собственно, позволило сделать такую интересную штуку, как включить анализ для тех проектов, которые не компилируются. То есть частично вытаскивать из них мета-информацию.
3584.38 3588.38 "Анатолий Кулаков" Улучшения коснулись также F# скриптинга.
3588.38 3592.38 "Анатолий Кулаков" Теперь он учитывает global.json файл.
3592.38 3598.38 "Анатолий Кулаков" Global.json - это, в принципе, файл, который в C# и в .NET тоже давно учитывается.
3598.38 3612.38 "Анатолий Кулаков" Он кладется непосредственно в ртовую директорию, и в нем можно будет прописать версию SDK, ту версию, тулинг, который будет использоваться для работы с этим проектом.
3612.38 3628.38 "Анатолий Кулаков" Например, банально откомпилировать или даже проанализировать, или даже запустить. То есть в этом файле вы можете сказать, что этот проект будет компилироваться только с помощью шестой версии .NET. Если ее нет, то значит у вас будет ошибка во время вызова .NET Build или .NET Publish.
3628.38 3634.38 "Анатолий Кулаков" Точно такие же ограничения теперь есть и у F#.
3634.38 3652.38 "Анатолий Кулаков" Весь скриптинг, который будет выполняться, он будет на этот файлик смотреть. Если вы там обозначите какую-то минимальную необходимую версию языка или фреймворка, это все будет учитываться. В System Text JSON добавили нативную поддержку F# типов, начиная с .NET 6. System Text JSON поддерживает F#.
3652.38 3658.38 "Анатолий Кулаков" Единственное ограничение, что пока не поддерживается User Defined Discrimination Unions.
3658.38 3684.38 "Анатолий Кулаков" Но в будущем обещают это упущение устранить. И в общем-то весь F#, он базируется на .NET 6, поэтому не забываем, что у него появились Source Build, Profile Guide Optimization, Dynamic PGO, CrossGen 2, HTTP 3 и прочие те вещи, которые мы с вами уже много раз обсуждали, которые достались F# только потому, что он основан на .NET 6.
3684.38 3688.38 "Анатолий Кулаков" Вот такие новости у нас из параллельной функциональной вселенной.
3688.38 3696.38 "Анатолий Кулаков" Надеюсь, что среди наших слушателей есть F#-исты, и они порадуются за активное развитие языка.
3696.38 3708.38 "Игорь Лабутин" Да, согласен, я особо не пользуюсь F#, я немножко на нем пытался что-то писать такое для себя, но не более того. Поэтому спасибо Владу, который нам много полезного и интересного рассказал.
3708.38 3728.38 "Игорь Лабутин" Пойдем дальше. Мы поговорили про .NET, мы поговорили про 7 .NET, но как же без Visual Studio? Visual Studio тоже обновилась на днях, и у нас теперь есть несколько анонсов на эту тему. Во-первых, вышла Visual Studio 2022.17.1 Это стабильная версия Visual Studio, и там появилось несколько нововведений.
3728.38 3764.38 "Игорь Лабутин" Это более быстрый поиск по файлам, и он происходит с помощью ну, собственно, незамысловатой штуки. Параллельно со студией запускается специальный процесс, который называется servicehub.indexingservice, который запускается в момент открытия солюшена или открытия папочки, если вы просто фолдер какой-нибудь открываете. И он аккуратненько индексирует файлики в вашем солюшене, причем не только C#, но вообще все, которые из солюшена ссылаются, и может таким образом ускорять поиск. Вы можете отключить эту штуку, если пойдете в настройки Tools, Options, Environment, Preview, Features, и соответственно, выключите индексинг.
3764.38 3766.38 "Игорь Лабутин" Тогда будет все по-старому.
3766.38 3770.38 "Игорь Лабутин" Мы уже обсуждали фичу про сохранение в бэкграунде. Тут ничего новенького не завезли.
3770.38 3782.38 "Игорь Лабутин" Если вы студию отправляете в idle-состояние, то есть она становится бэкграунд-процессом, вы куда-нибудь переключились по альт-табу, то, соответственно, ваша работа будет сохранена.
3782.38 3796.38 "Игорь Лабутин" Больше улучшений в ките, тоже мы их немножко обсуждали, видимо, в каких-то превьюшках или еще где-то, сравнение бранчей, поддержка Detached Head, и еще добавилась такая, наверное, кому-то полезная фича про солюшен-фильтры.
3796.38 3820.38 "Игорь Лабутин" Сами солюшен-фильтры существуют давно, и это просто возможность загрузить кусочек вашего солюшена, например, для того, чтобы работать с какой-то частью проекта. Но проблема в том, что у вас периодически проект живет, меняется, могут добавляться какие-то новые зависимости к проектам, новые cross-references, и ваш солюшен-фильтр возможно уже не загружает того необходимого под множество проектов, которые нужно для работы.
3820.38 3830.38 "Игорь Лабутин" Вот теперь есть фича под названием "загрузи, пожалуйста, все, что не хватает, для того, чтобы все зависимости текущих загруженных проектов были удовлетворены".
3830.38 3852.38 "Игорь Лабутин" То есть вы что-то загрузили, но если кто-то где-то добавил зависимость новую в проект, а в ваш солюшен-фильтр она еще не попала, то вот эта фича позволит вам ее автоматически догрузить. Это прям, мне кажется, приятно. А помимо 17.1, которая стабильная, вышла 17.2 Preview 1. Это то, что вам нужно для 7-го .NET. Там появились новые C# 11 рефакторинги.
3852.38 3860.38 "Игорь Лабутин" Конкретно сейчас в анонсе написано только про Rostering Literals, но возможно еще какие-то есть, надо посмотреть по GitHub.
3860.38 3878.38 "Игорь Лабутин" И добавили новых улучшений в ките. Теперь можно в Stage добавлять по чанкам или даже по строчкам. Вот. Что должно улучшить ваш experience. Причем там прям очень прикольно. То есть по умолчанию эта фича включена.
3878.38 3884.38 "Игорь Лабутин" Ее можно выключить, но так же через переведенную настройки. Но в целом она работает по дефолту.
3884.38 3898.38 "Игорь Лабутин" Плюс у вас теперь в левой границе, там где номера строк, под цветом показано, что с вашими строчками сделано с точки зрения цвета. То есть зелененьким будет выделяться строчки, которые вы модифицировали и добавили.
3898.38 3902.38 "Игорь Лабутин" Зелененьким не заполнено, добавленные, но не сохраненные.
3902.38 3908.38 "Игорь Лабутин" Соответственно таким синеньким модифицированные и красным делит.
3908.38 3910.38 "Игорь Лабутин" То есть прям, чтобы тут что-то было, но поделительно.
3910.38 3914.38 "Игорь Лабутин" То есть по сути, некоторый такой визуальный аналог гид статуса.
3914.38 3926.38 "Игорь Лабутин" Все это можно менять, цвета там, все это конечно настраивать. И если вы на такой вот handle ткнете, то прямо в этом месте вам открывается такой inline div внутри вашего редактора кода.
3926.38 3932.38 "Игорь Лабутин" Так раздвигаются строчки кода и внутри появляются маленькие две панельки дифа, которые показывают, что на самом деле в этом месте вы поменяли.
3932.38 3936.38 "Игорь Лабутин" С точки зрения гида. Можете прямо здесь посмотреть, что же было поменено.
3936.38 3946.38 "Анатолий Кулаков" Звучит очень интересно, прямо аж хочется попробовать. Я часто пользуюсь такими чанками добавления изменений в гид. И интересно потестить, как это будет
3946.38 3952.38 "Игорь Лабутин" выглядеть. И вот как раз в этом div view вы можете сказать, что вот этот change мне пожалуйста за стейджи.
3952.38 3958.38 "Игорь Лабутин" И соответственно оно будет за стейджи. И после этого эти за стейджиные ченчи можно закоммитить.
3958.38 3964.38 "Игорь Лабутин" Прям нормально. И они нормально будут коммититься. Короче, про гид посмотрите.
3964.38 3968.38 "Игорь Лабутин" Действительно студия как-то очень хорошо движется в сторону.
3968.38 3976.38 "Игорь Лабутин" Пытается по крайней мере двигаться в сторону еще лучше работы с гидом. Так что, наверное, там все будет скоро совсем хорошо.
3976.38 3980.38 "Анатолий Кулаков" А я еще слышал, что вышла также Visual Studio под Mac.
3980.38 3984.38 "Анатолий Кулаков" Скажи, у нее фичи отличаются или в принципе точно такие же? Ну, с Mac
3984.38 3988.38 "Игорь Лабутин" вышел превью 6. Visual Studio 2022 for Mac превью 6.
3988.38 4000.38 "Игорь Лабутин" Там основной фокус это, конечно, скажем, как о них написано, это fixing top issues и reducing crashes. То есть там все еще что-то падает иногда, поэтому это надо фиксить.
4000.38 4008.38 "Игорь Лабутин" И они, конечно, основное усилие сейчас старатели на то, чтобы сделать ее нативное под Mac OS с точки зрения UI.
4008.38 4028.38 "Игорь Лабутин" И статус на момент превью 6 такой, что все основные фичи перенесены и остались только несколько не очень важных экранов в окошке настроек, которые еще пока не совсем нативно выглядят, но они тоже будут сделаны в следующем превью. А все остальное прям нативно-нативно.
4028.38 4052.38 "Игорь Лабутин" И они сейчас по сути фокусируются исключительно на fixing. Причем они говорят, что сначала мы полностью сделаем так, чтобы полностью без багов работал Xamarin Development, то есть разработка на Xamarin. И только когда мы закончим Xamarin, мы займемся вплотную на MAUI. Понятно, что это близкие технологии, но все-таки MAUI это немножко другое, и там есть свои тонкости.
4052.38 4056.38 "Игорь Лабутин" И поэтому сначала здесь фокус на Xamarin, потом на MAUI. Вот такие дела.
4056.38 4066.38 "Анатолий Кулаков" У меня есть два брата-акробата, которые в принципе релизятся всегда практически с одними и теми же изменениями и работают кроссплатформенно. Я, конечно же, говорю о ReSharper и Ryder.
4066.38 4072.38 "Анатолий Кулаков" И компания JetBrains представила Roadmap для версии 2022.1.
4072.38 4082.38 "Анатолий Кулаков" И уже даже есть Early Access Program, по которой вы можете скачать эту версию и попробовать посмотреть, что же там такого происходит. Ну, а мы вернемся ближе к Roadmap.
4082.38 4096.38 "Анатолий Кулаков" Прежде всего продолжается разработка фичи для Entity Framework, которая называется "Анализ N+1 проблемы". Она еще в интенсивной разработке.
4096.38 4124.38 "Анатолий Кулаков" И кратко напомню, что N+1 проблема - это когда вы сделаете какой-то реквест, запросите, например, получите в результате несколько сущностей, а потом для каждой из этой сущностей отдельно будете ходить в базу и дергать какой-то другой отдельный реквест и получать другие данные. То есть, соответственно, вы сходите в базу N+1 раз, где N - это число как раз-таки рекордов, которые вы достали первый раз.
4124.38 4140.38 "Анатолий Кулаков" Это очень распространенная ошибка, и она очень сильно снижает перформанс. Безусловно, это приводит к тому, что ваше приложение начинает работать медленно, просто со всех сторон, и с input-output, и с памятью, и вообще с логикой.
4140.38 4172.38 "Анатолий Кулаков" Его очень легко допустить, оно часто происходит неявно, особенно когда у вас включен lazy loading в Entity Framework, и бывает сложно детектировать. То, что у вас происходит такая штука, не всегда очевидно. И поэтому команда ReSharper вкладывается в этот анализ, и ReSharper в будущем будет анализировать использование LINQ, которое вызывается на DB-контексте, и попытается уловить именно такой шаблон использования.
4172.38 4178.38 "Анатолий Кулаков" И, соответственно, предупредить вас о том, что потенциально возможна такая проблема, может быть, вы хотите как-то исправить эту ситуацию.
4178.38 4190.38 "Анатолий Кулаков" Продолжается интеграция с Visual Studio 2022, это новая платформа для ReSharper, 64-разрядная, не для самого ReSharper, а именно для сочетания Visual Studio + ReSharper.
4190.38 4194.38 "Анатолий Кулаков" Поэтому там тоже находится очень много и мелких багов, и крупных багов.
4194.38 4200.38 "Анатолий Кулаков" В общем, стабильность улучшается, а баги фиксятся. Еще одно интересное нововведение.
4200.38 4206.38 "Анатолий Кулаков" РеШарперовцы добавили Google Translate прямо в Localization Manager.
4206.38 4228.38 "Анатолий Кулаков" То есть это менеджер, который занимается локализацией строк, и, безусловно, вам нужно по-хорошему там сажать какого-то переводчика, но если вдруг переводчик еще не пришел, или нужно сделать какой-то черный вариант, или если вы сам себе индивидуальный контрибьютор, то можно воспользоваться волшебной кнопочкой Google Translate, и он вам переведет те значения без учета контекста, который сможет.
4228.38 4232.38 "Анатолий Кулаков" Еще у нас в ReSharper ждет улучшение в Discovery Endpoints.
4232.38 4240.38 "Анатолий Кулаков" Мы уже разбирали эту фичу через Rider, и надеялись, что она все-таки придет к нам в ReSharper, и вот она приходит.
4240.38 4274.38 "Анатолий Кулаков" Я кратко напомню, что у нас есть множество способов объявить Endpoints в нашем ISP.NET Core приложении. Прежде всего, это навесить какие-то атрибутики, использовать новомодный Minimal API, использовать Convention Base Routing, и много-много еще каких способов. В общем, все это вместе собрать довольно сложно простому программисту, потому что они могут как-то сочетаться, исключать друг друга, разбросаны быть в разных местах, и в голове, если у вас нет какой-то принятой политики партии, как вести это в проекте, в голове все это удержать довольно сложно.
4274.38 4278.38 "Анатолий Кулаков" И вот ReSharper теперь умеет все эти места находить и помогать по ним навигироваться.
4278.38 4324.38 "Анатолий Кулаков" То есть, вы можете теперь посмотреть везде, где этот роутинг используется, какие его клиенты используют, какие его контроллеры используют, можете его переименовать, он переименуется во всех местах. То есть, роутинг начинает быть просто First Class Citizen в приложении. Если ребята пойдут дальше по переносу функциональности из райдера, а я надеюсь, они все-таки пойдут, то у нас появится отдельное окошко для работы с роутингами, которое позволит нам сделать такой свагер-подобный интерфейс, но не в момент запуска приложения, а в момент разработки, в момент работы над приложением, где мы можем по одному роутингу найти все точки, которые его вызывают или которые его используют, и удобно ими управлять.
4324.38 4334.38 "Анатолий Кулаков" Вот, хорошо, будем следить за фичей, фича отличная, а пока же в ReSharper вы можете только быстро навигироваться по этим роутингам, посмотрим, что будет дальше.
4334.38 4346.38 "Анатолий Кулаков" У райдера вышли большие улучшения в параллель стэки и в memory visibility, то есть можно добавить какие-то улучшения в дебаггинг.
4346.38 4360.38 "Анатолий Кулаков" Вот, из того, что меня зацепило, это некий докер фаст мод, то есть это режим компиляции докера. Как я уже упоминал, сегодня все мы идем в докер, все мы идем в контейнер, и компилировать приложение в докерах - это тоже модно.
4360.38 4376.38 "Анатолий Кулаков" И вот райдер решил заоптимизировать этот процесс. Он, во-первых, может билдить докер и докер пауз решения более оптимально, то есть уменьшая время самого билда. Что же он делает?
4376.38 4404.38 "Анатолий Кулаков" Если используется фаст мод, то райдер сначала создает бейс стадию докер контейнера, то есть это подготовка приложения самого, затем билдит приложение, но билдит он его не в контейнере, как написано в докер файле, а билдит на локальной машине, и это очень сильно уменьшает время билда, потому что билдится на вашей хостовой машине приложение намного быстрее, чем в самом докер контейнере.
4404.38 4428.38 "Анатолий Кулаков" После этого те артефакты, которые получились в результате билда, райдер маунтит в докер контейнер с помощью вольюма, и соответственно уже приложение, сама IDE, она может отлаживаться и запускать различные функции уже в контейнере, посредственно на тех артефактах, которые на самом деле сбилдила на хостовой системе.
4428.38 4436.38 "Анатолий Кулаков" Вот, этот трюк позволяет значительно улучшить скорость билда, и доступен он только для дебага.
4436.38 4446.38 "Анатолий Кулаков" В релизе все будет билдиться, так как написано в докер файле, без всяких изощрений, чтобы не допустить каких-либо там ошибок или еще чего-то.
4446.38 4450.38 "Анатолий Кулаков" В общем, а для дебага, в принципе, интересная штука, интересный такой хак.
4450.38 4458.38 "Анатолий Кулаков" И что касается ремоут-девелопмента, и в частности, код Vimeo, нет, все еще не завезли.
4458.38 4468.38 "Анатолий Кулаков" Код Vimeo в 2022.1 релизе пока не будет. Говорят, что работа над ним активно идет, все пилится, но пока еще нет.
4468.38 4470.38 "Игорь Лабутин" Поэтому ждем. Ну, хорошо.
4470.38 4474.38 "Игорь Лабутин" На самом деле много полезных, я так понимаю, что там действительно очень много всего пилится.
4474.38 4480.38 "Игорь Лабутин" И, ну, значит, пока на код Vimeo не хватает ресурсов или там что-то действительно принципиально сложное. Пойдем дальше.
4480.38 4508.38 "Игорь Лабутин" На самом деле, под конец у меня последняя новость. Обновилась библиотечка, но библиотечка довольно важная в мире .NET, и, может быть, вы не так часто ей пользуетесь, особенно если вы бакендер, но если вы как-то работаете с графикой, то вам точно нужно на нее посмотреть. Я говорю про ImageSharp. Значит, ее в версии 1.0 вышла, ну, года полтора, получается, назад, в августе 2020 года, и с тех пор довольно регулярно обновлялась.
4508.38 4516.38 "Игорь Лабутин" Последняя версия выходила полгода назад, в сентябре 2021 года, она была в версии 1.0.4, и тут после этого внезапно сразу в версии 2.0.
4516.38 4520.38 "Игорь Лабутин" То есть она существенно переделана, много чего переписано.
4520.38 4536.38 "Игорь Лабутин" Появилась поддержка формата .wp, появилась поддержка .tiff, появилась поддержка метадаты в формате .xmp. Гораздо быстрее стала работа с памятью, потому что используется какой-то правильный memory pooling с unmanaged memory облокатором.
4536.38 4548.38 "Игорь Лабутин" Два, наверное, наиболее популярных формата .png и .jpg ускорились существенно, и в общем и целом по всем бичмаркам получается, что эта библиотека примерно в 3 раза быстрее работает, чем стандартный system drawing.
4548.38 4554.38 "Игорь Лабутин" При этом в статье о ноти написано, что она является самой быстрой, если брать кроссплатформенный.
4554.38 4574.38 "Игорь Лабутин" То есть понятно, что какие-нибудь там, скея, наверное, побыстрее, но скея, она требует нативного C++ кода, а эта штука полностью .NET. Так что, если вы каким-то образом работаете с графикой, то, наверное, вы и сами знаете про ImageSharp, но тем не менее, обратите внимание, что версия 2.0, видимо, обещает какие-то прям хорошие улучшения и точно достойны рассмотрения.
4574.38 4606.38 "Анатолий Кулаков" И еще у компании Six Labors, которая как раз-таки и поддерживает ImageSharp, у нее есть несколько других, тоже интересных библиотек, связанных с графикой. Во-первых, это ImageSharp Drawing, это библиотека для работы с 2D-полигонами и для манипуляций всякими рисуночками. Вот. И есть еще ImageSharp Web, это как раз набор Middleware, который встраивается в ASP.NET приложение и помогает вам делать какие-то базовые манипуляции для вашего веб-приложения с картинками.
4606.38 4628.38 "Анатолий Кулаков" И также Fonts, которая работает с TrueType и WoW шрифтами и умеет их рендерить. В общем, если для вас очень важен такой какой-то узкий кейс с картинками, то посмотрите, библиотеки очень качественные давно существуют и доказали уже на многих бичмарках и тестах свою профпригодность.
4628.38 4634.38 "Игорь Лабутин" Да, ну а на этом мы, я думаю, будем сегодня завершаться. Выпуск получился довольно плотный по новостям.
4634.38 4636.38 "Игорь Лабутин" 20 лет Дотнету.
4636.38 4644.38 "Игорь Лабутин" При этом это все широко так скажем отмечалось, кучей статей, блогов, воспоминаний тех, кто это все делал и начинал Дотнет.
4644.38 4668.38 "Игорь Лабутин" Дальше мы прошлись по анонсам Дотнет Мауи превью 13, Дотнет 7 превью 1, новый оператор 2 восксветных знаков C# и как комьюнити на него реагирует и почему он был сделан именно таким, как подходить к вообще отладке проблем на примере статьи Джонал Скита про таймзон инфу в 6 Дотнете. Поговорили про F# 6 довольно обстоятельно.
4668.38 4682.38 "Игорь Лабутин" Посмотрели на обновление Visual Studio 2022 и стабильной версии 17.1 и нового нестабильного, или точнее превью версии 17.2. Узнали, что нового в 2022 Visual Studio 4 Mac превью 6.
4682.38 4690.38 "Игорь Лабутин" ReSharper Ryder тоже опубликовали свои родмапы на 22-й год очередной релиз и будем ждать всех этих новых фич.
4690.38 4694.38 "Игорь Лабутин" Ну и обновился имидж Sharp до версии 2.0, мажорное обновление.
4694.38 4696.38 "Игорь Лабутин" Важное и интересное. Да,
4696.38 4700.38 "Анатолий Кулаков" хороший разнообразный выпуск и на этом, наверное, все. До следующих встреч.
4700.38 4702.38 "Анатолий Кулаков" Всем пока. Всем пока.
4702.38 4704.38 "Анатолий Кулаков" Лайк, шари, репост, донаты.
4704.38 4708.38 "Анатолий Кулаков" Заходите, рассказывайте о нас вашим друзьям и коллегам.
4708.38 4710.38 "Анатолий Кулаков" До новых встреч. До новых встреч.
4710.38 4712.38 "Игорь Лабутин" До новых встреч.
4712.38 4718.50 None [музыка]
