0.00 9.48 "Анатолий Кулаков" Здравствуйте дорогие друзья, в эфире Radio.net выпуск номер 32.
9.48 12.36 "Анатолий Кулаков" С вами как всегда Анатолий Кулаков и Игорь Лабутин.
12.36 13.36 "Анатолий Кулаков" Всем привет.
13.36 21.32 "Анатолий Кулаков" И первым делом мы хотим поблагодарить всех тех, кто помогает нам на наших сайтах Патреона и Бусти и в частности Александр, Сергей и Владислав.
21.32 25.74 "Анатолий Кулаков" Большое спасибо друзья, мы вас всех очень сильно любим.
25.74 30.04 "Анатолий Кулаков" Ну что ж, эта неделя выдалась даже не неделя, даже больше недели мы с вами не виделись.
30.04 33.64 "Анатолий Кулаков" Какая-то скучная на новости и Микрософт как-то не сжет.
33.64 37.14 "Анатолий Кулаков" Команда .NET вроде сказала все, что она хотела последними большими релизами.
37.14 52.16 "Анатолий Кулаков" Поэтому, наверное, самое дело вернуться к Best Practice, посмотреть, что у нас есть интересного в мире перформанса, менеджмента, тулинга и прочего, что не настолько связано с микрософтовскими новостями, а творится вокруг нашего любимого .NET.
52.16 62.08 "Анатолий Кулаков" И первая тема, конечно же, это что-нибудь хардкорное из мира памяти Назара и Memory Antipatents.
62.08 70.08 "Игорь Лабутин" Да, Кристоф Назар — это известный докладчик, новый, что делает в области работы с памятью и вообще перформансов в C# и .NET.
70.08 90.32 "Игорь Лабутин" И он выпустил статью по аналогии со статьей Кевина Годса, которую мы разбирали несколько подкастов назад про лучшие практики подхода к тому, чтобы писать достаточно быстрый код, при этом не сильно заморачиваться, но в том плане, что не уходить там во всякие unsafe, спаны и так далее, а просто писать нормальный, аккуратный C#, который будет при этом быстро работать.
90.32 99.68 "Игорь Лабутин" И Кристоф, так же как и Кевин, написал статью, где больше сконцентрировался на том, что делать и как писать код, чтобы правильно работать с памятью.
99.68 110.60 "Игорь Лабутин" И с одной стороны, когда я прочитал эту статью, мне показалось, что это очевидно, но с другой стороны, решил, что все-таки было бы неплохо все эти очевидности напомнить, тем более несколько интересных идей там есть.
110.60 117.16 "Игорь Лабутин" Начинается статья про то, как правильно работать с памятью и называется она анти-pattern, соответственно, как не надо писать.
117.16 119.48 "Игорь Лабутин" Естественно, с волшебной штуки.
119.48 120.88 "Игорь Лабутин" Дотнет называем файнлайзер.
120.88 128.64 "Игорь Лабутин" Кого наверняка не возьми, всех спрашивали, что такое файнлайзер, когда он вызывается, имеете ли вы отношение к сборке мусора и так далее.
128.64 136.12 "Игорь Лабутин" И правильный ответ, конечно же, имеет, если вы читали книгу Конрада Кокоса, там есть отдельная большая глава на эту тему, если даже может быть не одна.
136.12 168.00 "Игорь Лабутин" Но в общем, суть в том, что если у класса есть файнлайзер, который начинается с тильдочки и с имени у класса, выглядит как деструктор, то это означает, что класс при инициализации будет, ссылка на этот класс будет добавлена в специальную очередь финализации, а когда сборщик мусора этот класс из памяти соберет, то эта ссылка переместится в так называемую fetchable очередь, где уже в следующем поколении, при сборке следующего поколения запустится файнлайзер, отдельный поток, где будут исполнены все файнлайзеры тех объектов, которые не пережили прошлую парковку.
168.00 173.24 "Игорь Лабутин" Подход прекрасный, подход отличный и все было бы хорошо, если бы не несколько "но".
173.24 174.24 "Игорь Лабутин" Но первое.
174.24 194.96 "Игорь Лабутин" Получается, что поскольку после первой сборки мусора ссылка перемещается в эту самую fetchable queue, то по сути у вас объект переживает следующее поколение, и вам нужна следующая сборка мусора, более старшего поколения, которое возможно произойдет позднее, или может вообще не произойти, если у вас все хорошо с памятью, и вам придется достаточно долго ждать, когда этот файнлайзер вызовется.
194.96 197.72 "Игорь Лабутин" А файнлайзеры пишутся не просто так, зачем нам их писать?
197.72 207.72 "Игорь Лабутин" Классическая рекомендация, когда нужно освобождать unmanaged ресурсы, какие-нибудь там, не знаю, сокеты, или вы там, если работаете напрямую с каким-то хендлами из винапи или еще откуда-нибудь.
207.72 210.84 "Игорь Лабутин" И понятно, что такие ресурсы хорошо бы освобождать чем быстрее, тем лучше.
210.84 220.16 "Игорь Лабутин" И если ждать, пока там файнлайзер вызовется следующей сборкой мусора, ну в общем-то это будет очень долго, дорого, и будет приводить к тому, что ресурсы будут заблокированы достаточно надолго.
220.16 221.76 "Игорь Лабутин" Поэтому совет тут один.
221.76 224.40 "Игорь Лабутин" Постарайтесь не писать файнлайзера, если можете.
224.40 237.40 "Игорь Лабутин" Если вам нужно каким-то образом поработать с нативными указателями, с нативными хендлами, то если вы у себя в коде видите intptr, попробуйте все-таки как-то сделать так, чтобы заменить его на такой класс, как safehandle.
237.40 246.00 "Игорь Лабутин" Стандартная библиотека предоставляет этот класс, он уже внутри себя включает все, что нужно, правильно написанные файнлайзеры, и дальше мы поговорим про Disposable Pattern.
246.00 260.76 "Игорь Лабутин" И если вы используете его, то в вашей классе уже не нужно будет реализовывать файнлайзер, и соответственно в вашей классе будет нормально собран garbage collector, и только маленький safehandle может остаться в памяти, но он небольшой и аккуратно все будет собран.
260.76 269.68 "Игорь Лабутин" Так что тут главный паттерн или анти-паттерн файнлайзеров нужно избегать, если можете, и 20 раз подумайте, прежде чем его писать.
269.68 272.88 "Игорь Лабутин" С файнлайзерами связан второй, конечно же, паттерн, это idisposable.
272.88 296.84 "Игорь Лабутин" И если вы погуглите про idisposable_ac#, скорее всего вам вылезет стандартная рекомендация, в том числе в микрософтской документации, как писать паттерн, где будет метод dispose принимать, и флажок boolean, который называется тоже dispose, и соответственно еще будет private poly, который называется disposed, и дальше вы эту функцию dispose boolean будете вызывать и из файнлайзера, и из dispose обычно.
296.84 306.44 "Игорь Лабутин" И все было бы хорошо, но слов dispose становится слишком много, это во-первых, а во-вторых, у вас опять появляется файнлайзер, если следовать документации микрософт напрямую, поэтому это не здорово.
306.44 309.52 "Игорь Лабутин" Кристофф предлагает немножко другой подход.
309.52 319.76 "Игорь Лабутин" Во-первых, паттерн idisposable желательно делать только тогда, когда у вас в вашем объекте есть ссылки на другие idisposable, либо если у вас есть по какой-то причине файнлайзер.
319.76 328.16 "Игорь Лабутин" Если у вас есть другие idisposable, то ваш класс должен стать idisposable, потому что нужно каким-то образом дать возможность очистить внутренние объекты.
328.16 337.52 "Игорь Лабутин" Если же у вас есть файнлайзер, то хорошим тоном считается реализовать idisposable тоже, чтобы дать возможность явно очистить ваш объект, ну точнее, явно сказать, что ваш объект больше нет.
337.52 343.48 "Игорь Лабутин" Совет от Кристоффа - старайтесь не использовать паттерн idisposable для всяческого логинга и прочих таких штук.
343.48 359.36 "Игорь Лабутин" Ну, очень часто встречается код, где, скажем так, idisposable за счет того, что он поддержан клевой конструкцией языка using, очень часто idisposable используется для обозначения каких-нибудь scope, если вы назначаете scope, он там в конце как-то освобождается.
359.36 368.76 "Игорь Лабутин" И вот если это используется для логинга и так далее, то я считаю, что это как бы abuse на самом деле интерфейса idisposable, который был создан чисто для очистки ресурсов.
368.76 371.28 "Игорь Лабутин" Для такого используйте, пожалуйста, что-нибудь другое.
371.28 381.48 "Анатолий Кулаков" Хотя, конечно, далеко, в принципе, ходить не нужно, потому что стандартный entity framework, да в принципе любые фреймворки, которые реализуют транзакции, обычно делают транзакции через idisposable.
381.48 392.84 "Игорь Лабутин" Это удобно, понятно, что это действительно все привыкли просто-напросто писать using, всем понятен этот паттерн, когда вы внутри блока using что-то делаете, понимаете, что она выйдет без using, у вас нечто разрушится.
392.84 396.96 "Игорь Лабутин" Ну, кстати, с транзакциями это еще более-менее, транзакция это вполне себе managed resource.
396.96 403.48 "Игорь Лабутин" Если вы ее явно не закомплитите, она будет висеть в базе, ну, пока драйвер у базы данных не решит, что она затаймаутится.
403.48 407.60 "Игорь Лабутин" Поэтому, ну, какая-то здравая мысль в том, чтобы использовать здесь idisposable есть.
407.60 416.56 "Игорь Лабутин" Но если вы используете idisposable чисто ради того, чтобы написать, что вы там, не знаю, начали scope операции, закончили scope операции, ну, вот крестом почему-то считают, что это недопустимо.
416.56 420.80 "Игорь Лабутин" Хотя я вполне разделяю точку зрения, сама себя в коде для такого вполне использую.
420.80 431.40 "Анатолий Кулаков" Опять же, может, если мы говорим именно про disposable pattern, когда ты обязан делать и финалайзер, и прям dispose флажками и прочие глупости, то да, это какой-то overhead до лоудинга.
431.40 441.92 "Анатолий Кулаков" Но если мы просто реализуем интерфейс idisposable напрямую, тупо имплементить один метод, который, в принципе, никак не влияет на garbage collector, как ты выше описал, то почему бы и нет?
441.92 442.92 "Игорь Лабутин" Ну, да.
442.92 461.32 "Игорь Лабутин" Поэтому, если вам нужно такое поведение, то есть не очистка unmanaged или unmanaged ресурсов, а просто обозначение scope и выполнение каких-то действий, когда вы выходите из определенного scope, то бишь из юзинга, то просто реализуйте idisposable с одним методом dispose, не надо никаких флажков dispose, не dispose и так далее.
461.32 473.40 "Игорь Лабутин" А если же вам нужна полноценная реализация idisposable, то есть с финалайзером и всем остальным, то крестом советуют выкинуть нафиг рекомендацию Microsoft из стандартной документации и использовать чуть-чуть другие названия.
473.40 484.76 "Игорь Лабутин" Вот тот метод, который принимает булевский флажок, назовите его как-то по-другому, там, cleanup, например, и параметр, называйте его dispose, называйте его там, from garbage collector, будет гораздо более понятно.
484.76 494.08 "Игорь Лабутин" Вы его все равно вызовете из финалайзера, соответственно, с параметром true, что он from garbage collector, и из обычного dispose с параметром false, то есть это не garbage collector.
494.08 504.12 "Игорь Лабутин" И внутри этого cleanup код будет выглядеть немножко более чище, чем когда у вас там одни сплошные dispose, встречаются слова и никаких других, слишком overused термин получается.
504.12 508.12 "Игорь Лабутин" Дальше в этом cleanup есть достаточно строгие правила того, что нужно сделать.
508.12 514.36 "Игорь Лабутин" Во-первых, в любом случае должны почистить нативные ресурсы, то есть любые unmanaged ресурсы, они должны чиститься в любом случае.
514.36 521.12 "Игорь Лабутин" Дальше, если вы были вызваны из garbage collector, то есть это значит, что вас вызывали из финалайзера, managed ресурсы трогать не надо.
521.12 524.44 "Игорь Лабутин" Если у вас есть еще какие-то disposable объекты в полях, не трогайте их.
524.44 529.20 "Игорь Лабутин" Вас вызвали из garbage collector, garbage collector уже давно с ними разобрался сам или разберется после.
529.20 542.96 "Игорь Лабутин" И в любом случае в самом конце вы вызываете волшебный метод gc.suppress_finalize, что способствует тому, что объект удаляется из очереди на финализацию, потому что вы и так его явно уже почистили.
542.96 546.96 "Игорь Лабутин" Это снижает нагрузку на garbage collector и объект померет быстрее, что хорошо.
546.96 559.84 "Анатолий Кулаков" Тут есть еще, не знаю, может быть, мнемоническое правило, которое можно добавить, что как запомнить, что во время вызова gc не нужно dispose-ить ваши дочерние какие-то элементы, ваши дочерние компоненты.
559.84 580.88 "Анатолий Кулаков" Дело в том, что в принципе порядок gc может быть абсолютно любым и в тот момент, когда вы чиститесь, когда у вас происходит cleanup из gc, все эти объекты уже могут быть почищены и любое обращение к ним, в том числе вызов у них метода dispose, уже может обратиться в какую-то неизвестную, неинциализированную память, ну то есть какой-нибудь null reference exception там легко можно будет получить.
580.88 605.52 "Игорь Лабутин" Да, при этом финалайзеры обладают замечательными эффектами, если вы хотите, можете почитать про такой термин как resurrection, то есть возрождение объектов, вы можете с финалайзера, поскольку вам доступна вся остальная программа, то есть какие-нибудь статики поля, вы можете вполне спокойно обратно оживить ваш объект, получив на него, ну присвоив какому-нибудь статику внешнему полю, ссылку на this, this все еще живет внутри финалайзера и таким образом объект оживить.
605.52 621.00 "Игорь Лабутин" Некоторые таким образом, я видел реализации каких-нибудь крышей, где как бы в крыше лежат объекты, как бы финализированные, если у нас все плохо с памятью, финалайзеры будут у вас часто и они будут очень быстро убиваться, но мы можем контролировать как быстро возрождаетесь по мере необходимости.
621.00 624.68 "Игорь Лабутин" Странный очень подход, но я такое видел, не делайте так.
624.68 625.68 "Игорь Лабутин" Пойдем дальше.
625.68 683.84 "Игорь Лабутин" Дальше на самом деле некоторое количество достаточно простых рекомендаций, это при создании списков, ну и других коллекций, мы про это говорили, старайтесь указывать объем хотя бы даже примерно, даже если вы ошибетесь в два раза, это все равно существенно улучшит вашу производительность по памяти и на самом деле по скорости работы тоже, потому что возможно реалокейтов будет не так много, гораздо меньше, чем если бы вы создали дефолтный лист, который по-моему бы дефолт 16 элементов, если я правильно помню, и дальше растет в два раза каждый раз, а словарик растет по, по-моему, по числам фибоначи, если я правильно помню, и естественно про стрелбилдер помните, и никаких плюс-равно и плюс для строчек, если это только не 2, 3, 4 по максимум строчек, потому что для 2, 3, 4 строчек компилятор генерит достаточно эффективный вызов одного меру до string_oncut и строчка собирается сразу, а вот если такие большие операции, или вы делаете их в цикле, тогда однозначно используйте string_builder, string_builder работает хорошо и он оптимизирован на то, что строка потихонечку растет.
683.84 689.16 "Анатолий Кулаков" Почему компилятор, раз он такой умный, не может сам решить, когда использовать string_oncut и когда string_builder?
689.16 696.28 "Игорь Лабутин" Не знаю, наверное, он еще недостаточно умный и команда считает, что это не та оптимизация, которой нужно делать.
696.28 718.04 "Анатолий Кулаков" Наверное, тут еще можно упомянуть, что если вы складываете константы, то есть тоже такое часто бывает, когда константы объявлены в виде ресурсов в другом файлике или еще что-то, и часто константы просто складывают через плюсик, чтобы собрать какую-нибудь оконечную строку, то это тоже компиляторам раскрывается в момент компиляции, здесь никакого string_builder не нужно, честно, используйте плюсик.
718.04 744.64 "Игорь Лабутин" Да, еще, если помните, пару подкастов назад мы обзывали новые возможности interpolated strings в 6.net и там, скорее всего, может быть получится немножко проще собирать такие строчки, очень часто их собирают, потому что их нужно собрать прямо совсем раз, только, если это можно вместить в одну interpolated строку, то вот с новыми фичами interpolated strong в 6.net, может быть, можно будет это сделать без string_builder, потому что string_builder будет использоваться там внутри под капотом сам.
744.64 751.72 "Игорь Лабутин" Ну, в каком-то смысле они двигаются в этом направлении, но немножко окольными, может быть, путями или наоборот через самые популярные места.
751.72 753.00 "Анатолий Кулаков" Но пока так не делайте.
753.00 759.84 "Игорь Лабутин" Пока не надо, если нет, то если вы на 6.net, попробуйте, расскажите, что получилось.
759.84 778.88 "Игорь Лабутин" Дальше по строчкам и вообще по объектам, но мне особенно нравится рекомендация про строчки, на которые я очень много раз натыкался, в смысле в своих production проектах, старайтесь, те строчки, которые довольно сложные генерятся, пиши ровно, советую заряды делать типа хорошо, не делайте плохо, кажется, на первый взгляд.
778.88 779.88 "Игорь Лабутин" На самом деле не так все просто.
779.88 784.44 "Игорь Лабутин" Вы не всегда знаете, когда строчка генерится тяжело, когда легко.
784.44 790.40 "Игорь Лабутин" Я всегда считал, ну, до некоторого времени, что вызвать там enum.getValues это довольно простая операция.
790.40 792.72 "Игорь Лабутин" Ну, что, компилятор же знает все значения заранее.
792.72 795.68 "Игорь Лабутин" В общем-то, в момент мопиляции все элементы enum известны.
795.68 799.12 "Игорь Лабутин" Казалось бы, почему enum.getValues это такая сложная операция?
799.12 810.12 "Игорь Лабутин" Оказывается, действительно сложная, но там flex под капотом почти никем не используется и так далее, поэтому с того момента, как я узнал, что это так, я теперь любой момент, когда я использую enum.getValues, он сразу кешируется в словарь.
810.12 820.56 "Игорь Лабутин" То есть я один раз строю соотношение enum значения и его строкового представления, точнее, названия этого enum значения и дальше только этот статистический словарь использую.
820.56 825.28 "Игорь Лабутин" Только в частности в рантайме enum у нас не меняются, это можно просто закешировать в статистическом словаре.
825.28 833.52 "Анатолий Кулаков" Погоди, погоди, так, а почему так сложно, почему так медленно, почему компилятор сам не делает такой подобный кешик в момент компиляции или даже может быть в рантайме?
833.52 834.52 "Игорь Лабутин" Почему?
834.52 837.88 "Игорь Лабутин" Ну, я не знаю, почему у нас структура сразу не сочетается с Reflection, знаешь?
837.88 843.56 "Анатолий Кулаков" Ну, допустим, первый раз это была ошибка и сейчас это исправить невозможно, но ведь getValue-то можно прооптимизировать.
843.56 844.56 None Они сейчас, по-моему, прооптимизируют.
844.56 853.12 "Игорь Лабутин" Мне что-то казалось, что, по-моему, опять же, в шестом году найти стало быстрее, в плане сделок, но, по-моему, там тоже не так, чтобы легко это сделать.
853.12 856.88 "Игорь Лабутин" Хотя, кстати, можно с каким-нибудь source-генератором, будет прочно.
856.88 867.36 "Игорь Лабутин" Ты видишь, что используется на каком-то типе enum.getValues, генери соответствующий helper-метод автоматический framework, который сразу будет подставлен в список строковых констант.
867.36 868.36 "Анатолий Кулаков" Да, действительно.
868.36 871.92 "Анатолий Кулаков" Но все-таки кажется, что правильнее, если бы компилятор сам этим занимался.
871.92 876.28 "Игорь Лабутин" Ну, опять же, видишь, .NET огромный, кажется, что на всем можно действительно просто не хватать сил.
876.28 882.72 "Игорь Лабутин" А особенно, когда у тебя есть возможность выбирать и фиксить что-то старое и прилип новые фичи, что ты выберешь, конечно, прилип новые фичи.
882.72 886.68 "Игорь Лабутин" Не умаляй достоинств команды .NET с точки зрения того, что старые тоже стараются фиксить.
886.68 893.76 "Игорь Лабутин" Но вот понятно, что .NET Core и .NET 5 были сделаны во многое в рамках того, чтобы дать возможность сделать быстрые новые фичи.
893.76 894.76 "Игорь Лабутин" Вот одних и делают.
894.76 896.36 "Игорь Лабутин" Борются во всеческих рейтингах.
896.36 897.36 "Игорь Лабутин" Поехали дальше.
897.36 898.36 "Игорь Лабутин" LinkU.
898.36 899.92 "Игорь Лабутин" Ну, в общем, с LinkU паттерн простой.
899.92 907.80 "Игорь Лабутин" Если у вас какой-то memory-critical кусок кода, постарайтесь не использовать там LinkU, а если делаете, понимайте, что вы делаете.
907.80 916.04 "Игорь Лабутин" Естественно, там у Кристофов в статье вы можете прочитать все детальные советы, но они в основном сводятся к тому, что не вызывайте count, если можно вызвать any.
916.04 918.56 "Игорь Лабутин" Ну, там типа .count=0, это не здорово.
918.56 921.64 "Игорь Лабутин" Это заенумерейтит всю коллекцию, ну и так далее.
921.64 924.88 "Игорь Лабутин" Избегайте всяких toList, toArray и всего такого прочего.
924.88 931.68 "Игорь Лабутин" И тут как раз-таки возникает обычная дискуссия, что же передавать в методы, что возвращать из методов.
931.68 935.68 "Игорь Лабутин" И тут надо смотреть на логику, на бизнес-логику, то, как ваши методы выполнены.
935.68 938.72 "Игорь Лабутин" Внутрь принимать максимально, с моей точки зрения, опять
938.72 953.88 None же, максимально обобщенную коллекцию, обратно возвращать максимально конкретную, возможно, обернутую в какой-то там передел, или что вам там нужно, интерфейс, чтобы стараться как-то показать контрактам, что это не изменяет коллекцию, а с другой стороны, вернули и вернули, пусть меняют, как хотят.
953.88 960.76 "Игорь Лабутин" Но вопрос холиварный, и тут я знаю много разных методов, подходов, в принципе, аргументы есть и за и против такого подхода.
960.76 969.00 "Игорь Лабутин" Но главное, если вы пишете на link.io и есть подозрение, что у вас действительно какой-то high load по памяти, пройдитесь профайлером, посмотрите, что где локейтится.
969.00 972.48 "Игорь Лабутин" Вы будете, скорее всего, удивлены, какое количество памяти у вас там локейтится.
972.48 975.48 "Игорь Лабутин" Это, в общем-то, и все, что нам рекомендовал Кристо.
975.48 979.56 "Анатолий Кулаков" Хорошо, от Microsoft у нас, в принципе, тоже есть кое-какие рассуждения.
979.56 985.56 "Анатолий Кулаков" Это цикл статей от Ричарда Лендера Conversation, и сегодня мы с вами поговорим о нетворкинге.
985.56 1007.76 "Анатолий Кулаков" В принципе, это такие лайтовые небольшие обзорчики, которые вполне помогают подвести какую-то общую базу, что сейчас есть в дотнете, и так как он очень быстро меняется, то вероятно, что не все могут уследить за всеми фичами, поэтому такие подобные маленькие конверсейшены бывают весьма-таки полезны, тем более, когда на них приходят такие замечательные люди.
1007.76 1015.80 "Анатолий Кулаков" И сегодня у нас в гостях будут Стивен Таупт, Карл Зигмунд и Дэвид Фаулер, а также там другие какие-то люди и я без понятия, кто это.
1015.80 1020.12 "Анатолий Кулаков" Мне кажется, основные эти персоны уже могут задать тон любой дискуссии.
1020.12 1024.48 "Анатолий Кулаков" Итак, Ричард Лендер говорил со своими гостями о нетворкинге.
1024.48 1032.28 "Анатолий Кулаков" В принципе, тема хорошая, тема богатая, потому что любое современное приложение кажется уже никуда без нетворкинга.
1032.28 1038.68 "Анатолий Кулаков" Если вы не пишите какие-нибудь там сетевые, ой, какие-нибудь консольные утилитки, вот, тогда, может быть, вы как-то обойдетесь.
1038.68 1057.76 "Анатолий Кулаков" Но с другой стороны, таких вещей становится меньше и меньше, и все больше у нас микросервисов, все больше клиентов, все больше распределенщины и прочих-прочих-прочих вещей, поэтому нетворк - это, наверное, одна из самых главных точек, куда может упереться какое-то приложение как по функциональности, так и по перформансу.
1057.76 1062.16 "Анатолий Кулаков" Итак, что же у нас поддерживает дотнет прямо из коробки?
1062.16 1069.84 "Анатолий Кулаков" Прежде всего, если мы говорим про нетворкинг, то это начинает с самых базовых протоколов, полностью TCP/STK, TCP/IP.
1069.84 1081.20 "Анатолий Кулаков" Дальше у нас идет уже прикладной уровень, это HTTP/1.1, вторая версия, HTTP/3 собираются внедрить уже в дотнет/6, он тоже будет идти прямо из коробки.
1081.20 1122.40 "Анатолий Кулаков" Также у нас есть WebSockets, TLS, SSL, gRPC и немножко других поддерживаются в частности FTP и SMTP, но эти протоколы были задизайнены или заимплементированы довольно-таки давно, еще с момента всяких первых версий, и официально команда Microsoft рекомендует не использовать стандартные имплементации, они оставлены только для совместимости, для очистки совести, но официальная рекомендация - это использовать альтернативные компоненты, которые сделаны намного более чисто, производительно и, в принципе, задизайнены уже с современными тенденциями в архитектуре.
1122.40 1155.60 "Игорь Лабутин" Еще, соответственно, есть ряд протоколов, которые не поддерживаются напрямую в самом дотнете, но, тем не менее, достаточно широко используются, это DNS, но DNS используют все, очевидно, чтобы реминализовывать в IP-шнике, а также есть еще два протокола - MQTT и IMQP, которые, возможно, для некоторой части нашей аудитории не скажут ничего, эти две волшебных аббревиатуры, но на самом деле, если я скажу еще одну аббревиатуру - IoT, Internet of Things, то вы будете на этих два наиболее популярных протоколов в мире IoT.
1155.60 1185.36 "Анатолий Кулаков" Немножко уточню, что несмотря на то, что, в принципе, сам класс DNS в дотнете есть и вы можете легко разрезалвить и имя в IP-адресы и IP-адресы в имени, здесь имеется все-таки в виду именно низкоуровня и общения с DNS-API, то есть, когда вы можете получить там рекорды у этих рекордов, узнать типы у этих типов, узнать их наследование, их вложенности и прочее, то есть поработать с DNS вот на таком низкоуровневом текстовом уровне.
1185.36 1203.40 "Анатолий Кулаков" Это очень часто бывает нужно и, в принципе, из всех опрошенных практически единогласно решили, что DNS-API низкоуровнево нужно быть в дотнете, нужно быть из коробки и поставляться как бы как вместе с платформой, как нативное предложение.
1203.40 1205.84 "Анатолий Кулаков" А не использовать какие-то третий сторонние вещи.
1205.84 1209.44 "Анатолий Кулаков" Это очень часто бывает необходимо для разных приложений.
1209.44 1211.40 "Анатолий Кулаков" Ну что ж, пройдем дальше.
1211.40 1218.96 "Анатолий Кулаков" Итак, самый главный, наверное, протокол, который чаще всего используется в повседневной жизни многим приложениями - это HTTP.
1218.96 1225.96 "Анатолий Кулаков" Для HTTP-стека у нас есть такое глобальное деление, так как Client-API и Server-API.
1225.96 1246.40 "Анатолий Кулаков" Во некоторых компонентах их пытались вместе соединить, но авторы признались, что, в принципе, считают этот проект провальным и нужно четко понимать, на клиенте используется API или на сервере API, потому что очень различается и процесс инфраструктуры, и процесс дебаггинга, и процесс телеметрии и прочее, прочее.
1246.40 1251.20 "Анатолий Кулаков" В частности, HTTP-Client является типичным представителем Client-API.
1251.20 1258.32 "Анатолий Кулаков" По сути, это обертка над HTTP-Message Handler, который сидит поверх стримов, System of Streams.
1258.32 1273.84 "Анатолий Кулаков" По дефолту реализация стримов не заимплеменчена для сокетов, но на самом деле можно легко в эти стримы подставить любой интерфейс, который имплементирует стримы, не обязательно сокеты.
1273.84 1279.60 "Анатолий Кулаков" Также очень много есть в HTTP-Client из всяких специфичных хендлеров.
1279.60 1287.44 "Анатолий Кулаков" Эти хендлеры часто не только делают какую-то дополнительную поднагрузку или работу, но и помогают обойти всякие специфики операционных систем.
1287.44 1297.76 "Анатолий Кулаков" Например, есть хендлеры для Android, iOS, есть WinHTTP-Handler для Windows, есть Browser-HTTP-Handler, который используется в WebAssembly.
1297.76 1303.16 "Анатолий Кулаков" И это все используется для одного и тому же клиента, но с разными хендлерами.
1303.16 1308.08 "Анатолий Кулаков" Есть более интересные хендлеры для операционных систем.
1308.08 1321.28 "Анатолий Кулаков" Например, для Android и iOS есть специальный хендлер, который помогает переносить коннекшены, переносить соединения между несколькими сетьми, между несколькими нетворками.
1321.28 1328.64 "Анатолий Кулаков" Что, в принципе, тоже довольно забавная и интересная вещь, с которой может быть десктоп-разработчики даже не задумывались сталкиваться.
1328.64 1334.04 "Анатолий Кулаков" HTTP-стек на сервер-сайде обеспечивает ISP-net-core.
1334.04 1337.40 "Анатолий Кулаков" Главным интерфейсом, здесь таким корневым, является это IServer.
1337.40 1344.08 "Анатолий Кулаков" Этот интерфейс решает, каким образом обрабатывать входящие реквесты и хендлы.
1344.08 1348.36 "Анатолий Кулаков" И делает он с помощью промежуточных прослоек.
1348.36 1355.96 "Анатолий Кулаков" Это middleware-pipeline, который мы уже, наверное, привыкли строить в наших приложениях на старте приложения.
1355.96 1361.36 "Анатолий Кулаков" Добавляем туда всякие логику, всякий cross-cutting concern, логирование и прочие вещи.
1361.36 1366.72 "Анатолий Кулаков" В частности, в дотнете из коробки есть три реализации IServer.
1366.72 1368.40 "Анатолий Кулаков" Во-первых, это HTTP-size.
1368.40 1370.92 "Анатолий Кулаков" Это стандартный сервер для Windows.
1370.92 1374.08 "Анатолий Кулаков" Это IS-хостинг для Windows.
1374.08 1378.08 "Анатолий Кулаков" И Kestrel, самый популярный кроссплатформенный веб-сервер на данный момент.
1378.08 1380.48 "Анатолий Кулаков" И, соответственно, самый быстрый.
1380.48 1387.08 "Анатолий Кулаков" Никто не мешает вам реализовать свой IServer и заимплементировать все, что вам не хватает из этих трех наследников.
1387.08 1396.08 "Игорь Лабутин" Сколько я знаю, в дотнете сейчас ведется довольно активная работа по переписке большей части стека на C#, нейтрофового стека я имею в виду.
1396.08 1404.80 "Игорь Лабутин" Там, конечно, идет работа не только за нейтрофовым стеком, но там, я так понимаю, очень много изменений именно в сторону смегрирования C#, быть ли это нативно или бытно.
1404.80 1408.56 "Анатолий Кулаков" Да, это в принципе проблема стояла не так актуально, когда дотнет был чисто под винды.
1408.56 1413.24 "Анатолий Кулаков" Вот там завязали всякие микрософтовские библиотечки, стандартные виндовые библиотечки.
1413.24 1415.28 "Анатолий Кулаков" И в принципе все было хорошо.
1415.28 1424.96 "Анатолий Кулаков" С тех пор, как дотнет начал смотреть на другие операционные системы, когда появился dotnet core, проблема с переписыванием стала очень остра.
1424.96 1431.92 "Анатолий Кулаков" И одной из причин как раз является портабельность, то есть перенос C# кода на новые платформы.
1431.92 1443.84 "Анатолий Кулаков" Если у вас используются нативные вызовы операционной системы, то этих вызовов может не быть на другой операционной системе, они могут иметь другие интерфейсы, они могут быть быстрее, медленнее, не такие.
1443.84 1445.68 "Анатолий Кулаков" В общем, проблем с ними море.
1445.68 1453.96 "Анатолий Кулаков" Поэтому гораздо выгоднее, гораздо интереснее написать один раз правильную имплементацию на C# и носить ее между всеми операционными системами.
1453.96 1458.24 "Анатолий Кулаков" Таким образом гарантируя 100% переносимость с помощью компилятора.
1458.24 1464.72 "Анатолий Кулаков" Другой интересным преимуществом переписывания всего стека на C# является консистентность.
1464.72 1477.12 "Анатолий Кулаков" Те баги, которые вы находите, вы легко можете воспроизвести обычно на любой другой операционной системе, поддерживаемой дотнет платформой и отладить, зарепродюсить, оформить, описать.
1477.12 1486.80 "Анатолий Кулаков" И это все можно делать без всяких там страшных дампов системных библиотек, проникания внутрь кернела и прочих вот этих страшных вещей.
1486.80 1492.20 "Анатолий Кулаков" Еще одна штука, которая дает консистентность, это производительность.
1492.20 1501.76 "Анатолий Кулаков" Потому что, как я уже говорил, Network Stack один из самых узких горлышек обычно в перформансе всей системы, всего приложения.
1501.76 1504.68 "Анатолий Кулаков" И он должен быть мега-производительным, мега-эффективным.
1504.68 1521.80 "Анатолий Кулаков" И как раз таки, когда код написан вами, когда он написан на C#, вы можете вставлять множество каких-нибудь оптимизаций, новых алгоритмов, использовать системные дредпулы, например, какие-нибудь буферные сокеты и прочее-прочее.
1521.80 1530.04 "Анатолий Кулаков" Если вы используете какие-то системные вызовы, например, какой-нибудь libcurl, то вы сразу же лишаетесь всех этих возможностей по оптимизации.
1530.04 1542.60 "Анатолий Кулаков" Третьим интересным преимуществом, которое идет вместе с переписыванием стека является то, что сообщество намного легче и намного активнее переписывает, дополняет и оптимизирует код на C#.
1542.60 1547.12 "Анатолий Кулаков" То есть, это больше вовлеченность сообщества в этот кусок инфраструктуры.
1547.12 1559.68 "Анатолий Кулаков" И, соответственно, раньше, если вы видите, что происходит какой-то нативный вызов C++ кода или вообще операционной системы, то обычный разработчик туда вряд ли пойдет.
1559.68 1575.88 "Анатолий Кулаков" А если мы говорим про C# community, то здесь они уже чувствуют себя очень удобно, очень хорошо и могут как поправить документацию, которая немножко разъехалась, так и уже навести более интересные оптимизации, которые не подсмотрели или подслушали в других участках кода.
1575.88 1581.84 "Анатолий Кулаков" И команда отметила, что это очень весомое такое преимущество, которое сразу было неочевидным.
1581.84 1585.44 "Анатолий Кулаков" Но сейчас оно показывается все сильнее и сильнее.
1585.44 1589.72 "Анатолий Кулаков" Все же не весь dotnet stack переписан на нативный менеджмент кода.
1589.72 1594.40 "Анатолий Кулаков" Остались все еще большие, сложные компоненты.
1594.40 1601.96 "Анатолий Кулаков" Это SSL stream и некоторые крипто алгоритмы, крипто структуры, которые завязаны на networking.
1601.96 1607.32 "Анатолий Кулаков" Вот эти два компонента все еще используют нативные свойства операционной системы.
1607.32 1617.36 "Анатолий Кулаков" У команды есть в планах это как-то переписать, но за этим есть проблемы, поэтому сейчас они, в принципе, с этим не сторопятся.
1617.36 1618.84 "Анатолий Кулаков" Есть более приоритетные задачи.
1618.84 1633.24 "Игорь Лабутин" Одной из таких приоритетных задач, я думаю, что на пятый dotnet, если честно, шестой, это поддержка HTTP/2, потому что это основа-основ для протокола gRPC, который набирает популярность и без HTTP/2 просто не работает.
1633.24 1641.32 "Игорь Лабутин" Но если вы знаете, что такое протокол HTTP, то HTTP/2 это не то, чтобы там просто небольшое добавление, это довольно сильно переработанная спецификация.
1641.32 1650.92 "Анатолий Кулаков" Да, действительно, прежде всего это базис для gRPC, но не только, потому что там еще куча всяких других оптимизаций, в частности, HTTP/2 у нас теперь бинарный.
1650.92 1655.00 "Анатолий Кулаков" Это позволило сильно уменьшить размер пакета.
1655.00 1676.40 "Анатолий Кулаков" Те, кто боится всякой отладки, что невозможно бинарный протокол отлаживать, это будет слишком сложно и так далее, вот их утешают, что уже множество инструментов есть вокруг, которые динамически на лету вам позволяют представить его в удовольствием в MIDI, поэтому любой разработчик, который умеет пользоваться инфраструктурными инструментами вокруг себя, не должен столкнуться с проблемами нечитабельности кода.
1676.40 1684.04 "Анатолий Кулаков" Поэтому HTTP/2 все-таки решили сделать бинарным, и это дает очень много других преимуществ, где можно читабельностью пожертвовать.
1684.04 1696.12 "Анатолий Кулаков" Также у нас там будет меньше overhead на установление TLS-соединения, и вообще у нас есть перешаринг единственного соединения для нескольких запросов, которые идут в параллель.
1696.12 1698.52 "Анатолий Кулаков" Вот этот перешаринг там сделан довольно эффективно.
1698.52 1702.68 "Анатолий Кулаков" Все-таки HTTP/2, он больше заточен под браузеры.
1702.68 1715.36 "Анатолий Кулаков" Вот там нужно устанавливать множество соединений, закачивать например мелкие файлики, CSS-стильчики, всякие JS-скриптики, что нужно делать параллельно, быстро, переюзывая соединения и так далее.
1715.36 1727.96 "Анатолий Кулаков" Если мы говорим о server-to-server взаимодействии, то обычно это взаимодействие довольно продолжительное по lifetime, и поэтому там не очень видны все бенефиты HTTP/2.
1727.96 1733.92 "Анатолий Кулаков" Конечно, мы там какие-то преимущества получим, но в основном нужно признать, что это вотчина веб-браузера.
1733.92 1740.36 "Игорь Лабутин" Еще есть такая штука HTTP/3, это еще более переработанная вещь, где отказались вообще прямо от TCP даже.
1740.36 1746.12 "Анатолий Кулаков" Да, HTTP/3 вообще было решено сделать на UDP, но это не все.
1746.12 1757.40 "Анатолий Кулаков" Одним из интересных свойств HTTP, в частности Quica, является то, что мобильные клиенты теперь способны будут перескакивать между различными сетьми.
1757.40 1772.32 "Анатолий Кулаков" То есть, если у вас телефончик работал по Wi-Fi, потом вы куда-то перешли в другую комнату или в другой дом, и, соответственно, у вас он переключился на LTE, и все это происходит абсолютно прозрачно для высокоуровневых протоколов, все это обрабатывается на уровне HTTP.
1772.32 1790.80 "Анатолий Кулаков" Если вы теряли раньше пакеты, например, то предыдущая версия, включая HTTP/2, блокировала весь pipeline запросов для того, чтобы дождаться потерянного пакета, перезапросить его, и только после этого возобновлял работу всех запросов дальше.
1790.80 1803.88 "Анатолий Кулаков" В HTTP решили эту проблему, останавливается только тот реквест, который потерял свой пакетик, дожидается, его перезапрашивает, а все остальные реквесты в этот момент работают и никаким образом друг на друга не влияют.
1803.88 1822.24 "Анатолий Кулаков" Здесь интересно заметить, что и HTTP/2, и HTTP/3 полностью имплементированы на C#, но вот Quica протокол, вот эта Quica часть, она дергается через PainVoc, это нативная библиотека MS Quica, которая написана на C и C++.
1822.24 1843.08 "Анатолий Кулаков" По мнению экспертов, в принципе, HTTP/1, 1.1 в частности, никуда не денется, этот протокол с нами надолго на нем написана, а огромная инфраструктура, ну то есть практически весь интернет сейчас работает именно на нем, поэтому это было бы слишком смело говорить о том, что мы быстренько сейчас все заменим и все будут работать на новых протоколах.
1843.08 1858.44 "Анатолий Кулаков" Место HTTP/2 тоже не завидное, потому что, скорее всего, если HTTP/3 и Quica удачно выстрелят, то HTTP/2 будет не нужен, и скорее всего, у нас останется два протокола, третий и первый.
1858.44 1872.12 "Анатолий Кулаков" Но если с HTTP/3 будут какие-то проблемы или рынок не захочет его по какой-то другой причине адаптировать, то может появиться еще и HTTP/2 как более лучшая версия первого протокола.
1872.12 1880.36 "Анатолий Кулаков" В принципе, о будущем здесь сложно говорить, но пока такие места, такое будущее готовят им эксперты.
1880.36 1891.72 "Анатолий Кулаков" Следующий вопрос был, какие интересные performance-изменения были затронуты в нетворке для того, чтобы сделать наш стэк быстрым, красивым и самым лучшим.
1891.72 1899.92 "Анатолий Кулаков" Они не рассказывали про великие изменения Бена Адамса, когда он делал на Kestrel самым быстрым сервером во вселенной.
1899.92 1916.48 "Анатолий Кулаков" Они больше сосредоточились на низковыровном коде, где рассказали, что основные оптимизации были сделаны в имплементации сокетов, как они хорошо переюзали input-output и переделали input-output систему, что она стала очень асинхронной и очень быстрой.
1916.48 1927.12 "Анатолий Кулаков" И также, как они удачно заиздоюзали ThreadPool для того, чтобы переюзывать коннекшены не только в HTTP сервере, но и вообще в работе всего нетворка.
1927.12 1937.56 "Игорь Лабутин" Ну, в принципе, на самом деле мы про нетворки уже тоже затрагивали и раньше, аспекты именно про performance в последнюю часть, поискайте по старым выпускам, там точно где-то должно было быть.
1937.56 1941.88 "Игорь Лабутин" Но радует, что прогресс не стоит на месте, двигаемся вперед.
1941.88 1954.08 "Игорь Лабутин" И в частности, довольно старая статья от Майя этого года, но она тут очень в тему, про то, какова вообще жизнь gRPC в США.
1954.08 1962.92 "Игорь Лабутин" И краткая идея в том, что когда gRPC только-только приходил в США, существовало как минимум две версии его поддержки.
1962.92 1973.04 "Игорь Лабутин" Во-первых, была версия gRPC.net, а вторая была то, что называлась gRPC Core, если смотреть по именам Nougat пакета.
1973.04 1988.36 "Игорь Лабутин" gRPC Core, соответственно, это была просто тонкая C# обертка над натипной гугловской библиотекой, а gRPC.net, это был, соответственно, там есть и клиентская серверная часть, они были написаны целиком на C#, без какого-либо нативного аппи.
1988.36 2012.76 "Игорь Лабутин" И, соответственно, теперь вот в Майе было объявлено, что gRPC.net, то есть часть, которая написана целиком на .net, Nougat пакеты, это теперь рекомендованные реализации gRPC, которые нужно использовать на .net, а gRPC Core, который был основан на нативной библиотечке, потихонечку будет уходить из жизни, и это теперь не надо его использовать.
2012.76 2019.56 "Игорь Лабутин" Поскольку это зависит от какой-то сторонней библиотеки, она нативная, это мешает происходить платформенности и так далее.
2019.56 2056.24 "Игорь Лабутин" А кроме того, поскольку, как сказал Толя, теперь встроен .net Framework, ну, .net Core и .net 5, и поэтому почему бы не использовать просто нативный, не нативный, а структуральный C# gRPC клиент вместо какого-то нативного DLL? Почему команда считает, что gRPC.net это лучше, чем Native DLL? Хотя, кстати, если вы вспомните какие-нибудь ранние статьи на эту тему, более функциональной была версия от Google с C# оберткой, но команда прошла, проработала, и теперь gRPC.net, она полнофункциональная и вполне себе цеперничает по функциям, хотя они не равнозначны, не проверяйте там личку совместимости.
2056.24 2075.52 "Игорь Лабутин" Но если вы пишете на более-менее современной версии .net, то есть это .net Core, .net 5, опять же, если вы думаете, что вам нужно как-то, смотри выше, рассказ Толи про то, чтобы комьюнити побольше к вам пришло, которое не будет пугаться нативных DLL, то смотрите на gRPC.net.
2075.52 2091.36 "Игорь Лабутин" Она была сделана на основе стандартных опишек ASP.net Core, соответственно, знакома всем контрибьюторам, знакома тем, кто знает ASP.net Core, и по сути просто отличается немножко терминологией, совсем уж не с по уровню внутренней кухни, если туда кто-то захочет лезть.
2091.36 2102.92 "Игорь Лабутин" Вот с точки зрения планов, как я сказал, с мая 2021 года вот эта вот gRPC Core бюджетничка, основанная на нативных DLL, уходит в режим maintenance и будет находиться в нем в течение года.
2102.92 2108.36 "Игорь Лабутин" То есть она будет получать какие-то возможности к рептилии патчей или что-то еще, но только в течение года до мая 2022 года.
2108.36 2111.96 "Игорь Лабутин" С 2022 года она будет, прикинь, никак поддерживаться не будет.
2111.96 2139.64 "Игорь Лабутин" При этом, если вы посмотрите, еще есть где-то такие два пакета, это gRPC.tools и gRPC.core.app, они будут поддерживать нормально, они будут работать, потому что они на C#, и они на самом деле тоже нужны для gRPC.net, потому что tools это больше про компиляторы, про то, как генерить C# коды с порта бафа, а gRPC.core.app это тоже совсем низкого уровня в API, который тоже нужен для контракта, написанного базовым, который нужен для gRPC клиента, и сервера.
2139.64 2141.04 "Игорь Лабутин" Поэтому эти две штуки будут жить.
2141.04 2152.52 "Игорь Лабутин" В целом сейчас gRPC, как мы сказали выше, требует RSTP2, и поэтому это означает, что по сути для нормальной работы вам нужен, как минимум, Core 3.x, ну или пятый .NET, или шестой.
2152.52 2166.44 "Игорь Лабутин" Но на самом деле есть работа сейчас, которая потихонечку как-то ведется, для того, чтобы все-таки иметь возможность эти пакеты использовать на полноценном .NET-фреймворке, где какая-никакая реализация RSTP2 есть, она такая, не всегда работающая, но тем не менее.
2166.44 2186.40 "Игорь Лабутин" Поэтому работа ведется, если вы по каким-то причинам не можете пока перейти на .NET Core 3.x и .NET 5, последите за тем, что там происходит, есть, кстати, в случае с гитхамом, попадаются статьи про то, что там делается, и будете в курсе, что вообще происходит в этом мире, и есть ли шанс на нормальный gRPC на полноценном фреймворке.
2186.40 2196.84 "Анатолий Кулаков" Да, еще один отличный пример, когда переписали какой-то сетевой слой из каких-то нативных вызовов на C#, и получилось намного лучше, чем было раньше.
2196.84 2199.72 "Анатолий Кулаков" Да, забавный аспект.
2199.72 2206.04 "Анатолий Кулаков" Ну, здравия, здравия gRPC, будем развивать на родных C# языках.
2206.04 2230.44 "Анатолий Кулаков" Слушай, мы с тобой еще много очень говорили про всяких discovering HTTP/IPI, исследования HTTP/IPI, и тут как раз недавно наткнулся на статейку в блоге JetBrains, они сделали новый инструмент, новое окошко, которое вот как раз в тему, и мне кажется, очень-очень удобно оно будет к тому, что есть сейчас.
2230.44 2234.48 "Анатолий Кулаков" Окошко недвусмысленно называется Endpoints, но давай разберемся поближе.
2234.48 2244.28 "Анатолий Кулаков" Итак, сейчас у разработчиков есть очень много точек, где они могут указать Endpoints для своего приложения.
2244.28 2257.52 "Анатолий Кулаков" В частности, это можно делать в Razor Pages, в MVC-контроллерах, в Web API-контроллерах, можно вызвать специальный метод Map, с помощью которого прибавить кастомный обработчик к любому адресу.
2257.52 2259.48 "Анатолий Кулаков" В общем, таких точек много-много.
2259.48 2269.88 "Анатолий Кулаков" И мы, в принципе, лишены какого-то инструмента для того, чтобы все Endpoints, с помощью которых в нашу систему будут ходить сторонние приложения, взять так и обозреть.
2269.88 2276.84 "Анатолий Кулаков" Ну, грубо говоря, просто собрать наш публичный API из всех точек и показать, что мы выставляем наружу.
2276.84 2284.00 "Анатолий Кулаков" Очень часто для этих целей используют Swagger или другие инструменты, которые работают по OpenAPI, по артаколу.
2284.00 2293.04 "Анатолий Кулаков" И с помощью Swagger UI выдают что-то, что можно было в качестве Web API указать.
2293.04 2310.56 "Анатолий Кулаков" Но в большинстве случаев это довольно отдаленно приближено к настоящей практике, потому что из этого Swagger UI вы не можете взаимодействовать с кодом, вы не можете посмотреть, в какой строчке у вас этот роут зарегистрирован, не можете найти его юсиджи.
2310.56 2318.60 "Анатолий Кулаков" И много-много чего еще полезного, к чему мы привыкли с богатыми всякими дебаггинг-тулзами.
2318.60 2325.48 "Анатолий Кулаков" Разработчики, всего этого мы не можем сделать с нашим Web API, казалось бы, такой очень важной точкой.
2325.48 2334.32 "Анатолий Кулаков" И вот в JetBrains Rider версии 2021.2 в IAPI уже доступна новая окошко, которая называется Endpoints.
2334.32 2336.80 "Анатолий Кулаков" Это очень интересная штука.
2336.80 2341.60 "Анатолий Кулаков" Во-первых, сама технология, она сканирует все атрибуты, которые у вас есть в приложении.
2341.60 2346.36 "Анатолий Кулаков" Сейчас поддерживаются атрибуты route, HTTP метод и accept verb.
2346.36 2355.48 "Анатолий Кулаков" В будущем планируется этот список расширять, добавлять новые места, с помощью которых можно регистрировать Web API.
2355.48 2363.60 "Анатолий Кулаков" В частности, вышеупомянутый метод map, который можно зарегистрировать любой хендлер, скоро он тоже будет поддержан.
2363.60 2365.28 "Анатолий Кулаков" Итак, что же у нас происходит?
2365.28 2378.28 "Анатолий Кулаков" В тот момент, когда вы запускаете ваше приложение, в левой части вы сможете увидеть список всех endpoints, которые есть в вашей системе, которых нашел Rider.
2378.28 2385.56 "Анатолий Кулаков" Там вы, естественно, будете видеть метод, который вызывается, URL, который вызывается и прочая верхнеуровневая информация.
2385.56 2400.92 "Анатолий Кулаков" И из этого окошка вы можете навигироваться по коду, посмотреть, где он объявлен, посмотреть его использование, то есть обращаться с ним как с нормальным куском кода, используя всю мощь JetBrains и их навигационной системы.
2400.92 2404.56 "Анатолий Кулаков" Правая часть этого окна разделена на три табика.
2404.56 2407.40 "Анатолий Кулаков" Документация, HTTP Client и OpenAPI.
2407.40 2414.68 "Анатолий Кулаков" В документации ничего сверх нового нет, там просто используется документация из XML Documentation.
2414.68 2425.24 "Анатолий Кулаков" Вы можете почитать, что этот VPPA делает, что принимает, какие респонсы возвращает и прочие стандартные вещи, которые, в принципе, вам доступны из любого Swagger UI.
2425.24 2434.28 "Анатолий Кулаков" Вкладка HTTP Client включает специальный режим встроенного HTTP-инструмента, который позволяет вам из командной строки выполнять запросы.
2434.28 2439.12 "Анатолий Кулаков" Мы уже много раз упоминали подобную функциональность в виде плагинов, в виде еще чего-то.
2439.12 2453.64 "Анатолий Кулаков" Кратко напомню, это очень удобный такой текстовый редактор с интеллисенсом, в котором вы пишете просто в одну строчку GET, URL, что захотите достать, и тут же его запускаете, он же здесь же вам исполняется.
2453.64 2464.44 "Анатолий Кулаков" Именно текстом выдает BODY, который вернулся, там же можно посмотреть HTTP хедера, там же можно проанализировать ошибки, может быть, ставить какие-то переменные среды окружения и прочее.
2464.44 2471.00 "Анатолий Кулаков" В общем, это такой текстовый инструмент, который безумно удобен для того, чтобы работать сейчас с HTTP-забросами.
2471.00 2489.08 "Анатолий Кулаков" И прямо здесь же он вам интегрируется с этим окошком, то есть подставляется автоматически все URL, все методы, и можете одной кнопочкой все это запустить и посмотреть, насколько действительно ваше приложение отвечает теми заголовками и теми BODY, которые вы рассчитываете.
2489.08 2500.64 "Анатолий Кулаков" И последняя клавишка OpenAPI, она открывает OpenAPI-спецификацию, и эта вкладочка очень полезна для тех команд, которые работают напрямую со спецификацией, как-то ее изменяют, как-то ее редактируют.
2500.64 2511.48 "Анатолий Кулаков" У райдера есть множество интеграций со всякими спецификишен-серверами, которые вы можете откуда-то там скачивать, загружать и прочие вещи творить.
2511.48 2514.60 "Анатолий Кулаков" И это все доступно как бы на третьей вкладочке.
2514.60 2526.08 "Анатолий Кулаков" Вот такой забавный инструмент с богатым потенциалом, с хорошими возможностями для расширения, и мне кажется, что он найдет свою отличную нишу в инструментах для отладки в современных приложениях.
2526.08 2528.08 "Игорь Лабутин" Интересный вариант, давайте попробовать.
2528.08 2531.72 "Игорь Лабутин" Я, наверное, не буду ставить яблочко, потому что нормальная версия.
2531.72 2536.36 "Игорь Лабутин" Потом посмотрю, заодно пофиксить все неудобности, может еще какие-то кидать, дописать типа мапы.
2536.36 2541.60 "Игорь Лабутин" У нас на самом деле на мапах много сделал, поэтому без мапов будет тяжело их правильно найти.
2541.60 2543.08 "Игорь Лабутин" Ну да ладно, пошли дальше.
2543.08 2549.44 "Игорь Лабутин" Раз сегодня у нас мы так говорим много про сети, я хотел еще одну тадейку обсудить.
2549.44 2553.88 "Игорь Лабутин" Тему, которую мы практически не затрагивали в этом подкасте, а именно GraphQL.
2553.88 2559.48 "Игорь Лабутин" У тебя вообще была какая-то практика работать с ним или что-нибудь как-нибудь касалось GraphQL?
2559.48 2577.64 "Анатолий Кулаков" Нет, нет, наверное только так Hello World писал, пробовал как это работает, чтобы основные концепции узнать, но в настоящих больших продакшн системах не использовал, поэтому ни под нагрузкой, не понимая как он себя ведет, ни какие-то performance issues, ни удобства использования, версионирования, все это пока проходит мимо меня.
2577.64 2596.48 "Игорь Лабутин" Но вот да, это на самом деле, у меня есть ощущение, что это проходит мимо довольно большого числа разговорчиков, мало кто его потрогал в продакшне, но тем не менее давайте мы пробежимся по статье Джереми Ликнеса, который на самом деле, если я не ошибаюсь, сейчас находится в команде Entity Framework Core, но почему-то решил написать статью про GraphQL.
2596.48 2617.92 "Игорь Лабутин" Она такая очень вводная, если вам было интересно вообще что такое GraphQL и кратенькая выжимка вообще, как с ним работать и какие у него есть плюсы и минусы, загляните, она довольно неплохо написана, она не очень большая, с примерчиками, но тем не менее дает некоторый обзор того, зачем это может быть нужно и какие могут быть проблемы, если вы начнете использовать неправильные линии для тех задач.
2617.92 2618.92 "Игорь Лабутин" Давайте по порядку.
2618.92 2619.92 "Игорь Лабутин" Для начала что такое GraphQL?
2619.92 2631.20 "Игорь Лабутин" GraphQL это на самом деле, по сути, интерфейс для фронтендов, то есть это возможность для фронтендов каким-то образом указать какие данные нужны фронтенду и получить их.
2631.20 2641.68 "Игорь Лабутин" Он не предназначен для общения между бэкэндами, то есть если вы думаете про то, что "ммм, Facebook использует GraphQL и, наверное, я должен его теперь использовать везде", нет, это неправда.
2641.68 2645.52 "Игорь Лабутин" GraphQL специально дизайнился исключительно по цели фронтенда и ничего другого.
2645.52 2652.44 "Игорь Лабутин" Его создатель на самом деле говорит, что это, по сути, API для вытаскивания данных, достаточно мощная, чтобы описать весь Facebook.
2652.44 2662.92 "Игорь Лабутин" Ну, как вы понимаете, Facebook довольно большой, поэтому API получилась довольно мощная, но она сделана Facebook для Facebook, поэтому если вы не Facebook, то важно подумать подленно.
2662.92 2671.04 "Игорь Лабутин" По сути, она использует такую же традиционную, обычную, знакомую нам всем по HTTP модель запросов и ответов, RequestResponse.
2671.04 2683.12 "Игорь Лабутин" Респонсы практически всегда, конечно, это же JSON, а вот реквесты, они используют специальный диалект, который, ну, на первый взгляд, похож на JSON, но это на самом деле не JSON, он немножко другой.
2683.12 2702.24 "Игорь Лабутин" На Xamarin, соответственно, этот самый диалект парсится, и вы в коде должны написать некоторое количество кода, который называется резолверами, который как раз-таки умеет правильно обрабатывать этот самый диалект в вашей области терминологии, в вашем домине, чтобы знать, как вообще эти данные доставать с баны.
2702.24 2705.80 "Игорь Лабутин" Там есть некоторые, назовем это шерсткаты, я к ним немножко вернусь в конце.
2705.80 2716.80 "Игорь Лабутин" И плюс, соответственно, всего этого дела в том, что клиенту, в общем-то, более-менее все равно, откуда приходят данные, то есть вы можете за одним графикой линдпоинт спрятать огромное количество источников данных, для клиента это будет все еще один линдпоинт.
2716.80 2722.00 "Игорь Лабутин" И большим подспором для этого является фича, которая называется схема стичинг, то есть склеивание схем.
2722.00 2724.92 "Игорь Лабутин" И есть для этого, по мнению Джереми, два юзкейса.
2724.92 2733.00 "Игорь Лабутин" Первый, если у вас есть несколько команд, и которые девелопят каждый из них свою схему, вы можете просто выставить их под общим линдпоинтом.
2733.00 2742.72 "Игорь Лабутин" Но схема называется по-разному, соответственно, если запросишь что-то из схемы номер один, ну, оно, или с хемы А, оно будет отдано бакенду со схемой А, если будет, или с командой А.
2742.72 2746.04 "Игорь Лабутин" И если запросишь что-то из схемы Б, ну, будет отдано команду Б.
2746.04 2753.16 "Игорь Лабутин" Это с одной стороны, то есть это такой способ организовать работу в большой команде, и при этом все еще выглядит, как будто мы один линдпоинт, а один сервис.
2753.16 2768.48 "Игорь Лабутин" А второй вариант, если у вас в вашей системе данные хранятся, какие-то разные данные на разных узлах, то вы можете их включить как бы в один запрос, то есть пользователь будет их просить в одном запросе, я там хочу для юзера, поля там, имя и номер кредитной карточки.
2768.48 2771.16 "Игорь Лабутин" А у вас это хранится на самом деле в двух разных системах.
2771.16 2779.44 "Игорь Лабутин" То вы внутри это раскидываете на несколько разных бакендов, каждый бакенд что-то отвечает, дальше вы идут, отклеиваете в единый объект и все это отправляете клиенту.
2779.44 2786.76 "Игорь Лабутин" Это зовется схема стичинг, очень широко используемая штука GraphQL, насколько я понимаю, позволяет как-то дробить это и не писать один максимально главный GraphQL сервис.
2786.76 2792.32 "Игорь Лабутин" При этом надо понимать, что все то, что я сейчас говорю, это пока еще только касалось получения данных.
2792.32 2796.84 "Игорь Лабутин" Клиент посылает некоторый запрос в GraphQL диалекте и получает в ответ JSON.
2796.84 2801.12 "Игорь Лабутин" Но, как мы знаем, все сервисы не ограничены только Geth, надо еще что-то изменять обычно.
2801.12 2805.60 "Игорь Лабутин" В GraphQL это называется mutation, и это прям явно пишется внутри запроса.
2805.60 2816.36 "Игорь Лабутин" То есть понятно, что в ваш ДТП обычно мы отделяем Geth от постов, в случае же с GraphQL вы прямо внутри ботика будете писать, что это как бы query, а это mutation, прям текст.
2816.36 2820.20 "Игорь Лабутин" И, соответственно, GraphQL знает, что такое mutation.
2820.20 2826.76 "Игорь Лабутин" Это, скорее всего, штука, которая поменяет данные и относится к ней соответственно, и вызывает соответствующие методы у ваших обработчиков.
2826.76 2841.08 "Игорь Лабутин" Интересная штука, которая подменьшена Gethering, заключается в том, что если вы начинаете привыкать к современному методу, где если вы включаете nullable в reference type, то у вас по дефолту type становится не nullable.
2841.08 2849.64 "Игорь Лабутин" Здесь наоборот, по дефолту nullable, если вам нужно обязательно, чтобы какой-то атрибут был передан, то нужно обязательно в конце написать ему воскресветный знак.
2849.64 2856.84 "Игорь Лабутин" То есть если у вас большое количество, большая схема и все поля require, то у вас будет обилие воскресветных знаков.
2856.84 2861.00 "Игорь Лабутин" Мне визуально это не очень нравится, но так сложилось.
2861.00 2864.72 "Игорь Лабутин" Опять же, это относится к мьютейшенам, поэтому это плохо.
2864.72 2870.36 "Игорь Лабутин" Помимо мьютейшенов и непосредственно получения данных на конкретный запрос, есть еще механизм subscription.
2870.36 2889.36 "Игорь Лабутин" То есть все просто, это обычный WebSocket, который открывается в ответ на запрос, и если на соответствующий event срабатывает, то есть при каком-то условии на сервере что-то срабатывает, то сервер перезапускает заданную query, в которой заданы условия, и посылает результаты опять же в WebSocket.
2889.36 2895.96 "Игорь Лабутин" Клиент будет получать автоматически обновляемые результаты по мере того, как они будут реально на сервере что-то где-то обновляться.
2895.96 2900.80 "Игорь Лабутин" Но тут магия заключается в том, как написать самые евенты, условия при которых это нужно обновлять.
2900.80 2907.88 "Игорь Лабутин" С одной стороны, вам не валились эти апдейты, где же там миллисекундно, а с другой стороны, все-таки приходили когда нужно, зависит от вашей доменной области.
2907.88 2919.28 "Игорь Лабутин" Есть с этим, с subscription проблема, то что WebSocket сами по себе не поддерживает каких-то вещей типа HTTP кедров, и соответственно нет никакого стандартного способа написать авторизацию.
2919.28 2925.12 "Игорь Лабутин" То есть вы верите, что вы посылаете данные куда-то, а кто-то с другой стороны их слушает, непонятно.
2925.12 2939.40 "Игорь Лабутин" Чтобы все-таки не верить, а как-то авторизовываться в случае через WebSocket, большинство графиков или серверов, какую-то реализацию поддерживают, но у них, у каждого своя, и нужно смотреть свои стимули конкретно клиентам, конкретно серверам.
2939.40 2944.48 "Игорь Лабутин" Обычно проще взять пару клиентов сервера одного, так сказать, назовем это вендора или разработчика.
2944.48 2950.48 "Анатолий Кулаков" Ну пока функционально не очень отличается от всеми нашего привычного REST API, а зачем же это вообще тогда нужно?
2950.48 2966.92 "Игорь Лабутин" Ну удобство заключается в том, что вы в этом диалекте запроса указываете, в отличие от REST API, где вы говорите дай мне пожалуйста, ну классический модельный пример, да, блоги и посты, дай мне пожалуйста все посты, то тебе вот сервер что-то вернет.
2966.92 2972.44 "Игорь Лабутин" Ты можешь сказать, что окей, я хочу уметь возвращать посты с комментами и без комментов.
2972.44 2976.48 "Игорь Лабутин" Тебе для этого придется сделать query option или query параметр.
2976.48 2979.84 "Игорь Лабутин" Now нет запроса, типа include comments, true quotes.
2979.84 2990.08 "Игорь Лабутин" И так на каждую хотелку, то есть тебе придет UI команда старта, теперь мы хотим, чтобы у нас был фильтр по авторам коммента или по авторам постов или еще какую-то штуку.
2990.08 3005.12 "Игорь Лабутин" А GraphQL позволяет тебе сделать следующее, он тебе возвращает схему данных, то есть можно у сервера запросить схему, то есть ты будешь знать полную схему того, что тебе может нуждаться сервер, после чего в клиенте ты можешь запросить только нужные тебе поля, включая вложенные.
3005.12 3010.44 "Игорь Лабутин" То есть ты по сути этим диалектом указываешь структуру ответа, которую ты хочешь получить.
3010.44 3018.76 "Игорь Лабутин" А задача сервера, соответственно, выполнить это все на бэкэнде, забрать нужные данные из базы или из разных сервисов и вернуть тебе только тот кусочек, который тебе ну
3018.76 3020.76 "Анатолий Кулаков" да, да, в принципе понятно.
3020.76 3024.48 "Игорь Лабутин" В некотором смысле это похоже на там OData, да, где ты.
3024.48 3026.40 "Анатолий Кулаков" Да, сильно перекликается с OData.
3026.40 3035.20 "Игорь Лабутин" Передает по сути доступ в базу прямо клиенту. Здесь чуть-чуть лучше в том плане, что здесь есть те самые резолверы, которые посмотрят на кусочки.
3035.20 3045.24 "Игорь Лабутин" То есть, например, если у тебя есть резолвер информации о пользователе, который тебе всегда стандартно возвращает имя, фамилию, телефон, адрес и так далее, а клиент попросил только имя.
3045.24 3049.36 "Игорь Лабутин" Ну то есть из базы ты вытащишь все равно все, но клиенту дар только имя.
3049.36 3053.36 "Игорь Лабутин" Ну в базу сходил, получил чуть больше данных зато, по сетке передал поменьше.
3053.36 3057.96 "Игорь Лабутин" То есть с одной стороны позволяет использовать достаточно точные запросы, с другой стороны есть минусы.
3057.96 3059.88 "Игорь Лабутин" И как раз про минусы и плюсы сейчас поговорим.
3059.88 3062.52 "Игорь Лабутин" Плюсов перечислено аж 8 штук.
3062.52 3068.56 "Игорь Лабутин" Во-первых, то, что я уже сказал, клиентские разработчики могут просить дату, промоту, которую они хотят.
3068.56 3073.00 "Игорь Лабутин" И при этом не нужны никакие изменения на бакенде, если они просят, то что поддержат.
3073.00 3074.28 "Игорь Лабутин" Не нужно вот этого.
3074.28 3079.68 "Игорь Лабутин" А теперь мне нужно, чтобы в этом getAtPoint возвращалось не только имя и фамилию пользователя, но еще и его адрес.
3079.68 3085.20 "Игорь Лабутин" Нет таких feature-requests, просто пишешь еще дополнительный адрес в запросе, и тебе адрес тоже вернется, если он есть там.
3085.20 3086.20 "Игорь Лабутин" Шикарно.
3086.20 3098.92 "Игорь Лабутин" Второе, соответственно, поскольку теперь можно таким же образом просить вложенный коллекции, то есть дай мне все посты плюс все комментарии к ним, а к ним их автор, то это избавляет от нескольких запросов.
3098.92 3103.16 "Игорь Лабутин" Делаешь один запрос, и тебе летит вся большая JSON-коллекция результата.
3103.16 3108.52 "Игорь Лабутин" Дальше тот факт, что схема строго определена, позволяет тебе на клиенте на самом деле делать...
3108.52 3116.44 "Игорь Лабутин" Ну, скажем так, клиент может спросить у сервера, что он умеет с точки зрения, а вот ты упользовать его не умеешь, показывай адрес.
3116.44 3117.96 "Игорь Лабутин" Ждал, у этих пользователей умею.
3117.96 3118.96 "Игорь Лабутин" Окей, тогда дай адрес.
3118.96 3120.96 "Игорь Лабутин" Если не умеешь, тогда не буду просить адрес.
3120.96 3123.24 "Игорь Лабутин" В случае с REST'ом такое сложно сделать.
3123.24 3125.52 "Игорь Лабутин" Так, про контракты поговорили.
3125.52 3133.64 "Игорь Лабутин" У вас единственный endpoint, нет больше никаких десятков endpoints, кеты, посты, путы, патчи, делиты, вот это все.
3133.64 3143.20 "Игорь Лабутин" Endpoint один, клиент счастлив, контейнеры счастливы, не надо никакого сложного выбора, где какие глаголы использовать, пост один, вот и все.
3143.20 3144.20 "Игорь Лабутин" Все замечательно.
3144.20 3155.40 "Игорь Лабутин" Для большинства источников данных, то есть баз данных, сервисы, REST-сервисы, на самом деле уже существуют резолверы более-менее готовые, которые нужно только настроить от себя.
3155.40 3156.40 "Игорь Лабутин" Вот.
3156.40 3163.12 "Игорь Лабутин" И возможно только если у вас есть какая-то совсем прям старая-старая API, для которой у нее существует резолвер, ну придется написать сами.
3163.12 3165.28 "Игорь Лабутин" Так, в принципе, довольно много готовых.
3165.28 3172.08 "Игорь Лабутин" Схема stitching позволяет при этом не городить огромную, монструозную, единую JSON-схему вообще на весь...
3172.08 3178.84 "Игорь Лабутин" на весь продукт, а вот продукт может быть очень большой, отобрать ее из кусочка.
3178.84 3188.84 "Игорь Лабутин" Да, нужно, конечно, договориться о домене, чтобы пользователь назывался более-менее одинаково в одном и том же бизнес-домене, но это, в принципе, неплохая практика сама по себе.
3188.84 3199.84 "Игорь Лабутин" И в принципе, в качестве плюса приводится тот факт, что вообще говоря, GraphQL используется в больших компаниях, хотя там, я их там, ну вот Facebook точно использует, потому что они сами его и делали.
3199.84 3204.08 "Игорь Лабутин" Я так сходу даже не назову, кто еще использует, но может быть я просто мало знаю о GraphQL.
3204.08 3205.08 "Игорь Лабутин" Но это были плюсы.
3205.08 3206.08 "Игорь Лабутин" Есть еще минусы.
3206.08 3213.08 "Игорь Лабутин" И минусы на самом деле такие, они очень легко формулируются, но с ними довольно сложно и непонятно, что делать.
3213.08 3219.08 "Игорь Лабутин" Во-первых, в минусы заносится тот факт, что язык запросов он все-таки немножко специфичный.
3219.08 3231.08 "Игорь Лабутин" То есть с одной стороны, как JSON, а с другой стороны, как бы не совсем JSON, он не следует синтезирующему JSON, и поэтому нужна все-таки отдельная библиотечка, как их формировать.
3231.08 3238.08 "Игорь Лабутин" Ну, нужно какие-то ненулевые усилия прикладывать, чтобы формировать эти реквесты в GraphQL Endpoint.
3238.08 3243.08 "Игорь Лабутин" Под подписки, соответственно, никакого там long polling и так далее, только веб-сокеты.
3243.08 3246.08 "Игорь Лабутин" Нет авторизации, как я сказал, на веб-сокетах.
3246.08 3252.08 "Игорь Лабутин" Для обычных query и для mutations там просто обычная HTTP авторизация используется, там вопросов нету.
3252.08 3256.08 "Игорь Лабутин" Проблема GraphQL в том, что нету стандарта для фильтринга и пейджинга.
3256.08 3275.08 "Игорь Лабутин" Если в вашей HTTP-реквестах, ну, есть тоже несколько подходов, ну, по крайней мере, там все более-менее договариваются, например, query-опция, там да, skip и take в дешевом таком духе, и более-менее все работает, и sorting, соответственно, тоже можно договориться, то в GraphQL стандарта никакого нету, и каждая библиотечка просит это сделать по-своему.
3275.08 3280.08 "Игорь Лабутин" Это тоже небольшой минус, хотя если бы как бы одну выбрали, ну, скорее всего, весь продумывают на ней.
3280.08 3303.08 "Игорь Лабутин" Минус для современной системы в том, что не все реализации GraphQL поддерживают нормальный логин и трейсинг, то есть не все корректно обрабатывают входящие, что-то по-моему, эти вот кодера правильные и не очень правильные с точки зрения там v3c, не v3c, open, трейсинг и все остальные, и не все генерят правильные логи с правильной correlation.
3303.08 3311.08 "Игорь Лабутин" Это может помешать вам отлаживать какие-то сложные сценарии, когда вам нужно отследить полный жизненный цикл запроса от клиента до самых низов.
3311.08 3325.08 "Игорь Лабутин" И самый, наверное, большой минус, который всегда звучит, когда производят GraphQL, это то, что поскольку клиент формирует запрос, то клиент может на самом деле сформировать какой-нибудь офигенно сложный запрос, который просто положат вам в сервер.
3325.08 3335.08 "Игорь Лабутин" Ну, положат, не положат, но если ваш сервер будет занят исполнением множества сложных запросов, которые клиенты по неопытности или по незнанию или из-за ошибок в коде нагенерили, то будет нехорошо.
3335.08 3346.08 "Игорь Лабутин" С этим можно бороться, там аут на сервере, так далее, но это все полумера, и, вероятно, нужно каким-то образом анализировать эти запросы по их приходу.
3346.08 3354.08 "Игорь Лабутин" Я, честно скажу, не знаю, есть ли какие-то тубы, которые позволяют вам в рантайме понять, а этот запрос будет слишком сложный, и не надо его выполнять.
3354.08 3367.08 "Анатолий Кулаков" Ну, слушай, ты же наверняка сталкивался, давай представим, что сейчас наш Джереми Ликнес не слушает, и вот поговорим откровенно, ты же наверняка сталкивался с какими-нибудь приложениями, которые выставляют голую базу данных попой к UI-компонентам.
3367.08 3369.08 "Анатолий Кулаков" То есть, по сути, это то же самое есть.
3369.08 3381.08 "Анатолий Кулаков" Вы берете UI-компоненты, вы берете маляров, которые там у вас красят кнопочки, и заставляете их формировать запросы к вашему хранилищу, к вашему базе данных, к святым, к биллингу, может, к вашему.
3381.08 3383.08 "Анатолий Кулаков" Говорите, да идите, запрашивайте все, что хотите.
3383.08 3388.08 "Анатолий Кулаков" У нас там история может быть за 10 лет назад, вы можете ее все без проблем запросить.
3388.08 3391.08 "Игорь Лабутин" Ну, она будет запрашиваться несколько часов, запросится.
3391.08 3403.08 "Анатолий Кулаков" Да, может быть, запросится, при этом займет всю память, положит все остальные сессии, не даст никому работать на этом сервере, и много-много других интересных фидбэков вы потом получите.
3403.08 3416.08 "Игорь Лабутин" Встречал такие системы, но почему-то, не знаю, у меня вот есть ощущение, что когда ты делаешь это в таком клиент-сервером варианте, я сюда, ты много не работал, честно скажу, поэтому не знаю.
3416.08 3424.08 "Игорь Лабутин" У меня такой опыт только с десктопными системами, где как-то понятно, что ты вроде один, ну, кажется, что ты один, да, ты же один на десктопе, и не важно, что там в этой базе ходит еще много народа.
3424.08 3433.08 "Игорь Лабутин" И как-то, ну, психологически было понятно, что ты запустил какую-то операцию, но вроде как долго, ну, ладно, типа, пойду налью кофе, подожду.
3433.08 3438.08 "Игорь Лабутин" Не знаю, не было такого, чтобы прямо в продакшене как-то было плохо.
3438.08 3453.08 "Игорь Лабутин" А с фебом, ну, здесь же по сути веб получается, да, у тебя есть клиент, а есть где-то далеко непонятный сервер, лайтно очень мощный, но верим, что все сервера мощные, и интернет в среднем быстро работает, как бы я прошу все данные за 10 лет, а он что-то медленно, странно.
3453.08 3454.08 "Анатолий Кулаков" Не знаю, мне не понравилось.
3454.08 3480.08 "Анатолий Кулаков" Он не может быть бесконечно мощным, и тем более тебе нужно учитывать, что это не просто одно веб или десктоп-приложение, это приложение, которое грузит сервер, а этот сервер обслуживает несколько сессий, поэтому ты потенциально можешь навредить как бы всему Фейсбуку, если представим, у него там один большой мощный сервер стоит, ты начинаешь его грузить всякими делепыми запросами, на которые не построен индекс, которые не прооптимизированы там по трафику, которые еще что-то, и все, все остальные получают какие-то тормоза.
3480.08 3486.08 "Игорь Лабутин" Да, получают, и скорее всего, действительно, с этим можно бороться только а) тайм-аутами, б) каким-то анализом запросов.
3486.08 3490.08 "Игорь Лабутин" Я не могу представить тысячу способов, что с этим можно сделать.
3490.08 3512.08 "Игорь Лабутин" Наверное, существуют способы понять, что этот запрос слишком сложный, например, не знаю, по уровню вложности структуры данных, возможно, можно написать какие-то свои кастомные проверки, понимая, что вот тут нет смысла, бизнес, смысла просить больше X сущностей, а тут нет условия на количество сущностей, значит, наверное, или фильтра отсутствуют.
3512.08 3514.08 "Игорь Лабутин" Запрещено делать запросы без фильтра.
3514.08 3516.08 "Анатолий Кулаков" Ну, не всегда.
3516.08 3522.08 "Анатолий Кулаков" Есть же, например, сиквельные запросы, которые выполняются часами, потому что они случайно не попали в индекс.
3522.08 3528.08 "Анатолий Кулаков" Для этого тебе нужно посмотреть план, может быть, выпить чашечку чая с DBA, и так далее.
3528.08 3536.08 "Анатолий Кулаков" Ты же понимаешь, что те люди, которые на UI все это делают, схему вместе слепливают и прочие вещи, они этим заниматься не будут.
3536.08 3537.08 "Игорь Лабутин" Не будут.
3537.08 3539.08 "Игорь Лабутин" Этим будут заниматься пока это разработчики, все правильно.
3539.08 3547.08 "Игорь Лабутин" То есть, они получат этот запрос, скажут, ох, вы наворотили, ну и по-правильному они, конечно же, придут к ювелирщику и скажут, зачем вам столько данных.
3547.08 3554.08 "Игорь Лабутин" Ювелирщик скажет, мы не при делах, это нам клиент фильтровал, вот он хочет такие данные, ничего не знает.
3554.08 3557.08 "Игорь Лабутин" Ну и дальше пойдем думать, как с этим делать, что с этим делать.
3557.08 3564.08 "Игорь Лабутин" То есть, мне кажется, что если это реальный бизнес кейс, то пойдем думать, как этот реальный бизнес кейс привести в нормальный вид, чтобы такой запрос таки отрабатывать.
3564.08 3572.08 "Анатолий Кулаков" Вот, но обычно в этот момент у тебя, ты накладываешь какой-нибудь красивый индекс, допустим, который учитывает именно этот бизнес кейс, и все становится работать быстро.
3572.08 3577.08 "Анатолий Кулаков" Но проблема в том, что завтра туда добавится еще одно поле или еще одно условие, и опять все сломается.
3577.08 3585.08 "Анатолий Кулаков" Потому что, опять же, не задача UI решать то, какие запросы должны гонять к базе данных.
3585.08 3587.08 "Игорь Лабутин" Ну, а дальше все зависит от бизнеса.
3587.08 3594.08 "Игорь Лабутин" То есть, я был на проекте, где у нас такая ситуация встречалась, это был десктоп, правда, софт, но такая ситуация встречалась.
3594.08 3596.08 "Игорь Лабутин" Там ситуация в проекте была примерно такой.
3596.08 3605.08 "Игорь Лабутин" Если находилась комбинация фильтров, которая наработала не померно долго, ну, по каким-то разумным меркам, да, то это просто был, условно говоря, фичереквест.
3605.08 3606.08 "Игорь Лабутин" Вот такой запрос должен работать.
3606.08 3613.08 "Игорь Лабутин" То есть, это не то, что там плохо положили продакшен, просто что вот аналитики придумали новый запрос, они хотят, чтобы именно этот запрос работал быстро.
3613.08 3618.08 "Игорь Лабутин" Ну и где-то раз в месяц, раз в два месяца они придумали новый запрос, мы оптимизировали и под него тоже.
3618.08 3620.08 "Игорь Лабутин" Ну, проверяешь, старый тоже все еще работает.
3620.08 3621.08 "Игорь Лабутин" Так и жили, нормально.
3621.08 3631.08 "Анатолий Кулаков" Вот я тоже, в принципе, не сталкивался на практике с тем, как это работает, но я много очень сталкивался на практике с архитектурой, с архитектурой кода.
3631.08 3639.08 "Анатолий Кулаков" И в архитектуре у нас есть такой подход, как iQueryable, то есть выставлять из базы данных iQueryable или все-таки лепить спецификации.
3639.08 3642.08 "Анатолий Кулаков" Вот есть такая дилемма среди многих разработчиков.
3642.08 3655.08 "Анатолий Кулаков" И вот когда ты начинаешь выставлять iQueryable, то есть по сути ты выставляешь любую, возьмем OData, GraphQL, то есть вообще любой произвольный клиент может обратиться как угодно к твоим данным.
3655.08 3677.08 "Анатолий Кулаков" Когда ты выставляешь iQueryable, ты через несколько недель, месяцев пусть в продакшене начинаешь плакать горючими слезами, потому что всякие клиенты начинают запихивать в твой iQueryable такие запросы, под которые невозможно построить индекс, или это будет экономически невыгодно, или это невозможно просто сделать физически, то, что они так хотят и так они строят.
3677.08 3681.08 "Анатолий Кулаков" И именно поэтому появился такой подход, как specification.
3681.08 3690.08 "Анатолий Кулаков" То есть ты изначально говоришь те запросы, которые ты прооптимизировал, которые ты знаешь будут работать красиво, четко, отлаженно и проверенно.
3690.08 3695.08 "Анатолий Кулаков" И если вам вдруг нужен какой-то еще один такой запрос, это, как ты и сказал, feature request.
3695.08 3708.08 "Анатолий Кулаков" Это нужно сделать спецификацию, наложить индекс, сделать какие-то шардинги на нее, сделать какую-то репликацию, может быть еще что-то придумать, но это уже отдельная задача для отдельного специалиста, который будет о ней думать.
3708.08 3714.08 "Анатолий Кулаков" Это не просто так, что формашлеп поковырялся в носу, передвинул кнопку слева-направо и решил запросить еще третье поле.
3714.08 3716.08 "Анатолий Кулаков" И у вас как бы лег весь кластер.
3716.08 3718.08 "Анатолий Кулаков" Это так не должно работать.
3718.08 3725.08 "Игорь Лабутин" Вот именно поэтому GraphQL, мне кажется, не обрел еще такую популярность как раз, поэтому посмотрим, куда приведет.
3725.08 3737.08 "Игорь Лабутин" Говоря про Equariable, последний раздел статьи называется GraphQL.net, то есть непосредственно все, что было до этого, на самом деле общее описание GraphQL я применю вообще к любому языку, о чем бы я ни писал.
3737.08 3738.08 "Игорь Лабутин" А вот что в .net?
3738.08 3741.08 "Игорь Лабутин" В .net есть библиотечка под названием GraphQL.net.
3741.08 3750.08 "Игорь Лабутин" Почему-то многие считают, что она написана Microsoft, но это неправда, это просто какие-то ребята пишут в open source библиотечку, но так называется, типа, прикольно.
3750.08 3756.08 "Игорь Лабутин" Похоже на JSON.NET, которое, собственно, написано Microsoft до некоторой степени.
3756.08 3760.08 "Игорь Лабутин" Соответственно, GraphQL.net тоже почему-то альтернатива Microsoft, но это не так.
3760.08 3770.08 "Игорь Лабутин" Она неплохая, есть альтернатива, и это HotChocolate, где Майкл Стайп, наверное, вы его доклад найдете, наверное, в наибольшем количестве на тему HotChocolate.
3770.08 3775.08 "Игорь Лабутин" Это сервер GraphQL, и есть, ты упоминал про Equariable?
3775.08 3784.08 "Игорь Лабутин" Есть, короче, ну, где-то пакет называется GraphQL.init.framework, который позволяет Equariable выставить напрямую в резолвере в GraphQL.
3784.08 3792.08 "Игорь Лабутин" То есть, видимо, приходит запрос от GraphQL, по сути, который транслируется напрямую в Equariable, тоже приходилось делать.
3792.08 3796.08 "Игорь Лабутин" Пронтендеры могут писать практически любые запросы к Equariable напрямую в EF Core.
3796.08 3799.08 "Анатолий Кулаков" Да, это похоже на connection к OData, который был.
3799.08 3802.08 "Анатолий Кулаков" Он тоже мог Equariable превратить в любую OData.
3802.08 3804.08 "Игорь Лабутин" Да, ну вот, в общем, как раз-таки в эту сторону.
3804.08 3831.08 "Игорь Лабутин" Смотрите, если вам что-то интересно, потрогайте руками, и крайне рекомендую это сначала потрогать до того, как вы подтащите этот проект, попробовать что-нибудь небольшое запихать, тяжелые запросы погонять, потому что... и вообще поизучать эту тему, как это делается во фреймворке, потому что каждый из этих серверов, о которых я говорил, GraphQL, Net, HotChocolate, и есть наверняка еще реализации, они наверняка подходят немножко по-разному к тому, как ограничивать клиентов, и как не допускать совсем адовый перегруз к серверам.
3831.08 3836.08 "Игорь Лабутин" При этом, с GraphQL есть еще одна проблема, о которой я упоминал, это клиенты.
3836.08 3858.08 "Игорь Лабутин" Нужно уметь писать эти запросы, поэтому для того, чтобы обрешить эту задачу, практически все сервера имеют в той или иной степени какую-то парную клиентскую библиотеку, по крайней мере, HotChocolate точно имеет, но если вы возьмете клиентскую HotChocolate, а сервер GraphQL, Net, не факт, что они там будут на 100% совместимы, все проверяйте сначала на тестах.
3858.08 3860.08 "Игорь Лабутин" Вот такие пироги про GraphQL.
3860.08 3879.08 "Анатолий Кулаков" Ясненько. Так, мы тут еще немножко в комментариях подумали, кстати, приходите на наши комментарии, в YouTube или в других социальных сетях, и подумали и решили, что нам не хватает каких-нибудь историй про инструменты, которыми пользуются разработчики, и вот как раз, кстати, Andrew Log выпустил отличную статью про один из таких замечательных инструментов.
3879.08 3881.08 "Анатолий Кулаков" Давайте начнем сначала.
3881.08 3885.08 "Анатолий Кулаков" Случилось так, что Andrew Log вдруг захотел написать хук GitHub.
3885.08 3895.08 "Анатолий Кулаков" Для тех, кто не в курсе, GitHub предоставляет такой специальный интерфейс веб-хуков, который позволяет вам получать события, нотификации о том, что творится в вашем репозитории.
3895.08 3897.08 "Анатолий Кулаков" Абсолютно все там покрыто.
3897.08 3909.08 "Анатолий Кулаков" То есть, если кто-то создал pull request, завел новый issue, оставил комментарий, или зачекинил commit, или еще что-то сделал для того репозитория, на который вы подписали веб-хук, вы это можете узнать.
3909.08 3917.08 "Анатолий Кулаков" Вы можете узнать это в своем приложении с помощью строго типизированных, красивых, хороших рест-запросов.
3917.08 3924.08 "Анатолий Кулаков" Итак, чтобы такую штуку провернуть, вам необходимо пройтись в свою репозиторию на GitHub и создать новый веб-хук.
3924.08 3932.08 "Анатолий Кулаков" В качестве адреса, куда будут отсылаться данные о произошедшем событии, GitHub вас непременно просит URL.
3932.08 3938.08 "Анатолий Кулаков" После того, как вы введете URL, выберите событие, которое вас интересует.
3938.08 3944.08 "Анатолий Кулаков" Можно принимать все множество возможностей GitHub, но, скорее всего, вам этого не нужно.
3944.08 3949.08 "Анатолий Кулаков" Вам хватит буквально некоторых событий, с которыми имеет работать ваше приложение.
3949.08 3951.08 "Анатолий Кулаков" Вот там эти события вы можете выбрать.
3951.08 3952.08 "Анатолий Кулаков" В принципе, это все.
3952.08 3959.08 "Анатолий Кулаков" Этого достаточно для того, чтобы вы уже смогли что-то получать, потестировать немножко и делать какие-то приложения.
3959.08 3962.08 "Анатолий Кулаков" А делается на основании веб-хуков очень много всего.
3962.08 3964.08 "Анатолий Кулаков" Очень много интеграций.
3964.08 3967.08 "Анатолий Кулаков" Вы их можете найти, например, в GitHub Marketplace.
3967.08 3974.08 "Анатолий Кулаков" Но, в частности, наверное, каждый из тех, кто пользовался GitHub, сталкивались с Continuous Integration и Continuous Delivery.
3974.08 3978.08 "Анатолий Кулаков" Вот эти вещи - это типичные представители того, что можно сделать с хуками.
3978.08 3995.08 "Анатолий Кулаков" То есть, если вы делаете новый commit в вашу ветку, третисторонний сервис, который вообще никак не связан с GitHub, может получить по веб-хуку нотификацию, сбилдить ваши срцы, посмотреть код-коверидж, сделать вам какую-нибудь красивую картинку, опубликовать это все в вашем Redmi файле.
3995.08 3999.08 "Анатолий Кулаков" Вот это типичная схема, которая работает через веб-хуки.
3999.08 4003.08 "Анатолий Кулаков" Есть небольшая проблемка с веб-хуками - это тестирование.
4003.08 4014.08 "Анатолий Кулаков" То есть, допустим, вам нужно потестировать свое приложение, оно правильно обрабатывает их веб-хуки, хорошо парсит, хорошо принимает, и как-то эти данные хорошо обрабатывает.
4014.08 4021.08 "Анатолий Кулаков" Проблема в том, что когда вы запускаете ваше приложение для отладки, обычно оно поднимается на локал-хосте.
4021.08 4028.08 "Анатолий Кулаков" То есть, изначально вы его никуда не деплоите, и оно у вас сделано вот прямо здесь, на вашем компьютере.
4028.08 4033.08 "Анатолий Кулаков" Проблема в том, что ваш локал-хост никаким образом не светится в интернет.
4033.08 4036.08 "Анатолий Кулаков" То есть, GitHub к нему доступиться обычно не может.
4036.08 4039.08 "Анатолий Кулаков" Это очень небезопасно по многим причинам.
4039.08 4044.08 "Анатолий Кулаков" Есть огромное количество причин так не делать, и обычно так не делают.
4044.08 4055.08 "Анатолий Кулаков" Но если GitHub не может на указанный вами URL локал-хоста послать необходимую информацию, ваш локал-хост никогда не узнает о том, что в GitHub что-то произошло.
4055.08 4058.08 "Анатолий Кулаков" Эта проблема решается с помощью тоннелинга.
4058.08 4063.08 "Анатолий Кулаков" Это специальная техника, которая делает такую довольно несложную и очевидную вещь.
4063.08 4077.08 "Анатолий Кулаков" Она открывает коннекцию, она открывает соединение между вашим локальным компьютером и специальным сервером в интернете, который доступен публично всем вокруг, и все могут к нему обратиться, в том числе и ваш компьютер.
4077.08 4084.08 "Анатолий Кулаков" И также открывается второе соединение между публичным сервисом в интернете и, соответственно, GitHub для примера.
4084.08 4089.08 "Анатолий Кулаков" Это может быть не только GitHub, это может быть абсолютно любой другой сервис.
4089.08 4095.08 "Анатолий Кулаков" После открытия такого тоннеля вы, соответственно, можете уже обрабатывать хуки.
4095.08 4105.08 "Анатолий Кулаков" То есть GitHub работает не с вашим локальным хостом, а он посылает свое событие непосредственно публичному endpoint, который светится в интернете.
4105.08 4119.08 "Анатолий Кулаков" Публичный endpoint держит локальное соединение с вашим локальным сервером, так называемый тоннель, и через этот тоннель уже присылает вам все необходимые данные, все, что прислал GitHub, без каких-либо повреждений или модификаций.
4119.08 4130.08 "Анатолий Кулаков" И таким образом вы, соответственно, можете строить тоннели не только для GitHub, но и для любых других ресурсов, которые требуют хоть какой-то URL для того, чтобы с ним взаимодействовать.
4130.08 4139.08 "Анатолий Кулаков" Например, чат-боты какие-нибудь, сервисы, нотификации о почте, в общем, WebHookie - это такой стандартный формат в интернете.
4139.08 4147.08 "Анатолий Кулаков" Вы сможете найти огромное количество сервисов, которые умеют работать с другими приложениями, умеют интегрироваться через WebHookie.
4147.08 4162.08 "Анатолий Кулаков" И, соответственно, с помощью подобных инструментов, подобного тоннелинга, вы можете сделать проброс на вашу локальную машину и под дебаггером, непосредственно в вашей студии, уже посмотреть, что же вам все-таки пришло, и как ваше приложение с этим работает.
4162.08 4168.08 "Анатолий Кулаков" Существует на рынке огромное количество таких инструментов, таких программ, для того, чтобы сделать тоннель.
4168.08 4170.08 "Анатолий Кулаков" У них есть разные свойства.
4170.08 4179.08 "Анатолий Кулаков" Некоторые заставляют вас проинсталлировать какой-то пакет, некоторые заставляют залогиниться, некоторые дают какие-то коммерческие предложения за дополнительные фишки.
4179.08 4183.08 "Анатолий Кулаков" Одним, наверное, из самых популярных на данный момент является Ngrok.
4183.08 4190.08 "Анатолий Кулаков" Очень многофункциональное приложение, много всего умеет, в принципе, хорошая документация, красиво описан, очень много туториалов в интернете.
4190.08 4194.08 "Анатолий Кулаков" Но есть свои плюсы у него и свои минусы.
4194.08 4200.08 "Анатолий Кулаков" Эндрю все-таки выбрал другой хост, малоизвестен пока, по крайней мере, я о нем никогда не слышал до этой статьи.
4200.08 4202.08 "Анатолий Кулаков" Это localhost.run.
4202.08 4214.08 "Анатолий Кулаков" Это тоже публичный веб-сервер, он прост в использовании, он не заставляет скачивать каких-то клиентов, и ему для него не нужно логиниться, заводить вообще новый аккаунт.
4214.08 4219.08 "Анатолий Кулаков" То есть вы можете непосредственно, без всякой дополнительной регистрации, просто взять и начать его использовать.
4219.08 4222.08 "Анатолий Кулаков" И это одно из главных преимуществ данного сервиса.
4222.08 4225.08 "Анатолий Кулаков" Для того, чтобы его заиспользовать, вам необходим SSH-клиент.
4225.08 4231.08 "Анатолий Кулаков" Обычный SSH-клиент уже предустановлен во всех операционных системах, в том числе Windows 10, он там есть.
4231.08 4245.08 "Анатолий Кулаков" Ну, если вам не повезло, то вы можете, в принципе, скачать любой SSH-клиент, сгенерить пару ключей SSH-ных, и просто-напросто приконектиться с своим клиентом к localhost.run, к этому сервису, указав необходимые ключики.
4245.08 4253.08 "Анатолий Кулаков" В ответ на это соединение localhost.run выдаст вам специальный уникальный URL, который никто не будет знать, кроме вас.
4253.08 4263.08 "Анатолий Кулаков" И именно этот URL вы укажете в GitHub, в строке, которая требует от вас обратный адрес для подсылания данных об ивенте.
4263.08 4277.08 "Анатолий Кулаков" Именно этот URL свяжет GitHub и localhost.run, а после этого, через вот этот туннелинг, который вы только что установили про SSH, localhost.run пришлет данные непосредственно на ваш локальный компьютер.
4277.08 4280.08 "Анатолий Кулаков" И вы сможете, соответственно, работать с этими данными.
4280.08 4289.08 "Анатолий Кулаков" Вот такой забавный инструмент, который очень часто может пригодиться разработчикам, но, мне кажется, не только разработчикам, может быть продвинутым каким-нибудь системоадминистратором или пользователем.
4289.08 4291.08 "Анатолий Кулаков" Он тоже часто может быть полезен.
4291.08 4300.08 "Игорь Лабутин" Да, я такие туры использовал для того, чтобы временно разрабатываемое приложение просто выставить наружу и дать кому-нибудь просто посмотреть без диплоя.
4300.08 4304.08 "Игорь Лабутин" То есть, это даже не обязательно в GitHub или в какие-то автоматизированные штуки.
4304.08 4309.08 "Игорь Лабутин" Просто даже человеку дать посмотреть, с б/у localhost, вполне удобно.
4309.08 4310.08 "Анатолий Кулаков" Да, да, точно.
4310.08 4322.08 "Анатолий Кулаков" И это, наверное, самый простой use case, когда вам нужно просто с локального компьютера сделать доступным какой-то порт и по этому порту отдать все что угодно, хоть веб-сайтик, хоть ваше приложение, хоть еще что-нибудь.
4322.08 4325.08 "Анатолий Кулаков" И удаленный человек может зайти посмотреть.
4325.08 4330.08 "Анатолий Кулаков" После этого вы этот SSH-туннель быстренько разрушаете, и все, секьюрити снова на месте.
4330.08 4331.08 "Игорь Лабутин" Да, прикольный тул.
4331.08 4337.08 "Игорь Лабутин" Тут конкретно localhost.run не использовал, и действительно, несколько раз использовал Andro и какие-то другие аналоги.
4337.08 4339.08 "Игорь Лабутин" Надо будет попробовать с SSH-ом.
4339.08 4340.08 "Игорь Лабутин" Прикольно.
4340.08 4347.08 "Игорь Лабутин" Давай последнюю тему, не из нетворкинга, но тоже от Андрю Лока, если я правильно помню.
4347.08 4350.08 "Игорь Лабутин" Да, я думаю, нам скоро нужно будет ввести
4350.08 4358.08 "Анатолий Кулаков" лимит в подкаст, там не более 1 или 2 статьи Андрю Лока, иначе он тут все заполонит, и мы станем с тобой официальными евангелистами Андрю Лока.
4358.08 4361.08 "Игорь Лабутин" Ну, хорошие статьи пишет товарищ, почему бы нет.
4361.08 4369.08 "Игорь Лабутин" Но на самом деле меня удивила эта статья, потому что я думал, что он прям нашел какую-то новую штуку, которую я не знал, но нет.
4369.08 4371.08 "Игорь Лабутин" Внимание, внимание.
4371.08 4377.08 "Игорь Лабутин" Даже очень продвинутые, крутые чуваки могут не знать всего в той технологии, на которой они пишут.
4377.08 4384.08 "Игорь Лабутин" Андрю Лок внезапно узнал о существовании атрибута conditional в дотнете, которая живет аж со времен фреймворка 1.1.
4384.08 4390.08 "Анатолий Кулаков" Ну, если Андрю Лок узнал, то, наверное, среди наших слушателей тоже найдутся люди, которые никогда не всталкивались, не встречались с этим атрибутом.
4390.08 4392.08 "Анатолий Кулаков" Давай вкратце расскажем, а что это такое.
4392.08 4400.08 "Игорь Лабутин" Да, значит, давай начнем немножко издалека и вспомним, что в дотнете, хоть мы и не СПР+, в нем все еще есть препроцессор.
4400.08 4405.08 "Игорь Лабутин" Это всякие такие штуки, которые начинаются с решетка что-нибудь и директивы препроцессора.
4405.08 4411.08 "Игорь Лабутин" И в частности, сегодня нам интересна директива решетка if, которая позволяет нам сделать условную компиляцию.
4411.08 4428.08 "Игорь Лабутин" То есть, если вы хотите какой-то кусочек кода почему-то выкинуть из компилированного кода, то вы можете обрамить его в решетка if и решетка endif, и он будет вкомпилирован только если компилятор определяет тот символ, который вы указали после if.
4428.08 4438.08 "Игорь Лабутин" То есть вы можете написать if debug, и если в компиляторе, например, debug символ определен, в настройках, имеется в виду, компилятор, то этот кусочек кода окажется в вашей итоговой деле.
4438.08 4441.08 "Игорь Лабутин" Если не определен, то этого куска вообще целиком совсем не окажется.
4441.08 4443.08 "Игорь Лабутин" Довольно простая логика.
4443.08 4478.08 "Игорь Лабутин" И долгое время в классическом фреймворке эта штука была нужна, но очень редко, просто потому что мы все жили на Windows, и такая вот conditional compilation в основном была нужна, я видел, два кейса, либо какой-то совсем отладочную информацию, типа if debug, либо когда мы таким образом, допустим, включаем-выключаем фичи, то есть какие-то кусочки, мы собираем, например, несколько версий библиотеки с поддержкой разных фич, и чтобы им нельзя было идти какими-то окольными путями, даже попытаться вызвать, они были запихнуты в каких-то и даже не компилированы.
4478.08 4494.08 "Анатолий Кулаков" Ну если вы станете смотреть код официального дотнета или библиотек микрософта, то там вы как раз-таки можете очень много увидеть использования директив при процессоре в качестве специальных флагов для включения-выключения фич.
4494.08 4518.08 "Игорь Лабутин" Но с приходом дотнет-кора условная компиляция обрела вторую молодость, потому что мы стали писать мультитаргетные проекты, то бишь, которые собираются и для, допустим, классического фреймворка, и для дотнет-кора, или вообще для нет-стендарта, или для нескольких версий нет-кора и нескольких версий полноценного фреймворка, и так далее.
4518.08 4528.08 "Игорь Лабутин" На самом деле, SDK вам определяет довольно большое количество символов, которые вы можете использовать для того, чтобы определить, для какой платформы вы сейчас собираетесь.
4528.08 4534.08 "Игорь Лабутин" Есть символы типа net461, netcoreup, netcoreup3_1, net5, ну и так далее.
4534.08 4539.08 "Игорь Лабутин" То есть, почитайте официальную документацию майкрософта, там они все перечислены.
4539.08 4550.08 "Игорь Лабутин" И, как положено, что у вас есть кусочек кода, который вы не хотите, или он физически не может быть, например, скомпилирован по дотнет-кору, потому что такая фишка исчезла, например, что-нибудь про abdomen.
4550.08 4557.08 "Игорь Лабутин" Вы можете этот кусочек кода заплести в эту самую решетку и в net461 или framework, и все будет замечательно.
4557.08 4570.08 "Игорь Лабутин" Но дальше, если этот кусочек кода начнет разрастаться, вы его тут поддерживаете в таком виде, и функция начинает выглядеть очень некрасиво, особенно с учетом того, что директивы при процессоре часто пишутся, начиная с первой колонки, не глядя на отступы.
4570.08 4581.08 "Игорь Лабутин" Выглядит все это достаточно, ну, скажем так, грязно, и поэтому такие методы, которые платформ-специфик, они обычно, точнее, коды, которые платформ-специфик, выделяются обычно в отдельные методы.
4581.08 4583.08 "Игорь Лабутин" И тут возникает задача.
4583.08 4588.08 "Игорь Лабутин" Нам вот этот метод хотелось бы вызвать на, допустим, на framework, а на netcore не вызывать, или на bar.
4588.08 4594.08 "Игорь Лабутин" Какие есть варианты? Во-первых, вы можете эти атрибутики решетка if расставить в каждой точке вызова этого метода.
4594.08 4599.08 "Игорь Лабутин" Плюс, очевидно, на той платформе, где метод вызывать не надо, у вас даже не будет на ничего вкомпилировано.
4599.08 4601.08 "Игорь Лабутин" Вы не тратите время на вызов метода.
4601.08 4611.08 "Игорь Лабутин" Но есть проблема, потому что если у вас есть внутри этого метода используется опишка, которая не доступна на какой-то из платформ, то код просто не скомпилится.
4611.08 4616.08 "Игорь Лабутин" Вы можете тело метода тоже записнуть внутрь решетка if, но это как-то уже перебор.
4616.08 4627.08 "Игорь Лабутин" Нужно не забывать, что само тело метода, ну ладно, тут компилятор подскажет, а второй момент, что вы во всех местах, где вызывается этот метод, нужно не забывать добавлять решетку if.
4627.08 4631.08 "Игорь Лабутин" Код довольно быстро становится таким довольно грязным, особенно если у вас много таких методов.
4631.08 4639.08 "Игорь Лабутин" И все будущие разработчики, которые будут смотреть на этот код, должны тоже знать, что если они вдруг решили, почему-то вызвать этот метод, нужно обязательно написать вокруг решетку if.
4639.08 4641.08 "Игорь Лабутин" Шанс, что тот забудет, очень великий.
4641.08 4643.08 "Игорь Лабутин" Можно сделать по-другому.
4643.08 4648.08 "Игорь Лабутин" Можно только тело метода обернуть в if, и не заботиться о тех местах, где он вызывается.
4648.08 4659.08 "Игорь Лабутин" Плюс, понятен, что мы не паримся о том, сколько раз он в игре вызывается, плюс второе, что мы можем использовать опишки, которые доступны только в нужной платформе, поскольку body заключен тоже в решетку if.
4659.08 4669.08 "Игорь Лабутин" Но проблема, что вызываются дополнительные, то есть ингенерируется код для вызова этого метода, и не факт, что Gits может его оптимизировать так, что он вообще не будет вызываться.
4669.08 4671.08 "Игорь Лабутин" Может оптимизировать, может не оптимизировать.
4671.08 4678.08 "Игорь Лабутин" Там есть разные юристики, которые непонятно как повлияют, а если у вас какой-то высокопроизводительный код, то это может актисироваться.
4678.08 4697.08 "Игорь Лабутин" Поэтому был придуман attribute conditional, он был придуман в .NET Framework 1.1, и по сути в нем внутри вы в аргументы конструктора этого атрибутчика передаете тот же самый символ, за который вы пишете в решетку if, то есть можно написать там conditional, открыл с кавычки, и в .NET Framework, с кавычки закрылась, ну и все это в квадратный скоб.
4697.08 4708.08 "Игорь Лабутин" И это будет означать, что тот метод, на котором вы его применили, во всех местах, где он вызывается, получит как бы неявный решетка if вокруг своего вызова.
4708.08 4709.08 "Игорь Лабутин" То есть что это означает?
4709.08 4719.08 "Игорь Лабутин" Если в момент кумпиляции тот символ, который указан в параметрах этого атрибута, не определен, то во всех местах вызова, этого вызова просто физически не будет.
4719.08 4730.08 "Игорь Лабутин" При этом сам метод останется в коде и будет скомпилирован, что автоматически означает, что фишка, которую они пользуются, которая они пользуются, должна быть доступна на всех платформах, которые вы компилируете.
4730.08 4740.08 "Игорь Лабутин" Если это неправда, вам внутри этого метода тоже придется делать решетка if, но это хорошо, ну в смысле это не так плохо, как случайно, потому что все это все равно делается в одном единственном месте.
4740.08 4747.08 "Игорь Лабутин" То есть вы ставите на методе атрибут conditional, тем самым гарантируете, что во всех местах вызова, этого вызова не будет при нужных условиях.
4747.08 4751.08 "Игорь Лабутин" Ну и дело метода рядышком заключения решетка if тоже неплохо.
4751.08 4764.08 "Игорь Лабутин" Очевидная проблема, что такая штука, ну не только проблема, а особенность, про которую просто нужно знать, что этот атрибут работает только на методах, которые ничего не возвращают, не имеют auto-параметров и так далее.
4764.08 4772.08 "Игорь Лабутин" По понятным причинам, если вызов этого метода полностью убирается из того места, где он вызывается, то вы не можете убрать там инициализацию переменных и так далее.
4772.08 4773.08 "Игорь Лабутин" Это нарушит логику программ.
4773.08 4777.08 "Игорь Лабутин" Поэтому только на void методах, без auto-параметров, такую штуку можно применять.
4777.08 4788.08 "Игорь Лабутин" И несмотря на то, что я знал, что этот атрибут есть и что его можно использовать на методах, я узнал, что его можно использовать и на классах тоже, но только на тех классах, которые отследуют от атрибутов.
4788.08 4803.08 "Игорь Лабутин" То есть на самом деле, если вы пишете свой кастомный атрибут, на этом атрибуте можно навесить атрибут conditional и тогда ваш атрибут будет применяться либо не применяться к классу в зависимости от тех символов, которые отбрали при компиляции и указаны в атрибуте conditional.
4803.08 4808.08 "Игорь Лабутин" Можно сделать свои, как бы кандидатики, исчезающие атрибуты при определенном условии.
4808.08 4809.08 "Игорь Лабутин" Может, зачем-то пригодится.
4809.08 4810.08 "Игорь Лабутин" Вот такая вот тема.
4810.08 4822.08 "Игорь Лабутин" Если вы вдруг не знали и если у вас вдруг код выглядит, как большая лапша из решетка и решетка и решетка и, посмотрите, может быть, атрибут conditional вам позволит это как-то более компактно записать.
4822.08 4834.08 "Анатолий Кулаков" Я могу признаться, что с тех пор, как перешел из C+ на C#, наверное, практически перестал использовать директивы при процессоре Shortcue-if.
4834.08 4839.08 "Анатолий Кулаков" Но здесь нужно учитывать, что я не пишу кроссплатформенный вот этот код, у меня нет множества платформ и так далее.
4839.08 4847.08 "Анатолий Кулаков" Наверное, единственный момент, где я использую именно символы компилятора, это дебаг или релиз.
4847.08 4862.08 "Анатолий Кулаков" И как раз-таки для того, чтобы какой-то метод, какие-то данные прочитать только в дебаге, какую-то информацию проверить только в дебаге, мне обычно хватает conditional_debug, атрибутика вместе с символом debug и, в принципе, все.
4862.08 4870.08 "Анатолий Кулаков" Поэтому очень-очень спасает от замусовывания конда по сравнению с моими плюсовыми файликами, насколько я могу вспомнить.
4870.08 4871.08 "Анатолий Кулаков" Да, полезная штука.
4871.08 4884.08 "Игорь Лабутин" У меня как раз conditional я использую мало, а вот if у нас довольно много используется, потому что мы собираем многие пакеты наши внутренние, но они должны собираться под, условно говоря, у них обычные три таргета.
4884.08 4888.08 "Игорь Лабутин" Это NAT4, NAT6, NAT7, NAT2, NAT0, и вот сейчас появился NAT5.
4888.08 4902.08 "Игорь Лабутин" И есть API, особенно это касается всяких API вокруг, там работы с сертификатами, вот этим всем, которые имеют просто разное поведение, и у них нужно дернуть разные методы у одних и тех же классов, если вы находите в разных платформах.
4902.08 4908.08 "Игорь Лабутин" Поскольку поведение это менялось даже в самом большом фреймворке, но и в Дотнадкоре оно тоже поменялось.
4908.08 4920.08 "Игорь Лабутин" Поэтому у нас там есть, да, if NAT4, NAT6, NAT1, позови вот это пропертию, чтобы получить private ключ, сертификат, иначе вызови метод, а иначе кинь exception, потому что в NAT стендарте этого сделать нельзя.
4920.08 4922.08 "Анатолий Кулаков" Да, типичный случай.
4922.08 4924.08 "Анатолий Кулаков" Ну что, давай закрываться.
4924.08 4925.08 "Игорь Лабутин" Давай закрываться.
4925.08 4927.08 "Игорь Лабутин" Сегодня действительно получился такой немножко нестандартный выпуск.
4927.08 4937.08 "Игорь Лабутин" Мы вообще не обсуждали никакие новости, но зато смогли обсудить некоторое количество статей, которые, как мне казалось, выглядели достаточно разнообразно, но в итоге выстроились в неплохую линию.
4937.08 4941.08 "Игорь Лабутин" Начали мы с антипаттернов в памяти, ну, какой бы то ни было, без перформанса.
4941.08 4946.08 "Игорь Лабутин" Мы не могли не обойти стороной темы перформанса, потому что мы ее любить и не умеем.
4946.08 4956.08 "Игорь Лабутин" Дальше мы смотрели огромный кусок про всяческие нетворки, начали с общего обсуждения про то, что вообще происходит в нетворке в Дотнете со специалистами из Microsoft.
4956.08 4965.08 "Игорь Лабутин" Посмотрели на gRPC в Дотнете, посмотрели на то, как новый райдер, япп, позволит дисковерить новые IPшки с помощью нового окошка endpoints.
4965.08 4978.08 "Игорь Лабутин" Тронули графку L, которую мы практически не трогали в этом подкасте, посмотрели, как ваши вокальные сайтики, или приложения, или еще что-нибудь выставляют наружу большой интернет с помощью Localhost.ru и SSH.
4978.08 4988.08 "Игорь Лабутин" Ну и в конце заполировали старой темой, тем не менее, даже я нашел себе что-то новенькое, в виде conditional-атрибутов, и напомнили затем нужные директивы при процессоре.
4988.08 4989.08 "Игорь Лабутин" Такие дела.
4989.08 4991.08 "Анатолий Кулаков" Ну, а на этом все.
4991.08 4993.08 "Анатолий Кулаков" Большое спасибо, дорогие друзья, что слушали нас.
4993.08 4999.08 "Анатолий Кулаков" Расшарьте нас между друзьями, лайк, репост, 5 звездочек, всячески мы ценим вашу поддержку.
4999.08 5001.08 "Анатолий Кулаков" И до новых встреч, пока.
5001.08 5002.08 "Анатолий Кулаков" Пока.
