0.00 13.06 SPEAKER_01 Здравствуйте, дорогие друзья, в эфире Radio.net, в студию несменный ведущий Анатолий Кулаков.
13.06 14.92 SPEAKER_01 И Игорь Лабутин, всем привет.
14.92 30.14 SPEAKER_01 А за нашими спинами также бессмертные помогаторы – это Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин и Ольга Бондаренко.
30.14 36.00 SPEAKER_01 Спасибо большое, друзья, что нас поддерживаете, а всякие… также тех, кто пожелал остаться неизвестными.
36.00 40.02 SPEAKER_01 Так, ну что, пойдем сразу к темам.
40.02 44.50 SPEAKER_01 Мы хорошо отдохнули, так что практически, наверное, ничего не читали.
44.50 56.58 SPEAKER_01 Да, мы действительно очень хорошо отдохнули, но Майкрософт тоже отдохнул довольно хорошо, поэтому я, честно говоря, ожидал, что у нас будет там пара релизов в студии, не знаю, хотя бы один релиз уже девятого превью.
56.58 64.26 SPEAKER_01 Но, тем не менее, нет, ничего такого нету, но есть чуть-чуть совсем новостей от Майкрософта, о котором мы сегодня и пройдемся.
64.26 66.90 SPEAKER_01 Ну и не только от Майкрософта, конечно же.
66.90 73.98 SPEAKER_01 Начнем мы с того единственного превью, который нам все-таки подарил Майкрософт, а именно .NET Aspire превью.
73.98 127.58 SPEAKER_01 Напомню, что .NET Aspire зарелизили на .NET Conf в конце, в ноябре, соответственно, прошлого года, и .NET Aspire — это такая штука, которая призвана облегчить ваш труд на локалхосте, то есть когда вы разрабатываете какое-то cloud native приложение, состоящее из большого количества или не очень большого количества микросервисов, плюс эти микросервисы могут зависеть от каких-то инфраструктурных компонентов, как-то какой-нибудь там рейтинг для кэширования, база данных для хранения данных, очевидно, и для того, чтобы весь этот зоопарк как-то легко и непринужденно поднимать на локальном хосте, у вас была опция использовать какой-нибудь Docker Compose, ну или просто держать поднятыми, да, там железно поставленный PostgreSQL какой-нибудь и так далее, можно было использовать предыдущую наработку Майкрософта, это Project Time, который позволял худо-бедно как-то с помощью YAML-конфига все это поднимать и управлять.
127.58 131.18 SPEAKER_01 Ну, а можно использовать .NET Aspire, это...
131.18 145.38 SPEAKER_01 Слушай, Игорь, а тебе не кажется вот, что Aspire как раз сейчас закрывает именно две ниши и узнают его как раз по двум нишам, т.е. это конкурент Docker Compose, он же TIE, Project TIE, но больше на слуху это как раз-таки дэшборд.
145.38 152.30 SPEAKER_01 Т.е. когда тебе скажут одним словом опиши Aspire, тут не очень понятно, а что назвать, Compose или TIE, ты как думаешь, он больше что?
152.30 157.74 SPEAKER_01 Я думаю, что сейчас он все… т.е. смотри, для меня… Compose или дэшборд, да, правильно.
157.74 162.30 SPEAKER_01 Для меня это более полезно, что он дэшборд, я бы так сказал.
162.30 179.62 SPEAKER_01 Мне не впадло написать какой-нибудь простенький Docker Compose, который мне перманентно поднимет, не знаю, Redis, MySQL или Postgres, или с чем мы там работаем, SQL Server или еще кого-нибудь, держать постоянно этот Compose запущенным, а все мое приложение запускать тем же TIE или еще кем-нибудь.
179.62 191.70 SPEAKER_01 Т.е. мне более интересен он как дэшборд, единое место, где можно посмотреть логи, трейсы, что еще, метрики, и все это в одном окошке, связанное друг с другом и все такое прочее.
191.70 196.98 SPEAKER_01 Эта штука, несомненно, удобная, и меня она привлекает в каком-то смысле больше всего.
196.98 212.50 SPEAKER_01 Мне кажется, судя по хайпу, то у основного контингента тоже мнение совпадает полностью с твоим, потому что мало кто обсуждает, как он красиво между собой композит приложения, контейнеры, как они там, экзешники все вместе как-то работают вообще, мне кажется, всем наплевать.
212.50 217.82 SPEAKER_01 Всем больше интересуют дэшборды, как бы их выдрать оттуда, и все ишьюсы практически на гитхабе именно про это.
217.82 228.90 SPEAKER_01 Ну вот я не соглашусь про ишьюсы, потому что когда я читал ишьюсы, ну это правда было, наверное, недельки полторы назад, может, что-то поменялось, то там довольно много всего именно про деплоймент дальнейший.
228.90 238.26 SPEAKER_01 То есть когда-то давно, когда был project.ai, и если ты помнишь, у него была команда, типа, куда его, в кубер, по-моему, можно было задеплойтить, в общем, куда-то можно было задеплойтить.
238.26 239.26 SPEAKER_01 Конфиг?
239.26 240.26 SPEAKER_01 Да, в кубер.
240.26 241.26 SPEAKER_01 В кубер.
241.26 242.26 SPEAKER_01 Вот.
242.26 249.38 SPEAKER_01 Сейчас, соответственно, его можно задеплойтить в азер, ну очевидно, куда еще, но на самом деле деплоймент в азер, он происходит не напрямую.
249.38 262.90 SPEAKER_01 Aspire сделан таким образом, что вы пишете конфигурацию на C#, то есть, по сути, у вас добавляется новый проект в ваш solution, в котором вы описываете все ваши зависимости, все такое.
262.90 277.22 SPEAKER_01 А, ну еще, соответственно, там есть полезная штука, которую, наверное, вы, ну можно получить, но сложно в Docker Compose, это resolving зависимости, да, то есть вы просто указываете, что у вас есть где-то Redis, да, где на каком порту и так далее.
277.22 282.10 SPEAKER_01 Вся магия будет Aspire'ом сама сделана, ну детали.
282.10 292.78 SPEAKER_01 Короче, вы описываете всю эту конфигурацию, после чего у Aspire'а есть режим, когда вы можете его запустить так, что он просто сгенерит вам джейсоновый дамп этого конфига.
292.78 310.06 SPEAKER_01 И это, как бы, единственный вариант получить некоторое текстовое представление этого конфига, а вот дальше с этим джейсоночком можно сделать все, что угодно, например, написать tool, и Microsoft это сделали, который сконвертит этот джейсон в язык Bicep.
310.06 323.30 SPEAKER_01 Это такой человеческий вариант, как он называется, Azure ARM-темплейтов, там в ARM-темплейтах совершенно не читаемый джейсон Bicep, это такой более программистско-ориентированный язык, который позволяет это сделать.
323.30 348.54 SPEAKER_01 Кто-то, я где-то это видел, а может даже, кстати, в какой-то из статей было, про то, что, вот, наверное, это будет, кстати, в той статье, которую мы будем обсуждать в превью 2, про то, что кто-то из комьюнити написал штуку, которая умеет конвертить вот этот джейсон от Aspire в манифест к кубернетцу, называется она Aspirate, если кто-то хочет поискать.
348.54 350.26 SPEAKER_01 Пишется как Aspir и восьмерочка.
350.26 355.66 SPEAKER_01 Называется, ну да, Community Developed Tool for Deploying .NET Aspire Apps to Kubernetes.
355.66 379.22 SPEAKER_01 То есть, я так, и по E-шлифсам видно, что народу вот это вот deployment часть тоже хочется, причем там были просьбы, что-то типа, слушайте, а можно вот весь этот control plane, да, ваш, вот нам даже дешборд не очень нужен, а можно вот вместо того, чтобы мы взяли какой-нибудь миникуб, да, ну то есть ты хочешь входиться в кубернет, но тебе не нужен полноценный кубернет, ты берешь миникуб, например.
379.22 381.98 SPEAKER_01 И вот вместо него использовать вот эту штуку из Aspire.
381.98 386.30 SPEAKER_01 Ну типа она более легковесная, более какая-то простая, вот это все.
386.30 387.82 SPEAKER_01 Ну теоретически, да, почему бы и нет.
387.82 395.06 SPEAKER_01 Ну вот, короче, есть, кажется, что в комьюнити несколько направлений того, куда может действительно развиваться игра.
395.06 401.30 SPEAKER_01 У Microsoft есть какие-то свои планы, видения на то, что они хотят из этого продукта получить.
401.30 406.50 SPEAKER_01 В общем, жизнь покажет, я бы сказал.
406.50 409.90 SPEAKER_01 Да, давай тогда посмотрим, что там Microsoft нам предлагает.
409.90 410.90 SPEAKER_01 Что он заносил?
410.90 411.90 SPEAKER_01 Да, что он заносил?
411.90 434.18 SPEAKER_01 Заносил с превью 2, по сути, это некоторые, как я послушал в подкасте, да, еще один off-topic, надо, кстати, будет ссылочку добавить, я, по-моему, не добавлял, буквально недавно вышел эпизод «DotNet Rocks» с Дэвидом Фаулером, который один из, я так понимаю, авторов и идеологов-вдохновителей всего «DotNet Aspire», как раз он здесь был про «DotNet Aspire».
434.18 450.42 SPEAKER_01 И вот он там рассказывал, что во многом это все, конечно, мотивировано там и тем, что мы делали в ТАЕ, и немножко это мы посмотрели на Pulumi, который как раз-таки конфигурация в C#, на C# может в том числе описаться.
450.42 470.44 SPEAKER_01 Мы поняли, что можно описывать такую конфигурацию на языке опрограммирования не только в YAML, и в общем там как раз он немножко рассказывает про то, что превью 1 мы выпустили в каком-то смысле вопреки всем нормам обычного нормального программирования прямо перед праздниками.
470.44 473.82 SPEAKER_01 Ну типа никто не релизит, да, прямо перед праздниками.
473.82 486.66 SPEAKER_01 Ну мы типа сделали перед праздниками, по сути, превью 2 — это такая работа над ошибками, и в идеале бы у него прозвучала какая-то такая фраза, что именно вот превью 2 должно было стать тем, что мы как бы первый раз бы зарелизили бы.
486.66 492.30 SPEAKER_01 Ну так получилось, короче, ладно, значит, получилось следующее.
492.30 498.62 SPEAKER_01 Довольно много изменений, которые, как обычно, у Майкрософта аккуратненько сгруппированы в красивую статью.
498.62 510.38 SPEAKER_01 И первый раздел — это дэшборд, тот самый дэшборд, который позволяет вам действительно посмотреть, как чувствует ваше приложение, как он себя ведет, оно себя ведет, какие у него логи, трейсы, вот это все.
510.38 535.30 SPEAKER_01 И там есть следующая штука, в превью 1 все ресурсы, которые могут быть, которыми может управлять Aspire, это всякие проекты, исполнимые файлы, проекты имею в виду csproj, контейнеры, они все были разнесены на разные вкладочки, и поэтому у вас не было такого места, где вы могли в едином каком-то таком окошке, в едином списке увидеть всех, сразу все компоненты вашего приложения.
535.30 544.30 SPEAKER_01 Теперь это все называется ресурсес, и там прямо видно, ну в каждой строчке написано, кто это — экзекютабл, контейнер, csproj или еще что-нибудь.
544.30 559.82 SPEAKER_01 Точно такая же история постигла вьюшка консоль логс, там тоже теперь логи все агрегированы в единую вьюху, ну не в смысле, что они все идут прямо вперемешку, но их можно там пофильтровать, выбирать нужные вам компоненты, но если надо, можно посмотреть вообще все сразу.
559.82 570.54 SPEAKER_01 Они добавили во вью вывод лог категории name, но я так понимаю, что это то, что очень часто называется логер нейм, то, куда пишется логер нейм, что можно было тоже быстро фильтровать, говорят, это прям много кто хотел.
570.54 610.40 SPEAKER_01 И еще штука, которая довольно интересна, раньше, напоминаю, что Aspire — это в том числе штука про поиск зависимости, то есть вы внутри кода пишете, я хочу пойти в этом месте в Redis, ну в смысле, что мое дотнет-приложение зависит от Redis, под названием Redis просто, а что такое Redis определяется ресурсом по имени Redis, и как сконнектить Redis, запущенный в докере на каком-то рандомном порту, и ваше приложение, запущенное, как там, Cessproj, тоже на каком-то рандомном порту, чтобы оно подконнектилось к рандомному порту Redis, этим занимается Aspire.
610.40 626.06 SPEAKER_01 Так вот, до превью 2, если вы смотрите в трейсинг, у вас будет написано, что ваше дотнет-приложение пошло в Redis на порту, не помню, какой там дефолтный у Redis, но поскольку он рандомный, то скорее всего он пойдет на порт какой-нибудь там, не знаю, 18384.
626.06 640.14 SPEAKER_01 Так вот теперь, в превью 2, он понимает, что это на самом деле Redis, который он же сам и поднял, и поэтому в коде у вас это написано, что зависимость просто на Redis, он так и будет писать в трейсах теперь, что вот тут мы пошли на Redis, вот тут мы пошли на Redis 5, если у вас там их 5 штук, например, и так далее.
640.14 666.30 SPEAKER_01 То есть во всех местах, где вы обычно будете видеть урлы, если этот урл относится к ресурсу, который управляется самим Aspire, Aspire, Aspire, интересно это какого рода слово, не знаю, странно его склонять на русском получается, то во всех местах вы будете видеть реальные названия ресурсов именно, а не какие-то просто рандомные порты, про которые вы не будете знать, которые будут отличаться от запуска к запуску.
666.30 668.94 SPEAKER_01 В общем, дашборд улучшился.
668.94 677.02 SPEAKER_01 Пока нет никаких следов того, что они его как-то пытаются вынести совсем наружу, я, по крайней мере, не нашел.
677.02 678.02 SPEAKER_01 В вышлицах тоже пока пишут.
678.02 680.26 SPEAKER_01 Ну, наверное, мы и сделаем, но пока не знаем, когда.
680.26 683.02 SPEAKER_01 То есть пока никто не соглашался официально?
683.02 699.54 SPEAKER_01 Не то, смотри, в вышлицах написано от имени ребят, которые работают в Microsoft, что мы типа рассматриваем эту возможность, но для того, чтобы она стала возможной, возможность возможной, нужно там нам переработать немножко нашу внутреннюю архитектуру.
699.54 706.78 SPEAKER_01 А как ты понимаешь, программист, под словами "мне нужно поработать над внутренней архитектурой" может оправдывать такое чем угодно.
706.78 707.78 SPEAKER_01 В смысле, что угодно.
707.78 715.22 SPEAKER_01 Так что не знаю, пока прям конкретных планов не видно, но посмотрим.
715.22 716.22 SPEAKER_01 Дальше.
716.22 719.38 SPEAKER_01 Второй раздел — это хостинг и оркестрация.
719.38 725.94 SPEAKER_01 Здесь довольно много изменений, в основном про то, а как же надо ссылаться на ресурсы.
725.94 748.08 SPEAKER_01 То есть, как я говорил, вы внутри кода просто указываете, например, что add_redis, там с именем Redis, и все, а в другом проекте, который вы добавляете, когда вы включаете expire, вы опишете, что Redis — это на самом деле Redis сервер с такими-то настройками, если хотите, а можно вообще просто сказать, что это Redis, и он поднимется с дефолтными настройками.
748.08 754.88 SPEAKER_01 Так вот теперь есть пачка методов, то есть там есть пачка методов, которые начинаются со слова with.
754.88 764.24 SPEAKER_01 Если вы работаете с контейнерами, то теперь им можно передать с помощью with_args те аргументы, которые вы хотите, чтобы в контейнер передали, то есть аналог в некотором смысле run, да?
764.24 765.24 SPEAKER_01 Нет?
765.24 766.24 SPEAKER_01 Ну да.
766.24 767.24 SPEAKER_01 Скорее аналог entry_point, да?
767.24 771.04 SPEAKER_01 Что там в докерфайле мы указывали, не помню уже тонкой разницы.
771.04 774.44 SPEAKER_01 Короче, аналог entry_point со всеми там аргументами.
774.44 792.20 SPEAKER_01 Можно указать у произвольного даже компонента, у контейнера, что на него можно ссылаться по определенному имени, то есть с помощью метода with_service_binding, а из любого другого компонента можно сослаться на него с помощью with_reference.
792.20 807.16 SPEAKER_01 На проекты можно теперь ссылаться не только через тот факт, что вы раньше должны были обязательно добавить проект, которым вы хотите управлять через Aspire, в зависимости к главному Aspire проекту.
807.16 814.04 SPEAKER_01 Теперь не обязательно, можно просто прям путь указать к css-project и будет нормально работать.
814.04 818.16 SPEAKER_01 Node.js-приложеньки можно добавлять с помощью add_node_up или npm_up.
818.16 822.64 SPEAKER_01 А еще, как раз то, что я рассказывал про рандомность портов.
822.64 826.92 SPEAKER_01 Раньше порты были рандомные, как работает Aspire внутри чуть-чуть.
826.92 833.72 SPEAKER_01 Он для цели load-балансинга, потому что вы формально можете захотеть ваш, допустим, сервис поднять в нескольких экземплярах.
833.72 841.04 SPEAKER_01 Он поднимает некоторый локальный маленький load-балансер на каждый ваш сервис, и вот у него будет фиксированный порт.
841.04 847.12 SPEAKER_01 А ваш back-end, донатный, он, понятно, будет плюс-минус рандомный порт, особенно если их несколько.
847.12 868.36 SPEAKER_01 Так вот теперь, если он поднимается в одном-единственном экземпляре, то он будет использовать порт из launch профайла, то есть даже если вы просто запустите ваш проект в отладке, вы получите тот же порт, который вы получаете в Aspire, ну чтобы какие-то локальные урлы были одинаковые и локальная разработка была прям такая бесшовная, беспроблемная, как бы вы что ни запускали.
868.36 869.36 SPEAKER_01 Так, компоненты.
869.36 870.36 SPEAKER_01 Aspire состоит из компонентов.
870.36 871.36 SPEAKER_01 Что такое компоненты?
871.36 882.68 SPEAKER_01 Компоненты — это некоторый NuGet-пакет, в котором на самом деле написан просто набор extension-методов с той самой плюс-минус дефолтной конфигурацией.
882.68 885.08 SPEAKER_01 Что такое дефолтная конфигурация?
885.08 905.64 SPEAKER_01 Дефолтная конфигурация — это тщательно выбранная Майкрософтом, ну либо контрибьютором этого пакета, конфигурация для какого-то внешнего сервиса, ну например, для того же Redis-а, который у меня сегодня, примером, постоянно, или для SQL-сервера, или еще для чего-то, которая Майкрософтом считается максимально подходящей для среднестатистического приложения.
905.64 919.92 SPEAKER_01 Дэвид Фаулер как раз в подкасте рассказывал, что в основном инфа о том, какая наиболее оптимальная конфигурация, они берут во многом из своих внутренних больших дотантных сервисов, типа там Binga или Azure или еще кого-нибудь.
919.92 936.56 SPEAKER_01 Непонятно, насколько дефолтная конфигурация Binga или же Azure подойдет среднестатистическому дефолтному проекту, но, наверное, там все-таки тоже в Binga все неплохо настроено, и, наверное, неплохо подойдет, будем так говорить.
936.56 954.96 SPEAKER_01 Добавили два новых компонента, теперь можно еще MySQL и MongoDB использовать, помимо SQL-сервера и Passgrip, которые были в прошлый раз, и в Azure SDK Components, то есть все компоненты, которые позволяют коннектиться к ресурсам Ажура, там теперь включен Distributed Tracing по умолчанию, ну, кроме Service Bus'а почему-то.
954.96 965.72 SPEAKER_01 Ну, вероятно, потому что Service Bus - это штука, которая требует очень кастомного трейсинга, поскольку это очередь, и нужно зашивать это все в сами сообщения, и, наверное, в Generic Video сделать сложно.
965.72 982.60 SPEAKER_01 Так, развертывание, то самое развертывание, которое очень хочется делать плюс-минус автоматически и не тратить время на ручное написание, допустим, каких-нибудь там хелмчартов или чего-нибудь еще для Кубернетиса.
982.60 990.92 SPEAKER_01 Здесь есть какие-то улучшения в Ажурном CLI, не буду вдаваться в подробности, особо не изучал детально, можно в статье почитать, там написано.
990.92 1004.48 SPEAKER_01 И тот самый Aspirate - это тул, который позволяет вам взять Aspire Config и сделать из него штуку, которая позволит вам задеплоить ваше приложение в Кубернет, со всеми теми же сервисами, названиями там и так далее.
1004.48 1006.68 SPEAKER_01 Дальней строкой идет раздел про Dapr.
1006.68 1040.32 SPEAKER_01 Dapr, я напомню, это же, не знаю, ну, framework, наверное, для разработки распределенных Cloud Native, распределенных приложений от Microsoft, написанных на Go, и он в основном работает через всякие разные сайдкарт-контейнеры, т.е. вы пишете ваше основное приложение, пакуете его в контейнер, но для того, чтобы, например, обратиться к какому-нибудь соседнему микросервису, вы обращаетесь не к нему, а вы обращаетесь к тоненькой прослойке, которая работает в сайдкаре в вашем же поде, рядышком с вами, которая уже знает как сделать там сервис Discovery, вот это все, там Resilience, всякие и так далее.
1040.32 1064.28 SPEAKER_01 Вот Dapr теперь можно прямо описывать в конфигурации вашего приложения в Aspire, как у них это называется теперь, это First Class Support, т.е. прямо можно указывать непосредственно, что я хочу там Pub/Sub, там метод прямо такой теперь есть, addDaprPubSub, и вам будет автоматически в Pub/Sub добавлено, ну в таком духе.
1064.28 1088.20 SPEAKER_01 Вот, ну вот примерно такие штуки в Preview 2, т.е. они его, я так понимаю, довольно сильно заполировали и добавили такие еще большие интеграции, чтобы еще больше приложений можно было бы попробовать на них, на Aspire перевести и получить какое-нибудь прикольное поведение или упрощенный цикл разработки.
1088.20 1090.64 SPEAKER_01 Заметил, как они элегантно пытаются сообщество втащить?
1090.64 1115.20 SPEAKER_01 Ну т.е. обычно-то у нас проблемы со всякими, с помоганием дотнет-сообщества к каким-нибудь большим проектам, а также с open-source, и так далее, они не сделали как бы таргет в Kubernetes, ну 100% он всем будет необходим, в общем, первым делом люди потребуют таргет от Kubernetes, и вот сделали такой, ну хотите, пишите сами, вот вам как бы все инпуты, конвертите, так сообщество постепенно увлекается.
1115.20 1122.12 SPEAKER_01 В последний момент, Фаулер как раз рассказывал тоже в подкасте, что типа, во-первых, говорит, я удивлен качеством контрибьютов.
1122.12 1131.32 SPEAKER_01 Ну типа, Фаулер не последний человек в open-source, в смысле, что он довольно много всего делает, ну и делал, и он в принципе, наверное, знает, как обычно в open-source контрибьютит.
1131.32 1153.52 SPEAKER_01 Он говорит, что ну очень часто есть гора контрибьютов, типа там мы тут вам опечатки поправили, ну там тестик написали, ну какие-то такие мелочи, а тут, как бы говорит это, приходят с фичами в Aspire, типа опачки, и вот вам там полноценная фича с тестами, с интеграциями, ну короче прям, говорит, видно, что да, кому-то очень надо, и вот типа такие тулы появляются.
1153.52 1169.48 SPEAKER_01 С другой стороны, он говорит, что те же самые компоненты, мы, говорит, я подтверждаю, что там в первом превью у нас была, ну не так, чтобы сильно хорошая документация о том, как писать компоненты, это не мешало народу писать компоненты.
1169.48 1176.00 SPEAKER_01 Сами как-то разбирались, все, ну там, оно же open-source, все дела, можно посмотреть, как написаны другие компоненты.
1176.00 1179.36 SPEAKER_01 Разобрались, поняли, как писать, писали, короче, contributed, ток-так.
1179.36 1192.32 SPEAKER_01 Другое дело, что опять же он упоминал, что они выбрали в каком-то смысле такой подход, то, что называется некоторый одобренный список, то есть вот этих самых компонентов.
1192.32 1203.84 SPEAKER_01 Вы, как разработчик, можете написать сколько угодно компонент, но Microsoft будет выдавать некую такую а-ля плашечку-не-плашечку, да, про то, что вот это правильное компонентом.
1203.84 1209.76 SPEAKER_01 И тут они, ну, фармер сказал, что это чем-то похоже, что же он сказал-то?
1209.76 1223.64 SPEAKER_01 А, на Spring Cloud, в Java, то есть когда ты пишешь на Spring, если тебе нужно вот туда-то, в принципе, у тебя есть вариации там из десятков разных всяких там, не знаю, коннекторов, ну вот есть какой-нибудь один правильный одобренный Spring, типа.
1223.64 1250.72 SPEAKER_01 Вот они, говорят, хотят какую-то похожую историю получить, то есть никто не мешает написать 10 коннекторов к SQL-серверу, но понятно, что будет один правильный от Microsoft, или там можно написать коннектор, не знаю, к кому, ну, не знаю, к Postgre, например, или к MySQL, и будет один официальный, собственно, от MySQL, да, который вот правильный, но, возможно, будет чем-то неоптимальным, будет какой-то другой, еще один там более быстрый, но не такой фичастый, что-нибудь в таком духе.
1250.72 1269.64 SPEAKER_01 Короче, посмотрим, куда это разовьется, они явно очень хотят вот эту инфраструктуру компонент как-то сильно развивать, и желательно не своими силами, потому что, ну, своих сил у них просто не хватит, но опен-сорсы Microsoft делают такое, надо посмотреть, во что это выльется.
1269.64 1283.04 SPEAKER_01 То есть если они хотят это развивать какую-то там, грубо говоря, компоненты, маркетплейсы, одобрения и так далее, ну, тогда надо понимать, а к чему они идут, потому что сейчас Aspire не кажется чем-то таким большим коммерческой какой-то платформой, или может даже не коммерческой.
1283.04 1286.56 SPEAKER_01 Ну, кстати, когда мы говорим о Microsoft, скорее всего, она должна быть какой-то коммерческой платформой.
1286.56 1293.80 SPEAKER_01 В общем, она как-то туда не стремится, не декларируется, поэтому не очень понятно, зачем они хотят этого всего, всех этих компонентов.
1293.80 1300.48 SPEAKER_01 Чтобы разработчик сам у себя красиво, локально всё настроил, поднял и посмотрел, да ну, не стоит от этих сил.
1300.48 1312.12 SPEAKER_01 Вот давай мы к этому вопросу вернёмся чуть-чуть позднее, а именно через пару-тройку статей, у нас сегодня очень много статей про Aspire, ну, как много, три статьи.
1312.12 1315.60 SPEAKER_01 А пока прервёмся и поговорим о чём-то другом.
1315.60 1317.88 SPEAKER_01 Отвлечёмся, так сказать, да.
1317.88 1326.96 SPEAKER_01 Отвлечёмся немножко от Aspire, положим на стек, положим на полку, запихнём в кэш, не знаю, что вы с этим всем сделаете, но к Aspire мы сегодня ещё вернёмся и не один раз.
1326.96 1330.00 SPEAKER_01 А пока давай поговорим про Эндрю Лока.
1330.00 1333.72 SPEAKER_01 Ну, не то, чтобы совсем про Лока, про его статью.
1333.72 1358.04 SPEAKER_01 У Эндрю Лока вышла отличная статья, он заметил, что в Aspire можно писать логи, а логи, если вы пишете, то вы тогда можете написать всякого такого, что вам писать не стоит, и поэтому, наверное, вдохновившись, выдал интересную статью, т.е. каким образом нам всё-таки писать логи и не сообщить куда-нибудь наружу те данные, которые ружи знать не следует.
1358.04 1359.16 SPEAKER_01 Давайте поподробнее.
1359.16 1366.16 SPEAKER_01 Итак, статья называется «Каким образом использовать Microsoft Extension Compliance Reduction?» Это новый пакет.
1366.16 1370.08 SPEAKER_01 В общем, заодно познакомимся с этим новым пакетом.
1370.08 1372.84 SPEAKER_01 Прежде всего, зачем нужен редакшн?
1372.84 1374.52 SPEAKER_01 Что-нибудь убирать.
1374.52 1381.60 SPEAKER_01 Ну, вероятно, убирать всякую ту информацию, которую той самой ружи знать не нужно.
1381.60 1386.88 SPEAKER_01 Ну, по идее, как бы редакшн на человеческом языке – это, по сути, редактирование.
1386.88 1389.12 SPEAKER_01 Т.е. зачем вам нужно, по сути, редактировать логи?
1389.12 1392.12 SPEAKER_01 Я бы сказал, уменьшение даже, может быть.
1392.12 1393.76 SPEAKER_01 Да, наверное, всё-таки уменьшение.
1393.76 1401.16 SPEAKER_01 На самом деле, если вот такое маленькое обычное консольное приложение или начинающий стартапчик, то вам это и не нужно.
1401.16 1407.28 SPEAKER_01 Вы пишете себе логи, обычно туда закидываете всё, что хотите, и радуетесь жизнью, никаких проблем у вас с этим нет.
1407.28 1411.92 SPEAKER_01 Проблемы начинают возникать, когда вы немножко растёте и понимаете, что логи бывают разные.
1411.92 1420.80 SPEAKER_01 И, например, что в некоторых логах бывает секретная информация, в некоторых – чувствительная информация, а в некоторых даже и персональные данные могут попадаться.
1420.80 1444.84 SPEAKER_01 Если вы компания, которая более-менее ответственная, она следит за всякими безопасностями, там соблюдает всякие комплайнсы и вообще следит за тем, как у неё хранятся данные и где хранятся данные, то постепенно она приходит к тому, что заботиться нужно не только о том, чтобы пароли пользователей в базе данных солить, в базе данных выставлять хороший пароль, но и также задумываться о том, а что они вообще логируют.
1444.84 1451.04 SPEAKER_01 Потому что, как ни странно, к логам обычно относятся как к чему-то пренебрежительному.
1451.04 1455.92 SPEAKER_01 Ну, выплёвывает программа туда какой-то мусор, ну, куда-то этот мусор складывается, ну, и кому какая разница.
1455.92 1460.96 SPEAKER_01 А на самом деле в дебрях этого мусора очень часто находятся очень важные данные.
1460.96 1479.32 SPEAKER_01 Например, те же самые персональные данные очень легко оттуда вычлинить, не говоря уже о списке сервисов, о их взаимодействии, о количестве ваших пользователей или может даже о счетах этих пользователей и сколько там у них денег и что лежит в зависимости от того, какое приложение вы пишете.
1479.32 1484.80 SPEAKER_01 Но обычно компании не задумываются, а кто вообще имеет право доступа к этим логам.
1484.80 1489.80 SPEAKER_01 Должны ли все разработчики доступаться к логам, а тем более к логам продакшена.
1489.80 1505.52 SPEAKER_01 Или очень легко используют, например, люди всякие третисторонние системы, всякие APM или другие лог-сервисы, которые вам эти логи красиво обрабатывают и показывают в красивых графиках.
1505.52 1506.52 SPEAKER_01 Красиво?
1506.52 1507.52 SPEAKER_01 Конечно красиво.
1507.52 1513.16 SPEAKER_01 Но кто-нибудь когда-нибудь задумывался о том, можно ли доверять этой третисторонней системе, что если она ваши данные куда-нибудь сольет?
1513.16 1517.84 SPEAKER_01 Что если ее якобы взломают или нас по-настоящему взломают и все ваши данные утекут?
1517.84 1519.84 SPEAKER_01 Готовы ли вы к этому или не готовы?
1519.84 1530.16 SPEAKER_01 В общем, чтобы не задаваться такими страшными вопросами, а да, еще нужно не забывать, что есть как бы государственные контроли.
1530.16 1540.64 SPEAKER_01 Например, тот же самый GDPR в Европе, который вам четко говорит, какие логи вы обязаны хранить, какие ни в коем случае не можете хранить, и вот под это по все нужно подстраиваться.
1540.64 1547.80 SPEAKER_01 Давайте же посмотрим, как нам, как программистам избавиться от всех этих головных болей.
1547.80 1554.04 SPEAKER_01 Будем рассматривать на примере персональных данных и чувствительных данных.
1554.04 1559.32 SPEAKER_01 Тут нужно понимать, что чувствительные данные – это те же самые персональные данные, но только немножко более важные.
1559.32 1567.24 SPEAKER_01 Это данные, которые отвечают, например, за ваше здоровье, за ваши религиозные убеждения или за какое-то отношение к политике.
1567.24 1571.88 SPEAKER_01 То есть такие данные, которые могут вас скомпрометировать каким-то образом или с помощью которых на вас можно влиять.
1571.88 1577.64 SPEAKER_01 И такие данные очень нежелательны, чтобы попадали в логи.
1577.64 1586.56 SPEAKER_01 А к ним относятся довольно вольготно, то есть никогда никто обычно не ревьюет, что вы пишете в логе.
1586.56 1589.24 SPEAKER_01 И вот такие вещи легко могут утечь.
1589.24 1592.60 SPEAKER_01 Особенно легко могут утечь, когда на ревью, например, этого не видно.
1592.60 1593.96 SPEAKER_01 Почему это может произойти?
1593.96 1599.04 SPEAKER_01 Потому что часто разработчики пишут в логи полностью объект.
1599.04 1609.48 SPEAKER_01 И этот объект засовывают в надежде на то, что логер такой умный, что он разложит все поля этого объекта и все эти поля отправит в наше логовое хранилище.
1609.48 1615.88 SPEAKER_01 С новым атрибутом log properties, который можно навесить на подобный объект, это вообще все становится очень легко.
1615.88 1621.92 SPEAKER_01 То есть это специальный атрибут, который говорит, что у этого объекта возьми все проперти и запиши их в лог.
1621.92 1623.20 SPEAKER_01 Типа деструкторизации такой сделай.
1623.20 1629.60 SPEAKER_01 И благодаря этому очень легко могут учесть персональные данные.
1629.60 1644.80 SPEAKER_01 Потому что если вы хотите залогировать, допустим, что пользователь какой-то выполняет действие, вы можете его просто всего пользователя закинуть в лог, а потом придет время, когда у этого пользователя появится там пароль, имя, адрес проживания, паспортные данные и никто не пойдет рефакторить логи.
1644.80 1650.12 SPEAKER_01 Все будут помнить, что там пользователь со всеми полями логируется и все эти данные легко будут сливаться в лог.
1650.12 1654.64 SPEAKER_01 И это может привести к очень легкому утеканию довольно важных данных.
1654.64 1663.92 SPEAKER_01 И чтобы этого не происходило, опять же, есть специальный пакет, специальные подходы и специальные рекомендации от Микрософта.
1663.92 1667.00 SPEAKER_01 Это новый пакет Microsoft Extension Compliance Reduction.
1667.00 1672.68 SPEAKER_01 С помощью этого пакета вы можете устранить данные проблемы.
1672.68 1673.68 SPEAKER_01 Как же это делается?
1673.68 1686.12 SPEAKER_01 Ну, во-первых, пакет – это такой общий фреймворк для того, чтобы добавить вот это редактирование, устранение избыточной информации или информации, которая не должна выходить за контур в ваше приложение.
1686.12 1689.12 SPEAKER_01 И, естественно, этот пакет работает не только с логами.
1689.12 1699.04 SPEAKER_01 Логи – это лишь единственный частный случай, который у всех на слуху и, наверное, первый случай, который должен приходить вам в голову, когда вы задумываетесь о безопасности вашего приложения.
1699.04 1704.28 SPEAKER_01 Для того, чтобы ваше приложение исправить, вам необходимо сделать три основных шага.
1704.28 1715.56 SPEAKER_01 Во-первых, это классифицировать вашу таксономию, под таким умным словом подразумевается, что вы должны просто катеригазиризировать те данные, которыми хотите управлять.
1715.56 1723.14 SPEAKER_01 Ну, в нашем случае, допустим, это могут быть персональные данные и чувствительная информация, вот у нас там две категории, допустим.
1723.14 1739.20 SPEAKER_01 На втором шаге вам нужно подключить определенные сервисы к вашему логеру, которые как раз-таки и займутся фильтрацией всех необходимых данных, и на третьем шаге вы должны разметить все ваши модели вот этой таксономии, которые вот этими категориями, которые мы определили выше.
1739.20 1741.72 SPEAKER_01 Давайте подробнее рассмотрим, как это делается.
1741.72 1748.56 SPEAKER_01 Для примера, как я уже сказал, возьмем чувствительные данные, персональные данные, и третью категорию заведем прочие данные.
1748.56 1759.64 SPEAKER_01 В прочие данные будет относиться не чувствительная информация, не персональные данные, т.е. та информация, над которой не нужно ничего делать, вот как она логируется, так и пусть логируется, т.е. это большинство тех логов, которые мы пишем.
1759.64 1774.04 SPEAKER_01 Для того, чтобы объявить категории, нам предлагают сделать статический класс, и в этом статическом классе сделать статические свойства, которые будут являться экземплярами класса Data Classification.
1774.04 1778.74 SPEAKER_01 Класс довольно примитивный, он всего лишь навсего принимает к себе две строчки.
1778.74 1789.84 SPEAKER_01 Первая строчка – это название категории, к которой он относится, и вторая строчка – это название непосредственно вот этого свойства, т.е. по сути, категория и подкатегория у нас получается.
1789.84 1798.32 SPEAKER_01 Вот для примера мы можем создать Data Classification, вот такие свойства для Sensitive Data и для Personal Data.
1798.32 1815.54 SPEAKER_01 Для того, чтобы было удобнее их использовать в приложениях, есть специальный атрибут, Data Classification атрибут, в общем, мы должны пронаследоваться от этого Data Classification атрибута и связать его с нашим, вот с созданным Data Classification, для того, чтобы атрибутами потом легче размечать все наши данные.
1815.54 1819.68 SPEAKER_01 Вот мы объявили две категории, три категории.
1819.68 1820.68 SPEAKER_01 Следующий момент.
1820.68 1826.40 SPEAKER_01 Теперь мы должны подключить сервисы к нашему логеру.
1826.40 1836.16 SPEAKER_01 Прежде всего нужно определиться, какую конфигурацию нам сделать, что мы будем делать с теми данными, которые нечаянно попали, с чувствительными данными, которые нечаянно попали в наши логи.
1836.16 1842.04 SPEAKER_01 Есть несколько вариантов, например, если вы забросили пароль в логи нечаянно, что должно произойти?
1842.04 1845.44 SPEAKER_01 Ну, во-первых, мы можем его просто стереть, т.е. заменить на пустую строку.
1845.44 1850.64 SPEAKER_01 Мы можем его заменить на звездочки, на какое-то константное значение звездочек.
1850.64 1859.20 SPEAKER_01 Мы можем зашифровать эти данные, т.е. это в принципе тоже валидная ситуация, когда, допустим, вам данные нужно сохранить в лог, но при этом они являются чувствительными.
1859.20 1866.44 SPEAKER_01 Для того, чтобы, например, при дебаге, при воспроизведении какого-то случая найти обратные данные.
1866.44 1868.48 SPEAKER_01 Там их можно просто зашифровать.
1868.48 1881.48 SPEAKER_01 Зашифрованные данные вполне легко можно запихнуть в лог, и при случае разработчики или доверенные администраторы могут эти данные расшифровать и понять, а к какому конкретно человеку или с какими конкретно данными этот лог оперировал.
1881.48 1882.48 SPEAKER_01 Очень удобно.
1882.48 1884.84 SPEAKER_01 И следующая тема – это хэшинг.
1884.84 1907.72 SPEAKER_01 Тоже довольно приятный вариант, потому что если вы данные не можете напрямую посмотреть, но вам очень важно различать эти данные, допустим, у пользователя, один пользователь придерживается какой-нибудь одной религии, другой пользователь другой религии, и при этом нам хочется две религии, допустим, различать, но при этом мы не можем сказать, какая это религия у каждого конкретного пользователя.
1907.72 1923.04 SPEAKER_01 Мы можем просто хэш записать, и таким образом хэши у нас у двух пользователей будут отличаться, у одинаковых пользователя эти хэши будут одинаковые, соответственно, мы можем их сегментировать, но при этом не раскрываем того, в чем именно содержимое этих религий.
1923.04 1932.80 SPEAKER_01 Из коробки нам доступны от Микрософта всего лишь навсего два вот этих реплейсера – это Erising редактор и HMAC редактор.
1932.80 1940.92 SPEAKER_01 Первый у нас полностью стирает все sensitive data, все чувствительные данные, а второй генерирует хэш.
1940.92 1955.88 SPEAKER_01 Для того, чтобы нам подключить это к логеру, достаточно вызвать парочку простых методов, это Enable Reduction, и настроить наш редактор, в частности, указать, какой редактор мы будем использовать и на какую таксономию, т.е. на какую классификацию.
1955.88 1967.24 SPEAKER_01 Мы можем, например, для наших чувствительных данных использовать редактор, который стирает полностью чувствительные данные, а для нашей персональной информации, допустим, использовать редактор, который заменяет их на хэш.
1967.24 1970.20 SPEAKER_01 Это все тоже довольно гибко настраивается.
1970.20 1985.32 SPEAKER_01 Ну и третий, последний шаг, наконец, выходят наши атрибуты, которые мы создавали на первом шаге – это sensitive data атрибуты и personal data атрибуты, мы ими должны разметить те поля, например, у класса User, которые мы считаем вот такими чувствительными.
1985.32 2004.88 SPEAKER_01 Как только мы эти поля разметим и запустим наше приложение, мы увидим, что как бы мы не пытались залогировать этого пользователя, логгер такой умный, что он находит поля, помеченные таким атрибутом специальным, и затирает их или подставляет вместо них хэш, и поэтому в логгах никогда эти данные не утекут.
2004.88 2010.96 SPEAKER_01 Также абсолютно несложно сделать свой редактор, редактор, который что-то делает с этой строкой.
2010.96 2021.36 SPEAKER_01 Вот автор в примере, например, дает специальный класс, который может заменять чувствительные данные на какую-то константную строку.
2021.36 2023.68 SPEAKER_01 Кому интересно, тоже можно пройти посмотреть.
2023.68 2027.80 SPEAKER_01 На самом деле написать свой редактор довольно просто, для этого достаточно переопределить, грубо говоря, один метод.
2027.80 2033.44 SPEAKER_01 Метод, который на вход принимает строку, которую надо заменить, и на выходе отдаёт, а на что её заменить.
2033.44 2036.20 SPEAKER_01 Таким образом, вы легко можете написать абсолютно свой редактор.
2036.20 2040.96 SPEAKER_01 В общем, какая мораль этой истории?
2040.96 2049.72 SPEAKER_01 Я бы, мораль уже не от автора, а мораль от меня, я бы вывел мораль так, что никогда не пишите в логе полные объекты.
2049.72 2059.84 SPEAKER_01 Несмотря на то, что у нас есть куча механизмов, куча атрибутиков, как это всё делать, как за вами почистить вот эту всю грязь, самый безопасный способ – это всё-таки никогда не писать.
2059.84 2068.44 SPEAKER_01 Потому что эта классификация, классификатор надо собрать, разметить поля, поля переименовываются, переезжают, за ними нужно следить.
2068.44 2075.88 SPEAKER_01 И всё равно легко поле может попасть в лог, например, если его записали в переменную, а потом эту переменную засунули в лог.
2075.88 2079.28 SPEAKER_01 Никто на это, грубо говоря, сильно присматриваться не будет.
2079.28 2090.32 SPEAKER_01 В то же самое время, когда мы пытаемся, например, выдать бизнес-объект за пределы веб-контроллера, Best Practices придумали нам специальные DTO-шки.
2090.32 2101.08 SPEAKER_01 Мы не выдаём бизнес-объект сразу в JSON-стерилизатор, хотя могли бы, а мы мапим его сначала в DTO-шки, как раз именно по этой теме, чтобы лишней информации не ушло.
2101.08 2103.00 SPEAKER_01 Точно такая же тема с базой данных.
2103.00 2106.84 SPEAKER_01 У нас есть отдельные объекты, которые можно записывать в базу данных.
2106.84 2109.48 SPEAKER_01 Мы не пытаемся записывать обычно в базу данных бизнес-объекты.
2109.48 2117.04 SPEAKER_01 С логами такая же точная ситуация, это та же самая внешняя система, относитесь к логам, как к базе данных.
2117.04 2119.08 SPEAKER_01 Вы пишете туда какие-то данные.
2119.08 2142.32 SPEAKER_01 И у нас, например, несколько раз были случаи, когда люди полностью весь бизнес-объект или там какой-то дополнительный объект засовывали в логи, оказывалось, что у этого дополнительного объекта где-то там зацепился датабейс-контекст, оказывается, что у датабейс-контекста есть ссылки на все таблицы и на все базы данных, которые есть в вашей системе.
2142.32 2149.64 SPEAKER_01 И таким образом, залогировав какого-то маленького пользователя, вы вполне можете задампить всю вашу базу данных в логер.
2149.64 2157.52 SPEAKER_01 В общем, такая штука тоже встречается, это довольно нередкая ситуация и связана лишь с тем, что люди пытались засунуть в логи какой-то объект.
2157.52 2169.88 SPEAKER_01 С этим очень много разных проблем, поэтому не суйте объекты в логи, раскладывайте их по полям, которые удобно видно будет на ревью, что в этом поле, откуда оно взялось, как пришло и куда же запишется.
2169.88 2181.00 SPEAKER_01 И, соответственно, вам будет удобно и за собой следить, и за ребятам, которые вас ревируют, будет удобно следить, и вы избежите очень-очень много таких проблем, особенно случайных проблем.
2181.00 2185.16 SPEAKER_01 Это самые опасные, которые сначала стреляют, а потом их чинят.
2185.16 2186.16 SPEAKER_01 А может быть, уже довольно поздно к этому моменту.
2186.16 2196.76 SPEAKER_01 Ну т.е. правильно ли я тебя понимаю, что единственный максимально надёжный способ отловить такие штуки, как запись паролей в лог и т.д. – это ревью?
2196.76 2198.12 SPEAKER_01 К сожалению, да.
2198.12 2206.20 SPEAKER_01 Ну т.е. ты можешь понадеяться на атрибуты, ну т.е. наверное лучше всего это использовать несколько инструментов сразу, может кто-нибудь из них выстрелит.
2206.20 2213.32 SPEAKER_01 Допустим, если ты гарантируешь, что все ваши чувствительные данные будут офигенно размечены атрибутом, то здесь тоже как бы никаких вопросов.
2213.32 2222.36 SPEAKER_01 Ты запускаешь какой-нибудь даже статический анализатор, он прослеживает весь воркфлоу, где использовались эти поля, и он тебе может сказать, что вот эти поля нельзя записывать в логи.
2222.36 2232.04 SPEAKER_01 Опять же, если вдруг оно случайно пропадет в логи, статический анализатор не осилит, у нас есть Microsoft Reduction, который всё это может преобразовать постфактум.
2232.04 2234.40 SPEAKER_01 Если даже случайно попали, он их затрёт, захеширует.
2234.40 2241.68 SPEAKER_01 Тоже отличный инструмент второй, и третий инструмент, если у вас всё-таки будет ревью, то это тоже будет замечательно.
2241.68 2252.32 SPEAKER_01 Здесь такая тема, она ограничена на уровне с утечками, потому что о логах часто не заботятся люди, если они куда-нибудь попадут в не те руки, это довольно плохо может кончиться.
2252.32 2258.16 SPEAKER_01 И поэтому эти утечки лучше контролировать на всех уровнях, на которых только возможно.
2258.16 2264.96 SPEAKER_01 И атрибуты – да, и ревью – да, и статические анализаторы – да, и ещё какие-нибудь бестпрактисы и чего-нибудь в этом духе тоже – да.
2264.96 2271.84 SPEAKER_01 Но мне вот приходит в голову мысль, что может быть имеет смысл делать, как, например, GitHub делает своих воркфлоу.
2271.84 2275.32 SPEAKER_01 А знаешь, да, как там работает с логами?
2275.32 2284.52 SPEAKER_01 Ну, по крайней мере, работал он, давно не проверял, там смысл в том, что из логов выпиливаются любые значения, которые встретились в переменных окружениях.
2284.52 2290.12 SPEAKER_01 Да, но ты не сможешь собрать все возможные sensitive data из всех твоих приложений.
2290.12 2300.36 SPEAKER_01 Я согласен, но хотя бы я имею в виду, что если у тебя запущено приложение, то вероятно через переменные окружения, либо через конфиг тебе переданы возможно какие-то секреты.
2300.36 2303.88 SPEAKER_01 Секреты – да, а представь, что у тебя в базе хранится тысяча пользователей.
2303.88 2304.88 SPEAKER_01 Верю.
2304.88 2308.20 SPEAKER_01 У каждого из этих тысячи пользователей номера паспортов, и что ты будешь делать?
2308.20 2309.20 SPEAKER_01 Нет, с этим ничего.
2309.20 2322.80 SPEAKER_01 Ты же сам говоришь, у всех средства хорошие, я к тому, что не стоит ли логи ещё, нет ли, может быть, какого-то, не знаю, пакета, не знаю, нугета готового, который просто, зная всё, что пришло в конфигурацию, просто вычесть это нафиг из логов, даже если это просто строки.
2322.80 2335.56 SPEAKER_01 Ну, да, есть такие пакеты, и в принципе до Microsoft Reduction давно уже у серилога был такой же пакет, который умеет удалять по какому-то словарю, как ты говоришь, кто пришёл, кто ушёл.
2335.56 2337.24 SPEAKER_01 Здесь другая есть тонкость.
2337.24 2356.96 SPEAKER_01 Иногда, очень редко, но случается, что когда ты просматриваешь логи GitHub, и там проскальзывает какое-то сообщение типа файл в папочке такой-то, такой-то, компилируется, и часть этой папочки закрыта звёздочками, и в этот момент ты со стопроцентной вероятностью можешь разгадать пароль.
2356.96 2387.76 SPEAKER_01 Если у вас пароль не какой-то там стойкий, а просто обычные человеческие слова, то они очень часто, случайно довольно попадают в логи не в виде пароля, а в виде какой-то части там кода или файла, или какого-нибудь сообщения, и то, что это слово начинает, ну, например, ты залогировал «я люблю маму», да, а у тебя «love» - это твой пароль, и в этот момент у тебя GitHub предательски помечает слово «love» звёздочками, т.е. он тебе говорит, что на самом деле, чуваки, этот пароль где-то используется, посмотрите.
2387.76 2413.58 SPEAKER_01 Интересно, интересно, используйте сложные пароли, но, ну, короче, да, понятно, что не придумать, наверное, действительно технического какого-то решения, которое 100% вам уберёт все персональные данные из логов, и по-другому никак не будет, если только просто вы не напишете такого лога, не знаю, синк, который будет просто шифровать всё и всё сразу же, но такие логи будут относительно бесполезны.
2413.58 2442.28 SPEAKER_01 Ну, не такая безумная идея, потому что, например, некоторые компании, например, делят лог-левелы, например, лог-левел «дебаг» - они все весь шифруют, лог-левел «инфа» - они пишут так, чтобы там вообще было всё максимально абстрактно, даже если эти логи полностью утекут, в общем, вот такие есть извращения, т.е. зависит от вашего приложения, если вы работаете, не знаю, с финансами, с медициной, с политикой, ещё с чем-нибудь страшным, то там перешифровывать даже нужно 200 раз.
2442.28 2463.40 SPEAKER_01 Ну и, конечно же, тот синк, который вас логи пишет, естественно, он тоже должен писать по зашифрованную каналу, в зашифрованную базу данных, который имеет доступ там 2-3 человека, и то по хардварному токену в какие-то определенные праздники, ну т.е. вам нужно ещё задумываться не то, как вы пишете эти логи, но и куда они пишутся, и кто там потом эти логи сможет смотреть.
2463.40 2467.60 SPEAKER_01 Т.е. это дальнейшее развитие идеи, что этот контроль нужен абсолютно на всех ступеньках.
2467.60 2470.80 SPEAKER_01 В общем, сложная эта тема, пишите логи вдумчиво.
2470.80 2472.04 SPEAKER_01 Давай пойдём дальше.
2472.04 2479.72 SPEAKER_01 Вернёмся в Aspire, ну не то чтобы мы сильно далеко от него уходили, но тем не менее.
2479.72 2505.56 SPEAKER_01 Я уже напомнил, наверное, пожалуй, надеюсь, вы не забыли, что же такое Aspire, да, там контролируют запуск приложений, вот это всё, и я уже упоминал один раз, что, или даже несколько раз на самом деле, что при отшественниках Aspire был Project TIE, который был экспериментальный такой проект, который была попытка понять, о чём Microsoft сможет сделать для вот такого вот облегчения жизни разработчикам.
2505.56 2517.92 SPEAKER_01 Я уже не знаю, какие были прям официальные внутри цели, скорее всего понятно, что что-то попробовать, но вот для такого обыкновенного разработчика Project TIE был, ну удобной штукой для какого-то локального запуска и просмотра логов.
2517.92 2521.36 SPEAKER_01 По-моему, там кроме логов особо ничего не было, но тем не менее уже было приятно.
2521.36 2542.00 SPEAKER_01 В TIE всё делалось на ямле, ну как положено в современном мире, и дальше сам TIE был написан на C#, и он читал этот ямль, как-то всё это собирал в некоторое внутреннее представление и понимал, с какими ресурсами работает ваше приложение, точнее, из каких ресурсов оно состоит, и какие переменные окружения, куда нужно воткнуть.
2542.00 2548.56 SPEAKER_01 Там был какой-то начальный уровень сервис-дискавери, то есть можно было сослаться на соседнее приложение по имени, но не более того.
2548.56 2577.56 SPEAKER_01 А в Aspire пошёл чуть дальше, они вообще отказались от ямля, всё пишется на C#, как я сказал, то есть это было вдохновлено частично идеей того, что в ямле, ну по сути, поскольку это не язык программирования, то очень сложно делать какую-либо там условную логику или ещё что-нибудь, а с другой стороны, ну продукты типа Pulumi, как я сказал, вполне себе живы и очень неплохо принимаются сообществом, и поэтому Aspire родился в том виде, в каком он есть.
2577.56 2583.48 SPEAKER_01 Как я говорил, есть два режима запуска, точнее я говорил про один, но есть их всего два.
2583.48 2597.72 SPEAKER_01 Один — это собственно генерация JSON-манифеста, как я сказал, а второй — это непосредственно запуск, то есть вы просто говорите dotnet run на проекте, который является вот этим дополнительным Aspire-проектом в вашем солюшене, после чего Aspire делает следующую штуку.
2597.72 2605.84 SPEAKER_01 Во-первых, он собирает из вот этого C#-кода некоторую внутреннюю представление модели, того, чего вы вообще собираетесь запустить.
2605.84 2625.14 SPEAKER_01 После этого он запускает инстанс некоторого тула под названием Microsoft Developer Control Plane, он очень часто в репозиториях и во всяких статьях на него ссылаются как DCP, Developer Control Plane, это на самом деле там не один процесс, но мы сейчас к этому вернемся.
2625.14 2636.96 SPEAKER_01 После чего Aspire просит этот самый DCP, Control Plane, стартовать все то, что вы попросили, то есть Docker-контейнеры, приложеньки, CSProG, вот это все.
2636.96 2644.48 SPEAKER_01 Дальше он слушает, собственно, что там в DCP происходит, всякие венты, кто что упал, кто что вывел в консольку и так далее.
2644.48 2650.84 SPEAKER_01 Таким образом получает логи, трейсы, ну и понятно слушает на OpenTelemetry порте на предмет всяких метрик.
2650.84 2656.44 SPEAKER_01 И последнее, что он делает, это понятно открывает тот самый дешборд, про который мы много уже сегодня поговорили.
2656.44 2665.36 SPEAKER_01 Так вот, во всем этом замечательном алгоритме есть одна непонятная штука, это Microsoft Developer Control Plane.
2665.36 2676.48 SPEAKER_01 Вот мы в прошлой статье, ну в смысле в первой нашей сегодняшней статье обсуждали про то, что вот Microsoft куда-то там, непонятные его цели, open-source-ность, не open-source-ность.
2676.48 2688.68 SPEAKER_01 Так вот DCP, вот этот самый Microsoft Developer Control Plane, а это собственно центральная часть вообще всего Aspire, она с закрытыми исходниками, неизвестно, что в ней там внутри происходит.
2688.68 2689.68 SPEAKER_01 Абсолютно.
2689.68 2701.68 SPEAKER_01 Это несколько процессов, то есть на винде, конкретно, где автор статьи это все запускал, там запускаются три процесса, DCP/EXE, DCP/CTRL/EXE и DCP/DEXE, ну где мы видим какой-то аналог типа демона.
2701.68 2706.40 SPEAKER_01 И автор попытался понять вообще, что это такая за штука.
2706.40 2712.52 SPEAKER_01 Ну в принципе Aspire-то сам по себе открытый, поэтому видно по крайней мере по какому протоколу общаются с этим самым Developer Control Plane.
2712.52 2716.72 SPEAKER_01 И показалось, что он делает что-то похожее на Kubernetes.
2716.72 2720.24 SPEAKER_01 То есть он со стороны выглядел примерно как Kubernetes.
2720.24 2746.80 SPEAKER_01 И первые попытки подергать kubectl, значит, с указанием endpoints этого самого DCP как-то успехом не увенчались, но потом получилось таки подобрать набор аргументов для kubectl, так что этот самый DCP ответил, указал список ресурсов, с которыми он умеет работать, там, что неудивительно, в основном оказались чисто специфичные Aspire ресурсы.
2746.80 2771.08 SPEAKER_01 И в общем, глядя на исходники Aspire и некоторые догадки того, как это все работает, кажется, что Aspire коннектится к вот этому DCP и полностью его использует с помощью таких команд, похожих на команды Kubernetes, каким-то образом контролирует всю эту машинерию контейнеров, процессов и всего остального.
2771.08 2776.60 SPEAKER_01 И кажется, что вот этот самый DCP, эта центральная часть почему?
2776.60 2791.52 SPEAKER_01 Потому что она, именно она, ответственна за то, чтобы общаться с докером на предмет старта контейнеров, общаться с операционной системой для старта процессов, то есть это даже не сам Aspire делает процесс старт, а он обращается к отдельному компоненту, который уже это делает.
2791.52 2807.28 SPEAKER_01 Эта штука ответственна за то, чтобы как раз поднимать нужный load balancer и вытаскивать нужные порты наружу, она же следит за тем, как там живут ресурсы, если, например, там кто-то падает, а вам нужна репликация, то поднимает копии.
2807.28 2810.88 SPEAKER_01 В общем, вот это все делает внутри DCP.
2810.88 2825.90 SPEAKER_01 DCP это не кажется, что дотнетный проект, то есть кажется, что это нечто похожее на частично Dapr, частично Kubernetes, похоже написанное на Go, ну по таким косвенным признакам возможно.
2826.42 2836.30 SPEAKER_01 И Microsoft очень как-то умело, пока по крайней мере, обходит вопросы, что это такое, как и зачем, для чего и какое у этого всего будущее.
2836.30 2850.58 SPEAKER_01 То есть есть иши в репозитории Aspire со словами типа, ну скажите вообще, куда все это движется в плане, какая лицензия будет у DCP, там у них уже есть лицензия, которая позволяет типа делать что угодно на локал хосте, грубо говоря.
2850.58 2854.30 SPEAKER_01 Но весь Aspire пока только для локал хоста, по сути.
2854.30 2892.82 SPEAKER_01 И поэтому есть мысли у комьюнити, что может быть как раз DCP, это тот самый кусочек, который позволит потом, то что мы с тобой говорили чуть раньше сегодня, сделать эту всю историю коммерческой, потому что Aspire это конечно хорошо, Aspire это по сути, сам вот open-source часть, это по сути интерпретатор из C# в команды вот этому DCP, ну если очень грубо, плюс красивый дэшборд, то есть в принципе дэшборд и сбор каких-то метрик видимо вынести можно, но насколько вот этот сбор метрик, трейсов и так далее отделен от доцентной части и зашит вот этот вот closed-source кусочек, пока не очевидно.
2892.82 2911.02 SPEAKER_01 И вот это вот, до тех пор пока вот эта DCP часть будет оставаться closed-source, непонятно что там происходит внутри, непонятно какую телеметрию она шлет, потому что лицензии написано, что может, Microsoft пока говорит, что он ничего не шлет, но особых исследований, как я понимаю, на эту тему не проводилось.
2911.02 2935.54 SPEAKER_01 В общем, выводы авторы, что штука прикольная, кажется, что написано с умом, написано с оглядкой на кубернетис, ну понятно, что это стандарт индустрии и скорее всего там всё примерно хорошо, выглядит это как будто такой Microsoft реализация легковесного кубернетиса, но закрытость исходников, она как-то пока напрягает и непонятно, куда это пойдёт дальше.
2935.54 2940.10 SPEAKER_01 Слушай, а что, этих миниалов разучили пользоваться декомпайлером?
2940.10 2941.10 SPEAKER_01 Для Go?
2941.10 2942.10 SPEAKER_01 Нельзя было залезть?
2942.10 2949.04 SPEAKER_01 Конечно, ну почему, для обычного исходного кода, то есть для Asmodee мы декомпайлили, просто восстанавливали как бы.
2949.04 2962.42 SPEAKER_01 Смотри, нету как бы проблемы, ну давай, наверное, кто-то это делал, я статьи не находил, но что ты узнаешь, ты посмотришь, как в Asmodee выглядит общение с докером и запуск контейнеров.
2962.42 2966.82 SPEAKER_01 В целом, ну как бы, что оно делает внутри примерно понятно.
2966.82 2981.70 SPEAKER_01 Наверное, если к нему обращались по протоколу кубернетиса, наверное, я смогу вычислить общие части с настоящим кубернетисом, потом залезть как бы в лицензии хотя бы и посмотреть, имел ли право вообще Microsoft, например, переюзивать вот эти части.
2981.70 3038.04 SPEAKER_01 Ну, наверное, я думаю, что Microsoft имел, ну то есть, короче, юристы Microsoft, наверное, поработали с этой частью, я думаю, что там вопросы протокола кубернетиса, скорее всего, всё нормально, всё как бы опенсурсное, достаточно опенсурсное, чтобы его использовать, вот тут, скорее всего, проблем нету, а тут, скорее, вопрос не в том, как бы, как оно устроено внутри, скорее всего, все примерно понимают, как оно устроено внутри, ну, как бы, тут вопрос просто в ресурсах это всё написать, а вопрос в том, что, почему оно closed source, то есть, в чём причина того, что его держит closed source, там, код не очень или у Microsoft действительно есть планы как-то это коммерциализировать и поэтому они не хотят открывать сурсы, как там у Visual Studio, да, вот, ну, в таком духе, то есть, пока вся конспирология строится на том, что, ну, понятно, они будут брать деньги, потому что оно closed source, ну, в общем.
3038.04 3052.02 SPEAKER_01 Ну, кажется, это логичным, потому что, опять же, если они там компоненты накручивают и много сил потратили на маркетинг, столько вломили, как бы, и Fowler'а тогда прям запустили на full-time, что они дешёвый специалист, они должны как-то это окупать, поэтому это вопрос лишь времени.
3052.02 3061.58 SPEAKER_01 Если оно не будет окупаться, то, скорее всего, и проект заглохнет сам по себе, а составить, как бы, эту примитивную конкуренцию к кубернетизу давно пора.
3061.58 3072.30 SPEAKER_01 Я уже много лет вижу, что кубернет – это адская машина, и нам нужен в индустрии, как таковой, его альтернатива, какой-нибудь более упрощённый и более человеческий организм.
3072.30 3075.14 SPEAKER_01 И, может быть, вот Microsoft хочет эту нишу закрыть.
3075.14 3080.90 SPEAKER_01 Сначала, конечно, через разработчиков, через самых лояльных и понятных на старте людей.
3080.90 3085.34 SPEAKER_01 А потом почему бы и нет, и выйти прямо в какую-нибудь продакшн-конкуренцию.
3085.34 3092.82 SPEAKER_01 С совместимым протоколом, естественно, что тебе не помешает, как бы, докер-контейнеры там запускать и, может быть, те же самые конфиги использовать от кубернетиза.
3092.82 3103.46 SPEAKER_01 Ну вот, может быть, поглядим, и я надеюсь, что к релизу дотонт-9, а может быть, даже чуть раньше, в течение лета, например, мы хоть как-то начнём понимать, куда это движется.
3103.46 3106.82 SPEAKER_01 Возможно, какие-то последуют более официальные кусочки от Microsoft в том же GitHub.
3106.82 3115.14 SPEAKER_01 Я периодически посмотрю в GitHub дотонт-эспайра и смотрю, что там происходит с точки зрения ищущих.
3115.14 3124.38 SPEAKER_01 Мне там не столько вот такие технические, ну там много кто говорит, а вот такое, там на макоси что-то там местами не работало, а вот тут не работает, а вот так не работает.
3124.38 3130.50 SPEAKER_01 Но я смотрю на такие больше общечеловеческие, типа, куда всё это движется, да, какие-то там лицензионные вопросы.
3130.50 3132.54 SPEAKER_01 Если будут что-то интересное, притащу, расскажу.
3132.54 3133.54 SPEAKER_01 Отлично.
3133.54 3134.54 SPEAKER_01 Пойдём дальше.
3134.54 3137.62 SPEAKER_01 Опять же, немножко разбавим эспайр.
3137.62 3144.22 SPEAKER_01 Если бы эспайр был написан на дотнете в фреймворке, его пришлось бы мигрировать на дотнет шестой.
3144.22 3150.14 SPEAKER_01 Конечно, эспайр был сразу написан на шестом или даже, наверное, на восьмом.
3150.14 3159.26 SPEAKER_01 Нет, он написан на восьмом, и более того, он, насколько я понимаю, он требует, чтобы то, что вы запускаете под ним, было на восьмом, если это что-то на дотнете и через Cesspro.
3159.26 3163.46 SPEAKER_01 То есть через пакеты я не могу достать, да, старый какой-нибудь?
3163.46 3167.46 SPEAKER_01 Я так понимаю, что компоненты зависят от чего-то, что таргетит восьмёрку вроде как.
3167.46 3172.22 SPEAKER_01 Ну, они, может быть, забыхпортят до шестёрки, скорее всего, наверняка.
3172.22 3173.22 SPEAKER_01 Всё-таки шестёрка и ЛТС, да ведь?
3173.22 3174.22 SPEAKER_01 Да?
3174.22 3175.22 SPEAKER_01 Да.
3175.22 3176.22 SPEAKER_01 ЛТС.
3176.22 3178.22 SPEAKER_01 Поэтому, наверное, они всё-таки забыхпортят до шестёрки.
3178.22 3183.10 SPEAKER_01 Что-то ты, Фаулер, упоминал в подкасте, что шестёрка вроде бы что-то там, то ли в планах, то ли уже где-то рядом.
3183.10 3186.34 SPEAKER_01 Но в основном считать, что нужно восьмёрку.
3186.34 3189.06 SPEAKER_01 Ну ладно, договорились.
3189.06 3193.38 SPEAKER_01 Попалась интересная серия статей от Джимми Боггарда.
3193.38 3199.14 SPEAKER_01 Известный автор, хороший, пишет много, пишет интересно, пишет правильно.
3199.14 3200.50 SPEAKER_01 И серия прекрасная.
3200.50 3207.62 SPEAKER_01 Серия называется «Как смигрировать со старого .NET-фреймворка на новый .NET Core».
3207.62 3218.74 SPEAKER_01 И это не просто какие-то там рассуждения и измышления, а это настоящая практическая работа, которую автор проделал над большим приложением, на которое его наняли, и он решил своим опытом поделиться.
3218.74 3233.34 SPEAKER_01 В общем, мы, если кто помнит, в одном из прошлых выпусков обсуждали отчёт о том, сколько старого .NET-фреймворка у нас в индустрии, и там около половины как бы всех .NET-программ – это именно старый .NET-фреймворк.
3233.34 3236.46 SPEAKER_01 И вот мимо этой статьи нельзя было пройти.
3236.46 3246.42 SPEAKER_01 В общем, мы решили её обсудить, может быть, это кому-то позволит задуматься о том, что можно приложение на старом фреймворке портировать на .NET Core.
3246.42 3260.18 SPEAKER_01 Опять же, интересен кейс тем, что у нас здесь не какой-то 2-3 файлика, которые можно автоматически просто переконвертить, а большое легаси приложение, которое писалось несколько десятилетий, ну, в общем, как положено.
3260.18 3267.58 SPEAKER_01 То есть простые приложения уже давно все перевели, а вот страшные, большие, тяжёлые, к ним многие боятся подступиться.
3267.58 3283.88 SPEAKER_01 И вот эта серия интересна тем, что автор даёт хорошие рекомендации на каждом шаге, рассказывает про свои какие-то измышления, про свои практические костыли и грабли, на которые они наступили, и постепенно пользователя, разработчика проводят через весь этот путь.
3283.88 3290.06 SPEAKER_01 Давайте же мы попробуем проследить, как развивалась эта эпопея и чем она закончилась.
3290.06 3304.52 SPEAKER_01 Прежде всего напомню, что перед автором стоит цель мигрировать большое .NET приложение с 4.8, то есть его подняли до максимального старого фреймворка, насколько это можно было, чтобы порт был как можно менее болезненным.
3304.52 3313.42 SPEAKER_01 И хочется перевести на .NET 6, на момент написания статьи это был последний LTS, разумеется, вам разумнее переводить на 8 уже.
3313.42 3321.64 SPEAKER_01 И второй пункт, которая, вторая задача, которая перед ними стояла, это перевести с on-premise решение на Microsoft Azure, в облако.
3321.64 3331.22 SPEAKER_01 Это, в принципе, две независимые задачи, можно рассматривать их независимо, но прекрасно, что в одной статье две больших сложных задачи сплелись вместе.
3331.22 3333.70 SPEAKER_01 Давайте посмотрим, что же из этого вышло.
3333.70 3341.10 SPEAKER_01 Разумнее всего при этом случае применять шаблон проектирования, который называется Strangle Fig, т.е.
3341.10 3343.10 SPEAKER_01 фикус-душитель, также известный.
3343.10 3345.82 SPEAKER_01 Вкратце напомню его основные концепции.
3345.82 3356.26 SPEAKER_01 Мы постепенно начинаем убирать Legacy Code, т.е. переводить его на какой-то новый фреймворк или новую платформу или новый язык.
3356.26 3364.82 SPEAKER_01 И делаем это постепенно, до тех пор, пока Legacy Code окончательно не переведется, пока он не умрет.
3364.82 3370.26 SPEAKER_01 В этот момент у нас параллельно работают две версии, новая версия и старая версия.
3370.26 3378.02 SPEAKER_01 Старая версия постепенно худеет, новая постепенно толстеет, в тот момент, когда мы по чуть-чуть переносим всю логику или все компоненты из старой в новую.
3378.02 3386.34 SPEAKER_01 Таким образом мы уменьшаем риски все переписывания, когда мы говорим, что сейчас мы на год уйдем, перепишем вам все приложение с нуля и перейдем обратно.
3386.34 3388.96 SPEAKER_01 Обычно это ничем хорошим не заканчивается.
3388.96 3398.38 SPEAKER_01 А здесь же у нас постоянно будет работать в продакшене наше новое приложение, наше старое приложение, и переписывание будет гармонично как бы перетекать из старого кода в новое.
3398.38 3400.90 SPEAKER_01 Поэтому это довольно хороший шаблон.
3400.90 3420.02 SPEAKER_01 И даже в официальных гайдах Микрософта, который рассказывает о том, как переводить старые большие дотнет-приложения на новый фреймворк, этот шаблон советуется как самый основной и только с помощью него есть какие-то гарантии, что эта эпопея закончится удачно.
3420.02 3426.74 SPEAKER_01 И более того, у Микрософта есть отдельная статья, как это делать.
3426.74 3432.26 SPEAKER_01 И эта статья вводит еще один интересный проект в нашу систему, который называется System Web Adapters.
3432.26 3437.90 SPEAKER_01 Вкратце Микрософт говорит, да, давайте посмотрим вкратце рекомендации Микрософта, что нужно сделать.
3437.90 3444.98 SPEAKER_01 Во-первых, представим наше текущее приложение, обозвем его старое приложение, в виде трех основных блоков.
3444.98 3448.38 SPEAKER_01 Первый блок – это входящие запросы, которые приходят в ваше веб-приложение.
3448.38 3453.98 SPEAKER_01 Второй блок – это ваш старый ISP Network Framework, который обрабатывает эти запросы.
3453.98 3454.98 SPEAKER_01 И третий блок – это бизнес-логика.
3454.98 3463.30 SPEAKER_01 Для того, чтобы перевести это все на новый фреймворк, на шестой фреймворк, Микрософт рекомендует сделать следующую вещь.
3463.30 3470.10 SPEAKER_01 Во-первых, создать рядом, в том же самом Solution, новое дотнет-приложение на дотнет-шестом, допустим, ну или на последнем LTS.
3470.10 3484.14 SPEAKER_01 В дотнет-шестое приложение встроить YARP, это встроенный реверс-прокси, мы про него уже рассказывали, то есть это специальный набор компонент, который помогает делать разные совходящие запросы.
3484.14 3493.26 SPEAKER_01 В частности, в нашем случае он может все запросы, которые входят в это приложение, редиректить на ваше старое приложение.
3493.26 3511.30 SPEAKER_01 Поэтому у нас теперь появляется несколько блоков – это запрос, который входит в ваше приложение, этот запрос сразу попадает в новое дотнет-кор приложение, дотнет-кор приложение перенаправляет его в YARP, YARP его перенаправляет в ваше старое фреймворк приложение, и там уже выполняется бизнес-логика.
3511.30 3515.40 SPEAKER_01 Это базовая цепочка, с которой дальше уже можно начинать работать.
3515.40 3527.62 SPEAKER_01 Следующим шагом нужно добавить System Web Adapters, это специальный набор компонентов, который призван нивелировать вот эту разницу между старым ISP-нетом и новым ISP-net-кором.
3527.62 3538.82 SPEAKER_01 Если вы помните, там у нас ушли какие-то там сессии, http-контексты, очень много странных хендлеров, адаптеров, фильтров, в общем, много-много всяких компонентов ушло.
3538.82 3544.42 SPEAKER_01 Ну, то есть, по сути, это был breaking change, у нас даже название проекта поменялось, теперь это ISP-net-кор.
3544.42 3547.34 SPEAKER_01 Кор как раз подчеркивает то, что проект другой.
3547.34 3558.22 SPEAKER_01 И вот System Web Adapters, он как раз-таки и помогает внести вот эту разницу, которая была удалена, и эта разница как раз она адаптирована под новый дотнет-кор.
3558.22 3568.66 SPEAKER_01 И название такое, потому что в старом ISP-нете самая главная сборка, которая была, и в которой были практически все классы, с которыми нам приходилось работать, это System Web, поэтому System Web Adapters.
3568.66 3585.66 SPEAKER_01 Дальше мы внедряем эту сборку System Web Adapters в кор-приложение, и все запросы, которые мы не можем обработать, а изначально мы можем обработать никакие запросы, все запросы, которые мы не можем обработать, мы переводим через YARP в фреймворк-приложение.
3585.66 3588.46 SPEAKER_01 Дальше необходимо отрефакторить старое приложение.
3588.46 3600.18 SPEAKER_01 Если мы можем, мы выносим общий код в шарь сборки, то есть в общие сборки, и используем эти общие сборки и в старом приложении, и также используем их в новом приложении.
3600.18 3615.54 SPEAKER_01 Дальше, если невозможно выделить в старой сборке, мы код просто-напросто дублируем, оставляем кусок в старом приложении, пусть он работает дальше, и дублируем его в новое, и переписываем под новые реалии, под новые адаптеры.
3615.54 3623.06 SPEAKER_01 И после этого мы уже постепенно начинаем переносить логику и контроллеры из старого приложения в новое приложение.
3623.06 3640.90 SPEAKER_01 В этот момент, когда мы переносим, в новом приложении появляется какая-то функциональность, и эта функциональность будет работать именно в новом приложении, и в старое приложение, в YARP, мы ее не отсылаем, то есть YARP уже на старое приложение не будет редиректировать те части, которые заимплементированы в новом приложении.
3640.90 3648.74 SPEAKER_01 И таким образом, постепенно перенося все эти контроллеры, перенося всю эту бизнес-логику, у нас старое приложение иссыхает, а новое приложение полнеет.
3648.74 3659.86 SPEAKER_01 И в конце концов, когда у нас вся эта эпопея закончится, мы должны будем полностью удалить YARP, то есть удалить серии директ на старое приложение, потому что там, по идее, уже не должно ничего остаться.
3659.86 3665.70 SPEAKER_01 Удаляем само старое приложение и используем новое приложение как таковое.
3665.70 3678.50 SPEAKER_01 У нас остается три блока, это реквесты, входящие к нам от пользователей, это новое приложение, в котором мы перенесли всю бизнес-логику и непосредственно исполняется бизнес-логика уже в домене нового приложения, потому что мы ее портировали и перенесли.
3678.50 3682.42 SPEAKER_01 Вот так красочно Microsoft описывает вот эту стратегию, которая должна происходить.
3682.42 3686.94 SPEAKER_01 По пути, как вы, наверное, догадались, существует очень много подводных камней.
3686.94 3693.82 SPEAKER_01 Это, например, несовместимости третьесторонних библиотек, которые не согласны переноситься на новую версию.
3693.82 3700.74 SPEAKER_01 Это, например, код, который невозможно мигрировать, его концептуально-семантического аналога, например, в новом фреймворке.
3700.74 3705.50 SPEAKER_01 Какие-то отсутствующие фичи, которых тоже или не завезли, или они больше почему-то не нужны и так далее.
3705.50 3708.34 SPEAKER_01 Ну, то есть не все возможно так просто перенести.
3708.34 3721.14 SPEAKER_01 Поэтому шаблон этот хороший, им двигаться надо, но практической пользы, отвечающие на вопросы, а что делать, когда что-то не получается, эта статья не дает.
3721.14 3724.22 SPEAKER_01 Поэтому Джимми Богарт и решил поделиться своим опытом.
3724.22 3734.26 SPEAKER_01 Он тоже взял этот шаблон и решил более подробно, с большими примерами описать, что происходило в их команде с их проектом.
3734.26 3741.30 SPEAKER_01 Прежде всего, для начала, давайте разберемся, что мы хотим получить.
3741.30 3773.38 SPEAKER_01 Хотим мы получить это полностью уничтоженное, нивелированное .NET Framework приложение, которое нам больше не нужно, мигрированное вся необходимая бизнес-логика и функциональность в новое .NET приложение на последнюю версию .NET, а также все компоненты, которые у нас были неподдерживаемы или несовместимыми, мы могли бы или удалить их, или заменить чем-то, или переписать, или как-то портировать по-другому и так далее.
3773.38 3781.14 SPEAKER_01 В это же самое время можно было пора обновить все те библиотеки, которые сейчас поддерживаются.
3781.14 3785.46 SPEAKER_01 Есть несколько версий, никакой проблемы там перенести их нет между двумя приложениями.
3785.46 3807.30 SPEAKER_01 И резонно встает вопрос, если мы вообще начинаем переписывать абсолютно все приложение, но по сути, когда мы начинаем менять фреймворк, обновлять библиотеки, мы по сути там большую часть его переписываем, стоит ли нам обновлять все библиотеки, допустим, до самой последней версии и переписывать какие-то куски кода, которые давно хотелось переписать.
3807.30 3821.94 SPEAKER_01 Вот, и Эндрю отвечает, что нет, этого делать не стоит, потому что иначе вы сильно размажете контекст, и размажете свою основную цель, то есть наша основная цель – это перевести на новый .NET Framework и новый S/P/NET Core.
3821.94 3835.80 SPEAKER_01 Все остальное там, улучшение перфоманса, искривление старых багов, что давно хотелось переписать или замена одной хорошей библиотеки на другую хорошую библиотеку – все это не должно делаться в рамках этой задачи, иначе вы здесь завязнете.
3835.80 3844.58 SPEAKER_01 Вы должны минимизировать риски и брать в скоб как можно меньше задач, тот минимум, который вам необходим.
3844.58 3851.86 SPEAKER_01 Поэтому мы не заинтересованы в полном переписывании всего приложения, мы заинтересованы в минимальном переносе.
3851.86 3855.66 SPEAKER_01 Теперь попробуем посмотреть на рынок, что же нам предлагается в плане тулинга.
3855.66 3862.78 SPEAKER_01 Сразу можно сказать, что хорошего, понятного тулинга, который бы за вас сделал какую-то большую работу, его нет.
3862.78 3867.78 SPEAKER_01 Есть какие-то наработки у разных компаний, о многих из них мы рассказывали в подкасте.
3867.78 3877.70 SPEAKER_01 Например, у старого .NET CLI есть специальные анализаторы, которые помогают вам сделать вот такую вот… Эту миграцию немножко легче.
3877.70 3887.50 SPEAKER_01 Делают они следующее, они вам генерят HTML-отчет, в котором рассказывают, какие компоненты есть, во что они там превращаются, как они совместимы и что у вас работать не будет.
3887.50 3893.26 SPEAKER_01 Но на самом деле этот отчет довольно такой поверхностный и много пользы вам не принесет.
3893.26 3902.42 SPEAKER_01 Поэтому Джимми решил не надеяться на какие-то автоматизированные конвертеры, а решил пойти и руками разработать план, что нужно сделать, чтобы это все перенести.
3902.42 3913.94 SPEAKER_01 Например, они проанализировали .NET фреймворк, ISP.NET фреймворк, те зависимости, которые у них есть, и вывели несколько секций, над которыми им нужно будет поработать.
3913.94 3930.18 SPEAKER_01 Это MVC HTTP endpoint, не MVC HTTP endpoint, ISP.NET MVC middleware, ISP.NET просто middleware и зависимости, которые есть в основном в контроллерах и в middleware, которые необходимы для ISP.NET.
3930.18 3942.14 SPEAKER_01 Если разобраться подробнее, то MVC endpoints – это такие штуки, которые позволяют кастомизировать программу в рантайме, и в частности, например, роуты, контроллеры и так далее.
3942.14 3945.54 SPEAKER_01 Все это относится как раз к endpoints.
3945.54 3955.26 SPEAKER_01 Джимми говорит, что он не нашел способа, как в рантайме, например, собрать все контроллеры, все endpoints и выяснить вообще, какие endpoints существуют, допустим, в системе.
3955.26 3974.54 SPEAKER_01 По мне это довольно странно, потому что довольно давно в ISP есть API Explorer, на основании которого работает Swagger, допустим, и этот Swagger прекрасно перебирает все endpoints и показывает все методы, все параметры, все аргументы, и скорее всего в вашем случае вы можете им воспользоваться.
3974.54 3991.78 SPEAKER_01 Но так как Джимми не нашел, тоже проблемы большой не составило, он написал как тестик, в этом тесте просто собрал из сборки все типы, посмотрел, кто из них наследуется от контроллеров, забрал все публичные методы, которые являются HTTP методами, и выбрал основную информацию.
3991.78 4007.98 SPEAKER_01 В частности, это полное имя контроллера, это количество экшенов, которые контроллер предоставляет, т.е. по сути HTTP методов, HTTP endpoints, которые контроллер предоставляет, и количество зависимостей в конструкторе этого контроллера.
4007.98 4025.46 SPEAKER_01 И это примерно позволило собрать список issues, которые примерно выражали сложность перевода, т.е. мы теперь знаем, сколько контроллеров надо перевести, сколько методов перевести, и насколько много у них сложных зависимостей в их конструкторах.
4025.46 4032.10 SPEAKER_01 Это уже более-менее можно скастить в какие-нибудь issues, можно это уже как-то делать.
4032.10 4047.06 SPEAKER_01 Следующее – это не NVC HTTP endpoints, такие как ISPx-странички, ISM-вебсервисы, ISHx-вебхендлеры, я большинстве этих акронимов уже и не знаю.
4047.06 4053.90 SPEAKER_01 В общем, специальные методы расширения для сервиса, для хендлеров и т.д., которые есть у нас в ISP-нете.
4053.90 4061.26 SPEAKER_01 К счастью, они находятся довольно-таки легко, банально по методу расширения, по расширению файла.
4061.26 4072.34 SPEAKER_01 Поэтому он написал PowerShell скрипт, который нашел все файлы с такими расширениями и тоже добавил их в список заданий, потому что, понятно, вот тебе файл, у него какая-то одна компетенция, этот файл легко переводится.
4072.34 4075.62 SPEAKER_01 Т.е. тоже независимый параллельный блок, уже был выделен.
4075.62 4093.46 SPEAKER_01 ISP-нет NVC middlewari, эти middlewari немножко отличаются от тех middlewari, которые мы знаем в ISP-нет core, и в основном они зарегистрированы в файле global_assox.cs, и здесь можно как раз найти и MC middlewari, и прочие конфигурации.
4093.46 4114.38 SPEAKER_01 Например, там есть глобальные фильтры, которые перехватывают все события, там есть регистрация роутов, там есть регистрация view-энжинов, которые рендерят вам выходной запрос, и анализируя этот файл, тоже вы примерно понимаете, с какими, например, view-энжинами работало это приложение, т.е. какие view-энжины вам нужно поддержать, переписать или найти их аналоги.
4114.38 4136.22 SPEAKER_01 Дальше у нас есть авинковская кастомизация, это то, что записано в авинстартап-файле, например, там же подключается сигнал-эр, подключаются хендфайры, там настраивается аутентификация, что тоже, опять же, должно быть вынесено в отдельные пункты для того, чтобы мы не забыли это учесть в новом приложении, т.е. инфраструктура, которую мы должны поддержать, прежде чем двигаться дальше.
4136.22 4156.06 SPEAKER_01 ISP-нет middlewari, они хранились в WebConfig, и WebConfig – это на самом деле такая катомка, в которой может быть запрятано огромное количество магии, особенно в секциях System Web и System Web Server.
4156.06 4179.18 SPEAKER_01 Там есть конфигурации хендлеров, конфигурации модулей, их настройки, их какие-то кастомные фильтры, по которым должны только они срабатывать, например, в этой секции настраивается Glimpse, и нужно очень тщательно и категорично подходить к тому, что из всего этого найденного вы хотите переносить, а что не хотите.
4179.18 4186.58 SPEAKER_01 Безусловно, некоторые вещи там поддерживают уже ISP-net Core из коробки, некоторые нет, ну, например, та же самая авторизация, которая здесь есть.
4186.58 4192.74 SPEAKER_01 Авторизация – это довольно критическая штука, ее переносить надо 100% по-любому, вы от этого никуда не денетесь.
4192.74 4209.58 SPEAKER_01 А вот Glimpse – это не самая критическая вещь, и в принципе ее можно не переносить или переносить когда-нибудь потом, т.е. в рамках вот этого проекта вполне можно было бы пожертвовать такими библиотеками, которые были созданы чисто для удобства и ни для чего более.
4209.58 4212.22 SPEAKER_01 В общем, здесь нужно смотреть.
4212.22 4213.22 SPEAKER_01 Зависимости.
4213.22 4220.14 SPEAKER_01 В общем, зависимости можно разделить на два типа – это пакетж зависимости и лайберальд зависимости.
4220.14 4226.54 SPEAKER_01 Ну, не знаю, у всех нормальных людей давно уже все переведено на пакетж зависимости, и лайберальд напрямую никто не тащит за собой.
4226.54 4227.54 SPEAKER_01 Вот.
4227.54 4232.22 SPEAKER_01 И найти их довольно легко, анализируя разнообразные конфиги.
4232.22 4237.94 SPEAKER_01 Если вы анализируете пакетж конфиг, если вы проанализируете, то вы в основном найдете все зависимости, которые вам нужны.
4237.94 4240.38 SPEAKER_01 Тоже как бы понятно, что куда и где переводить.
4240.38 4252.50 SPEAKER_01 Эти зависимости тоже надо подробнее рассматривать, например, какие-нибудь Microsoft и SPNET зависимости, которые также есть в пакетже с конфиг, их просто не нужно никуда переводить, они нам приходят бесплатно с новым фреймворком.
4252.50 4255.66 SPEAKER_01 Поэтому никакой альтернативы для них искать не надо.
4255.66 4268.06 SPEAKER_01 Некоторые зависимости у вас будут, например, задеприкечены, то есть те библиотеки, которые вообще никогда не были переведены на новые .NET, и вам нужно будет искать их альтернативу.
4268.06 4282.42 SPEAKER_01 Некоторые зависимости могут содержать breaking changes, допустим, если какая-то зависимость, если какая-то библиотека перемахнула мажор версию, и только в мажорной версии поддерживает новый фреймворк, и вам нужно вот этот конфликт каким-то образом будет устранять.
4282.42 4290.62 SPEAKER_01 В общем, здесь очень много есть тонкостей, очень много есть моментов, что вы будете делать с этими библиотеками.
4290.62 4294.98 SPEAKER_01 И обычно все эти моменты нужно рассматривать индивидуально.
4294.98 4310.06 SPEAKER_01 Иногда может случиться так, что вы вообще не сможете обновить зависимость, то есть если она задеприкечена, и вам делать с ней больше… И альтернативы никакой нет, и вы не знаете, что с этим делать, то есть невозможно кусок просто мигрировать на новый фреймворк, и это моменты самые рискованные.
4310.06 4322.78 SPEAKER_01 На них нужно обратить внимание прежде всего, потому что непонятно, сможете ли вы вообще заменить эту функциональность, как заменить, сможете ли вы эту функциональность вообще удалить из своего приложения, если вдруг замены не найдется.
4322.78 4330.34 SPEAKER_01 То есть это самые рискованные моменты, и на них прежде всего нужно обращать внимание, то есть на те библиотеки, которые в будущем фреймворке вообще отсутствуют.
4330.34 4338.06 SPEAKER_01 Таким образом, вот пройдясь по этому основному списку ISP.NET, мы собрали основные issues для нашей работы.
4338.06 4347.90 SPEAKER_01 То есть мы примерно разделили это на минимальные независимые единицы, большинство из которых можно делать абсолютно параллельно, они ни от чего не зависят, и постепенно их переводить.
4347.90 4353.82 SPEAKER_01 Теперь самое время настроить наш дипломат, настроить наш рантайм.
4353.82 4367.38 SPEAKER_01 Как Микрософт и говорил, с самого начала создаем пустой прокси, и для того, чтобы создать пустой прокси, мы можем воспользоваться Visual Studio, у нее есть классный визард.
4367.38 4370.86 SPEAKER_01 Но прежде всего, что мы будем делать с этим прокси?
4370.86 4380.54 SPEAKER_01 Это отдельный класс, отдельный проект, который будет помещен в ваш solution, и изначально не пытайтесь запихнуть туда всякой логики.
4380.54 4391.34 SPEAKER_01 Самая основная задача этого шага – это научиться его билдить, паковать, деплоить, выпускать в продакшн и вообще научить его работать, чтобы он просто был пустой и тупо работал.
4391.34 4402.38 SPEAKER_01 То есть изначально наш прокси будет обрабатывать ничего и абсолютно все запросы проксировать через ярп на наш старый работающий проверенный сервер.
4402.38 4414.98 SPEAKER_01 В нашем проксе должно быть ноль контроллеров, у него не должно быть никакого API, никаких роутов, никаких медлевария, ни авторизации, ни аутентификации, вообще ничего.
4414.98 4431.90 SPEAKER_01 Пустой проект, который все запросы просто переводит на старый фреймворк, и нам нужно просто заставить это приложение встроиться в наш pipeline, чтобы мы такой своеобразный hello world выпустили, который просто запускается и точно работает.
4431.90 4441.42 SPEAKER_01 Как я уже сказал, в этом нам может помочь Visual Studio, у нее есть замечательный upgrade assistant, который пытается вам помочь в апгрейде.
4441.42 4447.02 SPEAKER_01 У него есть различные типы, как он может вам помочь, то есть различные типы миграции.
4447.02 4452.66 SPEAKER_01 В частности, если приложение маленькое и простое, он легко вам его сконвертит, просто без всяких загонов.
4452.66 4467.98 SPEAKER_01 В нашем случае приложение большое, толстое, старенькое, поэтому нам подходит тип, как раз описанный в статье Microsoft, это создать в том же самом солюшене core приложение и настроить его fallback на наше существующее старое фреймворк приложение.
4467.98 4471.46 SPEAKER_01 То есть это стандартный template Visual Studio готов вам предложить.
4471.46 4475.62 SPEAKER_01 И через пару кликов у вас уже такое приложение может быть в солюшене.
4475.62 4478.90 SPEAKER_01 Опять же, без контроллеров, без ничего, но зато уже с ярпом.
4478.90 4486.26 SPEAKER_01 Далее, мы должны, чтобы это все дело заработало, мы должны подготовить некую платформу.
4486.26 4494.18 SPEAKER_01 Прежде всего мы должны добавить system web adapters, о котором я упоминал ранее, набор компонентов, который позволяет нам облегчить немножко миграцию.
4494.18 4498.44 SPEAKER_01 Мы должны немножко настроить реверс-прокси, то есть наш ярп.
4498.44 4505.38 SPEAKER_01 Настраиваем мы таким образом, что он должен захватывать все запросы и перенаправлять на фреймворк приложения.
4505.38 4515.38 SPEAKER_01 Перенаправлять тоже нужно с умом, здесь очень важно это порядок, приоритет, здесь правильно сказать, приоритет этих запросов, приоритет перенаправления.
4515.38 4531.26 SPEAKER_01 Мы должны смапить наш ярп таким образом, чтобы в первую очередь выполнялись локальные контроллеры, и если они не найдены, вот только тогда он должен переводить все запросы на фреймворк приложения.
4531.26 4554.06 SPEAKER_01 Таким образом, еще нам нужно настроить все middlewari, которые мы будем настраивать, у нас сейчас ее нет, но когда мы их будем переносить, все middlewari должны быть настроены до вызова метода вот этого map forward, где мы как раз и настраиваем наш ярп для того, чтобы все middlewari тоже успели отработать до того, как их перенаправят, если вдруг они отработают нехорошо.
4554.06 4570.38 SPEAKER_01 Таким образом, у нас получилось абсолютно бесполезное с точки зрения функциональности приложение, которое всего лишь навсего редиректит, но зато очень полезное по сути своей, по структуре, по схеме и создающее нам плацдарм для дальнейшей работы.
4570.38 4581.90 SPEAKER_01 Мы можем запустить теперь это dotne6 приложение, и самое интересное, что обращаясь к этому dotne6 приложению, мы можем получать контент, настоящий рабочий контент, потому что все запросы перенаправляются на старый фреймворк.
4581.90 4585.42 SPEAKER_01 То есть мы работаем с dotne6 приложением, но при этом получаем контент из старого фреймворка.
4585.42 4588.02 SPEAKER_01 Это как раз то, что нам было нужно и то, чего мы добились.
4588.02 4612.34 SPEAKER_01 Для того, чтобы встроить это в pipeline, ребята зарегистрировали в easy новый веб-сайт, добавили туда ispnet-core-6-hosting-module, что позволяет хостить новый фреймворк LTS, промодифицировали deployment pipeline в своих приложениях, но эта больше специфика не сильно интересна.
4612.34 4615.86 SPEAKER_01 Теперь, наконец, переходим к переносу.
4615.86 4626.14 SPEAKER_01 И вот когда мы начинаем переносить, самое первое, что стоит сделать еще до того, как мы начали что-то переносить, это позаботиться об обновлении пакетов.
4626.14 4633.46 SPEAKER_01 Очень важно здесь выяснить, какую общую версию могут поддерживать пакеты из ваших зависимостей.
4633.46 4638.58 SPEAKER_01 Например, найти пакет, который одновременно поддерживает и старый фреймворк, и новый.
4638.58 4641.02 SPEAKER_01 Это иногда возможно сделать.
4641.02 4646.58 SPEAKER_01 Если эта штука возможна, то вам необходимо этим вопросом заняться.
4646.58 4649.18 SPEAKER_01 Дальше нам нужно сделать шареную сборку.
4649.18 4655.42 SPEAKER_01 Мы помним рекомендации Microsoft, мы первым делом делаем шареную сборку и пытаемся вынести в эту шареную сборку все, что возможно.
4655.42 4658.90 SPEAKER_01 В нашем случае это все, что не завязано на ispnet-компоненты.
4658.90 4671.38 SPEAKER_01 То есть ispnet у нас полностью поменяется, вся обвязка контроллера поменяется, но есть очень много классиков, которые никак не зависят от isp, которые просто выделены в какую-то свою область.
4671.38 4681.30 SPEAKER_01 Также нужно не забывать о коде, который не завязан напрямую на ispnet, но завязаны другие сторонние библиотеки.
4681.30 4690.10 SPEAKER_01 Например, это EF6 конфигурации, никакого отношения к ispnet не имеет, но это отдельный большой влог, который как-то возможно нужно будет мигрировать.
4690.10 4699.46 SPEAKER_01 Это view-модели, это медиаторы, это di-конфигурации, которые тоже могут быть несовместимы с новыми версиями, допустим, тех библиотек, куда вы их переносите.
4699.46 4704.66 SPEAKER_01 И общие рекомендации, что делать со всеми этими вещами, их нет.
4704.66 4713.82 SPEAKER_01 Рекомендация подходить к каждому из этих больших внешних зависимостей индивидуально и шаг за шагом по одному их переносите.
4713.82 4733.22 SPEAKER_01 И еще, например, если вы правильно разбивали свое приложение, например, клина Architecture, у вас всегда будет слой домена и слой даты, которые полностью независимы от ispnet, и вы их можете переносить, по идее, один к одному, вообще никак не загоняясь никакими тонкостями и подробностями.
4733.22 4758.34 SPEAKER_01 Теперь если посмотреть на зависимости, на вот эти зависимые библиотеки, которые нужно каким-то образом переносить, здесь легче всего воспользоваться каким-нибудь анализатором или тулом, который соберет вам все зависимости из всех ваших проектов и примерно представит вам, какая версия у вас есть сейчас и в какую версию вы хотя бы хотели бы переместиться, какая минимальная версия вам достаточна для того, чтобы мигрировать.
4758.34 4767.02 SPEAKER_01 Ну, например, такими библиотеками могут служить автомапер, антл, делегат декомпайлер, энтити фреймворк, флюэн валидейшн, медиатор.
4767.02 4777.30 SPEAKER_01 В общем, это такие фреймворки, о которых нужно задуматься, как вы их будете переводить, на какую версию и, может быть, даже сделать какие-то начальные шаги для того, чтобы подготовиться к их переводу.
4777.30 4784.46 SPEAKER_01 Очень удобно в этот момент пользоваться экстатическими анализаторами, как самописными, так и сторонними инструментами, например, n-depend.
4784.46 4795.26 SPEAKER_01 Есть такая прекрасная тулза, которая помогает вам анализировать ваш проект и рассказывает очень много информации о том, что у вас в проекте есть.
4795.26 4800.70 SPEAKER_01 Также она умеет хорошо находить неиспользуемые пакеты, что чем непременно нужно воспользоваться.
4800.70 4809.42 SPEAKER_01 Если у вас есть старый проект, то с очень большой вероятностью там огромная куча неиспользуемых пакетов вообще, и вы их можете безболезненно удалить, при этом не тратя время на их миграцию.
4809.42 4818.26 SPEAKER_01 Итак, прежде чем эти пакеты каким-то образом начинать переводить, повысим версию.
4818.26 4823.74 SPEAKER_01 Эта версия должна поддерживать оба фреймворка, и старый, и новый, если это возможно.
4823.74 4831.06 SPEAKER_01 Теперь перейдем к этапу создания Shared Library, т.е. мы теперь должны создать какую-то общую библиотечку, в которой начнем выносить свой код.
4831.06 4838.78 SPEAKER_01 И первое, что нам нужно, каким вопросом нам нужно задаться, когда мы создаем этот Shared Library, а какой таргет фреймворк будет у этой Shared Library?
4838.78 4848.22 SPEAKER_01 Ну, вестимо, если она должна использоваться и в старом приложении, и в новом, здесь должен быть какой-то таргет фреймворк, который можно зареференсить и в старом приложении, и в новом.
4848.22 4850.62 SPEAKER_01 Сразу на ум приходит NetStandard 2.0.
4850.62 4855.50 SPEAKER_01 Но, к сожалению, не все библиотеки поддерживают NetStandard 2.0.
4855.50 4860.50 SPEAKER_01 Например, Автомапер бросил поддержку NetStandard с версии 11.
4860.50 4867.74 SPEAKER_01 Энтити Фреймворк, например, поддерживает одновременно и .NET Framework, и .NET Standard 2.1, они поддерживают при этом 2.0.
4867.74 4871.46 SPEAKER_01 В общем, и таких библиотек их полно, у всех свои загоны.
4871.46 4882.42 SPEAKER_01 Поэтому общего стандарта, вот такого, как хотелось бы с самого начала, как, наверное, планировали авторы этого NetStandard, который объединит все, его, по факту, на практике сделать не получается.
4882.42 4903.66 SPEAKER_01 Таким образом, Джимми пришел к выводу, что самый простой и понятный способ – это не пытаться загнать все под один стандарт, потому что одного стандарта не существует в его практическом кейсе, и они выбрали таким образом, что Shared Library поддерживает мультитаргет.
4903.66 4911.78 SPEAKER_01 То есть она одновременно компилится и под .NET 4.8, и одновременно компилится под NetStandard 2.1.
4911.78 4922.06 SPEAKER_01 Такая двойная компиляция позволяет добиться довольно большой гибкости и при этом поддержать абсолютно все библиотеки, которые есть.
4922.06 4931.58 SPEAKER_01 Если библиотека одной версии существует только там, и только второй версии она существует только там, это тоже возможно все сделать, поддержать в мультитаргете.
4931.58 4941.74 SPEAKER_01 Следующим этапом вы должны обновить ваши зависимости в соответствии с тем, чтобы они попали в этот Shared Library.
4941.74 4947.82 SPEAKER_01 Затем переместить ваши типы в этот Shared Library, в общую библиотеку.
4947.82 4955.14 SPEAKER_01 Желательно, конечно же, использовать инструменты рефакторинга, то есть не ручками это все дело копировать, а именно рефакторингом.
4955.14 4960.14 SPEAKER_01 Тогда у вас процесс будет намного быстрее и безопаснее.
4960.14 4967.66 SPEAKER_01 И подключить вот этот Shared Library к .NET Core App, то есть к нашему новой сборке, нашему новому приложению.
4967.66 4987.86 SPEAKER_01 В старом приложении, естественно, мы выносим, оно там и так подключено, оно там и так продолжает работать, логика из него никуда не девается, мы ее не меняем, мы только лишь меняем ее расположение, и в этот момент вы уже эту Shared Library можете подключить в ISP .NET Core, то есть в нашем новом приложении уже есть там, уже начинает быть какая-то логика общая, которую можно уже начинать переиспользовать.
4987.86 4998.78 SPEAKER_01 На самом деле серия статей огромная, и я вам сейчас рассказал где-то примерно половинку, и чтобы, наверное, вас не утомить, я ее разобью на две части, поэтому на сегодня достаточно.
4998.78 5003.76 SPEAKER_01 Если вам понравилось, пишите в комментариях, и на следующем выпуске мы продолжим.
5003.76 5019.06 SPEAKER_01 Небольшая замануха, как раз во втором выпуске мы прообсудим о том, как переносить контроллеры, бизнес-логику, вьюшки и расшаренные сессии, то есть очень много практических интересных кейсов, наверное, вот там тоже оставлено будет на вторую часть.
5019.06 5027.54 SPEAKER_01 Поэтому на сегодня все, давайте немножко отдохнем и переметнемся на какую-нибудь другую тему, новую, свежую, интересную.
5027.54 5030.82 SPEAKER_01 Действительно, какую бы нам новую, свежую, интересную тему.
5030.82 5031.82 SPEAKER_01 Давно мы не говорили об интернет-эспайр.
5031.82 5032.82 SPEAKER_01 А, эспайр, точно.
5032.82 5033.82 SPEAKER_01 Не было.
5033.82 5049.66 SPEAKER_01 Я, кстати, еще хочу добавить, что, возможно, Джимми еще успеет что-нибудь дописать, поэтому ты так четыре, конечно, статьи новых анонсировал, в смысле продолжение второй части, но мы потом и до третьей доберемся, так что… Вполне может быть, потому что там эпопея довольно занимательная, хорошая, и самое главное, очень практически полезная.
5049.66 5050.66 SPEAKER_01 Да.
5050.66 5057.06 SPEAKER_01 Но тем не менее, давай вернёмся в эспайр, и в эспайр мы вернёмся с немножко, наверное, может быть, странной точки зрения.
5057.06 5078.38 SPEAKER_01 Именно есть такой человек, его зовут Оскар Дудыч, я не знаю, как он произносится, это чешская фамилия, вероятно, это автор, один из авторов, по крайней мере, фреймворков Мартин и Волверин, это, я так понимаю, некоторые опинионы, опять же, модель для всякого event-driven штук на дотнете.
5078.38 5092.02 SPEAKER_01 И вот он написал как раз статью, почему он не будет использовать, и почему он считает, что дотнет-эспайр сейчас использовать особо не получится, ну, по крайней мере, в его личном, так сказать, сценарии.
5092.02 5096.06 SPEAKER_01 Ну, неплохо, хорошее мнение, как ведущая против толпы, давай-давай.
5096.06 5107.38 SPEAKER_01 Да-да-да, он как раз и сказал, что типа я сначала что-то подумал, подумал, решил, что в гитхапише вписать такое, наверное, неправильное место, поэтому он сначала написал у себя в линктейне, а потом оформил это в отдельный пост в своём блоге.
5107.38 5120.54 SPEAKER_01 И получилось в итоге следующее, значит, надо сказать, что он всё это пробовал на превью-1, т.е. ещё не было превью-2, поэтому некоторые штуки, наверное, ну, скажем так, устарели и уже являются неверными, но, тем не менее.
5120.54 5121.90 SPEAKER_01 Значит, перечислим по всему.
5121.90 5147.58 SPEAKER_01 Во-первых, что он говорит, что у него были некоторые ожидания, т.е. понятно, что когда он послушал, как и все остальные анонсы этого дела, у него были некоторые ожидания, что это будет крутой тул для локал-девелопмента, вот это вот всё, они даже говорят, что мы, блин, готовы даже написать свои компоненты, чтобы вот эти вот Мартин и Вольверин штуки как-то, если они в Aspire должны интегриться хорошо, давайте мы их законтрибьёте.
5147.58 5215.02 SPEAKER_01 Казалось бы, всё здорово, но, как он сказал, что кажется, что Aspire не юзабл даже для локальной разработки, т.е. вообще не юзабл ни для чего, кроме тех случаев, если вы используете Винду и Visual Studio, ну, т.е. надо сказать, что Aspire действительно с Visual Studio ведёт себя прям шикарно, т.е. если вы, например, имеете Solution, в котором есть несколько запускабельных проектов, каждый из которых — это отдельный микросервис, например, то Aspire сам умеет так работать, что Visual Studio подключится отладчиком ко всем вашим проектам одновременно, без необходимости указывать там в Солюшене, как там это называется, Multiple Startup Projects, вот это всё, т.е. это всё действительно работает максимально прозрачно именно для Visual Studio, но Fowler обещал, что в VSCode тоже будет хорошо, и, наверное, они это улучшат, но пока типа вот считается, что это самый правильный способ — это, конечно, Винду с Visual Studio, а Оскар работает на Ubuntu, ну или на каком-то из, типа, дистрибутивов, построенных на Ubuntu, на Linux, и поэтому он говорит, что у прям было сложно.
5215.02 5246.70 SPEAKER_01 Во-первых, типа очень сложный сетап, во-первых, вам нужно добавить 2 новых проекта, на самом деле, когда я рассказывал про Aspire в позапрошлом подкасте, когда мы всё это анонсировали только, я говорил, что фактически проект достаточно только один, тот, который, собственно, сам .NET Aspire Project, ещё один если нужно, он заменяет дефолты сервисов, т.е. можно заменить конфигурацию каждого из используемых ресурсов через, собственно, код, а можно создать и новый проект отдельный, в котором эти все дефолты будут прописаны.
5246.70 5253.06 SPEAKER_01 Ну, короче, можно обойтись одним, но официальная документация говорит, что можно добавлять два.
5253.06 5265.46 SPEAKER_01 Во-вторых, нужно все проекты иметь в едином solution, потому что в Preview 1 нужно было обязательно делать ссылку из Aspire проекта в любой другой проект, который должен был быть ресурсом.
5265.46 5273.94 SPEAKER_01 Как я сказал, в Preview 2 добавили функциональность, что теперь можно CSS Project референсить хоть через просто относительный путь до него.
5273.94 5287.90 SPEAKER_01 Не знаю, насколько это влияет на Developer Experience с точки зрения отладчика и всего остального, не проверял, но по идее почему бы нет, если, как бы, одно приложение запустилось, отладчик к нему может подключиться в любом случае.
5287.90 5299.78 SPEAKER_01 Но, тем не менее, на момент Preview 1 и на момент написания этой статьи действительно нужно было все иметь в одном solution, и это, ну, как бы, далеко не всегда возможно.
5299.78 5315.06 SPEAKER_01 Дальше Оскар жаловался, что, ну, то есть они используют свой собственный Control Plane, тот самый DCP, который еще нужно установить, то есть для этого нужно использовать всякий .NET Workload Install, он там не всегда хорошо работает, по его словам, на его Ubuntu он вообще не смог ничего поставить.
5315.06 5317.74 SPEAKER_01 Вообще он не смог на Ubuntu запустить Aspire.
5317.74 5318.74 SPEAKER_01 Вот.
5318.74 5331.50 SPEAKER_01 Комменты к нему, конечно, сразу прибежали со словами «да нет, там, короче, все было нормально, в общем, .NET Workload Install, потом, там, .NET New приложение, оно создастся там с Aspire сразу, и, в общем, все работает».
5331.50 5334.66 SPEAKER_01 Но у него, в общем, на его проектах не заработало.
5334.66 5346.94 SPEAKER_01 Документацию, он говорит, пока тоже так себе, ну, я, собственно, про это говорил там парой статей выше, да, про то, что как создавать компоненты не описано, было, по крайней мере, не знаю, как сейчас, и, вероятно, с точки зрения пользователя тоже было еще пока так себе.
5346.94 5368.78 SPEAKER_01 И он говорит, то есть его, в общем, выводы из этой статьи, она такая довольно коротенькая, там, буквально, типа, полтора экрана, про то, что, кажется, что более правильным стратегически, это вот то, про что мы с тобой говорили недавно, было бы сделать вот этот самый .NET Aspire менее, так скажем, амбициозным проектом.
5368.78 5380.10 SPEAKER_01 То есть, таким, не попыткой, как вот мы обсудили сделать из него и дашборд, и запускалку, и сервис дискавери, и вообще все.
5380.10 5383.06 SPEAKER_01 Он говорит, а, скорее, такой, а-ля, типа, Spring Boot для .NET.
5383.06 5393.50 SPEAKER_01 То есть, некоторый способ притащить простым способом любые сторонние компоненты с хорошей дефолтной конфигурацией в ваш продукт.
5393.50 5397.34 SPEAKER_01 То есть, просто притащить любую стороннюю компонент — это легко, да?
5397.34 5398.34 SPEAKER_01 Ну, где-то пакет, и все нормально.
5398.34 5407.86 SPEAKER_01 А этот Aspire позволяет вам притащить хорошую конфигурацию за счет тех самых списка компонентов, заранее одобренных, плюс-минус, с удобной и правильной конфигурацией.
5407.86 5423.30 SPEAKER_01 И он говорит, что в текущем варианте кажется, что очень сложно найти нишу для такого продукта, потому что для каких-то таких, типа, pet-проектов или просто маленьких проектов кажется, что общий сетап какой-то overly complicated.
5423.30 5436.94 SPEAKER_01 Я пока не очень понимаю, о чем он говорит, в плане, что действительно по всем статьям получается, что пара команд-лайнов, и у тебя все работает, но действительно, если нужно какие-то дополнительные приседания, и там действительно много чего не работает, то, может быть, он и прав.
5436.94 5437.94 SPEAKER_01 Вот.
5437.94 5440.98 SPEAKER_01 Ну вот эти ворклоуды, все демоны эти страшные, мини-кубернетесы.
5440.98 5443.26 SPEAKER_01 Зачем тебе это для локального маленького проекта?
5443.26 5447.22 SPEAKER_01 Ну смотри, ворклоуд ставится как бы одной командой, а дальше все должно само работать.
5447.22 5448.62 SPEAKER_01 Ну вот, вероятно, не работает.
5448.62 5457.90 SPEAKER_01 Может быть, действительно, на винде действительно все хорошо работает, потому что это как бы, ну, как для Майкрософта это первичный, наверное, таргет.
5457.90 5466.30 SPEAKER_01 Я видел, действительно, в Гитхабе ищут, что на Маки что-то куда-то не те пути прописываются, еще что-то, то есть, ну, наверное, все не идеально, да.
5466.30 5467.30 SPEAKER_01 Вот.
5467.30 5480.30 SPEAKER_01 А для больших проектов, тут у него довольно странная фраза написана, написано, что эта штука too buggy, ну, может быть, она типа, ну, это все-таки превью один, блин.
5480.30 5482.98 SPEAKER_01 Я думаю, что в превью один, наверное, ты не потащишь это впрод.
5482.98 5496.66 SPEAKER_01 С другой стороны, вот странная часть фразы, звучит как, что она не привязана к open-стандартам, чтобы даже в принципе рассматривать эту штуку.
5496.66 5504.06 SPEAKER_01 Хотя, кажется, Ispire максимально привязана к стандартам, каким только можно, то есть там всякие open-телеметрии, вот это все, по крайней мере, со стороны мониторинга.
5504.06 5521.70 SPEAKER_01 А то, про что он имеет ввиду, про open-стандарты, это он про то, что Kubernetes, то есть про то, что вот это тут вместо проприетарного кастомного какого-то closed-source DCP надо было взять нормальный кубернетовский control plane, говорит он, с ним все понятно, он нормально работает на операционных системах.
5521.70 5535.30 SPEAKER_01 Тут как раз есть обратный эффект, он прекрасно работает на линуксе, потому что он для него написан, он неплохо работает на маке, и я не уверен, насколько он в принципе работает на винде, кубернетовский control plane.
5535.30 5562.50 SPEAKER_01 Поэтому понятно, что, ну, это немножко другая точка зрения, человек, который под винду не программирует в основном, и непонятно, насколько там была бы такая же хорошая интеграция, например, с Visual Studio, с точки зрения отладки, потому что кажется, что этот DCP содержит некоторое количество интеграций, возможно, из-за этого он и closed-source, в том числе с Visual Studio, чтобы, например, сказать как-то по какому-то кастомному протоколу Visual Studio, кому нужно теперь оттачиться с точки зрения отладки.
5562.50 5563.50 SPEAKER_01 Вот.
5563.50 5587.02 SPEAKER_01 И как бы сама по себе статья была бы, может быть, не так интересна, ну, как бы, кто-то в интернете что-то попробовал, у него не получилось, или он понял, что это не для него, или решил, что это не для него, ну и ладно, в принципе, это нормально, и я бы не ожидал, что любое там, не знаю, любая придумка Майкрософта в мире .NET будет обязательно радостно воспринята всеми разработчиками.
5587.02 5588.02 SPEAKER_01 Да нет, не обязательно.
5588.02 5594.98 SPEAKER_01 Это хорошо, что есть критика, хорошо, что есть те, кто что-то говорит, что вот тут не работает, это не работает.
5594.98 5621.14 SPEAKER_01 Интересный факт, и если вам интересно немножко более деталей почитать, в шоу-ноутах есть ссылка на LinkedIn, и туда, к нему в комменты в LinkedIn пришел собственно фаулер, и сейчас, Рубен Бонд, это один из, я так понимаю, тоже менеджеров ESPNET-а, и они там довольно конструктивно поабсурдали на предмет того, что да нет.
5621.14 5673.38 SPEAKER_01 То есть в качестве локального control plane, это как бы, скорее всего, нереально, потому что кубернет - это большой монстр, который, если мы от него начнем зависеть, то это будет прям совсем плохо, тем более на виде он вообще непонятно как работает, плюс нам нужна какая-то кастомизация, ну и плюс они там немножко прошлись по всяким аргументам, про то, что вот тут да, тут ты прав, нам нужно лучше поработать там с документацией, по-моему, еще с чем-то, с сложными проектами, когда у тебя много гид-репозиториев, там много разных салюшенов, да, есть над чем работать, ну в общем, там прям как бы видно, что с комьюнити они пытаются работать, пытаются вот выцепить эти статьи, по крайней мере конкретно эту, с каким-то недовольством и посмотреть, почему народу что-то может не нравиться, но он, например, не придет в GitHub ищет писать о том, что ему что-то не нравится, давайте сделаем по-другому.
5673.38 5680.90 SPEAKER_01 В общем, почитать Fowler в принципе интересно читать, он довольно аргументированно и неплохо пишет, вот, на мой взгляд.
5680.90 5683.02 SPEAKER_01 Хотя я не всегда согласен с его мнением.
5683.02 5718.54 SPEAKER_01 Так что посмотрим, посмотрим, я пока вот из тех, кто действительно сказал бы, что для простых проектов кажется, что да ну нафига, а на больших я пока не попробовал его вписать в какой-нибудь, ну хотя бы приличный большой проект, то есть вот наш там текущий, который .NET-ный у меня на работе есть, это, по-моему, что-то типа три салюшена, каждый проектов по 10, что ли, ну понятно, большая часть из них это либы, один салюшен пакуется в NuGet, то есть тут надо посмотреть, что из всего этого получится и насколько это в принципе будет полезно.
5718.54 5730.14 SPEAKER_01 Пока не знаю, может быть, действительно, когда попробую это вписать в локальную разработку, пойму, что тоже невозможно пользоваться, потому что слишком много там приседаний вокруг ради непонятной выгоды.
5730.14 5732.14 SPEAKER_01 Особенно под Mac или под Linux.
5732.14 5749.78 SPEAKER_01 Ну вот как раз под Mac или под Linux, может быть, штука чуть более, не знаю, там нет такой необходимости интегрироваться с Visual Studio, понимаешь, с другой стороны тогда как бы, а нафига Aspire можно чуть другое взять, если есть нормальный мониторинг, Dashboard и те самые, они конечно хороши.
5749.78 5766.70 SPEAKER_01 Ну, смотри, давай рассмотрим такую ситуацию, мне кажется, чувак довольно прав в том аспекте, что Aspire слишком много на себя берет, да, то есть он лезет сразу в несколько направлений, которые каждое отдельно можно было бы вполне закрывать каким-нибудь отдельным продуктом.
5766.70 5773.18 SPEAKER_01 И наверняка каждое из этих направлений можно было бы там выделить отдельную команду и работать на ним более тщательно.
5773.18 5782.22 SPEAKER_01 То есть смотри, он там и Dashboard и контейнерами управляет, и конфиги настраивает, и каталог самых лучших настройок ведет, как бы много, много обязанностей.
5782.22 5810.70 SPEAKER_01 Да, с другой стороны можно посмотреть, что я так понимаю, что Dashboard, они сильно много сил, кажется, что не тратили, потому что там тот же Fowler говорит, что да, вообще фигня вот этот вот трейсер, да, визуализатор трейсов, который можно видеть в Dashboard, он там типа за недельку написан этим James Newton King, то есть он там взял, вырень-ка за недельку все нафигачил, я не знаю, сколько они потом там доводили его до продакшн состояния, но это уже другой вопрос.
5810.70 5827.70 SPEAKER_01 То есть кажется, что вот в формате, а давайте напишем, ну прототипе, да, превьюшку, вот такого вот убертула, вроде как-то и не очень много работы, но вот дальше поддерживать его в нормальном состоянии и развивать, может быть, действительно придется больше и больше и больше народу для этого набирать.
5827.70 5837.46 SPEAKER_01 Ну действительно, написать как-нибудь быстренько что-то, это не составляет обычно большого труда, а вот все это заинтегрировать, фейдрить, поддерживать, обновлять, вот там обычно начинаются трудности.
5837.46 5859.10 SPEAKER_01 Ну и смотри, я бы согласился, если там это просто была бы там какая-нибудь программка, знаешь, демка, которую они ради релиза написали, сказали, вот смотрите, как мы можем, вы наверняка тоже так можете, идите, пишите, но они слишком много сил вбахивают в этот проект, и медийных сил, и тех же самых разработчиков, и отвечают там на ищу и ходят по блогам.
5859.10 5881.82 SPEAKER_01 Уж мне кажется, слишком Microsoft в этом проекте что-то видит на перспективу, да, т.е. она может позволить себе вкладывать в него таких больших мамонтов, как и Ньютон Кинг, и Фаулер тот же самый, т.е. все-таки, наверное, какая-то конечная цель у них есть, и судя по тому, что Aspire такой размазанный абсолютно везде, они еще сами не понимают, какая из этих конечных целей выстрелит.
5881.82 5890.14 SPEAKER_01 Они, кажется, хотят везде пощупать, посмотреть, и может быть уже постфактум потом определиться, а куда это развивать, и может быть даже где зарабатывать.
5890.14 5911.78 SPEAKER_01 Ну, может быть, действительно, и так, посмотрят, куда пойдут, посмотрят, куда комьюнити пойдет, посмотрят, что комьюнити скажет на тему, допустим, т.е. может быть, комьюнити начнет писать компоненты, может быть, комьюнити начнет писать или требовать, ну, в смысле, искать какие-то конвертеры вот этого JSON-конфигурации в разные места, ну, там для Амазона кто-нибудь что-нибудь напишет, для Гугла.
5911.78 5924.82 SPEAKER_01 Да, ну вот кажется, что вот этого ажиотажа, когда все просили отдать им дашборд, вот они не ожидали, иначе бы они элементарно сделали бы там каким-нибудь отдельным отчуждаемым компонентом, который сразу после превью пришел.
5924.82 5928.86 SPEAKER_01 Может и сделают, просто сил опять же нет на все.
5928.86 5943.34 SPEAKER_01 Так что непонятно, ну, в общем, будем следить, кажется, что, по крайней мере, пока .NET Aspire довольно, ну, это чуть ли не самая хайповая тема для .NET 9, которую мы можем видеть.
5943.34 5944.34 SPEAKER_01 Наверное, да.
5944.34 5948.06 SPEAKER_01 Потому что ничего другого пока и близко не видно.
5948.06 5956.54 SPEAKER_01 В C# пока полная тишина, и я не знаю, что там планируется новенького.
5956.54 5963.26 SPEAKER_01 Я даже еще не смотрел каких-либо планов, надо, конечно, глянуть будет.
5963.26 5969.10 SPEAKER_01 Но пока не видно, не видно.
5969.10 5971.82 SPEAKER_01 Хорошо, пойдем на следующую тему, что-то мы засиделись.
5971.82 5972.82 SPEAKER_01 Давай, пойдем.
5972.82 5976.86 SPEAKER_01 Так, а у нас следующая тема, что, мы сегодня быстренькие.
5976.86 5978.86 SPEAKER_01 Следующая у нас кратко о разном.
5978.86 5981.98 SPEAKER_01 Aspire кончился, все, рассказывать не о чем.
5981.98 5985.34 SPEAKER_01 Но в кратко о разном есть немножко еще.
5985.34 5994.06 SPEAKER_01 Во-первых, у нас есть релиз пакета, который, может быть, вы когда-либо использовали, это Recycable Memory Stream.
5994.06 6008.18 SPEAKER_01 Идея в том, что если вы используете обычные мемори-стримы, то когда вы в них постоянно пишете, не зная заранее его размера, то мемори-стрим внутри переаллоцирует массив байт, постоянно его удваивая, и тем самым зажирает кучу трафика, мемори-трафика.
6008.18 6016.10 SPEAKER_01 И если у вас такой сценарий довольно частый, можно использовать этот пакетик Recycable Memory Stream, который там внутри пулит массивы, вот это все.
6016.10 6034.82 SPEAKER_01 Он давным-давно, мне кажется, не обновлялся, и тут вышла прям новая мажорная версия, которая добавила кучу всяких штук, типа добавила нулабилити везде, как надо, поддерживает он теперь нетстандарт 2.0.2.1 и дотнет 6.0 и под 6.0, у него там есть какие-то оптимизации, он там работает еще оптимальнее, еще быстрее.
6034.82 6043.74 SPEAKER_01 Ну и поскольку это прям такой мажорный релиз, добавили новую опцию, теперь можно эти буферы, которые вы туда-сюда гоняете, делать автоматически очищаемыми.
6043.74 6055.38 SPEAKER_01 В общем, если вы много работаете со стримами и страдаете от memory traffic в memory stream, и сами не придумали ничего пока альтернативного, то посмотрите на Recycable Memory Stream.
6055.38 6056.38 SPEAKER_01 Мы пользовались, в принципе нормально работает.
6056.38 6066.70 SPEAKER_01 Я был не прав, что DotNet Aspire это единственный превью, который вышел за прошедшее время.
6066.70 6077.42 SPEAKER_01 На самом деле кажется, что вышла Visual Studio 17.9 Preview 3, но обычно у нас бывает довольно, ну хотя бы маленькая статья просто про то, что вот вышел такой релиз, сейчас такой статьи нет.
6077.42 6083.14 SPEAKER_01 Есть только статья про то, что в 17.9 Preview 3, которая зарелизилась, у нас есть новый Code Search.
6083.14 6095.18 SPEAKER_01 Это все тот же самый All-in-One Search, который по Ctrl+T, да, или Command, то блин, какой Command, на маке же нет, я живу в студии.
6095.18 6096.18 SPEAKER_01 Ctrl+T.
6096.18 6102.06 SPEAKER_01 Вызывается, и раньше он искал только по мемберам, ну в смысле по файлам, классам, там, namespace и мемберам.
6102.06 6116.42 SPEAKER_01 Теперь он будет еще и искать, мэчить текст по комментам, локальным переменным и так далее, но они там как-то правильно хитро сортируют, что всякие файлики и прочее будут в начале и мемберы, а вот такие вот типа кусочки комментов будут в самом конце.
6116.42 6126.88 SPEAKER_01 В общем, ну не кажется, что там какие-то супер популярные обновления, так что прям стоило бежать на Preview 3, я бы подождал какого-нибудь следующего более большого превью.
6126.88 6132.18 SPEAKER_01 А вот еще одна статья, которую Microsoft выпустила в начале года, это про Support.
6132.18 6149.64 SPEAKER_01 Не знаю, насколько слушателям подкасты это актуально, скажем так, но вдруг кто-то действительно живет в корпоративной среде на очень старой Visual Studio, и Microsoft напоминает, что Visual Studio 2013 Support заканчивается в апреле этого года, поэтому если вы до сих пор на Visual Studio 2013, вам кажется, стоит обновиться.
6149.64 6151.74 SPEAKER_01 Это 10 лет, да?
6151.74 6153.22 SPEAKER_01 Да, это 10 лет.
6153.22 6172.66 SPEAKER_01 И вот как раз Microsoft напоминает, что у 2015 студии этот самый Support будет до октября 2025 года, у 2017 студии до 2027 года, у 2019 студии только версии 16.11 до апреля 2029 года.
6172.66 6176.62 SPEAKER_01 Ну вообще молодцы, смотри, 10 лет держат, ну прям красавцы.
6176.62 6180.54 SPEAKER_01 Да, ну в статье вообще написано, обновитесь на 22 и не парьтесь.
6180.54 6184.86 SPEAKER_01 Она там 64-битная, ну и она, понятно, будет поддерживаться дольше всего.
6184.86 6187.82 SPEAKER_01 Если можете, обновитесь.
6187.82 6188.82 SPEAKER_01 Такие дела.
6188.82 6195.50 SPEAKER_01 Да, да, смысла особо держать не было, то есть смысла особого жить на такой старой версии, наверное, особого и нет.
6195.50 6198.50 SPEAKER_01 Ну может там есть совместимости какие-нибудь там с МФЦ проектами?
6198.50 6199.50 SPEAKER_01 Ну вот даже.
6199.50 6200.50 SPEAKER_01 Или ещё с чем-нибудь.
6200.50 6203.70 SPEAKER_01 Не, подожди, МФЦ проекты, я не уверен, кстати, на 13 работают даже.
6203.70 6207.38 SPEAKER_01 Я для МФЦ каких-то там, я чуть ли не шестёрку ставил в своё время.
6207.38 6214.22 SPEAKER_01 Ну вот, видишь, значит бывают люди, у которых там специальный дистрибутив есть для того, чтобы работать с их проектами.
6214.22 6216.22 SPEAKER_01 Специальная виртуалка, я бы сказал, дистрибутив.
6216.22 6217.22 SPEAKER_01 Да, специальная виртуалка.
6217.22 6221.26 SPEAKER_01 Ты сейчас попробуй поставь там какой-нибудь Visual C++ рантайм.
6221.26 6224.90 SPEAKER_01 А, подожди, какой Visual C++ рантайм, для C++ 6 она сама ставит этот самый рантайм.
6224.90 6234.78 SPEAKER_01 Какие-нибудь там МСВЦ РТ древней 98-й версии какой-нибудь, я не знаю, были они тогда, нет?
6234.78 6236.78 SPEAKER_01 Ну в общем, короче, ладно.
6236.78 6252.06 SPEAKER_01 Я хочу вам сообщить о том, что вышла новая, релиз кандидат от SICK, SICK это логовый сервер, который разрабатывается автором сервера, автором библиотеки SiriLog Николасом Блумхарта.
6252.06 6261.86 SPEAKER_01 И вообще идеальный лог-сервер, если вы там не пишите какие-то петабайты данных, а в общем, у вас довольно всё скромненько, хорошо.
6261.86 6265.54 SPEAKER_01 И тем более, если вы разработчик, для вас это в разработческой среде доступно вообще всё бесплатно.
6265.54 6277.62 SPEAKER_01 В общем, прекрасная штука, и главная тема этого релиз кандидата в том, что был добавлен Distributed Tracing, иерархический, то ну всё как положено, всё как мы любим.
6277.62 6291.50 SPEAKER_01 Этот Distributed Tracing опирается полностью на OpenTelemetry протокол, он присутствует абсолютно везде, в поиске, в анализе запросов, в дашбордах, в алертах и в различных integration points типа плагинов.
6291.50 6305.02 SPEAKER_01 Также в формате этого трейсинга, в формате такого облегчённого OpenTelemetry протокола может писать специальный синк для серилога, который называется Serilog Tracing, который был вместе с этим выпущен.
6305.02 6317.62 SPEAKER_01 И если так взглянуть на SICK, то есть на вот этот логовый сервер, он уже становится не просто логовым, у него там есть уже и метрики, и трейсинги, и алерты, и дашборды, и поиски, и аналитика, и плагины.
6317.62 6337.54 SPEAKER_01 Ну, то есть это такая вполне самостоятельная, хорошая, интересная система с очень мощными возможностями, и вот если мы сравниваем её со Spire, который был, то она вполне способна заменить вот эту его часть про всякие телеметрии, логи, трейсинги и так далее.
6337.54 6352.02 SPEAKER_01 Конечно, она не может объединять эти проекты разные, компоненты разные в одну кучу, но в плане визуализации основных параметров справляется, естественно, намного лучше.
6352.02 6367.78 SPEAKER_01 Это как раз то, что я говорил, что если бы Spire не пытался бы покрыть всё подряд, а вот разделился бы на несколько компонентов, вот SICK вполне мог бы стать таким компонентом, который полностью отвечает за всю телеметрию, которая есть в приложении, и делает это качественно хорошо, и вообще провязанно между друг другом.
6367.78 6376.86 SPEAKER_01 Ну, посмотрим, посмотрим, кто победит в итоге, потому что может быть действительно все подтянутся и сделают альтернативу Spire в качестве дэшборда.
6376.86 6377.86 SPEAKER_01 Поглядим.
6377.86 6388.66 SPEAKER_01 Ну чё, на сегодня тогда всё, больше у нас новостей про Spire для вас нету, даже в кратко разном итоге пришлось про Spire немножко сказать.
6388.66 6391.58 SPEAKER_01 Ну, дождитесь следующего выпуска, мы подсоберём.
6391.58 6394.38 SPEAKER_01 Там будет Spire Preview 3, я уверен.
6394.38 6398.86 SPEAKER_01 Ну, хотя нет, я надеюсь всё-таки на Dota 9 хоть какое-нибудь превью.
6398.86 6401.22 SPEAKER_01 Хотя, чёрт знает, успеют, не успеют, ладно.
6401.22 6417.26 SPEAKER_01 Мы сегодня поговорили много раз про Spire и со стороны что же появилось в Preview 2, и со стороны как он устроен внутри с Close Source Developer Control Plane, и почему может быть его не стоит сейчас использовать, потому что пока непонятно во что он выльется.
6417.26 6422.34 SPEAKER_01 Начнёте использовать, а потом придётся на что-то переходить, если вы не угадаете ваши пути с Майкрософтом.
6422.34 6448.42 SPEAKER_01 Мы поговорили про то, как правильно писать или наоборот не писать важную или личную информацию в логи с помощью нового пакета, ну и вообще какие-то общие практики, которые нам кажутся разумными, ну и начали обсуждать серию статей Джимми Бонгарда про то, как мигрировать существующие .NET-приложения с фреймворка на современную LTS .NET.
6448.42 6451.90 SPEAKER_01 И на этом, наверное, на сегодня всё.
6451.90 6476.26 SPEAKER_01 Да, всех с наступившим Новым Годом, шары, репосты, колокольчики, вы там всё знаете, на Boosty тоже у нас там места ещё свободные есть, поэтому заходите, смотрите, подписывайтесь и рекомендуйте нас своим друзьям, а мы всячески будем следить за миром .NET, C# и прочим вокруг творящимся и доносить это вам в любимой произвольной и лёгкой форме для восприятия.
6476.26 6481.30 SPEAKER_01 Да, я надеюсь, что доносительно лёгкая, но мы стараемся.
6481.30 6482.46 SPEAKER_01 Всё, всем пока!

