11.24 12.24 "Анатолий Кулаков" Привет.
12.24 18.28 "Анатолий Кулаков" Мы уже добрались с вами до 35 выпуска и мы выходим не в последнюю очередь благодаря активным людям.
18.28 27.76 "Анатолий Кулаков" В частности ваши подписки, рассказы друзьям, шары, репосты, 5 звездочек, колокольчики, что там еще есть у этих хипстеров, все категорически приветствуется.
27.76 38.52 "Анатолий Кулаков" Также у нас есть сайты на Patreon и Boosty и в частности хотелось бы отдельно поблагодарить наших самых активных помогателей, это Александр, Сергей и Владислав.
38.52 39.84 "Анатолий Кулаков" Спасибо большое друзья.
39.84 42.04 "Анатолий Кулаков" Ну а теперь перейдем непосредственно к новостям.
42.04 45.64 "Анатолий Кулаков" Так, Игорь, что там у нас от Майкрософта есть, чем позабавиться?
45.64 51.20 "Игорь Лабутин" Ну, Майкрософт нас пока не очень радует новыми там релиз-кандидатами или превьюшками.
51.20 55.32 "Игорь Лабутин" Мы все ждем с нетерпением релиз-кандидат 1, посмотрим что там будет.
55.32 64.84 "Игорь Лабутин" А пока тем не менее, все равно есть что обсудить, потому что вышло несколько статей, в том числе от Майкрософта, в которые мы сегодня и погрузимся.
64.84 72.04 "Игорь Лабутин" И начнем мы с огромнейшей статьи Стивена Тауба про Performance Improvements в 6.NET.
72.04 96.40 "Игорь Лабутин" Глядя на эту статью, на самом деле очень радует, что мы к подкасту готовимся и читаем это заранее, потому что у меня ушло примерно 3 вечера, чтобы аккуратненько все прочитать и вытащить из статьи хоть что-нибудь полезное, что можно рассказать, потому что статья это полный сборник всего, что происходило с .NET 6 с точки зрения Performance.
96.40 102.16 "Игорь Лабутин" То есть это перечисление практически всех pull-requests, там их, по-моему, больше 480 штук упомянуто.
102.16 107.04 "Анатолий Кулаков" Не просто перечисление, а как бы расписание вместе с битчмарками, с примерами, с описаниями.
107.04 109.20 "Анатолий Кулаков" То есть такая гигантская работа проделана.
109.20 115.28 "Анатолий Кулаков" Я на эту статью вообще не понимаю, где Стивен Тауб берет на всю свою активность столько времени и сил.
115.28 128.24 "Игорь Лабутин" Ну да, если мы считаем, что написать статью, раз там не знаю, в 5-10 сложнее, чем прочитать ее, то я потратил 3 вечера на аккуратное чтение, а он, стало быть, потратил, ну не знаю, месяц на ее написание.
128.24 129.24 "Игорь Лабутин" Фиг знает.
129.24 134.68 "Анатолий Кулаков" И такие статьи хорошенькие, подготовленные, монументальные, у него выходят довольно-таки регулярно.
134.68 135.80 "Игорь Лабутин" Ну каждый релиз.
135.80 140.04 "Игорь Лабутин" То есть оно началось все, он, кстати, с этого статьи начинается.
140.04 149.68 "Игорь Лабутин" Первую такую статью он сделал для, по-моему, 2-1, что ли, Дотнеткора, когда там было действительно большое количество клевых улучшений.
149.68 161.44 "Игорь Лабутин" Потом от него попросили такую же для следующего релиза, ну и как-то это стало традицией, теперь он перед каждым релизом Дотнета пишет такую большую статью про то, по сути, что произошло в Дотнете за год с точки зрения перформанса.
161.44 166.36 "Анатолий Кулаков" Ну я даже имею в виду не только перформанс, я имею в виду вообще его активность в блоге Дотнета.
166.36 168.52 "Анатолий Кулаков" Он же пишет много про что?
168.52 170.56 "Игорь Лабутин" Ну достаточно много, да.
170.56 171.56 "Анатолий Кулаков" Да.
171.56 176.12 "Анатолий Кулаков" В общем, Стиффентал молодец, давайте заценим его труды, что же он теперь такого там нарисовал.
176.12 195.20 "Игорь Лабутин" Ну он действительно просто аккуратно собрал все улучшения, все полуреквесты, которые были, и с атрибуцией к авторам аккуратненько все пробенчмаркал, и мало того, описал действительно достаточно понятными словами, где что происходило и зачем, или почему это было сделано.
195.20 221.76 "Игорь Лабутин" Это все поделено на такие логические куски по каким-то областям, мы пробежимся по ним по всем, но я не буду вдаваться в подробности вообще во всех, потому что, ну во-первых, мы по многому это все обсуждали, так или иначе, во-вторых, если буду вдаваться во все, то мы еще 2 часа будем только эту статью обсуждать и все уснут, потому что слушать бенчмарки это наверное не очень здорово.
221.76 223.08 "Игорь Лабутин" Пойдем по порядку.
223.08 270.60 "Игорь Лабутин" Начинается все с джета, в джете на самом деле огромное количество улучшений, чуть ли не больше, чем во всех остальных областях, но с джетом проблема в том, что конечно там каждое улучшение это какой-то очень-очень-очень мизерный кейс, в каких-то конкретных случаях чуть-чуть более оптимально генерится код, поэтому рассказывать про какие-то конкретные оптимизации здесь я не буду, но по общему впечатлению джет как бы резко улучшился сейчас в шестом дотнете и продолжит улучшаться дальше, так что если вы следите за джетом, если вам интересно, то во-первых, почитайте статью, во-вторых, можно будет послушать, кстати, Егора по идее богатого на дотнете, он будет про это тоже рассказывать.
270.60 284.32 "Игорь Лабутин" Дальше garbage collector, с garbage collector на самом деле в шестом дотнете все довольно-таки просто, там не так много каких-то существенных улучшений, кроме одного большого, это переход с сегментов на регионы.
284.32 323.60 "Игорь Лабутин" Напомню, что сегменты это такие большие куски памяти, там по сотне мегабайт, внутри которых garbage collector как-то умудрялся размещать свои поколения, при том, что нулевое и первое всегда было в одном-единством сегменте, а теперь garbage collector перевели регионами, это кусочки памяти, если я правильно помню, по 4 мегабайта, и соответственно там появляется гораздо больше гибкости с точки зрения, как их там переиспользовать, аллокейтить, диалокейтить и так далее, мы про это подробно говорили, в начале на самом деле это было одно из первых улучшений в одном из первых превьюшек, и поэтому в общем вот оно до сих пор живет, все нормально работает, так что у Маони все получилось, все работает, будем пользоваться.
323.60 367.56 "Игорь Лабутин" Трейдинг, многопоточность, недавно совсем мы обсуждали про улучшение в тредпуле, то есть теперь если тредпул определяет, что у нас есть поток в тредпуле, который ждет на окончание работы таска, то есть синхронно ждет окончание какой-то асинхронной работы, то такой поток будет, ну скажем так, такие потоки не будут читываться, если очень грубо говорить, в алгоритме подсчета потоков и понимания сколько потоков надо, и тредпул будет гораздо более агрессивно увеличивать количество потоков в этом случае, так что для сценариев, когда вы синхронно ждете на асинхронных тасках, скорее всего тредпул будет вести себя чуть лучше.
367.56 387.44 "Игорь Лабутин" Продолжается эпопея с кэшированием, теперь у нас, если вы используете task from result для каких-то примитивов типа true, false и всех int от -1 до 8, то такие таски у вас закэшированы, и будет всегда возвращаться одна и та же таска, ну сразу естественно в комплитном состоянии и все дела.
387.44 394.76 "Игорь Лабутин" Так что теперь можно смело писать task from result true или task from result 5, и это будет оптимально кэшироваться, там ничего локетиться не будет.
394.76 435.00 "Игорь Лабутин" Дальше на методах теперь можно задавать атрибут async метод builder, и тогда там будет использоваться, когда компилятор будет разворачивать собственно async await конструкцию вокруг этого метода, ожидание вызова такого метода, он будет использовать специальный тип вместо стандартного билдера, который внутри используется обычно, и это позволяет сделать прямо очень хитрой оптимизацию вокруг кэширующих value task, всяких task completion source и вот этого всего, читайте статью там прямо все очень подробно написано, и что делать, и на самом деле была по-моему отдельная статья, мы ее по-моему даже обсуждали, но вот кстати не уверен.
435.00 494.88 "Игорь Лабутин" Parallel forage async появился, который аккуратно собственно с async'ами работает, ну и cancellation token, там на самом деле очень интересная история, когда cancellation token только дизайнился давным-давно, то считалось, что основной сценарий работы с cancellation token это то, что мы создаем их мало и при этом ждет этого cancellation token очень много потоков, то есть очень много потоков будут регистрировать хендлеры, которые нужно будет вызвать, когда cancellation token сработал, по факту в современном дотнете, в условии того, как это все обычно работает, очень мало потоков делают регистр на cancellation token, и поэтому очень хитрый и очень клевый алгоритм того, как там конкурентом подписываться и отписываться был переписан довольно простой и топорный, но который хорошо работает вот в тех сценариях, которые мы сейчас в основном используем cancellation token, и сразу стало все быстро, хорошо и меньше аллокейтов, как ни странно.
494.88 513.50 "Игорь Лабутин" И кроме того cancellation token, точнее cancellation token sources можно теперь переюзывать, на них можно пытаться вызвать try reset, и в таком случае, если он не срабатывал, то try reset вернет true, и можно cancellation token передавать дальше в новые какие-то операции, а если вернул false, ну сорян, значит уже нельзя.
513.50 520.18 "Игорь Лабутин" Cancellation token не может вернуться из состояния сработал, состояние не сработал, так нельзя.
520.18 530.34 "Игорь Лабутин" Довольно много улучшений добавили в системные типы, в основном тоже все про всякие faster, лучше, короче, меньше аллокейтов и вот это все.
530.34 537.62 "Игорь Лабутин" Быстрее партятся гуиды, быстрее форматится в toString system version, и интересные импровменты вокруг рендома.
537.62 558.86 "Игорь Лабутин" У рендома сделали более качественную реализацию, которая, как написано, раньше использовали какую-то классическую реализацию, чуть ли не из книжки кнута, вот, а сейчас сделали новую клевую реализацию, которая там гораздо более рандомная и вот это все, но у нее есть один фатальный недостаток.
558.86 564.58 "Игорь Лабутин" Она нарушает обратную совместимость со старой версией, если вы передаете в рандом какой-то seed.
564.58 570.78 "Игорь Лабутин" Ну то есть можно просто выдать конструктор в рандом без аргументов, а можно туда передать стандартный seed.
570.78 590.94 "Игорь Лабутин" И поведение теперь такое, что если туда передается какой-то seed в конструктор рандома, то используется старое поведение, которое более медленное, более прожорливое по памяти, но зато оно точно такое же, как было и скорее всего это значит, что ваши, например, unit-тесты где-то часто используются, где передается фиксированный seed, чтобы последовательность была всегда одной и той же, ломаться не будут.
590.94 596.86 "Игорь Лабутин" А если вы туда ничего не передаете, то все будет хорошо и значит будет работать новая реализация.
596.86 618.78 "Игорь Лабутин" Так что не надо туда ничего не передавать, а еще лучше можно, если у вас рандом используется не очень часто и из небольшого числа потоков, можно вообще теперь использовать статический instance, который называется random.shared, который гарантированно, потокобезопасно будет вам возвращать рандомные чечилки или последовательность байта, что вы хотите.
618.78 633.34 "Игорь Лабутин" Ускорили date/time/utc/now, мы про это рассказывали, чтобы не проверять високосную секунду на каждый вызов, добавили всякие environment.processid, environment.processpath, чтобы избежать дорогого вызова конструктора процесс.
633.34 635.82 "Игорь Лабутин" В общем мелкие улучшения везде и всегда.
635.82 658.22 "Игорь Лабутин" Такая же штука с array-ми, string-ами и span-ами, они все дальше проникают в app, все больше викторизуют, добавили новый интерпол и идет string-и, мы про это подробно рассказывали, так что если вы работаете с array-ми, string-ами, то еще больше и больше вам будут доступны аппишки со span-ами, которые позволяют делать быстрые без локейтов.
658.22 676.78 "Игорь Лабутин" ArrayPool тоже претерпел небольшие изменения, там есть изменения во внутренней логике работы, кроме того теперь он, когда вы просите от него массив длиной больше чем 1 миллион элементов, ну точнее 1024 на 1024, то он теперь превозвратит такого массива, его тоже себе запомнит и закеширует.
676.78 682.14 "Игорь Лабутин" Плюс у него есть логика, как долго хранить такие массивы большие и когда их освобождать.
682.14 697.42 "Игорь Лабутин" Так что там прям они пытаются, поскольку опять же arraypool.shared, они используют много где-то, в том числе внутри базовой библиотеки для активного пулинга, то он претерпевает довольно-таки качественные изменения с точки зрения перформанса.
697.42 703.58 "Анатолий Кулаков" Кажется, что они там просто свой ГС строят с поколениями, значит с переиспользованиями, с кешированиями.
703.58 746.98 "Игорь Лабутин" Да, я вот сейчас не помню, но по-моему сейчас, секунду, да это как раз таки в Raypool, то есть там хитро, в Raypool это не просто там, не знаю, связанный список, точнее там коллекция, да, словарик связанных списков по размеру массива, там все хитрее, то есть там есть кэш-тред локальный, то есть в thread local storage лежит инстанс последнего как бы ввернутого array в этом threadpool, в этом thread, потом есть кэш на процессор, на каждый, и потом уже общий большой, то есть он трехуровневый кэш, и дальше есть специальная логика, которая понимает на каком уровне сколько массивов нужно держать в зависимости от частоты использования и так далее.
746.98 749.54 "Игорь Лабутин" И так, чтобы при этом память не сильно много кушалась.
749.54 754.62 "Игорь Лабутин" Короче, там прям какая-то мега логика, можно почитать исходнички и посмотреть, как это все работает.
754.62 761.26 "Анатолий Кулаков" Я уже жду отдельных там статей, лекций, видосиков о том, как сделать правильный Raypool.
761.26 762.26 "Анатолий Кулаков" На примере нашего.
762.26 766.02 "Игорь Лабутин" Ну, может быть, кстати, да, будет интересно посмотреть внутреннее устройство.
766.02 769.30 "Игорь Лабутин" Вот вывод I/O.
769.30 773.78 "Игорь Лабутин" Про файл стрим у нас есть отдельная статья, мы немножко попозже про это поговорим.
773.78 796.38 "Игорь Лабутин" И довольно много улучшений вокруг компрессии, то есть они взяли новую библиотечку для поддержки Brotli, такой компрессор, который в браузерах в том числе используется наравне с Zlib, и пофиксили довольно серьезный deflate с ним, это Zlib по сути, в котором была одна довольно таки неприятная не то что бага, а особенность.
796.38 806.26 "Игорь Лабутин" Как мы знаем, обычно, когда вы вызываете read на стриме и передаете туда какой-нибудь там массив байтиков, то вам никто не гарантирует, что весь этот массивчик будет заполнен.
806.26 811.74 "Игорь Лабутин" Он там, ну, сколько байтов сможет получить, столько он туда запишет и вам вернет число собственно записанных байтов.
811.74 818.90 "Игорь Лабутин" Ну, а вы дальше как бы сами думаете, снова вызывать, таки получить еще недостающие байты или поработать с теми, что получили.
818.90 826.94 "Игорь Лабутин" Так вот, у deflate stream был довольно таки серьезный недостаток, он всегда гарантированно старался заполнить весь буфер, который вы передали.
826.94 837.10 "Игорь Лабутин" Поэтому если вы передали буфер на там 1000 байт, вам пришло сообщение в 30 байт, то пока не придут остальные 970, то вы это сообщение не увидите, потому что read не возвращался.
837.10 844.54 "Игорь Лабутин" Вот, сейчас это поменяно, сейчас теперь он ведется как нормальный стрим, сейчас он вернет вам 30 из 1000 и дальше делаете с этим, что хотите.
844.54 845.54 "Игорь Лабутин" Нетворкинг.
845.54 868.74 "Игорь Лабутин" С нетворкингом довольно таки тоже много изменений, там довольно сильно перефигачили сокетную библиотеку, в смысле что раньше она была довольно активно использовала старый паттерн про begin and, там begin sent и end sent, и предоставляла еще task-based методы, которые были просто врапперами вокруг этих begin and.
868.74 886.74 "Игорь Лабутин" Сейчас все поменялось, теперь наоборот, task-based методы это теперь основные методы, в них собственно содержится вся логика, а begin and, а пишка старая, которая там, .NET какая получается, 2.0 совместимая, да, наверное около того, это теперь просто врапперы вокруг тасков.
886.74 899.90 "Игорь Лабутин" Улучшился DNS клиентик, он там теперь нативно осинки поддерживает, ну и куча улучшений в HTTP клиенте и в сокете с HTTP хендлером, в основном какие-то очень тонкие моменты поддержки того, как все это работает, посмотрите если вы используете.
899.90 902.42 "Игорь Лабутин" Интересно, кто сейчас этого не использует.
902.42 923.70 "Игорь Лабутин" Reflection, performance, performance, еще раз, performance, там поумнее стала инициализация всяких объектов, если вы не обращаетесь к каким-то кусочкам объекта, точнее метаданных, то оно там не инициализируется теперь, ну и там где инициализируется, это делается все с учетом спанов, там на спанах и вот этом всем, так что стало быстрее.
923.70 947.06 "Игорь Лабутин" Про коллекции сильно много говорить не приходится, мы обсуждали статью, что теперь можно в особых случаях обращаться к элементам словариков прямо через Ref ссылку, то есть для value типов это очень важно, у вас не будет двух копирований при чтении и при записи обратно, ну и опять же куча улучшений в LinkU, новые оптимизации, новые методы и так далее.
947.06 975.18 "Игорь Лабутин" Куча улучшений в криптографии, про performance в основном и про упрощение API, если раньше, например, вам чтобы закриптовать какой-нибудь там, не знаю, byte array в памяти, нужно было по-моему 2 или 3 стрима создать, чисто для конвертации штук друг в друга, передать кучу непонятных аргументов, теперь есть нормальные обычные статические хелперы, которые позволят вам сказать там, encrypt что-нибудь, передать ключик и все за encryption, вам в ответ вернут за encryption и байтики.
975.18 993.62 "Игорь Лабутин" Довольно-таки интересное изменение, команда .NET сказала, что теперь internal и private классы, там какой-то огромнейший PR на 2000 с лишним файлов, чтобы сделать их sealed, то есть закрытыми для наследования.
993.62 1019.34 "Игорь Лабутин" Я сначала подумал, что они это и для public, ну паблик сделали, но нет, то есть паблик классы, если они были не sealed, они так и остались не sealed, все ваши наследования никуда не сломаются, а internal и private, они теперь sealed, и это сделано опять же ради оптимизации JIT, JIT для sealed классов умеет чуть более оптимальный код писать, иногда даже убирать виртуальные вызовы и заменять их на обычный, соответственно это будет все быстрее и лучше.
1019.34 1073.90 "Анатолий Кулаков" У меня остался какой-то комплекс, наверное еще с плюсов, когда на плюсах программировал, но в принципе всю мою жизнь программирования в C#, я тоже все классы по дефолту делаю internal и sealed, и только если нужно, знаю, что можно как-то кому-то пронаследоваться в будущем, или мне, или потенциально кому-то еще, только тогда убираю sealed, или только тогда делаю их в паблике, но по умолчанию у меня все snippets, все анализаторы настроены на internal sealed классы, именно по этой причине, что это очень сильно ускоряет, и кстати не только JIT, но и компиляцию, но и анализ даже в студии, потому что студия если видит у вас private или internal класс, она дальше этой сборки наследников искать не будет, а если она у него видит вообще sealed класс, то вообще наследников искать не будет, то есть это очень часто ускоряет вообще весь ваш инвайромент, начиная от процесса написания кода, и не говоря уже о рантайме там тем более.
1073.90 1078.02 "Игорь Лабутин" Про студию я кстати не думал действительно, но и райдер тот же по идее тоже должен ускоряться.
1078.02 1094.98 "Анатолий Кулаков" Про студию ты наверное не думал, потому что ты не пользовался очень долго ReSharper, а так как я ReSharper пользовался там с первых версий, вот меня это очень сильно заставило задуматься, ну потому что анализаторы тоже самые, только попражерливее, и вот ReSharper очень сильно помогала такая структура каталогов, такая структура классов.
1094.98 1105.42 "Игорь Лабутин" Интересно, я почти не пользуюсь internal и private, то есть internal бывает, private вообще практически никогда, а sealed я не помню когда я последний раз писал слово sealed в C#.
1105.42 1108.70 "Игорь Лабутин" Но интересно, надо будет подумать, может быть действительно в этом что-то есть.
1108.70 1128.54 "Игорь Лабутин" Куча спан API завезли, там где не хватало, уменьшают боксинг по возможности внутри библиотеки, ну то есть в общем по мелочи, на самом деле это раздел был по принципу, все что не смогли отнести к какому-то другому разделу, запихнули в этот раздел.
1128.54 1134.18 "Игорь Лабутин" Смотрите, там много на самом деле довольно интересных pull requests, просто про всех говорить нет возможности вообще никакой.
1134.18 1145.18 "Игорь Лабутин" JSON, там основные изменения это конечно вокруг source генераторов, мы об этом подробно обсуждали, такой вообще подкаст получается типа это.
1145.18 1151.14 "Игорь Лабутин" Сборная солянка в силу того, что мы обсуждали за предыдущие 7 превьюшек, но тут ничего не поделаешь.
1151.14 1156.82 "Игорь Лабутин" Interop, мне даже сложно сказать, что там изменилось, но это такая интероп.
1156.82 1166.06 "Игорь Лабутин" В стартапе поменялись на самом деле некоторые вещи, в смысле что теперь есть там некоторые build time оптимизации, которые позволяют чуть побыстрее собирать проект.
1166.06 1184.06 "Игорь Лабутин" В трейсинге мелкие довольно оптимизации в библиотеке, которые генерят всякие event tracing, вот если вы используете библиотечку trace event или event listener, то теперь там чуть более простая API и она побыстрее работает.
1184.06 1194.90 "Игорь Лабутин" Ну и в рамках работы над Blazor, WebAssembly и так далее, там уменьшается размер, тримминг проверяют новый, ну и всякие такие штуки.
1194.90 1222.14 "Игорь Лабутин" А, и за счет того, что кстати Silt помог еще вот чем, Silt помог выпилить виртуальные вызовы и плюс он помог сделать местами более оптимальный трим, то есть когда runtime понимает, что в этом месте вызывается Silt класс и это значит, что никакой из наследников не может не вызываться, то он там чуть оптимальнее может провести анализ и понять, что какая-то сборка вообще не нужна.
1222.14 1226.82 "Анатолий Кулаков" Да-да, задумайтесь об этом, все ваши классы должны по умолчанию быть Silt, Internal.
1226.82 1243.26 "Игорь Лабутин" Окей, ну и в принципе все, на этом статья заканчивается, мы где-то минут за 10 наверное, да, ее пробежались, не знаю, ну примерно, будем считать, что за 10, но да, там в Doom чего чтение, ну часа на 2-3.
1243.26 1248.50 "Игорь Лабутин" Особенно если будете заходить в pull-requests и читать, что там происходит, легко может на неделю растянуться.
1248.50 1262.42 "Анатолий Кулаков" Да, тем более в pull-requests там обычно такие интересные драмы разыгрывают, разные use-cases приходят, разные люди приходят со всеми очевидными какими-то примерами, в общем наблюдать за гитхабом Microsoft, по-моему, это одно удовольствие.
1262.42 1274.38 "Анатолий Кулаков" Продолжаем препарировать блок Microsoft и вышла у него интересная тоже статейчика, которая называется «Как правильно понять стоимость C# делегатов?».
1274.38 1291.94 "Анатолий Кулаков" Казалось бы, такая примитивная вещь, наверное, многие даже современные разработчики и не знают, что такое делегаты, ну потому что это нужно было знать во времена первых дотнетов, когда это понятие только вводилось, а сейчас там практически все сделано неявно, под капотом и неизвестно.
1291.94 1304.02 "Анатолий Кулаков" Но в принципе, если вот посмотреть на эту статейчику, то здесь автор свел воедино очень много способов, с которыми можно этот делегат неявно создать, неявно получить.
1304.02 1309.86 "Анатолий Кулаков" И интересно, что мы пришли вокруг такой примитивной базовой концепции к такой сложности и нагромождению.
1309.86 1311.26 "Анатолий Кулаков" Давайте же по порядку разберемся.
1311.26 1315.70 "Анатолий Кулаков" На самом деле делегаты распространены в C# и в дотнете очень много.
1315.70 1323.22 "Анатолий Кулаков" Даже если вы явно не знаете, что они у вас есть, по правде, на самом деле в рантайме, во время копиляции они у вас появляются, они у вас есть.
1323.22 1331.38 "Анатолий Кулаков" Они используются во всяких event-handlers, callbacks, какой-нибудь логики, которую вы передаете в ринг операторы и во многих других местах.
1331.38 1336.22 "Анатолий Кулаков" Появились они еще с первых версий C#, с первых версий дотнета.
1336.22 1339.98 "Анатолий Кулаков" И в начале их можно было создать только явно.
1339.98 1343.94 "Анатолий Кулаков" То есть вы должны были объявить тип с ключевым словом делегат.
1343.94 1349.42 "Анатолий Кулаков" То есть этот тип описывал некую сигнатуру функции, которая принимала параметры, возвращала какой-то результат.
1349.42 1354.10 "Анатолий Кулаков" И единственное, чем отличалось от сигнатуры, тем, что у нее не было боди и она имела ключевое слово делегат.
1354.10 1358.14 "Анатолий Кулаков" То есть это практически такой интерфейс для одной функции.
1358.14 1361.38 "Анатолий Кулаков" Здесь функциональщики должны зааплодировать просто стоя.
1361.38 1362.38 "Анатолий Кулаков" Вот.
1362.38 1374.86 "Анатолий Кулаков" И единственный способ создать раньше делегат в первых версиях было только вызвать явно new и передать уже непосредственно какой-нибудь instance делегата, который делал бы какую-то полезную нагрузку.
1374.86 1377.74 "Игорь Лабутин" Там даже ключевое слово было делегат.
1377.74 1388.74 "Игорь Лабутин" Я помню мой первый experience на C#, это было уже во втором C#, но да, я помню, как меня бесило, что надо было писать это длинное ключевое слово делегат.
1388.74 1390.86 "Анатолий Кулаков" Тебя интеллисенсы тогда не завезли что ли?
1390.86 1396.26 "Игорь Лабутин" Ну что-то как-то вот, у меня вот это воспоминание из старого дотнет осталось ровно вот это почему-то.
1396.26 1399.22 "Игорь Лабутин" Про ключевое слово делегат, я его очень не любил.
1399.22 1406.10 "Анатолий Кулаков" Ну в принципе да, вот ключевое слово делегат это в принципе одно и то же, что ключевое слово интерфейс, но только для одной функции.
1406.10 1422.42 "Анатолий Кулаков" Со вторых версий C# у нас уже появились такие неявные преобразования, которые позволили нам не объявлять никаких ключевых слов делегат, не создавать явно какие-то отдельные классы, а делать это все под капотом неявно.
1422.42 1429.06 "Анатолий Кулаков" Например, так неявно кастовались к делегату, даже создавался новый делегат с помощью метод групп.
1429.06 1447.62 "Анатолий Кулаков" Если у вас есть какая-то функция, которая по сигнатуре совпадает с тем делегатом, который требует другая функция, то создался метод групп, неявно создавался делегат и все это прокидывалось как указатель на функцию туда, где она потом в последствии вызывалась.
1447.62 1454.94 "Анатолий Кулаков" У этой красивой магии существует одно неочевидное под капотное зло.
1454.94 1462.46 "Анатолий Кулаков" Заключается оно в том, что как только вы используете месседж групп, на каждый вызов такой функции создается новый делегат.
1462.46 1474.82 "Анатолий Кулаков" И например, это не так страшно, если у вас это какой-то повседневный код, но как только вы такое создание нового делегата попадает у вас в цикл, там уже становится немножко больнее.
1474.82 1483.02 "Анатолий Кулаков" Потому что в цикле неявно создаются постоянные делегаты, это приводит к тому, что выделяется много ненужной памяти, которую нужно потом кому-то чистить.
1483.02 1485.82 "Анатолий Кулаков" И от этого могут быть всякие у вас перформансы.
1485.82 1506.98 "Анатолий Кулаков" Сейчас современные анализаторы, в частности ReSharper подчеркивает такие места, может показать вам, что там есть неявное создание делегата, но с другой стороны у ReSharper по умолчанию включена рекомендация, вместо явных использования анонимных функций всегда используйте месседж групп, что соответственно начинает приводить к выделению памяти.
1506.98 1511.70 "Анатолий Кулаков" Третий вид, как вы можете получить делегат, это анонимные функции.
1511.70 1514.10 "Анатолий Кулаков" Тоже появились во второй версии, очень удобная штука.
1514.10 1524.60 "Анатолий Кулаков" То есть это такой неименованный блок с кодом, с функцией, которую вы можете задекларировать и использовать прямо в своем коде.
1524.60 1529.58 "Анатолий Кулаков" Например в Lambda Expression, это очень часто используется.
1529.58 1535.74 "Анатолий Кулаков" Соответственно компилятор может посмотреть на эту анонимную функцию и для себя их разделить на два типа.
1535.74 1542.30 "Анатолий Кулаков" Во-первых, это функция, которая не использует никаких внешних переменных, использует никаких внешних референсов.
1542.30 1548.54 "Анатолий Кулаков" То есть она принимает какие-то аргументы и делает действие непосредственно над этими аргументами и ни над чем более.
1548.54 1561.30 "Анатолий Кулаков" Такие ситуации он способен распознать, если нет никаких внешних зависимостей, то он создает делегат, то есть генерирует код, который создает делегат всего лишь навсего только один раз.
1561.30 1568.86 "Анатолий Кулаков" Это помогает нам избежать той проблемы, которую мы обсуждали в метод-группах, например.
1568.86 1572.54 "Анатолий Кулаков" Это более умное поведение компилятору, за что ему честь и хвала.
1572.54 1578.90 "Анатолий Кулаков" Вторая же ситуация, когда у вас в этой анонимной функции все-таки есть какие-то внешние зависимости.
1578.90 1588.46 "Анатолий Кулаков" То есть используются не только те аргументы, которые вам передали, но и какая-то переменная из локального контекста или какой-нибудь классик, который недалеко валялся.
1588.46 1592.06 "Анатолий Кулаков" В этом случае создается отдельный класс, он называется Clojure.
1592.06 1601.90 "Анатолий Кулаков" И этот класс захватывает эту переменную, которая там где-то в контексте у вас валялась, и плюс уже создает непосредственно сам делегат.
1601.90 1619.26 "Анатолий Кулаков" Здесь мы снова попадаем в ту ловушку, что Clojure могут создаваться в непредсказуемое число раз, и плюс еще одна ловушка у нас здесь появляется в том, что компилятор пытается оптимизировать те моменты, когда вы захватываете несколько переменных.
1619.26 1631.62 "Анатолий Кулаков" И если вы захватываете несколько переменных в рамках какого-то одного контекста, даже если они используются в разных анонимных функциях, компилятор создается всего-навсего один Clojure.
1631.62 1634.54 "Анатолий Кулаков" И все эти переменные захватятся в один Clojure.
1634.54 1647.10 "Анатолий Кулаков" То есть если вы рассчитываете, что какая-то переменная освободилась после какого-то участка кода, потому что она больше никаким анонимным функциям не нужна, и Garbage Collector ее успешно собрал, это может быть не так.
1647.10 1660.50 "Анатолий Кулаков" Если рядом есть какие-то другие анонимные функции, которые используют абсолютно другие переменные, никак не связанные с этой, но те другие переменные живут дольше, по оптимизации компилятора создастся всего-навсего один Clojure, который захватит их всех.
1660.50 1667.22 "Анатолий Кулаков" И жить они будут ровно столько, сколько живет самая долгая анонимная функция.
1667.22 1674.74 "Анатолий Кулаков" Тоже такой неочевидный момент, который может вам показать какие-нибудь интересные цифры в вашем профилере, поэтому будьте осторожны.
1674.74 1689.10 "Игорь Лабутин" Смотри, хочу немножко уточнить, во-первых, когда мы говорим анонимные функции, все, конечно же, представляют вот эту конструкцию, скобочка, стрелочка, и там какое-то тело функции, но вот это были лямбда, и они появились на самом деле не во втором, а в третьем C#.
1689.10 1694.78 "Игорь Лабутин" Во втором были эти вот анонимные функции, но там нужно было писать это слово делегат.
1694.78 1701.30 "Игорь Лабутин" Мало их кто воспринимал как функции, потому что это же делегат, но на самом деле это были как раз анонимные функции.
1701.30 1704.58 "Игорь Лабутин" А с Clojure есть еще одна такая забавная штука.
1704.58 1719.54 "Игорь Лабутин" Предположим, у вас есть, например, метод, который умеет складывать два числа, а и б, и вы пишете лямбду, которая принимает два аргумента а и б, и вызывает метод этот самый add, передавая туда два аргумента а и б.
1719.54 1728.78 "Игорь Лабутин" Казалось бы, захвата никакого нет, потому что аргументы, собственно, а и б берутся из аргументов лямбды и передаются в метод.
1728.78 1749.82 "Игорь Лабутин" И некоторые думают, что в этом случае не будет создано никакой Clojure, но на самом деле будет, если метод add является instance методом, потому что надо помнить, что для instance методов у нас всегда есть неявный this, указатель, который нужно использовать для вызова, и таким образом вы в Clojure кладете вообще весь ваш класс, указатель на него.
1749.82 1755.26 "Игорь Лабутин" И пока, соответственно, ваша лямбда используется, весь ваш класс не будет собран garbage-коллектором.
1755.26 1762.78 "Анатолий Кулаков" Да, это отличное замечание, что замыкание на this — это очень частая причина всяких memory leaks.
1762.78 1781.98 "Анатолий Кулаков" А еще интересно, что метод группы, про который я говорил ранее, они, в принципе, всегда порождают создание нового делегата, несмотря на то, что компилятор в случае, если у вас нет внешних зависимостей, умеет определять такие ситуации и создавать делегат только один раз.
1781.98 1798.54 "Анатолий Кулаков" Вот даже если у вас message group сделан на статическую функцию, то есть которая не имеет никаких зависимостей, у которой все статически, которое подтвердило ключевым словом, все равно в этом случае компилятор не создает делегат только один раз, а создает его на каждый вызов.
1798.54 1802.62 "Анатолий Кулаков" Вот это тоже, в принципе, непонятная для меня осталась штука, почему он так делает.
1802.62 1816.54 "Анатолий Кулаков" На это есть ish.io, которая заведена еще в 2015 году, там к ней приоточена куча pull-requests, куча комментариев, и она все еще почему-то не закрыта с ссылкой на то, что это поломает какую-то обратную совместимость.
1816.54 1819.26 "Анатолий Кулаков" Я так и не разобрался, какую обратную совместимость это может поломать.
1819.26 1821.66 "Анатолий Кулаков" Ты, случайно, не сталкивался, не знаешь?
1821.66 1823.38 "Игорь Лабутин" Нет, вот этого не знаю.
1823.38 1837.10 "Игорь Лабутин" То есть я понимаю, что оно действительно может поломать что-то в поведении обратной совместимости, на самом деле, скорее всего, какую-нибудь штуку, связанную с подписками и отписками каких-нибудь ивентов.
1837.10 1841.58 "Игорь Лабутин" Мы же очень часто используем метод группы или лямбда для обработки ивентов.
1841.58 1845.74 "Игорь Лабутин" Может быть там важно, что это обязательно разные инстансы должны быть, а не один.
1845.74 1857.14 "Анатолий Кулаков" Ну вот на практике, не знаю, никогда никто не проверял делегаты, которые он получил на референс иквелс или что-то в этом духе, и вроде примеров таких, наверное, никто не привел.
1857.14 1859.54 "Игорь Лабутин" Ну, может, в спеке написано, что должно быть разное.
1859.54 1861.74 "Игорь Лабутин" Ну, а раз спека говорит, значит, должно быть.
1861.74 1867.54 "Анатолий Кулаков" Нет, ну, ищи на гитхабе есть, она активная, по ней работают, то есть вроде спека по этому плану ничего нам не говорит.
1867.54 1872.38 "Игорь Лабутин" Ну, спеку тоже можно поменять в рамках ищи, что такого.
1872.38 1888.86 "Анатолий Кулаков" Хорошо, в 9 сериале у нас появились еще статические анонимные функции, то есть кроме того, что вы передаете туда лямбду, вашу непосредственную функцию, вы можете указать ключевое слово "static", и это тоже подскажет компилятору в том, что эта лямбда не содержит никаких внешних зависимостей.
1888.86 1898.74 "Игорь Лабутин" Она не только подскажет компилятору, а компилятор это прям явно проверит, если вы там пытаетесь что-то, то есть если там есть захват чего-нибудь, то это будет ошибка компиляции.
1898.74 1910.66 "Анатолий Кулаков" Ну, ожидаемо, наверное, как и в любой статической функции, если она обращается к каким-то локальным переменам, компилятор ее не скомпилирует, потому что статическая функция не должна ни от чего зависеть, кроме как от других статических функций.
1910.66 1941.22 "Анатолий Кулаков" Вот, это такой интересный списочек, ничем новым не отличается, никакие большие здесь открытий нет, просто автор хорошо свел воедино, описал какие-то проблемы, и хотел подчеркнуть, что если у вас вдруг вы не обращаете внимания на такие неявные выделения памяти, то это легко может вылиться у вас в какие-нибудь чрезмерные загрузки CPU, а происходит это потому, что у вас выделяется очень много мелких объектов, вот этих делегатиков, особенно в циклах, особенно на каких-то там ивентах, особенно на каких-то там стримах.
1941.22 1957.54 "Анатолий Кулаков" Большое выделение памяти приводит к тому, что вам нужно эту память как-то собирать, этим занимается естественно Garbage Collector, Garbage Collector запускается очень часто, собирает очень много, в это время загружается CPU, поэтому у вас и память жрется, и CPU загружается, и Garbage Collector вынуждена работать очень-очень много.
1957.54 1959.06 "Анатолий Кулаков" Это плохо.
1959.06 1961.82 "Анатолий Кулаков" Плохо обычно для производительности вашего приложения.
1961.82 1970.66 "Анатолий Кулаков" Чтобы избежать этого, в принципе есть очень простой хак, он не очень красивый, но зато эффективный.
1970.66 1984.86 "Анатолий Кулаков" Как мы уже упоминали, компилятор умеет создавать статический делегат, в котором один раз просто-напросто закэширует тот делегат, который будет потом непосредственно передавать в нужную точку, нужную точку вызова.
1984.86 2005.66 "Анатолий Кулаков" Вы можете сделать это ручками, взять свой метод групп, взять свою статическую функцию, взять свои какие-то методы и преобразовать это к делегату, сделать этот делегат статический, если вам это позволяет бизнес-логика, и вот этот статический делегат, вот только его, без всяких переобразований, неявных, использует в своем коде.
2005.66 2010.10 "Анатолий Кулаков" Наверное, для performance-critical кода это имеет смысл, т.е.
2010.10 2019.66 "Анатолий Кулаков" такие некрасивые оптимизации, позволяющие устранить всякие неявные выделения в памяти, они имеют смысл, поэтому наверное кому-то на практике может пригодиться.
2019.66 2025.78 "Игорь Лабутин" Но ты при этом не сможешь создать явный инстанс, если тебе нужно сделать клошу.
2025.78 2031.38 "Анатолий Кулаков" Ну да, здесь ты уже понимаешь, что ты делаешь и чем это грозит.
2031.38 2035.22 "Анатолий Кулаков" Тут главное понимать и в тех местах, когда это возможно использовать эту оптимизацию.
2035.22 2055.46 "Игорь Лабутин" На самом деле здесь тоже есть небольшой хинт, как можно в некоторых случаях попытаться это сделать, сделайте не захват переменной, а сделайте эту самую переменную еще одним аргументом лямбды, например, и того логики или метода, который вы вызываете внутри лямбды.
2055.46 2059.46 "Игорь Лабутин" И передавайте этот стейт как аргумент в лямбду.
2059.46 2064.38 "Игорь Лабутин" Тогда лямбда будет статической, она ничего не будет захватывать, и на этом можно тоже сэкономить.
2064.38 2075.66 "Анатолий Кулаков" Да, если вы плотно используете 3D или другие примитивы многопоточности в дот-нете, вы наверняка сталкиваетесь с таким паттерном.
2075.66 2089.54 "Анатолий Кулаков" Он есть во фреймворке, и в принципе автор признается, что в следующих версиях они планируют подобный подход внедрить еще как можно больше сигнатур, которые критичны к перформансу.
2089.54 2094.38 "Игорь Лабутин" Ну то есть практически весь дот-нет, потому что кажется, что весь дот-нет сейчас критичен к перформансу.
2094.38 2116.54 "Анатолий Кулаков" Да, просто этот подход не очень гибкий, потому что этих стейтов, которые можно передавать, желательно сделать по неограниченное число, по сути, потому что если вы сделаете всего лишь один аргумент стейта, вам придется этот аргумент во что-то заворачивать, то есть по сути создавать тоже какие-то объекты в раппер и потом их разворачивать.
2116.54 2125.90 "Анатолий Кулаков" Ну то есть есть с этим подходом и какие-то проблемы по красивости и может быть даже какие-то будут проблемы по производительности, если неправильно его использовать.
2125.90 2128.30 "Игорь Лабутин" Именованные ValueTuples по судносу.
2128.30 2130.06 "Игорь Лабутин" Передавай туда большой ValueTuple.
2130.06 2133.42 "Игорь Лабутин" Хотя он, кстати, забоксится, наверное, плохо будет тоже.
2133.42 2134.42 "Игорь Лабутин" Ладно, плохой совет.
2134.42 2136.42 "Игорь Лабутин" Ладно, пошли дальше.
2136.42 2137.74 "Игорь Лабутин" FILE и I/O.
2137.74 2153.70 "Игорь Лабутин" Это на самом деле такая прикольная фижа, про нее много что говорили, Microsoft много где и Adam Sittnick, в частности, который, я так понимаю, основной драйвер всей этой штуки, довольно много рекламировал ее в Твиттере, но долгое время ничего не было известно, что там делается.
2153.70 2163.22 "Игорь Лабутин" Ну, нет, наверное, на GitHub можно было найти ищу, если поискать, но мне ничего не попадалось до тех пор, пока, собственно, Adam не выпустил финальную статью, и он описал, что же было сделано.
2163.22 2174.10 "Игорь Лабутин" И мы в нее чуть поподробнее закопаемся, потому что там есть довольно интересные и на самом деле ломающие изменения, если вы как-то нестандартно работали с файлами.
2174.10 2178.06 "Игорь Лабутин" Я бы не назвал, что они брейкинг для 99% кода, но все-таки интересно.
2178.06 2182.82 "Игорь Лабутин" Во-первых, давайте вспомним, что такое файл стрима и вообще стримы.
2182.82 2197.82 "Игорь Лабутин" То есть, файл стрим, сама конструкция, несмотря на то, что она называется файл стрим, под Linux она позволяет работать только с файлами, а вот под Windows она позволяет работать с чем угодно, файлами, именованными каналами, сокетами, в принципе, ну и так далее.
2197.82 2199.74 "Игорь Лабутин" С тем, что можно читать и писать.
2199.74 2206.70 "Анатолий Кулаков" Слушай, это интересная декларация, потому что под Linux она по определению, все сокеты и пайпы, это уже по определению файлы.
2206.70 2215.62 "Игорь Лабутин" Да, но вот я могу ошибаться, может быть я не прав, но по-моему в статье было сказано, что файл стримы на Linux, это вот именно файл стримы.
2215.62 2217.18 "Игорь Лабутин" Сокеты там чуть-чуть по-другому поддержаны.
2217.18 2224.14 "Игорь Лабутин" Хотя ты прав, с точки зрения архитектуры самого Linux, это действительно близко все к файлам.
2224.14 2234.38 "Анатолий Кулаков" То есть, обычно на Aplication уровне, если ты пишешь файл, то ты никак не можешь понять, ты записал эти данные в сокет, который по правде этот файл возьмет и перешлет на другую машину или нет.
2234.38 2240.62 "Анатолий Кулаков" То есть, теоретически от фреймворка, от языка программирования, от самого программиста это вообще никак не зависит.
2240.62 2241.62 "Анатолий Кулаков" Да.
2241.62 2242.90 "Анатолий Кулаков" Умеешь писать файлы и все, в принципе, ты счастлив.
2242.90 2243.90 "Игорь Лабутин" Согласен.
2243.90 2251.50 "Игорь Лабутин" Ну вот почему-то у меня такое мнение сложилось из чтения статьи, возможно я ее читал неправильно или не по той диагонали.
2251.50 2257.50 "Игорь Лабутин" Кроме того, файл и вообще файл стрим может быть открыт в синхронном либо асинхронном режиме.
2257.50 2264.06 "Игорь Лабутин" И поверх этого у нас еще есть методы синхронные и асинхронные внутри самого файла стрима.
2264.06 2270.18 "Игорь Лабутин" То есть, может получиться так, что файл открыт для синхронного доступа, но вы используете асинхронные методы или наоборот.
2270.18 2283.10 "Игорь Лабутин" И при этом еще в файл стриме есть некоторая буферизация внутри, чтобы не все ваши записи, допустим, по одному байтику отсылать прямо в операционную систему, а сначала как-то накапливать промежуточную буферию и система отсылает целиком буфер.
2283.10 2291.26 "Анатолий Кулаков" Что-то мне подсказывает, что такой же буфер есть у самооперационной системы, потом есть у файловой системы, потом есть у дисковой системы и так далее.
2291.26 2293.70 "Анатолий Кулаков" То есть, таких буферочек у нас по дороге огромное
2293.70 2297.58 "Игорь Лабутин" количество. Кажется, ты знаешь архитектуру современного компьютера.
2297.58 2303.70 "Игорь Лабутин" Действительно их много, но как бы системный вызов по определению дорогой считается.
2303.70 2308.62 "Игорь Лабутин" И понятно, что каждый раз дергать системный вызов, это все-таки дорого, как ни крути.
2308.62 2321.38 "Игорь Лабутин" Несмотря на то, что там действительно огромное количество буферов дальше по пути, разработчики все-таки старались не делать syscall каждый раз, а делать его довольно-таки, скажем так, пореже.
2321.38 2324.06 "Игорь Лабутин" Теперь к изменениям.
2324.06 2335.46 "Игорь Лабутин" Одно забавное изменение сводится к тому, что полностью поменялся алгоритм работы с позиционированием внутри файла.
2335.46 2351.46 "Игорь Лабутин" То есть, до текущего момента, до шестого .NET, файл stream всячески пытался поддерживать свой внутренний файл-пойнтер и файл-пойнтер от операционной системы в синхронном состоянии.
2351.46 2372.22 "Игорь Лабутин" То есть, каждый раз, когда вы делали, допустим, перемещение по файлу, вызывался не только внутренний, какие-то методы, которые просто переставляли внутренний пойнтер, но и вызывался обязательно вызов в InApi, например, с getfilepointer, чтобы, в смысле, нативный указатель внутри файла тоже переставился.
2372.22 2373.90 "Игорь Лабутин" Теперь этого не делается.
2373.90 2391.18 "Игорь Лабутин" То есть, теперь, если вы, не знаю, читаете файл, например, у вас вроде как указатель текущее положение внутри файла двигается, но если вы вызовете в InApi на том же самом файле и получите getfilepointer, то он будет стоять в нуле и никуда не двигаться.
2391.18 2394.18 "Игорь Лабутин" Они теперь никак не связаны.
2394.18 2403.78 "Игорь Лабутин" Не то чтобы это было бы сильно важно, но если вы, например, один и тот же файл открываете в каком-нибудь shared режиме между нативным кодом и ненативным кодом и .NET, то теперь это надо учитывать.
2403.78 2410.38 "Игорь Лабутин" У вас при чтении, например, нативным кодом .NET не будет знать, что там кто-то куда-то что-то подвинул.
2410.38 2415.46 "Игорь Лабутин" Или если вы вызоветесь от файлпойнтера в InApi, это никак не повлияет на файлстрим.
2415.46 2419.06 "Анатолий Кулаков" Мне кажется, в shared режиме они могли бы все-таки оставить старое поведение.
2419.06 2420.58 "Игорь Лабутин" Нет, вот они и не оставили.
2420.58 2421.58 "Игорь Лабутин" Никак.
2421.58 2427.94 "Игорь Лабутин" Я про это еще скажу чуть дальше, но можно его оставить, но это нужно специально делать.
2427.94 2454.30 "Игорь Лабутин" Кроме того, если под виндой файлстрим конструктор понимает, что он открывает файл в режиме чтения, причем без возможности shared записи, то есть по сути в монопольном режиме, то есть никто другой кроме этого же файлстрима не может этот файл писать, то тогда он сразу кэширует длину файла и будет ее менять только если вы реально начнете писать, ну или триммить файл, соответственно, через файлстрим.
2454.30 2463.94 "Игорь Лабутин" Это позволяет в любой момент узнать точный размер файла, не обращаясь к операционке и не бегая в конец файла, соответственно, дополнительными вызовами операционной системы.
2463.94 2467.18 "Игорь Лабутин" Стало прям быстрее.
2467.18 2474.22 "Игорь Лабутин" Дальше довольно большое количество изменений произошло вокруг ride-async, read-async и так далее.
2474.22 2487.46 "Игорь Лабутин" И основной суть всех изменений заключается в том, чтобы ride-async делал не более одного сисколу, потому что, ну при записи read-async то же самое.
2487.46 2496.86 "Игорь Лабутин" То есть максимум, что может сделать ride-async, это максимум вызвать один раз соответствующий вызов операционной системы, чтобы записать, допустим, заполненный буфер.
2496.86 2500.18 "Анатолий Кулаков" Ну звучит довольно таки логично, а почему он мог сделать несколько сискол?
2500.18 2537.54 "Игорь Лабутин" Раньше потому что считалось, что если вы пишете, например, вы могли сказать перед ride-async, вы могли сказать setfileposition куда-нибудь за конец файла, это была разрешенная операция в Windows, после чего начать писать, и ride-async в старой версии сначала как-то вызывал специальный сискол, чтобы расширить файл до нужного размера, потом вызывал сискол для записи, потом он вызывал сискол для get нового файла pointer, чтобы понять, на сколько записалось, куда подвинулось, короче там по-моему 3 максимум получалось.
2537.54 2546.66 "Игорь Лабутин" Но тут разработчики тутнета поговорили с разработчиками Windows, выяснили, что половину этих сискол делать необязательно, и можно сделать прямо ride, и все будет работать.
2546.66 2551.38 "Игорь Лабутин" Ну а тем более, если мы не паримся с их организацией этих самых позишенов, то все стало совсем хорошо.
2551.38 2573.30 "Игорь Лабутин" С read-async то же самое, и плюс вокруг ride-async там есть еще добавление, ну когда мы используем async-версию, там в случае если для оптимизации используются value-таски, и там тоже есть некоторая оптимизация вокруг них через task-completion-source и так далее, чтобы с ними было поумнее работать.
2573.30 2583.02 "Игорь Лабутин" Значит вообще есть еще синхронные методы, как я говорил, у файлов стрима есть read-async, ride-async, а есть еще read-write.
2583.02 2596.22 "Игорь Лабутин" Для файлов, которые открыты были в режиме синхронного I/O, то есть для которых нужно использовать синхронный Windows API, там все вообще оптимально, то есть read и write максимально просто вызывали синхронный read и write операционки, и на этом все заканчивалось.
2596.22 2628.18 "Игорь Лабутин" А вот если для Windows у нас был файлик открыт в асинхронном режиме, то есть нужно было использовать асинхронный I/O в Windows, но при этом синхронно, result-to-net, то раньше это делалось на thread-pool, ну как вот обычный sync-over-async, используя потоки thread-pool, и очень неоптимально, теперь просто это дело авансируется в wait-handle просто на лету и ждется на нем без расходования thread-pool, так что все более эффективно стало.
2628.18 2637.02 "Игорь Лабутин" Появился новый класс Random Access, мы при нем уже говорили, здесь провалили немножко света на то, зачем он нужен.
2637.02 2664.54 "Игорь Лабутин" Это на самом деле то, что называется thread-safe-file-io, поскольку туда всегда передается явный оффсет внутри файла, то вызовы этих методов в Random Access не зависят от текущей позиции в файле, таким образом вы никак не… разные потоки не зависят от того, как там другие потоки в каком порядке пишут, RandomAccess.read или RandomAccess.write будут писать строго в той позиции, которая передана в метод, именно поэтому они не thread-safe.
2664.54 2685.78 "Игорь Лабутин" И там же в Random Access появилась новая API для то, что в Windows называется scatter-gatherer.io, это возможность писать из нескольких буферов сразу или читать в них соответственно, но более оптимально просто, если у вас есть несколько буферов, которые надо заполнить, можно делать оптимально в винде, есть просто API, это просто к ней доступ.
2685.78 2693.78 "Игорь Лабутин" Интересные изменения, это новая штука, она доступна была в винде, ну в смысле это можно было сделать через WinAPI, но не было доступно через Files 3.
2693.78 2706.26 "Игорь Лабутин" Теперь можно при открытии файлов при создании сказать, что файл должен сразу стать определенного размера, и прямо при открытии будет проверено, что место на диске есть, и под него будет зарезервировано нужное количество байтов.
2706.26 2719.94 "Игорь Лабутин" Таким образом, если вам, например, нужно открыть там гарантированно мегабайтный файл, а у вас на диске меньше там мегабайта, то у вас упадет уже прямо открытие файла, а не запись в какой-то более поздний момент, потому что место кончилось.
2719.94 2740.06 "Анатолий Кулаков" Я помню, как в какие-то древние времена специально для этих целей использовались специальные утилиты, которые могли на диске найти место без фрагментированных кластеров, создать один большой файл непрерывной длины, ну то есть непрерывного размера, и уже в этот файлик мы писали свои данные, делали свою базу данных.
2740.06 2742.26 "Анатолий Кулаков" Были такие даже времена.
2742.26 2750.50 "Игорь Лабутин" Да, были такие, и в WinAPI есть аргументик, который говорит "pre-allocate", я не помню, как там размер указывается, но как-то можно указать.
2750.50 2753.78 "Игорь Лабутин" Короче, теперь это просто доступно в дотнете.
2753.78 2771.34 "Игорь Лабутин" И поскольку количество аргументов конструктора файла стрима перевалило уже за какое-то неприличное число с учетом всех этих новых флажков и так далее, то теперь есть классик, называется "FileStreamOptions", и есть конструктор в файлстриме, который принимает теперь "FileStreamOptions", где вы все указываете.
2771.34 2775.78 "Игорь Лабутин" Там всякие "ReadMode", "SharedMode", вот эти "Pre-allocationSize" и все такое прочее.
2775.78 2777.70 "Игорь Лабутин" Остальные конструкторы помечены как абсолютные.
2777.70 2783.02 "Анатолий Кулаков" Отлично, любую проблему можно решить с помощью повышения уровня абстракции.
2783.02 2784.02 "Игорь Лабутин" Да.
2784.02 2786.54 "Игорь Лабутин" Дальше раздел "Breaking Changes".
2786.54 2795.30 "Игорь Лабутин" Значит, первый "Breaking Change" — это тот самый файл от offset, который теперь только в памяти файлстрима трекается и не синхронизируется с нативным файлстримом.
2795.30 2818.74 "Игорь Лабутин" И следующий "Breaking Change" теперь заключается в том, что если вы вызываете несколько "sync" операций на файлстриме, и у него включен буферинг, то есть буферизация промежуточных результатов, то теперь все асинхронные операции будут выполняться последовательно.
2818.74 2821.54 "Игорь Лабутин" То есть, они не асинхронные, все дела будут последовательны.
2821.54 2833.34 "Игорь Лабутин" И, соответственно, видимый эффект того, что "FileStream.Position" будет возвращать правильный результат после того, как операция закончена.
2833.34 2841.34 "Игорь Лабутин" То есть, например, вы пишете что-то или читаете, то вот эта позиция будет задвигаться после того, как операция выполнена, а не до.
2841.34 2850.86 "Игорь Лабутин" До шестого дотнета позиция обновлялась практически сразу или во время выполнения операции, сейчас теперь она будет обновляться только в конце выполнения операции.
2850.86 2870.14 "Игорь Лабутин" Поэтому если у вас есть, например, какой-нибудь, не знаю, код, который читает какой-нибудь огромный файл и в параллель трет, который проверяет, где сейчас позиция в файле, то вот надо понимать, что вот этот второй трет, который читает позицию, его поведение чуть-чуть поменяется теперь в зависимости от того, как выполняется ваша async операция.
2870.14 2875.82 "Игорь Лабутин" Все эти штуки можно выключить, чтобы этих breaking не было.
2875.82 2879.18 "Игорь Лабутин" Можно вернуть так называемый dotnet5 compatibility mode.
2879.18 2893.78 "Игорь Лабутин" Это можно сделать, как обычно, либо через runtime.config.json, туда написать "system.io.usenet5.compat.file.stream=true", ну либо через environment.perm, ну и точно так же dotnet.system.io.usenet5.compat.file.stream=1.
2893.78 2898.86 "Игорь Лабутин" Но это только на время шестого дотнета, в седьмом дотнете эти ключики уберут.
2898.86 2902.50 "Игорь Лабутин" Из седьмого дотнета, начиная, файлстрим будет вести себя только по-новому.
2902.50 2907.90 "Анатолий Кулаков" Ладно, это же писал Adam Sitnik, а Адам - это самый главный в дотнете по бенчмаркам.
2907.90 2909.30 "Анатолий Кулаков" Давай к цифрам.
2909.30 2910.30 "Анатолий Кулаков" К чему это привело?
2910.30 2911.50 "Анатолий Кулаков" Сколько мы выиграем?
2911.50 2913.74 "Анатолий Кулаков" Миллионов тактов или миллисекунд?
2913.74 2914.74 "Анатолий Кулаков" Где бенчмарки?
2914.74 2923.82 "Игорь Лабутин" Бенчмарков, кстати, огромное количество, я специально не останавливался на них, потому что к каждому из этих изменений есть подробнейший бенчмарк, где явно указывается, сколько и где они сэкономили.
2923.82 2926.10 "Игорь Лабутин" И экономия там прям очень разная.
2926.10 2935.50 "Игорь Лабутин" То есть, есть бенчмарки, где мы сэкономили 20%, есть бенчмарки, где мы сэкономили там 99-100%, особенно по памяти.
2935.50 2938.10 "Игорь Лабутин" Есть бенчмарки, где мы даже чуть-чуть ухудшили.
2938.10 2943.10 "Игорь Лабутин" Там есть парочка таких кейсов, но там буквально ухудшение типа 1%, не страшно.
2943.10 2951.30 "Игорь Лабутин" Но это все бенчмарки, это все довольно искусственные примеры в реальных кейсах после того, как собственно Адам анонсировал эти изменения.
2951.30 2961.02 "Игорь Лабутин" Появились ребята, которые в реальных проектах попробовали взять превьюшку шестого .NET и попробовать свой реальный кейс на новых файлстримах.
2961.02 2968.34 "Игорь Лабутин" И то, что они репортят, это где-то 30-40% с точки зрения каких-то метрик, назовем это так.
2968.34 2972.50 "Игорь Лабутин" То есть, код стал работать быстрее на процентов 30 на реальных приложениях.
2972.50 2974.82 "Игорь Лабутин" Но это реальные приложения число.
2974.82 2980.86 "Игорь Лабутин" Это файл дробилки, которые как бы много работают с файлстримами.
2980.86 2993.06 "Игорь Лабутин" Если у вас приложение, которое иногда что-то читает, вы прям не увидите какого-то существенного прироста производительности, но все равно приятно, что еще один кусочек .NET фреймворка стал поменьше чего-то кушать.
2993.06 2996.74 "Анатолий Кулаков" Да, еще на один шаг ближе ко всяким базам данных.
2996.74 3001.26 "Анатолий Кулаков" Активная работа с диском, с бигдатой и может быть еще с чем-нибудь таким.
3001.26 3004.62 "Анатолий Кулаков" Хорошо, давай ближе теперь вернемся к нашим редакторам.
3004.62 3008.98 "Анатолий Кулаков" И компания JetBrains выпустила анонсы ReSharper и Rider.
3008.98 3011.38 "Анатолий Кулаков" То есть, не анонсы, а roadmap.
3011.38 3014.26 "Анатолий Кулаков" Их планы на версии 2021.3.
3014.26 3023.46 "Анатолий Кулаков" Очень интересно посмотреть, что там у наших замечательных JetBrains в планах на редакторы.
3023.46 3026.58 "Анатолий Кулаков" Поэтому давай подробнее опустимся к ним.
3026.58 3029.42 "Анатолий Кулаков" Прежде всего это поддержка студии 2022.
3029.42 3033.66 "Анатолий Кулаков" Это всем известная студия, которая станет теперь 64-битной.
3033.66 3041.18 "Анатолий Кулаков" Естественно все плагины под нее нужно будет переписать и ReSharper является одним из самых больших и популярных плагинов.
3041.18 3043.98 "Анатолий Кулаков" Поэтому неудивительно, что его нужно адаптировать к этой студии.
3043.98 3052.10 "Анатолий Кулаков" И уже сейчас есть версия ReSharper в отдельном бранчике на отдельной страничке, которая доступна.
3052.10 3059.74 "Анатолий Кулаков" И вы можете уже попробовать в новой студии запустить новый ReSharper под 64 бита и посмотреть как оно там работает.
3059.74 3062.86 "Анатолий Кулаков" А также зарепортить свои баги и дать какой-то новый фидбэк.
3062.86 3069.86 "Анатолий Кулаков" И в Roadmap они обещают, что продолжат работать в этом направлении и всячески улучшить и стабилизировать.
3069.86 3070.86 "Анатолий Кулаков" Само собой разумеется.
3070.86 3076.26 "Анатолий Кулаков" Также у нас будет улучшенная поддержка C# 10.
3076.26 3080.46 "Анатолий Кулаков" Соответственно проапгрейдятся все анализаторы, навигаторы, рефакторинги.
3080.46 3087.30 "Анатолий Кулаков" И ReSharper начнет понимать такие замечательные и интересные фичи, как Constant Interpolation String, который мы уже обсуждали.
3087.30 3088.30 "Анатолий Кулаков" Рекорды.
3088.30 3092.26 "Анатолий Кулаков" Рекорды теперь смогут быть структурами.
3092.26 3097.86 "Анатолий Кулаков" Поддержка этой функции, когда рекорды будут структурами.
3097.86 3098.86 "Анатолий Кулаков" List Patterns.
3098.86 3109.58 "Анатолий Кулаков" Это когда мы можем матчить значения в списках с помощью более понятного, более читабельного синтаксиса, с какими-то определенными константами или с какими-то определенными переменными.
3109.58 3112.74 "Анатолий Кулаков" Global Using Directives.
3112.74 3123.86 "Анатолий Кулаков" Когда мы сможем объявлять часто используемые namespaces где-то в одном месте и они будут распространяться на весь какой-то модуль, проект или может быть даже солюшен.
3123.86 3132.94 "Анатолий Кулаков" Это тоже еще в принципе разработки, но уже чтобы такие фичи трогать, чтобы как-то с ними экспериментировать, было бы неплохо обзавестись поддержкой в IDE.
3132.94 3137.30 "Анатолий Кулаков" Вот на чем ReSharper уже начинает экспериментировать, начинает их добавлять.
3137.30 3140.54 "Анатолий Кулаков" Еще одна интересная фишка это Grammar Checking.
3140.54 3145.18 "Анатолий Кулаков" У ReSharper давно уже есть встроенная поддержка Spell Checking.
3145.18 3150.34 "Анатолий Кулаков" Изначально это был плагин, даже если я не ошибаюсь, это был плагин отдельного какого-то автора.
3150.34 3166.10 "Анатолий Кулаков" После этого ReSharper каким-то образом или выкупил или забрал этот плагин себе в JetBrains, строили его непосредственно сам ReSharper и давно уже есть поддержка языка у нас благодаря этому плагину.
3166.10 3180.50 "Анатолий Кулаков" Но теперь они посигнули на грамматику и теперь хотят, чтобы с ошибки в вашем тексте, в ваших комментариях проверялись еще с точки зрения грамматики.
3180.50 3185.42 "Анатолий Кулаков" Теперь наверное Grammarly должен задрожать, ибо у него появляется серьезный конкурент.
3185.42 3195.66 "Анатолий Кулаков" Посмотрим насколько комментарии в вашем коде и документация к вашим методам станет более красивая и более грамотная.
3195.66 3196.90 "Анатолий Кулаков" Predictive Debugger.
3196.90 3201.18 "Анатолий Кулаков" Еще одна интересная штука, о которых мы упомянули в предыдущих анонсах.
3201.18 3210.74 "Анатолий Кулаков" Это специальный механизм, который помогает понять, что будет в результате выполнения вашего кода, не запуская сам код.
3210.74 3220.82 "Анатолий Кулаков" То есть анализатор может просмотреть код, как-то его проинтерпретировать, посмотреть какие-то входят данные и примерно вам показать, что будет.
3220.82 3228.30 "Анатолий Кулаков" Хорошая новость заключается в том, что весь главный механизм, который делает основную работу уже закончен, он готов.
3228.30 3236.18 "Анатолий Кулаков" И сейчас дорабатывается только UI и User Experience о том, как это лучше всего показать и как это лучше всего использовать.
3236.18 3239.18 "Анатолий Кулаков" Тоже забавная штука, интересно посмотреть ее в действии.
3239.18 3242.86 "Анатолий Кулаков" Также добавляются планы на линку Visualizer.
3242.86 3254.18 "Анатолий Кулаков" Те, кто работал или слышал про Java Stream, наверняка видели, как она красиво умеет показывать всю подноготную этих стримов.
3254.18 3264.38 "Анатолий Кулаков" То есть, допустим, если у вас есть какая-то цепочка линку выражений, где вы там фильтруете, делаете select, как-то мапите, группируете.
3264.38 3274.22 "Анатолий Кулаков" Обычно это записывается в такую красивую цепочку лаконичных выражений, которая легко читается и красиво смотрится.
3274.22 3276.90 "Анатолий Кулаков" Но у нее есть большая проблема, она очень плохо отдебажится.
3276.90 3287.90 "Анатолий Кулаков" Обычно, если где-то посерединке этой цепочки у вас появляются какие-то странные данные, можно поставить breakpoint, как-то в дебагере попытаться там что-то отладить, как-то выделять.
3287.90 3295.06 "Анатолий Кулаков" Можно это даже вынести в отдельную переменную и на каждом шаге посмотреть, какие значения в этой переменной находятся и каким-то образом найти эту ошибку.
3295.06 3302.58 "Анатолий Кулаков" С помощью новой фишки линку Visualizer вам не нужно будет больше не ставить бряки, не вводить переменные.
3302.58 3314.70 "Анатолий Кулаков" Он вам возьмет весь расходящий поток данных и очень красиво, грамотно, по шагам визуализирует на каждом шаге, на каждом этапе, какие данные у вас получаются.
3314.70 3329.98 "Анатолий Кулаков" То есть вы вполне можете посмотреть, какие данные остались у вас после wear, после фильтрации, какие данные преобразовались после select, что у вас получилось в результате группировки и все это в виде удобного диалогового окошка с красивым, понятным интерфейсом.
3329.98 3338.26 "Анатолий Кулаков" Дальше планируется ввести много полезных функций в Entity Framework, в частности, это инспекция n+1 проблемы.
3338.26 3363.06 "Анатолий Кулаков" Мы тоже ее обсуждали в прошлый раз и там решатель отличается тем, что, мне кажется, впервые для себя он будет инспектировать не просто какой-то локальный синтаксис или локальный кусочек кода, но ему придется совместить очень много знаний о фреймворке, о синтаксисе, о различных инъекциях, все это собрать в одном месте и сделать такой вывод.
3363.06 3374.42 "Анатолий Кулаков" Такой довольно глобальный анализ на уровне всего солюшена и с очень большой логикой, с очень большим выводом, который приводит к качеству, к перформансу улучшения.
3374.42 3388.38 "Анатолий Кулаков" Дальше у нас там будет в Entity Framework расширенная валидация схемы, например, он научится искать циклические зависимости вашей схемы, а также какие-то неверные декларации модели.
3388.38 3401.42 "Анатолий Кулаков" Еще один неочевидный пункт, который меня удивил, это в том, что Redsharper начинает каким-то образом понимать, насколько ваш код может соответствовать CQRS модели.
3401.42 3413.42 "Анатолий Кулаков" То есть такие термины, как Event Sourcing, Domain Driven Design, очень популярны в .NET и очень часто используются как на уровне всего приложения, так и на уровне маленьких компонентиков в принципе везде.
3413.42 3424.50 "Анатолий Кулаков" Redsharper решил помочь разработчикам писать правильный код, который попадает под эти определения.
3424.50 3435.46 "Анатолий Кулаков" В частности, как первый шаг он научился понимать команды, кверизы и научился определять, что внутри команд не должно быть никаких вызовов кверий.
3435.46 3438.86 "Анатолий Кулаков" Вот это один из основных постулатов CQRS.
3438.86 3442.66 "Анатолий Кулаков" И вот здесь вот такой анализ был добавлен.
3442.66 3454.94 "Анатолий Кулаков" Анализ, конечно же, примитивный, но тот факт, что на уровне такого мощного анализатора, как Redsharper, мы научимся понимать шаблон CQRS, это, мне кажется, дорогого стоит.
3454.94 3466.66 "Анатолий Кулаков" Соответственно, я жду не дождусь, когда в домен Driven Design он мне тоже начнет подсказывать что-то интересное, например, какой-нибудь общий словарь, какие-нибудь bound контексты и так далее.
3466.66 3471.82 "Анатолий Кулаков" То есть непаханное поле просто оптимизаций и за этим будет очень интересно наблюдать.
3471.82 3476.10 "Анатолий Кулаков" Отличное направление, пожелаем отдельного успеха в этой области.
3476.10 3486.10 "Анатолий Кулаков" А касательно CommonLine Tools появилась долгожданная возможность это загружать всякие экстеншены, всякие плагины к CommonLine Tools.
3486.10 3503.86 "Анатолий Кулаков" То есть если вы вдруг запускали это на каком-нибудь вашем билд сервере, какие-нибудь Redshaper анализаторы или раннеры или еще что-то и вдруг использовали какие-то плагины, то вот сейчас вы это вполне можете сделать и на вашем билд сервере не только локально, не только из UI.
3503.86 3506.62 "Анатолий Кулаков" Это тоже прекрасно и хорошо.
3506.62 3510.50 "Анатолий Кулаков" Как я уже и сказал, планы такие же точно и на Rider.
3510.50 3517.70 "Анатолий Кулаков" У Rider будут те же самые перформансы и оптимизации, еще много там про Unity, Unreal.
3517.70 3525.94 "Анатолий Кулаков" Но в принципе самое главное, что стоит отметить, мне кажется, это то, что команда обещает сосредоточиться на поддержке код Vim.
3525.94 3541.26 "Анатолий Кулаков" Код Vim - это специальный сервис, инструмент, продукт, JetBrains, который позволяет вам работать вместе над каким-то одной кодовой базой, вместе общаться, вместе изменять код и что-то делать.
3541.26 3550.02 "Анатолий Кулаков" В общем, подсуществлять полную коллаборацию и при этом данную поддержку получили все инструменты на основе идеи, кроме Rider.
3550.02 3563.98 "Анатолий Кулаков" И вот теперь Rider обещает подтянуться, он обещает что-то в этом направлении сделать и всячески старается к следующему релизу эту функцию себя реализовать.
3563.98 3573.06 "Анатолий Кулаков" Все остальные мелочи, стоит обязательно отметить, что в комментарии народ просто шквалом требует поддержку мультимониторов, то есть нескольких мониторов.
3573.06 3582.50 "Анатолий Кулаков" И действительно, мне кажется, это один из самых главных бичей Rider, в принципе, что меня очень долго останавливало от того, чтобы начать им более-менее хоть как-то пробовать.
3582.50 3593.50 "Анатолий Кулаков" После Visual Studio, после ее шикарнейших окошек, которые можно растаскивать на разные мониторы, прикреплять в разные удобные места, которые работают предсказуемо, понятно и красиво.
3593.50 3598.50 "Анатолий Кулаков" Система окон у Rider просто отвратительно, ужасно и нетерпимо.
3598.50 3602.98 "Анатолий Кулаков" И работать с ним на нескольких мониторах, это тоже огромная боль.
3602.98 3608.98 "Анатолий Кулаков" В общем, надеемся, что ребята тоже здесь что-то сделают, но в этом Roadmap они ничего не обещали.
3608.98 3613.70 "Анатолий Кулаков" Это все крики из комментариев пользователей, которым это все жмет и мешает.
3613.70 3621.62 "Игорь Лабутин" Окей, прикольно, мы будем следить, что происходит и когда нам будет он реально доступен, поскольку Roadmap, Roadmap, а фичи писать тоже надо.
3621.62 3629.82 "Игорь Лабутин" В студии 2022 особых новостей нет, мы ждем пока следующих превьюшек, но пока их нет.
3629.82 3638.74 "Игорь Лабутин" Есть две фичи, которые я на самом деле не заметил в прошлые разы, но они довольно забавные, поэтому стоит их рассмотреть.
3638.74 3643.26 "Игорь Лабутин" Во-первых, в студии 2022 появилась такая штука как Trust Settings.
3643.26 3653.38 "Игорь Лабутин" Это абсолютно новая, ну скажем так, кусочек настроек и функциональности, которая позволяет вам теперь сказать, доверяете вы какому-то коду или не доверяете.
3653.38 3681.82 "Игорь Лабутин" И если вы открываете какой-то неизвестный ранее вам репозиторий, по дефолту студия будет считать, что он недоверенный, но он Trusted, и пока вы не выберете его, что он Trusted, то соответственно студия будет открываться в так называемом Restricted Mode, конкретно с этим проектом, и это означает, что в этом коде не будут выполняться никакие дизайн тайм билды, то есть никакие Source генераторы, всякие T4 генерации выполняться не будет.
3681.82 3692.78 "Игорь Лабутин" То есть по сути таким образом вы можете довольно безопасно открывать любой склонированный из интернета репозиторий, не боясь, что там что-нибудь на вашей машине выполнится, так скажем, страшное.
3692.78 3697.38 "Игорь Лабутин" Кто знает, что там в Source генератор напихали или еще куда.
3697.38 3717.26 "Игорь Лабутин" При этом студия, ну точнее Microsoft понимает, что студию часто используют в Enterprise, поэтому это все можно будет настроить через Group Policy, доменные политики, вот это все там, что у вас на работе будет только ряд допустимых репозиториев, а все остальные будут не Trusted и их нельзя будет сделать Trusted.
3717.26 3725.66 "Игорь Лабутин" Так что с одной стороны фича вроде прикольная, с другой стороны таким образом можно запретить сотрудников работать над чем угодно, кроме как над теми проектами, которые Trusted.
3725.66 3728.98 "Игорь Лабутин" Может даже кто-то этим воспользуется.
3728.98 3731.70 "Игорь Лабутин" Вторая фича это Debugging External Sources.
3731.70 3744.46 "Игорь Лабутин" Сам по себе дебаггер он давно уже есть, студия уже в 2019 версии вполне умеет декомпилировать внешние сурсы и подтягивать их, если они есть там где-то в PDB.
3744.46 3763.02 "Игорь Лабутин" Но теперь эти External Sources, если они есть у DailyLeg, которые у вас есть и вы находитесь в дебаггере, то в Solution Explorer у вас появится новая нода, называется External Sources, где будут видны эти самые сурсы, на которые есть ссылки из PDB.
3763.02 3768.14 "Игорь Лабутин" И соответственно вы сможете их побраузить, посмотреть, там бэкпоинты подоставлять и так далее.
3768.14 3779.58 "Игорь Лабутин" Так что штука удобная, если вы действительно отлаживаетесь со внешними исходниками из PDB, это прям будет очень полезно видеть их прям визуально в дереве в Solution Explorer.
3779.58 3786.50 "Игорь Лабутин" Вот таких вот две мелких фичи, ничего нового нет пока, ждем какого-то очередного апдейта в студии.
3786.50 3794.70 "Анатолий Кулаков" Хорошо, пойдем к более веселым вещам, что можно поделать в свободное от прослушивания нашего подкаста время.
3794.70 3802.70 "Анатолий Кулаков" Конференция .NEXT открыла по старой доброй традиции плейлист со своего предыдущего сезона, в частности Питер 2021.
3802.70 3814.50 "Анатолий Кулаков" И соответственно плейлист там около 30 отличных докладов от экспертов мирового уровня, от начинающих докладчиков и просто от хороших людей.
3814.50 3819.50 "Анатолий Кулаков" В общем обязательно посмотрите, наверняка каждый из вас найдет что-то для себя интересное.
3819.50 3837.82 "Анатолий Кулаков" А мы в принципе можем пообсудить статью, потому что вместе с плейлистом компания выпустила еще статью на Хабре с описанием топ 10 докладов по мнению слушателей, по мнению зрителей, которые голосовали за самые лучшие доклады, за самых лучших спикеров.
3837.82 3840.58 "Анатолий Кулаков" И в результате получился вот такой интересный рейтинг.
3840.58 3847.26 "Анатолий Кулаков" Предлагаю по старой доброй традиции пройтись по 10 первым местам и немножко вспомнить этих докладов.
3847.26 3853.78 "Анатолий Кулаков" В принципе по каждому докладу у нас есть подробный обзор в специальном выпуске, который мы посвятили этой конференции.
3853.78 3860.58 "Анатолий Кулаков" Если кому-то интересно, то можно этот выпуск переслушать перед просмотром плейлиста.
3860.58 3864.02 "Анатолий Кулаков" Может быть он вам поможет выбрать интересные для вас доклады.
3864.02 3865.62 "Анатолий Кулаков" Ну что ж приступим.
3865.62 3871.74 "Анатолий Кулаков" На 10 месте у нас распорядился Филипп Бочаров с докладом про наблюдаемость системы процессов.
3871.74 3877.30 "Анатолий Кулаков" Филипп рассказывал про свой опыт внедрения наблюдаемости в компании МТС.
3877.30 3883.58 "Анатолий Кулаков" Интересен доклад тем, что компания большая, проектов много, команд тоже очень много.
3883.58 3897.42 "Анатолий Кулаков" И как их всех пронаблюдать, так хорошо, чтобы весь девопс отдел был рад и счастлив, уникально, гарантированно и с различными фреймворками.
3897.42 3903.38 "Анатолий Кулаков" Вот про это все рассказывал Филипп, поэтому доклад отличный, достоин быть в топе.
3903.38 3905.26 "Игорь Лабутин" 9 место Павел Тупицын.
3905.26 3908.66 "Игорь Лабутин" Боремся с сетевым оверхедом в распределённых системах.
3908.66 3943.14 "Игорь Лабутин" Тут интересный доклад про хитрые распределённые базы данных, конкретно про то, как использовать Apache Ignite, что это такое и почему вам может быть это надо, потому что в традиционных базах данных, когда мы работаем с традиционными базами данных, у нас есть несколько там воркеров, которые исполняют код и мы ходим в какие-то удалённые возможно базы данных, чтобы прочитать оттуда что-то, перекинуть на компьютер или на виртуалку, где у вас живёт код обработки и как-то обработать и возможно записать данные обратно.
3943.14 3950.90 "Игорь Лабутин" Здесь же подход прям противоположно, мы берём код, кидаем его куда-то, где лежат данные и выполняем там, непосредственно рядом с данными.
3950.90 3958.30 "Игорь Лабутин" Подход довольно нетрадиционный, но интересный и в некоторых системах вполне себе активно используемый.
3958.30 3961.50 "Игорь Лабутин" Вот Павел как раз рассказывает про их опыт и про то, как они это использовали.
3961.50 3971.66 "Анатолий Кулаков" На 8 месте Станислав Сидристый разместился и рассказал он про то, каким образом они оптимизировали драйвер MongoDB и многократно увеличили его производительность.
3971.66 3990.42 "Анатолий Кулаков" Очень много всяких советов по увеличению перформанса, всяких хаков, очень много подходов, поэтому если вы любите заниматься именно перформансом, найдёте для себя у Стаса наверняка много-много полезных практических вещей, которые вам помогут.
3990.42 4008.66 "Игорь Лабутин" А на 7 месте доклад от Кемина Госса, где не узнаете ни одной практической вещи, которая вам помогут в реальной жизни в Тоннете, но тем не менее доклад очень интересный, и я всё-таки рекомендую его посмотреть, потому что, ну известно это выражение, что нужно знать систему на один уровень ниже того, на котором вы работаете.
4008.66 4016.14 "Игорь Лабутин" Здесь Кемин забирается уровня на три вниз, то есть если у вас есть проблема в Тоннете, то давайте поизучаем, как работает ронтайм на С++.
4016.14 4048.10 "Игорь Лабутин" Он довольно подробно разбирает, как он отлаживал некоторые проблемы, поэтому на самом деле вы, может быть, придётся вам столкнуться с таким штукой, если вы разбираете какие-то очень такие суровые concurrent проблемы, например, или что-то более интересное с painwalk'ами, так что посмотрите доклад, очень рекомендую, красивый разбор того, и очень понятный, надо сказать, того, как совместно работает ронтайм и базовая библиотека классов, и высокоуровневый dotnet-код, может быть, вам это пригодится какой-то
4048.10 4055.38 "Анатолий Кулаков" работе. Если ты считаешь, что у Кевина нет каких-нибудь практических подходов, то тебе нужно срочно обратиться к следующему месту.
4055.38 4061.58 "Анатолий Кулаков" На шестом месте у нас разместился Федерико Льюис с докладом про Teaching Sins in Virusland.
4061.58 4077.54 "Анатолий Кулаков" Этот доклад, прежде всего, этот Федерико известен тем, что, наверное, один из самых наших низкоуровневых и хардкорных спикеров, который может легко пощекотать железо и рассказать, как там что, где работает и как где летает.
4077.54 4089.02 "Анатолий Кулаков" И вот он занялся за жестокую математику, он занялся за анализ и решил проанализировать различные данные про нашей недавней пандемии.
4089.02 4100.78 "Анатолий Кулаков" В общем, что из него вышло и насколько это практически вообще реально хоть куда-то применить, вот это вам и предстоит увидеть на четвертом месте нашего топа.
4100.78 4106.02 "Игорь Лабутин" Пятое место, но только это было шестое, все-таки место у Федерико мы идем в обратном порядке, напоминаю.
4106.02 4111.98 "Игорь Лабутин" Поэтому пятое место это Барта Шепетковский Behind Modern Currency Primitives.
4111.98 4116.42 "Игорь Лабутин" Тема, на самом деле, довольно-таки простая, с одной стороны.
4116.42 4129.26 "Игорь Лабутин" Все мы работаем с асинхронностью, все мы так или иначе создавали какие-то потоки, задачи, а Бартыш рассказывает, как на самом деле это устроено внутри и самое главное, как обо всем этом нужно думать.
4129.26 4143.94 "Игорь Лабутин" Ну не то чтобы нужно, а как про это можно думать, в том числе показывая, как похожие вещи реализованы немножко в разных языках, по-разному и как это может помочь понять на самом деле, как они работают.
4143.94 4153.62 "Игорь Лабутин" То есть интересный взгляд на примитивы конкурентного программирования, на поточное программирование, в том числе с перспективой разных языков.
4153.62 4161.42 "Анатолий Кулаков" Четвертое место занял Станислав Лусов с докладом про миграцию вашего приложения с MS SQL на PostgreSQL.
4161.42 4189.14 "Анатолий Кулаков" Стас участвовал в проекте, который перенес огромную базу данных без единой секунды простоя в продакшене, перенес с MS SQL на PostgreSQL, при этом прошел этот процесс начиная от самого верха, то есть от бизнеса, от денег, от обоснования, от счетов, от лицензий и до самых низко уровнях вещей, от оптимизации, от совместимости по типам, от планов запросов, до SQL синтаксиса и так далее.
4189.14 4198.10 "Анатолий Кулаков" Ну то есть абсолютно все, что вам стоит знать для процесса миграции или просто для расширения кругозора, я думаю вы из доклада Стаса узнаете.
4198.10 4205.34 "Игорь Лабутин" На третьем месте довольно-таки нестандартный доклад, у нас редко бывают такие доклады, я крайне рекомендую его посмотреть.
4205.34 4236.78 "Игорь Лабутин" Доклад сам по себе про юнит тестирования, но он такой исследовательский, то есть докладчики проведут вас через некоторое количество задачек и загадок и в конце вы таки узнаете кто же убийца и почему все идет не так, как на самом деле должно идти, а попутно вы конечно узнаете много полезных вещей про то, как работать с моками, с тестовыми фреймворками, как работать с рефлекшеном правильно, создавать динамические прокси и так далее.
4236.78 4245.66 "Игорь Лабутин" Так что разумная доля практичности смешанная с прекрасным повествованием и постановкой этого доклада.
4245.66 4264.50 "Анатолий Кулаков" Еще хочется отметить про доклад Тайный динамический сборок в том, что это лучший дебют данной конференции, то есть ребята первый раз выступали на такой большой конференции и добрались прямо сразу до третьего места перешагнув там таких больших мастодонтов и гигантов, за что им конечно отдельный респект.
4264.50 4272.30 "Анатолий Кулаков" На втором месте у нас разместился Орн Йени, также известный в миру как Айенди, также известный в миру как автор RavenDB.
4272.30 4313.90 "Анатолий Кулаков" RavenDB это наверное самая популярная open source база данных, которая написана на C# и именно про это он и рассказал в своем докладе, то есть он рассказал что же внутри творится в этих страшных приложениях, которые называются базами данных, что они делают, как они работают, что такое индексы, глубоко шагнул в би-деревья, посмотрел как с ними обращаться, как строятся транзакции, как происходит durability, как происходит отказоустойчивость, какие есть подводные камни у ввода-вывода и прочие прочие вещи с которыми сталкивается типичный разработчик при написании своей собственной базы данных.
4313.90 4342.14 "Анатолий Кулаков" Я надеюсь, что в принципе доклад натолкнет людей на ту мысль, что писать данные на C# и .NET это в принципе хорошо, это здравая идея, этим нужно заниматься и у нас станет больше приложений, которые все-таки работают с данными, работают с какими-то очередями, работают с бигдатой, работают как базы данных и прочее, потому что сейчас нашей инфраструктуре этого очень сильно не хватает и очень-очень даже зря.
4342.14 4346.78 "Анатолий Кулаков" Очень зря разработчики не используют C# для того, чтобы писать такие продукты.
4346.78 4361.22 "Игорь Лабутин" Да, исторически вообще C# разработчики и .NET разработчики очень любят высокопроизводительный код и они особенно любят доклады про производительность на .NEXT, независимо от их практической применимости и это подтверждает этот рейтинг.
4361.22 4380.34 "Игорь Лабутин" На первом месте доклад Стивена Тауба, инженера из компании Microsoft, который работает над рантаймом и доклад называется Unlocking Performance Improvements in .NET, то есть это в некотором смысле доклад, построенный на статье Стивена, похожий на ту, которую мы разбирали сегодня в подкасте, только это было про .NET 5.
4380.34 4398.82 "Игорь Лабутин" Соответственно, если вы хотите вспомнить, что такого интересного было в .NET 5, а также как на самом деле самому прийти и начать что-то делать с перформансом .NET, то Стивен про это тоже упоминает, так что посмотрите, будет интересно и мы ждем похожий доклад про .NET 6, Стивен нам что-нибудь наверняка расскажет.
4398.82 4417.22 "Анатолий Кулаков" Это был топ 10 докладов с конференции .NEXT Питер 2021, также напоминаю, что открыт полный плейлист со всеми докладами, даже если вы что-то не нашли интересного для себя в нашем описании, посмотрите на другие доклады, они тоже довольно-таки достойные и наверняка найдете что-нибудь интересное.
4417.22 4468.06 "Анатолий Кулаков" В принципе конференция .NEXT не спит, она уже готовит новый сезон и программа практически уже опубликована, он практически готов, стартует он совсем скоро, этой осенью будет .NEXT 2021 Москва и там примут участие тоже такие знаменитые люди, как мы сегодня упоминали, это Стефен Тао, Паурен Иени, Скотт Влашин, который у нас был многократно на прошлых конференциях, Стэн Драбкин, Стас Сидористы, никуда от нас не денется, к ним присоединится Дмитрий Иванов, Егор Богатов, Сергей Тепляков и много-много других интересных спикеров, с которыми можно будет не только послушать их доклады, но и пообщаться после докладов, задать личные вопросы и обсудить их работу, их проекты и что они думают по той или иной теме.
4468.06 4469.82 "Анатолий Кулаков" Вот это всегда очень дорогого стоит.
4469.82 4484.02 "Анатолий Кулаков" Конференция пройдет онлайн, если вы еще не купили билет, то специально для слушателей нашего подкаста у нас есть промокод, поэтому заходите в описание к выпуску, ищите промокод и подключайтесь к конференции, она уже будет совсем скоро.
4484.02 4489.30 "Игорь Лабутин" Ну что, нам на сегодня надо завершаться или у нас есть еще что обсудить?
4489.30 4506.38 "Анатолий Кулаков" Практически есть, я хотел ставить нашу любимую рубрику про подслушано, где мы делимся с вами теми ресурсами, которые подслушали в других местах, но на этой неделе у меня получилась рубрика всего-навсего из одного подкаста, но зато какого?
4506.38 4513.26 "Анатолий Кулаков" Большого, красивого и интересного, поэтому я выкинул рубрику и выделил этот подкаст просто в отдельную тему.
4513.26 4516.42 "Анатолий Кулаков" Хотелось бы вам сегодня рассказать про подкаст "Читаем вместе".
4516.42 4529.30 "Анатолий Кулаков" Накнулся я на него практически случайно, этот подкаст более известен в кругу архитекторов, потому что он в принципе про архитектуру и именно голосами и мыслями архитекторов.
4529.30 4542.38 "Анатолий Кулаков" Мне кажется, даже если разработчик не стремится стать архитектором, то ему очень полезно понимать, о чем они думают, каким образом они общаются, какие темы обсуждают и именно такое понимание дается как раз в этом подкасте.
4542.38 4545.18 "Анатолий Кулаков" Здесь ребята собираются и обсуждают книгу.
4545.18 4562.06 "Анатолий Кулаков" Книгу по архитектуре, деля каждый выпуск по какой-то главе и подробно разбираю те же подходы, которые пропагандирует автор и параллельно делясь своим богатым опытом, обсуждая, прав автор или не прав, какие бы подходы они сами использовали, какие бы нет.
4562.06 4578.10 "Анатолий Кулаков" Данный подкаст в принципе никак не зависит от языка, но очень четко прослеживается, что ребята знакомы с .NET, потому что когда общаешься с людьми из другого языка, им при сервере приходится объяснять такие термины как DDD, SecureOS, Event Sourcing.
4578.10 4587.78 "Анатолий Кулаков" Очень хорошо, что .NET впереди планеты всей по этой терминологии и в принципе видно, что когда они объясняют эти шаблоны, они не делают каких-то определенных акцентов.
4587.78 4597.38 "Анатолий Кулаков" Это их выдает, потому что на самом деле на работе они плотно общаются с .NETчиками и поэтому .NETчикам случайно слушать их одно удовольствие.
4597.38 4612.26 "Анатолий Кулаков" Я долго привыкал, что они иногда спорят с друг другом, то есть не выдают нам какую-то одну стратегию, какую-то одну правильную мысль о том, как надо жить, а именно не договариваются с автором и пытаются вести какие-то дискуссии с разных сторон.
4612.26 4627.90 "Анатолий Кулаков" Но в конце концов мне это очень понравилось, потому что данный подход дает возможность посмотреть как раз-таки на проблему с разных сторон и увидеть даже те вещи, которые в принципе изначально не автор, не может быть даже те люди, которые обсуждают изначально могли не заметить.
4627.90 4638.10 "Анатолий Кулаков" И поэтому я рекомендую всем, кому интересна архитектура, кто хочет немножко приобщиться к архитекторам, попробовать послушать несколько первых эпизодов и понять.
4638.10 4641.66 "Анатолий Кулаков" Если вам интересно, то присоединится к постоянным слушателям.
4641.66 4649.66 "Анатолий Кулаков" У ребят как раз сейчас заканчивается первый сезон, то есть они практически дочитали книгу и скоро уже начнется следующий сезон, новая книга.
4649.66 4655.18 "Анатолий Кулаков" И пользуясь случаем, я пригласил к нам в гости одного из авторов этого подкаста, Евгения Биккинина.
4655.18 4656.18 "Анатолий Кулаков" Привет, Евгений!
4656.18 4657.18 "Анатолий Кулаков" Привет, Толь!
4657.18 4667.98 "Анатолий Кулаков" Когда я начинал слушать ваш подкаст, мне немножко не хватило какого-то вводного выпуска, чтобы понять, кто вы такие, что вас заботит и почему вы вообще взялись за это нелегкое дело.
4667.98 4671.10 "Анатолий Кулаков" Давай тогда немножко попробуем вот эту тему и приоткрыть.
4671.10 4675.94 "Анатолий Кулаков" Расскажи для начала, кто такие ведущие, как вы друг друга нашли, как вы вообще собрались?
4675.94 4692.30 "Евгений Биккинин" Я тебя, может быть, поправлю, у нас есть небольшое интро, нулевое, которое длится буквально минут пять, может быть, ты его просто пропустил, но как бы там не особо может быть афишируется, где мы примерно рассказываем, зачем мы это делаем и, ну, в общем, какую-то небольшую предысторию.
4692.30 4754.86 "Евгений Биккинин" Но давай я еще раз озвучу, значит, собственно, у нас ведущие, у нас как бы разное количество человек, каждый раз три записываются, это текущие и бывшие сотрудники ДОДА, да, вот как бы откуда все пошло, мы реально на работе у себя, там, каждую пятницу собирались таким небольшим, ну, как можно сказать, клубом и обсуждали книжку, которую читали в течение какого-то времени, да, вот мы каждую пятницу, каждый из нас прочитывал там по одной-две главы, насколько мы договаривались, и потом мы, собственно говоря, читали ее, разбирали именно для как бы ширинга знаний, да, для поддержания какого-то контекста, и это действительно было больше, ну, не просто обсуждение, а вот как бы прояснение неясных моментов, то, что там нашел интересного, ну, вот каждый, значит, читая что-то свое, да, он находит то, что, возможно, пропустили другие, то есть это реально достаточно, ну, как бы читать в коллективе полезнее во многом, чем читать одному, вот.
4754.86 4757.14 "Анатолий Кулаков" Да, действительно полезная практика.
4757.14 4761.54 "Анатолий Кулаков" Может, ты прав, может, я пропустил как-то этот эпизод, потому что больше старался вникнуть в главы.
4761.54 4768.14 "Анатолий Кулаков" Скажи вас, вот обычно на таких посиделках много ли людей собиралось, насколько это интересная активность?
4768.14 4789.26 "Евгений Биккинин" Ну, большое количество человек, тоже слишком много, тоже плохо, поэтому у нас где-то обычно человек там, ну, не знаю, в среднем 8, там, да, от 5 до 10, но в среднем, я думаю, 8 человек, кто-то обсуждает активно, кто-то пропустил этот раз, он просто как бы слушает, да, и там может быть какие-то вопросы добавить нас дают, ну, в общем, вот как-то вот так.
4789.26 4795.38 "Анатолий Кулаков" И почему вот эта активность решила вылиться в какой-то подкаст или, может быть, вы обсуждали другие форматы, почему решили записываться?
4795.70 4798.10 "Евгений Биккинин" Ну, это тоже довольно забавно получилось.
4798.10 4826.58 "Евгений Биккинин" Один из вот наших членов клуба, да, вот он в тот момент, как бы в один из моментов он не смог присутствовать, и он просил нас прозаписать встречу, да, вот нашу обычную, как бы, да, мы ему записали, скинули ссылку, и потом он там то ли в зале был, то ли еще там домой ехал и слушал, и как бы вроде все понятно, и как будто ты даже поучаствовал, ничего не пропустил, и вот это был Юрий Пастушенко, и ему это понравилось, и он предложил, собственно, давайте мы это сделаем как бы для всех, да.
4826.58 4833.42 "Анатолий Кулаков" Отличная идея, действительно, зачем остальным людям тоже это пропускать, когда они могут все это послушать?
4833.42 4839.42 "Анатолий Кулаков" Скажи, а как была сделана выбор книги, то есть почему выбрали именно эту книгу для первого сезона?
4839.42 4874.82 "Евгений Биккинин" Ну, эту книгу мы предварительно перед этим прочитали, собственно, вот внутри нашего клуба, и выбрали ее во многом, потому что, ну, скажем так, про эту книгу достаточно легко говорить, накидывая какие-то, да, там, примеры из собственной жизни, из предыдущих, там, практики, и она во многом не требует каких-то вот, ну, конечно, она подходит для аудиоформата, потому что вот сейчас мы решаем, что записывать в следующем, нам предлагают Клепмана, и, если честно, Клепмана я вообще не представляю, как можно в аудиоформате рассказывать все эти диаграммы, какие там события приходят первыми, как разрешать консенсус, да.
4874.82 4883.18 "Евгений Биккинин" В случае вот с архитектурой, в принципе, достаточно легко можно именно это в аудиоформат вынести, мне кажется, достаточно понятно при прослушивании.
4883.18 4890.06 "Анатолий Кулаков" Да, я с тобой полностью согласен, что тут книгу именно нужно все-таки выбирать под формат, несмотря на то, что Клепман прекрасен.
4890.06 4903.18 "Анатолий Кулаков" Мне кажется, другой лидер вам подходит намного больше, это как раз-таки Уди Дахан, и я за него лично голосовал, поэтому надеюсь, что он выиграет, и как бы на следующем сезоне мы увидим разбор его с шикарной, с шикарнейших лекцией.
4903.18 4912.90 "Евгений Биккинин" А, кстати, Дахана мы тоже, да, вот в своем внутреннем клубе как раз разбирали прошлым летом, а сейчас планируем почитать Database Internal с Алексея Петрова, но это так.
4912.90 4915.34 "Анатолий Кулаков" Да, да, тут тоже хорошая тема.
4915.34 4920.74 "Анатолий Кулаков" Хорошо, спасибо большое, Евгений, спасибо, что присоединился, рассказал про подкаст, и на этом пока.
4920.74 4922.54 "Евгений Биккинин" Спасибо, Толя, пока.
4922.54 4924.50 "Анатолий Кулаков" Отлично, большое спасибо, Женя.
4924.50 4930.98 "Анатолий Кулаков" Я напоминаю, что у нас был в гостях Евгений Бикинин, один из авторов подкаста «Читаем вместе».
4930.98 4939.74 "Анатолий Кулаков" Вот, я всех призываю попробовать послушать, и если вы запишетесь в число постоянных слушателей, передавайте привет от нашего
4939.74 4946.52 "Игорь Лабутин" подкаста. Ну а на этом теперь мы уже точно будем завершать наш подкаст, и давайте вспомним, что мы обсудили.
4946.52 4963.42 "Игорь Лабутин" Мы поговорили про то, какие performance improvements произошли в 6-м тотнете, огромнейшая статья, сотни pull-requests, и десятки или даже тоже сотни бенчмарков, почитайте, если вам интересно и вы неравнодушны к перформансу в 6-м тотнете.
4963.42 4969.02 "Игорь Лабутин" Вспомнили, что же такое делегаты в C#, лямпты, анонимные лямпты и вот это все.
4969.02 4971.98 "Игорь Лабутин" Посмотрели, когда может на них потратиться память.
4971.98 4979.94 "Игорь Лабутин" Узнали, что нового завезли в File.io в 6-м тотнете, и как теперь поменялся файл стрима сопутствующей классы.
4979.94 4987.66 "Игорь Лабутин" Поговорили про roadmap решарпера и райдера 2021.3, довольно много интересных фич ждем, когда выйдет.
4987.66 4995.34 "Игорь Лабутин" В студии 2022 новостей пока мало, но тем не менее пара небольших фич была упомянута.
4995.34 5005.58 "Игорь Лабутин" Подробнейшим образом обсудили топ-10 питерского .next 2021 и соответственно полностью открытого плейлиста конференции.
5005.58 5017.78 "Игорь Лабутин" Ну и узнали про еще один новый подкаст, так что будет здорово, если будем обмениваться информацией, пишите нам интересные, если вы что-то слушаете интересное для тотнетчиков, нам будет интересно узнать про это
5017.78 5023.42 "Анатолий Кулаков" тоже. На этом все, с вами был Анатолий Кулаков и Игорь Лабутин, всем пока.
5023.42 5024.42 "Анатолий Кулаков" До новых встреч, пока.
