0.00 12.00 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер 50.
12.00 15.08 "Анатолий Кулаков" И сегодня в студии с вами будут Анатолий Кулаков
15.08 16.08 "Игорь Лабутин" и Игорь Лобутин.
16.08 20.36 "Анатолий Кулаков" Привет. Прежде всего хотелось бы поблагодарить наших постоянных спонсоров.
20.36 25.68 "Анатолий Кулаков" Это Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья, Гурий Самарин.
25.68 37.84 "Анатолий Кулаков" Спасибо большое, друзья, вы нам очень сильно помогаете в России и в частности вы нам помогаете переживать очень странные и непростые события, которые произошли с нами буквально после предыдущего выпуска.
37.84 48.44 "Анатолий Кулаков" А случилось то, что Ankor, наш хостинг, любимый, который все это время поддерживал нас, решил заблокировать наш подкаст по национальному признаку.
48.44 65.88 "Анатолий Кулаков" И соответственно мы срочно начали переводить все свои подписки, буквально вот там он нам дал два дня выходных на переезд, поэтому переносили все свои подписки в срочную порядке на другой хостинг и пытались срочно изменить всякие РСС-фиды, чтобы пострадало как можно меньше наших слушателей.
65.88 80.00 "Анатолий Кулаков" И судя по всему, пострадало не так уж много, то есть для большинства из вас ничего не должно было поменяться, но хотелось бы, чтобы те, кто пострадали, они тоже как-то нашли нас на новом хостинге, на новом сервисе.
80.00 97.32 "Анатолий Кулаков" И поэтому как рекомендация, то есть наверное просьба как всегда, расшатите нас среди своих друзей, расскажите о нас и если вдруг кто-то не может получить от нас новые выпуски, то посоветуйте им переподписаться снова на наш РСС-фид, на уже новый.
97.32 104.72 "Анатолий Кулаков" Мы переехали на сервис Mave, который приютил огромное число подкастов, которые там массово мигрировали с Ankar.
104.72 110.32 "Анатолий Кулаков" И сервис шикарный, он точно так же бесплатный, как и был Ankar.
110.32 118.24 "Анатолий Кулаков" У него куча интересных статистики, у него шикарный интерфейс, в общем по всем параметрам Ankar сильно перегоняет.
118.24 124.08 "Анатолий Кулаков" Поэтому если вы вдруг решите делать подкасты, то вот вам новая рекомендация обалденная, это сервис Mave.
124.08 127.28 "Анатолий Кулаков" Вот мы его освоили, посмотрели и нам до сих пор все нравится.
127.28 132.24 "Анатолий Кулаков" И с того, что собственно произошло.
132.24 147.84 "Анатолий Кулаков" Соответственно старый РСС-фид был заблокирован у всех российских пользователей, а это в свою очередь значит, что заблокированы абсолютно все подкаст-платформы, потому что все подкаст-платформы пользовались единственным РСС-фидом, вот этим анкаровским уникальным.
147.84 158.52 "Анатолий Кулаков" То есть например, если вы слушали нас через Apple Music, через Google, через Castbox, еще через любые другие там плееры, любые другие площадки, то вы могли бы пострадать.
158.52 164.00 "Анатолий Кулаков" Вот насколько я ручками проверил все площадки, большинство из них успело переехать, но к сожалению не все.
164.00 171.36 "Анатолий Кулаков" Ну и в частности те, кто слушал нас непосредственно на Ankar, а такие люди судя по статистике были, вот они точно нас больше никогда не услышат.
171.36 180.52 "Анатолий Кулаков" Вот хотелось бы, чтобы к ним дошла информация, и они каким-то образом все-таки услышали нас и переподписались на новый фид.
180.52 192.24 "Анатолий Кулаков" Легче всего нас всегда находить в таких критичных ситуациях, это по нашему адресу, который надеюсь мы все-таки сможем содержать в стабильности, это radio.dotnet.ru.
192.24 198.84 "Анатолий Кулаков" Этот адрес мы уже перевели на новый сайт, на новый хостинг, кстати можете зайти посмотреть, насколько интерфейс там действительно прекрасен.
198.84 206.24 "Анатолий Кулаков" И соответственно там же есть подписка на новый RSS, можно, как я уже говорил, переподписаться.
206.24 215.88 "Анатолий Кулаков" И самый надежный способ, наверное, это все-таки запомнить этот адрес, его в ближайшее время не должны бы заблокировать, по крайней мере мы будем стараться так сделать, чтобы этого не произошло.
215.88 225.84 "Анатолий Кулаков" Ну и соответственно те люди, которые слушали нас на ютубе, тоже у нас очень большая аудитория слушает на ютубе, те совсем пока никак не пострадали, но на будущее имейте ввиду.
225.84 229.20 "Анатолий Кулаков" В общем адрес на всякий случай запомните, еще пригодится.
229.20 238.60 "Анатолий Кулаков" Наверное, это все, что касается нашего нового хостинга, ну у нас плохие новости кончились, но у нас накопилось очень много хороших.
238.60 245.60 "Анатолий Кулаков" Еще до основного выпуска по инфраструктурной части мы еще записали шикарный выпуск пришел.
245.60 256.52 "Анатолий Кулаков" У нас есть, соответственно, чатик для патронов, мы в этом чатике для патронов выкладываем те эпизоды, те кусочки, которые не вошли в основной выпуск и часто записываем какие-то интересные темы.
256.52 261.12 "Анатолий Кулаков" И наиболее интересные, и самые лучшие из этих тем мы выкладываем в публичный доступ.
261.12 265.48 "Анатолий Кулаков" И вот такой же в публичный доступ выпуск мы выложили про крипту.
265.48 272.84 "Анатолий Кулаков" Соответственно, наша цель была выяснить, каким образом можно теперь собирать донаты с крипты.
272.84 283.52 "Анатолий Кулаков" Соответственно, потому что патреон нас заблокировал, на патреоне нам теперь донатить практически нельзя, но бусти все еще позволяет, на бусти все донатится, все переехали туда и мы в принципе все счастливы.
283.52 292.04 "Анатолий Кулаков" Но хотелось бы каких-нибудь альтернативных средств, и вот мы решили обратить наше внимание на крипту, на блокчейн и прочие другие страны слова.
292.04 325.36 "Анатолий Кулаков" Вот позвали в гости большого-большого специалиста по этой теме и проспрашивали его на часик о том, что такое вообще блокчейн, каким образом он связан с деньгами, что такое кошелек, какой бывает софт, что делают биржи, действительно ли там есть анонимность и прочие такие интересные вещи, которые как бы база для людей, которые никогда не сталкивались напрямую с блокчейном и криптой и хотели бы просто от программиста к программистам услышать, что это такое, как это работает и может быть даже попробовать.
325.36 337.32 "Анатолий Кулаков" Вот соответственно заходите на наш сайт на бусти и там этот выпуск за кулисией сейчас выложен, вот слушайте его на здоровье, открыто, бесплатно, без смс.
337.32 405.48 "Анатолий Кулаков" Еще одна интересная инфраструктурная новость, конференция .NEXT, объявила, что наконец-то после более двух лет по-моему онлайна она сделает офлайн день, но с этим офлайн днем еще будет онлайн часть и соответственно отдельно будет офлайн, который будет проходить в Питере, все это будет прекрасными летними белыми ночами под фонтаны Петергофа и разводные мосты, поэтому милости просим всех тех, кто соскучился по нетворкингу, обнимашкам, коммуникашкам и вообще увидится, посмотрите на хорошие докладчики, на хорошие доклады и просто пообщаться, вот милости просим на конференцию .NEXT и у нас для специально для нашего радио и для Дотнетру сообщества в целом есть промокод, вот промокод вы найдете в описаниях к данному выпуску и соответственно вам по этому промокоду будет доступна скидка на персональный билет, поэтому если вы еще не приобрели билет и задумываетесь посетить это знаменательное мероприятие, то заходите, смотрите, покупайте, вводите наши промокодики.
405.48 409.92 "Анатолий Кулаков" Ну что ж, Игорь, на этом по-моему все, можно уже начинать темки.
409.92 420.16 "Игорь Лабутин" Да, давай пойдем по темкам, тем более, что у нас появилось несколько превьюшек, которые было бы неплохо посмотреть и узнать, что же в них новенького вышло.
420.16 427.64 "Игорь Лабутин" Начнем мы традиционно с самого Дотнета, вышел превью 3, в котором есть некоторые интересные штуки.
427.64 447.12 "Игорь Лабутин" Самый большой раздел в статье о новом Дотнет превью 3 это про native out или ahead of time compilation на самом деле, но его сейчас просто называют native out и именно под таким названием мы его будем дальше называть, я думаю, что он будет появляться примерно во всех статьях именно в таком названии.
447.12 448.12 "Игорь Лабутин" О чем вообще речь?
448.12 452.00 "Игорь Лабутин" В принципе эта штука всякая, почему она ahead of time?
452.00 458.68 "Игорь Лабутин" Это значит, что код генерируется, исполнимый нормальный код генерируется во время сборки вашего приложения, а не во время рантайма.
458.68 472.80 "Игорь Лабутин" Ну в рантайме у нас есть JIT, как известно, который IL-код, байт-код наш, переделывает в код той платформы, на которой запускается собственно Дотнет, но это накладывает некоторые ограничения.
472.80 493.36 "Игорь Лабутин" Во-первых, это занимает некоторое время, то есть когда вы стартуете свое приложение, JIT-у надо некоторое время, чтобы собственно сджитить весь тот код, который вы написали, а во-вторых, на некоторых платформах, например, IOS, там нельзя джитить, то есть вы там не можете имитировать в рантайме код, который тут же будете исполнять, поэтому там все должно быть скомпилировано заранее.
493.36 507.32 "Игорь Лабутин" В принципе сейчас в Дотнете была технология, и есть до сих пор технология под названием Ready to Run, которая позволяет сделать нечто похожее, то есть она подготавливает код к запуску и предкомпилирует кусочки какие-то.
507.32 512.60 "Игорь Лабутин" Вот есть еще Mono AOT для мобильников и для WebAssembly.
512.60 520.72 "Игорь Лабутин" Теперь соответственно появился Native AOT, это полная нативная предкомпиляция для десктопов, в том числе и для серверного кода.
520.72 522.48 "Игорь Лабутин" Что позволяет AOT?
522.48 537.72 "Игорь Лабутин" AOT позволяет уменьшить время стартапа вашего приложения, что может быть очень важно, например, для каких-нибудь маленьких тулов, и, как я сказал, добиться того, чтобы ваш код можно было запускать в принципе на время, которые не допускают JIT.
537.72 562.64 "Игорь Лабутин" Native AOT написан таким образом, что он продюсит только нативные артефакты, то есть если мы говорим про Ready to Run, то Ready to Run, если я правильно помню, он одновременно с вашей Managed сборкой положит рядышком специальную нативную сборку, которая будет использоваться, но если нужно что-то докомпилировать, например, из Managed сборки, то он возьмет Managed сборку и она будет нормально JIT обрабатываться.
562.64 564.12 "Игорь Лабутин" Native AOT делает другое.
564.12 580.04 "Игорь Лабутин" Native AOT генерирует только нативные артефакты, в нем даже нет никаких следов Managed Assembly, и вот этот вот runtime для Native AOT не умеет даже читать Managed Assembly, как написано в статье, то есть у него нет логики прочитать другую лирику, например, на .NET написан плагин какой-нибудь.
580.04 587.44 "Игорь Лабутин" И из-за этого возникает еще одно преимущество, на диске это все дело занимает меньше места, потому что вам не нужно тащить Managed в кусочек кода.
587.44 602.48 "Игорь Лабутин" В принципе, как говорят авторы статьи, это все очень похоже на то, как собственно компилируется Go, Rust, Swift, то есть вы можете скомпилировать Rust платформину в любую платформу, которая поддерживает .NET, и при этом получить довольно маленький компактный исходник, который будет быстро запускаться.
602.48 610.84 "Игорь Лабутин" Таким образом .NET может посоревноваться теперь с каким-нибудь Go в области таких небольших тулов полезных.
610.84 634.96 "Игорь Лабутин" И естественно это все идет не без каких-то ограничений, для того чтобы ваш код можно было скомпилировать таким образом в Native AOT, у него есть некоторое количество ограничений, и они довольно-таки строгие, то есть вы не можете использовать Reflection Emit, естественно, то есть в рантайме никакой коды генерации, и вы не можете загружать сборки в рантайме, то есть никаких плагинов в вашем коде быть не должно.
634.96 644.32 "Игорь Лабутин" То есть в принципе ограничения может быть и не такие строгие для большинства программ, но все равно некоторую предварительную подготовку сделать придется.
644.32 648.92 "Игорь Лабутин" Во-первых, вам нужно использовать .NET 7, очевидным образом.
648.92 657.00 "Игорь Лабутин" Сейчас для .NET 7 основная цель команды это сделать, чтобы это все работало хорошо и здорово для консольных приложений и для библиотечек.
657.00 667.80 "Игорь Лабутин" И что вам нужно делать, вам нужно взять сначала и применить все рекомендации, которые Microsoft приводит для того, чтобы подготовить вашу библиотеку или приложение для тримминга.
667.80 677.72 "Игорь Лабутин" Тримминг - это штука, которая позволяет вам из менедж-кода выкинуть все лишнее, то есть не тащить целиком менедж-дрельку, а из нее оставить только нужные, используемые вам вашим кодом кусочки.
677.72 686.96 "Игорь Лабутин" Вот сначала нужно применить все рекомендации по подготовке к триммингу, потом еще дополнительные по подготовке к native LTE, и тогда дальше уже пытаться все это компилировать.
686.96 689.40 "Игорь Лабутин" Это все только-только вышло в превью.
689.40 697.92 "Игорь Лабутин" У этого проекта длинная история, но его затащили в превью уже, и будут за ним следить и смотреть, как будет дальше развиваться дело.
697.92 702.88 "Игорь Лабутин" Второй большой раздел про .NET - это Observability.
702.88 709.80 "Игорь Лабутин" Мы очень много в этом подкасте говорили про поддержку в OpenTelemetry, и вот очередной виток, так сказать, в поддержке.
709.80 716.80 "Игорь Лабутин" В OpenTelemetry завезли некоторое количество новых пропозлов, и .NET команда 2 или 3 из них поддержала уже.
716.80 723.64 "Игорь Лабутин" Так что если вы следите и как-то используете OpenTelemetry, посмотрите внимательно на новый превью, там, возможно, завезли что-то полезное.
723.64 741.72 "Игорь Лабутин" Дальше есть некоторое количество улучшений про код-ген и startup-time improvement со всякими макоясными штуками типа write-xore-execute, ту штуку, про которую мы довольно много говорили, которая требуется для исполнения на платформе M1, на процессорах M1.
741.72 750.00 "Игорь Лабутин" И в .NET завезли регионы для сборки мусора, про которые мы подробнейшим образом рассказывали в одном из прошлых подкастов, в статье от Maoni.
750.00 753.12 "Игорь Лабутин" Теперь это включено, это есть в превью 3, так что ставьте, пробуйте.
753.12 759.84 "Игорь Лабутин" В IspandCore тоже появилось некоторое количество улучшений и новинок.
759.84 768.60 "Игорь Лабутин" Во-первых, если вы по какой-то причине пользуетесь, например, minimal APIs, то у вас появилась возможность добавлять фильтры.
768.60 786.32 "Игорь Лабутин" Фильтры - это штука, которая в некотором роде похожа на middleware, то есть это тоже некоторая лямбда, которая принимает контекст запроса, и next, то есть лямбду, при выполнении которой выполнится, собственно, основное тело вашего мини-контроллера или minimal API-хендлера.
786.32 799.60 "Игорь Лабутин" И вы можете, соответственно, эти фильтры навешивать на ваши minimal API-эндпойнты, то есть если вы пишете app.map_get и дальше лямбду, дальше вы можете написать .add_filter, передать туда лямбду, и все будет замечательно.
799.60 813.32 "Игорь Лабутин" Либо вы можете написать класс, который заимплеменит новый интерфейс, iRouteHandlerFilter, и просто тогда используете .add_filter и указываете имя вашего класса в generic, соответственно, скобочках, и тоже все будет работать.
813.32 826.20 "Игорь Лабутин" Позволяет вам, соответственно, написать некоторый код, который может выполниться либо до-после выполнения основного метода minimal API, либо вообще перехватить управление и не дать ему выполняться по каким-то причинам.
826.20 832.52 "Игорь Лабутин" Соответственно, вы можете это делать middleware, вы можете это делать не middleware, а внутри вот таким вот фильтром.
832.52 846.08 "Игорь Лабутин" Разница в том, что middleware будет выполняться, понятное дело, для всех, ну, в зависимости от того, как у вас там развешены условия визжения по маршрутам, в раутам, а фильтры будут выполняться только для тех endpoints, на которые вы их навесили.
846.08 860.56 "Игорь Лабутин" Дальше, если вы пользуетесь minimal API, то улучшили возможность юнит-тестов для них, там некоторое количество внутренних классов выставили в паблик, чтобы их можно было использовать в юнит-тестах и проверять, что там возвращается.
860.56 873.28 "Игорь Лабутин" Если вы пользуетесь MVC или API-контроллерами, то есть речь идет уже не только о minimal API, а вообще о любом любых контроллерах, то теперь улучшилась возможность байндинга параметров.
873.28 874.84 "Игорь Лабутин" Что теперь делается?
874.84 890.36 "Игорь Лабутин" То есть если… Одна из штук, которую framework делает при попытке байндинга параметров, это он смотрит на ваш класс попытки поиска метода под названием, точнее, сигнатурой public static bool try_parse, дальше string_value и out_result типа t.
890.36 902.84 "Игорь Лабутин" Если он таковой находит, ну, есть еще один вариант с ifrmat_provider, то именно такой метод будет использован для попытки распарсить строковое значение из урла или еще откуда-то в значение вашего типа.
902.84 905.48 "Игорь Лабутин" Если вернется true, то отлично, байндинг прошел успешно.
905.48 908.00 "Игорь Лабутин" Если false, то значит байндинг не прошел успешно.
908.00 911.92 "Игорь Лабутин" Так что можете теперь байндить какие-то очень сложные ваши постольные типы к обычным строчкам.
911.92 920.24 "Анатолий Кулаков" Ну, мне кажется, отличный паттерн, при том много встроенных типов его уже поддерживают, такие как, допустим, Intiguid и прочие вот эти люди.
920.24 922.72 "Анатолий Кулаков" Для кастомных классов прям прекрасно.
922.72 942.68 "Игорь Лабутин" Да, ну и главное, он действительно очень похож на то, что вы видите в стандартных даблах и прочих, и это прям очень здорово, что никакого нового интерфейса либо какого-нибудь хитрого соглашения не добавили, просто сделали обычный стандартный трипарт, который может быть полезен в том числе для вашего обычного кода за чем-то в тестах.
942.68 943.68 "Игорь Лабутин" Дальше.
943.68 960.56 "Игорь Лабутин" Есть некоторое количество кейсов, когда вам нужно, например, в контроллере, получив какой-нибудь стрим откуда-то, либо из другого HTTP вызова, либо, не знаю, из базы данных, какой-нибудь там blob откуда-то взяв, вам нужно его просто застримить в качестве результата.
960.56 974.44 "Игорь Лабутин" Теперь у вас есть некоторое количество новых оверлоудов у класса Results, то есть можно теперь сказать returnResults.stream и передав туда этот стрим, и он, соответственно, будет стримить его по мере того, как будто это ваш результат.
974.44 983.52 "Игорь Лабутин" Вот, то есть не будет ничего буферизироваться полностью на вашей стороне, а стрим прям будет качаться из того HTTP клиента в ваш HTTP ответ.
983.52 984.52 "Игорь Лабутин" Прям здорово.
984.52 1007.48 "Игорь Лабутин" В HTTP/2 завезли некоторое количество перформансов, улучшений, там процентов на 10 повысилась производительность в определенных сценариях, и если вы используете .NET Monitor и прочие связанные с этим ивенты, то появился новый ивент, назовем его Server Ready в namespace Microsoft S/P Core Hosting, который эмитится, когда ваше приложение полностью стартовано.
1007.48 1010.28 "Игорь Лабутин" То есть когда вы полностью стартовали, теперь есть сервер Ready Event.
1010.28 1018.76 "Игорь Лабутин" Можно по нему смотреть, например, на время старта приложения и как-то по этому строить какие-то метрики и что-то замечать, либо на его основании как-то реагировать и что-то делать.
1018.76 1021.56 "Игорь Лабутин" Запускать, например, что-нибудь другое.
1021.56 1026.48 "Игорь Лабутин" И последнее изменение в S/P на Core - это Developer Exception Page теперь поддерживает Dark Mode.
1026.48 1027.48 "Игорь Лабутин" Как обычно.
1027.48 1028.92 "Игорь Лабутин" Мне странно, что его не поставили первым.
1028.92 1031.88 "Игорь Лабутин" Как обычно Visual Studio ставит иконочки, но тем не менее тоже важно.
1031.88 1035.56 "Игорь Лабутин" Теперь будет поддерживать правильный Dark Mode.
1035.56 1039.72 "Игорь Лабутин" В этот раз есть статья от команды EF Core.
1039.72 1041.28 "Игорь Лабутин" Давно от них не было никаких апдейтов.
1041.28 1042.64 "Игорь Лабутин" Вернее, не так.
1042.64 1055.48 "Игорь Лабутин" Обычно команда EF Core стабильно раз в две недели выкладывает Bi-Weekly Update, где аккуратненько расписывает линки на все иши, которые они пофиксили, иногда сопровождая их каким-то чуть более длинным текстом.
1055.48 1058.84 "Игорь Лабутин" Но вот такой отдельный прям статик превью давно от них не было.
1058.84 1059.84 "Игорь Лабутин" Сейчас есть.
1059.84 1063.16 "Игорь Лабутин" И там есть два больших улучшения.
1063.16 1071.28 "Игорь Лабутин" Во-первых, добавили некоторые улучшения в Update Pipeline, то есть в той части, которая использует Insert, Update и Delete.
1071.28 1077.20 "Игорь Лабутин" Там есть ряд улучшений, поэтому если вы используете EF Core для этих операций, то посмотрите.
1077.20 1084.16 "Игорь Лабутин" Возможно, это как-то вас заденет и затронет, в хорошем или плохом смысле, в зависимости от того, как вы использовали.
1084.16 1090.80 "Игорь Лабутин" И второе изменение - это они назвали Take Control of your DB Context.
1090.80 1093.20 "Игорь Лабутин" То есть что вы теперь можете сделать?
1093.20 1107.76 "Игорь Лабутин" Entity Framework, когда он строит классы по базе, то есть когда вы делаете Database First, то он проанализирует вашу базу и генерирует классы, структуру которых определяет он сам.
1107.76 1115.28 "Игорь Лабутин" Название можно чуть-чуть комментировать, использовать единственное число, множественное число, как линки указывать.
1115.28 1120.96 "Игорь Лабутин" Но в целом контролировать то, какие классы создаются, как раньше, было не очень сильно можно.
1120.96 1133.04 "Игорь Лабутин" Теперь есть возможность это кастомизировать, я так понимаю, максимально глубоко, потому что если вы в определенную папочку положите t4 template, то EF Core будет использовать именно его для генерации.
1133.04 1141.88 "Игорь Лабутин" Так что теперь, по идее, вы можете генерировать вообще практически все, что угодно и как вам нужно, создавая DB Context, соответственно.
1141.88 1144.56 "Игорь Лабутин" Вот, это то, что завезли в превью 3.
1144.56 1154.12 "Игорь Лабутин" Не сказать, что прям супер много и не какие-то там такие знаковые штуки, но тем не менее, довольно неплохой набор фич, которые интересно посмотреть, пощупать.
1154.12 1166.12 "Анатолий Кулаков" Так, ну и не отходя далеко от Микрософта и его новинок, заанонсирована такая интересная штука, как центральный менеджер пакетов, центральное управление пакетами.
1166.12 1169.36 "Анатолий Кулаков" Вот когда ты слышишь такое громкое название, ты вот что себе представляешь?
1169.36 1178.52 "Игорь Лабутин" Что у нас будет какой-нибудь единый файл, где нужно будет указать все версии всех пакетов, а внутри, не знаю, solution, folder, еще чего-то.
1178.52 1182.28 "Игорь Лабутин" А вот как они дальше будут распределяться по проектам, я пока не очень понимаю.
1182.28 1184.32 "Анатолий Кулаков" Не, ну ты как-то не глобально мыслишь.
1184.32 1197.84 "Анатолий Кулаков" Я вот когда название увидел, я сразу подумал, что у нас будет такой интерпрайзный сервачок, который будет управлять всеми зависимости во всех ваших проектах, среди различных репозиторий во всех solutions, поддерживать там их актуально, следить за уязвимостями и прочими вот этими вещами.
1197.84 1200.84 "Анатолий Кулаков" Ну, центральный же, но менеджер, но пакетов же.
1200.84 1203.56 "Анатолий Кулаков" Хотелось что-то такое большое и жирное.
1203.56 1212.56 "Анатолий Кулаков" В общем, но анонс оказался действительно немножко более прозаичным, и давайте, соответственно, поговорим, вспомним и узнаем, а что же это за чудо-то такое.
1212.56 1220.12 "Анатолий Кулаков" Ну и так, постулат довольно прост, что если вы управляете зависимостью в одном проекте, то это довольно легко.
1220.12 1223.28 "Анатолий Кулаков" Прописали пакетик, прописали версию и больше никаких проблем у вас нет.
1223.28 1237.20 "Анатолий Кулаков" Если же в вашем solution находится множество проектов, и у каждого проекта есть свои собственные зависимости, и иногда какие-то зависимости между различными проектами совпадают, но иногда они по версии немножко различаются, вот тут у вас уже начинаются проблемы.
1237.20 1243.24 "Анатолий Кулаков" И решением этих проблем есть много различных костылей.
1243.24 1259.08 "Анатолий Кулаков" Ну вот, компания Microsoft придумала, что теперь можно эти костыли немножко более упорядочить и попытаться решить эту проблему, соединив в едином месте управление всеми версиями для всех ваших проектов внутри solution.
1259.08 1266.00 "Анатолий Кулаков" Итак, давайте вернемся немножко к истории и вспомним, что сейчас на данный момент у нас существует два основных места управления пакетами.
1266.00 1267.80 "Анатолий Кулаков" Мы говорим сейчас про NuGet.
1267.80 1288.32 "Анатолий Кулаков" Во-первых, это файл packages.config, это такой, считается, более-менее устаревший способ, который использовался в предыдущих версиях C#, но в принципе до сих пор поддерживается, до сих пор многие его используют, потому что он помогает выделить непосредственно проекты, описание проектов в отдельный понятный файлик.
1288.32 1297.00 "Анатолий Кулаков" Второй, более современный, по дефолту использующийся во всех последних версиях C#, это новый формат csproj файлов, так сказать.
1297.00 1308.20 "Анатолий Кулаков" И внутри этих csproj файлов хранятся все пакетжи в специальном элементе package-reference, который содержит имя пакета, версию, и вот туда мы их сохраняем, и вот оттуда они берутся.
1308.20 1314.88 "Анатолий Кулаков" Вот, и начиная с ну где-то 6.2, у нас теперь появилась третья возможность управления пакетами.
1314.88 1326.60 "Анатолий Кулаков" Это файлик, специальный файлик, который называется directory.package.props, и внутри этого файлика у нас происходит именно управление версиями.
1326.60 1342.92 "Анатолий Кулаков" Здесь нужно остановиться и уточнить то, что это поддерживается только в самых последних тулзах, например, в Visual Studio, только в 22, 17.2 или позже, в .NET SDK 6.0.300 и, соответственно, в NuGet 6.2.
1342.92 1349.56 "Анатолий Кулаков" То есть, вам нужно хорошенечко обновиться инструменты, если вы хотите такую вещь у себя попробовать.
1349.56 1354.92 "Анатолий Кулаков" Итак, как же внутри вашего Solution разрешить использовать Central Package Manager?
1354.92 1358.84 "Анатолий Кулаков" Прежде всего вам нужно создать файлик, который я уже упоминал, в directory.package.props.
1358.84 1366.84 "Анатолий Кулаков" Этот файлик лучше всего расположить рядом с основным файлом Solution, то есть непосредственно в руте вашего решения.
1366.84 1376.56 "Анатолий Кулаков" Внутри этого файлика, это по сути XML, форматом очень сильно похожим на MSBuild файлик, то есть на ваш CSS-прочт-файл.
1376.56 1388.12 "Анатолий Кулаков" Внутри у него можно расположить элемент, который называется новый элемент package-version, в котором вы указываете имя пакета и непосредственно его версию.
1388.12 1391.60 "Анатолий Кулаков" И чем это отличается от того, что было?
1391.60 1404.44 "Анатолий Кулаков" Отличается это тем, что теперь в непосредственно ваших CSS-прочт-файлах элемент, который вы раньше подключали package-reference, он теперь может содержать просто имя пакета и все, без версии.
1404.44 1410.68 "Анатолий Кулаков" Таким образом, мы приходим к тому, что все версии у нас указываются только в одном единственном файлике для всего Solution.
1410.68 1425.52 "Анатолий Кулаков" То есть, если вы используете в библиотеку NewtonSoft JSON определенной версии 1, то вы эту единичку прописываете в общем файлике, и она у вас будет одинаковой во всех проектах, во всем вашем Сolution.
1425.52 1436.80 "Анатолий Кулаков" Вы никогда не разойдетесь, обновлять ее можно в одном единственном месте, и весь инструментарий это увидит, это подтянет, и в рантайме у вас никаких конфликтов не будет.
1436.80 1439.60 "Анатолий Кулаков" Немножко поговорим про ограничения.
1439.60 1451.60 "Анатолий Кулаков" Ограничения есть, и заключается она в том, что каждый проект может прочитать только один единственный файлик в директоре Package Props.
1451.60 1470.44 "Анатолий Кулаков" Соответственно, если вы этих файликов забросите несколько, их можно положить в каждую папочку, хоть по файлику кладите, то если таких файликов будет несколько, то прочитается самый ближайший к тому проекту, который сейчас пытается найти по иерархии деревьев этот файлик наверх.
1470.44 1475.44 "Анатолий Кулаков" Это одно ограничение, и, соответственно, самое главное.
1475.44 1477.48 "Анатолий Кулаков" Ограничение, про которое стоит сказать.
1477.48 1507.96 "Анатолий Кулаков" Если же вам по какой-то причине нужно, чтобы версии расходились, то есть один проект в вашей системе, который не хочет смотреть на других, самый такой бунтарь, ему можно прописать индивидуальную версию, делать это с помощью специального знакомого атрибута Package Reference, но для того, чтобы это работало, вам необходимо указать и разрешить специальный флажок, который называется Enable Package Version Override.
1507.96 1516.36 "Анатолий Кулаков" Соответственно, если override разрешен, вы можете уже override-ить свои версии, если не разрешен, то вы обязаны брать только из центрального package management файлика.
1516.36 1529.20 "Игорь Лабутин" Тут надо сказать, что на самом деле override по дефолту разрешен, но для того, чтобы он работал в вашем Package Reference в CSS Project нужно указать не version уже атрибут, а version override атрибут.
1529.20 1543.16 "Игорь Лабутин" Насколько я понимаю, если вы укажете version для пакета, который указан в этом directory packages/props, то это будет ошибка компилят, потому что вы пытаетесь указать версию для пакета, который менеджится в центральном месте.
1543.16 1556.24 "Анатолий Кулаков" Да, точно ты прав, атрибут должен теперь называться version override, чтобы явно указать, что вы хотите именно заверядить это, не какая-то ошибка или случайно старый инструмент прописал туда какую-то непонятную циферку.
1556.24 1573.00 "Игорь Лабутин" Ну и, соответственно, можно вообще полностью дизейблить всю эту штуку, задав атрибутик manage package versions centrally в false, не атрибутика, а элемент в вашем CSS Project, либо еще где-то, и тогда никакие вот эти вот directory packages/props не будут использоваться вообще.
1573.00 1580.52 "Игорь Лабутин" Еще есть такая штука, которая задается еще более длинной опцией, называется Central Package Transitive Pinning Enabled.
1580.52 1599.60 "Игорь Лабутин" Ее можно поставить в true, причем ее можно поставить в проекте, в props-ах, в файлике, ну в общем где угодно, где вы можете ставить эти проперти, и тогда эта штука позволяет вам, ну как, транзитивно пиннить ваши пакетики, версии ваших пакетиков.
1599.60 1626.56 "Игорь Лабутин" Я, честно говоря, никогда такой штукой не пользовался, кажется, но я немножко поисследовал вопрос и выяснилось, что по идее функциональность под названием Transitive Pinning — это, как я ее понял, это возможность просто указать версию какой-то из ваших транзитивных зависимостей явно в вашем csproj, например, файле, и именно эта версия будет использоваться для всех ресторов всего дерева зависимостей, даже если где-то по дереву зависимость задана с какой-то другой версией.
1626.56 1627.56 "Игорь Лабутин" Вот.
1627.56 1639.32 "Игорь Лабутин" И казалось бы, зачем вам тогда опция, чтобы это enable, но дело в том, что эта опция работала до версии 5.8 в NuGet включительно, а в версии 5.9 она была выпилена по просьбе, так сказать, заказчиков.
1639.32 1644.52 "Игорь Лабутин" В NuGet-1000 так и написано, по многочисленным просьбам заказчиков давайте мы эту функцию выпилим.
1644.52 1651.24 "Игорь Лабутин" Как только выпилили, дальше появилось много новых issues со словами по многочисленным просьбам заказчиков, давайте-ка мы ее впилим обратно, потому что у нас все сломалось.
1651.24 1652.24 "Игорь Лабутин" Вот.
1652.24 1667.16 "Игорь Лабутин" И в итоге, как видим, компромиссный вариант, в версии 6.2 появилась вот эта вот штука, которая позволяет теперь включить Transitive Pinning для ваших зависимостей, для этого нужно поставить ее явно в true и вернуть себе поведение, которое было в 5.8.
1667.16 1674.28 "Анатолий Кулаков" Отлично, давай теперь порассуждаем, а как эту проблему мы могли решать раньше, до того, как появился Central Package Management.
1674.28 1684.92 "Анатолий Кулаков" То есть, в принципе, ничего нового в этом файлике нет, это обычный MSBuild файл, и раньше его вполне можно было проэмулировать самому.
1684.92 1707.24 "Анатолий Кулаков" Я видел огромное число проектов, особенно вот таких сложных проектов, которые там должны были управлять несколькими различными cssproj файлами, несколькими различными dependents, которые просто-напросто делали отдельный файлик, в котором они как раз-таки обозначали версию пакетов и уже использовали, included файл в обычных cssproj, не указывая там ничего, и точно так же в одном месте меняли версии.
1707.24 1726.80 "Анатолий Кулаков" Если вам такая схема нужна вдруг, или вы почему-то раньше про нее не слышали, и вы находитесь в старых инструментариях, не хотите никогда обновляться, то поищите этот подход, и раньше использовался просто без таких явных названий файлов, и может быть не с таким удобным поддержкой от лузов.
1726.80 1750.16 "Анатолий Кулаков" Потому что в этом случае, если вы руками используете msbuild файлы, которые там откуда-то референсы, в которых вы сами в bc-версии подставляете, вы уже не можете использовать допустим визуальный редактор студии или райдера, чтобы он вам обновил все пакеты, потому что когда он начнет обновлять, он вам испортит cssproj файл, и вам придется все равно идти ручками и переделывать все на ваш странный файлик.
1750.16 1761.92 "Анатолий Кулаков" Основная же фишка вот этого подхода заключается в том, что теперь инструментарии тоже поддерживают все вот эти нововведения, и можно со всех сторон из командной строки обновлять, из visual studio обновлять и так далее.
1761.92 1765.40 "Анатолий Кулаков" Но если для вас это не критично, то это можно было сделать и раньше.
1765.40 1782.16 "Игорь Лабутин" Да, мы использовали ровно такой подход, у нас был и в директоре props, в котором были написаны package_versions всего того, что мы используем, и внутри в cssproj мы на самом деле дублировали эти package_references, несмотря на то, что include как бы есть, мы явно прописывали все равно package_references, но без указания атрибута version.
1782.16 1786.32 "Игорь Лабутин" Просто чтобы визуально видеть, от кого конкретно проект зависит.
1786.32 1816.96 "Игорь Лабутин" Вот, но действительно есть проблема, потому что во-первых tooling, который не понимает такого, а во-вторых, если случайно написать какой-то конкретный version, или tooling, например, задел что-то и попытался обновить, и сам написал версию в cssproj явную, то в отличие от этого подхода центрального, где мы должны версию в cssproj указывать через version override отдельной атрибутом, от того, что вы указали версию таким же атрибутом version, но она честно и override-илась внутри cssproj на нужную конкретную версию, указанную.
1816.96 1826.32 "Игорь Лабутин" И отловить это никак, кроме как ручным или каким-то самописным анализом msbuilda всех файлов было, в общем-то, невозможно.
1826.32 1834.44 "Игорь Лабутин" Поэтому только code.review, ну мы использовали, по сути, просто проверку, грубо говоря, во время code.review, что у нас версии не override-ятся явно внутри cssproj.
1834.44 1845.20 "Анатолий Кулаков" Если у вас немного проектов, то еще хорошим нововведением, который тоже появился не так уж и давно, но, я думаю, уже для всех дошел, это consolidate.
1845.20 1859.44 "Анатолий Кулаков" То есть это специальная вкладочка, если вы откроете в Visual Studio ваш менеджер пакетов, то есть как он называется, ну, getmanagement, по-моему, так и называется, и последняя вкладочка там будет именно consolidate.
1859.44 1871.92 "Анатолий Кулаков" Это специальная функциональность, которая позволяет вам проанализировать все зависимости во всех ваших проектах внутри вашего солюшена и посмотреть, как раз-таки, когда одинаковые зависимости отличаются, имеют разную версию, отличаются по версии.
1871.92 1874.76 "Анатолий Кулаков" И там возможность как раз-таки привести их к одной версии.
1874.76 1884.40 "Анатолий Кулаков" Тоже очень удобный табик, поэтому если никогда не пользовались, посмотрите, может быть, у вас как раз-таки найдете с помощью него в вашем проекте какие-то расхождения.
1884.40 1890.04 "Анатолий Кулаков" То есть вручную вот так вот иногда заходить в этот табик и смотреть, очень полезная штука получается.
1890.04 1899.96 "Игорь Лабутин" Да, мне кажется, райдер тоже что-то такое поддерживает, он в своем package manager тоже показывал, когда выбираете пакет, он показывает, от каких версий зависят разные ваши проекты.
1899.96 1907.32 "Игорь Лабутин" Так что как-то вручную это все можно делать, но, конечно, когда будет центрально все это поддерживается, в том числе, это улами, будет, конечно, в разы удобнее.
1907.32 1908.32 "Игорь Лабутин" Давай дальше.
1908.32 1912.36 "Игорь Лабутин" Microsoft нас не отпускает, и на самом деле сегодня не отпустит довольно долго.
1912.36 1916.08 "Игорь Лабутин" У нас много новостей от Microsoft, вышла статья про C# 11.
1916.08 1929.60 "Игорь Лабутин" Если вы помните, выпускает, наверное, 4 назад, когда только-только начинался новый, так сказать, виток развития дотнета и седьмой версии, мы обсуждали список потенциальных фич, который дойдет до релиза.
1929.60 1943.60 "Игорь Лабутин" Вот, наконец-таки, начали потихонечку доходить разные всякие фичи из 11 C#, и несколько из них попали уже в очередной превью, который можно теперь подергать, посмотреть и составить свое мнение, назовем это так.
1943.60 1950.60 "Игорь Лабутин" Начнем мы с довольно прикольной фичи, которая мне, честно говоря, бывает, что не хватала, называется на raw string literals.
1950.60 1959.12 "Игорь Лабутин" То есть, если вы, например, хотели в ваш C# код вставить кусочек JSON в виде строки, то у вас было две проблемы.
1959.12 1961.40 "Игорь Лабутин" Проблема номер один — нужно экранировать кавычки.
1961.40 1993.72 "Игорь Лабутин" Проблема номер два — если у вас в JSON встречаются фигурные скобки, ну а какой JSON-чик без фигурных скобок, то сделать такую строчку еще, например, и интерполируемой, то есть, например, какие-то кусочки этого JSON подменять шаблоном интерполяции, становится чрезвычайно сложно, потому что как только вы ставите $ перед строчкой, она становится интерполируемой, все фигурные скобочки в строке автоматически начинают пытаться быть вот этими самыми placeholders для замены, и компилятор начинает считать их дотнет выражениями, которые надо вычислять, а понятное дело, что это неправда.
1993.72 1994.72 "Анатолий Кулаков" Вот.
1994.72 2004.08 "Анатолий Кулаков" И у тебя вообще смешная ситуация получается, у тебя скобочки все становятся двойными, ну для того, чтобы заэскейпить, и все кавычечки тоже становятся двойными для того, чтобы их тоже заэскейпить.
2004.08 2009.36 "Анатолий Кулаков" И у тебя уже вроде красивый JSON-чик, красивый XML-чик превращается в какое-то жуткое месиво.
2009.36 2011.92 "Игорь Лабутин" Да, теперь у нас есть rows.rangliterals.
2011.92 2014.64 "Игорь Лабутин" Это, короче, конструкция следующая.
2014.64 2019.80 "Игорь Лабутин" Во-первых, вы начинаете и заканчиваете новую строчку как минимум с трех двойных кавычек.
2019.80 2022.80 "Игорь Лабутин" И как минимум это важно.
2022.80 2030.36 "Игорь Лабутин" На самом деле вы можете их начать из четырех двойных кавычек, из пяти двойных кавычек, из шести двойных кавычек, главное, чтобы закрыли с стальким количеством двойных кавычек.
2030.36 2031.36 "Игорь Лабутин" Почему это важно?
2031.36 2033.32 "Игорь Лабутин" Важно это вот для чего.
2033.32 2043.44 "Игорь Лабутин" Компилятор будет считать любое количество двойных кавычек внутри строки, но меньше, чем вот это открывающее количество, как будто это обычные литералы, которые не надо эскейпить.
2043.44 2055.16 "Игорь Лабутин" То есть если вам нужно, например, JSON, где часто встречаются пустые строки, просто двойные кавычки подряд идут, две штуки, то как раз вы начинаете с трех двойных кавычек, и всё отлично.
2055.16 2059.24 "Игорь Лабутин" Двойные кавычки парой их будут считаться просто кавычками.
2059.24 2071.04 "Игорь Лабутин" Если же вам зачем-то нужно, например, показать пример с rostring.literal из трех двойных кавычек, вы начинаете с четырех штук, и тогда три двойные кавычки подряд не будут считаться никаким специальным, значит, специальной последовательностью.
2071.04 2082.64 "Игорь Лабутин" Дальше перед этой штукой, перед вот этим вот "тремя и больше двойными кавычками", можно добавить доллар, и тогда строчка внутри станет интерполируемой.
2082.64 2084.36 "Игорь Лабутин" Теперь следующая штука.
2084.36 2093.12 "Игорь Лабутин" Количество долларов вначале определяет, сколько фигурных скобочек нужно открывающих и закрывающих иметь подряд, чтобы это считалось шаблоном интерполяции.
2093.12 2107.16 "Игорь Лабутин" То есть для, например, JSON, как мы говорим, если мы, например, возьмем вот тройные двойные кавычки, и три двойные кавычки вначале, три двойные кавычки в конце, и вставить сюда какой-нибудь JSON, то кавычки от JSON уже не надо будет скрипить.
2107.16 2112.12 "Игорь Лабутин" Но фигурные скобки все еще надо, если вы хотите сделать ее интерполируемой.
2112.12 2125.08 "Игорь Лабутин" Но теперь вы можете, например, вставить два доллара вначале, и тогда для того, чтобы внутри JSON вот такого какой-то кусочек стал именно интерполируемым, нужно его открывать двумя фигурными скобками и закрывать тоже двумя.
2125.08 2136.32 "Игорь Лабутин" И, наконец, последняя фишка, которая меня всегда, скажем так, ставила в тупик в тех языках, где есть вот такие вот многострочные штуки, меня всегда интересовала.
2136.32 2152.08 "Игорь Лабутин" С одной стороны, мне хочется, чтобы мой текст красиво был выровнен вправо, да, ну вместе со всем остальным моим кодом, и с другой стороны, я не хочу, чтобы в моем тексте были все эти начальные пробилы, которые используют для выравнивания всех этих, значит, замечательных многострочных строк, потому что они могут быть еще и многострочные.
2152.08 2154.56 "Игорь Лабутин" Так вот в Дотнете сделали следующую штуку.
2154.56 2169.04 "Игорь Лабутин" Если вы закрывающую тройную кавычку ставите на пустую строку после, соответственно, последней значимой строки вашего текста, то слева от нее окажется какое-то количество whitespaces, да, в размере отступа обычно.
2169.04 2179.12 "Игорь Лабутин" Так вот компилятор при, собственно, создании вот этой строки отрежет от каждой строки вашей многострочной строки столько отступов, сколько отступов до последней закрывающей кавычки.
2179.12 2189.24 "Игорь Лабутин" Таким образом, выравнивая последнюю кавычку, как вам нужно, вы, то есть весь текст будет отрезан как будто по этой кавычке, убрав эффективно весь отступ, который был слева.
2189.24 2198.46 "Игорь Лабутин" Вот такие вот у нас теперь будут string literal, поэтому теперь, если вы в коде на C# увидите конструкцию string s = $$$$$...
2198.46 2202.20 "Игорь Лабутин" И дальше чего там? Потом "$$$$," не удивляйтесь.
2202.20 2203.56 "Игорь Лабутин" Это теперь так можно.
2203.56 2208.26 "Анатолий Кулаков" У меня вот эта фишка, она одновременно вызывает и восторг, и жуткий трепет.
2208.26 2211.72 "Анатолий Кулаков" В общем, восторг, потому что мне такие штуки очень часто нужны.
2211.72 2224.20 "Анатолий Кулаков" Я очень много темплейтов пишу, я люблю, например, в тесты вставлять какие-то уже готовые куски того же самого JSON, или XML, или кода, для того, чтобы тестировать мои анализаторы, еще что-то.
2224.20 2229.50 "Анатолий Кулаков" В общем, на практике мне такая штука безумно нужна, мне ее очень сильно не хватало, я возмучивался эскейпить.
2229.50 2239.10 "Анатолий Кулаков" И я наслаждался теми языками, в которых эта вещь уже есть, ну а такая штука есть практически во всех языках, именно скриптовых, безусловно.
2239.10 2253.70 "Анатолий Кулаков" В общем, я ее ждал, я ее хотел, но ты заметил, что у нас первый раз, наверное, в C# появилась магия, которая динамически изменяет, по сути, сигнатуру того, где начинается сам блок.
2253.70 2269.56 "Анатолий Кулаков" У нас обычно есть какой-нибудь определенный кейворд, или какой-нибудь определенный символ, допустим, доллар появился, мы понимаем, что после доллара идет какая-нибудь строка интерпретируемая, или там кавычка открылась, и у нас пошла обычная строка.
2269.56 2278.40 "Анатолий Кулаков" В общем, у нас есть какое-то понятное для парсера предсказуемое строка, или буковка, или еще что-нибудь, или символ.
2278.40 2282.86 "Анатолий Кулаков" В общем, ну а теперь это исчезает, такая предсказуемость.
2282.86 2300.16 "Анатолий Кулаков" Теперь у нас для парсера признак того, что начинается вот это магическое row string literals, этот признак он динамический, то есть парсер его вынужден считать и каким-то образом динамически сохранять, для того чтобы потом впоследствии закрыть.
2300.16 2310.10 "Анатолий Кулаков" В общем, мне кажется, настолько динамики, настолько пропахнувшего этим динамическим программированием структур в C# еще никогда не было.
2310.10 2311.22 "Игорь Лабутин" Это правда.
2311.22 2315.02 "Игорь Лабутин" Но я, что-то признаться, про эту часть не сильно задумывался.
2315.02 2322.40 "Игорь Лабутин" Мне просто действительно нравится сама концепция, мне нравится красота, как они сделали с отрезанием этих начальных whitespaces.
2322.40 2329.06 "Игорь Лабутин" Теперь можно все выравнивать, не заботясь о том, зная точно, сколько получится в результате, и это прям прекрасно.
2329.06 2335.22 "Игорь Лабутин" Поэтому я полагаюсь на команду компилятора, что она все сделала хорошо и буду просто пользоваться.
2335.22 2336.46 "Игорь Лабутин" Я думаю, что так.
2336.46 2338.66 "Анатолий Кулаков" Безусловно. Ты же представляешь, сколько магии за этим хранится.
2338.66 2351.86 "Анатолий Кулаков" То есть приходит человек с базовыми знаниями, допустим, C#, и видит конструкцию $$, кавычка, кавычка, а потом еще он должен помнить, что на самом деле у тебя потом еще везде переформатируется твоя строка.
2351.86 2353.86 "Анатолий Кулаков" То есть там начальные пробельчики отрежутся.
2353.86 2356.70 "Анатолий Кулаков" Но это знание из уровней черной магии вообще.
2356.70 2370.10 "Игорь Лабутин" Да, интересно будет, что произойдет, если у тебя отрезан, ну вот как бы, закрывающая кавычка, выровнен, не знаю, по 4 пробелам, ну на 4 пробелах вправо сдвинута, а весь текст написан, начиная с нулевой колонки.
2370.10 2375.70 "Анатолий Кулаков" Ну предсказуемо было бы, если бы он просто отрезал всю строку по этому числу, вот и все.
2375.70 2379.10 "Игорь Лабутин" То есть его первые 4 символа, ну да, 4 символа первые 2 типа теряются.
2379.10 2380.10 "Игорь Лабутин" Да, чисто символы просто.
2380.10 2382.34 "Игорь Лабутин" Не знаю, ну хотя да, наверное это предсказуемо.
2382.34 2389.34 "Анатолий Кулаков" Ну если он там начнет анализировать whitespace, это не whitespace, а в каких-то локалях, в каких-то языках whitespace будет не тот же самый, что и whitespace.
2389.34 2393.84 "Анатолий Кулаков" У нас же там есть пробелов 10 видов, они же, наоборот, переносимые, непереносимые, видимые, невидимые.
2393.84 2398.84 "Анатолий Кулаков" То есть если он начнет анализировать всю эту штуку, это будет еще хуже, поэтому тупо отрезать 4 чара и все.
2398.84 2402.34 "Игорь Лабутин" Да, а с другой стороны, слушай, даже делает компилятор, у него есть куча времени, все анализирует.
2402.34 2403.84 "Игорь Лабутин" Ладно, давай дальше.
2403.84 2409.84 "Игорь Лабутин" Это не единственные строки, которые были введены, у нас теперь есть еще один вид строк, называется utf-8-string-literals.
2410.08 2419.08 "Игорь Лабутин" Это, на самом деле, довольно узкоспецифичная штука, вряд ли вам она будет нужна прям так в повседневном коде, но эта конструкция примерно следующая.
2419.08 2428.84 "Игорь Лабутин" Она позволяет вам записать теперь выражение вида, допустим, объявить массив byte и присвоить ему сразу строку в момент инстализации.
2428.84 2433.84 "Игорь Лабутин" Либо объявить span, либо объявить redundant span и присвоить им, собственно, тоже сразу строку.
2433.84 2450.84 "Игорь Лабутин" Как я понимаю, это происходит некоторый аналог encoding utf-8.getbytes, по сути говоря, и компилятор сразу на лету превращает это в массив byte в utf-8-кодировке, и именно таким образом оно попадает в метаданные сборки.
2450.84 2453.58 "Игорь Лабутин" Ну, в статические данные сборки.
2453.58 2468.84 "Игорь Лабутин" Вот, там сейчас есть еще некоторые разговоры, нужен ли какой-то определенный суффикс, то есть была идея сделать, например, что нужно в конце строки написать там u8 или utf-8, или еще как-то по аналогии, как мы пишем, например, там с... не знаю, какие-нибудь там...
2468.84 2475.84 "Игорь Лабутин" Для шестнадцатричных чисел мы делаем 0x в начале, или можно там в каких-то языках всякие там...
2475.84 2478.84 "Игорь Лабутин" longi, l в конце надо написать, ну и так далее.
2478.84 2490.84 "Игорь Лабутин" То есть, вот суффикс пока вопрос неопределенный, но если вы зачем-то много работаете со строками и смотрите на них как на массивы byte или на спаны, то вот этот способ теперь чуть упростить инициализацию.
2490.84 2494.84 "Игорь Лабутин" По сути, это просто некоторые синтетические сахары для инициализации.
2494.84 2505.84 "Анатолий Кулаков" Ну, мне кажется, это не только сахар, это все-таки performance improvement, потому что теперь у тебя все строки раскладываются в compile time, и, соответственно, в run time никаких накладных расходов на конвертацию нет.
2505.84 2524.84 "Анатолий Кулаков" Допустим, если мы говорим про какой-то web-сервер, который ему нужно очень много срочно возвращать строчек, эти строчки в tf8, и они вот константные, такие статические, то вот эта штука помогает их превратить прямо в массив byte прямо на этапе компиляции, а у тебя в коде, соответственно, будут красивые понятные строчки с нормальным редактированием и все такое.
2524.84 2534.84 "Анатолий Кулаков" Если раньше вам приходилось писать массив в byte и разбивать их там по хексам, по int, или еще по чем-то, и как-то странно это поддерживать, то теперь вы можете их держать в виде строк, а компилятор сам все это сделает за вас.
2534.84 2551.84 "Игорь Лабутин" Не, ну я думаю, что в случае с web-сервером как раз проблемы нет, потому что web-сервер один раз на старте сделает encoding в tf8, get bytes и закеширует результат. Другое дело, что эта строчка, единожды зааллоцированная в памяти, поскольку она лежит в сборке, ну, в смысле, в метаданных сборке, она будет висеть в памяти и ее занимать.
2551.84 2557.84 "Игорь Лабутин" Вот. А она, по сути, как строчка, больше никогда не нужна, она один раз используется для получения массива byte, и все.
2557.84 2560.84 "Игорь Лабутин" Поэтому в этом смысле это, конечно, экономия.
2560.84 2577.84 "Игорь Лабутин" Ну и просто чуть более красивый текст, потому что, возможно, вы ради такой экономии сразу писали byte, там, array присвоить new byte, и дальше прям в 64-ричном виде записывали коды всех символов подряд, то теперь можете просто немножко покрасивее это написать.
2577.84 2598.84 "Игорь Лабутин" А, давай дальше. Дальше появилась штука под названием checked_user_defined_operators, это, если вы помните, в еще шестом .NET в режиме preview появилась штука под названием generic_math, где вы можете в вашем классе переопределять операторы типа +, - и так далее, позволяющие в итоге делать generic математику на ваших собственных типах.
2598.84 2611.84 "Игорь Лабутин" И для операторов, собственно, +, -, умножить, поделить, ++, -, -, в .NET есть, соответственно, вообще говоря, поведение checked и unchecked, то есть с проверкой переполнения или без проверки переполнения.
2611.84 2623.84 "Игорь Лабутин" Так вот теперь, когда вы пишете, собственно, свои собственные операторы в классах, можно указать специальным idifier checked, и тогда именно эта версия будет выбираться в checked контексте, как я понял, компилятором.
2623.84 2631.84 "Игорь Лабутин" То есть вы теперь можете написать, например, два оператора +, один будет checked, другой unchecked, и у них будет, понятное дело, разные перформансы.
2631.84 2633.84 "Игорь Лабутин" On checked версия, скорее всего, будет, возможно, быстрее.
2633.84 2644.84 "Игорь Лабутин" Хотя, хотя, спецификация формально ничего не требует, насколько я помню, то есть, насколько я понял статью, по спецификации формально checked версии не обязаны кидать никакие overflow, exceptions и так далее.
2644.84 2653.84 "Игорь Лабутин" Но все привыкли, что в checked контексте какой-нибудь плюс оператор, если вы к int max прибавите единичку, он вам кинет arithmetic overflow и exception.
2653.84 2657.84 "Игорь Лабутин" Но вот было бы неплохо, чтобы ваши кастомные операторы вели себя так же.
2657.84 2661.84 "Игорь Лабутин" В checked контексте теперь у вас есть возможность делить checked и unchecked варианты.
2661.84 2665.84 "Игорь Лабутин" Дальше, pattern matching потихонечку дальше двигается.
2665.84 2673.84 "Игорь Лабутин" Уже не такие огромные шаги, я так понимаю, что подавляющее большинство того, чего хотели сделать, сделали, но остались всякие кусочки.
2673.84 2679.84 "Игорь Лабутин" Теперь можно pattern matching спаны и read-only спаны с строчками, с литералами.
2679.84 2698.84 "Игорь Лабутин" Конечно, для этого нужны некоторые гарантии для компилятора, то есть компилятор должен понимать статически, что там будет обязательно спан от char или read-only спан от char, и если вы матчите эту штуку с null, то это будет прям ошибка компиляции, даже, а не runtime.
2698.84 2702.84 "Игорь Лабутин" То есть, возможность только матчить с какими-то стринговыми литералами.
2702.84 2706.84 "Игорь Лабутин" Ну, это примерно оттуда же, откуда utf-8 string_literals, видимо.
2706.84 2708.84 "Игорь Лабутин" Это разумное дополнение.
2708.84 2713.84 "Игорь Лабутин" Также в этом превью завезли фичу, про которую мы уже рассказывали в одном из прошлых подкастов.
2713.84 2725.84 "Игорь Лабутин" Если вы передаете в метод, который ждет, например, какой-нибудь там func t, либо action t, метод group, то есть просто указываете имя метода, который нужно передать, это называется метод group_conversion.
2725.84 2732.84 "Игорь Лабутин" Раньше, до этой версии, делегат, который создается в этом случае, создавался каждый раз новый.
2732.84 2747.84 "Игорь Лабутин" И, соответственно, у вас была не утечка памяти, но heap allocation на этом месте, и поэтому рекомендовалась странная конструкция, типа x, стрелочка, не знаю, action от x, хотя казалось бы, бессмысленная лямбда, но лямбда таки кэшировались.
2747.84 2757.84 "Игорь Лабутин" Теперь сделали по-другому, изменили, можно сказать, ввели большой breaking change, потому что так было со времен каких-то древних версий дотнета, и теперь делегаты тоже кэшируются.
2757.84 2764.84 "Анатолий Кулаков" Мне кажется, ты нас затягиваешь вообще всей этой мелочью против самой главной новости вообще на всем белом свете в этом релизе.
2764.84 2771.84 "Анатолий Кулаков" Ну ладно, кроме raw string literals, расскажи, как нам сначала сделали плохо, а потом обратно вернули, как было, и все после этого начали радоваться.
2771.84 2774.84 "Игорь Лабутин" Да, мы очень подробно рассказывали про null checking.
2774.84 2784.84 "Игорь Лабутин" Вы помните, что у нас есть огромное количество мест в коде, где мы проверяем аргументы на null, и у нас появилось, вообще говоря, к последним версиям C# несколько способов это делать.
2784.84 2810.84 "Игорь Лабутин" Вы могли написать классический if, вы могли использовать оператора два вопросика, вы могли использовать специальные хелперы argument null exception .throw if null или что-нибудь в таком духе, и к нам завезли, для того чтобы убрать весь этот ненужный синтаксис, завезли оператор, два восклицательных знака, которые нужно было указать после имени параметров в сигнатуре функции, и компилятор автоматически вставлял проверку на null.
2810.84 2813.84 "Игорь Лабутин" Но что-то пошло не так.
2813.84 2834.84 "Анатолий Кулаков" Ну, наоборот, смотри, они-то как раз написали, что как раз-таки все пошло так, как мы задумывали. Мы-то специально это выкатили как можно раньше, специально во всех форумах и во всех конференциях и во всех фидбэках просили вас сказать, насколько вам это нравится. Вы нам все прекрасно рассказали, послали нас куда надо, и, соответственно, мы вам большое за это благодарны.
2834.84 2842.84 "Анатолий Кулаков" Потому что комьюнити в основном высказалось за то, что так делать не надо, нам это не нравится, мы такое не любим, и это какая-то дичь.
2842.84 2862.84 "Анатолий Кулаков" И поэтому было принято стратегическое решение как раз-таки откатить два восклицательных знака и выкинуть их, удалить их из реализации спецификации C# 11. То есть в C# 11 не будет двух восклицательных знаков в том плане, что они делают проверку наших аргументов.
2862.84 2865.84 "Анатолий Кулаков" И, соответственно, это большая новость.
2865.84 2870.84 "Анатолий Кулаков" Вот такие вот ужасные, мне кажется, ugly syntaxes все-таки не проходят.
2870.84 2887.84 "Анатолий Кулаков" Проверку на сообщество, и радует, что Microsoft к этому прислушивается и каким-то образом пытается все-таки откатить даже тот код, который уже был переделан. Помнишь, мы с тобой обсуждали, что там уже огромные участки кода были переделаны для того, чтобы проверить, насколько это вообще красиво и пригодно на практике.
2887.84 2894.84 "Игорь Лабутин" Ну, переделают обратно, соответственно, Стивен Тау потратит еще полчасика и переделает весь репозиторий рантайма обратно.
2894.84 2900.84 "Анатолий Кулаков" Я думаю, да, да, напишет какой-нибудь анализатор, реплейсер, что-нибудь в этом духе исправится.
2900.84 2904.84 "Анатолий Кулаков" Как же мы теперь будем жить без этих двух восклицательных знаков?
2904.84 2906.84 "Анатолий Кулаков" Ну, в принципе, так же, как и раньше.
2906.84 2920.84 "Анатолий Кулаков" Рекомендовывается способ для .NET 6, все еще остается аргумент nullException.throwIfNull. Этот метод позволяет вам в одну строчку проверить все ваши аргументы. Нет, на одну строчку на каждый аргумент, конечно же.
2920.84 2934.84 "Анатолий Кулаков" Проверите ваш аргумент на null. Он прекрасен тем, что использует новый атрибут colorArgumentExpression, который позволяет вам не указывать имя переменной, а просто передать ее переменную, он сам ее проверит и сам из нее вычленит имя, если нужно брутить exception.
2934.84 2937.84 "Игорь Лабутин" И вообще, у него есть еще одно хорошее преимущество.
2937.84 2942.84 "Игорь Лабутин" Он, собственно, скрывает код именно выкидывания exception у себя внутри.
2942.84 2949.84 "Игорь Лабутин" И это значит, что в тексте вашей функции не будет конструкции throw, а это значит, что шансы, например, на ее inlining резко повышаются.
2949.84 2956.84 "Игорь Лабутин" Если у вас какая-то небольшая функция, то, если я правильно помню, если в функции есть код выкидывания exception, то она никогда не inlining.
2956.84 2962.84 "Игорь Лабутин" А таким образом, поскольку это все убрано в helper, то теперь ваш код может быть за inlining.
2962.84 2966.84 "Анатолий Кулаков" Да, именно так. Очень интересная такая микрооптимизация получается.
2966.84 2969.84 "Анатолий Кулаков" Ну и вообще, всем давно уже пора переходить на nullReferenceType.
2969.84 2972.84 "Анатолий Кулаков" Если вы еще не перешли, то срочно переходите.
2972.84 2978.84 "Анатолий Кулаков" Эта манна небесная спасет вас от кучи других больших проблем, ну и избавит от вот таких вот дурацких проверок.
2978.84 2981.84 "Анатолий Кулаков" Например, в большинстве мест в вашем коде.
2981.84 2996.84 "Игорь Лабутин" Ну и последнее нововведение в C# 11 - это новый warning, который я почему-то думаю затронет не очень большое количество пользователей, но раз он введен, наверное, Microsoft что-то знает и, наверное, там где-то делает.
2996.84 3003.84 "Игорь Лабутин" Warning будет, если вы называете ваши классы полностью lowercase, то есть только маленькими буквами.
3003.84 3005.84 "Игорь Лабутин" Я не знаю, кому и зачем это может быть надо.
3005.84 3011.84 "Игорь Лабутин" Для генерации, например, возможно, соответствие каким-нибудь внешним контрактам.
3011.84 3015.84 "Игорь Лабутин" То есть нужно, чтобы для сериализации, например, класс как-то правильно назывался.
3015.84 3019.84 "Игорь Лабутин" Хотя это можно обработать в том числе атрибутами дополнительными.
3019.84 3042.84 "Анатолий Кулаков" Вот, а я тебе скажу, как раз-таки я на таких проектах встречал более одного, люди, которые предпочитали писать именно классы именно в lowercase, потому что после того, как они засерилизуют в JSON эту штуку, она будет, соответственно, называться в SnackCase или в CamelCase, так как положено в JS.
3042.84 3051.84 "Анатолий Кулаков" И поэтому атрибуты слишком интерпразные выглядели или пачкали нашу прекрасную структуру, или какие-то другие нелепые отмазы.
3051.84 3053.84 "Анатолий Кулаков" Но, в общем, я такие структуры именно встречал.
3053.84 3055.84 "Анатолий Кулаков" Да, есть такие люди.
3055.84 3057.84 "Игорь Лабутин" Ну, окей, теперь это будет warning.
3057.84 3059.84 "Игорь Лабутин" Это всего лишь warning, ничего страшного.
3059.84 3066.84 "Игорь Лабутин" Но причина простая. C#-команда считает, что периодически придется и будет нужно вводить новые ключевые слова.
3066.84 3070.84 "Игорь Лабутин" И кажется, что у них есть какие-то большие планы, раз они добавили такой warning.
3070.84 3072.84 "Игорь Лабутин" Так что ждем новых ключевых слов.
3072.84 3082.84 "Игорь Лабутин" И поэтому они собираются теперь предупреждать о таких случаях, потому что если они введут такое новое ключевое слово, которое внезапно совпадает с именем вашего класса, ваш код сломается, с хорошей вероятностью.
3082.84 3085.84 "Игорь Лабутин" Поэтому, ну, в общем, следите за warning'ами.
3085.84 3089.84 "Игорь Лабутин" Если они вдруг появляются, либо переписывайте код, либо игнорите warning'и.
3089.84 3092.84 "Игорь Лабутин" Ну, в общем, думайте, что с этим всем делать.
3092.84 3096.84 "Игорь Лабутин" Либо всегда в C# есть возможность написать собачку перед названием такого класса.
3096.84 3103.84 "Игорь Лабутин" И тогда, даже если это ключевое слово, оно все равно будет использоваться именно как название вашего класса, а не как ключевое слово.
3103.84 3105.84 "Анатолий Кулаков" Да, да, и не смешивайте домены.
3105.84 3109.84 "Анатолий Кулаков" Если у вас все-таки классы написаны в C#, значит вы должны придерживаться стайл-гайда в C#.
3109.84 3121.84 "Анатолий Кулаков" Если они куда-то уходят наружу, то есть, есть способы сделать и отформатировать их под стайл-гайды наружного какого-то домена, наружного интерпретатора с помощью, опять же, нативных конструкций для C#.
3121.84 3128.84 "Анатолий Кулаков" То есть, не надо перезабытать какое-то извращение и ломать весь стайл только потому, что...
3128.84 3130.84 "Анатолий Кулаков" А не знаю, почему нет нормальных причин для этого.
3130.84 3133.84 "Анатолий Кулаков" Не надо просто никогда ломать стайл C#.
3133.84 3135.84 "Игорь Лабутин" Ну, и вообще любого языка, на который вы пишите.
3135.84 3137.84 "Игорь Лабутин" Пишите так, как принято на этом языке.
3137.84 3143.84 "Анатолий Кулаков" Да, идиоматично пишите, и я просто идиоматематично буду читать, и компилятор будет рад, и никаких варнингов у вас не будет.
3143.84 3145.84 "Игорь Лабутин" Да.
3145.84 3148.84 "Игорь Лабутин" Ну, чё, Майкрософт не закончил на этом.
3148.84 3155.84 "Игорь Лабутин" И, наконец-таки, после, я не знаю, по-моему, больше года ожидания прошло, у нас есть релиз кандидата Мауи.
3155.84 3157.84 "Анатолий Кулаков" Мауи, да, наконец-то мы ждали.
3157.84 3165.84 "Анатолий Кулаков" Я напомню, что мы ждали его еще в тот момент, когда зарелизился .NET, прошлой осенью, или там уже зима была.
3165.84 3171.84 "Анатолий Кулаков" Ну, в общем, они хотели, но не успели, и они приклятвенно пообещали, что через полгодика точно зарелизится.
3171.84 3175.84 "Анатолий Кулаков" И, судя по новостям, вроде и пока держат свой роудмап.
3175.84 3177.84 "Игорь Лабутин" Да, вышел релиз кандидат.
3177.84 3186.84 "Игорь Лабутин" В нем не то, чтобы прям какие-то супер улучшения и изменения, и новые фичи, это просто багфикс, который потихонечку полируется для релиза.
3186.84 3193.84 "Игорь Лабутин" Для того, чтобы его использовать, вам нужна будет Visual Studio 17.2 Preview 3, мы про нее чуть-чуть позднее поговорим.
3193.84 3198.84 "Игорь Лабутин" И в комплекте у вас будет SDK для Android, iOS, macOS, Windows.
3198.84 3214.84 "Игорь Лабутин" И вместе со всем этим SDK у вас будет больше сорока всяких контролов, лейаутов, которые оптимизированы уже под новый подход MAUI, с хендлерами и всем таким, которые готовы для того, чтобы разрабатывать десктопные мобильные приложения.
3214.84 3218.84 "Игорь Лабутин" Как мы помним, MAUI — это наследник в каком-то смысле Xamarin.Forms.
3218.84 3228.84 "Игорь Лабутин" Так вот, команда утверждает, что если вы с чем-то работали в Xamarin.Forms, то это точно будет в каком-то мере работать в MAUI, делаем скидку на то, что это релиз-кандидат.
3228.84 3236.84 "Игорь Лабутин" Но по крайней мере, всякие контролы и прочее, которые вам были знакомы по Xamarin.Forms, точно доступны в MAUI, и на самом деле набор контролов в MAUI даже больше.
3236.84 3253.84 "Игорь Лабутин" Так что если вы ждете какой-то кроссплатформенной разработки от Microsoft, то посмотрите — UI имеется в виду, конечно же — посмотрите в сторону MAUI, релиз-кандидат, вероятно, уже достаточный, так сказать, уровень взросления, чтобы его попробовать.
3253.84 3269.84 "Анатолий Кулаков" Да, надо позвать каких-нибудь экспертов по UI, чтобы они уже сравнили все это, все-таки взрослость этого фреймворка, и как он, например, бьется с теми же самыми Avalon'ями или какими-нибудь более старыми, более зрелыми, поддерживаемыми проектами.
3269.84 3274.84 "Анатолий Кулаков" Я думаю, в момент релиза мы такую штуку с тобой провернем.
3274.84 3275.84 "Игорь Лабутин" Да, давай пробуем.
3275.84 3276.84 "Игорь Лабутин" И побеседуем подробнее.
3276.84 3280.84 "Игорь Лабутин" Я надеюсь, что они успеют, как они обещают, зарелизиться во втором квартале этого года.
3280.84 3284.84 "Игорь Лабутин" Квартал только начался, считай, так что у них еще пара месяцев есть.
3284.84 3293.84 "Анатолий Кулаков" Так, Andrew Locke выпустил необычную статейку, мы любим тут Andrew Locke, но в основном за то, что он делает с ASP.NET, и как он там глубоко роет, и все такое.
3293.84 3295.84 "Анатолий Кулаков" А здесь вдруг ему понадобилось странное.
3295.84 3299.84 "Анатолий Кулаков" Ему понадобилось из C# запускать JavaScript.
3299.84 3303.84 "Анатолий Кулаков" Вот такое извращение, Игорь, ты когда-нибудь хотел странного?
3303.84 3305.84 "Игорь Лабутин" Нет, мне такого не хотелось.
3305.84 3316.84 "Игорь Лабутин" Я могу придумать что-то, может быть, вам захотелось, если вы, например, JavaScript используете в качестве скриптового языка в вашем продукте, но это как вариант, не знаю, зачем еще, может быть, надо.
3316.84 3332.84 "Анатолий Кулаков" Ну да, с одной стороны, не самый плохой выбор, потому что довольно популярный, и многие его знают, а с другой стороны, если вы используете у себя внутри какой-то скриптовый язык, то, наверное, вы бы выбрали что-то более предсказуемое, более понятное, и более, может быть, строго типизированное и легко обучаемое.
3332.84 3343.84 "Анатолий Кулаков" Но я думаю, что есть такие проекты, где вам нужно заинклюдить JavaScript, и вот как раз Andrew Locke, Andrew Locke, такая штука тоже понадобилась.
3343.84 3347.84 "Анатолий Кулаков" Для его целей понадобилась именно подсветка синтаксиса.
3347.84 3381.84 "Анатолий Кулаков" И в принципе он нашел всякие подсветки синтаксиса для C#, но большинство из них, те, которые были хорошие, пригодные, все-таки ссылались на нативные библиотеки, там все равно какой-то interop был, скорее всего, с плюсами. И существовала как альтернатива, это просто взять JavaScript реализацию, которая полностью нативная, то есть полностью на JavaScript, и, соответственно, просто вывезти и JavaScript, и C#, и посмотреть, что получилось, и воспользоваться уже существующим миром, богатым библиотек.
3381.84 3452.84 "Анатолий Кулаков" Я также могу придумать, что если вы хотите что-то с UI, например, сделать, или как-то отрендерить какие-нибудь интересные графики, то все еще JavaScript здесь, наверное, впереди планеты всей. В общем, у каждого, наверное, есть свои собственные хотелки, что можно позаимствовать из большого мира JavaScript, и при этом, не сильно в него погружаясь, а вот так вот сбоку вызвать из C# пару методов, и все, и быстренько закрыть, и не вспоминать об этом. Вот, хотелось бы как раз вместе с Андрю Локком сегодня с вами рассмотреть, какие же есть подходы, и на чем, собственно, остановился автор. Ну, прежде всего, самый банальный подход - это, если у вас на компьютере уже стоит Node.js, это, соответственно, специальный движок, специальный сервер, который умеет выполнять JavaScript, то самый очевидный способ - это сходить к Node.js, попросить у него выполнить какой-то кусочек, и вернуть вам уже результат этого выполнения, а результат уже потом как-то распарсить. Вот, и есть много таких библиотек, в частности, библиотека, которая называется Jaring JavaScript Node.js, делает именно такую штуку, она с собой Node.js не поставляет, но рассчитывает на то, что на машине уже установлен Node.js.
3452.84 3481.84 "Анатолий Кулаков" И, соответственно, самая большая проблема с такой библиотекой, если вы захотите ее взять в своих собственных проектах, это то, что вы как-то непредсказуемо должны гарантировать, что на том компьютере, где установлено ваше C# приложение, стоит Node.js. Гарантировать это довольно сложно, и, соответственно, с этим есть проблемы, поэтому это большой минус, то, что надо тащить еще какую-то зависимость, ее как-то гарантированно ставить.
3481.84 3484.84 "Анатолий Кулаков" Не очень хороший вариант.
3484.84 3490.84 "Анатолий Кулаков" Более интересная альтернатива - это использование библиотеки ChakraCore.
3490.84 3498.84 "Анатолий Кулаков" Это специальный JavaScript движок, который был написан Microsoft, специально для его новомодного когда-то браузера Edge.
3498.84 3504.84 "Анатолий Кулаков" И перед тем, как Edge свичнулся на Chromium, он как раз-таки использовал этот движок.
3504.84 3513.84 "Анатолий Кулаков" Сейчас это не так, но движок по-прежнему живет, его многие проекты используют, потому что он довольно быстрый, интересный, красивый, независимый и так далее.
3513.84 3519.84 "Анатолий Кулаков" Но с ним есть другая проблема - он использует нативные библиотеки, которые там написаны на сях.
3519.84 3525.84 "Анатолий Кулаков" И, соответственно, через всякие по-invoke C# должен с этими нативными библиотеками ходить и общаться.
3525.84 3537.84 "Анатолий Кулаков" И, соответственно, мы тоже здесь получаем небольшую неприятность, потому что теперь мы должны знать, на какую платформу мы устанавливаемся, чтобы с собой принести вот эти самые нативные библиотеки.
3537.84 3548.84 "Анатолий Кулаков" А также там правильно их подгрузить, в зависимости от архитектуры, в зависимости от разрядности и прочие-прочие проблемы, которые каждый из вас сталкивался, кто пытался заиспользовать в своем приложении нативные библиотеки.
3548.84 3551.84 "Анатолий Кулаков" Хотелось бы этой штуки тоже избежать.
3551.84 3556.84 "Анатолий Кулаков" И следующим на очереди у нас есть V8 JavaScript движок.
3556.84 3566.84 "Анатолий Кулаков" Это движок, который использует практически все большие монстры, тот же самый Node.js, Chromium, Chrome, Edge, который теперь переехал на V8.
3566.84 3568.84 "Анатолий Кулаков" В общем, все они его используют.
3568.84 3569.84 "Анатолий Кулаков" У него те же самые проблемы.
3569.84 3571.84 "Анатолий Кулаков" Это прежде всего нативные байдинги.
3571.84 3576.84 "Анатолий Кулаков" И, соответственно, если вдруг...
3576.84 3580.84 "Анатолий Кулаков" У него большое преимущество в том, что это самый популярный движок, который сейчас есть.
3580.84 3586.84 "Анатолий Кулаков" В него вкладываются в его перформансы, скорости, оптимизацию, вкладываются огромные и большие корпорации.
3586.84 3588.84 "Анатолий Кулаков" В общем, у него куча преимуществ.
3588.84 3594.84 "Анатолий Кулаков" И для него есть микрософтовские байдинги, которые называются Microsoft Clear Script.
3594.84 3597.84 "Анатолий Кулаков" В общем, байдинги есть к нативным библиотекам.
3597.84 3599.84 "Анатолий Кулаков" Если вам вдруг нужно, то тоже имеется.
3599.84 3610.84 "Анатолий Кулаков" Но для наших простых каких-то решений нам скорость необязательна, нам функциональность, совместимость необязательна, нам бы что-то по...
3610.84 3614.84 "Анатолий Кулаков" Нам бы какой-нибудь движок, который лучше распространяется, интегрируется.
3614.84 3623.84 "Анатолий Кулаков" И вот первым шагом к тому, что может быть что-то более-менее похожее на наши нужды, является Jint.
3623.84 3626.84 "Анатолий Кулаков" Jint - это JavaScript интерпретатор.
3626.84 3628.84 "Анатолий Кулаков" У него нет никаких зависимостей.
3628.84 3635.84 "Анатолий Кулаков" Он 100% написан на C# и вледет совместимость с нетстандартом 2.0.
3635.84 3637.84 "Анатолий Кулаков" То есть, вообще то, что нам нужно.
3637.84 3642.84 "Анатолий Кулаков" Встраиваем в наше приложение и без всяких зависимостей можем интерпретировать JavaScript.
3642.84 3644.84 "Анатолий Кулаков" Но есть еще лучше вариант.
3644.84 3647.84 "Анатолий Кулаков" Есть Jurassic.
3647.84 3654.84 "Анатолий Кулаков" Это .NET реализация, опять же JavaScript движка, но это не интерпретатор, это именно компилятор.
3654.84 3657.84 "Анатолий Кулаков" Компилирует он из JavaScript прямо в .NET-ный IL.
3657.84 3661.84 "Анатолий Кулаков" Что позволяет, естественно, быть его мега-быстрым, мега-удобным.
3661.84 3666.84 "Анатолий Кулаков" И, соответственно, никаких нативных зависимостей он с собой не тащит.
3666.84 3676.84 "Анатолий Кулаков" В общем, вот Jurassic кажется одним из самых лучших вариантов на данный момент, если вы не хотите загоняться всякими нативными зависимостями.
3676.84 3686.84 "Анатолий Кулаков" И при этом для вас не важен, не критичен перформанс, а также совместимость со самыми последними стандартами, которые мог бы дать вам V8.
3686.84 3692.84 "Анатолий Кулаков" И, соответственно, автор метался между всеми этими выборами.
3692.84 3694.84 "Анатолий Кулаков" Умным я хочу быть или красивым?
3694.84 3696.84 "Анатолий Кулаков" Нужны ли мне последние совместимости?
3696.84 3698.84 "Анатолий Кулаков" Нужны ли мне скорости?
3698.84 3703.84 "Анатолий Кулаков" Нужна ли мне хорошая интерпретируемость на любых платформах?
3703.84 3707.84 "Анатолий Кулаков" И он пришел к следующему выводу, что, в принципе, он хочет это все.
3707.84 3713.84 "Анатолий Кулаков" Он хочет динамически менять движок в зависимости от того, какие нужды ему сейчас нужны.
3713.84 3718.84 "Анатолий Кулаков" И нашел он интересный проект, который называется JavaScript Engine Switcher.
3718.84 3723.84 "Анатолий Кулаков" Это как раз общий API для всех этих движков.
3723.84 3730.84 "Анатолий Кулаков" И, соответственно, набор всяких врапперов, которые уже подходят ко всем этим движкам.
3730.84 3740.84 "Анатолий Кулаков" И вы можете динамически выбирать тот движок, который вам нравится, и запускать через один и тот же интерфейс, запускать JavaScript на любом из этих движков.
3740.84 3742.84 "Анатолий Кулаков" Запускается там все довольно легко.
3742.84 3747.84 "Анатолий Кулаков" Выставляете set variables, методы execute, методы evaluate.
3747.84 3749.84 "Анатолий Кулаков" В общем, все довольно очевидно и примитивно.
3749.84 3757.84 "Анатолий Кулаков" Можете поставить какие-то переменные, можете запустить JavaScript код, можете подключить библиотеки и можете получить результат из этого engine.
3757.84 3761.84 "Анатолий Кулаков" Там ничего такого сложного нет.
3761.84 3772.84 "Анатолий Кулаков" Интересно, что вот этот движок JavaScript Engine Switcher, вот этот движок, который объединяет все возможные API, его пилит Андрей Тарицын.
3772.84 3779.84 "Анатолий Кулаков" Это известный человек в узких кругах, активист .NET сообщества из Москвы.
3779.84 3786.84 "Анатолий Кулаков" И я не ожидал просто, что наткнусь на его из статьи Андрю Лока.
3786.84 3791.84 "Анатолий Кулаков" И совершенно случайно в нашей студии в гостях как раз тот самый Андрей Тарицын.
3791.84 3792.84 "Анатолий Кулаков" Привет, Андрей!
3792.84 3793.84 "Андрей Тарицын" Привет, Владимир Владимирович!
3793.84 3797.84 "Анатолий Кулаков" Слушай, хочется тебе по поводу этой библиотечки задать немножко вопросов.
3797.84 3799.84 "Анатолий Кулаков" Во-первых, интересно вообще сама идея.
3799.84 3800.84 "Анатолий Кулаков" Как она появилась?
3800.84 3804.84 "Анатолий Кулаков" Откуда вдруг у тебя лично возникла надобность в таком свитчере?
3804.84 3808.84 "Андрей Тарицын" Ну вот смотри, в 2019 году я выпустил бандл Transformer.
3808.84 3810.84 "Андрей Тарицын" Этот проект многие знают.
3810.84 3816.84 "Андрей Тарицын" Это бандлер, который содержит минификаторы и трансляторы различных языков при процессе.
3816.84 3821.84 "Андрей Тарицын" TypeScript, LES, SAS и CoffeeScript в тот момент был.
3821.84 3828.84 "Андрей Тарицын" И в какой-то момент библиотека, которая я использовал, которая называлась SAS and Coffee, перестала обновляться.
3828.84 3832.84 "Андрей Тарицын" То есть я решил перенести обработку CoffeeScript к себе.
3832.84 3835.84 "Андрей Тарицын" То есть у меня был JavaScript файл с CoffeeScript.
3835.84 3840.84 "Андрей Тарицын" И я из этой библиотеки выделил движок JavaScript.
3840.84 3843.84 "Андрей Тарицын" Это был Eesh движок.
3843.84 3846.84 "Андрей Тарицын" Я его оформил в виде библиотеки MCI.JS.ENG.
3846.84 3851.84 "Андрей Тарицын" И когда я запустил свой модуль на CoffeeScript, мне это понравилось.
3851.84 3853.84 "Андрей Тарицын" Я начал делать другие модули, минификаторы.
3853.84 3858.84 "Андрей Тарицын" Например, CSS Optimizer Яндексовский я перенес в бандл.
3858.84 3862.84 "Андрей Тарицын" И потом реализовал TypeScript.
3862.84 3865.84 "Андрей Тарицын" И все это довольно прекрасно работало.
3865.84 3867.84 "Андрей Тарицын" Но с CSS у меня была проблема.
3867.84 3871.84 "Андрей Тарицын" То есть Eesh движок не мог с ним работать.
3871.84 3873.84 "Андрей Тарицын" Поэтому я стал использовать V8.
3873.84 3876.84 "Андрей Тарицын" Была такая библиотека на ESIS.
3876.84 3877.84 "Андрей Тарицын" И я ее использовал.
3877.84 3882.84 "Андрей Тарицын" У меня каждый модуль шел с отдельным JavaScript движком.
3882.84 3887.84 "Андрей Тарицын" Это было не очень хорошо, но какое-то время это работало.
3887.84 3893.84 "Андрей Тарицын" И в какой-то момент, в ноябре 2012 года, меня пригласили выступить на MoscowJS.
3893.84 3895.84 "Андрей Тарицын" Рассказать про бандл Transformer.
3895.84 3899.84 "Андрей Тарицын" Это неформальная встреча с JavaScript разработчиков Москвы.
3899.84 3901.84 "Андрей Тарицын" Я туда пришел, выступил.
3901.84 3906.84 "Андрей Тарицын" И в конце ко мне подошел человек из команды BAM, сотрудник Яндекса.
3906.84 3914.84 "Андрей Тарицын" И он начал меня спрашивать, как я смог запустить CSS Optimizer, это минификатор от Яндекса, на Windows.
3914.84 3919.84 "Андрей Тарицын" То есть он не работал под Node.js на Windows.
3919.84 3920.84 "Андрей Тарицын" И мы начали с ним говорить.
3920.84 3926.84 "Андрей Тарицын" Я ему рассказал, что у меня он не работает на Internet Explorer движке.
3926.84 3930.84 "Андрей Тарицын" Я использую V8, и то, что у меня в каждом модуле используются разные движки.
3930.84 3934.84 "Андрей Тарицын" И мы начали рассуждать, что лучше бы сделать такую абстракцию.
3934.84 3939.84 "Андрей Тарицын" И у меня начала появляться идея создать ORM для JavaScript движков.
3939.84 3942.84 "Андрей Тарицын" Так называемый ORM для баз данных.
3942.84 3948.84 "Андрей Тарицын" То есть иметь провайдер каждого движка, который меняет в зависимости от ситуации.
3948.84 3951.84 "Андрей Тарицын" Какое-то время я еще выпускал по-старому все.
3951.84 3967.84 "Андрей Тарицын" И когда в 2013 году такое событие произошло, когда вышел третий Bootstrap, то есть там использовался Лес, совершенно новый, а библиотека .les под .net, то есть это порт LES.js на .net.
3967.84 3972.84 "Андрей Тарицын" И эта библиотека не поддерживала нужную версию LES.
3972.84 3980.84 "Андрей Тарицын" И в тот момент очень многих не могли воспользоваться Bootstrap на .net.
3980.84 3985.84 "Андрей Тарицын" И в итоге я написал модуль LES на основе JavaScript кода.
3985.84 3988.84 "Андрей Тарицын" То есть использовал библиотеку mcjs.engine.
3988.84 3992.84 "Андрей Тарицын" Мой модуль стал очень популярен в .net сообществе.
3992.84 3994.84 "Андрей Тарицын" Про .les на какое-то время забыли.
3994.84 3998.84 "Андрей Тарицын" И я вернулся к идее создания такой вот ORM.
3998.84 4004.84 "Андрей Тарицын" Первоначально я использовал интерфейс, он совпадал полностью с mcjs.engine.
4004.84 4012.84 "Андрей Тарицын" Я выпустил движки, первоначально это были mcjs.engine поверх, Jurassic и Naesis.
4012.84 4017.84 "Андрей Тарицын" Naesis я потом заменил на ClearScript, потому что это был более жизнеспособный продукт.
4017.84 4020.84 "Андрей Тарицын" И как бы все это развивалось внутри бандл трансформера.
4020.84 4029.84 "Андрей Тарицын" Библиотека была отдельно, конечно, с JavaScript и .net, но никто за пределами бандл трансформера ее не использовал.
4029.84 4033.84 "Андрей Тарицын" И в какой-то момент, где-то в 2014 году, появился проект React.net.
4033.84 4038.84 "Андрей Тарицын" Первоначально он был не очень популярен, его делали люди из Facebook.
4038.84 4041.84 "Андрей Тарицын" И они начали использовать JavaScript с .js фичер.
4041.84 4044.84 "Андрей Тарицын" Это было первое использование его за пределами бандл трансформера.
4044.84 4049.84 "Андрей Тарицын" Когда они просто переводили JSXJS, особо популярности не было.
4049.84 4056.84 "Андрей Тарицын" Но когда они сделали сервер-сайт рендеринг полноценный в этой библиотеке, она стала очень популярна.
4056.84 4064.84 "Андрей Тарицын" И в какой-то момент популярность стала расти, другие проекты начали подключаться.
4064.84 4066.84 "Андрей Тарицын" Потом появилась Chakra.
4066.84 4071.84 "Андрей Тарицын" Она появилась как раз, когда начался переход на .net core.
4071.84 4075.84 "Андрей Тарицын" И была одним из первых модулей, которые я портировал на .net core.
4075.84 4082.84 "Андрей Тарицын" Она начала работать под Linux, под macOS.
4082.84 4085.84 "Андрей Тарицын" И, скажем так, популярность пошла.
4085.84 4093.84 "Андрей Тарицын" Я узнал, что React.net и JavaScript с фичером стали пользоваться крупные игроки.
4093.84 4095.84 "Андрей Тарицын" У нас, например, это была афиша.
4095.84 4099.84 "Андрей Тарицын" Они держали совершенно бешеную нагрузку на своем сайте.
4099.84 4106.84 "Андрей Тарицын" И поэтому где-то в 2017-2019 году я проводил оптимизации большие в свитчере.
4106.84 4108.84 "Андрей Тарицын" Именно с точки зрения производительности.
4108.84 4110.84 "Андрей Тарицын" Уменьшал локации.
4110.84 4114.84 "Андрей Тарицын" Плюс мы делали доработку самого React.net с точки зрения производительности.
4114.84 4119.84 "Андрей Тарицын" Я участвовал, Даниил Соколюк из Rambler участвовал в этой доработке.
4119.84 4123.84 "Андрей Тарицын" И была у меня придумана такая штука, как предварительная компиляция.
4123.84 4132.84 "Андрей Тарицын" То есть, в принципе, некоторые движки могут скомпилировать скриптовый код в бинарное представление.
4132.84 4136.84 "Андрей Тарицын" Его можно сохранить, чтобы инициализировать другие движки очень быстро.
4136.84 4140.84 "Андрей Тарицын" И как раз у нас там использовался pooling движков из React.net.
4140.84 4142.84 "Андрей Тарицын" И вот эта штука очень хорошо пошла.
4142.84 4145.84 "Андрей Тарицын" Потом, к сожалению, это все начало падать.
4145.84 4147.84 "Андрей Тарицын" Популярность всего этого.
4147.84 4154.84 "Андрей Тарицын" В основном из-за такой вещи, что в чакре пошла очень плохая поддержка Linux.
4154.84 4156.84 "Андрей Тарицын" То есть, там шли ошибки в Linux.
4156.84 4158.84 "Андрей Тарицын" Где-то начиная с середины 2018 года.
4158.84 4161.84 "Андрей Тарицын" То есть, в самой чакре были ошибки.
4161.84 4163.84 "Андрей Тарицын" А потом уже чакра как-то сошла.
4163.84 4167.84 "Андрей Тарицын" Но по-прежнему свитчер используется.
4167.84 4172.84 "Андрей Тарицын" То есть, в основном его используют Jint и SV8 скрипт.
4172.84 4178.84 "Анатолий Кулаков" Слушай, скажи, а ты в общем перевел уже некоторые примеры того, как ты использовал и другие проекты.
4178.84 4181.84 "Анатолий Кулаков" А можешь еще придумать, для чего люди обычно используют свитч?
4181.84 4186.84 "Анатолий Кулаков" То есть, в каких стандартных ситуациях можно было бы посмотреть на эту библиотеку для своих нужд?
4186.84 4188.84 "Андрей Тарицын" Стандартные ситуации особо не подходят.
4188.84 4190.84 "Андрей Тарицын" Потому что нужно этот код модифицировать.
4190.84 4193.84 "Андрей Тарицын" То есть, обычно у нас сейчас чистого кода нет.
4193.84 4195.84 "Андрей Тарицын" У Andrew Locke, кстати, был чистый код.
4195.84 4198.84 "Андрей Тарицын" Вот это Prism, там чистый Ecma скрипт код.
4198.84 4206.84 "Андрей Тарицын" А от JavaScript в библиотеке они расстоятся или с обращением к DOM API, или к нодовскому API.
4206.84 4209.84 "Андрей Тарицын" То есть, вот это API нужно выпилить и заменять чем-то своим.
4209.84 4212.84 "Андрей Тарицын" То есть, здесь использовать Interop нужно.
4212.84 4213.84 "Анатолий Кулаков" Понятно.
4213.84 4218.84 "Андрей Тарицын" Сейчас в свитчере Interop ограничен только объектами и типами.
4218.84 4220.84 "Андрей Тарицын" Он плохо работает с коллекцией.
4220.84 4223.84 "Андрей Тарицын" Вот это, к сожалению, его недостаток.
4223.84 4227.84 "Андрей Тарицын" То есть, это идея для дальнейшего развития его в этом плане.
4227.84 4239.84 "Андрей Тарицын" Просто хочу сказать, например, у нас в сообществе MSK.NET люди начинали использовать свитчер в своих проектах.
4239.84 4249.84 "Андрей Тарицын" Например, Андрей Курыш, он писал какую-то библиотеку, использующую нодовские пакеты.
4249.84 4252.84 "Андрей Тарицын" Он не смог им пользоваться.
4252.84 4255.84 "Андрей Тарицын" Потому что нужно было их приспособить.
4255.84 4259.84 "Андрей Тарицын" Нужно было вырезать все нодовские API оттуда и чем-то их заменить.
4259.84 4262.84 "Андрей Тарицын" Он стал использовать непосредственный вызов процесса нода.
4262.84 4266.84 "Андрей Тарицын" То есть, там есть Jaring, например, библиотека.
4266.84 4269.84 "Андрей Тарицын" Jaring JavaScript Node.js, как она так называется.
4269.84 4273.84 "Андрей Тарицын" Есть модуль такой в свитчере на ее основе.
4273.84 4277.84 "Андрей Тарицын" Она позволяет использовать всю эту нодовскую инфраструктуру.
4277.84 4283.84 "Андрей Тарицын" То есть, фишка в том, что можно вполне использовать свитчер, если у тебя чистый код JavaScript.
4283.84 4286.84 "Андрей Тарицын" Если там какие-то сторонние обиды, то ты должен их доработать.
4286.84 4288.84 "Андрей Тарицын" Про мотивацию сказать.
4288.84 4292.84 "Андрей Тарицын" Вот именно случай, когда в библиотеку идет лес, которая была прямым портом.
4292.84 4297.84 "Андрей Тарицын" То есть, люди сидели и полностью переписывали JavaScript код на DootNet.
4297.84 4303.84 "Андрей Тарицын" Они просто не успевали догонять лес.js в библиотеку.
4303.84 4305.84 "Андрей Тарицын" Они не успевали ее портировать.
4305.84 4307.84 "Андрей Тарицын" Ну да, неудивительно.
4307.84 4314.84 "Андрей Тарицын" Сейчас фронтенд развивается с такой скоростью, что практически нельзя сделать актуальный порт.
4314.84 4328.84 "Андрей Тарицын" Основное применение JavaScript Engine и свитчера - это делать быстрый запуск изменений, которые появились в нодовском модуле.
4328.84 4330.84 "Андрей Тарицын" Это писать гораздо дешевле.
4330.84 4335.84 "Андрей Тарицын" То есть, брать JavaScript код, дорабатывать его и запускать его в DootNet через свитчер.
4335.84 4337.84 "Анатолий Кулаков" Да, это хорошее позиционирование.
4337.84 4339.84 "Андрей Тарицын" Вот это одно из применений.
4339.84 4347.84 "Андрей Тарицын" Но есть люди, которые запускают небольшие куски кода, но, как правило, небольшие куски кода можно переписать сразу на DootNet.
4347.84 4353.84 "Андрей Тарицын" Если у тебя есть какая-то библиотека на JavaScript, которую тебе дорого переписывать, то ты можешь ее запустить.
4353.84 4356.84 "Анатолий Кулаков" Хорошо, расскажи про планы по развитию.
4356.84 4359.84 "Анатолий Кулаков" Есть ли у тебя какие-нибудь идеи, что будет дальше?
4359.84 4361.84 "Андрей Тарицын" Планы следующие.
4361.84 4366.84 "Андрей Тарицын" Интерфейс мы не можем менять в пределах текущей версии.
4366.84 4369.84 "Андрей Тарицын" Должна быть следующая версия, четвертая.
4369.84 4376.84 "Андрей Тарицын" Именно вот эта библиотека, модуль JavaScript Engine Switcher Core, он...
4376.84 4380.84 "Андрей Тарицын" Есть интерфейсы, которые не должны меняться в пределах.
4380.84 4384.84 "Андрей Тарицын" Первое, что я планирую сделать, это доработать Interol.
4384.84 4395.84 "Андрей Тарицын" Интерол взаимодействует с DootNet типами во всех движках релизов по-разному, поэтому это довольно сложная задача, но без нее нельзя будет сделать промиссы.
4395.84 4410.84 "Андрей Тарицын" И есть сейчас очень большой кусок, он назрел, потому что появилось в ClearScript, например, в Chakra, в принципе, оно давно есть, и в Jint, и поддержка ECMAScript модулей.
4410.84 4416.84 "Андрей Тарицын" Следующий серьезный шаг - это доработка Interol и ECMAScript модулей реализации.
4416.84 4418.84 "Андрей Тарицын" Именно по стандарту.
4418.84 4422.84 "Андрей Тарицын" Может быть, использовать старые CommonJS модули.
4422.84 4424.84 "Андрей Тарицын" Вот такие планы есть.
4424.84 4425.84 "Андрей Тарицын" Отлично.
4425.84 4435.84 "Андрей Тарицын" Естественно, параллельно всему к модулям, скорее всего, понадобится асинхронность, те же промиссы реализовать, но все это упирается в Interol.
4435.84 4442.84 "Андрей Тарицын" Нужно сделать Interol, но есть с этим проблемы, потому что работа с теми же массивами реализована везде по-разному.
4442.84 4446.84 "Андрей Тарицын" Внутреннее представление движков у всех разное.
4446.84 4448.84 "Андрей Тарицын" Это довольно серьезная задача.
4448.84 4456.84 "Андрей Тарицын" Пока базовых возможностей всем хватает, но многие хотят иметь модули и работать с промиссами.
4456.84 4459.84 "Анатолий Кулаков" Ясно. Спасибо большое, Андрей, что зашел.
4459.84 4461.84 "Анатолий Кулаков" Все, пока.
4461.84 4462.84 "Андрей Тарицын" Пока.
4462.84 4467.84 "Анатолий Кулаков" Вот такая интересная библиотечка, спасибо, Андрей, что познакомил нас с ней.
4467.84 4473.84 "Анатолий Кулаков" Надеюсь, для кого-то это была полезная информация, как для меня, потому что я о ее существовании раньше не знал.
4473.84 4476.84 "Анатолий Кулаков" Теперь попробуй присмотреться к своим проектам.
4476.84 4479.84 "Анатолий Кулаков" У меня есть как раз подходящее для нее использование.
4479.84 4481.84 "Игорь Лабутин" Окей, поехали дальше.
4481.84 4483.84 "Игорь Лабутин" Я обещал, что мы поговорим про Visual Studio.
4483.84 4490.84 "Игорь Лабутин" Мы действительно немножко отложили этот момент, но Visual Studio 17.2 тоже вышла.
4490.84 4496.84 "Игорь Лабутин" За то время, пока мы не писали выпуски, то бишь, с прошлого раза вышло, аж два превью успело.
4496.84 4499.84 "Игорь Лабутин" 17.3 и 17.4.
4499.84 4506.84 "Игорь Лабутин" В 17.3 завезли фичу под громким названием New Code Search Experience.
4506.84 4510.84 "Игорь Лабутин" По факту, Microsoft объединила два диалога вместе.
4510.84 4514.84 "Игорь Лабутин" То есть, в студии было два способа поиска.
4514.84 4526.84 "Игорь Лабутин" Во-первых, мы могли поискать по именно менюшкам, настройкам и так далее с помощью штуки под названием Visual Studio Search, которая вызывалась shortcut'ом Ctrl+Q стандартным.
4526.84 4532.84 "Игорь Лабутин" Это был поиск наверху в строке, заголовка окошечкой где-то там рядышком.
4532.84 4543.84 "Игорь Лабутин" Либо у вас был тоже довольно часто используемый фича под названием Go To All, который Ctrl+T, где можно было поискать по вашим там мемберам, файликам, классам и так далее.
4543.84 4551.84 "Игорь Лабутин" Теперь они объединены вместе и открывается одно и то же окошечко, просто там немножко разные вкладочки, в зависимости от того, каким shortcut'ом вы это вызовете.
4551.84 4557.84 "Игорь Лабутин" Плюс появилась там возможность чуть получше пофильтровать варианты.
4557.84 4560.84 "Игорь Лабутин" Он там чуть по-другому сортирует вывод.
4560.84 4565.84 "Игорь Лабутин" Но там есть отдельная статейка, где нарисованы и написаны красивые гифки приложены.
4565.84 4568.84 "Игорь Лабутин" Поэтому можно посмотреть, как теперь это выглядит.
4568.84 4572.84 "Игорь Лабутин" Улучшение не такое, что прям супер-мега-большое, но тем не менее приятнее.
4572.84 4574.84 "Игорь Лабутин" Говорят, стало гораздо быстрее.
4574.84 4576.84 "Игорь Лабутин" Так что, наверное, они как-то лучше все это индексируют.
4576.84 4587.84 "Игорь Лабутин" Штуку надо включать в Preview Features, то если вы используете превью-версию Visual Studio, сходите в настройки, когда вы обновитесь до 17.3, и включите эту штуку в превью.
4587.84 4589.84 "Игорь Лабутин" Также улучшили Git Tooling.
4589.84 4593.84 "Игорь Лабутин" Там улучшили возможность стейджинга построчного.
4593.84 4619.84 "Игорь Лабутин" Плюс для скорости теперь можно включать/выключать, как у них написано, Git Commit Graph, то есть отображение, собственно, графа коммитов, а не просто, видимо, линейной истории, ну, не уж линейной, для того, чтобы в каких-то, видимо, сложных репозиториях не тратил время на рендер всех этих запутанных, запутанной лапши из бранчей, кто в кого мержился, а просто показывал вам там, Commit Graph текущего бранча, например, если вам интересен только текущий бранч.
4619.84 4626.84 "Игорь Лабутин" В тесту LAH обещают гораздо более быстрый код-ковередж, потому что они что-то там поменяли в движке вокруг этого всего.
4626.84 4629.84 "Игорь Лабутин" Это все было внесено в 17.3.
4629.84 4650.84 "Игорь Лабутин" После этого буквально в течение недели вышло 17.4, в которой, в общем-то, судя по Release Notes, не было возможности выйти на bugfixes, то есть, видимо, в 17.3 там что-то настолько все поломали в превью-версии, что пришлось выпускать 17.4, причем bugfixes в основном вокруг C++, так что если вы на .NET, то, скорее всего, может быть, 17.3 тоже неплохо.
4650.84 4654.84 "Игорь Лабутин" Но если вы на превью-канале, наверное, лучше сдать последний превью,
4654.84 4663.84 "Анатолий Кулаков" тем более, когда такой bugfix выходит. Ну да, если вы на превью-канале сидите, то, скорее всего, всякими багами и быстрым обновлением на самой последней версии вас уже не испугать.
4663.84 4665.84 "Игорь Лабутин" Так что пользуйтесь.
4665.84 4674.84 "Игорь Лабутин" Говорят, что, в принципе, довольно неплохо работает даже превью-канал, довольно стабилен, и, ну, опять же, можете использовать все эти новые фичи.
4674.84 4675.84 "Игорь Лабутин" Приятно.
4675.84 4676.84 "Анатолий Кулаков" Это точно.
4676.84 4685.84 "Анатолий Кулаков" Так, дальше прокатилась волна интересной библиотечки, которая называется FastendPoints, поэтому давайте вместе с вами сегодня на нее посмотрим.
4685.84 4691.84 "Анатолий Кулаков" Прежде всего, это очень легковесный REST API framework для ASP.NET.
4691.84 4696.84 "Анатолий Кулаков" Он реализует подход RequestedPointResponse.
4696.84 4700.84 "Анатолий Кулаков" Такой довольно обычный, довольно понятный подход.
4700.84 4702.84 "Анатолий Кулаков" Ничего здесь нового нет.
4702.84 4708.84 "Анатолий Кулаков" И позиционирует себя как альтернативу для Minimal API и MVC Controllers.
4708.84 4710.84 "Анатолий Кулаков" Ну, MVC Controllers еще понятно.
4710.84 4715.84 "Анатолий Кулаков" Мы, в принципе, давно с ними жили, и альтернатива там напрошелась чуть ли не каждый релиз.
4715.84 4723.84 "Анатолий Кулаков" Ну вот Minimal API, с которой вот просто недавно зарелизили, там кучу хвалили REST, кучу статей, кучу всего.
4723.84 4726.84 "Анатолий Кулаков" И здесь вдруг сразу альтернатива.
4726.84 4729.84 "Анатолий Кулаков" Вот это вот такой дерзкий интересный выпад.
4729.84 4732.84 "Анатолий Кулаков" Как раз, наверное, из-за него и хотелось бы обсудить эту библиотечку.
4732.84 4736.84 "Анатолий Кулаков" Что же она нам предлагает взамен нашего всеми хвалебного Minimal API.
4736.84 4740.84 "Анатолий Кулаков" А предлагает она довольно интересную концепцию.
4740.84 4743.84 "Анатолий Кулаков" Не знаю, опять же, может быть она многим не подойдет.
4743.84 4746.84 "Анатолий Кулаков" Вы сейчас сразу не ругайтесь, а просто дослушайте до конца.
4746.84 4754.84 "Анатолий Кулаков" Предлагает она нам создавать на каждый endpoint, то есть на каждый route, на каждый endpoint в вашем проекте, отдельный классик.
4754.84 4765.84 "Анатолий Кулаков" То есть то, что раньше у нас было в MVC Controllers отдельным методом, в одном большом классе, здесь непосредственно сразу выделяется целый класс, полноценный класс для этого.
4765.84 4770.84 "Анатолий Кулаков" Этот класс принимает, имеет две зависимости.
4770.84 4779.84 "Анатолий Кулаков" Во-первых, это отдельная DTO, которая называется, это отдельная DTO, которая представляет реквест, и, соответственно, отдельная DTO, которая представляет респонс.
4779.84 4783.84 "Анатолий Кулаков" Логично, реквест это то, что к вам входит, респонс это то, что от вас уходит.
4783.84 4798.84 "Анатолий Кулаков" Внутри этого класса есть стандартный метод handleAsync, который принимает реквест и должен отправить обратно респонс, каким-то образом обработав входящие данные и отформатировав обратно выходящие данные.
4798.84 4820.84 "Анатолий Кулаков" И также у этого классика есть вспомогательные методы, метод конфигур, внутри которого происходит мета-описание того, какой глагол мы будем использовать для этого метода, на какой роут мы его замапим, какие там роли и всякие различные security-атрибуты мы на этот роут навесим.
4820.84 4826.84 "Анатолий Кулаков" И, соответственно, каждый endpoint у нас представлен вот таким классиком и парочкой DTO-шек к нему.
4826.84 4836.84 "Анатолий Кулаков" И автор утверждает, что это мега удобно, мега гибко и очень читабельно, потому что вся обработка у вас заключена, по сути, в одном единственном классике.
4836.84 4841.84 "Анатолий Кулаков" И, соответственно, все атрибуты у нас переделаны в методы.
4841.84 4851.84 "Анатолий Кулаков" Какие же еще фичи, кроме того, что у нас все endpoints превращаются в отдельные классы, и якобы это удобно, какие же еще фичи, давайте посмотрим, оно пропагандирует.
4851.84 4860.84 "Анатолий Кулаков" Во-первых, это attribute-free подход, то есть там нет атрибутов, там все задается с помощью методов, то, что вы ставите там роуты, то есть вы навешиваете security-атрибуты.
4860.84 4867.84 "Анатолий Кулаков" Это все, по правде, делается методами в этом конфигурметоде.
4867.84 4880.84 "Анатолий Кулаков" И, соответственно, у вас нет никаких ограничений на атрибуты, что там нельзя указывать типы, которые вы знаете только в runtime, нельзя там загружать из конфигов какие-то, допустим, роуты, еще что-то.
4880.84 4885.84 "Анатолий Кулаков" Но, в принципе, все эти ограничения сняты, потому что это обычные методы, вы можете там делать все, что захотите.
4885.84 4897.84 "Анатолий Кулаков" Из коробки поддерживается микрософтовский контейнер с зависимостей, которые там есть, а также они хвалятся тем, что у них очень хорошая интеграция с другими библиотеками.
4897.84 4911.84 "Анатолий Кулаков" Например, сразу же мы знаем про fluent validation, про Swagger, про SiriLog и про несколько других библиотек, которые, в принципе, и так по дефолту новые проекты все используют.
4911.84 4917.84 "Анатолий Кулаков" А здесь прям с ними большая плотная интеграция на полную катушку, что тоже, в принципе, не может не радовать.
4917.84 4921.84 "Анатолий Кулаков" Сфера безопасности тоже покрыта очень хорошо.
4921.84 4927.84 "Анатолий Кулаков" Там по дефолту поддерживается много известных провайдеров аутентификации.
4927.84 4931.84 "Анатолий Кулаков" Есть методы по управлению JVT-барьерами.
4931.84 4938.84 "Анатолий Кулаков" Также есть методы и вспомогательные классы для настройки политик, пермиссий, ролей, клеймов.
4938.84 4948.84 "Анатолий Кулаков" Также есть возможность декларативно описывать security policy и цеплять их к каждому отдельному endpoint, в зависимости от роута, от каких-то еще дополнительных условий.
4948.84 4955.84 "Анатолий Кулаков" Поддерживается API-версионирование, rate-limiting, кэширование, servers and events.
4955.84 4967.84 "Анатолий Кулаков" И имеется удобная инфраструктура для тестирования, то есть уже тесты вы сможете писать на все ваши роутинги, кэши и прочие JVT-барьеры, что тоже не может не радовать.
4967.84 4970.84 "Анатолий Кулаков" И в частности, перформанса там тоже все довольно хорошо.
4970.84 4979.84 "Анатолий Кулаков" Если мы сравним со старичком MMC-контроллеров, то FastEndpoint выдает на 45 тысяч реквестов в секунду больше.
4979.84 4983.84 "Анатолий Кулаков" Естественно, на каком-то примитивном сампле, но все же.
4983.84 4992.84 "Анатолий Кулаков" И не уступает минимум API, там буквально на 2 тысячи быстрее минимум API, не так уж и много, но главное, что не медленнее.
4992.84 4995.84 "Анатолий Кулаков" Это тоже, конечно, может порадовать.
4995.84 5004.84 "Анатолий Кулаков" Но мне кажется, что главная фишка его - это все-таки в этом подходе, когда вы каждый endpoint переворачиваете и делаете его отдельным классом.
5004.84 5011.84 "Анатолий Кулаков" Вот этот подход, если вам нравится, если он вам подходит, то в принципе перформанс здесь уже будет не главным.
5011.84 5017.84 "Игорь Лабутин" Выглядит интересно, тем более, что я вот сейчас посмотрел на GitHub, там уже вышла четвертая версия.
5017.84 5023.84 "Игорь Лабутин" Проект всего примерно около полугода, в сентябре 2021 года первый раз был опубликован на GitHub версия 1.0.
5023.84 5027.84 "Игорь Лабутин" Сейчас уже версия 4.0, в начале апреля была зарележена.
5027.84 5033.84 "Игорь Лабутин" Так что звездочек пока не так, чтобы много, но идея интересная, может быть что-то взлетит.
5033.84 5038.84 "Игорь Лабутин" Для каких-то простых, например, задач, где не хочется прям городить что-то большое и сложное.
5038.84 5043.84 "Анатолий Кулаков" Мне кажется, как-то наоборот, для простых задач тебе и minimal API подойдет.
5043.84 5058.84 "Анатолий Кулаков" А вот когда у нас уже появляются большие интерфейсные системы, когда мы уже начинаем медиатор какой-то туда засовывать, какую-то внутреннюю шинку, пытаемся городить абстракции, то в конце концов я очень часто вижу, что контроллеры и выливаются в нечто подобное.
5058.84 5089.84 "Анатолий Кулаков" То есть когда нам нужен некий класс, который просто по известному роту, по известному глаголу примет какую-то DTO, сделает ей базовые проверки, может быть даже без проверок просто закинет дальше в шинку, а там ее уже встретят и Fluent Validator, и Tracer, и Logger, и так далее, и по цепочке по этой шинке пробежится, запроцессит, вернет нам результат, и вот задача этого класса теперь - отформатировать этот результат обратно и отдать этот результат клиенту.
5089.84 5104.84 "Анатолий Кулаков" В общем, когда у тебя именно вычленяется единственность ответственности, и ты понимаешь, что твой endpoint должен отвечать только за такие базовые примитивные вещи, то вот мне кажется именно там и сыграет вот это четкое выделение в один единственный класс.
5104.84 5106.84 "Игорь Лабутин" Может быть.
5106.84 5131.84 "Игорь Лабутин" То ли я пока не видел таких огромных проектов, где такое вырождается, ну где нужно такое, то ли у нас просто какие-то другие подходы были, но в целом да, действительно, может быть это тоже вариант, если у вас контроллеры очень тонкие, и они занимаются только тем, что кидают данные дальше в pipeline обработки, чем бы он ни был, то какая вам разница, какие у вас контроллеры, в общем-то, может быть действительно на такой штуке тоже можно удобно сделать.
5131.84 5134.84 "Игорь Лабутин" Ну чё, с Microsoft закончили на сегодня?
5134.84 5136.84 "Игорь Лабутин" Ну, кажется, что да.
5136.84 5176.84 "Игорь Лабутин" Ну, на самом деле, следующая и последняя на сегодня тема, она чуть-чуть тоже касается Microsoft, потому что автор работает вроде как в Microsoft, но тем не менее, это его сторонний проект, мы говорим про приложение под названием DevToys, то есть, возможно, вы слышали о такой приложении под названием PowerToys, это когда-то давно, в какой-то 2000-й, наверное, винде или около того, в общем, в какой-то очень старой винде была приложение, которое позволяло вам расширить функциональность винды, там всяческие, не знаю, красивее всякие скриншотики делать, не знаю, там линеечкой на экране что-то мерить, ну в общем-то, такие, добавляло функциональности в оконный менеджер винды, назовем это так.
5176.84 5180.84 "Анатолий Кулаков" Но мы же с тобой обсуждали PowerToys даже для десятки, с довольно интересными фичами.
5180.84 5187.84 "Игорь Лабутин" Да, PowerToys был реанимирован для десятки, у меня он стоит, и я им активно пользуюсь, для некоторых фич.
5187.84 5191.84 "Игорь Лабутин" У меня не все заенеблены, но действительно, некоторые вполне прикольные.
5191.84 5207.84 "Игорь Лабутин" Так вот, этот автор решил, что чего-то похожего не хватает для разработчиков, то есть, у разработчиков всегда возникает какое-то большое количество мелких задачек, которые нужно делать, и для них приходится использовать всякие разные тулы.
5207.84 5223.84 "Игорь Лабутин" И он написал свой один тул, называется DevToys, написан полностью на C#, это UI-ный тул под винду, соответственно, который написан на XAML, в XAML, то есть, в общем, открытый проект с открытым исходным кодом, можно посмотреть, как все это сделано, возможно, оттуда что-то подергать.
5223.84 5233.84 "Игорь Лабутин" И он предоставляет огромное количество таких, довольно, в общем-то, простых тулов, которые, ну, наверное, довольно много, довольно часто могут быть нужны обычным разработчикам.
5233.84 5240.84 "Игорь Лабутин" И вместо того, чтобы искать и собирать их по разным другим тулам, вы можете это использовать все в одном центральном месте.
5240.84 5242.84 "Игорь Лабутин" Давай по тулам, наверное, пробежимся немножко.
5242.84 5245.84 "Игорь Лабутин" Да, давай посмотрим.
5245.84 5252.84 "Игорь Лабутин" Так, ну что, список, оно не совсем по алфавиту, ну, давай вот как он у них на сайте указан, так и пробежимся.
5252.84 5254.84 "Игорь Лабутин" Base64 Encoder Decoder.
5254.84 5263.84 "Анатолий Кулаков" Нужная штука, да, я часто, когда дебажу, всякие ответы, пересылки и прочее по HTTP, часто пользуюсь.
5263.84 5271.84 "Анатолий Кулаков" Ну, опять же, и у меня нет какого-то инструмента, все время хожу на какие-то сайтики, и там это дело декодирую, форматирую.
5271.84 5280.84 "Игорь Лабутин" Я для этого пользуюсь Notepad++, там, соответственно, по-моему, даже без плагинов, или там есть в штатной поставке плагин, который умеет Base64 Encoder Decoder, а также все остальное, там, URU Encoding и вот это все.
5280.84 5285.84 "Игорь Лабутин" Поэтому мне в этом смысле обычно хватает Notepad++.
5285.84 5291.84 "Игорь Лабутин" Но, в принципе, если будет единый тул, где все остальное еще будет полезно, может быть, и туда буду ходить.
5291.84 5298.84 "Игорь Лабутин" Хотя у меня просто обычно бывает кейс, что если в Base64 внутри содержится какая-нибудь строка, то частенько бывает с ней что-нибудь надо сделать.
5298.84 5303.84 "Игорь Лабутин" Вот, дополнительный и так далее, Notepad++, ну вот ты уже вроде в нем, можно что-то делать.
5303.84 5307.84 "Игорь Лабутин" Ладно, Xib, Xib, Encoder Decoder.
5307.84 5311.84 "Игорь Лабутин" Тут я не знаю, насколько эта штука нужна, то есть мне редко приходят прям архивы в формате .gz.
5311.84 5315.84 "Игорь Лабутин" Сейчас это не такая популярная штука, в основном просто обычный Xib.
5315.84 5324.84 "Игорь Лабутин" То есть это только если вы, там, не знаю, как мне кажется, перехватили какой-нибудь трафик, не знаю, в AirShark в Xib, и вам нужно его раззибовать, ну вот, пригодится.
5324.84 5328.84 "Анатолий Кулаков" Ну да, я, насколько помню, что мне в последний раз такая нужна была как раз в AirShark.
5328.84 5335.84 "Игорь Лабутин" Хэш-генератор, то есть подсчет различного рода хэшей, от, видимо, строчек.
5335.84 5337.84 "Анатолий Кулаков" Ну полезная штука, почему бы и нет.
5337.84 5356.84 "Игорь Лабутин" Да, для того, у меня для, собственно, этих целей служит LinkPad, то есть когда мне нужно поставить какой-нибудь хэш, я обычно, ну, либо нахожу что-нибудь онлайн, да, либо у меня, по-моему, в LinkPad есть какая-то пара хилперов, типа SHA256 или еще что-то в таком духе, которые с помощью дотнетных, соответственно, функций это все считают.
5356.84 5370.84 "Анатолий Кулаков" У меня часто такая штука возникает для подсчета хэша файлов, в общем, поэтому у меня на PowerShell есть уже набор утилиток, которые как раз-таки для каталога, для файлов, и все почитывают и сравнивают, и выдают результат сравнения уже хэшей, например.
5370.84 5372.84 "Игорь Лабутин" Угу, интересно.
5372.84 5378.84 "Игорь Лабутин" PowerShell, кстати, да, я не думал, надо будет посмотреть, может, в PowerShell это будет для файликов здесь удобнее.
5378.84 5381.84 "Игорь Лабутин" А UUID генератор? Тебе GUIDы нужны?
5381.84 5397.84 "Анатолий Кулаков" Ну, GUIDы мне очень часто нужны, да, потому что такая универсальная штука, и он и уникальный, и интерпретируемый, и еще можно его использовать в качестве пароля, если быстренько надо что-то, где-то пароль вставить, и не сильно важно заморачиваться его секьюрностью, GUID тоже идеальное решение.
5397.84 5405.84 "Анатолий Кулаков" Но здесь меня абсолютно PowerShell спасает, потому что это такой же C#, там пишешь GUID, не GUID, и все, в одну строчку у тебя красивый-красивый гундик.
5405.84 5419.84 "Игорь Лабутин" Ну, я так понимаю, что там есть единственная тонкость, бывают места, где подходит стандартный C# вариант GUID на 2-стринг, бывает, где он все-таки нужен какой-то другой, ну, там, не знаю, руками его в фигурные скобочки обернуть, там кавочки добавить, еще что-нибудь в таком духе.
5419.84 5427.84 "Игорь Лабутин" Понятно, что это делается элементарно, но есть вот в таких генераторах обычный вариант выбора формата, так скажем, может быть, спасет.
5427.84 5429.84 "Игорь Лабутин" Плюс эта штука имеет там генератор...
5429.84 5433.84 "Анатолий Кулаков" Ну, ты же C#-ист, и туда передаешь в 2-стринг определенный параметр, и все, и вот этот генератор.
5433.84 5441.84 "Игорь Лабутин" О, я буду, я помнятно изучу, мне придется в это, в Docs.Microsoft.com лезть, вспоминать, какие там параметры нужно передать в GUID.2-string.
5441.84 5445.84 "Анатолий Кулаков" Ну, вот если ты там часто эти пользуешься, то ты запомнишь, что там, например, штуки 3-4 нужных.
5445.84 5448.84 "Игорь Лабутин" Да, лорен ипсун генератор.
5448.84 5450.84 "Анатолий Кулаков" Вот эта штука никогда не пригождалась.
5450.84 5474.84 "Игорь Лабутин" Да, вот сколько я не пишу на дотнете, да и на других языках тоже, ни разу, я вообще ни разу не использовал этот лорен ипсун текст, который, видимо, он все-таки нужен, когда ты действительно какие-нибудь там моки делаешь с точки зрения UI, а я обычно туда пишу что-то более простое, типа, тут эта кнопка, это поле для ввода, ну или какой-то такой.
5474.84 5481.84 "Анатолий Кулаков" Да, мне кажется, это больше так для UI-щиков, чтобы там форматирование, размеры проверить, layout, resize.
5481.84 5489.84 "Игорь Лабутин" Окей, так, checksum, отдельная штука для checksum файлов, это, видимо, похоже на hash-генератор, но как бы немножко другое.
5489.84 5493.84 "Игорь Лабутин" Ну, мы уже поговорили, что checksum файлы, да, удобно бывает, нужно нового.
5493.84 5497.84 "Игорь Лабутин" Для файлов, вероятно, удобнее, возможно, PowerShell в этом смысле.
5497.84 5500.84 "Игорь Лабутин" JSON форматер, SQL форматер и XML форматер.
5500.84 5513.84 "Анатолий Кулаков" Ну, форматеры часто нужны, я для этих целей обычно Visual Studio Code использую, у него много там подсветок, форматеров для как раз форматирования и быстрого редактирования файликов, само этого.
5513.84 5522.84 "Игорь Лабутин" Ну, я опять же много чего делаю в NuttyPad, в NuttyPad++, тоже плагинчиков хватает для такого форматирования, не все он форматирует идеально, может быть, тут будет чуть получше.
5522.84 5526.84 "Игорь Лабутин" Посмотрим, конвертеры с JSON в ямоли и обратно.
5526.84 5533.84 "Анатолий Кулаков" Ну, было время, да, пригождался пару раз, не то чтобы часто, но нужная штука и в принципе в интернете гуглиться довольно быстро.
5533.84 5538.84 "Игорь Лабутин" Ну, да, точно так же jvt-декодер, это jvt, ну, я так понимаю, что это оно от jvt.io?
5538.84 5540.84 "Анатолий Кулаков" Да, да, скорее всего.
5540.84 5547.84 "Игорь Лабутин" Которым пользуются все, но в принципе, если вы почему-то делаете это все offline, и вам там, не знаю, зачем-то нужно offline, вот можно использовать.
5547.84 5557.84 "Анатолий Кулаков" Или опять же, если у тебя есть инструмент, и тебе не надо открывать браузер, открывать отдельный табик, быстренько нажал там hotkey, у тебя вылетело окошко, ты туда вставил, и все счастливы.
5557.84 5571.84 "Игорь Лабутин" Да, да, да. Так, ColorBlind, это симулятор для color blindness, то есть симулятор того, как выглядит тот или иной вариант, видимо, цветов при различных вариантов цветовой слепоты.
5571.84 5579.84 "Анатолий Кулаков" Ну, это полезная штука, я не занимаюсь UI, но мне кажется, любой UI-щик должен такое под рукой иметь.
5579.84 5586.84 "Игорь Лабутин" Да, у меня такая же ситуация, я UI особо не касаюсь, но действительно, есть точно власти, где это нужно.
5586.84 5605.84 "Игорь Лабутин" Так, еще пачка конвертеров, это png, jpeg и вообще какой-то дженериковый имидж-конвертер. Ну, я, опять же, с изображения работаю мало, поэтому, если надо, что-нибудь онлайне сконвертчу, ну, либо какими-нибудь редакторами, а там стоит какой-нибудь png.net, можно сконвертить, но здесь, наверное, можно, если вы много с этим работаете, пригодиться.
5605.84 5612.84 "Игорь Лабутин" Markdown preview, не знаю, зачем это в этой туле, потому что, ну, превью должен быть в том редакторе, где вы редактируете Markdown.
5612.84 5626.84 "Анатолий Кулаков" Да, наверное, может быть, да и не знаю, где можно встретить такой Markdown, у которого сейчас нет превью, там, допустим, даже самый GitHub, он тебе показывает, те же самые Вики, Confluence и прочая глупость, они тебе все и превью, и редактор дают.
5626.84 5633.84 "Анатолий Кулаков" Ну, в общем-то, я для Markdown использую специализированные редакторы, на крайний случай Visual Studio Code, и там, естественно, есть какое-то превью.
5633.84 5639.84 "Игорь Лабутин" Да, даже в обычной Visual Studio, как мы обсуждали в прошлый раз, завезли экстернум для всего этого, есть и хорошо работает.
5639.84 5641.84 "Игорь Лабутин" А RegEx-тестер?
5641.84 5649.84 "Анатолий Кулаков" Мне нравится JetBrains, от Resharper, а RegEx-тестер, в принципе, всегда им пользуюсь и, в принципе, не знаю, что мне еще от него нужно.
5649.84 5650.84 "Анатолий Кулаков" Работает идеально.
5650.84 5663.84 "Игорь Лабутин" Я как раз обычно хожу онлайн для этого, RegEx-101, по-моему, но мне настолько редко это надо, вот, по-моему, я неделю назад этим пользовался, а перед этим я этим пользовался около года назад.
5663.84 5667.84 "Игорь Лабутин" То есть, это настолько редко, что, в принципе, сайт у меня более чем спасает.
5667.84 5672.84 "Анатолий Кулаков" Нет, регулярки люблю, особенно, опять же, в PowerShell, это первое дело.
5672.84 5676.84 "Анатолий Кулаков" Чего-нибудь попарсить, что регулярки, это мое любимое дело.
5676.84 5679.84 "Анатолий Кулаков" Но, опять же, стандартного JetBrains хватает.
5679.84 5681.84 "Игорь Лабутин" Окей, Unix Timestamp Converter?
5681.84 5686.84 "Анатолий Кулаков" Ну, тоже нужная штука, да, наверное, часто пригождается, но PowerShell спасает.
5686.84 5691.84 "Игорь Лабутин" Ну, я, опять же, за таким я в онлайн хожу, потому что в моем мире это довольно редко встречается.
5691.84 5697.84 "Игорь Лабутин" У нас редко где-то используется прям Unix Timestamp, насколько я, ну, вот по тем проектам, где я участвую.
5697.84 5705.84 "Игорь Лабутин" Base Converter, ну, понятно, десятичные, шестнадцатиличные, восьмеричные, не знаю, семеричные.
5705.84 5710.84 "Анатолий Кулаков" Вот еще-то как-то давно мне ничего, кроме десятичной, не надо было, как-то справлялся.
5710.84 5716.84 "Анатолий Кулаков" Ну, шестнадцати, да, но настолько редко и настолько понятно, что, наверное, отдельного конвертера для нее не надо.
5716.84 5735.84 "Игорь Лабутин" Не, ну, какую-нибудь там десятичную, шестнадцатиличную бывает нужно перевести, потому что, например, кстати, некоторые опции вот эти флаги .NET, .NET Runtime, когда вы задаете какой-нибудь, не знаю, хип, кастомный размер хипа, либо что-нибудь в таком духе, что-то менее экзотическое, некоторые эти значения нужно указывать в шестнадцатиличном виде.
5735.84 5745.84 "Игорь Лабутин" Ну, и иногда бывает, что ты видишь какие-то байтики в Visual Studio в отладчике или в мемори, да, в дампе, нужно их конвертнуть в понятное десятичное число.
5745.84 5749.84 "Игорь Лабутин" Ну, бывает нужно шестнадцатиличное в десятичное перевести, но не более того.
5749.84 5753.84 "Анатолий Кулаков" Да, точно, я для таких целей пользуюсь стандартным Windows Калькулятором.
5753.84 5761.84 "Анатолий Кулаков" Кстати, может, кто-то не знал, но у Windows Калькулятора есть режимы, и вот у них там есть инженерный режим, простой режим, сложный режим, и есть режим для разработчиков.
5761.84 5769.84 "Анатолий Кулаков" И вот, по-моему, единственный плюс режима для разработчиков, если не ошибаюсь, то, что он умеет конвертировать в различные системы счисления.
5769.84 5772.84 "Анатолий Кулаков" Вот, им пользуюсь, прекрасно работает.
5772.84 5778.84 "Игорь Лабутин" Окей. Что-то под названием String Utilities, я не смотрел в скришотике, поэтому не знаю, что это.
5778.84 5781.84 "Игорь Лабутин" Наверное, пропустим, что можно с вот ручками сделать.
5781.84 5783.84 "Игорь Лабутин" Тут на каком-нибудь Dreaming, не знаю, подсчет слов.
5783.84 5788.84 "Анатолий Кулаков" Ну да, может, в этот верхний регистр, в нижний регистр, там, как common cases, Pascal cases.
5788.84 5792.84 "Игорь Лабутин" Подсчет слов, количество слов, частотность слов в тексте, не знаю.
5792.84 5800.84 "Игорь Лабутин" Кучка, ну, в принципе, энкодеров, которые мы уже смотрели, это вот мы говорили про B64, тут еще URU и HTML, соответственно, энкодер.
5800.84 5802.84 "Анатолий Кулаков" Ну да, да, тоже полезные штуки, почему бы и нет.
5802.84 5808.84 "Игорь Лабутин" Текст escape, unescape, и текст-компарер, ну, то есть обычный дифф.
5808.84 5824.84 "Игорь Лабутин" Вот, с одной стороны, вроде штука полезная, вроде по мелочи все они так вместе могут быть полезны, с другой стороны, я что-то не знаю, то есть, меня вот ничего не зацепило с точки зрения взять, поставить и начать пользоваться.
5824.84 5832.84 "Анатолий Кулаков" Ну, действительно, это, наверное, такая огромная сумка библиотечек, которые уже у нас есть, мы как-то их используем, мы уже как-то привыкли.
5832.84 5837.84 "Анатолий Кулаков" И то, что мы будем выбивать себя из стандартных инструментов, это, конечно, минус.
5837.84 5849.84 "Анатолий Кулаков" Но если мы все эти инструменты будем иметь под рукой, и довольно быстро запускать, довольно гибко использовать, может быть, это отдаст какие-то свои преимущества, но, опять же, может, этого не стоит.
5849.84 5852.84 "Игорь Лабутин" Ну, слушай, я вижу два сценария, где эта штука может быть полезна.
5852.84 5868.84 "Игорь Лабутин" Сценарий номер один - это если я пошел, например, на какую-нибудь, не знаю, далекую, допустим, машинку, не знаю, в проде, например, или куда-нибудь, где, в общем, у меня нет привычного девелоперского окружения, где нет моей Visual Studio, Visual Studio Code и всего остального.
5868.84 5871.84 "Игорь Лабутин" И он под ++ конфигурирован не с моим набором плагинов.
5871.84 5874.84 "Игорь Лабутин" И мне именно там нужно что-то куда-то поконвертить.
5874.84 5880.84 "Игорь Лабутин" Понятно, что я могу через клейборд или как-то закинуть к себе на комп обратно и обратно туда.
5880.84 5882.84 "Игорь Лабутин" Но бывает нужно это сделать прямо непосредственно там.
5882.84 5890.84 "Анатолий Кулаков" И в это время ты на виндовую машину ставишь гуёвое приложение из интернета, да, ни хрена по векам написанное, под штуцком пилина.
5890.84 5892.84 "Игорь Лабутин" Не обязательно его ставить.
5892.84 5899.84 "Игорь Лабутин" Я так понимаю, что его можно просто, скорее всего, скачать, и он поставится только в твой юзер.
5899.84 5903.84 "Игорь Лабутин" Ну, короче, он поставится как ClickOnce, грубо говоря, твой юзер, короче, каталог.
5903.84 5906.84 "Игорь Лабутин" И поэтому никаких прав администратора, скорее всего, для этого не нужно.
5906.84 5909.84 "Анатолий Кулаков" Да я даже не про права администратора.
5909.84 5913.84 "Анатолий Кулаков" Я про то, что ты непонятную тулзень тащишь из интернета и запускаешь её на продакшене.
5913.84 5918.84 "Игорь Лабутин" Ну ладно, продакшен я, наверное, погорячился, но фиг знает, не знаю.
5918.84 5921.84 "Игорь Лабутин" Но это, по крайней мере, то, что мне пришло в голову за 5 секунд.
5921.84 5945.84 "Игорь Лабутин" Второй сценарий, может быть, это удобная штука для, условно говоря, условно-новичков, у которых нет того самого багажа тулов с собой, которые приходят в проект и говорят, вот, бери URL оттуда, сделай ему D-код, вот там токен лежит, сделай ему JWT-декод, и ты сидишь гуглишь, как сделать то, как сделать это, а тут вроде единый тул, который умеет делать всё.
5945.84 5960.84 "Анатолий Кулаков" Да, мне тоже почему-то в голову пришли новички, которые не насобирали всего этого жизненного опыта, который точно им пригодится, и если они его насобирают прямо внутри одной тулзы, и оно у них будет под рукой, мне кажется, это довольно удобно для них.
5960.84 5978.84 "Игорь Лабутин" Ну а дальше либо тулза будет просто использоваться и полезно, либо вы поймёте, что, например, чё-то не хватает, там, не знаю, JSON форматируется не так, или настроек недостаточно, или SQL не форматируется, или ваш диалект SQL не поддерживается и форматируется как-то странно, ну и тогда вы уже начнёте искать альтернативы, точно зная, что вам надо.
5978.84 5982.84 "Игорь Лабутин" Или законтрибьюдите, потому что это штука опенсурсная, берите и контрабьюдите.
5982.84 6018.84 "Анатолий Кулаков" Я, может быть, ещё рассмотрел этот инструмент под то, чтобы заточить под себя, потому что здесь уже написан какой-то удобный UI, уже какая-то категоризация есть, уже куча полезных утилит есть, если вам чё-то не хватает, вдруг там каких-то пару инструментов здесь нет, мне кажется, отличным способом будет законтрибьюдить в этот проект, или просто сделать свой форк и добавить только то, что нужно вам, и, соответственно, уже постепенно собирать вот такой багаж вот этих полезных утилит, потому что если бы я начал собирать это всё очень-очень давно, то мне кажется, я бы сейчас насобирал именно под себя, именно для себя какой-нибудь шикарный наборчик, с которым бы никогда не расставался.
6018.84 6029.84 "Игорь Лабутин" Да, ещё, кстати, вот я сейчас читаю в описании, тут есть всякие мелочи, которые могут на самом деле немножко склонить даже меня в сторону использования этого тула.
6029.84 6039.84 "Игорь Лабутин" Например, есть такая штука под названием Smart Detection, то есть когда вы запускаете эту приложеньку, она смотрит, что у вас в клипборде, и пытается автоматически угадать, что вы хотите.
6039.84 6046.84 "Игорь Лабутин" Ну, то есть предлагая вариант, если она увидит у вас в клипборде JSON, она, скорее всего, спросит вас, вы его хотите отформатировать или в ямоль конвертнуть?
6046.84 6049.84 "Игорь Лабутин" Но точно не будет предлагать, не знаю, UID сгенерить.
6049.84 6063.84 "Анатолий Кулаков" Да, да, отличная тема, особенно если вы ещё под себя все ваши привычки подпишите, заинтерпретируете ещё имя какого-нибудь процесса, где вы сейчас находитесь, время суток и примерные ваши действия, то вообще красота будет.
6063.84 6067.84 "Игорь Лабутин" Ночью обычно я конвертирую JSON, а днём я их форматирую, ну норм.
6067.84 6070.84 "Анатолий Кулаков" Да, да, там кодирую, там декодирую.
6070.84 6072.84 "Анатолий Кулаков" Ладно, что-то мы засиделись, давай закругляться.
6072.84 6075.84 "Игорь Лабутин" Да, давай закругляться.
6075.84 6107.84 "Игорь Лабутин" Сегодня мы собрали, мне кажется, практически самый полный список обычных анонсов Microsoft, то есть вышел DotNod 7 Preview 3, зарелизился Nouget 6.2 с поддержкой Central Package Management, в C# 11 завезли некоторое количество апдейтов, это пока всё ещё превью, и все эти апдейты могут откатиться, как мы увидели с фичей про nullable-чеки, но тем не менее, пробуйте, я надеюсь, что всякие интересные штуки всё-таки будут оставаться в C# 11 и к релизу.
6107.84 6113.84 "Игорь Лабутин" MAUI добрался до релиз-кандидата номер один, ждём релиза в течение второго квартала, надеемся, что так и будет.
6113.84 6118.84 "Игорь Лабутин" Visual Studio 17.2 вышли, Preview 3 и Preview 4.
6118.84 6135.84 "Игорь Лабутин" Andrew Logs зарелизил статью про то, как запускать JavaScript внутри DotNet, и библиотечка FastendPoints, если вам хочется минимал-APIs, но как-то по-другому, тоже появилась, она всего полгода возраста, но уже выглядит неплохо и работает быстро.
6135.84 6147.84 "Игорь Лабутин" Ну и если вам нужен какой-то большой рюкзак с кучей разных тулов, и вы не знаете, что выбрать, берите DevToys.app и пробуйте, может быть, это то, что вам нужно, или вы сможете его заточить под себя.
6147.84 6159.84 "Анатолий Кулаков" Отлично, большое спасибо всем, кто дослушал до конца, шарьте, репосты, рассказывайте друзьям, помогайте нам становиться более популярными и успешными, и может быть даже в будущем богатыми.
6159.84 6174.84 "Анатолий Кулаков" Кстати, на iTunes у нас довольно мало звёздочек, поэтому если вам несложно, зайдите там, чпокните 5 звёздочек нам, нам будет очень приятно, и на всех платформах, где вы нас слушаете, обязательно лайки, звёздочки, пальцы вверх и всё такое.
6174.84 6188.84 "Анатолий Кулаков" И пишите свои комментарии к этому выпуску, обычно мы все комментарии собираем в YouTube к этому выпуску, в общем, пока YouTube работает, заходите, делитесь вашими мыслями, предложениями, будем обязательно всех учитывать, всех услушать и делать по-своему.
6188.84 6194.84 "Анатолий Кулаков" И сегодня с вами были Анатолий Кулаков и Игорь Лобутин, это был 50-й выпуск Radio The Net.
6194.84 6196.84 "Игорь Лабутин" Всем пока.
