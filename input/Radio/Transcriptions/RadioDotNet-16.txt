0.00 5.00 "Анатолий Кулаков" Добрый день, дорогие друзья!
5.00 8.96 "Анатолий Кулаков" С вами Radio.net и 16-й выпуск в эфире.
8.96 11.12 "Анатолий Кулаков" Как всегда, здесь Анатолий Кулаков.
11.12 12.36 "Анатолий Кулаков" И Игорь Лабутин.
12.36 13.36 "Анатолий Кулаков" Привет!
13.36 15.64 "Анатолий Кулаков" Хотелось бы начать, прежде всего, с радостной новости.
15.64 19.28 "Анатолий Кулаков" У нас для вас есть промокод на конференцию .NEXT.
19.28 27.68 "Анатолий Кулаков" .NEXT пройдет со 2 по 5 декабря, он растянется на несколько дней, наверное, так же, как и весной.
27.68 31.44 "Анатолий Кулаков" Если вы присутствовали, то вы представляете, примерно, что будет происходить.
31.44 33.72 "Анатолий Кулаков" В формате онлайн, конечно же.
33.72 35.80 "Анатолий Кулаков" Но вас ждет куча сюрпризов.
35.80 44.72 "Анатолий Кулаков" Много интересных нововведений, много интересных новых форматов, много гостей, которых мы не могли к нам заманить уже очень-очень много лет.
44.72 48.72 "Анатолий Кулаков" И единственный, наверное, шанс был их вытащить, это как раз-таки онлайн.
48.72 55.08 "Анатолий Кулаков" Мы этим шансом воспользовались очень хорошо и пригласили кучу знаменитостей из самого Ренмонда.
55.08 56.08 "Анатолий Кулаков" И не только.
56.08 62.36 "Анатолий Кулаков" Но я сильно не буду рассказывать про .NEXT, мы все-таки запишем отдельный выпуск, где подробно обо всем об этом поговорим.
62.36 65.88 "Анатолий Кулаков" А пока вам нужно запомнить, что у нас есть для вас промокод.
65.88 71.44 "Анатолий Кулаков" И если вы почему-то еще не приобрели билет, то заходите в ShowNotes, мы вам дадим небольшую скидочку.
71.44 81.16 "Игорь Лабутин" Да, и вы можете тоже посмотреть уже программу на сайте, она постоянно дополняется, обновляется и посмотреть на всех тех самых звезд в ожидании выпуска отдельного.
81.16 82.16 "Игорь Лабутин" Поехали.
82.16 84.64 "Игорь Лабутин" Как мы обычно рассказываем про .NET 5.
84.64 89.24 "Игорь Лабутин" И в этот раз особых новостей нет, .NET 5 потихонечку близится к релизу.
89.24 95.24 "Игорь Лабутин" Через небольшое время произойдет .NET Conf, где .NET 5 будет официально представлен и официально зрелижен.
95.24 101.44 "Игорь Лабутин" Поэтому мы продолжаем просто напоминать, что еще такого интересного сделано было в .NET 5.
101.44 104.40 "Игорь Лабутин" И сегодня мы хотим поговорить про App Trimming.
104.40 112.00 "Игорь Лабутин" Тем более вышла неплохая статья обзорная, в которой рассказывается все, что нужно знать про App Trimming и его возможности.
112.00 113.28 "Игорь Лабутин" Давайте разбираться.
113.28 123.04 "Игорь Лабутин" Для начала надо вспомнить, что когда .NET Core только родился, одним из умолчательных способов деплоя был Framework Dependent Deployment.
123.04 132.28 "Игорь Лабутин" То есть вы собираете свою DLL, даже если это исполнимое приложение, передаете ее туда, где нужно исполнять и там говорите .NET Run вашей DLL.
132.28 134.56 "Игорь Лабутин" Все работает замечательно, все прекрасно.
134.56 137.64 "Игорь Лабутин" Кроме одной штуки, вам нужен все-таки рантайм.
137.64 141.64 "Игорь Лабутин" И это не очень удобно для пользователя, а также для распространения.
141.64 148.92 "Игорь Лабутин" Потому что вы можете сначала поставить рантайм, притащить кучу DLL вашего приложения и как-то это все не здорово.
148.92 153.96 "Игорь Лабутин" И кроме того, несмотря на то, что это ваше исполнимое приложение, оно все-таки DLL.
153.96 154.96 "Игорь Лабутин" Тоже не здорово.
154.96 159.68 "Игорь Лабутин" Поэтому вторым способом это было собрать Framework Dependent Executable.
159.68 177.52 "Игорь Лабутин" Это добавлялся ключ к -R и нужная вам платформа, когда вы паблишите ваше приложение и тогда у вас получалась папочка с огромным количеством DLL и .exe, которая по сути являлась небольшим враппером, который платформа зависим и при этом он умеет развернуть и найти весь остальной рантайм.
177.52 181.56 "Игорь Лабутин" Рантайм все еще необходим, поэтому это называется Framework Dependent.
181.56 193.88 "Игорь Лабутин" В какой-то момент Microsoft поняли, что Framework Dependent не очень удобно и возможно нам нужно что-то другое и был добавлен Self-Contained Executable вариант.
193.88 204.48 "Игорь Лабутин" Указав ключик Self-Contained True, можно было при паблише получить папочку с еще большим количеством DLL и бонус был в том, что она не требует рантайма.
204.48 215.16 "Игорь Лабутин" То есть все эти DLL собранные вместе просто представляют ваше приложение, которому ничего больше не нужно, кроме Windows или Linux или какой-то операционной системы, которая поддерживает .NET Core.
215.16 217.16 "Игорь Лабутин" К сожалению, есть один недостаток.
217.16 225.04 "Игорь Лабутин" Если мы напишем простой Hello World, который только и делает, что делает консоль RightLine, мы получим в аутпуте примерно 225 файлов и 65 мегабайт.
225.04 230.68 "Игорь Лабутин" Распространять такое не очень удобно, не очень здорово и кажется, что очень много.
230.68 240.44 "Игорь Лабутин" Поэтому, начиная с более поздних версий, по-моему это уже появилось в .NET Core 3, появилась возможность паблишить Self-Contained Single File Executable.
240.44 261.96 "Игорь Лабутин" Это передавалась опция Publish Single File True и после этого получалась папочка, где файликов становилось чуть-чуть меньше, все равно нужны DLL от рантайма, с ними, к сожалению, ничего сделать было нельзя и при этом размер уменьшался с 65 до 58 мегабайт в примере с Hello World.
261.96 265.52 "Игорь Лабутин" Все равно много и все равно куча рантайм DLL нужна.
265.52 272.40 "Игорь Лабутин" В .NET 5 появилась новая функциональность, называется Trimming и у этого самого Trimming есть несколько режимов работы.
272.40 276.52 "Игорь Лабутин" Во-первых, можно выставить режим работы Copy Used.
276.52 282.24 "Игорь Лабутин" Для этого нужно указать опцию Publish Trimmed True и сказать Trim Mode = Copy Used при паблише.
282.24 290.88 "Игорь Лабутин" В этом случае те сборки из фреймворка, из рантайма, которые не используются в вашем приложении, они просто не копируются в Output.
290.88 295.44 "Игорь Лабутин" Результирующий объем получается всего лишь 13 мегабайт и существенно меньше DLL.
295.44 296.92 "Игорь Лабутин" Это прям здорово.
296.92 312.44 "Игорь Лабутин" Но если вам этого мало, то тогда можно сказать опцию Link и тогда он не только удалит все ненужные сборки, но при этом еще попытается из оставшихся сборок поудалять всякие классики и мемберы этих классов, которые вроде бы и не нужны.
312.44 318.84 "Игорь Лабутин" И тогда мы достигаем размера 5.9 мегабайт, что уже для Hello World, наверное, можно сказать приемлемо.
318.84 319.84 "Игорь Лабутин" Хотя как посмотреть.
319.84 322.96 "Игорь Лабутин" Все равно многовато, но с этим можно уже как-то
322.96 329.24 "Анатолий Кулаков" работать. Учитывая то, что этот вариант не тащит с собой рантайм, мне кажется это довольно-таки крутецкие цифры.
329.24 333.08 "Анатолий Кулаков" А мы действительно получаем в этом случае всего лишь на все один .exe файл.
333.08 342.12 "Игорь Лабутин" Один .exe файл это, насколько я понимаю, еще пока не совсем идеально достижимая штука, над этим еще работают, но мы как-то очень близки к этому.
342.12 351.52 "Игорь Лабутин" То есть действительно сейчас ведется работа активная над тем, чтобы запаковать вообще все зависимости внутри одного .exe как ресурсы и не требовать вообще распаковки.
351.52 363.44 "Игорь Лабутин" Был такой вариант, но он есть на самом деле, что мы получаем один .exe файл, но это такой фейковый .exe, он на самом деле zip, и он при запуске распакует все на самом деле все равно на диск в темп куда-нибудь и оттуда запустят по стариночке.
363.44 367.16 "Игорь Лабутин" То есть вроде как single file, но не single file.
367.16 388.64 "Игорь Лабутин" А сейчас ведется работа, я не помню честно говоря точный статус, там были какие-то проблемы, но по моему все-таки всех должны были решить, и тогда это будет честный единый .exe, где все зависимые .dll запакованы внутрь как ресурсы, и когда рантаймом хочется подгрузить .dll, она будет автоматически подгружаться из ресурсов, не требуя распаковки на диск.
388.64 395.12 "Игорь Лабутин" Так что мы движемся к нормальным .net тулам, которые составляют один-единственный файлик.
395.12 411.40 "Игорь Лабутин" Но есть проблема, проблема это reflection, и любой вообще доступ к коду, который либо генерируется в динамике, либо каким-то образом не может быть проанализирован статически, потому что все вот эти оптимизации на тему вырезать все ненужное и неиспользуемое естественно работают только в статическом анализе.
411.40 416.12 "Игорь Лабутин" То есть никто reflection особо не анализирует, и его анализировать сложно.
416.12 427.92 "Игорь Лабутин" Для того чтобы помочь компилятору это все правильно сделать, в .NET 5 появились три новых атрибута, это requires unreference code, dynamically accessed members и dynamic dependency.
427.92 454.36 "Игорь Лабутин" Они размечают код, который либо казалось бы требует, то есть казалось бы этот конструктор может быть ниоткуда не вызывается и ниоткуда допустим не используется явно, но мы знаем, что он там внутри себя сгенерит какую-нибудь хитрую IL конструкцию, которая что-нибудь вызовет или его вызовут наоборот хитро через какой-нибудь динамик или reflection или еще через что-нибудь.
454.36 462.04 "Игорь Лабутин" В общем этими тремя атрибутами можно помочь компилятору как-то подсказать какие классы и методы в вашем коде нужно оставить.
462.04 478.04 "Игорь Лабутин" И насколько я понимаю, основная цель все-таки этих атрибутов, применения этих атрибутов это сам фреймворк, он размечен и чтобы компилятор знал, что можно удалить из самого фреймворка, но вы можете поиспользовать их тоже в вашем коде, чтобы компилятору было проще ваш код анализировать тоже.
478.04 503.56 "Игорь Лабутин" Ну что так, смотрим куда пойдет дальше, поскольку все это дело развивается и нравится во многом в том числе Blazor, где нам интересен минимальный размер файла, минимальный размер вообще рантайма, то скорее всего какая-то дальнейшая работа над этим будет производиться, потенциал еще есть и все это можно еще удалять и удалять и довести там, не знаю, размер приложения до какого-нибудь мегабайтика.
503.56 507.44 "Игорь Лабутин" Мегабайт Hello World будет уже, мне кажется, очень неплохим результатом.
507.44 516.48 "Анатолий Кулаков" Вот эти тенденции на удаление всего и вся и в Дотнет 5 могут давать не только какие-то хорошие, позитивные вещи, но еще и отрицательные, негативные.
516.48 530.68 "Анатолий Кулаков" Вот там разработчики недавно наудаляли такого, что string index off перестало работать, то есть буквально базовая концепция, она значит, что опирается огромное число библиотек, в частности Джимми Боггард разразился интересной статейкой.
530.68 531.68 "Игорь Лабутин" Читал про нее?
531.68 540.76 "Игорь Лабутин" Впервые эту проблему я увидел не в статье, а в твите от Джимми Боггарда, и когда он это написал в твите, действительно выглядело как то, что все-все-все сломалось.
540.76 548.32 "Игорь Лабутин" У него был юнит тест, который проверял, что некоторый аутпут, который выдает его код, содержит определенные подстроки.
548.32 554.76 "Игорь Лабутин" И тест, по сути, просто вызывал индексов от известных подстрочек и проверял, что это больше нуля.
554.76 560.68 "Анатолий Кулаков" Нужно дополнить, что тест этот начал падать он после того, как Джимми попытался перевести его на Дотнет
560.68 568.00 "Игорь Лабутин" 5. Надо как-то предполагать, что оно должно было бы работать легко и просто, но действительно индексов падал.
568.00 576.52 "Игорь Лабутин" При этом, если посмотреть на эту строчку в дебаггере и попытаться, например, скопировать ее в какой-нибудь редактор и найти Ctrl+F там эту строчку, она находится.
576.52 577.52 "Игорь Лабутин" Это было удивительно.
577.52 586.64 "Игорь Лабутин" После этого он смог минимизировать репорт стыпы до состояния, что мы объявляем строку, туда пишем какую-нибудь очень длинную строчку, которую мы пытаемся искать.
586.64 598.24 "Игорь Лабутин" После этого мы говорим string indexof известные подстроки, которые мы знаем, что там есть, индексов возвращает минус 1 и удивительно, мы потом пишем в этом же тесте string.contains от этой подстроки и он возвращает true.
598.24 607.96 "Игорь Лабутин" И в этот момент точно Джимми решил, что все сломалось, потому что получается, что вам Дотнет говорит, да, в этой строке подстрока есть, но где я не знаю.
607.96 609.48 "Игорь Лабутин" И это выглядело странно.
609.48 611.68 "Игорь Лабутин" Разгадка оказалась довольно простой.
611.68 612.68 "Игорь Лабутин" Это действительно breaking change.
612.68 621.80 "Игорь Лабутин" В прошлом выпуске мы упоминали список breaking changes и действительно после внимательнейшего чтения этого списка, действительно breaking change нашелся.
621.80 631.84 "Игорь Лабутин" И он состоит в том, что Дотнет 5 по дефолту теперь переключился на использование ICU вместо NLS, чтобы это не значило.
631.84 635.60 "Игорь Лабутин" На самом деле это про работу с культурами и с юникодом.
635.60 651.40 "Игорь Лабутин" Исторически Windows и Дотнет соответственно работают с так называемым NLS библиотекой, это Nature Language Support библиотека от Microsoft, которая собственно работает со всеми юникодными штуками, культурами и всеми строковыми операциями, где задействована хоть как-то культура.
651.40 658.24 "Игорь Лабутин" И это проблема для кроссплатформенного кода, то есть в частности для Дотнет Core, потому что на Линуксе NLS нет.
658.24 663.76 "Игорь Лабутин" И на Линуксе используется библиотечка ICU - International Components for Unicode.
663.76 671.72 "Игорь Лабутин" С недавнего времени Microsoft с определенной версии десятки, 2000 какой-то, я не помню точную ревизию, ICU эту поставляет.
671.72 679.16 "Игорь Лабутин" И она уже на самом деле есть теперь в NuGet пакете, ее можно затащить в свое приложение и гарантировать, что она тащится вместе с приложением.
679.16 681.76 "Игорь Лабутин" И Дотнет 5 по дефолту теперь использует ICU.
681.76 689.48 "Игорь Лабутин" Я посмотрел на этот breaking change, там действительно написано, что все будет гораздо лучше, гораздо кроссплатформеннее, совместимее, все здорово.
689.48 699.32 "Игорь Лабутин" И как я говорил в прошлом выпуске, там действительно написано, как это влияет на ваш код, написано, все будет только лучше, а action points вам ничего делать не надо, все работает само.
699.32 708.48 "Игорь Лабутин" Ну и приписочка внизу, что если вам все-таки не нравится, есть способ вернуться обратно, то есть можно в AppConfig написать волшебную строчку и Дотнет 5 вернется к использованию NLS.
708.48 711.92 "Игорь Лабутин" Натурально Дотнет 5, который использовал Джимми, использовал ICU.
711.92 714.52 "Игорь Лабутин" И здесь выяснилась следующая особенность.
714.52 727.44 "Игорь Лабутин" Contains, как известно, точнее, как могло бы быть кому-то известно, если посчитать внимательно документацию, использует сравнение строк с учетом культуры, если не передано что-то, что явно задает культуру.
727.44 734.08 "Игорь Лабутин" А индексов использует то, что называется ordinal comparison, то есть по сути, по байту, по символу.
734.08 746.52 "Игорь Лабутин" И так уж сложилось, что для того, чтобы в UnityTest проверять, что какая-то подстрочка точно содержится в output, нужно было проверить, что она содержится именно начиная с начала строки.
746.52 749.88 "Игорь Лабутин" И поэтому подстрока, которую искали, начиналась с символа \n.
749.88 754.32 "Игорь Лабутин" То есть по сути, стандартный виндовый перевод строки \r\n был попилен пополам.
754.32 766.16 "Игорь Лабутин" И сравнение строк, которые с учетом культуры, знает, что \r\n - это перевод строки на Windows, его считает как единым символом, и при попытке поискать его половинку его не находит.
766.16 773.40 "Игорь Лабутин" В общем, хотя казалось бы индексов это ordinal comparison, и оно должно находить.
773.40 776.00 "Игорь Лабутин" В общем, что-то как-то странно это в ICU работает.
776.00 778.20 "Игорь Лабутин" Я действительно попробовал, оно действительно так работает.
778.20 781.44 "Игорь Лабутин" Почему, я не знаю, но звучит как-то странно.
781.44 792.72 "Игорь Лабутин" Если в contains написать culture where аргумент и написать туда compare option, если я правильно помню, точку ordinal, то все нормально, все замечательно работает и все находится.
792.72 793.72 "Игорь Лабутин" Все как надо.
793.72 797.24 "Анатолий Кулаков" Я бы ожидал эту проблему увидеть, когда мы работаем с разными культурами.
797.24 802.72 "Анатолий Кулаков" Ну когда у нас в обоих случаях латинские буквы и меняется только перевод строк.
802.72 808.12 "Анатолий Кулаков" Непонятно, почему могла выстрелить разница между различными и некодными таблицами.
808.12 816.52 "Игорь Лабутин" Возможно разница в том, что NLS, будучи исходно-виндовой, она нормально обрабатывает переводы строк и их как-то не считает чем-то уникальным.
816.52 837.84 "Игорь Лабутин" А ICU, которая интернешнл и которая обязана поддерживать и линукс, и винды, и макос, и все что угодно, ей приходит, а везде же разные комбинации переводов строк, ей как-то видимо с этим приходится отдельно работать и видимо где-то там может ошибка, может не ошибка, может тонкость работы, ну как бы что-то пошло не так и в итоге тесты падают.
837.84 848.04 "Игорь Лабутин" Поэтому в данном случае солюшен был простой, использовать ординал и все будет хорошо, но конечно, когда такое видишь первый раз, оно выглядит прям не очень.
848.04 878.28 "Игорь Лабутин" Примерно похожая ситуация у меня была, когда я в разных локалях искал различные буквы типа там, буквосочетания типа AE и прочее, потому что там AE, буквосочетание в датской локали это отдельная буква датского алфавита и у нее есть отдельный апперкейс для нее и в общем, это почти как известный тест на то, правильно ли локализовано ваше приложение, да, попробуйте его запустить в турецкой локали, с вероятностью 90% оно у вас работать не будет из-за особенностей турецкого языка.
878.28 879.64 "Игорь Лабутин" Так что такие дела.
879.64 894.88 "Анатолий Кулаков" Вообще эту рекомендацию можно обобщить, что всегда используйте сравнение Ordinal, только если вы четко понимаете, что вам нужно что-то другое, что вам нужно использовать сравнение с учетом пользовательской локали, вот только тогда вставляйте какую-нибудь локаль.
894.88 900.68 "Анатолий Кулаков" А Ordinal вам дает не только гарантию от меньшего числа ошибок, но и очень сильно увеличивает перформанс.
900.68 904.52 "Анатолий Кулаков" Но не все в DotNet 5 так разрушительно.
904.52 925.46 "Анатолий Кулаков" Есть много интересных фичей, которых мы продолжаем вам до сих пор рассказывать и одна из таких фичей, которой мы не нарадовались, были Source генераторы, которые добавились в DotNet 5, мы про них несколько раз говорили и недавно вышла интересная статья от Гаэля Фрайтэо, это очень известный автор инструмента PostSharp.
925.46 933.30 "Анатолий Кулаков" Он не только автор, но в принципе организовал компанию, которая сейчас поддерживает PostSharp и является ее президентом.
933.30 939.14 "Анатолий Кулаков" Если кто не знает, PostSharp это фреймворк для реализации аспектно-ориентированного подхода в DotNet.
939.14 946.74 "Анатолий Кулаков" Статья очень интересная, у нее есть небольшая техническая часть и огромная философская часть, попробуем пройтись пока по технической.
946.74 958.62 "Анатолий Кулаков" Итак, давайте коротко вспомним, что Roslyn Source генераторы это новая точка расширения компилятора Roslyn, которая позволяет вам динамически порождать новый C# код.
958.62 959.62 "Анатолий Кулаков" Во время компиляции.
959.62 969.86 "Анатолий Кулаков" И эти генераторы могут распространяться с помощью NuGet пакетов, то есть вы можете скачать из NuGet какой-нибудь интересный генератор и он вам нагенерит что-нибудь интересного.
969.86 984.90 "Анатолий Кулаков" Здесь нужно учитывать, что само введение Source генераторов не привнесло каких-то новых сценариев использования, то есть все то, что они делают, мы могли делать и раньше, но просто это было более криво, более медленно и менее поддерживаемо.
984.90 988.22 "Анатолий Кулаков" Сейчас с Source генераторами это стало делать намного легче.
988.22 1008.74 "Анатолий Кулаков" Например, ускорились билды, потому что раньше вы точно так же могли порождать новый код, но для этого вам приходилось вызывать какие-то третисторонние тулзы, которые парсили отдельно каким-то образом ваш C# дерево, генерили на диск файлики, откомпиливали их или может даже лезли в ваши DLL, там их патчили или еще что-то с ними делали.
1008.74 1009.74 "Анатолий Кулаков" Это было все медленно.
1009.74 1016.46 "Анатолий Кулаков" Сейчас, так как это встроено в pipeline Roslyn, он может это все делать в памяти, порождать всю эту генерацию, это довольно таки быстро.
1016.46 1025.06 "Анатолий Кулаков" Еще одним плюсом новых Source генераторов является то, что они встроены из коробки в Roslyn и поэтому все IDE-шки их будут поддерживать.
1025.06 1040.74 "Анатолий Кулаков" Соответственно, вы сможете в Design Time увидеть то, что сгенерили эти генераторы, сможете навигироваться на код, сможете ощутить интеллисенс, посмотреть типы и все как мы привыкли, нормальной строго типизированной навигацией.
1040.74 1049.10 "Анатолий Кулаков" У Source генераторов, по мнению DLL, есть три неоспоримые точки, в которых он победил старые средства, которые раньше использовались.
1049.10 1052.42 "Анатолий Кулаков" Первый пункт - это код behind файлы.
1052.42 1059.98 "Анатолий Кулаков" Например, код поведения, который вставлял XAML дизайнер или который вставлял WinForm дизайнер или ISP.NET дизайнер.
1059.98 1063.42 "Анатолий Кулаков" Этот код теперь можно генерить с помощью Source генераторов.
1063.42 1066.54 "Анатолий Кулаков" Раньше этим занимался отдельный MSBuildTask.
1066.54 1070.70 "Анатолий Кулаков" Также один из интересных способов использования - это использование как application каталога.
1070.70 1080.86 "Анатолий Кулаков" Например, мы можем в Design Time собрать все контроллеры в ISP.NET, MEV компоненты и составить из них какой-то список.
1080.86 1087.10 "Анатолий Кулаков" Например, таким образом мы можем полностью избавиться от контейнеров, потому что все зависимости у нас уже известны на момент компиляции.
1087.10 1090.06 "Анатолий Кулаков" Раньше это решалось с помощью Reflection.
1090.06 1093.18 "Анатолий Кулаков" Теперь Source генераторы могут в этом месте заменить Reflection.
1093.18 1101.26 "Анатолий Кулаков" И для аспектно-ориентированных фреймворков была интересна ниша, такая как дополнение инфраструктурного кода.
1101.26 1115.38 "Анатолий Кулаков" Если вы не хотели писать к своим классикам какие-то унылые методы типа ToString, Equals, GetHashCode и прочие такие примитивные вещи, которые похожи на обезьяни труд, то всякие AOP-фреймворки типа PostSharp вам могли упростить эту задачу.
1115.38 1121.54 "Анатолий Кулаков" В данном случае Source генераторы теперь тоже могут с этим хорошо справиться и здесь никакие сторонние тулзы не нужны.
1121.54 1127.42 "Анатолий Кулаков" Вот в этих трех точках GL считает, что Source генераторы победили и в принципе там больше ловить нечего.
1127.42 1139.18 "Анатолий Кулаков" Но это не по наце, потому что у Source генераторов есть очень-очень много проблем и поэтому аспектно-ориентированные фреймворки с рынка никуда не уйдут, а останутся жить и цвести.
1139.18 1147.30 "Анатолий Кулаков" Давайте подробнее рассмотрим эти проблемы на очень хорошем примере, примере, который Microsoft сам дает нам в самплах.
1147.30 1151.50 "Анатолий Кулаков" Каким образом реализовать Inotify PropertyChanged с помощью генераторов.
1151.50 1152.50 "Анатолий Кулаков" Тема довольно-таки больная.
1152.50 1163.74 "Анатолий Кулаков" PropertyChanged это такой тоже мутный, муторный обезьянный код, который нужно очень много писать и которым изобилуют .df формочки.
1163.74 1168.14 "Анатолий Кулаков" Поэтому программисты очень часто и много просили Microsoft что-нибудь с этим делать.
1168.14 1172.30 "Анатолий Кулаков" И Source генераторы якобы представляются как решение этой проблемы.
1172.30 1179.98 "Анатолий Кулаков" Но главный их минус в том, что Source генераторы только умеют добавлять код, они не умеют его менять.
1179.98 1182.94 "Анатолий Кулаков" Это одновременно и минус, и мощь Source генераторов.
1182.94 1188.50 "Анатолий Кулаков" И поэтому в качестве примера для того, чтобы реализовать Inotify PropertyChanged предлагается сделать следующее.
1188.50 1194.58 "Анатолий Кулаков" Объявить филд и над этим филдом навесить специальный атрибут, который для примера называется AutoNotify.
1194.58 1195.98 "Анатолий Кулаков" К чему это приводит?
1195.98 1210.58 "Анатолий Кулаков" Source генераторы сканируют этот филд, видят специальный атрибутик и за вас сгенерят специальное свойство, которое уже будет проставлять правильное значение в этот филд и при этом вызывать необходимые всякие методы, необходимые всякие ивенты.
1210.58 1213.38 None Казалось бы, все хорошо, но на самом деле нет.
1213.38 1215.18 "Анатолий Кулаков" Прежде всего с точки зрения наблюдателя.
1215.18 1217.86 "Анатолий Кулаков" Разработчик в своем коде будет видеть именно филд.
1217.86 1224.86 "Анатолий Кулаков" Проперти, которая сгенерится с Source генератором, будет сгенерирована в отдельном файле и разработчик его перед глазами видеть не будет.
1224.86 1234.70 "Анатолий Кулаков" И ему нужно постоянно держать в уме, что как только он захочет присвоить какое-то значение этому филду, ему нужно обращаться не напрямую в этот филд, а делать это через свойства.
1234.70 1239.34 "Анатолий Кулаков" Иначе не сработает волшебная обертка и у нас не вызовется специальный ивент.
1239.34 1241.78 "Анатолий Кулаков" Это решение не очень идиоматичное.
1241.78 1255.18 "Анатолий Кулаков" Что, например, делать, если у вас уже есть какой-то классик, у него уже есть куча свойств и вам захочется навесить на эти свойства ивентик, то есть чтобы они стали реимплементировать интерфейс INotifyPropertyChanged.
1255.18 1263.02 "Анатолий Кулаков" Вам придется отрефакторить все, то есть перевести все свои свойства в проперти, навесить атрибутики, что немножко как бы напрягает.
1263.02 1275.94 "Анатолий Кулаков" Также точно вполне нормальная ситуация, когда вы хотите изменить имя свойства, то есть чтобы оно называлось не так, как филд, или сделать им какие-то зависимости, чтобы это свойство высчитывалось или зависело не только от одного филда, а от нескольких филдов.
1275.94 1279.74 "Анатолий Кулаков" Или вы можете захотеть подменять видимость этому свойству.
1279.74 1283.90 "Анатолий Кулаков" И это все необходимо будет делать с помощью забивания странных констант в атрибуте.
1283.90 1302.10 "Анатолий Кулаков" Казалось бы, у нас есть все выразительные инструменты для этого, мы вполне умеем объявлять свойства, мы вполне умеем объявлять их имена и уровень видимости, но нам придется это делать каким-то неестественным образом в атрибутах, для того чтобы генератор понял, что мы хотим сгенерировать.
1302.10 1313.86 "Анатолий Кулаков" И это выглядит очень ненатурально, и у этого есть, как говорит GL, design smell, то есть код получается не эдематичным, выглядит грязно и не очень понятно.
1313.86 1323.50 "Анатолий Кулаков" С другой стороны есть AOP-фриборки, которые разрабатывались и дизайнились специально под такие хаки, вот под такие нужды, и они с этой проблемой справляются прекрасно.
1323.50 1324.50 "Анатолий Кулаков" У них ничего такого нет.
1324.50 1336.26 "Анатолий Кулаков" А ОП-фриборки это довольно-таки мощная штука, хотя Microsoft их очень сильно не признает, то есть у них нет никакого официального фреймворка, он никогда не был встроен в .NET или в какие-то микрософтовские инструменты.
1336.26 1342.30 "Анатолий Кулаков" Но неявно, само аспект наориентированного программирования в .NET присутствует.
1342.30 1350.14 "Анатолий Кулаков" Например, у нас есть custom behaviors в .DubCF, которые в принципе это и делают, они внедряют какой-то аспект консерв.
1350.14 1359.82 "Анатолий Кулаков" У нас есть интерсепторы в Unity, у нас есть фильтры в ISP, .NET, MVC, все они делают то, что как раз-таки эмулирует аспектно-ориентированный подход.
1359.82 1380.38 "Анатолий Кулаков" И у ГАЭЛЯ довольно-таки большая компания, PostSharp — это лидирующий инструмент среди .NET в этом мире, у него много очень коммерческих разработок, и по его статистике в среднем код может сократиться и уменьшить свою сложность на 15%, что довольно-таки много, особенно на больших кодовых базах.
1380.38 1389.14 "Анатолий Кулаков" И миллионы-миллионы разработчиков используют аспектно-ориентированный программирование, и очень сильно бы хотели, чтобы аспекты появились в нативной поддержке .NET.
1389.14 1393.26 "Анатолий Кулаков" Но команда Microsoft очень сильно этого не хочет, по каким-то причинам.
1393.26 1401.58 "Анатолий Кулаков" Это, конечно, хорошо для фирмы PostSharp, для команды PostSharp, потому что они могут дальше зарабатывать деньги, но это очень плохо для сообщества.
1401.58 1407.58 "Анатолий Кулаков" Для сообщества это плохо прежде всего потому, что не дает языку достаточно выразительно развиваться.
1407.58 1417.86 "Анатолий Кулаков" Оно не дает языку очень много выразительных шаблонов, которые уже в аспектно-ориентированном мире давно приняты, развились, одобрились и помогают сэкономить кучу-кучу времени.
1417.86 1427.18 "Анатолий Кулаков" Например, такие понятные аспекты, как ThreadSafe или Observability, которые необходимо обязательно иметь в виду использовать, когда вы пишете UI, допустим.
1427.18 1429.74 "Анатолий Кулаков" Их нельзя просто так взять и навесить на ваш классик.
1429.74 1439.26 "Анатолий Кулаков" Вам придется писать ручками какой-то непонятный странный код, синхронизирующий ваши критические секции, или, может быть, бросающие необходимые NotifyPropertyChanges.
1439.26 1444.54 "Анатолий Кулаков" То есть нельзя просто так взять атрибутиком и навесить какие-то аспекты для класса.
1444.54 1448.86 "Анатолий Кулаков" И именно это GL приводит в пример как очень устаревший подход.
1448.86 1458.34 "Анатолий Кулаков" То есть подход, когда мы разрабатывали языки программирования с целью на то, что машина должна мочь их запустить, памяти должно хватить, процессор должен сработать.
1458.34 1467.86 "Анатолий Кулаков" И он считает, что это сейчас не главный лимит в языках программирования, а главный все-таки лимит, куда упираются все люди, это некий человеческий ресурс.
1467.86 1475.82 "Анатолий Кулаков" То есть это некая работоспособность разработчика, который должен хорошо понимать код, быстро его разрабатывать, хорошо его поддерживать.
1475.82 1482.26 "Анатолий Кулаков" И именно с этой точки зрения нужно планировать новые языки программирования и развивать существующие туда же.
1482.26 1489.86 "Игорь Лабутин" Ну вот смотри, я согласен, что AOP неплох, когда мне нужно, например, автоматически генерить equals или всякие такие штуки.
1489.86 1496.86 "Игорь Лабутин" И тут, в принципе, генераторы и так тоже сработают нормально, этот код не нужен особо тебе видеть, ты его явно не вызываешь.
1496.86 1499.30 "Игорь Лабутин" И с ним все будет хорошо.
1499.30 1515.06 "Игорь Лабутин" Но я, например, не уверен, что мне бы хотелось использовать, или что это даже, может быть, облегчит понимание, если я, например, атрибутами развешиваю всякие UI-ные концепции типа однопоточности и так далее.
1515.06 1520.78 "Игорь Лабутин" На самом деле, что-то же подобное, ну, может быть, отдаленно подобное, но было когда-то давным-давно.
1520.78 1534.42 "Игорь Лабутин" И если ты помнишь такую штуку как single thread apartment и multithread apartment в коме, когда можно было сказать, что вот этот классик, какой-то ком-объект, он STA, и из-за тебя весь фреймворк все синхронизировал, это было относительно просто.
1534.42 1538.94 "Игорь Лабутин" И я помню, что это было одной из причин дедлоков и всяких таких штук.
1538.94 1551.82 "Игорь Лабутин" А из недавнего такого атрибутов, которые были наиболее запутанными, что ли, это были всякие синхронизейшн контекст релейтед штуки, когда на вцф можно было повесить USynchronizationContextFalseTrue.
1551.82 1553.82 "Игорь Лабутин" В принципе, это про то же самое.
1553.82 1561.30 "Игорь Лабутин" В UI-чике Microsoft справедливо предполагал, что ты просто ставишь USynchronizationContextTrue и оно все магически работает в UI-чике.
1561.30 1564.86 "Игорь Лабутин" Ну, по факту нифига оно там не работает, как только ты начинаешь использовать дуплекс-каналы.
1564.86 1574.50 "Игорь Лабутин" Тут же уже надо очень качественно понимать, кто куда и какие callback'и к тебе приходят, и вот становится вообще непросто, и нужно, по сути, ставить false и все разруливать все равно руками.
1574.50 1586.22 "Игорь Лабутин" То есть все-таки вся эта аспектная ориентированность, она имеет, с моей точки зрения, применимость только когда она универсальна, единообразна и не требует каких-то сильно сложных кастомных сценариев.
1586.22 1596.62 "Игорь Лабутин" Может быть, у нас они такие были частенько, и поэтому я как бы все наши попытки поиспользовать постштаб то так, то сяк, на самом деле, по-моему, свелись к тому, что сейчас у нас его нет нигде.
1596.62 1599.74 "Игорь Лабутин" Мы так или иначе все заменили на обычный код.
1599.74 1608.94 "Анатолий Кулаков" Действительно, аспекты очень часто применяются как очень быстрый инструмент для того, чтобы начать, и очень простой для какого-то базового уровня.
1608.94 1618.78 "Анатолий Кулаков" Но как только ваше приложение куда-то далеко-далеко развивается, и у него появляются какие-то кастомные подходы, ему нужны какие-то большие сложные условия, то аспекты вас начинают больше тормозить, чем помогать.
1618.78 1625.10 "Анатолий Кулаков" Но, наверное, действительно, аспекты бывают разные, и каким-то проектам это подходит, каким-то проектам это не подходит.
1625.10 1636.38 "Анатолий Кулаков" Но по мнению ГАЭЛ, что у нас существует огромное число проектов, огромное число команд, которым данная функциональность критически необходима, и она помогает им сильно жить.
1636.38 1658.98 "Анатолий Кулаков" В качестве примера для того, чтобы не только останавливаться на UI, как можно привести, что еще может делать аспектно ориентированное программирование, например, оно может перехватывать любые члены вашего класса, property, event, и field, и каким-то образом обрабатывать их вызов, например, обрамлять их в try/catch, или лагировать вызов, или, может быть, скипать этот вызов, или делать что-то еще.
1658.98 1665.66 "Анатолий Кулаков" Можно добавлять динамически к классу какие-то члены, добавлять новые свойства, или новые методы имплементировать.
1665.66 1670.46 "Анатолий Кулаков" Можно добавлять кастомные атрибуты, или наоборот, удалять их почему-то.
1670.46 1683.58 "Анатолий Кулаков" Можно манипулировать ресурсами, можно имплементировать новые интерфейсы, то есть много-много чего-то очень полезного, очень нудного и очень того, что не хочется писать, кроме каких-то сложных концепций в виде UI и синхронизации.
1683.58 1687.22 "Игорь Лабутин" Да, это все звучит очень классно, но на самом деле очень стрёмно.
1687.22 1707.38 "Игорь Лабутин" Я иногда в рабочих проектах писал какие-то кусочки генерации или кода, или вот когда были наши попытки сделать постштар каким-то применением атрибутов либо переписывания кода, это иногда приводило к тому, что код переписывался как-то чуть-чуть не так, и понять, что там идет не так, вообще все это звучит очень опасно.
1707.38 1721.74 "Игорь Лабутин" Переписывать IL-код по-живому, так сказать, не имея возможности потом увидеть это в сурсах, приходится брать DLL-ку, декомпилировать ее, смотреть, что же там такое получилось, и почему оно получилось именно так, и в каком порядке все эти штуки применились.
1721.74 1725.02 "Игорь Лабутин" Иногда бывало, какие-то очень сложные комбинации получались.
1725.02 1738.74 "Анатолий Кулаков" Да, это действительно пугает, но ГАЭЛ рассказывает, что сейчас постшарп развился до таких высот, что у него огромное число тестов, у него огромная база кастомеров, а также у него хорошие инструменты для отладки.
1738.74 1747.10 "Анатолий Кулаков" То есть вы можете прямо в отладчике видеть стеки постшарповские, видите исходные коды, видите переменные, и все это хорошо у вас подсвечивается в студии.
1747.10 1756.38 "Анатолий Кулаков" К сожалению, я тоже пользовался постшарпом еще много-много лет назад, когда моя реакция на него была "давайте все это вчера твоей матери выпилим", и мы его выпилили.
1756.38 1770.66 "Анатолий Кулаков" Но по идее сейчас он чувствует себя намного лучше, потому что ГАЭЛ полностью посвящает фуллтайм этому проекту, и у него есть большие жирные клиенты, которые за это готовы башлять.
1770.66 1774.10 "Анатолий Кулаков" Поэтому я надеюсь, что там с процедуционным методом все так хорошо, как он обещает.
1774.10 1788.22 "Анатолий Кулаков" И мы видим, что твои опасения разделяет команда .NET, потому что команда .NET, когда сделала генераторы, она именно главной концепцией подчеркнула, что она не хочет делать модификации, именно потому что она боится.
1788.22 1800.26 "Анатолий Кулаков" Она боится, что это может привести к каким-то непредсказуемым результатам, она боится, что непонятно, кто кого будет модифицировать, как это будет подменяться для разработчиков, неинтуитивно, непонятно, что будет в конце.
1800.26 1804.94 "Анатолий Кулаков" То есть это какой-то непонятный черный ящик, который может привести к всему, чему угодно.
1804.94 1820.22 "Анатолий Кулаков" Но с точки зрения ГАЭЛ, так как он работает уже над аспектно-ориентированным программированием более 15 лет, он говорит, что это в принципе все мелочи, и для того, чтобы создать понятный аспектно-ориентированный пайплайн, достаточно всего-навсего два подхода.
1820.22 1825.90 "Анатолий Кулаков" Во-первых, у вас должна быть read-only, исходная модель, которую никто не может менять.
1825.90 1835.74 "Анатолий Кулаков" И второе, у вас должен быть механизм, с помощью которого вы сможете применять все эти трансформаторы в сортированном виде, то есть в каком-то предсказуемом виде.
1835.74 1836.86 "Анатолий Кулаков" Вот в принципе и все.
1836.86 1843.42 "Анатолий Кулаков" Если мы обеспечим эти две гарантии, то никаких проблем с аспектно-ориентированным подходом у нас быть не должно.
1843.42 1854.10 "Анатолий Кулаков" Мы тогда все сможем предсказать, в принципе и отдебажить, и если мы говорим про сорс-генераторы, то даже сможем посмотреть исходные коды и делать это без переписывания ИЛЯ.
1854.10 1857.62 "Анатолий Кулаков" То есть уберем вот эти самые главные страхи разработчиков.
1857.62 1865.06 "Игорь Лабутин" Ну, хорошо, действительно, наверное, постшарп в современном виде гораздо лучше, чем то, что я когда-то пробовал, и ты много лет назад.
1865.06 1869.02 "Игорь Лабутин" Возможно, надо попробовать, может, еще раз и посмотреть, что из этого получится.
1869.02 1878.66 "Игорь Лабутин" Наверное, на этом все про DotNet 5, и поскольку до релиза DotNet 5 осталось совсем чуть-чуть, мы уже можем немножко затронуть тему DotNet 6.
1878.66 1885.10 "Игорь Лабутин" Microsoft потихонечку начинает раскрывать планы, что же там будет, и понятно, что пока ничего не понятно.
1885.10 1897.06 "Игорь Лабутин" До релиза еще год, и планы могут поменяться очень сильно, но вышло уже несколько статей и видео на тему того, что же потихонечку готовится и в каком направлении все будет двигаться.
1897.06 1907.22 "Игорь Лабутин" Прошел SPNet Community Stand-Up, где как раз обсуждали вопросы планирования и что будет входить в SPNet Core 6, и как вообще все это будет происходить.
1907.22 1917.62 "Анатолий Кулаков" Вообще, Microsoft очень классная вот эта идея, они все свои стендапы практически во всех командах делают открытыми, то есть практически каждый может туда прийти, послушать, поучаствовать, вряд ли, конечно.
1917.62 1924.90 "Анатолий Кулаков" Но вот послушать, посмотреть записи и для себя решить, увидеть, куда движется тот или иной проект.
1924.90 1929.50 "Анатолий Кулаков" Это очень классная у них идея, мне нравится, как они двигаются к Open Source, но именно вот такими шагами.
1929.50 1936.34 "Игорь Лабутин" Да, причем такой Community Stand-Up, он начинается обычно с обзора каких-то прикольных новостей в мире.
1936.34 1945.82 "Игорь Лабутин" Идут на это Open Source, либо какие-то тулзы описывают, либо какие-то новости, важные моменты, какие-то изменения, которые могут кого-то затронуть.
1945.82 1948.78 "Игорь Лабутин" Это все обозревается и дальше переходится уже к основной теме.
1948.78 1954.50 "Игорь Лабутин" Это либо, как в данном случае, было обсуждение планов, либо это непосредственно перевью.
1954.50 1958.82 "Игорь Лабутин" Бывают детальные обсуждения различных фич и пропозлов.
1958.82 1970.70 "Игорь Лабутин" Тоже очень интересно послушать, как Мастодонты и Microsoft обсуждают, как же будут дизайниться кусочки C# или .NET, какого-нибудь отдельного классика, вплоть до там, а сколько конструкторов нам нужно, это прям супер.
1970.70 1975.30 "Игорь Лабутин" И так вот, .NET Core 6 и, в частности, ESP NET Core 6.
1975.30 1984.70 "Игорь Лабутин" Родмап пока еще не определен, и какие-то моментнометки для первой публикации обещают к началу года, или в начале, точнее, следующего года.
1984.70 1993.42 "Игорь Лабутин" Но уже несколько стратегических направлений вырисовывается, и они включают в себя следующие вещи.
1993.42 2003.02 "Игорь Лабутин" Во-первых, цель Microsoft для .NET 6 - это сделать его более привлекательным для новых разработчиков, причем из самых различных бэкграундов.
2003.02 2020.54 "Игорь Лабутин" Мы уже видим, что .NET переходит из такого backend, desktop языка и платформы разработки в и мобильную разработку с Xamarin и будущем MyUI или кем еще, и в браузерную разработку с Blazor.
2020.54 2030.74 "Игорь Лабутин" И поэтому Microsoft хочет расширять, расширять, расширять и привлекать в свою экосистему все больше и больше различных разработчиков на различных платформах и типах приложений.
2030.74 2038.58 "Игорь Лабутин" Второе, так, стратегическое направление - это более качественная поддержка open-source и community и проектов.
2038.58 2050.22 "Игорь Лабутин" Один из упомянутых примеров, уже реализованный, это то, что мы упоминали в одном из прошлых выпусков - добавление автоматической генерации OpenAPI документации в ASP.NET Core темплейтах.
2050.22 2060.46 "Игорь Лабутин" То есть туда ставится Swashbuckle, это абсолютно сторонний для Microsoft продукт, который вам позволяет генерить Swagger документацию автоматически на ваших контроллерах.
2060.46 2065.14 "Игорь Лабутин" И вот таких вот интеграций, по идее, будет больше и больше, если верить Microsoft.
2065.14 2069.06 "Игорь Лабутин" Это две таких очень больших темы.
2069.06 2072.22 "Игорь Лабутин" Третья достаточно большая тема - это Enterprise.
2072.22 2114.90 "Игорь Лабутин" Что туда входит, пока не очень понятно, потому что тема очень обширная и там, начиная от чем заменить WCF до там, как интегрироваться с Ажуром, не знаю, что конкретно попадет в .NET, но по крайней мере такой вот топик есть, что обратить внимание на Enterprise кастомеров, в частности, по многому на то, что внутри Microsoft называется First Party Clients, то есть либо большие проекты внутри самого Microsoft, типа там Bing'а какого-нибудь, который сейчас переехал на .NET Core, либо какие-то действительно очень большие компании сторонние, которые используют .NET, проработать с ними, посмотреть, чего им не хватает, дополнить как-то .NET 6, чтобы он им подходил.
2114.90 2145.82 "Игорь Лабутин" Одна из причин, почему это важно, потому что .NET 6 станет LTS-релизом, Long Term Support, он будет поддерживаться 3 года, и поэтому важно, чтобы корпорации, которые либо живут сейчас на .NET Framework, который, понятно, поддерживается, но непонятно, когда Microsoft решит вдруг перестать его поддерживать, либо они уже таки переехали на .NET Core 3.1, но он перестанет поддерживаться в 2022 году, и таким корпорациям, компаниям придется переходить на .NET 6, поэтому нужно, чтобы там все было.
2145.82 2149.94 "Игорь Лабутин" И последняя тема - это Client Development, то есть это, ну по сути, это Blazor.
2149.94 2158.98 "Игорь Лабутин" По большому счету сейчас, скорее всего, что-то будет, наверное, двигаться с MyUI тоже, но про MyUI пока ничего не слышно, никаких планов, будем ждать каких-то новостей.
2158.98 2164.94 "Игорь Лабутин" Интересно, что параллельно с планированием .NET 6 видно, как развивается tooling.
2164.94 2180.10 "Игорь Лабутин" Microsoft, как известно, по крайней мере .NET Core часть, EISP .NET Core часть, живет на GitHub, то есть это означает, что все issues, все планы, все там, user stories, все остальное заводится просто в виде GitHub issues, и одна из проблем Microsoft, что там все плоско.
2180.10 2197.90 "Игорь Лабутин" GitHub - это просто плоский список issues, да, там есть понятие проектов, там есть понятие milestone, но это все-таки не иерархичная модель, которую вы можете найти в Azure DevOps или в Jira какой-нибудь, и чувствуется, что этого Microsoft не хватает, поэтому они написали tool.
2197.90 2226.62 "Игорь Лабутин" Они написали tool, который по некоторым конвенциям, которым они следуют в их репозитории, выстраивает иерархию GitHub issues, и этот tool, линк на него публичный, он будет в шоу-ноутах, можно там посмотреть в частности все эти высокоуровневые топики, разбитые на user stories, к user stories уже подвешены какие-то issues, где-то уже с пропозлами, в общем, если вам интересно наблюдать, как двигается, развивается и планируется .NET, вот используйте этот tool.
2226.62 2238.42 "Игорь Лабутин" На стендапе показали при этом другой, еще один tool, внутренний уже, который тоже использует GitHub в качестве источника, но он используется больше для приоритизации, чтобы понять, собственно, что копать и куда копать.
2238.42 2265.38 "Игорь Лабутин" Нужно как-то весь этот огромный backlog отранжировать, и когда я беру свой backlog на ближайшие месяц-два в работе, и у меня там 2-3 десятка user stories, и мне надо как-то отранжировать, я уже иногда сижу и долго чешу голову, а у Microsoft по сути план на год, и с тысячей, десятки тысяч пожеланий от всех различных кастомеров, и надо как-то понять, что из этого делать, и совместить с стратегией и пожеланиями топ-менеджмента.
2265.38 2295.74 "Игорь Лабутин" Для этого есть некоторый внутренний tool, который может быть, как они сказали, никогда не за-опенсорсят, но пока он все-таки внутренний, потому что написан пару недель назад или около того, вот, и чисто для их внутреннего использования он позволяет точно так же посмотреть на GitHub issues, но помимо того, что он их как-то классифицирует тегами и еще чем-то, он им добавляет некоторый ранг, то есть чем популярнее, чем более востребований какой-то issue, тем он будет иметь больший ранг, и соответственно можно как-то по этому поводу пытаться выстраивать backlog.
2295.74 2311.34 "Игорь Лабутин" Поэтому для всех, кому небезразлично развитие .NET, и если вы хотите видеть какую-то очень нужную вам фичу, совет от команды .NET, используйте кнопочку upvote, ну а точнее ставьте этот +1 на нужных вам issues, или пишите туда комментарии.
2311.34 2316.54 "Игорь Лабутин" Обе этих метрики используются для оценивания, насколько популярная фича и насколько она нужна.
2316.54 2323.98 "Игорь Лабутин" Чем больше она наберет +1, тем больше вероятность у команды Microsoft посмотрит на нее и поймет, что да, она нужна.
2323.98 2340.94 "Игорь Лабутин" И как обычно, параллельно с .NET командой, работает команда Entity Framework, там тоже, собственно, подходит к концу Entity Framework Core 5 релиз, и нужно уже думать, чем заниматься в Entity Framework Core 6, и здесь команда сделала проще.
2340.94 2348.46 "Игорь Лабутин" Она запустила опросничек, он еще какое-то время будет висеть, ссылочка в шоуноутах, пройдя который вы поможете понять команде вообще над чем работать.
2348.46 2364.38 "Игорь Лабутин" Он довольно-таки подробный, при этом недвиданный, я его прошел минут за 5, и в нем огромное количество вопросов, вида какие фичи Entity Framework вы используете, каких вам не хватает, какие базы данных вы хотели бы еще видеть поддержанными, что вам более важно из вот такого списка фич и так далее.
2364.38 2372.74 "Игорь Лабутин" То есть каким-то образом они пытаются понять, что интересно людям, что они требуют, от чего у них там побаливает и так далее.
2372.74 2386.06 "Игорь Лабутин" При этом почти везде можно указать свои собственные варианты ответов, так что если у вас есть какие-то идеи, куда нужно двигаться Entity Framework, welcome в этот линк, успеете его заполнить и тогда сможете как-то повлиять на развитие Entity Framework.
2386.06 2399.58 "Анатолий Кулаков" Поближе от этих дальних предсказаний у нас есть родные инструменты, которые с нами каждый день, и в одном из таких инструментов, в ReSharper, в версии 2023, вышел долгожданный в фазе Search.
2399.58 2413.34 "Анатолий Кулаков" То есть это нечеткий поиск, который позволяет вам теперь искать слова, даже если вы допустили в них какие-то ошибки или даже если вы пропустили какое-то слово или наоборот, написали слишком много лишних слов, ReSharper теперь способен все это найти.
2413.34 2417.54 "Анатолий Кулаков" Для того, чтобы его попробовать, чтобы его потренировать, нужно вызвать Textual Search.
2417.54 2423.46 "Анатолий Кулаков" Это специальный режим ReSharper, который вызывается с помощью трех нажатий комбинации Ctrl+T.
2423.46 2425.90 "Анатолий Кулаков" Вот такой замысловатый магический трюк.
2425.90 2434.02 "Анатолий Кулаков" Я надеюсь, они все-таки строят его в обычный Ctrl+T, но пока может быть на первых этапах они хотят посмотреть, как это будет работать.
2434.02 2436.98 "Анатолий Кулаков" Самое интересное, что он ищет везде.
2436.98 2444.22 "Анатолий Кулаков" То есть вы можете искать нечетким способом сообщения, которые выдаются, например, пользователю сообщения в логах.
2444.22 2449.42 "Анатолий Кулаков" Вы можете искать ключи в конфигурационных файлах, вы можете искать ваши заметки в комментариях.
2449.42 2451.54 "Анатолий Кулаков" И естественно, вы можете искать сам код.
2451.54 2464.66 "Анатолий Кулаков" То есть если вы примерно помните название методов или аргументов, которые передаются в этот метод, это уже достаточно для того, чтобы воспользоваться не настоящим семантическим поиском по семантическому дереву, а даже текстовым поиском.
2464.66 2467.58 "Анатолий Кулаков" И ReSharper очень удачно такие вещи находит.
2467.58 2471.34 "Анатолий Кулаков" Также зарелизилось парочку мелочей в этой сфере.
2471.34 2480.14 "Анатолий Кулаков" Еще он запоминает последнее слово, которое вы искали, последнюю фразу, которую вы искали, что очень удобно, мелочь, но очень приятная.
2480.14 2486.10 "Анатолий Кулаков" Если вводимый текстбокс для поиска пустой, он вам напомнит последние 10 сёрчей, которые вы искали.
2486.10 2488.18 "Анатолий Кулаков" То есть тоже полезная штука.
2488.18 2499.62 "Анатолий Кулаков" Также очень часто бывает, что у вас находится слишком много результатов, но вы точно помните, например, в каком файле находится то, что вы ищете.
2499.62 2503.90 "Анатолий Кулаков" И специально для этих целей можно теперь фильтровать результаты.
2503.90 2516.22 "Анатолий Кулаков" Если вы в текстбоксе, в котором производите поиск, добавите магические слова, такие например, как /ext, и укажите extension, то вы можете отфильтровать ваш результат только по определенному расширению.
2516.22 2522.58 "Анатолий Кулаков" Другие полезные магические флажки это fm, который позволяет вам фильтровать по файл маски.
2522.58 2524.38 "Анатолий Кулаков" Вы можете задать любую маску.
2524.38 2529.54 "Анатолий Кулаков" cp, который обозначает current project, то есть искать только в текущем проекте.
2529.54 2533.82 "Анатолий Кулаков" Или /., который обозначает искать только в current directory.
2533.82 2536.14 "Анатолий Кулаков" Вот такие мелочи нужно потестировать.
2536.14 2540.70 "Игорь Лабутин" Мне иногда чего-то такого не хватает искать по нескольким солюшенам.
2540.70 2550.58 "Игорь Лабутин" У нас, например, бывает 3-4 исходника нугет библиотеки, ну в смысле 3-4 солюшена разных нугетов, и солюшен, который используют эти нугеты.
2550.58 2554.34 "Игорь Лабутин" Вот мне бы какой-нибудь способ, чтобы их всех сразу открыть и искать по всем.
2554.34 2559.22 "Игорь Лабутин" Потому что я помню, что где-то было, а вот в каком нугете открывать каждый солюшен нугета, искать.
2559.22 2562.90 "Игорь Лабутин" В итоге все сводится к тому, что я просто ищу в файловой системе иногда.
2562.90 2576.54 "Анатолий Кулаков" Вот теперь ты можешь, наверное, поднять на удаленном сервере с помощью код вевми сервиса ReSharper, сгенерить туда один единственный солюшен, в который войдут все твои проекты, там сгенерить этот индекс и сможешь к нему удаленно обращаться.
2576.54 2582.74 "Игорь Лабутин" А потом обновлять этот мегапроект по мере обновления разных нугетиков, точнее разных гидрепозиториев.
2582.74 2585.10 "Игорь Лабутин" Ну, в принципе, может быть, как-то это и заработает.
2585.10 2592.46 "Анатолий Кулаков" Я давно хочу себе ReSharper для операционной системы, чтобы она меня искала и по файлам, и по всем открытым программам, и по браузеру, и где угодно.
2592.46 2593.78 "Анатолий Кулаков" Вот это действительно мощь.
2593.78 2595.46 "Игорь Лабутин" Угу, и рефакторил заодно.
2595.46 2596.54 "Игорь Лабутин" Было бы неплохо.
2596.54 2597.98 "Игорь Лабутин" Ладно, погнали дальше.
2597.98 2602.94 "Игорь Лабутин" Еще одна штука, которая зарелизилась, она немножко нишевая, но интересная.
2602.94 2605.86 "Игорь Лабутин" И стоит про то, чтобы о ней рассказать.
2605.86 2614.30 "Игорь Лабутин" Когда мы создаем новый ASP.NET Core, например, проект, вебап или вебап, то мы можем выбрать, использовать авторизацию.
2614.30 2622.22 "Игорь Лабутин" Причем авторизация может быть основана на Identity Model, это будет наш хороший знакомый Identity Server, который мы упоминали в прошлом подкасте.
2622.22 2644.02 "Игорь Лабутин" Либо же мы можем использовать Azure Active Directory Integration, которым, наверное, пользуются не очень многие, но тем не менее, если вы пишете приложение какое-нибудь корпоративное, которое нужно как-то интегрировать в домен в Azure Active Directory, то вы можете выбрать этот вариант, и у вас тогда будет единая авторизация вместе с Azure и всеми любыми другими сервисами, которые зависят от Azure Active Directory.
2644.02 2646.22 "Игорь Лабутин" То есть это Microsoft Office и все остальное.
2646.22 2650.18 "Игорь Лабутин" Будет вообще такой single sign-on во все приложения.
2650.18 2661.74 "Игорь Лабутин" Но есть проблема, если вы это делаете на S/PWNed Core 3.1, то вы, конечно, получаете такую интеграцию, но у вас там очень анакутция по сравнению с тем, что дает Identity Server.
2661.74 2667.06 "Игорь Лабутин" Если вам нужна работа с сертификатами, особенно клиентскими, добро пожаловать руками и где криптить.
2667.06 2671.40 "Игорь Лабутин" Если вам нужна мультитенантность, добро пожаловать писать все руками.
2671.40 2682.78 "Игорь Лабутин" Если вам нужно использовать single sign-on с External Identity, так называемым, то есть я так понимаю, что это если вы дружите с Azure Active Directory, с каким-то другим Active Directory, то добро пожаловать писать все руками.
2682.78 2686.38 "Игорь Лабутин" Или вообще это даже было несовместимо, если я правильно помню.
2686.38 2687.54 "Игорь Лабутин" Короче, там как-то все было очень плохо.
2687.54 2699.42 "Игорь Лабутин" Поэтому Microsoft выпустил новый пакет Microsoft.identity.web, который позволяет в .NET 5 теперь сделать все гораздо лучше.
2699.42 2707.58 "Игорь Лабутин" Точнее он предоставляет даже некоторый набор темплейтов для приложений, которые позволяют сделать все гораздо лучше, удобнее и красивее.
2707.58 2712.10 "Игорь Лабутин" Это набор из нескольких Nuget пакетов, четырех.
2712.10 2725.02 "Игорь Лабутин" Один это Identity Web, это основная API, основная штука, которая будет работать с Azure Active Directory, предоставлять вам все нужные методы по авторизации и обработке всего этого дела в ваших контроллерах и так далее.
2725.02 2736.10 "Игорь Лабутин" Дальше можно подключить пакеты Identity.web.ui и тогда у вас получатся еще кнопочки для логина/логаута и каких-то интеграций со сторонними сервисами.
2736.10 2746.14 "Игорь Лабутин" Причем этот UI можно кастомизировать, то есть туда можно запихнуть ваше корпоративное лого, еще что-нибудь и получить вашу фирменную страничку логина без особых проблем.
2746.14 2756.14 "Игорь Лабутин" И есть еще два пакета, относящиеся к Microsoft Graph, которые позволяют доступаться к Microsoft Graph сервисам.
2756.14 2759.58 "Игорь Лабутин" Я особо с ними не работал, не буду распространяться, что это такое и зачем.
2759.58 2786.10 "Игорь Лабутин" Если сравнивать фичи темплейтов S/4HANA 3.1 и вот этого нового Microsoft Identity.web, то видно, что есть общие фичи, а именно вы можете логиниться, удивительно, вы можете каким-то образом защищать разные кусочки API и вы можете поддерживать некоторые сторонние интеграции, как я сказал, но в Azure IDE прошлой версии они были достаточно ограничены.
2786.10 2798.02 "Игорь Лабутин" Но сейчас добавилась поддержка нормальной валидации всех эйш-веров, то что мы знаем и давным-давно работает в Identity Server, это появилось сейчас нормально, только сейчас при работе с Azure IDE.
2798.02 2805.34 "Игорь Лабутин" Мы можем, как я сказал, нормально обеспечить работу с сертификатами, теперь не нужно писать никакого ручного кода для этого.
2805.34 2813.26 "Игорь Лабутин" Появилась поддержка заинкрипченных токенов, которые иногда используются, появилась поддержка специальных хедеров, которые используются в некоторых видах авторизации.
2813.26 2818.78 "Игорь Лабутин" В общем, если вам нужно каким-то образом интегрировать с Azure Active Directory, берите эту штуку и прям используйте.
2818.78 2829.18 "Игорь Лабутин" Она, как обычно, заточена под все новые модные Microsoft платформы, то есть это и веб-апи, и веб-апы, и вы можете использовать это в Blazor, в серверной его части.
2829.18 2840.14 "Игорь Лабутин" Кроме того, Microsoft предоставляет кучу примеров того, как использовать это API из Angular, React и прочих всяких клиентских штук, которые вы, может быть, используете в ваших продуктах.
2840.14 2854.98 "Игорь Лабутин" Так что берите, пользуйтесь и, надеюсь, вам не потребуется интегрировать с Azure Active Directory, не очень такая простая задачка, но если вдруг нужно, точно смотрите на этот пакет, Microsoft обещает, что там прям все шоколадно просто и быстро.
2854.98 2862.98 "Анатолий Кулаков" Вообще, по идее, любой продукт внутри Microsoft наверняка уже написал такую реализацию, может быть, это даже и есть компиляция своих внутренних решений.
2862.98 2884.66 "Игорь Лабутин" Да, скорее всего, они просто обернули это в хорошую API, я не смотрел, но, скорее всего, она должна быть, по сути, похожа немножко на то, что мы хорошо знаем с Identity Server, потому что, по сути, там концепции-то все более-менее похожи, и Learning Curve будет лучше и проще с ней начать работать, если вам не нужны какие-то суперсложные фичи.
2884.66 2891.14 "Игорь Лабутин" И работать она будет, на самом деле, лучше за счет того, что она просто предоставляет гораздо больше фич, которые полезны.
2891.14 2899.30 "Анатолий Кулаков" Не отходя далеко от ReSharper, у меня еще одна статейка про него есть, обалденная штука вышла, Data Flow Analysis of Integral Values.
2899.30 2905.54 "Анатолий Кулаков" У ReSharper и Rider добавился новый Data Flow Code Analysis, который позволяет творить интересные вещи.
2905.54 2920.06 "Анатолий Кулаков" Добавился он не просто так, а команда из ReSharper происследовала NuGet.org, посмотрела, проанализировала ILEA, которые там залиты кучами терабайт, и выяснила, между прочим, замечательное открытие.
2920.06 2924.82 "Анатолий Кулаков" Один из типов данных в C# используется больше всего.
2924.82 2926.66 "Анатолий Кулаков" Твои ставки, Игорь, что за тип?
2926.66 2929.26 "Игорь Лабутин" Я бы сказал, скорее всего, String.
2929.26 2930.26 "Анатолий Кулаков" Неправильно.
2930.26 2931.26 "Анатолий Кулаков" Все-таки это оказался Int.
2931.26 2936.70 "Анатолий Кулаков" Я думаю, String недалеко, но Int - это самый главный тип, оказывается, в C#.
2936.70 2949.10 "Анатолий Кулаков" И они решили написать специальный Data Flow Analysis, который трекает использование Int, и помочь в наших программах избежать самых популярных ошибок с этим замечательным типом.
2949.10 2951.26 "Анатолий Кулаков" Итак, что же он уже умеет?
2951.26 2961.10 "Анатолий Кулаков" Этот анализ умеет проверять и находить ошибки, если, например, вы допускаете какие-то логические нестыковки в сравнении или в присвоении Int.
2961.10 2966.94 "Анатолий Кулаков" Если, например, выражение всегда True или False, когда вы работаете с Int в условиях.
2966.94 2972.26 "Анатолий Кулаков" Он умеет определять недостижимые условия в свечах, когда вы матчите Int.
2972.26 2980.06 "Анатолий Кулаков" Он умеет понимать абсурдные математические преобразования, например, когда вы умножаете на единицу или начинаете прибавлять нолик.
2980.06 2986.70 "Анатолий Кулаков" Он умеет следить за overflow Int, если вы вдруг перебросили его через границу.
2986.70 2989.54 "Анатолий Кулаков" Он умеет отслеживать, естественно, деление на ноль динамически.
2989.54 2999.06 "Анатолий Кулаков" Он умеет понимать такие классики, как System Math, то есть он очень хорошо понимает сигнатуру и семантику этих методов, понимает, что они оттуда могли вернуть.
2999.06 3000.78 "Анатолий Кулаков" Как же это работает?
3000.78 3004.50 "Анатолий Кулаков" Для того, чтобы произвести подобный анализ, существует довольно-таки много подходов.
3004.50 3008.26 "Анатолий Кулаков" Команда ReSharper выбирала подход, который называется Abstract Interpretation.
3008.26 3017.06 "Анатолий Кулаков" Это значит, что они интерпретируют весь statement, все expressions, которые сейчас у вас есть в коде, и пытаются этот код проанализировать.
3017.06 3021.46 "Анатолий Кулаков" Естественно, они не знают всех значений, которые могут прийти в рантайме вашей методы.
3021.46 3028.14 "Анатолий Кулаков" Но зато они знают некую информацию, которая позволяет им и их анализу немножко ограничить этот Int.
3028.14 3033.26 "Анатолий Кулаков" Он уже может иметь значения не от min и max, а в каких-то пределах.
3033.26 3044.54 "Анатолий Кулаков" Ну, допустим, если вы вызвали библиотечную функцию Math Apps, которая делает модуль вашему Int, то этот анализ знает, что возвращаемое число обязательно будет менее отрицательное.
3044.54 3059.78 "Анатолий Кулаков" И если вы дальше его, например, проверите в условиях, если результат этого метода меньше нуля, и после этого пойдете писать какую-то логику, то ReSharper вам заботливо подскажет, что не пишите логику, никогда этот код у вас не вызовется, а у вас здесь написана полная чушь.
3059.78 3065.30 "Анатолий Кулаков" Еще один хороший пример интеграции с Math - это новый метод, который появился в .NET 5.
3065.30 3066.30 "Анатолий Кулаков" Этот метод называется Clump.
3066.30 3067.98 "Анатолий Кулаков" Что он делает?
3067.98 3070.10 "Анатолий Кулаков" Он принимает три аргумента.
3070.10 3073.62 "Анатолий Кулаков" Первый аргумент - это некое Int значение.
3073.62 3077.14 "Анатолий Кулаков" Второй аргумент - это минимальный порог, который это значение должно принимать.
3077.14 3080.90 "Анатолий Кулаков" И третий аргумент - это максимальный порог, которого это значение должно принимать.
3080.90 3085.78 "Анатолий Кулаков" Соответственно, метод выравнивает вашу value по границам переданных min и max.
3085.78 3088.58 "Анатолий Кулаков" У этого метода есть одна очень интересная штука.
3088.58 3095.22 "Анатолий Кулаков" Незадекларированный, незадокументированный exception, который метод бросает, если вдруг min и max перепутаны местами.
3095.22 3097.18 "Анатолий Кулаков" Если min больше, чем сам max.
3097.18 3099.10 "Анатолий Кулаков" И об этом вы нигде не почитаете.
3099.10 3108.18 "Анатолий Кулаков" А вот ReSharper'овский DataFlow анализ знает про это и предупредит вас, если вы вдруг поменяли их местами или если вы вдруг передали туда неправильные значения.
3108.18 3113.14 "Анатолий Кулаков" Для того, чтобы помочь этой магии, в ReSharper Annotations появились новые атрибуты.
3113.14 3114.14 "Анатолий Кулаков" Их два штуки.
3114.14 3121.58 "Анатолий Кулаков" Non-negative value, который вы проставляете, зная, что вы общаетесь с аргументом, который никогда не может быть негативным.
3121.58 3128.70 "Анатолий Кулаков" Или более гибкий value range, которым вы проставляете пороги from и to.
3128.70 3133.46 "Анатолий Кулаков" То есть от какой границы может принимать значение ваш int и до какой границы.
3133.46 3137.66 "Анатолий Кулаков" И благодаря этим двум атрибутикам довольно-таки много можно всего сделать полезного.
3137.66 3141.46 "Игорь Лабутин" Ну, звучит прикольно и, наверное, будет полезно.
3141.46 3148.90 "Игорь Лабутин" Я не могу сказать, что я очень часто встречаю такой род ошибки, но, может быть, это специфика проектов, над которыми я работаю, где у нас достаточно мало математики.
3148.90 3157.90 "Игорь Лабутин" И если вы действительно работаете в области обработки изображений, либо еще чего-то, то такие анализы будут очень полезны для вашего кода.
3157.90 3159.54 "Анатолий Кулаков" А меня знаешь, что всегда раздражало?
3159.54 3162.50 "Анатолий Кулаков" Что вот у нас есть у всяких коллекций свойство count.
3162.50 3167.06 "Анатолий Кулаков" И я точно знаю, что count не может вернуться отрицателем никогда.
3167.06 3174.70 "Анатолий Кулаков" И почему я вынужден использовать вот этот int, который мне дает слишком богатый выбор и позволяет мне ошибиться там в каких-то местах?
3174.70 3175.70 "Анатолий Кулаков" Ну, используй у int.
3175.70 3179.74 "Анатолий Кулаков" У int не могу, потому что count мне возвращает всегда int.
3179.74 3180.74 "Анатолий Кулаков" Это по интерфейсу, это по BCL.
3180.74 3185.50 "Анатолий Кулаков" Если я буду использовать int, в очень многих местах мне придется или кастить, или еще что-то делать.
3185.50 3188.26 "Анатолий Кулаков" Ну, вот такие вот мелочи, в принципе, раздражают.
3188.26 3193.18 "Анатолий Кулаков" И вот этот решарперовский кастиль, он более-менее позволяет как-то справиться с этой ситуацией.
3193.18 3201.18 "Анатолий Кулаков" То есть, наверняка решарпер разметил все count с помощью своего атрибута non-negative и будет мне подсказывать, если вдруг я буду с count делать какую-то глупость.
3201.18 3203.94 "Игорь Лабутин" Ну, хорошо, с интеджером понятно.
3203.94 3204.94 "Игорь Лабутин" А еще что-нибудь?
3204.94 3207.42 "Игорь Лабутин" С трингитами, с трингами что-нибудь будет?
3207.42 3211.06 "Игорь Лабутин" Или там все скучно, неинтересно, они immutable, и поэтому все просто?
3211.06 3212.06 "Анатолий Кулаков" Будет.
3212.06 3215.62 "Анатолий Кулаков" Это как первый шаг для того, чтобы опробовать в концепт.
3215.62 3217.66 "Анатолий Кулаков" Дальше эта тема будет развиваться.
3217.66 3228.98 "Анатолий Кулаков" В планах есть понимание длины строк, в планах есть понимание длины массивов, где мы тоже можем ошибаться с индексами и с копированием, и много тоже интересных багов может вылезти.
3228.98 3230.98 "Анатолий Кулаков" Наверное, гораздо интереснее, чем с int.
3230.98 3238.86 "Анатолий Кулаков" Ну, и также точно на базе int будет поддержка для байтов, шотов, лонгов и их unsigned друзей.
3238.86 3240.62 "Анатолий Кулаков" Это тоже будет в будущих версиях.
3240.62 3245.34 "Игорь Лабутин" Ну, прикольно, будем ждать, посмотрим, насколько это будет популярно.
3245.34 3250.78 "Игорь Лабутин" Интересно бы еще узнать, насколько всякие такие вот полезные фичи и анализы реально используются.
3250.78 3258.70 "Игорь Лабутин" То есть нет ли где-то в уличном доступе какой-нибудь статистики на тему, какие фичи решапперам максимально часто используются или еще в таком духе.
3258.70 3259.70 None Не встречал?
3259.70 3260.70 None Я не встречал.
3260.70 3264.58 "Анатолий Кулаков" Наверное, мы можем попросить коллег с нами поделиться какой-нибудь такой нескрытой информацией.
3264.58 3269.42 "Анатолий Кулаков" Ну, я очень много смотрю в твиттере, и в твиттере люди очень часто тегят решаппер.
3269.42 3285.02 "Анатолий Кулаков" И в частности, вот эта фича дата флоа словила интересный твит, в котором автор уже многие годы использовал какой-то код и вдруг внезапно обнаружил, что после установки новой версии решаппера этот код у него никогда не работал так, как он рассчитывал.
3285.02 3292.22 "Анатолий Кулаков" Потому что там он забыл добавить одну единственную строчку, которая инкрементила индексы, и вся логика у него работала абсолютно не так, как он надеялся.
3292.22 3294.26 "Анатолий Кулаков" А вот этот анализ как раз это поймал.
3294.26 3296.94 "Анатолий Кулаков" И таких твитов я встречаю довольно-таки много.
3296.94 3301.18 "Игорь Лабутин" Ну, прекрасно, значит, полезную работу делают ребята.
3301.18 3304.02 "Игорь Лабутин" Пожелаю им удачи и развития всего этого дела.
3304.02 3305.02 "Игорь Лабутин" Погнали дальше.
3305.02 3308.26 "Игорь Лабутин" Джон Скитт, небезызвестный в тот же мире товарищ.
3308.26 3311.18 "Игорь Лабутин" Вы его можете знать по книжкам, вы его можете знать по блогу.
3311.18 3317.62 "Игорь Лабутин" Как может быть вам известно, он работает в Google, и мне, честно говоря, было не очень понятно, что он там делает.
3317.62 3320.42 "Игорь Лабутин" Вроде как что-то про .NET, что-то в Google, что-то для Клауда.
3320.42 3322.14 "Игорь Лабутин" Но что точно, я не очень понимал.
3322.14 3331.38 "Игорь Лабутин" И вот, наконец-таки, от Джона вышла прям статья в его блоге на тему того, что же он делал и чего его команда добилась.
3331.38 3339.26 "Игорь Лабутин" У Google есть такой же сервис, по сути, как есть у Амазона и у Азера, у всех основных облаков.
3339.26 3344.38 "Игорь Лабутин" Это фанкшнс, Google фанкшнс, точнее Google Cloud фанкшнс, если быть точным.
3344.38 3352.30 "Игорь Лабутин" Это, по сути, некоторый фреймворк, который позволяет на разных языках писать функции, которые потом просто исполняются.
3352.30 3360.42 "Игорь Лабутин" Это модный нынче FaaS, function as a service, то есть вы, по сути, платите только за то, что ваша функция требует во
3360.42 3368.66 None время исполнения. И, по большому счету, это основной мотивирующий фактор переходить на функции, что они, в принципе, дешевы.
3368.66 3381.22 "Игорь Лабутин" Потому что все три основных провайдера облачных выдают какой-то базовый объем времени или, в общем, и CPU, и памяти для исполнения функций совершенно бесплатно.
3381.22 3387.38 "Игорь Лабутин" Если у вас какие-то очень маленькие нагрузки, то, в принципе, эти функции вы будете исполнять вполне бесплатно.
3387.38 3393.02 "Игорь Лабутин" Понятно, что если нагрузки растут, вам нужно какое-нибудь супермасштабирование, то за это придется платить, но до этих нагрузок еще надо дожить.
3393.02 3400.06 "Игорь Лабутин" Поэтому такие функции, они очень прикольны для всякого прототипирования или каких-то очень мало нагруженных, например, сайтов или сервисов.
3400.06 3411.26 "Игорь Лабутин" Так вот, у Google долгое время эти функции были, но под них на дотнете писать было, ну, вообще говоря, нельзя, насколько я понимаю, или очень неудобно, во всяком случае.
3411.26 3419.34 "Игорь Лабутин" Никто не мешал, понятно, запихнуть дотнет в докер и использовать все в докере, но это как-то неправильно, если вам нужны бесплатные или быстрые какие-то такие операции.
3419.34 3421.82 "Игорь Лабутин" Наконец-таки зарелизили .NET Functions Framework.
3421.82 3429.62 "Игорь Лабутин" Это, по сути, дотнетная реализация, Functions Framework Contract, то, что называется у Google, по сути, позволяющая писать на дотнете эти самые функции.
3429.62 3436.10 "Игорь Лабутин" И надо сказать, зарелизили прям прикольную штуку в том смысле, что она смотрится очень органично.
3436.10 3444.70 "Игорь Лабутин" Во-первых, появился пакетик с темплэйтами, который позволяет вам создать один из трех видов Google Cloud функции.
3444.70 3454.42 "Игорь Лабутин" Во-первых, самый простой вид - это то, что называется HTTP Triggered Function, то есть, по сути, функция, которая просто будет дергаться, когда на какой-то HTTP endpoint вам придет запрос.
3454.42 3458.94 "Игорь Лабутин" Второй вариант - это Google Cloud Functions Events.
3458.94 3466.34 "Игорь Лабутин" Это строго типизированные функции, но которые могут реагировать уже на произвольные события в Google Клауде.
3466.34 3469.10 "Игорь Лабутин" Есть еще Google Cloud Functions Untype Event.
3469.10 3475.58 "Игорь Лабутин" Это значит, что вам просто приходит тот пейлоуд, который вам прислали, и вам нужно самостоятельно все децерализовывать, все данные из этого пейлоуда.
3475.58 3479.58 "Игорь Лабутин" Если вы обмениваетесь какими-то совсем кастомными сообщениями, наверное, это подойдет вам.
3479.58 3484.34 "Игорь Лабутин" Для примера посмотрим на HTTP функцию, как наверняка самую популярную.
3484.34 3495.78 "Игорь Лабутин" Для того, чтобы ее написать, достаточно написать новый класс, наследовать его от IHTTP Function и реализовать единственный метод паблика - asyncTask, handleAsync от HTTP контекста.
3495.78 3503.22 "Игорь Лабутин" То есть, по большому счету, это то, что вы хорошо знаете в ASP.NET Core как middleware в некотором смысле.
3503.22 3511.90 "Игорь Лабутин" Единственное, что там нету штуки next, но там есть HTTP контекст, и вам просто нужно с этим контекстом получить из него данные реквеста и написать туда респонс.
3511.90 3513.38 "Игорь Лабутин" На этом как бы все.
3513.38 3523.78 "Игорь Лабутин" Все будет работать, все сделано, видимо, не случайно, очень похоже на ASP.NET Core с точки зрения терминологии и того, как это все пишется, чтобы все было очень похоже.
3523.78 3531.94 "Игорь Лабутин" После того, как вы написали такой классик в вашем проекте, вы просто говорите dotnet run и оно все магическим образом работает у вас локально на компьютере.
3531.94 3537.98 "Игорь Лабутин" Для того, чтобы задеплоить, уже нужна, понятно, API от Google Cloud, tooling от него.
3537.98 3545.26 "Игорь Лабутин" Вы вызываете gcloud function задеплой и указываете, какую функцию задеплоить, куда задеплоить, ключи подписки, все дела.
3545.26 3546.74 "Игорь Лабутин" Все деплоится, все работает.
3546.74 3551.86 "Игорь Лабутин" Вам в WebUI надо будет только посмотреть URL, по которому собственно вашу функцию дергать.
3551.86 3560.90 "Игорь Лабутин" Одна из сложностей всей этой штуки заключается в том, что, как я сказал, вы пишете один единственный класс function, а потом говорите dotnet run и все работает.
3560.90 3567.90 "Игорь Лабутин" А dotnet run, как известно, нужен main, метод, ну вот это всякие такие приседания, которые вроде как вы не писали.
3567.90 3575.74 "Игорь Лабутин" И по словам Джона, это была одна из самых сложных и ключевых вещей сделать вот такой developer experience максимально прозрачным.
3575.74 3582.94 "Игорь Лабутин" То есть вам не нужно писать каких-то искусственных мейнов, создавать каких-то временных хостингов, чтобы вашу функцию захостить локально.
3582.94 3585.10 "Игорь Лабутин" А вы просто говорите dotnet run и все работает само.
3585.10 3592.10 "Игорь Лабутин" Там есть кусочек кода генерации, который изгенерит нужный мейн и который автоматически вызовет вашу функцию, если она одна в проекте.
3592.10 3596.86 "Игорь Лабутин" Если их несколько, там все-таки придется каким-то образом выбирать, какую же функцию вызывать.
3596.86 3599.62 "Игорь Лабутин" Но это тоже все сделано прозрачно и удобно.
3599.62 3607.58 "Игорь Лабутин" Одна из дополнительных вещей к пакету, который мы зарелизили, называется Google Cloud Functions Testing.
3607.58 3610.62 "Игорь Лабутин" И это тоже, по словам Джона, очень прикольная концепция.
3610.62 3621.86 "Игорь Лабутин" Это некоторый дополнительный пакет, который обычно в продакшене вам уже не нужен, но он содержит огромное количество удобных утилит, что ли, для тестирования того кода, который вы написали.
3621.86 3636.86 "Игорь Лабутин" Поскольку все эти функции поддерживают стандартный dependency injection, то есть вы туда можете заинжектировать iLogger и прочие такие штуки, то для того, чтобы это все тестировать, было бы удобно иметь какой-нибудь InMemory логгер сразу, чтобы проверять, например, что у вас функция правильно логирует.
3636.86 3649.42 "Игорь Лабутин" Вам нужно уметь из тестов вызывать такую функцию и желательно сериализацию и децерализацию объектов возложить на framework, потому что функцию нужно передать RSTTP контекст, вы не будете в юнит-тесте собирать RSTTP контекст для этой функции.
3649.42 3654.02 "Игорь Лабутин" И вам нужно в конце концов как-то хостить эту функцию, чтобы она таки запустилась.
3654.02 3665.98 "Игорь Лабутин" Вот как раз таки этот пакет Testing, он содержит все эти штуки и позволяет вам юнит-тест наследовать от специального базового класса, который выдаст вам сразу готовые методы для вызова вашей функции.
3665.98 3683.26 "Игорь Лабутин" То есть в юнит-тесте можно будет просто писать по сути .NET вызов, как будто вы вызываете .NET функцию, а оно само вызовет вашу Google Cloud Function, захочетную во временном хостинге с заинжекционными правильными временными логгерами, которые пишут в памяти и вы можете просмотреть весь output.
3683.26 3685.58 "Игорь Лабутин" В общем, крайне удобно и рекомендуется.
3685.58 3695.42 "Игорь Лабутин" При этом функции являются обычным, похожим на SpanNetCore кодом, то есть там работает, как я сказал, Dependency Injection и всякие подобные штуки.
3695.42 3708.98 "Игорь Лабутин" И у функции можно определить стартап-класс, он определяется с помощью атрибутика function Startup на классе, туда передается тип того класса, который нужно использовать как стартапный и для него действуют те же самые конвенции, что для SpanNetCore.
3708.98 3720.66 "Игорь Лабутин" То есть там есть метод ConfigureServices, где вы будете конфигурировать ваш Dependency Injection, там есть метод Configure, где вы можете дополнительно в pipeline что-нибудь запихнуть, но функция всегда будет последней гарантирована в этом pipeline.
3720.66 3724.06 "Игорь Лабутин" И таким образом как-то до настраивать ваши функции.
3724.06 3730.66 "Игорь Лабутин" И в дополнение к этому есть еще два пакеджа, это Google Cloud Events и GoogleCloudEvents.net.
3730.66 3742.46 "Игорь Лабутин" В первом, соответственно, лежит описание схемы данных, которые могут ходить внутри Google Cloud Platform, то есть всех вот этих ивентов, которые может принять ваша функция.
3742.46 3754.14 "Игорь Лабутин" А во втором пакете лежит C# реализация для всех этих данных, то есть вы можете ее использовать, если вам нужно самостоятельно децерализовывать что-то или на основе нее что-то писать, используйте этот пакет.
3754.14 3761.70 "Игорь Лабутин" В общем, Google пытается затащить в свои функции .NET тоже, вместе с Amazon и, естественно, Azure.
3761.70 3773.90 "Игорь Лабутин" Посмотрим, как это будет развиваться, но именно как пример такого хорошего SDK, что ли, это прям супер набор пакетов и очень рекомендуется посмотреть, как это нужно делать.
3773.90 3777.42 "Анатолий Кулаков" Совсем замечательную и долгожданную фичу выкатил GitHub.
3777.42 3779.74 "Анатолий Кулаков" Не знаю, как ты, Игорь, а я вот давно об этом мечтал.
3779.74 3786.86 "Анатолий Кулаков" Теперь мы имеем хотя бы базовые какие-то инструменты для того, чтобы навигироваться по коду прямо в GitHub.
3786.86 3795.66 "Анатолий Кулаков" Очень полезная штука, особенно если ты исследуешь какой-то чужой код, ты не знаешь, где это идти, куда автор поместил эти интерфейсы, куда он поместил эту имплементацию.
3795.66 3802.82 "Анатолий Кулаков" И меня всегда одолевал буйный вопрос, а почему же GitHub умеет все это подсвечивать, умеет индексировать, и вообще там умные дядьки сидят.
3802.82 3811.46 "Анатолий Кулаков" Почему же он не может сделать хотя бы каких-то элементарных базовых вещей, которые простые редакторы умеют делать уже, то есть ходить по definition.
3811.46 3813.38 "Анатолий Кулаков" И он все-таки смог.
3813.38 3822.34 "Анатолий Кулаков" Теперь GitHub умеет понимать C# код, умеет джампиться на definition, умеет находить все референсы, умеет навигироваться по файловой структуре.
3822.34 3831.46 "Анатолий Кулаков" Например, если вы видите какой-то файлик на экране, вы можете вверху выбрать классики, которые объявлены в этом файлике, или методы, которые объявлены внутри этого классика.
3831.46 3835.86 "Анатолий Кулаков" Напоминает Visual Studio, у которой тоже есть такие соответствующие менюшечки.
3835.86 3853.82 "Анатолий Кулаков" Чтобы снавигироваться по методу или по функции, вы должны кликнуть прямо в исходном коде по этой функции, у вас появится специальная карточка, в которой можно выбрать референс или definition, если вы хотите посмотреть, и будет произведен поиск соответствующих функций в том же самом репозитории.
3853.82 3856.66 "Анатолий Кулаков" И если они найдутся, то вас туда снавигируют.
3856.66 3863.46 "Анатолий Кулаков" Функция появилась недавно, и еще не все репозитории может быть у вас проиндексировались, и эта функция будет доступна.
3863.46 3879.46 "Анатолий Кулаков" У меня, например, половина в репозиториях есть, во второй половине мне необходимо было потыкать бранч, потому что GitHub прежде всего индексирует те бранчи, которые активными, поэтому вам надо туда или запулить, или запушить, или каким-нибудь другим способом дать GitHub понять, что вы хотите здесь получить анализ.
3879.46 3883.78 "Анатолий Кулаков" Но после того, как он один раз это сделал, эта функция уже будет у вас дальше работать.
3883.78 3897.14 "Анатолий Кулаков" Естественно, C# появился не самым первым, до этого уже поддерживалось несколько языков, среди которых, кроме C#, Java, TypeScript, JavaScript, Go, PHP, Python, Ruby и CodeQL.
3897.14 3907.38 "Анатолий Кулаков" Очень приятная штука, которая позволяет нам не только лазить по своим файликам, которые мы примерно знаем, кто и где лежат, но и прежде всего исследовать чужой
3907.38 3933.42 "Игорь Лабутин" код. Теперь будет еще бы прикольно, если бы эту функцию раскатили на возможность поиска внутри организации, потому что у меня довольно частый кейс, когда я что-нибудь ищу в репозитории Microsoft, в S/P/Nad Core, а он ссылается на какой-нибудь .NET Runtime, было бы прекрасно иметь возможность из одного репозитория прыгнуть в другое и посмотреть, как там что-нибудь реализовано, какой-нибудь ToString для какого-нибудь внутреннего класса или что-нибудь в таком духе.
3933.42 3937.78 "Анатолий Кулаков" А еще ему ничего же не помешает проанализировать твои Nuget зависимости.
3937.78 3944.34 "Анатолий Кулаков" И наверняка половина из этих Nuget зависимостей лежит на GitHub со своим исходным кодом, со своей версией и с понятным бранчом.
3944.34 3947.94 "Анатолий Кулаков" И тоже можно было бы вполне зайти и посмотреть, что там происходит.
3947.94 3952.30 "Игорь Лабутин" В хорошем Nuget пакете у тебя будет ссылка действительно на GitHub, и Nuget.org ее отображает.
3952.30 3958.26 "Игорь Лабутин" И в еще более хорошем Nuget пакете у тебя будет прям commit hash, из которого собран Nuget пакет.
3958.26 3961.58 "Игорь Лабутин" Можно прям найти точную версию, из чего он был собран.
3961.58 3972.18 "Анатолий Кулаков" А дальше мы подцепляем сюда микрософтовский редактор, который автоматически инлайнит весь GitHub и позволяет его компилировать прямо в Azure DevOps, а потом это все деплойить.
3972.18 3976.42 "Анатолий Кулаков" И получаем прекрасные репозитории с прекрасным редактором и прекрасным деплой пайплаймер.
3976.42 3981.18 "Игорь Лабутин" Да, и не надо писать код, нужно просто его найти где-нибудь и оттуда завязать.
3981.18 3982.62 "Анатолий Кулаков" Об этом наша другая тема.
3982.62 3984.62 "Анатолий Кулаков" Как раз-таки, каким образом все найти.
3984.62 3989.02 "Анатолий Кулаков" У автора Берта Наллеройа стало почти такое же желание, как и у тебя.
3989.02 3994.42 "Анатолий Кулаков" Но только он захотел поискать не среди всего, всей организации, всего GitHub, а намного проще.
3994.42 3999.30 "Анатолий Кулаков" Ему захотелось поискать что-то внутри своего маленького приложения.
3999.30 4002.90 "Анатолий Кулаков" И он считает, что любое приложение должно обладать способом поиска.
4002.90 4013.02 "Анатолий Кулаков" Неважно где вы его билдите, насколько у него важны данные, в какой он организации, что он хранит, текстовый поиск нужен практически каждому приложению, даже самому маленькому.
4013.02 4016.02 "Анатолий Кулаков" И в принципе в этом меня очень сильно убедил ReSharper.
4016.02 4028.10 "Анатолий Кулаков" Потому что я был очень большим приверженством тоже того, что информацию, если правильно структурировать, разложить интерфейсики по папочкам, организовать правильно проектики, то это решит все мои проблемы.
4028.10 4030.18 "Анатолий Кулаков" Нет, не решает.
4030.18 4034.26 "Анатолий Кулаков" Потому что папочек много, файликов много, имена забываются.
4034.26 4036.26 "Анатолий Кулаков" Единственное, что решает, это поиск.
4036.26 4037.58 "Анатолий Кулаков" Желательно еще и не четкий.
4037.58 4040.38 "Анатолий Кулаков" И поэтому ReSharper очень сильно выручает в этом месте.
4040.38 4046.06 "Анатолий Кулаков" Таким же образом можно применить поиски в вашей программе, даже если вы думаете, что искать там абсолютно нечего.
4046.06 4049.62 "Анатолий Кулаков" Все и так у вас структурировано, разложено и в менюшках записано.
4049.62 4054.54 "Анатолий Кулаков" Опять же, никто не знает, где эти менюшки, где эти настройки и каким образом найти нужную кнопку.
4054.54 4056.18 "Анатолий Кулаков" Поиск вам очень сильно может помочь.
4056.18 4072.58 "Анатолий Кулаков" Но, к сожалению, за все эти годы написания распределенных баз данных, написания облаков на дотнете, поднятия бинга и стекового флоа на дотнете, никто так и не умудрился написать маленький поиск, который был бы легко встраиваемый для маленьких программок на дотнете.
4072.58 4085.06 "Анатолий Кулаков" Естественно, для поиска у нас есть такие большие гиганты, как Lucent.net, Solar, Elastic, но все они слишком большие и слишком сложные для того, чтобы их тащить в каждое приложение и туда их встраивать.
4085.06 4089.46 "Анатолий Кулаков" А хочется не просто string contents, а нормальной морфологии.
4089.46 4093.22 "Анатолий Кулаков" И эту проблему теперь решает новый проект, который называется LunarCore.
4093.22 4097.14 "Анатолий Кулаков" Это порт с JavaScript библиотеки LunarJS.
4097.14 4110.38 "Анатолий Кулаков" И отличается он тем, что имеет очень маленький размер, у него нет никаких зависимостей, он поддерживает полный текстовый поиск и как раз таки нацелен на то, чтобы внедряться в маленькие приложения.
4110.38 4115.70 "Анатолий Кулаков" Основные его фишки это как раз таки простота, легкость интеграции и легкость использования.
4115.70 4118.98 "Анатолий Кулаков" Но при этом он довольно таки фичастая библиотека получилась.
4118.98 4122.18 "Анатолий Кулаков" Как я уже сказал, это полный текстовый поиск для 14 языков.
4122.18 4125.42 "Анатолий Кулаков" Он умеет индексировать все с очень простым интерфейсом.
4125.42 4131.58 "Анатолий Кулаков" Ему достаточно передать dictionary с ключом и документом, который нужно проиндексировать, и все.
4131.58 4138.74 "Анатолий Кулаков" После этого у него внутри работает стеймер, то есть это специальный алгоритм по нахождению основы слова.
4138.74 4147.58 "Анатолий Кулаков" У него внутри работает фази-серчинг, который позволяет измерить дистанцию слова и который позволяет производить поиск на основе шаблона.
4147.58 4155.58 "Анатолий Кулаков" Он умеет роджировать документы по релевантности, то есть на сколько процентов тот или иной документ удовлетворяет вашим запросам.
4155.58 4158.82 "Анатолий Кулаков" Он понимает шумовые слова, так называемые stop words.
4158.82 4165.58 "Анатолий Кулаков" Он умеет искать по филдам в каком-то определенном классе или по специальному документу, который вы для него соберете.
4165.58 4172.58 "Анатолий Кулаков" У него плагиновая структура индексов и очень гибкий сервс-пайплайн, который вы можете настраивать.
4172.58 4183.18 "Анатолий Кулаков" Еще одним интересным побочным эффектом того, что этот проект был портирован из JS-овской библиотечки, является то, что формат его индекса полностью совместим с LunarJS.
4183.18 4200.62 "Анатолий Кулаков" Это значит, что вы можете проиндексировать какой-то большой массив данных на сервере, сохранить это, материализовать в индекс, отправить браузеру и браузер уже на 100% совместимый с проектом LunarCore может вам произвести поиск по вашему индексу.
4200.62 4205.70 "Анатолий Кулаков" Тоже такой интересный маленький лайфхак, как взаимодействовать фронтенду и бэкенду в этом плане.
4205.70 4209.90 "Игорь Лабутин" Мне никогда не приходилось использовать какие-то такие простые мелкие штуки.
4209.90 4213.74 "Игорь Лабутин" У нас в основном был эластик, там где было необходимо.
4213.74 4218.30 "Игорь Лабутин" Но действительно это отдельный, по сути, продукт, который нужно отдельно ставить и отменить.
4218.30 4242.30 "Игорь Лабутин" Возможно, держать его кластер даже, но на больших объемах понятно, что Lunar не будет справляться, но особенно если вам нужно как-то взаимодействовать с фронтендом и обеспечивать поиск на фронте, почему нет подготовить данные на сервере, может быть, даже достав их на самом деле из какого-нибудь большого эластика, запаковать в какой-то понятный формат и отправить на клиент, чтобы клиент их офлайновал по сути, все это процессило, почему
4242.30 4253.42 "Анатолий Кулаков" нет. Мы недавно столкнулись с этой проблемой, когда разрабатывали мобильное приложение для DotNet.ru Community, которое умеет отображать спикеров, докладов, какие-то даты митапов и так далее.
4253.42 4256.18 "Анатолий Кулаков" То есть там много текстовой информации, по которой было бы интересно поискать.
4256.18 4265.50 "Анатолий Кулаков" И как раз таки пытались найти какую-нибудь библиотеку для поиска, которая работала еще в офлайне, не тратила бы наш интернет и не требовала бы каких-то SaaS решений.
4265.50 4280.14 "Анатолий Кулаков" И если в общем поиск в виде SaaS еще найти довольно-таки просто, то вот маленьких таких интеграционных решений на мобилке, когда все данные у меня уже есть и никуда мне ходить не надо, вот их удобных не нашлось.
4280.14 4284.46 "Анатолий Кулаков" И поэтому эта библиотека, это у нас сейчас первый кандидат на то, чтобы попробовать делать такую штуку.
4284.46 4285.46 "Игорь Лабутин" Ну это здорово.
4285.46 4291.18 "Игорь Лабутин" Опять же она лежит на GitHub, можно, если чего-то не хватает, приходить к автору, помогать, контрибьютить.
4291.18 4310.26 "Игорь Лабутин" Там уже есть немножко проповодов новых фич, как например кастомные форматы сериализации, то есть формат, совместимый с LunarJS, это очень здорово, но это все-таки JSON, он довольно многословный и возможно вы захотите сериализовывать куда-то еще, посмотрите обсуждение, там оно уже идет на предмет, что можно запилить еще.
4310.26 4312.34 "Игорь Лабутин" Так что добро пожаловать на GitHub.
4312.34 4321.42 "Анатолий Кулаков" Также автору нужна большая помощь по портированию документации, потому что к самому Lunar документация довольно-таки хорошая, вот ее нужно адаптировать под .NET специфику и портировать.
4321.42 4326.50 "Анатолий Кулаков" То есть работа не слишком тяжелая, но очень полезная для .NET мира, поэтому тоже присоединяйтесь.
4326.50 4329.66 "Игорь Лабутин" Да, ну и на этом я думаю, что мы на сегодня будем заканчивать.
4329.66 4350.30 "Игорь Лабутин" Мы много чего успели обсудить, мы поговорили про .NET 5, немножечко вспомнили про App Trimming, посмотрели на примеры Breaking Change, которыми уже сталкиваются реальные разработчики и поговорили про Source Generator и как они соотносятся с миром аспектно-ориентированного программирования в виде PostSharp.
4350.30 4360.14 "Игорь Лабутин" Немножечко затронули тему планирования .NET 6 и как можно повлиять на то, что же войдет в .NET 6 и дальше пошли обсуждать различные пакеты, тулы и прочее.
4360.14 4367.26 "Игорь Лабутин" В ReSharper появился Fuzzy Search, в ReSharper появился Data Flow, Flow Analysis для целых чисел.
4367.26 4377.18 "Игорь Лабутин" Microsoft выпустил Microsoft Identity Web, который позволяет удобнее интегрироваться с Azure, Active Directory и прочим корпоративным интерпризным сектором.
4377.18 4383.74 "Игорь Лабутин" Google в свою очередь выпустил .NET Functions Framework, позволяющий запускать ваш .NET код на Google платформе.
4383.74 4388.50 "Игорь Лабутин" Если вы пользуетесь Google платформой и пишете на .NET, очень рекомендую посмотреть, попробовать.
4388.50 4391.38 "Игорь Лабутин" И GitHub выкатил фичу по навигации по коду.
4391.38 4400.18 "Игорь Лабутин" LunarJS был портирован на .NET и теперь есть нормальная простая библиотечка для каких-то простых применений поиска на .NET.
4400.18 4409.46 "Анатолий Кулаков" Друзья, у нас довольно-таки часто сейчас возникают такие вопросы, которые немножко не относятся к теме подкаста, а больше касаются каких-то наших личных предпочтений.
4409.46 4417.26 "Анатолий Кулаков" Поэтому мы с Игорем решили записать ближе к Новому году какой-нибудь специальный выпуск, в котором мы не будем обсуждать новости, а как раз-таки поотвечаем на ваши вопросы.
4417.26 4429.86 "Анатолий Кулаков" Поэтому у нас объявляется новая активность, задавайте нам любые вопросы, на которые вы хотели бы услышать ответы, которые касаются, может быть, нас, может быть, нашей деятельности или вообще поговорить о жизни.
4429.86 4439.62 "Анатолий Кулаков" Мы соберемся таким теплым ламповым составом и обсудим эти вопросы в каком-нибудь интересном формате, который ближе к Новому году уже определим вместе с вами.
4439.62 4449.22 "Анатолий Кулаков" Ваши комментарии вы можете слать нам на почту radiosobaka.net.ru или же бросать их в комментарии к этому выпуску на YouTube.
4449.22 4455.58 "Анатолий Кулаков" Мы там тоже все читаем и всячески благодарны вам за любой фидбэк, положительный или отрицательный.
4455.58 4464.50 "Анатолий Кулаков" Нам очень интересно узнать, каким образом вы нас слушаете, откуда вы нас слушаете и что бы вам хотелось предложить или улучшить или исправить в нашем шоу.
4464.50 4472.42 "Анатолий Кулаков" Также кроме YouTube нас можно слушать на Google подкастах, Apple подкастах, Яндекс.Музыке и, конечно же, в вебе.
4472.42 4476.66 "Анатолий Кулаков" Подключайтесь, шарьте, репостьте и всячески любите
4476.66 4480.38 "Игорь Лабутин" нас. И вот так вот наш 16 выпуск заканчивается.
4480.38 4481.38 "Игорь Лабутин" Всем пока.
4481.38 4481.88 "Игорь Лабутин" Счастливо.
4481.88 4487.64 "Игорь Лабутин" [музыка]
