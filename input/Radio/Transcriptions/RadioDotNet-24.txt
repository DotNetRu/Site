0.00 5.00 "Анатолий Кулаков" Привет, дорогие друзья!
5.00 9.44 "Анатолий Кулаков" В эфире Radio.net и в студии, как всегда, Анатолий Кулаков.
9.44 10.44 "Анатолий Кулаков" И Игорь Лабутин.
10.44 11.44 "Анатолий Кулаков" Привет!
11.44 22.84 "Анатолий Кулаков" У нас уже записывается 24 выпуск и прежде чем начать основной выпуск, нам бы хотелось поблагодарить нашего благодарного слушателя Александра.
22.84 24.64 "Анатолий Кулаков" Александр, большое спасибо за помощь!
24.64 27.60 "Анатолий Кулаков" Этот подкаст выходит практически благодаря тебе.
27.60 30.12 "Анатолий Кулаков" Давайте теперь к темам.
30.12 32.12 "Анатолий Кулаков" Я видел там Visual Studio новое вышло.
32.12 35.12 "Игорь Лабутин" Ну, новое, как обычно, там минорный апдейт.
35.12 39.44 "Игорь Лабутин" В 16.9 они добрались наконец-таки до двузначных чисел, 16.10.
39.44 40.44 "Игорь Лабутин" Но там превьюшка.
40.44 43.48 "Игорь Лабутин" Давайте сначала посмотрим, что в 16.9 нам привезли.
43.48 47.88 "Игорь Лабутин" Это нормальный релиз, который уже можно себе нормально поставить, никакая не превью-версия.
47.88 50.36 "Игорь Лабутин" Там довольно много C++ улучшений.
50.36 55.76 "Игорь Лабутин" Если вы пользуетесь C++ почему-то и слушаете Radio.net, то посмотрите внимательно.
55.76 58.84 "Игорь Лабутин" Но мы больше оправдываемся на это, конечно же.
58.84 67.96 "Игорь Лабутин" Во-первых, Microsoft вложилась в тех, у кого очень часто происходит Stack Overflow Exceptions и те, кто пишет бесконечные рекурсии и все такое.
67.96 73.92 "Игорь Лабутин" Если у вас такое случается, теперь CallStack будет гораздо более умным.
73.92 79.24 "Игорь Лабутин" Он будет вырезать повторяющиеся кусочки и вы сможете наконец-таки посмотреть, откуда же у вас все это началось.
79.24 84.40 "Игорь Лабутин" Microsoft уверяет, что это прям киллер фича и прям очень удобно дебажить теперь это дело.
84.40 89.64 "Игорь Лабутин" Кроме того, в разряд дебаггинга завезли новые Memory Dump Analyzers.
89.64 97.52 "Игорь Лабутин" И это прикольно, потому что есть ряд проблем, которые иногда возможно решить только с помощью Memory Dump.
97.52 99.68 "Игорь Лабутин" Один из таких случаев - это дедлоки.
99.68 106.72 "Игорь Лабутин" И дедлоки нужно аккуратно анализировать треды, смотреть, кто какие логи держит, кто с кем вообще взаимодействует.
106.72 116.24 "Игорь Лабутин" Теперь у нас есть автоматизированный аналайзер, которому можно скормить NetCore на Memory Dump, и он сам постарается найти золоченные друг на друга треды.
116.24 128.40 "Игорь Лабутин" Причем он учитывает и Finalizer Queue, то есть если у вас есть какой-то хитрый код в финалайзерах, который почему-то не дает быстро завершиться финалайзеру, то это тоже считается дедлоком, это тоже будет найдено и каким-то образом показано.
128.40 132.76 "Анатолий Кулаков" Я помню, в WinDBG была такая команда, типа "найди мне дедлок".
132.76 133.76 "Игорь Лабутин" Это что-то похожее?
133.76 135.20 "Игорь Лабутин" Да, видимо, это что-то похожее.
135.20 150.08 "Игорь Лабутин" Я помню, что я в WinDBG какой-то такой командой пользовался, но она мне ничего не показала, и мне пришлось ручками разбираться в списке локов, в списке тредов и смотреть, кто в каких call stack'ах живет, и понимать вообще, кто на ком завязан.
150.08 155.76 "Игорь Лабутин" Но там были какие-то хитрые локи через несколько потоков, возможно, она просто не смогла это понять, а простой бы дедлок из двух потоков, она бы смогла.
155.76 164.88 "Игорь Лабутин" Так, дальше Microsoft улучшает IntelliSense, ну или теперь это у них называется IntelliCode, хотя может раньше так называлось, я уже не помню.
164.88 171.08 "Игорь Лабутин" У них очень забавный заголовок, это теперь называется Frictionless Suggestions в списке автодополнения.
171.08 191.36 "Игорь Лабутин" То есть теперь, когда вы пишете код и Visual Studio вам предлагает список для автодополнения, там будет не только методы или константы какие-то, enum'чики, которые у вас в коде есть, но он также будет пытаться предугадать те, допустим, аргументы вызова функции, которым вы хотите эту функцию вызвать.
191.36 197.20 "Игорь Лабутин" То есть у вас, по сути, будет пытаться дополниться вся строчка целиком, или по крайней мере, expression.
197.20 208.64 "Игорь Лабутин" В статье есть небольшая гифка, которая показывает, как это делать, как это происходит, но я пока еще не попробовал эту фичу в реальности, поэтому сильно не могу комментировать, насколько она стала умная.
208.64 210.20 "Игорь Лабутин" Но говорят, что прям супер.
210.20 220.56 "Анатолий Кулаков" Вот, судя по описанию, мне кажется, что вот в плане IntelliCode Visual Studio скоро ReSharper обгонит, потому что у ReSharper у меня в принципе единственная претензия есть это к его подсказкам в IntelliSense.
220.56 223.24 "Анатолий Кулаков" Он там абсолютно сильно лажает.
223.24 234.16 "Анатолий Кулаков" Вот, если мы уже затронули ReSharper, то огромная часть статьи про нововведение Visual Studio никогда не обходится про то, что они еще стыгли из ReSharper.
234.16 247.84 "Анатолий Кулаков" И вот и здесь точно так же добавилось автоматическое вставление ютингов, как только вы копипастите код, добавились подсказки, inline-хинты, которые тоже у ReSharper и у Rider уже есть до сих пор.
247.84 251.52 "Анатолий Кулаков" И много-много чего еще скопировано из мелочей.
251.52 257.60 "Игорь Лабутин" Да, так что посмотрите, пользуйтесь, проверяйте, что там появилось новенького, интересного.
257.60 263.04 "Игорь Лабутин" Какие-то вещи скрыты за сеттингами и надо читать такие статьи внимательно, чтобы увидеть, как их выключить.
263.04 270.24 "Игорь Лабутин" Или те же inline-хинты, если они выключены, то нужно знать, что нужно нажать, по-моему, Alt+F1, чтобы они появились внезапно.
270.24 271.72 "Игорь Лабутин" Ну, а потом исчезли.
271.72 273.12 "Игорь Лабутин" Дальше по улучшениям.
273.12 275.60 "Игорь Лабутин" Улучшилась поддержка Windows App System for Linux.
275.60 278.96 "Игорь Лабутин" Теперь вы можете отлаживать ваше .NET Core приложение прямо из студии.
278.96 286.08 "Игорь Лабутин" Если .NET Core на приложении работает на Linux, то есть прямо из студии можно затачиться и все будет замечательно работать.
286.08 291.96 "Игорь Лабутин" Это, по-моему, работает не для всех Linux, Linux официально, но неофициально должно работать для всех.
291.96 295.36 "Игорь Лабутин" В статье есть список того, с чем оно точно работает и протестировано.
295.36 298.20 "Игорь Лабутин" Остальное пока все в таком экспериментальном режиме.
298.20 302.12 "Игорь Лабутин" И улучшили тулы для работы с XAML.
302.12 309.12 "Игорь Лабутин" Я сейчас не очень много работаю с UI, поэтому не буду детально комментировать, что там сильно улучшили или изменили.
309.12 311.44 "Игорь Лабутин" Это была студия 16.9.
311.44 317.32 "Игорь Лабутин" Мы к ней еще немножко вернемся попозже, но есть еще 16.10 Preview 1.
317.32 319.16 "Игорь Лабутин" Там не так много изменений пока.
319.16 325.52 "Игорь Лабутин" В основном они касаются мелких тех самых улучшений, которые надо подсматривать у ReSharper, возможно.
325.52 330.16 "Игорь Лабутин" Анатолий сказал, что у нас есть вот такая теперь фича, как автодобавление юзингов при вставке.
330.16 333.76 "Игорь Лабутин" Теперь появилась новая штука Remove Unused References.
333.76 341.44 "Игорь Лабутин" И, по-моему, кстати, Remove Unused Usings тоже где-то тут недавно завезли, хотя я могу ошибаться.
341.44 347.24 "Игорь Лабутин" Дальше есть фича, которая немножко похожа на рефактор Ingress Sharper.
347.24 348.24 "Игорь Лабутин" Это Simplifying UXpressions.
348.24 359.96 "Игорь Лабутин" То есть, если вы, например, пишете что-нибудь там коллекция.where.any без предиката any, то в принципе это можно просто заменить на коллекция.any с тем же предикатом, который был where.
359.96 360.96 "Игорь Лабутин" Студия теперь такое умеет.
360.96 363.88 "Игорь Лабутин" Это один из примеров, которые они приводят в статье.
363.88 367.64 "Игорь Лабутин" Полный список надо, конечно, смотреть более детально, что там поддержано.
367.64 370.52 "Игорь Лабутин" И еще больше улучшили completion.
370.52 382.64 "Игорь Лабутин" Теперь если вы начинаете набирать какой-нибудь терм, то в том числе студия пытается подобрать значение enum из известных enum в этом контексте.
382.64 390.48 "Игорь Лабутин" То есть, если вы, например, открываете там файл, ему нужно передать там file_mod.read.
390.48 396.12 "Игорь Лабутин" Допустим, в качестве режима, то можно просто начинать набирать read, и он сам предложит file_open.read.
396.12 402.16 "Игорь Лабутин" То есть, enumчики можно не писать для этого enumного префикса, чтобы он появился, а completion для него.
402.16 411.48 "Анатолий Кулаков" Я теперь начал понимать шутки, когда эти Apple шутили, что Samsung сидит и целыми днями обводит телефоны Apple для того, чтобы выпустить свою следующую версию.
411.48 415.32 "Анатолий Кулаков" Вот это такое ощущение, что Microsoft сидит и целыми днями ReSharper обводит.
415.32 418.04 "Игорь Лабутин" Ну, хорошее решение.
418.04 420.36 "Игорь Лабутин" Нужно каким-то образом внедрять тоже.
420.36 424.24 "Игорь Лабутин" Не получится сделать абсолютно альтернативный experience, который тоже будет удобный.
424.24 425.88 "Игорь Лабутин" Какие-то пересечения точно будут.
425.88 428.20 "Анатолий Кулаков" Ну, а у нас еще один большой релиз.
428.20 429.68 "Анатолий Кулаков" Зарелизился Core.dapcf.
429.68 438.40 "Анатолий Кулаков" Это open-source решение Windows Workflow Foundation, который, я напомню, Microsoft прикрыла в связи с переходом на .NET Core.
438.40 446.80 "Анатолий Кулаков" Но команда энтузиастов подхватила то, что есть, и начала развивать, дабы оставить какое-то наследие для существующих проектов.
446.80 451.60 "Игорь Лабутин" Да, только я тебя поправлю, там не Windows Workflow Foundation, а Windows Communication Foundation все-таки.
451.60 455.40 "Игорь Лабутин" Но, тем не менее, действительно, это не совсем команда прямо энтузиастов.
455.40 459.16 "Игорь Лабутин" То есть, это ребята внутри Microsoft поговорили внутри себя.
459.16 460.76 "Игорь Лабутин" Произошло это почти два года назад.
460.76 464.72 "Игорь Лабутин" И решили, что WCF все-таки, возможно, будет полезен.
464.72 471.52 "Игорь Лабутин" Но писать его заново вообще с нуля не очень интересно.
471.52 476.84 "Игорь Лабутин" Поддерживать весь старый код и как-то его делать кроссплатформенным тоже не очень интересно.
476.84 482.56 "Игорь Лабутин" Поэтому у них был принят целый ряд таких компромиссных решений, как с этим всем жить дальше.
482.56 487.28 "Игорь Лабутин" Сейчас действительно выпустилась версия 0.1 General Availability.
487.28 491.60 "Игорь Лабутин" То есть, это прям не еще совсем production, production, release, release.
491.60 493.24 "Игорь Лабутин" Но, тем не менее, пробовать его уже можно.
493.24 498.00 "Игорь Лабутин" И поскольку это open source, там достаточно много еще проблем и недоделок.
498.00 499.68 "Игорь Лабутин" Но оно в целом работает.
499.68 502.32 "Анатолий Кулаков" То есть, они два года пилили версию 0.1.
502.32 504.84 "Анатолий Кулаков" Я правильно понимаю, сейчас об этом заявляют как о большом
504.84 508.44 "Игорь Лабутин" релизе? И на самом деле пилили они довольно много.
508.44 509.44 "Игорь Лабутин" Значит, смотрите.
509.44 515.00 "Игорь Лабутин" В WCF, эти, кто с ним работал, знают, что есть такой класс Service Host.
515.00 518.16 "Игорь Лабутин" Это центральная точка, вокруг которой все крутится.
518.16 529.12 "Игорь Лабутин" Это ваш, собственно, сервис, хост, по сути, ну как мы его знаем, там в S/P/Nad Core тоже такой есть, который внутри себя, собственно, содержит слушающий кусочек, сокеты, пайпы, все вот это вот.
529.12 530.44 "Игорь Лабутин" И обеспечивает работу с ними.
530.44 533.72 "Игорь Лабутин" Вся работа с WCF, по сути, происходит через него.
533.72 535.84 "Игорь Лабутин" Или все его решения вокруг.
535.84 540.20 "Игорь Лабутин" Команда сказала, что в принципе у нас уже есть один Service Host, собственно, S/P/Nad Core.
540.20 541.20 "Игорь Лабутин" Нам второй не нужен.
541.20 548.76 "Игорь Лабутин" Это как бы два места, где нужно поддерживать работу, собственно, с сокетами, с пайпами.
548.76 553.72 "Игорь Лабутин" Опять же, там в WCF работает S/TTP, то есть, и S/TTP тоже надо поддерживать.
553.72 554.72 "Игорь Лабутин" Что-то как-то сложно.
554.72 558.52 "Игорь Лабутин" Поэтому Core WCF, он на самом деле хитрый.
558.52 561.04 "Игорь Лабутин" Он работает поверх S/P/Nad Core.
561.04 564.88 "Игорь Лабутин" То есть, из S/P/Nad Core берется сам, собственно, хост.
564.88 568.48 "Игорь Лабутин" И экстенджерами к нему допиливается WCF.
568.48 572.24 "Игорь Лабутин" WCF интегрируется в этот самый Service Host, на достаточно низком уровне.
572.24 582.60 "Игорь Лабутин" Так что он умудряется при этом работать даже, как у них написано в статье, с нет TCP протоколом, который, вообще говоря, требует прямого доступа к сокетам.
582.60 584.04 "Игорь Лабутин" Но все это поверх S/P/Nad Core.
584.04 588.80 "Игорь Лабутин" А там, где нужен наш S/TTP, там как бы S/P/Nad Core уже предоставляет все, что есть у него.
588.80 597.52 "Игорь Лабутин" Со всеми мудростями и оптимизациями Kestrel'а и WCF остается просто взять там пайпы или стримы и в них начинать читать и писать.
597.52 601.56 "Игорь Лабутин" Ну и делать свою обработку, соответственно, сооп вот этих вот штук.
601.56 606.12 "Игорь Лабутин" Если это сооп, то на уровне уже WCF-ных логики.
606.12 611.40 "Игорь Лабутин" В чем, как я сказал, такое переписывание было довольно сложным.
611.40 618.20 "Игорь Лабутин" Кроме того, чтобы написать это дело поверх S/P/Nad Core, нужно было сделать так, чтобы это все-таки было в стиле .NET Core, то бишь кроссплатформенно.
618.20 621.20 "Игорь Лабутин" Поэтому пришлось выпилить три вещи.
621.20 622.20 "Игорь Лабутин" Первое.
622.20 623.52 "Игорь Лабутин" Нельзя было вызывать нативный код.
623.52 627.96 "Игорь Лабутин" Ну, по понятным причинам, лучше всего все сделать в натуральном C#.
627.96 628.96 "Игорь Лабутин" Второе.
628.96 629.96 "Игорь Лабутин" Нельзя...
629.96 631.76 "Игорь Лабутин" Они это почему-то делят на две категории.
631.76 632.76 "Игорь Лабутин" Direct System Calls.
632.76 634.24 "Игорь Лабутин" Нельзя дергать в WinAPI.
634.24 637.36 "Игорь Лабутин" Ну, как бы платформенный код, так скажем.
637.36 638.36 "Игорь Лабутин" Давайте так назовем.
638.36 641.76 "Игорь Лабутин" А самое главное, как они сказали, довольно сложная штука была.
641.76 647.76 "Игорь Лабутин" Они полностью выпилили старую асинхронную модель работы внутри WCF.
647.76 660.76 "Игорь Лабутин" Поскольку фреймворк живет довольно давно, основным способом работы внутри WCF со синхронностью был паттерн, который называется APM, Asynchronous Programming Model, который все могут помнить по сочетанию begin/end.
660.76 670.76 "Игорь Лабутин" То есть вы вызываете какой-нибудь begin/receive, передаете какой-нибудь callback, он потом вызовет вам callback, в нем нужно будет вызвать end/receive, что-нибудь сделать с ним.
670.76 674.76 "Игорь Лабутин" Ну, в общем, это все такое очень сложное, замороченное.
674.76 678.76 "Игорь Лабутин" Но позволяло очень сильно и много чего очень круто и оптимизированно делать.
678.76 685.76 "Игорь Лабутин" WCF вообще очень прикольная штука с точки зрения ее производительности в том числе, но это вообще нифига не френдли, особенно в современном мире тасков.
685.76 690.76 "Игорь Лабутин" Поэтому они все это дело выкинули и переписали на нормальные Async/await, таски и вот это все.
690.76 693.76 "Игорь Лабутин" Это была большая работа, поэтому, собственно, это все много времени заняло.
693.76 703.76 "Игорь Лабутин" И действительно, оно делается как такой небольшой проект, небольшим количеством энтузиастов, там, либо сотрудников самого Microsoft, это уж я не знаю, но действительно двигается не очень быстро.
703.76 707.76 "Игорь Лабутин" И, в результате, довольно большим контрибьютором в это дело стал Амазон.
707.76 708.76 "Игорь Лабутин" Внезапно.
708.76 725.76 "Игорь Лабутин" Да, вот именно Амазон, AWS-команда, довольно много поконтрибьютила, вероятно, из-за того, что, может быть, они понимают, что там в их Linux-облаках хостится довольно много бизнесов, которые могут захотеть WCF все еще, чтобы остаться хоститься в Linux, но при этом использовать последний тутнет.
725.76 727.76 "Игорь Лабутин" Ну, и решили таким образом поддержать.
727.76 730.76 "Игорь Лабутин" Мотивация не очень понятна, но, тем не менее, спасибо им.
730.76 734.76 "Игорь Лабутин" В результате, да, пакет The Religion, его можно использовать.
734.76 746.76 "Игорь Лабутин" И вместе с ним, ну, он не совсем вместе с ним, это немножко параллельная работа, но, тем не менее, мы упомянули Амазон, Амазон законтрибьютил еще в одну штуку, которая называется WS Federation.
746.76 753.76 "Игорь Лабутин" Это один из байдингов в WCF, точнее, даже не байдингов, а вариантов схем авторизации.
753.76 768.76 "Игорь Лабутин" Используется в тех случаях, когда вы живете в каком-нибудь корпоративной сети или еще где-то, где у вас есть какой-нибудь Active Directory или Azure какой-нибудь, Active Directory или фейки Kerberos, и вот это все.
768.76 778.76 "Игорь Лабутин" Чтобы сделать авторизацию в WCF Endpoints на них, нужны были специальные авторизационные схемы, которых не было в Core WCF, вот они теперь есть.
778.76 789.76 "Игорь Лабутин" Причем они есть не в самом Core WCF, они есть в отдельном пакете, который поддерживает NetStandard 2.0, и его можно просто использовать отдельно.
789.76 793.76 "Игорь Лабутин" То есть это System Service Model Federation, так называется.
793.76 794.76 "Игорь Лабутин" Ну, где-то пакет.
794.76 802.76 "Игорь Лабутин" Если вам оно не надо, вы его просто не трогаете и не замаракиваетесь всеми этими очень сложными элементами авторизации.
802.76 814.76 "Игорь Лабутин" Это, кстати, та самая область, где находятся там всякие одни из самых длинных идентификаторов WCF, какие-то там WS Federation 2007, Version 3.5.2 с поправкой такой-то.
814.76 819.76 "Игорь Лабутин" Это все пишется в имени класса, и короче, там имена класса 50-60 символов, это нормально.
819.76 824.76 "Игорь Лабутин" Вот они примерно там живут, теперь они живут в отдельном пакете и можете пользоваться ими отдельно, если вам оно интересно.
824.76 827.76 "Игорь Лабутин" Так что живет WCF, не сильно помирает, это прикольно.
827.76 832.76 "Игорь Лабутин" Я как-то этому очень рад, хотя на практике сейчас его используют все меньше и меньше.
832.76 834.76 "Игорь Лабутин" Ну старые проекты у тебя остались?
834.76 842.76 "Игорь Лабутин" Да, старые проекты остались, но там их нет, планов никаких переводить на новые интернеты.
842.76 855.76 "Игорь Лабутин" Они работают на полном дотнет-фреймворке, там с WCF проблем нету, а те, которые переходят на новые, на netcore, там или, может быть, в будущем мы таки перейдем на net5, там уже везде REST, ну и вот это все.
855.76 857.76 "Игорь Лабутин" Там WCF-а нет.
857.76 858.76 "Игорь Лабутин" Хипстота.
858.76 869.76 "Анатолий Кулаков" Как раз для того, чтобы помочь вам все-таки, может быть, перейти, Microsoft выпустила еще один интереснейший продукт, который помогает вам переходить с большого дотнет-фреймворка на новомодный dotnet5.
869.76 871.76 "Анатолий Кулаков" Мне кажется, я это уже где-то слышал.
871.76 875.76 "Анатолий Кулаков" У него уже был такой продукт, и может даже не один, разве нет?
875.76 886.76 "Игорь Лабутин" Да, тула была, тула называлась StrikeConvert, она жила на гитхабе, по-моему, в организации то ли Microsoft, то ли dotnet, в общем, в dotnet, по-моему, dotnet/strikeconvert на гитхабе.
886.76 889.76 "Игорь Лабутин" Но это был, как я помню, command-line tool.
889.76 895.76 "Игорь Лабутин" Сейчас они сделали его более таким интерактивно, в общем, юзер-френдли, так скажем.
895.76 899.76 "Анатолий Кулаков" И переименовали в более солидное имя dotnet-upgradeassistant.
899.76 900.76 "Анатолий Кулаков" Да.
900.76 902.76 "Анатолий Кулаков" Не какой-то тебе там strikeconvert.
902.76 907.76 "Игорь Лабутин" Ну, strikeconvert, да, звучало не очень оптимистично, может получится, может не получится.
907.76 910.76 "Игорь Лабутин" Тут вроде как assistant, он как бы попробует помочь.
910.76 913.76 "Игорь Лабутин" Тоже может не получится, но он по крайней мере попробовал.
913.76 919.76 "Игорь Лабутин" Поддерживает эта штука Spanet MVC проекты, Windows Forms, WPF, ну и, конечно же, консольные приложения и библиотечки.
919.76 921.76 "Игорь Лабутин" Что он вообще делает-то?
921.76 923.76 "Игорь Лабутин" Работает он следующим образом.
923.76 927.76 "Игорь Лабутин" Первым делом он бэкапит ваши проектики, чтобы, если что, все можно было откатить.
927.76 928.76 "Игорь Лабутин" Это очень важный шаг.
928.76 936.76 "Игорь Лабутин" Следующее, он обновляет все ваши проекты до SDK-стайл, вот этого нового стиля CSS Project, чтобы все было по-модному и современному.
936.76 941.76 "Игорь Лабутин" Дальше он обновляет target-фреймворк у вас, чтобы они были 5.0.
941.76 946.76 "Игорь Лабутин" После чего он начинает проверять все зависимости и проверяет все зависимые NuGet-пакеты.
946.76 948.76 "Игорь Лабутин" Там есть несколько вещей, которые делаются.
948.76 960.76 "Игорь Лабутин" Во-первых, в новом стиле проектов можно не указывать транзитивные зависимости, поэтому можно на некоторые ссылки забить и их не указывать, указывать только зависимости от тех NuGet-ов, которые вы непосредственно используете.
960.76 976.76 "Игорь Лабутин" Второе, если он понимает, что NuGet-пакет, от которого вы зависите, та версия, от которой вы зависите, не поддерживает .NET 5, то он попытается проапгрейдиться на более новую версию, найдет следующую, в том числе мажорную версию, которая поддерживает .NET 5, и на нее проапгрейдится.
976.76 978.76 "Игорь Лабутин" Ну, про гравитационный референс.
978.76 982.76 "Игорь Лабутин" Возможно, у вас что-то перестанет компилиться, потому что это апгрейд на следующей мажорной версии.
982.76 986.76 "Игорь Лабутин" Может, еще что-то, но, тем не менее, он попытается это сделать более-менее автоматом.
986.76 990.76 "Анатолий Кулаков" Что-то мне утилита с приставкой Try нравилась больше.
990.76 992.76 "Анатолий Кулаков" Она хотя бы не пыталась изменить мои проекты.
992.76 995.76 "Игорь Лабутин" О, хуже. Дальше он пойдет изменять C# код.
995.76 999.76 "Анатолий Кулаков" Ну, началось. А зачем менять C# код при миграции на .NET 5?
999.76 1000.76 "Анатолий Кулаков" Это вообще как связано-то?
1000.76 1007.76 "Игорь Лабутин" Ну, во-первых, если вы мигрируете с чего-то очень старого, например, с Esplanade MVC, он его попытается автоматически переделать, видимо, в Esplanade Core.
1007.76 1013.76 "Игорь Лабутин" Там есть другие несколько соглашений по всяким стартап-CS-ам и вот таким вот файликам, он их там подобавляет.
1013.76 1022.76 "Игорь Лабутин" Вроде как обещается, что в основном они все-таки добавляют файлики, но есть несколько вещей, которые они будут править именно в C# файлах.
1022.76 1027.76 "Игорь Лабутин" И они приводят какое-то очень небольшое количество того, чего они делают.
1027.76 1034.76 "Игорь Лабутин" Ну, например, у них там ESP.NET Core Projects не должны референсить namespace ESP.NET.
1034.76 1042.76 "Игорь Лабутин" Или там, если вы используете тип HTMLString, то нужно его заменить на Microsoft.ESP.NET.Core.HTML.HTMLString.
1042.76 1057.76 "Игорь Лабутин" Ну, то есть какие-то такие мелочи, видимо, связанные с тем, что и в старом ESP.NET, и в новом ESP.NET Core могут быть типы с теми и теми же именами, и нужно правильно обновить эти фейки юзинги, чтобы они были из нужного namespace.
1057.76 1065.76 "Анатолий Кулаков" Ну, вообще, если он сам научится переезжать, например, с ESP.NET на ESP.NET Core, или с EF на EF Core, то это будет довольно-таки мощная штука.
1065.76 1068.76 "Анатолий Кулаков" Ну, что-то я сомневаюсь, что он сможет сделать это хорошо.
1068.76 1071.76 "Игорь Лабутин" Ну, он сможет это сделать, по крайней мере, что-то.
1071.76 1087.76 "Игорь Лабутин" Дальше зависит, конечно, от того, насколько .NET Framework специфичным был ваш проект, насколько вы сильно использовали какую-нибудь кастомизацию ESP.NET MVC, или насколько у вас были какие-нибудь сильно кастомные контроллы, не знаю, в WPF, которые почему-то не перенесутся на .NET 5.
1087.76 1108.76 "Игорь Лабутин" Понятно, что после таких апгрейдов нужны будут наверняка 100% какие-то еще ручные изменения в коде, но они утверждают, что самое сложное, вообще самое долгое по их опыту в процессе переезда, это как раз-таки работа со всякими CES Projами и Nugetами, и что вот эту часть они неплохо автоматизируют.
1108.76 1115.76 "Игорь Лабутин" Да, после апгрейда Nuget вам может потребоваться фиксить код, но вам даже вручную пришлось бы апгрейдить Nuget и фиксить код.
1115.76 1117.76 "Игорь Лабутин" Они, по крайней мере, половину работы сделали за вас.
1117.76 1121.76 "Игорь Лабутин" Лучше бы, конечно, код тоже фиксили, хотя лучше или хуже, не знаю.
1121.76 1123.76 "Анатолий Кулаков" Да, здесь немножко не хватает практики.
1123.76 1129.76 "Анатолий Кулаков" Интересно собрать статистику и отзывы после того, как люди попробуют этот инструмент.
1129.76 1135.76 None Ну, оно пока только в превью, я не думаю, что там будет какое-то огромное количество отзывов, но почему нет?
1135.76 1142.76 "Игорь Лабутин" Я посмотрел на issues в GitHub, там, в общем, довольно много всяких идей про то, что можно сделать.
1142.76 1149.76 "Игорь Лабутин" Там уже предлагают Visual Studio Extension написать, кто-то при этом жалуется, что этот тул невозможно поставить.
1149.76 1158.76 "Игорь Лабутин" Короче, всякие разные штуки предлагают, используют, и давайте вот это поддержим, вот то поддержим.
1158.76 1162.76 "Игорь Лабутин" Ну, как бы работа какая-то идет, то есть народ начинает пробовать.
1162.76 1167.76 "Игорь Лабутин" Я смотрю, что довольно много багов именно помечено тегом community reported, либо багов, либо предложений.
1167.76 1171.76 "Игорь Лабутин" Так что можете, если интересно, посмотреть, там вполне какая-то движуха есть.
1171.76 1173.76 "Игорь Лабутин" Живет это все в репозитории.
1173.76 1174.76 "Игорь Лабутин" Тут надо /upgradeassistant.
1174.76 1183.76 "Анатолий Кулаков" Если вы настолько счастливчик, что миграция вас не интересует, а вы делаете проекты с нуля, то наверняка уже задумывались о том, на что бы написать свой UI.
1183.76 1187.76 "Анатолий Кулаков" И один из самых привлекательных вариантов - это использовать новый MAUI.
1187.76 1191.76 "Анатолий Кулаков" Новый .NET Multi-Platform App UI.
1191.76 1196.76 "Анатолий Кулаков" И планы по MAUI тоже у нас сегодня есть в нашем списке новостей.
1196.76 1199.76 "Игорь Лабутин" На русском он все-таки как-то очень странно называется.
1199.76 1201.76 "Игорь Лабутин" Но вообще звучит прикольно.
1201.76 1203.76 "Игорь Лабутин" Действительно, планы.
1203.76 1205.76 "Игорь Лабутин" И не то, чтобы он сильно новый.
1205.76 1209.76 "Игорь Лабутин" Новое на самом деле название, потому что там ребрендинг, вот это все.
1209.76 1211.76 "Игорь Лабутин" А внутри это по сути Xamarin.
1211.76 1213.76 "Игорь Лабутин" Xamarin.Forms.
1213.76 1219.76 "Игорь Лабутин" Microsoft после того, как они получили к себе Xamarin, они его теперь планомерно встраивают в экосистему .NET.
1219.76 1221.76 "Игорь Лабутин" Раньше это был совершенно отдельный продукт.
1221.76 1226.76 "Игорь Лабутин" Сейчас Xamarin.SDK входит в официальный .NET SDK.
1226.76 1231.76 "Игорь Лабутин" И MAUI - это просто будет дальнейшее развитие Xamarin.Forms.
1231.76 1237.76 "Игорь Лабутин" У них была довольно большая дискуссия на тему, хотим ли мы вообще все переименовать полностью.
1237.76 1241.76 "Игорь Лабутин" Оставив по сути смысл Xamarin.Forms назвать все это по-новому.
1241.76 1244.76 "Игорь Лабутин" Но потом решили, что не стоит оно того.
1244.76 1251.76 "Игорь Лабутин" То есть это потребует хотя бы текста, но все-таки изменения кучи клиентского кода, кучи компонент.
1251.76 1253.76 "Игорь Лабутин" И в общем не стали этого делать.
1253.76 1256.76 "Игорь Лабутин" Оставили Xamarin.Forms с точки зрения namespace и всего остального.
1256.76 1258.76 "Игорь Лабутин" Но бренд-нейм - MAUI.
1258.76 1266.76 "Анатолий Кулаков" Еще и неплохо, что они не решились все это переписывать с нуля, как любит Microsoft, выбрасывать существующие технологии и писать альтернативы.
1266.76 1268.76 "Анатолий Кулаков" То есть это тоже очень хорошо.
1268.76 1282.76 "Игорь Лабутин" Да. Кроме того, что они сейчас активно пропагандируют и говорят, что в планах у них сейчас, особенно для релиза 5.0, не было особо никаких новых фич, ничего.
1282.76 1284.76 "Игорь Лабутин" То есть они в основном работают над bugfix'ами.
1284.76 1294.76 "Игорь Лабутин" И в принципе в новом релизе, который будет довременно с DotNet 6, тоже ничего сильно нового не планируется с точки зрения новых контролов, каких-то новых суперфич и так далее.
1294.76 1299.76 "Игорь Лабутин" Они просто планомерно причёсывают Gamma Rainforms, чтобы оно стало быстрым, удобным и так далее.
1299.76 1302.76 "Игорь Лабутин" И есть несколько вещей, которые они собираются сделать.
1302.76 1304.76 "Игорь Лабутин" Мы сейчас по ним пробежимся.
1304.76 1306.76 "Игорь Лабутин" Во-первых, перформанс.
1306.76 1318.76 "Игорь Лабутин" Тут все интересно, в том плане, что, во-первых, сам DotNet 6, с учетом ускорения, как бы, JIT'а, рантайма и всего остального, дает большой бенефит.
1318.76 1321.76 "Игорь Лабутин" Второе, они работают на The Head of Time Compilation.
1321.76 1324.76 "Игорь Лабутин" Они используют такую штуку, как Startup Tracing.
1324.76 1330.76 "Игорь Лабутин" То есть я так понимаю, что штука, которая позволяет понять, где тратится время на стартапе и улучшить это время.
1330.76 1335.76 "Игорь Лабутин" Потому что для Gamma Rain это может быть критично, поскольку там какие-нибудь мобильные приложения запускаются довольно часто.
1335.76 1342.76 "Игорь Лабутин" И в отличие от серверного варианта использования, где Startup Time не очень важен, там он критично важен.
1342.76 1346.76 "Игорь Лабутин" И они улучшают работу рендереров, чтобы всё это работало быстро, визуально.
1346.76 1350.76 "Игорь Лабутин" Для того, чтобы визуально это всё работало быстро, они немножко таки изменили архитектуру.
1350.76 1359.76 "Игорь Лабутин" Точнее, они не то чтобы изменили её, они сказали, что основной теперь будет новая архитектура хендлеров, как они это называют.
1359.76 1364.76 "Игорь Лабутин" Но старая и весь код продолжит работать, то есть всякая backward compatibility пока ещё не сломана.
1364.76 1369.76 "Игорь Лабутин" Они немножко переделывают вместе с этой хендлером архитектуру и то, как они работают с контроллами.
1369.76 1374.76 "Игорь Лабутин" Раньше, я так понимаю, у них была необходимость для каждого нативного контролла.
1374.76 1380.76 "Игорь Лабутин" Они как бы его оборачивали в свой собственный враппер и работали в коде мы с врапперами.
1380.76 1391.76 "Игорь Лабутин" Теперь, как я понимаю, зависимость они инвертировали, то есть мы всё ещё работаем с некоторыми абстракциями, но теперь есть просто несколько реализаций этих абстракций для разных платформ.
1391.76 1405.76 "Игорь Лабутин" Ну и таким образом, при инвертировании зависимости они говорят, что это будет гораздо лучше и проще писать платформенные контроллы, потому что меньше специфики знания нужно, по-какому-то.
1405.76 1409.76 "Игорь Лабутин" Есть улучшения в дизайне приложений, в дизайне, в смысле в визуальном дизайне.
1409.76 1419.76 "Игорь Лабутин" То есть Xamarin, поскольку всё-таки не абсолютно нативные контроллы использует, он может, но если вы хотите полностью круг платформы, то вы будете использовать ненативные.
1419.76 1423.76 "Игорь Лабутин" Но всё-таки хочется, чтобы оно выглядело похоже на нативные приложения.
1423.76 1434.76 "Игорь Лабутин" Они теперь поддерживают темы приложения и они экспериментируют как раз-таки с использованием нативных контроллов или комбинаций даже нативных и самостоятельно адресованных контроллов.
1434.76 1437.76 "Игорь Лабутин" Это пока эксперименты, непонятно, чем закончится.
1437.76 1445.76 "Игорь Лабутин" С точки зрения платформ, в DotNet 6 будут точно поддержаны Android, iOS, MacOS и Windows.
1445.76 1450.76 "Игорь Лабутин" Дальше, понятно, это дело будет ещё развиваться на остальные платформы тоже.
1450.76 1455.76 "Игорь Лабутин" Они довольно тесно работают с Blazor командой, чтобы получить Blazor Desktop в результате.
1455.76 1460.76 "Игорь Лабутин" Мы обсуждали Blazor Desktop, по-моему, в прошлом, если не ошибаюсь, выпуске.
1460.76 1463.76 "Игорь Лабутин" И как раз-таки вот здесь ведётся тесная работа.
1463.76 1471.76 "Игорь Лабутин" В DotNet будет поддержан Mac Catalyst.
1471.76 1479.76 "Игорь Лабутин" Это, я так понимаю, новое решение от Apple, которое позволяет вам притаскивать iOS-ное приложение на Desktop.
1479.76 1483.76 "Игорь Лабутин" То есть вы можете взять iOS-ное приложение и запустить его на своём любимом Mac.
1483.76 1485.76 "Игорь Лабутин" Вот можно будет сделать такое с Xamarin.
1485.76 1488.76 "Игорь Лабутин" Ну и они начинают поддерживать получше WinUI 3.
1488.76 1492.76 "Игорь Лабутин" Мы тоже его как-то упоминали несколько выпусков назад.
1492.76 1495.76 "Игорь Лабутин" Это вся работа для Windows Desktop идёт.
1495.76 1498.76 "Игорь Лабутин" Так, сейчас я посмотрю, что ещё.
1498.76 1508.76 "Игорь Лабутин" Во, ещё у нас у них теперь не нужно делать кучи проектов, точнее, можно не делать кучи платформенных проектов.
1508.76 1516.76 "Игорь Лабутин" Насколько я понимаю, раньше в Xamarin вы писали один общий проект, и дальше вы писали дополнительно несколько проектов отдельных для каждой платформы, которая поддержана.
1516.76 1523.76 "Игорь Лабутин" Теперь это всё можно держать в одном едином проекте, и студия сама разберётся, как это всё правильно собрать и изгенерить несколько аутпутов.
1523.76 1530.76 "Игорь Лабутин" Фича, которую они хотят завести много куда, и Xamarin здесь пионер, это .NET Hot Reload.
1530.76 1537.76 "Игорь Лабутин" Сейчас это уже работает с Xamarin для XAML, то есть вы можете редактировать XAML, и ваше приложение без перезапуска подхватывает изменения.
1537.76 1539.76 "Игорь Лабутин" Они хотят это сделать для C#.
1539.76 1542.76 "Игорь Лабутин" То есть вы подправите код, а оно прям в реал-тайме меняет поведение.
1542.76 1549.76 "Игорь Лабутин" Не знаю, как это будет работать, это требует в том числе изменения рантайма, но перспективы у этого неплохие, как мне кажется.
1549.76 1551.76 "Игорь Лабутин" И будет интересно не только в контексте Xamarin.
1551.76 1556.76 "Анатолий Кулаков" Я всё-таки надеюсь, что этим будет заниматься не команда MyUI, а всё-таки команда рантайма.
1556.76 1568.76 "Игорь Лабутин" Я думаю, что там связанная штука есть, то есть команда рантайма позволит это делать, а команда UI должна понять, как это заинтегрировать с тулами визуальными, в том числе с командой Visual Studio и всех остальных.
1568.76 1571.76 "Игорь Лабутин" То есть там, я думаю, что не одна команда трудится над этим.
1571.76 1572.76 "Игорь Лабутин" Это точно.
1572.76 1581.76 "Игорь Лабутин" Microsoft утверждает, что стратегически, если вы там ждёте, например, выхода MyUI, чтобы начать всё это пробовать, не делайте так.
1581.76 1585.76 "Игорь Лабутин" Можно взять уже Xamarin.Forms и начать использовать прямо сейчас.
1585.76 1599.76 "Игорь Лабутин" Когда вы захотите перейти уже на полноценный MyUI вот с вот этой новой хендлерной архитектурой и так далее, вы просто меняете SDK-версию и потом потихонечку начинаете переходить на вот эту новую архитектуру, потому что всё старое будет работать тоже.
1599.76 1609.76 "Игорь Лабутин" То есть новое будет чуть более быстрее, или может быть не чуть, а новое должно быть более правильное и прозрачное и просто, но старый весь код тоже будет работать.
1609.76 1611.76 "Игорь Лабутин" Так что ситуация какая-то такая.
1611.76 1613.76 "Анатолий Кулаков" Ну, неплохо, неплохо.
1613.76 1623.76 "Анатолий Кулаков" В принципе, основной вывод в том, что можно использовать Xamarin.Forms уже сейчас и ваше приложение в будущем будет продолжать саппортить последние микрософтовские технологии в сфере UI.
1623.76 1624.76 "Анатолий Кулаков" И это тоже хорошо.
1624.76 1625.76 "Анатолий Кулаков" Компатибилити наша вся.
1625.76 1629.76 "Анатолий Кулаков" Так, вышел в свет недавно Flexible HTTP API.
1629.76 1635.76 "Анатолий Кулаков" Это некий пропозал, который нам рассказывает ещё про одного конкурента для нашего любимого HTTP Client.
1635.76 1637.76 "Анатолий Кулаков" Игорь, зачем нам менять наш HTTP Client?
1637.76 1639.76 "Игорь Лабутин" Он же всем хорош.
1639.76 1642.76 "Игорь Лабутин" Это не конкурент, это даже не альтернатива.
1642.76 1645.76 "Игорь Лабутин" Это всё для тех, кому HTTP Client мало.
1645.76 1647.76 "Игорь Лабутин" Это действительно пока ещё очень ранний пропозал.
1647.76 1652.76 "Игорь Лабутин" Это вообще может никуда не пройти, а может всё сработать и будет реализовано.
1652.76 1654.76 "Игорь Лабутин" Будем следить.
1654.76 1665.76 "Игорь Лабутин" Но идея заключается в следующем, что если вы хотите работать с HTTP на достаточно низком уровне, то есть, например, вы хотите открыть коннекшн к серверу, не посылая реквесты.
1665.76 1667.76 "Игорь Лабутин" HTTP Client вам сейчас такого не позволяет.
1667.76 1671.76 "Игорь Лабутин" Или сделать реквесты без коннекшн пула.
1671.76 1677.76 "Игорь Лабутин" Или вы вообще хотите сделать свой собственный коннекшн пул, включая HTTP 2, например, протокол, или в будущем может быть даже HTTP 3.
1677.76 1678.76 "Игорь Лабутин" Сейчас вы...
1678.76 1681.76 "Игорь Лабутин" И зачем вообще это на практике может понадобиться?
1681.76 1690.76 "Игорь Лабутин" Если, например, у вас какой-то, не знаю, хитрый пул бэкэнд серверов, с которыми вы знаете, что надо общаться как-то по-особенному с точки зрения пула коннекшенов.
1690.76 1699.76 "Игорь Лабутин" Или вы хотите иногда делать запросы к одному конкретному серверу без использования коннекшн пула.
1699.76 1706.76 "Игорь Лабутин" Я не знаю таких прям серьезных юзкейсов в такой прикладной области, но, наверное, если вы пишите...
1706.76 1712.76 "Игорь Лабутин" Наверное, кстати, такую штуку будет нужно делать, если вы, например, пишете какой-нибудь прокси.
1712.76 1721.76 "Игорь Лабутин" То есть, не клиентское приложение, которое просто посылает запросы, а штука, которая работает над запросами, но достаточно абстрактной и при этом на довольно низком уровне.
1721.76 1737.76 "Анатолий Кулаков" Или, может быть, когда реализуете свой какой-нибудь высоконагруженный стриминг, там, видео, аудио, или, может быть, изобретаете свой протокол поверх HTTP/2 и хотите тонко управлять какими-то коннекциями, оптимизациями в вашей пропускной способности.
1737.76 1739.76 "Анатолий Кулаков" Наверное, что-то туда, да?
1739.76 1745.76 "Игорь Лабутин" Ну да, или хотите, например, улучшить что-нибудь про какой-нибудь TLS, который делает несколько...
1745.76 1749.76 "Игорь Лабутин" Когда в процессе TLS-хендшейка есть обмен какими-то данными.
1749.76 1759.76 "Игорь Лабутин" В общем, в Proposal.ly там есть довольно много сценариев, которые они видят как потенциальное применение этой штуки.
1759.76 1763.76 "Игорь Лабутин" Есть некоторые пропозлы по API, как это должно выглядеть.
1763.76 1778.76 "Игорь Лабутин" Так что, если вам интересна такого рода работа, ну, в смысле, получить такой клиент, то зайдите, почитайте, покомментируйте, добавляйте идеи, комментируйте существующие идеи, и посмотрим, куда это все выродится.
1778.76 1782.76 "Анатолий Кулаков" Недавно прошла .NET Conf с прицелом на операционную систему Windows.
1782.76 1788.76 "Анатолий Кулаков" И это странно вообще видеть у .NET Conf какие-то платформенные теперь таргеты.
1788.76 1791.76 "Анатолий Кулаков" Ведь мы же кроссплатформенные, кроссоблачные.
1791.76 1792.76 "Анатолий Кулаков" Зачем нам именно Windows?
1792.76 1803.76 "Игорь Лабутин" Ну, надо сказать, что у меня есть ощущение, что почти любой доклад про современный .NET 5 или .NET 6, он всегда оперирует каким-нибудь .NET Core приложением или Blazor.
1803.76 1807.76 "Игорь Лабутин" То есть, такой модельный пример - это всегда .NET Core приложение.
1807.76 1823.76 "Игорь Лабутин" И если вы заметите, когда я рассказывал про всякие фичи, например, включая сегодняшний .NET Upgrade Assistant, мы всегда говорим, что он поддерживает такие приложения, такие приложения, ну и, конечно же, .NET Core и Nougat, ну, либо.
1823.76 1828.76 "Игорь Лабутин" То есть, .NET Core и консоли, они по дефолту работают везде и кроссплатформенно.
1828.76 1830.76 "Игорь Лабутин" Чего не скажешь про UI.
1830.76 1840.76 "Игорь Лабутин" И поэтому понятно, что когда идет .NET Conf, которая такая общая и про все, и про кроссплатформенность, там, конечно, будет все про такие кроссплатформенные вещи.
1840.76 1845.76 "Игорь Лабутин" А здесь именно Microsoft хотела подчеркнуть, что вообще-то Windows они тоже не забывают.
1845.76 1849.76 "Игорь Лабутин" И они же принесли в .NET 5 всякие WinForms и WPF.
1849.76 1851.76 "Игорь Лабутин" И поэтому сделали вот такую конфу.
1851.76 1862.76 "Игорь Лабутин" По-моему, она была один денек, если я правильно помню, где доклады были целиком и полностью посвящены исключительно Windows UI и всему тому, что можно с ним делать на .NET.
1862.76 1866.76 "Анатолий Кулаков" Ну, то есть, правильно было бы назвать все-таки фокус на UI, не на Windows?
1866.76 1872.76 "Анатолий Кулаков" Потому что технологии, представленные в докладе, они вполне могут быть интересны людям, которые разрабатывают и кроссплатформенную UI.
1872.76 1883.76 "Игорь Лабутин" Ну, технически да, хотя, ну, какие-то вещи, мне кажется, они только, конкретно, Desktop и только на Windows.
1883.76 1886.76 "Игорь Лабутин" То есть, я могу захайлайтить несколько тем.
1886.76 1894.76 "Игорь Лабутин" Я красненько посмотрел доклады, мне не очень интересно тема Desktop Development сейчас, но мне было интересно, что там происходит.
1894.76 1896.76 "Игорь Лабутин" Тема, соответственно, такие.
1896.76 1900.76 "Игорь Лабутин" Upgrading .NET Desktop Apps from .NET Framework to .NET 5.
1900.76 1903.76 "Игорь Лабутин" Или "файв" я хотел бы сказать.
1903.76 1908.76 "Игорь Лабутин" То есть, что делать с вашими Desktop приложениями при Upgrading .NET Framework на .NET 5.
1908.76 1924.76 "Игорь Лабутин" Дальше была тема про то, как можно использовать Azure SignalR, потому что, опять же, обычно SignalR мы говорим в контексте веб каких-то клиентов, как использовать его для нотификации веб-клиентов, но, в принципе, SignalR можно использовать на Desktop.
1924.76 1938.76 "Игорь Лабутин" Была отдельная сессия на тему "Practical Tips to Improve Your User Experience", то есть, просто какие-то советы по тому, как улучшать experience ваших пользователей, так сказать, их ощущения от работы с вашим UI.
1938.76 1941.76 "Игорь Лабутин" Несомненно, не обошлось без всяких XAML-овых tool-тулинга.
1941.76 1949.76 "Игорь Лабутин" На самом деле, вы можете видеть по нашим новостям о всяких улучшениях Visual Studio, XAML сейчас довольно активно импровидится.
1949.76 1957.76 "Игорь Лабутин" Почти в каждом обновлении студии выходит что-нибудь про XAML, поэтому какая-то summary того, что происходило, оно было в докладе.
1957.76 1964.76 "Игорь Лабутин" Ну и была отдельная сессия про информацию о WPF и ARM, которые туда перенесли и теперь там тоже работают.
1964.76 1967.76 "Игорь Лабутин" ARM тоже становится актуальным в этом смысле.
1967.76 1971.76 "Игорь Лабутин" ClickOnce вспомнили, которые вернули DotNet 5 к жизни.
1971.76 1980.76 "Игорь Лабутин" И была отдельная сессия, посвященная DotNet 6, под названием "The Future of Native Apps Development", то есть, что нас ждет с точки зрения нативных приложений дальше в будущем.
1980.76 1984.76 "Игорь Лабутин" Скорее всего, там задрагивали WinUI, может, MAUI как раз вспомнили.
1984.76 1988.76 "Игорь Лабутин" В общем, оно, конечно, не совсем наитив, но почему нет.
1988.76 2000.76 "Игорь Лабутин" Так что, если вы интересуетесь Windows разработкой и фокус у вас на Desktop, то советую проглядеть заголовки и посмотреть вообще, может быть, найдете что-то интересное для вас.
2000.76 2020.76 "Анатолий Кулаков" Ну, а если вы совсем не интересуетесь Windows разработкой или Desktop разработкой, то, скорее всего, вы интересуетесь тем, как заоптимизировать ваш GC, потому что у вас, наверняка, серверные приложения, и на серверных приложениях всегда много нагрузки, по крайней мере, в моем окружении, и там всегда не хватает нашего текущего GC.
2020.76 2029.76 "Анатолий Кулаков" И о том, как это лучше всего сделать, знает самый замечательный специалист по GC, ну, конечно, после Майони, это Конрад Кокоса.
2029.76 2036.76 "Анатолий Кулаков" И от Конрада у нас есть тоже интересный курс, который называется "DotNet GC Intervals".
2036.76 2047.76 "Игорь Лабутин" Да, Конрад, как мы знаем, написал книжку по внутренней системе garbage collector, которая уже, конечно же, безнадежно устарела в связи с нововведениями, которые Майони делает в DotNet 5 и DotNet 6.
2047.76 2055.76 "Игорь Лабутин" Ну, не совсем безнадежно, но там есть действительно новые штуки, которые они планируют, которые могут довольно серьезно изменить то, как будет работать garbage collector.
2055.76 2060.76 "Игорь Лабутин" Но, тем не менее, пока он работает, как работает, и Конрад решил сделать следующую штуку.
2060.76 2070.76 "Игорь Лабутин" Он примерно раз в неделю делает такую онлайн-сессию, где рассказывает в течение примерно часа-полутора про какую-то одну конкретную фазу работы garbage collector.
2070.76 2077.76 "Игорь Лабутин" Сейчас у него вышло, по-моему, шесть уже видосиков, он обещает, как минимум, восемь, ну, а может быть и больше, как пойдет.
2077.76 2087.76 "Игорь Лабутин" Каждый видосик - это фаза компактинга, фаза разметки, фаза промоушена и так далее.
2087.76 2100.76 "Игорь Лабутин" Так что, если вам интересно, как работает garbage collector, и вам лень читать книжку Конрада, можно как раз-таки посмотреть видосики, где будет он, во-первых, рассказывать, как он работает, и действительно можно дать какие-то советы.
2100.76 2111.76 "Игорь Лабутин" В книжке есть советы на тему того, как не сильно нагружать ГЦ, или как структурировать ваш код, или какие паттерны применять, чтобы ГЦ работал побыстрее, или не сильно вообще аффектил ваше приложение.
2111.76 2127.76 "Анатолий Кулаков" Ну, или, может быть, вы пытались прочитать книжку, но для вас это было слишком сложно, и то есть вам нужна какая-то была визуальная картинка, и вот, мне кажется, вот эти серии, они отлично могут подойти таким людям, которым хочется все-таки что-то видеть, и хочется перед собой видеть какую-то визуальную картинку.
2127.76 2136.76 "Игорь Лабутин" Да, ну плюс я не исключаю, я не видел всех серий, но я не исключаю, что Конрад их немножко адаптирует все-таки под современный реальный Garbage Collector тоже.
2136.76 2142.76 "Игорь Лабутин" Это сделать чуть проще, чем в книжке, так что слушайте, смотрите, довольно интересное и познавательное занятие.
2142.76 2146.76 "Анатолий Кулаков" Так, еще один большой релиз у нас вышел, это Dapper.
2146.76 2151.76 "Анатолий Кулаков" Dapper объявил о том, что у него теперь версия 1.0.
2151.76 2155.76 "Анатолий Кулаков" Ну, это уже хоть что-то, это уже первая мажорная версия.
2155.76 2159.76 "Анатолий Кулаков" Мы обсуждали же Dapper, что это такое, зачем он нам нужен?
2159.76 2167.76 "Игорь Лабутин" Ну, мы немножечко обсуждали, что Microsoft объявила о такой штуке, что вот, мол, мы начинаем такую штуку делать.
2167.76 2173.76 "Игорь Лабутин" Не очень было понятно тогда, во что это превратится и насколько быстро будет развиваться, но действительно довольно быстро развилась.
2173.76 2177.76 "Анатолий Кулаков" Расскажи тогда, что это такое и зачем он вообще в наших приложениях может понадобиться.
2177.76 2181.76 "Игорь Лабутин" Dapper - это сокращение от Distributed Application Runtime.
2181.76 2202.76 "Игорь Лабутин" И идея Microsoft здесь заключается в следующем, что когда вы пишете ваш код в ваше приложение, в ваше, в основном, так скажем, бизнес-приложение, то есть мы не ведем речи о всяких там прокси, вот таких вот низкоуровневых вещах, а вы пишете нормальный, обычный ваш продукт, то в современном мире, когда, конечно же, все это делают на микросервисах, наверное.
2202.76 2204.76 "Игорь Лабутин" И на кубернетосах?
2204.76 2223.76 "Игорь Лабутин" Ой, на кубернетосах, может быть, не все, но многие, то вам все равно нужно как-то этим микросервисом между собой общаться, вам нужно где-то хранить состояние, вам нужно делать какую-то общую там security, авторизацию, ну в общем, кучу вещей, которые вроде к бизнес-логике не относятся, но делать все надо.
2223.76 2233.76 "Анатолий Кулаков" И они, в принципе, одинаковы для всех ваших микросервисов, ну то есть писать их все время вы наверняка не будете, шарить библиотечками можно, но с этим тоже есть какие-то определенные сложности.
2233.76 2236.76 "Игорь Лабутин" Ну, особенно если у вас, например, микросервисы на разных языках.
2236.76 2240.76 "Игорь Лабутин" Очень сложно пошарить библиотечку между, не знаю, .NET и Go.
2240.76 2243.76 "Игорь Лабутин" Действительно, интеропа прожива не выйдет за конец.
2243.76 2286.76 "Игорь Лабутин" Поэтому как раз-таки идея Dapr, он не единственный такой продукт, их не один существует, но идея такого продукта как Dapr, она заключается в том, что вы свои микросервисы хостите в докере, а чтобы получить какой-то общий кусочек для функциональности, которая вроде как общая для всех, и вы не хотите ее писать самому, вы используете так называемые сайткар-контейнеры, то есть это контейнер, который поднимается на том же хосте, где и работаете вы, в том же поди, если мы говорим про кубернетис, и вы общаетесь с вот этим сайткаром, если вам что-то нужно от внешнего мира, а сайткар уже знает, куда что отправить.
2286.76 2319.76 "Игорь Лабутин" То есть если вам нужно, например, отправить сообщение в какую-нибудь очередь, вы это не отправляете там в какую-нибудь, не знаю, Кавку или Азер, сервис баз, или еще куда-то, вы это отправляете в сайткар, со словами, пошли вот это вот сообщение в очередь, а сайткар уже настроен так, как вам нужно снаружи, то есть это просто делается конфигурацией, и он знает, что если он развернут в Азере, ему нужно посылать сервис баз, если он развернут в Амазоне, ему нужно посылать в соответствующие туллинг Амазона, не помню, как у них на очереди называются, и так далее.
2319.76 2334.76 "Игорь Лабутин" То есть идея в том, что это некоторая абстракция, позволяющая единым образом делать ваши микросервисы, и они, во-первых, не содержат в себе кучу общего кода, а во-вторых, они становятся, ну, в некотором смысле, независимы от того облака, где они развернуты.
2334.76 2336.76 "Игорь Лабутин" Вот примерно про этот дабр.
2336.76 2339.76 "Анатолий Кулаков" Отлично, и что же мы умеем в первой версии?
2339.76 2351.76 "Игорь Лабутин" В первой версии, которая вышла вот сейчас, а началось это все в октябре 2019 года, то есть это, считайте, полтора года примерно они работали над этим, там появилось следующее.
2351.76 2367.76 "Игорь Лабутин" Во-первых, Kubernetes - это основа основ, то есть эта штука вся заточена на работу с Kubernetes, и вы, в принципе, можете его использовать и вне Kubernetes, но весь Command Line и весь туллинг по дефолту предполагает, что оно все будет работать именно в Kubernetes.
2367.76 2387.76 "Игорь Лабутин" Дальше - Performance, то есть это все написано на Go, все эти сайткары, и основной целью при разработке было все-таки нормальный хороший Performance, то есть так, чтобы все работало быстро, и чтобы наличие такой прослойки, которая, ну как любая абстракция, немножко может снижать скорость, не сильно влияла на ваше Performance приложение.
2387.76 2402.76 "Игорь Лабутин" Дальше есть Support, то есть это все там поддержано, в том смысле, что всякие critical issues будут фикситься и так далее, то есть они обещают, что там все вылизано, но если что-то будет находиться, то к версии 1.0 мы будем выпускать всякие security-патчи и так далее.
2402.76 2431.76 "Игорь Лабутин" Они прошли несколько аудитов, security аудитов, то есть коду вроде как можно доверять, там нет, наверное, каких-то особых backdoor-ов, проблем и так далее, и в релиз включены уже production-ready SDK для четырех языков, это Java, .NET, Python и Go, и сейчас планируется, в превьюшке в версии уже есть, к следующим релизам будет готово байдинги SDK для JavaScript, PLUS, RASTA и PHP, то есть это вот то, что у нас есть на данный момент.
2431.76 2456.76 "Игорь Лабутин" На будущее, соответственно, планы, посмотреть, как все это будет использоваться и развивать это дело дальше с точки зрения добавлять новых вот этих вот building-блоков, то есть сейчас там, например, нет какой-то общей конфигурации, способа, например, каким-то единым образом получать конфигурацию приложений, это одна из идей, что можно делать, плюс улучшать, ускорять существующие блоки, будут над этим работать.
2456.76 2481.76 "Анатолий Кулаков" Многие команды сталкиваются при работе с .NET с огромными просто solutions, и за многие-многие годы существования .NET существует уже очень много проектов, у которых solutions даже ставятся до неимоверных уровней, и недавно появилась статейка, которая рассказывает о том, что же Microsoft предпринимает для того, чтобы помочь нам, разработчикам, работать с такими большими проектами.
2481.76 2495.76 "Игорь Лабутин" Да, ну и основная проблема, конечно же, то, что Visual Studio до сих пор 32-битная, поэтому если вы хотите делать что-то большое и хранить много данных, то это нужно делать либо в очень компактном виде, либо вне процесса.
2495.76 2496.76 "Игорь Лабутин" В райдере.
2496.76 2506.76 "Игорь Лабутин" Ну или да, можно это делать в райдере, который, собственно, делает примерно то же самое, на самом деле, и держит много чего out of process, потому что сам UI-чик — это не .NET.
2506.76 2508.76 "Игорь Лабутин" Но возвращаясь к студии.
2508.76 2516.76 "Игорь Лабутин" В студии, соответственно, Roslyn Compiler работает out of process, то есть C# и Visual Basic Compiler не занимают память в самой студии.
2516.76 2519.76 "Игорь Лабутин" Это, в принципе, довольно давно, я так понимаю, было сделано.
2519.76 2536.76 "Игорь Лабутин" Но из недавних изменений — это улучшение в dependencies node, то есть если вы в Solution Explorer видели dependencies node, там есть всякие зависимости от NuGet, от SDK, и еще чего-то от проектов.
2536.76 2541.76 "Игорь Лабутин" И проблема в том, что некоторые зависимости могут иметь дальнейшие зависимости.
2541.76 2546.76 "Игорь Лабутин" То есть NuGet может зависеть еще от чего-то, от SDK зависеть, его можно развернуть, было и так далее.
2546.76 2556.76 "Игорь Лабутин" И студия, на самом деле, хранила все эти зависимости в памяти, ну, в смысле информацию о них, а поскольку дерево вот этих зависимостей может быть довольно большим, то это занимало некоторое количество памяти.
2556.76 2559.76 "Игорь Лабутин" Сейчас они это все оптимизировали и стало занимать поменьше.
2559.76 2563.76 "Игорь Лабутин" Довольно большой кусок памяти отнимает MS Build.
2563.76 2585.76 "Игорь Лабутин" То есть студия очень сильно зависит от MS Build, да, потому что csproj — это, по сути, MS Build файлы, до некоторой степени, и MS Build органично встроена в саму студию, и поэтому любые улучшения и ускорения MS Build, на самом деле, не только улучшают сам билд, но и работу с самой студией в целом, потому что она основывается, я так понимаю, на механизмах парсинга и так далее.
2585.76 2590.76 "Игорь Лабутин" И проблема MS Build в том, что, по большому счету, MS Build работает со строками в огромном количестве.
2590.76 2597.76 "Игорь Лабутин" Это пути, это все эти properties, condition — это все, по сути, просто строчки в огромнейших количествах.
2597.76 2605.76 "Игорь Лабутин" Даже сами MS Build файлы, это XML-файлики, это, по сути, я думаю, что в памяти хранятся как строчки, местами, до того, как они разбарсены.
2605.76 2613.76 "Игорь Лабутин" И проблема в том, что, если вы видели когда-нибудь детальный лог от MS Build, там просто немеренейшее количество повторений.
2613.76 2617.76 "Игорь Лабутин" Один и тот же путь файла, понятное дело, повторяется во многих местах.
2617.76 2630.76 "Игорь Лабутин" Если вы берете какую-нибудь .cs файл, он может встретиться в каких-нибудь и в компиляторе, и сейчас вот терсор с генератором еще появились, и еще где-нибудь, ну, в общем, в огромном количестве мест.
2630.76 2637.76 "Игорь Лабутин" И MS Build команда сделала довольно большую работу, она только начата, но уже сейчас результаты видны.
2637.76 2647.76 "Игорь Лабутин" То есть они начали делать ручную дедубликацию, то есть они теперь длинные строчки, грубо говоря, хранят отдельно, в словарике, назовем это так, и используют их по ссылке.
2647.76 2661.76 "Игорь Лабутин" С одной стороны, это небольшое замедление, но за счет экономии памяти они утверждают, что, во-первых, они сэкономили процентов 10 по объему, и, в принципе, все это довольно сильно, ну, примерно на те же вроде как 5-10% ускорилось.
2661.76 2663.76 "Игорь Лабутин" Выглядит неплохо.
2663.76 2678.76 "Игорь Лабутин" И последнее, что сделано, как вы, может быть, знаете, Rostling, компилятор, ну и вообще вся система проектов, она внутри себя такая вся immutable, то есть любые изменения, они на самом деле создают копии объектов.
2678.76 2681.76 "Игорь Лабутин" Ну и потом ненужные выкидываются, собираются в сборщику мусора.
2681.76 2691.76 "Игорь Лабутин" Это все хорошо, но проблема в том, что современная студия, там, с некоторой версии не очень давней, начала позволять редактировать проект без его выгрузки.
2691.76 2699.76 "Игорь Лабутин" То есть раньше, если вы помните, нужно было говорить on load project, только после этого вы могли редактировать css-прочт файл, потом снова говорили load project и так далее.
2699.76 2703.76 "Игорь Лабутин" Сейчас это можно делать прямо не выгружая проектов, но это вынуждает студию держать копию.
2703.76 2705.76 "Игорь Лабутин" А потом вы можете еще что-нибудь поменять, а потом еще что-нибудь поменять.
2705.76 2711.76 "Игорь Лабутин" Ну, то есть если вы активно пошли работать над проектом, шансы, что вы в нем будете менять много чего, сильно возрастает.
2711.76 2716.76 "Игорь Лабутин" И вот студия хранила все эти копии, и довольно долго, как я понял, не отпускала их.
2716.76 2720.76 "Игорь Лабутин" Сейчас это все оптимизировано, по идее должно работать с сайтерами гораздо лучше.
2720.76 2732.76 "Игорь Лабутин" То есть они утверждают, что они видят по репортам, на примерно 25-30% лучше стало работать, в том числе, что стало крышей меньше на 25%, или как-то так они это формулируют.
2732.76 2737.76 "Игорь Лабутин" И по времени, типа, тоже существенное ускорение, улучшение загрузки больших салюшенов.
2737.76 2739.76 "Игорь Лабутин" Так что работа ведется.
2739.76 2752.76 "Игорь Лабутин" Мы вряд ли, кажется, увидим 64-битную студию, но вот этот auto-process движения плюс улучшение каких-то внутренних компонентов, видим, пока достаточно, чтобы это как-то поддерживать
2752.76 2754.76 "Анатолий Кулаков" на хорошем уровне. Ну, неплохо, неплохо.
2754.76 2760.76 "Анатолий Кулаков" В принципе, все эти изменения вы можете уже сами попробовать на своих проектах в версии 2019-16.8.
2760.76 2767.76 "Анатолий Кулаков" Поэтому, если у вас есть большие проекты, то, в принципе, зацените все эти обещания о бусте и ускорении.
2767.76 2776.76 "Анатолий Кулаков" А еще одна интересная статейка у нас есть про то, каким образом магическим Visual Studio делает свой всеобъемлющий поиск.
2776.76 2781.76 "Анатолий Кулаков" Это то, что вы, например, могли знать в ReSharper под именем Find Everywhere.
2781.76 2784.76 "Анатолий Кулаков" А что же такое студия там интересного делает под капотом?
2784.76 2789.76 "Игорь Лабутин" Во-первых, в студии действительно появилась эта штука, по-моему, как раз-таки в девятнадцатой версии.
2789.76 2796.76 "Игорь Лабутин" Вызывается по Ctrl+Q, по окошечку там наверху в районе title bar.
2796.76 2802.76 "Игорь Лабутин" И оно действительно тоже ищет по всему, и по пунктам меню, и по командам, и по коду.
2802.76 2805.76 "Игорь Лабутин" Но делает она это довольно интересно.
2805.76 2808.76 "Игорь Лабутин" До версии 16.9, я так понимаю, это было полностью оффлайн решение.
2808.76 2813.76 "Игорь Лабутин" То есть, оно знало про все фичи Visual Studio, которые у вас установлены, и как-то по ним умело искать.
2813.76 2818.76 "Игорь Лабутин" А в 16.9 внедрили новую логику, она теперь ищет через облако.
2818.76 2820.76 "Игорь Лабутин" Так что работает это теперь следующим образом.
2820.76 2838.76 "Игорь Лабутин" Значит, каждый раз, когда вы нажимаете Ctrl+Q и туда что-нибудь вводите, ваш поисковый запрос, все анонимно и все такое, но тем не менее уходит в облако, ну, в ажур, понятное дело, там, соответственно, обрабатывается, и возвращается вам результат в виде, собственно, результатов поиска.
2838.76 2844.76 "Анатолий Кулаков" Подожди, но я же ищу по локальным файлам, в локальной студии, по локальным менюшкам.
2844.76 2846.76 "Анатолий Кулаков" Какой смысл обсылать это в облако?
2846.76 2848.76 "Анатолий Кулаков" Облако же не знает ничего о моем окружении.
2848.76 2849.76 "Анатолий Кулаков" Или уже знает?
2849.76 2852.76 "Игорь Лабутин" Вот, облако знает, на самом деле, немножко о твоем окружении.
2852.76 2856.76 "Игорь Лабутин" Смотри, зачем это было сделано, по крайней мере, как они говорят.
2856.76 2861.76 "Игорь Лабутин" Во-первых, откуда берется вообще информация о том, по чему искать?
2861.76 2869.76 "Игорь Лабутин" То есть, облаку же тоже надо знать, по каким вообще искать, что у тебя за Visual Studio, что там есть и так далее.
2869.76 2871.76 "Игорь Лабутин" Делается это следующим образом.
2871.76 2884.76 "Игорь Лабутин" При сборке Visual Studio теперь инфа обо всех фичах автоматическим образом закидывается в специальную базу данных в облаке и делается это на 14 языках, на которых умеет, как я понимаю, работать Visual Studio.
2884.76 2885.76 "Игорь Лабутин" Вроде как.
2885.76 2894.76 "Игорь Лабутин" Я никогда не пользовался Visual Studio не на английском, но наверняка могу предсказать, что есть кто-то, кто пользуется не на английском.
2894.76 2900.76 "Игорь Лабутин" И, естественно, там бесполезно искать Solution Explorer, например, а нужно искать что-то другое на их родном языке.
2900.76 2909.76 "Игорь Лабутин" В итоге, в общем, есть некоторая база данных, где автоматически известно по каждой версии студии автоматический список фич, которые там есть.
2909.76 2918.76 "Анатолий Кулаков" О, а еще знаешь, прекрасная фича была, не знаю, есть она или нет, это когда ты все-таки ищешь Solution Explorer, а тебе в русской студии вываливается обозреватель решений.
2918.76 2920.76 "Анатолий Кулаков" То есть, тоже замечательная вещь.
2920.76 2922.76 "Игорь Лабутин" Ну, вот, я так понимаю, что это вот ровно оно.
2922.76 2937.76 "Игорь Лабутин" Возможно, так оно и должно работать, потому что, например, ты прочитал статью на английском, там написано "откройте Solution Explorer", ты идешь в свою студию, которая на русском, набиваешь Solution Explorer, а тебе прямо вот дается то, что нужно, это было бы действительно удобно.
2937.76 2938.76 "Игорь Лабутин" Так вот.
2938.76 2939.76 "Игорь Лабутин" Да, да, именно так.
2939.76 2952.76 "Игорь Лабутин" Всю эту пачку фич решил студия, она загнана в базу данных, дальше на это дело натравливается Azure Cognitive Services, которая с помощью Natural Language Processing начинает парсить все то, что там есть.
2952.76 2967.76 "Игорь Лабутин" То есть, я так понимаю, что там не просто пункты меню, но там какие-то кусочки, видимо, халпа, и строится, в общем, некоторая, ну, модель, не модель, не нейросетка, может быть, а распознается, по крайней мере, из этих текстов добавляются синонимы автоматически.
2967.76 2968.76 "Игорь Лабутин" Шикарно.
2968.76 2982.76 "Игорь Лабутин" Соответственно, у тебя получается довольно такой полный и автоматом сгенерированный обзор фич, который пригоден для поиска, уже за, так сказать, обогащенной синонимами и автоматически обработанный на 14 языках.
2982.76 2995.76 "Игорь Лабутин" Дальше студия, когда ты что-то набирал в поиске, присылает запрос в облако, ну, понятно, что там есть кашик, если такой запрос ты еще недавно присылал, то уже тебе вернут результат кэша, но, предположим, в кэше ничего нет.
2995.76 3013.76 "Игорь Лабутин" Тогда эта штука уходит, собственно, в поиск базу, что-то там по словам ключевым как-то находит, а дальше это все посылается в специальный модуль, который называется ranking module, то есть результат поиска еще может подвергаться некоторой обработке, и порядок результатов может меняться.
3013.76 3017.76 "Игорь Лабутин" И меняется он как раз-таки исходя из контекста, где ты сейчас находишься.
3017.76 3044.76 "Игорь Лабутин" То есть они как бы приводят пример, что в среднем, когда ты просто открыл студию, загрузив в ней solution, и ты в поиске набираешь solution, то старая студия, в которой поиск был обычный, в большинстве случаев выдает тебе пункт меню build solution, но по их опыту, по кликам того, что делают пользователи, они видят, что в среднем пользователю в свежеоткрытой студии скорее нужен solution explorer.
3044.76 3059.76 "Игорь Лабутин" И вот эта вот модель дополнительная, она, используя инфу о том вообще в каком контексте студии ты сейчас находишься, какие у тебя окна открыты, типа там ты в отладке, не в отладке, она упорядочивает результаты поиска так, чтобы они были более релевантны тому, что ты хочешь.
3059.76 3062.76 "Игорь Лабутин" Ну, тому, что она верит, что ты хочешь.
3062.76 3067.76 "Игорь Лабутин" Дальше, естественно, по результатам клика она поймет, ошиблась она или нет, и как-то адаптирует дополнительно модель.
3067.76 3083.76 "Игорь Лабутин" В общем, такая обучаемая штука, причем понятно, что в принципе, наверное, большинство пользователей, программистов более или менее одинаково пользуются студией, ну, основные сценарии все более-менее одинаковые, и поэтому, скорее всего, она будет неплохо обучаться и действительно показывать релевантные моменты для большинства сценариев.
3083.76 3088.76 "Анатолий Кулаков" Ну, звучит неплохо, но судя по критериям, работает она только онлайн, правильно?
3088.76 3107.76 "Игорь Лабутин" Да. Вся эта магия, конечно, работает только онлайн, если вы офлайн, не надо переживать, поиск совсем работать не перестанет, он просто фоллбетчится, я так понимаю, на старое поведение, пункты меню у вас все еще найдутся, и может быть даже она что-нибудь локально кэширует с точки зрения, что Solution Explorer все еще будет первым, а не Build Solution, хотя не удивлюсь, если откатится на старое решение.
3107.76 3119.76 "Игорь Лабутин" Но в комментариях к статье, к новости, уже есть, скажем так, недовольные тем, что как все мои поиски посылаются в онлайн, и я никак не могу это отключить.
3119.76 3131.76 "Игорь Лабутин" Официальный ответ Microsoft на данный момент, ну, вы сходите на UserVoice, или как там сейчас называется, сайт, где они принимают все эти идеи от пользователей, и предложите идею сделать флажок, чтобы можно было отключать.
3131.76 3146.76 "Игорь Лабутин" Пока вот оно на таком уровне, то есть если вы как-то не хотите, чтобы ваши поисковые запросы по вашей студии отправлялись в облако, хоть там и анонимные, и несохраняемые, то не пользуйтесь UserVoice 16.9, либо не пользуйтесь этим верхним окошечком.
3146.76 3159.76 "Анатолий Кулаков" Ну, и речь здесь идет не именно об всеобъемляющем поиске, который ищет просто везде, а только о поиске, который ищет по студии, то есть по окошкам, по диалогам, по менюшкам, вот по студии.
3159.76 3164.76 "Анатолий Кулаков" Ну, то есть ваш код, например, она такими умными способами искать не сможет?
3164.76 3169.76 "Игорь Лабутин" Ну, пока не сможет, но я думаю, что Microsoft может быть и в эту сторону тоже думает.
3169.76 3174.76 "Анатолий Кулаков" Слушай, перекачивать код в интернет, это уже, мне кажется, Microsoft не решится.
3174.76 3194.76 "Игорь Лабутин" Весь код может быть нет, но, например, если он сможет, скажем, если ты в такое окошечко введешь, там, не знаю, Control-Q, там, ну, не знаю, какой пример, ну, тот же там, не знаю, WCF, что-нибудь, какой-нибудь хитрый байдинг, да, который мы сегодня обсуждали, а он автоматически тебе предложит Nugetik сразу, ну, может быть, это будет иметь смысл.
3194.76 3217.76 "Игорь Лабутин" То есть я не столько по коду твоему локальному, с точки зрения найди мне класс такой-то, а именно с точки зрения кода, вот, чтоб меня такой поюзать, я хочу в коде видеть, там, не знаю, аж тп-клиент, что мне нужно заюзать, какой пакет, а она сама подберет тебе, учитывая, где ты находишься, в WPF-приложении или там, в .NET Core, консольке или еще где-то.
3217.76 3223.76 "Анатолий Кулаков" Ну да, по каким-нибудь открытым проектам, которые есть на Nugetik, которые есть на GitHub, там, наверное, уже вполне можно такую штуку делать.
3223.76 3228.76 "Анатолий Кулаков" А представляешь, как было бы интересно, если бы она тебе, там, синонимы, антонимы бы искала в твоем коде?
3228.76 3233.76 "Анатолий Кулаков" Вот ты набрал слово "юзер", она говорит, "не-не-не, вы хотели не юзер, вы хотели person".
3233.76 3234.76 "Анатолий Кулаков" Было бы забавно.
3234.76 3239.76 "Игорь Лабутин" Ну, вообще интересно, да, автоматический поиск проблем в коде, там.
3239.76 3244.76 "Игорь Лабутин" У вас это, в вашем Baotok контексте, используются три разных термина для одного и того же.
3244.76 3246.76 "Игорь Лабутин" Мы знаем, что обычно это одно и то же.
3246.76 3249.76 "Игорь Лабутин" Вы точно уверены, что вы хотите три разных термина?
3249.76 3251.76 "Игорь Лабутин" Такой "дэ-дэ-дэ хелпер".
3251.76 3259.76 "Анатолий Кулаков" Да-да, ты как раз понимание ubiquitous language, domain-driven design, аналитика подключать.
3259.76 3262.76 "Анатолий Кулаков" Так, слушай, что-то мы с тобой уже в послешоу какой-то сваливаемся.
3262.76 3264.76 "Анатолий Кулаков" Давай закругляться.
3264.76 3267.76 "Игорь Лабутин" Да, на сегодня, на самом деле, мы действительно закруглимся.
3267.76 3277.76 "Игорь Лабутин" Сегодня у нас нет каких-то больших, огромных, интересных технических статей, но новостей было довольно много, всяких разных, поэтому на сегодня мы на этом закончим.
3277.76 3281.76 "Игорь Лабутин" Итак, мы сегодня посмотрели на Visual Studio с довольно разных сторон.
3281.76 3285.76 "Игорь Лабутин" Мы посмотрели на то, что вышло в 16.9, 16.10, превью 1.
3285.76 3294.76 "Игорь Лабутин" Мы посмотрели, как в 16.8 работало с большими солюшенами, и как в 16.9 улучшили поиск по самой Visual Studio.
3294.76 3300.76 "Игорь Лабутин" Глянули на Core WCF, релиз, и что там завезли, и насколько им можно пользоваться.
3300.76 3309.76 "Игорь Лабутин" Посмотрели на новый tool, вот этот upgrade assistant, который пока в превьюшке, но может быть уже сможет помочь вам проапгрейдить ваши проекты до .NET 5.
3309.76 3314.76 "Игорь Лабутин" Узнали планы по .NET мультиплатформе AppUI, MAUI.
3314.76 3322.76 "Игорь Лабутин" Посмотрели на пропозы, что в Flexible HTTP APIs, если вам интересно низкоуровневые HTTP API в .NET, обязательно загляните.
3322.76 3327.76 "Игорь Лабутин" Упомянули два интересных плейлиста на YouTube.
3327.76 3341.76 "Игорь Лабутин" Один это .NET Conf Focus on Windows для десктопной разработки под Windows, а второй это .NET Garbage Collector and Turnouts от Конрада Кокоса, где он объясняет детально, как работает Garbage Collector в картинках и в виде серии докладов.
3341.76 3347.76 "Игорь Лабутин" И посмотрели на то, что такое Dapr, который зарелизился до версии 1.0, и зачем он может быть вам полезен.
3347.76 3355.76 "Анатолий Кулаков" Ну, а если ты хочешь поддержать наш подкаст, заходи на пусти и Patreon, и заодно услышишь наше послешоу.
3355.76 3356.76 "Анатолий Кулаков" На этом все.
3356.76 3357.76 "Анатолий Кулаков" Всем пока.
3357.76 3358.76 "Анатолий Кулаков" До новых встреч.
3358.76 3359.76 "Игорь Лабутин" Всем пока.
3359.76 3367.76 None [Музыка]
