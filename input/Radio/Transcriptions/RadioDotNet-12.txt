0.00 5.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
5.36 11.44 "Анатолий Кулаков" В эфире Radio.net и в студии, как обычно, Анатолий Кулаков и Игорь Лабутин.
11.44 12.44 "Анатолий Кулаков" Привет!
12.44 14.44 "Анатолий Кулаков" Мы объявляли в прошлом выпуске конкурс.
14.44 16.80 "Анатолий Кулаков" Спасибо большое всем тем, кто откликнулся.
16.80 19.04 "Анатолий Кулаков" Раздали три лицензии JetBrains.
19.04 23.44 "Анатолий Кулаков" Те, кто не удостоился этих лицензий, не расстраивайтесь.
23.44 26.12 "Анатолий Кулаков" Конкурсы еще будут, просто следите за нашими выпусками.
26.12 32.40 "Анатолий Кулаков" Также во время розыгрыша прозвучали интересные вопросы про то, как наиболее удобно слушать наш подкаст.
32.40 38.16 "Анатолий Кулаков" Поэтому хотелось бы немножко рассказать, что слушать нас можно практически везде, где вам только захочется.
38.16 41.08 "Анатолий Кулаков" Самое первое, что приходит на ум, это веб-плеер.
41.08 49.20 "Анатолий Кулаков" На сайте radio.net.ru вы можете найти плеер и слушать наши подкасты прямо в браузере.
49.20 52.36 "Анатолий Кулаков" Там же доступен список всех наших выпусков.
52.36 54.92 "Анатолий Кулаков" Второй очень популярный канал - это YouTube.
54.92 63.12 "Анатолий Кулаков" Никакого видео с нашими разумными лицами вы там не увидите, но звук ничем не отличается от того, что вы услышите в плеере.
63.12 64.52 "Анатолий Кулаков" Поэтому можно смотреть на YouTube.
64.52 68.56 "Анатолий Кулаков" Там есть удобная фишка прыгания по таймлайну.
68.56 71.44 "Анатолий Кулаков" То есть можно перематывать темы, можно возвращаться к темам.
71.44 79.28 "Анатолий Кулаков" И также там есть наиболее полный список всех ссылок про все темы, которые мы обсуждаем в нашем подкасте.
79.28 84.96 "Анатолий Кулаков" Самый удобный, наверное, как мне кажется, способ это все-таки слушать подкасты со своего мобильного телефона.
84.96 89.60 "Анатолий Кулаков" Для этого нужно воспользоваться какой-нибудь программой по прослушиванию подкастов.
89.60 90.96 "Анатолий Кулаков" Их сейчас миллионы.
90.96 100.60 "Анатолий Кулаков" Просто вводите в своем любимом магазине подкаст плеер и выбираете все то, что вам наиболее интересно по интерфейсу или по качеству или по настройкам.
100.60 107.84 "Анатолий Кулаков" Мы есть практически везде, во всех паблишинговских сетях по распространению подкастов.
107.84 114.64 "Анатолий Кулаков" В Google подкастах, в Apple подкастах, в Spotify и много-много где еще у нас около 10 сетей.
114.64 121.04 "Анатолий Кулаков" Самый, наверное, хардкорный вариант это скачивать прямо mp3 файлы и загружать их куда-нибудь к себе.
121.04 125.92 "Анатолий Кулаков" Я этим вариантом очень часто пользовался раньше, когда у меня был физический плеер.
125.92 131.56 "Анатолий Кулаков" Плеер был настолько крут, что он держал там батарейку целую неделю, чем никакой телефон похвастаться не мог.
131.56 136.36 "Анатолий Кулаков" Поэтому я использовал отдельный физический плеер и честно слушал подкасты в виде скачанных mp3 файлов.
136.36 142.32 "Анатолий Кулаков" Если вы предпочитаете этот способ, то у нас есть RSS-ка и там есть прямые ссылки прямо на mp3 файлы.
142.32 144.12 "Анатолий Кулаков" Скачивайте смело.
144.12 148.44 "Анатолий Кулаков" Ну и вообще подписывайтесь на нас в RSS, это отличный способ следить за новыми выпусками.
148.44 150.00 "Анатолий Кулаков" Так, Игорь, я все назвал?
150.00 152.56 "Анатолий Кулаков" Или у нас есть еще какие-то способы нас слушать?
152.56 154.52 "Игорь Лабутин" Да пожалуй все вроде.
154.52 158.84 "Игорь Лабутин" На самом деле нужно проверить Spotify, потому что Spotify пришел в Россию, наконец-таки.
158.84 163.72 "Игорь Лабутин" Я попробовал найти радио тут, но что-то не нашлось прямо сейчас во время подкаста.
163.72 168.20 "Игорь Лабутин" Поэтому надо будет проверить, где мы там в Spotify и доступны ли мы в России.
168.20 170.40 "Игорь Лабутин" Возможно просто в России, наверное, еще подкасты просто не завезли.
170.40 171.40 "Анатолий Кулаков" Скорее всего да.
171.40 177.12 "Анатолий Кулаков" Раздел подкастов в России еще не открыт, но если вы не в России, то попробуйте найти нас в Spotify.
177.12 178.92 "Игорь Лабутин" Да, вот наверное почему у меня не нашелся.
178.92 183.88 "Игорь Лабутин" Но все остальные способы валидны и конечно пользуйтесь и слушайте нас.
183.88 185.72 "Игорь Лабутин" Так, погнали теперь про .NET.
185.72 192.36 "Игорь Лабутин" У нас .NET 5, .NET 5 близится потихонечку к релизу, выходят очередные превью.
192.36 196.00 "Игорь Лабутин" И есть ли у нас какие-то новости, про которые мы можем поговорить сегодня?
196.00 197.00 "Анатолий Кулаков" Обязательно.
197.00 200.32 "Анатолий Кулаков" Ни одного выпуска без .NET 5, я думаю, у нас не останется.
200.32 205.92 "Анатолий Кулаков" И сейчас хотелось бы поговорить о интересных новых ключевых словах, которые предлагают ввести в C#.
205.92 209.44 "Анатолий Кулаков" И это ключевые слова AND, OR и NOT.
209.44 211.60 "Анатолий Кулаков" Прямо так вот буквами и пишется.
211.60 216.48 "Анатолий Кулаков" На первый взгляд кажется, что они ничем не отличаются от привычных нам логических операций.
216.48 221.16 "Анатолий Кулаков" Две вертикальные черты или два амперсанда, но это только с виду.
221.16 228.64 "Анатолий Кулаков" На самом деле эти слова ввели специально, чтобы мы не путались с тем, что означают амперсанды и означают эти ключевые слова.
228.64 231.28 "Анатолий Кулаков" Что же с помощью них можно творить?
231.28 241.84 "Анатолий Кулаков" Например, у меня часто возникала ситуация, когда есть переменная статус и мне нужно проверить, в этой переменной лежит OK или NO CONTENT или что-либо другое.
241.84 245.12 "Анатолий Кулаков" То есть какой-то список статусов из моего предопределенного списка.
245.12 250.32 "Анатолий Кулаков" Мы могли встретить, например, extension метод inRange, который делал подобную проверку.
250.32 256.32 "Анатолий Кулаков" Сейчас же Microsoft предлагает ввести новые ключевые слова и можно будет написать следующую фразу.
256.32 262.12 "Анатолий Кулаков" If status is OK or прямо двумя буковками NO CONTENT.
262.12 268.52 "Анатолий Кулаков" Это означает, что в статусе должна находиться переменная со значением OK или NO CONTENT.
268.52 271.76 "Анатолий Кулаков" Тогда условие примет истину и мы провалимся в true block.
271.76 280.14 "Анатолий Кулаков" Точно так же работает и OR и NOT введен просто для красоты, чтобы можно было писать полноценные литературные произведения в C#.
280.14 288.04 "Игорь Лабутин" Да, и на самом деле, если почитать эту тишью, то там рассматривалось достаточно много разных забавных альтернатив.
288.04 299.32 "Игорь Лабутин" Естественно, первым попыткой было, а давайте просто использовать стандартный mdor, как сказал Толя, но там есть проблемы с синтаксисом и с многозначностью.
299.32 304.84 "Игорь Лабутин" И вообще, как это все вычислять во время compile time или во время runtime, и поэтому от этой идеи отказали.
304.84 314.32 "Игорь Лабутин" Дальше там были предложения использовать, собственно, тройной амперсант, были предложения использовать честные математические знаки и/или в виде галочки и перевернутой галочки, соответственно.
314.32 321.24 "Игорь Лабутин" А отрицание - это вообще хитрый математический знак, который хрен наберешь на обычной клавиатуре.
321.24 333.08 "Игорь Лабутин" Ну, в общем, было предложение заключать эти паттерны в квадратные скобки, и тогда AND и OR не будут вычисляться компилятором заранее, а будут правильно интерпретироваться во время runtime.
333.08 336.96 "Игорь Лабутин" В общем, много-много-много всяких разных интересных предложений.
336.96 338.56 "Игорь Лабутин" Обсуждение еще до сих пор не закончено.
338.56 345.56 "Игорь Лабутин" AND, OR и NOT выглядят как наиболее подходящие, но буквально три дня назад был...
345.56 352.96 "Игорь Лабутин" Нет, буквально несколько дней назад был оставлен коммент, что и этот синтаксис не очень хорош, потому что вот есть какие-то причины.
352.96 359.00 "Игорь Лабутин" Так что следим за новостями, будем смотреть, во что мы превратим это все к моменту релиза.
359.00 368.28 "Игорь Лабутин" Очевидно, что какое-то изменение нужно, очевидно, что синтаксис нужен, но каким он будет в итоговом варианте - пока секрет и непонятно никому.
368.28 382.08 "Анатолий Кулаков" Но уже далеко не секрет, что скоро уже будет релиз .NET 5, и очень-очень много всяких performance improvements уже готово в мастере в .NET 5 или еще собирается только влиться.
382.08 390.68 "Анатолий Кулаков" И как раз Stephen Taub выпустил шикарную, огромную, большую статью про performance improvements в пятом .NET.
390.68 392.56 "Анатолий Кулаков" И давай по ней немножко пробежимся.
392.56 393.56 "Игорь Лабутин" Давай.
393.56 397.96 "Игорь Лабутин" Во-первых, надо сказать, что Stephen Taub делает такую статью почти для каждого мажорного релиза.
397.96 406.76 "Игорь Лабутин" Он не делал этого для 3.1 .NET Core, потому что там было не очень много конкретно performance improvements, больше про стабилизацию, но 3.0 была большая статья.
406.76 408.28 "Игорь Лабутин" И вот теперь .NET 5.
408.28 418.68 "Игорь Лабутин" Она традиционно разделена на несколько разделов по разным областям .NET, и можем просто пробежаться, захайлайтить какие-то интересные для нас моменты.
418.68 424.48 "Игорь Лабутин" Если вам интересно более детально во всем разобраться, то читайте статью.
424.48 438.16 "Игорь Лабутин" Каждый improvement подкреплен ссылкой на соответствующие pull requests и issues можно внимательно почитать, что же там обсуждалось, как все эти improvements делаются и какие вообще комменты посылают ревьюеры, когда такие improvements делаются.
438.16 439.76 "Игорь Лабутин" Занимательнейшее чтение.
439.76 446.48 "Анатолий Кулаков" Если Taub не врет, он описал около 250 issues, что довольно хорошо.
446.48 450.24 "Игорь Лабутин" Но мы 250 не будем рассматривать, иначе это затянется очень надолго.
450.24 458.20 "Игорь Лабутин" Главное, они настолько некоторые специфичные и небольшие, что, или узкоспециализированные, может лучше сказать.
458.20 461.96 "Игорь Лабутин" Смысла особого их нет обсуждать детально, но кое-какие мы рассмотрим.
461.96 462.96 "Игорь Лабутин" И начнем мы с garbage collector.
462.96 473.24 "Игорь Лабутин" В garbage collector на самом деле сделана первая штука, которая касается непосредственно garbage collector, и это то, что называется work stealing.
473.24 486.08 "Игорь Лабутин" То есть известно, что garbage collector в определенных режимах работы имеет несколько потоков, которые занимаются тем, что маркают объекты в соответствующих кучах, которые ассоциированы с нужным ядром процессора.
486.08 493.72 "Игорь Лабутин" И до dotnet 5 ситуация была такая, что если поток своей кучи закончил, он, собственно, ждал, пока все остальные закончат.
493.72 509.12 "Игорь Лабутин" Сейчас они реализовали штуку, что если одна из куч на одном из ядер, например, слишком большая, то остальные потоки, когда они закончатся своими маленькими, они немножко стянут работу у несчастного потока, у которого очень большая куча, и тем самым mark phase будет закончен гораздо быстрее.
509.12 518.92 "Игорь Лабутин" Это хорошо, это, естественно, накладывает некоторые дополнительные ограничения и сложность в работу garbage коллектора, но для нас, как конечных пользователей, это не должно быть заметно.
518.92 522.20 "Игорь Лабутин" Он просто станет работать чуточку быстрее в определенных сценариях.
522.20 527.64 "Игорь Лабутин" Второе улучшение, оно на самом деле не совсем про garbage коллектор даже, но оно тесно с ним связано.
527.64 540.76 "Игорь Лабутин" А именно мы уже это упоминали в каком-то из прошлых выпусков, что часть нативного кода переносится командой Microsoft, командой Runtime в реализацию на C#.
540.76 547.20 "Игорь Лабутин" Казалось бы, быстрый нативный код переписывают на C#, причем достаточно низкоуровневые вещи.
547.20 548.20 "Игорь Лабутин" Зачем?
548.20 550.88 "Игорь Лабутин" Оказалось, что у этого есть очень много плюсов.
550.88 554.32 "Игорь Лабутин" Плюс первый - гораздо проще в такой проект контрибьютить.
554.32 562.12 "Игорь Лабутин" Опыт команды Runtime показал, что сторонние разработчики контрибьютят в C# гораздо хоть не чем в какой-то там неизведанный C++.
562.12 564.48 "Игорь Лабутин" Ну, это как-то можно даже объяснить.
564.48 574.12 "Игорь Лабутин" Если я тут на этой разработчике нашел что-то, что мне мешает в Runtime, ну я могу на C# же что-то написать, а вот если мне нужно лезть в C++ для этого, это как-то довольно сложно для меня.
574.12 584.48 "Игорь Лабутин" Второе - это самой команде Runtime стало гораздо проще ревьюить и принимать pull-requests, потому что C# сам по себе он язык безопасный.
584.48 608.12 "Игорь Лабутин" То есть, понятно, там есть всякие bound, check, type checking и всякие прочие checking, и это означает, что даже если вдруг при ревью pull-requests будет пропущена та или иная ошибка, то в среднем команда Runtime может беспокоиться меньше, чем если то же самое было бы пропущено в C++ коде, где можно сделать все что угодно с памятью, все сломать и свалиться с каким-нибудь access violation exception.
608.12 611.60 "Игорь Лабутин" И это все очень здорово с точки зрения процесса контрибьюта.
611.60 618.68 "Игорь Лабутин" Но на самом деле вот этот переход из нативного кода в managed сделал очень хорошо garbage collector.
618.68 619.68 "Игорь Лабутин" Почему?
619.68 629.12 "Игорь Лабутин" Потому что garbage collector, как известно, для того, чтобы сделать свою работу, а именно сделать mark face, compact face и все остальное, ему нужно затормозить все потоки.
629.12 631.36 "Игорь Лабутин" По крайней мере для перемещения объектов уж точно.
631.36 634.88 "Игорь Лабутин" И тормозить он их может только в определенных местах, они называются safe points.
634.88 638.72 "Игорь Лабутин" И очевидно, что такой safe point не может быть в середине нативного кода.
638.72 651.56 "Игорь Лабутин" То есть если нам пришла пора сделать garbage collection, то останавливаются все managed потоки, а все те потоки, которые в данный момент находятся в unmanaged коде, они ждут, точнее garbage collector ждет, пока эти потоки вернутся в managed код и тут же их останавливает.
651.56 666.68 "Игорь Лабутин" И естественно, чем больше кода мы переносим из native в managed, тем у garbage collector больше шансов попасть именно в managed код и не делать вот эти мелкие паузы в начале своей работы, чтобы дождаться, пока все потоки вернутся в managed код, чтобы их можно было затормозить.
666.68 678.64 "Игорь Лабутин" И поэтому косвенным эффектом того, что все, ну не все, а часть кода переносится в managed стало то, что garbage collector становится чуть-чуть, не то чтобы быстрее, но он меньше паузится.
678.64 683.16 "Анатолий Кулаков" Игорь, а разве нет преимущества еще в том, что у тебя код автоматически становится кроссплатформенным?
683.16 691.60 "Анатолий Кулаков" Потому что на плюсах ты должен его конкретно подгонять под каждую платформу, под операционную систему, под процессор, под архитектуру памяти и так далее.
691.60 694.32 "Анатолий Кулаков" А на дотнете ты все это получаешь на халяву.
694.32 696.76 "Игорь Лабутин" Да, это тоже правда, действительно.
696.76 711.76 "Игорь Лабутин" То есть мы автоматически получаем вполне себе кроссплатформенный, плюс с современным распространением всяких интригсиков можно тем не менее писать достаточно высокоэффективный код в том числе managed и автоматически эти интригсики будут задействованы на каждой платформе своей.
711.76 721.80 "Анатолий Кулаков" Погоди, до интригсиков я хотел бы еще пример привести того, что ты сказал насчет того, что неужели действительно код, который переписан с плюсов на C#, он работает быстрее.
721.80 736.56 "Анатолий Кулаков" В дотнет 5 будут быстрее работать сортировка на маленьких массивах, потому что как раз таки overhead на вызов плюсового кода, на маршаллинг, он был настолько большой, что намного легче было сделать его здесь локально в управляемой среде.
736.56 740.48 "Анатолий Кулаков" И ни много ни мало, в два раза практически увеличился перформанс.
740.48 742.08 "Игорь Лабутин" Ну, это только для маленьких массивов.
742.08 757.64 "Игорь Лабутин" Конечно же для больших массивов перформанс вряд ли сильно увеличился, там накладные расходы на managed и unmanaged не такие большие, но зато на больших массивах как раз таки сильнее сыграет то, что я говорил про паузу garbage collector, потому что понятно, что пока мы в нативном коде сортируем большой массив, garbage collector будет этого
757.64 761.92 "Анатолий Кулаков" ждать. Еще интересное нововведение, у нас появился новый системный тип.
761.92 762.92 "Анатолий Кулаков" Вот это радость-то какая.
762.92 768.52 "Анатолий Кулаков" У нас были синглы, даблы, а теперь появился полусингл, который так и называли - system half.
768.52 782.20 "Анатолий Кулаков" Это 16-битный floating point примитив, и, например, чтобы его добавить, интересная статистика, понадобилось 14 файлов, в том числе вместе с тестами, чтобы добавить такой примитивный типчик.
782.20 794.64 "Анатолий Кулаков" Он полностью управляемый, в отличие от старых примитивов, там нет никаких пылесосных кодов, и это лишний раз подтверждает тот путь, который выбрала команда больше, больше .NET классов.
794.64 808.12 "Игорь Лабутин" Ну вот, продолжая дальше, я уже упомянул интринсики, основной, конечно, большой объем работы по интринсикам был сделан DotNet Core 3.0, где были добавлены SSE 4, AVX 2, поддержка всего этого добра.
808.12 831.56 "Игорь Лабутин" В DotNet 5 делается большая работа по ARM-специфичным интринсикам, потому что Microsoft нужно, чтобы все это работало на ARM-ах, во-первых, с точки зрения кроссплатформенности, чтобы это нормально работало на всяких там мобильничках, во-вторых, если я правильно понимаю, их собственный notebook, как же его зовут, я забыл, тоже на ARM, поэтому им нужно, чтобы все это на ARM работало.
831.56 840.60 "Игорь Лабутин" Ну, особых деталей рассказывать не будем, тем, кому интересно ARM-специфик интринсики, посмотрите, что там сделано, в ултриквесте все перечислены.
840.60 854.48 "Анатолий Кулаков" В стексе тоже много всего улучшили, основные перформансы и прумансы касаются работы строк, увеличилась производительность методов из whitespace, tool-over вариант, toString, startSweep и много-много разных других.
854.48 876.16 "Анатолий Кулаков" Основной вывод, который из этого можно сделать, если у вас есть возможность использовать сравнение или передачу, или конвертацию в инвариантной культуре, то обязательно пользуйтесь этой возможностью, потому что инвариантная культура всегда работает намного быстрее, намного эффективнее, и оптимизации для нее сделано намного больше, в том числе и оптимизации для регулярных выражений.
876.16 886.52 "Анатолий Кулаков" Мы уже обсуждали подробно статью про регулярные выражения, какие там оптимизации были сделаны, как там работает StateMachine, какие там применены были хаки, интересные фишки.
886.52 887.76 "Анатолий Кулаков" Думаю, повторяться мы не будем.
887.76 892.92 "Анатолий Кулаков" Если кому-то интересно, переслушайте один из наших последних выпусков про регулярные выражения.
892.92 896.20 "Игорь Лабутин" Да, дальше, как обычно, есть улучшения в async'ах.
896.20 897.60 "Игорь Лабутин" Async'ы и wait'ы у нас сейчас везде.
897.60 908.64 "Игорь Лабутин" В принципе, их уже с появлением типов valueTask довели до, ну я не знаю, если не до идеала, то близко, но тем не менее нашлась еще одна оптимизация.
908.64 932.60 "Игорь Лабутин" Мы об ней тоже немножко упоминали, что valueTask'и теперь можно пулить, то есть если вы используете valueTask'и в классическом сценарии, то есть только в async'а wait'а, не вызывая ничего больше на них, строго используя их один раз, то тогда можно сэкономить на создаваемых внутри task объектах для случая, когда у вас работа выполняется несинхронно, не комплитится несинхронно.
932.60 940.32 "Игорь Лабутин" Эти объекты можно пулить и тем самым сэкономить еще немножко локейтов памяти.
940.32 953.64 "Игорь Лабутин" Фича настолько, не сказать, что опасная, но довольно-таки нестандартная и требует достаточно аккуратного использования valueTask'ов, но ее сделали так, что ее нужно включать отдельно.
953.64 959.44 "Игорь Лабутин" Есть специальный environment переменная, который нужно поставить в единичку, и тогда у вас эта штука будет работать.
959.44 966.48 "Анатолий Кулаков" Еще одно интересное нововведение в коллекциях, которое из разряда когнитивного диссонанса.
966.48 981.16 "Анатолий Кулаков" Наверное каждый из вас тоже сталкивался с ситуацией, когда всякие Rostlin анализаторы или решаперы подсказывают вам, что условия в коллекции элементов больше нуля или не равно ноль, вы должны заменить на функцию any.
981.16 984.88 "Анатолий Кулаков" Большинство программистов так и делало, просто молча соглашалась и заменяла.
984.88 994.44 "Анатолий Кулаков" Те, кто лазил внутрь этого any, видел, что реализация any будет работать намного медленнее обычно, чем реализация count'а.
994.44 1006.80 "Анатолий Кулаков" Дело в том, что для таких стандартных примитивных коллекций, как dictionary, collection, array, у них count уже сохранен в локальном поле, и сложность операции count не равно ноль, это от единицы.
1006.80 1008.72 "Анатолий Кулаков" Никаких проблем с этим нет абсолютно.
1008.72 1016.68 "Анатолий Кулаков" Если же вы вызываете функцию any, линковый метод расширения, то на самом деле внутри происходят довольно-таки страшные вещи.
1016.68 1021.28 "Анатолий Кулаков" Там, во-первых, аллокетится энумератор, а во-вторых, диспатчится два интерфейсных метода.
1021.28 1026.36 "Анатолий Кулаков" То есть, эта функция просто-напросто забирает из коллекции энумератор и вызывает один раз moveNext.
1026.36 1030.52 "Анатолий Кулаков" Если moveNext прошел, значит any true, то есть какой-то элемент там есть.
1030.52 1032.88 "Анатолий Кулаков" Если moveNext не прошел, значит элементов там нет.
1032.88 1038.44 "Анатолий Кулаков" И поэтому многие игнорировали рекомендации Рослина о том, что нужно заменять count на any.
1038.44 1039.88 "Игорь Лабутин" И что теперь?
1039.88 1042.48 "Игорь Лабутин" Рослин переписали и стали рекомендовать обратное?
1042.48 1043.48 "Анатолий Кулаков" Нет, нет.
1043.48 1045.48 "Анатолий Кулаков" Они сделали any намного умнее.
1045.48 1065.84 "Анатолий Кулаков" Теперь any точно так же, как и настоящий count, он старается проверить, если у нас подлежащая коллекция имплементирует интерфейс iCollection или еще какой-то интерфейс, у которого есть уже готовый count, у которого есть готовая длина, он просто-напросто кастит эту коллекцию к этому count и эффект точно такой же абсолютно, как будто вы вызвали бы count.
1065.84 1070.48 "Анатолий Кулаков" Но any нам смотрится намного семантичнее, намного правильнее, намного читабельнее.
1070.48 1075.80 "Анатолий Кулаков" Поэтому теперь этими рекомендациями можно будет не пренебрегать, что довольно-таки полезно.
1075.80 1082.32 "Игорь Лабутин" Да, и отдельно хочется порекомендовать почитать ищи, где обсуждалась необходимость введения такой штуки.
1082.32 1098.68 "Игорь Лабутин" Там довольно неплохое рассуждение на тему трейд-оффов по производительности, потому что очевидно, что добавление, как мы сказали, any уже делает allocate энумератора плюс два интерфейсных вызова, а тут мы добавляем в него еще кода.
1098.68 1107.96 "Игорь Лабутин" Но, как выяснилось, это полезный трейд-офф, и обсуждение на тему того, будем мы это делать или не будем, весьма занимательное.
1107.96 1112.04 "Игорь Лабутин" Почитайте, если интересно, как команда это делает.
1112.04 1113.92 "Игорь Лабутин" Дальше погнали про сети.
1113.92 1118.16 "Игорь Лабутин" С сетями у нас, как всегда, есть актуальная тема, HTTP/2.
1118.16 1124.44 "Игорь Лабутин" Ну, там просто все потихонечку причесывают, и каких-то прорывных, по-моему, штук нет.
1124.44 1129.80 "Игорь Лабутин" Но есть интересные штуки в Linux, то есть там сделали нормальную поддержку сокетов на Linux.
1129.80 1137.16 "Игорь Лабутин" В Linux нет понятия completion port, в Linux приходится ждать немножко по-другому, что данные в сокет пришли.
1137.16 1149.28 "Игорь Лабутин" И в наивной реализации нужно было бы на каждый сокет держать по потоку, который бы делал вызов poll, ну или e-poll, и который вернется в тот момент, когда такие придут данные.
1149.28 1154.64 "Игорь Лабутин" Это не очень здорово, это перерасход потоков, поэтому команда Microsoft сделала забавное решение.
1154.64 1170.52 "Игорь Лабутин" Они ждут, появится ли хоть на каком-нибудь сокете что-нибудь в одном единственном потоке, а как только что появляется, во внутреннюю очередь, по-моему, чуть ли не concurrent queue практически один в один, кладут, собственно, кусочек работы, чтобы уже потом на thread pool ее выполнять.
1170.52 1175.60 "Игорь Лабутин" Естественно, есть накладные расходы на синхронизацию, но зато не тратится огромное количество потоков.
1175.60 1193.76 "Игорь Лабутин" При этом есть вариант эту работу пытаться делать прямо inline внутри потока, но это нужно тоже включать отдельное переменное окружение, потому что это достаточно налагает много ограничений на то, как долго и как много вы можете работать там и какие вызовы вы можете совершать.
1193.76 1197.32 "Игорь Лабутин" Например, вы не можете подождать какого-нибудь другого сокета, потому что это будет дедлок.
1197.32 1202.68 "Игорь Лабутин" В общем, нововведений вокруг Linux сокетов довольно много, деталей реализации довольно много.
1202.68 1205.88 "Игорь Лабутин" Читайте статью и там будет много чего интересного.
1205.88 1209.44 "Игорь Лабутин" Если мы говорим про сети, то, естественно, нельзя не сказать про JSON.
1209.44 1233.72 "Игорь Лабутин" Обработка JSON сейчас трендово нужно делать System Text JSON, хотя, как мы говорили в одном из прошлых выпусков Microsoft, хоть и выпустила хорошую статью, как мигрировать с Newtonsoft на System Text JSON, и явно говорит, что в целом это делать не совсем обязательно и они не полностью совместимы, поэтому если пользуетесь Newtonsoft JSON, то продолжайте пользоваться.
1233.72 1245.12 "Игорь Лабутин" Но если вы мигрировали на System Text JSON или просто им пользуетесь в каком-то новом проекте, там завезли очередное количество импрувментов, чуть быстрее реализуются коллекции, побыстрее реализуются словари.
1245.12 1248.00 "Игорь Лабутин" В общем, еще немножко улучшают туда-сюда.
1248.00 1260.76 "Игорь Лабутин" В общем, изменений много, как сказал Толя в начале, там порядка 250 pull-requests, которые только вошли в статью, а их на самом деле, конечно же, в репозитории еще больше, так что рекомендую начать с этой статьи.
1260.76 1270.44 "Игорь Лабутин" И если что-то заинтересовало конкретно, ходите по issues, по ссылкам друг на друга и смотрите, что конкретно менялось в разных уголках репозитория.
1270.44 1276.44 "Игорь Лабутин" На этом я думаю, что с performance, с improvement в .NET 5 мы закончим и пойдем дальше.
1276.44 1285.64 "Анатолий Кулаков" Билд прокатился два выпуска назад, но его анонсы, пара продолжает нас догонять.
1285.64 1291.88 "Анатолий Кулаков" В прошлом выпуске мы рассмотрели TIE, а в этом выпуске мы посмотрим на то, что же такое Visual Studio Codespace.
1291.88 1299.60 "Анатолий Кулаков" Тоже анонсировано на Build'е, новая платформа от Microsoft, которая по сути делает вам удаленную EDE.
1299.60 1300.88 "Анатолий Кулаков" Зачем вообще это может быть нужно?
1300.88 1303.96 "Анатолий Кулаков" Игорь, ты представляешь вообще, зачем разработчику удаленную EDE?
1303.96 1317.36 "Игорь Лабутин" У меня есть один сценарий, где мне может быть пригодится удаленную EDE, это когда мне нужно работать в каком-то, скажем так, в какой-то сети, откуда я не могу, например, забрать исходники.
1317.36 1320.76 "Игорь Лабутин" То есть бывают заказчики, которые говорят, что исходники должны быть только у нас.
1320.76 1325.76 "Игорь Лабутин" Ну вот, возможно, каким-то образом эта штука сможет помочь.
1325.76 1328.84 "Игорь Лабутин" Сейчас мы просто используем ремонт в сеть заказчика и там с ними работаем.
1328.84 1333.20 "Игорь Лабутин" То есть поможет ли такая штука вот такому сценарию?
1333.20 1340.00 "Анатолий Кулаков" Ну, если вы не будете делать быстренько принтскрин со всех исходников, которые вы видите, то, наверное, поможет.
1340.00 1344.40 "Анатолий Кулаков" Но, скорее всего, Microsoft более прозаичен, потому что твой сценарий слишком узкий.
1344.40 1346.88 "Анатолий Кулаков" Ему нужно что-то большее, что-то глобальное.
1346.88 1348.60 "Анатолий Кулаков" Давай посмотрим поподробнее.
1348.60 1352.04 "Анатолий Кулаков" Итак, Codespaces.
1352.04 1355.48 "Анатолий Кулаков" Раньше вы могли встречать под названием Visual Studio Online.
1355.48 1358.68 "Анатолий Кулаков" Это когда Visual Studio могла редактировать код прямо у вас в браузере.
1358.68 1362.64 "Анатолий Кулаков" Вот она теперь объединилась вместе с проектом Codespaces.
1362.64 1367.64 "Анатолий Кулаков" Также этот проект связан с GitHub Codespaces, который тоже принадлежит сейчас Microsoft.
1367.64 1371.60 "Анатолий Кулаков" И, естественно, что они захотели сделать в нем тесную интеграцию.
1371.60 1375.40 "Анатолий Кулаков" Это все сейчас пока в превью и не у каждого будет доступно.
1375.40 1390.44 "Анатолий Кулаков" Но, если вам вдруг эта функция доступна, то есть вы попросили у GitHub, например, специальное разрешение, Microsoft с этим согласился, то вы можете прямо на GitHub в репозитории нажать кнопочку "Не клонировать репозиторий", а "Редактировать репозиторий".
1390.44 1398.52 "Анатолий Кулаков" И в этот же момент у вас откроется Visual Studio код, в который будет локально склонирован тот репозиторий, на котором вы нажали эту кнопочку.
1398.52 1407.36 "Анатолий Кулаков" Под вас будет настроена машина, под вас будут настроены все ваши любимые конфиги, любимые плагины, шрифты и даже тема Visual Studio.
1407.36 1421.14 "Анатолий Кулаков" То есть все ваше привычное окружение откроется в браузере и там можно будет проект спокойно редактировать, его можно будет отлаживать и можно будет запускать и делать все то, что вы привыкли делать на своей локальной машине.
1421.14 1431.00 "Анатолий Кулаков" Visual Studio код в этом подходе запускается под Linux и работает практически со всем функционалом, в котором вы ожидали бы ее увидеть.
1431.00 1435.12 "Анатолий Кулаков" В том числе с Live Sharing, с дебаггером, как я сказал, со всеми своими плагинами.
1435.12 1440.64 "Анатолий Кулаков" Все, что вы сделаете, сохранить там любые настройки, любые файлы, все это сохранится, никуда не потеряется.
1440.64 1444.20 "Анатолий Кулаков" Естественно, отсюда же вы можете сразу зачекинить все ваши изменения в GitHub.
1444.20 1460.72 "Анатолий Кулаков" Если вы хотите, чтобы ваше окружение в таком, в Codespaces работало как-то по-особому, то в репозиторий можно добавить файлик "devcontainer.json" и в нем написать различные требования к СДА окружения и различные способы запуска.
1460.72 1467.40 "Анатолий Кулаков" Также Codespaces дает возможность работать не только в браузере, но и в настоящей Visual Studio в код.
1467.40 1475.00 "Анатолий Кулаков" Для этого вам нужно подключить специальный плагин и работает этот плагин поверх Remote Containers, если кто-то сталкивался.
1475.00 1484.64 "Анатолий Кулаков" Если нет, то в Remote Containers это уже был такой первый шаг для того, чтобы среду разработки поместить в некий контейнер, в некую абстрактную песочницу.
1484.64 1491.76 "Анатолий Кулаков" И в этой песочнице вы уже можете, например, устанавливать пакеты, компилировать, запускать, тестировать и все это никак не скажется на вашем компьютере.
1491.76 1499.56 "Анатолий Кулаков" Для меня это вообще рай, потому что я брезгу ставить на свой компьютер Node.js и прочие глупости, но, к сожалению, для многих проектов они необходимы.
1499.56 1506.60 "Анатолий Кулаков" Поэтому я запускаю это все в тест-контейнере и типа никто не видит, на моем компьютере никогда этой лажи не стояло и я ничего такого не делал.
1506.60 1507.68 "Анатолий Кулаков" Просто красота.
1507.68 1511.44 "Анатолий Кулаков" Также Codespaces работает и под большой Visual Studio.
1511.44 1523.84 "Анатолий Кулаков" У многих может стать вопрос, а как отлаживать, например, с локального порта, потому что очень много есть специальных команд, которые, допустим, работают только на localhost и никак по-другому их на удаленном хосте не отладить.
1523.84 1529.40 "Анатолий Кулаков" Например, очень часто делают программы, которые открывают админку, если к ней заходят по localhost.
1529.40 1535.32 "Анатолий Кулаков" И к этой админке невозможно доступиться, если вдруг вы заходите по другому IP-адресу.
1535.32 1537.40 "Анатолий Кулаков" Здесь тоже все элементарно и просто.
1537.40 1540.48 "Анатолий Кулаков" У Visual Studio уже давно есть такой интересный режим, как Live Sharing.
1540.48 1553.24 "Анатолий Кулаков" И с помощью Live Sharing вам открывается порт, прямо локальный порт на вашем компьютере и он прозрачно редиректится на удаленную машину, которая запускается где-то у вас в облаке на эту удаленную IDE и оплатка абсолютно прозрачная.
1553.24 1556.32 "Анатолий Кулаков" Пару слов про Live Sharing, если кто-то не сталкивался.
1556.32 1559.80 "Анатолий Кулаков" Это возможность в Visual Studio совместно редактировать код.
1559.80 1564.04 "Анатолий Кулаков" То есть вы можете подключить несколько человек и у вас будет несколько курсоров Visual Studio.
1564.04 1569.88 "Анатолий Кулаков" Вы можете совместно печатать, совместно запускать тесты, совместно делать код-ревью и так далее.
1569.88 1582.16 "Анатолий Кулаков" То есть это шикарное средство для экстрим программинг, особенно если вы работаете удаленно и у вас нет возможности сесть друг к другу на коленки и подбежать программу прямо в офисе.
1582.16 1586.88 "Анатолий Кулаков" Вот, этот же механизм применяется для того, чтобы взаимодействовать в Visual Studio с удаленной машиной.
1586.88 1593.44 "Анатолий Кулаков" Эта удаленная машина, эта удаленная IDE запускается естественно на серверах Azure.
1593.44 1598.72 "Анатолий Кулаков" Чтобы, чтобы смочь это сделать, вам естественно нужен тариф на Azure.
1598.72 1602.08 "Анатолий Кулаков" И тарифы сейчас, нужно признать, довольно-таки дорогие.
1602.08 1604.04 "Анатолий Кулаков" И бесплатных тарифов нет.
1604.04 1606.72 "Анатолий Кулаков" То есть у вас должна быть Azure подписка.
1606.72 1610.48 "Анатолий Кулаков" Вы должны выбрать, какую машину вы хотите использовать под ваши проекты.
1610.48 1614.92 "Анатолий Кулаков" Естественно, чем тяжелее, чем мощнее машина, тем дороже вы за нее будете платить.
1614.92 1619.84 "Анатолий Кулаков" Чем машина легче, тем это вам обойдется дешевле.
1619.84 1625.96 "Анатолий Кулаков" Поэтому в зависимости от размера, от качества проекта, столько вы напрямую будете платить теперь за редактирование кода.
1625.96 1627.84 "Анатолий Кулаков" Статус проекта сейчас в Private Preview.
1627.84 1632.68 "Анатолий Кулаков" То есть он есть, он работает, но пускают к нему не всем, пускают только по разрешениям.
1632.68 1634.64 "Анатолий Кулаков" Выглядит довольно многообещающе.
1634.64 1644.00 "Анатолий Кулаков" То есть если раньше мы с вами переносили из наших интерпрайс стоек весь наш софт в облака, то теперь мы можем переносить прямо IDE разработчиков в облака.
1644.00 1653.20 "Анатолий Кулаков" И довольно удобная конструкция, когда ты можешь стабильно загрузить свой конфиг, стабильно загрузить свои плагины, настроенную среду окружения, независимо от того, где ты сейчас находишься.
1653.20 1658.28 "Анатолий Кулаков" С браузера в планшете, или с полноценного ноутбука, или с большого компьютера.
1658.28 1662.00 "Анатолий Кулаков" Не важно, у тебя вся твоя среда рабочая будет всегда под рукой.
1662.00 1663.00 "Анатолий Кулаков" Удобная штука.
1663.00 1664.48 "Игорь Лабутин" Да, у меня есть только один вопрос.
1664.48 1669.92 "Игорь Лабутин" Это все прекрасно, когда мы говорим о разработке или отладке какой-то, достаточно standalone приложение.
1669.92 1681.04 "Игорь Лабутин" Но что если моему приложению нужна база данных, какой-нибудь еще сторонний сервис, который не в интернете, а допустим, поднят где-то, или я поднимаю его локально.
1681.04 1685.12 "Игорь Лабутин" То есть как такие штуки, все эти зависимости туда тянутся?
1685.12 1687.24 "Анатолий Кулаков" Это можно сделать с помощью девконтейнеров.
1687.24 1693.28 "Анатолий Кулаков" То есть желательно, чтобы твоя база данных или сторонние штуки были где-то в докере, распространялись.
1693.28 1703.00 "Анатолий Кулаков" И твой проект, после того, как ты запустишь его удаленно, он сам прозрачно подкачает все эти докер-контейнеры, запустит их на нужных портах и соединит с твоим приложением.
1703.00 1714.48 "Анатолий Кулаков" Ну или же воспользоваться функцией порт-форвардинга с помощью лайв-шеринга, которому ты задашь адресы твоих машин, и он тебе прозрачно заредиректит, куда тебе нужно.
1714.48 1716.56 "Анатолий Кулаков" Также есть интересная тема.
1716.56 1729.60 "Анатолий Кулаков" Ты можешь подключить локально любую машину и сказать ее, что я не хочу теперь машину на e-джери напрягать, вот у меня есть мой комп, вот давай на нем запускай весь код, компили на нем, я буду его использовать в качестве своей удаленной IDE.
1729.60 1742.76 "Анатолий Кулаков" Такое тоже возможно, и это можно делать, и соответственно сделать такое маленькое гибридное облако, когда у тебя половину машин будут в ажуре, а половину машин с твоей IDE и коннектом к локальной сети будут там, где ты укажешь.
1742.76 1743.76 "Игорь Лабутин" Понял.
1743.76 1760.40 "Игорь Лабутин" Ну действительно, может быть, это удобнее, чем таскать с собой ноутбук, который может быть не столь мощный, на котором все настроено, а таскать какой-нибудь легкий простенький ноутбучек, с которого ты можешь зайти в веб или запустить в Visual Studio Code и получить мощное окружение где-то в облаке.
1760.40 1770.04 "Анатолий Кулаков" Да, будем надеяться, что тарифы только станут менее прожорливыми и в будущем Microsoft как-нибудь сможет сделать этот сервис более доступным для обычных разработчиков.
1770.04 1773.16 "Игорь Лабутин" Окей.
1773.16 1785.24 "Игорь Лабутин" Тем не менее, несмотря на все стремление в облаках, Microsoft улучшает и локальные тулзы тоже, то есть, в частности, работу с Git в новой Visual Studio, притащили новенькую.
1785.24 1804.40 "Игорь Лабутин" И это такое, с одной стороны, вроде как минорный апдейт, с другой стороны, ощущение, что Microsoft пытается переделать практически полностью Git UI у себя в Visual Studio, чтобы исчезла необходимость использовать какие-то сторонние тулзы, если вы ими пользуетесь, типа там GitKraken, либо GitExtensions, либо еще кто-нибудь.
1804.40 1808.64 "Игорь Лабутин" То есть, они завезли вроде как нормальный мерш, теперь говорят, по крайней мере.
1808.64 1816.64 "Игорь Лабутин" Новое окошечко с репозиториями, где можно легко переключаться между бранчами, в смысле с просмотром истории бранчей.
1816.64 1822.16 "Игорь Лабутин" И какое-то количество настройки, да, теперь можно тоже настроить прямо из Visual Studio.
1822.16 1830.88 "Игорь Лабутин" В общем, по чуть-чуть везде попробуйте, это включается настройкой в превью, правда пока только версии Visual Studio.
1830.88 1835.68 "Игорь Лабутин" Возможно, действительно вы сможете отказаться от какого-то стороннего Git тула, если только вы не консольный
1835.68 1845.44 "Анатолий Кулаков" гуру. Недавно открыл для себя интересный сайтец, даже не сайт, а маленькую, одну страничку всего-навсего, которая называется "Карта знаний .NET Web Программиста".
1845.44 1860.88 "Анатолий Кулаков" Довольно интересный ресурс, потому что часто задают такие вопросы, с чего начать, как изучить, как подтянуть ту или иную тему, что нужно знать и прочие вещи, которые очень полезно знать начинающим разработчикам.
1860.88 1865.96 "Анатолий Кулаков" И куда податься, что сделать, такого консистентного, одного обширного, большого ресурса его не было.
1865.96 1868.80 "Анатолий Кулаков" И вот теперь, наверное, смело можно порекомендовать вот этот ресурс.
1868.80 1870.80 "Анатолий Кулаков" Что же он из себя представляет?
1870.80 1878.84 "Анатолий Кулаков" Это действительно такая карта, то есть большая-большая табличка, в которой все люди поделены на 4 уровня, начиная от стажера и заканчивая сеньором.
1878.84 1881.92 "Анатолий Кулаков" Соответственно, стажер, сеньор, мидл, джиньор.
1881.92 1891.44 "Анатолий Кулаков" И в этой карте заданы темы, которые, по мнению авторов, должен знать тот или иной уровень, и глубину этих тем, насколько он должен их знать.
1891.44 1896.04 "Анатолий Кулаков" Но это не только какие-то там теоретические наставления.
1896.04 1898.64 "Анатолий Кулаков" Это еще и куча очень полезных ссылок.
1898.64 1901.88 "Анатолий Кулаков" То есть по каждой теме есть ссылка, где можно почитать.
1901.88 1909.16 "Анатолий Кулаков" Или ссылка на книгу, или ссылка на микрософтскую документацию, или ссылка на какие-то другие сторонние ресурсы, которые можно отрыть в интернете.
1909.16 1916.28 "Анатолий Кулаков" Поэтому по каждой секции, по каждому уровню вы можете найти соответственную ссылку.
1916.28 1918.84 "Анатолий Кулаков" И дано очень-очень много тем.
1918.84 1920.40 "Анатолий Кулаков" То есть дана разбивка по темам.
1920.40 1926.04 "Анатолий Кулаков" Такие как языки, платформа, DDD, ООП, сеть, базы данных и так далее.
1926.04 1928.16 "Анатолий Кулаков" То есть очень-очень много разбивок.
1928.16 1931.56 "Анатолий Кулаков" Соответственно, для каждой секции есть ссылки.
1931.56 1934.36 "Анатолий Кулаков" И после каждой секции есть контрольные вопросы.
1934.36 1938.92 "Анатолий Кулаков" И эти контрольные вопросы как раз таки и закрывают главную боль начинающих программистов.
1938.92 1946.44 "Анатолий Кулаков" Вроде того, а что меня будут спрашивать на собеседовании, как подготовиться к собеседованию, и что там отвечать.
1946.44 1951.80 "Анатолий Кулаков" Вот эти вопросы помогут вам самому себя проверить, насколько вы разбираетесь в теме.
1951.80 1959.76 "Анатолий Кулаков" И если вы вдруг на какие-то из них не нашли ответов, то смело можно проследовать по ссылкам и там набраться уму и разуму.
1959.76 1966.44 "Игорь Лабутин" Да, надо при этом сказать, что ссылки ведут либо на какие-то книжки, то есть их вам возможно придется купить.
1966.44 1973.52 "Игорь Лабутин" Но основная масса ссылок это документация Microsoft и Hubr, где как бы по-русски все будет нормально написано.
1973.52 1993.96 "Анатолий Кулаков" Еще хочется подчеркнуть, что монументальность этой статьи, то есть это реально огромный труд, здесь собраны просто, я не знаю, наверное сотни различных секций, тем, все они промаркированы, ко всем из них прошиты ссылки, ну то есть это очень-очень хороший ресурс для того, чтобы начать или систематизировать свои знания.
1993.96 1997.68 "Игорь Лабутин" Да, систематизировать знания это всегда полезно, даже если вы синер-программист.
1997.68 2014.72 "Игорь Лабутин" И кроме того, даже если вы синер в какой-то одной области, возможно вот Джонниер где-то другой и будет интересно, если например вы хотите погрузиться в мир фронт-энда, будучи синер-бэкэнд-программистом, там тоже есть ссылки на эту тему и пойти почитать и покопать, чтобы получить какие-то базовые знания, вполне полезно.
2014.72 2017.76 "Анатолий Кулаков" И секцию полезных ресурсов продолжает JetBrains.
2017.76 2025.92 "Анатолий Кулаков" JetBrains запустил новый портал, который называется .NET Guide Tutorials Tips Tricks for .NET Writer and ReSharper.
2025.92 2033.28 "Анатолий Кулаков" Соответственно, как вы скорее всего поняли из названия, это специализированный портал JetBrains, в котором он публикует видеоролики.
2033.28 2042.40 "Анатолий Кулаков" Это могут быть маленькие ролики со специальными хаками или же большие полноценные лекции, в которых JetBrains рассказывает про свои продукты.
2042.40 2047.44 "Анатолий Кулаков" Но там рассказывается не только про их продукты, иначе это было бы слишком узко и слишком неинтересно.
2047.44 2053.00 "Анатолий Кулаков" Естественно, они пытаются охватить намного больше, но делая это на своих инструментах.
2053.00 2055.24 "Анатолий Кулаков" Соответственно, можно убить сразу двух зайцев.
2055.24 2062.96 "Анатолий Кулаков" Во-первых, вы досконально изучите инструменты JetBrains, что на практике дает вам офигенный прирост в перформансе.
2062.96 2071.88 "Анатолий Кулаков" А во-вторых, вы можете познакомиться со стандартными темами, например, с такими как ASP.NET Core, профайлинг, дебаггинг и так далее.
2071.88 2076.48 "Анатолий Кулаков" Соответственно, вы прокачаетесь и в .NET, и прокачаетесь в разработке, и прокачаетесь в инструментарии.
2076.48 2078.96 "Анатолий Кулаков" То есть, с этой стороны довольно хороший ресурс.
2078.96 2093.44 "Анатолий Кулаков" Там не только маленькие типсы, там можно встретить, например, видосики с JetBrains Online Days, которые мы обсуждали несколько выпусков назад, и, соответственно, посмотреть уже хорошие полноценные лекции от гуру с мировыми именами.
2093.44 2106.80 "Анатолий Кулаков" Среди авторов, которые постоянно наполняют контент этого ресурса, Matheus Koch, Martin Belavue, Matt Ellis и некоторые другие популяризаторы .NET и адвокаты JetBrains.
2106.80 2115.56 "Игорь Лабутин" Продолжая тему JetBrains, я видел, что там они обновили политику про лицензии вокруг ReSharper, Rider и чего-то такого.
2115.56 2118.00 "Игорь Лабутин" Можешь что-нибудь подробнее рассказать про это?
2118.00 2120.84 "Анатолий Кулаков" Да, JetBrains упростил лицензии.
2120.84 2125.96 "Анатолий Кулаков" У них раньше было немножко больше вариантов, то есть, что вы можете купить, если хотите программировать на .NET.
2125.96 2128.68 "Анатолий Кулаков" Сейчас все это было упрощено и понижены цены.
2128.68 2130.60 "Анатолий Кулаков" По порядочку, упрощение.
2130.60 2132.56 "Анатолий Кулаков" Сейчас осталось всего-навсего три типа лицензий.
2132.56 2134.60 "Анатолий Кулаков" Первая называется ReSharper Subscription.
2134.60 2140.24 "Анатолий Кулаков" Это лицензия, которая включает в себя ReSharper, плагин к Visual Studio и ReSharper C++.
2140.24 2143.68 "Анатолий Кулаков" То есть, они теперь все распространяются под одной лицензией.
2143.68 2146.08 "Анатолий Кулаков" Вторая лицензия - это Rider Subscription.
2146.08 2156.00 "Анатолий Кулаков" По ней вы получаете только Rider, но внутри Rider, соответственно, и работа с Unity, и работа с Samarin, и с Blazor, и прочее, прочее, прочее.
2156.00 2161.80 "Анатолий Кулаков" И самая последняя, третья, самая мощная лицензия, которая называется .NET Ultimate Subscription.
2161.80 2163.88 "Анатолий Кулаков" По этой лицензии вы получаете абсолютно все.
2163.88 2171.52 "Анатолий Кулаков" И ReSharper, и Rider, и тулзы для дебаггинга, .trace, .memory для трассировок, .cover для покрытия кода.
2171.52 2175.28 "Анатолий Кулаков" Абсолютно все, что только есть, соответственно, .NET.
2175.28 2187.52 "Анатолий Кулаков" Но это было бы, наверное, не так интересно, как информация, что вместе с понижением цен и переводом на новую систему лицензирования, у нас появились внезапные плюшки.
2187.52 2194.12 "Анатолий Кулаков" Такие как, если вы владели лицензией ReSharper Ultimate, то теперь она автоматически переведется в .NET Ultimate.
2194.12 2198.44 "Анатолий Кулаков" Это значит, что вместе с обычным ReSharper вам теперь будет доступен бесплатно Rider.
2198.44 2205.24 "Анатолий Кулаков" Если же у вас раньше была просто ReSharper Subscription, то теперь вы бесплатно к ReSharper еще получите ReSharper C++.
2205.24 2217.08 "Анатолий Кулаков" Может быть, эта связка не очень интересна, а вот в обратную сторону, то есть все те, кто раньше пользовались ReSharper C++, теперь бесплатно смогут перейти на C#, потому что они получат в довесок ReSharper.
2217.08 2218.76 "Игорь Лабутин" Ну, звучит приятно.
2218.76 2227.48 "Игорь Лабутин" То есть, действительно, кажется изменение логичным и посмотрим, как это повлияет на продажу JetBrains.
2227.48 2231.60 "Игорь Лабутин" Мы, конечно, этого не увидим, но, наверное, JetBrains от этого как-то должно стать легче.
2231.60 2237.00 "Анатолий Кулаков" Лицензии трансформируются вместе с релизом 2020.2.
2237.00 2241.48 "Анатолий Кулаков" Это примерно произойдет где-то в первых неделях августа.
2241.48 2244.16 "Анатолий Кулаков" Поэтому осталось ждать довольно недолго.
2244.16 2255.80 "Игорь Лабутин" Хорошо, давай, наверное, закончим про JetBrains, Rider и прочие темы вокруг обучения и пойдем поговорим про что-нибудь более интересное и технологичное.
2255.80 2263.68 "Анатолий Кулаков" Погоди, для более технологичного меня тут недавно стукнули по голове GitHub и сказали, что теперь мой код заморожен.
2263.68 2266.24 "Анатолий Кулаков" Хотелось бы немножко подробнее эту тему осветить.
2266.24 2271.32 "Анатолий Кулаков" Что же такое сделалось, произошло с моими репозиториями, с моим кодом?
2271.32 2277.68 "Анатолий Кулаков" Оказывается, GitHub без моего спроса взял и включил меня в свой проект, который называется GitHub Arctic World Program.
2277.68 2279.40 "Анатолий Кулаков" Слышал когда-нибудь о таком?
2279.40 2287.60 "Игорь Лабутин" Ну да, что-то слышал, что это Arctic, пролет и заморозка кода для наших будущих потомков, вдруг они не смогут собрать какой-нибудь проектик.
2287.60 2289.40 "Анатолий Кулаков" Вот типа того.
2289.40 2301.40 "Анатолий Кулаков" Подробнее, GitHub вместе с Microsoft Research, вместе с интернет-архивом и Стэнфордской библиотекой и многими-многими другими большими пупками решили сделать такую экстравагантную вещь.
2301.40 2307.08 "Анатолий Кулаков" Они решили создать архив, значимых для человека трудов, хранящийся как минимум тысячу лет.
2307.08 2311.40 "Анатолий Кулаков" Они для этого используют множество всяких подходов, множество всяких технологий.
2311.40 2315.32 "Анатолий Кулаков" Вообще GitHub довольно хорошо хранит ваши данные.
2315.32 2325.40 "Анатолий Кулаков" Во-первых, при каждом pull-request, при каждом push весь ваш код распространяется на множество дата-центров, то есть он реплицируется на множество гитхабовских дата-центров.
2325.40 2333.96 "Анатолий Кулаков" После него еще есть какие-то снапшоты, после этого еще есть интернет-архив, который обязательно дублирует весь ваш код и так далее, так далее.
2333.96 2337.76 "Анатолий Кулаков" То есть там около 10 уровней того, где дублируется ваш код.
2337.76 2342.00 "Анатолий Кулаков" Это разные сервисы, разные страны, разные регионы, и потерять его довольно-таки сложно.
2342.00 2350.28 "Анатолий Кулаков" И вот одним из самых конечных пунктов того, как гитхабовцы пытаются спасти ваш код, является программа Arctic World Archive.
2350.28 2362.28 "Анатолий Кулаков" 2 февраля 2020 года GitHub сделал слепок каждого активного публичного репозитория на своем ресурсе, который будет храниться в хранилище арктического кода.
2362.28 2366.84 "Анатолий Кулаков" Эти данные будут храниться на пленочных катушках для очень длительного хранения.
2366.84 2370.84 "Анатолий Кулаков" По тестам ISO такая катушка может храниться 500 лет.
2370.84 2375.68 "Анатолий Кулаков" По каким-то другим независимым тестам реальный размер может быть в 2 раза дольше.
2375.68 2383.48 "Анатолий Кулаков" В результате у них получился 21 терабайт кода, который они засунули в 250 метров глубины вечной мерзлоте, где-то там далеко-далеко.
2383.48 2392.44 "Анатолий Кулаков" Все это они закодировали на специальную пленку, которая больше всего визуально похожа на какие-то QR-коды, и естественно скомпрессировали.
2392.44 2406.48 "Анатолий Кулаков" Это то, что они сделали сейчас, и соответственно тех разработчиков, код которых попал в эти репозитории, вы теперь можете определить по специальному бэджу в их профиле, на котором написано ArcticCodeVaultContributor.
2406.48 2409.04 "Анатолий Кулаков" Но это еще не все.
2409.04 2416.12 "Анатолий Кулаков" Сейчас вместе с Microsoft Research GitHub разрабатывает еще один проект, который называется Silica.
2416.12 2433.44 "Анатолий Кулаков" Это архивная программа, которая в конечном счете нацелена на то, чтобы заархивировать все активные публичные репозитории и сохранить их более чем на 10 тысяч лет, записывая их на пластины из кварцевого стекла с помощью фемтосекундного лазера, что бы это, мать его, так ни означало.
2433.44 2436.08 "Анатолий Кулаков" Но вы сами вдумайтесь в эти цифры.
2436.08 2437.08 "Анатолий Кулаков" 10 тысяч лет.
2437.08 2441.52 "Анатолий Кулаков" То есть вы представляете, это намного больше, чем у нас сейчас Рождество Христово.
2441.52 2451.60 "Анатолий Кулаков" То есть что будет, какие языки существовать, какая письменность, какие цивилизации, какие войны пройдут, какие бомбы взорвутся, вообще неизвестно, что будет через эти года.
2451.60 2463.60 "Анатолий Кулаков" Поэтому GitHub и компаньоны отводят очень-очень много внимания для того, чтобы дать нашим будущим потомкам каким-то образом понять, а что же собственно они закодировали в этих дурацких квадратиках и записали на пленочку.
2463.60 2467.36 "Анатолий Кулаков" Потому что тысячи-тысячи лет - это реально много.
2467.36 2485.64 "Анатолий Кулаков" Они собрали антропологов, археологов, историков, лингвистов, специалистов по архивам, специалистов по данным и прочих футуристов и попросили их всех вместе придумать, каким же образом нашим потомкам донести ту мысль, что тут хранится и как этим воспользоваться.
2485.64 2497.92 "Анатолий Кулаков" Они разработали специальные алгоритмы, специальные способы считывания, они сделали специальные деревья для того, чтобы как-то систематизировать основной индекс того, что здесь написано.
2497.92 2506.64 "Анатолий Кулаков" И в виде картинок, стенограмм, кодов и прочего пытаются дать потомкам подсказку о том, как же всем этим кодом воспользоваться.
2506.64 2511.92 "Анатолий Кулаков" Как же восстановить все эти архивы, если они были для человечества потерянными.
2511.92 2529.84 "Анатолий Кулаков" Вместе с кодом, естественно, хранятся не только наши пул реквесты и матерные комментарии к коммитам, но там еще хранятся настоящие произведения человеческого искусства, картины, фотографии статуй, а также семена растений, которые очень важны для нашей планеты и много-много чего еще интересного.
2529.84 2536.96 "Анатолий Кулаков" Если вам будет любопытно прочитать подробности по эту программу, то ищите ссылки под нашими выпусками.
2536.96 2541.68 "Игорь Лабутин" Да, когда люди заходят о бэкапах, важно сообразить, как же их ресторить.
2541.68 2547.36 "Игорь Лабутин" Интересно, будут ли они тестировать какой-нибудь рестор этого добра и как вообще это все проверять.
2547.36 2549.00 "Анатолий Кулаков" Я думаю, обязательно будут.
2549.00 2554.24 "Анатолий Кулаков" Также они планируют замуровывать ваш код в арктические льды каждый год.
2554.24 2564.28 "Анатолий Кулаков" Поэтому, если вы в этом году не получили бейдж за контрибьют в гитхабовские проекты, у вас еще целый год для того, чтобы найти интересный проект и начать туда контрибьютить.
2564.28 2570.88 "Анатолий Кулаков" И в следующем году вы обязательно вольетесь в свартическую скалу в виде ваших пул реквестов.
2570.88 2573.00 "Игорь Лабутин" Прекрасно, вообще перспектива шикарная.
2573.00 2575.32 "Игорь Лабутин" Но давай все-таки к техническим немножко еще темам.
2575.32 2581.92 "Игорь Лабутин" Мы тут уже сколько-то говорим, но часть была про технику, часть про лицензирование и все остальное.
2581.92 2585.28 "Игорь Лабутин" Я хочу опять вернуться к технике.
2585.28 2596.88 "Игорь Лабутин" Пишли мы статью, статья на самом деле довольно старенькая, это января этого года, от Орана Эни, которого кто-то может знать как Айенда, CEO Hybernating Green, с которой делают RavenDB.
2596.88 2603.76 "Игорь Лабутин" Ну, в общем, Айенда, RavenDB, вполне, скорее всего, вам известные персонажи и продукты.
2603.76 2611.72 "Игорь Лабутин" И он написал блог-пост, в котором разбирает production case, где у них все дико тормозило.
2611.72 2618.32 "Игорь Лабутин" Когда я начал читать этот пост, было ощущение, что дико тормозило, это, наверное, все будет очень плохо.
2618.32 2631.52 "Игорь Лабутин" На самом деле, кейс был довольно-таки, с моей точки зрения, не то чтобы не важный, для их системы это очень важно, но не прям такой, чтобы прям по смортам, по смортам и большой критичный кейс.
2631.52 2632.88 "Игорь Лабутин" Ситуация была такая.
2632.88 2637.96 "Игорь Лабутин" Есть база RavenDB, она работает, работает много недель, без каких-либо проблем.
2637.96 2642.32 "Игорь Лабутин" И тут внезапно секунды на 3, 4, 5 замирает и ничего не делает.
2642.32 2644.36 "Игорь Лабутин" Потом снова работает много недель без каких-либо проблем.
2644.36 2656.32 "Игорь Лабутин" Казалось бы, ну что там, 5 секунд за много-много недель, тем не менее, это как бы важный кейс, а все плохо, в эти 5 секунд база перестает вообще хоть как-то откликаться и надо им вести гетти, что такое.
2656.32 2660.44 "Игорь Лабутин" И в блоге как раз и рассказано, как они все это искали.
2660.44 2662.48 "Игорь Лабутин" И статья, на самом деле, довольно интересная.
2662.48 2669.60 "Игорь Лабутин" Сначала они проверили, что с процессором, вводом-выводом, свопингом, никаких проблем нет, все тихо-мирно.
2669.60 2674.20 "Игорь Лабутин" Натуральный вывод любого дотнет-разработчика, ну конечно же, мне мешает garbage collector.
2674.20 2676.60 "Игорь Лабутин" Как бы кто еще может паузить мое приложение.
2676.60 2680.04 "Анатолий Кулаков" А как они это вообще воспроизвели, если это случается раз в несколько недель?
2680.04 2682.24 "Игорь Лабутин" Это проблема, они это не воспроизвели.
2682.24 2691.16 "Игорь Лабутин" То есть, пока как бы попытавшись все то же самое сделать на своих тестовых серверах или еще как-то, они это воспроизвести не смогли.
2691.16 2692.44 "Игорь Лабутин" Что они сделали?
2692.44 2700.68 "Игорь Лабутин" Они просто, ну, помониторили просто те сервера, на которых это происходило, поняли, что вроде с CPU, I/O и всем остальным никаких проблем нет.
2700.68 2711.12 "Игорь Лабутин" Опять же, у них есть мониторинг, то есть можно посмотреть конкретно в тот момент, когда те самые 5 секунд были зависания, что в CPU там не 100% и все такое прочее, и вроде как бы проблем нет.
2711.12 2715.28 "Игорь Лабутин" Дальше они сделали dump процесса, просто в прозвольный момент времени.
2715.28 2716.28 "Игорь Лабутин" Неважно где.
2716.28 2720.72 "Игорь Лабутин" Потому что поймать конкретно момент тормозов понятно, что сложно, или его ждать долго.
2720.72 2722.72 "Игорь Лабутин" Посмотрели на размер хипа.
2722.72 2724.72 "Игорь Лабутин" Хип оказался 8 гигабайт.
2724.72 2729.04 "Игорь Лабутин" Казалось бы, приличный хип, но при этом на машинке доступно 64 гигабайта.
2729.04 2744.20 "Игорь Лабутин" И поэтому это означает, что вроде как памяти огромное количество, и гарбусиколлектор не должен сильно тормозить, потому что, как правило, когда памяти много и никто другую память не использует, гарбусиколлектор дает процессору зайтись и спокойно аллокейтит, что там ему надо.
2744.20 2746.48 "Игорь Лабутин" Как-то вроде все норм.
2746.48 2747.80 "Игорь Лабутин" Посмотрели в dump.
2747.80 2754.48 "Игорь Лабутин" Если у вас есть dump, то одно из первых вещей, которые вы смотрите, а что вообще есть в памяти.
2754.48 2767.24 "Игорь Лабутин" И нашли в памяти, что из этих 8 гигабайт, 10%, то есть примерно 800 мегабайт, это занимают массивы каких-то волшебных типов linked slot volatile, которые находятся внутри класса thread local.
2767.24 2769.40 "Игорь Лабутин" Ну, наверное, что-то связано с thread local.
2769.40 2771.64 "Игорь Лабутин" Посмотрим, сколько занимают сами thread local.
2771.64 2774.12 "Игорь Лабутин" Сами thread local инстансы занимают около 2 мегабайт.
2774.12 2775.12 "Игорь Лабутин" Вроде немного.
2775.12 2777.24 "Игорь Лабутин" Но инстансов этих было 50 тысяч штук.
2777.24 2782.36 "Анатолий Кулаков" Игорь, а ты можешь немножко подробнее рассказать, а что это за thread local и это публичный класс?
2782.36 2783.36 "Анатолий Кулаков" Зачем они нужны?
2783.36 2785.64 "Игорь Лабутин" Да, thread local - это прекрасно публичный класс.
2785.64 2810.40 "Игорь Лабутин" Нужно это для того, чтобы если у вас есть какая-то переменная или поле класса, или что-то еще, ну, как правило, для полей класса, конечно же, используется, которым вы хотите, чтобы у одного инстанса класса, использующегося в разных потоках, это поле имело свое значение и не зависимо от других потоков, то используется этот класс thread local.
2810.40 2813.36 "Игорь Лабутин" Еще можно использовать thread static, я про это немножко потом поговорю.
2813.36 2818.48 "Игорь Лабутин" Но сейчас каноничный способ - это использовать thread local для этого.
2818.48 2819.88 "Игорь Лабутин" Он чуть более оптимален.
2819.88 2820.88 "Игорь Лабутин" Ха-ха.
2820.88 2821.88 "Игорь Лабутин" Как мы выясним чуть дальше.
2821.88 2829.32 "Игорь Лабутин" Ну и как раз-таки возвращаясь к проблеме, когда вы видите 50 тысяч штук thread local, это означает что?
2829.32 2830.80 "Игорь Лабутин" У нас где-то что-то течет.
2830.80 2835.52 "Игорь Лабутин" Ну, течет, не течет, непонятно, но у нас это значит, что где-то 50 тысяч потоков.
2835.52 2838.76 "Игорь Лабутин" И это может быть не очень здорово.
2838.76 2843.80 "Игорь Лабутин" Но на самом деле я, конечно, немножко утрирую, это не значит, что у нас 50 тысяч штук потоков.
2843.80 2849.92 "Игорь Лабутин" Потоков может быть у нас хоть два, но это значит, что действительно этих thread local мы по какому-то алгоритму создали много и они все живы.
2849.92 2858.68 "Игорь Лабутин" Вот, потоков, конечно же, не 50 тысяч, это один из мифов, которые иногда бывают, что каждый thread local - это там количество потоков создается.
2858.68 2859.68 "Игорь Лабутин" Нет.
2859.68 2866.60 "Игорь Лабутин" Сколько вы сами создали, то есть сколько у вас полей классов таким обозначено, сколько инстансов объектов таких создалось, и только у вас инстансов и будет thread local.
2866.60 2868.92 "Игорь Лабутин" Ну вот их было 50 тысяч штук.
2868.92 2870.48 "Игорь Лабутин" Пришлось разбираться, как это все устроено.
2870.48 2874.56 "Игорь Лабутин" В итоге оказалось, что устроено это очень интересно.
2874.56 2882.40 "Игорь Лабутин" Как я сказал, для того, чтобы хранить индивидуальные значения переменной для каждого потока, в дотнете есть такой способ как thread static.
2882.40 2888.28 "Игорь Лабутин" Если вы почитаете какие-то документации у Майкрософта, там будет сказано, что thread static использовать не надо, надо использовать thread local.
2888.28 2889.72 "Игорь Лабутин" Он типа эффективнее.
2889.72 2892.96 "Игорь Лабутин" Но если посмотреть исходный код thread local, он внутри использует thread static.
2892.96 2901.16 "Игорь Лабутин" То есть thread static - это такой примитив, который позволяет вам, конкретное поле, сказать, что вот оно будет, его значение, пожалуйста, храни в каждом потоке свое.
2901.16 2906.36 "Игорь Лабутин" И вот они вокруг этого thread static обернули удобный класс thread local, который действительно удобно использовать.
2906.36 2908.96 "Игорь Лабутин" Но работает он следующим образом.
2908.96 2915.00 "Игорь Лабутин" Внутри thread local у вас есть статическое поле, то есть оно одно на все инстансы, но оно помечено thread static.
2915.00 2919.00 "Игорь Лабутин" То есть значение этого поля свое для каждого потока.
2919.00 2923.64 "Игорь Лабутин" То есть сколько у вас потоков в системе, столько у вас будет этих полей, значений этого поля.
2923.64 2928.32 "Игорь Лабутин" И поле это ни много ни мало, как массив для содержимого объектов thread local.
2928.32 2934.72 "Игорь Лабутин" То есть thread local не имеет у себя внутри какого-то поля типа value, а thread local имеет на самом деле внутри просто индекс.
2934.72 2941.60 "Игорь Лабутин" И этот индекс обозначает, в каком месте вот этого массива искать значение этого thread local.
2941.60 2946.88 "Игорь Лабутин" И это, как оказалось, большая проблема, потому что thread local нумеруются последовательно.
2946.88 2953.76 "Игорь Лабутин" Соответственно, если вы создали 50 тысяч штук, то у вас должно быть в этом массиве как минимум 50 тысяч элементов.
2953.76 2955.24 "Игорь Лабутин" А массива будет столько, сколько у вас потоков.
2955.24 2958.48 "Игорь Лабутин" Вот, собственно, отсюда 800 мегабайт и взялись.
2958.48 2961.36 "Игорь Лабутин" То есть вот этих массивов образовалось 800 мегабайт.
2961.36 2964.52 "Игорь Лабутин" При этом надо сказать, что массивы в среднем довольно таки пустые.
2964.52 2977.56 "Игорь Лабутин" Ну, то есть понятно, что если у вас какой-то thread local используется из двух-трех потоков, то соответствующий слот с этим индексом во всех массивах будет заполнен только в тех потоках, в которых он был использован.
2977.56 2982.32 "Игорь Лабутин" То есть такие средне, достаточно пустенькие массивы, но при этом очень большие.
2982.32 2984.08 "Игорь Лабутин" Проблема или нет, как думаешь?
2984.08 2985.08 "Анатолий Кулаков" Конечно, проблема.
2985.08 2992.12 "Анатолий Кулаков" Они рано или поздно в лох попадут, начнут деформиментацию приводить и вообще непонятные массивы у тебя в памяти держатся.
2992.12 2993.12 "Анатолий Кулаков" Конечно, плохо.
2993.12 2994.12 "Игорь Лабутин" Да, но они пустые.
2994.12 2995.92 "Игорь Лабутин" Но это как бы полдела.
2995.92 2997.80 "Игорь Лабутин" Следующее дело заключается вот в чем.
2997.80 3001.44 "Игорь Лабутин" Thread local он класс реализует disposable.
3001.44 3002.44 "Игорь Лабутин" Что это означает?
3002.44 3018.40 "Игорь Лабутин" Что если вы скажете на thread local dispose, например, он лежит у вас в disposable классе и вы аккуратненько его задиспозируете тоже, то это означает, что в этот момент нужно освободить, то бишь по сути проставить в null все слоты с этим индексом во всех массивах.
3018.40 3019.40 "Игорь Лабутин" Понятно, да?
3019.40 3020.40 "Анатолий Кулаков" Объясняю.
3020.40 3021.40 "Анатолий Кулаков" Да, да, конечно.
3021.40 3023.52 "Анатолий Кулаков" Надеюсь, они потом переюзываются, эти пустые дырочки?
3023.52 3024.52 "Игорь Лабутин" Да, да, да.
3024.52 3026.32 "Игорь Лабутин" Если сказать dispose, они переюзаются.
3026.32 3027.52 "Игорь Лабутин" Но теперь смотри, проблема.
3027.52 3029.52 "Игорь Лабутин" Ты в одном потоке говоришь dispose.
3029.52 3037.64 "Игорь Лабутин" Thread local говорит, ну ладно, хорошо, мне нужно задиспозировать соответственно все значения во всех массивах с этим индексом.
3037.64 3043.96 "Игорь Лабутин" Все прекрасно, но массивы же, они же thread static, то есть в каждом потоке свой массив, как сходить в другие потоки, чтобы там тоже все почистить?
3043.96 3045.16 "Игорь Лабутин" Заблокировать всех.
3045.16 3050.84 "Игорь Лабутин" Заблокировать, понятно, но физически у тебя доступ к этим массивам будет только из другого потока.
3050.84 3052.52 "Игорь Лабутин" Попросить другой поток почистить их.
3052.52 3056.28 "Игорь Лабутин" Ну это было бы слишком сложно, поэтому Microsoft сделала более простое решение.
3056.28 3065.72 "Игорь Лабутин" Они, мало того, что у тебя слот внутри этого массива хранит само значение, эти слоты друг с другом связаны в двусвязный список.
3065.72 3068.96 "Игорь Лабутин" То есть у тебя получается структурка, напоминающая решетку.
3068.96 3086.88 "Игорь Лабутин" То есть, если, допустим, массивы расположить горизонтально, то и индекс, соответственно, в них обозначает instance thread local, к которому соответствует слот, то вертикально все элементы с одним и тем же индексом во всех массивах связаны в двусвязный список через классический previous и next указатели, ну или ссылки в C#.
3086.88 3097.52 "Игорь Лабутин" Это позволяет сделать такую штуку, что из какого бы thread они позвали dispose можно пробираться по этому двусвязному списку и найти таким образом все instances во всех массивах и их сбросить.
3097.52 3100.08 "Игорь Лабутин" Но эта структура, она дико проблемная для garbage collector.
3100.08 3125.08 "Игорь Лабутин" То есть ты понимаешь, у тебя есть массивы, там в данном случае по 60 килобайт каждый, и в них еще гора двусвязных списков, друг с другом связанных next previous указателей, по которым по-хорошему garbage collector по всему нужно пробежаться, потому что любой static массив это, как известно, garbage collection root, и garbage collector аккуратно брал каждый static массив и по каждому из них пробегал, по каждому слоту и везде, где встречал next previous указатели, ему нужно было по ним сбегать.
3125.08 3130.96 "Игорь Лабутин" Понятно, что рано или поздно он натыкался на какой-нибудь блок, который он уже проходил, но тем не менее работает дофига.
3130.96 3134.00 "Анатолий Кулаков" Да, действительно, очень должна медленная быть операция.
3134.00 3153.28 "Игорь Лабутин" Ну и вот как раз-таки они, когда поняли, как это все устроено, они сделали себе reppro step небольшой, они просто искусственным образом создали такую структуру, типа массив, в нем элемент слот, который был связанным списком с элементами таких же массивов, с такими же индексами, и попробовали просто принудительно вызвать garbage collector.
3153.28 3161.92 "Игорь Лабутин" На полугигабайтной куче это заняло, если я не ошибаюсь, что-то в духе 100 миллисекунд, что ли, Mark Face, или 500 миллисекунд.
3161.92 3166.32 "Игорь Лабутин" Ну, в общем, какие-то миллисекунды, ну, порядка сотен миллисекунд.
3166.32 3170.68 "Игорь Лабутин" Очевидно, что на их 8-гигабайтном хипе, ну, там, скорее всего, все было гораздо хуже.
3170.68 3176.56 "Игорь Лабутин" Дальше, соответственно, возникает вопрос, откуда столько thread-locals?
3176.56 3184.64 "Анатолий Кулаков" Это точно, это же не просто так эти массивы выросли, они, наверное, были рассчитаны на то, что их обычно мало, и поэтому команда рантайма немножко забила на это.
3184.64 3185.64 "Анатолий Кулаков" Да, это так.
3185.64 3186.64 "Игорь Лабутин" А откуда у них?
3186.64 3188.68 "Игорь Лабутин" У них из следующей штуки.
3188.68 3196.00 "Игорь Лабутин" RavenDB устроен таким образом, как я понял, я не использовал, но по описанию, у них работает следующая штука.
3196.00 3210.40 "Игорь Лабутин" Если у тебя есть какие-то активности в базе данных, то есть, например, у тебя есть, ну, какие-то обслуживания запросов этой базы данных, плюс у тебя есть какие-то индексы, которые нужно поддерживать, то каждая эта штука обрабатывается каким-то, возможно, своим потоком.
3210.40 3226.48 "Игорь Лабутин" Может быть, это сделано на тасках, но рано или поздно это все валится, естественно, в thread pool или, может быть, даже в выделенные потоки, и если у тебя много таких тасков, действительно много, то понятно, что thread pool тоже разрастется и живых реальных потоков будет довольно много.
3226.48 3228.60 "Игорь Лабутин" То есть, такие массивы будут заполнены довольно активно.
3228.60 3229.60 "Игорь Лабутин" Это про потоки.
3229.60 3231.44 "Игорь Лабутин" Это не объясняет количество thread-locals.
3231.44 3234.04 "Игорь Лабутин" А thread-locals заключается вот в чем.
3234.04 3246.64 "Игорь Лабутин" Действительно, на этом сервере, этот сервер был довольно загруженный, там было несколько десятков баз данных, в каждой базе огромное количество индексов, а индексы, поскольку RavenDB, насколько я понимаю, это документная база данных, правильно ведь?
3246.64 3248.56 "Игорь Лабутин" Да, все верно, это документная база данных.
3248.56 3260.76 "Игорь Лабутин" То там, соответственно, нужен всякий индексы, полнотекстовый поиск и так далее, они используют движок Lucene, и в его реализации там на каждое обращение создается instance thread-local.
3260.76 3268.64 "Игорь Лабутин" Ну, для какого-то сохранения стейта, видимо, не знаю, для чего, какой-то локальный кусочек работы, который нужно там, данных сохранять локально.
3268.64 3275.24 "Игорь Лабутин" И поскольку на большом количестве баз данных этих одновременно работающих и обновляющихся индексов много, то, ну, вот thread-locals стало 50 тысяч.
3275.24 3276.84 "Игорь Лабутин" Это, в принципе, для них нормально.
3276.84 3279.96 "Игорь Лабутин" То есть, они на это посмотрели, сказали, что да, их столько и должно быть.
3279.96 3282.36 "Игорь Лабутин" Но, а .NET оказался не готов к такому.
3282.36 3286.48 "Игорь Лабутин" И дальше надо все это решать, проблему надо решать.
3286.48 3290.68 "Игорь Лабутин" Проблему они стали решать довольно правильно, они пошли двумя путями.
3290.68 3300.72 "Игорь Лабутин" Краткосрочно они сделали свою реализацию thread-local, на основе просто concurrent dictionary и хитрой комбинации weak-references и ссылок на родителей.
3300.72 3313.08 "Игорь Лабутин" Таким образом, что у них получилась похожая структура, то есть набор каких-то значений для каждого потока, связанных друг с другом, так что их можно задиспользовать всех вместе, но при этом они не используют огромное количество массивов.
3313.08 3324.72 "Игорь Лабутин" Скорее всего, в каком-то виде эта реализация чуть медленнее, чем стандартный thread-local, потому что, ну, concurrent dictionary, он все-таки там, наверное, чуть медленнее, чем вот такая вот чистая трансцитатик реализации без единого лока.
3324.72 3325.72 "Игорь Лабутин" Вот.
3325.72 3326.72 "Игорь Лабутин" Это был один путь.
3326.72 3330.20 "Игорь Лабутин" И он работает, я так понимаю, что он сейчас у них в продакшене, все нормально.
3330.20 3334.08 "Игорь Лабутин" А второе, они создали еще и команду Runtime, со словами вот тут такое дело.
3334.08 3350.20 "Игорь Лабутин" И вот это еще очень интересно почитать, потому что там есть прекрасное описание того, что сначала команда Runtime говорила, так ну как бы сами виноваты, создают им столько много объектов, как бы да, они померили аккуратно garbage collector, сколько он тратит CPU, сказали, ну да.
3350.20 3359.84 "Игорь Лабутин" И получилось, что, по-моему, время на обход одного объекта составило одну десятую наносекунды, что они посчитали весьма хорошей скоростью.
3359.84 3364.48 "Анатолий Кулаков" Ну да, с точки зрения Runtime это вполне валидное поведение, ничего здесь такого нет.
3364.48 3372.72 "Игорь Лабутин" Но потом они подумали и поняли, что вообще этот thread-local, может быть, действительно сейчас довольно популярен, и решили, что не, можно что-то все-таки пооптимизировать.
3372.72 3377.28 "Игорь Лабутин" И написали оптимизацию, она еще не завершена, насколько я понимаю.
3377.28 3380.72 "Игорь Лабутин" Она где-то чуть-чуть подвисла, но вроде в дотант 5 она должна войти.
3380.72 3383.00 "Игорь Лабутин" И они сделали, на самом деле, простую штуку.
3383.00 3410.80 "Игорь Лабутин" Они вот эти массивы, которых было по индексам, там, соответственно, в данном случае длиной 60 тысяч, они их сгруппировали, точнее, не так, они сгруппировали слоты в группы по 64 штуки и замутили там какую-то клевую битовую, короче, битмасковые операции для того, чтобы понять вообще какие слоты пустые, какие полные, и как их освобождать все вместе, и что все лишь 64 уже хендла внутри освободились, чтобы потереть слот и так далее.
3410.80 3421.48 "Игорь Лабутин" И, в общем, массив сократился в 64 раза, то есть в 64 раза стало меньше объектов, которые надо обходить garbage-коллектору, и стало вроде как хорошо по всем патчмаркам, но вот pull request пока в процессе.
3421.48 3432.32 "Игорь Лабутин" Один из интересных кейсов, на самом деле, который, с одной стороны, довольно простой, то есть thread-local он хорош тем, что он самодостаточен.
3432.32 3440.00 "Игорь Лабутин" То есть вся реализация thread-local это один файлик, он ни от чего другого не зависит, и посмотреть, что было, что стало, очень интересно.
3440.00 3442.48 "Игорь Лабутин" Можете глянуть, будет интересно.
3442.48 3465.92 "Игорь Лабутин" На самом деле, говоря про thread-local, хочется вообще немножко поговорить вокруг хранения этих данных, потому что, как я вижу, тема того, что я хочу хранить что-то рядом со своим thread-ом, она была весьма популярна, она иногда встречается сейчас, и сейчас с этим на самом деле гораздо больше проблем.
3465.92 3474.00 "Игорь Лабутин" Началось все, как я сказал, был когда-то thread-static, thread-static никуда не делся, потом появился thread-local.
3474.00 3476.48 "Анатолий Кулаков" Какое основное отличие thread-local от thread-static?
3476.48 3479.60 "Игорь Лабутин" Thread-local стал удобнее двумя вещами.
3479.60 3498.48 "Игорь Лабутин" Thread-local стал, во-первых, гарантировать инициализацию в каждом потоке, thread-static имел проблему в thread-static, можно было написать правил thread-static, какой-нибудь int value присвоить 5, пометить такое поле thread-static, и с удивлением обнаружить, что value равно 5 только в одном thread, а именно в том, в котором выполнился конструктор.
3498.48 3501.88 "Игорь Лабутин" Первый раз, первый раз этого объекта.
3501.88 3507.84 "Игорь Лабутин" Все остальные получали null, ну то есть default value, в случае с reference с типами, соответственно, получался null.
3507.84 3515.96 "Игорь Лабутин" Приходилось делать propertue, которое в каждом потоке проверялось, заполнено ли value, не заполнено, значит надо заполнить, но в общем был неудобно.
3515.96 3528.96 "Игорь Лабутин" Сделали thread-local, которым передается на самом деле factory, ну factory, то есть func, по сути, который инициализирует значение в каждом потоке, плюс его можно диспозить и, соответственно, немножко эффективнее используется место в этих thread-static словариках.
3528.96 3537.40 "Анатолий Кулаков" Да, логично, но в принципе с потоками уже давно никто не пользуется, все пользуются тасками, а как известно, таски не мапятся напрямую на потоке.
3537.40 3540.32 "Анатолий Кулаков" Как в этом случае хранить переменную рядом?
3540.32 3557.16 "Игорь Лабутин" Да, соответственно, как только появились таски, стало понятно, что thread-local не работает, то есть многие пытались и если вам повезет, и continuation, например, или какое-нибудь там продолжение вашего sync-await будет исполняться в том же потоке, если у вас приложение не очень сильно нагружено, то почему нет?
3557.16 3560.20 "Игорь Лабутин" Все будет работать при этом, thread-local вас спасут.
3560.20 3574.92 "Игорь Лабутин" Но стоит чуть-чуть больше добавить нагрузки и добавиться на несколько потоков новых, то thread-local сразу станет бесполезен, потому что continuation или продолжение вашего sync-метода будет выполняться уже на другом потоке.
3574.92 3609.88 "Игорь Лабутин" На заре появления тасков ничего удобного не было, такого же как thread-local, и приходилось использовать такую штуку, как call-контекст, то есть есть call-контекст, либо есть его держащий execution-контекст, который на самом деле был вообще-то придуман для ремонтинга когда-то давно и позволял таким образом переносить состояние между обдоменами, даже на самом деле между процессами путем сериализации всего и вся, то есть в него можно было запихнуть какое-нибудь словарик ключ значения, он все сериализовывал и волшебным образом на другой стороне вызова все появлялось.
3609.88 3612.96 "Анатолий Кулаков" Но ремонтинга с нами уже давным-давно нет, а call-контекст
3612.96 3629.48 "Игорь Лабутин" остался. Call-контекст остался, execution-контекст остался, и на самом деле до сих пор вы можете написать execution-контекст точка set logical data, и это все будет работать, но оно там внутри немножко по-другому сейчас реализовано, особенно на dotnet core, где вообще нет ничего никакого, ни ремонтинга, ничего такого.
3629.48 3646.44 "Игорь Лабутин" Но тем не менее, пользоваться этим всем не очень удобно, вам нужно помнить эти текстовые ключики, то есть по сути там ключом был, ну обычно использовали строчки в качестве ключа, и значит нужно было во всех местах эти строчки помнить, там либо константы их выносить, неудобно, запарно и куча кода лишнего.
3646.44 3660.96 "Игорь Лабутин" Поэтому в dotnet 4.6 появился класс async-local, который, соответственно, использует execution-контекст напрямую, ради этого в execution-контекст даже добавили новые пропертии и филды, где собственно хранятся эти значения, это все уже работает в обход call-контекстов.
3660.96 3702.20 "Игорь Лабутин" И async-local это вот то, что нужно для тасков, то есть у него семантика такая, что у вас сохраняется значение, которое вы туда записали в рамках вашего, назовем это execution-flow, то есть если у вас есть async-метод, который, или просто метод, в котором вы записали в async-local переменную какое-то значение, то все последующие ответвления от этого метода, будь то старт потоков, продолжение работы в thread-пуле через thread-pull, queue, user work item, или создание новых тасков, или собственно async-await, который под капотом, естественно, создадут вам новые таски.
3702.20 3708.40 "Игорь Лабутин" Везде execution-контекст будет протаскиваться и, соответственно, будет протаскиваться ваше значение, которое вы туда положили.
3708.40 3711.68 "Игорь Лабутин" Удобно, прекрасно и все работает абсолютно прозрачно.
3711.68 3717.44 "Игорь Лабутин" Если вдруг вам не надо, чтобы это протаскивалось, там есть специальные методы, которые говорят, что вот тут конкретно не надо.
3717.44 3718.92 "Игорь Лабутин" Можно временно засопрессить.
3718.92 3719.92 "Игорь Лабутин" Вот.
3719.92 3730.44 "Игорь Лабутин" В целом, концепция удобная, но она не без изюминки, я бы сказал, которая на самом деле очень сильно путает и поначалу приводит несколько в ступор.
3730.44 3737.40 "Игорь Лабутин" Если вы, например, представите такую штуку, что у вас есть async-метод, который вызывает два метода, метод 1 и метод 2.
3737.40 3738.40 "Игорь Лабутин" Оба тоже асинковые.
3738.40 3747.60 "Игорь Лабутин" Так вот, если вы в async-local-переменную, допустим, у вас есть поле класса, где что-то хранится, метод 1 и метод 2 - оба метода класса.
3747.60 3748.60 "Игорь Лабутин" Оба async-метода, напоминаю.
3748.60 3759.64 "Игорь Лабутин" Если вы в методе 1 поставите какое-то значение в это async-local-переменную, то в методе 2 или даже в вызывающем методе в исходном этого значения видно не будет.
3759.64 3763.44 "Игорь Лабутин" Внутри async-local будет null, либо что вы туда проставили до этого.
3763.44 3770.40 "Игорь Лабутин" То есть любые значения, которые записаны в async-local, распространяются только вниз в потере его вызовов, но не вверх.
3770.40 3771.96 "Игорь Лабутин" Да, интересная особенность.
3771.96 3780.44 "Игорь Лабутин" Это нужно знать, это полезно знать, если вы, например, это пытаетесь делать в каких-нибудь middleware.
3780.44 3801.24 "Игорь Лабутин" Async-local - популярная тема при работе с spnadcore и middleware, то есть если вам, например, встречался такой класс как ahttp-контекст-аксессор, вот он как раз реализован с помощью async-local, и можно попасть в такую ловушку, что вы, например, в вашем middleware, в invoke-методе, который async, делаете какой-нибудь helper-метод, который вызываете перед тем, как вызывать next.
3801.24 3806.96 "Игорь Лабутин" И если он тоже async, то проставив в нем значение async-local, и внутри next этого async-local видно не будет.
3806.96 3811.60 "Игорь Лабутин" Поэтому в таком случае метод, вот этот вот helper нужно делать синхронным.
3811.60 3817.20 "Игорь Лабутин" На синхронные методы execution-контекст не влияет никак, в смысле его продвижения туда-сюда.
3817.20 3822.04 "Игорь Лабутин" И в синхронном методе можно проставить значение, и при выходе из него оно все еще будет видно.
3822.04 3823.68 "Анатолий Кулаков" Слушай, а это вообще баг или фича?
3823.68 3826.84 "Анатолий Кулаков" То есть это специально сделали, чтобы он не пропагетился вверх?
3826.84 3834.92 "Игорь Лабутин" Да, это сделано специально, для этого есть на самом деле кусочек специального кода, чтобы на самом деле при...
3834.92 3843.20 "Игорь Лабутин" То есть понятно, что простейшей реализацией было бы просто каждый раз копировать execution-контекст при каждом смене таска, при каждом новом потоке и так далее.
3843.20 3845.40 "Игорь Лабутин" Это было бы очень дорого с точки зрения памяти.
3845.40 3848.72 "Игорь Лабутин" Поэтому там реализована то, что называется copy-on-write семантика.
3848.72 3858.40 "Игорь Лабутин" То есть пока вы ничего не трогаете в дочерних тасках или потоках, ничего не будет происходить, но как только вы тронете, тут же создастся копия execution-контекста, и она уже будет жить сама по себе.
3858.40 3875.72 "Игорь Лабутин" Я не очень знаю, зачем это было сделано глобально, но вот в том практическом примере использования, когда мы это видим в ASP.NET Request, это вполне объяснимо и полезно, потому что один и тот же поток на самом деле может исполнять один и тот же разные...
3875.72 3884.72 "Игорь Лабутин" Обработку разных реквестов в разное время, и было бы очень неудобно, если бы один и тот же поток мог видеть какие-то SYNC LOCAL STATES от других потоков.
3884.72 3889.00 "Игорь Лабутин" Или от себя же самого, например, от прошлого реквеста.
3889.00 3900.04 "Игорь Лабутин" Поэтому распространение не только вниз, оно мне кажется весьма полезным, что как только мы вернулись из обработки какого-то реквеста или кусочка логической обработки реквеста, мы уже не знаем, что происходило внутри.
3900.04 3907.24 "Игорь Лабутин" Но это налагает некоторые тонкости, если вы хотите вернуть какие-то значения и пропагидить штуки изнутри-наружу.
3907.24 3918.96 "Игорь Лабутин" Это тоже можно сделать, просто добавляя специальный, скажем так, прослоечку, потому что это копирование, оно то, что называется, не глубокое, то есть копируется только верхний уровень объектов.
3918.96 3928.56 "Игорь Лабутин" Если внутри объектов есть ссылки, они, конечно, будут все ссылаться все на одно и то же, и именно за счет этого можно попытаться все-таки вернуть значения наружу, это работает.
3928.56 3947.40 "Игорь Лабутин" Но этого нужно стараться избегать, и есть очень хорошая статья Стефана Клири про вообще все эти асинхронные контексты и как это все работает, и как куда что передается, где всячески рекомендуется использовать только immutable объекты внутри async local, чтобы вы вот один раз их записали и больше не трогали.
3947.40 3956.32 "Анатолий Кулаков" Да, это отлично вообще рекомендация, если у вас есть какие-то проблемы с параллельностью, асинхронностью, конкаренсией, переходите на immutable, там все хорошо.
3956.32 3981.08 "Игорь Лабутин" Ну да, в общем, async local тема полезная и интересная, в мире тасков она может вам спасти, если не жизнь, то по крайней мере какое-то количество времени, когда вам нужно что-то куда-то хитро передать и воспользоваться клевыми штуками, типа там, то, что называется ambient context, когда у вас есть какой-нибудь там точка current, пропертя, которая автоматически везде сама работает, то это то, что вам нужно.
3981.08 3988.96 "Игорь Лабутин" Но, почитайте статьи, они будут в шоу-ноутсах, чтобы лучше понимать, как это работает, а еще лучше почитайте код, чтобы понять вообще, как это все устроено.
3988.96 3991.24 "Игорь Лабутин" Код довольно простой, ничего сложного там нет.
3991.24 3995.00 "Анатолий Кулаков" После таких сложных, запутанных историй, не очень даже хочется туда лезть.
3995.00 3999.64 "Анатолий Кулаков" Но я искренне надеюсь, что это когда-нибудь экранизируют и мы насладимся замечательным детективом.
3999.64 4016.72 "Игорь Лабутин" Да, ну экранизируют не знаю, но в принципе история хорошая детективная и мне кажется, что чем больше Microsoft делает ума-цурса, тем таких историй будет больше и интереснее, тем очень удобно, когда можно реально посмотреть исходный код и даже его поотлаживать.
4016.72 4018.24 "Игорь Лабутин" Это прям вообще бесценно.
4018.24 4024.04 "Анатолий Кулаков" Так, не хочется оставлять наших слушателей на такой мозгодробительной теме, но давай что-нибудь легенькое под конец откроем.
4024.04 4032.08 "Анатолий Кулаков" Например, вот интересная статейка есть, называется она "Contribute to the top 10 impactful .NET OSS project".
4032.08 4039.12 "Анатолий Кулаков" То есть, куда бы нам законтрибьютить и давайте найдем каких-нибудь 10 самых значимых проектов.
4039.12 4048.04 "Анатолий Кулаков" 10 проектов отбирались автором, судя по всему, абсолютно случайно или по какому-то его личным предрассудкам, но смысл не в этом.
4048.04 4054.88 "Анатолий Кулаков" В принципе, проекты он выбрал большинство довольно-таки замечательных, поэтому давайте по ним пройдемся и посмотрим, что же такого полезного можно в них привнести.
4054.88 4059.52 "Анатолий Кулаков" Автор - Халит Абухамех, который сейчас работает евангелистом JetBrains.
4059.52 4061.80 "Анатолий Кулаков" Или у них там не вангелисты, как они называются?
4061.80 4064.40 "Анатолий Кулаков" Девелоперы-адвокаты сейчас это правильно называют.
4064.40 4067.32 "Анатолий Кулаков" Вот, адвокатом JetBrains.
4067.32 4093.36 "Анатолий Кулаков" Автор много пишет, у него достаточно активный блог в последнее время, и он справедливо замечает, что тот мир, в котором мы сейчас с вами живем, мы как дотнет-разработчики, он очень сильно отличается от того мира, когда был Микрософт закрытый, у него все исходники были закрытыми, и посмотреть, как устроен ThreadLocal, или посмотреть, каким образом там происходит ГЦ, и какие структуры у них используются внутри, это было довольно проблематично.
4093.36 4098.64 "Анатолий Кулаков" Были там какие-то кастериспамы, референсосы, были декомпилы, но это все равно все-таки не то.
4098.64 4099.64 "Анатолий Кулаков" Немножко не то.
4099.64 4114.40 "Анатолий Кулаков" Сейчас мы живем в абсолютно другом мире, где мы можем смотреть исходники, где мы можем влиять на проекты, где мы можем сами посылать pull-requests, открывать issue, общаться вместе с разработчиками, находить какие-то новые интересные ситуации, новые интересные моменты.
4114.40 4126.68 "Анатолий Кулаков" И вот, Халид предлагает нам взглянуть на топ-10 проектов, которые, по его мнению, достойны того, чтобы в них начать контрибьютить, или продолжить, если вы уже очень активный контрибьютор.
4126.68 4131.00 "Анатолий Кулаков" Для начала, интересно вообще, зачем контрибьютить в open source проекты?
4131.00 4132.28 "Анатолий Кулаков" Игорь, как ты думаешь?
4132.28 4137.72 "Игорь Лабутин" Ну, во-первых, это возможность, не знаю, помочь комьюнити.
4137.72 4141.16 "Игорь Лабутин" Или, может быть, не во-первых, порядок не сильно может быть важен.
4141.16 4144.44 "Игорь Лабутин" Во-вторых, это возможность пофиксить те баги, которые мешают вам.
4144.44 4147.56 "Игорь Лабутин" И это, наверное, то, например, почему я начал контрибьютить.
4147.56 4153.04 "Игорь Лабутин" Было несколько багов или неудобств, которые в каких-то татулах мне не нравились, я пошел и просто их пофиксил.
4153.04 4159.36 "Игорь Лабутин" В-третьих, это на самом деле отличная возможность разобраться в том, как что-то устроено.
4159.36 4162.00 "Анатолий Кулаков" Вообще, это довольно безумно интересно.
4162.00 4169.24 "Анатолий Кулаков" Разобраться в чужом коде, смотреть, как это все устроено, потом применять это в своих проектах, может быть, помогать автору оригинального кода.
4169.24 4171.00 "Анатолий Кулаков" Поэтому полностью с тобой согласен.
4171.00 4182.44 "Анатолий Кулаков" Может быть, я бы отметил еще для резюме, потому что сейчас многие компании просят показать профиль на GitHub и смотрят, насколько вы там активный контрибьютор, или насколько вы себя вообще там активно ведете.
4182.44 4191.60 "Анатолий Кулаков" И вообще, увеличивать свои скиллы с помощью чтения книг, с помощью просмотра лекций, с помощью общения на форуме - это довольно-таки полезно.
4191.60 4197.36 "Анатолий Кулаков" И не менее полезно как раз-таки увеличивать свои скиллы с помощью контрибьютия в open source.
4197.36 4201.04 "Анатолий Кулаков" Это касается не только разработки, но и в том числе коммуникационной скиллы.
4201.04 4216.08 "Анатолий Кулаков" То есть связаться с автором, спросить, в чем проблемы, обсудить с ним способ решения, потом доказать, что ваше решение верно, предоставить какие-нибудь бенчмарк-тесты, проследить, как это попадет в мастер, зарелизить его, может быть, даже написать документацию или какой-нибудь анонс.
4216.08 4219.96 "Анатолий Кулаков" То есть поучаствовать в полном цикле в вашей фиче.
4219.96 4225.88 "Анатолий Кулаков" И можно набить руку на любом из этих аспектов, которые вам больше нравятся.
4225.88 4230.00 "Анатолий Кулаков" Ну, давай ближе к списку, посмотрим, куда советует автор нам обратиться.
4230.00 4234.36 "Анатолий Кулаков" На первом месте стоит ISP.NET Core.
4234.36 4251.48 "Анатолий Кулаков" Это сейчас, наверное, безусловно, самый знаменитый .NET фреймворк не только среди .NET разработчиков, но и в мире, потому что он уже находился несколько раз на первых позициях в некоторых тестах, как самый быстрый веб-сервер.
4251.48 4257.00 "Анатолий Кулаков" Этим веб-сервером является Kestrel, который входит в комплект ISP.NET Core.
4257.00 4266.60 "Анатолий Кулаков" Также ISP.NET Core состоит из множества других компонентов, таких как Blazor Engine, MVC, WebAPI и много-много всего другого.
4266.60 4270.32 "Анатолий Кулаков" В каждой из этих компонентов вполне можно поконтрибьютить.
4270.32 4281.60 "Анатолий Кулаков" Там очень много открытых ищей для новичков, очень много ищей в документации, с которой можно начать для того, чтобы подробнее ознакомиться с внутренними структурами.
4281.60 4293.48 "Анатолий Кулаков" И самое главное, что там очень большое и доброе комьюнити, которое всегда рады новичкам и не закидает вас злыми помидорами, а в принципе поможет правильно развиваться в нужном направлении.
4293.48 4295.20 "Анатолий Кулаков" На втором месте Nuget Search.
4295.20 4303.20 "Анатолий Кулаков" Это отдельный пакет, который используется официальным Nuget для того, чтобы осуществлять поиск по пакетам, по DLL-кам и так далее.
4303.20 4310.80 "Анатолий Кулаков" Мне почему-то никогда не приходилось искать по внутренностям DLL-ки, я даже не знал, что такая возможность у официального Nuget есть.
4310.80 4314.72 "Анатолий Кулаков" И как-то всегда точно знал, за каким пакетом я иду и как он называется.
4314.72 4320.52 "Анатолий Кулаков" Этот Search Engine, он открыт и находится на GitHub и зовет к себе контрибьюторов.
4320.52 4334.04 "Анатолий Кулаков" Понимание алгоритма полнотекстового поиска обязательно, но в принципе каких-нибудь основ вам достаточно для того, чтобы начать туда контрибьютить и стать частью одного из самых знаменитых лотнетовских серверов.
4334.04 4337.32 "Анатолий Кулаков" Дальше идет Godot Engine и MonoGames.
4337.32 4342.76 "Анатолий Кулаков" Это мультиплатформенные игровые движки и игровой фреймворк для написания игровых движков.
4342.76 4350.56 "Анатолий Кулаков" Они полностью открыты и бесплатны, в отличие от гигантов типа Unity и Unreal, которые требуют какой-то налог за использование.
4350.56 4355.28 "Анатолий Кулаков" Можно контрибьютить в эти движки с помощью написания демок для этих игр.
4355.28 4364.44 "Анатолий Кулаков" Соответственно, если вы мечтали писать игры, но вас не хватает на полноценный проект, то вы можете законтрибить эти демки и это будет очень большой вклад в развитие этих движков.
4364.44 4367.36 "Анатолий Кулаков" И также у них большие проблемы с документацией.
4367.36 4369.84 "Анатолий Кулаков" Поэтому тоже милости просим.
4369.84 4374.16 "Анатолий Кулаков" Дальше идет Serilog от Николаса Блумхарта.
4374.16 4377.04 "Анатолий Кулаков" Знаменитый автор, знаменитый проект.
4377.04 4378.76 "Анатолий Кулаков" Проект для структурного логирования.
4378.76 4383.04 "Анатолий Кулаков" Serilog сейчас находится на втором месте по числу скачиваний на Nuget сервере.
4383.04 4385.20 "Анатолий Кулаков" Среди всех проектов в экосистеме .NET.
4385.20 4392.20 "Анатолий Кулаков" То есть, это довольно популярный пакет и судя по количеству, его должен использовать, наверное, уже каждый проект.
4392.20 4396.96 "Анатолий Кулаков" Ну, каждый новый точно, но каждый старый, соответственно, тоже.
4396.96 4402.96 "Анатолий Кулаков" Здесь можно создавать новые синки, здесь можно предлагать новые интеграции и писать документацию.
4402.96 4406.32 "Анатолий Кулаков" Далее в списке находится довольно-таки новый проект, который называется Static.
4406.32 4408.68 "Анатолий Кулаков" Дэйва Глика.
4408.68 4412.76 "Анатолий Кулаков" Про Дэйва Глика и Static мне есть много чего сказать.
4412.76 4416.40 "Анатолий Кулаков" Прежде всего, Дэйв знаменитен его проектом Vimeo.
4416.40 4417.84 "Анатолий Кулаков" Или как-то так.
4417.84 4422.20 "Анатолий Кулаков" Это самый популярный движок для статической генерации сайтов, который написан на .NET.
4422.20 4425.84 "Анатолий Кулаков" В принципе, на .NET довольно-таки мало статических движков.
4425.84 4432.28 "Анатолий Кулаков" Еще меньше хороших статических движков и нормальных, поддерживаемых или вменяемых было там только два.
4432.28 4433.92 "Анатолий Кулаков" Один из которых это был Vim.
4433.92 4439.32 "Анатолий Кулаков" Я, к сожалению, его знаю, потому что наш сайт .NET.RU работает с помощью этого движка.
4439.32 4445.12 "Анатолий Кулаков" И это очень больной опыт, это очень страшные переживания.
4445.12 4449.16 "Анатолий Кулаков" Это многие часы кусания локтей и разбивания головы об монитор.
4449.16 4451.92 "Анатолий Кулаков" Как-нибудь я, наверное, об этом отдельно расскажу.
4451.92 4454.32 "Анатолий Кулаков" Но надо быть полным гением, чтобы такое придумать.
4454.32 4458.60 "Анатолий Кулаков" К сожалению, ничего лучше на рынке нет и поэтому это самый популярный движок.
4458.60 4461.64 "Анатолий Кулаков" К счастью для нас Vim закрылся.
4461.64 4465.34 "Анатолий Кулаков" Но, к сожалению, он закрылся потому, что у него появился преемник.
4465.34 4467.76 "Анатолий Кулаков" И преемник как раз-таки есть вот этот новый Static.
4467.76 4473.12 "Анатолий Кулаков" Я планирую на него перелезть, потому что, судя по документации, он гораздо лучше, чем Vim.
4473.12 4488.26 "Анатолий Кулаков" Несмотря на то, что он является идеологическим наследником и внутри себя использует компоненты из Vim, автор довольно-таки сильно пересмотрел саму концепцию составления пайплайнов, саму концепцию составления вот этого статического проекта.
4488.26 4490.40 "Анатолий Кулаков" И может быть на сей раз оно выстрелит.
4490.40 4495.60 "Анатолий Кулаков" В то же самое время это новый движок, ему очень нужна документация, ему очень нужны примеры.
4495.60 4498.68 "Анатолий Кулаков" Поэтому сюда тоже можно активно контрибьютить.
4498.68 4499.68 "Анатолий Кулаков" Далее Handfire.
4499.68 4505.80 "Анатолий Кулаков" Handfire это лучшее решение, если вы хотите строить какие-то background джобы в вашем приложении.
4505.80 4512.96 "Анатолий Кулаков" То есть не нужно записать ни какие-то там Windows сервисы, ни какие-то там другие ажуровские джобы, ни какие-то таски скедулить.
4512.96 4515.28 "Анатолий Кулаков" Вот только вам нужен Handfire и все.
4515.28 4526.08 "Анатолий Кулаков" Это средство, которое умеет хорошо планировать джобы, хорошо их выполнять, retry, следить за их статусом, сохранять в storage, объединять в батчи.
4526.08 4529.48 "Анатолий Кулаков" И как раз можно поконтрибьютить в том, чтобы добавить новый storage.
4529.48 4537.48 "Анатолий Кулаков" Можно поконтрибьютить в том, чтобы сделать более красивый дашборд или чтобы написать больше примеров для того, как этот проект использовать.
4537.48 4539.88 "Анатолий Кулаков" Дальше идет Entity Framework Core.
4539.88 4545.92 "Анатолий Кулаков" Это знаменитая ORM, которая сейчас скорее всего даже и переплюнула все остальные.
4545.92 4547.92 "Анатолий Кулаков" Надо свериться со статистикой.
4547.92 4556.16 "Анатолий Кулаков" И в ней можно найти кучу багов, которые пользователи хотят зафиксить, также кучу фичей, которые они хотят реализовать.
4556.16 4564.36 "Анатолий Кулаков" И все-таки до сих пор страдает документация, несмотря на то, что это микрософтовский проект, поэтому контрибьюторы тоже очень сильно нужны.
4564.36 4569.40 "Игорь Лабутин" Тут надо сказать, что команда Entity Framework Core очень небольшая.
4569.40 4579.28 "Игорь Лабутин" На момент примерно года назад это было, если не ошибаюсь, в пределах 10 человек, включая тех, кто пишет документацию.
4579.28 4592.76 "Игорь Лабутин" Поэтому, может быть, сейчас она немножко и расширилась, но тем не менее с такой ORM пишется реально небольшой команда и любая помощь просто приблизит время, когда ваша нужная вам фича будет в релизе.
4592.76 4594.52 "Игорь Лабутин" Поэтому приходите, помогайте.
4594.52 4598.12 "Анатолий Кулаков" И у вас есть шанс вписаться в такой большой, большой гениальный проект.
4598.12 4600.00 "Анатолий Кулаков" Следующий проект - Martin.
4600.00 4601.44 "Анатолий Кулаков" Слышал что-нибудь про Martin?
4601.44 4603.60 "Игорь Лабутин" Вообще первый раз слышу.
4603.60 4611.28 "Анатолий Кулаков" Martin - это попытка сделать документно-ориентированную базу данных на стабильном движке, а именно на POSRES SQL.
4611.28 4613.24 "Анатолий Кулаков" Действительно, у нас же есть POSRES.
4613.24 4621.24 "Анатолий Кулаков" У него есть нормальные ACID-транзакции, у него есть гарантированные критерии выполнения, у него есть execution-планы.
4621.24 4625.28 "Анатолий Кулаков" И много-много тысяч человеколет вложено в его инфраструктуру.
4625.28 4627.08 "Анатолий Кулаков" И также он поддерживает JSON.
4627.08 4630.00 "Анатолий Кулаков" В принципе, все, что нужно для документа ориентированной базы данных.
4630.00 4637.68 "Анатолий Кулаков" Вот Martin - это такая надстройка, написанная на дот-нете, которая позволяет вас POSRES SQL превратить в документно-ориентированную базу данных.
4637.68 4647.12 "Анатолий Кулаков" Под капотом у нее будет POSREST, но для внешнего мира она будет выставлять все API полноценной документной базы данных.
4647.12 4650.04 "Анатолий Кулаков" Также этот движок поддерживает и Event Store модель.
4650.04 4653.52 "Анатолий Кулаков" Мартину нужны контрибьюторы в документацию и примеры.
4653.52 4656.68 "Анатолий Кулаков" Это тоже довольно-таки активно развивающийся проект.
4656.68 4660.04 "Анатолий Кулаков" Не сказать, что молодой, но есть куда применить свои
4660.04 4665.84 "Игорь Лабутин" силы. Надо сказать, что есть еще кучка проектов от Microsoft, куда тоже интересно и полезно поконтрибьюйтесь.
4665.84 4671.08 "Игорь Лабутин" С одной стороны, мы уже обсуждали Project TIE, упоминали его уже в этом выпуске.
4671.08 4674.28 "Игорь Лабутин" Это попытка сделать локальный такой Kubernetes-оркестратор.
4674.28 4683.68 "Игорь Лабутин" Ну, даже не столько Kubernetes, сколько оркестратор, который позволяет вам как-то оперировать вашими приложениями и задеплоить их в Kubernetes, если вам все понравилось.
4683.68 4687.56 "Игорь Лабутин" И проект на очень ранней стадии, он там превью-превью.
4687.56 4692.96 "Игорь Лабутин" Пользоваться можно, но никаких гарантий нет и куда все это разовьется, непонятно.
4692.96 4702.12 "Игорь Лабутин" Но тем не менее, там фичи развиваются довольно быстро, поэтому нужны сэмплы, нужны документации, нужно интегрировать это все в разные всякие DE-шки.
4702.12 4712.56 "Игорь Лабутин" И поэтому, чем больше мы туда придем и поконтрибьютим, тем, возможно, полезнее проект окажется и Microsoft его не прибьет, а он продолжит счастливо жить и будет полезным тулом.
4712.56 4719.32 "Игорь Лабутин" И еще одно место в Microsoft, куда нужно точно контрибьютить, это документация.
4719.32 4723.08 "Игорь Лабутин" Документация Microsoft стала очень шикарна, мне прям очень нравится.
4723.08 4734.84 "Игорь Лабутин" По сравнению с MSDN-ом какими-то десятилетней давности, все совершенно замечательно, но бывают и ошибки, бывают проблемы, бывают какие-то недочеты и это все надо исправлять, фиксить и добавлять новые знания.
4734.84 4748.92 "Анатолий Кулаков" Нужно признать, что даже старый MSDN для своего времени это был очень крутой ресурс по сравнению с остальными конкурентами, но все движется, все развивается и действительно, чтобы не отставать и оставаться лучше на рынке, нужно усовершенствовать документацию.
4748.92 4761.28 "Анатолий Кулаков" Я сейчас очень часто нахожу уже не просто какие-то описания классов, описания методов, а полноценные классные статьи, прям как отрывки из книги, прямо главы в Microsoft Docs и действительно качество поражает.
4761.28 4762.92 "Анатолий Кулаков" Просто шикарные там документации.
4762.92 4772.64 "Анатолий Кулаков" И этим пунктом хочется подчеркнуть, что контрибьютить можно не только в код, но документация, примеры, ish.u, это все тоже засчитывается и тоже нужно.
4772.64 4787.16 "Анатолий Кулаков" Это все, что делает из простого кода полноценный продукт, поэтому если вы не созрели для того, чтобы в ваш любимый проект писать код, но можете написать к нему документацию или сделать какие-то самплы или дописать тестов, то это тоже будет довольно-таки замечательно.
4787.16 4795.20 "Анатолий Кулаков" Автор называет еще чуть-чуть больше примеров, это CSV Helper, Fluent Validation, ImageSharp, Mark Dick от Александра Мютола.
4795.20 4806.76 "Анатолий Кулаков" Если вы хотите еще каких-то интересных проектов, то можно сходить, например, на Детонет Фаундейшн, это ресурс, который объединяет в себе очень-очень много полезных и интересных проектов, все они open source.
4806.76 4813.76 "Анатолий Кулаков" Во всех у них есть наверняка какие-нибудь ish.u, какие-нибудь потребности, которые вы можете удовлетворить.
4813.76 4823.28 "Анатолий Кулаков" Сходите посмотрите на Avalonium, тоже активный проект, отлично развивается, очень перспективный, это UI-движок, в котором вы сможете визуально пощупать все свои контрибьюты.
4823.28 4843.92 "Анатолий Кулаков" Если вы совсем не дружите с английским языком, например, или если больше хотите общаться с русскоязычными разработчиками, то, наверное, можно порекомендовать нашу репозиторию .NET.RU, там есть несколько активных проектов, несколько вялотекущих проектов, несколько мертвых проектов, но в принципе мы всегда сможем найти для вас интересное занятие, если вам какое-то из этих проектов понравится.
4843.92 4846.36 "Анатолий Кулаков" Поэтому приходите создавать ish.u, будем общаться.
4846.36 4851.32 "Игорь Лабутин" Соответственно, в какой бы проект вы ни пришли, всегда нужно понимать вообще с чего начинать.
4851.32 4871.60 "Игорь Лабутин" То есть это очень здорово, если у вас есть какая-то конкретная проблема, которую вы хотите решить, как вот я приводил примеры раньше про мой кейс, и вы идете напрямую, фиксите ту проблему или тот баг, или пишете ту фичу, которая нужна именно вам, то если вы приходите в проект просто, чтобы чем-то помочь, нужно понять с чего начать.
4871.60 4879.16 "Игорь Лабутин" Если вы готовы попробовать фиксить какие-то ish.u, либо попытаться писать какую-то документацию, то нужно знать, как ориентироваться.
4879.16 4888.44 "Игорь Лабутин" И для этого есть на GitHub механизм лейблов, и есть три стандартных, так скажем, лейбла, которые разные репозитории используют.
4888.44 4898.68 "Игорь Лабутин" Не все они используются, всеми репозиториями, то есть нужно просматривать все три, это App4Graphs через Defice, GoodFirstIsh.u или HelpWanted.
4898.68 4908.76 "Игорь Лабутин" Хотя бы один из них обычно используется каждым репозиториям, и те ish.u, за которые так помечены, означают, что их нужно брать.
4908.76 4912.40 "Игорь Лабутин" В первую очередь это то, где contribution наиболее желателен.
4912.40 4917.48 "Анатолий Кулаков" Еще есть специальный сайт, ссылка будет в шоу-ноутах, он называется App4Graphs.net.
4917.48 4927.32 "Анатолий Кулаков" Там вы можете ввести теги, на каком языке вам интересно бы поконтрибьютить, и он для вас предоставит список всех тех ish.u, которые созданы специально для App4Graphs.
4927.32 4933.84 "Анатолий Кулаков" То есть он смотрит на те лейблы, которые выше сказал Игорь, собирает их в один сервис и производит по ним поиск.
4933.84 4953.52 "Анатолий Кулаков" Если вы используете в вашем проекте какой-нибудь Nuget пакет или какой-нибудь open-source движок, или какой-нибудь open-source пакет, зайдите на App4Graphs, введите его в поиски и посмотрите, какие ish'и требуют срочного внимания, и может быть вам не составит труда законтрибьютить туда и внести свою лепту в open-source.
4953.52 4958.64 "Игорь Лабутин" А после этого ваш код окажется замороженным где-то там в какой-то арктической горе и вот это все.
4958.64 4963.40 "Игорь Лабутин" Или на силиконовых или каких-то там кремниевых пластинах с кем-то секундным лазером.
4963.40 4965.60 "Игорь Лабутин" Это же прикольно, мне кажется вообще.
4965.60 4969.12 "Анатолий Кулаков" Об этом можно будет рассказывать потомкам, ровно через 10 тысяч лет.
4969.12 4970.12 "Анатолий Кулаков" Да.
4970.12 4971.12 "Анатолий Кулаков" Ну что, давай закругляться?
4971.12 4972.12 "Игорь Лабутин" Да, давай.
4972.12 4977.20 "Игорь Лабутин" Ну что, мы много сегодня с одной стороны обсудили, с другой стороны прям новостей-новостей.
4977.20 4982.96 "Игорь Лабутин" Не так, чтобы много, но тем не менее, давайте быстро вспомним, что мы сделали и про что мы поговорили.
4982.96 4985.48 "Игорь Лабутин" Во-первых, мы напомнили, как нас надо слушать.
4985.48 4990.80 "Игорь Лабутин" Я думаю, что еще раз надо сказать, что это можно делать в вебе, это можно делать в специальных приложениях, это можно делать в RSS.
4990.80 4994.08 "Игорь Лабутин" В общем, есть куча разных способов.
4994.08 4999.44 "Игорь Лабутин" Заходите, слушайте нас, хотя если вы это слышите, вы и так уже нас слушаете, и это уже здорово.
4999.44 5005.52 "Игорь Лабутин" Дальше мы прошлись по новинкам .NET 5, их становится чуть меньше, потому что релиз близится, но тем не менее.
5005.52 5008.56 "Игорь Лабутин" Войны за ключевые слова для паттерн-мастинга еще не прекратились.
5008.56 5012.52 "Игорь Лабутин" And/or/not, может войдут, может не войдут в этом виде в язык.
5012.52 5018.44 "Игорь Лабутин" Обзор перформанс-импрувментов .NET 5, 250 pull-requests в одной статье.
5018.44 5022.16 "Игорь Лабутин" Почитайте, восхититесь и посмотрите, как это все живет и работает.
5022.16 5028.72 "Игорь Лабутин" Тулинг был представлен Visual Studio Codespaces и новым гид-экспириенсом Visual Studio.
5028.72 5032.80 "Игорь Лабутин" Мы поговорили немножко про то, как нужно улучшать и обновлять свои знания.
5032.80 5043.48 "Игорь Лабутин" Это есть отличный ресурс по карту знаний .NET программиста и новая коллекция гайдов от JetBrains по .NET, Rider или Sharper.
5043.48 5051.24 "Игорь Лабутин" Напомнили, или точнее узнали, как у нас теперь будет обстоять дело с лицензированием JetBrains продуктов в .NET мире.
5051.24 5054.28 "Игорь Лабутин" И поговорили про более технические темы.
5054.28 5063.76 "Игорь Лабутин" Это что такое ThreadLocal, как вообще жить с этим в современной мире тасков, что такое SeedCloakal, какие трудности с этим бывают и что почитать на эту тему.
5063.76 5069.68 "Игорь Лабутин" Ну и закончили обзором того, куда можно поконтрибьютить и как вообще это правильно делать.
5069.68 5073.20 "Анатолий Кулаков" А я напоминаю, что с вами был Radio.NET.
5073.20 5079.00 "Анатолий Кулаков" Нас можно найти на сайте radio.net.ru, а также в любом подкаст-плеере.
5079.00 5082.08 "Анатолий Кулаков" Просто наберите в поисковике и найдете наш подкаст.
5082.08 5087.40 "Анатолий Кулаков" Если захотите что-нибудь прокомментировать, то лучшее место сейчас - это наши выпуски на YouTube.
5087.40 5094.12 "Анатолий Кулаков" Там разворачиваются довольно бурные комментарии, поэтому если будете пробегать мимо YouTube, нам будет приятно, если вы черкнете нам парочку строчек.
5094.12 5098.96 "Анатолий Кулаков" А также распространяйте нас, советуйте нас своим друзьям, советуйте нас своим коллегам.
5098.96 5103.52 "Анатолий Кулаков" Мы будем очень рады, если нас станет слушать еще немножко побольше людей.
5103.52 5106.40 "Игорь Лабутин" Да, на этом мы прощаемся с вами.
5106.40 5107.40 "Игорь Лабутин" И всем пока.
5107.40 5107.90 "Игорь Лабутин" Всем пока.
