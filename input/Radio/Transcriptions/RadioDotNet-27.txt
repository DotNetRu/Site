0.00 6.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
6.36 10.40 "Анатолий Кулаков" В эфире Radio.net, выпуск номер 27.
10.40 12.60 "Анатолий Кулаков" Сегодня с вами, как всегда, Анатолий Кулаков.
12.60 13.60 "Анатолий Кулаков" И Игорь Лабутин.
13.60 21.20 "Анатолий Кулаков" Мы хотели бы выразить благодарность, большое спасибо Александру за то, что крепко нас поддерживает, и вообще большое спасибо всем нашим патронам.
21.20 24.04 "Анатолий Кулаков" Мы всегда очень рады любой вашей помощи.
24.04 28.24 "Игорь Лабутин" Майкрософт, как и обещал, начал выпускать превьюшки довольно регулярно.
28.24 34.28 "Игорь Лабутин" Вышла .NET 6 Preview 3 вместе со всеми компонентами VDS Panet Core и Entity Framework Core.
34.28 39.48 "Игорь Лабутин" И давайте, как обычно, проберемся по тем нововведениям, которые нам завезли в последний месяц.
39.48 52.88 "Игорь Лабутин" Майкрософт честно говорит, что этот релиз он практически полностью посвящен всякому low-level performance, и поэтому вы вряд ли будете ожидать там каких-то суперпользовательских, так скажем, фич, но тем не менее некоторые все равно завезли.
52.88 54.04 "Игорь Лабутин" Поехали по порядку.
54.04 56.76 "Игорь Лабутин" Сначала идет раздел «Библиотеки».
56.76 63.12 "Игорь Лабутин" Внезапно в него попадают две вещи, которые я бы не сильно сказал, что относятся в раздел «Библиотеки», но тем не менее.
63.12 68.60 "Игорь Лабутин" Во-первых, теперь есть возможность гораздо быстрее работать со структурами, которые вы храните в словариках.
68.60 84.12 "Игорь Лабутин" Если у вас какой-то high-performance сценарий, и вы в качестве значений словарей храните структуру, то до этого превью, чтобы поменять там значение, вам нужно было забрать структуру к себе в стек, по сути она копируется в этот момент, поменять в ней значение и положить обратно в словарь.
84.12 85.52 "Игорь Лабутин" Она снова копировалась.
85.52 97.00 "Игорь Лабутин" Теперь есть специальный метод collections.marshall.getValueRef or nullRef, который вам вернет Ref-ссылку на эту структуру прямо in place внутри словаря, и вы можете поменять ее прямо там.
97.00 98.00 "Анатолий Кулаков" Вот это hard-code.
98.00 101.28 "Анатолий Кулаков" Вообще прямо на Assembly переходим, я чувствую, скоро взлетим.
101.28 112.32 "Игорь Лабутин" Ну вот да, это прям такой низкий-низкий уровень, наверняка это потребовалось в каком-нибудь очень хитром сценарии внутри самого фреймворка, но тем не менее теперь это вам доступно тоже.
112.32 119.24 "Игорь Лабутин" И вторая штука, которую улучшили, это более шустрое приведение типов и проверка интерфейса.
119.24 128.12 "Игорь Лабутин" Всякие операторы из касты к нужным интерфейсам, они ускорились по заверениям Microsoft где-то от 16 до 38%.
128.12 135.44 "Игорь Лабутин" Понятно, что в абсолютных числах это там милли, нано, секунды, но тем не менее операция вероятно частая.
135.44 160.64 "Игорь Лабутин" Как обычно много улучшений в рантайме, я не буду вдаваться в подробности всех улучшений, которые туда завезли, в основном это всякий код-эген, то есть все еще улучшается JIT, улучшается возможность того, насколько быстрый и насколько оптимальный код у нас глядится, все больше и больше моментов он умеет определять и понимать, что там где-то что-то можно соптимизировать, завязать какие-нибудь там, не знаю, интринсики, еще что-нибудь.
160.64 165.60 "Игорь Лабутин" Если интересно, смотрите статью, там все аккуратные ссылочки на GitHub issues приведены.
165.60 182.66 "Игорь Лабутин" Мы много раз рассказывали про .NET Hot Reload и наконец-таки можем его нормально попробовать, потому что завезли штуку под названием Initial .NET Hot Reload Support for Web Apps, то есть они теперь доступны для вебапов, для ваших SP-Netcore и Blazor.
182.66 196.96 "Игорь Лабутин" Можно запустить, посмотреть и используя .NET Watch вы сможете наблюдать как ваш C# код, который вы меняете на плиту, декомпилируется и работает в Runtime.
196.96 208.84 "Анатолий Кулаков" Это уже именно C# код, это не Razer какой-нибудь, не JavaScript, не TypeScript, это настоящий C# код в моей бизнес-логике, в моей инфраструктуре, там, коннекты к базе данных, вот они будут Hot Reloaded.
208.84 210.84 "Игорь Лабутин" Да-да-да, это настоящий C# код.
210.84 227.08 "Игорь Лабутин" Для того, чтобы это все работало, нужно немножечко поправить ваш launch settings.json, нужно добавить туда сеттинг под названием Hot Reload Profile, у него есть два значения пока, это ISP-Netcore либо Blazor WASM, и после этого у вас все будет работать.
227.08 240.04 "Игорь Лабутин" По умолчанию .NET Watch будет следить за вашим приложением C# исходниками, CSS, ну короче все, что у вас там есть в вашем Blazor либо ISP-Netcore приложении, и релоадить их по мере их изменения.
240.04 251.68 "Игорь Лабутин" Не все поддержано сейчас в режиме Hot Reload, и по большому счету, линк на то, что поддержано, ведет внезапно на статью про Edit and Continue в редакторе, в смысле в отладчике.
251.68 262.04 "Игорь Лабутин" То есть, все то, что вы могли делать в формате "я отлаживаю программку, поменяю код и она все еще работает", то есть Edit and Continue, все то же самое сейчас доступно в Hot Reload.
262.04 273.28 "Анатолий Кулаков" А есть какой-нибудь подробный список, что, ну вот допустим я открыл коннекцию к базе данных и поменял там какие-то строчки, вот что в нем, эта коннекция закроется, библиотечка выгрузится, статические перемены почистятся или как?
273.28 280.28 "Игорь Лабутин" Там есть четкий список, что можно менять, вплоть до того, какие методы можно менять, сигнатуры, что можно переименовывать, что нельзя переименовывать.
280.28 287.80 "Игорь Лабутин" По ссылкам из статьи там все четко подробно расписано и все должно работать согласно этой спецификации.
287.80 304.08 "Игорь Лабутин" А если вдруг весь этот рантайм вот этого Hot Reload поймет, что вы поменяли что-то, что он не может отработать в режиме Hot, то я так понимаю, что у него можно настроить, чтобы он автоматически быстренько пересобрал и перезапустил приложение.
304.08 306.16 "Игорь Лабутин" Ну и вы это можете сделать из консоли тоже руками.
306.16 311.16 "Игорь Лабутин" Ctrl + R нажать и он автоматически соберет, перезапустит без выхода из DotNet Watch.
311.16 317.92 "Анатолий Кулаков" Ну интересно, да, надо пробовать, посмотреть, что из этого работает и каким образом он ведет себя на всяких сложных ситуациях.
317.92 331.04 "Игорь Лабутин" Ну да, я допускаю, что это может быть интересно, когда вы меняете контроллер, например, на лету, что-нибудь пробуете, что-то не заработало, поменяли контроллер по-другому, еще раз попробовали, интересно, что будет происходить, допустим, с регистрацией контроллеров, если я новый добавлю.
331.04 333.36 "Игорь Лабутин" Поймет он на лету, что я добавил новый контроллер?
333.36 340.68 "Анатолий Кулаков" Да, действительно, это легко понимается про всякие веб-сервера, ну то есть такие динамические вещи, которые в основном не содержат никакого стейта.
340.68 347.32 "Анатолий Кулаков" А вот что делать со стейтом, то есть нельзя же просто так выгрузить классы, загрузить на его место под тем же самым минимум другой класс.
347.32 349.00 "Анатолий Кулаков" У класса есть какое-то состояние.
349.00 351.00 "Анатолий Кулаков" Что будет именно с этим состоянием, вот это уже
351.00 358.24 "Игорь Лабутин" не ясно. Все правильно, состояние, есть куча там замыканий возможно внутри там куда-то, какие-нибудь таски где-нибудь висят в каких-нибудь AsyncState машинах.
358.24 368.32 "Игорь Лабутин" В общем, ограничений наверняка много, но команда обещает, что будет очень плотно работать над увеличением списка того, что поддержано в режиме Hot Reload.
368.32 379.72 "Игорь Лабутин" Мы на самом деле уже перешли к тому, что находится в разделе ASP.NET Core, потому что в основном все-таки это поддержано для ASP.NET Core, ну и Blazor тоже, но Blazor традиционно относится к ASP.NET Core новостям.
379.72 389.08 "Игорь Лабутин" И еще одна штука там, это улучшили скрипты, JavaScript для SignalR, Blazor и MessagePack поддержки.
389.08 401.08 "Игорь Лабутин" То есть те JavaScript, которые вы тащите в браузер, чтобы работать со стороны клиента, веб-клиента с SignalR, с Blazor или с MessagePack, теперь стали на примерно 45-70% меньше.
401.08 406.96 "Анатолий Кулаков" А MessagePack сходит в стандартную поддержку в Blazor или это просто сторонняя библиотечка, если поставить?
406.96 440.52 "Игорь Лабутин" MessagePack используется в SignalR, и мы на самом деле это обсуждали довольно много выпусков назад, что долгое время была библиотечка MessagePack для C#, и она хорошо работала, я ей даже пользовался в своих рабочих проектах, но она была как-то заброшена, там не было модных спанов и вот этого всего, но в какой-то момент MessagePack потребовался Microsoft для SignalR, и они отредили там одного или команду даже людей помочь автору MessagePack перевести его на современные рельсы современного дотанета, всякая спонификация, вот это все.
440.52 454.88 "Игорь Лабутин" И сейчас есть MessagePack библиотечка для C#, которая наполовину написана под руководством и содействием Microsoft, она есть для C#, и соответственно есть ее JavaScript аналог, который позволяет декомпрессировать весь этот MessagePack обратно, децерализовывать в JavaScript.
454.88 470.52 "Игорь Лабутин" Но библиотечки были большие, даже после минификации они все-таки занимали какое-то определенное место, и вот внезапно Ben Adams смог их уменьшить примерно на 45-70%, так что он не только по C# мастер, но и по JavaScript тоже, как выясняется.
470.52 471.52 "Игорь Лабутин" Так, поехали дальше.
471.52 502.32 "Игорь Лабутин" Потихонечку-потихонечку движется поддержка HTTP/3, мне кажется, что даже HTTP/2-то не сильно широко распространен, чтобы уж прям в каждом endpoint-е торчать, но Microsoft потихоньку двигает HTTP/3, и теперь его можно настроить через стандартные Kestrel-настройки с учетом TLS, и как они заверяют, теперь, соответственно, настройка вот уровня транспорта полностью поддержана на уровне Kestrel, то есть через стандартные опции Kestrel можно все настраивать и HTTP/3 тоже.
502.32 506.76 "Игорь Лабутин" Не знаю, где Microsoft это использует внутри, но может, в этом будущее, посмотрим.
506.76 510.20 "Игорь Лабутин" Так, давайте пойдем дальше.
510.20 511.20 "Игорь Лабутин" Razer.
511.20 522.64 "Игорь Лабутин" Razer такая штука, которая, я так понимаю, не знаю, честно говоря, насколько часто пользуется с точки зрения прям вот views и в продакшене, я это в основном использовал только для каких-то модельных примеров.
522.64 530.40 "Анатолий Кулаков" Ну подожди, подожди, Razer сейчас используется в Blazor, значит Razer сейчас пользуется просто везде, всегда и продвигается очень много.
530.40 534.20 "Игорь Лабутин" Окей, ты у нас специалист по Blazor, будешь меня поправлять, значит.
534.20 543.80 "Игорь Лабутин" Вот, когда Razer компилировал views, как я понимаю, если я правильно действительно помню, так и было, создавалась отдельная сборка, в которой эти views лежали.
543.80 548.96 "Игорь Лабутин" Сейчас это поменяли, теперь это все компилируется в вашу основную сборку, туда же, куда компилируется ваш C-Sproj.
548.96 562.52 "Игорь Лабутин" Все эти классы кладутся в специальный namespace, ASP.NET Core Generated Document, и имеют атрибутики InternalSealed, то есть в общем они никому не доступны извне, от них нельзя наследоваться, они просто там лежат.
562.52 577.12 "Игорь Лабутин" Это было нужно для двух целей, во-первых, это позволяет делать single file deployments проще, ну, потому что на один файл меньше, а во-вторых, это было нужно для hot reload, так проще делать тот самый hot reload, чтобы когда вы меняете views, она автоматом хорошо перегружалась.
577.12 581.96 "Анатолий Кулаков" Это делается с помощью созданных генераторов, или какими-то другими способами?
581.96 595.28 "Игорь Лабутин" Вот тут я не знаю, но Razer Compiler, похоже, что это все-таки именно в самом компиляторе вот Razer части что-то поменяли, то есть это именно прям внутри компилятора замена, а не просто какой-то внешний дополнительный source-генератор.
595.28 600.64 "Игорь Лабутин" По крайней мере по описанию, я не смотрел GitHub'ы сейчас на эту тему, можно порыться поискать, не выяснял.
600.64 626.20 "Игорь Лабутин" Дальше, для тех, кто до сих пор все еще пользуется Ease, теперь есть новый экспериментальный сеттинг, который называется Shadow Copy, то есть теперь можно Ease попросить не просто запускать вашу веб-сервис или приложение из того места, которое вы указали, а делать shadow copy, это позволяет соответственно там всякие ревилдить и так далее, гораздо более просто.
626.20 641.96 "Игорь Лабутин" Ease не будет блокировать файлики, очень удобно и наверное в основном предназначено для девелопмента, но может быть это доберется и до каких-то нормальных целей, хотя сейчас этот сеттинг называется Experimental, то есть он такой еще ранней стадии эксперимента, поэтому пока используется только для разработки.
641.96 650.80 "Игорь Лабутин" Как я говорил, это все у нас про перформанс, этот релиз, хотя я вон уже сколько фич назвал и все, не совсем про перформанс, но тем не менее.
650.80 662.04 "Игорь Лабутин" Фича про перформанс это уменьшение объема памяти, казалось бы куда еще, Kestrel там уже заоптимизирован до сапаса, но я не могу, но тем не менее нашлось еще кусочек, где есть что сэкономить.
662.04 681.88 "Игорь Лабутин" Как выясняется, если у вас достаточно много TLS connections, которые ничего не делают, я так понимаю всякие веб-сокеты висят, еще какая-нибудь такая штука типа там long polling и там ничего не происходит, то каждый такой connection кушает немножко памяти, ну на самом деле он кушает память на небольшой буфер, который был отдан в асинхронный рит, который собственно ждет, когда что-нибудь придет из сетки.
681.88 696.76 "Игорь Лабутин" Это дело сооптимизировали и теперь туда отдается буфер нулевого размера, поэтому как только что-то придет из сетки, сначала прилетает нотификация, что что-то пришло и тогда уже сп.надкор говорит, а ну тогда вот давай меняй буфер там из пула и давай забирать данные.
696.76 700.80 "Игорь Лабутин" Говорят, что типа около 4 или 8 килобайт на каждый connection сэкономили.
700.80 701.80 "Игорь Лабутин" Неплохо, неплохо.
701.80 704.04 "Игорь Лабутин" Мелочь, а приятно.
704.04 711.12 "Игорь Лабутин" Так, следующий кусочек, наверное, ты, может быть, знаешь даже лучше меня, Blazor WebView Controls для WPF и Windows Forms.
711.12 714.12 "Анатолий Кулаков" Конечно, каждый день WinForm запишу, откуда я его знаю?
714.12 715.44 "Игорь Лабутин" О, ты знаешь слово Blazor.
715.44 721.32 "Игорь Лабутин" Короче, это штука для того, чтобы хостить Blazor компоненты внутри WPF и WinForms.
721.32 728.44 "Игорь Лабутин" Соответственно, вы сможете взять Blazor на кусочек, запихать его в ваше WinForms приложение и внутри WinForms показать Blazor на UI.
728.44 737.08 "Анатолий Кулаков" Я перевожу это вот, когда вы на HeadHunter хантите всякую хипстоту, которая говорит, мы будем только под Webчик писать и все такое.
737.08 740.16 "Анатолий Кулаков" Сейчас все под Webчик верстает, сейчас все под Webчик пишет.
740.16 746.48 "Анатолий Кулаков" Вы их сажаете на Blazor, даете им нормальный HTML, нормальный CSS и нормальный C#.
746.48 754.64 "Анатолий Кулаков" И они это все пишут на новомодных языках, на новомодных технологиях, подворачивают штанишки и чувствуют себя хипстотой-хипстотой.
754.64 769.36 "Анатолий Кулаков" Вы потом, как старый прожженный бородатый интерпрайс, берете все их Web-компоненты, достаете ваше 20-летнее приложение, которое написано на WinForms, которое умеет уже production, стабильность, релиз, доход.
769.36 777.16 "Анатолий Кулаков" И в это ваше WinForms приложение вставляете Blazor WebView и хостите эти хипстерские компонентики.
777.16 784.64 "Анатолий Кулаков" Ваши пользователи довольны, у них появляется прекрасная новая функциональность, быстро, красиво и легко.
784.64 789.88 "Анатолий Кулаков" Ваши разработчики довольны, они пишут на самых последних технологиях, на Blazor и на WebAsm.
789.88 791.08 "Анатолий Кулаков" И вы довольны.
791.08 797.92 "Анатолий Кулаков" Ваше приложение, которое приносит вам, вашей компании, прибыль, продолжает развиваться и поддерживается новыми разработчиками.
797.92 798.92 "Анатолий Кулаков" Все счастливы.
798.92 799.92 "Игорь Лабутин" Вот это Blazor WebView.
799.92 805.08 "Игорь Лабутин" И выглядит уже не совсем как WinForms, а как вполне нормальное визуально современное приложение.
805.08 806.44 "Анатолий Кулаков" Сейчас так модно, да.
806.44 813.28 "Анатолий Кулаков" Сейчас так принято, когда на всех операционных системах вырвиглазные интерфейсы, у всех разное и никто не следит за стилями.
813.28 814.64 "Анатолий Кулаков" Так что это тоже тренд.
814.64 817.16 "Игорь Лабутин" Квадратные кнопочки WinForms, где же вы?
817.16 818.92 "Игорь Лабутин" Ладно, поехали дальше.
818.92 819.92 "Игорь Лабутин" EF Corp.
819.92 821.76 "Игорь Лабутин" EF Corp. в этот раз вообще ничего не будет.
821.76 830.24 "Игорь Лабутин" Команда написала, что да, Preview 3 вышел, но там в основном всякие внутреннеинфраструктурные изменения для поддержки будущих фич, поэтому ничего особо нового нет.
830.24 831.68 "Игорь Лабутин" Говорить не о чем.
831.68 834.80 "Анатолий Кулаков" Ходили в отпуск всей команды, я чувствую, на этот спринт?
834.80 836.44 "Игорь Лабутин" Ну, как вариант.
836.44 843.48 "Игорь Лабутин" Следующая тема имела шанс не попасть в этот выпуск, но внезапно успели ее опубликовать, поэтому успели ее включить.
843.48 846.72 "Игорь Лабутин" Вижу, студию 2019, версия 16.10 Preview 2.
846.72 848.64 "Игорь Лабутин" Ух, длинное название.
848.64 853.32 "Игорь Лабутин" Внезапно это Preview 2, но в ней довольно много интересных фич.
853.32 857.84 "Игорь Лабутин" Они всем почти относятся к категории экспериментальных, но видимо потому, что в том числе это Preview.
857.84 867.44 "Игорь Лабутин" Но если вам интересно, то вы ждите нормальный 16.10 или даже ставьте Preview 2 и смотрите, что там происходит, либо ждите нормальный 16.10, где скорее всего они уже будут работать хорошо.
867.44 869.44 "Игорь Лабутин" Фичи для дотнета.
869.44 882.88 "Игорь Лабутин" Теперь, когда у вас открывается список комплешена, туда добавляются штуки как индексеры, то есть теперь у вас будут, если в вашем классе есть индексер, то он теперь будет в выпадающем списке, ну все они, их может быть несколько.
882.88 888.12 "Игорь Лабутин" Если для вашего класса определены операторы, они тоже будут теперь в выпадающем списке.
888.12 895.72 "Игорь Лабутин" И если у вас определены всякие касты, ну операторы приведения, то они тоже будут в выпадающем списке.
895.72 899.80 "Игорь Лабутин" Не знаю, зачем могут быть комплешены для кастов, потребуется, но тем не менее они есть.
899.80 902.32 "Игорь Лабутин" А индексеры и операторы полезны, мне кажется.
902.32 908.80 "Игорь Лабутин" Следующая штука — это автоматическое добавление методов, аргументов вызова методов.
908.80 931.04 "Игорь Лабутин" Ну это не совсем то, о чем вы подумали, совсем за вас код писаться не будет, но если вы теперь после вызова метода, ну в смысле после открытия круглой скобки нажмете два раза Tab, то вам подставятся все аргументы этого метода, ну их дефолтные значения, то есть если там были boolean, то подставится false, если там int, то null, если string, то наверное null, я не пробовал.
931.04 935.36 "Игорь Лабутин" И таким образом вы сразу видите сигнатуру метода не только в tooltyp.
935.36 936.36 "Игорь Лабутин" А прям вот уже в коде.
936.36 942.44 "Игорь Лабутин" И дальше можете заменять нужные вам аргументы на те, которые не должны иметь дефолтных значений.
942.44 954.68 "Анатолий Кулаков" Я очень часто ловлю себя на мысль, что мне более бы полезен был бы hint, который позволял бы мне добавлять в вызов метода имена переменных, которые совпадают с моим текущим контекстом.
954.68 964.08 "Анатолий Кулаков" Ну то есть если у меня в контексте есть переменные, которые зовут username, и в сигнатуре тоже требуется с таким же типом переменная username, то вот ее туда подставь.
964.08 969.60 "Анатолий Кулаков" У меня очень много таких кейсов, когда нужно просто перегнать то, что у меня есть в локальном скопе.
969.60 972.24 "Анатолий Кулаков" И вот это, блин, очень сильно хочу.
972.24 978.96 "Анатолий Кулаков" Товарищи JetBrains, я знаю, вы нас слушаете, замутите вот tap-tap и матчинг по именам и типам.
978.96 980.24 "Анатолий Кулаков" Цены не будет такой фичи.
980.24 982.44 "Игорь Лабутин" Ну может, кстати, Microsoft что-нибудь подобное сделать.
982.44 988.16 "Игорь Лабутин" Я смотрел только ролик с этой штукой, там просто показано, что вот они там добавляются.
988.16 990.68 "Игорь Лабутин" Но в принципе ничего не мешает это действительно сделать более умно.
990.68 994.80 "Игорь Лабутин" Дальше, добавили редактор для Editor-конфигов.
994.80 1001.24 "Игорь Лабутин" То есть теперь есть нормальный визуальный редактор, в котором можно аккуратненько, визуальненько все поредактировать, все, что есть в вашем Editor-конфиге.
1001.24 1006.32 "Анатолий Кулаков" То есть если ты изменишь какую-то настройку в Editor-конфиге, он тебе визуально покажет, как она изменит твой код?
1006.32 1009.00 "Анатолий Кулаков" То есть как положено, нормальное полноценное превью.
1009.00 1011.28 "Игорь Лабутин" Ну настолько я не знаю.
1011.28 1021.16 "Игорь Лабутин" Я видел только, что именно ты UI-чик где-то там, типа дропдаунами выбираешь всякие значения, насколько оно там одновременно показывает, насколько изменяется твой код.
1021.16 1022.16 "Игорь Лабутин" Я не уверен.
1022.16 1023.16 "Игорь Лабутин" Пока скорее всего этого еще нет.
1023.16 1028.80 "Анатолий Кулаков" Я вот опять со своими же баранами, но отличный вообще редактор настроек есть у JetBrains.
1028.80 1036.28 "Анатолий Кулаков" Не уверен, насколько он на Editor-конфиг работает, но вот на стандартный C# синтаксис у него просто шикарные примеры есть.
1036.28 1043.96 "Анатолий Кулаков" То есть у них там 200 чекбоксов, конечно, но под все эти чекбоксы подобраны очень показательные примеры.
1043.96 1047.04 "Анатолий Кулаков" То есть ты меняешь один чекбокс, и он тебе сразу показывает.
1047.04 1049.88 "Анатолий Кулаков" Вот у тебя код такой был, если ты чекбокс поставил, он таким вот стал.
1049.88 1053.16 "Анатолий Кулаков" Это наглядно, прекрасно и просто великолепно под себя подгонять.
1053.16 1057.16 "Игорь Лабутин" Ну будем надеяться, что Microsoft не отстанет и сделает похожий для Editor-конфигов.
1057.16 1058.16 "Игорь Лабутин" А это превью 2.
1058.16 1059.88 "Игорь Лабутин" Посмотрим, что будет в финальной версии.
1059.88 1065.36 "Игорь Лабутин" А и последнее улучшение в категории для дотнета это визуализация цепочек наследования.
1065.36 1072.56 "Игорь Лабутин" Если вы наведетесь теперь на класс или на интерфейс, то вам покажется Tooltip, где нарисована вся иерархия наследования этого класса.
1072.56 1076.92 "Игорь Лабутин" Ну кто его родители, прародители и так далее до самого верха.
1076.92 1077.92 "Анатолий Кулаков" Вот это полезно.
1077.92 1083.88 "Анатолий Кулаков" Еще неплохо было бы добавить всех, кто от него наследуется для полной компании, хотя бы в рамках этого солюшена.
1083.88 1087.60 "Игорь Лабутин" Ну вот с поиском, кто от него наследуется, видимо чуть сложнее.
1087.60 1091.56 "Игорь Лабутин" Понятно, что это не линейная штука, это все-таки дерево, их там может быть много.
1091.56 1094.08 "Игорь Лабутин" Тут да, чуть сложнее.
1094.08 1097.76 "Игорь Лабутин" Это тоже штука, которую нужно включать в настройках, по дефолту оно выключено.
1097.76 1099.32 "Игорь Лабутин" Так, пошли дальше.
1099.32 1103.96 "Игорь Лабутин" Если вы разрабатываете с контейнерами, то вам возможно будет интересные фичи для контейнеров.
1103.96 1109.00 "Игорь Лабутин" Теперь можно сделать примерно похожую штуку, как была раньше для runMultipleProjects.
1109.00 1120.84 "Игорь Лабутин" Если у вас есть в солюшене несколько проектов, раньше можно было настроить, что при запуске у вас запускается там этот проект просто рано, к этому проекту задать дебайгер, а вот этот не запускай в определенном профайле.
1120.84 1125.96 None Теперь такое можно сделать с контейнерами, вот этот контейнер запусти, вот этот контейнер мы будем отлаживать, этот контейнер не трогай.
1125.96 1136.92 "Игорь Лабутин" Причем эта штука автоматически умеет парсить ваши Docker Compose файлы и понимать вообще, что вам нужно запускать примерно из этого проекта и вы можете подредактировать какие-то дефолтные понимания студии, что с этим делать.
1136.92 1138.92 "Анатолий Кулаков" Не напоминает тебе эта штука Project TIE?
1138.92 1141.56 "Анатолий Кулаков" То есть как-то они сейчас начинают здесь пересекаться.
1141.56 1142.96 "Анатолий Кулаков" Немножко напоминает.
1142.96 1148.96 "Анатолий Кулаков" Было бы, наверное, интересно, если бы они строили TIE или поддержали бы его конфиг или что-то в этом духе.
1148.96 1150.60 "Анатолий Кулаков" Какую-то интеграцию бы сделали.
1150.60 1155.52 "Игорь Лабутин" Ну да, видишь, TIE был, их есть, экспериментальным проектом.
1155.52 1161.36 "Игорь Лабутин" Возможно, они как раз на нем что-то проверяют, а потом оттуда забирают студию непосредственно на хорошее работающее решение.
1161.36 1162.72 "Игорь Лабутин" Да, может быть.
1162.72 1165.76 "Игорь Лабутин" Так, про контейнеры есть еще одно улучшение.
1165.76 1169.20 "Игорь Лабутин" Они называют это Advanced Interactions with Containers.
1169.20 1176.16 "Игорь Лабутин" Там можно нормально работать с лейблами, тегами и можно теперь ходить в вольюмы и смотреть даже внутри файлики.
1176.16 1182.08 "Игорь Лабутин" То есть если у вас есть работающий Docker Container, вы можете пойти и посмотреть, что внутри происходит с точки зрения файликов прямо из студии.
1182.08 1183.08 "Игорь Лабутин" Юнит тесты.
1183.08 1185.56 "Игорь Лабутин" С юнит тестами в основном улучшение про логи.
1185.56 1191.92 "Игорь Лабутин" Если вы пишете в консольку из логов, из юнит тестов, теперь это будет видно в тест-эксплорере.
1191.92 1200.76 "Игорь Лабутин" И если вы пишете довольно много, а много по мнению студии это больше 300 символов, то это автоматически будет запихнуто в специальный файлик, который можно будет отдельно посмотреть.
1200.76 1208.00 "Игорь Лабутин" И если вы в эти файлики пишете линки внезапно, например, в результат тест, какие-нибудь урлы выводят и так далее, урлы стали теперь кликабельными.
1208.00 1210.92 "Игорь Лабутин" Не просто текст, а урлы стали кликабельными.
1210.92 1222.40 "Анатолий Кулаков" Мне кажется, это просто полезная штука, потому что тебе раньше нужно было загоняться к каким-нибудь iOutputProvider, iOutputWriter и прочими глупостями, чтобы писать нормально в тест-эксплорер.
1222.40 1226.36 "Анатолий Кулаков" Хотя гораздо более удобнее это взять и просто в консоль написать.
1226.36 1231.08 "Анатолий Кулаков" И очень полезно из любого места, даже там, где ты не можешь dependency это просунуть.
1231.08 1232.08 "Анатолий Кулаков" Хорошая штука.
1232.08 1239.56 "Игорь Лабутин" То есть интересно, как они это сделали технически, потому что это же нужно по сути, XUnit требует i вот этого testOutput что-то там.
1239.56 1241.60 "Игорь Лабутин" То есть они видимо как-то автоматически это делают.
1241.60 1242.60 "Игорь Лабутин" Непонятно.
1242.60 1246.72 "Игорь Лабутин" Так, есть еще ряд улучшений в Git'е.
1246.72 1255.24 "Игорь Лабутин" Если вы пользуетесь Visual Studio как Git-клиентом, ну в смысле не только как Git-клиентом, но в том числе и Git-клиентом, посмотрите, говорят там улучшилось все.
1255.24 1258.12 "Игорь Лабутин" Я не пользуюсь, тут сильно много ничего рассказать не смогу.
1258.12 1264.12 "Игорь Лабутин" Ну и если вы вдруг заходите в C++, есть довольно большой список C++ улучшений, но мы их касаться не будем.
1264.12 1265.12 "Игорь Лабутин" Мы предвзяты.
1265.12 1266.12 "Игорь Лабутин" Ну да, немножко off-topic.
1266.12 1272.88 "Игорь Лабутин" Я очень давно не занимался C++, особенно современным, поэтому я не сильно знаю, что происходит в современном C++.
1272.88 1278.04 "Анатолий Кулаков" Но зато мы хорошо знаем, что происходит в современном C#, .NET и все, что с этим связано.
1278.04 1284.60 "Анатолий Кулаков" И вот еще один поворот в развитии языка в .NET.
1284.60 1290.20 "Анатолий Кулаков" Это анонсирование нового .NET репозитория.
1290.20 1292.80 "Анатолий Кулаков" Называется он Open Source C# Standardization.
1292.80 1296.16 "Анатолий Кулаков" Итак, немножко исторической справки от Билла Вагнера.
1296.16 1301.76 "Анатолий Кулаков" Прежде всего у нас есть .NET компилятор, который сейчас называется Roslyn.
1301.76 1305.84 "Анатолий Кулаков" Располагается он в репозитории на GitHub в .NET Roslyn.
1305.84 1318.84 "Анатолий Кулаков" Это имплементация самого, непосредственно самого компилятора и всех инструментов, которые связаны с ним и как это располагается вокруг него, помогают компилировать, дебажить и полностью обеспечивают инфраструктуру.
1318.84 1323.72 "Анатолий Кулаков" Также выделился репозиторий C# LANG.
1323.72 1331.64 "Анатолий Кулаков" Здесь находятся всякие дискуссии, документы про развитие языка, про его дизайн, про его эволюцию.
1331.64 1336.60 "Анатолий Кулаков" Также там есть куча интересных проектов, которые показывают, как это может выглядеть, как это сделать.
1336.60 1344.36 "Анатолий Кулаков" В общем, это такая площадка, которую используют для того, чтобы проработать новые фичи языка.
1344.36 1350.62 "Анатолий Кулаков" И вот сейчас как раз-таки анонс третьего репозитория, который выделился из этой стаи.
1350.62 1353.56 "Анатолий Кулаков" Называется он C# Standard.
1353.56 1360.00 "Анатолий Кулаков" Это репозиторий, который призван для того, чтобы объединить сообщества вокруг ECMO стандарта.
1360.00 1372.88 "Анатолий Кулаков" Как, наверное, многие из вас знают, что C# является ECMO стандартом, то есть для него есть формальное описание, которое открыто, которое доступно абсолютно каждому, формальное описание языка.
1372.88 1386.40 "Анатолий Кулаков" И вот для того, чтобы это формальное описание лучше поддерживалось, у него были хорошие инструменты, у него была отдельная понятная площадка для обсуждений и был сделан вот этот третий репозиторий.
1386.40 1394.68 "Анатолий Кулаков" С помощью этого репозитория предполагается, что станет намного легче работать над стандартом, потому что у нас будет отдельное место.
1394.68 1402.24 "Анатолий Кулаков" В этом репозитории призывают всех участников задавать вопросы, которые связаны со стандартом языка и его будущих версий.
1402.24 1415.80 "Анатолий Кулаков" В этом репозитории можно спросить одновременно и команду, которая разрабатывает сам язык, задать вопросы, команду, которая разрабатывает компилятор и в то же самое время сообщество, которое поддерживает данный стандарт.
1415.80 1417.16 "Анатолий Кулаков" Что сейчас делается?
1417.16 1423.40 "Анатолий Кулаков" Сейчас уже переносятся ишисы из старых репозиториев, они переносятся уже сюда в новый репозиторий.
1423.40 1432.76 "Анатолий Кулаков" Сейчас замещается документация, чтобы она бралась непосредственно из последнего экмастандарта в микрософтовский докс и так далее.
1432.76 1444.52 "Анатолий Кулаков" В общем, такая небольшая коротенькая новость про новый репозиторий, который может быть интересен тем, кто загоняется именно в стандартизацию языка и смотрит о том, каким образом это должно работать.
1444.52 1450.88 "Игорь Лабутин" А вот про ишис я не понял, то есть не все же ишис перерезжают, а именно только те, которые касаются стандарта?
1450.88 1457.52 "Анатолий Кулаков" Да, просто раньше все вопросы по стандарту задавались или в Roslin репозитории, или, что чаще, в C# ленге.
1457.52 1461.52 "Анатолий Кулаков" И там их накопилось уже довольно большое количество и вот их сейчас как раз таки и переносят.
1461.52 1474.52 "Игорь Лабутин" Окей, то есть, ну, Roslin понятно, что никуда не денется и C# ленг тоже, видимо, никуда не денется, там продолжатся обсуждения новых идеи и фич языка, а в C# стандарт будет именно работа по стандартизации того, что уже есть.
1474.52 1477.40 "Анатолий Кулаков" Да, да, только по ECMO стандарту, все туда.
1477.40 1479.60 "Игорь Лабутин" Окей, хорошо, погнали дальше.
1479.60 1512.92 "Игорь Лабутин" В .NET 6 у нас должен выйти нормальный кроссплатформенный UI, который должен заработать на всех платформах, в принципе он уже до некоторой степени есть, ведь Xamarin.Forms, но его причесывают в .NET 6 и в рамках причесывания Microsoft сделала отдельные репозитории, называется .NET 6 Mobile Samples, это примеры кода приложений, пока довольно тривиальных, но тем не менее, которые можно взять и запустить на мобильничках, это iOS и Android на 6 .NET.
1512.92 1529.48 "Игорь Лабутин" При этом это не просто солюшен и пачка проектов, вы можете склонировать и запустить, это довольно детальный гайд по тому, как это все делать, что вам нужно на Андроиде, чтобы это все запустить и скомпилировать, что вам нужно для iOS, чтобы это все запустить и скомпилировать.
1529.48 1543.58 "Игорь Лабутин" Пока, как я сказал, все довольно на ранней стадии, но работа будет вестись и репозитории будут обновляться по мере того, как туда будут добавляться новые фичи и большее количество платформ или большее количество фич будет поддержано для разных платформ.
1543.58 1561.00 "Игорь Лабутин" Так что, если вы каким-то образом смотрите в сторону кроссплатформенной разработки и вам интересно, как на 6 .NET писать под iOS и Android, то идите туда, клонируйте репозиторий, читайте инструкцию, смотрите какие там SDK и прочее надо, собирайте и пробуйте запускаться.
1561.00 1573.28 "Анатолий Кулаков" Вот еще интересно, несмотря на то, что называется Mobile Samples, там также есть примеры для macOS, для WinUI, ну то есть это не только для мобильных, здесь есть примеры и для десктопов, странное название они выбрали.
1573.28 1582.72 "Игорь Лабутин" Это правда, почему непонятно, тут объяснить пока невозможно и я такого объяснения не вижу.
1582.72 1598.56 "Игорь Лабутин" При этом надо предупредить, что для некоторых фич и для некоторых платформ вам будут нужны превью версии разных штук, то есть в частности мы описывали версию Visual Studio 16.10 Preview 2, для некоторых вещей, которые описаны в этом репозитории, она уже необходима.
1598.56 1605.32 "Игорь Лабутин" Так что, если вы туда собираетесь нырять и пробовать всякие такие штуки, будьте готовы, что нужно будет ставить превьюшки.
1605.32 1615.24 "Анатолий Кулаков" А еще здесь прямо с первых релизов, с первых дней, это еще не релиз конечно, с первых дней репозитория есть уже, примеры на F#, что тоже не может не радовать, но это не финансы.
1615.24 1616.56 "Игорь Лабутин" Да, это действительно приятно.
1616.56 1640.48 "Игорь Лабутин" F#, F#, но у нас есть C# и надо сказать, что в целом по C# после того, как вышла 9 версия вместе с пятым дотнетом, не сильно много новостей, то ли это затишье перед тем, как она будет добавлена на какие-то киллер фичи, то ли C# 9 уже настолько хорош, что все сейчас сконцентрированы на том, чтобы сделать нормальный дотнет 6 как платформу и не трогать пока язык.
1640.48 1651.88 "Игорь Лабутин" Но тем не менее, потихонечку работа над C# тоже ведется, и один из пропозолов хочется обсудить, а именно interpolated string support в 10 C# уже.
1651.88 1656.52 "Анатолий Кулаков" Ну у нас же interpolation string уже давно поддерживается, в чем новость?
1656.52 1677.28 "Игорь Лабутин" Он действительно давно поддерживается, он умеет делать достаточно интересные штуки, то есть напоминаю, что string interpolation, когда вы пишете доллар перед строчкой, после этого вы внутри можете использовать не просто позиционные placeholders, там 0 в фигурных скобочках, 1 в фигурных скобочках, а прямо в фигурных скобочках писать выражения, которые будут подсчитываться и результат вставляться в строчку.
1677.28 1682.40 "Игорь Лабутин" Методов, собственно, такого вставления есть 3 у компилятора.
1682.40 1692.92 "Игорь Лабутин" Если компилятор понимает, что все то, что вы туда впихнули в виде placeholders, это константы, он это сделает, может быть, даже на уровне compile time и схлопнет вашу строчку в константу.
1692.92 1694.08 "Игорь Лабутин" Но это, понятно, редкость.
1694.08 1703.88 "Игорь Лабутин" Вторая штука, если компилятор понимает, что таких placeholders у вас не очень много, то он может сделать конкатенацию строчек.
1703.88 1722.68 "Игорь Лабутин" С конкатенацией есть проблема, потому что, как мы знаем, string concat имеет, скажем так, несколько только перегрузок с конечным числом аргументов, и если число аргументов превышает 3, 4, 5, не помню сколько, то происходит дальше аллокация массива, куда складываются все строчки, которые нужно склеить.
1722.68 1734.84 "Игорь Лабутин" Либо, в самом плохом случае, интерполяция строк это вызов по сути string format, что тоже приведет к тому, что будет залокечен массив и со всеми вытекающими последствиями.
1734.84 1751.20 "Игорь Лабутин" Помимо этого, все те штуки, которые вы передаете в виде значений placeholders, обычно даже будут бокситься, потому что они могут потенциально быть запихнуты в массив и обязаны иметь возможность забокситься.
1751.20 1758.88 "Игорь Лабутин" Поэтому, например, сейчас есть ограничения, туда нельзя передавать refstructs, ну и всякие такие штуки, которые вы не сможете боксить, спаны, например.
1758.88 1769.72 "Игорь Лабутин" То есть, если вы вырезали какой-нибудь slice из строчки и хотите этот slice span передать в какой-нибудь следующий interpolated string, ну так нельзя, не работает сейчас.
1769.72 1778.56 "Игорь Лабутин" Есть пропозона от Стивена Тауба, что "а давайте мы не будем использовать конкатенацию строк или string format для того, чтобы собирать эту интерполированную строчку".
1778.56 1780.72 "Игорь Лабутин" Ведь по сути, что такое интерполированная строчка?
1780.72 1793.92 "Игорь Лабутин" Весь текст до первого вхождения вашего, так сказать, аргумента, потом вот это значение первого placeholder, потом кусочек строчки до второго placeholder, потом второй placeholder.
1793.92 1802.44 "Игорь Лабутин" Так давайте компилятор при компиляции такого кода будет разбивать это по сути на вызов некоторого подобия stringbuilder, где будет вызывать много-много-много раз метод append.
1802.44 1803.44 "Игорь Лабутин" В чем бонусы?
1803.44 1818.16 "Игорь Лабутин" Бонусы в том, что метод append мы будем вызывать непосредственно на тех выражениях, которые вы передали, а это означает, что во-первых, это будут уже просто обычные аргументы функции, то есть туда можно будет передавать всякие и refstruct, и span, и что хотите.
1818.16 1828.64 "Игорь Лабутин" А второе, можно написать огромное количество специализированных append для int, для double, для boolean, для чего угодно, которые будут приводить к тому, что не нужно будет ничего боксить.
1828.64 1834.00 "Игорь Лабутин" И наконец-то Киришар перестанет вам писать, что "вот тут надо вызвать toString, иначе будет боксинг".
1834.00 1835.48 "Игорь Лабутин" Вот такая вот идея.
1835.48 1854.88 "Игорь Лабутин" Она довольно детально прописана Стивеном, то есть там такой многоэкранный большой пост в репозитории runtime, потому что по сути мы не сильно меняем именно public API, можно сказать, вы точно также пишете интерполированные строчки, но под капотом все будет работать чуть-чуть по-другому, если это примут и заимплементят.
1854.88 1874.02 "Игорь Лабутин" А кроме того, есть еще вторая часть этого пропозала, это отдельный большой ish.io, где уже предлагается расширить немножко идею строк интерполяции, потому что теперь у нас будет билдер, на котором мы вызываем кучку методов.
1874.02 1881.26 "Игорь Лабутин" И может случиться так, что мы хотим использовать какой-то кастомный билдер, а не встроенный.
1881.26 1893.90 "Игорь Лабутин" И есть предложение дать возможность на ваших интерполированных строчках специальным атрибутом навешивать тип билдера, который хочется, чтобы компилятор вызывал, и передавать туда еще какой-то state.
1893.90 1900.04 "Игорь Лабутин" В общем, интерполированные строчки, по-моему, скоро будут по сложности сравнимы с паттерн-матчингом, если все это, конечно, примут.
1900.04 1903.80 "Игорь Лабутин" Но это уже такой экстенджинг, который пока в стадии обсуждения очень раннего.
1903.80 1905.24 "Игорь Лабутин" Надо вообще такое, не надо.
1905.24 1908.64 "Игорь Лабутин" Но там уже есть, наверное, 2 или 3 use-case, где это, может быть, полезно.
1908.64 1910.12 "Анатолий Кулаков" Вот хотелось бы, конечно, реальные примеры от них.
1910.12 1913.84 "Анатолий Кулаков" Зачем они так загоняются в таком, казалось бы, неочевидном месте?
1913.84 1915.84 "Игорь Лабутин" Ну, в первом случае я более-менее понимаю, зачем.
1915.84 1925.06 "Игорь Лабутин" Ну, то есть, действительно, иметь возможность свободно передавать в интерполированную строчку все, что угодно, не задумываясь о боксинге и всем остальном, это хорошо.
1925.06 1934.06 "Игорь Лабутин" Если просто строчку интерполированную переписать на вот такой stringbuilder-like код внутри компилятора, то мне от этого хуже не станет,
1934.06 1936.06 "Анатолий Кулаков" например. Ну, подожди, тебе же станет хуже.
1936.06 1947.10 "Анатолий Кулаков" У тебя будет на каждую строчку создаваться новый класс, который называется stringbuilder-like interpreter, и у него будет еще дергаться десяток методов, которые тоже там внутри себя могут иметь все что угодно.
1947.10 1948.66 "Анатолий Кулаков" А так у тебя просто массив и все.
1948.66 1949.66 "Игорь Лабутин" Ну, массив.
1949.66 1952.58 "Игорь Лабутин" Ну, это тоже не так дешево, а так, может, структуру будет, а не builder.
1952.58 1953.58 "Игорь Лабутин" Ну, в смысле, не класс.
1953.58 1957.78 "Анатолий Кулаков" Хорошо, это, да, интересный вопрос, надо бы его померить, но все-таки мотивация.
1957.78 1960.26 "Анатолий Кулаков" Вот ладно, первую часть я с тобой согласен.
1960.26 1967.18 "Анатолий Кулаков" Насчет второй части, то есть зачем так сильно загоняться насчет кастомных interpolation builder в этих?
1967.18 1977.18 "Игорь Лабутин" Я так понимаю, что основной кейс, скорее всего, идет откуда-то из разряда span-adcores, и это называется иметь возможность писать напрямую в спаны.
1977.18 1981.74 "Анатолий Кулаков" Вот, писать напрямую в спаны, это тоже хорошо, но почему нельзя обойтись без interpolation здесь?
1981.74 1992.54 "Игорь Лабутин" Потому что хочется это сделать так, чтобы не надо было вводить какие-то дополнительно отдельные сущности, а можно было бы писать прямо так, скажем так.
1992.54 1998.46 "Анатолий Кулаков" Мне кажется, там, где у тебя performance critical code, ты там не должен хотеть писать удобно, красиво и все такое.
1998.46 2006.30 "Анатолий Кулаков" То есть вот эти все interpolation, рюшечки, линкочки и прочие глупости, это вот надо оставить для тех мест, которые не critical.
2006.30 2011.46 "Анатолий Кулаков" А где critical, ну уж как-нибудь потерпишь, будешь без interpolation и можешь конкретизировать свои спаны.
2011.46 2020.74 "Игорь Лабутин" Ну, слушай, кажется, может быть нам надо согласиться с тем, что C# уже настолько идеален, что остается только такие рюшечки делать.
2020.74 2021.74 "Анатолий Кулаков" Мне кажется, да, да.
2021.74 2028.78 "Анатолий Кулаков" Язык, в принципе, идеален уже давно, и все, что в последнее время происходит, это довольно такие украшательства, довольно специфичные.
2028.78 2030.78 "Анатолий Кулаков" Ну, может быть, посмотрим, примут это или нет.
2030.78 2034.98 "Игорь Лабутин" Да, вот сейчас я даже ради интереса пошел прямо сейчас посмотреть, чем все закончилось.
2034.98 2035.98 "Игорь Лабутин" Сейчас.
2035.98 2040.46 "Игорь Лабутин" А, вот, да, я даже могу проапдейтить.
2040.46 2047.90 "Игорь Лабутин" Закончилось это pull request'ом от Стивена Тауба на +1294 строчки.
2047.90 2052.58 "Игорь Лабутин" Судя по всему, вот эта вот первая фишка, stream builder like, опрочем, она заимплеменчена.
2052.58 2056.26 "Игорь Лабутин" Так что это не просто пропозал, это прям уже готовая штука.
2056.26 2061.06 "Анатолий Кулаков" Ну, хорошо, значит, это первая вещь, о которой мы можем рассказать, что в будущем версии языка это будет.
2061.06 2068.46 "Игорь Лабутин" Да, и ты зря переживаешь на тему allocate класса, ведь они внутри пользуются штукой, судя по всему, которая называется value string builder.
2068.46 2070.94 "Игорь Лабутин" Так что, похоже, это структурка string builder.
2070.94 2071.94 "Игорь Лабутин" Хорошо.
2071.94 2076.06 "Игорь Лабутин" В общем, вот так вот, практически в прямом эфире развивается язык C# 10.
2076.06 2077.38 "Игорь Лабутин" Ладно, пошли дальше.
2077.38 2081.82 "Игорь Лабутин" А дальше у нас закончились новости про пятый и шестой .NET.
2081.82 2085.38 "Игорь Лабутин" Ну, то есть, они, конечно же, не закончились, но хватит о пятом и шестом .NET'е.
2085.38 2088.46 "Игорь Лабутин" И мы пойдем немножко в более практическую плоскость.
2088.46 2105.54 "Игорь Лабутин" Мы уже когда-то давно рассказывали про то, что все более-менее знают, что в ASP.NET Core и вообще во всей этой инфраструктуре вокруг ASP.NET есть идея про сеттинги, конфигурации, которые бывают, во-первых, иерархичны, во-вторых, вложены.
2105.54 2115.78 "Игорь Лабутин" Ну, не вложены, а в смысле у вас может быть несколько configuration провайдеров, из которых вы получаете разные сеттинги из environment, из файликов, из файликов специфичных для вашего окружения и так далее.
2115.78 2126.38 "Игорь Лабутин" И когда-то давно мы говорили, что есть такой метод getDebugView, он доступен начиная с .NET Core 3.0, который вам просто в виде красивой строчки выдает содержимое всей вашей конфигурации.
2126.38 2131.46 "Анатолий Кулаков" Тут еще можно упомянуть, что эти переменные могут переписываться друг к другу.
2131.46 2136.02 "Анатолий Кулаков" И довольно-таки неочевидно, какой из провайдеров какую переменную переписал и откуда он ее взял.
2136.02 2142.02 "Анатолий Кулаков" И этот debugView позволяет вам более-менее понять, что вообще в итоге у вас получилось после всех этих переписываний.
2142.02 2148.34 "Игорь Лабутин" Да, откуда какое значение было взято, то есть кто является победителем из провайдеров и почему оно именно там.
2148.34 2155.38 "Игорь Лабутин" Естественно, для того, чтобы это получить, вам нужно иметь каким-то образом доступ к этой информации.
2155.38 2163.14 "Игорь Лабутин" И в OSP.NET Core приложение, естественно, является просто сделать отдельный уровень для этого, который доступен, например, только в Development сборке.
2163.14 2176.74 "Игорь Лабутин" Или может быть даже не только в Development, но включается только если приложение запущено с каким-то специальным сеттингом и возвращать просто реплай этого метода, как текст по сути вот этой конфигурации.
2176.74 2194.38 "Игорь Лабутин" Но Эндрю Лок, которого мы ссылаемся огромное количество раз уже, он, собственно, написал статью еще разок про вот сам метод, а потом написал, что можно же это улучшить, потому что внутри этот метод, если посмотреть на его исходники на GitHub, он делает следующее.
2194.38 2202.22 "Игорь Лабутин" Он перебирает все провайдеры, конфигурационные провайдеры, и берет, собственно, последний, чтобы указать, что значение было получено из вот этого последнего.
2202.22 2217.34 "Игорь Лабутин" Но ведь если у нас есть все провайдеры, мы же можем посмотреть все значения, и он изменил немножко код, он написал свой код, такой похожий метод, который просто берет и показывает вообще все значения всех сеттингов, которые были когда-либо с точки зрения вот оверайда друг друга.
2217.34 2229.98 "Игорь Лабутин" То есть вы будете видеть, что вот этот сеттинг сначала был загружен из Environment, имел такое значение, потом мы посмотрели в File, и он поменял значение, потом мы посмотрели там в App Settings, Development.json, снова поменял значение, и вот поэтому оно сейчас такое.
2229.98 2240.30 "Игорь Лабутин" Если вы когда-нибудь отлаживали, почему у вас откуда и какие значения берутся, возможно эта идея вам пригодится, и включите ее к себе в код, посмотрите, как оно работает.
2240.30 2252.62 "Анатолий Кулаков" Идеальное решение, мне кажется, я все-таки надеюсь, что он это запихнет в стандартный метод, debug.vue, и Microsoft примет это как стандартное расширение, потому что очень удобно.
2252.62 2254.22 "Анатолий Кулаков" Хотя бы по какому-нибудь флажку.
2254.22 2261.30 "Игорь Лабутин" Ну да, добавить просто еще один какой-нибудь булевский флажок, и это debug.vue, show full history или что-нибудь в таком духе.
2261.30 2265.70 "Анатолий Кулаков" В уровне детализации, например, показывать только последние значения или в том числе промежуточные.
2265.70 2284.18 "Игорь Лабутин" Да, и еще одна штука, чем мне понравилась статья Андрю Лока, он там это все дело еще красиво выводит в виде красивых консольных, так скажем, консольных псевдографик, используя библиотеческий спектр консоль, я на нее много вижу упоминаний в последнее время, хочу все тоже попробовать, не знаю, ты пробовал?
2284.18 2294.54 "Анатолий Кулаков" Я да, давно на нее смотрю, таких пару Hello World писал, но вот засунуть в какой-нибудь проектик хороший, чтобы она себя показала, вот еще руки не дошли, тоже, тоже давно хочу попробовать.
2294.54 2306.50 "Игорь Лабутин" Ну вот здесь мне кажется Андрю нашел прям идеальное применение во времена, когда мы не сильно много пишем консольных приложений, а в основном всякие SP.net core, сделать наконец-то хоть какое-то деревце, используя эти консольные штуки, было приятно.
2306.50 2308.34 "Игорь Лабутин" Ну действительно выглядит приятно, попробуйте.
2308.34 2313.46 "Анатолий Кулаков" Если у меня есть ASP уже, то зачем мне консольные штуки, я выведу это все в HTML.
2313.46 2318.22 "Игорь Лабутин" Ну это ты, я например стараюсь выводить все в тексте, зачем мне HTML?
2318.22 2322.18 "Анатолий Кулаков" Хорошо, но ты в тексте выведешь все равно, что мы введем, у тебя нет консоли в ASP.net приложениях.
2322.18 2330.86 "Игорь Лабутин" Ну почему, я просто верну стринг в качестве реплай, мне браузер покажет, тебе вернули какую-то там, оппликейшн слэш текст и все.
2330.86 2333.02 "Игорь Лабутин" Так, прекрасно, а где консоль?
2333.02 2347.94 "Игорь Лабутин" Ну вот, а эта штука, она в, скажем так, она тебе в этот текст рисует псевдографик, и помнишь, как там во времена Нортон Коммандера, эти рамочки, уголочки, вот это все, чтобы не рисовать минусиками и вертикальными черточками и плюсиками.
2347.94 2357.94 "Игорь Лабутин" Вот можно использовать такие тулы, оно как бы называется в спектре консоль, но она умеет в том числе писать и в обычный там стринг, грубо говоря, но просто используя красивую графику консольную.
2357.94 2371.46 "Анатолий Кулаков" Вот, да, именно этого уточнения и хотелось, что спектр консоль, он не только умеет в консоль выводить, он умеет там еще графический UI строить в виде текста, то есть любой текст его можно вывести, например, веб-страничку или файлик или куда-нибудь еще.
2371.46 2374.58 "Игорь Лабутин" А если будете в консоль, он еще цвета поддерживает нормально.
2374.58 2387.34 "Анатолий Кулаков" Да, ну вот тут нужно сказать, что там в виде псевдографики, то есть вы можете деревья строить, окошки рисовать, кнопочки и там вот все, что угодно, все, что вы можете себе представить в стандартном каком-нибудь фаре, вот это все можно сделать.
2387.34 2389.82 "Игорь Лабутин" Да, короче, если вы пишете консоль, попробуйте.
2389.82 2390.82 "Игорь Лабутин" Пошли дальше.
2390.82 2407.78 "Анатолий Кулаков" Дальше наткнулся на интересную статью от Рик Страхла, автор которой очень много пишет тоже про веб в основном, и он нам рассказал, что зарелизил одну из своих хом-проектов, которую пилил два года в бэкграунде, называется эта штука Live Reload Web Server.
2407.78 2411.46 "Анатолий Кулаков" И в принципе многим понятно из названия, что это, но я в принципе расшифрую.
2411.46 2420.74 "Анатолий Кулаков" Прежде всего это self-contained приложение, которое представляет собой утилиту командной строки, и оно запускает локальный веб-сервер.
2420.74 2430.46 "Анатолий Кулаков" То есть на вашем локальной машине вы можете запустить веб-сервер, который превращает локальные папочки на вашем компьютере в ресурс для статического сайта.
2430.46 2439.02 "Анатолий Кулаков" И соответственно вы можете заходить на определенный URL, на определенный порт и видеть все, что у вас в этих папочках лежит.
2439.02 2444.98 "Анатолий Кулаков" Это так действует в принципе миллион инструментов, которые просто делают статические веб-сайты.
2444.98 2449.74 "Анатолий Кулаков" Автор конечно же пошел дальше и навернул немножко фич на свой проект.
2449.74 2469.94 "Анатолий Кулаков" Прежде всего он снабдил свой проект функцией Live Reload, то есть все изменения, которые вы делаете в HTML или в CSS или в других файликах, которые у вас находятся на файловой системе автоматически перегружаются в браузере и показывается уже непосредственно новый измененный контент.
2469.94 2478.58 "Анатолий Кулаков" Также эта штука поддерживает не только статические файлы, но и Markdown она умеет рендерить, Razor Pages тоже неплохо справляется.
2478.58 2488.30 "Анатолий Кулаков" Позволяет вам запускать Blazor приложения, позволяет вам запускать SPA приложения, такие как Angular, Vue.js, React и вся вот эта JS-овская шелупень.
2488.30 2493.86 "Анатолий Кулаков" То есть это не только для статических сайтов, это еще немножко динамики есть.
2493.86 2503.94 "Анатолий Кулаков" Этот инструмент кроссплатформенный, поставляется в виде .NET Tool или через Choco или через стандартный Windows Installer, как вам удобнее.
2503.94 2506.14 "Анатолий Кулаков" Также у него есть несколько режимов хостинга.
2506.14 2510.22 "Анатолий Кулаков" Прежде всего это ISPnet Core приложение, которое может запускаться из командной строки.
2510.22 2512.74 "Анатолий Кулаков" Это в принципе основной его интерфейс.
2512.74 2517.06 "Анатолий Кулаков" Но есть еще один режим, когда вы можете запустить его в Ease.
2517.06 2532.06 "Анатолий Кулаков" То есть с помощью этой прослойки он вам создает веб-сервер и вы в Ease можете тоже нацелить его на какую-то папочку и со всеми вытекающими настройками, со всеми вытекающими конфигурациями, которые умеет делать этот веб-сервер.
2532.06 2537.20 "Анатолий Кулаков" Он поддерживает HTTPS, хостинг и в принципе тоже отлично справляется с этим.
2537.20 2542.02 "Анатолий Кулаков" В процессе написания этого сервера у автора развивалось параллельно несколько вспомогательных библиотек.
2542.02 2551.74 "Анатолий Кулаков" Прежде всего это компонент для Live Reload, который находится в отдельном репозитории и компонент для Markdown, который позволяет вам парсить и рендерить Markdown.
2551.74 2557.02 "Анатолий Кулаков" Соответственно, вы можете отдельно воспользоваться этими библиотеками, которые уже в принципе опробованы на множествах продакшен.
2557.02 2569.58 "Анатолий Кулаков" Ну и посмотреть на вот этот веб-сервер, если вам вдруг локально необходимо редактировать какие-нибудь JS-компоненты или локально вы много пишете HTML, CSS и хотите иметь хороший и быстрый превью.
2569.58 2570.98 "Анатолий Кулаков" Вот такая полезная утилитка.
2570.98 2571.98 "Игорь Лабутин" Да, действительно.
2571.98 2576.70 "Игорь Лабутин" В принципе, если вы разрабатываете что-то такое с учетом SPA.
2576.70 2583.02 "Игорь Лабутин" Хотя, опять же, если у вас есть Solutions с вашим SP Network проектом, зачем вам еще что-то Live Reload?
2583.02 2587.30 "Игорь Лабутин" Студии запустил и он там новый .NET Watch запустил и все работает само, нет?
2587.30 2588.30 "Анатолий Кулаков" Да, да.
2588.30 2593.86 "Анатолий Кулаков" Если у вас такие Solutions и большие проекты, то безусловно студия здесь более полезна.
2593.86 2598.46 "Анатолий Кулаков" Прежде всего этот проектик нацелен на какие-то мелкие сайты.
2598.46 2603.46 "Анатолий Кулаков" Вот если у вас есть какие-то хобби-сайты, сайты мелких проектов, мелких компаний и так далее.
2603.46 2607.54 "Анатолий Кулаков" То есть у вас уже есть несколько Razor компонентов.
2607.54 2611.82 "Анатолий Кулаков" Если поправить в них ошибку, это все, что вам нужно.
2611.82 2613.50 "Анатолий Кулаков" Для этого не обязательно поднимать большую студию.
2613.50 2627.26 "Анатолий Кулаков" Вы просто с помощью одной утилиты командной строки в Live Preview можете свободно поправить любые ошибки, любые опечатки, внести небольшую статейку, тут же просмотреть это и задеплоить без подъема какой-то студии.
2627.26 2639.78 "Анатолий Кулаков" А если у вас какой-нибудь еще богомерзкий JavaScript, то соответственно тоже можно запроксировать через эту утилитку и в любом удобном вам уже блокнотике, быстром, настроенном именно под вас, все отредактировать.
2639.78 2643.66 "Анатолий Кулаков" Без каких-то больших тяжелых редакторов, если он вам не нужен.
2643.66 2644.66 "Игорь Лабутин" Понятно, хорошо.
2644.66 2654.98 "Игорь Лабутин" Разговаривая о таких, может быть, полезных и немножко, может быть, сторонних для такой основной разработки тулов, хочется упомянуть Elspy, декомпилятор.
2654.98 2658.98 "Игорь Лабутин" У него зарелизился версия 7.0 Release Candidate 1.
2658.98 2667.66 "Игорь Лабутин" Это первая версия, нормально поддерживающая .NET 5, то есть там, соответственно, улучшили декомпиляцию всех последних нововведений C# 9.
2667.66 2675.62 "Игорь Лабутин" Возможно, там еще не совсем все прям идеально поддержаны, но тем не менее, если вы пользуетесь декомпиляторами, то вот это один из вариантов, который можно попробовать.
2675.62 2682.74 "Игорь Лабутин" То есть я, например, Elspy пользуюсь довольно активно, .Pick я как-то пользовался долго, но сейчас подзабросил.
2682.74 2686.22 "Игорь Лабутин" Счет он какой-то стал медленный для меня.
2686.22 2687.98 "Игорь Лабутин" У тебя вообще какой опыт?
2687.98 2691.62 "Игорь Лабутин" .Pick, Elspy, Studio, ReSharper, Rider?
2691.62 2693.82 "Анатолий Кулаков" Для декомпиляции я использую в основном .Pick.
2693.82 2712.14 "Анатолий Кулаков" Я с тобой согласен, что он безумно медленный и часто тормозит и все такое, но в моей практике мне не нет необходимости слишком часто декомпилировать, а тогда, когда такая необходимость появляется, всегда приятно, что он уже установлен, он у меня уже есть и в принципе мне его хватает с головой.
2712.14 2714.30 "Анатолий Кулаков" Поэтому никаких пока причин менять его не вижу.
2714.30 2722.10 "Игорь Лабутин" Ну вот у меня примерно тот же самый сценарий, что мне надо декомпилировать довольно редко, и именно поэтому меня время запуска довольно сильно бесит.
2722.10 2729.66 "Игорь Лабутин" Это вот тот тул, который должен запускаться мгновенно, а не пытаться там проанализировать полмира, чтобы составить себе какую-то ментальную модель внутри.
2729.66 2734.82 "Игорь Лабутин" Поэтому у меня как раз стоит Elspy, какой-то одной из предыдущих версий, надо будет обновить, значит.
2734.82 2739.74 "Игорь Лабутин" И на самом деле связанный с этим тул хотелось бы затронуть этот DN-SPY.
2739.74 2751.58 "Игорь Лабутин" Несмотря на очень схожие названия, это абсолютно разные тулы и от абсолютно разных авторов, это дебаггер, который так написан на C#, абсолютно standalone, вы просто берете папочку, копируете на другой компьютер и все работает.
2751.58 2767.50 "Игорь Лабутин" И он прикольен тем, что он довольно лайтовый, он при этом вполне нормальный дебаггер, ну примерно как в студии, ну конечно без всяких этих новомодных свистелок типа анализа памяти, вот этих тех перформанс, паралл стэков и всего такого.
2767.50 2772.46 "Игорь Лабутин" Ну какую-то базовую отладку с символами и вотчами, checkpoint'ами сделать можно.
2772.46 2778.82 "Анатолий Кулаков" Слушай, у меня по-моему самый необходимый инструмент на побудине, который есть, это все-таки SourceLink.
2778.82 2780.82 "Анатолий Кулаков" SourceLink нормально поддерживает?
2780.82 2821.22 "Игорь Лабутин" Да, SourceLink он поддерживает нормально, я им как раз-таки пользуюсь в сценариях, когда у нас например есть какая-то версия нашего софта, закинутая на какую-нибудь виртуалку в Stage Environment или в Test Environment, там что-то себя ведет очень странно, это не продакшн, к которому прям можно приатачиться и там все остановить весь мир, это в принципе Test Environment, я могу там предупредив всех к нему приатачиться и посмотреть, что конкретно происходит сейчас в приложенке и вот тут конечно эта штука незаменима для меня, не надо туда тащить студию, на такой полупродакшн все-таки, ставить туда девелоперские SDK и так далее, достаточно притащить эту маленькую программку и в общем счастливо пользоваться в привычном C#.
2821.22 2844.90 "Игорь Лабутин" Она старается добыть все по SourceLink'ам и по DB'шкам, если у нее не получается, она умеет прекрасно декомпилить, включая встроенные, понятно, Runtime, ну в смысле что, включает этот Runtime и это кстати второй кейс, когда я им довольно часто пользуюсь, когда нужно отладить что-то, что происходит в дебрях Runtime, то есть когда я много отлажил какой-нибудь WCF, как там что внутри друг с другом общается, вот эта вот штука прям для меня была незаменима.
2844.90 2866.02 "Игорь Лабутин" Вот, с ним есть проблема, автор его сейчас пока подзабросил и вообще куда-то делся, поэтому как он будет развиваться дальше непонятно, но с другой стороны, DotNet сильно в этой плане не меняется, Debugger API остается довольно стабильным поэтому я думаю, что он еще очень долго будет актуальным, поэтому если вам нужен легковесный Debugger, смотрите в эту сторону, бывает спасает, хотя это конечно не на каждый
2866.02 2884.10 "Анатолий Кулаков" день. Вот, наткнулся еще на статейочку в блоге Microsoft'а с списком отличных Open Source пакетов для работы с HTTP API, что-то мы с тобой давно не дотрагивали в HTTP API, поэтому я вот решил достать, откопать и немножко рассказать.
2884.10 2892.14 "Анатолий Кулаков" Некоторые пакеты очень известны, некоторые пакеты неизвестны, некоторые пакеты среднеизвестны, давайте вот так соберем в одну кучку и обсудим.
2892.14 2895.06 "Анатолий Кулаков" Игорь, ты если с чем-то сталкивался, в принципе добавляй.
2895.06 2906.74 "Анатолий Кулаков" Итак, прежде всего у нас это все разбито по секциям и первая секция нацелена на Open API Generation, то есть то, что каким-то образом геневидца или помогает вам построить непосредственно сам Open API.
2906.74 2930.46 "Анатолий Кулаков" Вкратце, Open API это стандартный протокол, который не только про DotNet, это вообще про весь веб, это специальный протокол, с помощью которого люди описывают ваши REST API поинты, то есть ваши веб-сервисы, каким образом можно к ним доступиться, какие аргументы они принимают, какие может быть валидации ожидают на входе, какой результат вернут, какие форматы поддерживают, ну вот это абсолютно практически все-все-все.
2930.46 2949.30 "Анатолий Кулаков" И в DotNet с ранних версий уже довольно-таки давно существует много вспомогательных библиотек, которые помогают вам описать свои контроллеры, то есть дать какое-то описание вашему API, чтобы оно выглядело, так сказать, по стандартам.
2949.30 2954.74 "Анатолий Кулаков" Вы еще можете знать Open API под старым названием, которое называется Swagger.
2954.74 2957.34 "Анатолий Кулаков" Вот это в принципе одно и то же Open API и Swagger.
2957.34 2966.06 "Анатолий Кулаков" И для DotNet часто используются два таких инструмента, которые хорошо помогают вам заинтегрироваться с этой спецификацией.
2966.06 2968.06 "Анатолий Кулаков" Прежде всего это NSwag.
2968.06 2975.22 "Анатолий Кулаков" NSwag это инструмент, который позволяет вам генерить из уже описанного Open API клиентов.
2975.22 2987.34 "Анатолий Кулаков" И это строго типизированные C#, HTTP клиенты, которые вы уже можете дергать, у которых есть IntelliSense, который возвращает вам предсказуемый респонс и все, как вы в принципе ожидаете.
2987.34 2994.50 "Анатолий Кулаков" Этот по с помощью NSwag вы можете поступить наоборот, если у вас есть какая-то спецификация.
2994.50 2999.82 "Анатолий Кулаков" А спецификация Open API обычно распространится в двух видах, это в JSON или в YAML.
2999.82 3012.18 "Анатолий Кулаков" Вот если у вас уже есть текстовый файлик с JSON, вы например можете сгенерить контроллеры для вашего приложения и уже эти контроллеры потом заимплементировать и соответственно использовать в каких-то своих программах.
3012.18 3020.34 "Анатолий Кулаков" Это очень полезно, например, когда вы пытаетесь держать один и тот же контракт между несколькими клиентами.
3020.34 3023.54 "Анатолий Кулаков" Третьим клиентом, который поддерживается NSwag это TypeScript.
3023.54 3025.22 "Анатолий Кулаков" Вы также можете генерить TypeScript клиенты.
3025.22 3035.66 "Анатолий Кулаков" Ну и представьте, у вас есть команда DotNet разработчики TypeScript UI-щики и в принципе еще какие-то от DotNet потребители, которые клиенты от DotNet хотят.
3035.66 3048.06 "Анатолий Кулаков" Если у вас какая-то одна сторона будет диктовать контракт, то две других будет постоянно недовольны, они будут или опаздывать или еще что-то, или как-то ошибаться в своих контрактах, иметь постоянно непонятную версию.
3048.06 3059.82 "Анатолий Кулаков" Вот если вы же первую точку принятия, то есть первую спецификацию, где описывается сам контракт выносите непосредственно в YAML, то есть в OpenAPI.
3059.82 3065.66 "Анатолий Кулаков" Вы сначала текстом описываете весь контракт, то после этого у вас уже никаких разногласий не будет.
3065.66 3075.54 "Анатолий Кулаков" Вы из YAML генерируете API-контроллеры для одних, строго типизированный C# клиенты для других и строго типизированный TypeScript клиенты для третьих.
3075.54 3082.70 "Анатолий Кулаков" И можете еще кучу нагенерить клиентов для десятых, потому что OpenAPI, как я уже сказал, он поддерживается практически всеми языками.
3082.70 3084.86 "Анатолий Кулаков" Это и Python, и Java и прочие глупости.
3084.86 3089.14 "Анатолий Кулаков" Вот в принципе такие штуки позволяют вам творить NSVAC.
3089.14 3091.78 "Анатолий Кулаков" Следующий популярный инструмент это Swashbuckle.
3091.78 3098.90 "Анатолий Кулаков" Swashbuckle - это великая толзиень, ей пользуются уже миллионы проектов на .NET.
3098.90 3108.22 "Анатолий Кулаков" Это штука, которая позволяет вам в очень идиоматичном виде описать тот самый OpenAPI на ваших контроллерах.
3108.22 3120.50 "Анатолий Кулаков" То есть вы разрешиваете атрибутики, вы разрешиваете какие-то middleware и он вам формирует из имен атрибутов, из роутеров, из тех типов, которые у вас принимают контроллеры.
3120.50 3122.94 "Анатолий Кулаков" Он уже сформирует базовую спецификацию.
3122.94 3135.54 "Анатолий Кулаков" Если вы хотите что-то там кастомно поменять или как-то улучшить, у него отличный есть API, который легко расширяется и позволяет вам добавить просто любые извращения, которые вам только захочется.
3135.54 3148.10 "Анатолий Кулаков" По дефолту Swashbuckle включен в ISP.NET Template, начиная с пятой версии фреймворка, то есть когда вы создаете чистый фреймворк, он уже включается в Swashbuckle и ваш проект уже получает автоматически поддержку OpenAPI.
3148.10 3164.74 "Анатолий Кулаков" Также у него есть Swashbuckle CLI, это специальная команда Line Tools, которая позволяет вам генерировать OpenAPI спецификацию из ваших скриптов, из MS Build, из .NET Tool или откуда-то вот еще.
3164.74 3168.70 "Анатолий Кулаков" То есть это такой инструмент, мне кажется, про который должны знать просто все.
3168.70 3173.14 "Анатолий Кулаков" Следующая полезная библиотечка это Microsoft OpenAPI.
3173.14 3179.42 "Анатолий Кулаков" Суть этой библиотеки в том, что она попыталась сделать единую модель для OpenAPI спецификации.
3179.42 3194.94 "Анатолий Кулаков" Она используется очень часто во всяких ажурах, например, и если вы, например, захотите сделать какую-то свою библиотеку, то Microsoft крайне рекомендует брать уже готовую модель из Microsoft OpenAPI и наворачивать сверху какие-то свои функциональности.
3194.94 3204.10 "Анатолий Кулаков" Хорошей штукой из Microsoft OpenAPI является то, что она поддерживает еще сервизаторы, а не только модельку.
3204.10 3210.66 "Анатолий Кулаков" И плюс предоставляет еще возможность как-то мигрировать между форматами.
3210.66 3215.86 "Анатолий Кулаков" Например, с помощью этой библиотеки вы можете переводить спецификацию свагера из YAML в JSON и обратно.
3215.86 3217.78 "Анатолий Кулаков" То есть сделать такие миграции туда-сюда.
3217.78 3226.74 "Анатолий Кулаков" И также это очень удобный инструмент, если вы хотите писать OpenAPI ручками, то есть заполнять свои модельки.
3226.74 3231.18 "Анатолий Кулаков" Может быть, он у вас очень сложный или вы еще какой-то цель преследуете в этом.
3231.18 3236.02 "Анатолий Кулаков" То есть заполнять свои модельки руками в коде и дальше сервизовать ее в стандартный формат.
3236.02 3239.46 "Анатолий Кулаков" Вот тоже тогда можно обратить внимание на эту библиотечку.
3239.46 3244.58 "Анатолий Кулаков" Следующая штука, про которую все обязаны знать, это ISP.NET API Versioning.
3244.58 3253.62 "Анатолий Кулаков" Это библиотека, которая намекает своим названием на то, что она создана для версионирования вашего API.
3253.62 3262.22 "Анатолий Кулаков" Это очень простой способ, как заверсионировать ваши контроллеры, методы у этих контроллеров, роуты и вообще абсолютно все, что угодно.
3262.22 3265.94 "Анатолий Кулаков" Вам достаточно навесить парочку атрибутов на контроллер и в принципе уже все.
3265.94 3266.94 "Анатолий Кулаков" Все-все готово.
3266.94 3270.78 "Анатолий Кулаков" Все остальные инструменты вас поддерживают.
3270.78 3284.98 "Анатолий Кулаков" Например, свеш-бакл автоматически интегрируется с этой библиотекой и уже непосредственно в своем интерфейсе показывает API, только соответствующий определенным версиям.
3284.98 3299.34 "Анатолий Кулаков" Да, я забыл упомянуть, что свеш-бакл это не только способ описать атрибутами ваши контроллеры, но он также включает в себя еще UI, которая на вашем порту по определенному урлу открывает очень удобный Web API.
3299.34 3308.06 "Анатолий Кулаков" Вы можете в него тыкаться, заполнять специальные поля переменными, нажимать кнопочку запустить и он вам вернет результат распаршенный.
3308.06 3315.22 "Анатолий Кулаков" Вы там можете менять версии, менять типы данных и в общем тестировать ваш API с помощью удобного WebTools.
3315.22 3320.58 "Анатолий Кулаков" То есть, это тоже очень классная его особенность.
3320.58 3323.58 "Анатолий Кулаков" Но все же вернемся к версионированию.
3323.58 3335.78 "Анатолий Кулаков" Задачи версионирования встают довольно часто и в принципе решать их ручками, обычными средствами довольно муторно и там есть очень много подводных камней, поэтому тоже не советуем это делать, лучше обратиться к профессионалам.
3335.78 3343.10 "Анатолий Кулаков" Вот эта библиотечка API Versioning, она поддерживает очень много различных типов версионирования.
3343.10 3348.18 "Анатолий Кулаков" Она поддерживает в том числе версионирование, которое рекомендует Microsoft по своим гайдлайнам.
3348.18 3351.98 "Анатолий Кулаков" Но если вас чем-то гайдлайн не устраивает, вы естественно можете использовать все, что хотите.
3351.98 3355.10 "Анатолий Кулаков" Способов версионирования API существует огромное количество.
3355.10 3362.62 "Анатолий Кулаков" Самое распространенное из них это версионирование через query строку, когда вы просто в урле задаете какую версию хотите данных получить.
3362.62 3371.90 "Анатолий Кулаков" Или с помощью сегмента, то есть когда у вас не в урл строке передается, а тоже в урле, но именно в сегменте.
3371.90 3387.62 "Анатолий Кулаков" И наверное самый распространенный, самый правильный способ это через хедера и там тоже есть очень много вариантов, то есть как в хедер его засунуть, потому что есть отдельные хедеры, есть вставка специальной в MediaType и прочие прочие вещи.
3387.62 3394.98 "Анатолий Кулаков" Об этом лучше всего почитать в документации и уже на основании этого выбрать тот Best Practice, который лучше всего вас удовлетворит.
3394.98 3397.30 "Анатолий Кулаков" Следующая интересная библиотечка это Refit.
3397.30 3404.30 "Анатолий Кулаков" Очень забавная штука, особенно когда первый раз ее увидел, было такое ощущение, ну как это, мне в голову не могло такое прийти.
3404.30 3413.98 "Анатолий Кулаков" Библиотека очень простая, она служит для того, чтобы вам сгенерировать REST клиент для какого-то уже известного понятного API.
3413.98 3421.62 "Анатолий Кулаков" Но генерирует в отличие от других рассмотренных плузов, она его не по OpenAPI, а по тому интерфейсу, который вы описываете.
3421.62 3438.28 "Анатолий Кулаков" То есть вы просто берете в C#, описываете интерфейс, называете в этом интерфейсе методы, как вам кажется полезным, например, getUsers, который возвращает список юзеров, getCustomers, который возвращает список кастомеров и над каждым этим методом просто-напросто навешиваете атрибутик.
3438.28 3446.60 "Анатолий Кулаков" Атрибутик, в котором указан route, то есть вы можете сказать, что я хочу этих юзеров получить из route/users.
3446.60 3448.12 "Анатолий Кулаков" И все.
3448.12 3459.52 "Анатолий Кулаков" Дальше вы просто-напросто запускаете специальную фабрику, которая резолвит вам этот интерфейс и в рантайме непосредственно создает вам этот клиент, имплементирует его сама.
3459.52 3463.40 "Анатолий Кулаков" Этот клиент на основании HTTP-клайента реализует все эти методы.
3463.40 3466.00 "Анатолий Кулаков" То есть все, что ему нужно, у него есть.
3466.00 3474.76 "Анатолий Кулаков" У него есть route, куда обратиться, у него есть полностью сигнатура, что он ожидает получить и во что он ожидает децерализовать все эти типы.
3474.76 3476.76 "Анатолий Кулаков" Все это он прозрачно под капотом делает.
3476.76 3484.52 "Анатолий Кулаков" То есть это, по-моему, самый быстрый способ, как вы можете составить клиента для какого-то небольшого известного вам API.
3484.52 3487.28 "Анатолий Кулаков" Все стандартные подводные камни он поддерживает.
3487.28 3492.20 "Анатолий Кулаков" Если вам нужно уже что-то более извращенное, то вы всегда можете воспользоваться обычным HTTP-клайентом.
3492.20 3495.92 "Игорь Лабутин" Слушай, но ты уже много так всего рассказал про то, что делать из кода.
3495.92 3505.24 "Игорь Лабутин" И вот refit, это мне уже кажется больше такое, ну не то чтобы про тестирование, но уже ближе к такому вот использованию всего этого добра.
3505.24 3514.00 "Игорь Лабутин" Давай поговорим про то, чем вообще все эти HTTP-апиайки тестировать, трогать, тестить, запускать и так далее.
3514.00 3517.16 "Анатолий Кулаков" Да, это в принципе отдельная большая группа инструментов.
3517.16 3518.16 "Анатолий Кулаков" Давай посмотрим.
3518.16 3524.24 "Анатолий Кулаков" Прежде всего такая ToolZ, о которой уже упоминалось ранее, HTTP-repo.
3524.24 3532.24 "Анатолий Кулаков" Это global tool, который предоставляет вам доступ к определенным API с помощью древовидной структуры.
3532.24 3541.56 "Анатолий Кулаков" Если вы когда-нибудь пользовались command-line для того, чтобы discover вашу файловую систему, то вы быстро освоитесь с этим инструментом.
3541.56 3551.12 "Анатолий Кулаков" Например, у него есть такие команды как dir или ls, с помощью которых он может вам показать, какие endpoints у вас там есть в виде таких файликов своеобразных.
3551.12 3557.12 "Анатолий Кулаков" Какие там директории есть, в которые вы можете зайти внутрь, которые вы можете запустить, вызвать, посмотреть.
3557.12 3564.60 "Анатолий Кулаков" В общем, не знаю, для фана этот инструмент или реально на практике им кто-то пользуется, но выглядит в принципе интересно, очень миленько и замечательно.
3564.60 3578.40 "Игорь Лабутин" Я пытался на самом деле один раз попробовать и что-то я прям как-то, ну не знаю, оно может быть для инвестигейта неизвестных тебе API удобно, а для работы с известными тебе API прям как-то очень долго у меня получалось.
3578.40 3579.40 "Игорь Лабутин" Мне не понравилось.
3579.40 3586.56 "Анатолий Кулаков" Ну, наверное, да, все-таки ходить по файловой системе даже с помощью вот этих стандартных команд это тоже не самый быстрый способ, надо признать.
3586.56 3596.24 "Анатолий Кулаков" Гораздо более интересная и полезная утилита, которую в принципе я пользуюсь довольно давно, называется REST Client for Visual Studio Code.
3596.24 3601.40 "Анатолий Кулаков" Это экстеншн к Visual Studio Code, который гениален по своей простоте.
3601.40 3610.64 "Анатолий Кулаков" Представьте, например, вы можете создать в своем проекте какой-нибудь файлик, у которого расширение HTTP или REST, и внутри этого файла просто нарисовать URL.
3610.64 3613.40 "Анатолий Кулаков" И в принципе все.
3613.40 3619.20 "Анатолий Кулаков" Данный плагин позволяет вам превратить этот файлик в какое-то подобие исполняемого кода.
3619.20 3625.96 "Анатолий Кулаков" То есть, если вы на этом URL нажмете, например, F5, то этот URL запустится и в превью вам вернется ответ.
3625.96 3630.88 "Анатолий Кулаков" Подробный ответ со всеми заголовками, со всеми децентрализациями, которые нужно было сделать.
3630.88 3635.12 "Анатолий Кулаков" Это элементарный способ, как может выглядеть этот файлик.
3635.12 3637.80 "Анатолий Кулаков" Далее, естественно, вы можете добавить какой-нибудь HTTP метод.
3637.80 3640.16 "Анатолий Кулаков" GET, POST, PUT и так далее.
3640.16 3642.16 "Анатолий Кулаков" И тогда, соответственно, управлять HTTP методами.
3642.16 3644.40 "Анатолий Кулаков" Но это и не все.
3644.40 3652.08 "Анатолий Кулаков" Естественно, можно управлять абсолютно всеми атрибутами, которые вы можете себе представить из стандартного, например, cURL_TOOLS.
3652.08 3660.88 "Анатолий Кулаков" То есть, вы можете задавать контент-тайп, вы можете задавать body, вы можете управлять авторизацией, вы можете задавать cookie, устанавливать proxy.
3660.88 3666.24 "Анатолий Кулаков" Там даже есть превью картинок, если вдруг обратный ответ вернул вам какой-то имидж.
3666.24 3673.64 "Анатолий Кулаков" То есть, вы можете полностью в тексте расписать вот этот HTTP запрос и далее просто исполнять его.
3673.64 3683.28 "Анатолий Кулаков" Мне кажется, для исследования какого-то API, который вам вот или знаете вы его уже или нет, вот это одна из самых полезных инструментов.
3683.28 3688.36 "Игорь Лабутин" Вопрос такой, а ты не знаешь, можно ли так нормально делать, скажем так, placeholder?
3688.36 3700.76 "Игорь Лабутин" То есть, например, у меня есть мой проект, в нем, понятно, есть какой-то API, я к нему создаю такой файлик, но дальше понятно, что у меня, например, есть, не знаю, production и pre-production, где немножко разные IDшники.
3700.76 3707.16 "Игорь Лабутин" Урулы, понятно, более-менее одинаковые, но, например, у них разный там base.url или внутри пути что-то отличается.
3707.16 3712.44 "Игорь Лабутин" Можно как-то это, не знаю, шаблончиком сделать или какие-то переменные подставлять?
3712.44 3729.48 "Анатолий Кулаков" Да, у них есть элементарная система шаблонизации, то есть там есть базовые какие-то вещи, которые вы всегда ожидаете увидеть, вот они тоже там подставляются, плюс можно это подтаскивать переменные из environment, из вашей среды окружения, что тоже очень полезно.
3729.48 3731.88 "Анатолий Кулаков" То есть такие банальные шаблончики можно подставить.
3731.88 3739.76 "Анатолий Кулаков" Плюс это еще интересная специфика этого инструмента, то что у вас остается понятный артефакт вашей файловой системы.
3739.76 3744.36 "Анатолий Кулаков" То есть эту штуку можно вместе с проектом распространять, версионировать, редактировать и так далее.
3744.36 3757.12 "Анатолий Кулаков" То есть это замечательная, например, вещь для того, чтобы отдать в документацию или к тестировщикам или еще куда-то понятный кусок кода, который вот точно работает, его можно запустить и его можно посмотреть.
3757.12 3770.28 "Анатолий Кулаков" Ну то есть вместе с проектом таскать такой файлик довольно часто бывает удобно, когда ты хочешь просто свои API подергать и посмотреть, продолжает ли они возвращать тот же результат, который ты ожидал от них получить.
3770.28 3771.84 "Игорь Лабутин" А респонс парсить умеют?
3771.84 3781.72 "Игорь Лабутин" Ну там, не знаю, вытащить какой-нибудь value из JSON на третьем уровне вложенности и запихнуть в environment, чтобы использовать в следующем запросе?
3781.72 3782.72 "Анатолий Кулаков" Вот этого не знаю.
3782.72 3787.04 "Анатолий Кулаков" То есть я знаю точно, что он умеет тебе показывать красиво, здесь реализованный респонс.
3787.04 3791.20 "Анатолий Кулаков" Можно ли оттуда какие-то переменные брать и в следующий запрос передавать?
3791.20 3792.56 "Анатолий Кулаков" Ни разу не пробовал.
3792.56 3807.16 "Игорь Лабутин" Потому что у меня такое в сценариях есть, ну там типа какой-нибудь, знаешь, пост-реквест, который что-нибудь запускает на сервере, ему в ответ возвращается гуидик заправки, ну гуидик этой операции, и нужен этот гуид, следующий, там, гет, который полингом выясняет статус.
3807.16 3814.52 "Игорь Лабутин" Вот было бы неплохо иметь распарсить реплай первого реквеста и запихнуть в переменные, чтобы он во второй автоматически там в уру подставился.
3814.52 3816.28 "Анатолий Кулаков" Да, да, я тебя понимаю.
3816.28 3818.60 "Анатолий Кулаков" В принципе, я не удивлюсь, если там эта штука есть.
3818.60 3826.32 "Анатолий Кулаков" Потому что инструмент довольно-таки разъяснительный, он очень много всего умеет и может быть даже вытаскивать вещи из предыдущих запросов тоже.
3826.32 3846.92 "Анатолий Кулаков" Ещё можно отметить, что точно такую же штуку, она есть встроенная в райдере, вот поэтому если вы пользуетесь уже райдером, то вам не нужен Visual Studio Code отдельный, райдер тоже это давно умеет, то есть ещё с не только райдером, но и любая IntelliJ-бейс система со своих первых версий такие файлики уже поддерживает.
3846.92 3848.60 "Анатолий Кулаков" А я по старинке пользуюсь Postman.
3848.60 3854.52 "Анатолий Кулаков" Я ещё упоминал, что для, есть, существует такой способ, как редактировать OpenAPI спецификацию вручную.
3854.52 3863.68 "Анатолий Кулаков" Вот это не настолько редкий, не настолько извращенный случай, как вам кажется, и много больших компаний именно таким образом предпочитают поддерживать свои API.
3863.68 3870.84 "Анатолий Кулаков" И вот для них может быть полезен специальное расширение для Visual Studio Code OpenAPI Editor.
3870.84 3880.48 "Анатолий Кулаков" Как вы понимаете, судя по названию, он предоставляет вам полный синтаксис для OpenAPI, поддерживает JSON и YAML форматы.
3880.48 3889.36 "Анатолий Кулаков" Он вам помогает с помощью IntelliSense, соответственно, подсказывает, какие можно туда подставить параметры, кто зачем должен идти.
3889.36 3894.20 "Анатолий Кулаков" У него есть навигация, как вы привыкли, как вы по коду ползаете.
3894.20 3902.44 "Анатолий Кулаков" И ещё у него есть Swagger UI Preview, то есть автоматически всё, что вы пишете, может быть просмотрено в реальном времени и это тоже помогает.
3902.44 3909.28 "Анатолий Кулаков" То есть, если вы вручную редактируете OpenAPI, посмотрите, может быть, этот инструмент тоже будет вам интересен или полезен.
3909.28 3911.28 "Игорь Лабутин" А мы его, кстати, используем сейчас в работе.
3911.28 3919.80 "Игорь Лабутин" У нас как раз таки specification-first подход, то есть мы сначала пишем YAML спецификацию, потом она уже отдаётся отдельно фронтендерам, отдельно бэкендерам для реализации.
3919.80 3923.20 "Игорь Лабутин" И мы как раз используем Visual Studio Code с OpenAPI Editor.
3923.20 3929.84 "Анатолий Кулаков" У меня ещё осталось пару библиотечек, которые уже непосредственно построены на ISP-нете.
3929.84 3932.24 "Анатолий Кулаков" Прежде всего это API Endpoints.
3932.24 3940.48 "Анатолий Кулаков" Это довольно интересный и свежий концепт, который я ещё, наверное, единственный, который я из этого всего зоопарка не попробовал.
3940.48 3942.32 "Анатолий Кулаков" Тоже у меня стоит в закладочках.
3942.32 3945.40 "Анатолий Кулаков" Смысл в том, что он пытается вам упростить контроллеры.
3945.40 3948.08 "Анатолий Кулаков" Он пытается вас избавить от контроллеров.
3948.08 3954.68 "Анатолий Кулаков" Наверное, многие из вас слышали мансу, что в жирные контроллеры это плохо и в контроллеры должно быть как можно меньше логики.
3954.68 3956.96 "Анатолий Кулаков" На самом деле сделать это довольно просто.
3956.96 3973.32 "Анатолий Кулаков" Ну то есть, с тех пор, как у нас контроллеры научились отлично децерализовать входные аргументы, как они научились децерализовать выходные аргументы по уже известным моделям, функцию маппинга взяли на себя отдельные классы, которые называются мапперы.
3973.32 3979.00 "Анатолий Кулаков" Контроллерам ничего не остаётся, как просто-напросто подержать на себе атрибутик.
3979.00 3980.36 "Анатолий Кулаков" Атрибутик с роутом.
3980.36 3986.68 "Анатолий Кулаков" Вот это и всё, что есть в большинстве таких лайтовых тонких контроллеров.
3986.68 3994.60 "Анатолий Кулаков" И вот данный фреймворк, он позволяет выкинуть уже контроллеры из этой цепочки и позволяет вообще их не использовать.
3994.60 4000.44 "Анатолий Кулаков" Обычно, когда мы говорим про лёгкие контроллеры, часто в проектах используется медиатор.
4000.44 4003.44 "Анатолий Кулаков" Мы уже обсуждали тему хендлеров, медиаторов и так далее.
4003.44 4016.08 "Анатолий Кулаков" То есть, смысл в том, что контроллер принимает какой-то у себя реквест, децерализует его и отдаёт сразу этот реквест на обработку шинки.
4016.08 4019.40 "Анатолий Кулаков" Такая шина данных, которая прокачивает абсолютно все реквесты.
4019.40 4021.60 "Анатолий Кулаков" Её роль обычно выполняет медиатор.
4021.60 4024.72 "Анатолий Кулаков" Медиатор вызывает кучу хендлеров, которые могут быть на него навешаны.
4024.72 4028.80 "Анатолий Кулаков" Эти хендлеры преобразуют каким-то образом запрос и возвращают вам ответ.
4028.80 4038.68 "Анатолий Кулаков" Ответ медиатор возвращает контроллеру, и контроллер его этот ответ отдаёт обратно наружу, где уже стандартный JSON серилизатор его там серилизует, допустим.
4038.68 4049.24 "Анатолий Кулаков" Если мы выбрасываем отсюда контроллер, то у нас единственная задача, которую нужно сделать, это просто-напросто медиатору отдать уже децерализованную модельку из-за штити переквеста.
4049.24 4053.96 "Анатолий Кулаков" Вот, в принципе, вот эту прослоечку и решает API endpoints.
4053.96 4065.32 "Анатолий Кулаков" То есть, они позволяют вам на вашем хендлере навесить route-атрибут, который будет делать абсолютно всё то же самое, что делают контроллеры.
4065.32 4072.72 "Анатолий Кулаков" Но при этом не нужно будет наследоваться от API контроллеров, как нужно было в старых версиях, например.
4072.72 4081.92 "Анатолий Кулаков" Не нужно будет поднимать кучу всяких middleware, exception фильтров и прочих API фильтров, которые навешиваются на контроллер.
4081.92 4089.72 "Анатолий Кулаков" То есть, очень много тяжеловесной архитектуры сразу отпадает, если вы просто-напросто отказываетесь от контроллеров, которая в большинстве проектов абсолютно никому не нужна.
4089.72 4097.88 "Анатолий Кулаков" Также вы не теряете никакой интеграции с другими инструментами ожидающими от вас каких-то контроллеров.
4097.88 4101.08 "Анатолий Кулаков" Например, тот же самый Sashbuckle или NSwag.
4101.08 4104.84 "Анатолий Кулаков" Они прекрасно умеют интегрироваться с этим фреймворком без каких-либо потерь.
4104.84 4111.92 "Анатолий Кулаков" И вот этот фреймворк, он позволяет вам сделать более такой модульный, более модульный подход, в отличие от MVC.
4111.92 4117.80 "Анатолий Кулаков" То есть, если вы используете в своих проектах миниатур, посмотрите, может вам тоже такая тема зайдёт.
4117.80 4120.84 "Анатолий Кулаков" Ещё один смешной проект называется Carter.
4120.84 4128.88 "Анатолий Кулаков" Carter - это прежде всего тоже главная цель убить контроллеры, но делает он это с помощью очень удобного синтаксиса.
4128.88 4131.88 "Анатолий Кулаков" Синтаксис этот он перенял из Nancy.
4131.88 4135.36 "Анатолий Кулаков" Может быть, старички помнят, был такой проект NancyFX.
4135.36 4148.08 "Анатолий Кулаков" Он был очень популярный, когда ещё ISP.NET не был кором, когда ещё ISP.NET был огромным тяжеловесным приложением, которое поднималось очень долго, работало очень медленно, хотелось чего-то такого свежего и приятного.
4148.08 4150.36 "Анатолий Кулаков" И был такой быстровесный фреймворк Nancy.
4150.36 4159.28 "Анатолий Кулаков" Многие Nancy любили ещё за его прекрасный синтаксис задания роутов и обработки как раз-таки вот этих реквестов.
4159.28 4164.56 "Анатолий Кулаков" Вот весь этот список роутов выжил, несмотря на Nancy, переехав в проект Carter.
4164.56 4169.36 "Анатолий Кулаков" Вы можете все ваши интпойнты, все ваши роуты описать просто-напросто в одном методе.
4169.36 4175.48 "Анатолий Кулаков" Если у вас их немного, если они у вас не слишком сложные, это довольно приятно и красиво выглядит.
4175.48 4187.32 "Анатолий Кулаков" Также он поддерживает OpenAPI с коробки, то есть ничего вы в плане юзабилити, в плане описания ваших контроллеров, вашего API вы не теряете.
4187.32 4189.64 "Анатолий Кулаков" Вот такой списочек инструментов набрался.
4189.64 4192.48 "Анатолий Кулаков" Надеюсь, что-то из этого было вам полезно.
4192.48 4194.60 "Игорь Лабутин" Не маленький список на самом деле.
4194.60 4198.72 "Игорь Лабутин" Давно у нас такого большого полезного перечисления не было.
4198.72 4209.48 "Игорь Лабутин" Действительно, наверняка что-нибудь будет полезно, а даже если конкретно те тулы или библиотеки, которые перечислены вам не пригодятся, они могут навести на какие-то соседние мысли.
4209.48 4224.76 "Игорь Лабутин" В частности, например, я когда искал себе альтернативы постману, нашел огромное количество всяких разных других REST клиентов, которые некоторые написаны, в том числе на C# и жрут поменьше памяти, а не как электронное приложение и так далее.
4224.76 4232.44 "Игорь Лабутин" Так что посмотрите эти библиотеки, посмотрите эти фреймворки, может что-то понравится или по крайней мере почерпнете какие-то идеи.
4232.44 4234.68 "Игорь Лабутин" Давай потихонечку сворачиваться.
4234.68 4236.60 "Игорь Лабутин" У нас есть последняя новость коротенькая.
4236.60 4237.60 "Игорь Лабутин" Это книжки.
4237.60 4241.98 "Анатолий Кулаков" Ну не то чтобы книжки, а просто книжка, но она по-моему стоит десятка.
4241.98 4246.76 "Анатолий Кулаков" Как Игорь уже упоминал, очень часто в наших выпусках встречается Эндрю Локк.
4246.76 4249.40 "Анатолий Кулаков" Поэтому мы не могли пройти мимо его книги.
4249.40 4254.56 "Анатолий Кулаков" Эндрю Локк выпустил книгу ASP.NET Core in Action, второе издание.
4254.56 4263.04 "Анатолий Кулаков" Это издание было опубликовано в марте 2021 года, то есть вот буквально свежачок, горячий, хорошенький.
4263.04 4270.24 "Анатолий Кулаков" Книга не маленькая, там более 800 страниц и зная Эндрю Локка, все эти страницы напичканы очень полезной информацией.
4270.24 4274.72 "Анатолий Кулаков" В принципе уже по содержанию видно, что он раскопал практически весь ASP.NET.
4274.72 4278.60 "Анатолий Кулаков" Все как мы любим, прошелся по всем частям, снизу до верху.
4278.60 4282.64 "Анатолий Кулаков" Кастомизация, полезные утилиты, третисторонние инструменты, библиотеки.
4282.64 4293.04 "Анатолий Кулаков" В общем, мне кажется, это одно из самых актуальных решений, один из самых полезных материалов, если вы захотите вот сейчас закапываться в ASP.NET.
4293.04 4297.08 "Анатолий Кулаков" Ну или даже не только закапываться, но и хорошо всесторонне изучить его.
4297.08 4299.48 "Анатолий Кулаков" Или, может быть, сэсимулятизировать те знания, которые у вас
4299.48 4302.60 "Игорь Лабутин" уже есть. Да, читайте книжки, это всегда полезно.
4302.60 4304.52 "Игорь Лабутин" Там можно найти много интересного.
4304.52 4306.88 "Игорь Лабутин" И теперь мы точно завершаем.
4306.88 4309.04 "Игорь Лабутин" Давайте вспомним, что мы сегодня обсудили.
4309.04 4316.00 "Игорь Лабутин" Это был DotNet 6 Preview 3, Visual Studio 2019-16-10 Preview 2.
4316.00 4326.12 "Игорь Лабутин" Поговорили про Open Source C#, поговорили про то, что можно смотреть новенькие сэмплы разработки на Android, iOS и других платформ для DotNet 6.
4326.12 4335.44 "Игорь Лабутин" Увидели, что практически в реальном времени завезли новую поддержку строк с антрополяцией в C# 10, которая теперь будет немножко по-другому обрабатываться.
4335.44 4340.48 "Игорь Лабутин" Посмотрели, как в ASP.NET Core смотреть на внутренности конфигурации и что там происходит.
4340.48 4346.44 "Игорь Лабутин" Как хостить ваши простые статические и не очень сайты с помощью Live Reload сервера.
4346.44 4350.44 "Игорь Лабутин" Обсудили декомпиляцию ELSPY и отладчик DNSPY.
4350.44 4356.20 "Игорь Лабутин" Посмотрели на огромнейший список тулов, пакетжей и библиотек для работы с HTTP.
4356.20 4360.20 "Игорь Лабутин" И рассказали про то, что вышла новая книжка Andrew Locke из ASP.NET Core in Action.
4360.20 4363.44 "Анатолий Кулаков" В самом конце у меня еще есть пара объявлений.
4363.44 4367.24 "Анатолий Кулаков" Как вы знаете, у нас есть сайты для поддержки.
4367.24 4371.72 "Анатолий Кулаков" Все, кто хочет нас поддержать, могут присоединиться к ним на Patreon Boost.
4371.72 4379.76 "Анатолий Кулаков" И там мы выкладываем наши прешоу, то есть те разговоры, которые у нас обычно происходят за кадрами основного выпуска.
4379.76 4386.16 "Анатолий Кулаков" Мы эти прешоу сейчас хотим раздавать абсолютно всем, кто нам помогает на этих сайтах.
4386.16 4390.68 "Анатолий Кулаков" Раньше они были доступны только за очень большие деньги на очень дорогих тарифах.
4390.68 4395.08 "Анатолий Кулаков" Мы решили сделать их подешевле, то есть абсолютно за минимальную цену.
4395.08 4403.08 "Анатолий Кулаков" Поэтому, если вам вдруг интересно и для вас это может служить каким-то мотиватором, заходите, посмотрите, что еще там есть интересного на этих сайтах.
4403.08 4407.60 "Анатолий Кулаков" Плюс у нас еще давно что-то ничего не разыгрывалось.
4407.60 4412.84 "Анатолий Кулаков" Я еще хочу сделать один подарок для всех, кто хочет нам помочь.
4412.84 4421.64 "Анатолий Кулаков" У нас есть три книги Джефри Рихтера, подписанные им лично, когда Джефри приезжал пару лет назад к нам в гости.
4421.64 4424.48 "Анатолий Кулаков" Выступал на наших митапах, выступал на конференциях.
4424.48 4430.08 "Анатолий Кулаков" И подписал специально для нас, для выпуска Radio.net три книги.
4430.08 4432.72 "Анатолий Кулаков" Мы эти книги просто так раздавать не хотим.
4432.72 4436.32 "Анатолий Кулаков" Мы хотим раздавать людям, которые нам могут помочь.
4436.32 4438.00 "Анатолий Кулаков" Помочь нам можно следующим образом.
4438.00 4440.24 "Анатолий Кулаков" Как-то порекламировать наш подкаст.
4440.24 4442.88 "Анатолий Кулаков" Например, вписать в наш подкаст какие-то awesome листы.
4442.88 4448.92 "Анатолий Кулаков" То есть это специальные листы, которые распространяются на GitHub и собирают список полезных .NET ресурсов.
4448.92 4455.88 "Анатолий Кулаков" Эти листы довольно популярны у различных сторонников в нашем случае .NET.
4455.88 4458.44 "Анатолий Кулаков" То есть там можно найти много интересных ресурсов.
4458.44 4460.96 "Анатолий Кулаков" И в том числе мы хотим, чтобы наш подкаст тоже там был доступен.
4460.96 4465.68 "Анатолий Кулаков" Поэтому, пожалуйста, вписывайте наш подкаст в такие листы, если они вам известны.
4465.68 4468.80 "Анатолий Кулаков" Присылайте нам на почту ссылки на ваши коммиты.
4468.80 4480.56 "Анатолий Кулаков" Если у вас есть какие-то свои собственные подкасты, свои собственные блоги, свои статьи, видеоблоги, то мы тоже будем вам очень признательны за рекламу нашего подкаста.
4480.56 4486.36 "Анатолий Кулаков" Или любой другой способ, который вы сочтете очень полезным.
4486.36 4488.80 "Анатолий Кулаков" Он тоже годится.
4488.80 4494.28 "Анатолий Кулаков" Присылайте нам на почту или в комментарии куда-нибудь ссылки на ваши работы, на ваше продвижение.
4494.28 4503.28 "Анатолий Кулаков" Мы уже сами, своими собственными силами, выберем победителя с учетом того, кто внес наибольший вклад, наверное, по нашему мнению.
4503.28 4505.64 "Анатолий Кулаков" И им раздадим книги.
4505.64 4508.56 "Анатолий Кулаков" Книг у нас с Джеффри Рихтером три штуки.
4508.56 4513.32 "Анатолий Кулаков" Поэтому, я думаю, все, кто хорошо вложится, все их получат.
4513.32 4516.64 "Анатолий Кулаков" Сроком этот конкурс будет, наверное, до конца апреля.
4516.64 4525.16 "Анатолий Кулаков" То есть, до конца апреля у вас есть возможность помочь нашему подкасту и плюс заработать книги Джеффри Рихтера с его личным автографом.
4525.16 4534.96 "Игорь Лабутин" Подписывайтесь, приходите, помогайте, делитесь новостями, делитесь идеями, расскажите, чего вам не хватает, расскажите, что вам интересно было бы еще, возможно, послушать.
4534.96 4537.40 "Игорь Лабутин" И мы будем прислуживаться ко всему фидбэку.
4537.40 4539.80 "Игорь Лабутин" А на этом мы на сегодня точно завершаемся.
4539.80 4541.92 "Игорь Лабутин" Это был 27 выпуск Радио.нет.
4541.92 4544.96 "Игорь Лабутин" С вами были Игорь Лабутин и Анатолий Кулаков.
