0.00 12.88 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет и его постоянный ведущий Анатолий Кулаков.
12.88 13.88 "Анатолий Кулаков" И Игорь Лабутин.
13.88 14.88 "Анатолий Кулаков" Всем привет.
14.88 23.52 "Анатолий Кулаков" Так, всем привет, всем огромное спасибо за помощь, видим ваши лайки, репосты во всех социальных сеточках, комментарии обязательно собираем.
23.52 38.84 "Анатолий Кулаков" На Ютубчике очень много у нас активных обсуждений, что не может не радовать, поэтому вы тоже не забывайте шартик, подкастик, репости, заходите на Ютуб, пишите там комментарии и рассказывайте друзьям, если вдруг наши выпуски вам интересны, может быть им тоже пригодятся.
38.84 50.32 "Анатолий Кулаков" И если хотите внести свою помощь еще больше, заходите на бусти, присоединяйтесь к благому списку помогаторов и в частности среди них вы можете лицезреть.
50.32 59.64 "Анатолий Кулаков" Александр, Сергей, Владислав, Лазарев Илья, Гурий Самарин, Виктор, Руслан Нартомонов, Александр Юрыгин, Сергей Бензенко, Александр Лапердин.
59.64 67.56 "Анатолий Кулаков" Большое спасибо, друзья, всем, кто нам помогает, шарит и вообще всячески как-нибудь помогает улучшить, изменить, усовершенствовать наш подкаст.
67.56 78.12 "Игорь Лабутин" Ну в этот раз у нас не так много новостей, я бы сказал, от основной команды тутнета, в смысле что вот у нас новый релиз-кандидат и все такое прочее.
78.12 84.48 "Игорь Лабутин" Да, релиз у нас осталось получается сколько, чуть больше месяца, но… Хорошо, мы хотя бы передохнуть
84.48 88.20 "Анатолий Кулаков" можем, там еще один релиз-кандидат будет у нас между этими месяцами.
88.20 90.80 "Игорь Лабутин" Будем надеяться, что будет, да.
90.80 96.48 "Анатолий Кулаков" Подожди, давай перед темами у нас очень много комментариев было насчёт нашей громкой унцы.
96.48 100.28 "Игорь Лабутин" О, унцы, да, унца, я надеюсь, стала потише.
100.28 105.92 "Игорь Лабутин" Этот выпуск будет третьим, где мы её заменили, возможно, вы это заметили, возможно, нет.
105.92 115.40 "Игорь Лабутин" Закиньте нам в ютубчик, пожалуйста, комментариев норм не норм, если кто-то был недоволен, стало хорошо, тоже напишите, если было хорошо, стало плохо, тоже пишите.
115.40 116.40 "Анатолий Кулаков" Посмотрим, кто победит.
116.40 121.48 "Анатолий Кулаков" Да, да, посмотрим, может кто-то будет кричать, верни типа громче, это плохо слышно и всё такое.
121.48 125.00 "Анатолий Кулаков" Кстати, да, если положительных не будет, что типа стало лучше, вернём обратно.
125.00 126.00 "Игорь Лабутин" Шантажист.
126.00 130.64 "Анатолий Кулаков" Ну что ж, а теперь по новостям.
130.64 135.28 "Анатолий Кулаков" Микрософт дал нам расслабиться, поэтому можно, наверное, осветить какие-то технические новости вокруг.
135.28 166.08 "Игорь Лабутин" Ну они не то что вокруг, они тоже в каком-то смысле от Майкрософта, потому что они про восьмой дотнет, но действительно начали появляться, ну не то что начали, подожди, они весь год, наверное, появлялись статьи про то, что нас ждёт восьмого дотнет и как, что сделано, но сейчас, видимо, такой период затишья, и плюс дотнет потихоньку обретает уже финальную форму того, как он будет выглядеть в момент релиза, и поэтому появляется много разных статей на тему каких-то мелких или не очень мелких аспектов вокруг дотнета восьмого.
166.08 194.64 "Анатолий Кулаков" Ну а также энтузиасты очень хорошо раскапывают различные аспекты, которые там сам Микрософт или не хочет, или не может осветить, или может с другого бока освещает, в общем это всегда такой хороший период, когда энтузиасты начинают осваивать те фишки, которые всё-таки зарелизятся в новом фреймворке, в общем и своё видение на это дают, как они там свои проблемы решают или какие там свои задачи, это всегда интересно посмотреть, то есть нормальные прикладные юзкейсы, не то в теории, как Микрософт планировал, а то как люди теперь будут этим микроскопом забивать гвозди.
194.64 207.24 "Игорь Лабутин" Да, и первый микроскоп, это штука, про которую мы уже упоминали, причём по-моему чуть ли не в прошлом выпуске, когда мы говорили про релиз кандидат-один, это же было наверное в прошлом выпуске, это новый подход к рефлекшену.
207.24 210.12 "Анатолий Кулаков" Да, да, это точно было в прошлом.
210.12 223.24 "Игорь Лабутин" Да, мы знаем, что у нас есть обычный наш классический рефлекшен, который позволяет вам делать, в общем, практически всё, что вы хотите с точки зрения доступа к внутреннему состоянию объектов в дотнете.
223.24 232.02 "Игорь Лабутин" Ну, наиболее, наверное, один из частых способов — это вызвать какой-нибудь private метод, либо получить доступ к какому-нибудь там private полю.
232.02 244.72 "Игорь Лабутин" Для этого мы обычно делаем, что мы каким-то образом получаем объект типа, это можно сделать либо через typeof, если вы знаете тип прям в compile-тайме, либо через gettype — метод, который вам вернёт тип в рантайме.
244.72 263.12 "Игорь Лабутин" Потом вы через специальное API получаете ссылку на field, точнее, ну да, ссылку на field, на объект, точнее, который описывает field внутри этого типа, указывая, соответственно, имя этого поля и набор флагов, то есть какой искать там instance поля, static поля, public поля и так далее.
263.12 272.12 "Игорь Лабутин" А дальше у вас есть специальные методы у этого объекта, getValue, setValue, через которые вы можете получить значение этого поля, либо проставить значение этого поля.
272.12 278.60 "Игорь Лабутин" При этом это методы не дженериковые, а вполне себе нормальные, которые с object работают.
278.60 285.12 "Игорь Лабутин" И там будет стильский боксинг, вот это всё, ну, в общем, reflection в принципе не для performance в каком-то смысле.
285.12 293.28 "Игорь Лабутин" Мы недавно обсуждали, что на самом деле есть там и все про performance тоже улучшения, там что-то стало кэшироваться, где-то стало генериться.
293.28 300.40 "Игорь Лабутин" Делегаты — это для вызова методов через reflection, и в общем и целом стало побыстрее, но тем не менее.
300.40 311.32 "Игорь Лабутин" Теперь у нас есть новый метод — получать доступ к закрытой информации, и это происходит через новый атрибут, который называется unsaveAccessorAttribute.
311.32 321.08 "Игорь Лабутин" Само слово unsave в названии подразумевает, что, наверное, в обычном коде лучше им не пользоваться, но если вам это очень надо, и вы знаете, что вы делаете, то вы можете это сделать.
321.08 329.76 "Игорь Лабутин" В этом атрибуте у него в конструкторе можно указать либо только kind, того, к чему вы собираетесь доступиться, либо kind и имя там где-то нужно.
329.76 335.08 "Игорь Лабутин" Сейчас поддержаны 4 kind'а, это конструктор, но в этом случае никакого имени не нужно.
335.08 341.68 "Игорь Лабутин" Можно указать метод или field, тут, понятно, имя обязательно, и оно должно совпадать с именем метода или field'а.
341.68 353.40 "Игорь Лабутин" И ещё можно указать kindProperty, и тогда в качестве метода нужно указать, например, set подчёркивание имя property, ну либо get подчёркивание property, соответственно, метод, который по сути вызывается.
353.40 359.72 "Игорь Лабутин" То есть вы указываете тот самый автосгенерённый метод, с помощью которого осуществляется доступ к property.
359.72 368.44 "Игорь Лабутин" Или он может быть… ну да, он в любом случае автосгенерённый, даже если вы getSetBlock'и указали явно в коде.
368.44 372.56 "Игорь Лабутин" Дальше вы делаете следующую конструкцию.
372.56 379.64 "Игорь Лабутин" Например, в примере в статье у нас есть тип counter, у которого есть поле внутри типа int.
379.64 384.88 "Игорь Лабутин" И для того, чтобы к нему достучаться, вам нужно сделать следующее.
384.88 389.16 "Игорь Лабутин" Вы пишете функцию, которая будет иметь следующий прототип.
389.16 395.60 "Игорь Лабутин" Во-первых, она будет static_extern, наверное, вы нечасто пишете extern функции в C#.
395.60 399.60 "Игорь Лабутин" Возвращать она будет ref_int, потому что поле типа int.
399.60 408.36 "Игорь Лабутин" Называется она как угодно, но в данном случае она называется getCountField, и аргументом она принимает объект того типа, к которому вы пытаетесь заступиться.
408.36 409.36 "Игорь Лабутин" То есть в данном случае counter.
409.36 412.16 "Игорь Лабутин" Всё типизировано, всё вообще замечательно.
412.16 417.44 "Игорь Лабутин" Вы размечаете этот метод, у него не будет тела, это просто объявление, как в paintwalk'е, короче.
417.44 427.84 "Игорь Лабутин" Вы размечаете его атрибутом unsafe_accessory, атрибют, где указываете, что вы хотите получить доступ к полю, к field'у и именем count, например, как он там называется внутри.
427.84 442.60 "Игорь Лабутин" Дальше, там, где вам нужно получить доступ к этому field'у, вы вызываете статический метод, передаете туда объект, у которого вы хотите получить доступ к этому private полю, и получаете в ответе ссылку на это поле.
442.60 448.64 "Игорь Лабутин" В результате вы можете по этой ссылке либо прочитать значение, либо вы можете записать.
448.64 453.04 "Игорь Лабутин" Синтексис получается довольно странный, вы в C# нечасто такое увидите.
453.04 464.60 "Игорь Лабутин" Синтексис будет что-то в духе getCountField, скобочка открылась, дальше название инстанса вашего объекта, переменной, там, counter, скобочка закрылась, присвоить, там, 5.
464.60 470.40 "Игорь Лабутин" То есть вроде как какой-то странный вызов функции слева от знака присваивания, от оператора присваивания.
470.40 473.52 "Игорь Лабутин" Ну вот, поскольку там refint, то так можно.
473.52 475.52 "Игорь Лабутин" Зачем это сделано?
475.52 493.08 "Игорь Лабутин" Казалось бы, это сделано для перформанса, потому что это будет работать офигенно быстро, и там бенчмарк, что-то типа там reflection вариант 32 наносекунды, а этот вариант 0, что-то по-моему 3, если я правильно помню, то есть типа в 100 раз быстрее, чем reflection.
493.08 497.16 "Игорь Лабутин" Но на самом деле основная цель это nativeout.
497.16 500.84 "Игорь Лабутин" Проблема в том, что в nativeout reflection очень ограничен.
500.84 513.08 "Игорь Лабутин" А еще в nativeout работает trimming, который может повыкидывать вообще все, что можно из вашей сборки, без учета доступа по reflection, и ваш reflection перестанет работать вообще, даже если бы он хоть как-то работал.
513.08 528.76 "Игорь Лабутин" А эта штука, она compile-time, поэтому в compile-time будет известно, что можно оставить, что нельзя оставить, кому у вас есть доступ, кому нет доступа, здесь будет явно ссылка на нужный вам тип, и поэтому этот самый trimming его не уберет.
528.76 534.72 "Игорь Лабутин" Есть еще гора ограничений у этого метода и способа доступа.
534.72 553.36 "Игорь Лабутин" Пока не поддерживается то, что они называют private или internal типа, то есть если у вас есть чужая сборка, в которой есть тип, который internal, несмотря на то, что весь код, ну вот этот новый код, который вы пишете, сейв-аксессор-этребьют, он навешивается снаружи этой сборки, то есть вы пишете его в своем коде, все равно работать не будет.
553.36 554.36 "Игорь Лабутин" Пока.
554.36 558.88 "Игорь Лабутин" Не поддерживается таким образом доступ к статическим методам и к статическим полям.
558.88 563.84 "Игорь Лабутин" Все это, я так понимаю, запланировано уже на 9.net, так что ждем там.
563.84 571.64 "Игорь Лабутин" А еще хотят сделать generic версию этого атрибута, не очень понимаю зачем, потому что типы там фактически не указываются, но наверное за чем-то полезно.
571.64 572.64 "Игорь Лабутин" Будет.
572.64 601.20 "Игорь Лабутин" Вот такая вот тема, если вы зачем-то использовали много всякой разной рефлексии для того, чтобы иметь доступ к private полям или private методам, мне кажется, что несмотря на слово unsave, вполне можно это в 8.net использовать нормально, потому что если вы используете reflection, в таком виде вы уже сами по себе unsave, и просто лишний раз подчеркнуть в коде, что это unsave операция, будет вполне не лишним, заодно работать будет быстрее.
601.20 607.32 "Анатолий Кулаков" Ну надо просто коллег предупредить, чтобы они сразу в обморок не падали, какую-нибудь ссылочку на документацию ставить.
607.32 613.40 "Игорь Лабутин" Ну да, но это же будет нормальный код такой, просто unsave название атрибутика, ничего такого.
613.40 628.80 "Анатолий Кулаков" Слушай, ну и не очень честно, что авторы называют эту штуку как замена reflection, или новая версия reflection, или еще что-то с reflection, потому что это всего лишь навсего один из методов reflection, сам по себе reflection намного мощнее, то есть это никакая не замена и ничего такого.
628.80 642.64 "Игорь Лабутин" Ну да, вы так не сможете получить в рантайме список полей типа, ну или список методов, выбрать в динамике в зависимости от каких-то условий, какой же метод вам нужно вызвать, это все понятно не работает, это вам.
642.64 647.40 "Игорь Лабутин" Если вы твердо знаете на момент compile time, что вам нужно зачем-то постучаться во внутреннюю структуру
647.40 650.56 "Анатолий Кулаков" данных. Ну и достать, да, значение именно поля.
650.56 655.60 "Анатолий Кулаков" Кстати, как развитие этого подхода, наверное, было бы удобно еще дергать точно так же приватные методы.
655.60 657.60 "Игорь Лабутин" А их можно дергать.
657.60 663.96 "Анатолий Кулаков" То есть погоди, ты же получаешь только значение по ссылке, ты же не получаешь там сколько ссылок на метод.
663.96 667.60 "Игорь Лабутин" Нет, подожди, unsave_accessor, ты указываешь kind, в том числе можно указать метод.
667.60 670.44 "Анатолий Кулаков" А, точно, я забыл, там же kind есть.
670.44 671.44 "Анатолий Кулаков" Да, да.
671.44 673.44 "Анатолий Кулаков" Даже конструктор можно вызвать, приватный.
673.44 674.44 "Анатолий Кулаков" Да, конструктор, я помню.
674.44 679.88 "Анатолий Кулаков" Ну хорошо, понятный подход, понятно, кому нужен, опять же, не злоупотреблять.
679.88 688.14 "Анатолий Кулаков" Ну наверное, так как у нас уже все привыкли не злоупотреблять reflection, то наверное этим атрибутом тоже мы все будем пользоваться в меру.
688.14 690.64 "Анатолий Кулаков" Посмотрим, мера у каждого разная.
690.64 692.64 "Анатолий Кулаков" Ну что, пойдем дальше?
692.64 693.64 "Анатолий Кулаков" Давай.
693.64 699.16 "Анатолий Кулаков" Так, дальше я хотел бы вам рассказать про улучшения в System Text JSON.
699.16 702.36 "Анатолий Кулаков" Мы в прошлый раз обсуждали релиз кандидата, там, мою и Entity Framework.
702.36 707.00 "Анатолий Кулаков" В общем, один из ключевых компонентов в System Text JSON мы пропустили.
707.00 714.96 "Анатолий Кулаков" Вот давай к нему вернемся и все-таки обсудим, а что же там нас ждет в Дотнет 8, какие импровьменты принесет нам эта чудесная библиотечка.
714.96 726.76 "Анатолий Кулаков" Кстати, заметь, довольно интересно, потому что раньше Microsoft очень много версий, даже десятилетий не обращал внимания на свою собственную реализацию систем, ну, свою собственную реализацию JSON, да?
726.76 732.86 "Анатолий Кулаков" То есть все пользовались Newtonsoft, и как бы всех это устраивало, в том числе даже сам Microsoft пользовался Newtonsoft.
732.86 743.62 "Анатолий Кулаков" А тут прямо текст JSON в каждом релизе мелькает, куча импровьментов, самый первый на себе испытал Source Generator, самый первый на себя взял I/O, в общем, такой передовик.
743.62 757.66 "Игорь Лабутин" Ну я думаю, что это из-за того, что в каких-нибудь бенчмарках, там, техэмпауру или где-нибудь было понятно, что а теперь мы страдаем с реализацией JSON, и надо как-то улучшать, а с Newtonsoft непонятно что делать, он на рефлексии частично, и фиг улучшишь.
757.66 768.38 "Анатолий Кулаков" Мне кажется, там все эти бенчмарки, они больше про вызов каких-нибудь REST методов, HTTP методов, которые просто возвращают тебе body, а кто их там парсить будет, зачем тебе body парсить?
768.38 771.58 "Игорь Лабутин" Там разные есть, там есть бенчмарк, который среализует JSONчик.
771.58 772.58 "Анатолий Кулаков" А, с реализатором?
772.58 773.58 "Анатолий Кулаков" Да.
773.58 780.70 "Анатолий Кулаков" Ну допустим, допустим, но все же мне кажется, к нему внимания больше, чем к ISP.net, так что не только
780.70 790.34 "Игорь Лабутин" бенчмарк один. Может быть нам надо вернуться на, не знаю, сколько, 2 года назад, 3 года назад и посмотреть мотивацию, зачем это было придумано, но придумано, придумано.
790.34 796.18 "Игорь Лабутин" Сорс-генераторы, по крайней мере, действительно, это пожалуй одно из первых мест, где они были так широко применены.
796.18 812.70 "Анатолий Кулаков" Ну и, кстати, в сорс-генераторах-то первые изменения всегда и описываются, потому что, наверное, наиболее незначимы в том, ибо сейчас, да и всегда, в принципе, сорс-генераторы это является основная движущая сила айота, нейтива айота, поэтому все их очень любят.
812.70 813.78 "Анатолий Кулаков" Давайте же посмотрим.
813.78 822.10 "Анатолий Кулаков" Прежде всего, теперь, ну как мы уже сказали, да, у нас сериализация джессоновская поддерживает сорс-генераторы.
822.10 837.22 "Анатолий Кулаков" То есть вы можете сделать специальный контекст, partial class, навесить на него веселый атрибутик, нажать build и вам сорс-генератор сгенерит класс, строго типизированный, под сериализацию и десериализацию вашего конкретного объекта.
837.22 847.10 "Анатолий Кулаков" Там уже будет минимум какого-нибудь боксинга, совсем не будет рефлекшна, и он будет обращаться напрямую к вашим свойствам, геттерам, сеттерам, в общем, все как положено.
847.10 852.90 "Анатолий Кулаков" Как будто вы заполняете ваши классики сами и сериализуете ваши классики сами, прямо в своем коде, прямо ручками.
852.90 854.98 "Анатолий Кулаков" В общем, это вот магия сорс-генератора.
854.98 866.22 "Анатолий Кулаков" И поэтому ее первые улучшают в каждый релиз, потому что она дает максимальный эффект на очень много областей, которые связаны и с перформансом, и с многим чем еще.
866.22 875.26 "Анатолий Кулаков" Так вот, как раз, теперь вот эти сорс-генераторы, которые у нас умеют сериализовать и десериализовать, поддерживают такие ключевые слова, как required и init.
875.26 888.74 "Анатолий Кулаков" Это довольно новые ключевые слова, поэтому я напомню кратко, что слово init, которое проставляется там в свойствах, оно было добавлено для того, чтобы обозначить, что данное свойство можно заполнить во время создания объекта.
888.74 895.78 "Анатолий Кулаков" Потом, через версию, разработчики вспомнили, что можно заполнить, это совсем не значит, что люди будут заполнять.
895.78 904.98 "Анатолий Кулаков" И придумали еще одно ключевое слово, которое назвали required, которое обозначает, что данное свойство должно быть заполнено во время инициализации объекта.
904.98 921.10 "Анатолий Кулаков" Так вот, теперь сериализаторы умеют понимать эти слова и умеют, соответственно, правильно заполнять ваши дтошки, если вы десериализуете какой-нибудь респонс или реквест, то сериализатор радостно вам пронициализирует поля required и init с учетом их семантики.
921.10 934.78 "Анатолий Кулаков" Дальше добавили интересный generic атрибут, который призван уменьшить как раз-таки runtime специфику для кода генерации.
934.78 942.22 "Анатолий Кулаков" В общем, мы раньше могли преобразовать enum в строки с помощью специального атрибута, который назывался JSON-String-enum-Converter.
942.22 950.62 "Анатолий Кулаков" И этот конвертер, соответственно, для преобразования ему необходимо, нужно было runtime-информация.
950.62 964.10 "Анатолий Кулаков" В общем, теперь добавили generic версию этого атрибута, который вы в качестве generic передаете как раз-таки тип этого enum, и больше никакая генерация в runtime не нужна кода генерации.
964.10 975.50 "Анатолий Кулаков" И мы, соответственно, можем в кодогенераторах использовать код полностью без reflection, полностью без runtime, что, соответственно, удовлетворило найти iot.
975.50 980.54 "Анатолий Кулаков" Теперь iot очень рад и с этим атрибутом еще лучше будет оптимизировать ваш код.
980.54 989.86 "Анатолий Кулаков" Так, теперь еще расширили возможности JSON Source Generation Options.
989.86 996.26 "Анатолий Кулаков" Эти опшоны, даже не опшонсы, а атрибут, который олицетворяет эти опшоны.
996.26 998.90 "Анатолий Кулаков" Есть два способа настройки JSON серилизатора.
998.90 1001.50 "Анатолий Кулаков" Первый - это через JSON опции.
1001.50 1010.38 "Анатолий Кулаков" Это класс, в котором вы там собираете, нужно ли там скипать запятые, нужно ли учитывать комментарии, какой буфер-сайз у серилизатора.
1010.38 1012.74 "Анатолий Кулаков" Короче, все свойства данного серилизатора.
1012.74 1018.34 "Анатолий Кулаков" В общем, и есть такой классик, как JSON Source Generation Option Attribute.
1018.34 1028.18 "Анатолий Кулаков" Этот атрибут вешается как раз-таки над будущим классом, который в себе сгенерит серилизатор и в соответствующем образом настраивает сам серилизатор.
1028.18 1033.06 "Анатолий Кулаков" И раньше у этого класса было довольно мало настроек, а сейчас там есть довольно много настроек.
1033.06 1039.86 "Анатолий Кулаков" То есть, все, что возможно было вытащить из этих опций, перенесли в том числе и в этот атрибут.
1039.86 1049.70 "Анатолий Кулаков" В общем, теперь настройка серилизатора, который будет генериться, она будет максимально приближена по возможностям к тому, что вы могли бы сделать с помощью обычных опций.
1049.70 1054.70 "Анатолий Кулаков" А еще одна интересная фича-свитчер появилась.
1054.70 1058.06 "Анатолий Кулаков" Это запрет рефлекшена по умолчанию.
1058.06 1074.06 "Анатолий Кулаков" То есть, раньше, если вдруг у вас Source Generator понимал, что данный класс невозможно серилизовать или десерилизовать без рефлекшена, он переключался в Reflection Mode и с помощью рефлекшена как бы доставал значение, делал что-то еще.
1074.06 1077.70 "Анатолий Кулаков" И для программиста это было абсолютно непрозрачно.
1077.70 1087.26 "Анатолий Кулаков" То есть, программист не знал, что у него будет, грубо говоря, на продакшене, потому что у себя под операционной системой он вполне мог дебажиться и видеть, как все хорошо работает.
1087.26 1096.26 "Анатолий Кулаков" А когда он деплоится под операционную систему, в которой динамическая кодогенерация в runtime запрещена, его приложение вполне могло бы упасть.
1096.26 1098.42 "Анатолий Кулаков" То есть, поведение, грубо говоря, отличается.
1098.42 1102.46 "Анатолий Кулаков" Вот чтобы поведение было предсказуемым, как раз ввели такой флаг.
1102.46 1104.86 "Анатолий Кулаков" Запретить по умолчанию использовать рефлекшен.
1104.86 1115.58 "Анатолий Кулаков" То есть, если теперь Source Generator или Serializator увидит, что ему нужно перейти в Reflection Mode для того, чтобы децерализовать какое-то поле или сериализовать, то он просто-напросто рухнет.
1115.58 1121.46 "Анатолий Кулаков" Эта ошибка тоже будет, конечно, в runtime, но хотя бы она будет предсказуема и там, и там, и везде одинаковой.
1121.46 1130.02 "Анатолий Кулаков" Очень хорошо убеждаться, что ваш сериализатор полностью поддерживает nativeout включением вот этой специальной фичи.
1130.02 1133.30 "Анатолий Кулаков" Ее можно включить через фичи-флаг, а можно включить через MSBuildProperty.
1133.30 1142.90 "Анатолий Кулаков" В результате всех вот этих ублажений nativeout у нас уменьшился размер испускаемых бинарников.
1142.90 1153.10 "Анатолий Кулаков" То есть, если мы возьмем self-contained nativeout приложение, которое активно использует System Text JSON, потому что он раньше за собой тащил очень много всего.
1153.10 1158.30 "Анатолий Кулаков" На седьмом дотнете такое приложение занимало 3,4 МБ.
1158.30 1161.70 "Анатолий Кулаков" Не то чтобы много, но на восьмом оно занимает 2,6 МБ.
1161.70 1167.06 "Анатолий Кулаков" То есть, это 23% уменьшился binary size в результате вот этих всех оптимизаций.
1167.06 1169.66 "Анатолий Кулаков" В принципе, 23% это неплохо.
1169.66 1170.66 "Анатолий Кулаков" Это очень даже хорошо.
1170.66 1174.14 "Анатолий Кулаков" Так, пойдем к другим свойствам сериализатора.
1174.14 1176.34 "Анатолий Кулаков" Вот эта фича, которую я очень долго ждал.
1176.34 1179.22 "Анатолий Кулаков" Это заполнение read-only свойств.
1179.22 1188.58 "Анатолий Кулаков" Представьте, если вы пишете обычно DTO, то у DTO есть свойства с примитивными типами, а есть еще коллекции или листы.
1188.58 1194.70 "Анатолий Кулаков" В общем, и эти листы обычно инициализируют сразу каким-то пустым экземпляром.
1194.70 1196.94 "Анатолий Кулаков" Не пустым листом или что-то в этом духе.
1196.94 1202.02 "Анатолий Кулаков" Потому что существует такое негласное правило, что коллекции никогда не должны быть нулябельными.
1202.02 1204.18 "Анатолий Кулаков" Это правило дает очень много преимуществ.
1204.18 1210.58 "Анатолий Кулаков" То есть, очень легко начинается с коллекциями работать, и на каждый чих не нужно проверять, есть там значение или нет.
1210.58 1213.06 "Анатолий Кулаков" Поэтому обычно они инициализируют его пустым значением.
1213.06 1222.14 "Анатолий Кулаков" А так как его инициализируют пустым значением, и обычно, чтобы заполнить эту коллекцию, вам достаточно просто вызвать какие-нибудь методы add и прочее.
1222.14 1225.30 "Анатолий Кулаков" То есть, обычно коллекцию не переприсваивают.
1225.30 1231.34 "Анатолий Кулаков" Это значит, что обычно свойствам, которые испускают из себя мутабельные коллекции, у них нет сеттера.
1231.34 1233.14 "Анатолий Кулаков" То есть, им сеттер не пишут.
1233.14 1239.34 "Анатолий Кулаков" И даже есть какие-то анализаторы, которые говорят, что типа уберите товарища сеттера, он нам там не нужен.
1239.34 1244.34 "Анатолий Кулаков" И раньше для DTO-шек, в принципе, это правило я тоже часто использовал.
1244.34 1248.46 "Анатолий Кулаков" Причем это правило, наверное, больше такое к бизнес-логике применимо.
1248.46 1250.18 "Анатолий Кулаков" Но почему бы и нет?
1250.18 1252.46 "Анатолий Кулаков" Для DTO-шек оно тоже вполне могло бы работать.
1252.46 1255.94 "Анатолий Кулаков" Я себя поймал на мысли, что раньше я его использовал именно с Newtonsoft.
1255.94 1260.72 "Анатолий Кулаков" Потому что в текущих версиях серилизатора мы так делать не можем.
1260.72 1269.86 "Анатолий Кулаков" То есть, если у вас класс есть, и есть свойство, у которого есть только getter, ну, допустим, свойство, которое возвращает мутабельный лист.
1269.86 1275.38 "Анатолий Кулаков" То есть, если у вас только getter, то серилизатор в него не будет записывать значения.
1275.38 1276.38 "Анатолий Кулаков" Даже если мог бы.
1276.38 1280.38 "Анатолий Кулаков" Серилизатору нужно обязательно setter для того, чтобы начать свойство записывать.
1280.38 1282.90 "Анатолий Кулаков" И наконец-то это исправлено.
1282.90 1286.02 "Анатолий Кулаков" То есть, это теперь можно сконфигурировать.
1286.02 1291.74 "Анатолий Кулаков" Появилось новое значение единамчика, которое называется JSON Object Creation Handling.
1291.74 1294.54 "Анатолий Кулаков" У единамчика есть значение populate.
1294.54 1303.14 "Анатолий Кулаков" Это значит, что существующие элементы коллекции, они будут заполняться значениями при десериализации.
1303.14 1307.82 "Анатолий Кулаков" Даже если у них нет setter, но при этом на наружу выставлен нормальный мутабельный лист.
1307.82 1313.98 "Анатолий Кулаков" Интересно заметить, что текущие элементы, которые есть в этом листе, они не удаляются.
1313.98 1317.10 "Анатолий Кулаков" То есть, все, что вы будете десериализовать, туда будет добавляться.
1317.10 1320.74 "Анатолий Кулаков" Соответственно, вы можете в этом листе иметь какие-то дефолты значения почему-то.
1320.74 1323.46 "Анатолий Кулаков" В общем, флажок хороший.
1323.46 1330.50 "Анатолий Кулаков" Жалко, по-моему, по умолчанию не включен, но, скорее всего, из-за того, чтобы они, наверное, нарушили бы обратную совместимость.
1330.50 1333.86 "Анатолий Кулаков" То есть, поведение JSON-серилизатора довольно сильно изменяется.
1333.86 1337.06 "Анатолий Кулаков" Так, пойдем дальше.
1337.06 1343.50 "Анатолий Кулаков" Появился интересный тоже enum, который называется JSON Unmapped Member Handling.
1343.50 1352.58 "Анатолий Кулаков" Этот enum обозначает, как нужно десериализатору вести себя с теми свойствами, которые он встретил в JSON, но при этом не нашел их в DTO.
1352.58 1356.82 "Анатолий Кулаков" То есть, они к вам пришли в виде данных, но куда их разложить он не знает.
1356.82 1358.86 "Анатолий Кулаков" И есть, соответственно, два свойства.
1358.86 1362.14 "Анатолий Кулаков" Skip – это он их просто игнорирует, то, что было раньше.
1362.14 1365.58 "Анатолий Кулаков" И новая незаменимая свойства, которая называется Disallow.
1365.58 1370.10 "Анатолий Кулаков" Если вы включите данный флажок этим свойствам, то будет бросаться эксепшены.
1370.10 1375.78 "Анатолий Кулаков" То есть, если вам в JSON пришли вдруг какие-то поля, которых ваша DTO не знает, произойдет эксепшен.
1375.78 1388.78 "Анатолий Кулаков" Наверное, это кому-то нужно, но на самом деле такая ситуация довольно странная, потому что как раз-таки по всем правилам вы должны быть максимально лояльны к тому контракту, который к вам приходит.
1388.78 1399.62 "Анатолий Кулаков" Потому что в новых версиях вполне наверняка ваши клиенты, которые, допустим, из внешней среды вам засылают JSON, они наверняка будут поля новые добавлять.
1399.62 1404.58 "Анатолий Кулаков" И по всем канонам добавление не считается breaking changes, и про это не должно ничего происходить.
1404.58 1407.94 "Анатолий Кулаков" Все обработчики должны просто новые поля, которые их не понимают, должны их игнорировать.
1407.94 1409.14 "Анатолий Кулаков" И это нормальное поведение.
1409.14 1415.38 "Анатолий Кулаков" В общем, мне кажется, что я за всю свою карьеру ни разу не встречал ситуации, когда мне нужно бросить эксепшен.
1415.38 1429.74 "Анатолий Кулаков" И даже если мне пришлось бы это сделать, то скорее всего я бы собрал все те поля, которых я не знаю, как бы в отдельный какой-то списочек и как-то их проанализировал, если бы нужно, из этого списочка бы сделал вывод и бросил бы исключение.
1429.74 1433.62 "Анатолий Кулаков" Но доверять этой автоматической децентрализации не знаю, зачем такое было нужно.
1433.62 1435.50 "Анатолий Кулаков" Ну, теперь умеем, и это хорошо.
1435.50 1439.70 "Анатолий Кулаков" Также у нас добавились новые полисы для нейминга.
1439.70 1449.22 "Анатолий Кулаков" Раньше у нас сервизатор имел достаточно ограниченное количество стратегий, как преобразовать имена в JSON файлики, в JSON формате.
1449.22 1452.58 "Анатолий Кулаков" Там был только camelCase, если не ошибаюсь, и все.
1452.58 1455.30 "Анатолий Кулаков" Сейчас добавился kebabCase и snakeCase.
1455.30 1459.54 "Анатолий Кулаков" И не просто добавился, а еще их вариации добавились.
1459.54 1465.50 "Анатолий Кулаков" То есть у нас есть теперь kebabCase_lower, kebabCase_upper, а также snakeCase_lower и snakeCase_upper.
1465.50 1468.34 "Анатолий Кулаков" В общем, теперь можем и lower, и upper делать.
1468.34 1471.14 "Анатолий Кулаков" Странно, что до сих пор как бы не добавили pascalCase.
1471.14 1474.70 "Анатолий Кулаков" Странно думают люди, что это нигде никому не пригодится.
1474.70 1485.22 "Анатолий Кулаков" Ну, потому что это форма записи, да, мы записываем всегда вроде C# объектов, C# объектов и так по умолчанию pascalCase, но для полноты картины почему-то, мне кажется, было бы справедливо.
1485.22 1487.38 "Анатолий Кулаков" Вот, погнали дальше.
1487.38 1495.46 "Анатолий Кулаков" Интересная еще функция – это интерфейс, поддержка серилизации интерфейсной иерархии.
1495.46 1501.50 "Анатолий Кулаков" Очень мутная штука, хотя нет, полиморфная децентрализация еще муднее, поэтому давайте разбираться.
1501.50 1513.78 "Анатолий Кулаков" Если, допустим, у вас есть интерфейс, и у которого есть имплементации, и эти имплементации добавляют несколько свойств своих собственных, которых нет в интерфейсе.
1513.78 1519.34 "Анатолий Кулаков" Допустим, в интерфейсе есть свойство a, а имплементация реализовала свойства a и плюс добавила свои там еще b и c.
1519.34 1523.74 "Анатолий Кулаков" Вот, и теперь мы пытаемся засерилизовать объект этого интерфейса.
1523.74 1532.38 "Анатолий Кулаков" Когда мы серилизовали это в предыдущих версиях серилизатора, то на самом деле в JSON попадали только те поля, которые есть в этом интерфейсе.
1532.38 1541.54 "Анатолий Кулаков" Сейчас же, начиная с восьмой версии, в JSON попадут все поля, которые есть в имплементации, то есть в том инстансе, который мы пытаемся засерилизовать.
1541.54 1546.70 "Анатолий Кулаков" В общем, так поведение изменится в будущих версиях.
1546.70 1549.70 "Анатолий Кулаков" Прямо из коробки у нас появилась поддержка новых типов.
1549.70 1556.42 "Анатолий Кулаков" Я напомню, что у нас есть новые типы, которые называются half, int128 и uint128.
1556.42 1564.90 "Анатолий Кулаков" А также из deserilizator и vserilizator можно легко загонять memory от t и read-only memory от t.
1564.90 1571.22 "Анатолий Кулаков" То есть вот такие оптимизированные структуры, оптимизированные стримы серилизатором тоже теперь понимаются в обе стороны.
1571.22 1581.22 "Анатолий Кулаков" Еще интересное наблюдение, то есть команда провела какой-то performance анализ и увидела, что люди очень часто неправильно используют JSON options.
1581.22 1584.02 "Анатолий Кулаков" В частности, JSON serializer options.
1584.02 1588.14 "Анатолий Кулаков" Такой специальный классик, потому что многим кажется, что там просто опции.
1588.14 1589.86 "Анатолий Кулаков" Судя по названию, как бы логично.
1589.86 1594.78 "Анатолий Кулаков" На самом деле, эта сволочь внутри себя еще хранит все кэши от серилизатора.
1594.78 1605.86 "Анатолий Кулаков" То есть, когда вы пользуетесь серилизатором, он переиспользует опции, он сам записывает в них определенные структуры, которые необходимы ему для ускорения работы и оттуда же их читает при следующем запуске.
1605.86 1615.10 "Анатолий Кулаков" Это значит, что если вы будете JSON serializer options каждый раз создавать новые, то по сути кэши не будут работать.
1615.10 1620.38 "Анатолий Кулаков" То есть, ваш серилизатор будет работать всегда как будто… всегда будет работать так, как будто вы запустили его первый раз.
1620.38 1621.38 "Анатолий Кулаков" Обычно это медленно.
1621.38 1628.58 "Анатолий Кулаков" Он начинает там что-то такое мутное собирать, что-то такое мутное искать, в общем, он мог бы сразу взять JSON кэши и все, не тратить на это время.
1628.58 1639.06 "Анатолий Кулаков" Ситуацию немножко изменили, как бы Microsoft цепунили свою ошибку и перенесли часть кэшей в некий расшаренный кэш, к которому теперь обращаются все серилизаторы.
1639.06 1651.62 "Анатолий Кулаков" Но все же в опциях кое-что осталось, что все-таки делает переиспользование одного инстанса опций очень полезным для вашей производительности.
1651.62 1660.94 "Анатолий Кулаков" Поэтому был написан специальный анализатор, который бросает предупреждение, если вдруг вы опции создаете всего лишь на один вызов серилизации, на один вызов децерилизации.
1660.94 1668.66 "Анатолий Кулаков" И он вам советует типа создайте опции один раз, где-нибудь у себя их сохраните и просто передавайте в серилизацию, децерилизацию как бы в виде аргумента.
1668.66 1672.70 "Анатолий Кулаков" Так вам будет быстрее и соответственно ронтайма меньше работы.
1672.70 1679.62 "Анатолий Кулаков" Расширились мощь атрибутов JSON-Include и JSON-Конструктор.
1679.62 1694.34 "Анатолий Кулаков" Если раньше они были ограничены только публичными свойствами, то есть мы могли только публичные конструкторы и публичные свойства передавать им, то в новой версии они получили возможность применяться к непубличным свойствам и филдам и конструкторам.
1694.34 1699.66 "Анатолий Кулаков" В общем теперь можно и internal свойства серилизать, и приватные конструкторы создавать.
1699.66 1708.06 "Анатолий Кулаков" В общем все как и должно быть, с полной мощью, которой мы уже давно все привыкли и давно все любим.
1708.06 1710.14 "Анатолий Кулаков" Тут правда есть одна тонкость.
1710.14 1718.98 "Анатолий Кулаков" Пока приватные конструкторы и приватные свойства не поддержаны в source-генераторе, то есть в серилизаторе, который генерится с помощью source-генератора.
1718.98 1723.10 "Анатолий Кулаков" Ну, скорее всего, помню нашу предыдущую тему, допилят.
1723.10 1725.74 "Анатолий Кулаков" И к приватным будут обращаться, и куда угодно будут обращаться.
1725.74 1733.94 "Анатолий Кулаков" Еще здесь можно упомянуть про JSON Serializer Options, которые мы вот только что обсуждали.
1733.94 1738.06 "Анатолий Кулаков" У него появилась явно метод makeReadOnly.
1738.06 1744.22 "Анатолий Кулаков" Дело в том, что изначально JSON Serializer Options был спроектирован под Freezable Semantic.
1744.22 1754.90 "Анатолий Кулаков" Я напомню, что Freezable Semantic, она применяется для неких изменяемых сущностей, которые обычно сначала как-то конфигурируют, или наполняют, или что-то с ними делают.
1754.90 1756.22 "Анатолий Кулаков" Как-то их изменяют.
1756.22 1761.42 "Анатолий Кулаков" Потом вызывают метод какой-нибудь freeze, и они становятся сразу read-only.
1761.42 1765.22 "Анатолий Кулаков" То есть у них уже нельзя ничего изменять, ничего конфигурировать, ничего с ними больше делать невозможно.
1765.22 1766.22 "Анатолий Кулаков" Нельзя.
1766.22 1767.22 "Анатолий Кулаков" Вот.
1767.22 1772.10 "Анатолий Кулаков" И на самом деле JSON Serializer Options всегда был таким Freezable, просто был неявно.
1772.10 1777.54 "Анатолий Кулаков" Вы его могли конфигурировать сколько угодно, но в момент первой серилизации он фризился.
1777.54 1780.46 "Анатолий Кулаков" После первой серилизации его уже невозможно было менять.
1780.46 1786.02 "Анатолий Кулаков" В данной версии вынесли метод makeReadOnly наружу.
1786.02 1794.54 "Анатолий Кулаков" Теперь он публичный, теперь каждый потребитель может его дернуть и без тяжелого процесса серилизации зафризить данный классик.
1794.54 1798.06 "Анатолий Кулаков" И также появилось свойство, которое называется isReadOnly.
1798.06 1802.54 "Анатолий Кулаков" То есть можно проверить, зафризено там все или не зафризено.
1802.54 1811.54 "Анатолий Кулаков" Также у нас есть улучшение в System.NET HTTP JSON Namespace.
1811.54 1818.22 "Анатолий Кулаков" Это специальный Namespace, который используют JSON-сериализаторы для того, чтобы работать с HTTP-клиентами, например.
1818.22 1828.54 "Анатолий Кулаков" Там очень много хороших, полезных методов расширения, которые позволяют вам одним-единственным методом и отправить запрос, и допустим, дестерилизовать результат, который там ушел.
1828.54 1834.14 "Анатолий Кулаков" В общем, самый современный и успешный путь для того, чтобы пользоваться HTTP-клиентами.
1834.14 1835.14 "Анатолий Кулаков" Но речь не о том.
1835.14 1843.30 "Анатолий Кулаков" Речь о том, что мы теперь поддержали специальную стриминговую дестерилизацию, которая реализуется интерфейсом iAsyncEnumerable.
1843.30 1868.78 "Анатолий Кулаков" То есть теперь HTTP-клиент, у него можно вызвать метод getFromJSONcAsAsyncEnumerable, в общем, передать ему, естественно, какой-то URL, попросить у него какой-то строго типизированный результат, и он вам в режиме стриминга будет отдавать enumerable… То есть он вам отдаст enumerable коллекцию, и в режиме стриминга он вам будет отдавать по одному элементу из этой коллекции.
1868.78 1874.22 "Анатолий Кулаков" То есть сервер может по одному элементу генерить на output, а ваш клиент может по одному элементу употреблять.
1874.22 1878.74 "Анатолий Кулаков" И таким образом можно генерить абсолютно бесконечный стриминг.
1878.74 1881.10 "Анатолий Кулаков" В общем, вот такие нововведения.
1881.10 1883.46 "Анатолий Кулаков" Вроде немало хороших нововведений.
1883.46 1887.78 "Анатолий Кулаков" Опять же, там performance подкрутили, кучу еще мелочей ввели, баги пофиксили, в общем, это все мелочи.
1887.78 1890.66 "Анатолий Кулаков" Но из крупных мазков вот где-то вот так.
1890.66 1894.62 "Игорь Лабутин" Ну и новые баги, наверное, добавили, да ведь?
1894.62 1895.62 "Анатолий Кулаков" Ну куда ж без этого?
1895.62 1899.54 "Анатолий Кулаков" Ну об этом мы узнаем, наверное, только в каком-нибудь первом патче или, может, уже в девятом в дотнете.
1899.54 1903.22 "Игорь Лабутин" В девятке наверняка будет что-нибудь, а может, как раз в релиз кандидате втором будет.
1903.22 1904.70 "Игорь Лабутин" Топофикшн, это пофикшн.
1904.70 1916.02 "Игорь Лабутин" Хорошо, System.json — это прекрасно, но мы вернемся немножко назад опять, в прошлый выпуск, где мы говорили про зеленые треды.
1916.02 1927.46 "Игорь Лабутин" Green threads — это возможность делать синхронную, асинхронную параллельную работу без необходимости влезать в детали самому разработчику.
1927.46 1931.46 "Анатолий Кулаков" И Microsoft… Наконец-то передумали и решили сделать.
1931.46 1941.30 "Игорь Лабутин" Нет, на GitHub опубликовали более техническую выжимку того, что они делали, почему не получилось, какие выводы они сделали, что пробовали.
1941.30 1949.78 "Игорь Лабутин" Статья, ну это не статья, это точнее вики, маркдаун документ, который находится в репозитории Runtime Lab.
1949.78 1950.78 "Игорь Лабутин" Ссылочка у нас…
1950.78 1951.98 "Анатолий Кулаков" Погоди, а чем это отличается от статьи?
1951.98 1955.94 "Игорь Лабутин" Ну что, ты придираешься к формату? Ну ладно, ладно, статья, хорошо.
1955.94 1962.38 "Анатолий Кулаков" Многие блоги введут в вики GitHub, и даже выше GitHub ведут блоги, и нормуль читают люди.
1962.38 1972.18 "Игорь Лабутин" Хорошо, ладно, пусть будет статья в блоге, называемом Runtime Lab Blog Feature Green Threads Docs Design Features Green Threads.md.
1972.18 1976.22 "Анатолий Кулаков" Неплохо, вот тут надо нам поучиться, слушай, какое хорошее название.
1976.22 1977.22 "Игорь Лабутин" Да.
1977.22 1978.22 "Игорь Лабутин" Солидно.
1978.22 1994.86 "Игорь Лабутин" Короче, в Runtime Lab, это такой репозиторий в организации .NET, где идут всякие разные эксперименты над рантаймом, там есть разное количество… там в… если посмотреть в корне, в мастер-бранче, ну или мейн, как он там у них называется, там есть документы, где описаны всяческие разные эксперименты и их статус.
1994.86 2008.62 "Игорь Лабутин" Где-то они завершены, где-то они идут, и каждый эксперимент живет в своей ветке, вот, соответственно, для green threads есть своя ветка, можно там посмотреть, что было сделано, и вот ту самую статью, про которую мы сегодня говорим, про то, что же было сделано.
2008.62 2040.94 "Игорь Лабутин" Итак, значит, давайте еще раз пробежимся, вспомним, во-первых, что такое green threads, зеленые threads, так называемые, это в каком-то смысле альтернатива обычным thread'ам в операционке, и почему они зеленые, потому что нету разницы… функции, короче, теряют свой цвет, да, перестает быть важно, а синхронно или асинхронно у вас функция, они все выполняются на вид, точнее, код пишется так, что они выполняются на вид синхронно, а они сами по себе внутри думают, нужна им асинхронность или не нужна.
2040.94 2064.78 "Игорь Лабутин" И цели того, чтобы проверить вот эти гипотезы про green threads были такие, во-первых, надо было понять вообще, какие у нас есть ограничения, и что нам придется трогать в рантайме, если мы хотим это реализовать, во-вторых, что нам придется трогать в BCL, в Base Class Library и в потенциальном коде заказчика, то есть в наших обычных программах, ну и померить производительность.
2064.78 2082.86 "Игорь Лабутин" Причем, когда мы говорим померить производительность, не было цели прям сравнить с async/await, была цель понять абсолютную производительность и понять, насколько мы в принципе можем это сделать как вообще фичу, или не можем, и производительность будет просто плохая.
2082.86 2087.26 None Там получилось в итоге сравнение с async/await, но это такой побочный результат, он не был основным.
2087.26 2098.42 "Игорь Лабутин" Во-первых, какие более-менее ограничения они себе поставили и пытались им следовать.
2098.42 2121.90 "Игорь Лабутин" Во-первых, как можно меньше менять API, то есть на верхнем уровне, то, что видит пользователь, поменялось буквально 3 API, то есть у thread добавился пропертиарь, что он зеленый или не зеленый, у task появился метод runAsGreenThread, как дополнение к run, ну и task.wait пришлось немножко подхачить, чтобы он правильно вел себя на green thread.
2121.90 2129.14 "Игорь Лабутин" На самом деле, насколько я понимаю, его именно public API не поменялся, поменялись внутренние реализации, серьезно.
2129.14 2138.42 "Игорь Лабутин" С высокоуровневой API тоже пришлось менять, но не в смысле их сигнатуры, а в смысле внутреннего поведения.
2138.42 2148.90 "Игорь Лабутин" То есть все API, которые работают с сокетами и с файлами, пришлось их менять, причем пришлось менять довольно интересный момент.
2148.90 2168.14 "Игорь Лабутин" У нас, ну как вы знаете, в дотнете мы сейчас говорим, что надо везде использовать async, если у вас синхронные, это прям не очень здорово, используйте async/await, а синхронные очень часто делаются через asynchron, с помощью всяких разных странных паттернов, это называется sync over async, и это посчитается не очень хорошим паттерном.
2168.14 2176.86 "Игорь Лабутин" А на green thread нужно как раз наоборот, даже если у вас есть асинхронный метод, его нужно вызывать как бы синхронно, и пусть сам runtime разбирается.
2176.86 2184.62 "Игорь Лабутин" Пришлось немножко над сокетными и файловыми API-ками поколдовать для этого, ну и kestrel там подхачить, чтобы он тоже правильно с этим всем работал.
2184.62 2220.38 "Игорь Лабутин" Выяснилось, что некоторые фичи дотнета весьма проблематичны с точки зрения дружбы с green thread, а именно, во-первых, есть так называемые by-reference параметры, когда вы передаете параметры через reference, потому что там обычно reference, в большинстве своем reference будут идти на stack, а поскольку у нас stack свой собственный, то там возникают вопросы, что с ним делать, и особенно если эти параметры дальше куда-то передаются, например, в какой-нибудь нативный код, потому что нативный код ожидает идти указатели на свой нативный stack.
2220.38 2229.14 "Игорь Лабутин" Непонятно, ну всякие function pointer не очень хорошо работают, тоже надо с ним что-то хачить, painwalk, смотри, опять же, работа с нативом.
2229.14 2264.38 "Игорь Лабутин" Выяснилось, что некоторые security фичи операционки не совсем дружат, потому что есть всякие странные, ну они не странные, они понятные, мы, кстати, про них даже говорили, я помню, в каком-то из выпусков, и есть такая штука, называется shadow stack, то есть она предназначена для того, чтобы следить за переполнением буфера и всякими такими атаками, чтобы вы через какие-нибудь атаки не сделали так, что на стеке у вас появится какая-то фигня, у вас операционка, она на самом деле, грубо говоря, как я понял, эту фичу держит в некоторую копию стека и там периодически сверяет, что они плюс-минус одинаковые.
2264.38 2281.14 "Игорь Лабутин" Не вдавался в детали, как это работает, но понятно, что если мы заменяем нативную реализацию стека на свою, а в игре на трейдах это нужно сделать, то поскольку он может прыгать между разными потоками, поэтому стек вызова должен быть свой собственный, то всякие такие security фичи идут непонятно куда.
2281.14 2293.26 "Игорь Лабутин" Также на винде, по крайней мере, операционка может внезапно, практически в любом месте, начать выполнять свой собственный код на юзерском потоке, например, в результате какого-нибудь исключения.
2293.26 2302.78 "Игорь Лабутин" То есть если мы не смогли доступиться к какому-нибудь кусочку памяти, вырабатывается исключение, которое, возможно, подгрузит этот кусочек, например, с диска.
2302.78 2308.94 "Игорь Лабутин" И этот код, он тоже где-то должен исполняться, и он как раз на том самом потоке, где мы сейчас и исполняемся.
2308.94 2312.18 "Игорь Лабутин" А с грейнтером непонятно где это будет.
2312.18 2316.14 "Игорь Лабутин" Текущий паттерн, async/await, тоже не идеально совместим.
2316.14 2320.98 "Игорь Лабутин" И штука, которая очень много используется внутри BCL, это thread static.
2320.98 2339.98 "Игорь Лабутин" То есть довольно много используется для оптимизации, то есть, например, известная техника, что string builder - штука дорогая, плюс он кеширует внутри массивы, поэтому когда мы объявляем string builder, помечаем его thread static, в итоге каждый thread использует свою копию, по сути, string builder.
2339.98 2345.18 "Игорь Лабутин" В большинстве случаев нам не нужно прерываться между string builder и в каком-нибудь async/await.
2345.18 2348.78 "Игорь Лабутин" То есть у нас есть набор строчек, мы из них как-то синхронно все собираем.
2348.78 2356.18 "Игорь Лабутин" Поэтому thread static вариант здесь как раз работает нормально, никто не сможет перехватить нас в серединке и записать тот же самый string builder.
2356.18 2373.26 "Игорь Лабутин" Так вот это все работать будет, ну, не будет, если оставить старый thread static, а если делать их на грейнтередах, чтобы они были с thread static на грейнтередах, там свои трудности, потому что грейнтередов может быть миллионы, и как все это хранить тоже непонятно.
2373.26 2383.22 "Игорь Лабутин" Когда начали реализовывать, выяснилось, что тоже не все хорошо, потому что команда честно написала, что у нас инженеры больше знакомы с виндой, поэтому мы делаем первую реализацию для винды.
2383.22 2420.26 "Игорь Лабутин" И выяснилось, что винда как операционнонка не очень готова к грейнтередам, смотри, вот выше там всякие исключения, вот это все, очень плохо стали почему-то работать стандартные механизмы типа event tracing for windows и windbg, как только внутри приложения начинают появляться вот такие вот фейковые call stack'и и все такое прочее, видимо логика обхода stack'ов во всех этих тулах она довольно сильно ломается и не ожидает увидеть там каких-то странных вещей, а там они есть и все ломается.
2420.26 2436.74 "Игорь Лабутин" Плюс каждая комбинация операционки и архитектуры требовала написать некоторую свою собственную там сборку для поддержки грейнтередов на такой комбинации, это прям ну довольно тяжелая долга, поэтому делали только для винды для начала.
2436.74 2439.18 "Игорь Лабутин" Теперь немножко про детали, что собственно сделали.
2439.18 2477.78 "Игорь Лабутин" Сделали довольно хитрую штуку, работает следующим образом, во-первых, для того чтобы мы могли смело эти самые грейнтереды кидать между разными реальными потоками, то есть идея грейнтереда в чем, что мы как будто бы живем в треде и у нас линейный call stack, но на самом деле если у нас происходит некоторая асинхронная операция, там обращение к диску, обращение к сокету, еще куда-нибудь, то мы этот тред, грейнтеред, забираем с как бы исполняемого операционного потока, он там где-то лежит ждет, а потом когда возвращается результат, мы его как бы возвращаем на обычный поток и продолжаем исполнение.
2477.78 2493.98 "Игорь Лабутин" При этом call stack виртуальный, он должен быть все тем же линейным, поэтому сделали так называемый сегментированный stack, ну в некотором смысле связанный список кусочков, там примерно по 12 килобайт каждый, как только соответственно место заканчивается, нужно лоцировать новый.
2493.98 2528.30 "Игорь Лабутин" Для того чтобы сделать возможность уходить и заходить обратно на stack с точки зрения когда мы прерываемся, пришлось делать некоторый патчинг адресов, и когда мы уходим в грейнтеред, то есть когда мы понимаем, что окей, сейчас начинается операция, которую можно выполнять на грейнтереде, мы на обычный нативный stack кидаем специальный фрейм, видимо на котором и ломались всякие виндабгы и прочее, который обозначает только тот факт, что вот тут начался грейнтеред.
2528.30 2543.86 "Игорь Лабутин" А потом, если нам нужно например вызвать какой-нибудь invoke, то мы в грейнтередовский stack кладем специальный фрейм, в котором написано, что мы пошли обратно в обычный нативный тред, ну и pointer соответственно туда.
2543.86 2550.62 "Игорь Лабутин" Все это, как я сказал, все эти сегменты слинкованы в linked list, и дальше возникает интересный момент.
2550.62 2578.10 "Игорь Лабутин" В обычной операционке, как если у вас просто выполняется ваше приложение, если вам вдруг не хватает стека, то есть вы аллоцируете, что этот стек закончился, это все обрабатывается на уровне операционки, то есть на самом деле, когда вам выделен стек, ну там сколько-то страничек предаллоцировано, а дальше есть так называемый guard page, то есть такая стражевая страничка, она находится сразу за концом стека выделенного.
2578.10 2590.22 "Игорь Лабутин" И если вы его трогаете, операционка понимает, что вы хотите писать следующую страничку, но ее нету, она в эту страничку выделяет вам память, а вот эту guard page перемещает дальше и работает автоматически.
2590.22 2624.62 "Игорь Лабутин" Но с greenthreads.dummy такого нельзя сделать, поэтому с greenthreads.dummy пришлось, если мы работаем с greenthreads.dummy, то runtime в момент jita в каждую managed функцию добавляют некоторый стандартизированный пролог, точнее у них это даже называется pre-prolog, поскольку мы знаем точно, сколько размер стека, какой нам нужен для managed функции, там все локальные перемены, все оно все известно, то мы можем заранее проверить, хватит ли нам места в нашем новом виртуальном стеке, если не хватит, то выделить.
2624.62 2632.06 "Игорь Лабутин" И получается, что в каждой managed функции у нас есть вот этот вот, там простой быстрый branch, но все же он есть в каждой функции.
2632.06 2633.06 "Игорь Лабутин" Дальше.
2633.06 2640.34 "Игорь Лабутин" Это технические трудности, технический, так сказать, момент, как это все было сделано.
2640.34 2645.98 "Игорь Лабутин" Как это влияет на модель программирования, того, что мы делаем в реальном коде.
2645.98 2649.86 "Игорь Лабутин" Значит, смотрите, получается следующая конструкция.
2649.86 2691.54 "Игорь Лабутин" Если мы вызываем синхронный какой-то вызов, и мы при этом находимся на greenthread, при этом этот синхронный вызов может привести к тому, что мы заблочимся, то нам нужно его вызвать на самом деле асинхронно, и поэтому во всякие синхронные методы, типа, например, socket.receive был добавлен код вида, если мы на greenthread, то создай valueTask вызове ресива sync, если получившийся valueTask он уже completed, то тогда сделай valueTask getAwaiterGetResult, иначе сделай valueTask.sTask и потом снова getAwaiterGetResult.
2691.54 2695.42 "Игорь Лабутин" Классический sync over sync вот этот вот подход, как дождаться таска синхронно.
2695.42 2711.94 "Игорь Лабутин" Всё бы хорошо, но у нас есть дофига API, которые используют спаны, а мы знаем, что спаны не дружат со синками, и соответственно, если у вас раньше такой синхронный вызов принимал спан, то вы его не сможете преобразовать в асинхронный.
2711.94 2720.90 "Игорь Лабутин" И что с этим делать, пока не очень понятно, либо надо какой-нибудь memory.tay использовать, который в heap можно сложить, либо ещё что-то, непонятно.
2720.90 2733.54 "Игорь Лабутин" Следующая проблема возникла, что если у вас есть синхронные API, и нам нужно его вызвать асинхронно, то сюрприз-сюрприз далеко не все синхронные API имеют своего асинхронного, так сказать, напарника.
2733.54 2740.94 "Игорь Лабутин" И есть обратная проблема, некоторые API только асинхронные, а в green3d хотелось бы их вызывать синхронно, иногда.
2740.94 2746.34 "Игорь Лабутин" И что делать, добавлять синхронную опцию, ну как бы в асинхронный вариант для всех тоже не здорово.
2746.34 2759.62 "Игорь Лабутин" Короче, вот из-за того, что у нас есть вот этот async await, из-за того, что у нас есть спаны, которые не дружат с async await, живут только на стейке, как это всё дружить с green3d было не очень понятно.
2759.62 2764.22 "Игорь Лабутин" Ну как-то подружили в минимальном варианте, чтобы всё это хоть как-то запустить в SPNet.
2764.22 2779.18 "Игорь Лабутин" Получили некоторые метрики, там в статье побольше всяких разных чисел, но выяснилось, что создание green3d это 3 микросекунды, а переиспользование green3d это 600 наносекунд, то есть это типа там 4 раза, в 5 даже раз быстрее.
2779.18 2786.58 "Игорь Лабутин" Отсюда был сделан вывод, что green3d хоть и дешёвый в создании, но пул green3d тоже неплохая штука, может быть надо писать green3d_pull.
2786.58 2787.58 "Игорь Лабутин" Ну не стали делать.
2787.58 2809.22 "Игорь Лабутин" В итоге, по-моему, мы приводили эти числа в прошлой статье, в прошлом выпуске, что на SPNet на green3d-ах показалось 160, возможность обработки 162 тысяч реквестов, в то время как на обычном async await, ну так классический, он обрабатывает 178, то есть помедленнее, но не сильно, несмотря на все сложности и проблемы там со спанами и всем остальным.
2809.22 2827.02 "Игорь Лабутин" То есть перспективы есть, перспективы, видимо, неплохие, но в статье также написана очень хорошая секция, называется "А куда мы не копали?" То есть мы типа копнули чуть-чуть, мы что-то проверили, но на самом деле осталось ещё огромное количество вещей, которые мы не посмотрели.
2827.02 2836.10 "Игорь Лабутин" Во-первых, мы не особо смотрели на то, что будет нужно менять в коде пользователей, то есть и вообще как пользователи на это всё смотрят.
2836.10 2843.90 "Игорь Лабутин" Во-вторых, мы не смотрели на Linux вообще, надо бы написать какой-нибудь прототипчик на Linux и только тогда дальше что-то делать.
2843.90 2845.26 "Игорь Лабутин" Побольше по бенчмаркете.
2845.26 2861.70 "Игорь Лабутин" Эксепшены не все и не везде нормально поддержаны, то есть там опять же эксепшены, они связаны с раскруткой стека, раскрутка стека это частично завязано на операционку, если green3d там не очень поддержаны, непонятно что с этим делать.
2861.70 2872.34 "Игорь Лабутин" Местами для более качественной поддержки green3d-ов неплохо бы сходить в команду винды и попросить поменять kernel API, что как бы нифига не простой процесс для винды.
2872.34 2874.90 "Анатолий Кулаков" Ну звучит довольно мощно и перспективно, скажешь.
2874.90 2878.46 "Анатолий Кулаков" Когда у тебя прям под язык подстраивается операционная система, это всегда прекрасно.
2878.46 2886.14 "Игорь Лабутин" Ну не под язык, под концепцию, то есть какая-то концепция файберов вот этого всего в винде всегда была, но она какая-то не такая и не подходит под green3d.
2886.14 2890.46 "Игорь Лабутин" Поэтому давайте мы под дотнет подстроим винду, ну чего нет.
2890.46 2914.02 "Игорь Лабутин" Дальше они говорят, что слетенсис, мы конечно мерили performance, но мы его не мерили не статистически значимо, то есть мы не мерили всякие там p95, p99, персонтили, вот это все, потому что все очень нестабильно, типа один запуск в одно, другой запуск в другое, и может быть те самые 162 тысячи это какой-нибудь там средний, не знаю, медиан, максимум из того, что они смогли выжить, мы не знаем.
2914.02 2927.86 "Игорь Лабутин" И подумать может быть как-то по-другому хендлить стеки вот из этот linked list, потому что этот препролог, который нужно добавлять в каждый менеджер функцию, он вообще говоря на performance скорее всего сильно влияет.
2927.86 2950.94 "Игорь Лабутин" И итоговые выводы всей этой конструкции заключаются в следующем, что в целом это возможно, получающаяся модель программирования она вполне себе удобна прямолинейно, но с другой стороны с учетом всего того, что уже имеется в рантайме, получается некая дополнительная сложность для разработчиков думать как бы о синхронном вейпе применить или на green3d перейти или че как, короче непонятно.
2950.94 2968.42 "Игорь Лабутин" А синхронный код в green3d имеет пока некоторые трудности с точки зрения нормальной производительности и тут некоторые конфликты в плане, что весь дотнет сейчас стремится быть асинхронным и кажется, что green3d, которые с этим конфликтуют как-то пока непонятно.
2968.42 2975.02 "Игорь Лабутин" Надо ли их либо как-то дружить, либо менять концепцию, в общем не очень здорово, не очень понятно что с этим делать.
2975.02 3010.18 "Игорь Лабутин" Не очень понятен импакт на обычный код обычных разработчиков, но и самое главное они вполне признают, что это не что-то что можно сделать на коленочке за один релиз, там типа остальные платформы, ну видимо имею ввиду в основном джава, много лет вообще занимались тем, что аккуратно допиливали платформу, выпускали превью, смотрели что там комьюнити думает, как это вообще работает на реальных продуктах, то есть технически это сделать можно, но работы прям очень много и кажется, что сейчас пока она не стоит того, чего мы можем получить и добиться.
3010.18 3022.38 "Игорь Лабутин" Так что вот такие дела, гриндредов видимо пока чего-то масштабного не случится в дотнете видимо не будет, будет у нас асинкавейт, все асинхронно и продолжим расставлять асинкавейт дальше по коду.
3022.38 3040.06 "Анатолий Кулаков" Слушай, меня все равно удивляет сама концепция, что мы не знаю 2 года от мою не можем добиться, чтобы он кнопочки хорошо перекрашивал, а тут ребята сели и ради фана написали гриндреды, так это что на нем даже кастрел запустился и даже какие-то бичмарки показал, что они довольно кислые.
3040.06 3069.74 "Игорь Лабутин" Это интересная мысль, ну это на разные команды, понятное дело, ну значит в команде рантайма есть такие ребята, ну плюс надо понимать, что команда рантайма драйвит там не знаю, какой-нибудь ажур, то есть если они допустим сделают эксперимент и покажут, что они могут ускорить ажур в 2 раза, ну давай не ускорить, а там либо ускорить, либо например сэкономить на железе ажур в 2 раза, потому что ту же нагрузку сможет вывозить у половины железа, то это же как бы сколько экономии денег или дополнительного заработка и всё такое, они молодцы.
3069.74 3077.54 "Игорь Лабутин" А малыш-то, ну как бы, новый способ писать UI-приложение, ну и чё, ажур с этого, туда же не пишут UI-приложение.
3077.54 3083.66 "Анатолий Кулаков" Ну какая-то слишком большая коммерциализация, как же там мир во всём мире, кроссплатформы, UI, что всем было хорошо.
3083.66 3090.70 "Игорь Лабутин" Ну это Майкрософт, ну какая коммерциализация, в смысле какая коммерциализация, прямая коммерциализация, никакого опенсурса.
3090.70 3105.70 "Анатолий Кулаков" Не, ну да, ладно, всё-таки ребята из лаборатории, из экспериментов, в общем они поражают, что действительно крутые такие киллер-фичи могут сделать просто на то, чтобы попробовать.
3105.70 3110.94 "Анатолий Кулаков" Хочется верить, что основные фичи у них делаются не хуже, а наверное даже лучше.
3110.94 3118.46 "Анатолий Кулаков" С таким же продуманностью, с тестами, с планами и с обзором всех технологий, которые вокруг происходят.
3118.46 3122.54 "Игорь Лабутин" Ну крупные фичи вроде как, да, хотя, ну как всегда находятся недовольные.
3122.54 3124.66 "Игорь Лабутин" Ну тут наверное всегда такое будет.
3124.66 3125.66 "Игорь Лабутин" Давай дальше пойдём.
3125.66 3137.02 "Анатолий Кулаков" Давай, раз у нас вот вечер ностальгии, что у нас там темы повторяются, я ещё хочу упомянуть про ту же тему, которую мы недавно затрагивали, это C# DevKit.
3137.02 3143.62 "Анатолий Кулаков" Мы затрагивали его тем, что он якобы появился, а здесь у нас как бы всё-таки официальная новость, он наконец-то зарелизился.
3143.62 3146.46 "Анатолий Кулаков" Или по-буржуйски General Availability.
3146.46 3155.62 "Анатолий Кулаков" В общем есть General Availability C# DevKit, и давайте же вспомним, что же это всё-таки такое.
3155.62 3166.66 "Анатолий Кулаков" Это специальный экстеншн для Visual Studio Code, который помогает вам добавить Editor First C# Development Experience, чтобы это не значило.
3166.66 3173.02 "Анатолий Кулаков" В общем, который помогает вам сделать из вашего Visual Studio Code полноценную C# IDE.
3173.02 3190.22 "Анатолий Кулаков" И в отличие от Microsoft Visual Studio, это C# IDE кроссплатформенная, потому что Visual Studio Code поддерживает Linux, Mac, Windows, и в данном случае ещё данный плагин поддерживает ту версию Visual Studio Code, которая запускается в Codespace.
3190.22 3192.86 "Анатолий Кулаков" То есть, по сути, из браузера это тоже можно делать.
3192.86 3196.54 "Анатолий Кулаков" Что же это такое?
3196.54 3203.58 "Анатолий Кулаков" Во-первых, это плагин для Visual Studio Code, как я уже сказал, он закрытый, то есть исходников его нет.
3203.58 3207.94 "Анатолий Кулаков" Он помогает улучшить продуктивность вашей работы в шарпах.
3207.94 3218.06 "Анатолий Кулаков" Он поддерживает ещё пока не в бете, но всё же Moyu и Unity, что для первой версии продукта довольно смело.
3218.06 3220.90 "Анатолий Кулаков" И он использует C# Language Service.
3220.90 3223.94 "Анатолий Кулаков" В общем, подробнее про C# Language Service.
3223.94 3236.02 "Анатолий Кулаков" Это специальный Language Service, также известный как LSP, для Visual Studio Code, который помогает принести мощь языка C# в Visual Studio Code.
3236.02 3245.38 "Анатолий Кулаков" То есть, Roslyn, Razer, подсветки, синтаксисы, интеллисенсы, вот это всё LSP для C# он уже делает.
3245.38 3258.70 "Анатолий Кулаков" Тут нужно отличать, что LSP для C# это open-source бесплатный плагин, который был уже давно, который тоже хорошо развивается, и поэтому он много всего умеет.
3258.70 3265.74 "Анатолий Кулаков" Например, он умеет запускать, соответственно, Roslyn для компиляции, для анализа, для интеллисенса.
3265.74 3268.62 "Анатолий Кулаков" Он умеет делать рефакторинги с помощью Roslyn.
3268.62 3274.78 "Анатолий Кулаков" У него есть навигация Roslyn, он умеет интеллисенсы делать, форматирование делать, линтеры делать.
3274.78 3281.02 "Анатолий Кулаков" То есть, нормальная, полноценная работа Roslyn, как мы его ожидаем во всех аспектах.
3281.02 3283.34 "Анатолий Кулаков" Что же делает новый плагин?
3283.34 3286.10 "Анатолий Кулаков" Вот это уже более такая тонкая материя.
3286.10 3292.50 "Анатолий Кулаков" Если мы бесплатно имеем всю мощь Roslyn с помощью C# LSP, то зачем же нам нужен C# DevKit?
3292.50 3296.38 "Анатолий Кулаков" А C# DevKit доворачивает то, чего вам не хватало.
3296.38 3298.70 "Анатолий Кулаков" То есть, делает полноценную Visual Studio.
3298.70 3307.30 "Анатолий Кулаков" Например, он добавляет Solution Explorer и, соответственно, всю систему проектов, файликов и всё, что с этим связано, там, референсов.
3307.30 3314.78 "Анатолий Кулаков" Вы, например, можете создать новый проект или, естественно, открыть существующий или создать новый из темплейта.
3314.78 3320.78 "Анатолий Кулаков" Как мы помним, там, темплейтов у стандартного .NET их много, как бы, и из CLI, и так далее.
3320.78 3324.82 "Анатолий Кулаков" Теперь вы это в Visual Studio Code можете красиво выбрать, красиво создать.
3324.82 3327.66 "Анатолий Кулаков" Также немаловажная фича – это Test Explorer.
3327.66 3333.54 "Анатолий Кулаков" Вы можете сканировать тесты в вашем проекте, то есть, discover-ить их, запускать и отлаживать.
3333.54 3338.78 "Анатолий Кулаков" Вот, это всё даёт только новый платный плагин, закрытый.
3338.78 3345.66 "Анатолий Кулаков" Также в нём включена Packet Management, то есть, вы можете работать с Nuget, восстанавливать пакетики и всё там с ним что-то делать.
3345.66 3347.46 "Анатолий Кулаков" И у него есть дебаггинг.
3347.46 3356.18 "Анатолий Кулаков" И также там декларируется какой-то IE Assistant, который там в IntelliSense вам вставляет какие-то умные подсказки в зависимости от того, насколько там часто оно используется.
3356.18 3358.14 "Анатолий Кулаков" Ну, на самом деле, пока оно не очень умное.
3358.14 3363.94 "Анатолий Кулаков" Но всё же, перспективы для IntelliSense, для расширения IntelliSense там довольно большие.
3363.94 3367.18 "Анатолий Кулаков" В общем, вот такая градация.
3367.18 3372.18 "Анатолий Кулаков" Если вы хотите какой-то базовый набор C#, Roslin, анализатор IntelliSense, это есть бесплатно.
3372.18 3373.54 "Анатолий Кулаков" Это всё уже давно работает.
3373.54 3380.78 "Анатолий Кулаков" Если вы хотите превратить его в полную Visual Studio с проектами, референсами, Nuget, дебагами, тестами, удобными тестами.
3380.78 3381.78 "Анатолий Кулаков" Это важно.
3381.78 3383.82 "Анатолий Кулаков" Удобный тест эксплойер - это всегда хорошо.
3383.82 3386.78 "Анатолий Кулаков" В общем, для этого вам уже нужен вот этот закрытый новый плагин.
3386.78 3391.26 "Анатолий Кулаков" Разберёмся с лицензированием.
3391.26 3394.74 "Анатолий Кулаков" Мы уже упоминали, что лицензия для него нужна от большой Visual Studio.
3394.74 3395.74 "Анатолий Кулаков" Что это значит?
3395.74 3404.06 "Анатолий Кулаков" Это значит, что этот плагин бесплатный для индивидуального использования или для академических кругов, или для open-source разработчиков.
3404.06 3407.42 "Анатолий Кулаков" То есть, все те же самые условия, что у Visual Studio Community.
3407.42 3409.98 "Анатолий Кулаков" В Visual Studio Community Edition такая же точная ситуация.
3409.98 3412.62 "Анатолий Кулаков" Можете использовать бесплатно в определенных этих сферах.
3412.62 3417.18 "Анатолий Кулаков" Если вы всё-таки организация, то там уже придётся раскошелиться.
3417.18 3420.86 "Анатолий Кулаков" Вам нужна подписка на Visual Studio Professional или Visual Studio Enterprise.
3420.86 3433.14 "Анатолий Кулаков" И всё бы интересно, но если мы уже сравниваем этот инструмент, эту IDE из Visual Studio Code, пусть да, к кроссплатформе, но и всё такое.
3433.14 3442.86 "Анатолий Кулаков" Но если мы сравниваем с другими конкурентами, а здесь, наверное, единственный конкурент - это Rider, то плагин для Visual Studio Code выходит дороже, чем Rider.
3442.86 3448.06 "Анатолий Кулаков" Но у Rider уже за плечами богатая история, куча плагинов, миллиарды настроек.
3448.06 3451.30 "Анатолий Кулаков" А у плагина от Visual Studio Code пока ничего.
3451.30 3453.78 "Анатолий Кулаков" Первый релиз на тебе состоялся.
3453.78 3456.78 "Анатолий Кулаков" Вот такая какая-то неровная схватка идёт.
3456.78 3458.78 "Анатолий Кулаков" Ну, посмотрим.
3458.78 3461.18 "Анатолий Кулаков" Я поставил, попробовал.
3461.18 3465.78 "Анатолий Кулаков" В принципе, первые три раза оно у меня крашилось на существующих проектах, но потом заработало.
3465.78 3468.34 "Анатолий Кулаков" И, к моему удивлению, заработало очень хорошо.
3468.34 3470.06 "Анатолий Кулаков" В принципе, скорость поражает.
3470.06 3478.14 "Анатолий Кулаков" То есть, можно было перейти на дефинишн методов, отыскать юсиджи, вернуться обратно, запустить тесты.
3478.14 3486.10 "Анатолий Кулаков" В общем, удобство и скорость работы, и скорость подсветки, и скорость интеллисенса на высоте.
3486.10 3495.82 "Анатолий Кулаков" Поэтому, как кроссплатформенная Toolzane, которая, в принципе, неплохой IDE, там можно и дебажить, и допускать тесты, и всё в этом духе.
3495.82 3498.26 "Анатолий Кулаков" Это очень хорошая альтернатива.
3498.26 3501.50 "Анатолий Кулаков" Притом надо учитывать, что Rider бесплатного нет.
3501.50 3506.14 "Анатолий Кулаков" У него бесплатной версии нет, у него надо только покупать, или какой-нибудь райл-период, или что-то в этом духе.
3506.14 3512.74 "Анатолий Кулаков" А для индивидуальной работы, в принципе, кроссплатформенной IDE, это безальтернативный плагин получается.
3512.74 3516.82 "Анатолий Кулаков" То есть, он рвёт пока всё, что было до него как стоячих.
3516.82 3522.30 "Анатолий Кулаков" Наверное, видится, да, какая-то неплохая альтернатива той Visual Studio for Mac, которую закрыли.
3522.30 3528.06 "Анатолий Кулаков" Правда, скорее всего, в той Visual Studio for Mac были какие-то специфики именно для Mac.
3528.06 3530.94 "Анатолий Кулаков" Вот здесь это пока не прослеживается, но, скорее всего, добавят.
3530.94 3538.34 "Анатолий Кулаков" Потому что площадка для будущих наворотов, для будущего развития очень хорошая.
3538.34 3539.86 "Анатолий Кулаков" Ну и задатки у него прекрасны.
3539.86 3545.86 "Игорь Лабутин" Ну это же Visual Studio Code, ещё 10 плагинов допишут, и будет у тебя полноценная Visual Studio.
3545.86 3546.86 "Анатолий Кулаков" Ну именно так, да.
3546.86 3552.46 "Анатолий Кулаков" Притом они пишут круглосуточно и огромным количеством человек.
3552.46 3553.46 "Анатолий Кулаков" Поэтому допишут.
3553.46 3564.26 "Анатолий Кулаков" Если, видишь, сразу же задекларировали и поддержку Unity, и поддержку мою я, то уж какую-то жалкую поддержку MacOS, тем более, допилят.
3564.26 3567.06 "Игорь Лабутин" Ну там свои трудности, но наверняка допилят.
3567.06 3571.02 "Игорь Лабутин" Может, даже уже есть, просто мы особо так не разрабатываем, поэтому не следим.
3571.02 3572.02 "Игорь Лабутин" Давай дальше.
3572.02 3577.94 "Игорь Лабутин" Дальше у нас статьи от любимого нашего Andrew Locke, которого мы довольно давно, мне кажется, не смотрели.
3577.94 3580.14 "Игорь Лабутин" Наверное, пару выпусков его у нас не было.
3580.14 3587.38 "Игорь Лабутин" Ну вот он вернулся, и он вернулся с довольно нестандартной для себя статьёй, я бы сказал.
3587.38 3592.34 "Игорь Лабутин" Это всё про новые .NET 8 Identity API Endpoints.
3592.34 3600.38 "Игорь Лабутин" Давайте для начала вспомним, что это такое, зачем это надо, а потом поговорим про то, что об этом всём думает Энди.
3600.38 3609.50 "Игорь Лабутин" Значит так, у нас всегда можно было в ISP.NET Core добавить аутентификацию и авторизацию.
3609.50 3611.62 "Игорь Лабутин" У нас всегда была такая опция, можно было сказать.
3611.62 3614.38 "Игорь Лабутин" Это называется ISP.NET Core Identity Framework.
3614.38 3624.50 "Игорь Лабутин" Он в каком-то смысле многослойный, то есть у него есть некоторый слой моделей, это классы типа Identity User, Identity Role.
3624.50 3639.62 "Игорь Лабутин" У него есть класс, слой хранения, это различные stores, которые сохраняют данные о пользователях, о ролях, о чём-то, о куких и всём остальном, что там выдается или настраивается.
3639.62 3654.54 "Игорь Лабутин" Ну и комплект, то что они называют менеджеры, это всякий слой сервисов, грубо говоря, которые ответственны за то, чтобы обрабатывать события логина, логаута и прочих таких вещей.
3654.54 3685.94 "Игорь Лабутин" Поверх этого всего добавлялся, можно было добавить UI на Razor пейджах, который как раз добавлял вам в приложение набор просто страничек, через которые можно было логиниться, логаутиться, задавать какие-то данные пользователя, конфирмить email, делать двухфакторную идентификацию, ну в общем, много-много-много всего делал, работал это всё на куках, но было в Razor UI.
3685.94 3687.70 "Игорь Лабутин" Что добавили сейчас?
3687.70 3710.90 "Игорь Лабутин" Сейчас добавили новый набор endpoints, который добавляется довольно легко, и можно это сделать в одну строчку, вы пишете app.mapgroup, чтобы у них у всех был общий префикс, /account например, и потом map.identity.api, и передаете туда класс вашего юзера, который скорее всего должен быть унаследован от identity юзера.
3710.90 3712.74 "Игорь Лабутин" И всё.
3712.74 3729.90 "Игорь Лабутин" Вы автоматически получаете набор endpoints для регистрации пользователя, для логина, для мультифакторной идентификации, для конфирмейшена email, какой-то там account.info можно получить минимальный, ну и ещё там по-моему всего порядка 12 или 15 методов около того.
3729.90 3733.50 "Игорь Лабутин" Какую проблему пытался решить Microsoft таким образом?
3733.50 3737.70 "Игорь Лабутин" То есть зачем нам вообще этот самый map.identity.api?
3737.70 3751.82 "Игорь Лабутин" По большому счёту, проблему, которую пытался решить, кажется, состояло в том, что этот самый старый слой того, что нужно было делать для того, чтобы делать логин и так далее на базе S/4HeadCore был основан на Razor.
3751.82 3782.42 "Игорь Лабутин" А сейчас в современном стеке всё-таки в основном frontend пишется на каком-нибудь там JavaScript, Blazor, если это C#, и вставлять именно в ваше красивое фронтендное приложение какой-то не очень так стилизованный Razor кусочек, или даже его стилизовать под ваше приложение, всё равно как бы частично получается server-side приложение, частично SPA приложение, что-то в общем-то странное, поэтому в итоге решили сделать API для этого.
3782.42 3786.42 "Игорь Лабутин" А дальше пишите свой фронтенд как хотите.
3786.42 3792.02 "Игорь Лабутин" По сути попроще стало добавлять всю эту функциональность identity в серверные приложения.
3792.02 3798.54 "Игорь Лабутин" Что вы могли сделать бы, если бы не было вот этих identity API?
3798.54 3801.26 "Игорь Лабутин" Ну не то, что могли, что народ делает.
3801.26 3808.70 "Игорь Лабутин" Во-первых, можно использовать дефолтные эти самые Razor UI, как-то его кастомизировать, и нормально, будет работать.
3808.70 3823.42 "Игорь Лабутин" Во-вторых, можно добавить полноценную поддержку OAuth OpenID Connect, и соответственно использовать какой-то сторонний провайдер, там Oktu, Google, Azure, как там он называется, они переименовывали недавно, Entra теперь это называется.
3823.42 3826.14 "Игорь Лабутин" Короче, куда-нибудь туда идти.
3826.14 3832.78 "Игорь Лабутин" Можно сделать свой собственный identity server и не использовать сторонний, а использовать в своем виде отдельного приложения.
3832.78 3839.38 "Игорь Лабутин" Тут подойдут библиотеки типа identity server, либо OpenID, либо еще какие есть.
3839.38 3848.10 "Игорь Лабутин" У всех этих трех способов довольно разные, есть свои сложности, и они все довольно разные.
3848.10 3852.02 "Игорь Лабутин" В некоторых случаях вам придется интегрироваться со сторонним сервисом.
3852.02 3857.30 "Игорь Лабутин" В некоторых случаях вам придется деплоить, собирать и вообще писать свое собственное приложение.
3857.30 3861.18 "Игорь Лабутин" Хоть там identity server много представляет, но своего какого-то кода написать придется.
3861.18 3869.02 "Игорь Лабутин" Вам в принципе нужно будет понимать, кто такой OpenID и кто Auth, а там черт ногу сломит.
3869.02 3878.82 "Игорь Лабутин" Ну либо вам придется иметь дело со старым UI, который как бы, ну не со старым UI, но UI на основе Razer, с которым тоже надо что-то делать.
3878.82 3888.50 "Игорь Лабутин" И опция, собственно, с Razer UI она самая простая, но UI, ладно, я уже много рассказал, что там UI, и которое надо кастомизировать.
3888.50 3890.06 "Игорь Лабутин" Но еще один момент, что там же cookie.
3890.06 3901.70 "Игорь Лабутин" А если вы почитаете все про микросервисы, у вас там будет из каждой статьи торчать уже, нам нужны JWT токены и вот это все.
3901.70 3907.38 "Игорь Лабутин" И короче, как же мы будем жить без токенов cookie прошлый век и все такое прочее.
3907.38 3916.06 "Игорь Лабутин" Поэтому новые API, которые были добавлены, во-первых, они выставляют наружу некоторый минимальный набор того, что можно делать с пользователями.
3916.06 3918.14 "Игорь Лабутин" Ну там регистрация, вот это все.
3918.14 3922.38 "Игорь Лабутин" И добавляют endpoint, по которому можно получить наконец-таки токен.
3922.38 3925.38 "Игорь Лабутин" Теперь не только cookie, но теперь и токен.
3925.38 3934.82 "Игорь Лабутин" И к середине статьи Энди говорит, ну блин, Эндрю, лог говорит, блин, короче, классные вообще API, кажется, что это то, что нам нужно.
3934.82 3938.54 "Игорь Лабутин" И следующий заголовок гласит, почему их не надо использовать.
3938.54 3942.02 "Игорь Лабутин" Microsoft старались, добавляли, но вообще-то их использовать не надо.
3942.02 3949.74 "Игорь Лабутин" И по его мнению есть 5 проблем с ними, 2 из них концептуальных и 3 таких более технических, которые вообще говоря можно решить.
3949.74 3976.82 "Игорь Лабутин" И первая концептуальная проблема это то, что токены токенами, но кажется, что в современном мире все опять потихонечку как-то идут обратно к cookies, причем в формате, что мы используем cookie для того, чтобы авторизоваться и общаться с back-end, front-end компонентой, а вот она уже получает токены со всеми клеймами, всем добром и использует дальше токены, рассылая их внутри системы.
3976.82 3987.90 "Игорь Лабутин" Типа это вот сейчас по его мнению больше становится в тренде, поэтому Microsoft, который добавил API для выдавания токенов, ну как-то может быть идет не туда.
3987.90 3999.14 "Игорь Лабутин" Второе это то, что использование этих самых API ведет сразу к ну давайте назовем это негибкой архитектуре.
3999.14 4011.86 "Игорь Лабутин" То есть если у вас какой-то pet-проект, где у вас полтора пользователя, конечно вы сделаете, ну и демо для конференции в таком духе, для метапа, то вы конечно просто добавите идентики и все.
4011.86 4026.02 "Игорь Лабутин" В реальной жизни у вас есть всякие там single sign-on, все такое прочее, то есть в реальной жизни вы пользуетесь способом, когда у вас есть некоторая сторонняя штука, которая за вас хранит пользователей, регистрирует их, а вы только авторизуете через нее.
4026.02 4031.14 "Игорь Лабутин" А здесь вроде как API этого не то чтобы не позволяют, но смотри чуть ниже.
4031.14 4033.98 "Игорь Лабутин" В этих API многого не хватает.
4033.98 4039.86 "Игорь Лабутин" Ну во-первых, нам нужно будет писать собственный UI, но ладно, вроде это была одна из целей.
4039.86 4056.86 "Игорь Лабутин" Во-вторых, вы не можете, например, посмотреть данные для конкретного пользователя, удалить конкретного пользователя, вы не сможете сделать внешних логинов, вы не сможете генерировать какие-то там recovery кодов для multi-factor авторизации, это все придется делать самому.
4056.86 4077.74 "Игорь Лабутин" Ну допустим вам все эти endpoints не нужны дополнительные, но например вы не хотите, чтобы пользователи регистрировались, потому что вы, например, делаете все-таки какой-нибудь там логин через сторонний сервис, у вас есть уже сторонняя база пользователей, никакой регистрации через ваше приложение происходить не должно.
4077.74 4082.30 "Игорь Лабутин" Так вот нет возможности убрать эти самые endpoints, которые были добавлены.
4082.30 4095.66 "Игорь Лабутин" Ну технически вы можете зарегать middlevark перед ними и сказать, что на такой-то маршрут нужно всегда возвращать там 404, не найдено, и тогда может быть это как-то поможет, но это какой-то очень кривой способ.
4095.66 4096.98 "Игорь Лабутин" Короче, убрать endpoints нельзя.
4096.98 4102.82 "Игорь Лабутин" И последний пятый момент, вы никак не можете их кастомизировать.
4102.82 4122.74 "Игорь Лабутин" Если в случае с Razer вы не подключали там Nougat какой-нибудь, вы на самом деле использовали так называемый scaffolding, то есть просто генерацию того, чего вам нужно добавить в проект, это все добавлялось к вам в проект и лежало в вашем проекте, вы могли кастомизировать, удалять, добавлять все, что вы хотите.
4122.74 4133.46 "Игорь Лабутин" В случае с этими endpoints это не так, вы тащите middlevark из Nougat пакета, ну или из Base Class Library по сути, и вы не можете особо там ничего кастомизировать.
4133.46 4136.42 "Игорь Лабутин" Не то чтобы вам это было часто нужно, но бывает надо.
4136.42 4142.62 "Игорь Лабутин" Какие-нибудь клеймы добавить при регистрации, еще какую-нибудь такую штуку сделать, вот этого невозможно сейчас сделать.
4142.62 4167.22 "Игорь Лабутин" Поэтому фактически получается, что вот эти проблемы с тем, что они не кастомизируемые, что там ничего нельзя убрать, много чего не хватает, их в принципе можно менять в допустим 9.NET, добавлять, дополнять, как-то расширять, но общий архитектурный вопрос все еще остается и непонятно насколько на самом деле эти методы вообще говоря обретут какую-то популярность, посмотрим.
4167.22 4185.86 "Игорь Лабутин" И во второй статье, сразу вышедшей после первой, Эндрю задается вопросом, ну хорошо, вот у нас есть теперь новые Identity APIs, а еще у нас есть Identity Server, ну или OpenDig, тот который мы знаем, наверняка же возникнет мысль их как-то подружить в одной приложении.
4185.86 4190.78 "Игорь Лабутин" Они же оба про идентификацию, авторизацию, идентификацию, почему нет?
4190.78 4209.86 "Игорь Лабутин" И тут надо понимать, что Identity Server дает вам фичи типа выдавать токены приложениям либо пользователям, куда-то делегировать аутентификацию на сторонние сервисы, он может верифицировать токены, он может в динамике, допустим, регистрировать новых клиентов, то есть новые приложения.
4209.86 4231.94 "Игорь Лабутин" И Identity Server в среднем работает в предположении, что пользователь аутентифицирован, то есть если пользователь аутентифицирован, то в мидловаре Identity Server позволяет сходить к еще некоторому количеству endpoints, типа там выдать токен, авторизоваться, discovery какой-то дополнительной работать и так далее.
4231.94 4253.14 "Игорь Лабутин" И кажется, что если подружить Identity Server с API, то будет не очень, потому что API умеют выдавать токены, но они выдают так называемые OPAC токены, то есть те, которые ну как-то прозрачные, да, то есть это не JVT токены, это по сути те же cookie, просто запакованные в виде токена.
4253.14 4263.06 "Игорь Лабутин" А Identity вроде как работает с JVT и будет, не будет, проблема, не проблема, в общем, как-то это все непонятно.
4263.06 4277.18 "Игорь Лабутин" И можно их в принципе подружить, пишет Андрю, давайте мы не будем использовать токены из API endpoints теперь, хотя ради этого они и добавлялись, будем использовать cookies, там есть флажок, который говорит, давай использовать cookies все равно.
4277.18 4300.90 "Игорь Лабутин" И тогда Identity Server будет более-менее окей, все будет нормально, но смотрим выше, у вас нет возможности отключить endpoints, поэтому, например, если у вас есть Identity Server и вы хотите регистрировать пользователей через него, то endpoint register от Identity API все еще будет торчать наружу, все равно, и вы его не можете никак отключить.
4300.90 4329.34 "Игорь Лабутин" Андрю попробовал все это совместить в одном продукте, в одном приложении, он добавил Identity Server, шаблончик для Identity Server позволяет добавить некоторое количество страничек для логина и регистра, все эти странички были удалены, добавили мидлварьки API endpoints, дописали logout endpoint руками и дальше он начал дергать эти самые endpoints, ну просто использовав условные лизы консоли и браузера, чтобы понять как это будет работать совместно.
4329.34 4392.42 "Игорь Лабутин" В целом, татификация вроде плюс-минус заработала, то есть можно залогиниться и даже посмотреть на токены, ну в смысле на клеймы, что там внутри находится, все замечательно работает, а вот дальше возникает такая проблема, если вы, например, разлогинились и в обычном приложении, как раньше это было, пойдете куда-нибудь на какую-нибудь страничку, где вам нужно быть залогиненным, то там срабатывает автоматический редирект на страничку логина, выглядит все это красиво и здорово, а вот в версии с identity API, API вам никакого редиректа не вернет, API аккуратно возвращает 401, 403 и как сделать, то есть вам нужно либо в вашем SPA писать, в этом случае переход на логин, либо приседать и упражняться со штуками называемыми authentication schemas и handlers в самом SPA на сайте, чтобы сделать автоматический редирект, возврат какого-нибудь редиректа на страничку логина прямо из медиалвальки.
4392.42 4437.98 "Игорь Лабутин" Короче писать придется много, зачем это дружить непонятно, скорее всего найдутся те, кто это будут пытаться делать, не очень может быть понимая всю сложность всей этой идеологии идентитизиров, в identity API все это очень похожее название, делаются разные вещи, скорее всего вам потребуется писать очень много кода, поэтому 20 раз подумайте, надо ли оно вам, нужно ли вам затаскивать identity API в ваш продукт, подумайте как вы будете его использовать, как вы будете его развивать и вообще зачем он вам нужен, потому что пока не очень понятны его юзкейсы, кроме каких-то очень простых приложений, в которых вы хотите, простых приложений с single-page application frontend, в котором вам не лень написать собственный UI для логина, кажется это какая-то очень узкая ниша.
4437.98 4533.14 "Анатолий Кулаков" Слушай, не знаю, я бы здесь поспорил, мне кажется что у Энди пошел, Эндрю, Эндрю, Эндрю пошел натягивать сову на глобус, ну то есть реально identity API были созданы не для этого, в общем если у вас identity сервер есть, то прекрасно, живите на identity сервере и это не ваш юзкейс, а вот тот как раз таки юзкейс, когда ты говоришь, что очень узкий, мне вот как раз таки кажется, что наоборот, это когда мы пытаемся городить там микросервисы на кубернетах и с тысячи как бы контейнеров, вот это довольно такой нишевый юзкейс, то есть только большие компании себе могут позволить, а если мы возьмем например обычные магазинчики, которые делаются, сайтики на коленке, которые делаются, то есть такий мелкий и средний сегмент, то там как раз таки тебе и будет одно большое приложение, которое для себя должно обеспечить вход пользователей, ну то есть какой-то элементарный логин для админов может быть или для пользователей, которые корзину наполняют, им нужны пользователи, им нужно как-то логиниться, им нужно что-то делать, и вот там эти идентики API прекрасно цветут и пахнут, и рынок у них будет намного, ну то есть не меньше точно, мне кажется, даже больше, чем вот этих корпоративных пузанов, и написать к ним отдельное UI-приложение тоже не составит труда, потому что раньше просто не было удобного кейса, то есть не было удобного API, а теперь после того, как API есть, у тебя практически там любая бабулька на фронт-энде будет клепать вот эти фронт-энды, и там через полгодика их будет сотни, ты просто выберешь, какой тебе больше нравится, а не подконнектиться к стандартному API, и оно сразу будет работать из коробки.
4533.14 4539.42 "Анатолий Кулаков" В общем, поэтому мне кажется, это довольно понятная прямая ниша, и смешивать их не надо, это две разные вещи.
4539.42 4569.46 "Игорь Лабутин" Ну, может быть, может быть, я согласен, что скорее всего появятся еще какие-нибудь пакеты дополнения, ну по принципу, что здесь вот не хватает действительно каких-то там GDPR, всяких нужных пунктов, типа как получить всю информацию, удалить информацию от пользователя сейчас невозможно, а в принципе это можно сделать стандартным endpoint, и я вполне вижу, что там Nuget пакет, который добавляет поверх стандартного API использующий стандартный storage, потому что вся нежелерящая инфраструктура S/4HANA Identity остается на месте.
4569.46 4572.78 "Игорь Лабутин" То есть storage, вот эти все модели данных.
4572.78 4577.26 "Анатолий Кулаков" Ну да, там тот же юзер-менеджер, который все это с юзером умеет делать, и удалять, и добавлять, и регистрировать.
4577.26 4583.46 "Игорь Лабутин" Да, да, да, это все остается, и написать в принципе простейший Nuget пакет, который экспозит это все как endpoint тоже можно.
4583.46 4597.10 "Игорь Лабутин" Возможно, Microsoft просто сейчас сделала, как так сказать, минимально необходимую версию, да, зарегистрироваться, залогиниться, и там получить инфу о юзере, чтобы посмотреть действительно, ну, как оно ложится, какой будет adoption и так далее, и потом добавят.
4597.10 4599.90 "Игорь Лабутин" Может быть, может быть, не знаю.
4599.90 4600.90 "Анатолий Кулаков" Да, вполне.
4600.90 4612.26 "Анатолий Кулаков" Ну, у Microsoft Identity, он же уже, даже не у Microsoft он был, а S/PNet Core Identity, он же давно есть как бы, с первых времен Core, и он никуда не девался, и у него такая же точно своя ниша.
4612.26 4615.82 "Анатолий Кулаков" А это чистая замена вот S/PNet Core Identity, ни больше,
4615.82 4633.18 "Игорь Лабутин" ни меньше. Ну, наверное, ну да, я, опять же, у меня взгляд немножко, так сказать, biased в каком-то смысле, потому что я ни разу не писал проектов, продуктов, и не работал с проектным продуктом, где был бы полноценный вот юзер менеджмент именно в чистом виде S/PNet Core Identity, да, с Razer вот этим всем.
4633.18 4636.34 "Игорь Лабутин" Вот вообще ни разу не видел в реальной жизни таких.
4636.34 4641.66 "Анатолий Кулаков" Ну, потому что есть доступ, наверное, к какому-нибудь контейнерам, облакам, к убернетам, к очень выпустям.
4641.66 4646.50 "Анатолий Кулаков" Ну, вот, для этого тебе ещё девопс-команда отдельная, потом психотерапевты, это девопс-команды.
4646.50 4651.10 "Игорь Лабутин" Ну, даже не отдельная, не, не, не, ну не отдельная, не надо, мы не всегда так.
4651.10 4655.10 "Игорь Лабутин" Дед, ну подожди, ты же сам рассказывал, что не должно быть отдельной девопс-команды.
4655.10 4659.02 "Игорь Лабутин" Вернее, должна быть, но она не про то.
4659.02 4666.70 "Анатолий Кулаков" Конечно не должно и не про то, опять же, но это же устоявшаяся индустрия, ты её просто так не сломаешь, и под индустрию как бы есть понятные стандарты.
4666.70 4676.86 "Анатолий Кулаков" Ну, в общем, я почему-то и говорил… Мне кажется, ниша есть, Microsoft понимает, куда она целится, и своего пользователя эти пиашки найдут.
4676.86 4680.38 "Анатолий Кулаков" То есть, мне кажется, не зря, не даром потребители у них будут.
4680.38 4690.46 "Игорь Лабутин" Ну вот, я поэтому и говорю, что это такая очень нестандартная статья для Эндрю, потому что обычно он как бы, ну, либо просто детально разбирает, либо как бы прямо говорит, о да, крутая фича.
4690.46 4694.82 "Игорь Лабутин" Это, по-моему, одна из немногих его статей, где он пишет, типа, блин, что-то как-то я не понимаю.
4694.82 4701.90 "Игорь Лабутин" То есть, может быть, он тоже как-то у него баяст мнение там, как консультанта, что он много видел именно больших корпоративных систем, не знаю.
4701.90 4709.54 "Игорь Лабутин" Ну, поглядим, будут выходить новости, будут выходить статьи про это дело, как только будет выходить, мы их будем, конечно, в подкасте обозревать.
4709.54 4714.86 "Игорь Лабутин" И таким образом, если вы будете внимательно наслушать в течение ближайших двух лет, наверное, вы тоже составите правильную картинку.
4714.86 4718.30 "Анатолий Кулаков" Да-да-да, наверняка.
4718.30 4723.94 "Анатолий Кулаков" Пойдём дальше, времени уже осталось немного, давай ещё одну статейку забросим.
4723.94 4730.54 "Анатолий Кулаков" Хочу вам рассказать про моки для того, чтобы тестировать ваш ISP.NET приложение.
4730.54 4736.26 "Анатолий Кулаков" В общем, давно просили у нас эту тему, я нашёл пару статей, и они меня, честно сказать, разочаровали.
4736.26 4740.42 "Анатолий Кулаков" В общем, но чтобы о чём-то поговорить, я думаю, нормуль, сойдут.
4740.42 4743.38 "Анатолий Кулаков" Если что, будем дальше в комментариях исправляться.
4743.38 4747.94 "Анатолий Кулаков" Итак, как же мы мокаем ISP.NET Core Server?
4747.94 4754.70 "Анатолий Кулаков" Ну, наверняка самым часто используемым приложением у нас в Дотнете является это ISP.NET Core сервера.
4754.70 4758.02 "Анатолий Кулаков" Да, десктопов сейчас всё меньше и меньше, а веб-серверов всё больше и больше.
4758.02 4762.50 "Анатолий Кулаков" Все хотят апишечку, все хотят джессончики обменивать и так далее.
4762.50 4766.06 "Анатолий Кулаков" Поэтому сервера у нас сейчас везде и всегда.
4766.06 4783.34 "Анатолий Кулаков" И на самом деле, тестирование вот такого сервера, такого большого интеграционного тестирования, то есть как он поднимается со всеми его роутами, форматами, валидаторами, сервизаторами, со всей той огромной инфраструктурой, которая себя поднимает, вот её протестировать в общем случае довольно сложно.
4783.34 4788.90 "Анатолий Кулаков" Но, к счастью, Microsoft об этом позаботилась, притом позаботилась довольно-таки давно.
4788.90 4794.26 "Анатолий Кулаков" И у нас давно на рынке есть прекрасный Nuget пакет, который поставляет нам Web Application Factory.
4794.26 4809.90 "Анатолий Кулаков" Это специальный классик, который был разработан Microsoft, который создает, который фейкой эмулирует тест-сервер, который позволяет нам запустить наше ISP.NET на самом деле довольно легковесно.
4809.90 4816.60 "Анатолий Кулаков" Главная его фишка, почему у него получается сделать легко и легковесно, в том, что он никак не затрагивает CP-Stack.
4816.60 4824.42 "Анатолий Кулаков" То есть он на самом деле не запускает кестрил, не бандит порты, не дисковерит адреса, вот эта вся часть у него выкинута.
4824.42 4838.86 "Анатолий Кулаков" Он на транспортном уровне просто подставляет HTTP-хендлер, который все запросы, которые клиенты бросают, роутит в тот же самый процесс, in-memory процесс, в локальный.
4838.86 4842.42 "Анатолий Кулаков" Именно поэтому данная штука работает легко, стабильно и безумно быстро.
4842.42 4865.86 "Анатолий Кулаков" И так как это делается все на максимально низком уровне, там на уровне именно там, где уже подключается сам кестрил, то весь остальной пайплайнинг, резолв контроллеров, резолв методов, серилизаторов, форматоров, аутентификации, авторизации, роутов, редиректов, короче, вся вот та бандура, которая несет с собой ISP.NET Core, она работает точно так же, как она будет работать в продакшене.
4865.86 4878.26 "Анатолий Кулаков" И это, в общем, самая главная фишка вот этого подхода, в том, что вы полностью тестируете ваше приложение и практически нереально поймать какие-то тонкости, которые у вас бы не воспроизвелись.
4878.26 4893.82 "Анатолий Кулаков" Опять же, если мы говорим не на уровне кестрила, не знаю, может, какие там веб-сокеты, нагрузка под веб-сокетами, естественно, вы этой штукой не протестируете, но все, что выше, прекрасно, все пайплайны, все мидлварии, все, что выше мидлварии, все тестируется великолепно.
4893.82 4902.18 "Анатолий Кулаков" Для того, чтобы вам такую вещь сделать, ваше приложение не нужно ни каким-то магическим образом подделывать или подстраивать, ничего этого не нужно.
4902.18 4934.54 "Анатолий Кулаков" Вам достаточно в вашем тестовом проекте подключить специальный Nuget пакет, создать New Web Application Factory, указать ей в качестве генерика аргумента Cleral Class Program, который является входной точкой для вашего сервиса, и дальше он с помощью там Reflection, конфигурации и прочего сам найдет нужные методы, сам передаст правильные аргументы, сам этот программ вызовет, этот программ уже пронициализирует полностью у вас настоящий сервис, запустит и сделает вообще все, что нужно.
4934.54 4940.38 "Анатолий Кулаков" В общем, теперь отличительные особенности от вашего настоящего сервиса.
4940.38 4947.42 "Анатолий Кулаков" Что было бы, если бы ваш настоящий сервис запустился, который поднял бы настоящий кестрил, открыл бы порт и начал бы слушать запросы, и между Web Application Factory?
4947.42 4952.22 "Анатолий Кулаков" На самом деле разница очень-очень маленькая, как я уже сказал, вот на вот этом низком уровне.
4952.22 4970.14 "Анатолий Кулаков" Для того, чтобы достучаться до вашего приложения, вам теперь нужен не обычный HTTP клиент, которым вы указываете URL и порт, потому что по этому URL и порту никого не будет, а специальный HTTP клиент, который вы можете создать из вот этого App Factory, из Application Web Factory.
4970.14 4983.22 "Анатолий Кулаков" Вы создаете специальный HTTP клиент, и специален он тем, что у него внутри есть HTTP хендлер, который редиректит все запросы, которые вы будете бросать, он редиректит на ваш сервер, тот, который у вас в памяти сейчас запущен.
4983.22 4988.42 "Анатолий Кулаков" Вот это единственная особенность, которая есть, и то, про которое вы, грубо говоря, задумываться не должны.
4988.42 4994.86 "Анатолий Кулаков" Единственное, о чем вы должны заботиться, это о том, чтобы все ваши клиенты использовали вот этот специальный HTTP клиент.
4994.86 5002.86 "Анатолий Кулаков" Если они создадут настоящий, обычный HTTP клиент, дефолтный HTTP клиент, он пойдет в сеть, и естественно, в сети вашего большого приложения не найдет.
5002.86 5006.14 "Анатолий Кулаков" Все остальное прекрасно работает и так.
5006.14 5019.10 "Анатолий Кулаков" Так как это In-Memory тесты, то есть, по сути, вы поднимаете ваш сервер полноценный, ISP-шный, в том же самом приложении, в котором у вас работают тесты, у вас есть возможность как-то подконфигурить этот сервис.
5019.10 5031.42 "Анатолий Кулаков" Вы можете обратиться к его Application Builder, вы можете зарегистрировать там какие-то дополнительные сервисы, например, замокать какие-нибудь тестовые сервисы, к которым он не должен ходить, куда-нибудь там в сеть почту отправлять.
5031.42 5045.10 "Анатолий Кулаков" Вы можете старый почтовый клиент оттуда выкинуть, чтобы мог клиента зарегистрировать и таким образом поднастроить ваше приложение, чтобы вот эти интеграционные тесты, они далеко в сеть не ходили, а тестировали только то, что внутри самого приложения.
5045.10 5049.58 "Анатолий Кулаков" И тут автора понесло.
5049.58 5064.46 "Анатолий Кулаков" Автор говорит, что типа я делаю вот этот реплейс в контейнерах сервисов, которые моковские, я хочу на моке их зареплейсить, и в каждом сервисе мне, в каждом тесте, по сути, мне делать это лень, потому что слишком многословно получается.
5064.46 5070.58 "Анатолий Кулаков" Поэтому я напишу специальный экстеншн метод, который мне позволит легче регистрировать моки в сервисах.
5070.58 5077.50 "Анатолий Кулаков" И на этом он, грубо говоря, свою статью заканчивает и говорит, смотрите, какие хорошие экстеншн методы написал.
5077.50 5083.02 "Анатолий Кулаков" Но мне кажется, это не до конца раскрученный путь, можно пойти гораздо дальше.
5083.02 5088.06 "Анатолий Кулаков" Во-первых, все-таки нужно понимать, что это интеграционные тесты.
5088.06 5098.46 "Анатолий Кулаков" Раз это интеграционные тесты, пусть даже мега-быстрые, но все же, мы этот сервер, который мы, ISP.NET Core Server, подняли, никакого смысла его поднимать для каждого теста нет, как предлагает автор.
5098.46 5106.62 "Анатолий Кулаков" Его можно поднять один раз для всех тестов, настроить, опять же, один единственный раз, а потом во всех тестах его юзать.
5106.62 5108.82 "Анатолий Кулаков" Это делается довольно-таки просто.
5108.82 5112.58 "Анатолий Кулаков" Если, допустим, использовать XUnit, вы создаете сервер коллекшн.
5112.58 5122.82 "Анатолий Кулаков" Это сервер коллекшн, наследователь от iCollectionFetch, который в дженерике принимает сервер-фичу, в которой реализован этот сервис.
5122.82 5127.02 "Анатолий Кулаков" И таким образом у вас в каждый тест будет зависеть от данного сервера.
5127.02 5134.74 "Анатолий Кулаков" То есть, сервер создается, поднимется один раз, а все тесты будут к нему ходить и таким образом обращаться очень быстро.
5134.74 5137.86 "Анатолий Кулаков" В общем, переюзывать все эти данные, которые в памяти у него там хранятся.
5137.86 5141.02 "Анатолий Кулаков" И таким образом вы получаете всего-навсего один раз.
5141.02 5146.02 "Анатолий Кулаков" Вы замокаете все эти ваши зависимости, при том, это один раз на всю сборку.
5146.02 5147.78 "Анатолий Кулаков" Вам не нужны никакие extension методы.
5147.78 5151.18 "Анатолий Кулаков" Просто зайдете в настройку тестового сервера и там все это зареплейсите.
5151.18 5154.14 "Анатолий Кулаков" И будете ездать во всех остальных тестах.
5154.14 5155.14 "Анатолий Кулаков" И все.
5155.14 5158.38 "Анатолий Кулаков" И на этом все проблемы ваши закончены.
5158.38 5160.26 "Анатолий Кулаков" Мы используем именно такой подход.
5160.26 5175.30 "Анатолий Кулаков" То есть, мы используем именно application web, application factory, как интеграционные тесты, естественно, которые позволяют нам тестировать именно pipeline, именно какую-то специфику SP net core, именно специфику middleware, авторизации, конвертеров, всего вот этого.
5175.30 5177.82 "Анатолий Кулаков" И это работает очень прекрасно.
5177.82 5183.66 "Анатолий Кулаков" Вторая статья, которую я пытался найти, это то, как посмотреть на этот сервер с другой стороны.
5183.66 5188.42 "Анатолий Кулаков" То есть, мы сейчас научились вам поднимать сервер, а теперь я уже говорил про специфику HTTP клиентов.
5188.42 5206.82 "Анатолий Кулаков" Если вы начинаете плотно работать и плотно писать какие-то там тесты на вот этот ваш поднятый локальный ISP net сервер, то вы сталкиваетесь с той проблемой, что как порядочный программист во всех ваших библиотеках вы должны использовать TypeIt HTTP clients.
5206.82 5210.86 "Анатолий Кулаков" В общем, если вы не знаете, что такое, посмотрите, это официальная рекомендация Microsoft.
5210.86 5225.14 "Анатолий Кулаков" То есть, как теперь создавать HTTP клиенты после того, как у нас появилась там HTTP client factory, после того, как мы научились DNS кэш сбрасывать, после того, как мы научились переузывать message invokers, которых там пул целый сделали.
5225.14 5234.98 "Анатолий Кулаков" В общем, после того, как у нас появилась новая концепция HTTP клиентов, свежих, модных, бодрых и красивых, в общем, официальная рекомендация Microsoft – это создавать TypeIt HTTP клиенты.
5234.98 5252.18 "Анатолий Кулаков" То есть, регистрировать такой HTTP клиент, то есть, регистрировать классик, который принимает определенный HTTP клиент и в этом классике уже делать оберточку в виде строго типизированных методов, строго типизированных DTO-шек, которые будут обращаться к этому зарегистрированному HTTP клиенту.
5252.18 5259.30 "Анатолий Кулаков" И вот если вы начинаете юзать по рекомендации Microsoft TypeIt HTTP клиенты, то у вас возникает небольшая проблемка.
5259.30 5263.34 "Анатолий Кулаков" А как вам теперь ходить к этому memory-сервису?
5263.34 5268.10 "Анатолий Кулаков" Потому что при использовании напрямую TypeIt HTTP клиентов, они начинают ломиться в сеть.
5268.10 5272.02 "Анатолий Кулаков" Они ничего не знают про тот mock, который мы там зарегистрировали.
5272.02 5274.82 "Анатолий Кулаков" Поэтому здесь вам необходимо пойти на хитрость.
5274.82 5278.38 "Анатолий Кулаков" Автор, опять же, предлагает следующую вещь.
5278.38 5283.78 "Анатолий Кулаков" Существует такая штука, как HTTP Message Handler.
5283.78 5297.62 "Анатолий Кулаков" Вот автор предлагает вам зарегистрировать свой HTTP Message Handler Builder, так называемый mock HTTP Handler Message Builder, который как раз таки билдит все сообщения, которые будут уходить на сервер.
5297.62 5305.70 "Анатолий Кулаков" Перекрыт там определенный метод, который в определенных случаях, а эти случаи у вас будут конфигурироваться через параметр.
5305.70 5309.90 "Анатолий Кулаков" В качестве параметра будет выступать concurrent dictionary.
5309.90 5319.38 "Анатолий Кулаков" И в этом concurrent dictionary вы будете передавать название строго типизированного клиента и хендлер, который нужно будет обработать, чтобы этот запрос от этого клиента ушел куда надо.
5319.38 5322.42 "Анатолий Кулаков" В общем, это не только на словах сложно описать.
5322.42 5324.38 "Анатолий Кулаков" Это и в коде слишком перегружено.
5324.38 5328.18 "Анатолий Кулаков" Ну, то есть, понятно, что он там хочет сделать, но сделан это опять через какую-то попеньку.
5328.18 5340.78 "Анатолий Кулаков" И это обидно, потому что я как бы подбирал как раз парочку тех авторов, которые мы часто обсуждаем и часто приводим их в пример, но вот оба они как-то не дотянули тему.
5340.78 5342.34 "Анатолий Кулаков" Дотягиваю за него тоже.
5342.34 5344.94 "Анатолий Кулаков" Как можно сделать намного легче?
5344.94 5350.90 "Анатолий Кулаков" У всех HTTP-клайентов, то есть строго типизированных клиентов, есть прекрасная особенность.
5350.90 5353.50 "Анатолий Кулаков" Они регистрируются в так называемом пайплайне.
5353.50 5357.66 "Анатолий Кулаков" И этот пайплайн легко можно конфигурировать, расширять или настраивать.
5357.66 5365.42 "Анатолий Кулаков" Для этого вам достаточно реализовать такой классик, такой интерфейсик, который называется IHTTP Message Handler Builder Filter.
5365.42 5369.62 "Анатолий Кулаков" Название сложное, но на самом деле результат работы его довольно примитивен.
5369.62 5372.46 "Анатолий Кулаков" Он регистрирует просто месседж-хендлеры.
5372.46 5377.90 "Анатолий Кулаков" Месседж-хендлеры это тот пайплайн, который строится для любого HTTP-клайнта.
5377.90 5387.06 "Анатолий Кулаков" То есть, когда вы в HTTP-клайнте выполняете какой-то запрос, типа «пойди мне к серверу .NET True», он сразу вам запускает определенные пайплайны.
5387.06 5391.02 "Анатолий Кулаков" Это можно представить с ISP.NET Core Middlewari.
5391.02 5396.54 "Анатолий Кулаков" Вот только там они называются Middlewari, а у HTTP-клайнта такие штучки называются Delegating Handlers.
5396.54 5402.82 "Анатолий Кулаков" То есть, это такие хендлеры, которые принимают на вход HTTP Request Message и должны отдать HTTP Response Message.
5402.82 5405.18 "Анатолий Кулаков" И внутри себя они могут его как угодно преобразовать.
5405.18 5409.02 "Анатолий Кулаков" Очень часто в этих хендлерах, например, добавляют какие-то заголовки, которые нужны.
5409.02 5411.10 "Анатолий Кулаков" Или авторизацию, которая вам нужна.
5411.10 5414.90 "Анатолий Кулаков" Или может быть проверяют статус-код или результат, который вернулся.
5414.90 5418.74 "Анатолий Кулаков" Здесь же часто делают кэширование, например, частых каких-то запросов и ответов.
5418.74 5421.66 "Анатолий Кулаков" В общем, это очень хорошая такая рабочая лошадка.
5421.66 5424.26 "Анатолий Кулаков" Прям очень хорошо сравнивается с Middlewari.
5424.26 5428.38 "Анатолий Кулаков" Как те эксплуатируют по полной, так и эти обычно люди эксплуатируют по полной.
5428.38 5430.46 "Анатолий Кулаков" Что же в нашем случае происходит?
5430.46 5443.26 "Анатолий Кулаков" В нашем случае мы можем написать такую Middlewari, которая внутри себя может редиректить все ваши запросы, которые направляются в сеть, может редиректить в наш In-Memory тестовый Web Application Factory Service.
5443.26 5445.34 "Анатолий Кулаков" То есть наш тестовый сервис.
5445.34 5452.22 "Анатолий Кулаков" Более того, так как мы знаем по какому адресу поднят наш тестовый сервис.
5452.22 5455.18 "Анатолий Кулаков" По сути у него адрес называется localhost и все.
5455.18 5461.62 "Анатолий Кулаков" Мы можем различать те запросы, которые вас HTTP-клиент бросил к нашему In-Memory тестовому сервису.
5461.62 5469.70 "Анатолий Кулаков" И те запросы, которые ваш HTTP-клиент шлет куда-то в настоящую сеть, к другому какому-то сервису, который доступен по сетевому адресу.
5469.70 5472.46 "Анатолий Кулаков" То есть мы, сравнивая адресы, можем их различать.
5472.46 5486.30 "Анатолий Кулаков" И поэтому в этом хендлере мы сделали такую очень легенькую проверку, которая говорит, что если этот реквест направлен к нашему тестовому сервису для localhost, тогда мы редиректим его на In-Memory вот этот pipeline.
5486.30 5490.30 "Анатолий Кулаков" Если нет, тогда мы отпускаем его к настоящему хендлеру и он уходит в сеть.
5490.30 5511.18 "Анатолий Кулаков" В общем, вот такой простой классик, вот такая простая доделочка позволяет писать интеграционные тесты с помощью Web Application Factory, поднимая настоящий сервис, при этом не меняя сам сервис, и юзая настоящие строго типизированные зарегистрированные HTTP-клиенты, при этом не меняя сами эти клиенты, потому что данный фильтр мы можем подключить только в тестах.
5511.18 5514.38 "Анатолий Кулаков" Естественно, в продакшене этот фильтр никогда подключаться не будет.
5514.38 5518.10 "Анатолий Кулаков" В общем, жалко, конечно, что никто из авторов не дал примеры этих кодов.
5518.10 5528.02 "Анатолий Кулаков" Это наталкивает на лишнюю мысль, что пора заняться ещё и писательством, не только говорением, и вот какие-то такие довольно неочевидные, но безумно полезные вещи надо бы как-то уже выкладывать.
5528.02 5530.38 "Анатолий Кулаков" В общем, если кому-то надо, приходите в комменты, обсудим.
5530.38 5540.22 "Игорь Лабутин" Да, будем писать статьи, но блин, я не люблю писать статьи, не знаю, мне на работе хватает писанины, поэтому лучше поговорить, а потом кто-нибудь…
5540.22 5543.90 "Анатолий Кулаков" Поэтому нам нужен отдельный секретарь PISUM, который будет
5543.90 5545.90 "Игорь Лабутин" за нас писать статьи. Писатель, да.
5546.06 5552.46 "Игорь Лабутин" Ладно, посмотрим, поехали тогда на последнюю… последнюю же тему?
5552.46 5554.14 "Игорь Лабутин" Да-да, последняя тема, кратко о разном.
5554.14 5565.06 "Игорь Лабутин" Набралось у нас всего три статейки на эту тему, я даже думал одну включить в основной выпуск, но чё-то я потом почитал и понял, что нет, не сядет она на основной выпуск.
5565.06 5566.06 "Игорь Лабутин" Но начнем по порядку.
5566.06 5588.90 "Игорь Лабутин" Во-первых, вышла PolyV8, Poly - это такая библиотечка, которая позволяет вам в вашем дотнет-приложении настроить все, что вы хотите с точки зрения ретраев, всяких политик, значит, circuit breakers и прочих таких штук, которые незаменимы и без которых не обойтись, когда вы пишете что-то распределенное.
5588.90 5612.02 "Игорь Лабутин" Восьмая версия - это прям довольно большой и сильный рефакторинг всего и вся, там сильно улучшилось много чего, настолько большое и настолько сильно, что теперь аж NugetPacket по-другому называется, он теперь называется poly.core, видимо подразумевается, что там есть еще и плагины, теперь, ну или какие-то расширения.
5612.02 5630.98 "Игорь Лабутин" Улучшили скорость, поменяли термин, раньше все называлось policy, теперь это называется стратегия, и появилась концепция resilience pipelines, то есть те самые пайплайны надежности или как там, не знаю, отказоустойчивости, то есть самые ради которых Poly использует.
5630.98 5640.78 "Игорь Лабутин" Модифицировали разные, значит, синки и асинки, раньше можно было что-то делать только синхронно, что-то только асинхронно, соответственно теперь все можно делать абсолютно одинаково.
5640.78 5653.98 "Игорь Лабутин" Нету больше никаких статических API, все, значит, там написано правильно и можно там мокать, если где-то надо в тестах там реализовывать интерфейсики, вот это все.
5653.98 5669.98 "Игорь Лабутин" По-новому конфигурироваться и завезли какую-то пачку телеметрии, то есть я, честно говоря, Poly настолько плотно не пользовался, чтобы там телеметрию какую-то оттуда считывать, но говорят теперь есть там полноценная поддержка телеметрии, в общем, говорят прям супер-супер релиз надо брать.
5669.98 5674.26 "Анатолий Кулаков" Ну, наверное, было бы удобно посмотреть, сколько раз он пытался, сколько получилось, сколько нет, ну то есть
5674.26 5697.10 "Игорь Лабутин" такие стандартные его попытки. Да, какая телеметрия, понятно, но как-то мы вот обходились, видимо, нашей внешней, по-моему, наверное, у нас просто висело что-то дополнительное, можно было что-то понять из наших остальных телеметрий, но да, говорят, видел несколько мнений, что прям очень хороший релиз, берите.
5697.10 5708.26 "Игорь Лабутин" Единственное, я вот не посмотрел, с чем он совместим, потому что понятно, что там есть какие-то минимальные требования по рантайму, ну в смысле по версии дотнета, вот это я чуть не посмотрел, с чем он там сейчас совместим у нас минимально.
5708.26 5715.90 "Игорь Лабутин" Но в любом случае, восьмерка скоро зарелизится, все мы переходим на восьмерку, в общем, поэтому ха-ха.
5715.90 5718.54 "Игорь Лабутин" Да, может быть далеко не все.
5718.54 5719.54 "Игорь Лабутин" Ну ладно.
5719.54 5734.78 "Игорь Лабутин" Вторая статья, это статья Стивена Клири, вот она как раз, я сначала хотел ее включить в основной выпуск, но она довольно технически сложная, поэтому оставлю, так сказать, для самостоятельного чтения, она про memory mapped файлы и про то, как из них читать данные.
5734.78 5742.94 "Игорь Лабутин" Как и Клири, с memory mapped файлами я лично работал очень давно, времена C++, виндового программирования, вот это всего.
5742.94 5756.50 "Игорь Лабутин" Это на самом деле способ не читать файл, а сказать операционной системе, мол, если я буду смотреть вот в эти адреса виртуальной памяти, сделай так, чтобы я смотрел в контент файла.
5756.50 5769.86 "Игорь Лабутин" То есть ровно так у нас подгружаются на самом деле операционные системы всякие xa и dll файлы, когда мы их грузим, то есть никто не читает с диска с точки зрения, там типа, прочитать в буфер и записать в память, они делают именно как memory mapped файлы.
5769.86 5773.26 "Игорь Лабутин" То есть это автоматически поддержано на уровне операционной системы.
5773.26 5792.90 "Игорь Лабутин" И вот Клири как раз показывает, как это сделать в C#, как замапить файлы, как к ним получать доступ, а самое главное, как сделать так, чтобы вы получали не просто доступ к набору байтиков, а доступ к набору байтиков через ваши структуры данных, которые как бы накладываются поверх.
5792.90 5801.18 "Игорь Лабутин" То есть C# будет думать, что именно в этом месте лежит ваша структура данных, а на самом деле там лежит файл, который физически есть на диске.
5801.18 5822.46 "Игорь Лабутин" Вот там возникает много разных интересных проблем, там типа возникают проблемы с выравниванием, возникают проблемы с старшими и младшими байтами, типа в каком порядке у вас лежат чиселки, big_ending, little_ending, вот это все.
5822.46 5839.38 "Игорь Лабутин" Возникают проблемы забавные с исключениями, то есть вы вроде как используете структуру, то есть вы вроде как не делаете никакого файла I/O с точки зрения кода, но фактически вы его делаете и там могут возникать исключения доступа к файлам, хотя вы всего лишь, например, просто читаете поле из структуры.
5839.38 5846.74 "Игорь Лабутин" Ну то есть много всяких разных приседаний, и вот как раз в статье написано, что с этим делать, как с этим работать.
5846.74 5859.90 "Игорь Лабутин" Ну статья типа первая из обещанного набора статей, поэтому возможно там не все досконально описано, но если вам вдруг зачем-то нужно быстро и типизированно читать из файла, может быть это интересный способ на винде, по крайней мере, с этим работать.
5859.90 5865.78 "Игорь Лабутин" Я, кстати, не знаю, на линксе, наверное, тоже есть какой-нибудь концепт мемориума файлов, но я не работал с ними.
5865.78 5867.18 "Анатолий Кулаков" Да, там есть.
5867.18 5870.90 "Анатолий Кулаков" То есть получается такая zero-cost сериализация у тебя по сути, да?
5870.90 5873.10 "Анатолий Кулаков" Ты можешь в файлике писать структуры и читать же их
5873.10 5876.62 "Игорь Лабутин" оттуда. Zero-cost бинарная сериализация даже, я бы сказал.
5876.62 5878.74 "Анатолий Кулаков" Ну бинарная, да, да, конечно.
5878.74 5884.62 "Анатолий Кулаков" Ну прикольно, да, хотя я тоже с мемориума маппет файлами лет 10 назад сталкивался, давно их не использовал как-то.
5884.62 5886.62 "Анатолий Кулаков" Да не надо, не нужны они сейчас.
5886.62 5890.82 "Анатолий Кулаков" Ну, Расклери обратился, значит, ему тоже зачем-то понадобились.
5890.82 5892.74 "Игорь Лабутин" Ну зачем-то понадобились, ну как бы да.
5892.74 5895.42 "Игорь Лабутин" В обычных бизнес-приложениях, скорее всего, вряд ли потребуется.
5895.42 5899.26 "Игорь Лабутин" А вот если вы пишете какую-нибудь базу данных или еще что-нибудь,
5899.26 5904.98 "Анатолий Кулаков" то может быть, может быть. Ну, кстати, да, вот самописные базы данных нужно начинать как раз с мемориума маппет файлов.
5904.98 5911.82 "Анатолий Кулаков" Это самый быстрый, самый понятный способ, как бы перестрельственно замапить в память и с довольно приличной скоростью.
5911.82 5915.26 "Анатолий Кулаков" Очень многие базы данных начинали как раз из мемориума маппет файла.
5915.26 5919.10 "Анатолий Кулаков" А потом, когда уже раскручивались, понимали про свою бизнес-модель, уже переходили на собственные движки.
5919.10 5925.70 "Анатолий Кулаков" Так, я еще нашел интересную статейку про pattern matching in C#.
5925.70 5931.62 "Анатолий Кулаков" В общем, мы очень много там в течение многих выпусков обсуждали там нововведения в pattern matching и так далее.
5931.62 5941.70 "Анатолий Кулаков" Ну дело в том, что это такие маленькие какие-то кусочки кода, которые довольно сложно там в голове удержать или как-то может быть систематизировать полностью, если говорить о них размазанно в несколько лет.
5941.70 5953.30 "Анатолий Кулаков" И вот хорошая статья, которая прямо собирает четко без лишней воды всякие нововведения в pattern matching, начиная прямо от C# 7 и заканчивая C# 11.
5953.30 5961.98 "Анатолий Кулаков" Здесь у вас будет все, начиная от type паттернов, declaration паттернов и kachayalist паттернов, extended property паттернов и так далее.
5961.98 5978.30 "Анатолий Кулаков" В общем, все это интересно очень посмотреть хотя бы визуально, к чему шел C#, какие шаблоны были добавлены, в какой версии и вообще, что мы умеем делать, потому что глядя на некоторые из них, я даже представить себе не могу, в каких бы случаях они бы мне пригодились.
5978.30 5982.10 "Анатолий Кулаков" Оказывается, мы так давно можем, давно умеем и языком это все поддерживается.
5982.10 5991.18 "Анатолий Кулаков" Поэтому очень красивые паттерники, хотя бы посмотрите перед сном, зацените всю мощь языка и все то, что вам могло бы, наверное, пригодиться, если бы вы о нем знали.
5991.18 6005.62 "Игорь Лабутин" Это как раз тот кейс, когда фичу, которую вводят последовательно на протяжении трех, наверное, лет, в пятом дотнете что-то появилось, в шестом дотнете что-то появилось, в седьмом дотнете что-то появилось, в восьмом дотнете что-то появилось.
6005.62 6011.70 "Игорь Лабутин" Уже как-то сложно следить, что когда появилось и что у нас, ты не помнишь иногда, что где было.
6011.70 6017.38 "Анатолий Кулаков" Ну да, но ты еще видишь, что основная проблема в том, что они не очень поддаются какой-то систематизации.
6017.38 6025.90 "Анатолий Кулаков" А все эти паттерн-матчинги, у них у всех практически там разные синтаксис, разные аргументы, разные параметры, в общем, очень много у них всего разного, такая вариативность довольно большая.
6025.90 6032.82 "Анатолий Кулаков" Поэтому как-то себя в голове-то систематизировать, а потом в течение нескольких лет наполнять смыслом, так не получится.
6032.82 6035.90 "Анатолий Кулаков" Надо все-таки зайти и посмотреть, что там и как оно бывает.
6035.90 6039.38 "Игорь Лабутин" Ну и попробуй и пописать, иначе забудете опять.
6039.38 6040.38 "Игорь Лабутин" Это точно.
6040.38 6042.14 "Игорь Лабутин" Ладно, давайте заканчивать.
6042.14 6053.46 "Игорь Лабутин" Сегодня у нас нет почти новостей от Microsoft, но мы все-таки посмотрели на новые возможности такого псевдорефлекшена в восьмом дотнете для частных случаев.
6053.46 6082.82 "Игорь Лабутин" Посмотрели, вспомнили, что нового в System Text JSON в восьмерке, узнали техническую информацию о том, что же Microsoft выяснил про зеленые потоки, посмотрели внимательно и лично на C# DevKit, можно пользоваться, глянули мнение Андрю Лока на тему Identity API Endpoints, посмотрели на то, как надо правильно мокать зависимости в тестах S/P/N CORE, ну и кратенько посмотрели на всякие поле, там и странные статьи про memory mapped файлы.
6082.82 6084.74 "Игорь Лабутин" Примерно так на сегодня.
6084.74 6092.06 "Анатолий Кулаков" Хорошо посидели, всем до новых встреч, не забывайте, шары, лайки, репосты, донаты, все ждем, все любим.
6092.06 6094.42 "Анатолий Кулаков" И до новых встреч, всем пока.
6094.42 6094.94 "Анатолий Кулаков" Всем пока.
