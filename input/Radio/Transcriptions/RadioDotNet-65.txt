0.00 11.68 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет выпуск номер 65.
11.68 13.76 "Анатолий Кулаков" Сегодня с вами, как всегда, Анатолий Кулаков.
13.76 14.76 "Игорь Лабутин" И Игорь Лабутин.
14.76 15.76 "Игорь Лабутин" Всем привет.
15.76 19.24 "Анатолий Кулаков" Прежде всего, хотелось бы поблагодарить наших помогаторов.
19.24 24.88 "Анатолий Кулаков" Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Илья, Гурий Самарин, Виктор.
24.88 35.44 "Анатолий Кулаков" Спасибо, друзья, спасибо, что нас поддерживаете, а также всех остальных наших друзей, которые также шарят, лайкают, репостят и делятся нашим подкастом со своими друзьями.
35.44 40.08 "Анатолий Кулаков" Вы все помогаете нам становиться более популярными и более доступными.
40.08 42.84 "Анатолий Кулаков" Спасибо вам большое за это.
42.84 45.72 "Анатолий Кулаков" Давай посмотрим, что накопилось за то время, пока мы отдыхали.
45.72 49.76 "Анатолий Кулаков" Новогодние каникулы закончились, все оттаяли.
49.76 55.72 "Анатолий Кулаков" И прямо первая тема первого выпуска в этом году у нас будет сразу про C# 12.
55.72 58.48 "Анатолий Кулаков" Что там уже вышло, зарелизилось?
58.48 61.08 "Игорь Лабутин" Ну, сильно много пока не вышло и не зарелизилось.
61.08 72.36 "Игорь Лабутин" Мы ждем официального первого превью дотнет-сдк, который обещают, что он выйдет в феврале, так что будем надеяться, что так и случится, и мы точно узнаем уже, что будет включено в этот сдк.
72.36 81.36 "Игорь Лабутин" Но я ради интереса пока пошел на GitHub и посмотрел, что на самом деле происходит с C# 12, как планируют, что делают.
81.36 94.64 "Игорь Лабутин" И как мы знаем, вообще говоря, дизайн языка у нас полностью открытый, только сами совещания не видны, но все каких-то минутки записываются в GitHub-репозиторе специальной дотнет-сдк.
94.64 100.84 "Игорь Лабутин" И я пошел посмотреть, что же там творится с точки зрения подготовки к следующему релизу языка.
100.84 116.84 "Игорь Лабутин" И выяснилось, что на самом деле работа началась примерно в августе 22 года, уже тогда начался обзор всего того, что там накопилось, с тем, чтобы решить, какие фичи, какие вообще области, я бы даже сказал, нужно рассматривать для следующего релиза.
116.84 127.32 "Игорь Лабутин" Вся разработка языка, весь дизайн, процесс дизайна, он основан на так называемых топиках или темах.
127.32 134.72 "Игорь Лабутин" Понятно, что там есть топик типа everything else, и туда попадают всякие мелочи, но больших тем тоже несколько есть.
134.72 138.24 "Игорь Лабутин" Первая большая тема — это discriminated unions.
138.24 165.24 "Игорь Лабутин" И здесь надо сказать, что я еще послушал какие-то подкасты с Мэтсом Торгерсоном, и у него прозвучала интересная мысль, что discriminated unions, как целиковые фичи, как ее там все многие хотят, с очень малой вероятностью заедет в язык, вот прям так целиком, как одна большая единая фича, как, не знаю, дженерики как это заехали, или async/await или что-то подобное.
165.24 172.48 "Игорь Лабутин" Скорее всего, во-первых, поскольку сама фича большая, то за один год разработки ее просто не сделать.
172.48 185.32 "Игорь Лабутин" А второй момент, что discriminated unions — это одна из, наверное, если не основополагающих, то очень важных вещей в функциональных языках.
185.32 191.92 "Игорь Лабутин" В то же время в объектно-ориентированных языках в принципе какую-то похожую роль играет наследование.
191.92 204.92 "Игорь Лабутин" То есть вы можете отнаследовать несколько дочерних классов от базового, да, вы не можете полностью сказать, что на этом иерархия полностью закончена, хотя через сил от класса это как-то можно пытаться выразить.
204.92 223.64 "Игорь Лабутин" И если добавить в C# и discriminated unions в полноценном своем виде, в том, как они во многих функциональных языках представлены, то по мнению Мэнса это будет означать, что в C# появились две, ну по сути, конкурирующие концепции — discriminated unions из функционального мира и объектно-ориентированное наследование из объектно-ориентированного мира.
223.64 230.16 "Анатолий Кулаков" Странно, что он об этом задумывается, как бы до этого всякие линкусы, лекторы и прочие лямбда его не смущали.
230.16 236.04 "Игорь Лабутин" Они его не смущали, он про это явно говорил, потому что они хорошо вписываются в объектно-ориентированные парадигмы в том числе.
236.04 258.72 "Игорь Лабутин" А вот discriminated unions, они уже касаются, так сказать, основы основ, то есть наследования и объектов, хотя при том он сам говорит, что мы понимаем, что поскольку наш, ну в основном все-таки C# — это язык объектно-ориентированный, то у нас довольно большое количество кода уходит именно на объявление объектов.
258.72 276.40 "Игорь Лабутин" Раньше это были прям вообще очень подробнейшие свойства и так далее, именно поэтому появились автопроперти, expression body, рекорды, primary конструкторы, вот это вот все вот это вот фигня, она появляется ради того, чтобы, охранив объектную ориентированность, уменьшить количество кода.
276.40 301.76 "Игорь Лабутин" И возвращаясь к discriminated unions, он говорит, что скорее всего мы будем какие-то кусочки из их, так сказать, концептуально завозить в C#, то есть возможно мы сможем как-то завести мысль, что как проверить полноценность закрытости наследования, то есть что большего этого класса наследников быть не может, тогда можно будет там pattern matching лучше все проверять и так далее.
301.76 327.44 "Игорь Лабутин" То есть какие-то кусочки они завозить будут, примерно как они завозили pattern matching на протяжении нескольких версий, но с завезением через несколько версий у них есть своя проблема, потому что нельзя, то есть что-либо завезенное в язык практически навечно становится в этом языке C# обратно совместим, за исключением очень маленьких мелочей, до версии 1.0.
327.44 335.88 "Игорь Лабутин" И поэтому сложно, разрабатывая фичу, которая занимает 2-3 года разработки, завести в первый год что-то, а в третий год захотеть это что-то поменять.
335.88 336.88 "Игорь Лабутин" Не получится уже.
336.88 341.72 "Игорь Лабутин" И в этом трудность, поэтому они очень тщательно планируют всякие такие большие фичи.
341.72 346.72 "Игорь Лабутин" Так что посмотрим, до чего доберется Discriminate.Union в 12-ом C#.
346.72 353.48 "Игорь Лабутин" Мэтс говорит, что возможно мы что-то сможем сделать в 12-ом C#, возможно только как превью флаг.
353.48 354.48 "Анатолий Кулаков" Ну посмотрим.
354.48 374.12 "Анатолий Кулаков" Да, интересен вообще сам вот этот процесс, то есть кажется, что эта фича она будет работать, она полезна к ней все привыкли только как действительно одной такой большой, которая пронизывает абсолютно весь язык и она именно прекрасна своей полноценностью, чтобы она и в синтексе хорошо писалась, и там отлично проверялась, и рантаймом поддерживалась.
374.12 384.64 "Анатолий Кулаков" И вот интересен как раз таки процесс, каким образом они будут выделять вот эти маленькие части, которые действительно можно поставить как отдельную ценность и при этом не развалить весь Discriminate.Union.
384.64 394.04 "Анатолий Кулаков" Ну то есть проблема интересная, проблема сложная, и как они ее будут решать, это вот достойно отдельной статейки, в общем достойно какой-то отдельной темы.
394.04 395.88 "Анатолий Кулаков" Я бы с удовольствием послушал, почитал.
395.88 429.72 "Игорь Лабутин" Ну вот на самом деле я почитал кучу всяких их итогов совещаний по результатам, вот с августа их там прошло, наверное, штук 15, если не ошибаюсь, по language design митингов так называемых, и я почитал всякие выводы, не все детально, не ходил во все их оближения, там очень много упоминается, но пока кажется, что нет какого-то консенсуса, скорее всего они образуют какую-то там рабочую группу, как они это называют, или что-то подобное, и будут прорабатывать уже вот в течение 12 сишап, в течение этого года, что же с этим делать, посмотрим.
429.72 443.84 "Игорь Лабутин" Есть еще вторая такая же большая тема, которую тоже много кто хочет, и они сами этого тоже хотят, но тоже пока не очень понимают до конца, точнее не очень спланировали до конца как к этому подступиться, называется roles или extension everything.
443.84 462.60 "Игорь Лабутин" То есть у нас есть сейчас extension методы, а идея в том, чтобы сделать extension что угодно, хочешь extension property, хочешь extension interface, в смысле на существующий класс с помощью какого-то extension реализовать какой-то сторонний интерфейс, который исходно классом не реализуется.
462.60 468.32 "Анатолий Кулаков" Ты имеешь в виду делать так, как будто он от этого интерфейса наследуется, правда он от него не наследуется.
468.32 471.08 "Анатолий Кулаков" То есть extension наследования такое больше получается.
471.08 472.08 "Анатолий Кулаков" Интересно, да.
472.08 496.20 "Игорь Лабутин" Можно сделать возможность, что если я знаю, как я хочу, чтобы там не знаю какой-нибудь стандартный, например, класс, ну string, наверное, плохо, ну какой-нибудь, короче, стандартный класс, реализовывал там мой интерфейс, я знаю, как я хочу его реализовать, понятно, что там могут быть тонкости с реализацией, она может быть не такая быстрая, например, как если бы реализовал ее автор этого класса, но тем не менее, хоть какая-то есть.
496.20 504.12 "Игорь Лабутин" Вот сейчас такого сделать нельзя, они хотят, чтобы это было сделать, можно, но тут примерно такая же проблема, как с discriminated unions и нарезанием по частям.
504.12 517.84 "Игорь Лабутин" Там возникает слишком много всего, что может пойти не так или слишком много пересечений с другими фичами языка и внутренностями компилятора, что тоже они много ведут обсуждений, как к этому подойти.
517.84 529.88 "Анатолий Кулаков" Мне кажется, уже extension методы протоптали хорошую дорожку, как в техническом плане, так и в умах потребителей, и поэтому те же самые extension property, допустим, extension наследования не должны вызвать какие-то большие
529.88 551.16 "Игорь Лабутин" грабли. В умах потребителей не вызовут, а вот внутри во всяком разрешении, то, что называется overload resolution, разрешение перегрузок, то есть чисто внутренняя штука компилятора, чтобы компилятор внутри сам себя остался корректен и вообще в принципе мог нормально обрабатывать код, там есть немало тонн кастей.
551.16 557.08 "Анатолий Кулаков" Ну, наверное, но если так представить, что все это вызов статических методов и тогда все становится на полочке.
557.08 560.00 "Анатолий Кулаков" Главное выяснить, какого статического метода надо вызвать.
560.00 561.00 "Анатолий Кулаков" Оверлод резолюшн.
561.00 562.00 "Анатолий Кулаков" Да, может быть.
562.00 584.16 "Игорь Лабутин" И я опять же слушал подкастик с главой, соответственно, Розлина Джаредом Парсонсом, и он говорил, что любая фича, в которой произносятся слова overload resolution, это как бы там x2 к разработке, потому что это самая сложная часть компилятора, которая практически не меняется с момента ее рождения.
584.16 590.00 "Игорь Лабутин" То есть ее по чуть-чуть дорабатывают только в тех местах, где она точно нужна.
590.00 596.84 "Игорь Лабутин" Потому что там очень много тонкостей, которые очень во многих тонких местах могут сломать обратную совместимость.
596.84 610.92 "Анатолий Кулаков" Действительно, это опасная штука, потому что у тебя в одной версии там с ДК вызывалась одна функция, а в другой версии с ДК вдруг начнется вызываться другая функция, просто у которой параметры местами поменялись, и ты это практически не отдебажишь.
610.92 613.68 "Анатолий Кулаков" Так что да, это кусочек очень важный.
613.68 616.40 "Игорь Лабутин" Вот они тут и думают.
616.40 623.28 "Игорь Лабутин" Дальше есть еще три у них больших области, больших темы, над которыми они думают.
623.28 626.24 "Игорь Лабутин" Во-первых, одна называется почему-то tooling improvements.
626.24 643.64 "Игорь Лабутин" Как language design соотносится с tooling не очень понятно, но тем не менее они говорят, что они хотят немножко посмотреть в сторону этих polyglot notebooks, Jupyter notebooks или .NET, и понять, может быть, где там какие-нибудь специфические фичи языка могут быть полезны.
643.64 647.60 "Игорь Лабутин" Не очень понятно, при чем здесь язык, но, наверное, есть какой-то запрос.
647.60 655.72 "Анатолий Кулаков" Тебе не кажется, что вот это устранение main и всякие minimal API, это как раз-таки все про интеграцию с подобными tooling?
655.72 656.72 "Анатолий Кулаков" Это часть языка.
656.72 659.28 "Игорь Лабутин" Да, это часть языка, я согласен.
659.28 686.76 "Игорь Лабутин" Это на самом деле конкретно вот устранение main и так далее, Мэдс опять же говорил, что это больше в сторону упрощения языка и приведения его к более современному виду, потому что вот тот язык, который, как мы знаем C#, вот это вот там объяви namespace, объяви класс, объяви внутри статический метод, ну и в Java такая же фигня, это то, как дизайнились языки в то время, когда дизайнился C#, в начале 2000-х.
686.76 689.60 "Игорь Лабутин" Тогда это было популярно так, сейчас популярно не так.
689.60 700.40 "Игорь Лабутин" И все эти top-level statement, это скорее дань моде современной, чтобы C# оставался достаточно современным, чтобы его выбирали, в том числе те, кто только сейчас начинает.
700.40 707.08 "Анатолий Кулаков" Ну ладно, но если мы говорим про нормальный интерпрайс проект, то часто ли ты редактировал этот файл к программам CS?
707.08 709.48 "Анатолий Кулаков" Ну ты его раз в жизни создал, он автоматически сгенерился и про него все забыли.
709.48 719.00 "Игорь Лабутин" В интерпрайсе все так, но если у тебя не будет тех самых newcamera, которые выберут C# в качестве первого языка, у тебя интерпрайза не будет расти количество.
719.00 728.96 "Анатолий Кулаков" Ну вот, поэтому это прежде всего сделано для как раз новичков, которые входит в язык и быстро выучат, и может быть как раз таки интеграция с тулингом, потому что в ноутбуках ты тоже не будешь писать вот эти static main.
728.96 729.96 "Анатолий Кулаков" Конечно, конечно.
729.96 734.48 "Анатолий Кулаков" Ты просто хочешь top-level statement получить и все, и пошел дальше описываться.
734.48 735.48 "Игорь Лабутин" Конечно.
735.48 736.48 "Игорь Лабутин" Вот посмотрим, во что это выльется.
736.48 740.64 "Игорь Лабутин" Ну, тулинг есть, каких-то подробностей пока нет, но такая тема есть.
740.64 743.68 "Игорь Лабутин" Следующая тема, с которой они хотят поработать, это expression trees.
743.68 751.12 "Игорь Лабутин" Я так понимаю, что она была добавлена где-то в районе linq, третья у нас версия это, по-моему, языка.
751.12 753.36 "Игорь Лабутин" Я сейчас боюсь наврать, но примерно.
753.36 755.56 "Игорь Лабутин" Ну да, где-то возле linq это было.
755.56 757.96 "Игорь Лабутин" И с тех пор они не менялись, по сути.
757.96 760.52 "Игорь Лабутин" И там есть что дорабатывать.
760.52 769.00 "Игорь Лабутин" Опять же, не знаю, откуда запрос идет, не видно как-то каких-то корней, особо по гитхабу сильно не смотрел, но вот говорят, что на expression trees поработать надо будет.
769.00 770.72 "Игорь Лабутин" Может быть, мы что-то увидим новенькое.
770.72 773.92 "Анатолий Кулаков" То есть в какую сторону они хотят это дорабатывать непонятно.
773.92 774.92 "Игорь Лабутин" Пока непонятно, да.
774.92 777.32 "Игорь Лабутин" Это просто как бы обозначено несколько больших тем.
777.32 779.32 "Игорь Лабутин" Типа мы думаем.
779.32 780.32 "Игорь Лабутин" Хорошо.
780.32 785.60 "Игорь Лабутин" И пятая большая тема, это так называемые community-driven projects.
785.60 789.56 "Игорь Лабутин" Это то, что предлагает именно community.
789.56 790.56 "Игорь Лабутин" Давайте вот это включим.
790.56 808.76 "Игорь Лабутин" То есть это довольно большой кусок пропозлов, которые понятно, что требуют продумывания, проработки и так далее, потому что в большинстве случаев, понятно, когда приходит какой-нибудь мэц или тот же Джаред, у них в голове уже там наполовину вся мотивация есть.
808.76 812.84 "Игорь Лабутин" То есть не просто им пришла в голову клевая мысль, добавить ли это в C#.
812.84 817.24 "Игорь Лабутин" Скорее всего у них уже есть там половина мотивации написанной даже, может быть, где-то.
817.24 822.76 "Игорь Лабутин" А community иногда приходит с пропозлами, которые еще нужно обсуждать, обдумывать.
822.76 826.48 "Игорь Лабутин" Но тем не менее они важны, они с ними работают.
826.48 832.84 "Игорь Лабутин" И вот один из таких пропозлов может даже дожить, может быть даже появится в 12-ом C#, если все успеется.
832.84 835.68 "Игорь Лабутин" Это ключевое слово "field".
835.68 838.12 "Анатолий Кулаков" Ужас, это какую проблему решает?
838.12 844.64 "Игорь Лабутин" Это решает проблему, если у тебя есть проперти, и тебе нужно делать что-то нетривиальное в get_set.
844.64 847.04 "Игорь Лабутин" Ну допустим, валидировать в сеттере что-то.
847.04 849.04 "Игорь Лабутин" А у тебя там value есть?
849.04 851.96 "Игорь Лабутин" Value – это аргумент, а присваивать куда?
851.96 854.04 "Игорь Лабутин" Ну присваивать к какому-нибудь field.
854.04 864.04 "Игорь Лабутин" Да, ты заводишь специальное поле, которое обычно называется как property только, ну в зависимости от конвенции, либо с подчеркивами начинается, либо с маленькой буквы, того же типа, и так далее.
864.04 866.20 "Игорь Лабутин" Но предлагается вместо этого просто сделать ключевое слово "field".
866.20 870.04 "Игорь Лабутин" И это будет такое скрытое backing поле, грубо говоря.
870.04 874.28 "Анатолий Кулаков" Автоматическое property, которое будет само заводиться, самодекларируется, и тебе не нужно тратить на это
874.28 883.92 "Игорь Лабутин" место. Да, внутри автопроперти ты можешь, кроме value, этого аргументов его сета, можно будет использовать ключевое слово "field", и это будет то, куда это value положить.
883.92 887.16 "Игорь Лабутин" Ну тогда ладно, да, вроде звучит полезно.
887.16 896.32 "Игорь Лабутин" То же самое сокращение немножко, потому что эти проперти народ любит, но стоит хоть какую-то минимальную валидацию – здрасте, автопроперти отвалилось.
896.32 898.76 "Игорь Лабутин" Уже приходится писать поле явно.
898.76 902.84 "Анатолий Кулаков" То есть чтобы остаться в рамках автопроперти и перед этим иметь возможность обращаться к field.
902.84 905.12 "Игорь Лабутин" Да, но только из этой проперти, по сути.
905.12 907.40 "Игорь Лабутин" Ни из какого-либо другого места ты к field уже не обратишься.
907.40 908.40 "Игорь Лабутин" Ну да, логично.
908.40 909.40 "Анатолий Кулаков" Вот.
909.40 917.80 "Игорь Лабутин" Это имеет смысл, обсуждение ведется, и если будет реализовано, ну вот почему нет.
917.80 931.56 "Игорь Лабутин" Ну и дальше есть еще всякие мелкие штуки, типа там, пока они сделали switch, да, у нас же теперь switch – это expression, раньше это был, кто там, statement, получается.
931.56 932.56 "Игорь Лабутин" Да.
932.56 936.24 "Игорь Лабутин" Сейчас он стал expression, вот они подумывают, не сделают ли еще какие-нибудь штуки тоже expression.
936.24 946.44 "Игорь Лабутин" То есть там пока это написано очень обтекаемо, типа expanding set of expressions, то есть еще больше то, что выражения, которые были statement, станут expression.
946.44 947.44 "Игорь Лабутин" Какие, пока непонятно.
947.44 950.84 "Игорь Лабутин" Но, видимо, опять же что-то имеют в виду для себя.
950.84 954.16 "Анатолий Кулаков" Я бы if-чик предложил, от if-чика мне тоже expression не
954.16 956.16 "Игорь Лабутин" хватает. Да, вместо тернарного оператора.
956.16 963.60 "Анатолий Кулаков" Ну да, тернарное – это обычно что-то маленькое, если нужно прям блоки засунуть, то почему бы и не сделать это expression.
963.60 975.32 "Игорь Лабутин" Ну, в общем, вот это то, что видится, вот этот список тем – это то, что я увидел по результатам обсуждений вот этих вот, то есть заметок митингов.
975.32 988.60 "Игорь Лабутин" Отдельно к этому есть еще специальная большая, ну в смысле, ishio на гитхабе, отдельный, один, где трекается собственно текущий, так скажем, прогресс, текущие актуальные темы.
988.60 1004.08 "Игорь Лабутин" И здесь более такой подробный список, это, у них это называется working set themes, то есть типа те это большие важные темы, больше, наверное, для обсуждений такого глобального стратегического планирования.
1004.08 1008.88 "Игорь Лабутин" Это более тактические темы, вот на ближайшее будущее, возможно, на ближайший релиз.
1008.88 1014.16 "Игорь Лабутин" Значит, они точно хотят поработать над инициализацией и immutability больше.
1014.16 1024.76 "Игорь Лабутин" Сюда относятся всякие primary конструкторы, рекорды, вот вокруг этого всего, там, рекорд классы, рекорд стракта и вот это все такое прочее.
1024.76 1036.68 "Игорь Лабутин" Конкретных пока прополз… там можно посмотреть конкретные проползлы, но я настолько детально сейчас не буду углубляться, потому что некоторые там залинкованы, те, которые давным-давно в репе, но там годами не обновлялись.
1036.68 1040.08 "Игорь Лабутин" Поэтому непонятно, что из этого пойдет в 12-ый C#.
1040.08 1041.52 "Игорь Лабутин" Подождем официальных релизов.
1041.52 1048.08 "Игорь Лабутин" Паттерн-матчинг, работа со скоупами, с nullability что-то еще хотят сделать.
1048.08 1056.56 "Игорь Лабутин" Есть отдельный разделчик, называется boilerplate-reduction, так что мы ожидаем еще какого-то сокращения синтаксиса.
1056.56 1069.12 "Игорь Лабутин" Те самые closed types, это вот реверанс в сторону discriminated unions, то есть если у нас есть иерархия, где мы точно знаем, что никаких других наследников не будет, то видимо, паттерн-матчинг может более эффективно работать.
1069.12 1075.28 "Игорь Лабутин" Statements, expressions, span и ref какие-то будут еще изменения.
1075.28 1079.84 "Игорь Лабутин" Deconstruction, там какие-то мелочи.
1079.84 1082.96 "Игорь Лабутин" Afterproperty мы обсудили, fields, ну и всяко-разно.
1082.96 1094.24 "Игорь Лабутин" То есть, в общем, если посмотреть на то, что такие более тактические штуки про C# в 12-ом, там прямо есть конкретные ищутся, которые обсуждаются, но они сейчас все обсуждаются на уровне, ну, надо что-нибудь поэкспериментировать.
1094.24 1096.80 "Игорь Лабутин" Какие эксперименты это вылезет, пока непонятно.
1096.80 1111.28 "Игорь Лабутин" И есть третье место, куда можно смотреть с точки зрения, чтобы вы хотели, ну, точнее, если вам интересно знать, что происходит в C# или что будет происходить в C#, это репозиторий самого рослина, компилятора нашего.
1111.28 1122.96 "Игорь Лабутин" И там есть на вике тоже табличка уже с, грубо говоря, статусом тех фич, которые сейчас находятся в прогрессе с точки зрения реализации.
1122.96 1133.04 "Игорь Лабутин" Это может быть пока в бранчах, это может быть уже влито в мастер, это может быть выкинуто, даже не доведя до конца реализации, но тем не менее, вот над этими штуками они работают.
1133.04 1155.96 "Игорь Лабутин" Первая штука, это называется semi-auto property, то есть полу-auto property, и здесь смысл заключается в том, насколько я помню, вот я сейчас что-то не помню, мы можем сделать такую штуку, например, в get написать какое-нибудь там развесистое тело, а в set написать ничего, set.запятой.
1155.96 1156.96 "Игорь Лабутин" По-моему, у нас сейчас либо-либо.
1156.96 1160.60 "Анатолий Кулаков" Нет, да-да, или auto property, или пиши оба.
1160.60 1168.84 "Игорь Лабутин" Вот, вот здесь как раз такиe вот semi-auto property можно будет сделать так, это, видимо, как раз тот самый, возможно, с field'ом, там где field.
1168.84 1171.04 "Игорь Лабутин" Ну да, кажется, что они пересекаются.
1171.04 1172.04 "Игорь Лабутин" Да.
1172.04 1182.52 "Игорь Лабутин" Primary конструкторы, это когда вы прямо в объявлении класса, например, public класс, то имя класса, после этого в скобочках сразу пишите аргументы, и это будет primary конструктор автоматически.
1182.52 1185.32 "Игорь Лабутин" То, что у нас сейчас уже есть в рекордах, по сути.
1185.32 1208.08 "Игорь Лабутин" Да, да-да-да, вот они хотят расширить на классы, как я понял, span от t хотят затащить в params, сейчас там массив объектов, ну хотят с паном, плюс там же почему-то в этом же бранче написано, что обрисдется работа над stack'олоком для вообще любых типов, то есть stack'олок массивов любых типов можно будет делать.
1208.08 1209.08 "Анатолий Кулаков" Неплохо.
1209.08 1214.32 "Игорь Лабутин" Вот, непонятно, почему это связано, но, наверное, потому что params span от t этого требует как раз.
1214.32 1216.32 "Анатолий Кулаков" Да, ты params должен на stack'е локать.
1216.32 1224.12 "Игорь Лабутин" Ну, а, ну если он с паном, то да, ты вынужден это делать на stack'е, согласен, как раз поэтому и связано, не подумал.
1224.12 1235.92 "Игорь Лабутин" Name of какой-то очередной улучшается, а, name of там сейчас требует типа имени типа или что-то в таком духе, они хотят, чтобы можно было как-то попроще, ну, минимальное какое-то сокращение синтаксис, да ладно.
1235.92 1253.72 "Игорь Лабутин" Default в deconstruction'е, это можно будет написать что-то типа скобочка там var, скобочка a, запятая b, присвоить скобочка default и типа default развалится на два default'а, типа такой простой инстализация всех переменных default'ом через deconstruction.
1253.72 1265.44 "Игорь Лабутин" И collection literals, тут они работают над такой, ну, над штукой как бы это, еще поулучшать синтаксис вокруг литералов коллекций.
1265.44 1276.92 "Игорь Лабутин" Он же у нас как бы есть, в фигурном скобочках же, да, мы по-моему литералы при инстализации задаем, но компилятором это разворачивается в object initializer и вызов fdd, если я правильно помню.
1276.92 1278.92 "Анатолий Кулаков" Да, все верно в этом.
1278.92 1281.64 "Игорь Лабутин" Вот, а здесь они что-то хотят с этим делать.
1281.64 1297.00 "Игорь Лабутин" Я так все рассказываю, что-то хотят, что-то хотят потому, что там как бы либо надо очень внимательно смотреть на все pull-requests, либо очень внимательно читать ish, там миллиард комментариев к некоторым, поэтому я пока сделал такой очень кратенький обзор, чтобы примерно понимать.
1297.00 1321.84 "Игорь Лабутин" Отсюда можно сделать вывод на данный момент, что каких-то, с моей точки зрения, супербольших фич на горизонте прямо сейчас не видно, то есть нет какой-то единой темы, которая обсуждается из language design митингов по нескольку раз как бы за неделю, но явно над какими-то фичами работы ведутся, и что-то большое наверняка мы в 12 c# должны увидеть.
1321.84 1327.08 "Игорь Лабутин" Надеюсь, что-то из того, что мы давно ждем, типа discriminated unions или extension everything.
1327.08 1335.44 "Анатолий Кулаков" Ну действительно, потому что последний релиз был довольно бедный на язык, и завезли нам всякие мелочи, а чего такого большого мясистого порадоваться, так мы и не дождались.
1335.44 1340.88 "Анатолий Кулаков" Хотелось бы, чтобы они вот хотя бы за два релиза, за две версии что-нибудь нам выдали.
1340.88 1347.28 "Анатолий Кулаков" Ну а так да, подождем релизов, официальных анонсов от Microsoft и посмотрим, что они там решают.
1347.28 1358.84 "Игорь Лабутин" Ну да, самое интервью с Джаредом Парсонсом как раз было очень показательно в этом смысле, его спрашивали прямо явно, а вот как на вашу команду влияет этот самый релизный цикл-то раз в год.
1358.84 1361.56 "Игорь Лабутин" Он говорит, ну как говорит, влияет в две стороны.
1361.56 1386.84 "Игорь Лабутин" С одной стороны, у нас теперь нету трех лет, чтобы спокойно заприметить фичу, и это прямо как бы ужасно говорит, потому что приходится, то что я говорил чуть раньше, если мы хотим попилить релиз фичи, ну разработку на несколько частей, не, ну мы можем делать ее в бранче три года, но как бы это не очень, потому что лучше выкатить все-таки хоть какую-то версию и показать людям.
1386.84 1405.44 "Игорь Лабутин" А говорит, либо нужно ее пилить, но пилить желательно так, чтобы то, что ты диплоишь в первый год, во-первых, работало и приносило пользу само по себе, желательно не нужно было менять, когда ты дойдешь до третьего года разработки и выяснишь, что ты ошибся в первом году, потому что как бы не круто.
1405.44 1418.64 "Игорь Лабутин" И это, говорит, конечно, очень сильно напрягает с точки зрения дизайна, требует в два раза больше времени дизайнить, но типа нам скорее нравится, потому что позволяет получить, конечно, быстрый фидбэк, и быстрый фидбэк, говорит, это прям вообще супер.
1418.64 1424.60 "Игорь Лабутин" То есть смотри пример с этим argument now проверкой, помнишь, с двумя восклицательными знаками после имена?
1424.60 1428.32 "Анатолий Кулаков" Ну да, но смотри, это настолько мелкая фича, что они бы ее и так могли бы выпустить.
1428.32 1435.44 "Анатолий Кулаков" То есть я не вижу для них профита, если они хотят что-нибудь там за неделю выпустить, типа вот этой проверки, ну пусть выпустят да посмотрят.
1435.44 1440.68 "Анатолий Кулаков" А если им нужно что-то сесть на три года расписать, то мне кажется надо было дать им шанс сесть и расписать.
1440.68 1450.44 "Игорь Лабутин" Смотри, так вот с argument now они как раз, Джаред говорит, фича была полностью готова в C# 10, мы могли ее взять и включить в релиз 10 C#.
1450.44 1466.16 "Игорь Лабутин" Мы специально не стали ее включать, зарелизили 10 C# и включили в первое превью 11, потому что понимали, что что-то она была очень такая контровершер, когда мы обсуждали внутри дизайн митингов, и нам не было понятно как народ ее воспримет.
1466.16 1469.72 "Игорь Лабутин" И превью показало, что народ воспринимает ее неоднозначно.
1469.72 1477.64 "Игорь Лабутин" Есть те, кто как бы ну типа 50/50, половина отзывов восторжены, половина отзывов как бы что-то хрень какая-то.
1477.64 1485.08 "Игорь Лабутин" Поняли, что мы были недалеки от правды, то что на дизайн митингов тоже были, все очень контровершил, и типа откатили.
1485.08 1492.92 "Игорь Лабутин" А говорит, прикиньте, ну как бы вот мы такое бы выкатили в старом варианте, когда студия релизится раз в три года вместе с компилятором.
1492.92 1497.20 "Игорь Лабутин" Все, как бы зарелизили, и даже если народу не понравилось, сорян, уже без шансов откатить.
1497.20 1499.68 "Анатолий Кулаков" Да не, мне кажется это надо комбинировать.
1499.68 1510.66 "Анатолий Кулаков" Ну то есть такие мелкие фичи ты можешь выкатывать раз в год, а какие-нибудь большие фичи типа дискриминационный юнион, которые невозможно выкатить раз в год, можно дать им время, чтобы они сели там и раз в три года такую штуку сделали.
1510.66 1517.32 "Игорь Лабутин" Ну, им никто не мешает, то есть понятно, что ты в правом бранче можешь, ну в смысле в любом бранче сиди да делай ты сколько угодно.
1517.32 1525.52 "Анатолий Кулаков" Ну видишь, они же все-таки стараются по чуть-чуть выкладывать, чтобы потом через три года оно не было, не противоречило того, что они в первом году запланировали, это все равно сложно.
1525.52 1537.84 "Игорь Лабутин" Нет, если можно фичу, то есть тут скорее может быть вопрос в том, что если можно фичу безопасно и без проблем пилить три года параллельно с весьма живым мейнлайнером, мастером, то и ок.
1537.84 1541.88 "Игорь Лабутин" Просто я так понимаю, что далеко не всю фичу можно так пилить.
1541.88 1546.80 "Анатолий Кулаков" Да что-то я вот и не вспомню, чтобы они такую штуку делали, они все время по кускам выкладывают.
1546.80 1553.44 "Игорь Лабутин" Может и не получается, может росли настолько тяжел, что в смысле что ты и бейсить замучаешься?
1553.44 1555.80 "Анатолий Кулаков" Ну может быть, но что-то кажется, что вряд ли.
1555.80 1557.72 "Игорь Лабутин" Но опять же, надо понимать, что их там народу мало.
1557.72 1564.44 "Анатолий Кулаков" Может быть в этом смысле это как раз таки плюс, что они в голове могут держать примерно консистентную
1564.44 1568.56 "Игорь Лабутин" картину мира. Нет, не то что плюс, это их осознанное ограничение.
1568.56 1575.00 "Игорь Лабутин" То есть Джаред говорит, команда росли на больше чем 7-8 человек, скорее всего будет нежизнеспособна.
1575.00 1583.00 "Игорь Лабутин" Потому что сейчас мы действительно все более-менее помним, что где происходит, у нас есть какие-то области ответственности и так далее, но в целом все более-менее знают.
1583.00 1588.04 "Игорь Лабутин" И в команде 7-8 человек еще хоть как-то можно договориться голосом, ну грубо говоря.
1588.04 1589.04 "Игорь Лабутин" Ну именно так, да.
1589.04 1606.08 "Игорь Лабутин" А если нас там будет условно в два раза больше, то мы как бы будем тратить еще полтора раза больше времени на бюрократию, чтобы это все хоть как-то жило, потому что когда-то штука сложная, ну 20-летний, ну он поменьше, рослин не 20 лет, да, рослин как бы появился не в первом C#, но все-таки.
1606.08 1607.08 "Игорь Лабутин" Вот.
1607.08 1616.40 "Игорь Лабутин" Так что, ну в общем, видимо, какие-то свои трудности есть, плюс видимо они стараются приносить, ну типа если они что-то зафигачили, давайте это завелизим.
1616.40 1621.52 "Игорь Лабутин" Ну, как бы, есть плюсы и минусы в таком подходе, не знаю.
1621.52 1624.48 "Игорь Лабутин" Может что-то сделают длинное и большое сразу.
1624.48 1627.68 "Игорь Лабутин" Посмотрим, что будут делать Discriminated Unions и всем остальным.
1627.68 1634.00 "Анатолий Кулаков" Ну да, будем надеяться, что они там отдохнули за предыдущий релиз и дадут нам много интересного в этом.
1634.00 1635.00 "Анатолий Кулаков" Ждем первых анонсов.
1635.00 1641.72 "Игорь Лабутин" Да, ждем, я надеюсь уже к следующему выпуску у нас все-таки появится хоть какое-нибудь превью и можно будет что-нибудь почитать, посмотреть, что там происходит.
1641.72 1645.56 "Анатолий Кулаков" Отлично, погнали дальше.
1645.56 1650.64 "Анатолий Кулаков" У нас там еще завалялась статейчика про новый Infer, как раз он выходил вместе с новым фреймворком.
1650.64 1672.60 "Анатолий Кулаков" Я напомню, что Infer# это специальный инструмент для анализа вашего кода, он построен на движке Infer от Facebook, который по описанию имеет какие-то там мегавозможности, построен на сверхновой суперматематике и должен просто ошибки сам вам находить и скорее всего вместе с GPT еще их исправлять после этого.
1672.60 1678.44 "Анатолий Кулаков" Ну вот, что-то мы следим с ним, давно уже за ним следим и как-то он не то, чтобы совсем летит.
1678.44 1681.36 "Анатолий Кулаков" Но каждый релиз какие-то интересные фичи предоставляет.
1681.36 1687.92 "Анатолий Кулаков" И вот как раз один из таких мелких релизов, один из таких мелких фич у нас и появился.
1687.92 1692.80 "Анатолий Кулаков" Прежде всего нужно отметить, что в Infer# 1.4 у нас сделана отличная интеграция.
1692.80 1697.40 "Анатолий Кулаков" Теперь вы можете запустить его с помощью просто одного клика во всех значимых IDE.
1697.40 1701.80 "Анатолий Кулаков" Это под такими подразумевается Visual Studio 2022 и VS Code.
1701.80 1705.08 "Анатолий Кулаков" VS Code тоже прекрасно работает, кроссплатформенно, красиво.
1705.08 1711.48 "Анатолий Кулаков" А также, в принципе, так как это отдельный какой-то фреймворк, какие-то отдельные анализы, вы можете запустить вообще без IDE.
1711.48 1715.40 "Анатолий Кулаков" Например, напрямую из VSL или даже из Docker.
1715.40 1723.24 "Анатолий Кулаков" Я уже рассказывал про его некие возможности по отслеживанию тасков, про отслеживание переменных.
1723.24 1726.00 "Анатолий Кулаков" Можно, я думаю, посмотреть в наших предыдущих выпусках.
1726.00 1730.76 "Анатолий Кулаков" И напомню, что, например, он может отслеживать цепочку Disposables.
1730.76 1749.80 "Анатолий Кулаков" Если у вас где-то там на низком уровне создался какой-то стрим, который нужно бы по-хорошему задиспозить, и это все обернуто в несколько классов, и там какой-нибудь верхнеуровневый класс все-таки забыл задиспозить эту цепочку, то Infer# это все может найти, отследить, показать, подсветить и исправить эти ошибки.
1749.80 1764.08 "Анатолий Кулаков" И в последнем релизе они ввели еще один новый анализ, который помогает вам избавиться от проблем с непроверенным, недоверенным пользовательским водом откуда-нибудь из внешнего контура.
1764.08 1766.80 "Анатолий Кулаков" Типичным примером является SQL Injections.
1766.80 1776.56 "Анатолий Кулаков" Бывают такие люди, бывают такие программисты, которые просто берут пользовательский вод, который к ним пришел там в парамсах, в каких-нибудь контроллер аргументах из консольного input еще откуда-то.
1776.56 1782.68 "Анатолий Кулаков" Берут то, что пришло не пойми откуда, не пойми как, и вставляют это в сырой SQL запрос.
1782.68 1787.68 "Анатолий Кулаков" В VATRIBUTE или в SELECTATRIBUTE или еще откуда-то.
1787.68 1800.84 "Анатолий Кулаков" И к такому коду элементарно сделать SQL Injection и выполнить практически любую команду, то есть выдать dump всей таблицы, или удалить все таблицы, или заэкспортить все таблицы.
1800.84 1807.00 "Анатолий Кулаков" В общем штука довольно опасная, в дотнете она встречается реже, чем в каких-нибудь скриптовых языках, но все же есть.
1807.00 1818.64 "Анатолий Кулаков" И к этой же проблеме можно привести пример не такую популярную, не такую очевидную штуку, как небезопасная децентрализация.
1818.64 1827.16 "Анатолий Кулаков" Например, я думаю многие из вас помнят, это binary форматор, который мог децентрализовать любой бинарный блок, который приходил из сети.
1827.16 1830.96 "Анатолий Кулаков" Например, он очень часто используется в DubCF.
1830.96 1839.32 "Анатолий Кулаков" И по умолчанию binary форматор мог создавать любой класс, который в этом блобе был записан.
1839.32 1843.16 "Анатолий Кулаков" Можно было full name указать, и он этот класс мог создать.
1843.16 1851.84 "Анатолий Кулаков" А во фреймворке существуют специальные классы, которым при создании можно указать какие-нибудь куски кода, которые будут просто выполнены.
1851.84 1862.24 "Анатолий Кулаков" Таким образом мы получаем в нашем runtime своеобразную бомбу, в которую можно засунуть любой произвольный кусок кода по сети, если мы специально заформатируем binary форматором, и он может быть выполнен.
1862.24 1864.48 "Анатолий Кулаков" Тоже довольно опасная штука.
1864.48 1868.88 "Анатолий Кулаков" Ее много где находили во многих сериализаторах, но сейчас от нее вроде везде избавились.
1868.88 1878.92 "Анатолий Кулаков" Но так как прецедент, особенно если вы пользуетесь каким-нибудь собственным кастомным сериализатором, а не стандартным микрософтовским или каким-нибудь стандартным проверенным, то эта ошибка все еще может быть.
1878.92 1889.76 "Анатолий Кулаков" Вот и наконец наш инфер научился подобные проблемы находить и анализировать, и сообщать о них, репортовать.
1889.76 1892.64 "Анатолий Кулаков" Такая штука называется Tain Analysis.
1892.64 1899.72 "Анатолий Кулаков" На русский ее можно было перевести как анализ испорченности или анализ примесей, но к сожалению на русский ее перевели как Tain Analysis.
1899.72 1904.92 "Анатолий Кулаков" Я имею ввиду не только Microsoft, но и стандартные Security Tools, которые у нас уже есть для анализа.
1904.92 1906.92 "Анатолий Кулаков" Там она тоже обычно называется Tain Analysis.
1906.92 1926.56 "Анатолий Кулаков" И она как раз таки позволяет вам проверить, что если пользовательский ввод пришел к вам без всяких там эскейпов, без всяких проверок, без валидации, еще без чего-то, и вы напрямую суете ее в опасные скейт запросы, то сразу выдается такое сообщение, которое писательно вам говорит, что так делать не стоит.
1926.56 1934.44 "Анатолий Кулаков" И инфер он прекрасен тем, что подобные сообщения, ой, подобный анализ он может делать между несколькими сборками.
1934.44 1949.76 "Анатолий Кулаков" То есть он работает не по C# коду, он работает именно по ILU, поэтому может анализировать в том числе и сборки там Entity Framework, то есть понимать, что именно он лезет к базу, и SPNet понимать, что именно из SPNet пришел необработанный сырой пользовательский ввод.
1949.76 1955.08 "Анатолий Кулаков" То есть все это он может проанализировать, просмотреть, составить цепочку и выдать вам хороший анализ.
1955.08 1966.92 "Анатолий Кулаков" В общем, еще я нашел, что PVE Studio поддерживает эту штуку еще с 2021 года, уже писала статейки, уже находила какие-то проблемы и уже говорила, как у них все хорошо.
1966.92 1974.04 "Анатолий Кулаков" Вот поэтому мне кажется, что инфер как-то, слова вот, развивается, медленно развивается, не поспевает он за какими-нибудь лидерами рынка.
1974.04 1980.24 "Анатолий Кулаков" Ну, будем следить дальше, посмотрим, может что-то они нам все-таки выдадут какой-нибудь крутой интересный анализ, которого нигде ни у кого больше нет.
1980.24 1992.28 "Игорь Лабутин" Я таким не очень сильно пользовался, и честно говоря, ну, всякий статический анализ у меня, по-моему, дальше сонарку бас сильно не ушел, поэтому…
1992.28 1999.32 "Анатолий Кулаков" Видишь, больше уже не статический анализ идет, а тут уже анализ прямо flow идет, то есть исполняемого какого-то потока.
1999.32 2002.36 "Игорь Лабутин" Но подожди, он все равно это делает статически, он же не исполняет его.
2002.36 2019.48 "Анатолий Кулаков" Ну, как сказать, да, естественно, он делает это статически, но для того, чтобы тебе сделать вот этот control flow, тебе необходимо его, грубо говоря, заинтерпретировать, потому что ты же там интерпретируешь эти if-ы, for-its-и, без их интерпретации ты не поймешь, обработан он, например, пользовательский или нет.
2019.48 2023.60 "Анатолий Кулаков" И тебе нужно найти все вот эти ветки, в которых он не обработан, и пройти по ним.
2023.60 2028.04 "Анатолий Кулаков" То есть, по сути, всегда пишется какой-то интерпретатор или в нашем данном случае.
2028.04 2034.52 "Игорь Лабутин" Ну, да, хорошо, наверное, есть у этого какие-то пользователи.
2034.52 2041.16 "Игорь Лабутин" Интересно, если вы чем-то таким пользователь, поделитесь где-нибудь в комментариях, нам будет интересно узнать.
2041.16 2043.84 "Игорь Лабутин" Давай пойдем к каким-то более традиционным тулам.
2043.84 2051.44 "Игорь Лабутин" Пока мы отдыхали, Visual Studio не дремало и выпустила новую версию, новое превью.
2051.44 2057.56 "Игорь Лабутин" Это Visual Studio 2022.17.5 Preview 3, которое включает… Как-то у них уже цифры кончатся.
2057.56 2058.56 "Анатолий Кулаков" Да, ну слушай…
2058.56 2067.96 "Игорь Лабутин" 17.3 Preview Beta 2. Да, надо, конечно, точно помнить, что вы там ставите, ну в смысле, что вы хотите поставить и чем 17.5 отличается.
2067.96 2071.44 "Игорь Лабутин" Раньше был профиль, 19, и потом ждешь 3 года, пока выйдет 2022.
2071.44 2074.28 "Анатолий Кулаков" Ну да, там патчи сервис-паки только и все.
2074.28 2075.28 "Игорь Лабутин" Да и то редкие.
2075.28 2076.96 "Игорь Лабутин" Да и то редкие, да.
2076.96 2085.36 "Игорь Лабутин" Здесь, тем не менее, появилось некоторое количество интересных штук, и я ради некоторых даже подумал, что может быть обновлюсь на превью-версию.
2085.36 2086.36 "Игорь Лабутин" Посмотрим.
2086.36 2106.16 "Игорь Лабутин" Во-первых, появился accessibility checking, то есть, если вы разрабатываете UI-чик и пишете его на WPF, UVP, VimUI или MAUI, то теперь в тулбарке будет у вас новая кнопка, по нажатию на которой Visual Studio постарается подумать над вашей разметкой и сказать, где могут быть проблемы с accessibility.
2106.16 2112.92 "Игорь Лабутин" То есть, где у вас, может быть, там, скрин-ридер будет как-то неправильно читать или что-то в таком духе работать.
2112.92 2115.80 "Игорь Лабутин" То есть, если вы занимаетесь UI, может быть, это будет вам полезно.
2115.80 2122.64 "Игорь Лабутин" Если же вы занимаетесь просто обычным написанием кода, то следующая фича — это spell-checking — тоже может быть вам полезно.
2122.64 2140.80 "Игорь Лабутин" Studio теперь начало делать spell-checking, он пока еще превью, но если вы часто ошибаетесь, не знаю, в идентификаторах или в комментариях или внутри строчек на C#, C++ или в Markdown, то Studio теперь будет про это все предупреждать, говорить, вот, это слово невалидно.
2140.80 2158.92 "Игорь Лабутин" Причем по дефолту она знает, что поскольку C#, C++ в среднем пишутся на английском, то английский словарь включен всегда, плюс дополнительно будет включаться словарик UI вашей винды, плюс можно через Editor Config это все еще понастраивать, сказать, какого там уровня предупреждения выдавать и какие словари дополнительно включать.
2158.92 2163.52 "Анатолий Кулаков" Ну, полезная штука, да, решетка такая давно есть.
2163.52 2167.72 "Анатолий Кулаков" Сначала он был в виде плагина, потом они встроили стандартную поставку.
2167.72 2169.72 "Анатолий Кулаков" Помогает, я люблю этот spell-checking.
2169.72 2176.96 "Анатолий Кулаков" Потому что, действительно, когда торопишься, часто описываешься, даже не то, что в комментах, а даже в идентификаторах, в названиях методов.
2176.96 2196.96 "Игорь Лабутин" Да, и здесь, ну, понятно, что это было, наверное, подразумеваемо, но важно сказать, что если она находит какую-нибудь опечатку в имени переменной или еще где-то, то исправление — это полноценный рефакторинг, в смысле он переименует ее везде, где надо, во всех юзеджах, в других файлах и так далее, а не только в том месте, где вы нашли ее.
2196.96 2204.04 "Игорь Лабутин" Дальше они серьезно улучшили работу отладчика с external sources, внешними сурсами и decompiler.
2204.04 2214.12 "Игорь Лабутин" У них даже есть сравнительная гифка, что пока в предыдущей версии 17.4 декомпилит один файлик, 17.5 успевает 3-4 файлика декомпилить и поотлаживать.
2214.12 2222.52 "Игорь Лабутин" Так что если вы входите в сторонние какие-то сурсы или в декомпилятор, точно берите новую превьюшку, говорят, там очень хорошо стало в этом смысле.
2222.52 2226.08 "Анатолий Кулаков" У меня больше претензий у них не к скорости, а к качеству декомпилированного кода.
2226.08 2227.48 "Анатолий Кулаков" Вот лучше бы они там поработали.
2227.48 2231.32 "Анатолий Кулаков" Я согласен 2 секунды подождать лишних, лишь бы нормальный код выдали.
2231.32 2235.48 "Игорь Лабутин" Но с этим ничего сказать не могу, пока не сравнивал, не знаю.
2235.48 2240.32 "Игорь Лабутин" Но действительно, обычно, если мне нужно дебажить внешний код, я все-таки обычно иду в райдер.
2240.32 2242.32 "Игорь Лабутин" Он получше это делает.
2242.32 2244.20 "Игорь Лабутин" И главное, более предсказуемо.
2244.20 2247.64 "Игорь Лабутин" В точке студии можно иногда сказать, что не смогла.
2247.64 2250.60 "Игорь Лабутин" Райдер вроде обычно такого не делает, обычно всегда декомпилит.
2250.60 2257.56 "Игорь Лабутин" Дальше они завезли новые саджешины, которые называются intent-based.
2257.56 2268.68 "Игорь Лабутин" И это очень такие умные саджешины, которые будут в инлайне появляться на основании того, о чем подумал за вас AI.
2268.68 2269.68 "Игорь Лабутин" Искусственный интеллект, короче.
2269.68 2272.60 "Игорь Лабутин" GPT уже встроили?
2272.60 2277.76 "Игорь Лабутин" Ну там не GPT и даже не Copilot.
2277.76 2287.52 "Игорь Лабутин" Там что-то их собственное, которое будет предлагать, как-то думая над вашим кодом, какие-то именно саджешины с точки зрения редактирования кода.
2287.52 2289.32 "Игорь Лабутин" Не знаю пока, что это будет.
2289.32 2292.68 "Игорь Лабутин" Там есть какая-то одинокая гифка, по-моему, или даже скриншотик того, как это выглядит.
2292.68 2294.56 "Игорь Лабутин" Пока я в действии этого нигде не видел.
2294.56 2298.64 "Анатолий Кулаков" Не, ну у меня в текущей студии уже такие саджешины есть, которые предыдущие.
2298.64 2301.52 "Анатолий Кулаков" Не сказать, что они мега умные, но прикольные, полезненькие.
2301.52 2308.84 "Игорь Лабутин" Ну вот улучшат, видимо, там, добавят интеллекта или искусственности, я уже не знаю, что они будут добавлять.
2308.84 2309.84 "Игорь Лабутин" Посмотрим.
2309.84 2314.52 "Игорь Лабутин" Улучшили перформанс Рейзора и Рослина.
2314.52 2324.56 "Игорь Лабутин" То есть он там чуть побыстрее собирает, чуть побыстрее, ну и то и то собирает по сути, да, Рейзор, компилятор, который вьюшки конвертит, во что он там их конвертит.
2324.56 2326.08 "Игорь Лабутин" В общем, будет собираться побыстрее.
2326.08 2343.16 "Игорь Лабутин" И кроме того, сделали более быстрые инкрементальные билды за счет того, что студия теперь понимает, в каких случаях, скажем так, можно поменьше копировать файлики, грубо говоря, при пересборке цепочки зависимых проектов.
2343.16 2363.00 "Игорь Лабутин" Она будет делать следующую штуку, если у вас там какая-то очень глубокая зависимость и вы пересобрали внутреннюю зависимость, то она сразу скопируется во все нужные таргеты всех тех проектов, которые зависят от этой внутренней зависимости, чтобы поменьше копироваться.
2363.00 2364.00 "Игорь Лабутин" Говорят, ускоряет.
2364.00 2371.24 "Игорь Лабутин" Но, видимо, опция настолько пока передавая, что включать ее надо прямо отдельно в project файле, отдельной опцией.
2371.24 2373.80 "Игорь Лабутин" Называется Accelerate Builds in Visual Studio внезапно.
2373.80 2376.60 "Игорь Лабутин" В CES Project такое напишешь и станет быстрее.
2376.60 2382.28 "Игорь Лабутин" Почему не включили по дефолту, не знаю, видимо, либо что-то работает иногда не так, либо все-таки это превью, поэтому пока экспериментируют.
2382.28 2390.96 "Анатолий Кулаков" Интересно, что именно от файла зависит, то есть непеременное окружение не в options студии ставишь, а это как глобально, а именно для конкретного проекта?
2390.96 2405.40 "Игорь Лабутин" Возможно, она себя плохо ведет, например, если у тебя какие-нибудь кастомные постбилд стыпы, с неправильно особенно расписанными, знаешь, in-out, которые не поддерживают инкрементальные билды, и там что-нибудь будет ломаться, и тогда можно, ну именно поэтому для таких проектов ты включать не будешь.
2405.40 2407.72 "Игорь Лабутин" Ну да, да, типичный случай.
2407.72 2416.48 "Игорь Лабутин" Ну, лучше, конечно, писать правильно постбилды, чтобы они правильно работали с инкрементальными билдами, но, наверное, бывают такие унаследованные проекты или что-то.
2416.48 2421.12 "Игорь Лабутин" Хотя, с другой стороны, вряд ли вы будете работать с какими-нибудь мегаунаследованными проектами в превью версии студии.
2421.12 2422.12 "Игорь Лабутин" Непонятно, не знаю.
2422.12 2429.32 "Игорь Лабутин" Ну, в общем, вот, пока примерно то, что зарелизилось в студии, ждем дальше на следующих превьюшках.
2429.32 2434.20 "Анатолий Кулаков" Ну да, хороший набор мелочей, опять же, без каких-то прорывных мегаидей.
2434.20 2436.80 "Анатолий Кулаков" Мне кажется, в студии их никогда и не было.
2436.80 2441.36 "Анатолий Кулаков" Они постепенно улучшаются, постепенно вводят что-то новое, поддерживают уже существующие фреймворки.
2441.36 2442.36 "Анатолий Кулаков" В принципе, туда и идем.
2442.36 2443.36 None Давай дальше.
2443.36 2446.36 "Анатолий Кулаков" Так, а что у нас дальше, интересно.
2446.36 2451.20 "Анатолий Кулаков" У нас дальше есть еще такие же улучшения в другом интересном редакторе, в райдере.
2451.20 2452.20 "Игорь Лабутин" Да.
2452.20 2453.56 "Игорь Лабутин" Ну, пока не улучшения, пока род мапы.
2453.56 2468.08 "Игорь Лабутин" Понятно, что там уже потихонечку начинаются ябы, но райдер и решарпер объявили свой род мап на следующий год, в смысле на этот год, и они довольно похожи, но тем не менее отличаются при этом.
2468.08 2469.84 "Игорь Лабутин" То есть, по решарпере планы следующие.
2469.84 2486.56 "Игорь Лабутин" Во-первых, они собираются довольно сильно переработать работу с шорткатами, потому что там есть некоторый инпут от пользователей на тему того, что неудобно, как их там, как они мапятся иногда не очень, как они переносятся, переключаются не очень, в общем, будут работать над шорткатами.
2486.56 2498.60 "Игорь Лабутин" Продолжат работать над миграцией из процесса Visual Studio, и там есть даже отдельная большая статья, она у нас будет в шоу-ноутах, если вы хотите почитать, что там сейчас происходит.
2498.60 2517.28 "Игорь Лабутин" Основная мысль там в том, что решарпер отказывается, ну, точнее, не отказывается, но довольно сильно пересматривает свою корневую концепцию, что внутренняя модель кода точно соответствует коду, потому что все изменения там вносятся под правильными райдлоками синхронно, вместе с тем, как вы тайпите.
2517.28 2545.72 "Игорь Лабутин" Но это все задерживает, понятно, тайпинг, а если решарпер живет вообще в отдельном процессе, то понятно, что тайпинг, с учетом того, что нужно сходить в соседний процесс и там получить райдлок, изменить модель и все такое, может технически немножко замедляться в некоторых случаях, поэтому решарпер потихонечку пытается перевестись на асинхронное, так сказать, тайпинг асинхронный, ввод, точнее, на асинхронную реакцию на ввод.
2545.72 2556.84 "Игорь Лабутин" Сейчас это есть только в виде прототипа пока, но команда будет работать дальше, так что ждем новостей на тему, когда решарпер станет полноценным out-of-process.
2556.84 2580.48 "Игорь Лабутин" Мы поговорили как раз, вот ты недавно сказал, что в решарпере в райдере есть этот сполчекинг, и в roadmap у них есть планы по замене встроенного чекера на внешний, точнее на плагин по сути, который называется JetBrains грация, который он же будет в райдере, как я понимаю, проверять там спеллинг, грамматику и так далее.
2580.48 2589.52 "Игорь Лабутин" Я так понимаю, что это внешний плагин над каким-то более умным движком, поэтому это сделано вот таким вот внешней штукой, и вот он будет проще, может быть,
2589.52 2600.60 "Анатолий Кулаков" обновлять, например. История идет по спирали, но кажется, что это наоборот, они сейчас используют словари от OpenOffice, а судя по названию, это JetBrains грация, это, наверное, какая-то собственная разработка.
2600.60 2603.20 "Анатолий Кулаков" Они, наверное, уходят от стороннего плагина на свой
2603.20 2610.32 "Игорь Лабутин" движок. Это собственный плагин, но движок, там сказано, что они откуда-то берут вроде, или словари откуда-то берут.
2610.32 2611.32 "Игорь Лабутин" А зачем вы его назвали тогда JetBrains?
2611.32 2612.32 "Игорь Лабутин" Некрасиво.
2612.32 2618.88 "Игорь Лабутин" Не знаю, не знаю, не изучал настолько детально, посмотрел, что просто это плагин, и там написано, что типа Base.donut что-то там.
2618.88 2624.16 "Игорь Лабутин" То есть это явно не полностью самописная штука, это на чем-то она все-таки основана.
2624.16 2628.04 "Игорь Лабутин" Ну, вряд ли JetBrains полностью свой словарь будет составлять, вроде не их работа.
2628.04 2632.48 "Анатолий Кулаков" Нет, ну словарь-то нет, там склонение, словоформы и преобразование.
2632.48 2635.88 "Игорь Лабутин" Это может быть, кстати, оно само работает, ну в смысле, это может быть их код.
2635.88 2639.64 "Игорь Лабутин" Я детально не изучал, что там кто писал, и на сколько они что позаимствовали.
2639.64 2647.80 "Анатолий Кулаков" Ну да, потому что OpenDict и словари довольно тупые, там они еще склонять, по-моему, какие-то простые вещи может, а какие-то вещи, которые он не знает, он склонять не умеет.
2647.80 2649.48 "Анатолий Кулаков" То есть там все довольно чопорно.
2649.48 2655.84 "Анатолий Кулаков" И может, если они это починят, будет вполне хорошо, особенно для русского языка, для русских комментариев, для русского аутбота.
2655.84 2656.84 "Игорь Лабутин" Ну да.
2656.84 2672.68 "Игорь Лабутин" Дальше в ReSharper теоретически может появиться диалог создания юнит-тестов, то есть можно будет раз кликнуть на класс, сказать создай мне для этого класса юнит-тест, помаркать методы, которые юнит-тестить, и он там, выбрать фреймворк, и он создаст рыбу для юнит-теста, размеченную атрибутами, правильно и так далее.
2672.68 2675.36 "Игорь Лабутин" Давно просили, говорят, но что-то все не делали.
2675.36 2676.36 "Игорь Лабутин" Локализация.
2676.36 2678.48 "Игорь Лабутин" В ReSharper появится локализация.
2678.48 2690.36 "Игорь Лабутин" Первоначальная цель — перевести ReSharper на корейско-китайско-японский, то есть все эти азиатские языки, но потом, возможно, появятся и какие-то более приближенные к нам.
2690.36 2699.76 "Игорь Лабутин" Переделают немножко UX/UI, хотя в ReSharper особо UX/UI это сильно нет, но всякие вот эти окошки юнит-тестов, видимо, раннеры и прочие такие.
2699.76 2703.48 "Игорь Лабутин" Окна рефакторингов, видимо, будут немножко редизайниться.
2703.48 2707.96 "Игорь Лабутин" Возможно по стопам того, что сделали в райдере с точки зрения UI.
2707.96 2721.08 "Игорь Лабутин" И основной фокус с точки зрения работы с кодом, с какими-то новыми диагностиками и так далее будет нацелен на веб-девелопмент, то есть SPNet, EF Core, вот это все.
2721.08 2724.88 "Игорь Лабутин" Довольно много будет сил вложено в эту часть.
2724.88 2730.84 "Игорь Лабутин" В райдере, соответственно, будет что-то похоже, но тем не менее будет многое отличаться.
2730.84 2745.04 "Игорь Лабутин" Во-первых, в райдере ведется большая работа над нормальной синхронизацией сеттингов, чтобы если вы пользуетесь райдером на куче разных машинок, то вы могли, грубо говоря, более-менее автоматически, без необходимости там ручного экспорта-импорта синхронизировать все свои сеттинги.
2745.04 2747.64 "Игорь Лабутин" Ну, которые можно, понятно, синхронизировать, кроме там локальных путей каких-нибудь.
2747.64 2751.84 "Игорь Лабутин" Shortcut и вот это все, чтобы везде был одинаковый экспириенс.
2751.84 2760.64 "Игорь Лабутин" Улучшат работу с докером, добавят новую возможность сравнивать схемы баз данных прямо в райдере.
2760.64 2764.44 "Игорь Лабутин" Улучшат геймдев, но я геймдевом не занимаюсь, ничего особо рассказать не могу.
2764.44 2766.76 "Игорь Лабутин" Тот самый граммер-чекинг такой же будет.
2766.76 2768.68 "Игорь Лабутин" Перформанс в очередной раз улучшат.
2768.68 2773.40 "Игорь Лабутин" UI-чик еще раз чуть-чуть пересмотрят на основании фидбэка после того, как выкатили новый.
2773.40 2778.56 "Игорь Лабутин" Ну и ту самую локализацию на японско-китайско-корейский тоже будут пилить.
2778.56 2782.76 "Игорь Лабутин" Вот примерно такие планы на райдер Sharper на этот год.
2782.76 2791.36 "Игорь Лабутин" И по-моему, кстати, у Sharper, если не ошибаюсь, уже же вышел YAP, что-то я где-то видел в новостях, но тут точно не скажу.
2791.36 2792.36 "Игорь Лабутин" Может, у райдера.
2792.36 2793.36 "Игорь Лабутин" Но у кого-то, по-моему, вышел.
2793.36 2796.36 "Игорь Лабутин" Можно уже пробовать что-то.
2796.36 2797.44 "Анатолий Кулаков" Прекрасно.
2797.44 2798.44 "Анатолий Кулаков" Поехали дальше.
2798.44 2803.88 "Анатолий Кулаков" Следующая статейка про обнаружение breaking changes между двумя различными версиями.
2803.88 2807.08 "Анатолий Кулаков" И самое прекрасное, что все это делается на уровне Nuget.
2807.08 2820.96 "Анатолий Кулаков" В общем, в мире давно уже была такая потребность для того, чтобы сравнить какие-то две версии вашего приложения и сказать, что в них изменилось, что не изменилось с точки зрения публичного API.
2820.96 2827.92 "Анатолий Кулаков" Именно API, который не REST API, а API именно C# классиков, .NET классиков и вот этого всего.
2827.92 2839.44 "Анатолий Кулаков" Существовало очень много инструментов, которые пытались реализовать с той или иной мерой успешности эту функциональность и в принципе тем, кому нужно было, этим пользовались.
2839.44 2846.96 "Анатолий Кулаков" И вот, начиная с шестого .NET, предоставляется такая новая фича, которая называется Package Validation.
2846.96 2853.64 "Анатолий Кулаков" И как несложно догадаться, она валидирует пакеты.
2853.64 2858.28 "Анатолий Кулаков" Валидирует пакеты в момент выполнения команды .NET Pack.
2858.28 2866.40 "Анатолий Кулаков" Эта штука не включена по умолчанию, потому что, естественно, не всем это нужно и даже, наверное, по умолчанию большинству это не нужно.
2866.40 2878.64 "Анатолий Кулаков" Но если вы хотите ее разрешить, то в своем CSS-файле вы можете указать парочку элементов, например, Enable Package Validation в True выставить и выбрать одну из стратегий.
2878.64 2882.52 "Анатолий Кулаков" Например, самая популярная это Package Validation Baseline Version.
2882.52 2890.96 "Анатолий Кулаков" Вы в этом последнем атрибуте указываете версию того пакета, с которым вы будете сравнивать текущую упакуемую.
2890.96 2897.80 "Анатолий Кулаков" Вот эта версия Baseline должна быть доступна в Nuget по определенной ссылочке, ну или там можно их поменять, но по умолчанию в Nuget.
2897.80 2912.56 "Анатолий Кулаков" И в тот момент, когда выполняется команда .NET Pack, берется эта версия из Nuget, из фида, берется пакеты, которые получились в результате упаковки и сравнивается у них публичный API.
2912.56 2920.72 "Анатолий Кулаков" Если вдруг он не совпадает, не совпадает в плане breaking changes, то есть если там есть breaking changes, то происходит сообщение об ошибке.
2920.72 2926.72 "Анатолий Кулаков" И это довольно интересно и довольно полезно на практике кейса.
2926.72 2938.80 "Анатолий Кулаков" Естественно, вы можете сделать suppression file, если вдруг вы понимаете, что это breaking change, на который вы рассчитывали, который вы знаете, который вы понимаете и сообщили пользователям, то естественно его можно подавить и пойти дальше работать.
2938.80 2949.80 "Анатолий Кулаков" Но если вдруг это какой-то change, на который вы не рассчитывали, который был допущен случайно или по неосмотрительности или по вине разработчика, то на этом этапе вы легко можете его поймать.
2949.80 2954.52 "Анатолий Кулаков" Тоже полезная штука, кстати, из примеров breaking changes.
2954.52 2963.00 "Анатолий Кулаков" Например, если у вас был какой-то публичный класс и вы этому классу добавили sealed, то есть сказали, что больше от него нельзя наследоваться, это пример нормального breaking changes.
2963.00 2968.48 "Анатолий Кулаков" Потому что какие-то другие приложения могли от этого класса в этот момент наследоваться.
2968.48 2974.12 "Анатолий Кулаков" И в тот момент, когда они поставят новый пакет, у них весь код упадет и перестанет правильно работать.
2974.12 2976.16 "Анатолий Кулаков" Это хороший пример.
2976.16 2982.84 "Анатолий Кулаков" Или вот другой забавный пример, это когда вы, например, добавляете условные параметры, option parameters.
2982.84 2991.64 "Анатолий Кулаков" То есть когда у вас метод принимал один аргумент, а потом вы написали ему через запятую второй аргумент и дали ему по умолчанию какое-то значение, там 2, 10, 40, 2, 15.
2991.64 2995.64 "Анатолий Кулаков" Игорь, как ты думаешь, это будет breaking changes или нет?
2995.64 2998.28 "Игорь Лабутин" Так, мы поменяли.
2998.28 3000.92 "Игорь Лабутин" Мы, по сути, расширили.
3000.92 3007.92 "Анатолий Кулаков" То есть у нас был метод раньше с одним параметром, а потом мы сделали ему option parameter второй с указанием дефолта.
3007.92 3010.64 "Анатолий Кулаков" То есть у нас теперь можно вызвать его с одним, а можно с двумя вызвать.
3010.64 3013.52 "Анатолий Кулаков" То есть теоретически мы его расширили.
3013.52 3016.76 "Анатолий Кулаков" Считается ли это breaking changes или все-таки это расширение?
3016.76 3031.48 "Игорь Лабутин" Ну смотри, там же есть эти разные, по идее мы добавили, то есть компилятор скомпилит, а в runtime у нас же значения подставляются в месте вызова, то есть так оно сломается.
3031.48 3035.32 "Игорь Лабутин" И даже если мы просто поменяем значение это дефолтное, то тоже же сломается все.
3035.32 3037.32 "Анатолий Кулаков" Да, если мы поменяем.
3037.32 3044.56 "Анатолий Кулаков" То есть смысл в том, что действительно option parameter они подставляются в момент компиляции, то есть по сути мы сделали breaking change.
3044.56 3057.24 "Анатолий Кулаков" То есть если на уровне source breaking changes, то это не изменение, не ломающее изменение, потому что любая библиотека, которая подключит вашу новую библиотеку, она скомпилируется и будет работать правильно.
3057.24 3063.60 "Анатолий Кулаков" А вот на уровне binary, binary breaking, то на уровне binary это реально breaking changes.
3063.60 3066.40 "Анатолий Кулаков" И соответственно компилятор это тоже выловит.
3066.40 3072.92 "Анатолий Кулаков" В общем это отдельная интересная тема, чтобы в глубь не уходить, у меня там в backlog давно лежит статья, что является breaking, а что не breaking changes.
3072.92 3077.24 "Анатолий Кулаков" И там довольно неочевидные ответы на некоторые поведения.
3077.24 3083.44 "Анатолий Кулаков" Я думаю мы ее в ближайшее время рассмотрим, тем более что появился такой замечательный тул прямо от Microsoft.
3083.44 3087.72 "Анатолий Кулаков" И про режимы проверки.
3087.72 3098.92 "Анатолий Кулаков" Я уже сказал, что baseline version это самый основной режим проверки, типа сравнивать с какой-то версией, которая уже у нас есть в NuGet feed, сравнивать текущую.
3098.92 3113.68 "Анатолий Кулаков" В общем также можно выбрать сравнение рантаймов, то есть NuGet SDK подтверждает, что те рантайм специфические библиотеки, которые вы запаковали в пакет, они совместимы в compile-time с определенными другими сборками.
3113.68 3129.24 "Анатолий Кулаков" И также есть compatible в совместимости по фреймворкам, то есть проверяется совместимость между фреймворками, что все библиотеки в условиях multi-targeting, multi-target package, они тоже совместимы друг с другом.
3129.24 3136.24 "Анатолий Кулаков" Такие алгоритмы, такие стратегии тоже есть, но мне кажется, что совместимость по версиям как раз-таки самая полезная и может быть кому-то пригодится.
3137.24 3138.24 "Игорь Лабутин" Ну, прекрасно.
3138.24 3142.88 "Игорь Лабутин" Так что на самом деле я бы сказал...
3142.88 3148.48 "Игорь Лабутин" Интересно, было бы полезно такую штуку использовать даже в какой-нибудь внутренней разработке?
3148.48 3153.12 "Игорь Лабутин" То есть для публичных NuGet пакетов это прям понятно, почему может быть нужно.
3153.12 3154.96 "Игорь Лабутин" Это must have, по-моему, да?
3154.96 3155.96 "Игорь Лабутин" Да.
3155.96 3163.48 "Игорь Лабутин" Прикидываю, вот для внутренней разработки пилим какую-нибудь общую функциональность в своем отдельном NuGet пакете, который никто кроме нас самих же не видит.
3163.48 3165.28 "Игорь Лабутин" Нужно будет, интересно, такое или нет?
3165.28 3166.28 "Игорь Лабутин" Так задумался.
3166.28 3186.28 "Анатолий Кулаков" Мне кажется, что у нас, например, есть пример между командами, и вот когда у тебя там команда готовится, целый спринт готовилась к какому-то важному ревью, к важному релизу и все такое, и тут ты внезапно заливаешь библиотечку, у которой поменялась там минорная версия, и она тебе делает breaking change, и все у тебя ломается, это тоже ситуация немножко нехорошая, неправильная.
3186.28 3193.36 "Анатолий Кулаков" То есть даже в пределах одной кампании, если мы договоримся о семантике к Вержени, то эта штука вполне рабочая, она вполне подходит.
3193.36 3205.56 "Игорь Лабутин" Да, я даже думаю, что твой пример валидный, еще, может быть, интересно даже не столько детектить breaking change, а именно их прямо документировать.
3205.56 3228.16 "Игорь Лабутин" То есть может быть мне и ок, что я там что-то ломаю, и все мои соседи в среднем знают, ну или мы договорились, да, команды в целом знают, что что-то там ломали, но чтобы еще не вручную писать эти описания, прямо самому в nugget-пакет при сборке, генерила бы вот этот nugget-пакет версии такой-то, по сравнению с предыдущим, в нем сломано двоеточие.
3228.16 3229.16 "Игорь Лабутин" Это, это, это, это.
3229.16 3231.16 "Игорь Лабутин" Ну, в смысле breaking change в нем.
3231.16 3232.16 None Такой, такой, такой, такой.
3232.16 3245.80 "Игорь Лабутин" Мне кажется, вот для внутренней разработки это было бы даже, может быть, более популярно, чтобы ты точно шел там в фит и смотрел, ага, если я обновлю свой продукт, свой сервис на следующую версию этой библиотеки, мне нужно будет там то-то, то-то, то-то.
3245.80 3248.60 "Игорь Лабутин" Ну, чтобы планировать, сколько займет времени обновления,
3248.60 3251.04 "Анатолий Кулаков" знаешь. Ну да, может быть, тоже полезно.
3251.04 3256.64 "Анатолий Кулаков" Мне кажется, так как там есть стандартный SDK-репорт, там error-репорт, наверное, можно ее как-то вытащить.
3256.64 3258.76 "Анатолий Кулаков" Плюс не забывай, что у нас есть suppression file.
3258.76 3265.20 "Анатолий Кулаков" То есть, если ты пошел и сказал, да, эти breaking changes я одобряю, ты их обязан занести в suppression file.
3265.20 3268.40 "Анатолий Кулаков" И по сути, у тебя suppression file, это и есть вот эта история всех твоих breaking changes.
3268.40 3272.36 "Игорь Лабутин" А, ну, заодно можешь из suppression файла редмишку сгенерить, обновить.
3272.36 3273.36 "Игорь Лабутин" Да, да, примерно так.
3273.36 3275.36 "Игорь Лабутин" Да, кстати, можно так сделать.
3275.36 3276.36 "Игорь Лабутин" Ладно, хорошо.
3276.36 3277.36 "Игорь Лабутин" Давай пойдем дальше.
3277.36 3287.64 "Игорь Лабутин" Дальше тоже статья из довольно наших стареньких, ну, то есть, не статья, а новость про штуку под названием database command batching в шестом дотнете.
3287.64 3295.56 "Игорь Лабутин" И я что-то прямо ее пропустил, хотя с базами данных я работаю, и не задумывался о том, что эта штука мне нужна.
3295.56 3296.56 "Игорь Лабутин" Да, смотрите, о чем речь.
3296.56 3309.64 "Игорь Лабутин" А donet, ну, в виде там adonet, а system.dat и вот этого всего у нас в дотнете очень давно и является таким, ну, понятно, абсолютно универсальным интерфейсом практически ко всем базам данных.
3309.64 3321.64 "Игорь Лабутин" То есть там достаточно высокий уровень абстракции и сколь команд, да, точнее даже сколь команд, db команд, я уже так, сколь серверную часть говорю, db command, db connection, вот это все.
3321.64 3332.04 "Игорь Лабутин" И как выяснилось, и я что-то действительно не замечал этого, не осознавал точнее полноценно для себя раньше, что там нету фичи под названием batching.
3332.04 3338.12 "Игорь Лабутин" То есть вы не можете послать одновременно несколько стейтментов в одном, так сказать, раунд трипе к базе.
3338.12 3343.04 "Игорь Лабутин" В принципе, технически, такая штука работает на сколь сервере.
3343.04 3349.72 "Игорь Лабутин" Вы могли туда закидать несколько команд, разделенных в две точки, ой, точка с запятой, и послать это как одну сколь команду.
3349.72 3354.84 "Игорь Лабутин" Но как-то это работает не очень здорово и на самом деле не все базы данных такое поддерживают.
3354.84 3380.40 "Игорь Лабутин" Есть некоторые, скажем так, драйвера-орм, да, которые пытаются это поддержать, но там возникает проблема, что, ну например, позгревый мог бы делать такую же штуку, бежим, делим по точкам с запятой и посылаем каждую командочку как отдельную команду, а пользователю это кажется как будто послали все целиком.
3380.40 3391.60 "Игорь Лабутин" Но проблема в том, что сделать сплит этой сколь команды по точке с запятой, это прям сложно, потому что точка с запятой у нас встречается внутри строки, и в общем нужно писать почти полноценный скольный парсер, что не очень хочется.
3391.60 3402.76 "Игорь Лабутин" И даже в сколь сервере на самом деле, который это поддерживает, делать можно далеко не все, вы там не можете сделать вызов нескольких хранимых процедур, там много чего нельзя делать.
3402.76 3409.52 "Игорь Лабутин" И поэтому в шестом .NET было добавлена прям концепция в ADUNET под названием нового класса, названием DBBatch.
3409.52 3413.76 "Игорь Лабутин" И смысл этого класса в том, чтобы заслать несколько команд в базу данных.
3413.76 3429.60 "Игорь Лабутин" Причем там можно замиксовать всякие инсерты, апдейты, селекты подряд, и при этом эта штука выполнится, и в ответе у вас будет возможность взять и посмотреть результаты каждой из этих команд независимо.
3429.60 3446.48 "Игорь Лабутин" То есть кто чего вернул, сколько, соответственно, записей зафиксировала та или иная команда, можно будет посмотреть независимо от того, какие там это были команды, и в том же количестве, в котором вы послали этих команд в базу.
3446.48 3454.44 "Игорь Лабутин" Можно использовать эту штуку нативно, ну в смысле прям напрямую, создать батч из connection, там метод есть соответствующий.
3454.44 3458.04 "Анатолий Кулаков" Леша, а правильно я понимаю, что это драйвер должен такую штуку поддерживать?
3458.04 3459.48 "Анатолий Кулаков" Она же магическим образом не заработает.
3459.48 3464.12 "Игорь Лабутин" Драйвер, да, должен поддерживать, конечно.
3464.12 3465.12 "Игорь Лабутин" Вот.
3465.12 3468.92 "Игорь Лабутин" Драйвер, сейчас я к этому дойду, кстати, да.
3468.92 3478.28 "Игорь Лабутин" Можно использовать напрямую, как я и говорю, можно, в принципе, ORM технически тоже можно это делать, идти к какой-нибудь EFCore, можно понимать, ага, мне вот тут выгодно послать две команды, два селекта.
3478.28 3488.72 "Игорь Лабутин" Раньше она была вынуждена делать db, создать сколь команду, сказать execute, потом снова создать сколь команду и снова сказать execute, теперь можно послать db_batch сразу, целиком.
3488.72 3495.52 "Игорь Лабутин" И лучше всего с этим работает сейчас Postgresовный драйвер, который NPG SQL.
3495.52 3502.84 "Игорь Лабутин" MySQL тоже неплохо работает драйвер, а вот SQL Server, соответственно, драйвер не поддерживает пока эту штуку.
3502.84 3508.72 "Игорь Лабутин" Ну он как бы и так типа работал с этими точками, через точки с запятой, но не дошли еще руки обновить его под этот новый db_batch.
3508.72 3517.88 "Анатолий Кулаков" Те базы, которые официально не будут поддерживать, не знаю, какой-нибудь SQLite, они что будут делать, не будут эмулироваться или падать?
3517.88 3520.04 "Анатолий Кулаков" Ну что значит не поддерживать?
3520.04 3524.64 "Анатолий Кулаков" Ну то, что они, если ты им зашлешь несколько команд, они их не смогут распарсить.
3524.64 3539.68 "Игорь Лабутин" Нет, подожди, подожди, у тебя в db_batch, по сути, лежит коллекция db_command, грубо говоря, там не совсем db_command, там другой немножко классик используется, но смысл такой, тебе никто не мешает их выполнить просто в 5 раунд-трипов, например, если у тебя 5 команд.
3539.68 3543.16 "Анатолий Кулаков" Ну да, я про это говорю, что они будут эмулироваться, то есть все-таки выполняться по одной.
3543.16 3552.44 "Игорь Лабутин" Да, да, да, они будут выполняться, никто там ничего не скажет, что он запортит, насколько я понимаю, ну из того, что по крайней мере я видел, но вот такая штука.
3552.44 3569.24 "Игорь Лабутин" Ну я так понимаю, что основные базы все обновятся, я думаю, что если ты работаешь, грубо говоря, с базой, в которой ты знаешь, что это поддержано, и, наверное, ты шлешь несколько команд не зря, и ты знаешь, зачем ты это делаешь, поэтому, наверное, все-таки там не будет такого, что типа ой, а мы работаем то на базе, которая поддерживает, то на базе, которая не поддерживает.
3569.24 3570.96 "Игорь Лабутин" Такое все-таки редко, мне кажется, встречается.
3570.96 3578.24 "Анатолий Кулаков" Ну для этого нам абстракция в виде ORM-ов и аддонетов и дана, чтобы мы не задумывались о том, какая база лежит под
3578.24 3582.80 "Игорь Лабутин" нами. Все так, но с другой стороны базы данных меняются не слишком часто в приложениях.
3582.80 3599.84 "Игорь Лабутин" Я, пожалуй, могу придумать кейс, что вот мы не знаем, на какой базе будем работать, когда мы базу используем как что-то очень простое, и я не знаю, там в дисклодном приложении ты говоришь, вот мне нужна какая-нибудь база, могу Postgres, могу Oracle, могу SQLite, что угодно, лишь бы табличка до селектора поддерживала.
3599.84 3604.16 "Игорь Лабутин" И там пользователь что-нибудь выберет, типа хочу вот с таким работать.
3604.16 3610.88 "Игорь Лабутин" Мне встречались такие тулы, которые говорили, да мне любая лицензия подойдет, типа хоть какую-нибудь, дайте connection string, напишите, я буду работать.
3610.88 3614.60 "Игорь Лабутин" Но с другой стороны, не знаю, нужны ли там банчи тогда.
3614.60 3615.60 "Игорь Лабутин" Непонятно.
3615.60 3625.64 "Игорь Лабутин" Ну, в общем, фича действительно, наверное, кому-то полезна, мне кажется, полезна для оптимизации, я как-то прошел мимо нее, и поэтому вот решил добавить, включить и рассказать.
3625.64 3629.60 "Анатолий Кулаков" Ну да, да, фича безусловно полезная, мне кажется, пригодится многим.
3629.60 3640.60 "Анатолий Кулаков" Слушай, другая интересная фича, которая у нас еще всплывала в радиочатике, это то, каким образом можно отследить все HTTP-запросы, которые происходят в вашем приложении.
3640.60 3644.68 "Анатолий Кулаков" И вот как раз вышла интересная статичка, хотелось о ней вам тоже немножко рассказать.
3644.68 3653.16 "Анатолий Кулаков" Итак, перед автором действительно стала задача, это отследить все HTTP-реквесты в полноценном .NET-приложении.
3653.16 3659.04 "Анатолий Кулаков" Напомню, что в принципе .NET-приложение поддерживает множество способов, как можно отправить HTTP-реквест.
3659.04 3664.20 "Анатолий Кулаков" Прежде всего, самый популярный и самый правильный – это через использование HTTP-клайента.
3664.20 3671.04 "Анатолий Кулаков" Есть еще устаревшие способы, как HTTP-вебреквест и WebClient класс.
3671.04 3672.72 "Анатолий Кулаков" В общем, через него тоже встречаются.
3672.72 3687.72 "Анатолий Кулаков" Если в принципе вы имеете доступ к этим классам, то, наверное, вы как-то можете их промодифицировать, добавить им какого-нибудь хендлера, добавить им какой-нибудь Invoke middleware и прочие какие-нибудь реквест-хендлеры для того, чтобы залогировать ваш запрос.
3687.72 3699.32 "Анатолий Кулаков" Но если вы уже сталкиваетесь с какой-то внешней библиотекой, которую вы к себе подключили и которая внутри себя сама создает HTTP-клайент, и вы никак не можете к нему доступиться, то здесь у вас в принципе могут быть проблемы.
3699.32 3709.68 "Анатолий Кулаков" И автор задался целью решить эту задачу для любой библиотеки, откуда она подключилась, несмотря на то, какой класс они используют, какие у нее реквест-хендлеры.
3709.68 3717.52 "Анатолий Кулаков" Он хочет логировать или по крайней мере узнавать все HTTP-реквесты, куда они ходят, зачем, как и почему.
3717.52 3727.76 "Анатолий Кулаков" И в принципе здесь нет ничего сложного, потому что у нас есть такие прекрасные средства для мониторинга приложений, как Diagnostic Source и Event Source.
3727.76 3734.84 "Анатолий Кулаков" Мы вам про них много раз уже рассказывали, но это прекрасный пример, где они ложатся прямо на практическую ценность.
3734.84 3749.68 "Анатолий Кулаков" Напомню, что Diagnostic Source это специальный механизм для инструментирования production-type, time-logов, который позволяет вам рассылать, даже не рассылать, а логировать, управлять таким богатым payload.
3749.68 3757.72 "Анатолий Кулаков" То есть он дает доступ абсолютно ко всему происходящему, ко всем параметрам этого класса.
3757.72 3768.92 "Анатолий Кулаков" И его минус, его ограничение в том, что его можно использовать только внутри того же самого класса, который порождает вот эти диагностические сообщения.
3768.92 3770.92 "Анатолий Кулаков" Рядом с ним есть Event Source.
3770.92 3780.36 "Анатолий Кулаков" Это точно также production-time-логирование, но он может распространять свои ивенты как внутри одного процесса, так и внутри другого процесса.
3780.36 3785.92 "Анатолий Кулаков" То есть Event Source могут слушать другие инструменты, которые находятся вне этого процесса.
3785.92 3795.12 "Анатолий Кулаков" Ну и соответственно для того, чтобы между процессами передавать какой-то payload, ваш payload должен быть сериализабельный.
3795.12 3796.84 "Анатолий Кулаков" Это одно из ограничений.
3796.84 3807.76 "Анатолий Кулаков" Ну и второе ограничение, что вы конечно не можете передать туда большой payload с какими-то референсами и сложными кросс-кольцевыми ссылками и прочим.
3807.76 3811.32 "Анатолий Кулаков" То есть payload должен быть понятный, сериализуемый и простой.
3811.32 3825.00 "Анатолий Кулаков" И желательно маленький, потому что чем больше у вас payload в этот момент, то тем больше времени вы тратите на сериализацию, на пересылку, на локацию и прочие накладные расходы, которые в нормальном production type логирования не должны влиять на performance.
3825.00 3828.44 "Анатолий Кулаков" Поэтому здесь весь payload старается держаться как можно меньше.
3828.44 3830.24 "Анатолий Кулаков" Вот такие два механизма.
3830.24 3831.88 "Анатолий Кулаков" Давайте рассмотрим их поподробнее.
3831.88 3840.28 "Анатолий Кулаков" И давайте как раз начнем с класса EventListener, который как раз умеет и межпроцессорные логирования передавать, и процессорные логирования.
3840.28 3851.44 "Анатолий Кулаков" Для того чтобы как раз слушать ивенты от Event Source, нам нужно заэкспериментировать свой класс EventListener, то есть поднаследоваться от стандартного класса.
3851.44 3863.88 "Анатолий Кулаков" Он может поддерживать типичные для любого HTTP-реквеста события, такие как request.start или request.stop, то есть когда мы послали реквест и когда уже реквест закончился.
3863.88 3879.08 "Анатолий Кулаков" В свойстве событий request.start у нас есть куча дополнительных каких-то объектов, например, имя домена, куда мы пошли, путь по этому домену, номер порта, версия HTTP и прочая информация можно из пропертии легко вытащить.
3879.08 3888.76 "Анатолий Кулаков" Для того чтобы реализовать этот класс, нам нужно поднаследоваться от EventListener, то есть делать своего собственного наследника, и перекрыть всего лишь два метода.
3888.76 3898.44 "Анатолий Кулаков" Первый метод это onEventSourceCreated, то есть когда мы создаем все Event Sources, мы здесь должны выбрать тот Event Source, который нас интересует.
3898.44 3905.00 "Анатолий Кулаков" Мы должны свещаться по EventSourceName и разрешить enableEvents сделать тому событию, которое мы хотим слушать.
3905.00 3909.40 "Анатолий Кулаков" После того, как мы это сделали, в наш второй метод начнут приходить вот эти события.
3909.40 3923.56 "Анатолий Кулаков" Второй метод называется onEventWritten, то есть это тоже перезагрузка, в которую у вас уже придет событие, в котором есть событие.start, событие.stop и доступ непосредственно к свойствам, которые вы можете залогировать, допустим, или что-то другое с ними сделать.
3923.56 3926.16 "Анатолий Кулаков" Довольно просто, гибко и понятно.
3926.16 3943.72 "Анатолий Кулаков" Так как механизм EventListener рассчитан на то, что его можно потреблять как внутри процесса, так и вне процесса, то снаружи процесса скоррелировать вот эти два ивента, request.start и request.stop, вам поможет такое свойство как activityID.
3943.72 3947.52 "Анатолий Кулаков" И в принципе, если вы снаружи находитесь, то другого выбора у вас нет.
3947.52 3953.60 "Анатолий Кулаков" Чтобы понять, что этот stop пришел от того же самого реквеста, от которого предыдущий старт, вам нужно их как-то коррелировать.
3953.60 3955.64 "Анатолий Кулаков" Вот для этого есть свойство activityID.
3955.64 3959.36 "Анатолий Кулаков" Например, если вы захотите померить время, за которое вам ответил сервер.
3959.36 3965.88 "Анатолий Кулаков" Для этого вам нужно знать эту пару и вычесть время окончания и время начала.
3965.88 3971.44 "Анатолий Кулаков" Если же вы находитесь внутри одного процесса, то в принципе можно использовать более удобные механизмы.
3971.44 3975.36 "Анатолий Кулаков" Например, внутри одного процесса можно использовать async.local.
3975.36 3986.16 "Анатолий Кулаков" В поле async.local просто-напросто сохранить некий стейт того реквеста, который у вас пришел в request.start и в request.stop просто-напросто этот стейт оттуда забрать.
3986.16 3991.84 "Анатолий Кулаков" То есть можно продолжить лагировать и всю магию по синхронизации для вас сам сделает async.local.
3991.84 3994.00 "Анатолий Кулаков" Такой интересный хак, который тоже очень часто помогает.
3994.00 3997.76 "Анатолий Кулаков" Как я уже сказал, у нас есть два события.
3997.76 4008.84 "Анатолий Кулаков" Первый – это вот этот внешний, который дает небольшой payload, но при этом можно его выкидывать во внешние процессы, такие как perfuse, допустим, и так далее.
4008.84 4011.92 "Анатолий Кулаков" И, соответственно, diagnostic listener.
4011.92 4016.36 "Анатолий Кулаков" Diagnostic listener позволяет нам слушать диагностик сорса.
4016.36 4020.56 "Анатолий Кулаков" Его сущность, она практически точно такая же.
4020.56 4024.16 "Анатолий Кулаков" То есть у нас есть HTTP request message, HTTP response message.
4024.16 4030.44 "Анатолий Кулаков" И в отличие от предыдущего класса, здесь они нормальные полноценные месседжи, которые приходят и уходят туда-сюда.
4030.44 4047.00 "Анатолий Кулаков" То есть на самом деле вы в diagnostic listener не просто можете считать информацию, но и каким-то образом их даже отмодифицировать и вытащить не только ту информацию, которую вам там логер удосужился прислать, но и всю настоящую информацию, с помощью которой HTTP request message уйдет в сеть.
4047.00 4051.32 "Анатолий Кулаков" Это плюсы данного подхода, диагностик сорса.
4051.32 4058.48 "Анатолий Кулаков" Его минусы в том, что его можно реализовать только внутри того же самого приложения, которое бросает эти ивенты.
4058.48 4065.88 "Анатолий Кулаков" В нашем случае это не проблема, так как мы решили, что мы перехватываем все ивенты из нашего собственного приложения.
4065.88 4077.48 "Анатолий Кулаков" У вас есть точно также возможность доступиться к статус коду, к хидерам и к боди и к прочим вещам, которые есть в HTTP request и HTTP response.
4077.48 4080.80 "Анатолий Кулаков" Регистрация его происходит немножко по-другому.
4080.80 4087.64 "Анатолий Кулаков" Здесь вам точно также необходимо сделать свой HTTP request observer, отнаследовать его стандартного класса.
4087.64 4089.92 "Анатолий Кулаков" Обзервер от diagnostic listener.
4089.92 4094.84 "Анатолий Кулаков" И в методе onNext вам будут приходить абсолютно все обзерверы, которые зарегистрированы в систему.
4094.84 4106.36 "Анатолий Кулаков" Как только вы найдете свой под особенной магической константой, в нашем случае это константа HTTP handler diagnostic listener, вы подписывайтесь на события этого листенера.
4106.36 4116.16 "Анатолий Кулаков" И точно также вам нужен второй класс с еще одним методом onNext, который принимает kvalue пэры от string object.
4116.16 4128.96 "Анатолий Кулаков" То есть, по сути, kvalue пэры каких-то свойств от определенного листенера, в котором вы точно также без особого труда, но может быть с небольшим трудом, вы сможете отыскать и хост, и порт, и query, и path.
4128.96 4133.64 "Анатолий Кулаков" Короче, все то, что вы ожидаете увидеть от нормального HTTP request.
4133.64 4138.16 "Анатолий Кулаков" И точно также, соответственно, залогировать.
4138.16 4141.88 "Анатолий Кулаков" Еще один интересный практически кейс, где это можно использовать, например, в юнит-тестах.
4141.88 4145.84 "Анатолий Кулаков" Даже не в юнит-тестах, а больше подходит для интеграционных тестов.
4145.84 4168.48 "Анатолий Кулаков" Например, для того, чтобы ваши интеграционные тесты, которые тестируют только те внешние сервисы, которые находятся на вашем локальном хосте, обычный интеграционный тест, они запускаются с такими блоками, там база данных, какой-нибудь почтовый сервис, еще кто-то, которые или мокаются, или эмулируют, или еще что-то на определенном хосте.
4168.48 4169.48 "Анатолий Кулаков" Обычно это localhost.
4169.48 4176.12 "Анатолий Кулаков" И часто бывает так, что вы забываете поставить правильный адрес к своему клиенту, и он начинает ходить к настоящему сервису.
4176.12 4179.92 "Анатолий Кулаков" Не к localhost, а к какому-нибудь стенду, или может быть даже вообще в интернет.
4179.92 4181.68 "Анатолий Кулаков" В общем, такая ситуация довольно часто.
4181.68 4186.64 "Анатолий Кулаков" И проблема в таких тестах в том, что они будут работать при определенных условиях.
4186.64 4197.64 "Анатолий Кулаков" Если у вас, допустим, доступен интернет, и вы можете случайно сходить в интернет, и у вас тест будет зеленый, а потом вы закатываетесь на Continuous Integration площадку, и там интернет недоступен, и ваш тест будет падать.
4197.64 4206.00 "Анатолий Кулаков" Или там какой-нибудь локальный стейдж, пока он работает, у вас тест зелененький, когда он моргает, обновляется, перестает работать, у вас тест становится красненьким случайно.
4206.00 4211.00 "Анатолий Кулаков" Вот чтобы не допускать таких вещей, можно сделать определенный фикс.
4211.00 4214.80 "Анатолий Кулаков" Можно зафиксить все ваши запросы внутри всего вашего тестового приложения.
4214.80 4224.94 "Анатолий Кулаков" Например, сказать, что если я нахожусь внутри интеграционных тестов, то все мои HTTP клиенты, HTTP реквесты обязаны ходить к localhost.
4224.94 4228.52 "Анатолий Кулаков" Для интеграционных тестов это вполне нормальное требование.
4228.52 4236.96 "Анатолий Кулаков" И вы таким образом довольно предсказуемо отсеете те тесты, которые у вас почему-то пошли к стендам, или к интернетам, или еще куда-то.
4236.96 4242.20 "Анатолий Кулаков" Для этого достаточно написать HTTP Request Detector.
4242.20 4245.96 "Анатолий Кулаков" Ему в словаре можно передать список допустимых хостов.
4245.96 4250.60 "Анатолий Кулаков" Сюда можно добавить инициализацию нашего диагностика Source Listener.
4250.60 4256.28 "Анатолий Кулаков" Для инициализации можно использовать модуль инициализаторы.
4256.28 4268.08 "Анатолий Кулаков" Это одна из фишек, который позволяет вам вызвать какой-то определенный статический метод в момент загрузки приложения еще до вызова любого другого метода, даже до вызова StaticMain.
4268.08 4275.68 "Анатолий Кулаков" Соответственно мы подписываем наш детектор на диагностик Listener, как уже было описано выше.
4275.68 4287.68 "Анатолий Кулаков" И в методе Next, который обзервированный, мы можем проверять, что если пришедший хост содержится в нашем белом списке разрешенных хостов, то есть по сути, если у него хост это localhost, то тогда все хорошо.
4287.68 4290.64 "Анатолий Кулаков" Ежели нет, тогда бросаем честный exception.
4290.64 4297.64 "Анатолий Кулаков" Это exception не позволяет HTTP клиенту выполниться, если он вдруг идет на внешний хост и валит весь тест.
4297.64 4311.64 "Анатолий Кулаков" Вот такой злобный киллер внешних реквестов у нас получается, который позволяет вам, например, детектировать веб-реквесты в интеграционных тестах на очень раннем уровне и вылавливать ранние потенциальные ошибки.
4311.64 4327.92 "Анатолий Кулаков" Ну а в общем, этот метод, который позволяет мониторить все реквесты, он довольно гибкий, потому что многие системные классы и многие даже не системные классы поддерживают вот эти diagnostic sources и event sources.
4327.92 4340.00 "Анатолий Кулаков" И скорее всего, если вам нужно просто посмотреть, просто проследить или просто залогировать, то скорее всего вы всегда найдете правильный event source или правильный diagnostic source и можете это сделать.
4340.00 4346.48 "Анатолий Кулаков" В общем, механизм довольно мощный, довольно распространенный, сам Microsoft его очень много юзает в различных своих фреймворках.
4346.48 4349.84 "Анатолий Кулаков" Поэтому не забывайте про него, если вдруг нужно, обязательно пользуйтесь.
4349.84 4361.28 "Игорь Лабутин" Да, звучит, наверное, может быть на слух довольно сложно, но внутри, если покопаться, там довольно простые идеи, в целом должно быть полезно.
4361.28 4363.04 "Игорь Лабутин" Хотя я, кстати, никогда такими не пользовался.
4363.04 4371.40 "Игорь Лабутин" У нас, в общем, никогда, по-моему, не было такой потребности, поэтому мне сложно даже прокомментировать, насколько это будет полезно.
4371.40 4373.40 "Игорь Лабутин" Пользовался таким в реальной жизни?
4373.40 4381.00 "Анатолий Кулаков" Ну да, мне нужно было иногда поймать какие-то определенные там открытия SQL-C, коннекции тоже самые, чтобы посмотреть, когда они открываются, с какими параметрами.
4381.00 4383.36 "Анатолий Кулаков" Https-запросы тоже часто ловил.
4383.36 4385.16 "Анатолий Кулаков" В основном такая быстрая диагностика.
4385.16 4389.72 "Анатолий Кулаков" Или, допустим, на основании этого же механизма построены любые OPM.
4389.72 4399.12 "Анатолий Кулаков" То есть, те механизмы, которые вы цепляете к вашему приложению, и радостно все exceptions, все traces, все логи сыпятся в какой-то один централизованный сервис.
4399.12 4401.56 "Анатолий Кулаков" А вы там в красивеньком интерфейсе это все наблюдаете.
4401.56 4407.80 "Игорь Лабутин" Ну так-то да, но только оно же уже встроено в этот самый API, и ты просто пользуешься уже готовым тулом.
4407.80 4411.88 "Игорь Лабутин" У нас так в OpenSight все работало в ажуре, то есть ты просто идешь в ажур, там все видно.
4411.88 4413.56 "Игорь Лабутин" Мне в коде не надо было ничего менять.
4413.56 4419.20 "Анатолий Кулаков" Конечно, ну до тех пор, пока ты не начинаешь или свой OPM писать, или разбираться, почему-то он не работает.
4419.20 4420.84 "Игорь Лабутин" Ну да, у нас все работало.
4420.84 4422.52 "Игорь Лабутин" А свой я не пишу.
4422.52 4423.52 "Игорь Лабутин" Ладно, давай дальше.
4423.52 4430.80 "Игорь Лабутин" Дальше у нас статья от не такого частого автора, я бы сказал, как, может быть, нам хотелось бы, от Жени Пешкова.
4430.80 4441.96 "Игорь Лабутин" Если вы не знаете, Женя завел блог, не то, чтобы он там сильно много пишет, но знаю, что статьи писать не так просто, поэтому будем смотреть на то, что уже сейчас есть.
4441.96 4448.48 "Игорь Лабутин" И Женя, на самом деле, в этой статье, которую я хочу сейчас посмотреть, разбирал проблемы консольного ввода на дотнете.
4448.48 4454.72 "Игорь Лабутин" Началось все на самом деле с обсуждения, ну или точнее для меня это, по крайней мере, то, что я видел в публичной дискуссии.
4454.72 4461.40 "Игорь Лабутин" Началось с обсуждения, удобен ли C# как язык для, ну так скажем, условно-олимпиадного программирования.
4461.40 4468.04 "Игорь Лабутин" Ну и не только олимпиадного, а допустим всякие штуки типа Advent of Code, которые традиционно в декабре проходят.
4468.04 4479.60 "Игорь Лабутин" Всякие такие задачки, они как правило требуют, ну там, сочетать какие-нибудь исходные данные из файлика либо из консольки, что-нибудь с ними сделать и написать в консольку уже вывод.
4479.60 4488.40 "Игорь Лабутин" И C# как правило подходит не очень здорово для этого, потому что у C# довольно ограниченные возможности по консольному вводу.
4488.40 4502.12 "Игорь Лабутин" Точнее, как ограничены, у нас есть класс Console, там можно вызывать всякие readCharacter или readLine целиком, но это во-первых работает не очень быстро, как выясняется, а во-вторых оно работает как будто со строками.
4502.12 4506.60 "Игорь Лабутин" То есть считается, что вы из файла либо из консольки всегда читаете строки, а дальше вы уже в программке
4506.60 4529.04 None с ними будете что-то делать. Что в отличие от других языков, потому что, ну в других языках есть всякие там C++, это волшебная конструкция C, I, N, больше-больше и дальше переменные, и в зависимости от того, какого типа у вас переменная, прочитается это либо как число, либо как число с плавающей точкой, либо как строка, в общем, гораздо проще писать код.
4529.04 4544.20 "Игорь Лабутин" Понятно, что там могут быть куча тонкостей на тему обработки валидных данных, но как правило в таких вот олимпиадных тиротестовых задачках данные априори достаточно валидны, чтобы не сильно париться в коде про их валидацию, и в таком случае C# становится как-то ну совсем неудобен.
4544.20 4558.00 "Игорь Лабутин" А в качестве тестового примера, на котором, собственно, вся статья развивается, предлагается задачка, где мы из входных данных читаем по 4 числа на строчку, разделенных пробелами, и выводим просто сумму на консоль.
4558.00 4570.92 "Игорь Лабутин" Простейшая задачка, но если мы ее просто напишем, и она будет просто работать, то пока читаем через read line, да, и пишем через write line, то все это занимает там 500 миллисекунд.
4570.92 4575.40 "Игорь Лабутин" Ну вот, допустим, это стандартное, считаем, время.
4575.40 4586.20 "Игорь Лабутин" Причем надо сказать, что все это было сделано с native out, потому что иначе там startup time тоже добавлял какие-то там сотни миллисекунд или около того.
4586.20 4592.28 "Игорь Лабутин" Дальше с консольным, несмотря на то, что статья называется быстрый консольный ввод, первое, с чем пытается разобраться Женя, это с выводом.
4592.28 4602.60 "Игорь Лабутин" И как ни странно, консоль write line, а помните, да, мы выводим сумму, в смысле не сумму всех чисел, а в каждой строчке у нас 4 числа, мы вычисляем их сумму и пишем на консольку.
4602.60 4613.72 "Игорь Лабутин" Если писать через консоль write line, то это будет довольно медленно, потому что у консоли можно сказать получить прям стрим консольный, обернуть его в stream writer и писать уже в stream writer.
4613.72 4617.88 "Игорь Лабутин" И тогда программка запускается не за 500 миллисекунд, а за 100 миллисекунд всего.
4617.88 4623.88 "Игорь Лабутин" То есть мы прям так в 5 раз ускорили просто за счет того, что пишем напрямую в каком-то смысле в поток.
4623.88 4628.80 "Игорь Лабутин" И разница на самом деле заключается в том, что консоль write line внутри себя вызывает флаж.
4628.80 4636.76 "Игорь Лабутин" И делает он это вполне разумным причинам, потому что обычно вы хотите видеть на консоли сразу все, что вы туда пишете.
4636.76 4648.40 "Игорь Лабутин" Ну точнее, предполагается, что вы после консоли write line, может быть, захотите сделать консоль read line, потому что вы только что написали какой-нибудь промпт пользователю, и неплохо было бы, чтобы был вызван флаж, чтобы содержимое стрима попало таки на консоль.
4648.40 4654.92 "Игорь Лабутин" Но в таких задачках мы знаем, что нам все равно, и мы знаем, что пользователь ничего смотреть не будет.
4654.92 4660.52 "Игорь Лабутин" Нам важно до конца работы процесса все записать, в конце сделать флаж и выйти.
4660.52 4666.68 "Игорь Лабутин" Поэтому мы можем делать это через stream writer, который флаж не делает, и сразу сэкономить довольно много времени, потому что флаж довольно дорогой.
4666.68 4687.80 "Игорь Лабутин" Но на самом деле это может быть не только важно в таких задачках, но и в обычных приложениях, потому что если мы пишем какие-то логи, например, на консоль, и делаете это по какой-то причине через консоль write line, ну вдруг так сложилось, то это может тормозить в итоге ваше приложение, потому что там будут делаться флажи, хотя для логов это не так важно.
4687.80 4693.68 "Игорь Лабутин" С write-ами вроде разобрались, будем писать дальше через stream writer, там сильно больше не ускорить.
4693.68 4697.52 "Игорь Лабутин" Теперь будем смотреть на чтение.
4697.52 4728.92 "Игорь Лабутин" Задачка эта взялась не просто так, задачка была, это какая-то из задачек на каких-то сайтах, где можно показать типа литкода, и в том варианте алгоритма, который Женя первый раз попробовал, нужно было прочитать 500 тысяч кисел, интов, и ограничение по памяти стояло в 16 мегабайт, то есть если объем памяти процесса превышал 16 мегабайт, то есть превышение после начала работы, то процесс прибивался по out of memory.
4728.92 4736.40 "Игорь Лабутин" Казалось бы, 500 тысяч чисел влезть в 16 мегабайт, да вообще фигня вопрос, потому что 500 тысяч чисел занимают интов 2 мегабайта всего.
4736.40 4739.04 "Игорь Лабутин" Куча места еще есть.
4739.04 4753.04 "Игорь Лабутин" Но фактически, если вы их читаете через консоль read, нам нужно прочитать строку, а строка, если внимательно посчитать в дотнете, для 10 цифр, ну а это максимум, может быть, интов, будет занимать 42 байта.
4753.04 4758.16 "Игорь Лабутин" А 42 байта это уже 21 мегабайт, если мы будем брать 500 тысяч таких строк.
4758.16 4771.32 "Игорь Лабутин" А приложение-то работает быстро, мы помним, да, там типа 500 миллисекунд, ну секунда, и garbage collector вообще ничего не успевает сделать, и ему и не нужно делать, казалось бы, что там 16 мегабайт-то это мало, что там garbage collector-то.
4771.32 4787.56 "Игорь Лабутин" И поэтому становится все плохо, в смысле, что память растет для обычных приложений не критично много, но вот для таких тестовых задачек становится плохо, и начинается, что вот, если я пишу тестовые задачки на дотнет-коде, я пишу оптимальный алгоритм, он все равно отваливается там по времени или по памяти.
4787.56 4793.60 "Игорь Лабутин" Ну потому что garbage collector не чистит память, и для дотнета это в целом нормально, но для таких сценариев не очень здорово.
4793.60 4795.52 "Игорь Лабутин" Надо что-то делать.
4795.52 4798.00 "Игорь Лабутин" Давайте напишем консольный ввод самостоятельно.
4798.00 4817.64 "Игорь Лабутин" Можно читать просто по символу, но если, у нас есть метод console.read, но так не очень здорово, получается что можно делать через StreamReader, так же как мы делали через StreamWriter, там чуть меньше всяких синхронизаций и прочих проверок, поэтому получается раза в три быстрее, чем через console.read.
4817.64 4828.60 "Игорь Лабутин" Но целые числа-то читать так просто, читаем пока встречаются там знаки плюс-минус и чиселки до ближайшего пробела, или что там у нас, до ближайшей нет цифрки, точнее.
4828.60 4841.44 "Игорь Лабутин" А вот с вещественными там сложнее, потому что там появляются разделительные точки, там появляется, соответственно, такая нотация, другая нотация, в общем, прочитать нормальное вещественное число, это прям непростая задачка.
4841.44 4845.28 "Игорь Лабутин" Поэтому, ну ладно, у нас пока только целые, будем работать с целыми.
4845.28 4868.24 "Игорь Лабутин" Можно еще больше ускорить, StreamReader, он все-таки читает это дело сразу в char, то есть он конвертирует байтики в char, char, как известно, UTF-16, и поэтому там все, тоже, как бы, память кушается, но тем не менее, ладно, допустим, пусть пока кушается.
4868.24 4872.56 "Игорь Лабутин" Но мы можем работать не через строчки, а мы можем работать через спаны.
4872.56 4879.68 "Игорь Лабутин" То есть набираем несколько символов в буфер, дальше через int.parse на спанах, все это работает.
4879.68 4884.76 "Игорь Лабутин" На самом деле, если это все сделать аккуратненько, и Женя это показывает, то перформанс получается на уровне плюсов.
4884.76 4898.08 "Игорь Лабутин" То есть вот на плюсовых там cin, соответственно, стандартном этом, через его стрим, то что называется, либо даже на cish-ном scanf, перформанс получается примерно такой же, как на таких int.parse на спанах.
4898.08 4904.52 "Игорь Лабутин" Наконец-таки на char можно писать приложение, которое работает примерно с той же скоростью, как на довольно низкоуровневых плюсах.
4904.52 4924.76 "Игорь Лабутин" Но дальше можно с этим еще ускорить, и если мы скажем, что ладно, мы не будем конвертить в дотнетовский UTF-16, давайте мы используем UTF-8 байты, но возникает вопрос, если мы рассмотрим строчку, а числа в принципе подходят под обычную категорию UTF-8, возникает вопрос, а как же нам UTF-8 читать, есть ли в дотнете стандартный способ?
4924.76 4925.76 "Игорь Лабутин" Оказывается, есть.
4925.76 4928.24 "Игорь Лабутин" У нас есть UTF-8 парсер класс, который используется для JSON.
4928.24 4936.72 "Игорь Лабутин" У нас же есть JSON Serializer, а он внутри умеет из массива байтов парсить напрямую UTF-8 строчки.
4936.72 4939.36 "Игорь Лабутин" Ну вот его-то мы и используем, этот самый UTF-8 парсер.
4939.36 4966.52 "Игорь Лабутин" И в итоге мы получаем скорость, если я правильно помню, медленный вариант вот этого ввода работал, именно бенчмарки на ввод работали что-то типа, по-моему, за 70 миллисекунд, C++ C/CIN и SCANF вместе с версией на спанах работал что-то за 25 миллисекунд, а вот версия с UTF-8 парсером напрямую на входном стриме байтов работает за 10 миллисекунд.
4966.52 4973.32 "Игорь Лабутин" То есть быстрее вообще всего, быстрее плюсового кода, идеально по памяти, потому что она ее вообще не кушает, спаны память не едят.
4973.32 5001.64 "Игорь Лабутин" И все бы здорово, но вывод статьи такой, что писать на дотнете можно, писать на дотнете такой быстрый код можно, но возникает вопрос, проблема, что в C++ это в общем-то одна строчка, прочитать число, а в дотнете приходится написать ну прям нетривиальный код на спанах, стримах, парсерах и так далее, который каждый раз воспроизводить сложно, то есть либо надо как-то библиотечку оформлять, либо еще что-то.
5001.64 5009.12 "Игорь Лабутин" Но если вы пишете, занимаетесь элементарным программированием, библиотечка вам не поможет, придется такой код писать условно по памяти каждый раз.
5009.12 5013.20 "Игорь Лабутин" Так что наверное все-таки для олимпиадного программирования C# пока еще не идеален.
5013.20 5032.52 "Игорь Лабутин" Ну а для вот таких задачек, если вам вдруг зачем-то хочется решать задачки типа литкода на плюсах, и вы упираетесь в ограничение памяти или времени и так далее, посмотрите на такие техники, может быть у вас скопернув такой код к себе и эффективно читая чиселки, вы избавитесь от этой проблемы.
5032.52 5050.04 "Анатолий Кулаков" Ну или если вам действительно это нужно, вы часто с этим сталкиваетесь, то существует еще pull request, или даже наверное ishu пока в стандартную библиотеку, то есть на основание, на то чтобы расширить стандартный консоль.
5050.04 5056.40 "Анатолий Кулаков" Вот Женя там тоже активно ведет дискуссии, поддержите его лайком, звездочками или прочим, чем полагается на GitHub.
5056.40 5069.16 "Анатолий Кулаков" Может быть данные изменения внесут в стандартный системконсоль или в вспомогательные классы рядом с ним, то есть в стандартный фреймворк как минимум, и они облегчат жизнь всем олимпиадным программаторам.
5069.16 5072.96 "Игорь Лабутин" Да ссылка на ishu есть в тексте статьи.
5072.96 5084.24 "Анатолий Кулаков" Прекрасно, пойдем к другой статейчике, здесь я тоже достал из бэклога интересную штуку, хотел давно рассказать ее, это про то, как расширяется xunit.
5084.24 5092.68 "Анатолий Кулаков" И тоже хороший практический кейс от Андрю Лока нам выпал, он как раз столкнулся с ситуацией, когда без этого было совсем никак.
5092.68 5102.88 "Анатолий Кулаков" Вот Андрю Лок в отличие от тебя, он пишет APM, и кстати он является одним из авторов датадок, APM Tracing Library, которая именно шерповая часть шерпового клиента.
5102.88 5110.48 "Анатолий Кулаков" И когда он разрабатывал эту Tracing Library, он столкнулся с одной интересной проблемой.
5110.48 5120.64 "Анатолий Кулаков" Если начинать сначала, то естественно эта библиотека, она должна очень плотно, очень массивно интегрироваться с огромным количеством любых вообще дотнет приложений.
5120.64 5132.04 "Анатолий Кулаков" Поэтому нам написано куча юнит тестов и такая же большая куча еще интеграционных тестов, потому что интеграция с другими приложениями, это грубо говоря ее основная функциональность, поэтому интеграционных тестов там очень много.
5132.04 5143.64 "Анатолий Кулаков" И вот команда внезапно напоролась на то, что один из интеграционных тестов, или в принципе может даже не один, короче какие-то интеграционные тесты начали виснуть прямо на Continuous Integration, на CI.
5143.64 5145.44 "Анатолий Кулаков" И какой из них вис?
5145.44 5155.84 "Анатолий Кулаков" Вообще куда копать, абсолютно невозможно понять, потому что XUnit не показывает то, какие тесты сейчас запущены и каким образом, то есть какой из них сейчас завис.
5155.84 5166.88 "Анатолий Кулаков" По идее это должно быть что-нибудь такое довольно простое, то есть нам достаточно обычных диагностических операций того, что тест начал выполняться и тест окончил выполняться.
5166.88 5172.40 "Анатолий Кулаков" Вот если бы у нас такая диагностика была, если бы XUnit это в логе писал, то данная проблема бы не возникла.
5172.40 5175.96 "Анатолий Кулаков" Авторы бы довольно быстро нашли бы тест и разобрались, что с ним не так.
5175.96 5180.36 "Анатолий Кулаков" Но они не могли этого сделать и локально тоже не могли воспроизвести эту ситуацию.
5180.36 5186.20 "Анатолий Кулаков" Она воспроизводилась только иногда и только на Continuous Integration площадке.
5186.20 5197.40 "Анатолий Кулаков" Поэтому засучив рукава, они пришли к одному единственному выводу, что нужно каким-то образом самим разобраться, как работает XUnit и самим решить эту проблему.
5197.40 5206.12 "Анатолий Кулаков" Дело в том, что XUnit из коробки имеет огромную возможность по расширению.
5206.12 5209.60 "Анатолий Кулаков" Там можно заменить абсолютно все, там можно расширить абсолютно любой шаг.
5209.60 5217.52 "Анатолий Кулаков" И именно, наверное, поэтому его так сильно любят в узких кругах, в частности в Microsoft.
5217.52 5220.48 "Анатолий Кулаков" Но у него есть другая проблема.
5220.48 5228.28 "Анатолий Кулаков" Вы расширить-то, конечно, можете абсолютно все, но вот из коробки никаких там удобных расширяторов вам не поставляется.
5228.28 5231.28 "Анатолий Кулаков" Если вы хотите, то садитесь и пишите сами.
5231.28 5241.92 "Анатолий Кулаков" Никаких там плагинов, каких-нибудь удобных экстеншн-методов, какой-нибудь библиотеки уже готовых классиков, которые позволяют вам сделать какие-то стандартные расширения, их нет.
5241.92 5243.72 "Анатолий Кулаков" Поэтому приходится все писать самому.
5243.72 5252.96 "Анатолий Кулаков" И из-за этого Андрю Лок с друзьями сели и дружно решили, что придется написать свой тестовый фреймворк на базе XUnit.
5252.96 5255.12 "Анатолий Кулаков" Звучало это именно абсолютно точно так же.
5255.12 5261.40 "Анатолий Кулаков" Но так как XUnit полностью расширяем, то называть это своим собственным тестовым фреймворком язык не поворачивается.
5261.40 5264.64 "Анатолий Кулаков" Они просто в правильных местах его расширили.
5264.64 5268.44 "Анатолий Кулаков" Что же для решения данной проблемы нужно все-таки сделать?
5268.44 5273.72 "Анатолий Кулаков" Ну, во-первых, самая главная точка расширения – это класс, который называется тест-фреймворк.
5273.72 5274.72 "Анатолий Кулаков" Вот так и называется.
5274.72 5277.72 "Анатолий Кулаков" И в XUnit этот класс отвечает за две вещи.
5277.72 5283.00 "Анатолий Кулаков" Во-первых, это за Discover тестов, то есть за обнаружение всех тестов, которых только можно найти.
5283.00 5285.60 "Анатолий Кулаков" И во-вторых, за запуск этих тестов.
5285.60 5287.68 "Анатолий Кулаков" Точнее, за создание запускаторов.
5287.68 5289.84 "Анатолий Кулаков" Но смысл именно в этом.
5289.84 5293.00 "Анатолий Кулаков" Существует реализация по умолчанию.
5293.00 5296.72 "Анатолий Кулаков" Она называется XUnit тест-фреймворк, как несложно догадаться.
5296.72 5299.20 "Анатолий Кулаков" А вы можете, соответственно, сделать свою.
5299.20 5308.08 "Анатолий Кулаков" Вы можете пронаследовать свой класс от тест-фреймворка и перекрыть те методы, которые вам нужны, и реализовать их так, как вам их нужно.
5308.08 5318.24 "Анатолий Кулаков" Для того, чтобы ваши тесты заработали, вам не нужно сделать это какой-то отдельным плагином или компилировать это отдельной сборкой, как, например, Rostran анализатор или еще что-то.
5318.24 5325.96 "Анатолий Кулаков" Вы можете это сделать, то есть заимплементировать свой собственный тестовый фреймворк в том же самом коде, в том же самой сборке, в которой находятся ваши тесты.
5325.96 5334.04 "Анатолий Кулаков" XUnit настолько умный и гибкий, что он сразу обнаружит ваш тестовый фреймворк и запустит уже ваши тесты в этой сборке прямо с помощью него.
5334.04 5338.44 "Анатолий Кулаков" И чтобы он это обнаружил и запустил, ему нужно немножко помочь.
5338.44 5346.52 "Анатолий Кулаков" Для этого существует специальный атрибут на уровне сборки, который называется XUnit.testframework.attribute.
5346.52 5354.40 "Анатолий Кулаков" Если вы в этом атрибуте укажете тип вашего тестового фреймворка, то будет использоваться для запуска тестов в этой сборке именно он.
5354.40 5362.44 "Анатолий Кулаков" Следующий шаг, который необходимо сделать, я напомню, что они хотели залогировать просто-напросто время начала теста, каждого теста и время окончания каждого теста.
5362.44 5371.76 "Анатолий Кулаков" И вот для того, чтобы логировать, у тестового фреймворка есть специальный класс, в который происходит диагностическое логирование.
5371.76 5376.72 "Анатолий Кулаков" Но по умолчанию диагностическое логирование все выключено, и поэтому вы его никогда не увидите.
5376.72 5386.60 "Анатолий Кулаков" Для того, чтобы его включить, вам нужно будет создать или отмодифицировать файл xunit.runner.json, указав там то, что диагностическое логирование разрешено.
5386.60 5392.32 "Анатолий Кулаков" Тогда вы будете видеть логи из вашего нового тестового фреймворка, и половину задачи кажется, что как будто уже решено.
5393.32 5400.40 "Анатолий Кулаков" Вторая точка, которая была найдена, это тест-метод runner.
5400.40 5405.12 "Анатолий Кулаков" То есть это специальный класс, у которого есть метод, который называется runTestCase.
5405.12 5413.96 "Анатолий Кулаков" И этот runTestCase делает то, что вызывается в момент вызова каждого тест-кейса.
5413.96 5415.48 "Анатолий Кулаков" То есть именно то, что нам нужно.
5415.48 5417.96 "Анатолий Кулаков" Внутри него мы можем контролировать каждый тест-кейс.
5417.96 5430.56 "Анатолий Кулаков" Это один вызов, если мы, допустим, выполняем факт, то есть тест-кейс, помеченный атрибутом факт, и единственный вызов, если мы выполняем тест-кейс, помеченный атрибутом теория.
5430.56 5432.36 "Анатолий Кулаков" То есть для теории он вызывается только один раз.
5432.36 5434.16 "Анатолий Кулаков" Но в принципе это то, что нам нужно.
5434.16 5441.64 "Анатолий Кулаков" То есть мы нашли ту точку, в которой мы можем вначале ставить логи о начале тестового метода, в конце ставить логи, а посередине вызвать наш тестовый метод.
5441.64 5447.00 "Анатолий Кулаков" И он нам всем подходит.
5447.00 5461.80 "Анатолий Кулаков" Мы его можем заимплементировать с помощью наследования точно от такого же стандартного метода, или воспользоваться стандартным XUnit тестом метод рандер, перекрыв всего-лишь навсего один из его методов, чтобы не загоняться слишком сильно с остальными перекрытиями.
5461.80 5464.32 "Анатолий Кулаков" Казалось бы, все в принципе готово.
5464.32 5469.12 "Анатолий Кулаков" Мы нашли точку, как подменить свой собственный тест-фреймворк у XUnit.
5469.12 5477.08 "Анатолий Кулаков" Мы нашли точку, где мы хотим перекрыть определенный метод, залогировав начало и конец этого метода.
5477.08 5496.64 "Анатолий Кулаков" Но так как XUnit не очень удобен в плане стандартных каких-то коробочных расшираторов, для того, чтобы нам доползти от тестового фреймворка до вот этого XUnit тест-метода рандера, пришлось реализовать своих собственных наследников, ну по сути наследников пустышек, от следующих классов.
5496.64 5506.48 "Анатолий Кулаков" Тест-фреймворк-экзекьютор, тест-ассемблер-рандер, тест-коллекшн-рандер, тест-класс-рандер, и только после этого мы дошли до тест-метод-рандер.
5506.48 5517.24 "Анатолий Кулаков" В общем, вот такую всю иерархию пришлось понаследовать из практически пустышек, то есть они нужны только для того, чтобы в самом конце нам подбросить свой собственный тест-метод-рандер.
5517.24 5525.16 "Анатолий Кулаков" То есть это показывает как раз и гибкость фреймворка, то, что можно подменить, настроить, затюнить практически на любом шаге.
5525.16 5531.56 "Анатолий Кулаков" Там и на исшаге исследования, на загрузке сборки, и класса, и метода, и все, что угодно можно подменить и расширить.
5531.56 5542.28 "Анатолий Кулаков" Но для этого вам придется переписать практически всю иерархию, пусть банальной копипастой, пусть какими-то пустыми классами, но все равно выглядит не так красиво и прекрасно, как хотелось.
5542.28 5550.56 "Анатолий Кулаков" Но мощность, конечно, действительно поражает, что можно сделать как бы абсолютно все, что вам придет в голову, и заинтегрировать это сразу прямо в текущую сборку.
5550.56 5561.72 "Анатолий Кулаков" Вот таким образом они просто-напросто вставили логирование начала, логирование конца, нашли свой тест, который приводил к падению и в принципе были все счастливы.
5561.72 5582.76 "Анатолий Кулаков" Но они здесь применили еще одну интересную хитрость, потому что если бы они просто логировали начало и окончание, а у них там просто тысячи и миллиарды тестов, и после этого им пришлось бы парсить весь output log на предмет начала, окончания, фейла, таймаута, времени и так далее, ну то есть для большого количества тестов это довольно проблематично.
5582.76 5587.44 "Анатолий Кулаков" Так как они решали довольно конкретную проблему, они пошли немножко другим путем.
5587.44 5590.56 "Анатолий Кулаков" Они не захотели парсить весь этот output log, они просто завели таймер.
5590.56 5600.96 "Анатолий Кулаков" В начале каждого теста они запускают таймер и в конце теста смотрят, что даже не в конце теста, потому что нам нужно зависшие тесты поймать, то есть они не в конце теста смотрят, а через определенный промежуток времени.
5600.96 5612.28 "Анатолий Кулаков" Если там таймер за две минуты показывает, что тест до сих пор все еще не завершен, то они пишут прямо в лог явный warning, явное сообщение, что вот этот тест, вот он завис.
5612.28 5619.76 "Анатолий Кулаков" И поэтому все тысячи тестов запустились, они в лог не спамили, а заспамили только те, которые вот зависли с помощью такого таймера.
5619.76 5624.80 "Анатолий Кулаков" Вот такой нехитрый способ, казалось бы банальная житейская ситуация.
5624.80 5636.08 "Анатолий Кулаков" Здесь мы посмотрели, каким образом можно расширить XUnit тестовый фреймворк и примерно прикинули, каким образом быстро найти те тесты, которые зависают на CI.
5636.08 5648.92 "Анатолий Кулаков" Может быть для кого-то из вас, кому тоже хотелось добавить XUnit, немножко специфического поведения, которое есть только у ваших тестов, которое есть только у ваших сборок или вашего приложения.
5648.92 5659.80 "Анатолий Кулаков" В общем, данная статья будет полезна и натолкнет вас на эту точку расширения, где вы можете настроить абсолютно все, что вам придет в голову про запуск ваших тестов и про Discovery, естественно, тоже.
5659.80 5666.88 "Игорь Лабутин" Да, такие статьи, они очень полезны для того, чтобы нормально получить такой обзор, что ли, о чем в принципе можно расширять.
5666.88 5681.60 "Игорь Лабутин" Потому что я, допустим, по старой памяти, когда давным-давно занимался тем же WCF, который тоже супер расширяемый, но ты смотришь на это обилие 50 разных интерфейсов или точек расширения, куда можно встроиться, и думаешь, ну и куда.
5681.60 5692.56 "Игорь Лабутин" Вот здесь так же, тебе новый фреймворк, новый раннер, новый то, новый сё, вот тебе показано, как они друг другом взаимодействуют, и хоть немножко начинаешь понимать, куда смотреть и зачем.
5692.56 5696.64 "Анатолий Кулаков" Да, да, как в эту цепочку влезть, чтобы ничего не сломать, оно еще потом и работало.
5696.64 5700.76 "Игорь Лабутин" Ну, да, чтобы оно сначала заработало.
5700.76 5710.28 "Игорь Лабутин" Ладно, давай мы будем потихонечку закругляться, у нас осталась вот последняя тема, это кратко о всяком разном, в котором тоже поднакопилось.
5710.28 5711.28 "Игорь Лабутин" Да, давай быстренько пробежимся.
5711.28 5721.04 "Игорь Лабутин" И в этот раз у нас начинается эта тема со статьи Маони Стефенс, главный архитектор и разработчик garbage collector .net.
5721.04 5728.52 "Игорь Лабутин" В данном случае я не стал ее включать в основной выпуск, а добавил в кратко разном, потому что статья довольно нишевая и специфическая.
5728.52 5733.36 "Игорь Лабутин" В garbage collector, оказывается, в .net нам есть специальный режим, называется heap verification.
5733.36 5772.92 "Игорь Лабутин" То есть если вы вдруг взяли, например, новое SDK, запустили ваше приложение и оно у вас там падает с какими-то там access violations или с секфолтами и прочими такими страшными штуками, которые, казалось бы, вроде не относятся к менеджменту, и обычно означает, что что-то не так работает либо в рантайме, либо в ГЦ, либо в вашем unmanaged коде, если вы используете его, то есть переменное окружение, называется .net_heap_verify, вы ставите ее в единичку, и после этого garbage collector начинает, ну точнее не garbage collector, а рантайм, начинает очень внимательно смотреть на heap в момент, когда garbage collector начинает свою работу и в момент, когда garbage collector заканчивает свою работу.
5772.92 5789.56 "Игорь Лабутин" Там вызывается функция verify_heap, которая проверяет кучу всяких разных вещей, что можно по всем сегментам или по всем регионам пройтись, что они все на месте, что там никаких, все объекты правильно размечены, что нет такого, что там длина объекта какая-то странная и так далее.
5789.56 5802.24 "Игорь Лабутин" Приложение, естественно, начинает работать гораздо медленнее, потому что этот verify_heap делает много чего, но если оно у вас падает с access_violation, то, как правило, вы допустите то, что оно работает немножко медленно для того, чтобы найти это падение.
5802.24 5818.00 "Игорь Лабутин" И Maoni говорит, что на самом деле, если вот этот режим у вас выдает тот вариант поведения, когда приложение падает на начале garbage collector, то это с хорошей вероятностью означает, что garbage collector не виноват.
5818.00 5832.84 "Игорь Лабутин" То есть вы обновили рантайм, но при этом, поскольку все это происходит в начале garbage collector, а в конце garbage collector оно не падало, то есть повреждение heapа произошло между garbage collectors, значит сам код garbage collector скорее всего не виноват.
5832.84 5836.00 "Игорь Лабутин" Есть маленькая вероятность, но все-таки скорее всего нет, чем да.
5836.00 5859.28 "Игорь Лабутин" А вот если на входе в garbage collector все было хорошо и ничего не упало, а на выходе verify_heap сказал что-то не то, ну это точно значит, что garbage collector что-то там намудрил, и надо это все репортить в Майкрософт, усмотреть, что же вы там сделали такое, что же у вас за сценарий рантайм, там не знаю, операционка на которой это все работает или код вашего приложения, который делает какие-то странные вещи.
5859.28 5869.44 "Игорь Лабутин" В общем, если после обновления SDK или просто по какой-то причине вы встретили падение с access violation, вот у вас есть еще один инструмент, что можно сделать.
5869.44 5884.28 "Игорь Лабутин" Дальше следующая ссылочка это библиотечка, которая мне попалась просто на просторах интернет, но показалась она довольно, она не имеет какого-то большого количества звездочек на GitHub, но выглядит по крайней мере по документации и по примерчикам очень прям солидно.
5884.28 5888.52 "Игорь Лабутин" Это библиотечка под названием dotenv.core.
5888.52 5890.64 "Игорь Лабутин" Простая штука для работы с n-файлами.
5890.64 5902.92 "Игорь Лабутин" N-файлы сам по себе простая штука, это набор строчек вида ключ=значения, но там есть свои тонкости, там бывает нужна подстановка значений переменных, то есть некоторый вариант string interpolation.
5902.92 5920.88 "Игорь Лабутин" Библиотечка это умеет, она имеет довольно неплохой интерфейс, довольно сильно кастомизируется, хотя что-то казалось бы кастомизировать, но прям документация развиситая, приятная, так что если вы вдруг зачем-то работаете на дотенете с .n-файлами, мне кажется это неплохой, по крайней мере кандидатно посмотреть, как оно там.
5920.88 5931.48 "Анатолий Кулаков" Ну они еще можно добавить, что применяются там всяких докерах, кубернетасах, если вам вдруг там нужно настраивать это все дело или наоборот считывать то, что уже настроено, в принципе там может пригодиться.
5931.48 5961.08 "Игорь Лабутин" Появилась новая версия такого продукта, такой библиотеки OpenEDict 4.0, general availability он теперь, и примерно прошло пару лет с прошлого релиза, для тех кто не знает, OpenEDict это в каком-то смысле альтернатива идентити серверу, то есть библиотечка, которая поддерживает протоколы OAuth и OpenID Connect, или позволяет точнее их реализовать сервер, ну их часть.
5961.08 5977.76 "Игорь Лабутин" При этом в этом релизе они поддерживают примерно 17 разных провайдеров, то есть они умеют из коробки работать со всякими ажурами, амазонами, октой и вот этим всеми теми, кто предоставляет доступ снаружи, то есть вы можете сделать там сортпати, аутентификацию в 17 внешних серверов.
5977.76 5984.40 "Игорь Лабутин" Библиотечка полностью совместима со спиноткором 2.1 и новее, так что должна быть по идее применима практически везде.
5984.40 6005.44 "Игорь Лабутин" Когда мы, по-моему, не обсуждали ее в подкасте, но периодически всплывают там обсуждения где-то в чатиках и так далее, она в целом кажется чуть менее функциональной, чем идентити сервер, ну и как-то менее популярной, но с учетом того, в каком виде сейчас лицензируется идентити сервер, возможно OpenEDict будет вполне себе применим.
6005.44 6012.52 "Анатолий Кулаков" Я, кстати, недавно узнал, что ABP Framework работает, интегрируется именно с OpenEDict.
6012.52 6024.68 "Игорь Лабутин" Да-да-да, вот может быть сейчас я как раз хотел сказать, что наверное за 2 года они должны были, по идее, хорошо продвинуться с прошлой версией и, наверное, может быть даже сравнятся по фичам с идентити, я не знаю.
6024.68 6030.12 "Анатолий Кулаков" Я смотрю сейчас, что она выпускается под лицензией Apache 2.0, что в принципе, да, не может не радовать.
6030.12 6038.60 "Игорь Лабутин" Да, так что посмотрите, возможно это хороший конкурент сейчас идентити серверу текущему, ну четверки, которые по сути сейчас не поддерживаются.
6038.60 6048.32 "Игорь Лабутин" Следующая штука называется Dots и это простенькое приложение, которое UI-ный менеджер, кроссплатформенный для ваших .NET SDK.
6048.32 6061.44 "Игорь Лабутин" То есть если вы знаете, у вас есть консольная приложение .NET, в которой можно написать .NET, пробел, минус-минус лист, минус SDK, он покажет, какие SDK доступны, с ними можно поинсталить, поанинсталить, вот это все.
6061.44 6065.56 "Игорь Лабутин" И автор, он сказал, ну это все, конечно, хорошо, но хочу UI.
6065.56 6081.20 "Игорь Лабутин" А чтобы было интересно, давайте мы этот UI напишем на MAUI, а то как-то мало у нас продуктов на MAUI, и я это тоже много раз где-то упоминал, что MAUI вроде зарелизилось, все такое, но как-то продуктов на нем что-то не видно, на самом деле, больших, особенно от Microsoft.
6081.20 6085.92 "Игорь Лабутин" Ну вот товарищ решил, говорит, давай попробуем на MAUI что-нибудь написать, и написал.
6085.92 6094.84 "Игорь Лабутин" В целом работает, но он говорит, что MAUI, конечно, еще сырой-сырой, в общем, там еще работать и работать.
6094.84 6106.92 "Игорь Лабутин" До нормального использования, так что может быть это, наверное, приложение, которое я бы рекомендовал посмотреть, если вы рассматриваете вопрос, типа, а не поиспользуют ли сейчас MAUI.
6106.92 6118.92 "Игорь Лабутин" Вот можно взять такое простое, понятное приложение, и на примере его посмотреть, насколько вообще в принципе MAUI жизнеспособна и отвечает тем нуждам, которые вы сейчас хотите.
6118.92 6127.08 "Игорь Лабутин" Да, внутри эта штука работает все равно с консолькой, то есть она будет просто вызывать ваши консольные командочки, можно заодно посмотреть, какие командочки она вызывает.
6127.08 6133.54 "Игорь Лабутин" Для вызова используется библиотечка CleverApp, которая тоже довольно мощная с точки зрения работы и вызова всяких консольных штук.
6133.54 6153.36 "Игорь Лабутин" Так, и последний тоже релиз, это YARP, мы про него довольно много говорили, это ReverseProxy от Microsoft, точнее, даже не ReverseProxy, это библиотека для создания ReverseProxy на основе Kestrel для C#, ну, AsperNadKore и так далее, на C# написано.
6153.36 6156.08 "Игорь Лабутин" ReverseProxy, естественно, может использоваться для чего угодно в результате.
6156.08 6174.20 "Игорь Лабутин" И штука довольно мощная, ее много кто любит, и ее обновили, минорный релиз был в июне, в общем-то полгода была тишина, тишина, тишина, вот сейчас 2.0, релиз кандидат 1, скоро будет, надеюсь, какой-то полноценный релиз.
6174.20 6197.16 "Игорь Лабутин" Там есть breaking.cng, там довольно исчерпывающий список с точки зрения, подробно написано, что где сломали и что теперь работает по-другому, и при этом завезли поддержку WebSockets поверх ажты TTP2, мы про это говорили в подкасте, что это завезли в седьмом дотнете, ну, соответственно, если вы работаете, если вы таргетите седьмой дотнет в приложении, который использует YARP, у вас будет поддержка WebSockets поверх ажты TTP2.
6197.16 6209.88 "Игорь Лабутин" При этом в целом они, новый релиз, они дропнули совместимость со старыми дотнет-версиями, и со старыми в их понимании означает все, что старше шестерки, то есть они совместимы теперь только с шестеркой и выше.
6209.88 6210.88 "Игорь Лабутин" Мысленно вея.
6210.88 6227.04 "Игорь Лабутин" Что, в принципе, наверное для YARP нормально, потому что это обычно отдельное приложение, которое, ну, по сути, никак не завязано на вашей бизнес-логике, обычно работает как-то отдельно, и, ну, почему бы его не затаргетить, действительно, на последнюю версию, вряд ли там нужны какие-то особые совместимости со старыми рентаймами.
6227.04 6232.36 "Игорь Лабутин" Примерно так, на сегодня у меня, пожалуй, все, больше никаких кратких новостей нету.
6232.36 6239.28 "Анатолий Кулаков" Ну, прекрасно, мы, в принципе, и достаточно уже посидели, тем более для первого новогоднего, поэтому давай закругляться.
6239.28 6254.32 "Игорь Лабутин" Сегодня мы посмотрели на C# 12, точнее, не то чтобы на C# 12, мы посмотрели на то, как живет репозиторий C# Roslyn, и что нас может ожидать в новом C# 12, что нас реально будет ожидать, будем узнавать по мере выхода новых превью.
6254.32 6309.12 "Игорь Лабутин" Посмотрели на старую статью про InferSharp, и чем она вам может помочь в анализе вашего кода, узнали что нового в Visual Studio 2022 17.5 Preview 3, узнали roadmap на Ryder Harper 2023.1, посмотрели что делать, если вы хотите понять, какие breaking changes произошли у вас между двумя новогодними пакетами, и как это более-менее автоматизировать, узнали что в шестом дотнете появилась возможность батчить команды в базе данных в Adoneti, и дальше стали смотреть на то, как закапываться вглубь всяких разных кусочков фреймворка, то есть смотреть на все ваши HTTP-реквесты в приложении, либо узнавать, как очень эффективно читать и писать в консоль, либо вообще писать свой собственный тестовый фреймворк на базе XUnit и в него, точнее встраиваться в XUnit, чтобы по большому счету ради простой задачки написать почти полноценный тестовый фреймворк.
6309.12 6313.68 "Анатолий Кулаков" Ну и посмотрели кучу всякой мелочи в рубрике "Кратко
6313.68 6317.64 "Игорь Лабутин" о разном". Ну да, но мы ее смотрели последней, поэтому подробно я ее перечислять не буду.
6317.64 6318.64 "Игорь Лабутин" Перечислять точно не надо.
6318.64 6322.20 "Игорь Лабутин" Я надеюсь, она недалеко ушла по таймингу, так что.
6322.20 6326.16 "Игорь Лабутин" Если что, можно отмотать минут на 5 назад и она там вся будет.
6326.16 6327.16 "Анатолий Кулаков" Еще раз переслушать.
6327.16 6340.32 "Анатолий Кулаков" Да, переслушивайте чаще наши подкасты, даже можно не на 5 минут назад, а при ведущий выпуск, если вы вдруг пропустили, или найдите какого-нибудь друга, о котором вы хотите счастья, хорошего друга, и посоветуйте ему подписаться, послушать наши подкасты.
6340.32 6361.40 "Анатолий Кулаков" Хочется, чтобы людей, которые нас слушают, было как можно больше, чтобы они просвещались как можно лучше, и вместе с вами, соответственно, мы тоже будем набирать много новых тем, будем просвещаться, будем расти, и в этом году точно так же, как и в следующем, будем показывать большой, интересный рост с красивыми темами, может быть, новыми гостями.
6361.40 6364.64 "Анатолий Кулаков" На этом все, всем пока, всем до новых встреч.
6364.64 6365.36 "Игорь Лабутин" Всем пока.
6365.36 6376.24 None [музыка]
