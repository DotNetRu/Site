0.00 12.52 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет и это у нас 48 выпуск.
12.52 15.64 "Анатолий Кулаков" В студии, как всегда, Анатолий Кулаков и Игорь Лабутин.
15.64 16.64 "Анатолий Кулаков" Всем привет.
16.64 25.56 "Анатолий Кулаков" Спасибо большое за то, что поддерживаете наш подкаст и в частности Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья, огромное вам спасибо.
25.56 34.68 "Анатолий Кулаков" Патреон в последнее время нас недолюбливает, поэтому если вы вдруг захотите присоединиться к этому бравому списку или нашему приватному чатику, рассмотрите поближе Boosty.
34.68 43.04 "Анатолий Кулаков" Там все в порядке, там авторов любят, платят и, соответственно, помогают нам быть вместе и поддерживать интересные и хорошие начинания.
43.04 58.92 "Анатолий Кулаков" Из неочередных тем, а хотел еще сказать, что у нас в 44 выпуске мы обсуждали такой прекрасный диаграммный движок, как Marmorite, и с помощью него вы можете рисовать диаграммы в виде текста и вставлять их в вашу документацию.
58.92 71.48 "Анатолий Кулаков" Там мы рассуждали, что у GitHub уже есть issue, и в планах было добавить поддержку рендеринга диаграммчиков в свой основной движок, то есть в Wiki, в Readme.
71.48 84.60 "Анатолий Кулаков" Так вот, эта штука зарелизилась, теперь в GitHub ждите наплыва новых красивых диаграммчиков, и теперь, я думаю, что наши Readme, Wiki и прочая документация станет еще красивее и еще лучше.
84.60 89.84 "Анатолий Кулаков" И это вот такая хорошая новость, которую хотелось бы в первую очередь с вами поделиться.
89.84 95.64 "Анатолий Кулаков" А теперь давай, наверное, перейдем к официальным темам, и что-нибудь от Microsoft у нас?
95.64 99.44 "Игорь Лабутин" Да, в этот раз у нас есть от Microsoft.
99.44 112.24 "Игорь Лабутин" Зарелизился очередной превью, это .NET 7 Preview 2, всего лишь второй превью седьмого .NET, но у нас всего и март на дворе, так что до, когда у нас там в ноябре релиз, как обычно, времени еще вроде как много.
112.24 113.24 "Анатолий Кулаков" Ну, где-то осенью, да.
113.24 123.16 "Игорь Лабутин" Вот, поэтому потихонечку начинаем смотреть на новенькие фичи, пока ничего прям супер выдающегося нету, но тем не менее есть о чем поговорить.
123.16 132.24 "Игорь Лабутин" Во-первых, у нас увеличивается использование Source-генераторов, и очередной Source-генератор - это Source-генератор для RegEx'ов.
132.24 150.48 "Игорь Лабутин" То есть теперь вместо того, чтобы писать там какой-то хитрый RegEx, думать, как там его сказать ему, компилировать его, значит, или не компилировать, и он каждый раз тогда будет интерпретироваться, а если нужно компилировать, то он будет компилироваться в рантайме, и, соответственно, тратить на это время.
150.48 156.32 "Игорь Лабутин" Теперь можно вместо этого сделать все через Source-генераторы, то есть все это будет в Compile-тайме.
156.32 172.80 "Игорь Лабутин" Для этого вам нужно всего лишь ваш тип сделать паршилом, и добавить в него новый паршил-метод, который пометит, собственно, атрибутиком RegEx-генератор, в котором, собственно, указать весь ваш RegEx, который вы хотите, со всеми нужными опциями.
172.80 183.40 "Игорь Лабутин" В результате вы из этого метода, который вы объявите, будете получать, собственно, RegEx-обжект, который раньше у вас был объявлен полем или пропертей, и его использовать.
183.40 187.68 "Игорь Лабутин" А он уже будет прям соптимизирован так, что круче некуда.
187.68 200.56 "Игорь Лабутин" Там действительно очень крутой Source-генератор, вроде как этим занимался чуть ли не сам Стивен Тауп, я не проверял по GitHub, а потом по каким-то косвенным признакам видел где-то, что, по-моему, Тауп в основном занимался RegEx, так что, скорее всего, там что-то очень крутое.
200.56 214.88 "Анатолий Кулаков" Слушай, а это же значит теперь, что мы можем даже дебажить RegEx, то есть если у вас вдруг что-то не мачется, вы прям можете зайти в уже сгенерированный код, там наверняка он будет состоять из всяких ифчиков и фурычей с обычными вальвачами, и можно пройтись и подебажить, а почему не мачется.
214.88 217.60 "Игорь Лабутин" Да, это, кстати, интересная идея, я об этом не думал.
217.60 232.08 "Игорь Лабутин" Я не смотрел, что там генерится, возможно, там все-таки есть какие-нибудь фоллбэки на стандартный RegEx в сложных случаях, но действительно, наверное, для каких-то простых понятных случаев там будут нормально написанные циклики и можно будет действительно просто посмотреть, как он ходит по ним.
232.08 250.64 "Анатолий Кулаков" Ну, насколько я помню, последней оптимизацией в предыдущем релизе, который мы с тобой рассматривали, где еще генерация RegEx происходила в рантайме, то есть там еще имитилось все, там была довольно хорошая такая стейт-машина, которая реально в псевдокоде очень грамотно смотрелась.
250.64 260.08 "Анатолий Кулаков" То есть я не удивлюсь, если это будет, знаешь, такая мега фишка, это единственный, наверное, язык, который я могу придумать, который позволяет реально отдебажить, а почему у вас RegEx после что-то там не смачил.
260.08 261.88 "Игорь Лабутин" Ну, надо будет попробовать, посмотрим.
261.88 268.44 "Игорь Лабутин" В принципе, семерка превью у меня еще пока не стоит, но возможно поставлю, надо будет глянуть.
268.44 280.36 "Игорь Лабутин" Дальше завезли некоторое количество разных не очень больших улучшений в CodeGen, в Profile Guided Optimization, для Arma 64 есть новые оптимизации.
280.36 298.08 "Игорь Лабутин" Вообще в целом в рантайме появились некоторые оптимизации, которые применимы ко всем платформам, то есть, ну, потихонечку пилят всякие разные штуки, которые нужно пилить рано, в том числе потому что, чтобы успеть проверить это все на всех платформах, что оптимизация оптимизации, но мы ничего не сломали при этом.
298.08 323.80 "Игорь Лабутин" Дальше, в разделе Observability мы будем еще немножко сегодня касаться Observability, чуть-чуть, но конкретно в Observability у нас, как известно, в шестом тотнете поддержаны метрики, у нас есть стандартный тип реймспейс для метрик, и там теперь появился новый класс под названием UpDownCounter, то есть, каунтер, который умеет ходить и вверх, и вниз, раньше там был только каунтер, который умеет ходить только вверх, и вы его не могли уменьшать, теперь есть каунтер, который умеет туда-сюда.
323.80 326.92 "Игорь Лабутин" Ну, наверное, вам это будет зачем-то полезно.
326.92 350.64 "Игорь Лабутин" В Logging Source Generators пофиксили некоторое количество багов, то есть, там ссылки на, по-моему, 5 или 6 исшиусов на GitHub, и все из них были там Fixed, Incorrect, Behaviour, When, что-нибудь, то есть, находились какие-то Corner Cases, при которых Source Generator ввел себя не очень здорово, и это все фиксилось, что наводит на мысль, что в случае с Regex с Source Generator интересно, сколько там может быть багов.
350.64 352.84 "Игорь Лабутин" Вот, но посмотрим.
352.84 353.84 "Игорь Лабутин" Дальше.
353.84 366.76 "Игорь Лабутин" В SDK мы завезли некоторое количество улучшений, а именно в .NET ToolZoo командную поменяли немножко то, как она работает с командной строчкой, и поэтому теперь...
366.76 404.84 "Игорь Лабутин" все это сейчас пока коснулось только в основном команды .NET New, где всякие шаблончики нужно подставлять для создания новых проектов, и вот там теперь работает нормальный TabCompLinux, то есть, вы можете имена вот этих шаблонов подставлять, плюс поменялась немножко имена команд, то есть, раньше часть команд выглядела как опции, они были с - - префиксом, теперь они есть как нормальные команды, но старые тоже сохранены для Backward Compatibility, поэтому почитайте внимательно новость, там прям поменялись вроде несущественные мелочи, но может быть это будет вам полезно в такой дейли работе.
404.84 409.28 "Игорь Лабутин" Хотя не знаю, я не так часто создаю новые проекты через .NET New и какие-то шаблончики.
409.28 417.12 "Игорь Лабутин" Еще один раздел улучшений - это Native AOT, Ahead of Time Compilation.
417.12 430.20 "Игорь Лабутин" Как мы уже говорили, Native AOT было подвинуто, перенесено из специальной репозитории под названием Runtime Lab, где обкатываются всякие разные улучшения и эксперименты для .NET Runtime.
430.20 442.12 "Игорь Лабутин" Оно перенесено в нормальный .NET Runtime теперь, но поддержка еще не абсолютно полная и нужно теперь некоторое количество времени, чтобы поддержать это все в SDK, чтобы там нормально работал паблиш.
442.12 452.20 "Игорь Лабутин" То есть сейчас вы можете это все собирать, это все может компилироваться, но там с паблишем еще есть некоторые проблемы, но уже можно пытаться что-то с этим делать и смотреть, как оно поддержано.
452.20 455.00 "Игорь Лабутин" Это все то, что касается .NET.
455.00 466.36 "Игорь Лабутин" Как обычно вместе с .NET конечно же зарелизился и ASP.NET и там не так много прям таких крутых больших огромных улучшений, но они планомерно работают над разными фичами.
466.36 489.52 "Игорь Лабутин" То есть пока не очень видно мне, по крайней мере, что у нас в седьмом .NET будет такого прям ух крутого в ASP, но с другой стороны седьмой у нас и не LTS, поэтому возможно там будут какие-то пока мелкие улучшения и может быть ближе к релизу или к серединке релиза мы увидим какие-то новинки, которые будут тоже обкатываться на будущее.
489.52 493.84 "Игорь Лабутин" Но пока в превью 2 нам завезли следующие штуки.
493.84 500.76 "Игорь Лабутин" Во-первых, теперь в API-контроллерах можно не указывать атрибут from services.
500.76 518.60 "Игорь Лабутин" То есть если вы помните, у нас есть dependency injection стандартный в ASP.NET и вы можете, например, заинжектировать какие-то зависимости в конструктор класса, но тогда эти зависимости будут туда заинжектированы в момент, когда этот класс создается.
518.60 523.68 "Игорь Лабутин" И это значит, что эта зависимость тоже будет создана.
523.68 530.24 "Игорь Лабутин" Но возможно эта зависимость нужна только в одном или двух методах контроллеров, а всем остальным методам контроллера не нужна.
530.24 533.04 "Игорь Лабутин" И, например, это какая-то очень тяжелая зависимость.
533.04 538.52 "Игорь Лабутин" В этом случае рекомендуется такую зависимость инжектировать непосредственно в метод контроллера, аргументом.
538.52 550.00 "Игорь Лабутин" И раньше нужно было обязательно туда указывать атрибут from services, чтобы DI Container знал, что нужно instance для значения этого параметра взять из DI Container.
550.00 552.48 "Игорь Лабутин" Теперь такого делать не надо, он сам сообразит.
552.48 553.48 "Игорь Лабутин" Абсолютно.
553.48 565.72 "Игорь Лабутин" Если вас вдруг почему-то такое поведение не устраивает, или возможно оно, например, неправильно работает или еще что-то, есть специальная опция, она конфигурится в рантайме для ASP.NET Configuration.
565.72 568.64 "Игорь Лабутин" Называется disable implicit from services parameters.
568.64 572.40 "Игорь Лабутин" Если ее поставить в true, то, соответственно, это поведение будет отключено.
572.40 576.80 "Анатолий Кулаков" Я бы еще добавил, что так делать никогда нельзя.
576.80 588.36 "Анатолий Кулаков" Если у вас вдруг действительно есть зависимость, которая хочет быть использована только в паре методов, сделайте отдельный контроллер для нее с этими двумя методами и инжекти ее, как положено в конструктор.
588.36 596.24 "Анатолий Кулаков" Потому что property inject, метод inject и куда угодно inject, кроме конструктора зависимости, это считается очень-очень плохой практикой.
596.24 602.92 "Анатолий Кулаков" В любой документации по контейнерам вам об этом в первых же строках сразу скажут.
602.92 608.04 "Анатолий Кулаков" Поэтому Microsoft, конечно, сделал гибко, красиво и хорошо, но лучше вы так никогда не делайте.
608.04 609.48 "Игорь Лабутин" Ну удобно же, мы делали.
609.48 610.76 "Игорь Лабутин" Ничего вроде не сломалось.
610.76 616.24 "Игорь Лабутин" Вообще, конечно, да, лучше действительно стараться все делать через конструктор, это гораздо явнее.
616.24 619.76 "Игорь Лабутин" Это то место, куда все по дефолту идут, чтобы посмотреть, от чего зависит класс.
619.76 623.60 "Игорь Лабутин" И бегать потом еще по методу контроллеров, это, конечно, не как property.
623.60 631.44 "Игорь Лабутин" Проперти совсем плохо, потому что property, ну их можно забыть, проставить и вообще ничего не произойдет, кроме null reference exception какого-то, например.
631.44 636.92 "Игорь Лабутин" В контроллерах все-таки забыть что-то, передать сложно, но тем не менее не очень удобно.
636.92 645.12 "Анатолий Кулаков" Да, все равно это более не явно, чем через конструктор, к которому уже все привыкли, все умеют анализировать, все туда смотрят и вообще всем удобно.
645.12 646.12 "Игорь Лабутин" Да.
646.12 647.12 "Игорь Лабутин" Поехали дальше.
647.12 654.04 "Игорь Лабутин" Dependency injection для SignalR методов, там в некоторых местах не было поддержано, теперь есть.
654.04 658.80 "Игорь Лабутин" Для Minimal API, конечно же, добавили еще немножко улучшений.
658.80 668.96 "Игорь Лабутин" Теперь можно для того, чтобы в вашей Swagger документации, которая красиво генерится по вашим Minimal API, можно было написать красивый description к endpoint.
668.96 677.12 "Игорь Лабутин" Теперь это можно сделать либо атрибутиком под названием endpoint summary, либо специальным extension методом под названием with description и передать туда строчку.
677.12 684.84 "Игорь Лабутин" Она, соответственно, будет сгенерена, использована при генерации Swagger спецификаций для вашего Minimal API.
684.84 688.64 "Анатолий Кулаков" Ничего себе, это теперь файлики с XML документацией больше не нужны?
688.64 691.80 "Анатолий Кулаков" Можно вот такими вот extension методами наворачивать документацию?
691.80 700.76 "Игорь Лабутин" Ну, можно, тем более что тебе некуда наворачивать XML, ну не, XML, ладно, XML можно отдельно, файликом.
700.76 721.08 "Игорь Лабутин" Ну не знаю, Minimal API вообще там, мне кажется, я что-то как-то один раз попробовал собрать какой-то такой простенький пример на Minimal API, и там у меня получился такой микс, вроде там и логика, и маршруты там же, и ну вот если мы Swagger хотим нормально, там этих атрибутов появляется огромное количество, кто кого куда.
721.08 726.16 "Игорь Лабутин" Там какая-то очень большая такая мешанина всего и вся, мне пока не очень понравилось.
726.16 731.68 "Игорь Лабутин" То ли я делал что-то, что не подходит под Minimal, но не было Minimal, возможно.
731.68 733.52 "Анатолий Кулаков" Или не было API.
733.52 749.88 "Анатолий Кулаков" Да, действительно, получается такая каша, месиво какое-то из всяких атрибутов, методов, лямбт, замыканий, и может быть уже смотришь на это все, и кажется, что может все-таки уже вынести в контроллер, описать нормально, и будет сочетабельно красиво, и все такое.
749.88 760.92 "Игорь Лабутин" Ну вот может быть, поэтому пока непонятно, я все жду, когда появится какой-нибудь, ну так скажем, хороший, большой относительно проект, продукт, где эти Minimal API будут.
760.92 761.92 "Игорь Лабутин" Так что посмотрим.
761.92 763.52 "Игорь Лабутин" Поехали дальше.
763.52 789.28 "Игорь Лабутин" Дальше, если у вас есть, например, в Query или в Body набор, а, в Header еще, в Header, sorry, в Header и в Query набор, например, параметров, которые вы хотите смапить в массив, то теперь для примитивных типов и для строчек это все работает нативно, то есть, в смысле, вам не нужно писать каких-то конструктных байндеров и так далее, оно само смапится в массив.
789.28 796.16 "Игорь Лабутин" Если у вас есть соответствующий набор, например, для Header несколько значений через запятую, они будут смаплены теперь в массив строчек.
796.16 812.60 "Игорь Лабутин" И более того, вы это можете даже делать для своих кастомных типов, если у этого типа есть метод try_parse, который принимает string, возвращает, соответственно, bool, ну и out параметр с вашим типом.
812.60 827.68 "Игорь Лабутин" Тогда .NET, ASP.NET автоматически попытается вызвать try_parse на значении, допустим, Header, разбив его сначала через запятые на разные значения и сформирует из этого тоже массив и передаст вам, соответственно, в ваш метод контроллера.
827.68 838.00 "Игорь Лабутин" Так, и последнее, не то чтобы завезли в ASP.NET, но прямо очень, скажем так, сильно подчеркнули в этом анонсе.
838.00 847.64 "Игорь Лабутин" Значит, смотрите, в шестом .NET было сделано такая фича, как shadow copying для IIS, для Ease.
847.64 848.92 "Игорь Лабутин" В чем проблема?
848.92 862.92 "Игорь Лабутин" Если у вас Ease запущен и ваш сайт в нем, соответственно, работает, то вы не можете заменить длельки вашего приложения, ну просто потому что винда их лочит, да, винда и Ease их лочит, потому что они загружены в память и используются на данный момент.
862.92 878.84 "Игорь Лабутин" Поэтому в шестом .NET, в модуль, который, собственно, отвечает за загрузку всех .NET сборок, была добавлена логика, которая на самом деле не грузит эти длельки из того места, где они лежат, а делает shadow copy, то есть некоторую такую копию куда-то там к себе, и загружает оттуда.
878.84 888.48 "Игорь Лабутин" Таким образом, вы можете обновлять ваши длельки, они не залочены, а модуль этот следит, что там, о, что-то обновилось, супер, давайте мы тогда его перезапустим.
888.48 904.64 "Игорь Лабутин" И эта поддержка, она экспериментальная, с ней не очень понятно, как правильно там все сделано, неправильно, удобно, неудобно, и поэтому они прямо просят, Microsoft прямо просит, что если вы таким пользуетесь и попробовали, то пожалуйста отпишите фидбэк им.
904.64 919.52 "Игорь Лабутин" Там есть все нужные линки, это на GitHub, понятное дело, можно туда все это отписать и рассказать, насколько вы этой фичей пользуетесь, чем она удобна, чем она неудобна, какие сценарии она, возможно, ломает.
919.52 924.84 "Игорь Лабутин" Вообще, конечно, интересно, что и Ease до сих пор живет, и не все перешли на Kestrel, но в принципе…
924.84 937.88 "Анатолий Кулаков" Ну, у Ease есть очень много преимуществ, то есть он там умеет перезапускать твои линки, умеет проксировать, умеет сертификаты подставлять, роутинги переписывать, и под это заточена уже куча админов, которые уже 30 лет этим занимаются и знают, как это делается.
937.88 941.08 "Анатолий Кулаков" Ну вот, чем Kestrel, пожалуй, пока похвастаться не может.
941.08 955.08 "Игорь Лабутин" Ну это да, ну и на самом деле, конечно, Azure тоже основан в общем-то на Ease внутри, и все это запускается, все ваши App Services или Functions, они все равно все запускаются в Ease, и поэтому, да, над Ease все равно хорошо работают.
955.08 961.48 "Игорь Лабутин" Последнее про наши обычные разговоры про превьюшки — это EF Core.
961.48 982.92 "Игорь Лабутин" EF Core, команда, она потихонечку пилит всякие багфиксы, и пока особо никакими громкими анонсами отмечена не была, они прямо даже явно не стали выкладывать никакой прям отдельной статьи с анонсом того, что у них сделано, а ограничились обычным релиз-ноутсами на Docs.Microsoft.com, если даже не на GitHub'е у себя.
982.92 997.92 "Игорь Лабутин" Да, прямо на GitHub'е просто завели Ease, и где написали, что вот мы зарелизили превью 2, учтите, что в превью 1 и в превью 2 нет никаких новых фич, там есть примерно 30 багфиксов и около 30 всяких разных мелких улучшений.
997.92 1015.96 "Игорь Лабутин" То есть там улучшили всякие поддержку TablePerClass, когда мы храним иерархию по табличке на класс, ну и там атрибутики разные новые, даже не столько новые, сколько улучшили работу каких-то старых атрибутиков, для разширили для новых баз и так далее.
1015.96 1021.76 "Игорь Лабутин" Так что если вы пользуетесь EF Core 6, посмотрите, может быть какие-то из ваших багов уже пофиксили.
1021.76 1028.16 "Игорь Лабутин" Но в целом вот примерно такое получилось в DotNet 7 Preview 2.
1028.16 1037.08 "Анатолий Кулаков" Да, разгоняются все еще команды, разгоняются, или им там до сих пор премии не пообещали за количество реализованных фич, поэтому пока что-то маловато.
1037.08 1042.76 "Анатолий Кулаков" А как же наш давно уже анонсируемый и крепко ожидаемый DotNet 7 Preview?
1042.76 1044.76 "Игорь Лабутин" Тоже вышло превью, 14-ый.
1044.76 1052.48 "Игорь Лабутин" Для него нужна Visual Studio 2022 17.2 Preview 2, про нее мы немножко позднее поговорим сегодня.
1052.48 1061.84 "Игорь Лабутин" И здесь есть всего лишь одна новая фича, это добавили такую полезную штуку, мне даже удивительно, что ее не было до этого, это меню бар.
1061.84 1068.40 "Игорь Лабутин" То есть если вы пишете десктопное приложение, ну обычно такое классическое десктопное приложение, то вы знаете, что наверху бывают менюшки.
1068.40 1077.00 "Игорь Лабутин" В современных приложениях, правда, частенько не бывает, ну либо они там как-то хитро скрываются куда-нибудь, но в целом вообще обычно там есть меню.
1077.00 1092.48 "Игорь Лабутин" И вот теперь это можно, меню можно добавлять, это прямо в XAML или в C# добавляется с помощью специальной коллекции меню бар items, ну и дальше там можно описать иерархи менюшек и все командочки, которые будут выполняться, когда вы по этой меню будете ходить.
1092.48 1098.52 "Игорь Лабутин" Дальше в Maui завезли большое количество исправлений, то есть они сейчас работают над стабильностью.
1098.52 1109.40 "Игорь Лабутин" Цель у них в апреле сделать релиз-кандидат, насколько я знаю, ну и где-то во втором квартале все-таки выпустить уже релиз, пока они к этому движутся.
1109.40 1119.20 "Игорь Лабутин" Еще из новинок, точнее новинок улучшений, помимо самого UI, да, Maui это конечно же в основном про UI, но еще это про кроссплатформерность.
1119.20 1124.96 "Игорь Лабутин" И важная штука это доступ к API, который специфичен для каждой платформы.
1124.96 1133.00 "Игорь Лабутин" Там теперь соответственно есть удобные C# обертки, которые позволяют вам спокойно подергать некоторые платформы специфик API.
1133.00 1157.44 "Игорь Лабутин" И туда же относится работа с connectivity, то есть допустим, если вам нужна какая-то разная логика работы, если у вас телефончик offline или онлайн, то теперь это можно прям в C# легким проверкой одной пропертии, которая возвращает bool или enum, там онлайн, офлайн, да, спокойно проверить в каком состоянии сейчас телефон и на основе этого строить какую-то логику.
1157.44 1164.84 "Игорь Лабутин" В общем-то все, про Maui больше ничего нового нет, то есть потихонечку улучшают, потихонечку дофикшивают баги.
1164.84 1168.40 "Игорь Лабутин" И я надеюсь, что в скором времени мы все-таки увидим релиз кандидата.
1168.40 1180.60 "Анатолий Кулаков" Да, да, будем надеяться, уже пора бы, тем более что основной фреймворк пока молчит, сейчас очень хорошее время для хороших новостей и соответственно релиз Maui нам бы всем очень пригодился.
1180.60 1183.60 "Анатолий Кулаков" Так, пойдем дальше.
1183.60 1196.64 "Анатолий Кулаков" Я тут набрал на статейку, которую написал Aaron Stennard, это автор akki.net, если вдруг кто не знает, и он тут рассказал про новый OpenTelemetry, его текущее положение, как он к нему относится и что у него там сейчас происходит.
1196.64 1207.24 "Анатолий Кулаков" В общем, мимо двух этих фактов я не мог пройти мимо, статейка не очень глубока оказалась, но все же давайте посмотрим, как Aaron на данном этапе относится к данной теме и что он там делает.
1207.24 1226.12 "Анатолий Кулаков" Во-первых, кратко напомню, что OpenTelemetry появилась из-за того, что у нас стала куча различных микросервисов, которые начали терять какую-то связь между собой, в отличие от, например, Monolith, у которого все workflow, все процессы, они какие-то были внутри собраны и их можно было легко проследить, мониторить, дебажить.
1226.12 1238.00 "Анатолий Кулаков" В общем, с микросервисами мы эту штуку, мы эту привилегию потеряли, потому что каждый деплоится где угодно, ходит кому как захочется и какими-то вопросами и ответами обменивается.
1238.00 1246.32 "Анатолий Кулаков" Поэтому дебаг стал сложным, связанность сервисов стала очень маленькая, непонятно каким образом их теперь мониторить вообще.
1246.32 1260.24 "Анатолий Кулаков" И поэтому индустрия потребовала от девопсов каких-то новых инструментов, того чего не было раньше, и поэтому такими инструментами как раз таки и стали распределенные трассировки, которые очень сильно продвигаются в OpenTelemetry.
1260.24 1269.40 "Анатолий Кулаков" И в частности, Aaron предлагает нам рассмотреть, а что же такого интересного в плане распределенных трассировок в OpenTelemetry и DOT-06 сейчас мы имеем.
1269.40 1284.16 "Анатолий Кулаков" Aaron портировал как раз таки свой проект Phobos 2, это специальный APM-инструмент платный, который позволяет вам мониторить приложение, в том числе приложение с АК, естественно.
1284.16 1299.60 "Анатолий Кулаков" В общем, и он переводил его с OpenTracing и AppMetric, это, в принципе, такая была, наверное, стандартная связка, AppMetric и OpenTracing для того, чтобы каким-то образом выставлять ваши метрики, как-то мониторить ваше приложение.
1299.60 1306.52 "Анатолий Кулаков" В общем, он переводил его на OpenTelemetry и решил с нами поделиться своими наработками, своими наблюдениями.
1306.52 1310.72 "Анатолий Кулаков" Прежде всего, на данный момент мы имеем несколько корневых концепций.
1310.72 1321.80 "Анатолий Кулаков" Это прежде всего Trace, это термин описывает весь реквест от начала до самого конца по распределенным приложениям между всеми сервисами.
1321.80 1330.48 "Анатолий Кулаков" У каждого сервиса есть спаны, это такая атомарная единица одного сервиса внутри приложения, который описывает, что именно он там делал.
1330.48 1335.56 "Анатолий Кулаков" В общем, весь Trace, он по сути состоит из суммы вот этих спанов.
1335.56 1348.88 "Анатолий Кулаков" И по одному Trace мы можем понять, какие сервисы взаимодействовали внутри этого запроса, что они делали, какие ошибки у них были, сколько времени у них на это ушло и прочую диагностическую информацию.
1348.88 1363.48 "Анатолий Кулаков" Также стоит внимание обратить на SpanContext, это такой полезный чемодан, в котором в частности лежит привязка к Span, от которого породился данный Span для того, чтобы строить иерархию и прочие мелочи типа багажа.
1363.48 1372.52 "Анатолий Кулаков" И еще интересная концепция, это Propagations и Propagators, то есть это такие специальные распространители.
1372.52 1382.12 "Анатолий Кулаков" Это инструменты, которые позволяют вам сериализовать и децерализовать данные между различными контекстами вашего приложения.
1382.12 1405.28 "Анатолий Кулаков" Соответственно, для того, чтобы передать, например, вот эти данные отрассировки между HTTP, которые потом пойдут к Redis, после Redis уйдет куда-нибудь в скейнерную базу данных, то есть они будут обмениваться и путешествовать по разным протоколам, им нужно каким-то образом с помощью стандартных инструментов понимать, а как именно в этих протоколах конкретно реализован OpenTelemetry.
1405.28 1407.92 "Анатолий Кулаков" Вот этим и занимаются пропагаторы.
1407.92 1416.52 "Анатолий Кулаков" На данный момент у нас существует два API, которые реализуют OpenTelemetry.
1416.52 1421.72 "Анатолий Кулаков" Во-первых, это SystemDiagnosticActivity, это базовые классы для любого Distributed Tracing.
1421.72 1434.16 "Анатолий Кулаков" И второй API, это OpenTelemetry.API, это тоже отдельная длелька, которая реализовывает тот же самый OpenTelemetry, но в терминах настоящей OpenTelemetry спецификации.
1434.16 1450.04 "Анатолий Кулаков" Как вы уже помните, наверное, мы в предыдущих выпусках это обсуждали, что настоящая OpenTelemetry спецификация и реализация в Дотнете, они полностью не сопоставимы по именам, по классам, по иерархии, в силу исторических причин и якобы так лучше.
1450.04 1463.08 "Анатолий Кулаков" Поэтому OpenTelemetry.API, она выражает все в терминах настоящей спецификации и по сути является просто-напросто оберткой над SystemDiagnosticActivity и всех, соответственно, типов вокруг этого.
1463.08 1470.60 "Анатолий Кулаков" Разработчикам рекомендуется использовать именно Activity, ActivitySource и, в общем, все остальные классы из SystemDiagnostic.
1470.60 1492.12 "Анатолий Кулаков" И большинству разработчиков их хватает с головой в 99% случаев до тех пор, пока вы не начинаете вручную протягивать контексты, протягивать спаны, каким-то образом с ними взаимодействовать, то есть не опускайтесь на более низкий уровень и в этом случае вам уже поможет OpenTelemetry.API.
1492.12 1500.16 "Анатолий Кулаков" Итак, из интересного, то есть как у нас сейчас реализуются пайплайны в нашем приложении.
1500.16 1508.28 "Анатолий Кулаков" Каждый раз, когда у вас создается новый спан, делает этот трейсер с помощью метода StartActiveSpan или может быть ActivityStartActivity.
1508.28 1518.16 "Анатолий Кулаков" В общем, каждый раз, когда вы начинаете новый спан, новую Activity, у вас текущая активность, которую вы только что создали, записывается в статическую переменную ActivityCurrent.
1518.16 1542.68 "Анатолий Кулаков" В общем, это не простая статическая переменная, это специальная AsyncLocal переменная, соответственно, она поддерживает асинхронный код и вместе с вашими Async Await будет безболезненно путешествовать между всеми вашими контекстами, что безумно удобно для быстрого доступа и для диагностирования, для логирования, для записи метрик какой-то очень важной критической информации, без всяких сторонних зависимостей.
1542.68 1549.96 "Анатолий Кулаков" И, в общем, пока активность не закрыта, эта переменная будет вам доступна во всех ваших методах.
1549.96 1558.04 "Анатолий Кулаков" И трейсинги, метрики и на все прочее, что происходит в Application, в вашем приложении, теперь можно подписаться.
1558.04 1561.76 "Анатолий Кулаков" То есть подписаться можно было всегда, но теперь это стало более удобным.
1561.76 1568.64 "Анатолий Кулаков" То есть в новых версиях у вас есть ActivityListener, который как раз таки определяет, какие ивенты вы хотите ловить.
1568.64 1573.52 "Анатолий Кулаков" И этот ActivityListener примечательен тем, что все ивенты он ловит асинхронно.
1573.52 1587.64 "Анатолий Кулаков" То есть вся ваша диагностическая операция, которая туда записалась в каком-то высоконагруженном запросе, она не ждет, пока кто-то, какие-то другие сабскрайберы, которые подписались на эти ивенты, обработают их.
1587.64 1589.84 "Анатолий Кулаков" Она просто продолжает эта логика работать дальше.
1589.84 1603.32 "Анатолий Кулаков" A Listener, соответственно, оповещает всех сабскрайберов, и они уже внутри делают какие-то определенные преобразования, запускают какие-то пайплайны и что-то с этими данными могут делать.
1603.32 1617.64 "Анатолий Кулаков" Например, фильтровать, какие-нибудь агрегировать или готовить к экспорту, или даже, может быть, экспортировать уже непосредственно в какие-то APM-платформы, которые уже непосредственно будут их анализировать, показывать пользователю, сохранять и прочие-прочие вещи творить.
1617.64 1635.00 "Анатолий Кулаков" Для того, чтобы в вашем приложении использовать OpenTelemetry на каких-то определенных протоколах, существует специальный Namespace, который называется OpenTelemetry Instrumentation, и в нем находятся все пакеты, которые позволяют вам заинжектить различные протоколы, а именно вот эти трассировки.
1635.00 1639.52 "Анатолий Кулаков" И есть набор пакетов в OpenTelemetry Exporter.
1639.52 1654.68 "Анатолий Кулаков" Это пакеты, которые являются уже непосредственно APM-специфик, то есть они вам уже говорят, куда можно экспортировать, начиная от In-Memory и консоль экспортера, уже непосредственно в какие-то определенные APM-системы конкретных коммерческих вендоров.
1654.68 1685.04 "Анатолий Кулаков" В общем, по итогу, Аарон безумно доволен, он говорит, что в принципе за этим будущее получается именно то, что он хотел, и все очень удобно, красиво, универсально, самое главное, что это все открыто, и кто угодно может реализовать поддержки, может пилить свои коммерческие APM-системы, то есть и вроде Open Source доволен, и коммерческие ребята все довольны, и сам протокол получился довольно хорошим, удобным и кросс-языковым.
1685.04 1696.80 "Анатолий Кулаков" В общем, соответственно, за этим будущее, и если у вас вдруг появилась такая необходимость, то попробуйте посмотреть именно уже на OpenTelemetry, забыв о всех старых предыдущих библиотеках.
1696.80 1719.88 "Игорь Лабутин" Да, мы не устаем напоминать про эту полезную штуку, про OpenTelemetry, которая действительно довольно сильно развивается, я думаю, что будет дальше развиваться, я немножко упоминал про метрики, это чуть-чуть тоже в эту сторону, так что используйте, смотрите, изучайте, и давайте делать так, чтобы мы использовали все более-менее похожие стандарты.
1719.88 1720.88 "Игорь Лабутин" Поехали дальше.
1720.88 1746.76 "Игорь Лабутин" Visual Studio 2022 version 17.2 preview 2, которую я уже сегодня упоминал в контексте MAUI, вышла, но вышла как-то, по крайней мере на момент записи выпуска, у нас нет прям статьи, как обычно это делается на DevBlocks'ах про выпуск новой версии Visual Studio, но есть, понятно, релиз ноутсы на Docs.Microsoft.com, по ним, собственно, и пробежимся.
1746.76 1755.96 "Игорь Лабутин" Первое, что бросается в глаза, и прям первое и самое большое улучшение, которое прямо написано в релиз ноутсах большими буквами, это улучшение Live Unit Testing.
1755.96 1787.88 "Игорь Лабутин" Не знаю, пользуются ли кто-нибудь когда-нибудь в Visual Studio Live Unit Testing, это фича, которая доступна только в Enterprise версии, и она, по сути, запускает ваши тестики в бэкграунд, то есть понимает, какой код вы поменяли, понимает, какие тесты могли быть затронуты из числа выбранных, то есть вы сначала выбираете набор тестов, дальше она пытается понять, что было затронуто, что нужно пересобрать, и эти тесты в бэкграунде запускает и каким-то образом показывает вам, как там у вас дела, по мере того, как вы работаете над кодом.
1787.88 1803.60 "Игорь Лабутин" В этой версии, соответственно, существенно улучшили работу со сборкой, то есть там теперь они все прям параллельные собираются, собираются только релевантные проекты, они все подряд, и это позволило поддержать прям действительно большие солюшены.
1803.60 1824.80 "Игорь Лабутин" Кроме того, поправили немножко то, как эта вся фича настраивается, там добавили wizard, добавили специальный файлик LUT ignore, ну по образу и подобию гида ignore, где можно указать, какие файлики не трогать и не забирать при сборке и копировании вот этих временных дл, для которых запускаются тесты.
1824.80 1842.08 "Игорь Лабутин" И теперь появилась клевая фича, теперь запуск таких бэкграундных тестов можно отменить, то есть если у вас, например, вы поменяли код так, что у вас тест завис какой-нибудь бесконечный цикл, то раньше нужно было дождаться какого-то специального таймаута, и только после этого все отваливалось, теперь можно это все дело спокойненько заканселить нормально.
1842.08 1855.04 "Игорь Лабутин" Ну и в Test Explorer теперь показывается более правильный прогресс бар, в том числе для обычных тестов, которые вы просто запускаете, более понятно вообще, что происходит с тестами и в каком состоянии у вас запуск.
1855.04 1864.00 "Игорь Лабутин" Про Live Union Testing есть вообще отдельная статья, поэтому если вам интересна эта фича, можете посмотреть, у нас она в шоуноутах будет.
1864.00 1865.00 "Игорь Лабутин" Продолжаем про студию.
1865.00 1869.84 "Игорь Лабутин" Доттонадд продуктивити раздел обзавелся следующими штуками.
1869.84 1882.20 "Игорь Лабутин" Во-первых, в очередной раз, по-моему, мы уже это говорили, но мне кажется, точно обсуждали такую новость, но тем не менее, добавили поддержку Embedded Sources и Source Link, когда мы используем GoToImplementation.
1882.20 1886.52 "Игорь Лабутин" Может быть в тот раз была GoToDefinition, не знаю.
1886.52 1896.96 "Игорь Лабутин" Ну короче, потихонечку допиливают поддержку исходников, и теперь если у вас есть Source Link либо Embedded Sources в NuGet пакете, то они будут использованы для GoToImplementation.
1896.96 1903.24 "Игорь Лабутин" В седьмом доттонадде добавили новый атрибут под названием String Syntax Attribute.
1903.24 1913.80 "Игорь Лабутин" Это позволяет разметить строчку этим атрибутом и указать, что внутри этой строчки, например, JSON, или SQL, или еще какой-нибудь язык.
1913.80 1925.92 "Игорь Лабутин" И после этого, на основе значения этого атрибута, получается, что можно попытаться, допустим, подсветить строчку внутри, согласно синтаксису того, что написано в этом атрибуте.
1925.92 1930.08 "Игорь Лабутин" Вот как раз вижу в студии, в этом превью завезли подсветку JSONчиков.
1930.08 1941.40 "Игорь Лабутин" То есть если вы пометите вашу строчку атрибутом String Syntax Attribute и поставите там JSON, то внутри этой строчки JSON будет расцвечен, прямо как положено JSON.
1941.40 1945.28 "Игорь Лабутин" Не знаю, что там еще работает, пока написано, что только Highlights.
1945.28 1959.84 "Игорь Лабутин" Допилили некоторое количество новых рефакторингов вокруг новых фич C#, добавили немножко новых опций конфигурации и улучшили код Cleanup, чтобы он поддерживал вообще все возможные опции код стайла.
1959.84 1962.96 "Игорь Лабутин" Потому что раньше код Cleanup не все поддерживал, не все позволял настроить.
1962.96 1969.04 "Игорь Лабутин" Кроме этого, завезли улучшения в Razor Editor, если вы зачем-то им пользуетесь.
1969.04 1976.76 "Игорь Лабутин" В Container Tool чуть-чуть улучшили работу с докером и докерфайлами.
1976.76 1985.36 "Игорь Лабутин" Если вы отлаживаете .NET приложения, которые запущены на Windows Subsystem for Linux в ESL, то там появилось некоторое количество улучшений.
1985.36 1994.24 "Игорь Лабутин" Ну и, как обычно, не обошли вниманием Major и Web сценарий, там тоже довольно много всяких разных улучшений, но я не буду на них сильно останавливаться.
1994.24 2000.04 "Игорь Лабутин" Да, про отладку есть еще такая, ну одна новая штука на самом деле про отладку.
2000.04 2032.76 "Игорь Лабутин" Если у вас есть IEnumerable, то теперь рядом с IEnumerable переменной, ну если вы в Watch, либо если вы просто смотрите на нее, когда наводите курсор мышки, появляется теперь новая иконочка, потому что Microsoft в новой Visual Studio запилила визуалайзер для IEnumerable, который, естественно, его проэтерирует, но это можно было делать и раньше, можно было нажать плюсик, он там предупреждал, что получение результатов приведет к тому, что мы проконсимим этот IEnumerable, вы соглашались и получали собственно плоский список.
2032.76 2045.48 "Игорь Лабутин" Но как правило в IEnumerable мы храним объекты или вообще анонимные объекты даже, да, если там в Selective использовали анонимные, значит, New, то там будут просто какие-то объекты.
2045.48 2061.52 "Игорь Лабутин" Так вот теперь есть специальный визуалайзер, который все это дело покажет в табличном виде, причем в колонке можно добавлять-удалять, то есть если вы смотрите коллекцию IEnumerable для каких-то сложных объектов, вы сможете выбрать нужные вам колонки для визуализации и посмотреть прям табличку с тем, что лежит внутри IEnumerable.
2061.52 2065.52 "Анатолий Кулаков" А фильтровать желательно с полным линкой с синтаксисом?
2065.52 2069.56 "Игорь Лабутин" Ну да, и SQL тебе туда же допиши, нет, такого пока нету.
2069.56 2073.56 "Анатолий Кулаков" Ну жадины, жадины, уже альтернативные инструменты давно это умеют.
2073.56 2077.08 "Игорь Лабутин" Ну, в общем, они не спешат, доделывают.
2077.08 2079.68 "Игорь Лабутин" У них, видимо, народу мало, не знаю, много других фич.
2079.68 2080.68 "Игорь Лабутин" Вот.
2080.68 2087.84 "Игорь Лабутин" И в Git, как обычно, тоже появилось некоторое количество улучшений, добавили Interactive Staging, ну, то есть не добавили, а улучшили.
2087.84 2109.16 "Игорь Лабутин" Улучшили переключение бранчей и улучшили поддержку, когда вы работаете в режиме Detached Head, то есть когда вы зачекалите лишь что-то, что не является хэдом сейчас, какой-то промежуточный коммит, и дальше при переключении на какую-то уже реально существующую ветку студия чуть лучше обрабатывает эту ситуацию и спрашивает, собственно, что мы будем делать с файликами.
2109.16 2110.92 "Игорь Лабутин" Ну, вот примерно так про студию.
2110.92 2111.92 "Анатолий Кулаков" Отлично.
2111.92 2131.44 "Анатолий Кулаков" У меня здесь есть статичка из темы по Best Practices, давно у нас такого не было, поэтому решил достать и небезызвестного Стиффена Клэри, у которого есть замечательные книги по Concurrency, у него есть замечательный блог про, опять же, Concurrency, трейдинг, таски, вообще все, что касается Concurrency.
2131.44 2132.44 "Анатолий Кулаков" Один из лучших блогов.
2132.44 2138.16 "Анатолий Кулаков" Если вдруг вас интересует тема, то обязательно ознакомьтесь, если вы, соответственно, еще не видели.
2138.16 2143.52 "Анатолий Кулаков" И вот у Стиффена Клэри вышла замечательная статья, в которой он описывает Value-tasks.
2143.52 2158.04 "Анатолий Кулаков" В общем, Value-tasks появились на свет еще в Core 1, и они были представлены миру как что-то, что мега сильно оптимизирует асинхронный код или еще какой-то там волшебной магией занимается, в общем.
2158.04 2164.48 "Анатолий Кулаков" И вот Стиффен разобрался и расписал нам, какие же подводные камни.
2164.48 2169.68 "Анатолий Кулаков" Самое главное есть у этого подхода, и я предлагаю с ними так разобраться.
2169.68 2173.16 "Анатолий Кулаков" Статья называется «Ограничения в Value-tasks».
2173.16 2176.04 "Анатолий Кулаков" И, соответственно, поехали по порядку.
2176.04 2194.52 "Анатолий Кулаков" Прежде всего, как я уже сказал, Value-tasks появились достаточно давно, и изначально они позиционировали себя как более улучшенные таски, которые дают вам больше преимуществ и больше возможностей.
2194.52 2202.48 "Анатолий Кулаков" И в последнее время они становятся все более и более популярными, несмотря на то, что когда они появились, они использовались только фреймворком.
2202.48 2216.24 "Анатолий Кулаков" Сейчас, когда уже появляется асинхронный dispose, когда у нас появляются асинхронные стримы, которые async/enumerable, вот Value-tasks все чаще и чаще начинают использоваться обычными смешными, обычными разработчиками.
2216.24 2223.92 "Анатолий Кулаков" И, соответственно, знать о их ограничениях нужно уже буквально практически все.
2223.92 2228.40 "Анатолий Кулаков" Может быть, это одна из тех вещей, которые скоро нас будут спрашивать на собеседованиях.
2228.40 2229.40 "Анатолий Кулаков" Поживем - увидим.
2229.40 2234.48 "Анатолий Кулаков" Соответственно, зачем нужны были Value-tasks?
2234.48 2240.96 "Анатолий Кулаков" Как я раньше сказал, первое позиционирование было, что это более эффективная замена обычных старых унылых референсов тасков.
2240.96 2246.56 "Анатолий Кулаков" Ну, это не совсем так, но давайте, в принципе, разберемся с основной позицией.
2246.56 2257.96 "Анатолий Кулаков" Самая главная фишка Value-tasks в том, что они Value, то есть они Value-тип, и поэтому не аллокейтят новой памяти, в отличие от референс-типов.
2257.96 2274.72 "Анатолий Кулаков" И в таких случаях, например, когда в вашем асинхронном коде вы уже заранее знаете значение, которое необходимо вернуть, но ваша сигнатура требует возвращения таски, обычно программисты пишут "task from result", то есть они делают некий враппер, оборачивают свой результат и возвращают его.
2274.72 2295.56 "Анатолий Кулаков" Это работает нормально, если, соответственно, ваш код не очень высоко нагруженный, но если у вас там миллиард запросов в секунду, то вот этот "task from result" превращается в большую головную боль, потому что фактически на каждый вызов он создает враппера, то есть он создает новый объект, который, естественно, аллоцирует память, и у нас получается нагрузка на ГЦ.
2295.56 2304.76 "Анатолий Кулаков" Value-task избавлен от этой проблемы, потому что это Value-тип, никакой памяти он не аллоцирует, ГЦ вообще его никак не трогает, и он ГЦ тоже, соответственно, никак не трогает.
2304.76 2311.04 "Анатолий Кулаков" И из-за этого получается более эффективный код в тех случаях, когда значение вам предварительно известно.
2311.04 2323.68 "Анатолий Кулаков" Но из-за специфики работы Value-task, и может быть потому, что они делались уже после настоящих task реализовывались, есть некий прямо асинхронный сценарий, где они тоже выигрывают у task.
2323.68 2327.20 "Анатолий Кулаков" Но обо всем по порядку.
2327.20 2336.72 "Анатолий Кулаков" Прежде всего, Value-task могут вам пригодиться в вашей повседневной жизни, и поэтому вам нужно знать об их ограничениях.
2336.72 2343.32 "Анатолий Кулаков" К счастью, таких ограничений немного, всего два, но к несчастью, они очень мощные, они очень зверские.
2343.32 2365.88 "Анатолий Кулаков" Поэтому каждый член вашей команды перед тем, как использовать Value-task, обязан понимать, как они работают, что они делают, и даже более того, если вы пишете, например, в библиотечке, которую распространяете среди неизвестных людей, непонятно, кто их потом будет использовать, но каждый потребитель вашей библиотеки обязан четко понимать, как работают Value-tasks.
2365.88 2369.76 "Анатолий Кулаков" Отсюда мы приходим к выводу, что вообще, наверное, каждый разработчик должен понимать.
2369.76 2376.96 "Анатолий Кулаков" И, соответственно, сейчас мы попытаемся дать вам вот это понимание, а что же, соответственно, нужно знать такого о Value-task.
2376.96 2386.68 "Анатолий Кулаков" Прежде всего, первое правило, только один раз можно потреблять Value-task, то есть только один раз вызвать у него evade.
2386.68 2394.72 "Анатолий Кулаков" И после того, как вы вызвали evade, нужно сразу забыть про Value-task и больше ничего с ним не делать и никак не использовать.
2394.72 2407.72 "Анатолий Кулаков" Потому что Value-tasks на самом деле реализованы как reusable объекты, то есть они внутри себя могут переиспользовать то значение, которое возвращают.
2407.72 2412.52 "Анатолий Кулаков" И, соответственно, внутри себя Value-tasks они mutable.
2412.52 2415.36 "Анатолий Кулаков" И это сделано, соответственно, ради перформанса.
2415.36 2422.56 "Анатолий Кулаков" В общем, на ради перформанса мы идем на многое, и в частности мы придумали mutable value-типы.
2422.56 2423.56 "Анатолий Кулаков" Почему это необычно?
2423.56 2432.72 "Анатолий Кулаков" Потому что, наверное, сложно вспомнить любой другой mutable value-тип, потому что любые другие примитивные переменные структуры и value-типы ведут себя абсолютно не так.
2432.72 2442.20 "Анатолий Кулаков" Поэтому это может быть большим сюрпризом для разработчиков, которые использовали .NET до Value-task.
2442.20 2448.76 "Анатолий Кулаков" Еще раз повторюсь, что как все потребители должны сделать просто await, как положено, и все.
2448.76 2459.88 "Анатолий Кулаков" Или можно вызвать ас-таск, это специальный конвертер, который конвертирует Value-task в Reference-task со всеми вытекающими минусами, но и без этих ограничений.
2459.88 2468.60 "Анатолий Кулаков" То есть, если вы захотите вызвать несколько await на вашем Value-task, то этого делать нельзя.
2468.60 2477.72 "Анатолий Кулаков" Также, если вы захотите применить методы task.thenAll и task.thenAny на вашем Value-task, то этого тоже делать нельзя.
2477.72 2481.08 "Анатолий Кулаков" Иначе будет недекларируемое поведение.
2481.08 2483.48 "Анатолий Кулаков" Что произойдет в этом случае, что взорвется, вы не знаете.
2483.48 2485.80 "Анатолий Кулаков" То есть, просто делать этого нельзя.
2485.80 2500.28 "Анатолий Кулаков" Если же вам это нужно сделать по какой-то логике или по еще чему-то, или очень сложно обойти, то вызывайте метод конвертер, который называется as-task, и он конвертирует ваш Value-task в Reference-task.
2500.28 2513.64 "Анатолий Кулаков" И соответственно, этот Reference- полученный task вы уже можете несколько раз await, вы уже можете передавать его to thenAll и делать с ним абсолютно все то же самое, к чему вы привыкли в обычных task.
2513.64 2515.52 "Анатолий Кулаков" Это было первое правило.
2515.52 2518.80 "Анатолий Кулаков" Нельзя несколько раз await Value-task.
2518.80 2526.68 "Анатолий Кулаков" Второе важное правило, и оно же последнее, это потреблять Value-task можно только асинхронно.
2526.68 2533.04 "Анатолий Кулаков" Никакие синхронные и блокирующие операции с Value-task делать нельзя.
2533.04 2540.04 "Анатолий Кулаков" Под блокирующими операциями я понимаю getAwaiter, getResult, .result, .await.
2540.04 2549.36 "Анатолий Кулаков" В общем, вот эти очень bad practices, которые нам тоже в каждой статье Power-O Asynchronous советуют не делать.
2549.36 2559.48 "Анатолий Кулаков" Но если с Reference-types, если вам сильно припечет, их сделать можно, то с Value-types их вообще делать нельзя, потому что это тоже непредсказуемое поведение.
2559.48 2563.60 "Анатолий Кулаков" То есть, это тоже непонятно, что взорвется, если вы вдруг к этому обратитесь.
2563.60 2567.08 "Анатолий Кулаков" И соответственно, с Value-task это абсолютно не работает.
2567.08 2583.24 "Анатолий Кулаков" Если вы хотите для чего-то сделать вот эти богомерзкие операторы, методы вызвать, то здесь такая же рекомендация, конвертируйте с помощью stask и используйте уже обычный Reference-task со всеми вытекающими локациями, но с большей функциональностью.
2583.24 2590.20 "Анатолий Кулаков" В принципе, казалось бы, вот такие простые два правила, но они довольно-таки неочевидны.
2590.20 2597.44 "Анатолий Кулаков" Во-первых, неочевидно, потому что Value-task все-таки воспринимается как структура, и никто от него не ожидает мьютабельности.
2597.44 2601.68 "Анатолий Кулаков" А во-вторых, Value-task, он обычно по сигнатуре полностью совпадает с таском.
2601.68 2616.96 "Анатолий Кулаков" И поэтому всем кажется, что если мы раньше использовали таски, а теперь давайте все сделаем реплейсом просто-напросто все таски на Value-task, всю логику, весь обрабатывающий код оставим на месте, не будем его трогать, и у нас все прекрасно заработает, то вот, к сожалению, нет.
2616.96 2630.24 "Анатолий Кулаков" Несмотря на все совпадение по сигнатурам, и несмотря на то, что компилятор все это проглотит и никаких проблем не расскажет, в рантайме это все может очень сильно умереть и, к сожалению, с очень плохой диагностикой иногда.
2630.24 2644.52 "Анатолий Кулаков" Еще хочется обратить внимание на библиотеки, то есть почему эта отдельная сложность возникает с библиотеками, которые в своей сигнатуре, в своем API декларируют Value-tasks.
2644.52 2651.16 "Анатолий Кулаков" Дело в том, что Value-tasks бывают трех видов, их реализация на самом деле, имплементация, она бывает трех видов.
2651.16 2660.80 "Анатолий Кулаков" Во-первых, это обычная обертка над уже полученным, уже известным значением, как обычный fromResult, например, это самый простой тип.
2660.80 2672.64 "Анатолий Кулаков" Также существует обертка над reference-task, то есть когда у нас действительно есть какая-то синхронная операция, долго выполняющаяся, но метод вернул Value-task, создается некая оберточка, которая ждет настоящий reference-task.
2672.64 2679.40 "Анатолий Кулаков" И самый сложный, но при этом самый эффективный и оптимизированный - это обертка над task-source.
2679.40 2691.12 "Анатолий Кулаков" Ну, соответственно, да, есть у вас task-source, это тоже управление как бы reference-task, и он оптимизирован специально под Value-tasks, чтобы тоже работать мега-эффективно.
2691.12 2698.44 "Анатолий Кулаков" И если вы нарушаете два вот этих правила, которые мы обсудили выше, как я уже говорил, у вас будет непредсказуемое поведение.
2698.44 2708.24 "Анатолий Кулаков" И сложность, проблема заключается в том, что это непредсказуемое поведение, оно разное у всех этих трех оберток, у всех этих трех имплементаций.
2708.24 2709.92 "Анатолий Кулаков" Ну, может быть пока трех.
2709.92 2711.84 "Анатолий Кулаков" Но проблема в том, что она разная.
2711.84 2715.00 "Анатолий Кулаков" И полностью зависит от того, что подставится.
2715.00 2720.60 "Анатолий Кулаков" А что подставится, оно тоже как бы сильно не декларируется, от версии к версии может поменяться.
2720.60 2721.60 "Анатолий Кулаков" Ну, допустим.
2721.60 2724.08 "Анатолий Кулаков" Допустим, есть у вас библиотека версии 1.
2724.08 2734.92 "Анатолий Кулаков" И эта библиотека на самом деле возвращает из какого-то метода Value-task, и на самом деле это обертка над reference-task.
2734.92 2748.28 "Анатолий Кулаков" Ваши потребители установили вашу библиотечку из Nuget, радостно посмотрели на метод, увидели Value-task и начали по старой памяти вызывать несколько раз await на нем, потому что они всегда так делали на тасках.
2748.28 2754.28 "Анатолий Кулаков" Или вдруг почему-то совсем их приспичило, и они начали блокирующие операции делать на вашем Value-task.
2754.28 2759.16 "Анатолий Кулаков" И к сожалению или к счастью, этот код будет работать.
2759.16 2768.24 "Анатолий Кулаков" Потому что в текущей имплементации, на текущей версии обертка над reference-task, эти все манипуляции она поддерживает.
2768.24 2774.00 "Анатолий Кулаков" Несмотря на то, что по спецификации приложения не декларированное поведение, оно не означает обязательно ошибку.
2774.00 2776.44 "Анатолий Кулаков" Оно может означать, что это иногда работает.
2776.44 2779.12 "Анатолий Кулаков" Вот мы направились на тот случай, когда оно иногда работает.
2779.12 2796.36 "Анатолий Кулаков" Но тут вдруг выходит версия 1.0.1, которая в принципе не меняет публичную сигнатуру метода, поэтому она всего-лишь навсего исправляет какой-то маленький баг, увеличивает минорную версию, на которую обычно никто не смотрит и автоматически обновляет до последней минорной версии.
2796.36 2805.44 "Анатолий Кулаков" Но внутри, в реализации, мы переключились с обертки над reference-task на обертку над task-sources.
2805.44 2811.04 "Анатолий Кулаков" И у обертки над task-sources уже поведение абсолютно другое.
2811.04 2817.04 "Анатолий Кулаков" Все те консюмеры, которые раньше творили непотребство с вашим Value-task, теперь сломаются.
2817.04 2823.16 "Анатолий Кулаков" К сожалению, они сломаются не в compile-time, а в run-time.
2823.16 2829.60 "Анатолий Кулаков" И соответственно, если вдруг кто-то делал блокировки, у них начнут лететь exceptions.
2829.60 2841.32 "Анатолий Кулаков" Если кто-то делал несколько вызовов, несколько await-ов над этим Value-task, то у них будет поведение намного сложнее и страшнее.
2841.32 2850.28 "Анатолий Кулаков" Потому что там уже эти Value-tasks будут переиспользоваться и соответственно, поведение будет абсолютно непредсказуемым.
2850.28 2857.68 "Анатолий Кулаков" И например, ваш код может ожидать той операции, того task, который никогда еще даже не стартовал.
2857.68 2861.64 "Анатолий Кулаков" И отладить такое безумно сложно, поймать такое безумно сложно.
2861.64 2868.60 "Анатолий Кулаков" И даже ими отладчик уже прицепленный, несмотря на то, что если там кто-то уже в продакшене все это будет спускать.
2868.60 2871.56 "Анатолий Кулаков" В общем, это очень трудно уловимый баги.
2871.56 2873.68 "Анатолий Кулаков" Лучше к таким просто не доводить.
2873.68 2887.12 "Анатолий Кулаков" И поэтому вот эти правила, их нужно очень четко соблюдать, очень четко соответствовать и помнить, что даже если сигнатура не поменялась у метода, это все-таки может быть breaking changes.
2887.12 2892.00 "Анатолий Кулаков" И от таких breaking changes еще непонятно, как декларировать, как защищаться.
2892.00 2896.96 "Игорь Лабутин" Звучит это все очень страшно и кажется, что Value-tasks вообще пользоваться не надо никогда.
2896.96 2906.76 "Анатолий Кулаков" Действительно это так, но к сожалению, очень много команда Microsoft вложила в их оптимизацию, не к сожалению, а к счастью, что она вложила в их оптимизацию.
2906.76 2911.20 "Анатолий Кулаков" И они дают безумный прирост реально в перформанс местах.
2911.20 2923.84 "Анатолий Кулаков" И там, где все-таки у вас есть перформанс места, скорее всего у вас должны работать специалисты, которые четко понимают когда, где и как использовать структуру, использовать Value-tasks и что им за это будет.
2923.84 2931.04 "Анатолий Кулаков" Но действительно просто так к таким участкам вашего кода, просто так любого разработчика допускать не стоит.
2931.04 2933.16 "Анатолий Кулаков" Он может там натворить уйму вещей.
2933.16 2943.68 "Анатолий Кулаков" И Клэрри придерживается такого принципа и нам велит, что если вам хватает таски, обычной референс таски, то используйте ее.
2943.68 2949.08 "Анатолий Кулаков" Если уже вам нужны какие-то страшные перформансы оптимизации, вот тогда смотрите, переходите на Value-tasks.
2949.08 2955.08 "Анатолий Кулаков" В общем, но пока вам это не нужно, упростите себе жизнь и жизнь всем вашим потребителям.
2955.08 2956.84 "Анатолий Кулаков" В общем, не ищите проблем.
2956.84 2962.44 "Анатолий Кулаков" Он говорит, что в принципе знает очень много умных дядек, у которых мнения полностью противоположны.
2962.44 2972.92 "Анатолий Кулаков" Обычно это дядьки, это какие-нибудь перформанс инженеры, которые очень хорошо разбираются и они вообще наоборот советуют всем использовать Value-tasks, забудьте про этот старый Legacy-task, никто ими больше не пользуется.
2972.92 2997.48 "Анатолий Кулаков" Он говорит, что в принципе, может быть в будущем, когда программисты станут более ответственные, более грамотные или может у нас появятся более лучшие глубокие анализаторы, которые предотвратят нас от всех этих глупостей, может быть он с ними согласится, но на данный момент он все-таки рекомендует и придерживается той рекомендации, которую давал еще в своей великолепной книге, что используйте по умолчанию таски.
2997.48 3004.28 "Анатолий Кулаков" Не лезьте в Value-tasks, если вам это действительно не нужно и тем более, если вы не понимаете, как они внутри работают и что они там делают.
3004.28 3011.76 "Игорь Лабутин" А если вы очень хотите туда залезть, то как с любой перформанс-штукой, мерите, мерите и еще раз мерите, не устаем это напоминать.
3011.76 3013.80 "Игорь Лабутин" Поехали дальше.
3013.80 3020.48 "Игорь Лабутин" Дальше у нас еще кусочек про Visual Studio, но на этот раз это Visual Studio 2022 for Mac.
3020.48 3023.04 "Игорь Лабутин" И у нее вышло превью 7.
3023.04 3030.04 "Игорь Лабутин" Там тоже не то чтобы прям сильно большой прогресс, потому что там большая работа проводится над стабилизацией, всего и вся.
3030.04 3039.08 "Игорь Лабутин" И в данном случае завезли довольно большое количество багфиксов вокруг Xamarin, Xamarin Mobile Tooling конкретно.
3039.08 3055.72 "Игорь Лабутин" И более того, так же как с SPNet, я говорил, что там по ISU Microsoft хочет фидбэка, в данном случае Microsoft сказала, что все, вроде как Xamarin Mobile Tooling сейчас довели до такого состояния, что мы готовы слушать ваш фидбэк.
3055.72 3061.08 "Игорь Лабутин" То есть мы считаем, что всякие основные баги мы пофиксили, так что если есть фидбэк, присылайте.
3061.08 3079.12 "Игорь Лабутин" При этом надо понимать, что Visual Studio 2022, она вроде как превью 7, при этом там, например, вот в 7 превью был пофикшен баг, в виду что если вы отлаживаете дллку и установили там breakpoint, то execution не будет остановлено на таком breakpoint.
3079.12 3088.12 "Игорь Лабутин" То есть бага выглядит как, ну по крайней мере по описанию, она выглядит как какой-то довольно основополагающий, то есть это прям один из базовых сценариев отладки, наверное.
3088.12 3101.64 "Игорь Лабутин" Ну хорошо, дллки по сравнению с основным приложением не знаю, но в принципе да, приложение всегда состоит, или зачастую состоит из основного экземодуля, да, и куча дллок вокруг, может быть даже не обязательно вытащенных из нугета.
3101.64 3107.84 "Игорь Лабутин" Поэтому кажется, что там все-таки все еще не настолько прям супер стабильно, но тем не менее работа идет.
3107.84 3116.92 "Игорь Лабутин" Как мы помним по прошлым превью, очень много работы было вложено в то, чтобы UI был нативный macOS, и теперь вроде как вся эта работа закончена.
3116.92 3121.48 "Игорь Лабутин" По идее полностью теперь UI в Visual Studio полностью натив macOS.
3121.48 3139.88 "Игорь Лабутин" И последнее, что добавили, это в 6.NET добавили, мы про это немножко упоминали, Azure Functions новую версию, которая собственно работает на 6.NET, в Visual Studio macOS добавили возможность с ними работать, то есть теперь можно Serverless писать на Azure Functions на Mac'е на Visual Studio.
3139.88 3142.08 "Игорь Лабутин" В общем-то и все.
3142.08 3150.36 "Игорь Лабутин" Там точно так же работа по стабилизации, ждем официального большого релиза, но там пока я не слышал каких-то прям конкретных планов по срокам.
3150.36 3154.20 "Игорь Лабутин" Я так понимаю, что как только достаточно тут стабильным, так и зарелизят.
3154.20 3163.04 "Анатолий Кулаков" Слушай, а мы когда обсуждали всякие распространения и использования различных IDI-шек, ты случайно не помнишь, какой там процент у этой Visual Studio for Mac, то есть вообще их кто-то пользуется или нет?
3163.04 3167.56 "Игорь Лабутин" Слушай, по-моему какой-то он не нулевой был, но мне кажется типа меньше десятки точно.
3167.56 3169.72 "Игорь Лабутин" Вообще там он какой-то мизерный был.
3169.72 3172.32 "Анатолий Кулаков" Ну десятка, да, десятка тоже наверное было приличным.
3172.32 3178.72 "Анатолий Кулаков" Я пока не понимаю, как он работает рядом со своими конкурентами, то есть с Visual Studio Code в основном, да, и Ryder'ом.
3178.72 3182.04 "Анатолий Кулаков" То есть какую позицию он там держит и для чего он вообще существует?
3182.04 3189.64 "Игорь Лабутин" Ну, я не знаю, я на маке особо не работаю, поэтому ничего сказать не смогу и у меня нет такой статистики.
3189.64 3199.08 "Игорь Лабутин" Возможно, я кстати думаю, даже сейчас начался год, по идее скоро начнутся всякие Stack Overflow опросы, вот это всё, я думаю, что мы скоро будем иметь какую-то более-менее свежую информацию.
3199.08 3201.08 "Анатолий Кулаков" Да, да, интересно посмотреть.
3201.08 3208.72 "Анатолий Кулаков" Так, я думаю, что мы тут уже статичками затронули практически все слои населения, кроме знаешь кого, кроме начинающих.
3208.72 3222.08 "Анатолий Кулаков" И вот прямо для начинающих, я думаю, им такая статика должна зайти, я нашел хорошую штуку про хорошее описание енумов, то есть что каждый разработчик обязан знать о енумах.
3222.08 3230.56 "Анатолий Кулаков" Как ты думаешь, насобираются ли тут какие-нибудь факты, которые будут повседневно полезны разработчикам и которые они не знали?
3230.56 3234.12 "Анатолий Кулаков" Вот лично для тебя, как ты думаешь, узнаешь ли из этой статики что-нибудь новое или нет?
3234.12 3241.40 "Игорь Лабутин" Ну, как правило, я из многих статей узнаю на самом деле какие-то мелочи или вспоминаю, что я их когда-то знал, но забыл.
3241.40 3243.44 "Игорь Лабутин" То есть, наверное, что-то новенькое, может, и узнаю
3243.44 3245.44 "Анатолий Кулаков" вполне. Ну, ладно, давай попробуем.
3245.44 3258.20 "Анатолий Кулаков" Статика не то, чтобы совсем откровенная, но хороший такой свод правил для того, чтобы как-то поработать с енумами, которые, казалось бы, тоже безумно простая штука, что там можно такое выдумать.
3258.20 3263.20 "Анатолий Кулаков" Но на три статейки у автора насобиралось материала, давайте же посмотрим, что он там накопал.
3263.20 3275.32 "Анатолий Кулаков" Ну, прежде всего, стоит сказать, что енумы, это, соответственно, в чистом виде, это просто-напросто именованный номерик, какие-то числовые значения.
3275.32 3286.76 "Анатолий Кулаков" И в этих числовых значениях могут быть представлены такие типы, как byte, short, int, long и, соответственно, их unsigned, беззнаковые тоже, друзья.
3286.76 3300.64 "Анатолий Кулаков" По умолчанию все енумы, это static int32 значения имеют, и это легко видно, если вы откроете, например, в ILL ваш енамчик, то увидите, что это просто-напросто класс со статическими интовыми полями.
3300.64 3304.24 "Анатолий Кулаков" Вот, и ну плюс какие-то там магические атрибуты, магические методы.
3304.24 3305.24 "Анатолий Кулаков" Не суть важно.
3305.24 3324.88 "Анатолий Кулаков" Всегда первый элемент у нас имеет значение 0, если вдруг по дефолту, если вдруг не сказано иного, и все остальные элементы просто-напросто прибавляются, плюс единичка, поэтому у каждого енамчика элемента вы можете, соответственно, вы можете проверить, вы можете использовать два значения.
3324.88 3331.80 "Анатолий Кулаков" Имя, которое вы видите, и неявную цифру, которая с ним ассоциирована.
3331.80 3345.28 "Анатолий Кулаков" Вы также можете, соответственно, назначить первому элементу абсолютно любую цифру, и уже начиная с этой цифры, все остальные будут делать плюс один, то есть начнут свой счет именно с этого первого элемента.
3345.28 3357.36 "Анатолий Кулаков" Это немножко плохо, потому что если вы перетасуете, поменяете сортировку у вашего enum, то все, соответственно, цифры, которые проставлены автоматически, они тоже поедут.
3357.36 3365.28 "Анатолий Кулаков" Может быть для вашего приложения это не критично, но если критично, то непосредственно цифры можно проассоциировать с каждым элементом enum.
3365.28 3372.52 "Анатолий Кулаков" Вот, теперь давайте рассмотрим, какими же способами можно извлечь имя из конкретного значения enum.
3372.52 3386.48 "Анатолий Кулаков" То есть если у нас есть enum, у которого значение там mail, мы можем сделать с помощью нового оператора nameof, и уже на этапе компиляции мы получим строковое представление этого значения.
3386.48 3398.64 "Анатолий Кулаков" Или же можно сделать у статического метода, у enum вызвать статический метод getName, передать ему непосредственно то значение, из которого мы хотим извлечь имя, и нам тоже вернется строка.
3398.64 3400.80 "Анатолий Кулаков" В рантайме же это сделать гораздо проще.
3400.80 3411.76 "Анатолий Кулаков" Мы можем сделать toString или enum.format, вызвать такой метод, и он отформатирует уже в виде строкового представления, если мы формат передаем в специальный флажочек j.
3411.76 3424.40 "Анатолий Кулаков" И если вдруг вы захотите воспользоваться числовым представлением enum, то всего лишь навсего вам нужно это значение обычного enum скастить к nt, и у вас будет циферка, которую вы тоже можете как-то уже у себя использовать.
3424.40 3427.40 "Анатолий Кулаков" Обратное преобразование, соответственно, делается с помощью парсинга.
3427.40 3433.32 "Анатолий Кулаков" enum.tryParse может вам из строки создать enumовское значение.
3433.32 3442.24 "Анатолий Кулаков" И еще один важный метод, про который многие забывают, но который должен быть просто в каждом методе, это enum.isDefined.
3442.24 3452.60 "Анатолий Кулаков" Это специальный метод, который проверяет, действительно ли строка с подобным значением объявлена за декларированным в данном enum.
3452.60 3454.84 "Анатолий Кулаков" Почему это важно, мы рассмотрим чуть-чуть попозже.
3454.84 3462.32 "Анатолий Кулаков" Также у нас существует еще одна такая в сторонке стоящая структурка, это флаговые enum.
3462.32 3466.28 "Анатолий Кулаков" Они всего лишь навсего отличаются тем, что на обычный enum навешивают атрибут flags.
3466.28 3483.44 "Анатолий Кулаков" Его фишка заключается в том, что теперь этот enum может принимать несколько значений, и между этими значениями очень удобно делать битовые операции, такие как or, end или xor, и, соответственно, можете как-то ими манипулировать и что-то с ними делать.
3483.44 3496.20 "Анатолий Кулаков" Здесь единственное замечание, что значение у этих флаговых enum должно быть степенью двойки, не так, как раньше 1, 2, 3, 4, 5, а 1, 2, 4, 8 и так далее.
3496.20 3511.20 "Анатолий Кулаков" И, соответственно, если у вас будет значение степени двойки, то любые бинарные операции, например, объединяющие и или, они могут соединять вам какие-то новые кортежи, которые будут легко храниться, которые будут легко проверяться.
3511.20 3518.44 "Анатолий Кулаков" И туда можно записывать какую-то удобную логику, которая объединяет себе несколько таких флагов.
3518.44 3529.12 "Анатолий Кулаков" Соответственно, проверить, установлен данный флаг или нет, данные значения enum или нет, в этом кортеже, который может быть собран из нескольких значений, можно с помощью метода has_flag.
3529.12 3541.76 "Игорь Лабутин" Надо добавить, что на самом деле values не обязательно прям строго должны быть степенью двойки, то есть понятно, что индивидуальные флажки должны быть степенью двойки по понятным причинам, чтобы они соответствовали разным битам в этом самом целом числе.
3541.76 3560.52 "Игорь Лабутин" Но никто не мешает вам прямо в этом enumчике объявить какое-нибудь, не знаю, поле под названием all, и туда прямо сразу в определении enum через или прописать все значения, и таким образом проставить ему значения, соответствующие всем флагам сразу.
3560.52 3563.48 "Игорь Лабутин" То есть в принципе это допустимо, так делать можно.
3563.48 3566.68 "Анатолий Кулаков" Ну и даже более того, так делать очень удобно.
3566.68 3578.40 "Анатолий Кулаков" Если вы декларируете там свои фильтры, допустим, то очень удобно именно благодаря вот таким alias, грубо говоря, к какому-то уже сотрого определенному набору уже подсобирать какие-то фильтры.
3578.40 3588.52 "Анатолий Кулаков" В общем, если вы часто пользуетесь Reflection, то Reflection любит принимать вот такие флаговые enum, которые показывают, а что делать, какие поля доставать, а какие аксессоры у филдов использовать.
3588.52 3593.24 "Анатолий Кулаков" В общем, стандартный BCL очень сильно этой возможностью
3593.24 3605.96 "Игорь Лабутин" пользуется. И для флаговых enum еще один момент, очень рекомендую всегда добавлять дефолтный, ну то есть самый первый элемент под названием какой-нибудь none, и присваивать ему значение 0.
3605.96 3609.80 "Игорь Лабутин" То есть это элемент, который собственно отвечает за ни один непоставленный флаг.
3609.80 3610.80 "Анатолий Кулаков" Именно так.
3610.80 3626.64 "Анатолий Кулаков" Так, здесь я еще хотел упомянуть про serializer, потому что enum по умолчанию в System Text JSON сервизуется как обычные винты, чтобы это исправить вам нужно соответственно настраивать System Text JSON, добавляя к нему конвертер.
3626.64 3628.00 "Анатолий Кулаков" JSON string enum converter.
3628.00 3634.72 "Анатолий Кулаков" Просто добавляете при декларации, там где вы например в контейнере регистрируете его, или где вы создаете ручками.
3634.72 3639.24 "Анатолий Кулаков" В общем, добавляете этот конвертер, и enum начинает сериализоваться как строки.
3639.24 3643.04 "Анатолий Кулаков" Что наверное в большинстве случаев более ожидаемо у разработчиков.
3643.04 3648.44 "Анатолий Кулаков" Или можно просто навесить на enumчик какой-то, на один конкретный enum, а не для всех подряд.
3648.44 3654.08 "Анатолий Кулаков" Можно навесить специальный атрибут JSON converter, и передать ему тот же самый JSON string enum converter.
3654.08 3657.52 "Анатолий Кулаков" И будет только этот один enumчик преобразовываться в строки.
3657.52 3671.56 "Анатолий Кулаков" Вот, еще один интересный факт в том, что на самом деле атрибут flax это не тот атрибут, который позволяет вам хранить в одном значении enum несколько значений.
3671.56 3679.28 "Анатолий Кулаков" То есть enum начинает уметь хранить несколько значений не потому, что вы на него навесили атрибут flax.
3679.28 3684.20 "Анатолий Кулаков" На самом деле несколько значений в enumчике может храниться в любом.
3684.20 3698.00 "Анатолий Кулаков" То есть даже обычный enum вы возьмете, объедините через бинарный OR, и можно его точно так же воспринимать, и можно его точно так же легко положить в enumовое значение, даже если оно не задекларированное.
3698.00 3702.32 "Анатолий Кулаков" И комбинатор на это ничего не скажет, Runtime ничего не скажет, все будет работать как и раньше.
3702.32 3711.32 "Анатолий Кулаков" На самом деле атрибут flax единственное что делает он заставляет Runtime правильно форматировать ваши enumчики.
3711.32 3714.60 "Анатолий Кулаков" Всего лишь навсего это строковое представление enum.
3714.60 3728.24 "Анатолий Кулаков" То есть без флага обычно, когда вы будете вводить это в консоль, это будут какие-то непонятные или цифры абсолютно непредсказуемые, или если это индивидуальное значение, то это выведется именно строкой.
3728.24 3733.88 "Анатолий Кулаков" Но если вы объединили несколько значений через или, у вас обычно выводятся цифры.
3733.88 3742.28 "Анатолий Кулаков" Если же вы используете флаговый enum и объединили несколько значений через или, у вас выведется enumчик в виде строк через запятую.
3742.28 3746.08 "Анатолий Кулаков" То есть очень красиво, удобно и наверное то на что вы рассчитываете.
3746.08 3749.64 "Анатолий Кулаков" Вот в принципе все что делает флаг-атрибут.
3749.64 3754.32 "Анатолий Кулаков" А теперь давайте перейдем к best-practices, которые же у нас есть с enumами.
3754.32 3769.28 "Анатолий Кулаков" Мне кажется за всеми такими на первый взгляд простенькими типами, особенно если мы говорим про value-тайпы, существует очень много подводных камней и вот те best-practices, которые там есть, их нужно очень хорошо знать, очень хорошо понимать.
3769.28 3772.92 "Анатолий Кулаков" У enumов тоже есть такие подводные камни и давайте же на них посмотрим.
3772.92 3780.08 "Анатолий Кулаков" Во-первых, рекомендуется, если у вас есть какое-то дефолтное значение у enum, давать ему обязательно индекс 0.
3780.08 3787.64 "Анатолий Кулаков" То есть такими дефолтными значениями может быть null, none, default или что-то еще.
3787.64 3795.60 "Анатолий Кулаков" В общем эти значения рекомендуют давать индекс 0 по той причине, что если вы вспомните из чего состоят enum, то это обычные цифры.
3795.60 3797.04 "Анатолий Кулаков" По дефолту это int.
3797.04 3802.76 "Анатолий Кулаков" Если вы ничего не запишите в int, он просто-напросто примет значение 0.
3802.76 3815.04 "Анатолий Кулаков" И если вы ничего не запишите в ваше поле, которое допустим является enum в вашем классике и при этом создадите классик, то автоматически в этот enum запишется 0.
3815.04 3825.64 "Анатолий Кулаков" А enum на первый взгляд кажется, что объявляет значения, которые могут в него входить и другие значения он принимать не может.
3825.64 3826.80 "Анатолий Кулаков" Это на самом деле не так.
3826.80 3830.80 "Анатолий Кулаков" На самом деле enum может принимать любые значения, которые соответствуют цифровому типу.
3830.80 3840.00 "Анатолий Кулаков" То есть даже если вы нигде у вас нет значения, которые соответствуют 0, но при этом вы присвоили туда 0, это будет нормальная валидная операция.
3840.00 3843.04 "Анатолий Кулаков" Как я уже сказал, никто не упадет, все по-прежнему станет сработать.
3843.04 3847.12 "Анатолий Кулаков" И по дефолту 0 туда и так и будет присваиваться.
3847.12 3857.32 "Анатолий Кулаков" Этой проблемой, этого случая, в том, что туда присвоится какое-то значение, которое не является допустимым набором с вашей точки зрения, ее можно решить двумя способами.
3857.32 3870.96 "Анатолий Кулаков" Во-первых, это допустить в этом наборе 0, то есть сделать вот этот первый элемент, которому дать индекс 0, и он будет автоматически всегда присваиваться неявно вашему enum, или придерживаться второго правила.
3870.96 3883.52 "Анатолий Кулаков" Если у вас все-таки нет в enum какого-то значения, которое можно принимать по умолчанию, допустим, не знаю, пол человека, там мужчина или женщина, и все, по умолчанию невозможно выбрать, кого вы создаете, мужчину или женщину.
3883.52 3888.04 "Анатолий Кулаков" В этом случае рекомендуется всегда явно инициализировать enum.
3888.04 3904.12 "Анатолий Кулаков" То есть если в вашем классе, в вашей структуре, где-то еще в вашем хранилище есть поле enum, обязательно всегда явно его инициализируйте, или запрашивайте из параметров, или читайте из конфигов, или просто какую-то строку забейте.
3904.12 3917.44 "Анатолий Кулаков" Но его обязательно нужно инициализировать допустимым значением, потому что если вы этого не сделаете, очень большой шанс, что оно инициализируется недопустимым значением, то есть тем значением, которое все остальные методы обрабатывать и принимать не готовы.
3917.44 3935.92 "Анатолий Кулаков" И тут мы соответственно подходим к методу is_defined, который я говорил раньше, именно благодаря вот этой специфике enum, что в качестве валидного значения к вам может прийти абсолютно невалидный enum, то есть абсолютно произвольное число.
3935.92 3943.60 "Анатолий Кулаков" Вот вы допустим даже можете скастить там 1, 2, 3, 4 к любому enum, который есть в вашем проекте, он скастится и пойдет дальше путешествовать по вашему workload.
3943.60 3945.88 "Анатолий Кулаков" Вот именно потому что так может быть.
3945.88 3956.64 "Анатолий Кулаков" На самом деле все методы, которые принимают к себе enum перед тем, как его, как-нибудь к нему обратиться, или сделать из него какие-то выводы, должны сделать is_defined.
3956.64 3963.32 "Анатолий Кулаков" Если они этого не сделают, то опять же зависит от того, как у них реализована логика, что дальше они с этим enum делают.
3963.32 3968.92 "Анатолий Кулаков" Но по-хорошему все, что они дальше могут с ним сделать, это опять же непредсказуемое поведение.
3968.92 3978.92 "Анатолий Кулаков" В общем, если такой enum не задефайнен, неофициально не задекларирован в среде этого списка, то по-хорошему с ним работать дальше нельзя, метод дальше работать уже не может.
3978.92 3981.12 "Анатолий Кулаков" Это какие-то невалидные аргументы пришли.
3981.12 3985.28 "Анатолий Кулаков" В общем, вот такая интересная тонкость есть.
3985.28 3989.28 "Анатолий Кулаков" Соответственно, по-хорошему надо валидировать каждый входящий enum.
3989.28 3990.96 "Анатолий Кулаков" Обычно такого не делают.
3990.96 3994.36 "Анатолий Кулаков" Я, в принципе, ни разу не видел, чтобы так писали методы.
3994.36 4003.52 "Анатолий Кулаков" И поэтому лучше все-таки придерживаться двух первых правил, которые более легче обеспечить и легче поддерживать.
4003.52 4009.20 "Анатолий Кулаков" И отдельно best practices для флаговых enums.
4009.20 4012.00 "Анатолий Кулаков" И используйте для уникальных значений степень двойки.
4012.00 4013.96 "Анатолий Кулаков" Опять же, их можно потом комбинировать.
4013.96 4020.64 "Анатолий Кулаков" Но уникальный лучше делать степенью двойки, чтобы и не путаться, и удобно делать вот такую как раз таки комбинацию.
4020.64 4032.28 "Анатолий Кулаков" Как уже сказал Игорь, делайте специальный первый аргумент, который можно назвать non, empty, default, еще что-нибудь, и давать ему индекс 0.
4032.28 4037.80 "Анатолий Кулаков" Для того, чтобы как раз таки не давать непредсказуемых результатов, если вы забыли проинициализировать ваши поля.
4037.80 4050.40 "Анатолий Кулаков" И в старых версиях дотнета метод hasFlag работает намного менее эффективно, чем бинарная проверка того, установлен флаг или не установлен.
4050.40 4055.16 "Анатолий Кулаков" В общем, это тоже имейте в виду, если вы используете старые версии дотнет фреймворка.
4055.16 4066.80 "Анатолий Кулаков" И давайте на этом моменте остановимся поподробнее, потому что есть некий миф от того, что hasFlag он безумно медленный, никогда его не используете и всегда проверяете бинарно.
4066.80 4071.16 "Анатолий Кулаков" Прежде всего, что такое бинарная проверка на наличие флага?
4071.16 4080.04 "Анатолий Кулаков" Это вы можете к вашему enum, прибавить то значение, которое вы хотите проверить, именно установлено поле или не установлено.
4080.04 4092.20 "Анатолий Кулаков" Вот, прибавляете вы его через end, то есть бинарный и, и смотрите, получилось результирующее значение вашему проверяемому полю или не получилось, то есть равно или не равно.
4092.20 4104.88 "Анатолий Кулаков" Если это чисто то значение, которое осталось после того, как с ended все нули и единички, значит такой флаг в изначальном enum установлен, иначе он не установлен.
4104.88 4115.40 "Анатолий Кулаков" Вот так раньше в старых фреймворках, когда еще не был введен этот метод, введен он в принципе довольно недавно, так люди раньше жили, так люди раньше и проверяли.
4115.40 4119.16 "Анатолий Кулаков" Но давайте посмотрим, нужно ли это сделать сейчас.
4119.16 4138.48 "Анатолий Кулаков" И соответственно автор приводит несколько бенчмарков с помощью benchmark.net, он пытается проверить массивы с большим числом элементов, с маленьким числовым элементом, еще с чем-то и пытается вот с помощью hashflag и бинарной проверки и проверки с помощью метода найти хоть какую-то разницу.
4138.48 4141.96 "Анатолий Кулаков" Вот, и он приходит к выводу в том, что на современных фреймворках никакой разницы нет.
4141.96 4149.44 "Анатолий Кулаков" Это абсолютно два одинаковых подхода и используйте то, что вам больше нравится, то, что у вас принято.
4149.44 4164.92 "Анатолий Кулаков" Но если мы возьмем старый фреймворк, например 461, и проверим там, то там мы действительно увидим, что просадка в перформансе есть и разница между hashflag и бинарным сравнением тоже есть.
4164.92 4168.80 "Анатолий Кулаков" И она довольно существенная, где-то примерно в два раза.
4168.80 4177.68 "Анатолий Кулаков" То есть примерно в два раза вы можете увеличить перформанс вашей программы, если все, что делает ваша программа, это проверяет наличие флажков, буквально переделав вот на такой костыль.
4177.68 4184.12 "Анатолий Кулаков" Это, естественно, бага, ее пофиксили еще в 2017 году и в современных фреймворках таких глупостей нет.
4184.12 4194.12 "Анатолий Кулаков" Более того, hashflag прооптимизировали настолько, что в современных фреймворках он где-то в 10 раз быстрее, чем, например, в 461.
4194.12 4209.00 "Анатолий Кулаков" Это еще один аргумент к тому, что перформанс каждой новой версии у нас в дотнете увеличивается и увеличивается, поэтому не отставайте, пытайтесь обновляться на новые версии абсолютно сразу, как только вы чувствуете все силы, как только они выпускают LTS.
4209.00 4215.56 "Анатолий Кулаков" Потому что перформанс вот даже в таких банальных вещах, как hashflag увеличивается в десятки раз.
4215.56 4216.80 "Анатолий Кулаков" В общем, это прекрасно.
4216.80 4221.12 "Анатолий Кулаков" Соответственно, это все, что я хотел вам рассказать о enumchickx.
4221.12 4228.16 "Анатолий Кулаков" С виду простые типы, но нужно знать о их тонкостях и нужно знать, как и где их применять.
4228.16 4231.76 "Анатолий Кулаков" И тогда у вас получится читабельный, поддерживаемый и код без багов.
4231.76 4238.64 "Игорь Лабутин" Я бы еще хотел одну вещь добавить про enumchickx, который я сам сталкивался и который применяют во многих проектах.
4238.64 4252.88 "Игорь Лабутин" Если у вас вдруг эти enumchickx используются в каких-то местах, где у вас есть довольно много toString, то есть мы говорили, что можно на enumchickx вызвать toString или getName и получить имя или nameof.
4252.88 4256.88 "Игорь Лабутин" nameof хорошо, когда у вас в compile time известно, что вы хотите.
4256.88 4279.80 "Игорь Лабутин" Если же вам приходится делать toString, допустим, передавая каким-то образом значение туда-сюда, то по моей практике, по крайней мере пока, иногда бывает выгоднее один раз собрать статический словарик из enum в строчку и дальше уже просто делать лукап по словарику.
4279.80 4287.68 "Игорь Лабутин" Нужно замерять, нужно смотреть, что дороже, а локация строки либо поиск по словарю, потому что и то и то не бесплатно.
4287.68 4304.96 "Игорь Лабутин" Но на кусочках, где нужна, допустим, какая-то большая сериализация или еще что-то, иногда бывает быстрее действительно посериализовать все в строчку, собрать словарик заранее один раз в статическом конструкторе, например, и после этого только ходить к нему.
4304.96 4309.88 "Игорь Лабутин" Ну и надо сказать, что команда runtime постоянно работает действительно над всякими улучшениями.
4309.88 4327.96 "Игорь Лабутин" То есть в шестом .NET ускорили в два раза метод hasFlag, сейчас идет обсуждение, не хотим ли ускорить toString как раз таки, потому что такая наивная реализация со словариком пока работает быстрее и, собственно, она не локетит память, потому что вы всегда возвращаете одну и ту же строчку.
4327.96 4332.80 "Игорь Лабутин" Хотя это не очень хорошо работает для флаговых enum, поэтому с флаговыми так не заработает.
4332.80 4339.80 "Игорь Лабутин" Так что следите за тем, что происходит в .NET, возможно, на это обратят внимание еще больше.
4339.80 4346.68 "Анатолий Кулаков" Я за эту недельку нашел интересный проект, которым тоже хочу с вами поделиться.
4346.68 4361.32 "Анатолий Кулаков" В данном случае это набор видеозаписей от архитекторов компании Тинькофф, которые начали разбирать интереснейшую книгу, о которой много лет уже просят разобрать нас в том или ином виде.
4361.32 4363.56 "Анатолий Кулаков" Особенно с тех пор, как у нас появился BookClub.
4363.56 4374.24 "Анатолий Кулаков" Я напоминаю, что у нас есть BookClub, в котором ребята разбирают сейчас книгу про Microsoft с контейнеризируемым приложением.
4374.24 4377.16 "Анатолий Кулаков" Там очень много всего, кроме контейнеров, поэтому обязательно посмотрите.
4377.16 4380.24 "Анатолий Кулаков" А это еще одна очень популярная книга.
4380.24 4383.84 "Анатолий Кулаков" Я уверен, что каждый из вас ее слышал хотя бы название.
4383.84 4388.32 "Анатолий Кулаков" Это книга Мартина Клеммана Design Data Intensive Applications.
4388.32 4391.32 "Анатолий Кулаков" В простонародье известна как книга с кабанчиком.
4391.32 4394.60 "Анатолий Кулаков" На ней изображен красненький кабанчик.
4394.60 4398.32 "Анатолий Кулаков" Соответственно эта книга стала уже просто культовой.
4398.32 4413.24 "Анатолий Кулаков" Там рассмотрено очень много всего полезного для того, чтобы построить, может быть спроектировать и вообще узнать, как работают распределенные приложения, какие у них бывают трудности, с какими шаблонами они сталкиваются, как решают.
4413.24 4416.84 "Анатолий Кулаков" В общем, это безумно интересный труд, безумно интересный автор.
4416.84 4419.84 "Анатолий Кулаков" Я с ним сталкивался на Гидре.
4419.84 4424.72 "Анатолий Кулаков" Он приезжал в Санкт-Петербург, подписал мне книгу, пообщались немного.
4424.72 4425.72 "Анатолий Кулаков" В общем, прекрасный человек.
4425.72 4430.36 "Анатолий Кулаков" И по его статьям это тоже было понятно.
4430.36 4434.52 "Анатолий Кулаков" Это один из первых авторов, который начал популяризировать CRDT еще до того, как это стало модным.
4434.52 4437.56 "Анатолий Кулаков" И соответственно много у него наработок, научных трудов.
4437.56 4438.56 "Анатолий Кулаков" Он именно занимается наукой.
4438.56 4441.24 "Анатолий Кулаков" Много очень научных трудов с этой темой связано.
4441.24 4445.96 "Анатолий Кулаков" И соответственно он очень много общается в этой сфере распределенных вычислений, распределенных приложений.
4445.96 4457.00 "Анатолий Кулаков" И книга у него получилась тоже безумно достойная на конкретных практических примерах, с конкретными теоретическими, какими-то научными выводами, с кучей ссылок, с кучей приложений.
4457.00 4468.52 "Анатолий Кулаков" И неудивительно, что люди вокруг проявляют интерес к этой книге и часто, при любом удобном случае, пытаются ее каким-то образом обсудить.
4468.52 4476.04 "Анатолий Кулаков" И мне кажется, подобралась идеальная команда, идеальная группа, которая могла бы это хорошо сделать.
4476.04 4477.80 "Анатолий Кулаков" И она таки сделала.
4477.80 4487.28 "Анатолий Кулаков" То есть она, эта команда начала выкладывать видео на YouTube, видео своего проекта.
4487.28 4492.56 "Анатолий Кулаков" И я думаю, что лучше всего об этом проекте расскажет один из ведущих.
4492.56 4497.72 "Анатолий Кулаков" И как раз у нас в студии Solution Architector и Senior Engineering Manager Владимир Иванов.
4497.72 4502.00 "Анатолий Кулаков" Как раз один из авторов упомянутого подкаста или курса лекций.
4502.00 4503.00 "Анатолий Кулаков" Привет, Владимир.
4503.00 4504.00 "Анатолий Кулаков" А, привет, Анатолий.
4504.00 4509.48 "Анатолий Кулаков" Так, у тебя, то есть у вас, соответственно, курс называется Code of Architecture.
4509.48 4511.36 "Анатолий Кулаков" Как вы его больше позиционируете?
4511.36 4515.12 "Анатолий Кулаков" Это какой-то подкаст у вас, лекции, уроки или что это такое?
4515.12 4516.96 "Владимир Иванов" Ну, это не лекции, не уроки.
4516.96 4519.32 "Владимир Иванов" Это больше такой читательский клуб.
4519.32 4530.48 "Владимир Иванов" И мы его позиционируем просто как такой клуб обсуждения, где мы читаем всякие полезные для архитекторов и старших разработчиков книжки.
4530.48 4536.84 "Владимир Иванов" И обсуждаем, соответственно, вот для текущей книжки мы по главам просто делали сессию.
4536.84 4546.64 "Владимир Иванов" Но иногда получалось даже так, что мы одну главу обсуждали на двух или трех заседаниях, потому что главы были очень большие и там были разные темы.
4546.64 4549.32 "Анатолий Кулаков" Слушай, а как возникла вообще идея такого формата?
4549.32 4553.32 "Анатолий Кулаков" То есть как появилась мысль создать читальный клуб?
4553.32 4554.32 "Владимир Иванов" История интересная.
4554.32 4556.12 "Владимир Иванов" Я вообще люблю читать книжки.
4556.12 4566.32 "Владимир Иванов" Вот у меня есть блог такой, www.wfsl.dev, и я там пишу всякие технические статьи, статьи по архитектуре, и в том числе пишу обзоры на книжки.
4566.32 4574.40 "Владимир Иванов" И, соответственно, когда я что-то читаю, мне интересно всегда потом написать ревью, поделиться своим мнением и так далее.
4574.40 4583.84 "Владимир Иванов" И когда я выбирал новую книжку, я написал в Twitter типа "Вот, собираюсь читать вот эту вот книжку с кабанчиком - Designing Data Intensive Applications".
4583.84 4594.68 "Владимир Иванов" И мой коллега Илья Зонов, он мне в ответ прямо в реплай туда говорит "А давай мы как-то вот это публично будем типа вместе читать и обсуждать, сделаем такой читательский клуб".
4594.68 4602.96 "Владимир Иванов" Я сказал "О, круто, вообще классная идея", потому что, во-первых, это мотивация дочитывать книжки до конца, даже если ты немножко заскучал.
4602.96 4617.12 "Владимир Иванов" Во-вторых, это такая полезная общественная активность, потому что ты всем рассказываешь, а что ты вычитал, что понял, добавил какие-то свои истории жизни, сказал, что "А, вот где это стрельнуло, и вот почему, и вот так это работает".
4617.12 4621.60 "Владимир Иванов" Поэтому мы с Илюхой такое дело придумали, и в Тинькове внутри...
4621.60 4631.48 "Владимир Иванов" Ну, Илья - это мой коллега по Тинькову, и мы позвали еще двух экспертов - это Вова Чистяков и Саша Поломодов.
4631.48 4635.84 "Владимир Иванов" И вот мы решили, что мы будем записывать такие вот сессии.
4635.84 4648.04 "Владимир Иванов" То есть мы читаем неделю главу, пишем какие-то ноты, вот Илья рисует очень крутые mind-map для каждой главы, и потом мы собираемся и час обсуждаем, что мы вычитали, что поняли.
4648.04 4652.08 "Владимир Иванов" И вот так по главе, соответственно, читаем всю книжку.
4652.08 4653.08 "Владимир Иванов" Круто.
4653.08 4664.36 "Анатолий Кулаков" Я должен признаться, что тоже с твоим творчеством познакомился прежде всего с твоего блога, давно, в принципе, тебя читал, и очень рад был увидеть уже непосредственно в виде вот этого читального клуба.
4664.36 4667.60 "Анатолий Кулаков" А про остальных ведущих, вот, ты...
4667.60 4671.08 "Анатолий Кулаков" Кем они являются, чем они занимаются в своей профессиональной деятельности?
4671.08 4687.92 "Владимир Иванов" Да, ну Илья Зонов - архитектор, соответственно, в кредитах для бизнесов в Тинькове, и он, соответственно, придумывает, как кредитным системам развиваться, да, как новые продукты поддерживать, как там выдерживать всякие нагрузки и так далее.
4687.92 4700.84 "Владимир Иванов" Вова Чистяков там же является тем ледом одной из команд глубокого бэкэнда, и, соответственно, он руководит целой командой там 10 человек, которые вот эти кредитные продукты непосредственно делают.
4700.84 4718.36 "Владимир Иванов" А Саша Поломодов руководит управлением разработки Тиньков банка, то есть это вот приложение для физиков, вот, и он тоже архитектор с большим и глубоким опытом.
4718.36 4723.72 "Анатолий Кулаков" А не обсуждались ли вообще другие книги, или почему именно выбрали «Кабанчик», а почему вокруг нее именно собрались?
4723.72 4725.20 "Владимир Иванов" Да, почему именно эта книга...
4725.20 4739.96 "Владимир Иванов" Ну, во-первых, я давно собирался ее прочитать, потому что все вокруг говорят типа «Вот, это must have, все должны ее прочитать», и так далее, а я чувствовал себя немножко неуютно, потому что, ну, как же так, типа я не читал, надо как-то это возмещать.
4739.96 4753.24 "Владимир Иванов" Другие книжки мы обсуждаем сейчас, то есть вот смотри, эту книгу мы закончили, теперь у нас есть 5 претендентов на следующие книги, там Understanding DDD, всякие Microservices Patterns и так далее.
4753.24 4760.88 "Владимир Иванов" И вот мы сейчас, мы составили shortlist, мы сейчас проведем голосование и выберем следующую книжку, которую будем читать.
4760.88 4766.80 "Анатолий Кулаков" Отлично, это просто предусветило мой вопрос про что вы дальше собираетесь делать, какие у вас планы на будущее.
4766.80 4774.16 "Анатолий Кулаков" В общем, ты прекрасно все рассказал, но насчет планов, я так понимаю, что на YouTube сейчас не выложено не все, когда собираетесь выложить остальные лекции?
4774.16 4785.64 "Владимир Иванов" Сейчас у нас выложено всего 3 выпуска, по-моему, там ребята из Тинькофф внутри работают над тем, чтобы выложить все остальные, ну, потому что там оформление нужно, там все такое.
4785.64 4791.64 "Владимир Иванов" И там выпусков, по-моему, 14 всего будет по книжке с Кабанчиком.
4791.64 4793.92 "Владимир Иванов" Прекрасно, я думаю, хорошо получилось.
4793.92 4794.92 "Владимир Иванов" Да, супер.
4794.92 4807.92 "Владимир Иванов" И в дальнейшем мы, соответственно, будем, остальные лекции мы хотим делать уже live, ну, то есть, чтобы они сразу были в виде трансляции на YouTube, прямо как мы записываем, и, соответственно, там и оставались.
4807.92 4819.16 "Владимир Иванов" То есть раньше это был такой внутренний продукт Тинькоффа, и мы его обкатывали, да, то есть там уже нужно понимание, что у нас контента наберется, что мы не развалимся, что нам не надоест и так далее.
4819.16 4829.16 "Владимир Иванов" Вот сейчас мы с книжкой обкатали, и теперь новые книжки мы будем прямо live на публику обсуждать, соответственно, всех звать в обсуждение, там обсуждать всякие вопросы, должно быть весело.
4829.16 4835.48 "Анатолий Кулаков" То есть у вас основная цель – это подцепить вот как раз real-time аудиторию, да, чтобы вместе с вопросами, с примерами из живой аудитории общаться?
4835.48 4843.24 "Владимир Иванов" Ну, так интереснее, конечно, когда кто-то пишет что-то, и ты такой сразу подхватываешь это, обсуждаешь, задаешь личный вопрос, вот, очень круто получается.
4843.24 4851.32 "Анатолий Кулаков" Ну, а смотри, вот вы уже книгу прочитали, вы уже обсудили, ты много разных мнений услышал, как ты думаешь, для кого эта книга?
4851.32 4854.36 "Анатолий Кулаков" То есть кто, основная целевая аудитория?
4854.36 4872.60 "Владимир Иванов" Ну, целевая аудитория для начала, мне кажется, это любые инженеры, которым хочется разобраться, как работают современные распределенные системы, да, то есть условно почему ты, когда твиттер открываешь, у тебя там написано два ретвита, ты заходишь в детали, а там написаны детали только про один из них.
4872.60 4881.48 "Владимир Иванов" Вот почему вот так происходит и почему нельзя сделать так, чтобы эти вещи там совпадали без того, чтобы это было предельно дорого.
4881.48 4899.44 "Владимир Иванов" И обязательно эта книга для прочтения для тех, кто занимается вот систем дизайн, то, что называется, да, то есть если вам приходится проектировать такие системы с нуля или менять существующие системы для поддержки новых требований, там, для большего количества пользователей или еще для чего-то, то вот вам прям необходимо эту книжку прочитать.
4899.44 4907.28 "Анатолий Кулаков" Отлично, ну и ты в конце концов ее прочитал, как ты теперь можешь сказать, стоит ли она всего того хайпа, который вокруг не выходит, то есть нужная книга или так себе?
4907.28 4917.32 "Владимир Иванов" Я считаю, что книжка абсолютно нужная, я вот в блоге написал ревью и это пока первая книжка, которая получила 5 из 5, то есть это абсолютный мастхэв.
4917.32 4926.60 "Владимир Иванов" Там есть некоторые вопросы к Мартину, что какие-то вещи там, им уделено очень мало внимания, но книжка и так получилась толстая, поэтому это понятно.
4926.60 4928.44 "Владимир Иванов" Так что читайте обязательно.
4928.44 4933.52 "Анатолий Кулаков" Отлично, спасибо большое, я напомню, что с нами был Владимир Иванов, спасибо большое, заходи к нам еще.
4933.52 4934.52 "Владимир Иванов" Спасибо, пока.
4934.52 4935.52 "Владимир Иванов" Пока.
4935.52 4951.68 "Анатолий Кулаков" Вот такой интересный плейлист, обязательно посмотрите, может быть, вам тоже зайдет, и это отличный способ для того, чтобы, соответственно, если вы эту книгу не читали, для того, чтобы вместе с ребятами начать ее читать и смотреть отзывы и комментарии знающих людей.
4951.68 4962.24 "Анатолий Кулаков" Вот, на этом у меня подслушано все, не такой уж продуктивной были эти недели насчет новых интересных подкастов, поэтому пока только одна рекомендация.
4962.24 4972.04 "Игорь Лабутин" У меня, да, подкасты тоже сейчас пока на паузе немножко, ну то есть я их слушаю, но там пока ничего такого, что я прям двумя руками готов порекомендовать.
4972.04 4989.20 "Игорь Лабутин" На сегодня на самом деле надо заканчивать, мы уже сидим почти около полутора часов точно, и за это время мы успели обсудить, что у нас вышли .NET 7 Preview 2 и .NET MAUI Preview 14, поговорили про OpenTelemetry в шестом .NET и вспомнили, что же это такое.
4989.20 5013.36 "Игорь Лабутин" Кроме этого вышли Visual Studio 2022 V17.2 Preview 2 и Visual Studio 2022 Format Preview 7, это мы тоже обсудили, и обсудили еще две статьи, это напомнили, что такое Value Tasks и какие проблемы и особенности работы с ними могут быть и могут вам встретиться, а также напомнили основы, можно сказать, Sharp'а и какие-то тонкие моменты вокруг Enumov, как с ними правильно работать.
5013.36 5023.16 "Игорь Лабутин" Ну и под конец, да, книжка с кабанчиком, клевая тема, у меня она лежит в стопочке на книг на прочтение в спокойной обстановке, видимо теперь буду читать параллельно с клубом.
5023.16 5039.08 "Анатолий Кулаков" Отлично, а на сегодня все, до новых встреч, всем спасибо, что слушаете нас, распространяете, лайкаете, рассказываете друзьям, для нас это очень важно, пишите комментарии, пишите какие-то предложения и всем до новых встреч, всем пока.
5039.08 5040.08 "Игорь Лабутин" Это был радио.
5040.08 5042.04 "Игорь Лабутин" Дотнет номер 48.
5042.04 5042.76 "Игорь Лабутин" Всем пока.
