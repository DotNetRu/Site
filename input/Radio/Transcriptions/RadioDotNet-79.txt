0.00 7.88 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
7.88 11.56 "Анатолий Кулаков" В эфире Радио.нет выпуск номер 79.
11.56 15.60 "Анатолий Кулаков" И с вами его постоянный ведущий Анатолий Кулаков.
15.60 16.60 "Игорь Лабутин" И Игорь Лабутин.
16.60 17.60 "Игорь Лабутин" Всем привет!
17.60 29.80 "Анатолий Кулаков" Особую благодарность хочется выразить нашим самым любимым помогаторам – Александр, Сергей, Владислав, Алексей, Шевченко Антон, Лазарь Вальяк, Гурий Самарин, Виктор, Руслан Нартамонов, Александр Ярыгин, Белотский Евгений.
29.80 37.28 "Анатолий Кулаков" Спасибо, кто нас поддерживает, а также всем, кто поддерживает и при этом, пожалуй, остался неизвестным и не попал в этот список.
37.28 44.80 "Анатолий Кулаков" Ну и что самое интересное на прошедших неделях – это то, что от Grimmel до Next.
44.80 49.64 "Анатолий Кулаков" В общем, мы были на конференции, многих увидели.
49.64 58.08 "Анатолий Кулаков" Огромное спасибо всем, кто подходил и узнавал ведущих, и узнавал подкаст.
58.08 62.16 "Анатолий Кулаков" Очень приятно и интересно было увидеть, что действительно есть какие-то живые люди, кто нас слушает.
62.16 68.52 "Анатолий Кулаков" То есть все эти выпуски, все эти счётчики не только моя мама накручивает, но, наверное, кто-то ещё есть.
68.52 69.52 "Анатолий Кулаков" Забавный эффект.
69.52 82.40 "Игорь Лабутин" Да, всем действительно спасибо, а мы перейдём к новостям, тем более, что у нас есть о чём рассказать, потому что вышел релиз Кандидат 1 у 8го Дотнета, и сейчас мы по нему будем очень подробно разговаривать.
82.40 89.56 "Анатолий Кулаков" Слушай, ну на самом деле не такой уж большой кандидат, я думаю, что они там всё-таки к релизу ждут каких-то и собирают основной материал к релизу.
89.56 98.48 "Анатолий Кулаков" Ну и с другой стороны, там выпуск выходит не такой уж и хороший, ну не такой многогранный и широкий, чтобы про него много было чего писать.
98.48 99.84 "Анатолий Кулаков" Но рассмотрим, рассмотрим.
99.84 107.00 "Анатолий Кулаков" Прежде всего нужно сказать, что это первый релиз, намечается их всего два, то есть релиз кандидатов.
107.00 108.00 "Анатолий Кулаков" Каких релизов?
108.00 112.68 "Анатолий Кулаков" Да, два будет релиз Кандидата, и релиз 8го Дотнета будет 14го ноября.
112.68 118.44 "Анатолий Кулаков" Именно в эту дату уже запланирован Дотнет Конф, на котором традиционно презентуются новые версии Дотнета.
118.44 123.80 "Анатолий Кулаков" И вот в середине ноября нас как раз ожидает 8го, будем ждать.
123.80 128.04 "Анатолий Кулаков" Так, давайте же посмотрим, чем нас порадовал RC1.
128.04 142.96 "Анатолий Кулаков" Во-первых, были улучшены систем-текст JSON, ему добавили стриминговую децерализацию, то есть теперь мы можем читать, то есть децерализовать из потока, то есть децерализовать по сути async enumerable.
142.96 158.08 "Анатолий Кулаков" Это такая отложенная коррекция, которая может не только перебирать элементы по мере их поступления, но и делать это асинхронно, то есть допустим скачивать из сети по одному элементику, что тоже часто бывает полезным, и приятно, что сериализатор подтянулся и тоже теперь это умеет делать.
158.08 162.20 "Анатолий Кулаков" Также появился асинхронный механизм к JSON ноде, который JSON-node-parse.
162.20 166.28 "Анатолий Кулаков" Парсить теперь можно асинхронно, что тоже весьма примечательно.
166.28 177.00 "Анатолий Кулаков" Также добавилось два режима, который называется Android strip IL-Auto-IoT и WASM strip IL-Auto-IoT.
177.00 185.48 "Анатолий Кулаков" Как вы, наверное, догадались, это режимы, которые сокращают, удаляют IL, который остался после out-компиляции.
185.48 190.16 "Анатолий Кулаков" Первый в режиме компиляции для Android, а второй для ASM.
190.16 220.00 "Анатолий Кулаков" Ну, во-первых, это, конечно же, увеличило время старта приложения, но, наверное, не сам strip, а именно out-компиляция, потому что out-компиляция для Android и для ASM теперь включена по дефолту, и это привело к увеличению время старта, перформанс улучшился, но немножко вырос application size, потому что пришлось немножко больше кода засунуть в бинарник.
220.00 223.20 "Анатолий Кулаков" И что же сказать?
223.20 240.20 "Анатолий Кулаков" Да, после того, как мы включили IOT, у нас немножко увеличился бинарник, и если мы включим вот этот флаг, что мы должны удалять IL после out-компиляции, у нас запускается специальный алгоритм, который удаляет неиспользуемые куски кода из уже готового бинарника после IOT.
240.20 248.84 "Анатолий Кулаков" И таким образом мы смогли сократить бинарник где-то на 3-4%, наш алгоритм примерно удаляет ненужного кода.
248.84 251.28 "Анатолий Кулаков" Поэтому размер немножко уменьшается.
251.28 264.56 "Анатолий Кулаков" Из несовместимых изменений немножко переделали конфигурацию binding-генератора, то есть это тот source-генератор, который нам специальные методы делал для конфигурации, чтобы она загружалась не с помощью reflection, а с помощью автогенерированных свойств.
264.56 277.52 "Анатолий Кулаков" И переделали его как раз-таки на интерсепторы, которые мы обсуждали в прошлых выпусках, то есть теперь код должен загружаться из конфигурации, значения из конфигурации должны загружаться еще быстрее.
277.52 280.80 "Анатолий Кулаков" Но из-за этого пришлось добавить небольшую несовместимость.
280.80 287.04 "Анатолий Кулаков" Поэтому в превью-версии, используя превью-версию интерсепторов.
287.04 293.80 "Анатолий Кулаков" И для того, чтобы вам ее заиспользовать, в msbuild-свойства нужно включить специальный фичи-флаг, который называется interceptors-preview.
293.80 296.04 "Анатолий Кулаков" В общем, без него работать не будет.
296.04 303.48 "Анатолий Кулаков" В будущих версиях, конечно же, когда интерсепторы уже придут в релиз, этот флаг не нужен будет, но пока приходится вот так вот выкручиваться.
303.48 308.52 "Анатолий Кулаков" Дальше у нас добавилась поддержка виндовых ресурсов.
308.52 319.88 "Анатолий Кулаков" Если вы собираете вашу сборку не под виндовой платформой, но при этом хотите вставить в нее виндовые ресурсы, такие как иконочка приложения, манифест и так далее.
319.88 322.64 "Анатолий Кулаков" Раньше с этим были какие-то проблемы, я так понял, что оно вообще не работало.
322.64 326.80 "Анатолий Кулаков" Сейчас вроде как-то пофиксили билдер или компилятор.
326.80 332.12 "Анатолий Кулаков" В общем, теперь виндовые ресурсы можно встраивать, даже если вы компилируете не на виндовом приложении.
332.12 335.32 "Анатолий Кулаков" Вот, в принципе, все, что касается самого фреймворка.
335.32 337.24 "Анатолий Кулаков" Вот это вот и все изменения.
337.24 339.52 "Анатолий Кулаков" Не то чтобы совсем большой RC1.
339.52 350.08 "Игорь Лабутин" То есть это получается у нас сам фреймворк, а ASP.NET, там Entity Framework, MAU, и не знаю, WPF, MAU, и что у нас с графикой?
350.08 351.28 "Анатолий Кулаков" Да, давай пробежимся.
351.28 354.08 "Анатолий Кулаков" Начнем, конечно же, с ASP.NET.
354.08 358.04 "Анатолий Кулаков" Прежде всего новость, что HTTP/3 выключили по дефолту.
358.04 366.72 "Анатолий Кулаков" Я напомню, что во всех превьюшках дотнет 8-го он был по дефолту включен, и его тестировали там бы везде, но решили в релизе все-таки выключить.
366.72 369.48 "Анатолий Кулаков" И сейчас состояние такое же, как и в дотнет 7-м.
369.48 378.08 "Анатолий Кулаков" То есть никаких, грубо говоря, breaking changes между 7-м и 8-м не будет, потому что его в 8-м превью включили, ну 8-м превью же и выключили.
378.08 380.28 "Анатолий Кулаков" Почему же так сделали?
380.28 385.40 "Анатолий Кулаков" Потому что с ним возникли проблемы не технического характера, а больше такого организационного.
385.40 395.12 "Анатолий Кулаков" К сожалению, существуют антивирусы, которые спрашивали у пользователя разрешения на то, чтобы допустить программу к сети.
395.12 398.84 "Анатолий Кулаков" Если мы начинали использовать HTTP/3 и при этом подключались с дебаггером.
398.84 401.48 "Анатолий Кулаков" То есть пытались отладить эту программу.
401.48 418.40 "Анатолий Кулаков" В общем, Microsoft сказал, что это очень плохой экспириенс, они не хотят, чтобы с HTTP/3 были связаны какие-то вот такие дурацкие спрашивания и проблемы с отладкой, поэтому они пока его отключили и решили, что будут каким-то образом искать пути обхода.
418.40 426.04 "Анатолий Кулаков" И обхода вот этих спрашиваний и улучшения пользовательского опыта в будущем.
426.04 437.04 "Анатолий Кулаков" Если вы уже вдруг заиспользовали HTTP/3 и хотите его продолжить использовать в своих приложениях, то естественно можно все это настроить через специальный конфигурки кестрил метод.
437.04 439.84 "Анатолий Кулаков" Там, где обычно вы опция настраиваете для кестрила.
439.84 442.72 "Анатолий Кулаков" Так что тоже не проблема.
442.72 449.92 "Анатолий Кулаков" Из других тонкостей была добавлена поддержка кит сервис в DI.
449.92 455.00 "Анатолий Кулаков" Это вот сервис, помеченный ключевым словом, специальным ключевым атрибутом, который мы тоже недавно обсуждали.
455.00 463.08 "Анатолий Кулаков" В общем в DI они появились довольно давно, но теперь вы их можете пробросить в minimal API, так же как и в control-based API и так же в сигнал R-хабы.
463.08 472.56 "Анатолий Кулаков" Туда тоже почему-то поддержку завезли, непонятно почему отдельно им пришлось завозить, вроде это как бы DI-система должна в общем на всех разбрасывать, но наверное какие-то тонкости были.
472.56 477.48 "Анатолий Кулаков" Обновили очень много и широко Blazor-темплейт, много чего добавили.
477.48 490.52 "Анатолий Кулаков" Во-первых, вспомнили про возможность статического рендеринга начальной загрузочной страницы Blazor, которая позволила прооптимизировать время загрузки.
490.52 493.16 "Анатолий Кулаков" Мы тоже уже упоминали и обсуждали.
493.16 500.88 "Анатолий Кулаков" Кратце напомню, что Blazor при старте может переключаться в такой автоселект режим, который сейчас включен даже по умолчанию.
500.88 516.52 "Анатолий Кулаков" Когда он загружает сначала в браузер серверную часть, если вдруг у него WebAssembly Runtime был еще не скачан, и в это время скачивает WebAssembly Runtime, и в то время, когда он его скачал, он переключается на WebAssembly.
516.52 535.04 "Анатолий Кулаков" Таким образом вы получаете очень быструю загрузку, потому что у вас сразу первый код приходит с сервера, и в это же время получаете очень быстрый пользовательский отклик, потому что в бэкграунде у вас скачивается движок WebAssembly Runtime, который уже непосредственно начинает работать в браузере и переключает вообще все, что вам нужно.
535.04 545.52 "Анатолий Кулаков" В общем, вот это поведение оно теперь вшито в Blazor Template по дефолту, то есть все новые приложения, которые вы будете создавать, будут автоматически с вот этим авторендер модом работать.
545.52 554.08 "Анатолий Кулаков" И в принципе там много других интересных нововведений в темплейт, которые в принципе не так важны, как этот.
554.08 558.12 "Анатолий Кулаков" Еще один интересный breaking change – это переименование метрик.
558.12 581.52 "Анатолий Кулаков" Как вы знаете, у .NET есть стандартный диагностик метрикс, это тоже класс, который недавно появился, и имена у этих метрик были немножко несовместимы с OpenTelemetry Metrics, потому что микрософтовские метрики появлялись немножко раньше, чем застаканились, чем зарелизились OpenTelemetry Metrics, поэтому имена там были немножко несовместимы.
581.52 600.32 "Анатолий Кулаков" И вот как раз в этом релизе Microsoft прочитали OpenTelemetry Semantic Convention, где как раз таки описывается, как метрики должны именоваться в зависимости от того, к чему они относятся, к чему отсылают, как крутят, и они подтюнили свои метрики под него.
600.32 612.96 "Анатолий Кулаков" Например, то, что раньше Kestrel публиковал метрику про продолжительность web-реквеста, как-то называлась по-страшному, теперь называется стандартно HTTP Server Request Duration.
612.96 622.76 "Анатолий Кулаков" То есть это стандартное такое название из OpenTelemetry, которое в принципе понимают многие инструменты, многие графики, в общем теперь более совместимо получилось.
622.76 649.56 "Анатолий Кулаков" В то же самое время Microsoft там свои собственные метрики, все свои собственные каунтеры, которые у него были и которые несовместимы со стандартом, тоже загнал в пространство ISP.NET Core, например, RateLimiting Queue Requests, где, которая как раз для RateLimiter была нужна, в общем, она тоже никуда не пропала, просто уехала в нужное пространство и переименовалась в кейсе в регистре, следуя всем конвенциям.
649.56 663.80 "Анатолий Кулаков" Это привело к тому, что те дашборды, там эти алерты, которые у вас могли быть на превью, они сейчас сломались, потому что именно очереди каунтеров изменились, поэтому вам нужно их переделать, если вдруг вы их уже под себя настроили.
663.80 668.00 "Анатолий Кулаков" Вот, в принципе про ISP это все.
668.00 670.00 "Анатолий Кулаков" Давайте посмотрим про Entity Framework.
670.00 680.36 "Анатолий Кулаков" Entity Framework, в принципе, весь RC1 вышел с описанием нового типа данных, который поддержал Entity Framework, это Complex Type, как он называется.
680.36 683.88 "Анатолий Кулаков" Хороший интересный тип данных, ну давайте как раз мы тоже с ним разберемся.
683.88 695.16 "Анатолий Кулаков" Более-менее новая концепция, более-менее какой-то релиз, который имеет смысл почитать, и он интересный, и он что-то новое нам привносит, в отличие от остальных, которые так по мелочи повторяют что-то, что мы уже знали.
695.16 697.32 "Анатолий Кулаков" В общем, Entity Framework в этот раз порадовала.
697.32 707.88 "Анатолий Кулаков" Итак, как я уже сказал, весь релиз Entity Framework, релиз с кандидат 1, именно вот этот анонс был сосредоточен вокруг Complex Type.
707.88 710.32 "Анатолий Кулаков" Давайте же посмотрим, что это такое.
710.32 715.72 "Анатолий Кулаков" Итак, объекты, которые сохраняются в базе данных, можно разделить на три типа.
715.72 730.08 "Анатолий Кулаков" Во-первых, это примитивные объекты, это инты, гуиды, строки, IP-адресы, то есть такие примитивные типы, которые обычно являются колонками обычных таблиц, которые уже не делятся и которые понятно, как сохранять и как засовывать.
730.08 741.84 "Анатолий Кулаков" Во-вторых, это Entity Types, то есть сущности, которые можно проиндентифицировать, например, блок, пост, кастомер, ордер, то есть все это некие сущности, которые уже представляются таблицами.
741.84 746.76 "Анатолий Кулаков" В общем, их уже можно проиндентифицировать, дать им ID-шник и разложить по разным таблицам.
746.76 758.40 "Анатолий Кулаков" И третий тип, который существует обычно в доменах, это Value Types, то есть это разнообразные значения, которые не идентифицируемы, то есть у них нет собственного определения, у них нет собственного ID-шника.
758.40 773.24 "Анатолий Кулаков" Ну, например, адрес или какие-нибудь координаты, или там номер телефона, или деньги, вот что-нибудь такое, что в принципе может состоять из нескольких полей, но при этом отдельные таблицы не заслуживают.
773.24 776.80 "Анатолий Кулаков" Это обычно называется Value Types.
776.80 785.16 "Анатолий Кулаков" И вот до Entity Framework 8 не было какого-то хорошего способа сохранить в базе Value Types.
785.16 795.24 "Анатолий Кулаков" Естественно, примитивы у нас были всегда, Entity Types тоже как бы изначально, а вот на Value как-то забивали все это время.
795.24 808.36 "Анатолий Кулаков" Раньше был такой тип как Owned Types, и он примерно эмулировал работу с Value Types, то есть это самое близкое, что люди раньше использовали для того, чтобы реализовать подобную стратегию, стратегию хранения Value Types.
808.36 812.16 "Анатолий Кулаков" Но у него есть небольшие недостатки.
812.16 822.12 "Анатолий Кулаков" На самом деле Owned Types оперирует с типами как с сущностями, это значит, что он дописывает им ключ, то есть дописывает им ID-шник.
822.12 829.28 "Анатолий Кулаков" И вся семантика работы с Owned Types, она опирается на то, что у этих Owned Types есть ключ.
829.28 835.68 "Анатолий Кулаков" Даже если в бизнес-объекте его не видно, то есть вы ее там скрыли или явно не декларировали, он все равно не явно добавлялся.
835.68 838.40 "Анатолий Кулаков" И как бы вся семантика дальше пошла через ключ.
838.40 840.44 "Анатолий Кулаков" В общем, это было не очень удобно.
840.44 852.08 "Анатолий Кулаков" В отличие от них, вот эти комплекс-тайпы, они всех этих минусов лишены, и у них есть свои особенности.
852.08 860.32 "Анатолий Кулаков" Во-первых, они не идентифицируемые, то есть у них не может быть никакого ключа, и вся семантика как бы устроится от того, что ключа нет.
860.32 863.96 "Анатолий Кулаков" Соответственно, они нетрекабельные, то есть они не отслеживаются.
863.96 868.68 "Анатолий Кулаков" Хотя здесь небольшое лукавство, немножко-то они отслеживаются, я об этом расскажу попозже.
868.68 877.20 "Анатолий Кулаков" Также они обязательно являются частью Entity Type, то есть любой Value Type, он сам по себе не имеет никакого смысла, он сам по себе не существует.
877.20 881.16 "Анатолий Кулаков" Он лишь должен быть частью чего-то, нечто большего.
881.16 894.92 "Анатолий Кулаков" То есть для нас, как со стороны Entity Framework, это обозначает, что у комплекс-тайпов не может быть своего DB Set, то есть у нас нет какой-то таблицы, нет какой-то коррекции, где лежат эти комплекс-тайпы, где лежат, допустим, все адреса.
894.92 900.32 "Анатолий Кулаков" Нет, такого не бывает, они все часть какого-то большого типа, в котором хранятся.
900.32 908.60 "Анатолий Кулаков" Также комплекс-тайпы могут быть представлены .NET Value Type, то есть структурами и также референсами, то есть классами.
908.60 912.16 "Анатолий Кулаков" То есть туда можно и структуру, и классы засовывать с одинаковым результатом.
912.16 916.04 "Анатолий Кулаков" И они могут расшаривать свой instance между несколькими свойствами.
916.04 919.28 "Анатолий Кулаков" Это я тоже расскажу, наверное, попозже.
919.28 926.36 "Анатолий Кулаков" Итак, насчет того, что комплекс-тайпы, у них нет собственной таблицы.
926.36 927.36 "Анатолий Кулаков" Чем это выражается?
927.36 942.80 "Анатолий Кулаков" Допустим, если вы объявите тип Customer, и у этого Customer вы объявите сложный тип, который называется адрес, допустим, класс адрес, и в этом адресе будет, например, город, улица, номер дома, номер квартиры.
942.80 950.40 "Анатолий Кулаков" И вы можете вот этот адрес не объявлять как отдельная сущность, не объявлять как отдельный entity type.
950.40 954.52 "Анатолий Кулаков" Можете его просто задекларировать как класс и в Customer просто на него сослаться.
954.52 960.00 "Анатолий Кулаков" И описать это, сказав, что адрес - это мой комплекс-тайп.
960.00 968.60 "Анатолий Кулаков" Это значит, что Entity Framework не будет заводить под него отдельную таблицу, а непосредственно встроит его в таблицу с Customers.
968.60 975.92 "Анатолий Кулаков" То есть, когда вы будете делать какой-нибудь insert в Customer, вот этот адрес разложится на то количество полей, которые есть в классе адрес.
975.92 980.80 "Анатолий Кулаков" То есть, если в классе адрес 5 полей, значит, к вашей таблице Customer еще добавятся 5 полей.
980.80 984.08 "Анатолий Кулаков" Адрес подчеркивания city, адрес подчеркивания country и так далее.
984.08 989.24 "Анатолий Кулаков" И все это будет храниться именно в базе данных той сущности, которая хостит этот адрес.
989.24 996.52 "Анатолий Кулаков" Когда вы deserializовать его будете, Entity Framework естественно вам не будет возвращать вот эти адрес подчеркивания city как отдельные поля.
996.52 1002.56 "Анатолий Кулаков" Он их соберет всех в класс адрес и вернет там уже полноценно созданный класс адрес.
1002.56 1006.92 "Анатолий Кулаков" Вот именно такую концепцию реализует себе ValueType.
1006.92 1020.20 "Анатолий Кулаков" Также есть планы сделать так, чтобы вот эти комплекс-тайпы они записывались не в 10 полей, не раскладывались каждое поле по колоночке, а могли сериализоваться в JSON-колоночку.
1020.20 1028.84 "Анатолий Кулаков" И тогда у вас появится просто одна колонка, которая называется адрес и внутри нее будет JSON-ом засериализованы все поля, которые только у вас есть в этом адресе.
1028.84 1031.12 "Анатолий Кулаков" Тоже довольно удобная была бы фича.
1031.12 1032.92 "Анатолий Кулаков" Пока она еще не реализована.
1032.92 1039.24 "Анатолий Кулаков" Если она вам нужна, то заходите там на GitHub, ставьте лайки и авторы обещают тогда сделать ее побыстрее.
1039.24 1041.76 "Анатолий Кулаков" Вот теперь проговорим про переиспользованность.
1041.76 1058.36 "Анатолий Кулаков" Если вдруг у вас вот эти типы, комплекс-тайпы, они будут модифицируемы, ну типа допустим, если у вас есть адрес и у этого адреса можно поменять город или поменять улицу, то с ним может произойти довольно неприятная ситуация.
1058.36 1062.48 "Анатолий Кулаков" Адресы, то есть вот эти комплекс-тайпы, они переиспользуемы.
1062.48 1080.84 "Анатолий Кулаков" Если вы возьмете один адрес, например, адрес у кастомера и присвоите его к адресу доставки какой-нибудь, то instance этого адреса, несмотря на то, что он не идентифицируемый entity framework, будет отслеживаться и переиспользоваться.
1080.84 1088.68 "Анатолий Кулаков" Это значит, что как только вы в первом адресе измените улицу, то адрес во второй сущности тоже поменяет улицу.
1088.68 1094.44 "Анатолий Кулаков" То есть с точки зрения reference-тайпов и с точки зрения классов и логики .NET это логично.
1094.44 1101.24 "Анатолий Кулаков" Вы какой-то взяли reference-тайп, присвоили его в две ссылки и по одной из ссылок поменяли значение.
1101.24 1105.68 "Анатолий Кулаков" Ну конечно, по второй ссылке, естественно, значение будет то же самое, то есть оно тоже изменится.
1105.68 1127.76 "Анатолий Кулаков" Но если мы говорим о базах данных, то в принципе это не очень логично, потому что если мы в одной базе обновили адрес, например, нашей компании, мы совсем не ожидаем, что тот же адрес, например, обновится у пользователя или у почтового конверта, который доставляется, допустим, в эту компанию.
1127.76 1131.64 "Анатолий Кулаков" Но, к сожалению, вот поведение почему-то сделали именно такое.
1131.64 1135.12 "Анатолий Кулаков" Потому что вот эти адреса переиспользуются, они клонируются.
1135.12 1138.20 "Анатолий Кулаков" Может быть для оптимизации перформанса, может и еще для чего-то.
1138.20 1142.88 "Анатолий Кулаков" Но в обоих сущностях, в обоих таблицах по сути адрес будет обновлен.
1142.88 1152.28 "Анатолий Кулаков" Чтобы избежать такой неприятности, авторы советуют использовать immutable типы для случаев комплекс-тайпов.
1152.28 1159.76 "Анатолий Кулаков" То есть в нашем случае рекорды или struct рекорды подойдут прекрасно для того, чтобы реализовать комплекс-тайпы.
1159.76 1167.96 "Анатолий Кулаков" Они immutable, поэтому если вы захотите поменять улицу, вам придется заменять полностью весь рекорд и никакого там двойного апдейта во все таблицы не пойдет.
1167.96 1172.64 "Анатолий Кулаков" Еще немножко про особенности комплекс-тайпов.
1172.64 1177.28 "Анатолий Кулаков" Во-первых, комплекс-тайпы внутри себя могут содержать другие комплекс-тайпы.
1177.28 1181.04 "Анатолий Кулаков" То есть вы можете сделать комплекс-тайп, который называется контакт.
1181.04 1186.24 "Анатолий Кулаков" Внутри этого комплекс-тайпа будет тип адрес, который тоже является комплекс-тайпом и так далее.
1186.24 1188.72 "Анатолий Кулаков" Можно вкладывать матрешку сколько угодно.
1188.72 1191.80 "Анатолий Кулаков" Идите фреймворк прекрасно разложит любую в глубину.
1191.80 1199.28 "Анатолий Кулаков" Также нужно заметить, что комплекс-тайпы всегда загружаются, когда загружается сущность.
1199.28 1203.32 "Анатолий Кулаков" Это не какое-то отложенное навигейшн свойство, как я уже говорил.
1203.32 1205.32 "Анатолий Кулаков" Это непосредственная часть этой сущности.
1205.32 1211.68 "Анатолий Кулаков" Поэтому как только вы попросили какого-нибудь кастомера, у которого есть адрес, загрузится полностью весь класс адреса.
1211.68 1215.68 "Анатолий Кулаков" То есть как будто это поля являются самого этого кастомера.
1215.68 1219.12 "Анатолий Кулаков" Комплекс-тайпы можно использовать в проект-сех.
1219.12 1225.28 "Анатолий Кулаков" То есть вы можете сделать select и выбрать только тот тип, который является комплексным.
1225.28 1228.80 "Анатолий Кулаков" Или можете у него там свойства какие-то выбрать или еще что-то.
1228.80 1233.60 "Анатолий Кулаков" В общем тоже к нему можно через select обращаться, как вы интуитивно предполагаете.
1233.60 1239.68 "Анатолий Кулаков" И точно так же, как вы интуитивно предполагаете, с помощью комплекс-тайпа можно делать фильтрацию.
1239.68 1245.76 "Анатолий Кулаков" То есть использовать его выражение where и фильтровать адрес по городу, по номеру дома и так далее.
1245.76 1249.48 "Анатолий Кулаков" Все это тоже будет раскладываться прекрасно на Entity Framework.
1249.48 1253.88 "Анатолий Кулаков" Вот такой прекрасный механизм у нас появляется, что как бы не может не радовать.
1253.88 1254.88 "Анатолий Кулаков" Вещь хорошая.
1254.88 1257.40 "Анатолий Кулаков" В общем да, мы обычно эмулировали ее руками.
1257.40 1261.48 "Анатолий Кулаков" Теперь можно завязать будет стандартные механизмы, что прекрасно.
1261.48 1277.40 "Игорь Лабутин" Ну и вообще, насколько я сейчас смотрю в эту статью про Entity Framework, они там перечислили, я так понимаю, практически все, что они пофиксили за то время, пока молчали или не выходили статьи, и там просто приведено огромное количество ссылок на GitHub issues, которые, собственно, они исправили.
1277.40 1291.20 "Игорь Лабутин" Поэтому если вам что-то интересно, вы там ждете какую-то конкретную фичу от Entity Framework, сходите, почитайте хотя бы по названиям этих issues, чтобы понять, насколько там все, насколько реализовалось то, что вам нужно.
1291.20 1298.44 "Анатолий Кулаков" Ну да, как бы верится, что ребята не просто сидели, а работали все это время, даже несмотря на то, что пару последних анонсов они пропустили.
1298.44 1308.76 "Анатолий Кулаков" А вот кому совсем не верится, это .NET MyUI, потому что он как бы все анонсы не пропускал, но все его анонсы были сплошной фикцией.
1308.76 1330.92 "Анатолий Кулаков" И данный релиз-кандидат оказался не исключением, потому что единственное, что я выяснил из их анонса, что у нас был quality improvement, то есть они улучшили качество MyUI, устроили memory leak, улучшили работу UI-контролов, пофиксили какие-то платформ-специфичные баги и улучшили performance.
1330.92 1335.24 "Анатолий Кулаков" Вот как бы стандартный набор, то, что они делают каждый раз.
1335.24 1338.68 "Анатолий Кулаков" Ну и, наверное, из того, что можно выделить, это поддержка Xcode 15.
1338.68 1344.28 "Анатолий Кулаков" В общем, можно Xcode 15 бету теперь юзать вместе с MyUI.
1344.28 1346.08 "Анатолий Кулаков" Поэтому он здесь не очень сильно выделился.
1346.08 1355.40 "Игорь Лабутин" Да, ну вот интересно, конечно, куда это все придет, насколько они его будут продвигать, что скажут про MAUI на .NET Conf в момент релиза.
1355.40 1369.96 "Игорь Лабутин" Потому что действительно новостей как-то очень мало и примеров от Microsoft очень мало, и будет выглядеть странным, если они… то есть я понимаю, как они будут гордо говорить, что у них теперь ISP.NET работает еще быстрее, но там хотя бы по анонсам видно, что много чего менялось.
1369.96 1372.04 "Игорь Лабутин" А что будет говорить про MAUI даже интересно.
1372.04 1378.28 "Анатолий Кулаков" Ну, контроллы рисуются быстрее, а мемореликов меньше.
1378.28 1380.36 "Анатолий Кулаков" Я думаю, они нальют, как бы растянут.
1380.36 1392.56 "Игорь Лабутин" Ну, хорошо, давай пойдем к команде, так сказать, Microsoft, которая гораздо больше и чаще пишет нам статьи, и статьи действительно вдумчивые и большие.
1392.56 1393.56 "Игорь Лабутин" И это Visual Studio.
1393.56 1397.72 "Игорь Лабутин" У нас вышла Visual Studio 2022-17.8 Preview 2.
1397.72 1402.44 "Игорь Лабутин" Странно, почему она до сих пор называется 2022, уже 23-й год скоро закончится.
1402.44 1405.08 "Игорь Лабутин" Ну, видимо, может быть, к релизу таки будет 2023, не
1405.08 1408.92 "Анатолий Кулаков" знаю. Ну да, может это из-за превью, а в релиз переименуют.
1408.92 1410.88 "Игорь Лабутин" Ну, будем посмотреть.
1410.88 1411.88 "Игорь Лабутин" Что поменялось?
1411.88 1415.92 "Игорь Лабутин" Как обычно, все разделено на несколько тематических разделов.
1415.92 1418.56 "Игорь Лабутин" Во-первых, это Productivity.
1418.56 1424.48 "Игорь Лабутин" Там появились такие штуки, что вы теперь можете pull requests редактировать прямо в студии.
1424.48 1430.00 "Игорь Лабутин" Причем их можно было создавать, теперь можно редактировать descriptions в Markdown, из Preview и так далее.
1430.00 1435.72 "Игорь Лабутин" В общем, потихонечку-потихонечку, по маленьким фичам, в Visual Studio появляется полноценный менеджмент pull requests.
1435.72 1438.76 "Игорь Лабутин" Это было понятно в GitHub и в Azure DevOps.
1438.76 1443.52 "Игорь Лабутин" В прошлом Preview, если я правильно помню, добавили штуку под названием summary diff.
1443.52 1452.92 "Игорь Лабутин" Это когда вы дифаете несколько файлов, два файла, и все одинаковые кусочки, они скрываются, показываются только совсем дифы именно.
1452.92 1455.56 "Игорь Лабутин" Ну, там с каким-то контекстом вокруг этих дифов.
1455.56 1461.24 "Игорь Лабутин" Теперь можно эти дифы сворачивать, в общем, некоторое количество improvement в эту вьюжку завезли.
1461.24 1470.68 "Игорь Лабутин" В GTM, если вы смотрите историю проекта с GitHub, то туда будут подтягиваться GitHub аватары авторов.
1470.68 1471.68 "Игорь Лабутин" Очень важная фича.
1471.68 1487.28 "Игорь Лабутин" Хотя на самом деле действительно помогает иногда, потому что позволяет быстро не по имени, фамилии парсить или по логину, кто же сделал какое-то изменение, а прямо по картинкам, особенно если они достаточно разные у всех, видеть, кто же какие изменения делал.
1487.28 1488.28 "Анатолий Кулаков" Может быть, полезно.
1488.28 1493.68 "Анатолий Кулаков" Ну, если у тебя большая команда, то это действительно удобно, когда визуально просто хватаешь аватарчик и все.
1493.68 1501.44 "Игорь Лабутин" Ну и мы рассказывали про фичу под названием multi-repo support, то есть когда вы можете открыть несколько репозиториев в одном салюшене.
1501.44 1504.04 "Игорь Лабутин" Мы так и не придумали, зачем это может быть надо.
1504.04 1531.20 "Игорь Лабутин" Ну так вот теперь в студии есть фича, которая называется multi-repo activation setting, и которая по дефолту стоит так, что если студия даже понимает, что кажется, вы открываете салюшен, в котором есть несколько репозиториев, то теперь можно галочкой в настройках настроить, включать автоматически эту поддержку, то есть грузить сразу там все статусы со всех гидов, или все-таки не надо и считаем, что используем один репозиторий, и надо будет выбрать какой.
1531.20 1542.96 "Игорь Лабутин" Видимо, не всем понравилось, или видимо у кого-то есть такие эти multi-repo, и они написали фидбэк, что нам не нравится, что оно автоматически включается, эта поддержка.
1542.96 1543.96 "Игорь Лабутин" Есть такие люди.
1543.96 1550.04 "Игорь Лабутин" Ну C++, GameDev подробно оставлять на улице не будем, посмотрите в статье, если интересно.
1550.04 1551.04 "Игорь Лабутин" .netc#.
1551.04 1553.20 "Игорь Лабутин" Тут не так много изменений.
1553.20 1561.88 "Игорь Лабутин" В студии, как вы знаете, есть поддержка http файлов, то есть вы можете в plaintext писать все http запросы и потом их выполнять.
1561.88 1568.92 "Игорь Лабутин" Добавили в какой-то момент, по-моему не в этом превью, а в прошлом, поддержку переменных.
1568.92 1587.16 "Игорь Лабутин" То есть если вы рядом http с http файлом положите файл под названием http_env.json, ну или его юзер-специфичную версию http_env.json.user, которую не надо коммитить, в репозитории то внутри http файла можно будет использовать переменные в двойных фигурных скобочках.
1587.16 1592.32 "Игорь Лабутин" Так вот теперь добавилась еще опция поддержки секретов.
1592.32 1606.72 "Игорь Лабутин" Теперь если вам нужно поддержать секреты, вы объявляете в этом env файле переменную, ну точнее json элемент, у которого внутри вложено объявляется json объект, у которого два поля.
1606.72 1617.80 "Игорь Лабутин" С одной стороны провайдер, поддержанные три, это например файл github, azure devops и кто-то еще, а ну локальный юзер секреты скорее всего.
1617.80 1623.60 "Игорь Лабутин" А второй параметр это собственно строка, по которой из этого провайдера можно достать нужное вам значение.
1623.60 1626.12 "Игорь Лабутин" Обычно это просто какой-то текстовый ключик.
1626.12 1631.12 "Игорь Лабутин" После чего внутри http файла можно будет использовать и туда эти секреты будут автоматически подставляться.
1631.12 1634.72 "Игорь Лабутин" Очень удобно, если вы пользуетесь такими http файлами.
1634.72 1660.44 "Игорь Лабутин" А если вы внутри ваших spnet приложений например еще держите где-то рядышком javascript или typescript приложения, и у вас там есть файлик launch.json, который обычно лежит в папочке .vscode, потому что его использует vscode, чтобы понять что можно и что нельзя запускать, то visual studio теперь тоже понимает и в дропдауне про дебаг будет сразу подтянуты все те же настройки, которые были в vscode.
1660.44 1662.72 "Игорь Лабутин" То есть те же кусочки, которые можно запустить.
1662.72 1665.32 "Игорь Лабутин" Кажется, что удобно.
1665.32 1668.04 "Игорь Лабутин" Должно быть.
1668.04 1671.12 "Игорь Лабутин" Неожиданно большая секция про f# в этот раз.
1671.12 1672.84 "Игорь Лабутин" Довольно много изменений в...
1672.84 1678.56 "Игорь Лабутин" Ну они такие, больше косметические, но много изменений вокруг f#.
1678.56 1690.80 "Игорь Лабутин" Новые кодфиксы, сильно заимпровили автодополнение, убрали лишь такой, как у них написано, noise в параметрах, в хинтах, которые показываются для имен параметров.
1690.80 1696.36 "Игорь Лабутин" Если у вас имя параметра совпадает с именем аргумента, ну зачем вам показывать хинт с именем этого же самого аргумента?
1696.36 1697.92 "Игорь Лабутин" Такие хинты теперь не показываются.
1697.92 1720.00 "Игорь Лабутин" Ну и добавилась опция под названием "активировать диагностику для неоткрытых файлов", то есть в каком-то смысле похожа на какой-нибудь solution-wide analysis, но она имеет возможно какие-то, не то чтобы проблемы, а affected performance, понятное дело, потому что у вас прайк может быть большой, и поэтому по умолчанию выключено, но можно включить.
1720.00 1725.68 "Игорь Лабутин" В отладке диагностики есть тоже несколько прям очень интересных штук.
1725.68 1748.96 "Игорь Лабутин" Во-первых, hot reload и edit and continue теперь кроссплатформенные и работают даже если ваш target, то с чем вы сейчас работаете, работает внутри WSL, да, Windows App System for Linux, или в линуксовом контейнере внутри, то есть поддерживается hot reload внутри линуксового контейнера, который крутится в WSL, ну или в докере.
1748.96 1763.48 "Игорь Лабутин" Дальше, если вы живете в ажуре и используете App Services на линуксе, что в общем я бы сказал, может быть даже один из наиболее частых сценариев, то теперь можно к ним подключаться через attach to process и отлаживаться.
1763.48 1767.60 "Игорь Лабутин" Я такое делал с виндовыми, ну теперь можно с линуксовыми.
1767.60 1772.20 "Игорь Лабутин" В профайлере, в вижу, в студийном профайлере появилась поддержка бенчмарка .NET.
1772.20 1773.20 "Игорь Лабутин" Как тебе?
1773.20 1778.04 "Анатолий Кулаков" Неплохо, неплохо, дорого закинчено, как бы с Microsoft
1778.04 1783.44 "Игорь Лабутин" начало интегрироваться. На самом деле, на самом деле это не окинчен интегрируется, это студия сделала следующее, если вы запускаете…
1783.44 1785.44 "Анатолий Кулаков" А студия закинчена, ну да, извините.
1785.44 1798.72 "Игорь Лабутин" Если вы запускаете ваш бенчмарк под профайлером, то теперь есть отдельная вьюшка, в которой показан список бенчмарков, и вы на time, и для каждого бенчмарка написано в таймлайне, где он был.
1798.72 1809.32 "Игорь Лабутин" То есть если вы, ну понятно, анализируете, что же там происходило, то вы теперь можете ткнуть в нужный конкретный бенчмарк и сказать, вот хочу этот, ну и таким образом сократить таймлайн только до нужного.
1809.32 1816.92 "Игорь Лабутин" Что удобно, потому что иначе у вас, понятно, в одном запуске смешано все, и не очень удобно.
1816.92 1828.00 "Игорь Лабутин" То есть это не какая-то там суперподдержка всего-всего-всего, пока это только вопрос таймлайна и выбора того, чего смотреть вы будете в профайлере, но кажется, это уже хороший шаг вперед.
1828.00 1831.84 "Анатолий Кулаков" Да, на практике довольно полезная штука, согласен.
1831.84 1851.28 "Игорь Лабутин" Дальше, в dotnet-каунтеры, напомню, что в вижу студийном отладчике или там профайлере, как вы на это посмотрите, есть отдельная вкладочка-окошечка с dotnet-каунтерами, теперь она работает через новый метраж API, про который мы рассказывали, ну и соответственно поддерживает там новые инструменты типа там каунтеров, observable-каунтеров и так далее.
1851.28 1861.80 "Игорь Лабутин" Ну и можно теперь, вот это вообще странная штука, сказано, что теперь можно запрофайлить юнит тест с помощью вижу студии профайлера, то есть можно теперь на тесте сказать не только там run и debug, но еще и профайл.
1861.80 1866.08 "Игорь Лабутин" Что-то мне казалось, что такое было можно всегда, но может быть я с райдером или решарпером путаю.
1866.08 1870.92 "Анатолий Кулаков" Ну такое всегда было точно у решарпера, а вот студии я не знаю, как бы там.
1870.92 1871.92 "Игорь Лабутин" Я вот тоже чуть-чуть.
1871.92 1872.92 "Игорь Лабутин" Наверное не было.
1872.92 1876.36 "Игорь Лабутин" Ну видимо добавили, сказали, что вот теперь типа можно, можно, не знаю.
1876.36 1877.36 "Анатолий Кулаков" Ну вот.
1877.36 1878.36 "Игорь Лабутин" Молодцы, и что?
1878.36 1886.40 "Игорь Лабутин" Ну вот, такие штуки на самом деле выглядят неплохо, особенно вот в секции дебаггинга, мне кажется, как-то прям хорошо обработанная команда в этой части.
1886.40 1890.44 "Игорь Лабутин" Так что ждем, ждем, ждем релиза, можно будет обновляться.
1890.44 1892.96 "Анатолий Кулаков" Слушай, ну действительно кажется, что студия, она как-то воспряла.
1892.96 1898.36 "Анатолий Кулаков" Раньше про нее меньше анонсов было, а сейчас прям смотри, javascript, и blazer, и там, темплейты, и дебаггинги.
1898.36 1902.44 "Анатолий Кулаков" Ну что-то в нее вдохнули какую-то вторую жизнь, вторую силу.
1902.44 1906.16 "Игорь Лабутин" Ну, команда Vigil Studio Format может не работать, может теперь
1906.16 1913.20 "Анатолий Кулаков" здесь работает, не знаю. Слушай, они там так работали, что я боюсь, что здесь они там особого пользы не принесут, даже если перейдут.
1913.20 1915.04 "Анатолий Кулаков" Ну, посмотрим, посмотрим.
1915.04 1929.68 "Анатолий Кулаков" Давай к следующей теме, притом тема интересная, это знаешь, как раз интересный тот случай, когда чувак со стороны как бы принес информацию про новый .NET намного интереснее, чем во всех анонсах Microsoft за последние там несколько месяцев.
1929.68 1935.20 "Анатолий Кулаков" Рассказать я вам хочу про новый способ, как можно доступиться к приватным переменам без Reflection.
1935.20 1939.44 "Анатолий Кулаков" И очень хороший способ, и новый.
1939.44 1941.40 "Анатолий Кулаков" В общем, давайте по порядку.
1941.40 1944.12 "Анатолий Кулаков" Прежде всего, зачем нам это вообще нужно?
1944.12 1949.96 "Анатолий Кулаков" Ну, начнем с того, что часто нам приходится обращаться к каким-то приватным методам, которым у нас доступа нет.
1949.96 1959.20 "Анатолий Кулаков" Допустим, такое может быть нужно для сериализации или для десериализации, ну или для чего-то еще, почему мы хотим посмотреть почему-то чужие приватные методы.
1959.20 1968.02 "Анатолий Кулаков" В обычной жизни, конечно, такое не пригождается, но если вы пишете какие-нибудь там инструменты, библиотеки или инфраструктурный код, то очень-очень часто бывает такое нужно.
1968.02 1973.28 "Анатолий Кулаков" И, разумеется, есть стандартный способ, это Reflection.
1973.28 1978.36 "Анатолий Кулаков" Другой стандартный способ, если вы умный и продвинутый, то это генерация EL-кода в рантайме.
1978.36 1985.44 "Анатолий Кулаков" Она немножко получше, но с другой стороны, оба этих подхода имеют большие минусы.
1985.44 1987.24 "Анатолий Кулаков" Самый большой минус в том, что они медленные.
1987.24 1993.08 "Анатолий Кулаков" В общем, как бы вы ни извращались, все это не очень быстро.
1993.08 2001.76 "Анатолий Кулаков" Ну и второй огромный минус, который стал актуален в последнее время, это то, что оба этих метода, они не совместимы с NativeOut.
2001.76 2007.52 "Анатолий Кулаков" NativeOut не любит компиляцию и тем более какие-то там динамические коды генерации в рантайме.
2007.52 2013.80 "Анатолий Кулаков" Потому что ему на момент компиляции нужно все знать, все прооптимизировать и все слинковать.
2013.80 2035.44 "Анатолий Кулаков" Поэтому .NET 8 ввел новую технологию, новую технику, новый способ, который с помощью Zero Overhead помогает вам доступаться к приватным членам класса без Reflection и без EL-генерации.
2035.44 2037.60 "Анатолий Кулаков" Давайте рассмотрим, как эту технику реализовать.
2037.60 2041.28 "Анатолий Кулаков" Я знаю, я знаю, поменять правила на паблик.
2041.28 2045.68 "Анатолий Кулаков" Хороший вариант, но в большинстве случаев, если бы вы могли так сделать, вы бы уже давно сделали.
2045.68 2055.44 "Анатолий Кулаков" В большинстве случаев вы должны доступаться к каким-то private переменным из чужого кода, из чужих библиотек, то есть там, где вы не можете ничего поменять.
2055.44 2059.44 "Анатолий Кулаков" Ну ладно, давай посмотрим, что же придумали.
2059.44 2063.32 "Анатолий Кулаков" Придумали опять же способ, с помощью которого можно доступаться, как его реализовать.
2063.32 2076.80 "Анатолий Кулаков" Чтобы его реализовать, вам нужно объявить extern метод, то есть по сути этот метод, которого вы не должны декларировать никакой имплементации, он подставится когда-то потом, его имплементация, в данном случае она подставится в рантайме.
2076.80 2084.20 "Анатолий Кулаков" Над этим методом вы должны навести специальный атрибут, называется unsafe access атрибут, и который принимает в себя нескольких параметров.
2084.20 2098.56 "Анатолий Кулаков" Нам в частности важны такие параметры, как тип, куда мы будем доступаться, это может быть там поле, конструктор, что-то еще и name того мембера, которому мы будем доступаться, в виде обычной строки.
2098.56 2102.88 "Анатолий Кулаков" Здесь ничего нового не придумали, от строк не ушли никуда.
2102.88 2103.88 "Анатолий Кулаков" Обычная строка.
2103.88 2124.24 "Анатолий Кулаков" И вот таким образом мы можем задекларировать специальный метод extern, навеси на него некие атрибуты, с помощью которых рантайм поймет, что именно для этого метода можно не проверять доступ к членам какого-то другого класса, а напрямую разрешить к ним обращаться.
2124.24 2138.28 "Анатолий Кулаков" В этом, в принципе, вся магия и заключается, что у вас появляется вот такой способ декларации, и вы теперь можете использовать этот метод, и его результат вернет вам приватные какие-то мемберы.
2138.28 2156.76 "Анатолий Кулаков" Этот способ, он, конечно, намного менее мощный, чем Reflection, с помощью Reflection вы больше всякой дичи можете творить с помощью или генерации, тем более, но зато он поддерживает как раз-таки очень-очень быстрый доступ ко всем этим свойствам.
2156.76 2170.36 "Анатолий Кулаков" В частности, из минусов в том, что в нем пока нет или всегда нет доступа к свойствам, есть доступ только к конструкторам, к приватным конструкторам, к приватным методам и к приватным филдам.
2170.36 2176.76 "Анатолий Кулаков" Не знаю, может быть, авторы подумали, что приватные свойства почти никто не делает, и доступаться к ним особо смысла нет.
2176.76 2183.92 "Анатолий Кулаков" Ну и также есть неполная поддержка generic types, тоже там есть с ними небольшие проблемы.
2183.92 2195.16 "Анатолий Кулаков" А во всем остальном, в принципе, шикарный метод, показывает отличные performance результаты, то есть, естественно, не сравнится ни с какими-либо reflection, ни с какими-либо лимитами.
2195.16 2196.48 "Анатолий Кулаков" В общем, все это работает быстро и прекрасно.
2196.48 2217.44 "Анатолий Кулаков" Также, как подсказал Егор Богатов, инсайт изнутри, что основным мотиватором для изобретения такого костыля была команда Entity Framework, потому что как раз-таки Entity Framework очень любит сериализовать всякие приватные стейты, для того чтобы засунуть их в баску, а потом как бы загрузить из баски.
2217.44 2222.52 "Анатолий Кулаков" Кстати, да, про загрузку тут ничего нет, здесь, по-моему, только про аксессоры.
2222.52 2229.04 "Игорь Лабутин" Ну, я немножко проспойлерю, можно делать и сеттер через него.
2229.04 2230.88 "Игорь Лабутин" Делается это следующим образом.
2230.88 2235.80 "Игорь Лабутин" Ты объявляешь вот такой метод, навешиваешь на него атрибут unsave_accessor.
2235.80 2248.80 "Игорь Лабутин" Ну и надо понимать, смотрите, если вы хотите сделать getter, то вы у этого метода объявляете один параметр того типа, к которому вы хотите доступаться.
2248.80 2253.96 "Игорь Лабутин" Надо же как-то тип-то знать, а то мы тип-то вообще-то, говоря, нигде не указали, мы указали только имя поля в атрибутчике.
2253.96 2260.32 "Игорь Лабутин" Так вот тип указывается первым аргументом, ну он такой типа а-ля как в extension методах, this будет, да.
2260.32 2269.44 "Игорь Лабутин" А возвращаемое значение должно быть, ну там, не знаю, int, например, если у вас это поле int или string, если у вас строковое поле.
2269.44 2275.52 "Игорь Лабутин" А чтобы сделать сеттер, вы возвращаете не int и не string, а вы возвращаете ref string.
2275.52 2280.56 "Анатолий Кулаков" И мы можем по этому ref значение поменять, да, и оно отразится
2280.56 2298.68 "Игорь Лабутин" в оригинальном значении. Да, только код будет выглядеть, конечно, очень шикарно, потому что у вас будет выглядеть, ну я не знаю, вот имя вашего метода, unsave что-нибудь, unsave_set что-нибудь, скобочка круглая открылась, instance вашего объекта, скобочка круглая закрылась, присвоить значение.
2298.68 2302.36 "Игорь Лабутин" Поскольку это ref, то его можно использовать слева за знаком присвоения.
2302.36 2310.64 "Игорь Лабутин" Это такой, мне кажется, C++ стайл совсем уже, когда вызов метода слева от знака присвоения, но так можно.
2310.64 2317.20 "Анатолий Кулаков" Ну да, получается, что мы уже меняем, выглядит как будто мы меняем какой-нибудь метод сам.
2317.20 2319.36 "Анатолий Кулаков" Пошла магия на указателях, я чувствую.
2319.36 2320.36 "Анатолий Кулаков" Пошла-пошла.
2320.36 2321.36 "Игорь Лабутин" Ну почти.
2321.36 2324.52 "Игорь Лабутин" Я этот пример, кстати, видел в блоге у Тауба, как раз таки мы до него доберёмся сегодня.
2324.52 2327.68 "Анатолий Кулаков" Да, то есть он тоже не скрывает, что такое есть.
2327.68 2341.08 "Анатолий Кулаков" Хорошо, хорошо, ну в общем, те редкие случаи, когда вам всё-таки нужно доступаться к приватным полям, они по идее действительно должны быть редки, но когда нужно, вот теперь у вас есть такой быстрый доступ.
2341.08 2358.56 "Анатолий Кулаков" Ещё нужно отметить, что здесь в принципе не зря ставили именно строковое имя члена или имя метода, имя поля, потому что, наверное, предполагается, что мы будем использовать этот атрибут только из source-генераторов.
2358.56 2366.60 "Анатолий Кулаков" То есть из того места, где мы точно знаем, в какой строчке, в каком файлике и как называлось это поле, как мы недавно обсуждали с интерсепторами.
2366.60 2376.40 "Анатолий Кулаков" Но я думаю, что как бы так же точно, как и Reflection, нам никто не мешал пользоваться без source-генераторов, так же точно этим атрибутом будут навешивать без всяких source-генераторов.
2376.40 2389.52 "Игорь Лабутин" Ну наверняка сейчас появятся какие-нибудь кастомные супер-пупер быстрые сериализаторы, которые прям вообще делают всё это самое шустро и быстро, до тех пор, пока дотнетрантайм не поменяет какую-нибудь внутреннюю структуру.
2389.52 2399.40 "Анатолий Кулаков" Ну нам-то не надо внутреннюю структуру, смотри, по имени поля ты всегда можешь сгенерить себе source-генератором очень быстрый сериализатор, который напрямую ходит к полям и записывает их, куда надо.
2399.40 2417.72 "Игорь Лабутин" Ну это как ты говоришь, это если source-генератор, а если без, то как бы… Я на самом деле видел код, ну в библиотеке по крайней мере, который там закладывается на тот факт, что там в лист от Т есть всегда поле, что-то как там, подчёркивание Ray или как-то так, которое собственно содержится внутри коллекции.
2417.72 2424.64 "Анатолий Кулаков" Ну да-да, все микроэремы почти этим хаком используют этот хак, да.
2424.64 2426.64 "Анатолий Кулаков" Ну посмотрим, подлиннее.
2426.64 2435.20 "Анатолий Кулаков" Смотри, хороший атрибутик в принципе для… опять же, если не злоупотребляете, но там, где нужно, мне кажется, вообще достойная вещь.
2435.20 2448.00 "Игорь Лабутин" Мне кажется, это на самом деле, да, один из наиболее частых способов, ну один из частых способов, зачем нужна рефлексия, а ещё она нужна для вызова методов, но про это мы поговорим чуть позднее.
2448.00 2451.00 "Игорь Лабутин" В принципе, через эту штуку можно и методы вызывать, правильно же, да?
2451.00 2454.60 "Анатолий Кулаков" Ну она может давать тебе доступ к приватным методам, раз может давать доступ, да.
2454.60 2457.76 "Игорь Лабутин" О, смотри, можно теперь юнитестировать приватные методы.
2457.76 2458.76 "Игорь Лабутин" Отказать.
2458.76 2459.76 "Анатолий Кулаков" Ладно, не будем.
2459.76 2469.00 "Анатолий Кулаков" Я чувствую, да, до следующего выпуска мне надо достать статью там «Лучшие практики юнитестирования», чтобы вот такие мысли даже в голове не появлялись ни у кого.
2469.00 2471.84 "Игорь Лабутин" Хорошо, я ещё что-нибудь придумаю к следующему выпуску.
2471.84 2472.84 "Игорь Лабутин" Ладно, поедем дальше.
2472.84 2477.00 "Игорь Лабутин" У нас мега-статья Стивена Тауба про performance improvements.
2477.00 2483.20 "Анатолий Кулаков" Мы не будем… Да хорош, тогда я пошёл спать, ты меня там кутру разбудишь, когда закончишь читать.
2483.20 2484.20 "Игорь Лабутин" Да, кутру разбужу.
2484.20 2490.12 "Игорь Лабутин" Нет, я потратил на её просмотр и подготовку к этому подкасту примерно полтора часа.
2490.12 2501.40 "Игорь Лабутин" Очень удобная статья, я сегодня летел на самолёте, соответственно, 2 часа, открыл в аэропорту, и как бы мне не нужен был интернет её дальше читать.
2501.40 2505.20 "Игорь Лабутин" Она очень длинная, и как бы 2 часа пролетели незаметно.
2505.20 2507.20 "Игорь Лабутин" Ну чуть меньше на самом деле, потому что…
2507.20 2510.52 "Анатолий Кулаков" Да мне кажется, что за 2 часа её нереально прочитать.
2510.52 2516.96 "Игорь Лабутин" Прочитать нереально. Я её просмотрел, собственно, минут за 90, вот.
2516.96 2524.80 "Игорь Лабутин" А ещё у меня есть, ну у меня же все эти самые, как называется, статейки я складываю в pocket.
2524.80 2528.44 "Игорь Лабутин" Ну вы, наверное, знаете, да, pocket такая штука, куда складывают статьи и никогда их не читают.
2528.44 2545.28 "Игорь Лабутин" Вот, у меня там лежат статьи, в частности туда идут статьи, по которым я потом готовлюсь, и там она лежала, а pocket показывает, ну, собственно, сколько, по его мнению, времени нужно, чтобы прочитать статью.
2545.28 2546.28 "Игорь Лабутин" Ну-ка, ну-ка.
2546.28 2555.92 "Игорь Лабутин" И вот для примера, и у меня сейчас как раз открыт pocket, можно сказать, что вот, например, entity framework core, да, релизы вот этих про комплекс тайп и то, что ты рассказывал, время чтения 13 минут.
2555.92 2557.56 "Игорь Лабутин" Ну такая большая статья.
2557.56 2559.88 "Игорь Лабутин" А S/P/Nad Core 9 минут.
2559.88 2563.92 "Игорь Лабутин" MAUI 2 минуты, ну, всё понятно.
2563.92 2566.76 "Игорь Лабутин" Что тут ещё интересного из того, что мы обсуждали?
2566.76 2569.04 "Игорь Лабутин" Ну, наверное, пока ничего.
2569.04 2574.52 "Игорь Лабутин" И вот этот вот Steven Tao performance improvements 298 минут, по его мнению.
2574.52 2575.52 "Игорь Лабутин" Это 5 часов.
2575.52 2585.88 "Анатолий Кулаков" То есть 5 часов просто, чтобы прочитать статью, вот даже там не вникая, не запоминая, не обдумывая, 5 часов, друзья, вот целый рабочий день можете угробить только на чтении одной статьи.
2585.88 2589.00 "Игорь Лабутин" На написании, мне кажется, он угробил целый рабочий месяц.
2589.00 2591.20 "Игорь Лабутин" Да, скорее всего, даже побольше.
2591.20 2599.60 "Игорь Лабутин" То есть всё надо было выверить, вычистить, плюс оформить, там же всякие подсветки кода, хайлайтинги, битчмарки, таблички, вот это всё, короче, много.
2599.60 2606.84 "Анатолий Кулаков" Лишний раз по восхищаемся работоспособности Тауба, будьте как Тауб, пишите хорошие, большие, понятные
2606.84 2609.28 "Игорь Лабутин" статьи. Да, он при этом ещё и коммитит в код, как ни в себе.
2609.28 2611.20 "Игорь Лабутин" Да, он ещё и работает когда-то.
2611.20 2619.96 "Игорь Лабутин" Поэтому давайте мы просто пробежимся, я для себя что-то захайлайтил из того, что мне показалось интересным упомянуть.
2619.96 2627.24 "Игорь Лабутин" Здесь не будет практически никаких чисел, за числами пожалуйста в саму статью, она разбита на разделы, очень удобно по ним смотреть, искать.
2627.24 2630.32 "Игорь Лабутин" Но про какие-то вещи я, наверное, скажу.
2630.32 2635.72 "Игорь Лабутин" И начинаем мы с джета, с того самого тиринга и профайл гайдед оптимизейшена.
2635.72 2642.88 "Игорь Лабутин" Во-первых, у нас теперь по умолчанию включён динамический профайл гайдед оптимизейшен.
2642.88 2650.28 "Игорь Лабутин" Надо понимать, что у нас был ещё и статический, почему мы все называем его дайнэмик профайл гайдед, потому что есть статический, который называется радиотуран.
2650.28 2659.68 "Игорь Лабутин" Это значит, что вы запустили приложение, оно как-то поработало, собрался профиль, что-то там поджитилось согласно этому профилю, и вот этот поджитченный код лежит рядом с вашей обычной сборкой.
2659.68 2663.92 "Игорь Лабутин" И используется в момент запуска сначала, пока джит не поработает.
2663.92 2670.60 "Игорь Лабутин" И тут интересный момент, если внимательно почитать статью, на самом деле этих самых тайров, их больше чем два.
2670.60 2673.60 "Игорь Лабутин" Они называются 0 и 1, но на самом деле их больше.
2673.60 2686.88 "Игорь Лабутин" Если ваше приложение, а большинство ваших приложений будет такими, было скомпилировано без радиотурана, то сначала оно запускается в так называемый tier 0, который без оптимизации и без инструментации.
2686.88 2696.24 "Игорь Лабутин" То есть ваши методы просто компилируются так, быстренько, без особой усердия, назовём это так, и как-то так, худо-бедно работают.
2697.24 2707.64 "Игорь Лабутин" Потом метод перекомпилируется, если он достаточно часто вызывается, он перекомпилируется всё ещё без оптимизации, но уже с инструментацией.
2707.64 2715.08 "Игорь Лабутин" То есть внутри всяких бранчей добавляется сбор статистики, по какому пути мы пошли и так далее.
2715.08 2719.12 "Игорь Лабутин" То есть не только как часто мы метод вызываем, но и куда мы внутри ходим для больших методов.
2719.12 2720.12 "Игорь Лабутин" Это полезно.
2720.12 2730.44 "Игорь Лабутин" И когда наберётся соответствующая статистика по вот этим вот переходам, всё это перекомпилируется уже в tier 1, медленно с оптимизациями и так далее, и подменяется, чтобы всё работало быстро.
2730.44 2739.32 "Игорь Лабутин" Если же у вас был ready-to-run вариант, то есть у вас уже была какая-то версия, она оптимизированная, ну как-то,
2739.32 2744.24 None но без инструментации. Понятное дело, потому что инструментацию никто не добавлял в ready-to-run образ.
2744.24 2746.28 "Игорь Лабутин" Поэтому обычно работает она.
2746.28 2753.96 "Игорь Лабутин" Потом это всё компилируется в tier 1, который оптимизирован всё так же, как в ready-to-run, но с инструментацией.
2753.96 2761.08 "Игорь Лабутин" И потом перекомпилируется снова в tier 1, но уже с информацией от собственно инструментации.
2761.08 2773.16 "Игорь Лабутин" Короче я не знаю, почему они не сделали 0.1.2, потому что либо мы 2 раза в 0 оказываемся с инструментацией и без инструментации, либо мы 2 раза оказываемся в tier 1 с инструментацией и с оптимизацией.
2773.16 2776.00 "Игорь Лабутин" Ну в общем как-то странно это выглядит, но тем не менее работает так.
2776.00 2778.04 "Игорь Лабутин" В общем-то это такие.
2778.04 2784.52 "Игорь Лабутин" Это основное большое изменение в GTA, там много, очень много мелочей всяких разных других, но тем не менее.
2784.52 2786.88 "Игорь Лабутин" Дальше был большой раздел про векторизацию.
2786.88 2794.36 "Игорь Лабутин" Тут надо всего лишь сказать, что есть такой тип, ну вообще векторизация использована для векторных конструкций процессоров, всякие SSE, AVX, вот это всё.
2794.36 2802.40 "Игорь Лабутин" У нас был тип вектора 256, его улучшили, добавили поддержку новых команд, вот это всё.
2802.40 2811.00 "Игорь Лабутин" Но есть процессоры с поддержкой AVX 512, когда вы можете сразу AVX 512 битами управлять, и для этого появился тип вектор 512.
2811.00 2812.64 "Игорь Лабутин" Тут всё хорошо.
2812.64 2813.64 "Игорь Лабутин" Дальше бранчинг.
2813.64 2815.60 "Игорь Лабутин" Это тоже интересная штука.
2815.60 2825.20 "Игорь Лабутин" Как вы помните, бывает такой особый вид, не знаю, спортивного программирования, назовём это так, когда вы пишете код без бранчей.
2825.20 2827.08 "Игорь Лабутин" Ну всем это знают, да, бранчи плохо.
2827.08 2833.92 "Игорь Лабутин" Процессор там не знает куда идти, сбрасывает кэш, заново загружает pipeline инструкции, короче всё плохо.
2833.92 2840.32 "Игорь Лабутин" Но надо понимать, что в реальном коде действительно бывают тяжёлые бранчи, когда мы прям сурово разделяемся.
2840.32 2847.64 "Игорь Лабутин" А бывают очень простые бранчи, и в одно присвоят из одного значения, и в другое, ну если я не ошибаюсь, присвоят из какого-то другого места.
2847.64 2848.64 "Игорь Лабутин" И всё.
2848.64 2850.84 "Игорь Лабутин" И дальше как бы пошли снова без бранчей.
2850.84 2859.52 "Игорь Лабутин" Так вот, на современных процессорах для таких операций есть прям отдельная цепу инструкций, там cmove, csel, и если их имитить, то код будет без бранча.
2859.52 2865.08 "Игорь Лабутин" В C# у вас есть бранч, а в реальном ассембле не будет бранча.
2865.08 2869.12 "Игорь Лабутин" Вот эта оптимизация тоже теперь есть, и на x64, и на рмах.
2869.12 2874.16 "Игорь Лабутин" Соответственно, код, который вы видите на мониторе будет с бранчами, а исполнимый без.
2874.16 2875.16 "Игорь Лабутин" Прекрасно.
2875.16 2882.68 "Игорь Лабутин" Также JIT научился распознавать ещё дополнительные паттерны с точки зрения bounce-чекинга.
2882.68 2890.76 "Игорь Лабутин" Ну то есть надо понимать, что есть классические места, в которых не используется bounce-чекинг.
2890.76 2898.24 "Игорь Лабутин" То есть если вы написали for от нуля до длины массива, то компилятор прекрасно понимает, что внутри этого for'а можно не делать bounce-чекинг.
2898.24 2902.36 "Игорь Лабутин" И если вы не делаете каких-то операций с индексом вручную, конечно же.
2902.36 2906.88 "Игорь Лабутин" Но теперь он понимает ещё больше паттернов.
2906.88 2925.24 "Игорь Лабутин" Например, если вы взяли значение, нашли остаток его деления на длины массива и потом пошли индексироваться в этот массив, то точно bounce-чеков не нужно, потому что операция остатка деления точно вернёт число между нулём и длиной массива минус единичкой.
2925.24 2930.52 "Игорь Лабутин" И это очень частый кейс, потому что это то, как работает хэш-табличка, то бишь дикшенерия и всё такое прочее.
2930.52 2932.80 "Игорь Лабутин" Там теперь не будет bounce-чеков.
2932.80 2934.48 "Игорь Лабутин" То как бы хорошо в плюсу скорости.
2934.48 2941.68 "Игорь Лабутин" Так, ну constant folding, понятно, там ещё больше логики про константы.
2941.68 2954.80 "Игорь Лабутин" Gc, с Gc появилась штука под названием non-GCHIP, мы про это рассказывали, называлась это frozen object heap, оно в принципе сейчас так называется, я понимаю, но почему-то в статье называется non-GCHIP.
2954.80 2963.16 "Игорь Лабутин" Смысл в том, что туда можно положить объекты, даже есть способ туда их в принципе положить, но в этих объектах не должно быть ссылок на обычную кучу.
2963.16 2981.44 "Игорь Лабутин" То есть если у вас есть какие-то объекты, которые там более-менее константные, то вы можете их туда запихнуть, после чего G будет нужно делать редиректом, куда сейчас указывается ссылка, можно просто вообще хардкорные адреса писать во всех местах, где используются такие объекты, потому что они никогда гарантированно не будут подвинуты garbage-коллектором никуда.
2981.44 2988.68 "Игорь Лабутин" Викторизация, викторизация, викторизация, это я так проглядываю свои заметки, пропускаю всё лишнее.
2988.68 2992.52 "Игорь Лабутин" А, value-typing, с value-typing интересная штука произошла.
2992.52 3005.72 "Игорь Лабутин" Есть такое понятие struct promotion, называется оно, мне кажется, не очень правильно, наверное, потому что по смыслу штука следующая.
3005.72 3019.64 "Игорь Лабутин" Если у вас есть, например, структуру с, не знаю, там, тремя-четырьмя int-полями, то если вы куда-то где-то её таскаете, присваиваете и так далее, то она всегда таскается, присваивается, копируется как единое целое.
3019.64 3034.44 "Игорь Лабутин" Но может случиться так, что, допустим, вы передали структуру в какую-то функцию, а внутри функции вы используете только одно поле от этой структуры, поэтому технически передавать вы туда можете только одно поле из всех.
3034.44 3042.84 "Игорь Лабутин" И вот struct promotion — это на самом деле оно, то есть это рассмотрение структуры как просто набора индивидуальных полей.
3042.84 3055.76 "Игорь Лабутин" И тогда JIT понимает, какой код генерить, как оптимальнее короче передавать объекты, как не копировать структуру целиком, а копировать только нужные её кусочки, если, например, вы передаете жирную структуру куда-то, то вы используете там только пару полей из неё.
3055.76 3068.60 "Игорь Лабутин" Эта штука была поддержана уже в семёрке, но она была поддержана в семёрке только для структур, где полей не больше четырёх и не были поддержаны вложенные такие структуры, теперь всё улучшили.
3068.60 3082.64 "Игорь Лабутин" Native Out — как ты говорил, значит, существенное улучшение размера на диске, и это был фокус этого релиза, то есть фокус релиза — уменьшить размер на диске.
3082.64 3107.88 "Игорь Лабутин" Для тестов можно сказать, по-моему, одним из немногих чиселок будут, что из 13 мегабайт для Hello World получилось полтора мегабайта, ну прям почти в 10 раз, и это при этом не предел, можно ещё больше оптимизировать, если выкинуть всякие там интернационализацию, можно ещё разных флажков поуказывать, и тогда размер ещё больше уменьшается.
3107.88 3108.88 "Игорь Лабутин" Это прям хорошо.
3108.88 3113.80 "Игорь Лабутин" Так, трейдинг с потоками.
3113.80 3117.20 "Игорь Лабутин" Здесь происходит следующее.
3117.20 3122.28 "Игорь Лабутин" С потоками ускорился довольно существенный доступ к тред-статикам.
3122.28 3130.32 "Игорь Лабутин" Тред-статик — это некая переменная, которая имеет своё значение для каждого потока отдельное.
3130.32 3135.16 "Игорь Лабутин" Если вы к ней в коде, вы доступаетесь как будто к одной переменной, но в каждом потоке значение будет отдельное.
3135.16 3138.84 "Игорь Лабутин" Это довольно часто используется для прокидывания контекста туда-сюда.
3138.84 3147.96 "Игорь Лабутин" И понятно, что в мире async/await это частенько делается через async/local, но tread-local тоже до сих пор продолжают жить и бывают полезными.
3147.96 3151.80 "Игорь Лабутин" Вот они, в общем, ускорились.
3151.80 3155.56 "Игорь Лабутин" А ещё ускорилось кэширование тасков.
3155.56 3160.40 "Игорь Лабутин" Точнее, не ускорилось кэширование тасков, а появилось и расширилось кэширование тасков.
3160.40 3173.20 "Игорь Лабутин" Смотрите, если вы делаете какой-нибудь task.from_result, то если у вас часто делается task.from_result, например, от нуля, то нет смысла каждый раз создавать новый таск.
3173.20 3175.64 "Игорь Лабутин" В принципе, такой таск можно закэшировать.
3175.64 3187.16 "Игорь Лабутин" Так вот теперь все таски, которые можно создать для любых value типов с размером до 16 байт, они закэшированы.
3187.16 3190.96 "Игорь Лабутин" Ну, то есть понятно, что не со всеми значениями, а с дефолтными значениями.
3190.96 3202.16 "Игорь Лабутин" То есть если вы возвращаете условный task.from_result от нуля или от double нуля или от, не знаю, longа нуля, то нового таска создаваться не будет.
3202.16 3207.36 "Анатолий Кулаков" То есть мне ничего для этого специально делать не надо, это вот обычный конструктор.from_result.
3207.36 3216.48 "Игорь Лабутин" Да, да, да, да, да, он будет внутри сам понимать, что это константа, ну, короче, это default от t, и сам будет возвращать то, что нужно.
3216.48 3221.48 "Игорь Лабутин" Дальше с parallel_api, ты использовал когда-нибудь parallel_for_each_async?
3221.48 3223.48 "Анатолий Кулаков" Да, почему-то было дело.
3223.48 3225.48 "Анатолий Кулаков" Не помню, зачем, наверное, просто поиграться.
3225.48 3237.84 "Игорь Лабутин" Он, короче, делает дофигища аллокаций внутри себя, и это было не очень хорошо, и поэтому теперь появился новый API, называется parallel.for_async, который почти ничего не аллокирует.
3237.84 3241.96 "Игорь Лабутин" Там на бенчмарке разница была, что это типа 20 мегабайт против 700 байт или как-то так.
3241.96 3245.40 "Анатолий Кулаков" Чё, а старые оптимизировать никак, надо обязательно новые создавать.
3245.40 3249.16 "Игорь Лабутин" Там чё-то какая-то была непонятка, но в общем сделали for_async теперь.
3249.16 3255.40 "Игорь Лабутин" Он по-другому работает, и там, видимо, итераторы не нужно создавать, ну типа потому что подцикл просто будет бегать.
3255.40 3265.16 "Игорь Лабутин" Там, возможно, другие требования к коллекции, там скорее всего не inumerable, а какой-нибудь icollection, чтобы, ну, понятно, доступ по индексу был и можно было количество элементов узнать.
3265.16 3272.88 "Анатолий Кулаков" Я думаю, что теперь мы опять вернёмся к баттлам "кто быстрее for или for_each", и как к коллекции правильно отбегать там сначала или с конца.
3272.88 3275.68 "Игорь Лабутин" Да, при parallel это особенно важно.
3275.68 3278.76 "Игорь Лабутин" Ну, тем не менее.
3278.76 3280.16 "Игорь Лабутин" Дальше с exceptions.
3280.16 3301.76 "Игорь Лабутин" Мы, наверное, не знаем, насколько бы все привыкли, но в каноничный способ в дотнете сейчас проверять всякие аргументы на null, если вдруг они у вас есть, и вам нужно написать классический код if argument = null throw argument null exception, то нужно использовать helper, да, argument null exception.throw if и передать туда условие, ну, параметр, да.
3301.76 3302.76 "Игорь Лабутин" Почему так?
3302.76 3309.48 "Игорь Лабутин" Потому что если внутри метода есть конструкция throw, то шансов, что он заинлайнится, практически нет.
3309.48 3312.84 "Игорь Лабутин" По-моему, это даже show_stopper для inliner, я не помню.
3312.84 3313.84 "Анатолий Кулаков" Наизусть, на полном.
3313.84 3316.48 "Анатолий Кулаков" Да, насколько я знаю, шансы 100% что он не заинлайнится.
3316.48 3317.48 "Игорь Лабутин" Вот.
3317.48 3320.36 "Игорь Лабутин" А если вы используете такой helper, ну, как бы вызов helper заинлайнится.
3320.36 3325.04 "Игорь Лабутин" Ну, в смысле, ваш метод может заинлайнится, а helper не заинлайнится, наоборот.
3325.04 3332.56 "Игорь Лабутин" Но шансов, что значение всё-таки не null обычно, ну, короче, нормально будет, и это рекомендованный сейчас способ.
3332.56 3342.16 "Игорь Лабутин" И такой же способ теперь есть для argument out of range exceptions, потому что там добавили гору методов throw_if, всяких там, больше, меньше, короче, в ренже и так далее.
3342.16 3346.84 "Игорь Лабутин" Если вы вдруг кидаете argument out of range exceptions, берите, можно пользоваться.
3346.84 3350.64 "Анатолий Кулаков" Что-то хорошее такое нововведение, которое должно было во фреймворк попасть.
3350.64 3351.64 "Анатолий Кулаков" Зачем вы в performance засунули?
3351.64 3352.64 "Анатолий Кулаков" Оно как на performance влияет?
3352.64 3353.64 "Анатолий Кулаков" Чисто ради inlining?
3353.64 3354.64 "Анатолий Кулаков" Быстрее, да, inlining, вот это всё.
3354.64 3355.64 "Игорь Лабутин" Понятно, ну, ладно.
3355.64 3357.64 "Игорь Лабутин" А может оно и было во фреймворке каком-нибудь из превью, мы просто уже забыли.
3357.64 3358.64 "Игорь Лабутин" Столько этих мелочей.
3358.64 3360.64 "Игорь Лабутин" Или просто не обратили внимания, поскольку в этом же превью вышло как раз таки.
3360.64 3363.64 "Игорь Лабутин" Ну, может, в релизе посмотрим.
3363.64 3364.64 "Игорь Лабутин" Рефлекшн.
3364.64 3374.92 "Игорь Лабутин" С рефлекшеном, если вам всё-таки нужен рефлекшен, и вы не хотите использовать тот самый unsafe attribute, unsafe accessor точнее, то в рефлексине тоже стало быстрее.
3374.92 3383.44 "Игорь Лабутин" В рефлекшене уменьшились аллокации довольно сильно, там довольно много рождалось таких массивов объектов для аргументов и вот этого всего, этого стало поменьше.
3383.44 3389.96 "Игорь Лабутин" Добавили вот эти вот, я не знаю, определённые, там, объекты для аргументов, вот этого всего, этого стало поменьше.
3389.96 3393.92 "Игорь Лабутин" Добавилось довольно агрессивное кэширование всей нужной данных.
3393.92 3397.04 "Игорь Лабутин" А ещё добавилось два новых класса.
3397.04 3400.52 "Игорь Лабутин" Один называется метод Invoker, второй называется конструктор Invoker.
3400.52 3403.28 "Игорь Лабутин" Потому что, что делалось?
3403.28 3410.00 "Игорь Лабутин" Вы обычно, чтобы вызвать метод, вы там говорили, дайте мне тип, потом дай мне метод, а потом говорили метод точка Invoke.
3410.00 3414.88 "Игорь Лабутин" Да, и передавали instance объекта, и набор аргументов, если нужно, для метода.
3414.88 3424.88 "Игорь Лабутин" Так вот, внутри этот метод делает довольно много одинаковых операций для вызова одного и того же метода, который было бы неплохо сделать один раз и закэшировать.
3424.88 3432.60 "Игорь Лабутин" Вот метод Invoker, то есть вы теперь его, так сказать, создаете класс метод Invoker, передаете туда, к какому типу, какой метод нужно будет вызывать.
3432.60 3438.40 "Игорь Лабутин" Он делает всю необходимую магию с методанными, всё кэширует в себе, и дальше Invoke, он там супербыстрый.
3438.40 3441.56 "Игорь Лабутин" То есть так же для конструктора.
3441.56 3446.08 "Игорь Лабутин" Так что если вам всё ещё нужно Reflection, обязательно смотрите на эти два класса, они вам точно всё ускорят.
3446.08 3451.64 "Анатолий Кулаков" Ну да, супер кейс, очень часто, и да, странно, почему они раньше до него не додумались.
3451.64 3454.64 "Игорь Лабутин" Ну, руки не доходили.
3454.64 3455.64 "Игорь Лабутин" Enumчики.
3455.64 3458.44 "Игорь Лабутин" С Enumчиками тоже стало интересно.
3458.44 3462.44 "Игорь Лабутин" Как ты думаешь, как раньше хранились значения Enumов?
3462.44 3467.16 "Игорь Лабутин" Вот ты определил Enum, да, как хранить все его значения?
3467.16 3470.88 "Анатолий Кулаков" В виде какого-нибудь Int, побитой маски, вот смотря
3470.88 3476.12 "Игорь Лабутин" где хранить-то. И внутри надо же как-то хранить, в смысле все возможные
3476.12 3478.52 "Анатолий Кулаков" значения. А, все возможные перечислить?
3478.52 3479.52 "Анатолий Кулаков" Угу.
3479.52 3481.52 "Анатолий Кулаков" Не знаю, какой-нибудь там массив строк, что-нибудь там ещё было.
3481.52 3482.52 "Игорь Лабутин" Там хранилось два массива.
3482.52 3486.60 "Игорь Лабутин" Один массив строк, это имена Enumов, и один массив
3486.60 3488.60 "Анатолий Кулаков" у... А другой массив у?
3488.60 3489.60 "Анатолий Кулаков" Чего?
3489.60 3490.60 "Анатолий Кулаков" А другой массив Values.
3490.60 3491.60 "Анатолий Кулаков" Валюсов.
3491.60 3492.60 "Анатолий Кулаков" Там же не только Int может быть, там может быть всё
3492.60 3498.40 "Игорь Лабутин" что угодно. Да, да, именно поэтому там хранился массив UnsignedLangov, потому что...
3498.40 3499.40 "Анатолий Кулаков" UnsignedLangov?
3499.40 3500.40 "Анатолий Кулаков" Да.
3500.40 3501.40 "Анатолий Кулаков" А если у меня будет там decimal?
3501.40 3503.40 "Анатолий Кулаков" Да, decimal ты не можешь Enumчик сделать.
3503.40 3505.08 "Анатолий Кулаков" А на что я могу?
3505.08 3506.08 "Анатолий Кулаков" Можно какие-нибудь floats?
3506.08 3507.08 "Анатолий Кулаков" Нет.
3507.08 3512.64 "Игорь Лабутин" Ну, floats, нет, floats можно, можно даже doubles, они побитого приводят просто к long.
3512.64 3515.64 "Игорь Лабутин" Ну, в смысле double влезает в 8 байт long, поэтому всё
3515.64 3518.40 "Анатолий Кулаков" нормально. Ну, то есть это по сути байт арены, он там хранил,
3518.40 3520.40 "Игорь Лабутин" да, размер long. По сути да.
3520.40 3521.40 "Игорь Лабутин" Почему был выбран у long?
3521.40 3525.96 "Игорь Лабутин" Потому что у long 8 байт, это максимальный размер того, что может быть базовым типом Enum.
3525.96 3538.24 "Игорь Лабутин" Но получается не очень, потому что по статистике внезапно большинство, то есть 99% Enum естественно интовые.
3538.24 3543.44 "Анатолий Кулаков" Ну, просто естественно дефолтные, никто не переопределяет, а по дефолту они интовые.
3543.44 3553.80 "Игорь Лабутин" Они интовые, и поэтому теперь там переделали внутреннюю кухню и теперь там хранится дженериковый массив типа T, ну массив типа T, где T это базовый тип Enum.
3553.80 3559.20 "Анатолий Кулаков" Ну вот это уже покручить, может теперь мы как раз дексельминишн юнином дойдём, если там T.
3559.20 3560.20 "Анатолий Кулаков" Ну, может быть когда-нибудь.
3560.20 3561.64 "Игорь Лабутин" Можно туда и класс какой-нибудь засунуть.
3561.64 3568.48 "Игорь Лабутин" Да, может быть когда-нибудь, но по крайней мере теперь все Enumчики, ну обычные, стандартные, кушают в два раза меньше места.
3568.48 3573.88 "Игорь Лабутин" Ну ладно, не в два, имена всё равно хранить приходится, поэтому не так много.
3573.88 3591.40 "Игорь Лабутин" Но в дополнение с этим они довольно сильно заимпровили toString и isDefined, два таких метода на Enumе, если известно, что все значения Enumа последовательны от нуля до какой-то константы.
3591.40 3603.72 "Игорь Лабутин" Ну то есть если вы не переопределяете значения, если вы не пишете там Enum first = 1, second = 4, third = 6, странный, наверное, Enum будет, но тем не менее, почему нет.
3603.72 3607.80 "Игорь Лабутин" Бывает нужно явно определить какие-то значения, в этом случае всё останется как было.
3607.80 3614.40 "Анатолий Кулаков" А как они выясняют эту информацию, что там по порядку идут все значения?
3614.40 3616.56 "Игорь Лабутин" Ну в рантайме при инициализации, при загрузке типа, вероятно,
3616.56 3623.12 "Анатолий Кулаков" это можно узнать. То есть при загрузке типа они один раз делают анализ и выясняют, как оптимально теперь обращаться к toString.
3623.12 3642.04 "Игорь Лабутин" И если они понимают, что там вот этот от нуля до n все значения, то всякие isDefined и toString это просто поиск по индексу в массиве, потому что гарантированно всё лежит в массиве подряд, а иначе это цикл по массиву с поиском, сравнение строчек, ну в общем вот этого всего.
3642.04 3646.92 "Игорь Лабутин" Короче, должно стать быстрее существенно для таких common case.
3646.92 3647.92 None Дальше.
3647.92 3675.16 "Игорь Лабутин" Кэширование тутнет теперь любит очень сильно, и поэтому если вы вызовете toString на int, и ваш int входит в диапазон от нуля до 299-ти включительно, то вам вернется константная строчка, ну в смысле теперь закэшированы строки, строковое представление int от нуля до 299-ти, и оно будет всегда возвращаться toString.
3675.16 3679.84 "Игорь Лабутин" Если вызван, ну в дефолтной понятно, локали, там вот это всё без каких-либо перегрузок по локали.
3679.84 3700.04 "Игорь Лабутин" Число 299 выбрано случайно, как написано в статье, в каком-то смысле типа, может мы его попробуем поддать, короче не закладывайте на это поведение, считайте, что toString возвращает всегда разные, а может одинаковые, никто не знает, нельзя ничего предполагать, мы будем это вероятно менять.
3700.04 3730.76 "Игорь Лабутин" Дальше есть огромное количество всяких разных улучшений в форматинге и в парсинге, то есть добавился интерфейс iUTF-8 SpanFormatable, который позволяет форматировать всё сразу в UTF-8 спаны, GUI, DATETIME и много чего поменялось, значит появился новый класс, значит у нас есть класс там UTF-8, по-моему там даже называется UTF-8 Encoding, кто-то из них двоих, который позволяет делать операции над UTF-8 строчками.
3730.76 3749.56 "Игорь Лабутин" Появился новый класс, который называется ASCII, который позволяет собственно быстро делать операции над ASCII строчками, типа equals, там всякие toLower, toUpper, можно сделать toLower in place и соответственно над спаном, и спан перевести в какой-нибудь lowercase, прям не локейте новые кусочки памяти.
3749.56 3752.08 "Анатолий Кулаков" То есть у нас появляются immutable строки, смотри.
3752.08 3754.24 "Игорь Лабутин" Это не строки, это я сказал над спанами.
3754.24 3755.24 "Анатолий Кулаков" Ну спан, ну какая разница.
3755.24 3757.92 "Игорь Лабутин" Ну нет, есть разница, строки пока всё еще нет.
3757.92 3762.60 "Анатолий Кулаков" Если ты с ним работаешь как через ASCII энкодер, то по сути ты будешь работать как со строкой.
3762.60 3763.60 "Анатолий Кулаков" Ну я понимаю.
3763.60 3767.16 "Анатолий Кулаков" Иначе ты toLower не сделаешь, ну как бы toLower есть только у строк.
3767.16 3768.16 "Игорь Лабутин" Ну это да, да.
3768.16 3774.00 "Игорь Лабутин" Но тем не менее, причём это рядом или спан именно от байтов, потому что ASCII должен обязательно влезать в байт.
3774.00 3779.36 "Игорь Лабутин" Вот, но есть два метода, fromUTF16 и toUTF16, которые соответственно преобразуют это дело в чара.
3779.36 3781.04 "Игорь Лабутин" Ну и конвертируют как надо.
3781.04 3790.20 "Игорь Лабутин" А главное, есть прекрасный метод, называется isValid, который проверяет, что в переданном спане всё действительно как надо, в спане от чаров, по-моему.
3790.20 3791.64 "Игорь Лабутин" И это действительно ASCII.
3791.64 3793.40 "Игорь Лабутин" Ну и тогда, видимо, можно пользоваться.
3793.40 3794.40 "Игорь Лабутин" Вот.
3794.40 3801.64 "Игорь Лабутин" Векторизация, векторизация, всякие истеричные, это всё мы пропустим.
3801.64 3810.68 "Игорь Лабутин" Вот, stringFormatting, появился новый класс под названием CompositeFormat, который решает следующую проблему.
3810.68 3817.28 "Игорь Лабутин" Смотрите, если вы форматируете строчки, ну там, stringFormat, вы туда же передаете что?
3817.28 3827.36 "Игорь Лабутин" Форматную строку, где указаны всякие там в фигурных скобочках нолики и единички, опционально с указателем формата, который нужно применить, через двоеточие.
3827.36 3833.60 "Игорь Лабутин" И каждый раз, когда вызывается stringFormat, он вынужден парсить строку, вот это всё, долго и так далее.
3833.60 3854.80 "Игорь Лабутин" Похожую проблему мы имеем в log.info, когда мы передаем туда строку логирования, которую нужно распарсить, что-то понять, и именно поэтому там у нас есть возможность сказать defineLog, как там defineLogMessage или как-то так заранее, defineLogger, куда передать строку и потом вызывать метод уже только с аргументами.
3854.80 3859.56 "Игорь Лабутин" Вот CompositeFormat, это штука, которая позволяет сделать то же самое для обычного stringFormata.
3859.56 3874.20 "Игорь Лабутин" Вы заранее создаёте CompositeFormat объект, куда передаёте форматную строку, а потом в stringFormat передаёте уже этот CompositeFormat объект, в котором вычислены все там нужные конвертеры и вот это всё для форматной строки.
3874.20 3879.24 "Игорь Лабутин" Она распаршена уже, известно, в какие места нужно подставлять значения и всё такое прочее.
3879.24 3883.20 "Игорь Лабутин" Так что если вы пользуетесь stringFormata, будет полезно,
3883.20 3887.92 "Анатолий Кулаков" наверное. То же штука, которая давно просилась, то же штука, которая давно была очевидна.
3887.92 3892.72 "Анатолий Кулаков" Её же везде там и на логах, и на перформанс-каунтерах её везде прошли, везде заоптимизировали.
3892.72 3897.52 "Анатолий Кулаков" А в самом частом случае, в случае stringFormata почему-то вот ждали чего-то.
3897.52 3902.20 "Игорь Лабутин" Мне кажется, как всегда, рабочие руки, рабочие руки.
3902.20 3909.88 "Игорь Лабутин" И в спанах, как ни странно, где уже всё, мне кажется, заоптимизировано, добавили ещё некоторые оптимизации.
3909.88 3914.08 "Игорь Лабутин" То есть не столько оптимизации, сколько полезные методы.
3914.08 3921.20 "Игорь Лабутин" Почему-то в разделе спанов, ну хотя ладно, это там и про string тоже раздел был, добавили метод streamBuilder.replace.
3921.20 3928.24 "Игорь Лабутин" Точнее не добавили, он был, по-моему, но он теперь работает просто супер быстро из-за векторизации.
3928.24 3931.28 "Игорь Лабутин" IndexOf теперь умный.
3931.28 3964.68 "Игорь Лабутин" IndexOf теперь понимает, что если у нас внутри спана лежит структура, которая blittable, то есть которая типа из примитивных типов, вот это всё, которую можно сравнивать через memcmp, и у вас нету кастомного equals, то IndexOf будет прям вообще быстро и офигенно, потому что он будет пользоваться векторизацией, он не будет идти просто циклом и вызывать каждый раз equals, а он будет это оптимально, используя semd, всё быстро и шустро сверять.
3964.68 3967.92 "Игорь Лабутин" IndexOf прям супер какой-то, быстрый стал.
3967.92 3968.92 "Игорь Лабутин" Ну ладно.
3968.92 3973.60 "Игорь Лабутин" Так, опять векторизация, опять векторизация, опять векторизация, коллекшены.
3973.60 3975.84 "Игорь Лабутин" О, коллекшенах интересно.
3975.84 4003.76 "Игорь Лабутин" Во-первых, теперь если вы энумерируете пустую коллекцию, то у вас практически не будет оверхеда на allocate, потому что для всех популярных коллекций написан теперь код внутри библиотеки, что если коллекция пустая, то возвращать один готовый empty энумератор, пустой энумератор, и не нужно ничего allocate-ить.
4003.76 4016.08 "Игорь Лабутин" А поскольку мне кажется, что довольно много коллекций иногда бывает пустыми, особенно если базу данных вычитываешь, ну нет там ничего, нет и нет, то на итераторах мы сэкономим.
4016.08 4024.68 "Анатолий Кулаков" Не знаю, скоро не дойдут, когда будут итераторы из одного элемента оптимизировать, из двух, из трёх, ну такие самые популярные, до десяти можно сделать.
4024.68 4030.08 "Игорь Лабутин" Ну с этим сложнее, потому что если ты начал итерировать, ты в iEnumerable уже не знаешь, сколько их там.
4030.08 4034.96 "Игорь Лабутин" Хотя если скастить iEnumerable к iCollection, проверить, сколько там элементов, то да, да, да.
4034.96 4041.24 "Анатолий Кулаков" Конечно, там же count уже протаскивается практически везде, где только можно, там iHasCount, iCountSource и прочие вот эти вещи.
4041.24 4044.40 "Игорь Лабутин" О, будет как в математике.
4044.40 4049.96 "Игорь Лабутин" Миллиард интерфейсов, я умею считать, я умею это, короче, не знаю.
4049.96 4052.48 "Анатолий Кулаков" Ну да, generic математика к этому и же идёт.
4052.48 4053.68 "Анатолий Кулаков" Ну в общем, посмотрим.
4053.68 4060.84 "Игорь Лабутин" Дальше, у листа появились методы копирования в и из спана, то есть можно прямо листу теперь сказать copy to или copy from span.
4060.84 4065.12 "Игорь Лабутин" У словаря добавился метод try_added.
4065.12 4068.24 "Игорь Лабутин" У нас его вроде не было.
4068.24 4071.24 "Анатолий Кулаков" Был у concurrent dictionary, у простого dictionary не было.
4071.24 4075.08 "Игорь Лабутин" Вот, и у простого приходилось писать if не contains, то тогда добавь.
4075.08 4081.52 "Игорь Лабутин" Короче, теперь есть try_add, который добавит либо ничего не сделает, если уже есть.
4081.52 4090.76 "Игорь Лабутин" Добавились frozen коллекции, как я говорил, это вот для того самого frozen heap, то есть если вы создали коллекцию, то она один раз инициализируется, и больше если...
4090.76 4095.00 "Игорь Лабутин" Ну, кстати, я не уверен, что она во frozen heap попадает, но смысл в том, что он frozen...
4095.00 4105.40 "Игорь Лабутин" Нет, она не попадает в frozen heap, потому что вы туда можете класть всё что угодно, но она точно известна, что в неё больше никто ничего никогда не напишет, и поэтому её можно оптимально достаточно без локов читать.
4105.40 4121.64 "Игорь Лабутин" Ну и фича языка здесь тоже упоминается про collection expressions, потому что там есть всякий простор для оптимизации компилятора, про то, как интерпретировать эти самые collection expressions и какими конструкциями создавать итоговые коллекции.
4121.64 4122.64 "Игорь Лабутин" Ну, ладно.
4122.64 4127.24 "Игорь Лабутин" File.io, мы уже близимся к концу.
4127.24 4131.92 "Игорь Лабутин" Тут прям революционные изменения, мне кажется, это прям...
4131.92 4133.92 "Игорь Лабутин" Мы на это напарывались, короче говоря.
4133.92 4135.68 "Игорь Лабутин" Знаешь ли ты, как работает get_tmp_filename?
4135.68 4136.68 "Игорь Лабутин" Ой, да, get_tmp_filename.
4136.68 4142.96 "Анатолий Кулаков" По-моему, генерирует рандомный файл, а потом идёт на диск и проверяет, нет ли такого файла.
4142.96 4154.00 "Игорь Лабутин" Именно так, ну не совсем так делает, у него есть внутренний каунтер, имя файла всегда вида, если я правильно помню, tmp4.tmp или как-то так, типа такого.
4154.00 4155.00 "Игорь Лабутин" Вот.
4155.00 4157.80 "Игорь Лабутин" И он просто этот каунтер инкрементирует, есть файл на диске?
4157.80 4158.80 "Игорь Лабутин" Нету.
4158.80 4159.80 "Игорь Лабутин" Ну, как бы окей, используем.
4159.80 4160.80 "Игорь Лабутин" Есть файл на диске?
4160.80 4161.80 "Игорь Лабутин" Ну, есть.
4161.80 4163.76 "Игорь Лабутин" Ну тогда как бы берём следующий по инкременту.
4163.76 4164.76 "Игорь Лабутин" И так и работает.
4164.76 4172.84 "Игорь Лабутин" Итого, во-первых, на диске не может быть больше, чем 65 536 файлов вообще всего в системе, насколько я понимаю.
4172.84 4176.60 "Анатолий Кулаков" То есть не в одной папочке, а во всех папочках?
4176.60 4177.60 "Игорь Лабутин" А там нет папочек.
4177.60 4178.60 "Игорь Лабутин" Где-то в одной.
4178.60 4179.60 "Игорь Лабутин" Temp файл всегда в одной папке.
4179.60 4183.88 "Игорь Лабутин" Он использует стандартную виндовую API, которая в одной папке всегда создаёт.
4183.88 4185.96 "Игорь Лабутин" Ну, в temp директоре создаёт.
4185.96 4186.96 "Анатолий Кулаков" Да, да, да.
4186.96 4193.32 "Игорь Лабутин" То есть если у тебя есть куча приложений, которые используют temp папку, то как бы они все её будут шать.
4193.32 4194.32 "Игорь Лабутин" Вот.
4194.32 4195.32 "Игорь Лабутин" Это во-первых.
4195.32 4198.36 "Игорь Лабутин" Во-вторых, API-шка вот эта виндовая, она достаточно тормозная.
4198.36 4204.32 "Игорь Лабутин" А на Linux и на Mac OS у них есть своя реализация была, которая работала совсем по-другому.
4204.32 4212.16 "Игорь Лабутин" Она во-первых использует 6 цифр, во-вторых, она использует, насколько я понимаю, random, то есть она рандомно выбирает число и потом проверяет.
4212.16 4214.76 "Игорь Лабутин" Если не получилось, снова рандомно выбирает число и сама же проверяет.
4214.76 4216.00 "Игорь Лабутин" Ну, просто в цикле пока не попадёт.
4216.00 4222.36 "Игорь Лабутин" Ну или, видимо, после какого-то количества итераций сама прекращает говорить, что она не смогла.
4222.36 4223.92 "Игорь Лабутин" Вот на винде теперь такая же логика.
4223.92 4232.48 "Игорь Лабутин" То есть .NET теперь на винде будет создавать, не использует виндовую функцию getTemp.filename, а будет сам создавать temp.fileName.
4232.48 4241.64 "Игорь Лабутин" Темповые файлики с шестью, соответственно, цифрками, то есть гораздо меньше шансов попасть на коллизию и упереться в ограничение количества temp.files.
4241.64 4259.80 "Анатолий Кулаков" Ну, всё-таки то, что их шесть не даёт тебе возможности реже попасть на коллизию, реже тебе попасть на коллизию позволяет рандом, потому что ты не по порядку их уже будешь инномерить, поэтому если два процесса параллельно запустятся и будут генерировать рандомные файлы, вот тогда будет большая коллизия, если они по порядку пойдут.
4259.80 4263.32 "Анатолий Кулаков" А если они будут всё-таки использовать рандом, то у них коллизий практически никаких не будет.
4263.32 4275.84 "Игорь Лабутин" Это с одной стороны, а с другой стороны с четырьмя чиселками в 65, даже там получается не 65, нет, там 65,536, просто чиселки эти, 16-ти речные, сколько я помню.
4275.84 4278.48 "Игорь Лабутин" То мы, короче, упирались в это ограничение довольно
4278.48 4282.72 "Анатолий Кулаков" легко. Вы быстрее кончитесь, да, вы быстрее этот счётчик выбирали просто.
4282.72 4288.28 "Игорь Лабутин" Да, да, да, да, то есть у нас как бы прямо была проблема, что программка писала нет temp.files.
4288.28 4289.28 "Игорь Лабутин" В смысле?
4289.28 4290.28 "Анатолий Кулаков" Не в шмага.
4290.28 4292.04 "Анатолий Кулаков" Извините, не нашло.
4292.04 4293.04 "Игорь Лабутин" Кончились.
4293.04 4302.96 "Анатолий Кулаков" Не знаю, мы писали свой просто этот temp.file генератор, когда понимали, что нам нужно много с темпами работать и просто и быстрее, и надёжнее, и лучше.
4302.96 4309.72 "Игорь Лабутин" Но мы считали, что мы работаем мало, но оказалось, что каждое приложение так считало, все они работали на одном
4309.72 4312.36 "Анатолий Кулаков" сервере. Да, да, если несколько лет не чистить темпы.
4312.36 4317.64 "Игорь Лабутин" Да, ну и где-то, да, маленькая ошибка, темпы не чистятся, и всё, и они быстро кончаются.
4317.64 4319.64 "Игорь Лабутин" Короче, теперь не будет такого.
4319.64 4320.64 "Игорь Лабутин" Нетворкинг.
4320.64 4328.80 "Игорь Лабутин" В нетворкинге там огромнейший раздел, подробно рассмотрены все уровни, начиная с самого низкого уровня, сокетов и вот этого всего, до самого верхнего, что-то тп.
4328.80 4331.64 "Игорь Лабутин" Там в основном улучшения в работе с памятью.
4331.64 4334.48 "Игорь Лабутин" Спаны, там вот это всё.
4334.48 4344.00 "Игорь Лабутин" Ну и конфигурация, ты уже сказал, упомянул это кратенько, что у нас теперь есть source-генератор для того, чтобы байндить конфигурацию sources.
4344.00 4362.20 "Игорь Лабутин" И вот как раз таки, чтобы когда мы говорим bind, точно знать, к чему мы байндим, и правильный код вызвать, используют интерсепторы, чтобы вызвать правильный метод, который будет знать, в какие поля что написать при байндинге.
4362.20 4367.44 "Игорь Лабутин" Вот, почему это в перформансе, опять же, не очень понятно, но понятно, что он стал быстрее из-за этого.
4367.44 4376.28 "Игорь Лабутин" Ну, видимо, вот так эта статья и родилась там, не знаю, мне кажется, четверть можно было, может быть, даже выкинуть, потому что напрямую именно к перформансу не относится.
4376.28 4379.76 "Игорь Лабутин" Хотя, с другой стороны, не знаю, тоже перформанс.
4379.76 4388.12 "Анатолий Кулаков" Ну да, мне кажется, что я бы большинство этих фич забрал куда-нибудь во фреймворк, потому что очень интересные доработки есть, очень интересные, там новые классы, новые методы и так далее.
4388.12 4390.68 "Анатолий Кулаков" А перформанс, он так, должен быть, по идее, сбоку.
4390.68 4397.00 "Анатолий Кулаков" А так, судя по всему, Тао себе отжал самые лучшие темы, а обычным анонсам не досталось вообще ничего.
4397.00 4401.92 "Игорь Лабутин" Попробуй найди в этом блоге Тао бы хоть какие-то темы, то нормальным чтением можно вытащить.
4401.92 4406.48 "Игорь Лабутин" Ну ладно, давай пойдем дальше, у нас еще много чего пообсуждать есть.
4406.48 4412.88 "Анатолий Кулаков" Так, давай попробуем, интересно, после твоих там этих изречений найдем ли мы там чего пообсуждать уже.
4412.88 4421.40 "Анатолий Кулаков" Я так увлекся, в принципе, шикарная статья, прекрасные графики, очень много информации, действительно, надо перед сном часов 5, перед сном, почитать.
4421.40 4425.56 "Анатолий Кулаков" Если вдруг у вас есть лишние 5 часов перед сном, пожалуйста, обращайтесь.
4425.56 4427.28 "Анатолий Кулаков" Давай опять про лицензии.
4427.28 4439.40 "Анатолий Кулаков" Про лицензии, да, была у нас такая новость из мира почти .NET, почти игр и почти Unity, заключается она в том, что Unity захотела очень много денег.
4439.40 4441.92 "Анатолий Кулаков" И давайте поподробнее.
4441.92 4447.52 "Анатолий Кулаков" Для тех, кто не знает, Unity это самый популярный движок для разработки игр, ну, по крайней мере, мы так надеемся.
4447.52 4452.76 "Анатолий Кулаков" И он использует .NET и C# в своей работе.
4452.76 4457.08 "Анатолий Кулаков" И вот этот движок состоит из двух частей.
4457.08 4469.12 "Анатолий Кулаков" Это Unity Runtime, на котором непосредственно запускаются все игры, и он был бесплатный, и Unity Editor, то есть это как раз такие инструменты, .DE, с помощью которых разрабатывались все эти игры.
4469.12 4475.60 "Анатолий Кулаков" И вот создатели решили поменять цену на Unity Runtime, то есть решили брать с него теперь бабло.
4475.60 4487.24 "Анатолий Кулаков" И это очень сильно возмутило всех разработчиков и всех пользователей, и вообще абсолютно всех, потому что условия оказались какие-то конские.
4487.24 4503.24 "Анатолий Кулаков" В частности, с 2024 года разработчики, которые зарабатывали на играх более 200 тысяч долларов, и имеющие более 200 тысяч скачиваний игр, обязаны были платить по 20 центов за каждую инсталляцию.
4503.24 4520.20 "Анатолий Кулаков" И Unity, в принципе, очень много использовался для инди-игр, потому что это такой довольно мощный, легкий движок, в который легко войти, и он позволял делать очень качественно красивую графику, поэтому для индивидуальных игроделов это была вообще одна из излюбленных вещей.
4520.20 4526.68 "Анатолий Кулаков" И там игры продавались довольно за низкую цену, там 1 бакс за игру, это нормальная ситуация.
4526.68 4536.68 "Анатолий Кулаков" То есть получается, что если игра продаётся за 1 доллар, а Unity хочет 20 центов за каждую инсталляцию, то он забирает 20% дохода таких компаний.
4536.68 4544.68 "Анатолий Кулаков" Ну 20% это довольно-таки уже существенная такая, ощутимая вещь, тем более, что ты отдаёшь её просто за то, что движок есть, ни за что более.
4544.68 4546.96 "Анатолий Кулаков" То есть тоже за что ты раньше вообще не платил.
4546.96 4556.92 "Анатолий Кулаков" Но ситуация оказалась может быть ещё хуже, потому что тут подтянулись владельцы игр, которые распространялись по подписочным сервисам.
4556.92 4564.76 "Анатолий Кулаков" Это когда у вас есть некий сервис, которому вы ежемесячно отчисляете какое-то бабло, а он вам периодически выдаёт какой-то пакет игр.
4564.76 4567.72 "Анатолий Кулаков" И вы что хотите с этим пакетом, то и играете.
4567.72 4570.92 "Анатолий Кулаков" Что не хотите, подождите, и в следующем месяце он вам новый выдаст.
4570.92 4574.88 "Анатолий Кулаков" Ну или там можно постоянно играть, в зависимости от условий.
4574.88 4582.32 "Анатолий Кулаков" В общем, таких пользователей у этих подписочных сервисов, их были просто миллионы.
4582.32 4588.04 "Анатолий Кулаков" И по лицензии Unity разработчик должен был платить за каждого потенциального игрока.
4588.04 4601.56 "Анатолий Кулаков" Ну то есть неизвестно, игрок этот скачал игру или не скачал, но так как он потенциально эту игру скачать может, за неё уже уплачено, то есть по сути разработчики должны были за это платить.
4601.56 4603.04 "Анатолий Кулаков" А это миллионы долларов.
4603.04 4608.44 "Анатолий Кулаков" Ну то есть реально люди не зарабатывали столько, сколько они потенциально уже должны были заплатить только Unity.
4608.44 4619.40 "Анатолий Кулаков" Вот такая ваханалия была, то есть там поднялся огромный лай, огромный вой, все кричали, топали ножками и визжали для того, чтобы авторы Unity их услышали.
4619.40 4628.48 "Анатолий Кулаков" Ну и как гласит древняя китайская пословица, если долго сидеть на берегу и смотреть на воду, то рано или поздно тело твоего врага проплывёт мимо.
4628.48 4636.68 "Анатолий Кулаков" И вот тело врага проплыло, поэтому авторы Unity услышали, и они решили поменять все-таки вот эти дерзкие условия.
4636.68 4643.68 "Анатолий Кулаков" Сказали, мы все услышали, извините, вы нас не так поняли, мы вам не так сказали, давайте все переиграем.
4643.68 4653.52 "Анатолий Кулаков" Теперь будет 4% от дохода игр, но это только после превышения 1 миллиона долларов, и установки не будут считаться задним числом.
4653.52 4657.80 "Анатолий Кулаков" То есть неважно сколько вы там до этого поставили, это все идёт лесом.
4657.80 4670.68 "Анатолий Кулаков" Unity уверяет, что они посчитали на каких-то своих мега статистиках, что это не коснётся 90% всех разработчиков, то есть 90% останется жить так, как они жили дальше, они вообще никаких изменений не увидят.
4670.68 4687.72 "Анатолий Кулаков" А это лишь коснётся вот этих 10% богачей толстосумов, то есть самых крупнейших пользователей движка, которым в принципе не жалко, будет немножко поделиться с компанией за то, чтобы она свои инструменты в будущем разрабатывала больше, качественнее и веселее, потому что уже будет за это получать немножко больше бабла.
4687.72 4695.28 "Анатолий Кулаков" Вот такой скандальчик у нас небольшой был, в принципе всё вроде уладилось, всё вроде улеглось, поэтому сейчас все счастливы.
4695.28 4698.28 "Игорь Лабутин" Ну посмотрим, что получится.
4698.28 4703.60 "Игорь Лабутин" Разработчики игр такие, может всем пойдут переписывать всё с Unity, кто там у нас альтернативы.
4703.60 4705.00 "Игорь Лабутин" Ну на Unreal только.
4705.00 4708.72 "Анатолий Кулаков" Ну Godot ещё там был какой-то, не знаю.
4708.72 4713.72 "Анатолий Кулаков" Ну вообще по мощности в принципе там против Unity никто кроме Unreal не выстоит.
4713.72 4715.92 "Анатолий Кулаков" Поэтому если куда-то идти.
4715.92 4718.72 "Игорь Лабутин" Будем ждать, что там получится.
4718.72 4726.84 "Игорь Лабутин" Окей, давай пойдём дальше, обратно в наш мир.net с новостями про зелёные потоки.
4726.84 4729.52 "Игорь Лабутин" Что ты знаешь про зелёные потоки?
4729.52 4733.52 "Анатолий Кулаков" То, что в отличие от зелёной энергетики, они реальны.
4733.52 4745.64 "Игорь Лабутин" Ну они действительно реальны, они даже вот зарелизились тут несколько дней назад в Java под названием Project Blue, точнее это было название того проекта, под которым они создавались в Java.
4745.64 4748.64 "Игорь Лабутин" А в .NET их нет.
4748.64 4764.96 "Игорь Лабутин" И поскольку как раз таки java-ская имплементация довольно активно пушилась и все ждали-ждали, когда же в 21 Java она выйдет, то команда .NET решила, что надо вообще тоже посмотреть, подумать, что это такое, и попробовала у себя это дело.
4764.96 4772.68 "Игорь Лабутин" Но до того, как мы обсудим, что из этого получилось, давайте сначала узнаем, что же такое потоки зелёные, особенно зелёные.
4772.68 4777.96 "Анатолий Кулаков" Да-да, вроде потоки у нас были, лёгкие потоки в виде тасков были, а вот зелёных ещё не было.
4777.96 4778.96 "Игорь Лабутин" Зелёных не было.
4778.96 4789.00 "Игорь Лабутин" Смотрите, штука в следующем, что современный код большинства приложений, ну ладно, не большинства, но многих приложений, он довольно сильно зависит от ввода-вывода.
4789.00 4793.28 "Игорь Лабутин" Надо сходить в базу, сходить в сеть, сходить на диск за чем-нибудь.
4793.28 4801.76 "Игорь Лабутин" И пока эти операции выполняются, в общем-то процессору делать особо нечего, ну в смысле в этом конкретном потоке.
4801.76 4817.56 "Игорь Лабутин" То есть если мы полностью заблокируем поток, когда будем ждать, то мы занимаем поток, в ThreadPool начинает может быть не хватать потоков, хотя поток сам по себе ничего не делает, он просто ждёт, когда драйвер ему скажет «всё, я таки данные прочитал или записал, можешь продолжать свою работу».
4817.56 4848.08 "Игорь Лабутин" Поэтому у нас в C# в .NET есть понятие асинхронного кода, те самые async/await, когда мы помечаем функции, мы говорим, что вот в этой функции может быть конкретно какая-то там ввод-вывод, грубо говоря, либо какая-то другая асинхронная работа, и в том месте, где мы знаем, что может быть такое случится, мы пишем ключевое слово await, говоря, что вот тут можно ждать вне потока, и когда закончится, возвращать исполнение обратно на поток.
4848.08 4854.92 "Игорь Лабутин" С восстановлением всяких execution-контекстов, вот этого там, синхронизейшн-контексты, вот это всё.
4854.92 4856.60 "Игорь Лабутин" Сейчас в эти детали углубляться не будем.
4856.60 4872.80 "Игорь Лабутин" Штука в том, что, как я сказал, разработчики должны решать, какие методы им объявлять асинхронными, то есть в каких методах может быть нужно разрешать поток приостанавливать ради того, чтобы ждать ввода-вывода.
4872.80 4882.68 "Игорь Лабутин" При этом не очень здорово не думать, было бы, конечно, удобно не думать, но так не получается, нельзя сказать, что все методы будут асинхронными.
4882.68 4883.68 "Игорь Лабутин" Почему?
4883.68 4886.48 "Игорь Лабутин" Потому что асингт не бесплатный.
4886.48 4901.48 "Игорь Лабутин" То есть как только вы пишете перед функцией асингт, а внутри пишете await, то это уже не просто функция, там рождается, стоит машина, классы какие-то, сохранение состояния, в общем, есть там прям некоторые просадки по производительности.
4901.48 4903.76 "Игорь Лабутин" В общем, асингт в этом смысле не бесплатный.
4903.76 4918.40 "Игорь Лабутин" Кроме того, поскольку метод становится не просто методом на стэке, а может по сути его исполнения перепрыгивать между разными физическими потоками операционной системы, то там возникают всякие разные ограничения того, что вы можете делать внутри асингт-метода.
4918.40 4928.16 "Игорь Лабутин" Например, вы не сможете использовать спаны, потому что спаны, какие-нибудь стэка-локи, они аллоцируют на стэки, а если поток прыгает между разными стэками, то что с этим делать?
4928.16 4933.12 "Игорь Лабутин" Вы не сможете доступиться к стэку соседнего потока, на котором исполнялось начало метода.
4933.12 4938.92 "Игорь Лабутин" И третий момент, что асинхронные методы вы можете вызывать в общем-то только из асинхронных методов.
4938.92 4952.96 "Игорь Лабутин" То есть технический язык позволяет вызвать асинхронные методы синхронного, но это а) делается довольно криво, б) может привести к неприятным последствиям в виде дедлоков, потому что прыгание по потоку может привести к такой забавной ситуации.
4952.96 4962.96 "Игорь Лабутин" И чтобы всё вот это вот описывать, C# не первый язык, который столкнулся с такой проблемой.
4962.96 4965.24 "Игорь Лабутин" Было введено понятие цветных функций.
4965.24 4970.08 "Игорь Лабутин" И цветные функции бывают двух цветов, красный и синий.
4970.08 4975.60 "Игорь Лабутин" И в приложении каждая функция имеет обязательно какой-то цвет, цветных не бывает.
4975.60 4981.84 "Игорь Лабутин" При этом красные могут вызываться только из красных, синие могут вызываться из красных, ну и из синих тоже.
4981.84 4985.04 "Игорь Лабутин" И красные функции, они на то и красные, что их очень дорого вызывать.
4985.04 4991.00 "Игорь Лабутин" Ну, понятно, что перекладывается на наши термины, всё понятно, синие это обычные функции, красные это асинки.
4991.00 4997.48 "Игорь Лабутин" И вот как раз чтобы продолжить всю эту картину с цветами, отсюда и взялись зелёные труды.
4997.48 5004.92 "Игорь Лабутин" Зелёные труды делают так, что у функций цвет исчезает, вам становится неважно, какого цвета функция.
5004.92 5009.84 "Игорь Лабутин" Типа в зелёном треде нет ни красного, ни синего, поэтому там всё одинаково зелёное.
5009.84 5014.16 "Игорь Лабутин" А что же это собственно такое?
5014.16 5018.52 "Игорь Лабутин" Что такое зелёные труды и почему исчезают цвета функций?
5018.52 5030.84 "Игорь Лабутин" Зелёные труды существенно упрощают то, что называется программинг модул, то есть модель того, как вы пишете код, ваша ментальная модель того, как вы думаете о коде.
5030.84 5032.48 "Игорь Лабутин" Весь код можно писать синхронно.
5032.48 5039.32 "Игорь Лабутин" Вы не заморачивайтесь, будет там вот вывод, не будет вот вывода, нужно ждать, не нужно ждать.
5039.32 5043.20 "Игорь Лабутин" Пусть рантайм сам вот этих зелёных трудов сам решит.
5043.20 5045.84 "Игорь Лабутин" Нужно освободить тред, не нужно освобождать тред.
5045.84 5057.92 "Игорь Лабутин" Вы просто пишите код, как будто он синхронный, а в нужных местах всё само автоматически перепрыгивает между обычными трудами, в нужный момент аффлодит из трудов, засыпает, ждёт, всё работает само.
5057.92 5066.28 "Игорь Лабутин" При этом понятное дело, что пользоваться таким можно только если оно дёшево, то есть если там будет гигантский оверхед, то зачем.
5066.28 5072.68 "Игорь Лабутин" Оно не должно влиять никак на всякие скала-абилити, то есть вы всё ещё должны масштабироваться, как и раньше.
5072.68 5082.72 "Игорь Лабутин" И в целом такой подход себя оправдал, то есть есть примеры того, как это сделано, ну хотя бы наши джава, в которых таки сделали.
5082.72 5091.52 "Игорь Лабутин" Но проблема в том, что у нас в C# есть уже Async/await, и с этим надо что-то делать.
5091.52 5093.72 "Игорь Лабутин" Ну в смысле, как-то с этим жить.
5093.72 5099.32 "Игорь Лабутин" В итоге вот с такими вводными команда Microsoft решила в отдельной препозитории провести эксперимент.
5099.32 5101.68 "Игорь Лабутин" Что же они сделали?
5101.68 5108.44 "Игорь Лабутин" Они поменяли рантайм, добавили новые API, которые позволяют работать с теми самыми зелёными трейдами.
5108.44 5118.32 "Игорь Лабутин" То есть вы пишете код плюс-минус синхронно, а вот этот рантайм API сам теперь понимает, в каком месте нужно подождать и как будто бы вы написали Async/await.
5118.32 5131.00 "Игорь Лабутин" Рантаймом дело не ограничилось, дописали соответствующие API в сокетах и в SPNate, чтобы получить вообще прям такой end-to-end сценарий, на котором можно потестить прям RPS с реквестами.
5131.72 5141.40 "Игорь Лабутин" И в целом выводы были из эксперимента, точнее вот того, что они попробовали, такое, что ну в целом сделать можно.
5141.40 5163.20 "Игорь Лабутин" Причём даже с точки зрения перформанса, это был эксперимент, понятно, что там никто не оптимизировал SPNate Core в течение многих лет, то есть в рамках эксперимента скорее всего код получился не очень идеальным, но тем не менее стандартный SPNate Core вот с Async/await на приложении держал 178 тысяч реквестов в секунду, а на зелёных тогда 162 тысячи.
5163.20 5169.20 "Игорь Лабутин" Ну то есть поменьше, но не критично меньше, наверняка там можно дооптимизировать.
5169.20 5181.60 "Игорь Лабутин" При этом выяснилось несколько интересных моментов, которые они забавно, ну не забавно, а ожидаемо обозвали challenges.
5181.60 5199.00 "Игорь Лабутин" Во-первых, поскольку вы пишете консинхронно, то технически может получиться так, что у вас будут довольно глубокие call stack, потому что там какие-нибудь callback и ещё что-нибудь, то есть технически у вас-то они синхронные, не очень может быть глубокие, но за счёт всей этой машинерии итоговый call stack реальный получается довольно глубокий.
5199.00 5206.92 "Игорь Лабутин" И он сопоставим с цепочками Async/await вызовов, которые вы видите сейчас, когда вы отлаживаете асинхронный код.
5206.92 5221.60 "Игорь Лабутин" Так вот оказалось почему-то, что вот эти виртуальные thread stack для green threads, они ведут себя гораздо хуже с точки зрения перформанса, их там сложнее собирать, их там иденить, чем такой же глубины цепочки Async/await.
5221.60 5224.80 "Игорь Лабутин" Но это ладно, это техническая деталь.
5224.80 5227.76 "Игорь Лабутин" Дальше, собственно, программная модель.
5227.76 5235.96 "Игорь Лабутин" Поскольку Async/await есть, а green thread это совершенно новая модель, которая, ну просто пишем синхронный код, то возникает вопрос, как их дружить.
5235.96 5240.12 "Игорь Лабутин" Мы не можем сказать, что просто типа не, мы, типа нельзя смешивать в одном приложении.
5240.12 5244.76 "Игорь Лабутин" Всё равно есть библиотеки, которые используют Async/await внутри там таски и так далее.
5244.76 5252.36 "Игорь Лабутин" Или наоборот, из таких библиотек вы можете вызывать код, который рассчитан на то, что он работает в green thread, если, например, какие-то новые библиотеки написать.
5252.36 5259.84 "Игорь Лабутин" И в итоге получается, что из Async/await подавать что-то green thread'овое, это ладно, вы просто синхронный вызов делаете и всё.
5259.84 5265.92 "Игорь Лабутин" А вот наоборот, получается та же проблема, которую мы имеем сейчас, когда вы пытаетесь из синхронного метода вызвать асинхронный.
5265.92 5268.76 "Игорь Лабутин" Так называемый Async/await.
5268.76 5272.20 "Игорь Лабутин" Выглядит кривовато, может привести к дедлокам.
5272.20 5274.48 "Игорь Лабутин" Ещё одна проблема - это interop.
5274.48 5276.64 "Игорь Лабутин" Interop с нативным кодом.
5276.64 5280.32 "Игорь Лабутин" Тут, во-первых, он получается медленным, как ни странно.
5280.32 5291.20 "Игорь Лабутин" Почему-то, опять же, детали не приведены, был написан бенчмарк, который делает 100 миллионов пейнтволков и померенно время.
5291.20 5297.00 "Игорь Лабутин" На нашем обычном дотнете это 300 миллисекунд, на вот этим green thread'овом 1800 миллисекунд, 6 раз медленнее.
5297.00 5307.88 "Игорь Лабутин" И при этом возникают проблемы с трансатитами переменными, потому что понятно, что green thread'ы автоматически скачут между thread'ами, и какой там thread static куда улетит, непонятно.
5307.88 5325.32 "Игорь Лабутин" При этом, если мы интеропимся в какой-то нативный код, то некоторые нативные вызовы ожидают, что например какие-нибудь callback'и или ещё что-нибудь будет вызываться из того же thread'а, в котором был вызван исходный нативный код или что-то в таком духе.
5325.32 5332.92 "Игорь Лабутин" Вспоминаются всякие com, эти single thread apartment, multiple thread apartment и так далее.
5332.92 5337.72 "Игорь Лабутин" И гарантировать это, это довольно сложно логически получилось.
5337.72 5356.84 "Игорь Лабутин" И ещё один челлендж, который они описали, выглядел так, что кажется, что green thread'ы можно сделать даже более быстрыми, чем осинки в определённых сценариях, но ценой того, что в других сценариях они будут существенно более медленными, чем осинки.
5356.84 5362.84 "Игорь Лабутин" В итоге, посмотрев на всё это, были сделаны следующие выводы.
5362.84 5368.20 "Игорь Лабутин" В целом, мы пока в дотнете green thread'ы делать не будем.
5368.20 5372.28 "Игорь Лабутин" Мы продолжим импровить осинковейты в том или ином виде.
5372.28 5384.84 "Игорь Лабутин" Наиболее важные консерны сейчас относятся именно к тому, что мы внедряем совершенно новую модель, то есть мы несколько лет, много лет уже, учим комьюнити писать на осинковейтах, как это делать и так далее.
5384.84 5390.44 "Игорь Лабутин" При этом рождаем что-то совершенно новое, которое с осинковейтами не очень совместимо.
5390.44 5397.36 "Игорь Лабутин" Но при этом они говорят, что мы будем смотреть, что происходит в индустрии и вполне может быть вернёмся к этому вопросу чуть позднее, когда мы поймём, куда идёт.
5397.36 5401.52 "Игорь Лабутин" Плюс посмотрим на Java, как это в Java пойдёт.
5401.52 5404.20 "Игорь Лабутин" Вот такая вот история с green thread'ами.
5404.20 5410.24 "Игорь Лабутин" Тут надо ещё понимать такой практический момент, а как же это на самом деле работает.
5410.24 5414.88 "Игорь Лабутин" То есть звучит это всё здорово, мы пишем код просто синхронно, но само как-то понимает.
5414.88 5420.60 "Игорь Лабутин" Как же понимать, в какой момент можно переключиться и переключить thread.
5420.60 5423.08 "Игорь Лабутин" По сути, выход только один.
5423.08 5429.80 "Игорь Лабутин" Вам нужно в рантайме знать все методы, которые могут привести к вводу-выводу.
5429.80 5441.60 "Игорь Лабутин" То есть во всех местах, где у вас есть какой-то шанс ввода-вывода, вы должны написать явно код, который будет с учётом вот этих, по сути написать там осинковейт, грубо говоря, вручную.
5441.60 5448.56 "Игорь Лабутин" И это то, что по сути происходило в Java в Project Loon, почему он занял так долго времени.
5448.56 5450.56 "Игорь Лабутин" Они там много чего переписывали ради этого.
5450.56 5457.48 "Игорь Лабутин" Но в Дотнете, видимо, этого делать не очень хотят.
5457.48 5458.48 "Игорь Лабутин" Это во-первых.
5458.48 5479.28 "Игорь Лабутин" Второе, если вы, это проблема green thread'ов, что если вы таки что-то сделаете блокирующее, реально блокирующее, то есть вы забудете, например, какие-то методы, которые внезапно занимаются I/O, но вокруг них green thread runtime не будет знать, что они на самом деле делают I/O, то вы, честно, заблокируете thread, который вас исполняет.
5479.28 5488.04 "Игорь Лабутин" То есть это как бы несеребряное пуле, и абсолютно автоматно детективать вообще весь I/O, ну практически нереально.
5488.04 5500.36 "Игорь Лабутин" Третий момент, который упоминался в комментариях к этому GitHub-ище, где, собственно, команда Microsoft писала результаты про то, что кажется, что .NET гораздо больше использует интеропы, чем Java.
5500.36 5523.04 "Игорь Лабутин" Ну это такое довольно субъективное ощущение, но кажется, что в .NET интеропится проще с нативным кодом, и поэтому в Java это такие все-таки редкие случаи, которые можно отдельно рассмотреть, а в .NET такое сплошь и рядом, ну особенно это дергать в InApi, мы вообще это делаем постоянно, то есть здесь надо будет размечать еще и всякие такие методы, и поэтому гораздо сложнее это все сделать.
5523.04 5537.76 "Игорь Лабутин" А если вы хотите чуть больше узнать про то, как это происходило в Java, на самом деле очень полезная презентажка, в шоуноутах будет ссылочка на видосик, где аккуратно рассказано, что же такое эти green-red с примерами и так далее, как это все работает.
5537.76 5538.76 "Игорь Лабутин" Вот, посмотрите.
5538.76 5544.60 "Игорь Лабутин" Но в .NET их не будет, пишем async/await, как и раньше.
5544.60 5554.40 "Анатолий Кулаков" Ну, в принципе, слушай, на концепцию async/await перешли, поэтому если бы появилась третья концепция, наверное, так же точно немножко поперетягивали бы, да попереходили бы, ничего страшного.
5554.40 5558.36 "Игорь Лабутин" Видишь, разработчики перейдут, я так понимаю, что с кодом проблемы.
5558.36 5565.32 "Игорь Лабутин" Ну, то есть вот эти всякие async/await, да, учитывая какие-нибудь синхронизации контексты, и там здравствуют дедлоки.
5565.32 5567.96 "Анатолий Кулаков" Ну это технические проблемы, пусть команда решает.
5567.96 5570.28 "Игорь Лабутин" Нам-то главное, чтобы код был красивый.
5570.28 5576.12 "Игорь Лабутин" Да, там превью выходит редко, релиз кандидата еще реже, никаких новых интересных фич нифига не работает, ребята, да, я согласен.
5576.12 5578.76 "Анатолий Кулаков" Конечно, там по-моему один талп работает.
5578.76 5581.72 "Игорь Лабутин" Ну и Егор еще фигачит, мне кажется, в GT.
5581.72 5583.76 "Игорь Лабутин" Вот они на двоих весь анатомию пишут.
5583.76 5584.76 "Игорь Лабутин" Ладно.
5584.76 5585.76 "Игорь Лабутин" Весь перформансы дают.
5585.76 5595.80 "Игорь Лабутин" Кратко о разном, последний наш блок, мне кажется, надо на сегодня уже нам плюс-минус сворачиваться, поэтому давай быстренько посмотрим, что у нас есть.
5595.80 5598.32 "Анатолий Кулаков" Да, давайте закругляться.
5598.32 5604.68 "Анатолий Кулаков" Библиотечка, интересная библиотечка, которая называется Fluent Docker.
5604.68 5613.44 "Анатолий Кулаков" Она позволяет вам сделать удобным из C# прямо работу с API докера и Docker Compose, а также Docker Machine.
5613.44 5623.96 "Анатолий Кулаков" То есть вы прямо в C# можете создать контейнер, написать use image, написать expose port, стартануть любой контейнер и каким-то образом взаимодействовать с этими контейнерами.
5623.96 5626.72 "Анатолий Кулаков" При том взаимодействий есть огромное-огромное количество.
5626.72 5640.88 "Анатолий Кулаков" Вы можете доинсталировать пакеты, создать какие-нибудь папочки, вы можете подождать, пока будет доступен порт, вы можете примаунтить какой-нибудь volume, вы можете настроить network, как я уже сказал, с Compose он работает, то есть можно поднять несколько Docker контейнеров, настроить между ними связь.
5640.88 5653.40 "Анатолий Кулаков" Также есть какие-то интеграции с тестами, то есть вы можете прямо в своих тестах поднять все эти контейнеры и начать каким-то образом отстреливать запросами и проверять ответики и посмотреть, что у вас там из этого получается.
5653.40 5670.84 "Анатолий Кулаков" В общем, библиотечка очень интересная, очень напоминает тест контейнер, если вы вдруг с ними работали, в общем, я пока не нашел какой-то разницы, может это и есть какие-то прямые конкуренты, но судя по тому обширному API, по тем гибким методам, которые предоставляются, всем вообще ничего не уступает.
5670.84 5673.00 "Анатолий Кулаков" В общем, кажется, что нужно взять на практике и попробовать.
5673.00 5681.12 "Анатолий Кулаков" Поэтому если вдруг кому-то нужно с Docker Composами, контейнерами, сетями поднимать, все растаскивать, то вот, посмотрите.
5681.12 5688.04 "Игорь Лабутин" Мне кажется, она такая замена типа command line Docker, все, что можно сделать через command line, можно сделать через нее, наверное.
5688.04 5695.80 "Анатолий Кулаков" Ну типа да, но ты еще это можешь интегрировать, грубо говоря, в свои тесты, в свои проекты, то есть если тебе не нужно интегрировать в тесты, не очень понятно, зачем тебе это надо.
5695.80 5701.00 "Анатолий Кулаков" Ты же не будешь писать утилиту, там, command line утилиту для замены обычной докеровской силой.
5701.00 5702.00 "Анатолий Кулаков" Ну почему нет?
5702.00 5704.20 "Анатолий Кулаков" А вот… Ну может я хочу.
5704.20 5705.84 "Анатолий Кулаков" Потому что много их таких не надо.
5705.84 5709.16 "Анатолий Кулаков" А вот, например, тесты в контейнерах запускать надо практически всем.
5709.16 5711.68 "Анатолий Кулаков" Это какой-то такой более широкий рынок.
5711.68 5712.68 "Анатолий Кулаков" Ну ладно, давай.
5712.68 5714.44 "Анатолий Кулаков" Судя по всему, она туда целится.
5714.44 5715.88 "Анатолий Кулаков" Я там еще есть.
5715.88 5726.56 "Анатолий Кулаков" Еще есть статичка про то, как построить надежный отсылальщик почты с retry и outbox паттерном.
5726.56 5730.48 "Анатолий Кулаков" В принципе, статья интересна тем, что она очень простая.
5730.48 5739.36 "Анатолий Кулаков" Здесь элементарно показывается, что такое retry, зачем он нужен и показывается на очень-очень простом примере, что такое outbox паттерн и как его тоже использовать.
5739.36 5743.72 "Анатолий Кулаков" В общем, естественно, если вам будет настоящий нужен outbox паттерн, данная статья не пойдет.
5743.72 5754.96 "Анатолий Кулаков" Но если вы вдруг захотите просто узнать, что это такое, потому что шаблон довольно популярный, довольно полезный и к сожалению, о нем мало кто знает и мало кто использует.
5754.96 5759.12 "Анатолий Кулаков" В общем, для того, чтобы просто ознакомиться, что это такое, вот эта статья подойдет.
5759.12 5760.68 "Анатолий Кулаков" Она простая, очевидная и наглядная.
5760.68 5772.84 "Анатолий Кулаков" В общем, если вам будет интересно, то пишите в комментах, мы обязательно найдем какую-нибудь хорошую статью, которая про outbox паттерн и обсудим ее более детально, со всеми плюсами, минусами, подводными камнями, там их огромное количество.
5772.84 5779.96 "Игорь Лабутин" Да, штука действительно полезная и интересная, особенно если вы работаете с какими-то очередями или чем-нибудь подобным.
5779.96 5791.48 "Игорь Лабутин" А также раньше Microsoft выпустила, даже не статья, в документацию Microsoft добавили большую статейку, которая про Observability.
5791.48 5804.40 "Игорь Лабутин" То есть мы много раз говорили про Observability, Microsoft хорошая документация на эту тему, про всякие, как писать логи, как писать метрики, так вот теперь появилась общая единая статья под названием, так сказать, Observability с OpenTelemetry.
5804.40 5828.44 "Игорь Лабутин" Она сборная, то есть там прям написано все, что вам нужно знать для начала работы с OpenTelemetry в дотнете, вся информация о пакетах и примеры того, как сделать ваше приложение готовым к работе с OpenTelemetry, прям с примерами того, как настроить Prometheus, Jaeger и Grafana, соответственно, для того, чтобы все это дело смотреть.
5828.44 5841.84 "Игорь Лабутин" Статья такая, ну она обзорная, практическая, но если вы не работали с OpenTelemetry и вам нужно начинать это делать в дотнете, вот самое оно, мне кажется, просмотреть ее, а после этого уже вбиваться в детали.
5841.84 5845.96 "Игорь Лабутин" Там есть куча ссылочек на эту тему для более детального изучения.
5845.96 5861.48 "Игорь Лабутин" И последнее на сегодня, это даже не статья, это отчет от Cloud Native Computing Foundation про состояние VBS Assembly в 2023 году.
5861.48 5872.80 "Игорь Лабутин" Они делают примерно то же самое, что делают с TalkOverflow, там делают большой опрос, там отвечает какое-то количество народу на предмет, как вы используете, зачем вы используете, где вы используете и все такое прочее.
5872.80 5878.48 "Игорь Лабутин" Насколько я понимаю, там респондентов было не так, чтобы супер много, но тем не менее интересно посмотреть на статистику.
5878.48 5882.92 "Игорь Лабутин" Я очень кратенько только скажу некоторые интересные факты, которые меня заинтересовали.
5882.92 5889.32 "Игорь Лабутин" Во-первых, для чего используется VBS Assembly, по мнению тех, кто опрашивали.
5889.32 5895.88 "Игорь Лабутин" Большая часть, подавляющая часть используют для веб-приложений, ну, собственно, все понятно.
5895.88 5906.36 "Игорь Лабутин" На втором месте визуализация данных, что бы это ни было, то ли как раз в браузере какие-то супер оптимальные вычисления делают, я не очень понимаю, почему
5906.36 5909.60 "Анатолий Кулаков" Data Visualization. Ну, наверное, тоже все-таки через веб-приложения, да?
5909.60 5914.44 "Анатолий Кулаков" То есть, игры, я вполне могу предположить, какие-нибудь 3D графики, медицинские или научные.
5914.44 5919.40 "Игорь Лабутин" Ну, может быть, не знаю, не знаю, я как-то не рассматриваю пока VBS Assembly для визуализации.
5919.40 5924.12 "Игорь Лабутин" Ну и дальше там идут всякие Internet of Things, Machine Learning, вот это все.
5924.12 5937.20 "Игорь Лабутин" Дальше, ну, что привлекает в VBS Assembly, самый первый и самый популярный ответ – это быстрое время загрузки, а на второй популярности ответ – надо пробовать что-нибудь новенькое.
5937.20 5940.20 "Игорь Лабутин" Поэтому как бы странно, что он не первый.
5940.20 5941.68 "Игорь Лабутин" Действительно, почему бы и нет.
5941.68 5947.20 "Игорь Лабутин" И вот, наверное, то, за что зацепился глаз и почему вообще эта статья попала в мое поле зрения – это языки.
5947.20 5951.00 "Игорь Лабутин" Наиболее популярный язык для VBS Assembly, как ты думаешь,
5951.00 5953.00 "Анатолий Кулаков" какой? Наверное, Rust.
5953.00 5954.00 "Игорь Лабутин" Ну, JavaScript.
5954.00 5955.00 "Анатолий Кулаков" Да.
5955.00 5956.00 "Анатолий Кулаков" А зачем им VBS Assembly?
5956.00 5957.00 "Анатолий Кулаков" Ну, по ходу дела.
5957.00 5958.00 "Игорь Лабутин" А на втором месте?
5958.00 5959.00 "Игорь Лабутин" Надо попробовать что-то новенькое, да?
5959.00 5960.00 "Игорь Лабутин" Да.
5960.00 5961.00 "Анатолий Кулаков" Терно библиотеки не обновляли.
5961.00 5962.00 "Анатолий Кулаков" А на втором месте?
5962.00 5963.00 "Анатолий Кулаков" Ну, Rust.
5963.00 5964.00 "Анатолий Кулаков" C#.
5964.00 5965.00 "Игорь Лабутин" Мм, C#.
5965.00 5967.00 "Игорь Лабутин" Ну, все-таки дал Blazor вот этот пинок, когда люди начали все-таки пушиться и писать на VBS Assembly.
5967.00 5968.00 "Анатолий Кулаков" Да, да, да, да.
5968.00 5971.00 "Анатолий Кулаков" Я вот как раз зацепился в каком-то обзоре за то, что типа, вау, на втором месте C#, причем надо понимать, что там есть, такая статистика, что в VBS Assembly, в том числе
5971.00 5998.52 "Игорь Лабутин" его используют для VBS Assembly, а какой язык, ну, такой типа, other languages, который вы, может быть, будете использовать.
5998.52 6003.08 "Игорь Лабутин" Так вот, если взять только primary, то там C# делится с JavaScript первое место.
6003.08 6004.08 "Игорь Лабутин" Вот.
6004.08 6013.48 "Игорь Лабутин" Но понятно, что JavaScript используется во многих других местах, поэтому вот это вот за счет второго компонента, типа other, он довольно сильно обогнал.
6013.48 6014.48 "Игорь Лабутин" Но тем не менее.
6014.48 6028.08 "Игорь Лабутин" Ну и самые три большие проблемы в VBS Assembly — это отладка, это разница перформанса между разными рантаймами, то есть у нас же есть несколько рантаймов, есть браузеры, есть всякие там wasmtime, вот это все.
6028.08 6031.12 "Игорь Лабутин" И разница в перформансе между ними довольно сильная сейчас пока.
6031.12 6034.20 "Игорь Лабутин" И это вот народ отмечает как самый большой челлендж.
6034.20 6035.20 "Игорь Лабутин" Видимо, ты не знаешь.
6035.20 6037.52 "Анатолий Кулаков" Ну, если все в основном используют браузеры, какая разница?
6037.52 6041.92 "Игорь Лабутин" Ну, разница, видимо, в том, что ты там пишешь локально, отлаживаешь где-то у себя, не знаю, на матч.
6041.92 6043.28 "Анатолий Кулаков" Ну, браузерское все будет быстрее.
6043.28 6050.52 "Игорь Лабутин" А потом ты переносишь, не знаю, в другой браузер из хрома, в edge, там еще что-нибудь, и видишь разницу в перформансе.
6050.52 6051.52 "Анатолий Кулаков" Вот.
6051.52 6052.52 "Анатолий Кулаков" Понятно.
6052.52 6054.12 "Анатолий Кулаков" Ну, скоро хром всех захватит, поэтому какая разница.
6054.12 6055.12 "Игорь Лабутин" Ну, может быть.
6055.12 6062.80 "Игорь Лабутин" А вот другие отмечают недостаток, так сказать, developer experience с tooling проблемы и внезапно с learning materials.
6062.80 6068.92 "Игорь Лабутин" То есть кажется, что сейчас про vbassembly с каждого утюга, но тем не менее learning materials не хватает.
6068.92 6073.24 "Анатолий Кулаков" Ну, вот скоро выйдет книжка про Blazor, надо им всем всунуть.
6073.24 6074.24 "Анатолий Кулаков" Да.
6074.24 6080.56 "Игорь Лабутин" В общем, если вы следите за vbassembly, то, вообще говоря, наверное, вы и без меня знаете про этот отчет.
6080.56 6086.28 "Игорь Лабутин" А если не следите, но вам интересно почитать, вот смотрите, он там небольшой, страничек 30, мне кажется, или около того.
6086.28 6092.80 "Игорь Лабутин" Посмотрите вообще, чем народ занимается, на чем пишет и зачем вообще использует vbassembly.
6092.80 6093.80 "Игорь Лабутин" Примерно так.
6093.80 6096.44 "Анатолий Кулаков" Ну что ж, давай завершать.
6096.44 6107.36 "Анатолий Кулаков" Вроде хорошо сегодня пробежались и Microsoft затронули, и всех остальных посмотрели, и даже vbassembly потыкали, и Unity, никто ничего не упомянут, тоже был у нас в гостях.
6107.36 6109.80 "Анатолий Кулаков" Поэтому на этом, наверное, все.
6109.80 6111.44 "Анатолий Кулаков" До новых встреч.
6111.44 6126.20 "Анатолий Кулаков" Не забывайте лайкать, шары, репост, рассказывать друзьям, кликать, сердечки, звездочки, в общем, вы сами знаете, проставляйте больше, комментируйте больше и приносите больше нам и каких-нибудь интересных статьй и материалов.
6126.20 6128.24 "Анатолий Кулаков" Мы обязательно что-нибудь еще от вас обсудим.
6128.24 6142.84 "Игорь Лабутин" Смотри, я тут, кстати, ты так сказал, что вот Microsoft и от всех остальных, это, по-моему, один из немногих выпусков получился, где у нас, кроме Unity и вот коротко разного, все статьи от Microsoft.
6142.84 6146.84 "Игорь Лабутин" И идут на твоем релиз кандидат, и студия, и вот эти все аксессоры,
6146.84 6150.24 "Анатолий Кулаков" и перформансы. Ну погоди, private accessor мне от Microsoft был.
6150.24 6151.64 "Игорь Лабутин" Ох, сорян, сорян.
6151.64 6154.12 "Игорь Лабутин" Ну код от Microsoft, так что ладно.
6154.12 6155.12 "Анатолий Кулаков" Код от Microsoft.
6155.12 6156.12 "Анатолий Кулаков" Ну это все код от Microsoft.
6156.12 6157.12 "Анатолий Кулаков" Игры, и все остальное.
6157.12 6164.40 "Игорь Лабутин" Ну в общем, да, посмотрели на все со всех сторон, пишите, шарьте, задавайте вопросы, будем рады.
6164.40 6167.24 "Игорь Лабутин" На этом все на сегодня, всем пока.
6167.24 6168.16 "Анатолий Кулаков" До новых встреч.

