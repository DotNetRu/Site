0.00 11.40 SPEAKER_01 Здравствуйте, дорогие друзья, в эфире Radio.net, выпуск номер 88.
11.40 15.72 SPEAKER_01 И сегодня с вами его постоянный ведущий Анатолий Кулаков
15.72 16.92 SPEAKER_00 и Игорь Лабутин.
16.92 17.92 SPEAKER_00 Всем привет.
17.92 34.44 SPEAKER_01 А также большая-большая армия наших помогаторов, в частности Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин и Ольга Бондаренко.
34.44 36.40 SPEAKER_01 Всем спасибо, друзья, кто нас поддерживает.
36.40 46.20 SPEAKER_01 Если вы не знаете, про что я говорю, заходите на Boosty и поддержите мелкой копеечкой ваш любимый подкаст и посмотрите также, что у нас там еще есть интересного для вас.
46.20 66.32 SPEAKER_01 Так, из неофициальных новостей у нас все еще продолжается CFP на .NEXT, поэтому если вы хотите стать звездой и блистать на самой большой конференции по .NET, то обязательно поддавайтесь на спикерство, поддавайтесь на доклады, мы поможем с тренировками, с подготовками, со всем и сделаем отличную конференцию вместе.
66.32 68.52 SPEAKER_01 Поэтому всех ждем, всех милости просим.
68.52 73.00 SPEAKER_01 И, кажется, из неофициального это все, можно приступать к выпуску.
73.00 74.00 SPEAKER_01 Как у нас там с материалами?
74.00 75.00 SPEAKER_01 Микрософт подтянулся?
75.00 94.20 SPEAKER_00 Да, Майкрософт нашел, чем нас порадовать, ну или погрустить тут же, я не знаю, кому как, и выпустил не только статью про то, что там у нас новый превью, у нас там еще что-нибудь, а у нас прям теперь есть статья под названием «Новый вижен .NET 9», точнее не то, что новый, просто вижен .NET 9.
94.20 99.96 SPEAKER_00 То есть что же Майкрософт в целом хочет сделать за этот наступающий год, так скажем.
99.96 109.24 SPEAKER_01 Знаешь, интересно, после статей, как бы мы переписываем .NET сервисы на раст от Майкрософта, уже прям страшно такие вижены смотреть, открывать, так знаешь, страничку.
109.24 134.24 SPEAKER_00 Ну открываешь вижен, на самом деле там начинается все с типичных, ну я бы сказал баз вардов, то есть там написано, что самый главный фокус для нас это Cloud Native и Intelligent App Application Development, ну имеется в виду, конечно же, все, что связано с искусственным интеллектом, ну и куда же без тщательное и значительное вложение в Performance, Productivity и Security.
134.24 142.16 SPEAKER_00 Короче, все максимально общие слова, такое можно, наверное, сказать практически про любую платформу, про любой релиз, но вот тем не менее, вижен и вижен.
142.16 149.64 SPEAKER_00 Но этими словами не только ограничивается, точнее не только ими все ограничивается, есть расшифровка, что же это все значит.
149.64 188.96 SPEAKER_00 Начнем мы с раздела номер один, называется он Platform for Cloud Native Developers, и здесь Майкрософт говорит примерно следующее, что они хотят сделать более легким, то есть не то, чтобы развивать именно сам .NET, а сделать так, чтобы у тех, кто пишет на .NET были простые и легкие способы использовать популярную инфраструктуру, которую все и так используют в Prod, ну например, не знаю Kuber или еще что-нибудь, там Redis, более так сказать прямолинейным путем из .NET, то есть сделать так, чтобы все было попроще.
188.96 195.00 SPEAKER_00 И конечно же, главный кусочек здесь это .NET Aspire, тут куда же без него, мы про него уже каждый выпуск говорим.
195.00 239.28 SPEAKER_00 Кроме того, это конечно же найти фауты Trimming, потому что это позволяет уменьшать размеры кода в контейнере и размеры в контейнерах, дальше туда же уходит новый режим Garbage Collector, который был в The Religion в прошлом .NET, это Dynamically Adaptable to Application Size, то есть штука, которая позволяет подгонять размеры потребляемой памяти, а точнее количество куч, которые использует Garbage Collector внутри себя для разных режимов работы вашего приложения и в динамике их менять, ну и всякие более прикладные вещи, типа там Rate Limiting вот этого всего, то что без чего сейчас не живет ни одно Cloud Native приложение, вот это все будет, так сказать, в фокусе команды на ближайший релиз.
239.28 241.60 SPEAKER_00 Это то, что касается платформы.
241.60 306.48 SPEAKER_00 Есть еще раздел Tools for Cloud Native Developers, и с тулингом тут опять буду повторять те же самые слова, это опять же найти фаут, сейчас для того, чтобы что-то скомпилить в найти фаут, вам нужно поюзать, ну скажем так, как написано в Microsoft, это требует установки тулов, которые большинство дотнет-девелоперов, вообще говоря, обычно не используют, ну типа, например, докера или VSL, Windows Subsystem for Linux, а цель Microsoft сделать так, чтобы любой пользователь Visual Studio мог это все спокойно делать, поэтому они будут расширять поддержку Ahead of Time компиляции в Visual Studio каким-то образом, не знаю, пока каким, ну а также, конечно же, дотнет Aspire, куда войдет более тщательная интеграция с Visual Studio и Visual Studio Code, конфигурация компонентов, отладка, включая Hot Reload, ну и какая-то интеграция с тем самым дэшбордом, то есть, видимо, так, чтобы этот дэшборд можно было смотреть не только в браузере, но, возможно, прямо из студии в каком-нибудь там тулинг окошке, не знаю пока.
306.48 324.16 SPEAKER_00 Никуда мы не деваемся от искусственного интеллекта, Microsoft, наверное, не был бы Microsoft, если бы не сказал, что они не будут делать никакой искусственный интеллект на дотнете, конечно же, будут, и, конечно же, там ведется некоторое количество разработок уже.
324.16 340.56 SPEAKER_00 Основная цель — это не то, чтобы прямо на дотнете все это писать, а именно сам искусственный интеллект, а больше цель на то, чтобы интегрировать в себя все те тулы, которые сейчас есть, то есть более легкое использование там всяких OpenAI и других открытых моделей.
340.56 364.08 SPEAKER_00 Ну и дальше, так скажем, сотрудничество со всякими тем же самым OpenAI, сотрудничество с HRSDK, чтобы более удобно использовать всякие Artificial Intelligence сервисы из Azure, и все такое прочее, просто чтобы было попроще на дотнете использовать искусственный интеллект, ну потому что все этим, конечно, сейчас занимаются.
364.08 377.32 SPEAKER_00 Кроме того, несмотря на то, что у нас есть как бы отдельная статья под названием DotNet 9, overview, да, как там называется, Roadmap Vision, есть еще Roadmap отдельных команд.
377.32 389.20 SPEAKER_00 И я ради интереса заглянул в эти Roadmap, может быть, оно немножко пересечется с превью, который мы будем обсуждать чуть позднее в этом выпуске, но первым мне на глаза попался Maui Roadmap.
389.20 392.72 SPEAKER_00 Как ты думаешь, что же у нас в Maui Roadmap?
392.72 396.52 SPEAKER_01 Перформанс, интеграции, стабилити и все такое?
396.52 397.52 SPEAKER_00 Типа того.
397.52 409.08 SPEAKER_00 У них это называется Product Quality Across Layout, то есть они будут улучшать layouting, они будут улучшать контролы, они будут улучшать надежность тулинга, вот.
409.08 423.52 SPEAKER_00 И может быть, как у них написано, these items are under consideration, будет interrupt со свифтом, чтобы ты мог свифтовые кусочки на iPhone отдергать, может быть, они подумают про кастомные курсоры.
423.52 426.56 SPEAKER_01 Во-во, вот это замахнулись прямо.
426.56 438.36 SPEAKER_00 Да, и на том же уровне у них стоит, что они часть контролов подвинули в Maui Core слой для того, чтобы они были, ну там, видимо, можно их быстрее писать, там я не знаю еще как, что.
438.36 448.00 SPEAKER_00 Вот они move, короче, remainder of controls, оставшиеся контролы тоже подвинуть в Maui Core Layer для того, чтобы стало лучше с перформансом и стабилити.
448.00 452.08 SPEAKER_00 Короче, мы что-то будем делать, но мы пока не знаем, что мы будем делать.
452.08 454.32 SPEAKER_00 Quality и стабилити как бы.
454.32 456.36 SPEAKER_00 Quality и стабилити, да.
456.36 464.72 SPEAKER_00 Значит, дальше я посмотрел на SPNet Core Roadmap, там много всего, прям очень много, но все это под одним большим жирным заголовком – Blazor.
464.72 475.16 SPEAKER_00 То есть из прям таких больших, ну как сказать, не мега-фич, а таких направлений, да, это Blazor, Blazor, Blazor, еще Blazor, все для Blazor.
475.16 478.60 SPEAKER_00 Конечно, там будут другие улучшения, но вот это основное.
478.60 487.00 SPEAKER_01 Смотри, как интересно, это же Blazor, он же никуда не вписывается, это и не Artificial Intelligence, и не CloudNet, и вообще никуда.
487.00 490.00 SPEAKER_01 Зачем они у него столько сил вкладывают, непонятно.
490.00 491.00 SPEAKER_00 Не знаю пока.
491.00 532.20 SPEAKER_00 Ну вот посмотрим, то есть я действительно пытался найти в SPNet какие-то, ну прям такие, в вышках, которые там приведены в качестве Roadmap, какие-то более приземленные, что ли, или относящиеся к SPNet штуки, но там есть, конечно, там тема раутинг здесь, там какие-то форм-байнинги там, но они очень мелкие на самом деле, какие-то мелкие полировка всего того, что уже есть в Minimal API и в остальных местах, почему, не знаю, ну может быть они пытаются таким образом как-то, не знаю, тех, кто пишет на дотнете, десктопы, например, писал, и сейчас пересаживается на современный дотнет, типа можно JS не учить?
532.20 538.92 SPEAKER_01 Ну десктопы, мне кажется, уже давно волна прошла, которых пересаживали, ну там, естественно, они еще сохранились, но все же первая активная волна была потом.
538.92 547.00 SPEAKER_01 Мне кажется, наоборот, они видят, что не хватает фронтовиков и пытаются все-таки пересадить, ну побороться с JavaScript в этом плане, с WB Assembly и все такое.
547.00 552.28 SPEAKER_00 Ну побороться, откусить маленький кусочек, может быть.
552.28 553.28 SPEAKER_00 Ну да, наверное.
553.28 557.84 SPEAKER_01 Ну ты же понимаешь, что там даже если от слонака бы маленький откусить, тут уже как бы много.
557.84 558.84 SPEAKER_01 Это да.
558.84 559.84 SPEAKER_00 Уже хватит всем.
559.84 560.84 SPEAKER_00 Это правда.
560.84 563.60 SPEAKER_00 Поэтому может быть и действительно имеет смысл кусать.
563.60 580.16 SPEAKER_00 Дальше у нас есть C# Roslyn, там все очень непонятно, потому что там есть некоторый список VNEXT, который можно было бы принять за то, что вот это может быть и войдет в следующую версию C#, но проблема в том, что некоторые сущности в этом VNEXT живут уже годами.
580.16 588.36 SPEAKER_00 Какие-нибудь как Rawls Extensions там или, не знаю, Paramspans, они, по-моему, уже два релиза живут, не срелизятся.
588.36 589.36 SPEAKER_00 Вот.
589.36 590.36 SPEAKER_00 Но посмотрим.
590.36 602.00 SPEAKER_00 Из очередных таких полукрышесносящих штук, которые мы скорее всего будем, если их сделают, мы будем разбирать и пытаться понять, нафига это сделано, это будут refstruct интерфейсы.
602.00 608.32 SPEAKER_00 То есть спаны можно будет делать, спаны смогут реализовывать интерфейсы.
608.32 620.96 SPEAKER_01 Жестоко, refstruct интерфейсы, ну то есть с интерфейсами, которые реализуют методы, мы уже сталкивались, теперь интерфейсы, которые только для структур, по идее, будут и не просто для структуры, а только для reference structure.
620.96 629.92 SPEAKER_00 Короче, да, если еще вспомнить, что есть еще readonly, refreadonly, вот это все, то, короче, сделают фичу, посмотрим.
629.92 633.80 SPEAKER_01 Ужас, ужас, что-то куда-то не туда она идет.
633.80 634.80 SPEAKER_00 Да.
634.80 665.88 SPEAKER_00 Ну и есть у F# отдельный roadmap, там на самом деле довольно все прикольно сгруппировано, они будут пилить, ну или обновлять скорее, ленгвич сервер, короче, LSP для Visual Studio, Visual Studio Code, они будут улучшать перформанс компилятора и вот этого самого LSP, ну и докидывать там кучку аналайзеров, вот это все, как всегда, догонять по фичам в C#, когда C# что-нибудь зарелизит, такое, что не очень совместимо с F#, им придется срочно пилить совместимость, чтобы ничего не развалилось.
665.88 666.88 SPEAKER_00 Ну, в общем, как-то так.
666.88 672.12 SPEAKER_00 Вот, примерно, такой у нас vision.net.
672.12 682.56 SPEAKER_01 Ну и тут, в принципе, наверное, важно понимать, что это как бы не roadmap уже конечных фич, потому что почему-то Microsoft никогда не рассказывает те большие фичи, над которыми они работают.
682.56 690.12 SPEAKER_01 Они все еще, у меня от себя не знаю, какая-то коммерческая компания, которая во время релиза сообщает какие-то громкие навидки интересные, которые нас встречают.
690.12 692.36 SPEAKER_01 Ну, можем вспомнить много примеров.
692.36 704.80 SPEAKER_01 Поэтому это, наверное, какой-то такой действительно общий roadmap, те мелкие вещи, которые уже известны, но, скорее всего, в рукавах там есть несколько больших фич, которые будут релизиться, будут выпускаться, о которых мы еще понятия не имеем.
704.80 706.64 SPEAKER_00 Может быть, даже и они понятия не имеют.
706.64 723.08 SPEAKER_00 Кажется, что Aspire, например, поскольку он вышел только на dotnet.conf в виде первого превью, да, то есть не факт, что он там с фероля начал делаться, может быть, какие-то идеи позднее появились, потому что я думаю, что тогда бы они dotnet.conf чего-нибудь более табильное бы выпустили.
723.08 726.80 SPEAKER_01 Может быть, они даже не думали, что оно вообще выстрелит и кому-то это будет интересно.
726.80 731.56 SPEAKER_00 Ну или что успеют, в принципе, доделать dotnet.conf хоть как-то, хотя бы до первого превью.
731.56 737.56 SPEAKER_00 Так что будем смотреть, да, давайте поглядим дальше, ближе к делу.
737.56 738.56 SPEAKER_01 Давай дальше.
738.56 745.92 SPEAKER_01 Ну и тут как раз, да, как раз недалеко от вижена вышел превью 1, девятки, как бы всех фреймворков, которые связаны и так далее.
745.92 760.80 SPEAKER_01 И самое, наверное, запоминающееся в этом превью 1 в том, что эти господа изменили структуру анонсов, которые раньше были оформлены в виде хороших блокпостов, которые было прекрасно читать, прекрасно вам рассказывать и прекрасно искать и ссылаться.
760.80 781.44 SPEAKER_01 Теперь они там превратили это все в какой-то ад, они сделали все анонсы в гитлабе, о, в гитхабе, они сделали все анонсы в гитхабе, при том половина из них в виде ишисов, половину тегами к релизам, половину маркдаун-файлы, которые не забросили репозиторий, и еще есть штучки три разновидностей на сайтах микрософта, leon, whatsnew, там и еще где-то в блогах.
781.44 796.88 SPEAKER_01 В общем, получилась адская смесь, ну не знаю, с одной стороны, конечно, плохо, с другой стороны у вас теперь точно не будет никакого шанса самим это читать, вам придется нас слушать, потому что мы все это сагрегировали, задистинктили и доносим вам понятным, упорядоченным языком.
796.88 808.56 SPEAKER_01 Поэтому, не знаю, я сначала, когда собирал анонс, я думал, что я половину не нашел, как бы того, что заанонсили, я все-таки не нашел 10-20 лишних ресурсов, где это тайком нам рассказали.
808.56 813.08 SPEAKER_01 Ну на самом деле нет, я в принципе нашел все, и анонс сам по себе довольно бедненький.
813.08 818.30 SPEAKER_01 Кажется, что это, знаешь, как Hello World, его выкатывают не ради функциональности, а ради того, чтобы обкатать новую инфраструктуру.
818.30 828.00 SPEAKER_01 Так и здесь они вот надумали себе каких-то глупостей, не хотят обкатать инфраструктуру, поэтому надо было выпустить хоть что-то, хотя бы даже без изменений, просто версию поднять.
828.00 837.64 SPEAKER_00 Зато смотри, зато теперь тебе не нужен какой-нибудь клевый автор на девблог, просто сами разработчики закидали маркдаун файлик в репозитории, вот тебе и релиз ноутс.
837.64 848.88 SPEAKER_01 Так и есть, и это в лучшем варианте, если взять какой-нибудь там капам в EF Core, там просто дали тебе эту сотню ссылок на исчез и все, вот наш what's new.
848.88 852.48 SPEAKER_01 Как бы легче всего, что за спринт закрыли, вот это и разбирайте.
852.48 857.92 SPEAKER_00 Это они и в прошлом году так делали, от них статьи не было, в общем-то, одна или две за весь год.
857.92 865.20 SPEAKER_01 Ну, как бы то, что вы спихнули на разработчиков написание документации еще не решит проблему, а скорее всего даже усугубит ее.
865.20 869.00 SPEAKER_00 Ну ладно, давай посмотрим, что в итоге рано-насобиралось.
869.00 893.28 SPEAKER_01 Ну начнем с фреймворка, .NET 9, тут одни из самых главных нововведений, это то, что в JSON Serializer Options теперь засунули два необходимых всем свойства, это Ident Size и Ident Character, то есть то, как мы будем отбивать наши отступы в сериализованном JSON-файлике, и то, каким символом мы будем это делать, ну как бы, как мы без этого жили непонятно.
893.28 898.20 SPEAKER_01 Дальше, вот это еще более-менее нормальная тема, добавили в линку парочку полезных методов.
898.20 903.92 SPEAKER_01 Во-первых, это Count By, который позволяет вам вычислить то же самое количество, но уже по определенному ключу.
903.92 911.32 SPEAKER_01 Есть часто случаи оптимизации, когда это намного удобнее, чем сделать Select, а по нему уже Count, или что-то типа того городить.
911.32 918.32 SPEAKER_01 Aggregated By, который похож на основной Aggregate, но тоже умеет воспринимать в особых местах ключик, где тоже это полезно.
918.32 929.68 SPEAKER_01 И довольно концептуально новая вещь, это новый метод Index, который возвращает нам tuple, где мы получаем элемент вместе с его индексом.
929.68 934.80 SPEAKER_01 Это очень похоже на Select с индексом, вы наверняка таким могли пользоваться.
934.80 942.24 SPEAKER_01 Что есть метод Select, который принимает в качестве аргументов порядковый номер этого элемента в единомерабле и сам элемент.
942.24 945.60 SPEAKER_01 И на основании это что-то делает, что-то происходит.
945.60 951.80 SPEAKER_01 Вот здесь же этот номер и элемент, они просто возвращаются, они не передаются в какое-то замыкание.
951.80 954.04 SPEAKER_01 Вот поэтому их, например, удобно в фурриче прокручивать.
954.04 970.68 SPEAKER_01 Дальше, про фреймворк в Priority и Q немножко изменилось, тогда добавили метод Remove, это сделало возможным эмулировать изменение приоритетов в этой Priority и Q, потому что раньше это было невозможно, и поэтому некоторые хорошие оптимизированные алгоритмы невозможно было сделать.
970.68 972.32 SPEAKER_01 В общем, теперь это возможно.
972.32 985.40 SPEAKER_01 У Security области добавилась поддержка алгоритма KeemAC, это к МАК, поэтому в дотинной девятом к МАК со всех сторон пропихивают, рассовывают во всякие места, чтобы он везде поддерживался.
985.40 1001.24 SPEAKER_01 Небольшое изменение в Assembly Builder, в билдере его сделали persistent имплементацию, то есть теперь мы в рантайме можем собирать код через Reflection Emit, и не только собирать, но и теперь мы можем его сохранять в виде сборки.
1001.24 1005.72 SPEAKER_01 В общем, это тоже возможно после превью первого.
1005.72 1009.84 SPEAKER_01 Саму фреймворк, в принципе, это все, давай по другим компонентам посмотрим.
1009.84 1012.16 SPEAKER_01 Прежде всего, рантайм.
1012.16 1021.60 SPEAKER_01 В рантайме есть оптимизация в NetEvo Auto, сюда притащили Object Writer, новый Object Writer, который был написан на чистом C#.
1021.60 1032.00 SPEAKER_01 До этого в 7, 8 версии использовался тот же самый Object Writer, который базировался на LLVM версии в библиотеке и использовался везде он.
1032.00 1040.72 SPEAKER_01 Это специальный объект, специальный классик, с помощью которого записывалась дебаг информации и всякие дебажные символы для NetEvo Auto.
1040.72 1045.40 SPEAKER_01 То есть полезная в хозяйстве вещь, но была использована через интеропы всякие.
1045.40 1050.92 SPEAKER_01 А теперь на чистом C#, теперь она стала быстрее, у нее удобный интерфейсик и куча простора для оптимизации.
1050.92 1051.92 SPEAKER_01 Ну как и все.
1051.92 1057.28 SPEAKER_01 Идти и кроссплатформенно, и отвязались от лишних нативных лип, что тоже не может не радовать.
1057.28 1068.20 SPEAKER_01 Дальше есть много луп-оптимизаций, то есть оптимизаций циклов, как их красиво выравнивать, разворачивать, выносить неизменяющиеся конструкции за пределы цикла и вот это вот все.
1068.20 1081.80 SPEAKER_01 Также добавилась поддержка AMD64, SVE и SVE2 инструкций, это Scalable Vector Extensions, которые очень широко используются, например, в машин-ленингах и во всяких high-performance компьютингах.
1081.80 1085.60 SPEAKER_01 Наверное, тоже богатым и жирным принесет много удовольствия.
1085.60 1089.76 SPEAKER_00 Я тебя только тут поправлю, это не AMD64, это все-таки ARM64.
1089.76 1097.40 SPEAKER_00 На AMD64 у нас давно всякая параллелизация и прочее есть, векторизация, а вот на ARMах с ней было, ну вроде тоже неплохо, но сейчас стало получше.
1097.40 1101.72 SPEAKER_01 Да, точно, спасибо, на ARM.
1101.72 1116.62 SPEAKER_01 Оптимизации у JITA приехали также в Registered Allocation Improvements, ну это как раз та часть, которая сильно страдала при стартапе, в общем, там тоже что-то подшаманили, что теперь стартап или сделают, или будут делать быстрее и красивше.
1116.62 1138.08 SPEAKER_01 В SDK, в самом Build Tool, которым мы пользуемся, добавили Terminal Logger по дефолту включенный, мы обсуждали же Terminal Logger, это специальная версия аутпута, когда вы запускаете те же самые .NET Build, Restore, Pack и прочие вещи, а вот аутпут, который выдается, теперь будет намного красивее.
1138.08 1148.56 SPEAKER_01 В частности, там появятся кликабельные ссылки, продолжительность различных операций, т.е. таймеры внедрятся, различные подсветки, разноцветные подсветки, уборнингов и роров.
1148.56 1152.64 SPEAKER_01 В общем, станет все очень красивенько и нативненько, и модненько, и стильненько.
1152.64 1171.88 SPEAKER_01 Естественно, этот логгер, он не включается, если вдруг ваш терминал такого не поддерживает, т.е. он там все динамически анализирует и смотрит, что если у вас новый модный терминал с линками и эмоджиками, то он загружается и показывает что-то красивенькое вам.
1171.88 1177.12 SPEAKER_01 Также немножко изменилось поведение команды .NET Tool Install.
1177.12 1190.52 SPEAKER_01 Теперь, если вы вызываете .NET Tool Install и такой пакет на вашем компьютере уже установлен, но у вас находится более старая версия, то Install обновляет эту версию до самой последней, которую он найдет.
1190.52 1199.88 SPEAKER_01 Раньше такого было делать не можно, раньше вам необходимо было вызывать отдельно .NET Tool Update, и с тем же самым эффектом практически.
1199.88 1212.46 SPEAKER_01 А SP-Core практически спит, он добавил JSON-полиморфик Type-support для SignalEra, т.е. в SignalEra-хабах вы теперь можете децерализовать полиморфические ДТОшки, ну, допустим.
1212.46 1227.70 SPEAKER_01 У Entity Framework из заметного, это поддержка комплекс-тайпов в Execute-Update, напомню, Execute-Update это мега шикарная штука, когда вы можете целую пачку по какому-то условию запихнуть в нее Update.
1227.70 1233.04 SPEAKER_01 В общем, очень полезная вещь для многих сценариев, для многих алгоритмов, прям вообще класс.
1233.04 1250.48 SPEAKER_01 А комплекс-тайпы тоже мы обсуждали как раз недавно, это специальные такие Entity в Entity Framework, которые инкапсулируют в себя какие-то более сложные типы, более сложные value-обжекты, которые могут раскладываться, допустим, на несколько полей.
1250.48 1256.20 SPEAKER_01 И теперь вы такие сложные объекты тоже можете обновлять по условию.
1256.20 1261.72 SPEAKER_01 Там синтаксис, конечно, немножко непривычен для нормального человека, но, к сожалению, там по-другому не сделаешь.
1261.72 1264.60 SPEAKER_01 Поэтому если вам это нужно, вы даже этим будете радоваться.
1264.60 1275.60 SPEAKER_01 Ну и MAUI тоже выпустил превью первый, но там практически ничего нет, про что можно сказать в приличном обществе, поэтому про него просто промолчим.
1275.60 1276.60 SPEAKER_01 Ну, Performance, Stability.
1276.60 1279.32 SPEAKER_01 Да, да, да, вот этот все.
1279.32 1291.40 SPEAKER_00 Я прямо вижу наши вот заметки к этому выпуску, и там видно там заголовок такой-то, там SDK Update, какие-то заметки, там SPNET, заметки Entity Framework, заметки про MAUI, только заголовок.
1291.40 1293.36 SPEAKER_00 Прям прекрасно, да.
1293.36 1299.16 SPEAKER_01 Ну, просто про все остальные команды можно было хотя бы один параметр вытащить, а здесь вот просто ничего.
1299.16 1310.04 SPEAKER_01 В общем, превью довольно бедный, практически никчемный, но, наверное, просто чтобы обкатать какую-то инфраструктуру для релизов или просто новую версию выпустить, чтобы что-то было.
1310.04 1328.40 SPEAKER_00 Ну, да, посмотрим, когда это будет уже нормальные следующие превью, превью 2, я надеюсь, там будет что-то ценное и хорошее, и, может быть, даже заметки как-то обретут, может быть, они какую-нибудь ретру проведут на тему того, что как неудобно это все читать и будут экспериментировать дальше.
1328.40 1344.52 SPEAKER_01 Ну, я, кстати, лазил по гитхабу с целью как бы увидеть гневные комментарии, и, если честно, гневных не нашел, а таких нейтральных есть парочку, но не кажется, знаешь, что у них будет какой-то материал для того, чтобы проводить ретроспективы насчет их заметок.
1344.52 1348.72 SPEAKER_00 Ну, может, они сами на самом деле фиг знают, поймут еще что-нибудь.
1348.72 1350.84 SPEAKER_00 Ладно, глянем, давай дальше.
1350.84 1355.28 SPEAKER_00 Дальше у нас про C# и про breaking changes.
1355.28 1371.64 SPEAKER_00 В гитхабе появилось ищу, в котором, ну, точнее, как в гитхабе, в главном репозитории C# ленга появилось ищу, в котором Мэтт Скридсонсон в том числе рассуждает на тему того, как они собираются вносить breaking changes в C#.
1371.64 1384.56 SPEAKER_00 То есть надо понимать, что C# — язык, в который очень строго блюдет принцип обратной совместимости и фича, единожды добавленная в язык, в общем-то живет в этом языке, ну, можно сказать, вечно.
1384.56 1393.32 SPEAKER_00 Можно по пальцам, может быть, даже одной руки пересчитать случаи, когда в языке что-то прямо существенно серьезно ломалось.
1393.32 1407.88 SPEAKER_00 Но проблема заключается в том, что если таким образом жить дальше, то, ну, получается, что довольно много изменений в язык не сделать, потому что они, ну, ломающие по сути своей.
1407.88 1410.28 SPEAKER_00 И вот Мэтт приводит несколько примеров.
1410.28 1418.00 SPEAKER_00 Например, то, что сейчас давно хотят и, может быть, это появится в ближайшем C#, это так называемый field access.
1418.00 1419.00 SPEAKER_00 То есть что это такое?
1419.00 1425.20 SPEAKER_00 Напомню, у нас есть в классе, мы можем объявить property, мы можем объявить поле, field.
1425.20 1441.40 SPEAKER_00 При этом в свойстве вы можете написать setter, getter, и внутри setter вы можете, например, использовать неявную переменную типа value для того, чтобы ее, ну, присвоить тому полю, в который вы хотите его присвоить.
1441.40 1447.92 SPEAKER_00 То есть это то, что передали вам, когда присваивали в это поле, в это свойство что-то.
1447.92 1458.36 SPEAKER_00 Но для того, чтобы это работало, то есть если вам нужна какая-то кастомная логика в setter или getter, приходилось заводить собственно реальное физическое поле, куда это значение, например, складывать.
1458.36 1475.20 SPEAKER_00 Довольно давно висит пропозал про то, что ну раз у нас есть такое специальное переменное, типа псевдопеременное под названием value, давайте заведем псевдопеременное под названием field, и компилятор нам будет автоматически генерить вот это самое то, что на английском называется backing field.
1475.20 1480.92 SPEAKER_00 То есть поле, которое лежит под этим свойством и, собственно, занимается тем, что хранит это значение.
1480.92 1491.00 SPEAKER_00 А в setter или getter мы будем там писать field присвоить value, да, и там в getter и return field, грубо говоря, если прямо вот такое самое простейшее свойство написать, с явным getter и setter.
1491.00 1506.60 SPEAKER_00 Все бы хорошо, но эта штука является breaking change, потому что если у вас уже есть в классе, в области видимости getter или setter, поле под названием field, то внедрив такую новую штуку в язык, вы потенциально поменяете поведение.
1506.60 1529.80 SPEAKER_00 То есть либо вы начнете использовать вот этот новый field, новое псевдопеременное внутри setter и таким образом поменяете поведение, потому что раньше ваш setter, например, обращался к полю field, или, наоборот, вы добавите фичу в язык, но ради сохранения обратной совместимости внутри setter field не будет означать то, ради чего его добавляли в язык, ну тоже как бы странное поведение.
1529.80 1535.56 SPEAKER_00 Короче, breaking change — это то, что новенького, то, что еще не сделано.
1535.56 1548.72 SPEAKER_00 Но на самом деле, те фичи, которые вы хорошо знаете, они тоже в каком-то смысле были добавлены, ну скажем так, с определенными приседаниями, чтобы избежать breaking change.
1548.72 1554.04 SPEAKER_00 Например, всем известное слово var — это ключевое слово языка.
1554.04 1561.92 SPEAKER_00 И его добавление — это тоже было breaking change, потому что технически у вас мог быть класс по имени var маленькими буквами.
1561.92 1566.80 SPEAKER_00 Это, наверное, очень странный класс, но по идее он мог быть.
1566.80 1573.08 SPEAKER_00 Например, я допускаю такой пример, что он мог бы быть автосгенерен из какой-нибудь, не знаю, грамматики.
1573.08 1580.16 SPEAKER_00 У вас там в вашем домене var — это нормальный термин для какого-нибудь бизнес-объекта, и у вас мог бы быть такой класс, ну для удобства.
1580.16 1582.84 SPEAKER_00 Да, это не по C# стилю, но почему нет?
1582.84 1589.76 SPEAKER_01 Ну проблема точно такая же, как и с field, то есть field тоже должен быть маленькими буквами назван так, класс, чтобы это было каким-то breaking changes.
1589.76 1595.92 SPEAKER_00 Нет, в field как раз необязательно, у тебя в field может быть private поле, названное уже field, и всё.
1595.92 1598.84 SPEAKER_01 А, private поле, ну да, private поле может быть.
1598.84 1616.72 SPEAKER_01 Ну вот, да, мне просто хочется сделать небольшую заметку, что если вам вдруг почему-то режется лук, когда мы говорим, что breaking changes возможны, то вот подумайте, что если бы Microsoft не пошёл на breaking changes, то у вас никогда бы не было слова var, потому что var — это реально мог такой класс существовать.
1617.04 1637.24 SPEAKER_01 Но если подумать разумно, то вероятность этого очень-очень мала, и вот ради парочки извращенцев в мире, у кого такое могло бы быть, как бы не развивать полностью язык, это ещё хуже решение, чем вот такими людьми там или проектами такими пренебречь немножко или как-нибудь там компиляторам помочь им проапдейтиться или ещё что-то.
1637.24 1641.60 SPEAKER_01 То есть breaking changes нужны, без них никуда не денешься, ну естественно в каких-то разумных пределах.
1641.60 1642.60 SPEAKER_00 Ну вот.
1642.60 1661.20 SPEAKER_00 Так вот, когда вводили var, то было принято следующее решение, что var означает «выведи, пожалуйста, тип этой переменной автоматически только в том случае, если нет в скоупе, в том месте, где вы написали var, класса под названием var, видимо».
1661.20 1696.08 SPEAKER_00 И как пишет Мэттс у себя в статье выше, если вы помните, там когда только вводили var, были всякие споры, да, там типа var или не var, использовать var или использовать var только там, где тип явно виден из правой части, ну короче там даже в райдере есть, или в шерпе такие настройки типа, да, когда автоконвертить в var, то многие, кто были абсолютно против вара, делали простую штуку, они заводили какой-нибудь утилитный, в утилитном пакете, который включается во все там ваши проекты, компании, класс под названием var маленькими буквами и всё, у вас везде var не работает.
1696.08 1697.08 SPEAKER_00 Вот.
1697.08 1699.72 SPEAKER_00 Такая простая как бы штука.
1699.72 1715.08 SPEAKER_00 И Мэттс говорит, что это как раз очень плохо, не в смысле тот факт, что заводили такую штуку, а тот факт, что заведение класса где-то далеко в каком-нибудь чёрт знает каком нугете влияет на поведение программы в совершенно несвязанном логическом месте.
1715.08 1718.84 SPEAKER_00 Тот факт, что просто эта штука видна в скоупе не означает, что она должна влиять.
1718.84 1719.84 SPEAKER_00 Вот.
1719.84 1722.56 SPEAKER_00 Ну, тем не менее, в общем, штука есть.
1722.56 1723.56 SPEAKER_00 Дальше.
1723.56 1753.24 SPEAKER_00 Есть такая фича в C#, называется она, я, кстати, не знаю, как это на русском называется, я её называю дискард, ну по-английскому называется дискарды, это когда вы можете написать одиночное подчёркивание вместо символа, вместо имени переменной, и в этом случае компьюратор будет понимать, что вам вообще не важно, что там, такое часто используют, например, для out-параметров, то есть если у вас есть функция, которую вам нужно вызвать, у неё есть out-параметр, но вам он не нужен, то вы просто туда пишете там out, не знаю, там int подчёркивание, и компьюратор знает, что подчёркивание в принципе как бы можно игнорировать.
1753.24 1754.24 SPEAKER_00 Вот.
1754.24 1765.88 SPEAKER_00 Но технически, опять же, подчёркивание - это валидное имя переменной, никто никогда не запрещал в C# заводить такое имя переменной, наверное, это опять же странное имя, но почему нет?
1765.88 1767.04 SPEAKER_00 Вот.
1767.04 1788.00 SPEAKER_00 Поэтому, когда вводили эту фичу, то ввели её, задумайся, с приседаниями следующими, что она будет, вот одиночное подчёркивание будет работать дискардом только в тех случаях, которые синтаксически были невозможны в прошлых версиях C#.
1788.00 1791.08 SPEAKER_00 Ну, типа, это в таком случае точно не breaking change.
1791.08 1798.60 SPEAKER_01 То есть, когда ты не мог написать var подчёркивание, потому что тебе нужно было бы раньше указать тип какой-нибудь, да?
1798.60 1812.08 SPEAKER_00 Ну, не var, это не var подчёркивание, это int подчёркивание можно тоже, или там string подчёркивание, ну, в смысле, в каком-нибудь таком месте, в каком-нибудь, например, там tuple deconstruction, вот не было их раньше, вот тут появились, и вот тут можно дискарды, а в других местах нельзя.
1812.08 1825.52 SPEAKER_00 И более того, если есть хотя бы одно использование в качестве, ну, как бы, обычной переменной, то, опять же, дискардность отменяется, и подчёркивание становится валидной переменной.
1825.52 1847.20 SPEAKER_00 Короче, то есть такое ощущение, что ради того, чтобы сделать как можно лучше избежать потенциального breaking change, приходится в компиляторе, скорее всего, генерить огромное количество вот этой лишней логики по проверкам на тему, значит, а вот в каком ли мы месте, в каком мы контексте, в каком ли мы версии языка, вот это всё.
1847.20 1848.20 SPEAKER_00 Короче, сложно.
1848.20 1856.16 SPEAKER_01 Ну, и сам язык это делает некрасивым, неконсистентным, неудобным, сложным для объяснения, сложным для понимания, тебе надо учитывать какие-то неявные контексты.
1856.16 1860.08 SPEAKER_01 Ну, по-разному, по-разному, мне кажется, вот здесь надо жёстче.
1860.08 1957.00 SPEAKER_00 Да, и поэтому следующий как раз раздел – это про то, что, окей, breaking change кажется, что нужны, но breaking нужно делать так, чтобы вся команда, ну, короче, это не должно быть просто так, что типа, ой, я придумал новую фичу, кажется, на breaking, окей, у нас есть алгоритм, как мы будем работать с этим breaking change, ну, технически, да, там, кейнтворнинг, там ещё что-то, поэтому делаем спокойно и не паримся, нет, всё-таки надо минимизировать количество breaking change и делать их максимально безопасными, да, так скажем, и поэтому вот Мэдс предлагает в это ищу, и там дальше есть какое-то обсуждение, я не знаю, не дочитал там какое-то огромное обсуждение, но кажется, что они плюс-минус пришли к следующим критериям того, даже не критериям, а каким-то, ну, набору соображений, не знаю, лозунги, наверное, неправильное слово, как подходить к вопросу, нужно ли и как, если нужно делать этот самый breaking change, то есть, во-первых, это должно быть достаточно редко и с прям вот очевидными преимуществами для потенциальных пользователей, то есть, если действительно у нас есть какая-то старая фича C#, которая, ну, логически неудобна, а мы можем придумать новую, удобную и она точно будет полезна большинству пользователей C#, тогда есть смысл делать, если кому-то там, не знаю, трём человеком хочется какую-нибудь странную фичу в C# и остальные её никогда не будут использовать, но это breaking change, нет, тогда не будем делать.
1957.00 1986.96 SPEAKER_00 Дальше, даже если это breaking change, то технически, как ты раньше говорил, в адекватном, в среднестатистическом C# коде, скорее всего, breaking change не будет, ну, мало кто объявляет классы с именем var маленькой буквы, или мало кто поля объявляет с полем field, ну, обычно всё-таки чуть, в смысле, с названием field, обычно чуть более говорящие названия, да, у полей, то есть в реальном коде, скорее всего, breaking change не будет.
1986.96 2012.48 SPEAKER_00 Дальше, каждый конкретный breaking change должен быть объяснён соответствующими диагностическими месседжами, то есть не просто про то, что типа, а, чувак, ты использовал новую версию компилятора, может у тебя что-то сломается, ну, может быть это будет про слово field, а прям конкретно в нужном месте, вот здесь вот подчеркивается какое-нибудь использование слова field, да, и говорится, вот тут у тебя сломается так-то, вот.
2012.48 2065.44 SPEAKER_00 И последнее четвёртое, для каждого такого случая должен быть хороший дефолтный фикс, который можно применить в EDE-шке, грубо говоря, да, там типа, ну, родственники, да, условно говоря, аналайзеры и фикс к нему, который будет а) простой, то есть не потребует переписывания половины проекта, б) железно работающий, то есть не то, что он там типа в большинстве случаев починит, но 50 на 50, кто-то может ещё сломать, вот, и полностью автоматизируемый, то есть типа, а, и самое главное, я забыл, он должен как это, сохранять смысл кода, то есть, грубо говоря, значит, вы должны иметь возможность каким-то образом поймать эти варнинги, я сейчас объясню каким, после чего, посмотрев на них, сказать, ага, понятно, сказать, применить фикс ко всему solution и быть уверенным, что после этого ваш solution нормально будет работать.
2065.44 2070.96 SPEAKER_01 Ну, типа какой-нибудь migrate процесс запустить и замигрировать на новую версию C#.
2070.96 2079.72 SPEAKER_00 Ну, типа такого, там скорее должно быть case by case, в смысле по каждому из breaking changes, вы должны посмотреть, понять, ага, может быть, что-то руками самому поправить.
2079.72 2086.36 SPEAKER_00 О, блин, кто у нас называл класс, слово var, давайте перепишем, вот, либо просто автоматически что-то сделать.
2086.36 2103.04 SPEAKER_00 Вот, и вот как раз-таки на примере Филда, он говорит, что типа, ага, давайте примерим эту штуку к Филду, вот эти принципы, да, как бы, есть ли у нас явная, так сказать, польза для пользователей.
2103.04 2116.72 SPEAKER_00 Ну, как бы, да, есть, в том смысле, что это одна из, она это, наверное, не самая высоко залайканная фича в гитаре PC#, но довольно высоко, то есть, есть такая просьба.
2116.72 2128.92 SPEAKER_00 Ну, и она звучит логично, имея value, имеет еще и field, но все хорошо с точки зрения, так сказать, adoption от community, все будут, скорее всего, рады.
2128.92 2159.16 SPEAKER_00 Второе, будет ли тот факт, как бы, будет ли соблюдаться тот факт, что реальный breaking change будет действительно встречаться редко в реальном коде, и да, таки будет, потому что для того, чтобы это было breaking change, добавление филда ключевого там слова или какого-то специального слова внутри сеттера или геттера для property будет breaking change, только если внутри такого геттера или сеттера есть доступ к чему-либо под названием field маленькими буквами.
2159.16 2162.70 SPEAKER_00 Ну, что это, скорее всего, означает private поле.
2162.70 2165.72 SPEAKER_00 Как я сказал, вряд ли вы называете private поля просто словом field.
2165.72 2169.48 SPEAKER_00 Я не могу придумать, зачем, но технически такое возможно.
2169.48 2170.48 SPEAKER_00 Дальше.
2170.48 2173.96 SPEAKER_01 В этой ситуации, надо признать, может встретиться гораздо чаще, чем в R-классе.
2173.96 2185.24 SPEAKER_00 Ну, я согласен, какой-нибудь там, не знаю, опертка над чем-нибудь, где у тебя единственное поле, но я все равно как-то не думаю, что это действительно часто.
2185.24 2186.24 SPEAKER_00 Не думаю.
2186.24 2190.88 SPEAKER_00 Это чаще, чем в R, конечно, может быть, но все равно абсолютный процент очень мало.
2190.88 2200.04 SPEAKER_01 Ну вот смотри, можно, например, привести пример, это недалеко ушло от поля под названием value, а поле под названием value применяется много где, в том числе и самим Microsoft.
2200.04 2211.60 SPEAKER_01 Вспомним, например, класс Nullable, то есть структуру Nullable, у которой есть field value, допустим, или там, по моему, гуйда там какой-то value есть, или урла, ну то есть, или options.
2211.60 2215.40 SPEAKER_01 Ну то есть, есть много классов, у которых есть поле value от самого Microsoft.
2215.40 2220.00 SPEAKER_01 Но кажется, что поле field недалеко ушло от такого названия.
2220.00 2226.76 SPEAKER_00 Все верно, я согласен, возможно, действительно так, вопрос, но тебе нужно не только поле field, но тебе еще нужна пропертя.
2226.76 2245.12 SPEAKER_00 То есть тебе нужен класс, у которого есть внутреннее поле, плюс поверх него есть пропертя, которая внутри доступается к этому полю, ну, наверное, есть такие, но, короче, Microsoft, возможно, опять же, они же не просто так считают это из воздуха, они как-то явно это, не знаю, ищут по кодовой базе GitHub, например.
2245.12 2250.40 SPEAKER_00 Непонятно, насколько она репрезентативна, но думаю, что для некоторых… У них просто выбора нет
2250.40 2251.40 SPEAKER_01 особо.
2251.40 2252.40 SPEAKER_00 Ну да.
2252.40 2259.92 SPEAKER_00 Дальше, с точки зрения диагностики, тут тоже все четко, вот там, где ты использовал field, в этом месте его можно подчеркнуть и сказать, вот тут будет breaking change.
2259.92 2267.76 SPEAKER_00 И дефолтный фикс тоже довольно простой, вы просто меняем это на this.field и все, и у тебя все продолжает работать.
2267.76 2273.44 SPEAKER_00 То есть тут без вариантов, все хорошо, все нормально.
2273.44 2276.44 SPEAKER_00 Как, собственно, с этим будут жить?
2276.44 2284.20 SPEAKER_00 Мы вот про это уже когда-то говорили, теперь это оформлено в виде уже вот полноценного такого issue, так сказать, в письменном виде, нормально зафиксировано.
2284.20 2293.56 SPEAKER_00 Смотрите, значит, допустим, мы в новой версии C# что-то делаем breaking, да, вот сейчас выйдет у нас новый C#.
2293.56 2299.52 SPEAKER_00 Ну сейчас, больше, чем через полгода, мы в нем сделаем breaking change.
2299.52 2309.56 SPEAKER_00 Компилятор версии новый, когда он компилирует для любой версии старее, чем новая, ну то есть выйдет у нас какой сейчас, тринадцатый будет, да?
2309.56 2312.40 SPEAKER_00 Я же ничего не путаю, или я уже запутался в числах?
2312.40 2313.40 SPEAKER_00 Или тринадцатый вышел?
2313.40 2314.40 SPEAKER_01 Давай.
2314.40 2315.40 SPEAKER_01 Ну следующее, короче.
2315.40 2316.40 SPEAKER_00 Не это самое, а это самое.
2316.40 2319.64 SPEAKER_00 VNEXT, давай, не будем с числами, что-то я уже путаюсь в числах.
2319.64 2328.60 SPEAKER_00 Короче, выйдет VNEXT, а мы берем, в общем, если мы компилируем под любую версию старше, чем VNEXT, то будет ворнинг в коде.
2328.60 2330.60 SPEAKER_00 То вот тут будет все плохо.
2330.60 2331.60 SPEAKER_00 Вот.
2331.60 2342.92 SPEAKER_00 В ворнинге будет, соответственно, тот самый message, который там из критерия номер три выше, да, будет suggested fix, который, соответственно, из критерия номер четыре.
2342.92 2345.48 SPEAKER_00 Все, в общем, по-моему, все идеально.
2345.48 2350.46 SPEAKER_00 И всякие DE-шки, всякие миграторы должны все эти фиксы, конечно же, предлагать.
2350.46 2372.14 SPEAKER_00 А теперь вопрос, кто, ну как бы, такая стратегия не гарантирует того, что про этот breaking change узнают все, потому что многие просто апгрейдят, ну, ты типа апгрейдишься до последнего, ты апгрейдишь SDK, тут же апгрейдишь target, и типа все хорошо.
2372.14 2381.26 SPEAKER_00 Но поскольку версия языка, под которой компилируется, определяется таргетом, то не будет ситуации, когда весь шаро-компилятор компилирует под старую версию языка.
2381.26 2382.90 SPEAKER_00 Это пока открытый вопрос.
2382.90 2385.62 SPEAKER_00 Что с этим делать?
2385.62 2389.78 SPEAKER_00 Ну, про него чуть-чуть дальше, может быть, еще скажу.
2389.78 2393.50 SPEAKER_00 Теперь смотрите, дальше Мэттс говорит интересную штуку.
2393.50 2419.06 SPEAKER_00 На самом деле, если у вас есть код, он компилировался в старой версии компилятора, работал, у вас там стоит warnings as errors, вот это все, и вы добавляете новые ворнинги на существующий код, то само по себе это вообще, так говорят, тоже breaking change, то есть борясь с breaking change на уровне языка, мы вносим breaking change на уровне билда.
2419.06 2421.30 SPEAKER_00 То есть у вас проект собирался, теперь перестал.
2421.30 2429.46 SPEAKER_00 Да, вы, конечно, переехали на новый, не знаю, на новый таргет, но тем не менее, как бы тоже breaking change.
2429.46 2449.46 SPEAKER_00 Но здесь Мэттс говорит следующее, что, во-первых, мы уменьшаем количество этих ворнингов, уменьшаем точнее количество мест и раз, когда это может встретиться, ну типа раз в год, вот это может случиться, вот когда мы SDK проапгрейдили, тогда случилось, поэтому это будет редко.
2449.46 2460.42 SPEAKER_00 Второе, у компилятора будет специальный флаг, называется выключить нахрен все breaking change ворнинги, вот эти все специальные ворнинги, конкретно про breaking change будет специальный флаг, который вы говорите, вот их конкретно выключи, остальные не оставь, а эти выключим.
2460.42 2461.42 SPEAKER_00 Почему?
2461.42 2485.10 SPEAKER_00 Потому что, во-первых, у вас могут быть какие-то там легаси проекты, в которых вы знаете, что вы никогда ничего не будете фиксить, и вам неинтересно видеть эти ворнинги, ну то есть вы апгрейдите SDK, но вы не собираетесь обновлять target framework на них, это как раз тот кейс, когда ворнинги вам нужно показать, но вы знаете, что вы не будете обновлять target framework у этих проектов, поэтому ворнинги можно выключить.
2485.10 2505.82 SPEAKER_00 И второе, на самом деле, как говорит Мэттс, в принципе на билд-серверах эти ворнинги тоже по идее не нужны, потому что эти ворнинги то, с чем может программист что-то сделать, поэтому они нужны при билде вашем локальном, чтобы вы их видели, а на билд-сервере, ну как бы, пока оно собирается под старый target, там все работает по старому, они не нужны.
2505.82 2515.90 SPEAKER_01 Ну если бы только локально, они могли бы сделать это просто отдельной командой, типа check for migrate, vnext или что-нибудь в этом духе, ну тогда никакого смысла их бы не было в компи засовывать.
2515.90 2519.98 SPEAKER_01 Никто не будет запускать отдельную команду, ну ты что.
2519.98 2525.66 SPEAKER_01 Ну опять же, Visual Studio будет, если мы говорим только про локально, вот пожалуйста, Visual Studio будет запускать эту команду.
2525.66 2528.86 SPEAKER_01 А те, кто умные, те руками могут и сами определенно раз в месяц запускать.
2528.86 2530.94 SPEAKER_00 Ну в общем, пока принято.
2530.94 2539.22 SPEAKER_01 Мне кажется, что как раз-таки наоборот, на CI, если у тебя будет CI падать с этими ворнингами, с этими break-in-changes, то это будет хороший показатель.
2539.22 2542.22 SPEAKER_01 Ты увидишь, ты точно увидишь, ты это не пропустишь никогда.
2542.22 2549.86 SPEAKER_01 Ну и если ты хочешь подавить, пожалуйста, присылаешь флажочек, который говорит, что не надо мне падать на break-in-changes, и он проходит дальше.
2549.86 2553.06 SPEAKER_01 То есть это не то, чтобы сильно ухудшает работоспособность.
2553.06 2555.82 SPEAKER_00 Я так понимаю, что они так и будут делать.
2555.82 2559.62 SPEAKER_00 То есть не так, что компилятор будет понимать, что он в CI, и тут же глушить.
2559.62 2560.62 SPEAKER_00 Нет.
2560.62 2567.10 SPEAKER_00 Это скорее, что ты типа должен в своем CI этот флажок написать явно.
2567.10 2568.10 SPEAKER_00 Хочешь, пиши, хочешь, не пиши.
2568.10 2570.94 SPEAKER_00 Ну вот это хорошо, вот это нормальный в принципе выбор.
2570.94 2575.42 SPEAKER_00 И последний момент тоже довольно важный.
2575.42 2588.74 SPEAKER_00 Как вы знаете, у нас, как вот мы сейчас только что говорили, точнее, компилятор, когда он компилирует ваш C# код, он знает target language level, так называемый, или target версию языка.
2588.74 2591.42 SPEAKER_00 Обычно она определяется таргетом вашего проекта.
2591.42 2603.98 SPEAKER_00 То есть если вы указываете там какой-нибудь .NET, не знаю, 6, возьмется тот C#, который был релизный на момент .NET 6 в качестве таргетного, то есть компилятор будет считать, что вы пишете на том C#.
2603.98 2608.46 SPEAKER_00 Если вы таргетите .NET какой-нибудь 8, вот возьмется последний.
2608.46 2612.66 SPEAKER_00 Но есть две специальных версии.
2612.66 2616.98 SPEAKER_00 Версия на специальный номер 1 – это latest.
2616.98 2635.34 SPEAKER_00 Вы можете в C++ указать lang version, по-моему, называется пропертя, указать туда latest, ну и да, естественно, вы можете указать любую другую фиксированную, то есть вы даже в таргете .NET 6 можете сказать lang version, вот какая сейчас у нас текущая, и он будет компилить ее под текущую нормальную, но можно указать latest.
2635.34 2639.86 SPEAKER_00 И тогда он берет, типа, максимально новую, которую я могу.
2639.86 2648.50 SPEAKER_00 И понятно, что никаких breaking, change warning тогда не будет, потому что у вас нету кейса, когда новый компилятор компилирует под старую версию языка.
2648.50 2662.10 SPEAKER_00 И здесь медс говорит, что, скорее всего, версию под названием latest уберут, ее будет указывать нельзя, ну, точнее, указывать будет можно, но это будет warning.
2662.10 2667.62 SPEAKER_01 Блин, ну это вообще беспредел, это моя самая любимая опция была.
2667.62 2671.98 SPEAKER_01 Так не хотелось вот с этими старперами жить, которые раз в 4 года обновляют эту версию.
2671.98 2674.50 SPEAKER_01 Я всегда под latest сижу, мне все нравится.
2674.50 2676.70 SPEAKER_00 Ну вот, пока не сломали.
2676.70 2687.82 SPEAKER_00 Вот, и для тебя будет специальная опция, которая сможет, так сказать, засопросить этот warning про то, что не надо ворнинги про latest.
2687.82 2692.94 SPEAKER_00 Ну то есть у них убрать в английском это у них называется retire и в кавычках.
2692.94 2699.74 SPEAKER_00 То есть я так понимаю, что типа они не будут промоутить ее использование, но прям убирать-убирать совсем ее не планируют.
2699.74 2703.14 SPEAKER_00 То есть она останется, но будет всегда под warning, который можно всегда убрать.
2703.14 2705.94 SPEAKER_01 Опять какие-то костыли непонятные, блин.
2705.94 2708.74 SPEAKER_00 Вот да, смотри, а мы обсуждаем breaking change, да?
2708.74 2709.74 SPEAKER_00 Вот тебе breaking change.
2709.74 2728.18 SPEAKER_01 Ну подожди, а давай вот вернемся к той идее, что если б у нас все-таки была бы отдельная команда, которая говорит товарищ компилятор, проверь мне вот этот мой код, я собираюсь там перейти с дотнета 6 на 7, проверь мой код и выдай мне ворнинги, на которые я должен обратить внимание.
2728.18 2730.10 SPEAKER_01 Ну это же решило бы абсолютно вообще все проблемы.
2730.10 2736.58 SPEAKER_01 Не надо было бы запрещать там latest, не надо было бы там какие-то флажки, не надо какие-то дизейблы придумать, просто, блин, сделайте отдельную команду и все.
2736.58 2741.62 SPEAKER_01 И как часто ее запускать, то я сам решу, в конце до конца у меня есть MCI-настрой, который каждую ночь ее будет запускать и проверять что-то.
2741.62 2742.62 SPEAKER_00 Ты такой умный.
2742.62 2748.70 SPEAKER_00 Настроишь, и ты точно знаешь, с какой версии языка ты переходишь на какую версию языка.
2748.70 2759.90 SPEAKER_00 Большинство, кажется, народу, Microsoft видео все-таки ориентируется на большинство, они тупо сидят в Visual Studio, жмут кнопку publish, и у них все работает.
2759.90 2766.74 SPEAKER_00 И вот как бы для их кейса никто не будет запускать все эти тулы, там CI-настроить, вот это все.
2766.74 2769.58 SPEAKER_00 Но при этом их код тоже нельзя ломать.
2769.58 2780.74 SPEAKER_01 Просто мы придем постепенно с таким путем, мы придем к тому, что у нас в дотнет-билде будет интегрирован какой-нибудь дотнет-мигрейт, который будет знать, и делать, и проверять, и все на свете.
2780.74 2786.82 SPEAKER_01 У тебя билд будет или медленный, или сложный, или то другое вместе.
2786.82 2790.50 SPEAKER_00 Не знаю, это, может быть, надо смотреть.
2790.50 2797.74 SPEAKER_00 То есть, опять же, надо понимать, что это все не окончательно финальное решение, которое с нами теперь на десятки лет.
2797.74 2845.66 SPEAKER_00 Это некоторый пропозал, который сейчас у МЭДСа родился и сформировался в некоторую уже документированную, структурированную штуку, которую они, скорее всего, собственно говоря, которую они попробуют на том самом филде, вот этот филд аксессор, который внутри пропертий, они его собираются сделать в следующем C# 13, и на нем отработать эту штуку, и посмотреть, какой будет фидбэк от комьюнити, что все остальные скажут, какой фидбэк будет не только от комьюнити, надо понимать, что фидбэк от комьюнити будет это, как сказать, народ типа тебя, который понимает, что они делают, в большинстве своих, могут настроить себя и все остальное, и так далее.
2845.66 2867.50 SPEAKER_00 Возможно, будет фидбэк от каких-нибудь там first, second, third party, кастомеров, где какие-то, возможно, более бизнес там, ну такие, как интерпрайс-программисты сидят, которые только вижу в студии что-то делают, условно говоря, в таком духе, то есть и вероятно к C# 14 следующей версии может что-то еще изменится, посмотрим, пока не знаю.
2867.74 2891.50 SPEAKER_00 Вот, еще последний момент, то, что я недорассказал, помимо лейтеста есть еще специальная версия под названием превью, вот, с ней делать ничего не хотят, если ты такой крутой, что ты указал превью в своем C#, ты, значит, сам лучше Майкрософта знаешь, какие breaking changes могут быть в своем коде, тебя вообще ни о чем предупреждать не будут, вот такие вот дела нас ждут в C#.
2891.50 2906.46 SPEAKER_01 Ну, хорошо, хорошо, вроде звучит вполне разумно, но мне нравится сама ситуация, что наконец-то начали съезжать с этой пьяной точки, когда блюли всякие различные совместимости просто без оглядки, как бы обязательно-обязательно совместимость.
2906.46 2916.86 SPEAKER_01 Наверное, в каких-то вещах это хорошо, но не здесь, ну, вот, например, совместимость в Windows мне нравится, да, когда мы можем на последней винде запустить там какой-нибудь DOS и проиграть в старинные игры, которые делались еще под MS-DOS.
2916.86 2927.70 SPEAKER_01 Вот это нормально, ну, потому что действительно очень много кейсов в мире существует, когда непонятно, под чем и кто сейчас сидит, и что и кто сейчас запускает.
2927.70 2938.82 SPEAKER_01 Но когда мы разговариваем с программистами, у которых кажется, что должно охватить ума, как бы запустить пару команд и посмотреть пару отчетов, то здесь, мне кажется, уже какая-то избыточная паранойя пошла.
2938.82 2942.66 SPEAKER_00 Ну, может быть, они что-то понимают о своих заказчиках?
2942.66 2946.74 SPEAKER_01 Ну, может быть, может быть, я в это искренне верю.
2946.74 2954.98 SPEAKER_01 В общем, хорошая тенденция на то, что мы начали об этом думать, начали каким-то образом ломать breaking changes, в общем, и будем надеяться, что мы дальше пойдем по этой дорожке.
2954.98 2970.78 SPEAKER_01 Я уверен, что мы сильно не углубимся, как бы не будет у нас разницы, как между питонами, но вот такие мелкие вещи, как классы вар с маленькой буквы, их надо истреблять, и под них не надо подстраиваться.
2970.78 2977.78 SPEAKER_00 Ну, будем надеяться, посмотрим, что будет, а у нас тем временем вышел релиз Visual Studio.
2977.78 2992.50 SPEAKER_01 Visual Studio версия 20.22.17.9, когда они уже нормальные версии начнут давать, а также вышел превью, соответственно, 17.10, и вот эти два экземпляра, два анонса мы сегодня с вами и рассмотрим.
2992.50 2999.50 SPEAKER_01 Прежде всего, конечно же, в каждом релизе выходит что-то про копайлот, GitHub-копайлот.
2999.50 3007.02 SPEAKER_01 Нужно напомнить, что для этого вам нужна отдельная платная подписка на GitHub-копайлот, иначе вы ничего этого не увидите.
3007.02 3033.18 SPEAKER_01 И прежде всего, Visual Studio уже в релизе научилась генерировать commit-месседжи, т.е. у вас есть какой-то нобор файлов, которые вы поменяли, и самое сложное – это, конечно же, не реализовать фичу, не протестировать ее, не написать на нее какой-то технический анализ, а самое сложное – это придумать commit-месседж к этой фиче, когда вы пытаетесь запустить ее вашим коллегам на pull-request или в Git-репозиторий, или куда-то туда.
3033.18 3041.98 SPEAKER_01 И вот теперь вам поможет кнопочка, которая запустит GitHub-копайлот и сгенерит вам, проанализирует все ваши изменения и сгенерит вам описание.
3041.98 3051.58 SPEAKER_01 Нужно сказать, что описание – это не просто какой-то однострочник, который у вас там будет появляться, это такой полноценный, блин, прямо вот статья, прямо анонс.
3051.58 3055.34 SPEAKER_01 Т.е. он реально под каждую фичу расписывает там чуть ли не по абзацу.
3055.34 3059.46 SPEAKER_01 Я не знаю, настраивается это где-то или не настраивается, но прямо это хороший документ получается.
3059.46 3060.46 SPEAKER_00 Так вот так вот нужно.
3060.46 3070.82 SPEAKER_00 Они может такое на этих самых перейдут, на своих анонсах превью, что закинул им набор коммитов, как вот в EF Core там сейчас, и все, и вот тебе готовая статья.
3070.82 3082.38 SPEAKER_01 Ну может быть, может быть, но там, мне кажется, нужно 10 уровней и потом еще самурайзеров вставить, строить, потому что если он там для трех файлов выдает абзацы текста, то у Микрософта этих файлов там тысячи летают.
3082.38 3086.26 SPEAKER_01 Поэтому нужен какой-то самурайзер очень умный, который все это способен объединить.
3086.26 3090.46 SPEAKER_00 И обратно сложить, а потом еще выделить основные тезисы для нас.
3090.46 3096.22 SPEAKER_01 Да, отдельно там для разработчиков, для маркетологов, для анонсеров, для конференций и так далее.
3096.22 3100.02 SPEAKER_00 Ладно, да, надо еще допиливать Микрософт, Капайлот, окей.
3100.02 3108.38 SPEAKER_01 Вот, еще поддержаны так называемые слэш-команды, это когда вы у Капайлота просите какие-то стандартные для программиста вещи.
3108.38 3115.78 SPEAKER_01 Ну, например, пофикси мне этот код, или напиши документацию к этому методу на основании его содержимого, или объясни вообще, что этот метод делает.
3115.78 3120.22 SPEAKER_01 В общем, есть маленькие команды, которые с помощью слэша вызываются очень быстро и удобно.
3120.22 3138.46 SPEAKER_01 Еще одна прикольная штучка – это инлайн-чат, это когда вам не нужно отвлекаться на какое-то левое окошко, вы прямо в коде пишите, у вас прямо в коде всплывает какое-то окошко, куда можно повзаимодействовать с Капайлотом, дать ему какие-то команды, попросить отрефакторить текущий код, где сейчас сидит курсор.
3138.46 3142.14 SPEAKER_01 В общем, это все сделать удобно и меньше отвлекаться.
3142.14 3148.42 SPEAKER_01 В общем, это кажется, что довольно полезная штука будет и продуктивность она должна хорошо улучшать.
3148.42 3149.42 SPEAKER_01 Про Visual Studio.
3149.42 3154.06 SPEAKER_01 Также у нас есть оптимизации и улучшения в Memory2Log.
3154.06 3166.10 SPEAKER_01 Прежде всего, это Event Handler Leak поисковик, т.е. у вас теперь в Memory Management вкладочке есть такая специальная опция – это найти все Event Handler Leaks.
3166.10 3174.02 SPEAKER_01 Это один из самых популярных ликов, которые существуют, т.е. утечек памяти, когда вы подписываетесь на какие-то события и забываете про них отписаться.
3174.02 3179.70 SPEAKER_01 Особенно, если мы говорим про UI-разработку на десктопах, винформах, DPF-ах и прочем.
3179.70 3181.46 SPEAKER_01 Там эта проблема очень актуальна.
3181.46 3189.10 SPEAKER_01 И также прорабатывается HotPath ToRoot, это показывается вам самые горячие точки для оптимизации.
3189.10 3204.98 SPEAKER_01 Т.е. если вы захотели прооптимизировать перформанс в вашей программе, то самое лучшее, что вы можете сделать, это посмотреть на вот этот HotPath, который вам посоветует, опять же Memory2Log, и попытаться его каким-то образом простимулировать, прооптимизировать.
3204.98 3209.50 SPEAKER_01 И это даст вам самый лучший прирост в вашей программе, который вы могли бы только придумать.
3209.50 3212.22 SPEAKER_01 Еще из нововведений.
3212.22 3217.78 SPEAKER_01 Сделали меньше модальных окошек, в частности теперь дебаггинг визуалайзеры не модальные.
3217.78 3226.10 SPEAKER_01 Это те окошки, которые вы можете, например, в дебаг в очаг открыть, для того, чтобы посмотреть более подробно какой-то объект или что-то еще.
3226.10 3232.40 SPEAKER_01 В общем, раньше каждое окошко можно было открыть только в одном экземпляре, оно полностью перекрывало абсолютно всю работу.
3232.40 3239.50 SPEAKER_01 Сейчас же их можно пооткрывать несколько штучек и в это же время продолжать редактировать код, что очень удобно.
3239.50 3242.46 SPEAKER_01 Сделана улучшая поддержка Multiproject Configuration.
3242.46 3253.46 SPEAKER_01 Это когда вы можете для запуска ваших нескольких проектов, то есть, допустим, у вас есть Solution, и в Solution есть несколько проектов, допустим, несколько микросервисов, которые друг с другом взаимодействуют.
3253.46 3260.30 SPEAKER_01 Вы можете настроить Visual Studio так, чтобы при нажатии F5 у вас поднималось сразу, запускалось сразу несколько этих проектов.
3260.30 3262.62 SPEAKER_01 И вы, естественно, оттачались к ним сразу.
3262.62 3266.74 SPEAKER_01 Это было, в принципе, всегда, насколько я помню, в Visual Studio.
3266.74 3275.42 SPEAKER_01 А вот теперь в новой версии вы можете сохранить вот эти способы запуска в определенный файлик, в определенный профиль.
3275.42 3276.42 SPEAKER_01 И эти профили менять.
3276.42 3286.86 SPEAKER_01 Ну, например, если у вас очень большой Solution, то у вас может быть профиль с сервисами для бухгалтерии, профиль с сервисами для продажников, профиль с сервисами для инфраструктурного обслуживания.
3286.86 3294.22 SPEAKER_01 И вот вы между ними можете переключаться и запускать не все сразу, а определенный набор запускабельных сервисов.
3294.22 3296.18 SPEAKER_01 Тоже вполне удобно.
3296.18 3303.38 SPEAKER_01 У Razor файлов появилась возможность делать мультитаргет фреймворк, поддержку мультитаргет фреймворков.
3303.38 3306.06 SPEAKER_01 То есть можно комбинировать их в мультитаргеты теперь.
3306.06 3314.06 SPEAKER_01 У Razor scaffold'ов вышла поддержка, соответственно, scaffold'инга для Entity Framework.
3314.06 3321.06 SPEAKER_01 То есть, например, вы можете сказать, у меня вот стандартная сущность есть, сгенерикаю для нее стандартные Blazor компоненты.
3321.06 3323.46 SPEAKER_01 И у вас магическим образом сгенерится UI'ка.
3323.46 3350.90 SPEAKER_01 В этой UI'ке может сгенерироваться табличка, в этой табличке будут стандартные крут-операции, которые за вас уже будут удалять все, апдейтить, читать и прочие такие стандартные мелочи, которые как бы помогают на примитивных операциях, когда вы какие-то справочники делаете, то одной кнопкой можно для справочников нагенерить и обвязку вокруг Entity Framework'а и обвязку вокруг Blazor'а, и контроллеры вам там еще сами сгенерятся и мапперы сами построятся.
3350.90 3364.54 SPEAKER_01 Здесь можно ответить, что данный scaffold'инг использует Static Server Site Rendering, который был недавно зарелизан, то есть все это делается довольно оптимально, красиво и с поддержкой современных технологий.
3364.54 3370.62 SPEAKER_01 Еще классная штука – это улучшенная поддержка экосистемы.
3370.62 3373.62 SPEAKER_01 Так, под этим мудрым заголовком подразумевается довольно примитивная вещь.
3373.62 3437.58 SPEAKER_01 Вот у вас очень часто бывает в компании такая штука как расширение к студии, и эти расширения вам нужны для какого-то конкретного проекта, ну может быть какие-то там ростлин анализаторы или какой-нибудь рисовальщик графиков, или какой-нибудь компилятор ресурсов, или оптимизатор картинок, или оптимизатор css файлов, в общем плагинов в Visual Studio очень много, и часто бывает так, что какой-то конкретный проект от этих плагинов грубо говоря зависит, то есть чтобы вам нормально собрать что-то, вам нужны эти плагины, и вот сделали такую поддержку, что если вы в специальный файлик, который называется VSConfig, добавите описание тех расширений, которые вам нужны для этого проекта, Visual Studio их поймет, то есть при загрузке вашего солюшена, она проанализирует файлик VSConfig, если она найдет там обязательные плагины для этого солюшена, она спросит человека, который создал этот солюшен, а не хочет ли он случайно установить эти плагины, установить эти экстеншены, и если он вдруг случайно захочет, то она их пойдет и установит.
3437.58 3456.10 SPEAKER_01 Это все особенно прекрасно в рамках того, что VSConfig это отдельный файлик, то есть по сути вы его можете зачекинить в репозиторий, выложить в какую-то шару, распространять между членами команды и так далее и тому подобное, то есть это обычный файлик, и распространяется довольно легко.
3456.10 3465.98 SPEAKER_01 И нужно признать, что это была одна из самых запрашиваемых фич для студии, которая только была там в голосовалке.
3465.98 3481.42 SPEAKER_01 И эта фича в принципе сейчас уже есть в какой-то превью-версии, но она все еще находится под активной разработкой, поэтому если вдруг что-то не сработает, не судите строго, но я думаю тем, кому это было нужно, те уже могут смело пробовать.
3481.42 3494.02 SPEAKER_01 Такие нововведения у нас есть в Visual Studio, в принципе она старается не отставать от основного фреймворка, а если судить по чинь-жам, то даже сильно его перегоняет, потому что фреймворк что-то, вообще она запаздывает.
3494.02 3495.02 SPEAKER_01 Поэтому студия молодец.
3495.02 3501.70 SPEAKER_00 Да, я как раз хотел сказать, что прям в студии гораздо больше чинь-жам в превью, чем в основном фреймворке.
3501.70 3526.70 SPEAKER_00 Ну да ладно, с другой стороны, мне кажется, что, опять же, студия много чего копит по всяким разным своим превьюшкам, зато к релизу выпускает красивые статьи про то, что ах, как вы много всего сделали, поэтому приятно видеть, что инструмент развивается, мне действительно интересно, сколько лет они еще будут держать название 2022, и главное, зачем тогда держать это Visual Studio 2022, пусть оно будет просто 17.9.
3526.70 3531.70 SPEAKER_01 А никакого ishu на гитхабе нету, ну то есть должен был народ поинтересоваться таким же вопросом?
3531.70 3538.26 SPEAKER_00 Нет, студия же не на гитхабе живет никак, это полностью closed source, у нее, по-моему, даже никакого репозитория типа там с ishu за меня нету.
3538.26 3539.46 SPEAKER_01 И трекера ничего такого, да?
3539.46 3540.46 SPEAKER_00 Нет, нету.
3540.46 3542.06 SPEAKER_00 User Voice, помнишь такой?
3542.06 3549.82 SPEAKER_01 Ну да, User Voice помню, но именно вот там эти фичи все и были, ну надо в User Voice завести, типа, чуваки, вы забыли заинкрементировать на 2 года версию.
3549.82 3564.46 SPEAKER_00 Ну зачем, нет, ну возможно они будут инкрементировать только в том случае, если там будет какой-то мажорный, не знаю, перепишут на что-нибудь, плюс платформеры сделают, окей, ладно, вы не инкрементируете мажорный, но уберите, ну не знаю, короче, не знаю, 2022 как-то, уже 24-й год, странно.
3564.46 3573.26 SPEAKER_01 Ну да, ну то же самое, 17.9, 17.10 у них есть, они могут просто это убрать, использовать цифру 17 вместо года, зачем тащить, непонятно.
3573.26 3576.50 SPEAKER_00 И вообще 17. убрать и просто вижу услуги, 9, 10.
3576.50 3577.50 SPEAKER_01 Да?
3577.50 3583.14 SPEAKER_01 Ну вот как C# там делает, у них уже, 12-й C#, 11-й C#, вполне рабочие.
3583.14 3587.22 SPEAKER_00 Там много, номеров можно долго, какая-то я первая была, 2003, да?
3587.22 3588.22 SPEAKER_00 А, нет, 98, нет.
3588.22 3594.02 SPEAKER_01 Что-то мне кажется, что я 5-й, или я там не с виду работаю.
3594.02 3600.26 SPEAKER_00 Нет, 5.0, 6.0 были, а потом была, по-моему, сразу 2000, вижу в студию.net, 2002, наверное, или 2003, какая-то такая она
3600.26 3601.26 SPEAKER_01 была.
3601.26 3605.50 SPEAKER_01 Так, не пались, а то ты выдаёшь нас, торпёров, давай, и нас там хипстеры тоже должны их слушать.
3605.50 3611.30 SPEAKER_00 Вот, и, короче, до 2000-х ещё столько релизов можно сделать, короче, нормально, чисел хватит.
3611.30 3612.30 SPEAKER_00 Да-да, прокатит.
3612.30 3613.30 SPEAKER_00 На всех.
3613.30 3616.42 SPEAKER_00 Если что, потом пропустим, там всё уже забыло, почему 2000.
3616.42 3620.18 SPEAKER_00 Короче, к тому моменту можно уже и 2000 называть, все уже не будут знать, что это такое.
3620.18 3622.06 SPEAKER_00 Давай дальше, дальше у нас Andrew Locke.
3622.06 3628.14 SPEAKER_01 Да, давай что-нибудь более лёгенькое такое, что-то про новинки, про хардкоры, про оптимизации.
3628.14 3637.34 SPEAKER_01 Andrew Locke решил задаться непростым вопросом, а каким образом вы можете изменить урл, по которому ваш кестрил слушает все входящие запросы?
3637.34 3645.38 SPEAKER_01 Ну, для того, чтобы ISP.NET обрабатывал все запросы и отсылал контроллер, он должен их где-то слушать, на каком-то порту, на каком-то хосту, по какому-то протоколу.
3645.38 3650.02 SPEAKER_01 И вот какие способы есть для того, чтобы изменить этот хост?
3650.02 3657.46 SPEAKER_00 Погоди, погоди, погоди, мы такую статью точно обозревали года три назад, давно, короче, где-то благодаря подкасту.
3657.46 3664.82 SPEAKER_01 У Andrew Locke есть такая интересная хобби, он эту статью пишет в каждой новой версии .NET, потому что он находит новые способы запуска.
3664.82 3669.06 SPEAKER_01 И поэтому он не мог себя удержать и выпустил последнюю версию все-таки.
3669.06 3672.66 SPEAKER_01 Как теперь, вот на данный момент это можно и нужно задавать?
3672.66 3673.66 SPEAKER_01 Ну, давай посмотрим.
3673.66 3676.10 SPEAKER_01 Быстренько пробежимся.
3676.10 3685.46 SPEAKER_01 Итак, по дефолту, если вы ничего не настраиваете, просто поставили себе ISP.NET, завели контроллер, нажали F5, то ваше приложение запустится на Localhost 5000.
3685.46 3689.78 SPEAKER_01 Это стандартный порт, который, в принципе, ничем не плох, ничем не хорош.
3689.78 3690.78 SPEAKER_01 Это нормальный дефолт.
3690.78 3697.58 SPEAKER_01 Вы можете поменять это значение, вы можете поменять его, например, изменить порт или указать конкретный IP-адрес.
3697.58 3712.46 SPEAKER_01 Нужно понимать, что если на вашем компьютере установлено несколько сетевых карт или настроено несколько network протоколов, или настроено просто несколько IP-адресов, то вы, может быть, не хотите, чтобы ваш сервис слушал на каждом из них.
3712.46 3717.98 SPEAKER_01 Ну, например, один IP-адрес у вас может уходить в интернет, а другой адрес может уходить в локальную сеть.
3717.98 3722.86 SPEAKER_01 И вы хотите свой веб-сервер настроить только для локальной сети.
3722.86 3727.26 SPEAKER_01 В этом случае вам нужно прибаниться только к IP-адресу локальной сети.
3727.26 3740.42 SPEAKER_01 Ежели вы просто укажете Localhost или там какую-нибудь звездочку, то ISP прибанится ко всем адресам, то есть он будет доступен с любой сети, хоть с интернета, хоть с локальной, хоть с любой другой, к которой к нему можно обратиться.
3740.42 3742.02 SPEAKER_01 И тут немножко поаккуратнее.
3742.02 3745.90 SPEAKER_01 И по дефолту он как раз-таки слушает Localhost 5000.
3745.90 3751.10 SPEAKER_01 Вы можете указать один конкретный адрес, вы можете указать несколько адресов, разделяя их разделителем.
3751.10 3757.78 SPEAKER_01 Опять же, это невозбранно, или можете сказать, что слушай вообще все адреса, которые найдешь на моем локальном хосте.
3757.78 3760.18 SPEAKER_01 Как же теперь их можно поменять?
3760.18 3771.98 SPEAKER_01 Ну, наверное, самое очевидное, хотя, может быть, и не самое очевидное, это использовать специальный метод расширения для веб-аппликейшн-билдера, который называется UseUrls.
3771.98 3786.14 SPEAKER_01 То есть в нашем программ.cs файле мы создаем веб-аппликейшн-билдер, это, наверное, одна из тех строчек, которые все еще не убрали, которые все еще нам доступны, и у этого билдера у нас есть куча свойств для настройки нашего будущего сервиса.
3786.14 3794.26 SPEAKER_01 В частности, есть .webhost.useurls, и туда вы в качестве строки можете передать вот этот URL, по которому вам нужно слушать.
3794.26 3813.18 SPEAKER_01 Другое интересное нововведение, нововведение его ввели в шестом дотнете, почему его раньше не было, никто не знал, и, наверное, все очень сильно хотели, это заключается в том, что вы можете этот URL настроить не только у билдера, но и непосредственно в своем уже конкретном аппликейшне.
3813.18 3822.78 SPEAKER_01 То есть вы билдер позадавали, вызвали метод билд, вам вернулся аппликейшн, и у этого аппликейшна вам все еще есть возможность настроить URL для прослушивания.
3822.78 3829.54 SPEAKER_01 У аппликейшна есть свойство, которое называется .urls, и к нему можно добавить такой же точно URL.
3829.54 3855.90 SPEAKER_01 За сценой этот urls, это свойство, на самом деле ходит к сервер-фичам, то есть это специальный такой классик, который хранит все возможные свойства, которыми обладает текущий сервер, и вытаскивает оттуда специальный сервис, который называется iservice-address-feature, то есть фича, которая поддерживает оповещения, даже не оповещения, поддерживает коллекцию всех сервисных адресов, которые нужно послушать.
3855.90 3861.70 SPEAKER_01 И вот в этот сервис-адрес-фичу оно записывает новый адрес, который вы добавили.
3861.70 3865.34 SPEAKER_01 На самом деле к этой фиче обращается очень много методов.
3865.34 3884.74 SPEAKER_01 В частности, вы, например, можете вызвать app-run, то есть запустить ваш аппликейшн, и в ране есть перегрузка, которая точно так же принимает URL, по которому нужно послушать, по которому нужно запустить кестрил, и этот URL, который принимает в ране, делает абсолютно то же самое.
3884.74 3891.06 SPEAKER_01 Он берет сервис-адрес-фичу и просто-напросто да, этот URL записывает, а эту фичу уже потом потребляет кестрил.
3891.06 3895.08 SPEAKER_01 В общем, поэтому есть несколько endpoint, которые под капотом используют одно и то же.
3895.08 3897.66 SPEAKER_01 В общем, мы их рассматривать не будем, будем считать, что это одно и то же.
3897.66 3898.66 SPEAKER_01 Дальше.
3898.66 3909.58 SPEAKER_01 Для того, чтобы настроить еще этот URL, вы, возможно, захотите воспользоваться стандартным интерфейсом опций, который пришел к нам в ASP.NET и также во весь .NET.
3909.58 3918.78 SPEAKER_01 Опции позволяют вам комбинировать и загружать настройки, конфигурацию из нескольких источников, из нескольких провайдеров опций.
3918.78 3935.38 SPEAKER_01 По умолчанию, Configuration Manager использует в качестве источника для своих настроек Upsettings JSON-файл, а также Upsettings с Environment JSON-файл, то есть, когда вы хотите отдельно для Production, отдельно для Development, отдельно для стейджинга сделать файлики.
3935.38 3938.42 SPEAKER_01 Это тоже в стандартную поставку, в стандартный комплект входит.
3938.42 3947.46 SPEAKER_01 Также он загружает секреты, после этого Environment Variables и в последнюю очередь Command-Line-аргументы, которые перебивают абсолютно все, что было вышесказано.
3947.46 3956.14 SPEAKER_01 В общем, из вот этой всей шарманки, из вот этой всей каши он, соответственно, может вам сгенерить конечные настройки.
3956.14 3961.62 SPEAKER_01 И в любом из этих провайдеров, если он найдет настройку URL, он ее, естественно, затащит.
3961.62 3967.66 SPEAKER_01 Настройка URL может быть с помощью определенного названия, определенного ключа.
3967.66 3972.02 SPEAKER_01 Ключ может называться URLs, может называться ISPnetCoreURLs или .NETURLS.
3972.02 3983.10 SPEAKER_01 А ISPnetCore и .NET по умолчанию отрезаются, как только вы загружаете все ваши конфигурации через Configuration Manager, поэтому они сводятся все все едино к URLs.
3983.10 3996.58 SPEAKER_01 Поэтому очень легко, если вы хотите, допустим, настраивать через переменное окружение, ваш URL, по которому запускается сервачок, вы можете просто выставить переменное средоокружение и после этого запустить приложение.
3996.58 4000.84 SPEAKER_01 И по умолчанию он подхватит переменную, если она названа правильно.
4000.84 4010.40 SPEAKER_01 Дальше, если мы начнем задумываться, что наш сервис принимает в качестве того, что он будет слушать, он принимает URL.
4010.40 4014.42 SPEAKER_01 На самом деле он использует из этого URL не полное подмножество.
4014.42 4023.06 SPEAKER_01 Он может использовать протокол, он может использовать порт, а вот название хоста в этом URL у него довольно ограниченное.
4023.06 4027.18 SPEAKER_01 То есть вы не можете сказать, что я хочу свой сервис запустить на URL Яндекс.Ру, допустим.
4027.18 4031.18 SPEAKER_01 Ну потому что прибавиться к этому интерфейсу вы не сможете.
4031.18 4033.90 SPEAKER_01 Вы сможете прибавиться только то, что у вас есть на локальном хосте.
4033.90 4045.26 SPEAKER_01 И вот чтобы такой диссонанс убрать, недавно было введено новые переменные, новые настройки, которые называются HTTP Port и HTTPS Port.
4045.26 4054.82 SPEAKER_01 То есть вы можете менять, по сути, только порты, но и при изменении этих портов ваш сервер будет слушать на любом IP-адресе.
4054.82 4059.90 SPEAKER_01 То есть он, по сути, прибавится ко всем IP-адресам, и вы будете настраивать только порты.
4059.90 4064.22 SPEAKER_01 Вы можете настроить несколько портиков точно так же, как и с несколькими адресами.
4064.22 4073.58 SPEAKER_01 И начиная с .NET 8, у вас есть переменная SPNet Core HTTP Ports, которую вы можете настраивать.
4073.58 4088.26 SPEAKER_01 Здесь еще нужно сказать, что начиная с .NET 8, по умолчанию во всех официальных .NET Docker images, в Docker images используется эта переменная, и она проставлена в значение 8080.
4088.26 4098.50 SPEAKER_01 Это еще связано с rootless контейнерами, чтобы мы там не бандились на адресах, которые меньше какого-то определенного системного пользователя и так далее.
4098.50 4108.26 SPEAKER_01 В общем, вот эта переменная пригодилась, и каждый из вас, кто использует докер-контейнеры для запуска вашего .NET-приложения, там явно или не явно, эту переменную подкомпотом юзают.
4108.26 4115.54 SPEAKER_01 Еще один способ, как переписать адреса – это, естественно, командная строка.
4115.54 4119.82 SPEAKER_01 Наверное, опять же, тоже, может быть, не для всех очевидный способ.
4119.82 4134.32 SPEAKER_01 Вы можете запустить ваше приложение и в качестве параметра указать --urls, и в этом значении после этого urls-ключа вы можете передать список тех адресов, которые теперь нужно слушать.
4134.32 4136.66 SPEAKER_01 Еще одно место – это upsettings.json.
4136.66 4149.26 SPEAKER_01 В upsettings.json вы прямо в самом ротовом элементе можете указать свойства, которые называются urls, можете указать свойства, которые называются http_ports, которые было выше упомянуто, и оба они потянутся без всяких проблем.
4149.26 4155.50 SPEAKER_01 Дальше у нас есть еще один JSON-файл, который не так очевиден.
4155.50 4156.98 SPEAKER_01 Это launch_settings.json.
4156.98 4161.26 SPEAKER_01 Это специальный файл, который находится в папочке properties.
4161.26 4171.54 SPEAKER_01 И его использует в основном Visual Studio для того, чтобы предоставить вам очень удобный drop-down-лист с профилями запуска.
4171.54 4180.54 SPEAKER_01 Допустим, ваше приложение может быть запущено под IS-экспресса, может быть запущено в виде EXE, может быть запущено под или развернуто под настоящий IS.
4180.54 4184.10 SPEAKER_01 В общем, есть различные профили запуска вашего приложения.
4184.10 4188.26 SPEAKER_01 И вот эти профили запуска, они как раз-таки все и описываются в launch_settings.json, очень полезный файлик.
4188.26 4202.74 SPEAKER_01 И у этого launch_settings.json есть свойство, которое называется application_url, которое вы точно так же можете настроить и которое точно так же скажет, на каком адресе ваше приложение должно слушать входящие запросы.
4202.74 4208.50 SPEAKER_01 Также в launch_settings.json очень удобно настраивать переменное окружение.
4208.50 4230.90 SPEAKER_01 Допустим, если вы хотите, чтобы загружать ваше приложение под какими-нибудь разработческими настройками, с разработческими environment variables или с какими-нибудь тестовыми настройками, переменными среды окружения, вы можете просто запустить два профиля, у каждого из профилей обозначить свои переменные окружения, и в Visual Studio очень удобно переключаться между этими профилями.
4230.90 4233.98 SPEAKER_01 В общем, полезный файлик, про него тоже полезно знать.
4233.98 4246.46 SPEAKER_01 Ну и самый последний, самый хардкорный, самый низкоуровневый, самый оптимизируемый способ – это указать Кестрилу напрямую, откуда ему брать этот адрес.
4246.46 4248.50 SPEAKER_01 То есть вы можете сконфигурировать Кестрил.
4248.50 4252.58 SPEAKER_01 В обычной жизни вам этим, скорее всего, не приходится заниматься, но в этом нет ничего сложного.
4252.58 4260.86 SPEAKER_01 У вышеупомянутого билдера есть свойство webhost и у этого свойства есть метод, который называется ConfigureCastKestril.
4260.86 4280.30 SPEAKER_01 Это свойство принимает Kestril Server Options в качестве аргумента, и у этих опционов есть метод Listen, который принимает кучу аргументов, у него есть куча перегрузок и в частности он может вам получить конкретный адрес, получить конкретный порт и прибандить Кестрил именно туда.
4280.30 4297.62 SPEAKER_01 У этих опций очень много возможностей, там сертификаты туда можно подставлять, какие-нибудь буферы кестриловские, оптимизировать какие-нибудь свои собственные протоколы проставлять вместо TCP/IP, в общем, там черт ногу сломит, но в частности, портики и адреса туда тоже можно записывать.
4297.62 4312.70 SPEAKER_01 Вот такой набор свойств, у каждого из них есть какие-то плюсы и какие-то минусы, у каждого можно захардкодить, каждый можно динамически в рандайме выяснить, какой и какие можно в файлах прописать, наверное, какой ближе к вам, какой ближе к вашей ситуации, такой и стоит использовать.
4312.70 4316.14 SPEAKER_00 Мне приятно, что видите такое разнообразие, действительно.
4316.14 4327.34 SPEAKER_00 Не уверен, что я наизусть, например, помню все их, но обычно просто это либо через параметр командной строки, либо через переменное окружение недостаточно, но удобно, что только всего есть.
4327.34 4360.42 SPEAKER_01 Ну, вот приятная штука, знаешь, что есть еще специальная опция, когда ты можешь поднять свой сервис и настроить прослушивание на любом рандомном порту, на любом свободном открытом, потому что ты не можешь сто процентов гарантировать, что у тебя порт 8080 абсолютно везде настроен, абсолютно везде открыт, и у тебя есть право вообще к нему бандиться, поэтому можно на любом рандомном, например, открывать, на любом рандомном открытом, опять же, открывать и гарантировать тем, что, допустим, твои интеграционные тесты всегда найдут себе свободный порт.
4360.42 4370.34 SPEAKER_01 Ну, в этом случае у тебя, Павел, получается проблема, что как только ты открываешь, грубо говоря, на рандомном портике, ты не знаешь, а на каком портике запустился твое приложение и куда клиенты должны обращаться.
4370.34 4381.98 SPEAKER_01 И вот там, например, есть, можно, опять же, взять сервер фикчу, у нее спросить, где ты слушаешь, но она не всегда есть, например, когда ты хотишься пдисом, ее у тебя нет.
4381.98 4396.46 SPEAKER_01 И вот там уже другие способы работают, например, динамически самому найти свободный порт, динамически его указать уже через конфигурацию, допустим, того же самого кестрала или аппликейшн билдера, и то есть на момент старта программы его, несмотря на то, что он рандомный, его уже знать.
4396.46 4398.66 SPEAKER_01 И когда ты его знаешь, ты уже можешь его куда-то запаблишить.
4398.66 4405.78 SPEAKER_01 В общем, случаи получаются всякие, и как бы на момент запуска самого экзешника, может быть, тебе порт и неизвестен будет.
4405.78 4422.02 SPEAKER_00 Ну, а еще можно, мы, по-моему, один раз такое делали, я не помню, пушится ли он по дефолту, или мы добавляли это сами, запушить его как метрику наружу, сочетать эту метрику и таким образом узнать, ну, типа, метрики есть.
4422.02 4423.02 SPEAKER_01 Ну, это такой очень экзотический способ.
4423.02 4424.02 SPEAKER_01 Как метрика.
4424.02 4425.02 SPEAKER_01 Да, метрика, это сильно.
4425.02 4426.02 SPEAKER_01 Ну, число же число.
4426.02 4427.02 SPEAKER_01 У тебя она всегда будет одинаковая.
4427.02 4428.02 SPEAKER_01 Да?
4428.02 4429.02 SPEAKER_01 Ну, а что такого?
4429.02 4430.02 SPEAKER_00 Действительно, действительно.
4430.02 4432.26 SPEAKER_00 Почему бы и нет?
4432.26 4434.26 SPEAKER_00 Ладно, давай пойдем дальше.
4434.26 4444.10 SPEAKER_00 А дальше у нас, ну, как, тема, мне кажется, последних трех, больше выпусков, это «Дональд Эспаир».
4444.10 4451.10 SPEAKER_01 Если еще считать анонсы, мы там про него начали говорить, да, потом в декабре там что-то тоже было, и тут в январе полностью выпуск про него был.
4451.10 4453.50 SPEAKER_00 Ну, в общем, да, популярный чувак, знаешь.
4453.50 4454.50 SPEAKER_00 Короче, «Эспаир».
4454.50 4455.50 SPEAKER_00 «Дональд Эспаир превью-3».
4455.50 4457.38 SPEAKER_00 Что в нем поменялось?
4457.38 4459.66 SPEAKER_00 В нем поменялось довольно много всего.
4459.66 4462.86 SPEAKER_00 Во-первых, напомню, что что такое вообще в принципе «Эспаир».
4462.86 4479.54 SPEAKER_00 Да, «Эспаир» - это некоторый такой opinionated stack, библиотека набор компонентов от Microsoft, который позволяет вам удобнее разрабатывать локальное приложение, локально разрабатывать клауд-приложение, да, то есть микросервисы, грубо говоря.
4479.54 4483.54 SPEAKER_00 И потом их чуть более удобно деплойть, дальше уже куда вы их там деплойте.
4483.54 4486.86 SPEAKER_00 И концептуально он состоит из нескольких частей.
4486.86 4487.86 SPEAKER_00 Одна из частей - это дэшборд.
4487.86 4498.14 SPEAKER_00 Дэшборд - это, пожалуй, главное, что обновилось в превью-3, потому что они много чего в нем отрефакторили, много чего в нем переделали и в итоге вытащили его в абсолютно отдельный тул.
4498.14 4500.90 SPEAKER_00 Что позволяет дэшборд делать?
4500.90 4507.06 SPEAKER_00 Дэшборд позволяет вам смотреть, что же у вас запущено, какие там контейнеры, процессы, приложения и так далее.
4507.06 4510.46 SPEAKER_00 Позволяет смотреть логи, позволяет смотреть метрики, позволяет смотреть трейсы.
4510.46 4528.38 SPEAKER_00 Короче, красиво делать практически полное обзервабилити, если не сказать полной обзервабилити вашего приложения, причем все это локально и в виде одного как бы, по сути одного проектика, одного как бы тула, а не трех-четырех контейнеров, которые должны работать там вместе.
4528.38 4529.82 SPEAKER_00 Графана, Прометеус и все остальное.
4529.82 4541.02 SPEAKER_01 А скажи, вот этот дэшборд, он как запускается, отдельный контейнер или я могу его в end-process со своим приложением запустить, если мне не нужны контейнеры, у меня есть один всего-навсего экзешничек и я хочу его тогда встроить?
4541.02 4545.54 SPEAKER_00 Пока вроде как в экзешничек я не видел, чтобы встраивали.
4545.54 4564.30 SPEAKER_00 Пока вроде как отдельно, но поскольку это первый превью, в котором это вышло, ну в смысле превью третий, но это первый раз, когда они такое сделали, то сейчас начались эксперименты, в комьюнити видно по всяким разным твитам и прочему, что прикольно, работает, так что посмотрим, может и в end-process занесут как-нибудь.
4564.30 4573.94 SPEAKER_01 Ну да, мне кажется, для таких небольших приложений, которые состоят из одного экзешника, которые может быть даже не очень контейнеры используют, тоже был бы последний дэшборд, такой эмбарик, если его сделают.
4573.94 4577.90 SPEAKER_00 Да, сейчас пока это просто, как они пишут, это independent executable.
4577.90 4578.90 SPEAKER_00 Ну, посмотрим.
4578.90 4603.50 SPEAKER_00 Много чего поменяли в дэшборде на тему локализации и аксессибилити, улучшили ресурс детейлс, более красиво, чтобы все показывалось, добавили улучшений в телеметрию, какие-то гистограммы, метрик, спаны, венты, короче, много чего такого, пользуйтесь, посмотрите, будет выглядеть лучше.
4603.50 4604.50 SPEAKER_00 По компонентам.
4604.50 4632.10 SPEAKER_00 Это вторая большая часть Aspire, это компоненты, которые позволяют легко добавить в ваш продукт некоторую стандартную функциональность, тоже хорошо сконфигурированную, то есть, например, добавить хорошо сконфигурированное что-то по эклиен, со всякими поли, ну короче, ретраями, резилиенсом, вот этим всем, или там добавить стандартные настройки для RADIS, или еще для чего-нибудь.
4632.10 4640.42 SPEAKER_00 Добилось несколько новых компонентов, во-первых, ну куда же без Azure AI Open AI Component, никуда не делась.
4640.42 4670.22 SPEAKER_00 Второй компонент это Kafka, причем не только, как это сказать, не только подключает возможность коннекта Kafka в ваше приложение, но если вам нужно для локальной отладки, вы теперь можете в Aspire конфигурации в C# написать что-нибудь типа with Kafka, я не помню как там, пишется точно, и у вас будет локально подниматься преконфигурированная Kafka для вашей локальной разработки.
4670.22 4683.54 SPEAKER_00 Ну, то есть, понятно, что это просто поднимается контейнер с Kafka, но вот теперь достаточно просто написать в одном месте C# кода with Kafka и все, у вас есть готовый сервер Kafka, когда у вас приложение работает.
4683.54 4712.70 SPEAKER_00 Дальше, соответственно, появились интеграции для работы через Entity Framework с Oracle и с MySQL, можно теперь сделать с Cosmos DB то же самое, как я только что говорил, с Kafka, то есть при необходимости, у Cosmos DB есть локальный эмулятор, вы можете поднять, не обязательно ходить в Azure для этого, можно поднять локальную копию Cosmos DB, точнее локальную базу данных, которая эмулирует поведение Cosmos DB, вот теперь есть компонент, который позволяет это легко сделать.
4712.70 4785.18 SPEAKER_00 В Redis завезли логирование, точнее не в сам Redis, а в библиотеку доступа от Second Exchange, завезли логирование, и поскольку все это еще в превью, то у нас есть ряд breaking-чинджей, ну например поменяли API, то, что раньше называлось withServiceBinding, теперь называется withEntryPoint, если вы обновляете на третью превью, у вас перестает все собираться, потому что поменялись названия методов, такой нормальный breaking-чиндж, ну превью, что вы хотели, зато для контейнеров теперь можно указывать специальную функцию withEntryPoint и таким образом просто прямо указывать, что запустить внутри контейнера, когда он поднимется, дальше из полезняшек таких добавилось, например у вас была компонента Postgres, она позволяла настроить вам ConnectedPostgres, прокидывала там всякие connection-стринги к базе, вот это все, теперь туда можно еще дописать метод расширения withPgoadmin, после чего у вас поднимется дополнительный контейнер с Pgoadmin рядышком, и такая же штука для Redis Commander, это веб-менеджмент для Redis, короче они делали максимально удобно, максимально односрочно, так скажем, дефолтные конфигурации для самых популярных тулов.
4785.18 4876.98 SPEAKER_00 Внезапно в DotNet Espire Preview 3 добавили поддержку орлинсов, вот уж чего-чего, не думал, что так быстро сделают, но видимо кому-то надо было, очень надо, поэтому добавили, и добавили три новых проекта, примеров проектов, прямо в репозитории DotNet Espire лежит, три новых проекта, во-первых, называется Espire with JavaScript, это проект, который показывает как работать с Espire, если у вас есть DotNet Espire Application плюс дополнительно еще Node.js приложение зачем-то, плюс какой-нибудь SPA frontend типа Angular, React или Vue, как это все вместе сдружить и все это работает в Espire, дальше есть проект под названием ClientAppsIntegration, которое показывает как подружить DotNet Espire с WinForm или WPF и собирать с них аналогии, трейдсы и все такое, ну и последний проект это PersistentVolumeMount, это проблематика следующая, Espire вот этот вот дэшборд и сервер, который собирает все менеджеры, логи и так далее, он все это делает в памяти, т.е. как только вы говорите закончить там отладку или еще что-нибудь, хост DotNet Espire, дэшборда опускается и он теряет все, что у него было, т.е. если вам после этого захочется посмотреть логи прошлого запуска, вы уже не сможете, но есть возможность подключить нормальную базу данных либо файловую систему для того, чтобы хранить все по-человечески, вот этот пример показывает как это сделать.
4876.98 4904.14 SPEAKER_00 Ну и последнее изменение для превью 3, это добавили два новых шаблончика, т.е. до превью 3, что вы могли сделать, вы могли создать новый проект с поддержкой Espire, а вот если вам нужно было добавить поддержку Espire к существующему проекту, то вам откуда-то нужно было взять вот эти два шаблонных проекта, UpHost и ServiceDefault, в которых собственно и описывается вся инфраструктура и настройки.
4904.14 4919.18 SPEAKER_00 Вот теперь есть два шаблончика, которые позволяют в уже готовом солюшене написать DotNet New Espire UpHost или DotNet New Espire ServiceDefault и вам к существующему солюшену добавится два вот этих вот новых нужных для работы Espire проекта, т.е.
4919.18 4922.42 SPEAKER_00 ServiceDefault не то чтобы сильно нужен, но по крайней мере обычно есть.
4922.42 4935.66 SPEAKER_00 Вот такие дела, Espire живет, развивается, смотрим что будет дальше с Dashboard, насколько комьюнити его полюбит, примет и будет использовать, может быть даже отдельно от DotNet будем посмотреть.
4935.66 4936.66 SPEAKER_01 Пока не видел.
4936.66 4960.82 SPEAKER_01 Слушай, а нету ли примеров с тестами, потому что интересная тема, у нас же есть отдельный контейнер тестов, грубо говоря, а здесь кажется, что эта штука примерно их покрывает, потому что если мы под разработческим окружением можем одной кнопкой запустить все наши кавки, как ты сказал, Orleans, то мы наверняка же захотим это делать и в интеграционных тестах, вот нет ли каких-то примеров, как она дружит с интеграционными тестами?
4960.82 4965.30 SPEAKER_00 Пока я не видел, пока это чисто девелоперский тулинг из того, что я видел.
4965.30 4975.46 SPEAKER_01 Ну, то есть, понимаешь, у нас теперь будет как бы мы эту кавку и Orleans будем настраивать в девелоперском тулинге, а потом то же самое будем идти и делать в тест-контейнерах.
4975.46 4976.82 SPEAKER_01 Звучит как довольно странно.
4976.82 4986.34 SPEAKER_00 Я согласен, и скорее всего надо внимательно почитать репозитории Espire, может быть там что-то про это есть, я просто настолько внимательно и не изучал их в части.
4986.34 5000.50 SPEAKER_00 Можно посмотреть к следующему разу, если что-то нароется, я периодически туда заглядываю, ради того, чтобы понять, есть ли что-то новенькое, а может и превью какую-нибудь выпустят в следующем выпуску, или когда выпустят следующий превью, я постараюсь не забыть посмотреть на эту тему.
5000.50 5001.50 SPEAKER_01 Давай.
5001.50 5003.50 SPEAKER_01 Не дадим вам отдохнуть от Espire ни одного выпуска,
5003.50 5004.50 SPEAKER_00 да?
5004.50 5008.02 SPEAKER_00 Ну, я надеюсь, что они не успеют за 2 недели выпустить следующий превью.
5008.02 5015.10 SPEAKER_01 Ладно, погнали, времени осталось мало, а тут еще пару интересных статей, которые хотелось бы вбросить.
5015.10 5021.78 SPEAKER_01 Марк Симон, давно мы не обращались к нашему гуру, хотелось бы повысить градус гиковости.
5021.78 5029.38 SPEAKER_01 Давайте посмотрим, у него есть хорошая статья вышла, которая называется «Категории ошибок и ошибки категорий».
5029.38 5041.78 SPEAKER_01 Казалось бы, да, что сейчас мы снова про категории, но нет, здесь все довольно более приземисто, здесь автор рассуждает о том, на какие типы и виды он делает где-то ошибки, каким образом он их обрабатывает и как к этому вопросу подходит.
5041.78 5058.58 SPEAKER_01 Вообще вопрос обработки ошибок, он очень нетривиальный, несмотря на его очевидность и, казалось бы, продуманность уже не одно десятилетие, многие языки все еще перезабретают какие-то подходы к ошибкам, как их обрабатывать, что надо обрабатывать, что не надо обрабатывать и прочие-прочие эти вещи.
5058.58 5065.38 SPEAKER_01 Поэтому тема глобальная, тема большая, ну, так поверхностно немножко про ней пошелся Марк.
5065.38 5071.42 SPEAKER_01 Прежде всего нужно осознать, что в любом программном приложении есть ошибки или будут ошибки.
5071.42 5086.10 SPEAKER_01 Вы никогда не будете застрахованы от всего, начинать можно с обычного user input, если у вас есть user input, то пользователь вам может ввести невалидные данные, которые ваше приложение не способно, не хочет и не будет обрабатывать.
5086.10 5119.10 SPEAKER_01 К вам могут попасть какие-то поврежденные данные, какие-то поврежденные конфиги, которые у вас уже есть, у вас может случиться проблема с сетью, у вас может быть наведенка от рентгеновских лучей, у вас может быть какие-то параллельные вычисления, которые дадут вам risk condition или concurrent exception или еще что-то, ну и в крайнем случае в вашем коде всегда могут быть баги, то есть мы разрабатываем все наши приложения всегда оперируя тем, что вокруг нас есть ошибки того или иного уровня сложности, критичности и так далее.
5119.10 5120.10 SPEAKER_01 Это уже не суть важно.
5120.10 5125.94 SPEAKER_01 Важно то, что наше приложение не всегда работает так, как мы это задумывали в идеальном success path.
5125.94 5132.42 SPEAKER_01 И по версии Марка ошибки можно разделить на начальном этапе на три категории.
5132.42 5145.82 SPEAKER_01 Во-первых, это предсказуемые ошибки, которые мы можем обработать, предсказуемые ошибки, которые мы не можем обработать и, соответственно, непредсказуемые ошибки, которые мы не можем никак предсказать.
5145.82 5147.22 SPEAKER_01 Давайте рассмотрим их поподробнее.
5147.22 5152.58 SPEAKER_01 Ну прежде всего большинство ошибок, которые есть в наших приложениях, мы вполне способны предсказать.
5152.58 5156.54 SPEAKER_01 Например, к ним относится уже вышеупомянутый ввод пользователя.
5156.54 5165.30 SPEAKER_01 Когда пользователь вводит какие-то данные в ваше приложение, вы на сто процентов можете быть уверены, что рано или поздно он в этих данных ошибется.
5165.30 5169.34 SPEAKER_01 Поэтому там существует стандартный процесс валидации пользовательских данных.
5169.34 5171.06 SPEAKER_01 В общем, от этого вы никуда не денетесь.
5171.06 5174.10 SPEAKER_01 И это то, что мы можем предсказать на сто процентов.
5174.10 5177.66 SPEAKER_01 То есть, это тот слой, который обязательно должен присутствовать в вашем приложении.
5177.66 5182.46 SPEAKER_01 Немножко сложнее обстоит дело с получением данных из другой системы.
5182.46 5188.94 SPEAKER_01 То есть, когда не пользователь вам вводит эти данные, а другая система вводит данные, здесь есть тонкости, от которых мы немножко позже посмотрим.
5188.94 5200.02 SPEAKER_01 То есть, для того, чтобы избежать ошибок пользовательского ввода, вам необходимо настроить свой слой валидации и каким-то образом проинформировать пользователя о плохих данных, которые он вам ввел.
5200.02 5206.54 SPEAKER_01 Выдать сообщение об ошибке, написать в лог, написать в консольку или каким-то другим образом.
5206.54 5213.66 SPEAKER_01 Дальше следующая категория – это тоже предсказуемые ошибки, но немножко более сложные.
5213.66 5220.34 SPEAKER_01 Например, ваше приложение, скорее всего, может зависеть от базы данных.
5220.34 5222.30 SPEAKER_01 А эта база данных может быть недоступна.
5222.30 5225.18 SPEAKER_01 Может покарабкаться, может отвалиться винт, может отвалиться сеть.
5225.18 5229.58 SPEAKER_01 И вообще у вас может отвалиться сеть, например, с другими сервисами, которые необходимы вам для работы.
5229.58 5234.54 SPEAKER_01 Например, ваше приложение могли плохо сконфигурировать.
5234.54 5236.82 SPEAKER_01 Например, задать неправильный connection string.
5236.82 5242.74 SPEAKER_01 Отчего оно, естественно, работать не сможет, с базой данной приконектиться не сможет и вообще основные функции выполнять не сможет.
5242.74 5244.98 SPEAKER_01 У вас, может быть, банально кончится место на диске.
5244.98 5250.30 SPEAKER_01 Может быть, не знаю, сервер закрашивался из-за какой-то ошибки.
5250.30 5253.30 SPEAKER_01 Может закрашивалась какая-то из ваших зависимостей, которая вам нужна.
5253.30 5258.70 SPEAKER_01 В общем, очень много существует инфраструктурных, технических проблем, от которых вы абсолютно никак не застрахованы.
5258.70 5265.86 SPEAKER_01 Вы должны понять, что любая сеть падает, любая датабаза сломается, любой диск заполняется.
5265.86 5270.58 SPEAKER_01 Эти штуки можно решить, можно попытаться решить, давайте так.
5270.58 5286.94 SPEAKER_01 Можно сделать ретрай, можно сделать какие-нибудь дополнительные приседания, попробовать через какое-то время уменьшить количество запросов, circle bracket поставить, можно еще что-то сделать.
5286.94 5290.94 SPEAKER_01 Но в общем случае, единственное, что вы сможете сделать, это залогировать проблему.
5290.94 5295.26 SPEAKER_01 Ну и не факт, что вообще ваш лог сможет куда-то записаться, потому что все зависит от проблем.
5295.26 5313.66 SPEAKER_01 И надо понимать, что если, допустим, у вас ваше приложение зависит от базы данных, и база данных почему-то или повреждена, или не отвечает, или мы не можем получить правильный connection string к ней, то ваше приложение, по сути, становится неработоспособным.
5313.66 5317.46 SPEAKER_01 Это значит, что вы не можете обработать эту ошибку.
5317.46 5324.32 SPEAKER_01 То есть, когда мы раньше в эту категорию спускались, мы ее рассматривали как предсказуемые ошибки.
5324.32 5327.98 SPEAKER_01 И вот это те предсказуемые ошибки, которые вы обработать не в состоянии.
5327.98 5339.26 SPEAKER_01 Да, вы можете пытаться хоть целый день ретраить на базу данных, но вы должны понимать, что рано или поздно лимит ретраива у вас закончится, и все равно ваше приложение не способно будет работать полноценно.
5339.26 5348.82 SPEAKER_01 Поэтому у нас появляется вот такая отдельная категория, что ошибки, которые мы теоретически можем предсказать, да, все рано или поздно ломается, но сделать мы с этим ничего не сможем.
5348.82 5354.50 SPEAKER_01 Также нужно понимать, что часто ошибки бывают контекстно зависимыми.
5354.50 5362.14 SPEAKER_01 Ну, например, рассмотрим наш предыдущий сценарий, когда у нас есть пользователь, который вводит невалидные данные.
5362.14 5366.42 SPEAKER_01 Когда он вводит невалидные данные, мы ему выдаем сообщение об ошибке, и здесь все хорошо.
5366.42 5370.62 SPEAKER_01 Теперь возвращаемся к примеру, когда эти невалидные данные к нам присылает какой-то другой сервис.
5370.62 5376.90 SPEAKER_01 И этот другой сервис, допустим, с ним нет какого-то канала связи, вы не можете ему там сказать просто exception и все.
5376.90 5379.90 SPEAKER_01 Он вам просто загружает какой-то файл и говорит «обрабатывай».
5379.90 5380.90 SPEAKER_01 И никого не волнует этот файл.
5380.90 5383.22 SPEAKER_01 Может быть с плохими данными, с плохими, с еще какими-то.
5383.22 5387.54 SPEAKER_01 Что можно сделать в случае, если вдруг у вас там есть в этом файле невалидные данные?
5387.54 5395.90 SPEAKER_01 Ну, во-первых, конечно, можно всегда бросить ошибку, отказаться отрабатывать этот файл, послать bad request, сделать reject.
5395.90 5399.54 SPEAKER_01 То есть, в принципе, как вариант тоже может быть.
5399.54 5404.98 SPEAKER_01 Можно попытаться найти из этого файла только валидные какие-то значения и обработать только их.
5404.98 5415.22 SPEAKER_01 Можно послать какое-то асинхронное сообщение, что типа «я не смог обработать этот файл», приложить файл, объяснить почему, и типа попытайтесь снова через какое-то время или еще что-то с этим файлом сделать.
5415.22 5417.14 SPEAKER_01 В общем, как-то оповестить админов.
5417.14 5433.82 SPEAKER_01 Все это нас приводит к тому выводу, что если у нас есть проверка пользовательского ввода, то есть, допустим, обычная валидация инпута, то то, как мы будем реагировать на эту валидацию инпута, вполне контекстно зависимо.
5433.82 5440.26 SPEAKER_01 И тот сам процессор, который валидирует этот файл, может быть, даже не знает, каким образом это правильно нужно отвалидировать.
5440.26 5445.62 SPEAKER_01 Знает только тот, кто этот файл в этот процессор отдал.
5445.62 5449.06 SPEAKER_01 То есть, некий враппер сверху, который может принять решение.
5449.06 5457.38 SPEAKER_01 Есть у него текущий интерактивный пользователь или у него просто какой-нибудь машин-то машин-коммуникация и он как-то может другой машине сообщить о проблемах.
5457.38 5471.58 SPEAKER_01 Нужно также понимать, что обработка ошибок всегда связана с неким трейдовом, то есть, у вас всегда есть какие-то плюсы, какие-то минусы и вы всегда должны уметь чем-то жертвовать.
5471.58 5484.70 SPEAKER_01 Возвращаясь к примеру с базы данных, когда мы получаем недоступную базу данных, то вы можете сколько угодно ретраиться, но рано или поздно вы придёте к осознанию, что вы не можете ничего с этим сделать.
5484.70 5492.38 SPEAKER_01 И в обычном банальном случае вы можете отказаться от обработки этой операции, от обработки команды.
5492.38 5496.50 SPEAKER_01 Это как бы 100% скорее всего нашей повседневной бизнес-задачи.
5496.50 5508.90 SPEAKER_01 Когда к нам приходит какой-то реквест на создание пользователя, мы идём в базу, она недоступна, ну мы просто падаем и всё с криками, ай-яй-яй, не могу создать пользователя, программа наша выполнила недопустимую ошибку и будет открыта, и будет закрыта.
5508.90 5517.42 SPEAKER_01 Это самый распространённый кейс, но подумайте, что будет, если вдруг вы пишете программу, которая обрабатывает какие-нибудь медицинские данные, от которых зависит жизнь человека.
5517.42 5529.50 SPEAKER_01 Или если вы запускаете какой-нибудь зонд в космос, где у вас нет возможности просто-напросто поднять ручки и сказать "всё, нишмогла", там вам нужно как-то мучиться, что-то делать.
5529.50 5531.22 SPEAKER_01 И мучиться можно на разных уровнях.
5531.22 5539.34 SPEAKER_01 Можно, как я уже говорил, напрячь сисадминов, которые поставят вам какой-нибудь файловер к базе данных, чтобы она была не одна, чтобы она была более отказоустойчивая.
5539.34 5549.46 SPEAKER_01 Можно запаять к вам в ящик несколько сетевых карт, чтобы если одна отвалилась, у нас всегда был резервный канал связи, мы могли пойти на другую карту.
5549.46 5557.26 SPEAKER_01 Но всё это более-менее от нас не зависит, мы можем это бросить как-то на админов, но как разработчики, грубо говоря, этот путь нам не интересен.
5557.26 5565.10 SPEAKER_01 Нам интересен другой путь, мы на это можем повлиять с точки зрения архитектуры программного приложения.
5565.10 5566.10 SPEAKER_01 Каким образом?
5566.10 5580.90 SPEAKER_01 Ну, например, если у нас недоступна база данных, но при этом доступен, допустим, какой-нибудь асинхронный обмен событиями, там Kafka или Rabbit, мы вполне можем послать себе какое-нибудь асинхронное сообщение, допустим, попытаясь сделать ту же операцию через какой-то промежуток времени.
5580.90 5592.14 SPEAKER_01 Если эти сообщения ещё отправляются через какую-нибудь дюрибл очередь, то есть очередь, которая может сохраниться себе на диск и гарантировать нам какую-то доставку, то вообще прекрасно.
5592.14 5597.26 SPEAKER_01 Могут быть какие-то другие ситуации, которые мы можем каким-то образом по-другому обрабатывать.
5597.26 5614.62 SPEAKER_01 Но, например, если недоступна сеть, вам нужно срочно отправить логи, а недоступна сеть, вы можете вполне сделать у себя локально на диске какой-то буфер с этими логами и как только сеть поднимется, вы этот буфер можете, например, запаблишить куда-нибудь в ваше официальное хранилище.
5614.62 5620.34 SPEAKER_01 То есть можно предусматривать на уровне кода, на уровне программистов вот обход вот таких вот ситуаций.
5620.34 5625.34 SPEAKER_01 Но, опять же, нужно понимать, что всему есть предел.
5625.34 5629.22 SPEAKER_01 Вы не можете бесконечно буферировать в диск, потому что диск сломается.
5629.22 5637.58 SPEAKER_01 Если у вас отказала база данных, то, скорее всего, можете отказать и шинка, в которую вы можете забрасывать сообщения.
5637.58 5649.66 SPEAKER_01 Таким образом, у нас все-таки ситуация, когда у нас есть предсказуемые ошибки, которые вы якобы могли бы обработать, мы можем уменьшить вот этот эффект, который мы могли бы обработать.
5649.66 5655.74 SPEAKER_01 Мы можем и на локальный диск писать, и в другие источники записывать, и как-то это все кэшировать, и как-то повторять.
5655.74 5666.06 SPEAKER_01 Но рано или поздно мы понимаем, что все возможные ситуации предусмотреть невозможно, и постепенно эта категория все равно сваливается в категорию ошибок, которая называется предсказуемые ошибки, которые мы не можем отработать.
5666.06 5679.50 SPEAKER_01 Поэтому нужно ли загоняться вот этими всеми оптимизациями, которые мы пытаемся сделать с ошибками, которые мы якобы можем предсказать, но не можем обработать?
5679.50 5686.74 SPEAKER_01 Нужно ли все-таки ресайленты делать, буферы делать, ретраи делать каждый раз на любом вашем приложении?
5686.74 5687.74 SPEAKER_01 Ответ по дефолту нет.
5687.74 5697.86 SPEAKER_01 Это все очень большое усложнение, которое дается очень большими силами разработчиков, а самое главное, оно ввозит в ваше приложение дополнительную сложность.
5697.86 5706.02 SPEAKER_01 Вся эта сложность, это прямое следствие этой сложности будут дополнительные баги, какие-то проблемы по эксплуатации, какие-то проблемы с метриками, еще чего-то.
5706.02 5712.90 SPEAKER_01 В общем, все это очень-очень сложно, поэтому зря, просто так, ради интереса, по дефолту в эту сложность вписываться не надо.
5712.90 5717.14 SPEAKER_01 И опять же, вся эта сложность, она не дает вам никаких гарантий.
5717.14 5724.74 SPEAKER_01 У вас все равно диск закончится, ретраи кончатся, все базы данных и очереди отвалятся, т.е. у вас все равно гарантий никаких нет.
5724.74 5726.66 SPEAKER_01 Поэтому здесь вам нужно взвешивать.
5726.66 5730.30 SPEAKER_01 Опять же, если у вас критикал-система, то да, стараемся изо всех сил.
5730.30 5734.78 SPEAKER_01 Если что-то средненькое, ну, пробуем какие-то базовые ретраи того же самого поля запустить.
5734.78 5741.02 SPEAKER_01 Если пользователь прекрасно переживет bad-request, то просто бросаем им ошибку и не загоняемся ни о чем.
5741.02 5744.66 SPEAKER_01 Это будет просто, красиво, понятно, а самое главное – поддерживаемо.
5744.66 5750.06 SPEAKER_01 Есть еще одна интересная категория ошибок, которая называется баги, они же инциденты.
5750.06 5755.18 SPEAKER_01 Третья категория, к которой относятся категории невозможно предсказать.
5755.18 5762.66 SPEAKER_01 Ну, т.е. мы все можем предсказать, что баги у нас, конечно, есть, но мы абсолютно не понимаем ни в каком месте они выстрелят, ни как программа будет после этого себя вести.
5762.66 5766.22 SPEAKER_01 Поэтому эта категория относится невозможно предсказать.
5766.22 5768.18 SPEAKER_01 Но мы точно знаем, что они будут.
5768.18 5777.34 SPEAKER_01 И если у вас был баг один раз, допустим, он стрельнул и исчез, то это прямое следствие того, что он может стрельнуть и второй раз, поэтому это очень опасная штука.
5777.34 5786.02 SPEAKER_01 И в этот момент мы можем для себя решить, мы будем этот баг искать и фиксить или есть еще другой вариант, можно не искать и не фиксить.
5786.02 5797.50 SPEAKER_01 Если мы не можем это сделать, мы можем вполне себе сами честно ответить, что этот баг, который мы фиксить не будем, он не так уж сильно влияет на наше приложение.
5797.50 5801.06 SPEAKER_01 Мы его можем вполне описать, сказать, что оно происходит раз в год и в принципе забить.
5801.06 5807.26 SPEAKER_01 Когда мы говорим про моделирование ошибок, у нас есть очень много подходов.
5807.26 5816.38 SPEAKER_01 К сожалению, человечество до сих пор не придумало идеальные подходы, которые бы нам позволяли хорошо работать со всеми вот этими ошибками, которые здесь были описаны.
5816.38 5821.18 SPEAKER_01 Но были придуманы некие вспомогательные методы.
5821.18 5826.74 SPEAKER_01 Например, самая прекрасная вещь, которую придумала человечество для того, чтобы бороться с ошибками, это стронг тайпинг.
5826.74 5837.98 SPEAKER_01 Именно поэтому языки с сильной статической типизацией очень сильно выиграют языку с динамической типизацией или без типизации, или со слабой типизацией, в общем, со всем этим шлаком в виде джаваскрипта.
5837.98 5846.92 SPEAKER_01 Потому что то, что джаваскриптеры, питанисты и прочие люди должны выявлять в тестах, у нас делает компилятор на уровне компиляции.
5846.92 5854.86 SPEAKER_01 Большинство из тех проблем, которые случаются в рантайме в этих языках, в строго типизированных языках, мы отлавливаем в компайл тайме.
5854.86 5863.30 SPEAKER_01 У нас также есть на основании строгих типов еще их дополнительные фишки, дополнительные плюшки.
5863.30 5873.06 SPEAKER_01 Прежде всего, это null-reference-types, это просто мега-фича, мега-взрывная штука и ее можно прям сравнить, как будто у вас не было раньше типа, а вы типы добавились.
5873.06 5891.38 SPEAKER_01 Потому что null-reference-types дают вам огромное количество прекрасных возможностей избежания самой популярной в мире проблемы, это null-reference-exception, если вдруг вы почему-то до сих пор уже не пользуетесь все еще null-reference-types, то обязательно изучите вопрос, оно того стоит, оно спасает просто мега-сильно.
5891.38 5912.02 SPEAKER_01 Также, благодаря тому, что у нас есть нормальные строгие типы, у нас полно линтеров и анализаторов, которые не просто там какие-то буквы анализируют, а могут нормально построить семантическое, синтаксическое дерево, пройтись, проанализировать, посмотреть свои типы и в памяти даже проинтерпретировать вам некоторый код для того, чтобы прям найти какие-нибудь определенные, например, векторы атаки.
5912.02 5914.26 SPEAKER_01 Этим часто грешат там security-сканеры уязвимостей.
5914.26 5928.30 SPEAKER_01 В общем, линтеры, анализаторы, NRT, strong-types, эти все инструменты как раз были призваны нам для того, чтобы уменьшить то количество ошибок, которые у нас возможно будут порождаться в рантайме и свести это на самый эффективный уровень – на билд-тайм.
5928.30 5939.86 SPEAKER_01 Другие способы, как работать с ошибками – это введение специальных явных результатов, которые нам говорят о том, что данный метод может вернуть ошибку.
5939.86 5946.46 SPEAKER_01 Это наверняка всем известный вам result-type, он же either в других методах, в других языках или maybe.
5946.46 5950.70 SPEAKER_01 То есть это обычно тип, который может принимать два значения.
5950.70 5956.66 SPEAKER_01 Или он успешно выполнился, и вам успешный результат, или не успешно выполнился, и какое-то описание ошибки возвращает.
5956.66 5960.02 SPEAKER_01 В общем, этот подход тоже очень популярен в различных языках.
5960.02 5969.22 SPEAKER_01 Ну и у нас еще есть методология, то есть у нас есть TDD, который позволяет нам покрывать тестами максимальное количество задач.
5969.22 5971.22 SPEAKER_01 То есть это уже ловля на уровне рантайма.
5971.22 5977.26 SPEAKER_01 У нас есть код-ревью, который тоже помогает уменьшить количество проблем на каких-то ранних этапах.
5977.26 6002.98 SPEAKER_01 В общем, человечество придумало очень много всего, и включая инструментарии, включая методологии, включая подходы и чуть ли не целые концепции в языках программирования, которые отталкивались от ошибок, и как вести себя с ошибками, и как, например, перезапускать проблемы с ошибками, как это сделано, допустим, в АКИ, когда у нее есть целая стратегия, когда мы из ошибок перезапускаем целый кластер акторов.
6002.98 6012.70 SPEAKER_01 В общем, ошибки драйвят очень сильно нашу систему, и пока человечество не выдумало что-то такое хорошее, где можно описать красиво все и решить все эти проблемы.
6012.70 6019.94 SPEAKER_01 Поэтому мы пока остаемся на уровне методологии, на уровне договоренности, на уровне концепции, а также строгих типов и кучи анализаторов, которые нам в этом помогают.
6019.94 6026.90 SPEAKER_00 Ну, вообще, с одной стороны, звучит все это масштабно, классификация, все такое.
6026.90 6030.78 SPEAKER_00 С другой стороны, это не из разряда нормально делать нормально будет.
6030.78 6038.38 SPEAKER_00 Ну, то есть, подходи, так сказать, с умом к тому, насколько критична твоя система, и сообразно планируй.
6038.38 6043.82 SPEAKER_00 Это же все не просто разработчик решает, они сделают для меня тут ретрай.
6043.82 6054.94 SPEAKER_00 Это же как-то все, не знаю, должно проговариваться на каком-то плюс-минус критикурном уровне, пусть даже с самим разработчиком, но с каким-то более опытным разработчиком.
6054.94 6055.94 SPEAKER_01 Не знаю.
6055.94 6056.94 SPEAKER_01 Проговариваться – это одно.
6056.94 6063.94 SPEAKER_01 Но так как мы в нашем повседневном коде сталкиваемся с миллионом мест, где может случиться ошибка, все это проговорить невозможно.
6063.94 6071.42 SPEAKER_01 Поэтому у тебя должен быть очень высокий уровень сознательности, а уровень сознательности подразумевает под собой какой-то практический опыт.
6071.42 6082.34 SPEAKER_01 Пока ты не натолкнешься на то, что база данных у тебя может отсутствовать, что тебе connection string могут неправильно записать, пока ты на практике вот это не испытаешь, скорее всего, большинство людей об этом даже не задумываются.
6082.34 6090.94 SPEAKER_00 Ну, или connection string есть, но у тебя мастер базы данных умерла, а реплика живет в рядомом режиме, и у тебя половина только с программой работает.
6090.94 6094.46 SPEAKER_00 Типа, гетпоинты работают, а посты не работают.
6094.46 6099.22 SPEAKER_01 И приложение может быть устроено так, что при первой попытке записи у тебя оно просто рушится.
6099.22 6105.86 SPEAKER_01 Можно было поставить его, чтобы только начание работало, но ты это как-то не предусмотрел, и у тебя на записи оно просто все падает.
6105.86 6107.30 SPEAKER_01 Например, такое тоже может быть.
6107.30 6128.02 SPEAKER_00 Ну, в общем, подходите с умом, думайте о том, когда вы пишете код, что здесь может пойти не так, и если вам кажется, что что-то может пойти не так, и либо сами принимаете решение, как бы с этим бороться, либо сначала посоветуйтесь с кем-то еще в проекте, нужно с этим бороться, или пусть падает, потому что по факту вам окей.
6128.02 6135.74 SPEAKER_00 Хорошо, давай попробуем на сегодня успеть последнюю темку, наверное, быстренько пробежаться.
6135.74 6136.74 SPEAKER_01 Ну, давай.
6136.74 6140.22 SPEAKER_01 Ну, я думаю, что шансов мало.
6140.22 6141.22 SPEAKER_01 Ладно.
6141.22 6142.22 SPEAKER_01 Погнали.
6142.22 6152.22 SPEAKER_01 Топ 10 визуал студийных фич, которые были выпущены в 2023 году, и которые понравились товарищу Джеймс Монтемангону.
6152.22 6163.02 SPEAKER_01 Этот товарищ довольно знаменит, особенно в средах мобайл-разработчиков, очень много библиотек написал, очень много статей написал, в общем, товарищ просто золото.
6163.02 6176.22 SPEAKER_01 К сожалению, в наших статьях, в наших подкастах он звучит редко, потому что по профилю немножко не подходит, но в основном человек очень крутой, поэтому нет никаких резонов ему не верить.
6176.22 6184.26 SPEAKER_01 Давайте посмотрим, что он для себя открыл в 2023 году, даже не открыл, наверное, посчитал самыми хорошими инструментами, которые появились в визуал студии.
6184.26 6194.06 SPEAKER_01 Прежде всего, это DevTunnels, туннели для разработчиков, которые позволяют вам, ваш локальный хост, выставить голой попой, например, в интернет.
6194.06 6209.62 SPEAKER_01 То есть, данный сервис помогает вам сформировать специальный урл, и если кто-то зайдет по этому урлу, любой человек в интернете зайдет по этому урлу, он будет перенаправлен на ваш локальный сервак, на ваш локальный порт, который, допустим, у нас сейчас под студией запущен.
6209.62 6215.30 SPEAKER_01 И вы, например, можете этот запрос отдебажить или что-то показать, например, вашу презентацию, или еще что-то.
6215.30 6218.30 SPEAKER_01 Это просто мега-фича для мобильных разработчиков.
6218.30 6228.42 SPEAKER_01 Когда у вас есть миллион девайсов, эти все миллионы девайсов никаким образом не подключены к вашей, допустим, корпоративной сети, у них нормально, если есть интернет.
6228.42 6244.70 SPEAKER_01 И вот вы этим девайсам даете ссылочку, и эти девайсы заходят на ваш сервер, который сейчас запущен у вас под отладчиком, и делают там всякое, вызывают запросы, проходит авторизация, вы это все можете видеть, дебажить, смотреть, как бы снимать дампы, в общем, золотая штука.
6244.70 6262.06 SPEAKER_01 А также, если вы просто хотите, например, показать в вашем веб-сайте, который вы недавно разработали какому-то, не корпоративному, а наоборот, внешнему клиенту, вы точно так же можете дать им урлик вот этот и не паблишить этот сайтик никуда, запустить его под Visual Studio, и по этому урлу ваш внешний потребитель все это увидит, все это посмотрит.
6262.06 6265.30 SPEAKER_01 Короче, прекрасная штука, которая для некоторых сфер просто критикал необходима.
6265.30 6276.98 SPEAKER_01 Дальше он отмечает вторую фичу, которая ему понравилась, это HTTP файлы и Endpoint Explorer, вообще не связаны между собой вещи, кроме там слова HTTP, наверное, но обе прекрасны.
6276.98 6285.18 SPEAKER_01 HTTP файл – это возможность в Visual Studio сделать специальный файлик с расширением HTTP и писать там обычным текстом запросы.
6285.18 6292.66 SPEAKER_01 Типа, дай мне такой сервис, и вы нажимаете специальную кнопочку, о, не дай, а вызови мне такой-то HTTP урл, допустим, какой-то Endpoint какой-то.
6292.66 6301.34 SPEAKER_01 Нажимаете специальную кнопочку, и у вас этот урл вызывается, и показывается ответ от удаленного сервиса в виде такого же текстового файлика.
6301.34 6313.38 SPEAKER_01 Казалось бы, идея примитивная, т.е. это обычный курл, грубо говоря, т.е. но более в удобном виде, в удобном файлике, который можно сохранить, передать и т.д., но это действительно на практике безумно удобно.
6313.38 6331.98 SPEAKER_00 Ну, и эта штука поддержана не только в Visual Studio, она поддержана многими и IDE, и RIDER такой умеют, в общем, такой плюс-минус стандарт, что ли, VVS-код, всё это пошло, на самом деле, из VVS-кода, где кто-то написал отличный экстенджер, который, собственно, эту идею предложил, насколько я понимаю.
6331.98 6334.46 SPEAKER_00 Ну и дальше это потихонечку растянулось во все места.
6334.46 6337.86 SPEAKER_01 Я даже уже не боюсь предположить, откуда это первый раз пошло.
6337.86 6344.86 SPEAKER_01 Ну, я, например, допользуюсь Visual Studio кодом, мне там удобнее такую штуку делать, но надо понимать, что Visual Studio тоже это умеет.
6344.86 6379.82 SPEAKER_01 И второй подпункт – это Endpoint Explorer, тоже прекрасная тулза, которая позволяет вам просканировать весь ваш проект, притом не надо его запускать, сканируется исходный код, и посмотреть все endpoints, которые у вас есть, и посмотреть, где они в одном единственном окошечке, что они вызывают, а самое приятное – это сгенерировать для них реквест, и этот реквест как раз генерируется в подобном http-файле, т.е. вы можете открыть, нажать кнопочку "Generate" и позапускать запросы прямо к вашему endpoint, и увидеть сразу в этом же файле ответы к этому endpoint, вообще прекрасно.
6379.82 6395.30 SPEAKER_01 Третий пункт – это GitHub Copilot, GitHub Copilot Chat, в общем, все, что связано с искусственными интеллектами, которые помогают нам давать подсказки в реальном времени, а также помогают кодить, помогают генерить файлы, тесты, рефакторинг, объяснять код и прочее-прочее.
6395.30 6427.82 SPEAKER_01 Четвертый пункт – это GIT и улучшения в пул реквестах, т.е. вы в Visual Studio можете создать и управлять GIT-репозиториями с помощью интегрированного в Visual Studio UI, вы можете прилинковать коммиты из GitHub-ов, из GitHub-issues для более тщательного общения там и по отслеживанию истории того, что вы делаете, и также в Visual Studio есть встроенный пул реквест-креатор, который умеет создавать пул реквесты прямо из Visual Studio.
6427.82 6432.06 SPEAKER_01 Игорь, ты пользуешься Visual Studio и вообще вот этой интеграцией с GIT-ом?
6432.06 6442.54 SPEAKER_00 У меня GIT либо command-line, либо веб, так сказать, вариант, либо сторонник-клиент, из Visual Studio я GIT-ом практически не пользуюсь.
6442.54 6450.94 SPEAKER_01 Да, у меня похожая ситуация, но судя по картинкам это выглядит все прекрасно, в общем-то, гораздо лучше, чем, например, пул реквесты смотреть в вебке.
6450.94 6453.74 SPEAKER_01 Но надо пересилиться и попробовать, наверное.
6453.74 6471.14 SPEAKER_00 Нет, я таким пользуюсь в Райдере, когда я смотрю гитлабовские мерч реквесты, там это называется, там есть специальное расширение, которое позволяет прямо нативно, она подтягивает сразу чек-аутик, нужную веточку тебе, все дифы, сразу все навигации тут же работают, все прекрасно работают, шикарно.
6471.14 6474.06 SPEAKER_00 Если в студии сделали так же, это прекрасно.
6474.06 6476.14 SPEAKER_01 Ну вот судя по скриншотам, да, там тоже пытались что-то
6476.14 6477.14 SPEAKER_00 подобное сделать.
6477.14 6483.90 SPEAKER_00 Ну слушай, мы весь прошлый год в превьюхах, каждое превьюху было что-то улучшение в GIT-е, так что я не удивлен.
6483.90 6498.30 SPEAKER_01 Пятый пункт, вообще не поверите, вот рядом с АИ, девтуннелями, гитхабами, копайлотами стоит такая прекрасная штука, как разноцветные скобочки фигурные.
6498.30 6505.38 SPEAKER_01 Заключается смысл в том, что Visual Studio, кстати, с подачи Мэтта Торгессона, не Мэтта Торгессона, а как главный наш писатель?
6505.38 6506.38 SPEAKER_01 Мэтс Кристенсен.
6506.38 6550.74 SPEAKER_01 Мэтс Кристенсен, да, позаводили Мэтсов, с подачи Мэтса Кристенсена эта штука появилась в Visual Studio, естественно, я сначала плагин под ним написал, штука, которая позволяет вам раскрашивать фигурные скобочки, ну открыть-закрыть блок в разные цвета, и дает это два преимущества, во-первых, вы видите фигурные скобочки, они у вас выделяются, и во-вторых, вы вложенность, видите уже вложенные фигурные скобочки, вы уже видите совершенно другим цветом, да, и это визуально помогает вам улучшить читабельность и улучшить идентификацию скобочек друг от друга, то есть пару ей найти очень быстро визуально, и это по мнению Джеймса, в общем, достойная мега фича, которую срочно стадо упомянуть, и он не понимает, как он без этого раньше жил.
6550.74 6553.66 SPEAKER_00 Ну, может, код у него такой, с кучей скобочек он пишет.
6553.66 6556.42 SPEAKER_01 Ну, код с кучей скобочек у нас у всех, да.
6556.42 6562.06 SPEAKER_00 Слушай, ну следующая ему тоже, spellcheck, ну блин, spellcheck, как бы, что такое?
6562.06 6567.14 SPEAKER_01 Ну, да, он есть у многих, просто в Visual Studio недавно появился, я, например, тоже живу долго с spellcheck.
6567.14 6571.66 SPEAKER_00 Сколько у меня ошибок оказывается, да, сказал он, ну какая полезная штука, ну да.
6571.66 6577.78 SPEAKER_00 А вот следующая мне, кстати, даже непонятна на самом деле, давай вот я так быстро перебрыгну.
6577.78 6585.10 SPEAKER_00 Это accessibility checker, если ты говоришь, что он в основном про мобильную разработку, а тут в основном про ВПФ, насколько я вижу.
6585.10 6589.42 SPEAKER_01 Ну, он про мобильную разработку в терминах Xamarin, а Xamarin это
6589.42 6591.42 SPEAKER_00 ВПФ, поэтому что-то удивляешься.
6591.42 6592.42 SPEAKER_00 Ладно, хорошо.
6592.42 6609.34 SPEAKER_01 Ну то есть accessibility checker довольно полезная вещь, она умеет сканировать ваши десктопы визуальные там или мобильные, короче, любое приложение, у которого есть разметка визуальная, юайка, которая есть, правильно сказать, да, и подсвечивает вам какие-то ошибки, которые можно устранить и которые можно прооптимизировать для лучшей доступности.
6609.34 6610.34 SPEAKER_01 Прикольно.
6610.34 6617.14 SPEAKER_01 Восьмой пункт, это его вдохновляет, тотнет эспайр и всё, что с ним происходит, в общем, без эспайра ни на одной темы ни одного дня у нас.
6617.14 6618.82 SPEAKER_01 Ну, надо же профушить.
6618.82 6619.82 SPEAKER_00 Ну, наверное, да.
6619.82 6620.82 SPEAKER_00 Да, все дела, да.
6620.82 6638.66 SPEAKER_01 Несмотря на то, что у них там есть эспайр-темплейт, который позволяет вам создавать новые проекты, вы также можете добавить эспайр в существующие проекты благодаря Visual Studio, и также ему нравится, что там прекрасные дефолты есть, которые подключают сразу и трейсинг, и метрики, и дают красивые дашборды, и всё это красиво без единой там нажатия кнопочки.
6638.66 6641.10 SPEAKER_00 Звучит, как типичный рекламный текст.
6641.10 6642.10 SPEAKER_01 Давай дальше.
6642.10 6643.10 SPEAKER_01 Это точно.
6643.10 6663.62 SPEAKER_01 Visual Studio UI Refresh, я долго думал, кто там рефрешит у Visual Studio что-то, оказывается, Visual Studio в прошлом году сильно улучшило свой дизайн, он теперь стал более современным, например, появились скругленные уголочки, табики начали вести себя немножко по-другому, и подтянулись новые темы, и также эти темы прооптимизировались.
6663.62 6664.62 SPEAKER_01 Прекрасно.
6664.62 6665.62 SPEAKER_01 Да.
6665.62 6671.70 SPEAKER_01 И последний, десятый пункт – это C# WebKit for Visual Studio Code.
6671.70 6672.70 SPEAKER_00 Давай, DevKit.
6672.70 6674.54 SPEAKER_00 Всё-таки не WebKit, а DevKit.
6674.54 6678.34 SPEAKER_00 Это, да, набор плагинов для VS Code.
6678.34 6698.46 SPEAKER_01 Для Visual Studio, который над Language Service, настраивает вам нормальный Solution Explorer, даёт хорошие темплейты, тест Discovery, тест Solution, дебаггинг хороший, IntelliSense тот же самый подключает, в общем, делает практически вот из Visual Studio Code полноценную Visual Studio, ну, по крайней мере, пытается на том Language Service, который у неё есть.
6698.46 6712.78 SPEAKER_00 Нет, ну там как раз Language Service это неплохой, потому что, я так понимаю, что они туда тянут свой, который закрытый и хороший, а я так понимаю, что эта цель как раз какая-никакая замена в Visual Studio for Mac, потому что таким образом на VS Code вы можете нормально писать.
6712.78 6715.66 SPEAKER_00 Ну, кроссплатформенной версии, да, что-то такое.
6715.66 6716.66 SPEAKER_00 Да, да.
6716.66 6717.66 SPEAKER_00 Давай, у тебя три минуты.
6717.66 6721.82 SPEAKER_00 У меня три минуты, так у меня же тема называется «Кратко о разном».
6721.82 6722.82 SPEAKER_00 Никаких проблем.
6722.82 6723.82 SPEAKER_00 Кратко так кратко.
6723.82 6740.16 SPEAKER_00 Во-первых, вышла статья от Джеймса Ньютон Кинга про то, что, напоминаем, что у нас, у Майкрософта есть очень классные дэшбордики для графана, то есть Aspire это, конечно, хорошо, но графану мы не забываем.
6740.16 6748.20 SPEAKER_00 Короче, есть репозитории, где лежат полезные дэшборды, которые очень круто показывают состояние вашего Asp.NET приложения.
6748.20 6752.88 SPEAKER_00 Так что, если вы пользуетесь графаной и пишете на дот.нете Asp.NET приложение, посмотрите обязательно.
6752.88 6760.56 SPEAKER_00 И вторая новость это, если вы не знаете, есть такой, не знаю, продукт, библиотека, Enquire.
6760.56 6761.56 SPEAKER_00 Кто он?
6761.56 6762.56 SPEAKER_00 Библиотека, мне кажется.
6762.56 6763.56 SPEAKER_00 Библиотека или фреймворк.
6763.56 6764.56 SPEAKER_00 Фреймворк, да.
6764.56 6765.56 SPEAKER_00 Вот такое.
6765.56 6773.24 SPEAKER_00 Это все, всякие там про таймеры, запуск, про расписание, вот это все, короче, шедулер, вот все вокруг этого.
6773.24 6779.88 SPEAKER_00 Они написали библиотечку, которая называется Kronos, которая позволяет на дот.нете парсить крон-экспрессион.
6779.88 6791.44 SPEAKER_00 То есть, если вот эти все ваши стандартные там, один звездочка-звездочка-звездочка-звездочка, вот это все, библиотечка, которая позволяет это все распарсить, причем она поддерживает ряд кастомизаций, там интервалы можно задавать.
6791.44 6817.12 SPEAKER_00 Поддерживает нормальный парсинг, поддерживает нормальный удобную API-шку вида, а дай мне, пожалуйста, когда случится следующее событие согласно этому крону от текущего момента, или дай мне, пожалуйста, все события, которые случатся в интервале ближайший год для вот этого крон-выражения, и он вам вернет набор дэйт таймов, когда же случится то, что должно было случиться по вашему запрограммированному крону.
6817.12 6828.92 SPEAKER_00 Короче, если пользуетесь вдруг крон-синтаксисом зачем-то, посмотрите на кроны, скажется, что это довольно неплохая библиотека от чуваков, которые знают, что такое шедулеры и явно, скорее всего, парсить крон умеют.
6828.92 6832.40 SPEAKER_01 Да, судя по фичам, очень крутая библиотечка, стоит
6832.40 6833.40 SPEAKER_00 попробовать.
6833.40 6874.96 SPEAKER_00 Ну, на этом все, мы посмотрели на DotNet 9 Vision, посмотрели на DotNet 9 Preview 1, узнали, как мы собираемся ломать C# 13-й версии, посмотрели на Visual Studio 20.22, 17.9 и 17.10 Preview 1, узнали у Эндрю Лока очередной раз, как же мы можем настраивать урлы и порты для Espanet Core приложения, посмотрели на новинки Aspire Preview 3, поразмышляли об категориях ошибок, об ошибках категорий вместе с Марком Симоном, ну и узнали крутые 10 новых фич в Visual Studio за 2023 год, по мнению Джеймса Монтеманио.
6874.96 6876.88 SPEAKER_00 И на этом все.
6876.88 6883.32 SPEAKER_01 Всем до новых встреч, лайки, шарики, репосты, ждём ваших комментариев, присылайте письма, всем пока.
6883.32 6883.96 SPEAKER_01 Всем пока.

