0.00 3.24 None Здравия, други!
3.24 9.56 "Анатолий Кулаков" В эфире Радио.нет, выпуск номер 36.
9.56 11.92 "Анатолий Кулаков" С вами в студии сегодня Анатолий Кулаков.
11.92 12.92 "Анатолий Кулаков" И Игорь Лабутин.
12.92 13.92 "Анатолий Кулаков" Всем привет!
13.92 27.92 "Анатолий Кулаков" И прежде всего большое спасибо нашим постоянным патронам – Александру, Сергею, Владиславу и всем другим, кто нас поддерживает, а также рассказывает своим друзьям, шарит, репостит и всячески помогает подкасту продвинуться в массы.
27.92 29.96 "Анатолий Кулаков" Большое спасибо вам за то, что помогаете нам.
29.96 33.32 "Анатолий Кулаков" И за то, что помогаете людям вокруг становиться образование.
33.32 38.52 "Анатолий Кулаков" А мы, соответственно, будем поддерживать планку и будем рассказывать вам про интересные новости.
38.52 43.44 "Анатолий Кулаков" Сегодняшний выпуск станет не исключением, потому что первая новость очень интересная.
43.44 45.28 "Анатолий Кулаков" Мы ее ждали довольно-таки давно.
45.28 52.84 "Анатолий Кулаков" Итак, Дотнет 6 вышел на финишную прямую и готов нам уже сейчас показать релиз-кандидат первый.
52.84 54.76 "Анатолий Кулаков" Ну что ж, Игорь, что там у нас в релиз-кандидате?
54.76 58.40 "Анатолий Кулаков" Давай разберемся, что вошло, что не вошло, от чего отказались и что получилось.
58.40 63.72 "Игорь Лабутин" Прежде чем мы посмотрим, что вошло, что не вошло, давай сначала разберемся, что же такое релиз-кандидат.
63.72 67.60 "Игорь Лабутин" На самом деле, в случае Майкрософта это довольно интересная штука.
67.60 71.72 "Игорь Лабутин" Это первый из двух, всего их будет два, это уже известно.
71.72 74.92 "Игорь Лабутин" И после второго будет уже, собственно, паблик релиз в ноябре.
74.92 80.72 "Игорь Лабутин" И фишка с релиз-кандидатами у Майкрософта состоит в том, что они уже поддержаны для продакшена.
80.72 86.96 "Игорь Лабутин" То есть вы можете сейчас в продакшен-коде брать, использовать релиз-кандидат и дальше ругать Майкрософта, если у вас что-то не работает.
86.96 89.64 "Игорь Лабутин" И почему это называется релиз-кандидат?
89.64 97.44 "Игорь Лабутин" Ну потому что все-таки еще не все финализировано, но тем не менее они, как пишет Майкрософт, supported in production, так что можно уже брать и использовать.
97.44 99.92 "Анатолий Кулаков" Интересная терминология, да, я такого раньше не встречал.
99.92 107.32 "Игорь Лабутин" Ну вот они перешли на такую штуку, по-моему, начиная с 3x какого-то дот надкора, что релиз-кандидаты они стали поддерживать в продакшене.
107.32 127.64 "Игорь Лабутин" И они на самом деле активно призывали кто-то из Майкрософтовцев в Твиттере, типа пишите нам, значит, на почту, если вы хотите заадоптить дот над 6 пораньше, ну типа если там большая компания вам интересна мигрировать, мы вам всем поможем, там расскажем, что делать, помониторим вас, оперативно пофиксим баги, если вы что-то найдете.
127.64 138.16 "Игорь Лабутин" Ну то есть, короче, они прям пытаются очень активно продвигать, так сказать, раннее использование с тем, чтобы, видимо, действительно успеть к нормальному релизу отловить как можно больше багов.
138.16 142.96 "Игорь Лабутин" Но тем не менее, поехали попробуем посмотреть, что там появилось.
142.96 150.04 "Игорь Лабутин" А, еще момент, для того, чтобы использовать дот над 6 релиз кандидат 1, вам нужна visual studio 2022 превью 4.
150.04 158.04 "Игорь Лабутин" Мы поговорим немножко позднее про превью 4, но надо понимать, что вот именно она нужна, если вы хотите пробовать дот над 6.
158.04 170.72 "Игорь Лабутин" И дот над 6 пока не доступен для мака, но будет visual studio 2022 for mac превью 1, про которую мы еще пока ничего не знаем, но именно там будет дот над 6 рц 1.
170.72 186.28 "Игорь Лабутин" В статье про релиз кандидат 1 на самом деле есть несколько больших разделов, и многие из них, это не то, чтобы вот прям появилось в релиз кандидате, на самом деле в релиз кандидат завезли не очень много именно прям вот фич.
186.28 196.84 "Игорь Лабутин" Это, как обычно, Richlander, который обычно пишет все эти статьи, обозревает, а что вообще они сделали в целом за весь релизный цикл, так скажем.
196.84 206.76 "Игорь Лабутин" И выяснилось, что на самом деле Microsoft довольно плотно работала с Red Hat для того, чтобы сделать правильную штуку под названием Source Build.
206.76 215.16 "Игорь Лабутин" Начали они еще до того, как они выпустили дот над Core 1.0, то есть они этим занимаются уже сколько, 5 лет получается, больше даже.
215.16 238.96 "Игорь Лабутин" И фишка заключается в том, что Red Hat, это же как известно, ну они делают Linux, в том числе, ну в смысле свой дистрибутив Linux, а идея open source'ного, так сказать, софта, который там распространяется, по крайней мере так считает Red Hat, заключается в том, что для сборки, собственно, дотнета там нужно иметь возможность собрать его из некоторого source package, куда будет входить в том числе сам компилятор и так далее.
238.96 250.64 "Игорь Лабутин" То есть нельзя распространять, ну это неправильно распространять дотнет SDK на Linux, если вы не можете собрать его не на Linux и не используя какой-то Microsoft'овский тул.
250.64 254.64 "Игорь Лабутин" Нужно обязательно использовать только то, что распространяется в пакетжах самого Red Hat.
254.64 261.76 "Игорь Лабутин" И поэтому сейчас для того, чтобы Red Hat собирал правильный дотнет SDK, они делают это в несколько проходов.
261.76 281.88 "Игорь Лабутин" Сначала они берут Microsoft Build из нормального, обычного дотнет SDK, который делает Microsoft, собирают из исходников дотнет SDK новый SDK, после этого берут MS Build из собранного SDK и собирают еще раз те же исходники, но уже теперь правильным MS Build'ом, который собран из этих же исходников.
281.88 288.76 "Игорь Лабутин" И именно вот такой финальный SDK потом распространяется Red Hat'ом для своих Linux'ов.
288.76 290.24 "Игорь Лабутин" Да, круто завернули.
290.24 291.24 "Игорь Лабутин" Вот.
291.24 308.36 "Игорь Лабутин" Улучшение в шестом дотнете, что сделали в шестом дотнете, теперь в том, что результатом как бы билда внутри Microsoft'а получается некоторый архивчик с кодом, который можно просто отдать Red Hat'у и вот он провернет на этом деле свой двухшаговый билд.
308.36 315.76 "Игорь Лабутин" То есть раньше для того, чтобы собрать пакет с исходничками для Red Hat'а нужно было проделать некоторую работу, в том числе частично ручную.
315.76 317.76 "Игорь Лабутин" Сейчас это просто продукт билда.
317.76 318.76 "Игорь Лабутин" Вот.
318.76 323.16 "Игорь Лабутин" И вторая часть, над которой они активно работают, она связана с этим, это Reproducible билды.
323.16 326.68 "Игорь Лабутин" То есть многие дистрибутивы стремятся к тому, чтобы делать Reproducible билды.
326.68 337.76 "Игорь Лабутин" То есть если вы берете те же самые исходники, там через год, через два, через три, просто их собираете, а как мы помним компилятор должен быть включен в комплект, то вы получаете абсолютно идентичные бинарники, прям вот побайтово.
337.76 338.76 "Игорь Лабутин" Вот.
338.76 342.68 "Игорь Лабутин" И сейчас с этим есть некоторые проблемы в дотнете.
342.68 347.32 "Игорь Лабутин" Вы не можете собрать полностью идентичные бинарные SDK из того же самого исходника.
347.32 355.60 "Игорь Лабутин" При этом основная проблема на самом деле не в коде, именно DLELIC, а как они утверждают в алгоритмах компрессии ресурсов в сборках.
355.60 364.28 "Игорь Лабутин" Когда там всяческие резиксы и прочие там, картинки запаковываются, вот там есть алгоритмы компрессии, которые не то что не детерминированы, но они могут продюсировать чуть-чуть разный бинарный контент.
364.28 365.28 "Игорь Лабутин" Вот.
365.28 371.28 "Игорь Лабутин" Но вот они с этим осталось побороться и будут, я так понимаю, что практически полностью reproducible билды.
371.28 379.04 "Анатолий Кулаков" Я когда-то несколько лет назад изучал этот вопрос, когда вот тема только поднималась, там как раз у компилятора появились какие-то специальные флажки, которые более-менее могли это гарантировать.
379.04 395.60 "Анатолий Кулаков" И мне казалось, там есть и как раз такие security моменты, которые подставляли какие-то рандомные адреса, куда должны там загружаться какие-то ресурсы, которые поставили рандомные гуиды для того, чтобы как-то идентифицировать наверное сборку, вот.
395.60 399.04 "Анатолий Кулаков" То есть там именно чисто какие-то бизнес проблемы были с этим.
399.04 400.76 "Анатолий Кулаков" То есть сейчас они это все убрали, да?
400.76 417.16 "Игорь Лабутин" Я не думаю, что они убрали, но если мы говорим про security, мы немножко сейчас затронем эту тему, то во-первых, мы уже много раз обсуждали, что со стороны процессоров и операционных довольно много делается в сторону security, и возможно какие-то вещи уже не так нужны именно на уровне билда.
417.16 436.60 "Игорь Лабутин" А во-вторых, действительно, например, мы при сборке в DLL добавляется специальный там ID-шник, грубо говоря, по которому, или там подпись, по которому потом будет матчиться PDB-шка, чтобы если ты соберешь где-то ее в другом месте, то PDB-шка будет возможна чуть-чуть другая и нужно, чтобы они полностью совпадали, как мы все знаем из опыта отладки.
436.60 444.28 "Анатолий Кулаков" Да, PDB-шка это отличный пример, у него по идее каждый раз вот этот ID-шник должен быть уникальным для того, чтобы не перепутать как раз такие символы.
444.28 452.92 "Игорь Лабутин" Вот, так а на самом деле, если ты всегда из одних исходников гарантированно собираешь абсолютно одинаковую DLL, то и PDB-шка будет всегда одинаковая.
452.92 459.52 "Анатолий Кулаков" PDB-шка включает в себя полные имена исходников, если исходники одни, но лежат они в другой папке, это те же самые исходники или нет?
459.52 461.72 "Анатолий Кулаков" Потому что PDB-шки у них будут разные.
461.72 472.68 "Игорь Лабутин" Это интересный вопрос, но на самом деле полные имена исходников не важны, где они лежали, если мы используем всякие, как это называется, source, не помню.
472.68 473.68 "Игорь Лабутин" Source-линки.
473.68 474.68 "Игорь Лабутин" Source-линки, да.
474.68 491.44 "Игорь Лабутин" Вот, то есть у меня он прекрасно находит, если я собираю, например, кусочек своего продукта, ну где-то, который собран на билд-сервере, где он там собирается в какой-то странной папочке билд-агента, и подбираю эту PDB-шку к себе, он прекрасно это все source-линком находит, ему пофигу.
491.44 504.88 "Анатолий Кулаков" Ну и опять же, скорее всего, вот этот ID-шник, это не просто какой-то чексум от PDB-шки, то есть даже если PDB-шки будут одинаковые, но собраны в разный момент времени, это ID-шники, скорее всего, какой-то рандомный ее автоинкремент.
504.88 508.68 "Анатолий Кулаков" Поэтому как ты сделаешь его уникальным для уже точно такой же PDB-шки?
508.68 518.00 "Игорь Лабутин" Не знаю пока, но я точно знаю, что Reproduceable Build тема интересная, и в Индии она, мне кажется, как-то мало продвигается, что ли, или фокусируется на ней.
518.00 523.64 "Игорь Лабутин" А вот в Linux мире она действительно важна, там тоже есть PDB-шки, так что ну как-то оно работает.
523.64 527.96 "Игорь Лабутин" Посмотрим, поглядим, в седьмом, вы знаете, наверняка, что-нибудь еще на эту тему внедрят.
527.96 535.20 "Анатолий Кулаков" Да, я надеюсь, что будет какая-нибудь отдельная статья, которая расскажет вообще, для чего это нужно, как это нужно, как это сделано и почему так долго не было сделано.
535.20 538.20 "Анатолий Кулаков" То есть вопросов много, было бы интересно в это закапаться.
538.20 539.20 "Игорь Лабутин" Да.
539.20 541.64 "Игорь Лабутин" Вторая большая часть – это Profile Guided Optimization.
541.64 553.44 "Игорь Лабутин" С ним интересно, то есть мы его тоже много раз обсуждали, и казалось, что в шестом дотнете они все успеют допилить, но нет, все не успели, поэтому в шестом дотнете там все будет не до конца сделано.
553.44 556.72 "Игорь Лабутин" Но давайте сначала вспомним, что такое Profile Guided Optimization.
556.72 559.48 "Игорь Лабутин" В принципе, идея довольно простая.
559.48 567.52 "Игорь Лабутин" Скорее всего, ваш код вашего приложения при старте приложения делает почти всегда примерно одно и то же.
567.52 589.52 "Игорь Лабутин" И, например, если вы хотите сильно как-то ускорить старт, если вам это, например, сильно важно, то, наверное, можно попытаться как-то так переделать код, в смысле в момент сборки, либо в момент джета, или в момент раскладывания готового собранного кода в дл, чтобы при старте все было как-то пошустрее.
589.52 593.12 "Игорь Лабутин" Код лежал поближе, рядышком, или еще как-то.
593.12 611.68 "Игорь Лабутин" Плюс, если, например, с помощью Profile Guided Optimization вы понимаете, что какие-то куски исполняются редко или вообще не исполняются, какие-то там, не знаю, exception handlers, которые почти никогда не срабатывают, то можно пытаться их, например, вообще, например, не компилировать джетом при старте.
611.68 612.68 "Игорь Лабутин" Ну а зачем?
612.68 616.76 "Игорь Лабутин" В смысле не джетом, а не загружать, может быть, даже как-то.
616.76 632.32 "Игорь Лабутин" Ну, то есть, короче, пересортировать код внутри бинарничка, я бы сказал, чтобы весь код, который нужен при стартапе, лежал где-то рядом, чтобы он был рядом в памяти, а не нужно было бегать по всей огромной дл по разным памяти, сбрасывая кэш процессора.
632.32 634.44 "Игорь Лабутин" То есть, короче, всякие такие штуки можно.
634.44 646.44 "Игорь Лабутин" Одно, на самом деле, жило довольно давно, то есть такие тулы, так скажем, существовали, но такие тулы существовали только внутри Майкрософта, и они были прям очень сложными для использования.
646.44 654.68 "Игорь Лабутин" Они сами это признают, то есть для того, чтобы сделать это нормально для Visual Studio или для всего SDK или рантайма, они это делали на самом деле.
654.68 661.32 "Игорь Лабутин" Вот те самые Ngen, как я понимаю, частично могли использоваться всякие Profile Guided штуки.
661.32 667.52 "Игорь Лабутин" Что-то, по-моему, кстати, в Ngen можно было какие-то опсы передать, что-то там, типа собрать какой-то профиль, что-то, я не помню, не пользовался ни разу.
667.52 673.16 "Игорь Лабутин" И, в общем, все было так сложно, что в 6-ом Дотнете они подумали, решили, что, короче, давайте все переделаем вообще с нуля.
673.16 675.16 "Игорь Лабутин" Всю вообще идею Profile Guided.
675.16 678.08 "Игорь Лабутин" И у них было несколько целей.
678.08 689.60 "Игорь Лабутин" Во-первых, им нужны, то есть они считают, что не только им, а вообще девелоперам нужны тулы, которые позволят собирать эти данные, то есть профили как раз-таки достаточно легко.
689.60 694.12 "Игорь Лабутин" То есть надо понимать, что это не что-то, что делается прям во время рантайма внутри приложения.
694.12 705.16 "Игорь Лабутин" Это внешний тул, который смотрит на ваше приложение снаружи, понимает, как оно обычно работает, и на основе этого дает некоторую дополнительную инфу компилятору, либо всяким кроссгенам и прочим штукам.
705.16 715.92 "Игорь Лабутин" Второе, эта инфа, которая собрана в вашем приложении, нужно как-то ее хорошо, уметь легко отдать приложению либо компилятору, чтобы это нормально использовать.
715.92 724.32 "Игорь Лабутин" Дальше было бы неплохо, чтобы эти данные для профилей можно было как-то в Source Control положить, ну мало ли вам это зачем-то интересно.
724.32 738.92 "Игорь Лабутин" А кроме того, там я чуть дальше сейчас расскажу, это статические данные, которые собраны для внешних тулов, должно быть можно как-то использовать динамическим профайл гайдед оптимизейшн, подходом, про который мы сейчас чуть позднее поговорим.
738.92 757.36 "Игорь Лабутин" В общем, со всеми этими целями оказалось, что работы настолько много, что в шестом дотнете они только успели, скажем так, начать подготовку ко всему этому, сделать, я так понимаю, какие-то версии тулов, но пока это все вообще никак не выставлено в паблик, поэтому ждем седьмого дотнета.
757.36 762.56 "Игорь Лабутин" Так что этой штуки у нас, ну по сути, не будет доступна в шестом дотнете вроде как ни в каком виде.
762.56 766.60 "Анатолий Кулаков" Да, очень жалко, могли бы хотя бы какие-то мелкие экспериментальные вещи включить.
766.60 775.68 "Игорь Лабутин" Ну вот какие-то мелкие экспериментальные вещи, видимо, включены в формате динамического профайл гайдед оптимизейшн, dynamic pgo.
775.68 797.44 "Игорь Лабутин" Там как раз таки сказано, что, ну они говорят, что статический в основном входит в кроссген, а кроссген это мы помним по сути джит, который запускается отдельно и генерирует вам готовую сборку именно под ваш процессор, а динамическая профайл гайдед, она интегрирована прямо в сам джит, который как бы умеет это делать прямо на лету во время работы приложения.
797.44 804.92 "Игорь Лабутин" То есть он по мере работы приложения собирает какие-то данные, но эти данные полностью теряются, как только вы завершаете приложение.
804.92 816.84 "Игорь Лабутин" То есть это скорее не про оптимизацию времени стартапа, это скорее про оптимизацию внутренних ваших каких-то цепочек вызовов, которые можно пытаться оптимизировать, зная, как ваше приложение работает.
816.84 851.08 "Игорь Лабутин" То есть здесь немножко это все перекликается с tiered compilation, то есть если мы помним, у нас сейчас есть теперь штука, подназываем tiered compilation, которая работает так, что ваш метод джитится, но если он, допустим, в нем понимается, что какие-то там бранчи срабатывают чаще других или еще что-то, то его можно переджитить заново немножко по-другому, например, разложив там ассемблерные инструкции, чтобы, например, happy path или тот, который наиболее часто занимал меньшее количество инструкций, вы, например, делали какой-нибудь early exit.
851.08 879.20 "Игорь Лабутин" А в Regit как раз-таки Dynamic PGO позволяет сделать, например, такую штуку, что если у вас есть какой-нибудь вызов метода через интерфейс, то есть по сути это виртуальный вызов, он довольно дорогой, но если по статистике мы понимаем, что в среднем он всегда падает в один и тот же тип, в один и тот же класс, то выгодно добавить туда один простой type-check, и если этот type-check прошел, то мы сразу идем обычным call'ом, не виртуальным вызовом, а прям обычным call'ом в тот класс.
879.20 887.84 "Игорь Лабутин" А ну а если не прошел, тогда full-batch'имся на старый алгоритм, который там все правильно пробежится по метод-тейблам и все там правильно найдет, кто же это на самом деле.
887.84 896.92 "Игорь Лабутин" Вот, это позволяет прям, с одной стороны, вроде как дополнительная проверка, с другой стороны, если это действительно очень частый кейс, то этот частый кейс будет очень сильно заоптимизирован.
896.92 908.76 "Игорь Лабутин" Сейчас эта вся штука, она пока в формате opt-in, то есть ее нужно включить, поставив переменные .NET, подчеркиваю, tiered pgo, в единичку, и .NET, подчеркиваю, не tc, подчеркиваю, не qgit for loops.
908.76 912.44 "Игорь Лабутин" Там оптимизация циклов еще включается прикольнее, тоже в единичку.
912.44 916.56 "Игорь Лабутин" Ну и тогда будет у вас dynamic pgo.
916.56 927.12 "Игорь Лабутин" В crossgen2 там тоже был какой-то раздел в статье, но я не буду ничего распространяться, про crossgen у нас был большой отдельный выпуск подкаста, там ничего принципиально не поменялось, насколько я понимаю.
927.12 935.24 "Игорь Лабутин" Дальше раздел про security, как раз-таки мы немножко это затронули, Microsoft запаблишила security roadmap, как они называют.
935.24 945.44 "Игорь Лабутин" Это на самом деле такой прикольный документ, мы его наверное отдельно рассмотрим, где расписано о чем нужно думать, чтобы ваш код был секьюрный, можем потом обсуждать.
945.44 950.12 "Игорь Лабутин" А в .NET 6, конкретно если говорить про .NET, завезли две штуки.
950.12 977.00 "Игорь Лабутин" Во-первых, есть такая штука, как, сокращается как CAT, Control Flow Enforcement Technology, и эта штука позволяет, это процессорная фича, насколько я понимаю, которая позволяет проверять, что приложение не меняет себе прямо Control Flow во время исполнения, ну типа не патчит ассемблерный код прямо на лету, чтобы, например, там, ретурны возвращались в другие места, ну и так далее.
977.00 988.08 "Игорь Лабутин" То есть, как я понимаю, это делается через какой-то shadow stack, то есть есть stack, call stack, в котором имеет доступ к программам, есть shadow stack, который контролирует процессоры, который периодически сверяет, что они вообще говоря одинаковые.
988.08 999.64 "Игорь Лабутин" И если вы в основном стеке что-то поподменяли, там ретурн адреса, например, то это как бы процессорный ошибка, ну не ошибка, а какой-то exception, и вам не дадут ничего исполнять после этого.
999.64 1003.84 "Игорь Лабутин" Таким образом они борются, понятно, со всякими патчерами, которые пытаются что-то пропатчить.
1003.84 1014.84 "Игорь Лабутин" И такая же фигня с write XOR executable, wxorx, мы тоже это обсуждали, что теперь страничка не может быть одновременно для записи и для исполнения.
1014.84 1018.20 "Игорь Лабутин" На маке это прям теперь обязательно, на новом m1.
1018.20 1026.04 "Игорь Лабутин" Ну и в остальных местах это пока выключено, то есть это нужно включать, либо дождать 7.net, там это будет включено по дефолту.
1026.04 1033.12 "Игорь Лабутин" Так, дальше, что у нас есть еще, не маленький раздел про HTTP/3, но у нас есть отдельная статья, поэтому мы поговорим про это чуть дальше.
1033.12 1048.48 "Игорь Лабутин" И мы тоже говорили про SDK Workloads, сейчас они добавили возможность по сути добавлять кусочки SDK после того, как вы SDK уже поставили через .NET Workload, там add или remove, ну или как там, uninstall.
1048.48 1066.96 "Игорь Лабутин" И идея состоит в том, что сейчас это пока относится только в основном к MAUI, ну и Android, iOS разработке и WebAssembly, но план у них такой, но это не к 6.NET, мы увидим все-таки в следующем .NET, что больше компонентов изнутри SDK будут вытащены наружу и распространятся именно в виде Workloads.
1066.96 1073.16 "Игорь Лабутин" То есть если вы, например, девелопите только для десктопа, то вам вообще говоря не нужен iSP.NET, он будет отдельным Workload.
1073.16 1083.60 "Игорь Лабутин" И так сказать, то что они называют Ultimate Goal заключается в том, что в SDK будут входить только MSBuild, но GIT и компиляторы, а все остальное вы ставите уже Workloadами, которые вам нужны.
1083.60 1084.60 "Игорь Лабутин" С чем работаете, тем и ставите.
1084.60 1092.72 "Игорь Лабутин" Это то, что вошло в статью про .NET 6 и релиз кандидата 1, но как всегда есть же конечно парная статья про iSP.NET.
1092.72 1105.08 "Игорь Лабутин" И тут прям на самом деле изменений довольно много, они все небольшие, но как обычно, чем ближе к релизу, тем изменений становится меньше и больше как полировочные.
1105.08 1106.88 "Игорь Лабутин" Довольно много вещей про Blazor.
1106.88 1111.52 "Игорь Лабутин" Я сейчас Blazor никак не занимаюсь, поэтому не могу сильно прокомментировать, чисто по заголовкам пробегусь.
1111.52 1116.76 "Игорь Лабутин" Может быть, если ты что-то знаешь или слышал про это, может что-нибудь прокомментируешь.
1116.76 1123.40 "Игорь Лабутин" Теперь можно Blazor компоненты рендерить прямо с JavaScript, то есть прямо с JavaScript можно написать явный код, типа вот здесь отрендери пожалуйста Blazor.
1123.40 1131.00 "Игорь Лабутин" В Blazor появились кастомные элементы, то есть можно создавать какие-то свои кастомные элементы помимо видимо стандартных кнопочек и так далее.
1131.00 1144.36 "Игорь Лабутин" Из Blazor теперь можно сгенерить, как я понимаю, стандартную обертку, так что Blazor компонента будет считаться ангулярной либо реактовой компонентой, и их можно нативно будет использовать из ангулярной реакт-приложения.
1144.36 1158.68 "Игорь Лабутин" Можно теперь, кстати, по-моему мы говорили уже, но тем не менее почему-то это включено именно сюда, можно теперь трогать queryStroke из браузера, из Blazor, и в том числе ее менять, но по-моему это уже было.
1158.68 1165.00 "Игорь Лабутин" И мы обсуждали, что можно было стримить из JavaScript в .NET, если я правильно помню, теперь можно в обратном направлении из .NET в JavaScript.
1165.00 1170.28 "Игорь Лабутин" Для этого теперь есть классик .NET StreamReference, и через него все это как-то делается.
1170.28 1177.56 "Игорь Лабутин" В MouseEvent завезли PageX и PageY, вообще интересно, потому что как может быть MouseEvent без координат, что там было раньше.
1177.56 1184.40 "Игорь Лабутин" В темплейты добавили возможность проставлять сразу патч тайтл, ну типа в темплейтах по дефолту, там патч тайтл можно легко менять.
1184.40 1204.60 "Игорь Лабутин" И убрали, это важный change, это breaking change на самом деле, по дефолту, если у вас есть транспорт для Blazor сервера, ну как мы знаем он там будет пытаться работать через веб-сокеты, а если веб-сокеты почему-то не работают, то он переключался на long polling, чтобы слушать, что там сервер ему скажет и перерисовать вовремя.
1204.60 1213.60 "Игорь Лабутин" Так вот теперь по дефолту long polling выключен, и если у вас вдруг почему-то не настроены или там как-то не работают веб-сокеты, то у вас ничего не будет работать.
1213.60 1226.92 "Игорь Лабутин" Это сделано специально потому что веб-сокеты все-таки primary транспорт и именно он в основном должен работать, и если вдруг веб-сокеты не работают, то лучше об этом узнать заранее, а не выяснять что он на самом деле зафолпэтчился на long polling.
1226.92 1231.76 "Игорь Лабутин" Но всегда можно вернуть обратно дефолтовое поведение старое и заимлить.
1231.76 1249.08 "Игорь Лабутин" Для Razer завезли теперь такую штуку, можно теперь, если у вас есть например там index.cshtml или index.razr, теперь можно написать файлик вида index.razr.js или index.cshtml.js и туда написать JavaScript в дополнение.
1249.08 1255.56 "Игорь Лабутин" То есть у нас теперь есть Razer, к нему можно написать C#, теперь к нему еще можно написать JavaScript рядышком.
1255.56 1259.80 "Игорь Лабутин" Все это будет скомбинировано соответственно при рендеринге.
1259.80 1275.24 "Игорь Лабутин" И появилась возможность запускать JavaScript-овый код перед и после того, как запускается прям целиком Blazor-овое приложение, если вам нужно что-то настроить, то можно теперь написать кусочек кода, который будет JavaScript выполнять перед и после загрузки вашего Blazor-ового приложения.
1275.24 1278.60 "Игорь Лабутин" Это все про Blazor, но это не все про SPNet.
1278.60 1297.00 "Игорь Лабутин" Наверняка если вы хоть как-то следите за твиттером, назовем это так, вы наверняка видели кучу обсуждений про всякие, что меняется в шаблонах, что меняется в Minimal API, это вообще сейчас какая-то трендовая тема про SPNet.
1297.00 1316.40 "Игорь Лабутин" Но короче, в шаблонах Microsoft прислушивалась к комьюнити и сказала, что ладно, implicit usings, вот те, которые global usings, которые можно один раз написать и на весь C++ использовать, это теперь фича по дефолту opt-in, то есть в стандартном темплейте она теперь использоваться не будет, по умолчанию ее можно включить, но по дефолту темплейт генериться без нее.
1316.40 1339.96 "Игорь Лабутин" И второе, что раньше, когда вы создавали проект, ну через шаблон, то у вас назначался порт для HTTP и порт для HTTPS в launch-settings.json, они были все стандартные, 5000, 5001, теперь они будут рандомные, то есть при создании проекта у вас будет какой-то рандомный порт для HTTP выбираться и какой-то рандомный порт для HTTPS.
1339.96 1349.54 "Игорь Лабутин" При этом если вы запаблишите приложение, I know все равно будет прям строго на 5000, на 5001, как и было раньше, чтобы при паблише ничего не ломалось, но при разработке будет рандом.
1349.54 1360.52 "Игорь Лабутин" Чуть-чуть поправили дефолтовые логи, по дефолту теперь только namespace microsoft.sql.core стал варнинговым, все остальное на уровне information.
1360.52 1383.04 "Игорь Лабутин" Это означает, что на самом деле у вас теперь все компоненты, которые находятся в namespace microsoft начнут писать инфологи, раньше они были выключены, то есть у вас появятся логи от хостинга, которые частично были включены, и у вас появятся логи, например, от Entity Framework, типа по дефолту Entity Framework будет вам писать кверки, которые он выполняет.
1383.04 1385.72 "Игорь Лабутин" С таймингами и так далее.
1385.72 1390.84 "Игорь Лабутин" Мне кажется, поудобнее, хотя я не пробовал на практике, может быть там будет слишком много логов.
1390.84 1403.08 "Игорь Лабутин" Minimal API, тут все по чуть-чуть, они просто по чуть-чуть улучшают, добавили немножко способов как-то развесить метаданные на minimal endpoints, чтобы OpenAPI генерировалось правильно.
1403.08 1410.32 "Игорь Лабутин" Можно теперь задавать optional параметры в экшенах, и структура там правильно биндится.
1410.32 1421.16 "Игорь Лабутин" По дефолту теперь сразу подключается Developer Exception Page Middleware, если вы в Development Environment, раньше нужно было сами писать, теперь это все само.
1421.16 1429.56 "Игорь Лабутин" Чем-то поддержали Lightning 1 Encoded Request Headers, по мне кажется, что там всегда ASCII в хедерах, но видим, кто-то пользуется не только ASCII.
1429.56 1443.72 "Игорь Лабутин" И полезная фича, если у вас что-то не так работает с Kestrel, и вы как-то пытаетесь понять, с какими опциями стартует Kestrel, Kestrel теперь генерирует специальный вентик через Event Source механизм, куда в JSON-чике вываливает свою полную конфигурацию.
1443.72 1447.60 "Игорь Лабутин" Так что если вам интересно, как сконфигурирует ваш Kestrel, то вперед.
1447.60 1458.36 "Игорь Лабутин" И дальше, в ISI, когда мы используем SPNet Core модуль, он пишет какие-то логи, вот теперь в эти логи включен PID, чтобы было понятно, какой процесс ISI за это ответственен.
1458.36 1462.08 "Игорь Лабутин" Добавились и венты, опять же, это не логи, но и венты.
1462.08 1472.64 "Игорь Лабутин" Если Kestrel либо SPNet сам по себе реджектит какой-то реквест по своим внутренним причинам, раньше было вообще непонятно почему, теперь он генерирует ивент, где в ивенте будет написано причина.
1472.64 1488.80 "Игорь Лабутин" И последнее, это они проапгрейдили в шаблончике Identity Server 4 на последнюю версию, теперь это Duende, с соответствующей лицензией, то есть помните, что если вы берете новый шаблон и используете его для коммерческих каких-то целей, то нужно платить будет за лицензию нового Identity Server.
1488.80 1490.80 "Игорь Лабутин" Вот, примерно такие изменения.
1490.80 1495.60 "Игорь Лабутин" Про EF Core, как обычно, никаких новостей, там скорее всего просто полируют, фиксят баги и все.
1495.60 1501.60 "Анатолий Кулаков" Слушай, ну вместе с релизом, я думаю, очень многие ждали кроссплатформенного нашего Маюя.
1501.60 1506.68 "Анатолий Кулаков" Что там у них с нашими UI-чиками-то?
1506.68 1510.68 "Анатолий Кулаков" Будет у нас красивый кроссплатформенный убийца Авалони или нет?
1510.68 1511.68 "Игорь Лабутин" Будет, но не сразу.
1511.68 1525.92 "Игорь Лабутин" Значит, действительно, мы надеялись, что Мауй зарелизится вместе с Dota 6 в ноябре, но команда, видимо, не успевает по каким-то причинам, и для продакшена в ноябре готова не будет.
1525.92 1535.80 "Игорь Лабутин" Сейчас у них план такой, что для продакшена, то есть для General Availability, они целятся во второй квартал 2022 года, то есть там, не знаю, апрель-май.
1535.80 1540.16 "Игорь Лабутин" У них написано early q2, так что, наверное, там апрель-май.
1540.16 1561.44 "Игорь Лабутин" При этом все фичи, которые они планируют, будут доступны в ноябре, но всякие, видимо, достаточно много багов и достаточно много то, что они называют Customer Feedback, то есть каких-то комментариев от тех, кто уже использует, что нужно больше полировать, и, видимо, вот им еще нужно полгодик, чтобы дополировать до конца.
1561.44 1564.32 "Игорь Лабутин" При этом вышел превью 8, как-то так тихо и незаметно.
1564.32 1574.64 "Игорь Лабутин" Есть небольшие изменения, он включен в превью 4, вижу, в студии, там теперь можно при инсталляшке выбрать прям DotNet Maui, и он поставится.
1574.64 1588.24 "Игорь Лабутин" К самому льхот релоуд, мы много раз обсуждали льхот релоуд, он прекрасно работает на андроиде, аосе и винде, и DotNet хот релоуд тоже работает прекрасно на андроиде, аосе и винде.
1588.24 1593.84 "Игорь Лабутин" Плюс они увеличивают, кстати, количество вещей, которые этот хот релоуд переживает.
1593.84 1611.32 "Игорь Лабутин" Если вы помните, мы обсуждали, что хот релоуд, это по сути похоже на Edited Continue в дебаггере, и что начинали они с полностью идентичного, как я понимаю, списка вещей, сейчас они в хот релоуд добавляют все больше и больше разных штук, так что потихонечку это становится все более крутой штукой.
1611.32 1631.20 "Игорь Лабутин" Ну и они заюзали в Maui такой же паттерн, как они используют в SPNet и всех остальных, то есть там HostBuilder, то есть теперь у вас есть MauiProgram.createMauiApp, дальше вам создается App, где уже настроены всякие dependency injection и все такое, в общем, подход похожий на то, что вы знаете по SPNet и всяким другим кусочкам платформы.
1631.20 1634.76 "Игорь Лабутин" Так что вот, да, это удобно, ну, по крайней мере, какое-то единообразие.
1634.76 1638.48 "Игорь Лабутин" Ну а в целом ждем, как это будет развиваться, посмотрим,
1638.48 1650.44 "Анатолий Кулаков" что получится. Хорошо, еще другая хайповая тема, которую ты обещал нам рассказать про HTTP/3, что там происходит, насколько протокол быстр, когда он будет и насколько его поддерживает, в принципе, все остальное.
1650.44 1666.52 "Игорь Лабутин" Ну, насколько быстр и насколько все остальное поддерживает, пока сказать трудно, то есть ну вроде как он быстрый, его дизайн заключался в том, что он должен быть а) быстрый, б) переживать смену сети и вообще не пользоваться TCP, потому что TCP придумывался давно и UDP гораздо круче в современных сетях.
1666.52 1677.82 "Игорь Лабутин" Но практическая плоскость этого дела заключается в том, что поддержка HTTP/3, она сейчас довольно разная на разных платформах и общая ситуация примерно следующая.
1677.82 1684.52 "Игорь Лабутин" На винде .NET использует библиотечку под названием MSQuick для того, чтобы работать с этим протоколом.
1684.52 1692.76 "Игорь Лабутин" Это, вообще говоря, open-source на кроссплатформе библиотечка от сетевой команды Windows.
1692.76 1706.00 "Игорь Лабутин" Они хотят делать Windows, но они написали кроссплатформенную библиотечку, но используют они ее, я так понимаю, практически исключительно только на Windows, потому что есть проблемы на остальных операционках с авторизацией.
1706.00 1733.28 "Игорь Лабутин" Для QuickA, TLS должен входить в состав этой Quick библиотечки, это есть не везде, поэтому на Linux они запартнерились с конторой Akamai, сделали форк OpenSSL, назвали его QuickTLS, но это как бы не форк, видом мы там форкнули и больше не трогаем, а это практически всегда последний OpenSSL с кусочками патчей поверх, которые именно включают то, что нужно для Quick.
1733.28 1739.12 "Игорь Лабутин" Это все запаковано для Linux дистрибутивов, соответственно в Linux и .NET тоже умеет работать с Quick.
1739.12 1740.76 "Игорь Лабутин" А вот на MacOS пока нет.
1740.76 1743.84 "Анатолий Кулаков" И назад они это вливать не собираются, этот QuickTLS?
1743.84 1756.56 "Игорь Лабутин" Собираются, они ждут OpenSSL 3.0 или что-то, какой-то 3.x, по-моему вроде в 3.0 общалось, что будет уже нормальная поддержка, то есть как только выйдет 3.0, то все можно будет сразу перейти на нормальный OpenSSL.
1756.56 1772.48 "Игорь Лабутин" Или когда дистрибутивы заадоптят этот OpenSSL 3.0, я уже не знаю, не вчитывался в детали, но смысл в том, что каким-то образом .NET и Microsoft сделали так, что на Windows и Linux Quick можно по крайней мере попробовать потрогать.
1772.48 1783.16 "Игорь Лабутин" При этом на Linux нужно ручками добавить вот эту либо MSQuick, а для винты вам нужен Windows 11 обязательно или 2022 сервер, на десятки не заработает.
1783.16 1798.88 "Игорь Лабутин" Дальше, для того чтобы это все включить нужно пойти в Kestrel и включить Preview Features, это через, ну делается либо через C-Sproj, там нужно добавить Enable Preview Features, по-моему называется опция, и просто в Protocols при конфигурации Kestrel поставить, что вы хотите HTTP 3.
1798.88 1810.68 "Игорь Лабутин" HTTP Client тоже проапдейтился для поддержки HTTP 3, там нужно его тоже включить через отдельный runtime флаг, и для каждого реквеста указывают, что вы хотите его именно по HTTP 3.
1810.68 1838.76 "Игорь Лабутин" При этом если вы живете на сервере 2022, то вы можете заиспользовать не ISP.NET поддержку HTTP 3 в Kestrel и всем таком, а в Ease и HTTP Seed, там она есть, ее нужно включить через реестр, но тогда вы можете использовать хоть какой-нибудь старый, пятый .NET, старый, и он тоже будет прекрасно работать с HTTP 3, потому что в этом случае, собственно, именно HTTP частью занимается, понятное дело, Ease, а вам только реквестики уже приходят.
1838.76 1848.60 "Игорь Лабутин" При этом, как мы знаем, HTTP 2, одна из причин появления HTTP 2 был gRPC, ну по крайней мере они очень хорошо вместе дружат.
1848.60 1857.72 "Игорь Лабутин" Так вот, Microsoft подумала и сказала, давайте мы попробуем gRPC поверх HTTP 3, и предложила это как бы стандартизировать.
1857.72 1863.04 "Игорь Лабутин" Пока там все на очень ранней стадии, но может быть это станет тоже каким-то стандартом.
1863.04 1887.52 "Игорь Лабутин" Пользователи MacOS пока обделены, там нет нормальной поддержки, как я сказал, TLS API для Quik, и можно было бы как бы пересобрать тоже что-то как-то кроссплатформерное, но Microsoft сказала, что там слишком много проблем с Security Patch, я не понимаю, почему там есть какая-то разница с Linux, но тем не менее какая-то есть, и поэтому MacOS пока ждет, пока у них появится нормальный TLS API именно для Quik.
1887.52 1888.52 "Игорь Лабутин" Ну примерно так.
1888.52 1908.28 "Игорь Лабутин" А, ну и главный вывод, в R6.NET никаких как бы таких прям явных API-шек ничего не экспонуется, то есть это все нужно прям явно включать кучу, вот как я сказал, флагов, опций и так далее, ручками добавлять в библиотеки, то есть если вам очень хочется попробовать потрогать, пожалуйста, можно, но это прям нелегко.
1908.28 1914.48 "Игорь Лабутин" Ну и на этом, наверное, все из таких больших новостей того, что мы знаем про DotNet 6.
1914.48 1918.12 "Анатолий Кулаков" Хорошо, давай тогда немножко отвлечемся и поговорим про архитектуру.
1918.12 1931.60 "Анатолий Кулаков" Я тут недавно столкнулся с такой идеей, что новомодные рекорды, ну как новомодные, из C# 9 вполне отлично подходят под описание value-objects из терминологии domain-driven design.
1931.60 1939.68 "Анатолий Кулаков" И начал немножко копать эту тему, нашел прекрасную статью Владимира Хурикова, который как раз-таки и прорабатывает этот вопрос.
1939.68 1941.24 "Анатолий Кулаков" Давайте непосредственно об этом поговорим.
1941.24 1955.08 "Анатолий Кулаков" Итак, переключаемся с фреймворков в DDD и вспоминаем, что в принципе один из основных конструкторов вашего домена обычно являются value-объекты и entity-объекты.
1955.08 1968.64 "Анатолий Кулаков" Разница между этими понятиями в том, что у value-объекта нет какого-то идентификатора, а entity, они постоянно находятся с самым идентификатором и живут непосредственно вместе с ним.
1968.64 1990.72 "Анатолий Кулаков" Чтобы представить value-объекты, это такие классы, например, как деньги или какой-нибудь идентификатор или что-нибудь еще, то есть такие какие-то обычные мелкие незначительные классики, которые живут своей жизнью и у которых нет какой-то богатой истории, у которых нет идентификатора, который можно создавать когда угодно и так далее.
1990.72 1994.72 "Анатолий Кулаков" В принципе, value-объекты еще должны соответствовать нескольким правилам.
1994.72 2000.56 "Анатолий Кулаков" Прежде всего, кроме того, что у них нет идентификатора, они обычно сравниваются по структуре по своей.
2000.56 2007.92 "Анатолий Кулаков" То есть, если у нас есть 50 рублей, то абсолютно неважно, откуда пришли эти 50 рублей, кому они принадлежат и прочее.
2007.92 2009.68 "Анатолий Кулаков" Главное, что у них циферка 50 и что они рублей.
2009.68 2014.84 "Анатолий Кулаков" Если же мы говорим про entity, то там в основном принято сравнение по идентификатору.
2014.84 2019.20 "Анатолий Кулаков" Например, юзера обычно это сущности, представленные в виде entity.
2019.20 2023.56 "Анатолий Кулаков" Их сравнивают по имени или по какому-нибудь более уникальному полю типа e-mail.
2023.56 2025.76 "Анатолий Кулаков" И неважно, какие поля там у них есть внутри.
2025.76 2032.96 "Анатолий Кулаков" Еще обычно value-объекты это неизменяемые объекты.
2032.96 2034.60 "Анатолий Кулаков" Необычно, а точно.
2034.60 2039.76 "Анатолий Кулаков" Потому что если вам хочется изменить value-объект, то скорее всего это entity и вы их неправильно разделили.
2039.76 2045.40 "Анатолий Кулаков" Вот это так по поверхности, если вдруг кому-то вспомнить, чем заключаются value-объекты.
2045.40 2050.00 "Анатолий Кулаков" Теперь давайте сравним это с рекорд-классами, которые у нас появились в C# 9.
2050.00 2055.64 "Анатолий Кулаков" И когда мы начинаем их сравнивать, мы понимаем, что примерно семантика того, что я сказал, отслеживается в рекордах.
2055.64 2057.28 "Анатолий Кулаков" Ну, прежде всего рекорды.
2057.28 2061.96 "Анатолий Кулаков" Они прекрасны тем, что их можно записать в виде одной строчечки.
2061.96 2065.64 "Анатолий Кулаков" Очень заманчиво сделать value-объект в виде одной строчки.
2065.64 2068.60 "Анатолий Кулаков" Кажется, что с помощью них можно написать красивые домены.
2068.60 2069.60 "Анатолий Кулаков" Далее рекорда.
2069.60 2073.16 "Анатолий Кулаков" Есть публичный конструктор, который принимает обязательно все поля на вход.
2073.16 2080.40 "Анатолий Кулаков" И init-only свойства, которые задаются через конструктор или через init-метод.
2080.40 2082.12 "Анатолий Кулаков" И после этого никогда не меняются.
2082.12 2083.92 "Анатолий Кулаков" То есть рекорды у нас тоже иммьютабельные.
2083.92 2087.68 "Анатолий Кулаков" И также у рекордов переопределены методы equals.
2087.68 2091.80 "Анатолий Кулаков" То есть и getHashCode, и equality.
2091.80 2097.68 "Анатолий Кулаков" Для того, чтобы как раз-таки обеспечить сравнивание объектов по их структуре, а не по их идентификатору.
2097.68 2101.28 "Анатолий Кулаков" Вот это тоже очень смахивает на те value-объекты, которые мы упоминали выше.
2101.28 2106.32 "Анатолий Кулаков" С первого взгляда кажется очень заманчивым использовать рекорды для value-объектов.
2106.32 2110.72 "Анатолий Кулаков" Но если мы начинаем копать глубже, то с этим есть несколько проблем.
2110.72 2113.00 "Анатолий Кулаков" Давайте эти проблемы как раз-таки рассмотрим.
2113.00 2117.48 "Анатолий Кулаков" Прежде всего рекорды сейчас не имплементят интерфейс IComparable.
2117.48 2121.72 "Анатолий Кулаков" Этот интерфейс как раз-таки и говорит, что рекорд может сравниваться с другим рекордом.
2121.72 2125.72 "Анатолий Кулаков" У него переопределены всякие equals, но до этого интерфейса почему-то не дошли.
2125.72 2131.52 "Анатолий Кулаков" Может быть это какое-то временное решение, и в будущем я не вижу причин, почему бы этого не добавить.
2131.52 2137.12 "Анатолий Кулаков" Но существует следующая проблема, и она нам верна немножко более глобальная.
2137.12 2138.12 "Анатолий Кулаков" Это инкапсуляция.
2138.12 2151.76 "Анатолий Кулаков" В DDD нам есть несколько постулатов, которые требуют от нас создавать объекты, полностью инкапсулирующие внутреннее состояние и гарантирующие нам консистентность своих свойств.
2151.76 2157.76 "Анатолий Кулаков" То есть то, что все свойства у них отвалидированы, проверены, правильные и красивые.
2157.76 2160.20 "Анатолий Кулаков" Объект не может существовать в невалидном состоянии.
2160.20 2168.28 "Анатолий Кулаков" Если же мы говорим о рекордах, то у них есть публичный конструктор, с помощью которого эти рекорды создаются.
2168.28 2173.60 "Анатолий Кулаков" И вполне можно передать в конструктор какие-нибудь невалидные аргументы.
2173.60 2183.60 "Анатолий Кулаков" Естественно, внутри аргументы можно проверить, но существует такой код смайл, что очень большую валидацию в конструкторе делать не стоит.
2183.60 2187.64 "Анатолий Кулаков" И вообще выполнять какие-то сложные долгоиграющие методы в конструкторе делать не нужно.
2187.64 2193.68 "Анатолий Кулаков" Там обычно делают какую-то легкую валидацию, чисто на null и на пустоту, и инициализируют свойства.
2193.68 2195.36 "Анатолий Кулаков" Вот в принципе и все.
2195.36 2208.36 "Анатолий Кулаков" Если вам нужно проверить формат, попытаться распарсить или еще куда-то сходить и проверить на какие-то сложные рулы, то обычно делают статический метод и выносят все эти валидации туда.
2208.36 2215.24 "Анатолий Кулаков" А это также хорошо, потому что единственный способ вернуть ошибку из конструктора - это бросить исключения.
2215.24 2219.48 "Анатолий Кулаков" И исключения в принципе это плохая идея.
2219.48 2223.28 "Анатолий Кулаков" Исключения в таких местах лучше не бросать по многим причинам.
2223.28 2234.40 "Анатолий Кулаков" А если мы сделаем отдельный статический метод, то мы вполне можем возвращать результат не в виде исключений, а в виде какого-то более понятного диагностического описания, которое нам скажет в каком поле какая ошибка и почему была сделана.
2234.40 2246.72 "Анатолий Кулаков" Если мы говорим, что инкапсуляция в нашем доме не важна и делаем такой статический конструктор, по сути статический в Factory метод, то оригинальный конструктор от рекорда нам придется сделать приватным.
2246.72 2252.80 "Анатолий Кулаков" И именно в этот момент теряется вся привлекательность однострочника рекордового.
2252.80 2260.32 "Анатолий Кулаков" Потому что если мы хотим приватный конструктор, нам придется его расписывать вручную, все поля перемапливать вручную и все, вся магия рекордов теряется.
2260.32 2266.96 "Анатолий Кулаков" Кроме инкапсуляции есть еще другие проблемы.
2266.96 2278.48 "Анатолий Кулаков" Часто бывает необходимо сравнивать не все свойства, которые есть у данного рекорда, а только некоторые из них, а какие-нибудь диагностические пропустите, типа стектрейса или еще чего-нибудь.
2278.48 2280.60 "Анатолий Кулаков" В общем, это в эквалите не должно участвовать.
2280.60 2289.08 "Анатолий Кулаков" В таком случае вам придется переписать все методы сравнения ручками и опять же теряется очень большая часть сгенерированных рекордов.
2289.08 2294.00 "Анатолий Кулаков" С сравнением есть еще одна проблема у рекордов.
2294.00 2299.80 "Анатолий Кулаков" Несмотря на то, что поля сравниваются нормально, как положено по значению, коллекция сравнивается все еще по ссылкам.
2299.80 2313.24 "Анатолий Кулаков" То есть, допустим, если у вас в рекорде есть какой-то список, лист или массивчик, то вы получите в сгенерированном рекорде сравнение только по референсу, что обычно не то, что нам нужно.
2313.24 2314.36 "Анатолий Кулаков" Абсолютно не то.
2314.36 2327.20 "Анатолий Кулаков" Поэтому у рекордов есть очень много проблем, когда мы говорим об использовании их именно как value object и хотим соблюсти всю семантику value object.
2327.20 2332.40 "Анатолий Кулаков" То есть, в принципе-то рекорды не очень подходят.
2332.40 2336.08 "Анатолий Кулаков" Давай же посмотрим, для каких вещей рекорды подходят.
2336.08 2339.88 "Анатолий Кулаков" Мы как-то поднимали этот вопрос в нашем чатике с патронами.
2339.88 2343.36 "Анатолий Кулаков" Игорь, ты рекорды используешь с тех пор, как они вышли в своем коде?
2343.36 2348.96 "Игорь Лабутин" По-моему, только один проект у меня был, где я их смог чуть-чуть начать использовать, но не более того.
2348.96 2358.16 "Анатолий Кулаков" У меня вот вспоминается, что когда мы новые фичи все шарпо озвучивали, то рекорды – это была одна из самых многообещающих и многожданных фич.
2358.16 2361.72 "Анатолий Кулаков" Но, как показала практика, у меня они тоже используются довольно-таки редко.
2361.72 2369.32 "Анатолий Кулаков" Владимир советует присмотреться на следующие юзкейсы, где рекорды все еще могут себя проявить.
2369.32 2372.32 "Анатолий Кулаков" Во-первых, это fluent interface шаблон.
2372.32 2388.28 "Анатолий Кулаков" Это так называемые билдеры, когда вы пишете, когда нужно собрать какой-то сложный объект, и вы к нему дописываете кучу методов, которые принимают по одному, по два свойства, с понятными именами, с понятными типами, и таким образом с помощью этой цепочки собираете что-то сложное.
2388.28 2398.48 "Анатолий Кулаков" С помощью рекордов мы можем немножко облегчить эту ситуацию, потому что у них появилось ключевое слово "with", с помощью которого мы можем очень красиво изменять рекорд.
2398.48 2407.08 "Анатолий Кулаков" То есть объявить его с помощью одной строчки и с помощью "with" эмулировать все те методы, которые мы бы добавляли вручную в этот билдер.
2407.08 2410.80 "Анатолий Кулаков" Здесь нам все делает компилятор автоматически.
2410.80 2412.24 "Анатолий Кулаков" Вот интересный юзкейс.
2412.24 2421.12 "Анатолий Кулаков" Также рекорды удобно использовать для всяких временных классов, когда нужно передать какие-нибудь структурки данных, но они чуть больше, чем один класс.
2421.12 2427.56 "Анатолий Кулаков" Например, упаковать 2, 3, 4, 5 каких-то переменных в классик и передать куда-то или отдать.
2427.56 2440.24 "Анатолий Кулаков" Это очень похоже на результат классы, то есть, например, если вы компилируете C# с помощью рослина, вам возвращается уже результат класс, который содержит диагностическую информацию, какие-нибудь подробности о компилировании и так далее.
2440.24 2450.64 "Анатолий Кулаков" В принципе, с появлением туплов эта ниша тоже, мне кажется, немножко занята, потому что туплы, особенно именованные туплы, довольно хорошо решают эту проблему без декларации всяких рекордов.
2450.64 2461.40 "Анатолий Кулаков" Но может быть, если мы говорим про какие-нибудь передачи между сборками или более глобальные границы контекста, то там все еще можно эти рекорды туда натянуть.
2461.40 2484.44 "Анатолий Кулаков" Ну и если вы все-таки делаете не какой-то очень богатый домен, для вас не так важна инкапсуляция, не так важна возможность структурного сравнения с учетом коллекций, то рекорды – это все еще может быть неплохим решением для value-object, но с учетом всех этих вышесказанных оговорок.
2484.44 2495.72 "Анатолий Кулаков" Нужно признаться, что у Владимира есть еще одно предложение, как делать красивые value-object, но об этом я предлагаю вам почитать самим в его статейке.
2495.72 2496.72 "Игорь Лабутин" Прекрасно.
2496.72 2511.08 "Игорь Лабутин" Это действительно интересно, что есть много разных фич C#, которые мы обсуждали, какие-то нам нравятся больше, какие-то нам нравятся меньше, а в итоге выстреливают или пользуемся совсем не теми, которыми мы считали, что будем пользоваться.
2511.08 2513.32 "Анатолий Кулаков" Посмотрим, что будет с 10 C#.
2513.32 2517.92 "Анатолий Кулаков" Да, а 10 C# у нас будет работать только в новой студии 2022.
2517.92 2524.28 "Анатолий Кулаков" Я надеюсь, это только в релиз кандидате, потому что релиз новой студии мы не получим еще довольно таки долго.
2524.28 2557.24 "Игорь Лабутин" Это, кстати, очень непонятный вопрос, то есть даже его задавали на самом деле к статье, по-моему, 2006, релиз кандидате, про то, что вы говорите, что там, и я говорил, что там требуется превью 4, значит ли это, что Visual Studio 2022 релизится тоже в ноябре, на что Ричард Лендер сказал, что ну вообще говоря, команда Visual Studio нам еще ничего не говорила, ну может внутри-то, конечно, говорила, но для паблика считаем, что не говорила, и ждем какого-то пресс-релиза именно от команды Visual Studio, чтобы понимать, что будет.
2557.24 2567.20 "Игорь Лабутин" Хотя, как я понял, Microsoft не исключено, что .NET 6 будет зарелизен, при этом студия может быть, например, да, релиз кандидатом, возможно, кто знает.
2567.20 2568.56 "Игорь Лабутин" Посмотрим, не знаю пока.
2568.56 2573.96 "Анатолий Кулаков" Ну обычно это странная ситуация, такого не бывает, обычно у нас есть какая-то студия, которая работает со свежим .NET.
2573.96 2582.76 "Игорь Лабутин" Да, ну посмотрим, что будет, всегда что-то бывает первый раз, тем более правда .NET 6 это вроде как LTS релиз, было бы неплохо поддержать его какой-нибудь хорошей студией.
2582.76 2618.00 "Игорь Лабутин" Тем не менее, пока вышло 2022 превью 4, не то, чтобы там сильно много, опять же, каких-то изменений, хотя они есть, в основном это все про productivity, например, они ускорили поиск в файлах, типа в 3 раза говорят, посмотрим, улучшили опыт с дебаггингом, то есть теперь вам, если вы хотите выбирать процесс, у вас там теперь есть не только дерево процессов, как мы помним, в прошлой превью появившиеся, но теперь его можно выбирать еще через выбор окна приложения, то есть у вас теперь есть window picker, вы просто можете взять, тыкнуть в какое-то окно и сказать, вот это хочу отлаживать, и он сам как бы поймет, что там за процесс.
2618.00 2656.48 "Игорь Лабутин" Мы уже обсуждали штуку под названием External Source, которая позволяет показывать исходнички внешних библиотек прямо в Solution Explorer, там еще немножко изменений, и они в превью 4 допилили фичу под названием Dependent Breakpoints, то есть зависимый брекпоинт, когда вы можете на одном брекпоинте поставить условие, что он энейблится только если сработал какой-то другой эндпоинт, сильно помогает в отладке сложных сценариев, когда у вас есть общая точка входа, из которой потом, например, вы проваливаетесь в несколько разных, не знаю, дочерних функций, а вам хочется брейкаться в родительские функции только когда вы провалитесь в какую-то очередную дочернюю, то есть можно попытаться как-то это все сделать на Dependent Breakpoints.
2656.48 2665.48 "Игорь Лабутин" Дальше, если вы вдруг пользовались превью 3 и у вас были какие-то проблемы с редакторами для Blazor или Eraser, обновитесь на превью 4, там говорят пофиксили много багов.
2665.48 2689.16 "Игорь Лабутин" Ход reload улучшился, как я говорил, дальше вы теперь можете раскрашивать ваши табы для файлов в разные цвета для более правильной визуальной группировки, не знаю, зачем это может быть надо, потому что, ну, не знаю, я навигирую все в основном с помощью Ctrl+T, что в Rider, что в Visual Studio, поэтому зачем еще табки раскрашивать разными цветами, ну, наверное, кто-то, кто визуально как-то это больше воспринимает, может быть,
2689.16 2697.12 "Анатолий Кулаков" полезно. По крайней мере, я видел такой плагин для Visual Studio, и у него было очень много скачиваний и рейтинга, ну, то есть люди, по идее, пользуются этим очень часто.
2697.12 2708.60 "Игорь Лабутин" По-моему, я его даже ставил, по-моему, этот плагин дополнительно позволял эти табочки сделать слева, по-моему, а не сверху, и как-то их еще группировать, я пытался им пользоваться года, наверное, 2 или 3 назад, но я не понял, зачем это.
2708.60 2726.76 "Игорь Лабутин" По большому счету, мне табка нужна для двух целей, ну, если у меня их там открыто 2-3, я могу по ним кликать мыши и переключаться, хотя я чаще буду тогда control tab просто использовать, а второе, я туда навожу мышку, чтобы посмотреть полный путь к файлу, ну, вот бывает нужно, типа, зачем-то на диск сходить, вот это место, я вот так делаю.
2726.76 2729.32 "Игорь Лабутин" Больше, в принципе, табы мне для чего не нужны.
2729.32 2730.32 "Игорь Лабутин" А, ну, закрыть.
2730.32 2736.84 "Анатолий Кулаков" Если наши слушатели пользуются плагином, который раскрашивает табики, придите в комментарии и расскажите нам, зачем вы это делаете.
2736.84 2737.84 "Игорь Лабутин" Да, будет интересно.
2737.84 2755.52 "Игорь Лабутин" В Solution Explorer теперь появилась клевая команда, по-моему, а может, не в Solution Explorer, по-моему, это в меню файла она появилась, называется Synchronize to Namespaces, и теперь, если вы ее выполните, то он посмотрит на все ваши cs-файлики и в каждом cs-файлике поставит namespaces, соответствующие тому, в каких папочках это находится.
2755.52 2758.32 "Игорь Лабутин" Подожди, это же появилось в ReSharper лет 10 назад.
2758.32 2761.00 "Игорь Лабутин" Ну, как обычно, а здесь появилось 4, а что, нормально.
2761.00 2764.08 "Игорь Лабутин" Я, кстати, не помню, такого в ReSharper он имеет, да?
2764.08 2774.16 "Анатолий Кулаков" Да, да, я всегда пользуюсь, отлично, что когда ты набрасываешь просто кучу классиков в один файлик, а потом раскидываешь их по нужным папочкам, и он тебе сам правильные namespaces проставляет.
2774.16 2784.88 "Игорь Лабутин" А, ну вот когда классики в папочках, да, а вот так, чтобы взять готовое дерево и просто сказать вот по всему cs-проджу, пожалуйста, поправь все namespaces, что-то я не помню, но наверняка есть, в ReSharper много чего
2784.88 2790.24 "Анатолий Кулаков" есть. Да, да, в любой части дерева, да, папочки на файлике, на Solution не можешь так кликнуть и сказать, давай, пофикси
2790.24 2798.04 "Игорь Лабутин" мне это все. Окей, но мне кажется, никто не знает 100% фичи ReSharper и Ryder, поэтому это нормально, каждый день узнаешь что-то новое.
2798.04 2828.48 "Игорь Лабутин" И если вы как-то пользуетесь нестандартными темами для Visual Studio и вам, например, нравились какие-то темы из Visual Studio кода, то, во-первых, Microsoft сконвертила какие-то темы из кода, из VS Code в формат Visual Studio и вы теперь можете их использовать, а во-вторых, выложила на GitHub сам конвертер, поэтому если у вас есть какая-то кастомная тема Visual Studio кода, которая вам очень нравится, и вы хотите такую же Visual Studio, сходите на GitHub и таком онлайн-тула, сконвертируйте ее в формат Visual Studio и пользуйтесь в том числе Visual Studio.
2828.48 2833.28 "Анатолий Кулаков" И почему бы эту тулу просто не засунуть в Visual Studio, чтобы она понимала темы от кода, да и все.
2833.28 2835.64 "Игорь Лабутин" Может и засунуть, просто времени не хватило.
2835.64 2868.52 "Игорь Лабутин" Ну или там, не знаю, на самом деле Visual Studio же там прям свой формат, в VS Code по-моему там JSON-чик обычный, вот, а Visual Studio там прям какой-то VS AX, да, или я с экстендерами путаю, ну короче какой-то прям сложный, видимо, какой-то бинарный формат, если я правильно помню, и видимо ну не так просто, там небось какой-нибудь, знаешь, это binary serializer, где сериализуют это все дело и все, и вот тебе этот самый, как зовут, вот тебе тема готова, правильно, раскладывают сразу в памяти, а может нет, не знаю, короче, скорее всего просто не хватает ресурсов на все.
2868.52 2886.44 "Анатолий Кулаков" Да, давай немножко подробнее пообсудим форматы, у меня тут как раз завалялась статейка подходящая, автором ее является Аарон Стэрнест, безызвестный автор и главный вдохновитель Aki.net, то есть человек, который много знает, много пишет и многое умеет.
2886.44 2899.64 "Анатолий Кулаков" И рассказал он нам в этой статье как раз-таки про совместимости, он рассматривал несколько типов совместимости и рассказал, что каждый из них представляет и как это натягивается на текущее положение Aki.net.
2899.64 2918.76 "Анатолий Кулаков" Прежде всего нужно сказать, что совместимость между API, между какой-то библиотечкой, которая использует ваше приложение и вашим приложением, это своеобразный уровень доверия между потребителем библиотеки и тем автором, который эту библиотеку распространяет.
2918.76 2921.52 "Анатолий Кулаков" И это доверие в принципе довольно дорогого стоит.
2921.52 2937.28 "Анатолий Кулаков" Вот почему за совместимостями нужно следить, ведь никто не обрадуется, если вы вдруг случайно обновите длл, которая не предвещала вам ничего плохого, она при этом сломает весь ваш проект до неузнаваемости и может накрыть какой-нибудь ближайший релиз.
2937.28 2944.80 "Анатолий Кулаков" Поэтому в нашей среде выработалась такая интересная и полезная штука, как Semantic Version.
2944.80 2951.16 "Анатолий Кулаков" Это специальная договоренность, которая помогает нам конвертировать какие-то чиселки в ожидания.
2951.16 2958.84 "Анатолий Кулаков" Прежде всего эти чиселки нам говорят, что будет, когда ваше приложение обновит какую-то библиотеку на более новую версию.
2958.84 2965.12 "Анатолий Кулаков" Произойдет ли breaking changes, то есть сможет ли ваша библиотека дальше работать с этой новой версией или нет.
2965.12 2969.24 "Анатолий Кулаков" Это зависит от специальных цифр, которые располагаются на особых местах.
2969.24 2974.12 "Анатолий Кулаков" То есть, какой будет мажорная циферка, минорная или все остальные.
2974.12 2977.76 "Анатолий Кулаков" И от этого зависит наличие breaking changes.
2977.76 2984.08 "Анатолий Кулаков" ARIN выделяет три типа совместимости, которые используются в Wacky.net.
2984.08 2989.80 "Анатолий Кулаков" Это бинарная совместимость, совместимость на уровне API и wire совместимость.
2989.80 2994.32 "Анатолий Кулаков" Давайте немножко подробнее рассмотрим, что же это значит и когда используется.
2994.32 2997.76 "Анатолий Кулаков" Первые две – бинарная и API совместимость.
2997.76 3013.36 "Анатолий Кулаков" Бинарная совместимость – это способность библиотечки, которая говорит, что если вы подложите новую версию библиотеки в свой проект, в свои приложения без перекомпиляции, то ваше приложение все еще будет работать.
3013.36 3018.60 "Анатолий Кулаков" То есть, есть большой шанс, что оно по-прежнему продолжит работать без всяких проблем.
3018.60 3022.80 "Анатолий Кулаков" То есть, это совместимость на уровне сигнатур API в бинарном виде.
3022.80 3028.80 "Анатолий Кулаков" Второй тип совместимости на уровне API немножко слабее, чем бинарная совместимость.
3028.80 3035.68 "Анатолий Кулаков" Он всего лишь навсего гарантирует, что весь API в этой библиотеке на уровне кода был не сломан.
3035.68 3046.00 "Анатолий Кулаков" И если вдруг вы подключите эту библиотеку уже к вашему проекту и перекомпилируете приложение, то у вас компиляция не сломается, у вас все пройдет гладко.
3046.00 3048.64 "Анатолий Кулаков" Почему же может различаться API и binary совместимость?
3048.64 3052.92 "Анатолий Кулаков" Казалось бы, и там, и там сигнатуры, и там, и там все должно работать одинаково.
3052.92 3060.60 "Анатолий Кулаков" К сожалению, API совместимость не гарантирует тот же самый байт-код.
3060.60 3073.24 "Анатолий Кулаков" То есть, из-за того, что в C# очень много синтаксического сахара или еще каких-нибудь вещей, которые меняют непосредственно генерацию ILL, ваша зависимость, эта библиотечка, она может сломаться.
3073.24 3080.64 "Анатолий Кулаков" Если рассмотреть на примере, допустим, у вас есть публичный sealed class user, у которого есть одно единственное Redundant свойство - name.
3080.64 3087.76 "Анатолий Кулаков" Это Redundant свойство выставляется через публичный конструктор, передается name и выставляется этому свойство без всяких там проблем.
3087.76 3094.88 "Анатолий Кулаков" А теперь давайте представим, что в новой версии вашей сборки, новой версии вашей DLL, допустим, была версия 1, и вы делаете версию 2.
3094.88 3101.08 "Анатолий Кулаков" И в версии 2 вы решаете просто-напросто добавить дополнительное поле к вашему юзеру.
3101.08 3111.04 "Анатолий Кулаков" Ну, допустим, сейчас всем пользователям заставляют ходить в общественные места только при наличии штрих-кода, допустим, поле булевое has_barcode.
3111.04 3119.36 "Анатолий Кулаков" Вы добавляете к вашему юзеру, то есть оно прокидывается в публичный конструктор, и также появляется новое публичное свойство только на чтении has_barcode.
3119.36 3122.24 "Анатолий Кулаков" Что это значит для вашей сборки?
3122.24 3132.04 "Анатолий Кулаков" А значит это то, что теперь версия 2 не совместима по API с версией 1 и не совместима бинарно с версией 1.
3132.04 3134.00 "Анатолий Кулаков" Это происходит из-за конструктора.
3134.00 3145.92 "Анатолий Кулаков" Если раньше класс юзер можно было создать, указав только name, то теперь в библиотеке версии 2 вы должны создавать юзера, указав ему name и плюс булевый флаг has_barcode.
3145.92 3153.52 "Анатолий Кулаков" Что делает сборку абсолютно непригодной ни для обычного реплейса в уже скомпилированном приложении, ни для перекомпиляции.
3153.52 3158.36 "Анатолий Кулаков" Вам придется все-таки менять код приложения для того, чтобы это все заработало.
3158.36 3162.08 "Анатолий Кулаков" Естественно, можно добавить дефолтный параметр.
3162.08 3177.24 "Анатолий Кулаков" То есть если мы в конструкторе запишем конструктор, который принимает name в виде строки и поле has_barcode установим по дефолту false, добавим дефолтный параметр, то у нас ситуация немножко улучшится.
3177.24 3184.16 "Анатолий Кулаков" Эта библиотека станет совместимой по API, то есть приложение теперь сможет откомпилироваться.
3184.16 3189.48 "Анатолий Кулаков" Даже если она раньше задавала пользователя только с одним именем, никаких проблем не будет, у нас есть дефолт.
3189.48 3193.22 "Анатолий Кулаков" Оно после компиляции создаст этого пользователя без всяких проблем.
3193.22 3196.56 "Анатолий Кулаков" Но при этом оно по-прежнему осталось несовместимым бинарно.
3196.56 3205.34 "Анатолий Кулаков" Все это происходит потому, что на самом деле дефолт сохраняется не в сборке, где он объявлен, а в вызывающем коде.
3205.34 3216.44 "Анатолий Кулаков" Именно поэтому бинарная сигнатура конструктора у визера изменилась и он не может больше использоваться как обычный реплейсмент существующих сборок.
3216.44 3224.12 "Анатолий Кулаков" Так как же нам сделать все-таки сигнатуру, как же нам сделать все-таки сборку, которая совместима и по API, и бинарно?
3224.12 3225.12 "Анатолий Кулаков" Все очень просто.
3225.12 3228.12 "Анатолий Кулаков" Нужно добавить еще новый конструктор.
3228.12 3231.08 "Анатолий Кулаков" То есть теперь у класса User должно быть два конструктора.
3231.08 3234.92 "Анатолий Кулаков" Первый со старой сигнатурой, который принимает только один name и все.
3234.92 3241.60 "Анатолий Кулаков" И при этом он внутри себя вызывает новый конструктор с дефолтным значением, с false.
3241.60 3249.52 "Анатолий Кулаков" И второй конструктор, который будет принимать в качестве аргументов name и hasbar-код, и уже который будет оперировать новым полем.
3249.52 3253.32 "Анатолий Кулаков" Таким образом у нас сохранится и бинарная совместимость, и API-совместимость.
3253.32 3263.56 "Анатолий Кулаков" То есть старый код будет использовать старый конструктор, а новый код, который будет использовать оба поля, будет воспользоваться новым конструктором и тоже будут все счастливы.
3263.56 3269.96 "Анатолий Кулаков" Теперь последний рассматриваемый тип совместимости это wire-совместимость.
3269.96 3274.84 "Анатолий Кулаков" По-русски ее можно характеризовать как бинарная совместимость сериализации.
3274.84 3281.32 "Анатолий Кулаков" И ARN утверждает, что это наиболее важная совместимость, за которой больше всего нужно следить.
3281.32 3291.96 "Анатолий Кулаков" Ее легко представить, если описать, что она характеризует версионирование именно сериализатора как какого-то хранилища.
3291.96 3299.92 "Анатолий Кулаков" Допустим, вам нужно передавать данные по сети, допустим вам нужно сериализовать данный файлик или сохранять в базу данных или еще куда-то.
3299.92 3303.46 "Анатолий Кулаков" Ну то есть каким-то образом данные выкидывать из вашего приложения.
3303.46 3314.84 "Анатолий Кулаков" А вот насколько совместимы эти данные, которые ушли из вашего приложения с новой версией сборки, вот это и определяет бинарная совместимость сериализации.
3314.84 3319.24 "Анатолий Кулаков" ARN выделяет два подтипа совместимости.
3319.24 3323.24 "Анатолий Кулаков" Во-первых, это backward compatibility, то есть обратная совместимость.
3323.24 3329.80 "Анатолий Кулаков" Это та вещь, когда старый формат может быть прочитан новой версией сборки.
3329.80 3333.24 "Анатолий Кулаков" И forward compatibility - это прямая совместимость.
3333.24 3337.72 "Анатолий Кулаков" Когда старая версия сборки может прочитать новый формат.
3337.72 3344.68 "Анатолий Кулаков" Если вы собираетесь в вашей сборке гарантировать хороший качественный уровень совместимости, вам желательно поддержать оба этих уровня.
3344.68 3362.16 "Анатолий Кулаков" Если же вы делаете high availability приложение, которое общается по сети, например, то вы обязаны поддержать оба этих уровня, потому что как только вы начинаете обновлять ваш кластер, у вас всегда будут присутствовать половину приложений со старой версией, а половину приложений с новой версией.
3362.16 3364.96 "Анатолий Кулаков" И они должны как-то взаимодействовать, как-то коммуницировать.
3364.96 3370.00 "Анатолий Кулаков" И в принципе поддержка backward и forward compatibility здесь сыграет ключевую роль.
3370.00 3379.96 "Анатолий Кулаков" Итак, каким же образом добиться этой поддержки, и чтобы ваше приложение могло работать и назад, и вперед, очень даже успешно со всеми версиями?
3379.96 3385.44 "Анатолий Кулаков" В этом нам помогут довольно простые правила, которых нужно придерживаться, и все у вас будет хорошо.
3385.44 3389.60 "Анатолий Кулаков" Во-первых, самое главное правило - только расширять.
3389.60 3396.88 "Анатолий Кулаков" То есть никогда протокол или контракт у вас не должен ни что удалять какие-то поля, ни изменять какие-то поля.
3396.88 3402.56 "Анатолий Кулаков" А вот добавлять и расширять - вот это то, что вы можете делать без опаски.
3402.56 3406.44 "Анатолий Кулаков" То есть только расширение, и тогда не будет у вас проблем вообще ни с какими версиями.
3406.44 3409.68 "Анатолий Кулаков" Другой подход, который называется Tolerant Reader.
3409.68 3420.12 "Анатолий Кулаков" Это специальный шаблон, который нам говорит, что старые версии сериализаторов должны игнорировать те части формата, которые они не смогли распознать.
3420.12 3427.60 "Анатолий Кулаков" Они должны считать, что если какое-то новое поле пришло, то это значит что-то из новой версии, и в принципе они не должны каким-то образом падать.
3427.60 3435.92 "Анатолий Кулаков" Они должны попытаться продолжить работать с теми данными, которые есть, и нормально отработать свою бизнес-логику.
3435.92 3440.32 "Анатолий Кулаков" При этом новые части они должны просто отбросить и никак не учитывать в общем случае.
3440.32 3447.16 "Анатолий Кулаков" И третье правило - это вводить новые типы протоколов до того момента, когда вы захотели их использовать.
3447.16 3452.04 "Анатолий Кулаков" Допустим в предыдущем случае отбрасывать просто данные и для вас недопустимо.
3452.04 3456.40 "Анатолий Кулаков" То есть вы не хотите терять данные даже в старых версиях вашего приложения.
3456.40 3458.32 "Анатолий Кулаков" Тогда вы можете поступить хитрее.
3458.32 3467.92 "Анатолий Кулаков" Вы можете ваше старое приложение научить работать новому протоколу в версии 2, но при этом новый протокол в второй версии библиотеки нигде не использовать.
3467.92 3475.12 "Анатолий Кулаков" Но сериализаторы версии 2 уже научатся его децерализовать, уже научатся как-то с ним работать, уже научатся что-то с ним сделать.
3475.12 3482.68 "Анатолий Кулаков" Затем обновить первую версию приложения на вторую и уже в версии 3 вашего приложения заиспользовать новый протокол.
3482.68 3489.88 "Анатолий Кулаков" Таким образом уже кластер версии 2 будет готов к тому, что такой протокол начнет приходить и уже сможет как-то с ним работать.
3489.88 3498.02 "Анатолий Кулаков" И таким образом вы сможете и не терять данные и при этом соблюсти различные совместимости между всеми версиями.
3498.02 3500.96 "Анатолий Кулаков" Вот, статья интересная, познавательная.
3500.96 3506.72 "Анатолий Кулаков" Как всегда, Арн уходит много в философию, в рассказы о том, почему так важно держать совместимость, что такое версионирование.
3506.72 3516.52 "Анатолий Кулаков" Поэтому если вам хочется не каких-то пустых фактов, а больше размышлений умного человека, то советую обратиться непосредственно к статье.
3516.52 3518.44 "Игорь Лабутин" Вообще прям как-то сложно звучит.
3518.44 3530.52 "Игорь Лабутин" То есть получается, что если хочется прям поддержать правильное то, что называется wire compatibility, то прям, ну во-первых, быстро ничего не раскатишь, как ты говоришь, нужно версию 2 обновить весь кластер, версию 3.
3530.52 3532.56 "Игорь Лабутин" Во-вторых, и кодировать это, наверное, тоже сложнее.
3532.56 3536.20 "Игорь Лабутин" То есть прям надо сильно заморачиваться, мне кажется.
3536.20 3537.20 "Анатолий Кулаков" Да, безусловно.
3537.20 3545.76 "Анатолий Кулаков" Если вы делаете такие приложения, которые требовательны к отказу стойчевости, к high availability, то здесь приходится, конечно, загоняться.
3545.76 3557.36 "Анатолий Кулаков" Многие приложения даже держат у себя в памяти не только первую и вторую версию для того, чтобы как-то раскатить просто апдейт, а отдельный слой, который держит в памяти несколько версий.
3557.36 3580.12 "Анатолий Кулаков" То есть если у вас кластер не только вами полностью каталируется, но и приходят какие-то события из внешних источников или от клиентских каких-то программ, которые вообще неизвестно когда обновятся, то вам приходится в памяти хранить очень много конверторов, которые конвертируют входящие запросы из той версии, в которую вам прислал клиент, в ту, которую вы понимаете.
3580.12 3582.60 "Анатолий Кулаков" И это отдельная большая проблема.
3582.60 3584.44 "Игорь Лабутин" Хорошо, если только конверторы.
3584.44 3588.56 "Игорь Лабутин" Иногда приходится мейнтейнить всякие старые API и так далее.
3588.56 3593.00 "Игорь Лабутин" Потому что когда-то зарелизили и есть клиенты, которые этими пользоваться, хотя очень хочется выкинуть.
3593.00 3594.00 "Игорь Лабутин" Так, пойдем дальше.
3594.00 3602.84 "Игорь Лабутин" Ты затронул на самом деле интересную тему этой статьей про зависимости, про то, как обеспечить совместимость, как не сломать ваших клиентов.
3602.84 3636.56 "Игорь Лабутин" Но когда мы говорим про зависимости, то есть еще один аспект, мы его наверное даже чуть-чуть затрагивали в подкасте раньше, но наверняка вы слышали про такую тему уж как атаки через supply chain, то есть supply chain attacks, то есть когда вы каким-то образом подменяете пакеты, которые используются при сборке вашего продукта и таким образом внедряете вредоносный код в продукт, который собирается, причем автора этого продукта понятия не имеет, потому что он верит в то, что на Nuget.org лежит все как надо.
3636.56 3644.44 "Игорь Лабутин" Или что не на Nuget.org как раз таки, а на каком-то внутреннем репозитории, и что именно с внутреннего репозитория будет взят пакет, а не с Nuget.org.
3644.44 3669.92 "Игорь Лабутин" Так вот, поскольку эта штука как-то получила довольно большое распространение, и на многих языках и на многих пакетных менеджерах было продемонстрировано, что это все действительно очень уязвимо, Microsoft сделала такую штуку в Nuget, что теперь у вас есть фича под названием package source mapping, и она дает возможность контролировать, какие пакеты приходят откуда, с каких серверов.
3669.92 3688.04 "Игорь Лабутин" И она по большому счету особенно важна, если вы смешиваете в одном проекте и паблик сервера, и ваши какие-то свои локальные Nuget сервера, чтобы не получилось так, что сборка, которую вы хотите, чтобы забралась с приватного сервера, на самом деле скачается с паблика, с неизвестным кодом.
3688.04 3700.88 "Игорь Лабутин" Вся эта магия, которую я сейчас расскажу, работает как обычно, только в 22 студии превью 4 требует релиз кандидата первого для .NET 6, и требует превью 4 от Nuget.exe.
3700.88 3714.60 "Игорь Лабутин" Если вы все это имеете, то работать это все будет на самом деле даже для старых проектов, то есть это не зависит от target framework, вы можете таргетить хоть .NET framework, пожалуйста, но сами tools и SDK должны быть новыми.
3714.60 3728.80 "Игорь Лабутин" Для того, чтобы это все заработало, нужно, чтобы у вас был Nuget config файлик, в котором будут описаны package sources, дальше вы в нем, как обычно, пишете несколько package sources, это пожалуйста, но появилась новая опция.
3728.80 3742.76 "Игорь Лабутин" Помимо package sources, вы теперь на том же уровне можете задать новый элемент, называется package source mapping, и внутри для каждого package source, это важно, для каждого package source нужно указать pattern пакетов, которые вы ожидаете с этого package source.
3742.76 3758.84 "Игорь Лабутин" То есть вы можете сказать, что например с nuget.org вы ждете только Microsoft.*, то есть любые пакеты Microsoft вы ждете с nuget.org, а любые другие, например, вы просто указываете pattern.*, то есть все остальные, дефолтовые, вы ждете с вашего private сервера.
3758.84 3771.68 "Игорь Лабутин" То есть таким образом вы сможете нормально использовать Microsoft SPA пакеты и вот это все, но любые другие вы обязаны будете их залить на ваш внутренний сервер, возможно проконтролируя перед этим, что там внутри.
3771.68 3793.48 "Игорь Лабутин" Или наоборот, если у вас есть, допустим, соглашение, что ваши внутренние пакеты всегда начинаются с названия вашей компании, вы ставите pattern для внутреннего package source, что название вашей компании там ***, и таким образом все такие пакеты будут заливаться только, скачиваться только с вашего внутреннего nuget сервера, а все остальные будут с nuget.org.
3793.48 3813.76 "Игорь Лабутин" В pattern поддерживается всего пока два, то есть вы можете указать либо префикс, то есть имя пакета и звездочка в какой-то момент, либо просто звездочка для того, чтобы указать, что это вообще дефолтный source, откуда надо все брать, либо вы можете в принципе написать прям явный package id, прям полностью и сказать, что конкретно этот пакет всегда брать отсюда.
3813.76 3823.28 "Игорь Лабутин" Для каждого package source, как я сказал, нужно обязательно указать pattern, это может быть либо хотя бы звездочка, но он должен быть указан явно, то есть нельзя оставлять неописанные package source.
3823.28 3848.32 "Игорь Лабутин" И вообще говоря, это может показаться нелогичным, но тем не менее, если вы например написали, что ваш пакет должен забираться только с вашего сервера, но при этом ваш пакет будет зависеть от какого-нибудь Microsoft точка что-то, вот Microsoft пакеты будут забираться согласно тому паттерну, под который они подходят, то есть Microsoft пакеты при этом будут заниматься, забираться с Nuget.org.
3848.32 3863.88 "Игорь Лабутин" Ну и вроде для Microsoft пакетов это кажется очевидным, но надо понимать, что транзитивные зависимости, они просто независимо анализируются и нет никакой гарантии, что транзитивные зависимости будут скачены с того же сервера, откуда скачен главный пакет.
3863.88 3867.00 "Игорь Лабутин" Это надо понимать и правильно расставлять эти самые паттерны.
3867.00 3877.76 "Игорь Лабутин" И если вдруг пакет, на котором вы зависите, уже лежит в кэше, в пакетчес папочки, то никакого сравнения паттернов, ничего не происходит, он просто берется из кэша.
3877.76 3884.76 "Игорь Лабутин" Ну предполагаю, что он туда попал, так сказать, уже правильным, проверенным, с правильного пакетчесоверства и что еще раз сравнивать.
3884.76 3925.28 "Игорь Лабутин" Так что фича пока, ну вот она довольно ранняя, наверняка там может еще найдутся какие-то подводные камни и тонкости, но в целом, если вы заботитесь о том, чтобы не скачать что-то левого и у вас есть, например, какие-то паблик NuGet сервера в ваших NuGet конфигах, то рекомендую посмотреть на эту штуку, ну возможно когда вы обновитесь до 6 SDK и 22 студии, чтобы действительно обезопасить себя от того, что кто-то назовет пакет именем вашей компании и подложит его на NuGet.org и затащит туда какой-нибудь, не знаю, майнер или еще что-нибудь, а вы это радостно скачаете, если у вас неправильный порядок пакетчесоверств в NuGet конфиге.
3925.28 3946.48 "Анатолий Кулаков" Слушай, мне кажется, мы недостаточно строго подошли, потому что это реально критическая уязвимость и многие разработчики просто не знают и никогда не услышат, то есть это нужно было бы сделать как-нибудь прям ломая обратную совместимость и заставлять разработчиков явно указать, задуматься, заблокировать какие-нибудь внешние NuGet пакеты или что-нибудь в этом духе.
3946.48 3975.08 "Игорь Лабутин" Я допускаю, что они это, может быть, сделают, например, в семерке, ну или где-нибудь попозднее в каком-нибудь сразу после релиза, то есть понятно, что вроде как шестой мейджор-релиз, в принципе, неплохое время, чтобы что-нибудь прям сломать, может, конечно, и сломают, полтора месяца еще осталось, они могут сказать, что теперь это мы в превью попробовали, ну в релиз-кандидате, вроде там никаких возражений нет, давайте теперь везде будем это требовать, ну не знаю.
3975.08 3990.36 "Анатолий Кулаков" Да, вполне, мне кажется, нужно явно всегда указывать и нести полную ответственность за то, откуда берутся твои сборки, то есть об этом люди должны задумываться, нужно находить там статью в микрософте и отдельно это понимать и рассказывать всем остальным.
3990.36 3996.20 "Игорь Лабутин" Ну или, может быть, хотя бы какие-нибудь ворринги писать при билде, если в вашем NuGet-конфиге есть NuGet.org, например.
3996.20 4004.00 "Анатолий Кулаков" Да, да, если есть сборки из вашего локального и NuGet.org, значит, вы их уже мешаете, значит, уже должны задуматься.
4004.00 4009.52 "Игорь Лабутин" Ну да, package-соурсов больше одного, и один из них какой-нибудь паблик, типа NuGet.org, MyGet, ну же не в таком духе.
4009.52 4012.92 "Анатолий Кулаков" Да, да, в принципе, значит, уже опасность есть как таковая.
4012.92 4020.16 "Игорь Лабутин" Ну посмотрим, как всегда, вот они это сделали, в принципе, фича полезная, но посмотрим, как будет адаптиться и как она будет инфорсироваться дальше.
4020.16 4049.44 "Анатолий Кулаков" Хорошо, у нас есть source-генераторы, которые тоже часто радуют нас какими-то новыми изобретениями, новыми какими-то сборочками, и я тут набрел как раз, когда раскапывал тему про value objects и прочие вот эти всякие ddd-шелупень, набрел на интересные генераторы, которые позволяют нам немножко упростить вот это создание различных value objects с помощью генераторов.
4049.44 4055.04 "Анатолий Кулаков" Ну казалось бы, действительно, это та вотчина, где генераторы должны хорошо выстрелить и отлично себя показать.
4055.04 4063.68 "Анатолий Кулаков" Первым на мой обзор попала strongly-typed-id, это сборка, которая помогает генерить идентификаторы.
4063.68 4065.68 "Анатолий Кулаков" Ну прежде всего, в чем проблема-то?
4065.68 4070.28 "Анатолий Кулаков" Обычно в различных приложениях идентификаторы представляют из себя какие-то банальные примитивы.
4070.28 4076.52 "Анатолий Кулаков" Int, good, string, ну или какая-то комбинация из этих свойств.
4076.52 4089.28 "Анатолий Кулаков" То есть обычно мы не загоняемся, мы выдаем им какое-то примитивное число и у нас идентификатор какого-то объекта живет, странствует по сети, передается и участвует в нашей бизнес-логике вполне незамысловато.
4089.28 4098.48 "Анатолий Кулаков" Такой подход считается не очень хорошим и называется эта проблема primitive obsession, то есть какая-то озабоченность с примитивами.
4098.48 4106.16 "Анатолий Кулаков" Слишком много у вас в коде появляется примитивов и у кода появляются проблемы с чтением или даже бизнес-ошибки.
4106.16 4117.80 "Анатолий Кулаков" Например, если у вас метод принимает два int, один из которых это идентификатор пользователя, другой это идентификатор группы, вполне легко вызывающая сторона может перепутать их местами.
4117.80 4124.84 "Анатолий Кулаков" И там, и там int, и там, и там какие-то идентификаторы, никто не заметит, если они вызывающей стороне поменяются местами.
4124.84 4131.32 "Анатолий Кулаков" И это довольно трудная бага, ее не всегда можно быстро отыскать и все ошибки будут фронтами.
4131.32 4133.40 "Анатолий Кулаков" Это довольно-таки плохо.
4133.40 4136.84 "Анатолий Кулаков" Также бывают ошибки, когда вы сравниваете несравнимые вещи.
4136.84 4147.16 "Анатолий Кулаков" Например, вам передали в int какой-то идентификатор пользователя, у вас там локально был идентификатор группы и вы стараетесь их сравнивать и в принципе компилятор никак вам этому не помешает.
4147.16 4153.16 "Анатолий Кулаков" Он вполне удастся вам сравнить идентификатор пользователя и однишние группы и выдаст даже какой-то разумный результат.
4153.16 4156.24 "Анатолий Кулаков" Даже это сравнение вы практически никак не отследите.
4156.24 4159.44 "Анатолий Кулаков" Упадет, может быть, если повезет, только в рантайме.
4159.44 4172.36 "Анатолий Кулаков" И вот эти примерные проблемы позволяют решить тот подход, что вы можете представить идентификаторы не примитивными классами, а сделав для каждого идентификатора свой собственный класс.
4172.36 4176.68 "Анатолий Кулаков" Класс, который может называться UserId, класс, который может называться ГруппID и так далее.
4176.68 4179.28 "Анатолий Кулаков" Плюсов такого подхода довольно много.
4179.28 4181.44 "Анатолий Кулаков" Во-первых, код становится самодокументированным.
4181.44 4186.64 "Анатолий Кулаков" То есть, когда у вас метод принимает UserId, здесь уже вообще никаких вопросов не возникает.
4186.64 4189.88 "Анатолий Кулаков" Вы понимаете, что для вызова вам нужен UserId.
4189.88 4198.60 "Анатолий Кулаков" Если же в старом варианте метод принимает у вас Int, то здесь уже начинаются какие-то вопросы и вам приходится смотреть на имя переменной.
4198.60 4201.84 "Анатолий Кулаков" Имя переменной не всегда говорящее, может быть, просто ID.
4201.84 4205.24 "Анатолий Кулаков" И вы начинаете думать, а какой там ID, а чего там ID, почему он ID.
4205.24 4210.44 "Анатолий Кулаков" То есть, документация немножко теряется, самоописаемость кода немножко теряется.
4210.44 4216.44 "Анатолий Кулаков" Естественно, плюс в отсутствии выше обозначенных проблем.
4216.44 4223.52 "Анатолий Кулаков" То есть, если у вас будут различные идентификаторы для пользователя и группы, вы уже не сможете поменять их местами при вызове метода.
4223.52 4229.64 "Анатолий Кулаков" Компилятор вам ругнется, компилятор вам подскажет, поможет, и вы быстренько это в compile time просто поменяете.
4229.64 4233.32 "Анатолий Кулаков" Также у вас появляется место для каких-то дополнительных методов.
4233.32 4237.36 "Анатолий Кулаков" Например, в идентификатор можно засунуть дату и время для чего-то.
4237.36 4242.52 "Анатолий Кулаков" Можно засунуть вспомогательные и утилитные методы, типа parse, convert и прочее.
4242.52 4245.08 "Анатолий Кулаков" То есть, тоже такое полезное место.
4245.08 4249.76 "Анатолий Кулаков" Минусы у создавания отдельного класса на каждый идентификатор естественно тоже есть.
4249.76 4254.28 "Анатолий Кулаков" Во-первых, этот код нужно создавать, его нужно писать ручками.
4254.28 4257.90 "Анатолий Кулаков" Код довольно примитивный, утомительный и никому это не интересно.
4257.90 4262.08 "Анатолий Кулаков" Поэтому такая практика распространена довольно-таки редко.
4262.08 4268.52 "Анатолий Кулаков" Во-вторых, подобные идентификаторы мешают примитивным типам во время сериализации.
4268.52 4276.28 "Анатолий Кулаков" Практически любой сериализатор знает, каким образом представлять int или string в своем формате.
4276.28 4281.36 "Анатолий Кулаков" Вы их можете легко передать через JSON, в Entity Framework и куда угодно абсолютно везде.
4281.36 4284.88 "Анатолий Кулаков" Но никто не знает, каким образом работать с вашим user id.
4284.88 4286.64 "Анатолий Кулаков" Что с ним делать, как его сериализовать.
4286.64 4288.60 "Анатолий Кулаков" Это в принципе проблема.
4288.60 4295.12 "Анатолий Кулаков" Вот такие вот минусы, часть из которых вам помогает решить source генераторы.
4295.12 4303.72 "Анатолий Кулаков" А вторую часть вам помогает решить немножко новых знаний, которые тоже легко засунуть в source генераторы.
4303.72 4310.04 "Анатолий Кулаков" Действительно, как только мы встречаемся с кодом, который примитивный, банальный, скучный, сразу нужно думать о source генераторах.
4310.04 4315.16 "Анатолий Кулаков" Значит, они могут решить эту проблему и сделать всю необходимую рутинную работу за вас.
4315.16 4316.16 "Анатолий Кулаков" Так и здесь.
4316.16 4328.24 "Анатолий Кулаков" Здесь автор описывает интересный генератор, который позволяет вам объявить partial class, например, user id в вашем коде без единой строчки body.
4328.24 4335.60 "Анатолий Кулаков" Всего лишь навесив ему сверху атрибутик strong type id и указать, какой из примитивных типа вы хотите использовать как базовый.
4335.60 4337.60 "Анатолий Кулаков" Int, string, good, еще что-нибудь.
4337.60 4341.40 "Анатолий Кулаков" И всю остальную черновую работу source генератор сделает за вас.
4341.40 4347.44 "Анатолий Кулаков" Например, он создаст нужные конструкторы, он добавит необходимые методы parse, try parse.
4347.44 4355.52 "Анатолий Кулаков" Он сделает сравнение объектов по их структуре, переопределит comparable, equals, get hash code.
4355.52 4363.48 "Анатолий Кулаков" То есть все вот эти методы, которые нужны для идентификатора и для вылья объектов, он вам красиво все сделает.
4363.48 4373.24 "Анатолий Кулаков" Также решая проблему серилизаторов, на самом деле у практически у каждого нормального серилизатора поддерживается способ расширения этого серилизатора.
4373.24 4381.16 "Анатолий Кулаков" И вы можете легко написать свой конвертер практически для любого типа, который расскажет, что с этим типом должен делать каждый конкретный серилизатор.
4381.16 4388.28 "Анатолий Кулаков" У этого генератора есть интеграция с System Text JSON и Newton Soft JSON с помощью JSON-конвертеров.
4388.28 4395.92 "Анатолий Кулаков" Также у него есть type-конвертеры, которые позволяют ваш кастомный класс использовать в ASP.NET контроллерах.
4395.92 4410.00 "Анатолий Кулаков" Например, вы в контроллерах можете принимать не int user_id в качестве аргумента, вычисляемого из route, а прямо можете так и написать user_id и имя параметра.
4410.00 4421.88 "Анатолий Кулаков" И ASP.NET Core поймет, что если у него есть int и при этом хочется user_id, то нужно вызвать type-конвертер, зарегистрированный в системе и все прозрачно сконвертировать.
4421.88 4431.12 "Анатолий Кулаков" И уже контроллеры у вас начинают работать не просто с какими-то int-ами и строками, а нормальными строго типизированными идентификаторами, что тоже часто удобно.
4431.12 4440.88 "Анатолий Кулаков" Entity Framework точно также можно легко приучить понимать ваш тип с помощью value-конвертера и даже для MongoDB есть интеграция с помощью Bsone Serializer.
4440.88 4447.00 "Анатолий Кулаков" Как мы видим, большинство проблем кастомных идентификаторов уходит.
4447.00 4457.40 "Анатолий Кулаков" Второй генератор называется Unit Generator, он сильно похож на первый, но немножко более широкий функционал имеет.
4457.40 4463.36 "Анатолий Кулаков" Он собирается генерировать объекты не только для идентификаторов, но и для любых принципий value-объектов.
4463.36 4467.52 "Анатолий Кулаков" То, что мы обсуждали вместе с Владимиром Хориковым.
4467.52 4474.16 "Анатолий Кулаков" Генератор кроме уже описанных вещей умеет добавлять арифметические операции, если это нужно.
4474.16 4481.08 "Анатолий Кулаков" Например, чтобы считать количество жизней у вашего игрока.
4481.08 4486.32 "Анатолий Кулаков" Количество жизней тоже можно обозначать не int-ом, не float-ом, а через какой-то понятный объект.
4486.32 4490.88 "Анатолий Кулаков" И с этим объектом хочется производить математику, делить жизни, умножать жизни, добавлять их.
4490.88 4494.48 "Анатолий Кулаков" Вот генератор вам легко может добавить арифметические операции.
4494.48 4500.20 "Анатолий Кулаков" Кроме очевидных интеграций с JSON и с EF, у здесь еще есть Dapper и Message Pack, если вам это нужно.
4500.20 4504.68 "Анатолий Кулаков" То есть генераторы довольно хорошо покрывают всю эту тему.
4504.68 4513.60 "Анатолий Кулаков" И также я набрал на замечательный список от товарища Amis92, который на GitHub называется C# Source Generators.
4513.60 4517.04 "Анатолий Кулаков" Там более сотни различных генераторов на все вкусы.
4517.04 4522.04 "Анатолий Кулаков" Здесь что-то рекомендовать абсолютно бессмысленно, но для себя что-то интересное.
4522.04 4526.76 "Анатолий Кулаков" Естественно много сборчик с генераторами по dependency injection.
4526.76 4534.72 "Анатолий Кулаков" Есть mini ORM, которая все ORM вещи делает в compile-time, то есть мапит ваши объекты на базу данных.
4534.72 4545.44 "Анатолий Кулаков" Есть генераторы, которые позволяют из вашего кода очень легко сделать строго типизированные Excel таблички без минимума различных интеропов.
4545.44 4549.96 "Анатолий Кулаков" Mini Razor - интересная штучка, которая парсит темплейт Razor.
4549.96 4552.60 "Анатолий Кулаков" Итра сделает транспарлинг полный C# код.
4552.60 4558.64 "Анатолий Кулаков" То есть уже в runtime у вас не будет никаких потерь на то, чтобы запустить парсеры.
4558.64 4565.16 "Анатолий Кулаков" И object mappers типа automappers тоже никакого смысла в runtime теперь делать не существует.
4565.16 4571.64 "Анатолий Кулаков" Если вы знаете все типы объектов, которые вам нужно смапить, вы легко это сделаете без лишних библиотек прямо в build-time.
4571.64 4579.28 "Анатолий Кулаков" Также там есть хорошая подборочка статейчик, видосиков с обучающими примерами и много чего еще про генераторы.
4579.28 4587.96 "Анатолий Кулаков" Поэтому если вам интересно каких-нибудь хороших примеров или просто ищете для себя подходящий генератор, загляните на C# Source Generators, ссылки будут в шоу-ноутах.
4587.96 4591.60 "Игорь Лабутин" Да, я хотел добавить, что очень забавная ситуация.
4591.60 4598.68 "Игорь Лабутин" Ты когда начал рассказывать про strongly-typed ID, я был вообще на 100% уверен, что ты будешь рассказывать про Andrew Locke.
4598.68 4603.96 "Игорь Лабутин" Но внезапно оказалось, что strongly-typed ID - это не единственный NuGet.
4603.96 4611.52 "Игорь Лабутин" У него существует как минимум два, двух независимых авторов, и они довольно синхронно его переписывали на Source Generators.
4611.52 4619.64 "Игорь Лабутин" То есть у Andrew Locke есть серия статей из шести статей 2019 года, когда он впервые сделал вот этот самый strongly-typed ID, свой пакет.
4619.64 4624.24 "Игорь Лабутин" И вот в августе этого года он его переписал на Source Generators.
4624.24 4627.28 "Игорь Лабутин" Мы эту линку тоже приложим, посмотрите, сравните.
4627.28 4632.12 "Игорь Лабутин" Они на самом деле довольно похожи, видимо, как бы идеи очень действительно одинаковые.
4632.12 4640.76 "Анатолий Кулаков" Да, это просто место, наверное, которое у всех наболело, и которое элементарно, очевидно, делается на генераторах, и поэтому каждый должен написать свой strong ID, я считаю.
4640.76 4649.12 "Игорь Лабутин" Да, мне показалось забавно, что они реально прямо называются одинаково, это тоже strongly-typed ID, и у меня ощущение, что даже атрибутики как-то очень похожи называются.
4649.12 4652.16 "Игорь Лабутин" То есть, видимо, они все, ну, друг на друга смотрели, наверное.
4652.16 4658.12 "Игорь Лабутин" Дальше пойдем по библиотекам, так по библиотекам.
4658.12 4675.00 "Игорь Лабутин" Корр WCF, новый релиз 0.3.0, ну, я думаю, что версии 1.0 мы будем ждать очень долго, но тем не менее, 0.3.0 тоже вполне полезно, тем более, что я слышал, что Корр WCF вполне есть даже в продакшене, и он неплохо развивается.
4675.00 4682.28 "Игорь Лабутин" И в этом релизе завезли довольно интересные фичи, их не так много, но они вполне такие практические.
4682.28 4688.36 "Игорь Лабутин" Во-первых, теперь можно задавать конфигурацию WCF через файлы конфигурации.
4688.36 4704.76 "Игорь Лабутин" Но единственное, что поскольку в современном дотнете файл конфигурации — это JSON, то вам нужно написать отдельный апконфиг и его там правильно указать в конфигурации вашего приложения, в коде C#, дать на него ссылочку, и из него тогда можно будет прочитать конфигурацию.
4704.76 4719.88 "Игорь Лабутин" Там сейчас поддержано не все, смотрите релиз ноутсы, и там будет написано, что конкретно поддержано, но работа идет, и понятно, что портировать старый код стало проще, чем переписывать все эти большие байдинги на C# аналог.
4719.88 4731.40 "Игорь Лабутин" Дальше сделали паблик элементом https-transport-binding-element, то есть теперь если вы хотите конфигурировать https-transport, у вас теперь есть нормальный способ это сделать через конфигурацию.
4731.40 4771.92 "Игорь Лабутин" Добавили поддержку xml-сериалайзера формата атрибюта, и тут идея довольно простая, вы можете контракты размечать старыми атрибутами из System Service Model на имспейсах, а можете новыми из Core WCF, но проблема в том, что если вы хотите использовать например общую сборку, что в WCF очень часто делается, шарить контракт не через там WSDL, а прям вот DLL между клиентом и сервером, то вам по сути придется делать два одновременно атрибута использовать, то есть размечать и теми и теми атрибутами, плюс делать зависимость на Core WCF, что может быть, ну как бы оно вам зачем, если вы его используете в каком-нибудь там серверном части на дотленд фреймворке.
4771.92 4780.60 "Игорь Лабутин" Вот поэтому Core WCF на самом деле поддерживает разметку только старыми атрибутами, но он поддерживал их не все, и если вы использовали какие-то очень специфические, то они не работали.
4780.60 4792.84 "Игорь Лабутин" Сейчас вот потихонечку добавили еще один важный атрибут, и по-моему список стал довольно полным, может быть там есть еще что-то, ну тогда welcome по open source и по-контрибьюти туда.
4792.84 4812.04 "Игорь Лабутин" Важное, наверное прям супер важное изменение, теперь поддерживаются дуплексные контракты, это прям открывает огромное количество, скажем так, возможностей по портированию старого кода, и добавилось такой кусочек VCF, как fold contract info, и с ним очень интересная история.
4812.04 4824.84 "Игорь Лабутин" На самом деле, как выяснилось, в Core WCF в библиотеке очень много всего реализовано уже, то есть вы так вот смотрите, типа в release notes там написано, ну мы поддерживаем вот это, вот это, вот это, думаешь, ну как-то маловато.
4824.84 4831.28 "Игорь Лабутин" На самом деле поддерживаем гораздо больше, но у команды Core WCF есть интересный подход.
4831.28 4846.24 "Игорь Лабутин" API не может быть сделано public, даже если оно заимплеменчено, если на него нет тестов, поэтому на самом деле довольно много issues в репозитории, они про то, что вот это API готово, если на него написать тест, мы его сделаем public.
4846.24 4854.40 "Игорь Лабутин" Ну и вот как раз-таки fold contract info, это было одно из таких API, пришел какой-то товарищ и написал собственно тестики, после чего API стало public.
4854.40 4867.60 "Игорь Лабутин" Вот, поэтому посмотрите, если вы вдруг думали, что делать с WCF, смотрели в сторону Core WCF и не видели в списке поддерживаемых вещей то, что вам надо, посмотрите, может быть на самом деле оно написано, просто на него тестов нет, допишите тест и оно станет public.
4867.60 4872.24 "Игорь Лабутин" Вот, контрибьютить, как оказывается, полезно и иногда вот так вот забавно.
4872.24 4892.08 "Игорь Лабутин" И команда на самом деле отмечает, что вот этот релиз 0.3.0, он вообще говорят там практически на 90% состоит из внешних контрибьюторов, то есть его бы не было, если бы не помощь внешних контрибьюторов и у нас сегодня есть возможность с одним из этих контрибьюторов поговорить, это Дмитрий Маслов.
4892.08 4893.08 "Игорь Лабутин" Привет, Дмитрий.
4893.08 4894.08 "Игорь Лабутин" Привет.
4894.08 4908.96 "Игорь Лабутин" Расскажи, пожалуйста, каким образом тебя занесло в такую технологию как WCF, куда, ну, как мне кажется, не так много кто заходит и вообще чем ты занимаешься, как относишься к дотнету и зачем ты с нами?
4908.96 4945.12 "Дмитрий Маслов" Я разработчик в компании Soft Media Lab из города Екатеринбурга, вот, и предыдущий мой проект очень тесно был связан с WCF, было очень много сервисов и меня очень расстроила новость о том, что новый дотнет не поддерживает сервисную часть корпусов, вот, и я решил каким-то образом помочь развитию этой платформы и пошел на GitHub почитать ищу, чтобы, собственно, понять, чем я могу помочь в развитии данной платформы.
4945.12 4965.40 "Игорь Лабутин" Ну, и в итоге, я так понимаю, нашел что-то, ну, я с GitHub же и Contribution там всегда есть какие-нибудь App4Graphs или там Good First Issue, то есть ты выбрал именно такое или просто выбирал из каких-то, ну, знакомых вещей, там, типа, вот эту часть я знаю, давай попробуем поконтрибьютить тут.
4965.40 4966.40 "Игорь Лабутин" Как ты выбирал вот ищу?
4966.40 4995.56 "Дмитрий Маслов" Я достаточно поверхностно знаком на самом деле с этой платформой, вот, поэтому я, да, больше ориентировался, наверное, на какую-то легкость в имплементации, вот, и одно из ищу, которое мне показалось достаточно простым, значит, было одного, от одного из чуваков из Microsoft, который предлагал читать конфиги клиентские WCF-ные и точно так же их конфигурировать через DI из Pnet Core.
4995.56 5004.60 "Дмитрий Маслов" Вот, соответственно, он с этим предложением написал ищу, типа, не хотите ли вы, типа, в сервисную часть эту штуку затащить.
5004.60 5033.56 "Дмитрий Маслов" Соответственно, долго не было ответа по этому ищу, и я решил, типа, ну, технические задачи выглядят нескожно, вот, то есть надо что, просто прочитать конфиг, да, и, собственно, в сервис-билдере, который, собственно, конфигурирует Core WCF, да, дернуть ненужный метод, вот, собственно, начали обсуждать дизайн, вот, как это должно выглядеть, ну и после этого я взял это в работу.
5033.56 5053.96 "Игорь Лабутин" Ну, то есть получается, что код, по большому счету, во многом был написан, да, в основном Netcore, где оставили клиентскую поддержку WCF, оставалось только поддержать нужные элементы, которые со стороны сервера, сервиса, потому что там немножко другие элементы и, ну, нести их просто код в нужное место или даже просто заиспользовать библиотеку.
5053.96 5073.08 "Дмитрий Маслов" Ну, нет, на самом деле, все оказалось не так просто, вот, да, большая часть, конечно, кода — это миграция из старого репозитория классического дубнет-фреймворка, в частности, работа с конфигами, вот, но вот имплементация работы именно с DI, она как бы полностью писалась с нуля.
5073.08 5074.08 "Игорь Лабутин" Круто.
5074.08 5098.56 "Игорь Лабутин" При этом я, когда прочитал pull request, у меня сложилось впечатление, что история там развивалась примерно таким образом, кто-то написал вот эту ишу со словами «было бы здорово такое внести в core WCF», после чего ты пришел, начал над этим работать, после чего набежал народ со словами типа «ой, что тут происходит, и как бы, зачем мы это делаем, все надо делать не так, и вот все такое прочее».
5098.56 5107.44 "Игорь Лабутин" У меня такое сложилось ощущение, что вроде с одной стороны фича нужна, а с другой стороны как-то все набросились на то ли на способ реализации, то ли вообще в принципе на дизайн.
5107.44 5109.84 "Игорь Лабутин" Можешь рассказать, как это выглядело с твоей стороны?
5109.84 5112.32 "Игорь Лабутин" Стороны того, кто пытался сделать эту штуку.
5112.32 5115.52 "Дмитрий Маслов" Да, я понял ситуацию, о которой ты говоришь.
5115.52 5125.48 "Дмитрий Маслов" На самом деле в дискуссии участвовали только два человека — это Мэтт из Microsoft и второй, который из AWS, я к сожалению не произнесу его имени.
5125.48 5133.72 "Дмитрий Маслов" И мы как бы втроем обсуждали и планировали то, как мы будем развивать эту фичу.
5133.72 5138.04 "Дмитрий Маслов" Ну типа, что необходимо в первую очередь включить, что там во вторую.
5138.04 5145.40 "Дмитрий Маслов" А вот один из участников, да, собственно, как-то так внезапно залетел, все раскритиковал.
5145.40 5150.72 "Дмитрий Маслов" Я попытался с ним вступить в дискусс, что типа не все так просто, как кажется.
5150.72 5161.88 "Дмитрий Маслов" Ну потому что большая часть фичи уже была мной сделана и были определенные стратегические решения предприняты по поводу развития этой фичи.
5161.88 5167.28 "Дмитрий Маслов" Ну потом что-то я не стал сильно с ним спорить и просто она просто...
5167.28 5168.72 "Дмитрий Маслов" Дискуссия на этом закончилась.
5168.72 5175.48 "Дмитрий Маслов" То есть как бы сам владелец репозитория даже не стал там порядок наводить.
5175.48 5176.48 "Дмитрий Маслов" Понятно, здорово.
5176.48 5185.44 "Игорь Лабутин" Ну то есть получается, что фича в итоге запилена, доделана, вышла в релизе, соответственно 0.3.0, все здорово.
5185.44 5203.72 "Игорь Лабутин" Вопрос следующий состоит в том, немножко может быть неожиданный, а насколько в принципе сложно взять так вообще сторонний какой-то репозиторий, в данном случае Core WLCF, его же тебе нужно было собрать у себя, убедиться, что все работает, ну в смысле всякие тестики, чтобы гонялись.
5203.72 5210.08 "Игорь Лабутин" То есть вообще насколько хорошо все документировано и все завелось с первого раза или пришлось долго помучаться, прежде чем все собралось локально?
5210.08 5215.00 "Дмитрий Маслов" Ну там на самом деле у них достаточно хороший contributing guide описан.
5215.00 5220.28 "Дмитрий Маслов" С локальной сборкой и запуском тестов особых каких-то проблем нет.
5220.28 5230.60 "Дмитрий Маслов" То есть там все хорошо унифицировано, поэтому с первоначальным запуском проекта особых проблем нет.
5230.60 5237.48 "Дмитрий Маслов" Но разобраться в самой архитектуре это, наверное, самое сложное.
5237.48 5247.84 "Дмитрий Маслов" Потому что ты примерно знаешь, что делать, но каким образом это должно быть встроено в текущую структуру проекта, это всегда вызывает сомнения и вопросы.
5247.84 5252.40 "Игорь Лабутин" Но я так понимаю, что ровно для этого там есть мейн-трейнеры, которым в принципе можно писать.
5252.40 5262.44 "Игорь Лабутин" Если вы выбрали ищу, которая действительно полезна, то мейн-трейнеры скорее всего с радостью внутри этой ищи вам расскажут, с какой стороны подойти, куда посмотреть и на что обратить внимание.
5262.44 5277.72 "Дмитрий Маслов" Да, то есть мы в процессе обсуждения дизайна, собственно, пришли к выводу, что это должен быть отдельный пакет у нас, который называется Corvus F Configuration Manager и что все зависимости пакетов должны быть только в одну сторону.
5277.72 5282.76 "Дмитрий Маслов" То есть Corvus F Primitive не должны зависеть от этого пакета.
5282.76 5284.84 "Игорь Лабутин" Окей, понятно, спасибо.
5284.84 5289.84 "Игорь Лабутин" Мы уже, наверное, не будем вдаваться сильно в технические детали того, что там и как контрибьютилось.
5289.84 5301.52 "Игорь Лабутин" Ссылочку на pull request мы оставим в описании подкаста и вы сможете внимательно посмотреть и сами оценить то, как развивалась дискуссия и работа над этим конкретно, contribution.
5301.52 5306.04 "Игорь Лабутин" А теперь хочу немножко с другой стороны затронуть тему.
5306.04 5314.16 "Игорь Лабутин" Ты в самом начале говорил, что вот хотелось как-то там помочь, законтрибьютилить в open source и так далее.
5314.16 5321.40 "Игорь Лабутин" Есть какие-нибудь мысли на тему, может быть, конкретно WCF или вообще в целом, как к этому подходить?
5321.40 5325.04 "Дмитрий Маслов" Ну, я думаю, здесь, наверное, просто не стоит бояться.
5325.04 5331.88 "Дмитрий Маслов" То есть, ну, как бы pull request - это такая штука, возможно, страшная, что тебя будут критиковать и так далее.
5331.88 5336.04 "Дмитрий Маслов" Но на самом деле это некий просто процесс обсуждения.
5336.04 5349.24 "Дмитрий Маслов" Поэтому если вы хотите делать вклад в развитие комьюнити и развивать открытое ПО, то просто ищите удобный вам способ и начинайте контрибьютить.
5349.24 5350.24 "Дмитрий Маслов" Вот.
5350.24 5362.12 "Дмитрий Маслов" Также я со стороны WCF комьюнити всех приглашаю сходить посмотреть запиннед ишью по фичу roadmap и проголосовать за те фичи, которые вам необходимы.
5362.12 5370.08 "Дмитрий Маслов" С точки зрения комьюнити очень важно понять, какие фичи в первую очередь необходимо реализовать на кросс-платформе на .NET.
5370.08 5371.08 "Игорь Лабутин" Да, это здорово.
5371.08 5376.00 "Игорь Лабутин" Мы эту новость, по-моему, даже обсуждали, наверное, полгода назад или когда это было.
5376.00 5377.00 "Игорь Лабутин" Давно, мне кажется.
5377.00 5379.72 "Игорь Лабутин" Я действительно уже подзабыл, что это такое есть.
5379.72 5384.60 "Игорь Лабутин" И здорово, что на самом деле оно до сих пор живет и что вы все еще можете голосовать за фичи.
5384.60 5390.32 "Игорь Лабутин" И команда, я надеюсь, к ним прислушивается и старается делать все в соответствии с бэклогом.
5390.32 5392.52 "Игорь Лабутин" Хотя, я так понимаю, команда там очень небольшая.
5392.52 5397.80 "Игорь Лабутин" Если мне не изменяет память, то вроде то ли два основных человека работают над этим проектом.
5397.80 5403.64 "Игорь Лабутин" Так что contribution очень полезно, если вы хотите получить WCF на пятом либо шестом .NET.
5403.64 5408.68 "Игорь Лабутин" Отлично, спасибо, Дмитрий, за детальный рассказ про то, что такое contribute в open source.
5408.68 5420.84 "Игорь Лабутин" Я надеюсь, ты будешь не единственным, и много кто другой последует твоему примеру и будет развивать и улучшать различные аспекты нашей дотнетной инфраструктуры и экосистемы.
5420.84 5422.48 "Игорь Лабутин" Спасибо еще раз и пока.
5422.48 5423.48 "Игорь Лабутин" Пока.
5423.48 5424.48 "Игорь Лабутин" А мы идем дальше.
5424.48 5426.88 "Игорь Лабутин" Есть у нас еще что-нибудь обсудить?
5426.88 5428.08 "Игорь Лабутин" Или хватит на библиотек?
5428.08 5429.76 "Анатолий Кулаков" Да, давай еще одну зацепим.
5429.76 5438.96 "Анатолий Кулаков" Захотелось мне тут нагрузочное тестирование для своего приложения провести, и я пошел обратить, смотреть, что же есть в дотнете про это.
5438.96 5445.16 "Анатолий Кулаков" Интересный момент, что огромное число библиотек, которые делают нагрузочное тестирование на других языках, оно есть.
5445.16 5447.56 "Анатолий Кулаков" И очень-очень много их.
5447.56 5450.20 "Анатолий Кулаков" На дотнете с этим просто беда.
5450.20 5460.60 "Анатолий Кулаков" Есть какие-то жалкие калеки, но при любом их использовании начинаешь понимать, что они не выдают абсолютно той нагрузки, которую могли бы выдавать.
5460.60 5470.56 "Анатолий Кулаков" Например, весь наш кестерол давно хвалится, что он может выдержать под миллионы запросов в секунду, бьет первые места на всяких бичмарках и так далее.
5470.56 5481.96 "Анатолий Кулаков" А вы попробуйте хоть раз нагрузить в ваш обычный Hello World, который возвращает просто какое-нибудь константное значение, попробуйте нагрузить из вашего приложения с всеми запросами.
5481.96 5487.40 "Анатолий Кулаков" Сколько максимального запроса вы сможете дать на вот этот кестерол, и сколько он вам выдаст.
5487.40 5492.24 "Анатолий Кулаков" Оказывается, сделать нормальное нагрузочное тестирование так уж и просто.
5492.24 5494.92 "Анатолий Кулаков" И я сравнивал с другими приложениями.
5494.92 5508.68 "Анатолий Кулаков" Я брал какой-то бичмаркер на C, на других языках и нагружал мое приложение, а потом брал то же самое приложение, тот же самый Load Tester, который написан на C# и нагружал мое приложение.
5508.68 5519.64 "Анатолий Кулаков" И видно было, что C# нагруженное тестирование не выдает на десятой доле то, что может выдавать лоудер на плюсах.
5519.64 5520.64 "Анатолий Кулаков" Это довольно странно.
5521.36 5528.92 "Анатолий Кулаков" В принципе, изыскания то, как приблизиться к хорошей цифре у меня практически закончены.
5528.92 5532.20 "Анатолий Кулаков" Может быть в следующих выпусках я поделюсь.
5532.20 5534.84 "Анатолий Кулаков" Но сейчас речь не об этом.
5534.84 5537.04 "Анатолий Кулаков" Это лирическое отступление.
5537.04 5542.96 "Анатолий Кулаков" А хотелось бы поговорить все-таки об нормальном инструменте, который я нашел благодаря моим поискам.
5542.96 5543.96 "Анатолий Кулаков" Это N-Bomber.
5543.96 5557.80 "Анатолий Кулаков" N-Bomber это система для нагрузочного тестирования, которая способна нагружать ваше приложение с распределенного кластера, очень гибкая, поддерживает кучу всяких протоколов, то есть абсолютно неважно на чем работает приложение на другом конце.
5557.80 5566.60 "Анатолий Кулаков" В частности, из коробки есть HTTP, WebSocket, AMQP, GraphQL, gRPC, SQL и много-много чего еще.
5566.60 5570.88 "Анатолий Кулаков" То есть можно нагрузить абсолютно все, начиная от базы данных до веб-сервера.
5570.88 5582.20 "Анатолий Кулаков" Есть у N-Bomber хорошая интеграция с CIM, то есть можно запускать нагрузочные тесты и валить ваш билд, если вдруг он не прошел по каким-то критериям качества.
5582.20 5594.48 "Анатолий Кулаков" Интересно, что приложение полностью написано на F# и вы можете довольно-таки легко с помощью специального DSL описывать свои сценарии о том, кого нагрузить, как нагрузить, куда нагрузить.
5594.48 5597.68 "Анатолий Кулаков" Вот это все довольно мило выглядит.
5597.68 5605.84 "Анатолий Кулаков" Отчетики он умеет выдавать в красивую консольку с цветами, прогресс-барами и как положено нормальному современному приложению.
5605.84 5621.48 "Анатолий Кулаков" Также у него есть красивые HTML-отчеты, где вы можете в красивых табличках, графиках рассмотреть все более подробно, более персистентно и узнать о том, какие цифры выдает тот или иной нагрузочный сценарий.
5621.48 5625.92 "Анатолий Кулаков" Весной вышел у ребят как раз N-Bomber версии 2.
5625.92 5629.16 "Анатолий Кулаков" Там очень много всего интересно обновилось, заоптимизировалось.
5629.16 5635.88 "Анатолий Кулаков" В общем, довольно удачное время для того, чтобы узнать об этом инструменте и попробовать его попримерить в своих проектах.
5635.88 5640.88 "Игорь Лабутин" Слушай, а инструмент при этом открытый, open-source или свободный или как он, денег хочет?
5640.88 5648.48 "Анатолий Кулаков" Да, инструмент полностью открытый, он лежит на GitHub, каждый может прийти, посмотреть, может быть пофиксить баги, скачать, откомпилировать.
5648.48 5657.16 "Анатолий Кулаков" Но если вы вдруг хотите какой-то плаватной интерфейс поддержки или консультации, то есть платные тарифные планы, куда можно занести мешок денег.
5657.16 5668.24 "Игорь Лабутин" Супер, ну да, я кстати, когда мне такое нужно было, N-Bomber что-то не находил, я по привычке просто пошел, известно куда, в Vegemator и там быстренько все набросал через UI.
5668.24 5679.48 "Анатолий Кулаков" Да, именно так, есть уже инструменты, которые за себя зарекомендовали и давно хорошо живут, но хотелось чего-то православного и вот кажется, что кто-то православный у нас уже вырисовывается.
5679.48 5686.24 "Игорь Лабутин" Ну прикольно, прикольно, да, .NET как бы часто ругают за то, что язык хороший, платформа хорошая, экосистема как-то страдает.
5686.24 5690.04 "Игорь Лабутин" Вот пусть развивается, будет лучше, будет почти как в Java или лучше Java.
5690.04 5692.80 "Игорь Лабутин" Ну что, на этом мы заканчиваем.
5692.80 5696.48 "Анатолий Кулаков" Да, давай, наверное, закругляться, давай посмотрим, что мы сегодня обсудили.
5696.48 5709.12 "Игорь Лабутин" О, сегодня было много чего, сегодня был .NET 6 релиз кандидат 1, который можно использовать в продакшене и в котором довольно с одной стороны мало нововведений, с другой стороны много всяких мелочей, которые полезны и удобны.
5709.12 5718.60 "Игорь Лабутин" Мы узнали новости, что MAUI не будет в General Availability в ноябре, ждем его только в апреле-май следующего года.
5718.60 5732.28 "Игорь Лабутин" Http3 support в .NET 6 тоже, ну скажем так, на очень ранней стадии в том смысле, что его нужно включать разными флажками и прочим и на Mac не работает, но тем не менее, если интересно попробовать, уже можно начинать.
5732.28 5755.84 "Игорь Лабутин" Посмотрели на Visual Studio 2022 Preview 4 и пошли обсуждать кучу всяких статей про TULI и прочую архитектуру, то есть заглянули, что же такого полезного, принесли нам рекорды, можно ли их использовать в VDDD в качестве Value Objects, ответ, ну почти нет, но если очень хочется, то можно.
5755.84 5767.68 "Игорь Лабутин" Посмотрели, как можно смотреть на ваши API с точки зрения совместимости, бинарной либо API совместимости, либо вообще совместимости на уровне сериализации.
5767.68 5775.72 "Игорь Лабутин" Узнали, что можно на самом деле защищаться от того, чтобы качать неправильные Nuget пакеты с неправильных серверов.
5775.72 5777.88 "Игорь Лабутин" Для этого, опять же, нужны последние превьюшки.
5777.88 5792.28 "Игорь Лабутин" Посмотрели очередной набор примеров использования Source Generators, узнали, что вышел Core VCF 0.3.0 практически полностью благодаря open source contribution и поговорили с нашим гостем про то, как вообще это происходит.
5792.28 5804.52 "Игорь Лабутин" Ну и посмотрели, что платформа развивается, экосистема развивается и TULI типа NBomber тоже появляются, причем уже версии 2.0, так что не все так плохо в дотнете, все вообще прекрасно.
5804.52 5820.64 "Анатолий Кулаков" Я хочу напомнить, что у нас впереди ждет конференция .NEXT, если вы вдруг еще не купили билеты, то для нашего подкаста есть специальный промокод, который вы найдете в шоу-нотах на сайте конференции, уже огромное число крутейших докладчиков, интересных докладов, смотрите, присоединяйтесь.
5820.64 5833.16 "Анатолий Кулаков" И несмотря на то, что сегодня новостей от JetBrains у нас не было, эта компания всегда в нашем сердце и поэтому хочется раздать от этой замечательной конторы три лицензии на любой их продукт.
5833.16 5838.12 "Анатолий Кулаков" Друзья, конкурс такой же, как и всегда, правила те же самые.
5838.12 5857.88 "Анатолий Кулаков" Одну лицензию получит комментатор на ютубе к этому выпуску, одну лицензию тот, кто расшарит данный выпуск вконтактике из паблика .NET.RU и одну лицензию получит тот, кто ретвитнет наш твит из аккаунта .NET.RU об этом выпуске.
5857.88 5863.12 "Анатолий Кулаков" Всего три лицензии, розыгрыш будет через 7 дней после релиза данного выпуска.
5863.12 5870.44 "Игорь Лабутин" Ну а на этом мы завершаемся, это был 36 выпуск подкаста Radio.NET, с вами были Игорь Лабутин и Анатолий Кулаков,
5870.44 5871.94 "Анатолий Кулаков" всем пока. Пока.
