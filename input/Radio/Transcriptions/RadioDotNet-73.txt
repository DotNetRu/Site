0.00 11.44 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер 73.
11.44 14.48 "Анатолий Кулаков" Сегодня в студии, как всегда, Анатолий Кулаков.
14.48 15.48 "Анатолий Кулаков" И Игорь Лабутин.
15.48 16.48 "Анатолий Кулаков" Всем привет.
16.48 21.20 "Анатолий Кулаков" И не одни у нас за спиной стоит богатый интересный список.
21.20 28.96 "Анатолий Кулаков" Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Лазарев, Илья, Гурий, Самарин, Виктор, Руслан, Артемонов, Александр, Ярыгин.
28.96 31.80 "Анатолий Кулаков" Спасибо большое, друзья, за то, что поддержите наш подкаст.
31.80 38.20 "Анатолий Кулаков" А если вы хотите присоединиться к этому бравому списку, заходите на наш сайт на Boosty и посмотрите, что там есть интересненького.
38.20 40.96 "Анатолий Кулаков" Ну что ж, давай к выпуску.
40.96 45.96 "Анатолий Кулаков" Мы в прошлый раз сильно ругали Microsoft и компанию за то, что нам новостей никак не предоставляют.
45.96 51.96 "Анатолий Кулаков" И в этот раз они наконец нас услышали, одумались и навалили нам весь выпуск новостей.
51.96 54.56 "Анатолий Кулаков" Похоже, у нас сегодня только новости и влезут.
54.56 61.00 "Игорь Лабутин" Ну, действительно, мы достаточно долго ждали, чтобы хоть чего-нибудь от них дождаться, а в результате получилось следующее.
61.00 68.72 "Игорь Лабутин" Во-первых, прошла конференция Microsoft Build 2023, и там было довольно много всяких разных анонсов.
68.72 74.40 "Игорь Лабутин" Есть большая статья, называется Microsoft Build 2023 Book of News.
74.40 80.28 "Игорь Лабутин" Традиционно Microsoft делает такую штуку, чтобы рассказать полный обзор того, чего было в письменном виде.
80.28 85.04 "Игорь Лабутин" И есть все возможные записи, понятное дело, всех выступлений.
85.04 95.72 "Игорь Лабутин" Вообще, эта конференция, она такая, так сказать, ориентированная на разработчиков, то есть по-хорошему там должно быть все полезное нам.
95.72 104.24 "Игорь Лабутин" Но, есть но, Microsoft сейчас считает, что для разработчиков полезны в основном и исключительно три вещи.
104.24 111.88 "Игорь Лабутин" Это ажур, понятное дело, так было всегда, мне кажется, и AI, Copilot и внезапно Windows 11.
111.88 124.24 "Игорь Лабутин" То есть на конференции, которая вроде как для разработчиков довольно много было всякой разной информации про Windows 11, ну и понятно, про искусственный интеллект в лице Copilot от Microsoft, ChartGPT и всего остального.
124.24 133.24 "Анатолий Кулаков" Ну, насколько я помню, я думаю, наши постоянные слушатели не дадут нам соврать, что Build все время, в последней особенно выпуске, ничего интересного для разработчиков никогда не показывал.
133.24 134.76 "Анатолий Кулаков" Это была конференция про ажур.
134.76 138.12 "Анатолий Кулаков" Ну теперь она стала конференцией про ажур и про искусственный интеллект.
138.12 146.60 "Игорь Лабутин" Да, и при этом надо сказать, что довольно много всего, что было показано, оно пока находится во всяких разных превью стадиях и так далее.
146.60 157.16 "Игорь Лабутин" Что-то уже доступно, что-то еще в превью, поэтому смотрите внимательно на всякие анонсы, которые вы будете более детально изучать, чтобы понять, что же из этого доступно, что из этого надо еще подождать.
157.16 169.28 "Игорь Лабутин" То есть, например, в Windows 11 они там будут всячески встраивать Copilot, что там будет отдельная кнопочка, которая будет появляться отдельным сайт баром, вот это все.
169.28 171.52 "Игорь Лабутин" Все это все пока в превью версии Windows 11.
171.52 183.12 "Игорь Лабутин" Эта штука будет уметь смотреть на ваш там, на ваш собственный контент, то есть в ваши файлики, в ваш календарь, всячески очень умно и искусственно, интеллектуально подсказывать по поводу них что-нибудь.
183.12 184.48 "Игорь Лабутин" В Copilot плагины.
184.48 189.00 "Игорь Лабутин" Интересная штука для разработчиков, которая может быть кому-то полезна, называется Divbox.
189.00 195.40 "Игорь Лабутин" То есть, например, если вы сидите, не знаю, на Маке, вам внезапно нужна или на Линуксе, что может быть еще хуже.
195.40 203.68 "Игорь Лабутин" Вам внезапно нужна винда для разработки, то можно поставить виртуалку, а можно теперь сходить в Microsoft, в Azure опять же, и запросить Divbox.
203.68 212.92 "Игорь Лабутин" Это такая рабочая станция в облаке, которую можно преднастроить, чтобы когда вы ее запустите, она уже там имела в себе, вижу у студии еще что-нибудь.
212.92 214.80 "Игорь Лабутин" Она естественно за деньги.
214.80 221.04 "Игорь Лабутин" Минимальная конфигурация это где-то 4 CPU с 16 гигами памяти и 256 гигов места.
221.04 227.52 "Игорь Лабутин" Если ее не выключать в полный день, то она будет обходиться примерно, я так посчитал по их ценам, 15 долларов в день.
227.52 233.44 "Игорь Лабутин" Ну, как бы, что там получается, 450 долларов в месяц, если вообще не выключать ее и всегда работать.
233.44 236.36 "Анатолий Кулаков" Ну, это там где-то 1000-1500 рублей.
236.36 237.36 "Анатолий Кулаков" 450 долларов?
237.36 238.36 "Анатолий Кулаков" А, не, 15.
238.36 239.36 "Анатолий Кулаков" Ты сказал 15 в день.
239.36 242.00 "Игорь Лабутин" Это в день, я уже на месячные перешел.
242.00 243.00 "Анатолий Кулаков" А, на месячные.
243.00 245.68 "Анатолий Кулаков" Ну, слушай, на месячные это уже только богатые разработчики могут себе позволить.
245.68 254.84 "Игорь Лабутин" Ну, да, короче, но по факту вы, конечно, будете ее там может быть выключать на ночь, еще что-нибудь, ну или по крайней мере не использовать на ночь, я не знаю, как это сделано у них, то есть, ну, наверное, долларов в 300 можно уложить.
254.84 259.44 "Игорь Лабутин" То есть, за 300 долларов в месяц вы можете получить рабочую машинку, если вам вдруг внезапно надо.
259.44 271.24 "Игорь Лабутин" То есть, считается, что это будет хороший оффер для, не знаю, всякой удаленной работы, корпорации будут платить много денег Microsoft, а Microsoft будет предоставлять унифицированные рабочие места для всех.
271.24 273.40 "Игорь Лабутин" Ну, посмотрим, что из этого получится.
273.40 280.80 "Игорь Лабутин" С другой стороны, если у вас ваш собственный компьютер есть, то для вас будет доступна штука под названием DevHome.
280.80 296.26 "Игорь Лабутин" Это как раз это, которые разрабатывали Windows Terminal, которые разрабатывали PowerToys, то есть все вот эти вот приложения, которые мы, как разработчики, можем использовать на наших собственных ноутбуках или на рабочих станциях, десктопах, они сделали новую программку под названием DevHome.
296.26 303.80 "Игорь Лабутин" DevHome это, ну, такой дешборд, что ли, штука, которая поддерживает виджеты, куда можно напихать всяких разных виджетов.
303.80 310.76 "Игорь Лабутин" Сейчас доступен виджеты от GitHub, которые позволяют посмотреть там все ищицы, которые на вас повешены, пол реквеста и так далее.
310.76 318.12 "Игорь Лабутин" И они надеются, что туда же напишут виджеты всякие там, атласины для Jira, слаки для, соответственно, Slack, ну и так далее.
318.12 326.20 "Игорь Лабутин" То есть будет такое единое приложение, куда вы в начале рабочего дня заходите и смотрите, о, сколько всего работает, закрываете и больше не работаете.
326.20 328.24 "Анатолий Кулаков" Это же называется это приложение браузер.
328.24 333.64 "Игорь Лабутин" Ну, видишь, в браузере ты не видишь это все на одном экране.
333.64 344.00 "Игорь Лабутин" Вкладочка GitHub, вкладочка, не знаю, Azure DevOps, например, если ты GitHub смотришь не по работе, а Azure DevOps по работе.
344.00 347.24 "Игорь Лабутин" Вкладочка какой-нибудь Jira и по второй работе.
347.24 350.24 "Игорь Лабутин" Вкладочка с YouTube по третьей работе, ну и так далее.
350.24 351.24 "Анатолий Кулаков" Надо выбрать.
351.24 357.84 "Анатолий Кулаков" Ну, я этому несказанно рад, потому что даже эти вкладочек, у меня сейчас открыто 300 штук и 3 окна браузера, в каждом из них примерно столько.
357.84 362.64 "Анатолий Кулаков" Что будет, если они захотят мне это в один виджет поместить там или в одну панель, я боюсь даже представить.
362.64 367.40 "Игорь Лабутин" Вот ты выкинешь лишнее, ставишь 3 самых главных вкладочки и вот оно и будет то, что нужно.
367.40 370.52 "Игорь Лабутин" Короче, ну, они верят в это, посмотрим, что из этого получится.
370.52 377.10 "Игорь Лабутин" Возвращаясь к .NET, мы вообще говоря, .NET подкаст, поэтому было интересно понять, а что же нового показали про .NET.
377.10 393.72 "Игорь Лабутин" И на самом деле, если читать, как я сказал, букву в news про .NET, не сказали практически ничего, но команда .NET сделала плейлист, то есть всех видео, которые хоть как-то упоминают .NET или в которых хоть как-то участвуют те люди, которые обычно ассоциированы с .NET.
393.72 395.48 "Анатолий Кулаков" Прям натягивают как могут.
395.48 408.80 "Игорь Лабутин" Ну потому что, например, там есть видосик с Скоттом Хансельманом и Марком Русиновичем, которые оба, ну ладно, Скотт Хансельман к .NET относится непосредственно, он его довольно активно популяризирует.
408.80 414.68 "Игорь Лабутин" У него там блог, его живет на .NET, он там много всяких обучающих видео выпустил по .NET.
414.68 421.20 "Игорь Лабутин" Марк Русинович, он известен всякими Windows Internal стулами, которые и к .NET он имеет, в общем-то, не очень большое отношение.
421.20 429.04 "Игорь Лабутин" И на этом видео они с помощью, ну кто бы мог подумать, чат GPT, да, и копайлота пытаются программировать на JavaScript.
429.04 433.68 "Игорь Лабутин" К .NET это относится ну вообще совсем никак, кроме как с Скоттом Хансельманом.
433.68 439.52 "Игорь Лабутин" Но видео получилось офигенно забавным, я крайне рекомендую его глянуть.
439.52 442.20 "Анатолий Кулаков" Очень жалко, что не на C# они там все это делают.
442.20 452.00 "Игорь Лабутин" Ну на C# типа да, но вот они хотели попрограммировать на языке, который они оба, видимо, не очень прям 100% профессионально знают, особенно Марк.
452.00 469.04 "Игорь Лабутин" Вот, там же есть в этом видео и более .NET специфичные штуки, то есть там, например, есть видео от Дамиана Эдвардса и Дэвида Фаулера, традиционный их двойной, так сказать, доклад про всякие перформанс-оптимизации на ETF-out и так далее.
469.04 478.48 "Игорь Лабутин" Там же есть видео с Мэтсом Торгерсоном, ведущим дизайнером языка C#, про то, куда движется C# и что мы, может быть, увидим в C# 12.
478.48 500.52 "Игорь Лабутин" Он показал там пару возможных фич, которые могут приехать в какую-то версию будущего языка, но я сразу говорю, я так проглядывал только видео, не слушал подробно весь рассказ, но там сейчас идут обсуждения про extension everything, чтобы у нас появились не только extension методы, но и вообще можно было расширять типы как угодно, полями там еще чем-нибудь.
500.52 513.96 "Игорь Лабутин" В общем, работа ведется, есть видео, которые там про Blazor, есть видео про Azure, про то, как запихнуть или использовать из C# AI, но есть и такие более хардкорные штуки типа перформанса и так далее.
513.96 528.36 "Игорь Лабутин" Так что смотрите, может быть, вы там найдете что-то интересное или, по крайней мере, проглядите список новостей и вот этот плейлист, чтобы понять, что там есть интересненького в плане, куда движется Microsoft.
528.36 535.16 "Анатолий Кулаков" Ну, если вам там интересен E или Azure, то традиционно там будет очень много всего про это.
535.16 538.04 "Анатолий Кулаков" Так, погнали теперь более к приземленным темам.
538.04 540.84 "Анатолий Кулаков" Все-таки у нас вышли еще анонсы.
540.84 543.32 "Анатолий Кулаков" ДотаНет 8, превью 4.
543.32 550.84 "Анатолий Кулаков" Как всегда, по стандартам у нас вышел анонс самого фреймворка, асп.нета и энтити фреймворка.
550.84 554.00 "Анатолий Кулаков" И давай посмотрим, что там у нас интересного подвезли.
554.00 557.24 "Анатолий Кулаков" Начнем мы с самого главного, своего основного фреймворка.
557.24 564.28 "Анатолий Кулаков" По C# там нет ничего, команда что-то там спит, похоже, но зато есть всего много вокруг тулинга.
564.28 573.16 "Анатолий Кулаков" Прежде всего ребята прооптимизировали консольный терминал логера для MS Build.
573.16 588.40 "Анатолий Кулаков" То есть, я думаю, если кто-то у вас запускал MS Build вручную или .NET Build вручную, или из Visual Studio хотя бы в Output Log смотрел, то наверняка видел список всего, что компилятор пытается сделать, когда собирает ваш проект.
588.40 594.84 "Анатолий Кулаков" Он восстанавливает файлики, проходится по всем солюшенам и билдит билдики, в общем много-много всего.
594.84 604.36 "Анатолий Кулаков" И обычно это такой довольно массивный выхлоп, в котором сообщается куча ненужной информации, куча нужной информации, куча избыточной информации.
604.36 610.84 "Анатолий Кулаков" Ну в общем, такая огромная простыня текста, в которой очень сложно было найти самая главная проблему.
610.84 618.40 "Анатолий Кулаков" Если вдруг билд у вас завершился с ошибкой, вы в конце вам в этом написали, типа "поздравляем, у вас одна ошибка, ура, вы молодец".
618.40 627.12 "Анатолий Кулаков" Вы начинаете скролить, искать, где же эта ошибка произошла, что там случилось и потом пытаетесь каким-то образом еще найти, что там реально за проблема была.
627.12 635.12 "Анатолий Кулаков" И этот фидбэк команде Microsoft уже давно донесли, они его долго собирали и вот решили что-то с ним сделать.
635.12 641.60 "Анатолий Кулаков" И в виде результата того, что они сделали, получился новый терминал-логер.
641.60 652.80 "Анатолий Кулаков" Это специальный режим, наверное, MS Build, да, скорее всего MS Build, который позволяет вам сделать модный, современный, красивый логинг в консоли.
652.80 657.48 "Анатолий Кулаков" Естественно, только те консоли, которые это поддерживают, со всякими интерактивными рюшечками.
657.48 660.92 "Анатолий Кулаков" Ну в частности, можно там сгруппировать ошибки по проекту теперь.
660.92 676.96 "Анатолий Кулаков" Вся структура, когда во время билда представляет собой такой динамический, живущий какой-то куст, который постоянно меняется, что-то вам показывает, потом ненужную информацию склопывает, стирает, оставляет только самореал нужной информации, после этого переходит к следующему проекту.
676.96 681.24 "Анатолий Кулаков" И выглядит это все, конечно, красивенько, и на больших проектах может быть даже будет полезненько.
681.24 684.80 "Анатолий Кулаков" И что он еще умеет делать?
684.80 690.76 "Анатолий Кулаков" Так, этот логер умеет в реальном времени показывать, что он сейчас делает, и какой прогресс обычный у этой операции.
690.76 693.44 "Анатолий Кулаков" И, как я уже сказал, почищает все ненужное.
693.44 701.16 "Анатолий Кулаков" Поэтому в результате, когда у вас все добилось, выхлоп, вот этот отчет, он выглядит более таким стройным, стабильненьким, чистеньким и красивеньким.
701.16 708.96 "Анатолий Кулаков" Ну, это сложно описывать, здесь мы уже переходим в грань какую-то между консолью, текстом и UI, и поэтому желательно один раз увидеть.
708.96 716.56 "Анатолий Кулаков" Поэтому, если можете, то перейдите просто по ссылочке и посмотрите пару гифок, которые показывают, насколько мощный и красивый теперь у нас выхлоп будет.
716.56 722.68 "Анатолий Кулаков" Ну, кроме ясности, наглядности, терминал приобрел способность показывать эмоджи, ну как же без этого?
722.68 725.32 "Анатолий Кулаков" Какой билд C# проекта без эмоджи?
725.32 733.56 "Анатолий Кулаков" Конечно же, мы билдим теперь с эмоджами, там специальным крестиком подсвечивается, на какой строчечке у нас была ошибочка, если вдруг она случилась, поэтому найти ее будет легко.
733.56 742.04 "Анатолий Кулаков" Ну, и если вы хотите вдруг это чудо попробовать, нужно указать специальный флажочек при билде, называется TL.
742.04 753.04 "Анатолий Кулаков" Также есть автоматический режим распознавания совместимости терминала, если вдруг терминал совместим, то по дефолту данный режим красивости включается автоматически.
753.04 759.12 "Анатолий Кулаков" Или можно принудительно включить или выключить благодаря вот такому флажочку вот этот новый способ отображения.
759.12 763.40 "Анатолий Кулаков" Это, наверное, главная рюшечка, которую нам донес четвертый превью.
763.40 767.60 "Анатолий Кулаков" Теперь перейдем к эпопее с директориями.
767.60 776.00 "Анатолий Кулаков" В одном из прошлых выпусков Игорь нам докладывал, что у нас теперь появляется директория .artifacts, в которой будут по умолчанию складываться все артефакты.
776.00 780.84 "Анатолий Кулаков" Вот, мы там еще думали, насколько это может сломать совместимость или не сломать совместимость.
780.84 789.92 "Анатолий Кулаков" Так вот, по отзывам работодателей и разработчиков, команда решила превратить .artifacts в папочку просто "artifacts".
789.92 794.24 "Анатолий Кулаков" И теперь все-таки по умолчанию она будет просто "artifacts" без точечки.
794.24 797.24 "Анатолий Кулаков" Точечку они добавляли там по многим причинам.
797.24 808.68 "Анатолий Кулаков" В частности, они не хотели, чтобы этот файл, даже не файл, а это папочка, как вы понимаете, это папочка с бинарниками со всеми output, которые выдаст вам компилятор.
808.68 813.44 "Анатолий Кулаков" Так вот, они не хотели, чтобы эта папочка с бинарниками случайно залетела в ваш репозиторий.
813.44 814.88 "Анатолий Кулаков" Например, когда вы делаете git commit.
814.88 827.52 "Анатолий Кулаков" Но потом внезапно острый глаз обнаружил, что практически во всех там дефолтных git-игнорах, особенно git-игнорах для Visual Studio, там уже папочка .artifacts добавлена как исключение.
827.52 837.04 "Анатолий Кулаков" Поэтому они расслабились и решили, что это для них уже больше не проблема, поэтому эта папочка не залетит случайно в git-репозиторий и разработчики должны чувствовать себя великолепно.
837.04 847.56 "Анатолий Кулаков" Если вы хотите попробовать данную фичу о том, как все вкладывается в один папочку .artifacts, то вам нужно в директоре битпропсах включить специальный флажочек.
847.56 859.88 "Анатолий Кулаков" Или же создать новый файл в директоре пропс с помощью нового темплейта, который делается с помощью команды .net new buildprops --useartifacts.
859.88 868.24 "Анатолий Кулаков" И тогда он создаст правильный файлик битпропс, положит его куда нужно и добавит туда нужный флажочек с использованием как раз папочки .artifacts.
868.24 872.48 "Анатолий Кулаков" Так, про SDK, про билд вроде все.
872.48 874.68 "Анатолий Кулаков" Давай к Nuget.
874.68 877.84 "Анатолий Кулаков" Nuget хорошо занялись с точки зрения безопасности.
877.84 888.08 "Анатолий Кулаков" В частности, в этой версии сделали запрет на скачивание Nuget пакетов из ресурсов, которые работают по протоколу HTTP.
888.08 890.44 "Анатолий Кулаков" То есть из фидов по HTTP.
890.44 903.84 "Анатолий Кулаков" То если вы укажете какой-нибудь фид с таким протоколом, морально устаревшим, то вам выдастся ошибка и скажет "не, качать не буду, давайте нормально с HTTPS будем шифроваться".
903.84 912.44 "Анатолий Кулаков" Естественно, это поведение можно подавить с помощью флажка force.
912.44 918.44 "Анатолий Кулаков" То есть если вы скажете "качай", я все-таки сильно сказал, то тогда он вам все-таки скачает.
918.44 930.80 "Анатолий Кулаков" Но этот флажок планируют удалить в .net 9, поэтому можете пока баловаться во время перехода, но все-таки рекомендуется все свои фиды перевести именно на HTTPS и тогда у вас никаких проблем не будет.
930.80 939.96 "Анатолий Кулаков" Также Nuget научился сообщать вам об security уязвимостях в некоторых пакетах, в тех пакетах, про которые он знает.
939.96 955.16 "Анатолий Кулаков" Во время install, update или просто проверки, security проверки, он нам скажет, что типа "вот у вас пакет, который вы пытаетесь сейчас установить, он содержит security уязвимости, не ешьте его.
955.16 958.88 "Анатолий Кулаков" Возьмите что-нибудь или поновее, или замените его чем-нибудь".
958.88 962.28 "Анатолий Кулаков" Это поведение также можно подавить с помощью флажка force.
962.28 969.96 "Анатолий Кулаков" То есть если вы скажете "install force", то он все-таки установит вам пакет с уязвимостями, но при этом вас сильно-сильно предупредит.
969.96 988.68 "Анатолий Кулаков" Другим нововведением Nuget еще является то, что теперь добавили в видимое место специальный флажочек, который называется "trusted", а по сути он является отображением флажка prefix-reserve, который мы обсуждали в нескольких выпусках назад.
988.68 1004.40 "Анатолий Кулаков" То есть когда вы показываете, например, список установленных пакетов или список пакетов, которые хотите поставить, в общем какую-то информацию о пакете пытаетесь вытащить, то там вам прежде всего скажут, что зарезервирован этот префикс или нет, то есть доверять этому паблишеру или нет.
1004.40 1017.08 "Анатолий Кулаков" И также добавили package-owner, новое поле, которое тоже помогает сориентироваться в том, насколько данный автор заслуживает к себе доверия или нет.
1017.08 1027.36 "Анатолий Кулаков" Еще интересная фича в плане security-report - это аудит ваших пакетов, который происходит во время восстановления, то есть во время рестора.
1027.36 1037.32 "Анатолий Кулаков" Как только вы делаете .NET restore, может запуститься специальный анализ, который проверит все ваши пакеты на наличие критических security-вызывимости.
1037.32 1044.48 "Анатолий Кулаков" Это похоже немножко на тот флажок, который я сообщал ранее, но тот работает только когда вы новое что-то ставите и не тратит время вам на каждый рестор.
1044.48 1045.48 "Анатолий Кулаков" А этот тратит.
1045.48 1054.24 "Анатолий Кулаков" Но, наверное, имеет больше смысла, потому что, наверное, устанавливаете вы пакеты нечасто, а вот ресторите вы их каждый билд.
1054.24 1062.12 "Анатолий Кулаков" Поэтому этот способ нужен для того, чтобы как можно раньше узнавать об ошибках.
1062.12 1071.56 "Анатолий Кулаков" Чтобы включить такой отчет, нужно добавить специальный флажок в ваш nuget файл или csproj файл, который называется nuget audit true.
1071.56 1079.80 "Анатолий Кулаков" Также можно выставить уровень аудита, который будет вам сообщать о том, насколько ваше приложение в опасности.
1079.80 1091.36 "Анатолий Кулаков" Вы можете поставить, чтобы он вам сигнализировал о низком уровне, о высоком или только о критичных каких-то уязвимостях, которые есть в тех зависимостях, которые использует ваше приложение.
1091.36 1094.16 "Анатолий Кулаков" Так, по nuget все.
1094.16 1095.16 "Анатолий Кулаков" По классикам.
1095.16 1101.08 "Анатолий Кулаков" Наконец, мучили-мучили и так и не вымучили, но внедрили TimeProvider.
1101.08 1108.96 "Анатолий Кулаков" TimeProvider мы уже обсуждали несколько выпусков назад, но вкратце повторюсь, что это специальная абстракция.
1108.96 1115.04 "Анатолий Кулаков" Это специальный абстрактный класс, который нужен для того, чтобы использовать его в моках.
1115.04 1124.08 "Анатолий Кулаков" Чтобы элементарно можно было замокать время, которое часто используется во всяких тестовых сценариях, и сделать ваши тесты более предсказуемыми.
1124.08 1130.36 "Анатолий Кулаков" Наверняка в ваших проектах уже есть такие интерфейсики, которые просто-напросто мокают текущую дату и время.
1130.36 1134.64 "Анатолий Кулаков" Или вы могли бы видеть такие интерфейсики в других проектах.
1134.64 1135.64 "Анатолий Кулаков" Не суть важно.
1135.64 1137.68 "Анатолий Кулаков" Важно, чтобы вы никогда не увидели такого монстра.
1137.68 1146.96 "Анатолий Кулаков" Если вы наблюдали это в своих проектах или в чужих проектах, там обычно это какой-нибудь один метод, который называется getUTCNow, возвращает вам UTCшную дату и все.
1146.96 1149.04 "Анатолий Кулаков" Больше, в принципе, для нормального приложения ничего не нужно.
1149.04 1158.00 "Анатолий Кулаков" Если же мы посмотрим на то чудовище, которое предоставила нам команда Microsoft, команда .NET, то здесь ответственности и целая куча.
1158.00 1165.36 "Анатолий Кулаков" Например, как я уже сказал, естественно, есть здесь метод getUTCNow, плюс у него есть метод getLocalNow.
1165.36 1166.96 "Анатолий Кулаков" Ну ладно, за это еще можно простить.
1166.96 1171.44 "Анатолий Кулаков" Но дальше они пошли уже совсем в какую-то дверь в ад открыли.
1171.44 1177.32 "Анатолий Кулаков" Это также является не только временем, провайдером времени, но и провайдером таймзоны.
1177.32 1180.84 "Анатолий Кулаков" Потому что теперь он еще умеет вам сообщать таймзону.
1180.84 1189.68 "Анатолий Кулаков" Далее он умеет вам сообщать частоту процессора, то есть таймстэп фриквенси, с помощью которой можно посчитать тики более точно.
1189.68 1199.48 "Анатолий Кулаков" Если вам нужны какие-то перформанс измерения, то лучше, конечно, использовать не дату, время, а именно такие ланги, которые в виде ланга здесь представлены.
1199.48 1210.48 "Анатолий Кулаков" То есть мы можем вернуть фриквенси, мы можем вернуть таймстэпы, мы можем посчитать, сколько времени прошло от одного таймстэпа до другого таймстэпа в лангах, я замечу.
1210.48 1221.04 "Анатолий Кулаков" И также мы можем создать некий таймер, который используют там во всяких асинках, тасках и прочих вещах.
1221.04 1226.64 "Анатолий Кулаков" Это уже какая-то треть ответственности, мы еще создаем таймеры.
1226.64 1228.68 "Анатолий Кулаков" И все это, естественно, виртуальное.
1228.68 1233.20 "Анатолий Кулаков" То есть все это мы почему-то должны хотеть уметь переопределять.
1233.20 1235.24 "Анатолий Кулаков" Ну естественно для тестов, для чего же еще.
1235.24 1242.56 "Анатолий Кулаков" Смысл в том, что здесь напихали очень много всякой ответственности, очень много сплели вместе, даже то, кому надо, кому не надо.
1242.56 1248.00 "Анатолий Кулаков" И ишью по этому поводу заслужило очень много комментариев.
1248.00 1249.68 "Анатолий Кулаков" Приходили все.
1249.68 1255.72 "Анатолий Кулаков" Приходил Марк Симон, приходил Джон Скид, жаловались абсолютно все, кто только может жаловаться по этой теме.
1255.72 1259.84 "Анатолий Кулаков" Но как показал результат, видимо никого из них не послушали.
1259.84 1261.96 "Анатолий Кулаков" Выпустили вот то, что есть.
1261.96 1266.28 "Анатолий Кулаков" Скорее всего в таком именно виде оно и попадет к нам в релиз.
1266.28 1267.28 "Анатолий Кулаков" Ну посмотрим.
1267.28 1276.52 "Анатолий Кулаков" Очень много нововведений про интринсики, векторы, avx и прочие страшные вещи, которых я наверное ничего не знаю.
1276.52 1278.80 "Анатолий Кулаков" Если вам это интересно, то скорее всего вы знаете больше меня.
1278.80 1282.04 "Анатолий Кулаков" Поэтому я немножко упомяну еще про ahead of time compilation.
1282.04 1290.06 "Анатолий Кулаков" А вот сейчас цветет и пахнет, но в том плане, что очень много ей уделяется времени и оно внедряется практически везде.
1290.06 1294.16 "Анатолий Кулаков" Вот в частности обновился темплейт консольной программы.
1294.16 1301.60 "Анатолий Кулаков" Вот когда вы делаете .NET new console, создаете новую консольную программу, теперь туда добавилась поддержка флажочка - -out.
1301.60 1307.48 "Анатолий Кулаков" То есть сразу вы создаете консольку, которая нацелена на out компиляцию.
1307.48 1312.80 "Анатолий Кулаков" И у вас создается проект, сконфигурированный специально для out.
1312.80 1313.80 "Анатолий Кулаков" Что это значит?
1313.80 1316.24 "Анатолий Кулаков" Это значит в основном три пункта.
1316.24 1324.92 "Анатолий Кулаков" Во-первых, .NET publish, когда вы сделаете такому проекту вашей консольки, он в результате сгенерит нативный self-contained файлик.
1324.92 1329.16 "Анатолий Кулаков" Один файлик, который оптимизирован под .NET iOT.
1329.16 1342.76 "Анатолий Кулаков" Во-вторых, в ваше приложение добавятся рослин анализаторы, которые будут анализировать ваш код на предмет совместимости с стримингом, с аутом и с тем, чтобы запаковать это в сингл файл, в единый файлик.
1342.76 1350.52 "Анатолий Кулаков" И в-третьих, включится специальный режим отладки, который позволит во время дебага эмулировать аут.
1350.52 1359.52 "Анатолий Кулаков" То есть на самом деле у вас там аута не будет, но он будет выдавать вам все те же ошибки, если вдруг вы начнете каким-то образом вызывать код, который не совместим с аутом.
1359.52 1363.44 "Анатолий Кулаков" В общем, тоже довольно полезная и интересная штука.
1363.44 1369.76 "Анатолий Кулаков" И вот такой интересный темплетик добавили.
1369.76 1372.76 "Анатолий Кулаков" Еще стоит упомянуть наверное System Tech JSON.
1372.76 1374.80 "Анатолий Кулаков" Опять же, там есть мелкие нововведения.
1374.80 1376.32 "Анатолий Кулаков" Мне бы хотелось выделить одно.
1376.32 1381.04 "Анатолий Кулаков" Теперь это чудо умеет заполнять read-only поля и read-only свойства.
1381.04 1398.40 "Анатолий Кулаков" То есть когда вы десертилизуете ваш read-only классик, то с помощью специальной опции JSON serialization options, он, можно сказать этому сериализатору, что несмотря на то, что поле read-only, несмотря на то, что field read-only, его нужно тоже записать.
1398.40 1403.04 "Анатолий Кулаков" Вот такое немножко контринтуитивное поведение, но наверное кому-то это нужно.
1403.04 1410.36 "Анатолий Кулаков" Также, сию штуку можно настроить не глобально через опции всего десериализатора, а конкретно атрибутами.
1410.36 1413.32 "Анатолий Кулаков" То есть на классик или индивидуально на каждое свойство.
1413.32 1416.28 "Анатолий Кулаков" И тогда он будет применяться только к каждому свойству.
1416.28 1418.88 "Анатолий Кулаков" Вот в принципе все, что касается основного дотнета.
1418.88 1426.48 "Анатолий Кулаков" Как мы увидели, там C# нету, но над SDK, и над Nuget, и над MS Build работает очень даже активно.
1426.48 1437.36 "Игорь Лабутин" Вообще интересно, что System Tech JSON попал в общую часть дотнета, потому что мне казалось, обычно они все такие новости про него запечатывают в ASP.NET Core.
1437.36 1444.52 "Игорь Лабутин" Но видимо ASP.NET Core тоже было немало, мы сейчас к ним вернемся, раз уж мы начали говорить про JSON.
1444.52 1449.12 "Игорь Лабутин" Давай немножко отвлечемся на внезапно Entity Framework.
1449.12 1458.24 "Игорь Лабутин" Пойдем немножко по тому порядку, как мы обычно ходим, потому что то, что завезли в Entity Framework в 8 preview 4, оно относится к JSON.
1458.24 1460.40 "Игорь Лабутин" Ну, как бы это ни показалось странным.
1460.40 1463.44 "Игорь Лабутин" Смотрите, значит они сделали следующую штуку.
1463.44 1480.80 "Игорь Лабутин" Предположим, у вас есть запрос, где вы в линку пишете что-нибудь типа where, какая-нибудь ваша переменная, name, поле объекта, in, и дальше список каких-то констант, строчек например.
1480.80 1486.36 "Игорь Лабутин" То есть вы просто проверяете, что имя является одним из какого-то предопределенного списка.
1486.36 1501.04 "Игорь Лабутин" Что делает Entity Framework, когда он видит такую штуку для трансляции, то есть в link_u, который через методы, вы будете писать это все, конечно же, через contains.
1501.04 1515.28 "Игорь Лабутин" То есть вы пишете, что там where ваша коллекция, на ходу созданный массивчик из двух элементов или из трех, из пяти, точка contains и соответственно тот объект, ту переменную, которую вы хотите сравнить.
1515.28 1523.24 "Игорь Лабутин" А link_u, Entity Framework, это все странслирует нормальный SQL.
1523.24 1525.28 "Игорь Лабутин" Но что значит нормальный?
1525.28 1527.72 "Игорь Лабутин" Далеко не все базы данных умеют работать с массивами.
1527.72 1535.04 "Игорь Лабутин" На самом деле такая по-хорошему, в общем-то только passgres, наверное, из таких, которыми с Entity Framework нормально используется.
1535.04 1546.04 "Игорь Лабутин" Поэтому фактически он транслирует эту SQL конструкцию where, там, name, например, in, и дальше в круглых скобочках набора, собственно, через запятую всех значений, которые указали.
1546.04 1556.56 "Игорь Лабутин" Но проблема в том, что поскольку нормально массив не передать параметр, то Entity Framework делает простую штуку, он просто все ваши значения вставляет в запрос.
1556.56 1573.68 "Игорь Лабутин" Ничего суперплохого в этом нету, кроме того, что это немножко портит работу кэша запросов, кэша запросов либо планов выполнения, если мы говорим про SQL Server, потому что в зависимости от разных переданных значений у вас будут получаться разные запросы.
1573.68 1584.36 "Игорь Лабутин" Ну и, соответственно, у вас будет из-за этого проблема с performance, потому что каждый раз новый запрос, его надо заново компилить, невозможно переиспользовать уже готовый план, если мы, например, на SQL Server.
1584.36 1588.48 "Игорь Лабутин" Хотя запрос, в общем-то, точно такой же, он отличается только текстом этих значений.
1588.48 1605.20 "Игорь Лабутин" И проблема с performance вокруг этого является одной из наиболее важных для комьюнити, в том смысле, что она является второй по порядку с точки зрения реакции больших пальцев вверх в репозиторий.
1605.20 1607.92 "Анатолий Кулаков" Интересно, то есть часто пользуется, да?
1607.92 1609.64 "Игорь Лабутин" Я думал, что это такой редкий случай.
1609.64 1617.16 "Игорь Лабутин" Видимо, многие упираются в это, то есть проверить, что он в каком-то фиксированном пачке этих самых значений.
1617.16 1621.56 "Игорь Лабутин" Причем ты же можешь эти значения в рентайме собрать, да?
1621.56 1622.56 "Игорь Лабутин" Ну конечно, обычно так и есть.
1622.56 1625.20 "Игорь Лабутин" Да, но дальше все равно это претранслируется в статический запрос.
1625.20 1632.16 "Игорь Лабутин" Интересно, сможешь ли ты сказать так сходу, какая самая желаемая фича?
1632.16 1634.12 "Анатолий Кулаков" То есть это на втором месте, да?
1634.12 1635.12 "Анатолий Кулаков" Кто на первом?
1635.12 1636.12 "Анатолий Кулаков" Да.
1636.12 1637.12 "Анатолий Кулаков" У NTT Framework.
1637.12 1638.12 "Анатолий Кулаков" У NTT Framework.
1638.12 1639.88 "Анатолий Кулаков" Наверное, поддержать документно-редированные базы данных.
1639.88 1641.24 "Игорь Лабутин" Нет, там все проще.
1641.24 1642.84 "Игорь Лабутин" Они просят поддержать нормально absurd.
1642.84 1644.92 "Игорь Лабутин" А, absurd, ну да, да.
1644.92 1648.20 "Анатолий Кулаков" Но просто непонятно, почему это NTT Framework должен делать, да?
1648.20 1649.20 "Анатолий Кулаков" Ну потому что это же не совместимо.
1649.20 1650.20 "Анатолий Кулаков" Ну это не стандарт.
1650.20 1651.92 "Игорь Лабутин" Не совместимо между всеми базами данных.
1651.92 1656.16 "Игорь Лабутин" Там даже ищи называется, типа please support merch/absurd/addonsert.
1656.16 1657.16 "Игорь Лабутин" Да, да, да.
1657.16 1660.92 "Игорь Лабутин" Но типа он вот самый-самый-самый голосуемый.
1660.92 1663.20 "Игорь Лабутин" Его хотят больше всего.
1663.20 1665.00 "Игорь Лабутин" А эта штука была на втором месте.
1665.00 1669.20 "Игорь Лабутин" Так вот, теперь это делается внезапно через JSON.
1669.20 1683.88 "Игорь Лабутин" То есть теперь, когда вы пишете в C# коде запросик типа там, ну что-нибудь там where, значит, и дальше лямбдочку там, типа какой-нибудь там name, ну или там x стрелочка, x.name.
1683.88 1686.80 "Игорь Лабутин" Даже наоборот это надо писать.
1686.80 1694.72 "Игорь Лабутин" Ваш там массив ваших значений, предупредленный, .contains и дальше x.name, то есть поле вашего объекта, да?
1694.72 1697.52 "Игорь Лабутин" Которое потом превразуется в колонку из SQL.
1697.52 1709.48 "Игорь Лабутин" То теперь NTT Framework транслирует это, он берет этот массив, а на лету его будет потом, то есть он его будет передавать как строчку, как JSON строчку в базу.
1709.48 1721.08 "Игорь Лабутин" А в базе, соответственно, с запросом будет делать open JSON, используя функцию, например, open JSON или соответствующие аналоги во всех других базах, потому что все нормальные базы с JSON умеют работать.
1721.08 1723.72 "Игорь Лабутин" Ну вот это ты загнул, SQLite тоже?
1723.72 1726.48 "Игорь Лабутин" Ну они не заморачиваются такими мелочами.
1726.48 1729.04 "Игорь Лабутин" POSRES и SQL Server работают, им достаточно.
1729.04 1731.64 "Игорь Лабутин" Во-во, во всех других базах, POSRES и SQL Server.
1731.64 1744.12 "Игорь Лабутин" Да-да-да, ну в общем, короче, смысл в том, что они будут передавать это как параметр, и open JSON, вот именно JSON синтексисом SQL проверять, входит ли колонка в список значений.
1744.12 1752.04 "Игорь Лабутин" То есть запрос будет становиться существенно сложнее за счет этой JSON, потому что SQL вокруг JSON это обычно что-то малочитаемое, с моей точки зрения.
1752.04 1763.36 "Игорь Лабутин" Там вот эти все приседания с "как там правильно open JSON заджойнить", что-то там, короче, не всегда легко читается, но в общем будет теперь вот так нормально.
1763.36 1771.00 "Игорь Лабутин" А вторую штуку, которую, дальше они сказали, например, в следующей статье, ну раз мы сделали такую штуку, мы поняли, что легко поддержать и другую вещь.
1771.00 1779.04 "Игорь Лабутин" Смотри, есть у тебя модель, ну какой-нибудь класс, который мапится на табличку, и ты там объявляешь property вида массив стрингов.
1779.04 1794.16 "Игорь Лабутин" Ну такой типичный пример, не знаю, у тебя есть какая-нибудь там, не знаю, пост, ну там, да, если вот с точки зрения классических этих примеров для релизационных баз данных, у тебя есть там авторы посты, да, и к постам комменты, а еще у поста есть теги в блоге.
1794.16 1798.24 "Игорь Лабутин" Вот ты, естественно, ну теги это просто массив строк, правильно?
1798.24 1805.68 "Игорь Лабутин" Ты у объекта блог, блог пост, говоришь, что у тебя теперь есть стринг, значит, дальше квадратные скобочки, что вот это тегс.
1805.68 1809.72 "Игорь Лабутин" И говоришь, entity framework, сгенерить ты мне базу по этой модели.
1809.72 1819.96 "Игорь Лабутин" Раньше entity framework сказал бы тебе, я, кстати, не помню, что он говорит, если он встречает незнакомый ему тип, ну который он не может смапить в базу никак.
1819.96 1821.76 "Анатолий Кулаков" Возьми монгу, что ты делаешь?
1821.76 1822.76 "Игорь Лабутин" Ну типа того, вот.
1822.76 1824.52 "Анатолий Кулаков" У меня должна быть третья нормальная форма, ты про
1824.52 1840.08 "Игорь Лабутин" нее забыл. Теперь он спокойненько сгенерит тебе колоночку, если в сиквеле это будет nvarchar_max, ну в подгрефе это будет, видимо, просто текст, в нее запишет содержимое этой колонки в виде json массива автоматически.
1840.08 1844.56 "Игорь Лабутин" Ну и обратно, соответственно, тоже будет мапить json массивы на такие вот массивы в C#.
1844.56 1848.40 "Анатолий Кулаков" Слушай, ну он же поддерживает колонки типа json, да, насколько я помню?
1848.40 1851.76 "Игорь Лабутин" Да, это вот было, по-моему, в семерке было сделано, если я правильно помню.
1851.76 1856.92 "Анатолий Кулаков" Ну то есть это же просто-напросто поддержать колонку json и записать туда json массив.
1856.92 1862.28 "Игорь Лабутин" Да, но это как бы будет, тебе не нужно на поле вешать атрибут, что это json, вот это все.
1862.28 1863.96 "Игорь Лабутин" То есть ты говоришь, что это просто массив.
1863.96 1867.16 "Игорь Лабутин" Ну то есть это как бы на халяву получилась такая фича.
1867.16 1889.16 "Игорь Лабутин" Ну и, соответственно, если они еще используют вот эти, если вы где-то используете эти inline коллекции, да, так называемые, то есть когда вы объявляете коллекцию прямо inline, там new int, для фигурной скобочки, и там типа 1, 2, 3, то это теперь, он старается транслировать в сиквельный оператор values, который, понятно, тоже, собственно, поддерживает набор значений.
1889.16 1894.20 "Игорь Лабутин" Ну, values генерирует, по сути, одну запись с заданными значениями.
1894.20 1907.44 "Игорь Лабутин" В общем, всячески поразвлекались вокруг коллекции, когда вы проверяете принадлежность той или иной колонки в коллекции или когда вы сохраняете коллекцию примитивных типов в базу или загружаете.
1907.44 1918.32 "Игорь Лабутин" Поэтому если вы какими-то этими фичами пользуетесь, посмотрите на новый preview 4, не то чтобы надо его прямо сейчас тащить в production, но последите за тем, что там будет изменяться, кажется, что вокруг этого они могут еще чего-нибудь накрутить.
1918.32 1924.92 "Игорь Лабутин" Но, там есть несколько но, там не все примитивные типы поддержаны до конца в разных сценариях.
1924.92 1932.16 "Игорь Лабутин" Где-то как раз что-то не поддержано на SQLite, что-то не поддержано в POPGESOVYM драйвере, но они говорят, что мы все допилим, все будет.
1932.16 1946.64 "Анатолий Кулаков" Ну вот, многие годы backendчики страдали от страшного засилья фронтендчиков и JSON, теперь эти датапазисты тоже прекратят над нами смеяться и тоже будут страдать, потому что теперь все запросы у нас будут на JSON летать.
1946.64 1964.32 "Игорь Лабутин" Ну и да, SQL Server, SQL-ные запросы будут выглядеть как очень страшный и непонятный код, потому что JSON в SQL, я еще раз говорю, я его не очень люблю и не очень понимаю, в смысле, обычный SQL читается нормально, а как только там встречается OpenJSON, ну это примерно как было с OpenXML и дальше что-то там с XML.
1964.32 1965.96 "Анатолий Кулаков" Ладно, OpenXML был прекрасен.
1965.96 1970.96 "Игорь Лабутин" Ну, он, может быть, прекрасно работал, но читать его было так себе, мне не нравилось.
1970.96 1974.96 "Игорь Лабутин" Нет, там был, подожди, там был не OpenXML, там был ForXML что-то
1974.96 1986.32 "Анатолий Кулаков" там. Ну да, да, OpenXML, ну который по стандарту, он страшненький, а вот который у Microsoft родной был в SQL Server уже давно, там с начала времен, вот, он вполне нативный синтекси-СМЛ, у него хорошо было.
1986.32 1987.32 "Анатолий Кулаков" Ну, все равно.
1987.32 1988.32 "Игорь Лабутин" Прям на линку был похож.
1988.32 1993.60 "Игорь Лабутин" Ну вот да, но все-таки не совсем нативный, мне как-то вот что-то все время глаза резало.
1993.60 1995.84 "Анатолий Кулаков" Ладно, давай посмотрим, что у нас в ASP.
1995.84 1998.48 "Анатолий Кулаков" Теперь у тебя глаза просто вытекут, не будут резаться.
1998.48 2003.40 "Анатолий Кулаков" Да, мы пропустили ASP и там, в принципе, много всего завезли, давайте пробежимся.
2003.40 2006.72 "Анатолий Кулаков" ASP.NET 8 Preview 4.
2006.72 2013.60 "Анатолий Кулаков" Прежде всего для Blazor, для Blazor есть одна большая интересная фича, про нее у нас отдельная статья, поэтому я ее придержу.
2013.60 2018.16 "Анатолий Кулаков" Кроме того, у Blazor появился отложенный стриминг-рендеринг.
2018.16 2026.24 "Анатолий Кулаков" Это страшное слово обозначает, что мы теперь можем контент с сервера отдавать на клиент постепенно.
2026.24 2033.12 "Анатолий Кулаков" Ну, это все, естественно, делается в Blazor Component, потому что постепенно отдавать мы его всегда могли, а вот Blazor Component немножко от этого страдали.
2033.12 2035.16 "Анатолий Кулаков" Вот у них такая функциональность была немножко недоступна.
2035.16 2036.72 "Анатолий Кулаков" Например, что это значит?
2036.72 2055.24 "Анатолий Кулаков" Если вы отдаете пользователям свою какую-то первую страничку и на этой страничке вам нужно загрузить какой-то страшный запрос, очень долгий, к стороннему сервису падает и все такое, то вы первым делом отдаете ей лейаут главной страницы, то есть какой-нибудь шаблончик, который больше пользователю показывает, что все хорошо, мы грузимся, недалеко не уходите.
2055.24 2065.08 "Анатолий Кулаков" После этого запускаете свой длинный реквест и в тот момент, когда реквесты у вас отдают хоть какие-то данные, вы их можете досылать в ваш лейаут.
2065.08 2068.96 "Анатолий Кулаков" Допустим, там, не знаю, какие-нибудь карточки в трейл, у вас миллиард карточек, все тяжелые, с видео.
2068.96 2075.24 "Анатолий Кулаков" И вот они могут появляться по одной постепенно в тот момент, когда сервер ваш их отдает и обрабатывается.
2075.24 2086.56 "Анатолий Кулаков" Это делает возможным сделать такую страничку, которая быстро показывается перед пользователем, он перестает нервничать и дальше ему уже добавляется контент по мере того, как он начинает быть готов на серверной стороне.
2086.56 2087.56 "Анатолий Кулаков" Тоже удобно.
2087.56 2091.64 "Анатолий Кулаков" И еще одна интересная штука - это поддержка формата WebTool.
2091.64 2101.80 "Анатолий Кулаков" WebTool призван для того, чтобы решить проблему с нативными файликами Blazor.
2101.80 2104.04 "Анатолий Кулаков" Сейчас, немножко объясню сначала.
2104.04 2115.12 "Анатолий Кулаков" Прежде всего Blazor WebASM, который выполняется на клиентской стороне, который выполняется в браузере, он генерится в виде виндовых DLL, ну вот прям тупо расширение .dll.
2115.12 2129.24 "Анатолий Кулаков" И когда ваш веб-браузер пытается загрузить файлик .dll, любой вменяемый firewall или антивирус начинает кричать, что вы грузите бинарный код, который может исполняться и который потенциально может содержать вирусы.
2129.24 2133.76 "Анатолий Кулаков" Из интернета обычно напрямую DLL из XS-ники нормальные люди не грузят.
2133.76 2139.52 "Анатолий Кулаков" И это был вообще красный флаг для всех защитников нашей корпоративной сети.
2139.52 2154.40 "Анатолий Кулаков" Вот чтобы решить эту проблему, для того чтобы избавиться от вот этого исторического, исторической несправедливости, которая считает, что все файлики .xs.dll это виндусовые вирусы, был предложен формат, который называется WebTool.
2154.40 2165.26 "Анатолий Кулаков" По сути это те же самые бинарники WebASM, просто они избавлены от расширений виндовых и избавлены от начальных ядров, которые показывают, что это действительно какой-то запускаемый файлик.
2165.26 2173.08 "Анатолий Кулаков" То есть WebTool это просто-напросто формат WebASM никак не связанный с виндусом или с какой-нибудь запускабельностью.
2173.08 2181.40 "Анатолий Кулаков" Так вот, именно этот формат теперь поддержан в новом превью и его можно использовать и угомонить наконец-то ваших защитников корпоративной сети.
2181.40 2195.24 "Анатолий Кулаков" А еще интересная штука добавилась в темплейты, которые вы создаете с помощью .NET New API, то есть это проект, с помощью которого вы хотите сделать какой-то API сервер.
2195.24 2198.52 "Анатолий Кулаков" В этот темплейт теперь по умолчанию включены файлики .http.
2198.52 2204.48 "Анатолий Кулаков" Это очень удобные файлики для того, чтобы отправлять запросы на ваши endpoints.
2204.48 2217.52 "Анатолий Кулаков" И представляют они из себя обычные текстовые файлики, в которых там написан адрес сервиса, какие-нибудь http вербы, которые можно сделать с этим адресом, заголовки, может быть даже body в JSON.
2217.52 2219.24 "Анатолий Кулаков" В общем, очень полезный файл.
2219.24 2237.08 "Анатолий Кулаков" Мы про них уже не раз упоминали в контексте и райдера, и Visual Studio Code, который был как раз-таки плагин, который как раз-таки послужил вдохновлением к новому редактору Visual Studio, который умеет поддерживать теперь тоже.
2237.08 2241.80 "Анатолий Кулаков" Из большой Visual Studio теперь тоже можно поддержать http и вот эти файлики.
2241.80 2245.76 "Анатолий Кулаков" Очень полезные штуки для тестирования, для оплатки, для каких-то демок.
2245.76 2254.04 "Анатолий Кулаков" Поэтому, если вы их еще не освоили, то теперь у вас вообще нет оправданий во всех редакторах, которыми пользуются уже датанные разработчики, они уже появились.
2254.04 2256.60 "Анатолий Кулаков" Поэтому пробуйте, смотрите, хорошие файлики.
2256.60 2260.12 "Анатолий Кулаков" Тем более теперь они ходят в стандартный темплейт.
2260.12 2270.20 "Анатолий Кулаков" Дальше интересная штука о том, как компания научилась избавляться от ненужных размеров вашего выходных файликов, выходных артефактов.
2270.20 2285.80 "Анатолий Кулаков" В общем, они делают много всего интересного в этой области, особенно если мы говорим про native iot, то есть когда мы пытаемся скомпилировать в нативный iot, то там как раз очень много техник есть, которые позволяют уменьшить размер файлов.
2285.80 2302.52 "Анатолий Кулаков" И вот одна из техник, до которой дошли люди, это техника, которая говорит, что если вашему приложению не нужен https и http3, то вся поддержка вот этого чуда она удаляется.
2302.52 2314.88 "Анатолий Кулаков" А это не такой уж и редкий случай, как вы можете себе представить, потому что очень много backend сервисов работают за каким-нибудь TLS-прокси, TLS-termination-прокси.
2314.88 2332.84 "Анатолий Кулаков" Ну например во всех облаках, в ажуре облаках или в локальных корпоративных сетях обычно там ставят какой-нибудь впереди Nginx, который полностью обеспечивает тлс-соединение, а все ваши сервисы уже общаются по http, по https, без всякой security, без всякого http3, это вам вообще не нужно.
2332.84 2338.72 "Анатолий Кулаков" И вот если вы эту поддержку просто-напросто вырежете из фреймворка, то это даст вам дополнительных 2 мегабайта.
2338.72 2342.48 "Анатолий Кулаков" Что не так уж и мало, если мы говорим про Netioid.
2342.48 2345.60 "Анатолий Кулаков" Вот такую штуку сделали как раз в Preview 4.
2345.60 2353.48 "Анатолий Кулаков" А чтобы вам дать больше картину о том, какая сейчас ситуация у нас с размерами.
2353.48 2365.20 "Анатолий Кулаков" Вот если мы возьмем дефолтное приложение, какое-нибудь ISP-нетное, то его средний стартап тайм, время старта короче, будет 169 миллисекунд.
2365.20 2375.96 "Анатолий Кулаков" Если мы откомпилируем его с помощью Netioid Preview 4, который то естественно оптимизируется на каждом превью, то его время старта будет 32 миллисекунды.
2375.96 2378.68 "Анатолий Кулаков" То есть 32 миллисекунды против 169.
2378.68 2381.00 "Анатолий Кулаков" Вот такое чудо дает нам Netioid.
2381.00 2385.20 "Анатолий Кулаков" И плюс Netioid тащит в себе кучу всяких триммингов, которые уменьшают размеры.
2385.20 2394.32 "Анатолий Кулаков" Поэтому обычное приложение под стандартный фреймворк будет занимать у вас 88 мегабайт, а вместе с Netioid всего лишь навсего 9,3 мегабайта.
2394.32 2395.84 "Анатолий Кулаков" То есть 9 мегабайт.
2395.84 2403.68 "Анатолий Кулаков" Прямо разительное такое расстояние между этими двумя штуками и размером файлика и временем старта.
2403.68 2404.92 "Анатолий Кулаков" Очень интересная тема.
2404.92 2407.20 "Анатолий Кулаков" Посмотрим, что они смогут добиться до релиза.
2407.20 2417.92 "Анатолий Кулаков" Как мы помним, как раз в последних превью, вот как раз перед самым релизом, там идут массовые оптимизации именно по перформансу, по месту, по сайзу, по всему.
2417.92 2425.32 "Анатолий Кулаков" Может быть там эти цифры еще лучше увеличатся, но сейчас то, что происходит, уже красота, уже прям хорошо.
2425.32 2427.96 "Анатолий Кулаков" Также обновился Worker Service Template.
2427.96 2432.56 "Анатолий Кулаков" Это то штука, которую вы создаете с помощью .NET New Worker.
2432.56 2441.76 "Анатолий Кулаков" Это специальный бэкграунд Worker, который выполняет там какие-то долгие операции, не требующие пользовательского интерактивного взаимодействия или просто долгие.
2441.76 2447.16 "Анатолий Кулаков" Добавилось, то есть изменился темплейт в сторону того, что ему добавился тот же самый флажок - - iOD.
2447.16 2462.84 "Анатолий Кулаков" Сейчас этот iOD добавляется практически во все темплейты для того, чтобы можно было очень бешевно, нативно, красиво создавать вот такие оптимизированные маленькие быстрые приложенницы, которые не требуют основного фреймворка и имеют кучу разных других интересных преимуществ, о которых мы уже много раз рассказывали.
2462.84 2467.92 "Анатолий Кулаков" Еще штуку интересную завезли в Web Application.
2467.92 2474.96 "Анатолий Кулаков" Обычно мы создаем наш Web Application с помощью метода, которая называется Create Builder и начинаем там навешать ему всякую конфигурацию и прочее.
2474.96 2478.24 "Анатолий Кулаков" Завезли новую вещь, которая называется Create Slim Builder.
2478.24 2483.48 "Анатолий Кулаков" Правда ее завезли еще в третьем превью восьмого .NET, но все же стоит еще раз упомянуть.
2483.48 2484.48 "Анатолий Кулаков" Slim Builder.
2484.48 2499.12 "Анатолий Кулаков" Когда вы создаете Slim Builder, ваше .NET приложение старается сделать ваш Application как можно меньше, то есть минимизировать размер выходных артефактов, которые у него будут.
2499.12 2503.76 "Анатолий Кулаков" То есть он перестает использовать какие-то вещи, которые избыточные и может быть вам не нужны.
2503.76 2509.44 "Анатолий Кулаков" Что конкретно туда войдет, мы посмотрим уже на релизе, но примерно вот такая концепция есть.
2509.44 2512.92 "Анатолий Кулаков" Вы можете создать обычный Create Builder и Slim Builder.
2512.92 2517.88 "Анатолий Кулаков" И в частности в превью 4 туда добавили в этот Slim Builder поддержку конфигурации.
2517.88 2522.88 "Анатолий Кулаков" Потому что раньше настолько его хорошо урезали, что нельзя было загрузить конфигурацию.
2522.88 2526.84 "Анатолий Кулаков" Конфигурацию JSON, User Secret, влогов и прочих вот таких вещей.
2526.84 2536.00 "Анатолий Кулаков" Сейчас в четвертом ее туда добавили, но все же стараются ее держать в таких пределах, чтобы размер выходных файликов не уходил за 10 Мб.
2536.00 2538.52 "Анатолий Кулаков" На тех размерах олеток, про которые мы с вами говорили.
2538.52 2539.52 "Анатолий Кулаков" Пока получается.
2539.52 2545.72 "Анатолий Кулаков" Для аудентификации и авторизации привезли кроласную штуку.
2545.72 2547.96 "Анатолий Кулаков" Это новые Endpoints.
2547.96 2557.92 "Анатолий Кулаков" Эти новые Endpoints генерятся, если мы отконфигурируем наше приложение на самом старте с помощью специального метода, который называется Map Identity API.
2557.92 2561.84 "Анатолий Кулаков" Эта конфигурация добавляет нам два маленьких Endpoints.
2561.84 2563.60 "Анатолий Кулаков" Register и Login.
2563.60 2577.52 "Анатолий Кулаков" И нужны они для того, чтобы можно было организовать работу с регистрацией и логином пользователя через SPA приложения, которых любят JavaScript Framework, Single Page Application и все такое.
2577.52 2579.84 "Анатолий Кулаков" Ну или с помощью того же Blazor.
2579.84 2587.84 "Анатолий Кулаков" Потому что раньше по умолчанию весь UI для регистрации и логина пользователей генерился с помощью Razor Pages.
2587.84 2596.84 "Анатолий Кулаков" Если вы хотели все-таки использовать не Razor Pages, как у вас в компании принято, а какие-нибудь React, Angular или Vue, то вам нужно было немножко постараться.
2596.84 2598.76 "Анатолий Кулаков" То есть нужно было это все переделывать.
2598.76 2604.60 "Анатолий Кулаков" Теперь эти Endpoints это стандартная функциональность ASP.NET.
2604.60 2607.64 "Анатолий Кулаков" Вы их можете добавить с помощью одной команды и все.
2607.64 2616.24 "Анатолий Кулаков" И теперь можно ходить с помощью SPA приложений, можно вызывать с помощью API удобно эти логины и эти регистрации.
2616.24 2626.24 "Анатолий Кулаков" И Razor Pages по-прежнему останется, но скорее всего пользоваться им будут намного-намного реже, потому что появилась более современная, более интересная возможность.
2626.24 2637.96 "Анатолий Кулаков" Также команда обещает, что сюда же появится скоро и API для двухфакторной аутентификации, также API Endpoints, Routes для проверки e-mail.
2637.96 2640.32 "Анатолий Кулаков" Все это будет в будущих версиях.
2640.32 2648.16 "Анатолий Кулаков" То есть эту тему будут постепенно наращивать, расширять для того, чтобы она приобрела полноценную функциональность авторизации без всяких Razor.
2648.16 2652.20 "Анатолий Кулаков" В общем это тоже хорошая штука, давно ее ждали, в принципе давно просили.
2652.20 2662.16 "Анатолий Кулаков" Еще одно улучшение в плане Security, в плане безопасности это работа с Authorization Policies.
2662.16 2671.44 "Анатолий Кулаков" А раньше для того, чтобы вам создать свой Custom Authorization Policy необходимо было написать много-много классиков, штуки 4 минимум.
2671.44 2679.96 "Анатолий Кулаков" Authorization Attributes, чтобы его навесить, Policy Provider, Authorization Requirement, Authorization Handler, все это вместе соединить, зарегистрировать, провязать.
2679.96 2690.84 "Анатолий Кулаков" В общем, чтобы добавить казалось бы такую маленькую функциональность, как какую-нибудь лишнюю проверку пользователя на какие-нибудь роли, или возраст, или время суток.
2690.84 2692.96 "Анатолий Кулаков" В общем приходилось городить целый огород.
2692.96 2700.16 "Анатолий Кулаков" А теперь это все улучшилось с помощью специального нового интерфейса Authorization Requirement Data.
2700.16 2709.96 "Анатолий Кулаков" Вы можете сделать всю необходимую инфраструктуру внутри одного классика, который будет пронаследован от этого интерфейса, и там буквально классик из нескольких строчек кода.
2709.96 2712.48 "Анатолий Кулаков" То есть кода тоже стало намного меньше.
2712.48 2722.32 "Анатолий Кулаков" Такая удобная поддержка тоже, наверное, будет полезна многим, кто сталкивался с данной проблемой, куш, пишет много Authorization Policies.
2722.32 2728.56 "Анатолий Кулаков" И еще одна такая фундаментальная штука, которая появилась это поддержка новых метрик.
2728.56 2741.52 "Анатолий Кулаков" Наверное, вы многие знаете, что у нас там в Дотнете есть всякие Performance Counter, даже сейчас не Performance Counter называется, просто там Counter какие-то, которые умеют мерить различные показатели Дотнета.
2741.52 2756.48 "Анатолий Кулаков" И вот к ним то ли для конкуренции, то ли для расширения, то ли для адаптации пришла новая система метрик, которая лежит у нас и живет в Namespace System Diagnostic Metrics.
2756.48 2766.40 "Анатолий Кулаков" Эта система очень интересная, красивая и тоже очень сильно запоздалая, потому что если вы когда-нибудь работали с AppMetrics, то вот это оно.
2766.40 2769.84 "Анатолий Кулаков" То есть наконец-то AppMetrics принесли нам в нативный BCL.
2769.84 2772.60 "Анатолий Кулаков" Немножко поподробнее давайте обсудим.
2772.60 2785.00 "Анатолий Кулаков" Эта система метрик как раз таки служит для того, чтобы предоставить современный нормальный API для сбора метрик и отчета, то есть для репортинга куда-либо.
2785.00 2796.68 "Анатолий Кулаков" И эти метрики включают в себя не просто Counter, может быть какой-нибудь Int или Long, которые уменьшаются, увеличиваются, а нормальные… Я даже не знаю, как это по-русски называется.
2796.68 2799.00 "Анатолий Кулаков" Игорь, это кто такие?
2799.00 2800.00 "Анатолий Кулаков" Гудезы.
2800.00 2801.68 "Анатолий Кулаков" Это как по-русски вообще?
2801.68 2806.96 "Игорь Лабутин" Ну вообще… Я тебя тоже задачил, да?
2806.96 2809.80 "Игорь Лабутин" Да, я знаю, как это выглядит штука.
2809.80 2812.52 "Игорь Лабутин" Обычно рисуется как приборчик, типа это со стрелочкой.
2812.52 2813.52 "Игорь Лабутин" Да-да-да.
2813.52 2815.52 "Игорь Лабутин" Ну в общем, если вы видели… Индикаторы, давай назовем это индикаторы.
2815.52 2816.52 "Анатолий Кулаков" Индикаторы, хорошее название, давай.
2816.52 2823.36 "Анатолий Кулаков" В общем, если вы видели какие-нибудь спидометры в машине, которые показывают вам, что немножко меняется скорость туда-сюда.
2823.36 2830.80 "Анатолий Кулаков" Если вы видели загрузку процессоров, которые постоянно меняются то вверх, то вниз, или загрузку памяти, то все это вот эти индикаторы.
2830.80 2835.12 "Анатолий Кулаков" И для того, чтобы их отобразить, недостаточно одного Long.
2835.12 2840.72 "Анатолий Кулаков" Ну то есть вы можете воспользоваться одним Long, но вы немножко там теряете и агрегацию, и историчность, и так далее.
2840.72 2863.52 "Анатолий Кулаков" Есть обычный Counter, который действительно вот счетчик туда-сюда, который бегает, и есть гистограммы, например, которые вот прям совсем… Хорошая тема, в общем, помогает вам разбить историчность на различные секции и прослеживать там попадание, например, одних запросов в какой-то определенный тайм-период, или других ответов в определенный там размер боди.
2863.52 2869.68 "Анатолий Кулаков" В общем, я думаю, что темой метрики, как ей не бывает, мы прям займемся отдельно, когда они зарелизятся.
2869.68 2876.68 "Анатолий Кулаков" В общем, какие-то сложные конструкции предоставляются вам, в которых сохраняется намного больше информации, чем обычное какое-нибудь интовое число.
2876.68 2889.28 "Анатолий Кулаков" И вот этого намного больше информации, его, соответственно, можно намного лучше анализировать и визуализировать, что позволяет строить гораздо более красивые, интересные графики и отчеты о том, как живет ваше приложение.
2889.28 2898.84 "Анатолий Кулаков" А более того, там еще есть Multi-Dimensional Values, то есть вы можете большие размерности выбирать для тех значений, которые вы сохраняете с помощью ваших метрик.
2898.84 2906.16 "Анатолий Кулаков" Такие системы, как я уже сказал, они всегда на рынке были, но предоставлялись они третьесторонними приложениями, третьесторонними библиотеками.
2906.16 2908.32 "Анатолий Кулаков" В дотнете нативно такой поддержки не было.
2908.32 2923.56 "Анатолий Кулаков" Я не знаю, насколько нужно было внедрять это во фреймворк, но так как сейчас AppMetrix больше мертв, чем жив, и куча его клонов оставляет желать лучшего, качество кода довольно ужасное у них, то я в принципе надеюсь, что здесь просто будет хорошо это все дело написано.
2923.56 2930.48 "Анатолий Кулаков" Оптимизированная подскорость, как это должно быть в настоящих нормальных метриках, и подрасширяемость, как любит делать Microsoft.
2930.48 2940.88 "Анатолий Кулаков" Вот, может быть, лучше, чтобы они это выпустили в виде отдельного пакета, может он как-нибудь будет в виде отдельного пакета, пока точно неизвестно в каком виде, но штука довольно прекрасная.
2940.88 2946.00 "Анатолий Кулаков" И прекрасна она тем, что на выхлопе она сразу нативно будет поддерживать OpenTelemetry.
2946.00 2951.64 "Анатолий Кулаков" То есть все вот эти чуточки, которые вы собирали, их сразу можно будет репортить в OpenTelemetry Provider.
2951.64 2969.44 "Анатолий Кулаков" А это значит, что ваше приложение будет читаться хорошо практически всеми Cloud-провайдерами, которые снимают диагностики, потому что OpenTelemetry - это индустриальный стандарт как раз про метрики, про логи и про Distributed Tracing.
2969.44 2972.96 "Анатолий Кулаков" И вот здесь они как раз метриками пытаются выстрелить вот эту нишу.
2972.96 2985.12 "Анатолий Кулаков" Теперь абсолютно все провайдеры, которые поддерживают OpenTelemetry, а это абсолютно все провайдеры, которые снимают какие-то метрики, теперь смогут считать наши данные из наших ISP-нетных приложений.
2985.12 3004.20 "Анатолий Кулаков" И в частности, поддерживаются уже из коробки такие счетчики, как время длительности запроса, частота запросов, частота ошибок, частота исключений, популярность эндпоинтов, то есть каким эндпоинтом ходит чаще всего количество коннекций, которые держит ваше ISP-нет приложение.
3004.20 3005.20 "Анатолий Кулаков" В общем, и много-много других.
3005.20 3012.52 "Анатолий Кулаков" Там прилично, как каунтеров, они не все, к сожалению, потому что это только первое превью, грубо говоря, этой технологии.
3012.52 3018.92 "Анатолий Кулаков" Но там уже много, и естественно, команда говорит, что в будущем их будет еще больше и будут прям все, которые вам нужны.
3018.92 3030.00 "Анатолий Кулаков" И в качестве прикольного примера, они уже сделали пример, который позволяет репортить эти данные в Prometheus и из Prometheus уже читать графа на дешборде.
3030.00 3044.96 "Анатолий Кулаков" То есть они создали стандартный граф на дешборде, который вы можете подключить к своему ISP-нет приложению, и вот базовые какие-то счетчики типа реквестов, эксепшенов, эндпоинтов он вам уже покажет в красивом, хорошем, понятном, любимом, всеми привычном графа на окошке.
3044.96 3047.28 "Анатолий Кулаков" Вот это тоже прекрасно, тоже интересно.
3047.28 3054.28 "Анатолий Кулаков" В общем, кажется, что хорошая фича, нормальную внедрили, есть будет чем похвастаться на релизе, я чувствую.
3054.28 3062.00 "Игорь Лабутин" Ну прекрасно, это на самом деле действительно очень хорошо, метрики и прочее, ну и вообще ISP в данном случае новости вроде как неплохие.
3062.00 3066.20 "Игорь Лабутин" Понятно было, чем они занимались все это время, это мы еще про Blazer не поговорили детально.
3066.20 3069.72 "Игорь Лабутин" К нему мы вернемся, но мы вернемся к нему чуть-чуть позднее.
3069.72 3077.16 "Игорь Лабутин" А мы сначала пройдемся по другой вещи, которую тоже анонсировали, штука под названием C# DevKit.
3077.16 3092.56 "Игорь Лабутин" Сначала кажется, что это, ну когда я увидел такое название, было не очень понятно, что это такое, потому что DevKit это значит набор чего-то, но как выяснилось, это набор расширений для Visual Studio Code для того, чтобы было более удобно программировать на C#.
3092.56 3100.60 "Игорь Лабутин" Сейчас у нас есть собственно сам базовый C# экстенджен, который позволяет вам базово работать с C#.
3100.60 3105.92 "Игорь Лабутин" Он совершенно независим, в смысле что вот он работает, как работал, так и работает.
3105.92 3114.00 "Игорь Лабутин" Теперь появился еще один экстенджен, который называется C# DevKit, и про него говорят, что он a build from foundations of Visual Studio.
3114.00 3132.80 "Игорь Лабутин" Не знаю, что там они переиспользуют код из студии или просто скорее, это вряд ли, я думаю, что они просто какие-то логические, хотя можно сказать логические кусочки переиспользуют, потому что он на самом деле выдает вам три, так сказать, больших области, которых вам возможно не хватало в Visual Studio Code, если вы работаете в ней с C#.
3132.80 3144.52 "Игорь Лабутин" А именно, он теперь позволяет использовать Solution Explorer, то есть он добавляет новую вьюшку в Visual Studio Code под названием Solution Explorer, того, как мы его знаем из Visual Studio.
3144.52 3146.20 "Игорь Лабутин" Ну и он реально похож прям, да.
3146.20 3164.00 "Игорь Лабутин" Добавляет поддержку темплейтов, то есть если вы там пользуетесь темплейтами Visual Studio, ну там add new чего-нибудь, то вот оно там есть теперь, и он добавляет test discoverability, то есть у вас Visual Studio Code будет сама находить все ваши unit-тесты в ваших solutions и может их запускать, отлаживать и так далее.
3164.00 3167.04 "Игорь Лабутин" То есть это, соответственно, отдельный экстендер, который будет работать.
3167.04 3171.96 "Игорь Лабутин" И есть еще третий экстендер, который называется IntelliCode for C# DevKit Extension.
3171.96 3190.64 "Игорь Лабутин" Он является опциональным для этой всей конструкции, но если его поставить, то у вас появится такой же IntelliCode IntelliSense, как и в Visual Studio, там AI-powered, Copilot, вот это, в общем, поставьте все нужные хайповые словечки, которые нужны для современного IntelliCode IntelliSense.
3190.64 3211.04 "Игорь Лабутин" Поддерживается сейчас в этом комплекте экстенджеров, ну традиционный набор для дотнета, который обычно поддерживается всегда на первых этапах, это веб-приложения, консольные приложения, библиотеки, то есть те, которые максимально не требовательны ко всему и максимально кроссплатформенные, то есть никакого UI, пока ничего такого, ну и тестовые проекты, понятное дело, тоже.
3211.04 3223.12 "Игорь Лабутин" Если вы поставили C# DevKit Extension на вашу Visual Studio Code, то она преапгрейдит ваш существующий C# экстенджер до нужной версии, потому что ей нужна нужная пререлизная версия C# экстенджера.
3223.12 3242.56 "Игорь Лабутин" При этом эта вся радость не то чтобы совсем прям бесплатно-бесплатно, ну точнее как, она настолько же бесплатна, как бесплатная основная Visual Studio, то есть у Visual Studio, я напомню, есть Community Edition, которая бесплатна для, так сказать, личного использования, либо бесплатный, если у вас там не более чем сколько-то человек в компании, по-моему, 5, если я правильно помню.
3242.56 3246.64 "Игорь Лабутин" Если больше, то нужно покупать уже тогда Pro или Enterprise подписку.
3246.64 3254.84 "Игорь Лабутин" Вот этот экстенджер работает по той же самой модели, он просто тупо требует ваш майкрософтский аккаунт и проверяет, какая там у вас подписка есть, нет и так далее.
3254.84 3263.40 "Анатолий Кулаков" Ну смотри, это выглядит так, как будто они пилили Visual Studio for Mac много-много лет и наконец сплюнули и сказали, да, ну у вас лучше, как бы на Visual Studio
3263.40 3270.08 "Игорь Лабутин" Code. Возможно-возможно, я не знаю, что есть еще в Visual Studio for Mac, чего нет в этом экстенджере, например, я не пробовал, не пользовался.
3270.08 3272.20 "Игорь Лабутин" Красивые маковские окошки, анимация.
3272.20 3276.80 "Игорь Лабутин" А, ёлки-палки, а Visual Studio, это какой-то там электрон, который непонятно, как будет работать.
3276.80 3284.52 "Анатолий Кулаков" Не, ну к чести Visual Studio Code, она совсем не похожа на электрон, обычный электрон - это большой, тормознутый, страшный отстой, а Visual Studio Code прям летает.
3284.52 3289.92 "Игорь Лабутин" Ну она большая, в смысле, что она занимает-то много, но летает, да, действительно, это правда.
3289.92 3297.80 "Игорь Лабутин" Поэтому посмотрим, какая судьба будет ожидать этой штуки, в принципе, для тех случаев, когда действительно не получится использовать нормальную Visual Studio, может
3297.80 3308.12 "Анатолий Кулаков" быть, и еще. Ну а давай посмотрим, для кого эта вещь, потому что она не бесплатная, да, то есть там все равно к ней лицензия Visual Studio нужна, ну по крайней мере, если вы в интерпрете сидите, если сами для себя дома, то бесплатно.
3308.12 3309.40 "Анатолий Кулаков" Окей, для кого эта штука?
3309.40 3317.08 "Анатолий Кулаков" Если вы сидите на винде, то, скорее всего, вы себе поставите Visual Studio Community Edition, которая точно так же бесплатна и будете счастливы, правда?
3317.08 3321.88 "Игорь Лабутин" Ну да, смотри, мне кажется, это для двух кейсов, я вижу, это для двух кейсов.
3321.88 3342.28 "Игорь Лабутин" Кейс номер один - это гораздо более проще попробовать C#, не выходя, то есть если ты в основном, например, не знаю, какой-нибудь там Frontend Developer, тебе нужно немножко на C#, то чем ставить полноценную тяжелую большую Visual Studio, у тебя уже есть Visual Studio Code, куда нужно просто доставить экстенджер, то есть чтобы не выходить из знакомых тулов, грубо говоря.
3342.28 3344.48 "Игорь Лабутин" Вот, это один кейс.
3344.48 3364.68 "Игорь Лабутин" А другой кейс - это наоборот, если ты в основном, допустим, работаешь в Visual Studio, но вдруг тебе потребовалось что-то сделать на Mac'е там, либо на Linux'е, ты запускаешь там код, подрубаешь туда эти экстенджеры, но у тебя и так уже есть студия большая, у тебя есть на неё какая-то лицензия, то у тебя эта штука тут же кроссплатформенно позволяет посмотреть на других операционках что-то.
3364.68 3366.96 "Анатолий Кулаков" А ты думаешь, можно лицензию переюзать, да?
3366.96 3376.60 "Игорь Лабутин" Ну, в смысле, ещё раз, да-да-да, нет такого, что, то есть не то чтобы эта штука стоит дополнительных денег, она требует активной подписки Visual Studio, вот так вот.
3376.60 3380.24 "Анатолий Кулаков" И ты по этой подписке можешь себе открыть сколько угодно студии?
3380.24 3381.24 "Анатолий Кулаков" Да.
3381.24 3383.24 "Анатолий Кулаков" Я могу тебе на 100 компьютерах поставить себе студию по одной подписке?
3383.24 3386.92 "Игорь Лабутин" Ну, ты везде залогинишься, если ты её везде используешь лично сам туда.
3386.92 3392.80 "Анатолий Кулаков" Ну, какой-то хороший обход как бы для недобросовестных пользователей.
3392.80 3396.24 "Анатолий Кулаков" Мне кажется, я купил одну корпоративную лицензию, поставил всем сотрудникам и всё.
3396.24 3404.52 "Игорь Лабутин" Ну, возможно, но там возможно есть какие-то тонкости на предмет именно проверки того, что она параллельно активно используется из разных мест.
3404.52 3412.44 "Игорь Лабутин" То есть предполагается, что если ты один девелопер, ну ты там, не знаю, посидел за своей виндой, там что-то поделал, потом открыл там, не знаю, твой Mac или пошёл на виртуалку и там активно что-то поделал.
3412.44 3420.04 "Игорь Лабутин" Ну, я не знаю, как это работает, я никогда не пробовал на самом деле пытаться под одной учёткой работать с многих мест, как-то не нужно было никогда.
3420.04 3434.60 "Игорь Лабутин" Хотя нет, подожди, было у меня такое, да, у меня было, когда я, соответственно, ставил, ну на моём рабочем компе был, и потом на нескольких виртуалках, где мне нужно было что-то отлаживать, я там тоже свою учётку выводил просто в Майкрософтскую, всё работало, Майкрософт не приходил.
3434.60 3455.88 "Анатолий Кулаков" Слушай, в принципе, зная то, как развивается быстро и активно Visual Studio Code, я даже не удивлюсь, что в будущем она вполне может составить конкуренцию вот этому монстру, который сейчас зовётся Visual Studio, потому что её давно уже просят переписать, обновить, убыстрить, вот эти плачи Ярославны продолжаются на всех форумах много-много лет, и вот это вот как вариант переписать Visual Studio, ты как думаешь?
3455.88 3459.36 "Игорь Лабутин" Ну, для C# может быть, то есть там есть… Для C#, да.
3459.36 3472.80 "Игорь Лабутин" Да-да-да, ну понятно, что студия ещё поддерживает, например, плюсы, если мы посмотрим на анонсы новых версий студии, то там регулярно, вот для C++ мы что-то завезли и так далее, я думаю, что там для всего её прям перенести на код будет сложно, но по чуть-чуть, наверное, понемножку.
3472.80 3489.56 "Игорь Лабутин" Опять же, смотри, может быть такое, что, ну, фактически для большинства, не знаю, для, не знаю, 80-90% работы на C# тебе нужно просто хороший редактор с хорошим интеллисенсом, ну, в смысле, билд и отладка, ну и тесты, запуск, в общем.
3489.56 3491.92 "Анатолий Кулаков" Ну тогда бы решапера не существовало бы.
3491.92 3499.36 "Игорь Лабутин" Нет, ну подожди, решапер, дальше вопрос как бы рефактор… Ну фиг знает, я работаю без решапера, на самом деле.
3499.36 3507.56 "Анатолий Кулаков" Ну ты работаешь без решапера только в последних версиях студии, которая стала более-менее сносной по рефакторингам, но до этого это же был просто ужасный тормозной редактор и всё.
3507.56 3509.64 "Анатолий Кулаков" Там ты не работал без решапера, заметь.
3509.64 3513.48 "Игорь Лабутин" Ну там да, но вопрос опять же тогда, значит, в коде тоже нужно будет решапер.
3513.48 3520.80 "Анатолий Кулаков" Ну вот, вот это вот расширение, которое даёт тебе вот и powered интеллисенс, как ты сказал.
3520.80 3523.64 "Игорь Лабутин" Ну интеллисенс это не рефакторинг ещё всё-таки, погоди, это
3523.64 3531.72 "Анатолий Кулаков" поменьше. Ну недалеко, недалеко, там уже всё равно провайдер есть, навигация есть, потом к этому прикрутить как бы ещё символик рефакторинга, я думаю, недалеко.
3531.72 3532.72 "Игорь Лабутин" Ну посмотрим, посмотрим.
3532.72 3541.08 "Игорь Лабутин" Ну я думаю, что всё равно для более сложных сценариев, там какое-нибудь хидропрофилирование, вот это вот такое там и прочее, плюсы, останется большая студия.
3541.08 3545.88 "Анатолий Кулаков" Ну мне кажется, да, плюсы всё-таки сейчас без этого, без каких-то подозрений.
3545.88 3548.44 "Анатолий Кулаков" А вот C# уже, наверное, стоит дорожать.
3548.44 3549.44 "Игорь Лабутин" Редактор WinForms?
3549.44 3554.48 "Анатолий Кулаков" Не-не-не, WinForms тоже останутся на месте, никуда не денутся, я уверен.
3554.48 3555.48 "Анатолий Кулаков" Никто их поддерживать не будет.
3555.48 3574.32 "Анатолий Кулаков" А вообще тебя не дискриминирует, не удивляет тот факт, что как бы на языке, который изначально разрабатывался для того, чтобы кнопочки раскрашивать, вот он уже победил студию, которая пусть чуть-чуть написана на C#, и вот мы, великие C#-писты должны сидеть под тем подельем, которые к нам доносят какие-то фронтенщики.
3574.32 3576.36 "Игорь Лабутин" Мне пофигу, на чём оно написано.
3576.36 3577.76 "Анатолий Кулаков" Какой-то беспринципный, а.
3577.76 3579.80 "Игорь Лабутин" Хоть на прологе пишите, мне не важно.
3579.80 3583.80 "Игорь Лабутин" Ну работает, как бы не тормозит, памяти есть, ну относительно немного и нормально.
3583.80 3590.60 "Игорь Лабутин" На чём оно там внутри написано, тем более пока мне не надо это отлаживать или писать к этому плагины, мне в общем-то более-менее всё равно.
3590.60 3603.40 "Анатолий Кулаков" Вот, я тебе сейчас расскажу про тему, про которую должно было быть всё написано, но к сожалению, товарищ Блейзер запоздал на пару десятилетий, но вот если бы он был, то я думаю, что такого безобразия у нас бы в мире не существовало.
3603.40 3611.56 "Анатолий Кулаков" Но Блейзер немножко запоздал, но зато семимильными шагами двигается вперёд-вперёд и вводит новые-новые фичи.
3611.56 3616.80 "Анатолий Кулаков" И я вам хочу рассказать про ещё одну новую фичу Блейзера, которая нас ждёт в восьмом дотнете.
3616.80 3631.92 "Анатолий Кулаков" А давайте начнём сначала, вдруг опять же кто-то был в танке и пропустил все эти десятилетия развития Блейзера, и немножко напомню, что на самом деле Блейзер создавался как технология, которая может работать в нескольких окружениях, в различных окружениях абсолютно.
3631.92 3638.76 "Анатолий Кулаков" И с самого начала у нас появилось два варианта Блейзера, между которыми часто люди путались, поэтому разделим их чётко.
3638.76 3641.84 "Анатолий Кулаков" Это Blazer Server и Blazer WASM.
3641.84 3658.28 "Анатолий Кулаков" Blazer Server это такая штука, которая помогает вам держать ваш .NET код, всю часть, которую управляет даже UI, но она держится на серверной стороне и общается с помощью Socket Connection с браузером.
3658.28 3677.32 "Анатолий Кулаков" В то время, когда пользователь взаимодействует в браузере с UI компонентами, все эти UI компоненты отсылают оповещение, модификации на сервер, на котором крутится настоящее нормальное .NET приложение и сообщает, что же всё-таки делал с ним пользователь, за какие места он его трогал, за какие кнопочки он нажимал.
3677.32 3690.24 "Анатолий Кулаков" И если вдруг сервер определял, что пользователь сделал что-то, что изменило UI, то .NET сервер отсылал маленький див по тому же сокету обратно в браузер, на клиент.
3690.24 3704.96 "Анатолий Кулаков" И этот див с помощью мегамагических технологий и Shadow DOM и прочих страшных вещей накладывался на Domain Object Model самого браузера и изменял визуально ту картинку, которую перед глазами видит пользователь.
3704.96 3720.60 "Анатолий Кулаков" И поэтому пользователь очень быстро ловил этот фидбэк, потому что сейчас на самом деле это отослать див, вернуть его обратно и заплавить его в окошко, это всё делалось без тормозов, с огромной скоростью, если у вас, естественно, отличная сеть.
3720.60 3723.80 "Анатолий Кулаков" И поэтому эта технология смогла заработать в нашем современном мире.
3723.80 3726.60 "Анатолий Кулаков" Это делал всё Blazor сервер.
3726.60 3730.60 "Анатолий Кулаков" Его преимущество заключалось в том, что у него очень быстрое время старта.
3730.60 3741.00 "Анатолий Кулаков" Ну, по сути, он вам отдает страничку, уже готовую, и пользователь, когда открывал браузер, он уже сразу видел какой-то контент, с которым мог начать взаимодействовать.
3741.00 3749.48 "Анатолий Кулаков" Ему не приходилось ждать какой-то огромной инициализации всех вот этих новомодных фреймворков, которые там поднимаются по минуте для того, чтобы вам одну кнопочку отрисовать.
3749.48 3752.28 "Анатолий Кулаков" Нет, Blazor сервер в этом плане был идеальным.
3752.28 3754.84 "Анатолий Кулаков" Но у него был один жесткий минус.
3754.84 3760.56 "Анатолий Кулаков" Это вам нужна стабильная и очень быстрая сеть.
3760.56 3767.88 "Анатолий Кулаков" Потому что всё взаимодействие, каждое нажатие кнопочки, каждое перемещение какой-то картиночки, оно происходит с сервером.
3767.88 3771.44 "Анатолий Кулаков" Поэтому канал до сервера вам нужен стабильный и быстрый.
3771.44 3777.32 "Анатолий Кулаков" Тогда для пользователя это не будет тормозить, и весь его опыт взаимодействия с вашим приложением будет шикарным.
3777.32 3786.44 "Анатолий Кулаков" Это не всегда так, потому что не все интернеты быстры и стабильны, связь иногда рвется, особенно в других странах каких-нибудь страшных.
3786.44 3791.56 "Анатолий Кулаков" И частично решить эту проблему был призван Blazor WASM.
3791.56 3797.92 "Анатолий Кулаков" Это второй режим запуска Blazor компонентов, Blazor приложения, который пошел совсем по другому пути.
3797.92 3803.08 "Анатолий Кулаков" Он скомпилировал всё дотнет-приложение в WebASM-ли формат.
3803.08 3808.52 "Анатолий Кулаков" WebASM-ли формат - это формат, который поддерживается сейчас абсолютно всеми браузерами, включая мобильные.
3808.52 3811.60 "Анатолий Кулаков" Такой кросс-языковой, кросс-признанный формат.
3811.60 3818.76 "Анатолий Кулаков" И эти компоненты, эти DLL, эти сборки, они загружались непосредственно в веб-браузер.
3818.76 3823.16 "Анатолий Кулаков" Они загружались в веб-браузер, и соответственно для их работы им вообще не нужен был сервер.
3823.16 3830.96 "Анатолий Кулаков" Опять же, если они хотели что-то где-то удаленно хранить или с кем-то удаленно взаимодействовать, они могли работать непосредственно на устройстве клиента.
3830.96 3835.92 "Анатолий Кулаков" То есть октлик у них был максимально быстрый, даже если у клиента вообще нет сети.
3835.92 3839.76 "Анатолий Кулаков" Вы могли... и там работал полноценный .NET код.
3839.76 3846.92 "Анатолий Кулаков" То есть вы могли запускать сложные алгоритмы, писать страшную иерархию классы, ивенты, фабрики.
3846.92 3847.92 "Анатолий Кулаков" В общем, все как мы любим.
3847.92 3849.24 "Анатолий Кулаков" Нагружать это по максимуму.
3849.24 3851.96 "Анатолий Кулаков" И все это работало в обычном стандартном браузере.
3851.96 3861.48 "Анатолий Кулаков" Здесь мы избавляемся от того минуса, что нам нужна стабильная сеть для всего времени работы приложения.
3861.48 3864.68 "Анатолий Кулаков" Нам нужна быстрая стабильная сеть для того, чтобы загрузить нам приложение.
3864.68 3865.68 "Анатолий Кулаков" Да, безусловно.
3865.68 3869.16 "Анатолий Кулаков" Но потом она нам абсолютно не нужна, и можно уходить как вообще в офлайн мод.
3869.16 3872.68 "Анатолий Кулаков" И взаимодействие с пользователем ускорялось еще быстрее.
3872.68 3875.68 "Анатолий Кулаков" То есть теперь нам даже не нужно было отсылать вот эти запросики, которые я говорил.
3875.68 3881.00 "Анатолий Кулаков" Они безусловно быстрые, и скорее всего взглядом вы не сможете определить, какой режим у вас выставлен.
3881.00 3883.12 "Анатолий Кулаков" На сервере этот запрос обрабатывается или на клиенте.
3883.12 3888.68 "Анатолий Кулаков" Но все же, клиентское приложение могло еще быстрее реагировать на пользовательские нажатия.
3888.68 3893.84 "Анатолий Кулаков" Но у этого приложения, как вы наверное догадались, была большая проблема.
3893.84 3895.36 "Анатолий Кулаков" Есть большая проблема.
3895.36 3897.72 "Анатолий Кулаков" Это полноценный дотнет-код.
3897.72 3914.20 "Анатолий Кулаков" Пусть и в виде асма, но для того, чтобы вся эта штука заработала, вам нужно будет скачать к себе на клиента по сути весь фреймворк с гарблеж коллектором, с эмулятором гарблеж коллектора в асме, и с дополнительным с бцл и так далее.
3914.20 3924.32 "Анатолий Кулаков" Безусловно, весь этот код там триммится, 10 раз жмется, пережимается, удаляется все ненужное, но по-прежнему вам нужно скачать большой бинарный пакет для того, чтобы ваше приложение заработало.
3924.32 3942.00 "Анатолий Кулаков" И при этом, когда первый раз пользователь входит на вашу страничку, он вынужден ожидать то время, когда приложение хотя бы немножко загрузится для того, чтобы начать взаимодействие с UI, для того, чтобы ему хоть какой-то UI показался, на который можно понажимать или на который можно посмотреть.
3942.00 3948.40 "Анатолий Кулаков" Когда он будет в следующий раз заходить, браузер это все дело закеширует, естественно вы вот этой заминки не заметите.
3948.40 3950.44 "Анатолий Кулаков" Но первый раз это действительно проблема.
3950.44 3960.56 "Анатолий Кулаков" С этой проблемой в основном борются тем, что постоянно уменьшают вот этот необходимый workload, который необходимо загрузить на клиент, чтобы оно начало работать.
3960.56 3963.04 "Анатолий Кулаков" Теперь вернемся немножко на машине времени назад.
3963.04 3986.88 "Анатолий Кулаков" Вот до тех пор, когда придумали single-page-applications, когда это слово было не ругательным, а модным, когда еще не существовало ангуляров, блейзеров, blazer-vasmov конкретно, когда не было реактов и вуев, тогда в мире существовали другие приложения, которые в отличие от single-page-applications назывались multi-page-applications.
3986.88 4005.72 "Анатолий Кулаков" То есть у них было много страничек, браузер тупо заходил на эту страничку, страничка отдавала конкретный понятный код в виде простого обычного чистого HTML, который рендерился мгновенно, потому что там ничего не надо было ни загружать, ни раскрашивать, ни подвигать, ни выравнивать ничего.
4005.72 4011.72 "Анатолий Кулаков" То есть HTML браузерами, тем более современными, рендерится просто с безумной скоростью.
4011.72 4020.00 "Анатолий Кулаков" И поэтому эти сайты, они в принципе и сейчас много где остались, они рендерятся очень быстро и содержат никаких проблем.
4020.00 4025.08 "Анатолий Кулаков" Но их минус был в том, что они не были достаточно интерактивными.
4025.08 4037.92 "Анатолий Кулаков" То есть вам нужно было на одной страничке нажать кнопочку, чтобы сразу что-то на страничке поменялось, посчиталось, пользователю всплыла подсказочка, не знаю, каким-нибудь градиентиком покрасилась кнопочка и прочие вот эти глупости.
4037.92 4042.40 "Анатолий Кулаков" Вот этого не хватало людям, оказывается, на самом-то деле.
4042.40 4044.40 "Анатолий Кулаков" И вот именно на этой волне и поднялся JavaScript.
4044.40 4056.80 "Анатолий Кулаков" То есть он взял на себя вот эту роль, когда он перенес всю логику с сервера на клиент и пытался на клиенте, добавив больше интерактивности, добавить и клиенту удобства.
4056.80 4065.56 "Анатолий Кулаков" И именно поэтому и начали процветать Single Page Application и понеслась вот эта штука с Front-End Framework.
4065.56 4075.92 "Анатолий Кулаков" В течение последних лет, как ни странно, у многих фреймворков, людей, компаний наблюдается такой небольшой возврат к прошлому.
4075.92 4081.12 "Анатолий Кулаков" Люди хотят простоты и скорости, которые давал им как раз таки Multi-Page Application.
4081.12 4091.60 "Анатолий Кулаков" И при этом они не готовы убирать полностью богатые взаимодействия, богатый пользовательский опыт по взаимодействию со страничками, потому что иначе пользователи просто начнут страдать.
4091.60 4101.20 "Анатолий Кулаков" И поэтому у них родилась идея о том, что мы можем смешать вот эти вот два подхода.
4101.20 4108.08 "Анатолий Кулаков" То есть, например, когда пользователь запрашивает какой-то сайт, мы можем отправить на сервер запрос.
4108.08 4118.44 "Анатолий Кулаков" На сервере запрос уже отрендерит нам готовую HTML-страничку, которую браузер покажет просто мгновенно, сразу, без всяких загрузок, всяких различных фреймворков.
4118.44 4123.92 "Анатолий Кулаков" И эта страничка вполне может быть базовой домашней страничкой Single-Page Application.
4123.92 4137.56 "Анатолий Кулаков" И после этого, когда браузер ее отобразил, Single-Page Application в бэкграунде может проинициализироваться и уже пойти взаимодействовать, дать пользователю вот этот богатый опыт взаимодействия со страничками.
4137.56 4140.60 "Анатолий Кулаков" Но зато первая загрузка будет очень-очень быстрой.
4140.60 4145.36 "Анатолий Кулаков" И мы избавимся от того времени, когда мы ожидаем, пока эта большая страшная штука поднимется.
4145.36 4157.96 "Анатолий Кулаков" И вот на этой идее, которая в простонародье называется просто не затея, а сервер-сайт рендеринг, на этой идее Blazor компоненты и пытаются выехать в DotNet 8.
4157.96 4174.96 "Анатолий Кулаков" То есть теперь Blazor компоненты, те же самые Blazor компоненты, которые вы писали и для сервер-сайта, те же компоненты, которые вы могли писать и для Wasmo, их можно использовать в так называемом гибридном моде, то есть в другом режиме использования.
4174.96 4177.60 "Анатолий Кулаков" Когда они генерятся на сервере.
4177.60 4192.56 "Анатолий Кулаков" Когда от браузера приходит простой запрос, а уходит не какой-то там бинарный файлик, который нужно запустить для того, чтобы получить приложение, а не какой-то там JavaScript библиотека, который опять же нужно загрузить, пронициализировать и запустить, а уходит уже готовый HTML.
4192.56 4199.32 "Анатолий Кулаков" И пользователь страничку видит мгновенно и радость у него приходит в этот момент просто мгновенно.
4199.32 4207.48 "Анатолий Кулаков" Для того, чтобы использовать все ваши вот эти готовые Blazor компоненты, вам достаточно просто в вашем приложении вызвать один-единственный метод, который называется MapLazorComponents.
4207.48 4209.52 "Анатолий Кулаков" Так вот незатейливо и просто.
4209.52 4222.52 "Анатолий Кулаков" И после того, как вы это сделаете, Blazor сможет генерить вам ваши странички прямо на сервере и отдавать на выход уже чистый HTML, который браузер сможет быстро и хорошо показывать.
4222.52 4228.32 "Анатолий Кулаков" Вот такому сервер-сайт рендерингу научился Blazor в .NET 8.
4228.32 4230.08 "Анатолий Кулаков" Но это еще не все.
4230.08 4240.96 "Анатолий Кулаков" Также разрабатывается такая технология, и почти уже там есть некоторые превьюшки, что мы можем комбинировать вот эти три подхода.
4240.96 4248.20 "Анатолий Кулаков" То есть Blazor Server, Blazor WASM и Blazor Server Site Rendering.
4248.20 4252.00 "Анатолий Кулаков" Мы их можем комбинировать вместе в зависимости от того, что нам сейчас нужно.
4252.00 4256.96 "Анатолий Кулаков" И не просто приложению, что сейчас нужно, а что сейчас нужно конкретному компоненту или пользователю.
4256.96 4259.96 "Анатолий Кулаков" То есть это атрибут на уровне компонента.
4259.96 4267.28 "Анатолий Кулаков" Если пользователь первый раз заходит к вам на страничку, то безусловно вы хотите мгновенно ему отдать какой-то результат.
4267.28 4275.80 "Анатолий Кулаков" Здесь в работу вступает компонент домашней странички, который помечен атрибутом Server-Site Rendering.
4275.80 4281.68 "Анатолий Кулаков" То есть это уже предрендеренная страничка, которая мгновенно возвращается пользователю и мгновенно отображается в браузере.
4281.68 4293.36 "Анатолий Кулаков" В этот момент, пока пользователь дивится, как быстро ему пришла страничка, наслаждается вашим приложением, открывается сокет Connection и цепляется к веб-серверу.
4293.36 4297.08 "Анатолий Кулаков" И на той странице запускается Blazor-сервер.
4297.08 4303.36 "Анатолий Кулаков" То есть теперь пользователь уже может менять компоненты, взаимодействовать с каким-то веб-сервисом, если у него вдруг сеть стабильная и быстрая.
4303.36 4316.24 "Анатолий Кулаков" Если сеть нестабильная и быстрая, то в этот момент, когда он загрузил первую страничку, ему на базу клиента загружается Blazor WASM, который загружается пусть и долго, и инициализируется пусть и долго, но уже в бэкграунде.
4316.24 4317.72 "Анатолий Кулаков" Пользователь уже этого не ждет.
4317.72 4324.52 "Анатолий Кулаков" Он уже может взаимодействовать с вашим приложением, что-то читать, что-то смотреть или даже какие-то базовые клики выполнять, которые позволяет сделать HTML.
4324.52 4339.12 "Анатолий Кулаков" В этот момент загружается Blazor WASM, и после этой процедуры у него снова появляется весь тот богатый опыт, весь тот богатый experience, вся эта сложная логика, которую он ожидает увидеть от современного приложения.
4339.12 4363.52 "Анатолий Кулаков" Вот с помощью вот такого гибридного подхода, с помощью модификации различных режимов запуска каждого отдельного компонента, мы можем добиться такого эффекта, что пользователь всегда будет чувствовать себя комфортно с вашим приложением, оно никогда не будет для него тормозить, и оно всегда будет работать быстро, отзывчиво, и он не будет на себе чувствовать всех тех гигабайтов, которые вы прокачиваете в результате нажатия на одну какую-нибудь специальную кнопочку.
4363.52 4368.16 "Игорь Лабутин" Че-то поймался я на мысли, что у нас что ни тема, мы все про фронтенд.
4368.16 4371.04 "Анатолий Кулаков" Не говори, не говори.
4371.04 4377.20 "Анатолий Кулаков" Поэтому я говорю, что наши темы постепенно занимает фронтендовый, мы скоро, наверное, с тобой перечем какой-нибудь TypeScript.net.
4377.20 4382.20 "Анатолий Кулаков" Ну ладно, TypeScript тоже это придумал.
4382.20 4384.64 "Игорь Лабутин" Не так позорно, да?
4384.64 4385.64 "Игорь Лабутин" Не так далеко, да.
4385.64 4397.20 "Игорь Лабутин" Пойдем дальше, давай вернемся все-таки к Visual Studio и прочему, и скажем, что вышла, официально зарелизилась, видимо, как раз под Microsoft Build Visual Studio 2022-17.6.
4397.20 4405.28 "Игорь Лабутин" И там, на самом деле, завезли много всего, мы про это все более-менее рассказывали практически постоянно, потому что все эти фичи были в превьюшках.
4405.28 4407.32 "Игорь Лабутин" Давайте еще раз быстренько пробежимся.
4407.32 4415.56 "Игорь Лабутин" Они разделены на несколько разделов, это Productivity, про .NET, про Game Development, про C++, и там еще немножко.
4415.56 4423.12 "Игорь Лабутин" Про Productivity, это, конечно же, улучшение производительности, улучшили скорость открытия Solution и закрытия Solution.
4423.12 4424.12 "Игорь Лабутин" Помнишь, мы когда-то обсуждали?
4424.12 4425.12 "Игорь Лабутин" Да, да, закрытие, это важно.
4425.12 4430.52 "Игорь Лабутин" Оно оказалось настолько важным, что вошло в финальный, так сказать, статью про финальный релиз.
4430.52 4438.64 "Игорь Лабутин" Улучшилось, ускорилось отображение истории гита и ускорилась остановка профилирования.
4438.64 4445.44 "Игорь Лабутин" То есть вот раньше начинала сисю профилирования, потом говорил stop collection, он очень долго думал, теперь думает быстрее.
4445.44 4447.96 "Игорь Лабутин" Не знаю, что-то не ускорили, но что-то ускорили.
4447.96 4462.56 "Игорь Лабутин" В редакторе появился Sticky Scroll, это когда вы скролите вниз ваш файл с кодом, наверху остаются строчки, которые соответствуют имени класса, имени функции, имени какой-нибудь управляющей конструкции типа while, for, if и так далее.
4462.56 4474.52 "Игорь Лабутин" То есть по мере углубления вложенности все элементы, на которых вложенность меняется, у вас будут наверху, чтобы вы понимали контекст, где вы вообще находитесь.
4474.52 4488.84 "Игорь Лабутин" Улучшили поддержку поиска, который все в одном Ctrl+T, раскрасили спарные скобочки, добавили spellchecker, улучшили работу с отладкой диагностикой, добавили breakpoint группы, мы их относительно недавно обсуждали.
4488.84 4500.64 "Игорь Лабутин" Те самые визуалайзеры, а инумером был и датасет, теперь поддержаны и в удаленной отладке, давным-давно уже не занимался удаленной отладкой, но если кто-то этим занимается, вот полезные фичи и до вас тоже доехали.
4500.64 4517.28 "Игорь Лабутин" Если вы пользуетесь профайлером Visual Studio и профайлите приложения, которые запущены в Windows Subsystem for Linux с использованием .NET Monitor, то профайлер теперь умеет показывать графики прямо оттуда, из этого самого .NET Monitor, из Linux.
4517.28 4522.76 "Игорь Лабутин" И инструментирование, если вы используете профайлер с инструментацией, то там тоже поменьше ресурсов.
4522.76 4530.40 "Игорь Лабутин" В общем, я не знаю, как оно работало все до этого, такое ощущение, что если каждый релиз так улучшает перформанс, то кто же ее так медленно написал в самом начале?
4530.40 4533.24 "Анатолий Кулаков" Да, да, где не набрали столько тормозов, чтобы так его
4533.24 4536.88 "Игорь Лабутин" что-то отнять. Ну зато теперь можно каждый релиз что-то улучшать, очень удобно, мне кажется.
4536.88 4550.08 "Игорь Лабутин" Так, касательно .NET и Cloud Native Apps, эта секция почему-то начинается с фичи под названием Android Manifest Editor, никак я не ожидал увидеть в .NET и Cloud Native Apps, но тем не менее, можно теперь делать.
4550.08 4555.32 "Игорь Лабутин" Поддержан синтекс-хайлайтинг для JavaScript и TypeScript, здравствуй опять, FrontEnd.
4555.32 4557.80 "Игорь Лабутин" Code Lens теперь там поддержаны.
4557.80 4561.36 "Игорь Лабутин" И вот наконец-то такие фичи, которые относятся непосредственно к .NET.
4561.36 4564.12 "Игорь Лабутин" Это Web API Endpoint Explorer.
4564.12 4577.72 "Игорь Лабутин" Эта штука, это отдельное окошечко, которое теперь вам сможет поискать по вашему .NET проекту все endpoints, которые вы так или иначе экспозите, либо через контроллеры, либо через Minimal API, и показать их просто с единым сводным списком.
4577.72 4580.28 "Игорь Лабутин" При этом на каждом endpoint вы можете сделать две вещи.
4580.28 4586.64 "Игорь Лабутин" Вы можете либо сказать, сходите в собственно реализацию этого endpoint быстро, то есть либо в контроллер, либо в соответствующий обработчик.
4586.64 4589.56 "Игорь Лабутин" Либо вы можете сказать Create Request.
4589.56 4599.64 "Игорь Лабутин" Если вы скажете Create Request, ну то есть Generate Request, если я правильно помню, то у вас создастся .http файлик, ты уже говорил про них чуть-чуть раньше и выше сегодня.
4599.64 4602.56 "Игорь Лабутин" Visual Studio действительно теперь поддерживает .http файлы.
4602.56 4611.04 "Игорь Лабутин" Это такой текстовый формат, который позволяет вам записывать реквесты и их исполнять в случае, если ваш IDE это поддерживает.
4611.04 4621.60 "Игорь Лабутин" Первым это, по-моему, начало поддерживать, ну это стало популярно благодаря экстенджеру Visual Studio Code, но теперь и до Visual Studio полноценно тоже добрались.
4621.60 4647.44 "Игорь Лабутин" К сожалению, сейчас поддержка .http достаточно ограничена, то есть там можно только по сути писать простые запросы, там даже нет никакой истории исполнения, там нету возможности задавать суперсложные переменные, там сохранять ответы в какой-нибудь файлик, кастомизировать разные запросы с разными параметрами, то есть там довольно большой список всего того, что нужно еще поддержать, но основные штуки поддержаны.
4647.44 4654.04 "Игорь Лабутин" А, отдельно еще они говорят, что мы хотим что-нибудь придумать с тестированием вокруг этого, ну чтобы можно было тестировать результаты ваших запросов.
4654.04 4658.52 "Игорь Лабутин" Но это как раз-таки придется парсить JSON, вот это все.
4658.52 4667.32 "Игорь Лабутин" В Visual Studio студийное расширение уже это, по-моему, умеет в каком-то виде, в IDE, по-моему, тоже можно было что-то такое делать, ну и в RIDER, соответственно.
4667.32 4670.32 "Анатолий Кулаков" Ну там из ответов, например, вытаскивать authorization token
4670.32 4685.12 "Игорь Лабутин" или вытаскивать какой-то body, там уже можно, да? Ну это даже не про тестирование, то есть это как минимум использовать результат предыдущего запроса для следующего, вот сейчас такого у меня не поддержано, вот, а есть можно еще тестировать, можно проверять, что вернули, ну там соответствует какому-то ожидаемому.
4685.12 4688.68 "Игорь Лабутин" Ну в общем, что-то, я думаю, что нас ждет улучшение в этой области.
4688.68 4691.64 "Игорь Лабутин" А второе улучшение — это scaffolding.
4691.64 4700.12 "Игорь Лабутин" Теперь можно сказать на проекте вы можете сказать add a new scaffolded item, и там выбрать что-нибудь, что можно сгенерить.
4700.12 4716.24 "Игорь Лабутин" А сгенерить можно интересные штуки, например, вы можете выбрать пункт, который называется API with read, write and points using Entity Framework, и вам автоматически сгенерится почти полноценное приложение, то есть сначала этот визарт вас спросит, а какой класс модели мы будем использовать в нашем API?
4716.24 4724.40 "Игорь Лабутин" Он говорит, хорошо, а потом, а какие endpoints мы будем использовать, а какой db-контекст у тебя, а какой у тебя вообще db-провайдер, какая база данных.
4724.40 4749.96 "Игорь Лабутин" Дальше можно еще поставить галочки использовать open API или не использовать, использовать typed result или не использовать, и после этого вам сгенерится minimal API код, который будет иметь набор, соответственно, там get, post, delete endpoints с уже реализованным, прям, телом, в смысле, что он будет работать с вызовом db-контекстов и так далее, то есть вам останется только какие-нибудь данные в базу напихать и все будет работать.
4749.96 4755.72 "Игорь Лабутин" Кстати, правда, забавно написано, что после того, как вы это все сгенерите, неплохо бы проверить в этот момент, что все компилируется и работает.
4755.72 4758.48 "Игорь Лабутин" Видимо, иногда не компилируется и не работает.
4758.48 4764.60 "Игорь Лабутин" Вот, если нужно, там есть темплейты и для контроллеров, то есть можно из контроллера это все генерить.
4764.60 4780.40 "Игорь Лабутин" Короче, возможно, это действительно довольно простой способ быстро набросать какую-нибудь простую API, ну, чтобы не руками писать все эти db-контексты, вот это все, то есть базовые шаблоны все это сгенерят, а дальше уже, понятно, дополнять эти свои бизнес-модели и своими нужными endpoints.
4780.40 4792.20 "Анатолий Кулаков" Я все еще жду какого-нибудь механизма, который позволит все-таки scaffolding использовать не только в самом начале проекта, когда ты какую-то пустую шаблон сделал, а поддерживать в реальном жизни в приложении.
4792.20 4793.56 "Анатолий Кулаков" То есть это же намного важнее.
4793.56 4802.44 "Анатолий Кулаков" У тебя в приложении, допустим, добавляется какая-то сущность, и тебе опять же нужен свой контекст, свои контроллеры, своя UI, свои валидаторы, маппинги и прочее, вот это чушь.
4802.44 4805.76 "Анатолий Кулаков" И вот ручками это копировать, там, не знаю, может полдня занять.
4805.76 4811.72 "Анатолий Кулаков" Почему это не автоматизировать до сих пор, понятно, красиво и хорошо, почему нет таких инструментов, вот это меня очень сильно угнетает.
4811.72 4824.72 "Игорь Лабутин" Слушай, а я так понимаю, что эта штука может быть такой уже частичной поддержкой, потому что в статье прям явно написано, что если вы, например, для, когда вы выбираете класс для endpoints, то есть куда запихать ваши endpoints, можно выбрать существующий класс, они туда добавятся.
4824.72 4828.68 "Игорь Лабутин" То есть сгенерить новый endpoint, существующий продукт, ты сможешь.
4828.68 4832.12 "Игорь Лабутин" Вот там поменять существующий, ну тут уже сложнее.
4832.12 4838.44 "Анатолий Кулаков" Ну поменять, ладно, хотя бы чтобы научился новый генерить, но не там, где он хочет, а, например, там, где у меня положено в моём проекте.
4838.44 4840.00 "Игорь Лабутин" Слушай, тут вроде всё кастомизируемо.
4840.00 4843.56 "Игорь Лабутин" Ну на VIP, по крайней мере, по скриншотикам я сам не пробовал, но...
4843.56 4856.72 "Анатолий Кулаков" Ну, будем надеяться, потому что обычного стартового визарда, который умеет как бы по заданным критериям генерить тебе начальный проект, он существует там со времён 90-х годов и первых Visual Studio, то есть такое давно всегда все умели.
4856.72 4869.80 "Анатолий Кулаков" Тут бы они этого анонса не включили, поэтому я всё-таки надеюсь, что вот эта штука, она какая-то более интерактивная, может быть, более умная, давай так, может тут наконец какой-нибудь капайзер нам поможет для того, чтобы вставлять те места, куда они должны быть вставлены, а не там, где у него хардкодом забито.
4869.80 4880.64 "Игорь Лабутин" Ну вот, посмотрим, что будет, побользуемся, посмотрим на отзывы, наверняка будут какие-нибудь восторженные или не очень восторженные твиты на предмет, типа "Вау, какая крутая штука", или "Ну вот, опять не то".
4880.64 4894.88 "Игорь Лабутин" И такая же штука в Entity Framework Support, то есть раньше, если вы читали всякие разные статьи про то, как там, не знаю, создать новую миграцию, то в статье все говорили там, ну сходите в Command Line, напишите тут NetEF, Migrations, etc.
4894.88 4902.64 "Игорь Лабутин" Я уже сейчас не вспомню весь Command Line, там, назовите как-нибудь её, вам сгенерится файлик, а потом вы туда идите и пишите, что вы хотите апгрейдить.
4902.64 4910.28 "Игорь Лабутин" Ну или, соответственно, если вы заранее обновили модель, то вы знаете, ну она сама поймёт, что вы там обновили в модели и вот, генерит вам миграцию.
4910.28 4919.20 "Игорь Лабутин" Теперь это все есть в Visual Studio, то есть можно теперь сказать, такой же есть Wizard, создать миграцию, дать ей там название, вот это все, она сама все там, нужно изменить, положит в нужное место.
4919.20 4935.20 "Игорь Лабутин" И можно, наверное, кликнуть на проект и сказать Update Database, он попросит выбрать DB Context, который нужно использовать, и тоже все сам проапгрейдит, то есть можно в Command Line и не ходить вообще для EF, ну по крайней мере на вид, для простых действий.
4935.20 4942.04 "Игорь Лабутин" Понятно, что если вы хотите там забандлить какие-нибудь миграции вместе, то это придется уже Command Line использовать.
4942.04 4961.44 "Игорь Лабутин" Это основные фичи, которые хоть как-то касаются .NET или обычного использования, дальше там есть улучшения про GameDev, есть улучшения про C++, кроссплатформенную разработку и всякие там типа штуки, там Remote File Explorer for Unix, что бы это ни было, CMake Debugger, дебаггер для системы сборки, прекрасно.
4961.44 4969.08 "Игорь Лабутин" Вот, и отдельный пункт, Enterprise Management, мы про это уже, по-моему, рассказывали, что там можно ставить Visual Studio с предопределенными темплейтами, вот это все.
4969.08 4978.00 "Игорь Лабутин" Про это, кстати, было на Build, если я правильно помню, что там можно теперь там в Visual Studio запихнуть заранее файлик с нужной конфигурацией, она поставится прямо в нужной конфигурации.
4978.00 4985.24 "Игорь Лабутин" Но это все, видимо, нужно только для Enterprise, потому что обычно разработчики, как правило, все-таки не переставляют Visual Studio регулярно и часто, что бы это было какой-то проблемой.
4985.24 4996.92 "Игорь Лабутин" И, естественно, вместе с релизом основной студии вышел превью следующей студии, 17.7.preview1, там появилось уже несколько вещей.
4996.92 5003.20 "Игорь Лабутин" Во-первых, это Productivity раздел, в котором появились такие штуки, как сравнение файлов в Solution Explorer.
5003.20 5006.28 "Игорь Лабутин" Тебе часто требуется сравнивать файлы в Solution Explorer?
5006.28 5010.00 "Анатолий Кулаков" Ну, как в Solution Explorer не знаю, но мне часто требуется сравнивать файлы.
5010.00 5011.40 "Анатолий Кулаков" Это одно и то же или нет?
5011.40 5015.88 "Игорь Лабутин" Ну, там написано, что ты сначала кликаешь на одном файле в Solution Explorer, говоришь "Select as".
5015.88 5020.28 "Игорь Лабутин" Короче, ну, first файл, а потом кликаешь на другого, говоришь "Вот, сравни с тем".
5020.28 5027.48 "Анатолий Кулаков" Нет, два разных типа файла, ну, раз они в Solution Explorer в одном, то теоретически это два разных файла, чтобы мне их сравнивать никогда не приходилось.
5027.48 5037.88 "Игорь Лабутин" Не, ну, я, пожалуй, могу такое придумать, только если у тебя в каких-нибудь тестах лежат ресурсы, ну, какие-нибудь ресурсные файлики, то вот там узнать разницу, в чем там разница у одного и у другого, может быть, будет полезно.
5037.88 5038.88 "Игорь Лабутин" Такой довольно нишевый кейс.
5038.88 5040.64 "Игорь Лабутин" В общем, теперь можно, превью1.
5040.64 5041.64 "Игорь Лабутин" Спасибо, спасибо.
5041.64 5046.00 "Игорь Лабутин" В GIT появилась штука под названием Multi-Branch Graph.
5046.00 5051.44 "Игорь Лабутин" Наконец-таки вижу, студийный GIT Graph умеет теперь рисовать историю нескольких бранчей одновременно.
5051.44 5052.44 "Игорь Лабутин" По-моему, не мог.
5052.44 5053.44 "Игорь Лабутин" Мне это всегда как-то...
5053.44 5066.04 "Игорь Лабутин" Каждый раз, когда я им пользовался, но я давно не пользуюсь именно GIT в Visual Studio, я почти всегда сторонним клиентам либо коммонлайнам пользуюсь, и там обычно так это и работает, но в Visual Studio, видимо, было не так.
5066.04 5070.48 "Игорь Лабутин" Большая фича, которая нужна, важная и очень прикольная, это Copy and Trim Intentions.
5070.48 5078.72 "Игорь Лабутин" Если вы копируете теперь кусочек кода из Visual Studio, он автоматически отрежет все лидирующие лишние этапы пробелы, которые общие во всех строчках.
5078.72 5085.80 "Игорь Лабутин" Ну, чтобы у вас при вставке не было этих лидирующих пробелов, если вы какой-то супер вложенный кусочек скопировали.
5085.80 5088.08 "Анатолий Кулаков" Ну, вот этим я пользуюсь гораздо чаще, чем сравнивать
5088.08 5090.08 "Игорь Лабутин" два распайла. Да, да, да.
5090.08 5092.80 "Игорь Лабутин" И дальше какие-то еще улучшения в сёрче.
5092.80 5103.68 "Игорь Лабутин" В .NET специфичном, специфичный для .NET улучшение, это поддержка IntelliTest для .NET 6 и новее.
5103.68 5115.20 "Игорь Лабутин" IntelliTest - это, я так понял из описания, это штука, которая смотрит на ваш код класса и умеет понять, какие тесты для этого класса нужно попытаться сгенерить.
5115.20 5117.20 "Игорь Лабутин" И генерит их, соответственно.
5117.20 5125.16 "Игорь Лабутин" Но я жду какую-нибудь более качественную статью на эту тему, либо самому может попробовать, но я превью ставить не собираюсь пока, по крайней мере, превью один слишком рано.
5125.16 5129.68 "Игорь Лабутин" То есть я бы... подождем статью хорошую, где будет написано, что же это такое.
5129.68 5137.32 "Игорь Лабутин" Потому что название IntelliTest мне знакомо, но мне казалось, что это что-то про постоянное выполнение тестов по мере континьюз тестинга, что-то в духе.
5137.32 5143.08 "Игорь Лабутин" Или понимание типа, что вот раз я поменял такой кусочек кода, то надо выполнить вон те тесты.
5143.08 5148.00 "Игорь Лабутин" А тут что-то про Generate, куда-то какие-то новые тесты, символьные исполнения.
5148.00 5149.68 "Игорь Лабутин" В общем, там что-то сложное.
5149.68 5151.60 "Игорь Лабутин" Подождем что-нибудь прикольную статью какую-нибудь.
5151.60 5157.84 "Анатолий Кулаков" Я вот про генерацию тестов и IntelliTest тоже у Microstos слышал довольно давно.
5157.84 5164.64 "Анатолий Кулаков" На простых примерах, я их даже пробовал, оно работало нормально, но как всегда на сложных оно все глубоко падало.
5164.64 5176.84 "Анатолий Кулаков" Я все-таки надеюсь, что после того, как они начали Windows тащить везде Copilot и прочие вот эти глупости, они наконец свои IntelliTest тоже переписали на Copilot и тогда вот это будет вообще бомба.
5176.84 5190.60 "Анатолий Кулаков" Если это будет так, то тесты будут генерироваться с помощью хорошего и хорошего Copilot, тогда они действительно могут читаться, Intel и все такое, и время будет сокращаться для разработки просто значительно.
5190.60 5192.52 "Игорь Лабутин" Ну посмотрим, что там получится.
5192.52 5198.36 "Игорь Лабутин" Я думаю, что если там действительно что-то супер прорывное, они наверняка напишут про это отдельную статью, может просто не успели.
5198.36 5217.88 "Игорь Лабутин" Ну и Blazor Wasm приложение, теперь можно паблишить прямо напрямую в ажурные статические приложения, то есть если вы как-то пользуетесь ажуром, то у вас теперь можно одним паблишем сразу все это задеплоить по сути в продакшн, в статические ажурные приложения, ну и плюсы тоже там какие-то улучшения завезли.
5217.88 5221.08 "Игорь Лабутин" Вот примерно такие новости про Visual Studio.
5221.08 5225.96 "Игорь Лабутин" Обыкновенную про Visual Studio for Mac полная тишина, вообще ничего не.
5225.96 5228.24 "Анатолий Кулаков" О, о, попомни мои слова.
5228.24 5232.36 "Анатолий Кулаков" Уже много не было каких-то новостей, да.
5232.36 5233.36 "Анатолий Кулаков" Отлично, погнали.
5233.36 5244.84 "Анатолий Кулаков" Продолжаем раскрывать все-таки новинки дотнет 8, мы все новости все еще не рассказали, и продолжает встречать нас на этом пути нововведения, которые были сделаны в бэкграунд сервисах.
5244.84 5253.64 "Анатолий Кулаков" Кратенько напомню, что бэкграунд сервисы - это специальный абстрактный класс, который предназначен для того, чтобы запускать какие-нибудь долгие операции на старте вашего приложения.
5253.64 5284.84 "Анатолий Кулаков" Очень просто, вы регистрируете свой класс как бэкграунд сервис, у него должно быть, вы наследуетесь от бэкграунд сервиса, тоже такой абстрактный классик есть, перекрываете метод executeAsync, регистрируете ваш классик с помощью специального метода в контейнере зависимости, и этот классик ваш запускается на старте приложения, и он прекрасен тем, что без всяких запросов, без всяких обращений пользователей, если мы говорим про S/P/N framework, он может выполнять какие-то операции.
5284.84 5297.12 "Анатолий Кулаков" Допустим, вам нужно считать какие-то данные из удаленного сервера, может быть как-то подготовить для дальнейшего использования, может быть предкашировать, может быть составить какой-то сложный годовой отчет, начать его делать с самого утра, пока все пьют чаек.
5297.12 5302.32 "Анатолий Кулаков" В общем, все эти задачи успешно и красиво можно решать в бэкграунд сервисе.
5302.32 5308.76 "Анатолий Кулаков" До дотнет 8 между бэкграунд сервисами была одна особенность.
5308.76 5315.24 "Анатолий Кулаков" Как вы понимаете, их бэкграунд сервиса может быть много, и стартовали они все последовательно.
5315.24 5323.84 "Анатолий Кулаков" То есть каждый бэкграунд сервис стартовал, потом S/P/N framework ждал, пока он закончится, и запускал следующего.
5323.84 5328.16 "Анатолий Кулаков" Стартовал, потом бэкграунд сервиса заканчивался и запускал следующего.
5328.16 5333.44 "Анатолий Кулаков" Естественно, эти сервисы предназначались для того, чтобы работать долго.
5333.44 5343.64 "Анатолий Кулаков" И невозможно было, грубо говоря, на старте приложения дождаться первого сервиса, для того, чтобы запустить второй, потому что первый сервис мог работать долго, часами мог работать.
5343.64 5356.48 "Анатолий Кулаков" Поэтому, чтобы решить эту проблему, была своеобразная рекомендация, что при старте самого сервиса, в старт осинки, вы должны вернуть таску прямо сразу.
5356.48 5358.52 "Анатолий Кулаков" И эту таску никто не ждал.
5358.52 5369.04 "Анатолий Кулаков" Грубо говоря, эта таска отцеплялась от индивидуального контекста и была рекомендация не делать слишком много работы в старт осинки, то есть в самом старте.
5369.04 5377.52 "Анатолий Кулаков" Если вам нужна была какая-то большая работа, то старт должен был быть быстрым, а основную работу вы делаете где-нибудь потом, где-нибудь в другом месте, где-нибудь дальше.
5377.52 5387.24 "Анатолий Кулаков" Это все было довольно нетривиально, там были интересные костыли с точки зрения фреймворка, как обезопасить себя от зависших больших долгих бэкграунд сервисов.
5387.24 5388.80 "Анатолий Кулаков" В общем, все это мелочи.
5388.80 5396.08 "Анатолий Кулаков" И та же самая ситуация была со стопом.
5396.08 5406.60 "Анатолий Кулаков" У стопа была такая же точная штука, то есть стоп ждал, когда закончится предыдущий сервис, для того, чтобы перейти к остановке следующего бэкграунд сервиса, но только в реверсном порядке, в обратном порядке.
5406.60 5412.72 "Анатолий Кулаков" И у стопа еще одна была небольшая штука.
5412.72 5421.84 "Анатолий Кулаков" Если приложение стартовать может, грубо говоря, сколько угодно, потому что все эти сервисы в бэкграунде были, то стопаться приложение обычно должно за какой-то фиксированный тайм-аут.
5421.84 5426.56 "Анатолий Кулаков" Если в этот фиксированный тайм-аут стоп не произошел, то приложение просто-напросто келялось.
5426.56 5432.28 "Анатолий Кулаков" Если произошел, то оно закрывалось graceful shutdown, то есть хорошо, правильно и красиво закрывалось.
5432.28 5439.68 "Анатолий Кулаков" И поэтому, может быть, даже для стопа эта проблема последовательного запуска, она горела, может быть, даже сильнее.
5439.68 5447.64 "Анатолий Кулаков" В Дотонетте 8 попробовали решить эту штуку с помощью введения двух новых переключателей.
5447.64 5460.12 "Анатолий Кулаков" Это переключатели, которые позволяют вам настроить, чтобы бэкграунд сервисы стартовали параллельно и останавливались тоже параллельно.
5460.12 5470.20 "Анатолий Кулаков" Они настраиваются в host options, называются services start concurrently true и stop concurrently true.
5470.20 5482.84 "Анатолий Кулаков" После того, как вы эти флажочки установите, у вас будет происходить параллельный запуск всех ваших бэкграунд воркеров и в конце концов будут просто ожидаться, пока все эти бэкграунд воркеры закончатся.
5482.84 5484.52 "Анатолий Кулаков" Но стартуют они параллельно.
5484.52 5499.92 "Анатолий Кулаков" Эта опция не включена по умолчанию, потому что в текущем поведении, когда они запускались последовательно, у вас вполне могла быть логика, которая рассчитывает на результаты работы одного из бэкграунд сервисов внутри другого бэкграунд сервиса.
5499.92 5506.44 "Анатолий Кулаков" То есть вы рассчитывали, что второй начнет работать только после того, как первый доработает, поэтому я могу использовать результаты его работы.
5506.44 5521.52 "Анатолий Кулаков" Если у вас таких зависимостей нет, то вы вполне легко можете поставить вот эти флажочки в true и запускать все ваши сервисы, останавливать все ваши сервисы параллельно и при этом скорость их взлета и скорость остановки должна очень сильно возрасти.
5521.52 5526.84 "Анатолий Кулаков" Вот такой небольшой переключатель, но в принципе очень полезен для долгих бэкграунд сервисов, особенно если у вас их много.
5526.84 5527.84 "Анатолий Кулаков" Ну да, действительно.
5527.84 5537.68 "Игорь Лабутин" Я по-моему ни разу не встречал случаев, когда действительно были какие-то зависимости между разными бэкграунд сервисами.
5537.68 5541.68 "Игорь Лабутин" У нас они обычно это просто какие-то независимые кусочки, которые просто работают где-то.
5541.68 5544.96 "Анатолий Кулаков" Ну вообще рекомендуется конечно таких зависимостей не допускать.
5544.96 5547.64 "Анатолий Кулаков" То есть это уже плохая практика, это уже какой-то запах.
5547.64 5551.52 "Анатолий Кулаков" Если у вас какой-то один бэкграунд сервис зависит от результатов другого бэкграунд сервиса.
5551.52 5555.56 "Анатолий Кулаков" Ну такие люди тоже встречаются, и Microsoft не может себе позволить обидеть таких людей.
5555.56 5556.56 "Игорь Лабутин" Действительно.
5556.56 5573.68 "Игорь Лабутин" Ну хорошо, давай теперь вернемся еще немножко снова к Blazor, потому что попался мне ролик от Стива Сандерсона, это автор собственно Blazor, который мы уже на самом деле про его забавный эксперимент разговаривали.
5573.68 5587.56 "Игорь Лабутин" Может быть помните эксперимент под названием .NET Isolator, который позволяет запустить изолированное .NET приложение внутри другого .NET приложения, передавая туда контекст какой-то и обмениваться даже как-то вызовами между ними.
5587.56 5590.52 "Игорь Лабутин" Он теперь поэкспериментировал еще с одной штукой.
5590.52 5593.28 "Игорь Лабутин" Смотрите, во-первых, надо вспомнить, что такое Wazy.
5593.28 5598.12 "Игорь Лабутин" Wazy это VM by Assembly что-то там интерфейс.
5598.12 5599.12 "Игорь Лабутин" Я каждый раз...
5599.12 5600.12 "Игорь Лабутин" VM by Assembly интерфейс.
5600.12 5606.08 "Игорь Лабутин" Короче, это стандарт для того, чтобы запускать VM by Assembly сборки в сценариях вне браузера.
5606.08 5618.00 "Игорь Лабутин" То есть Wazy как таковой был придуман для того, чтобы запускать это все в обычный такой бинарный код в браузере, но есть еще теперь вот Wazy это вариант запуска VM by Assembly из вне браузера.
5618.00 5619.56 "Игорь Лабутин" Он систем интерфейс.
5619.56 5620.92 "Игорь Лабутин" О, систем интерфейс.
5620.92 5621.92 "Игорь Лабутин" Окей, спасибо.
5621.92 5628.40 "Игорь Лабутин" Значит, версия прототипов для того, чтобы, собственно, SDK для .NET для этого существует где-то примерно уже год.
5628.40 5629.40 "Игорь Лабутин" Это все прототип.
5629.40 5638.56 "Игорь Лабутин" И в восьмом .NET, согласно Стив Сандерсон, это все будет почищено, расширено, улучшено, стабилизировано и в восьмом .NET будет аж The Religion.
5638.56 5645.12 "Игорь Лабутин" То есть там будет прямо SDK, который позволяет вам собирать такие сборки, которые поддерживают этот самый Wazy.
5645.12 5649.12 "Игорь Лабутин" Сейчас для того, чтобы это делать, вам нужно заинсталить workload.
5649.12 5655.08 "Игорь Лабутин" Напоминаю, что в .NET у нас ставится не целиком, а есть опциональные компоненты, которые называются workloads.
5655.08 5663.16 "Игорь Лабутин" Workload сейчас называется Wazy Defense Experimental, но, видимо, к стандарту, ну, в смысле к релизу он будет все-таки Wazy, может быть, уже без экспериментов.
5663.16 5669.08 "Игорь Лабутин" И у вас появится новый project template, который называется Wazy Console.
5669.08 5671.40 "Игорь Лабутин" Пока там только речь про консольные приложения.
5671.40 5680.40 "Игорь Лабутин" И если вы создадите такое приложение, то вы увидите, что в Cessproje у вас появился новый runtime идентификатор.
5680.40 5684.52 "Игорь Лабутин" Напомню, что runtime идентификатор — это штука, которая показывает target платформу.
5684.52 5686.32 "Игорь Лабутин" Там это Linux, Windows и так далее.
5686.32 5688.92 "Игорь Лабутин" Но он называется теперь Wazy Defense Wasm.
5688.92 5694.96 "Игорь Лабутин" Если вы запустите просто такое приложение .NET RUN, то там произойдет довольно много магии.
5694.96 5709.84 "Игорь Лабутин" Он запустит приложение под названием Wasm App Host, которое внутри запустит Wasm Time — это специальный сервер-сайдранер для VBSAML сбора, который потом уже возьмет ваше скомпилированное приложение и его запустит внутри.
5709.84 5727.76 "Игорь Лабутин" Если теперь в Cessproje файл добавите Wasm Single File Bundle и поставите значение true, то результат у вас скомпилируется в путь, который там, ну, bin, debug, net8.0, как все это, как обычно, в Wazy Wasm, как мы говорили, это runtime идентификатор.
5727.76 5731.12 "Игорь Лабутин" И внутри будет папочка под названием App Bundle.
5731.12 5738.76 "Игорь Лабутин" Но результат вашего приложения будет не миллион файликов, потому что обычный .NET RUN ничего не пакует в один единственный Wasm файлик.
5738.76 5745.28 "Игорь Лабутин" Он пакует приложение в Wasm файлик и еще кучу Wasm файликов вокруг для, собственно, рантайма и всех остальных штук.
5745.28 5756.52 "Игорь Лабутин" Но если вы делаете Single File Bundle, то в этом случае у вас будет единственное приложение под названием, ну, в данном случае, MyApp.Wasm, которое будет содержать и ваше приложение, и рантайм целиком.
5756.52 5765.48 "Игорь Лабутин" То есть, по сути, это у вас такой единый Wasm файлик, который, собственно, он же, по сути, можно отправлять в браузер, но он же как раз работает и для Wazy.
5765.48 5769.56 "Игорь Лабутин" То есть он подготовлен для работы в Wazy, в самом рантайме.
5769.56 5771.16 "Игорь Лабутин" Зачем это, может быть, надо?
5771.16 5776.32 "Игорь Лабутин" Дальше я тут вам советую просто посмотреть видео, там буквально минут 10-15 про это надо посмотреть.
5776.32 5786.24 "Игорь Лабутин" Потому что, конечно же, можно было бы это использовать для того, чтобы взять ваше, там, ASP.NET приложение, собрать его в Wazy формате и запаблишить на сервер.
5786.24 5787.24 "Игорь Лабутин" Но зачем?
5787.24 5791.52 "Игорь Лабутин" То есть кажется, что существующие серверные приложения прекрасно работают и без Wazy.
5791.52 5792.52 "Игорь Лабутин" Нормального?
5792.52 5805.24 "Игорь Лабутин" Хотя, конечно, там со стороны всяких докеров и прочих появляется некоторая нативная поддержка Wasm файликов и так далее, но, тем не менее, Стив Сандерсон говорит, ну зачем?
5805.24 5816.24 "Игорь Лабутин" На самом деле это все не для этого, это больше для экспериментов и у него это сказано, что цель это иметь возможность создавать новые платформы и там использовать .NET.
5816.24 5837.44 "Игорь Лабутин" То есть это скорее как универсальный такой вариант для плагинов каким-нибудь или там, что-нибудь такое, ну да, типа плагинов для каких-нибудь платформ, чтобы вы могли не standalone приложение в такой формат компилировать, а именно писать для них метод расширения, еще что-нибудь на любом языке, который поддерживает Wazy, в частности на .NET.
5837.44 5848.68 "Игорь Лабутин" Вот, и он приводит три примера у себя в видосике, где такая штука может быть в принципе полезна, то есть вот один пример это тот самый .NET Azure Later, который мы уже обсуждали.
5848.68 5858.84 "Игорь Лабутин" Другой пример это тоже из разряда "А зачем?" Можно скомпилировать вот такой вот Wasm файлик, внутри которого будет работать ASP.NET Core сервер и все это будет работать в браузере.
5858.84 5871.80 "Игорь Лабутин" Не очень понятно, при чем здесь Wazy, мне кажется это в принципе просто showcase технологии Wasm и того, что вы можете зачем-то запустить браузер внутри, в смысле ASP.NET сервер внутри браузера.
5871.80 5874.44 "Игорь Лабутин" Не очень понятно, зачем это может быть надо, но допустим.
5874.44 5888.56 "Игорь Лабутин" Вот, и третий пример, вот ради него я рекомендую посмотреть видосик, это про то, как можно Wasm приложение одновременно запускать и на клиенте, и на сервере с прозрачной миграцией состояния между этими двумя приложениями.
5888.56 5902.48 "Игорь Лабутин" То есть у вас по сути не только, ну Blazor, Blazor Wasm в частности продавался долгое время, ну и иногда сейчас такой тоже один из аргументов в пользу того, что это тоже C#, вы там можете шарить бизнес модельки, бизнес логику и так далее.
5902.48 5906.92 "Игорь Лабутин" Так вот здесь Стив зашел до того, что он шарит просто целиком прямо Wasm файлик готовый.
5906.92 5914.60 "Игорь Лабутин" И вы можете либо его запускать как Wasm приложение в браузере, либо вы можете его запускать в Wazy Runtime на сервере.
5914.60 5928.04 "Игорь Лабутин" И поскольку это один и тот же код, то дальше там есть тент тонкости и техники, как сделать так, чтобы стейт относительно прозрачно шарился и у вас была возможность работать там как в оффлайне, так и в онлайне, и ваш экспириенс особо не отличался.
5928.04 5950.40 "Игорь Лабутин" Вот, в общем, это все понятно, что эксперименты, это все скорее про то, что Wasm стараются покрутить и так, и этак, чтобы найти ему, чтобы понять вообще на что он годен, какие применения ему могут быть, и что из этого нужно тащить в основной .NET или в тулинг вокруг .NET, или в студии, или еще чего-нибудь.
5950.40 5967.64 "Игорь Лабутин" Вот, поэтому если интересуетесь темой, рекомендую глянуть на Стива Сандерсона, он, наверное, по крайней мере в .NET мире один из тех, кто на переднем крае всей технологии изучает и паблишит видео вокруг всех этих экспериментов довольно часто.
5967.64 5979.36 "Анатолий Кулаков" Я все-таки верю в Wazy как в формат, как раз-таки бинарный формат обмена программами, кроссплатформенно и кросспрограммно, то есть как в интерфейс межязыкового взаимодействия.
5979.36 5993.04 "Анатолий Кулаков" Допустим, тот же самый пример с контейнерами, с кубернетосами, когда кубернетосу, в принципе, все равно, на какой контейнер запускать, на каком языке этот контейнер написан, какие в нем внутри фреймворки, какие версии и так далее.
5993.04 5996.24 "Анатолий Кулаков" У него должен быть какой-то интерфейс, который просто запускается и все.
5996.24 6006.48 "Анатолий Кулаков" Вот раньше таким интерфейсом служил Docker, и, в принципе, в Wazy это хорошая замена Docker по тем или иным причинам, которые могут быть.
6006.48 6014.84 "Анатолий Кулаков" То есть вы можете распространять свои бинарники, которые могут запускаться какой-то средой, и неважно, на чем эти бинарники написаны.
6014.84 6027.00 "Игорь Лабутин" Причем, более того, это не просто бинарник, но это бинарник с известным более-менее API стандартизированным, что позволяет подергать прям возможные API этих самых программ.
6027.00 6028.00 "Анатолий Кулаков" Именно так.
6028.00 6049.00 "Анатолий Кулаков" И еще одно интересное свойство этого бинарника заключается в том, что этот формат разрабатывался на основе WebAssembly, естественно, а WebAssembly разрабатывалась специально для выполнения в изолированной среде, где очень много техник применено для того, чтобы вредоносный код не вылез за вот этот сэндбокс, в котором он работает.
6049.00 6058.40 "Анатолий Кулаков" И это очень хорошее свойство всех исполняемых файлов, которые, в принципе, должно было быть изначально, с времен во всех приложениях.
6058.40 6063.44 "Анатолий Кулаков" Если я не хочу, чтобы эта штука имела доступ к какой-нибудь хостовой системе, значит, она не должна его туда иметь.
6063.44 6067.60 "Анатолий Кулаков" Или каким-то образом декларировала свои намерения, которые я могу одобрять или отклонять.
6067.60 6077.64 "Анатолий Кулаков" Эта технология довольно хорошо показала себя, например, на мобильных приложениях, когда вы сами даете разрешение программе лезть туда или сюда, и можете это решать.
6077.64 6080.76 "Анатолий Кулаков" И в Азии это приносит как раз на уровень уже самой непосредственно платформы.
6080.76 6093.84 "Анатолий Кулаков" И мне кажется, не за горами, когда операционные системы начнут запускать просто-напросто в WebAssembly приложения через ВАЗ-интерфейс, как вот обычные наши десктоп-приложения.
6093.84 6096.24 "Анатолий Кулаков" Я думаю, что Windows в этом плане должна подсветиться.
6096.24 6099.12 "Анатолий Кулаков" Она там уже умеет как бы Linux-приложения запускать.
6099.12 6102.92 "Анатолий Кулаков" Вот скорее всего, она должна быть одной из первых, кто позволит такую штуку сделать.
6102.92 6113.20 "Анатолий Кулаков" И тогда мы сможем писать кроссплатформенные десктопные приложения на любом языке программирования и запускать их где угодно, на абсолютно любой операционной системе, хоть в облаке, хоть в браузере, хоть где угодно.
6113.20 6118.00 "Анатолий Кулаков" Мне кажется, к такому счастливому будущему нас подталкивает вот этот интерфейс.
6118.00 6119.80 "Игорь Лабутин" Да, звучит как бы действительно будущее.
6119.80 6120.80 "Игорь Лабутин" Ладно, посмотрим.
6120.80 6122.80 "Игорь Лабутин" Давай вернемся к настоящему.
6122.80 6130.52 "Игорь Лабутин" У нас есть еще немножко относительно мелких тем, но от этого они становятся менее важными.
6130.52 6135.20 "Анатолий Кулаков" Ну и это тоже большая новость, потому что компания, какая компания, блин, сообщество.
6135.20 6139.40 "Анатолий Кулаков" Сообщество DotNet.ru поделилось с нами еще одной радостной новостью.
6139.40 6151.20 "Анатолий Кулаков" И для тех, кто не знает, и для тех, кто не помнит, мы напомним, что сообщество DotNet.ru занимается переводом книг с английского языка на русский, книг по программированию и по C#, по Дотнету в частности.
6151.20 6155.60 "Анатолий Кулаков" Ну даже не столько переводом, потому что переводом занимается любое издательство.
6155.60 6164.24 "Анатолий Кулаков" Основная фишка этой организации заключается в том, что мы вычитываем книги и переводим их на разговорный русский язык.
6164.24 6172.52 "Анатолий Кулаков" И когда вы берете эту книгу и начинаете читать, у вас не возникает уже такого желания как бы прогнать ее обратно через Google Translate и почитать в оригинале.
6172.52 6183.16 "Анатолий Кулаков" Потому что она должна читаться легко, понятно, на живом русском языке и с учетом всех тех терминов и всей той специфики, с которой общаются разработчики.
6183.16 6191.36 "Анатолий Кулаков" И вот команда DotNet.ru Translate объявила о том, что перевела очередную книгу и книга очень в тему.
6191.36 6194.56 "Анатолий Кулаков" Это книга про ISP.net Core Security.
6194.56 6200.04 "Анатолий Кулаков" То есть там очень детально описывается, каким образом строить безопасные приложения, поддерживать их.
6200.04 6207.00 "Анатолий Кулаков" Ну и, наверное, лучше всего расскажет Игорь, потому что он как раз-таки организовывал и курировал этот процесс.
6207.00 6210.00 "Анатолий Кулаков" Игорь, что ты скажешь про переводы данной книги?
6210.00 6216.52 "Игорь Лабутин" Ну, я могу сказать, что хорошая книжка, отличный перевод, наша вычитка еще лучше, конечно.
6216.52 6219.76 "Игорь Лабутин" Мы становимся все более и более профессиональны с каждой новой книжкой.
6219.76 6223.12 "Игорь Лабутин" Но на самом деле, да, Кристиан Венц написал довольно хорошую книжку.
6223.12 6226.96 "Игорь Лабутин" Я, по сути, ее прочитал, пока мы ее вычитывали.
6226.96 6242.68 "Игорь Лабутин" И надо сказать, что там довольно подробное описание и уязвимостей, которым могут подвергаться ваши приложения, и про то, что с ними делать, как их предотвращать и как, в принципе, подходить к безопасной разработке приложений.
6242.68 6250.36 "Игорь Лабутин" То есть это не просто обзор уязвимостей, там всякие топ-10 авазп, вот это в таком духе, хотя есть отдельная глава, посвященная авазп топ-10.
6250.36 6257.00 "Игорь Лабутин" Но это скорее такое руководство по в целом безопасной разработке программ на .NET и на SPNET.
6257.00 6271.80 "Игорь Лабутин" То есть там, если вы не знаете, что такое какие-нибудь там все эти same-site cookies, course policy, cross-origin, как там они называются, request, что-то там, я уже забыл, course и course.
6271.80 6285.88 "Игорь Лабутин" То берите книжку, там все это очень подробно расписано на понятных примерах, все поймете, все будете писать вообще идеально, отличный код, там же, кстати, есть отдельно и про авторизацию, и про авторизацию, и про идентификацию, что со всем этим делать, как с этим всем бороться и жить.
6285.88 6294.48 "Игорь Лабутин" У нас было в этот раз довольно мало споров, то есть книжка получилась и переведена, и написана понятным языком.
6294.48 6307.72 "Игорь Лабутин" Я, честно говоря, ожидал, что будет гораздо больше проблем, потому что security и безопасность - такая область, где довольно много специфических терминов, но мы как-то справились и почти без споров завершили всю работу над ней.
6307.72 6343.72 "Анатолий Кулаков" Если вы хотите немножко больше подробностей о переводе, о команде, а самое главное - о промокоде, который даст вам скидку 25% на покупку этой книги, в общем, у нас в шоу-ноутах будет ссылочка на статью на Хабре, в общем, на Хабре там все подробно с ссылками, с именами, с фамилиями, все подробно рассказано, поэтому заходите, читайте, покупайте, хорошая книга, отличная тема, которую, мне кажется, должен знать абсолютно каждый разработчик, начиная с джунов, потому что безопасность - это самое главное, ее надо узнавать еще до того, как вы начинаете опишки наружу выставлять голой попой, потому что иначе вы можете в будущем от этого пострадать.
6343.72 6346.00 "Игорь Лабутин" Да, но не забывайте про промокодик.
6346.00 6370.96 "Анатолий Кулаков" Да, да, промокодик есть, я еще кратко напомню, что у нас это была четвертая книга, которую мы вычитали, у нас был еще Конрад Кокос в управлении памятью, Эндрю Лока в SP.NET Core в действии, Entity Framework в действии, и вот эта четвертая - безопасность в Entity SP.NET Core, то есть не в Entity, просто в SP.NET Core, и мы продолжаем работать с издательствами, мы продолжаем переводить книги, и мы уже работаем над следующей книгой, она будет угадать про что?
6370.96 6371.96 "Анатолий Кулаков" Про FrontEnd.
6371.96 6376.36 "Анатолий Кулаков" Ну, не то, что про FrontEnd, но про Blazer, конечно.
6376.36 6377.36 "Анатолий Кулаков" Смысл в чем?
6377.36 6423.76 "Анатолий Кулаков" Если вы хотите присоединиться к нашему дружному сообществу, абсолютно все это мы делаем безвозмездно, бесплатно и для собственного удовольствия, то все ссылки будут в статье на хабре, присоединяйтесь к нашему чату переводчиков, можно просто посидеть, можно там свои отзывы дать по переводу, мы обязательно будем его улучшать, если вы вдруг нашли какие-то интересные мысли, идеи, как это можно сделать лучше, или если вы хотите нам помочь, опять же, здесь не важно абсолютно знание, не то, чтобы абсолютно не важно, не так критично знание английского языка, как вам может показаться на первый раз, здесь намного критичнее знание русского языка, как правильно выразиться, как правильно сказать, консистентнее донести свою мысль, вот это для нас очень важно, поэтому если вы хотите поучаствовать в такой интересной движухе, то все ссылки будут на хабре, присоединяйтесь к нашему телеграм-чатику, там будут все подробности.
6423.76 6433.88 "Игорь Лабутин" Ну и давай потихонечку завершать, у нас остался наш традиционный раздел "Кратко о разном", у нас там чуть-чуть новостей, я смотрю, вышел новый сек?
6433.88 6467.20 "Анатолий Кулаков" Да, и это немножко тоже пересекается с нашей темой про метрики в дотнет 8, потому что новый сек, он поддерживает, его основная фишка в этом релизе - релиз 2023.2, он поддерживает нативно протокол OpenTelemetry, то есть все те заголовочки, все те поля, которые там у вас были, вроде TraceID, SpanID, они теперь являются First Class Citizen в SICK, то есть вы можете по ним искать, сортировать, фильтровать, пристроить индексы, рисовать графики, в общем все это нативно он способен потреблять.
6467.20 6487.64 "Анатолий Кулаков" Вы можете писать в SICK с помощью стандартной любые OpenTelemetry, которые есть абсолютно на любом языке, ну или если вы пользуетесь Serilog, что очень часто бывает в нашем мире, то там есть специальный Sink для OpenTelemetry, который точно также может писать и в SICK, и в любой другой провайдер OpenTelemetry, и много куда еще.
6487.64 6505.64 "Анатолий Кулаков" В общем, да, хороший такой полезный релизик, он, напомню, что SICK доступен не только под Windows, но и под Linux, и под любые операционные системы, и в частности в Docker контейнере, поэтому везде, где запускается Docker, там вы можете просто поставить бесплатную версию SICK и посмотреть, на что он способен.
6505.64 6567.76 "Игорь Лабутин" А кроме этого от Microsoft потихонечку, если там покопаться в дебрях GitHub, то находят всякие интересные штуки, то есть, во-первых, у нас, если вы помните, у нас теперь не только там Small Object Heap и Large Object Heap есть, у нас есть еще теперь Pinned Object Heap, Frozen Object Heap, короче, хипов у нас теперь не оберешься, и Microsoft задумалась, что вот тот самый Frozen Object Heap, куда на самом деле попадают всякие литералы, строковые объекты типов, то есть те объекты, по сути, которые известны заранее на момент запуска программы и больше особо никогда не меняются, то есть их не нужно garbage collect, их не нужно, в общем, они не там, не мигрируют по поколениям и так далее, и тут Microsoft поняла, что как только они туда начнут пихать довольно много всяких разных объектов, надо бы теперь поддержать это дело в диагностике нормальной, потому что раньше этот хип, который отдельный, он был такой немножко отдельный и не обрабатывался довольно многими тулами, которые в основном в тотмейтчике пользуются для диагностики.
6567.76 6573.48 "Игорь Лабутин" Ну, когда мы говорим тотмейтчик, мы подразумеваем на самом деле скорее команду рантайма, но и не только.
6573.48 6596.12 "Игорь Лабутин" И теперь они свели все в единую большую ищу на GitHub, на которой работают, где есть прям по пунктам перечислено, что они будут делать, в каких тулах, что будет поддержано, и в частности там есть интересный момент, что общий настрой примерно такой, что любая API, а, давай не так, общий настрой примерно такой, что у нас есть теперь разделение на два типа хипов.
6596.12 6602.20 "Игорь Лабутин" Один называется GC-хип, туда входит Small Object HIP, Large Object HIP и Pinned Object HIP.
6602.20 6604.68 "Игорь Лабутин" Это хипы, которые обслуживаются garbage collector.
6604.68 6613.96 "Игорь Лабутин" Есть Non-GC-хип, это тот самый Frozen Object HIP, потому что garbage collector, ну ему туда заходить не нужно, по большому счету.
6613.96 6616.52 "Анатолий Кулаков" Отлично, новый вопрос на собеседование готов.
6616.52 6628.72 "Игорь Лабутин" Да, и соответственно изменение логическое, оно будет заключаться в следующем, что все API, которые в себе в имени имеют слово GC, будут теперь возвращать данные только про GC-хипи.
6628.72 6645.68 "Игорь Лабутин" То есть если ты, например, возьмешь какой-нибудь строковый литерал, а в C# программе это же объект, правильно, это reference, и спросишь на нем system.gc.getGeneration, по-моему, это называется, туда можно передать объект, и он тебе скажет, в каком поколении сейчас находится этот объект.
6645.68 6651.12 "Игорь Лабутин" Так вот, для таких вот строковых литералов, которые живут во Frozen-хипе, он вернет внезапно -1.
6651.12 6660.44 "Игорь Лабутин" И если вы в вашей программе где-то надеялись, что getGeneration всегда возвращает 0, 1 или 2, то знайте, теперь может вернуть -1.
6660.44 6675.20 "Игорь Лабутин" Ну и вот все такие же штуки, то есть если там какой-нибудь GC enumerate-hips, не будет теперь энумерировать Frozen-Object-hip, не то чтобы он и раньше это делал, но теперь вот это прям четкое разделение, есть GC-хип, есть Non-GC-хип, мало ли где-то встретятся все.
6675.20 6681.88 "Игорь Лабутин" Из незамеченных, я, кстати, думал, что это будет где-то в анонсах студии, но, тем не менее, это нигде в анонсах не прозвучало.
6681.88 6692.52 "Игорь Лабутин" Hot Reload, штука, которая, по сути, поддержан студией и дутнетулом, позволяющей модифицировать код прямо во время исполнения, теперь поддерживает модификацию дженериков.
6692.52 6708.08 "Игорь Лабутин" Вы все еще не можете менять количество параметров в типе, это Hot Reload не переваривает, но вот добавлять методы, в том числе дженерик-методы, в существующие, в том числе дженерик-классы вполне можно, это работает нормально.
6708.08 6709.56 "Игорь Лабутин" Так что Hot Reload потихонечку учится.
6709.56 6726.08 "Игорь Лабутин" Для VCF, а если вы вдруг зачем-то пользуетесь VCF, вы, может быть, знаете, что для клиентского VCF в Microsoft поставляет официальный Nougat пакет, System Service Model, там вот это все, даже коллекцию, на самом деле, они все начинаются с System Service Model, это официальный пакет от Microsoft.
6726.08 6733.88 "Игорь Лабутин" Для сервер-сайда, соответственно, есть Core VCF проект, который там как-то потихонечку пытается поддержать все, что нужно для VCF, и при этом кросс-платформенно.
6733.88 6761.16 "Игорь Лабутин" Так вот, появилась поддержка в клиентской части, нет named pipes, то есть вы теперь можете коннектиться, если вы на винде, по именовым каналам, это довольно популярный способ работы был всегда в VCF, как быстрое межпроцессное взаимодействие, работает пока только на виндусе, но Core VCF команда пилит поддержку Unix доменных сокетов в проекте Core VCF, и как только она будет допилена в серверной части, вот в этой кросс-платформенной, тут же добавят поддержку в клиентскую.
6761.16 6775.08 "Игорь Лабутин" Targeted это все теперь .NET 6.0+ и у них теперь интересная система версионирования, то есть они теперь сказали, что у нас будет, то есть вот сейчас вышел пакет System Service Model 6, потому что он Targeted .NET 6.
6775.08 6780.84 "Игорь Лабутин" Как только выйдет 8, следующая версия будет System Service Model 8, которая будет Targeted, соответственно, 8+.
6780.84 6784.56 "Игорь Лабутин" Ну и поддерживаться пакеты будет, соответственно, пока поддерживается LTS-версия.
6784.56 6785.56 "Игорь Лабутин" Такие дела.
6785.56 6791.00 "Игорь Лабутин" Если вы зачем-то пользуетесь VCF, или вам нужно как клиент уходить, вот, наверное, вам это будет полезно.
6791.00 6801.00 "Игорь Лабутин" И последнее, это проектик, на который я наткнулся совершенно случайно, где-то тоже то ли в твиттере увидел, то ли что-то, называется .NET Version Sweeper.
6801.00 6823.64 "Игорь Лабутин" Это GitHub Action, который бегает по вашему коду, ну, то есть это GitHub Action, который по задумке авторов исполняется по крону, там, раз в месяц, и который репортит вам ишью ваш проект, если он находит в вашем проекте процесс про .G, который ссылается на фреймворки, которые либо out of support уже, либо которые скоро будут out of support.
6823.64 6828.16 "Игорь Лабутин" Ну, такая напоминалка, типа, обнови версию .NET, она скоро будет уже не поддержана.
6828.16 6839.60 "Игорь Лабутин" Не то чтобы это было, ну, я не знаю, на самом деле, нужно ли это кому-то с точки зрения прямо поддержки-поддержки, хотя, может быть, если вы поддерживаете очень много проектов на GitHub, и такое будет полезно, чтобы регулярно их обновлять на последнюю версию.
6839.60 6847.80 "Игорь Лабутин" Но я, скорее, смотрел на этот проект как на интересный, ну, не столько интересный, просто как бы, практически пример того, как можно работать с GitHub.
6847.80 6855.12 "Игорь Лабутин" То есть там довольно приятный, понятно написанный C# код, который там умеет создавать ишью на GitHub, вот это вот все.
6855.12 6859.24 "Игорь Лабутин" Вот, вполне можно посмотреть, поизучать, если вдруг вам зачем-то это надо.
6859.24 6864.60 "Анатолий Кулаков" Полезная интеграция с GitHub часто, да, бывает полезная для всяких проектов.
6864.60 6871.32 "Игорь Лабутин" Ну, видишь, поскольку это GitHub Action, то там нет интеграции по идее, по коду, потому что, ну, Action просто его склонирует и все.
6871.32 6875.92 "Игорь Лабутин" То есть, в смысле, это Action сам сделает за тебя, то есть тебе просто нужно побегать по коду и все.
6875.92 6880.00 "Игорь Лабутин" Но, по крайней мере, с точки зрения, в разрезе ишьев, вполне можно.
6880.00 6893.88 "Игорь Лабутин" Там эта штука, она автоматически там создаст нужный лейбл, все ишьев от этого Action помечаются специальным лейблом, то есть она его там создаст, проверит, что он есть, если нет, то новый будет, ну и так далее.
6893.88 6897.80 "Игорь Лабутин" Короче, просто аккуратно написанный код, неплохой, чисто на C#.
6897.80 6898.80 "Анатолий Кулаков" Отлично.
6898.80 6901.68 "Анатолий Кулаков" Ну, кажется, что мы на сегодня отстрелялись.
6901.68 6902.68 "Анатолий Кулаков" Да.
6902.68 6903.68 "Игорь Лабутин" Давай закругляться.
6903.68 6905.68 "Игорь Лабутин" Да, давай будем закругляться.
6905.68 6914.24 "Игорь Лабутин" Мы сегодня поговорили про Microsoft Build и про то, как у нас теперь будет круто с новым нашим искусственным интеллектом в лице Copilot, AI, Azure и всего остального.
6914.24 6916.40 "Игорь Лабутин" .NET 8 Preview 4 вышел.
6916.40 6928.44 "Игорь Лабутин" На самом деле, вышел он буквально на пару дней после того, как мы опубликовали прошлый выпуск подкаста, но так уж сложилось, пришлось немножко подождать, пока мы его обозрели.
6928.44 6937.44 "Игорь Лабутин" Вышел C# DevKit для Visual Studio Code, новый экстенджер для более правильной поддержки, там, с Solution Explorer и тестами и всем остальным в DC# Visual Studio Code.
6937.44 6948.72 "Игорь Лабутин" Узнали, что нас ждет в Blazor в .NET 8, посмотрели на Visual Studio новую 17.6 релиз и Preview 17.0 следующие.
6948.72 6953.68 "Игорь Лабутин" Посмотрели улучшение в .NET 8 Concurrent Hosted Services, Start и Stop.
6953.68 6955.32 "Игорь Лабутин" Можно теперь это настроить.
6955.32 6963.44 "Игорь Лабутин" Узнали, что такое вази в общих чертах и зачем это может быть нам полезно, ну, скорее так, в качестве эксперимента.
6963.44 6969.16 "Игорь Лабутин" Услышали про то, что новая книжка по S/S Security вышла в правильном переводе от .NET True.
6969.16 6979.48 "Игорь Лабутин" Ну и узнали всякие мелочи вокруг того, на что мы наткнулись по пути, пока эти несколько недель искали новости и смотрели, что происходит в .NET.
6979.48 6980.48 "Анатолий Кулаков" Отлично.
6980.48 6991.68 "Анатолий Кулаков" А вы, дорогие наши слушатели, не забывайте рассказывать о нас своим друзьям, шарить, репостить, пишите нам побольше комментариев, мы их очень любим, все обязательно читаем и учитываем в наших будущих выпусках.
6991.68 7000.56 "Анатолий Кулаков" Если найдете какую-нибудь интересную темку или программку или автор или еще что угодно, связанное с .NET, обязательно присылайте к нам на почту, мы это тоже что-нибудь учтем.
7000.56 7001.56 "Анатолий Кулаков" На этом все.
7001.56 7004.32 "Анатолий Кулаков" Побежали радоваться солнечному питерскому лету.
7004.32 7006.36 "Анатолий Кулаков" Всем счастливо, всем пока, до новых встреч.
7006.36 7007.36 "Анатолий Кулаков" Всем пока.
