0.00 10.24 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер
10.24 11.24 "Анатолий Кулаков" 82.
11.24 13.96 "Анатолий Кулаков" И в студии с вами, как всегда, Анатолий Кулаков.
13.96 15.16 "Анатолий Кулаков" И Игорь Лабутин.
15.16 16.16 "Анатолий Кулаков" Всем привет.
16.16 20.56 "Анатолий Кулаков" А также большая гвардия тех, кто нам помогает, кто
20.56 23.44 "Анатолий Кулаков" ставит свои комментарии, шарит, репостит, рассказывает
23.44 24.88 "Анатолий Кулаков" друзьям, и вы тоже не забывайте.
24.88 26.50 "Анатолий Кулаков" Кстати, там что-то заглядывал недавно в iTunes, у нас там
26.50 29.28 "Анатолий Кулаков" совсем мало голосов, поэтому если вы вдруг пользуетесь
29.28 31.92 "Анатолий Кулаков" какой-то площадочкой, поставьте нам каких-нибудь звездочек,
31.92 35.52 "Анатолий Кулаков" может эти заморские буржуи продвинут нас куда-нибудь
35.52 38.64 "Анатолий Кулаков" в своих чартах, и больше людей узнает про наш подкаст.
38.64 42.62 "Анатолий Кулаков" И в частности, если вы захотите помочь материально нашему
42.62 45.16 "Анатолий Кулаков" подкасту, напоминаю, что у нас до сих пор нет рекламы,
45.16 48.24 "Анатолий Кулаков" поэтому вот ее нет благодаря таким замечательным людям,
48.24 51.20 "Анатолий Кулаков" как Александр, Сергей, Владислав, Шевченко Антон, Лазарев
51.20 54.48 "Анатолий Кулаков" Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр
54.48 58.48 "Анатолий Кулаков" Ерыгин, Сергей Бензенко и Александр Лапердин.
58.48 61.40 "Анатолий Кулаков" Большое спасибо, друзья, и также всем тем, кто помогает
61.40 64.68 "Анатолий Кулаков" нам на Boosty, если вы еще не среди них, то заходите
64.68 65.68 "Анатолий Кулаков" и присоединяйтесь.
65.68 68.68 "Анатолий Кулаков" Ну что ж, о чем сегодня поговорим?
68.68 70.76 "Анатолий Кулаков" Давай лучше скажем, о чем мы поговорить не будем.
70.76 74.76 "Игорь Лабутин" Да, это важный момент, мы прямо вот, это, наверное,
74.76 78.76 "Игорь Лабутин" небольшой секрет, мы пишемся ровно примерно, когда идет
78.76 82.20 "Игорь Лабутин" или даже уже почти закончился .NET Conf, и, наверное, все
82.20 85.48 "Игорь Лабутин" бы ожидали, что к моменту, когда этот выпуск вы услышите,
85.48 88.44 "Игорь Лабутин" .NET Conf уже пройдет несколько дней назад, но в этот момент
88.44 92.88 "Игорь Лабутин" в этот раз не будет ничего про .NET 8, в смысле обзора
92.88 95.80 "Игорь Лабутин" .NET Conf, что же нам там показал Майкрософт, это все будет
95.80 99.64 "Игорь Лабутин" в следующем выпуске, который мы постараемся сильно
99.64 100.64 "Игорь Лабутин" не затягивать.
100.64 103.80 "Игорь Лабутин" Можно было бы затянуть подольше, успеть все это
103.80 106.56 "Игорь Лабутин" просмотреть, почитать все анонсы, но мы решили, что
106.56 109.40 "Игорь Лабутин" затягивать не будем, лучше мы выпустим выпуск сейчас,
109.40 111.80 "Игорь Лабутин" почитаем потом спокойненько, и там через недельку или
111.80 116.12 "Игорь Лабутин" где-нибудь около того запишем отдельный выпуск именно
116.12 118.36 "Игорь Лабутин" про релиз .NET 8.
118.36 121.28 "Анатолий Кулаков" Ну и основная часть материала нашим постоянным слушателям
121.28 124.52 "Анатолий Кулаков" все равно уже знакома, те, кто с нами давно знает,
124.52 127.04 "Анатолий Кулаков" что мы практически весь год обозревали то, к чему
127.04 130.88 "Анатолий Кулаков" мы стремимся, плюс этот подход хорош тем, что там
130.88 134.56 "Анатолий Кулаков" за недельку уляжется вся пыль, как бы сформируются
134.56 137.04 "Анатолий Кулаков" статьи, сформируются мнения, сформируются какие-то еще
137.04 138.96 "Анатолий Кулаков" интересные, может быть, инструменты вокруг этого,
138.96 145.12 "Анатолий Кулаков" поэтому все обозреем основательно и тщательно для того, чтобы
145.12 146.12 "Анатолий Кулаков" вам все это донести.
146.12 148.88 "Анатолий Кулаков" Поэтому не торопитесь, нормально, все будет.
148.88 151.72 "Анатолий Кулаков" А сегодня поговорим как раз о тех интересных статьях,
151.72 155.24 "Анатолий Кулаков" которые давно нас ждут в бэклоге, и парочку новинок
155.24 157.48 "Анатолий Кулаков" тоже сегодня будет, поэтому, я думаю, не заскучаем.
157.48 160.88 "Игорь Лабутин" Я даже больше скажу, мы чуть-чуть затронем .NET 9
160.88 163.32 "Игорь Лабутин" уже, но очень в конце и очень чуть-чуть.
163.32 166.96 "Игорь Лабутин" А давай пока к статьям.
166.96 167.96 "Анатолий Кулаков" Давай к статьям.
167.96 170.16 "Анатолий Кулаков" Вот в принципе из нового релиза, можно сказать,
170.16 172.32 "Анатолий Кулаков" да, из восьмерочки, к нам приедет такая прекрасная
172.32 176.92 "Анатолий Кулаков" штука, как TimeProvider, и к этому TimeProvider есть большое количество
176.92 177.92 "Анатолий Кулаков" вопросов.
177.92 178.92 "Анатолий Кулаков" Вот предлагаю с него и начать.
178.92 183.36 "Анатолий Кулаков" Давайте разогреемся немножко и обозрим немножко поближе
183.36 189.92 "Анатолий Кулаков" этот TimeProvider, его специфику, его альтернативную одаренность,
189.92 191.88 "Анатолий Кулаков" и в этом нам поможет Андрю Логг.
191.88 195.52 "Анатолий Кулаков" Андрю Логг вообще любит доставать все новое, что
195.52 198.84 "Анатолий Кулаков" есть в библиотеке, там есть ВСП, и по косточкам все
198.84 199.84 "Анатолий Кулаков" это разбирать.
199.84 202.68 "Анатолий Кулаков" Не сказать, что у него как бы слишком глубокие разборы,
202.68 205.32 "Анатолий Кулаков" но я думаю, для нашего формата голосового это хорошо подходит.
205.32 207.64 "Анатолий Кулаков" В глубокие мы с вами все равно не взорвемся.
207.64 209.84 "Анатолий Кулаков" И Андрю недавно выпустил статью, которая называется
209.84 213.12 "Анатолий Кулаков" как раз таки «Как избежать флаки тестов с помощью
213.12 214.52 "Анатолий Кулаков" TimeProvider и таймера».
214.52 217.72 "Анатолий Кулаков" Флаки на русский как-нибудь переводится нормально?
217.72 219.56 "Анатолий Кулаков" Мигающие, мигающие тесты.
219.56 222.00 "Анатолий Кулаков" Мигающие тесты, там типа зыбкие тесты.
222.00 224.44 "Игорь Лабутин" Не, мне кажется, это обычно называется мигающие, но
224.44 226.36 "Игорь Лабутин" которые у вас то красненькие, то зелененькие, то красненькие,
226.36 227.36 "Игорь Лабутин" то зелененькие.
227.36 230.12 "Игорь Лабутин" А потом красненькие, красненькие, красненькие, а запускаешь
230.12 232.88 "Игорь Лабутин" локально – зелененькие.
232.88 235.40 "Анатолий Кулаков" Такие тесты очень сильно зависят от окружения, где
235.40 237.16 "Анатолий Кулаков" запускаются, особенно когда их запускают на каком-нибудь
237.16 239.92 "Анатолий Кулаков" ICD, где не хватает ресурсов, и там начинают проявляться
239.92 242.36 "Анатолий Кулаков" такие какие-то мелкие погрешности.
242.36 245.88 "Анатолий Кулаков" И очень часто такие тесты связаны как раз таки с таймерами,
245.88 248.24 "Анатолий Кулаков" потому что пытаются там дождаться, например, часто
248.24 250.72 "Анатолий Кулаков" в таких тестах есть строчка подождать там одну секунду
250.72 253.36 "Анатолий Кулаков" или подождать две секунды и проверить, что результат
253.36 255.56 "Анатолий Кулаков" наконец-то в базе сформировался, вот какую-нибудь такую
255.56 258.24 "Анатолий Кулаков" глупость люди пишут, а потом от этого страдают.
258.24 262.90 "Анатолий Кулаков" И вот в частности, таких проблем позволяет избежать
262.90 263.90 "Анатолий Кулаков" новый интерфейс.
263.90 265.64 "Анатолий Кулаков" Ну, давайте по порядку.
265.64 268.12 "Анатолий Кулаков" Что же это такое и зачем оно нам нужно?
268.12 274.44 "Анатолий Кулаков" Как я уже сказал, в новом Дотнет 8 будет новая концепция
274.44 278.44 "Анатолий Кулаков" айтайм-провайдера и айтаймера.
278.44 280.56 "Анатолий Кулаков" Разберемся на простом примере, какую же проблему мы все-таки
280.56 281.56 "Анатолий Кулаков" решаем.
281.56 282.56 "Анатолий Кулаков" Проблема следующая.
282.56 285.64 "Анатолий Кулаков" Обычный человек, когда ему нужно обратиться к дате
285.64 290.76 "Анатолий Кулаков" времени, чтобы узнать, например, текущую дату, использует
290.76 296.64 "Анатолий Кулаков" свойства dataTime.utcNow или dataTime.offset.utcNow, т.е. он узнает, какое текущее
296.64 300.52 "Анатолий Кулаков" время сейчас с помощью этих стандартных свойств.
300.52 302.68 "Анатолий Кулаков" Это статические свойства, поэтому их можно выяснить
302.68 305.72 "Анатолий Кулаков" в любой момент в любом коде, который у вас есть.
305.72 309.16 "Анатолий Кулаков" И все хорошо до тех пор, пока вы не собираетесь ваш
309.16 310.16 "Анатолий Кулаков" класс оттестировать.
310.16 314.52 "Анатолий Кулаков" Например, есть у вас какой-нибудь билет, который должен экспириться
314.52 317.40 "Анатолий Кулаков" через 14 дней, т.е. закрываться и становиться недействительным.
317.40 320.48 "Анатолий Кулаков" Вы обычно в коде напишите метод, который называется
320.48 325.70 "Анатолий Кулаков" xExpired и проверите, прошло ли с момента, когда был
325.70 332.28 "Анатолий Кулаков" заведен билет, плюс 14 дней, больше ли это дата, чем dataTime.utcNow.
332.28 334.36 "Анатолий Кулаков" Таким образом вы сможете ответить на вопрос, действительно
334.36 335.96 "Анатолий Кулаков" этот билет еще или недействительный.
335.96 341.08 "Анатолий Кулаков" И в принципе все хорошо, класс будет жить нормально
341.08 343.76 "Анатолий Кулаков" до тех пор, пока вы не начнете его тестировать.
343.76 345.72 "Анатолий Кулаков" Потому что непонятно, как его тестировать.
345.72 349.04 "Анатолий Кулаков" Вы не можете поставить в ваших тестах sleep на 14 дней
349.04 351.44 "Анатолий Кулаков" и проверить, заэкспирился ли билет через 14 дней или
351.44 352.44 "Анатолий Кулаков" не заэкспирился.
352.44 353.44 "Анатолий Кулаков" Ну, это глупо.
353.44 356.84 "Анатолий Кулаков" Поэтому люди решают данный подход разными способами.
356.84 359.76 "Анатолий Кулаков" Ну, в частности, самый простой способ – это просто-напросто
359.76 363.72 "Анатолий Кулаков" передать в конструктор этому классу тикету, текущую
363.72 366.92 "Анатолий Кулаков" дату, и к текущей дате он прибавит 14 дней, сделает
366.92 369.96 "Анатолий Кулаков" свои манипуляции, и в принципе тест вы тогда в этом случае
369.96 370.96 "Анатолий Кулаков" легко напишете.
370.96 375.64 "Анатолий Кулаков" То есть, когда он не будет брать dataTime из какого-то
375.64 377.84 "Анатолий Кулаков" статического свойства, а получит его явно через
377.84 379.60 "Анатолий Кулаков" конструктор, тогда все входные параметры будут
379.60 381.44 "Анатолий Кулаков" полностью управляться, и тесты на такие вещи писать
381.44 382.44 "Анатолий Кулаков" довольно-таки легко.
382.44 386.56 "Анатолий Кулаков" Но проблема на этом не заканчивается.
386.56 390.52 "Анатолий Кулаков" Потому что обычно хочется, чтобы еще этот класс участвовал
390.52 391.88 "Анатолий Кулаков" в интеграционных тестах.
391.88 394.60 "Анатолий Кулаков" А в интеграционных тестах вы уже ему напрямую никакие
394.60 396.84 "Анатолий Кулаков" аргументы не засунете, в конструктор никакой dataTime
396.84 397.84 "Анатолий Кулаков" не просунете.
397.84 402.88 "Анатолий Кулаков" И поэтому эта задача данным способом не решается.
402.88 403.88 "Анатолий Кулаков" Рассмотрим второй пример.
403.88 408.52 "Анатолий Кулаков" Вот, допустим, у вас есть какой-то background job с таймером,
408.52 411.08 "Анатолий Кулаков" и этот таймер там тикает каждую секунду, и каждую
411.08 413.08 "Анатолий Кулаков" секунду делает там какую-то работу.
413.08 416.92 "Анатолий Кулаков" Например, выводит текущее время в лог, что-нибудь
416.92 417.92 "Анатолий Кулаков" такое.
417.92 419.68 "Анатолий Кулаков" И с этим подходом у вас тоже будут проблемы.
419.68 421.52 "Анатолий Кулаков" Ну, как нам сделать, например, чтобы он тикал каждую
421.52 422.52 "Анатолий Кулаков" секунду?
422.52 423.52 "Анатолий Кулаков" Самый банальный способ – это сделать taskDelay.
423.52 427.28 "Анатолий Кулаков" То есть taskDelay одну секунду, все, вы спите, сделали свою
427.28 430.08 "Анатолий Кулаков" работу, потом опять taskDelay, и так в бесконечном цикле,
430.08 431.08 "Анатолий Кулаков" пока вас не заканчивают.
431.08 434.00 "Анатолий Кулаков" В общем, такой примитивный довольно-таки background task,
434.00 435.00 "Анатолий Кулаков" который обычно все пишут.
435.00 438.24 "Анатолий Кулаков" Какие проблемы у нас есть здесь?
438.24 443.12 "Анатолий Кулаков" Ну, во-первых, у нас о том, что он дилейт одну секунду,
443.12 445.12 "Анатолий Кулаков" допустим, он будет дилейт там не одну секунду, а 10
445.12 446.12 "Анатолий Кулаков" секунд.
446.12 447.12 "Анатолий Кулаков" Опять же, что мы будем делать в тестах?
447.12 448.60 "Анатолий Кулаков" Как нам протестировать эту шнягу?
448.60 451.40 "Анатолий Кулаков" Мы же не можем ее просто ждать 10 секунд в тестах.
451.40 454.20 "Анатолий Кулаков" Значит, тесты будут очень длинные.
454.20 458.20 "Анатолий Кулаков" Мы, конечно, можем заинжектить, опять же, вот этот период,
458.20 460.24 "Анатолий Кулаков" когда он спит, то есть sleep time, мы можем заинжектить
460.24 462.72 "Анатолий Кулаков" в конструктор, чтобы его настраивать, и для продакшена
462.72 464.56 "Анатолий Кулаков" там настроить одну секунду, для теста настроить там
464.56 466.40 "Анатолий Кулаков" ноль одну секунду, допустим.
466.40 469.12 "Анатолий Кулаков" Но в целом это довольно сильно нарушает наш дизайн,
469.12 471.16 "Анатолий Кулаков" потому что мы, может быть, не хотим конфигурировать
471.16 472.16 "Анатолий Кулаков" эту штуку.
472.16 474.04 "Анатолий Кулаков" Может, для нас принципиально важно, чтобы это было ровно
474.04 475.84 "Анатолий Кулаков" одна секунда, ни больше, ни меньше, и конфигурировать
475.84 479.60 "Анатолий Кулаков" ему никому не хотим давать, это нарушает наш бизнес-домен,
479.60 480.60 "Анатолий Кулаков" нашу договоренность.
480.60 484.08 "Анатолий Кулаков" Ну, и если мы будем вообще в тестах рассчитывать,
484.08 486.52 "Анатолий Кулаков" что вот мы сейчас ему передадим ноль одну секунду, и мы
486.52 489.96 "Анатолий Кулаков" поспим, сделаем sleep на ноль две секунды, то как раз
489.96 493.64 "Анатолий Кулаков" из-за этого и начнутся вот эти мигающие тесты, потому
493.64 497.72 "Анатолий Кулаков" что на самом деле вот эта регулярность ноль одна
497.72 500.72 "Анатолий Кулаков" секунды или ноль две секунды, она не гарантирована сто
500.72 501.72 "Анатолий Кулаков" процентов.
501.72 504.18 "Анатолий Кулаков" И на CI-машине, которая очень сильно занята, у нее много
504.18 507.64 "Анатолий Кулаков" агентов, мало процессоров, мало памяти, это время может
507.64 509.36 "Анатолий Кулаков" немножко затянуться, то есть ваш процессор могут
509.36 511.92 "Анатолий Кулаков" немножко отложить, и в этот момент как раз вот мигающий
511.92 514.76 "Анатолий Кулаков" тест станет красненьким, потому что он там одну какую-то
514.76 518.44 "Анатолий Кулаков" миллисекунду, данный поток не получил квант, и мы не
518.44 521.80 "Анатолий Кулаков" дождались, мы не дождались сакцессного ассерта на
521.80 522.80 "Анатолий Кулаков" наш тест.
522.80 526.48 "Анатолий Кулаков" В общем, из-за этого как раз тесты бывают мигающими,
526.48 528.88 "Анатолий Кулаков" и из-за того, что мы вообще используем в тестах sleep,
528.88 531.48 "Анатолий Кулаков" за это надо руки отдельно отрубать, тесты становятся
531.48 532.48 "Анатолий Кулаков" очень медленными.
532.48 536.56 "Анатолий Кулаков" Если у вас как бы одна бабка рубль, а сто бабок – это
536.56 537.56 "Анатолий Кулаков" уже сто рублей.
537.56 539.84 "Анатолий Кулаков" Если вы каждое тесто будете писать таким способом,
539.84 542.20 "Анатолий Кулаков" то постепенно у вас этот sleep накапает на довольно
542.20 544.16 "Анатолий Кулаков" существенные секунды.
544.16 547.00 "Анатолий Кулаков" Вот поэтому так делать вообще нехорошо.
547.00 548.40 "Анатолий Кулаков" Что же нам делать?
548.40 550.12 "Анатолий Кулаков" Безвыходное какое-то положение.
550.12 554.36 "Анатолий Кулаков" А вот тут появляется спаситель всех нас, это time-провайдер.
554.36 559.28 "Анатолий Кулаков" Абстракция, которая введена в .NET 8, и она предлагает
559.28 562.16 "Анатолий Кулаков" нам альтернативный способ решения обоих этих проблем,
562.16 563.16 "Анатолий Кулаков" которые мы рассмотрели.
563.16 566.36 "Анатолий Кулаков" Что у нее есть?
566.36 571.00 "Анатолий Кулаков" В принципе, вся вот эта абстракция, она не нова,
571.00 574.20 "Анатолий Кулаков" она довольно давно существует в мире, и всегда, когда людям
574.20 576.80 "Анатолий Кулаков" нужно было тестировать время, они заводили какой-то
576.80 579.72 "Анатолий Кулаков" интерфейс, который обычно назывался iClock, iSystemClock,
579.72 580.72 "Анатолий Кулаков" iDataTimeProvider.
580.72 584.68 "Анатолий Кулаков" Я думаю, каждый из вас сталкивался о ваших как-нибудь корпоративных
584.68 588.24 "Анатолий Кулаков" приложениях с этим интерфейсом, или даже в SPNET недавно был
588.24 592.36 "Анатолий Кулаков" интерфейс iSystemClock, который как раз в 8 задеприкетили
592.36 596.12 "Анатолий Кулаков" из-за выхода вот этого нового интерфейса.
596.12 599.28 "Анатолий Кулаков" Прелесть всех тех интерфейсов, которые были раньше, состояла
599.28 602.40 "Анатолий Кулаков" в том, что его можно было записать одной строчкой.
602.40 605.20 "Анатолий Кулаков" Это интерфейс, допустим, iClock с одним-единственным
605.20 609.24 "Анатолий Кулаков" свойством – UTCNow, который возвращает DataTime или DataTimeOffset
609.24 611.80 "Анатолий Кулаков" в зависимости от договоренности вашей компании.
611.80 612.80 "Анатолий Кулаков" И все.
612.80 616.28 "Анатолий Кулаков" Он прекрасный, он маленький, он понятный, вы его инжектируете
616.28 618.92 "Анатолий Кулаков" в конструктор и решаете практически все проблемы,
618.92 619.92 "Анатолий Кулаков" которые мы озвучили выше.
619.92 625.80 "Анатолий Кулаков" Новый же абстрактный класс DataTimeProvider немножко побольше,
625.80 627.96 "Анатолий Кулаков" чем вот этот интерфейс из одного метода.
627.96 632.64 "Анатолий Кулаков" У него три свойства, шесть методов, он умеет сравнивать
632.64 636.72 "Анатолий Кулаков" таймстемпы, он умеет создавать таймеры, и кажется, это
636.72 639.48 "Анатолий Кулаков" все, что это какой-то большой оверкил, что если раньше
639.48 642.80 "Анатолий Кулаков" мы наши проблемы решали с помощью одного свойства,
642.80 647.36 "Анатолий Кулаков" то теперь у нас нужен класс, нужно абстрактный класс
647.36 650.36 "Анатолий Кулаков" с десятком примерно мемберов, чтобы решить то же самое.
650.36 656.12 "Анатолий Кулаков" И это не только оверкил по строчкам, одна строчка
656.12 659.84 "Анатолий Кулаков" вместо десяти строчек, это кажется, что еще оверкил
659.84 660.84 "Анатолий Кулаков" по концепциям.
660.84 663.76 "Анатолий Кулаков" Т.е. если у нас раньше таймер отвечал только за время,
663.76 666.00 "Анатолий Кулаков" то сейчас он умеет времена сравнивать, он умеет их
666.00 669.38 "Анатолий Кулаков" конвертить в ланги, он умеет создавать таймеры, он умеет
669.38 672.32 "Анатолий Кулаков" вычислять какие-то дифы, т.е. в него засунули абсолютно
672.32 678.80 "Анатолий Кулаков" все, где можно хоть как-то упомянуть тайм или какой-нибудь
678.80 679.80 "Анатолий Кулаков" таймер.
679.80 682.40 "Анатолий Кулаков" Кажется, что просто все, что там скопилось, все
682.40 687.88 "Анатолий Кулаков" баги, какие были, люди решили как бы зарезолвить с помощью
687.88 688.88 "Анатолий Кулаков" этого нового интерфейса.
688.88 693.92 "Анатолий Кулаков" Но, как утверждает автор, на это были причины.
693.92 696.96 "Анатолий Кулаков" Давайте немножко ближе рассмотрим причины.
696.96 701.88 "Анатолий Кулаков" Что наш старый метод из одной строчки не мог делать?
701.88 707.80 "Анатолий Кулаков" Во-первых, он не мог реализовать неявные зависимости от
707.80 711.52 "Анатолий Кулаков" времени в стандартных PCL-классах, например, то же самое вспомним
711.52 713.76 "Анатолий Кулаков" наш таск дилей, который у нас в бэкграунд джобе
713.76 715.12 "Анатолий Кулаков" ждал одну секунду.
715.12 718.32 "Анатолий Кулаков" Вот как его заставить ждать не одну секунду, а то время,
718.32 723.16 "Анатолий Кулаков" которое мы скажем, и при этом внутри никаким образом
723.16 727.28 "Анатолий Кулаков" его не переписывая, т.е. на самом деле у него внутри
727.28 729.68 "Анатолий Кулаков" естественно используется зависимость неявная от
729.68 730.68 "Анатолий Кулаков" даты и времени.
730.68 735.12 "Анатолий Кулаков" Он сравнивает разницу между двумя временами, и для этого
735.12 737.80 "Анатолий Кулаков" ему как раз нужен UTC now.
737.80 740.88 "Анатолий Кулаков" И стандартный iClock не мог этого предоставить, не
740.88 741.88 "Анатолий Кулаков" мог этого обеспечить.
741.88 744.28 "Анатолий Кулаков" Он решал только первую проблему, которую мы решали с тем,
744.28 747.60 "Анатолий Кулаков" что в конструкторе нам нужно было передать текущее
747.60 749.76 "Анатолий Кулаков" датовремя для того, чтобы выяснить, заэкспарился
749.76 751.56 "Анатолий Кулаков" тикет или не заэкспарился.
751.56 752.56 "Анатолий Кулаков" Вот эту проблему он прекрасно решал.
752.56 754.48 "Анатолий Кулаков" Если мы же опускаемся до системных классов типа
754.48 758.04 "Анатолий Кулаков" таск дилеев, то здесь, к сожалению, он нам уже никак
758.04 759.04 "Анатолий Кулаков" не помогает.
759.04 764.08 "Анатолий Кулаков" И одна из самых главных методов, которые есть в
764.08 766.52 "Анатолий Кулаков" новом тайм-провайдере, это как раз метод, который
766.52 767.52 "Анатолий Кулаков" называется create timer.
767.52 771.16 "Анатолий Кулаков" И вот этот create timer, он как раз таки вводит новую абстракцию
771.16 774.72 "Анатолий Кулаков" timer, которая неявно будет использоваться внутри
774.72 777.88 "Анатолий Кулаков" всех таймеров, которые есть в фреймворке.
777.88 780.44 "Анатолий Кулаков" В частности, внутри таск дилея.
780.44 784.60 "Анатолий Кулаков" Для того, чтобы таск дилей заиспользовал этот новый
784.60 789.40 "Анатолий Кулаков" create timer, добавили несколько оверайдов для дилея.
789.40 793.08 "Анатолий Кулаков" Если раньше таск дилея принимал просто таймспан,
793.08 795.08 "Анатолий Кулаков" то есть время, которое нужно подождать, то теперь ему
795.08 797.64 "Анатолий Кулаков" добавился второй параметр, который называется тайм-провайдер.
797.64 800.52 "Анатолий Кулаков" То есть вы вот этот тайм-провайдер, который обычно получается
800.52 802.76 "Анатолий Кулаков" из конструкторов, засовываете в дилей.
802.76 806.00 "Анатолий Кулаков" И этот дилей уже начинает таймер использовать не
806.00 810.24 "Анатолий Кулаков" свой собственный на текущих временах системных, а тот,
810.24 811.24 "Анатолий Кулаков" который ему выдаст тайм-провайдер.
811.24 813.36 "Анатолий Кулаков" Соответственно, мы можем его в будущем замокать
813.36 815.60 "Анатолий Кулаков" и каким-то образом протестировать.
815.60 819.00 "Анатолий Кулаков" Вот такие перегрузки появились не только у дилея, появился
819.00 823.12 "Анатолий Кулаков" у таск wait_async и у некоторых других методов, которые
823.12 825.56 "Анатолий Кулаков" позволяют нам задать какое-то время, которое мы хотим
825.56 826.56 "Анатолий Кулаков" ждать на таймерах.
826.56 828.12 "Анатолий Кулаков" Это очень хорошо.
828.12 832.32 "Анатолий Кулаков" В принципе, вот такой хак, такой подобный интерфейс,
832.32 834.68 "Анатолий Кулаков" такой подобный инжект помогает нам решить задачу номер
834.68 838.52 "Анатолий Кулаков" 2, когда мы в бэкграунд-джобе спали ровно одну секунду.
838.52 844.04 "Анатолий Кулаков" Более того, Microsoft выпустил Microsoft BCL TimeProvider пакет, и
844.04 848.98 "Анатолий Кулаков" этот пакет бэкпортирует вот эту концепцию с тайм-провайдером
848.98 853.48 "Анатолий Кулаков" обратно в .NET стандарт 2.0 и, соответственно, в .NET
853.48 854.48 "Анатолий Кулаков" Framework.
854.48 856.72 "Анатолий Кулаков" То есть, там тоже появляются тайм-провайдеры, там тоже
856.72 862.88 "Анатолий Кулаков" появляются методы дополнительной override у дилеев и таймеры,
862.88 863.88 "Анатолий Кулаков" и вот это все.
863.88 866.00 "Анатолий Кулаков" Поэтому, если кому-то нужно, то, в принципе, можно пользоваться
866.00 868.20 "Анатолий Кулаков" и в старых фреймворках, поставив дополнительный
868.20 869.44 "Анатолий Кулаков" пакет.
869.44 871.68 "Анатолий Кулаков" Теперь вернемся к нашей главной цели, для чего
871.68 873.44 "Анатолий Кулаков" все это водило, для тестирования.
873.44 877.48 "Анатолий Кулаков" Здесь тоже Microsoft подсуетился и создал новый пакет, который
877.48 881.18 "Анатолий Кулаков" называется Microsoft Extension TimeProvider Testing, специально для того,
881.18 884.54 "Анатолий Кулаков" чтобы удобно было тестировать вот эти наши такие вот случаи.
884.54 888.38 "Анатолий Кулаков" В этом пакете лежат буквально пару классиков, один из
888.38 890.22 "Анатолий Кулаков" которых – Fake TimeProvider.
890.22 893.66 "Анатолий Кулаков" Это тайм-провайдер, который позволяет вам контролировать
893.66 896.50 "Анатолий Кулаков" то время, которое сейчас существует в вашей системе
896.50 897.50 "Анатолий Кулаков" для тестов.
897.50 901.70 "Анатолий Кулаков" В общем, этот фейк-провайдер, естественно, реализует
901.70 904.42 "Анатолий Кулаков" обычный тайм-провайдер и предоставляет множество
904.42 905.86 "Анатолий Кулаков" интересных методов.
905.86 911.40 "Анатолий Кулаков" С помощью него вы можете переводить время, естественно,
911.40 913.58 "Анатолий Кулаков" контролировать таймеры, задавать, когда они будут
913.58 914.58 "Анатолий Кулаков" триггериться.
914.58 917.58 "Анатолий Кулаков" В общем, все то, что вы ожидаете увидеть от Mocha TimeProvider.
917.58 919.66 "Анатолий Кулаков" Также с помощью него вы можете контролировать,
919.66 921.82 "Анатолий Кулаков" например, тайм-зоны, что уже не так очевидно и многим
921.82 924.54 "Анатолий Кулаков" тоже нужно протестировать, как приложение ведет себя
924.54 927.68 "Анатолий Кулаков" в зависимости от тайм-зоны или от смены поясов или
927.68 928.68 "Анатолий Кулаков" еще чего-то.
928.68 930.74 "Анатолий Кулаков" В общем, все это данная штука покрывает.
930.74 933.72 "Анатолий Кулаков" В общем, специальный тестовый проект, с которым вам будет
933.72 934.72 "Анатолий Кулаков" еще удобнее.
934.72 941.80 "Анатолий Кулаков" Вот такую вели классики, потом написали к ним прекрасный
941.80 947.42 "Анатолий Кулаков" тестовый фрейворк, не забыли учесть таймеры и не забыли
947.42 950.70 "Анатолий Кулаков" учесть стандартную реализацию нашего iClock.
950.70 953.96 "Анатолий Кулаков" Кажется, что мы теперь все заживем, теперь время
953.96 957.50 "Анатолий Кулаков" будет гораздо легче и прекраснее.
957.50 960.30 "Игорь Лабутин" Осталось только переписать все на эту новую абстракцию,
960.30 965.16 "Игорь Лабутин" для своей миллионы тестов, ну ладно, не миллионы, тысячи.
965.16 966.16 "Анатолий Кулаков" В принципе, да.
966.16 970.44 "Анатолий Кулаков" И для начала можно начать с адаптера своего интерфейса,
970.44 974.24 "Анатолий Кулаков" который просто-напросто врапит или директит все
974.24 975.24 "Анатолий Кулаков" вызовы на этот.
975.24 976.24 "Игорь Лабутин" Допустим.
976.24 978.90 "Игорь Лабутин" Ну, кстати, да, если у вас уже все написано на вашем
978.90 981.76 "Игорь Лабутин" этом интерфейсе, то да, а если без него, то срочно
981.76 984.20 "Игорь Лабутин" меняйте ваши тазы, делая их в тестах на хотя бы вот
984.20 985.20 "Игорь Лабутин" эту штуку.
985.20 987.32 "Игорь Лабутин" А для этого вам придется переехать на ДотаНет 8.
987.32 990.30 "Анатолий Кулаков" Ну, вот нет, потому что теперь в стандарт 2 бэкпортировано.
990.30 991.30 "Игорь Лабутин" Да-да-да, окей.
991.30 994.38 "Анатолий Кулаков" Берешь и в текущем вашем ДотаНет фреймворке 4.5 или
994.38 997.50 "Анатолий Кулаков" кто там у вас есть, пожалуйста, езжай в здоровье.
997.50 1000.60 "Игорь Лабутин" 4.6.1 или лучше 4.6.2, это минимум, который нормально совместим
1000.60 1002.02 "Игорь Лабутин" с стандартом 2.0.
1002.02 1004.30 "Игорь Лабутин" Да, лучше 4.6.2.
1004.30 1007.74 "Анатолий Кулаков" Слушай, ну вот все равно, даже после всех этих объяснений
1007.74 1010.10 "Анатолий Кулаков" я абсолютно не согласен с проектировщиками Microsoft,
1010.10 1011.10 "Анатолий Кулаков" что они там намудрили.
1011.10 1014.70 "Анатолий Кулаков" Потому что, на самом деле, 99% как бы всех проблем
1014.70 1016.54 "Анатолий Кулаков" с тестированием – это все-таки iClock.
1016.54 1019.46 "Анатолий Кулаков" То есть это реально один единственный проперти,
1019.46 1021.18 "Анатолий Кулаков" который возвращает текущую дату и время.
1021.18 1024.26 "Анатолий Кулаков" В общем, все остальное, вот эти тестирование таймеров,
1024.26 1028.24 "Анатолий Кулаков" еще какая-то глупость, это в лучшем случае 1% всех
1028.24 1029.24 "Анатолий Кулаков" тестов.
1029.24 1031.78 "Анатолий Кулаков" А на моей практике, по-моему, 0%, ни разу мне не захотелось
1031.78 1035.50 "Анатолий Кулаков" протестировать код, который что-то там делал на таймерах.
1035.50 1038.46 "Анатолий Кулаков" Поэтому мне кажется, они сотворили огромную глупость,
1038.46 1040.42 "Анатолий Кулаков" вот смешав, опять же, все вместе, все эти концепции.
1040.42 1044.26 "Игорь Лабутин" Нужно было два интерфейса, создавать один iClock, а другой,
1044.26 1046.22 "Игорь Лабутин" который зависит от него, который про таймеры и таски.
1046.22 1048.66 "Анатолий Кулаков" Да, да, мне тоже кажется, вот на крайний случай мне
1048.66 1050.70 "Анатолий Кулаков" нужен iClock, все остальное мне вообще не нужно.
1050.70 1053.42 "Анатолий Кулаков" И если вдруг он мне не понадобился раз в жизни,
1053.42 1055.90 "Анатолий Кулаков" я бы не обломался заинжектировать второй интерфейс, давайте
1055.90 1059.58 "Анатолий Кулаков" мне второй iTimeProvider, который там с таймерами, с таймзонами,
1059.58 1061.82 "Анатолий Кулаков" с лонгами, с компараторами, с чем угодно.
1061.82 1064.78 "Анатолий Кулаков" В общем, но в большинстве случаев мне вот эта вот
1064.78 1065.78 "Анатолий Кулаков" лобуда не нужна.
1065.78 1068.70 "Анатолий Кулаков" И вот, не знаю, может быть, неплохо было бы, если бы
1068.70 1070.66 "Анатолий Кулаков" они ввели туда дополнительный интерфейс, например, и
1070.66 1073.70 "Анатолий Кулаков" пронаследовали бы таймпровайдер от него, от iClock, который
1073.70 1075.10 "Анатолий Кулаков" был бы одно единственное свойство.
1075.10 1077.38 "Анатолий Кулаков" И мы могли бы инжектировать и маленький интерфейсик
1077.38 1079.38 "Анатолий Кулаков" и большой, если тебе уж нас совсем нужно.
1079.38 1085.30 "Игорь Лабутин" Ну, скажем так, я сейчас в некоторых чатах комьюнити
1085.30 1091.50 "Игорь Лабутин" разных читаю всякие обсуждения того, как Майкрософт так
1091.50 1093.90 "Игорь Лабутин" или иначе добавляет всякие разные опишки, не только
1093.90 1095.86 "Игорь Лабутин" про таймпровайдер, а вообще про разные.
1095.86 1099.90 "Игорь Лабутин" И про многие опишки есть разговор, что ну как-то
1099.90 1104.86 "Игорь Лабутин" бывает либо переусложнено, либо очень, есть такое хорошее
1104.86 1109.32 "Игорь Лабутин" русское слово opinionated, как это по-русски нормально
1109.32 1110.32 "Игорь Лабутин" сказать, я не знаю.
1110.32 1111.90 "Игорь Лабутин" А теперь рассказывай, да, что оно значит.
1111.90 1114.88 "Игорь Лабутин" Да, ну в смысле, что они как-то какой-то use case видят
1114.88 1117.38 "Игорь Лабутин" для себя, кто-то к ним пришел, возможно, ажур, возможно,
1117.38 1119.86 "Игорь Лабутин" кто-то еще, возможно, какой-то большой кастомер, возможно,
1119.86 1125.02 "Игорь Лабутин" они сами у себя в BCL, в рантайме, в каких-то в SP-нете, в EF-коре
1125.02 1127.46 "Игорь Лабутин" страдают от чего-то и вот строго под них делают какую-то
1127.46 1131.06 "Игорь Лабутин" абстракцию, не думая, насколько она будет простой для всех
1131.06 1132.06 "Игорь Лабутин" остальных.
1132.06 1135.22 "Анатолий Кулаков" Ну и я напомню, что когда эту штуку обсуждали, там
1135.22 1137.46 "Анатолий Кулаков" и Джон Скитт приходил, и Марк Симон приходил, и кто
1137.46 1140.30 "Анатолий Кулаков" только не приходил, объясняя им, что делают они глупости,
1140.30 1142.90 "Анатолий Кулаков" все равно, к сожалению, вот та практически первая
1142.90 1145.42 "Анатолий Кулаков" реализация со всеми этими глупостями дошла до релиза.
1145.42 1149.08 "Игорь Лабутин" Вот, и именно потому, что нет какой-то такой, ну не
1149.08 1155.22 "Игорь Лабутин" сказать адекватной, а какой-то конструктивной в смысле
1155.22 1158.90 "Игорь Лабутин" реакции, которая, видно, что они приняли это все
1158.90 1160.58 "Игорь Лабутин" во внимание и учли.
1160.58 1162.86 "Игорь Лабутин" Вот ее как-то не видно, это не единственный случай
1162.86 1167.54 "Игорь Лабутин" такой, ну непонятно, непонятно, почему так происходит.
1167.54 1171.82 "Игорь Лабутин" Ну, они монополисты, единственный производитель дот-нета,
1171.82 1172.82 "Игорь Лабутин" поэтому могут себе позволить.
1172.82 1177.06 "Анатолий Кулаков" Ну, к сожалению, да, поэтому если у вас там есть шанс
1177.06 1180.10 "Анатолий Кулаков" форкнуть фреймворк и развивать его параллельно, хотя нет,
1180.10 1182.46 "Анатолий Кулаков" это нам даст слишком много разных версий, под которые
1182.46 1184.34 "Анатолий Кулаков" надо будет совместимости делать.
1184.34 1186.70 "Анатолий Кулаков" Лучше рантайм, лучше рантайм, развивайте свой.
1186.70 1191.22 "Игорь Лабутин" Не, ну фреймворк тоже можно, но тогда значит нужно делать
1191.22 1195.78 "Игорь Лабутин" как с Джавой, где есть, соответственно, этот самый tck, который полный
1195.78 1198.10 "Игорь Лабутин" большой комплект тестов для совместимости, для
1198.10 1200.86 "Игорь Лабутин" проверки того, что то поделие, которое вы сделали, является
1200.86 1201.86 "Игорь Лабутин" Джавой.
1201.86 1204.58 "Анатолий Кулаков" Ну да, ну а tck тебе, скорее всего, только Микрософт
1204.58 1206.22 "Анатолий Кулаков" напишет, не будешь ты его рядом же писать.
1206.22 1207.22 "Игорь Лабутин" Ну.
1207.22 1210.62 "Анатолий Кулаков" Оно его писать не будет, поэтому без шансов вообще.
1210.62 1211.62 "Анатолий Кулаков" Это правда, да.
1211.62 1213.90 "Анатолий Кулаков" Ладно, погнали, это вся первая тема, нам еще надо много
1213.90 1215.50 "Анатолий Кулаков" обсудить, не будем сильно задерживаться.
1215.50 1216.50 "Игорь Лабутин" Ох, да, давай, пойдем дальше.
1216.50 1218.38 "Игорь Лабутин" Дальше у нас тема, которую мы, собственно, обещали
1218.38 1223.06 "Игорь Лабутин" в прошлый раз, это asynchronous programming от Дэвида Фаулера,
1223.06 1226.90 "Игорь Лабутин" это очень древний, это даже не называется статья, это
1226.90 1231.06 "Игорь Лабутин" маркдаун-документик в гисте где-то у Дэвида Фаулера,
1231.06 1233.62 "Игорь Лабутин" он давно не пишет именно прям в блог, он это гисты
1233.62 1234.62 "Игорь Лабутин" у себя.
1234.62 1237.66 "Анатолий Кулаков" Ну да, но часто пишет и в Твиттере, и гисты, у него
1237.66 1239.26 "Анатолий Кулаков" свой способ блогирования.
1239.26 1241.70 "Анатолий Кулаков" Кстати, спасибо всем тем, кто голосовал за эту темку,
1241.70 1243.74 "Анатолий Кулаков" которые попросили нас ее сделать, в общем, мы вас
1243.74 1244.74 "Анатолий Кулаков" услышали.
1244.74 1246.70 "Игорь Лабутин" Да, и, кстати, ну ладно, здесь, кстати, это не гист, все-таки
1246.70 1249.18 "Игорь Лабутин" это прям нормальная его полноценная репозитория
1249.18 1250.18 "Игорь Лабутин" спиноткордиагностикс.
1250.18 1252.86 "Игорь Лабутин" Он из тех времен, когда ему было еще не лень хотя
1252.86 1255.18 "Игорь Лабутин" бы в репозиторию складывать, сейчас он обленился и складывает
1255.18 1256.18 "Игорь Лабутин" все в гисты.
1256.18 1258.82 "Игорь Лабутин" Ну да ладно, значит, в чем суть?
1258.82 1263.94 "Игорь Лабутин" Суть в том, что работая с осинками, осинки у нас
1263.94 1267.34 "Игорь Лабутин" давно с нами уже, с какого дотнета-то?
1267.34 1270.22 "Игорь Лабутин" Ну с древнего какого-то дотнета, я уже даже не помню,
1270.22 1271.22 "Анатолий Кулаков" с какого.
1271.22 1274.06 "Анатолий Кулаков" Ну, просто так долго, что почти всегда.
1274.06 1277.66 "Игорь Лабутин" Да, и с ними есть некоторое количество проблем, даже
1277.66 1280.38 "Игорь Лабутин" не то, что проблем, они в среднем работают хорошо,
1280.38 1282.96 "Игорь Лабутин" но есть определенное количество особенностей их использования
1282.96 1285.90 "Игорь Лабутин" корнер-кейсов, которые иногда порождают странный
1285.90 1288.78 "Игорь Лабутин" код или порождают, возможно, небезопасный или неэффективный
1288.78 1289.78 "Игорь Лабутин" код.
1289.78 1292.82 "Игорь Лабутин" И корнер-кейсы, про которые нужно просто знать и знать,
1292.82 1295.98 "Игорь Лабутин" как с ними бороться и какие workaround или какие наоборот
1295.98 1298.74 "Игорь Лабутин" best practices есть для того, чтобы такие места писать
1298.74 1299.74 "Игорь Лабутин" правильно.
1299.74 1303.34 "Игорь Лабутин" И статья от Дэвида Фаулера — это как раз попытка выдать
1303.34 1308.14 "Игорь Лабутин" какие-то guidance, то, что называют guidance, да, то есть рекомендации
1308.14 1312.70 "Игорь Лабутин" с примерами плохого и хорошего кода от человека, который
1312.70 1314.78 "Игорь Лабутин" на самом деле довольно много занимается сп-надкором,
1314.78 1316.90 "Игорь Лабутин" знает довольно много всего про хинковейты, потому
1316.90 1318.72 "Игорь Лабутин" что внутри они, понятно, используются в огромном
1318.72 1322.06 "Игорь Лабутин" количестве в сп-надкоре, плюс он близко знаком с
1322.06 1326.02 "Игорь Лабутин" командой, да, командами внутри Майкрософта, и поэтому
1326.02 1329.66 "Игорь Лабутин" у него явно есть куча рекомендаций на эту тему.
1329.66 1331.90 "Игорь Лабутин" И давайте пойдем просто по порядку.
1331.90 1338.06 "Игорь Лабутин" Первая штука — это что async — это штука, которую
1338.06 1340.74 "Игорь Лабутин" будет затрагивать весь ваш код, у него это называется
1340.74 1341.74 "Игорь Лабутин" asyncIsViral.
1341.74 1347.02 "Игорь Лабутин" Если у вас есть async метод, то в общем-то все методы,
1347.02 1350.66 "Игорь Лабутин" которые вызывают этот метод, должны быть тоже асинхронными,
1350.66 1351.66 "Игорь Лабутин" по-другому нельзя.
1351.66 1356.98 "Игорь Лабутин" То есть и проблема в том, что из-за особенностей
1356.98 1362.26 "Игорь Лабутин" того, как это все работает, если у вас где-то есть, допустим,
1362.26 1365.62 "Игорь Лабутин" синхронный метод, который как-то хочет вызвать асинхронный,
1365.62 1369.98 "Игорь Лабутин" делает это через какие-нибудь там .result или .getAwaiter, .getResult,
1369.98 1373.34 "Игорь Лабутин" то итоговый результат внезапно может оказаться хуже, чем
1373.34 1375.74 "Игорь Лабутин" если бы вы просто повызывали синхронные версии тех же
1375.74 1378.50 "Игорь Лабутин" методов, если они, конечно, есть.
1378.50 1381.46 "Игорь Лабутин" Бывает такое, что их нету, но если вам нужно что-то
1381.46 1383.82 "Игорь Лабутин" сделать из синхронного метода, и у вас есть возможность
1383.82 1386.90 "Игорь Лабутин" вызвать синхронный метод, вызовите синхронный метод.
1386.90 1389.34 "Игорь Лабутин" Иногда это даже проще и быстрее будет работать.
1389.34 1393.96 "Анатолий Кулаков" Мне кажется, они остались только у каких-нибудь старых
1393.96 1397.22 "Анатолий Кулаков" интерфейсов, которые были еще до появления асинхронченной.
1397.22 1399.90 "Анатолий Кулаков" Любой новый интерфейс, который появляется асинхронный,
1399.90 1402.62 "Анатолий Кулаков" он обычно не делает соответствующий синхронный метод.
1402.62 1405.78 "Анатолий Кулаков" Может, у Microsoft это какое-то исключение, но это довольно
1405.78 1406.78 "Анатолий Кулаков" редко.
1406.78 1408.22 "Игорь Лабутин" Да, как правило, это редко, но бывает.
1408.22 1410.98 "Игорь Лабутин" Мы не все работаем со совсем современным кодом, поэтому
1410.98 1413.34 "Игорь Лабутин" бывает такое, что есть такое.
1413.34 1416.50 "Игорь Лабутин" Но сейчас действительно, наверное, проблемы меньше,
1416.50 1420.70 "Игорь Лабутин" чем она была тогда давно, когда асинки только появлялись.
1420.70 1421.70 "Игорь Лабутин" Вторая штука, async/void.
1421.70 1428.54 "Игорь Лабутин" Это, наверное, одна из двух таких самых сложно, ну часто
1428.54 1431.06 "Игорь Лабутин" обсуждаемых, точнее, вот так вот, скажем, концепций
1431.06 1434.42 "Игорь Лабутин" и проблем в мире асинка.
1434.42 1439.74 "Игорь Лабутин" Первая рекомендация – это не используйте async/void, насколько
1439.74 1440.74 "Игорь Лабутин" можно.
1440.74 1444.82 "Анатолий Кулаков" Вторая рекомендация – не используйте async/void.
1444.82 1447.98 "Игорь Лабутин" Но если вам все-таки зачем-то надо, ну так сложилось,
1447.98 1451.02 "Игорь Лабутин" то лучше как минимум у этого метода сделать его
1451.02 1457.38 "Игорь Лабутин" не async/void, а async/task, то есть пусть он возвращает task,
1457.38 1461.16 "Игорь Лабутин" который будет как минимум приводить, то есть дефолтное
1461.16 1463.78 "Игорь Лабутин" поведение рантайма, это, кстати, мне кажется, менялось,
1463.78 1467.84 "Игорь Лабутин" но если у вас в async/void методе выкинется exception, то у вас
1467.84 1470.98 "Игорь Лабутин" все это дело радостно, раньше, по крайней мере,
1470.98 1471.98 "Игорь Лабутин" крашилось.
1471.98 1473.02 "Игорь Лабутин" Сейчас, может быть, сейчас не крашнется, но все равно
1473.02 1477.06 "Игорь Лабутин" не очень здорово, вы с этим exception вообще ничего не сделаете.
1477.06 1479.70 "Анатолий Кулаков" Да, в каких-то фреймворках приложение просто-напросто
1479.70 1482.30 "Анатолий Кулаков" падало в таких вещах, и вам нужно было там специальный
1482.30 1484.14 "Анатолий Кулаков" глобальный хендлер определить и так далее.
1484.14 1486.66 "Анатолий Кулаков" По-моему, даже, кстати, нельзя было глобальный хендлер,
1486.66 1487.66 "Анатолий Кулаков" в том-то и дело.
1487.66 1488.66 "Анатолий Кулаков" Не, можно, можно.
1488.66 1489.66 "Анатолий Кулаков" Можно было.
1489.66 1490.66 "Анатолий Кулаков" Можно было определить глобальный хендлер, да, там специальный
1490.66 1491.66 "Анатолий Кулаков" хендлер просто есть.
1491.66 1493.62 "Анатолий Кулаков" В task scheduler есть специальный хендлер.
1493.62 1496.28 "Игорь Лабутин" Вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот.
1496.28 1498.40 "Игорь Лабутин" Нет, нет, нет, нет, нет, нет, для async/void это не работало.
1498.40 1500.72 "Игорь Лабутин" Это работало только для async/tasks, то есть если у тебя
1500.72 1503.80 "Игорь Лабутин" появился task, в котором лежит exception, но ты его не
1503.80 1507.44 "Игорь Лабутин" заэвейтил и не узнал, что там лежит exception, вот при
1507.44 1511.64 "Игорь Лабутин" диспоузе такого таска, ну, приложение падало, понимая,
1511.64 1515.00 "Игорь Лабутин" что у тебя, э-э-эй, у тебя там вот это вот.
1515.00 1517.40 "Игорь Лабутин" Возможно, возможно, с async/void оно падало сразу, потому
1517.40 1519.36 "Игорь Лабутин" что там не было task, а куда сложить результат.
1519.36 1523.60 "Анатолий Кулаков" Как раз в task scheduler статический делегат был, ему не нужно
1523.60 1524.60 "Анатолий Кулаков" был task.
1524.60 1527.64 "Анатолий Кулаков" Ну, в любом случае, смотри, а мне ещё понравилось, знаешь,
1527.64 1530.08 "Анатолий Кулаков" когда в этот, это поведение изменили, ну, типа в будущих
1530.08 1533.28 "Анатолий Кулаков" версиях оно не падает, оно там просто или проглатывается
1533.28 1535.92 "Анатолий Кулаков" исключение, или проглатывается лог, или пишется куда-то
1535.92 1538.48 "Анатолий Кулаков" в системы, не суть важна, там ещё добавили специальный
1538.48 1542.20 "Анатолий Кулаков" флажок, в котором ты можешь включить и вернуть обратно,
1542.20 1543.48 "Анатолий Кулаков" чтобы приложение падало.
1543.48 1545.08 "Анатолий Кулаков" Интересно, да, сколько людей вернуло.
1545.08 1548.40 "Игорь Лабутин" Ну, то есть самый простой, самый, не только что простой,
1548.40 1550.16 "Игорь Лабутин" самый, наверное, правильный способ, если вам всё-таки
1550.16 1554.36 "Игорь Лабутин" нужен какой-то такой async/void стайл штука, верните task
1554.36 1557.12 "Игорь Лабутин" и на нём вызовите, напишите ваш кастомный метод, мы
1557.12 1559.08 "Игорь Лабутин" вам в прошлом выпуске уже про это говорили, какой-нибудь
1559.08 1562.68 "Игорь Лабутин" там под названием fire and forget, где вы зарегистрируете
1562.68 1565.00 "Игорь Лабутин" на этот task какой-нибудь continuation, или просто его
1565.00 1568.64 "Игорь Лабутин" за, ну да, зарегистрируете continuation, в котором хотя
1568.64 1570.72 "Игорь Лабутин" бы залогируете, если что-то пошло не так.
1570.72 1575.40 "Игорь Лабутин" Вот, это единственный способ хоть как-то побороться.
1575.40 1579.20 "Игорь Лабутин" Дальше, следующая рекомендация, она довольно простая, мне
1579.20 1581.52 "Игорь Лабутин" кажется, что уже почти все это выучили, или даже
1581.52 1585.48 "Игорь Лабутин" вообще все, используйте task.from_result вместо того, чтобы
1585.48 1587.84 "Игорь Лабутин" сделать task.run с какой-нибудь очень простым, или даже
1587.84 1592.48 "Игорь Лабутин" с константой выражением, было такое на заре рождения
1592.48 1594.60 "Игорь Лабутин" task, сейчас, мне кажется, с этим попроще, task.from_result
1594.60 1595.60 "Игорь Лабутин" выучили все.
1595.60 1599.36 "Игорь Лабутин" Единственное, это приведёт всё равно к аллокации самого
1599.36 1602.92 "Игорь Лабутин" task, даже если вы константу возвращаете, если вам совсем
1602.92 1606.52 "Игорь Лабутин" не в моготу аллоцировать task, используйте new_value_task.
1606.52 1609.44 "Игорь Лабутин" Для value_task, по-моему, нет функции типа from_result, его
1609.44 1613.84 "Игорь Лабутин" нужно явно создать через new_value_task, но оно тоже работает
1613.84 1615.20 "Игорь Лабутин" и тогда даже аллокаций не будет.
1615.20 1620.72 "Анатолий Кулаков" Есть же ещё value_task_pull, если совсем плохо всё.
1620.72 1625.44 "Игорь Лабутин" Ой, там сложно, там есть value_task_pull_source, дальше там
1625.44 1628.76 "Игорь Лабутин" можно пулить, короче, да, это мы уходим уже совсем
1628.76 1629.76 "Игорь Лабутин" в дебри.
1629.76 1632.76 "Игорь Лабутин" Если вам это надо, да, вы, скорее всего, знаете лучше
1632.76 1633.76 "Игорь Лабутин" нас.
1633.76 1637.20 "Игорь Лабутин" Лучше, наверное, не надо, то есть это очень специфический
1637.20 1639.68 "Игорь Лабутин" случай, вероятно, только в библиотечном каком-нибудь
1639.68 1643.28 "Игорь Лабутин" коде, очень high-performance и вот это всё.
1643.28 1647.04 "Игорь Лабутин" Дальше, очевидная рекомендация не использовать task_run для
1647.04 1649.44 "Игорь Лабутин" длинных, долгих методов.
1649.44 1652.16 "Игорь Лабутин" В статье написано, что долгие — это в смысле какой-то
1652.16 1654.12 "Игорь Лабутин" бесконечный цикл, который вечно продлевает очередь
1654.12 1656.04 "Игорь Лабутин" на время работы приложения, потому что вы тем самым
1656.04 1661.52 "Игорь Лабутин" забираете один thread из thread_pull, ну и тем самым thread_pull считает,
1661.52 1663.84 "Игорь Лабутин" что у него что-то забрали всё-таки, а thread всё ещё
1663.84 1664.84 "Игорь Лабутин" считается thread_pull.
1664.84 1666.88 "Игорь Лабутин" То есть если вы точно знаете, что thread будет жить долго
1666.88 1671.32 "Игорь Лабутин" и всё время приложения, ну, родите отдельный, вот,
1671.32 1673.40 "Игорь Лабутин" прямо через new thread вполне можно.
1673.40 1679.44 "Игорь Лабутин" Либо можно через task с опцией task_creation_options_long_running, это
1679.44 1681.48 "Игорь Лабутин" не гарантирует, что будет отдельный thread, но это, по
1681.48 1684.32 "Игорь Лабутин" крайней мере, хинт для runtime про то, что мы точно
1684.32 1686.76 "Игорь Лабутин" знаем, что он будет долго исполняться и, скорее всего,
1686.76 1689.12 "Игорь Лабутин" мы успеем всё-таки создать отдельный thread.
1689.12 1690.12 "Игорь Лабутин" Вот.
1690.12 1692.92 "Игорь Лабутин" Поэтому, ну, такая довольно очевидная тоже рекомендация,
1692.92 1694.80 "Игорь Лабутин" я давно уже не видел таких проблем в коде, так что
1694.80 1695.80 "Игорь Лабутин" нормально.
1695.80 1701.36 "Игорь Лабутин" Следующая штука, тот самый sync_over_async, так называемый,
1701.36 1706.80 "Игорь Лабутин" постарайтесь не использовать task.result и task.wait, то есть синхронные
1706.80 1709.76 "Игорь Лабутин" операции, которые либо синхронно дождутся и вернут
1709.76 1712.24 "Игорь Лабутин" результат — это result, либо просто дождутся completed
1712.24 1715.76 "Игорь Лабутин" task — это wait, потому что вам для этого, по сути,
1715.76 1717.96 "Игорь Лабутин" вы блокируете два thread'а, в смысле, используете два
1717.96 1718.96 "Игорь Лабутин" thread'а.
1718.96 1720.72 "Игорь Лабутин" В одном thread'е будет производиться непосредственная работа,
1720.72 1725.20 "Игорь Лабутин" а в другой thread'е будет заблокирован result'ом или wait'ом, поэтому,
1725.20 1729.24 "Игорь Лабутин" ну, зачем вам два thread'а использовать, плюс, если у вас используются
1729.24 1733.64 "Игорь Лабутин" синхронизационные контексты, то могут быть дедлоки, и
1733.64 1734.64 "Игорь Лабутин" это не очень здорово.
1734.64 1736.92 "Игорь Лабутин" Поэтому будьте внимательны и аккуратны, лучше синхронные
1736.92 1737.92 "Игорь Лабутин" версии не использовать.
1737.92 1744.48 "Игорь Лабутин" И у Fowler написана прекрасная фраза, что нет нормального
1744.48 1748.76 "Игорь Лабутин" хорошего способа синхронно дождаться завершения таски.
1748.76 1752.00 "Игорь Лабутин" Ну, типа, заблокиться синхронно и безопасно, чтобы дождаться
1752.00 1753.00 "Игорь Лабутин" завершения таски.
1753.00 1755.20 "Анатолий Кулаков" Ну, нет его.
1755.20 1757.80 "Анатолий Кулаков" Дождаться асинхронного результата, вот так.
1757.80 1758.80 "Игорь Лабутин" Да.
1758.80 1761.68 "Игорь Лабутин" То есть так или иначе из-за всяких синхронизационных
1761.68 1766.20 "Игорь Лабутин" контекстов и thread'ов и прочего могут быть проблемы с заблокировками.
1766.20 1772.20 "Игорь Лабутин" Дальше, предпочитайте wait вместо continue with, то есть
1772.20 1774.44 "Игорь Лабутин" раньше, когда появились только таски, но не было
1774.44 1776.84 "Игорь Лабутин" async/wait'ов, там понятно, что все писали на continue with'ах.
1776.84 1780.84 "Игорь Лабутин" Ну, все не все, но это была такая интересная методика.
1780.84 1786.08 "Игорь Лабутин" Но, тем не менее, оно похоже, но оно немножко обладает
1786.08 1788.92 "Игорь Лабутин" другой семантикой, потому что continue with никогда не
1788.92 1793.40 "Игорь Лабутин" capture синхронизационный контекст, из-за чего, ну,
1793.40 1795.28 "Игорь Лабутин" там могут быть, то есть если вы просто напишите какую-нибудь
1795.28 1798.44 "Игорь Лабутин" тасочку и в continue with обновление элемента на uident thread'е, оно
1798.44 1799.44 "Игорь Лабутин" не заработает.
1799.44 1804.24 "Игорь Лабутин" Там нужно все через синхронизационный контекст вручную делать,
1804.24 1806.64 "Игорь Лабутин" поэтому если wait, то лучше пользуйтесь wait'ом, continue
1806.64 1807.96 "Игорь Лабутин" with нужен в очень редких случаях.
1807.96 1813.68 "Игорь Лабутин" Так, вот, интересная рекомендация.
1813.68 1816.76 "Игорь Лабутин" Значит, у нас есть такой класс, называется task completion
1816.76 1817.76 "Игорь Лабутин" source.
1817.76 1821.52 "Игорь Лабутин" Он нужен, если вы создаете, собственно, таски, у которых
1821.52 1825.40 "Игорь Лабутин" вы можете вручную регулировать, когда они комплетятся.
1825.40 1827.48 "Игорь Лабутин" То есть, как правило, это нужно, когда у вас есть
1827.48 1833.52 "Игорь Лабутин" операция, вы хотите выставить асинхронно какую-то операцию,
1833.52 1835.96 "Игорь Лабутин" которую вы сами контролируете, и закомплетить или закэнселить
1835.96 1838.60 "Игорь Лабутин" или зафейлить ее в нужный момент времени.
1838.60 1841.68 "Игорь Лабутин" Так вот, рекомендация от Fowler заключается в том, что
1841.68 1845.80 "Игорь Лабутин" создавать такой completion source нужно всегда с опцией
1845.80 1847.28 "Игорь Лабутин" run continuation asynchronously.
1847.28 1850.28 "Игорь Лабутин" В чем фишка?
1850.28 1853.20 "Игорь Лабутин" Фишка в том, что если вы эту опцию не зададите,
1853.20 1857.04 "Игорь Лабутин" то в момент, когда вы вызовете set result у этого класса, что
1857.04 1858.04 "Игорь Лабутин" произойдет?
1858.04 1861.84 "Игорь Лабутин" Вы вызовете set result, у таска проставится, что он completed,
1861.84 1866.08 "Игорь Лабутин" и технически тот код, который сейчас evaded эту таску, может
1866.08 1868.20 "Игорь Лабутин" продолжить исполняться прямо в том же треде, где
1868.20 1870.04 "Игорь Лабутин" вы вызвали set result.
1870.04 1873.56 "Игорь Лабутин" И это может привести к интересным сайд-эффектам,
1873.56 1877.12 "Игорь Лабутин" до самой блокировки, взаимоблокировки, sync-контекст и вот это все.
1877.12 1880.84 "Игорь Лабутин" Поэтому лучше говорить run continuation asynchronously, потому
1880.84 1884.44 "Игорь Лабутин" что тогда ваш тред, в котором вы вызвали set result, не будет
1884.44 1885.44 "Игорь Лабутин" ничего.
1885.44 1887.36 "Игорь Лабутин" Например, это какой-нибудь background-тред, который слушает
1887.36 1889.12 "Игорь Лабутин" какую-нибудь очередь, и вы не хотите, чтобы в этом
1889.12 1891.64 "Игорь Лабутин" треде исполнялся еще какой-то пользовательский код этих
1891.64 1892.64 "Игорь Лабутин" самых continuation.
1892.64 1894.12 "Игорь Лабутин" Зачем вам это?
1894.12 1896.12 "Игорь Лабутин" Вы хотите, чтобы тред пошел дальше слушать какое-нибудь
1896.12 1899.18 "Игорь Лабутин" следующее событие из очереди, например, или обрабатывать
1899.18 1900.18 "Игорь Лабутин" его.
1900.18 1903.24 "Анатолий Кулаков" Да, я как раз тот человек, который узнал об этой веселой
1903.24 1906.24 "Анатолий Кулаков" особенности после трех часов дебага.
1906.24 1909.32 "Анатолий Кулаков" Так что бага страшная, а не полезно знать.
1909.32 1914.52 "Анатолий Кулаков" Даже не бага, а специфика поведения дефолтного, она
1914.52 1915.52 "Анатолий Кулаков" довольно страшная.
1915.52 1917.36 "Анатолий Кулаков" Дебажится довольно плохо, поэтому лучше о ней сразу
1917.36 1918.36 "Анатолий Кулаков" знать.
1918.36 1919.36 "Игорь Лабутин" Да.
1919.36 1923.20 "Игорь Лабутин" Дальше интересная штука, которая довольно, мне кажется,
1923.20 1924.48 "Игорь Лабутин" может часто встречаться.
1924.48 1929.32 "Игорь Лабутин" У нас есть довольно популярный паттерн, это тайм-ауты через
1929.32 1930.32 "Игорь Лабутин" cancellation token.
1930.32 1935.48 "Игорь Лабутин" То есть мы говорим cancellation token source, создаем в нем какой-нибудь
1935.48 1938.84 "Игорь Лабутин" токен, собственно, при создании cancellation token source можно задать
1938.84 1941.96 "Игорь Лабутин" тайм-аут, через который он сам токены проставит
1941.96 1942.96 "Игорь Лабутин" в cancel.
1942.96 1946.72 "Игорь Лабутин" И мы создаем из него токены, cancellation token, которые дальше
1946.72 1948.36 "Игорь Лабутин" отдаем в код.
1948.36 1951.84 "Игорь Лабутин" Так вот такие cancellation token source, если вы у него либо
1951.84 1954.24 "Игорь Лабутин" задали тайм-аут при создании, либо, по-моему, вызвали
1954.24 1956.72 "Игорь Лабутин" метод cancel after, там как-то так, по-моему, можно двумя
1956.72 1960.78 "Игорь Лабутин" способами, то обязательно его нужно диспоузить.
1960.78 1963.80 "Игорь Лабутин" Иначе это утечка памяти, потому что внутри он использует
1963.80 1968.12 "Игорь Лабутин" таймеры, и вы просто будете забивать очередь этих таймеров,
1968.12 1970.24 "Игорь Лабутин" которые уже никогда не исполнятся, по сути, ну
1970.24 1973.28 "Игорь Лабутин" либо исполнятся через ваш тайм-аут, но зачем вам
1973.28 1974.28 "Игорь Лабутин" это?
1974.28 1976.24 "Игорь Лабутин" Вот, поэтому лучше их диспоузить.
1976.24 1979.36 "Игорь Лабутин" Если вы знаете, что вы дождались и тайм-аут не сработал,
1979.36 1981.60 "Игорь Лабутин" то сходите и задиспоузите.
1981.60 1984.28 "Игорь Лабутин" Ну, про cancellation token очевидная рекомендация, если у вас
1984.28 1987.12 "Игорь Лабутин" есть cancellation token и вы вызываете async какой-нибудь метод,
1987.12 1991.70 "Игорь Лабутин" то засуньте в него cancellation token, чтобы была кооперативная
1991.70 1994.56 "Игорь Лабутин" отмена, значит, вниз по стеку.
1994.56 1999.04 "Игорь Лабутин" А вот дальше тоже вокруг cancellation есть большой интересный
1999.04 2001.00 "Игорь Лабутин" паттерн, который часто используется.
2001.00 2003.44 "Игорь Лабутин" Предположим, у вас есть какая-нибудь асинхронная
2003.44 2006.40 "Игорь Лабутин" операция, которая почему-то не принимает cancellation token.
2006.40 2007.40 "Игорь Лабутин" Ну, так сложилось.
2007.40 2011.56 "Игорь Лабутин" Но вам все равно нужно дождаться в рамках определенного
2011.56 2012.56 "Игорь Лабутин" тайм-аута.
2012.56 2013.56 "Игорь Лабутин" Что вы обычно делаете?
2013.56 2017.88 "Игорь Лабутин" Вы создаете тасочку через task delay с нужным тайм-аутом,
2017.88 2020.76 "Игорь Лабутин" создаете тасочку из вашего асинхронной работы, которую
2020.76 2025.52 "Игорь Лабутин" нужно выполнить, и делаете task.vnn, кто первый сработал,
2025.52 2026.52 "Игорь Лабутин" того и тапки.
2026.52 2030.08 "Игорь Лабутин" Если task delay первым сработал, хорошо, значит, у нас тайм-аут.
2030.08 2032.44 "Игорь Лабутин" Если работа сработала, ну, хорошо, значит, работа
2032.44 2033.64 "Игорь Лабутин" завершилась, все прекрасно.
2033.64 2043.04 "Игорь Лабутин" Технически, если у вас не сработала, то есть тут
2043.04 2046.00 "Игорь Лабутин" примерно та же фигня, что и с таймерами, но если у
2046.00 2051.32 "Игорь Лабутин" вас сработал обычный task, то вот этот самый cancellation
2051.32 2056.44 "Игорь Лабутин" token registration, который получился, когда вы вызывали task delay,
2056.44 2060.84 "Игорь Лабутин" он, вообще говоря, утекает, то есть он там будет куда-то
2060.84 2065.72 "Игорь Лабутин" добавлен, в какую-то очередь, не очередь, коллекцию, не
2065.72 2067.44 "Игорь Лабутин" коллекцию, и он технически утекает.
2067.44 2071.56 "Игорь Лабутин" Это очень маленький объектик, но зачем?
2071.56 2075.80 "Игорь Лабутин" Поэтому правильный способ – это не просто создавать
2075.80 2083.00 "Игорь Лабутин" cancellation token, в смысле task delay с каким-то тайм-аутом,
2083.00 2086.48 "Игорь Лабутин" а создавать отдельный cancellation token и говорить
2086.48 2090.76 "Игорь Лабутин" ему register, прям вызывать метод register, он как раз возвращает
2090.76 2094.52 "Игорь Лабутин" этот самый объект cancellation token registration, который нужно
2094.52 2098.08 "Игорь Лабутин" будет dispose-ить обязательно, вот.
2098.08 2100.88 "Игорь Лабутин" Но это все можно забыть, все то, что я сказал, если
2100.88 2103.80 "Игорь Лабутин" вы переехали на 6.net или новее, потому что там есть
2103.80 2107.08 "Игорь Лабутин" замечательный метод, называется task.waitAsync, куда можно просто
2107.08 2109.72 "Игорь Лабутин" передать тайм-аут, и он сам все сделает правильно
2109.72 2110.72 "Игорь Лабутин" внутри.
2110.72 2116.56 "Игорь Лабутин" Так что пользуйтесь лучше task.waitAsync, и не заморачивайтесь.
2116.56 2119.76 "Игорь Лабутин" При работе со стримами, все же, ну как, стримы – это
2119.76 2124.16 "Игорь Лабутин" штамп, потенциальные I/O, все работают, понятно, асинхронно,
2124.16 2128.08 "Игорь Лабутин" там writeAsync, writeAsync, еще что-нибудь, а потом в конце что мы делаем
2128.08 2129.08 "Игорь Лабутин" правильно?
2129.08 2131.60 "Игорь Лабутин" Мы вызываем dispose, потому что все это в юзинге находится,
2131.60 2134.56 "Игорь Лабутин" и тут могут быть проблемы, потому что async, ну он там
2134.56 2137.36 "Игорь Лабутин" что-нибудь забуферизовывал и так далее, потом вы вызываете
2137.36 2141.88 "Игорь Лабутин" синхронный dispose, а синхронный dispose должен, ну что он будет
2141.88 2142.88 "Игорь Лабутин" делать?
2142.88 2143.88 "Игорь Лабутин" Он будет дожидаться, пока все запишется.
2143.88 2146.52 "Игорь Лабутин" А как он будет дожидаться, что все допишется?
2146.52 2149.72 "Игорь Лабутин" Ну по сути, это внутри синхронного метода нужно вызвать или
2149.72 2153.92 "Игорь Лабутин" дождаться завершения асинхронной задачи, что мы выясняли
2153.92 2157.84 "Игорь Лабутин" несколькими минутами раньше, сделать это, скажем так,
2157.84 2160.24 "Игорь Лабутин" надежным образом, в общем-то, невозможно.
2160.24 2163.72 "Игорь Лабутин" Поэтому рекомендация, если вы пишете асинхронно в стримы,
2163.72 2167.40 "Игорь Лабутин" перед тем, как вызывать dispose, вызовите flush async, чтобы
2167.40 2170.08 "Игорь Лабутин" вы точно знали, что все зафлашилось, и тогда dispose
2170.08 2171.76 "Игорь Лабутин" ничего ждать не будет, он поймет, что ждать не надо
2171.76 2175.12 "Игорь Лабутин" и спокойно закроет стрим, либо используйте новый
2175.12 2180.04 "Игорь Лабутин" dispose async там, где он есть, через evade_using, у нас есть
2180.04 2183.34 "Игорь Лабутин" в C# конструкция теперь evade_using, которая будет вызывать
2183.34 2186.80 "Игорь Лабутин" dispose async с правильными там evade-ами и всем добром.
2186.80 2188.56 "Игорь Лабутин" Она, понятно, будет работать.
2188.56 2191.16 "Анатолий Кулаков" Ну только не совсем с правильными, потому что она не сможет
2191.16 2193.76 "Анатолий Кулаков" тебя вызвать неявно, сконфигуровать false.
2193.76 2195.76 "Анатолий Кулаков" О, да, мы же это обсуждали.
2195.76 2198.16 "Анатолий Кулаков" Да, deadlock там тоже может быть, к сожалению.
2198.16 2200.48 "Игорь Лабутин" Пара, да, и ты тоже потратил на это несколько часов,
2200.48 2201.48 "Игорь Лабутин" я помню.
2201.48 2202.48 "Игорь Лабутин" Да.
2202.48 2206.56 "Игорь Лабутин" Интересно, когда ты берёшь статью и понимаешь, что
2206.56 2209.52 "Игорь Лабутин" ты на это я потратил время, и тут тоже, эх.
2209.52 2213.64 "Игорь Лабутин" А статья, между прочим, 2000 какого-то, не знаю, раннего
2213.64 2215.44 "Игорь Лабутин" года, прочитал бы, знал бы.
2215.44 2216.44 "Анатолий Кулаков" Ну ладно.
2216.44 2218.20 "Анатолий Кулаков" Да, я тратил, когда они ещё даже про это не писали.
2218.20 2219.20 "Анатолий Кулаков" Ну ладно.
2219.20 2222.52 "Анатолий Кулаков" Я падал на deadlock, когда ещё даже таски не заберли.
2222.52 2226.12 "Игорь Лабутин" Да, фаулер ещё даже у вас по netcore не пришёл, я понял.
2226.12 2227.12 "Игорь Лабутин" Да-да-да.
2227.12 2228.12 "Игорь Лабутин" Я уже падал.
2228.12 2229.12 "Игорь Лабутин" Окей.
2229.12 2232.84 "Игорь Лабутин" Интересная рекомендация называется, смотрите, если
2232.84 2235.32 "Игорь Лабутин" у вас есть метод, который возвращает таск, и внутри
2235.32 2237.52 "Игорь Лабутин" вы просто вызываете метод, который тоже возвращает
2237.52 2238.52 "Игорь Лабутин" таск, допустим.
2238.52 2242.12 "Игорь Лабутин" Можно просто написать return и вы вернёте таск, а можно
2242.12 2245.64 "Игорь Лабутин" метод повесить как async_evade и сказать return_evade этот метод.
2245.64 2250.00 "Игорь Лабутин" С одной стороны, таким образом вы получите более чистый
2250.00 2253.32 "Игорь Лабутин" в код, в смысле, что он будет более понятный и предсказуемый,
2253.32 2256.32 "Игорь Лабутин" то есть у вас callstakes будут плюс-минус нормальные,
2256.32 2258.44 "Игорь Лабутин" у вас не будут теряться методы, потому что если
2258.44 2261.12 "Игорь Лабутин" вы просто вернёте таску, тот метод, из которого вы
2261.12 2264.16 "Игорь Лабутин" вернули таску, он не будет виден нигде, вообще, ни
2264.16 2267.24 "Игорь Лабутин" в каких там callstacks, ни в чём, они и так-то в async'ах так
2267.24 2271.60 "Игорь Лабутин" себе, ну сейчас вроде получше стали, tooling подтянулся
2271.60 2274.60 "Игорь Лабутин" с точки зрения async_callstacks, но вы не увидите тогда этот
2274.60 2277.42 "Игорь Лабутин" ваш метод, поэтому лучше использовать async_evade везде,
2277.42 2280.22 "Игорь Лабутин" но помните, что если это прям ну совсем супер критичный
2280.22 2283.36 "Игорь Лабутин" код по перформансу, то async_evade это всё-таки некоторые
2283.36 2287.56 "Игорь Лабутин" дополнительные издержки на генерацию, кстати, машины,
2287.56 2291.52 "Игорь Лабутин" и поэтому если у вас там, не знаю, callstakes по 100-200 вызовов
2291.52 2296.48 "Игорь Лабутин" и каждый из них по async_evade, то ну overhead будет, надо мерить,
2296.48 2297.48 "Игорь Лабутин" вот.
2297.48 2301.16 "Игорь Лабутин" Но я обычно предпочитаю везде async_evade явно прописать,
2301.16 2304.36 "Игорь Лабутин" до тех пор, пока я не подтвердил каким-то другим способом,
2304.36 2305.36 "Игорь Лабутин" что это просто тормозит.
2305.36 2310.40 "Игорь Лабутин" Хотя, опять же, как правило, если там async_evade, значит
2310.40 2312.36 "Игорь Лабутин" внизу будет какой-нибудь I/O, который, возможно, тормозит
2312.36 2315.28 "Игорь Лабутин" ещё больше, и поэтому не такие большие вкладные
2315.28 2316.28 "Игорь Лабутин" расходы.
2316.28 2321.68 "Игорь Лабутин" И последний большой влог — это async_locals, значит, когда
2321.68 2324.76 "Игорь Лабутин" мы программировали на обычных потоках, когда было просто
2324.76 2327.12 "Игорь Лабутин" многопоточное программирование во времена дотлент фреймворка
2327.12 2330.80 "Игорь Лабутин" раннего, то там была такая штука под названием thread_local,
2330.80 2333.64 "Игорь Лабутин" но она по-разному называлась, была thread_local, была thread_static,
2333.64 2335.28 "Игорь Лабутин" можно было её по-разному объявить, но смысл был
2335.28 2336.28 "Игорь Лабутин" один и тот же.
2336.28 2339.76 "Игорь Лабутин" Что у вас есть некоторая переменная, которая будет
2339.76 2342.58 "Игорь Лабутин" иметь своё значение в каждом потоке, то есть технически
2342.58 2345.12 "Игорь Лабутин" в коде она одна, но в каждом потоке у неё будет своё
2345.12 2346.12 "Игорь Лабутин" значение.
2346.12 2349.52 "Игорь Лабутин" Это использовалось активно для такого кэширования,
2349.52 2351.72 "Игорь Лабутин" то есть стрингбилдеры так кэшировали, потому что
2351.72 2355.44 "Игорь Лабутин" обычно поток не прерывается для того, чтобы стрингбилдеры
2355.44 2358.68 "Игорь Лабутин" там как-то что-то заиспользовали, поэтому создали, там положили,
2358.68 2361.88 "Игорь Лабутин" и чтобы его не очищать, например, его клали в thread_static_переменной,
2361.88 2363.72 "Игорь Лабутин" поэтому таким пользовались, отлично экономило память.
2363.72 2367.80 "Игорь Лабутин" Точнее, меморий трафика, скорее, чем память.
2367.80 2371.48 "Игорь Лабутин" Но с async и wait-ами такое не пройдёт, мы можем использовать
2371.48 2374.92 "Игорь Лабутин" thread_local, но у вас нет никаких гарантий, что continuation,
2374.92 2377.92 "Игорь Лабутин" то есть продолжение вашего async метода, будет исполняться
2377.92 2380.36 "Игорь Лабутин" на том же потоке, то есть он может увидеть какую-то
2380.36 2383.56 "Игорь Лабутин" совершенно другую потоку, у него будет свой thread_local,
2383.56 2386.64 "Игорь Лабутин" и вы можете увидеть не там, что не то же самое значение,
2386.64 2388.68 "Игорь Лабутин" которое вы туда положили в начале метода.
2388.68 2391.76 "Игорь Лабутин" Поэтому для такой асинхронной модели программирования
2391.76 2394.84 "Игорь Лабутин" была придумана альтернатива под названием async_local, от
2394.84 2397.00 "Игорь Лабутин" t, это специальный класс, который может содержать
2397.00 2399.36 "Игорь Лабутин" в себе, ну, что угодно, по сути, ну, ссылку на объект.
2399.36 2405.68 "Игорь Лабутин" Он так же, как и thread_local в каком-то смысле, живёт
2405.68 2409.56 "Игорь Лабутин" только уже не в контексте потока, а в контексте некой
2409.56 2411.68 "Игорь Лабутин" сущности, которая называется execution_context.
2411.68 2415.24 "Игорь Лабутин" Это, на самом деле, такая, тоже, по сути, объект, некоторая
2415.24 2418.76 "Игорь Лабутин" коллекция сущностей, в которой раньше, по крайней
2418.76 2420.84 "Игорь Лабутин" мере, хранилась нужная информация про всякие там
2420.84 2424.64 "Игорь Лабутин" имперсонейшены, под какими кредентами этот код выполняется,
2424.64 2426.60 "Игорь Лабутин" то есть во времена старого dotnet framework, это очень давняя
2426.60 2427.60 "Игорь Лабутин" концепция.
2427.60 2430.54 "Игорь Лабутин" Сейчас в современном dotnet, я так понимаю, там по большей
2430.54 2433.96 "Игорь Лабутин" части async_local, в общем-то, и там почти ничего нет,
2433.96 2434.96 "Игорь Лабутин" кроме этого.
2434.96 2435.96 "Игорь Лабутин" Вот.
2435.96 2437.80 "Игорь Лабутин" В частности, туда как раз скепчерится synchronization_context,
2437.80 2438.80 "Игорь Лабутин" если нужно.
2438.80 2440.84 "Игорь Лабутин" Если я правильно помню, года три назад уже туда
2440.84 2444.28 "Игорь Лабутин" не смотрел, но по памяти примерно так.
2444.28 2449.28 "Игорь Лабутин" Так вот, этот самый execution_context, он везде передаётся в любых
2449.28 2452.76 "Игорь Лабутин" методах дальше, где мы, так или иначе, можем работу
2452.76 2454.64 "Игорь Лабутин" сгрузить на любой другой тред.
2454.64 2457.92 "Игорь Лабутин" То есть, если вы шедулите какой-то кусочек работы
2457.92 2462.88 "Игорь Лабутин" в этот самый, в user thread pool, то есть вы вызываете функцию
2462.88 2469.92 "Игорь Лабутин" queue_user_work_item, вы можете его зафлоуить, он будет флоуиться,
2469.92 2472.68 "Игорь Лабутин" если вы, например, там в таймер что-то поместите,
2472.68 2474.48 "Игорь Лабутин" то есть какую-нибудь лямбдочку, оно там тоже закепчерит
2474.48 2475.48 "Игорь Лабутин" всё это дело.
2475.48 2478.32 "Игорь Лабутин" И, в частности, async_local туда кепчерится.
2478.32 2481.36 "Игорь Лабутин" Причём execution_context, надо понимать, что он хитрый,
2481.36 2485.76 "Игорь Лабутин" он обладает свойством copy_on_write, то есть вы, если вы вот в
2485.76 2490.92 "Игорь Лабутин" async_local, который лежит в этом контексте, в асинк-методе
2490.92 2495.12 "Игорь Лабутин" запишите какое-нибудь значение, потом вы вызовете другой
2495.12 2499.48 "Игорь Лабутин" асинк-метод, этот асинк-метод тоже запишет в этот же асинк-локал
2499.48 2503.84 "Игорь Лабутин" переменную тоже какое-то значение, то когда вы выйдете
2503.84 2505.96 "Игорь Лабутин" из внутреннего асинк-метода, значение там будет всё
2505.96 2510.76 "Игорь Лабутин" ещё старое из первого метода, то есть значения не выходят
2510.76 2513.56 "Игорь Лабутин" за пределы асинк-методов наружу, они только внутрь
2513.56 2516.92 "Игорь Лабутин" проваливаются, то есть каждый раз, когда туда
2516.92 2521.00 "Игорь Лабутин" что-то пишется, по сути, создаётся копия execution_context.
2521.00 2525.52 "Игорь Лабутин" Это бывает полезно, иногда это не очень удобно, потому
2525.52 2531.72 "Игорь Лабутин" что сложно передавать сущности наружу, как это по-русски
2531.72 2534.36 "Игорь Лабутин" называется, по-английски есть хороший термин ambient,
2534.36 2536.80 "Игорь Лабутин" а по-русски что-то я не могу сообразить, как он называется,
2536.80 2542.32 "Игорь Лабутин" но неважно, смысл понятен, то есть такой неявный контекст,
2542.32 2545.52 "Игорь Лабутин" если вы хотите через него передавать как-то возвращаемые
2545.52 2548.24 "Игорь Лабутин" значения, то так не получится, асинк-локалы так не работают,
2548.24 2550.30 "Игорь Лабутин" там нужно приседать, на самом деле делать двойной
2550.30 2555.72 "Игорь Лабутин" уровень, то есть нужно внутрь асинк-локала хранить ссылочку
2555.72 2559.52 "Игорь Лабутин" на другой объект, и тогда вот уже в том объекте можно
2559.52 2560.52 "Игорь Лабутин" всё менять.
2560.52 2564.04 "Игорь Лабутин" Так, кстати, работает rstp_context_accessor в ASP.NET Core, можете посмотреть,
2564.04 2566.98 "Игорь Лабутин" как он написан, вот он ровно так сделан, там есть внутренний
2566.98 2569.16 "Игорь Лабутин" промежуточный объект, в котором уже лежит ссылка
2569.16 2573.60 "Игорь Лабутин" на rstp_context, и сделано это для того, чтобы когда заканчивается
2573.60 2577.64 "Игорь Лабутин" реквест, обработка реквеста, мы rstp_context проставляем в
2577.64 2581.80 "Игорь Лабутин" null, чтобы он везде, где мы хоть как-то этот rstp_context_accessor
2581.80 2586.80 "Игорь Лабутин" зачем-то забрали, а там асинк-локал, он тоже обнулился, и вы получили
2586.80 2590.16 "Игорь Лабутин" свой null reference exception, если вы вдруг доступаетесь
2590.16 2593.84 "Игорь Лабутин" к rstp_context вне контекста запроса, вот, то есть техники
2593.84 2597.80 "Игорь Лабутин" есть, с ними можно работать, но не так это просто.
2597.80 2602.60 "Игорь Лабутин" Так вот, возвращаясь к асинк-локалу, если вы его таки используете,
2602.60 2606.04 "Игорь Лабутин" то самый лучший способ — это класть туда либо штуку,
2606.04 2612.04 "Игорь Лабутин" которая неизменяемая, там, только для чтения, либо
2612.04 2614.08 "Игорь Лабутин" thread-safe, то есть какой-нибудь concurrent dictionary туда положить
2614.08 2618.44 "Игорь Лабутин" нормально, какой-нибудь там read-only stringo положить
2618.44 2623.68 "Игорь Лабутин" нормально, изменяемую коллекцию, типа там, list, а t там хранить,
2623.68 2627.12 "Игорь Лабутин" ну, кажется, будет не очень эффективно, не очень здорово,
2627.12 2630.44 "Игорь Лабутин" потому что нет никаких гарантий, сколько туда народу будет
2630.44 2632.80 "Игорь Лабутин" одновременно доступаться, ну и самое главное — туда
2632.80 2636.56 "Игорь Лабутин" нельзя класть disposable штуки, потому что не очень понятно,
2636.56 2639.08 "Игорь Лабутин" кто и когда, в какой момент будет ее диспоузить, можно
2639.08 2641.28 "Игорь Лабутин" пытаться написать аккуратный код вокруг этого, но это
2641.28 2644.24 "Игорь Лабутин" очень непросто, поэтому лучше туда не класть disposable
2644.24 2645.24 "Игорь Лабутин" штуки.
2645.24 2652.64 "Игорь Лабутин" А если вам нужно почему-то, допустим, избежать того,
2652.64 2655.88 "Игорь Лабутин" чтобы execution context закепчерился, то есть вы не хотите, чтобы
2655.88 2659.48 "Игорь Лабутин" ваш async local куда-то дальше пролез, например, вы что-то
2659.48 2663.76 "Игорь Лабутин" schedulety, но вы не хотите, чтобы thread-pool поток про
2663.76 2667.82 "Игорь Лабутин" это знал, как раз в частности для этого существуют методы
2667.82 2671.08 "Игорь Лабутин" с префиксом unsafe, то есть вот, например, у constellation
2671.08 2674.40 "Игорь Лабутин" есть метод под названием register, туда можно зарегать
2674.40 2677.20 "Игорь Лабутин" лямбдочку, которая будет выполнена, когда constellation
2677.20 2678.20 "Игорь Лабутин" токен сработает.
2678.20 2681.88 "Игорь Лабутин" Но также есть парный к нему метод unsafe register, также есть
2681.88 2685.76 "Игорь Лабутин" у thread-pool item quser workitem, есть, соответственно, unsafe quser
2685.76 2686.76 "Игорь Лабутин" workitem.
2686.76 2690.02 "Игорь Лабутин" Это надо знать, скорее всего, вам это особо не потребуется
2690.02 2692.24 "Игорь Лабутин" для обычного, типичного использования async local в
2692.24 2696.92 "Игорь Лабутин" виде прокидывания какого-то неявного контекста, но
2696.92 2700.28 "Игорь Лабутин" помните про эту штуку, иногда это может быть важно.
2700.28 2705.88 "Игорь Лабутин" И если вам вдруг нужна функциональность вида, ну как я сейчас объяснил
2705.88 2710.24 "Игорь Лабутин" для http-контекста, то есть хранить внутри async local контейнер
2710.24 2713.36 "Игорь Лабутин" со ссылкой на уже реальное значение, чтобы иметь возможность
2713.36 2716.56 "Игорь Лабутин" ее обнулять, то можно посмотреть, есть такой класс под названием
2716.56 2720.20 "Игорь Лабутин" strongbox, я не знаю, почему он называется strongbox, но
2720.20 2723.68 "Игорь Лабутин" он где-то там в system.runtime.compiler.services есть, и вот фаулер говорит,
2723.68 2725.56 "Игорь Лабутин" что в принципе нормальная тема его использует для
2725.56 2726.56 "Игорь Лабутин" вот таких вот случаев.
2726.56 2730.04 "Игорь Лабутин" Почему он strong, не знаю, не смотрел исходники, интересно.
2730.04 2732.60 "Игорь Лабутин" Возможно, есть еще какой-нибудь weakbox, который хранит там
2732.60 2736.20 "Игорь Лабутин" слабую ссылку на boxed объект.
2736.20 2739.34 "Игорь Лабутин" Ну и последняя рекомендация про async local, это про то, что
2739.34 2743.30 "Игорь Лабутин" помните, что вся эта магия с async local и copy on write, и тот
2743.30 2746.68 "Игорь Лабутин" факт, что вы не можете проставить значение и видеть его после
2746.68 2750.16 "Игорь Лабутин" выхода из метода, не работает, если метод синхронный.
2750.16 2751.96 "Игорь Лабутин" Синхронный метод, понятно, ничего там не captured, никаких
2751.96 2755.32 "Игорь Лабутин" copy on write не происходит, поэтому с одной стороны это можно,
2755.32 2758.24 "Игорь Лабутин" я, например, это использовал в каком-то своем коде для
2758.24 2761.92 "Игорь Лабутин" того, чтобы с помощью helper метода, то есть пишем синхронный
2761.92 2764.80 "Игорь Лабутин" там helper метод, который в этот ambient context нафигачит
2764.80 2766.36 "Игорь Лабутин" нужных значений.
2766.36 2768.64 "Игорь Лабутин" Они сохраняются после выхода из синхронного метода и
2768.64 2771.28 "Игорь Лабутин" дальше спокойно по async stack распространяются.
2771.28 2776.36 "Игорь Лабутин" Но если вдруг у вас там, вы раньше писали async метод,
2776.36 2778.28 "Игорь Лабутин" потом решили переделать его там на sync почему-то
2778.28 2781.56 "Игорь Лабутин" и так далее, а там остался async local кусочек, то вот знайте,
2781.56 2783.48 "Игорь Лабутин" что в этот момент значения начнут вылезать наоружу
2783.48 2786.56 "Игорь Лабутин" этого метода, и это может быть важно.
2786.56 2791.64 "Игорь Лабутин" Вот такая вот такой, точнее, свод рекомендации Дэвида
2791.64 2792.64 "Игорь Лабутин" Фаулера.
2792.64 2797.52 "Игорь Лабутин" Но это далеко не все, это свод вида как бы типа делай
2797.52 2801.40 "Игорь Лабутин" так, не делай вот так, так хорошо, так плохо.
2801.40 2803.76 "Игорь Лабутин" В большинстве случаев мы все-таки сталкиваемся
2803.76 2811.16 "Игорь Лабутин" с реальными сценариями, что нужно делать, и в таких
2811.16 2814.12 "Игорь Лабутин" сценариях нужно просто узнать, так скажем, типовое
2814.12 2816.56 "Игорь Лабутин" решение, что с ним нужно сделать.
2816.56 2819.36 "Игорь Лабутин" И таких сценариев у него рассмотрено 5, я расскажу
2819.36 2822.92 "Игорь Лабутин" 4/5, это прям какой-то impersonation, что-то там, что-то очень
2822.92 2825.16 "Игорь Лабутин" далекое от обычного пользователя, мне кажется.
2825.16 2827.52 "Игорь Лабутин" Поэтому рассмотрим только 4 штуки.
2827.52 2830.72 "Игорь Лабутин" Штука первая, callback-и таймеров, ну то есть у нас есть таймеры,
2830.72 2833.80 "Игорь Лабутин" у него должны быть callback-и, и если мы туда хотим в этом
2833.80 2837.88 "Игорь Лабутин" callback-е запустить async код, что делать, потому что собственно
2837.88 2840.92 "Игорь Лабутин" все callback-и таймеров очевидно возвращают в айды в большинстве
2840.92 2845.12 "Игорь Лабутин" своем, вернее не в большинстве, а в стопроцентном числе
2845.12 2848.96 "Игорь Лабутин" случаев, это асинхронные методы, и из них нужно вызвать
2848.96 2851.84 "Игорь Лабутин" асинхронную работу, вспоминаем, опять же, раньше это невозможно
2851.84 2857.28 "Игорь Лабутин" сделать надежно, что делать, ну как, async void это плохо,
2857.28 2861.24 "Игорь Лабутин" async overasync плохо, и самое лучшее, что можно было
2861.24 2864.56 "Игорь Лабутин" сделать до шестого дотнета, это все-таки сделать вашу
2864.56 2867.72 "Игорь Лабутин" асинк работу через метод, который возвращает таск,
2867.72 2871.80 "Игорь Лабутин" и его просто задискардить, тот самый fire and forget, по-другому
2871.80 2872.80 "Игорь Лабутин" никак.
2872.80 2875.36 "Игорь Лабутин" Вот, начиная с шестого дотнета появился класс, мы про него
2875.36 2878.24 "Игорь Лабутин" рассказывали, periodic timer, который устроен очень
2878.24 2881.88 "Игорь Лабутин" забавно, у него нет callback-а, у него просто нужно асинхронно
2881.88 2886.64 "Игорь Лабутин" вызвать функцию waitForNextTickAsync и дождаться ее, то есть
2886.64 2890.20 "Игорь Лабутин" вы просто выделяете некоторый отдельный трет, в котором
2890.20 2892.44 "Игорь Лабутин" просто в цикле начинаете вызывать этот таймер, дождаться
2892.44 2895.00 "Игорь Лабутин" следующего тика, когда дождались, вызываете свою
2895.00 2899.12 "Игорь Лабутин" функцию waitDoMyWork, потом снова waitNextTickAsync и так далее до
2899.12 2900.92 "Игорь Лабутин" тех пор, пока таймер не законсолится или вы не
2900.92 2905.36 "Игорь Лабутин" закончите там, не сделаете нужное количество повторений,
2905.36 2906.36 "Игорь Лабутин" это первая штука.
2906.36 2907.36 "Игорь Лабутин" Вторая штука.
2907.36 2911.96 "Игорь Лабутин" Если вам нужно куда-то передать делегат, action от
2911.96 2917.52 "Игорь Лабутин" t, просто action, да, а нужно, опять же, сделать асинхронную
2917.52 2921.04 "Игорь Лабутин" работу, ну вам нужно в качестве делегата асинхронную работу,
2921.04 2923.72 "Игорь Лабутин" один из вариантов, вы пишете асинхронную лямбдочку,
2923.72 2929.04 "Игорь Лабутин" в которой делаете, значит, wait внутри вашего метода,
2929.04 2933.60 "Игорь Лабутин" но по сути он создаст асинх, wait - метод, который вызовется
2933.60 2936.36 "Игорь Лабутин" синхронно и будет, ну, все как обычно, да, это по сути
2936.36 2939.40 "Игорь Лабутин" таск, которую вызвали и с ней ничего не делают.
2939.40 2942.96 "Игорь Лабутин" Поэтому либо пользуемся тем самым способом дискарда
2942.96 2948.16 "Игорь Лабутин" fireAndForget, вот это все, либо в идеале самый хороший
2948.16 2950.34 "Игорь Лабутин" способ в вашей опишке, если это ваша опишка, которую
2950.34 2953.36 "Игорь Лабутин" вы контролируете, не надо принимать только action, action
2953.36 2955.70 "Игорь Лабутин" вы принимаете для синхронного случая, а для асинхронного
2955.70 2960.84 "Игорь Лабутин" вы принимаете func от таска, и тогда вы туда можете передать
2960.84 2964.12 "Игорь Лабутин" нормальный асинхронный метод, и тот, кто будет обрабатывать,
2964.12 2966.88 "Игорь Лабутин" будет знать, что на нем нужно бы появить, желательно,
2966.88 2967.92 "Игорь Лабутин" и тогда нормально заработает.
2967.92 2973.92 "Игорь Лабутин" ConcurrentDictionary, там есть интересная функция, называется getOrAdd,
2973.92 2976.92 "Игорь Лабутин" которая по ключу возвращает значение, либо вызывает
2976.92 2979.96 "Игорь Лабутин" лямбду, которая сгенерит значение, которое будет
2979.96 2982.96 "Игорь Лабутин" гарантировано в единственном экземпляре, положено в
2982.96 2984.44 "Игорь Лабутин" конкурент, и дальше будет использоваться при следующих
2984.44 2985.44 "Игорь Лабутин" getах.
2985.44 2989.98 "Игорь Лабутин" Точно так же, если вам эта функция, которая генерирует
2989.98 2993.72 "Игорь Лабутин" значение асинхронно, то с ней надо что-то делать,
2993.72 2995.68 "Игорь Лабутин" один из вариантов, который предлагается, это хранить
2995.68 2999.24 "Игорь Лабутин" в ConcurrentDictionary сразу таски, то есть мы храним не там
2999.24 3004.48 "Игорь Лабутин" dictionary из строки в person, а из строки в task от person,
3004.48 3007.04 "Игорь Лабутин" то есть мы по сути кэшируем сразу таску, и везде, где
3007.04 3009.08 "Игорь Лабутин" надо, мы будем у нее вызывать точка результат, у таска
3009.08 3011.68 "Игорь Лабутин" можно несколько раз спросить результат, почему нет,
3011.68 3015.00 "Игорь Лабутин" но есть проблема, нет, у этого метода, getorad, нет никаких
3015.00 3017.04 "Игорь Лабутин" гарантий, сколько раз будет вызвана эта лямбда, если
3017.04 3019.36 "Игорь Лабутин" конкурент на несколько клиентов пришли за одним
3019.36 3021.48 "Игорь Лабутин" и тем же ключом, технически каждый из них может выполнить
3021.48 3024.28 "Игорь Лабутин" ту лямбду, значение в итоге запишется только одно,
3024.28 3025.72 "Игорь Лабутин" но лямбда будет выполняться.
3025.72 3030.64 "Игорь Лабутин" А поскольку лямбда содержит task, а task, ну он скорее всего
3030.64 3033.62 "Игорь Лабутин" будет уже запущенный, вряд ли мы создаем task в состоянии
3033.62 3037.56 "Игорь Лабутин" started, в смысле в состоянии created, который еще не стартован,
3037.56 3039.96 "Игорь Лабутин" то всю ту работу, которую нужно проделать для того,
3039.96 3041.64 "Игорь Лабутин" чтобы получить значение, вы будете делать несколько
3041.64 3042.64 "Игорь Лабутин" раз.
3042.64 3043.64 "Игорь Лабутин" Вот.
3043.64 3046.12 "Игорь Лабутин" Возможно для очень тяжелых операций это сложно, дорого
3046.12 3050.24 "Игорь Лабутин" и не очень хочется, и тогда можно использовать замечательный
3050.24 3054.92 "Игорь Лабутин" класс под названием sink_lazy, у нас есть класс lazy_at, который
3054.92 3057.80 "Игорь Лабутин" делает ровно одну штуку, он не вычисляет значение,
3057.80 3059.64 "Игорь Лабутин" пока вы за ним не обратились, как только обратились,
3059.64 3062.32 "Игорь Лабутин" он один раз вызовет, один или там разные гарантии
3062.32 3066.52 "Игорь Лабутин" есть, может быть несколько раз вызовет метод, который
3066.52 3069.44 "Игорь Лабутин" в него указали, там можно указать некоторые гарантии
3069.44 3073.68 "Игорь Лабутин" в зависимости от этого, зависит то, насколько затратным
3073.68 3075.40 "Игорь Лабутин" он будет, грубо говоря, на сколько там будет синхронизация
3075.40 3076.40 "Игорь Лабутин" внутри происходить.
3076.40 3079.84 "Игорь Лабутин" Есть его асинхронный аналог, это async_lazy, то есть мы в словарик
3079.84 3084.32 "Игорь Лабутин" сохраняем async_lazy, и он будет, он вызовет вашу асинк функцию
3084.32 3087.64 "Игорь Лабутин" ровно столько, ровно тогда, когда нужно, и уже в нормальном
3087.64 3088.64 "Игорь Лабутин" асинхронном виде.
3088.64 3091.72 "Игорь Лабутин" Ну и вы, естественно, его тоже потребляете в асинхронном
3091.72 3093.92 "Игорь Лабутин" виде, тут уже никуда не деться.
3093.92 3098.64 "Игорь Лабутин" Ну и последний, наверное, один из самых популярных
3098.64 3100.96 "Игорь Лабутин" кейсов — это конструкторы, конструкторы по определению
3100.96 3101.96 "Игорь Лабутин" синхронны.
3101.96 3104.36 "Игорь Лабутин" И если вам из конструктора нужно вызвать асинхронный
3104.36 3107.80 "Игорь Лабутин" метод зачем-то, ну вы в тупике, опять же, либо ты самый
3107.80 3112.80 "Игорь Лабутин" fire and forget, смотри выше, либо Fowler предлагает тогда воспользоваться
3112.80 3117.04 "Игорь Лабутин" методом и паттерном static_factory, то есть вы конструктор
3117.04 3120.96 "Игорь Лабутин" делаете private, он синхронный, он ждет нужных ему данных
3120.96 3124.60 "Игорь Лабутин" уже прям данных, а вы делаете public_static функцию, которая
3124.60 3127.28 "Игорь Лабутин" имеет ту же сигнатуру в среднем, что и конструктор,
3127.28 3129.48 "Игорь Лабутин" ее делать асинхронной, соответственно, она сначала
3129.48 3131.68 "Игорь Лабутин" асинхронно вызывает все нужные асинхронные методы,
3131.68 3133.16 "Игорь Лабутин" получает из них данные, и дальше вызывает уже нормальный
3133.16 3135.24 "Игорь Лабутин" приватный конструктор, как обычно, через new там
3135.24 3138.16 "Игорь Лабутин" и передавая уже реальные полученные данные.
3138.16 3141.36 "Анатолий Кулаков" Ну вообще смотри, это нечестно, ввели у нас во фреймворк
3141.36 3146.12 "Анатолий Кулаков" интерфейс idisposable_async, а вот ctor_async почему-то не
3146.12 3147.12 "Анатолий Кулаков" догадались.
3147.12 3150.20 "Игорь Лабутин" А конструктор async, да-да-да, await_new, вот, точно.
3150.20 3152.20 "Анатолий Кулаков" И await_new, да-да-да.
3152.20 3155.24 "Игорь Лабутин" Подождать пока new, звучит как будто это, подождать,
3155.24 3157.44 "Игорь Лабутин" пока появится свободная память, и тогда создай объект.
3157.44 3163.28 "Игорь Лабутин" Ну может быть, может быть, но кажется, что с конструкторами,
3163.28 3165.12 "Игорь Лабутин" и если делать асинхронный конструктор, это будет
3165.12 3167.76 "Игорь Лабутин" уже совсем непредсказуемо, то есть то ли он создался,
3167.76 3171.60 "Игорь Лабутин" то ли он не создался, то ли еще что-то, не знаю, в
3171.60 3172.60 "Анатолий Кулаков" общем.
3172.60 3174.60 "Анатолий Кулаков" Тем более там еще контекст нас начнет капчурить, и
3174.60 3176.20 "Анатолий Кулаков" человек в дедлок встанет.
3176.20 3178.76 "Игорь Лабутин" Да, начинаем создавать объекты на одном трейде,
3178.76 3180.72 "Игорь Лабутин" заканчиваем на другом, короче, ух.
3180.72 3184.84 "Анатолий Кулаков" Не, метод с фабрикой прекрасен, в принципе, у него больших
3184.84 3185.84 "Анатолий Кулаков" минусов никаких нет.
3185.84 3188.96 "Игорь Лабутин" Ну, я думаю, что у него единственный минус, только если тебе
3188.96 3191.64 "Игорь Лабутин" нужно каким-то образом создавать эти объекты, ну, например,
3191.64 3193.76 "Игорь Лабутин" не, ну это, наверное, уже совсем экзотический случай,
3193.76 3196.74 "Игорь Лабутин" если тебе нужно, чтобы какой-нибудь там, не знаю, сериализатор
3196.74 3199.80 "Игорь Лабутин" создавал объект, он тогда будет дергать конструктор,
3199.80 3202.00 "Игорь Лабутин" а тебе в нем нужно вызвать асинхронный метод.
3202.00 3205.36 "Игорь Лабутин" Ну, наверное, это прям совсем экзотика, не надо так делать.
3205.36 3206.92 "Анатолий Кулаков" Ну, наверное, да, и вообще старайтесь конструкторы
3206.92 3209.52 "Анатолий Кулаков" держать как можно примитивнее, конструкторы должны выполняться
3209.52 3212.20 "Анатолий Кулаков" очень быстро, не вмещать в себя никаких сложных
3212.20 3213.20 "Анатолий Кулаков" действий.
3213.20 3215.16 "Анатолий Кулаков" Ну, в принципе, про это тоже есть большие бестпрактисы,
3215.16 3217.72 "Анатолий Кулаков" поэтому единственное, что он должен делать, это проверять
3217.72 3220.48 "Анатолий Кулаков" входные аргументы и присваивать локальные поля, всё, больше
3220.48 3223.20 "Анатолий Кулаков" в нем никакой работы быть не должно, а асинх – это,
3223.20 3225.56 "Анатолий Кулаков" по идее, какая-то большая работа, в общем, большую
3225.56 3227.40 "Анатолий Кулаков" работу нельзя делать в конструкторах.
3227.40 3228.40 "Игорь Лабутин" Да.
3228.40 3230.12 "Игорь Лабутин" Используйте правила конструктора, про которые мы поговорим
3230.12 3231.64 "Игорь Лабутин" в следующем выпуске, ну или про которые мы, на самом
3231.64 3232.64 "Игорь Лабутин" деле, конечно, уже говорили.
3232.64 3239.56 "Игорь Лабутин" Если вы внимательно слушали, и если вы внимательно работали
3239.56 3243.76 "Игорь Лабутин" когда-либо с async/await, вы, конечно, наверно, да, я должен сказать,
3243.76 3246.76 "Игорь Лабутин" что на этом, собственно, статья Fowler заканчивается,
3246.76 3250.38 "Игорь Лабутин" и вы могли бы сказать, а где же одна из главных
3250.38 3251.38 "Игорь Лабутин" тем?
3251.38 3253.68 "Игорь Лабутин" Вот я сказал, что async/await – это одна из очень сильно
3253.68 3257.00 "Игорь Лабутин" обсуждаемых тем в контексте async/await, а вторая – это,
3257.00 3258.00 "Игорь Лабутин" конечно, configure/await.
3258.00 3261.84 "Игорь Лабутин" Наверное, может быть, даже это самая обсуждаемая тема
3261.84 3266.12 "Игорь Лабутин" в контексте async/await, и надо сказать, что у Fowler в статье
3266.12 3269.96 "Игорь Лабутин" про вот эти все async/guidance, про configure/await есть раздел,
3269.96 3271.16 "Игорь Лабутин" в котором написано TBD.
3271.16 3275.16 "Игорь Лабутин" Вот уже несколько лет TBD, видимо, пока не может определиться,
3275.16 3276.16 "Игорь Лабутин" что что-то написать.
3276.16 3281.68 "Игорь Лабутин" Но, к счастью, недавно Стивен Клири, ну, собственно, недельку
3281.68 3286.42 "Игорь Лабутин" назад или около того, разродился блогом про .NET, у него давно
3286.42 3288.62 "Игорь Лабутин" что-то не было, на самом деле, ничего про .NET, и тут
3288.62 3292.16 "Игорь Лабутин" он прямо написал про новый configure/await, потому что мы
3292.16 3294.84 "Игорь Лабутин" про него немножко уже говорили, но для полноты картинки
3294.84 3298.96 "Игорь Лабутин" давайте мы еще раз напомним, что же меняется, а точнее,
3298.96 3302.06 "Игорь Лабутин" что добавляется в configure/await в новом восьмом .NET.
3302.06 3305.76 "Игорь Лабутин" Для начала давайте вспомним, зачем нам, в принципе, configure/await.
3305.76 3311.24 "Игорь Лабутин" Как я сказал, при await'ах происходит некоторая магия,
3311.24 3314.68 "Игорь Лабутин" и когда await'ы были только придуманы, то было понятно,
3314.68 3317.56 "Игорь Лабутин" что, например, если вы вызываете какой-то асинхронный код
3317.56 3322.64 "Игорь Лабутин" из WPF или WinForms'кого приложения, и он вдруг, внезапно, continuation
3322.64 3325.80 "Игорь Лабутин" начнет выполняться на трэдпульном потоке, то ваш UI полностью
3325.80 3328.40 "Игорь Лабутин" развалится, потому что, как известно, UI можно обновлять
3328.40 3330.96 "Игорь Лабутин" только из того потока, где окошки были созданы, ну,
3330.96 3333.24 "Игорь Лабутин" грубо говоря, из главного потока приложения.
3333.24 3337.28 "Игорь Лабутин" И поэтому await был наделен такой волшебной функциональностью,
3337.28 3340.40 "Игорь Лабутин" как по дефолту continuation будет продолжаться в том
3340.40 3343.16 "Игорь Лабутин" же синхронизейшн-контексте, где он был начат.
3343.16 3347.20 "Игорь Лабутин" WPF, WinForms и некоторые другие фреймворки синхронизейшн-контекст
3347.20 3352.24 "Игорь Лабутин" используют, а SPNetCore современный не использует, и при этом
3352.24 3356.00 "Игорь Лабутин" есть еще такой момент, что, если вы, например, делаете
3356.00 3358.68 "Игорь Лабутин" какую-то тяжелую работу, то вам бы очень не хотелось,
3358.68 3361.76 "Игорь Лабутин" чтобы она выполнялась на главном вашем потоке приложения
3361.76 3364.84 "Игорь Лабутин" в синхронизейшн-контексте.
3364.84 3369.16 "Игорь Лабутин" Поэтому на таске, по сути, был написан extension метод,
3369.16 3373.16 "Игорь Лабутин" который возвращает некоторую другую штуку, в которой
3373.16 3375.76 "Игорь Лабутин" стоит флажок, то есть configure await принимает флажок true
3375.76 3378.52 "Игорь Лабутин" или false, по дефолту там true, то есть если вы его
3378.52 3381.30 "Игорь Лабутин" вызываете с true, то вы не сделали ничего, но вы можете
3381.30 3384.80 "Игорь Лабутин" вызвать false, и это означает, что аргумент там, по-моему,
3384.80 3387.88 "Игорь Лабутин" называется continuum-captured-context, имеется в виду, конечно,
3387.88 3390.44 "Игорь Лабутин" синхронизейшн-контекст, и это тоже, наверное, источник
3390.44 3392.54 "Игорь Лабутин" путаницы, потому что, как я сказал, там на самом деле
3392.54 3397.00 "Игорь Лабутин" есть два контекста, у нас есть execution-контекст и синхронизейшн-контекст.
3397.00 3400.88 "Игорь Лабутин" Вот этот флажок отвечает за синхронизейшн-контекст,
3400.88 3404.84 "Игорь Лабутин" а чтобы не capture execution-контекст, напомню, нужно использовать
3404.84 3407.80 "Игорь Лабутин" unsafe методы, если вы этого хотите.
3407.80 3415.82 "Игорь Лабутин" Так вот, поскольку, допустим, авторы библиотек не очень
3415.82 3418.42 "Игорь Лабутин" знали, где ваш код будет использоваться, да даже
3418.42 3421.34 "Игорь Лабутин" если вы пишете не библиотеку, а внутри ваш продукт, вы
3421.34 3424.48 "Игорь Лабутин" понятия не имеете, вот конкретный какой-нибудь там глубокий
3424.48 3427.02 "Игорь Лабутин" метод в вашей бизнес-логике дергается ли он напрямую
3427.02 3432.38 "Игорь Лабутин" из UI или откуда-то из тредпула, то в среднем вы бы не хотели
3432.38 3436.26 "Игорь Лабутин" оказаться на UI-ном треде, и только тот код, который
3436.26 3438.34 "Игорь Лабутин" эвейтит реально на UI-ном треде, то есть вот если
3438.34 3441.58 "Игорь Лабутин" вы знаете, что это обработчик кнопочки и в нем вы вызываете
3441.58 3444.38 "Игорь Лабутин" эвейт, в нем вы хотите, чтобы континуейшн исполнился
3444.38 3447.34 "Игорь Лабутин" на UI-ном треде, во всех остальных случаях как бы не хотите.
3447.34 3450.50 "Игорь Лабутин" И поэтому, как только это все появилось, первая,
3450.50 3453.06 "Игорь Лабутин" ну по крайней мере, как вот Клири пишет, первая историческая
3453.06 3455.14 "Игорь Лабутин" рекомендация была вообще использовать и конфигурировать
3455.14 3457.30 "Игорь Лабутин" false везде, где только можете.
3457.30 3460.38 "Игорь Лабутин" Вот где вы уверены, что вам нужно, то делайте, там
3460.38 3462.86 "Игорь Лабутин" можно ничего не писать, а так везде пишите false.
3462.86 3465.38 "Игорь Лабутин" Видел даже рекомендацию, что везде пишите явно,
3465.38 3469.70 "Игорь Лабутин" но это как бы совсем overkill, true писать как бы не надо.
3469.70 3472.18 "Игорь Лабутин" Потом эту рекомендацию упростили до состояния,
3472.18 3474.94 "Игорь Лабутин" типа если вы пишите библиотечку, пишите везде false и не парьтесь,
3474.94 3478.10 "Игорь Лабутин" если вы пишите не библиотечку, а приложение, не пишите
3478.10 3479.10 "Игорь Лабутин" нигде.
3479.10 3481.54 "Игорь Лабутин" Вот сейчас есть тренд, что вообще не пишите, конфигурируйте,
3481.54 3483.98 "Игорь Лабутин" я знаю, Толя, что ты не согласен с этим делом, потому что
3483.98 3487.22 "Игорь Лабутин" ты опять же провел несколько часов в отладке с синхронизейшн
3487.22 3488.66 "Игорь Лабутин" контекстами, где ты их не ожидал.
3488.66 3496.18 "Игорь Лабутин" Есть несколько, ну скажем так, clearly это называют misconceptions,
3496.18 3502.70 "Игорь Лабутин" то есть недопонимание, что ли, про configure await.
3502.70 3506.66 "Игорь Лабутин" Есть такое мнение, что configure await false гарантированно
3506.66 3508.78 "Игорь Лабутин" помогает избежать дедлоков.
3508.78 3511.94 "Игорь Лабутин" Технически это не его цель.
3511.94 3516.90 "Игорь Лабутин" Можно так сделать какой-нибудь там thread pool, вот этот scheduler,
3516.90 3519.10 "Игорь Лабутин" то и на нем можно получить какие-нибудь дедлоки даже
3519.10 3522.68 "Игорь Лабутин" с configure await false, но в среднем в обычном приложении это
3522.68 3525.26 "Игорь Лабутин" скорее полезный side effect, нежели чем основная цель
3525.26 3530.14 "Игорь Лабутин" configure await false, все-таки цель была не capture синхронизейшн
3530.14 3532.98 "Игорь Лабутин" контекст, а как-то по совпадению получилось, что именно он
3532.98 3535.74 "Игорь Лабутин" основной источник дедлоков, просто потому что в большинстве
3535.74 3537.84 "Игорь Лабутин" случаев синхронизейшн контексты выполняют все,
3537.84 3540.58 "Игорь Лабутин" что в них падает последовательно, ну так сложилось в одном
3540.58 3541.58 "Игорь Лабутин" потоке.
3541.58 3543.50 "Игорь Лабутин" У нас очень мало синхронизейшн контекстов, которые выполняют
3543.50 3546.82 "Игорь Лабутин" что-то в нескольких потоках.
3546.82 3553.62 "Игорь Лабутин" Второй такой миф про configure await false в том, что некоторые
3553.62 3557.94 "Игорь Лабутин" считают, что если вы напишите await, что-то там, task какой-нибудь,
3557.94 3560.82 "Игорь Лабутин" да, ну метод, который возвращает task, .configure await false, то это
3560.82 3563.70 "Игорь Лабутин" гарантирует, что все, что после этого await будет исполняться
3563.70 3567.42 "Игорь Лабутин" на thread pool, нет, не гарантирует.
3567.42 3570.22 "Игорь Лабутин" По одной простой причине, если task к моменту, когда
3570.22 3573.86 "Игорь Лабутин" вы выполняете await, уже закончилось синхронно, то есть если
3573.86 3577.10 "Игорь Лабутин" task быстро успело закончиться синхронно, то continuation будет
3577.10 3580.26 "Игорь Лабутин" исполняться там же, то есть это не гарантия того, что
3580.26 3582.30 "Игорь Лабутин" поток уйдет в thread pool исполнение.
3582.30 3585.02 "Игорь Лабутин" Это может быть так случится, и в большинстве случаев
3585.02 3587.54 "Игорь Лабутин" оно именно так и случится, если task, там действительно
3587.54 3588.54 "Игорь Лабутин" нужно что-то подождать.
3588.54 3591.66 "Игорь Лабутин" Но если ждать внезапно не надо, task готово, то продолжим
3591.66 3592.66 "Игорь Лабутин" прямо там, где начали.
3592.66 3593.66 "Игорь Лабутин" Вот.
3593.66 3596.62 "Игорь Лабутин" В 8-м дотнете есть некоторые изменения во всем этом
3596.62 3600.46 "Игорь Лабутин" поведении, точнее не в поведении даже, а в configure
3600.46 3602.78 "Игорь Лабутин" await в самом, в том, как его можно вызывать.
3602.78 3606.30 "Игорь Лабутин" Во-первых, все старое поведение никуда не поменялось.
3606.30 3608.58 "Игорь Лабутин" Как можно было вызывать false true, так и сейчас можно
3608.58 3612.34 "Игорь Лабутин" вызывать false true, поведение все осталось тем же самым,
3612.34 3614.98 "Игорь Лабутин" но появился новый overload для метода, который принимает
3614.98 3617.82 "Игорь Лабутин" флаговый enum под названием configure await options, и там аж
3617.82 3621.26 "Игорь Лабутин" 4 опции, 4 флага, их можно комбинировать в любой в
3621.26 3622.78 "Игорь Лабутин" общем-то комбинации.
3622.78 3626.30 "Игорь Лабутин" Первая опция — это none, и она эквивалентна по сути
3626.30 3628.54 "Игорь Лабутин" configure await false.
3628.54 3629.54 "Игорь Лабутин" Дальше.
3629.54 3633.14 "Игорь Лабутин" Вторая опция — это continue on captured context, она очевидно
3633.14 3636.22 "Игорь Лабутин" эквивалентна true, то есть вот эти две, если вам не
3636.22 3639.22 "Игорь Лабутин" хочется писать configure await false, вы можете писать configure
3639.22 3641.50 "Игорь Лабутин" await, скобочка открылась, configure await options, точка none,
3641.50 3642.50 "Игорь Лабутин" скобочка закрылась.
3642.50 3643.50 "Анатолий Кулаков" Будет?
3643.50 3645.22 "Анатолий Кулаков" Действительно, почему мы должны этого хотеть?
3645.22 3650.22 "Игорь Лабутин" Ну вдруг вам по Java соскучились, там, подлиннее методы, вот
3650.22 3651.22 "Игорь Лабутин" это все.
3651.22 3652.22 "Игорь Лабутин" Не знаю.
3652.22 3654.02 "Игорь Лабутин" Ну можно так переписать.
3654.02 3655.02 "Игорь Лабутин" Дальше.
3655.02 3660.22 "Игорь Лабутин" Надо понимать, что все эти configure await штуки доступны
3660.22 3663.10 "Игорь Лабутин" только на таске или на таске от T.
3663.10 3666.90 "Игорь Лабутин" Они не доступны на value таске, потому что value таски, они
3666.90 3669.74 "Игорь Лабутин" такие все оптимизированные, там считается, что они в
3669.74 3671.98 "Игорь Лабутин" основном полезны, когда все заканчивается синхронно
3671.98 3674.90 "Игорь Лабутин" и не нужно ничего реальное вейтить, и поэтому там
3674.90 3679.10 "Игорь Лабутин" никаких этих штук просто недоступно, то есть вы только
3679.10 3681.30 "Игорь Лабутин" на тасках и на тасках от T можете эти сделать.
3681.30 3684.58 "Анатолий Кулаков" А что там происходит с контекстом, разве он не капчурится?
3684.58 3685.58 "Анатолий Кулаков" В value таске?
3685.58 3686.58 "Анатолий Кулаков" На value тасках, да.
3686.58 3689.62 "Игорь Лабутин" А смотри, в value таске, если нужно ее эвейтить физически,
3689.62 3690.74 "Игорь Лабутин" там же таск создается нормальный.
3690.74 3693.46 "Игорь Лабутин" А, и уже на нем там запускается метро или фолкс?
3693.46 3695.02 "Игорь Лабутин" Да, и на нем запускается стандартная машинерия,
3695.02 3696.02 "Игорь Лабутин" да.
3696.02 3698.74 "Игорь Лабутин" То есть value таск, он же, плюс его в том, ну в смысле, его
3698.74 3701.38 "Игорь Лабутин" фишка в том, что если он типа быстро и синхронно
3701.38 3703.66 "Игорь Лабутин" ты закончился, то у тебя нет вообще никакой аллокации.
3703.66 3704.66 "Игорь Лабутин" Вот.
3704.66 3707.42 "Игорь Лабутин" А вот если нужно подождать, то там родится нормальный
3707.42 3709.66 "Игорь Лабутин" полноценный таск, который положится на нормальную
3709.66 3712.34 "Игорь Лабутин" кучу со всем кепчерингом и всем добром.
3712.34 3714.74 "Анатолий Кулаков" Ну так почему я не могу на value таске вот этот янумчик
3714.74 3717.42 "Анатолий Кулаков" передать, чтобы он потом на настоящую таску перебросился?
3717.42 3721.66 "Игорь Лабутин" Вот это интересный вопрос, не помню, не знаю, не смотрел.
3721.66 3722.66 "Анатолий Кулаков" Вероятность...
3722.66 3725.06 "Анатолий Кулаков" Я же наверняка хочу там же, точно такие же у меня
3725.06 3726.86 "Анатолий Кулаков" проблемы, я хочу или капчурить контекст, или не капчурить
3726.86 3727.86 "Анатолий Кулаков" контекст.
3727.86 3729.74 "Анатолий Кулаков" У меня же желание никуда не делось, от того, вылью
3729.74 3730.74 "Игорь Лабутин" она или не вылью.
3730.74 3733.70 "Игорь Лабутин" Интересный вопрос, не знаю на него ответа, надо изучать,
3733.70 3734.70 "Игорь Лабутин" гуглить.
3734.70 3737.38 "Игорь Лабутин" Если вспомню и будет не лень, как-нибудь посмотрю, почитаю
3737.38 3738.38 "Игорь Лабутин" более детально.
3738.38 3739.38 "Игорь Лабутин" Ну вот.
3739.38 3742.10 "Игорь Лабутин" Не могу ответить, я согласен, что действительно хотелось
3742.10 3744.54 "Игорь Лабутин" бы конфигурить, но может быть это та самая проблема,
3744.54 3747.54 "Игорь Лабутин" как и с твоими, то что мы упоминали раньше, дисползосинками,
3747.54 3749.50 "Игорь Лабутин" которые тоже не конфигурируются, конфигурируют фолзом правильно.
3749.50 3754.70 "Анатолий Кулаков" Ну значит надо багу создать и посмотреть официальный
3754.70 3755.70 "Игорь Лабутин" ответ.
3755.70 3756.70 "Игорь Лабутин" Ну может быть такая и есть.
3756.70 3758.18 "Игорь Лабутин" Я говорю, что наверняка надо почитать, на самом
3758.18 3760.58 "Игорь Лабутин" деле может быть даже в проползли на эту фичу наверняка есть
3760.58 3763.46 "Игорь Лабутин" какое-нибудь описание, в этом смысле Microsoft неплохо
3763.46 3766.58 "Игорь Лабутин" работает и пишут, ну они довольно подробно рассматривают
3766.58 3768.50 "Игорь Лабутин" всякие pros и cons.
3768.50 3772.74 "Анатолий Кулаков" Да, они не могли пропустить такую штуку, мне кажется,
3772.74 3774.86 "Анатолий Кулаков" должна была какая-то причина быть, что в этой версии
3774.86 3775.86 "Анатолий Кулаков" они не сделали.
3775.86 3776.86 "Игорь Лабутин" Наверняка.
3776.86 3780.46 "Игорь Лабутин" Так вот, две новых опции.
3780.46 3785.14 "Игорь Лабутин" Первая опция это suppress throwing, значит, что такое, зачем
3785.14 3786.14 "Игорь Лабутин" она нужна?
3786.14 3788.38 "Игорь Лабутин" Смотрите, если у вас есть асинхронный код, который
3788.38 3791.22 "Игорь Лабутин" зачем-то кинул эксепшн, ну так сложилось, то этот
3791.22 3793.94 "Игорь Лабутин" эксепшн перевыкинется уже в ваш код, когда вы сделаете
3793.94 3794.94 "Игорь Лабутин" wait.
3794.94 3796.34 "Игорь Лабутин" То есть так он там капчурится внутрь тасочки, складывается
3796.34 3798.92 "Игорь Лабутин" объект, ну полем просто внутри таска живет, и если
3798.92 3801.66 "Игорь Лабутин" вы await таску, которая в эксепшне, в поле эксепшн
3801.66 3803.94 "Игорь Лабутин" не нал, то этот эксепшн просто вам будет кинуть
3803.94 3804.94 "Игорь Лабутин" дальше.
3804.94 3811.14 "Игорь Лабутин" Если вы знаете, что вам на эксепшны пофигу, значит,
3811.14 3813.98 "Игорь Лабутин" даже в библиотеке, в стандартной библиотеке был код вида
3813.98 3818.82 "Игорь Лабутин" там try, фигурная скобочка открылась, await что-нибудь,
3818.82 3821.66 "Игорь Лабутин" фигурная скобочка закрылась, catch exception и две пустых фигурных
3821.66 3822.66 "Игорь Лабутин" скобочки.
3822.66 3826.78 "Игорь Лабутин" Ну то есть типа мы catch all, не парясь, что там были
3826.78 3827.78 "Игорь Лабутин" за эксепшны.
3827.78 3829.74 "Игорь Лабутин" То есть нам просто нужно вызвать async метод, дождаться
3829.74 3832.46 "Игорь Лабутин" его завершения, не важно, что он там сделал, успешно,
3832.46 3835.26 "Игорь Лабутин" не успешно, все равно.
3835.26 3839.78 "Игорь Лабутин" В таком случае в текущем варианте, когда мы делаем
3839.78 3842.62 "Игорь Лабутин" try, catch, эксепшн, все дела, у нас есть некоторое количество
3842.62 3843.62 "Игорь Лабутин" накладных расходов.
3843.62 3846.94 "Игорь Лабутин" Во-первых, собственно, создается объект эксепшна, там собирается
3846.94 3850.10 "Игорь Лабутин" стэк, ну короче там много чего.
3850.10 3855.26 "Игорь Лабутин" Во-вторых, мы делаем try, catch, что тоже не бесплатно,
3855.26 3857.60 "Игорь Лабутин" а в-третьих мы просто это все игнорим, то есть эксепшн
3857.60 3858.60 "Игорь Лабутин" кидается и мы игнорим.
3858.60 3862.02 "Игорь Лабутин" Поэтому если мы знаем, что мы вейтим что-то, что может
3862.02 3863.86 "Игорь Лабутин" кинуть эксепшн, но мы не заинтересованы в этом
3863.86 3866.42 "Игорь Лабутин" эксепшне, случаи такие довольно редки, но тем не
3866.42 3869.92 "Игорь Лабутин" менее могут быть, то можно сразу в флажок передать
3869.92 3873.52 "Игорь Лабутин" suppress rowing, в этом случае и эксепшн не будет создаваться
3873.52 3875.98 "Игорь Лабутин" соответственно и try, catch вам не нужно, в общем все
3875.98 3878.10 "Игорь Лабутин" будет работать чуть-чуть пошустрее.
3878.10 3882.96 "Игорь Лабутин" Но вот тут есть одно но, указать-то вы эту штуку
3882.96 3888.26 "Игорь Лабутин" можете и на таске, и на таск от t, но если вы это указываете
3888.26 3890.42 "Игорь Лабутин" на таске, ну все понятно, вы заэвейтили таск, таск
3890.42 3893.54 "Игорь Лабутин" там как-то закончился, все хорошо, вы пошли дальше,
3893.54 3895.46 "Игорь Лабутин" ну эксепшн проигнорировали, пошли дальше, но если вы
3895.46 3898.46 "Игорь Лабутин" вейтите таск от t, то ему же нужно вернуть какой-то
3898.46 3899.46 "Игорь Лабутин" t, правильно?
3899.46 3901.78 "Игорь Лабутин" Значение-то ему нужно же вернуть, вы же вейтите
3901.78 3904.70 "Игорь Лабутин" его, а он закончился эксепшном, что делать?
3904.70 3910.30 "Игорь Лабутин" И тут в майкрософте есть логичное и прекрасное решение,
3910.30 3914.90 "Игорь Лабутин" вам будет кинуть аргументов out of range exception, то есть если
3914.90 3915.90 "Игорь Лабутин" вы заэвейтите.
3915.90 3918.94 "Игорь Лабутин" Я попросил не бросать ни эксепшна и за это нам бросят
3918.94 3919.94 "Игорь Лабутин" эксепшн.
3919.94 3922.42 "Игорь Лабутин" Ну если ты попросил бросать эксепшн и говорить, что
3922.42 3925.26 "Игорь Лабутин" тебе не интересен результат таски, по большому счету,
3925.26 3926.26 "Игорь Лабутин" правильно?
3926.26 3928.74 "Игорь Лабутин" То зачем ты ждешь результат таски, ну если это таск
3928.74 3929.74 "Игорь Лабутин" от t, да?
3929.74 3932.54 "Игорь Лабутин" Потому что могу, вы сами до копии написали, извините.
3932.54 3935.14 "Игорь Лабутин" Но на самом деле у них есть еще и аналайзер, то есть
3935.14 3937.34 "Игорь Лабутин" на самом деле тебе будет ворнинг в момент компиляции,
3937.34 3940.46 "Игорь Лабутин" что типа ты указал это с расстроения на таск от
3940.46 3943.70 "Игорь Лабутин" t, типа будет, скорее всего, так сказать, проблемы.
3943.70 3945.50 "Игорь Лабутин" То есть это будет видно не только в рантайме, это
3945.50 3947.14 "Игорь Лабутин" будет в компайл тайме тоже видно.
3947.14 3949.98 "Анатолий Кулаков" Ну вот это же хорошо, да, в компайл тайме, это нормальная
3949.98 3950.98 "Игорь Лабутин" решение.
3950.98 3952.46 "Игорь Лабутин" Так что вам, по крайней мере, подскажут, что тут что-то
3952.46 3953.46 "Игорь Лабутин" не то.
3953.46 3957.74 "Игорь Лабутин" И опять же, по дефолту это ворнинг, но к лире говорит
3957.74 3958.74 "Игорь Лабутин" сделайте сразу эррор.
3958.74 3961.38 "Игорь Лабутин" Ну то есть в данном случае ворнинг из эррор конкретных,
3961.38 3963.14 "Игорь Лабутин" пусть даже хотя бы только для этой штуки, это очень
3963.14 3966.82 "Игорь Лабутин" полезно, потому что в рантайме это практически гарантированный
3966.82 3967.82 "Игорь Лабутин" эксепшен.
3967.82 3969.80 "Игорь Лабутин" Причем аргумент out of range, который вы в принципе не
3969.80 3973.70 "Игорь Лабутин" ожидаете, он довольно редкий в каком-то смысле.
3973.70 3976.54 "Игорь Лабутин" И лучше сразу пофиксить код.
3976.54 3981.34 "Игорь Лабутин" И последний, четвертый аргумент флаг, это force yielding.
3981.34 3984.46 "Игорь Лабутин" У нас есть ключевое слово yield, как вы помните, которое
3984.46 3989.10 "Игорь Лабутин" используется во всяких методах, итераторах, да,
3989.10 3991.38 "Игорь Лабутин" вот та и номер, был генерить вот это все.
3991.38 3996.30 "Игорь Лабутин" У нас есть метод task_yield, и в принципе эта штука похожая.
3996.30 3998.54 "Игорь Лабутин" Зачем нам нужен был task.yield?
3998.54 4002.54 "Игорь Лабутин" Task.yield был нам нужен для того, чтобы мы гарантированно,
4002.54 4007.78 "Игорь Лабутин" грубо говоря, переключились на действительно другой
4007.78 4009.38 "Игорь Лабутин" поток, грубо говоря.
4009.38 4011.18 "Игорь Лабутин" Не обязательно другой, это может быть в результате
4011.18 4013.18 "Игорь Лабутин" тот же самый, но если вы исполнялись, например,
4013.18 4017.34 "Игорь Лабутин" в контексте UI потока, и вы скажете task_await, task_yield,
4017.34 4023.14 "Игорь Лабутин" сconfigure_await_falls, то вот там 100% у вас будет уже поток
4023.14 4029.54 "Игорь Лабутин" thread pool, потому что так устроен task_yield, он никогда не комплитится
4029.54 4035.18 "Игорь Лабутин" синхронно, но сразу executes все, что на него навесили,
4035.18 4040.62 "Игорь Лабутин" все continuation, но уже в другом понятно потоке.
4040.62 4045.06 "Игорь Лабутин" Соответственно, если вам это вдруг нужно, то это
4045.06 4047.74 "Игорь Лабутин" будет, во-первых, отдельный await, смотрится не очень
4047.74 4051.58 "Игорь Лабутин" здорово и так далее, и можно просто указать await с force
4051.58 4055.30 "Игорь Лабутин" yielding теперь, сconfigure_await, и тогда это тоже будет гарантировать,
4055.30 4058.66 "Игорь Лабутин" что это точно будет, ну, грубо говоря, переложено
4058.66 4062.12 "Игорь Лабутин" как будто там task ждали, на там бэкграундный поток
4062.12 4063.12 "Игорь Лабутин" еще куда-то.
4063.12 4069.58 "Игорь Лабутин" И при этом надо понимать, что вот этот вот force yielding,
4069.58 4074.10 "Игорь Лабутин" он подразумевает, что вы не capture-ите контекст.
4074.10 4077.82 "Игорь Лабутин" То есть если вы хотите закепчурить при этом контекст, а это
4077.82 4080.82 "Игорь Лабутин" вы, может быть, хотите, то нужно писать и force yielding,
4080.82 4082.50 "Игорь Лабутин" и continuing captured контекст.
4082.50 4083.50 "Игорь Лабутин" Вот.
4083.50 4087.26 "Игорь Лабутин" Кликеры говорят, что, скорее всего, в продакшен-коде
4087.26 4089.46 "Игорь Лабутин" вам это особо не нужно, ну, то есть сложно придумать,
4089.46 4092.26 "Игорь Лабутин" зачем вам это, может быть, надо, ну, кроме случая действительно
4092.26 4096.18 "Игорь Лабутин" обязательного offload'а с этого, с UI-потока.
4096.18 4099.22 "Игорь Лабутин" Но, скорее всего, это может быть полезно в юнит-тестах,
4099.22 4101.14 "Игорь Лабутин" когда вы хотите что-нибудь поэмулировать, потому что
4101.14 4103.38 "Игорь Лабутин" в юнит-тестах у вас, скорее всего, какие-то таски, которые
4103.38 4106.02 "Игорь Лабутин" там мгновенно комплитятся, либо возвращают там просто
4106.02 4109.46 "Игорь Лабутин" task from result для тестов, да, из моков каких-нибудь, там
4109.46 4111.26 "Игорь Лабутин" все будет комплититься мгновенно, и по факту ваш
4111.26 4113.70 "Игорь Лабутин" многопоточный асинхронный код будет там синхронным
4113.70 4114.70 "Игорь Лабутин" и однопоточным.
4114.70 4117.38 "Игорь Лабутин" А вот force yielding может его заставить таки быть честным
4117.38 4119.50 "Игорь Лабутин" тасковым, что он там будет между потоками прыгать
4119.50 4121.86 "Игорь Лабутин" и так далее, и больше шансов, что вы что-нибудь поймаете.
4121.86 4123.66 "Игорь Лабутин" Или проведете еще несколько часов в отладке.
4123.66 4131.54 "Игорь Лабутин" Вот такие вот дела про асинхронность, на этом наш экскурс в историю
4131.54 4134.30 "Игорь Лабутин" и современное состояние асинхронности заканчивается.
4134.30 4137.10 "Игорь Лабутин" Если вам еще что-то интересно про асинхронность или мы
4137.10 4139.94 "Игорь Лабутин" рассказали какую-нибудь явную дичь, пишите нам об
4139.94 4142.94 "Игорь Лабутин" этом, мы обязательно почитаем, признаемся, что мы рассказали
4142.94 4145.66 "Игорь Лабутин" дичь, что мы ничего не пишем на тасках давно, и все забыли.
4145.66 4148.94 "Игорь Лабутин" Но вроде мы постарались не соврать.
4148.94 4150.82 "Игорь Лабутин" Только на continuation, да.
4150.82 4152.62 "Игорь Лабутин" Да, все так.
4152.62 4154.86 "Анатолий Кулаков" Ну и если кому-то понравилось, то напомню, что в прошлом
4154.86 4157.34 "Анатолий Кулаков" выпуске мы тоже обсуждали большую интересную статью
4157.34 4160.54 "Анатолий Кулаков" про таски, про best practices, про анализаторы, и если
4160.54 4163.34 "Анатолий Кулаков" вы ее случайно пропустили или специально пропустили,
4163.34 4166.30 "Анатолий Кулаков" и вам все-таки эта тема интересна, то рекомендую послушать.
4166.30 4169.66 "Игорь Лабутин" Да, а мы пойдем дальше, потому что у нас еще немало статей,
4169.66 4172.70 "Игорь Лабутин" а времени мы уже потратили дофига на эту статью.
4172.70 4174.98 "Анатолий Кулаков" Да-да, надо как-то ускоряться.
4174.98 4177.62 "Анатолий Кулаков" К сожалению, сильно ускориться не получится, потому что
4177.62 4180.62 "Анатолий Кулаков" эта статья тоже такая немаленькая, но мы сейчас попробуем
4180.62 4182.58 "Анатолий Кулаков" пробежаться, пропуститься.
4182.58 4185.30 "Анатолий Кулаков" Смотрите, хочется поговорить о breaking changes, ну не даром
4185.30 4187.86 "Анатолий Кулаков" у нас тут скоро релиз, как бы Microsoft что-то релизит,
4187.86 4190.34 "Анатолий Кулаков" и понятное дело, что когда ты говоришь про выпуск
4190.34 4192.50 "Анатолий Кулаков" каких-то новых фич, тебе нужно понимать, а старые
4192.50 4196.26 "Анатолий Кулаков" фичи-то у тебя будут нормально ли работать, и вообще существующий
4196.26 4197.90 "Анатолий Кулаков" код с вашей новой версией будет живется.
4197.90 4202.64 "Анатолий Кулаков" И когда вы задаетесь подобным вопросом, то у вас невольно
4202.64 4206.90 "Анатолий Кулаков" на ум приходят breaking changes, версионирование, совместимость,
4206.90 4209.78 "Анатолий Кулаков" backward compatibility, forward compatibility и прочие такие странные
4209.78 4210.78 "Анатолий Кулаков" вещи.
4210.78 4212.70 "Анатолий Кулаков" Вот давайте о них немножко поговорим.
4212.70 4215.58 "Анатолий Кулаков" В частности, а что же такое breaking changes?
4215.58 4217.22 "Анатолий Кулаков" Давайте попробуем немножко разобраться.
4217.22 4221.26 "Анатолий Кулаков" Во-первых, когда вы вносите в свой код какие-то изменения,
4221.26 4223.50 "Анатолий Кулаков" вам всегда нужен некий баланс, вы всегда стоите
4223.50 4224.50 "Анатолий Кулаков" перед выбором.
4224.50 4227.46 "Анатолий Кулаков" Перед выбором тем, что будете ли вы держать стабильную
4227.46 4230.54 "Анатолий Кулаков" кодовую базу, или будете внедрять мегаинновационные
4230.54 4231.54 "Анатолий Кулаков" фишки.
4231.54 4234.08 "Анатолий Кулаков" Потому что если ваша база стабильная, вы соблюдаете
4234.08 4237.02 "Анатолий Кулаков" определенное количество правил, то те клиенты, те
4237.02 4238.92 "Анатолий Кулаков" кастомеры, которые пользуются вашей библиотекой или вашим
4238.92 4242.14 "Анатолий Кулаков" приложением, или вашим API, они продолжат пользоваться
4242.14 4244.38 "Анатолий Кулаков" и следующей версией вашей библиотеки.
4244.38 4247.36 "Анатолий Кулаков" Они будут вспоминать вас благим матом и прекрасно
4247.36 4250.46 "Анатолий Кулаков" заинтегрируются и обновятся на вашу новую версию.
4250.46 4253.98 "Анатолий Кулаков" Ежели вы все-таки хотите много каких-то инновационных
4253.98 4257.98 "Анатолий Кулаков" вещей, таски внедрить, флаги странные в Янумчик
4257.98 4260.70 "Анатолий Кулаков" пробросить новые, в общем, здесь ваши инновации очень
4260.70 4264.26 "Анатолий Кулаков" часто конфликтуют как раз-таки со стабильностью, с сигнатурой
4264.26 4267.06 "Анатолий Кулаков" тех методов, которые у вас были, с какими-то аргументами,
4267.06 4269.34 "Анатолий Кулаков" параметрами, классами, методами, чем угодно.
4269.34 4273.62 "Анатолий Кулаков" И вы имеете большой соблазн перед собой их поломать,
4273.62 4277.42 "Анатолий Кулаков" переименовать, может быть, перенести, изменить, отрефакторить,
4277.42 4278.78 "Анатолий Кулаков" вот это вот все.
4278.78 4281.82 "Анатолий Кулаков" Поэтому каждый раз, когда рука у вас подымается такое
4281.82 4284.06 "Анатолий Кулаков" что-то сделать, вы должны сразу понимать, а все-таки
4284.06 4285.90 "Анатолий Кулаков" какая у вас ответственность перед кастомерами, что
4285.90 4289.38 "Анатолий Кулаков" вы сейчас делаете, может ли ваша библиотека или
4289.38 4291.62 "Анатолий Кулаков" приложение себе это позволить или не может себе этого
4291.62 4292.62 "Анатолий Кулаков" позволить.
4292.62 4296.34 "Анатолий Кулаков" Так, и чтобы у вас это решение было более-менее осознанным,
4296.34 4298.18 "Анатолий Кулаков" мы сейчас об этом поглубже поговорим.
4298.18 4301.26 "Анатолий Кулаков" Во-первых, давайте определимся, какие бывают breaking changes,
4301.26 4305.38 "Анатолий Кулаков" т.е. что такое можно сломать, чтобы тот код, который
4305.38 4308.80 "Анатолий Кулаков" использует вашу библиотеку, перестал нормально работать.
4308.80 4311.82 "Анатолий Кулаков" На самом деле действительно есть какие-то очевидные
4311.82 4314.82 "Анатолий Кулаков" случаи, поменять полностью сигнатуру, переименовать
4314.82 4315.82 "Анатолий Кулаков" типы и т.д.
4315.82 4318.78 "Анатолий Кулаков" Ну, т.е. это понятное дело, но есть еще много интересных
4318.78 4319.78 "Анатолий Кулаков" неочевидных вещей.
4319.78 4323.10 "Анатолий Кулаков" В частности, давайте по порядку, какие типы breaking
4323.10 4324.10 "Анатолий Кулаков" changes существуют?
4324.10 4327.82 "Анатолий Кулаков" Казалось бы, один, но нет, их на самом деле три штуки.
4327.82 4332.58 "Анатолий Кулаков" Т.е. breaking changes можно разделить, например, на source breaking changes,
4332.58 4339.70 "Анатолий Кулаков" т.е. когда вы меняете исходный код, но при этом программа,
4339.70 4343.78 "Анатолий Кулаков" это не аффектит исполняемую программу, это аффектит
4343.78 4346.70 "Анатолий Кулаков" только в момент компиляции, т.е. вы, по сути, меняете
4346.70 4349.74 "Анатолий Кулаков" исходники, и эти исходники будут у вас не компилиться.
4349.74 4354.46 "Анатолий Кулаков" Ну, допустим, когда вы добавляете какой-нибудь метод, который
4354.46 4357.54 "Анатолий Кулаков" конфликтует с уже существующим, в том плане конфликтует
4357.54 4360.62 "Анатолий Кулаков" не, что у него сигнатуры совпадают, а в том плане,
4360.62 4364.10 "Анатолий Кулаков" что какой-то кастомер, когда вызывал этот метод, компилятор
4364.10 4367.90 "Анатолий Кулаков" мог однозначно определить, что это за метод.
4367.90 4370.30 "Анатолий Кулаков" Теперь, когда вы добавили такой же метод, но с чуть
4370.30 4375.14 "Анатолий Кулаков" похожими аргументами, но с разными, в принципе,
4375.14 4378.06 "Анатолий Кулаков" это довольно валидный код, но компилятор уже не может
4378.06 4380.10 "Анатолий Кулаков" однозначно определить, а что конкретно вы хотите
4380.10 4384.38 "Анатолий Кулаков" вызвать и заставить вызывающую сторону конкретно уточнить
4384.38 4388.74 "Анатолий Кулаков" там или тип, или генерик, или constraint, или еще что-то.
4388.74 4392.90 "Анатолий Кулаков" Например, еще в случае, когда вы переименовываете
4392.90 4393.90 "Анатолий Кулаков" параметры.
4393.90 4398.78 "Анатолий Кулаков" Если вы переименуете просто-напросто параметры и подсунете эту
4398.78 4402.18 "Анатолий Кулаков" сборку, допустим, выполняющемуся уже приложению, то никаких
4402.18 4404.54 "Анатолий Кулаков" проблем не будет, эти параметры без проблем вызовются,
4404.54 4407.34 "Анатолий Кулаков" потому что в момент вызова никакие там имена не используются.
4407.34 4410.30 "Анатолий Кулаков" Но если вы переименуете параметры и попытаетесь
4410.30 4413.82 "Анатолий Кулаков" перекомпилировать приложение, которое использует вашу
4413.82 4419.30 "Анатолий Кулаков" библиотеку и при этом использует named параметры, то есть вызывает
4419.30 4421.78 "Анатолий Кулаков" код из вашей библиотеки с помощью явного указания
4421.78 4424.70 "Анатолий Кулаков" имени параметра, который он хочет вызвать, вот тогда
4424.70 4425.94 "Анатолий Кулаков" компиляция у вас сломается.
4425.94 4433.02 "Анатолий Кулаков" Вот такие вещи у нас входят в source breaking changes, и в принципе,
4433.02 4436.98 "Анатолий Кулаков" это, наверное, самые безобидные вещи, потому что это самый
4436.98 4439.46 "Анатолий Кулаков" безобидный breaking changes, который только может существовать,
4439.46 4442.74 "Анатолий Кулаков" потому что он всегда посвечивается компиляторам, и обычно
4442.74 4446.38 "Анатолий Кулаков" это те вещи, которые разработчики могут элементарно починить.
4446.38 4449.58 "Анатолий Кулаков" Переименовать или перенести, или перефиксировать что-нибудь,
4449.58 4452.34 "Анатолий Кулаков" или конкретно указать, в общем, это самые лёгкие
4452.34 4455.70 "Анатолий Кулаков" breaking changes, которые только существуют, несмотря как
4455.70 4459.86 "Анатолий Кулаков" бы на их страшное название, что это именно breaking changes.
4459.86 4463.90 "Игорь Лабутин" Поэтому сразу хочется сказать, если уж ломаете, ломайте
4463.90 4466.78 "Игорь Лабутин" на уровне исходного кода, перепишите всё нахрен, переименуйте
4466.78 4471.54 "Игорь Лабутин" все свои поля, классы и так далее, и тогда те, кто возьмут
4471.54 4474.26 "Игорь Лабутин" вашу новую версию, точно сразу увидят в компиляторе,
4474.26 4475.26 "Игорь Лабутин" что нужно поменять.
4475.26 4478.86 "Анатолий Кулаков" Это правда, если у вас нет выбора, как бы вас представили
4478.86 4482.78 "Анатолий Кулаков" к стенке и заставляют вводить breaking changes, то самое прекрасное,
4482.78 4485.26 "Анатолий Кулаков" что вы можете сделать, это внедрить breaking changes, который
4485.26 4486.26 "Анатолий Кулаков" определит компилятор.
4486.26 4491.46 "Анатолий Кулаков" Но вообще старайтесь, конечно же, breaking changes не вводить,
4491.46 4493.94 "Анатолий Кулаков" или вводить их с помощью специальных техник, о которых
4493.94 4495.58 "Анатолий Кулаков" мы поговорим чуть попозже.
4495.58 4497.78 "Анатолий Кулаков" Второй вид breaking changes, который хочется рассмотреть, это
4497.78 4501.46 "Анатолий Кулаков" behavior breaking changes, т.е. это когда вы меняете поведение.
4501.46 4504.14 "Анатолий Кулаков" И это, к сожалению, самое распространённое и может
4504.14 4506.38 "Анатолий Кулаков" быть, да не может быть, а точно, это самое сложное
4506.38 4509.78 "Анатолий Кулаков" для выявления и самый опасный тип breaking changes, который существует.
4509.78 4514.82 "Анатолий Кулаков" Эти breaking changes приводят к логической ошибке, т.е.
4514.82 4515.90 "Анатолий Кулаков" которую компилятор не определит.
4515.90 4520.62 "Анатолий Кулаков" Например, методы сигнатуры остались те же самые, названия
4520.62 4523.14 "Анатолий Кулаков" остались те же самые, но внутри вы начинаете творить
4523.14 4524.14 "Анатолий Кулаков" дичь.
4524.14 4527.22 "Анатолий Кулаков" Например, начинаете выдавать исключения на какие-то входные
4527.22 4530.66 "Анатолий Кулаков" данные, которые раньше считались валидными, т.е. приложение
4530.66 4533.06 "Анатолий Кулаков" их вызывало в вашу библиотеку, передавало данные, всё
4533.06 4534.06 "Анатолий Кулаков" было хорошо.
4534.06 4536.26 "Анатолий Кулаков" Обновилось на новую версию, начало вызывать, и тут полетели
4536.26 4537.26 "Анатолий Кулаков" какие-то исключения.
4537.26 4540.62 "Анатолий Кулаков" Вот это и есть behavior breaking changes.
4540.62 4542.78 "Анатолий Кулаков" Это очень опасная штука.
4542.78 4546.58 "Анатолий Кулаков" И тут есть интересный момент, я уже упоминал про Microsoft,
4546.58 4550.94 "Анатолий Кулаков" когда он, не знаю, бага это была или не бага, да, когда
4550.94 4554.10 "Анатолий Кулаков" у нас на таске, когда возникало исключение, приложение
4554.10 4555.94 "Анатолий Кулаков" всё полностью варилось, несмотря на то, что там
4555.94 4559.18 "Анатолий Кулаков" одна таска ошиблась, в рантайм рушил всё приложение.
4559.18 4562.18 "Анатолий Кулаков" И Microsoft как бы, грубо говоря, пофиксил, изменил это поведение
4562.18 4565.10 "Анатолий Кулаков" в новых фреймворках, но при этом оставил флажочек,
4565.10 4566.78 "Анатолий Кулаков" что если вы вдруг хотите, переключитесь на старое
4566.78 4567.78 "Анатолий Кулаков" поведение.
4567.78 4568.78 "Анатолий Кулаков" Вот.
4568.78 4571.66 "Анатолий Кулаков" И как раз это продиктовано тем, что на самом деле это
4571.66 4575.42 "Анатолий Кулаков" не какой-то смешной или непонятный случай, потому
4575.42 4579.14 "Анатолий Кулаков" что это как раз таки и был behavior breaking changes.
4579.14 4582.86 "Анатолий Кулаков" И по-хорошему, даже если вы фиксите багу, но эта
4582.86 4586.22 "Анатолий Кулаков" бага приводила к какому-то определенному поведению,
4586.22 4590.82 "Анатолий Кулаков" на которое вызывающее приложение могло вполне рассчитывать,
4590.82 4593.60 "Анатолий Кулаков" это всё ещё breaking changes, и по-хорошему вы обязаны
4593.60 4597.06 "Анатолий Кулаков" предоставить какой-нибудь фич-флаг, который вернёт
4597.06 4598.54 "Анатолий Кулаков" это поведение обратно.
4598.54 4602.30 "Анатолий Кулаков" И вообще, когда вы делаете behavior breaking changes, опять же,
4602.30 4605.40 "Анатолий Кулаков" конечно, старайтесь этого не делать, но как бы сложно
4605.40 4607.78 "Анатолий Кулаков" быть красивым и богатым, иногда приходится всё-таки
4607.78 4609.18 "Анатолий Кулаков" breaking changes вводить.
4609.18 4611.62 "Анатолий Кулаков" Есть рекомендации, когда вы вводите behavior breaking
4611.62 4614.06 "Анатолий Кулаков" changes, то можно попробовать скрыть это за специальным
4614.06 4616.50 "Анатолий Кулаков" флажочком, за специальным фич-флагом.
4616.50 4619.74 "Анатолий Кулаков" Это позволит тем клиентам, которые используют, тем
4619.74 4622.02 "Анатолий Кулаков" приложениям, которые используют вашу библиотеку, безопасно
4622.02 4623.02 "Анатолий Кулаков" обновиться.
4623.02 4625.02 "Анатолий Кулаков" Да, ещё рекомендация, что этот фич-флаг должен по
4625.02 4626.02 "Анатолий Кулаков" умолчанию быть выключен.
4626.02 4628.46 "Анатолий Кулаков" Не так, как у Микрософта, у него там, в принципе, очевидная
4628.46 4630.86 "Анатолий Кулаков" бага, он всё-таки её по умолчанию включил, а у вас должна
4630.86 4632.14 "Анатолий Кулаков" её по умолчанию выключить.
4632.14 4637.70 "Анатолий Кулаков" То есть, если вы ввели какое-то новое поведение, которое
4637.70 4640.40 "Анатолий Кулаков" подключили ещё какое-то машинное обучение, которое,
4640.40 4643.90 "Анатолий Кулаков" в принципе, в некоторых случаях будет нарушать
4643.90 4645.50 "Анатолий Кулаков" то поведение, которое было раньше, например, бросать
4645.50 4649.26 "Анатолий Кулаков" исключение, то по умолчанию вы всё-таки должны это
4649.26 4650.26 "Анатолий Кулаков" поведение выключить.
4650.26 4653.16 "Анатолий Кулаков" И если вдруг клиент хочет, ваше приложение хочет, оно
4653.16 4655.02 "Анатолий Кулаков" должно будет явно его включить.
4655.02 4657.46 "Анатолий Кулаков" В общем, это какой-то такой best practice считается.
4657.46 4661.54 "Игорь Лабутин" Ну, кстати, надо сказать, что Майкрософт именно,
4661.54 4664.46 "Игорь Лабутин" когда всё это касается прям совсем больших чинджей,
4664.46 4665.46 "Игорь Лабутин" ровно так и делает.
4665.46 4667.98 "Игорь Лабутин" То есть, если вы вспомните все наши обсуждения всяких
4667.98 4672.58 "Игорь Лабутин" там новых garbage коллекторов, нового поведения рантайма,
4672.58 4675.74 "Игорь Лабутин" трекпулов, когда их переделывали на менеджерные штуки, даже
4675.74 4678.70 "Игорь Лабутин" в превью-версиях их нужно было обычно включать отдельным
4678.70 4682.26 "Игорь Лабутин" флагом поначалу, чтобы народ как раз мог спокойно себе
4682.26 4684.94 "Игорь Лабутин" поставить какую-нибудь превьюшку или РЦ, посмотреть
4684.94 4687.66 "Игорь Лабутин" и, если надо, включить.
4687.66 4688.66 "Анатолий Кулаков" Именно так.
4688.66 4691.66 "Анатолий Кулаков" И обычно все библиотеки, фрейворки, они именно тащат
4691.66 4695.94 "Анатолий Кулаков" за собой вот этот хвост из флагов, из каких-то енумов,
4695.94 4699.02 "Анатолий Кулаков" из конфигов, еще из чего-то, и тот момент, когда они
4699.02 4701.02 "Анатолий Кулаков" приходят к какому-нибудь новому релизу, т.е. меняют
4701.02 4703.40 "Анатолий Кулаков" большую мажорную версию, вот там они могут немножко
4703.40 4706.34 "Анатолий Кулаков" расслабиться и позволить себе весь этот мусор почистить.
4706.34 4708.86 "Анатолий Кулаков" Там уже можно позволить себе перейти на какой-нибудь
4708.86 4712.58 "Анатолий Кулаков" более рациональный дефолт, если вы понимаете, что это
4712.58 4716.18 "Анатолий Кулаков" действительно нужно новым пользователям, почистить
4716.18 4718.82 "Анатолий Кулаков" там старые флаги, убрать ненужные заглушки и при
4718.82 4720.74 "Анатолий Кулаков" этом составить большой релиз ноутс и предупредить
4720.74 4723.82 "Анатолий Кулаков" ваших пользователей, что вот секция breaking changes, смотрите
4723.82 4724.82 "Анатолий Кулаков" на нее.
4724.82 4727.58 "Анатолий Кулаков" Если вы обратитесь, например, к гитхабу Microsoft, то у них
4727.58 4730.66 "Анатолий Кулаков" прям есть специальная категория breaking changes и на самом деле
4730.66 4734.68 "Анатолий Кулаков" там очень много issues, которые вводят breaking changes, но в основном
4734.68 4737.38 "Анатолий Кулаков" они там или баги фиксят, или под флажочками, или
4737.38 4739.94 "Анатолий Кулаков" еще что-то, поэтому обычно все-таки переезды на новые
4739.94 4742.18 "Анатолий Кулаков" фреймворки доставляют не так много проблем, как
4742.18 4745.58 "Анатолий Кулаков" могли бы из-за как раз вот этих breaking changes.
4745.58 4749.86 "Анатолий Кулаков" Ну, как я уже сказал, у нас три типа breaking changes и третий
4749.86 4753.66 "Анатолий Кулаков" и последний – это бинарный breaking changes, это тоже довольно
4753.66 4757.58 "Анатолий Кулаков" редкая штука, но в принципе и появляется, она случается,
4757.58 4764.02 "Анатолий Кулаков" когда вы изменяете публичный API и при этом ваше приложение,
4764.02 4766.10 "Анатолий Кулаков" которое использует вашу библиотеку скомпилировано
4766.10 4768.70 "Анатолий Кулаков" против старой версии, у которой это публичный API
4768.70 4774.26 "Анатолий Кулаков" был еще старым и вы, например, без перекомпиляции можете
4774.26 4777.42 "Анатолий Кулаков" подложить новую версию библиотеки вашему старому
4777.42 4780.82 "Анатолий Кулаков" приложению и по-хорошему приложение будет работать,
4780.82 4782.98 "Анатолий Кулаков" вот это и называется бинарная совместимость.
4782.98 4784.94 "Анатолий Кулаков" Что же нужно сделать, чтобы эту бинарную совместимость
4784.94 4785.94 "Анатолий Кулаков" сломать?
4785.94 4789.86 "Анатолий Кулаков" Все очень просто, измените сигнатуру, например, метода,
4789.86 4792.98 "Анатолий Кулаков" добавьте новый параметр и тогда, когда вы подложите
4792.98 4796.98 "Анатолий Кулаков" вот эту сборочку, то ваше приложение в принципе запустится,
4796.98 4798.22 "Анатолий Кулаков" никаких проблем с этим нет, но когда оно попытается
4798.22 4801.02 "Анатолий Кулаков" вызвать метод с такими параметрами, вы получите
4801.02 4806.14 "Анатолий Кулаков" эксепшен, который называется missing method exception, это как
4806.14 4809.78 "Анатолий Кулаков" раз-таки значит, что в рантайме система не смогла сбандить
4809.78 4811.50 "Анатолий Кулаков" метод и не нашла его.
4811.50 4815.70 "Игорь Лабутин" Тут, кстати, надо сказать, что есть довольно неочевидный
4815.70 4818.38 "Игорь Лабутин" момент, о котором, может быть, многие не задумываются,
4818.38 4823.34 "Игорь Лабутин" а если у вас есть binary breaking change, то, как ни странно,
4823.34 4827.14 "Игорь Лабутин" у вас может не быть source breaking change, то есть вот, например,
4827.14 4830.06 "Игорь Лабутин" если взять твой пример, что мы меняем сигнатуру
4830.06 4832.58 "Игорь Лабутин" метода, добавляя туда новый параметр, казалось бы,
4832.58 4835.38 "Игорь Лабутин" ну это же и source breaking change, правильно, он же не скомпилится
4835.38 4839.94 "Игорь Лабутин" больше, но если вы добавите параметр с дефолтным значением,
4839.94 4843.18 "Игорь Лабутин" то это не будет source breaking change, код прекрасно скомпилится
4843.18 4846.50 "Игорь Лабутин" и будет работать, а вот если вы такую сборку подсунете,
4846.50 4848.66 "Игорь Лабутин" то в силу того, как у нас реализованы дефолтные
4848.66 4850.98 "Игорь Лабутин" параметры, что значение копируется на самом деле
4850.98 4856.34 "Игорь Лабутин" в вызывающий код тоже, то бинарно работать не будет,
4856.34 4862.14 "Игорь Лабутин" то есть вот есть такой забавный эффект, что в source-варианте
4862.14 4866.70 "Игорь Лабутин" у вас может быть какое-то изменение, которое будет
4866.70 4870.50 "Игорь Лабутин" бинарно совместимо, но не совместимо, допустим,
4870.50 4873.62 "Игорь Лабутин" по сорсу, и наоборот, есть бинарные изменения, которые
4873.62 4875.10 "Игорь Лабутин" прекрасно совместимы по исходникам.
4875.10 4879.00 "Анатолий Кулаков" Да-да-да, дефолт параметры как раз такой хрестоматийный
4879.00 4881.06 "Анатолий Кулаков" пример, когда это очень прекрасно проявляется.
4881.06 4883.82 "Игорь Лабутин" Наверное, можно ещё придумать, просто сейчас входу в голову
4883.82 4885.74 "Игорь Лабутин" чуть ничего не приходит, но да, действительно хрестоматийный
4885.74 4886.74 "Игорь Лабутин" пример.
4886.74 4893.06 "Анатолий Кулаков" Если вы вдруг хотите изменять сигнатуры, менять методы,
4893.06 4896.70 "Анатолий Кулаков" убивать классы, переименовывать их, то рекомендация здесь
4896.70 4900.58 "Анатолий Кулаков" — используйте absolute attribute, то есть вы его навешиваете
4900.58 4904.24 "Анатолий Кулаков" на тот мембр, который вы хотите убить или переименовать,
4904.24 4907.82 "Анатолий Кулаков" и пишите там «товарищи, я собираюсь это убить, перейдите,
4907.82 4911.18 "Анатолий Кулаков" пожалуйста, на альтернативный класс или на другой метод,
4911.18 4913.86 "Анатолий Кулаков" и дайте пожить немножко вашей библиотеке с этим
4913.86 4916.54 "Анатолий Кулаков" атрибутом, чтобы все ваши потребители как можно быстрее
4916.54 4917.54 "Анатолий Кулаков" его увидели».
4917.54 4919.98 "Анатолий Кулаков" У него есть ещё один хак, вы вторым аргументом можете
4919.98 4925.22 "Анатолий Кулаков" передать «падать с эррором при компиляции», в true поставить
4925.22 4928.10 "Анатолий Кулаков" его, например, в следующих версиях, когда-то после
4928.10 4931.58 "Анатолий Кулаков" ворнинга вам уже можно посыпать там исключениями,
4931.58 4934.02 "Анатолий Кулаков" ошибками компиляции соответственно, и после ошибок компиляции
4934.02 4936.26 "Анатолий Кулаков" уже, наверное, в каких-нибудь мажорных версиях вы можете
4936.26 4937.78 "Анатолий Кулаков" это дело менять и переименовывать.
4937.78 4941.98 "Анатолий Кулаков" Так, в принципе, можно постепенно переходить опять же к новому
4941.98 4944.42 "Анатолий Кулаков" коду и постепенно ваших пользователей не ломать
4944.42 4946.46 "Анатолий Кулаков" сразу, а дать им какое-то время на переезд.
4946.46 4949.06 "Анатолий Кулаков" При этом грамотно и красиво предупредить их с помощью
4949.06 4950.82 "Анатолий Кулаков" замечательного такого специального атрибута.
4950.82 4954.66 "Анатолий Кулаков" Так, у Микрософта тоже есть куча правил, что считается
4954.66 4957.62 "Анатолий Кулаков" брекничным, что не считается, чего не придерживаются
4957.62 4959.74 "Анатолий Кулаков" в фреймворках, в рантаймах, в компиляторах.
4959.74 4962.84 "Анатолий Кулаков" В общем, я выбрал самое интересное, давайте посмотрим, а к
4962.84 4963.84 "Анатолий Кулаков" чему же Микрософт придерживается.
4963.84 4967.04 "Анатолий Кулаков" Я думаю, что это такие рекомендации, которые, в принципе, можно
4967.04 4969.54 "Анатолий Кулаков" перетащить абсолютно в любое приложение и тоже
4969.54 4970.54 "Анатолий Кулаков" их придерживать.
4970.54 4973.90 "Анатолий Кулаков" Опять же, если вам вдруг важно сделать совместимость
4973.90 4977.54 "Анатолий Кулаков" API между чем-то и чем-то, это может быть не только
4977.54 4981.94 "Анатолий Кулаков" совместимость между C# API, большинство этих методов
4981.94 4984.82 "Анатолий Кулаков" можно натянуть, например, и на REST API, и на какие-то
4984.82 4986.94 "Анатолий Кулаков" другие виды API, которые у вас есть.
4986.94 4990.74 "Анатолий Кулаков" Но все же, мы говорим конкретно про C# и про .NET.
4990.74 4993.34 "Анатолий Кулаков" Итак, что же можно, что нельзя?
4993.34 4997.86 "Анатолий Кулаков" Ну, например, невозбранно можно удалять имплементацию
4997.86 5001.02 "Анатолий Кулаков" интерфейса из класса при том условии, что в базовом
5001.02 5002.82 "Анатолий Кулаков" классе такой интерфейс уже наследуется.
5002.82 5005.54 "Анатолий Кулаков" То есть, казалось бы, что это тоже может повлиять
5005.54 5009.82 "Анатолий Кулаков" на какой-то binary breaking change, но на самом деле нет.
5009.82 5012.34 "Анатолий Кулаков" В принципе, те методы, когда мы используем поиски интерфейсов,
5012.34 5015.34 "Анатолий Кулаков" они здесь прекрасно все сработают.
5015.34 5018.74 "Анатолий Кулаков" Несмотря ни на что, перемещать тип из одной сборки в другую
5018.74 5021.66 "Анатолий Кулаков" сборку вполне можно, никаких, кстати, проблем нет.
5021.66 5023.50 "Анатолий Кулаков" Единственная оговорка, что для этого вы должны
5023.50 5028.06 "Анатолий Кулаков" использовать специальный атрибут typeForwardedTo, атрибут,
5028.06 5030.94 "Анатолий Кулаков" в котором укажете новую сборку, куда переехал этот
5030.94 5031.94 "Анатолий Кулаков" тип.
5031.94 5035.18 "Анатолий Кулаков" На самом деле, злоупотреблять этой штукой тоже не стоит,
5035.18 5037.54 "Анатолий Кулаков" потому что Микрософт очень часто баловался, особенно
5037.54 5041.46 "Анатолий Кулаков" в первых версиях FPF, когда он перебрасывал классы
5041.46 5044.52 "Анатолий Кулаков" туда-сюда, жонглировал ими, как хотел, и всё-таки какие-то
5044.52 5047.50 "Анатолий Кулаков" проблемы с компиляциями, с совместимостями, это
5047.50 5048.50 "Анатолий Кулаков" прекрасно выходило.
5048.50 5052.30 "Анатолий Кулаков" Поэтому, если сильно надо, да, но не злоупотребляйте.
5052.30 5054.98 "Игорь Лабутин" Ну и это довольно часто использовалось в ранних
5054.98 5058.94 "Игорь Лабутин" версиях дотнет-кора, как раз когда они там, и дотнет-стандарт
5058.94 5062.50 "Игорь Лабутин" на этом во многом основан, что там что-то в дотнет-стандарте,
5062.50 5067.14 "Игорь Лабутин" что-то там typeForwardedTo в mscore-lib, и там эти типы двигались
5067.14 5069.62 "Игорь Лабутин" туда-сюда, чтобы всё это было совместимо, но тут
5069.62 5073.38 "Игорь Лабутин" было одно важное "но", которое надо понимать, что как правило
5073.38 5079.22 "Игорь Лабутин" Майкрософт typeForwarded такие типы плюс-минус между своими
5079.22 5081.54 "Игорь Лабутин" сборками, про которые они практически уверены, что
5081.54 5083.70 "Игорь Лабутин" они будут у вас в приложении, так или иначе.
5083.70 5086.70 "Игорь Лабутин" А вам нужно быть внимательным, если вы typeForwarded в какую-нибудь
5086.70 5089.42 "Игорь Лабутин" другую соседнюю сборку, то нужно убедиться, что
5089.42 5090.42 "Игорь Лабутин" эта сборка грузится.
5090.42 5094.06 "Игорь Лабутин" Я вот не уверен, что typeForwarded по-моему автоматически
5094.06 5096.22 "Игорь Лабутин" подгружает зависимую сборку, которая указана.
5096.22 5098.26 "Игорь Лабутин" Я вот чё-то сейчас не вспомню.
5098.26 5099.26 "Анатолий Кулаков" Да, я что-то тоже.
5099.26 5100.26 "Игорь Лабутин" В принципе, было бы логично.
5100.26 5101.26 "Анатолий Кулаков" Было бы логично, если она лежит рядом.
5101.26 5102.26 "Анатолий Кулаков" Тип там.
5102.26 5103.26 "Анатолий Кулаков" Надо помнить, что её нужно собрать, ну в общем вот
5103.26 5104.26 "Игорь Лабутин" это всё.
5104.26 5105.26 "Игорь Лабутин" Короче.
5105.26 5106.26 "Игорь Лабутин" Не, ну конечно.
5106.26 5107.26 "Игорь Лабутин" Можно её поискать, если она рядом, запустить.
5107.26 5108.26 "Игорь Лабутин" Если не рядом, там уже что-нибудь бросать.
5108.26 5109.26 "Анатолий Кулаков" Или искать дальше.
5109.26 5110.26 "Анатолий Кулаков" Ну короче, надо быть внимательным, да, смотрите на это.
5110.26 5121.18 "Анатолий Кулаков" Да, очевидно, что можно расширять видимость мембров
5121.18 5123.14 "Анатолий Кулаков" или тайпов, или классов, т.е. если у вас класс был
5123.14 5126.34 "Анатолий Кулаков" там private или internal, то вы можете сделать его public,
5126.34 5129.10 "Анатолий Кулаков" и это тоже не считается breaking changes, наверное, логично,
5129.10 5132.06 "Анатолий Кулаков" что это как будто появляется новый для внешнего API, для
5132.06 5134.62 "Анатолий Кулаков" внешнего потребителя, наблюдателя появляется просто-напросто
5134.62 5135.62 "Анатолий Кулаков" новый класс.
5135.62 5138.98 "Анатолий Кулаков" А вот запрещено как раз-таки наоборот, скрывать класс.
5138.98 5141.10 "Анатолий Кулаков" Если ваш класс раньше был public, то естественно его
5141.10 5144.08 "Анатолий Кулаков" мог, приложение его могло заюзать, и в своей сборке
5144.08 5146.30 "Анатолий Кулаков" вы просто так его скрыть не можете, это уже получается
5146.30 5147.30 "Анатолий Кулаков" breaking changes.
5147.30 5150.62 "Анатолий Кулаков" Т.е. вам нужно идти через какие-то шаги breaking changes,
5150.62 5155.06 "Анатолий Кулаков" через мажорные версии и т.д., через абсолит атрибуты,
5155.06 5158.34 "Анатолий Кулаков" изменять и переименовывать мемспейсы или имена классов,
5158.34 5161.14 "Анатолий Кулаков" или имена типов, или имена методов публичных, естественно,
5161.14 5163.70 "Анатолий Кулаков" вот тоже нельзя.
5163.70 5169.34 "Анатолий Кулаков" Дальше, если у вас был класс, который не помечен ключевым
5169.34 5173.30 "Анатолий Кулаков" словом silt, и вы хотите пометить его ключевым словом silt,
5173.30 5175.58 "Анатолий Кулаков" вот это тоже делать нельзя, потому что от вашего класса
5175.58 5178.06 "Анатолий Кулаков" могли в таком случае кто-то пронаследоваться, и как
5178.06 5181.10 "Анатолий Кулаков" только вы его запечатаете, этот наследник упадет,
5181.10 5182.86 "Анатолий Кулаков" это будет несовместимость.
5182.86 5186.46 "Анатолий Кулаков" Еще запрещается добавлять интерфейс в базовый таб
5186.46 5190.62 "Анатолий Кулаков" тип или наследовать интерфейс от другого интерфейса,
5190.62 5194.98 "Анатолий Кулаков" потому что это может привести к такой штуке, что те классы,
5194.98 5197.78 "Анатолий Кулаков" которые были в приложении, пронаследованные от этого
5197.78 5201.46 "Анатолий Кулаков" интерфейса, они не имплементят тех методов, которые новый
5201.46 5202.46 "Анатолий Кулаков" интерфейс добавил.
5202.46 5208.46 "Игорь Лабутин" Ну, у нас же есть дефолтные методы интерфейсов.
5208.46 5210.82 "Анатолий Кулаков" Про дефолтные методы интерфейсов здесь тоже упоминается,
5210.82 5212.82 "Анатолий Кулаков" и упоминается в контексте, что не всегда и не все их
5212.82 5215.66 "Анатолий Кулаков" поддерживают, поэтому нужно смотреть на фреймворки
5215.66 5216.66 "Анатолий Кулаков" и прочее.
5216.66 5218.38 "Игорь Лабутин" Ну да, конечно, оно поддержано только на современных
5218.38 5221.34 "Игорь Лабутин" фреймворках, плюс на самом деле, на самом деле, даже
5221.34 5227.30 "Игорь Лабутин" если вы такой, ну, кстати, это интересный момент,
5227.30 5230.74 "Игорь Лабутин" добавлять, вот смотри, есть у меня интерфейс, я добавляю
5230.74 5233.74 "Игорь Лабутин" какой-то метод, а, ну да, даже если у меня в моем
5233.74 5235.90 "Игорь Лабутин" наследнике есть такой же метод, ну окей, я как будто
5235.90 5236.90 "Игорь Лабутин" его реализовал.
5236.90 5239.90 "Игорь Лабутин" Окей, это не должно быть проблемой, если совпало
5239.90 5240.90 "Игорь Лабутин" по сигнатуре.
5240.90 5244.54 "Анатолий Кулаков" Если он у тебя совпал, то это может быть даже проблема,
5244.54 5246.58 "Анатолий Кулаков" потому что обычно, если ты добавляешь интерфейс,
5246.58 5248.54 "Анатолий Кулаков" значит, его кто-то будет дёргать, и этот кто-то будет
5248.54 5250.74 "Анатолий Кулаков" дёргать, рассчитывает на особое поведение, а совпасть
5250.74 5253.46 "Анатолий Кулаков" он у тебя с твоим наследником абсолютно случайно, и поведение
5253.46 5255.78 "Анатолий Кулаков" там будет совершенно другое, а не то, на которое рассчитывает
5255.78 5256.78 "Анатолий Кулаков" вызывающий класс.
5256.78 5259.26 "Игорь Лабутин" Особенно если ты добавляешь какой-нибудь интерфейс
5259.26 5262.38 "Игорь Лабутин" с каким-нибудь методом под названием do work или что-нибудь
5262.38 5263.38 "Игорь Лабутин" в таком духе.
5263.38 5265.94 "Игорь Лабутин" А у меня своих этих do work по проекту.
5265.94 5271.82 "Анатолий Кулаков" Вот, ещё интересная специфика есть с disposable, если ты добавляешь,
5271.82 5274.66 "Анатолий Кулаков" например, интерфейс disposable, и даже если ты его там по
5274.66 5278.58 "Анатолий Кулаков" умолчанию как-то переопределил, дефолт интерфейс имплементации
5278.58 5281.56 "Анатолий Кулаков" ему засунул, то на самом деле это не просто добавление
5281.56 5282.56 "Анатолий Кулаков" какого-то метода.
5282.56 5285.02 "Анатолий Кулаков" Это обычно декларация того, что ты начинаешь использовать
5285.02 5289.12 "Анатолий Кулаков" какие-то ресурсы, которые могут течь, и тебе недостаточно
5289.12 5292.78 "Анатолий Кулаков" просто-напросто дефолт заимплементить dispose метод.
5292.78 5296.56 "Анатолий Кулаков" Тебе нужно переделать вызывающее приложение, чтобы оно теперь
5296.56 5298.82 "Анатолий Кулаков" умело эти ресурсы освобождать.
5298.82 5302.02 "Анатолий Кулаков" Если оно этого не научится освобождать, то у тебя приложение
5302.02 5303.02 "Анатолий Кулаков" может начать тупо течь.
5303.02 5306.06 "Анатолий Кулаков" В общем, это тоже такой интересный метод, что в
5306.06 5308.14 "Анатолий Кулаков" принципе добавление disposable – это довольно большой
5308.14 5310.28 "Анатолий Кулаков" breaking change, с которым не просто перекомпилировать
5310.28 5312.92 "Анатолий Кулаков" вам надо, даже если у вас код компилится, а пойти
5312.92 5313.92 "Анатолий Кулаков" и переделать behavior.
5313.92 5316.26 "Анатолий Кулаков" Ладно, согласен, не будем добавлять.
5316.26 5317.26 "Игорь Лабутин" Окей.
5317.26 5318.26 "Игорь Лабутин" Пишем параллельный класс рядом.
5318.26 5319.26 "Анатолий Кулаков" Хорошо.
5319.26 5325.08 "Анатолий Кулаков" Так, также запрещается изменять публичные константы и
5325.08 5326.42 "Анатолий Кулаков" значения enum.
5326.42 5329.70 "Анатолий Кулаков" Если вдруг вы там константу поменяли или enum поменяли,
5329.70 5334.46 "Анатолий Кулаков" то в принципе это довольно breaking change.
5334.46 5336.74 "Анатолий Кулаков" Переименовывать параметры я уже говорил, здесь важно
5336.74 5339.22 "Анатолий Кулаков" отметить, что даже если вы просто изменяете кейс,
5339.22 5341.30 "Анатолий Кулаков" то есть в основном опечатка как это была в большой и
5341.30 5343.88 "Анатолий Кулаков" маленькой букве, и вы просто думаете, что это безобидная
5343.88 5346.62 "Анатолий Кулаков" штука – нет, это реально breaking change большой.
5346.62 5349.14 "Анатолий Кулаков" Поэтому дальше даже менять маленькие и большие буквы
5349.14 5350.14 "Анатолий Кулаков" местами не стоит.
5350.14 5354.86 "Анатолий Кулаков" Также запрещается добавлять конструктор к классу, если
5354.86 5356.34 "Анатолий Кулаков" у него до этого не было конструктора.
5356.34 5359.34 "Анатолий Кулаков" То есть по сути у него был конструктор без параметров.
5359.34 5361.46 "Анатолий Кулаков" А вы добавляете конструктор с параметрами.
5361.46 5363.54 "Анатолий Кулаков" То есть breaking change состоит в том, что раньше ваш класс
5363.54 5366.98 "Анатолий Кулаков" могли создать без параметров, а если вы добавили конструктор,
5366.98 5368.18 "Анатолий Кулаков" и у этого конструктора есть обязательный параметр,
5368.18 5370.16 "Анатолий Кулаков" то вот этот вызывающий код больше этого сделать
5370.16 5371.16 "Анатолий Кулаков" не сможет.
5371.16 5375.14 "Анатолий Кулаков" Посмотрим немножко на behavior changes.
5375.14 5377.22 "Анатолий Кулаков" Запрещается изменять имя сборки.
5377.22 5382.26 "Анатолий Кулаков" Прямо такое очень масштабное изменение, кажется, если
5382.26 5383.26 "Анатолий Кулаков" вообще имя сборки менять.
5383.26 5385.86 "Анатолий Кулаков" Но почему-то Microsoft это очень часто и много где приговаривает.
5385.86 5388.66 "Анатолий Кулаков" Наверное, люди переименовывали сборки, ренеймили, рефакторили.
5388.66 5392.12 "Игорь Лабутин" Ну а что бы нет, да, я же поменял, придумал новое
5392.12 5394.58 "Игорь Лабутин" крутое имя продукта, пусть у меня сборка теперь поменяется.
5394.58 5398.78 "Анатолий Кулаков" Да, тот пример, который ты уже упоминал, что не
5398.78 5402.06 "Анатолий Кулаков" надо тебе менять дефолтные значения или даже добавлять
5402.06 5408.02 "Анатолий Кулаков" дефолтные значения, потому что когда вы меняете или
5408.02 5410.22 "Анатолий Кулаков" добавляете, оно остается в скомпильной сборке уже.
5410.22 5415.46 "Анатолий Кулаков" Самое интересное, что это не бинарный breaking change,
5415.46 5419.34 "Анатолий Кулаков" это если изменение именно, если вы меняете дефолтное
5419.34 5421.62 "Анатолий Кулаков" значение, то никакого бинарного breaking change не будет, потому
5421.62 5423.56 "Анатолий Кулаков" что в бинарной сборке это дефолтное значение уже
5423.56 5424.56 "Анатолий Кулаков" вкомпилено.
5424.56 5427.06 "Анатолий Кулаков" Оно вкомпилено старое и этой сборки по барабану.
5427.06 5430.06 "Анатолий Кулаков" Оно будет использовать всегда старое значение.
5430.06 5432.82 "Анатолий Кулаков" Поэтому это не бинарный breaking change, это source breaking
5432.82 5433.82 "Анатолий Кулаков" change.
5433.82 5438.62 "Анатолий Кулаков" И при этом это может стать behavior breaking change, если вдруг
5438.62 5443.62 "Анатолий Кулаков" вы попытаетесь перекомпилить, оно нормально перекомпилиться,
5443.62 5445.50 "Анатолий Кулаков" или полностью измениться в зависимости от того,
5445.50 5447.38 "Анатолий Кулаков" на что вы поменяли дефолтное значение.
5447.38 5451.06 "Игорь Лабутин" Ну там смотри, мне кажется тут надо немножко по-другому
5451.06 5452.06 "Игорь Лабутин" сказать.
5452.06 5454.90 "Игорь Лабутин" То есть изменение не является source breaking change, но ты поменял
5454.90 5456.46 "Игорь Лабутин" значение к дефолтному параметру, у тебя продолжило
5456.46 5457.70 "Игорь Лабутин" всё компилиться, в чём проблема?
5457.70 5460.78 "Игорь Лабутин" Ну вот behavioral может быть, а вот удаление дефолтного
5460.78 5463.86 "Игорь Лабутин" значения точно будет source breaking change, потому что у тебя
5463.86 5464.86 "Игорь Лабутин" код не скомпилиться.
5464.86 5468.50 "Анатолий Кулаков" Да, удаление может быть абсолютно всеми breaking
5468.50 5471.42 "Анатолий Кулаков" changes, в бинарном том числе, потому что тебя попытаются
5471.42 5473.22 "Анатолий Кулаков" вызвать с каким-то параметром, который у тебя уже вообще
5473.22 5474.22 "Анатолий Кулаков" удалил.
5474.22 5475.22 "Анатолий Кулаков" Да, всё так.
5475.22 5478.78 "Игорь Лабутин" Нет, стоп, стоп, стоп, мы про дефолтные значения,
5478.78 5480.82 "Игорь Лабутин" поэтому удаление дефолтного… А, то есть ты параметр оставляешь?
5480.82 5482.86 "Игорь Лабутин" Да, удаляешь дефолтное значение, бинарно всё будет
5482.86 5485.34 "Игорь Лабутин" окей, тебя будут вызывать со своим старым дефолтным
5485.34 5486.34 "Игорь Лабутин" значением.
5486.34 5487.78 "Игорь Лабутин" У них же в компьютере… Если только дефолтное,
5487.78 5488.78 "Игорь Лабутин" то да.
5488.78 5489.78 "Игорь Лабутин" Да, да, да, да.
5489.78 5492.06 "Игорь Лабутин" Но вот source будет breaking, у тебя он не скомпилится,
5492.06 5497.18 "Игорь Лабутин" в коде нет этого параметра, вот, ну да, давай дальше.
5497.18 5499.78 "Анатолий Кулаков" Про исключения, немножко тоже интересные вещи,
5499.78 5504.46 "Анатолий Кулаков" то, что вы можете бросать исключения, если вместо
5504.46 5507.02 "Анатолий Кулаков" существующего, которое вы бросали, вы завели более
5507.02 5510.66 "Анатолий Кулаков" специфическое исключение, это не является breaking changes,
5510.66 5513.42 "Анатолий Кулаков" потому что тот код, который там мог кетчить ваши исключения,
5513.42 5515.42 "Анатолий Кулаков" но по-прежнему наследников также точно продолжит
5515.42 5517.98 "Анатолий Кулаков" кетчить, поэтому это нормально.
5517.98 5520.94 "Анатолий Кулаков" Также можно бросать не наследников, то есть не
5520.94 5525.90 "Анатолий Кулаков" более специфичные исключения в случаях, когда вы заменяете
5525.90 5530.26 "Анатолий Кулаков" одно из специальных исключений, это not supported exception, not implemented
5530.26 5533.74 "Анатолий Кулаков" and null reference exception, в общем, если ваш код раньше бросал
5533.74 5536.34 "Анатолий Кулаков" вот эти три, то, в принципе, вы их можете поменять на
5536.34 5539.38 "Анатолий Кулаков" любое другое, которое более подходит вам, ну или вообще
5539.38 5542.62 "Анатолий Кулаков" убрать эту проблему, чтобы оно не бросало этих исключений.
5542.62 5545.78 "Игорь Лабутин" Тут мне интересная подборка, то есть not supported, not implemented,
5545.78 5548.58 "Игорь Лабутин" я понимаю, ну окей, раньше я бросал, теперь я перестал,
5548.58 5551.62 "Игорь Лабутин" и, скорее всего, вряд ли код, который использует
5551.62 5555.42 "Игорь Лабутин" мою там библиотеку, будет кетчить not supported или not
5555.42 5556.42 "Игорь Лабутин" implemented.
5556.42 5557.42 "Игорь Лабутин" Но null reference.
5557.42 5560.66 "Анатолий Кулаков" Ну, на самом деле, null reference, он не сильно от них отличается,
5560.66 5564.94 "Анатолий Кулаков" потому что он имеет специальную семантику, это не то исключение,
5564.94 5567.06 "Анатолий Кулаков" которое бросается явно, это исключение, которое
5567.06 5569.22 "Анатолий Кулаков" обычно бросается рантаймом, и ты его никогда кетчить
5569.22 5572.42 "Анатолий Кулаков" не должен, потому что это полный ахтунг, его никто
5572.42 5573.42 "Игорь Лабутин" не должен отсчитывать.
5573.42 5575.86 "Игорь Лабутин" Ну, смотря какие библиотеки используешь, вдруг ты знаешь,
5575.86 5578.58 "Игорь Лабутин" что там точно будет null ref, я его закетчу.
5578.58 5581.98 "Анатолий Кулаков" Ну вот это, наверное, типа относится, что это точно
5581.98 5584.46 "Анатолий Кулаков" бага, если вы ее пофиксите, это даже, мы вам не будем
5584.46 5585.46 "Анатолий Кулаков" считать это брейккетчатчаткой.
5585.46 5587.78 "Игорь Лабутин" Ну да, наверное, ты прав.
5587.78 5590.34 "Анатолий Кулаков" Также точно у нас есть еще одно интересное исключение,
5590.34 5595.78 "Анатолий Кулаков" которое называется unrecoverable, это access violation, execution engine
5595.78 5601.58 "Анатолий Кулаков" exception и ceh exception, в общем, их тоже как бы разрешается
5601.58 5602.58 "Анатолий Кулаков" заменять.
5602.58 5603.58 "Анатолий Кулаков" Это тоже нормально.
5603.58 5607.74 "Анатолий Кулаков" И также разрешается, в принципе, вполне вообще удалять
5607.74 5609.90 "Анатолий Кулаков" исключения, если они у вас там были, если вы вдруг
5609.90 5612.46 "Анатолий Кулаков" вместо этого исключения добавите какую-нибудь обработку
5612.46 5615.34 "Анатолий Кулаков" какого-то сценария, делайте какое-то новое поведение,
5615.34 5617.06 "Анатолий Кулаков" которое все-таки решит вам проблему без выбрасывания
5617.06 5619.58 "Анатолий Кулаков" исключений, это тоже не считается breaking changes.
5619.58 5623.14 "Игорь Лабутин" Вот, это что Microsoft сделала с этим unobservable task, было
5623.14 5625.26 "Игорь Лабутин" исключение, нет исключения?
5625.26 5627.46 "Анатолий Кулаков" Ну там проблема была не в исключении, там проблема
5627.46 5629.18 "Анатолий Кулаков" была в том, что приложение завершалось.
5629.18 5630.18 "Анатолий Кулаков" Ну это еще круче.
5630.18 5632.14 "Анатолий Кулаков" У тебя была завязана, у тебя вполне могла быть завязана
5632.14 5635.02 "Анатолий Кулаков" логика на то, что выполняя этот метод, мое приложение
5635.02 5637.30 "Анатолий Кулаков" завершается, и это какой-то флаг, что вот моя логика
5637.30 5639.18 "Анатолий Кулаков" прошла правильно или неправильно.
5639.18 5642.82 "Игорь Лабутин" У нас за счет этого перезапускалось наше приложение, там раз
5642.82 5645.94 "Игорь Лабутин" в сутки падало в кубере, и кубер все сам перезапускал.
5645.94 5648.18 "Игорь Лабутин" А теперь вы подхиксили, и у нас приложение жрет
5648.18 5649.18 "Игорь Лабутин" память.
5649.18 5652.06 "Анатолий Кулаков" Представляешь, оно могло бы запускаться по таймеру,
5652.06 5654.70 "Анатолий Кулаков" типа мое приложение должно запускаться там раз в сутки,
5654.70 5657.46 "Анатолий Кулаков" работать одну минуту, падать на вот этом исключении,
5657.46 5659.50 "Анатолий Кулаков" а потом я запущу его еще раз через сутки.
5659.50 5661.98 "Анатолий Кулаков" А если оно прекратит падать, то у меня через месяц будет
5661.98 5663.82 "Анатолий Кулаков" 30 приложений там работать.
5663.82 5666.38 "Анатолий Кулаков" Вот тебе, пожалуй, утечка ресурсов, как бы.
5666.38 5670.42 "Игорь Лабутин" Это проблема, да.
5670.42 5672.46 "Анатолий Кулаков" Такие подобные рекомендации у Микрософта есть практически
5672.46 5676.50 "Анатолий Кулаков" в каждом репозитории, они более или менее одинаковые,
5676.50 5679.18 "Анатолий Кулаков" могут отличаться в мелочах, но в общем концепция вот
5679.18 5680.18 "Анатолий Кулаков" такая.
5680.18 5682.42 "Анатолий Кулаков" Посмотрите на свои приложения, возможно, если вы пишете
5682.42 5684.90 "Анатолий Кулаков" библиотеку, вам тоже эти рекомендации будут полезны.
5684.90 5687.66 "Анатолий Кулаков" Ссылки на конкретные описания я, естественно, рассказал
5687.66 5690.50 "Анатолий Кулаков" не про всех, есть намного больше и намного интереснее.
5690.50 5692.70 "Анатолий Кулаков" В общем, ссылки будут, как всегда, в шоу-ноутах.
5692.70 5695.10 "Игорь Лабутин" А мы пойдем дальше, и мы не будем далеко уходить
5695.10 5697.70 "Игорь Лабутин" с темы breaking changes, потому что Майкрософт для того,
5697.70 5702.52 "Игорь Лабутин" чтобы поддерживать свою, так сказать, понимание того,
5702.52 5706.18 "Игорь Лабутин" а что же у них входит в тот самый список breaking changes,
5706.18 5710.10 "Игорь Лабутин" а как вы понимаете, у Майкрософта библиотек полно, и это в
5710.10 5714.10 "Игорь Лабутин" ваших, возможно, не очень больших библиотеках, просто
5714.10 5719.18 "Игорь Лабутин" понять, да, что мы там поменяли в одну или две руки за время
5719.18 5721.54 "Игорь Лабутин" прошедшего, с прошлого релиза, то у Майкрософта
5721.54 5725.02 "Игорь Лабутин" там работают огромные команды, там есть куча комьюнити-контрибьюторов,
5725.02 5728.14 "Игорь Лабутин" и за всем этим уследить на самом деле довольно сложно.
5728.14 5732.78 "Игорь Лабутин" Поэтому как бы нам хотя бы понять, а что поменялось
5732.78 5734.86 "Игорь Лабутин" от версии к версии, вот.
5734.86 5738.22 "Анатолий Кулаков" Ну даже смотри, не что поменялось, а что поменялось в публичном
5738.22 5741.14 "Анатолий Кулаков" API, т.е. что является breaking changes для наших потребителей.
5741.14 5744.50 "Игорь Лабутин" Да, хотя бы это, понятно, что мы так не можем, наверное,
5744.50 5747.06 "Игорь Лабутин" отловить все типы, как мы говорим, да, какой-нибудь
5747.06 5751.26 "Игорь Лабутин" там behavioral мы точно не отловим, но хотя бы понять, как меняется
5751.26 5756.06 "Игорь Лабутин" public API surface, чтобы, возможно, это можно исслужить источником,
5756.06 5759.00 "Игорь Лабутин" например, для новой документации, т.е. окей, мы зачем-то добавили
5759.00 5761.94 "Игорь Лабутин" новые public API методы, значит, нужно их документировать,
5761.94 5764.46 "Игорь Лабутин" или наоборот, мы что-то убрали, значит, нужно там
5764.46 5767.18 "Игорь Лабутин" как минимум убрать документацию с сайта или там, не знаю,
5767.18 5769.66 "Игорь Лабутин" пометить, что оно теперь все обсолит, и предложить
5769.66 5770.66 "Игорь Лабутин" альтернативы.
5770.66 5773.02 "Игорь Лабутин" Короче, надо как-то это все менеджить, можно это
5773.02 5777.34 "Игорь Лабутин" менеджить руками, можно это менеджить более, так
5777.34 5781.36 "Игорь Лабутин" скажем, автоматизированным способом, и для этого у
5781.36 5786.06 "Игорь Лабутин" Microsoft, опять же, есть решение, которое, в принципе, используется
5786.06 5787.06 "Игорь Лабутин" внутри Microsoft.
5787.06 5791.54 "Игорь Лабутин" Я это видел только, скажем так, в хорошо описанном
5791.54 5795.02 "Игорь Лабутин" виде, я это видел в информовском репозитории, и почему-то
5795.02 5797.30 "Игорь Лабутин" оттуда про него узнал, потом, как бы, я посмотрел, что,
5797.30 5801.94 "Игорь Лабутин" по-моему, оно есть почти везде в Microsoft, ну, типа в
5801.94 5802.94 "Игорь Лабутин" .NET репозиториях.
5802.94 5807.14 "Игорь Лабутин" Но, тем не менее, смотрите, значит, это все только и
5807.14 5810.42 "Игорь Лабутин" речь идет про пабликапи, значит, что такое пабликапи?
5810.42 5813.48 "Игорь Лабутин" Пабликапи — это набор типов и мемберов, только те, которые
5813.48 5814.78 "Игорь Лабутин" помечены как паблик.
5814.78 5817.14 "Игорь Лабутин" Мы не рассматриваем пока internal, которые технически
5817.14 5819.14 "Игорь Лабутин" могут быть тоже доступны каким-то сборком через
5819.14 5822.34 "Игорь Лабутин" internal с Visible2, например, это мы все не смотрим, мы смотрим
5822.34 5823.34 "Игорь Лабутин" только пабликштуки.
5823.34 5827.70 "Игорь Лабутин" Значит, что такое, что мы сможем отслеживать тем
5827.70 5829.58 "Игорь Лабутин" механизмом, который здесь предлагается?
5829.58 5833.02 "Игорь Лабутин" Значит, мы сможем отслеживать добавление или удаление
5833.02 5837.78 "Игорь Лабутин" новых пабликтайпов или их мемберов, мы можем отслеживать
5837.78 5841.02 "Игорь Лабутин" какое-то изменение, добавление или удаление параметров,
5841.02 5843.26 "Игорь Лабутин" и мы сможем отслеживать изменение типа параметра.
5843.26 5845.38 "Игорь Лабутин" Мы не сможем отслеживать переименование параметров
5845.38 5848.46 "Игорь Лабутин" или еще что-то такого, но, по крайней мере, вот такие
5848.46 5851.14 "Игорь Лабутин" большие и важные changes мы сможем понять.
5851.14 5857.38 "Игорь Лабутин" Соответственно, при этом, как мы вот поговорили, что
5857.38 5860.58 "Игорь Лабутин" вроде как добавление нового типа — это никак не breaking
5860.58 5863.50 "Игорь Лабутин" change, но, тем не менее, даже, как я сказал, этот факт
5863.50 5866.24 "Игорь Лабутин" может быть важен для того, чтобы отобразить что-то
5866.24 5870.46 "Игорь Лабутин" в документации, плюс иногда мы можем подумать, что мы
5870.46 5873.30 "Игорь Лабутин" добавили новый тип, надо не забыть, например, какой-то
5873.30 5876.54 "Игорь Лабутин" старый пометить как абсолет, это же тоже можно забыть,
5876.54 5879.02 "Игорь Лабутин" по сути, мы же новый добавили, что-то потестировали, решили,
5879.02 5881.70 "Игорь Лабутин" что да, он окей, он хорошо, он пойдет в новую версию,
5881.70 5884.46 "Игорь Лабутин" и надо не забыть бы по-хорошему разрисовать абсолет-атрибуты
5884.46 5888.10 "Игорь Лабутин" на старых, если мы хотим.
5888.10 5892.54 "Игорь Лабутин" И второй и третий какой-то уже пункт по счету, еще
5892.54 5894.98 "Игорь Лабутин" интересный момент, вот можете ли вы для своей библиотеки
5894.98 5898.54 "Игорь Лабутин" сходу сказать, какие public методы и public классы из нее
5898.54 5899.54 "Игорь Лабутин" торчат?
5899.54 5901.66 "Игорь Лабутин" С хорошей вероятностью оттуда торчит очень много
5901.66 5904.14 "Игорь Лабутин" всего, что, может быть, вы как автор библиотеки не
5904.14 5908.66 "Игорь Лабутин" хотели бы показывать наружу, то есть далеко не все по
5908.66 5911.50 "Игорь Лабутин" дефолту пишут, допустим, internal классы, да, и сознательно
5911.50 5914.58 "Игорь Лабутин" пабликом делают только тот контракт, который нужно.
5914.58 5916.66 "Анатолий Кулаков" А это правильное поведение?
5916.66 5917.66 "Игорь Лабутин" Ну конечно.
5917.66 5918.66 "Игорь Лабутин" Так надо делать?
5918.66 5922.18 "Игорь Лабутин" Так надо делать, но в среднем, я думаю, что 90% народу, если
5922.18 5926.30 "Игорь Лабутин" не 99, 9, 9, 9, тупо всегда пишут паблик, класс и т.д. и особо
5926.30 5927.30 "Игорь Лабутин" не парятся.
5927.30 5929.54 "Анатолий Кулаков" Я надеюсь, среди наших слушателей таких нет.
5929.54 5934.82 "Анатолий Кулаков" Если есть, то срочно идете в сниппеты Visual Studio или
5934.82 5939.32 "Анатолий Кулаков" Райдера, меняете там сниппет класс на слово internal, и тогда
5939.32 5942.94 "Анатолий Кулаков" ваша жизнь сразу превращается в безопасную, красивую
5942.94 5945.02 "Анатолий Кулаков" и полностью контролируемую публичную API.
5945.02 5947.22 "Игорь Лабутин" Я тебе страшное скажу, надеюсь, что после этого подкаст
5947.22 5950.18 "Игорь Лабутин" не станет моноподкастом, но даже среди ведущих такие
5950.18 5951.18 "Игорь Лабутин" есть.
5951.18 5955.10 "Игорь Лабутин" Я в среднем все пишу пабликом, вот, internal почти никогда
5955.10 5956.10 "Игорь Лабутин" не использую.
5956.10 5957.10 "Игорь Лабутин" Вот.
5957.10 5960.50 "Анатолий Кулаков" Это, кстати, еще сильно ускоряет скорость работы
5960.50 5963.22 "Анатолий Кулаков" анализаторов публичных в студии, и поэтому тебя
5963.22 5965.66 "Анатолий Кулаков" студия перестает тормозить, и сборки анализируются
5965.66 5967.98 "Анатолий Кулаков" легче, и компилятор лучше работает, так что там очень
5967.98 5968.98 "Игорь Лабутин" много плюсов.
5968.98 5969.98 "Игорь Лабутин" Попробуй.
5969.98 5970.98 "Игорь Лабутин" Провал летает хорошо, так что нормально.
5970.98 5971.98 "Игорь Лабутин" Зальем железом, да, типичный бекендер.
5971.98 5972.98 "Игорь Лабутин" Да-да-да.
5972.98 5973.98 "Игорь Лабутин" Все так.
5973.98 5977.54 "Игорь Лабутин" Нет, на самом деле штука действительно полезная.
5977.54 5980.90 "Игорь Лабутин" Надо понимать, это очень важно, если вы пишете именно
5980.90 5984.34 "Игорь Лабутин" прям публично что-то, библиотечки на GitHub еще в таком духе
5984.34 5987.70 "Игорь Лабутин" или библиотечки для переиспользования в большом количестве проектов,
5987.70 5988.70 "Игорь Лабутин" там это суперважно.
5988.70 5990.56 "Игорь Лабутин" Там понятно, что внутри продукта, если у вас там
5990.56 5992.94 "Игорь Лабутин" просто пара нугет-пакетов чисто для удобства в шарении
5992.94 5995.02 "Игорь Лабутин" кода, это может быть не так принципиально, но тоже
5995.02 5997.46 "Игорь Лабутин" полезно, хотя бы даже с точки зрения скорости.
5997.46 6002.18 "Игорь Лабутин" Так вот, во-первых, статья, на которой у нас есть в
6002.18 6004.38 "Игорь Лабутин" шоу-ноутах, ссылается про то, что, во-первых, надо
6004.38 6006.90 "Игорь Лабутин" понять, что вы хотите включить в пабликапе, как его задизайнить.
6006.90 6008.82 "Игорь Лабутин" На эту тему есть огромное количество всяких разных
6008.82 6012.10 "Игорь Лабутин" документов, там книжка Framework Design Guidelines от ребят,
6012.10 6014.94 "Игорь Лабутин" которые когда-то проектировали первые версии дотной тапи.
6014.94 6018.86 "Игорь Лабутин" Майкрософтские доки текущие, все эти ссылки есть в той
6018.86 6021.42 "Игорь Лабутин" статье, на которую мы ссылаемся, можете посмотреть там,
6021.42 6023.30 "Игорь Лабутин" сейчас не будем детально углубляться.
6023.30 6025.82 "Игорь Лабутин" Так вот вопрос, как же нам, собственно, следить за
6025.82 6028.30 "Игорь Лабутин" тем, что у нас входит в пабликапе и как это все меняется.
6028.30 6032.14 "Игорь Лабутин" У Майкрософта есть специальный аналайзер, точнее, ну, пакет,
6032.14 6034.86 "Игорь Лабутин" да, который является родственным аналайзером, называется
6034.86 6040.66 "Игорь Лабутин" microsoft.codeanalysis.publicapi-analyzers, который, по сути, делается
6040.66 6041.66 "Игорь Лабутин" следующим образом.
6041.66 6044.94 "Игорь Лабутин" Он требует, чтобы весь ваш пабликапи был описан в
6044.94 6045.94 "Игорь Лабутин" текстовых файлах.
6045.94 6050.58 "Игорь Лабутин" Значит, у вас есть, что вы делаете?
6050.58 6054.38 "Игорь Лабутин" Во-первых, вы добавляете этот пакет, он чисто compile
6054.38 6056.58 "Игорь Лабутин" time, грубо говоря, поэтому ему нужно сказать private
6056.58 6060.54 "Игорь Лабутин" assets all, чтобы паблиш-папочку не шло, от него ничего не
6060.54 6061.54 "Игорь Лабутин" нужно.
6061.54 6066.26 "Игорь Лабутин" Вы создаете два файлика, один называется publicapi.shipped.txt,
6066.26 6068.22 "Игорь Лабутин" другой publicapi.unshipped.txt.
6068.22 6075.66 "Игорь Лабутин" Вот, если вам нужно вдруг, зачем-то, у вас разные пабликапи
6075.66 6078.70 "Игорь Лабутин" для разных target-фреймворков, ну, это можно через ифы,
6078.70 6083.86 "Игорь Лабутин" соответственно, сделать, как надо.
6083.86 6089.26 "Игорь Лабутин" Включаете эти файлики в ваш csproj через additional files.
6089.26 6094.14 "Игорь Лабутин" Если вы используете nullable-reference-type, то в начале этих двух файлов
6094.14 6099.42 "Игорь Лабутин" нужно добавить nullable-enable, ну, решетка nullable-enable, тогда
6099.42 6102.30 "Игорь Лабутин" аналайзер будет понимать, что вы, он еще будет аналабилити
6102.30 6104.82 "Игорь Лабутин" учитывать при всяких изменениях.
6104.82 6106.98 "Игорь Лабутин" Ну и дальше, как это все работает?
6106.98 6109.18 "Игорь Лабутин" Значит, файлик, который имеет в своем названии
6109.18 6118.06 "Игорь Лабутин" shipped.txt, это список тех пабликапи, которые сейчас, текущая
6118.06 6121.22 "Игорь Лабутин" версия вашей запаблишенной библиотеки, последняя,
6121.22 6123.10 "Игорь Лабутин" считается, так сказать, актуальной.
6123.10 6126.62 "Игорь Лабутин" То есть это то, что видят ваши кастомеры.
6126.62 6131.62 "Игорь Лабутин" Unshipped – это то, что у вас кастомеры могут видеть
6131.62 6135.50 "Игорь Лабутин" в каких-то текущих версиях, то есть, например, какие-то
6135.50 6139.58 "Игорь Лабутин" пабликапи, еще что-то, и при этом там же входит,
6139.58 6140.58 "Игорь Лабутин" например, абсолетный.
6140.58 6143.42 "Игорь Лабутин" То есть они уже, они как бы, хотелось бы, чтобы их
6143.42 6145.86 "Игорь Лабутин" не было видно, но они пока видны, поэтому считаем
6145.86 6148.58 "Игорь Лабутин" их, что они такие, unshipped.
6148.58 6151.46 "Игорь Лабутин" Значит, что будет делать аналайзер?
6151.46 6155.30 "Игорь Лабутин" Аналайзер будет показывать ворнинги во время сборки,
6155.30 6160.26 "Игорь Лабутин" ну, где он там у вас вызывается, в какой момент, если он
6160.26 6164.10 "Игорь Лабутин" увидит какой-то пабликапи, который не присутствует
6164.10 6165.34 "Игорь Лабутин" ни в одном из этих файлов.
6165.34 6169.18 "Игорь Лабутин" То есть, грубо говоря, если вы создадите просто эти
6169.18 6174.94 "Игорь Лабутин" пустые файлики, вот, и откроете ваш solution с этим аналайзером,
6174.94 6176.74 "Игорь Лабутин" то аналайзер, по идее, все ваши пабликапи должен
6176.74 6179.10 "Игорь Лабутин" аккуратно по каждым по ним подсветить и выдать
6179.10 6182.94 "Игорь Лабутин" специальную диагностику RS0016 со словами, что, типа,
6182.94 6184.46 "Игорь Лабутин" вот это пабликапи, но его нет в файлике.
6184.46 6186.02 "Игорь Лабутин" Может, вы не знаете про то, что это у вас торчит
6186.02 6187.02 "Игорь Лабутин" наружу.
6187.02 6191.38 "Игорь Лабутин" Если вы пользуетесь Visual Studio, для этой проблемы
6191.38 6197.58 "Игорь Лабутин" есть global fix, вы можете сказать fix, и тогда все эти пабликапи
6197.58 6201.46 "Игорь Лабутин" попадут в файлик unshift, вот, автоматически.
6201.46 6204.14 "Игорь Лабутин" Либо это можно сделать через command-line, сказать do net format
6204.14 6209.82 "Игорь Лабутин" analyzers --diagnostics=rs0016, то есть отдельную диагностику
6209.82 6214.98 "Игорь Лабутин" конкретно вызвать, и он автоматически проапдейтит
6214.98 6215.98 "Игорь Лабутин" publicapi.unshift.txt.
6215.98 6219.66 "Игорь Лабутин" Если вы пользуетесь райдером, в райдере есть там проблема
6219.66 6222.54 "Игорь Лабутин" с global fix, так что пофиксить это прямо из EDE, поэтому
6222.54 6223.98 "Игорь Лабутин" там только command-line пока работает.
6223.98 6227.62 "Игорь Лабутин" Может быть, уже пофиксили, но вот там, когда я это читал
6227.62 6229.02 "Игорь Лабутин" статью, еще не было пофикшено.
6229.02 6233.38 "Игорь Лабутин" В итоге, что вы получаете после этого в этот момент?
6233.38 6237.38 "Игорь Лабутин" У вас получается, что у вас есть файлик publicapi.unshift,
6237.38 6239.70 "Игорь Лабутин" в котором написаны, допустим, вы только-только вот первую
6239.70 6242.38 "Игорь Лабутин" версию библиотечки делаете, в котором написаны все
6242.38 6246.82 "Игорь Лабутин" ваши эти самые пабликапи, которые потенциально могут
6246.82 6251.50 "Игорь Лабутин" быть видны пользователю, и в момент, когда вы релизите
6251.50 6255.66 "Игорь Лабутин" вашу библиотеку, вы, собственно, перемещаете те пабликапи,
6255.66 6262.94 "Игорь Лабутин" которые вы имеете в файлик, в unshift, соответственно,
6262.94 6268.42 "Игорь Лабутин" при этом у вас может быть так, что какие-то пабликапишки
6268.42 6269.42 "Игорь Лабутин" удалились.
6269.42 6271.50 "Игорь Лабутин" То есть у вас была пишка, но при этом удалилась, если
6271.50 6274.10 "Игорь Лабутин" вы не первую версию уже релизите, а на лазер такие
6274.10 6279.18 "Игорь Лабутин" строчки в unshift файлики пометит звездочка removed в начале,
6279.18 6283.38 "Игорь Лабутин" и вы будете понимать, что, в общем, по сути, что получается,
6283.38 6285.50 "Игорь Лабутин" что вам в момент релиза нужно взять все, что лежит
6285.50 6289.86 "Игорь Лабутин" в unshift, понять, что там добавилось, что там удалилось, и сообразно
6289.86 6292.46 "Игорь Лабутин" этом, во-первых, перенести эти изменения в файлик
6292.46 6295.06 "Игорь Лабутин" shift, ну, удалив там нужные версии, нужные строчки
6295.06 6298.66 "Игорь Лабутин" или добавив новые, и по каждой из этих строчек обновить
6298.66 6299.66 "Игорь Лабутин" документацию.
6299.66 6300.66 "Игорь Лабутин" Так делает Microsoft.
6300.66 6302.66 "Игорь Лабутин" Они, соответственно, проверяют таким образом, во-первых,
6302.66 6304.66 "Игорь Лабутин" чтобы не было никаких surface, а во-вторых, чтобы ничего
6304.66 6305.66 "Игорь Лабутин" не забыть для обновления документации.
6305.66 6307.66 "Игорь Лабутин" Ну и дальше вы это все пометите, понятно, в репозитории,
6307.66 6310.34 "Игорь Лабутин" эти два файлика лежат в репозитории, и начинаете
6310.34 6312.18 "Игорь Лабутин" работу на следующей версии, потихонечку накапливая
6312.18 6314.78 "Игорь Лабутин" очередные изменения в unshift файлики до следующего
6314.78 6315.78 "Игорь Лабутин" релиза.
6315.78 6318.86 "Игорь Лабутин" И таким образом у вас получается некоторый процесс работы.
6318.86 6322.98 "Анатолий Кулаков" То есть эта штука заставляет вас контролировать, какие
6322.98 6326.74 "Анатолий Кулаков" API вы добавляете, какие удаляете, и, самое главное, изменяете.
6326.74 6327.74 "Анатолий Кулаков" Да.
6327.74 6330.14 "Анатолий Кулаков" Что если вдруг вы увидите в одном месте, в единственном
6330.14 6333.02 "Анатолий Кулаков" месте, вот в этом текстовом файлике, что вас взял API,
6333.02 6336.94 "Анатолий Кулаков" один удалился или один переименовался, то вы, соответственно,
6336.94 6339.22 "Анатолий Кулаков" сразу задаетесь вопросом – а это breaking changes?
6339.22 6342.54 "Анатолий Кулаков" Давайте мы подумаем, а точно ли он нам нужен, или мы его
6342.54 6344.38 "Анатолий Кулаков" отнесем на какое-нибудь мажор изменения.
6344.38 6347.06 "Анатолий Кулаков" В общем, здесь вы уже полностью можете контролировать
6347.06 6349.38 "Анатолий Кулаков" и управлять жизненным циклом вашего API, то есть, грубо
6349.38 6352.54 "Анатолий Кулаков" говоря, гарантировать, что ваш API, по крайней мере
6352.54 6357.14 "Анатолий Кулаков" хотя бы на source breaking changes, он будет совместим с тем,
6357.14 6359.54 "Анатолий Кулаков" на что рассчитывают ваши клиенты, ваши кастомеры.
6359.54 6362.30 "Игорь Лабутин" Ну, возможно, не полностью, потому что он там не учитывает
6362.30 6364.70 "Игорь Лабутин" всякие дефолтные параметры и вот это всё, то есть там
6364.70 6368.90 "Игорь Лабутин" 100% полноценный сурс совместимости не будет, но хоть что-то
6368.90 6369.90 "Игорь Лабутин" это уже хорошо.
6369.90 6372.10 "Игорь Лабутин" Лучше, чем совсем ничего, когда вы просто реализуете
6372.10 6374.58 "Игорь Лабутин" новую версию, словом, да, ладно, наверное, совместимо.
6374.58 6377.10 "Анатолий Кулаков" Ну, я думаю, слушай, там технически, мне кажется,
6377.10 6379.62 "Анатолий Кулаков" никаких проблем нету довести его до 100% совместимости.
6379.62 6380.62 "Игорь Лабутин" Ну, наверное.
6380.62 6383.26 "Игорь Лабутин" Скорее всего аналозик где-нибудь в open-source лежит у Microsoft,
6383.26 6385.82 "Игорь Лабутин" поэтому, наверное, его можно найти, посмотреть, как оно
6385.82 6386.82 "Игорь Лабутин" работает внутри.
6386.82 6390.54 "Игорь Лабутин" Я, кстати, заглядывал в исходники, там всё довольно
6390.54 6394.46 "Игорь Лабутин" примитивно и прямолинейно, в каком-то смысле, и поэтому
6394.46 6397.34 "Игорь Лабутин" можно просто посмотреть, да, дописать, если что-то
6397.34 6398.34 "Анатолий Кулаков" надо.
6398.34 6399.34 "Анатолий Кулаков" Угу, гуд.
6399.34 6400.54 "Анатолий Кулаков" Погнали, хочется влезть, как бы, в меньше 2-х часов
6400.54 6403.54 "Анатолий Кулаков" всё-таки, хотя бы в этом выпуске.
6403.54 6404.54 "Игорь Лабутин" Давай попробуем, давай попробуем.
6404.54 6406.42 "Анатолий Кулаков" Поэтому бегом, бегом, бегом, бегом, а бегом опять не
6406.42 6408.62 "Анатолий Кулаков" получится, потому что шикарная новость, про которую надо
6408.62 6410.66 "Анатолий Кулаков" срочно поговорить ещё часок.
6410.66 6414.70 "Анатолий Кулаков" Дело в том, что команда Donaturu Translate выпустила новый
6414.70 6415.70 "Анатолий Кулаков" перевод книги.
6415.70 6419.86 "Анатолий Кулаков" Я напомню, что у нас есть специальная команда добровольцев,
6419.86 6424.58 "Анатолий Кулаков" которая делает русский язык снова великим и редактирует
6424.58 6429.26 "Анатолий Кулаков" книги, технические книги по C#, по .NET, редактирует
6429.26 6432.14 "Анатолий Кулаков" переводы английские на русский язык так, чтобы
6432.14 6435.30 "Анатолий Кулаков" их было приятно читать, приятно запоминать и приятно
6435.30 6436.30 "Анатолий Кулаков" обсуждать с коллегами.
6436.30 6439.30 "Анатолий Кулаков" То есть с хорошим, нормальным, хорошим, качественным переводом.
6439.30 6442.74 "Анатолий Кулаков" И вот команда выпустила ещё одну книгу, это уже пятая
6442.74 6444.46 "Анатолий Кулаков" книга, которая у нас есть, которая называется «Блейзер
6444.46 6445.74 "Анатолий Кулаков" в действии».
6445.74 6448.94 "Игорь Лабутин" Ну, как вы понимаете, исходное название «Блейзер in action»
6448.94 6449.94 "Игорь Лабутин" – «в действии».
6449.94 6450.94 "Игорь Лабутин" Не пригласим.
6450.94 6455.22 "Игорь Лабутин" Ну да-да-да, над названием мы не работали, это перевод
6455.22 6456.22 "Игорь Лабутин" издательства.
6456.22 6458.62 "Игорь Лабутин" Причём, на самом деле, по-моему, это так и есть же, по-моему,
6458.62 6459.90 "Игорь Лабутин" издательство само создаёт.
6459.90 6464.02 "Анатолий Кулаков" Ну по-моему, она серия же, это же серия, поэтому серия
6464.02 6466.46 "Анатолий Кулаков" по-русски уже называется «в действии», тут уже ничего
6466.46 6467.46 "Анатолий Кулаков" не поделаешь.
6467.46 6468.46 "Анатолий Кулаков" Мы ничего не можем сделать, да.
6468.46 6469.86 "Анатолий Кулаков" Устоявшиеся сочетания.
6469.86 6474.50 "Игорь Лабутин" Книжка действительно хорошая, понятная, я особо Блейзером
6474.50 6478.16 "Игорь Лабутин" не занимаюсь, ни на работе, ни для себя, но прочитав
6478.16 6480.86 "Игорь Лабутин" её, пока мы её, собственно, вычитывали, в принципе,
6480.86 6483.74 "Игорь Лабутин" всё прекрасно понятно и здорово.
6483.74 6486.22 "Игорь Лабутин" Могу сразу сказать, что, конечно, скорее всего она
6486.22 6489.18 "Игорь Лабутин" уже устарела после выхода 2008, там наверняка что-нибудь
6489.18 6491.94 "Игорь Лабутин" новенького придумали и что-то поменяли, но базовые
6491.94 6494.38 "Игорь Лабутин" концепции никуда не делись, и если вы занимаетесь или
6494.38 6497.70 "Игорь Лабутин" хотите заниматься Блейзером, я думаю, что вы смело можете
6497.70 6501.82 "Игорь Лабутин" её брать и по ней изучать, что, как работает в Блейзере,
6501.82 6504.74 "Игорь Лабутин" а потом по каким-то уже статьям выяснять, что в
6504.74 6505.74 "Игорь Лабутин" «восьмёрке» поменяли.
6505.74 6508.02 "Анатолий Кулаков" Ну, я тоже думаю, что она не настолько критично
6508.02 6510.80 "Анатолий Кулаков" поменялась, что прям книжка совсем даже на какой-то
6510.80 6512.82 "Анатолий Кулаков" процент ставилась, стала неактуальной.
6512.82 6515.30 "Анатолий Кулаков" Актуальность в ней есть, естественно, за новинками
6515.30 6516.30 "Анатолий Кулаков" нужно следить.
6516.30 6519.62 "Анатолий Кулаков" В общем, ну и чтобы следить за новинками было удобнее
6519.62 6523.98 "Анатолий Кулаков" и сподручнее, у нас есть промокод на скидку 25% прямо
6523.98 6526.38 "Анатолий Кулаков" на сайте издательства, т.е. вы напрямую покупаете
6526.38 6530.62 "Анатолий Кулаков" у издательства, и плюс сверху получаете ещё 25% от нас.
6530.62 6533.94 "Анатолий Кулаков" Промокод найдёте по ссылочке, а также всю дополнительную
6533.94 6536.02 "Анатолий Кулаков" информацию, если вы вдруг захотите участвовать в
6536.02 6538.50 "Анатолий Кулаков" наших будущих переводах или просто хотите поделиться
6538.50 6542.18 "Анатолий Кулаков" мнением о книге с переводчиками, которые всё это отлаживали
6542.18 6545.38 "Анатолий Кулаков" и вычитывали, вот тоже заходите, там все ссылки есть, заходите
6545.38 6548.06 "Анатолий Кулаков" в наш Telegram-чатик, мы с радостью примем любой фидбэк от
6548.06 6549.06 "Анатолий Кулаков" вас.
6549.06 6553.70 "Анатолий Кулаков" Так, давай дальше, давай посмотрим, что у нас в коротко-разном
6553.70 6554.70 "Анатолий Кулаков" есть.
6554.70 6556.86 "Анатолий Кулаков" У нас много ли у нас вообще короткого?
6556.86 6560.02 "Игорь Лабутин" Да, кратко-разном у нас, конечно же, есть, и в этот
6560.02 6564.54 "Игорь Лабутин" момент, не знаю, насколько будет кратко, но точно разным.
6564.54 6568.02 "Анатолий Кулаков" Так, у нас буквально счёт на минуты, поэтому не затягивай.
6568.02 6570.66 "Игорь Лабутин" Не-не-не, магии монтажа я потом попробую сделать
6570.66 6572.98 "Игорь Лабутин" меньше двух часов, но не обещаю, не обещаю, будет
6572.98 6576.22 "Игорь Лабутин" опять больше двух, но ничего страшного, ладно, слушай,
6576.22 6579.14 "Игорь Лабутин" больше тутнета, больше хорошего контента по тутнету, не
6579.14 6580.14 "Игорь Лабутин" страшно.
6580.14 6584.06 "Игорь Лабутин" Поехали, сначала немножко про релизы, они никак не
6584.06 6586.54 "Игорь Лабутин" связаны, просто мне попались на глаза релизы, поэтому
6586.54 6587.70 "Игорь Лабутин" я про них решил рассказать.
6587.70 6593.42 "Игорь Лабутин" Unoplatform, если вы хотите кроссплатформенный UI, и он вам зачем-то вдруг
6593.42 6596.26 "Игорь Лабутин" потребовался на Unoplatform, Unoplatform вышла версия 5.0,
6596.26 6599.94 "Игорь Лабутин" она приурочена к восьмерке, она довольно прикольная,
6599.94 6602.30 "Игорь Лабутин" они сделали, во-первых, штука такая у них была,
6602.30 6603.86 "Игорь Лабутин" насколько я понимаю, в прошлых версиях, они её сильно
6603.86 6606.54 "Игорь Лабутин" улучшили, это C# маркап, если вы не хотите писать
6606.54 6609.30 "Игорь Лабутин" на XAML, вы можете писать то же самое, но на C#, там
6609.30 6614.30 "Игорь Лабутин" есть такой mini DSL на C# в таком fluent стиле, где можно описать
6614.30 6616.62 "Игорь Лабутин" всё то же самое, ну плюс-минус всё то же самое, что вы пишете
6616.62 6617.62 "Игорь Лабутин" на XAML.
6617.62 6618.62 "Игорь Лабутин" Но на C#.
6618.62 6621.98 "Игорь Лабутин" Казалось бы, зачем это может потребоваться, а, например,
6621.98 6623.86 "Игорь Лабутин" это может потребоваться, потому что у них есть плагин
6623.86 6627.94 "Игорь Лабутин" к Figma, вы рисуете в Figma ваши макеты, и потом с помощью
6627.94 6631.26 "Игорь Лабутин" плагина экспортируете их прямо в C#, и у вас получается
6631.26 6632.86 "Игорь Лабутин" готовая разметка на C#.
6632.86 6634.98 "Игорь Лабутин" Ну вот это же богатая идея, да?
6634.98 6635.98 "Игорь Лабутин" Для уна.
6635.98 6638.66 "Игорь Лабутин" Может быть, у них есть и Figma TOOXAML, тут ещё я не знаю,
6638.66 6639.66 "Игорь Лабутин" честно сказать.
6639.66 6640.66 "Игорь Лабутин" Но тем не менее.
6640.66 6642.18 "Игорь Лабутин" Ещё в этом релизе есть хорошие, они там хот релоуд как-то
6642.18 6645.30 "Игорь Лабутин" сильно улучшили, вероятно, будет гораздо удобнее редактировать,
6645.30 6647.98 "Игорь Лабутин" ну в смысле писать UI-ные приложения у них.
6647.98 6650.98 "Анатолий Кулаков" То есть, представляешь, всё, что вот эти фронтендеры
6650.98 6653.94 "Анатолий Кулаков" на Figma нагенерили, всякие свои UI-ки на ангулярах,
6653.94 6656.46 "Анатолий Кулаков" реактах, можно прямо взять и сконвертить в C#.
6656.46 6657.46 "Анатолий Кулаков" Красотинь же.
6657.46 6658.46 "Игорь Лабутин" Да.
6658.46 6659.46 "Игорь Лабутин" Ну я не знаю, насколько он там хорошо работает и
6659.46 6661.50 "Игорь Лабутин" полноценно конвертит, но что-нибудь похожее наверняка
6661.50 6662.50 "Игорь Лабутин" получится.
6662.50 6663.50 "Игорь Лабутин" Вот.
6663.50 6664.50 "Игорь Лабутин" Дальше по релизам.
6664.50 6668.94 "Игорь Лабутин" Вышел ELSPY 8.2, там новые улучшения в поддержке языка, но по
6668.94 6671.74 "Игорь Лабутин" сути в декомпиляторах единственное, что улучшается, мне кажется,
6671.74 6674.14 "Игорь Лабутин" это там какие-то мелкие баги фиксятся и, понятно,
6674.14 6676.22 "Игорь Лабутин" добавляется поддержка всех последних синтаксических
6676.22 6677.22 "Игорь Лабутин" новинок.
6677.22 6679.98 "Игорь Лабутин" Вот ELSPY 8.2 вышла относительно недавно, я не уверен, что
6679.98 6683.58 "Игорь Лабутин" там есть полноценная поддержка полного 12-го C#, но скорее
6683.58 6685.42 "Игорь Лабутин" всего где-то близко к этому.
6685.42 6689.54 "Игорь Лабутин" А если же вы, ELSPY, к сожалению, только на Windows, если вы не
6689.54 6694.02 "Игорь Лабутин" на Windows, вам нужно что-то на Linux или на MacOS, то есть
6694.02 6698.90 "Игорь Лабутин" дебэкпорт ELSPY на Avalonia называется Avalonia SPY, лежит также на GitHub,
6698.90 6699.90 "Игорь Лабутин" можно использовать.
6699.90 6702.50 "Игорь Лабутин" Там еще, к сожалению, последняя версия вышла год примерно
6702.50 6705.36 "Игорь Лабутин" назад, если не полтора уже, мне казалось, май 22 года
6705.36 6709.74 "Игорь Лабутин" релиз кандидата 7.2, с тех пор ее особо, ну не то, что
6709.74 6712.42 "Игорь Лабутин" не обновляют, там есть какие-то коммиты, она не настолько
6712.42 6715.86 "Игорь Лабутин" живая, как ELSPY, но пользоваться можно, в принципе это был
6715.86 6719.02 "Игорь Лабутин" как эксперимент, типа спортировать, кажется, что удачно, может
6719.02 6723.14 "Игорь Лабутин" быть, надо там помочь ребятам ее таки дебэкпортить, всякие
6723.14 6727.74 "Игорь Лабутин" изменения, особенно языковые, чего бы и нет.
6727.74 6730.26 "Игорь Лабутин" Если мы говорим про Avalonia, у Avalonia тоже был важный
6730.26 6734.26 "Игорь Лабутин" релиз, он не то, чтобы недавний, но про него надо было упомянуть,
6734.26 6738.62 "Игорь Лабутин" называется Avalonia XPF, у нас были всякие VPF, VCF, теперь
6738.62 6743.98 "Игорь Лабутин" у нас есть XPF, XPF — это кроссплатформенный VPF, VPF у нас стал open source'ом,
6743.98 6746.62 "Игорь Лабутин" какое-то время назад Microsoft его за open source'ило, и Avalonia
6746.62 6749.22 "Игорь Лабутин" решила, ну это же отличный повод, и в итоге сделала
6749.22 6752.42 "Игорь Лабутин" свой собственный fork-VPF, где бэкэндом, ну в смысле
6752.42 6757.42 "Игорь Лабутин" внизу, под ним работает не WinAPI, а Avalonia вся штука,
6757.42 6760.46 "Игорь Лабутин" и соответственно вы можете взять любое ваше приложение,
6760.46 6764.58 "Игорь Лабутин" которое работает на VPF'е, скомпилить его с помощью
6764.58 6768.14 "Игорь Лабутин" вот этой приблуды от Avalonia, и получить ваше приложение
6768.14 6771.06 "Игорь Лабутин" на VPF'е, причем, в принципе, если вы используете какие-то
6771.06 6773.78 "Игорь Лабутин" плюс-минус стандартные, там телерики и прочие контролы,
6773.78 6777.02 "Игорь Лабутин" они тоже заведутся, и такое приложение заведется поэтому
6777.02 6780.06 "Игорь Лабутин" на МакОси, на Линукси, в общем, везде работает, ну
6780.06 6782.50 "Игорь Лабутин" пока на МакОси, на Линукси, но планы есть на 2024 год,
6782.50 6783.50 "Игорь Лабутин" на всякие андроиды и прочее.
6783.50 6787.18 "Игорь Лабутин" Вот, прикинь, VPF на андроиде, ну или на iOS'е.
6787.18 6789.40 "Анатолий Кулаков" Ну слушай, меня больше радует то, что мы можем взять как
6789.40 6793.00 "Анатолий Кулаков" бы приложение, которое там разрабатывали 500 лет
6793.00 6795.50 "Анатолий Кулаков" на DPF'е и получить, ну под Windows, естественно, только,
6795.50 6799.46 "Анатолий Кулаков" и получить сразу, просто взять из коробки кроссплатформенное
6799.46 6801.78 "Анатолий Кулаков" приложение, которое можно дальше там разрабатывать,
6801.78 6802.78 "Анатолий Кулаков" обновлять.
6802.78 6803.78 "Анатолий Кулаков" Да.
6803.78 6804.78 "Анатолий Кулаков" Портировать на другие платформы.
6804.78 6805.78 "Анатолий Кулаков" Ну прям, это же красота.
6805.78 6808.38 "Анатолий Кулаков" Это просто как взять дотнет фреймворк, как бы перекомпилировать
6808.38 6809.98 "Анатолий Кулаков" его под Core и пойти жить дальше.
6809.98 6812.34 "Игорь Лабутин" Да, это красота, как бы понятно, что это ориентировано
6812.34 6815.94 "Игорь Лабутин" в основном на всякие большие бизнесы, XPF платная штука,
6815.94 6818.50 "Игорь Лабутин" то есть для его использования нужно заплатить, это нужна
6818.50 6819.50 "Игорь Лабутин" лицензия.
6819.50 6822.26 "Игорь Лабутин" Не смотрел стоимость, наверное, стоит много, но я думаю,
6822.26 6824.26 "Игорь Лабутин" что если вам это надо, зачем-то, то…
6824.26 6827.58 "Анатолий Кулаков" Ну кажется, да, что это корпоративная история и там люди готовы
6827.58 6829.58 "Анатолий Кулаков" вкладываться, потому что если ты будешь переписывать
6829.58 6833.22 "Анатолий Кулаков" всё на какой-нибудь кроссплатформный Моюй с непонятными какими-то
6833.22 6835.18 "Анатолий Кулаков" перспективами, это выйдет ещё дороже.
6835.18 6836.18 "Анатолий Кулаков" Да-да-да.
6836.18 6837.18 "Анатолий Кулаков" Который потребует сервер.
6837.18 6838.18 "Анатолий Кулаков" Тут с маленьким пассом всё.
6838.18 6839.18 "Анатолий Кулаков" Да, там ещё дороже.
6839.18 6841.70 "Анатолий Кулаков" Ты знаешь, сколько эти троглодиты стоят, фронтендеры?
6841.70 6844.10 "Игорь Лабутин" Так даже не только стоят, дело в том, что тебе просто
6844.10 6847.46 "Игорь Лабутин" может логически не получиться это сделать, ну просто по
6847.46 6849.82 "Игорь Лабутин" особенностям, там, дипло или ещё что-нибудь.
6849.82 6850.82 "Игорь Лабутин" Ну тем более.
6850.82 6851.82 "Игорь Лабутин" Ладно, дальше.
6851.82 6854.70 "Игорь Лабутин" Если вам интересно, мы давно особо не копались
6854.70 6857.62 "Игорь Лабутин" ни в каких там кишках отладки и прочего, вот если вам
6857.62 6861.02 "Игорь Лабутин" интересно, есть статья про то, как в райдере писали
6861.02 6864.70 "Игорь Лабутин" отладчик для AVB-ассембли, мы не стали её брать в основное
6864.70 6867.82 "Игорь Лабутин" время выпуска, потому что там прям протокол описан,
6867.82 6870.74 "Игорь Лабутин" ну в каких-то деталях, да, там типа как оно всё взаимодействует.
6870.74 6873.02 "Игорь Лабутин" Если вам интересно, почитайте, статья, в принципе, интересная
6873.02 6875.26 "Игорь Лабутин" и хорошо.
6875.26 6878.90 "Игорь Лабутин" Сергей Тепляков тут опять написал блог-пост, он очень
6878.90 6881.30 "Игорь Лабутин" редко пишет, но тут такой забавный блог-пост про
6881.30 6884.48 "Игорь Лабутин" то, что как не надо бенчмаркать, то есть он взял какой-то
6884.48 6888.54 "Игорь Лабутин" бенчмарк, в котором было написано, что типа, ну работа
6888.54 6891.10 "Игорь Лабутин" со структурами гораздо быстрее, чем работа с классами,
6891.10 6892.58 "Игорь Лабутин" но это же очевидно, правда ведь?
6892.58 6894.38 "Игорь Лабутин" Тут, знаете, структура быстрее классов, там память
6894.38 6898.46 "Игорь Лабутин" меняла, цены, ностеки и так далее, но казалось
6898.46 6901.86 "Игорь Лабутин" бы, очевидный вывод бенчмарка на самом деле привёл к статье,
6901.86 6903.82 "Игорь Лабутин" в которой показано, что бенчмарк – полная фигня
6903.82 6906.50 "Игорь Лабутин" и на самом деле он меряет совсем не то, то есть это
6906.50 6911.34 "Игорь Лабутин" очень хорошая статья, показательная на тему, как из казалось
6911.34 6915.22 "Игорь Лабутин" бы правильных, ну как бы ожидаемых результатов бенчмарка
6915.22 6918.50 "Игорь Лабутин" получить совсем неправильные выводы, вот, это важно смотреть
6918.50 6921.22 "Игорь Лабутин" и поэтому посмотрите, почитайте, там просто довольно много
6921.22 6925.06 "Игорь Лабутин" цифр, много объяснений, мелких штук, которые надо
6925.06 6929.86 "Игорь Лабутин" внимательно читать, а не вот так вот на слух воспринимать.
6929.86 6933.02 "Игорь Лабутин" Дальше, в прошлом выпуске, в прошлом же, да, по-моему
6933.02 6935.10 "Игорь Лабутин" в прошлом мы обсуждали, что вышел MongoDB провайдер
6935.10 6941.54 "Игорь Лабутин" для EF Core, и вышла статья, где написано, как поюзать
6941.54 6944.22 "Игорь Лабутин" MongoDB провайдер с EF Core и с тест-контейнерами на
6944.22 6948.66 "Игорь Лабутин" дотнете, так сказать, взять, поднять баску пустую, в
6948.66 6950.14 "Игорь Лабутин" ней что-то посоздавать, почитать, из неё поудалять,
6950.14 6952.06 "Игорь Лабутин" пообновлять и так далее, поэтому если вы работаете
6952.06 6955.18 "Игорь Лабутин" с Монгой и хотите, хотели попробовать, вот там теперь
6955.18 6957.34 "Игорь Лабутин" есть не просто официальная инструкция от Майкрософт,
6957.34 6960.26 "Игорь Лабутин" но прям статья, где по шагам всё расписано.
6960.26 6963.34 "Игорь Лабутин" И вот осталось две темы, которые, надо сказать, очень
6963.34 6965.86 "Игорь Лабутин" прекрасно ложатся на основные темы нашего выпуска, я
6965.86 6968.10 "Игорь Лабутин" прям специально не готовил их, но вот они очень прекрасно
6968.10 6969.10 "Игорь Лабутин" ложились.
6969.10 6974.74 "Игорь Лабутин" Первая это про BinaryFormatter, те самые breaking changes, значит,
6974.74 6977.54 "Игорь Лабутин" был у нас такой класс, называется BinaryFormatter, он есть до сих
6977.54 6980.06 "Игорь Лабутин" пор, который позволяет вам бинарно форматировать
6980.06 6982.50 "Игорь Лабутин" любой объект, дампить в поток байтов.
6982.50 6985.94 "Игорь Лабутин" В седьмом дотнете его помаркали как абсолетный и сказали,
6985.94 6988.50 "Игорь Лабутин" что вообще это больше использовать не надо, причём помаркали
6988.50 6991.46 "Игорь Лабутин" абсолетным с тем самым true, чтобы это была ошибка
6991.46 6993.78 "Игорь Лабутин" в compile time, как ты и советовал.
6993.78 6994.78 "Игорь Лабутин" Молодцы, слушаются.
6994.78 6999.30 "Игорь Лабутин" Да, в восьмом дотнете теперь вот методы, соответственно,
6999.30 7004.26 "Игорь Лабутин" serialize и deserialize, класс остался, он всё ещё помечен, как
7004.26 7006.94 "Игорь Лабутин" я понимаю, абсолетом, но если ты всё-таки вызвал
7006.94 7010.14 "Игорь Лабутин" метод, засапрессил всё, что можно и всё такое прочее,
7010.14 7011.74 "Игорь Лабутин" метод кинет not supported exception.
7011.74 7015.58 "Анатолий Кулаков" В общем, сопротивляется как могут, да, и атрибутами,
7015.58 7016.58 "Игорь Лабутин" и exception.
7016.58 7021.46 "Игорь Лабутин" Но, но со звёздочкой, если вы это делаете в WinForm или
7021.46 7024.54 "Игорь Лабутин" в WPF-приложении, то не кинет, а будет работать.
7024.54 7028.34 "Игорь Лабутин" А как он детектит, он что там, StackTrace анализирует,
7028.34 7029.34 "Игорь Лабутин" что ли?
7029.34 7031.78 "Игорь Лабутин" Я не знаю, как это детектит, ну, в общем, как-то детектит,
7031.78 7032.78 "Анатолий Кулаков" вот.
7032.78 7033.78 "Игорь Лабутин" Очень интересно, очень интересно.
7033.78 7036.26 "Игорь Лабутин" Короче, в WinForm и WPF и не кинет, а везде в другом
7036.26 7037.26 "Игорь Лабутин" месте кинет.
7037.26 7040.06 "Анатолий Кулаков" То есть для своих можно, да, а вот вам нельзя?
7040.06 7041.06 "Игорь Лабутин" Да, да.
7041.06 7043.30 "Игорь Лабутин" А рекомендация Microsoft в этом breaking change очень простая
7043.30 7049.22 "Игорь Лабутин" – migrate away from, короче, using, в общем, бегите с байнер-реформатора,
7049.22 7050.22 "Игорь Лабутин" если можете.
7050.22 7051.26 "Анатолий Кулаков" Если вдруг… Почему она своей команде
7051.26 7052.26 "Анатолий Кулаков" это не сказала?
7052.26 7053.26 "Игорь Лабутин" Ну, видимо, что-то не смогли.
7053.26 7057.78 "Игорь Лабутин" В WPF же на каком-то там странном саппорте, где там никто
7057.78 7060.70 "Игорь Лабутин" ничего не делает, баги не фиксит и так далее, поэтому
7060.70 7061.70 "Игорь Лабутин" проще это.
7061.70 7066.00 "Игорь Лабутин" Так вот, флажок, про который ты говорил, что хорошо бы
7066.00 7068.26 "Игорь Лабутин" можно было оставлять флажком, да, чтобы вернуть старое
7068.26 7069.26 "Игорь Лабутин" поведение.
7069.26 7071.22 "Игорь Лабутин" В седьмом дотунете был флажок «Верни старое поведение»,
7071.22 7072.98 "Игорь Лабутин" в восьмом он тоже есть и все еще работает.
7072.98 7075.86 "Игорь Лабутин" То есть если вам все-таки нужен, то этот флажок можно
7075.86 7078.22 "Игорь Лабутин" включить, и тогда он запортит exception, перестанет кидаться
7078.22 7079.22 "Игорь Лабутин" и будет работать.
7079.22 7081.26 "Игорь Лабутин" То есть если вы почему-то не можете прям сразу, вы
7081.26 7083.58 "Игорь Лабутин" хотите на восьмой дотунете, но не можете быстро отказаться,
7083.58 7085.94 "Игорь Лабутин" можно использовать этот флажок, он продолжит работать,
7085.94 7088.90 "Игорь Лабутин" но очень рекомендую на что-то переходить, по-любому.
7088.90 7092.22 "Анатолий Кулаков" Ну, в принципе, да, Microsoft – это идеальный пример,
7092.22 7093.58 "Анатолий Кулаков" как надо работать с breaking changes.
7093.58 7095.96 "Анатолий Кулаков" То есть она поддерживает просто абсолютно все, там
7095.96 7097.92 "Анатолий Кулаков" приложения, которые там запускались под Windows 3.1,
7097.92 7100.44 "Анатолий Кулаков" под DOS, в большинстве случаев у вас прекрасно будут работать
7100.44 7101.44 "Анатолий Кулаков" и дальше.
7101.44 7103.36 "Анатолий Кулаков" В общем, с дотунетом они такого же точно принципа
7103.36 7104.36 "Анатолий Кулаков" придерживаются.
7104.36 7108.36 "Анатолий Кулаков" И вот отключают вот в пределах нескольких даже мажорных
7108.36 7109.36 "Анатолий Кулаков" версий там.
7109.36 7112.68 "Анатолий Кулаков" И абсолютами, и флажочками, и фичи-флагами, и эксцепшенами,
7112.68 7114.80 "Анатолий Кулаков" ничего они только не делают, чтобы вас мягенько-мягенько
7114.80 7115.80 "Анатолий Кулаков" перевести.
7115.80 7116.80 "Игорь Лабутин" Да.
7116.80 7119.20 "Игорь Лабутин" И последняя, значит, новость, пока рассказывать про нее
7119.20 7122.32 "Игорь Лабутин" особо нечего, но это задел, с одной стороны, задело
7122.32 7124.96 "Игорь Лабутин" на будущее, потенциальное, может ничего и не получится,
7124.96 7127.40 "Игорь Лабутин" а с другой стороны, отличное завершение для выпуска,
7127.40 7129.74 "Игорь Лабутин" потому что это про синки, про которые мы тоже сегодня
7129.74 7130.74 "Игорь Лабутин" много говорили.
7130.74 7134.68 "Игорь Лабутин" Я уже рассказывал, что в восьмом дотунете была попытка,
7134.68 7136.88 "Игорь Лабутин" ну не попытка, а был нормально проведенный эксперимент
7136.88 7140.92 "Игорь Лабутин" про green 3D, да, зеленые 3D, там как отказаться от async/await,
7140.92 7143.48 "Игорь Лабутин" в пользу другой программной модели, можно ли это сделать
7143.48 7145.68 "Игорь Лабутин" в дотунете, нужно ли это сделать в дотунете, результат,
7145.68 7149.60 "Игорь Лабутин" как вы помните, были, можно отказаться, непонятно зачем,
7149.60 7153.12 "Игорь Лабутин" профит вроде не очевиден, работает примерно так же,
7153.12 7156.48 "Игорь Лабутин" пока решили больше экспериментов в эту сторону не проводить.
7156.48 7159.88 "Игорь Лабутин" В девятом дотунете появилась github.ish, ссылка, значит, в шоу
7159.88 7163.64 "Игорь Лабутин" на нотах, в котором написано, что в дотунет 9 будет проводиться
7163.64 7167.20 "Игорь Лабутин" runtime async эксперимент, причем если green 3D были в специальном
7167.20 7171.24 "Игорь Лабутин" репозитории дотунет, как он там, что-то там labs, а runtime
7171.24 7174.84 "Игорь Лабутин" labs он называется, то это прямо в дотунет runtime основном,
7174.84 7177.92 "Игорь Лабутин" и смысл эксперимента примерно следующий, ну как бы green
7177.92 7181.04 "Игорь Лабутин" 3D мы потрогали и сказали, ладно, async/await вроде работает
7181.04 7183.80 "Игорь Лабутин" неплохо, будем работать с ним дальше, и в девятом
7183.80 7186.72 "Игорь Лабутин" будем смотреть, можно ли как-то улучшить юзабилити
7186.72 7190.96 "Игорь Лабутин" вокруг async/await, вот, потому что сейчас async/await по большому
7190.96 7194.48 "Игорь Лабутин" счету это магия компилятора, потому что все эти стейк
7194.48 7198.56 "Игорь Лабутин" машины, да, рерайтинг вызовов, а runtime про них вообще ничего
7198.56 7201.16 "Игорь Лабутин" не знает, по большому счету, для него это все обычные
7201.16 7204.54 "Игорь Лабутин" методы, и магия стейк машин, соответственно возникает
7204.54 7209.68 "Игорь Лабутин" вопрос, можно ли что-то сделать с юзабилити и, так
7209.68 7214.24 "Игорь Лабутин" сказать, вообще работой с async/await, если бы runtime знал
7214.24 7220.08 "Игорь Лабутин" о том, что методы async/await, вот, и интересная характеристика,
7220.08 7222.08 "Игорь Лабутин" которую они собираются посмотреть, это пропускная
7222.08 7224.52 "Игорь Лабутин" способность, то есть await не бесплатный, как я говорил,
7224.52 7227.56 "Игорь Лабутин" да, то есть возможно, если runtime будет знать о том,
7227.56 7230.16 "Игорь Лабутин" что это await, как-то можно снизить косты на эти стейк
7230.16 7234.56 "Игорь Лабутин" машины, еще на что-то, что делать, опять же, смотри
7234.56 7237.18 "Игорь Лабутин" наши рекомендации выше, помечайте все методы async/await,
7237.18 7238.98 "Игорь Лабутин" даже если вы просто пробрасываете таску, соответственно у
7238.98 7241.74 "Игорь Лабутин" вас может быть очень много вложенных awaits, какие там
7241.74 7245.62 "Игорь Лабутин" проблемы с перформансом и так далее, посмотреть,
7245.62 7248.86 "Игорь Лабутин" насколько, если они что-нибудь придумают, насколько поведение
7248.86 7250.86 "Игорь Лабутин" семантика будет отличаться от старого поведения с
7250.86 7254.54 "Игорь Лабутин" поддержкой чисто компиляторной, а самое, одна из тоже важных
7254.54 7256.42 "Игорь Лабутин" и основных моментов, как это все повлияет на размер
7256.42 7258.74 "Игорь Лабутин" кода, потому что, наверное, можно сделать все в runtime,
7258.74 7261.30 "Игорь Лабутин" чтобы там runtime все умно как-то, не знаю, генерил
7261.30 7264.62 "Игорь Лабутин" не генерил, еще что-нибудь делал, ну как например для
7264.62 7268.00 "Игорь Лабутин" дженериков, для дженериков же для структур runtime на
7268.00 7271.22 "Игорь Лабутин" каждую структуру генерит свою собственную копию класса
7271.22 7274.30 "Игорь Лабутин" дженерикового со своим лиль-кодом, оптимизированный
7274.30 7276.78 "Игорь Лабутин" под конкретный размер структуры, не получится
7276.78 7278.70 "Игорь Лабутин" ли здесь, что код будет слишком сильно большой, слишком
7278.70 7281.26 "Игорь Лабутин" маленький, причем как в варианте intermediate-language,
7281.26 7284.14 "Игорь Лабутин" так и в варианте native-auto, это тоже метрика, на которую
7284.14 7285.14 "Игорь Лабутин" будут смотреть.
7285.14 7288.62 "Игорь Лабутин" Пока в этой ишью, в общем-то, пусто, я подозреваю, что
7288.62 7293.18 "Игорь Лабутин" будут сливаться какие-то, не знаю, результаты экспериментов,
7293.18 7295.98 "Игорь Лабутин" может быть какие-то pull-requests будут, но посмотрим, в общем
7295.98 7299.74 "Игорь Лабутин" будем следить, возможно в девятом дотнете будет
7299.74 7301.38 "Игорь Лабутин" интересно про async.
7301.38 7304.38 "Игорь Лабутин" Да, будет хорошо, если что-нибудь интересное получится.
7304.38 7309.96 "Игорь Лабутин" Да, на этом про кратко о разном все, есть у меня
7309.96 7312.58 "Игорь Лабутин" еще одна тема, мы довольно давно не рекомендовали
7312.58 7315.30 "Игорь Лабутин" никаких подкастов других, может сложиться ощущение,
7315.30 7317.22 "Игорь Лабутин" что мы никого не слушаем, нет, мы слушаем, но мы слушаем
7317.22 7320.26 "Игорь Лабутин" все то же самое, что мы слушали раньше, вероятно, ничего
7320.26 7324.38 "Игорь Лабутин" нового нет, но вот тут я таки добрался, мы какое-то
7324.38 7326.30 "Игорь Лабутин" время назад, точнее с Толей обсуждали, что появился
7326.30 7329.82 "Игорь Лабутин" новый подкаст под названием Брислав и Ложечкин, соответственно
7329.82 7333.34 "Игорь Лабутин" от Андрея Брислава и Александра Ложечкина, не самых далеких
7333.34 7336.66 "Игорь Лабутин" для нас людей, но Андрей Брислав известный человек,
7336.66 7340.46 "Игорь Лабутин" автор Kotlin и вот этого всего, а Александр Ложечкин довольно
7340.46 7344.58 "Игорь Лабутин" известный, ну давай так, наверное, он кому-то в дотнет
7344.58 7347.02 "Игорь Лабутин" мире известен, потому что он когда-то работал в Майкрософт.
7347.02 7350.06 "Анатолий Кулаков" Ну не просто работал, он был директором России в
7350.06 7351.06 "Игорь Лабутин" Майкрософт.
7351.06 7352.78 "Игорь Лабутин" Ну для кого-то это там, ну где-то работал в Майкрософт,
7352.78 7353.78 "Игорь Лабутин" кто он директор, где-то.
7353.78 7354.78 "Игорь Лабутин" Ну хорошо, где-то работал, да.
7354.78 7357.26 "Игорь Лабутин" Вот, то есть я его на самом деле в какой-то момент просто
7357.26 7359.26 "Игорь Лабутин" услышал его фамилию, потому что он был в Майкрософте.
7359.26 7362.82 "Игорь Лабутин" Так вот, они теперь вместе с Андреем ведут подкаст
7362.82 7366.20 "Игорь Лабутин" про внезапно менеджмент, потому что и Андрей когда
7366.20 7369.46 "Игорь Лабутин" руководил Kotlin, он по сути был менеджером, и Александр
7369.46 7371.60 "Игорь Лабутин" долгое время был менеджером профессионально, и сейчас
7371.60 7372.84 "Игорь Лабутин" я так понимаю, ими является.
7372.84 7375.44 "Игорь Лабутин" И вот они рассказывают про всякие особенности менеджмента,
7375.44 7376.44 "Игорь Лабутин" как вообще все это делать.
7376.44 7380.12 "Игорь Лабутин" И надо сказать, что в отличие от типичных, ну скажем
7380.12 7383.72 "Игорь Лабутин" так, менеджерских таких подкастов, тут прям все
7383.72 7387.32 "Игорь Лабутин" очень прикольно для простых разработчиков, таких как
7387.32 7388.32 "Анатолий Кулаков" я.
7388.32 7389.64 "Анатолий Кулаков" Ну они рассказывают не каким-то менеджерским языком
7389.64 7392.28 "Анатолий Кулаков" про ожарилые скрамы, берндауны и прочие вот эти глупости,
7392.28 7393.84 "Анатолий Кулаков" которые вы можете читать там в книжках или слушать
7393.84 7394.84 "Анатолий Кулаков" в другом подкасте.
7394.84 7397.54 "Анатолий Кулаков" Они больше говорят про людей, про взаимоотношения,
7397.54 7400.92 "Анатолий Кулаков" про какие-то свои практические наработки, про те вещи,
7400.92 7404.24 "Анатолий Кулаков" которые они выучили на работах, что им там помогло,
7404.24 7405.24 "Анатолий Кулаков" что наоборот не помогло.
7405.24 7408.12 "Анатолий Кулаков" В общем, много таких классных житейских ситуаций, которые
7408.12 7410.68 "Анатолий Кулаков" будут полезны вам, даже если вы вообще далеки от
7410.68 7413.84 "Анатолий Кулаков" менеджмента, и просто вам интересно узнать, как думают
7413.84 7415.56 "Анатолий Кулаков" или как работают другие люди вокруг.
7415.56 7417.84 "Игорь Лабутин" Да, они рассматривали в том числе и взгляд на все
7417.84 7419.72 "Игорь Лабутин" это со стороны собственных рядовых программистов,
7419.72 7421.72 "Игорь Лабутин" потому что по крайней мере Андрей точно им был, и Андрей
7421.72 7423.84 "Игорь Лабутин" как раз, кстати, это интересный кейс, которым возможно
7423.84 7426.32 "Игорь Лабутин" многим будет показательный, он как раз вырастал из
7426.32 7429.92 "Игорь Лабутин" таких вот как бы индивидуальных контрибьюторов, внезапно
7429.92 7433.36 "Игорь Лабутин" осознал, что он руководит каким-то коллективом, как
7433.36 7437.24 "Игорь Лабутин" самый компетентный его, возможно, так надо сказать,
7437.24 7440.44 "Игорь Лабутин" да, или там самый желающий или еще что-то в таком духе,
7440.44 7442.68 "Игорь Лабутин" и вот теперь, оказывается, надо руководить, и это как
7442.68 7446.08 "Анатолий Кулаков" бы… Он столкнулся как раз с одной
7446.08 7448.62 "Анатолий Кулаков" из самых популярных проблем, когда он просто хотел много
7448.62 7450.92 "Анатолий Кулаков" писать кода, а потом ему оказалось, что он на самом
7450.92 7453.12 "Анатолий Кулаков" деле руководитель, и писать код ему некогда, ему нужно
7453.12 7455.12 "Анатолий Кулаков" как-то развивать и мотивировать команду.
7455.12 7457.96 "Анатолий Кулаков" В общем, я думаю, что многие через это проходили.
7457.96 7460.32 "Игорь Лабутин" Многие себя узнают, возможно, какие-то действительно полезные
7460.32 7463.56 "Игорь Лабутин" советы, либо ретроспективом послужат, скажут «да-да-да,
7463.56 7465.80 "Игорь Лабутин" я даже так думал», либо для себя просто будущего
7465.80 7468.52 "Игорь Лабутин" узнают, что «ага, на эти грабли можно не наступать».
7468.52 7472.68 "Игорь Лабутин" Ну вот примерно так, на этом на сегодня у нас, пожалуй,
7472.68 7473.68 "Игорь Лабутин" все.
7473.68 7478.36 "Игорь Лабутин" Мы сегодня особо не затрагивали никаких новинок, мы поговорили
7478.36 7483.00 "Игорь Лабутин" про тайм-провайдеры и айтаймер в 8-ом дотнете, старье уже,
7483.00 7486.40 "Игорь Лабутин" надо сказать, давно, оно уже в дотнете, про синхронное
7486.40 7488.68 "Игорь Лабутин" программирование Дэвида Фаулера и все советы тоже
7488.68 7492.56 "Игорь Лабутин" старье и много лет в статье, Warbreaking changes и с точки
7492.56 7495.68 "Игорь Лабутин" зрения того, что это такое и как это отслеживать, и
7495.68 7498.16 "Игорь Лабутин" как это отслеживают в Майкрософт с помощью специального
7498.16 7501.78 "Игорь Лабутин" пакетика, книжка Blazor, куча кратких новостей о новых
7501.78 7505.48 "Игорь Лабутин" релизах и рекомендация целого одного подкаста.
7505.48 7510.84 "Игорь Лабутин" Говорим при этом, наверное, уже больше двух часов, всего-то
7510.84 7511.84 "Игорь Лабутин" ничего.
7511.84 7514.56 "Анатолий Кулаков" Ну посмотрим, посмотрим, сколько останется еще после
7514.56 7517.32 "Анатолий Кулаков" редактирования, ну и у нас есть сюрприз для тех, кто
7517.32 7521.12 "Анатолий Кулаков" дослушал до конца, именно до этого места, не переключился
7521.12 7526.12 "Анатолий Кулаков" и надеюсь лайкнул, зашарит, зарепостил, книгу, о которой
7526.12 7528.84 "Анатолий Кулаков" мы рассказали пару минут назад, великолепная книга
7528.84 7531.92 "Анатолий Кулаков" про Blazor, свеженькая, только что от печатного станка,
7531.92 7534.72 "Анатолий Кулаков" у меня как раз есть две лишних копии, которые хотелось
7534.72 7535.72 "Анатолий Кулаков" бы раздать.
7535.72 7538.12 "Анатолий Кулаков" Мне кажется, мы никогда в нашем подкасте не дарили
7538.12 7540.36 "Анатолий Кулаков" какие-то физические подарки, да, мы все время раздавали
7540.36 7542.92 "Анатолий Кулаков" там виртуальные подарки, а сейчас хочется раздать
7542.92 7543.92 "Анатолий Кулаков" физические.
7543.92 7547.96 "Анатолий Кулаков" В общем, у меня есть две книги, правила такие же,
7547.96 7551.36 "Анатолий Кулаков" если кто-то помнит из наших старых слушателей, как
7551.36 7552.36 "Анатолий Кулаков" и были раньше.
7552.36 7558.76 "Анатолий Кулаков" Он получит два человека, по одному человеку из каждого
7558.76 7559.76 "Анатолий Кулаков" списка.
7559.76 7564.56 "Анатолий Кулаков" Первый список – это тот, кто расшарит анонс об этом
7564.56 7569.20 "Анатолий Кулаков" подкасте из группы .net.ru ВКонтакте, то есть расшарит
7569.20 7572.56 "Анатолий Кулаков" в своих группах или расшарит у себя на локальной страничке
7572.56 7573.56 "Анатолий Кулаков" на домашней.
7573.56 7576.36 "Анатолий Кулаков" И вторую книгу получит человек, один рандомный
7576.36 7580.12 "Анатолий Кулаков" человек, который напишет комментарий к YouTube-ролику,
7580.12 7583.48 "Анатолий Кулаков" которым мы как раз… к этому подкасту, да, к которому
7583.48 7587.52 "Анатолий Кулаков" мы говорим про этот подкаст.
7587.52 7589.40 "Анатолий Кулаков" Комментарий может быть абсолютно любой, расскажите
7589.40 7592.40 "Анатолий Кулаков" нам, откуда вы нас слушаете, в какой момент вы нас слушаете,
7592.40 7593.72 "Анатолий Кулаков" что вам нравится, что не нравится.
7593.72 7596.56 "Анатолий Кулаков" Если вы вот долго нас слушали и копили в себе что-то,
7596.56 7598.96 "Анатолий Кулаков" но вам было лень написать, то сейчас именно этот момент,
7598.96 7601.92 "Анатолий Кулаков" сходите и напишите нам что-нибудь, а если вы подпишетесь
7601.92 7604.16 "Анатолий Кулаков" и дёрнете колокольчик, вообще будет прекрасно.
7604.16 7606.36 "Анатолий Кулаков" Поэтому один человек получит из комментариев YouTube, и
7606.36 7608.40 "Анатолий Кулаков" второй человек получит тот, кто расшарил нас в
7608.40 7609.40 "Анатолий Кулаков" ВКонтакте.
7609.40 7612.96 "Анатолий Кулаков" И если вы все-таки это сделали, следите, пожалуйста, за
7612.96 7616.72 "Анатолий Кулаков" результатами, потому что мы попытаемся вас найти
7616.72 7620.48 "Анатолий Кулаков" через эти соцсети, и если получится, то есть если
7620.48 7623.48 "Анатолий Кулаков" получится, я спрошу у вас адрес и пришлю вам эту физическую
7623.48 7625.36 "Анатолий Кулаков" книгу, бумажную, настоящую, прям которую можно будет
7625.36 7627.64 "Анатолий Кулаков" попробовать, пришлю вам ее на почту.
7627.64 7630.40 "Анатолий Кулаков" Если не получится, то мы подождем пару неделек, чтобы
7630.40 7632.56 "Анатолий Кулаков" вы нам ответили, если не ответите, то к сожалению,
7632.56 7635.52 "Анатолий Кулаков" мы эти книги переиграем кому-нибудь другому.
7635.52 7639.96 "Анатолий Кулаков" Результаты я выложу ровно через неделю, результаты
7639.96 7642.24 "Анатолий Кулаков" будут в виде отдельного ролика в нашей группе
7642.24 7643.24 "Анатолий Кулаков" ВКонтакте.
7643.24 7648.48 "Игорь Лабутин" Давай скажем точнее, на ваши комментарии и перепосты
7648.48 7651.56 "Игорь Лабутин" давайте мы дадим ровно неделю с момента выхода,
7651.56 7655.04 "Игорь Лабутин" чтобы точно это мы легко сможем, а по прошествии
7655.04 7659.32 "Игорь Лабутин" недели мы соберем всех, кто это сделал, в каким-нибудь
7659.32 7664.44 "Игорь Лабутин" вечерком соберемся с Толей, запишем, так сказать, тот
7664.44 7667.16 "Игорь Лабутин" самый розыгрыш в прямом эфире, ну не в прямом эфире,
7667.16 7670.04 "Игорь Лабутин" а в записи, чтобы всем было видно, как это делается,
7670.04 7671.96 "Игорь Лабутин" если вдруг кто-то забыл или не видел, как это делалось
7671.96 7674.20 "Игорь Лабутин" раньше, и уже опубликуем результаты.
7674.20 7677.52 "Игорь Лабутин" Важное дополнение, я думаю, Толь поправь меня, если
7677.52 7680.40 "Игорь Лабутин" не прав, что все-таки посылать мы сможем только, понятно,
7680.40 7683.24 "Игорь Лабутин" в России, поэтому готовьте российские адреса.
7683.24 7686.44 "Анатолий Кулаков" Да-да, именно так, рассылать будем только по России,
7686.44 7688.84 "Анатолий Кулаков" поэтому если вы вдруг не здесь, то найдите кого-нибудь,
7688.84 7690.08 "Анатолий Кулаков" кто способен принять вашу книгу.
7690.08 7695.42 "Игорь Лабутин" Все так, ну а теперь уже точно все, лайки, шары, репосты,
7695.42 7699.52 "Игорь Лабутин" это особенно важно в этом выпуске, ну и вообще в любом
7699.52 7703.12 "Игорь Лабутин" выпуске, и до новых встреч, мы постараемся долго не
7703.12 7707.44 "Игорь Лабутин" тянуть с обзором .NET 8, .NET Conf.
7707.44 7709.44 "Игорь Лабутин" Да, всем пока, счастливо.
7709.44 7709.96 "Игорь Лабутин" Всем пока.
7709.96 7719.96 "Игорь Лабутин" [музыка]
