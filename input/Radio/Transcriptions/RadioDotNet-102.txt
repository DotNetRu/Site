0.00 11.44 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net, выпуск номер 102.
11.44 14.52 "Анатолий Кулаков" И в студии его постоянный ведущий Анатолий Кулаков.
14.52 15.52 "Игорь Лабутин" И Игорь Лабутин.
15.52 16.52 "Игорь Лабутин" Всем привет.
16.52 37.00 "Анатолий Кулаков" Особенный привет нашим замечательным помогаторам Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Лазарев Илья, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей и Дмитрий Сорокин.
37.00 41.56 "Анатолий Кулаков" Спасибо большое вам, друзья, а также всем, кто нам помогает и пожелал остаться неизвестным.
41.56 46.92 "Анатолий Кулаков" А если вы хотите тоже помочь своему любимому подкасту, нам, если кто не догадался.
46.92 58.08 "Анатолий Кулаков" Заходите на Boosty и посмотрите, чем можно поддержать ведущих, которые тут для вас перелопачивают тонны статьи для того, чтобы выбрать самые интересные новости, самые вкусные статьи и самые прекрасные доклады и подкасты.
58.08 66.28 "Анатолий Кулаков" Всё это соединить в один выпуск и преподнести вам с сжатым интересным материалом и с новым озвучиванием.
66.28 70.46 "Анатолий Кулаков" Раньше же, помнишь, переводчики были фильмов, которые там пиратские фильмы озвучивали.
70.46 73.40 "Анатолий Кулаков" Некоторые фильмы получились прекрасными только благодаря их голосам.
73.40 77.64 "Анатолий Кулаков" Как ты думаешь, некоторые статьи приобретают блеск только потому, что мы их озвучиваем?
77.64 79.68 "Игорь Лабутин" Конечно, приобретают, как иначе-то.
79.68 81.08 "Игорь Лабутин" Вот это вот.
81.08 85.28 "Игорь Лабутин" А сегодня у нас, блин, я не могу таким голосом говорить.
85.28 89.84 "Игорь Лабутин" Поддонат девятый, кажется, два.
89.84 90.84 "Игорь Лабутин" Подонки.
90.84 91.84 "Игорь Лабутин" Типа того, да.
91.84 93.96 "Игорь Лабутин" Не, я не умею таким голосом говорить.
93.96 101.32 "Анатолий Кулаков" Ну, я думаю, вы всё же привыкли к нашим голосам, поэтому давай на этот выпуск оставим, а там лишь 1 апреля, может, что-нибудь придумаем.
101.32 102.32 "Игорь Лабутин" Случайно.
102.32 105.96 "Игорь Лабутин" Дёрну какого-нибудь ручку в редакторе, будет что-нибудь
105.96 106.96 "Анатолий Кулаков" странное.
106.96 109.80 "Анатолий Кулаков" Точно, даже в век современных технологий можно фильтры накладывать.
109.80 110.80 "Анатолий Кулаков" Ну что, как ты понял?
110.80 111.80 "Игорь Лабутин" Ну и AI поверх.
111.80 112.80 "Игорь Лабутин" AI, AI, как же без него?
112.80 113.80 "Игорь Лабутин" Да, да, да.
113.80 116.88 "Анатолий Кулаков" AI должен быть в каждом выпуске.
116.88 119.72 "Анатолий Кулаков" Как ты правильно заметил, у нас РЦ2 вышел, да?
119.72 120.72 "Анатолий Кулаков" Да.
120.72 125.48 "Анатолий Кулаков" Давай приготовим этот попкорн, большой список нововведений и обсудим, что же там такого.
125.48 133.56 "Игорь Лабутин" Как сказал Анатолий, мы действительно перелопатили огромную кучу статей, я, честно, перелопатил весь анонс DotNet 9 и РЦ2, чтобы найти хоть что-то интересное, и не нашёл.
133.56 148.80 "Игорь Лабутин" Значит, это действительно, пожалуй, первый в истории, за то время, по крайней мере, пока мы что-то обозреваем, случай, когда в релиз ноутсах нет ничего, кроме того, что написано "We are working on quality", короче, quality, значит.
148.80 157.08 "Игорь Лабутин" Причём это были релиз ноуты и по SDK, и по библиотекам, и по Runtime, и по SPNet, и по MAUI, везде написано, что, в общем, quality, quality.
157.08 175.84 "Игорь Лабутин" Везде есть ссылочки на GitHub, вы можете сходить посмотреть на точный фильтр тех issues, которые были исправлены в РЦ2 по сравнению с РЦ1, я сходил, посмотрел, там действительно, ну, по крайней мере, по названиям, я в код, понятное дело, не заглядывал, в каждую, но по названиям там везде действительно какие-то исправления, баги и так далее.
175.84 193.84 "Игорь Лабутин" Ничего какого-то существенного, большого, нового и светлого не добавили, что, впрочем, и, ну, я бы сказал, ожидаемо от релиз кандидата номер 2, особенно учитывая тот факт, что, я напомню, релиз кандидата в Майкрософте имеют так называемую Go Live поддержку, то есть, в принципе, вы их можете брать и ставить в прот.
193.84 201.84 "Игорь Лабутин" Майкрософт, несмотря на то, что это ещё не официальный релиз, он их уже поддерживает, поэтому берите старт, пользуйтесь.
201.84 210.96 "Анатолий Кулаков" Неожидаемо, да, но сколько мы лет обозревали, и там всегда такой списочек, что любой релиз обзавидуется нововведением, не только фикс-оптимизацией и так далее.
210.96 226.68 "Игорь Лабутин" Ну, вот в этот раз действительно нету, либо действительно, я напомню, что девятка у нас же не LTS на релиз, то есть, казалось бы, можно было хоть в последнем этом самом РЦ запихнуть что-нибудь ещё, но не запихнули, а решили сфокусироваться на качестве.
226.68 231.96 "Игорь Лабутин" Ну, хорошо, пусть, как бы, тоже, в принципе, неплохой вариант, будет там чуть шустрее, чуть быстрее.
231.96 243.16 "Игорь Лабутин" Я допускаю, что там половина, ну, не половина, но какая-то часть задачек была в том числе что-то где-то ускорить и улучшить, просто не настолько это показательно, чтобы писать про это отдельные статьи.
243.16 247.32 "Игорь Лабутин" Ну, и ладно, в общем, ждём ещё три недельки, и там уже будет полноценный релиз.
247.32 260.44 "Анатолий Кулаков" Слушай, а мне кажется, проблема в другом, они просто выкинули все фичи, которые хотели добавить в релиз, и раз они все фичи выкинули, то у них импровить-то нечего, и добавлять нечего, и редактировать нечего, вот они остались с голым непонятным релиз-кандидатом.
260.44 269.12 "Игорь Лабутин" Ну, может быть и так, но если выкинули фичи, может или добавить обратно, чё, чтобы добавить что-нибудь не нужно, ну, когда нужно, выкинуть что-нибудь не
269.12 270.12 "Анатолий Кулаков" нужно.
270.12 271.12 "Анатолий Кулаков" Выкинул сначала, теперь добавляй.
271.12 277.88 "Анатолий Кулаков" Ну, ладно, вот такой релиз-9, который, в принципе, как и должен быть релиз-9, только performance improvements, и bugfix, и всё, ничего нового.
277.88 282.20 "Анатолий Кулаков" Но что неожиданно для донета, интересно, насколько тенденция это будет на них сохраняться.
282.20 284.76 "Анатолий Кулаков" Как ты думаешь, будет релиз-3 на этом фоне?
284.76 286.76 "Игорь Лабутин" Нет-нет-нет, кандидатов всегда… Релиз-кандидатов, да.
286.76 290.44 "Игорь Лабутин" Релиз-кандидатов, по-моему, всегда два, я не помню ни одного случая, чтобы их было три.
290.44 293.80 "Анатолий Кулаков" Ну, тут смотри, экстраординарных случаев такого никогда не было.
293.80 296.68 "Игорь Лабутин" То есть, ты думаешь, в релиз-кандидате-3 будут как раз-таки все фичи?
296.68 307.72 "Игорь Лабутин" То есть, сейчас мы поработали, когда у нас там 16-18, если я правильно помню, донетконов, где объявят релиз, я считаю, что где-нибудь 14-го надо выпускать релиз-кандидат-3 с какими-нибудь фичами, ну, чтобы интереснее было.
307.72 310.72 "Анатолий Кулаков" Да, чтобы пуканы у всех там подрывались.
310.72 314.88 "Игорь Лабутин" Ну, спикеры на лайв-демо во время конференции, чтобы у них всё сломалось.
314.88 315.88 "Игорь Лабутин" Это что-то интересное самое.
315.88 316.88 "Анатолий Кулаков" Да-да.
316.88 324.22 "Анатолий Кулаков" Обычно это самое интересное в докладах, когда вчера это работало, а сегодня выпустили новый релиз, я с утра обновился, и смотрите, мой доклад не работает.
324.22 326.12 "Анатолий Кулаков" Сколько раз это было у нас там на конференции?
326.12 327.12 "Анатолий Кулаков" Там много-много.
327.12 328.12 "Анатолий Кулаков" Да.
328.12 329.12 "Анатолий Кулаков" Ну, давай дальше.
329.12 330.12 "Игорь Лабутин" Ну что, пойдём дальше, да?
330.12 337.12 "Игорь Лабутин" У нас точно есть что-то, что выйдет в 9-ом донете, и у нас есть про это отдельная статья, и давай про это поговорим.
337.12 369.56 "Анатолий Кулаков" Да, не только же C# и .NET выходить, есть ещё куча прекрасных классиков, которые рядом с ним выходят, в частности System Text Json продолжает отбирать бразды управления у NewtonSoft, что ему успешно удаётся, и вот вышла статичка, не поверите, а что нас ждёт в релизе .NET 9 System Text Json, несмотря на то, что, естественно, релиз 9-ого ещё нет, но так как уже посыпались пустые релиз-кандидаты, то, наверное, команда System Text Json решила, что хорош, делать им всё равно больше ничего дополнительного не будем, давайте анонсик заделаем.
369.56 374.48 "Анатолий Кулаков" Ну и, в принципе, прекрасно, нам-то во время релиза будет меньше оборзевать.
374.48 379.28 "Анатолий Кулаков" Поэтому давайте посмотрим, а что же на System Text Json в .NET 9 такого появится.
379.28 392.28 "Анатолий Кулаков" Напоминаю, что ещё деват релиза нет, соответственно System Text Json 9-го тоже ещё нет, есть релиз 2-й, его вы можете взять, и все фичи, которые мы сегодня здесь обсудим, там, естественно, будут.
392.28 400.40 "Анатолий Кулаков" А фич, в принципе, достаточно, и одной из самых главных направлений, одной из самых главных фич - это, конечно же, поддержка JSON-схемы.
400.40 418.12 "Анатолий Кулаков" JSON-схема - крутая штука, её давно, в принципе, ждали, давно просили, давно хотели, ну и это реально такой прям целый отдельный пласт, его можно прям сравнить с появлением самого серилизатора, потому что очень много всего нужно было поделать, это же не только извлечение.
418.12 421.64 "Анатолий Кулаков" Ну, кстати, да, для малолеток, что такое JSON-схема?
421.64 428.36 "Анатолий Кулаков" Это способ проверить, провалидировать ваш документ, то есть узнать, насколько ваш документ соответствует определённому протоколу.
428.36 458.20 "Анатолий Кулаков" Различные хипстеры кричали, у нас там динамический JSON, кто что-то хочет, то и пишет, мы всё это будем динамически разбирать, и будет всё хорошо, в общем, но не прошло и 10 лет, как этих хипстеров уже всех угомонили и сказали, что нет, давайте делать всё-таки какой-то протокол, какую-то схему, в этой схеме у нас есть типы, у нас есть какие-то атрибуты и обязательности, в общем, приводить всё к менее строго типизированному языку, который мы привыкли видеть в C#, но не привыкли видеть в динамических языках программирования.
458.20 462.48 "Анатолий Кулаков" Короче, схема - это такая строгая типизация для JSON.
462.48 470.20 "Анатолий Кулаков" Естественно, чем больше мы и строже загоняем JSON в какие-то рамки, тем больше у нас гарантии, что в рентайме это всё будет работать хорошо и прекрасно.
470.20 485.08 "Анатолий Кулаков" Поэтому JSON-схема в себя включает не только описание того, какие типы, какие поля, с какими именами у нас должны быть, но и также инструменты для валидации, то есть мы можем провалидировать, удостоверившись, что определённый документ соответствует определённой схеме.
485.08 496.84 "Анатолий Кулаков" И это тоже замечательно, потому что вы можете, например, выставить какой-то контракт наружу вашего сервиса и не начинать даже работать с тем пакетом, который к вам пришёл, если он не соответствует строго этой схеме.
496.84 519.36 "Анатолий Кулаков" То есть у вас понятна какая-то валидация, которую может у себя взять клиент, и независимо от того, на каком языке программирования он пишет, JSON-схема у всех одинаковая, инструментарий у всех языков как бы заимплементирован реализован одинаково, он может на своей стороне проверить, выдаёт он правильный пакет или неправильный, что принимающая сторона валидно его отвергает или не валидно.
519.36 548.70 "Анатолий Кулаков" В общем, у схем куча преимуществ, как бы на заре становления программирования, когда был популярен ещё православный XML, XML-схема это первое, что появилась, ещё может быть даже до самого XML появилась схема, ну нет, на самом деле её потом прикручивали, но всё же, там не прошло десять лет, как хипстеры наконец-то уже доросли до того уровня, пока у JSON-а появилась схема, может ещё лет сорок, глядишь, они дорастут и до других XML-фич, таких как спейцы, трансформации и прочие.
548.70 567.88 "Анатолий Кулаков" Сейчас поделки на коленках, конечно, есть, но нормальной стандартизации всего этого нету, вот так JSON появлялся как избавление от интерпрайса XML, но сам постепенно становится естественным интерпрайс XML, никуда он от этого не денется, вот мы сейчас можем наблюдать, как хипстеры плачут, косятся, но жуют этот кактус.
567.88 568.88 "Анатолий Кулаков" К чему это я?
568.88 575.32 "Анатолий Кулаков" Да, такое длинное предусловие к тому, что наконец-то в .NET 9 у нас появилась нормальная интерпрайсная схема, что не может не радовать.
575.32 579.44 "Анатолий Кулаков" Итак, для того, чтобы получить схему, что же нам нужно сделать?
579.44 597.36 "Анатолий Кулаков" Прежде всего, схема получается из наших .NET-типов, то есть вы прям можете отдать какой-нибудь тип, допустим, если вы создали тип Person, его можно прямо сделать рекордом, у этого Person есть name, стринговый, у него есть int, age и опциональный адрес в виде строки, который по дефолту равен null.
597.36 603.60 "Анатолий Кулаков" Вот такой, ну, гораздо сложный, вполне сложный с точки зрения типов, вот такое описание нашего класса.
603.60 606.32 "Анатолий Кулаков" Итак, что же нам нужно сделать?
606.32 618.40 "Анатолий Кулаков" Ну, прежде всего, мы должны сделать JSON Serialization Options, их каким-то образом настроить, допустим, мы возьмем дефолтную реализацию, и там уже будет прямо метод, который называется getJSONSchemaAsNode.
618.40 624.72 "Анатолий Кулаков" И в качестве параметра в NOPE получает тип, из которого мы хотим сгенерить схему.
624.72 635.04 "Анатолий Кулаков" С помощью Reflection, этот анализатор проходится по нашему типу, забирает оттуда название полей, конструкторов, типов и составляет схему.
635.04 637.40 "Анатолий Кулаков" Что из себя представляет JSON-схема?
637.40 641.48 "Анатолий Кулаков" Это валидный JSON-документ, в котором описывается несколько секций.
641.48 653.32 "Анатолий Кулаков" Ну, например, самая первая секция верхнеуровневая - это то, какого типа у нас предстоит вот этот рутовый элемент, top-level элемент.
653.32 662.32 "Анатолий Кулаков" Почему-то в JSON-е он обозначается как тип-обжект, наверное, потому что какие-то есть договоренности, которые говорят, что в схеме высокоуровневого типа он объект.
662.32 669.68 "Анатолий Кулаков" Ну, то есть, так как у нас в C# он называется Person, то в схеме вот этот Person никакого отображения не имеет.
669.68 678.16 "Анатолий Кулаков" Мы понимаем, что JSON не оперирует с именами именно полей и именами классов, он оперирует только со значениями.
678.16 682.72 "Анатолий Кулаков" Вот так же точно, как и JSON, схема не знает, как называется этот тип.
682.72 687.52 "Анатолий Кулаков" Она только знает, какие свойства есть у этого типа и какого типа эти свойства.
687.52 691.72 "Анатолий Кулаков" Поэтому у нас есть свойство, атрибут, который называется Properties.
691.72 699.56 "Анатолий Кулаков" У этого атрибута есть перечисленные названия тех полей, тех пропертей, которые у нас заданы в классе Person.
699.56 704.32 "Анатолий Кулаков" Это name, age, address и типы.
704.32 708.52 "Анатолий Кулаков" У каждого из этих атрибутов заданы типы.
708.52 714.08 "Анатолий Кулаков" Примечательно, что если мы говорим про name и age, что там просто задан тип String и Integer, ничего интересного.
714.08 721.88 "Анатолий Кулаков" Если мы смотрим на адрес, напомню, что мы задавали адрес в Person как нулябельный String с дефолтом Null.
721.88 730.28 "Анатолий Кулаков" Вот это все отразилось в схеме, то есть схема знает, что тип у данного свойства может быть String, а может быть Null.
730.28 732.56 "Анатолий Кулаков" То есть Null считается как один из типов.
732.56 735.52 "Анатолий Кулаков" Вместе для нас можно читать, как Null был String.
735.52 739.56 "Анатолий Кулаков" И он также знает, что по дефолту это свойство должно принимать значение Null.
739.56 741.32 "Анатолий Кулаков" Это тоже там отображено.
741.32 746.60 "Анатолий Кулаков" Также схема знает, что у нашего Person есть обязательный конструктор.
746.60 752.52 "Анатолий Кулаков" И у этого конструктора есть два обязательных аргумента – name и age.
752.52 756.44 "Анатолий Кулаков" И это нашло отражение, опять же, в JSON-схеме.
756.44 764.48 "Анатолий Кулаков" Там есть отдельный атрибут, который называется required, и у него указано, что name и age у нас находятся в списке required.
764.48 784.88 "Анатолий Кулаков" Вот такой простой типик, он довольно хорошо так разложился, довольно много всего поддержалось, и тут нужно заметить, что, во-первых, у нас есть поддержка nullable и non-nullable пропертей, то есть он понимает, кто такой String, а кто такой nullable String, и у нас есть поддержка обязательных параметров конструктора, которые располагаются в секции required.
784.88 792.12 "Анатолий Кулаков" Также в конструкторе он понимает, какие поля у нас обязательные, какие необязательные, и у каких есть дефолт.
792.12 794.44 "Анатолий Кулаков" То есть они обязательные, но еще и с дефолтом.
794.44 796.56 "Анатолий Кулаков" Это все прекрасно отражается в схеме.
796.56 816.76 "Анатолий Кулаков" Также, если вдруг вы захотите как-нибудь эту схему модифицировать или подменить, или что-нибудь как-нибудь расширить, то сразу предоставляется специальный делегат, который называется transform-schema-node, и он вам позволяет подсунуть какую-то свою реализацию, какой-то свой делегат, процессор, который что-то как-то может манипулировать с этой схемой.
816.76 827.68 "Анатолий Кулаков" Ну, например, в качестве сампла приводится такая ситуация, что нам нужно к каждой ноде, по сути к каждому свойству, добавить description.
827.68 834.52 "Анатолий Кулаков" И у нас description c#-коди задан с помощью description-атрибута над каждым свойством.
834.52 847.12 "Анатолий Кулаков" Вполне нормальная тема – это зарегать вот этот transformation-делегат, извлечь из атрибута какой-то описание ноды и добавить ее в схему, что, в принципе, не возбраняется.
847.12 850.72 "Анатолий Кулаков" Схема, так как это JSON-документ, она довольно хорошо расширяется.
850.72 853.68 "Анатолий Кулаков" Мы можем свои кастомные поля туда тоже каким-то образом добавлять.
853.68 873.88 "Анатолий Кулаков" Вообще, это довольно такой хороший, мощный механизм, который, в принципе, позволит вам вот эту JSON-схему, она, помню, это, скорее всего, будет применяться в первую очередь, да, не «скорее всего», а в первую очередь это будет применяться, допустим, для описания вашего API, то есть ваш API обзаведется не только каким-нибудь слагерьюаем, но и нормальной, понятной, описанной JSON-схемой.
873.88 891.10 "Анатолий Кулаков" И в этой JSON-схеме, если вы добавите еще туда и какое-нибудь человеческое текстовое описание, а потом надравите на эту штуку какой-нибудь chat-GPT, который умеет по текстовому описанию составлять какие-то пользовательские предложения, то с этим API вполне нормально можно будет общаться с человеческим языком.
891.10 893.96 "Анатолий Кулаков" Я думаю, какие-нибудь такие примеры уже должны в скором времени появиться.
893.96 894.96 "Анатолий Кулаков" Да, наверное, уже есть.
894.96 898.04 "Анатолий Кулаков" Так, пойдем дальше.
898.04 903.40 "Анатолий Кулаков" С схемой мы закончили, давайте к следующей фиче перейдем.
903.40 909.72 "Анатолий Кулаков" Следующая фича — это потребление множественного JSON-документа, чтобы это значило.
909.72 918.20 "Анатолий Кулаков" У нас есть класс UTF-8 JSON Reader, и с помощью него можно было раньше прочитать обычный JSON-документ, которым никого не удивишь.
918.20 925.20 "Анатолий Кулаков" А теперь его немножко расширили, и теперь он может прочитать не из стрима один документ, а несколько документов.
925.20 937.64 "Анатолий Кулаков" Это очень часто бывает нужно, когда вы просто-напросто шлете кучку каких-то маленьких документиков и не хотите ради разных документов создавать там какой-то новый буфер или открывать новый стрим, или городить какой-то свой сепаратор.
937.64 950.20 "Анатолий Кулаков" Обычно это, например, часто применяется в логах, когда вы пишете, например, структурированные логи, то каждая запись этого лога — это полноценный валидный JSON-документ.
950.20 955.16 "Анатолий Кулаков" Но следующая запись этого лога — это уже другой документ, никак не связанный с первым.
955.16 963.44 "Анатолий Кулаков" Таким образом их отделяют, например, началом новой строки, и у нас получается такой документ, который состоит из кучи маленьких JSON-документов.
963.44 971.72 "Анатолий Кулаков" В целом этот документ общий, рутовый, он не валиден с точки зрения JSON, но если мы берем по одной строчке, то каждая строчка с точки зрения JSON вполне валидна.
971.72 976.96 "Анатолий Кулаков" Вот, в принципе, такую штуку теперь можно прочитать легко с UTF-8 JSON-ридером.
976.96 989.72 "Анатолий Кулаков" Делит он документы по любому whitespace-сепаратору, то есть конец строки, пробелы, табуляции, вот это вот все, и может прочитать несколько JSON-документов из одного буфера или одного стрима.
989.72 1002.48 "Анатолий Кулаков" И по дефолту он так не делает, по дефолту он бросает исключения, и чтобы это изменить, и чтобы он начал все-таки читать множественный документ, вам необходимо это поведение изменить, выставив специальный флаг, который называется allow multiple values.
1002.48 1008.36 "Анатолий Кулаков" После того, как мы его проставим, он начинает соответствовать тому, что заявлено.
1008.36 1016.96 "Анатолий Кулаков" Таким образом мы можем прочитать множественные документы, и более того, вот этот подход, который появился, он нам дает несколько еще интересных вещей.
1016.96 1034.96 "Анатолий Кулаков" Ну, например, теперь мы, допустим, если у нас есть стрим, и там первые 10 документов у этого стрима валидны, а 11-й какой-нибудь был поврежденный, то есть плохой JSON был, и раньше у нас весь стрим, по сути, ломался, то есть считался, что этот JSON-документ огромный, он как бы весь невалидный.
1034.96 1043.80 "Анатолий Кулаков" Как только мы начинаем читать его, воспринимать его как несколько документов, нам парсер способен отдавать, соответственно, все эти документы по мере поступления.
1043.80 1070.36 "Анатолий Кулаков" Если, допустим, первые 10 документов валидны, то парсер нам отдаст нормальные валидные 10 документов, а потом 11-й, который будет невалидным JSON-ом по какой-то там причине, он на нем упадется ошибкой, но при этом 10 валидных он нам отдаст, то есть такое разделение стрима на несколько валидных документов позволило нам в том числе красиво отдавать ошибки, при этом не повреждая никак предыдущие нормальные идущие валидные JSON-ы.
1070.36 1073.88 "Анатолий Кулаков" Это тоже хорошо, это тоже интересно.
1073.88 1079.28 "Анатолий Кулаков" Еще одна классная тема, которую мы немножко затрагивали в наших предыдущих выпусках, но не грех будете напомнить, потому что она прекрасна.
1079.28 1086.44 "Анатолий Кулаков" Это Respecting Nullable Attributes, то есть уважение к нуллабл атрибутам появилось какое-то, да?
1086.44 1100.64 "Анатолий Кулаков" Нуллабл атрибуты появились довольно давно, это очень мощная система, которая позволяет C# типы сделать более выразительные и более функциональные, используется довольно уже широко, часто, я надеюсь, вообще всеми.
1100.64 1107.64 "Анатолий Кулаков" И вот как раз только к .NET девятому сериализатор доперло, что их каким-то образом надо поддерживать.
1107.64 1111.04 "Анатолий Кулаков" Что же, собственно, происходит?
1111.04 1116.92 "Анатолий Кулаков" JSON-сериализатор теперь добавил некую ограниченную поддержку Non-Nullable Reference Types.
1116.92 1118.08 "Анатолий Кулаков" Что это значит?
1118.08 1138.20 "Анатолий Кулаков" Что у нас появился новый флажок, который называется Respect Nullable Annotations, его нужно проставить в JSON Serialization Options, и с этих самых пор сериализация и десериализация JSON-ов, какие-то объекты или не объекты, учитывает то, каким образом это свойство задекларировано в .NET и в C#.
1138.20 1140.00 "Анатолий Кулаков" В частности, учитывает его нулябельность.
1140.00 1152.96 "Анатолий Кулаков" Ну, например, если у нас поле объявлено как ненулябельное, но мы туда почему-то засунули null, к сожалению, такое можно сделать, и мы попытаемся этот объект засериализовать, то сериализатор выкинет нам JSON Exception.
1152.96 1162.28 "Анатолий Кулаков" Или же наоборот, мы пытаемся десериализовать какое-то свойство, и нам в качестве JSON-значения этого свойства приходит null.
1162.28 1175.68 "Анатолий Кулаков" Но в C# мы объявили тип как неналабл, и, соответственно, как только мы попытаемся этот null туда записать, у нас тоже вылетит JSON Exception, что, в принципе, ожидаемо, очевидно, и, казалось бы, блин, почему было сразу так не сделать.
1175.68 1181.32 "Анатолий Кулаков" Вот, теперь это будет так, если вы, естественно, включите этот флаг.
1181.32 1185.80 "Анатолий Кулаков" К сожалению, не все в этом мире так радужно, и есть куча ограничений.
1185.80 1196.72 "Анатолий Кулаков" Ограничения в основном связаны с тем, что реализация в .NET NullReferenceType была сделана с таким уклоном, чтобы не нарушить существующий язык.
1196.72 1217.36 "Анатолий Кулаков" Потому что, на самом деле, внедрение вот этой самой концепции NullReferenceType, сделать из языка, который ничего не знал о null-референсах, сделать это понятие non-null-non-nullable-reference - это довольно такая мощная парадигма, и на самом деле никто в языках еще ее не повторил.
1217.36 1226.28 "Анатолий Кулаков" То есть не существует языка, который раньше не поддерживал NullReferenceType, а потом в каком-то там виде, в котором они были, например, в .NET, а потом начал поддерживать.
1226.28 1229.40 "Анатолий Кулаков" В общем, .NET единственный пока в мире сделал вот этот свитч.
1229.40 1240.68 "Анатолий Кулаков" И языки изначально или разрабатываются с тем, что у нас в референс-тайпах может быть null, или сразу разрабатываются с тем, что у нас null-а там быть никогда не может.
1240.68 1243.28 "Анатолий Кулаков" В основном этим страдают всякие функциональные языки.
1243.28 1246.88 "Анатолий Кулаков" Там сразу это идет из коробки, и там как бы никаких вопросов нет.
1246.88 1251.04 "Анатолий Кулаков" То, что вначале появился такое, а потом переделали вот так, такого еще в мире не бывало.
1251.04 1254.64 "Анатолий Кулаков" И то, что сделал .NET, в принципе, довольно годно.
1254.64 1266.16 "Анатолий Кулаков" Его в большинстве случаев хватает, его можно использовать, но, к сожалению, есть какие-то определенные ограничения, которые как раз и были связаны с тем, что Microsoft попытался усидеть на двух стульях.
1266.16 1275.80 "Анатолий Кулаков" Он захотел, чтобы и старый код продолжил работать, и новый код можно было писать в этом прекрасном строгом nullable-типе, на nullable-аннотации.
1275.80 1277.76 "Анатолий Кулаков" В чем же это выразилось?
1277.76 1285.60 "Анатолий Кулаков" Ну, в частности, в том, что в il-коде не существует такого понятия, как nullable или не nullable.
1285.60 1302.64 "Анатолий Кулаков" Допустим, если у вас есть класс Person, и PersonNullable, ну не класс, а переменка, да, допустим, переменка обычная Person, и переменка PersonNullable, и мы посмотрим на il-код, который сгенерится, допустим, когда вы оперируете с этими переменками, мы увидим, что il-код абсолютно идентичен, и для nullable, и для не nullable.
1302.64 1305.76 "Анатолий Кулаков" Все это потому, что на уровне il-а они никак не отличаются.
1305.76 1323.12 "Анатолий Кулаков" Это все магия уровня компиляторов и атрибутов, то есть над типами в основном ставятся атрибуты, всякие средства анализаторов, компиляторы, рослины и прочее помогают эти атрибуты каким-то образом исследовать, и подсказывает уже VDE там или в компиляции, правильно вы работаете с типами или неправильно.
1323.12 1338.08 "Анатолий Кулаков" Но когда мы говорим о сериализации, то там вся магия идет в рантайме, и в рантайм-рефлекшене, и вот как к сожалению в рантайм-рефлекшене не всегда можно отличить nullable тип от не nullable.
1338.08 1348.56 "Анатолий Кулаков" Иногда это можно сделать, как я уже сказал, по неким атрибутам, которые иногда проставляются, но они проставляются не всегда, не везде, и иногда этого сделать невозможно.
1348.56 1377.80 "Анатолий Кулаков" Именно по этой причине вот эта валидация, которую я выше рассказывал, она работает только для неженериковых свойств, полей и параметров конструктора, и при этом не работает для, например, топ-левел типа, то есть это тот тип, тот объект, который вы непосредственно передаете в метод serialize/deserialize, в общем там не работает вот эта проверка, и самое обидное, она не работает в элементах коллекции.
1377.80 1394.96 "Анатолий Кулаков" Допустим, лист от строк у нас никак не будет отличаться от листа от nullable строк, вот с точки зрения JSON-сериализатора у них тип будет один и тот же, потому что вот как раз это стреляют generic типы.
1394.96 1412.32 "Анатолий Кулаков" Ну, как бы Java так всю жизнь живет и ничего, вроде как-то более-менее ползет, но у нас, как строго типизированную нормальному типизированному языку и с нормальными генериками конечно вот эта штука довольно обидная, и где это еще не поддерживается?
1412.32 1419.92 "Анатолий Кулаков" Это не поддерживается для любых свойств, филдов и параметров, у которых есть generic, вот на примере, например, листа.
1419.92 1436.44 "Анатолий Кулаков" Вот, такие довольно серьезные ограничения, но опять же, если у вас публичные свойства, если у вас нет там генериков, то есть обычные, если мы говорим про обычные DTOшки, где чаще всего применяется serializer, то там более-менее все должно работать.
1436.44 1449.08 "Анатолий Кулаков" Включается вот эта штука, как я уже сказал, можно включить уважение к nullable атрибутам, можно включить через опции, а также можно включить глобально, с помощью фичи флага.
1449.08 1468.24 "Анатолий Кулаков" Если вы на уровне своего проекта выставите специальный ключик, который называется "respect nullable annotations true", то во всем проекте включится вот эта опция, и вам не нужно даже для этого менять, допустим, serializer, если он не поддерживает явно эту, то есть не поддерживает, а не включил явно эту опцию.
1468.24 1482.56 "Анатолий Кулаков" Так, еще одно интересное, еще одно интересное ограничение наверное, можно отнести это к ограничениям, есть у вот этого "respect nullable annotations", это в том, что оно не учитывает те свойства, которые оно не децерализовало.
1482.56 1490.16 "Анатолий Кулаков" Ну, например, допустим, у нас есть какой-то класс "person", у этого "person" есть обязательное поле "name".
1490.16 1501.52 "Анатолий Кулаков" Если мы включим уважение к nullable reference type, и попытаемся в этот "name" записать null, то все рухнет в JSON exception, как мы и ожидали.
1501.52 1519.68 "Анатолий Кулаков" Но, если мы попытаемся децерализовать пустой объект, то есть просто две фигурные скобочки, то это прекрасно децерализуется, несмотря на то, что "name" не может быть нулябельным, но так как мы туда и не пытались засунуть null, а взяли просто и создали класс, то все нормально децерализуется.
1519.68 1523.20 "Анатолий Кулаков" В "name" будет храниться null, несмотря на то, что оно ненулябельное.
1523.20 1540.84 "Анатолий Кулаков" Вот, это, опять же, есть очень много людей, которые почему-то, когда делают DTO-шки, делают с ненулябельными типами, и говорят, ну я же тип сделал ненулябельным, у меня же сериализатор все проверит, и никакой null в это поле не запишет, поэтому я могу к этим полям обращаться как хочу.
1540.84 1557.44 "Анатолий Кулаков" А на самом деле это не так, это глубочайшее заблуждение тех людей, которые не понимают, как он работает, и как только они к этому "name", допустим, начнут обращаться, у них все упадет с null reference exception, несмотря на то, что они используют даже null reference type, которые, по идее, от этого нас должны спасать.
1557.44 1566.80 "Анатолий Кулаков" Поэтому, если вдруг вы работаете с DTO-шками, то у всех DTO-шек поля должны быть nullable, потому что сериализатор туда может засунуть nullable.
1566.80 1601.88 "Анатолий Кулаков" И System Tech Jason, он еще умный, он еще как-то пытается, и то, только девятый, и то, если вы явно выставите опцию, он еще как-то будет пытаться туда в некоторых случаях, будем считать, в половине случаев, запихнуть туда нормальное значение, но во всех остальных случаях там легко может оказаться null, поэтому все ваши DTO-шки на границах приложения должны иметь nullable типы, и вы в вашем контроллере, допустим, или где-то там еще, должны все-таки проверить, что туда почему-то не засунулся null по какой-то либо причине, потому что это может быть на практике.
1601.88 1610.48 "Анатолий Кулаков" Так, погнали, еще поговорим про уважение, и сейчас мы с вами поговорим про уважение к неопциональным параметрам конструктора.
1611.20 1627.52 "Анатолий Кулаков" Раньше у GSON-сериалайзера, System Tech GSON-сериалайзера была возможность децерализовать типы, глядя на их конструктор, то есть мы не создаем какой-то POCO-объект, а потом проставляем ему свойства, как работают обычные сериализаторы.
1627.52 1638.72 "Анатолий Кулаков" Это сериализатор умный, он может посмотреть на конструктор, который есть у этого объекта, и если в конструкторе передавались какие-то аргументы, System Tech GSON вполне был способен эти аргументы передать.
1638.72 1675.16 "Анатолий Кулаков" Единственная там оказия была, что он все параметры этого конструктора трактовал как опциональные, то есть несмотря на то, что ваш класс Person требовал обязательно name и требовал обязательно age, при этом децерализуя пустой GSON-документ в Person, операция проходила успешно, и в Person прекрасно у нас записывалось, записывался null в reference type, и записывался 0, ну или дефолт там в структурный тип, в нашем случае int, то есть конструктор он поддерживал, он молодец, но передавал тогда какую-то чушь.
1675.16 1679.24 "Анатолий Кулаков" Казалось бы тоже, почему не сделать было с самого начала нормально, непонятно.
1679.24 1699.84 "Анатолий Кулаков" Довели людей до того, что может быть куча багов, поэтому если вы даже в конструкторе требуете обязательный параметр name, и при этом, ну в DTO-шке почему-то, да, у вас есть DTO-шка с конструктором, и вы там требуете обязательный параметр name, и надеетесь, что туда вам никто его не передаст, то нет, вы не правы, передаст, и даже более того, это поведение по дефолту.
1699.84 1735.26 "Анатолий Кулаков" Итак, в DotNet 9 наконец-то врубили нам, добавили прекрасный флаг, который называется RespectRequiredConstructorParameter, смысл у него такой же точно, как и на NullableRespect, то есть он меняет вот это дефолтное поведение, теперь все параметры в конструкторе, которые не объявлены опциональными, ну то есть объявлены по сути обязательными, они становятся обязательными при децерализации, и происходит опять же то же самое, если вдруг мы нас не удовлетворили этим неймом, а он у нас обязательный, то выкинется AddressOnException, что в принципе прекрасно, что в принципе и должно было быть.
1735.26 1761.28 "Анатолий Кулаков" Это поведение опять же по дефолту выключено для того, чтобы соблюсти backward compatibility со старым кодом, и вы его можете включить, можете включить его как в опциях, также точно можно включить его с помощью фичи флага на всем проекте для того, чтобы все ваши социализаторы теперь заработали по этим новым правилам, но вам нужно учитывать, что это реально breaking change, поэтому вы должны знать тот код, который у вас используется и понимать, не повредит ли это ему.
1761.28 1789.72 "Анатолий Кулаков" Итак, оба этих флага я хочу подчеркнуть, они очень полезные, очень хорошие, но по умолчанию не выключены для того, чтобы не было breaking changes, и Microsoft крайне рекомендует для всего нового кода, для всех новых приложений эти флажки включать, то есть мы уже начинаем бросать вот этими Legacy костылями, которые почему-то по дефолту Microsoft включить не может, но в вашем приложении вы не должны забыть их включать, естественно многие будут забывать и как бы об этом напоминать, кроме как каких-нибудь стандартных шаблонов, ну непонятно.
1789.72 1799.44 "Анатолий Кулаков" Описывайте у себя в Вики, там создавайте шаблоны, передавайте из уст в уста, что как только вы начинаете использовать JSON сериализаторы, их надо вот так вот магически поднастроить.
1799.44 1846.44 "Анатолий Кулаков" Погнали дальше, довольно-таки такая минорная фича, но все же это кастомизация членов enum, у нас теперь есть новый JSON string enum member attribute, который позволяет вам изменить название, значение enum при сериализации вот этого индивидуального значения, ну допустим у нас был my_enum и у него value1 есть значение, вы его можете засериализовать и если вы настроили, что enum у вас должны сериализоваться в виде строки, то прекрасно в вас в JSON запишется значение value1, но навесив вот этот атрибут, вы можете поменять значение, то есть у вас это может записаться не value1, а любой вообще произвольный текст, который вы захотите.
1846.44 1856.88 "Анатолий Кулаков" Очень похоже то, как мы например выбираем имена для полей или для свойств в нашем объекте, но теперь мы можем выбрать вот это имя не только для свойств, но и для значения enum.
1856.88 1864.32 "Анатолий Кулаков" Не знаю, не очень понятно, почему не заиспользовали уже существующий флаг, какой-нибудь JSON property, зачем было изобретать новый.
1864.32 1867.48 "Анатолий Кулаков" Ну наверное там с этим есть какие-то тонкости, но смысл у него тот же самый.
1867.48 1879.68 "Анатолий Кулаков" Еще одна интересная штука, это out-of-order metadata, штука это, чтобы вы понимали, metadata, да, что такое metadata.
1879.68 1884.72 "Анатолий Кулаков" Metadata это некая информация, которая добавляется в ваш JSON-документ в некоторых случаях.
1884.72 1887.88 "Анатолий Кулаков" Эти случаи довольно-таки редкие, но все-таки бывают.
1887.88 1888.88 "Анатолий Кулаков" Например полиморфизм.
1888.88 1899.24 "Анатолий Кулаков" Если мы хотим, допустим, сохранить знания об иерархии в наш JSON-документ, то для этого необходимо туда записать еще какую-то metadata.
1899.24 1904.52 "Анатолий Кулаков" Ну допустим, у нас есть какой-то базовый класс и от этого класса пронаследован какой-то наследник, вот.
1904.52 1924.52 "Анатолий Кулаков" И если мы, допустим, хотим записать в JSON-документ именно наследника и все его свойства, то сделать это несложно, но надо понимать, а как мы его потом читать будем, потому что на самом деле мы же можем начать вычитывать базовый класс, а при этом создать мы хотим не базовый класс, создать мы хотим наследника.
1924.52 1938.24 "Анатолий Кулаков" То есть, если у вас такой извращенная ситуация в серилизации есть, а я знаю, что они часто у многих бывают, когда мы пытаемся иерархию там сохранить и децерализовать, то на помощь нам приходят как раз-таки вот эти metadata.
1938.24 1955.28 "Анатолий Кулаков" Metadata это специальный такой ключик, который добавляется в ваш JSON-документ без переопределения, например, он называется $type, и в этот $type записывается непосредственно имя того класса, который реально должен проинстанцироваться, независимо от того, какой базовый класс вы попросили.
1955.28 1959.08 "Анатолий Кулаков" Вот, это метадата, что же с ней случилось?
1959.08 1977.12 "Анатолий Кулаков" Ну, в общем, метадату подобную писать и читать мы умели давно, но по дефолту метадата записывалась в самом начале вот этого JSON-документа, то есть мы в самом начале должны знать, что мы создаем Derived Class, то есть класса наследника, а потом уже начинаем считывать все его свойства и постепенно записывать в тот класс, который создали.
1977.12 1991.32 "Анатолий Кулаков" Вот, и записывать метадату в самое начало – это очень правильный момент, потому что как только мы знаем наследника, мы можем этот тип проинстанцировать, и у нас будет уже объект, который мы можем заполнять значениями.
1991.32 2000.04 "Анатолий Кулаков" Поэтому раньше метадата-ридер, он требовал, чтобы сначала перед всеми свойствами было записано метадата.
2000.04 2038.76 "Анатолий Кулаков" Иногда это приводило к проблемам, например, если кто-то пользовался какими-то сторонними сериализаторами, не такими умными и красивыми, как наш System Tech JSON, а скорее всего вообще на других языках программирования, которые не думают ни о performance, ни о чем, то эти чудилы запихивали метадату в конец JSON-документа, да, то есть вы понимаете, вы читаете какой-то объект, у него есть имя, у него есть возраст, а потом в конце вы догадываетесь, оба-на, а этот объект – это мой derived person, допустим, и как бы да, и что с этим делать, непонятно, может там какие-нибудь языки, которым наплевать на производительность, типа динамический язык, и они с этим радостно справлялись, но нормальные языки этого поддерживать не хотели.
2038.76 2054.52 "Анатолий Кулаков" Естественно, так дела не делаются и пришлось поддержать Microsoft такое поведение, для этого нам понадобилось новое свойство, которое называется allowOutOfOrderMetadataProperties, которое вы тоже можете сконфигурировать и вот это ограничение убрать.
2054.52 2056.76 "Анатолий Кулаков" Что же у нас теперь происходит?
2056.76 2080.52 "Анатолий Кулаков" Теперь когда ридер читает вот этот класс, который неизвестно какого типа, он еще этого не понимает, для него нужно там какого-то наследника узнать, он начинает все свойства считывать в некий буфер, и вот он читает-читает-читает в буфер, дошел уже в конце до метадаты, то есть где у нас записано то, о какой непосредственно класс нам нужно проинстанцировать, и в этот момент класс инстанцирует и туда сбрасывает весь этот буфер.
2080.52 2090.98 "Анатолий Кулаков" Казалось бы, рабочий алгоритм, все хорошо, все нормально, наверное, какие-то так делают люди, но здесь нужно быть осторожным, если вы этот флажок включаете, нужно быть осторожным.
2090.98 2091.98 "Анатолий Кулаков" Почему?
2091.98 2110.52 "Анатолий Кулаков" Потому что такой подход приводит к тому, что у нас может быть out of buffer, у нас на больших JSON документах у нас может буфер быть таким огромным, что это может привести к какому-то исключению, поэтому все-таки метадаты рекомендуется запихивать в самое начало, чтобы такого не было.
2110.52 2137.76 "Анатолий Кулаков" Так, еще одно изменение в JSON, это у нас теперь можно настраивать отступы, то есть у нас появилось в опциях такое свойство как indent character, и его можно указать там, табики и так далее, мне кажется, что это должно было быть каких-то самых первых версий, вроде не какой-то там rocket science, ну ладно, можем настраивать отступы и можем, хорошо.
2137.76 2144.80 "Анатолий Кулаков" Другое интересное чудо, это JSON Object Property Order Manipulation, на что люди жаловались.
2144.80 2180.36 "Анатолий Кулаков" Короче, существует у нас такой класс, как JSON Object, это хороший класс, он используется для mutable дома, то есть если вам нужно построить какое-нибудь JSON дерево, но при этом вы не хотите пользоваться готовым серилизатором готового объекта, а это mutable дерево вам нужно собирать в рантайме, ну допустим, пользователь с клавиатурой вводит имя, свойство и его тип, и вам нужно в это время собирать JSON под то, что ввел пользователь, то есть вы в момент написания программы, у вас нет никакой DTO, которую вы можете серилизовать, знания о том, как собирается DTO появляются у вас в рантайме, это называется mutable дом.
2180.36 2190.32 "Анатолий Кулаков" У System Text JSON довольно богатые классы, хорошие для того, чтобы в рантайме, в динамическом, динамически собирать вот этот дом и читать этот дом.
2190.32 2194.16 "Анатолий Кулаков" Мы сейчас говорим о JSON Object, который динамически позволяет как раз его собирать.
2194.16 2216.56 "Анатолий Кулаков" Ну так вот, и внутри вот этого JSON Object, он хранил, соответственно, свойства и значения этих свойств, и вот это хранилище, оно декларировалось в виде IDictionary от string JSONNode, да, то есть в string мы записывали имя, свойства, а в JSONNode уже какое-то ее значение, это мог быть там скалярная нода, или массив, или другой вложенный объект, не суть важна.
2216.56 2223.84 "Анатолий Кулаков" Вот, и так как мы записывали это все в dictionary, то по факту у нас не было какой-то предсказуемой сортировки этих полей.
2223.84 2231.84 "Анатолий Кулаков" Ну и более того, некоторые пользователи-завращенцы, они хотят не просто какую-то предсказуемую сортировку, они хотят менять порядок полей.
2231.84 2240.56 "Анатолий Кулаков" Они хотят, чтобы сначала шел IDичник, потом шел какой-нибудь нейм, потом другие свойства, или может быть метадату вставить на нулевое место, на самое первое.
2240.56 2242.88 "Анатолий Кулаков" То есть хотелось бы управлять этим порядком.
2242.88 2246.36 "Анатолий Кулаков" Так как у нас в dictionary, мы не могли дать им такого порядка.
2246.36 2250.08 "Анатолий Кулаков" Но в новом релизе все кардинально изменилось.
2250.08 2254.04 "Анатолий Кулаков" Как сказано в статье, модель была переделана на OrderDictionary.
2254.04 2257.60 "Анатолий Кулаков" Но если посмотреть внутрь, то естественно никакого OrderDictionary там нет.
2257.60 2265.76 "Анатолий Кулаков" OrderDictionary они просимулировали, ну, как все мы симулируем OrderDictionary, если нам нужно, мы делаем list от k-value пэйеров string JSON-нода.
2265.76 2273.28 "Анатолий Кулаков" То есть то же самое, но только мы сделали не dictionary от string ноды, а мы сделали list от k-value пэйеров от string ноды.
2273.28 2274.92 "Анатолий Кулаков" Ну вот таким образом мы проэмулировали порядок.
2274.92 2278.92 "Анатолий Кулаков" Короче, теперь JSON-объект поддерживает порядок свойств.
2278.92 2286.08 "Анатолий Кулаков" Благодаря этому у него появились такие свойства как index_of, когда мы можем определить индекс свойства, то есть под каким номером он находится.
2286.08 2292.22 "Анатолий Кулаков" У нас есть метод insert_at и remove_at, что мы можем в какую-то позицию вставить новое свойство и из какой-то позиции удалить.
2292.22 2300.08 "Анатолий Кулаков" Соответственно пользователь теперь может манипулировать и передвигать свойства вверх-вниз и вообще так, как ему нравится в этом прекрасном динамическом mutable доме.
2300.08 2303.40 "Анатолий Кулаков" В общем, все вот хотелки такие удовлетворились.
2303.40 2319.68 "Анатолий Кулаков" Ну вот такие вот самые важные, самые большие, самые значимые, самые интересные изменения в System Text JSON, в принципе изменения хорошие, изменения нужные, и кажется, что на основе, то есть на фоне релиз-кандидата команда System Text JSON себя даже неплохо показала.
2319.68 2326.92 "Игорь Лабутин" Не, ну подожди, это все-таки они показали за весь релиз за год, а релиз-кандидат всего около месяца был.
2326.92 2343.68 "Игорь Лабутин" Но да, я как раз хотел сказать, что ты уже порядка 30 минут рассказываешь про System Text JSON, так что да, если мы настолько подробно и полчаса тратим время на подробный рассказ, то может быть действительно не так, как ты, и много новостей других.
2343.68 2358.96 "Анатолий Кулаков" Слушай, я думаю, что сам релиз DotNet 9, ну и в частности может быть даже C#, будет поменьше, чем System Text JSON, поэтому я думаю, что вот эта статейка, она вполне посоревнуется и с нашим выпуском по релизам.
2358.96 2359.96 "Анатолий Кулаков" Ну посмотрим.
2359.96 2360.96 "Анатолий Кулаков" Дождемся релиза.
2360.96 2363.28 "Игорь Лабутин" Фич там, да, фич там довольно мало планируется.
2363.28 2371.84 "Игорь Лабутин" Поглядим, посмотрим, когда будет статья про релиз, наверняка же мы еще раз вспомним о том, что зарелизил с 9 DotNet, и какой-нибудь выпуск, видимо, этому посвятим.
2371.84 2377.52 "Игорь Лабутин" Ну видимо тот, который выйдет после уже DotNet Conf, и поговорим, какой длины он будет.
2377.52 2378.52 "Игорь Лабутин" Обязательно.
2378.52 2392.40 "Игорь Лабутин" А пока пойдем еще в одну новую штуку, ну как новую, ну да нет, почему, новую вполне, а именно DotNet Aspire, у нас же это не выпуск без Aspire, и у Aspire вышел тоже релиз-кандидат, DotNet Aspire 9, релиз-кандидат 1.
2392.40 2403.96 "Игорь Лабутин" Кажется, что Microsoft планирует успеть зарелизить нормальный релиз для DotNet Aspire вместе с основным DotNet 9, но пока непонятно, может быть еще будет релиз-кандидат 2.
2403.96 2404.96 "Игорь Лабутин" Поглядим.
2404.96 2410.08 "Игорь Лабутин" А может быть там на недельку, на две позднее выпустят почему-то полноценный релиз, ну поглядим.
2410.08 2418.84 "Игорь Лабутин" Давайте быстренько пробежимся, может быть даже не за полчаса, а побыстрее, что же такого появилось в 9 DotNet Aspire и релиз-кандидат 1.
2418.84 2419.84 "Игорь Лабутин" Да.
2419.84 2420.84 "Игорь Лабутин" Первый релиз-кандидат.
2420.84 2426.08 "Игорь Лабутин" Во-первых, Microsoft отказывается от установки Aspire через ворклоуды.
2426.08 2441.40 "Игорь Лабутин" Напомню, что раньше, ну до текущего момента, для того чтобы поставить всякие разные компонентики от Aspire, нужно было сказать dotnet-workload-install что-то там, теперь этого делать не нужно, нужно сделать SDK, нужно теперь добавить SDK.
2441.40 2456.36 "Игорь Лабутин" Теперь в вашем CSS Project вы выбираете специальный тип SDK, он называется Aspire-uphost-sdk, в том проекте, в котором у вас Uphost, соответственно, должен быть, этот главный проект, в котором вы через C# определяете, как выглядит ваше приложение.
2456.36 2460.52 "Игорь Лабутин" И подключаете этот SDK и все остальное подтянется само.
2460.52 2468.80 "Игорь Лабутин" Если же вам нужны шаблоны, шаблоны нужно теперь установить отдельно через dotnet-new-install-aspire.project-templates и дальше там версия.
2468.80 2477.88 "Игорь Лабутин" Пока она выглядит довольно страшно, это 9.0.0.dcsrc.1.build-number, потом, понятно, к релизу будет просто Aspire.project-templates.
2477.88 2478.88 "Игорь Лабутин" Все будет хорошо.
2478.88 2481.36 "Игорь Лабутин" Это про шаблоны.
2481.36 2487.00 "Игорь Лабутин" Одна из основных фичей Aspire, про которую мы, по крайней мере, довольно подробно говорим, это Dashboard.
2487.00 2493.30 "Игорь Лабутин" В Dashboard появились всякие, ну, скажем так, мелочи, но полезные мелочи.
2493.30 2503.36 "Игорь Лабутин" Во-первых, появилась возможность стартовать, стопать и перестартовать любые ваши ресурсы, ну, точнее, не любые, это относится к проектам, контейнерам и исполнимым файлам.
2503.36 2518.88 "Игорь Лабутин" Если у вас такие есть, то вы можете прямо из Dashboard запустить, остановить и перестартовать, причем, если вы это делаете, например, для ресурса, в котором был подключен отлачник, отлачник переподключится, просто вы перестартуете.
2518.88 2523.88 "Игорь Лабутин" Дальше появилась поддержка, внезапно, мобильных браузеров.
2523.88 2527.00 "Игорь Лабутин" Как ты думаешь, зачем Dashboard запускать на мобильных браузерах?
2527.00 2531.84 "Анатолий Кулаков" Ну, удобно же, когда ты в отпуске, у тебя там прот рухнул, ты раз через мобилочку зашел, загрузил все починок.
2531.84 2534.72 "Игорь Лабутин" Так, погоди, Aspire ж не для прота, это для локал хаста.
2534.72 2536.72 "Анатолий Кулаков" Для локал хаста, мобильный браузер.
2536.72 2541.80 "Анатолий Кулаков" Ну, может, это отлаживать мобильные приложения, а не что-то на мобилке запустить?
2541.80 2542.80 "Игорь Лабутин" А, ну, может быть.
2542.80 2543.80 "Игорь Лабутин" Может быть, кстати, да.
2543.80 2550.04 "Игорь Лабутин" Или ты, не знаю, запустил у себя что-нибудь большое сложное, ушел курить, а на телефончик смотришь, как у тебя там поживает твой комп.
2550.04 2552.96 "Анатолий Кулаков" Дышать свежим воздухом, курил и летает.
2552.96 2553.96 "Игорь Лабутин" Да, хорошо.
2553.96 2554.96 "Игорь Лабутин" На прогулку.
2554.96 2555.96 "Игорь Лабутин" На пробежку.
2555.96 2560.40 "Игорь Лабутин" Значит, из телефона контролируешь, как твой сервис крутится под нагрузкой.
2560.40 2561.40 "Игорь Лабутин" Локально.
2561.40 2562.40 "Игорь Лабутин" Ну, нормально.
2562.40 2575.52 "Игорь Лабутин" Дальше появилась поддержка sensitive properties, то есть можно некоторые пропертии обозначить как sensitive, и у них значения тогда будут маскироваться по дефолту, чтобы в вашем дашборде подошедший коллега не мог подсмотреть ваши секретные пароли для разработки.
2575.52 2584.12 "Игорь Лабутин" Кроме того, показываются вольюмы в контейнерах, и теперь есть понятие health checks у ресурсов, и они тоже показываются.
2584.12 2585.12 "Игорь Лабутин" Сейчас про них я чуть позднее расскажу.
2585.12 2596.80 "Игорь Лабутин" Ну, и, естественно, куда же мы без всякого разноцветного и прочего украшательства в консольных логах, теперь можно через nc_escape, ну, стандартные, короче, показывать цветные логи.
2596.80 2599.80 "Анатолий Кулаков" А темы поддерживаются?
2599.80 2600.80 "Игорь Лабутин" Дашборда?
2600.80 2601.80 "Игорь Лабутин" Я что-то не помню.
2601.80 2602.80 "Игорь Лабутин" Ну, да.
2602.80 2603.80 "Игорь Лабутин" Прям...
2603.80 2607.44 "Анатолий Кулаков" Я хочу там visual studio dark тему наложить, как у нас в чатике любят.
2607.44 2608.44 "Игорь Лабутин" Я не помню.
2608.44 2611.60 "Игорь Лабутин" Наверняка там есть какая-нибудь светлая и темная, а может только темная.
2611.60 2612.60 "Игорь Лабутин" Я что-то, кстати, не помню.
2612.60 2615.48 "Игорь Лабутин" Про тему в дашборде что-то я не помню, что-то мы что-то говорили.
2615.48 2617.36 "Игорь Лабутин" Ну, возможно, я ошибаюсь.
2617.36 2618.36 "Игорь Лабутин" Надо вспомнить.
2618.36 2619.36 "Игорь Лабутин" Не помню.
2619.36 2620.36 "Игорь Лабутин" Дальше.
2620.36 2621.36 "Игорь Лабутин" Телеметрия.
2621.36 2629.24 "Игорь Лабутин" Телеметрия — это, в смысле, все то, что вам репортится в Aspire с точки зрения всяких метрик и прочего.
2629.24 2644.92 "Игорь Лабутин" Во-первых, улучшилась фильтрация, можно теперь фильтровать по значениям атрибутов, и есть автокомплит тех значений, ну, у которых некоторое ограниченное число значений, там какой-то автокомплит работает, длинные значения можно теперь не набирать, а не подставиться.
2644.92 2671.36 "Игорь Лабутин" Можно комбинировать, например, телеметрию из разных источников в одном, так сказать, ну, в одном view, как сказано в статье, в основном это нужно, если у вас, например, несколько реплик, не знаю, зачем вам это при локальной разработке, но, допустим, у вас несколько реплик, это все теперь скомбинируется, можно в одном view и там дальше либо группировать, либо как-то объединять по репликам, ну, в общем, получше стало.
2671.36 2692.28 "Игорь Лабутин" И довольно, наверное, интересные изменения, они сделали возможность засылать телеметрию из браузера, и если у вас есть джаваскриптовое приложение, в котором есть сбор OpenTelemetry Metric, а есть такие библиотеки, то теперь даже из браузерного кода можно засылать все в Aspire и тоже там смотреть, как там ваш фронтенд работает.
2692.28 2697.84 "Анатолий Кулаков" Ну, вот это полезно, это хорошо, интересно, для всяких десктопов есть там, для WPF, для Volonie?
2697.84 2705.00 "Игорь Лабутин" Да наверняка, слушай, ну там-то, оно ж ничем не отличается от обычного WPF, но только что работает с UI-чиком, а не с сокетами.
2705.00 2711.14 "Анатолий Кулаков" Ну да, я имею в виду, уже готовы, библиотечки есть, чтобы там людям не страдать, чтобы там каждая кнопочка свой спан создавала и все такое.
2711.14 2714.80 "Анатолий Кулаков" А-а, не, ну такого- Автоинструментейшн меня больше интересует.
2714.80 2720.12 "Игорь Лабутин" Автоинструментейшн я не видел, кстати, для десктопа, но и не интересовался, давно не пишу десктоп.
2720.12 2723.44 "Анатолий Кулаков" Ну, если у нас есть опытные люди в чатике, придите,
2723.44 2724.44 "Игорь Лабутин" скажите.
2724.44 2726.56 "Игорь Лабутин" Да, было бы интересно послушать опыт.
2726.56 2737.56 "Игорь Лабутин" Апхост — это, напомню, основное приложение, которое контролирует как раз все то, что происходит в вашем Aspire-продукте, ну, как бы, в проекте, продукте, как хотите, назовите.
2737.56 2740.12 "Игорь Лабутин" Во-первых, появилась возможность ждать зависимости.
2740.12 2748.32 "Игорь Лабутин" Вы теперь можете, когда вы пишете C#-овое определение вашего продукта, то есть как сервисы связаны друг с другом, у вас есть два новых метода — waitFor и waitForCompletion.
2748.32 2757.48 "Игорь Лабутин" waitFor ждет до тех пор, пока у вас healthCheck не станет зелененьким, и waitForCompletion, очевидно, ждет, пока не закончится что-то.
2757.48 2764.36 "Игорь Лабутин" То есть вы можете запустить какую-то одноразовую джобу, например, при старте, дождаться его завершения, только после нее запускать какие-то другие сервисы.
2764.36 2773.14 "Игорь Лабутин" Эти самые healthChecks, они как раз используются для этого waitFor, и кроме того, могут репортить произвольные данные в виде JSON, которые отображаются на дашборде тоже.
2773.14 2778.96 "Игорь Лабутин" То есть можно через healthCheck смотреть какие-то базовые информации о здоровье ваших сервисов.
2778.96 2811.60 "Игорь Лабутин" Поддерживаются persistent контейнеры, например, если у вас есть контейнер, который довольно долго стартует, и вы не хотите при каждой сессии дебага, когда вы поднимаете, опускаете весь ваш продукт, его перестартовать, вы можете в коде описания этого контейнера написать новый метод использовать withLifetime, и передать туда enum.container.lifetime.persistent, и тогда он не будет перезапускаться при перезапуске основного сервиса, всей коллекции сервисов, которые контролируются Ispire, и он остановится только если вы вручную его остановите из дашборда.
2811.60 2814.88 "Анатолий Кулаков" Вот, например, базу так можно поднять, да?
2814.88 2815.88 "Игорь Лабутин" Да, базу.
2815.88 2826.60 "Игорь Лабутин" На самом деле я бы так поднимал, например, какие-то, не знаю, ювайные клиенты к чему-то, ну, какой-нибудь там pgadmin, например, у меня там в каком-нибудь докере крутится, его-то что перестартовать, он точно ни от чего не зависит.
2826.60 2827.60 "Анатолий Кулаков" Ну, да, да.
2827.60 2839.52 "Игорь Лабутин" То есть базу, может быть, я, например, бы, ну, не знаю, базу, например, если при старте она каждый раз новая создается с известными предефайненными данными, то почему нет, а вот какие-нибудь ювайчики такие вспомогательные?
2839.52 2841.40 "Игорь Лабутин" Ну или там рейдис какой-нибудь с кэшом.
2841.40 2851.24 "Анатолий Кулаков" Ну, да, да, наверное, зависит от юзкейсов, когда вам нужна новая база, когда вам нужна уже существующая или какие-то сторонние клиенты вот такие, типа юай-админов.
2851.24 2857.88 "Анатолий Кулаков" Ну, да, удобная штучка, поэтому у тебя будет очень быстро твое приложение запускаться, потому что не будут сторонние вот эти вещи перезапускать.
2857.88 2858.88 "Игорь Лабутин" Ну, да.
2858.88 2873.48 "Игорь Лабутин" Дальше появилась тоже интересная фича, я не знаю пока как она будет использоваться, называется resource commands, то есть вы можете теперь в вашем ресурсе, то есть когда вы разрабатываете плагинчик к эспайру, вы можете определить произвольный набор команд.
2873.48 2886.48 "Игорь Лабутин" Команды это, по сути, просто некоторые, ну, грубо говоря, эндпойнт, да, который некоторой метаданной задается и вы в коде вашего ресурса можете просто определить обработчик, что будет, если эту ручку дернуть.
2886.48 2896.44 "Игорь Лабутин" В дэшборде появится, соответственно, кнопка, ну, кнопка-ссылка, как хотите назовите, с нужным названием, при нажатии на которую выполнится ваш обработчик.
2896.44 2908.32 "Игорь Лабутин" То есть в статье, для примера, сказано, что, например, можно radius resource, radius как ресурс, как bd, можно, например, выставить наружу такую функциональность, как там, не знаю, почистить, ну, дропнуть, короче, все кэши из радиуса целиком.
2908.32 2917.44 "Игорь Лабутин" То есть просто вы в дэшборде жмёте одну кнопку и у вас выполняется код в вашем сервисе, который законнектится к радиусу и дропнет все данные, которые в нём лежат.
2917.44 2922.00 "Анатолий Кулаков" Ну, то есть по факту это получается такой плагин к юайке.
2922.00 2923.00 "Анатолий Кулаков" Да.
2923.00 2926.68 "Анатолий Кулаков" То есть мы расширяем юай довольно-таки хорошим, примитивным и понятным способом.
2926.68 2935.92 "Анатолий Кулаков" Ну, мне кажется, это мощненько, это мощненько, то есть мы теперь можем не только контейнеры запускать, но и там как-то их настраивать, какие-то команды выдавать, какую-то функциональность добавлять, прям целую админки к ним писать.
2935.92 2936.92 "Анатолий Кулаков" Нормаль, нормаль.
2936.92 2937.92 "Игорь Лабутин" Это хорошо.
2937.92 2938.92 "Игорь Лабутин" Вот.
2938.92 2939.92 "Игорь Лабутин" Дальше.
2939.92 2940.92 "Игорь Лабутин" С контейнерами.
2940.92 2952.28 "Игорь Лабутин" Раньше, как я понимаю, когда Aspire запускает все докер-контейнеры, они все запускаются в контексте хостового нетворка, ну, чтобы если вы что-то ещё локально запускаете, к ним всё могло коннектироваться и так далее.
2952.28 2957.36 "Игорь Лабутин" Теперь по умолчанию все контейнеры запускаются в одном нетворке, ну, в одном докерном нетворке.
2957.36 2965.92 "Игорь Лабутин" Я не очень понял, насколько этот нетворк связан с хостом, ну, то есть он совсем изолирован или всё-таки его как-то через бридж там связывается.
2965.92 2976.24 "Игорь Лабутин" Вот этот момент я не посмотрел, но по крайней мере контейнеры точно смогут друг с другом работать, ну, потому что докерная сетка единая, ну, и, вероятно, как-то выходить наружу.
2976.24 2979.36 "Игорь Лабутин" Вряд ли они прям всё это загнали в одну единственную внутреннюю сетку.
2979.36 2981.64 "Анатолий Кулаков" Ну, это правильное решение, чё на хостик.
2981.64 2986.24 "Анатолий Кулаков" Ну да, ты к ним даже, иначе даже дашбордом не подцепишься, не посмотришь.
2986.24 2987.24 "Анатолий Кулаков" Ну да, да.
2987.24 2988.24 "Игорь Лабутин" Должно же кто-то быть.
2988.24 2989.24 "Игорь Лабутин" Как-то должно быть.
2989.24 2990.24 "Игорь Лабутин" Вопрос как бы, что они экспозят.
2990.24 2994.92 "Игорь Лабутин" Они же могут заэкспозить только порты или они могут всю сетку забриджить целиком, что ты мог коннектиться к чему угодно.
2994.92 2998.36 "Игорь Лабутин" Вот, вероятно, достаточно, в принципе, только на хост вытащить, ну, основные порты.
2998.36 2999.36 "Игорь Лабутин" И всё.
2999.36 3013.12 "Анатолий Кулаков" Да, но опять же, если мы говорим про то, что это используется только локально, только для отладки, вот что-то по всем тем изменениям, знаешь, которые ты сейчас перечисляешь, мне кажется, они всё-таки дуют в ту сторону, чтобы это было не только локально и не только для отладки.
3013.12 3014.12 "Анатолий Кулаков" Возможно.
3014.12 3015.12 "Анатолий Кулаков" Ну, такие фичи локально для отладки не делают.
3015.12 3017.36 "Анатолий Кулаков" Ну, это уже совсем, как бы, белый не вид, камешито.
3017.36 3028.80 "Игорь Лабутин" И дальше расскажу, есть ещё одна фича, которая тоже, я пока не знаю, куда, в какую сторону, это дуновение, но это ещё большее расширение, называется Eventing Model.
3028.80 3038.88 "Игорь Лабутин" Короче, теперь этот обхост позволяет зарегистрировать обработчики на ивенты типа там Before Start Event, After Resources Created Event, After Endpoints Allocated Event.
3038.88 3047.76 "Игорь Лабутин" Это глобальные ивенты, а ещё на каждый ресурс будет ещё триггериться ивенты типа Before Resource Start, Connection String Available и Resource Ready Event.
3047.76 3062.88 "Игорь Лабутин" Короче, теперь ещё можно разные ресурсы или ваш вот этот обхост могут подписываться на разные ивенты и как-то что-то где-то, не знаю, донастраивать, да ещё что-то делать, в общем.
3062.88 3065.84 "Игорь Лабутин" Кажется, что теперь на Aspire тоже можно как-то очень хитро программировать.
3065.84 3070.00 "Игорь Лабутин" Поглядим, во что это выльется, пока примеров реальных не видел, но посмотрим.
3070.00 3074.36 "Игорь Лабутин" Там в статье какие-то довольно синтетические, так скажем.
3074.36 3086.36 "Игорь Лабутин" Если с Redis было вот этот нормальный пример, сбросить кэш, он понятен, то вот с ивентами там пока какие-то довольно синтетические, типа там вывести в лог что-нибудь, вот, но может быть и что-то реальное.
3086.36 3090.64 "Игорь Лабутин" Явно не добавили из-за каких-то желаний пользователей для своих собственных нужд.
3090.64 3091.64 "Анатолий Кулаков" Посмотрим.
3091.64 3101.52 "Анатолий Кулаков" Да, какие-то такие точки расширения, которые довольно функциональны и запихнуть в них можно много всего, но интересно, какие у них в голове сценарии под это
3101.52 3102.52 "Игорь Лабутин" есть.
3102.52 3118.20 "Игорь Лабутин" Ну да, я пока не могу придумать, что я туда хотел бы запихнуть, но я и не пишу эти компоненты для спайра, поэтому, наверное, если бы я писал, может быть, у меня уже было бы какое-то количество вещей, которые я хотел бы знать, что бы мне сделать, когда все готово, да, все стартовано, что-нибудь что-нибудь сделать.
3118.20 3120.84 "Анатолий Кулаков" Ну, например, поднять репликацию на другом кластере.
3120.84 3136.84 "Анатолий Кулаков" Если мы отвязываемся все-таки от локального дебага, вот у тебя там запускается где-нибудь нода на первом кластере, потом ты смотришь, что и раз она поднялась, значит, на втором кластере, например, можно загасить старую ноду, ну, старой версии, то есть таким образом rolling update, например, можно делать, но это так в плане конспирации.
3136.84 3167.40 "Игорь Лабутин" Ну, может быть, но посмотрим, я думаю, что мы будем находить какие-то статьи, где уже вот такие более advanced штуки будут использоваться, потому что пока все статьи по спайру они такие довольно вводные, типа смотрите, как я использую спайр в какой-то своей локальной разработке, но в целом, ну, поглядим, поглядим, если попадется что-то интересное с этими вот новыми расширенными штуками, или мы увидим это в каких-то более интересных больших статьях, более подробными описаниями того, зачем это использовать, ну, конечно, поделимся.
3167.40 3197.36 "Игорь Лабутин" И с точки зрения интеграции, которые компоненты, да, напомню, что они теперь называются integrations, там добавили некоторое количество, radius-inside, open-ai в превьюшке, которая позволяет, это библиотечка, которая позволяет контактировать ко всем open-ai штукам, mongodb и там ажурные немножко тоже расширили, добавили поддержку функций в превью, то есть можно теперь в ваших проектах использовать эти же функции, и они будут подниматься в локальном хосте, не в ажуре, а прям в локальном, для локальной отладки.
3197.36 3200.62 "Игорь Лабутин" Вот такие у нас дела со спайром.
3200.62 3207.28 "Анатолий Кулаков" Ну, хороший, хороший источник тоже нам вдохновления, новостей и всяких интересных анонсов.
3207.28 3208.28 "Анатолий Кулаков" Да.
3208.28 3214.76 "Анатолий Кулаков" Так, еще без чего не отходится уже практически ни один наш выпуск, это без ИИ, искусственный интеллект.
3214.76 3219.32 "Анатолий Кулаков" Когда же без него уже все плюш проел, ну, приходится говорить, товарищи, поэтому не обессудьте.
3219.32 3238.12 "Анатолий Кулаков" Чтобы быть в курсе, чтобы понимать, что в мире творится, что у нас есть и с чем мы работаем, Microsoft заанонсировал новый пакет, который называется Microsoft Extensions.ai, и также там какие-то вспомогательные в библиотеке, типа .abstractions, .azure и прочие глупости, но в целом пакет называется так.
3238.12 3249.96 "Анатолий Кулаков" Я бы звал его ни много, ни мало, так не скромно, как Unified Building Blocks, то есть такие универсальные блоки для того, чтобы построить AI-приложения на .NET.
3249.96 3252.48 "Анатолий Кулаков" Давайте посмотрим, что же это такая за превьюшка.
3252.48 3253.48 "Анатолий Кулаков" Да, это превьюшка.
3253.48 3255.60 "Анатолий Кулаков" Итак, что же за Building Blocks такие?
3255.60 3266.80 "Анатолий Кулаков" Это, прежде всего, набор библиотек, которые внутри себя собрали такие общие шаблоны проектирования, под которые подходят практически все текущие AI-компоненты.
3266.80 3277.00 "Анатолий Кулаков" Там у них есть куча абстракций, которые позволяют между различными провайдерами, между различными ресурсами каким-то образом универсализировать обмен.
3277.00 3283.68 "Анатолий Кулаков" Сейчас он доступен в виде превью, в общем, пока стабилизируется и посмотрим, когда там релиз будет.
3283.68 3287.40 "Анатолий Кулаков" Пока не очень понятно, может быть вместе с большим .NET, может еще нет.
3287.40 3302.64 "Анатолий Кулаков" И подробнее, если вдруг вы сталкивались с Semantic Kernel, то есть вот эта тема очень похожа на Semantic Kernel, то есть там тоже пытались собрать какие-то универсальные компоненты, которые абстрагировались от конкретной реализации и прочее, прочее.
3302.64 3314.90 "Анатолий Кулаков" В общем, если вы работаете знакомы с Semantic Kernel, то можно воспринимать данную библиотеку как логическое продолжение Microsoft Semantic Kernel Abstractions.
3314.90 3317.80 "Анатолий Кулаков" То есть вот это вот оттуда пошло.
3317.80 3318.80 "Анатолий Кулаков" Какие же там есть абстракции?
3318.80 3322.16 "Анатолий Кулаков" Ну, для примера, всем нам плеш проевшую, это чатики.
3322.16 3335.36 "Анатолий Кулаков" То есть у нас есть какой-нибудь chat-клайент, у нас есть универсальный интерфейс, iChat-клайнт, который как раз позволяет потреблять вот этот чатик, независимо от того, какая там на том конце сидит модель, где она находится, какого размера и прочего.
3335.36 3343.04 "Анатолий Кулаков" У этого чатика там есть какие-то connections, у него есть какой-то completion, то есть то, что из этого чатика пришло у него из history, message и так далее.
3343.04 3351.00 "Анатолий Кулаков" То есть стандартные вещи, которые будут у любого чатика, несмотря на то, как он реализован, а также несмотря на то, где он размещен, локально или удаленно.
3351.00 3353.00 "Анатолий Кулаков" То есть здесь эта абстракция тоже пытается поддерживаться.
3353.00 3359.16 "Анатолий Кулаков" Соответственно, этот iChat-ик может заимплементировать все провайдеры, кому только придет в голову.
3359.16 3363.56 "Анатолий Кулаков" Кто-то захочет поддержать вот этот универсальный и абстрактный мегаинтерфейс.
3363.56 3376.16 "Анатолий Кулаков" Объявляется поддержка не только LLM-ов, то есть не только large-language моделей, но и small-language моделей.
3376.16 3394.32 "Анатолий Кулаков" И также, кроме абстракции, которые нужны каждому уважающему себя чатику, там есть какие-то общие компоненты, которые юзаются всеми обычными ай-ай-ами, такие как, например, кэширование нужно всем, OpenTelemetry провязанная через все компоненты нужно всем.
3394.32 3408.20 "Анатолий Кулаков" Также стандартные наши вещи, к которым мы привыкли из ASP, например, логирование, DI-контейнер и прочие-прочие вот эти микрософтовские удобные штучки, которые пролезли в принципе везде и непонятно, почему бы не пролезть в том числе в фреймворк для написания чат-ботиков.
3408.20 3415.60 "Анатолий Кулаков" Итак, какие же мы получаем преимущества, заполучив вот эту библиотеку?
3415.60 3429.72 "Анатолий Кулаков" Прежде всего, это универсальный API, который един для всех и этот API, он как бы под одну гребенку зачесывает всех поставщиков и заставляет их использовать какой-то задекларированный интерфейс.
3429.72 3443.40 "Анатолий Кулаков" Мы, например, видели такую наезд монополию интеграции захват с iLogger, который подвел под единую черту всех логгер с DI-контейнером, который рассказал нам, как мы должны все регистрировать DI-ки и использовать их.
3443.40 3454.64 "Анатолий Кулаков" В общем, Microsoft вот эту сторону целится, то есть он хочет создать такой единый API, под который будут поставиться все остальные производители всяких искусственных интеллектов.
3454.64 3463.44 "Анатолий Кулаков" Ну, в принципе, это хорошее направление, нам-то лучше, там не разбираться с различными документациями, с различными настройками.
3463.44 3466.60 "Анатолий Кулаков" В самом примитивном случае можем использовать Unified API.
3466.60 3484.24 "Анатолий Кулаков" Также нам это дает гибкость, то есть она позволяет, например, авторам библиотек, которые работают с помощью каких-то там компонентов для искусственного интеллекта и сервисов, они помогают вот эти библиотеки писать абсолютно независимо от того, какого провайдера потом в эту библиотеку подставят.
3484.24 3493.80 "Анатолий Кулаков" И, соответственно, поддерживает даже тех провайдеров, которые не подразумевались на момент написания самой библиотеки, потому что есть такая удобная абстракция.
3493.80 3515.00 "Анатолий Кулаков" Еще одно преимущество – это простота в использовании, то есть декларируется, что разработчики теперь могут экспериментировать с различными пакетами, подключать различные компоненты, и все это на том уровне абстракции, когда им будет необходимо менять минимум кода и при этом там тестировать сотни тысяч разных моделей, вообще не загоняясь о том, какие они бывают.
3515.00 3526.24 "Анатолий Кулаков" Дальше компонензайшн, то есть это возможность добавлять какие-то новых провайдеров или добавлять какие-то новые фичи, и не задумываясь о том, какая там у вас есть реализация.
3526.24 3541.64 "Анатолий Кулаков" Или, например, тестировать ваше приложение, то есть в качестве примера можно, например, в продакшене запускать ваши алгоритмы на OpenAPI-движке, а все тесты запускать на локальной LLAMI, которая бесплатная, локальная, быстрая и предсказуемая.
3541.64 3552.88 "Анатолий Кулаков" И таким образом наша кастомизация, наше тестирование будет проходить более-менее с такими справдивыми данными, поэтому мы будем экономить и средства, и ресурсы и прочее-прочее-прочее.
3552.88 3559.28 "Анатолий Кулаков" Из коробки нам уже сейчас доступны в данном превью несколько компонентов, несколько реализаций.
3559.28 3571.04 "Анатолий Кулаков" Прежде всего, это OpenAI-имплементация, это, естественно, журовская имплементация, куда же без нее, и OLAMI-имплементация, это возможность как раз подключить, например, оффлайновые модели.
3571.04 3586.84 "Анатолий Кулаков" Кстати, мы в прошлом выпуске обсуждали OLAMI-Sharp, это специальная библиотека, которая позволяла запускать наши модели локально и в дот-нете общаться с этими локальными моделями.
3586.84 3607.84 "Анатолий Кулаков" То есть реализация от Microsoft, по сути, вот эта OLAMI, она получается конкурент той библиотеки, которую мы обсуждали с вами в прошлом выпуске, но смысл весь остался тот же самый, поэтому если вы пропустили информацию о том, как локально запустить большие языковые модели и на C# с ними работать, вот послушайте предыдущий выпуск.
3607.84 3622.32 "Анатолий Кулаков" Кстати, к нам в комментарии на ютубе пришел замечательный человек и немножко нас поправил, что сказал, что OLAMI-Sharp это не единственный способ локально запускать модели, существуют другие библиотеки, существуют другие инструменты, и действительно это так.
3622.32 3627.76 "Анатолий Кулаков" Необходимо упомянуть, что мы лишь вам рассказали о некоторых вариантах, безусловно, таких вариантов намного больше.
3627.76 3635.40 "Анатолий Кулаков" Поэтому большое спасибо за поправку, если вдруг у вас тоже есть какие-то там замечания, то приходите, оставляйте комментарии, мы будем очень рады.
3635.40 3642.44 "Анатолий Кулаков" Итак, что же у нас есть, что же дальше можно сказать про Microsoft Extension AI?
3642.44 3657.76 "Анатолий Кулаков" Ну, то, что у нас есть куча самплов на GitHub-репозитории, поэтому если вы хотите уже конкретно посмотреть, каким образом копы на AI подключить чатик, законнектить его, настроить, запросить оттуда какие-то данные, вывести на консольку, вот это все, это в примерах есть.
3657.76 3663.68 "Анатолий Кулаков" Примеры красивые, подготовленные и заимплементированы для всех провайдеров, которые здесь есть.
3663.68 3683.92 "Анатолий Кулаков" Также напомню, что у нас теперь есть eShop Support, это специальный сампл от Microsoft, большой такой разрезистый интерфейс приложений, который как раз построен на том, чтобы показать возможности всяких AI-компонентов, и там Microsoft Extension AI уже тоже используется, поэтому можно взять, открыть его, посмотреть и какие-то идеи, может быть, взять в свое приложение.
3683.92 3693.64 "Анатолий Кулаков" Ну, и так как библиотека все еще находится в превью, то Improvement, Expanding, Functionality, Performance Extensibility и прочее тоже нас ждет впереди.
3693.64 3704.28 "Анатолий Кулаков" Вот еще один такой фермерчик, который Microsoft объявила, анонсировала и будет поддерживать, а мы будем держать вас в курсе, что там интересного они еще будут туда напихивать.
3704.28 3716.76 "Игорь Лабутин" Однозначно будем, поглядим AI тоже в тренде и видимо, я не знаю, насколько, я даже ожидаю, что половина Дотнад 9 конфы будет про AI в том или ином виде.
3716.76 3724.72 "Анатолий Кулаков" Я думаю, да, в прошлое тоже там было очень-очень много, мы выдирали там буквально по кусочкам для нормальной новости, но это не должно уступить.
3724.72 3749.92 "Игорь Лабутин" Ладно, пойдем в нормальные, наконец-таки, новости, которых у нас давно не было, от Microsoft появилась, вышла, точнее, большая, подробная, ну ладно, наверное, не такая редкая статья про прям кишочки-кишочки и хардкор-хардкор, наверное, сравнима только с статьями Taoba про performance improvements, а именно статья про SVE.
3749.92 3752.08 "Игорь Лабутин" Давайте разберемся, про что эта штука.
3752.08 3783.96 "Игорь Лабутин" Мы знаем, что у нас есть Synth, мы много про него рассказывали, это Single Instruction Multiple Data, то есть это некоторые специальные инструкции процессора, которые позволяют работать над векторами в довольно-таки, ну скажем так, оптимизированном виде, в том смысле, что параллельно обрабатывается один или несколько векторов, над ними выполняется какая-то определенная операция, одновременно сразу над всеми элементами, за счет чего достигается, ну, скорость, которая выше, чем просто если линейно эти вектора делать на обычном CPU, в смысле обычными инструкциями.
3783.96 3798.64 "Игорь Лабутин" Но проблема с Синдами в том, что она, эта технология требует векторов фиксированного размера, то есть оно работает там только со 128-битными, например, и вот вы тогда вынуждены писать ваш код ровно на них.
3798.64 3829.40 "Игорь Лабутин" SVE это штука, которая позволяет как раз делать то, что называется Flexible Vector Processing, то есть с векторами, у которых длина может меняться от 128-бит до 2048-бит, соответственно, без необходимости как-то перекомпилировать приложение, потому что под разные типы симдов вы должны использовать прям разные типы векторов в коде, у нас есть в C# соответствующий тип вектора t и вы туда должны запихать нужную чиселку сразу.
3829.40 3832.98 "Игорь Лабутин" Как это работает?
3832.98 3896.38 "Игорь Лабутин" Ну для этого добавляются внезапно новые регистры, регистров добавляется довольно много, у нас добавляется обычных, ну как обычных, тех самых Scalable Vector Registers в количестве 32 штуки новых от Z0 до Z31, также добавляется регистров, которые называются предикаты, регистры предикатов, я сейчас расскажу зачем они нужны, ну и еще добавляется один регистр под названием First Faulting Register, он нужен для определенных операций, предикатные регистры они довольно интересные, потому что они покороче, они подлиннее, это 1/8 длины регистров, которые Z-регистры, Z0-Z31, и они работают в каком-то смысле как битовая маска, ну только они не по битово, они по, поскольку они 1/8, то получается по байтово, то есть они маскируют целые байты сразу, ну вот так вот.
3896.38 3916.34 "Игорь Лабутин" Дальше, что у нас есть в API, что у нас есть в .NET, статья сразу скажу, она довольно подробная и детальная, там прямо с наглядными картинками, кто как куда, в какие операции, какие битики меняются, как это все работает, это все рассказывать голосом понятно, битовую арифметику очень сложно, поэтому я так общий обзор сделаю, если интересно, почитайте как это внутри работает.
3916.34 3944.46 "Игорь Лабутин" Значит .NET, интеграция .NET с технологией SVE сейчас заключается в том, что у нас есть API, которая позволяет работать, но пока в девятом .NET она конечно SVE, она scalable vector, но это все будет забито, зашито на вектора длиной ровно 128 бит, ну вот так получилось, пока в первой версии, потом понятно расширят, чтобы они были действительно scalable, но пока 128 бит.
3944.46 4105.26 "Игорь Лабутин" Для того, чтобы поддерживать операции, мы используем те самые, тот же самый тип вектора t, и для предикатных типов тоже используется, для предикатных регистров, для предикатных этих переменных, которые надо передавать в операции, тоже используется тип вектора t, рассматривали возможность ввести специальный тип, там вектор маска или еще что-нибудь в таком духе, но там в статье объясняются причины, почему так не было сделано, но как минимум просто для того, чтобы API было попроще, и всякие разные операции в итоге добавляются, и добавилось их прям очень немало, для того, чтобы добавить новые инструкции, то есть инструкция в SVE это некоторая такая базовая операция, то есть например, не знаю, там сложение или там взять первый элемент, если он не ноль, иначе взять второй, ну и из таких базовых операций, примерно чуть больше чем 1100 штук, нормальный такой набор, то есть все эти операции были добавлены в runtime, в компилятор, поддержку, и понятное дело, что руками такое написать было довольно сложно, главное без ошибок, поэтому было сделано следующее, да, это все работает на ARM процессорах, то есть это все в основном, ну только для ARMA, и есть спецификация от ARMA в виде PDF, в которой это все описано, и сначала команда .NET попыталась написать tool, который распарсил PDF, вытащил из нее все необходимые вот эти вот опкоды, и там входные и выходные параметры, и из этого сгенерировал какой-нибудь код, PDF распарсить не получилось, поэтому в итоге они получили от ARMA xml-ный вариант набора этих инструкций, ну и соответственно сгенерировали нужное количество плюсового кода в runtime, в JIT, чтобы сэкономить некоторое количество времени, ну tool они писали месяц, возможно за это время можно было бы написать, но может быть это было бы с ошибками, ну и довольно много всего, времени все равно пришлось много потратить на то, чтобы все эти инструкции аккуратно прописать, прописать логику аллокатора регистров, потому что инструкция-то конечно просто, не прототипы, как это называется-то, ну интерфейс интринсики, и объявления функций писать можно, сгенерить, но логику аллокатора регистров, как для каждой операции лоцируют регистры, какое количество их там нужно, это все нужно писать более-менее руками, это все пришлось написать руками, то есть довольно большая работа проделана, хотя и часть автоматизировали.
4105.26 4140.58 "Игорь Лабутин" Дальше проблема возникла следующая, напомню, что мы добавили 32 новых регистра, плюс еще, по-моему, там то ли 16, то ли сколько-то вот этих вот предикатных регистров, короче, возникла проблема, потому что раньше внутри онтайма маски, в логике, которая определяла какие там регистры использованы, не использованы, как с ними работать, использовалось 64-битное число в виде маски, где каждый битик был собственный один регистр, и тут мы добавили новых, причем немало, и их общее число стало больше чем 64.
4140.58 4154.86 "Игорь Лабутин" Кстати, надо было что-то сделать, там они рассмотрели, по-моему, 3 или 4 разных варианта, как с этим можно побороться, ну перешли на простую вещь, они просто сделали структурку из двух 64-битных чисел, и теперь у нас 128 возможных регистров, которые можно так закодировать масочками.
4154.86 4161.38 "Игорь Лабутин" Это тоже была довольно интересная нетривиальная задача, потому что эта логика, она прошита через практически весь ронтайм.
4161.38 4175.26 "Игорь Лабутин" А дальше еще интересная штука с коллинг конвеншеном, я помню, что когда вы живете на уровне вот таком низком, когда вы уже вызываете просто функции с точки зрения как бы инструкции процессора, то есть понятие коллинг конвеншен.
4175.26 4198.30 "Игорь Лабутин" Наверное, кто-то помнит еще всякие слова типа fast call, cd, std call, и вот это все, и по сути коллинг конвеншен определяет, а как должны быть разложены аргументы, то есть кто отвечает за то, что аргументы будут положены в нужное место регистров стека, кто отвечает за то, что они будут оттуда очищены, и так далее, и в каком порядке эти регистры используются, какие.
4198.30 4218.06 "Игорь Лабутин" И в общем, для вызова вот этих sve инструкций есть свои интересные моменты того, как вызывать, особенно интересно то, что они немножко отличаются в зависимости от того, коллинг конвеншен отличается в зависимости от того, вызываете вы обычный метод или sve метод, ну sve инструкцию.
4218.06 4237.70 "Игорь Лабутин" И там тоже есть некоторые свои приколы, потому что у нас много регистров, если по дефолту мы будем всегда сохранять все регистры, куда-нибудь дампить, а потом их восстанавливать, мы просто потратим кучу времени и вся экономия того, что мы вызываем какую-то супервекторизованную инструкцию сведется на нет, поэтому тоже надо к этому подходить довольно интересно.
4237.70 4267.62 "Игорь Лабутин" Ну и да, тот самый first_fault_register, с ним тоже пришлось отдельно поработать, есть отдельная специально выделенная опишка, то есть из этих 1100+ опишек есть несколько методов для работы конкретно с этим регистром, который как раз ну это в некотором смысле можно сказать такой регистр переполнения или что-то в таком духе, в который некоторые операции могут записать дополнительные результаты, потом его использовать, ну соответственно вот для него тоже пачка опишек сделана.
4267.62 4292.34 "Игорь Лабутин" После того, как вы добавили в рантайм 1100 с лишним новых инструкций, было бы неплохо как-то это протестировать, потому что понятно, что что-то может пойти не так, и это все действительно сильно протестировали, тоже нагенерили кучу тестов некоторым код-генераторам, ну плюс какое-то количество, видимо, написали руками, чтобы проверить, что все правильно генерится в разных случаях.
4292.34 4316.46 "Игорь Лабутин" Довольно много было сделано ручного тестирования, потому что в момент, когда все это добавляли, далеко не все можно было запустить в CI, просто из-за ограничений железа, потому что далеко не все железо поддерживает SVE, это такая сейчас довольно передовая штука, и просто на обычной виртуалочке это не запустить, нужны специальные виртуалки с поддержкой SVE, и это в общем не так-то просто.
4316.46 4415.78 "Игорь Лабутин" Ну и дальше проблема в том, что поддержали пока всю эту очень маленькую часть, выглядит это все конечно очень, так скажем, то, что по-английски называется промиссинг, многообещающее, но пока все это ограничено 128 битами и только, это не поддержано в режиме nativeout никак, это все пока под флагом experimental, и понятно, что Microsoft ждет некоторого фидбэка от комьюнити на предмет того вообще, насколько это все будет нужно, потому что дальше там есть всякие разные решения, то есть помимо того, что нужно сделать его действительно scalable, то есть действительно динамичным с точки зрения, не только 128 бит, а максимум до 2 килобайт, но есть еще дальше расширение там стриминг мод, а есть еще scalable matrix extensions, следующая, так скажем, ступень, когда вы не над векторами, а уже прямо над матрицами оперируете, и кажется в сторону, это опять же, реверанс в каком-то смысле в сторону AI, чуть-чуть не того, тех мест, хотя понятно, что там в основном все на графических карточках делается, но почему бы быстро матрицы не поперемножать, и на CPU, так что вот, если вы хотите почитать хардкорную статью, обязательно рекомендую, действительно хорошо написано, кунау, в общем, знает толк в том, как писать статьи, все подробно объяснено со схемами, и в целом все понятно, но рассказывать это прям тяжело, потому что, ну я так и не придумал как нормально рассказывать всякие такие битовые штуки голосом, поэтому кратенько я рассказал, дальше если тема заинтересовала, посмотрите, рекомендую прям статью.
4415.78 4419.66 "Анатолий Кулаков" Ну да, такие вещи, наверное, лучше визуально как-то осознавать.
4419.66 4434.02 "Анатолий Кулаков" Так, еще интересно есть статейчика, очень нишевая, но вполне интересная, это немножко поговорить подробнее про Overload Resolution Priority.
4434.02 4450.98 "Анатолий Кулаков" Мы упоминали уже про этот атрибут скольз, когда обсуждали новинки C# 13, но там было довольно мало примеров и не очень понятно, зачем он нужен, и вот вышла статья, которая нам как раз таки немножко примерщиков раздает, и можно примерно представить, как эта штука используется.
4450.98 4456.14 "Анатолий Кулаков" Итак, Understanding Overload Resolution Priority - атрибут.
4456.14 4471.50 "Анатолий Кулаков" В C# 13, как я уже сказал, появилось сие чудо, и для широкого круга, наверное, мало применимо, но вот для библиотек это довольно полезная штука, наверное, Microsoft в первую очередь может для самого себя и выпускал.
4471.50 4483.30 "Анатолий Кулаков" Так, здесь мне тоже потребуется от вас фантазия, которая заставит вас представлять код в голове, поэтому давайте тренируемся, я думаю, этот навык у вас уже хорошо разлился после прослушивания наших подкастов.
4483.30 4488.70 "Анатолий Кулаков" Представьте, что у нас есть библиотечка и есть наше приложение, которое использует этот библиотечный метод.
4488.70 4520.70 "Анатолий Кулаков" В библиотечке очень просто, у нас есть класс Sample, и у нас есть у этого Sample один единственный статический войд и метод, который называется Test, и этот тест выводит на консоль строчку, которая называется Test1, самая примитивная штука, которую можно представить, статический класс с единственным войдовым статическим методом, который просто на консоль печатает константу Test1, у этого метода никаких атрибутов нет, никаких аргументов нет, и у нас есть какое-то приложение, которое просто-напросто делает из статического класса точка Test1, без всяких параметров, вызывает этот метод.
4520.70 4524.54 "Анатолий Кулаков" Вот такой пример, и нам его, в принципе, достаточно на протяжении всей статьи.
4524.54 4527.62 "Анатолий Кулаков" Надеюсь осознали, представили, поехали дальше.
4527.62 4539.62 "Анатолий Кулаков" Теперь мы хотим обновить нашу сигнатуру, мы хотим добавить один опциональный параметр, допустим, CallerMemberName, т.е. мы теперь хотим у этого теста знать, а кто же собственно нас вызывает.
4539.62 4548.78 "Анатолий Кулаков" Поэтому мы берем старый метод и добавляем к старому методу опциональный строковой параметр, который называется Name.
4548.78 4553.66 "Анатолий Кулаков" Ставим ему атрибут CallerMemberName, и по дефолту даем значение пустая строка.
4553.66 4557.14 "Анатолий Кулаков" Т.е. у нас опять же статический класс Sample появляется, т.е.
4557.14 4567.66 "Анатолий Кулаков" был класс Sample, в нем вместо старого метода появляется статический void метод Test, у которого есть один единственный аргумент, имеющий значение по умолчанию, пустая строка.
4567.66 4570.98 "Анатолий Кулаков" И в качестве реализации он теперь выводит слово Test.
4570.98 4584.94 "Анатолий Кулаков" Кажется, что в принципе все нормально, мы сделали то, что хотели, мы расширили нашу сигнатуру, при том ничего не сломали, так как мы сделали дефолтное значение поставить этого метода, но это только на первый взгляд.
4584.94 4604.06 "Анатолий Кулаков" Наши внимательные слушатели, те, кто слушал наш выпуск про Breaking Change, конечно догадались, что даже если мы выставляем дефолтное значение этому аргументу, то это бинарный Breaking Change, и так делать нельзя, и мы не можем такой себе позволить, как авторы библиотек.
4604.06 4615.74 "Анатолий Кулаков" Гораздо более правильным методом было бы все-таки оставить старую сигнатуру, абсолютно без параметров, и при этом добавить еще один новый метод, у которого будет уже новый параметр, тот, который мы хотим.
4615.74 4620.32 "Анатолий Кулаков" Но, к сожалению, это тоже не работает, давайте рассмотрим подробнее почему.
4620.32 4642.42 "Анатолий Кулаков" Итак, если мы оставляем старый метод Test без параметров, и добавляем новый метод, который называется точно также Test, но при этом у него есть один единственный параметр с дефолтным значением пустая строка, то компилятор будет использовать старый метод в вашем приложении, т.е. старый метод Test.
4642.42 4643.42 "Анатолий Кулаков" Почему?
4643.42 4648.26 "Анатолий Кулаков" Ну, вот у него такие правила Resolution, т.е. правила нахождения метода.
4648.26 4654.62 "Анатолий Кулаков" Если метод существует, т.е. имена у них одинаковые, напомню, и компилятору нужно выбрать, какой из них вызвать.
4654.62 4674.14 "Анатолий Кулаков" И первый метод у вас без параметров, а второй с одним единственным параметром, и у этого параметра заданное значение по умолчанию, то компилятор как раз вызовет метод без параметра по дефолту, потому что он больше подходит под вот эти его правила, с помощью которых он выбирает, какой из методов вызвать, т.е. методов с одинаковыми именами.
4674.14 4687.68 "Анатолий Кулаков" Напомню, что удалить старый мы не можем, потому что это сразу breaking change, т.е. нам как-то нужно оставить оба метода, но при этом заставить существующий код в приложении вызывать наш новый, не удаляя старый.
4687.68 4690.46 "Анатолий Кулаков" Кажется, что задача практически невыполнима.
4690.46 4704.78 "Анатолий Кулаков" И вот как раз в этот момент на сцену выходит наш Overload Resolution Priority атрибут, который как раз таки вам позволяет указать приоритет, с помощью которого компилятор будет выбирать, а какой же из Overload методов он выберет.
4704.78 4721.66 "Анатолий Кулаков" И если, ну опять же, приоритет может быть отрицательным, т.е. нам необязательно новому методу повышать приоритет, мы можем старому методу приоритет понизить, так и сделал автор, он взял старый тестовый метод, тестовый без параметров, и навесил ему атрибут со значением -1.
4721.66 4729.62 "Анатолий Кулаков" В этот момент наш новый метод, который с одним-единственным параметром со значением по умолчанию, стал автоматически приоритетом побольше.
4729.62 4739.38 "Анатолий Кулаков" И поэтому теперь компилятор выберет именно его в нашем приложении, который вызывает просто метод теста из статического класса.
4739.38 4748.38 "Анатолий Кулаков" Т.е. теперь вы можете добавить себе в библиотеку Override метод совсем без Breaking Changes, что в принципе и собственно мы и хотели добиться.
4748.38 4757.82 "Анатолий Кулаков" Еще одно интересное использование, можно даже сказать, этого метода, этого атрибута довольно неочевидно.
4757.82 4776.90 "Анатолий Кулаков" Допустим, у вас есть класс Sample, у него есть метод test, и т.е. один и метод test есть второй, и эти тесты называются одинаково, эти методы называются одинаково, и все они принимают один-единственный аргумент, но первый принимает int-овый аргумент, а второй принимает byte-овый аргумент, один-единственный.
4776.90 4791.10 "Анатолий Кулаков" Если мы вызовем метод test, например, с единичкой, то у нас автоматически будет использоваться int-овое переопределение, т.е. тестовый метод с int-овым аргументом.
4791.10 4797.42 "Анатолий Кулаков" Ну потому что компилятору больше единичка кажется, что она больше похожа на int, чем она похожа на byte.
4797.42 4808.10 "Анатолий Кулаков" Но если мы хотим, допустим, то, что влазит в byte, передавать в метод byte-овый, который принимает byte, а то, что в byte-овый не влазит, уже в int-овый.
4808.10 4810.94 "Анатолий Кулаков" Раньше тоже такое сделать практически нереально было.
4810.94 4824.90 "Анатолий Кулаков" Теперь достаточно поставить атрибут overload resolution priority в 1 над byte-овым методом, т.е. указать, что byte-овый метод наиболее приоритетный, и после этого компилятор будет пытаться подставить в byte-овый метод все значения, которые влазят в byte.
4824.90 4841.18 "Анатолий Кулаков" Например, если мы вызовем sample test с единичкой, он будет использовать byte-овый метод, а если мы вызовем sample test с 1000, то уже в byte компилятор его не сможет засунуть, и поэтому будет использовать метод test с int-ом.
4841.18 4844.96 "Анатолий Кулаков" Вот такое довольно неочевидное применение вот этого атрибутика.
4844.96 4858.62 "Анатолий Кулаков" Из ограничений следует отметить, что данный resolution priority атрибут, он поддерживает только методы, которые находятся в одном и том же классе, которые находятся недалеко друг от друга.
4858.62 4874.78 "Анатолий Кулаков" Т.е. поэтому невозможно создать, например, какой-нибудь extension метод, назвать его точно так же, как, например, какой-то существующий extension метод и переопределить поведение существующего extension метода, чтобы теперь все начали вызывать ваш extension метод, а не тот, который был там.
4874.78 4893.10 "Анатолий Кулаков" Скорее всего, это сделали специально, опять же, потому что код может прийти вообще в невалидное состояние, если мы сейчас начнем переопределять какие-то уже существующие методы, к которым уже все привыкли, допустим, тот же самый linq, можно будет заново весь переопределить в каком-нибудь соседнем extension классе, все бы сошли с ума.
4893.10 4895.34 "Анатолий Кулаков" Поэтому, скорее всего, это было сделано специально.
4895.34 4945.50 "Анатолий Кулаков" Итак, если у вас есть .NET 9, то никаких проблем, вы можете использовать этот атрибут на свое усмотрение, но если вы используете более раннюю версию .NET, в котором этот атрибут еще не был объявлен, то тоже не беда, потому что можно воспользоваться так называемыми полифилами, это или где-то пакет можно поставить, где этот атрибут объявлен, или можно просто-напросто написать в вашем собственном коде, заимплементировать самому этот атрибут, потому что на самом деле компилятору неважно в каком нам спейсе лежит этот атрибут, он просто смотрит на название, поэтому вы можете у себя просто-напросто объявить internal sealed class avelot-resolution-priority-attribute от наследованного атрибута, указать ему все нужные поля, набросить на него все нужные атрибутики, и компилятор сможет его использовать, независимо от того, какой у вас фреймворк, главное, чтобы компилятор поддерживал это чудо.
4945.50 4956.26 "Анатолий Кулаков" Вот, вот такое довольно узкое нише, наверное, действительно, применение этого атрибута, но зато, если оно вам понадобится, то вы можете решить довольно сложные задачи, которые перед вами встали.
4956.26 4971.90 "Игорь Лабутин" Ну да, я так понимаю, что основная его цель — это как раз-таки для самой команды рантайма и бестандартной библиотеки, чтобы иметь возможность добавлять новые методы перегрузки в библиотеки, не нарушая совместимость никак со старым кодом.
4971.90 4972.90 "Игорь Лабутин" Ну, наверное, да.
4972.90 4978.34 "Игорь Лабутин" Но, действительно, авторы библиотек могут тоже воспользоваться при случае и действительно что-то удобное сделать.
4978.34 4982.86 "Игорь Лабутин" Ну чего, основной контент, мне кажется, мы разобрали.
4982.86 4995.26 "Игорь Лабутин" Кажется, можно перейти к кратко о разном, куда у меня очень чесались руки запихнуть DotNet 9 RC2, который действительно получился очень кратким, но есть и без DotNet 9 RC2 о чем поговорить.
4995.26 5006.26 "Игорь Лабутин" И начнем мы с статьи про серилок, небольшая статейка у Николаса Бломхарта о том, что вышел новый серилок 4.1.
5006.26 5009.06 "Игорь Лабутин" Насколько я понимаю, это какой-то превью, ну в каком-то виде.
5009.06 5012.50 "Игорь Лабутин" Но там появилась интересная фича, называется fallback-синки.
5012.50 5048.58 "Игорь Лабутин" То есть если вы когда-нибудь сталкивались с задачей, что нужно писать, например, логи в какой-то синк, но если он недоступен, то, например, хотя бы сложить файлик, то есть, ну, например, не знаю, шлем куда-нибудь по сети, но если вдруг сеть почему-то отвалилась, ну давайте хотя бы файл запишем, чтобы не потерялось, то теперь есть прям встроенная фича, вы вместо того, что вы write to точка и куда вы там пишите, пишете теперь write to точка fallback-chain и дальше в виде набора аргументов перечисляете разные, собственно, синки, куда вы хотите записать, и он в некотором порядке будет их, ну в порядке выказанном на самом деле будет перебирать.
5048.58 5088.06 "Игорь Лабутин" При этом это все работает на основе новой фичи, которая называется, ну которая реализуется через интерфейс iLoggingFailureListener, и это интерфейс, в котором есть метод, который позволяет вам обработать тот факт, что вы что-то не записали в какой-то синк, ну и сделать некоторые следующие действия, вот fallback-chain, он просто выбирает следующий синк и пытается записать туда, там дальше можно понастраивать всякие разные количества повторов, вот это все, но в целом если вам нужен какой-то прям супернадежный логинг, который точно хоть что-то хоть куда-то запишет, там в сеть, в файл, не знаю, в консоль, куда угодно, то почему бы и нет, можно теперь такое поиспользовать в новом серилоге.
5088.06 5150.82 "Анатолий Кулаков" Так, я напомню, что мы в прошлом выпуске обсуждали статью, которая нам рассказывает, о каким образом можно расширить функциональность enum'ов с помощью перехода там на рекорды, на классы стандартных enum'ов, которые в C#, и вот к нам на ютубчике тоже пришел автор, тоже пришел наш слушатель и сказал, что в принципе он знает хорошую библиотечку, поэтому если вам вдруг не хватает функциональности стандартных enum'ов, то можно воспользоваться библиотекой, которая называется Smart Enums, то есть для этого есть даже специальная библиотека, кто бы мог подумать, и она примерно делает то же самое из коробки, вот что мы обсуждали в статье, и еще поддерживает там специфику с серилизацией или де-серилизацией, поэтому отличная тоже библиотечка, я посмотрел, Smart Enums, если вдруг кто-то сталкивался с такой проблемой, что вам не хватает стандартных enum'ов, тоже гляньте на нее, полезная штука, ну и если вдруг у вас еще будут какие-то интересные библиотеки, которые будут в исполнении, опять же, пишите в комментариях, очень интересно все читать, Smart Enums, это как тоже ссылочка будет в шоу-нотах.
5150.82 5207.46 "Анатолий Кулаков" Еще одна интересная статья, которая вышла и поразила нас до глубины души своим откровением, это то, что райдер получает новую лицензию, то есть у райдера появляется non-commercial use лицензия, в частности JetBrains выпустил райдер WebStorm под non-commercial use лицензией, начиная с версии 2024.2.7, будет доступна такая штучка, и это полноценная IDE, полнофункциональная, без всяких там ограничений, и ее функциональность абсолютно сопоставима с платной версией, за исключением, наверное, нескольких моментов, в частности, у вас всегда будет собираться Data Collection, то есть будет отправляться анонимная статистика в лого JetBrains, это нельзя отключить в non-commercial use лицензии, и там нет оффлайна активации, то есть для того, чтобы активировать вам IDE с такой лицензией, необходим JetBrains аккаунт.
5207.46 5221.70 "Анатолий Кулаков" В принципе, и это, по-моему, все ограничения, в статье более подробно описано, кто считается commercial use, кто не commercial, там, в принципе, довольно хорошие примеры приведены, если для вас это важно, то почитайте, посмотрите.
5221.70 5224.66 "Анатолий Кулаков" Ну а всем остальным попробуйте проверить, насколько эта штука будет работать.
5224.66 5237.26 "Игорь Лабутин" Да, отлично, и теперь пойдем в последнюю нашу тему, тут я довольно активно опять вернулся к прослушиванию разных подкастов, и есть у меня две рекомендации для вас.
5237.26 5269.10 "Игорь Лабутин" Один подкаст – это подлодка, который я дослушал почти до конца, и выпуск 393 про социальную инженерию, он не про дотнет, он не про технику, но он прям про все вот эти вот звонки, да, про банки, МВД, вот это все, послушайте, там специалист в этой области, в смысле в области безопасности и вокруг всего этого рассказывает подробно, детально, как это работает, какие способы применяются, просто очень интересно послушать для общего развития, прям рекомендую, с удовольствием провел эти сколько там, полтора часа или около того.
5269.10 5306.70 "Игорь Лабутин" Ну а если говорить про дотнет, то у No Dogma Podcast вышел выпуск 174 с Мэтсом Торгерсоном, мне кажется, это у них уже такая плюс-минус традиция, по-моему, на последние две или три версии он точно приходит, и он рассказывал про C# 13, там первые полвыпуска я бы, может быть, даже рекомендовал плюс-минус пропустить, потому что там они обсуждают какая же классная фича, значит, по RAMS, которые теперь могут быть IEnumerable и всем таким прочим, в очередной раз обсуждают, как происходит процесс дизайна языка, вот это все, комьюнити там, да, LDM, ну так, не очень много.
5306.70 5313.74 "Игорь Лабутин" А самое интересное, это последние где-то, по-моему, минут 20 или 25, где обсуждается судьба трех фич.
5313.74 5376.90 "Игорь Лабутин" Одна фича, это Field Keyword, я напомню, что мы, ну я не знаю, сколько раз уже в этом подкасте упоминали про эту фичу, про то, что у нас есть Getter и Setter, да, в Setter у нас уже есть спецслово, ключевое слово Value, и была идея, ну она даже реализована, добавить ключевое слово Field так, чтобы можно было не писать BackingField руками, а просто присваивать в такой Field, и с этим ключевым словом была проблема, что оно могло конфликтовать с реальным полем, который называется Field, что в этом случае делать было не очень понятно, была идея, что а давайте мы сделаем вот такой режим, когда мы новым SDK компилируем проект под старый SDK, который при этом знает про то, что мы добавляем какие-то Breaking Features, Breaking Changes, в частности, Field, то есть мы сможем проанализировать таким компилятором старую версию кода, понять, что там есть или нет проблемы, подсветить это вордингами, сказать, вот смотри, если ты сейчас переключишь SDK, то мы тебе все сломаем, поэтому давай ты здесь поправишь, тебе, кстати, и код фикс, значит, прямо в студии.
5376.90 5402.82 "Игорь Лабутин" Отличный был план, это была экспериментальная фича, которую они собирались зарелизить в C# 13, чтобы как раз таки проверить, как вот вся эта история с подходом к этим Breaking Changes будет работать, чтобы была потом некоторая история и понимание, можно ли с таким работать, и как сказал Mads, ближе к релизу они поняли, что это что-то им как-то стремно, релизить такую штуку, вдруг они кого-то сломают, и они решили ее убрать в превью.
5402.82 5405.58 "Анатолий Кулаков" Погоди, это же экспериментальная штука, как она может кого-то
5405.58 5406.58 "Игорь Лабутин" сломать?
5406.58 5448.18 "Игорь Лабутин" Ну в смысле нет, она не планировала быть экспериментальной, то есть она планировала быть в нормальном релизе, то есть если ты берешь, если у тебя есть, допустим, класс, да, в нем есть PolyField, ты у себя в csproj ставишь новый .net и сразу в csproj ставишь target.net 9, не пытаясь скомпилировать target.net 8 новым девятым SDK, то у тебя все сломалось, потому что твой силт теперь не используется, используется ключевое слово, ну или может он хотя бы не скомпилируется, я уже не помню, как оно будет работать в разных случаях, но технически у тебя может поменяться поведение, грубо говоря, твоего кода, без каких-либо вордингов, предупреждений, чего угодно.
5448.18 5455.74 "Анатолий Кулаков" Ну а как же они планировали эту штуку внедрять, если не осознали в последнюю неделю перед релизом, а до этого два года разрабатывали?
5455.74 5470.94 "Игорь Лабутин" План был такой, что ты никогда, ну ладно, не то что все разработчики будут такие умные, ты сначала ставишь новый SDK, им компилируешь, потом только поднимаешь версию target SDK, когда ты убедился, что под старый SDK тоже собирается, в смысле
5470.94 5471.94 "Анатолий Кулаков" под старый target.
5471.94 5475.34 "Анатолий Кулаков" Ну вот и они поняли, что этот план не рабочий, да, и они от него ушли.
5475.34 5487.30 "Игорь Лабутин" Кажется, что они, ну, Мэтт сказал, что что-то мы испугались, то есть он буквально сказал сразу, что we were afraid of breaking changes, и поэтому типа убрали фичу в превью.
5487.30 5493.74 "Анатолий Кулаков" Ну так могли же тоже ее закрыть каким-нибудь экспериментальным атрибутом, чтобы те, кто явно включил такую штуку, могли…
5493.74 5512.14 "Игорь Лабутин" Ну да-да-да, ну в превью в смысле, это значит, что если ты поставишь length preview или как-то там, оно будет работать, пожалуйста, оно есть, но они таким образом по сути не смогут протестировать вот этот свой механизм, как, так сказать, ломать код при этом с нормальными предупреждениями.
5512.14 5518.66 "Анатолий Кулаков" Да, понятно, так а он сказал, в какую сторону они дальше будут двигаться, они вообще забьют или придумают какую-то новую стратегию миграции перехода?
5518.66 5529.66 "Игорь Лабутин" Ну конкретно с field, как я понял, если я правильно понял подкаст, в 14 C# она будет выкачана уже сразу в боевой, и как-то он так сказал, что типа…
5529.66 5531.62 "Анатолий Кулаков" И там они не боятся, да?
5531.62 5539.78 "Игорь Лабутин" Да-да-да, что типа если у вас был код на 12, и вы сразу прогрессите на 14, то типа да, без варников все заработает прямо так.
5539.78 5544.54 "Игорь Лабутин" И там ведущий такой типа, ааа, то есть типа не будет никаких варников, которые вы там вот планировали?
5544.54 5545.98 "Игорь Лабутин" Он такой, не, не будет.
5545.98 5549.78 "Игорь Лабутин" Короче, я что-то не понял, может еще кто-то послушает объяснит мне.
5549.78 5560.66 "Игорь Лабутин" В общем, в 13 они забоялись, а в 14, который еще и LTS будет, напомню, ну в смысле дотнет соответствующий, да, будет LTS, решили, что норм, возможно, они за год еще что-нибудь придумают и передумают.
5560.66 5566.90 "Игорь Лабутин" Ну в общем, в 13 C# field keyword он будет, но для того, чтобы его включить, его нужно будет передать в флажок превью.
5566.90 5575.14 "Игорь Лабутин" Ну и как там этот long version поставить, не latest, а превью уже, по-моему, в C# можно поставить, тогда будет field keyword.
5575.14 5576.14 "Игорь Лабутин" Это первое.
5576.14 5577.14 "Игорь Лабутин" Второе.
5577.14 5578.14 "Игорь Лабутин" Extension everything.
5578.14 5585.22 "Игорь Лабутин" Как мы помним, на MS Buildе конференции летом, Торгерсон с кем?
5585.22 5600.86 "Игорь Лабутин" С Джаредом, по-моему, они, или со Скоттом Хантелем, ну с кем-то они показывали фичу Extension everything, где там были implicit extension, explicit extension, можно было расширить там, не только метод расширения добавить, но и пропертии, что-то там еще.
5600.86 5601.86 "Игорь Лабутин" Индексеры, по-моему, показывали.
5601.86 5602.86 "Игорь Лабутин" Не помню уже точно.
5602.86 5619.34 "Игорь Лабутин" В общем, это фича, которую они тоже не взяли в релиз, потому что они поняли, что когда они написали довольно много кода, они поняли, что они нашли какое-то немеренное количество корнер-кейсов, когда это то ли не работало, то ли работало плохо, то ли мешало чему-то внутри.
5619.34 5622.98 "Игорь Лабутин" В общем, они сделали следующее.
5622.98 5645.82 "Игорь Лабутин" Они еще раз посмотрели на фичу, выкинули оттуда то, что называлось roles, то есть я так понимаю, что это, ну, то есть, грубо говоря, в фиче есть фишки вида там добавить extension методы, а можно добавить, типа там, новую реализацию интерфейса в другую, в уже существующий класс, да, как бы извне, вот роли, я так понимаю, это про это.
5645.82 5654.02 "Игорь Лабутин" Это пока отложили, вот, а extension everything в каком-то виде должен появиться в следующем C#.
5654.02 5662.86 "Игорь Лабутин" Они планируют, что они как бы выкинули самое сложное, остальное они успеют сделать, и в следующем C# у нас в каком-то виде новые экстенджины появятся.
5662.86 5670.66 "Анатолий Кулаков" А то в каком виде они эти roles сделают, они еще не знают, и когда они придумают, это снова будет какая-то пятая нога к бубку.
5670.66 5690.98 "Игорь Лабутин" Ну, вот смотри, нет, в целом, в целом, вот как показал опыт, не знаю, там, паттерн-матчинга, да, они, хоть у них это и получается медленно, но, в смысле, тот же партнер паттерн-матчинга, они неплохо распилили на несколько релизов, да, на 5 релизов подряд, да, и в итоге получилась довольно стройная картинка в конце.
5690.98 5702.22 "Анатолий Кулаков" Конечно, но мне кажется, тут было абсолютно наоборот, они в паттерн-матчинге, скорее всего, сначала все запроектировали, как это расширяться будет и будет внедряться, а потом разбили это все на этапы, это окей.
5702.22 5703.98 "Анатолий Кулаков" А здесь они говорят, мы не можем запроектировать,
5703.98 5706.02 "Игорь Лабутин" у нас не получается, значит, не сходится.
5706.02 5713.34 "Игорь Лабутин" Нет, нет, нет, они не могут сейчас заимплементировать так, чтобы то, что сейчас зарелижено и потом нужно будет поддерживать годами, они были бы в этом уверены.
5713.34 5732.78 "Игорь Лабутин" Я так понял, что они, ну, то есть буквально это звучало, что мы сейчас splitting this feature into parts, я прямо цитату себе записал, то есть они сейчас пытаются распилить эту фичу на, ну, относительно независимые кусочки с понятными переходами между собой и понятно, как каждый кусочек уложить в релиз.
5732.78 5739.10 "Анатолий Кулаков" Ну, хотя бы понятно, чтобы они понимали, чтобы это было консистентно и красиво.
5739.10 5744.22 "Игорь Лабутин" Да, и понятно, что в этом разбиении роли будут точно в конце.
5744.22 5761.82 "Игорь Лабутин" Вот это, типа, было озвучено, то есть роли мы точно не будем брать первыми, первыми мы будем брать, то есть, как он сказал, типа, в следующем релизе, я точно надеюсь, что мы сможем экстендить пропертии, индексеры, возможно, статические мемберы добавлять, возможно, конструкторы.
5761.82 5762.82 "Игорь Лабутин" Вот звучало это так.
5762.82 5763.82 "Игорь Лабутин" Вот.
5763.82 5768.90 "Игорь Лабутин" То есть, ну, типа, основные, короче, что ты мог бы захотеть экстендить.
5768.90 5780.06 "Анатолий Кулаков" Ну, просто если у них уже в голове понимание есть, как это должно выглядеть, и там у них уже какая-то имплементация тоже была, могли бы нам бросить хотя бы пропертии, хотя бы индексеры уже готовые.
5780.06 5783.94 "Игорь Лабутин" Ну, вот, видимо, что-то пошло не так.
5783.94 5790.78 "Игорь Лабутин" И последняя большая фича, про которую мы тоже говорим каждый релиз C# уже много-много лет, это discriminated unions.
5790.78 5793.82 "Игорь Лабутин" Значит, discriminated unions — ситуация такая.
5793.82 5797.82 "Игорь Лабутин" Mads сказал, что сейчас идет над ними активная работа.
5797.82 5855.82 "Игорь Лабутин" Они пытаются придумать и вот как раз-таки сформировать некоторые видения того, как это будет выглядеть в языке, во что это должно превращаться, как это должно обрабатываться, насколько там важна, а, видимо, достаточно важна тот самый completeness с точки зрения pattern matching, это то, что все ждут, чтобы тебе не нужно было писать дефолт, и компилятор сам понимал, чтобы ты здесь рассмотрел все варианты, как это сделать с учетом, ну, грубо говоря, расширяемой системы типов, да, и возможности, на самом деле, там, генерить типы в рантайме, по большому счету, да, наследники, надо все это, ну, продумать, короче, работа есть, и Mads сказал простую штуку, что работа идет, работа идет активная, и discriminated unions-ов точно не будет в четырнадцатом C#, так что два года ждать еще минимум, ай-яй-яй-яй-яй-яй, вот, то есть типа они уверены, что к четырнадцатому не успеют, такие дела.
5855.82 5861.38 "Анатолий Кулаков" Ну, ладно, ну что ж, на этой грустно-пессимистичной ноте давай завершаться.
5861.38 5865.82 "Игорь Лабутин" Да, давай завершаться, ну, как, грустно-пессимистично, но зато честно.
5865.82 5877.10 "Анатолий Кулаков" Опять же, мы какой релиз уже сидим без нормальных фич-то, у нас уже, как бы, хвастаться нечем, то раньше был C# впереди планеты всей, все отставали от нас минимум на десять лет, а тут как бы.
5877.10 5882.86 "Игорь Лабутин" Так котели наворотили таких, ну, правильно, наворотили таких фич, что теперь каждую новую попробуй впихни в этот пазл.
5882.86 5883.86 "Игорь Лабутин" Чем больше пазл, тем хвастаться.
5883.86 5889.46 "Анатолий Кулаков" У них не один год был, у них уже сколько релизов пустую просто проходит, могли бы уже вернуть что-нибудь.
5889.46 5892.58 "Игорь Лабутин" Вот они что-то делают, ну, что непонятно, ладно.
5892.58 5898.70 "Игорь Лабутин" Сегодня мы обсудили девятый дотнет-релиз кандидат-2, в котором ничего нет, только, кстати, работа по стабильности.
5898.70 5925.66 "Игорь Лабутин" Вспомнили, что нового в системе Text.json в, опять же, девятом дотнете, посмотрели на dotnet.aspire, девятый релиз кандидат-1 с кучей новых фич, посмотрели на новую библиотечку Microsoft Extensions AI для работы с AI, глянули на статичку про Scalable Vector Extensions, посмотрели на атрибут Overload Resolution Priority и пообсуждали всякие разные небольшие новости про там будущее C# и все такое прочее вокруг него.
5925.66 5928.78 "Игорь Лабутин" И это был сто второй выпуск радио дотнет.
5928.78 5930.78 "Игорь Лабутин" На этом, наверное, все.
5930.78 5938.30 "Анатолий Кулаков" Да, всем спасибо, до новых встреч, слушайте шары, репост, комментики там, пальчики вверх, все-все-все, как вы умеете, все, как вы любите.
5938.30 5939.94 "Анатолий Кулаков" Всем пока, до новых встреч.
5939.94 5940.58 "Игорь Лабутин" Всем пока.
