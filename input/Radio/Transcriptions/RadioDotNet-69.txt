0.00 11.56 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net, выпуск уже 69-й.
11.56 15.28 "Анатолий Кулаков" И в эфире, как всегда, Анатолий Кулаков.
15.28 16.28 "Анатолий Кулаков" И Игорь Лaбутин.
16.28 17.28 "Анатолий Кулаков" Всем привет.
17.28 26.48 "Анатолий Кулаков" Прежде всего хотелось бы поблагодарить за помощь наших уважаемых помогаторов Александр Сергеев, Владислав, Алексей Шевченко, Антон Илья, Гурий Самарин, Виктор, Руслан Артамонов.
26.48 34.08 "Анатолий Кулаков" Спасибо большое, друзья, а также всем, кто поддерживает нас на Boosty, заходите, смотрите, что у нас там есть интересного.
34.08 37.28 "Анатолий Кулаков" Ну что ж, наверное, перейдем непосредственно сразу к статьям.
37.28 38.96 "Анатолий Кулаков" У нас тут накопилось много статейчиков.
38.96 41.96 "Анатолий Кулаков" Новостей немного, но зато интересные какие-то статьи.
41.96 49.60 "Анатолий Кулаков" И как-то странно они сгруппировались вокруг такой темы, как докер и секьюрити сегодня, и диагностика.
49.60 50.96 "Анатолий Кулаков" Что-то такое у нас получается.
50.96 52.92 "Анатолий Кулаков" Выпуск про секьюрити и докеров.
52.92 53.92 "Игорь Лабутин" Ну типа того.
53.92 60.64 "Игорь Лабутин" Не то чтобы прям совсем нет новостей, как раз-таки про докер новости есть немножко от Microsoft, поэтому ровно с него мы и начнем.
60.64 64.56 "Игорь Лабутин" Ну и по пути затронем некоторое количество связанных статей, ну или не очень связанных.
64.56 66.56 "Игорь Лабутин" В общем, посмотрим, что будет.
66.56 81.04 "Игорь Лабутин" Итак, в седьмом дотнете, который зарелизился у нас в ноябре, в одной из превьюшек, которая была в августе, была заанонсирована фича под названием, как это называлось, типа нативная поддержка контейнеров.
81.04 82.60 "Игорь Лабутин" То есть что можно было сделать?
82.60 110.12 "Игорь Лабутин" Можно было добавить некоторое количество пропертей в C-Sproj, после чего, не пользуясь докер билд, да, и не создавая докер файл, можно было собрать докер имидж просто через .NET Publish, указать туда некоторое количество специальных аргументов, минимум обязательно это было, указать специальный паблиш профайл, и после чего у вас собирался имидж даже без использования докера.
110.12 122.80 "Игорь Лабутин" Цель этого всего мероприятия была в том, чтобы для вас, как и для разработчика, было поменьше всяких разных концепций нужно изучать, чтобы собирать код для клауда.
122.80 146.60 "Игорь Лабутин" То есть Microsoft, понятно, она пытается облегчить жизнь разработчикам тем, чтобы у тебя есть .NET консольная тулза, ну или Visual Studio, в которой тоже есть паблиш диалог, и ты написал код, и через ту же .NET тулзу его собрал через .NET Build, через .NET Publish запаковал в контейнер, и желательно сразу бы запушил куда нужно без использования и необходимости изучения отдельной тулзы, под названием Docker.com.line.
146.60 155.28 "Игорь Лабутин" Но к сожалению в релиз это все не вошло, никакого как бы пуша не было, имидж можно было собрать, но дальше ничего не работало.
155.28 159.92 "Игорь Лабутин" И вот теперь наконец-таки время, руки нашлись, и мы прошли дальше.
159.92 164.28 "Игорь Лабутин" Мы влезаем в Microsoft, пошли дальше, и во-первых поддержали аутентификацию.
164.28 166.96 "Игорь Лабутин" Ну, потому что зачем?
166.96 172.28 "Игорь Лабутин" Потому что нужно пушить в удаленные репозитории, которые еще зовут Registry.
172.28 176.16 "Игорь Лабутин" Но они как правило требуют авторизации, аутентификации авторизацией.
176.16 179.32 "Игорь Лабутин" Поэтому с этим надо было что-то делать.
179.32 185.72 "Игорь Лабутин" Тут Microsoft сильно решила не выпендриваться, они сделали следующую штуку, что если вы...
185.72 187.28 "Игорь Лабутин" Что нужно будет собственно сделать?
187.28 190.92 "Игорь Лабутин" Docker.com.line вам, к сожалению, потребуется, потому что нужно заказать Docker.login.
190.92 195.16 "Игорь Лабутин" Они решили не изобретать велосипед, и тут наверное надо сказать им спасибо.
195.16 203.48 "Игорь Лабутин" Логин происходит через стандартный докеровский command line, то есть вы говорите Docker.login, он там либо спросит логин-пароль, либо как-то все это вы по-другому запоминаете.
203.48 208.84 "Игорь Лабутин" И дальше с этим самым логином будет работать как докеровский command line, так и .NET command line.
208.84 210.12 "Игорь Лабутин" Они переиспользуют друг друга.
210.12 226.04 "Игорь Лабутин" Дальше вы говорите тот же самый .NET publish, но вы передаете ему не только publish профайл и имя этого профайла, по дефолту это называется default container, но вы еще передаете ему 2 пропертии.
226.04 230.40 "Игорь Лабутин" Одна называется container registry, это собственно адрес того registry, куда нужно пушить.
230.40 247.60 "Игорь Лабутин" И container image name это стандартная штука типа там тег вашего имиджа, 2 обычно, 2 токена через слэш, если это github registry, то обычно это ваш логин слэш имя вашего имиджа.
247.60 258.84 "Игорь Лабутин" Обычно все это в command line писать довольно сложно и нутно, поэтому вот тот самый publish профайл, который мы до сих пор, я много раз упоминал и в прошлых наших выпусках, когда рассказывал про эту фичу, тоже упоминал.
258.84 273.44 "Игорь Лабутин" Обычно там указывается типа default container, это дефолтный publish профайл, но можно в вашем проекте внутри папочки properties создать папочку publish profiles и внутри создать файлик, например, назвать его github.pubxml.
273.44 291.56 "Игорь Лабутин" И внутри как раз задать и container registry, и container image name, и после этого вы в аргументе publish профайл указываете уже github, то есть имя вашего созданного файла без расширения, и все свойства, которые нужны, будут браться ровно оттуда, а не из дефолтного профайла.
291.56 302.68 "Игорь Лабутин" Собственно, таким образом вы теперь можете использовать docker.com.online только для того, чтобы сказать docker.login, а дальше за вас все можно сделать через .net publish.
302.68 309.04 "Игорь Лабутин" Второй момент, который улучшили, это сборка контейнеров для другой архитектуры.
309.04 319.72 "Игорь Лабутин" Бывает такое, особенно сейчас в современном мире, что вы работаете, например, на макбуке, где новые макбуки на m1, m2, это arm64, а собирать нужен образ для md64.
319.72 331.04 "Игорь Лабутин" Либо наоборот, вам нужно собрать образ, который будет нативно работать, например, на макбуках, а вы сейчас на x64 платформе, или нужно собрать для линукса, или еще в таком духе.
331.04 346.12 "Игорь Лабутин" Для этого вы просто теперь в .net publish аккуратненько указываете - - os и указываете, например, linux, потом с ключиком -a указываете архитектуру и правильный, то есть .net publish автоматически берет правильный базовый имидж.
346.12 374.60 "Игорь Лабутин" То есть вы в свойствах csproj можете указать конкретный базовый имидж, а можете указать просто общий, там, хочу, не знаю, alpine, и он из имеющихся, про которые он знает, ну те, которые Microsoft, естественно, поставляются, он подберет тот, который подходит под вашу желаемую таргетную архитектуру, если не подойдет ни один, в смысле, если ваша архитектура, в которой вы хотите собрать имидж, не поддерживается базовым образом, будет ошибка сборки, там он не будет ничего по умолчанию находить.
374.60 382.00 "Игорь Лабутин" При этом остается возможность прямо указать явно, что хочу прямо конкретно этот базовый имидж, вот, брать оттуда и использовать только его.
382.00 384.88 "Игорь Лабутин" Естественно, если архитектура не совпадет, тоже будет ошибка.
384.88 400.72 "Игорь Лабутин" Для того, чтобы это все работало, надо было раньше обязательно указывать ссылку на нужный пакет, то есть нужно было указать ссылочку на Microsoft.NET Build Containers Nuget Package, нужные версии.
400.72 418.04 "Игорь Лабутин" В данном случае сейчас вот то, что я рассказываю, поддержаны версии 0.3.2, но теперь, если у вас это веб-апи, то можно просто указать в CSS Project Enable STK Container Support True, и Nuget Package, референс можно не указывать, оно само подтянется.
418.04 428.04 "Игорь Лабутин" Причем, если потом у нас будет несколько версий, вам зачем-то нужна конкретная, есть пропертия под названием SDK Container Support Package Version, куда можно указать конкретную версию этого самого Nuget Package.
428.04 432.20 "Игорь Лабутин" Visual Studio тоже сама все это добавит за вас, если вы через Publish Dialog это будете делать.
432.20 436.16 "Игорь Лабутин" Но это пока поддержано только для веб-апичных проектов.
436.16 439.12 "Игорь Лабутин" Дальше у команды есть планы.
439.12 452.08 "Игорь Лабутин" Планы допиливать, ну, там есть много всяких мелочей, потому что, вообще говоря, у Docker Command Line есть много всяких разных ключиков, которые можно технически так или иначе поддержать через .NET Publish или через Publish Profile.
452.08 453.88 "Игорь Лабутин" Видимо, над этим будет вестись работа.
453.88 480.40 "Игорь Лабутин" В общем-то, их цель перевести, ну, то есть чтобы вам Docker Command Line был не нужен ни для чего, кроме логина, они собираются поработать над всякими сообщениями об ошибках получше, и добавить вот эту самую поддержку через CSS Project Enable SDK Container Support, чтобы не нужно было Nuget Package явно инклюдить в все релевантные типы проектов, те, которые имеют смысл все это заворачивать в Docker.
480.40 503.24 "Игорь Лабутин" Более того, надо сказать, что это все, мы это все рассказываем в контексте, да, у нас там .NET 8, все вот это вот, но на самом деле эта вся фича, она для .NET 7 делается, то есть вот в следующем апдейте SDK, сейчас у нас актуальный SDK это 7.0.200, в следующем апдейте SDK 7.0.300 уже это все должно вроде как быть, по крайней мере запланировано для него, поэтому тем, кто сейчас сидит на семерке, это тоже будет доступно.
503.24 533.76 "Игорь Лабутин" И параллельно с этим есть отдельная статейка про, сейчас мы вот обсудили кроссплатформенные билды, да, когда вы на X64 собираете для Arma, наоборот, там свинды на Linux и так далее, а есть еще так называемые мультиплатформ-контейнеры, это когда вы пишете универсальный докерфайл и из единого докерфайла можете собрать несколько сразу имиджей, на самом деле даже разместить их одним тегом и он автоматически будет подтягивать правильный заглас, согласно архитектуре при сборке, при потом использовании точнее.
533.76 564.56 "Игорь Лабутин" Вот Microsoft подхачила свой докерфайл стандартный, который они генерят, для того чтобы он лучше подходил как раз под вот этот вот сценарий мультиплатформенной сборки, там были проблемы с тем, что те самые ключики, которыми вы специфицируете архитектуру, там X64, AMD64 и прочие, они немножко не совпадали между докером и дотнетовским тулингом, и поэтому там были некоторые проблемы, чтобы их легко вместе использовать.
564.56 631.32 "Игорь Лабутин" Вот они все это профиксили, заменили все, что нужно, заиспользовали правильные переменные внутри докерфайла, типа как build_platform и target_arch, архитектура, и таким образом позволяют прям, используя один докерфайл, собирать все, что надо, поддержали таким образом ключик - - платформу докера, у докербилда, и также это все должно нормально теперь работать через докербилд.текст, так что если вы вдруг собирали, или собираете, или собираетесь собирать мультиплатформенные контейнеры, имиджи на последнем дотнете, вот, соответственно, забирайте обновление свеженького SDK, скорее всего это войдет в следующую превьюшку, третью, восьмерке, потом это будет заблокировано вроде как в семерку, но как бы, потому что это просто изменение вокруг докерфайлов, я так понимаю, и немножко тулинга, поэтому я так понимаю, что докерную часть-то они бы портят по какой-то причине в семерку довольно активно, и будет у вас хорошая жизнь с дотнетскими контейнерами почти без использования докеркоммантлайна.
631.32 638.28 "Анатолий Кулаков" Ну, потому что семерке еще жить целый год как минимум, а так на нее очень много проектов переехало, поэтому мне кажется, правильное решение.
638.28 642.44 "Игорь Лабутин" Ну и так, наверное, больше народу этого все попробует.
642.44 650.76 "Анатолий Кулаков" Да, конечно, еще потестит до восьмерки, тем более которая там LTS будет, поэтому потестить ее надо основательно.
650.76 654.20 "Анатолий Кулаков" Ну да, так что ждем, ждем нового превью.
654.20 671.88 "Анатолий Кулаков" Отлично, да, меня радует прогресс с докером, непонятно, правда, куда они движутся с вот этими контейнерами, которые генерируются напрямую с прошфайла, потому что если они побегут все параметры, которые есть в докере, перегонять в прошфайл, это какая-то бесконечная гонка будет.
671.88 676.32 "Анатолий Кулаков" Мне кажется, что зря они туда вписались, нам нужно было что-то сделать более умное такое.
676.32 681.68 "Анатолий Кулаков" Но может в конце концов они перенесут только всякие основные, а на всех остальных забьют, остановятся.
681.68 688.12 "Игорь Лабутин" Ну я не думаю, что они смогут через CS Project нормально сделать какие-нибудь эти многостадийные билды, когда мы кэшируем кучу промежуточных слоев.
688.12 697.76 "Игорь Лабутин" Типа сделал рестор в одном слое, потом скопировал в другом слое, ну то есть, в смысле, не слое, стадии докера.
697.76 713.72 "Анатолий Кулаков" Мне кажется, так как разработчику это основная цель получить на выходе готовый докер-контейнер, то ему там по барабану какие у него слои будут, и скорее всего даже генерится сейчас докер-файл, который и использует все эти слои, потому что никакого смысла там ресторить его и компилить, и паблишить в одном слое, нет.
713.72 715.48 "Анатолий Кулаков" Может быть, может быть.
715.48 719.20 "Анатолий Кулаков" По факту, скорее всего, там и так слои будут использовать.
719.20 722.56 "Игорь Лабутин" Ну вот посмотрим, что там генерится, что там происходит.
722.56 727.56 "Игорь Лабутин" Я, честно говоря, не смотрел, как работает NuGet, то есть генерит ли он докер.
727.56 736.28 "Игорь Лабутин" Я так понимаю, что он, кстати, работает же, они же, я так понимаю, все сделали нативно, в смысле-то он даже не требует докер-ком онлайна у себя, ну кроме.
736.28 737.28 "Анатолий Кулаков" Не должен.
737.28 749.36 "Анатолий Кулаков" Обычные тулзы, которые такие делают, тут надо признать, что Microsoft не первый, естественно, а тулзы, которые так делают, которые генерят сами докер-файлы из своего собственного формата, они не требуют даже установленного докера на вашем компьютере.
749.36 759.72 "Анатолий Кулаков" Так как весь этот докер-файл – это всего лишь на все zip-архив, который, естественно, сформирован определенным образом, если ты знаешь, как его формировать, то тебе никакой установленный докер на компьютере не нужен.
759.72 760.72 "Анатолий Кулаков" Ну вот.
760.72 768.76 "Анатолий Кулаков" Может быть, для начала Microsoft как бы пошел, я думаю, может, тулзами внешними обзавелся, чтобы просто API проработать, а потом уже сделать нормальную имплементацию.
768.76 769.76 "Анатолий Кулаков" Или может, сразу сделал.
769.76 777.00 "Игорь Лабутин" Не, подожди, они, по-моему, сразу сделали, мы же как раз обсуждали, что поддержка тара архивов, которые в .NET завезли, как раз была нужна, чтобы докер-инные имиджи делать.
777.00 779.80 "Анатолий Кулаков" Да, точно, для файловой системы используется.
779.80 782.16 "Анатолий Кулаков" Да, да, наверное, сразу сделали.
782.16 800.12 "Игорь Лабутин" Так что, наверное, они сделали сразу, вопрос как бы, действительно, работают ли они это все по слоям или просто вместе ресторят, сразу билдят, сразу, ну, короче, не знаю, ладно, не копался, работает и ладно, для простых проектов быстрых, которые нужно в докер завернуть, точно хорошо подойдет, чтобы не писать отдельный докерфайл.
800.12 810.76 "Игорь Лабутин" Ну, там, для сложных, я думаю, что если у тебя сложный проект, где важно делать какой-нибудь мультистейдж билд, ну, как бы ты это в любом случае будешь знать и будешь делать сам тогда руками.
810.76 825.32 "Анатолий Кулаков" Я думаю, да, здесь выпендриваться не стоит, как бы если у вас не какой-то простой проект, то легче сделать докерфайл, контролировать там все пакеты, все настройки, все какие-нибудь сеттинги операционной системы, уже контролировать через нормальные нативные тулзы.
825.32 827.92 "Игорь Лабутин" Да, ну, что, давай дальше.
827.92 848.76 "Анатолий Кулаков" Давай, как я уже сказал, мы сегодня еще не раз коснемся темы секьюрити, и вот первая штука, о которой хотелось бы рассказать, это дело в том, что специальные эксперты обнаружили, что наконец-то наш NuGet, любимый репозиторий, наш сторидж пакетов, наше все, начали нападать злобные хакеры.
848.76 851.80 "Анатолий Кулаков" И про это хотелось бы с вами немножко поговорить.
851.80 863.52 "Анатолий Кулаков" Недавно вышла статья, которая называется, что хакеры все-таки стали замечать дотнетовских разработчиков и стали делать вредоносный код в NuGet пакетах.
863.52 885.32 "Анатолий Кулаков" Если начать издалека, то в принципе пакеты, репозитории и все эти центральные пакеты, которые есть практически в каждом нормальном языке, они всегда подвергались атаке, потому что это самая уязвимая и самая простая дыра, с помощью которой можно настучаться и получить сразу огромные ботнеты из наивных разработчиков.
885.32 897.28 "Анатолий Кулаков" Потому что по сути все мы с вами живем в каких-то розовых лепестках и ставим пакеты из интернета, запускаем код, даже после того, как поставили эти пакеты из интернета и радуемся нашим программам.
897.28 903.92 "Анатолий Кулаков" И я думаю, надеюсь, что постоянные наши слушатели уже знают, что это абсолютно небезопасно.
903.92 910.76 "Анатолий Кулаков" Код в этих программах может быть подменен, может быть заражен, может быть спровоцирован, может быть еще много чего сделано с ним.
910.76 919.76 "Анатолий Кулаков" И вот эти репозитории, из которых мы затаскиваем код, это одно и то же, что мы скачиваем файлики с интернета, то есть экзешники с интернета и просто их запускаем.
919.76 927.36 "Анатолий Кулаков" То, что в одном из этих репозиторий написано NuGet, вообще не разу не значит, что там что-то не так, как в обычном интернете.
927.36 931.64 "Анатолий Кулаков" Как-то просто обычные вирусы все-таки пока не пролазят.
931.64 934.16 "Анатолий Кулаков" Непонятно почему.
934.16 937.84 "Анатолий Кулаков" Наверное потому, что антивирусы каким-то образом еще умудряются их находить.
937.84 949.72 "Анатолий Кулаков" Но вот какие-нибудь закладки в виде не вирусов, а стандартной работы систем, систем установки, например, очень часто пролазят.
949.72 965.68 "Анатолий Кулаков" Например, в NPM и в Python пакетч репозиториях, там и во всех остальных, где скриптовые в основном языки, там очень много пакетов, которые каждый день, каждую секунду пытаются вас обмануть, заразить и что-то страшное с вами сделать.
965.68 968.76 "Анатолий Кулаков" Может быть потому, что там больше просто народу.
968.76 977.16 "Анатолий Кулаков" Может быть на скриптовых языках довольно веселее, можно делать какие-нибудь веселые вещи, поэтому там люди веселятся чаще.
977.16 982.28 "Анатолий Кулаков" Но как факт, до Nuget репозитория долго эта волна веселья не доходила.
982.28 995.96 "Анатолий Кулаков" И вот совсем недавно команда security исследователей из компании GFrog обнаружила интересную атаку, то есть такой всплеск на Nuget репозиторий, заметный интерес к нашему Nuget.
995.96 1010.72 "Анатолий Кулаков" Вообще команда мониторит все репозитории, если кто не знает, то GFrog выпускает Artifactory, это такой инструмент как раз для кэширования пакетов, абсолютно для практически всех систем, которые там есть для всех языков, для всех платформ и так далее.
1010.72 1028.24 "Анатолий Кулаков" И в частности для дотнета тоже, то есть он поддерживает протокол Nuget, и поэтому отдельная команда сидит и мониторит пакеты для того, чтобы выявлять на ранних стадиях всякие зловредов и прочие нехорошие дяденек и тетенек.
1028.24 1034.32 "Анатолий Кулаков" И вот она обнаружила всплеск в Nuget ни с того ни с сего вдруг очень большой.
1034.32 1048.40 "Анатолий Кулаков" Пошел накат зараженных пакетов, и более того эти пакеты в общем проскачивали люди или боты 150 тысяч раз за один месяц.
1048.40 1057.08 "Анатолий Кулаков" Пакеты были довольно банальны, никаких там хитростей особых нету, они просто-напросто скачивались и запускали некий payload, некий зловредный код.
1057.08 1061.28 "Анатолий Кулаков" И делали они это все с помощью стандартных PowerShell скриптов.
1061.28 1073.72 "Анатолий Кулаков" Все эти пакеты на данный момент из Nuget уже были удалены но как факт того, что они там были, что их там могли успеть скачать и тот факт, что дырка до сих пор осталась она есть.
1073.72 1079.16 "Анатолий Кулаков" Давайте немножко подробнее разберем, чтобы мы все понимали что все собственно происходит.
1079.16 1083.08 "Анатолий Кулаков" Итак, как я уже сказал дырка еще на месте есть.
1083.08 1106.06 "Анатолий Кулаков" Если мы вспомним старые добрые времена, когда у нас была старая Visual Studio, по-моему еще до DotA.net Core, у Visual Studio, даже не только у Visual Studio, у любого Package Manager, у Nuget Package Manager можно было в папочку Tools положить PowerShell скриптик и потом эту папочку паковать в виде пакета.
1106.06 1113.18 "Анатолий Кулаков" Этот пакет распространить через Nuget и как только вы устанавливали с помощью Package Manager такой пакет, автоматически запускался ваш скриптик.
1113.18 1125.38 "Анатолий Кулаков" В зависимости от имени он мог запускаться во время инсталляции, во время деинсталляции, во время регистрации, в общем там куча была автоматизации и шагов для удобства.
1125.38 1133.54 "Анатолий Кулаков" Теперь все эти скриптики из папочки Tools, которые там назывались раньше install.ps1, install.ps1 они игнорируются в современном Nuget.
1133.54 1138.94 "Анатолий Кулаков" Но несмотря на это, есть один файлик, который не игнорируется.
1138.94 1140.74 "Анатолий Кулаков" Это почему-то файлик init.ps1.
1140.74 1145.26 "Анатолий Кулаков" Он по-прежнему продолжает запускаться в современной студии.
1145.26 1157.50 "Анатолий Кулаков" Несмотря на то, что о нем удалили все упоминания в документации, что он помечен там где есть антиприкейт и все такое, студия по-прежнему продолжает его упорно запускать.
1157.50 1164.18 "Анатолий Кулаков" Не знаю, ради какого-нибудь очень крутого пакета это было сделано, такой гвоздями забито или почему это осталось.
1164.18 1174.90 "Анатолий Кулаков" Я просто помню, что во времена .NET Core была огромная волна отказа от этих custom ps-скриптов, переход полностью на декларированный подход, чтобы как раз избежать вот таких проблем.
1174.90 1178.26 "Анатолий Кулаков" Но как мы видим, до конца почему-то не отказались.
1178.26 1192.18 "Анатолий Кулаков" И вот этот initps1, он не просто запускается, когда вы устанавливаете этот Nuget пакет, а каждый раз перезапускается, как только вы открываете package-manager.console.
1192.18 1195.90 "Анатолий Кулаков" То есть как только вы к консоли обращаетесь, он опять перезапускается.
1195.90 1210.58 "Анатолий Кулаков" И внутри этого скрипта на PowerShell, естественно, можно написать любые команды, любой код и делать абсолютно все что угодно с вашим компьютером в пределах тех прав, с которыми вы работаете в вашей Visual Studio, в вашей IDE.
1210.58 1222.22 "Анатолий Кулаков" И я знаю немало людей, у которых почему-то проект так настроен или они не смогли разобраться с баннингом портов или еще что-то, кто очень часто запускает Visual Studio под системным администратором.
1222.22 1227.82 "Анатолий Кулаков" То есть процент людей, которые работают под админом в этот момент, он огромный просто.
1227.82 1242.98 "Анатолий Кулаков" Соответственно, вирус получает полностью права админа на вашей машине и может заражать не только вас, но и соответственно вашу вся систему, ваш репозиторий и прочее-прочее, дальше на что только хватит фантазии у автора.
1242.98 1258.50 "Анатолий Кулаков" Интересно, что этот Build PS 1, он может даже не упоминаться в Nuspec файле, в котором в методате, в котором описываются все файлы обычно и все прочие метаданные Nuget пакет, он может просто лежать рядышком и Visual Studio найдет и комфортно для вас запустит.
1258.50 1268.46 "Анатолий Кулаков" Итак, как я уже сказал, эта волна заражения, она включала в себя огромное число пакетов, это было не один пакет, там их большое количество.
1268.46 1279.42 "Анатолий Кулаков" Они были объединены только по принципу заражения и по принципу похожести скриптов и пейлодов, и по серверам, с которых сталкивался этот пейлод.
1279.42 1284.70 "Анатолий Кулаков" То есть можно было определить, что это одна волна, что какой-то один участник за этим за всем стоит.
1284.70 1287.46 "Анатолий Кулаков" По именам это сделать невозможно, имена были абсолютно разные.
1287.46 1295.94 "Анатолий Кулаков" Например, был пакет, который назывался Coinbase Core, который играл на желание людей, подключив за Coinbase биржи.
1295.94 1305.42 "Анатолий Кулаков" Был пакет Discord Reach, Discord Reach Presenter API, по-моему, который про Discord и его API был.
1305.42 1314.34 "Анатолий Кулаков" В общем, все эти пакеты были названы такими популярными именами или опечатками популярных имен, где якобы пользователь мог ошибиться и скачать.
1314.34 1324.86 "Анатолий Кулаков" И, как я уже сказал, там скачиваний было больше 150 тысяч, но нужно признать, что это вполне могли быть не все успешно зараженные разработчики.
1324.86 1333.70 "Анатолий Кулаков" Вполне может быть, что злоумышленник сам мог накрутить эти скачивания с помощью ботов, для того, чтобы пакеты выглядели более прилично.
1333.70 1338.06 "Анатолий Кулаков" Если пакет там скачали 100 тысяч раз, то, конечно же, мухи ошибаться не могут.
1338.06 1339.78 "Анатолий Кулаков" Значит, наверное, для нас он безопасный.
1339.78 1341.42 "Анатолий Кулаков" В общем, логика такая тоже работала.
1341.42 1350.62 "Анатолий Кулаков" Итак, прежде всего, как же заидентифицировать, что этот пакет злоуномерен.
1350.62 1359.34 "Анатолий Кулаков" Прежде всего, если в этом пакете есть какие-нибудь PS1 скрипты, а особенно, если и не один PS1 скрипт, то это должно вас насторожить.
1359.34 1365.46 "Анатолий Кулаков" Вообще, современные пакеты и приличные авторы, которые пишут пакеты, они давно уже избавились от PS1 скриптов.
1365.46 1370.50 "Анатолий Кулаков" Я вот так на вскидку не вспомню ни одного пакета, кто бы до сих пор продолжал его использовать.
1370.50 1374.30 "Анатолий Кулаков" Все сознательные авторы давно отказались от этого подхода.
1374.30 1378.82 "Анатолий Кулаков" И если вы такой скрипт увидите в вашем Nuget пакете, то будьте осторожны.
1378.82 1382.38 "Анатолий Кулаков" Скорее всего, с большой вероятностью, это какой-то зловред.
1382.38 1389.94 "Анатолий Кулаков" Если заглянуть внутрь этого PS1 файла, то в данном случае это скачивался какой-нибудь .exe, бинарник и запускался.
1389.94 1391.98 "Анатолий Кулаков" Скачиваться они тоже могут разным образом.
1391.98 1398.70 "Анатолий Кулаков" Там регистрироваться в реестре, качаться напрямую, скедурить какой-нибудь task, системный скедулер.
1398.70 1406.42 "Анатолий Кулаков" В общем, много разных способов скачивания .exe есть, не думайте, что там просто будет какой-нибудь download файл.
1406.42 1413.50 "Анатолий Кулаков" Какими трюками им пользовался злоумышленник, для того чтобы попытаться обмануть Nuget?
1413.50 1417.74 "Анатолий Кулаков" Прежде всего, как я уже упомянул, он пытался мимикрировать под уже известные названия.
1417.74 1420.34 "Анатолий Кулаков" Такие там, как Coinbase, например.
1420.34 1422.34 "Анатолий Кулаков" Такие, например, как Discord.
1422.34 1436.46 "Анатолий Кулаков" И добавлял к ним какой-нибудь .core, .engine, еще что-нибудь в общем, какие-нибудь другие буковки, которые могли как бы человеком отбрасываться, но на самом деле имели значение.
1436.46 1442.06 "Анатолий Кулаков" Следующая интересная тема это в том, что никак не проверяются владельцы пакетов.
1442.06 1451.06 "Анатолий Кулаков" То есть, очень легко можно было выставить владельцам пакетов, то есть, даже тут не проверяются, а подделываются легко.
1451.06 1459.44 "Анатолий Кулаков" Владельцам пакетов можно было легко поставить такую надпись как Nuget Developers или Official Developers Team или еще что-нибудь.
1459.44 1468.86 "Анатолий Кулаков" Или, например, он поставил известного разработчика из Microsoft, который как раз работает в Nuget и которому принадлежит очень много Nuget пакетов.
1468.86 1478.86 "Анатолий Кулаков" В общем, он подделал, этот злоумышленник подделал имя этого разработчика, просто-напросто написав его имя с измененной одной буквой, которую визуально заметить практически невозможно.
1478.86 1486.22 "Анатолий Кулаков" Еще одна интересная проблема в том, что Nuget вообще никак не проверяет авторов.
1486.22 1497.46 "Анатолий Кулаков" Если вы создадите Nuspec файл и внутри этого Nuspec файла укажете автора Microsoft, то вы со всеми правами можете этот пакет залить в Nuget Repository.
1497.46 1502.58 "Анатолий Кулаков" И Nuget Repository с радостью всем расскажет, что этот пакет выпустил Microsoft.
1502.58 1513.02 "Анатолий Кулаков" Вот такая тоже интересная штука есть, которая помогает обмануть абсолютно всех, даже тех, кто якобы смотрит на авторов и якобы видит правильные имена пакетов.
1513.02 1526.66 "Анатолий Кулаков" Также нужно заметить, что некоторые пакеты не включали на себя напрямую каких-нибудь злонамеренных скриптов или каких-нибудь злонамеренного кода, но они зависели от пакетов, от злонамеренных пакетов.
1526.66 1542.94 "Анатолий Кулаков" Таким образом вы ставя нормальный, хороший и красивый пакет, проверив может быть его даже в том, что он никаких скриптов не содержит, вы все равно заражали свою систему, потому что при первом ресторе он начинал подтягивать зловредный пакет и тот уже делал всю грязную работу за него.
1542.94 1544.46 "Анатолий Кулаков" Вот такие есть проблемы.
1544.46 1549.06 "Анатолий Кулаков" Итак, как же можно себя обезопасить?
1549.06 1550.54 "Анатолий Кулаков" Что можно сделать?
1550.54 1566.94 "Анатолий Кулаков" Прежде всего внимательно смотреть на опечатки, то есть такие преднамеренные опечатки, где кто-то добавляет ненужные слова или меняет буквы, но для людей, скорее всего, это не какой-то там хороший способ, потому что невозможно просмотреть все буквы, особенно те, которые пишутся одинаково.
1566.94 1593.22 "Анатолий Кулаков" Также советуется, прежде чем использовать какой-то новый пакет в вашем проекте, обязательно скачать его вручную, не через какие-то средства скачивания, запуска, менеджмент пакетжес, консоли и прочие вещи, просто вручную нажмите кнопку Download на Nuget.org, она есть такая, скачайте его, откройте как zip-архив и посмотрите внутрь, поищите там скрипты PowerShell.
1593.22 1598.46 "Анатолий Кулаков" InitPS1, InstallPS1, UninstallPS1, да вообще любые PS1 в принципе.
1598.46 1603.28 "Анатолий Кулаков" Если они там есть, то насторожитесь и желательно заглянуть внутрь.
1603.28 1611.02 "Анатолий Кулаков" Внутри, скорее всего, они будут что-нибудь скачивать или устанавливать или еще что-то, ну я бы на вашем месте, если они там есть, просто-напросто ушел бы от таких пакетов.
1611.02 1616.34 "Анатолий Кулаков" Если авторы настолько плохо относятся к своим ездищам, скорее всего, от них можно ожидать все чего угодно, любой халатности.
1616.34 1632.02 "Анатолий Кулаков" И, наверное, самый, не знаю, надежный и распространенный фактор, который можно представить, это количество скачиваний, но так как они легко накручиваются, еще можно проверить количество версий и за какое время все эти версии существуют.
1632.02 1644.58 "Анатолий Кулаков" Так как Nuget все-таки при помощи вот таких вот благотворительных Research Security Team старается репозиторий держать чистыми и красивыми, то есть он удаляет пакеты, такие пакеты зловредные, они обычно долго не живут.
1644.58 1659.06 "Анатолий Кулаков" И можно посмотреть на историю версий, если он там существует несколько лет, активно разрабатывается, все время выходит, все время скачивается, то, наверное, есть шанс, что это какой-то хороший, понятный пакет, который ему более-менее можно доверять.
1659.06 1667.46 "Анатолий Кулаков" Но, опять же, надо быть осторожным, потому что никто не мешает автору несколько версий выкладывать в хороший, красивый пакет, а потом после этого его заразить.
1667.46 1680.74 "Анатолий Кулаков" Это, конечно, сделает всю его работу, вся работа его на смарку за несколько лет пойдет куда-нибудь под хвост, но, наверное, такие прецеденты тоже вполне могут быть, главное, что он от этого получит.
1680.74 1695.42 "Анатолий Кулаков" В общем, универсальных способов нет, к сожалению, этот орг не предоставляет нам каких-то хороших верифицированных аккаунтов, верифицированных пакетов, все еще, сколько об этом мы не говорили, в общем, таких хороших способов нет.
1695.42 1706.66 "Анатолий Кулаков" Пользуйтесь только проверенными пакетами, переходите из доверенных GitHub-репозиториев и старайтесь проверять вторичные половые признаки в виде скачиваний, время жизни и отсутствия PS-скриптов.
1706.66 1728.14 "Игорь Лабутин" Да, я бы еще добавил, что я иногда смотрю на, ну, если я вдруг действительно встречаю какой-то совсем незнакомый мне пакет, еще полезно посмотреть на вкладочку used by, то есть если это не какой-то пакет, ну, то есть если это достаточно популярный пакет, который много кем используется, вдруг вам он раньше не нужен был и вы почему-то про это не знаете, то used by подскажет.
1728.14 1736.02 "Игорь Лабутин" Может быть, действительно он используется кем-то очень известным и хорошим, и это тоже дополнительный плюсик в, так сказать, карму пакета.
1736.02 1753.62 "Игорь Лабутин" Дальше, можно, я могу посоветовать, например, не скачивать, я иногда просто иду на NuGet, там есть кнопочка в правой колонке, называется open in NuGet Package Explorer, она откроет веб-версию Package Explorer, вы можете прямо в браузере посмотреть, что внутри, то есть скачивать локально в этом смысле не обязательно.
1753.62 1783.34 "Игорь Лабутин" И третий момент, у нас нет действительно механизма какой-то верификации паблишеров, но на самом деле есть штука, мы про нее рассказывали, называется резервирование префиксов, то есть для некоторых пакетов, вот я сейчас ради интереса открыл Newtonsoft.json, у него под названием пакета стоит финя галочка и написано prefix reserved, то есть это значит, что никто кроме, собственно, самого Newton, Json с Newton King, видимо, да, или там организации, да, от которой он это все выкладывает, не сможет выложить пакет с таким же префиксом Newtonsoft.
1783.34 1798.58 "Игорь Лабутин" Но тут, да, смотрите на там опечатки в названии и так далее, но кажется, что если вот этот prefix reserved галочка стоит, то это тоже дополнительный какой-то бонус пакету, хотя, возможно, хакеры зарезервируют себе тоже какой-то префикс.
1798.58 1799.58 "Игорь Лабутин" Например, Microsoft.
1799.58 1808.30 "Игорь Лабутин" Ну, Microsoft, я думаю, не дадут зарезервировать, понятное дело, но какой-то нормально выглядящий префикс вполне могут.
1808.30 1827.86 "Анатолий Кулаков" К сожалению, да, с этой галочкой тоже не все в порядке, потому что ее запустили уже очень долгое время назад, и я пытался себе забиндить несколько имен, и это вообще не работало, то есть если кто не знает, эти галочки биндятся с помощью писем, никакого трекера или фидбэка нет, письмо уходит куда-то в пустоту, и никто на него не отвечает.
1827.86 1839.98 "Анатолий Кулаков" Поэтому, может быть, Microsoft и товарищ King как-то себе пробил эту галочку, но мне кажется, что для обычных смертных, для обычных пакетов, которые не Microsoft, это пока еще сделать все еще очень сложно.
1839.98 1852.70 "Игорь Лабутин" Ну, слушай, это на самом деле в каком-то смысле добавляет ей веса, потому что если вы смогли добиться, чтобы она у вас появилась, наверное, может быть, вам можно доверять, потому что к вам прислушивается со мной GeTorG.
1852.70 1854.06 "Игорь Лабутин" Ну, может быть.
1854.06 1858.54 "Анатолий Кулаков" Просто если вы используете пакет же только от Microsoft, то тут, наверное, вам бояться нечего.
1858.54 1865.34 "Анатолий Кулаков" Вся как раз таки проблема возникает, когда вы пытаетесь пакеты других авторов поставить, и там вот эта галочка как раз не работает.
1865.34 1867.70 "Анатолий Кулаков" Там, где она могла быть наиболее полезной.
1867.70 1876.70 "Игорь Лабутин" Ну, вот я, кстати, смотрю всякие, те самые automapper, mocku, тот самый Castle Core, они, Serialoc, они все с галочками.
1876.70 1881.22 "Анатолий Кулаков" Может, там нужны, знаешь, какие-нибудь первые миллионы скачиваний для того, чтобы на тебя внимание брать.
1881.22 1890.06 "Игорь Лабутин" У которой Swashbuckler, LifeSpan at Core, обновленный 3 месяца назад, у которого 381 миллион скачиваний, без галочек.
1890.06 1891.06 "Игорь Лабутин" Недостоин.
1891.06 1892.06 "Игорь Лабутин" Недостоин.
1892.06 1895.46 "Игорь Лабутин" Swashbuckler, Poly, с галочкой.
1895.46 1899.94 "Игорь Лабутин" Мне даже интересно, XUnit, ну, XUnit, ладно, XUnit, очевидно, будет с галочкой.
1899.94 1905.98 "Анатолий Кулаков" Ну, вот поэтому вся эта система, она какая-то все еще непрозрачная, несмотря на прошедшее количество времен.
1905.98 1913.02 "Анатолий Кулаков" Вот надо бы ее довести до ума, и как бы не только там автора, но еще и префиксы, и пакеты ее автора, там все надо перепроверить.
1913.02 1914.02 "Игорь Лабутин" О, прикольно.
1914.02 1921.66 "Игорь Лабутин" NUnit с галочкой, Flying Assertions с галочкой, StackExchangeRedis с галочкой.
1921.66 1929.62 "Игорь Лабутин" Он, понятно, паблишится Mark gravel, да, Ник Крайвером, там вот этими всеми ребятами, кто там в StackExchange раньше или сейчас работает.
1929.62 1934.10 "Игорь Лабутин" Но при этом Dapper, который теми же ребятами абсолютно паблишится, он без галочки.
1934.10 1938.82 "Игорь Лабутин" Короче, прям, да, забавно.
1938.82 1943.26 "Игорь Лабутин" AfterEffects без галочки, апдейты 24 дня назад, ну в общем, да.
1943.26 1944.26 "Игорь Лабутин" Не все очевидно.
1944.26 1958.18 "Игорь Лабутин" Не все очевидно, поэтому, ну не, на самом деле видно, что галочка потихонечку как-то распространяется, и поэтому, наверное, все-таки рано или поздно они будут добавляться, поэтому если она и есть, наверное, все-таки неплохой признак.
1958.18 1965.78 "Игорь Лабутин" Ну, ладно, хорошо, следите за вашими Nuget пакетами, пользуйтесь безопасно и все такое прочее.
1965.78 1967.82 "Игорь Лабутин" Пойдем дальше, вернемся к нашим контейнерам.
1967.82 1983.06 "Игорь Лабутин" Про Docker у Microsoft есть еще одна статья, потому что они сделали апдейт для своих базовых имиджей, потому что начиная с восьмерки, начиная с .NET 8, все Linux-бейс контейнеры будут включать в себя нерутового юзера.
1983.06 1999.10 "Игорь Лабутин" То есть, да, на текущий момент в обычном стандартном .NET базовом имидже есть там десятки разных, ну десятки, наверное, нет, хотя там, по-моему, если ETC пассворд посмотреть, там, по-моему, 20 или 15 или 20 юзеров набирается, ну всяких служебных системных.
1999.10 2006.58 "Игорь Лабутин" Но в целом вы обычно пользуетесь root и собираете так называемый контейнер, который требует root, да, где дефолтное на самом деле поведение докера.
2006.58 2026.02 "Игорь Лабутин" Но это не очень здорово, особенно смотря, смотри в тему security чуть выше, да, лучше приложениям давать как можно меньше прав, чтобы даже если в ваш контейнер заберутся, то такое приложение, которое работает не под root, а внутри контейнера, работает под своим собственным пользователем, не сможет ничего сделать.
2026.02 2052.38 "Игорь Лабутин" Во-первых, оно не сможет ничего сделать внутри контейнера, вдруг вы там, не знаю, в temp файликах что-то храните, ну или там какой-нибудь в конфигурации контейнера в базовом имидже у вас что-то было зашито, соответственно, оно не сможет там что-то подменить и, например, вместо там какой-нибудь конфигурации, которую вы туда зашили и посылать данные в ваши сервера, оно начнет посылать данные в другие сервера.
2052.38 2071.46 "Игорь Лабутин" С другой стороны, тут даже скорее не то, чтобы если там в ваш контейнер кто-то вломится, а если вы, например, при сборке, смотри выше, да, там, например, с Nuget, если вы что-нибудь себе такое заберете, DLL, которое там внутри вашего приложения будет творить какую-нибудь дичь.
2071.46 2077.74 "Игорь Лабутин" Ну вот если она будет творить эту дичь не из-под рута, пусть это даже в докере заизолировано, то это лучше.
2077.74 2092.18 "Игорь Лабутин" Поэтому теперь у нас есть в каждом Linux имидже, начиная с восьмерки, ну, видимо, это будет сейчас вот уже потихонечку раскатываться, так что не надо ждать восьмерки официального релиза, в каждом имидже будет пользователь под названием app, ну типа приложение.
2092.18 2103.82 "Игорь Лабутин" Единственное, что может делать этот пользователь, он может, у него есть права на запуск вашего приложения и на чтение любых директорий, которые есть в, собственно, том образе, который вы собрали.
2103.82 2108.86 "Игорь Лабутин" На запись у него прав нет, единственное, куда у него есть права, это только в свою home directory.
2108.86 2118.70 "Игорь Лабутин" То есть у него есть home directory, это /home/app, uid этого пользователя 64198, если интересно, магическая константа.
2118.70 2126.06 "Игорь Лабутин" И пользователи существуют во всех базовых образах, поэтому вы можете там их свободно менять, и для вас ничего не поменяется.
2126.06 2130.78 "Игорь Лабутин" UID везде одинаковые, имя пользователя везде одинаковые, home directory везде одинаковые.
2130.78 2136.46 "Игорь Лабутин" Как использовать эту штуку, как вообще собирать теперь докер имидж, чтобы он был нерутовым?
2136.46 2154.90 "Игорь Лабутин" Можно это сделать через command line, вы можете указать при, когда вы говорите, не собирать, а, то есть можно во-первых запустить, да, вы можете сказать docker run -u app, указав имя пользователя, дальше там указать ваш имидж, вот это все, и запустить, значит, любой command line от имени этого пользователя.
2154.90 2159.06 "Игорь Лабутин" Но это, понятно, вы будете делать только у себя, в момент разработки, тестирования, еще чего-то.
2159.06 2160.06 "Игорь Лабутин" Обычно делается не так.
2160.06 2174.78 "Игорь Лабутин" Обычно вы в докер файле указываете директиву, либо user пробел app, либо вы можете указать user пробел 6498, либо Microsoft собирается сделать специальное переменное окружение, называется app_id.
2174.78 2195.26 "Игорь Лабутин" Это id-шник, который будет резолвиться, собственно, всегда в 6498 для их образов, и это способ, который они собираются сделать дефолтным, везде у себя использовать, вот в том самом докер файле, который я рассказывал там пару новостей назад, про то, что они новый универсальный докер файл пишут, вот там будет, видимо, такая штука.
2195.26 2207.34 "Игорь Лабутин" А если вы это все ничего не указываете, то есть если вы не указываете директиву user пробел что-нибудь, то контейнер соберется по дефолту с рутом, в смысле, что ваше приложение будет запускаться из-под рута.
2207.34 2208.34 "Игорь Лабутин" Дальше возникают проблемы.
2208.34 2226.22 "Игорь Лабутин" Допустим, вы указали этот самый user app, или там через id, или как угодно, но проблема в том, что если вы собираете в такой контейнер aspen это приложение, которое на 7-ке или ниже, ну то есть раньше, то по дефолту такое приложение будет слушать на http порту 80.
2226.22 2230.74 "Игорь Лабутин" Хотя tps у нас по мультяне 4.4.3, а http будет 80.
2230.74 2236.66 "Игорь Лабутин" А проблема в том, что нерутовый пользователь не имеет права использовать порты, бандится на порты меньше чем 1024.
2236.66 2242.78 "Игорь Лабутин" И поэтому ваше приложение просто не дадут слушать на этом порту, и оно будет абсолютно бесполезно внутри контейнера.
2242.78 2247.74 "Игорь Лабутин" Поэтому, ровно поэтому, Microsoft сделала новое переменное окружение.
2247.74 2256.70 "Игорь Лабутин" Мы когда-то обсуждали статью Andrew Locke про то, сколько существует способов задать набор url-ов и портов, на которым слушает ваше aspen.cor приложение.
2256.70 2266.98 "Игорь Лабутин" Там есть и переменные окружения, и всякие, как они называются, launch settings json, ну опять же, через переменные окружения это делается, и аргумент командной строки --urls.
2266.98 2271.78 "Игорь Лабутин" Так вот теперь у нас есть переменное окружение, которое называется aspen.cor_http_ports.
2271.78 2272.78 "Игорь Лабутин" Еще одна.
2272.78 2273.78 "Игорь Лабутин" Еще одна.
2273.78 2281.48 "Игорь Лабутин" Которую можно через запятую указать набор портов, http портов, на котором будет слушаться.
2281.48 2290.18 "Игорь Лабутин" Есть такая же переменная, которая только в названии имеет https, они, соответственно, для https портов, там через запятую можно указать несколько портов.
2290.18 2294.14 "Игорь Лабутин" Старые переменные все еще работают, причем имеют приоритет.
2294.14 2300.78 "Игорь Лабутин" То есть если вы указали и aspen.cor_http_ports, и, например, aspen.cor_urls, то будет использовано именно urls.
2300.78 2307.02 "Игорь Лабутин" http_ports проигнорится, не пробовал, напишут ли про это орл, но скорее всего нет.
2307.02 2313.34 "Игорь Лабутин" Поэтому если вам нужна прям точная настройка, какие urls вы используете, ну как бы используйте по старинке aspen.cor_urls.
2313.34 2317.74 "Игорь Лабутин" Ну а если просто указать порты, можно использовать http_ports.
2317.74 2324.58 "Игорь Лабутин" И таким образом как раз все контейнеры имиджа будут переопределены для того, чтобы использовать 8080.
2324.58 2329.58 "Игорь Лабутин" Там будет задаваться переменное окружение, и через 8080 будет использоваться.
2329.58 2336.82 "Анатолий Кулаков" Так, а если я ничего не задам по дефолту, если у меня будет ни одной переменной настроен, не стоит ли переподниматься?
2336.82 2346.82 "Игорь Лабутин" То старое aspen.cor приложение при запуске тебе напишет "сорян, ну как там операционка тебе проскинет исключение со словами типа socket operation, что-то там запрещено".
2346.82 2347.82 "Игорь Лабутин" Ну и?
2347.82 2348.82 "Игорь Лабутин" Новые?
2348.82 2350.82 "Игорь Лабутин" А новые будут слушать на 8080.
2350.82 2351.82 "Игорь Лабутин" Хорошо.
2351.82 2352.82 "Игорь Лабутин" Как я понимаю.
2352.82 2356.86 "Игорь Лабутин" Восьмерки начинаю, ну с какого-то превью, видимо.
2356.86 2368.22 "Игорь Лабутин" Все будет слушать на 8080, и поэтому если у вас есть какие-то там девелоперские скрипты, которые ожидают, что ваше дефолтное приложение поднимается на 80-м порту, ну исправляйте на 8080 теперь.
2368.22 2375.34 "Игорь Лабутин" С исполнением не из-под рута есть пока одна некоторая проблема — это диагностика.
2375.34 2383.34 "Игорь Лабутин" То есть все вот эти вот, понятное дело, волшебные наши тузлы, там dotnet trace, вот это все, они под линуксом требуют иногда рутовых прав.
2383.34 2385.78 "Игорь Лабутин" По крайней мере в докер-сценариях.
2385.78 2398.54 "Игорь Лабутин" По утверждениям Microsoft, у них сейчас не все работает, и они как раз сейчас выясняют и решают, каким образом лучше всего сделать всю эту диагностику, так чтобы при этом у нас rootless контейнеры были все еще секьюрными, но при этом чтобы все работало как надо.
2398.54 2400.62 "Игорь Лабутин" Там всякие remote отладки, вот это все.
2400.62 2412.02 "Игорь Лабутин" Они так написали, что как бы next steps — это investigate challenges, не указывая как бы конкретно, и какие челленджи у них есть, кроме общих слов, что ну там что-то в диагностических сценариях пока не работает или не оптимально.
2412.02 2413.46 "Игорь Лабутин" Ну вот посмотрим, будем следить.
2413.46 2425.78 "Игорь Лабутин" Я думаю, что к конкретному превью, когда уже будет статья про прям вот вышел там .NET 8 превью 3, там наверное будет что-то более подробно про это написано, если они к тому времени что-то успеют сделать.
2425.78 2427.30 "Игорь Лабутин" Ну или будем ждать следующих превью.
2427.30 2445.26 "Анатолий Кулаков" Так, а вот расскажи мне, вот если у тебя пользователь всего-навсего один есть во всей операционной системе, и он, допустим, root, и пользователь один во всей операционной системе, и он не root, все-таки какая разница под кем запускается вот твое приложение?
2445.26 2456.46 "Анатолий Кулаков" Вот даже если взломали его изнутри контейнера, и он имеет root-овые права, то что он сможет сделать такого страшного, что не сможет сделать обычный там гостевой пользователь, ап-пользователь?
2456.46 2459.58 "Анатолий Кулаков" Он же точно так же может сходить в сеть.
2459.58 2461.26 "Анатолий Кулаков" А что еще?
2461.26 2464.30 "Анатолий Кулаков" Посмотреть пароли у закрытого, изолированного докер-контейнера?
2464.30 2465.30 "Анатолий Кулаков" Посмотреть его логи?
2465.30 2466.30 "Анатолий Кулаков" Ну кому это надо?
2466.30 2467.30 "Анатолий Кулаков" Посмотреть.
2467.30 2469.06 "Анатолий Кулаков" Там все равно в этом контейнере никого нет, кроме этого
2469.06 2472.58 "Игорь Лабутин" приложения. А если он вылезет из-за предела контейнера, из-за какой-нибудь дырки?
2472.58 2473.58 "Анатолий Кулаков" Из-за какой-нибудь дырки в докере?
2473.58 2474.58 "Анатолий Кулаков" Да.
2474.58 2480.30 "Анатолий Кулаков" Ну просто если мы говорим про дырку в докере, то скорее всего тебе тут админ или не админ не поможет эта дырка в докере.
2480.30 2489.02 "Игорь Лабутин" Ну так неважно, ты вылезешь наружу, ну ты вылезешь, почему не поможет, поможет, ты вылезешь наружу, но ты будешь в хостовой системе тоже не root.
2489.02 2490.54 "Анатолий Кулаков" Ну это же разные вещи.
2490.54 2499.22 "Анатолий Кулаков" В хостовой системе под кем запускается докер-контейнер, и кем внутри твой процесс запускается внутри гостевой операционной системы.
2499.22 2503.58 "Анатолий Кулаков" Мы сейчас обсуждали гостевую операционную систему, и там мы избавились от root.
2503.58 2504.58 "Анатолий Кулаков" Не хостовый.
2504.58 2505.58 "Игорь Лабутин" Хороший вопрос.
2505.58 2513.10 "Игорь Лабутин" Я сейчас, наверное, тебе не смогу прямо точно сформулировать со всеми аргументами, чем это плохо, чем хорошо.
2513.10 2520.34 "Игорь Лабутин" Мне точно попадались статейки, где все это хорошо разжевывалось, но я их, конечно же, прочитал и забыл, как это и положено делать со статьями.
2520.34 2535.22 "Игорь Лабутин" Поэтому давай мы просто прямо вот в бэклог себе запишем, ну не знаю, если к следующему выпуску у нас не будет, куча новостей от Microsoft про новые превью, просто отдельно статейку, продолжим серию про докер и рассмотрим, в чем же у нас вообще, зачем все эти root из контейнера.
2535.22 2545.98 "Игорь Лабутин" И тут же действительно есть еще момент, что ты можешь запускать root/нерут внутри контейнера, и сам контейнер можно запускать как root из-под рута и не из-под рута, снаружи.
2545.98 2557.50 "Игорь Лабутин" То есть докер/демон обычно работает из-под рута, а вот там всякие штуки типа подмана, они как раз умеют запускаться не из-под рута, а контейнера.
2557.50 2563.86 "Игорь Лабутин" Так что пользователь, который, у процесса, который запускает контейнер снаружи, тоже не root.
2563.86 2579.58 "Игорь Лабутин" Короче, давай мы просто внимательно в этом покопаемся и постараемся нормальным, понятным языком донести всю эту разницу, таблички два на два, да, вот это все, чтобы сейчас по памяти не наврать нигде.
2579.58 2589.18 "Анатолий Кулаков" Согласен, давай, ну вот как внешнюю систему запускать, то есть сам докер/демон запускать не из-под рута, поэтому непонятно, это как бы любому параноику очевидно.
2589.18 2597.10 "Анатолий Кулаков" А вот зачем внутри там загоняться, и в принципе многие люди загоняются, поэтому естественно есть какая-то хорошая, может быть даже не одна причина для этого.
2597.10 2607.06 "Анатолий Кулаков" И если вдруг наши слушатели знают, то у вас есть прекрасный шанс нам помочь и накидать или хороших статей, или написать свое мнение в комментариях к этому выпуску.
2607.06 2612.50 "Игорь Лабутин" Да, кидайте ссылки, мы в общем, не факт, что наши статьи самые лучшие, возможно, у вас есть отличное руководство.
2612.50 2622.06 "Игорь Лабутин" Скорее всего, оно правильно есть в каком-нибудь официальном документах докера, я не помню, я читал какую-то статью, то ли у Редхата, то ли у кого-то, я не помню.
2622.06 2629.30 "Анатолий Кулаков" Опять же, читать документацию – это самое последнее средство, когда уже все остальные исчерпаны, у нас еще остались наши слушатели, поэтому давай оставим шанс.
2629.30 2632.86 "Игорь Лабутин" Давай, хорошо, а пока пойдем дальше.
2632.86 2637.98 "Анатолий Кулаков" Не удаляясь далеко от темы безопасности, предлагаю еще поговорить про пароли.
2637.98 2652.38 "Анатолий Кулаков" Если кто помнит, мы недавно обсуждали как раз криптографию в Дотнете, получился довольно хороший выпуск, я имею в виду статейка и вообще хороший контент, который там есть, не знаю, насколько вам было приятно воспринимать это на слух, но статья отличная.
2652.38 2663.66 "Анатолий Кулаков" Поэтому если вы вдруг пропустили наш выпуск про криптографию, обязательно послушайте, там просто базовые основы, которые нужны абсолютно всем и каждому разработчику в этом мире.
2663.66 2675.46 "Анатолий Кулаков" И вот следующий шаг, сегодня хочется продолжить разговор и поговорить именно про пароли, каким же образом вообще хранить пароли.
2675.46 2689.38 "Анатолий Кулаков" Если вдруг ваша система действительно нужна для того, чтобы хранить какие-то пароли, это может быть абсолютно все что угодно, вход пользователя по паролю, может быть пароль от какого-то секрета, от какого-то сториджа, от еще чего-то.
2689.38 2693.22 "Анатолий Кулаков" В общем пароли в нашей жизни могут встречаться довольно чаще, чем вам кажется.
2693.22 2700.18 "Анатолий Кулаков" И по эти пароли нужно хранить очень специальным образом.
2700.18 2703.74 "Анатолий Кулаков" Прежде всего никогда нельзя пароли хранить в открытом виде.
2703.74 2707.82 "Анатолий Кулаков" Пароли всегда нужно хешировать, и не только хешировать, но и солить.
2707.82 2715.46 "Анатолий Кулаков" И вот о том, как грамотно и правильно хешировать, солить и хранить пароли, мы с вами сейчас и поговорим.
2715.46 2739.50 "Анатолий Кулаков" Многие из вас, наверное, помнят, когда был еще бум только интернета, может быть, самого, и когда все сайтики делались максимум на PHP или на Perl или еще на какой-то такой мракобесии, очень часто были новости такие, что один сервис взломали, утекли все пользовательские пароли, все данные пользователя были вытащены.
2739.50 2755.82 "Анатолий Кулаков" В общем, новости о взломах баз и об утекании каких-то пользовательских данных, об утечках пользовательских данных и об утечках персональных данных и так далее, они были намного чаще на самом деле, чем происходит сейчас.
2755.82 2767.58 "Анатолий Кулаков" Несмотря на то, что в наш нелегкий год тоже повзломывали и поутекало очень много, это даже в сравнении идет с тем, что было раньше, когда любые сайтики делались на коленке с помощью PHP скриптиков.
2767.58 2773.02 "Анатолий Кулаков" И самая главная проблема, которая затем была, почему все это стало возможным?
2773.02 2792.66 "Анатолий Кулаков" Потому что все эти скриптоделы просто-напросто записывали все пароли открытым текстом в базу данных, а тогда еще был большой бум всяких форумов, все распробовали, что такое форумы, как общаться, как писать друг к другу, сообщенница и форумы были практически на все тематики, на всех ресурсах и про все.
2792.66 2798.46 "Анатолий Кулаков" Каждый вожащийся с себя сайт обязан был иметь плашку форумс, где собирались все его посетители.
2798.46 2801.46 "Анатолий Кулаков" И вот форумы как раз таки этим очень сильно грешили.
2801.46 2806.66 "Анатолий Кулаков" Естественно у них была регистрация и там были пароли в открытом виде.
2806.66 2807.66 "Анатолий Кулаков" Почему это плохо?
2807.66 2825.74 "Анатолий Кулаков" Потому что все это рано или поздно ломалось, потому что писали такие же криворуки и когда злоумышленники взломывали систему и существует очень много способов вытащить базу данных из вломанной системы, когда они вытаскивали эту базу данных, у них на руках были просто-напросто пароли.
2825.74 2830.50 "Анатолий Кулаков" То есть они могли под любым пользователем зайти и сделать дальше все, что они хотели.
2830.50 2838.86 "Анатолий Кулаков" Прочитать его личные сообщения, продать его личные данные, посмотреть его историю покупок или может быть даже больше, найти какие-нибудь кредитные карточки и так далее.
2838.86 2842.78 "Анатолий Кулаков" То есть основная проблема была в том, что все пароли хранились в открытом виде.
2842.78 2847.46 "Анатолий Кулаков" Это, по-моему, даже сейчас где-то проскакивает.
2847.46 2855.66 "Анатолий Кулаков" В общем, если вы знаете такие сервисы или таких людей или таких разработчиков, сразу бегите оттуда, потому что это абсолютно некомпетентные люди.
2855.66 2864.94 "Анатолий Кулаков" И вот чтобы нам с вами не быть такими некомпетентными, давайте все-таки углубимся в тему, разберемся и как положено узнаем, как нужно поступать правильно.
2864.94 2876.62 "Анатолий Кулаков" Как мы обсуждали в вышеупомянутом моем прошлом выпуске, что как раз хеширование паролей обладает очень многими интересными функциями.
2876.62 2883.18 "Анатолий Кулаков" Во-первых, применение хешированной пароли применяют некие алгоритмы.
2883.18 2894.54 "Анатолий Кулаков" Эти алгоритмы производят хеш и прелесть этого хеша состоит из двух основных для нас, даже трех, наверное, важных свойств.
2894.54 2897.78 "Анатолий Кулаков" Это в том, что этот хеш невозможно расшифровать.
2897.78 2905.42 "Анатолий Кулаков" Это значит, что мы можем сравнивать некоторые данные, мы можем получать ответ равный или неравный, не имея самих этих данных.
2905.42 2909.82 "Анатолий Кулаков" Это на самом деле просто гениальное свойство, которым обладают хеши.
2909.82 2913.18 "Анатолий Кулаков" То есть нам не нужно знать пароль для того, чтобы сказать, верный он или неверный.
2913.18 2916.06 "Анатолий Кулаков" Дальше, следующее свойство.
2916.06 2918.50 "Анатолий Кулаков" Они детерминированные.
2918.50 2926.14 "Анатолий Кулаков" Хеш-функции всегда, получая один и тот же вход, дают на всем вам всегда один и тот же выход, один и тот же хеш.
2926.14 2935.94 "Анатолий Кулаков" И это значит, что мы, соответственно, можем взять от пользователя пароль и сравнить его с хешом, который хранится в нашей базе.
2935.94 2940.54 "Анатолий Кулаков" Поэтому в нашей базе мы можем не хранить открытый текст, мы можем хранить просто хеш.
2940.54 2946.30 "Анатолий Кулаков" Мы с помощью этой конструкции сможем отвечать на вопрос пользователя, правильно ввел пароль или неправильно.
2946.30 2952.94 "Анатолий Кулаков" И при этом, если злоумышленник утащит нашу базу данных, то у него в руках окажется всего лишь на все хеш.
2952.94 2959.46 "Анатолий Кулаков" Это немножко хуже, чем если бы он просто получил открытые пароли.
2959.46 2963.50 "Анатолий Кулаков" Поэтому хранить в базах данных мы должны обязательно только хэши.
2963.50 2971.82 "Анатолий Кулаков" Дальше, если мы возвращаемся к алгоритму, которым хэши должны записывать.
2971.82 2991.50 "Анатолий Кулаков" Мы в прошлый раз тоже обсуждали много алгоритмов, но вкратце нужно вспомнить, что хэш-алгоритм, то есть хэши невозможно, как я уже сказал, повернуть обратно, невозможно расшифровать их, невозможно из них получить пароль, но против них применяется атака бортфорса.
2991.50 2997.38 "Анатолий Кулаков" То есть если злоумышленник все-таки украл хэш из базы данных, то он все-таки может кое-что с ним сделать.
2997.38 3004.30 "Анатолий Кулаков" Он может перебрать все возможные пароли, с оптимизацией по словарю, по частотности, не суть важно.
3004.30 3013.94 "Анатолий Кулаков" Он может просто-напросто все пароли по порядку перебирать, хэшировать вот этот перебор и сравнивать уже непосредственно сам хэш с тем, что он украл.
3013.94 3021.06 "Анатолий Кулаков" Таким образом он может подобрать исходную строку, которая дает тот же самый хэш.
3021.06 3034.26 "Анатолий Кулаков" Даже если он подберет не тот же самый пароль, который есть у пользователя, а только тот же самый хэш, то есть ту строку, которая дает тот же самый хэш, это все-равно хватит, потому что наша программа обычно проверяет непосредственно только сами хэши.
3034.26 3038.74 "Анатолий Кулаков" В общем, с помощью таких бортфорсов и взламываются хэши.
3038.74 3056.86 "Анатолий Кулаков" Для того, чтобы алгоритм считался хорошим, вот хэш-функция, как определяется хорошая хэш-функция или плохая, если мы говорим о криптостойких хэш-функциях, это зависит полностью от того, насколько она быстрая.
3056.86 3065.02 "Анатолий Кулаков" То есть чем секьюрнее функция, чем безопаснее функция, чем лучше функция, тем больше она требует стоимости.
3065.02 3070.34 "Анатолий Кулаков" Стоимости по CPU, по памяти, по времени хэширования.
3070.34 3076.62 "Анатолий Кулаков" В общем, если функция хэшируется несколько часов и выдает вам какой-то результат, это самая крутая функция.
3076.62 3084.34 "Анатолий Кулаков" Но на практике люди стараются соблюсти все-таки баланс между удобством и потреблением ресурсов.
3084.34 3090.34 "Анатолий Кулаков" Но в общем случае, чем дольше работает функция, чем больше она потребляет ресурсов, тем лучше.
3090.34 3093.58 "Анатолий Кулаков" И нужно это как раз именно для защиты от бортфорсов.
3093.58 3098.26 "Анатолий Кулаков" Потому что как только мы захэшируем один пароль, мы этого времени даже не заметим.
3098.26 3110.82 "Анатолий Кулаков" Как только злоумышленнику нужно перешифровать миллиарды паролей для того, чтобы получить тот же самый хэш, вот здесь как раз и сыграет тот факт, что для работы функции нужно очень много ресурсов.
3110.82 3115.30 "Анатолий Кулаков" И злоумышленник уже не сможет с очень большой эффективностью подбирать пароли.
3115.30 3124.22 "Анатолий Кулаков" Тут нужно понимать, что безопасность вся строится не на том, что это невозможно взломать, на то, что невозможно подобрать, на то, что невозможно проникнуть в систему.
3124.22 3127.86 "Анатолий Кулаков" Она лишь строится на том, что все ломается.
3127.86 3133.14 "Анатолий Кулаков" Единственная задача – это то, что оно все ломается с различной затратой ресурсов.
3133.14 3139.50 "Анатолий Кулаков" И чем больше ресурсов злоумышленник потратит на взлом, тем лучше ваша защита.
3139.50 3149.38 "Анатолий Кулаков" Если этот взлом будет стоить ему намного дороже, чем он получит бенефитов в результате взлома, то считается, что вы отлично защищены.
3149.38 3152.10 "Анатолий Кулаков" Злоумышленнику нет никакого смысла вас ломать.
3152.10 3155.46 "Анатолий Кулаков" Вот на этом и играют криптографические хэш-функции.
3155.46 3163.02 "Анатолий Кулаков" Здесь нужно отметить, что именно этим они отличаются от обычных хэш-функций, задача которых в основном это все-таки обеспечить целостность.
3163.02 3171.90 "Анатолий Кулаков" А вот криптографические хэш-функции не только обеспечивают целостность, они еще и пытаются сделать такой сложный алгоритм, который потребляет максимальное количество ресурсов.
3171.90 3192.38 "Анатолий Кулаков" Здесь также нужно отметить, что те ресурсы, которые нужны были для хэш-функции, допустим, 10 лет назад, с ростом наших высоких технологий, облаков, оптимизации по процессорам и по видеокартам, вот сейчас эти ресурсы есть практически на каждом телефоне.
3192.38 3202.20 "Анатолий Кулаков" И именно поэтому крутые, хорошие, интересные алгоритмы, такие как MD5 или SHA, какой-нибудь мелкий, начальный, они раньше были нормальными.
3202.20 3211.42 "Анатолий Кулаков" Но, несмотря на то, что в них находили какие-нибудь баги во самой имплементации, в коллизиях, они еще становились слишком быстрыми.
3211.42 3222.62 "Анатолий Кулаков" И как только алгоритм становится слишком быстрым для брутфорса, автоматически он перестает быть хорошим алгоритмом хэширования, несмотря на то, что еще буквально несколько лет назад был таковым.
3222.62 3230.34 "Анатолий Кулаков" Поэтому никогда не используйте такие старые алгоритмы, а пытайтесь все время посмотреть, что сейчас актуально, какой размер ключа, какие алгоритмы и так далее.
3230.34 3238.34 "Анатолий Кулаков" Сейчас актуальны такие алгоритмы, как PBKDF2, bcrypt, Argon2 и многие-многие другие.
3238.34 3245.58 "Анатолий Кулаков" Как я уже и сказал в начале, хэшинг - это не панацея.
3245.58 3253.34 "Анатолий Кулаков" Вообще, хэша недостаточно для того, чтобы четко быть уверенным, что ваш пароль находится в безопасности.
3253.34 3269.10 "Анатолий Кулаков" Как я уже говорил, что злоумышленник может скачать ваши хэши, допустим, если он украдет вашу базу данных, он все еще может скомпрометировать ваш пароль, если он подберет это через BruteForce.
3269.10 3280.22 "Анатолий Кулаков" И дело в том, что для всех популярных алгоритмов, особенно быстрых, таких как MD5 и маленькие хэша, для них уже давно перерассчитаны все эти хэши.
3280.22 3283.82 "Анатолий Кулаков" То есть вам уже даже не надо их BruteForce, вам их не надо будет взламывать.
3283.82 3289.58 "Анатолий Кулаков" Злоумышленники уже давно все посчитали и сложили специальную табличку, которая называется "радужная таблица" - Rainbow Table.
3289.58 3301.86 "Анатолий Кулаков" По этой табличке вы просто обычным лукапом можете забросить любой хэш и посмотреть, из какого изначального слова, из какой изначальной строки получился этот хэш.
3301.86 3308.18 "Анатолий Кулаков" То есть взламываются, грубо говоря, практически мгновенно такие простые алгоритмы.
3308.18 3327.06 "Анатолий Кулаков" Существует очень много таких табличек с прикалькулированными хэшами, также существует очень много хаков, которые позволяют в старых алгоритмах находить некие лазейки, которые как раз таки позволяют избежать вот этого BruteForce очень долгого по ресурсам и находить хэш коллизии намного быстрее.
3327.06 3332.34 "Анатолий Кулаков" Хэш коллизии - это практически текст, который даст в результате тот же самый хэш.
3332.34 3335.50 "Анатолий Кулаков" Он не обязательно должен быть таким же точным паролем, который был у вас оригинально.
3335.50 3337.86 "Анатолий Кулаков" Главное, что он тот же самый хэш даст.
3337.86 3339.62 "Анатолий Кулаков" И это уже поможет вам взломать систему.
3339.62 3347.02 "Анатолий Кулаков" Также еще есть большой минус у хэш-алгоритмов.
3347.02 3350.38 "Анатолий Кулаков" И минус заключается в том, что они детерминированные.
3350.38 3354.34 "Анатолий Кулаков" То есть они в результате на один вход дают один и тот же выход.
3354.34 3359.30 "Анатолий Кулаков" Каким образом этот плюс вначале стал его минусом?
3359.30 3371.02 "Анатолий Кулаков" Дело в том, что если несколько пользователей имеют одинаковые пароли, то взломав пароль одного пользователя, автоматически ломаются все остальные пользователи, использующие точно такой пароль.
3371.02 3375.30 "Анатолий Кулаков" А это не такая редкая ситуация в больших базовых данных, как вам кажется.
3375.30 3376.78 "Анатолий Кулаков" Люди - примитивные амебы.
3376.78 3379.14 "Анатолий Кулаков" Они очень часто заводят одинаковые пароли.
3379.14 3381.02 "Анатолий Кулаков" И вот здесь очень опасно.
3381.02 3387.74 "Анатолий Кулаков" Особенно если человек почему-то увидел свой пароль и знает, как он был зашифрован, он легко может найти такие же пароли по базе данных.
3387.74 3389.98 "Анатолий Кулаков" Может быть даже не в этом сервисе, а даже в других.
3389.98 3392.10 "Анатолий Кулаков" В общем, это тоже большой-большой минус.
3392.10 3396.30 "Анатолий Кулаков" И именно поэтому была придумана такая гениальная изобретение, как SOL.
3396.30 3402.26 "Анатолий Кулаков" Все пароли должны солиться, прежде чем они будут сохранены куда-нибудь в базу данных.
3402.26 3412.06 "Анатолий Кулаков" На самом деле SOL - это не что иное, как просто какой-то абсолютно рандомный набор информации, который вставляется, добавляется к вашему паролю.
3412.06 3417.30 "Анатолий Кулаков" SOL у каждого пасворда должна быть в идеале уникальная.
3417.30 3429.62 "Анатолий Кулаков" И как только вы добавляете еще какой-то уникальный кусочек к паролю, то такой хэш, получившийся в результате смеси пароля плюс SOL, его становится гораздо сложнее бредфорсить.
3429.62 3436.98 "Анатолий Кулаков" Ну, сложнее, я бы сказал, даже на уровне невозможного, если вы не знаете все-таки, каким образом это подставляется и какая там SOL.
3436.98 3442.10 "Анатолий Кулаков" Потому что здесь уже автоматически не работает вся эта радужная таблица, которую вы составили до этого.
3442.10 3448.78 "Анатолий Кулаков" Потому что до этого они составлялись или с небольшой SOL, или вообще без SOL.
3448.78 3454.02 "Анатолий Кулаков" И вообще невозможно предсказать, каким образом эта SOL была тогда подмешана.
3454.02 3460.66 "Анатолий Кулаков" Итак, лучшие практики по солению, лучших соленеводов.
3460.66 3464.14 "Анатолий Кулаков" Мы должны обязательно использовать SOL с каждым паролем.
3464.14 3466.94 "Анатолий Кулаков" Эта SOL должна быть разная для каждого пароля.
3466.94 3475.46 "Анатолий Кулаков" Очень часто, особенно когда только появилась мода солить пароли, очень часто использовалась одна SOL вообще на все пароли в системе.
3475.46 3481.62 "Анатолий Кулаков" Ее там задавал администратор в то время, когда устанавливал форум, допустим, и она добавлялась ко всем паролям.
3481.62 3486.86 "Анатолий Кулаков" Это, конечно, спасало в большинстве случаев, но все-таки опасная штука.
3486.86 3490.78 "Анатолий Кулаков" Потому что один раз установят SOL, вы автоматически ломаете все пароли.
3490.78 3495.62 "Анатолий Кулаков" Поэтому желательно разная SOL на разные пароли.
3495.62 3496.62 "Анатолий Кулаков" Еще одна важная вещь.
3496.62 3500.86 "Анатолий Кулаков" Хранить пароли лучше всего отдельно от SOL, хотя бы в разных табличках.
3500.86 3509.30 "Анатолий Кулаков" Потому что если вдруг у вас введут таблицу с паролями, не зная таблицу с SOL, опять же проблема подбора сильно усложняется.
3509.30 3518.46 "Анатолий Кулаков" Если у вас введут табличку с паролями и там же рядом в соседней колодке будет лежать SOL, то подбор будет намного легче производиться.
3518.46 3524.94 "Анатолий Кулаков" Особенно если ломанут парочку паролей, все остальные скорее всего можно будет каким-то образом подобрать по известному алгоритму.
3524.94 3527.94 "Анатолий Кулаков" Следующее правило.
3527.94 3530.26 "Анатолий Кулаков" SOL должна быть очень сложно угадываема.
3530.26 3533.78 "Анатолий Кулаков" То есть это не должно быть какое-то понятное, простое словарное слово.
3533.78 3537.62 "Анатолий Кулаков" Лучше всего для этих целей использовать криптографический рандом.
3537.62 3543.26 "Анатолий Кулаков" Потому что правильный криптографический рандом у нас валяется в системе security криптографии.
3543.26 3545.22 "Анатолий Кулаков" Рандом NUMBER GENERATOR.
3545.22 3548.06 "Анатолий Кулаков" Вот тот рандом надо использовать.
3548.06 3551.82 "Анатолий Кулаков" И также SOL должна быть достаточно длинной.
3551.82 3555.38 "Анатолий Кулаков" Нормальная длина SOL это примерно как размер аутпота.
3555.38 3561.30 "Анатолий Кулаков" Если вы понимаете, что хэш вам выдается 512, то примерно вот такую SOL берите и тоже не прогадаете.
3561.30 3565.94 "Анатолий Кулаков" Еще одна интересная техника, с помощью которой можно защищать пароли.
3565.94 3571.86 "Анатолий Кулаков" Это продолжение техники хэширования.
3571.86 3574.94 "Анатолий Кулаков" Потому что на самом деле после хэширования вы получаете некий хэш.
3574.94 3579.42 "Анатолий Кулаков" Но вы можете этот хэш захэшировать еще раз и получите уже совсем другой хэш.
3579.42 3583.42 "Анатолий Кулаков" И если вы захэшируете другой хэш, то получите совсем другой хэш.
3583.42 3592.86 "Анатолий Кулаков" И таким образом еще одним интересным параметром, который часто используют в админках и так далее, это количество итераций, которые нужно произвести для того, чтобы захэшировать ваш пароль.
3592.86 3601.74 "Анатолий Кулаков" На заре цивилизации такие итерации могло быть 5, 10, 20.
3601.74 3612.98 "Анатолий Кулаков" Сейчас в нормальных алгоритмах это сотни тысяч итераций, которые производятся хэшом над самим себя, для того, чтобы получить вот такой какой-нибудь криптостокий.
3612.98 3627.26 "Анатолий Кулаков" Например, тот же самый PBKDF 2, он использует несколько тысяч итераций над вашим паролем, для того, чтобы получить криптостокий какой-то пароль.
3627.26 3630.66 "Анатолий Кулаков" А как же проверять пароли?
3630.66 3638.06 "Анатолий Кулаков" Вот допустим в базах у вас хранится мега зашифрованный, посоленный, проитерированный, в общем страшный-страшный хэш.
3638.06 3639.06 "Анатолий Кулаков" Что же с ним делать?
3639.06 3640.70 "Анатолий Кулаков" На самом деле ничего сложного в этом нет.
3640.70 3658.66 "Анатолий Кулаков" Несмотря на то, что вы не можете его расшифровать, вы можете взять входящий пароль от пользователя, который он ввел в формочки, применить к нему весь тот алгоритм, всю ту солянку, которую вы использовали для того, чтобы захэшировать пароль, получить хэш и сравнить этот хэш с тем, что хранится у вас в базе данных.
3658.66 3665.06 "Анатолий Кулаков" Если не совпадают, значит пользователь легитимный, если нет, значит нет, значит что-то не так.
3665.06 3675.66 "Анатолий Кулаков" И на самом деле, если вдуматься, то для того, чтобы вот этот миксер из пароля заработал, там есть куча разных аргументов.
3675.66 3680.86 "Анатолий Кулаков" Во-первых, вам нужно выбрать хороший алгоритм хэширования, например, самый SHA-512.
3680.86 3687.06 "Анатолий Кулаков" Во-вторых, вам нужно придумать размер ключа, вектор инициализации, который будет использоваться.
3687.06 3691.98 "Анатолий Кулаков" Во-вторых, вам нужно знать количество итераций для того, чтобы, например, подобрать пароль.
3691.98 3696.06 "Анатолий Кулаков" И вот эти факторы, их в принципе можно посмотреть в исходниках.
3696.06 3702.46 "Анатолий Кулаков" Если у вас ПО с открытым исходным кодом, то это в принципе открытая информация и ее всегда можно найти.
3702.46 3707.78 "Анатолий Кулаков" Если у вас ПО с закрытым кодом, то вот эта часть, она практически нереальна для подбора.
3707.78 3714.18 "Анатолий Кулаков" То есть, ее, грубо говоря, как-то подобрать, взломать, распознать практически невозможно.
3714.18 3725.30 "Анатолий Кулаков" И две составляющих, которых никогда никто не знает, которые в принципе секьюрны всегда, это непосредственно сам пароль, который участвует в создании хэша, и соль.
3725.30 3732.54 "Анатолий Кулаков" И вот эти штуки, они в принципе никогда не известны, поэтому их надо хранить в безопасности и, как я уже сказал, желательно отдельно.
3732.54 3739.66 "Анатолий Кулаков" В принципе, примеров хэширования есть миллион, много даже в самих микрософтовских библиотечках.
3739.66 3743.66 "Анатолий Кулаков" Хорошим примером является библиотека Microsoft ISP.NET Core Identity.
3743.66 3755.86 "Анатолий Кулаков" У нее есть специальный класс, который называется PasswordHasher от юзера, который, как нетрудно догадаться, как раз применяется для того, чтобы в стандартных микрософтовских логинах хэшировать пароль.
3755.86 3764.66 "Анатолий Кулаков" В общем, она как раз-таки используется, использует внутри себя pbcdf2, куча там различных тоже настроек и так далее.
3764.66 3769.10 "Анатолий Кулаков" Вы можете посмотреть, классик небольшой, в принципе, довольно понятный и интуитивно используемый.
3769.10 3772.10 "Анатолий Кулаков" В общем, кому интересно, загляньте.
3772.10 3789.02 "Анатолий Кулаков" Мы уже упоминали в прошлый раз, когда обсуждали криптографию, что если вы вдруг захотите копнуться в эту тему на практике, обязательно посмотрите доклад Стэна Драбкина, в котором он рассуждает о высокоуровневых хэш-функциях, даже высокоровней криптографии и низкоуровневой криптографии.
3789.02 3808.06 "Анатолий Кулаков" Вот глядя, например, в этой статье, например, того, как правильно использовать вот этот алгоритм хэширования, какие туда вектора передать, какие туда размеры передать, как соль туда найти, сразу вспоминается доклад Стэна, потому что, глядя на такие сложные манипуляции, очень легко допустить ошибку.
3808.06 3815.62 "Анатолий Кулаков" И довольно непонятно, один из этих десяти аргументов, которые требуют эти функции сложные, а где их взять?
3815.62 3817.82 "Анатолий Кулаков" А какую правильную размерность применять?
3817.82 3819.62 "Анатолий Кулаков" А как правильно соль сгенерить?
3819.62 3822.58 "Анатолий Кулаков" То есть, встает очень много вот таких вот проблем.
3822.58 3824.50 "Анатолий Кулаков" У Стэна есть прекрасное решение.
3824.50 3836.42 "Анатолий Кулаков" У него есть хорошая библиотека, а также хорошие алгоритмы, хорошие подходы, про которые он рассказывает в этом докладе, который позволяет скрыть всю вот эту сложность, которая на самом деле в большинстве случаев вам не должна быть нужна.
3836.42 3843.38 "Анатолий Кулаков" Вы должны уметь посчитать хороший, строгий, красивый хэш, который будет для вас гарантированно стабильный и красивый.
3843.38 3845.98 "Анатолий Кулаков" И вот Стэн рассказывает, как этого добиться.
3845.98 3850.94 "Анатолий Кулаков" Глядя на этот код, конечно, стандартных микрософтовских библиотек хочется только ужаснуться.
3850.94 3859.62 "Анатолий Кулаков" Но плюсом надо сказать, что они есть, они работают шикарно, отлично, и поэтому многие библиотеки и другие фреймворки могут использовать все эти алгоритмы.
3859.62 3860.62 "Анатолий Кулаков" Это хорошо.
3860.62 3865.02 "Анатолий Кулаков" В общем, вот так, друзья, хешируйте пароли правильно, храните их правильно.
3865.02 3873.26 "Анатолий Кулаков" Если можете что-то не хранить, обязательно не храните, потому что, как я уже сказал, взломают всех, а разговор лишь про то, насколько вы нужны.
3873.26 3874.26 "Анатолий Кулаков" Прекрасно.
3874.26 3891.58 "Игорь Лабутин" Мне кажется, мы сегодня очень детально посмотрели в тему security, и кажется, мы пойдем сейчас дальше, уже совсем не про security, а пойдем немножко в другую тему, про баз данных, IDшники, UID, GUID, вот это все.
3891.58 3894.62 "Игорь Лабутин" На самом деле, тема родилась из довольно простой штуки.
3894.62 3906.78 "Игорь Лабутин" С одной стороны, мне тут что-то потребовалось по работе подумать, как генерить GUID, которые были бы последовательные, которые, скажем так, монотонно возрастали бы.
3906.78 3922.82 "Игорь Лабутин" И если вы знакомы с SQL Server, там есть прекрасная штука под названием New Sequential ID, по-моему, так называется функция или как-то процедура SQL, которая вам сгенерирует нечто похожее на GUID, но которое плюс-минус гарантирует монотонное возрастание.
3922.82 3934.54 "Игорь Лабутин" Вот это не GUID ни разу, он не соответствует никаким стандартам того, чего должно называться GUID или UID, но тем не менее штука полезная.
3934.54 3941.58 "Игорь Лабутин" Если у вас нет SQL Server под рукой, либо вы почему-то хотите генерить эту штуку в коде, то возникает некоторая проблема.
3941.58 3967.18 "Игорь Лабутин" Значит, давайте сначала разберемся… Ну и да, я полез в это копаться и как-то так неожиданно для себя довольно глубоко во все закопался, так что подобрался набор статей, которые захотелось немножко собрать вместе и попробовать это все обозреть, чтобы у всех возникло какое-то понимание, представление о прекрасном дивном мире тех самых GUID, которые у нас есть.
3967.18 3970.82 "Игорь Лабутин" Во-первых, давайте разберемся со следующей штукой.
3970.82 3974.34 "Игорь Лабутин" У нас в дотнете есть тип под названием System GUID.
3974.34 3982.38 "Игорь Лабутин" Все соответствующие конструкции, которые он умеет генерить, значения, все по привычке называют GUID.
3982.38 3989.30 "Игорь Лабутин" Но на самом деле правильное название этой штуки — это UUID — Universal Unique Identifier.
3989.30 4005.50 "Игорь Лабутин" И у него есть на самом деле огромное количество версий и своя спецификация — это RFC 4122 или 4212, я сейчас не вспомнил, но, по-моему, 4122, которая вообще говоря специфицирует, что там может быть.
4005.50 4014.06 "Игорь Лабутин" И у этого UUID есть несколько версий, которые со временем, обновляя эту спецификацию, потихонечку добавлялись.
4014.06 4025.58 "Игорь Лабутин" На данный момент в актуальной спецификации есть пять версий — V1, V2, V3, V4, V5, которые отличаются некоторыми деталями того, как это все генерируется.
4025.58 4029.70 "Игорь Лабутин" Вообще UUID — это 128 бит, то есть 16 байт.
4029.70 4042.62 "Игорь Лабутин" И, скажем так, идеология была в том, чтобы туда запихнуть как можно большее количество рандома, но при этом минимизировать коллизии.
4042.62 4058.18 "Игорь Лабутин" Поэтому начиналось это все с V1, V2, там, соответственно, нужно было использовать MAC-адрес и какой-то рандомный кусочек байтов, который запихивался в оставшуюся часть.
4058.18 4067.54 "Игорь Лабутин" Потом есть V3, V5, которые вместо MAC-адреса используют некоторый сид, в спеке это, по-моему, называется namespace.
4067.54 4075.42 "Игорь Лабутин" И есть UUID V4, это когда у вас все свободные биты внутри UUID заполняются просто рандомом.
4075.42 4081.54 "Игорь Лабутин" Почему я говорю все свободные, потому что из 128 бит на самом деле далеко не все можно использовать под свои рандомы.
4081.54 4101.78 "Игорь Лабутин" То есть если вы вдруг генерируете 16-байтовый рандомный массив, складываете его в UUID и говорите, что вот это теперь у нас мой новый UUID, то вы не соответствуете спецификации, потому что там есть 6 бит, которые трогать нельзя, которые как раз указывают на версию этого UUID.
4101.78 4105.70 "Игорь Лабутин" И есть еще так называемый вариант внутри версии.
4105.70 4108.78 "Игорь Лабутин" Мы разберемся что-то такое, когда...
4108.78 4111.14 "Игорь Лабутин" Ну хотя можем сразу сейчас обсудить.
4111.14 4113.98 "Игорь Лабутин" Версия-то, собственно, указывает V1, V2, V3, V4, V5.
4113.98 4121.94 "Игорь Лабутин" А вариант - это такое забавное битовое поле, которое динамическое, оно может занимать 1, 2 или 3 бита.
4121.94 4124.30 "Игорь Лабутин" И нам там интересно два значения.
4124.30 4128.94 "Игорь Лабутин" Бывает вариант 1 - это, так сказать, UUID, который соответствует спецификации.
4128.94 4134.50 "Игорь Лабутин" А бывает вариант 2, который в RFC спецификации написано, что он Reserved for Microsoft Corporation.
4134.50 4139.06 "Игорь Лабутин" То есть вот так вот в RFC мы зарезервировали один вариант из двух.
4139.06 4140.06 "Игорь Лабутин" Удобно.
4140.06 4141.06 "Игорь Лабутин" Конкретно для Microsoft.
4141.06 4143.70 "Игорь Лабутин" И как раз Microsoft этим пользуется.
4143.70 4147.74 "Игорь Лабутин" То есть System GUID - это как раз штука, которая вроде как соответствует варианту 2.
4147.74 4148.74 "Игорь Лабутин" Почему?
4148.74 4157.10 "Игорь Лабутин" Потому что если вы видели текстовое представление GUID, это несколько чисел через минус написанных.
4157.10 4164.22 "Игорь Лабутин" Там есть 30-дубитный компонент, 16-дубитный компонент и в конце хвост из, соответственно, просто байтов.
4164.22 4166.42 "Игорь Лабутин" Там 8 байтов, получается, в хвосте написаны.
4166.42 4176.66 "Игорь Лабутин" Так вот, эти первые компоненты, поскольку они пишутся как 30-дубитные или 16-дубитные чиселки, для них возникает вопрос - а в каком порядке писать байты этих самых чиселок?
4176.66 4182.18 "Игорь Лабутин" Так вот, Microsoft эти байты свопает, делает их Little Endian, то есть наименее значимый байт идет первым.
4182.18 4184.50 "Игорь Лабутин" Хотя по стандарту должно быть наоборот.
4184.50 4187.10 "Игорь Лабутин" Вот именно за это и отвечает вариант.
4187.10 4191.86 "Игорь Лабутин" И из-за этого как раз свопинга в том числе, с одной стороны.
4191.86 4205.86 "Игорь Лабутин" А с другой стороны, из-за того, что UUID v4 как один из наиболее популярных, то есть System GUID, он генерирует в общем-то полностью рандомный GUID, получается проблема, что ваши UUID, они честные и рандомные.
4205.86 4213.62 "Игорь Лабутин" Не то чтобы это была проблема, это в общем-то была цель получить эти самые рандомные UUID, но иногда хочется, чтобы они были монотонны.
4213.62 4217.26 "Игорь Лабутин" По разным причинам, давай про причины чуть ближе к концу поговорим.
4217.26 4221.06 "Игорь Лабутин" Ну вот хочется нам, чтобы UUID были рандомны, но монотонны.
4221.06 4223.10 "Игорь Лабутин" И тут начинается творчество.
4223.10 4239.06 "Игорь Лабутин" Значит, во-первых, есть собственно тот самый v1, v2, который в общем-то можно, он основывается на таймстэмпе, но там по стандарту должен быть MAC-адрес, MAC-адрес, ну в общем там много всяких разных неудобств, поэтому обычно их не используют.
4239.06 4255.86 "Игорь Лабутин" Но зато креативные программисты придумали много разных других форматов, и один из них довольно часто встречается, когда заходит речь о, собственно, таких вот монотонных UUID-ах, он называется ULID, Universal Lexical Graphical Sortable Identifier.
4255.86 4265.66 "Игорь Лабутин" То есть фишка в том, что его текстовое, он сам по себе, его байтовое представление сортируемое монотонно, но еще и текстовое представление тоже сортируемое монотонно.
4265.66 4269.98 "Игорь Лабутин" Значит, давайте быстренько расскажу, что это, а потом пойдем дальше в UUID.
4269.98 4279.62 "Игорь Лабутин" Значит, во-первых, интересная штука здесь в том, что он кодируется как 26-символьная строка, а не 36-символьная за счет использования кодировки Base32.
4279.62 4315.42 "Игорь Лабутин" Тоже это очень интересная кодировка, она заключается, то есть полностью она называется Crockford Base32, и она заключается в следующем, мы берем английский алфавит, добавляем к нему цифры от 0 до 9, получаем 36 символов, но дальше мы выкидываем буквы I, L, O и U, потому что они, ну I, L и O, это однозначно понятно, потому что они могут быть перепутанные с цифрой 1 или с 0, а U не помню почему, с чем может быть U перепутано?
4315.42 4316.42 "Игорь Лабутин" Да ничем.
4316.42 4325.74 "Игорь Лабутин" Ну вот почему-то U выкидывают, не знаю почему, как-то так сложилось, вот, и в итоге получается у вас вместо 36-ти 32 символа.
4325.74 4339.50 "Анатолий Кулаков" Ну и вообще подожди, сама идея в том, что у тебя единичка может быть перепутана с L или O, перепутана с 0, это же по ровности зависит от шрифта, ну то есть это как это, мне кажется, такое довольно убогое оправдание.
4339.50 4355.26 "Игорь Лабутин" Нет, эта штука была именно придумана для того, чтобы вот эти самые идентификаторы, они зависели, они действительно были независимы, то есть от шрифта в том смысле, что его можно продиктовать, ты можешь записать от руки чего угодно, и ты не перепутаешь.
4355.26 4358.98 "Анатолий Кулаков" Ну тогда может быть U, она путалась с V буквой.
4358.98 4359.98 "Анатолий Кулаков" Ну может быть, может быть.
4359.98 4360.98 "Игорь Лабутин" С викторией.
4360.98 4370.74 "Игорь Лабутин" То есть я так понимаю историю вот именно этого Chromehost Base 32, это была идея в том, чтобы максимально легко, чтобы ты потом не диктовал типа, О, но не 0, ну короче типа.
4370.74 4374.02 "Анатолий Кулаков" Ну в общем довольно нелепая, по-моему, отмазка в наши современные века.
4374.02 4392.46 "Игорь Лабутин" Ну не, на самом деле, не знаю, мне как бы прикольно, когда ты в каком-нибудь странном месте, когда ты в каком-нибудь, не знаю, кастомер где ты не можешь настроить нормальный шрифт, в каком-нибудь странной консоли, где ты селектом, ручками из базы что-нибудь селектишь, угадывать, что там единичка или L, и ну
4392.46 4398.62 "Анатолий Кулаков" конечно. Ну если вывернить все руки, выколоть глаза и, конечно, попенькой набирать по клавиатуре, то, конечно, это пригодится.
4398.62 4399.62 "Анатолий Кулаков" Ну давай вернёмся к реальности.
4399.62 4408.06 "Анатолий Кулаков" Ты каждый день пересылаешь, как бы, и зря транжиришь там несколько байт, вот проблема, которая каждый день у тебя возникает.
4408.06 4415.14 "Игорь Лабутин" Непонятно, не, ну можно, конечно, Base 64 использовать и получить ещё более компактное представление, но тем не менее, я не знаю.
4415.14 4420.94 "Игорь Лабутин" Мне идея как таковая понравилась, возможно, где-то кому-то она зайдёт.
4420.94 4428.70 "Игорь Лабутин" Ну дальше, ну понятно, что оно всё там case insensitive, никаких там special characters, то есть оно там в URL можно спокойно всё это запихивать.
4428.70 4437.98 "Игорь Лабутин" Ну и они монотонны, потому что там используется 48-битный таймстэмп, это Unix тайм в миллисекундах, и дальше 80 бит рандома.
4437.98 4447.42 "Игорь Лабутин" Причём они всё аккуратненько раскладываются правильно по юиду, в смысле, что они не затрагивают вот те самые там 4, 5, 6 битов, которые нужны для версии.
4447.42 4452.10 "Игорь Лабутин" Используют всегда с BigEndian, то есть всё это сортируется.
4452.10 4460.02 "Игорь Лабутин" Всё было бы хорошо, если бы в дотнете для этого были нормальные реализации.
4460.02 4463.86 "Игорь Лабутин" Они нашлись, их на самом деле нашлось несколько, они там разной степени качества.
4463.86 4474.50 "Игорь Лабутин" На самую, кажется, качественную линк есть в шоуноутах, от автора месседжпака, так что, скорее всего, там всё хорошо, с точки зрения производительности и всего остального.
4474.50 4486.74 "Игорь Лабутин" Но дальше мне, вот собственно на этом я как-то стал копаться дальше, что вообще ещё бывает, и выяснилось, что есть расширение спецификации для юидов, где привели новую версию.
4486.74 4493.02 "Игорь Лабутин" Придумали ещё три версии юидов, теперь есть ещё шестая, седьмая и восьмая юиды.
4493.02 4504.86 "Игорь Лабутин" Мне интересно, потому что как они это запихали, я, кстати, не посмотрел в спеке, как они запихали, потому что исходно под версию… А, нет, под версию там 4 бита используются, так что всё нормально, у нас есть время до 15.
4504.86 4506.86 "Игорь Лабутин" Пока хватает, пока гуляем.
4506.86 4511.74 "Игорь Лабутин" Да, так что пока живём, но… Но гуиды кончаются.
4511.74 4515.58 "Игорь Лабутин" Гуиды уже кончаются в каком-то смысле, ну ладно, в версии не так часто появляются.
4515.58 4521.98 "Игорь Лабутин" Короче, юид v6 это тот же самый, что v1, но только с нормально хранимыми таймстемпами.
4521.98 4528.42 "Игорь Лабутин" В юиде v1 первым хранилась лоу-часть таймстемпа, а в v1 только, соответственно, хай-биты.
4528.42 4537.22 "Игорь Лабутин" То есть, ну они были развернуты, и по сути из-за этого он не был, в общем-то, монотонным, несмотря на то, что основан на таймстемпе.
4537.22 4542.14 "Анатолий Кулаков" Ужас, на это мы потратили версии, ну какая расточительность.
4542.14 4550.02 "Игорь Лабутин" Да, v6, причём спека говорит, ну типа, если вам… Короче, если вы можете, v6 не используйте, вот мы её придумали, но не используйте, берите v7.
4550.02 4551.02 "Игорь Лабутин" Ну вот, да.
4551.02 4552.02 "Игорь Лабутин" Ужас.
4552.02 4553.02 "Игорь Лабутин" Почему?
4553.02 4555.66 "Игорь Лабутин" В v7, потому что нормальный таймстемп.
4555.66 4566.14 "Игорь Лабутин" В v6 или в v1 используется количество стонаносекундных интервалов с 1500, когда там начало грегорианского календаря, 1500 какой-то год.
4566.14 4574.22 "Игорь Лабутин" И это, короче, очень неправильная, видимо, сложно считаемая штука для того, чтобы изгнедить гуид.
4574.22 4582.58 "Игорь Лабутин" А вот в v7 используется нормальная штука, это количество миллисекунд от юникс таймстемпа, да, какой-то 1970 год.
4582.58 4595.98 "Игорь Лабутин" Причём поскольку это 48-битное число, то там нет проблем, его хватит до чего-то там, то ли 10000-года, то ли… Да, 10889 год.
4595.98 4599.62 "Игорь Лабутин" В общем, хватит, гуиды не кончатся.
4599.62 4609.50 "Игорь Лабутин" Потому что дальше есть ещё 80-бит рандомности, которые туда как бы докидываются.
4609.50 4616.22 "Игорь Лабутин" Так что внутри одной миллисекунды можно изгнедить 2/80 степени гуидов и в принципе должно всем хватить.
4616.22 4621.06 "Игорь Лабутин" Ну и дальше есть ещё гуид v8.
4621.06 4627.90 "Игорь Лабутин" Тут вообще очень странная спека, потому что оно написано, что оно такое же как в v4, в смысле что всё рандомное.
4627.90 4634.50 "Игорь Лабутин" Но сказано, что как бы в v4 всё рандомное, в v8 ну вы типа можете что-нибудь использовать не очень рандомное.
4634.50 4637.86 "Игорь Лабутин" Зачем это в спеку писать, непонятно, но видимо кому-то надо.
4637.86 4648.38 "Игорь Лабутин" Дальше, соответственно, возникает вопрос, ну гуиды гуиды, их там столько куча версий, что вообще с ними делать?
4648.38 4652.26 "Игорь Лабутин" Зачем они используются, зачем вокруг них столько плясок?
4652.26 4664.30 "Игорь Лабутин" С ними, ну мы, и наверное это одно из довольно частых применений, используем эту штуку, когда нужно генерить там ID каких-нибудь сущностей и нету какого-то центрального гуидового места, где эти ID генерятся.
4664.30 4676.74 "Игорь Лабутин" Ну то есть, например, мы на клиенте генерим ID, не знаю, чего-нибудь, там пользователь, товар, заказ, кого угодно, и нет у нас возможности спросить базу, дай нам следующий как бы ID числовой.
4676.74 4692.66 "Игорь Лабутин" Вот второй момент, где это можно использовать, это когда вам нужно генерить псевдо-уникальные, так скажем, ID-шники чего-либо, чтобы не дать возможность вашим пользователям угадать соседние ID-шники и как-то их возможно заиспользовать.
4692.66 4708.70 "Игорь Лабутин" Не то чтобы вас это должно, ну по идее ваше приложение должно быть от этого защищено, типа если вы там выдали пользователю информацию о том, что он является пользователем номер 3, ну наверное он, если он очень любопытный, попробует узнать что-нибудь про пользователя номер 2 и пользователя номер 4.
4708.70 4725.86 "Игорь Лабутин" Вот, и по идее ваша там API и все остальное должно корректно все это отработать, сказать, там, нет доступа, 401, вот это все, но с гуидами вроде как попроще в плане, что их угадать сложнее, совсем сложнее, за счет рандомной части, даже если они у вас, первая половинка основана на времени.
4725.86 4747.82 "Игорь Лабутин" Дальше возникает вопрос, что с ними делать в плане как хранить, то есть я видел кейсы, когда гуиды хранят аккуратненько в базе, в поле типа там текстовом, в текстовом представлении со всеми минусиками, видел вариант, когда его хранят еще с фигурными скобочками окружающими обязательно, ну там есть же такое, в ту стринг, по-моему, да, представление, когда он
4747.82 4749.82 "Анатолий Кулаков" сразу фигурно. Ну тоже текстом, ты имеешь в виду, да?
4749.82 4772.94 "Игорь Лабутин" Да-да-да, текстом, то есть по-моему, там по дефолту уже 36 символов, если я правильно помню, если с дефисами, но без фигурных скобок, а там было прям поле nvarchar от 38, чтобы фигурные скобки влезали, дальше, как ты понимаешь, поиск по такому полю, это значит, можно написать, то есть предварительный аргумент, если передали вдруг без фигурных скобок, нужно обернуть фигурные скобки, либо написать like в SQL.
4772.94 4776.02 "Игорь Лабутин" Красавцы, блин, отрывайте руки.
4776.02 4779.70 "Игорь Лабутин" Для маленьких табличек работало, как только табличка стала большая, стала работать плохо.
4779.70 4801.54 "Игорь Лабутин" Вот, на самом деле, конечно, гуиды надо хранить в нормальном нативном типе для BD, то есть там в pass-grade uid, в SQL Server, я уже забыл, как он называется, ну тоже как-то так он там называл, по-моему, там был, гуид, по-моему, он называется у них, традиционно для Microsoft, вот, и тогда в BD будет чуть более нормально с ними работать.
4801.54 4856.94 "Игорь Лабутин" Вот, дальше возникает вопрос, как бы, как их генерить, эти самые гуиды, и тут, с моей точки зрения, тут надо посмотреть, а какие гуиды вам нужны, то есть если вам нужен вообще полный-полный рандом, то можно использовать стандартный систем гуид, он не такой, может быть, шустрый-быстрый, но нормально работает, есть хороший генератор, это от Ромы Букина из Dodo, ссылочка будет у нас в описании, он там с панной, вот это все на него, просто на код можно посмотреть, как правильно и быстро все делать, он там генерирует их, их можно генерировать, там есть возможность, по-моему, последовательно генерировать time-based, а там получится нечто похожее на v1, вот, можно генерировать обычные v4 гуиды, либо, ну, либо пользоваться базой данных, если у вас есть такая возможность.
4856.94 4872.10 "Игорь Лабутин" И тут возникает вопрос, нужны ли нам последовательные гуиды зачем-то, вот тебе кажется, последовательные нам нужны, или вот эта вот идея с sequential ID в SQL, она как бы… что мне делать, если я не могу SQL использовать для генерации гуидов?
4872.10 4893.42 "Анатолий Кулаков" Ну, если вам нужны SQL сервер, который хранит гуиды, то есть ему нужны для хранения именно sequential гуиды, иначе у него там будут проблемы с select, с update и вообще со всеми прочими работами с этой базкой, то, конечно, нужны, но просто, мне кажется, это единственный случай, который я сейчас могу из головы придумать, зачем они тебе еще нужны?
4893.42 4900.82 "Игорь Лабутин" Ну, подожди, в любой базе у тебя будут проблемы, если ты хранишь гуиды, по нему хочешь что-то делать, например, индексы строить.
4900.82 4912.38 "Анатолий Кулаков" Да нет, абсолютно нет, ну если у тебя, например, хранится индекс в виде hash индекса, то есть ты по hash достаешь, как и стандартном dictionary, то они там могут быть хоть в 10 раз упорядочены, и hash наплевать.
4912.38 4915.02 "Игорь Лабутин" Да, но не каждый индекс может быть… Зависит от типа индекса.
4915.02 4917.42 "Игорь Лабутин" Правильно, не каждый индекс может быть hash индексом,
4917.42 4926.94 "Анатолий Кулаков" то есть, например, что… Ну, я же говорю, если тебе нужно хранить где-то там в b3 индексе, то допустим, но не всем это нужно, где тебе еще это надо?
4926.94 4945.22 "Игорь Лабутин" Ну, в основном как раз в b3 индексе, то есть, b3 индекс, если я правильно помню, тот же postgre, например, который сейчас, наверное, пользуется много кто, если я правильно помню, ну, я сейчас не скажу за последние версии, но до недавних версий, если ты вешаешь unique constraint на колонку, то все, у тебя только b3 индекс.
4945.22 4955.90 "Анатолий Кулаков" Нет, насколько я знаю, подgre вообще это не нужно, и в качестве доказательства можно привести то, что у postgre нет даже стандартной функции для генерации sequential индекса, потому что она и не нужна просто.
4955.90 4959.66 "Анатолий Кулаков" Она прекрасно переваривает с одной и той же скоростью и обычный, и GUID, и sequential.
4959.66 4960.66 "Игорь Лабутин" О, это же стало интересно.
4960.66 4961.66 "Игорь Лабутин" Мне что-то казалось, postgre…
4961.66 4966.34 "Анатолий Кулаков" Ну, ладно, давай мы это за эфиром как-то уточним.
4966.34 4971.18 "Игорь Лабутин" Нет, мы пока можем продолжать, я умею гуглить параллельно, это нормально.
4971.18 4986.58 "Игорь Лабутин" Дальше, ну да, в общем, если вам нужны, то есть, в SQL сервере там было понятно, что, потому что если вы создаете табличку по дефолту, она создается по дефолту с кластерным индексом, кластерный индекс это хб3 в SQL, и там, да, вот эта вот последовательность, она роляет.
4986.58 5002.38 "Игорь Лабутин" Такая же, кстати, штука, по-моему, в MySQL, если я правильно помню, там тоже по дефолту будет кластерный индекс на первичный ключ, и, соответственно, там тоже последовательность будет очень хорошо, иначе ваши рандомные GUID будут тягать в рандомные странички из бы дерева, из дисков памяти.
5002.38 5017.38 "Анатолий Кулаков" Я знаю, что Рэвин еще использует свои собственные, не то чтобы сказать GUID, но свои собственные, грубо говоря, грузы, потому что ему важно засовывать дату и время, он зачем-то там использует, не помню, тоже для каких-то системных нужд, например, очень полезно знать, когда эта запись была создана.
5017.38 5021.78 "Анатолий Кулаков" Ну это уже совсем хакерство и попытка запихнуть в 16
5021.78 5027.82 "Игорь Лабутин" байт как можно больше, там у них, видимо, нет цели, как бы соответствует спике GUID.
5027.82 5061.86 "Игорь Лабутин" Вот, ну, в общем, да, если у вас ваша BD плохо работает с совсем уж рандомными GUID, или в каких-то сценариях, если вам нужен строго B3 индекс по этой колонке или еще как-то, то тогда вам нужны последовательные GUID, и смотрите тогда в сторону либо UUID, либо ULEAD, для них есть, кстати, расширение для PuzzleGrig, которое нормально с ними работает, хранит их в 16 байтах, ну, короче, в UUID колонке, все как надо, в общем, все хорошо работает.
5061.86 5073.86 "Игорь Лабутин" Но иногда нужна штука, которая не то чтобы GUID, не то чтобы UUID, но все еще должна быть достаточно уникально.
5073.86 5087.18 "Игорь Лабутин" Хороший пример, который довольно многие приводят, это вот когда ты генеришь, когда ты аплодишь ролик на YouTube, у тебя ссылочка на YouTube, она, это там YouTube.com/что-то-там, и потом слышишь примерно десяток символов, относительно рандомных.
5087.18 5114.42 "Игорь Лабутин" Вот эта штука, она, ну вот у YouTube я не знаю, есть ли у него какое-то стандартное название, для, в целом я откопал штуку, которая называется NanoID, для начала она была, в принципе, придумана в JavaScript, где позволяет, ну то есть по стандарту или спеке, который, значит, они там придумали, они умеют генерить 126-битное рандомное число, там 2 бита каких-то служебных уходит.
5114.42 5132.54 "Игорь Лабутин" Используют они как раз бейс, типа бейс 36 или как-то так, пакуют это все в 21 символ, но сам стандарт, спека этого NanoID позволяет сказать, а генери мне, пожалуйста, рандомную штуку длиной не больше 10.
5132.54 5150.74 "Игорь Лабутин" Понятное дело, что вероятность коллизий увеличивается, но зато у тебя будет там стандартные 10 рандомных чисел, и вот этот алгоритм что ли полезен, если вам нужно генерить что-то похожее на YouTube, на YouTube вещь?
5150.74 5181.70 "Анатолий Кулаков" Я бы тут тебя поправил, для YouTube вещей немножко другой алгоритм используется, там именно словарик есть, который позволяет вам по порядку не перебирать, вот, например, IDшники, которые ты, например, приводил в начале, там используется что-то наподобие их Hash ID, я тебе тут еще немножко заброшу, что мы все эти темы уже обсуждали, как бы все уже было в Симпсонах, выпуск номер 51, если кого-то интересует, тема называлась у нас "Generating Sortable GUIDs Using New ID", не поверишь.
5181.70 5182.70 "Анатолий Кулаков" Вау.
5182.70 5195.34 "Анатолий Кулаков" И там как раз обсуждали YouTube-овские Hash, и New ID, и Sortable GUID, и Андрю Лока, который к ним тоже приложил руку, в общем, это там все тоже есть, поэтому, если кому тема интересна, 51 выпуск тоже послушайте.
5195.34 5200.66 "Игорь Лабутин" Ну это давно было, сколько уже, 18 выпусков назад, это ж почти год.
5200.66 5202.66 "Анатолий Кулаков" Ну да, уже пора повторяться.
5202.66 5208.78 "Игорь Лабутин" Да, так что, ну видишь, мне тоже пора переслушивать, старенький мы стали, свои же архивы приходится переслушивать.
5208.78 5223.78 "Игорь Лабутин" Ну короче, да, есть такая штука на Найде, она запортирована тоже на много языков, в общем, вполне тоже может быть пригодится для таких читаемых коротких рандомных строчек там в Урлы или еще куда-нибудь.
5223.78 5235.46 "Игорь Лабутин" Вот, примерно такую штуку, так сказать, я внезапно начал копаться, не то чтобы у меня по ней сложилась абсолютно полная картинка, но будем копать дальше.
5235.46 5241.78 "Игорь Лабутин" Про Postgres мне даже интересно, потому что, да, тоже покопаюсь, посмотрю.
5241.78 5244.54 "Игорь Лабутин" Мне казалось, что обязательно B3 должно быть.
5244.54 5245.54 "Анатолий Кулаков" Ну, разберемся.
5245.54 5255.78 "Анатолий Кулаков" Если у вас вдруг еще есть какие-то примеры, где вам вдруг понадобилось сортированные GUID, тоже придите в комменты, покажите, очень интересно для расширения кругозора.
5255.78 5262.98 "Игорь Лабутин" Ну или поправьте нас, если мы где-то были неправы или сказали что-то не так, тоже вполне может быть.
5262.98 5264.50 "Анатолий Кулаков" Так, пойдем дальше.
5264.50 5267.82 "Анатолий Кулаков" У меня тут еще одна интересная темка есть про логи.
5267.82 5270.82 "Анатолий Кулаков" Продолжаем best practices, продолжаем best practices про логи.
5270.82 5274.14 "Анатолий Кулаков" Я надеюсь, что мы когда-нибудь наконец-то они все-таки договорим.
5274.14 5279.38 "Анатолий Кулаков" Но пока темы остались, и раз остались темы, давайте пробежимся еще по одной статейчике.
5279.38 5287.14 "Анатолий Кулаков" Она называется «Максимизируем мощь логов в ваших расширяемых приложениях».
5287.14 5298.14 "Анатолий Кулаков" Эта статья мне понравилась тем, что автор заходит с довольно нестандартной стороны, которую очень редко обсуждают, рассматривают какие-то другие авторы.
5298.14 5301.82 "Анатолий Кулаков" Он как раз-таки смотрит на логи как на источник информации.
5301.82 5306.86 "Анатолий Кулаков" Давайте конкретно на примерах посмотрим, что именно он как раз имеет в виду.
5306.86 5331.10 "Анатолий Кулаков" Итак, после того как, это уже личные мои мнения, после того как я увидел, осознал и начал применять структурированное логирование, это было очень-очень давно, я старый, я сразу подумал, что в принципе, если мы применяем структурированное логирование, то результат нашей работы, результат логов, это по сути схема лес база данных.
5331.10 5336.54 "Анатолий Кулаков" Раз это база данных, из нее можно выбирать данные абсолютно любые, какие вам нужны.
5336.54 5349.58 "Анатолий Кулаков" И все то, что сейчас называется open telemetry, open tracing или какая-нибудь еще телеметрия или метрики или еще что-то, на самом деле все это есть в логах.
5349.58 5365.06 "Анатолий Кулаков" Если мы абстрагируемся от того, что выбирать это там медленно, надо строить индексы, должна быть какая-то избыточность, то есть от технической шушеры мы абстрагируемся и мыслим только логически, то по сути мы получаем базу данных, в которой вся эта информация есть.
5365.06 5369.74 "Анатолий Кулаков" Ну в зависимости от того, сколько мы туда пишем, то есть вполне мы можем туда писать столько, чтобы она там была.
5369.74 5375.86 "Анатолий Кулаков" И вот автор рассматривает как раз таки шесть типов данных, которые мы можем вытащить из наших логов.
5375.86 5381.70 "Анатолий Кулаков" Ну первый тип прежде всего, это непосредственно замена дебагингу, это сам дебагинг.
5381.70 5386.66 "Анатолий Кулаков" То есть когда мы видим какую-то проблему на продакшене, мы первым делом идем и смотрим в логи.
5386.66 5391.22 "Анатолий Кулаков" И в этих логах мы обязательно надеемся увидеть некие стандартные вещи.
5391.22 5399.26 "Анатолий Кулаков" Вот сейчас мы несколько этих стандартных пунктов обсудим, а вы подумайте, есть они в ваших логах или нет и эти вещи вам могут помочь в дебагинге.
5399.26 5402.94 "Анатолий Кулаков" Прежде всего мы должны обязательно логировать все ошибки.
5402.94 5413.54 "Анатолий Кулаков" Это исключения, какие-нибудь плохие запросы, логические проблемы, несоответствие ожидания или если приложение например завалилось, все это обязательно должно быть в логах.
5413.54 5415.38 "Анатолий Кулаков" И все это относится к теме дебагинга.
5415.38 5419.06 "Анатолий Кулаков" Это помогает нам понять, что с приложением пошло не так.
5419.06 5424.62 "Анатолий Кулаков" Второй интересный момент это сохранение с каждым лог-месседжем с сэшн-айди.
5424.62 5432.10 "Анатолий Кулаков" С сэшн-айди в данном случае подразумевается некая ассоциация с кастомером, с клиентом.
5432.10 5441.38 "Анатолий Кулаков" То есть как только клиент, кастомер открыл ваше приложение, ему генерится сэшн-айди и не меняется до тех самых пор, пока приложение не закрывается.
5441.38 5445.06 "Анатолий Кулаков" Таким образом вы всегда сможете проследить сессию вашего пользователя.
5445.06 5454.42 "Анатолий Кулаков" Что с ним было с самого начала открытия, то есть с самого начала работы, вообще с начала вашего приложения и до того, как он закрыл вкладку или закрыл приложение.
5454.42 5460.54 "Анатолий Кулаков" Здесь интересный момент есть, что ваше приложение должно давать пользователю возможность послать какой-то фидбэк.
5460.54 5466.86 "Анатолий Кулаков" Если он нажмет кнопочку и напишет туда какое-нибудь гневное замечание, то это тоже можно вполне отослать в логи.
5466.86 5473.86 "Анатолий Кулаков" Главное связать его с этим сэшн-айди, по которому мы сможем найти, что это за пользователь, как он его послал и как он работает со своим приложением.
5473.86 5477.94 "Анатолий Кулаков" В общем, провязать весь веб-флог пользователя с вот этим идентификатором.
5477.94 5481.38 "Анатолий Кулаков" Другой идентификатор, который должен у вас быть, это корреляшн-айди.
5481.38 5486.82 "Анатолий Кулаков" Корреляшн-айди должен быть уникальным в каждом запросе к серверу.
5486.82 5496.54 "Анатолий Кулаков" То есть это именно тот айдишник, который, например, используется в Distributed Tracing, который позволяет вам проследить все сервисы, которые были в цепочке этого запроса.
5496.54 5502.14 "Анатолий Кулаков" Он должен быть каждому запросу уникальный, но при этом один и тот же, если сервис вызывает сервис.
5502.14 5504.34 "Анатолий Кулаков" Как только пользователь вызывает, он у вас генерится.
5504.34 5512.02 "Анатолий Кулаков" Как сервис вызывает сервис, он передается тот же самый и таким образом мы можем построить весь Distributed Tracing по вот этому идентификатору.
5512.02 5517.22 "Анатолий Кулаков" И это тоже очень упрощает отладку, тем более если мы говорим про распределенную отладку.
5517.22 5524.10 "Анатолий Кулаков" Также у вас в логах должна быть обязательно одна система, в которую сливаются все логики.
5524.10 5542.66 "Анатолий Кулаков" Потому что как только у вас начнется быть много микросервисов, клиентов на разных платформах с разными форматами и все будут писать в какие-то свои собственные системы, свои собственные сториджи, вы замучаетесь все это мерзнуть, все это коррелировать по какому-то одишнику, это практически невозможно.
5542.66 5548.94 "Анатолий Кулаков" Поэтому у вас должна быть одна система, куда все вместе сливается и там уже можно каким-то образом работать с этими данными.
5548.94 5557.58 "Анатолий Кулаков" Следующий пункт, вы должны обязательно логировать важные ивенты, по которым изменяется состояние вашего приложения.
5557.58 5565.02 "Анатолий Кулаков" Для того, чтобы определить ключевые точки, что собственно происходило с приложением, что пользователь делал и к чему это привело.
5565.02 5570.06 "Анатолий Кулаков" Это стандартные наши информейшн логи, которые каждый из вас должен писать.
5570.06 5573.10 "Анатолий Кулаков" Вот эти пункты, они все как раз относятся к дебагингу.
5573.10 5584.74 "Анатолий Кулаков" Если вы их соблюдаете, то по идее, по вашим логам должно быть очень легко отлаживать приложение, искать какие-то проблемы и наблюдать вообще за тем, что с пользователем все-таки происходило.
5584.74 5588.66 "Анатолий Кулаков" Второй пункт, который могут заменить логи, это телеметрия.
5588.66 5597.06 "Анатолий Кулаков" Как только ваше приложение становится большое, большое, и вами начинают пользоваться миллиарды пользователей, смотреть все это в логах становится проблематично.
5597.06 5600.54 "Анатолий Кулаков" Ну даже не все, это ошибки, вы все равно будете в логах смотреть, от этого никуда не денетесь.
5600.54 5605.58 "Анатолий Кулаков" А вот наблюдать за пользователем, за его поведением, вот это становится уже проблематично.
5605.58 5614.62 "Анатолий Кулаков" Вам нужно в этот момент агрегировать много-много данных, может быть строить графики, может быть навешивать туда какие-то дополнительные анализы, но для этого вам нужна телеметрия.
5614.62 5632.18 "Анатолий Кулаков" И телеметрия включает в себя, например, ответы на такие вопросы, какие фичи пользователь использует, как часто он их использует, как долго он проводит время в том или ином режиме, там окне или сессии, как много вообще у вас пользователей есть в системе, как часто они заходят, в какое время заходят.
5632.18 5636.74 "Анатолий Кулаков" Чаще он использует фичу один или чаще он использует фичу два.
5636.74 5644.90 "Анатолий Кулаков" И вот такие вот вещи, которые позволяют вам более детально анализировать то, как ваше приложение работает, как с ним работает и как взаимодействует.
5644.90 5658.06 "Анатолий Кулаков" И если вдруг вы обнаружили, что какую-то фичу у вас вообще не используется, то вам, наверное, можно сделать ее более доступной для пользователя, как-то написать более про нее документации больше или еще что-то, или вообще выпилить ее наконец.
5658.06 5660.42 "Анатолий Кулаков" И вот на все эти вопросы позволяет ответить телеметрия.
5660.42 5664.46 "Анатолий Кулаков" И эта телеметрия также точно элементарно достается из логов.
5664.46 5676.70 "Анатолий Кулаков" Если у вас вся эта информация есть, куда пользователь нажал, что открыл, как часто смотрел, вы эту телеметрию можете симулировать с помощью прекрасно структурированного запроса из хранилища логов.
5676.70 5681.62 "Анатолий Кулаков" Третий пункт, который могут заменить логи, это всякие перформанс-каунтеры и метрики.
5681.62 5687.14 "Анатолий Кулаков" На самом деле логи - это прекрасный источник для того, чтобы замерять перформанс.
5687.14 5694.18 "Анатолий Кулаков" И, например, время работы каких-то функций, время выполнения обычной функции, время выполнения запроса к базе данных.
5694.18 5704.46 "Анатолий Кулаков" Http-реквеста, например, сколько рендерился ваш UI, сколько времени обрабатывался какой-то хендлер, какая-то команда.
5704.46 5709.34 "Анатолий Кулаков" Все это обычно очень легко записать в логи.
5709.34 5713.34 "Анатолий Кулаков" Пишите начало, засекаете таймер и в конце пишите, сколько вас это заняло.
5713.34 5716.42 "Анатолий Кулаков" То есть, эта информация тоже элементарно вытаскивается из логов.
5716.42 5722.06 "Анатолий Кулаков" И очень часто нормальные корпоративные приложения, особенно, запихивают к себе APM.
5722.06 5737.10 "Анатолий Кулаков" Это такие специальные инструменты, которые как раз таки снимают различную телеметрию, различные метрики, позволяют вам визуализировать такие запросы, позволяют вам показать, как раз таки, как интерактивно сервисы общаются друг с другом.
5737.10 5738.30 "Анатолий Кулаков" И все это просто идет из коробки.
5738.30 5748.74 "Анатолий Кулаков" Если у вас есть структурированные логи, то вы на основании сырых данных можете получить ту же самую информацию, и вам не нужны никакие дорогостоящие инструменты.
5748.74 5755.38 "Анатолий Кулаков" Вы все это можете сделать сами, визуализировать сами, используя всего лишь один источник – это логи.
5755.38 5759.30 "Анатолий Кулаков" Четвертый пункт, который логи могут вам предоставить – это алертинг.
5759.30 5768.50 "Анатолий Кулаков" То есть это то же самое, если у вас очень много данных и вы уже ручками не успеваете разгребать все инциденты, то вам нужно уже настраивать автоматизацию.
5768.50 5772.06 "Анатолий Кулаков" И автоматические алертинги – это одно из самых главных спасений.
5772.06 5778.02 "Анатолий Кулаков" Например, если ваше приложение уронилось, вам должно прийти какое-то сообщение, если оно закрашилось.
5778.02 5783.26 "Анатолий Кулаков" Если на сервере стали получаться очень много ошибок, которых раньше не было.
5783.26 5788.70 "Анатолий Кулаков" Если вдруг CPU стала зашкаливать или потребляться больше, или вдруг меньше памяти, чем раньше.
5788.70 5793.14 "Анатолий Кулаков" Или если вдруг появилось много ошибок в ваших логах.
5793.14 5798.50 "Анатолий Кулаков" На это все настраиваются алерты, которые вам неизменно сообщают, что же, собственно, случилось.
5798.50 5804.94 "Анатолий Кулаков" Как вы понимаете, вся эта информация тоже легко может быть доступна в логах, ее оттуда можно считать.
5804.94 5809.78 "Анатолий Кулаков" Еще интересная штука – это различные эксперименты и А/Б тестирования.
5809.78 5827.14 "Анатолий Кулаков" То есть вы вполне можете в свои приложения сделать какую-то фичу флаг для улучшения перформанса или для исследования какой-то новой фичи, нового дизайна и логировать то, как пользователь взаимодействует с той или иной фичей в том или ином режиме фичи флага.
5827.14 5839.30 "Анатолий Кулаков" Для этого, для проведения такого А/Б тестирования элементарно вам нужно сделать фичу, вам нужно ее каким-то образом рандомно раскидать между сессиями или между пользователями и в логах записывать, как пользователь с ней участвует.
5839.30 5840.30 "Анатолий Кулаков" Вот и все.
5840.30 5845.18 "Анатолий Кулаков" В принципе, этой информации вам достаточно для того, чтобы опять же из лога все это вытащить, посмотреть и почитать.
5845.18 5849.26 "Анатолий Кулаков" И шестой, последний пункт, довольно неочевидный – это как раз таки тестирование.
5849.26 5852.10 "Анатолий Кулаков" Как логи могут помочь вам в тестировании?
5852.10 5865.78 "Анатолий Кулаков" Автор говорит, что очень часто компоненты есть, которые внутри себя скрывают сложную логику и какой-нибудь end-to-end тест написать для того, чтобы она проверила эту сложную логику практически невозможно.
5865.78 5872.68 "Анатолий Кулаков" То есть без открытия какой-то внутренней реализации или внутренних событий, которые происходят внутри домена.
5872.68 5874.86 "Анатолий Кулаков" И открывать это обычно не хочется.
5874.86 5883.18 "Анатолий Кулаков" Он предлагает довольно, наверное, дерзкий подход – это использовать для этого логи.
5883.18 5895.46 "Анатолий Кулаков" Если мы представим, вернемся к нашему тезису, что по сути результат работы вашего приложения – это логи и логи в виде базы данных, то по сути мы можем сходить к этой базе данных и спросить, а что собственно происходило.
5895.46 5912.22 "Анатолий Кулаков" То есть, допустим, если мы запустили какой-то end-to-end тест, приложение внутри себя создало пользователя с каким-то таким айдишником непонятным, нам ничего не вернуло, но в тестах мы можем пойти в базу данных, найти там этого пользователя, найти айдишник, посмотреть его поля и сделать выводы о том, что да, приложение отработало нормально.
5912.22 5916.54 "Анатолий Кулаков" Или же, если бы не нашли такого пользователя, приложение отработало ненормально.
5916.54 5927.14 "Анатолий Кулаков" Естественно, это немножко добавляет хрупкости тестам, потому что эти логи могут меняться, добавляться, переноситься, но как факт, автор говорит, что применял такие штуки и в принципе это все работает.
5927.14 5941.80 "Анатолий Кулаков" Как я уже сказал, я, наверное, не первый, к кому пришла эта мысль использовать логи как базу данных, более того, насколько я знаю, в самой крупной дотнет-компании в России, компании Contour, как раз-таки используется такой подход.
5941.80 5946.78 "Анатолий Кулаков" Они это начали делать еще до того, по-моему, как появились даже структурные логи.
5946.78 5955.82 "Анатолий Кулаков" Они абсолютно все логи писали в Kafka, Kafka это все складывало там в различные системы вплоть до, по-моему, Clickhouse, боюсь соврать уже.
5955.82 5961.30 "Анатолий Кулаков" И они воспринимали все эти логи и как метрики, и как логи, и как distributed tracing.
5961.30 5973.62 "Анатолий Кулаков" В зависимости от того, какой инструмент слушал этот топик, он для себя собирал те или иные данные, записывал в тот или иной вид, строил те или иные графики, но источник был всегда один, это логи.
5973.62 6014.82 "Анатолий Кулаков" В общем, если кому-то интересно, пишите в комментариях, разберем подход Contour поподробнее, потому что мне кажется, очень занимательное направление и странно, что в эту сторону никто не думает, ну то есть мейнстрим не думает, потому что в основном все люди как раз-таки пытаются делить, все инструменты пытаются делить и как раз-таки не применяют тот подход, что на самом деле у нас может быть один единственный источник данных и современные технические средства вполне это тянут, что было там как бы не раз доказано на практике и Contour, и тот же самый у Azure есть инструменты, которые позволяют вашим логам именно так с ними работать, и много-много других там есть инструментов и коммерческих, и не очень.
6014.82 6031.02 "Анатолий Кулаков" В общем, интересное направление, мне кажется, имеет право на жизнь, даже мне казалось, оно должно было выиграть у направления, которое проповедует OpenTelemetry, когда мы под каждую сущность заводим свою новую что-то и пытаемся как-то с этим подружить всех.
6031.02 6037.18 "Анатолий Кулаков" Ну, посмотрим, история покажет, кто выиграет в конечном итоге.
6037.18 6053.90 "Игорь Лабутин" Не, ну видишь, OpenTelemetry заводит сущность и говорит, что мы их репортим по-разному, потому что все-таки паттерны репортинга могут быть немножко разные, и в метриках ты можешь себе позволить что-то пропустить, в логах может быть ты не хочешь позволять себе ничего пропускать, в зависимости от твоих настроек.
6053.90 6064.78 "Игорь Лабутин" И может быть даже полезно их складывать, ну, в качестве разной сториджа, потому что, опять же, они немножко time series одного, а логи немножко другое.
6064.78 6075.62 "Игорь Лабутин" Но вот иметь абсолютно единый UI, как раз вот даже Azure OpenSights был хорошим примером, там тебе и метрики, и логи все вместе сразу в одной точке, все это можно скоррелировать, посмотреть.
6075.62 6077.66 "Игорь Лабутин" Короче, вот это было бы да.
6077.66 6080.78 "Анатолий Кулаков" Ну, просто смотри, складывать это уже 10-й вопрос.
6080.78 6084.38 "Анатолий Кулаков" Мы сейчас говорим про интерфейс именно паблишеров, как мы это репортим.
6084.38 6088.86 "Анатолий Кулаков" И вот кажется, что репортить мы это все могли в одном единственном виде, например, в виде логов.
6088.86 6091.10 "Анатолий Кулаков" Почему бы и нет, это структурированные данные.
6091.10 6095.30 "Анатолий Кулаков" А вот куда эти логи пойдут, это можно решать, например, их уровнем логирования.
6095.30 6098.46 "Анатолий Кулаков" Трейсы мы можем пропускать, иерорры мы пропускать не должны.
6098.46 6101.74 "Анатолий Кулаков" Для метрик сделать еще какой-нибудь уровень, допустим, логирования.
6101.74 6111.02 "Анатолий Кулаков" И то, куда они будут потом створиться, какие синки записываться, как реплицироваться, это тоже можно уже решать потом, в зависимости от того, что мы там, собственно, зарепортили.
6111.02 6115.78 "Анатолий Кулаков" Но вот зачем было делать разные интерфейсы для этого, вот это довольно неочевидно, потому что пользователь только путается.
6115.78 6118.14 "Игорь Лабутин" Но пользователь, ты имеешь в виду девелопер?
6118.14 6119.14 "Анатолий Кулаков" Да, девелопер.
6119.14 6124.86 "Анатолий Кулаков" Он не знает в большинстве случаев, это лог, под каким он уровнем, может быть, это метрика, а может, это вообще дистрибьютор трейсинга.
6124.86 6126.34 "Анатолий Кулаков" Зачем мне вот это все усложнение?
6126.34 6140.02 "Анатолий Кулаков" Причем тебе нужно не только девелопер путается, но и тебе же под каждый этот интерфейс там отдельные консюмеры, отдельные транспортеры, отдельные форматоры, это же все отдельно вообще планируется, идет, специфицируется.
6140.02 6146.74 "Игорь Лабутин" А что-то же ты вообще никуда не шлешь, а тебя какой-нибудь Прометеус сам дергает и спрашивает, ну скажи мне твои метрики.
6146.74 6154.18 "Анатолий Кулаков" Да, что-то не шлешь, что-то в памяти хранишь, он там к тебе приходит, что-то там в какой-то приватный диск складывается для того, чтобы не потеряться.
6154.18 6157.34 "Анатолий Кулаков" Что-то в сеть отправляется, но это решается уже потом.
6157.34 6172.14 "Игорь Лабутин" А вот непонятно, ну допустим, не знаю, я хочу мониторить, ну чтобы у меня в метриках появилась, не знаю, сейчас дай сформулирую, длина какой-нибудь моей внутренней очереди, допустим, да, я там храню какой-нибудь in-memory очередь, вот я хочу ее длину увидеть в метриках.
6172.14 6179.98 "Игорь Лабутин" У меня, ну вот в каком месте кода я буду пушить, как в логе, ну типа в лог, ее размер.
6179.98 6185.10 "Анатолий Кулаков" Ну смотри, в общем случае у тебя все логи идут куда-нибудь в кавку.
6185.10 6186.10 "Анатолий Кулаков" Нет.
6186.10 6190.82 "Анатолий Кулаков" То есть как только у тебя меняется размер очереди, ты переставишь сообщение в кавку, новый размер очереди такой-то.
6190.82 6197.30 "Игорь Лабутин" А, вот, то есть типа внутренне, ну сейчас, то есть это во всех местах, где я в эту очередь пишу, получается?
6197.30 6207.06 "Анатолий Кулаков" Ну по идее у тебя есть какой-то класс очереди, у которого есть размер, и ты должен мочь там проследить, когда он меняется, там у тебя события или resize, или еще что-то, или add какой-то.
6207.06 6208.06 "Анатолий Кулаков" Это если моя очередь.
6208.06 6210.06 "Анатолий Кулаков" То есть не те места пишет, куда ты пишешь.
6210.06 6211.06 "Анатолий Кулаков" Это если моя очередь.
6211.06 6212.06 "Анатолий Кулаков" Вбери в свою.
6212.06 6216.58 "Игорь Лабутин" Ну вот начинается, надо наследоваться, оборачивать, короче.
6216.58 6222.70 "Анатолий Кулаков" Так а как ты туда метрики еще засунешь, даже если мы сейчас возьмем, что ты будешь писать туда с помощью телеметрии?
6222.70 6223.70 "Анатолий Кулаков" Как ты эту длину очереди переплачешь наружу?
6223.70 6230.82 "Игорь Лабутин" Ну, как Prometheus дернул от меня, я в этом месте беру и очереди говорю, типа вот, меня Prometheus дернул, я говорю return, q, и пишу кавку.
6230.82 6240.82 "Анатолий Кулаков" Ну если тебя устраивает, что ты раз в час там видишь изменение своей очереди, пиши, ну заведи таймер и дергай себя раз в час и пиши логи раз в час в очередь, какая разница-то?
6240.82 6241.82 "Анатолий Кулаков" Ты же мне сделаешь хуже.
6241.82 6262.82 "Игорь Лабутин" Ну вот да, Prometheus-то так и делали, мы, собственно, там 10-15 лет назад писали всякие десктопные приложения, да, ровно так и делали, там был, ну там не таймер был, там был просто какие-то ключевые, ну по сути, в общем, таймер, можно сказать, да, который просто периодически дампил в интересные места, в интересные моменты времени какую-то статистику по внутренним структурам данных.
6262.82 6263.82 "Анатолий Кулаков" Но это все как-то, не знаю.
6263.82 6270.66 "Анатолий Кулаков" Так и есть, ты же не сделаешь хуже, то есть подход с Prometheus-ом, он самый галеный, который только может быть, хуже его сделать невозможно.
6270.66 6286.50 "Анатолий Кулаков" Подход с вот этим Event Sourcing, когда ты валишь все логи, как бы он, с ним можно сделать и плохо, как с Prometheus-ом, и это не то чтобы хорошо, это ну, реал таймер, не всегда это надо, но ты можешь так сделать, ты же можешь выбирать, что тебе нужно.
6286.50 6298.54 "Игорь Лабутин" Ну может быть, может быть, ну может быть было как-то и хорошо, или там могло бы быть как-то лучше, чем сейчас, ну и что есть, что есть, OpenTelemetry с нами, кажется, это все-таки становится стандартным.
6298.54 6303.86 "Игорь Лабутин" Они, кстати, договорились, ты не в курсе, до того, чтобы стандартизировать остатки-то всей спецификации?
6303.86 6307.38 "Анатолий Кулаков" Потому что телеки… Да, да, кажется стандартизировали, уже это вот на это во всё имплементируется.
6307.38 6311.62 "Игорь Лабутин" В смысле, и логи, и метрики, и трейдинг, ну все полностью,
6311.62 6314.26 "Анатолий Кулаков" да, теперь уже? И логи, и метрики, и трейдинги, да.
6314.26 6322.38 "Игорь Лабутин" Все, потому что я что-то, когда последние какие-то статьи у меня попадалось, было сказано, что пока нет, ну она была там от какого-то середины 1922 года.
6322.38 6327.50 "Анатолий Кулаков" Ну надо перепроверить, я думаю, добавим подкастик, расскажем всем, как только узнаем.
6327.50 6329.46 "Анатолий Кулаков" Давай закругляться, у нас там уже много всего.
6329.46 6336.78 "Игорь Лабутин" Давай закругляться, у нас, да, последняя тема, кратко, о разном, в этот раз об очень разном, и довольно кратко.
6336.78 6345.62 "Игорь Лабутин" Во-первых, попалась статейка, которая навела на мысль, которую я действительно не думал, это про минимал API и про группы.
6345.62 6352.10 "Игорь Лабутин" То есть каждый раз, когда я рассказывал про минимал API группы, возникал вопрос, ну и у меня в том числе, зачем их использовать.
6352.10 6367.58 "Игорь Лабутин" Ну один момент, которым удобно их использовать, это единая точка, где можно навесить, например, авторизацию на всю там пачку endpoints, которые определены в этой группе, а другая мысль, которая приводится в этой статье, это про то, что это может быть интересный способ версионировать.
6367.58 6374.30 "Игорь Лабутин" То есть вы задаете группу с названием там V1, группу с префиксом V2, и дальше внутри что-то используете.
6374.30 6392.14 "Игорь Лабутин" Возможно, вы, если вы дальше, допустим, переиспользуете какие-то методы, которые не меняются между версиями, но вы сможете одни и те же лямбдачки передать, объявить их как-то отдельно, и таким образом один и тот же код будет исполняться с этими и теми же модельками.
6392.14 6400.82 "Игорь Лабутин" Ну в общем, подход, возможно, интересный, возможно, иметь место быть, надо пробовать, больших каких-то приложений и отзывов я не видел, но посмотрим, что получится.
6400.82 6401.82 "Игорь Лабутин" Мысль интересная.
6401.82 6405.26 "Игорь Лабутин" Это такой был практически небольшой момент.
6405.26 6412.14 "Игорь Лабутин" А вот дальше интересная штука, которая пока непонятно куда вывернется, но тем не менее.
6412.14 6421.10 "Игорь Лабутин" Эксперимент от Стива Сандерсона, это автор Blazor, он сделал штуку, которая называется .NET Isolator.
6421.10 6424.90 "Игорь Лабутин" Он спросил себя следующий вопрос.
6424.90 6448.74 "Игорь Лабутин" Смотрите, говорит, у нас есть .NET приложение, и я хочу в этом приложении запускать другие кусочки .NET кода, но изолировано, так чтобы эти самые кусочки .NET кода не могли ничего сделать с моей, так сказать, средой вокруг меня, то есть там, не знаю, диск не могли прочитать, то есть как-то ограничить API-сервис этих кусочков, чтобы им разрешить только то, что я хочу.
6448.74 6450.46 "Анатолий Кулаков" Он перезабрел апдомены?
6450.46 6456.30 "Игорь Лабутин" Типа того, но все-таки в апдомен, я не помню, можешь ли ты прям так сурово ограничить апдомен.
6456.30 6463.78 "Анатолий Кулаков" Да, там security restrictions есть, к которым ты можешь передать даже методы, которые можно выполнять, и из каких-то спейсов их можно выполнять.
6463.78 6465.14 "Игорь Лабутин" Там очень хорошо все было.
6465.14 6472.06 "Игорь Лабутин" Хорошо, этим я не пользовался никогда, но у нас апдоменов нету, он по сути их перезабрел с помощью WASM в WebAssembly.
6472.06 6487.42 "Игорь Лабутин" То есть он сделал следующее, он внутри .NET поднял WASM runtime с помощью библиотечки WASM time, а внутрь этого WASM закидывает .NET код, который ты хочешь исполнять, скомпилированный в WASM.
6487.42 6489.42 "Игорь Лабутин" Ну это сильно, сильно.
6489.42 6495.58 "Игорь Лабутин" И у тебя получается такая виртуальная машинка в виде WebAssembly, которая исполняет .NET код.
6495.58 6501.90 "Игорь Лабутин" Причем ты можешь дергать из своего хостового .NET внутренний .NET, он там нормально работает, строчки всякие прокидывает и так далее.
6501.90 6514.02 "Игорь Лабутин" Понятно, что это все очень экспериментал, поэтому все это очень на тоненького, но на удивление, он говорит, как бы работает даже на удивление довольно шустро, он ожидал гораздо более проблемного и медленной работы.
6514.02 6515.02 "Игорь Лабутин" Так что посмотрим, куда это.
6515.02 6523.26 "Игорь Лабутин" Скорее всего это не пойдет никуда, конечно, в никакой продукт, но это видимо очередные интересные эксперименты, которые возможно во что-то интересное формятся чуть дальше.
6523.26 6532.94 "Игорь Лабутин" Так что если вам интересна тема WebAssembly, рекомендую посмотреть там 15-минутный видосик от него с демонстрацией основных фич, у нас ссылочка на него есть, и ссылочка на его GitHub, где собственно все это лежит.
6532.94 6542.98 "Анатолий Кулаков" Ну мысль очевидная, потому что WASM он сам разрабатывался как штука, которая работает внутри сендбокса, браузерного сендбокса изначально, но не принципиально.
6542.98 6547.30 "Анатолий Кулаков" И на основании его сделать сендбокс .NET-овский, это конечно хорошо.
6547.30 6552.90 "Анатолий Кулаков" Тут единственное смущает, конечно, то, что .NET приходится перекомпилировать WASM для того, чтобы выполниться.
6552.90 6555.02 "Анатолий Кулаков" Вот это, наверное, большой все-таки минус пока.
6555.02 6560.62 "Игорь Лабутин" Ну почему перекомпилироваться, ты же можешь туда закидывать как бы и Delay, там просто интерпретируется внутри и все, ну же.
6560.62 6566.02 "Анатолий Кулаков" Интерпретируется, это же то же самое, то есть ты теряешь на производительности, на маршаллинге и на прочих всяких глупостях.
6566.02 6568.58 "Игорь Лабутин" Ну конечно, плюс у тебя второй рентайм внутри живет, хоть и маленький.
6568.58 6570.58 "Анатолий Кулаков" Ну да, так и есть.
6570.58 6579.18 "Игорь Лабутин" Но тем не менее, возможно, это какой-то для каких-то суперкритичных случаев, если вам нужно суперсекьюрно выполнить какой-то левый код, то почему нет.
6579.18 6581.30 "Игорь Лабутин" Да, да, вполне вариант.
6581.30 6591.98 "Игорь Лабутин" Дальше в Твиттере набрел на ссылочку про новый кластер-интерфейс в .NET и в PCL.
6591.98 6598.86 "Игорь Лабутин" Он сейчас еще пока не вышел, ну в смысле он вроде как закоммичен уже, так что в следующем превью, думаю, что мы будем про это говорить.
6598.86 6612.18 "Игорь Лабутин" Сейчас пока кратенько скажу, что если вы когда-нибудь использовали DateTime.now или UTCnow, и вам было очень неудобно, что его нельзя замокать, чтобы в тестиках что-нибудь сделать с ним и так далее, то теперь будет можно.
6612.18 6633.58 "Игорь Лабутин" В .NET, на самом деле в .NET в библиотеке было много всяких разных, там iClock, iSystemTime и так далее, но они были нужны, они были внутренние, их было порядка десятка, и они были нужны для всяких внутренних нужд внутри самого PCL, то есть ими так, ну как-то широко они использовались, то есть DateTime.now все равно вот он статический, единственный.
6633.58 6634.58 "Анатолий Кулаков" Теперь у нас есть...
6634.58 6641.74 "Анатолий Кулаков" Ну погоди, это внутри Microsoft, и там было десяток, ну нужно понимать, что это нужно практически каждому проекту и в любом проекте есть еще своих десяток.
6641.74 6649.82 "Игорь Лабутин" Да, а еще есть какая-нибудь там нода Time, которая свой iClock реализовывала, ну выставляла наружу, ну в общем, каждый пытался это все заабстрактить.
6649.82 6655.82 "Игорь Лабутин" Теперь у нас есть абстракт от Microsoft, называется этот класс теперь TimeProvider.
6655.82 6657.82 "Игорь Лабутин" Это абстрактный класс.
6657.82 6659.82 "Анатолий Кулаков" Ну название, конечно, галеное.
6659.82 6671.58 "Игорь Лабутин" Да, по этому поводу уже по-моему по Microsoft прошлись все, все спрашивали, почему не назвали TimeProviderFactory, типа или там, AsiaTimeProvider что-нибудь, короче.
6671.58 6685.02 "Анатолий Кулаков" Ну и более того, смотри, если мы посмотрим на те заглушки, которые делали и ISP, и EntityFreeWork, и ISP Identity, там же тоже везде вся эта штука есть, и там называется нормально, там какой-нибудь iClock или iSystemClock они все называются.
6685.02 6687.78 "Анатолий Кулаков" То есть хорошие имена-то есть, люди понимают, какой
6687.78 6698.62 "Игорь Лабутин" провайдер. Если бы у этого класса был бы там PolyUtcNow и все, то его можно было бы назвать iClock, но только iClock нельзя, потому что это абстрактный класс, а не интерфейс.
6698.62 6704.66 "Игорь Лабутин" Но на самом деле это класс, у которого есть примерно 8 или 9 мемберов.
6704.66 6711.90 "Игорь Лабутин" Ну во-первых, у него есть статическое поле System, его же типа, ну то есть понятно, что писать TimeProvider.System, тут как бы вопросов нет.
6711.90 6719.50 "Игорь Лабутин" Статический Singleton, который как бы типа дефолтный, если тебе нужно куда-то подсунуть дефолтную реализацию, тут все хорошо.
6719.50 6724.78 "Анатолий Кулаков" Да ладно, после статических методов абстрактных в интерфейсе могли бы и в интерфейс засунуть.
6724.78 6739.26 "Игорь Лабутин" Не, они там тот самый, по-моему, то ли Taub, то ли кто-то пришел и объяснял, почему они используют классы, а не интерфейсы, потому что их потом проще расширять, там вот как раз и так далее, хотя дефолтные методы интерфейсов ровно для этого и делали, но почему-то они до сих пор все равно классы пишут.
6739.26 6740.26 "Игорь Лабутин" Ну ладно.
6740.26 6746.26 "Игорь Лабутин" Дальше там есть пропертиа UtcNow, тут как бы вопросов нет, UtcNow.
6746.26 6751.42 "Игорь Лабутин" Дальше есть пропертиа LocalNow, это то же самое, что DateTimeNow.
6751.42 6757.54 "Игорь Лабутин" На самом деле они не в DateTimeNow идут, они идут в DateTimeOffset.
6757.54 6759.14 "Игорь Лабутин" Now и UtcNow, соответственно.
6759.14 6762.46 "Анатолий Кулаков" И возвращать, соответственно, тоже не DateTime, а UtcNow.
6762.46 6764.38 "Игорь Лабутин" Да, DateTimeOffset, по-моему, да.
6764.38 6770.14 "Игорь Лабутин" Дальше есть LocalTimeZone, ну, который возвращает тебе типа TimeZone.
6770.14 6781.38 "Игорь Лабутин" Дальше есть GetTimeStamp и парное к нему пропертия TimeStampFrequency, это вот те самые монотонно возрастающие счетчики, частоты процессора, вот это все.
6781.38 6800.46 "Игорь Лабутин" Чтобы ты не заморачивался подсчетами, какой же длительности у тебя прошло между двумя событиями, то есть ты в начале событий вызвал GetTimeStamp, в конце вызвал GetTimeStamp, чтобы не извращаться с каким-то подсчетом через TimeStampFrequency, у тебя есть хелперная функция GetEllapsedTime, которая принимает два TimeStamp и возвращает TimeSpan.
6800.46 6805.74 "Игорь Лабутин" И в этом же интерфейсе есть функция CreateTimer, которая возвращает iTimer.
6805.74 6807.74 "Игорь Лабутин" А это зачем?
6807.74 6811.74 "Игорь Лабутин" Ну, мало ли тебе за одной таймерой нужно мокать.
6811.74 6814.74 "Анатолий Кулаков" Ну таймер в данном случае что это означает?
6814.74 6815.74 "Анатолий Кулаков" Он что умеет делать?
6815.74 6828.22 "Игорь Лабутин" В интерфейсе iTimer есть единственный метод, Change, куда можно передать новый TimeSpan с DueTimer и новый TimeSpan с Period, ну типа когда сработает первый раз и через сколько срабатывать потом.
6828.22 6829.74 "Игорь Лабутин" И все, больше в нем нет ничего.
6829.74 6834.66 "Анатолий Кулаков" Ну так сработать в нем это что, это Event или Action или кто это?
6834.66 6835.66 "Анатолий Кулаков" Не знаю.
6835.66 6836.66 "Анатолий Кулаков" Хорошо.
6836.66 6847.10 "Игорь Лабутин" Я не читал, там ISHI этот, для понимания, ISHI этот был создан где-то в 20-м году, там примерно 200+ комментариев и обсуждений, вот только сейчас его сделали.
6847.10 6848.10 "Игорь Лабутин" Я все не читал.
6848.10 6853.66 "Анатолий Кулаков" Ну я удивлен даже что так поздно, в 20-м году создан, мне казалось, потребность в нем стала намного раньше.
6853.66 6856.82 "Игорь Лабутин" Ну вот доберитесь руки сейчас дальше.
6856.82 6859.10 "Игорь Лабутин" Тут это еще не все.
6859.10 6865.66 "Игорь Лабутин" Смотри, у тебя же есть всякие разные штуки, ну например, не знаю, Task.Wait.
6865.66 6870.74 "Игорь Лабутин" Да, метод или там WaitAsync, куда ты можешь передать какое-нибудь там время и так далее.
6870.74 6873.58 "Игорь Лабутин" Так вот теперь туда можно передавать TimeProvider.
6873.58 6876.26 "Игорь Лабутин" А зачем я должен этого хотеть?
6876.26 6888.58 "Игорь Лабутин" Ну чтобы, например, у тебя, ты WaitAsync ты говоришь, ну то есть допустим у тебя какая-то бизнес логика считает, что нужно подождать там 5 секунд, так?
6888.58 6901.62 "Игорь Лабутин" Ты передаешь TimeProvider, ты можешь в TimeProvider сэмулировать что-то, типа вот у тебя следующий UTC, ну то есть тебе нужно, чтобы Task.Wait.Async изнутри вызвал твой TimeProvider замоканный, чтобы ты ему сказал, ага, вот прошло 5 секунд и у тебя Task.Wait.Async вернется после этого.
6901.62 6908.10 "Анатолий Кулаков" Ну подожди, я надеюсь, что Wait.Async не вызывает никакого DataTimeNow, ему это не нужно для того, чтобы подождать 5 секунд.
6908.10 6909.10 "Игорь Лабутин" А он CreateTimer как раз вызовет.
6909.10 6910.10 "Игорь Лабутин" CreateTimer это ладно.
6910.10 6913.58 "Игорь Лабутин" Ну вот, а он же есть в TimeProvider.
6913.58 6914.58 "Игорь Лабутин" Короче.
6914.58 6917.10 "Игорь Лабутин" Опять же, зачем ему это?
6917.10 6933.06 "Игорь Лабутин" Это, короче, монструозная штука, тогда пришел этот самый Марк Симон, накатал там коммент в GitHub экрана на полтора, значит, со словами, что это нарушает, по-моему, все принципы Solid, причислил аккуратно и показал, почему.
6933.06 6936.22 "Игорь Лабутин" Вот, и по неймингу там все прошлись, ну в общем.
6936.22 6938.38 "Анатолий Кулаков" Со ссылочками на его статьи уже готовые.
6938.38 6939.38 "Анатолий Кулаков" Очень спорная.
6939.38 6940.38 "Игорь Лабутин" В пятилетней давности, скорее всего.
6940.38 6974.46 "Игорь Лабутин" Очень спорная фича, но в общем непонятно, причем одна из тех фич, про которые Microsoft сказала, что они это забэкпортят, и эта фича будет работать в шестерке и в семерке в .NET в виде, ну, GetPacket Microsoft Extensions Primitives, то есть, ну, она, понятно, будет работать для, как называется, там, waitAsync ты не сможешь модифицировать, потому что он в BCL, да, в шестерке и в семерке, но там экстенджин методы будут, соответственно, правильные, которые принимают TimeProvider и вот это все.
6974.46 6977.02 "Игорь Лабутин" И эта штука TargetedNetStandard 2.0.
6977.02 6988.50 "Игорь Лабутин" В общем, там какая-то большая движуха вокруг этого Current System Time, их вместо простого iClocks, UTC, Now и просто Now, навернули какого-то монстра, посмотрим, во что это выльется.
6988.50 6993.18 "Анатолий Кулаков" Игорь, ты не заноси такие статейки к юрткам разным.
6993.18 6996.66 "Анатолий Кулаков" Тут как бы халеваров на два часа только по одной этой штуке, можно было бы разойтись.
6996.66 7009.26 "Игорь Лабутин" И я хочу подождать официального анонса, скорее всего они это упомянут в анонсе, вот, с каким-то, возможно, более человеческим объяснением, почему и как, но иначе надо просто читать эти 200+ комментариев.
7009.26 7015.66 "Анатолий Кулаков" Ну тогда ж халеваров не получится, тогда уже как бы все решено, здесь можно еще поспорить и высказать свое важное мнение.
7015.66 7019.62 "Игорь Лабутин" Ну мы еще успеем, я думаю, что давай дождемся анонса и посмотрим, что к тому времени скажут.
7019.62 7021.42 "Игорь Лабутин" Ну ладно, давайте.
7021.42 7052.02 "Игорь Лабутин" И последняя от меня небольшая новость, это вот буквально свеженькая, есть такой человек, Михаил Стряховский, это, насколько я понимаю, товарищ из команды тут который сделал штуку, называется Scyzoscope, это тутзи, на винформах, кстати, Targeted.net 7.0 при этом, но на винформах, которая позволяет сделать следующее, вы ей скармливаете ваш nativeout.image .net, а она вам раскладывает, сколько в нем, чего занимает место.
7052.02 7059.74 "Игорь Лабутин" То есть вот вы собрали вашу приложенку, запаблишили ее в nativeout.image, смотрите на него, и оно там получилось, не знаю, 50 мегабайт, вы такие, блин, что-то большое.
7059.74 7074.34 "Игорь Лабутин" Натравливаете эту узлу, она вам скажет, вот эти там методы типа namespace и сборки занимают столько-то места, она умеет делать диффы, то есть ей можно скармлить две версии, там, не знаю, вы что-нибудь поменяли в вашем коде, пересобрали, стало там, не знаю, не 50, а 70 мегабайт.
7074.34 7082.02 "Игорь Лабутин" Типа, кто добавил 20 мегабайт, вот вы можете натравить эту узлу, она покажет дифф между двумя сборками, что вам добавилось или наоборот убралось.
7082.02 7094.82 "Игорь Лабутин" И начиная, ну у него что-то странное написано на гитхабе, типа, начиная с .NET 8 превью 4, хотя еще даже 3 не вышло, но будет фича, которая будет показывать, а почему тот или иной тип включен в nativeout.
7094.82 7106.26 "Игорь Лабутин" Если вы помните, nativeout подразумевает trimming, то есть по идее он подразумевает, что все ненужные, неиспользуемые типы там сборки и так далее будут выкинуты, то есть если сборка оставлена, значит она кем-то используется.
7106.26 7110.62 "Игорь Лабутин" Вот туза сможет показывать, а кем же она используется по мнению, собственно, триммера.
7110.62 7112.62 "Анатолий Кулаков" Ну это полезно, это вообще круто.
7112.62 7114.34 "Игорь Лабутин" И почему она осталась.
7114.34 7119.94 "Игорь Лабутин" Работает это все на основе файликов с расширением mstat, которые генерируются во время билда, видимо.
7119.94 7136.78 "Игорь Лабутин" И вот как раз превью 4 для вот этого rootkos нужно, потому что только с этого превью, видимо, я не знаю, то ли они уже отбранчили 3 превью для будущего релиза, и поэтому он уже только в 4, его изменения попали, не знаю.
7136.78 7142.86 "Игорь Лабутин" Нужная инфа, она будет только вот в mstat файликах, только начиная с вот этой превьюшки, поэтому типа rootkos вот этого не будет в ближайшее время.
7142.86 7146.30 "Игорь Лабутин" Ну, в смысле вот, прямо сейчас, если вы возьмете версию на гитхабе.
7146.30 7151.54 "Игорь Лабутин" Ну, по крайней мере, посмотреть в вашем нейтифаут имидже, куда что уходит, уже полезно и можно прямо сейчас.
7151.54 7152.54 "Игорь Лабутин" Такие дела.
7152.54 7159.30 "Анатолий Кулаков" Да, классная штука, особенно вот визуализайзер того, чего происходит, это всегда прекрасно, всегда хорошо.
7159.30 7168.42 "Анатолий Кулаков" Так, а я наткнулся еще на интересную новую директиву компилятора, которая позволяет нам сделать компилятор еще жестче, еще бодрее.
7168.42 7181.22 "Анатолий Кулаков" И все началось с того, что один чемодан на гитхабе запостил интересную ищу, в том, что c#-код, который проверяет int ptr на null, он компилируется.
7181.22 7187.30 "Анатолий Кулаков" Хотя очевидно, что int ptr это структура и всегда этот результат будет возвращать false, этот if.
7187.30 7191.70 "Анатолий Кулаков" И почему-то он спросил, а почему компилятор вообще такое позволяет, почему он ошибки там не возвращает.
7191.70 7205.14 "Анатолий Кулаков" И один из микрософтовских разработчиков, Sam Horwell, сообщил, что в принципе можно заставить компилятора поругаться, главное передать ему специальный флаг, который называется feature strict.
7205.14 7212.90 "Анатолий Кулаков" Если вы этот флаг передадите, то он будет ругаться на вот такую ошибку, которая не имеет особого смысла, а также на много других.
7212.90 7227.18 "Анатолий Кулаков" И естественно этот флаг можно не просто передать компилятору, его можно указать в вашем csproj, достаточно сделать в csproj элемент, который называется feature, указывать туда просто-напросто строчку strict и компилятор поймет, что это вы именно его просили.
7227.18 7239.62 "Анатолий Кулаков" Кроме проверки int ptr на null, там есть много других интересных вещей, которые вы ожидаете увидеть от компилятора, но которые синтаксически правильные, компилятор не может вам на них выдать ошибку просто так.
7239.62 7248.42 "Анатолий Кулаков" Такие как например сделать log на null, тоже безумность, но компилятор это разрешает.
7248.42 7257.10 "Анатолий Кулаков" Как можно прикастить к статическому классу или проверить тип, потому что эта переменная содержит внутри себя тип статического класса.
7257.10 7262.94 "Анатолий Кулаков" Тоже компилятор сейчас это пропускает, как можно например от int вычесть enum, это тоже можно сделать.
7262.94 7267.82 "Анатолий Кулаков" В общем такие вещи, которые в подседенной жизни вы не должны хотеть, но компилятор их пропускает.
7267.82 7270.50 "Анатолий Кулаков" И вот эту штуку можно включить.
7270.50 7281.70 "Анатолий Кулаков" То есть теперь к нашим любимым thread warnings, warning level и прочим таким вещам добавляется еще один флажочек, это вот feature strict.
7281.70 7295.58 "Анатолий Кулаков" И на самом деле как сообщает автор и как я к нему присоединяюсь, мы надеемся, что вообще в компилятор эти включат все по дефолту или хотя бы с какой-то версии компилятор это включат по дефолту, чтобы естественно куча breaking changes у нас не появилась.
7295.58 7302.50 "Анатолий Кулаков" Но в какой-то конкретной версии уже можно было бы это сделать, чтобы не включать кучу разных флагов для того, чтобы проверять очевидные вещи.
7302.50 7309.26 "Анатолий Кулаков" Если вы тоже захотите заставить компилятор работать на себя чуть посильнее, то обратите внимание на этот флажочек.
7309.26 7315.10 "Анатолий Кулаков" И еще один интересный инструмент, и кейс прислал нам наш слушатель, за что ему огромное спасибо.
7315.10 7332.38 "Анатолий Кулаков" Кейс такой, он говорит, что у него часто бывают ситуации, в которых пользователь вбивает данные в поля ввода всяких формочек или еще где-то, и эти данные он туда не просто на клавиатуре набирает, а откуда-то копирует или вставляет.
7332.38 7338.26 "Анатолий Кулаков" Естественно все это вставляется с пробелами, с табами, в конце с какими-то символами еще непонятными, ненужными.
7338.26 7347.78 "Анатолий Кулаков" И очень часто разработчики не заботятся о том, чтобы каким-то образом провалидировать пользовательский ввод, как-то его облагородить, как-то его затриметь, и все это сохраняют в базу данных.
7347.78 7358.38 "Анатолий Кулаков" В базе данных это все потом размножается, начинается какой-то поиск происходить, начинают какие-то выводы делаться, и вот эти все пробелы, они все мешают.
7358.38 7368.46 "Анатолий Кулаков" В общем, в тех программах, где очень много пользовательского ввода, особенно когда это какая-то от пользователя копипаста из каких-то там документов внешних, это очень частая ситуация.
7368.46 7381.42 "Анатолий Кулаков" И вот настолько это часто, что автор загнался и написал библиотечку, которая позволяет автоматически триммить абсолютно все строки, которые к вам поступают в приложение во всех этих входящих модельках.
7381.42 7390.42 "Анатолий Кулаков" Более того, следуя самым новободным тенденциям, есть вариант с Source-генератором, который для вас сгенерит специальные функции, которые ваши модельки будут триммить.
7390.42 7404.22 "Анатолий Кулаков" В общем, если кто-то еще сталкивался с такой проблемой, что вам нужно триммить абсолютно все входящее, что у вас есть, и не загоняясь там на написание ручных триммеров каждому полю, вот обратите внимание на библиотечку, все ссылки будут у нас в шоу-ноутах.
7404.22 7411.50 "Игорь Лабутин" Ну, прекрасно, кратенько пробежались о разном, не очень кратенько, но действительно о очень разном.
7411.50 7420.98 "Игорь Лабутин" Вообще сегодня мы посмотрели на улучшение про поддержку контейнеров напрямую в дотнет SDK, причем это будет и в символическом SDK тоже.
7420.98 7428.78 "Игорь Лабутин" И заодно заглянули, что такое rootless контейнеры, но мы в эту тему еще раз углубимся чуть позднее в следующих выпусках.
7428.78 7439.62 "Игорь Лабутин" Посмотрели, что вам может прилететь со всякими вредоносными nuget-пакетами, как от этого защищаться на nuget.org и в других местах, откуда вы можете забирать пакеты.
7439.62 7443.98 "Игорь Лабутин" Глянули, как правильно хранить, солить и проверять пароли.
7443.98 7455.86 "Игорь Лабутин" Посмотрели на сортируемые UUID, выяснили, что их аж 8 версий теперь, и среди этого зоопарка нужно как-то уметь выбирать и понимать, в каких случаях вам нужно это все использовать.
7455.86 7471.06 "Игорь Лабутин" Обсудили, когда и как нужно писать логи, и как их лучше использовать, и как же было бы правильнее с некоторой точки зрения писать логи и метрики единообразные из приложения.
7471.06 7485.38 "Игорь Лабутин" И посмотрели на много-много разных мелких тем, и про новые тулы, и про новый интерфейс класс для текущего системного времени, и про эксперименты с WebAssembly, и про Trimming, и все остальное прочее.
7485.38 7486.38 "Игорь Лабутин" Примерно так.
7486.38 7488.54 "Игорь Лабутин" На этом, наверное, будем заканчивать.
7488.54 7489.74 "Анатолий Кулаков" Да, давай закрыляться.
7489.74 7494.30 "Анатолий Кулаков" Всем огромное спасибо, что слушали, шары, репост, колокольчики и все такое.
7494.30 7496.18 "Анатолий Кулаков" Вы знаете, как это все делается.
7496.18 7497.50 "Анатолий Кулаков" Всем благодарны.
7497.50 7498.50 "Анатолий Кулаков" До новых встреч.
7498.50 7499.50 "Анатолий Кулаков" Пока.
7499.50 7501.62 "Игорь Лабутин" Это был 69 выпуск радио.нет.
7501.62 7502.14 "Игорь Лабутин" Пока.
