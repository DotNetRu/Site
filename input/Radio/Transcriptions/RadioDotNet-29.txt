0.00 10.76 "Анатолий Кулаков" Здравствуйте, уважаемые слушатели, в эфире Radio.net, выпуск 29.
10.76 13.56 "Анатолий Кулаков" И в студии, как всегда, Анатолий Кулаков.
13.56 15.60 "Анатолий Кулаков" И Игорь Лабутин.
15.60 16.60 "Анатолий Кулаков" Всем привет.
16.60 22.16 "Анатолий Кулаков" И в сегодняшний выпуск я хотел бы начать с подведения итогов.
22.16 29.00 "Анатолий Кулаков" Мы объявляли конкурс на то, кто поможет нашему подкасту хорошо порекламироваться.
29.00 31.48 "Анатолий Кулаков" И для этого у нас были специальные призы.
31.48 36.20 "Анатолий Кулаков" Книги Джеффри Рихтера с его личным автографом.
36.20 40.76 "Анатолий Кулаков" И таких добровольцев, таких умельцев нашлось у нас два.
40.76 45.80 "Анатолий Кулаков" Это прежде всего Чебетов Николай и Нурмухамед Абдулин.
45.80 49.76 "Анатолий Кулаков" Спасибо большое, ребята, за то, что помогаете нашему подкасту продвигаться.
49.76 57.40 "Анатолий Кулаков" Они уже получили своего Рихтера, уже наслаждаются его личными книгами, его личными подписями.
57.40 62.68 "Анатолий Кулаков" И у нас еще осталось две книги, которые ждут своего автора.
62.68 65.88 "Анатолий Кулаков" Поэтому я пермаментно оставляю их при себе.
65.88 74.84 "Анатолий Кулаков" Но в принципе, если вы можете нам как-то помочь, то свяжитесь с нами, расскажите, что у вас есть.
74.84 81.16 "Анатолий Кулаков" И если ваша помощь будет весомой, ощутимой, то мы тоже с радостью подарим вам книжечки.
81.16 83.88 "Анатолий Кулаков" Вот книги есть, они ждут своих победителей.
83.88 91.28 "Анатолий Кулаков" И еще хотелось бы поздравить еще пару человек, без которых наш подкаст уже не полон.
91.28 93.60 "Анатолий Кулаков" Это прежде всего Александр и Сергей.
93.60 99.32 "Анатолий Кулаков" Люди, которые поддерживают нас уже не первый месяц, и за что им большое-большое спасибо.
99.32 101.04 "Игорь Лабутин" Вопрос такой.
101.04 104.28 "Игорь Лабутин" Мы поблагодарили Николая и Нурмухамеда.
104.28 107.32 "Игорь Лабутин" Вопрос, а что ж полезного было сделано?
107.32 108.84 "Игорь Лабутин" Где нас теперь можно найти?
108.84 113.24 "Анатолий Кулаков" Да, Николай получил свою заслуженную книгу не просто так.
113.24 124.16 "Анатолий Кулаков" Он не только распространял нас среди разных других awesome листов, таких как Discover.net и прочие-прочие.
124.16 127.68 "Анатолий Кулаков" Но сегодня я хотел бы вам рассказать о его собственном репозитории, которую он собрал.
127.68 132.16 "Анатолий Кулаков" Мне кажется, это самый огромный awesome лист, который я вообще видел, который только бывает.
132.16 138.60 "Анатолий Кулаков" Удивительно, что этот awesome лист собирается еще на русскоязычную IT.
138.60 141.36 "Анатолий Кулаков" Называется он Awesome Russian IT.
141.36 154.44 "Анатолий Кулаков" Если вы никогда не видели, то попробуйте хотя бы зайти и оценить, что вообще есть в России, насколько развита IT область, насколько развита IT пространство.
154.44 159.96 "Анатолий Кулаков" Я думаю, что у вас уйдет целый день, чтобы прочитать одни названия.
159.96 172.32 "Анатолий Кулаков" Кроме различных сайтов, блогов, есть отдельный список YouTube каналов и плейлистов со знаменитыми авторами, по тематикам или еще с чем-то.
172.32 175.20 "Анатолий Кулаков" И также есть огромнейший лист подкастов.
175.20 188.60 "Анатолий Кулаков" Если вдруг нашего подкаста вам почему-то мало, и вы хотите больше-больше чего-нибудь интересного, то в этом плейлисте, я думаю, собраны просто все подкасты русскоязычные, которые только есть по IT.
188.60 193.00 "Анатолий Кулаков" Я призываю вас зайти, посмотреть, ознакомиться.
193.00 197.20 "Анатолий Кулаков" Обязательно ставьте звездочки, лайки, шар, репост и как положено.
197.20 199.20 "Анатолий Кулаков" Работа проделана титаническая.
199.20 201.80 "Анатолий Кулаков" Я думаю, что автор заслужил благодарности.
201.80 206.72 "Игорь Лабутин" Да, действительно, я посмотрел огромный список русскоязычных активностей и митапы.
206.72 212.72 "Игорь Лабутин" Причем митапы не только в России, но и в других странах, где есть русскоязычная Докнайт комьюнити.
212.72 215.44 "Игорь Лабутин" Так что заходите, смотрите, участвуйте.
215.44 217.48 "Игорь Лабутин" Анатолий, ты звучишь по-другому сегодня.
217.48 222.12 "Анатолий Кулаков" Да, в принципе, и это не просто так.
222.12 233.84 "Анатолий Кулаков" Я звучу специально, потому что благодаря нашим патронам, благодаря всем тем, кто нас поддерживает, мы как раз приобрели новую покупку, то, ради чего все это затевалось.
233.84 242.48 "Анатолий Кулаков" У меня теперь новый микрофон, и я надеюсь, что теперь буду радовать вас более бархатистым и сглаженным голосом.
242.48 260.96 "Анатолий Кулаков" Поэтому, друзья, огромное спасибо всем тем, кто нас поддерживает, а всем тем, кто еще не знает, про что мы говорим, и может быть, хочет присоединиться к нашей дружной компании, людей, которые делают подкаст, делают его теплее, ламповее и участвуют непосредственно в создании программы.
260.96 265.48 "Анатолий Кулаков" Заходите на Patreon и Boosty и посмотрите, что мы можем вам предложить.
265.48 267.68 "Игорь Лабутин" Мы переходим непосредственно к Дотнету.
267.68 274.64 "Игорь Лабутин" У нас сегодня не так много, на самом деле, новостей, но мы начнем с интересного, с open-source и контрибьютов.
274.64 284.28 "Игорь Лабутин" Много раз уже говорили, что давайте, давайте, если вам интересно, поконтрибьтесь в само S/P/Net Core или в Дотнет, это сделать довольно легко.
284.28 292.64 "Игорь Лабутин" Там в репозиториях огромное количество issues, которые помечены лейблами help wanted или good first issue, и можно за них браться.
292.64 294.04 "Игорь Лабутин" Так вот теперь за них браться еще проще.
294.04 299.80 "Игорь Лабутин" S/P/Net Core команда сделала такую штуку, называется S/P/Dotnet Core Development Sprints.
299.80 315.80 "Игорь Лабутин" И если вы знакомы со Scrum, для вас спринт — это, наверное, что-то там идущее неделю или там 2-3 недели, у кого-как, то здесь это виртуальный ивент на один день, когда кто угодно может пойти и поконтрибьютить в S/P/Net Core.
315.80 321.32 "Игорь Лабутин" Казалось бы, ну, контрибьютить можно в любой день, неважно какой, но здесь есть одна тонкость.
321.32 335.64 "Игорь Лабутин" Вы, когда контрибьютите, есть рекомендации сначала, например, написать в issues, что вот я хочу взять эту issue, я там собираюсь сделать ее так-то, так-то, я там могу этим заняться или есть какие-то возражения.
335.64 342.68 "Игорь Лабутин" И у меня был такой опыт, и это иногда может занимать там несколько дней, а то и недель, чтобы ответить.
342.68 344.68 "Игорь Лабутин" К счастью, обычно отвечают быстро, но все-таки.
344.68 361.08 "Игорь Лабутин" Так вот теперь есть специальное время, это второй четверг каждого месяца, когда S/P/Net Core команда, она целенаправленно, так сказать, фокусируется на том, чтобы отвечать на такие issues, и как раз-таки именно в этот день, если вы придете контрибьютить, вы, скорее всего, получите максимальную поддержку от команды.
361.08 367.80 "Игорь Лабутин" То есть это такие однодневные спринты, которые помогут вам начать контрибьютить в свой любимый фреймворк.
367.80 374.48 "Анатолий Кулаков" Я считаю, это прекрасная возможность, в принципе, и идея, и инициатива, просто загляденье.
374.48 378.72 "Анатолий Кулаков" И в принципе, это, наверное, для команды довольно-таки существенные растраты.
378.72 387.20 "Анатолий Кулаков" Ты представляешь, вот каждый день, то есть один день в неделю выдавать на то, чтобы поддерживать таким образом сообщество, такое нехилая трата.
387.20 392.12 "Игорь Лабутин" Это все-таки не в неделю в месяц, второй четверг месяца, это все-таки раз в месяц.
392.12 401.12 "Игорь Лабутин" Но это не означает, что по всем остальным дням они не будут этого делать, поэтому, наверное, может быть, в среднем это тратится, не знаю, 2-3 дня в месяц, но это действительно довольно много.
401.12 406.20 "Игорь Лабутин" Плюс у них есть неплохая страничка, где описано, как подготовиться к такому дню.
406.20 413.28 "Игорь Лабутин" То есть вы не то, что вы проснулись утром в четверг и пошли, пойду-ка я поставлю последний дот над корс дк, чтобы что-нибудь поконтрибьютить.
413.28 428.28 "Игорь Лабутин" Нет, вы можете подготовиться заранее, все инструкции написаны и прийти в четверг уже, соответственно, подготовленным, с выбранным ишью и конкретно в этот день начать в этой мышь и общаться с авторами фреймворка, чтобы они помогли вам как-то продвинуться в деле его реализации.
428.28 432.48 "Анатолий Кулаков" Ну что ж, каждый день все лучше и лучше для того, чтобы начать контрибьютить в дотнет.
432.48 441.12 "Анатолий Кулаков" В принципе, отличная строчка будет в вашей резюмешке, поэтому попробуйте, почему нет, может вам понравится и вы пойдете дальше и дальше, и пойдете в микрософт.
441.12 445.20 "Анатолий Кулаков" Поэтому всем, кто давно хотел и почему-то сомневался, отличная новость.
445.20 465.60 "Игорь Лабутин" А еще, слегка связанное с этим, сейчас в титре есть такой тренд, недавно, несколько дней назад заметил, что появилось довольно много постов на тему вот, у какого-нибудь питоновского джанга 20 тысяч звездочек на гитхабе и так далее, или 30 тысяч звездочек, я не помню точно, а у дотнета на самом деле довольно мало.
465.60 473.52 "Игорь Лабутин" Поэтому сейчас в англоязычной части дотнета довольно активная движуха, называется это поставь звездочку своему любимому фреймворку в ASP.NET Core.
473.52 478.12 "Игорь Лабутин" Поэтому если вы пользуетесь ASP.NET Core, сходите на гитхаб, поставьте звездочку, команде будет приятно.
478.12 487.96 "Анатолий Кулаков" Да, друзья, и вообще не стесняйтесь ставить звездочки, шарить, рассказывать друзьям, репостить, писать хорошие комментарии и хвалебные обзывы к нашему подкасту в том числе.
487.96 502.80 "Анатолий Кулаков" То есть вот эта практика благодарности, теми проектами, которые вы пользуетесь, теми инструментами, которые вам помогают каждый день, она довольно-таки хорошо влияет на разработчиков, на всех тех контрибюторов, которые это все поддерживают, и на нашу платформу в целом.
502.80 514.48 "Анатолий Кулаков" Чем больше вокруг нашей платформы будет активностей, тем лучше в нее будут идти новички и видеть, что здесь происходит движуха, здесь происходят какие-то интересные вещи и прочее-прочее.
514.48 524.40 "Анатолий Кулаков" Поэтому не стесняйтесь никогда хвалить, лайкать, звездить те инструменты, те сайты, которыми вы пользуетесь, которые вам действительно нравятся.
524.40 528.44 "Игорь Лабутин" А мы пойдем дальше и давай поговорим все-таки что-нибудь поближе к коду.
528.44 529.44 "Игорь Лабутин" Data Time.
529.44 535.96 "Анатолий Кулаков" Да, ты когда-то из недавних выпусков затрагивал эту тему, но получилось так, что она прошла у нас как-то фоном.
535.96 545.68 "Анатолий Кулаков" Вот я решил раскопаться, потому что не каждый день в Дотнете появляются базовые структуры в Namespace и System, и тем более такие основополагающие.
545.68 547.96 "Анатолий Кулаков" Поэтому хотелось бы остановиться немножко подробнее.
547.96 555.56 "Анатолий Кулаков" Итак, действительно, у нас в Дотнете 6 будет новый тип, который называется Date Only и Time Only.
555.56 560.56 "Анатолий Кулаков" Это структуры, которые хранит первая только дату, а вторая только время.
560.56 573.76 "Анатолий Кулаков" Напомню, что у нас уже есть большое количество всяких классиков структур, которые позволяют работать с этим типом данных, но не так аккуратно, не так очевидно, как новые структуры.
573.76 576.36 "Анатолий Кулаков" Прежде всего это Date Time.
576.36 583.68 "Анатолий Кулаков" Обычно, когда вам нужно хранить только дату, наверное, используется он, а время пытаются каким-то образом игнорировать.
583.68 589.64 "Анатолий Кулаков" Это сопряжено с множеством костылей, там множество багов с таким подходом и так далее.
589.64 593.08 "Анатолий Кулаков" В общем, практика хотя есть, но она порочная.
593.08 595.40 "Анатолий Кулаков" То же самое, в принципе, хранить только время.
595.40 601.12 "Анатолий Кулаков" Для времени у нас еще, может быть, Time Span пригоден, но там точно такая же проблема.
601.12 608.64 "Анатолий Кулаков" Например, если вы к 23 часам в Time Span прибавите еще 3 часа, то получите один день и один час.
608.64 612.84 "Анатолий Кулаков" По идее, если вам нужно хранить только время, вы бы хотели получить просто один час.
612.84 615.88 "Анатолий Кулаков" То есть, такие разные мелочи, которые приходится учитывать.
615.88 618.56 "Анатолий Кулаков" Может быть, гордить своей враппера насчет этого.
618.56 626.32 "Анатолий Кулаков" И, наконец-то, в нашем любимом фреймворке завезут нативные структуры, которые позволят обработать подобные ситуации.
626.32 631.32 "Анатолий Кулаков" Там не будет ни Time Zones, ни Date/Time Kinds, ничего такого.
631.32 633.60 "Анатолий Кулаков" Просто только дата или только время.
633.60 638.84 "Анатолий Кулаков" Здесь интересно углубиться в историю, потому что был Visual Basic.
638.84 642.80 "Анатолий Кулаков" У Visual Basic был тип, который назывался Date.
642.80 646.72 "Анатолий Кулаков" Date, по правде, внутри этого типа содержалось дата и время.
646.72 654.76 "Анатолий Кулаков" После того, как люди осознали, что немножко вводят в заблуждение это название, они все-таки его переназвали в Date/Time.
654.76 659.92 "Анатолий Кулаков" И, соответственно, заодно в C#, в .NET фреймворке тоже был Date/Time.
659.92 662.12 "Анатолий Кулаков" И вот в Visual Basic он тоже появился.
662.12 671.70 "Анатолий Кулаков" Но для совместимости со старым кодом все-таки был изобретен кейворд Date, который, по сути, продолжал ссылаться на Date/Time.
671.70 679.08 "Анатолий Кулаков" И именно вот эта проблема стала очень остра, когда решились придумывать новые имена к нашим структурам.
679.08 682.48 "Анатолий Кулаков" Казалось бы, почему бы не назвать просто Date и просто Date/Time?
682.48 689.20 "Анатолий Кулаков" Вот одна из причин того, что это несовместимо с Visual Basic, а, как вы знаете, совместимость в наше все.
689.20 693.60 "Анатолий Кулаков" Поэтому решили назвать Date Only, дабы избежать всяких коллизий.
693.60 695.56 "Анатолий Кулаков" Но эта причина не единственная.
695.56 698.20 "Анатолий Кулаков" Были еще аргументы или, может, оправдания.
698.20 699.20 "Анатолий Кулаков" Давайте вместе подумаем.
699.20 707.44 "Анатолий Кулаков" Также, например, у Date/Time существующего есть свойство Date, который сейчас возвращает Date/Time.
707.44 710.80 "Анатолий Кулаков" Ну, просто отрезанный без времени, с зануленным временем.
710.80 717.84 "Анатолий Кулаков" Естественно, пользователь, который будет пользоваться новым API, захочет из Date тоже извлечь только дату.
717.84 722.32 "Анатолий Кулаков" Но в качестве результата он захочет видеть наш новый тип.
722.32 730.96 "Анатолий Кулаков" Но в текущем API мы не можем сделать так, чтобы свойство Date начало вдруг, ни с того ни с сего, вместо Date/Time возвращать наш новый тип Date.
730.96 734.80 "Анатолий Кулаков" Поэтому это имя тоже как-то не состыковывалось с существующим кодом.
734.80 741.24 "Анатолий Кулаков" В новом же API у нас будет свойство Date/Time/Date Only, которое будет возвращать тип Date Only.
741.24 742.76 "Анатолий Кулаков" И, в принципе, все счастливы.
742.76 748.48 "Анатолий Кулаков" Старый API работает, новый API тоже есть, и он по именам не конфликтует.
748.48 756.56 "Анатолий Кулаков" Еще популярное предложение было назвать Time Only как Time of Day.
756.56 760.88 "Анатолий Кулаков" Но, к сожалению, у Date/Time опять же есть свойство, которое называется Time of Day.
760.88 765.00 "Анатолий Кулаков" Сейчас он возвращает Time Span, и здесь тоже получается конфликт.
765.00 772.16 "Анатолий Кулаков" Но если мы назовем наш тип Time Only, то никакого конфликта не будет, мы можем добавлять новые свойства и радоваться жизни.
772.16 775.36 "Анатолий Кулаков" Теперь немножко подробнее по тому, как с ними работать.
775.36 777.20 "Анатолий Кулаков" Прежде всего, сериализация.
777.20 790.76 "Анатолий Кулаков" У этих типов нет стандартного атрибута Serialize, потому что этот атрибут задепликейчен в .NET Core и последующих версиях, и команда разработчиков ядра не собирается его использовать в будущем, поэтому нет там никакого атрибута.
790.76 805.60 "Анатолий Кулаков" И также эти типы не реализуют интерфейс XML Serializable или какое-то подобие для JSON, потому что тип находится в самых корневых сборках, и там нет еще никакого понятия ни о сериализации, ни о XML, ни о чем этом.
805.60 819.00 "Анатолий Кулаков" Ага, это значит, что все ваши сериализаторы должны и будут обязательно сделать кастомную обработку этих типов, то есть каким-то образом включить в базовый комплект, в базовую поставку обработку стандартных системных типов.
819.00 831.84 "Анатолий Кулаков" Это касается и JSON-сериализаторов, XML-сериализаторов, также тех вещей, которые ходят в базу данных, преобразуют ваши SQL-запросы и работают с датой и временем в виде линк-у-выражений.
831.84 835.96 "Анатолий Кулаков" Вот все это предстоит разработчикам библиотек пройти.
835.96 842.72 "Анатолий Кулаков" Для все-таки каких-то сложных сценариев авторы рекомендуют по-прежнему использовать нода Time.
842.72 848.48 "Анатолий Кулаков" Напомню, что нода Time – это очень крутая библиотека, разработанная Джоном Скитом.
848.48 851.44 "Анатолий Кулаков" Там пройдено огромное количество подводных камней.
851.44 864.04 "Анатолий Кулаков" Если вы вдруг никогда не сталкивались, вам эта тема интересна, погуглите видосик от Джона Скита про дату-время, он его очень много рассказывает, этот толк.
864.04 873.56 "Анатолий Кулаков" И в принципе там очень интересные такие вещи, которые, может быть, не всегда придут вам в голову, когда вы начинаете с ними работать.
873.56 876.76 "Анатолий Кулаков" Вот также нода Time очень богата на всякие типы.
876.76 888.28 "Анатолий Кулаков" Там можно, например, объявить тип, у которого отсутствует год, например, только 3 января или, может быть, март 2021 года без указания конкретного дня или, может быть, даже без указания месяца.
888.28 892.84 "Анатолий Кулаков" Все это там можно, намного гибче, чем в стандартных типах.
892.84 895.28 "Анатолий Кулаков" И в принципе они как-то стараются не конфликтовать.
895.28 901.24 "Анатолий Кулаков" Стандартные типы выдают какие-то базовые функциональности, а нода Time жжет уже по самому хардкору.
901.24 909.08 "Анатолий Кулаков" Если вы плотно работаете с датой-временем и для вас это какой-то даже бизнес-домен, то обязательно смотрите на нода Time.
909.08 910.72 "Анатолий Кулаков" Вот такие у нас типчики появятся.
910.72 911.72 "Игорь Лабутин" Хорошо.
911.72 912.72 "Игорь Лабутин" Еще больше конфьюжина.
912.72 917.20 "Игорь Лабутин" Надо же их будет еще как-то правильно сериализовать, как ты говоришь, сохранять базу.
917.20 918.68 "Игорь Лабутин" Еще вопрос интересный.
918.68 921.80 "Игорь Лабутин" Есть ли в JSON стандартный какой-нибудь метод их передачи?
921.80 926.88 "Игорь Лабутин" То есть для DateTime есть стандартный ISO, какой-то там номер 8.8 что-то там.
926.88 930.52 "Игорь Лабутин" А для DateOnly или TimeOnly еще надо подумать.
930.52 934.16 "Анатолий Кулаков" Да-да, словно снова, наверное, начнутся какие-то битвы форматов.
934.16 942.04 "Анатолий Кулаков" ISO всякие есть, но, опять же, пока мы с ними не сталкивались, они вообще приняты, их очень много и прочее-прочее.
942.04 945.60 "Игорь Лабутин" Ну ладно, посмотрим, как приживется новая штука.
945.60 947.08 "Игорь Лабутин" Может быть, действительно будет удобно.
947.08 948.08 "Игорь Лабутин" Пошли дальше.
948.08 952.96 "Игорь Лабутин" Небольшая новость про ASP.NET Core 6 и Identity Server.
952.96 970.08 "Игорь Лабутин" Как вы, может быть, знаете, начиная с какой-то версии NetCore 3, если я правильно помню, Microsoft начала поставлять Identity Server в качестве одного из кусочков, одного из темплейтов в .NET, чтобы при создании приложения у вас сразу был готовый Identity Server, который может выдавать токены.
970.08 978.84 "Игорь Лабутин" Ну да, удобно для всяких там SPA-приложений и так далее, чтобы можно было сразу завести готовый темплейтик и все работает "Hello World", так сказать.
978.84 984.84 "Игорь Лабутин" Но после того, как это было сделано, Identity Server, как мы тоже рассказывали несколько месяцев назад, поменял лицензию.
984.84 997.04 "Игорь Лабутин" И теперь, если вы хотите использовать его для коммерческого использования в компании, которая зарабатывает там от какого-то количества денег в год, то вы должны заплатить определенное количество денег этой самой автором Identity Server.
997.04 1008.36 "Игорь Лабутин" Казалось бы, конфликт, ну вроде как с свободно распространяемой SDK содержит такой вот Identity Server, и Microsoft выпустила новость, где разъяснила, что и как они собираются делать.
1008.36 1017.04 "Игорь Лабутин" То есть, во-первых, они не собираются, по крайней мере пока, писать какую-то альтернативу Identity Server вот прямо сейчас, чтобы этот NET6 поставлять уже не Identity Server.
1017.04 1031.96 "Игорь Лабутин" Во-вторых, в принципе, Microsoft считает, что они могли бы по дефолту поставлять, например, SDK со своей Major Active Directory, где вы можете 500 тысяч объектов иметь бесплатно.
1031.96 1034.16 "Игорь Лабутин" То есть это могут быть пользователи, группы, еще что-то.
1034.16 1036.56 "Игорь Лабутин" Ну, 500 тысяч, кажется, довольно много.
1036.56 1045.20 "Игорь Лабутин" Но они прекрасно понимают, что есть кастомеры, которым облака не очень интересны, либо решение должно быть полностью в их контуре.
1045.20 1063.32 "Игорь Лабутин" И поэтому решение на данный момент состоит в том, что в .NET 6 Identity Server продолжат поставляться в виде темплейта, но при старте вам будет вываливаться в консольки большое лицензионное предупреждение, что если вы это будете использовать дальше для коммерческой разработки, то как бы ознакомьтесь с условиями лицензирования Identity Server.
1063.32 1066.68 "Игорь Лабутин" Возможно, вам нужна будет нормальная полноценная лицензия.
1066.68 1073.44 "Игорь Лабутин" Напомню, что если вы делаете open-source продукт, то вам лицензия не нужна, Identity Server можно использовать и так.
1073.44 1075.64 "Анатолий Кулаков" Вообще, кажется, неплохая такая лазейка.
1075.64 1085.24 "Анатолий Кулаков" Сложишь какой-нибудь open-source открытый продуктик, делаешь его мега популярным, запихиваешь его в стандартные темплейты, а потом резко делаешь коммерческим.
1085.24 1096.80 "Анатолий Кулаков" Потому что вот этот экран, на котором выбираются всякие дефолтные проекты, он довольно-таки дорого стоит, и огромные большие компании не все могут себе позволить это попасть.
1096.80 1101.24 "Анатолий Кулаков" А здесь Identity Server, смотри, все-таки коммерческая компания, а как ловко и хитро промелькнул.
1101.24 1120.28 "Игорь Лабутин" Ну, он это сделал еще до того, как стал коммерческой компанией, и в каком-то смысле такую же роль занял Newtonsoft Jason, но просто сам соответственно автор успел идти в Microsoft, поэтому может быть не то, чтобы не успел, не смог, но ему уже не было необходимости основывать свою компанию и делать Newtonsoft Jason платный.
1120.28 1123.32 "Анатолий Кулаков" Да, Newtonsoft бесплатный, там ему все равно как бы.
1123.32 1127.24 "Анатолий Кулаков" А здесь вот реальная реклама коммерческого продукта получается из-за бесплатного.
1127.24 1133.80 "Игорь Лабутин" Ну, по сути же, продукт один из немногих, если не единственный на рынке именно такой, как Identity Server.
1133.80 1142.04 "Игорь Лабутин" Есть какие-то альтернативы, насколько я знаю, именно в дотнет мире, но они не очень, ну скажем так, не дотягивают по качеству до Identity Server.
1142.04 1153.00 "Игорь Лабутин" Другое дело, что есть, понятно, огромное количество таких продуктов на других платформах, и в принципе это вам не так, чтобы сильно принципиально, чтобы ваш Identity Server был именно на дотнете, в общем-то.
1153.00 1157.48 "Игорь Лабутин" В современном мире контейнеров, поднял контейнер с чем-нибудь рядышком, и пусть там хоть Java, хоть что-то.
1157.48 1162.60 "Игорь Лабутин" Но вам все равно нужна какая-то экспертиза, значит, другой платформе в другом языке, и в этом смысле это будет
1162.60 1164.60 "Анатолий Кулаков" минусом. Ну ладно, пойдем дальше.
1164.60 1168.80 "Анатолий Кулаков" Напрел на статеечку про Best Practice for Global Reference Types.
1168.80 1175.00 "Анатолий Кулаков" Хотелось бы поднять, потому что тема хорошая, но почему-то про нее там в последнее время никаких новостей не выходит.
1175.00 1186.72 "Анатолий Кулаков" А сейчас, в принципе, после того, как уже многие поработали с этим типом, с этими всеми типами, наверное, можно уже подвести какие-то итоги, вырабатывать Best Practice и продолжить нарабатывать какие-то техники.
1186.72 1187.72 "Анатолий Кулаков" Давай пробежимся.
1187.72 1203.60 "Анатолий Кулаков" Так, прежде всего, хотелось бы напомнить про небольшую историю, что начиная с C# 2, как только у нас появились Nullable generics, появилась возможность делать Value Types nullable, то есть теперь они могли содержать или null, или какое-то конкретное значение.
1203.60 1205.80 "Анатолий Кулаков" С Reference Types все было намного сложнее.
1205.80 1213.76 "Анатолий Кулаков" Они были nullable с самого начала, и поэтому не требовали каких-то специальных нововведений, структур или что-то в этом духе.
1213.76 1225.48 "Анатолий Кулаков" И здесь был какой-то диссонанс, потому что для того, чтобы сделать nullable Value Type, вам нужно было поставить вопросик возле его типа, и тогда компилятор все отлично понимал, раскладывал и начинал с этим работать.
1225.48 1235.44 "Анатолий Кулаков" Для Reference Types никакого вопросика не надо, потому что подразумевалось, что это само собой очевидно, все программисты должны читать и видеть, где nullable Reference Type, где Value Type.
1235.44 1243.00 "Анатолий Кулаков" И это немножко обескураживало пользователей, разработчиков и так далее.
1243.00 1250.28 "Анатолий Кулаков" Но в принципе, с той идеологией, которая теперь в Майкрософте, все начало немного исправляться.
1250.28 1253.56 "Анатолий Кулаков" Итак, Microsoft ввел nullable Reference Types.
1253.56 1275.04 "Анатолий Кулаков" И для того, чтобы привести все к единообразию, что все-таки не раскорочить язык куда-то непонятно, он решил придерживаться синтексиса, который уже давно был привычен дотнет-разработчикам, и решил, что теперь для того, чтобы обозначить Reference Type, как могущим принимать значение null, возле него тоже нужно поставить вопросик.
1275.04 1287.04 "Анатолий Кулаков" Но что же делать с тем кодом, который уже существует, с теми Reference Types, у которых вопросик не стоит, но с nullами они как-то общаются, непонятно.
1287.04 1295.80 "Анатолий Кулаков" Поэтому решили не включать nullable по дефолту, а решили по дефолту оставить поведение компиляторов и анализаторов, как и раньше.
1295.80 1305.40 "Анатолий Кулаков" Именно поэтому приходится напоминать всем, кто создает новые проекты, обязательно ставьте nullable enabled в true.
1305.40 1310.72 "Анатолий Кулаков" Это позволит вам очень сильно усовершенствовать и усилить вашу систему типов.
1310.72 1320.64 "Анатолий Кулаков" Именно когда вы ставите nullable enabled в true, то тогда включается как раз-таки вся мощь nullable Reference Types и начинается твориться магия.
1320.64 1323.28 "Анатолий Кулаков" Магия творится с помощью код анализов.
1323.28 1336.64 "Анатолий Кулаков" Наверное, это еще одна такая не очень хорошая штука, то есть не компилятор проверяет всю эту штуку, не компилятор проверяет все эти nullable, как, например, происходит с value-тайпами, а приходится городить рядом стоящие анализы.
1336.64 1339.24 "Анатолий Кулаков" Но это дает немножко больше возможностей.
1339.24 1359.56 "Анатолий Кулаков" Итак, прежде всего, как только вы включаете поддержку nullable в вашем проекте, это включается для каждого проекта отдельно, у вас начинают работать анализаторы специальные, которые на каждое несоответствие работы с переменными, nullable, неналобными, начинают генерировать ворнинги.
1359.56 1378.80 "Анатолий Кулаков" То есть, например, если у вас была налобная переменная, и вы пытаетесь из нее прямо считать значение без проверки того, что там внутри, или наоборот, пытаетесь присвоить null переменной, которая не должна позволять этого делать, у вас выдаются ворнинги, и, соответственно, анализаторы вас в этом предупреждают.
1378.80 1384.32 "Анатолий Кулаков" Для некоторых проектов это не очень большой плюс, потому что они и так завалены ворнингами.
1384.32 1389.08 "Анатолий Кулаков" От этого мы, наверное, возвращаемся к нашей best-practice, о которой мы говорили всегда.
1389.08 1400.40 "Анатолий Кулаков" Обязательно включайте trade warnings as error в ваших проектах и помогайте себе вычищать эти ворнинги, потому что компилятор просто так ругаться не будет.
1400.40 1403.28 "Анатолий Кулаков" Если он поругался, значит, есть проблемы в этом коде.
1403.28 1408.64 "Анатолий Кулаков" Лучше перестраховаться, переделать, пересмотреть, переформатировать и устранить все эти ворнинги.
1408.64 1415.28 "Анатолий Кулаков" А еще лучше выставляйте максимальный уровень ворнингов, их там несколько, и вычищайте все, что только можно.
1415.28 1429.88 "Анатолий Кулаков" То есть, если вы хотите писать на строго типизированном языке, гарантии типов которого гарантируется в момент компиляции и убирает кучу багов в момент компиляции, а не когда-то там у пользователя на продакшене, пользуйтесь этим инструментом, убирайте ворнинги.
1429.88 1453.12 "Анатолий Кулаков" И, соответственно, теперь, когда анализатор null value types выдаст вам какие-то подсказки и у вас включена опция trade warnings as error, вы не сможете скомпилировать свой проект и вы вынуждены будете поправить ваши типы, вы вынуждены будете правильно работать теперь с null reference types, что, опять же, сократит количество ошибок в вашем коде.
1453.12 1469.16 "Анатолий Кулаков" Эти анализаторы довольно-таки умные, то есть, если вы используете null variable переменную и при этом проверили ее на неравность null, то, соответственно, можете беспрепятственно обращаться к ее значению и анализаторы вам расскажут, что никаких проблем нет, да, обращайтесь.
1469.16 1472.24 "Анатолий Кулаков" Если же вы не проверили, то он попросит вас это сделать.
1472.24 1487.36 "Анатолий Кулаков" Но, к сожалению, попадаются очень сложные control flow, а в принципе иногда даже на самых легких анализаторы не всегда срабатывают, не всегда срабатывают правильно, корректно, так как вы рассчитываете и выдают часто всякую дичь.
1487.36 1500.16 "Анатолий Кулаков" Например, когда объект меняет свое состояние из нескольких контекстов, в многопоточной среде, из других методов или какой-то сложный control flow встречается в вашем приложении, то есть это бывает.
1500.16 1517.04 "Анатолий Кулаков" Поэтому нужно подсказывать анализатору с помощью специальных аннотаций, специальные annotation attributes, которые помогают анализаторам разобраться в том, что вы имели в виду, подсказать в каких моментах что возвращается.
1517.04 1526.60 "Анатолий Кулаков" Если вдруг вы сталкивались с пакетом JetBrains annotations, то, наверное, обязательно видели эти штуки, они там называются null, not null и прочее, прочее, прочее.
1526.60 1531.64 "Анатолий Кулаков" Такие же аналоги есть и у стандартного C#.
1531.64 1543.24 "Анатолий Кулаков" К сожалению, они не совместимы по именам, то есть было бы, наверное, идеально, если бы Microsoft просто забрал имена у JetBrains и мы бы существующий код получили бы размеченным уже атрибутами.
1543.24 1551.48 "Анатолий Кулаков" Но этого не произошло, поэтому переделываем, мучаемся и перекладываем все из одного имени в другое.
1551.48 1554.56 "Анатолий Кулаков" Хотелось бы немножко затронуть тему миграции старых проектов.
1554.56 1563.84 "Анатолий Кулаков" Безусловно, начинать новые проекты нужно с nullbar и reference types, но у всех у нас есть существующие проекты, что же делать с ними?
1563.84 1576.96 "Анатолий Кулаков" В существующих проектах, если вы включите подобную опцию, может быть очень много warning, опять же невозможно их все пофиксить за один раз, поэтому существует несколько подходов.
1576.96 1579.48 "Анатолий Кулаков" Самые распространенные два из них.
1579.48 1584.60 "Анатолий Кулаков" В этих подходах нам помогает специальная директива при процессоре, которая называется nullbar.
1584.60 1593.92 "Анатолий Кулаков" С помощью этой директивы вы можете как включить проверку nullbar reference types, так и выключить на определенном участке кода или даже всего файла.
1593.92 1596.16 "Анатолий Кулаков" Итак, два способа.
1596.16 1615.28 "Анатолий Кулаков" Во-первых, первый способ - это по умолчанию nullbar types выключены, то есть код у вас копилируется, как и раньше, и вы для каждого нового файлика вставляете директиву при процессоре вверху, которая называется nullbar enabled, и этот файлик начинается анализироваться.
1615.28 1623.28 "Анатолий Кулаков" Вы поправляете все warning, которые есть в этом файлике, директиву оставляете, переходите к следующему файлику, и так постепенно предлагается переводить все проекты.
1623.28 1628.24 "Анатолий Кулаков" Я такой способ пробовал, от себя могу отметить, что часто забиваешь на это.
1628.24 1640.60 "Анатолий Кулаков" То есть подразумевается, что когда ты редактируешь какой-то файлик, чинишь баги или добавляешь новую функциональность, ты идешь наверх, ставишь атрибутик и переделываешь заодно этот файлик, переделываешь его на nullable reference type.
1640.60 1649.12 "Анатолий Кулаков" Забывается ставить атрибуты, не хочется ставить иногда эти атрибуты, часто нет времени, часто это не соответствует тому, зачем ты сюда пришел и прочие нелепые отмазы.
1649.12 1651.92 "Анатолий Кулаков" Поэтому есть более агрессивный способ второй.
1651.92 1665.64 "Анатолий Кулаков" Вы включаете nullable reference type по дефолту для вашего проекта и с помощью специального скриптика проходитесь по всем файлам и автоматически вставляете в начало файла атрибут, который называется nullable disabled.
1665.64 1672.24 "Анатолий Кулаков" То есть вы выключаете проверку во всех ваших файлах, но при этом для всего проекта проверка включена.
1672.24 1673.44 "Анатолий Кулаков" Что это позволяет сделать?
1673.44 1681.32 "Анатолий Кулаков" Во-первых, все новые файлы, все новые классы, которые вы будете создавать, компилятор будет вас автоматически принуждать писать правильно, то есть nullable reference type.
1681.32 1693.12 "Анатолий Кулаков" А во-вторых, вы можете зайти в старый файл, убрать просто эту директиву, что делается довольно-таки легко, понятно, предсказуемо и получить кучу варнингов именно в этом файлике, который вы можете беспрепятственно отредактировать.
1693.12 1711.56 "Анатолий Кулаков" Такой способ показывает более лучшие результаты и поэтому может быть на каких-то небольших проектах или на тех проектах, в которых много разработчиков, которые готовы на это вкладываться, может дать лучший результат и гораздо быстрее перевести вас на правильные типы.
1711.56 1725.80 "Анатолий Кулаков" Так, стоит уточнить, что nullable reference type работают прекрасно, как только весь ваш код размечен этими типами и плюс все библиотеки, которые вы используете, именно ими размечены этими атрибутами, этими типами.
1725.80 1745.40 "Анатолий Кулаков" В частности, хочется, чтобы, конечно, прежде всего был размечен сам .NET Framework, потому что каждое приложение, как ни крути, будет использовать .NET Framework и по статистике в .NET Framework 5 размечен на 94%, что в принципе довольно-таки много и скорее всего хватит с головой каждому из нас.
1745.40 1750.28 "Анатолий Кулаков" В .NET 6 они планируют разметить, естественно, все 100% до конца.
1750.28 1755.04 "Анатолий Кулаков" Что касается третьесторонних библиотек, то тут все не так уж и хорошо.
1755.04 1763.04 "Анатолий Кулаков" Для третьесторонних библиотек, ну, хотелось бы хотя бы, чтобы они разметили все input и output из публичного API, которыми будут пользоваться другие библиотеки.
1763.04 1767.52 "Анатолий Кулаков" Но этот поезд идет довольно-таки медленно и причина этому есть.
1767.52 1778.00 "Анатолий Кулаков" Дело в том, что все вот эти атрибуты, которые помогают статическим анализаторам правильно анализировать сложные ситуации, они появились только в .NET стендарте 2.1.
1778.00 1783.44 "Анатолий Кулаков" К сожалению, большой фреймворк никакой не реализует .NET стендарт 2.1.
1783.44 1787.76 "Анатолий Кулаков" Самый последний стендарт, который там есть, это 2.0.
1787.76 1806.80 "Анатолий Кулаков" Поэтому как только авторы библиотек начинают активно использовать эти атрибуты, обмазывают все свои библиотеки атрибутами с null-reference-types, автоматически они прекращают поддерживать .NET фреймворк большой, что все еще большая-большая доля рынка и авторы на это идти не хотят.
1806.80 1810.32 "Анатолий Кулаков" Поэтому, к сожалению, этот поезд идет довольно-таки медленно.
1810.32 1815.12 "Игорь Лабутин" Справедливости ради есть, я видел техники, которые позволяют сделать следующее.
1815.12 1840.12 "Игорь Лабутин" Вы размечаете весь ваш код библиотеки вот этими атрибутами и если ваша библиотека multi-target build-on, то есть она таргетит и какой-то старый фреймворк или стендарт 2.0 и последний, например, .NET 5, то в .NET 5 эти атрибуты используются, ну как они есть, а для старого таргета вы просто у себя под fdef определяете эти атрибуты сами по себе, просто в вашей сборке лично.
1840.12 1844.88 "Игорь Лабутин" И таким образом компилятор счастлив, но атрибуты смысла никакого не несут тогда.
1844.88 1847.08 "Игорь Лабутин" Просто что засоряют немножко метаданные.
1847.08 1848.28 "Анатолий Кулаков" Именно так.
1848.28 1857.52 "Анатолий Кулаков" Кроме атрибутов, которые там называются allow null, disallow null, maybe null, появились еще парочка интересных моментов.
1857.52 1865.96 "Анатолий Кулаков" Во-первых, мы теперь можем указывать generic constraint, который называется not null, то есть вы можете в дженерике запросить какой-то тип, который обязательно должен быть ненулявельным.
1865.96 1872.68 "Анатолий Кулаков" К сожалению, constraint, который называется null, там нет, то есть наоборот вы запросить не можете.
1872.68 1888.76 "Анатолий Кулаков" Немножко, чтобы было понятнее, например, если есть у вас метод try_parse, который возвращает bool и получилось это парсить или нет, и какой-нибудь output значение, результат парсания, то обычно вот такой метод, он размечается как раз таки с помогательными атрибутами.
1888.76 1896.48 "Анатолий Кулаков" То есть вы должны сказать, что если метод вернул false, то в output параметре у вас скорее всего лежит null, и к этому аргументу обращаться не стоит.
1896.48 1904.00 "Анатолий Кулаков" Если же метод вернул true, то там 100% в output параметре не null, и тогда с этим аргументом можно безбоязненно работать.
1904.00 1909.48 "Анатолий Кулаков" И это подскажет анализаторам, что можно никаких лишних проверок не вставлять, все уже проверено за вас.
1909.48 1912.52 "Анатолий Кулаков" Вот такие подобные штуки помогают творить атрибуты.
1912.52 1917.40 "Анатолий Кулаков" Что касается сторонних библиотек, в частности Entity Framework.
1917.40 1924.32 "Анатолий Кулаков" Entity Framework довольно хорошо был проработан, чтобы соответствовать всяким этим not nullable type.
1924.32 1936.36 "Анатолий Кулаков" Например, если раньше для указания того, что колонка обязательная, ненулябельная в базе данных, требовался специальный атрибут, который назывался required, то вот теперь этого не нужно.
1936.36 1944.40 "Анатолий Кулаков" Если у вас тип ненулябельный, то колонка создаться без возможности ставить туда 0 в SQL, а если нулябельный, то наоборот.
1944.40 1952.60 "Анатолий Кулаков" Другой интересной особенностью является то, что Entity Framework по-особому работает с вашими энтитями.
1952.60 1965.92 "Анатолий Кулаков" То есть вы должны объявлять специальные свойства типа например dbset с вашей сущностью и эти свойства будут автоматически инициализированы Entity Framework в рантайме.
1965.92 1968.16 "Анатолий Кулаков" То есть компилятор ничего про них не знает.
1968.16 1974.60 "Анатолий Кулаков" Для компилятора это будет обычный класс, у которого есть getset и они никак не инициализируются в конструкторе.
1974.60 1978.48 "Анатолий Кулаков" Но при этом у них должен быть ненулябельный тип dbset.
1978.48 1982.84 "Анатолий Кулаков" Соответственно, любой нормальный анализатор на это будет ругаться.
1982.84 1985.24 "Анатолий Кулаков" И ростовиновские анализаторы тоже на это делают.
1985.24 1990.16 "Анатолий Кулаков" То есть они говорят, что у вас есть ненулябельный тип, который вы никак не инициализируете, у вас там 100% будет null.
1990.16 1993.52 "Анатолий Кулаков" Но мы-то знаем, что Entity Framework его проинициализирует в рантайме.
1993.52 1996.60 "Анатолий Кулаков" Для подобных случаев есть специальные костыли.
1996.60 1999.48 "Анатолий Кулаков" Вы можете поставить null с восхитительным знаком.
1999.48 2001.48 "Анатолий Кулаков" Это называется shipbank operator.
2001.48 2007.12 "Анатолий Кулаков" А он говорит, компилятор, заткнись, я лучше знаю, как правильно не лезть сюда.
2007.12 2011.16 "Анатолий Кулаков" Это ужасный костыль, старайтесь никогда так не делать.
2011.16 2018.28 "Анатолий Кулаков" То есть если возможно, в вашем коде не использовать никогда восхитительный знак, для того чтобы подавить вот эти референсы.
2018.28 2025.14 "Анатолий Кулаков" Старайтесь все-таки правильно писать код, использовать правильный шаблон на проектирование, для того чтобы обходить такие ситуации.
2025.14 2028.92 "Анатолий Кулаков" И давай подведем итоги.
2028.92 2033.52 "Анатолий Кулаков" Итак, прежде всего включайте nullble референс тайпы.
2033.52 2038.08 "Анатолий Кулаков" И чем раньше вы это сделаете в вашем проекте, тем вам же будет легче, тем вам же будет лучше.
2038.08 2041.04 "Анатолий Кулаков" Включайте опцию интерпретировать warning как ошибки.
2041.04 2045.12 "Анатолий Кулаков" Это вам поможет даже если вы не используете еще nullble референс тайпы.
2045.12 2048.72 "Анатолий Кулаков" Просто держать ваш код чистым и красивым.
2048.72 2052.88 "Анатолий Кулаков" Никогда не используйте оператор восхитительного знака.
2052.88 2055.88 "Анатолий Кулаков" В принципе это мой личный совет.
2055.88 2058.76 "Анатолий Кулаков" Это нигде не описывается, почему-то в блогах.
2058.76 2063.40 "Анатолий Кулаков" Там к нему относятся очень снисходительно, ну типа ну если надо, ну что же делать.
2063.40 2073.16 "Анатолий Кулаков" Я писал несколько проектов с использованием nullble референс тайпов на всех уровнях, полностью проекты покрытые.
2073.16 2082.44 "Анатолий Кулаков" И могу сказать, что вполне реально написать весь проект, весь solution не используя ни разу восхитительный знак.
2082.44 2092.80 "Анатолий Кулаков" Обильно используя атрибуты, обильно расставляя правильный workflow и обильно пользуясь best practices в паттернах проектирования.
2092.80 2106.16 "Анатолий Кулаков" Потому что как только вы видите, что вам хочется поставить восхитительный знак, это должен быть для вас красный флаг, что скорее всего вы неправильно использовали паттерны проектирования или где-то пропустили проверку или еще что-то.
2106.16 2113.44 "Анатолий Кулаков" Да, иногда приходилось ставить немножко левых проверок, бессмысленных для того, чтобы компилятор немножко ублажить.
2113.44 2115.88 "Анатолий Кулаков" Но эти случаи довольно-таки незначительные.
2115.88 2121.76 "Анатолий Кулаков" В большинстве случаев подобные места свидетельствуют о том, что вам нужно переделать ваш код правильно.
2121.76 2123.96 "Анатолий Кулаков" Одно единственное исключение есть.
2123.96 2133.52 "Анатолий Кулаков" Это не существует сейчас валидного способа рассказать компилятору, что в коллекции, которая у вас есть, вот там нет ненулябельных элементов.
2133.52 2138.92 "Анатолий Кулаков" Ни с помощью каких проверок, ни с помощью каких атрибутов вы это не проверите.
2138.92 2144.80 "Анатолий Кулаков" Поэтому здесь рекомендация создайте всего-навсего один единственный метод расширения для коллекции.
2144.80 2147.76 "Анатолий Кулаков" У меня он, например, называется not null items.
2147.76 2157.44 "Анатолий Кулаков" И там, в этом расширении, отфильтруйте все нулевые айтемы и вставьте там восклицательный знак, вернув коллекцию.
2157.44 2164.52 "Анатолий Кулаков" Таким образом, с помощью одного этого метода расширения вы покроете вот этот страшный корнер-кейс, который пока никак не решается.
2164.52 2170.68 "Анатолий Кулаков" То есть реально во всем Солюшене иметь только одну строчку с восклицательным знаком.
2170.68 2172.92 "Анатолий Кулаков" Все остальные можно сделать и так.
2172.92 2174.76 "Анатолий Кулаков" Попробуйте, я думаю вам понравится.
2174.76 2177.36 "Анатолий Кулаков" Это в принципе как еще одна интересная игра.
2177.36 2182.44 "Анатолий Кулаков" Как играть с компилятором так, чтобы он делал вам больше проверок, а ваш код был чище и понятнее.
2182.44 2187.64 "Анатолий Кулаков" Еще несколько открытий, которые передо мной встали, когда я начал использовать повсеместно на лоббл тайпы.
2187.64 2193.42 "Анатолий Кулаков" Прежде всего на всех границах приложения обычно типы нулябельные.
2193.42 2200.36 "Анатолий Кулаков" То есть, например, те DTO, к которым вы привыкли, у них по идее все референс тайпы должны быть нулябельными.
2200.36 2204.48 "Анатолий Кулаков" Потому что никто никогда вам не гарантирует, что там все правильно заполнится.
2204.48 2207.56 "Анатолий Кулаков" Также еще интересное место это децерализаторы.
2207.56 2216.60 "Анатолий Кулаков" Естественно в нормальных децерализаторах можно проставить какие-нибудь атрибуты, где сам децерализатор будет вам проверять, обязательно это поле или не обязательно.
2216.60 2218.40 "Анатолий Кулаков" Но все это тоже филькина грамота.
2218.40 2221.56 "Анатолий Кулаков" По идее вы должны децерализовать все поля нулябельными.
2221.56 2232.28 "Анатолий Кулаков" И если хотите убедиться, что там все проставлено как вам нужно, вставляйте нормальные бизнес проверки или запускайте нормальные фреймворки и они вам все это проверят.
2232.28 2234.28 "Анатолий Кулаков" То же самое касается API контроллеров.
2234.28 2244.96 "Анатолий Кулаков" У API контроллеров есть реквесты, в этих реквестах может быть те же самые поля, которые точно так же парсятся, децерализуются, может быть достаются из боди и так далее.
2244.96 2247.56 "Анатолий Кулаков" Там тоже огромное количество может прилетать на лобов.
2247.56 2253.44 "Анатолий Кулаков" Вы должны это не игнорировать, не подавлять там восклицательными знаками, а именно обрабатывать как нормальные входные параметры.
2253.44 2265.26 "Анатолий Кулаков" Знайте, что вас могут вызвать действительно с нулями и если вы хотите сделать по-настоящему приложение стабильное, не падающее, то вы обязаны все эти ситуации обработать.
2265.26 2269.08 "Игорь Лабутин" Кажется, получился вообще отличный гайд на тему того, как все это использовать.
2269.08 2271.48 "Игорь Лабутин" И действительно надо пробовать.
2271.48 2283.16 "Игорь Лабутин" Я, к сожалению, живу еще на достаточно старом фреймворке и не пробовал в каких-либо больших проектах, так скажем, для себя в маленьких тестовых проектах их использовал, но это не показательный пример.
2283.16 2289.28 "Игорь Лабутин" Для больших каких-то проектов я пока еще не успел попользоваться, пока мы не отказались от 4.7 фреймворка.
2289.28 2296.70 "Игорь Лабутин" Но, как я сказал, в принципе есть способы при мультитаргетинге начать это использовать.
2296.70 2302.82 "Игорь Лабутин" Мы потихонечку все это переводим в кухню нашу на дотнет 5, поэтому, скорее всего, сейчас начнем.
2302.82 2310.02 "Игорь Лабутин" И вот такой вот самарей на самом деле полезен, чтобы вспомнить, что это такое и вообще, да, начать правильно пользоваться.
2310.02 2321.62 "Анатолий Кулаков" Да, со своего опыта я могу сказать, что это действительно работает, т.е. код становится намного чище, понятнее, избавлен от багов и писать очень приятно.
2321.62 2331.74 "Анатолий Кулаков" Т.е. сразу убирается вот эти все входные проверки на not null, argument null exception, странные непонятные какие-то кетчи и прочие-прочие глупости.
2331.74 2342.58 "Анатолий Кулаков" Т.е. очень много убирается мусора, очень приятно становится читать код и я вообще стараюсь теперь везде, где только можно использовать эту практику, чего я вам, в принципе,
2342.58 2344.58 "Игорь Лабутин" советую. Супер.
2344.58 2349.54 "Игорь Лабутин" Дальше по плану у нас, как мы обещали в прошлый раз, это performance.
2349.54 2384.02 "Игорь Лабутин" У нас накопилось определенное количество статей по перформансу, которые мы планировали запихнуть все в один выпуск, но после прочтения всех этих статей показалось, что, наверное, в один выпуск это будет слишком много, поэтому в этот раз мы посмотрим на все, что можно рассказать про перформанс непосредственно в C# и дотнете, как платформе и языке, а в следующий раз уже затронем конкретный Entity Framework, где есть большая отличная серия статей на тему того, как оптимально использовать Entity Framework, чтобы получить хороший быстрый код при работе с базой данных.
2384.02 2393.62 "Игорь Лабутин" А начнем мы с статьи, она довольно-таки древняя, но тем не менее не теряет своей актуальности, дотнет не сильно в этом смысле меняется.
2393.62 2398.06 "Игорь Лабутин" Статья Майкла Шпильта про performance problems на C#.
2398.06 2409.10 "Игорь Лабутин" И она хороша тем, что она пропагандирует такой всесторонний подход к перформансу и начинается с того, что описывает, когда вообще надо заботиться о перформансе.
2409.10 2414.74 "Игорь Лабутин" Сюрприз, далеко не всегда надо заботиться о перформансе, как бы это ни грустно звучало, например, для меня.
2414.74 2434.38 "Игорь Лабутин" Мне очень нравится профайлить, вот это все делать, но это действительно надо делать не всегда, потому что, во-первых, вы можете оптимизировать не то, то есть вообще не код, который исполняется на каком-то критическом пути, а во-вторых, оптимизации могут давать очень небольшой выигрыш, но при этом сильно портить качество и читаемость кода.
2434.38 2446.06 "Игорь Лабутин" Под качеством я имею в виду там понятность и вот такой, может быть он продолжит работать без ошибок, но будет гораздо менее понятен и вероятность его изменения без внесения багов будет какая-то очень небольшая.
2446.06 2463.14 "Игорь Лабутин" При этом, конечно же, нужно все, что вы делаете, стараться замерять и беспокоиться о перформансе только тогда, когда измерения показывают, что все-таки надо что-то делать и по сути автор выделяет три сценария, когда вам точно нужно позаботиться о перформансе.
2463.14 2476.14 "Игорь Лабутин" Во-первых, если вы заранее знаете, что вы пишете какой-то high load, то есть если у вас в требованиях к вашему продукту написано, что у вас там будут миллионы пользователей одновременно, ну надо позаботиться о перформансе, но опять же только на хот-патхах.
2476.14 2479.34 "Игорь Лабутин" Второе, когда нужно заботиться о перформансе, это в алгоритмах.
2479.34 2511.18 "Игорь Лабутин" Если вы пишете какой-то алгоритм, то вы понятия не имеете, где этот алгоритм будет использоваться, особенно если он оформлен в виде библиотеки или плагинчика, но даже если в вашем основном продукте вы просто пишете какой-то алгоритм, то скорее всего, раз вы сильно задумываетесь об алгоритме, ну подумайте о его сложности, то самое обольшое, алгоритмическое, линейное, квадратичное и так далее, и возможно о том, сколько памяти он потребляет, то есть не надо там как-то очень наивно пытаться что-то делать, а латируя огромное количество памяти.
2511.18 2534.06 "Игорь Лабутин" Если же вы пишете библиотечку или плагин, который будут использоваться вообще непонятно кем, там публикуете NuGet на nuget.org, то тоже есть рекомендация от автора позаботиться о перфомансе, чтобы те, кто пользуют вашу библиотечку, не думали о том, ну не находили, что проблема с перфомансом именно в ней, а спокойно могли использовать ее в любых своих сценариях, в том числе, например, в highload серверах, которые пишут о них.
2534.06 2540.14 "Игорь Лабутин" Так что думайте, тщательно выбирайте, что же нужно оптимизировать и когда.
2540.14 2547.66 "Игорь Лабутин" Если же вдруг вы поняли, что все-таки надо, или подумали, что надо, то первая рекомендация это, конечно же, мерить.
2547.66 2550.14 "Игорь Лабутин" Мы уже много раз повторяем, повторим еще раз.
2550.14 2551.14 "Игорь Лабутин" Мерить нужно.
2551.14 2552.50 "Игорь Лабутин" Когда нужно мерить?
2552.50 2567.10 "Игорь Лабутин" Мерить нужно, в общем-то, всегда, то есть когда вы разрабатываете, всегда полезно посмотреть периодически, насколько у вас там все медленно или много памяти кушает, чтобы потом не получить сюрпризы на продакшене, когда у вас приложение будет быстро сжрать всю доступную память.
2567.10 2583.50 "Игорь Лабутин" А напоминаем, что в контейнерах на самом деле память ведет себя немножко не так, и garbage collector ведет себя немножко не так, как на вашей большой машине с кучей памяти, и приложение, которое прекрасно работает на вашей машине разработчик с 16 гигами памяти, внутри контейнера будет вести себя совсем по-другому.
2583.50 2584.98 "Игорь Лабутин" Так что смотрите внимательно.
2584.98 2588.10 "Игорь Лабутин" При измерениях нужно четко понимать, что мы мерим.
2588.10 2599.62 "Игорь Лабутин" То есть полезно иногда, я так иногда делаю, взять целиком продукт, погонять его чуть-чуть с каким-нибудь там профайлером, посмотреть вообще в принципе, что профайлер говорит про продукт, и не говорит ли он чего-то неожиданного для вас.
2599.62 2607.94 "Игорь Лабутин" То есть если вы например там много работаете с JSON, то наверное будет неудивительно, что профайлер будет говорить, что у вас много строчек аллоцируется.
2607.94 2616.30 "Игорь Лабутин" Но если вы работаете с байтами например, или какой-нибудь графикой, вам говорят, что аллоцируется много строк, это явно что-то не то.
2616.30 2617.30 "Игорь Лабутин" Вот.
2617.30 2625.78 "Игорь Лабутин" И смотреть нужно на CPU, понятное дело, всякие характеристики garbage collector, мы про это еще поговорим, на память в конце.
2625.78 2647.58 "Игорь Лабутин" А самое главное, по возможности попытайтесь, если вы уже на самом деле начали заниматься какой-то performance проблемой, или вы видите, что приложение ведет себя не совсем так, как вы ожидали, постарайтесь минимизировать приложение, то есть как всегда найдите минимально воспроизводимый пример, потому что это очень сильно поможет вам в будущем, когда вы будете измерять результаты ваших оптимизаций, если они будут.
2647.58 2649.42 "Игорь Лабутин" И последний момент, как мерить.
2649.42 2669.62 "Игорь Лабутин" Традиционно, естественно, все говорят, мерить надо в релиз моде, обязательно без подключенного отладчика, конечно же в окружении максимально близком к продакшену, и конечно же только после вормапа, когда уже весь код отджитился, а в новом дотнете у нас есть еще секонд тайр, через какое-то время код еще раз может отджититься и сделаться чуть более оптимальным.
2669.62 2676.54 "Игорь Лабутин" Поэтому сначала делаем так, чтобы приложение работало стабильно с точки зрения потребления ресурсов, а потом уже меряем.
2676.54 2686.46 "Анатолий Кулаков" Ну все это очень слишком сложно, и ты точно наверняка назвал не все, скорее всего там еще есть какие-то обязательные вещи, которые надо потанцевать и постучать.
2686.46 2687.46 "Игорь Лабутин" Конечно, конечно, конечно.
2687.46 2699.10 "Игорь Лабутин" Есть, во-первых, огромное количество, скажем так, специфических сценариев, то есть я могу сколько угодно говорить, что надо мерить только после вормапа, но если у вас проблемы на старте приложения, ну о чем речь?
2699.10 2702.98 "Игорь Лабутин" Надо мерить старт приложения и пытаться учитывать всякие джит-штуки и так далее.
2702.98 2710.30 "Игорь Лабутин" Во-вторых, еще есть момент, как ни странно, и автор, и я тоже, иногда мы меряем в дебаге.
2710.30 2723.14 "Игорь Лабутин" Это анти, так сказать, научно, но на самом деле даже такое позволяет иногда поймать какую-то очень суровую проблему с памятью, если там не сильно оптимально написан алгоритм, даже в дебаге вы это увидите.
2723.14 2726.42 "Игорь Лабутин" Так что иногда бывает полезно быстренько запустить, посмотреть.
2726.42 2741.70 "Анатолий Кулаков" А еще есть разные рантаймы, например, разные фреймворки, и если вы поправили, например, на своем девелоперском фреймворке баг или перформансы, то не факт, что на продакшеновском, где может быть версия фреймворка немножко другая, там все будет точно так же хорошо.
2741.70 2749.50 "Игорь Лабутин" А теперь у нас еще завезли новые процессоры, и то, что работает оптимально под Windows, у них будет работать оптимально под macOS на новом M1, или наоборот.
2749.50 2760.14 "Анатолий Кулаков" В общем, условий очень много, матрицы огромные, флажков очень много, и все их вы никогда хорошо не проверите ручками без помощи каких-нибудь сторонних инструментов.
2760.14 2772.50 "Игорь Лабутин" Да, поэтому про инструменты, опять же, они не помогут вам проверить автоматически на всех возможных процессорах, окружениях и так далее, но они, инструменты эти нужно тоже правильно выбирать в зависимости от вашей задачи.
2772.50 2778.86 "Игорь Лабутин" Если у вас тормозят запросы в вашем ASP.NET Core приложении, наверное, использовать Benchmark.NET не самая лучшая идея.
2778.86 2793.18 "Игорь Лабутин" Поэтому Benchmark.NET, например, это отличная библиотека, которую обязательно нужно использовать, но только если вы занимаетесь какими-то микрооптимизациями на уровне, там, дали секунды или еще меньше времени выполнения.
2793.18 2806.90 "Игорь Лабутин" Потому что Benchmark.NET вам все прогреет, все сделает, запустит много-много-много тысяч, миллионов раз, чтобы увидеть все нужные распределения того, как у вас все работает, но это требует, чтобы ваш тестовый код работал все-таки достаточно быстро.
2806.90 2828.06 "Игорь Лабутин" Если же у вас есть нормально работающее приложение, большое, и вам нужно померить на каком-то большом промежутке времени, то это уже просто обычный профайлер, dottrace, ints, visual studio, perfew, что угодно, который может работать довольно долго, собирать снапшоты приложения до-после в какие-то моменты времени, или следить за ним во время работы и смотреть, что получается.
2828.06 2842.70 "Игорь Лабутин" Иногда полезно, на самом деле, померить даже в коде, у нас было несколько примеров, когда мы просто в коде использовали stopwatch и писали в логи какие-то критические операции по времени, и можно потом по логам все это погребать, грубо говоря, и найти время выполнения.
2842.70 2855.06 "Анатолий Кулаков" Главное, не используйте для этой цели dateTime, потому что иначе вы можете получить такую погрешность, о которой ваш настоящий алгоритм даже и не мечтал, только на том, чтобы доставать из dateTime now.
2855.06 2865.14 "Игорь Лабутин" Потому что now еще будет пытаться вам переводить UTC в вашу локальную таймзону, но и UTC now тоже плохо.
2865.14 2872.94 "Игорь Лабутин" Так, продолжим про безпрактисы, о том и все говорили, напоминая про measure, когда измерять, когда, что, зачем и как.
2872.94 2885.50 "Игорь Лабутин" Дальше автор говорит то, что я уже сказал, используйте performance profiler хотя бы периодически, но потому что вы никогда не знаете, где вы на самом деле слегка ошиблись и забыли какую-то лямбадочку, которая вам нагрелит гигабайты мемориального трафика.
2885.50 2904.50 "Анатолий Кулаков" А вот здесь вполне уместно будет уменуть шикарную тулзу от JetBrains, которая позволяет вам не использовать performance profiler периодически, а performance profiler у вас сам будет всегда использоваться при любом запуске вашего приложения и в бэкграунде все чекать, никак не влиять на ваш performance и выдавать прекрасные отчетники.
2904.50 2905.50 "Анатолий Кулаков" Да.
2905.50 2907.34 "Анатолий Кулаков" Как тебе такой, Илон Маск?
2907.34 2922.94 "Игорь Лабутин" Это правда, но на самом деле даже в Visual Studio по дефолту, в данной конфигурации сейчас справа открывается вот это окошечко перформанса, где в принципе количество garbage collection и график расхода памяти вы вполне увидите.
2922.94 2930.38 "Игорь Лабутин" Если он куда-то летит в космос наверх или из заметок garbage collector вы уже не видите самого графика, ну наверное что-то не то.
2930.38 2945.74 "Анатолий Кулаков" Если вы боитесь больших и сложных performance profilers сейчас еще почему-то, хотя они совсем не сложные, вот можете обратиться к парочке вот таких вот подобных инструментов, которые вам дадут в очень легкой доступной форме основные показатели, от которых вы уже можете отталкиваться дальше.
2945.74 2946.74 "Игорь Лабутин" Да.
2946.74 2961.70 "Игорь Лабутин" Когда вы вообще думаете про то, что надо бы что-то может померить или про то, как вообще писать код, как потом может быть надо что-то оптимизировать, есть несколько стандартных вещей в дотнете, на которые нужно смотреть и на которые нужно знать.
2961.70 2963.66 "Игорь Лабутин" Во-первых, это конечно же garbage collector.
2963.66 2979.90 "Игорь Лабутин" Это практически по некоторым, согласно некоторым авторам, garbage collector это практически единственный такой источник проблем и решений вокруг перформанса в дотнете, то есть примерно 90% проблем решается, мне кажется, чем-то вокруг работы с памятью.
2979.90 2984.26 "Игорь Лабутин" Если бы, конечно, не написали какой-то совсем уж кривой алгоритм, который живет в полной не в себя.
2984.26 2997.98 "Игорь Лабутин" То есть тут смотрите сколько времени проводится в garbage collector, есть для этого специальные performance каунтеры и смотрите сколько у вас коллекций второго поколения, сколько собирается мусора во втором поколении.
2997.98 3001.86 "Игорь Лабутин" Это два таких самых базовых признаков, про которые нужно смотреть.
3001.86 3011.14 "Игорь Лабутин" Если вам интересно детально узнать на что смотреть в garbage collector, выпуска три назад мы разбирали статью Маони про то, как правильно вообще мониторить garbage collector.
3011.14 3016.82 "Игорь Лабутин" Там она привела огромное количество примеров, что делать и на что смотреть, на какие показатели, в каких сценариях.
3016.82 3021.38 "Игорь Лабутин" Ну а так, в целом, при разговоре про память всегда есть две стандартных рекомендации.
3021.38 3024.90 "Игорь Лабутин" Меньше аллоцируйте, а если аллоцируете, убеждайтесь, что объекты быстро помирают.
3024.90 3027.90 "Игорь Лабутин" Рекомендации простые, добиться их иногда бывает сложновато.
3027.90 3062.18 "Игорь Лабутин" В современном .NET еще важная штука это JIT, потому что во-первых он становится умнее все время, а во-вторых как я сказал JIT у нас теперь многоэтапный, назовем это так, и первая версия кода может быть не совсем оптимальной, если JIT видит, что ваш код, ваши конкретные функции выполняются очень часто, он может решить перекомпилить их чуть-чуть помедленно, потратить еще немножко времени, перекомпилить их еще раз с учетом того профиля выполнения, который он на них видит, и сделать более оптимальную версию этих функций и подменить.
3062.18 3069.90 "Игорь Лабутин" Так что не удивляйтесь, если во время вы измеряете приложение и у вас какие-то совершенно разные результаты получаются раз от раза.
3069.90 3079.22 "Игорь Лабутин" А с третьей стороны, если вы рассматриваете какие-то проблемы стартапа, то может быть вам нужно задуматься о технологиях типа Ready to Run, Ahead of Time Compilation и так далее.
3079.22 3084.58 "Анатолий Кулаков" - А как же, каким образом всякие бичмарк.нет будут справляться с вот этим многоэтапным JIT?
3084.58 3088.22 "Анатолий Кулаков" Ведь он может быть в зависимости от профиля проснуться не пойми когда.
3088.22 3097.50 "Игорь Лабутин" - Ну, во-первых, его можно выключить, есть специальное переменное окружение, которое позволяет его выключить, но я не уверен, как работает бичмарк.нет, надо посмотреть, не помню.
3097.50 3102.62 "Игорь Лабутин" Наверняка Андрей и Адам что-нибудь придумали, но это действительно может быть проблемой.
3102.62 3111.66 "Игорь Лабутин" Если вам прям очень хочется закопаться в .NET Performance, то конечно нужно изучить поподробнее эту тему и поизучать более low-level тулы.
3111.66 3118.86 "Игорь Лабутин" То есть мы уже упоминали Performance Counter, но это не сказать, что прям low-level тул, хотя там довольно много всего экспозится наружу.
3118.86 3123.50 "Игорь Лабутин" Вам нужно поразбираться, что такое ZW - Event Tracing for Windows.
3123.50 3129.90 "Игорь Лабутин" На основе него работает на самом деле большинство пропайлеров и таких, скажем, тулов для анализа типа PerfView.
3129.90 3135.50 "Игорь Лабутин" А если вы на .NET Core и хотите про кроссплатформенность подумать, то тогда нужно обязательно смотреть на .NET Counters.
3135.50 3140.22 "Игорь Лабутин" Это замена PerfCounter, .NET Trace - это замена Event Tracing for Windows.
3140.22 3144.54 "Игорь Лабутин" Возможно они когда-то станут основой для линуксовых и других пропайлеров.
3144.54 3150.82 "Игорь Лабутин" Пока это просто command-line тулы, которые позволяют смотреть на ваше приложение со стороны, но непосредственно на тех платформах.
3150.82 3152.94 "Игорь Лабутин" Так, пошли дальше по беспрактисам.
3152.94 3155.34 "Игорь Лабутин" Так, так, так, так, так, где я нахожусь?
3155.34 3156.34 "Игорь Лабутин" О, вот я где.
3156.34 3159.34 "Игорь Лабутин" Значит, по беспрактисам дальше пошли такие.
3159.34 3164.38 "Игорь Лабутин" Резкий скачок от низкоуровневым к сильно высокоуровневым со словами "используйте кэширование".
3164.38 3168.18 "Игорь Лабутин" И это очень такой противоречивый совет.
3168.18 3179.30 "Игорь Лабутин" С одной стороны, действительно правильное кэширование вам сильно поможет в работе с памятью, потому что вместо того, чтобы выделять объект и тратить потом время на его сборку мусора, вы просто переиспользуете одни и те же объекты.
3179.30 3185.58 "Игорь Лабутин" Но, как известно, это одна из самых главных проблем разработчиков - это именование переменных и инвалидация кэша.
3185.58 3193.90 "Игорь Лабутин" Поэтому если вы используете кэш, то есть вероятность, что ваш кэш будет расти безразмерно, там будут лежать объекты, которые уже больше никогда не используются и не будут использованы.
3193.90 3196.18 "Игорь Лабутин" И это тоже проблема получается с памятью.
3196.18 3198.34 "Игорь Лабутин" Так что будьте очень аккуратны с кэшированием.
3198.34 3203.38 "Анатолий Кулаков" Да, я могу посоветовать обратить внимание на стандартный класс, который называется MemoryCache.
3203.38 3218.86 "Анатолий Кулаков" Он хуже, чем есть какие-то специализированные сторонние тулзы, но во-первых, он во фреймворке, а во-вторых, он точно лучше, чем ваш какой-нибудь concurrent dictionary, потому что у него есть огромное количество ручек по тому, когда его почистить, по отслеживанию памяти.
3218.86 3225.54 "Анатолий Кулаков" И плюс у него уже сразу встроены performance-каунтеры, которые позволяют вам следить за вашими кэшами прямо на дешбордах.
3225.54 3233.02 "Игорь Лабутин" А еще у него API построена таким образом, что вы просто не сможете запихнуть туда item и не указать, когда же его оттуда удалить.
3233.02 3240.70 "Игорь Лабутин" То есть там, по-моему, почти все функции, которые кладут в кэш, обязывают тебя добавить аргумент, когда же ему заэкспириться.
3240.70 3241.70 "Игорь Лабутин" И это хорошо.
3241.70 3243.74 "Игорь Лабутин" Дальше про UI мысль.
3243.74 3251.58 "Игорь Лабутин" Тоже довольно популярная, она много где тиражируется про то, что отклик для пользователя комфортный, это где-то 100-200 мс.
3251.58 3262.26 "Игорь Лабутин" Секунда это в принципе максимум, который готов пережить пользователь, поэтому если у вас что-то делается на UI дольше, чем это время, это показать прогресс бар и какую-то движуху в UI.
3262.26 3266.86 "Игорь Лабутин" Старайтесь ничего не делать на UI 3D, чтобы он не замораживался, потому что приложение выглядит повисшим.
3266.86 3282.98 "Игорь Лабутин" Ну и если у вас есть что-то, что не требует непосредственно отображения в UI, то есть какая-то работа, которую можно делать в граунде и просто потом пользоваться и сходить, посмотреть, что там вообще как, то используйте всякие очереди, работы, какие-нибудь background-worker и так далее.
3282.98 3289.94 "Игорь Лабутин" Ну не знаю, там в пайлике в браузере донлоудится, он куда-то там свалился в download-менеджер, что-то там где-то в бэкграунде работает.
3289.94 3291.66 "Игорь Лабутин" Когда надо, вы сходите, посмотрите.
3291.66 3294.26 "Игорь Лабутин" Хороший пример того, как не надо фризить UI.
3294.26 3297.66 "Игорь Лабутин" Дальше опять мы возвращаемся к hotpath.
3297.66 3301.26 "Игорь Лабутин" Рекомендации автора идут про то, что смотрите только на critical path.
3301.26 3308.90 "Игорь Лабутин" Если у вас есть hotpath, то на нем можно применять микрооптимизацию, если вы понимаете, что это то, что принесет вам большой boost в производительности.
3308.90 3318.42 "Игорь Лабутин" И тут можно уже разбирать более детальные техники, мы на них посмотрим чуть пояснее, про всякие там не используйте link queue, используйте stream builder, это мы там чуть дальше посмотрим.
3318.42 3326.70 "Игорь Лабутин" И последняя мысль автора это про то, что помните об основных, как скажем, источниках проблем с перфомансом.
3326.70 3332.70 "Игорь Лабутин" Это не только там памяти, CPU, как мы говорили, да, или неоптимальный алгоритм, а именно то, что вы используете в коде.
3332.70 3333.70 "Игорь Лабутин" Во-первых, это финалайзеры.
3333.70 3343.34 "Игорь Лабутин" Любой объект, у которого есть финалайзер, никогда не будет собран в нулевом поколении, просто потому что так устроены финалайзеры в дотнете, объект точно доживет хотя бы до первого поколения.
3343.34 3346.82 "Анатолий Кулаков" Еще нужно учитывать, что финалайзеры вам практически никогда не нужны.
3346.82 3354.02 "Анатолий Кулаков" То есть финалайзер нужен только для того, когда у вас есть неуправляемые ресурсы и вы хотите его специально освободить, чтобы ничего не потерять.
3354.02 3357.52 "Анатолий Кулаков" Я с такими проектами не сталкивался уже много-много лет.
3357.52 3363.02 "Анатолий Кулаков" Поэтому если вы используете финалайзер для чего-то, то подумайте, правильно ли вы делаете, правильно ли вы шаблон применяете.
3363.02 3375.46 "Игорь Лабутин" Да, и во многих местах вам может встретиться шаблон например правильного диспоуза, когда там есть всякие suppress finalization, диспоуз с boolean, который вызывается из финалайзера и из диспоуза.
3375.46 3380.02 "Игорь Лабутин" Вот это все нужно действительно только если у вас прям unmanaged ресурсы и так далее.
3380.02 3386.34 "Игорь Лабутин" А в этом случае проще использовать какой-нибудь safe handle и наследоваться от него, чем писать вручную всю эту протянку.
3386.34 3391.58 "Игорь Лабутин" Обычно стандартных методов диспоуза достаточно для обычного managed dispose.
3391.58 3393.70 "Игорь Лабутин" Дальше, как ни странно, выкидывание исключений.
3393.70 3395.42 "Игорь Лабутин" Ну почему не странно?
3395.42 3400.98 "Игорь Лабутин" Выкидывание исключений - это прерывание того процесса исполнения, который возможно предугадал процессор.
3400.98 3404.50 "Игорь Лабутин" И соответственно это сразу некоторые проблемы для производительности.
3404.50 3412.46 "Игорь Лабутин" Поэтому не пытайтесь вызывать метод parse, ловить исключения в формат exception и понимать, что ага, там было не число.
3412.46 3418.18 "Игорь Лабутин" В строке используйте метод типа try parse, они для этого придуманы, чтобы не кидать исключений в таких случаях.
3418.18 3423.78 "Игорь Лабутин" Понятно, что всякие reflection и динамики тоже явно не способствуют перформансу.
3423.78 3432.30 "Игорь Лабутин" Так что если у вас есть какие-то места, где вам нужен перформанс, но при этом вам не обойтись без reflection, подумайте об агрессивном кэшировании того, что вы нашли с reflection.
3432.30 3438.46 "Игорь Лабутин" Складывайте в словарики, генерите код на лету и так далее, чтобы только не использовать reflection.
3438.46 3444.46 "Анатолий Кулаков" Ну а также большинство современной reflection легко заменяется с помощью source-генераторов, тоже рассмотрите эту возможность.
3444.46 3445.46 "Игорь Лабутин" Да, это правда.
3445.46 3447.50 "Игорь Лабутин" Так что смотрите туда.
3447.50 3460.46 "Игорь Лабутин" Ну и естественно, как только вы трогаете любую синхронизацию, то есть локи, силафоры, венты, тоже нужно очень тщательно следить и думать, потому что это скорее всего вряд ли как-то соотносится с сильным перформант-кодом.
3460.46 3462.34 "Игорь Лабутин" Это была статья Майкла Шпильта.
3462.34 3465.94 "Игорь Лабутин" В принципе она такая довольно неплохая обзорная на тему перформанса.
3465.94 3481.70 "Игорь Лабутин" Но дальше еще была серия статей, это вообще очень старая серия статей 2014 года, мне кажется, от Джедбрэйнса на тему того, что может пойти не так с точки зрения перформанса, если вы пишете C# и используете какие-то конструкции неоптимально.
3481.70 3485.18 "Игорь Лабутин" Прошло 7 лет, с моей точки зрения статья до сих пор актуальна.
3485.18 3486.18 "Игорь Лабутин" Что может пойти не так?
3486.18 3490.50 "Игорь Лабутин" У вас может случиться боксинг, когда ваши вэлютипы попали на кучу.
3490.50 3498.50 "Игорь Лабутин" Они туда будут попадать в любом случае, больше-меньше, но если туда их попадает огромное количество, то это уже становится проблемой.
3498.50 3499.50 "Игорь Лабутин" Я с таким сталкивался.
3499.50 3510.66 "Игорь Лабутин" Чтобы такое найти, вы берете любой профайлер, который позволяет вам смотреть содержимое кучи и пытаетесь найти в куче объекты типа int, double, ну или, например, вашу структуру каких-нибудь, которую вы используете в коде.
3510.66 3522.14 "Игорь Лабутин" И если их там оказывается сильно больше, чем вы ожидаете, или они там, например, были созданы, некоторые профайлеры позволяют смотреть, каким методом был аллоцирован, какой call stack был в момент, когда аллоцировали тот или иной объект.
3522.14 3526.82 "Игорь Лабутин" Если они аллоцируются в каких-то странных мест, то это повод разобраться в этих местах.
3526.82 3532.90 "Анатолий Кулаков" Не могу не порекомендовать плагин Crash Arp Room, который называется Hippolocator, по-моему.
3532.90 3540.10 "Анатолий Кулаков" Его вся сущность заключается в том, что он прямо в коде вам подсвечивает все места, где у вас выделяется память.
3540.10 3544.34 "Анатолий Кулаков" В том числе боксинг, создание объектов и все-все-все в этом духе.
3544.34 3549.82 "Анатолий Кулаков" Открывает глаза на многие вещи, где, казалось бы, никакого new нет, но почему-то память выделяется.
3549.82 3557.42 "Анатолий Кулаков" Поставьте хотя бы ради того, чтобы увидеть и посмотреть, и узнать, где же на самом деле еще выделяется память в вашем программе.
3557.42 3569.14 "Игорь Лабутин" Да, это плагин для Sharper, он же есть для… он, собственно, встроен в Rider, и на самом деле есть некоторое подобие для чисто Visual Studio плагинчика похожего.
3569.14 3576.82 "Игорь Лабутин" Он не настолько полноценный, но тоже что-то умеет, поэтому даже если вы не пользуетесь Sharper или Rider по какой-то причине, то даже в студии это можно сделать.
3576.82 3578.82 "Игорь Лабутин" На основе Roslyn, конечно же.
3578.82 3583.02 "Игорь Лабутин" Дальше, следующая штука — это изменение размеров коллекции.
3583.02 3593.10 "Игорь Лабутин" То есть, когда вы докидываете в коллекцию элементы, внутри большинства коллекций там либо массивы, либо что-то подобное, то как только в эти массивы все перестает влезать, массивы обычно увеличиваются в размерах.
3593.10 3596.98 "Игорь Лабутин" По разным алгоритмам, где-то ровно в два раза, где-то по простым числам, где-то еще как-то.
3596.98 3608.10 "Игорь Лабутин" Но тем не менее, если вы знаете, что вам нужно 10 тысяч элементов запихать в словарик или еще куда-то, то глупо будет создавать пустой словарик и потом в него 10 тысяч раз говорить "эдэдэ".
3608.10 3609.66 "Игорь Лабутин" Создайте сразу его от нужной тысячи.
3609.66 3616.82 "Игорь Лабутин" Для того, чтобы понять, что у вас есть такая проблема, надо в профайлере поискать соответствующие вызовы.
3616.82 3622.14 "Игорь Лабутин" Для этого, может быть, надо будет посмотреть в исходничке дотнета и глянуть, каким же образом ресайзятся все линейные коллекции.
3622.14 3633.94 "Игорь Лабутин" То есть, по сути, вы увидите, что у вас очень много allocated byte arrays, ну или массивов символов или еще чего-то, того, чего вы храните в этих словариках или в других коллекциях в списках.
3633.94 3638.54 "Игорь Лабутин" И дальше посмотреть по call stack, из-за чего они аллоцируются.
3638.54 3648.62 "Игорь Лабутин" Если вы увидите там, что, например, вызывается какой-нибудь dictionary.resize, то это повод подумать, почему в этом dictionary он часто вызывается и нельзя ли этот dictionary как-то заранее пронициализировать нужным размером.
3648.62 3657.54 "Игорь Лабутин" Тут важно не переборщить и не пронициализировать его всегда, например, в 10 тысяч элементов, хотя туда только в половине случаев нужно 10 тысяч, а в другом случае 2.
3657.54 3667.46 "Анатолий Кулаков" Ну, вообще, по моему опыту, практически 50% всех использований листов и dictionary, они знают примерно размер тех элементов, которые у них будут засунуты.
3667.46 3677.22 "Анатолий Кулаков" Если вы встречаете код, в котором у вас есть dictionary или list или другие коллекции, и вы точно знаете, какой у вас capacity, задавайте его явно.
3677.22 3679.58 "Анатолий Кулаков" Это очень сильно улучшает performance.
3679.58 3686.78 "Игорь Лабутин" Да, даже если вы ошибетесь там один раз в чуть-чуть меньшую сторону или большую, это не так страшно, как если вы туда просто передаете 0.
3686.78 3687.78 "Игорь Лабутин" Памяти сэкономите много.
3687.78 3692.70 "Игорь Лабутин" Дальше штука с, опять же, коллекциями.
3692.70 3701.74 "Игорь Лабутин" Когда вы пишете fridge по какой-то коллекции, в зависимости от всяких разных условий, у вас может итератор этой коллекции оказаться в куче.
3701.74 3712.02 "Игорь Лабутин" Как правило, итераторы у большинства нормальных коллекций — это структуры, и для того, чтобы они оказались в куче, нужно как-то очень сильно постараться, но тем не менее такое случается.
3712.02 3726.26 "Игорь Лабутин" Ищется это просто потому, что вы идете в кучу и ищете, что там какой-нибудь лист от t, точка итератор там почему-то лежит, и это явный повод подумать, где вы итероидитесь не так, как надо, а происходит это по одной простой причине.
3726.26 3730.98 "Игорь Лабутин" Происходит это потому, что в методы многие любят передавать коллекции, какая номер был.
3730.98 3745.50 "Игорь Лабутин" И если бы там был нормальный лист, то fridge от листа у нас forEach он ducktyping, то есть он поймет, что у класса лист есть метод getEnumerator, подставит вызов getEnumerator и переменно объявит нужного типа, и соответственно структура правильно присвоится.
3745.50 3756.50 "Игорь Лабутин" Если же мы передали лист в функцию через inNumerable, inNumerable обязан быть на куче, и поэтому итератор обязательно туда закинется в любом случае, на кучу.
3756.50 3772.54 "Анатолий Кулаков" Я все жду, чтобы кто-нибудь из больших наконец написал статью «никогда не используйте в жизни inNumerable», чтобы я наконец-то мог разразиться и вылить все то ведро мата, которое у меня накопилось за это время, к подобному коду.
3772.54 3774.10 "Анатолий Кулаков" Но пока пойдем дальше.
3774.10 3775.10 "Игорь Лабутин" Дальше строчки.
3775.10 3779.62 "Игорь Лабутин" Строчки, как известно, у нас в интернете immutable, то есть вы не можете изменять.
3779.62 3785.30 "Игорь Лабутин" И это значит, что как только вы хотите что-то изменить, скорее всего вы порождаете новую строчку.
3785.30 3790.58 "Игорь Лабутин" И если таких строчек стало порождаться очень много, надо пойти проверить почему.
3790.58 3798.78 "Игорь Лабутин" Лучший способ, как я это понял, это просто вы идете в профайлер, который позволяет вам смотреть в call stack того, когда аллоцируются деленные объекты.
3798.78 3803.42 "Игорь Лабутин" Берете строки и смотрите, из каких методов больше всего аллоцируются.
3803.42 3812.38 "Игорь Лабутин" Обычно дальше становится все предельно понятно, почему там много конкатенаций или почему там много каких-нибудь substrings или еще что-нибудь.
3812.38 3816.90 "Игорь Лабутин" Таким образом, кстати, вы внезапно можете для себя понять, где же у вас ход паф в приложении.
3816.90 3822.66 "Игорь Лабутин" Что вот этот url оказывается партится там две сотни раз на один реквест, потому что мы не подумали закешировать результат парсинга.
3822.66 3825.02 "Игорь Лабутин" Ну или что-нибудь в таком духе.
3825.02 3828.50 "Игорь Лабутин" Перерабатывайте бизнес логику, думайте, как избавиться от кучи строчек.
3828.50 3829.50 "Игорь Лабутин" Логирование.
3829.50 3836.70 "Игорь Лабутин" С логированием становится все чуть лучше, но все равно я тоже в том числе регулярно натыкаюсь.
3836.70 3849.22 "Игорь Лабутин" Если у нас есть log, там log.information, вы туда передаете кучку объектов, то во-первых, если у вас параметров достаточно много, то автоматически начнет аллоцироваться массив этих параметров.
3849.22 3857.34 "Игорь Лабутин" Если вы передаете в этот log.information, например, value типы, то они будут бокситься и повеляться на куче.
3857.34 3887.02 "Игорь Лабутин" И в-третьих, если вы, например, пишете какой-нибудь свой собственный фасад, например, или еще что-то, хотя в современном мире .NET Framework и стандартного логинга, abstraction, это скорее всего уже редко происходит, но тем не менее, если вы вдруг пишете какой-то интерфейс, похожий на то, что делает логирование, то есть с переменным числом аргументов, всегда добавляете несколько перегрузок для безаргументов, для одного аргумента, для двух аргументов и очень желательно их делать generic, чтобы value типы не боксились, тогда у вас не будет аллокаций.
3887.02 3889.86 "Игорь Лабутин" Опять же, heap allocation viewer в помощь.
3889.86 3895.98 "Игорь Лабутин" И последнее, это lambda.inq, тоже примерно из разряда IEnumerable.
3895.98 3904.54 "Игорь Лабутин" Если вы пишете какой-то метод и передаете туда, например, лямбда, решапер очень часто говорит "давай на метод групп заменим", ну давай на метод групп заменим.
3904.54 3914.94 "Игорь Лабутин" Вот это, я не знаю почему он это делает, это в принципе наверное читается чуть проще, хотя не знаю, мне например проще читать лямбду, с вот этими скобочками и стрелочкой в начале, даже если она без аргументов.
3914.94 3925.86 "Игорь Лабутин" Но во-вторых, лямбда может быть потенциально закеширована к аппеляторам, в то время как метод групп это всегда лоцирование делегатов, поэтому я придерживаюсь стараясь только лямбд.
3925.86 3940.30 "Игорь Лабутин" Ну а с link_u, та же самая проблема, что с итерацией коллекций, ищите итераторы на куче, они там очень характерно называются, типа там where_list итератор, или там where_select, если у вас два подряд, например, select. и потом where.
3940.30 3963.98 "Игорь Лабутин" Но наоборот, то во фреймворке есть оптимизации под такую тему, и там на самом деле используется один итератор, и тут они называются всякими странными именами, типа там, как я сказал, where_select или что-то подобное, если они оказываются на куче, это значит, что вы скорее всего слишком много используете link_u, и может быть надо подумать и от него частично отказаться на опять же путях, где это мешает вам получить максимальный перформанс.
3963.98 3979.74 "Игорь Лабутин" Напомню, что это были рекомендации 2014 года, и надо сказать, что в современном мире, ну вот только что про логинг, наверное, стало чуть проще, потому что у нас появился более-менее стандартный фасад про весь логинг, и практически все, наверное, только им сейчас и пользуются, а все остальное не сильно поменялось.
3979.74 3993.74 "Игорь Лабутин" Дальше, вторая статья, она, даже третья уже статья, она смотрит на перформанс немножко с другой стороны, и это статья от Кевина Госсе, нашего известного эксперта с точки зрения перформанса.
3993.74 4001.02 "Анатолий Кулаков" У него рекомендации… А сколько я знаю Кевина, наверное, эта статья смотрит и изнутри как-нибудь, и
4001.02 4018.42 "Игорь Лабутин" наружу, да? Слушай, я тоже думал, что он будет про всякие там вот allocate и низкоуровневые, у него нет, у него, как ни странно, больше такие бизнесовые, ну да нет, тоже нельзя врать так, не совсем бизнесовые, конечно, штуки, но немножко вообще с другой стороны.
4018.42 4026.70 "Игорь Лабутин" Давай я перечислю, что он рекомендует делать и не делать, и ты потом сможешь оценить вообще, насколько это низкоуровнево или наоборот.
4026.70 4032.54 "Игорь Лабутин" Первая он говорит, первая рекомендация в статье про перформанс, не надо ждать синхрона на синхронном коде.
4032.54 4033.54 "Игорь Лабутин" Сложно спорить.
4033.54 4037.90 "Игорь Лабутин" Ну, то есть всякие точка резалт, вот это все вызывать, лучше не надо.
4037.90 4040.46 "Игорь Лабутин" Если вы пишете синхронный код, пишите его синхрон.
4040.46 4051.14 "Игорь Лабутин" Дальше не забывайте использовать конфигure_weighted_falls, если вы это пишете, помните, что конфигure_weighted работает только если вы действительно используете weight.
4051.14 4059.50 "Игорь Лабутин" Это extension метод, он может быть вызван на любом таске, но эффект он имеет только когда вызываете его через await, а ждете точнее таску через await.
4059.50 4066.02 "Игорь Лабутин" И делайте конфигure_weighted_falls только если вы, ну не так, понимаете зачем вы это делаете.
4066.02 4073.38 "Игорь Лабутин" В библиотеках, как известно, практически всегда это делать надо, а в основном приложении надо думать, особенно если вы работаете с UI.
4073.38 4077.86 "Игорь Лабутин" Но скорее всего там не будет особых performance проблем именно вокруг этого.
4077.86 4078.86 "Игорь Лабутин" Никогда не используйте async_void.
4078.86 4087.70 "Игорь Лабутин" Это не совсем относится к performance, это относится к общей стабильности программы, потому что exceptions, которые оттуда кинутся, про них никто никогда ничего не узнает.
4087.70 4100.22 "Анатолий Кулаков" Ну, опять же, если мы говорим про UI, то это не всегда возможно, потому что в UI очень много есть ивентов, ивентов асинхронных, и когда ты на них подписываешься, твой хендлер в любом случае должен быть асинхронным и при этом возвращать void.
4100.22 4101.22 "Игорь Лабутин" Да, это правда.
4101.22 4113.54 "Игорь Лабутин" Естественно, так же, как ты рассказывал про nullable type, всегда есть какие-то corner cases, ограничения, public surface, который не может быть nullable, также здесь всегда есть какие-то вещи, но…
4113.54 4118.66 "Анатолий Кулаков" Ну да, да, справедливости ради можно сказать, наверное, что это единственный такой случай общепринятый.
4118.66 4132.58 "Анатолий Кулаков" Вот, я еще написал в своих тестах тестик, который рефлекшнно обходит все типы, все методы, забирает у них сигнатуру и ищет подобную, которая называется async void, и как только он ее находит, кричит благим матом.
4132.58 4134.38 "Анатолий Кулаков" Вот, тоже рекомендую, хороший тест.
4134.38 4138.38 "Игорь Лабутин" Ну и в нем есть список эксепшенов, да, так сказать, кому можно.
4138.38 4139.94 "Игорь Лабутин" Да, да, список исключений.
4139.94 4141.78 "Игорь Лабутин" Хорошо, пошли дальше.
4141.78 4147.86 "Игорь Лабутин" Дальше Кевин говорит, постарайтесь не использовать сравнение строк с учетом культуры.
4147.86 4169.78 "Игорь Лабутин" Это может быть не очень интуитивно, и ну что вы там, равно-равно написали, или что-нибудь в таком духе, или просто передали какую-то культуру, это на самом деле довольно-таки затратное дело, и если у вас есть возможность, если вам действительно просто нужно проверить, что эти две строки в принципе одинаковы по байтово, используйте тогда ordinal comparison, он будет максимально быстрым вариантом.
4169.78 4181.22 "Анатолий Кулаков" Ну тут стоит уточнить, что как раз сравнение по культуре идет по дефолту, то есть если вы ни о чем не думаетесь, не загоняетесь об этом, то у вас по дефолту все сравнивается культурно, так сказать.
4181.22 4183.98 "Анатолий Кулаков" Но в большинстве случаев программистам это не нужно.
4183.98 4188.02 "Анатолий Кулаков" Действительно всегда должно хватать ordinal.
4188.02 4210.50 "Игорь Лабутин" Ну в большинстве случаев опять же это не приносит каких-то проблем, но если у вас какой-то действительно сильно быстрый путь, то есть например если вы там пишете фреймворк похожий на S/P/Nad Core, и вам нужно быстро сравнивать, например, заголовки запросов, то конечно там нужно использовать ordinal, и там культура вообще не нужна, все точно уверены, что там один английский, даже ASCII, не то что английский.
4210.50 4215.82 "Игорь Лабутин" Дальше, никогда не используйте concurrent back без бенчмаркинга.
4215.82 4216.82 "Игорь Лабутин" Почему?
4216.82 4228.94 "Игорь Лабутин" Потому что concurrent back был придуман, как выясняется, я вот этого не знал, для довольно-таки специфичного юзкейса, когда то, что туда кладется, забирается из этого concurrent back тем же потоком.
4228.94 4244.14 "Игорь Лабутин" То есть это видимо сценарий, когда у нас есть много, скажем так, продюсеров кончивых, точнее много активности по продюсингу каких-то сущностей и вытаскивания их оттуда, и при этом поток может заниматься и тем и другим, то ли попеременно, то ли еще как-то.
4244.14 4247.02 "Игорь Лабутин" А вы почитать почему так было сделано и зачем?
4247.02 4260.18 "Игорь Лабутин" Не знаю, но суть в том, что внутренняя инструктура оптимизирована ровно на такую штуку, и если вам нужно просто такой общечеловеческий concurrent что-то, откуда в каком-то произвольном порядке вы будете выбирать, лучше использовать concurrent q.
4260.18 4264.22 "Игорь Лабутин" Хоть это и честная очередь, но она будет гораздо более быстро работать.
4264.22 4272.90 "Игорь Лабутин" И надо сказать, что все эти рекомендации у Кевина они из реальных performance проблем на реальных бизнес-кейсах, поэтому наверное он знает, что говорит.
4272.90 4275.86 "Игорь Лабутин" Следующая штука тоже может быть немножко контуититивна.
4275.86 4293.70 "Игорь Лабутин" Все наверное знают, что не надо использовать класс reader-write-log, потому что есть reader-writer-log-slim, но опять же, используйте битчмарки, потому что обычный лог скорее всего будет быстрее, чем reader-writer-log-slim, если у вас только не огромное количество одновременно читающих потоков.
4293.70 4308.26 "Игорь Лабутин" То есть reader-writer-log-slim он оптимизирован под очень много читающих потоков, но тот overhead, который он дает, чтобы это все хорошо работало, будет тормозить на не очень большом количестве читающих потоков, и обычный лог будет быстрее.
4308.26 4313.78 "Игорь Лабутин" Так что начинайте с обычного лога, а дальше уже, если вы видите именно в этом проблему, тогда думайте дальше.
4313.78 4318.58 "Игорь Лабутин" Про лямбы-то я говорил, что их надо предпочитать, нежели чем метод группы.
4318.58 4320.90 "Игорь Лабутин" Янумчики в стринги конвертить.
4320.90 4337.02 "Игорь Лабутин" Мне кажется, кстати, по-моему в последних версиях что-то на эту тему делают, но в целом, когда вы у Янума вызываете стринг, там на самом деле все довольно медленно работает, поэтому результат лучше закошелить в словарике, и использовать оттуда будет быстрее.
4337.02 4343.30 "Игорь Лабутин" Так, ну, есть ряд рекомендаций про структуру, и про структуру можно вообще в принципе говорить много и долго.
4343.30 4347.18 "Игорь Лабутин" Тут две стандартных рекомендации.
4347.18 4355.30 "Игорь Лабутин" Обязательно реализуйте quality members, то есть равно-равно, и equals, потому что иначе вы побежите в reflection, дефолт реализация использует reflection очень медленно.
4355.30 4361.42 "Игорь Лабутин" И второе, то что я уже много раз повторял, старайтесь не допускать боксинга, передавая структуры через интерфейс.
4361.42 4362.42 "Игорь Лабутин" Как интерфейс?
4362.42 4363.86 "Игорь Лабутин" Пишите generic методы.
4363.86 4366.46 "Анатолий Кулаков" Я бы обобщил, старайтесь не использовать структуры.
4366.46 4371.38 "Анатолий Кулаков" Вот это хорошее правило, которое работает практически в 90% случаях.
4371.38 4375.62 "Анатолий Кулаков" Если вы до конца не понимаете, зачем вам это нужно, старайтесь структуру никогда не использовать.
4375.62 4379.18 "Анатолий Кулаков" Если вас очень сильно припекло, попробуйте использовать read-only структуры.
4379.18 4385.94 "Анатолий Кулаков" Вот read-only структуры избавлены практически от многих минусов, которые есть у структур.
4385.94 4393.02 "Игорь Лабутин" А если вы будете использовать read-only ref структуры, то компилятор за вас будет смотреть, чтобы вы их ненароком в кучу не запихнули, потому что их нельзя в кучу.
4393.02 4398.02 "Игорь Лабутин" Но там есть куча других проблем, так что я, пожалуйста, соглашусь, старайтесь не использовать структуры.
4398.02 4404.18 "Игорь Лабутин" И еще две рекомендации касательно вокруг тасков, это cancellation токены.
4404.18 4418.66 "Игорь Лабутин" Помните, что когда у cancellation токена вызывается cancel, то вызовутся все подписчики этого cancellation токена, потому что на него можно вызвать метод register for cancellation, тогда будет некоторая делегатика, лямоточка вызвана, когда собственно этот самый cancel будет вызван.
4418.66 4425.42 "Игорь Лабутин" Так вот, знайте, что cancel вызовет все вот эти делегатики прямо в том же потоке, где был вызван cancel.
4425.42 4431.02 "Игорь Лабутин" И это может оказаться сюрпризом и в каких-то ситуациях можно даже добиться deadlock.
4431.02 4442.78 "Игорь Лабутин" Поэтому, если вам нужно гарантировать, что все вот эти подписки на cancellation будут вызваны в отдельном потоке, лучше cancel вызывать через task run, так чтобы все это выполнялось где-то в ThreadPool.
4442.78 4450.30 "Игорь Лабутин" Ну и то же самое с task completion source, continuation, как правило, inline, то есть выполняется в том же потоке, где закомплетилась предыдущая task.
4450.30 4463.62 "Игорь Лабутин" И Kevin вообще рекомендует, когда создаете task completion source, старайтесь всегда использовать опцию task creation option run continuation asynchronously, чтобы вообще он всегда пытался их выполнять синхронно.
4463.62 4468.58 "Игорь Лабутин" В общем вот, это уже чуть более современные рекомендации от Кевина.
4468.58 4473.30 "Игорь Лабутин" И не знаю, наверное мы уже аудиторию слишком сильно загрузили всем таким.
4473.30 4476.02 "Игорь Лабутин" Лямбда и память, вот это все.
4476.02 4481.42 "Игорь Лабутин" Хочется разобрать последнюю статью про перформанс на сегодня, и больше мы не будем мучиться с перформансом.
4481.42 4485.58 "Игорь Лабутин" Это уже статья от Стивена Гордона, которого мы много раз упоминаем.
4485.58 4497.10 "Игорь Лабутин" И тут, я когда читал ее, я сначала думал, что, интересно, а что же еще расскажет Стивен, чтобы удивить и так далее.
4497.10 4503.62 "Игорь Лабутин" Потому что статья получилась довольно длинной, мне казалось, что будет опять повтор всех этих рекомендаций, но нет.
4503.62 4508.26 "Игорь Лабутин" Повтора практически не было, потому что у Стивена был такой пример.
4508.26 4513.30 "Игорь Лабутин" У него есть метод конвертирования некоторой строчки в URL.
4513.30 4520.30 "Игорь Лабутин" Строчка это на самом деле шаблончик URL, и там возможно есть некоторые placeholders, которые нужно заменить.
4520.30 4529.94 "Игорь Лабутин" И алгоритм работает следующим образом, он берет URL, этот шаблончик, разбивает его на кусочки, так что каждый кусочек это либо строка, либо шаблон.
4529.94 4539.34 "Игорь Лабутин" И после этого спокойненько обходит их в цикле, если это шаблон, то заменяет его на соответствующий параметр, собирает результат в StringBuilder, вызывает toString в конце и возвращает.
4539.34 4560.94 "Игорь Лабутин" Достаточно оптимально, все обходится в форум, никакого link_u нету, StringBuilder используется, StringBuilder инициализируется некоторым заранее предопределенным размером, но в принципе мы примерно понимаем, что в их конкретном кейсе там URL в среднем влезали в 100-200 символов, то есть StringBuilder инициализируем, все зашибись, но тем не менее все равно это hotpath, можно что-нибудь пооптимизировать.
4560.94 4574.26 "Игорь Лабутин" Дальше он пишет, что в принципе можно было бы заморочиться, пойти в область спанов, как-то все преаллоцировать, stack-алоги, вот это все, но на самом деле он пошел другим путем и тоже получил хороший выигрыш.
4574.26 4613.38 "Игорь Лабутин" Фактически оказалось, что в некоторых URL нет placeholders в некоторых шаблонах, но вот часть туннелов вообще без шаблонов, и как ни странно, некоторые такие URL дергаются довольно часто, пример это какой-нибудь healthcheck, то есть у вас может быть сколь угодно сложное приложение с кучей URL, endpoints, где есть много параметров, которые нужно подменять, но жизнь такова, что healthcheck вы дергаете раз в секунду в любом случае, и возможно не вы один, а много клиентов, чтобы проверить, что ваша API до сих пор жива, и поэтому если в вашей клиентской библиотечке вы поставляете SDK, вы там как-то собираете хитрые URL, то такой URL будет собираться много-много-много раз за секунду, и вот этим сложным алгоритмом.
4613.38 4627.86 "Игорь Лабутин" А поэтому дальше его мысль развивалась следующим образом, первым делом, когда вы занимаетесь перформансом, обязательно замешите бейнхмарк до того, как вы что-то поменяли, чтобы убедиться, что потом после того, как вы что-то поменяли, стало быстрее, ну или медленнее.
4627.86 4637.22 "Игорь Лабутин" Дальше, делаем оптимизацию, оптимизация из трех строчек, если URL состоит из одной части, и одна часть не является плейсхолдером, мы прям возвращаем эту часть.
4637.22 4643.74 "Игорь Лабутин" Никаких for-each, никаких stringbuilder ничего, и только если частей больше одной, ну тогда придется как бы заменять.
4643.74 4662.50 "Игорь Лабутин" Все, это была вся оптимизация, то есть никаких спанов, никаких stack-a-log, хитрых кэширований stringbuilder, ничего такого, и в 70% случаев это ускорило выполнение, грубо говоря, с 80 миллисекунд или наносекунд, я уже не помню точно, до 5.
4662.50 4669.62 "Игорь Лабутин" Ну то есть как бы оптимизировать 80% кейсов тремя строчками, при том, что код не стал сильно менее читабельным, это на самом деле очень круто.
4669.62 4707.94 "Игорь Лабутин" И вот основная мысль, и я ее очень сильно придерживаюсь, такая, до того и перед тем, как вы побежали, использовать все ваши отличные знания про то, как работает garbage коллектор, все новомодные low-level улучшения runtime и SDK .net, которые команда .net нам предоставляет, подумайте о логике работы вашего приложения, и подумайте, нельзя ли каким-то простым способом изменить, так скажем, основные пути, и может быть путем пары-тройки проверок какие-то основные простые пути отсечь заранее и сделать так, чтобы ваш код вообще не нужно было выполнять, а значит и оптимизировать.
4707.94 4713.02 "Игорь Лабутин" И это будет гораздо лучше, чем если вы перепишите этот метод через какие-то адские оптимизации.
4713.02 4718.46 "Анатолий Кулаков" Да, хороший подход, согласен, что его нужно применять в первую очередь перед любой оптимизацией.
4718.46 4721.30 "Игорь Лабутин" Ладно, хватит на сегодня про performance, есть у нас еще
4721.30 4727.58 "Анатолий Кулаков" что-нибудь? Да, у меня есть прекрасная точка ко всей той большой тираде, которую ты нам выдал про performance.
4727.58 4732.50 "Анатолий Кулаков" Набрел я на викторину от нашего любимого Конрада Кокоса.
4732.50 4749.14 "Анатолий Кулаков" Ты не зря упоминал, что в принципе проблемы с ГЦ, с памятью, это, наверное, самая распространенная причина всяких наших performance деградаций, и у нас в последнее время самым большим специалистом по памяти, по ГЦ и все, что с этим связано вокруг, является Конрад Кокоса.
4749.14 4758.66 "Анатолий Кулаков" Если вы еще не читали его книгу или не подписаны на его блог, или не видели его потрясающих докладов, то советую погуглить, посмотреть, что этот типаж из себя представляет.
4758.66 4764.18 "Анатолий Кулаков" И в своем блоге Конрад сделал нам интересную викторинку.
4764.18 4768.50 "Анатолий Кулаков" Назвал он ее викторина по .NET Memory Management.
4768.50 4776.10 "Анатолий Кулаков" Несмотря на страшное название, викторина довольно интересная, все там сделано довольно-таки качественно, прекрасно.
4776.10 4791.06 "Анатолий Кулаков" И Конрад говорит, что несмотря на то, что у нас есть отличная абстракция в .NET, что в принципе никакой памяти задумываться не надо, ссылки диспозить не надо, все для нас делает Garbage Collector, все удобно, красиво и понятно.
4791.06 4800.18 "Анатолий Кулаков" И большинству разработчиков, скорее всего, даже не нужно заботиться о том, как управлять памятью, и что она из себя представляет, и где там выделяются объекты.
4800.18 4813.58 "Анатолий Кулаков" Но на самом деле, как только разработчик начинает расти, то он обязательно сталкивается с какими-то корневыми случаями, что какие-то проблемы при скалировании, какие-то проблемы при масштабировании, начинаются какие-то утечки памяти.
4813.58 4818.54 "Анатолий Кулаков" И все-таки с памятью в большинстве случаев нужно быть знакомым.
4818.54 4822.90 "Анатолий Кулаков" Нужно понимать, каким образом она работает, какие там процессы есть и что там происходит.
4822.90 4833.38 "Анатолий Кулаков" И вот для того, чтобы проверить, насколько вы разбираетесь в работе памяти в дотнете, он и создал этот интересный вопросник.
4833.38 4844.50 "Анатолий Кулаков" Там нет никаких глупых вопросов, как он сам написал, никаких тупых вопросов о том, сколько поколений у нас в ГЦ.
4844.50 4850.26 "Анатолий Кулаков" Вот, я подтверждаю, я тоже минуток за 10 его быстренько прокликал для того, чтобы оценить вопрос, и мне очень понравились.
4850.26 4857.38 "Анатолий Кулаков" Я потом даже пересматривал свои ответы, чтобы узнать правильные опции, которые были.
4857.38 4862.06 "Анатолий Кулаков" В принципе, вот так вот ненапряжно я набрал 31 балл из 49.
4862.06 4865.22 "Анатолий Кулаков" Ну, то есть, это примерно троечка из пяти.
4865.22 4866.22 "Анатолий Кулаков" Игорь, ты проходил?
4866.22 4870.54 "Игорь Лабутин" Да, я проходил, я даже в Твиттере результат написал реплайм Конраду.
4870.54 4880.34 "Игорь Лабутин" И да, у меня, ну я тоже так, наверное, минут 10-15 посидел, не сильно вдумываясь, и у меня получилось 47 из 49.
4880.34 4882.74 "Игорь Лабутин" Я поошибался в паре вопросов.
4882.74 4883.74 "Анатолий Кулаков" Ну, красота, красота.
4883.74 4892.74 "Анатолий Кулаков" В принципе, давайте слушатели тоже проходите, пишите в комментариях, что получилось у вас, наберёт ли кто-то 49 так с наскоку.
4892.74 4910.74 "Анатолий Кулаков" Вот, вопросы интересные, даже если вы ничего не понимаете в ГЦ, просто пройдите ради фана, посмотрите на ответы, там собранные от основ языка, вот от самых банальных, которые должен знать просто любой джун, и до самых продвинутых каких-то вещей, которые вышли вот в последнем дотент фреймворке, о которых ещё многие могут даже и не знать.
4910.74 4916.10 "Игорь Лабутин" И на этом, я думаю, что мы будем завершаться, по крайней мере, основную техническую часть.
4916.10 4920.74 "Анатолий Кулаков" Подожди, у нас ещё есть парочку линков от коллег, давай быстренько их обсудим.
4920.74 4921.74 "Анатолий Кулаков" Давай.
4921.74 4934.90 "Анатолий Кулаков" Наша традиционная рубрика "Подслушано", в которой мы даём вам ссылки на какие-то интересные другие доклады или подкасты, которые нам понравились и которые мы, может быть, рекомендуем вам тоже послушать.
4934.90 4942.62 "Анатолий Кулаков" Прежде всего в DevZen приходил один из авторов Кликхауса, самый главный автор Кликхауса, это Алексей Миловидов.
4942.62 4951.54 "Анатолий Кулаков" Алексея всегда прекрасно слушать на любых конференциях, в любых подкастах, и выпуск называется "Кликхаус не тормозит", это выпуск 334-й.
4951.54 4959.66 "Анатолий Кулаков" Там он рассказывал об устройстве Кликхауса, о его возможностях, обсуждали последние версии, какие там нововведения были.
4959.66 4972.46 "Анатолий Кулаков" В общем, всем тем, кому интересно, это база данных, как её можно использовать, что там внутри творится, как работает команда и прочие интересные вещи от создателя самого Кликхауса, можно отправить в DevZen.
4972.46 4980.38 "Игорь Лабутин" А от меня, соответственно, рекомендация послушать выпуск подкаста "Подлодка" 204-й про разработку приложений под ТВ.
4980.38 4987.02 "Игорь Лабутин" Я когда видел тайтл, ну и анонс, я подумал, что не, я это слушать не буду, ну где мы, где разработка под телевизор?
4987.02 4993.90 "Игорь Лабутин" Нет, там конечно есть, .NET, да, в Самсунге, но он всё-таки довольно специфичный и вряд ли это будет конкретно про .NET.
4993.90 4999.98 "Игорь Лабутин" Это действительно было не совсем про .NET, это было про разработку под специальный Netflix браузер.
4999.98 5009.78 "Игорь Лабутин" Netflix для того, чтобы облегчить себе жизнь, сначала разработала свой собственный браузер под телевизоры, а потом под этот самый браузер-телеплатформу стал писать всякие плагинчики.
5009.78 5028.42 "Игорь Лабутин" Вот в гости приходил один из разработчиков, который половину подкаста довольно увлекательно рассказывал, какие вообще проблемы бывают у разработчиков под телевизор, и ты понимаешь, что в нашей обычной жизни разработчика в Backend или в Desktop приложении всё гораздо проще и спокойнее.
5028.42 5042.14 "Игорь Лабутин" А с другой стороны, вторая часть подкаста, она была вообще не про разработку приложения под ТВ, она была про жизнь в Netflix, про то, что это такое Netflix, как в нём живётся, работает, какие-то корпоративные практики и так далее.
5042.14 5051.66 "Игорь Лабутин" Поэтому если вам интересно посмотреть, послушать, как это выглядит изнутри, я очень рекомендую обе части, ну это один выпуск, но прослушайте его целиком от начала и до конца, узнаете много нового для себя.
5051.66 5063.02 "Анатолий Кулаков" Ну и Netflix интересен тем, что там это не какая-то простая компания, в Netflix придерживается очень много так открытых принципов, где можно делать всё, что хочешь, ходить, куда хочешь, писать про всё, что хочешь.
5063.02 5075.26 "Анатолий Кулаков" Вот и вот эта вот культура, которая не похожа на большинство компаний, которые мы знаем, она имеет очень много не только плюсов, но и скрытых интересных минусов, вот о которых вам как раз таки автор тоже поведает.
5075.26 5077.82 "Игорь Лабутин" Да, ну а на этом мы точно будем завершаться.
5077.82 5108.74 "Игорь Лабутин" Сегодня мы посмотрели на то, как попроще стало контрибьютировать в S/Penet Core с Development с принтами каждый второй четверг месяца, узнали, что нас теперь ждёт два новых типа в базовой библиотеке, Data Only и Time Only, посмотрели на то, как Microsoft планирует поступать с Identity Server в новых темплейтах, в DotNet 6 ничего не поменяется, он также будет поставляться, вспомнили, что есть такая фича как nullable reference types и подробно рассмотрели, как с ними начать работать и какие-то бестпрактисы вокруг них.
5108.74 5120.30 "Игорь Лабутин" Мы очень детально обсудили различные аспекты перформанса в DotNet, в основном довольно-таки популярные и известные, но наверняка каждый до себя нашёл какие-то неизвестные ему ещё фишечки.
5120.30 5129.94 "Игорь Лабутин" И одна из мыслей, которая была рассмотрена, это про то, что не бегите оптимизировать перформанс, если вы можете оптимизировать бизнес-логику, так чтобы код вообще не выполнялся.
5129.94 5136.06 "Игорь Лабутин" Ну и небольшой квиз от Конрада Кокоса про DotNet Memory Management, проходите, будет интересно узнать ваши результаты.
5136.06 5137.86 "Анатолий Кулаков" Ну а на этом всё, давай закругляться.
5137.86 5157.94 "Анатолий Кулаков" Я призываю всех в честь запуска Microsoft срочно идти лайкать свои репозитории, писать комменты, писать положительные отзывы, шарить их с друзьями, а также рассказывайте про наш подкаст и пишите нам комментарии, что вы хотите улучшить, что хотите ухудшить и любые ваши пожелания.
5157.94 5159.94 "Анатолий Кулаков" Всем пока, до новых встреч.
5159.94 5160.44 "Анатолий Кулаков" Пока.
5160.44 5168.32 "Анатолий Кулаков" [музыка]
