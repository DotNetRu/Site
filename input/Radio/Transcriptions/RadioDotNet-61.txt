0.00 11.24 SPEAKER_00 Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер 61.
11.24 15.00 SPEAKER_00 Прежде всего, хотелось бы поблагодарить наших помогаторов.
15.00 24.00 SPEAKER_00 Это прекраснейший список – Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья и Гурий Самарин, что давно не растет, задумайтесь уже.
24.00 27.24 SPEAKER_00 Спасибо большое всем, кто нас поддерживает.
27.24 30.60 SPEAKER_00 И начинаем выпуск, что у нас там сегодня интересного?
30.60 37.00 SPEAKER_01 Ну, во-первых, хочется напомнить, что прошел онлайн.next 3-4 ноября.
37.00 39.04 SPEAKER_01 Если у вас есть билет, доступны все записи.
39.04 57.64 SPEAKER_01 Если у вас билета еще нет, то в шоуноутах вы найдете промокод на скидку, который позволит вам посмотреть, во-первых, прошедшие записи, во-вторых, попасть на онлайн просмотр офлайн дня 20 ноября, либо даже купить офлайн билет и встретиться, в том числе, с нами в Москве 20 ноября на офлайн-дне конференции.
57.64 60.80 SPEAKER_01 Приходите, будет, я думаю, интересно.
60.80 63.12 SPEAKER_00 Да, всех будем ждать на офлайне, заходите.
63.12 85.56 SPEAKER_00 Еще хотелось бы сказать, что наверняка вы этот выпуск уже будете слушать, когда .NET Conf идет или уже прошла, мы же записываемся еще до нее, поэтому сейчас в этом выпуске пока ничего про .NET Conf не будет, а вот следующий выпуск, я думаю, мы полноценно посвятим всем новинкам, которые анонсируют, которые выйдут, которые напишут статьи, бенчмарки, ну и прочее-прочее, что там посмотрим.
85.56 97.96 SPEAKER_00 А сейчас пока насладимся буквально несколькими днями тишины перед большими анонсами и посмотрим, что у нас еще интересно было, вышло, заанонсилось в мире .NET за то время, пока мы с вами не виделись.
97.96 101.96 SPEAKER_01 Ну, сильно много не заанонсилось, как мне кажется.
101.96 104.36 SPEAKER_01 Мы начнем с Entity Framework.
104.36 116.80 SPEAKER_01 Не то, чтобы это новый анонс, это на самом деле штука, про которую мы уже рассказывали, это performance improvement в Entity Framework 7, которые вышли еще в 6 превью, это пару или тройку превью назад.
116.80 140.76 SPEAKER_01 Однако же эта статья интересна тем, на самом деле это даже несколько статей, они интересны тем, что это не просто Microsoft показала, как они сделали круто, это реальные ребята посмотрели в достаточно таких, ну наполовину, скажем так, реально практических кейсах, насколько же получается выигрыш от этих всех изменений в EF.
140.76 154.80 SPEAKER_01 Причем надо понимать, что это все, поскольку превью, то прям совсем production, конечно на EF Core не переводили, но попытались эмулировать, что будет происходить в реальной жизни, когда вы реально развернете приложение.
154.80 166.92 SPEAKER_01 Напомню, что было сделано, собственно, с EF Core, они убрали возможность, невозможность, они убрали часть вызовов для явной работы с транзакциями.
166.92 181.28 SPEAKER_01 То есть, если вы делаете insert одной всего лишь записи, то делать два дополнительных round trip в базу, чтобы сказать begin transaction и end transaction, ну или commit transaction, как бы вроде странно, база данных и так сама автоматически сделает транзакцию на этот единственный insert.
181.28 194.72 SPEAKER_01 Поэтому эта штука была убрана, и мы на этом сэкономили два round trip, два round trip, ну вроде как, как бы немного с одной стороны, с другой стороны это две трети от всей операции записи, и казалось бы, должно стать лучше.
194.72 224.40 SPEAKER_01 Они действительно это проверили, и проверили они следующим способом, они взяли три кейса, это база данных на том же компе, где entity framework, то есть по сути на localhost, дальше берем ажурную регионы и говорим, что база данных будет лежать в том же регионе, что и код, но на разных машинках, и берем код в одном ажурном регионе, а базу данных в другом ажурном регионе, ну вдруг у вас такая георепликация, и почему-то ваше приложение решило пойти в соседний регион писать базу данных.
224.40 234.48 SPEAKER_01 В данном случае был выбран регион для базы, по-моему, Америка, US West, а для кода, соответственно, Europe West.
234.48 238.40 SPEAKER_01 Между ними, согласно ажурным данным, latency 72 миллисекунды.
238.40 246.52 SPEAKER_01 И чиселки получились следующие, для localhost, EFCore 7 по сравнению с EFCore 6, получило примерно 6% улучшения.
246.52 257.36 SPEAKER_01 Ну там скорее всего, конечно, сыграли роль и там оптимизация runtime и все остальное, но в целом какие-то оптимизации, ну на roundtrip, в том числе для localhost тоже время тратится.
257.36 272.08 SPEAKER_01 Если база данных живет в том же регионе, что и код, но на разных машинках, то мы получили 13% экономии времени, что уже, ну не так, чтобы сильно много, но достаточно много, учитывая, что это всего лишь один единственный инсерт.
272.08 284.64 SPEAKER_01 А в случае, если у вас база живет вообще в соседнем регионе, по какой-то причине, относительно кода, то вы получили 65% экономии, то есть по сути приложение в целом стало в 2 раза быстрее в этом конкретном аспекте.
284.64 285.72 SPEAKER_01 Это уже прям немало.
285.72 300.08 SPEAKER_01 Вторая штука, которая была изменена, это то, как обрабатывается multiple insert, то есть если вы сделали много раз insert, insert, insert, insert, а потом save changes, то EFCore делает следующую штуку.
300.08 305.76 SPEAKER_01 Во-первых, он батчит, то есть он объединяет все эти инсерты в батчи по несколько штук.
305.76 308.04 SPEAKER_01 Помнишь ли ты, какой размер батчи по дефолту?
308.04 310.04 SPEAKER_01 Нет, как-то не приводилось.
310.04 312.56 SPEAKER_01 Ну, это число нужно знать, это 42.
312.56 314.92 SPEAKER_01 А, 42, да, мы же обсуждали эту штуку.
314.92 325.56 SPEAKER_01 Да-да-да, он по дефолту 42, это действительно не поменялось, то есть это не было какой-то шуткой, в релизе, судя по всему, тоже будет 42, и оно так и есть, в тестах, по крайней мере, пока это подтверждается.
325.56 342.28 SPEAKER_01 EFCore, соответственно, объединяет инсерты в несколько, ну в батчи по 42 штуки, если их больше, чем 42, после чего использует, если это SQL Server, например, то SQL Statement под названием Merge, который позволяет как раз таки сделать инсерт.
342.28 352.20 SPEAKER_01 Раньше он это делал с временной табличкой, то есть он результат забирал во временную табличку, и потом оттуда понимал, какие ID-шники были сгенерены.
352.20 366.20 SPEAKER_01 Теперь он использует более простую версию, он просто использует output statement для этого, но, к сожалению, у этого есть и достоинства, и недостатки, точнее, к счастью, у этого есть достоинства, к сожалению, у этого есть недостатки.
366.20 367.84 SPEAKER_01 Достоинство в том, что это работает быстрее.
367.84 372.20 SPEAKER_01 Недостаток в том, что если на вашей табличке есть триггеры, то, например, SQL Server такой не поддерживает.
372.20 376.08 SPEAKER_01 Нельзя делать merge с output, если на табличке есть триггеры.
376.08 390.32 SPEAKER_01 Поэтому если это так, то вам нужно в db-контексте явно указать, что на этой таблице есть триггеры, и тогда EFCore будет работать по-старому, но вы не получите всех бенефитов от того, чтобы все стало быстрее.
390.32 404.04 SPEAKER_01 И в этом случае, если все нормально, если триггеров нет, и если у вас количество инсертов меньше, чем размер батча, либо равно, то, опять же, не будет никаких дополнительных begin-end на транзакции.
404.04 409.04 SPEAKER_01 Ну, если батчей больше одного, то там begin-end явный будет в любом случае явным round-trip, тут без этого никак.
409.04 414.36 SPEAKER_01 В плане чиселок получается примерно следующее.
414.36 431.52 SPEAKER_01 На тех же, назовем это условиях теста, то есть localhost, тот же регион и другой регион, относительно кода и базы разной регионы, получилось на вставке 10 рекордов улучшение соответственно на 23%, на 40% и опять на 65%.
431.52 436.76 SPEAKER_01 То есть, короче, здесь прям слеттанс стало лучше на десятки рекордов сразу.
436.76 443.24 SPEAKER_01 Хотя непонятно, почему на десятки рекордов, прямо на localhost такая, четверть сэкономили, но, видимо, еще какие-то рантаймовые штуты помогли.
443.24 460.56 SPEAKER_01 И последнее, что в этой статье интересно, и связано с ней, это то же, это фича, которую я на самом деле особо не знал, ну, точнее, я знал, как она работает для гуидов, но не знал, что есть другой способ.
460.56 470.48 SPEAKER_01 Смотрите, если мы вставляем, допустим, у нас есть пара объектов, точнее, пара классов связанных, это, допустим, традиционный пост и коммент к нему.
470.48 492.16 SPEAKER_01 Когда мы добавляем пост и, допустим, сразу, не знаю, к нему хотим сохранить какой-нибудь коммент, то для того, чтобы Entity Framework такое сохранить, ему нужно сначала сохранить объект родитель, получить его id-шник обратно и потом сохранить dto, чтобы указать, собственно, foreign ключом, кто был родителем.
492.16 508.16 SPEAKER_01 Если вы используете в качестве id ваших объектов родителя гуиды, то в этом случае такого делать не нужно или этого можно избежать, потому что гуиды можно сгенерить на клиенте и сразу одним инсертом запихнуть и родителя и dto в базу одним roundtrip.
508.16 512.44 SPEAKER_01 Инсертом, конечно, не получится, это будет два инсерта, но это можно сделать одним roundtrip.
512.44 524.60 SPEAKER_01 Но мы не все используем гуиды, не везде это нормально, не везде этим хочется заниматься, и поэтому в Entity Framework есть такая фича под названием high-low.
524.60 526.68 SPEAKER_01 Вот четыре буквы.
526.68 529.36 SPEAKER_01 Она работает следующим образом.
529.36 537.36 SPEAKER_01 Можно завести специальную sequence в базе данных и Entity Framework сказать, что для этой таблички, для его ключей использую этот sequence.
537.36 555.64 SPEAKER_01 И тогда Entity Framework, когда вы ему говорите save changes, он смотрит, сколько нужно будет заинсертить записей, ну например, если мы добавляем сразу 10 блок-постов, то он сходит в базу данных и скажет, отдай мне, дорогой дизайнер, пожалуйста, n ID-шников.
555.64 557.60 SPEAKER_01 Следующий, так сказать, range.
557.60 566.00 SPEAKER_01 По дефолту n = 10, но разработчики Entity Framework говорят, ну, короче, дефолт 10, но это не очень правильный дефолт, ставьте сразу больше, там, сотню, ставьте, будет норм.
566.00 578.76 SPEAKER_01 Вот, и по сути, получится, что Entity Framework сразу получает себе локально сотню ID-шников, в базе sequence двигается, и любой следующий клиент, который тоже захочет инсертию, он получит другую сотню.
579.76 587.40 SPEAKER_01 А ваша, так сказать, копия в памяти будет использовать эту сотню, пока она не закончится.
587.40 590.12 SPEAKER_01 Как только закончится, он получит следующую сотню.
590.12 619.84 SPEAKER_01 Таким образом, получается, что если вы делаете много инсертов, и вам не важен порядок, потому что, если у вас, допустим, несколько, не знаю, нод ходят в одну и ту же базу данных, да, и все они инсертят, то понятно, что каждый получит свой range, а использовать они будут их в каком-то случайном порядке, куда там будут запросы приходить, и поэтому записи, которые будут вставляться, казалось бы, по порядку, будут получать ID-шники, ну, на самом деле, довольно рандомно.
619.84 633.96 SPEAKER_01 Плюс, если вы, допустим, у вас есть какая-то там нода или под в кубернет, который взял, получил этот range 600 элементов, и тут же помер, ну, эти 100 элементов потерялись, то есть у вас еще и будут дырки в ваших ID-шниках.
633.96 651.88 SPEAKER_01 Если вас это все устраивает, а по мнению как бы разработчиков EF Core в большинстве приложений это норм, то, может быть, это вполне себе хороший вариант, как сделать так, чтобы у вас были ID-шники числовые, и при этом не было такой просадки по перформансу, если вы часто вставляете детей с родителями вместе.
651.88 663.16 SPEAKER_01 Поэтому, если это ваш кейс, по бенчмаркете такой способ, возможно, это действительно хороший способ сэкономить на вставке в современном Entity Framework 7.
663.16 674.72 SPEAKER_00 Тут хотелось бы еще добавить, что Hilo - это, в принципе, общеизвестный алгоритм, он применяется во многих базах данных и как раз таки служит для того, чтобы нивелировать все проблемы с распределенными идентификаторами.
674.72 686.76 SPEAKER_00 Например, вы можете с помощью этого прекрасного подхода добиться того, что у вас есть несколько распределенных нод, вам нужно вставлять какие-то записи, и вы при этом не хотите почему-то использовать гуиды.
686.76 689.92 SPEAKER_00 Ну, такая проблема всегда решается по дефолту с помощью гуидами.
689.92 696.08 SPEAKER_00 Если вам кто-то скажет, что это невозможно, это неправда, потому что очень распространен метод, вот такой подход как Hilo.
696.08 709.28 SPEAKER_00 Он вам позволяет оставаться в интах, то есть у вас по-прежнему будут красивые более-менее идентификаторы, они будут идти более-менее по порядку, но опять же без гарантированного какого-то отсутствия дырок или без гарантированного порядка, как сказал Игорь.
709.28 713.88 SPEAKER_00 В общем, но при этом это намного короче, намного приятнее будет смотреться, чем гуиды.
713.88 721.12 SPEAKER_00 И этот алгоритм часто применяется, часто используется, опять же, главное смотреть и понимать его минусы и его плюсы.
721.12 727.04 SPEAKER_00 И в большинстве ситуаций он вам вполне может заменить гуиды, если они вам почему-то не нравятся.
727.04 740.04 SPEAKER_01 Да, но нужно выбирать размер вот этого ренжа, который каждый из ваших копий приложения получает, ну и смотреть, насколько у вас получаются при этом большие дырки, насколько все это хорошо работает.
740.04 743.96 SPEAKER_01 Я просто на самом деле что-то не знал, что EF Core его нативно поддерживает.
743.96 745.68 SPEAKER_01 Но, как выясняется, совпадное поддерживает.
745.68 756.56 SPEAKER_01 Причем, если вы используете Code First, то вам даже не нужно генерить ручную секвенцию, он по-моему сам генерирует его в нужном варианте.
756.56 766.84 SPEAKER_01 А вот если у вас Database First, то секвенцию вам нужно объявить в базе самому, а Entity Framework просто сказать вот для Hilo вот этой таблички используй вот тот секвенс под таким названием.
766.84 767.84 SPEAKER_01 И все будет работать.
767.84 775.76 SPEAKER_01 Давай пойдем дальше, кроме Entity Framework у нас сегодня день Performance Improvement.
775.76 782.80 SPEAKER_00 Ну, конечно, перед релизом всегда так, сначала там накидают, что только задали высший сахар, а потом начинают оптимизировать и перформанс улучшать.
782.80 791.36 SPEAKER_00 Ну, да, у нас еще есть на подходе статейка про ASP.NET Core, что же там случилось с перформансом, давайте посмотрим.
791.36 802.60 SPEAKER_00 Здесь, наверное, в этой статье очень прикольно на нее взглянуть с точки зрения вообще подхода, каким образом можно чинить самые распространенные проблемы с перформансом.
802.60 808.12 SPEAKER_00 Потому что я надеюсь, что вы знаете, что прежде чем чинить перформанс, вам нужно попрофайлить и найти точки, которые вас именно тормозят.
808.12 812.56 SPEAKER_00 Не так, как вам хочется и кажется, а реально, чтобы инструменты это вам подтвердили.
812.56 816.88 SPEAKER_00 И после того, как вы их нашли, у вас, соответственно, встает вопрос, а что же дальше с ним делать?
816.88 822.68 SPEAKER_00 В принципе, таких подходов, которые позволяют вам более-менее стандартные участки улучшать, их не так уж много.
822.68 828.92 SPEAKER_00 Я думаю, что если была бы какая-нибудь хорошенькая статейка или книжечка, то набралось бы несколько десятков и все.
828.92 833.68 SPEAKER_00 Если вы их выучите, вам их обычно хватит на всю жизнь, чтобы улучшать ваш перформанс.
833.68 834.68 SPEAKER_00 Да, ой-ой-ой.
834.68 838.92 SPEAKER_00 И здесь как раз-таки ярко выражены несколько таких подходов.
838.92 839.92 SPEAKER_00 Давайте посмотрим.
839.92 856.80 SPEAKER_00 Прежде всего, авторы нам хвалятся, что они смогли улучшить показатели на их специальной 80-ядерной машине на 514% для обычной дистиллизации текста и для 311% для JSON обработки запросов.
856.80 859.20 SPEAKER_00 В общем, как это они сделали?
859.20 863.72 SPEAKER_00 У них был очередь на входящие запросы для кестрила.
863.72 868.88 SPEAKER_00 Эта очередь была одна и, соответственно, она очень сильно локалась на контеншоне.
868.88 880.60 SPEAKER_00 Как только мы пытались распараллелить все запросы, только обработать их параллельно, все эти запросы лезли в одну очередь и оттуда доставали работу.
880.60 887.28 SPEAKER_00 Чтобы работа досталась только одному какому-то персонажу, только одному воркеру, там, естественно, был какой-то лок.
887.28 890.48 SPEAKER_00 В общем, это все было совсем нехорошо.
890.48 898.28 SPEAKER_00 Поэтому прежде всего эту очередь разбили на несколько очередей и теперь каждый воркер ходит к своей очереди.
898.28 903.72 SPEAKER_00 Это позволило избежать контеншона, то есть мы избавились от локов.
903.72 922.92 SPEAKER_00 И теперь у нас каждый воркер может забирать свою работу, но при этом немножко увеличилось время CPU, потому что бывают ситуации, когда воркер всю свою работу сделал и сидит без работы, а в это время другой воркер захлебывается от работы, не успевает разгрести свою очередь и в это время происходит так называемое воровство.
922.92 932.88 SPEAKER_00 То есть тот воркер, который халтурничает, он ворует работу у занятого воркера и вот здесь уже немножко нужно будет потратить CPU для того, чтобы это сделать.
932.88 940.92 SPEAKER_00 Но в принципе такой подход, он обычно дает больше плюсов, чем минусов, поэтому команда остановилась именно на нем.
940.92 948.64 SPEAKER_00 Также добавилась на Windows поддержка Windows I/O Completions в портабл ThreadPool.
948.64 954.52 SPEAKER_00 Давно уже переписали ThreadPool на портабл, но почему-то там Windows I/O Completions до сих пор не подтянули.
954.52 958.52 SPEAKER_00 Теперь это исправлено и это дало прирост на 11%.
958.52 970.56 SPEAKER_00 И также позволило убрать другую техдолг, который делал DoubleDispatch в Windows I/O, что увеличило еще на 18% производительность данных тестов.
970.56 975.32 SPEAKER_00 Еще одна интересная оптимизация - это исключения.
975.32 978.76 SPEAKER_00 Как вы наверное слышали, бросать исключения - это очень дорого.
978.76 993.80 SPEAKER_00 Конечно, если вы бросаете одно или два бизнес-исключения, может быть это не так страшно, но если мы говорим про уровень сокета и когда у нас там тысячи коннекций и там сокеты открываются-закрываются, то там исключения вполне могут дать какую-то просадку по производительности.
993.80 1011.20 SPEAKER_00 И вот авторы нашли одно место, которое бросало исключение на коннекшенах и это исключение в принципе было не обязательно, то есть вполне можно было бы обработать эту ситуацию без исключения, пробросать ее в более верхний слой обработки всех этих ошибок.
1011.20 1016.56 SPEAKER_00 В общем, просто-напросто убрали throw одного исключения.
1016.56 1029.68 SPEAKER_00 И это позволило уменьшить потребление CPU, только задумайтесь там с 50% до 40% на рынок-системах и всего лишь навсего выбрасывание одного исключения тогда, когда можно было бы этого не делать.
1029.68 1033.32 SPEAKER_00 В общем, бросать исключение это тоже зло, поэтому задумывайтесь прежде чем это делаете.
1033.32 1050.12 SPEAKER_00 И еще одна оптимизация, это новый классик, ну относительно новый, называется он PoolingAsyncValueTaskMethodBuilder, то есть это специальный класс, который применяется в довольно узких кейсах, когда вам нужно запулить value-таски.
1050.12 1056.96 SPEAKER_00 Если вы помните, что value-таски они сами были изобретены для того, чтобы в некоторых ситуациях можно было заменить таски.
1056.96 1062.48 SPEAKER_00 В общем, а теперь даже сами value-таски, сами структуры оказались слишком дорогими и их теперь можно пулить.
1062.48 1076.56 SPEAKER_00 Скорее всего вы никогда не встретите в своем коде надобности пулить value-таски, но если вы автор кестрила или там какого-нибудь сверхнагруженного протокола типа gRPC, вот там это вам может понадобиться.
1076.56 1091.08 SPEAKER_00 Если по цифрам, то запуская 1000 рядов swap-сокетов, раньше аллокейтилось 3000 стейт-машин, то есть стейт-машина, которая получается в результате вот этих await-тасков, то есть await-стейт-машина.
1091.08 1095.60 SPEAKER_00 Их было 3000 и они аллокейтились.
1095.60 1097.32 SPEAKER_00 Это было страшно.
1097.32 1104.20 SPEAKER_00 То есть ВЦ там тоже старался и это давало какие-то проблемы с перформансом.
1104.20 1111.84 SPEAKER_00 После того, как поставили пул в нужное место, а именно в дотнет-седьмом, таких аллокаций вместо 3000 стало 11.
1111.84 1115.00 SPEAKER_00 То есть это практически уже незаметно.
1115.00 1121.72 SPEAKER_00 Вот так пулинг нам помогает в каких-то местах, которым обращаются очень много раз.
1121.72 1126.16 SPEAKER_00 Каждое обращение, каждый аллокейт стейт-машины, он мизерный, он элементарный.
1126.16 1136.52 SPEAKER_00 Но если их набирается много-много, на 1000 клиентов, на 1000 коннекций, это уже становится существенно, это уже видно на профайлерах и это значит можно чинить.
1136.52 1138.92 SPEAKER_00 Следующие новинки по HTTP/2.
1138.92 1148.08 SPEAKER_00 В HTTP/2 у нас тоже была проблема с тем, что есть лог контеншен, то есть был лог контеншен.
1148.08 1153.76 SPEAKER_00 Там некоторые клиенты дрались за определенную очередь для того, чтобы разбирать себе задачи.
1153.76 1156.48 SPEAKER_00 И по-моему даже писать.
1156.48 1160.56 SPEAKER_00 Да, некоторые клиенты дрались для того, чтобы писать ответы уже после того, как все обработали.
1160.56 1162.80 SPEAKER_00 И здесь авторы пошли следующим путем.
1162.80 1165.00 SPEAKER_00 Они все переделали на ченнел.
1165.00 1177.16 SPEAKER_00 То есть в ченнел пишется определенные задачи, которые нужно сделать, а один-единственный консюмер обрабатывает эту очередь задач из ченнелов и делает всю основную работу для записи.
1177.16 1187.84 SPEAKER_00 То есть реально пишет один консюмер, то есть это значит, что мы в одном потоке загружаем весь сокет и никакой драки, никакого контеншена, ничего плохого не происходит.
1187.84 1199.64 SPEAKER_00 И соответственно это очень сильно убрало лог контеншен, подняло рпс с 1.2 млн до 6.8 млн рпс в данном конкретном бичмарке.
1199.64 1205.88 SPEAKER_00 Но самое интересное, что данная оптимизация подняла расход CPU на 100%.
1205.88 1212.08 SPEAKER_00 Раньше там были какие-то жалкие проценты, а сейчас CPU вырабатывал весь на 100% и это хорошо.
1212.08 1220.44 SPEAKER_00 Потому что теперь мы видим, что мы не упираемся в контеншен, то есть у нас работает железо на полную мощь, значит выдает максимум, что оно только может.
1220.44 1230.36 SPEAKER_00 Когда у нас был контеншен, у нас в профайле была ситуация, когда CPU еле нагружен, сеть еле нагружена, вроде как бы ресурсов полно, но ничего не происходит.
1230.36 1234.96 SPEAKER_00 Как раз таки все потому, что большинство воркеров ждали своей очереди на логах.
1234.96 1256.56 SPEAKER_00 В общем логи это страшная сила, поэтому если вы можете избежать их, обязательно избегайте, а если не можете избежать, то задумайтесь об одном из методов устранения логов, это вот в частности оставление одного консюмера, если это возможно, а все остальное загонять в очередь, или вот как мы обсуждали чуть выше, несколько воркеров, которые таскают задачи каждой своей очереди.
1256.56 1291.56 SPEAKER_00 Далее еще увеличили окно, так называемый upload window у кистерла в HTTP/2, что позволило загружать хорошо и быстренько большие файлы, например 100 мегабайтный файл, раньше грузился за 27 секунд, а сейчас он начал грузиться за 4 секунды, то есть вот такие большие огромные изменения, но опять же все нужно понимать, что игры с окном это тоже какой-то компромисс, в некоторых ситуациях он может дать какой-то плохой результат, в некоторых хороший, в общем здесь все на совести команды разработчиков, мы им поверим.
1291.56 1306.92 SPEAKER_00 В HTTP/3, HTTP/3 наконец-то вышел из экспериментальной стадии, теперь это вроде считается больше не эксперимент, но его по-прежнему не включили в .NET 7 по умолчанию, поэтому если вы захотите его юзать, вам придется его явно включить.
1306.92 1424.56 SPEAKER_00 Еще улучшили декодер и улучшили его в 900 раз, вот такие страшные цифры, вообще не понимаешь как оно раньше работало, ну не зря наверное это все в экспериментальном было, потому что там ничего не улучшали, 900 раз, тоже интересная техника, как добились 900 раз перформанса, все очень просто, заставили сжимать компрессор, заставили сжимать намного-намного эффективнее, чтобы вы понимали эффективность, раньше хидра сжимались до 109 байт, а теперь они сжимаются до 7 байт, это вообще все похоже на какой-то анекдот про архиватор, для которого осталось придумать только разархиватор, но на самом деле существует тоже такой интересный хак, когда у вас есть какой-то понятный предсказуемый набор список значений, как в нашем случае HTTP хедеры, ну наверное каждый из вас сталкивался, это какой-нибудь content type, content size, что там у нас еще есть, какой-нибудь агент, все сервер в его столице, какой-нибудь агент, еще что-то, ну вот стандартные HTTP хедера, они все объявлены спецификацией и каждый раз гонять полные их текстовые названия в ASCII строках, это довольно бессмысленно, даже если мы их сожмем, поэтому команда Durnet, команда ASP приняла следующее интересное решение, она просто-напросто присвоила каждому хедеру уникальный индекс и далее теперь пересылает не строчки с названиями хедеров, а индекс, вот там допустим индексу 42 соответствует хедер content type, сервер об этом знает, клиент об этом знает и соответственно если они оба договорились о правильных индексах, им не обязательно подправлять строки, они отправили там один байтик и уже всем все понятно какой хедер имеется в виду, вот такая немудреная оптимизация и сократила размер и увеличила перформанс и вообще позволила показать красивые графики нашим читателям.
1424.56 1434.24 SPEAKER_00 В Signal Area уменьшили аллокацию с помощью кэширования, аллокацию строк тоже популярная способ оптимизации, это кэширование, главное не забывайте когда его чистить.
1434.24 1466.52 SPEAKER_00 И в аутентификации также закэшировали policy_authorize_result, интересная оптимизация была сделана в http_results, http_results это такие специальные классики, которые возвращаются серверам в зависимости от того, что там произошло, самый частый случай это 200 окей, наверное все вам известны, когда возвращаете какой-то результат серверу, сообщаете ему, что все хорошо, в этот момент создается http_result, который умеет рендерить 200-ый респонс и он возвращается клиенту.
1466.52 1485.36 SPEAKER_00 Зоркий глаз заметил, что очень часто, особенно для каких-то общеизвестных статус кодов, вот эти http_results они по сути иммьютабельные, то есть в них практически никогда нет какого-нибудь стейта, и поэтому решили http_results просто закэшировать и переиспользовать.
1485.36 1503.72 SPEAKER_00 Но не просто закэшировали, а взяли и сгенерировали уже http_results по всем известным http кодам, потому что это очень частая ситуация, обычно наши клиенты не выдумывают каких-то хитроумных, наши серверы обычно не выдумывают каких-то хитроумных кодов, а возвращают то, что уже все знают и все давно есть.
1503.72 1511.36 SPEAKER_00 В общем вот эти всем известные коды взяли и закэшировали, то есть закэшировали, да, а для того, чтобы закэшировать их для начала сгенерили.
1511.36 1515.04 SPEAKER_00 И интересное в этой схеме в том, что сгенерили их с помощью t4-темплейтов.
1515.04 1533.68 SPEAKER_00 Вот мы как раз недавно обсуждали жив t4-темплейт или мертв, или его заменил рослин генераторой или что-то в этом духе, оказывается нет, жив, живее всех живых, и вот в последних релизах Dota 7 команда ISP активно использует t4-темплейты, отличная технология, хорошо, что живет.
1533.68 1551.72 SPEAKER_00 Еще один интересный момент в том, что для t4-темплейтинга они использовали не микрософтовскую реализацию, которая имеет свои минусы, а взяли монотекст-темплейтинг, то есть реализацию t4, ту, которая была сделана под моно, и вот ISP теперь юзает ее.
1551.72 1559.24 SPEAKER_00 Это кроссплатформенная реализация, соответственно, и дает все те плюсы t4, которые вы, скорее всего, сталкивались когда-нибудь под виндой.
1559.24 1578.72 SPEAKER_00 В общем, тоже прекрасная оптимизация, если вы можете что-нибудь сгенерить в дизайн тайме, то есть еще до того времени, когда вы начали компилировать, это всегда прекрасная идея, и самый лучший инструмент, который вам помогает это сделать, это t4, без него вообще никуда.
1578.72 1594.92 SPEAKER_00 У нас, кстати, недавно в сообществе SPB.net был докладик по t4, если кто-то вдруг не сталкивался, обязательно на доклад посмотрите, я думаю, многим может помочь, там как раз доклад очень практичный, упоминается очень много кейсов, в которых в том числе есть performance оптимизации.
1594.92 1596.60 SPEAKER_00 Так, погнали дальше.
1596.60 1610.24 SPEAKER_00 В фильтрах наконец-то додумались светлой умой заменить new object, то есть создание нового пустого массива на специальное редональное свойство, которое называется array.empty от object.
1610.24 1616.96 SPEAKER_00 Если вдруг в ваших проектах еще осталась аллокация нового пустого массива, то обязательно меняйте на array.empty.
1616.96 1620.32 SPEAKER_00 По-моему, сейчас уже все анализаторы это советуют, но вдруг вы почему-то упустили.
1620.32 1629.32 SPEAKER_00 И последняя оптимизация, о которой хотелось бы рассказать, это когда делают нескончаемый набор аргументов.
1629.32 1635.80 SPEAKER_00 Редко такая штука встречается, но иногда бывает, когда вам нужно передать количество аргументов, которые вы заранее не знаете.
1635.80 1638.44 SPEAKER_00 Вы обычно пишите по RAM и задаете это на массив объектов.
1638.44 1643.84 SPEAKER_00 Это стандартный подход, например, в логгерах он используется практически всегда.
1643.84 1647.40 SPEAKER_00 То есть, когда вы пишете log, вы не знаете, сколько параметров передастся.
1647.40 1650.84 SPEAKER_00 Там будет message template и плюс еще куча всяких параметров.
1650.84 1654.64 SPEAKER_00 В этом случае пишут обычно по RAM и массиву объектов.
1654.64 1656.52 SPEAKER_00 И все, и корренно все в огнем.
1656.52 1658.64 SPEAKER_00 Но хороший логгер, естественно, так не делает.
1658.64 1662.36 SPEAKER_00 И хорошие микрософтовские пайплайны в ASP тоже так не делают.
1662.36 1663.36 SPEAKER_00 Как делать правильно?
1663.36 1669.80 SPEAKER_00 Правильно все-таки взять, напрячься и скопипастить, сгенерить, добавить 10 отдельных методов.
1669.80 1675.52 SPEAKER_00 У первого метода будет один аргумент, у второго метода второй аргумент, у третьего три аргумента и так далее.
1675.52 1680.08 SPEAKER_00 То есть, поддержать самое адекватное, то есть, самое часто распространенное количество аргументов.
1680.08 1683.56 SPEAKER_00 И последнее можно сделать там уже с массивом объектов.
1683.56 1685.08 SPEAKER_00 Что это вам даст?
1685.08 1688.92 SPEAKER_00 Прежде всего, это позволит вам не аллокировать массив объектов.
1688.92 1695.72 SPEAKER_00 Потому что аллокация в частых случаях, ну, например, если мы возьмем логгер, логгер на самом деле пользуется очень часто.
1695.72 1702.08 SPEAKER_00 И там аллокация массива объектов – это уже какой-то performance penalty.
1702.08 1707.56 SPEAKER_00 То есть, уже могут с этим вылезти проблемы, и вы их на профилере точно увидите при интенсивном использовании.
1707.56 1708.56 SPEAKER_00 Вот.
1708.56 1714.08 SPEAKER_00 И вторая проблема – это в том, что обычно такой массив параметров, он задается как массив объектов.
1714.08 1716.48 SPEAKER_00 Потому что, по сути, вы не знаете, что туда положить.
1716.48 1718.24 SPEAKER_00 И это провоцирует боксинг.
1718.24 1723.44 SPEAKER_00 Боксинг – это еще одна такая невидимая штука, которая хорошо сажает performance.
1723.44 1730.68 SPEAKER_00 Если же вы делаете отдельные параметры, то вы можете использовать в этот момент дженерики.
1730.68 1739.72 SPEAKER_00 Никакого боксинга не будет, вы просто пишете t1, t2, t3, t4, и компилятор сам их раскладывает в правильные нужные вам типы, и эти типы подставляет во время компиляции.
1739.72 1743.00 SPEAKER_00 То есть, никакого боксинга не будет, никакого создания массива не будет.
1743.00 1751.56 SPEAKER_00 И в тех моментах, когда данные методы используются очень часто интенсивно, это очень сильно помогает вам улучшить performance.
1751.56 1756.24 SPEAKER_00 Вот такие основные новинки по performance в WSP.net Core.
1756.24 1760.96 SPEAKER_00 Думаю, что мы получим еще одни интересные тесты сразу после релиза.
1760.96 1769.96 SPEAKER_00 Пока ребята обновят какие-нибудь общие употребимые теком power, и посмотрим, что там у нас изменится с местами.
1769.96 1775.24 SPEAKER_00 Ну что ж, у нас осталась последняя статья по перформансу, давай перейдем уже к ней.
1775.24 1783.12 SPEAKER_01 Да, с перформансом у нас в этот раз все хорошо, и в этот раз мы посмотрим на перформанс MAUI, новую UI.
1783.12 1795.40 SPEAKER_01 Ну, не сказать, чтоб фреймворка, но по крайней мере, не сказать, чтоб нового, как наследника Xamarin.Forms, но тем не менее в нем тоже есть некоторые performance improvement по сравнению с .NET 6.
1795.40 1813.20 SPEAKER_01 MAUI в основном, ну он вообще предполагается то, что он должен быть полностью кроссплатформенным, но основной фокус сейчас, конечно же, на Android и на iOS, потому что там особые требования и к времени старта, и к размеру приложения, и там нужно более тщательно к этому всему подходить.
1813.20 1822.40 SPEAKER_01 Поэтому в этом релизе, в 7.NET, был фокус на Android и на iOS, и он был немножко разный.
1822.40 1834.88 SPEAKER_01 Согласно статье, для Android фокус был на производительности стартапа, то есть насколько быстро приложение запускается, потому что размер приложения был уже неплох, как у них написано.
1834.88 1835.88 SPEAKER_01 Was in good place.
1835.88 1845.60 SPEAKER_01 А для iOS наоборот, они фокусировались на размере приложения, потому что стартап тайм был in good shape, как опять же у них сказано.
1845.60 1851.36 SPEAKER_01 На одной платформе хорошо с размером, на другой платформе хорошо с временем старта.
1851.36 1858.64 SPEAKER_01 Но при этом у них был еще и кастомер фидбэк после шестерки, что в целом UI performance, то есть layout, scrolling и прочее надо улучшать.
1858.64 1861.60 SPEAKER_01 Ну в общем, примерно над этим и работали.
1861.60 1863.76 SPEAKER_01 И надо сказать улучшили.
1863.76 1877.96 SPEAKER_01 С одной стороны улучшили хорошо, с другой стороны чиселки ну прям такие как бы… когда я начал читать статью, они какие-то такие, ну не сказать смешные, но не очень убедительные что ли.
1877.96 1897.96 SPEAKER_01 То есть у них для примера, и мы может быть помните, обсуждали давным-давно, что у них появилось новое приложение, когда они начали разрабатывать Мауи, появилось новое, так скажем, модельное приложение, называется dotnet podcast app, то есть это некоторый каталог подкастов, который компилируется как Мауи приложение, и он кроссплатформенный.
1897.96 1914.24 SPEAKER_01 Соответственно для стартап тайма на андроиде это тестировалось на пятом пикселе, они улучшили по сравнению с шестеркой, было 814 мс, стало 759 мс, то есть улучшение где-то на 54 мс из 800.
1914.24 1922.60 SPEAKER_01 Ну как бы не знаю, лучше, но не сильно впечатляюще, было бы там 800-400, вот было бы да.
1922.60 1929.00 SPEAKER_01 А тут как-то улучшили, ну процентов на 7 получается, если так оценить.
1929.00 1940.12 SPEAKER_01 Немного, с размером на iOS примерно та же история, этот самый подкаст приложения занимал 25 мегабайт в варианте dotnet 6 и стал занимать 23.9 в варианте dotnet 7.
1940.12 1942.96 SPEAKER_01 Ну сэкономили 4% примерно.
1942.96 1948.64 SPEAKER_01 Не знаю, насколько это круто и хорошо, но наработали над этим много.
1948.64 1957.36 SPEAKER_01 И на самом деле вся статья это про то как раз-таки чем, какие подходы они использовали для того, чтобы этого всего добиться.
1957.36 1976.80 SPEAKER_01 И действительно можно посмотреть, что в некоторых местах startup time или с размером они прям выигрывали какие-то сотые доли секунды, не знаю там 16 мс сократили до 2 мс кусочки, то есть там они буквально профайлили вот такие вот места, то есть типа ооо вот здесь код занимает 16 мс, давайте его улучшим.
1976.80 1982.84 SPEAKER_01 Чего в обычной жизни конечно, ну вряд ли вы будете обращать свое внимание на код, который работает 16 мс.
1982.84 1987.64 SPEAKER_01 Здесь важна каждая мелочь, потому что даже она позволяет хоть что-то выиграть.
1987.64 1993.00 SPEAKER_01 И произвести свой вклад в общее дело.
1993.00 1999.24 SPEAKER_00 Ну знаешь, там 16 мс, здесь 16 мс, там уже 100 бабок это руб.
1999.24 2017.64 SPEAKER_01 Ну видимо на этом они и основывались, то есть понятно, что есть какие-то очень большие куски, которые возможно сейчас сделать сложно, ну просто потому что дотлен сам по себе, там требует поднять довольно много вещей, там и DC, и JIT, там где он доступен на андроиде, но все остальное они пытаются оптимизировать.
2017.64 2020.36 SPEAKER_01 И с деталями там примерно следующее.
2020.36 2029.36 SPEAKER_01 Во-первых, они сначала сделали приложеньку, на которой они пытались это все моделировать и измерять, насколько вообще хорошо-плохо.
2029.36 2035.48 SPEAKER_01 Приложенька есть вообще на самом деле стандартная, как они говорят, некоторые тесты такой модель на приложение, но они написали свое.
2035.48 2038.20 SPEAKER_01 Они написали свое в 5 вариантах.
2038.20 2051.04 SPEAKER_01 Приложенька, смысл этой приложеньки, он простой, он берет рандомный текст, ну на самом деле берет фиксированную строчку текста, и выводит его с рандомным поворотом и рандомным цветом на экран просто, в разных местах, опять же рандомно.
2051.04 2054.44 SPEAKER_01 И по сути просто мерить, сколько раз вы смогли это сделать за секунду.
2054.44 2076.96 SPEAKER_01 Текст они выбрали очень прикольный, текст они выводят лолы, поэтому у них метрика называется lols_per_seconds, и на Xamarin.Forms, если это написать прям стареньком, то это будет 179 штук в секунду, на .NET 6 Maui 327 штук в секунду, на .NET 7 493, то есть это в полтора раза больше.
2076.96 2098.08 SPEAKER_01 На .NET Android, то есть это .NET приложение, использующее нативные байнинги к Android, всяким контроллам и всему остальному, 594, то есть .NET Maui где-то на 20% отстает от полноценного .NET Android, и на Java он еще процентов на 20% отстает, на Java 682.
2098.08 2103.60 SPEAKER_01 Короче нужно .NET 7 Maui ускорить где-то раза в полтора, чтобы добраться до скорости Java.
2103.60 2108.60 SPEAKER_01 Ну Java, понятно, нативный язык для Android, поэтому там все быстрее максимально.
2108.60 2119.12 SPEAKER_01 И это на самом деле, вот это вот Interop с Java, это практически основной источник улучшения стартап тайма и вообще работы для .NET приложения.
2119.12 2124.68 SPEAKER_01 То есть и в стартапе требуется много Interop, и дальше при дальнейшей работе много Interop.
2124.68 2140.04 SPEAKER_01 И там написано в статье довольно много интересных и на самом деле довольно очевидных техник, ну типа если у вас есть пропертия, которые под капотом ходят в javaski Interop, ну наверное можно внутри одной функции эту пропертию запихнуть в локальную переменную и дальше пользоваться локальной переменной.
2140.04 2145.80 SPEAKER_01 Ну в C# мы привыкли, что пропертия обычно это дешевая штука, ну если правильно написано.
2145.80 2149.56 SPEAKER_01 То естественно код написан был исходя из того, что пропертия это дешевая штука.
2149.56 2160.28 SPEAKER_01 Но оказалось она в мире такого Interop и Maui не очень дешевая местами, и потому что идет в Java на каждую чтение пропертии, это не здорово.
2160.28 2169.24 SPEAKER_01 Во-вторых, есть например методы, которые вам нужно получить, например, дефолтную ширину-высоту экрана, для этого нужно дернуть javaski метод.
2169.24 2172.56 SPEAKER_01 Точнее вы дергаете два метода, получить ширину, получить высоту.
2172.56 2178.36 SPEAKER_01 Можно дернуть метод, который вернет структурку, но там накладные расходы на передачку этой структуры.
2178.36 2189.32 SPEAKER_01 Инфективнее всего передавать интеджеры или лонги, и поэтому они написали хелперный Java метод, который пакует ширину и длину в общий лонг, ну битовой магии, да, и потом это все возвращает в C#.
2189.32 2194.88 SPEAKER_01 В общем, такими методами 100 миллисекунд, 10 миллисекунд, вот таким образом это все и экономится.
2194.88 2198.24 SPEAKER_01 Дальше там пошли уже совсем какие-то извращенные техники с моей точки зрения.
2198.24 2206.40 SPEAKER_01 Например, они выяснили, что очень много времени уходит на вызов метода datetime_offset.now, но не метод на пропертии.
2206.40 2208.00 SPEAKER_01 Ну, по понятным причинам.
2208.00 2217.28 SPEAKER_01 UTC_NOW добыть легко, а NOW требует сходить в информацию о таймзоне, узнать, собственно, что за таймзона, зааджастить текущее время к текущей таймзоне.
2217.28 2221.48 SPEAKER_01 И вот эта вот загружка информации про таймзоны, она занимает время.
2221.48 2224.32 SPEAKER_01 Поэтому они сделали хитрый ход, я так и не понял, зачем.
2224.32 2235.12 SPEAKER_01 На старте они сначала читают информацию о таймзоне в джава-коде, передают ее из джава-кода в C# и используют эту информацию об оффсете во время стартапа.
2235.12 2246.88 SPEAKER_01 Одновременно они стартуют бэкграундный трет для загрузки этой же информации в C#-овый код, и как только эта информация загрузится, то все вычисления оффсетов переходят на C#-овые данные.
2246.88 2247.88 SPEAKER_01 Сложно.
2247.88 2248.88 SPEAKER_01 Сложно.
2248.88 2249.88 SPEAKER_01 Я не понял, в чем смысл.
2249.88 2256.84 SPEAKER_01 Возможно, потому что там что-то может поменяться, ну, по пути или еще как-то, или чтобы поведение точно соответствовало поведению C# везде и было одинаковым.
2256.84 2258.76 SPEAKER_01 Ну, а на стартапе будет немножко отличаться.
2258.76 2262.16 SPEAKER_01 Выглядит забавно, я не очень понимаю эту технику, но вот так сделано.
2262.16 2275.36 SPEAKER_01 Вот, в куче мест они постарались убрать передачу массивов, то есть часть AP-шек была сделана так, что она возвращает, например, не знаю, массив из трех элементов, ну, там RGB-компонент, например, или еще что-нибудь в таком духе.
2275.36 2276.36 SPEAKER_01 Вот.
2276.36 2284.12 SPEAKER_01 Интерроб массивов он сложный и медленный, как выяснилось, потому что для того, чтобы интерробить массивы между Java и C#, они их копируют всегда.
2284.12 2287.68 SPEAKER_01 То есть передача массива и туда и обратно - это обязательная копия.
2287.68 2295.84 SPEAKER_01 А поэтому, опять же, пришлось битовой магией схлопывать это все по возможности в одно число и передавать.
2295.84 2299.36 SPEAKER_01 Дальше к SAML они компилируют в IL-код сразу.
2299.36 2304.84 SPEAKER_01 То есть не хранят там в виде ресурсов, в виде еще чего-то, а стараются сразу компилировать в IL-код.
2304.84 2319.12 SPEAKER_01 Ну и для винды используют RadioTuran во все, значит, это самое, потому что RadioTuran - это хорошо, он там прикомпилирует все как надо, и тем самым улучшает стартап-тайм на десктопе на винде.
2319.12 2335.40 SPEAKER_01 Помимо этого пришлось делать кучу изменений в Mono, ну потому что под компотом там Mono крутится, интерпретатор, потому что, например, на iOS у вас нету JIT, а хочется поддерживать System Reflection Emit.
2335.40 2343.72 SPEAKER_01 Чтобы это сделать, на самом деле на iOS, как выяснилось, для меня это было новостью, вполне поддерживается System Reflection Emit.
2343.72 2347.84 SPEAKER_01 Но мы же не можем на iOS исполнять код, который мы только что сгенерили, там JIT нет.
2347.84 2353.20 SPEAKER_01 Поэтому для исполнения такого кода используется Mono Interpreter внутри, под компотом семерки.
2353.20 2372.04 SPEAKER_01 И туда завезли некоторый аналог Tyrate компиляции, то есть это, конечно, не компиляция, это интерпретация, но если Mono Interpreter понимает, что какой-то кусочек кода, который вы сгенерили, используется очень часто, он его как-то оптимизирует пооптимальнее и начинает выполнять быстрее.
2372.04 2385.36 SPEAKER_01 Ну и куча всяких разных, повыкидывали лишних вещей из джавовского кода, плюс вот это может быть практически интересная штука, написали тул, который позволяет мерить стартап тайм.
2385.36 2400.44 SPEAKER_01 Все измерения стартап тайма, которые я выше приводил, они сделаны не просто так секундомером, для этого написан специальный тул, который, если вам интересно, если вы вдруг зачем-то мерите стартап тайм вашего продукта, можете у Microsoft позаимствовать и использовать тот же самый тул.
2400.44 2406.08 SPEAKER_01 Может быть, они его даже оформят в виде полноценного dotnet тула, рассматривать такую возможность пока еще не сделали.
2406.08 2407.08 SPEAKER_01 Примерно так.
2407.08 2429.68 SPEAKER_01 Короче, MAUI — это такая забавная конструкция, то есть с одной стороны там довольно противоречивые требования, потому что и Android, и iOS, и десктопы, они все очень разные, везде свои особенности, везде свои проблемы, везде свои оптимизации, которые нужно делать, и они как-то пытаются это все балансировать так, чтобы в результате получилось удовлетворительный перформанс везде.
2429.68 2431.92 SPEAKER_01 Ну вот, как-то получается.
2431.92 2434.96 SPEAKER_01 Не знаю, я пока не видел, не знаю, слышал ты каких-нибудь,
2434.96 2443.44 SPEAKER_00 ну хоть каких-то приложений к этому MAUI? Наверное, еще нет, скорее всего все боятся, все ждут какую-то стабильную версию, и вот это, наверное, она и есть.
2443.44 2458.56 SPEAKER_01 Но с другой стороны, dotnet 7 — это не LTS, поэтому возможно сейчас на семерке начнут появляться какие-то экспериментальные приложения, и только к восьмерке, которая будет LTS, там вот уже, может быть, кто-то начнет что-то менять, переписывать или писать что-то новое.
2458.56 2480.92 SPEAKER_00 Так как UI-компоненты, то есть UI-продукты, вот эти, в общем, UI-ки — это довольно-таки сложные обычно вещи, и там очень много, очень плотная интеграция с самим фреймворком, то мне кажется, что те люди, которые, например, уже давно сидят на старых UI-ках и хотят куда-то переехать, то для них сейчас самое время уже начинать переписывать, чтобы к моменту стабильного выхода нового релиза через год у них уже было все готово.
2480.92 2486.24 SPEAKER_02 Да, согласен, но с другой стороны, как человек, который
2486.24 2501.68 SPEAKER_01 когда-то переписывал, ну не переписывал, а начинался писать на нестабильной версии WPF, ну как бы количество workaround-ов и bug-ов, которые были, не то чтобы это плохо, но эти workaround-ы жили потом долго даже после выхода стабильной версии.
2501.68 2504.96 SPEAKER_01 Поэтому… Да, такое тоже бывает, к сожалению.
2504.96 2507.36 SPEAKER_01 Тут надо будет тщательно балансировать.
2507.36 2518.44 SPEAKER_01 Ну ладно, в общем с performance у нас вроде как все, вернее как, ну у нас на этот выпуск все, мы скорее всего затронем, конечно, какой-то performance в следующем выпуске, когда будем говорить в целом про тот всем релиз.
2518.44 2522.72 SPEAKER_01 Еще раз напомню, что все стало лучше, выше, сильнее и быстрее.
2522.72 2525.44 SPEAKER_01 Ну а пока давай перейдем к другим вещам.
2525.44 2539.04 SPEAKER_00 Давай, я тут как раз наткнулся на одну такую фановую статьечку, которая нам расскажет и про новые методы, и про интеграцию с .NET, и вообще должна нас развлечь от всех вот этих performance низковыровневых вещей.
2539.04 2546.08 SPEAKER_00 А нашел я статью, которая рассказывает нам о том, а как добавить в WPF .NET экспериментальный новый метод.
2546.08 2560.76 SPEAKER_00 И я напомню, а для тех, кто не знал, расскажу, что сейчас в HTTP стандарте рассматривается новое ключевое слово, новый verb, новый глагол, который называется query.
2560.76 2564.76 SPEAKER_00 И вот его, в принципе, вы уже можете добавить в свои приложения.
2564.76 2568.40 SPEAKER_00 Давайте обсудим и посмотрим, как это можно сделать.
2568.40 2571.44 SPEAKER_00 Во-первых, что такое query и зачем он был нужен?
2571.44 2574.40 SPEAKER_00 Тут лучше всего начать с истории.
2574.40 2588.04 SPEAKER_00 Наверное, как многие из вас знают, что для того, чтобы запросить какую-то информацию с сервера, например, там список юзеров, список групп, еще какую-то подробную информацию об одном юзере, обычно люди используют метод get.
2588.04 2594.56 SPEAKER_00 Вы делаете get, потом передаете туда адрес ресурса, и вам возвращается то, что вы хотели.
2594.56 2603.00 SPEAKER_00 Если вы хотите добавить какие-то дополнительные параметры, например, вам нужен список не всех юзеров, а как-то вы хотите отфильтровать, это тоже делается элементарно.
2603.00 2611.52 SPEAKER_00 Вы просто в query строку записываете какой-нибудь фильтр с каким-нибудь экспрессионом, и тоже у вас, в принципе, все работает.
2611.52 2615.84 SPEAKER_00 Фильтр отработает на сервере, вам вернутся к значению, и в принципе все счастливы.
2615.84 2619.00 SPEAKER_00 Но у этого подхода есть большие ограничения.
2619.00 2624.40 SPEAKER_00 Во-первых, вся эта query строка, она должна быть заискепиана, заинкожена.
2624.40 2637.32 SPEAKER_00 После того, как она заинкожена, на нее накладываются всякие ограничения HTTP спецификации, что у нее там есть определенные ограничения по размеру, которые зависят тоже от браузера, от версии, от погоды на Марсе.
2637.32 2651.28 SPEAKER_00 Но суть в том, что если вам вдруг нужно эту query строку сделать большую, то вы упретесь в тот факт, что сделать это практически нереально, потому что HTTP протокол не поддерживает большие query строки.
2651.28 2655.64 SPEAKER_00 А строку сделать большую, на самом деле, это не такая редкая ситуация, как вам кажется.
2655.64 2673.60 SPEAKER_00 Если взять тот же самый произвольный фильтр, который вы туда накладываете, и прибавить туда какое-нибудь более сложное условие, например, если пользователь находится в таком-то списке имен и передавать туда список имен, то вы очень быстро уткнетесь в тот лимит, буквально передать там несколько десятков имен и все.
2673.60 2681.08 SPEAKER_00 И лимит достигнут, и ваше приложение уже не работает, уже агент делать не сможет.
2681.08 2686.52 SPEAKER_00 Человечество столкнулось с этой проблемой довольно давно, и, соответственно, есть несколько способов ее решения.
2686.52 2692.52 SPEAKER_00 Одним из самых простых и порицаемых – это использование вместо GET-а поста.
2692.52 2700.00 SPEAKER_00 POST в данном случае от GET-а отличается тем, что у GET-а не имеет права иметь BODY.
2700.00 2703.64 SPEAKER_00 То есть у GET-а BODY не бывает, у него только query-параметры.
2703.64 2707.44 SPEAKER_00 А вот в POST можно засунуть любой BODY.
2707.44 2716.68 SPEAKER_00 Соответственно, весь тот огромный запрос, который у вас не влез в предыдущем пункте в GET, вы очень легко можете селезнуть и засунуть его в BODY-поста.
2716.68 2722.44 SPEAKER_00 На BODY практически нет никаких ограничений, в общем, вам его хватит с головой всегда и везде.
2722.44 2738.20 SPEAKER_00 Соответственно, у нас уже будет метод, который называется POST к ресурсу, который называется USER, или может быть даже в этом случае уже GET-USER, и в качестве экспрессиона, в качестве фильтра мы в BODY передадим все, что нам нужно.
2738.78 2746.94 SPEAKER_00 Данный подход не зря полицаем народом, потому что POST имеет кучу проблем.
2746.94 2752.10 SPEAKER_00 Самая главная проблема, на которую все обращают внимание в первую очередь, это в том, что он не кашируется.
2752.10 2762.02 SPEAKER_00 Действительно, у нас HTTP в мир, у нас HTTP протокол, и вот этот весь World Wide Web, он существует на куче спецификаций и договоренностей.
2762.02 2767.62 SPEAKER_00 И одна из самых главных договоренностей существует в том, что метод GET можно кашировать.
2767.62 2774.42 SPEAKER_00 Если у него одинаковые параметры в query-строке, то значит можно безболезненно отдавать какой-то результат.
2774.42 2779.98 SPEAKER_00 Естественно, на какое-то время, не навсегда, но это очень сильно увеличивает перформанс.
2779.98 2793.06 SPEAKER_00 Я думаю, когда мы разбирали методы оптимизации и методы улучшения перформанса команды ISP.NET Core и прочих команд в Дот-нете, вы увидели, что очень много вещей решается там с помощью кэша.
2793.06 2798.90 SPEAKER_00 И кэш вам дает обалденный буст производительности, если вы знаете, когда его правильно чистить.
2798.90 2802.18 SPEAKER_00 И вообще это один из самых первых методов оптимизации.
2802.18 2805.94 SPEAKER_00 Поэтому кэширование на самом деле это очень важно.
2805.94 2816.44 SPEAKER_00 Особенно если мы смотрим на сеть интернет, в которой там идут сексилиарды запросов в миллисекунду, то там кэширование становится просто ключевым фактором и просто так терять его не хотелось.
2816.44 2831.22 SPEAKER_00 Но если вы используете метод POST и передаете аргументы в BODY, то кэширование вы теряете на вот таких промежуточных узлах, которые вполне могли бы обеспечить более быстрый доступ к вашим методам.
2831.22 2835.50 SPEAKER_00 В большинстве случаев на это все забивали, потому что это было меньше изол.
2835.50 2840.22 SPEAKER_00 Если там мы просто в GIT не могли ничего сделать, то в POST мы всего лишь на все теряем кэширование.
2840.22 2850.74 SPEAKER_00 Ну, наверное, для большинства запросов это нормальная ситуация, но все же остаточек оставался.
2850.74 2862.14 SPEAKER_00 И как раз таки, чтобы убрать эту проблему, весь консорсум World Wide Web собрался и наконец-то в 21 веке придумал новое ключевое слово, которое называется QUERY.
2862.14 2881.06 SPEAKER_00 Это ключевое слово имеет полностью семантику GET, его же плюсы, то есть оно подразумевает, что все прокси будут кэшировать ответ, также подразумевается, что QUERY, так же как и GET, он иденпатентный, и ему прибавляется плюс POST.
2881.06 2883.42 SPEAKER_00 QUERY теперь может иметь BODY.
2883.42 2891.10 SPEAKER_00 В общем, в этот BODY можно засунуть опять же все, что вам угодно, даже тот expression, который вам нужно было бы передать, и он большой, страшный и все такое.
2891.10 2894.50 SPEAKER_00 Но теперь вы можете его засунуть в BODY, и это все будет кэшироваться.
2894.50 2897.14 SPEAKER_00 Вот ради этого изобрели новое слово.
2897.14 2900.06 SPEAKER_00 Слово, которое объединяет и GET, и POST.
2900.06 2902.94 SPEAKER_00 Теперь в BODY вы можете положить все, что угодно.
2902.94 2912.70 SPEAKER_00 Например, вы туда можете засунуть GRAPHQL, вы туда можете засунуть полноценный SQL SCRIPT, вы туда можете даже LINK положить, потому что теперь это можно.
2912.70 2916.14 SPEAKER_00 Теперь фильтр может быть вообще произвольной и произвольной длины.
2916.14 2921.82 SPEAKER_00 Теперь там можно и запросы вкладывать, и батчинги вкладывать, и скрипты вкладывать, вообще все, что вам только придет в голову.
2921.82 2925.38 SPEAKER_00 Вот консорциум такую штуку придумал.
2925.38 2928.46 SPEAKER_00 Отлично, но в официальном кестре она еще не появилась.
2928.46 2935.38 SPEAKER_00 Давайте же посмотрим, а как можно ее уже сейчас добавить в ваше приложение, и что для этого нужно сделать.
2935.38 2937.90 SPEAKER_00 Для начала рассмотрим MINIMAL API.
2937.90 2943.14 SPEAKER_00 На самом деле не нужно очень много кода для того, чтобы держать вот такую ключевую концепцию, как новое слово.
2943.14 2951.54 SPEAKER_00 А все потому, что на самом деле в HTTP протоколе не задекларирован какой-то строгий список этих глаголов.
2951.54 2954.62 SPEAKER_00 На самом деле вы туда можете передать абсолютно любой глагол.
2954.62 2958.58 SPEAKER_00 Другой вопрос, кто его будет поддерживать и как он будет обрабатываться, это дело десятое.
2958.58 2963.06 SPEAKER_00 Но вы можете, судя по самой спецификации протокола.
2963.06 2967.14 SPEAKER_00 Вот и здесь в принципе протокол никак нам не запрещает использовать новое слово.
2967.14 2973.30 SPEAKER_00 Нам осталось лишь научить наш MINIMAL API, наши хендлеры, наш ASP.NET обрабатывать эту штуку.
2973.30 2975.46 SPEAKER_00 И обработка тоже делается достаточно просто.
2975.46 2989.10 SPEAKER_00 Все, что вам нужно сделать, это сделать специальный метод, который называется MapQuery, по аналогии с другими экстеншн методами, который MapGet, MapPost, которые мапят соответствующий URL на его обработчик.
2989.10 3004.38 SPEAKER_00 В этом методе MapQuery у вас будет Endpoint Convention Builder, у которого достаточно вызвать метод MapMethod и передать ему этот глагол, то есть передать ему просто Query.
3004.38 3013.78 SPEAKER_00 В общем, этого достаточно для того, чтобы кестер сообразил, что как только вам приходит вот этот неизвестный глагол, должен вызываться ваш делегат.
3013.78 3017.62 SPEAKER_00 А в делегате уже непосредственно происходит обработка события.
3017.62 3026.78 SPEAKER_00 Этот делегат в MINIMAL API может принимать специальный класс, который описывает тот запрос к нему, как только к нему пришел.
3026.78 3029.14 SPEAKER_00 Это, допустим, класс Query.
3029.14 3040.74 SPEAKER_00 Теперь все, что вам нужно сделать, это создать вот этот класс Query и переопределить у него метод BindAsync, который при качестве параметра принимает HTTP контекст и параметр List.
3040.74 3055.78 SPEAKER_00 Как вы уже догадались, из HTTP контекста и из параметров вам нужно каким-то образом, известным только вашему обработчику, достать параметры, в нашем случае просто-напросто считать Body и положить его уже в какую-то заранее переменную для децерализованных данных.
3055.78 3058.14 SPEAKER_00 И дальше эта переменная будет доступна в делегате.
3058.14 3071.26 SPEAKER_00 Таким образом, вы можете теперь регистрировать ваши новые делегаты с помощью метода MapQuery, указывать route и принимать в качестве параметра тот децерализованный классик Query, который мы разобрали секунду назад.
3071.26 3073.62 SPEAKER_00 Обращаться, соответственно, к его свойствам.
3073.62 3075.10 SPEAKER_00 Все легко и просто.
3075.10 3078.54 SPEAKER_00 Как же сделать подобную штуку в ASP.NET Core MVC?
3078.54 3080.86 SPEAKER_00 На самом деле, еще проще.
3080.86 3088.78 SPEAKER_00 Вы просто-напросто добавляете еще один атрибут, например, HTTP Query атрибут, который наследуется от специального HTTP метод атрибута.
3088.78 3097.62 SPEAKER_00 И HTTP метод атрибут в конструкторе принимает список методов, которые поддерживает ваш вот этот вот атрибут.
3097.62 3100.30 SPEAKER_00 Естественно, вы туда передаете строку Query.
3100.30 3115.78 SPEAKER_00 Как только вы это сделали, со этого самого момента, вы можете навешивать ваш HTTP Query атрибут над вашими экшенами, над вашими методами контроллера, точно так же, как вы раньше навешивали HTTP GET, HTTP POST.
3115.78 3118.82 SPEAKER_00 Теперь у вас будет просто-напросто HTTP Query атрибут.
3118.82 3124.62 SPEAKER_00 И ваш метод уже будет дергаться непосредственно, как только придет Query глагол к кестрелу.
3124.62 3126.86 SPEAKER_00 Кестрел уже знает, что с ним делать.
3126.86 3127.94 SPEAKER_00 Вот в принципе вот так.
3127.94 3129.98 SPEAKER_00 Все намного проще, чем казалось.
3129.98 3133.26 SPEAKER_00 И поддерживается и в старых версиях, и в новых версиях, и где угодно.
3133.26 3137.98 SPEAKER_00 Лишний раз доказывается, что ASP.NET расширяется просто великолепно.
3137.98 3144.26 SPEAKER_00 В общем, если вы вдруг захотите использовать этот Query атрибут по-настоящему в вашем продакшн коде, то вот здесь вот сильно не торопитесь.
3144.26 3148.30 SPEAKER_00 Ну, во-первых, это все-таки еще экспериментальный метод.
3148.30 3151.86 SPEAKER_00 Все еще идут обсуждения, все еще идут какие-то договоренности.
3151.86 3157.26 SPEAKER_00 И в частности, он не поддерживается во многих сторонних инструментах.
3157.26 3160.58 SPEAKER_00 Во многих инструментах, которые окружают вас ежедневно.
3160.58 3168.18 SPEAKER_00 Ну, например, тот же самый Swashbuckle, который также известен как Swagger, который также известен как Open API Library.
3168.18 3171.14 SPEAKER_00 В общем, он еще не понимает этот новый кейворд.
3171.14 3177.34 SPEAKER_00 Соответственно, вы не сможете с помощью него отлаживать, запускать методы, которые вызываются с помощью Query.
3177.34 3182.78 SPEAKER_00 Также точно практически никто из инфраструктуры не поддерживает Query.
3182.78 3189.34 SPEAKER_00 То есть, вы можете потерять кэширование, load balancing и прочие вещи на сторонних каких-то инструментах.
3189.34 3194.02 SPEAKER_00 На Jinx, на Lastic Load Balancer и на прочей инфраструктуре.
3194.02 3196.74 SPEAKER_00 Они тоже пока еще не очень знают, что с ним делать.
3196.74 3205.86 SPEAKER_00 Эта поддержка добавляется, безусловно, я думаю, через некоторое время все главные библиотеки, все главные инструменты, которые развиваются, такую штуку к себе добавить.
3205.86 3208.62 SPEAKER_00 Но пока ситуация именно такая.
3208.62 3210.66 SPEAKER_00 Используется все на ваш страх и риск.
3210.66 3217.90 SPEAKER_00 Если вы вдруг захотите это использовать в продакшене, то обязательно смотрите, какими инструментами вы используетесь и проверяйте проверку у них.
3217.90 3225.18 SPEAKER_01 Ну, я что-то думаю, что пока это не будет поддержано в максимально большом количестве тулов, использовать это, ну не знаю зачем.
3225.18 3234.70 SPEAKER_01 Если это между вашими двумя приложениями, так можно и просто постом, а если куда-то наружу, так там в интернете мало кто это поддерживает, нормально пока еще, мне кажется.
3234.70 3240.02 SPEAKER_00 Да, к сожалению, мы не знаем через какие роутеры пройдет эта штука и какая версия, какого ПО там стоит.
3240.02 3241.58 SPEAKER_00 Поэтому мы можем только надеяться.
3241.58 3248.88 SPEAKER_01 Но пока у нас твой страх и риск, можно поэкспериментировать, не знаю, добавлять поддержку этой штуки в разные другие тулы.
3248.88 3250.86 SPEAKER_01 Вам, может, спасибо скажут за это.
3250.86 3253.22 SPEAKER_01 И потом все начнем использовать резко.
3253.22 3258.86 SPEAKER_01 Давай пойдем дальше, в другую часть нашего замечательного фреймворка.
3258.86 3261.22 SPEAKER_01 Ты знаешь ли ты, что такое memory model?
3261.22 3262.22 SPEAKER_01 Да, конечно.
3262.22 3264.50 SPEAKER_00 Знаешь ли ты, какая она у .NET?
3264.50 3267.62 SPEAKER_00 Я знаю в том, что она у .NET неформализованная.
3267.62 3268.62 SPEAKER_01 Ну, как?
3268.62 3270.90 SPEAKER_01 Значит, на самом деле у нас есть спека.
3270.90 3276.22 SPEAKER_01 Спека называется ECMO-335, насколько я помню, на рантайм, да?
3276.22 3279.00 SPEAKER_01 И технически там что-то описано.
3279.00 3289.96 SPEAKER_01 Но то, что там описано, оно очень, то, что называется weak, то есть оно слабое, то есть оно подходит под много чего и дает очень мало.
3289.96 3295.72 SPEAKER_00 Она мега абстрактная и какие-то конкретные вещи, которые вам нужно ответить на вопрос, а здесь что будет?
3295.72 3297.92 SPEAKER_00 Вот обычно на такие конкретные вещи она не отвечает.
3297.92 3301.20 SPEAKER_01 Ну, она не отвечает в том смысле, что она разрешает довольно много всего.
3301.20 3307.86 SPEAKER_01 То есть рантайм, который удовлетворяет ECMO-335, может делать, ну не то чтобы все что угодно, но там довольно мало ограничений.
3307.86 3332.06 SPEAKER_01 В реальной жизни рантайм, он гораздо более ограничен, потому что исторически .NET Runtime развивался на железе, которое чуть более ограничено, и даже сейчас, когда мы переехали, ну не переехали, а позволили поддерживать и армы и всякие странные процессоры, реалии таковы, что реальные железные ограничения все равно сильнее, чем ECMO, насколько я понимаю.
3332.06 3346.16 SPEAKER_01 Поэтому в репе .NET Runtime появилась наконец-таки идея сделать нормальное описание .NET Memory Model, а что же собственно текущий современный .NET Runtime в принципе сейчас предоставляет.
3346.16 3359.16 SPEAKER_01 Он предоставляет некоторый компромисс, чтобы быть разумно работающим на всех платформах и при этом все еще удовлетворять ECMO-335, и при этом чтобы это было как-то нормально, понятно, используемо.
3359.16 3373.16 SPEAKER_01 И появился pull request, он появился где-то в сентябре, если я правильно помню, в котором появилась некоторая, просто видите, страничка в том самом ботере буквы Runtime, где написано .NET Memory Model.
3373.16 3377.00 SPEAKER_01 Если вы хотели узнать, что же такое .NET Runtime Memory Model, вам туда.
3377.00 3399.64 SPEAKER_01 Это пока еще не финальный вариант, там активнейшее обсуждение, там пришли все самые умные люди из Runtime и все это дело активно обсуждают, то есть я там не то чтобы половину комментов не понял, но чтобы их понять надо реально хорошо вчитываться, кто там куда, кого заимствует, кто как читает, какие reordering разрешены и все такое прочее.
3399.64 3408.68 SPEAKER_01 Но если вам это интересно, если вы всегда хотели узнать, как же по-настоящему работает volatile, что он гарантирует, что он не гарантирует, то идите туда и посмотрите.
3408.68 3421.60 SPEAKER_01 Также там есть интересная секция, последняя в этом документе, это практически примеры того, как же нужно реализовывать правильно паттерны, то есть типа условный double check log для singleton, вот этого всего.
3421.60 3436.04 SPEAKER_01 Там это все написано правильно, ну даже не то чтобы правильно, а минимально необходимо, то есть понятно, что можно все обвесить логами и все будет работать, но на самом деле местами достаточно делать volatile read и volatile write и все тоже будет работать.
3436.04 3440.28 SPEAKER_01 Вот там написано как бы минимально правильные примеры, как это нужно все делать.
3440.28 3448.52 SPEAKER_00 Вот это интересный вопрос, знаешь, обычно на собеседование задают, типа реализуйте мне самый примитивный какой-нибудь double checking log.
3448.52 3472.12 SPEAKER_00 На самом деле, если придерживаться официальной спецификации memory module, то однозначно реализовать его невозможно, потому что, ну однозначно примитивный, самый минимальный реализовать невозможно, потому что мы не знаем, как ведет себя memory module и мы не знаем, где эта штука будет запускаться, это зависит от рантайма, от версии и от железа и от много всего еще.
3472.12 3478.04 SPEAKER_00 Поэтому такой простейский вопрос, на который, наверное, уже каждый джун отвечает, на самом деле не имеет ответа.
3478.04 3482.00 SPEAKER_01 Ну, как бы да, каждый джун отвечает, делаем log, да.
3482.00 3483.92 SPEAKER_01 Да, делаем два лока и все хорошо.
3483.92 3487.24 SPEAKER_01 Нет, подожди, один log, два if, if log, if.
3487.24 3488.24 SPEAKER_01 Да, два if.
3488.24 3497.76 SPEAKER_01 Вот, и как бы везде, где работает dotnet, работать будет, потому что dotnet runtime, он вот некоторые гарантии дает.
3497.76 3501.88 SPEAKER_01 Но на самом деле можно написать его чуть более оптимально, вот это все.
3501.88 3515.76 SPEAKER_01 Поэтому если вам интересна тема вот этих всех memory modules, да, acquired read, write, reordering, вот это все, идите, читайте, участвуйте в обсуждении, задавайте вопросы, там довольно все активно живет.
3515.76 3526.24 SPEAKER_01 PR, не знаю, когда будет реально закоммичено, я думаю, что они будут долго обсуждать, пока не придут к какому-то общему пониманию и правильным примерам и терминологии.
3526.24 3532.52 SPEAKER_01 Там не только обсуждается непосредственно, что же мы реализовали и как оно на самом деле работает, но и какими примерами это лучше иллюстрировать.
3532.52 3540.20 SPEAKER_01 То есть там часть, по крайней мере, комментов, которые я читал к этому pull request, они про то, что вот этот пример не совсем характерен, давайте лучше вот такой возьмем.
3540.20 3552.36 SPEAKER_01 А если вы новичок и вам, в принципе, интересно, что такое memory module, то у нас в шоу-ноутах будет еще ссылочка на очень старый доклад Саши Гальштейна на dotnext про C++ и CLR memory modules.
3552.36 3573.84 SPEAKER_01 Тогда не было ничего еще стандартизированного и формализованного, но некоторое понимание того все-таки, как работает CLR memory module в то время, это 6 лет назад, уже было, некоторое понимание было, и он как раз-таки рассказывает вообще, что это такое, как к этому подходить и какие основные термины, концепции есть и чем они на самом деле отличаются от плюсов, если вам это интересно.
3573.84 3585.04 SPEAKER_00 Кажется, именно там у него есть такие смешные демки, которые казалось бы абсолютно правильный код, и который все пишут и все такое, работает немножко не так, как на самом деле.
3585.04 3598.64 SPEAKER_01 Да, я помню, что доклад был хороший, давно его не пересматривал, надо будет действительно как-нибудь посмотреть, как раз и memory module почитать современную, чтобы уяснить себе-таки, как оно работает, и как же правильно надо отвечать на вопросы на собеседованиях.
3598.64 3609.20 SPEAKER_00 Я думаю, когда этот доклад выйдет, мы там не один доклад на эту тему еще должны увидеть, услышать и не одну статейку прочитать, потому что труд действительно нужный, монументальный.
3609.20 3615.96 SPEAKER_00 Конечно, интересно, что его делают постфактум, когда уже все состоялось, и обычно memory module делают в самом начале, когда пишут runtime.
3615.96 3617.96 SPEAKER_00 Но что имеем, то имеем.
3617.96 3627.00 SPEAKER_01 Не, ну как бы, может быть она в каком-то виде и есть в головах у тех, кто пишет этот самый runtime, просто это некоторая попытка его формально записать в понятном виде.
3627.00 3634.76 SPEAKER_00 Я думаю, она есть в коде, то есть runtime как-то работает по какой-то модели, и сейчас пытаются именно ее описать и как-то подогнать под теорию.
3634.76 3644.56 SPEAKER_01 Ну и хорошо, пошли в еще одну интересную тему, как я сказал, дотунайт работает много где, и в том числе на Raspberry.
3644.56 3648.00 SPEAKER_00 Да, продолжаем рубрику, расширяем горизонты.
3648.00 3656.48 SPEAKER_00 Хочется еще об некоторых технологиях вам рассказать, может быть, которые почему-то вы еще не слышали, и это мы устраним с помощью нашего образовательно-новостного подкаста.
3656.48 3665.36 SPEAKER_00 Хочется рассказать о том, каким же образом все-таки запустить дотнет через WASM на Raspberry Pi.
3665.36 3669.24 SPEAKER_00 Вот такая сложная цепочка, давайте посмотрим по каждому пункту в отдельности.
3669.24 3672.24 SPEAKER_00 Во-первых, для тех, кто в танке, что такое WASM.
3672.24 3677.84 SPEAKER_00 Вы с WASM знакомы, наверное, давно, когда еще в дотнете появились первые версии Blazor, Blazor WebAssembly.
3677.84 3685.68 SPEAKER_00 Это такая специальная технология, которая позволяет вам дотнет компилировать прямо под браузер, грубо говоря, под движок джаваскрипта.
3685.68 3693.60 SPEAKER_00 И, соответственно, браузер может выполнять вашу программу, не обращаясь к серверу, даже вообще не имея никакого коннекта к серверу, вообще даже офлайн.
3693.60 3696.36 SPEAKER_00 Он один раз загружает сборочку и выполняет ее.
3696.36 3699.08 SPEAKER_00 И это достигается с помощью технологии WASM.
3699.08 3703.60 SPEAKER_00 WASM прекрасен тем, что он не только для дотнета.
3703.60 3713.92 SPEAKER_00 Поэтому, когда сравнивают почему-то Blazor с Silverlight, вот здесь, безусловно, нужно учитывать, что это не какая-то плагина от Microsoft, которая нужна только для дотнета.
3713.92 3715.48 SPEAKER_00 Нет, WASM пошел другим путем.
3715.48 3720.48 SPEAKER_00 Теперь это встроенная фишка во все современные браузеры, в том числе в мобильные.
3720.48 3730.12 SPEAKER_00 Поддерживается она очень многими производителями и достойными всеми нормальными языками.
3730.12 3735.48 SPEAKER_00 На самом деле это набор бинарных инструкций для специальной stack-based virtual машины.
3735.48 3744.48 SPEAKER_00 Это, как я уже сказал, язык программирования, который не зависит от архитектуры.
3744.48 3751.68 SPEAKER_00 То есть он очень портабельный, он выполняется абсолютно везде, где может выполняться в данном случае браузер и JavaScript.
3751.68 3754.92 SPEAKER_00 А это, как мы понимаем, практически любая платформа.
3754.92 3759.48 SPEAKER_00 Он очень низкоуровневый, он больше похож на Assembler.
3759.48 3770.68 SPEAKER_00 Если вы когда-нибудь интересовались, заглядывали или гуглили, как выглядят Assembler инструкции, или если вы заглядывали в .NET.IL, то WASM напоминает именно его.
3770.68 3774.56 SPEAKER_00 То есть это минимальные Assembly инструкции для виртуальной машины.
3774.56 3783.12 SPEAKER_00 Он бинарный и он очень компактный, потому что сразу рассчитывалось на то, что будут передавать по сети, поэтому он должен быть очень сжатым, красивым, быстрым.
3783.12 3786.28 SPEAKER_00 В общем, и этого удалось достигнуть.
3786.28 3795.02 SPEAKER_00 И самое интересное, что его перформанс довольно высокий, потому что многие браузеры его поддерживают нативно.
3795.02 3806.32 SPEAKER_00 И там были выбраны специально, подобраны инструкции таким образом, чтобы они хорошо ложились на векторизацию, на нативные команды процессора, на нативные команды видеокарт и прочее, прочее.
3806.32 3821.60 SPEAKER_00 То есть язык разрабатывался специально для трехмерной реальности, для виртуальных игр, для еще вот таких вот очень ресурсов, таких активностей, которые требуют очень много производительности.
3821.60 3825.80 SPEAKER_00 Поэтому он получился довольно компактный, довольно хорошо производительный.
3825.80 3834.72 SPEAKER_00 И как я уже упомянул, нормальные языки, такие как C#, C, C++, Rust, все недавно умеют и хорошо компилироваться именно в WASM.
3834.72 3841.56 SPEAKER_00 Таким образом у нас получается, что WASM — это такой интересный кроссплатформенный формат.
3841.56 3850.88 SPEAKER_00 Наверное, многие большевики рассчитывали и надеялись на то, что у нас появится какой-нибудь формат, куда можно один раз скомпилировать и запускать абсолютно на всех платформах, на везде.
3850.88 3856.24 SPEAKER_00 Но вряд ли кто-то мог представить, что это будет какой-то там отросток от JavaScript.
3856.24 3858.28 SPEAKER_00 Но по сути получилось именно так.
3858.28 3870.12 SPEAKER_00 Намного легче было написать кроссбраузерный JavaScript, захватить мир и потом на JavaScript сделать оптимизированный общесистемный низкоуровневый язык.
3870.12 3871.12 SPEAKER_00 Получилось смешно.
3871.12 3874.12 SPEAKER_00 Но, как ни странно, получилось очень хорошо.
3874.12 3879.88 SPEAKER_00 И народ подхватил эту идею и подумал, а зачем нам обязательно запускать это все в браузере.
3879.88 3883.32 SPEAKER_00 В принципе, получился отличный формат, поддерживается многими языками.
3883.32 3890.16 SPEAKER_00 Он быстрый, он компактный, он интересный, он довольно легко читается и понимается.
3890.16 3896.12 SPEAKER_00 А давайте мы будем его использовать как обычный формат для любого языка программирования.
3896.12 3902.68 SPEAKER_00 То есть, по сути, запускать все эти приложения не в браузере, а запускать все эти приложения вообще на любом хосте.
3902.68 3905.48 SPEAKER_00 И таким образом появился Wasi.
3905.48 3908.64 SPEAKER_00 Wasi – это WebAssembly System Interface.
3908.64 3918.96 SPEAKER_00 Это как раз-таки отдельный стандарт для Wasmo, который рассказывает о том, каким образом Wasmo взаимодействовать с любым окружением на хосте.
3918.96 3921.68 SPEAKER_00 Хостом может быть любая операционная система.
3921.68 3927.56 SPEAKER_00 Его можно запускать на чистом Linux, на Android, на Windows и вообще где угодно.
3927.56 3929.08 SPEAKER_00 Везде, где что-то запускается.
3929.08 3938.20 SPEAKER_00 Вот каким образом из песочницы JavaScript перетащить его на полноценную операционную систему, этим и занимается как раз вот этот System Interface.
3938.20 3944.56 SPEAKER_00 То есть, это набор API, с помощью которого WebAssembly может вызывать нативные хостовые методы.
3944.56 3951.40 SPEAKER_00 Таким образом, Wasi помогает вам запустить вашу Wasm-сборку без браузера на чистом хосте.
3951.40 3956.76 SPEAKER_00 И для того, чтобы это сделать, нам нужны соответствующие рантаймы, которые реализуют данный подход.
3956.76 3962.32 SPEAKER_00 Из известных есть WasmTime, Wasmir или WasmEdge.
3962.32 3964.52 SPEAKER_00 Давайте же теперь посмотрим, как это все связано с .NET.
3964.52 3966.76 SPEAKER_00 На .NET очень легко получить Wasi Project.
3966.76 3973.04 SPEAKER_00 Для этого вам достаточно всего лишь на все немножко поменять стандартный WebAPI проект.
3973.04 3979.88 SPEAKER_00 После этого вы можете создать обычный WebAPI проект, допустим, даже с дефолтным вот этим приложением, который там погодку нам показывает.
3979.88 3983.92 SPEAKER_00 Оставим его таким же точно пустым, сделаем .NET Publish -c release.
3983.92 3993.64 SPEAKER_00 И в результате, на выходе в Output мы уже получим не какую-то сборочку или .exe, а получим файл с расширением Wasm.
3993.64 3997.88 SPEAKER_00 Этот файл можно запустить, допустим, прямо на Windows.
3997.88 3999.68 SPEAKER_00 Для этого нам понадобится WasmTime.
3999.68 4004.72 SPEAKER_00 WasmTime – это очень быстрая и security runtime для WebAssembly.
4004.72 4014.04 SPEAKER_00 Это как раз таки и есть та запускалка, которая способна интерпретировать код Wasm на многих операционных системах.
4014.04 4018.56 SPEAKER_00 Мы можем скачать WasmTime с GitHub.
4018.56 4020.08 SPEAKER_00 Вызывается все довольно просто.
4020.08 4026.84 SPEAKER_00 WasmTime, пробел и указываем имя того Output приложения, которое у нас появилось с расширением .wasm.
4026.84 4029.56 SPEAKER_00 Как только мы его указали, у нас запустится это приложение.
4029.56 4035.68 SPEAKER_00 Можно сделать проще, можно просто даже запустить .NET Run, если мы находимся в каталоге с нашим Wasi Solution.
4035.68 4039.68 SPEAKER_00 И .NET Run вам, соответственно, запустит приложение.
4039.68 4048.32 SPEAKER_00 Вы после этого можете открыть браузер, зайти на Localhost и убедиться, что весь WPPI отвечает вам стандартными отчетами про коду.
4048.32 4054.30 SPEAKER_00 Вот так просто получить из .NET Wasm.
4054.30 4055.60 SPEAKER_00 Мы на этом не останавливаемся.
4055.60 4059.16 SPEAKER_00 Мы хотим запульнуть наш Wasm на Raspberry Pi.
4059.16 4066.44 SPEAKER_00 Если кто не знал, то в последних Windows давно SSH и SCP входят в коробочную версию.
4066.44 4069.16 SPEAKER_00 То есть, поставляются out of box эти утилиты.
4069.16 4078.80 SPEAKER_00 С помощью SSH мы можем коннектиться к удаленному хосту по протоколу SSH, а с помощью SCP мы можем просто-напросто скопировать какой-то файлик на удаленный хост.
4078.80 4080.16 SPEAKER_00 Чем мы, собственно, и займемся.
4080.16 4085.64 SPEAKER_00 Возьмем этот файлик с Wasm и скопируем его с нашего PC на Raspberry Pi.
4085.64 4090.36 SPEAKER_00 После этого мы с помощью SSH можем подконнектиться к Raspberry Pi.
4090.36 4094.40 SPEAKER_00 Там нам нужно снова установить WasmTime для Raspberry Pi.
4094.40 4100.84 SPEAKER_00 Это делается с помощью скачивания с GitHub, разархивирования и у нас уже есть готовый запускальщик в WebAssembly.
4100.84 4108.24 SPEAKER_00 Точно так же WasmTime, пробел, наш файлик .wasm и на Raspberry Pi все точно так же запускается.
4108.24 4116.24 SPEAKER_00 Вот таким образом выглядит эра кроссплатформенности, межязыковости и так далее.
4116.24 4122.28 SPEAKER_00 Тут уже опять еще раз стоит напомнить, что эти Wasm файлы их может генерить абсолютно любой язык программирования.
4122.28 4124.48 SPEAKER_00 Любой нормальный современный язык программирования.
4124.48 4129.12 SPEAKER_00 То есть вы можете собрать какие-то утилиты с помощью разных языков.
4129.12 4131.96 SPEAKER_00 Вы можете писать плагины с помощью разных языков.
4131.96 4138.76 SPEAKER_00 Уже мы никак не опираемся на совместимость с архитектурой, с операционной системой, еще с чем-то.
4138.76 4142.76 SPEAKER_00 Wasm предоставляет нам такой хороший абстрактный слой.
4142.76 4146.60 SPEAKER_00 Соответственно мы с вами посмотрели каким образом создаются Wasm модули в дот-нете.
4146.60 4155.64 SPEAKER_00 Каким образом можно сделать Web API прямо на чистом Wasm и как его запустить под виндой, как его запустить под Raspberry Pi.
4155.64 4159.12 SPEAKER_00 И познакомились с утилитой WasmTime.
4159.12 4162.72 SPEAKER_00 Таких утилит, которые способны запускать их несколько, WasmTime это одна из них.
4162.72 4166.60 SPEAKER_00 Вот такое интересное будущее рисует нам WebAssembly.
4166.60 4176.56 SPEAKER_01 Ну да, кажется, что если мы туда можем купить вообще все что угодно и запускать это везде, где может быть запущен Wasm, то это такой почти докер.
4176.56 4177.56 SPEAKER_00 Именно так.
4177.56 4188.96 SPEAKER_00 Когда мы разговаривали про чистый Wasm, то при его разработке учитывалась та специфика, что он как раз таки будет запускаться всегда в браузере.
4188.96 4192.36 SPEAKER_00 А браузер это должна быть очень секурная песочница.
4192.36 4199.64 SPEAKER_00 Потому что из браузера никогда ваш ни JavaScript, ни какие-то другие скрипты, которые вы скачали из сторонних сервисов выбраться не должны.
4199.64 4206.12 SPEAKER_00 Потому что как только в этой песочнице найдется дыра, то сразу в мире можно заразить миллиарды компьютеров, миллиарды пользователей.
4206.12 4208.00 SPEAKER_00 Это очень-очень-очень страшно.
4208.00 4210.96 SPEAKER_00 Поэтому в браузерах обычно железобетонные песочницы.
4210.96 4217.36 SPEAKER_00 В самом Wasm есть специальные механизмы, которые позволяют железобетонные песочницы поддерживать.
4217.36 4225.04 SPEAKER_00 То есть это штука, которая изначально проектировалась именно для того, чтобы секурно запускаться в песочницах.
4225.04 4229.48 SPEAKER_01 Ну и это как раз то, что нужно для докера по большому счету.
4229.48 4230.88 SPEAKER_01 Ну или для чего-то, что может заменить докер.
4230.88 4234.12 SPEAKER_01 Только более, не знаю, легковесное что ли.
4234.12 4251.76 SPEAKER_00 Вот эта возможность запускаться в неком контейнере, который может быть ограничен по ресурсам, который обязательно ограничен по секьюрности и который распространяется в виде какого-то межплатформенного формата, которым вы тоже не должны задумываться, под какую архитектуру его скомпилить.
4251.76 4254.44 SPEAKER_00 Кажется, что это прекрасная замена контейнером.
4254.44 4263.40 SPEAKER_00 Более того, если вы используете Kubernetes, то под Kubernetes уже есть специальное расширение, которое позволяет вам запускать не контейнеры, а именно вот эти Wasm файлы.
4263.40 4269.40 SPEAKER_00 Именно как обычный докер-контейнер, как в обычных ваших приложениях.
4269.40 4270.40 SPEAKER_01 Прекрасно.
4270.40 4273.08 SPEAKER_01 Ну в общем, посмотрим, куда это все сдвинется.
4273.08 4285.24 SPEAKER_01 Кажется, что в ближайшее время, ну я пока не слышал о таком широком распространении этой техники, назовем это так, но действительно потихонечку появляются всякие плагины и поддержка этого дела.
4285.24 4290.96 SPEAKER_01 Так что может быть мы и увидим переход с докер-контейнеров на Wasm-контейнеры или как их там назовут.
4290.96 4298.48 SPEAKER_00 А также смотри, можно дойти до операционной системы, которая ничего не умеет, кроме как интерпретировать Wasm, которую запускать Wasm.
4298.48 4313.04 SPEAKER_00 Теперь можно на Wasm записать операционную систему, все модули расширения, все плагины, все программы писать под ней, у тебя автоматически получится, все программы будут изолированными, будут мега-секьюрными, и очень сложно будет под такую штуку писать вирусы, например.
4313.04 4315.36 SPEAKER_00 В общем, эта дорожка может привести нас очень далеко.
4315.36 4319.16 SPEAKER_01 Ну посмотрим, как далеко и как быстро она нас туда приведет.
4319.16 4333.64 SPEAKER_01 Ну а потом еще в одну тему у нас давно достаточно лежит в бэклоге статья от Маони, главного архитектора Garbage Collector в Дотнете, и наконец-таки мы до нее добрались.
4333.64 4348.92 SPEAKER_01 И статья продолжает цикл довольно редких статей от Маони про Garbage Collector и раскрывает, куда же немножко они двигаются, точнее немножко раскрывают, куда они двигаются или планируют двигаться.
4348.92 4375.76 SPEAKER_01 Напомню, что в шестом Дотнете появились и в седьмом уже были официально включены так называемые регионы вместо сегментов, то есть Garbage Collector у нас работал раньше на сегментах, это большие куски памяти, там от сотни мегабайт и больше, где внутри них уже каким-то образом распределялись там нулевое первое поколение в эфемерный сегмент или сегменты, а второе поколение в прочий сегмент, но тоже большой.
4375.76 4408.92 SPEAKER_01 В какой-то момент было принято решение, что мы переходим на регионы, это уже более маленькие, ну скажем так, блоки памяти по 4 мегабайта или около того, которые можно свободно переиспользовать между разными сегментами, и одна из целей это была возможность декомитить какое-то количество памяти, но также это открывает некоторые возможности более правильной оптимизации, более интересных, так скажем, оптимизаций с точки зрения того, как мы работаем вообще с памятью не только с точки зрения garbage collection, а вообще работаем с памятью.
4408.92 4414.56 SPEAKER_01 И одна из оптимизаций как раз таки описана в этой статье, называется она более точные write barriers.
4414.56 4423.32 SPEAKER_01 Вы можете подумать, что если мы говорим про барьеры, это про memory model, который мы обсуждали чуть выше, потому что там тоже есть понятие memory barrier, но это не про то.
4423.32 4428.68 SPEAKER_01 Это про другую штуку, которая именно в контексте garbage collection.
4428.68 4439.80 SPEAKER_01 Представьте себе, что у вас есть некоторое поле в каком-то объекте, назовем его field, и новый объект, object, который вы присваиваете в это поле.
4439.80 4445.72 SPEAKER_01 Ну, операция, которую вы делаете очень часто, да, сохраняете ссылку на объект в каком-то поле.
4445.72 4456.04 SPEAKER_01 Каждый раз, когда вы выполняете такой код, у вас на самом деле выполняется метод внутри JIT, точнее JIT вызывает метод, называется JIT write barrier.
4456.04 4465.28 SPEAKER_01 И исходная цель заключается в том, чтобы, собственно, на основе этого у нас и получается сделать поколенческий garbage collector.
4465.28 4473.28 SPEAKER_01 То есть нам нужно знать, какие поколения смотреть, когда мы будем собирать, точнее, какие объекты смотреть, когда мы будем собирать то или иное поколение.
4473.28 4493.84 SPEAKER_01 Для этого нужно знать, какие объекты в каком поколении вообще потенциально могли измениться или могли получить, не то чтобы измениться, а получить новых родителей, точнее новых, как это сказать, не родителей, тех, кто их удерживает в памяти, вот удаление новых там, рутов, назовем это так.
4493.84 4513.28 SPEAKER_01 Если вы читали книжку "Кондрат Кокос" или слушали какой-то из наших подкастов из древних, где мы хоть что-то описывали про garbage collector, вы, может быть, знаете такой термин как cartable, это, грубо говоря, некоторая такая масочка по всему адресному пространству памяти, где одному битику соответствует некоторое количество килобайт в памяти.
4513.28 4528.84 SPEAKER_01 И если вот такое присвоение меняет хоть какой-то объект в этом регионе памяти, то в cartable этот битик проставляется в единичку, это значит, что когда сработает следующий garbage collector, он знает, в какие регионы памяти нужно посмотреть на предмет появившихся новых ссылок на объекты.
4528.84 4533.00 SPEAKER_01 Возможно, там ничего не появилось, но может быть, появилось.
4533.00 4541.40 SPEAKER_01 Когда .NET был спортирован на Linux, работа в RightBarrier заключалась ровно в том, что там нужно просто проставить этот самый битик.
4541.40 4548.64 SPEAKER_01 На самом деле проставлялся байтик, потому что атомарно поставить битик сложно, а байтик, ну как бы, архитектуру поддерживает.
4548.64 4555.84 SPEAKER_01 Когда это все спортировали на Linux, в эту функцию gRightBarrier добавили еще одну функциональность.
4555.84 4560.84 SPEAKER_01 На Linux дело в том, что нет такой штуки, как PageRightWatch, которая поддерживает винда.
4560.84 4569.24 SPEAKER_01 То есть винда умеет идентифицировать процесс о том, что в какую-то страничку памяти что-то записали в этом процессе.
4569.24 4572.84 SPEAKER_01 Linux такого не умеет, поэтому теперь RightBarrier занимается примерно тем же самым.
4572.84 4582.34 SPEAKER_01 И в случае с сегментами у этой функции RightBarrier была следующая задача.
4582.34 4605.64 SPEAKER_01 Во-первых, нужно было понять, пишем ли мы куда-то в heap или может быть мы присваиваем, не знаю, в поле структуры, которое лежит на стейке, и тогда нам не надо ничего добавлять ни в какой CardTable, потому что стейк у нас по дефолту будет, да, крутый, мы его в любом случае будем просматривать при сборке мусора, и тогда ничего писать никуда не надо.
4605.64 4616.40 SPEAKER_01 Для того, чтобы понять, есть ли это ссылка в heap, ну ссылка, куда мы пишем, она в heap или не в heap, для сегментов было просто, сегменты они большие, у каждого есть начало и конец.
4616.40 4625.36 SPEAKER_01 Особенно для эфемерного сегмента все просто, в Workstation GT он вообще один, и поэтому у вас здесь по сути два адреса, начало сегмента и конец сегмента.
4625.36 4632.28 SPEAKER_01 Сравнили адрес, куда мы пишем, с этим двумя и точно поняли, мы попадаем в эфемерный сегмент или не попадаем.
4632.28 4643.48 SPEAKER_01 С серверным GC все сложнее, потому что там есть несколько эфемерных сегментов, поэтому там была другая логика, там CardTable он обновлялся вообще безусловно.
4643.48 4648.44 SPEAKER_01 Если мы дернули какой-то кусочек памяти и он не на стейке, то мы считаем, что он в heapе и обновляем.
4648.44 4649.44 SPEAKER_01 Вот.
4649.44 4674.12 SPEAKER_01 В седьмом дотнете вот эти write barriers стали гораздо более точными, потому что у нас есть регионы, региончики они маленькие, они могут быть раскиданы где угодно, между ними могут быть какие-то дырки, и поэтому мы не можем себе позволить просто так считать, что вообще все это heap, потому что регионов много, и, ну, они не такие последовательные, может быть их будет слишком много и они будут раскиданы слишком далеко по виртуальной памяти.
4674.12 4679.28 SPEAKER_01 И самое главное, что каждый регион может быть вообще говоря в любом поколении, у нас теперь нету такой строгой последовательности.
4679.28 4690.00 SPEAKER_01 Для регионов у нас хранится так называемая generation info map, это некоторая, ну, словарик карта того, в каком поколении соответствует какой регион.
4690.00 4713.84 SPEAKER_01 Она хранится достаточно компактно, потому что в отличие от cart table, где по-моему на один бит требовалось около, в смысле один бит описывал по-моему странички то ли по 4, то ли по 16 килобайт, ну не странички, а регионы памяти, здесь у нас один регион это 4 мегабайта как минимум, поэтому количество битов для описания того, в каком поколении этот регион находится, ну, нужно говорить, гораздо меньше.
4713.84 4720.92 SPEAKER_01 Майкрософт утверждает, что настолько мало, что в принципе эта информация частенько попадает нормально в кэшброса и там хранится.
4720.92 4735.12 SPEAKER_01 Поэтому сейчас, вот, собственно, после этой оптимизации, алгоритм теперь выглядит следующим образом, того, что делает, того, что emitted JIT, по сути, вызов вот этой функции JIT write barrier, и она делает теперь следующую штуку.
4735.12 4745.16 SPEAKER_01 Сначала мы берем номер поколения того, куда мы пишем, то есть того адреса, куда мы пишем по вот этому generationInfoMap, это быстрая и простая операция.
4745.16 4750.44 SPEAKER_01 Если это нулевое поколение, вообще ничего делать не надо, то есть мы сохранили ссылку на объект в объект нулевого поколения.
4750.44 4758.04 SPEAKER_01 И объекты нулевого поколения мы в любом случае будем просматривать при следующей фазе сборки мусора, поэтому ничего дополнительно отмечать не надо.
4758.04 4772.72 SPEAKER_01 Если мы, если же это все-таки не объект нулевого поколения, а там первого или второго, то может быть мы сделали следующее, может быть мы свежесозданный объект, который сейчас живет в нулевом поколении, ссылку на него положили в какой-нибудь долго живущий объект.
4772.72 4787.56 SPEAKER_01 И это значит, что когда мы будем собирать нулевое поколение, нужно не забыть проверить в качестве рутов еще и те объекты, которые мы затронули в более старших поколениях, потому что иначе, если мы их не посмотрим, то мы не найдем ссылок на этот новый объект в нулевом поколении и его соберем.
4787.56 4788.56 SPEAKER_01 Вот плохо.
4788.56 4794.84 SPEAKER_01 Поэтому мы берем и выясняем, собственно, поколение того объекта, который мы присваиваем.
4794.84 4799.40 SPEAKER_01 Возможно оно нулевое, возможно первое, возможно второе.
4799.40 4807.68 SPEAKER_01 Если поколение объекта, который мы присваиваем, больше либо такой же, чем поколение филда, в который мы его присваиваем, то делать ничего не надо.
4807.68 4812.64 SPEAKER_01 То есть мы положили ссылку на более старший объект, ссылку в более новый объект.
4812.64 4814.32 SPEAKER_01 Ничего страшного, все нормально.
4814.32 4827.12 SPEAKER_01 А вот если наоборот, то есть мы сохранили ссылку на объект нулевого поколения в второе поколение, например, и перешли в первое, то тогда нам нужно таки update карт table.
4827.12 4835.96 SPEAKER_01 В результате получается из этого алгоритма, что мы гораздо реже обновляем карт тейбл, особенно в случае с сервером ГЦ, потому что раньше мы это делали безусловно.
4835.96 4850.64 SPEAKER_01 И в результате, когда у нас наступает фаза сборки мусора, Mark phase, когда мы пробегаемся по всем объектам и размечаем, кого удалить, кого не удалять, эта фаза протекает гораздо быстрее, потому что нам нужно просмотреть гораздо меньше объектов.
4850.64 4853.88 SPEAKER_01 Карт тейбл, собственно, используется как источник того, сколько нам посмотреть.
4853.88 4867.24 SPEAKER_01 Более того, после некоторых экспериментов Microsoft пришли к выводу, что на самом деле, несмотря на то, что вроде как архитектура у нас атомарно, по сути, мы можем поставить только байт, мы не можем атомарно поставить бит.
4867.24 4876.88 SPEAKER_01 Но фактически Microsoft теперь ставит бит, то есть она атомарно ставит байт, изменяя в нем один бит.
4876.88 4889.56 SPEAKER_01 То есть технически, если два конкурирующих потока будут проставлять один и тот же байт в карт тейбле, пытаясь поставить разные биты, то кто-то из них победит, а второму придется делать лишние захотные на простановку.
4889.56 4892.04 SPEAKER_01 То есть технически может быть больше контеншн.
4892.04 4895.56 SPEAKER_01 Но фактически эксперименты показали, что не так все
4895.56 4913.24 None плохо и можно ставить биты. Эксперименты, собственно, показали, что если мы ставим вот этот, с новым right barrier, но который все еще делает байты, ставит байты в карт тейбле, мы получаем ускорение в МГЦ примерно на 18%.
4913.24 4917.44 SPEAKER_01 За счет многих вещей, но вот в том числе за счет этого.
4917.44 4923.40 SPEAKER_01 За счет того, что у нас теперь новый right barrier и он пишет меньше данных, меньше карт тейблов обновляет.
4923.40 4929.36 SPEAKER_01 Если же мы проставляем биты right barrier, то мы улучшаем не на 18%, а аж на 25.
4929.36 4932.84 SPEAKER_01 То есть еще 7% дополнительно добавляем.
4932.84 4940.80 SPEAKER_01 Ну это, конечно, не бесплатно, то есть JIT right barrier, соответственно, тратит чуть больше времени потенциально на это.
4940.80 4946.12 SPEAKER_01 Но рекомендация Microsoft говорит следующее.
4946.12 4957.28 SPEAKER_01 Поскольку мы изменили, ну в общем-то, ключевую, одну из ключевых функций, одну из функций внутрянки, понятное дело, которая используется очень часто, на каждое присвоение вызывается JIT right barrier.
4957.28 4965.08 SPEAKER_01 И вам нужно понять вообще в новом .NET 7, когда вы запустите ваше приложение, посмотреть, нет ли у вас регрессии из-за этого.
4965.08 4966.44 SPEAKER_01 Технически она может быть.
4966.44 4968.04 SPEAKER_01 И рекомендация Microsoft простая.
4968.04 4976.76 SPEAKER_01 Если вы видите, что JIT right barrier в вашем профайлинге вылез больше чем на 1%, это как бы плохо и скорее всего это регрессия.
4976.76 4980.56 SPEAKER_01 Обычно она должна быть меньше чем 1% времени, а по факту еще ниже.
4980.56 4987.84 SPEAKER_01 Если вдруг что-то произошло и это действительно для вас регресс для вашего приложения, ну понятно, сообщите Microsoft.
4987.84 4993.68 SPEAKER_01 Плюс можно откатиться на старое поведение, как обычно с помощью переменной окружения .NET GC right barrier.
4993.68 5001.96 SPEAKER_01 У нее есть 4 значения, но фактически дефолт совпадает с не совсем дефолтом.
5001.96 5007.64 SPEAKER_01 Короче там можно сказать дефолт, можно сказать используйте новую right barrier с битами, это одно и то же.
5007.64 5010.52 SPEAKER_01 Можно выбрать новый right barrier, но все-таки с байтами.
5010.52 5017.24 SPEAKER_01 В этом случае прирост скорости GC будет чуть меньше, потому что карта ABLE будет обновляться побольше.
5017.24 5020.96 SPEAKER_01 Но зато и времени будет тратиться в JIT right barrier поменьше.
5020.96 5030.60 SPEAKER_01 Можно включить вообще старое поведение и использовать вот по старинке все обновлять и вернуться к старому поведению GC с точки зрения right barrier.
5030.60 5039.44 SPEAKER_01 При этом нельзя включить вот тот самый Workstation GC поведение, ну потому что эксперименты показали, что сервер GC тоже нечего работает даже в Workstation сценариях.
5039.44 5045.40 SPEAKER_01 Это пока только начало, у Маони есть еще некоторые планы про то, что делать в будущих релизах.
5045.40 5060.80 SPEAKER_01 Так что скорее всего мы увидим еще больше изменений вокруг Garbage Collector и они возможно будут настолько тонкими, что мы с одной стороны, ну 25% прироста скорости в GC это в принципе неплохо, четверть, это прям круто.
5060.80 5065.08 SPEAKER_01 Сравните с изменениями там Android Startup Time, где было там 6-7%.
5065.08 5070.92 SPEAKER_01 25% это круто, причем в той вещи, которая работает прям всегда в вашем приложении.
5070.92 5079.56 SPEAKER_01 Но с другой стороны, они уже настолько low-level, что иногда довольно сложно разобраться и понять, что же там такое сделали и насколько это зааффектит ваше приложение.
5079.56 5092.72 SPEAKER_01 Так что смотрите внимательно, смотрите внимательно за статьями Маони, потому что, как правило, когда большие изменения выходят, она пишет какую-нибудь полезную статью на эту тему.
5092.72 5101.48 SPEAKER_01 Ну и каждый раз, меняя рантайм, проверяйте, что случилось, что изменилось в вашем приложении и как оно теперь себя ведет.
5101.48 5107.20 SPEAKER_00 Да, наверное, могут быть ситуации, когда это еще будет и хуже себя вести ваше приложение.
5107.20 5141.56 SPEAKER_01 Ну Microsoft старается тестировать, у них огромное количество так называемых и внутренних, и first-tier клиентов, и много кого другого, и рантаймы, они, ну количество превьюшек вкладываемое достаточно великое, поэтому много кто успевает что попробовать, какие-то косяки собрать, но практика показывает, что вот ошибки такого рода, ну в смысле что, изменения в таких компонентах типа GCE или GTA, они иногда стреляют на каких-то ну совсем экстремальных корнер-кейсов, которые может не быть в большинстве проектов, а именно в вашем он попадется.
5141.56 5153.36 SPEAKER_00 Интересный эффект получается, я вот заметил, что почему-то мне кажется, что в последнее время очень много меняется джит и очень часто меняется джит, или это, наверное, только потому, что Маони начал об этом писать, а до этого мы просто не знали, как он меняется.
5153.36 5167.84 SPEAKER_01 Ну Маони про джит, кстати, не пишет, про джит мы максимум узнаем из, ну не знаю, из профильных чатиков, назовем это так, или если действительно появляются какие-то там твиты от Егора Бакатова и так далее, то есть…
5167.84 5176.60 SPEAKER_00 Да, я перепутал, конечно же, про ГЦ. То есть мне почему-то раз уж казалось, что ГЦ вот где-то до дот-нета 3.1 он вообще не двигался никуда и никак.
5176.60 5185.84 SPEAKER_02 Ну возможно как раз там, как говорила Маони, когда мы с ней общались на самом деле, она говорила, что там проводилась некоторая работа по, ну назовем это
5185.84 5195.32 SPEAKER_01 внутреннему рефакторингу, чтобы это не было монолитным ГЦ-ЦПП, да, это было хоть как-то поддерживаемым, потому что там все-таки команда работает, там не она одна работает над этим.
5195.32 5211.04 SPEAKER_01 И во-вторых, я так понимаю, что вся эта затея с регионами и прочее, она требовала некоторой, ну скажем так, серьезной подготовки и обкатки, поэтому, видимо, в релизных вещах мы этого ничего не видели, потому что это все было под капотом пока там в экспериментальных ветках.
5211.04 5218.28 SPEAKER_00 Ну хорошо, как ты думаешь, после такой хардкорного ГЦ перейти к философскому рефакторингу, это нормальная
5218.28 5226.44 SPEAKER_01 тема будет? Да, нормально, мы всегда переходим как-то непонятно куда чего, просто берем следующую тему в списке и про нее рассказываем, поэтому валяй.
5226.44 5230.68 SPEAKER_00 То есть ты думаешь, никакой логики повествования от нас уже слушатели не ждут?
5230.68 5235.56 SPEAKER_01 У нас новостной подкаст, мы это, а теперь новости философии, давай.
5235.56 5249.52 SPEAKER_00 Отлично, ну главный философ в нашей области, это безусловно Марк Симон, хочется посмотреть на еще одну интересную его статью, и в этой статье он рассуждает, а нужно ли просить менеджеров разрешение или времени на рефакторинг.
5249.52 5253.24 SPEAKER_00 Игорь, ты вот как думаешь, на рефакторинг надо время отдельно выпрашивать?
5253.24 5271.56 SPEAKER_01 Выпрашивать, наверное, ну вопрос такой формулировки меня немножко ставит в тупик, если вы видите, что нужно рефакторить, то да, наверное, надо выпрашивать, просто мне непонятна терминология выпрашивать, то есть типа,
5271.56 5286.68 SPEAKER_00 а если не дадут? Обычно у тебя стоит как бы выбор, или сделать фичу супер нужную бизнесу, или все-таки потратить какое-то время от фичи, что-то двинуть, но сделать рефакторинг и это гипотетически улучшит в будущем жизнь неким абстрактным разработчикам.
5286.68 5290.16 SPEAKER_00 А фича, она уже здесь, она как бы полезная, она бабло может принести и все такое.
5290.16 5301.00 SPEAKER_00 И для того, чтобы понять, куда тебе тратить время на фичу или на рефакторинг, ты должен договориться, наверное, с твоим менеджером, чтобы как-то предсказуемо результаты ощущать.
5301.00 5337.36 SPEAKER_01 Мне, видимо, везло с, ну давай назовем это продукт-аунерами, те, кто ответственен за там приоритизацию, у нас всегда была некоторая договоренность, ну условно, где-то формальная, где-то неформальная, про то, что какое-то время, то есть все хотелки по рефакторингу, те или иные, которые возникают у команды, либо просто возникают, либо из-за того, что мы там нашли какую-то проблему в ронтайме, либо просто кто-то прочитал стазию какую-нибудь, или послушал подкаст, они все тоже скидывались в общий баклог и приоритизировались, ну условно говоря, наравне.
5337.36 5348.36 SPEAKER_01 То есть понятно, что приоритет все-таки за бизнес-фичами, но какое-то время у нас всегда находилось практически на всех проектах, где я работал, на то, чтобы хоть какой-то рефакторинг делать в общем порядке.
5348.36 5353.80 SPEAKER_00 Ну вот смотри, с Марком произошла примерно такая же история, рассказываю вкратце.
5353.80 5366.96 SPEAKER_00 В общем, работал он над одним проектом, и там понадобился срочный рефакторинг, там был какой-то технический долг, этот долг был такой большой, концептуальный, и нужно было засесть и отрефакторить.
5366.96 5374.48 SPEAKER_00 Он точно так же обратился к менеджеру, говорит, чувак, надо, а менеджер сказал, да, хорошо, без проблем, раз уж надо, давайте делать.
5374.48 5376.68 SPEAKER_00 И он засел за рефакторинг.
5376.68 5396.00 SPEAKER_00 После того, как через неделю проект все еще не компилировался, менеджер позвал его в сторонку и ласково намекнул, что как бы я немножко неудовлетворен, сложився с текущей ситуацией, потому что как бы бизнес-фичи пилить надо, у нас все стоит, потому что проект развален, ничего не компилируется, и когда это будет работать, непонятно.
5396.00 5397.92 SPEAKER_01 А развален, ясное дело, в мастер-ветке.
5397.92 5410.60 SPEAKER_00 Он не в мастер-ветке развален, но так как эта фича была мега-фундаментальная, она затрагивала практически абсолютно все, поэтому если бы мастер-ветка ушла далеко, то МЕЖ был бы очень-очень сложно.
5410.60 5413.60 SPEAKER_00 И надо разваливать заново мастер.
5413.60 5414.60 SPEAKER_00 Практически.
5414.60 5415.60 SPEAKER_00 Окей.
5415.60 5418.88 SPEAKER_00 Вот, и как раз ситуация очень неприятная.
5418.88 5428.24 SPEAKER_00 Марк сел, подумал, как поступать в будущем и как выйти из подобных ситуаций, и придумал нам вот такую прекрасную статейку, которую мы с вами предлагаем рассмотреть.
5428.24 5439.28 SPEAKER_00 Итак, прежде всего он сделал вывод, что никогда не нужно менеджеров спрашивать разрешения о том, проводить рефакторинг или не проводить рефакторинг.
5439.28 5443.80 SPEAKER_00 Более того, он никогда больше так не делал, то есть не спрашивал менеджеров.
5443.80 5458.88 SPEAKER_00 А самая главная причина, почему он менеджеров не спрашивал, потому что он никогда не вписывался в такие задачи, где нужно было делать рефакторинг очень-очень долго, и в момент этого рефакторинга, возможно, разваливался код.
5458.88 5470.44 SPEAKER_00 В общем, и вот каким образом он пришел к такой позиции, что он избежал таких больших рефакторингов с развалением кода, он пытается нам в статье объяснить.
5470.44 5473.52 SPEAKER_00 Прежде всего, здесь он напоминает о нескольких стратегиях.
5473.52 5478.16 SPEAKER_00 Во-первых, это известный стратегий-душитель, который называется "стрэнглер".
5478.16 5480.96 SPEAKER_00 Это тоже известная такая штука.
5480.96 5489.00 SPEAKER_00 Она помогает вам мигрировать ваш код на новый API, и в то же самое время старый API оставлять на месте.
5489.00 5492.00 SPEAKER_00 То есть параллельно должны работать оба API.
5492.00 5497.76 SPEAKER_00 И постепенно нового кода появляется больше, а старого кода должно появляться меньше.
5497.76 5500.26 SPEAKER_00 И старый код должен постепенно исчезать.
5500.26 5504.00 SPEAKER_00 Таким образом, новый код постепенно душит старый код.
5504.00 5508.44 SPEAKER_00 Также очень полезна в этом случае такая штука, как фичи-флаги.
5508.44 5524.28 SPEAKER_00 Когда вы закрываете какой-то блок исполнения с помощью специального флага, и все ваши нововведения, все ваши изменения, они относятся только к тем блокам, которые закрыты с помощью этого фичи-флага, и старое поведение остается за фичи-флагом.
5524.28 5533.88 SPEAKER_00 Это позволяет вам, вот эти два подхода, позволяет вам беспрепятственно, например, межить в мастер, как уже было предложено выше, и при этом не ломать текущую совместимость.
5533.88 5541.28 SPEAKER_00 То есть, чтобы текущий код, который уже выполнялся, и на который рассчитывает бизнес-фичи, он продолжал исполняться.
5541.28 5544.88 SPEAKER_00 И вы при этом можете постепенно добавлять какие-то новые кусочки.
5544.88 5549.72 SPEAKER_00 То есть, основная идея этого подхода, это в том, что двигаться нужно маленькими шагами.
5549.72 5557.12 SPEAKER_00 И в коем случае не нужно допускать, что вы на неделю уходили в рефакторинг, разваливали там все, и может быть, к какому-то моменту оно как-нибудь заработает.
5557.12 5562.00 SPEAKER_00 Нет, такой подход не работает, работает только подход, когда вы делаете все маленькими шагами.
5562.00 5570.48 SPEAKER_00 Более того, вот этот определенный скил рефакторинга и рефакторинга маленькими шагами – это специальная наука.
5570.48 5572.20 SPEAKER_00 Про нее написано множество книг.
5572.20 5576.00 SPEAKER_00 Нельзя не упомянуть здесь книгу Мартина Фаулера про рефакторинг.
5576.00 5583.92 SPEAKER_00 В общем, это большая наука, у которой есть свои подходы, свои шаблоны проектирования, свои тесты и много-много всего интересного.
5583.92 5589.68 SPEAKER_00 Поэтому если вы чувствуете, что не владеете этой техникой, ее нужно целенаправленно осваивать.
5589.68 5592.80 SPEAKER_00 Не надейтесь на то, что у вас оно может получиться само собой.
5592.80 5598.00 SPEAKER_00 Такие, конечно, самородки тоже есть, но мы за правильный учебный подход.
5598.00 5606.12 SPEAKER_00 Давайте теперь разберем немножко конкретных примерчиков, как это может работать на практике.
5606.12 5610.16 SPEAKER_00 Во-первых, часто задаются вопросом, а когда рефакторить?
5610.16 5623.28 SPEAKER_00 То есть нужно ли откладывать это на конец итерации, нужно ли откладывать это в отдельные таски, чтобы их опять же предлагать на рассмотрение управляющему менеджеру, раундеру или еще каким-то образом.
5623.28 5625.48 SPEAKER_00 То есть когда выделять время для рефакторинга?
5625.48 5626.48 SPEAKER_00 Правильный ответ всегда.
5626.48 5634.36 SPEAKER_00 Рефакторить нужно безотлагательно, ежесекундно, как тогда же, когда вы пишете код.
5634.36 5637.80 SPEAKER_00 Даже существует такое правило, которое звучит следующим образом.
5637.80 5641.16 SPEAKER_00 Сначала сделай, чтобы оно работало, а потом сделай это правильным.
5641.16 5642.96 SPEAKER_00 Что это означает?
5642.96 5651.28 SPEAKER_00 Что сначала вы, когда делаете любую фичу, первым этапом добитесь для того, чтобы она выполняла свои прямые обязанности, на которые вы рассчитываете.
5651.28 5655.92 SPEAKER_00 После того, как вы это сделали, уже нужно переходить ко второй фазе, фазе рефакторинга.
5655.92 5664.44 SPEAKER_00 То есть тогда вы уже причесываете эту штучку, делаете там некрасивый API, может быть пишете документацию, может еще как-нибудь ее облагораживаете.
5664.44 5666.52 SPEAKER_00 В общем четко делите две этих фазы.
5666.52 5675.84 SPEAKER_00 Как только вы начнете делить, вы попробуйте в себя в голове представить, сколько времени будет занимать та или иная фаза.
5675.84 5679.52 SPEAKER_00 Например 50% на разработку, 50% на рефакторинг.
5679.52 5683.96 SPEAKER_00 Ну или вдруг 30% на разработку и 70% на рефакторинг.
5683.96 5685.28 SPEAKER_00 Скорее всего это не так.
5685.28 5694.20 SPEAKER_00 Скорее всего основное время у вас потратится именно на разработку фичи, на проработку идеи, на интеграцию с существующим кодом, на тесты, еще на что-то.
5694.20 5702.72 SPEAKER_00 И обычно на рефакторинг, то есть на конечное причесывание, у вас будет уходить не более 10% всего этого времени.
5702.72 5705.40 SPEAKER_00 Как показала практика Марка, это именно так.
5705.40 5711.36 SPEAKER_00 А если уходит меньше 10%, то здесь нет никакого смысла спрашивать менеджера разрешения.
5711.36 5716.68 SPEAKER_00 Это как раз та штука, которую легче просто сделать в рамках текущей таски.
5716.68 5730.44 SPEAKER_00 Для того, чтобы держать эту планку, чтобы все-таки на рефакторинг уходило немного времени, достаточно первой фазы, которую сделать, чтобы она работала, не пытаться сделать идеальной.
5730.44 5732.48 SPEAKER_00 Ее нужно сделать достаточно хорошей.
5732.48 5737.84 SPEAKER_00 Достаточно хорошей для вашей задачи, для вашего текущего контекста и для вашей текущей интеграции.
5737.84 5745.16 SPEAKER_00 Не пытайтесь применить там сверхновые техники, засунуть сверхновые библиотеки или сделать максимальный перформанс, который только можно.
5745.16 5748.28 SPEAKER_00 Всегда есть какой-то понятный достаточный критерий.
5748.28 5753.08 SPEAKER_00 Вот эти достаточные критерии, их обычно хватает для того, чтобы сделать просто, понятно и хорошо.
5753.08 5764.76 SPEAKER_00 Также для того, чтобы не тратить много времени на рефакторинг, придерживайтесь вполне каких-то банальных вещей, которые можно внедрять уже непосредственно на этапе разработки.
5764.76 5766.56 SPEAKER_00 Например, используйте нормальные имена.
5766.56 5768.84 SPEAKER_00 Не надо откладывать это на какой-то долгий ящик.
5768.84 5770.76 SPEAKER_00 Вам и разрабатывать легче будет.
5770.76 5773.16 SPEAKER_00 Старайтесь удалять дубликаты.
5773.16 5779.52 SPEAKER_00 Обязательно следите за кодсмейлами, за вот этими запахами, которые мы много обсуждали в наших подкастах.
5779.52 5783.64 SPEAKER_00 Держите методы маленькими, чтобы их легко можно было тестировать, управлять ими и так далее.
5783.64 5786.32 SPEAKER_00 И держите маленькой сложность.
5786.32 5791.56 SPEAKER_00 Чем больше сложность, тем у вас будет больше недопониманий и тем больше вам придется рефакторить и разбивать эти методы.
5791.56 5804.04 SPEAKER_00 В общем, придерживаясь таких простых правил, у вас всегда будет часть, которая отвечает за разработку, она всегда будет закончена и более-менее приближена к тому идеалу, к которому вы приступите во второй фазе и на который соответственно вы не потратите много времени.
5804.04 5808.24 SPEAKER_00 Это что касается фичи, которые вы делаете новенькую.
5808.24 5812.24 SPEAKER_00 То есть у вас понятная фича, вы ее сделали, вы ее отрефакторили и все хорошо.
5812.24 5818.04 SPEAKER_00 Но обычно тех долг и, соответственно, большой рефакторинг встречается в фичах, которые уже есть.
5818.04 5824.12 SPEAKER_00 В каких-то старых, больших фичах вам, допустим, нужно туда что-нибудь добавить, что-нибудь изменить.
5824.12 5826.44 SPEAKER_00 Вот как подойти к этому большому куску.
5826.44 5828.56 SPEAKER_00 Здесь есть другое правило.
5828.56 5834.20 SPEAKER_00 Сначала сделайте так, чтобы изменение было легким, а потом легко сделайте это изменение.
5834.20 5836.68 SPEAKER_00 Что это значит?
5836.68 5849.16 SPEAKER_00 Это значит, когда вы приходите в какой-то большой Legacy Code, видите, что вам нужно добавить всего лишь какой-то маленький флажочек, но чтобы это сделать, вам нужно перелопатить огромные какие-то куски интеграции, огромные какие-то непонятные зависимости.
5849.16 5851.64 SPEAKER_00 Разделите, опять же, эту фазу на две части.
5851.64 5860.76 SPEAKER_00 В первой части вы занимаетесь подготовкой вашего кода, существующего, к тому, чтобы он новую фичу воспринял очень легко и просто.
5860.76 5863.80 SPEAKER_00 То есть вы, по сути, рефакторите существующий код.
5863.80 5869.80 SPEAKER_00 И вторая фаза, как только ваш код уже готов к тому, чтобы воспринять эту новую фичу, вы ее очень легко и просто добавляете.
5869.80 5873.32 SPEAKER_00 Что у нас из этого получается?
5873.32 5877.16 SPEAKER_00 Получается, соответственно, что вы не тратите время на рефакторинг.
5877.16 5880.56 SPEAKER_00 Вы, грубо говоря, тратите время на имплементацию этой фичи.
5880.56 5888.44 SPEAKER_00 Но, если бы вы попытались вкорячить эту фичу в старый, страшный, заросший код, вы бы, скорее всего, потратили столько же времени.
5888.44 5891.20 SPEAKER_00 Может быть, это время вылилось бы у вас потом в баги.
5891.20 5894.32 SPEAKER_00 Может быть, это время вылилось бы в сложность написания тестов.
5894.32 5897.44 SPEAKER_00 Но в общем, временем вас заняло бы это столько же.
5897.44 5910.32 SPEAKER_00 Но при этом ваш код остался бы еще более кривым, потому что как только вы в кусок грязи добавляете еще одно ведро грязи, то есть еще одну какую-то новую фичу, у вас появится просто большая куча грязи.
5910.32 5917.64 SPEAKER_00 Вместо того, чтобы сделать тот код, с которым вам пришлось работать, сначала прекрасным и элегантно добавить туда новую фичу.
5917.64 5920.32 SPEAKER_00 Соответственно, после вас код останется прекрасным.
5920.32 5925.12 SPEAKER_00 И следующий человек, который придет добавлять новую фичу, он сделает это уже быстро, красиво.
5925.12 5933.48 SPEAKER_00 Может быть, потратив небольшое, маленькое время на то, чтобы доработать, отрефакторить, улучшить тот код, который оставили после себя вы.
5933.48 5942.28 SPEAKER_00 Основная идея вот этих посылов в том, что когда вы приходите в код и смотрите, что его можно улучшить, то обязательно улучшайте его.
5942.28 5947.04 SPEAKER_00 И тогда после этого все фичи, которые вы будете добавлять, они будут добавляться легко и просто.
5947.04 5950.00 SPEAKER_00 Соответственно, нужно ли здесь спрашивать разрешение в этой ситуации?
5950.00 5957.00 SPEAKER_00 Наверное, не нужно, потому что вы тратите на реализацию фичи столько же времени, сколько вы бы тратили, скорее всего, и без рефакторинга.
5957.00 5961.48 SPEAKER_00 Но при этом еще оставляете за собой чистым и красивым код.
5961.48 5969.48 SPEAKER_00 И больше времени вам для этого не нужно, потому что вы, соответственно, создаете предусловия для реализации фичи.
5969.48 5978.36 SPEAKER_00 Вот таким образом можно разбить весь код на какие-то подходы и весь рефакторинг включать в эти подходы.
5978.36 5981.04 SPEAKER_00 Что мы получаем в итоге?
5981.04 5986.16 SPEAKER_00 Во-первых, правило, что если вдруг вы видите, что код может быть улучшен, то не дожидайтесь ничего.
5986.16 5989.28 SPEAKER_00 Если это маленькое, легенькое изменение, обязательно улучшайте его.
5989.28 5995.28 SPEAKER_00 Никакого смысла ждать, откладывать, или смотреть, или выделять, или просить.
5995.28 5996.28 SPEAKER_00 Смысла никакого нет.
5996.28 6001.60 SPEAKER_00 Как только вы пришли делать какую-то фичу, то у вас уже выделено время на эту фичу.
6001.60 6006.16 SPEAKER_00 И если вы смотрите на этот код, значит, этот код находится где-то рядом с вашей фичей.
6006.16 6012.96 SPEAKER_00 Если займет это вас не больше 5-10 минут, то потратите это время и вокруг этой фичи приведите код в порядок.
6012.96 6017.56 SPEAKER_00 То есть потратите минимальное усилие для того, чтобы улучшить ваш существующий код.
6017.56 6028.56 SPEAKER_00 Если же этот код занимает часы, дни, недели и прочие такие страшные размерности, то применяйте технику, когда мы рефакторим с помощью маленьких шагов.
6028.56 6037.48 SPEAKER_00 И не обязательно спрашивать при этом менеджера, потому что маленькие шаги, они тем и прекрасны, что мы возвращаемся к предыдущему варианту.
6037.48 6042.24 SPEAKER_00 То есть вы выделяете какую-то область и вы можете маленькими шагами ее улучшать.
6042.24 6049.92 SPEAKER_00 Чем больше фич вы делаете вокруг этой грязной области, тем больше шансов, тем больше вероятности у вас эту грязную область почистить, улучшить.
6049.92 6051.92 SPEAKER_00 Точно так же маленькими небольшими шагами.
6051.92 6069.20 SPEAKER_00 Все это будет заливаться в мастер, все это будет интегрироваться, все это будет пропускаться через тесты и все это будет жить, а не накапливаться в отдельной большой ветке на целый месяц непонятных каких-то изменений, которые еще не понятно, как мы будем выливать и к чему не приведут наш релиз.
6069.20 6086.76 SPEAKER_00 Вот такие простые, кажется, на первый момент шаги, но если их попытаться применить в настоящем коде, то мне кажется, что они как раз таки дадут хороший boost, хорошее понимание того, как когда улучшать код и что сделать, чтобы код стал лучше и понятнее, красивее, при этом не развалился.
6086.76 6090.32 SPEAKER_01 И кажется, что здесь нужно уметь вовремя останавливаться.
6090.32 6098.96 SPEAKER_01 То есть понятно, что нам всем очень нравится рефакторить, понятно, что очень хочется сразу весь проект сделать лучше, отформатировать нафиг все файлы под современные кодинг гайдлайны.
6098.96 6125.32 SPEAKER_01 Вот это все, короче, прям, чтобы все было хорошо, но в итоге получаются огромные пул реквесты с кучей изменений, где-то форматирование, где-то рефакторинг, где-то фича, все это одновременно, и поэтому лучше все-таки уметь себя останавливать, то есть улучшить кусочек, закоммитить и продолжить дальше, а не пытаться сделать все и сразу, хотя и очень хочется.
6125.32 6130.88 SPEAKER_00 Да, каждый сам для себя определяет, что такое маленькие шаги, но опять же, чем меньше эти шаги, тем лучше.
6130.88 6132.72 SPEAKER_00 Максимально маленькие, которые вы сможете.
6132.72 6139.72 SPEAKER_01 Мне кажется, если шаги будут выбраны слишком крупные, команда, которая будет ревьюить такие пул реквесты, тоже намекнет о том, что шаги крупноваты.
6139.72 6147.32 SPEAKER_00 Да, ваши коллеги вам обязательно помогут, особенно когда нужно показать, ткнуть носом в ваши ошибки, будьте уверены.
6147.32 6148.76 SPEAKER_01 Да, ну что, пойдем дальше.
6148.76 6158.64 SPEAKER_01 Дальше у нас, как обычно, мы переходим к новостям, которые мы не знали, куда отнести, или они просто очень небольшие, поэтому по чуть-чуть, но о разном.
6158.64 6161.00 SPEAKER_01 То есть продать нельзя, а выбросить жалко, да?
6161.00 6163.60 SPEAKER_01 Ну, типо того, обязательно когда-нибудь пригодится.
6163.60 6164.96 SPEAKER_01 И может быть действительно пригодится.
6164.96 6181.92 SPEAKER_01 Для начала Дэвид Фаулер, он очень редко пишет в блоге, у него есть блог, но он туда пишет крайне редко, зато он мастер всяких полезных твитов и иногда выкладывает интересные гисты на гитхаб.
6181.92 6192.36 SPEAKER_01 В этот раз он выложил интересный, ну он не очень большой, но тем не менее мне показался полезный титр-рет-рет про минимал-АПИ, про телеметрию, про Метеус и вот это вот все.
6192.36 6200.72 SPEAKER_01 Он там показал, как обычно, что, а он фанат, как я понимаю, минимал-АПИ, прям вот, по-моему, самый главный фанат в Майкрософте.
6200.72 6228.32 SPEAKER_01 И как это все легко сконфигурить, как можно просоздавать свои собственные метрики, какие ресурсы, ну в смысле ссылочки почитать в интернете, если вам это интересно, какие-то типсы, как это сделать поудобнее, поправильнее, то есть в общем, если вы смотрите на минимал-АПИ, OpenTelemetry и вот это все, то гляньте твит, он прям, ну серию твитов, они прям действительно, 2-3 скриншота объясняют практически все, как легко это дело подключить.
6228.32 6230.80 SPEAKER_01 Дальше немножко про тулинг.
6230.80 6259.16 SPEAKER_01 Я давно хотел упомянуть, это произошло еще примерно в июле или в августе, зарелизился Illspy 8.0, но это все еще Preview 2, я все ждал, когда же будет релиз, по релизу, к сожалению, пока так и нет, он все еще в состоянии Preview 2, на момент 30 июля, видимо, не хватает сил, не знаю, ресурсов в команде, чтобы довести это до полноценного релиза, либо они ждут, собственно, финального релиза 7.0.net, чтобы окончательно поддержать все фичи C# 11.
6259.16 6274.52 SPEAKER_01 Но тем не менее, какие-то фичи уже поддержаны, поэтому если вам нужен декомпилятор, DotPick, наверное, поддерживает получше, потому что, ну, JetBrains все-таки старается бежать достаточно в ногу с тем, как Microsoft релизит фичи C#.
6274.52 6297.28 SPEAKER_01 Ну а Illspy полегковеснее, Dnspy тоже вариант, я уже рассказывал, что есть, сам Dnspy не развивается, но есть DnspyX, который является форком Dnspy и который развивается, зарелизлен последний раз тоже примерно в июне-июле, так что из таких легковесных декомпилеров пока только эти два более-менее живы.
6297.28 6312.08 SPEAKER_01 И третья новость, она такая больше, я бы ее назвал корпоративной, Microsoft OpenSource Tool, который позволяет генерить то, что называется Software Bill of Materials.
6312.08 6339.28 SPEAKER_01 Мы уже в какой-то момент рассказывали про такую штуку, что сейчас участились, ну скажем так, атаки всякие разные через NuGet и через вот эти всякие вещи, плюс если вы работаете в каком-нибудь большом, не знаю, enterprise, довольно часто становится важным вообще из чего собран ваш продукт, не затащили ли вы туда какую-нибудь странную библиотеку, странной лицензии, ну и так далее.
6339.28 6358.12 SPEAKER_01 А вот как раз-таки Microsoft Tool зарелизился, лежит на GitHub, который позволяет сгенерить по вашему продукту в некотором стандартном SPDX формате описание того, что же затащено в ваш продукт, то есть из чего он состоит.
6358.12 6394.20 SPEAKER_01 Причем поддержан не только .NET, там поддержано огромное количество разных всяких языков и фреймворков, поэтому если вы увлекаетесь, наверное, неправильным глаголом, но вам приходится заниматься какой-то такой работой, посмотрите на этот тул, возможно, это то, что поможет вам более-менее автоматически, например, во время какого-нибудь CI проверять, что старые и детектить изменения в заиспользованных библиотеках и как-то триггерить какие-то дополнительные проверки, либо просто, не знаю, валить билд, пока они не запробят новую библиотеку, если вы почему-то живете в таком окружении.
6394.20 6411.56 SPEAKER_00 Я наткнулся на очень интересный код стили, наверное, код стилей бывает много разных, и все мы с вами сталкивались с ними, в общем, я наткнулся на такие, я бы назвал их более глубокие рекомендации по стилям кодирования, что я имею в виду.
6411.56 6427.20 SPEAKER_00 Очень часто анализаторы Рослиновский и Житбреновский, они заложники той ситуации, что они обязаны поддерживать максимально широкое число клиентов, то есть они, конечно, подсказывают отличные какие-то рекомендации, но они не заходят слишком далеко.
6427.20 6435.12 SPEAKER_00 А мне бы хотелось рекомендаций более высокоуровневых, то есть все-таки забить на какие-то возможности языка, на возможности рантайма, это все.
6435.12 6438.40 SPEAKER_00 Мне бы хотелось рекомендаций, которые ближе именно к самому домену.
6438.40 6447.48 SPEAKER_00 И вот кажется, что я нашел прекрасный сайтик, который такие рекомендации в виде как раз-таки анализаторов и предлагает.
6447.48 6448.96 SPEAKER_00 Ну сейчас я вам для примера расскажу.
6448.96 6455.76 SPEAKER_00 Например, что из методов, обычно, если возвращаете коллекцию, то вам обычно нужно возвращать иммьютабл коллекцию.
6455.76 6462.88 SPEAKER_00 Никакой решайпер вам это не подскажет, потому что, в принципе, никто не запретит вам возвращать хоть массив оттуда, хоть обычный лист.
6462.88 6470.36 SPEAKER_00 Но, насколько я сталкивался, никогда практически не нужно на практике возвращать вам какой-нибудь массив.
6470.36 6474.76 SPEAKER_00 Потому что всегда нужно возвращать ридон для листы, ридон для коллекции, еще что-нибудь такое.
6474.76 6479.80 SPEAKER_00 И вот прекрасно было бы, если бы анализатор вот эти штуки все проверял.
6479.80 6486.60 SPEAKER_00 То есть, естественно, это будет, правда, не в 100% случаев, но опять же, мы покроем 99% случаев, и это прекрасно.
6486.60 6488.08 SPEAKER_00 И вот их хотелось бы иметь.
6488.08 6495.36 SPEAKER_00 Например, этот анализатор может нам проверить, что элементы коллекции и также таски не могут быть нулями.
6495.36 6505.20 SPEAKER_00 То есть, это тоже штука, которая язык не запрещает, так можно делать, но в любой нормальной команде всегда есть договоренность, что так делать нельзя, так делать не надо.
6505.20 6507.60 SPEAKER_00 Это приводит к огромному числу неприятностей.
6507.60 6511.48 SPEAKER_00 И вот есть анализатор, который как раз таки работает на уровне вот этих доменов.
6511.48 6522.36 SPEAKER_00 Также он может проверять домен-специфик value, когда вы используете primitive obsession, то есть, когда вы возвращаете строку, а вам нужен был ISBN, например, уникальный номер книги.
6522.36 6528.96 SPEAKER_00 Он точно так же может вам порекомендовать, типа, оберните это в нормальный домен-специфик primitive и пользуйтесь им.
6528.96 6542.16 SPEAKER_00 Он может проверять, что когда у вас используются магические номеры, то есть, магические числа, которые непонятно, что значат, встречаются где-то посредине кода, и никто никогда не догадается, что это за смещение с левой стороны луны.
6542.16 6550.00 SPEAKER_00 В общем, вот подобные проверки, которые такие уже более домен-специфик, какие-то более на уровне договоренности между командами, вот там есть.
6550.00 6551.24 SPEAKER_00 И их там достаточно много.
6551.24 6556.92 SPEAKER_00 И этот анализатор, он работает именно не на уровне языка, а на уровне принципов.
6556.92 6576.20 SPEAKER_00 Такие как принцип наименьшего удивления, принцип kitted simple stupid, это kiss, всем известный yagna, это you ain't gonna need it, don't repeat yourself, те же самые принципы OOP с правильным наследованием, с раскрытием каких-нибудь protected members.
6576.20 6579.56 SPEAKER_00 Очень много у него есть про DDD, безусловно.
6579.56 6581.96 SPEAKER_00 В общем, вот на таких уровнях, на уровнях принципа.
6581.96 6583.40 SPEAKER_00 И вот это как раз то, чего не хватало.
6583.40 6591.72 SPEAKER_00 Идеи автор сцеплял из Стивена Макконнелла, Джимми Нильсона, Джерми Миллера, Дэвида Фаулера, Роберта Мартина.
6591.72 6600.64 SPEAKER_00 В основном это авторы больших таких монументальных трудов, это книги, книги по архитектуре, по дизайну, и там как раз вот эти все принципы очень тщательно и хорошо разобраны.
6600.64 6603.56 SPEAKER_00 И как раз автор пытался отразить это все в анализаторах.
6603.56 6607.68 SPEAKER_00 Есть, естественно, несколько уровней предупреждений.
6607.68 6612.16 SPEAKER_00 Все они настраиваются с помощью Editor-Config, атрибутов, директив, все как положено.
6612.16 6620.00 SPEAKER_00 Интересно то, что этот сайт, то есть вот эти описания всех вот этих проверок, они переведены на русский.
6620.00 6630.92 SPEAKER_00 Если вдруг как раз эти описания могут быть очень полезны и для джунов, которые только учатся программировать и которые не знают, что, например, плохого в том, что вернули мьютабельную коллекцию из вашего метода.
6630.92 6635.32 SPEAKER_00 Вот, часто джуны не знают хорошо английский и стесняются как бы читать английские сайты.
6635.32 6641.80 SPEAKER_00 Здесь есть отличная переведенная версия, можно прямо на русском давать им ссылочки и там подробно будет написано, что все-таки случилось.
6641.80 6643.84 SPEAKER_00 Ну и, собственно, конечно же есть анализатор.
6643.84 6653.64 SPEAKER_00 То есть вам не нужно сверяться с этими принципами вручную, есть анализатор, который вы можете подключить к вашему CI или к вашей IDE и он будет это все дело проверять.
6653.64 6659.12 SPEAKER_00 В общем, я планирую в ближайшее время попробовать и, может быть, на постояночку такой анализатор к себе подключу.
6659.12 6663.84 SPEAKER_00 Еще я наткнулся на библиотечку.
6663.84 6673.80 SPEAKER_00 Мне нужна была какой-нибудь embedded движок, который может хранить данные и, соответственно, загружать данные прямо в процессе.
6673.80 6677.76 SPEAKER_00 То есть без какой-то отдельной базы данных, а прямо база данных, встроенная в процесс.
6677.76 6683.16 SPEAKER_00 И мне не очень нужен был SQL syntax, иначе я бы, скорее всего, остановился на SQLite.
6683.16 6689.76 SPEAKER_00 Ну и даже когда берешь SQLite, сразу вспоминаешь, что там все работает через interop и как-то не по себе становится.
6689.76 6691.64 SPEAKER_00 Ну, вроде в 21 веке работаем, а тут опять interop.
6691.64 6696.92 SPEAKER_00 В общем, и нагуглил внезапно какую-то интересную библиотечку, которая называется LightDB.
6696.92 6706.24 SPEAKER_00 LightDB – это serverless, соответственно, вам не нужен какой-то выделенный сервак, embedded driver для базы данных, то есть он встраивается непосредственно в ваш процесс.
6706.24 6712.16 SPEAKER_00 Он встраивается в виде одной-единственной DLL, вы ее просто подключаете через зависимость и все, и больше ни о чем не заботитесь.
6712.16 6717.56 SPEAKER_00 Это NoSQL, документ Store, очень похожий по смыслу на MongoDB.
6717.56 6723.44 SPEAKER_00 У него точно такой же примитивный API, ну, примитивный в хорошем смысле этого слова, простой API.
6723.44 6746.76 SPEAKER_00 Он 100% в этой базе данных написан на C#, у него поддерживается полностью ACID транзакции, у него есть хорошие data recovery, допустим, если вдруг случилась ошибка в момент записи данных, там ваше приложение почему-то кильнулось, его убили, есть VOL, все в VOL пишется, потом восстанавливается и соответственно, данные ваши потеряться не должны.
6746.76 6751.60 SPEAKER_00 Встроенное шифрование DES, IS, криптография, все на месте.
6751.60 6757.36 SPEAKER_00 Результат записывается в единственный файл на диске, в базу данных, наподобие SQLite.
6757.36 6765.00 SPEAKER_00 Библиотека полностью open-source, лежит на GitHub, распространяется под MIT лицензией, то есть свободна для всех, даже для коммерческого использования.
6765.00 6772.40 SPEAKER_00 В общем, довольно прекрасно выглядит, много лайков, много коммитов, мне кажется, должна работать хорошо, тоже у меня в планах попробовать.
6772.40 6790.44 SPEAKER_01 Да, я ее как-то видел, мне кажется, но что-то мне no-seq не нужен был особо в таком вот формате, потому что если нужна реализационка, то есть SQLite, собственно, а ее как-то хватало до сих пор.
6790.44 6792.56 SPEAKER_01 Я и в корпусе SQLite, все работает.
6792.56 6795.20 SPEAKER_01 Ну надо будет на заметку себе взять, мало ли пригодится.
6795.20 6798.64 SPEAKER_01 Ну что, все, на сегодня, я думаю, хватит.
6798.64 6801.00 SPEAKER_00 Да, кажется, пора заканчивать.
6801.00 6822.76 SPEAKER_01 Посмотрели мы на очень разные темы сегодня, сначала обсудили три performance темы, про EF7, про ISP.NET Core 7 и про MAUI, тоже о версии 7, потом посмотрели, как вы можете добавить свой собственный HTTP-глагол или HTTP-метод в ISP.NET Core, поддержку либо в minimal API, либо в MVC.
6822.76 6826.68 SPEAKER_01 Не очень понятно, зачем вам это сейчас надо, но если хочется, то почему нет.
6826.68 6835.04 SPEAKER_01 Обсудили DotNet Memory Module, который наконец-таки будет нормально документирован, надеемся, через скором времени.
6835.04 6840.36 SPEAKER_01 Посмотрели, как вы можете запустить DotNet 7 с помощью WASM на Raspberry Pi.
6840.36 6845.68 SPEAKER_01 Узнали, какие новые оптимизации нам принесли регионы в деле нормач-коллектора.
6845.68 6863.08 SPEAKER_01 Обсудили философию Quadrifactory, поговорили про всякие разные мелочи типа OpenTelemetry, ELSPY, LightDB, Coding Guidelines, в общем, тоже такая солянка из техники и философии немножечко, потому что Coding Guidelines, это иногда, мне кажется, больше философия в том числе.
6863.08 6865.88 SPEAKER_01 Хотя и практические моменты, конечно, тоже есть.
6865.88 6867.76 SPEAKER_01 Примерно так, на этом будем заканчивать.
6867.76 6876.08 SPEAKER_00 Да, всем счастливо, слушайте и подписывайтесь, советуйте нас друзьям, распространяйте как только можно, мы будем очень счастливы.
6876.08 6877.08 SPEAKER_00 Всем пока.
6877.08 6877.60 SPEAKER_00 Всем пока.
6877.68 6878.68 None Пока.
6878.76 6879.76 None Пока.
6879.84 6880.84 None Пока.
6880.84 6881.84 None Пока.
6881.84 6882.84 None Пока.
6882.84 6883.84 None Пока.
6883.84 6884.84 None Пока.
6884.84 6885.84 None Пока.
