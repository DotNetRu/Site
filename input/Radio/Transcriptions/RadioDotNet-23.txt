0.00 9.44 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Radio.net, выпуск 23.
9.44 13.20 "Анатолий Кулаков" И сегодня в студии будет Анатолий Кулаков.
13.20 15.08 "Анатолий Кулаков" И Игорь Лабутин, как обычно.
15.08 24.60 "Анатолий Кулаков" И с самого начала хотелось бы выразить огромную благодарность за то, что поддерживаете нас на Patreon и Boosty, и особенно Александру.
24.60 26.68 "Анатолий Кулаков" Александр, спасибо большое, твоя помощь очень важна
26.68 31.24 "Игорь Лабутин" для нас. Начать мы хотим с комментария к прошлому выпуску.
31.24 42.00 "Игорь Лабутин" Мы обсуждали DI-контейнеры и про то, какие типы регистрации там есть, всякие синглтоны, скоупт, транзиент и чем они все отличаются.
42.00 46.36 "Игорь Лабутин" И надо сказать, туда вкралась некоторая, ну не ошибка, но некоторая неточность.
46.36 60.56 "Игорь Лабутин" Мы говорили про то, что довольно популярная ошибка в том, что в синглтон можно запихнуть ко зависимости что-то с регистрацией как скоупт, и это будет проблемой, потому что оно будет жить долго, потому что синглтон живет вечно.
60.56 64.28 "Игорь Лабутин" Но на самом деле, начиная с .NET Core 2.2, это не так.
64.28 72.72 "Игорь Лабутин" В смысле запихнуть-то вы можете попробовать, но у вас будет ошибка, и вам на самом деле ругнется контейнер про то, что так делать нельзя.
72.72 78.32 None .NET команда, к счастью, это в .NET Core 2.2 поправила, и стало все хорошо.
78.32 94.68 "Игорь Лабутин" Но мы, несмотря на то, что в подкасте тут все обсуждаем, всякие .NET 5, .NET 6 и все такое новенькое, в реальном продакшене у меня, например, до сих пор 2.1, так что поэтому я еще не успел увидеть 2.2 вживую во всех его деталях и попробовать во всех возможных вариантах.
94.68 97.20 "Игорь Лабутин" Так что именно поэтому ошибка и вкралась.
97.20 101.48 "Анатолий Кулаков" А еще мы с Игорем с начала года решили отметить тем, что почистить наш бэклог.
101.48 113.68 "Анатолий Кулаков" Это не тайна, что многие статьи, которые мы намечаем к выпуску, не попадают к нам в официальный выпуск, и, наверное, устаревают со временем, но статьи все отличные, хорошие, и довольно жалко их было просто так выбрасывать.
113.68 125.12 "Анатолий Кулаков" Поэтому мы собрали их в некий документик и сделали своеобразный блог-пост с теми статьями, которые за прошлый год не вошли у нас ни в один выпуск, но все-таки их интересно было бы про них рассказать.
125.12 133.76 "Анатолий Кулаков" Вот эти линки и краткое их описание вы сможете найти как раз-таки на наших блогах на Boosty и Patreon.
133.76 140.04 "Анатолий Кулаков" Статьи полностью открытые, поэтому они будут доступны абсолютно каждому без необходимости за них платить.
140.04 142.28 "Анатолий Кулаков" Вот если вам интересно, тоже зайдите, посмотрите.
142.28 144.44 "Анатолий Кулаков" Там есть много интересных вещей.
144.44 154.36 "Анатолий Кулаков" И если вам кажется, что оттуда что-то стоило бы все-таки рассказать, тема замечательная, интересная, опять же, пишите в комментарии, и мы в будущем учтем ваши пожелания.
154.36 158.08 "Игорь Лабутин" И можем, на самом деле, вернуть статью в бэклог и действительно обсудить ее более подробно.
158.08 168.56 "Игорь Лабутин" То, что она оттуда попала, не означает, что мы отказываемся ее обсуждать, просто нам показалось, что так или иначе есть другие, более актуальные, более интересные темы.
168.56 176.60 "Игорь Лабутин" Пойдем к нашим основным темам и начинаем мы, как обычно, с .NET 5, 6 и всех новостей вокруг основной платформы.
176.60 182.20 "Игорь Лабутин" И здесь Microsoft выпустил новость, что доступно Preview 1.
182.20 197.48 "Игорь Лабутин" Когда я открывал эту статью, я думал, ну, Preview 1, обычно там не так много всяких штук, и, скорее всего, там будет не так много всего новенького, но оказалось, что прям, блин, Microsoft очень сильно постарались, и уже к февралю выплатило довольно много новых изменений.
197.48 207.48 "Игорь Лабутин" Но статья содержит не только то, что вошло непосредственно в Preview 1, а вообще некоторый обзор того, что будет в том или ином виде доступно в .NET 6.
207.48 213.56 "Игорь Лабутин" Поэтому давайте пробежимся немножко сначала по общим темам, а потом затронем, что добавилось в Preview 1.
213.56 220.88 "Игорь Лабутин" Одним из основных улучшений и добавлений в .NET 6 будет поддержка платформ, более расширенная, более углубленная.
220.88 240.88 "Игорь Лабутин" Главной добавкой, главным довеском в .NET 6 будет поддержка Android и iOS, но не забывают и macOS с новым Apple M1, и добавляют поддержку Windows ARM 64, она уже была, но она была только для консольных и S Pen откорных приложений, будет поддержан Windows Desktop, я про это чуть дальше скажу.
240.88 278.72 "Игорь Лабутин" То, что касается UI, то, что мы знаем как MAUI, .NET мультиплатформ App UI, живет и развивается, это реинкарнация Xamarin.Forms, и в .NET 6 основные улучшения мы должны ждать в области перформанса, добавления новых тем, то есть новый look and feel будет, и более качественный developer experience, то есть все должно собираться быстрее, грузиться быстрее, и ваш feedback cycle, так называемый, или developer cycle, когда вы что-то поменяли, должен быть гораздо более шустрым.
278.72 290.18 "Игорь Лабутин" В превью 1 конкретно включена поддержка Android и iOS для .NET мультиплатформ App UI, можно уже на это начинать смотреть и примериваться, насколько это будет перспективно для использования.
290.18 302.60 "Игорь Лабутин" В области UI появилась еще одна штука, точнее не то, чтобы появилась, а запланирована пока еще, это Blazor Testtop App, она в каком-то виде уже есть, но там еще работы много, поэтому будем следить за обновлениями.
302.60 324.16 None В целом эта штука очень похожа на Electron, то есть это внутренний веб-сервер, который сервит вам Blazor, сервер-сайт Blazor, и кроме этого можно сервить все, что угодно остальное, там всякие JavaScript, CSS, таким образом вы можете, ну по сути, сделать нечто подобное электрон-приложению из вашего web-based приложения на Blazor.
324.16 343.04 "Игорь Лабутин" Особенно хочется отметить, что здесь не идет речь о Blazor WebAssembly, Microsoft считает, что WebAssembly на десктопе особо нафиг не сдалось, потому что оно довольно медленное за счет дополнительной трансляции получается, ну или по крайней мере медленнее, чем нативный код, и поэтому кажется, что незачем.
343.04 358.04 "Игорь Лабутин" Вторая важная штука, что Blazor Testtop App смогут интегрироваться с нативным UI, например с WPF, то есть вы можете написать в WPF на приложении, где один из контролов будет кусочек от Blazor, и там будет рендериться, соответственно, Blazor-ная часть.
358.04 364.96 "Игорь Лабутин" При этом эта Blazor-ная часть может полноценно взаимодействовать с WPF-ю UI, то есть там показывают, например, WPF на MS-Edgebox и так далее.
364.96 369.12 "Игорь Лабутин" Это такой хороший способ заинтегрировать эти кусочки
369.12 379.48 "Анатолий Кулаков" вашего приложения из веб-части в десктопную часть. Слушай, а будет ли какой-то способ написать один раз приложение на Blazor и запускать его и в браузере, и в нативном окошке?
379.48 381.04 "Анатолий Кулаков" Или мне нужно два разных приложения делать?
381.04 383.04 "Анатолий Кулаков" То есть там таргет какой стоит?
383.04 393.60 "Игорь Лабутин" Насколько я видел, пока это все-таки два разных приложения, потому что электронная обвязка, она все-таки требует некоторого отдельной сборки, ну не электронная обвязка, а в смысле электрон-лайк обвязка.
393.60 407.40 "Игорь Лабутин" Но поскольку речь идет про то, что, и вообще почти во всех топиках, относящихся к DotNet 6, речь идет про всякие улучшенные Developer Experience, я допускаю, что Microsoft будет работать в направлении того, чтобы это было вообще прямо одно приложение.
407.40 408.40 "Игорь Лабутин" Посмотрим.
408.40 413.40 "Игорь Лабутин" Пока рано говорить, и я пока не видел ничего такого, но может быть я пропустил.
413.40 418.20 "Игорь Лабутин" Новостей реально много вокруг этого, и сложно следить.
418.20 436.28 "Игорь Лабутин" Большой топик, если вам интересно последить более детально со всем тем, что происходит, есть такой сайт, называется Themes of .net, типа темы .net, где ребята из Microsoft написали простенький тул, он довольно по отзывам в Twitter тормозной, местами подучий, но в целом работает.
436.28 452.48 "Игорь Лабутин" Он показывает все те же иши, из которых вы видите на GitHub в виде дерева, типа вот те самые топики, типа Streams, потом Epics, внутри типа Stork, внутри Task, то есть некоторую иерархию сущностей, на основе которой команда .net и работает.
452.48 461.36 "Игорь Лабутин" То есть там можно пофильтровать по интересующим вас темам, и там можно конкретно смотреть все иши, которые есть в определенном топике, Epics и так далее.
461.36 467.76 "Игорь Лабутин" То есть если вам интересно почитать и последить, как это все происходит, гляньте туда, там все достаточно наглядно видно.
467.76 473.76 "Игорь Лабутин" Следующий кусочек довольно интересный, они называют Fast Inner Loop.
473.76 475.52 "Игорь Лабутин" Он состоит из двух частей.
475.52 478.68 None Первая часть это сделать билды быстрее.
478.68 488.36 None В Microsoft сейчас есть некоторое количество внутренних, они это называют проектов, в смысле ведется работа над тем, чтобы сделать билды быстрее.
488.36 505.56 "Игорь Лабутин" Система с билд вообще довольно-таки гибкая, но при этом довольно-таки тормозная, поскольку она очень много работает со строчками, и ей приходится делать вот эти два прохода, один раз вычислять property, потом вычислять все остальное, и они довольно сейчас много работают над оптимизацией билда.
505.56 517.68 "Игорь Лабутин" Плюс в билде, даже не связанном с MS Build, есть части, которые тоже не оптимальны, то есть известно, что, например, довольно долго занимает поиск референсов и определение вообще какие длейки используют для референсов.
517.68 520.00 "Игорь Лабутин" Над этим всем ведется работа, чтобы было побыстрее.
520.00 522.72 "Игорь Лабутин" А вторая часть, она более интересная.
522.72 536.36 "Игорь Лабутин" Они хотят попробовать сделать так, чтобы не нужно было вообще собирать варкод во время разработки, и все ваши изменения кода будут прямо в живом виде отправляться в процесс, который работает, и без необходимости рестартовать процесс.
536.36 549.48 "Игорь Лабутин" Такая фиша есть уже в Xamarin для XAML, называется XAML Hot Reload, и Microsoft хочет расширить ее для C# и, собственно, Intermediate Language, причем для обоих рантаймов, для Core CLR и для Mono.
549.48 558.12 "Игорь Лабутин" То есть можно будет прямо, так сказать, писать код, менять код, а у вас ваше приложение будет менять поведение без необходимости пересборки, и все будет работать в рантайме.
558.12 559.76 "Игорь Лабутин" Звучит довольно-таки интересно.
559.76 561.44 "Игорь Лабутин" Да, звучит очень интересно.
561.44 580.60 "Игорь Лабутин" Они говорят, что, несомненно, это точно требует изменения рантайма, то есть это не просто какая-то новая фича C# или тулинга, которую можно сделать на текущем рантайме, рантайм точно потребуется менять, но они очень хотят этого делать, потому что это довольно сильно улучшит экспириенс и в некотором смысле приблизит C# к каким-нибудь скриптовым языкам.
580.60 581.60 None Так, ARP64.
581.60 591.92 "Игорь Лабутин" Я уже сказал, что добавляют ARP64 в Windows поддержку, которая уже была, но была только для консольных и ASP.NET Core приложений, сейчас добавили WinForms и WPF.
591.92 595.32 "Игорь Лабутин" Теперь на Windows ARP64 можно делать полноценный UI-десктопный.
595.32 603.60 "Игорь Лабутин" И добавили начальную поддержку Apple M1, пока только для консольных и ASP.NET Core приложений, но, как обычно, начинают с простого.
603.60 608.28 "Игорь Лабутин" И ведутся много работ, я чуть-чуть дальше еще расскажу про Apple.
608.28 609.28 "Игорь Лабутин" Контейнеры.
609.28 610.28 "Игорь Лабутин" Контейнеры - важная тема.
610.28 616.96 "Игорь Лабутин" В основном, основная работа ведется по таким направлениям, то есть уменьшение размера и увеличение перфоманса.
616.96 619.72 "Игорь Лабутин" В общем-то, там никаких особых новостей нет.
619.72 629.80 "Игорь Лабутин" В DotA 6 стандартные образы, то есть официальные образы от Microsoft для контейнеров будут базироваться либо на Alpine 3.13 или более поздний, который там выйдет к Новоебрю.
629.80 633.68 "Игорь Лабутин" Они используют еще Debian 11 и Ubuntu 20.04.
633.68 636.80 "Игорь Лабутин" Вот, интересно, что Debian 11 еще пока в не...
636.80 646.04 "Игорь Лабутин" Ох, не помню, как называется Debian, не совсем стейбл релиз, но они надеются, что к Ноябрю Debian 11 уже будет стейбл, и на нем они будут все выпускать.
646.04 647.04 "Игорь Лабутин" Почему так?
647.04 660.40 "Игорь Лабутин" Потому что предыдущая десятка выпущена довольно давно, а DotNet 6, которая релизится в ноябре, будет официальным long-term support релизом, то есть он будет поддерживаться три года, и поэтому они хотят сразу уже базироваться на чем-то более новом.
660.40 662.76 "Игорь Лабутин" Так, поехали дальше.
662.76 675.52 "Игорь Лабутин" Во, одна из тем, всего DotNet 6 релиза, которые они хотят тоже сделать, и таких тем будет много, и в каждом DotNet Preview обзорной статье будет описываться одна или две таких темы.
675.52 679.40 "Игорь Лабутин" В статье про Preview 1 темой стал Profile Guided Optimization.
679.40 690.72 "Игорь Лабутин" Microsoft хочет улучшить скорость стартапа приложений и пропускную способность приложений, то есть количество обрабатываемых запросов, используя информацию о времени выполнения.
690.72 692.84 "Игорь Лабутин" Вообще, что такое Profile Guided Optimization?
692.84 708.28 "Игорь Лабутин" Это штука, которую вы можете использовать за счет некоторого внешнего тулинга, вы запускаете ваше приложение, этот тул собирает какую-то информацию о том, какой код у вас там работает, какой код выполняется чаще, какой реже, какой может вообще не выполняется.
708.28 716.48 "Игорь Лабутин" После этого эта информация коллектится, отдается на откуп специальному коду-генератору, он называется CrossGen.
716.48 727.96 "Игорь Лабутин" После этого рядом с вашими нативными, не нативными, а managed delay'ками складываются нативные delay'ки, которые соответственно оптимизированы под тот сценарий, на котором вы все это тренировали.
727.96 731.00 "Игорь Лабутин" Дальше выясняется, что у вас есть еще сценарий, который надо перетренировать.
731.00 742.68 "Игорь Лабутин" В общем, процедура такая довольно-таки нужная, чревата ошибками и подходит по сути только для приложений, как мне кажется, у которых довольно узкая область применения или там хорошо известный сценарий.
742.68 748.12 "Игорь Лабутин" Там число дробилок, которые всегда работают одним и тем же способом, ну наверное для них это все очень хорошо.
748.12 751.72 "Игорь Лабутин" Regit тоже поддерживает Profile Guided Optimization.
751.72 753.72 "Игорь Лабутин" Тут немножко другая тема.
753.72 769.40 "Игорь Лабутин" Мы помним, что в DotA 5 была добавлена штука, что Git умеет перегенерировать код, если он понимает, что что-то используется более часто, генерить более оптимальную версию и так далее за счет информации о том, как вызываются методы.
769.40 772.40 "Игорь Лабутин" Это все нормально, это все хорошо и сейчас уже поддержано.
772.40 779.88 "Игорь Лабутин" И классический код, когда мы говорим о Profile Guided Optimization, разделяется на две категории - hot и cold.
779.88 783.60 "Игорь Лабутин" Hot - это тот, который, соответственно, выполняется часто и много.
783.60 787.64 "Игорь Лабутин" Cold - это тот, который выполняется редко, мало или может быть вообще не выполняется.
787.64 795.28 "Игорь Лабутин" Идея в том, чтобы весь код, который hot, положить где-нибудь рядышком, чтобы он уже был в кэше процессора, ну и достаточно быстро работал за счет этого.
795.28 803.48 "Игорь Лабутин" В менеджмент языках появляется еще категория very cold - это тот, который точно вообще не надо генерить в нативный код.
803.48 814.72 "Игорь Лабутин" Это всякие там код кидания исключений, коды обработки ошибок, которые должны по идее никогда выполняться, ха-ха, и он просто джетуется на лету, когда нужно.
814.72 817.80 "Игорь Лабутин" В шестом дотнете есть планы сделать следующее.
817.80 821.36 "Игорь Лабутин" Во-первых, улучшить тулинг, сделать его более простым.
821.36 840.92 "Игорь Лабутин" Во-вторых, все эти данные, которые использовались, чтобы натренировать этот кроссген для стандартных дотнет библиотек, сделать публичными, чтобы, например, другие вендоры, как мы в прошлый раз говорили, например, Red Hat делает свою сборку дотнета в Linux, могли использовать эти данные для того, чтобы генерить свои собственные версии бинарников, предоптимизированных для своих платформ.
840.92 847.88 "Игорь Лабутин" Дальше Microsoft хочет дать возможность собирать вот эту training data для приложений прямо в продакшене.
847.88 857.76 "Игорь Лабутин" Сейчас это делается, по сути, на девелоперской машине либо где-то в каком-то более контролируемом окружении, но можно делать, в принципе, это и в продакшене, наверное, даже лучше делать это в продакшене, потому что оптимизируем тв под продакшен.
857.76 868.32 "Игорь Лабутин" А четвертое, G2 дадут возможность использовать вот эту статическую данные от тренировок вашего алгоритма, не алгоритма, а кроссгена.
868.32 875.52 "Игорь Лабутин" И в пятых, G2 сделают еще более умным, так что ему не нужно будет тренироваться заранее, он будет на лету понимать чё как.
875.52 878.52 "Игорь Лабутин" Ну, то есть, типа как та R2 компиляция, только еще
878.52 883.28 None более умная. В общем, планов много, общий прирост при этом.
883.28 902.36 "Игорь Лабутин" Я ожидал там увидеть какие-то шумошедшие цифры, но по факту они обещают, что порядка 10% в среднем улучшения, хотя если это реальные числа-надробилка, как я говорил, то там можно ожидать и больше, но объем работы настолько велик, что Microsoft сразу говорит, что в DotNet 6 это, ну, скорее всего, полностью сделано не будет, это займет два полных релиза.
902.36 905.72 "Игорь Лабутин" То есть мы финальный результат увидим только в году через полтора-два.
905.72 912.84 "Игорь Лабутин" Но, к счастью, Microsoft сейчас работает, так сказать, по Agile и мы увидим все эти фишки потихонечку появляющиеся
912.84 917.72 None в превью. А теперь, собственно, к тому, что появилось в превью 1, практическим моментом.
917.72 923.16 "Игорь Лабутин" Во-первых, улучшили DotNet Command Line Interface, появились респонс-файлы.
923.16 926.16 "Игорь Лабутин" Толя, ты помнишь, что такое респонс-файлы, вообще пользовался хоть когда-нибудь?
926.16 927.68 "Игорь Лабутин" Нет, по-моему, не приходилось.
927.68 933.36 "Игорь Лабутин" Вот мне казалось, что я где-то видел эти файлики с расширением RSP, но я здесь никогда не пользовался.
933.36 934.36 "Игорь Лабутин" Смысл в чем?
934.36 941.32 "Игорь Лабутин" Обычно для всяких там pet-проектов и маленьких проектов вы просто набираете dotnet build и у вас все работает, все собирается и все готово.
941.32 946.80 "Игорь Лабутин" Но в маломальски сложном проекте dotnet build требует некоторого количества дополнительных аргументов.
946.80 953.68 "Игорь Лабутин" Передать какие-нибудь проперти, изокружение, еще что-нибудь и, в общем, получается довольно длинная строчка аргументов.
953.68 960.04 "Игорь Лабутин" Вот теперь эту строчку аргументов можно записать в файлик и передать имя этого файлика через собачку.
960.04 964.32 "Игорь Лабутин" То есть вы пишете dotnet, пробьет build, пробьет собачка, там, demo.rsp.
964.32 972.80 "Игорь Лабутин" И все аргументы, которые лежат в этом rsp-файлике, это просто текстовый файлик, они берутся и подставляются, как будто они были заданы вам в хомейтлайне.
972.80 976.84 "Анатолий Кулаков" Ну да, я обычно использовал какие-нибудь скриптовые языки, в которых этой проблемы не стоит.
976.84 982.28 "Анатолий Кулаков" Ты там всегда мог состряпать себе массив из аргументов с помощью встроенных средств, скриптов.
982.28 990.52 "Игорь Лабутин" Да, но это решает еще одну проблему, не только собрать массив аргументов или длинную строчку, а решает некоторые ограничения длины командной строки.
990.52 996.56 "Игорь Лабутин" CMD.exe, как мы помним, имеет ограничения на длину разрешенной командной строки, если у вас аргументов очень много,
996.56 998.56 None вы ее превысите. Это правда.
998.56 1003.84 "Игорь Лабутин" А тут командная строчка точно короткая, а все длинное идет в rsp-файл.
1003.84 1009.16 "Игорь Лабутин" Вторая штука, которая появилась, это так называемые две новые директивы, suggest и parse.
1009.16 1016.84 "Игорь Лабутин" То есть теперь в dotnet есть возможность делать в некотором смысле дополнение команд, и она как бы есть и есть.
1016.84 1018.80 "Игорь Лабутин" А вот вторая, parse, она интересная.
1018.80 1036.40 "Игорь Лабутин" То есть теперь можно написать dotnet parse и дальше то, что вы обычно писали, тот же build, там что-нибудь, и в ответ вам вернется, ну, не AST, конечно, но в некотором смысле распарсенный вид того, как dotnet приложение, dotnet вот это вот, .exe, распарсил вашу командную строчку.
1036.40 1042.60 "Игорь Лабутин" Microsoft говорит, что это очень полезно и популярно для понимания, почему ваша командная строка работает не так, как вы ожидаете.
1042.60 1048.80 "Игорь Лабутин" То есть где вы там забыли какие-нибудь кавычки, как передали аргументы, не туда, не там, не так и так далее.
1048.80 1054.16 "Игорь Лабутин" То есть вам, по сути, dotnet покажет внутреннюю кухню, как он видит вашу командную строчку.
1054.16 1055.56 "Игорь Лабутин" Может быть будет где-то полезно.
1055.56 1060.60 "Игорь Лабутин" Возможно как раз при сборке скриптами, что parse вам расскажет, как вы что где собрали.
1060.60 1073.56 "Игорь Лабутин" Дальше добавилось некоторое количество новых библиотек, появились некоторые решения в math API, там всякие улучшенные синусы, косинусы, местами стали возвращаться туплы вместо out параметров.
1073.56 1077.84 "Игорь Лабутин" Ну то есть если вам как-то работать с математикой, посмотрите.
1077.84 1087.52 "Игорь Лабутин" Улучшили поддержку Windows Access Control Lists, но тут по сути они вернули, не вернули, а реализовали все то, что было и так реализовано в dotnet framework.
1087.52 1093.96 "Игорь Лабутин" Поэтому если вы опять же работаете с Windows ACL, то загляните, может быть там найдете что-то полезное.
1093.96 1098.00 "Игорь Лабутин" И довольно интересные изменения в dotnet 6 по дефолту.
1098.00 1115.00 "Игорь Лабутин" Теперь используется portable thread pool, то есть раньше thread pool писался на нативных, так скажем, примитивах, сейчас он полностью менеджит имплементацию и на всех платформах, которые поддерживает dotnet 6, он будет один и тот же, независимо от операционной системы.
1115.00 1124.52 "Игорь Лабутин" Пока это поведение можно отключить и вернуться к операционной системе, зависимой, но нет никаких гарантий, сколько этот ключ проживет для отключения.
1124.52 1127.20 "Игорь Лабутин" Так что теперь thread pool будет везде общий и одинаковый.
1127.20 1133.08 "Игорь Лабутин" Скорее всего вы вообще этого никак не заметите, Microsoft утверждает, что по их тестам разницы нет никакой.
1133.08 1135.60 "Игорь Лабутин" Предсказуем столько больше, что везде работает одинаково.
1135.60 1136.60 None Рантайм.
1136.60 1141.16 "Игорь Лабутин" Здесь как раз таки интересные изменения, это Apple M1 support.
1141.16 1172.56 "Игорь Лабутин" Пока Microsoft говорит, что рассматривать его как alpha quality, то есть оно работает, но так, никакого пока автоматизированного тестирования нет, еще не настроено в них, поэтому полного гарантии они дать не могут, у них есть пока некоторые проблемы, полные перформанс тесты и стресс тесты не проходят еще пока на M1, но тем не менее, работа над этим ведется и я так понимаю, что судя по огромному количеству отсылок к Apple и слов благодарности Apple, Microsoft с Apple работают довольно тесно, чтобы это все заработало.
1172.56 1176.60 "Игорь Лабутин" При этом самое, может быть, интересное, что он не работает
1176.60 1182.32 None отладка совсем пока и она появится не раньше превью третьего, а может быть даже и позднее.
1182.32 1185.96 "Игорь Лабутин" Так что Apple M1 в дотнете это пока так, чисто поиграться.
1185.96 1191.88 "Игорь Лабутин" При этом x64 версия нормально работает с эмуляцией, так что тут спокойно пользуйтесь, если надо.
1191.88 1206.28 "Игорь Лабутин" Наконец-таки заимпровили single file app, сколько мы обсуждали этот паблишинг и то, что мы можем теперь дотнет приложение запаблишить в виде отдельного одного файла за тем исключением, что на винде и на макоси там нужно было один или два длельки нативных положить
1206.28 1217.48 None таки рядышком. Все, теперь не нужно, теперь это все гарантированно один единственный бинарник, который вы точно можете распространять просто как без необходимости распаковки его куда-либо в процессе рантайма.
1217.48 1225.64 "Игорь Лабутин" Но если ваше приложение использует какие-то нативные зависимости, то их внутрь запаковать не получится, они должны лежать рядом.
1225.64 1251.20 "Игорь Лабутин" Дальше идем, улучшили, добавили точнее новый кроссген, то есть это вариант кода генератора, компилятора по сути, который умеет компилировать из вашего менеджменаторского кода, то что называется длельки, то есть готовые нативные бинарники, которые будут использоваться вместо JIT-версии, причем вы можете это делать кросс-платформенно, то есть если вы находитесь на винде, вы можете сгенерить такие длельки для линукса.
1251.20 1264.04 "Игорь Лабутин" Запускаться они естественно не смогут на винде, но сгенерить вы их полностью можете, то есть вы можете использовать вашу единственную билд-машину, например виндовую или там линуксовую какая у вас есть, для того чтобы генерить эти кроссген-библиотеки для всех платформ, куда вы таргетитесь.
1264.04 1265.04 "Игорь Лабутин" Это прям удобно.
1265.04 1275.12 "Игорь Лабутин" Ну и естественно куча работы по перформансу, то есть ARM64 улучшили перформанс, добавили некоторые оптимизации для структуры очередные, много работ над своими собственными
1275.12 1279.08 None перформанс-тестами, чтобы там было все стабильно, аккуратно и красиво.
1279.08 1285.12 "Игорь Лабутин" В общем, примерно такое уже готово в Totnet 6, Preview 1, ждем что же будет дальше.
1285.12 1286.64 "Игорь Лабутин" У нас еще сколько?
1286.64 1291.68 "Игорь Лабутин" 8 месяцев минимум работы, которые скорее всего принесут огромное количество интересностей.
1291.68 1305.64 "Игорь Лабутин" Как обычно, вместе с Totnet естественно зареализовался Asp.NET Core 6 Preview 1, там ничего сильно интересного нет, там добавили поддержку IOCing Disposable, где нужно, и немножко больше разметили на лоббл аннотейшнами типы.
1305.64 1322.12 "Игорь Лабутин" В EF Core 6 добавилось побольше, добавились некоторые новые атрибутики, теперь можно указывать у строковых полей должны ли они быть юникодными или нет, если указать явный юникод false, то EF Core будет использовать в базе не юникодные колонки.
1322.12 1338.28 "Игорь Лабутин" Можно указывать у полей Precision теперь атрибутиком, можно задавать отдельно, теперь есть новый атрибут EntityTypeConfiguration, которым можно задать специальный класс, который будет вам конфигурить конкретную модель.
1338.28 1351.20 "Игорь Лабутин" То есть не обязательно теперь всю конфигурацию для модели делать в одном единственном классе, а сделать на генерите отдельных классиков для каждой из ваших моделей данных и потом их всех поюзать через атрибуты.
1351.20 1354.56 "Игорь Лабутин" Ну, возможно, так будет удобно в некотором смысле.
1354.56 1361.36 "Игорь Лабутин" Майкрософт работает довольно активно над поддержкой SQLite, они добавили там некоторое количество новых функций для него.
1361.36 1370.52 "Игорь Лабутин" Есть новая функция EF Functions Random, если вы ее используете в вашей link_u запросе, она корректно транслируется в random функцию в вашей базе данных.
1370.52 1386.64 "Игорь Лабутин" Ну и SQL Server поддержали то, что называется SparseCodes, это специальные колонки, оптимизированные для случая, когда у вас очень много null в этих колонках, теперь это можно указать прямо явно в EF Core, и он соответствующий, запись, точнее, скейнерит соответствующие колонки в базе при работе.
1386.64 1387.64 "Игорь Лабутин" Как-то так.
1387.64 1392.04 "Анатолий Кулаков" Хорошая работа проделана, то есть будущая Elyse прям сулит много всего интересного.
1392.04 1399.84 "Анатолий Кулаков" Кстати, заметь, нет ничего про новые синтакси языка, ну то есть какие-нибудь новые конструкции, синтаксические сахары, кейварды, пока молчат.
1399.84 1411.08 "Игорь Лабутин" Да, про C# следующие как-то пока действительно ничего особо не слышно, либо там готовятся какие-то огромные большие фичи, либо там действительно пока довольно тихая работа, которая требует просто много времени.
1411.08 1421.20 "Игорь Лабутин" Может быть, кстати, к следующему выпуску будет интересно заглянуть просто в backlog, у них уже все это публично, и посмотреть, какие в принципе фичи в C# 10, в каком состоянии они находятся.
1421.20 1422.20 "Игорь Лабутин" Может быть, сделаем.
1422.20 1434.40 "Анатолий Кулаков" Слушай, ну вот многому было таких пожеланий, что хватит нам выбрасывать новые фичи языка, потому что мы не успеваем их как бы уже читать, уже учить, и давайте оптимизируйте уже инфраструктуру, рантайм, тулзы и все вокруг.
1434.40 1438.84 "Анатолий Кулаков" Может быть, кстати, Microsoft в этом релизе и на этом сосредоточится, тем более это LTS?
1438.84 1439.84 "Анатолий Кулаков" Да.
1439.84 1445.20 "Анатолий Кулаков" То есть для C# там уже все хорошо, поэтому было бы неплохо вокруг инфраструктуру пора оптимизировать.
1445.20 1447.52 "Игорь Лабутин" Ну, будем смотреть, поизучаем.
1447.52 1449.00 "Игорь Лабутин" Новости мимо нас не пройдут.
1449.00 1450.00 "Анатолий Кулаков" Ну, хорошо.
1450.00 1455.48 "Анатолий Кулаков" Не отходя далеко от Microsoft, еще один наш друг, компания JetBrains, выпустила интересный отчетик.
1455.48 1458.60 "Анатолий Кулаков" Это отчет за 2020 год.
1458.60 1464.80 "Анатолий Кулаков" То есть компания рассказала, что же, собственно, она достигла, какие цифры она получила в прошедшем году.
1464.80 1470.40 "Анатолий Кулаков" Год был непростой для многих компаний, но для JetBrains год выдался довольно продуктивным и интересным.
1470.40 1490.68 "Анатолий Кулаков" И, наверное, статейка больше маркетинга, но я все-таки хочу, чтобы разработчики тоже знали, что там есть, что происходит, потому что JetBrains - это одна из немногих российских IT-компаний, которая отлично видна и на мировой арене, и нужно понимать, чем живет компания, почему ее так все любят и куда она развивается.
1490.68 1493.64 "Анатолий Кулаков" Поэтому давайте посмотрим немножко цифрок.
1493.64 1498.52 "Анатолий Кулаков" Во-первых, это больше 10 миллионов разработчиков используют инструменты JetBrains.
1498.52 1502.48 "Анатолий Кулаков" 175 новых организаций становятся клиентами каждый день.
1502.48 1507.36 "Анатолий Кулаков" 2800 человек становятся пользователями продуктов каждый день.
1507.36 1509.04 "Анатолий Кулаков" Представляешь, эти цифры просто.
1509.04 1511.12 "Анатолий Кулаков" Каждый день по 2800 человек.
1511.12 1514.04 "Анатолий Кулаков" Всего сейчас в портфеле компании 30 продуктов.
1514.04 1521.36 "Анатолий Кулаков" На 11% вырос рост выручки по сравнению с прошлым годом, напоминаю, что мы говорим про 2020.
1521.36 1525.48 "Анатолий Кулаков" Аж более 6000 плагинов размещено в маркетплейсе.
1525.48 1530.08 "Анатолий Кулаков" 1500 сотрудников работают и плюс еще 30 стажеров.
1530.08 1535.00 "Анатолий Кулаков" Всего у компании сейчас 9 офисов, в России 3 - Питер, Новосибирск и Москва.
1535.00 1541.92 None Что-то как-то про стажеров, там их точно 30 как-то на 1500 сотрудников, 30 как-то маловато стажеров-то.
1541.92 1544.04 "Игорь Лабутин" 300 стажеров, я наверное оговорился.
1544.04 1546.04 "Игорь Лабутин" 300 стажеров, ух ты, дофига.
1546.04 1548.48 "Игорь Лабутин" Ну то есть это на самом деле 1/5 компании по сути.
1548.48 1550.60 "Игорь Лабутин" Ну да, 1/5, немало.
1550.60 1551.60 "Анатолий Кулаков" По сути да, да.
1551.60 1556.96 "Анатолий Кулаков" И в принципе компания очень плотно работает со всякими университетами, школами и так далее.
1556.96 1557.96 "Анатолий Кулаков" Дальше будут цифры.
1557.96 1571.00 "Анатолий Кулаков" Смотри, прежде всего хотелось бы отметить, что есть такое направление как JetBrains Lab и в рамках его сотрудники могут посвящать 20% рабочего времени своим интересным проектам.
1571.00 1575.44 "Анатолий Кулаков" То есть это то, что много обсуждалось во всяких крупных больших компаниях.
1575.44 1581.84 "Анатолий Кулаков" Оказывается российские компании тоже такие есть, которые дают своим сотрудникам делать проекты на стороне в рабочее время.
1581.84 1583.96 "Анатолий Кулаков" И мне кажется это замечательная практика.
1583.96 1598.32 "Анатолий Кулаков" JetBrains Research - другое интересное направление компании, которое может быть мало известно среди наших слушателей, поэтому хотелось бы сказать, что JetBrains поддерживает научные группы, которые занимаются исследованиями в различных областях.
1598.32 1603.40 "Анатолий Кулаков" От ядерной физики, нейрофизиологии, доработотехники, машинного обучения.
1603.40 1606.76 "Анатолий Кулаков" То есть эта компания не только про программирование, она вкладывается в чистую науку.
1606.76 1613.92 "Анатолий Кулаков" Проект JetBrains Research объединяет 18 лабораторий, 4 из которых сформировались именно в 2020 году.
1613.92 1620.72 "Анатолий Кулаков" В прошедшем году более 50 старшеклассников и около 200 студентов получили стипендию от JetBrains.
1620.72 1626.92 "Анатолий Кулаков" JetBrains Research предоставила гранты 52 исследователям в университетах, институтах и школах.
1626.92 1629.44 "Анатолий Кулаков" По продуктам.
1629.44 1636.60 "Анатолий Кулаков" Общее число активных пользователей, если брать вместе платные и бесплатные подписки, сгруппированные по странам.
1636.60 1644.88 "Анатолий Кулаков" Первое место занимает США, второе место Китай, Германия на третьем месте, Россия на четвертом и на пятом Великобритания.
1644.88 1656.04 "Анатолий Кулаков" Самые быстрорастущие продукты по количеству платных подписок это Rider, вырос на 67% GoLand, это IDE для Go, 48% прирост.
1656.04 1658.44 "Анатолий Кулаков" И DataGrip на 37% прирост.
1658.44 1661.32 "Анатолий Кулаков" Это инструмент для базы данных.
1661.32 1664.36 "Анатолий Кулаков" Редактирование, рефакторинг и управление базами данных.
1664.36 1667.16 "Анатолий Кулаков" Вот как раз таки секция про обучение.
1667.16 1680.84 "Анатолий Кулаков" То есть у JetBrains очень много всяких направлений, которые поощряют ученых, курсы, обучение, школы, университеты, даже open source проект и прочее, прочее, прочее.
1680.84 1691.04 "Анатолий Кулаков" Более 1,3 миллиона студентов и более 80 тысяч преподавателей получили бесплатный JetBrains Education Pack, который они могут использовать, соответственно, в своих обучениях.
1691.04 1699.48 "Анатолий Кулаков" 1,700 школ и университетов получили 133 тысячи бесплатных аудиторных лицензий для обучения программированию.
1699.48 1704.24 "Анатолий Кулаков" 360 учебных курсов воспользовались бесплатными лицензиями для обучения.
1704.24 1712.04 "Анатолий Кулаков" Более 6 тысяч проектов с открытым исходным кодом получили более 10 тысяч бесплатных лицензий для некоммерческой работы.
1712.04 1719.56 "Анатолий Кулаков" И более тысячи IT-сообществ из 87 стран получили более 12 тысяч бесплатных лицензий.
1719.56 1722.16 "Анатолий Кулаков" То есть там цифры огромные практически.
1722.16 1729.60 "Анатолий Кулаков" Если у вас есть такая задача получить бесплатную лицензию от JetBrains, то для вас это должна быть минимальный просто порог.
1729.60 1735.12 "Анатолий Кулаков" Вам достаточно участвовать в open source, обучать или учиться, или быть студентом.
1735.12 1740.56 "Анатолий Кулаков" В общем, просто малейшее ваше усердие практически дарит вам бесплатную лицензию JetBrains.
1740.56 1743.64 "Анатолий Кулаков" И хотелось бы отдельно отметить о поддержке IT-сообщества.
1743.64 1745.40 "Анатолий Кулаков" Вот это действительно правда.
1745.40 1754.28 "Анатолий Кулаков" Это, наверное, единственная программа в России, которая 100% без всяких глупостей и прочей бюрократии работает для некоммерческих IT-сообществ.
1754.28 1763.60 "Анатолий Кулаков" Мы организовали уже 13 сообществ по всей России, и они с радостью подключаются к этой программе от JetBrains и получают отличные подарки.
1763.60 1766.40 "Анатолий Кулаков" То есть отлично стимулируют людей, которые приходят на сообщества.
1766.40 1773.12 "Анатолий Кулаков" Ну и наши постоянные слушатели тоже, наверное, знают, что лицензию JetBrains можно достать и в нашем подкасте.
1773.12 1778.44 "Анатолий Кулаков" Как раз таки потому, что компания активно поддерживает всякие IT-направленности, в том числе вот такие, как
1778.44 1795.16 "Игорь Лабутин" наша. Ну и в 2021 году JetBrains запустила, точнее уже даже свой классический Developer Ecosystem опрос, который вы можете пройти и дать больше информации о том, что происходит в мире девелопмента.
1795.16 1803.96 "Игорь Лабутин" Конечно же, по результатам опроса будут опубликованы всякие сводные информации, разделенные по странам, направлениям, языкам и так далее.
1803.96 1806.80 "Игорь Лабутин" Занимать это должно не больше получаса.
1806.80 1816.28 "Игорь Лабутин" Пройти это все можно на 10 языках и даже выиграть какой-нибудь приз типа Macbook, Playstation, Xbox или что-нибудь от сертификатов на услуги Amazon.
1816.28 1830.16 "Анатолий Кулаков" Еще одна интересная штука, это после прохождения этого отчета JetBrains специально для вас подготовит специализированный отчет, который покажет, а где в стадии дот-нет-разработчиков мировых ваше место.
1830.16 1836.48 "Анатолий Кулаков" То есть, какое вы занимаете место с учетом всех ваших ответов, тоже такой забавный персонализированный отчет.
1836.48 1843.04 "Игорь Лабутин" Да, и при этом надо сказать, что вот эта 30 минут, это такая довольно-таки верхняя оценка.
1843.04 1844.52 "Игорь Лабутин" Ты пробовал вообще проходить его?
1844.52 1846.76 "Анатолий Кулаков" Нет, пока еще не прошел, у меня лежит в закладочках.
1846.76 1862.32 "Игорь Лабутин" Я вот уже прошел, у меня это заняло, наверное, минут 15 от силы и такой могу сказать хинт, не верьте про грозбару внизу, про грозбару будут говорить "вас пройдено" там 20%, 25%, примерно на 27% он мне сказал "ну все, спасибо, вы прошли".
1862.32 1872.24 "Игорь Лабутин" Поэтому не надо бояться того, что там он очень медленно ползет, скорее всего, ответ и вообще общая продолжительность сильно зависит от того, как вы отвечаете.
1872.24 1879.52 "Игорь Лабутин" Может быть мне так повезло, что у меня была краткая версия, я не знаю, но возможно вы справитесь гораздо быстрее, чем за 30 минут.
1879.52 1886.88 "Игорь Лабутин" Потратьте 10 минут, посмотрите, куда вас это заведет и скорее всего для большинства из вас этого будет достаточно.
1886.88 1906.96 "Анатолий Кулаков" Ну и действительно, опросник очень интересный, мы разбираем его практически каждый год и всегда находим там интересные ответы, интересные тренды и в отличие от остальных идиотских трендов, типа какой язык самый лучший, какой язык самый опрашиваемый, самый востребованный, вот этот отчет, этот опрос он строится на ваших настоящих ответах.
1906.96 1915.80 "Анатолий Кулаков" Не пытаются анализироваться какие-то частоты запросов гугла или подробности ответа на Stack Overflow, которые вот как-то косвенно привязывают к тому, какой язык популярен.
1915.80 1933.00 "Анатолий Кулаков" Поэтому вот если вы хотите здесь рассказать о вашем языке, о том, как вы его используете, о том, насколько часто и много он используется на ваших проектах, вот мне кажется этот отчет это один из самых честных и правильных способов узнать и сообщить всему миру о том, как вы используете свою инфраструктуру.
1933.00 1936.36 "Анатолий Кулаков" Поэтому шарьте отчет с друзьями, проходите сами и выигрывайте
1936.36 1939.40 "Игорь Лабутин" призы. Да, и получайте удовольствие, на самом деле он довольно
1939.40 1945.12 None забавно построен, то есть там есть вопросы в стиле какой у вас там язык, а как долго вы на нем пишете,
1945.12 1947.12 None а что вы едите на завтрак. И ты такой, че?
1947.12 1948.12 None А, ну окей.
1948.12 1955.44 "Игорь Лабутин" Как бы довольно интересное ощущение заполнять разнородные ответы на совершенно разнородные вопросы.
1955.44 1961.28 "Анатолий Кулаков" А потом еще корреляцию отследить, типа на каком языке пишут разработчики и что они кушают на завтрак после этого.
1961.28 1962.28 "Игорь Лабутин" Да, да, да, будет забавно посмотреть.
1962.28 1963.28 "Игорь Лабутин" Наверняка же будет такое.
1963.28 1969.00 "Игорь Лабутин" Я по-моему JetBrains в прошлом отчете что-то такое сводил, может быть не про завтраки, но про что-то другое.
1969.00 1975.64 "Анатолий Кулаков" Да, да, про домашних животных сводил, про по-моему спорт сводил, ну то есть такие неотехнические вопросы там тоже есть.
1975.64 1976.64 "Анатолий Кулаков" Погнали дальше.
1976.64 1987.48 "Анатолий Кулаков" Дальше, как только мы еще начинали обсуждать source генераторы, у нас уже вставал вопрос, а какую, собственно, template engine использовать для того, чтобы непосредственно в source генераторах генерить код.
1987.48 1990.84 "Анатолий Кулаков" Потому что само по сравнению код дома, оно довольно-таки тяжко.
1990.84 2018.76 "Анатолий Кулаков" Микрософт рекомендует использовать тупо строчку с возможностями форматирования, но это прокатывает, когда у вас совсем небольшой проект, но когда вы делаете какое-то развеситое приложение, может быть даже с тестами, может быть даже с анализом аиста дерева, может быть даже с какими-то подсказками, то вам необходим какой-то все-таки текстовый движок, с помощью которого вы можете грамотно писать C# код, вставить туда какие-то бандинги к модели и на выходе уже получить непосредственно генерированный source к вашему C#.
2018.76 2023.80 "Анатолий Кулаков" Микрософт явного решения не дал, поэтому сообщество ринулось искать само.
2023.80 2030.76 "Анатолий Кулаков" И насколько я сейчас наблюдаю, в большинстве случаев в сложных source генераторах используется так называемый язык Scriban.
2030.76 2033.28 "Анатолий Кулаков" Вот про него мне бы и хотелось рассказать.
2033.28 2038.52 "Анатолий Кулаков" Если вдруг кто-то тоже столкнулся с такой задачей, обратите внимание на этот пакетик.
2038.52 2042.20 "Анатолий Кулаков" У него есть масса преимуществ, о которых мы сейчас как раз-таки и поговорим.
2042.20 2045.88 "Анатолий Кулаков" Одно из самых главных преимуществ написал его Александр Мютл.
2045.88 2055.72 "Анатолий Кулаков" Для тех, кто не знаком, это специалист широкого профиля, очень сильно повернут на performance, zero location и прочих глупостях.
2055.72 2063.52 "Анатолий Кулаков" Он сейчас работает в компании Unity Technologies, то есть непосредственно оптимизирует код для геймдизайна, для игр.
2063.52 2070.36 "Анатолий Кулаков" И у нас на конференциях делал очень интересные, очень подробные доклады про то, что он может вытворять.
2070.36 2073.28 "Анатолий Кулаков" Человек действительно очень знающий, очень интересный.
2073.28 2082.64 "Анатолий Кулаков" И поэтому, когда я увидел его в качестве автора этого пакета, мне сразу же захотелось попробовать, что же там интересного такого происходит.
2082.64 2084.68 "Анатолий Кулаков" Итак, давайте же разберемся поподробнее.
2084.68 2089.28 "Анатолий Кулаков" На самом деле, этот NGINE довольно-таки не новый.
2089.28 2093.84 "Анатолий Кулаков" Он вышел в 2017 году, появилась его первая бета-версия.
2093.84 2103.08 "Анатолий Кулаков" И этого времени было достаточно для того, чтобы проект обзавелся стабильными клиентами, для того, чтобы исправились основные баги.
2103.08 2112.68 "Анатолий Кулаков" И когда я набрел на статью в блоге Александра, где он рассказывал, как он пришел к этому проекту, я очень сильно узнал себя.
2112.68 2117.76 "Анатолий Кулаков" В принципе, он прошел все те же шаги, которые терзали меня, но он зашел дальше.
2117.76 2121.56 "Анатолий Кулаков" Он все-таки оформил это в отдельный свой пакет, в отдельный свой продукт.
2121.56 2126.32 "Анатолий Кулаков" Начинал он, как и все, наверное, люди, которые хотят генерить, начинал он с T4-темплейтинга.
2126.32 2138.60 "Анатолий Кулаков" T4 - это отличный инструмент, который входит на рабочий набор Visual Studio практически с первых ее версий и позволял вам заниматься кодогенерацией в самых первых языков C#.
2138.60 2145.40 "Анатолий Кулаков" Для Mono также есть кроссплатформенная версия, которая называется Mono Text Templating.
2145.40 2155.84 "Анатолий Кулаков" Всем прекрасен этот энджайн, но Александру не понравилось, что он очень тяжелый, он очень медленный и основывается на C# синтаксисе.
2155.84 2164.36 "Анатолий Кулаков" То есть, вот эти всякие binding вставки, всякие обвязки вокруг данных вам нужно будет описывать на C#.
2164.36 2171.88 "Анатолий Кулаков" Для многих это покажется преимуществом, потому что не нужно учить новый синтаксис, но есть и кое-какие минусы, о которых мы поговорим попозже.
2171.88 2176.96 "Анатолий Кулаков" Следующим, наверное, многие уже знают, был Razer движок.
2176.96 2180.36 "Анатолий Кулаков" Razer выступал прежде всего как часть ASP.NET.
2180.36 2189.56 "Анатолий Кулаков" Он помогал писать очень удобно HTML-шаблоны, HTML-странички, но также был и некий Razer Engine.
2189.56 2198.60 "Анатолий Кулаков" Это специальный оторванный от ASP текстовый движок, который помогал вам встроить Razer-шаблоны прямо в ваше непосредственное приложение.
2198.60 2202.88 "Анатолий Кулаков" Это может быть любое консольное приложение, или .dp в приложении, или .info, не важно.
2202.88 2206.90 "Анатолий Кулаков" В общем, он никак не зависел от ASP.NET, и в принципе довольно часто использовался.
2206.90 2217.36 "Анатолий Кулаков" Например, в почтовых рассылках, если вам нужно было какое-то темплейт-письмо сделать, или просто сгенерить HTML-репорт в вашем приложении, то почему бы и нет.
2217.36 2228.48 "Анатолий Кулаков" Александр уже на этом шагу проанализировал Razer Engine, понял, что он слишком тяжеловесный, и сделал свой вариант Razer движка, который назвал Sharp Razer.
2228.48 2237.88 "Анатолий Кулаков" Он был лучше, он был быстрее, но все также имел C# синтаксис под капотом, и все также в силу своих особенностей был очень медленный.
2237.88 2247.68 "Анатолий Кулаков" Потому что Razer под капотом все-таки компилирует настоящий C# код, и подготавливает непосредственно к рендерингу очень сильно переменной, поэтому компиляция у Razer довольно-таки медленная.
2247.68 2259.76 "Анатолий Кулаков" Далее он начал переделывать свой блок-хост на статический хостинг, и непосредственно столкнулся с самым популярным движком статических сайтов - это Jekyll.
2259.76 2261.80 "Анатолий Кулаков" Jekyll и GitHub Pages.
2261.80 2266.64 "Анатолий Кулаков" Jekyll по умолчанию использует язык темплейтов тоже, который называется Liquid.
2266.64 2274.48 "Анатолий Кулаков" Он довольно-таки простой, он довольно безопасный, потому что не позволяет использовать полностью произвольный код.
2274.48 2289.08 "Анатолий Кулаков" Он запускает всю трансформацию в сэндбоксе, поэтому вы не можете, например, как в T4-темплейтах или в Razer-темплейтах запустить произвольный C# код, сходить в интернет, выклювать диск и закачать куда-нибудь все ваши секретные файлы.
2289.08 2295.48 "Анатолий Кулаков" У Liquid довольно ограниченные синтаксис, и поэтому там вообще работы с файлой системы и прочими глупостями нет.
2295.48 2304.76 "Анатолий Кулаков" Далее Mute решил написать свой статический движок, то есть свой движок для генерации статических сайтов.
2304.76 2310.40 "Анатолий Кулаков" И он понял, что прежде чем писать сам движок, нужно, чтобы этот движок хорошо мог работать с инструментарием вокруг.
2310.40 2316.40 "Анатолий Кулаков" В частности, нужна отличная поддержка Markdown, и хорошая поддержка какой-нибудь движка-темплейтов.
2316.40 2318.88 "Анатолий Кулаков" То есть он опять столкнулся с тем, что ему нужен движок-темплейтов.
2318.88 2326.72 "Анатолий Кулаков" Для Markdown, недолго думая, он написал свой паршивер, который называется MarkDig, тоже прекрасный инструмент, может быть мы про него в какой-нибудь теме поговорим.
2326.72 2333.88 "Анатолий Кулаков" А для движка-темплейтов решил написать свой собственный темплейт, потому что все существующие его не устраивали.
2333.88 2335.44 "Анатолий Кулаков" Итак, что же он все-таки хотел?
2335.44 2344.92 "Анатолий Кулаков" А хотел он от своего движка простой синтаксис, функциональные пайплайны, чтобы можно было передавать какую-нибудь одну функцию через пайпик в другую функцию.
2344.92 2347.04 "Анатолий Кулаков" В движках, в темплейтах это очень-очень удобно.
2347.04 2351.08 "Анатолий Кулаков" Работа с массивами, работа с кастомными функциями.
2351.08 2360.56 "Анатолий Кулаков" Он хотел очень легковесный рантайм, в котором бы не нужно было компилировать код в дотнет-сборке, и поэтому можно было бы сделать его быстрым.
2360.56 2367.40 "Анатолий Кулаков" Он хотел очень быстрый паршивер, без всяких там рига-экспов и с минимумом локаций в гарбеж-коллекторе.
2367.40 2379.64 "Анатолий Кулаков" Он хотел сделать полноценное АСТ, то есть некое дерево, которое представляло этот темплейт, которое можно будет транслировать, которое можно будет изменять, обратно загружать, сохранять, то есть работать как с полноценным майстер-деревом.
2379.64 2389.12 "Анатолий Кулаков" И, конечно же, легкую интеграцию с дотнет-рантаймом, чтобы можно было дотнет-библиотеки передавать, сериализовать, использовать, вытаскивать, управлять и так далее.
2389.12 2392.36 "Анатолий Кулаков" То есть, чтобы это был полноценный дотнет-темплейт-движок.
2392.36 2398.92 "Анатолий Кулаков" Рассматривались несколько кандидатов из уже готовых движков, например, Ликвид с помощью библиотеки dotliquid.
2398.92 2409.48 "Анатолий Кулаков" Но Александра остановило то, что это был мега тупой язык, то есть он был очень непродуман, у него было непредсказуемое поведение в некоторых случаях.
2409.48 2413.76 "Анатолий Кулаков" Ну, то есть, писал абсолютный дилетант, который не соображает ничего в языках программирования.
2413.76 2418.32 "Анатолий Кулаков" Дальше на очереди был Мустеш с помощью библиотеки Nustash.
2418.32 2424.00 "Анатолий Кулаков" Это его, прежде всего, смутило в этом языке, это отсутствие какой-то логики.
2424.00 2428.00 "Анатолий Кулаков" Ну, то есть, тоже язык не очень был продуманный и не очень предсказуемый.
2428.00 2432.84 "Анатолий Кулаков" Далее был Handlebars.js с помощью библиотеки Handlebars.net.
2432.84 2440.80 "Анатолий Кулаков" Это был эквивалент Mustash под .NET с какими-то оптимизациями, с какими-то улучшениями.
2440.80 2447.80 "Анатолий Кулаков" Но, все-таки, это оставался по-прежнему тупой язык и он опирался на наследие, которое ему досталось от Mustash.
2447.80 2451.36 "Анатолий Кулаков" Далее малоизвестный был темплейт, называется Kotl.
2451.36 2458.44 "Анатолий Кулаков" Он был довольно быстр, но при этом был слишком шумный и синтаксис Александру вообще не понравился.
2458.44 2460.04 "Анатолий Кулаков" Следующим рассматривался Hyuga.
2460.04 2463.24 "Анатолий Кулаков" Это темплейтинг, который часто применяют в Go.
2463.24 2471.44 "Анатолий Кулаков" Он нашел там очень много интересных подходов, он был крайне простой, но у него были некоторые проблемы.
2471.44 2480.84 "Анатолий Кулаков" Эти проблемы в основном были с неявным поведением, туда передавались неявные свойства и было очень много магии для Александра, он вот такого не хотел.
2480.84 2485.36 "Анатолий Кулаков" И последним, кого он нашел в языке Python, язык Jinja.
2485.36 2493.08 "Анатолий Кулаков" Этот язык наиболее привлек его, это язык, который наиболее соответствовал всем его критериям качества.
2493.08 2500.28 "Анатолий Кулаков" И этот язык явился как раз-таки самым главным прототипом, на основании которого Александр решил делать свой движок.
2500.28 2510.24 "Анатолий Кулаков" Итак, его движок должен был стать очень простым для изучения и очень знакомым, поэтому он его максимально придерживал также к Liquid'у.
2510.24 2512.64 "Анатолий Кулаков" Это один из самых распространенных темплейт движков.
2512.64 2520.80 "Анатолий Кулаков" Но он должен был быть намного умнее, он должен был стать намного чище и проще для изучения и для чтения.
2520.80 2530.68 "Анатолий Кулаков" Там должны быть конструкции, такие как if/else, там должны быть циклы, for/while, там должны быть функции, кастомные функции, встроенные функции.
2530.68 2539.76 "Анатолий Кулаков" И также должна быть хорошая поддержка со стороны IDE, и к своему новому движку он сразу же написал Visual Studio Code плагин.
2539.76 2540.76 "Анатолий Кулаков" Что же в итоге получилось?
2540.76 2544.16 "Анатолий Кулаков" В итоге получился как раз-таки движок Screamen.
2544.16 2547.64 "Анатолий Кулаков" Это полностью написано от руки Lexer и Parser.
2547.64 2558.16 "Анатолий Кулаков" Lexer написан по принципу ZeroGC, то есть для постройки лексического дерева вам не нужно будет вообще выделять память.
2558.16 2563.16 "Анатолий Кулаков" Parser имеет специальный мод совместимости с Liquid'ом.
2563.16 2570.48 "Анатолий Кулаков" И также он, как и хотел, реализовал AST-дерево, полностью полноценное и хорошее.
2570.48 2581.52 "Анатолий Кулаков" Вместе с поддержкой Liquid'а это дало интересную фичу, что можно было бы загрузить темплейт в терминах Liquid'а, каким-то образом это AST-дерево изменить и сохранить его обратно на диск.
2581.52 2592.64 "Анатолий Кулаков" То есть это сделало элементарную, например, миграцию огромного проекта, который уже был написан на Liquid'е, просто-напросто загрузив в AST-дерево Screamen'а и сохранив эти темплейты обратно на диск.
2592.64 2595.04 "Анатолий Кулаков" И вот вся миграция у вас закончена.
2595.04 2605.88 "Анатолий Кулаков" И как утверждает автор, Screamen это единственный темплейт-движок, который позволяет загрузить темплейт в память, построить по нему AST и сохранить обратно на диск.
2605.88 2610.92 "Анатолий Кулаков" Я не проверял, но действительно с такой фишкой никогда раньше не сталкивался для темплейт-движков.
2610.92 2619.36 "Анатолий Кулаков" Там более 100 встроенных функций, которые автор благоразумно подготовил для всех нужд на каждый день.
2619.36 2623.64 "Анатолий Кулаков" Естественно могут передаваться до .NET объекты и всячески с ними там можно управлять.
2623.64 2629.88 "Анатолий Кулаков" И Александр потратил намного больше времени на документацию, чем он делал это на своих предыдущих проектах.
2629.88 2632.44 "Анатолий Кулаков" То есть документация там довольно-таки хорошая.
2632.44 2634.00 "Анатолий Кулаков" Итак, к чему же это все привело?
2634.00 2644.52 "Анатолий Кулаков" А привело это к тому, что парсинг у нас занимает примерно в 3 раза меньше времени, чем у распространенного .Liquid'а и в 1000 раз быстрее, чем у Razer'а.
2644.52 2651.48 "Анатолий Кулаков" При этом памяти жрется в 4 раз меньше, чем у .Liquid'а и в 900 раз меньше, чем у Razer'а.
2651.48 2658.08 "Анатолий Кулаков" Рендеринг занимает в 5 раз меньше времени, чем у .Liquid'а и в 4 раза больше, чем у Razer'а.
2658.08 2665.08 "Анатолий Кулаков" И при этом память жрется при рендеринге в 11 раз меньше, чем у .Liquid'а и примерно столько же, сколько у Razer'а.
2665.08 2674.32 "Анатолий Кулаков" Тут действительно интересен момент, то есть этот парсер самый быстрый на рынке, самый красивый темплей-движок и все такое, памяти не жрет, делает все быстро.
2674.32 2682.24 "Анатолий Кулаков" Единственное, кому он проигрывает, это время рендеринга для Razer'а проигрывает он в 4 раза.
2682.24 2683.92 "Анатолий Кулаков" Смысл здесь довольно-таки простой.
2683.92 2693.60 "Анатолий Кулаков" Razer тратит в 1000 раз больше времени на компиляцию и во время компиляции делает C# код, который просто-напросто пишет вам строчки в output.
2693.60 2706.08 "Анатолий Кулаков" То есть можно это представить, что у Razer'а генерируется программа, внутри которой есть Console.WriteLine и этот Console.WriteLine полностью вам пишет весь движок в тот стрим, куда вы ему скажете.
2706.08 2712.96 "Анатолий Кулаков" Соответственно, этот процесс, в результате получается некий рендер, который выполняется максимально быстро.
2712.96 2715.40 "Анатолий Кулаков" То есть быстрее него невозможно ничего сделать.
2715.40 2717.56 "Анатолий Кулаков" Это просто записывание строк в некий вуфер.
2717.56 2726.00 "Анатолий Кулаков" Именно поэтому Razer выигрывает у всех на этапе рендеринга, но зато в 1000-кратном размере проигрывает на этапе паршинга.
2726.00 2741.76 "Анатолий Кулаков" То есть на данный момент это одна из самых быстрых, если, наверное, не самая быстрая библиотека для текст-темплейтинга, коджущая меньше всего памяти, отлично сейчас поддерживающая и получающая огромную популярность в Source-генераторах.
2741.76 2747.40 "Анатолий Кулаков" Если у вас станет такое требование для вашего проекта, обязательно посмотрите на библиотеку.
2747.40 2756.16 "Анатолий Кулаков" С учетом того, что у нее очень замечательный автор и у него очень много опыта в Open Source проектах, в оптимизациях, библиотека будет только лучше и лучше с каждым днем.
2756.16 2781.20 "Игорь Лабутин" Да, и тут хотелось бы добавить, что те самые 4 раза медленнее, чем Razer не должны быть действительно большими проблемами в Source-генераторах, потому что Razer все-таки оптимизирован больше на использовании в SPNet и других местах, где он действительно парсится один раз, а показывается у вас потенциально очень много раз, в то время как в Source-генераторе, скорее всего, вы распарситесь, генерируете, ну и все.
2781.20 2794.52 "Игорь Лабутин" То есть здесь скорость парсинга, она на самом деле довольно-таки сильно важна, а при изменении следующей генерации вы заново будете опять парсить исходный файл, поскольку Source-генераторы, насколько я помню, никакого стейта между системами не хранят.
2794.52 2799.52 "Анатолий Кулаков" Ну, с другой стороны, никто этого не мешает, если они воспользуются локальной файловой системой, допустим.
2799.52 2807.88 "Игорь Лабутин" Ну, да, но это усложняет, и скорее всего, первой версией вашего Source-генератора вы будете писать все-таки без таких оптимизаций, так скажем.
2807.88 2811.76 "Игорь Лабутин" Если она будет достаточно прилично работать, то зачем они тогда нужны?
2811.76 2815.04 "Игорь Лабутин" И вот как раз-таки Scribn может вам обеспечить эту достаточно
2815.04 2823.36 "Анатолий Кулаков" приличность. И действительно сейчас никто не задумывается, но если так разобраться, то Source-генераторы - это очень сильное замедление время компиляции.
2823.36 2834.80 "Анатолий Кулаков" И не только то время компиляции, когда вы нажали кнопочку Build в вашей Visual Studio, а то время компиляции, когда Rostlin по правде в бэкграунде за вас перестраивает аисты деревья в момент прямо печатания.
2834.80 2841.68 "Анатолий Кулаков" То есть, когда вы печатаете буковки, переводите скобочки, подсвечиваете телесенсы, все это время Rostlin перестраивает деревья.
2841.68 2844.12 "Анатолий Кулаков" И на все это время могут вызываться Source-генераторы.
2844.12 2855.96 "Анатолий Кулаков" Сейчас это, наверное, не проблема, когда в проекте один или два Source-генератора, но, скорее всего, со временем таких генераторов будет становиться больше и больше, и я не удивлюсь, если у нас в ближайшем будущем будут сотни Source-генераторов на проект.
2855.96 2859.96 "Анатолий Кулаков" И там скорость их исполнения уже должна будет выходить просто на новый уровень.
2859.96 2867.32 None Ну, возможно, к тому моменту появятся еще какие-то дополнительные оптимизации, в том числе, возможно, и скрипынь и рендеринг тайм подрастет.
2867.32 2868.32 "Анатолий Кулаков" Безусловно.
2868.32 2871.32 "Анатолий Кулаков" А мы будем за этим за всем следить и удержать вас в курсе.
2871.32 2872.32 "Игорь Лабутин" Да.
2872.32 2873.32 "Игорь Лабутин" Давай пойдем дальше.
2873.32 2878.88 "Игорь Лабутин" И дальше у нас статья про Find, Fix and Avoid Memory Leaks в C#.
2878.88 2880.92 "Игорь Лабутин" 8 советов, 8 лучших практик.
2880.92 2899.76 "Игорь Лабутин" И она довольно-таки, наверное, очевидна для тех, кто постоянно занимается поиском и работой с утечками памяти, но наверняка не все наши слушатели этим занимаются каждый день, и напомнить, что это такое, и зачем это делать, и как это вообще можно подходить к такому проблеме, будет не лишним.
2899.76 2902.64 "Игорь Лабутин" И начнем мы с того, что бывают два типа утечек.
2902.64 2907.56 "Игорь Лабутин" Во-первых, это Managed память может утекать, во-вторых, Unmanaged.
2907.56 2918.52 "Игорь Лабутин" Сегодня мы будем говорить только про Managed память, потому что утечки Unmanaged, они в общем случае довольно-таки тяжело ловятся, есть способы, но они требуют знания Windows API и соответствующих тулов вокруг.
2918.52 2925.20 "Игорь Лабутин" То есть это довольно-таки advanced сценарии и немножко даже не по теме может быть дотнета.
2925.20 2933.44 "Игорь Лабутин" Если у вас вдруг есть Unmanaged утечки памяти, гуглите всякие Windows Performance Analyzer и сопутствующие тулы.
2933.44 2937.88 "Игорь Лабутин" А в Managed мире, казалось бы, что такое утечка памяти?
2937.88 2940.48 "Игорь Лабутин" У нас же есть Garbage Collector, Garbage Collector все соберет.
2940.48 2949.68 "Игорь Лабутин" Ну так вот, традиционно утечками памяти в Managed мире называется ситуация, когда у нас есть объекты, которые почему-то еще живы, хотя давно должны были помереть.
2949.68 2958.60 "Игорь Лабутин" То есть на них есть откуда-то ссылки, и поэтому Garbage Collector совершенно справедливо их не собирает и оставляет жить, хотя реальной программе по логике они уже давным-давно
2958.60 2961.20 None не нужны. Как же их найти?
2961.20 2964.40 "Игорь Лабутин" Как вообще для начала понять, что у вас есть проблема с утечкой памяти?
2964.40 2970.36 "Игорь Лабутин" Как известно, до того, как что-то фиксить, нужно убедиться, что эта проблема есть, потому что как же вы будете проверять, что вы что-то пофиксили?
2970.36 2975.04 "Игорь Лабутин" И первый очевидный тул - это диагностик с тул Windows Visual Studio.
2975.04 2984.52 "Игорь Лабутин" Это такое окошечко, оно обычно справа возникает, когда вы запускаете ваше приложение под отладкой, там какие-то графики рисуются, какие-то точечки желтенькие ставятся, флажочки.
2984.52 2990.56 "Игорь Лабутин" И в среднем многие на это смотрят и думают, ну, если там что-то двигается, значит приложение живет.
2990.56 3000.88 "Игорь Лабутин" На самом деле там показываются в динамике некоторые показатели по памяти, то есть насколько у вас растет память, сколько у вас вообще или падает использование памяти.
3000.88 3007.48 "Игорь Лабутин" Плюс желтые флажки, которые там появляются, это те моменты, когда у вас срывается garbage collector в том или ином поколении.
3007.48 3024.04 "Игорь Лабутин" Соответственно, вы можете видеть, что если у вас память постоянно растет или если этих желтых флажков становится неприлично много, то есть они постоянно появляются, значит, что у вас либо утекает память, то есть копятся какие-то объекты, либо у вас очень часто работает garbage collector.
3024.04 3025.40 "Игорь Лабутин" И это тоже может быть плохо.
3025.40 3031.00 "Игорь Лабутин" Надо понимать, что если память растет, то это еще не обязательно memory leak, возможно, это логика вашей программы.
3031.00 3037.36 None Либо это может быть, что garbage collector еще не успевает срабатывать или считает, что это не нужно.
3037.36 3042.60 "Игорь Лабутин" Например, если у вас огромное количество памяти, то garbage collector начнет срабатывать далеко не сразу.
3042.60 3049.12 "Игорь Лабутин" Так что если вы видите, что у вас растет память, но при этом желтых флажков не появляется и garbage collector не работает, это еще не повод беспокоиться.
3049.12 3053.92 "Игорь Лабутин" Но если они там есть, их много, а память все равно растет, у вас точно что-то не то с памятью.
3053.92 3064.56 "Игорь Лабутин" Теперь второй способ посмотреть на это дело, если вы не отлаживаете Visual Studio, это просто взять стандартный Task Manager, Process Explorer от System Terminals или даже PerfMonitor, посмотреть на performance counters.
3064.56 3067.76 "Игорь Лабутин" В Task Manager и Process Explorer делается все просто.
3067.76 3070.48 "Игорь Лабутин" Вы просто смотрите на колоночку использования памяти.
3070.48 3077.24 "Игорь Лабутин" Я очень рекомендую смотреть на колоночку, по-моему, она называется Private Bytes, потому что она наиболее показательна.
3077.24 3081.76 "Игорь Лабутин" Если же это PerfMonitor, то добавляйте соответствующий performance counter и смотрите на график.
3081.76 3085.80 "Игорь Лабутин" Если чиселки растут, то, скорее всего, у вас как-то
3085.80 3091.68 None увеличивается потребление памяти, но, опять же, убедитесь, что у вас срабатывал garbage collector.
3091.68 3095.60 "Игорь Лабутин" И третий идеальный способ - это, конечно, в Emry Profiler.
3095.60 3098.00 "Игорь Лабутин" Большинство профайлеров работают более-менее одинаково.
3098.00 3108.60 "Игорь Лабутин" Вы либо оттачиваетесь к процессу уже работающему, либо просто запускаете процесс прямо из профайлера, добиваетесь некоторого стабильного состояния вашего приложения, создаете snapshot.
3108.60 3116.84 "Игорь Лабутин" В этот момент профайлер записывает состояние, в чём у вас находятся в памяти, какие объекты, в каком количестве, как они лежат, как они друг с другом связаны.
3116.84 3126.08 "Игорь Лабутин" После этого вы делаете какие-то операции, которые, предположительно, ведут к утечкам памяти, возвращаете ваше приложение в такое же стабильное состояние и создаете новый snapshot.
3126.08 3130.04 "Игорь Лабутин" Как правило, между этими snapshot'ами не должно быть сильно большой разницы.
3130.04 3161.76 "Игорь Лабутин" Она, естественно, может быть, там может что-то закэшироваться, какие-то объекты добавятся в какие-нибудь пулы, где-то по логике программы что-то должно сохраниться и остаться в памяти, но в целом вы должны посмотреть на разницу этих двух snapshot'ов, все профайлеры умеют это показывать, посмотреть на те объекты, которые были созданы и до сих пор живы, или созданы и безотносительно того, были они собраны или нет, и подумать вообще, те объекты, которые остались живы ко второму snapshot'у, они должны были остаться живы или не должны.
3161.76 3162.76 None Это один вариант.
3162.76 3172.48 "Игорь Лабутин" И второй вариант, в принципе, какие объекты создавались, в каком количестве, не создавалось ли их слишком много для того, чтобы той логике, которую вы предполагаете, у вас должна работать.
3172.48 3178.36 "Игорь Лабутин" Это поможет вам понять уже максимально точно, какие классы утекают, почему они остаются живыми.
3178.36 3187.56 "Игорь Лабутин" Все профайлеры смогут вам показать, почему тот или иной объект до сих пор не собран garbage-коллектором, какие ссылки на него ведут и откуда они вообще происходят.
3187.56 3192.44 "Игорь Лабутин" Дальше нужно будет только уже разбираться в логике программы и понимать, почему у вас те или иные объекты
3192.44 3197.20 None так или иначе остаются в памяти. Есть еще одна техника.
3197.20 3201.96 "Игорь Лабутин" Я ей пользовался довольно редко, но в пару раз она довольно здорово помогала.
3201.96 3214.52 "Игорь Лабутин" Если у вас есть доступ к Visual Studio и вы отслашиваете ваше приложение, вы можете воспроизвести проблему, предположительную проблему с путичкой памяти в отладке, то вы можете использовать такую штуку, как make object ID.
3214.52 3224.24 "Игорь Лабутин" То есть, если вы там, допустим, с помощью профайлера определили, что какие-то объекты вроде как создаются, но почему-то не удаляются, вы можете делать следующее.
3224.24 3228.00 "Игорь Лабутин" Вы ставите breakpoint на тот момент, когда такой объект создается.
3228.00 3231.76 "Игорь Лабутин" После того, как он создался, на той переменной, в которой
3231.76 3245.08 None лежит ссылка на этот объект, вы можете сказать make object ID и после этого, во всех случаях, когда в watch окошке или в imedit окошке вы будете смотреть на этот объект, у него будет написано его индивидуальный номер.
3245.08 3249.20 "Игорь Лабутин" Он обычно выглядит как доллар один, доллар два, доллар три и так далее.
3249.20 3253.48 "Игорь Лабутин" Вот таким образом вы сможете отличать разные объекты одного и того же типа друг от друга.
3253.48 3268.16 "Игорь Лабутин" И тогда вы можете сделать следующее, пометить такой объект, сказав make object ID, пройти сценарий, в результате которого этот объект должен будет уничтожиться, зафорсить garbage collect, который делается стандартным способом.
3268.16 3274.24 "Игорь Лабутин" Можно это сделать внутри приложения, если вы можете легко менять код, либо это можно сделать из imedit окошка студии.
3274.24 3280.52 "Игорь Лабутин" И после этого попробуйте посмотреть на значение вот этого доллара один в imedit окошке.
3280.52 3284.12 "Игорь Лабутин" И если объект живой, то там будет его, соответственно, ссылка и контент.
3284.12 3288.56 "Игорь Лабутин" Если он собрался, значит там будет, грубо говоря, null.
3288.56 3293.56 "Игорь Лабутин" То есть таким образом вы можете, во-первых, отличать объекты друг от друга, во-вторых, проверить, живы они или нет.
3293.56 3298.80 "Игорь Лабутин" Отдельно нужно сказать, что такое зафорсить gccollect.
3298.80 3302.24 "Игорь Лабутин" Недостаточно вызвать просто gc.collect один раз.
3302.24 3308.72 "Игорь Лабутин" Правильная последовательность будет заключаться в том, что вы должны сказать gc.collect, потом gc_wait_for_pending_finalizers
3308.72 3315.68 None и только потом еще раз gc_collect. Эта последовательность до некоторой степени гарантирует почти полную сборку мусора.
3315.68 3329.96 "Анатолий Кулаков" Самый лучший способ того, чтобы в вашем приложении не было все-таки никаких утечек памяти, это знать базовые проблемы, которые обязательно приведут вас к утечкам памяти и следить за такими ситуациями наиболее строго.
3329.96 3333.64 "Анатолий Кулаков" Давайте разберем вообще типичные вещи, где утекает у нас память.
3333.64 3339.04 "Анатолий Кулаков" Во-первых, это всем известно, наверное, людям, которые ищут утечки памяти, это события.
3339.04 3344.20 "Анатолий Кулаков" Ивенты в дотнете печально известны тем, что они часто могут приводить к утечкам памяти.
3344.20 3355.64 "Анатолий Кулаков" И в принципе, когда только появились информы, когда только появилось вот это массовое подписывание на события, это был частый и, возможно, самый единственный случай вот таких вот утечек.
3355.64 3357.76 "Анатолий Кулаков" Поэтому будьте внимательны, будьте осторожны.
3357.76 3361.32 "Игорь Лабутин" Если вы на что-то подписываетесь, не забывайте от этого отписываться.
3361.32 3377.56 "Игорь Лабутин" Если вы видите какой-то объект, который висит, скажем так, со ссылками из какого-то странного места, из ивента, то это значит, что вы, скорее всего, забыли у этого объекта какой-нибудь хендлер этого ивента отписать.
3377.56 3387.40 "Игорь Лабутин" И, соответственно, объект этот захватился как переменная того, как таргет того делегата, который нужно выполнить.
3387.40 3400.00 "Анатолий Кулаков" И обычно это захватывается какая-нибудь или форма, или полностью там все формы, или все аппликейшены, и у вас там куча форм, которые открывались или закрывались несколько раз, они все висят у вас в памяти, и garbage collector не может их собрать.
3400.00 3404.76 "Анатолий Кулаков" Такие специфичные деревья висячих форм вы увидите в профайлере.
3404.76 3406.56 "Анатолий Кулаков" Далее это статические переменные.
3406.56 3412.24 "Анатолий Кулаков" Действительно, если вы завели статическую переменную, записали какие-то данные, то garbage collector никогда ее не соберет.
3412.24 3414.80 "Анатолий Кулаков" Именно это вы по сути его и попросили делать.
3414.80 3420.44 "Анатолий Кулаков" Поэтому особое внимание обращайте на статические переменные, а лучше полностью избегайте их.
3420.44 3427.32 "Анатолий Кулаков" Еще один очень распространенный мешок для сбора багов и утечек памяти - это кэширование.
3427.32 3438.64 "Анатолий Кулаков" Про кэширование можно говорить с разных сторон, но в нашей сегодняшней теме прежде всего кэширование это источник того, что у нас будет кушаться много-много памяти и может быть даже никогда не очищаться.
3438.64 3442.52 "Анатолий Кулаков" И в результате вы вполне можете увидеть out of memory в своем приложении.
3442.52 3448.84 "Анатолий Кулаков" Здесь, наверное, можно порекомендовать уже стандартный класс, который есть в библиотеке .NET.
3448.84 3450.80 "Анатолий Кулаков" Класс называется Memory Cache.
3450.80 3465.12 "Анатолий Кулаков" Memory Cache довольно-таки умный кэш, который предоставляет интерфейс наподобие iDictionary, но при этом умеет принимать некие полисы, которые позволяют вам следить за тем, когда очищается ваш кэш.
3465.12 3475.36 "Анатолий Кулаков" То есть можно настроить очищение по времени, очистление по количеству объектов, по занимаемой памяти, можно сделать слайдинг в Windows и прочие-прочие интересные вещи.
3475.36 3484.00 "Анатолий Кулаков" А также он умеет отслеживать, насколько операционная система нуждается сейчас в памяти и независимо от полисей допустим чистить тоже ваш кэш.
3484.00 3499.68 "Анатолий Кулаков" То есть у него очень много разных интересных стратегий, хорошая оптимизация по скорости и конкарнси, как самый примитивный, не беспроблемный, конечно, класс, но, наверное, в любом случае лучше, чем вы будете использовать обычный dictionary и как-то пытаться его чистить.
3499.68 3513.64 "Игорь Лабутин" И хороший бонус этого класса в том, что, по-моему, вот эту самую стратегию вы обязаны указывать при добавлении записи в кэш, и таким образом вы просто не сможете обойти вопрос подумать, какая же она должна у вас быть.
3513.64 3517.72 "Анатолий Кулаков" Еще интересный бонус, что этот класс создает сразу performance counter.
3517.72 3529.48 "Анатолий Кулаков" То есть вы прямо все свои memory кэши, которые у вас есть в приложении, можете наблюдать через performance counter, смотреть кэш-миссы, кэш-хиты, насколько он там вырос, когда он чистится.
3529.48 3532.32 "Анатолий Кулаков" Очень интересные познавательные чтивы, хочу вам сказать.
3532.32 3535.00 "Анатолий Кулаков" Далее это привязки к .dapp.pf.
3535.00 3544.36 "Анатолий Кулаков" Есть негласное правило, что объекты .dapp.pf надо бандить обязательно к dependency object или к inectify property change.
3544.36 3555.32 "Анатолий Кулаков" Если этого не сделать, то .dapp.pf создает сильную ссылку на ваши данные, то есть на view model, и привязывает ее к переменной, и это может привести к утечкам памяти.
3555.32 3569.72 "Игорь Лабутин" Да, потому что внутри .dapp.pf все это будет хранить все равно в статических массивах, и вы все равно это увидите как будто вы куда-то что-то записали в статик переменную, причем где-то внутри этот framework, и будете думать и догадать, как же я туда смог добраться.
3569.72 3588.92 "Игорь Лабутин" На самом деле, очень много конструкций .net framework, и .net core, и вообще .net в целом, всех библиотек на нем используют некоторые внутренне статические штуки для кэшей, и поэтому не удивляйтесь, если вы будете видеть в качестве gcroot довольно много статических переменных или даже массивов.
3588.92 3600.04 "Игорь Лабутин" Это нормально, так оно и внутри работает, просто ищите ваш код дальше и понимайте, где этот код вы могли забыть, отписаться или на что-то там неправильно запайдить.
3600.04 3610.40 "Анатолий Кулаков" Одним, наверное, из самых неявных мест, где может у вас случиться утечка памяти, это захват локальных членов.
3610.40 3636.08 "Анатолий Кулаков" То есть, если вы ставите у себя в обработчике или может быть в каком-то коде, просто пишите обычную лямбдочку, но при этом эта лямбдочка как-то работает с вашими локальными филдами или может быть ссылается на какие-то локальные классы, все эти локальные классы, локальные филды упаковываются в специальный классик, передаются это в лямбдочки и лямбдочка их замыкает и будет держать их до тех пор, пока сама будет жива.
3636.08 3651.68 "Анатолий Кулаков" И это тоже одна из неочевидных вещей, когда вы пишете легкий код, который в лямбдах обращается к каким-то переменным, которые просто витают где-то снаружи.
3651.68 3660.28 "Анатолий Кулаков" Для вас это все легко, предсказуемо и понятно, но для компилятора и для рантайма это большая работа, которая в том числе может вылиться вот в такие утечки.
3660.28 3675.92 "Игорь Лабутин" Тут еще есть такой момент, что может даже вылиться не только в утечки, а может быть вы даже все в конце концов корректно, правильно допустим отпишите и в нужном месте эту лямбду удалите из делегата и все будет работать.
3675.92 3700.16 "Игорь Лабутин" Но есть еще такой эффект, если вы вдруг случайно, допустим вы подписываетесь на какое-то событие и указываете лямбду и внезапно внутри лямбды указываете в качестве одного из используемых полей, переменных, используете просто this по большому счету или ссылку на какой-то класс, из которого вам нужно какое-то одно полечко, при этом сам класс содержит огромное количество данных.
3700.16 3706.88 "Игорь Лабутин" Надо понимать, что если за-кепчуриться вот в весь такой класс, то все это огромное количество данных будет жить все то время, пока жива лямбда.
3706.88 3717.64 "Игорь Лабутин" Поэтому если вы хотите использовать какие-то значения из очень большого измеренного класса, скопировать их в локальные переменные и за-кепчурить эти локальные переменные.
3717.64 3721.06 "Игорь Лабутин" Будет несколько проще, чем кепчурить один большой огромный класс.
3721.06 3725.54 "Анатолий Кулаков" Еще встречается такая вещь, как потоки, которые никогда не завершаются.
3725.54 3738.28 "Анатолий Кулаков" Естественно, если поток у вас все время работает и никогда не завершается, то все переменные, которые лежат у него на стеке, все что он захватил, это все тоже остается в памяти и отсюда получаются утечки памяти.
3738.28 3743.08 "Анатолий Кулаков" Интересно, что это может быть не настолько явно, как вам кажется.
3743.08 3746.64 "Анатолий Кулаков" Например, очень часто люди используют таймеры.
3746.64 3755.04 "Анатолий Кулаков" А таймеры, по сути, и делают именно такую штуку, что они создают некий поток, который может быть никогда и не завершится.
3755.04 3760.08 "Игорь Лабутин" Ну, это может быть не очень известно, но таймеры в Дотнете работают на основе потока.
3760.08 3768.32 "Игорь Лабутин" То есть, есть поток, который просто спит и ждет какое-то количество ивентов в зависимости от того набора таймеров, которые вы задали.
3768.32 3774.40 "Игорь Лабутин" Если я правильно помню, один поток обрабатывает до 63 таймеров в общей куче.
3774.40 3783.08 "Игорь Лабутин" И если вы больше таймеров создаете, новые потоки рождаются и все эти потоки будут жить до тех пор, пока вы не задиспозите аккуратно все таймеры.
3783.08 3784.72 "Игорь Лабутин" Так что, внимательнее.
3784.72 3790.20 "Анатолий Кулаков" Вообще, это вот наиболее базовые, наиболее самые элементарные вещи, за которыми вам стоит следить.
3790.20 3801.20 "Анатолий Кулаков" Но если вы возьмете любой современный профайлер, то они уже давно научились обнаруживать намного более тайные, более скрытые какие-то шаблоны, которые есть в вашем коде.
3801.20 3815.68 "Анатолий Кулаков" И много очень профайлеров включают в себя специальные анализаторы, которые анализируют ваш код, анализируют его поведение в ран тайме и выцепляют вот эти стандартные паттерны и могут вам уже дать рекомендации о том, каким образом улучшить ваш код.
3815.68 3820.52 "Анатолий Кулаков" Если там есть какие-то memory leak, то как их убрать, на что поменять.
3820.52 3827.32 "Анатолий Кулаков" И вот такие вот советы они уже могут давать вам прямо в момент профилировки, что тоже очень удобно.
3827.32 3828.32 "Игорь Лабутин" Да.
3828.32 3831.36 "Игорь Лабутин" Дальше есть еще такая штука, как dispose pattern.
3831.36 3844.52 "Игорь Лабутин" Если у вас есть что-то disposable, то очень неплохо бы писать это внутри using влока, чтобы, ну или использовать using declaration в новом C#, чтобы все стало хорошо и все ресурсы очистились.
3844.52 3860.16 "Игорь Лабутин" Поскольку вы не знаете, что у вас происходит, обычно вы не знаете, что происходит внутри disposable класса, если он особенно пришел из какой-нибудь сторонней библиотеки или из самого .NET фреймворка, предполагайте худший, предполагайте, что внутри есть какой-нибудь unmanaged ресурс, который утечет, если что.
3860.16 3869.80 "Игорь Лабутин" Это могут быть открытые файл-хендлы, сокеты, память общая, та же самая unmanaged память, то есть лучше, если есть что-то disposable, стараться его dispose.
3869.80 3884.60 "Игорь Лабутин" Если только в документации явно не написано, что можно не dispose, потому что, например, базовая реализация требует реализации disposable и вы точно знаете, что на самом деле она пустая.
3884.60 3891.92 "Игорь Лабутин" Пример это, например, memory stream в .NET, memory stream в dispose не делает ничего, если я правильно помню.
3891.92 3902.96 "Игорь Лабутин" Но на самом деле гарантий никаких нет и в новых версиях .NET memory stream может поменяться и, например, начать использовать какой-нибудь pooling уферов внутри и тогда dispose все-таки не будет нужен.
3902.96 3906.84 "Игорь Лабутин" Так что лучше, если класс является disposable, задиспойте его, когда он вам не нужен.
3906.84 3907.84 "Игорь Лабутин" Будет легче.
3907.84 3921.12 "Игорь Лабутин" А предпоследний момент это, если у вас есть подозрение, что у вас приложение достаточно большое и может утекать, или вы уже видите, что вроде как оно утекает, добавьте на самом деле некоторую телеметрию прямо в ваше
3921.12 3941.52 None приложение. Пусть оно периодически пишет в какой-нибудь логе или в метрике информацию о том, сколько памяти оно скушало, возможно, какие-то ключевые данные, как Толя сказал, на тему размеров кэшей, длины чередей и так далее, чтобы иметь свое внутреннее представление о том, как работает именно ваша бизнес логика с точки зрения расхода ресурсов.
3941.52 3947.36 "Игорь Лабутин" Дальше вы сможете, глядя на эти цифры, понимать, у вас приложение живет нормальной жизнью или все-таки где-то что-то пошло не так.
3947.36 3951.48 "Игорь Лабутин" Какие-то очереди начинают увеличиваться, или где-то кэши растут, или еще что-то.
3951.48 3953.48 "Игорь Лабутин" Или просто растет потребление памяти.
3953.48 3958.76 "Игорь Лабутин" Но все то, что мы говорили, это все-таки относится уже к абсолютно работающему приложению.
3958.76 3965.92 "Игорь Лабутин" Было бы, конечно, идеально находить утечки памяти еще во время написания кода, но здесь могут помочь анализаторы те самые.
3965.92 3971.36 "Игорь Лабутин" Если же в момент написания кода мы это как-то пропустили, самое время посмотреть на это с точки зрения тестов.
3971.36 3995.88 "Игорь Лабутин" И некоторые профайлеры, точнее, некоторые компании, которые делают профайлеры, поставляют еще дополнительно набор библиотек для юнит-тестирования на утечки памяти, где есть специальный набор ассертов, который позволяет проверить, что память там не сильно увеличилась, а не появилось новых объектов или новых объектов заданного типа не осталось живых, и так далее.
3995.88 4007.96 "Игорь Лабутин" Это может помочь вам для каких-то критических сценариев, какие-то критические куски бизнес-логики, проверить с точки зрения утечек памяти и убедиться, что с ними все хорошо и логика работает действительно как надо.
4007.96 4009.52 "Игорь Лабутин" На этом статья заканчивается.
4009.52 4028.04 "Игорь Лабутин" И в принципе это действительно хороший базовый обзор того, что можно делать в обычной жизни с вашим приложением, если вы подозреваете утечки памяти или если вы видите, что оно действительно утекает в продакшене, но и можете при этом повторить в вашем девелоперском окружении.
4028.04 4042.68 "Игорь Лабутин" К сожалению, частенько бывает так, что в девелоперском окружении повторить либо сложно, потому что данных нету нужных и нагрузки нужной нету, либо даже если есть данные и нагрузка, все равно не повторяется и приходится использовать продакшен и отлаживаться напрямую на продакшене.
4042.68 4055.32 "Игорь Лабутин" И тут не так уже просто взять полноценный профайлер большой и подключиться к работающему приложению в продакшене, потому что оно будет замедлять и вообще кто вам позволит ставить профайлер на продакшен-систему.
4055.32 4057.36 "Игорь Лабутин" Здесь может помочь несколько вариантов.
4057.36 4070.28 "Игорь Лабутин" Во-первых, некоторые профайлеры имеют, так скажем, легковесный вариант чисто собрать данные профайла в продакшене или где угодно просто в отдельный файлик, анализировать его уже у себя на рабочей машинке.
4070.28 4072.24 "Игорь Лабутин" Это рабочая версия, можно пользоваться.
4072.24 4075.24 "Игорь Лабутин" Либо берите совсем уж хардкор, это Perf.io.
4075.24 4087.36 "Игорь Лабутин" Это тоже в некотором смысле профайлер для менеджмент языков, то есть вы берете, создаете снапшоты, так же как я и говорил, и сравниваете снапшоты, смотрите куда как память утекла, какие объекты создались.
4087.36 4104.16 "Игорь Лабутин" А UI там, конечно, ужасен и то, что упоминал Толя на тему того, что профайлеры уже давно научились там определять классические паттерны утечек, тут ничего такого нет, вы просто увидите на борт, так сказать, сырых ссылок из garbage collector.
4104.16 4108.88 "Игорь Лабутин" Но если у вас что-то течет в продакшене, это единственный способ понять почему.
4108.88 4117.88 "Игорь Лабутин" Это нормальный способ, для меня на самом деле довольно таки настольный tool, Perf.io я пользуюсь регулярно, в том числе для поиска утечек и прекрасно работает.
4117.88 4119.36 "Игорь Лабутин" Так что можно пользоваться.
4119.36 4134.96 "Анатолий Кулаков" Ну что ж, пока .NEXT конференция питерская весенняя готовится и вовсю собирает спикеров, в это время .NEXT конференция московская, которая недавно прошла, выложила в открытый доступ все свои видосики.
4134.96 4152.84 "Анатолий Кулаков" Я напоминаю, что это одна из самых хардкорных и самых интересных конференций по .NET, которая существует и все ее видосики довольно таки отличного качества, как по контенту, так и по видео стриму, и по спикерам, и по подготовке, и по всем-по-всем.
4152.84 4160.80 "Анатолий Кулаков" Поэтому они обычно набирают очень хорошее количество просмотров и мы тоже крайне рекомендуем к ним присоединиться.
4160.80 4174.12 "Анатолий Кулаков" И с нашей стороны хотелось бы наверное рассказать немножко про эти видосики и например сделать топ 10 лучших спикеров, лучших докладов в прошедшей конференции .NEXT Москву.
4174.12 4181.08 "Анатолий Кулаков" Здесь нужно опять же оговориться, что у конференции .NEXT существует две линейки, две мерилки.
4181.08 4189.72 "Анатолий Кулаков" Одна из них называется средняя, это средний балл, мы по анкетам обратной связи зрители выставили докладу.
4189.72 4195.88 "Анатолий Кулаков" И вторая это средний балл с учетом еще посещаемости, так называемый софткворум.
4195.88 4199.92 "Анатолий Кулаков" То есть этот средний балл еще коррелирует на то, сколько человек посетило.
4199.92 4209.40 "Анатолий Кулаков" Если вы посмотрите статью на гитхабе, которая должна скоро выйти, с подобным рейтингом, то вы там увидите совершенно другие места, не такие, как мы вам будем рассказывать.
4209.40 4211.16 "Анатолий Кулаков" Это будут места по софткворуму.
4211.16 4215.00 "Анатолий Кулаков" Мы же вам расскажем места по среднему, по средней оценке.
4215.00 4218.84 "Анатолий Кулаков" Это не зависит от того, сколько человек посещали доклад или вообще не посещали.
4218.84 4223.72 "Анатолий Кулаков" Будет зависеть только от того, на сколько зрители оценили тот или иной доклад.
4223.72 4225.44 "Анатолий Кулаков" Ну что ж, начнем с 10 места.
4225.44 4233.00 "Анатолий Кулаков" А на 10 месте у нас расположился Бартош Адамчевский с докладом про Data-Oriented Design для бизнес-приложений.
4233.00 4242.80 "Анатолий Кулаков" Data-Oriented Design это довольно распространенная практика в играх, потому что там люди очень загоняются перформансом и начинают загоняться перформансом не так, как мы.
4242.80 4250.32 "Анатолий Кулаков" Якобы не нужно сначала преждевременную оптимизацию делать, а потом врубайте профайлеры и оптимизируйте, если у вас вдруг какие-то просадки.
4250.32 4256.32 "Анатолий Кулаков" Там люди просто проектируют приложения, проектируют архитектуру, прежде всего помня о перформансе.
4256.32 4259.24 "Анатолий Кулаков" И именно об этом подходе рассказал Бартош.
4259.24 4271.44 "Анатолий Кулаков" Очень интересный доклад, очень оригинальный подход, который в принципе уже давно используется на практике в параллельной индустрии и может быть для некоторых ваших приложений, если им важна производительность, тоже будет полезен.
4271.44 4278.20 "Игорь Лабутин" В 9 месте доклад от Мэтца Торгессона, ведущего дизайнера языка C#.
4278.20 4296.84 "Игорь Лабутин" Он рассказал какие-то кусочки того, что появилось в C# 9.0, но мы много-много-много раз это все обсасывали и обсуждали, поэтому вряд ли вы там увидите что-то принципиально новое, хотя посмотреть на то, как это видит сам главный архитектор языка, довольно забавно и познавательно.
4296.84 4303.60 "Игорь Лабутин" Плюс он поделился, так скажем, некоторыми планами на то, как это все будет развиваться, куда может двигаться C# дальше.
4303.60 4306.96 "Игорь Лабутин" Так что, если вам интересно будущее C#, обязательно смотрите.
4306.96 4312.12 "Игорь Лабутин" Мэтц Торгессон - тот человек, который сейчас определяет то, куда будет развиваться C#.
4312.12 4314.16 "Анатолий Кулаков" На 8 месте Рафаэль Риалди.
4314.16 4318.08 "Анатолий Кулаков" Рафаэль рассказал про новинки Дотнет 5.
4318.08 4330.76 "Анатолий Кулаков" Он рассказал про те вещи, которые может быть не всегда появляются у вас на глазах, может быть вы о них не знали, о каких-то нововведениях, какие-то интересные инструменты и все, что вокруг с этим связано.
4330.76 4339.68 "Анатолий Кулаков" С нашим новым рантаймом, который как раз-таки объединил большой Дотнет фриворк и Дотнет корр, и Мона, и Косомарин, и все на свете.
4339.68 4342.16 "Анатолий Кулаков" И что из этого концепционального получилось.
4342.16 4344.88 "Анатолий Кулаков" Очень тоже интересный, познавательный доклад.
4344.88 4346.60 "Игорь Лабутин" 7 место Андрей Дятлов.
4346.60 4347.60 "Игорь Лабутин" Source генераторы.
4347.60 4357.36 "Игорь Лабутин" Прошлый Дотнекст, точнее уже позапрошлый Дотнекст, знаменовался тем, что Андрей сделал подробнейший доклад про Analog Reference Types.
4357.36 4369.56 "Игорь Лабутин" И сейчас не менее подробнейший доклад про то, что такое Source генераторы, как оно работает, как оно вообще в реальной жизни сейчас живет, проблемы, решения, трудности, тонкости.
4369.56 4377.88 "Игорь Лабутин" Так что, если вы задумываетесь о том, что вам нужно использовать Source генераторы или вы хотите это попробовать, обязательно посмотрите, уйма полезной информации на эту тему.
4377.88 4386.72 "Анатолий Кулаков" Андрей выбрал беспроизвешную стратегию, он берет самые горячие фичи релиза, что Nullable Type, что Source генераторы и начинает про них рассказывать.
4386.72 4398.72 "Анатолий Кулаков" Тут нужно еще уточнить, что Андрей это разработчик в компании JetBrains, он работает непосредственно над анализами и над поддержкой в райдере ReSharper и Nullable Type, и Source генераторов.
4398.72 4404.32 "Анатолий Кулаков" Поэтому он очень много про них знает, как они устроены внутри, как развивала их команда Microsoft.
4404.32 4411.12 "Анатолий Кулаков" И вот про очень интересные такие вещи, из-за чего доклад смотрится в 10 раз интереснее, чем обычное чтение документации.
4411.12 4414.56 "Анатолий Кулаков" На шестом месте расположился новичок, Риваль Абдрахманов.
4414.56 4427.12 "Анатолий Кулаков" Несмотря на то, что он первый раз выступал на такой большой конференции, доклад у него получился просто шикарный и занял очень много положительных отзывов и положительных мест во многих рейтингах.
4427.12 4432.56 "Анатолий Кулаков" Доклад называется "Паттерны распределенных систем в традициях коренных малочисленных народов Севера".
4432.56 4438.12 "Анатолий Кулаков" И если вас заинтриговало название, то вы абсолютно не разочаруетесь самим докладом.
4438.12 4442.80 "Анатолий Кулаков" Потому что в докладе все обыграно и представлено именно в том же жанре.
4442.80 4457.04 "Анатолий Кулаков" Легкий, ненавязчивый юмор, разбавленный отличными паттернами распределенных систем и подводящий хорошую основу, хорошую базу для любой команды, которая начинает заниматься распределенными системами.
4457.04 4469.88 "Игорь Лабутин" На пятом месте наш давний друг и проверенный докладчик Станислав Сидористый, который в очередной раз показал, что можно сделать с кодом, если вы хотите сделать его с Zero Location.
4469.88 4479.08 "Игорь Лабутин" Это Hardcore, это Memory Pooling и все остальные техники, которые вы делаете для того, чтобы оставить карбюдж-коллектор без работы.
4479.08 4490.00 "Игорь Лабутин" Так что, если вам кажется, что ваше приложение кушает много памяти, если вам хочется сделать так, чтобы оно кушало ее поменьше и при этом работало быстро, смотрите доклад Станислава, там вы найдете немало интересных техник.
4490.00 4492.52 "Анатолий Кулаков" Четвертое место занял Владимир Хориков.
4492.52 4496.96 "Анатолий Кулаков" Владимир - это известный специалист по тестированию и по DDD.
4496.96 4501.10 "Анатолий Кулаков" И в этот раз он нам тоже представил свой доклад про DDD.
4501.10 4505.58 "Анатолий Кулаков" Самое важное, по мнению Владимира, что у нас есть в DDD.
4505.58 4512.34 "Анатолий Кулаков" И в принципе, действительно отличное введение, хорошая компиляция его лекций из его блога.
4512.34 4517.46 "Анатолий Кулаков" Владимир уже не первый раз на нашей конференции и всегда занимает довольно-таки высокие позиции.
4517.46 4525.26 "Анатолий Кулаков" Он отличен как спикер, как преподаватель и как человек, который умеет грамотно, четко доносить очень сложные темы.
4525.26 4527.26 "Игорь Лабутин" Третье место - Михаил Филиппов.
4527.26 4529.78 "Игорь Лабутин" Объятные-объятные инфраструктуры сборки JetBrains Rider.
4529.78 4535.98 "Игорь Лабутин" Еще один докладчик от JetBrains, который обладает огромным опытом в мире сборки.
4535.98 4540.58 "Игорь Лабутин" Михаил долгое время был ответственным за сборку ReSharper.
4540.58 4547.86 "Игорь Лабутин" Rider - это еще более сложная система, потому что это помещь Java, IntelliJ, AD и Sharpen ReSharper.
4547.86 4565.90 "Игорь Лабутин" Поэтому как собрать Rider, как это все вообще работает в масштабах JetBrains, что интересно знает вообще, если вы собираете что-то сложное и большое, вам тогда на этот доклад и смотрите, понимайте, как это все работает, какие моменты нужно обращать внимание.
4565.90 4569.74 "Анатолий Кулаков" Еще один заседатый топов нашей конференции - Егор Богатов.
4569.74 4576.02 "Анатолий Кулаков" И на этот раз он тоже не подвел, занял второе место и рассказал им про то, как устроен JIT-компилятор в Core CLR.
4576.02 4587.34 "Анатолий Кулаков" Егор действительно рассказал много интересных вещей, факов, приемов про JIT-компилятор, про то, как он работает, как оптимизирует код и вообще, что там внутри происходит.
4587.34 4601.70 "Анатолий Кулаков" Замечательный доклад от автора, который внес очень много исправлений, очень много оптимизаций, очень много дополнительного кода в JIT-компилятор и знает не понаслышке, как там все внутри устроено.
4601.70 4613.94 "Игорь Лабутин" Более того, теперь Егор работает непосредственно в команде JIT-компилятора основной, и поэтому мы будем узнавать еще больше интересного про то, как происходит это дело и как вообще все там устроено и работает.
4613.94 4618.58 "Игорь Лабутин" На первом месте - Джаред Парсонс с темой nullability и C#.
4618.58 4638.38 "Игорь Лабутин" А как я говорил на предыдущем .next, Андрей Дятлов сделал подробный доклад про nullable reference types, но у Джаред Парсонса как разработчика непосредственно компилятора, где они все это nullability обеспечивали, наверняка было что добавить, и это вылилось в отличный доклад, который занял первое место.
4638.38 4654.06 "Игорь Лабутин" Джаред рассказал какие-то добавки к тому, что рассказывал Андрей, он использовал доклад Андрея для подготовки, и кроме того, рассказал планы, рассказал, какие трудности были и как вообще все это будет жить дальше, так что топ-1, мне кажется, надо смотреть обязательно.
4654.06 4661.42 "Анатолий Кулаков" Мы рассказали вам только о 10 докладах, но абсолютно весь плейлист шикарен, там более 30 докладов.
4661.42 4664.98 "Анатолий Кулаков" Не обязательно этот топ-10 будет лучшим для вас.
4664.98 4676.98 "Анатолий Кулаков" Потому что у каждого свои проекты, у каждого свой опыт, какие-то свои цели, и вполне может быть, что вы найдете тот доклад, который никто не смотрел, кроме вас, но для вас он принесет наибольший value.
4676.98 4695.06 "Анатолий Кулаков" Поэтому посмотрите на весь плейлист, а если вдруг вы почему-то раньше не видели, что .next выкладывает все свои доклады в открытый доступ или не замечали этого, то посмотрите на предыдущие конференции, там тоже собраны вечные доклады, очень много докладов, которые в принципе актуальны до сих пор.
4695.06 4700.98 "Игорь Лабутин" Ну, на этом наш основной технический выпуск, так скажем, техническая часть выпуска закончена.
4700.98 4713.98 "Игорь Лабутин" Дальше у нас осталось еще немножко материала, но тут, к сожалению, я был в отпуске, и я не смогу ничего добавить, так что, Анатолий, тебе слово, рассказывай, чего ты там наслушал.
4713.98 4717.26 "Анатолий Кулаков" Наша постоянная рубрика, которая называется "Подслушано".
4717.26 4723.90 "Анатолий Кулаков" Я напомню, что мы слушаем очень много подкастов, смотрим очень много докладов и решили сделать для вас вот такую вот компиляцию.
4723.90 4735.70 "Анатолий Кулаков" Например, если вы были Игорем и в это время уходили в отпуск и не знаете, что же вам послушать, я вот как раз за эти недельки насобирал для вас краткий список, по которому вы можете сделать выводы, стоит это слушать или нет.
4735.70 4737.10 "Анатолий Кулаков" Итак, начнем про подлодку.
4737.10 4745.82 "Анатолий Кулаков" В подлодке мне понравился подкаст, где к ним в гости приходил Виталий Брагилевский, это подкаст 200 и 119.
4745.82 4752.38 "Анатолий Кулаков" Если кто не знает, Виталий Брагилевский - это один из самых, наверное, сейчас знаменитых людей, которые занимаются развитием языков.
4752.38 4761.26 "Анатолий Кулаков" И он занимается не каким-то там C# или Go или JavaScript, а он занимается теми языками, которые будут популярны через 10 или может быть даже через 20 лет.
4761.26 4773.82 "Анатолий Кулаков" Вот если вы хотите узнать, что будет в тех языках, на которых будут разрабатывать, может быть, ваши дети или может быть даже ваши внуки, вот тогда рекомендую выпуск 119 с Виталием Брагилевским.
4773.82 4784.78 "Анатолий Кулаков" Там он как раз таки рассказывает про теорию языков программирования и о том, куда двигаются языки, что, по его мнению, будет в будущем и как к этому подготовиться.
4784.78 4801.62 "Анатолий Кулаков" А в 200 выпуске Виталий рассказывает о том, каким образом учить языки программирования, зачем вообще их нужно учить, какие языки хорошие, может быть, какие-то плохие, в чем плюсы и минусы каждого языков, кого, когда из них нужно применять и вот прочее-прочее про теорию изучения языков.
4801.62 4824.94 "Анатолий Кулаков" Выпуск мне очень понравился, потому что я сам склоняюсь к тому мнению, что языки программирования учить нужно разные, интересные, несмотря на то, что вы на работе, может быть, пишете 20 лет одну и ту же программу на одном и том же языке программирования, знать нужно много разных языков для того, чтобы принимать принципы, для того, чтобы принимать шаблоны, для того, чтобы как-то мыслить нестандартно, смотреть вокруг и очень много других преимуществ.
4824.94 4830.58 "Анатолий Кулаков" Дает просто разностороннее изучение мира вокруг, в том числе разных языков программирования.
4830.58 4834.58 "Анатолий Кулаков" В DevZem заходил Владимир Хориков.
4834.58 4839.42 "Анатолий Кулаков" Если вы слушаете наши подкасты, то вы знаете, что это один из наших любимейших авторов.
4839.42 4841.86 "Анатолий Кулаков" У него много интересных статей, много докладов.
4841.86 4845.74 "Анатолий Кулаков" Вот как раз-таки на Dext он недавно занял хорошие места.
4845.74 4859.52 "Анатолий Кулаков" Владимир выпустил книгу, в принципе, выпустил он ее давно и как раз DevZem рассказывал о том, каково это написать книгу, какие плюсы у этого процесса есть, какие минусы, что было сложно, что было легко, зачем вообще люди пишут книги.
4859.52 4864.38 "Анатолий Кулаков" Книга у него про тестирование, поэтому некоторые темы с книги они также затронули в выпуске.
4864.38 4868.82 "Анатолий Кулаков" Они поговорили про тестирование, МОКи, про изоляцию, про базовые вопросы, базовые принципы.
4868.82 4881.58 "Анатолий Кулаков" Один из шоков, который у меня был во время прослушивания этого подкаста, Игорь, попробуй зацени, они не знали, что существует сайт Pluralsight и они также не знали, кто такой Джон Скитт.
4881.58 4885.66 "Анатолий Кулаков" Вот в моей вселенной, мне кажется, такого быть не может.
4885.66 4890.38 "Анатолий Кулаков" Не могут люди, которые интересуются темой, ведут подкасты, не знать таких элементарных вещей.
4890.38 4891.38 "Анатолий Кулаков" Оказывается, могут.
4891.38 4896.86 "Анатолий Кулаков" Если вы не дотнет-разработчик, то вы вполне можете не знать Pluralsight и Джона Скитта.
4896.86 4897.86 "Анатолий Кулаков" Как тебе вопрос?
4897.86 4905.46 "Игорь Лабутин" Ну, про Джона Скитта ещё ладно, он действительно может быть довольно популярен в дотнет-мире, но за его прителами может быть действительно не так известен.
4905.46 4910.50 "Игорь Лабутин" Но мне казалось, что Pluralsight - это не только дотнет и даже не столько дотнет.
4910.50 4915.18 "Игорь Лабутин" Там довольно много джаваскрипта, там довольно много других технологий, так скажем.
4915.18 4928.26 "Анатолий Кулаков" Да, мне тоже именно так и казалось, но на самом деле оказывается, что как раз таки Pluralsight начинался с чистого дотнета и только потом он начал развиваться вширь и уже сейчас на нём начали появляться другие топики по другим направлениям.
4928.26 4929.26 "Анатолий Кулаков" Интересно.
4929.26 4941.66 "Анатолий Кулаков" Если вам интересна больше тема про именно юнит-тестирование, а не про написание книжек, то у нас в шоу-ноутах будет видео, которое называется "Pragmatic Unit Testing", которое делал Владимир.
4941.66 4955.58 "Анатолий Кулаков" Очень хорошее видео, в принципе покрывает много тех вопросов, которые у него есть в книге и позволит вам понять, стоит ли покупать книгу полностью или та подача, которую делает Владимир вам почему-то не подходит.
4955.58 4966.70 "Анатолий Кулаков" У Владимира, нужно сказать, был такой довольно мощный сезон, он пробежался не только про Дивзену, я его также обнаружил в SD-касте и The Art of Programming в подкастах.
4966.70 4974.78 "Анатолий Кулаков" Темы совещались разные, но вокруг Владимира, если вы фанат Хорикова, то прослушайте и другие подкасты.
4974.78 4999.62 "Анатолий Кулаков" В IT-бороде пришел Сергей Тихон, кто не знает, Сергей Тихон, наверное, это самый популярный русскоязычный продвигатель F#, он уже давно и очень долго ведет F#-дайджест, как раз таки в этом подкасте затрагивалась эта история, каким образом он вообще начал вести дайджест, почему он его ведет, что он туда пишет, чему ему этого стоит.
4999.62 5020.42 "Анатолий Кулаков" Также рассказал про свою биографию, как он познакомился с F# и уже непосредственно обсудили язык, особенности языка F#, какие у него плюсы, минусы, какие неочевидности, чем Сергей занимается в Open Source, как связан Сергей Тихон с Blazor и WebAssembly и много интересного из жизни такого замечательного человека.
5020.42 5029.90 "Анатолий Кулаков" В общем, тоже всем любителям F# или кто интересуется этим environment или инфраструктурой, рекомендую IT-борода с Сергеем Тихоном.
5029.90 5036.86 "Игорь Лабутин" И да, мне точно на самом деле есть что послушать, я думаю, что из этого я что-то себе заберу и добавлю в списочек.
5036.86 5039.74 "Анатолий Кулаков" Ну что ж, наверное, давай закругляться.
5039.74 5041.86 "Анатолий Кулаков" Давайте разыграем лицензии.
5041.86 5050.54 "Анатолий Кулаков" Из-за того, что мы так много использовали в этом выпуске слово JetBrains, я думаю, нам комментаторы не простят, если мы не раздадим лицензии.
5050.54 5054.26 "Анатолий Кулаков" Поэтому объявляется конкурс на три лицензии JetBrains.
5054.26 5057.54 "Анатолий Кулаков" Одну получит тот, кто напишет комментарий в YouTube.
5057.54 5071.54 "Анатолий Кулаков" Все что угодно, можете написать какой-нибудь комментарий о выпуске, нравится он нам, не понравился, что нравится, что не нравится, город из которого слушаете, место из которого слушаете, как зовут собаку, с которой вы гуляете, когда слушаете наш подкаст.
5071.54 5078.82 "Анатолий Кулаков" Без разницы, просто напишите нам комментарий, мы хотим просто знать, что люди живые у нас есть и скачивают нас не только роботы.
5078.82 5083.38 "Анатолий Кулаков" Вторую лицензию получит тот, кто расшарит наш подкаст ВКонтактике.
5083.38 5087.74 "Анатолий Кулаков" В группе DotNet.ru будет анонс этого подкаста, этого выпуска.
5087.74 5097.06 "Анатолий Кулаков" И третью лицензию тот, кто расшарит среди своих друзей в Твиттере анонс этого подкаста, который будет также в группе Твиттера DotNet.ru.
5097.06 5098.42 "Анатолий Кулаков" Вот три лицензии.
5098.42 5100.30 "Анатолий Кулаков" Розыгрыш будет в течение 7 дней.
5100.30 5103.38 "Анатолий Кулаков" О результатах мы подробно выложим в наших социальных
5103.38 5105.38 "Игорь Лабутин" сетях. На этом будем завершаться.
5105.38 5112.14 "Игорь Лабутин" Сегодня мы посмотрели на мало тем на самом деле, но получился довольно насыщенный выпуск.
5112.14 5117.50 "Игорь Лабутин" Мы выкинули часть тем из бэклога и вы их можете почитать в отдельной статье.
5117.50 5118.74 "Игорь Лабутин" Ссылочка будет отдельно.
5118.74 5124.30 "Игорь Лабутин" Мы посмотрели, что нового появилось в DotNet 6 Preview 1 и вообще какие планы у Microsoft на DotNet 6.
5124.30 5126.78 "Игорь Лабутин" И планов очень и очень много.
5126.78 5133.90 "Игорь Лабутин" Подвели некоторые итоги работы JetBrains в 2020 году и будем смотреть с оптимизмом в будущий год.
5133.90 5139.26 "Игорь Лабутин" Заполняйте опросы JetBrains, чтобы узнать, где же вы находитесь в мире с точки зрения DotNet разработки.
5139.26 5145.06 "Игорь Лабутин" Глянули на Templating Language Scribben от Александра Мютола.
5145.06 5152.94 "Игорь Лабутин" Посмотрели, вспомнили, что такое меморилики, как с ними бороться, как их искать и как с ними бороться, то есть как их не допускать.
5152.94 5160.74 "Игорь Лабутин" Кратенько обсудили топ 10 видео DotNet 2020 в Москве и немножко напомнили про те подкасты, которые мы
5160.74 5161.74 "Анатолий Кулаков" слушаем.
5161.74 5164.46 None Ну что ж, на этом все. Всем счастливо, всем пока.
5164.46 5165.46 "Анатолий Кулаков" Всем пока.
5165.46 5169.62 "Анатолий Кулаков" И если хочешь поддержать любимый подкаст, заходи на Boosty и Patreon.
5169.62 5170.62 "Анатолий Кулаков" Ссылки будут в шоу-нотах.
5170.62 5173.10 "Игорь Лабутин" С вами был Игорь Лабутин и Анатолий Кулаков.
5173.10 5178.10 "Игорь Лабутин" Пока.
