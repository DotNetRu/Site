0.00 16.68 "Анатолий Кулаков" Здравствуйте дорогие друзья, в эфире радио.нет выпуск номер 75 и в эфире с вами Анатолий Кулаков и Игорь Лабутин.
16.68 17.68 "Анатолий Кулаков" Всем привет!
17.68 29.52 "Анатолий Кулаков" А также большая орда наших слушателей, которые не забывают нас лайкать, ставить 5 звездочек в iTunes и прочих безобразиях, писать комментарии и всячески поощрять наш нелегкий труд.
29.52 40.64 "Анатолий Кулаков" И в частности, наши группы поддержки Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Лазарев, Илья, Гурий, Самарин, Виктор, Руслан Артамонов, Александр Ерыгин и Виловский Евгений.
40.64 51.28 "Анатолий Кулаков" Спасибо всем большое, кто нас поддерживает, а также не забывает рассказывать про нас своим друзьям и конечно же слушать, обязательно слушать и оставлять еще комментарии.
51.28 53.52 "Анатолий Кулаков" Комментарии мы тоже очень-очень любим.
53.52 63.84 "Анатолий Кулаков" Так, вроде все, расхвалил нас со всех сторон, теперь мы должны попереть звездочки и рейтинги, можно непосредственно перейти к новостям.
63.84 66.68 "Анатолий Кулаков" Что у нас там интересного?
66.68 74.48 "Игорь Лабутин" Мы аккуратненько прожидали примерно 2 недели, плюс-минус, и Microsoft выпустил новые превью 6, которые мы пережидали.
74.48 75.48 "Анатолий Кулаков" Пунктуальность это хорошо.
75.48 76.48 "Анатолий Кулаков" М?
76.48 78.12 "Анатолий Кулаков" Я говорю, пунктуальность это хорошо.
78.12 82.92 "Анатолий Кулаков" Да, главное, что Microsoft подстраивается под наши выпуски, и Microsoft молодец.
82.92 96.68 "Игорь Лабутин" Слушай, да, стоит нам начать обсуждение, что неправильно написать следующий выпуск, тут же опа и готовый новый превью, про который на самом деле говорили очень много хвалебных отзывов, в твиттере прям многие писали типа вау-вау, ну из тех, кто из Microsoft.
96.68 104.92 "Игорь Лабутин" Что вообще за шибенный превью, ну давайте почитаем, посмотрим, что же в нем такого крутого и действительно ли он так хорош, как его нахвалят.
104.92 116.80 "Игорь Лабутин" Понятно, что делать не так, чтобы сильно плохо, но не знаю, я в нем честно сказать не нашел каких-то супер крутых прорывных идей, но много очень полезных и приятных мелочей.
116.80 131.36 "Игорь Лабутин" Но начнем, как обычно, с главной части, это основной дотнет, в ней обычно рассматриваются все кусочки дотнета, которые касаются всех различных фреймворков, и первым внезап там идет систем текст JSON.
131.36 140.24 "Игорь Лабутин" Я уже, по-моему, один раз говорил, что я привык его видеть в spnet разделе, но почему-то его теперь постоянно запихивают в основной дотнет раздел, а не в spnet.
140.24 148.92 "Анатолий Кулаков" Все отвыкает, потому что сервизация JSON, такой же, как и текст, не обязательно в spnet, ты можешь сервизовать и децервизовать и в обычном консольном приложении.
148.92 164.04 "Игорь Лабутин" Это правда, но поэтому, видимо, они туда включают, а еще туда это включают, потому что это все дело относится к nativeout, который, видимо, довольно сильно сейчас продвигается, и поэтому оно находится, все эти нововведения находятся именно в этом разделе.
164.04 168.16 "Игорь Лабутин" Что же произошло с систем текст JSON в этом превью 6?
168.16 181.24 "Игорь Лабутин" Туда добавили некоторое количество улучшений, точнее, не прям конкретно туда, а в source generator, если вы помните, у system text JSON есть два варианта работы, один вариант основан на reflexe, другой вариант основан на source generator.
181.24 210.48 "Игорь Лабутин" И reflexe, она более функциональная, она позволяет делать больше вещей, чем source generator, но зато она несовместима с nativeout, вариантом компиляции, и Microsoft все-таки старается сделать так, чтобы все-таки nativeout был полноценным решением, что можно было использовать для всего, и поэтому как раз в этой версии в source generator добавили много улучшений для того, чтобы привести функциональность в соответствии с тем, что умеет reflection-based сериализатор.
210.48 212.72 "Игорь Лабутин" Там не все поддержано, но тем не менее.
212.72 227.24 "Игорь Лабутин" И одно из нововведений, это особенно подчеркнутое в статье, это JSON string-num-converter от tay-num, то есть генериковый тип конвертер, который дополняет негенериковый вариант, который не поддерживается в nativeout.
227.24 236.72 "Игорь Лабутин" То есть они, поскольку для nativeout важно отсутствие рефлексии, они всячески делают генерик версии всего и вся, чтобы оно таки заработало.
236.72 237.72 "Игорь Лабутин" В общем-то все.
237.72 245.52 "Игорь Лабутин" В системе JSON на этом все, но эта новость настолько важная, что вот она удостоилась первой строчки большой статьи.
245.52 246.52 "Игорь Лабутин" Дальше.
246.52 247.52 "Игорь Лабутин" Zip-файл.
247.52 251.48 "Игорь Лабутин" Поддержка zip-файлов была добавлена в .NET относительно недавно.
251.48 264.60 "Игорь Лабутин" Она была добавлена через класс zip-файл, и там есть два метода - createFromDirectory и extractToDirectory, соответственно для создания и для распаковки zip-файлов.
264.60 268.28 "Игорь Лабутин" Теперь оно умеет не только непосредственно на диск это делать, но и в стримы.
268.28 286.08 "Игорь Лабутин" То есть если вам нужно в памяти зазиповать что-то из директории на диске в zip-архив, тут же его отправить, например, по каком-то там, не знаю, http-каналу в ответ на http-запрос, то теперь не нужно его сначала сохранять в темповый файл на диске, а потом отсылать через http-запрос.
286.08 291.28 "Игорь Лабутин" Сразу можно воспользоваться нужной версией метода, которая пишет в стримы.
291.28 296.12 "Игорь Лабутин" С Metrics API происходит полномерное улучшение.
296.12 310.16 "Игорь Лабутин" Раньше у нас был класс, который назывался InstrumentRecorder, который позволял записывать результаты, работал таким типа мини-прометеусом, то есть он позволял записывать ваши метрики в себя.
310.16 314.48 "Игорь Лабутин" Теперь этот класс называется MetricCollector, его немножко переделали, передизайнили.
314.48 316.76 "Игорь Лабутин" Его основное предназначение это для тестов.
316.76 324.84 "Игорь Лабутин" То есть если вам нужно в тестах что-то посмотреть, померить какие-то метрики, понять как ведет ваше приложение, то вот используйте MetricCollector.
324.84 329.04 "Игорь Лабутин" Мы про него еще чуть дальше поговорим, чуть ниже в s.p.net разделе.
329.04 341.16 "Игорь Лабутин" SourceGenerators у нас находят применение почти везде, и теперь у нас появился еще один SourceGenerator Microsoft, который нужен для того, чтобы валидировать опции.
341.16 353.56 "Игорь Лабутин" Если мы теперь возьмем класс, как мы пишем SourceGenerator, в смысле как мы используем SourceGenerator, берем и объявляем partial class, который реализует какой-нибудь интерфейс, например, и отмечет каким-нибудь атрибутчиком.
353.56 356.44 "Игорь Лабутин" И остальное SourceGenerator дегенерит его.
356.44 369.72 "Игорь Лабутин" Так вот, если вы теперь объявите partial class, который реализует iValidateOptions от типа T, и пометите его атрибутом OptionsValidator, то за вас сгенерится SourceGenовая версия, которая будет этот тип T уметь валидировать.
369.72 379.16 "Игорь Лабутин" Понятное дело, она просто в compile-time обойдет весь тип T, все его поля, и проверит все data annotation атрибуты, и сгенерит код, собственно, валидации.
379.16 383.16 "Игорь Лабутин" Не нужна никакая рефлексия, не нужен runtime, все работает на эти фауты счастливые.
383.16 387.24 "Анатолий Кулаков" Ну, то есть это валидация именно по data annotation атрибутам, да, происходит?
387.24 388.24 "Игорь Лабутин" Насколько я понял, да.
388.24 408.92 "Игорь Лабутин" Я не читал исходники, и не вдумывался подробно в документацию SourceGenerator, что он там умеет, что поддерживает, что не поддерживает, но я думаю, что там скорее всего поддержано, конечно же, далеко не все, что умеет базовый обычный наш привычный валидатор, но как обычно, поскольку это превью, в следующих превью он будет допиливаться, дорабатываться и улучшаться.
408.92 417.36 "Игорь Лабутин" К релизу достигнуть какого-то, ну если не паритета с reflection вариантом, то близко к нему.
417.36 427.12 "Анатолий Кулаков" Ну, в принципе, в data annotation там не так уж и много работает, они не очень сложные, поэтому я верю, что можно доделать, придать полноценную функциональность.
427.12 442.44 "Игорь Лабутин" Дальше, если вы зачем-то используете logger message attribute, то там немножко добавили, допилили этот атрибутик, чтобы было все побыстрее и получше, поменьше на всякий боксинг и работать с памятью и так далее.
442.44 451.04 "Игорь Лабутин" Опять же про SourceGenerator, у нас есть штука, которую мы, не мы, Microsoft, заинтродиусил в третьем превью, это configuration binding SourceGenerator.
451.04 462.08 "Игорь Лабутин" Ну и теперь он всегда включен для nativeout приложений и может быть включен вручную через csproj enable configuration binding generator.
462.08 469.56 "Игорь Лабутин" В общем, все, что можно, Microsoft переводит на SourceGenerator, потому что иначе, видимо, nativeout работать не будет.
469.56 472.12 "Игорь Лабутин" И поэтому у нас есть еще один SourceGenerator.
472.12 483.00 "Игорь Лабутин" В общем, dotnet 6, вот этот 8preview6, это превью SourceGenerator, потому что следующий неожиданный SourceGenerator на самом деле для меня это SourceGenerator для com.interop.
483.00 507.12 "Игорь Лабутин" У нас уже есть один, который для обычного library import, то есть если вы хотите позвать какой-нибудь метод из dll, нативный платформенный, вы можете этот метод написать, как обычно, в сигнатуру метода c#, пометить его атрибутом в library import и все остальное SourceGenerator вам допилит всяким rshaling, rnrshaling и вот это вот все.
507.12 518.56 "Игорь Лабутин" Теперь можно пометить атрибутом generated.com.interface и после этого у вас допилится кусочек кода, который позволит прям вызывать com-методы.
518.56 526.76 "Игорь Лабутин" Там есть куча ограничений, посмотрите статью внимательно, но для каких-то базовых сценариев это точно уже работает и можно пользоваться.
526.76 537.36 "Игорь Лабутин" В общем, мне кажется, с SourceGenerator у Microsoft появилась какая-то возможность переписать половину bcl на их использование и избавиться от рефлексии.
537.36 542.00 "Анатолий Кулаков" Интересно, что их заставило в ком полезть, не говорится там, где они их собираются применять?
542.00 551.36 "Игорь Лабутин" Нет, не говорится, но чую я, что нужны им какие-то штуки для себя, возможно, не знаю, там Visual Studio на nativeout частично переведут, а?
551.36 552.36 "Анатолий Кулаков" Прикинь?
552.36 558.04 "Анатолий Кулаков" Ну там плюсов не меньше, чем шарпов, поэтому не знаю, не знаю.
558.04 564.92 "Игорь Лабутин" Ну тем не менее, наверняка это чем-то дравится, каким-то внутренним бизнесом, мне кажется, хотя не знаю, может кто-то из комьюнити пришел.
564.92 579.08 "Анатолий Кулаков" Да, вряд ли кому-то эта штука вообще была нужна, даже если из комьюнити кто-то пришел, Microsoft бы отказал, если бы не было нужно ему самому посмотреть, сколько из комьюнити пытались и WPF сохранить, и WCF сохранить, да наплевать им на комьюнити, ну по крайней мере в этом аспекте.
579.08 581.80 "Игорь Лабутин" Хорошо, ладно, давай дальше пойдем.
581.80 620.84 "Игорь Лабутин" Поддержаны https-прокси, это такие специальные прокси, которые секьюрно проксируют ваши допросы, SHA-3 поддержали и улучшили контейнер паблишинг перфоманс, как они пишут, и компатибилити, то есть теперь, когда вы в SDK паблишите контейнер куда-нибудь через SDK, то он это делает побыстрее, получше, напомню, что можно у нас теперь собирать контейнеры и пушить их без наличия докера для сборки, докера не нужно, SDK сам умеет собирать образы и пушить их теперь, вот это все они потихонечку полномерно улучшают и ускоряют.
620.84 713.04 "Игорь Лабутин" Для WebAssembly завезли штуку под названием гибридная локализация, и я напомню, что у нас можно собирать WebAssembly с полной локализацией, можно собирать вообще без локализации, точнее это называется Invariant Globalization режим, проблема с ним в том, что вы тогда не можете использовать собственно локализованную информацию о том, где какие-то там, не знаю, форматы, еще что-нибудь такое используется, но если вам это не нужно, то это хорошо, но если вам вдруг нужно, то если вы тащите полную локализацию, то вы с собой тащите довольно большой объем данных, а поскольку это WebAssembly, то это означает, что, особенно в режиме WebAssembly, который в браузере, что вам все это нужно затащить в браузер, то есть скачать, то есть потратить время, трафик и ожидания пользователя, это не очень хорошо, поэтому вот ввели гибридную локализацию, она-то более легковесная штука, она работает довольно замысловатым образом, как я понял, она часть данных тащит из собственно того, чего вы будете скачивать с сайта, в смысле с вашего дипломного приложения в браузер, а часть берет информацию из JavaScript, то есть такой получается микс информации, частично из .NET, частично из JavaScript, потому что в браузере оно уже есть, потому что скорее всего браузер, понятно, пользователь обычно хочет той локали, в которой он и так работает, так что если вы пишете в основное приложение, ну вот гляньте с локализацией, я не пишу поэтому сильно больше, чем я рассказал, особо не знаю.
713.04 745.56 "Игорь Лабутин" И последний пункт в статье про .NET мне показался довольно, для меня был довольно неожиданным, потому что он звучит как то, что мы в nativeout теперь поддержали iOS, при том, что мне казалось, что одна из причин, почему мы делаем nativeout, почему Microsoft делает nativeout, это как раз возможность паблишить спокойно .NET приложение на платформы, где у нас с G2 есть проблемы, в смысле, что архитектура iOS не позволяет работать G2, в смысле, чтобы делать странички, которые он записывает, тут же исполнимыми.
745.56 753.24 "Игорь Лабутин" Поэтому для меня было странным, что nativeout только сейчас можно таргетить для iOS.
753.24 754.76 "Игорь Лабутин" Ну вот теперь можно.
754.76 764.00 "Анатолий Кулаков" Может там просто какие-то биндинги появились, технические, и раньше можно было, но каких-то биндингов стандартных не хватало для того, чтобы нативно интегрироваться с этим.
764.00 775.48 "Игорь Лабутин" Возможно, но при этом они, кстати, выиграли в размере, то есть у них теперь написано, что мы примерно на 40% меньше файлики получаются в том вот варианте, как они сейчас таргетятся.
775.48 780.76 "Игорь Лабутин" Но при этом не все фичи iOS поддержаны, так что там еще есть куда работать.
780.76 785.92 "Игорь Лабутин" Вот примерно все про основную часть .NET, но у нас еще есть ISP.NET.
785.92 788.64 "Игорь Лабутин" В ISP.NET все тоже довольно развесисто.
788.64 794.82 "Игорь Лабутин" Во-первых, продолжается улучшение всякого разного про дебаггинг.
794.82 804.68 "Игорь Лабутин" Мы уже рассказывали, что вокруг что-то по реквестам, что-то по респонсам и прочих других классов, которые обычно вы можете встретить при работе с веб-приложениями.
804.68 808.60 "Игорь Лабутин" Докрутили всяких дебаггеров и визуалайзеров, так что они теперь хорошо показываются в дебаггере.
808.60 811.84 "Игорь Лабутин" Теперь эта очередь дошла до веб-аппликейшена.
811.84 818.72 "Игорь Лабутин" Если вы посмотрите на ваш веб-аппликейшен, который с билдера возвращается, то у него теперь в дебаггере показывается все красиво.
818.72 828.08 "Игорь Лабутин" Какие стадии lifecycle прошли, какие не прошли, как там middleware, какая коллекция, сколько их штук и так далее.
828.08 829.28 "Игорь Лабутин" В общем, поприятнее.
829.28 832.48 "Игорь Лабутин" Очень много улучшений в Blazor.
832.48 839.28 "Игорь Лабутин" Я ими сейчас особо не пользуюсь, в смысле улучшениями Blazor, поэтому тоже знаю чисто теоретически.
839.28 849.76 "Игорь Лабутин" Но довольно много изменений вокруг сервера сайта rendering, в смысле что всякие изменения, которые поддержаны конкретно на сервере сайта rendering.
849.76 859.08 "Игорь Лабутин" Либо для компонентов вы можете теперь выбирать, где вы хотите рендерить его, хотите на сервере, хотите не на сервере.
859.08 870.68 "Игорь Лабутин" Улучшение поддержки секций, query-стринги поддержаны в любых компонентах, в смысле что как раз это значение из внешней странички в любые внутренние компоненты можно получить доступ.
870.68 880.76 "Игорь Лабутин" И немножко изменили темплейты, они называют консолидацию, то есть видимо уменьшили количество Blazor темплейтов, свели их в несколько более универсальных, больших.
880.76 887.92 "Игорь Лабутин" Если занимаетесь Blazor, то посчитайте внимательно статью, там много всяких разных именно технических моментов, которые улучшили.
887.92 889.84 "Игорь Лабутин" Не буду сейчас на них останавливаться.
889.84 898.32 "Игорь Лабутин" С метриками добавили поддержку тестирования метрик, ну это тот самый класс метрик collector, который я говорил выше.
898.32 927.68 "Игорь Лабутин" И добавили некоторое количество новых метрик вокруг маршрутизации, насколько там успешные, неуспешные рауты матчатся, и вокруг ошибочных ситуаций, то есть Diagnostic Handler теперь, точнее Exception Handler теперь пишет некоторое количество диагностики в метрике HTTP Server Unhandled Requests, то есть когда мы вообще не смогли по этим маршрутам обрабатывать этот конкретный запрос.
927.68 930.76 "Игорь Лабутин" Ну тогда некоторые метрики будут меняться.
930.76 939.28 "Игорь Лабутин" И вокруг rate limiting тоже накрутили довольно много метрик, чтобы вы понимали, что происходит с rate limiting ваших приложений.
939.28 969.00 "Игорь Лабутин" В HTTP Sys, это штука, которая обычно работает на виндах, если вы не пользуетесь Kestrel на его нативном, так сказать, драйвере, то есть в основном это значит, что вы живете на EAC, добавили буферизацию респонсов, то есть вы теперь можете прямо настроить, и он будет собирать респонс в буфер, прежде чем отправить, помогает когда вы пишете много-много-много маленьких кусочков в output stream, например, собираете его по частям из каких-то элементов.
969.00 983.68 "Игорь Лабутин" И мы когда-то рассказывали про output caching, что у нас теперь есть штука, которая позволяет кешировать ответы сервиса на уровне самого сервиса, вот теперь добавили стандартный backend для него на основе Redis.
983.68 987.64 "Игорь Лабутин" Можно теперь туда подключить Redis, и он будет распределенно кешировать.
987.64 1072.84 "Игорь Лабутин" Уже традиционно в блок новостей о новом превью третьим идет не Entity Framework, про который тишина и гладь и там видимо никаких больших хищ не выходит, либо они не хотят писать про них или ленятся или не знаю что, зато есть про Maui, большая статья, в которой есть раздел про то, что ну мы пофиксили какие-то баги на десктопе, мы улучшили там управление памятью и убрали некоторые меморелики, да у них есть меморелики, но зато мы заинтродюсили большое расширение для VS Code, то есть оно сейчас пока в превью режиме, но теперь у нас есть экстенджер для VS Code, который позволяет писать для Maui, там есть подсветка синтаксиса для Xaml, понятно есть подсветка синтаксиса для C#, можно дебажить всякие там андроидные и iOS-ные симуляторы и девайсы на разных операционках, там немножко разные варианты доступны, но тем не менее в среднем доступны, довольно логичные комбинации, типа там iOS недоступен на винде, но Mac OS доступен, это расширение основано на расширении C# DevKit, о котором мы рассказывали пару выпусков назад, и как мы говорили, оно требует подписки Visual Studio, поэтому если вы хотите на Visual Studio Code программировать для Maui, вам все равно потребуется подписка Visual Studio, уж не знаю какого уровня, нужна ли там Enterprise, Enterprise, я не выяснял, но какая-то нужна.
1072.84 1081.44 "Игорь Лабутин" Вот и все, что вошло в DotNet 8 Preview 6, не знаю, стоило ли оно того прям, типа таких вау-комментариев, но что есть, то есть.
1081.44 1099.92 "Анатолий Кулаков" Ну и чем ближе к релизу, тем кажется, что этот релиз DotNet будет в основном таким стабильным, перформансным и аутным, конечно же, Blazor-ным и аутным, и никаких новых реализационных идей в плане языка или в плане технологий ждать, наверное, уже не стоит.
1099.92 1108.64 "Игорь Лабутин" Ну про язык мы поговорим сегодня чуть-чуть подробнее, но давай пока сначала немножко продолжим про ISP.NET, у нас есть статья от Эндрю Лока.
1108.64 1121.92 "Анатолий Кулаков" Ну, кстати, вот Эндрю Лок - это хороший такой показатель, что там, собственно, нас ждет в будущих релизах, потому что он всегда по косточкам разбирает новые фреймворки и смотрит, что там, как поменялось, какие новые инструменты доступны и как мы теперь будем работать.
1121.92 1126.64 "Анатолий Кулаков" А ISP - это прям перениматель всех новинок, которые только есть.
1126.64 1134.96 "Анатолий Кулаков" Можно даже сказать, что он законодатель, потому что там первые спаны, когда появились, они были сделаны там для ISP, первые оптимизации для Kestela и так далее.
1134.96 1145.96 "Анатолий Кулаков" То есть все непосредственно, что связано с перформансом, какими-то новинками, garbage-collector, Jita, ISP.NET команда первая в себя пробирует и первая к себе внедряет.
1145.96 1155.64 "Анатолий Кулаков" И здесь, опять же, как я уже сказал, Эндрю Лока можно использовать как некий компас, и этот компас нам очень часто в последнее время рассказывает про аут с разных сторон.
1155.64 1171.36 "Анатолий Кулаков" И в частности, вот еще одна статейка, хорошая у него есть, которая называется "Сравнение Web Application Create Builder", который мы раньше все с вами использовали для ISP.NET приложений, с новым методом, который называется Create Slim Builder.
1171.36 1173.40 "Анатолий Кулаков" Мы его тоже упоминали недавно в прошлых выпусках.
1173.40 1180.44 "Анатолий Кулаков" Новый метод, и давайте наконец нормально сядем и разберемся, что это такое, для чего он нужен и чем может быть нам полезен.
1180.44 1190.72 "Анатолий Кулаков" Итак, метод Create Slim Builder, он был введен в .NET 8 и является альтернативой, как я уже сказал, в Web Application Create обычному билдеру.
1190.72 1195.80 "Анатолий Кулаков" И нужен он как раз для тех моментов, когда мы собираемся использовать аут сценарий.
1195.80 1206.68 "Анатолий Кулаков" То есть когда мы собираемся проджитить наш код и оптимизировать его по размеру, увеличить скорость старта приложения и все прочие плюшки, которые нам дает аут.
1206.68 1212.12 "Анатолий Кулаков" И важная часть компиляции аута в том, что аут дает нам тримминг.
1212.12 1214.44 "Анатолий Кулаков" Прежде всего это уменьшить размер нашего приложения.
1214.44 1220.12 "Анатолий Кулаков" И делается это с помощью сокращения тех частей, которые в вашем приложении не используются.
1220.12 1227.52 "Анатолий Кулаков" То есть раньше вас компилятор забирал в ваше приложение и там была целая куча ненужного для вас кода, которые вы никогда не запускали.
1227.52 1231.12 "Анатолий Кулаков" Но в этом особой проблемы не было, потому что джит просто-напросто.
1231.12 1236.36 "Анатолий Кулаков" Этот код никогда не джитил и вы не тратили время ни на старте приложения, ни память на него не аллоцировалась.
1236.36 1238.88 "Анатолий Кулаков" Ну вообще он никак не участвовал в работе.
1238.88 1245.64 "Анатолий Кулаков" Единственное где он себя каким-то образом проявлял это размер бинарника, который распространялся в виде вашего приложения.
1245.64 1255.92 "Анатолий Кулаков" И вот задача аута как раз найти все эти неиспользуемые плюшки, отрезать их полностью и сократить размер в размер вашего итогового приложения.
1255.92 1264.68 "Анатолий Кулаков" И для того, чтобы сократить размер вашего итогового приложения, товарищу аоту необходимо знать какой код используется, а какой не используется.
1264.68 1265.68 "Анатолий Кулаков" Логично.
1265.68 1269.24 "Анатолий Кулаков" И самый главный враг этого знания это конечно же рефлекшн.
1269.24 1276.72 "Анатолий Кулаков" Потому что рефлекшн помогает разработчикам во время исполнения как раз таки решить, хотим мы этот код использовать или нет.
1276.72 1284.16 "Анатолий Кулаков" Например, пойти поискать какой-нибудь классик, у этого классика вызвать какие-нибудь методы, которые заранее на этапе компиляции мы не знаем.
1284.16 1291.08 "Анатолий Кулаков" Ни эти методы, ни как этот классик будет использоваться, ни где он будет искаться, может он будет динамически вообще заряжаться с локального диска.
1291.08 1295.08 "Анатолий Кулаков" В общем, все это во время компиляции нам неизвестно.
1295.08 1307.24 "Анатолий Кулаков" И как раз таки все вот эти силы, про которые Игорь чуть раньше говорил, которые направлены на генераторов, на какое-то декларирование во время компиляции, все это нужно как раз для айота.
1307.24 1309.20 "Анатолий Кулаков" И избавление от рефлекшн.
1309.20 1318.32 "Анатолий Кулаков" За все эти годы интернет очень сильно оброс рефлекшном, абсолютно везде, у каждой практически вложающей себе фреймворк, у него есть куча рефлекшна.
1318.32 1323.36 "Анатолий Кулаков" Вот и сейчас мы пытаемся во всей платформе, во всей инфраструктуре от этого избавиться с помощью генераторов.
1323.36 1337.76 "Анатолий Кулаков" И вот createSlimBuilder - это как раз метод, который призван удалить из нашего ISPNet pipeline всякие ненужные вещи, ненужные именно для айота.
1337.76 1350.60 "Анатолий Кулаков" Наверное, даже правильно сказать, несовместимые с айотом, потому что некоторые штуки мы уже умеем в айоте запускать, например, для кого есть генераторы или для тех, кто не требует рефлекшна.
1350.60 1360.36 "Анатолий Кулаков" Некоторые мы научимся в процессе сюда внедрять, а некоторые совсем не хотим, совсем не нужны и поэтому мы их удалим.
1360.36 1366.44 "Анатолий Кулаков" И давайте же посмотрим, что же конкретно делает этот новый метод.
1366.44 1379.16 "Анатолий Кулаков" Как вы, наверное, знаете, обычный createBuilder инициализирует веб-аппликейшн билдера и позволяет потом ваше ISPNet приложение настроить.
1379.16 1393.84 "Анатолий Кулаков" И в общем, Slim занимается тем же самым, он даже использует тот же самый класс веб-аппликейшн билдера, но только со специальным флажком, который позволяет вам использовать только те необходимые методы, которые мы поддерживаем в аоте.
1393.84 1400.76 "Анатолий Кулаков" Ну и этот набор, соответственно, он довольно небольшой, он довольно маленький, именно поэтому это выделось в названии Slim.
1400.76 1411.20 "Анатолий Кулаков" Давайте же конкретно, что у нас отсутствует в Slim, то есть в настоящем веб-аппликейшн билдере, в большом толстом Reflection Based и что у нас отсутствует в Slim.
1411.20 1416.68 "Анатолий Кулаков" Во-первых, у нас не поддерживается Startup, iHosting Startup.
1416.68 1423.88 "Анатолий Кулаков" Это специальные сборочки, которые у нас могут подгружаться во время старта приложения и запускаться до начала времен.
1423.88 1431.24 "Анатолий Кулаков" Это обычно используется во всяких APM, профайлерах и прочих таких системных низкоуровневых вещах.
1431.24 1445.44 "Анатолий Кулаков" Не поддерживается вызов метода useStartup в качестве аргумента, который принимает Classic, потому что, опять же, этот Classic разбирается с помощью Reflection, находятся там методы, которые мы должны вызвать и этот метод тоже дергается с помощью Reflection.
1445.44 1456.36 "Анатолий Кулаков" Здесь кажется, что нет никакой проблемы заменить это на генератор, то есть мы в Compile Time вполне знаем, что у нас есть Classic и какие у него есть методы, но пока не поддерживается.
1456.36 1458.36 "Анатолий Кулаков" Может в будущих версиях добавят.
1458.36 1466.84 "Анатолий Кулаков" Поддерживаются не все логеры, которые требуют много Reflection или вообще пишут когда-нибудь в Windows Event Log.
1466.84 1473.20 "Анатолий Кулаков" От них решили просто отказаться, потому что вряд ли подразумевается, что мы будем это много использовать на Windows.
1473.20 1479.68 "Анатолий Кулаков" В частности, отсутствует такая важная Web Hosting Feature, как Hosting в Easy.
1479.68 1488.92 "Анатолий Кулаков" Тоже не знаю, насколько Microsoft планирует ее добавлять, но скажется, что, опять же, нашему iOtu не очень интересен, по крайней мере, первые релизы точно.
1488.92 1493.28 "Анатолий Кулаков" И есть некоторые фичи, которые отсутствуют в Kestrel.
1493.28 1500.28 "Анатолий Кулаков" То есть вы не сможете настроить Kestrel на использование HTTPS и также нет никакого Quick, он же HTTP 3.
1500.28 1504.40 "Анатолий Кулаков" Эта штука тоже не поддерживается, по крайней мере, на данный момент.
1504.40 1509.60 "Анатолий Кулаков" Также не поддерживаются регулярные выражения и альфа-констрейнты в роутингах.
1509.60 1522.68 "Анатолий Кулаков" У нас есть направления, где мы регулярные выражения записываем с помощью Source Generator, там со своими ограничениями, безусловно, но в роутинг их решили пока не засовывать, пока они там не нужны.
1522.68 1527.92 "Анатолий Кулаков" Ну, будем надеяться, что никогда не засунут и не будут усложнять ту вещь, которую усложнять не надо.
1527.92 1529.96 "Анатолий Кулаков" В общем, вот такие основные изменения.
1529.96 1539.12 "Анатолий Кулаков" И в своей статье Эндрю подробно разбирает, каким образом эти изменения были реализованы в изначальном коде, то есть в изначальном Web Application Builder и что там получилось сейчас.
1539.12 1555.72 "Анатолий Кулаков" Ну, в частности, он обращает внимание на то, что создаётся точно такой же класс в Web Application Builder, единственная разница, которую вы там увидите, это маленький булевый флажок, который называется slim и передается в одном случае true в одном extension методе, а в другом extension методе, таком же, но без slim, передается slim false.
1555.72 1556.72 "Анатолий Кулаков" Вот как бы вся разница.
1556.72 1572.72 "Анатолий Кулаков" Внутри там тоже есть небольшие методы, там UpConfigurationSlim вызывается, @DefaultServicesSlim, в общем, есть какие-то аналоги по Ростову и Слимовскому, которые в большинстве своём выливаются именно те ограничения, которые я сказал.
1572.72 1578.72 "Анатолий Кулаков" Ну, то есть, некоторых вещей нет, некоторые вещи добавлены через генераторы, некоторые вещи там где-то как-то запланированы.
1578.72 1584.04 "Анатолий Кулаков" Всё это сделано вот на таких небольших оболочках, классах и extension методах.
1584.04 1598.36 "Анатолий Кулаков" Если вам интересно вдруг какие-то подробности, чего там творится внутри, то легче обратиться прямо непосредственно к статье, там уже на примере кода, на примере коммитов на GitHub Энди разбирает, каким образом команда этого добилась и каким образом она это ветление обеспечивает.
1598.36 1607.68 "Анатолий Кулаков" Наверное, здесь всё как бы, как ожидалось, классик довольно очевидный, небольшой, никакой магии внутри там связанной непосредственно с аутом там нет.
1607.68 1620.44 "Анатолий Кулаков" Единственное, что там есть, это выбираются те фичи, которые поддерживаются и в правильной конфигурации заносятся в наш код, конфигурацию нашего web application, который мы собираемся сейчас построить.
1620.44 1629.04 "Игорь Лабутин" Ну да, кажется, что эта фича больше ориентирована на всякие докер-контейнеры и прочее, с учётом, что не поддерживают ни HTTP, ни всякие такое.
1629.04 1636.92 "Игорь Лабутин" Мы выставляем всё по HTTP, а остальным будет озаботиться какой-нибудь API твоей безвне на Nginx.
1636.92 1638.52 "Анатолий Кулаков" Ну да, именно так.
1638.52 1655.02 "Анатолий Кулаков" Мне кажется, что это хороший компромисс, когда тебе не нужно реализовать кучу жестких, тяжёлых каких-то протоколов и при этом у тебя есть уже специализированные инструменты, которые пока могут заменить тебе нормальные и коншельки, и сертификаты, и прочие вот эти вещи.
1655.02 1657.30 "Игорь Лабутин" Ну и хорошо, посмотрим, насколько приживётся.
1657.30 1658.30 "Игорь Лабутин" Пойдём дальше.
1658.30 1666.10 "Игорь Лабутин" Дальше у нас, наконец-то, хоть какое-то проявление того, что у нас будет новые фичи в C# 12.
1666.10 1668.58 "Анатолий Кулаков" То есть C# 12 хотя бы будет, да?
1668.58 1669.58 "Анатолий Кулаков" Вот уже хорошее новое.
1669.58 1678.86 "Игорь Лабутин" Он точно будет, и там будет как минимум три новых фичи, про которые сегодня вышла, ну не сегодня вышла статья, но в которой вышла статья, которую мы сегодня будем обсуждать.
1678.86 1682.30 "Игорь Лабутин" Первая фича, она довольно простая и незамысловатая.
1682.30 1686.14 "Игорь Лабутин" Это оператор nameof, который потихонечку расширяется.
1686.14 1703.62 "Игорь Лабутин" Если вы помните, в прошлом .NET добавили возможность указывать сладость, точнее, на имена параметров функции, когда вы используете nameof в атрибуте, который написан перед этой функцией, то есть формально, вне скоупа объявления этих параметров.
1703.62 1711.74 "Игорь Лабутин" В новом же превью теперь nameof позволяет использовать не только любые instance методы.
1711.74 1728.90 "Игорь Лабутин" То есть если у вас, например, есть какой-нибудь string, то вы теперь можете написать nameof, скобочка открылась, s, где s это переменная типа string, точка length, где length это вполне себе instance property, которое, ну как бы, раньше так было нельзя.
1728.90 1729.90 "Игорь Лабутин" Теперь можно.
1729.90 1730.90 "Игорь Лабутин" И все.
1730.90 1731.90 "Игорь Лабутин" Это про nameof.
1731.90 1733.50 "Игорь Лабутин" Больше там ничего нового нет.
1733.50 1736.58 "Игорь Лабутин" Можно доступаться до вынесенных member.
1736.58 1737.58 "Игорь Лабутин" Следующая фича...
1737.58 1738.58 "Анатолий Кулаков" Блин, маловато, маловато.
1738.58 1744.50 "Анатолий Кулаков" Как бы с nameof, там очень много всего можно накрутить, и больше nameof хороших и разных.
1744.50 1746.82 "Анатолий Кулаков" Давайте еще, наверное, nameof будет хорошо.
1746.82 1753.02 "Игорь Лабутин" Ну, наверняка будут потихонечку докручивать по мере того, как будет появляться необходимость в их использовании.
1753.02 1757.02 "Игорь Лабутин" Следующая фича, она такая, про performance.
1757.02 1758.02 "Игорь Лабутин" Называется inline-arrays.
1758.02 1760.42 "Игорь Лабутин" Что это такое?
1760.42 1763.50 "Игорь Лабутин" Они сами говорят, что это advanced feature.
1763.50 1766.42 "Игорь Лабутин" И давайте попробуем понять, как она работает.
1766.42 1767.86 "Игорь Лабутин" Работает она следующим образом.
1767.86 1769.86 "Игорь Лабутин" Берем какой-нибудь тип.
1769.86 1773.78 "Игорь Лабутин" Он должен быть обязательно с единственным полем.
1773.78 1775.78 "Игорь Лабутин" И этот тип объявляем...
1775.78 1788.62 "Игорь Лабутин" Ну, в смысле, на него навешиваем атрибут inline-array, в котором аргументным конструктором этого атрибута является чиселка int, которая является размерностью массива.
1788.62 1792.34 "Игорь Лабутин" Поскольку это array, то это будет размерность массива.
1792.34 1802.26 "Игорь Лабутин" В результате у вас получится некоторый тип, который будет восприниматься runtime как массив.
1802.26 1810.66 "Игорь Лабутин" То есть, когда вы будете использовать этот ваш объявленный тип в нужных местах, это будет на самом деле не одинокое значение с одним полем.
1810.66 1812.66 "Игорь Лабутин" Напоминаю, что тип содержит одно поле.
1812.66 1817.02 "Игорь Лабутин" А это будет массив из стольких элементов, сколько вы указали в атрибуте.
1817.02 1822.50 "Игорь Лабутин" Причем этот атрибут, я так понимаю, константный, compile-time, все должно быть известно.
1822.50 1830.46 "Игорь Лабутин" Кажется, что эта штука нужна для каких-то очень внутренних целей, не знаю, ISP над командой или еще кого-то.
1830.46 1837.26 "Игорь Лабутин" И скорее всего, в нормальной разработческой жизни вы с ними вряд ли столкнетесь.
1837.26 1838.26 "Игорь Лабутин" Давайте так скажем.
1838.26 1841.26 "Анатолий Кулаков" Слушай, ну выглядит это очень ужасно.
1841.26 1845.22 "Анатолий Кулаков" Я сейчас попытаюсь тоже словами описать.
1845.22 1857.02 "Анатолий Кулаков" Передается переменная, которая, допустим, если вы назвали тип буфер 10, он просто буфер 10, это обычная структура с одним-единственным полем, как сказал Игорь.
1857.02 1859.42 "Анатолий Кулаков" Ничего себя страшного, неподозревающего.
1859.42 1863.94 "Анатолий Кулаков" И вдруг у вас вот эта переменная буфер 10, у нее появляется индексатор.
1863.94 1869.46 "Анатолий Кулаков" И вы с помощью индексатора можете обращаться к неким непонятным элементам.
1869.46 1873.34 "Анатолий Кулаков" Непонятным, потому что это обычная структура, там не может быть индексатора.
1873.34 1875.66 "Анатолий Кулаков" То есть добавляется индексатор.
1875.66 1877.22 "Анатолий Кулаков" Выглядит ужасно.
1877.22 1883.46 "Анатолий Кулаков" Просто реально, переходишь на Definition, там просто поле, просто структура с единственным полем.
1883.46 1890.98 "Анатолий Кулаков" Смотришь на использование, у нее появляется индексатор, к ней начинается по индексу обращаться, записывать, читать.
1890.98 1895.58 "Анатолий Кулаков" Просто никаких слов, одни эмоции.
1895.58 1897.46 "Анатолий Кулаков" Что это за дичь, что это за чудо иуда.
1897.46 1899.30 "Анатолий Кулаков" Зачем так могло бы ее?
1899.30 1900.90 "Анатолий Кулаков" Могли бы что-то более элегантное придумать.
1900.90 1901.90 "Анатолий Кулаков" Не знаю.
1901.90 1907.54 "Игорь Лабутин" Ну, в общем, да, я не очень пока знаю, куда и зачем эта штука нужна.
1907.54 1920.90 "Игорь Лабутин" Надо будет, конечно, было бы, наверное, правильнее почитать мотивацию и так далее, как у всех фич она есть, но она настолько внутренняя, что мне кажется, что там будут какие-то очень дрянкие штуки.
1920.90 1921.90 "Игорь Лабутин" Пойдем дальше.
1921.90 1927.98 "Игорь Лабутин" Следующая фича еще более прикольная, не знаю, опять же, кто ее будет использовать.
1927.98 1930.62 "Игорь Лабутин" Называется интерсепторы.
1930.62 1934.10 "Игорь Лабутин" Значит, смотрите, у нас есть source-генераторы.
1934.10 1942.82 "Игорь Лабутин" Source-генераторы позволяют объявить какой-то, допустим, класс partial и догенерить в него новых методов.
1942.82 1946.74 "Игорь Лабутин" Source-генераторы не позволяют менять поведение существующего кода.
1946.74 1954.98 "Игорь Лабутин" Теперь у нас есть фича под названием интерсепторы, которые позволяют менять поведение существующего кода.
1954.98 1973.58 "Игорь Лабутин" А что более правильным сказать, они позволяют сделать так, что в момент compile-тайма будет определено, что какие-то вызовы определенных методов должны быть заменены на вызовы других методов, другого кода, который тоже в compile-тайме написан.
1973.58 1979.30 "Игорь Лабутин" То есть это речь не идет о run-тайме, все это в compile-тайме делается, но тем не менее.
1979.30 1986.66 "Игорь Лабутин" Штука вам позволяет теперь сделать так, что вы видите в коде одно, а в реальной жизни исполняется другое.
1986.66 1998.86 "Игорь Лабутин" По мнению, точнее как написано в статье, нужно это для advanced сценариев, например, для того, чтобы улучшить, чтобы вы думали, конечно же, ahead-of-time compilation.
1998.86 2022.10 "Игорь Лабутин" То есть вероятно идея состоит в том, что вы в коде пишете вполне себе нормальный дженериковый вызов, который возможно бы с ahead-of-time компиляцией развернулся бы во что-то не очень эффективное, но если компилятор статически может доказать, что там в этом месте точно будет вызов определенного класса, ну так давайте сразу в момент компиляции подставим туда вызов нужного класса через вот эти интерсепторы.
2022.10 2023.10 "Игорь Лабутин" Атрибуты.
2023.10 2031.30 "Игорь Лабутин" Для того, чтобы это все заработало, нужно сначала эту штуку включить.
2031.30 2041.02 "Игорь Лабутин" Для этого нужно в css-projection вашем добавить property-group под названием features и добавить туда значение interceptors-preview.
2041.02 2045.30 "Игорь Лабутин" Эта штука, судя по всему, в 8-ом тутнете будет только в превью-варианте.
2045.30 2049.34 "Игорь Лабутин" Я не уверен, что до релиза они ее выпустят прям в релиз-врелиз.
2049.34 2050.54 "Игорь Лабутин" Скорее всего она останется в превью.
2050.54 2051.54 "Игорь Лабутин" Но поглядим.
2051.54 2054.46 "Игорь Лабутин" Может и до релиза успеют допинать.
2054.46 2063.94 "Анатолий Кулаков" Интересно, потому что когда они там только вводили генератор и все на них набрасывались с матюками, первое оправдание, которое они вводили, это то, что ничего меняться не будет.
2063.94 2065.74 "Анатолий Кулаков" Все будет предсказуемо, понятно, чисто, красиво.
2065.74 2071.82 "Анатолий Кулаков" То есть такой бронзовый у них вообще щит был, через который невозможно было пробиться, что ничего меняться не будет, только добавлять.
2071.82 2074.22 "Анатолий Кулаков" И на это все копии, естественно, ломались.
2074.22 2076.86 "Анатолий Кулаков" И тут вдруг бац, давайте теперь менять.
2076.86 2079.14 "Анатолий Кулаков" Прежде всего менять оперейки для существующих кодов.
2079.14 2081.62 "Анатолий Кулаков" Я бы понял, если бы они просто там добавлять как-нибудь.
2081.62 2083.38 "Анатолий Кулаков" Добавлять уже было, правда, да.
2083.38 2085.42 "Анатолий Кулаков" То есть им нужна была модификация.
2085.42 2090.82 "Анатолий Кулаков" Это явно и очевидно было во многих исшисах, которые люди писали и требовали какой-то модификации кода.
2090.82 2092.86 "Анатолий Кулаков" Но Microsoft яростно сопротивлялся.
2092.86 2098.14 "Анатолий Кулаков" И вот, наконец, пропозал дошел до какой-то финальной стадии, где мы можем посмотреть эти примеры.
2098.14 2100.38 "Анатолий Кулаков" Ну и здесь важно соблюсти баланс.
2100.38 2108.50 "Анатолий Кулаков" Потому что действительно, если этим будут пользоваться все подряд, то мы придем к тому, что у нас в коде написано одно, а в программе выполняется другое.
2108.50 2115.02 "Анатолий Кулаков" И как вот этот момент поймать, который преобразует одно в другое, будет практически нереально.
2115.02 2124.62 "Анатолий Кулаков" Вот нужно здесь интересно посмотреть, в общем-то, какие инструменты они придумали, какие техники, договоренности и так далее, чтобы вот это все не превратилось в жуткий ад.
2124.62 2137.54 "Игорь Лабутин" Ну, начать с того, что для того, чтобы это заиспользовать, кроме того, что эту фичу нужно включить, дальше же нужно каким-то образом указать, что вот если выполняется вот этот метод, нужно его заменить на вот этот новый код.
2137.54 2138.98 "Игорь Лабутин" Как ты думаешь, как это делается?
2138.98 2142.38 "Игорь Лабутин" Это делается самым лучшим способом, который можно было придумать в Sharpie.
2142.38 2144.74 "Игорь Лабутин" Возможно, это сделано не зря, а специально.
2144.74 2154.30 "Игорь Лабутин" Есть атрибут, то есть на том коде, которым вы будете заменять, эта функция, понятное дело, она должна по сигнатуре совпадать с тем вызовом, который вы хотите подменять.
2154.30 2157.10 "Игорь Лабутин" Вы вешаете атрибутик, который называется InterceptsLocation.
2157.10 2166.18 "Игорь Лабутин" И слово location тут как бы намекает, что вам нужно указать локейшн того метода, вызов которого нужно подменить.
2166.18 2175.70 "Игорь Лабутин" И location - это, да, это тот самый location, это путь к файлу, строчка в файле и номер символа в строчке.
2175.70 2180.70 "Анатолий Кулаков" То есть если строчка сдвинется, то все, надо идти и перерегистрировать интерцепт?
2180.70 2181.70 "Игорь Лабутин" Да, да.
2181.70 2192.22 "Игорь Лабутин" И именно поэтому, возможно, это сделано как раз специально, чтобы нельзя было это действительно, ну, грубо говоря, подменить какой-нибудь там DateTimeNow, да, поставив случайно на GetPacket с интерцептором.
2192.22 2200.58 "Игорь Лабутин" А они говорят, что это как раз из-за того, что сделано вот так вот через Location, эта штука подходит в основном для source-генераторов.
2200.58 2204.62 "Игорь Лабутин" То есть я так понимаю, целевое видение примерно такое.
2204.62 2219.42 "Игорь Лабутин" Мы делаем source-генератор, который генерирует какой-то более-менее общий употребительный код, который в среднем будет работать везде, native-out, не native-out, ну смотри выше, сколько мы там source-генераторов за сегодня обсудили новых.
2219.42 2236.82 "Игорь Лабутин" И для native-out мы знаем, что например, какой-нибудь там, не знаю, JSON, System Text JSON, сериализатор в source-генераторе вот в этом месте, точно, если мы точно знаем, что в этом месте к нам пришла, не знаю, структура, а не класс, то мы можем вызвать вот такую вот оптимальную функцию.
2236.82 2243.46 "Игорь Лабутин" И ты в дополнение к source-генератору пишешь еще интерцептор, который позволяет подменить.
2243.46 2248.38 "Игорь Лабутин" Не очень понятно, почему это не сделать сразу в source-генераторе, но это уже другой вопрос.
2248.38 2254.74 "Игорь Лабутин" Возможно, на source-генераторе у нас нет еще информации про то native-out это или native-out на самом деле, скорее всего из-за этого.
2254.74 2279.26 "Игорь Лабутин" Вот, то есть фича пока для меня довольно туманная, я еще не видел ни одной статьи, где кто-нибудь восторженно писал на тему того, что вау, смотрите, что мы с помощью нее натворили, пока как бы тишина и спокойствие, с нетерпением жду хоть какой-нибудь статьи на предмет типа о, мы теперь можем подменять что-нибудь.
2279.26 2292.74 "Анатолий Кулаков" Не, ну примеров там много, у всяких Foddy и PostSharp, они то не зря есть, то есть это out tools, которые умеют менять как раз таки код, переписывать или, и сообщество за многие времена придумало много хороших практических кейсов.
2292.74 2324.54 "Игорь Лабутин" Нет, смотри, зачем Foddy и как переписать или, я понимаю, мне непонятно связка вот этого точной указательной, то есть ты не указываешь там как-то в std или там namespace имя, что вот там все вызовы к dateTimeNow, да, Foddy ты бы наверняка напишешь, что вот смотрите, сделай так, чтобы все вызовы dateTimeNow у меня там, не знаю, возвращали на час меньше, такое в принципе ты можешь сделать, да, заменив вызовы на свою собственную как бы функцию, которая будет дергать внутри dateTimeNow и высчитать час, вот.
2324.54 2328.86 "Игорь Лабутин" А здесь вот прям конкретный специфичный метод в конкретной строчке.
2328.86 2332.94 "Игорь Лабутин" Я вот это пока не могу уложить в голове, почему именно такое решение было принято.
2332.94 2337.66 "Анатолий Кулаков" А тебе не кажется, что так как это самый первый превью, то это самый простой способ?
2337.66 2343.78 "Анатолий Кулаков" Вот сходи, Roslyn, распарься мне вот эту строчку и отдай мне там вот этот файл, и именно для этого указывай файл и строчку.
2343.78 2344.78 "Игорь Лабутин" Возможно, возможно.
2344.78 2348.82 "Анатолий Кулаков" А потом можешь допилить на что-то более вменяемое.
2348.82 2360.98 "Игорь Лабутин" Может быть действительно так, может быть потому, что если ты пользуешься Roslyn API, то это один из способов быстро достать какой-нибудь элемент синтексиса по этому адресу, ну по этому локейшену, и сказать, а вот теперь вместо этой ноды возьми другую ноду.
2360.98 2364.98 "Анатолий Кулаков" Да, это быстро, вот для первого превью самое то.
2364.98 2365.98 "Игорь Лабутин" Допустим, допустим.
2365.98 2369.66 "Игорь Лабутин" Ладно, будем ждать каких-нибудь следующих превью, не знаю.
2369.66 2376.18 "Игорь Лабутин" Разбор и андрю лока, хотя он, мне кажется, про C# в основном не пишет, так что может быть и от кого-нибудь другого дождемся.
2376.18 2381.18 "Анатолий Кулаков" Так, и это все, что у нас в 12-м C# там ждет?
2381.18 2388.50 "Игорь Лабутин" Да, на этом у нас все, в смысле не все на сегодня, но все с точки зрения новостей Дотнета от Майкрософт.
2388.50 2394.74 "Анатолий Кулаков" Ну ладно, давай тогда поговорим о чем-то более философском, более общем.
2394.74 2395.74 "Анатолий Кулаков" Как ты относишься к неймингу?
2395.74 2398.94 "Анатолий Кулаков" Есть ли у тебя проблемы с именованием?
2398.94 2433.30 "Игорь Лабутин" Бывает, то есть у нас, конечно, когда ты пишешь просто код, в основном проблемы с именованием с точки зрения перевода предметной области на английский, особенно если это предметная область исходная на русском, да, очень специфичная какая-нибудь, не знаю, медицина или бухгалтерия, да, вот на английский переводить, там, снилсы и вот это все, да, и понятно, что есть какие-то общепотребительные вещи, но есть очень специфические, особенно аббревиатуры на русском, к которым все привыкли, но плохо переводится.
2433.30 2440.74 "Игорь Лабутин" Это одна проблема, вторая проблема, с которой я сталкиваюсь, когда наоборот нужно назвать что-нибудь очень общее.
2440.74 2462.94 "Игорь Лабутин" Ну, ты знаешь, все эти хелперы, менеджеры, сервисы, да, ну вот такие общие штуки, общие субмогательные классы, которые вроде как относятся, с одной стороны к бизнес-области, с другой стороны, уже называть какого-нибудь четвертого не знаю, юзер-хелпер вроде как-то странно, а всех в один класс пихать вроде тоже странно.
2462.94 2466.18 "Игорь Лабутин" Ну, в общем, вот в таких местах начинают иногда возникать проблемы.
2466.18 2477.50 "Анатолий Кулаков" Ну, я обнаружил интересную статичку, интересную еще тем, что она на хабре, статья на русском, и написали ее наш коллеги из Dodo, которая называется "Делай нейминг как сеньор".
2477.50 2497.70 "Анатолий Кулаков" Хорошая статья, где как раз ребята делятся своим опытом, своей практикой, что у них получается, какие они техники используются для того, чтобы нейминг был понятным, и каждый разработчик, который вливался в компанию, он примерно как бы мог легко влиться в эту систему.
2497.70 2500.26 "Анатолий Кулаков" Давайте по порядку, чтобы не забегать вперед.
2500.26 2511.62 "Анатолий Кулаков" Итак, прежде всего нейминг - это часть архитектурной работы, то есть это реально, когда вы продумываете какую-то структуру классов, куда ее положить, как она будет займетись с Эцбаской, как она будет займется другими сервисами.
2511.62 2515.66 "Анатолий Кулаков" Вот нейминг - это как раз таки вот эта часть именно вашего дизайна процесса.
2515.66 2521.42 "Анатолий Кулаков" И это очень важно, в принципе, если вы хотите в будущем вырасти и стать большим толстым архитектором, то можете начинать уже сейчас.
2521.42 2531.34 "Анатолий Кулаков" Придумывайте правильные названия для ваших классиков и переменных, и это будет отличный первый шаг для того, чтобы стать умным бардатом архитектором.
2531.34 2543.22 "Анатолий Кулаков" И именование классов, и переменных, и структуры - они очень важны, потому что на самом деле из них вы потом будете, скорее всего, делать именно таблиц возле данных, именно событий, которые будут бросать в ваше приложение.
2543.22 2547.86 "Анатолий Кулаков" Также вы наружу будете выставлять какой-нибудь API, там REST, gRPC - не столь важно.
2547.86 2559.58 "Анатолий Кулаков" Но название этих API, название ресурсов, название роутов - скорее всего, будет браться как раз из нейминга изначальных переменных, изначальных классов, которые вы будете закладывать в основы вашего приложения.
2559.58 2567.70 "Анатолий Кулаков" И оттуда же пойдет и документация, и тест-кейсы для тестировщиков, и какие-нибудь страшные отчеты для ваших аналитиков.
2567.70 2571.66 "Анатолий Кулаков" Все это пойдет из тех названий, которые вы будете закладывать еще в самом начале.
2571.66 2579.34 "Анатолий Кулаков" И поэтому правильные названия, правильные имена, понятные, вливающиеся в правильную предметную область - это очень-очень важно.
2579.34 2597.86 "Анатолий Кулаков" И на самом деле нейминг - это то, насколько разработчик хорошо вник в предметную область, и как хорошо он ее понял, и как хорошо он потом ее представил для других разработчиков, для всех остальных, кто будет работать дальше с его классами и с его кодом.
2597.86 2615.62 "Анатолий Кулаков" Поэтому как раз глубина понимания предметной области и глубина проработки данной предметной области - она как раз и будет отражена в именах всех переменных, которые разработчик будет впоследствии использовать в коде.
2615.62 2623.58 "Анатолий Кулаков" Рассмотрим самые распространенные ошибки, которые, я думаю, каждый из вас находил в своих приложениях или в приложениях коллег.
2623.58 2626.42 "Анатолий Кулаков" Итак, что здесь было интересного?
2626.42 2630.06 "Анатолий Кулаков" Название переменных ничего не говорит о ее предназначении.
2630.06 2642.02 "Анатолий Кулаков" Я думаю, типичные перемены - это data, info, array, value, которые хочется назвать, которые встречаются часто в коде, и которые абсолютно непонятно - data или info - это к чему?
2642.02 2646.34 "Анатолий Кулаков" Что значение там хранится, или что мы там хотим хранить?
2646.34 2648.26 "Анатолий Кулаков" Здесь рекомендация одна - конкретизируйте.
2648.26 2652.18 "Анатолий Кулаков" Никаких data, value, info быть не может.
2652.18 2657.06 "Анатолий Кулаков" Старайтесь написать, что там именно должно храниться, что должно быть в этой переменной.
2657.06 2661.06 "Анатолий Кулаков" Следующая ошибка - это избыточные названия.
2661.06 2670.38 "Анатолий Кулаков" Например, когда добавляют тип переменной, ну не добавляют - таким образом отражают тип переменной в названии переменной.
2670.38 2672.34 "Анатолий Кулаков" Или избыточный префикс объекта.
2672.34 2676.38 "Анатолий Кулаков" Для тип переменной часто бывает daytime, например.
2676.38 2678.38 "Анатолий Кулаков" Переменная, которая называется editDateTime.
2678.38 2685.02 "Анатолий Кулаков" Ее можно просто переименовать в editAt и не отражать то, что она внутри себя хранит daytime.
2685.02 2689.30 "Анатолий Кулаков" Это понятно из контекста, из предлога.
2689.30 2702.82 "Анатолий Кулаков" И избыточный префикс - это тоже частая ситуация, когда мы используем, например, название bucketId вместо id поля, которое вложено в класс bucket.
2702.82 2704.54 "Анатолий Кулаков" Так очень часто еще раз повторено в SQL.
2704.54 2713.34 "Анатолий Кулаков" Из SQL, мне кажется, переехала в наш объектно-ориентированный мир, когда у нас есть user, и у юзера поле с идентификатором называется именно userId, а не просто id.
2713.34 2720.58 "Анатолий Кулаков" Такая избыточность тоже никакого смысла не имеет и часто дает лишнюю просто когнитивную нагрузку.
2720.58 2732.90 "Анатолий Кулаков" Переменная без контекста - это еще одна ошибка, например, когда переменную называют source вместо, например, lead source, когда state вместо country state, статус вместо employment status.
2732.90 2738.50 "Анатолий Кулаков" В общем, когда смысл переменной - статус, он не понятен, про что этот статус до тех пор, пока вы не заглянете внутрь.
2738.50 2744.02 "Анатолий Кулаков" Как только вы посмотрите на значение этого статуса, тогда будет уже понятно статус чего это, как он меняется и когда меняется.
2744.02 2746.34 "Анатолий Кулаков" В общем, и это проблема.
2746.34 2754.22 "Анатолий Кулаков" То есть вы должны понимать по названию переменной, что она внутри себя содержит без заглядывания в перечень ее значений.
2754.22 2756.42 "Анатолий Кулаков" Вот тогда это хорошее имя.
2756.42 2758.50 "Анатолий Кулаков" Следующая ошибка - это неправильный перевод.
2758.50 2766.78 "Анатолий Кулаков" Это, наверное, такие самые распространенные ошибки в русскоязычном сегменте, вот как ты говорил, когда мы боремся с языками.
2766.78 2782.70 "Анатолий Кулаков" Интересные примеры из как раз области пиццерии - это переменная, которая называлась travel most вместо transport type, driving вместо vehicle, walking вместо on foot, bicycling вместо bicycle.
2782.70 2790.46 "Анатолий Кулаков" То есть это способы доставки как раз тип транспорта, который доставляет товар, какую-нибудь пиццу, заказ.
2790.46 2807.86 "Анатолий Кулаков" И если русскоязычный пользователь, то он обычно очень легко может догадаться, что мы написали, но если у вас команда распределенная по миру или человек с базой на другом языке, то ему, скорее всего, будет трудно догадаться, что вы именно имели ввиду.
2807.86 2816.94 "Анатолий Кулаков" И это же немножко пересекается со следующим пунктом - это калька со своего языка, когда мы русскоязычными терминами пытаемся выразить англоязычные слова.
2816.94 2823.18 "Анатолий Кулаков" Тот же самый упомянутый enn, часто его прям так и пишут, и nn.
2823.18 2829.30 "Анатолий Кулаков" На самом деле его можно заменить на text identification number, это будет более правильный.
2829.30 2836.90 "Анатолий Кулаков" Или, например, medical book - это наша медицинская книжка, его можно легко заменить на health permit.
2836.90 2851.50 "Анатолий Кулаков" Preparation time - это уже больше калька с доминой области, это как время приготовления, но в данном случае ребята рассматривают пиццерию, и там это время готовки, то есть правильнее было бы использовать термин cooking time.
2851.50 2859.02 "Анатолий Кулаков" И вот так вот, интересный калька с языка, плюс неправильный перевод - все это порождает такие забавные довольные термины.
2859.02 2862.82 "Анатолий Кулаков" Дальше ошибка - это недостаточно точный термин.
2862.82 2870.34 "Анатолий Кулаков" Когда мы выражаем какое-нибудь среднее арифметическое или count, или еще чего-то, и не указываем чего.
2870.34 2880.38 "Анатолий Кулаков" Например, переменная avg waiting time, то есть мы в среднем ожидаем чего-то, и непонятно из названия переменной чего мы ждем, что нам нужно.
2880.38 2892.66 "Анатолий Кулаков" То есть правильнее эту переменную было бы назвать avg heated shelf time, то есть насколько мы ждем разогревания нашей тепленькой, горяченькой полочки.
2892.66 2897.06 "Анатолий Кулаков" И еще ошибка хорошая - это абстрактные названия.
2897.06 2908.38 "Анатолий Кулаков" Когда мы даем какое-то название, надеясь на то, что внутри нее может будет храниться какое-то что-то мега абстрактное и мега неопределенное.
2908.38 2911.78 "Анатолий Кулаков" Например, one per task rate.
2911.78 2915.70 "Анатолий Кулаков" Не очень понятно какой task и какого rate он там должен быть one.
2915.70 2922.86 "Анатолий Кулаков" И если ее переименовать, то на самом деле имелось в виду trips with one order count.
2922.86 2928.58 "Анатолий Кулаков" То есть это доставка с одним единственным заказом.
2928.58 2937.30 "Анатолий Кулаков" Так намного конкретнее и легче хотя бы по словам догадаться, что именно имелось в виду, что хотели засунуть в эту переменную или какое значение хотели бы туда положить.
2937.30 2940.78 "Анатолий Кулаков" Еще ошибка - это несколько вариантов для одного термина.
2940.78 2955.94 "Анатолий Кулаков" Здесь тоже часто распространенный случай, когда мы пытаемся подобрать какой-то англоязычный термин, не до конца понимаем контекст, в котором обычно англоязычные люди его используют и начинаем перебирать просто русские переводы.
2955.94 2961.22 "Анатолий Кулаков" Например, заведение.
2961.22 2965.98 "Анатолий Кулаков" Несколько названий, несколько переводов термина заведения было у ребят.
2965.98 2970.78 "Анатолий Кулаков" В частности, была пиццерия, ресторан, store и unit.
2970.78 2973.86 "Анатолий Кулаков" Выручкой у них был sales и revenue.
2973.86 2979.06 "Анатолий Кулаков" И даже такое узкое слово, как самовывоз, тоже не было однозначного определения.
2979.06 2981.90 "Анатолий Кулаков" Это был pick up, take away и carry out.
2981.90 2984.86 "Анатолий Кулаков" И все это на русский переводится как самовывоз.
2984.86 2993.46 "Анатолий Кулаков" И здесь тоже обычно можно легко найти правильный термин, если хорошо покопаться в конкретном бизнес контексте.
2993.46 2995.10 "Анатолий Кулаков" Но иногда это не так легко.
2995.10 3002.94 "Анатолий Кулаков" Иногда все-таки нужно договориться о чем-то одном и не пытаться доказать правду со всех сторон.
3002.94 3010.26 "Анатолий Кулаков" И последняя ошибка, которая встречается, это игнорирование конвенций нейминга языка программирования или в компании.
3010.26 3019.90 "Анатолий Кулаков" То есть, всегда нужно помнить, что у нас есть микрософтовские стандарты, которые предписывают нам использовать какие-нибудь Pascal кейсы, скобочки, кавычки и все такое.
3019.90 3029.62 "Анатолий Кулаков" Писать вы, конечно, можете как угодно, но если вы будете использовать общепринятые стандарты, то любому программисту, который приходит в вашу компанию, сталкивается с вашим продуктом, будет легче осваиваться.
3029.62 3041.54 "Анатолий Кулаков" Ну и также точно у компаний обычно есть свои гайдлайны, которые, я чаще видел, что они не переписывают микрософтовские, они именно дополняют какими-то своими более конкретными, более строгими требованиями.
3041.54 3047.50 "Анатолий Кулаков" Это как раз нужно для того, чтобы когда программисты переключались с одного проекта на другой, они чувствовали себя комфортно.
3047.50 3052.50 "Анатолий Кулаков" Они не видели, что они перешли там с одного языка практически программирования на другой.
3052.50 3058.94 "Анатолий Кулаков" Они могли примерно догадаться, что это работает одна компания, но они те же люди и у них примерные стайлы, тоже все одинаковые.
3058.94 3060.26 "Анатолий Кулаков" Этого тоже стоит придерживаться.
3060.26 3068.78 "Анатолий Кулаков" Итак, вернемся к нашему предыдущему утверждению, что нейминг - это прежде всего про понимание предметной области.
3068.78 3080.78 "Анатолий Кулаков" И если у вас есть проблемы с неймингом, есть проблемы с пониманием того, что вы пишете, зачем вы пишете и как, то, скорее всего, вы не допонили предметную область и стоит потратить время на более глубокую ее проработку.
3080.78 3090.30 "Анатолий Кулаков" Всегда нужно понимать, что плохой нейминг сейчас - это всегда работа, которая... то есть это технический долг по сути, это работа, которую вы оставляете на потом.
3090.30 3104.70 "Анатолий Кулаков" И каждый раз, когда вы будете исправлять этот код, читать этот код, дополнять этот код, вы будете делать это медленнее, потому что у вас будет тратиться больше когнитивных усилий для того, чтобы правильно работать с этим кодом, правильно его поддерживать.
3104.70 3111.18 "Анатолий Кулаков" А это значит, что будет увеличиваться вероятность ошибки, которые вы можете допустить.
3111.18 3115.98 "Анатолий Кулаков" Ну и поддержка будет занимать всегда больше времени и вам будет сложнее это делать.
3115.98 3119.26 "Анатолий Кулаков" То есть разработка будет медленнее и труднее.
3119.26 3128.38 "Анатолий Кулаков" И чем дальше вы будете запускать вот этот процесс с неправильным именованием, тем сложнее, медленнее и труднее вам будет в будущем.
3128.38 3136.66 "Анатолий Кулаков" Поэтому нейминг, он в принципе очень важен и желательно его делать прямо на самом старте, на самом этапе, потому что дальше все остальное будет абсолютно на него наслаивать.
3136.66 3140.70 "Анатолий Кулаков" Так как же рекомендуется нам выстроить работу с неймингом в команде?
3140.70 3144.62 "Анатолий Кулаков" Первым делом, прежде всего, нужно погрузиться в предметную область.
3144.62 3149.02 "Анатолий Кулаков" Для этого существует очень много различных практик.
3149.02 3159.10 "Анатолий Кулаков" Самая базовая там какая-нибудь адаптация, когда вашему сотруднику просто рассказывается, новому сотруднику рассказывается, чем мы все-таки занимаемся, что делает наша программа, с кем взаимодействуют.
3159.10 3168.18 "Анатолий Кулаков" И в этом процессе, когда мы просто рассказываем про программу, мы всегда будем использовать какие-то термины, которые уже приняты, уже состоялись в нашем команде, в нашем бизнес-процессе.
3168.18 3171.70 "Анатолий Кулаков" И это более-менее есть погружение в предметную область.
3171.70 3196.86 "Анатолий Кулаков" Есть и более глубокие технические средства, такие как Event Storming или разработка User Story Map, которые позволяют как раз-таки не только глубоко погрузиться, но и просто проработать весь бизнес-процесс настолько, что очень часто в Event Storming находят какие-то скрытые бизнес-процессы или скрытую терминологию, которую одни участники знают, а другие не знают.
3196.86 3206.78 "Анатолий Кулаков" Или какие-нибудь новые события, которые на самом деле полкоманды не знала, что происходит, что они нужны или что они будут именно в такой последовательности.
3206.78 3221.06 "Анатолий Кулаков" В общем, это техника, которая позволяет поднять самые глубинные знания, которые уже, может быть, на практике есть в вашей компании, но при этом многие члены этого процесса, взаимодействия этого процесса, о них даже не знали.
3221.06 3228.46 "Анатолий Кулаков" И для того, чтобы отразить это в коде, естественно, это нужно поднять, договориться, как-то зафиксировать и дальше уже использовать.
3228.46 3235.06 "Анатолий Кулаков" В общем, погрузка в предметную область - это самое главное, что вам нужно для того, чтобы давать правильные имена.
3235.06 3236.74 "Анатолий Кулаков" Без этого у вас ничего не получится.
3236.74 3243.42 "Анатолий Кулаков" Ну и естественно, чем глубже и сложнее предметная область, тем сильнее и тщательнее необходимо будет погружаться.
3243.42 3250.02 "Анатолий Кулаков" После того, как погрузились, вам необходимо зафиксировать словарь, то есть сделать, задекларировать и поддерживать некий словарь терминов.
3250.02 3252.98 "Анатолий Кулаков" В терминах DDD это называется Ubiquitous Language.
3252.98 3267.38 "Анатолий Кулаков" Для того, чтобы организовать вот этот словарь, зафиксировать, это тоже отдельный процесс, то есть отдельный венд какой-то, в котором собираются все участники процесса.
3267.38 3274.42 "Анатолий Кулаков" То есть начиная с разработчиков, тестировщиков и заканчивая бизнесом, экспертом, аналитикой.
3274.42 3276.50 "Анатолий Кулаков" То есть это реально вся команда, которая будет работать вместе.
3276.50 3281.34 "Анатолий Кулаков" Она должна выработать внутри себя тот единый язык, с помощью которого они будут в дальнейшем общаться.
3281.34 3295.78 "Анатолий Кулаков" Словарь такой состоит из сущностей, акторов, процессов, в области и связывает общую терминологию, с помощью которой теперь и разработчик, и тестировщик, и бизнес-заказчик могут разговаривать.
3295.78 3314.02 "Анатолий Кулаков" И в этот момент, даже когда вы еще не написали ни строчки кода, вы уже можете понять бизнес, какую фичу хочет и в терминах бизнес-сущности уже выразить, как вы будете ее реализовать и может быть даже сразу с бизнесом верифицировать, того ли он ожидает или не того же он ожидает.
3314.02 3325.78 "Анатолий Кулаков" Все это позволяет сделать единый язык, который тоже нужно создавать желательно на самом раннем уровне и дальше с помощью него уже общаться.
3325.78 3329.54 "Анатолий Кулаков" Как раз этот язык будет поддерживать синхронизацию ваших разработчиков и бизнеса.
3329.54 3344.94 "Анатолий Кулаков" Вы будете говорить на одном языке, будете чаще общаться, будете часто взаимодействовать и меньше, соответственно, осыпок будет между желаемым ТЗ, который вам выдают в бизнес, и имплементацией, которая у вас уже будет непосредственно на выходе.
3344.94 3348.02 "Анатолий Кулаков" Также желательно составить глоссарий бизнес-терминов.
3348.02 3366.42 "Анатолий Кулаков" И если Ubiquiti сленгвич, он в принципе уникален для каждого сервиса, по сути для каждого контекста, может быть для каждой команды, если у вас команда занимается каким-то конкретным сервисом одним, то глоссарий бизнес-терминов он должен быть един для всей компании.
3366.42 3378.78 "Анатолий Кулаков" И желательно сразу этот глоссарий делать вместе с английской терминологией, чтобы в различных сервисах, в различных командах примерно сводились к одним и тем же терминам, общим для всей компании.
3378.78 3397.82 "Анатолий Кулаков" И еще тут интересно, есть набор инструментов, то есть для того, чтобы такие правильные названия давать, вам недостаточно обычного Google Translate или Яндекс Транслейта, поэтому существуют отдельные интересные переводчики, которые, самая главная особенность у них это то, что они учитывают контексты.
3397.82 3405.54 "Анатолий Кулаков" Может быть кто-то из вас с ними уже сталкивался, это Multitran.com, World Hunt.ru и Reverso.net.
3405.54 3413.50 "Анатолий Кулаков" Это как раз инструменты, которые помогают вам с различных сторон переводить термины, но с учетом контекста.
3413.50 3425.74 "Анатолий Кулаков" То есть вы вбиваете там не просто слово, и он дает вам отдельный перевод, а вам расписывается контекст, где оно употребляется, фразы, каким образом оно употребляется, тематические словари, в которых оно присутствует.
3425.74 3433.26 "Анатолий Кулаков" Реверсо вам показывает там даже книги, фильмы, в которых настоящие герои в повседневной жизни употребляют эти слова.
3433.26 3439.70 "Анатолий Кулаков" То есть вы полностью окунаетесь в контекст, вся смысл вот этих инструментов всех это давание контекста.
3439.70 3451.26 "Анатолий Кулаков" После того, как вы составили бизнес словарик, рекомендуется его где-нибудь сразу прикрепить к реми про самого проекта, чтобы можно было удобно перейти, и каждый заинтересованный разработчик мог с этим словарем ознакомиться.
3451.26 3461.62 "Анатолий Кулаков" Также этот словарик не является каким-то там выбитым гранитом, его обязательно нужно поддерживать, актуализировать, но каждая актуализация и поддержка, добавление изменения должны проходить строгие ревью.
3461.62 3477.62 "Анатолий Кулаков" То есть у каждого словарика есть некий ответственный, который на своем уровне понимает четко бизнес домен, в который были все погружены, и который способен как раз четко рассказать, стоит это слово добавлять или не стоит, или в каком виде его переименовывать.
3477.62 3494.02 "Анатолий Кулаков" Переименовывание это отдельная большая боль, то есть если вы вдруг внедрили какой-то термин, и на вас завязалось сто тысяч других сервисов, контрактов и всего прочего, потом вы через 10 лет захотели переименовать, это будет очень-очень сложно, поэтому именами лучше заниматься с самого начала.
3494.02 3496.14 "Анатолий Кулаков" Скорее всего это даже будет невозможно.
3496.14 3499.58 "Анатолий Кулаков" Итак, практически советуем.
3499.58 3502.70 "Анатолий Кулаков" С чего же начать?
3502.70 3513.02 "Анатолий Кулаков" Если вдруг вы захотите дать какое-то определение, даже самым банальным нашим переменкам, которые есть в каждом коде, каждый день вы сталкиваетесь, как подойти к этому процессу.
3513.02 3524.38 "Анатолий Кулаков" Прежде всего рекомендуется начать с русского именования, значения, которые должны храниться в этом переменке, то есть как бы вы назвали это значение, как бы вы описали набор этих значений.
3524.38 3533.62 "Анатолий Кулаков" И рекомендация не старайтесь называть лаконично, назовите большим полным предложением, что там должно храниться.
3533.62 3544.14 "Анатолий Кулаков" После того, как вы большим предложением назовете, можете попробовать по контексту его перевести, и уже лишние слова отбросить, которые вы понимаете, что в данном случае они избыточны и не несут никакой дополнительной информации.
3544.14 3551.30 "Анатолий Кулаков" Таким образом, с помощью отбрасывания слов из полного предложения можно получить уже какое-то хорошее описательное название переменной.
3551.30 3552.82 "Анатолий Кулаков" Еще советы.
3552.82 3554.94 "Анатолий Кулаков" Явное лучше неявного.
3554.94 3560.58 "Анатолий Кулаков" То есть если вы даже всегда должны смотреть на код и представить, как будто видите его первый раз.
3560.58 3573.06 "Анатолий Кулаков" Или представьте, что прошел там целый год, вы переключались на другие проекты, уже полностью забыли, что здесь происходит, и вдруг вам нужно срочно поправить в этом месте, в котором вы только что объявляете переменную, срочно поправить код.
3573.06 3585.54 "Анатолий Кулаков" Возвращаетесь вы туда и вспомните ли вы все нюансы, которые вы в этом коде учитывали, все смыслы, которые вы вкладывали в то значение, которое будет храниться в этой переменной.
3585.54 3599.10 "Анатолий Кулаков" Сможете ли вы без перечитывания всей документации, без пересмотра всего использования переменной юзалой, сможете ли вы вспомнить, что в ней хранится, как это использовать, и не перепутаете ли вы с другими переменными в данном контексте.
3599.10 3602.18 "Анатолий Кулаков" Попробуйте на себе на эти вопросы ответить.
3602.18 3603.58 "Анатолий Кулаков" Следующая рекомендация.
3603.58 3606.90 "Анатолий Кулаков" Не стремитесь называть максимально коротко переменные.
3606.90 3615.10 "Анатолий Кулаков" То есть мы наверное уже отошли от того, что переменные называли одной буквой, я уже давно такого не встречал, надеюсь этого уже больше нет.
3615.10 3621.42 "Анатолий Кулаков" Но все же очень часто программисты стараются назвать переменные очень коротко.
3621.42 3626.10 "Анатолий Кулаков" Не надо забывать, что код вы пишете один раз, а потом вы будете тысячу раз еще читать.
3626.10 3636.82 "Анатолий Кулаков" Поэтому намного легче один раз написать, понятно, много, но потом, чтобы у вас когнитивная нагрузка на чтение и понимание была очень маленькая, чтобы вы это читали просто в лед.
3636.82 3640.50 "Анатолий Кулаков" То есть 3-4 слова для названия переменной это вполне нормально.
3640.50 3648.74 "Анатолий Кулаков" Не старайтесь писать это все в одно слово, обычно одно слово не сильно передает то значение, особенно в какой-то сложной логике, то значение, которое там хранится.
3648.74 3649.74 "Анатолий Кулаков" Дальше.
3649.74 3650.86 "Анатолий Кулаков" Одна переменная - одна цель.
3650.86 3658.10 "Анатолий Кулаков" Не переиспользуйте переменную только потому, что у вас случайно совпал тип, а вам эта переменная больше по скоупу не нужна.
3658.10 3664.66 "Анатолий Кулаков" Так делать не нужно, это путь, который ведет в ад и их множество ошибок.
3664.66 3666.90 "Анатолий Кулаков" Отрицание только усложняет.
3666.90 3670.86 "Анатолий Кулаков" То есть старайтесь не использовать отрицание в названиях переменных.
3670.86 3673.10 "Анатолий Кулаков" Переменная "недоступна" - это плохое название.
3673.10 3675.94 "Анатолий Кулаков" Хорошее название для него будет "доступ запрещен".
3675.94 3683.66 "Анатолий Кулаков" Когда вы будете оперировать с отрицанием, особенно если оно не будет у вас в условиях, то есть "if not" - "недоступно".
3683.66 3688.10 "Анатолий Кулаков" В общем, это все ведет к большим когнитивным нагрузкам и не делайте так.
3688.10 3691.26 "Анатолий Кулаков" Не усложняйте себе жизнь и коллегам на пустом месте.
3691.26 3693.34 "Анатолий Кулаков" Просто называйте всегда в позитиве.
3693.34 3695.62 "Анатолий Кулаков" Вырабатывайте единую структуру.
3695.62 3698.66 "Анатолий Кулаков" Договоритесь, но это больше о договоренностях внутри компании.
3698.66 3703.70 "Анатолий Кулаков" Например, использовать одинаковые суффиксы или одинаковые префиксы в определенных местах.
3703.70 3708.54 "Анатолий Кулаков" Такие как "count", "percentage", "total", "add", "name", "duration".
3708.54 3714.50 "Анатолий Кулаков" У вас должны быть четкое понимание, что хранится за каждым из этих стандартных префиксов или стандартных суффиксов.
3714.50 3718.74 "Анатолий Кулаков" Используйте глаголы или прилагательные для уточнения контекста.
3718.74 3721.86 "Анатолий Кулаков" "Added ingredients" вместо "просто ингредиентс".
3721.86 3725.46 "Анатолий Кулаков" "Late orders count" вместо "просто orders count".
3725.46 3736.10 "Анатолий Кулаков" В общем, если вы будете добавлять описательные какие-то глаголы или прилагательные, которые помогут вам раскрыть содержимое переменной, это тоже хорошо.
3736.10 3738.26 "Анатолий Кулаков" Это тоже даст больше понимания.
3738.26 3740.86 "Анатолий Кулаков" Стандартизируйте нейминг для времени.
3740.86 3743.34 "Анатолий Кулаков" Это действительно очень частая такая штука.
3743.34 3744.74 "Анатолий Кулаков" Это работа с датой и временем.
3744.74 3746.46 "Анатолий Кулаков" И каждый пишет там все, что угодно.
3746.46 3750.42 "Анатолий Кулаков" Влодь дат таймов, тайм спанов и так далее.
3750.42 3757.38 "Анатолий Кулаков" Например, хорошая рекомендация - это для событий использовать глагол в прошедшем времени плюс суффикс "at".
3757.38 3760.38 "Анатолий Кулаков" Например, "happened at", "started at".
3760.38 3765.02 "Анатолий Кулаков" Довольно хорошее номинование, понятно, что там внутри хранится, и суффикс довольно такой уникальный.
3765.02 3767.54 "Анатолий Кулаков" Можно понять, что там какое-то дато-время лежит.
3767.54 3773.02 "Анатолий Кулаков" И опирайтесь на словари, синонимов и значений.
3773.02 3777.22 "Анатолий Кулаков" Еще один хороший абзацик - это то, что же нам делать с легоси.
3777.22 3778.78 "Анатолий Кулаков" Конечно, все хорошо, если у вас новый проект.
3778.78 3787.22 "Анатолий Кулаков" Вы тут сели, потратили месяц на всякие EventStorming, вырабатку словарей и дальше пошли делать все как по накатанной.
3787.22 3796.58 "Анатолий Кулаков" Но что делать, если у вас есть легоси-проект, в котором имена уже устоялись, никто их менять не будет, как я уже сказал, 10 тысяч подписчиков, все завязано.
3796.58 3798.46 "Анатолий Кулаков" Здесь есть два варианта.
3798.46 3813.50 "Анатолий Кулаков" Прежде всего нужно смириться, что если проект находится на поддержке и сильно в него никто не вкладывается, то те инвестиции в переделку, в планирование и в переименование, которые вы туда можете вложить, они никогда не окупятся.
3813.50 3824.98 "Анатолий Кулаков" То есть здесь можно смириться и все-таки не использовать здесь правильные именования, а использовать так, как было изначально положено и оставить проект спокойно помирать на поддержке.
3824.98 3836.86 "Анатолий Кулаков" Если же у вас ситуация другая, проект активный, разрабатывается, у вас есть большие планы по его расширению, по его поддержке, то здесь стоит загнаться и сделать ему правильный нейминг.
3836.86 3846.26 "Анатолий Кулаков" Начать нужно, конечно же, из своего словарика, то есть составляйте словарь с единой терминологией, как мы обсуждали выше, а далее рекомендуется сделать фасад для нового кода.
3846.26 3856.06 "Анатолий Кулаков" Чтобы локализовать область, где остается старый нейминг и ее оставить жить, как она есть сразу, и через фасад использовать новый код.
3856.06 3868.18 "Анатолий Кулаков" И новый код уже будет работать с новым неймингом и с новыми названиями и постепенно приводить старый код к минимуму, переделывая на новые фасады.
3868.18 3881.26 "Анатолий Кулаков" Здесь рекомендуется, что каждый разработчик, который активно разрабатывает это активное приложение, может небольшими кусочками приходить и исправлять ту часть, где он сейчас работает, исправлять на новый нейминг.
3881.26 3891.54 "Анатолий Кулаков" И таким образом постепенно, без каких-то глобальных breaking changes вся команда перейдет на новый нейминг, особенно в тех местах, которые очень часто меняются.
3891.54 3903.70 "Анатолий Кулаков" И таким образом можно ваш Legacy проект, который страшный и некрасивый, безболезненно перевести на новую терминологию, которая будет консистентная, правильная и глубоко бизнес-доменная.
3903.70 3905.86 "Анатолий Кулаков" Это общими чертами.
3905.86 3906.86 "Анатолий Кулаков" Я побежал по статье.
3906.86 3911.50 "Анатолий Кулаков" В статье в самой есть больше интересных примеров, больше советов.
3911.50 3919.74 "Анатолий Кулаков" Ссылки, опять же, все тоже там есть на инструментарий, на какие-то еще находки ребят.
3919.74 3923.66 "Анатолий Кулаков" Поэтому переходите, читайте, ставьте лайки, плюсики.
3923.66 3924.94 "Анатолий Кулаков" Отличный материал.
3924.94 3928.74 "Анатолий Кулаков" Его должно быть больше, поэтому поощряйте хороших авторов.
3928.74 3938.26 "Игорь Лабутин" Да, действительно, неплохая статья с многими примерами и очень подробно разобраны как раз те моменты, про которые я говорил в начале.
3938.26 3944.18 "Игорь Лабутин" Про то, что очень часто непонятно, что делать с терминологией, особенно с русскоязычной, особенно с аббревиатурами.
3944.18 3948.30 "Игорь Лабутин" Придумывайте, пишите длинно и так, чтобы было понятно.
3948.30 3952.74 "Игорь Лабутин" Строчки кода экономить нам вроде как не нужно.
3952.74 3953.74 "Игорь Лабутин" Давай пойдем дальше.
3953.74 3957.90 "Игорь Лабутин" Дальше у нас еще есть немножко по TULAM новостей.
3957.90 3959.50 "Игорь Лабутин" Ну как по TULAM?
3959.50 3962.86 "Игорь Лабутин" Конкретно про Benchmark.net давно мы не вспоминали.
3962.86 3969.86 "Игорь Лабутин" TUL живет и развивается, там появляется много разных фич и он допиливается под новые версии.
3969.86 3980.86 "Игорь Лабутин" И одна из вещей, которые там есть, которыми вы, может быть, пользовались, если вы когда-нибудь запускали Benchmark.net, это диагностики или то, что в английском у них называется "diagnosis".
3980.86 3989.46 "Игорь Лабутин" Они позволяют посчитать, например, показать точнее вместе с результатом вашего бенчмарка, насколько активно там работал коробочек-коллектор или сколько памяти зааллоцировало.
3989.46 3998.58 "Игорь Лабутин" Или какую-то статистику по G2 посмотреть или узнать перформанс-метрики на основе Event Tracing for Windows.
3998.58 4004.58 "Игорь Лабутин" И вот теперь появилась новая добавочка, новый диагнозер под названием Dot Trace Diagnoser.
4004.58 4009.18 "Игорь Лабутин" И название как бы намекает, что эта штука позволяет вам действительно вызывать дот трейс.
4009.18 4011.14 "Игорь Лабутин" Что нужно сделать?
4011.14 4031.38 "Игорь Лабутин" Вы пишете бенчмарк, как обычно, навешиваете атрибут Dot Trace Diagnoser и Benchmark.net после запуска у вас сгенерит файлик с расширением DTP, Dot Trace Profile, которым будет лишать результаты, соответственно, снапшотики, профайлинг сессии того, как запускался ваш бенчмарк.
4031.38 4044.86 "Игорь Лабутин" Понятно, что вам нужен тул для того, чтобы открывать этот самый формат, сам запускалка, как бы она бесплатная и так далее, но тул вам нужен либо JetBrainsRider, либо сам Dot Trace, который входит в подписку DotUltimate.
4044.86 4050.70 "Игорь Лабутин" Но если они у вас есть, то вы можете открыть этот формат и посмотреть, как же ваш бенчмарк запускался.
4050.70 4066.90 "Игорь Лабутин" Если он вдруг внезапно тормозит, или медленнее, чем вы ожидали, или медленнее, чем референсная реализация, то, с чем вы сравнивали, а бенчмарк.net обычно используется для того, чтобы сравнивать разные реализации между собой, вы сможете сразу посмотреть, попробовать, по крайней мере, понять, в чем же, собственно, проблема.
4066.90 4075.02 "Игорь Лабутин" Есть, конечно же, и некоторые минусы, ну помимо того, что вам нужен Rider для Dot Trace, есть некоторые limitations.
4075.02 4084.86 "Игорь Лабутин" То есть это все работает на основе консольного плюс-минус консольной версии Dot Trace, и ограничения ровно те же самые, как и там.
4084.86 4098.10 "Игорь Лабутин" То есть там есть проблемы с ранними версиями, то есть вам нужен .NET Core 3.0 на Linux, или 5.0, или позднее, на MacOS, если у вас что-то раньше это работать не будет.
4098.10 4106.58 "Игорь Лабутин" Поддержан только Timeline Assembling Profiling, сейчас, насколько я помню, то есть никакого там line-by-line вы не получите и так далее.
4106.58 4124.66 "Игорь Лабутин" И поэтому, возможно, это не покроет вообще всех кейсов, и вам по старинке, если вам нужен детальный line-by-line профайлинг, вам придется писать все-таки какую-нибудь простую консольную приложение, которое вызовет тот же benchmark, но только в виде уже нормального приложения, обычного, и вы его оттрейтите, как обычно.
4124.66 4128.50 "Игорь Лабутин" Но DiagnoSphere, понятное дело, тоже штука полезная для каких-то быстрых вещей.
4129.50 4134.46 "Игорь Лабутин" Так что пробуйте, пользуйтесь, смотрите, что из этого получится и будет ли это помощь.
4134.46 4143.34 "Игорь Лабутин" Я не очень понимаю, насколько будет полезно для именно прям таких микробенчмарков, потому что там кажется, что сэмплинг там будет просто не успевать попасть в бенчмарки.
4143.34 4156.18 "Игорь Лабутин" Может не успевать, но бенчмарк .NET используется в том числе для довольно длинных операций, для которых занимают, возможно, секунды или даже минуты, и тогда там, конечно, профайлинг будет более чем актуален.
4156.18 4170.10 "Анатолий Кулаков" Да, в принципе, обычно, чем искать какую-то вторую или отдельную толзу, очень много людей использует, например, в интеграционных тестах бенчмарк .NET, и, в принципе, если правильно подойти к этому процессу, то тоже вполне возможно.
4170.10 4197.10 "Анатолий Кулаков" И там вот профайлинг очень хорошо себя показывает, и мы сейчас как раз, если мы вот этот лишний степ уберем, когда мы сначала попрофайлили, потом пошли, каким-то образом переделали entry point, и не так, сначала побенчмаркали, посмотрели, что есть проблемы, потом пришли, переделали entry point для того, чтобы хорошо это попрофайлить, если лишний вот этот шаг убрать, сразу получились намшоты, то, конечно, немножко времени экономится, и это приятно, конечно.
4197.10 4201.10 "Игорь Лабутин" Ну, давай дальше, у вас есть еще статья?
4201.10 4224.86 "Анатолий Кулаков" Да, я думаю, под конец можно такую статью, которая «Расширяй горизонты, взрывай мозг», и именно такую тему вбросил Марк Симон, называется она «Folders vs Namespaces», то есть папочки против пространства имен, и идея довольно интересная для того, чтобы ее хотя бы попробовать озвучить или поразмыслить над ней как-нибудь перед сном.
4224.86 4245.22 "Анатолий Кулаков" Началось все с того, что студент первого курса у Марка был, и учителя обычно, объясняя студентам программирование, рассказывают, что вы, товарищи, давайте используйте namespaces, но никто не рассказывает обычно, что namespaces в дот-нете, даже не в дот-нете, в C#, надо будет правильнее сказать.
4245.22 4253.34 "Анатолий Кулаков" Namespaces в C# обычно полностью соответствуют структуре папочек и полностью отражают один к одному папочки, в которых лежат файлы.
4253.34 4265.90 "Анатолий Кулаков" То есть фраза «идите и используйте namespaces» довольно очевидна для всех, кто пишет на C#, «идите правильно и дематично используйте namespaces», но, наверное, не очевидна для джунов, для тех, кто только знакомится с программированием.
4265.90 4269.54 "Анатолий Кулаков" И в C# дематично нужно делать именно так.
4269.54 4279.74 "Анатолий Кулаков" И на это даже есть статические анализаторы, хоть в ReShaper, в Ryder, хоть в Rust они сейчас все анализируют и смотрят, что действительно, давайте соблюдайте название папочек и название namespaces.
4279.74 4287.46 "Анатолий Кулаков" И вот один из студентов после очередного такого недопонимания пришел и сказал, а что если мы этой концепции продерживаться не будем?
4287.46 4288.46 "Анатолий Кулаков" Типа, что случится?
4288.46 4290.54 "Анатолий Кулаков" Что плохого или что хорошего?
4290.54 4325.74 "Анатолий Кулаков" И вот Марк решил подумать, а что действительно, если мы отойдем немножко от этой концепции и от типичной организации файлов, которые есть обычно в каждом солюшене, а по дефолту вот всякие темплейты, генераторы, студии и вообще какая-то дефолтная концепция у нас принята в том, что мы делим все наши папочки, называем по technical concern, то есть у нас контроллеры лежат в отдельной папочке, модели в отдельной, там, вьюшки, мапперы, дтошки, все это делится по технической составляющей, то есть по типу того, тех классов, которые находятся внутри этой папочки.
4325.74 4335.46 "Анатолий Кулаков" И этот подход мы в принципе довольно сильно критикуем и считается неверным среди просвещенных бардачей, но сейчас не про это.
4335.46 4343.18 "Анатолий Кулаков" Сейчас мы рассматриваем то, что все эти папочки, которые у нас есть, они являются отражением дерева файловой системы.
4343.18 4354.42 "Анатолий Кулаков" Файловая система по определению своей, это иерархия, это дерево, также можно его назвать ацикличным графом, у которого нет, у которого соответственно нет циклов никаких.
4354.42 4362.02 "Анатолий Кулаков" То есть это значит, что каждый вертекс этого графа, у него есть только один парам, только один родитель.
4362.02 4377.78 "Анатолий Кулаков" То есть это значит, что если вы поместили контроллер в папочку с контроллерами, то вы не сможете больше этот контроллер, класс контроллера поместить, например, в папочку с календарями, несмотря на то, что это у вас был календарь-контроллер.
4377.78 4380.74 "Анатолий Кулаков" По идее он должен относиться и туда, и сюда.
4380.74 4383.98 "Анатолий Кулаков" Но что произошло, если бы вы могли бы такое сделать?
4383.98 4395.34 "Анатолий Кулаков" И на самом деле вы в принципе можете, потому что пространство имен, они как бы отвязаны от иерархии того дерева, который представляет файловая система.
4395.34 4414.22 "Анатолий Кулаков" То есть если вы решите игнорировать вот эту конвенцию, если вы на нее забьете, и решите немножко отступиться, то вы можете сделать следующий трюк, что у вас появляются папочки, это одно измерение, и у вас появляются namespaces, и это абсолютно другое, это второе измерение, которое вы можете добиться.
4414.22 4426.90 "Анатолий Кулаков" То есть вы можете организовать, например, в папочках всю иерархию по technical concern, а в namespaces вы можете всю иерархию сделать по feature concern.
4426.90 4436.06 "Анатолий Кулаков" То есть как раз-таки объединить в namespaces одни и те же фичи внутри одного и того же namespaces, неважно где они лежат.
4436.06 4441.58 "Анатолий Кулаков" То есть контроллер вместе с DTO, вместе с маппером, вместе с конвертером и вместе с валидатором, они будут лежать в одном namespace.
4441.58 4444.18 "Анатолий Кулаков" У вас такой получится vertical slice.
4444.18 4458.94 "Анатолий Кулаков" И таким образом вы можете и в файловой системе, в solution explorer, смотреть на один разрез, и в namespace explorer смотреть абсолютно на другой разрез, тех же самых ваших файликов, которые вам будут удобнее.
4458.94 4469.10 "Анатолий Кулаков" Марк такую штуку проверил, о всех его эмоциях, которые он при этом испытал, я призываю вас почитать самостоятельно, потому что здесь близкое каждому свое.
4469.10 4478.34 "Анатолий Кулаков" Ну и качестве из отравочки могу предсказать, что он все-таки остался при своем мнении, что на самом деле никакие иерархии не нужны, это все от лукавого.
4478.34 4495.02 "Анатолий Кулаков" И плоская структура всех файлов, когда они свалены просто в рутье сборки, это самый идеальный способ хранения всей вашей иерархии, всей вашей структуры файлов, ее теперь невозможно назвать иерархией, всей вашей структуры файлов и всех ваших классиков.
4495.02 4506.86 "Анатолий Кулаков" Почему он так решил, где это хорошо, какие плюсы, какие минусы, опять же призываю вас ознакомиться самостоятельно, потому что здесь больше такой философский диалог с собой, чем какие-то публичные полезные рекомендации.
4506.86 4507.86 "Анатолий Кулаков" Все ссылки будут в шоу-ноутах.
4507.86 4517.66 "Игорь Лабутин" А главное, что если вы такое будете использовать, то смотрите выше про нейминги, вот это все, есть некоторые стандартные принятые практики, вот это все.
4517.66 4529.18 "Игорь Лабутин" И когда какой-нибудь другой разработчик забредет на ваш проект и увидит такое, ну не знаю, может быть это будет понятно и очевидно, но я бы удивился поначалу.
4529.18 4535.82 "Анатолий Кулаков" Ну скорее всего да, это эксперименты на ваших хобби-проектах, не старайтесь тасить это в компании.
4535.82 4553.78 "Игорь Лабутин" Хорошо, давай последняя тема, кратко о разном, которая у нас традиционно в конце, сегодня не очень много всего, а именно новый экстенджен для Visual Studio вышел экстенджен, пока это превью-версия, но звучит многообещающе, а именно это экстенджен под названием MS Build Editor.
4553.78 4600.62 "Игорь Лабутин" То есть если вы редактировали MS Build файлики вручную, а это CES-пронши и все связанные с ними, то возможно вам не хватало какого-нибудь хорошего интеллисенса, так вот теперь этот экстенджен позволит вам иметь интеллисенс, квик-инф, валидацию, код фиксы, рефакторинги, а он автоматически тащит схему из всех импортнутых зависимостей, но более того, если у вас есть какой-то ваш очень специфичный MS Build файлик, не знаю, в общих библиотеках, нугетах или еще где-то, в которые вы хотите разметить дополнительные информации, то это тоже можно сделать, он поддерживает внешнюю разметку, видите, отдельный JSON файлик со схемой, и в общем выглядит прям такой, ну еще не LSP, не ленгвистер для MS Build, но что-то очень близкое.
4600.62 4611.42 "Игорь Лабутин" Пока, к сожалению, только для Visual Studio, я бы наверное ожидал, что для Visual Studio код вышел бы вообще идеально, но даже в Visual Studio уже приятно это дело поредактировать.
4611.42 4625.78 "Игорь Лабутин" Я пока сам не пробовал, но точно себе поставлю, я думаю, потому что MS Build редактировать приходится, и IntelliSense там будет точно полезен, а еще рефакторинги, хочется посмотреть на рефакторинг, там экстракт метод в MS Build, выглядеть наверное будет интересно.
4625.78 4651.34 "Игорь Лабутин" Так, вторая новость, это про графаном, я говорил сегодня в новостях про SPNet, что довольно много всего сейчас происходит про метрики, и в частности у Джеймса Ньютон Кинга появился такой репозиторий про графан и темплейты, потому что если у нас есть метрики, метрики складываются наверняка в какой-нибудь там Prometheus или что-то подобное, и их нужно визуализировать.
4651.34 4661.82 "Игорь Лабутин" Визуализируем мы в среднем в графане, и чтобы вам каждый раз не создавать ваш дешборд с нуля, у вас теперь есть темплейтик от команды по сути Microsoft.
4661.82 4671.66 "Игорь Лабутин" Джеймс сам пишет, что я не очень понимаю пока официальный статус, будет ли это так же в личном репозитории, или это как-то переместится в официальный Microsoft.
4671.66 4696.54 "Игорь Лабутин" Короче позиция Microsoft по этому вопросу пока непонятна, но тем не менее есть два дешборда, один дешборд это такой overview, общие метрики для здоровья вашего приложения, а второй дешборд это более детальные метрики по конкретным endpoints, которые позволяют посмотреть насколько эти endpoints живы, как там все, как я говорил сегодня вышло, кешируются, не кешируются, rate-limited-ся, еще что-нибудь, ошибки какие вы схахиваете и так далее.
4696.54 4708.06 "Игорь Лабутин" Так что используйте в качестве вдохновения при составлении ваших собственных endpoints, ну и способ посмотреть как работать с метриками, которые вам продюсит S Pen на приложении.
4708.06 4716.78 "Игорь Лабутин" И последняя третья новость, ссылочку на нее нам, даже не на новость, а собственно на YouTube канал, про который мы хотим рассказать, принесли нам наши патроны в чатик.
4716.78 4744.42 "Игорь Лабутин" Это YouTube канал про C#, про программирование на C#, Internet, S Pen, вот все вокруг этого, англоязычный, от товарища-разработчика из Англии, United Kingdom, который почему-то проходил вообще мимо меня, я никогда не видел его, хотя каналу как минимум год, с достаточно большим количеством подписчиков, порядка 60 тысяч, ты говорил, Толь.
4744.42 4753.42 "Анатолий Кулаков" Да, да, там больше 60 тысяч, ну и темы такие довольно разнообразные, и попсовые есть, и узкие, и глубокие, прям много интересного.
4753.42 4791.54 "Игорь Лабутин" Да, все это организовано в разумно выглядящие плейлисты, то есть если вы хотите про авторизацию, вот вам плейлист, если вы хотите какие-то типа паттерны на C#, вот вам другой плейлист, видео достаточно короткие, ну там типа полчасовые, да, где-то 10 минут, какие-то полчаса, там все не смотрел, поэтому точно статистику не скажу, понятный английский хороший, так что если вам интересно более глубоко разобраться в каких-то темах, то есть например мне понравился плейлист про авторизацию и аутентификацию, кажется, что там довольно хороший разбор, начиная от теории до деталей того, как это программировать, конкретно в S/P/Nine на C# довольно современно.
4791.54 4795.62 "Игорь Лабутин" Так что если интересно поизучать что-то, можно заглянуть.
4795.62 4800.82 "Игорь Лабутин" Ну и наверное на этом на сегодня у нас все.
4800.82 4806.14 "Анатолий Кулаков" Скорее всего да, давай посмотрим, что мы сегодня просмотрели, пообсудили.
4806.14 4821.50 "Игорь Лабутин" Посмотрели, пообсудили мы DotNet 8 превью 6, говорят по слухам, что превью 7 будет последним превью, пока это слухи, посмотрим, и потом пойдут уже релиз кандидаты, так что ждем не дождемся каких-нибудь новых фич.
4821.50 4860.94 "Игорь Лабутин" Посмотрели, чем отличается новый Slim Builder от обычного Web Application Builder и что там отсутствует, узнали какие фичи хотя бы немножко появятся в 12-ом C#, узнали как правильно называть ваши переменные и методы и вообще объекты любые в коде, как к этому подходить, выяснили, что бенчмарк DotNet теперь позволяет не только митчмаркет, но еще и профилировать с помощью dottrace, порассуждали на тему, как раскладывать файлики, нужно ли соблюдать структуру namespaces и фолдеров, или можно все-таки их раскладывать независимо, ну и посмотрели какие-то мелкие новости в концепте, как мы обычно это и делаем.
4860.94 4899.54 "Анатолий Кулаков" Ну и также я напоминаю, что грядет большая московская конференция DotNext, на которой встретятся все специалисты крупнейшие, русскоязычные, для того, чтобы обсудить все самые прекрасные интересные темы, а также приглашаем всех и других специалистов, и тех, кто мечтает стать специалистами, и будущих спикеров, и нынешних спикеров, в общем всех встретиться, затусить, как мы делали это всегда раньше, и прекрасно отметить очередную веху, очередной будущий релиз DotNet, который будет LTS, поговорить что же интересного там появится, обсудить технологии.
4899.54 4908.74 "Анатолий Кулаков" Если вы еще не купили билетик, то в шоу нотах вас ждет специальный промокод для всех наших слушателей на хорошую скидку, поэтому тоже не забывайте.
4908.74 4910.02 "Анатолий Кулаков" Теперь точно все?
4910.02 4913.02 "Игорь Лабутин" Да, теперь точно все, можно прощаться.
4913.02 4921.70 "Анатолий Кулаков" Ну закругляемся тогда, шарьте, репосты, комментируйте, все это вы знаете, не забывайте слушайте радио, радио DotNet.
4921.70 4923.18 "Анатолий Кулаков" Всем пока, до новых встреч.
4923.18 4923.78 "Анатолий Кулаков" Всем пока.
