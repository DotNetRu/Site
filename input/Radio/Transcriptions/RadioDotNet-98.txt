0.00 81.12 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net и выпуск номер 98. В студии, как всегда, постоянный ведущий Анатолий Кулаков. И Игорь Лабутин, всем привет. И за нашими спинами бравая армия наших помогаторов - Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Бальсим Альджавахири, Андрей Маслов, Дмитрий Павлов и Постарнаков Андрей. Друзья, всем большое спасибо за то, что помогаете, особенно тех еще, кого мы не назвали. Интересно, когда список перевалит по продолжительности дольше, чем наш подкаст, что мы будем делать? Ну, говорите, всем спасибо, до следующего выпуска. Вы прослушали самую главную часть. Ну, мне кажется, из-за такого летнего количества тем, которые нам сейчас раздает Микрософт, самым интересным скоро будет это список бравых людей в нашей необъятной, потому что Микрософт молчит. У него там или летний отпуск, или там всех разогнали, или может, действительно, готовят какую-нибудь лиркичу, фичу. Но что-то со спайром единственная новость наша сегодня от Микрософта, да?
81.12 101.52 "Игорь Лабутин" Да, не сказать, чтобы мы в этом подкасте ждали бы новостей только от Майкрософта. В принципе, мы рады любым новостям из мира .NET, но, действительно, и статей как-то не очень много, и новостей, собственно, о каких-то релизах мало. Но, действительно, вышла новость. Вышла она, на самом деле, довольно давно, просто у нас тут был легкий перерыв на отпуска.
101.52 107.04 "Анатолий Кулаков" Ты не думаешь, да, что программисты просто любят отдыхать летом? Мы как бы все расходимся.
107.04 149.64 "Игорь Лабутин" Ну, как я и говорю, да, мы как раз с подкастом разошлись немножко с тобой на небольшой отпуск, и поэтому как раз и все остальные, видимо, почувствовали, что некому будет рассказывать о новостях, и пока ничего не делают. Никаких новостей не пишут. Ну, посмотрим. Давай расскажем, что произошло на самом деле с эспайром. Напомним, что в мае этого года внезапно для всех зарелизился дотнет эспайр 8, ну, мы ждали, собственно, релиза вместе с полноценным релизом девятки в ноябре, видимо, но они что-то решили, что давайте в середине года под конференцию Microsoft Build, Build же, наверное, был как раз, они сделали релиз эспайра. Ну, сделали-сделали, мы, по-моему, про него должны были, по идее, рассказывать, сейчас не помню сходно,
149.64 155.16 "Анатолий Кулаков" но, наверное, рассказывали. А в июле… Ну, был у нас про релиз, конечно, мы же не могли бы такую
155.16 175.92 "Игорь Лабутин" тему пропустить. Ну, мы, на самом деле, про все превью кусочки рассказывали, и, скорее всего, в релизе ничего супер инновационного не было, просто собрали аккуратно все из превью. А в июле вышло обновление, релиз тоже 8.1, никакой не превью, а полноценный релиз, в котором появилось некоторое количество фич новых, ну, и исправления, понятное дело, про которые мы сейчас и расскажем.
175.92 180.84 "Анатолий Кулаков" А тебе не кажется, что они к ноябрю как раз эспайр 2 выпустят, если у них уже 8.1 там пошел?
180.84 192.28 "Игорь Лабутин" Может быть, может быть. Нет, эспайр действительно как-то развивается. Сейчас мы увидим, что он развивается не только в сторону дотнет, а вообще для других экосистем тоже, так что, может быть, к ноябрю что-нибудь интересное увидим, посмотрим.
192.28 240.56 "Игорь Лабутин" А пока начнем с простой штуки. Много кто просил, что если у меня есть эспайр проект, но я не хочу его запускать, например, не знаю, в кубернетосе или еще где-то, я хочу его запускать просто в докер файле, ну, в смысле, в докер композе, например. Вот можно ли так? В принципе, можно. По-моему, это было делать через aspirate. Можно было из него, с помощью него, заэкспортить манифест вашего приложения в том числе в формат некоего докер-докер композ файла, но все-таки это немножко не то, и поэтому в эспайр добавили, так сказать, first-class support этого дела. Ну, это понятно, что все равно экстенджин какой-то. Тем не менее, теперь у нас есть возможность собирать эти самые докер-файлики. Делается это с помощью...
240.56 245.92 "Игорь Лабутин" Композ-файлики, да? Нет, именно докер-файл, прикинь.
245.92 253.04 "Игорь Лабутин" Ну окей, рассказывай подробности. То есть у них есть два новых экстенджин-метода.
253.04 275.60 "Игорь Лабутин" Один экстенджин-метод называется add_docker_file. И вы его используете в том случае, если вы из вашего компонента в будущем будете создавать докер-имидж, который потом куда-то там пушите и для чего-то использовать. У вас в аутпуте будет докер-файл. По идее, все компоненты эспайра – это
275.60 280.52 "Анатолий Кулаков" в том или ином виде элементы кубернета, то есть они по-любому в докер будут упаковываться.
280.52 285.76 "Анатолий Кулаков" А что значит если? Где ситуация, когда он не будет в конце концов докером в кубернетесе?
285.76 301.32 "Игорь Лабутин" Оно, конечно, будет докером в кубернетесе, но я, так понимаю, исходно предполагалось, что это все было скрыто. Вы не видите докер-файла, вы просто говорите, что вот у меня есть один компонент, он зависит от другого компонента, а тут еще SQL-сервер есть, а тут вот Redis какой-нибудь.
301.32 305.24 "Игорь Лабутин" И все это прозрачно деплоит в кубернетес, вы вообще не паритесь с никакими докер-файлами именно.
305.24 309.48 "Анатолий Кулаков" То есть это может быть возможность более тонкой настройки через докер-файл?
309.48 332.64 "Игорь Лабутин" Да, да-да-да. И вот addDockerFile у вас добавит возможность сборки этого докер-файла, а есть еще withDockerFile. И это нужно для кастомизации докер-файлов. То есть, например, вы можете сказать builder.addSqlServer, ну это давно можно было сделать, и у него сказать withDockerFile и указать путь. И тогда у вас подтянется SQL-сервер, используя нужный докер-файл.
332.64 338.24 "Анатолий Кулаков" У тебя же SQL-сервер уже упакован в докер-файл какой-то, да? То есть это уже как докер-имейш распространяется.
338.24 357.00 "Игорь Лабутин" Ну да, но ты можешь, например, подменить ему какой-нибудь run. Ты же можешь сейчас на основе имиджа SQL-сервера написать докер-файл, где будет написано fromSqlServer, как он называется, докер его образ, fromSql что-нибудь, там run, и там свою кастомную команду, например, выполнить.
357.00 361.40 "Анатолий Кулаков" Ты имеешь ввиду пронаследоваться, грубо говоря, от докер-файла этого и его переопределить
361.40 438.16 "Игорь Лабутин" в какие-то там параметры. Ну да. Теперь это можно сделать типа EC#. То есть, ну как бы, без необходимости писать докер-файл руками. А можно это сделать EC#. Туда можно передать build-аргументы, туда можно передать переменные. То есть, если вы в докер-файлике, если, точнее, докер-файлик, который вы будете использовать, уже declared какие-нибудь аргументы с помощью конструкции arg, то можно будет их передавать через EC#. Ну короче, там, поскольку я не пробовал, не могу сказать точно, где там заканчиваются EC# и начинаются реальные докер-файлы, и сколько нужно писать реальных докер-файлов, и можно ли написать, например, какой-нибудь супер-кастомный докер-файл, наследующийся от SQL, и именно с помощью него его подкладывать, когда мы говорим "хочу вот здесь вот addSqlServer". То есть, вся остальная настройка будет от Espire, а вот сам докер-файл, который надо запустить, он будет с мой. Ну, скорее всего, можно в пределе такое сделать, ну, либо собрать его, значит, из кусочков через C#. Короче, если нужна тонкая настройка вокруг докер-файлов, вот, пожалуйста, теперь есть. Вторая часть к .NET не относится вообще никак, это метод расширения, называется addPythonProject. Звучит неплохо.
438.16 458.60 "Игорь Лабутин" Теперь можно... у них написано, что у них есть, так сказать, желание увеличить поддержку, улучшить поддержку Polyglot Microservice Architectures. То есть, когда у тебя в твоем продукте есть как бы кусочки на питоне какие-то, есть кусочки, собственно, .NET, может, еще на чем и так далее.
458.60 483.00 "Игорь Лабутин" Поэтому теперь можно сказать addPythonProject. Для этого, понятно, нужно заиспользовать отдельный пакет, называется espire.hosting.python. И после этого в addPythonProject вы туда передаете название, вы туда передаете путь к вашему питончику, к папочке, где лежит питоновый код, и имя питоновского файлика, где, собственно, main, грубо говоря. И он будет запускаться, когда надо.
483.00 493.48 "Анатолий Кулаков" Тут интересно же, что в отличие от .NET, у питона нет какого-то общепринятого проекта или входной точки, то есть там каждый лепит все, что захочет, зависит от редактора, зависит от команды,
493.48 561.56 "Игорь Лабутин" зависит от страны, от чего угодно. Да, но, значит, там как минимум даже у питона есть несколько всяких разных способов поставить себе окружение и вот это все. Здесь у них четко написано, что это все построено на virtual environments, которые vn и не поддерживается пока автоматическая установка зависимости, то есть сказать там pip install -r requirements нужно руками пока еще. Но, по крайней мере, если вы это сделали, то дальше оно через vn само найдет, каким питоном это все запустить и запустит. Более того, если в этих requirements.txt, ну это зависимости, у вас есть штука, в смысле конструкционный пакет, модуль, модуль, наверное, который называется OpenTelemetry.dfist.distro, ну и он же либо от LP, еще там бывает суффикс, то тогда он попробует запустить вот этот вот Aspire, попробует запустить питонский проект с нужной инструментацией, то есть передавая всякие нужные переменные окружения или аргументы, и телеметрия будет видна в Aspire дэшборде автоматически. Короче, пытаемся принести крутой детонетный тулинг,
561.56 568.28 "Анатолий Кулаков" в том числе во всякие сторонние экосистемы. Ну это хорошо, это правильно. Чтобы полуавтоматически
568.28 616.40 "Игорь Лабутин" работало. Также к релизу добавилось некоторое количество ресурс типов и компонент. Напоминаю, что вот эти все методы решения типа addPythonProject, addSqlServer, addRedis, add какой-нибудь там kafka.ui, вот это все, это все просто экстенджент-методы, которые должным образом меняют модель данных вашего вот этого solution, да, как это сказать-то, модель, внутреннее, короче, представление вашего продукта. И добавили некоторое количество новых типов, а именно добавили поддержку кейклога, то есть если вы хотите, можно запустить теперь локальный кейклог, просто сказав addKeyClog, ElasticSearch, Garnet и Valkey, это короче аналог Redis, и то и другое в каком-то смысле, kafka.ui, ну и там ажурные несколько кусочков тоже добавили. Если интересно, посмотрите.
616.40 676.04 "Игорь Лабутин" Дальше. В тестировании тоже некоторые улучшения появились. Есть теперь новый метод, называется WaitForResourceAsync, который позволяет попроще написать тесты, ну потому что иногда вам нужно подождать, когда какой-то из компонентов поднимется. То есть вы в тесте, я напоминаю, в Aspire довольно развеситая система тестов, которая позволяет тестировать эту самую модель, да, поднимая какие-то кусочки всего приложения, и вот иногда нужно подождать, пока что-то поднимется, прежде чем, например, записать там в базу какие-то начальные данные. Вот теперь есть прям специальный метод WaitForResourceAsync, который дождется, пока конкретный ресурс, по мнению Aspire, не поднимется окончательно. А также до недавнего времени в Aspire была только поддержка XUnit, но теперь добавили NUnit и mstest для желающих, так что теперь там, я так понимаю, полноценная поддержка всего, чего только можно. Дальше. В метрике, ну метрики в Aspire поддержаны, понятно, все хорошо, все нормально, но теперь добавили еще штуку под названием экземпляры метрик.
676.04 717.08 "Игорь Лабутин" Это вообще экземпляры, это кусочек OpenTelemetry стандарта, и эта штука, позволяющая вам в момент, когда вы репортите метрики, в конкретный таймстэмп добавить какую-то, ну условно тег какой-то повесить, да, или какую-то экстра, экстра данные к этому конкретной метрике. Эта штука используется как раз для того, чтобы слинковать метрики к этим самым, к трейсам. То есть в момент, когда у вас есть HTTP-реквест, если вы, например, инкризите метрику, сколько у вас там обработано HTTP-реквестов, в этот момент вы к этой метрике можете отослать текущий обрабатываемый HTTP-реквест. Ну и таким
717.08 733.68 "Анатолий Кулаков" образом как-то что-то, с чем-то смачить. Ну и, например, на графике метрик, если он будет визуализироваться, этот маркер, на графике метрик теперь вы можете чпокнуть по этому маркеру и перейти уже на график Distributed Tracing в этот момент. То есть это вот такая связь между различными
733.68 796.80 "Игорь Лабутин" телеметриями получается. Да, он поддержан, это поддержано пока только на графике гистограммы распределения, но, возможно, еще добавят. Но оно уже поддержано, точечки показываются, кликнуть можно, все перейдет. И мы, по-моему, мы в прошлом или позапрошлом подкасте рассказывали про штуку под названием SpanLinks. Это когда разные спаны можете склеить, ну точнее не склеить, а слинковать друг с другом, и Spar теперь поддерживает эту визуализацию на трейсинге распределенном. И теперь можно по этим ссылкам туда-сюда ходить. То есть если у вас есть линк, на этом он подсвечен как будто это линк, на него можно кликнуть, перейти в соседний трейс, где, соответственно, эти спаны, ну слинкованные, тоже отображаются. Вот как-то так. То есть, в общем, ну такие довольно практическ, практичные, как сказать, практичные, в общем, изменения, вполне полезные. Ну я не знаю, я там не собираюсь добавлять какой-нибудь Garnet, но, в целом, появление там тех же CakeLog'ов и Python'а или может кому-то и докерфайлы будут интересны, вполне интересно. Так что кажется, что тут вроде, ну, minor release вполне по делу.
796.80 815.88 "Анатолий Кулаков" Да-да, вроде развитие хорошее, при том несколько таких ключевых компонентов было законтрибучено с помощью комьюнити. То есть там, кажется, тоже жизнь какая-то налаживается, жизнь растет. Поэтому развивается хорошо. После релиза все не умерло, как бы после релиза продолжает команда работать, наверняка у нее есть планы, ну и посмотрим, чем она нас удивит еще
815.88 821.60 "Игорь Лабутин" в ноябре. Я думаю, должна. Я очень на это надеюсь. А пока давай пойдем дальше.
821.60 825.72 "Игорь Лабутин" У нас есть продолжение от Джимми Богорда. Наконец-таки у него вышло еще пара статей.
825.72 829.48 "Анатолий Кулаков" Ну, не просто пару статей, а пару статей по нашей теме, которые мы давно отслеживаем.
829.48 865.00 "Анатолий Кулаков" Я уже не помню, когда вышла первая часть, но... А, для начала, да? Для начала это серия статей о том, как он мигрировал свой проект. Мы уже записали две части. Вторая часть была в выпуске в 90-м, поэтому если для вас тема актуальна, в общем, советую очень послушать. Джимми портирует старый легаси-проект с Entity Framework'а на новый Core. Ну, относительно новый, да, если мы говорим про Entity Framework. К сожалению, очень много еще проектов. Мы разбирались там статистику в прошлом году. До сих пор еще больше 50% используют .NET Framework. И никуда мы от этого пока не делись.
865.00 940.48 "Анатолий Кулаков" Поэтому мне кажется, что статья, которая рассматривает практически аспекты миграции, они довольно нужны и полезны. Поэтому если вдруг у вас есть приложение на большом фреймворке, на старом фреймворке, и у вас есть какие-то там ресурсы, планы, бизнес-идеи, чтобы его портировать, то вот серию Джимми Богорда крайне рекомендую к ознакомлению. Потому что он как раз таки прагматично хорошо рассказывает, как что переносить, как это сделать бесшовно. То есть сервис они не останавливали, они это все делают на рабочих данных, постепенно выкатывая релизы в новом сервисе и убирая какие-то фичи старого сервиса. Так называемый шаблон-душитель. То есть все это проходит, и он как раз по этапам, по компонентам разбирает, какие вещи переносили. Некоторые вещи, которые у них используются там, допустим, не очень интересны, там какая-то специфика, специальный фильтр, еще что-то. А некоторые вещи, такие как, например, аутентификация, какие-нибудь кэширование, опять же, тот же самый паттерн-душитель они очень хорошо рассмотрят, они довольно интересны, довольно прикольны. И вот сегодня мы подобрались к третьей части. Напомню, что вторая часть - это эпизод 90. Если кому интересно, можете сгонять посмотреть. В третьей части мы с вами познакомимся с еще двумя его статьями. И первая статья нам расскажет о том, как они переносили аутентификацию.
940.48 972.74 "Анатолий Кулаков" Довольно важный слой, и у каждого уважающего себя приложения оно должно быть. И самое плохое, наверное, в этом подходе, что Microsoft очень долго не мог стабилизировать аутентификацию. То есть вот этот, тот же самый ISP.NET Core Identity, он не то чтобы недавно появился, он недавно стабилизировался. То есть он был довольно давно, но всегда там были то ли какие-то огрехи, то ли какие-то баги, то ли вообще им никто не пользовался, то ли никем не поддерживался. В общем, стандарта такого, чтобы можно было обновить библиотеку и сказать все, его долгое время не было.
972.74 1048.36 "Анатолий Кулаков" Сейчас у нас есть ISP.NET Identity, то есть такой стандартный подход к аутентификации, авторизации и прочим токенам, и там довольно все хорошо. Но когда мы говорим про старый фреймворк, естественно, было не так. Давайте уже посмотрим, что там было. Ну, во-первых, в вашем приложении может быть, опять же, что-то свое, так как стандарта не было. Например, если вы использовали какой-нибудь внешний Single Sign-On сервис, с помощью Google, с помощью Яндекса, с помощью ВКонтакта, логинились, то для вас, в принципе, никаких изменений не будет, вы просто меняете клиент, обновляете, скорее всего, просто клиент на новую версию, и все, никаких проблем нет. У Джимми ситуация была, наверное, самая сложная, которую только можно представить. У старого фреймворка команда написала свой собственный менеджер аутентификации, авторизации, свой собственный токен-валидатор, в общем, все собственное у него вообще было свое, и никакого ISP.NET Identity не использовалось, потому что версия какая-то в тот момент тоже была, они вполне могли бы ее поиспользовать, я просто думаю, что им ничем это не помогло, потому что та версия, которая сейчас в Core, она вообще никак не совместима с тем, что было. Поэтому, может, не так все и плохо. Поэтому у него был выбор практически переписывать все с нуля.
1048.36 1071.32 "Анатолий Кулаков" Какие требования ставились при переходе? Во-первых, хочется, чтобы пользователь мог залогиниться и на старом, и на новом приложении. Для контекста, кто предыдущие серии не помнит, у него используется паттерн-душитель, это значит, что у него есть старое приложение, которое крутится на .NET 4.8, и новое приложение, которое крутится на .NET 8, на .NET Core 8.
1071.32 1146.28 "Анатолий Кулаков" И постепенно он переносит часть функциональности старого в новое. И вот перед ним стала задача переносить аутентификацию. Все запросы идут в новое приложение, если новое приложение не находит какой-то функциональности у себя, оно перенаправляет запрос просто-напросто в старое приложение, которое точно также в бэкграунде крутится. Если оно эту функциональность у себя находит, то оно обрабатывает запросы, старое приложение не получает ничего. Таким образом, постепенно перенос фич позволяет нам все меньше и меньше делать нагрузку на старое приложение, и все больше и больше делать нагрузку на новое приложение. И где-нибудь там в конце он должен старое вообще выключить и выкинуть, и все постепенно перенести в новое. Если мы говорим про перенос аутентификации, да, что должно происходить? Ну, во-первых, пользователь должен уметь логиниться. Он должен залогиниться независимо от того, есть это фича на старом или на новом приложении, он должен уметь логиниться всегда, и хоть на старом, хоть на новом. Оба приложения должны понимать, что пользователь залогинился и должны понимать, что он аутентифицировался и что он авторизовался. То есть у него должны быть какие-то права, клеймы, роли, имена, токены, вот это все. И также пользователь должен уметь разлогиниваться, несмотря на то, на каком приложении его функциональность основная.
1146.28 1353.80 "Анатолий Кулаков" Здесь можно пойти двумя путями. Первый - это Remote Authentication. Это стандартный подход, когда мы логинимся на старом сервисе и при этом все данные о логине, о том, какой пользователь, какие у него роли, просто-напросто запрашиваем в новом сервисе. Этот подход мы уже делали, когда обсуждали Session Sharing, по-моему, да, когда мы говорили про сессии, как мы мигрировали в сессии, мы точно таким же подходом использовались. Мы не захотели шифровать и декриптовать сессии на новом приложении, поэтому мы использовали старое как такое удаленное хранилище. Второй подход, к которому можно было пойти, это Sharing Cookie. То есть вся информация о том, какой пользователь залогинит, какие там у него роли, какие принципы, она хранится в куках. И в принципе, эти куки можно было бы читать как в новом приложении, так и в старом приложении и беспрепятственно ходить туда-сюда и без всяких проблем. Но в куках он нашел некое ограничение. Он утверждается дословно, что метод с Shared Cookies работает только с Microsoft Avin Cookie Authentication. Я точно не понимаю, что он имеет в виду, но, скорее всего, у него подключены какие-то middleware, которые обрабатывают эти куки, и эти куки уже, то есть эта middleware, она уже настроена на какой-то формат, и этот формат в его старом фреймворке отличается от того формата, который он ожидает в новом фреймворке. Он, конечно, мог бы написать там какой-нибудь свой собственный читатель Cook, как-нибудь это прокинуть в Authentication Middleware, но, наверное, этот подход показался какой-то слишком сложным. Поэтому из коробки он быстро этого сделать не смог и решил этим путем не идти. Также у него была проблема с Shared Cookies с тем, что куки хранятся в зашифрованном виде, и для того, чтобы их расшифровать, необходимо сделать Shared Data Protection. То есть это общие ключи шифрования, к которым доступ есть и у старого приложения, и у нового приложения. Ну, в принципе, это делается несложно, там буквально нужно реализовать один интерфейсик, там XML Data Protection Provider, и брать эти Data Protection можно откуда угодно, хоть из сети, хоть из базы данных, хоть откуда угодно. Но, наверное, опять же, тоже он решил, что этот способ слишком трудоемкий, и поэтому он решил остановиться на втором подходе. Он решил сделать Remote Authentication, то есть удаленную аутентификацию. Как это делается? Как я уже говорил, когда приходит запрос на логин, этот запрос перенаправляется на старое приложение. В старом приложении пользователь логинится, так же, как он логинился и раньше. А новое приложение с помощью специального адаптера, который отправила пользователя аутентифицироваться туда, просто-напросто забирает у старого приложения всю информацию о пользователе, который у него есть, ну, в частности, все его клеймы, и заполняет локального идентити, то есть локальную информацию об аутентификации, заполняет этими клеймами, которые она получила из старого приложения. Самое прекрасное, что, в принципе, под это под все, Microsoft уже написал все необходимые компоненты, все необходимые методы. Так как мы уже заюзали прекрасную библиотеку System Web Adapters, эта библиотека создана для того, чтобы сделать процесс миграции как можно более бесшовным. И мы эту библиотеку использовали для того, чтобы как раз добавить Remote Application, то есть тот сервер, из которого мы будем переходить.
1353.80 1400.72 "Анатолий Кулаков" Поэтому, благодаря этой библиотеке, в старом приложении мы добавляем всего-навсего одну строчку кода "Add Authentication Server", в новом предложении мы добавляем одну строчку кода "Add Authentication Client", и таким образом мы получаем в новом приложении клиента, который умеет перенаправлять аутентификацию на старый сервер, а в старом сервере мы получаем сервер, который умеет обрабатывать аутентификацию и отдавать все необходимые клеймы обратно этому клиенту. И клиент уже знает, что с ними сделать. Он уже знает, что он должен автоматически заполнить все клеймы, которые пришли из старого ISPnet в новый ISPnet Core. Естественно, у этих методов очень много настроек, потому что аутентификация - это обычно штука сложная, и поэтому вы можете клейм-трансформейшны настраивать, какие-нибудь токены передавать, какие-то адреса менять, редиректы подставлять.
1400.72 1459.84 "Анатолий Кулаков" В общем, все это тоже есть в опциях данной библиотеки. Поэтому делается все довольно легко и просто. Действительно, глядя на эти две строчки, понятно, почему он не захотел реализовать свой собственный Shared Data Provider и прочие кастомные аутентификационные хендлеры. Потому что этот способ у Microsoft проработан достаточно хорошо. Тут нужно понимать, что он не переделал у себя аутентификацию. Он ее отдал на аутсорс, грубо говоря, старому приложению. И в тот момент, когда он перенесет все и будет отключать старое приложение, вот в этот момент он у себя в новом ISP Network приложении просто-напросто с нуля напишет хорошую понятную аутентификацию. А старый уже тогда погасит, так как ему не нужна будет совместимость, то в принципе с этим проблем никаких не будет. Но в данный момент перехода это довольно хорошее, понятное и прагматичное решение. Вторая статья рассказывает нам о том, как мы переносили Middleware. Тут не то чтобы много откровений, но давайте вкратце пройдемся.
1459.84 1466.08 "Анатолий Кулаков" Во-первых, Middleware есть очень много и они бывают очень разные. Не все из них нужно переносить.
1466.08 1499.22 "Анатолий Кулаков" Например, очень большая часть, которые, например, системные стандарты Middleware, они такие же точно системные стандартные, но их аналоги есть уже в Core. То есть нужно понимать, кто из них что делал и нужно ее эмулировать, нужно ли переносить или просто нужно найти какой-нибудь хороший аналог. Основные места, где хранятся у нас Middleware могут храниться, это WebConfig, Global ASACS и Awin Startup. У меня прям old school свело, потому что этих названий уже давно не слышал, но да, кто с .NET Framework возится, наверняка про них не забудет аниме и во сне снятся.
1499.22 1545.00 "Анатолий Кулаков" Так, погнали по порядку. WebConfig. В WebConfig у нас обычно очень много всяких настроек. Мы там настраивали раньше, как хандятся всякие ошибки, как конфигурируется приложение, как конфигурируется сервер, то есть где слушать, какие редиректы там есть. Все это раньше было в WebConfig. И вот это как раз тот самый момент, когда там обычно хранились какие-то стандартные Middleware. Практически все, что там есть, оно имеет какой-то свой аналог в Kestrel. Вам нужно четко понимать, как там настраивались эти конфигурации, зайти в настройки Kestrel Options или куда-то вот возле них и все это поперенастраивать, если у вас там есть какие-то кастомные сложные настройки.
1545.00 1572.26 "Анатолий Кулаков" Например, там у Энри был Custom Error Redirect в SPX страницы, которые он очень легко портировал на стандартные Custom Error ISP.net Core страницы. То есть раньше, когда мы хотели по какой-то ошибке редиректироваться на специальную страницу, допустим, что у вас 404 был красивеньким с какой-нибудь вашей умной картинкой, нужно было писать какую-то заглушку, какие-то хаки, какие-то что-то еще.
1572.26 1582.80 "Анатолий Кулаков" В общем, в современном Kestrel у нас есть специальный урлык, который мы подставляем и мы редиректимся туда на любые ошибки, на любые там какие-то сложные ситуации, на любые какие-то кастомные хейдеры.
1582.80 1677.60 "Анатолий Кулаков" Все это легко делается, но нужно понимать, что, где и как подкручивать. В общем, с этой секцией мы примерно разобрались. Теперь у нас есть ISP.net MVC Middleware. Обычно они находятся в Global ASAXE, и там обычно лежат некие фильтры, которые пронаследованы от Action Filter Attribute. То есть это те как раз фильтры, которые запускаются возле самого ISP-движка. В общем, поэтому они такие ценные, потому что у них есть очень много полезного контекста. И в данном случае у Эндрю тоже там было несколько фильтров, которые кастомные были написаны. Там не суть важно, какое их содержимое, главное, как он их переводил. В отличие от старого фреймворка, теперь их нужно наследовать не Action Filter Attribute, а от интерфейса iAsync Action Filter. В общем, мы пронаследовали, это тот же самый, то есть это эквивалент атрибутам, которые были раньше. Пронаследовали, у них есть такие же методы, такие же контексты, вообще все остальное тоже самое. И перенесли в новое приложение. С этим, в принципе, справились. Дальше у нас идет секция Awin Middlewary. Это классы, которые обычно помечены атрибутом Awin Startup. По дефолту у нас такой класс один, и назывался этот класс Startup. В этом стартапе обычно находились всякие регистрации, но потенциально можно было с помощью атрибута таких классов сделать много. У себя Эндрю там нашел SignalR, Handfire и специальную настройку аутентификации. Про Handfire и аутентификацию мы говорили выше в предыдущих выпусках, смотрите.
1677.60 1731.28 "Анатолий Кулаков" А SignalR, в принципе, переносится индивидуально. То есть у нас есть SignalR Core, там аналогичные настройки все есть. Регистрации немножко отличаются, поэтому все, что можно сделать, это просто-напросто завести новый SignalR, настроить его, как рекомендуется настраивать именно новый SignalR, посмотреть какие тонкости были в старых конфигах и эти тонкости все перенести в новые. Никаких проблем с этим нет. Тут важно отметить, что вот эти компоненты, которые здесь лежат, они обычно требуют индивидуального подхода. То есть Handfire мы переносили там по одному принципу, SignalR мы переносим по другому принципу. То есть это тут сложно дать какие-то универсальные какие-то рекомендации. Здесь уже вам нужно смотреть на конкретные примеры. Ну вот Эндрю привел два хороших примера. Это SignalR и Handfire. Аутентификация тоже как хороший пример отсюда. То есть он показал, что здесь можно сделать и как здесь можно мыслить.
1731.28 1819.80 "Анатолий Кулаков" В принципе, с этой секцией больше все, потому что она полностью зависит от ваших настройок, от того, что ваше приложение дальше использовалось. Она не очень критична, но здесь очень важно, как раз во время переноса, да, очень важно не сломать то поведение, которое было раньше. Именно поэтому мы так тщательно и так индивидуально подходим к каждому компоненту. Потому что, если у вас там написана какая-то бизнес-логика страшная, например, у Эндрю один из фильтров был фильтр, который открывал транзакцию в начале любого HTTP-реквеста в базе данных и закрывал транзакцию в конце любого HTTP-реквеста. Казалось бы, медлеварь такая спорная, может быть, ее нужно было переделать, может быть, ее нужно отменить, может быть, нужно было сделать как-то по-другому. Но тот бизнес-код, который уже написан в этом приложении, он рассчитывает на эту транзакцию, он без нее точно работать не будет. И поэтому, опять же, мы говорили в самом начале, когда начиналась эта серия, у нас нет задачи отрефакторить и сделать идеальное приложение. У нас есть задача перевести на новый фрамворк. Поэтому он взял эту медлеварю, этот экшен-фильтр, переписал его на новый интерфейс, оставил там для совместимости все точно так же. Ну, единственное, конечно, что немножко преобразил код, потому что раньше он был совсем ужасный, а теперь он нормальный, то есть сделан красиво, с контейнерами, со скопами и так далее. Но смысл остался тот же самый. И он его перенес. То есть он сохранил поведение. Это очень важно, потому что вы не тратили потом еще целый год на ловя бизнес-ошибки, а что же там такое отвалилось.
1819.80 1840.40 "Анатолий Кулаков" Ничего отваливаться не должно. Платформы должны быть на 100% совместимы. Уже когда перенесем, вот тогда уже будем причесывать. А пока вот так. На этом очередные два шага эндрюпового переноса закончились. Будем ждать следующей серии. Если у вас перед вами стоит такая же точная задача, серию статей, рекомендую, обязательно знакомьтесь. Ну да, ты пока рассказывал столько
1840.40 1864.40 "Игорь Лабутин" всяких старинных слов произнес, про которые я уже даже и забыл. Да, оказывается, были даже, чинили же, искали же. Да вообще. Но действительно, серия статей очень хорошая. Прям в отличие от таких, знаешь, коротеньких статей и вида, как можно сделать что-то и побежать дальше, здесь прям такой основательный гайд на тему того, как полноценный большой продукт перевести со всеми,
1864.40 1874.84 "Анатолий Кулаков" ну, костылями. Куда уж без них. Ну, этим он отличается. Потому что, знаешь, когда обычно статьи пишут, напишите, ну, запустите мигратор, он вам обычно там все-все промигрирует.
1874.84 1909.52 "Анатолий Кулаков" Да нет, обычно он как раз-таки везде сломается. И когда начинаешь реальное приложение переносить, вот очень часто возникает вопрос, а как? Именно поэтому у нас очень часто, допустим, на митапах, на конференциях, пользовались популярностью доклады, а как мы переезжали. То есть, во время переезда было, ну, очень популярны они. Потому что у людей на практике возникают абсолютно не те проблемы, которые описывают маркетологи в своих статьях. Там совсем другие проблемы. Вот как здесь написал кто-то, какой-то странный медаль Варри, что с ним дальше делать, непонятно как бы. Автор умер, библиотека не поддерживается, а все, кто знал про это хоть что-то, давно уволились. Именно с такими ситуациями обычно люди как раз и сталкиваются. Им про
1909.52 1966.40 "Игорь Лабутин" такие ситуации интересно слушать, если вы переезжаете. Ну да. Окей, пойдем дальше тогда. Дальше у нас Andrew Look с очередной серией статей, которую он писал довольно долго. Это 5 статей про Collection Expressions. Ой, ну да, Collection Expressions, все правильно. Я что-то задумался про Collection Initializers, но я не ошибся, потому что Initializers мы тоже рассмотрим по пути. Это новая фича C# 12, которая уже вполне себе выпущена и работает. Позволяет вам теперь вместо того, чтобы писать разными странными способами литералы коллекций, которых в общем-то и не было у нас раньше в C#, теперь позволяет писать литерал коллекций, которые хитрой магией компилятора приводятся к разным всяким коллекциям по мере необходимости. И статья последовательно рассматривает, что это, как это, зачем это, как это работает внутри и во что самое интересное генерится вся эта магия под капотом.
1966.40 2048.44 "Игорь Лабутин" И поэтому давайте пробежимся по порядку. Я не буду, как я обычно, это дисклеймер, как обычно, я не буду прямо детально рассказывать про все пять статей, потому что там довольно много кода, и диктовать код, особенно который генерится компилятором, это то еще удовольствие, но основные идеи постараюсь рассказать. Начнем мы с доисторических времен, как же мы жили без Collection Expressions. Иногда коллекции нужно чем-то инициализировать, ну довольно каким-то, не знаю, фиксированным списком, строчек там, не знаю, чисел, еще чего-то в вашем коде. И в принципе у нас такой способ был, то есть можно было допустим написать new list от стринга и дальше в фигурных скобочках перечислить элементы, которые туда нужно добавить. Это называлось Collection Initializer, и фактически, фактически приводило к тому, что у вас создавался пустой список, это компилировалось в вызов пустого конструктора, и дальше сколько вы элементов указали между фигурными скобочками, столько раз будет вызван метод add. И фактически эта штука работала необязательно там на листах или еще на чем-то, она как у нас иногда встречается в C#, она была, так скажем, то что называется ducktyping сделана. Если у вас есть коллекция, точнее тип любой, у которой реализуют innumerable и имеют метод add, а также пустой конструктор, вы прекрасно могли
2048.44 2052.92 "Анатолий Кулаков" этой штукой пользоваться. Как у нас положено в строго типизированных языках, у нас полно
2052.92 2057.64 "Игорь Лабутин" ducktyping. Да, ну не полно, ладно уж, не так уж много мест у нас, где есть ducktyping, но он есть.
2057.64 2066.28 "Анатолий Кулаков" Ну вот если устроить кивис, прям можно много назвать. Вспомни там те же самые foreach, innumerable, dispose, initializers, вот эти те же самые. Ну прям можно, можно.
2066.28 2121.72 "Игорь Лабутин" Да, да. Для массивов, соответственно, было немножко побольше вариаций. Можно было написать new string от чиселки какой-то, 4, 5, 6, размерность, и дальше в фигурных скобочках элементы. Можно было не указывать тип, можно было даже не указывать количество элементов, поскольку их фиксированное количество. Но это все тоже компилировалось в довольно очевидную конструкцию, это просто разворачивалось в присваивание через индексер, да, то есть там массив от нуля присвоит значение, массив от единички присвоит значение, ну и так далее. И третий, самый, наверное, редкий кейс, с которым вы сталкивались, а может большинство и не сталкивались, это stackalloc. Там тоже можно было initialize с фиксированным массивом. Я ни разу этого не делал, кстати. Конструкция выглядит для меня довольно интересно, это выглядит как stackalloc, пробел, квадратные скобки и дальше в фигурных скобках набор элементов, и это все компилируется в некоторую магию указателей, там звездочка и звездочка, вот это все со смещениями, ну как положено. Так а это не то же самое
2121.72 2128.00 "Анатолий Кулаков" синтакси, что и с массивами? Что тебя удивило-то? Там нет new. Да, вместо new stackalloc. Ну,
2128.00 2162.28 "Игорь Лабутин" типа того, да. В этом смысле не удивило, но просто я никогда не писал, я как-то не задумывался, как это должно выглядеть для stackalloc. Давай так, мне никогда не требовался stackalloc с фиксированным инициализатором. То есть обычно у меня stackalloc это какие-то временные небольшие массивчики были, и для них я просто размерность указывал, и все. Как-то так сложилось у меня, что не встречалось. Теперь у нас есть collection expressions. Это штука, которая позволяет точно так же написать список элементов, только не в фигурных скобочках, а в квадратных. И в этом
2162.28 2167.28 "Анатолий Кулаков" случае мы теперь можем… Ну все, разница закончилась, всем до свидания. Ну можно теперь не писать
2167.28 2188.04 "Игорь Лабутин" new, можно не писать размерность, можно не писать квадратные скобки, если вы присылаете это все в массив перед инициализером, вы просто пишете ваш тип, там массив, лист, redundancy span, что хотите присвоить. Квадратные скобки открыли, набор элементов записали через запятую, квадратную скобку закрыли, точку с запятой поставили, все. Вы молодцы. А я правильно понимаю,
2188.04 2191.88 "Анатолий Кулаков" что все-таки нужно писать тип явно слева, то есть я вар уже всегда не могу заюзать?
2191.88 2210.60 "Игорь Лабутин" Да, я про это скажу. Ага, окей. Где-то я про это собирался говорить, но я про это сразу скажу. Да, действительно, вар туда писать нельзя, потому что непонятно, собственно, что получится. Технически, технически можно было бы сказать, что если и слева, и справа непонятно что, то это будет там,
2210.60 2214.32 "Анатолий Кулаков" не знаю, лист. Ну типа да, самое частое. Давайте лист, и все счастливы.
2214.32 2245.28 "Игорь Лабутин" Вот, ну или массив, поскольку он может быть там, не знаю. Ну короче, видимо не решили, поэтому решили, что не будем усложнять, пока вар писать нельзя. Дальше, соответственно, синтаксис абсолютно идентичный для всех инициализаторов, это удобно. И, в принципе, местами можно получить некоторый прирост производительности. Не то, чтобы мы сильно много теряли на производительности при инициализации каких-то статических вот таких вот штук, потому что, как правило, количество элементов там невелико, но все же может быть полезно.
2245.28 2366.48 "Игорь Лабутин" Значит, как же быть с интерфейсами? Значит, если вам, например, нужен какой-нибудь, не знаю, IEnumerable, который проинциализирован на фиксированной коллекции элементов. Раньше вам нужно было слева написать IEnumerable что-нибудь, например, но справа вы все равно должны были выбрать тип. Будет это массив, будет это лист, будет это еще что-нибудь. Но тип нужно было выбрать, собственно, что будет под этим IEnumerable. Теперь вы просто пишете IEnumerable что-нибудь, присвоить квадратные скобочки, ну и набор элементов внутри. И все, компьютер сам выберет, что вам туда подсунуть для реализации IEnumerable. И что он туда выберет, я расскажу чуть позже. В принципе, теперь один из моментов, про который Эндрю говорит, что штука вот эта вот вся с CollectionExpressions она полезная, она чуть-чуть облегчает рефакторинг в том плане, что если вы передаете такую коллекцию как аргумент функции, просто прям явно в вызове функции вызываете функцию от некого CollectionExpressions, вы теперь можете спокойно менять тип аргумента этой функции. Хотите IEnumerable, хотите лист, хотите что угодно. У вас не поменяется вызывающая сторона с точки зрения совместимости исходного кода. Там все будет продолжить работать. Так, и да, с пустыми коллекциями. С пустыми коллекциями ситуация следующая. Раньше мы, если вам нужна честная пустая коллекция, можно было всегда написать new и квадратные скобочки от нуля. Но это не очень хороший вариант, потому что все равно аллазируется пустой объект. А для неизменяемых коллекций, которые вы все равно не можете изменить, например, массив, вы не можете массив нулевой длины превратить во что-то другое. Зачем его рождать миллионами, допустим, единиц, если у вас это на каком-то горячем пути. Нужно было использовать статический метод под названием array.empty, который возвращал всегда один и тот же экземпляр.
2366.48 2375.56 "Игорь Лабутин" Ну а для листов, например, если вы знали, что у вас есть листы, которые вы точно не будете модифицировать. Ну у нас, например, в продукте частенько мы просто делали такой хелпер типа
2375.56 2381.76 "Анатолий Кулаков" empty list в таком духе, который также использовали. Ну да, у нас тоже, который реализует array.empty,
2381.76 2393.60 "Игорь Лабутин" например. Сейчас можно просто использовать пустые квадратные скобки, и комбинатор сам выберет максимально подходящую, так скажем, альтернативу. Слушай, а вот это интересно,
2393.60 2397.16 "Анатолий Кулаков" а что он может выбрать, кроме array.empty? Потому что array.empty у него-то нет,
2397.16 2406.76 "Игорь Лабутин" он про него ничего не знает. А мы к этому придем. А, хорошо. Интригант, интригант, просто столько лекарей оставил. Да-да-да, не переключайтесь, это все будет потом.
2406.76 2411.08 "Анатолий Кулаков" Мне казалось, что это было где-то. Ну мы себя потом спросим. А, может, нет, ладно. Если что,
2411.08 2431.60 "Игорь Лабутин" я статью открою и быстренько тебя найду. Погнали. Значит, что происходит, собственно, теперь в компиляторе. Если мы хотим создать коллекцию, и Эндрю внезапно начал, я когда читал статью, он, как вы говорите, внезапно, если вы хотите создать sorted set. Часто так.
2431.60 2454.32 "Игорь Лабутин" Прямо каждый день хочу себе sorted set. Ну а также hash set и concurrent bag. На самом деле, вот эти три коллекции почему-то он как бы их выбрал, но для них на самом деле ничего не поменялось, будет генерирован такой же код, как и с collection initializer. То есть он просто создаст пустую коллекцию и вызывает added method. Там по-другому никак. Не, ну хороший fullback,
2454.32 2459.16 "Анатолий Кулаков" ничего не сломается, хуже мы не сделаем. Хуже не сделаем. Значит, если вы хотите лист t
2459.16 2520.20 "Игорь Лабутин" создать, то раньше, напомню, вызывался пустой конструктор листа и потом накидывалось туда added, сколько там элементов нужно, сколько вы задали в initializatory. Теперь используются методы, которые появились в восьмом дотнете, в типе называемый collections marshal. Это такой спецтип, который позволяет заглядывать во внутрянку коллекции и работает следующим образом. То есть он теперь генерирует следующий код. Мы создаем лист пустой, потом мы через collection marshal вызываем метод set count на нужный размер. То есть он таким образом реалайзирует внутренний массив на нужный размер. Потом получаем ссылку на span, span на ссылки на этот внутренний массив. И через span просто аккуратно через индексеры присваиваем. span 0, span 1, span 2, всю коллекцию. Прямо удаление gland через нет, не оттуда. Это еще пока нет. Это применение простой
2520.20 2526.32 "Анатолий Кулаков" способ. Да. Расскажи мне, у тебя же new list, он принимает в качестве аргумента длину списка.
2526.32 2532.88 "Анатолий Кулаков" Почему просто count не передать было в конструктор? Вероятно потому, чтобы прямо точный размер. Я
2532.88 2544.20 "Игорь Лабутин" вот не знаю, отличается ли collection marshal set count в плане, что он возьмет ближайшую степень двойки, например, для размера или точный размер создаст. Возможно, они создают точный размер.
2544.20 2548.48 "Анатолий Кулаков" Ну, скорее всего, точный, да. Какой смысл тебе степень двойки брать, если ты точно знаешь количество
2548.48 2552.88 "Игорь Лабутин" элементов? А вот new list я не помню. Точный ли он берет или он там тоже как-то подбирает?
2552.88 2557.92 "Анатолий Кулаков" New list тоже точный делает. Чего-то я уже не помню. Почему-то решили не делать таким образом. Короче,
2557.92 2564.76 "Игорь Лабутин" вот. Делали через collection marshal. Дальше, если… Подожди, подожди, скажи вот еще. Ответь за
2564.76 2577.04 "Анатолий Кулаков" Microsoft. Давай. А почему тогда просто у листа не сделать метод set count и у листа не сделать метод aspan? Дайте листу новые методы. Зачем нам вот эти всякие collection marshal? Потому что если вы это
2577.04 2582.44 "Игорь Лабутин" сделаете, то больше реализацию внутреннего листа вы менять не сможете. Никак. Ну, потому что…
2582.44 2587.68 "Анатолий Кулаков" А погоди, а как маршал тебя от этого ограничивает? Я точно так же могу реализацию внутреннего
2587.68 2592.40 "Игорь Лабутин" листа поменять, и маршал упадет. Ну, уберем маршал с следующего релиза.
2592.40 2597.04 "Анатолий Кулаков" Ну, они сделали его публичным классом. Ну, я понимаю. Слушай, это интересный вообще
2597.04 2610.68 "Игорь Лабутин" дизайн вопрос. Почему такие… На самом деле, наверное, вот почему. Я бы это делал из соображений, что это все-таки довольно такие специфические опишки, которые не хочется светить в довольно
2610.68 2625.12 "Анатолий Кулаков" популярном классе. Ну, опять же, я бы с тобой согласился, если бы у листа в конструкторе не было бы метод, который принимал бы длину, и если бы, например, у строки не было бы метода aspan, который уже они засветили. Так чем строка отличается от листа? Строка immutable гарантирована.
2625.12 2635.16 "Анатолий Кулаков" Immutable, ну да, в принципе, может, если immutable, они прямо явно это светят, а если не immutable, они это выносят в отдельный класс для того, чтобы разработчик задумался, что это не просто так,
2635.16 2682.56 "Игорь Лабутин" а надо быть осторожным. Ну, да, скорее такое, потому что все-таки сетка, он такой прямой доступ к underlying массиву, это такое. Нет, у листа же был, подожди, у листа же, по-моему, был этот getbuffer, нет, это у memory stream'а был getbuffer, я что-то уже не помню. Да, у memory stream'а getbuffer доступ был, это я уже путаю. Ладно. Так вот, еще надо понимать, что несмотря на то, что это фича языка C# 12, который зарелизился с восьмым дотнетом, вам никто не мешает на восьмом дотнете собирать приложение, которое таргетит более ранний дотнет. Понятно, да, то есть вы ставите в C с project'ом target framework, не знаю, .NET 6, и приложение соберется и будет работать на шестом дотнете, но в шестом дотнете нет collection marshal, типа. И поэтому, если target семерка или раньше, то там будет fallback на старый способ. Создали и вызвали EDD. Ну, это хорошо, да, нормуль.
2682.56 2731.78 "Игорь Лабутин" Вот. Еще один кейс, когда используется лист T внутри для collection expression, это если вы присваиваете collection expression в ilist или ycollection, тогда он использует просто лист T. Ну, как-то, наверное, наиболее разумный, так сказать, вариант. Дальше пошли с массивами. Вот с массивами там прямо интересно. Если вы создаете массив из референсных типов, ну там, не знаю, строк, то в принципе ничего интересного не происходит. Точно так же создается новый массив, и потом по индексерам все аккуратненько сетится, как было раньше. Ничего не поменялось. Но вот если вы создаете массив из так называемых bleedable типов, то есть это те типы, у которых, как это называется, представление в managed и unmanaged коде одинаковое. Ну, это всякие… Типа, да, бинарное представление.
2731.78 2770.76 "Игорь Лабутин" Бинарное, да. Инты, всякие ланги, вот это все. То есть если вы создаете коллекцию интов, например, и интеллизируете ее в массив, то тут возникает супермагия. Во-первых, генерится некоторый внутренний специальный класс, в котором заводится internal static read-only поле, в котором лежит ваше представление вот этих вот, как сказать, вашего будущего массива прямо в бинарном виде. Прямо подряд ваши инты, ну, допустим, если это массив интов, прямо подряд инты лежат в памяти. Вот там просто ссылочка на кусок памяти в ресурсах где-то скомпилированных.
2770.76 2794.88 "Игорь Лабутин" А дальше у вас есть специальный метод под названием runtime_helpers.initialize_array, куда вы передаете, собственно, новый пустой массив и ссылочку на вот этот вот волшебную пропертю. И этот метод, этот метод вам недоступен, то есть это чисто компиляторная штука, которая доступна только к компилятору, он, по сути, делает мем-копию из ресурсов в новый массив.
2794.88 2798.72 "Анатолий Кулаков" Ну, нормуль-магия-нормуль. Прямо оптимизация такая пошла.
2798.72 2811.52 "Игорь Лабутин" Да, но это происходит только если три или более элементов содержат недефолтные значения. То есть если у вас такое, знаешь, коллекция, где у вас там все нули и одна единичка, там будет по стариночке.
2811.52 2841.32 "Игорь Лабутин" Заинициализировали и только в один элемент поставили не ноль. Да, надо понимать, что если у вас нули в массиве, то присвоения нулей по индексерам не будет, это дефолтное значение, поэтому компилятор понимает это и вырезает. То есть они так оптимизировали, по сути, да, что не нужно все это универить. Что у тебя там, не знаю, лежит, не знаю, какой-нибудь там 10 или 20 элементный массив, это все равно там, ну, сколько, 10 элементов, что, 40 байт интов. Ну, зачем их хранить просто так? 40 байт нулей, из них там одна только не ноль.
2841.32 2858.64 "Анатолий Кулаков" Ну, в принципе, да, да, ты прав. Вот, значит, если вы… Ну, заметь, какой компилятор умный стал, да, то есть смотри, допустим, у меня в одной версии приложения там лежали только нолики, во второй версии приложения я добавил парочку значений уже настоящих, и у меня, по сути, изменился output-код, у меня там изменился весь бинарник,
2858.64 2862.44 "Игорь Лабутин" логика создания. Да, да, да, да, и performance поменяется, и все такое.
2862.44 2867.56 "Анатолий Кулаков" Да, да, очевидно, очевидно. Дальше, соответственно, еще массивы вот
2867.56 2879.56 "Игорь Лабутин" примерно таким же образом инициализируются и используются, если вы создаете, точнее, если вы присваиваете collection expression в innumerable, в iridonly collection или в iridonly list.
2879.56 2969.92 "Игорь Лабутин" Ну, поскольку все эти три, они iridonly, то есть они не могут изменить размер, ну, точнее, технически, да, у вас коллекция, которая под ними вообще говоря может, но если вы, поскольку она у вас фиксирована исходно и через интерфейс вы ее изменить больше не сможете, то внутри генерится массив, который дополнительно оборачивается специальным типом, который убедится, который запрещает, на самом деле, все эти операции записи в него, ну, то есть там приопределяются всякие сеттеры и прочее, и все это выставляется наружу в виде innumerable, iridonly или iridonly list. Вот. Это то, что касается списков и массивов. Есть еще спаны. Со спанами интересно, потому что если там, то есть если вы создаете, если вы используете collection expression, который нужно присвоить в span, в ridonly, точнее, span, то тогда, если используются примитивные типы, то есть, ну, те самые, да, int, long, blit table, то делается ровно все то же самое, как для массивов. Прям вот один в один. Но вот если вы используете ссылочные типы и при этом хотите спаны, то тут становится все очень интересно. Я не очень понял, почему именно используется такой вариант, почему используется такой подход. Здесь начинает использоваться фича под названием inline array. Помнишь, мы такое обсуждали в релизе C# 12? Да, и гадали, кому она нужна и зачем она нужна,
2969.92 2973.80 "Анатолий Кулаков" и кто ее вообще придумал, да, вообще непонятно, что. Вот здесь она как раз нужна, то есть здесь
2973.80 2995.00 "Игорь Лабутин" объявляется inline array нужного размера. Размер-то известен на этапе компиляции? Таким образом, у тебя получается тип, под который зарезервировано место нужного размера, и потом туда ассайнится нужный контент с помощью там специального helper метода еще более монструозного и магического. Этот код даже не буду пытаться объяснить. Вот здесь, короче, inline array работают
2995.00 3002.88 "Анатолий Кулаков" для референсных типов. То есть, по сути, быстрого создания многих референсных типов. Да,
3002.88 3028.88 "Игорь Лабутин" да. Значит, для immutable коллекций, всех вообще, там все просто, с ними работаются как с массивами, то есть либо через создание явное, либо через вот это вот bleedable и копирование, и потом аккуратненько через отдельный класс под названием immutable collection marshal, метод as immutable array, ну, оборачивается, чтобы он был действительно immutable, возвращается вам нужная коллекция.
3028.88 3177.04 "Игорь Лабутин" В collection expressions есть у нас еще такой замечательный элемент, это называется spread operator, это две точечки, но не надо его путать с range operator, это когда внутри вот этих квадратных скобочек вы можете написать точка, точка и имя переменной, которая ссылается на другой collection. И в результате инициализации у вас такая коллекция будет собрана из, ну, в runtime, по сути, эта коллекция, на которую вы сослались через две точечки, она встроится в ту коллекцию, которую вы создаете. Тут уже понятно, что не обязательно compile time, вы туда можете поскольку имя переменной, вы можете туда собрать все, что угодно, и там прямо, опять же, простор для того, как этот код сгенерить, потому что коллекция, которую вы туда передадите, туда можно передавать любое inumerable, в общем-то, и там начинается тоже магия. По большому счету, если то, что вы туда передали, можно к нему доступиться как к span, то есть это там лист, массив и так далее, то там будет просто, по сути, мемкопия из span в span, то есть он выяснит размер, создаст сразу нужного размера место и туда скопирует, значит, эффективным образом через span. Если вы туда передали что-то, что поддерживает только inumerable, ну тут без вариантов, тут только list.addRange и все, то есть ну inumerable нужно честно проитерировать, тут никак, без вариантов. Но как ни странно, если вы туда, например, закинете там какой-нибудь span или еще что-нибудь, то используется метод toArray на некоторых коллекциях, который, собственно, создаст нужный кусочек массива и уже из него все копируется, то есть там может быть небольшая локация на этом месте, но, видимо, без нее было никак не обойтись. Теперь, прежде чем мы пойдем совсем уж в дебри, которые, возможно, вы использовать не будете, вернемся к вопросу пустых, так сказать, коллекций, mpt-коллекций, что же там генерится. Ну, на самом деле, ты, конечно, прав, там никакой магии, в общем-то, нету. Если вы создаете массивы, если вы создаете inumerable или если вы создаете array-only collection, array-only list, в общем, везде, где можно подсунуть массив, то там будет array-empty. Тут никаких вариантов. Если вы создаете что-то mutable, то есть хэшсеты, листы, i-листы, то будет new list, ну или new hashset, соответственно. Без вариантов, потому что никто не гарантирует, что эту коллекцию потом не надо будет менять, ну и, соответственно, он тут будет создавать
3177.04 3200.76 "Анатолий Кулаков" лист. Ну вот я бы на их месте под шумок сюда ввел бы нам какие-нибудь интерфейсы, там array-only hashset и сделал точно так же hashset.empty, как мы сделали для массивов, и для всех прочих коллекций, для дикшенерей в частности. Почему дикшенере empty нет, до сих пор непонятно, как бы для array-only dictionary. В общем, вот это можно было бы притянуть за уши и привестись тут в порядок бы все. Ну, может быть, для словарей, может быть,
3200.76 3238.16 "Игорь Лабутин" они приведут все это в порядок, когда будут дополнять collection expressions для словарей, они сейчас не поддержаны, ты не можешь сейчас интеллизировать словари через collection expressions, но в теории, в issue, когда они все это реализовывали, говорили, что мы просто не успеваем, может быть, успеем сделать в следующем релизе. В девятом, правда, что-то молчат, но, может быть, еще успеют когда-нибудь доделать. Интересно, кстати, что происходит, если мы создаем immutable list, в этом случае в качестве дефолтной коллекции будет вызван immutable list.create от default от read-only span. Ну, в принципе, да, почему бы и нет?
3238.16 3346.40 "Игорь Лабутин" Такую штуку создают, в общем, прикольно. Итак, последнее, о чем хочется рассказать, что на самом деле collection expressions звучит как огромная компиляторная магия, что же там делать, но на самом деле вы можете добавить поддержку collection expressions в любой ваш тип. То есть, если вы, допустим, пишете какую-то свою кастомную коллекцию или даже тип, который, ну, по сути, своей коллекции не является, но, может быть, его удобно инициализировать через collection expressions, это все можно сделать. Во-первых, можно заимплементить innumerable, добавить публичный конструктор без параметров и иметь метод add, то есть все, что было достаточно для collection initializers, если это есть, можно использовать collection expressions. Это во-первых. Во-вторых, появился специальный атрибут, называется collection builder, который нужно навесить на какой-нибудь тип. У этого атрибута есть два параметра. Первый параметр - это typeof вашей коллекции, грубо говоря, типа коллекции, естественно, а второй - это имя метода, который в типе билдера нужно вызвать. Точнее, я, кстати, был неправ, там typeof не коллекции, а там typeof билдера. Ну, собственно, вы на коллекцию навешиваете атрибут collection builder, где указываете, каким типом нужно эту коллекцию собирать. А там есть метод, должен быть метод в этом билдере, public static метод, который возвращает instance вашей коллекции и который принимает read-only span от элементов вашей коллекции, ну, от элементов, которые будут, понятное дело, каким-то образом там заданы в collection initialize. И в этом методе create вам нужно создать вашу коллекцию из read-only span. Если вы это можете сделать, все у вас это есть. И по факту тебе
3346.40 3350.64 "Анатолий Кулаков" компилятор сгенерирует код, который в рантайме вызовет твой билдер и вернет коллекцию, там,
3350.64 3382.96 "Игорь Лабутин" где ты использовал collection expressions. Да. Причем, если ваша коллекция, точнее, тип initialize, которым вы пытаетесь создать, не является джинновиком, вы можете билдером обозвать сам же свой тип. То есть вы можете в collection builder навесить на коллекцию и сказать, что вызови create у моего же типа. Вот. Если же это джиннерик, там он должен ссылаться, этот билдер, на билдер должен быть не джиннерик типом обязательно. И в этом случае, ну, выносится в отдельный тип, и тогда, ну, аккуратненько просто вешается ссылочка. И все. Вот.
3382.96 3403.12 "Игорь Лабутин" И эта штука поддержана точно так же для более ранних дотнетов, так же, как мы обычно это делаем во всех других случаях. Значит, если вы таргетите более ранние дотнеты, ну, создайте свой собственный collection builder, а атрибут компилятора это понимает. Необязательно иметь этот атрибут конкретно из восьмого SDK. Компилятор все поймет, даже если вы его напишите в своем коде.
3403.12 3442.00 "Игорь Лабутин" И последний кусочек статьи — это про то, для чего collection expressions не поддержаны. Мы уже упомянули словари. Возможно, поддержат в будущем, но пока нет. Почему-то нет для iSet. Вот hashSet можно, а iSet нельзя. Это прям странно. Может, так же не успели. Может, не успели. Но при этом добавили frozenSet. Это вот в девятке добавили эти frozen коллекции, если ты помнишь. В девятке же? По-моему, в девятке. Ну и теперь frozenSet вот теперь есть. Ну и нету во всяких экзотики типа concurrentQueue, concurrentStack, priorityQueue и вот это все. Потому что их вряд ли вы будете
3442.00 3452.64 "Анатолий Кулаков" нитилизировать через collection expressions. Честно. Ну и там, наверное, не так критично какая-то оптимизация или performance. Если они добавятся через стандартный add, то никто не обидится.
3452.64 3456.84 "Игорь Лабутин" Ну а там нету add. В том-то и дело. А если там нету add, то даже collection initializer не сработает.
3456.84 3461.52 "Анатолий Кулаков" Да, тогда тем более вы не будете этого делать. Но с другой стороны, никто не мешает
3461.52 3477.96 "Игорь Лабутин" Microsoft в какой-то момент или комьюнити, например, докинуть в BCL тип под названием concurrentQueueBuilder, пометить concurrentQueue атрибутами, и вот у тебя появится поддержка. За счет атрибута можно же как бы не обязательно сам тип расширять. Достаточно атрибут навести, и все.
3477.96 3484.48 "Игорь Лабутин" А потом нам завезут экстенджены, и мы будем через экстенджены навешивать атрибуты на стандартные
3484.48 3491.60 "Анатолий Кулаков" типы BCL. Да ну погоди, погоди, еще лет 10 и завезут. Ну типа того. Ну в общем, как-то так,
3491.60 3517.88 "Игорь Лабутин" подробнейший разбор про collection expressions. Наверное, это все, что про них нужно знать, если интересен код, и как это все генерится, и зачем там inline array. Посмотрите в код Andrew Locke, там довольно подробно объясняется, как эта магия работает. То есть он убирает все это компиляторное, странное название компиляторов, да, все это магия именования, и описывает это все довольно простым и понятным кодом. Так что так. Ну действительно кажется, что фишка
3517.88 3529.80 "Анатолий Кулаков" простая, всего лишь навсего добавили квадратные скобки и все. Но под капотом очень много всего интересного происходит. Интересно, а на собеседовании будут спрашивать, как работает, будут спрашивать, как работает Locke, как работает forEach, будут спрашивать, как работает
3529.80 3541.76 "Игорь Лабутин" collection initializer? Как ты думаешь? Ну почему нет? Я бы на самом деле, ну по крайней мере про spread operator, вот точка-точка что-нибудь, я бы может спросил бы. Я надеялся, что вот такие
3541.76 3553.16 "Анатолий Кулаков" извращенцы, которые учились там на Риктере и Кнуте, они как бы не следят за этими новинками и до такого не дорастут. А те хипстеры, которые сейчас проводят собеседование, они такого не
3553.16 3563.24 "Игорь Лабутин" спрашивают. Не, ну видишь, смотри, я не хочу спрашивать там компиляторную магию InlineRay, но именно с точки зрения использования, ну если человек использовал, то спрошу, почему нет.
3563.24 3574.72 "Анатолий Кулаков" Ну ладно, допустим. Пойдем дальше. Так, у меня тоже статья почему-то от Andrew Locke. Я как-то не осознал вовремя, что у нас уже есть Locke в выпуске. Мы обычно двух одинаковых авторов не берем.
3574.72 3579.48 "Игорь Лабутин" Да ладно, да ладно. Он, видимо, в отпуск не ходит. Наверное, он единственный, кто работает из всех
3579.48 3614.20 "Анатолий Кулаков" разработчиков. В общем, Andrew Locke нам рассказал, каким образом нам заюзать нашу комбинаторику в наших юнит-тестах. Вообще, как мы жили без этого, непонятно. Вот об этом сегодня поговорим. Статья называется «Как упростить XUnit Theory атрибуты», то есть XUnit тесты с помощью библиотеки XUnit Combinatorial. Вот так. Это специальная библиотечка для генерации тестов и данных, для того, чтобы вам удобнее было их генерировать. Она довольно простая. Может быть, именно поэтому ее можно легко освоить, в отличие от какие-нибудь property-based тестов и прочих генераторов.
3614.20 3816.28 "Анатолий Кулаков" И поэтому, может быть, Андрею она так и понравилась. Мне тоже понравилось. Я часто встречал кейсы, где она была бы нужна. И вот, наверное, наконец нашел. Давайте же подробно разберемся, о чем, собственно, речь и о чем, собственно, статья. Для начала вспомним про сам XUnit. У него, для того, чтобы передать какие-то тестовые данные в метод, есть несколько способов. Вот вы написали какой-то тестовый метод. Допустим, у вас есть два входных значения, два була. Первый бул и второй бул. И вам нужно теперь в эти входные значения передать все возможные значения. Вы хотите, допустим, XOR потестировать, узнать, что там XOR возвращает. Вот. И хотите передать, соответственно, значения false-false, false-true, true-false и true-true, как и положено. Какие у вас для этого есть способы? Ну, во-первых, параметризованные методы для тестов XUnit поддерживает со всех сторон. Самое элементарное, что можно придумать, это атрибут inlineData, который позволяет вам непосредственно задекларировать над методом, какие константные данные вы будете туда передавать. Задекларировав четыре этих атрибута над методом, мы как раз запустим тест четыре раза со всеми этими значениями. Во-вторых, можно выбрать MemberData. Это специальный атрибут, который указывает на метод или параметр, находящийся в тестовом классе, который может вам вернуть эти значения, по которым нужно проретерироваться. Это полезно, допустим, если вы эти значения хотите сгенерировать, ну или вообще атрибуты поддерживает очень узкий набор типов, которые, допустим, вам в них передавать. Это должны быть какие-нибудь константы времени компиляции. Если вам нужно что-то больше, допустим, там создать какой-то классик, заполнить у него какие-то поля, вызвать у него какие-то методы, то для этого уже нужен оперативный код, и как раз MemberData отлично для этого подходит. Также есть атрибут classData, который похож на MemberData, но кроме метода у него еще можно указать какой-то внешний класс, ну или nested класс, не суть важно, какой-то другой класс. И вот другой класс в своем методе должен вас обеспечить всеми теми тестовыми данными, которые XUnit Framework должен прокрутить для запуска вашего метода. Вот, в принципе, такие базовые основы XUnit, это параметризованных тестов и вот в ситуации, когда мы хотим прокрутить все возможные параметры. Когда два параметра, в принципе, не так страшно, это всего лишь навсего 4 значения, но когда такие параметры 5 или может быть даже 10, которые мы хотим проверить в сложных тестах, вот там уже перебирать ручками все эти значения будет довольно сложно. А часто возникают кейсы, когда мы хотим проверить, а как каждый параметр работает с каждым другим. Такую комбинаторику сделать. И вот для этого как раз и нужна библиотечка, которая называется XUnit Combinatorial. Говорят, написал ее Эндри Арнотт, это член Visual Studio платформ-тим. То есть, он прям разрабатывает Visual Studio. Ну, не суть важна, просто нужно понимать, что дядька авторитетный, как бы, наверное, плохие вещи не напишет и поддерживать должен хорошо. Будем покромеливаться с этим, надеяться. Итак, что же эта штука дает? А дает она дополнительные атрибуты. В частности, мы можем теперь на наш тест навесить атрибут, который называется CombinatorialData и убрать все остальные подходы. То есть, InlineData, MemberData, ClassData, вот это нам больше ничего не нужно.
3816.28 4084.00 "Анатолий Кулаков" CombinatorialData нам говорит о том, что у нас наш фреймворк, наш XUnit Combinatorial сгенерит нам все возможные значения, которые пойдут в наш класс. То есть, в наш метод. Я напомню, что метод, допустим, к примеру, метод у нас принимает два була. Это значит, что повесим над этим методом просто-напросто CombinatorialData, мы получим четыре запуска данного метода. И во все эти четыре запуска передадутся все возможные комбинации val1 и val2. Кроме булов, поддерживается и немножко других типов. Какие же? Давайте рассмотрим. Ну, в частности, bool, да, там true/false передается. 0-абельный bool, что не так уж и неважно. То есть, кроме true/false, у нас там еще может null передаваться. Это уже как бы три значения, что неплохо, неплохо. Int. Вначале можно было бы подумать, что там перебираются все int от int_min до int_max, но автору показался такой подход слишком безумным. Поэтому по умолчанию в int передается только 0 и единичка. Если вы задекларируете тип int, в качестве комбинаторики там будет только 0 и 1. Это поведение можно будет исправить, но мы об этом поговорим в будущем. 0-абельные int, которые к нашему 0 и 1 добавляет null. И enum. Из enum берется все get_names, которые у него есть, и все эти get_names передаются, соответственно, в комбинаторике. Что же делать, если среди этого списка нет вашего любимого типа, например, double. Мы хотим передавать double. Ну, прежде всего, очевидно, почему его не добавили, потому что там непонятно, как его итеретить. Можно было бы сделать double только с 0 и только с 1, но тогда этот тест больше тестировал бы int, чем double. В общем, с double много значений, поэтому понятно, почему их не добавили по дефолту. Но мы можем это более-менее нивелировать. У нас есть специальный атрибут, который называется combinatorial values. И этот атрибут уже применяется непосредственно к самому значению внутри этого теста. То есть, допустим, если у нас есть double значение, которое мы хотим принять в тест, мы навешаем к нему, к значению, атрибут, который называется combinatorial values, и указываем там, например, от 0 до 2 и с каким шагом. И фреймворк будет перебирать все числа от 0 до 2 с указанным шагом. Таким образом, грубо говоря, поддержим комбинаторику doubles. Также точно, естественно, можно сделать не только для doubles, но и для int. Если вы хотите не просто 0 и 1 передавать, а, допустим, передавать туда от -1 до 1, это тоже можно сделать с помощью данного атрибута. combinatorial values поддерживает следующие параметры. То есть, как он может перебирать? Он может просто перебирать, допустим, от 10 5 раз, то есть, от какого числа и сколько таких чисел надо выдать, или от какого числа до какого числа с каким шагом. Вот как бы два стандартных цикла, которые он может крутить. Дальше мы сталкиваемся с ситуацией, как и с обычными атрибутами. То есть, как мы в обычных тестовых атрибутах иногда не могли использовать значения, допустим, если это значения не выражаются константой, а должны быть какие-то императивными. Также здесь, если у нас значение не константное, а может выражаться только какой-нибудь императивной логикой, есть атрибут combinatorial member data. Мы ему можем передать какое-нибудь поле или какой-нибудь метод, в котором хранится тестовые данные, которые он должен закомбинаторить. То есть, которые он должен перебрать все со всеми. В общем, точно так же можно указать. Можно указать не только метод, можно в качестве аргумента сюда же добавить и класс. А еще интересное свойство - можно добавить аргумент, который будет передан в метод, который генерит вам тестовые данные. Таким образом, вы с помощью данного атрибута можете настраивать то, какие данные вам выдаст сам генератор. И еще интересный атрибут есть, который называется combinatorial random data. Как вы, наверное, поняли из названия, он выдает вам рандомное какое-то значение. Этот атрибут тоже хорошо настраивается. У него есть минимум, максимум. Вы можете у него задать count или даже seed, с помощью которого он инициализирует рандомный счетчик. И таким образом сделать комбинаторику не только с предсказуемыми числами, но и еще с непредсказуемыми, с рандомными. Вот такая функциональность довольно богатая, довольно хорошая для такой примитивно решаемой задачи. И наверняка в некоторых ваших возможных тестовых кейсах найдет себе применение.
4084.00 4096.28 "Игорь Лабутин" Хорошо об этом знать. Действительно, и самое главное, спасибо, что в random data есть сейчас не seed, чтобы была повторяемость. Иначе отлаживать такое прям сложно. Ну вообще да, в тестах
4096.28 4101.42 "Анатолий Кулаков" использовать рандом это очень плохо. Поэтому обычно какой-нибудь seed все-таки стараются добавить.
4101.42 4106.50 "Анатолий Кулаков" Потому что иногда тест будет падать, а иногда не падать. У нас получатся флаги теста, что ужасно.
4106.50 4113.82 "Игорь Лабутин" Ну что, Мпэй, сегодня у нас практически все. У нас осталось последний раздел, это кратко о разном.
4113.82 4148.88 "Игорь Лабутин" Давайте попробуем кратко по нему пробежаться. Во-первых, попалась тулза под названием dependify. Это новая тулза для того, чтобы осмотреть зависимости между модулями, ну то есть по сути, между css прош файлами в вашем солюшене. Это dotnet tool, который можно заинсталить. Я так понимаю, что у него можно получить некоторый отчет в виде фиттекста, а можно заиспользовать командочку serve. И тогда вы получите веб-интерфейс, в котором можно побраудить зависимости между вашими проектами в динамике, подключать-подключать всякие штуки. И все это еще интегрируется в Aspire.
4148.88 4155.28 "Игорь Лабутин" Соответственно, можно подключить эту штуку к компоненту в Aspire и видеть прямо в Aspire отдельно.
4155.28 4175.76 "Игорь Лабутин" Ну там, по сути, просто будет ссылочка на тот же веб-интерфейс. В общем, если вы работаете с каким-то сложным солюшеном, и вам интересно посмотреть на зависимости, и вас почему-то не устраивают штатные тулы студии и райдера, которые в принципе умеют показывать зависимости между параджами, то можно посмотреть на этот тул тоже. Я не пробовал, но не знаю.
4175.76 4187.32 "Анатолий Кулаков" Да, не та ситуация, что мы в прошлом выпуске обсуждали, когда можно просто в JSON файл зайти и посмотреть вообще все зависимости, которые есть, даже транзитивные. Ну да, но видишь, здесь именно
4187.32 4198.88 "Игорь Лабутин" скорее не зависимости в смысле от чего зависит твой csproj, а зависимости между csproj, кто кого референсит. То есть такая диаграмма зависимости csproj в вашем продукте, в вашем солюшене.
4198.88 4207.96 "Анатолий Кулаков" Ну то есть то, что я могу увидеть в принципе в файл csproj, но мне нужно во всех файлах посмотреть что-то удобное для всех файлов csproj. Да, по-моему в райдере это называется
4207.96 4225.00 "Игорь Лабутин" architectural diagram, как-то так это, по-моему, называлось. В студии тоже какая-то подобная штука была, правда, по-моему, в enterprise версии, мне кажется. Но я просто давным-давно уже не пользовался таким. Я давно-давно не работаю с такого рода солюшеном, где бы мне это было надо, вот так скажем.
4225.00 4239.24 "Анатолий Кулаков" Это да, просто когда у меня возникает такая необходимость, я не хочу рисовать диаграмму, мне не нужны эти квадратики вообще от слова совсем. Мне больше бы подошла инструмента, которая раскрывает тебе референсы, как мы делаем, например, с зависимостью от NuGet-пакета.
4239.24 4243.76 "Анатолий Кулаков" Ты заходишь, раскрываешь, и там дальше-дальше пошел раскрывать и смотреть, от чего оно зависит.
4243.76 4259.20 "Игорь Лабутин" Возможно, оно как раз генерирует JSON, который ты сможешь в каком-нибудь правильном JSON-вьюере посмотреть именно таким раскрыванием. Ну, скорее всего, tool родился в целях, так сказать, нужно самому, заодно что бы не опубликовать. Вроде нормальная документация,
4259.20 4267.60 "Анатолий Кулаков" хороший код. Не, полезная, полезная tool, да, часто необходима, просто жалко, что это стандартный какой-то комплект студии до сих пор не могли встроить. Ну, слушай, теперь это .NET tool,
4267.60 4364.60 "Игорь Лабутин" поэтому .NET install, и, в принципе, все, и готово. А, тоже верно, да. Вот. Дальше, ссылочка на ютубный плейлист, прошел .NET Aspire Developers Day, это, видимо, событие, посвященное как раз релизу 8.1, по-моему, оно примерно в те же даты было где-то, в районе середины июля, и там примерно 15 разных сессий разной длины, таких достаточно технических, на предмет, значит, как Aspire использовать, как разные модули подключать, как из этого все, какие диаграммки смотреть, ну и так далее. Поэтому, если вам интересно Aspire, интересно, как им пользуются, вот, посмотрите видосики, может быть, там что-то найдете интересное. И третья новость, это про binary форматор, мы уже много раз про него говорили, и много раз говорили, что он все деприкейтится, деприкейтится, деприкейтится. Наконец-таки задеприкейтился, в девятом .NET все, не будет никакого binary форматора, и возникает вопрос, а что делать? Ну, как бы, у вас же есть наверняка какой-то, какие-то данные, которые, возможно, с помощью binary форматора были куда-то сериализованы. Вот. В целом, ссылка, которая будет в шоуноутах, это гайд, официальный гайд от Microsoft по миграции, там предлагается, собственно, два выхода, либо надо с binary форматора уходить, ну и тут выбор, понятно, широкий, это JSON-разный сериализатор, XML-сериализатор в виде датаконтракта сериалайзера, MessagePack, Protobuf, в общем, все, что хотите из современных сериализаторов. Либо можно взять неподдерживаемый пакет, у них так и написано, use unsupported system runtime serialization formatters package, и там будет binary форматор. То есть тот старый добрый,
4364.60 4368.24 "Анатолий Кулаков" да, они вынесли в отдельный пакет. Они вынесли в отдельный пакет, возможно,
4368.24 4416.68 "Игорь Лабутин" его порезали, я не проверял, насколько порезали, да, то есть там же он был весь из себя такой небезопасный, вот это все, то из-за чего, собственно, весь сервор. Но, скорее всего, они его туда вынесли плюс-минус целиком. Но возникает вопрос, ну, допустим, мы скажем, ладно, пойдем там, не знаю, в JSON, в MessagePack, ну, куда угодно, но нам же, может быть, надо прочитать что-то, что лежит уже в binary форматор виде, где-нибудь с реализованным в базе данных, например, и у нас есть новый пакет, называется System Formats NRBF, я не знаю, почему, ну, видимо, non-что-нибудь, binary форматор, вот, в котором есть тип NRBF decoder, который может читать то, что было сериализовано binary форматором с дефолтными настройками, грубо говоря.
4416.68 4463.76 "Игорь Лабутин" Только читать, да, писать эпизодизм. Да, только читать, при этом он очень параноидальный, то есть он не будет делать всю ту магию, которую умеет делать binary форматор, там, создавать на лету массивые неизвестные длины из payload'а, вот это все, ну, короче, там есть куча проверок, может, почитайте статью, там прям четкий список есть, по-моему, из 10 или 15 пунктов, значит, что он не будет делать, вот, и поэтому, возможно, он подойдет не всем, но, скорее всего, если у вас дефолтные настройки, вы просто сериализовывали какие-то небольшие данные, то он вам подойдет, и тогда вы сможете это дело прочитать. Если же binary форматор вам был нужен, потому что вы использовали WinForms или WPF, а там он тоже был в некоторых местах нужен, то там есть отдельный раздел гайда, что с этим делать. Вот такие дела, не используйте binary
4463.76 4480.56 "Анатолий Кулаков" форматор. Не, ну, хорошие инструменты, просто их надо было как-то осветить до того, как они его задеприкейтили, как-то они запоздали. Сначала надо замигрировать, там, хотя бы пару лет отдать людям на миграцию, там, на инструменты предоставить и все такое, а потом уже деприкейтить. Ну, слушай, они уже, по-моему,
4480.56 4483.20 "Игорь Лабутин" начинают с шестерки или семерки, говорят, мы задеприкейтим.
4483.20 4485.44 "Анатолий Кулаков" Не, ну то они просто говорили, это одно.
4485.44 4489.68 "Игорь Лабутин" Теперь вот пакет появился, ну да, да. А вот когда задеприкейтили, да.
4489.68 4494.92 "Игорь Лабутин" Тем более, видишь, девятка-то, она же не LTS, поэтому.
4494.92 4499.32 "Анатолий Кулаков" А, ну да, там еще четыре года добавляется. Ну почему четыре, ну не четыре,
4499.32 4506.00 "Игорь Лабутин" восьмерка будет поддержана до еще три года, так что, ну, два с половиной от текущего момента, так что нормально, время есть. Время есть.
4506.00 4511.12 "Анатолий Кулаков" Ну, хорошо. Я тоже добавил парочку статейщик, которые хотелось бы вам рассказать.
4511.12 4517.16 "Анатолий Кулаков" Во-первых, на хабре мне понравилась статья .NET на CBC, максимально каноничная.
4517.16 4611.28 "Анатолий Кулаков" Это от нашего любимого автора Baldo. Не автор, да, он нам больше знаком как докладчик, но, кстати, у него тоже хорошие. Статья про то, как можно на синглборд компьютер для .NET и Linux поставить .NET на вот эти одноплатники, синглборды, Raspberry Pi и прочие вот эти айотные штучки. В общем, у меня очень большое желание как-нибудь завязать мой Raspberry Pi, наконец, с .NET, поэтому я все-таки статейщики очень люблю. Тема интересна не всем, поэтому в основном выпуск я ее не включил, но если вдруг вам интересно, как же живет .NET на айот-устройствах и как его самому можно там заделать, запоставить, то, в общем, статья очень хорошая. Очень много полезных ссылок, которые я еще долго буду там читать, лазить и смотреть. Вторая интересная заметка - это я наткнулся на mermaid.net. Про mermaid мы много раз уже упоминали. Это специальный язык для создания диаграмм, текстов язык. То есть, он похож чем-то, если вы юзали на plant.yml, но гораздо более легковестен и поддерживается во всех там, практически во всех редакторах, которые возможны. Например, в том же самом github, вы можете редмишки писать, в редмишках на github использовать mermaid. Там он просто рендерится в хорошие красивые диаграммки. Он, как я уже сказал, легковестен, красивый, поддерживает огромное число диаграмм. Меньше, конечно, чем plant.yml. Тут не поспоришь, но все, что нужно вот за последние годы, я практически там находил. Что делает библиотечка?
4611.28 4657.72 "Анатолий Кулаков" Так как mermaid – это просто текстовый язык, то есть вам нужно все-таки сгенерить просто отформатированный текстовый файлик. Все, что она делает, это предоставляет хорошие билдеры. То есть, билдеры, которые в интеллисенсе позволят вам не ошибиться, в каком чарте должна быть какая нода, какие у нее тайтлы, какие у нее ширины, какие у нее цвета и вот это вот все прочее. В принципе, такая библиотечка пишется за полчаса на коленке, но с другой стороны, как бы если она уже есть, если автор поддержит всевозможные чарты, если автор там добавляет всякие возможные скейпы, чтобы не ошибиться в названиях, то это всегда приятно. Поэтому библиотечка приятна, если вы себя используете в проектах mermaid, то посмотрите, может, вы тоже куда-нибудь прикрутите.
4657.72 4664.76 "Игорь Лабутин" Ну и супер, на этом можно заканчивать. Сегодня получился около часа, наверное, выпуск.
4664.76 4668.04 "Игорь Лабутин" Посмотрим, близим или не близим. Летний формат.
4668.04 4694.88 "Игорь Лабутин" Да. Посмотрели на .NET Aspire 8.1, посмотрели на еще две статьи в большом цикле статьи Джима Боггарда про миграцию из .NET фреймворка в современный .NET, детально разобрали коллекшн экспрессионы, посмотрели на новый XUnit combinatorial атрибутик, который позволяет вам не писать много кода для того, чтобы получить комбинаторные тесты, ну и кратко-разно поближаясь по разным темам.
4694.88 4698.72 "Игорь Лабутин" На этом на сегодня, наверное, все. 98-й выпуск.
4698.72 4727.84 "Анатолий Кулаков" Да, точно все. Я забыл упомянуть, да, у нас же есть, как всегда, Boosty, поэтому, если вдруг что, заходите на Boosty, если захотите поддержать подкаст. У нас есть много социальных сетей, там есть комментарии. Комментарии можно оставлять, можно нас поправлять, можно нам предлагать какие-нибудь там темы, можно выражать свои мысли насчет тех фич, которые вводятся в .NET, и можно там делать вообще абсолютно все, что угодно, там довольно хорошее сообщество, отвечает довольно приятно и по делу, обычно.
4727.84 4732.24 "Анатолий Кулаков" Поэтому заходите, ставьте комментарии, ну и главное, шарьте, репостите и слушайте.
4732.24 4734.64 "Анатолий Кулаков" Всем до новых встреч, всем пока. Всем пока.
