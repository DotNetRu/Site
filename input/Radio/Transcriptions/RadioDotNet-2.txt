0.00 6.24 "Анатолий Кулаков" Доброе время суток, дорогие друзья!
6.24 9.36 "Анатолий Кулаков" В студии вас снова приветствует Анатолий Кулаков.
9.36 10.36 "Игорь Лабутин" И Игорь Лабутин.
10.36 13.56 "Анатолий Кулаков" И мы продолжаем наши выпуски про .NET.
13.56 16.36 "Анатолий Кулаков" И сегодня мы добрались до целого второго выпуска.
16.36 21.84 "Анатолий Кулаков" Интересно, сколько нужно выпусков, чтобы перестать представляться и стать уже наконец всемирно известными звездами?
21.84 22.84 "Анатолий Кулаков" Игорь, как ты думаешь?
22.84 24.20 "Анатолий Кулаков" Мы же дотянули или еще поработать придется?
24.20 25.92 "Игорь Лабутин" Я думаю, что придется еще поработать.
25.92 28.32 "Игорь Лабутин" Ну, можно ради эксперимента попробовать не представиться.
28.32 31.60 "Игорь Лабутин" Еще один-два выпуска и посмотреть, что из этого получится.
31.60 34.12 "Игорь Лабутин" Надеюсь, что нас уже начнут узнавать по голосу.
34.12 38.04 "Анатолий Кулаков" Не знаю насчет голоса, но насчет тем меня поразило.
38.04 39.96 "Анатолий Кулаков" Оказывается, представляешь, Microsoft нас слушает.
39.96 46.32 "Анатолий Кулаков" Помнишь, мы в прошлый раз обсуждали про объединение ISP .NET репозиториев, как у них так все стало хорошо и так далее.
46.32 54.80 "Анатолий Кулаков" Ну и почему-то возмущались, что там все по-прежнему остается сложно с изменением версии, билдов и так далее.
54.80 61.48 "Игорь Лабутин" Было дело, там сколько-то 15 или 19 файлов нужно было поменять, чтобы версию проапгрейдить.
61.48 62.88 "Игорь Лабутин" Они наконец-таки это улучшили?
62.88 64.04 "Анатолий Кулаков" Вот-вот, типа того.
64.04 66.88 "Анатолий Кулаков" Они не просто улучшили, они пошли еще дальше.
66.88 72.32 "Анатолий Кулаков" Они решили вообще перерефакторить все свои репозитории и провести небольшое объединение.
72.32 75.32 "Анатолий Кулаков" И в этом, в принципе, заключается наша первая новость.
75.32 81.12 "Анатолий Кулаков" Microsoft решил объединить некоторые .NET репозитории на своем GitHub.
81.12 86.64 "Игорь Лабутин" То есть объединить, слить или как-то попереносить между организациями?
86.64 92.68 "Игорь Лабутин" У них же еще есть разные организации, типа .NET одно, Mono живет в другом месте.
92.68 95.40 "Анатолий Кулаков" Более того, ISP живет в третьем месте.
95.40 99.32 "Анатолий Кулаков" Да, в принципе и репозитории, и организации все немножко перефакторить.
99.32 101.24 "Анатолий Кулаков" Давай немножко расскажу подробности.
101.24 103.40 "Анатолий Кулаков" Прежде всего, какие с этим были проблемы.
103.40 109.76 "Анатолий Кулаков" В качестве примера можно рассмотреть два репозитория, это .NET Core CLR и .NET Core FX.
109.76 113.76 "Анатолий Кулаков" Очень часто среди этих репозиторий шарились низкоуровневые библиотеки.
113.76 122.96 "Анатолий Кулаков" И когда такие библиотеки шарятся, и в них находятся какие-то проблемы или наоборот нужно добавить какие-то фичи, не очень понятно в какой репозитории все эти фичи добавлять.
122.96 124.92 "Анатолий Кулаков" В первой или во второй?
124.92 130.68 "Анатолий Кулаков" Потому что эти библиотеки шарились с помощью магических линков и исходных кодов.
130.68 138.48 "Анатолий Кулаков" Соответственно, во-первых, это проблема шаринга одинаковых ресурсов, которые нельзя зареферентировать в виде каких-то библиотек, а нужны именно исходные коды.
138.48 141.64 "Анатолий Кулаков" Во-вторых, это непонятно, где открывать OpenIsh.
141.64 145.52 "Анатолий Кулаков" Во-третьих, непонятно, куда засылать pull-request, если вдруг это все пофиксилось.
145.52 149.96 "Игорь Лабутин" Да, мне кажется, что с фичами еще, может быть, куда не шло.
149.96 162.80 "Игорь Лабутин" Мне кажется, большая проблема у конечных пользователей, у которых там что-то не работает в .NET, и надо понять, это Core FX, Core CLR, ASP.NET или еще 100-500 вспомогательных репозиторий.
162.80 178.24 "Игорь Лабутин" И я так понимаю, что все-таки связь по исходникам - это все-таки такая очень прерогатива Core FX и Core CLR, которые сильно связаны, особенно какими-то базовыми типами, типа строчек, и непонятно, где там функционально живет половина в Core FX и половина в Core CLR-е, внативно.
178.24 182.36 "Игорь Лабутин" Но проблема с ish-юсами, я так подозреваю, действительно очень велика.
182.36 189.84 "Игорь Лабутин" У меня было пару раз, когда я пытался понять, куда же закинуть ish-ю - это Core FX или это ASP.NET, потому что это было где-то на стыке.
189.84 197.12 "Анатолий Кулаков" И обычно какая-нибудь фича, если ты забрасываешь, ее можно реализовать как непосредственно в классах, так и поддержать в рантайме.
197.12 199.04 "Анатолий Кулаков" То есть она относится и туда, и туда.
199.04 210.40 "Анатолий Кулаков" И с этим тоже было много проблем, связанных, когда люди там половину фичи заливали туда, потом ждали, пока она промерзнется в одну ветку, заливали в другую репозиторию, вторую часть этой фичи, ждали, пока она промерзнется там.
210.40 215.76 "Анатолий Кулаков" И вот эта карусель там крутилась, порождая конфликты, порождая много багов и так далее.
215.76 225.12 "Анатолий Кулаков" И, соответственно, ребята из Microsoft поняли, что делить нужно все-таки не по маркетинговым каким-то сборкам или названиям, а по принципу собираемости.
225.12 232.16 "Анатолий Кулаков" То есть что вместе собирается, что не может жить друг без друга, вот это по идее нужно попробовать объединить.
232.16 234.40 "Анатолий Кулаков" И они пришли к следующему делению.
234.40 246.16 "Анатолий Кулаков" Давайте возьмем Core CLR, CoreFX, CoreRT, он еще жив, кстати, CoreSetup и такую же функциональность из Mon, и там какой-то кусочек, и объединим это все в один репозиторий.
246.16 249.80 "Анатолий Кулаков" И репозиторий получил название .NET Platform.
249.80 252.92 "Анатолий Кулаков" Такой же трюк они проделали и с ISP.NET Core.
252.92 263.16 "Анатолий Кулаков" Они взяли ISP.NET Core, объединили его с Blazor, добавили туда еще всяких мелких репозиториев и назвали новый репозиторий .NET ISP.NET Core.
263.16 268.44 "Анатолий Кулаков" То есть ISP.NET теперь переехал из своей собственной организации в организацию .NET.
268.44 278.84 "Анатолий Кулаков" С организацией тоже у них были связаны проблемы с тем, что, например, нужно отдельно настраивать пермишены для одного и того же пользователя в каждой отдельной организации.
278.84 286.68 "Анатолий Кулаков" Были проблемы также с тем, что ish'ы создавались в одном репозитории, а их нужно было перенести в другой, потому что проблема была совсем не здесь.
286.68 289.44 "Анатолий Кулаков" Ish'ы пока нельзя переносить между организациями.
289.44 297.52 "Анатолий Кулаков" Здесь интересный момент, что у GitHub есть бета-функциональность перенесения ish'ю между репозиториями, но в пределах одной организации.
297.52 299.64 "Анатолий Кулаков" Я уже, кстати, попробовал и работает отлично.
299.64 303.60 "Анатолий Кулаков" Но между различными организациями ish'и перенести невозможно.
303.60 308.00 "Анатолий Кулаков" И тут у меня заключается конспирологическая теория, зачем все-таки микрософтовцы купили GitHub.
308.00 311.96 "Анатолий Кулаков" Потому что иначе им не давали доступ к внутренней базе данных, и они не могли это сделать.
311.96 313.52 "Анатолий Кулаков" А теперь все становится очевидным.
313.52 317.08 "Анатолий Кулаков" Купили они GitHub вот как раз ради этой фичи, чтобы объединить
317.08 322.72 "Игорь Лабутин" репозитории. Ну и теперь они перенесут, собственно, свои ish'и и больше фичи будет не нужна, возможно.
322.72 324.84 "Игорь Лабутин" А может и допилят до релиза.
324.84 329.72 "Анатолий Кулаков" А может, наоборот, для продакшена всем откроют, кто захочет дальше такие трюки делать.
329.72 333.32 "Анатолий Кулаков" Потому что через официальные открытые API такого сделать невозможно.
333.32 341.32 "Анатолий Кулаков" И третья репозитория, которую я забыл упомянуть, это .NET CLI, которая объединит в себе старые репозитории Toolset и .NET SDK.
341.32 345.80 "Игорь Лабутин" Тут мне кажется, что я видел некоторые споры, довольно ожесточенные на тему имени.
345.80 351.84 "Игорь Лабутин" Потому что CLI это все-таки вроде как command-line interface.
351.84 355.44 "Игорь Лабутин" Были идеи назвать его SDK, и Toolset, и Toolchain.
355.44 363.20 "Игорь Лабутин" Я так понимаю, что если платформа и Aspen.Core более-менее устоявшиеся названия, то вот CLI, там еще идут пока дебаты, как это все назвать.
363.20 366.32 "Игорь Лабутин" Как вообще планировать весь этот процесс переезда?
366.32 368.68 "Игорь Лабутин" Потому что выглядит очень массивно.
368.68 369.68 "Анатолий Кулаков" Да, именно так.
369.68 371.28 "Анатолий Кулаков" И при том это объединение репозиторий.
371.28 374.16 "Анатолий Кулаков" То есть тут очень важно не потерять git history.
374.16 385.00 "Анатолий Кулаков" И команда обещает нам, что git history будет правильно смержен, ничего не потеряется, все pull-requests будут смержаны, все контрибьюторы будут упомянуты, все ишьи будут красиво и ровно перенесены.
385.00 387.76 "Анатолий Кулаков" То есть никакой старой информации не потеряется.
387.76 390.12 "Анатолий Кулаков" Все переедет ровно и красиво.
390.12 410.80 "Игорь Лабутин" Интересный вопрос, а pull-requests, те, которые уже закоммичены, понятно, со своими git-веточками, это одно, а те, которые сейчас активны, то есть я там вчера взял, создал новый pull-request, у них будет шанс переехать или они их всех закроют, или они останутся в старом репо и никуда не денутся больше и нужно заново открывать в новом репо?
410.80 411.80 "Игорь Лабутин" Есть какая-то информация?
411.80 416.20 "Анатолий Кулаков" Нет, там сейчас ведется очень большая дискуссия, как это будет происходить.
416.20 426.00 "Анатолий Кулаков" Пока к единому мнению не пришли, но все-таки большинство склоняется к тому, что сейчас старые репозитории останутся read-only и все новые веточки будут открываться уже в новых репозиториях.
426.00 429.20 "Анатолий Кулаков" А старые постепенно доделываются и постепенно переносятся.
429.20 431.52 "Анатолий Кулаков" И так, естественно, и смертью они отомрут.
431.52 435.04 "Игорь Лабутин" Ну, посмотрим, как это пойдет.
435.04 438.64 "Игорь Лабутин" А есть какие-то сроки, когда это все начнется?
438.64 451.32 "Анатолий Кулаков" Нет, пока конечных сроков не определили и не дают, пока это все идеи, пока не призывают сообщество выдавать какие-то свои мысли, что может пойти не так, что можно сделать лучше, или те же самые проблемы с именованием.
451.32 456.48 "Анатолий Кулаков" Сейчас идет как раз бурная дискуссия, и если вам интересно, вы можете стремительно поучаствовать.
456.48 459.80 "Анатолий Кулаков" Кстати, первым прибежали люди из ISP.NET.
459.80 466.08 "Анатолий Кулаков" Как вы помните, ISP.NET репозитории тоже недавно объединились, их раньше было 55, теперь их стало просто 5.
466.08 475.60 "Анатолий Кулаков" Вот, они сказали, что они съели очень-очень много всего интересного и с Git, и с объединением, и с GitHub, и все про них теперь такого знают, что даже не хотели раньше этого знать.
475.60 477.32 "Анатолий Кулаков" Вот, и готовы помочь, соответственно.
477.32 490.48 "Игорь Лабутин" Ну, а мы, как конечные подавители, должны быстро-быстро закрывать pull-requests, если они у нас есть, и стремиться свою работу по-быренькому вкомитить, чтобы она успела переехать нормально.
490.48 496.88 "Игорь Лабутин" Хорошо, Microsoft прям гигантские планы строит на тему того, как хранить код.
496.88 499.48 "Игорь Лабутин" Еще бы они что-нибудь сделали с документацией.
499.48 506.80 "Игорь Лабутин" Хотя, признаться, в последнее время Docs.Microsoft.com весьма радует и качеством, и наполнением.
506.80 526.00 "Игорь Лабутин" То есть, если раньше, когда я лет 5-6-7 назад пытался что-то найти в MSDN, ну, это было иногда больно, и стековерфлоу было гораздо лучше, то сейчас Docs.Microsoft.com вполне себе отличная тема, и, мне кажется, улучшается и улучшается, в том числе, я так понимаю, сильно за счет контрибьюторов внешних.
526.00 527.28 "Анатолий Кулаков" Да, именно так.
527.28 529.20 "Анатолий Кулаков" У него очень много контрибьюторов.
529.20 536.08 "Анатолий Кулаков" Это видно, когда ты заходишь практически на каждую страницу, то можно увидеть, кто приложил руку к написанию этой статьи.
536.08 544.20 "Анатолий Кулаков" А еще интересная тема, что кроме документации непосредственно к классам и к коду, они внедрили еще документацию в виде статей.
544.20 553.28 "Анатолий Кулаков" То есть, ты не просто можешь почитать какие-то голые методы и их сигнатуры, а именно, как это можно использовать, как это можно удобно интегрировать в свои системы и так далее.
553.28 557.04 "Анатолий Кулаков" И различные контрибьюторы, не только микрософтовские, добавляют новые и новые примеры.
557.04 562.08 "Анатолий Кулаков" Из-за этого документация становится более обширная, более актуальная и более интересная.
562.08 569.12 "Анатолий Кулаков" А еще они, в принципе, к своей документации добавили еще один интересный портал, который стал частью Docs Microsoft Comma.
569.12 571.04 "Анатолий Кулаков" Это тоже безумно полезная штука.
571.04 572.64 "Анатолий Кулаков" Я не понимаю, как ее раньше-то не было.
572.64 574.36 "Анатолий Кулаков" Это Microsoft Code Samples.
574.36 582.88 "Анатолий Кулаков" Они решили все сэмплы, которые у них были разбросаны по куче SDK, по куче статей, по куче репозиторий и так далее, они решили все это объединить в один репозиторий.
582.88 589.40 "Анатолий Кулаков" И получился довольно-таки интересный репозиторий с быстрым поиском, естественно, с фильтрацией по языкам, с фильтрацией по технологиям.
589.40 591.96 "Анатолий Кулаков" Кстати, технологии там есть не только микрософтовские.
591.96 596.52 "Анатолий Кулаков" Это намекает на то, что, опять же, репозиторий открыт для внешних контрибютеров.
596.52 598.84 "Анатолий Кулаков" Ко многим примерам есть прям отличная документация.
598.84 605.32 "Анатолий Кулаков" То есть не просто голые какие-то сэмплы с кодом и все, а прям ко многим есть интересные статьи, которые описывают эту документацию.
605.32 607.96 "Анатолий Кулаков" Примеры можно скачать тремя способами.
607.96 612.64 "Анатолий Кулаков" Во-первых, это, конечно же, zip-архив, как мы все с вами привыкли качать микрософтовские примеры.
612.64 615.64 "Анатолий Кулаков" Во-вторых, это ссылка на GitHub.
615.64 620.00 "Анатолий Кулаков" Мне кажется, там все примеры имеют какой-то репозиторий на GitHub, и, наверное, это одно из требований.
620.00 626.04 "Анатолий Кулаков" И еще обалденная какая-то интересная штука – это диплой примера прямо в ваш Azure.
626.04 629.68 "Анатолий Кулаков" Это возможно с помощью Azure Resource Manager Templates.
629.68 635.32 "Анатолий Кулаков" То есть это специальный файл, который вы описываете в своем GitHub-репозитории, файл в формате JSON.
635.32 648.96 "Анатолий Кулаков" И с помощью этого файла вы можете создать функциональность, с помощью которой Azure знает все о вашем проекте, то есть знает о том, какие ресурсы необходимо создать для его запуска, знает о том, как развернуть этот проект, и знает о том, как его запустить.
648.96 653.12 "Анатолий Кулаков" То есть одной кнопкой прямо из сэмплов вы можете его развернуть в Azure.
653.12 654.68 "Игорь Лабутин" Ну вообще магия.
654.68 660.92 "Игорь Лабутин" Я вот сейчас смотрю на эти все примерчики, и меня, врат, почему-то куда-то в DriverKit занесло.
660.92 662.32 "Игорь Лабутин" Ну тут тоже прикольно.
662.32 665.16 "Игорь Лабутин" Там есть какой-то пример под названием SPBetaStool.
665.16 668.60 "Игорь Лабутин" Это что-то про Simple Peripheral Bus.
668.60 670.04 "Игорь Лабутин" Звучит прикольно.
670.04 671.04 "Игорь Лабутин" Совпадение?
671.04 672.04 "Игорь Лабутин" Не думаю.
672.04 678.28 "Игорь Лабутин" Тут, конечно, намешано все, и Azure, и DriverA, и Informs, и Excel, Office.
678.28 679.68 "Игорь Лабутин" Ну, в общем, тут все подряд.
679.68 680.68 "Игорь Лабутин" Но масштабно.
680.68 692.12 "Анатолий Кулаков" Это и прекрасно, потому что раньше приходилось это собирать по множеству разным уголкам, а в принципе неплохо бы иметь действительно какую-то одну точку, где ты можешь зайти и через грамотный поиск отыскать все, что тебе нужно.
692.12 693.12 "Игорь Лабутин" Вообще, да, прикольно.
693.12 709.12 "Игорь Лабутин" А, я смотрю, что у них еще многие лежат по отдельным Git-репозиториям, то есть это не единый Git-репозиторий типа CodeSamples, а вот я там конкретно сейчас скликнул там WindowsDriverSamples, или если там глянуть, какой-нибудь тот самый SPBetaStool, он тоже WindowsDriver.
709.12 716.96 "Игорь Лабутин" Короче, у них есть куча-куча-куча мелких репозиториев, чисто для примерчиков, по несколько десятков файлов.
716.96 717.96 "Игорь Лабутин" Ну, прикольно.
717.96 718.96 "Анатолий Кулаков" Прикольно.
718.96 727.56 "Анатолий Кулаков" Физически это распределенные репозитории, это не какой-то один, поэтому они могут подключать к каким угодно сторонним репозиториям, не заставляя их контрибьютировать в какой-то один большой свой.
727.56 731.72 "Анатолий Кулаков" Такая распределенная система samples получается, которая виднена вместе одним вот этим поисковиком.
731.72 734.20 "Игорь Лабутин" Посмотрим, попользуемся.
734.20 743.80 "Игорь Лабутин" Я надеюсь, что Google начнет это все правильно индексировать, и на мои запросы будут теперь не только StackOverflow и Docs.Microsoft.com, но еще и samples.
743.80 748.84 "Игорь Лабутин" Это было бы прикольно, когда прямо тебе на свой запрос как что-то сделать, вываливается сразу готовый примерчик.
748.84 750.36 "Игорь Лабутин" Это было бы вообще супер.
750.36 754.00 "Игорь Лабутин" Но, опять же, удачи с хорошим начинанием.
754.00 755.00 "Игорь Лабутин" Посмотрим.
755.00 760.12 "Игорь Лабутин" Следующая новость, она не такая радостная.
760.12 766.04 "Игорь Лабутин" Тут я углядел, что заканчивает свою жизнь некоторый журнал под названием MSDN Magazine.
766.04 773.84 "Игорь Лабутин" Я, признаться, оттуда если и читал что-то, то только по чуть-чуть, то ли потому что он был как-то не очень доступен, то ли потому что я про него не знал.
773.84 777.68 "Игорь Лабутин" Но я так понимаю, что все, последний выпуск будет в ноябре.
777.68 778.68 "Игорь Лабутин" Сколько лет он?
778.68 780.44 "Игорь Лабутин" Я смотрю, с 2000 года.
780.44 781.44 "Анатолий Кулаков" 19 лет.
781.44 782.44 "Игорь Лабутин" Немало.
782.44 789.64 "Игорь Лабутин" В основном начиналось все с Windows Operating Environment, ну и потихонечку там и про .NET, и про все подряд, я так понимаю, было.
789.64 790.64 "Игорь Лабутин" Про Visual Studio.
790.64 793.48 "Игорь Лабутин" Ты как-то застал, пользовался, читал?
793.48 797.40 "Анатолий Кулаков" Да, меня в начале моей карьеры MSDN Magazine очень сильно выручил.
797.40 805.32 "Анатолий Кулаков" Потому что, когда я начинал, не было нормальной документации, не было нормальных статей, а видео тогда и мечтать вообще никто не мог.
805.32 809.96 "Анатолий Кулаков" И приходилось выбирать статейки из интернета просто практически по одной.
809.96 812.64 "Анатолий Кулаков" И каждый выпуск журнала довольно-таки откровение.
812.64 818.80 "Анатолий Кулаков" То, что постепенно с годами всё меньше и меньше интересных статей начало появляться, это одно.
818.80 826.28 "Анатолий Кулаков" Но то, какой он вклад вложил в эти 19 лет назад, когда он появлялся, это безусловно просто такой огромный пласт.
826.28 839.40 "Анатолий Кулаков" Ну и надо вспомнить, что большинство тех знаменитых авторов, которые мы сейчас знаем, там то же самое Дина Эспозита и множество-множество других, они как раз-таки очень активно пиарились на MSDN.
839.40 844.20 "Игорь Лабутин" Ну, опять же, наверное, действительно бумажная версия сейчас уже не так актуальна.
844.20 853.12 "Игорь Лабутин" Форматировать какой-то электронный вариант в эпоху всеобщих персональных блогов, наверное, тоже что-то лишнее.
853.12 858.64 "Игорь Лабутин" Возможно, они посчитали, действительно, будут больше фокусироваться на благосфере, скажем так.
858.64 874.72 "Игорь Лабутин" И единственное, что, по-моему, у Microsoft уже была история месяца 2 или 3 назад, может быть, полгода уже, когда они как-то стали закрывать какие-то старые архивные блоги, и там все возмутились, так что им пришлось из архива все восстанавливать.
874.72 877.56 "Игорь Лабутин" То есть, главное, чтобы они все эти личные блоги никуда не дели.
877.56 883.52 "Игорь Лабутин" А так, ну, не будет журнальчика, будем собирать по крупицам из блогов, куда денемся.
883.52 893.24 "Анатолий Кулаков" Да, блоги там действительно такие монументальные были, там первые статьи Липерта, которые читаются до сих пор, которые поисковики ищут их до сих пор, и закрывать их просто нельзя.
893.96 906.12 "Анатолий Кулаков" А с MSDN Magazine команда решила сосредоточиться больше на существующей электронной документации, которую мы с вами уже выше обсуждали, это докс с Microsoft.com и на DevBlocks.
906.12 914.20 "Анатолий Кулаков" Поэтому, если кто скучает по ним, можно следить за новыми материалами на этих микрософтовских ресурсах.
914.20 924.80 "Анатолий Кулаков" Хотя я думаю, что действительно, последнее поколение, так сказать, нынче живущие разработчики, они о таком журнале даже не слышали, потому что в надобности он давно-давно отпал, уже много лет как.
924.80 930.28 "Игорь Лабутин" Ну да, возможно, кому-то из совсем начинающих интересно почитать, но не более того.
930.28 938.36 "Игорь Лабутин" Ладно, давайте перейдем к более интересным и, так скажем, позитивным новостям, хотя позитивность тут тоже под вопросом.
938.36 952.60 "Игорь Лабутин" А именно, Microsoft на тех самых DevBlocks'ах заанонсировала изменения в схему инсталляции .NET Core SDK и Visual Studio, пока все это на Windows.
952.60 956.40 "Игорь Лабутин" Давайте сначала обсудим, как оно работает сейчас.
956.40 964.56 "Игорь Лабутин" А насколько я знаю, сейчас все SDK, которые вы хотите поставить, вы можете ставить сайт-бай-сайт.
964.56 976.84 "Игорь Лабутин" То есть, у вас может жить много разных релизнутых версий, у вас может быть еще пачка превьюшек от разных версий, и все это счастливо живет вместе, указываете нужную версию SDK и все прекрасно работает.
976.84 982.20 "Игорь Лабутин" Исполняя .NET Core 3.0 превью 7, поведение анонсируется, что изменится.
982.20 989.16 "Игорь Лабутин" И теперь превью 7 и более поздние версии будут удалять при своей инсталляции предыдущие превью.
989.16 992.88 "Игорь Лабутин" То есть, теперь нельзя будет держать превью 8 и превью 9 одновременно.
992.88 994.84 "Игорь Лабутин" Можно держать только последнюю превьюшку.
994.84 1008.52 "Игорь Лабутин" Вероятно, это из-за того, что Microsoft стала считать, что а) это все сложно слишком поддерживать, б) превью 7 и дальше достаточно стабильно, чтобы не было необходимости проверять совместимость, просто обновлять последнюю превью и все хорошо.
1008.52 1014.72 "Игорь Лабутин" Все было бы не так может быть масштабно, если бы не одно "но".
1014.72 1021.76 "Игорь Лабутин" Visual Studio традиционно использовала ту версию SDK, .NET Core SDK, которая у вас стояла.
1021.76 1036.92 "Игорь Лабутин" Теперь Visual Studio будет ставить себе свою собственную .NET Core SDK, она будет ставиться в ту же папочку .NET, как и все остальные SDK, которые вы сами ставите, но контролироваться я вижу в студии, то есть она сама ее будет обновлять себе, если вы накатываете какие-то апдейты на студию.
1036.92 1040.04 "Игорь Лабутин" И если вы удалите студию, то эта SDK тоже удалится.
1040.04 1055.84 "Игорь Лабутин" Это важно, потому что нельзя теперь взять и почистить просто папочку .NET, и кроме того, в папочке .NET у вас будет одна запись, для которой не будет записи в Adream of Programs, или как там сейчас по-современному, Programs and что-то там.
1055.84 1057.64 "Анатолий Кулаков" Вот такие вот дела.
1057.64 1059.28 "Анатолий Кулаков" Какая-то пугающая тенденция.
1059.28 1063.12 "Анатолий Кулаков" Мне не нравится, когда инструменты начинают приносить с собой свою SDK.
1063.12 1072.36 "Анатолий Кулаков" Это вот первый шаг на пути к тому, что они начнут его под себя потом патчить, потом он станет несовместимым, потом будут какие-то конфликты, и вот это и прочие все вещи.
1072.36 1081.04 "Игорь Лабутин" На самом деле, с моей точки зрения, тот факт, что студия тащит себе свою собственную SDK и runtime, на который она работает, это может быть и ок.
1081.04 1089.12 "Игорь Лабутин" В конце концов, довольно сложно, может быть, им было заставить работать студию на произвольном runtime, который там пользователи соизволил поставить.
1089.12 1095.48 "Игорь Лабутин" Я так понимаю, что в мире Java, например, более-менее окей тащить себе свою версию Java на JRE.
1095.48 1101.44 "Игорь Лабутин" Но, что мне не нравится, это тот факт, что студия ставит ее туда же, куда .NET, в общую папочку.
1101.44 1107.36 "Игорь Лабутин" То есть, ставила бы она себя куда-нибудь там в Debris, в Program Files, куда-нибудь подальше, и окей.
1107.36 1115.64 "Игорь Лабутин" Она там ее себе спокойно мониторит, я не вижу этой версии SDK, я не могу ее затаргетить из своих приложений и так далее.
1115.64 1120.56 "Игорь Лабутин" А так будет получаться, что я затаргетил версию, там обновил студию, и вот у меня версия там обновилась.
1120.56 1122.16 "Игорь Лабутин" И будет не очень.
1122.16 1129.96 "Игорь Лабутин" Мне кажется, что это как-то вот странно иметь свой runtime, который ставится в общую кучу, куда я могу затаргетить кто угодно, что угодно.
1129.96 1135.08 "Анатолий Кулаков" А вот не надо было опускаться до уровня Java, как бы, и начинать делать такие же подобные глупости.
1135.08 1138.80 "Анатолий Кулаков" Ты IDE, ты должна работать так же, как и остальные .NET программы.
1138.80 1144.44 "Анатолий Кулаков" Требуешь минимальную версию, которая должна быть установлена в системе, а все остальное ты должна поддерживать.
1144.44 1146.20 "Анатолий Кулаков" По-моему, нормальное, разумное требование.
1146.20 1152.04 "Игорь Лабутин" Ну, с какой-то стороны, да, с другой стороны, возможно, в текущем мире быстро меняющегося надкора это было очень сложно выдержать.
1152.04 1158.76 "Игорь Лабутин" То есть, возможно, им нужны уже, они скорее всего очень хотят фичи надкор 3, про всякие там спаны и вот это все.
1158.76 1162.68 "Игорь Лабутин" При этом требовать от всех, чтобы поставили минимум надкор 3, ну, не знаю.
1162.68 1168.72 "Игорь Лабутин" Но пока я вот не нашел так сходу, с какой версии студии это будет применимо.
1168.72 1170.80 "Игорь Лабутин" Сейчас, может быть, я что-то обширю.
1170.80 1174.24 "Игорь Лабутин" А, нет, это начинается с 16.3 превью 1.
1174.24 1175.24 "Анатолий Кулаков" Вот.
1175.24 1176.88 "Анатолий Кулаков" Какую-нибудь версию фреймворка она будет с собой таскать.
1176.88 1180.40 "Игорь Лабутин" Так, сейчас посмотрим.
1180.40 1182.40 "Анатолий Кулаков" Какой-нибудь 1.0?
1182.40 1184.40 "Игорь Лабутин" Нет, нет.
1184.40 1187.40 "Игорь Лабутин" Visual Studio Workloads, бла-бла-бла.
1187.40 1190.20 "Игорь Лабутин" 3.0 Runtime она по дефолту будет ставить.
1190.20 1194.88 "Игорь Лабутин" Если нужны 2.1, 2.2, то вы галочками добавляете в инсталляторе и она их тоже поставит.
1194.88 1195.88 "Анатолий Кулаков" Ну, неплохо.
1195.88 1203.12 "Анатолий Кулаков" Будем надеяться, что Visual Studio использует внутри себя реально третий фреймворк и использует все те оптимизации, которые в нем появились.
1203.12 1205.48 "Анатолий Кулаков" Кстати, появилось в нем очень много чего.
1205.48 1215.12 "Анатолий Кулаков" Я думаю, чтобы нам во время релиза третьего кора просто не сойти с ума, мы должны уже начинать обсуждать его фичи постепенно в наших подкастах.
1215.12 1217.44 "Анатолий Кулаков" Что мы, собственно, и начали делать в прошлых выпусках.
1217.44 1234.12 "Анатолий Кулаков" И я предлагаю продолжить, потому что я тут наткнулся на интереснейший видосик, где Дэвид Фаулер и Дэмион Эдвардс, это знаменитые авторы из Микрософта, то есть они и контрибютят в фреймворк, и очень много выступают со своими презентациями, сделали отличный доклад.
1234.12 1235.60 "Анатолий Кулаков" Игорь, ты его смотрел?
1235.60 1243.68 "Игорь Лабутин" Да, я смотрел, вообще шикарный доклад, даже если не брать в расчет контент, даже сама подача весело, бодро.
1243.68 1246.12 "Игорь Лабутин" Делать доклад на двоих, на самом деле, очень сложно.
1246.12 1257.36 "Игорь Лабутин" У них там и во время демок что-то шло не так, и много чего, и ноутбук выключить во время, в середине презентации это норм, но при этом все равно смотрится вообще шикарно.
1257.36 1260.76 "Игорь Лабутин" Уместить в час такое количество информации, ну, они крутые.
1260.76 1274.68 "Анатолий Кулаков" Я с тобой согласен, отдельно заслуживает похвала их презентационной скиллы, потому что выглядит все так, как будто они не очень хорошо подготовились и очень плохо себя неуверенно чувствуют на сцене, но на самом деле это не так.
1274.68 1285.48 "Анатолий Кулаков" Люди очень профессиональные, и то, как они себя ведут расслабленно на сцене говорит как раз о том, что они очень хорошо контролируют ситуацию и очень хорошо понимают, какие косяки не допустили, и как качественно их исправить.
1285.48 1303.12 "Анатолий Кулаков" Если вам вдруг интересны публичные выступления, то в качестве вот одного из тех форматов, когда не выходит какой-то лектор и начинает вам читать идеально отрепетированный текст, а вот как идут именно живые презентации, какие могут быть фокапы, и как из них правильно выходить, вот это видео тоже заслуживает отдельного просмотра.
1303.12 1306.44 "Анатолий Кулаков" Но все-таки давай мы с тобой остановимся на технической части.
1306.44 1307.92 "Анатолий Кулаков" Что тебя привлекло больше всего?
1307.92 1323.32 "Игорь Лабутин" Ну, я думаю, что мы можем пойти по порядочку, и вся презентация была разделена на 4 блока, от самых низов до самого верха, и начать с низов, то есть это Corsair LAR, это наш любимый garbage collector, вот это все.
1323.32 1330.40 "Игорь Лабутин" Во-первых, теперь для Corsair LAR есть куча новых ручек, которые можно покрутить.
1330.40 1349.08 "Игорь Лабутин" Да, garbage collector, с которым можно покрутить ручки, попробовать заставить его кушать меньше памяти, то есть срабатывать на чуть более ранних этапах, и таким образом ваше приложение, если у него достаточно такой лайтовый режим потребления памяти, сможет кушать ее гораздо меньше.
1349.08 1353.28 "Игорь Лабутин" И новые дефолты, кстати, они подкручены довольно сильно.
1353.28 1364.88 "Игорь Лабутин" Кроме того, вообще довольно много изменений вокруг загрузки стартапов и всего остального, про загрузку и сборки мы поговорим чуть позднее, наверное.
1364.88 1371.36 "Игорь Лабутин" А вот что меня не то что порадовало, заинтересовало, это стартап hookie.
1371.36 1385.68 "Игорь Лабутин" Я не очень понял, зачем такая классная штука, но теперь можно сделать свой класс, он должен быть обязательно internal, называть его startup hook, и тогда его метод initialize будет гарантированно вызван перед main.
1385.68 1402.36 "Анатолий Кулаков" Насколько я понял, это нужно именно для инструментария, то есть допустим, если вы используете какую-то систему мониторинга, которой нужно обязательно проинструментировать ваш код, и при этом до того, как запустится первый метод main, главный метод main, вот это как раз-таки для них.
1402.36 1411.44 "Анатолий Кулаков" Я пока тоже себе на практике слабо это представляю, потому что не писал подобных инструментов, но если появится такая возможность, я думаю, что-то поэкспериментировать придется.
1411.44 1430.60 "Игорь Лабутин" Ну вообще, кстати, про диагностики там тоже довольно много всяких разных улучшений, то есть они добавили API, которые позволяют получать информацию про garbage collector и прочую статистику, и казалось бы, они у нас были, но они у нас были только в формате либо GTV, либо performance мониторов, и все это было Windows-специфик.
1430.60 1437.88 "Игорь Лабутин" Сейчас оно теперь стало кроссплатформенным и позволяет под любой осью получить информацию, как там живет ГЦ.
1437.88 1442.48 "Игорь Лабутин" Кроме того, добавилось несколько новых команд в утилиту .NET.
1442.48 1444.52 "Игорь Лабутин" Во-первых, теперь можно делать дампы.
1444.52 1447.16 "Игорь Лабутин" Опять же, это, насколько я понимаю, кроссплатформенно.
1447.16 1449.12 "Анатолий Кулаков" Да, именно так, дампы кроссплатформенные.
1449.12 1474.80 "Игорь Лабутин" И их можно даже немножко анализить, то есть можно сказать .NET dump analyze, и вы попадаете в некоторый такой environment, очень похожий на винт ДБГ с SOS расширением, где можно всякие там командочки запускать, стеки посмотреть, потоки, то есть такой винт ДБГ для очень бедных, но зато кроссплатформенно и можно с этим как-то в нештатной ситуации поработать.
1474.80 1483.80 "Анатолий Кулаков" Кроссплатформенно, это значит, что не только вы можете использовать его на двух платформах, но и вы можете, например, под Windows-ом дамп снять и пойти под Windows-ом проанализировать, то есть это тоже работает.
1483.80 1501.68 "Игорь Лабутин" Да, но под Windows-ом справедливости ради проще дамп по возможности открывать Visual Studio, это там тоже работает, он там будет использовать всю мощь Visual Studio тулов для показа CPU профилей и всего остального, но в целом, да, все работает.
1501.68 1508.76 "Игорь Лабутин" В основном, конечно, направление интересно с Linux на Windows, потому что Visual Studio, она пока в основном Windows only.
1508.76 1517.60 "Анатолий Кулаков" Да, потому что под Linux-ом нет, насколько я понимаю, хороших именно визуализаторов, редакторов и просмотрщиков, такой трассировочной дамповой информации.
1517.60 1520.24 "Игорь Лабутин" Ну, может, что появится рано или поздно.
1520.24 1527.16 "Игорь Лабутин" И еще одна опция из раздела Core CLR, это новые опции про паблиш.
1527.16 1545.16 "Игорь Лабутин" Мы на самом деле немножко их затрагивали в прошлый раз, про паблиш стрим, то, что она умеет теперь делать некоторые трешей и убирать неиспользуемые ассимбли, но они сделали более клевую фишку, теперь можно делать так называемые ready-to-run имиджи.
1545.16 1563.96 "Игорь Лабутин" Это та штука, которая в момент сборки вы указываете дополнительную архитектуру, непосредственно на которой ваше приложение собирается исполняться, и в сборку попадает как обычный IL-код, как он там и должен быть, но и заодно еще декомпилированный под вашу архитектуру бинарный код.
1563.96 1565.32 "Игорь Лабутин" Так что, в принципе, JIT уже и не нужен.
1565.32 1567.32 "Анатолий Кулаков" Да, это отличная функциональность.
1567.32 1572.52 "Анатолий Кулаков" Таких ключевых моментов работы с файлами и конечным аутпутом всего три штуки.
1572.52 1577.68 "Анатолий Кулаков" Во-первых, это ready-to-run, который создает вам бинарник, независимый от платформы.
1577.68 1582.52 "Анатолий Кулаков" Во-вторых, это single file, который позволяет вам все эти бинарники объединить в один единственный файл.
1582.52 1593.52 "Анатолий Кулаков" И в-третьих, это trimming, который позволяет вам затримить ненужные бинарники, ненужные дллки и значительно сократить результирующий аутпут вашей библиотеки или вашего программного продукта.
1593.72 1600.32 "Игорь Лабутин" Да, но ready-to-run это на самом деле не только просто бинарник, готовый для исполнения на любой платформе.
1600.32 1608.92 "Игорь Лабутин" Он готов на исполнение для любой платформы, потому что там есть нормальный лид-код, но он чуть более оптимизирован под ту платформу, которую вы указали при вашей сборке.
1608.92 1610.96 "Игорь Лабутин" Но на этом еще не все.
1610.96 1653.12 "Игорь Лабутин" Как мы помним, в .NET Core 3.0 появилась такая функциональность как TireJIT, то есть, по сути, JIT, который работает, может пер-JIT-евать один и тот же код несколько раз, и это работает ровно таким образом, что если при запуске вашей сборки, которая скомпилирована с ready-to-run опцией, у платформы совпало все дела, то используется тот код, который был получен в результате сборки, и JIT не используется, но когда накопится некая статистика и понимание, что является hotpath в вашем приложении уже в рантайме, то эти кусочки из il-кода могут JIT-ом пер-JIT-иться в какой-то чуть более оптимальный вариант.
1653.12 1667.56 "Игорь Лабутин" И таким образом вы получаете в среднем быстрее код для всех путей, потому что он у вас есть в бинарном и нативном виде, плюс особо горячие кусочки вам еще и под-JIT-ят на лету более оптимально.
1667.56 1672.04 "Игорь Лабутин" Так что вообще прям перформанс должен быть на уровне, не знаю, круче всех.
1672.04 1679.60 "Анатолий Кулаков" Ну, я так понял, что reJIT, он работает не только с опцией reJIT-ером, да, он работает вообще в принципе в новом Core 3 всегда?
1679.60 1693.00 "Игорь Лабутин" Вроде как да, но я думаю, что его там, я помню, что его то включали, то выключали по-моему по превьюшкам, и в каких-то их нужно было, его нужно было принудительно включать, чтобы он заработал.
1693.00 1701.04 "Игорь Лабутин" Я, к сожалению, сейчас не знаю текущего статуса, давно не игрался с NETCORE 3, жду официального анонса и там посмотрим.
1701.04 1703.32 "Анатолий Кулаков" Я думаю, да, это мы увидим после официального анонса.
1703.32 1711.12 "Анатолий Кулаков" А еще мы с тобой обсуждали в прошлый раз, что оптимизация сборок происходит именно на уровне только сборок.
1711.12 1713.68 "Анатолий Кулаков" И ты мечтал там, что они заюзают Monolinker.
1713.68 1717.36 "Анатолий Кулаков" И насколько я понял из этой презентации, что Monolinker они все-таки заюзали.
1717.36 1726.36 "Анатолий Кулаков" И обещают к релизу третьему нам выдать полноценную функциональность, которая с помощью Monolinker позволяет обрубать ненужную информацию.
1726.36 1728.48 "Анатолий Кулаков" Это как раз таки флаг Publish Treemant.
1728.48 1733.56 "Игорь Лабутин" Ну вот в том варианте, как он сейчас зарелижен, это только на уровне отрубить целую сборку.
1733.56 1738.16 "Игорь Лабутин" Если они сделают возможность выпилить из сборки все ненужные типы, это вообще будет супер.
1738.16 1742.24 "Анатолий Кулаков" Вот, мне казалось, что они говорили про Monolinker, про Mono и что вот это именно он.
1742.24 1743.24 "Анатолий Кулаков" Хорошо, пойдем дальше.
1743.24 1744.92 "Анатолий Кулаков" Второй раз делал BCL.
1744.92 1752.52 "Игорь Лабутин" Так, BCL, Base Class Library, ну там есть всякие штуки, которые уже много раз кто описывал, это всякие, Icing Disposable.
1752.52 1754.32 "Игорь Лабутин" Меня зацепило три вещи.
1754.32 1757.88 "Игорь Лабутин" Меня зацепила вещь Runtime Feature Detection.
1757.88 1787.92 "Игорь Лабутин" И если вы пишете код под какой-нибудь стандартный виндовый сервер, то вам, скорее всего, это не очень интересно, а вот если вы пишете на чем-нибудь более кросс-платформенном или под что-то, что должно запускаться непонятно где, то вам может понравиться тот факт, что теперь можно прямо из Runtime проверить, а вообще, что происходит, что Runtime делает с динамик-кодом, который вы имитите на лету.
1787.92 1808.60 "Игорь Лабутин" Во-первых, вам могут сказать, в принципе, поддержан он или нет, потому что есть среды исполнения, где невозможно на лету скомпилировать или интерпретировать ничего, а есть среды исполнения, где то, что вы нагенерили там или митом, или еще каким-нибудь вариантом кода генерации, он не компилируется, а именно интерпретируется, ну и соответственно будет исполняться медленнее.
1808.60 1816.36 "Игорь Лабутин" Хотя очень часто такие штуки используются для оптимизации скорости, а можете попасть на тот факт, что он будет интерпретироваться и все будет работать еще медленнее.
1816.36 1818.72 "Игорь Лабутин" Теперь это можно проверить в Runtime.
1818.72 1822.96 "Игорь Лабутин" Есть 2 проперти, Dynamic Code Compiled и Dynamic Code Supported.
1822.96 1825.72 "Анатолий Кулаков" Я хотел бы влезти в типичный пример, это iOS-приложение.
1825.72 1835.20 "Анатолий Кулаков" Вот на iOS вам Apple запрещает генерировать какой-то динамический код, и все, что вы можете запустить, оно должно распространяться через их магазин в их проверенном и зафриженном состоянии.
1835.20 1837.08 "Анатолий Кулаков" Вот теперь вы можете задетективать.
1837.08 1839.28 "Анатолий Кулаков" Можете вы это сделать или не можете сделать?
1839.28 1852.00 "Игорь Лабутин" Да, или в зависимости от того, скомпилировались ли вы под iOS или ваша общая какая-то библиотечка бизнес-логики скомпилирована под ваше обычное аутентное приложение на Виндах, оно сможет использовать всю мощь код генерации, если ей это нужно.
1852.00 1857.00 "Игорь Лабутин" Так, дальше есть некоторые улучшения по ThreadPool.
1857.00 1861.72 "Игорь Лабутин" Во-первых, можно кьюить всякие штуки в ThreadPool без учета execution-контекста.
1861.72 1871.52 "Игорь Лабутин" Execution-контекст нас сейчас преследует везде, потому что именно через него передается всякая инфа про таски, continuation, как я понимаю, и все такое.
1871.52 1874.08 "Анатолий Кулаков" И именно он тормозит все ваши асинхронные программы.
1874.08 1882.56 "Игорь Лабутин" Ну да, теперь можно на него забить и, используя метод unsave queue work_item, по-моему, называется, заширлить все в обход execution-контекста.
1882.56 1894.48 "Игорь Лабутин" То есть это такой, как будто вы из-за синк-метода сказали грубо task_run и передали туда новый инстанс-шедулер, который ничего не знает про текущие контексты и все такое.
1894.48 1913.32 "Игорь Лабутин" А кроме того, появилась возможность реализовывать специальный интерфейс iThreadPool.work_item, который имеет, по-моему, один-единственный метод execute, и это будет чуть более оптимально, чем текущий вариант, когда мы скедуем, по-моему, просто обычную лямбду по старинке, оставшуюся со времен чуть ли не дотнета первого, наверное, или второго.
1913.32 1928.00 "Анатолий Кулаков" Более того, они уже заюзали его для Kestrel, и Kestrel как раз-таки использует iThreadPool.work_item, имплементацию, для того, чтобы передать все миллионы входящих запросов на ThreadPool и при этом не порождать никаких новых объектов.
1928.00 1932.28 "Анатолий Кулаков" То есть это позволяет организовать allocation-free алгоритмы, например.
1932.28 1940.56 "Игорь Лабутин" Ну да, если у вас как-то очень активно используется ThreadPool, то можно посмотреть в эту сторону, возможно, что вы там что-то сможете выиграть.
1940.56 1954.08 "Игорь Лабутин" И третья штука, которая меня зацепила, но я думаю, что, Толя, ты про нее должен рассказывать гораздо лучше, потому что у тебя было несколько докладов даже, практически про это, или близко к этому, по крайней мере, на Threadnext, это про distributed tracing.
1954.08 1969.60 "Анатолий Кулаков" Да, обалденная вещь, в принципе, я тоже ей много занимался, и что хочется отметить, в стандартную поставку ISP, ISP.NET и в BCL внесена поддержка так называемых распределенных трейсингов.
1969.60 1974.12 "Анатолий Кулаков" Это позволяет вам оформить одну активность между различными вашими сервисами.
1974.12 1998.16 "Анатолий Кулаков" Допустим, если в вашем микросервисе участвуют такие подсервисы, как там frontend, backend, база данных, сервис авторизации, сервис хранения, сервис фоточек, вы это все можете залогировать, используя один и тот же correlation ID, а потом, в конце концов, взять этот correlation ID, связать все эти запросы воедино и на одной картине увидеть, какой сервис сколько времени занял, где тупил, какие ошибки выдал, какие логи написал.
1998.16 2008.00 "Анатолий Кулаков" То есть он позволяет из всей вашей картины микросервисов собрать вот такую целостную, полноценную цепочку вызовов, которые можно увидеть на одной картине и, соответственно, разложить по разным диагностикам.
2008.00 2010.64 "Анатолий Кулаков" Вся эта тема называется distributed tracing.
2010.64 2021.10 "Анатолий Кулаков" У нас существует множество проектов, которые пытались ее поддержать, имплементировать и так далее, но в конце концов они все закрылись и объединились под общим названием OpenTelemetry.
2021.10 2046.28 "Анатолий Кулаков" Здесь еще стоит отметить, что все эти протоколы, они не просто придуманы Microsoft, они поддерживаются сейчас активно в комьюнити и, более того, существует отдельная спецификация WF3C, которая называется trace context, которая декларирует, каким образом trace contexts должны передаваться между различными приложениями, какие заголовки должны иметь в HTTP протоколе и так далее.
2046.28 2054.64 "Анатолий Кулаков" То есть это не какая-то кастовная поделка на коленке, это уже такой формат, который общепризнанный и поддерживается многими интересными инструментами.
2054.64 2067.88 "Анатолий Кулаков" В будущем это будет только расширяться и укрепляться, поэтому я думаю, что это отличная инициатива на таком раннем этапе развития этого протокола, этого проекта, в таком раннем этапе, внедрить это непосредственно в саму библиотеку BCL.
2067.88 2079.84 "Игорь Лабутин" Да, звучит здорово, дальше это надо все… А, ну, я так понимаю, что раз это все OpenTelemetry, то, соответственно, визуализация всего этого тоже наверняка есть куча стандартных тулов, куда все это можно сгрузить и потом смотреть.
2079.84 2085.44 "Анатолий Кулаков" Да, есть уже базы данных, есть уже анализатор, есть визуализаторы, Zipkines и прочие глупости.
2085.44 2086.92 "Анатолий Кулаков" Я думаю, мы о них в принципе попозже поговорим.
2086.92 2090.48 "Игорь Лабутин" Окей, тогда погнали дальше.
2090.48 2094.08 "Игорь Лабутин" Идем выше по стеклу и раздел ASP.NET Core.
2094.08 2102.32 "Игорь Лабутин" Здесь в основном все касается довольно-таки низкоуровневых штук относительно ASP.NET.
2102.32 2112.08 "Игорь Лабутин" То есть появилась возможность смотреть на переменные EASA, если вы до сих пор под ним хоститесь, то можно теперь взять и посмотреть все, что там в EASA сконфигурено.
2112.08 2132.00 "Игорь Лабутин" Можно теперь настраивать довольно тонко на контроллерах, как эти контроллеры, как реквесты, соответствующие нужным методам контроллера будут исполняться в зависимости от того, на какой хост и порт пришел запрос.
2132.00 2141.20 "Игорь Лабутин" То есть можно сделать так, что у вас есть два метода контроллера, которые исполняются в зависимости от того, на какие порты вообще пришел запрос, а не только какой-то мурл дальше.
2141.20 2148.12 "Анатолий Кулаков" Раньше, я так понимаю, можно было это делать только по непосредственно IP-патху, то есть по части, которая после порта идет.
2148.12 2151.88 "Игорь Лабутин" Да, теперь можно по имени и порту.
2151.88 2172.12 "Игорь Лабутин" Мы, кстати, такое используем в ВЦФ стареньком нашем, для того чтобы кучу наших сервисов от разных инстансов жить все на 4.4.3, условно говоря, чтобы для всех пользователей казалось, что все нормально и просто выдаем от нового и тому же паблика IP-шника кучу DNS.
2172.12 2176.72 "Игорь Лабутин" И тогда по DNS можно знать, кто вообще пришел.
2176.72 2180.32 "Анатолий Кулаков" О, а еще безумная идея, можно использовать ПОК-порт в качестве версии.
2180.32 2184.96 "Анатолий Кулаков" Вот у тебя версия 101, ты потом версию поменял, у тебя теперь контроллер жив на порту 102.
2184.96 2187.56 "Анатолий Кулаков" А на порту 101 по-прежнему живут старые контроллеры.
2187.56 2189.40 "Игорь Лабутин" Ух ты, об этом я не думал.
2189.40 2201.16 "Игорь Лабутин" Так, дальше, из таких довольно мелочей, с моей точки зрения, но тем не менее, для GRPC потребовалась такая фича, как Trailing Headers.
2201.16 2212.00 "Игорь Лабутин" То есть, на самом деле, насколько я понял, стандарт Http позволяет послать хедеры, они хоть и называются хедеры, то есть заголовки, их можно послать в конце, после того, как вы послали body.
2212.00 2215.04 "Анатолий Кулаков" Да, но, к сожалению, ASP.NET такого раньше не позволял.
2215.04 2219.92 "Игорь Лабутин" Теперь можно, пришлось сделать для GRPC, и я так понимаю, это заинейбли, грубо говоря, глобально для всего.
2219.92 2224.72 "Игорь Лабутин" Говорят, полезно, чтобы слать всякую статистику, сколько там заняла обработка запроса и так далее.
2224.72 2228.68 "Игорь Лабутин" Не знаю, у меня пока не встречалось юзкейза для этого, но посмотрим.
2228.68 2238.40 "Анатолий Кулаков" Например, да, очень часто у тебя тот же самый GitHub, он шлет время, которое ему понадобилось на формирование твоего body, то есть на формирование ответа, респонса.
2238.40 2246.32 "Анатолий Кулаков" И, соответственно, это время логичнее всего засунуть как бы в хедера, потому что для этого они и существуют, для передачи специальной информации.
2246.32 2247.64 "Анатолий Кулаков" Это не часть body.
2247.64 2257.00 "Анатолий Кулаков" Но в хедера ты это засунуть не мог, потому что, чтобы померить время, тебе нужно сначала сформировать body, а после того, как body сформировано, уже, соответственно, начал отправляться респонс.
2257.00 2259.56 "Игорь Лабутин" Либо мне его надо целиком формировать в памяти.
2259.56 2267.16 "Анатолий Кулаков" Да, либо тебе нужно двойное потребление памяти, сначала ты формируешь респонс, а потом копируешь его непосредственно в ответ, не в стрим.
2267.16 2270.52 "Игорь Лабутин" Ну, посмотрим, может быть что-то изменится.
2270.52 2283.68 "Игорь Лабутин" А еще я с удивлением узнал, что, оказывается, в S/Panet Core, это я знал, поддержана компрессия этих респонсов, респонсов-реквестов, но респонсов в основном.
2283.68 2287.52 "Игорь Лабутин" И вроде, как я понял, по дефолту она была выключена в ваш ТТПС.
2287.52 2302.44 "Игорь Лабутин" То есть, если вы используете наш ТТПС, то компрессия по дефолту выключена, потому что были найдены какие-то уязвимости, и если у вас включена компрессия в ТТПС, то там что-то можно было узнать про ваши сертификаты и как-то, в общем, навредить.
2302.44 2312.08 "Игорь Лабутин" Теперь появилась опция, когда можно принудительно сказать S/Panet, что да, тут нет никаких секьюрных данных, включай компрессию, даже если здесь аж ТТПС.
2312.08 2313.64 "Игорь Лабутин" Наверное, это что-то сэкономит.
2313.64 2316.84 "Игорь Лабутин" Особенно для всяких ресурсов, видимо, это там картинок и прочего будет полезно.
2316.84 2320.08 "Игорь Лабутин" Ну, в принципе, по S/Panet Core более-менее все.
2320.08 2323.44 "Игорь Лабутин" Из такого интересного есть еще раздел.
2323.44 2326.88 "Игорь Лабутин" Всякое разное, но, возможно, у тебя есть еще что-нибудь про S/Panet.
2326.88 2330.68 "Анатолий Кулаков" Ну, а еще по S/Panet Core мне понравилась тема про выделение Kestrel API.
2330.68 2341.04 "Анатолий Кулаков" Разработчики Kestrel подумали, что, в принципе-то, функциональность Kestrel довольно-таки универсальная, и многие другие продукты захотят ее вполне использовать.
2341.04 2349.60 "Анатолий Кулаков" То есть очень эффективно, очень быстро обрабатывать какие-то потоки информации, обрабатывать какие-то стримы байтов через входящие endpoints.
2349.60 2352.84 "Анатолий Кулаков" То есть обрабатывать рекресты, отдавать респонсы.
2352.84 2356.28 "Анатолий Кулаков" Это много где нужно, даже за пределами Kestrel.
2356.28 2358.44 "Анатолий Кулаков" Просто если вы пишете, например, свой протокол.
2358.44 2365.04 "Анатолий Кулаков" И они выделили Kestrel API в так называемый отдельный public API, который ваши программы теперь могут использовать.
2365.04 2368.00 "Анатолий Кулаков" Это все довольно красиво и довольно удобно.
2368.00 2375.08 "Анатолий Кулаков" Я надеюсь, что у нас появится больше таких быстрых сервисов, которые способны молотить большие потоки информации.
2375.08 2386.64 "Игорь Лабутин" Да, эта штука написана так, что ее интерфейс и, в общем, вся ее, так скажем так, реализация независима от того, какой канал вы используете внутри.
2386.64 2400.08 "Игорь Лабутин" То есть она, по сути, представляет собой некоторую абстракцию над некоторыми каналами или, ну, можно сказать, сокетами, которые оперируют просто байтами туда-сюда.
2400.08 2410.48 "Игорь Лабутин" А как внутри эти байты пересылаются, будет ли это TCP, будет ли это HTTP, будет ли еще что-то странное, это уже дело как бы того, что запихнете туда внутрь в качестве endpoint.
2410.48 2414.04 "Игорь Лабутин" Естественно, всякие стандартные IP-endpoints и прочее поддерживаются.
2414.04 2417.20 "Игорь Лабутин" Вы можете поверх стандартного TCP-endpoint это все сделать.
2417.20 2421.04 "Анатолий Кулаков" Еще монументальная вещь, которая появилась, это отказ от libuv.
2421.04 2429.04 "Анатолий Кулаков" Если кто помнит, это такая библиотека, которая позволяла оперировать к кестрелу на Linux с Unix domain сокетами.
2429.04 2441.00 "Анатолий Кулаков" Вот, теперь эту абстракцию выкинули, .NET напрямую общается с Unix domain сокетами, и от этого данное взаимодействие стало еще быстрее.
2441.00 2461.04 "Анатолий Кулаков" Также у нас зарелились такие интересные компоненты, как BodyReader, BodyWriter, которые работают непосредственно со стримом кестрела, для того, чтобы читать и писать информацию непосредственно со спанами, и больше не используется SystemStreams, которые для этих целей оказались не так эффективны, как чистые спаны.
2461.04 2466.04 "Анатолий Кулаков" И, соответственно, мы тоже теперь в своих продуктах можем использовать эти замечательные классы.
2466.04 2473.04 "Игорь Лабутин" Я так понимаю, что это как раз кусочек того самого AppUt, который кестрел выделил из себя.
2473.04 2476.48 "Игорь Лабутин" Про BodyReader, BodyWriter, вроде в примерочке что-то такое видел.
2476.48 2479.64 "Игорь Лабутин" Ну, да, посмотрим, куда заведут нас пайплайны.
2479.64 2484.32 "Игорь Лабутин" А пока пойдем в другую степь, а именно, всяко-разно.
2484.32 2488.40 "Игорь Лабутин" И всяко-разно здесь в основном все про конфигурацию.
2488.40 2502.56 "Игорь Лабутин" А именно, появилась такая штука, можно у Configuration Root сказать GetDebugView, и вам задампят все ваши значения конфигурации со всеми источниками, откуда они были взяты.
2502.56 2509.76 "Игорь Лабутин" То есть, это такой способ получить, откуда все конфигурационные значения ваше SPNet-приложение взяло.
2509.76 2517.36 "Игорь Лабутин" Что-то из глобальных штук, что-то из Environment переменных, что-то из вашего JSON-настроек, что-то еще откуда-то.
2517.36 2521.20 "Игорь Лабутин" Я пока еще не попробовал, но звучит прям вообще волшебно.
2521.20 2523.32 "Игорь Лабутин" Для дебага сценариев должно быть прям супер.
2523.32 2540.08 "Анатолий Кулаков" Слушай, это отличная штука, потому что действительно, как только у тебя появляется что-то больше, чем один файл, у тебя это появляется сразу, потому что у тебя есть Environment, у тебя есть командная строка, и у тебя есть как минимум еще пару файлов, то совсем непонятно, кто это переписал, откуда оно взялось, как оно к нам попало, и почему именно эта версия считается актуальной.
2540.08 2549.04 "Анатолий Кулаков" Поэтому мы в своем проекте сделали такую штуку ручками, мы сами это выдираем там жесткими хаками и показываем в нашем дебаг-вью.
2549.04 2554.28 "Анатолий Кулаков" Но после того, как появится стандартный просмотрчик, это будет просто волшебно.
2554.28 2555.84 "Анатолий Кулаков" Поэтому я очень рад.
2555.84 2584.80 "Игорь Лабутин" Вторая штука тоже касается, по сути, такой девелоперской помощи, а именно после того, как вы зарегистрировали всех возможных сервис-провайдеров, заинжектили все, что хотите в вашем стартапе, значит, ЦС или где-то еще, вы можете теперь вызвать такой метод, называется service-provider-options.validate-on-build, и он проверит, что для всех сервисов хватает всех зависимостей.
2584.80 2596.28 "Игорь Лабутин" То есть он не будет, естественно, ничего никуда создавать, но он, по крайней мере, пробежится по всем нужным конструкторам, которые могут вызваться, если попытаться создать instance того или иного класса, и проверит, что все зависимости тоже зарегистрированы.
2596.28 2604.88 "Игорь Лабутин" Наверное, это очень важно и удобно для каких-нибудь там плагинных систем, еще чего-нибудь, где непонятно, кто в каком порядке регистрирует.
2604.88 2621.68 "Анатолий Кулаков" Мне кажется, просто удобная штука для любой программы, которая использует опции, потому что гораздо удобнее упасть на старте и показать, что таких-то опций мне не хватает, чем это когда-нибудь в рантайме, может быть, когда запускается ежегодный отчет один раз в год, и именно самый неподходящий момент, когда у всех отпуск.
2621.68 2641.52 "Игорь Лабутин" Ну да, еще такой интересный момент, сделали нативную интеграцию с системой, это линуксовый, я так понимаю, демон-аналог, позволяющий делать аналоги Windows служб, то есть теперь на линуксе вы можете сделать некий аналог Windows службы, который так как линуксовый, терминологии демон, и это все будет работать так, как линуксовая служба.
2641.52 2646.16 "Игорь Лабутин" В принципе, Microsoft все больше и больше нативно продолжает поддерживать линукс.
2646.16 2647.16 "Игорь Лабутин" Это приятно.
2647.16 2657.24 "Игорь Лабутин" Так, мне кажется, что мы пробежались по основным темам из этого прекраснейшего доклада, но одна осталась немножко отложенной попозже, а именно Collectable Assemblies.
2657.24 2659.96 "Игорь Лабутин" Мы про нее сказали, что поговорим попозже.
2659.96 2667.00 "Анатолий Кулаков" Не просто так отложенной, потому что у нас есть отдельная статья, у нас есть отдельная тема, которая более широко раскрывает эту тему, чем в докладе.
2667.00 2683.00 "Анатолий Кулаков" Кратко расскажу, что мы очень давно, по крайней мере мы и я, очень давно мечтали о том, чтобы .NET на сборке можно было выгружать, потому что я большой фанат кода генерации, динамического создания сборок, и у меня этого мусора всегда полно в моих приложениях.
2683.00 2685.04 "Анатолий Кулаков" Очень хотелось бы его выгружать.
2685.04 2694.04 "Анатолий Кулаков" Каким-то шансом на то, что мы научимся это делать, были апдомены, но апдомены умерли в Core 3, и я думал, что это была вся эта идея с выгрузкой, и она тоже умерла вместе с ними.
2694.04 2695.96 "Анатолий Кулаков" Оказывается, нет, как раз-таки наоборот.
2695.96 2705.72 "Анатолий Кулаков" В Core сделали все, чтобы эта идея получила реализацию, и в .NET Core 3 мы как раз-таки научимся выгружать сборки из наших .NET приложений.
2705.72 2706.72 "Анатолий Кулаков" Ура, господа!
2706.72 2708.08 "Анатолий Кулаков" А теперь подробнее.
2708.08 2712.72 "Анатолий Кулаков" В .NET Core уже есть класс, который называется AssemblyLoadContext.
2712.72 2717.28 "Анатолий Кулаков" Как минимум в приложении существует обычно один AssemblyLoadContext, это дефолт, естественно.
2717.28 2720.24 "Анатолий Кулаков" То есть все сборки, которые вы загружаете, помещаются в него.
2720.24 2731.00 "Анатолий Кулаков" В нём можно создать свои кастомные LoadContext, в которые можно также точно отдельно загружать сборки по каким-то своим условиям, из каких-то отдельных путей или из каких-то непонятных источников.
2731.00 2738.68 "Анатолий Кулаков" В Core 3 появится волшебный флажок в конструкторе LoadContext, который позволяет выгрузить LoadContext, если он вам больше не нужен.
2738.68 2741.52 "Анатолий Кулаков" Для этого достаточно вызвать у него метод unload.
2741.52 2743.76 "Анатолий Кулаков" Соответственно, применение этому масса.
2743.76 2754.88 "Анатолий Кулаков" Любой инструмент, у которого есть система плагинов, например, любой инструмент, у которого есть кодогенерация, у которого есть динамическое создание библиотек, все найдут своё какое-то применение в этом механизме.
2754.88 2761.96 "Игорь Лабутин" Но при этом, я так понимаю, что не должно остаться никаких использований типов из этой загруженной сборки.
2761.96 2762.96 "Игорь Лабутин" Ничего, нигде, никак.
2762.96 2770.08 "Игорь Лабутин" То есть если я там, не знаю, создавал экземпляры этого плагина, то я должен всех аккуратненько что сделать?
2770.08 2772.56 "Игорь Лабутин" Задиспоузить, просто забыть ссылки.
2772.56 2776.32 "Игорь Лабутин" Они должны загарабить коллектор, и после этого я смогу сказать AssemblyUnload.
2776.32 2777.32 "Анатолий Кулаков" Да, всё.
2777.32 2780.00 "Анатолий Кулаков" И это нужно сделать так, чтобы GarbageCollector их собрал.
2780.00 2782.28 "Анатолий Кулаков" То есть, соответственно, не оставить никаких ссылок.
2782.28 2788.28 "Анатолий Кулаков" Если GarbageCollector может их собрать во время метода unload, то он соберёт, и библиотека успешно выгрузится из памяти.
2788.28 2791.44 "Анатолий Кулаков" Соответственно, метод unload работает не сразу.
2791.44 2794.60 "Анатолий Кулаков" То есть вы не увидите эффекта, как только вызовете метод unload.
2794.60 2801.40 "Анатолий Кулаков" На самом деле, unload только помечает контекст, как готовый к выгрузке, а сама выгрузка происходит непосредственно при первом GarbageCollection.
2801.40 2813.84 "Анатолий Кулаков" Также, чтобы поддержать эту функциональность, были добавлены на уровень Assembly и MemberInfo специальные флаги, по которым можно проверить, является ли Assembly выгружаемой или нет.
2813.84 2815.84 "Анатолий Кулаков" То есть, можно ли её выгрузить, будет ли нельзя.
2815.84 2829.76 "Анатолий Кулаков" И в зависимости от этих флагов, вам стоит или удерживать эти типы, или не удерживать, а создавать с помощью weak references, на них какие-то слабые ссылки, или другим способом стараться избежать какого-то захвата этих типов на всё время жизни приложения.
2829.76 2832.12 "Анатолий Кулаков" Но это уже тонкости.
2832.12 2838.80 "Анатолий Кулаков" Самое главное, что это действительно работает, это действительно войдёт в Elis, и мы, наконец, дождёмся полноценного выгрузки библиотек.
2838.80 2840.76 "Анатолий Кулаков" Мне кажется, это победа просто.
2840.76 2848.08 "Игорь Лабутин" Наверняка могут появиться какие-нибудь фреймворки на основе этого, ну, хотя, либо народ будет сам писать всё это дело, так сказать, руками.
2848.08 2849.08 "Игорь Лабутин" Хорошо.
2849.08 2854.04 "Игорь Лабутин" Мне кажется, что через месяцок, когда у нас всё это выйдет, прям должно быть.
2854.04 2855.04 "Игорь Лабутин" Здорово.
2855.04 2874.84 "Игорь Лабутин" Хотя, вот есть некое такое, не знаю, вспоминая года три назад, когда там все ждали какого-нибудь DotNet 4-сколько-нибудь, где не было никаких особых превью, там мог быть какой-нибудь там RC с непонятными фичами, и ты ждал там финального релиза, и посмотреть, что же войдёт, что же не войдёт.
2874.84 2880.00 "Игорь Лабутин" Сейчас, в принципе, более-менее всем и так понятно, что войдёт, ну, и как бы, ну, объявят официально.
2880.00 2881.00 "Игорь Лабутин" Ну и ладно.
2881.00 2882.60 "Игорь Лабутин" Как-то уже не так ждёшь.
2882.60 2884.28 "Анатолий Кулаков" Но интересных фич меньше не стало.
2884.28 2886.52 "Игорь Лабутин" Это правда, и можно на них тоже как-то повлиять.
2886.52 2888.52 "Игорь Лабутин" На самом деле, по которым бьются, это здорово.
2888.52 2898.96 "Игорь Лабутин" Так, ещё одна фича, которая тоже не то чтобы сильно важная что ли, или не сильно большая, скорее так, не сильно большая, но довольно важная, это фича флаги.
2898.96 2899.96 "Игорь Лабутин" Веспен от Кокоро.
2899.96 2905.96 "Анатолий Кулаков" Вот я тоже думал, что она какая-то небольшая, неважная, пока не наткнулся на замечательную серию статей Эндрю Лока.
2905.96 2909.76 "Анатолий Кулаков" Кстати, отличный автор, классный блог, если не читали, обратите внимание.
2909.76 2914.12 "Анатолий Кулаков" Вот ты, Игорь, как-нибудь использовал фичи тогглы в твоём проекте?
2914.12 2918.84 "Игорь Лабутин" Вот фичи тогглы это что-то, что, ну, я, наверное, использовал раза три в жизни.
2918.84 2934.36 "Игорь Лабутин" То есть у нас как-то они не прижились в силу специфики того, что мы делаем в основном коробки, которые как бы поставил и они где-то на серверах, где мы недоступны, нам они недоступны очень, то как-то там особо тогглы это не по тогглям.
2934.36 2935.36 "Игорь Лабутин" Особо переключать нечего.
2935.36 2947.12 "Игорь Лабутин" И переключать-то может и есть чего, не дотянуться до переключателей частенько, поэтому пока нет, но на самом деле у нас есть там модные планы переезда в блока, поэтому скорее всего там это может быть.
2947.12 2952.48 "Игорь Лабутин" Получат свою вторую жизнь идеи это и в нашем коде в том числе.
2952.48 2957.88 "Анатолий Кулаков" Если кто не знаком с шаблоном проектирования фичи тоггл, то это довольно-таки элементарная концепция.
2957.88 2968.00 "Анатолий Кулаков" В тот момент, когда вы хотите какую-то фичу включить в ваш проект или наоборот выключить, вы просто заводите банально, например, булевый флаг, и который в коде проверяете.
2968.00 2971.20 "Анатолий Кулаков" Если булевый флаг есть, то я эту фичу делаю, если нет, то не делаю.
2971.20 2973.08 "Анатолий Кулаков" Казалось бы, элементарнее некуда.
2973.08 2976.92 "Анатолий Кулаков" Но на основе этой идеи Microsoft построила целый фреймворк.
2976.92 2979.60 "Анатолий Кулаков" Который называется Microsoft Feature Management.
2979.60 2984.12 "Анатолий Кулаков" Он сейчас в превью, но уже умеет очень много всяких интересных вещей.
2984.12 2989.40 "Анатолий Кулаков" Во-первых, он основан на стандартном Microsoft Configuration Options.
2989.40 2997.52 "Анатолий Кулаков" То есть он может черпать вот этот флажок, использовать фичу или не использовать, из всех тех источников, которые поддержат Microsoft Configuration.
2997.52 2999.56 "Анатолий Кулаков" Как мы знаем, их там уже сотни.
2999.56 3005.24 "Анатолий Кулаков" То есть это и из файлов, и из Environment Variables, и из баз данных, и откуда угодно дальше.
3005.24 3008.24 "Анатолий Кулаков" У него есть, соответственно, интеграция с контейнером.
3008.24 3018.16 "Анатолий Кулаков" То есть вы можете из контейнера запросить Feature Toggle, тот, который вам нужен, и непосредственно в конструкторе уже получить проинициализированный из правильных мест экземпляр класса.
3018.16 3020.16 "Анатолий Кулаков" Что же можно с помощью него делать?
3020.16 3028.08 "Анатолий Кулаков" Естественно, не только банально проверять ифы, что само собой разумеется, но и более глубокую интеграцию иметь, например, в ASP.NET Core.
3028.08 3036.96 "Анатолий Кулаков" Например, с помощью Feature Toggle вы можете скрывать некоторые экшены, чтобы не выполнялись в вашем контроллере, или добавлять их, если они в какой-то новой версии вашего приложения появились.
3036.96 3044.88 "Анатолий Кулаков" Также Feature Toggle интегрированы с Tech Helper, поэтому вы там можете писать удобные кондишены и удобно формировать формы.
3044.88 3049.36 "Анатолий Кулаков" То есть показывать на формах какие-то возможности для пользователя или не показывать их.
3049.36 3051.60 "Анатолий Кулаков" Также вы можете регистрировать роуты.
3051.60 3057.44 "Анатолий Кулаков" Например, что у вас по одному Feature Toggle запросы идут в одно место, по другому Feature Toggle совсем в другое место.
3057.44 3068.08 "Анатолий Кулаков" И подключать свои кастомные middleware, что тоже порой удобно, если вы, например, реализовали свой какой-нибудь кастомный протокол или тоже самое кастомное сжатие, то вы его можете переключать с помощью Feature Toggle.
3068.08 3080.08 "Игорь Лабутин" И я так понимаю, что эти самые Feature Toggle это не просто там глобальная штука, типа там включили-выключили для всего сервера, но судя по всему они как-то могут зависеть от реквестов, ну или там хотя бы от пользователя.
3080.08 3091.48 "Анатолий Кулаков" Да, динамические Feature Toggle это в принципе отдельная тема, то есть можно задать Feature Toggle статические, которые просто конфигурятся один раз перед стартом вашего приложения и используются в процессе жизни приложения.
3091.48 3096.72 "Анатолий Кулаков" Но есть динамические Feature Toggle, которые в принципе могут изменяться во время жизни приложения.
3096.72 3103.76 "Анатолий Кулаков" Например, в зависимости от хидров, которые пришли в вашем реквесте, вы можете выключить или включить те или иные возможности для данного реквеста.
3103.76 3113.60 "Анатолий Кулаков" Или в зависимости от текущего времени, например, если вам хочется на Новый год показать снежинки на вашем сайте, то это как раз-таки Feature Toggle, который будет включаться и отключаться в зависимости от времени.
3113.60 3118.80 "Анатолий Кулаков" Или в зависимости от прав текущего пользователя, который сейчас к вам пришел в вашем реквесте.
3118.80 3123.64 "Анатолий Кулаков" Также интересный динамический Feature Toggle – это AB-тестирование.
3123.64 3134.20 "Анатолий Кулаков" Вы можете разделить своих пользователей какими-нибудь процентами или какими-нибудь клеймами, или каким-нибудь географическим положением и тестировать отдельные фичи соответственно на них.
3134.20 3145.80 "Анатолий Кулаков" Вот этот контейнер, вся эта интеграция, она прозрачная для разработчика, провяжет это все среди системы UI, среди системы ваших контроллеров, среди вашей системы бизнес-логики.
3145.80 3147.88 "Анатолий Кулаков" Все это будет контролироваться одним Feature Toggle.
3147.88 3151.84 "Анатолий Кулаков" Пользователи будут приходить к вам, казалось бы, на один и тот же уровень, а получать разные функциональности.
3151.84 3155.72 "Анатолий Кулаков" Вы можете тестировать, насколько им удобно пользоваться тем или иным компонентом.
3155.72 3156.72 "Игорь Лабутин" Звучит здорово.
3156.72 3163.16 "Игорь Лабутин" Осталось только, как я понимаю, по сути, дизайнить свой бизнес-код так, чтобы это, ну, получалось туда вписать.
3163.16 3170.56 "Игорь Лабутин" Потому что я так понимаю, что далеко не всегда бизнес-код может быть написан там и в одно, и в другое.
3170.56 3173.36 "Игорь Лабутин" Все-таки бывает там посложнее и попроще.
3173.36 3183.96 "Игорь Лабутин" И, как бы, я так понимаю, что интегрировать Feature Toggle в ваш код, это все-таки особое, если не искусство, то, по крайней мере, некая работа, которая требует размышления.
3183.96 3187.44 "Игорь Лабутин" И, соответственно, систему надо дизайнить под использованием Feature Toggle.
3187.44 3199.88 "Анатолий Кулаков" Ну, не сказать, что прямо под… вам нужно выдумать какую-то отдельную архитектуру, но действительно тебе нужно задумываться, что неплохо бы эту функциональность объединить в какой-то компонент, который можно будет легко проверять и легко выбрасывать.
3199.88 3204.76 "Анатолий Кулаков" Вот просто так размазывать функциональность, например, по 10 методам уже не получится.
3204.76 3212.40 "Игорь Лабутин" Ну, с другой стороны, может быть, это хороший повод как-то навести порядок и правильно организовать код в любом случае.
3212.40 3213.40 "Анатолий Кулаков" Может быть, да.
3213.40 3218.40 "Анатолий Кулаков" Эндрю также привел интересный обзор альтернатив, которые существуют на данный момент.
3218.40 3221.48 "Анатолий Кулаков" Естественно, Microsoft не первая, которая реализовала этот фреймворк.
3221.48 3224.60 "Анатолий Кулаков" Альтернативы тоже весьма интересны.
3224.60 3229.88 "Анатолий Кулаков" И, наверное, самая значительная часть, которой сейчас не может похвастаться Microsoft Feature Toggle, это WebUI.
3229.88 3232.88 "Анатолий Кулаков" Вот, WebUI у многих действительно довольно-таки прекрасная.
3232.88 3241.48 "Анатолий Кулаков" То есть, вы можете зайти в ваше приложение, оно вам отрендерит красиво, что мы страничку, и вы можете прямо через нее пощелкать какие-то тогглы и включить динамические или отключить их.
3241.48 3246.36 "Анатолий Кулаков" Вот, ну, я думаю, за этим дело не станет, и к релизу Microsoft подтянет к себе и красивую веб-морду.
3246.36 3250.76 "Игорь Лабутин" Ну, да, с другой стороны, если у вас есть доступ к серверу, можно покрутить их конфигурации.
3250.76 3252.28 "Игорь Лабутин" В чем бы и нет.
3252.28 3253.68 "Игорь Лабутин" Так, погнали дальше.
3253.68 3263.80 "Игорь Лабутин" В Feature Toggle все здорово, давай вернемся в, так скажем, простой мир обычного разработчика, который пишет немножко кода и немножко тестов.
3263.80 3266.88 "Игорь Лабутин" И я так понимаю, что у нас есть какие-то новости из тестового мира?
3266.88 3270.72 "Анатолий Кулаков" О, да, я тут недавно отрыл великолепную статью.
3270.72 3274.72 "Анатолий Кулаков" Да, это же не статья, это видео на Channel 9.
3274.72 3278.76 "Анатолий Кулаков" Я просто сам для себя уже давно похоронил МС-тест, не думал, что он вообще жив.
3278.76 3284.80 "Анатолий Кулаков" А тут я внезапно увидел рекламное объявление, что наконец-то выходит МС-тест версии 2.
3284.80 3285.80 "Анатолий Кулаков" Не поверишь.
3285.80 3288.96 "Анатолий Кулаков" И это как раз-таки случилось 5 дней назад, поэтому это просто свежак.
3288.96 3293.00 "Анатолий Кулаков" Я подумал, что мы просто обязаны осветить такое страшное событие.
3293.00 3294.64 "Анатолий Кулаков" Ты вообще сталкивался когда-нибудь со МС-тестами?
3294.64 3296.92 "Анатолий Кулаков" Я думаю, вначале ты должен был просто на них напороться.
3296.92 3302.40 "Игорь Лабутин" Я не то чтобы сталкивался, у нас один из продуктов на них полностью еще и тестируется на V1.
3302.40 3307.36 "Игорь Лабутин" Че-то типа 4 или 5 тысяч тестов на них написано и все прекрасно работает.
3307.36 3316.24 "Игорь Лабутин" Благо там нам от максимум там сетап, тирдаун и собственно тесты нужны, мы там не используем никаких всяких там параметризованных тестов и прочего.
3316.24 3335.84 "Игорь Лабутин" Мне казалось, что да, с появлением XUnit, который у нас официальный, я так понимаю, тест-юнит, тест-фреймворк для Netcore и вроде как он используется и в основных репозиториях, там CoreFX и всего остального, МС-тест как-то действительно немножко в сторонке остался.
3335.84 3336.84 "Анатолий Кулаков" Да, именно так.
3336.84 3342.96 "Анатолий Кулаков" Микрософт уже сам на всех своих open-source продуктах перешел на XUnit и всячески кроссплатформенно его использует.
3342.96 3348.84 "Анатолий Кулаков" И одной причиной как раз таки из этого было то, что МС-тест не поддерживался под Linux, под Mac.
3348.84 3350.32 "Анатолий Кулаков" Соответственно выбора особенно не было.
3350.32 3357.08 "Анатолий Кулаков" Как раз во второй версии они это пофиксили, потому что одной из главных фишек второй версии было, это как раз таки кроссплатформенность.
3357.08 3362.64 "Анатолий Кулаков" Теперь МС-тест 2 работает на .NET Core и соответственно может запускать тесты где угодно.
3362.64 3370.16 "Анатолий Кулаков" Также он теперь open-source, вы можете в него контрибьютировать, писать issues и распространяется он с помощью NuGet пакета.
3370.16 3388.16 "Игорь Лабутин" Мне кажется, что Microsoft сделала, не знаю, конкурента, не конкурента XUnit и теперь если МС-тест 2 хоть как-то будет жить, то не удивлюсь, если следующим после объединения репозиториев будет шаг, а теперь мы переводим все тесты на МС-тест, чтобы не зависеть от внешнего XUnit.
3388.16 3389.76 "Игорь Лабутин" Как они собственно сделали с Nintenso Json?
3389.76 3394.32 "Игорь Лабутин" Они же написали свой собственный Json Serializer, чтобы не зависеть от стороннего компонента.
3394.32 3405.92 "Анатолий Кулаков" Ну, с Json все было посложнее, потому что им приходилось вместе со своим фреймворком таскать этот компонент, и если у пользователя была конфликтующая версия, то это приводило к большим проблемам.
3405.92 3408.60 "Игорь Лабутин" Ну да, с тестами попроще в этом плане, согласен.
3408.60 3410.88 "Анатолий Кулаков" Переписать тесты, мне кажется, в большинстве случаев бессмысленная
3410.88 3412.88 "Игорь Лабутин" задача. Ну, последим.
3412.88 3423.36 "Игорь Лабутин" Мне интересно, я действительно считал, что МС-тест уже все, выбор по большому счету между NUnit и XUnit, больше особо-то такого прям ничего нет, но вот так.
3423.36 3429.96 "Анатолий Кулаков" Больше особо тебе в принципе ничего не нужно, там не такая богатая функциональность, которая должна каждый год появляться и приносить что-то новое.
3429.96 3433.20 "Игорь Лабутин" Вот, поэтому интересно, почему тратят ресурсы на МС-тест.
3433.20 3435.40 "Игорь Лабутин" Ну, интересно, посмотрим, возможно, за этим что-то стоит.
3435.40 3439.60 "Анатолий Кулаков" Непонятно, но там действительно появляются такие фишки, знаешь, которые достойны в принципе XUnit.
3439.60 3450.28 "Анатолий Кулаков" Там хорошая расширяемость раннеров, например, то есть ты можешь написать свой раннер прямо в коде, он у тебя заинжектируется в виде плагина, и ты можешь контролировать методы, которые и как этот раннер вызывает.
3450.28 3453.24 "Анатолий Кулаков" То есть интересно, есть атрибуты, которые позволяют его гибко выстраивать.
3453.24 3459.44 "Анатолий Кулаков" Ну, то есть всё то, что вначале было у XUnit, из-за что он как раз-таки получил свою популярность.
3459.44 3464.68 "Анатолий Кулаков" Поэтому начало там довольно-таки хорошее, несмотря на не очень хорошую репутацию.
3464.68 3467.96 "Анатолий Кулаков" Кстати, насчёт видео, мне обалденно понравилась ведущая.
3467.96 3475.20 "Анатолий Кулаков" Если вы вдруг её не видели, Кендра Хеванс - это просто феноменальный образец, каким должна быть настоящая ведущая.
3475.20 3490.04 "Анатолий Кулаков" То есть она расспрашивала разработчика о, ну, таких банальных мёртвых вещах, как МС-тест, и при этом выражала такую качественную заинтересованность, то есть после каждой фразы она говорила "О, это прекрасно, о, это супер, это я так люблю, это мне так нравится".
3490.04 3502.44 "Анатолий Кулаков" А ещё она очень качественно, очень ловко заполняла паузы, когда разработчик пытался найти код или подобрать какие-то нужные слова, или выражался более техническими терминами, которые рядовой слушатель мог не понять.
3502.44 3506.24 "Анатолий Кулаков" Она очень обалденно это всё разъясняла и рассказывала.
3506.24 3507.84 "Анатолий Кулаков" В общем, ведущую я просто влюбился.
3507.84 3511.28 "Игорь Лабутин" Да, она же, кстати, она программ-менеджер.
3511.28 3521.04 "Игорь Лабутин" Дотонетт вижу, студия команды, поэтому, видимо, во-первых, разбирается во всём этом добре, во-вторых, действительно работа у неё такая.
3521.04 3524.00 "Анатолий Кулаков" Кстати, да, технический уровень у неё тоже отличный.
3524.00 3526.40 "Игорь Лабутин" Ну, здорово, надо будет посмотреть, я не видел.
3526.40 3527.40 "Игорь Лабутин" Так, поехали дальше.
3527.40 3546.88 "Игорь Лабутин" На самом деле дальше попалась статья, она немножко такая из цикла статей 100-500 методов что-нибудь сделать, или там 10 способов, 10 типсов как чего-нибудь добиться, и в данном случае это про дебаггинг.
3546.88 3552.96 "Игорь Лабутин" То есть, по мнению автора, 6 техник, которые вам обязательно прям нужно знать, если вы отлаживаете дотонеткод.
3552.96 3560.56 "Игорь Лабутин" В принципе, я даже, наверное, со всеми ими согласен.
3560.56 3568.12 "Игорь Лабутин" Они немножко из разных, так скажем, разделов, но я так почитал, в принципе, все прикольные и полезные.
3568.12 3569.12 "Анатолий Кулаков" А ну-ка, расскажи.
3569.12 3571.92 "Игорь Лабутин" Давайте, прям по порядку, пойдём сверху вниз.
3571.92 3582.04 "Игорь Лабутин" Во-первых, автор рекламирует такое расширение, как Object Exporter, Object Export, точнее, Extension, хотя нет, он так называется, Object Exporter.
3582.04 3583.36 "Игорь Лабутин" Суть его в чём?
3583.36 3601.20 "Игорь Лабутин" Если вам попадается какой-нибудь сложный класс, и вам там хочется посмотреть, что находится в четвёртом списке третьего ложного дикшеннери внутри хеш-сета и по какому-то ключу, то пока вы через плюсики продираетесь в эти менюшки, нажав куда-нибудь не туда, вы их закрываете.
3601.20 3602.56 "Игорь Лабутин" Дебаггер, это не очень здорово.
3602.56 3607.32 "Игорь Лабутин" Ну, вам снова приходится вспоминать, там это было в третьем элементе пятого списка.
3607.32 3610.32 "Игорь Лабутин" Поэтому этот Extension позволяет сделать следующее.
3610.32 3617.72 "Игорь Лабутин" Можно right-click на переменную и сказать "экспортить этот объект в виде либо C# кода, либо JSON-чека, либо XML-и".
3617.72 3629.08 "Игорь Лабутин" И он вам генерирует, допустим, если вы экспортите его как C#, он вам генерирует, просто откроет новое окошечко, в котором написан контент текущего объекта в формате, как будто вы его объявили в C#.
3629.08 3635.24 "Игорь Лабутин" То есть там так будет, прям класс такой-то, int poly такое-то, равно такое-то значение, и так далее.
3635.24 3638.68 "Анатолий Кулаков" Слушай, я сейчас смотрю картинки, и это действительно очень удобно.
3638.68 3640.00 "Анатолий Кулаков" Я думаю, я это обязательно попробую.
3640.00 3650.96 "Игорь Лабутин" Вот, я вот тоже, я этим никогда не пользовался, но я поймался на мысль, что я продираюсь иногда в наших, у нас есть несколько количеств доменных объектов, где вложено несколько списков в списках, и вот это все.
3650.96 3653.00 "Игорь Лабутин" И было бы интересно посмотреть, как он работает.
3653.00 3659.04 "Игорь Лабутин" Я не очень знаю, как он работает на всяких inumerables, то есть будет ли он их enumerate там, и так далее.
3659.04 3665.16 "Игорь Лабутин" Но это вообще в любом случае достойно, так скажем, тестирования посмотреть.
3665.16 3689.56 "Игорь Лабутин" И я немножко перескочу, связанный с этим штукой, когда как раз-таки у нас есть всякие inumerables, то наверняка многие сталкивались с такой вещью, что попытавшись в дебаггере посмотреть какое-нибудь значение, вы приводили к тому, что исполнялся какой-то код в вашем приложении, то есть там, не знаю, лейзилот в базу срабатывал, или еще какая-нибудь такая штука, которой не очень хотелось бы.
3689.56 3698.36 "Игорь Лабутин" А оказывается, в Visual Studio, для тех, кто не знает, в watch-окошечке, где вы обычно все смотрите, можно писать разные суффиксы.
3698.36 3706.36 "Игорь Лабутин" Во-первых, там можно писать разные суффиксы, типа там "нq", и тогда все строчки будут без кавычек, ну в этой переменной.
3706.36 3715.56 "Игорь Лабутин" А можно написать "nse", и тогда это пропертиа будет эволюционироваться в своей отдельной песочнице, и никак не будет влиять на ваше приложение.
3715.56 3717.04 "Игорь Лабутин" То есть понятно, что...
3717.04 3718.60 "Анатолий Кулаков" Погоди, а как они этого добиваются?
3718.60 3722.64 "Анатолий Кулаков" Ведь когда эволюционируется моя пропертиа, она же все равно взаимодействует с инсенсом моего кода.
3722.64 3723.64 "Игорь Лабутин" Да, как-то...
3723.64 3735.00 "Игорь Лабутин" Вот я так подозреваю, что скорее всего он скажет для всяких мест, где есть лейзи-штуки, что "ну извини, не могу", то есть там "выполнить".
3735.00 3744.60 "Игорь Лабутин" Но у меня, например, довольно частая ситуация, что я хочу развернуть какой-нибудь объект, а по дефолту Visual Studio настроено на то, чтобы эволюировать пропертии.
3744.60 3752.24 "Игорь Лабутин" И тогда он просто проходит по всем пропертиям, и даже если какая-то дергает его лейзи-эволюцион, либо еще что-нибудь, она его естественно дергает.
3752.24 3753.24 "Игорь Лабутин" Да.
3753.24 3754.84 "Игорь Лабутин" Я был бы счастлив, если бы...
3754.84 3759.84 "Игорь Лабутин" Да и ладно, мне неинтересно это значение, мне интересно посмотреть правила сфилды, которые не лейзи.
3759.84 3772.36 "Игорь Лабутин" И это, соответственно, либо нужно глобально в студии выключать эволюционные пропертии вообще в очек-окошках, либо вот писать NSE, и тогда прекрасно оно как-то хотя бы часть информации покажет.
3772.36 3776.96 "Игорь Лабутин" Я не пробовал, но возможно, действительно, в каких-то сценариях это поможет.
3776.96 3781.84 "Анатолий Кулаков" Отличный хак, еще надо найти все суффиксы, я так подозреваю, что там очень много всего полезного.
3781.84 3807.88 "Игорь Лабутин" Я когда-то пытался, это правда было во времена 15-й студии, я тогда нашел там буквально 3-4 штуки, то есть вот NQ, я помню, это no quotes, был принудительный вариант выводить чиселки в Хексе, либо в десятичной системе, и вот что-то подобие NSE было, я что-то не помню больше ничего, честно скажу, но может новое появилось в 17-й или в 19-й студии, не смотрел.
3807.88 3812.12 "Игорь Лабутин" Можем, кстати, порыться потом, может в каком-нибудь следующем выпуске осветим эту тему.
3812.12 3818.28 "Игорь Лабутин" Дальше, касательно дебаггера и всего остального еще.
3818.28 3839.92 "Игорь Лабутин" Современный мир - это всякая многопоточность, и когда мы отлаживаем многопоточность, нужно не забывать, что когда вы нажимаете F10, у вас начинают исполняться все потоки, которые у вас есть в приложении, и если у вас много брейкпоинтов по разным потокам расставлено, то не факт, что вы попадете на следующую строчку, выполняя нажав F10, вы попадете в какой-нибудь брейкпоинт в совершенно другом потоке.
3839.92 3861.08 "Игорь Лабутин" Поэтому если вы отлаживаетесь, многопоточный, и вам нужно пока побыть в одном том потоке, в котором вы, не знаю, имеете сложный алгоритм, который вы прямо сейчас нужно отладить, а что делать остальные потоки вам не важно, то в дебаггере есть такая штука, можно райтликнуть по списку потоков, точнее по потоку списки или по группе потоков и сказать freeze, после чего эти потоки перестанут исполняться.
3861.08 3876.76 "Игорь Лабутин" А в 19-й студии появилась фишечка, что если в результате исполнения вы перепрыгнули на другой поток, то есть вы нажали F10 и брейкпоинт сработал на другом потоке, то там как-то по-особенному подсвечивалась строчка с этим брейкпоинтом.
3876.76 3882.44 "Игорь Лабутин" Вот я сейчас не помню, не пробовал еще, но они вот улучшили эту тему, поняв, что на это многие напарываются.
3882.44 3887.76 "Игорь Лабутин" Теперь там есть некая визуальная индикация того, что на самом деле F10 это F10, но вы попали в другой поток.
3887.76 3890.64 "Анатолий Кулаков" Да, тоже очень полезная функциональность, я часто пользуюсь.
3890.64 3896.60 "Игорь Лабутин" Так, третий какой уже, четвертый по порядку, это Object ID.
3896.60 3912.00 "Игорь Лабутин" Я когда-то давно, лет 5-6 назад, у меня была задача, нужно было понять, почему в нескольких местах кода вроде бы должен быть один объект, а по факту приходят какие-то разные.
3912.00 3921.40 "Игорь Лабутин" Или наоборот, вроде мы ждем, что на каждый запрос, например, будет создаваться своя собственная instance какого-либо объекта, а вроде передается какой-то один и тот же.
3921.40 3940.40 "Игорь Лабутин" Я для этого использовал такой очень метод в лоб, а именно я тупо логировал Object.getHashCode, который, понятно, не уникален, но более-менее в рамках плюс-минус нескольких минут, наверное, можно считать, что уникален, и это помогало.
3940.40 3945.28 "Игорь Лабутин" Но это было почти в продакшене, поэтому там другого выхода не было.
3945.28 3969.12 "Игорь Лабутин" А если вы дебажите и вам нужно это все понять, то во время отладки, то можно опять же реткликнуть на переменную и сказать makeObjectId, после чего в watch-окошке справа от вашей переменной будет еще писаться ObjectId, и когда вы придете в это же место кода и в этой переменной будет лежать какой-то другой объект, вы можете на этот ObjectId посмотреть и сказать, был ли он тот же или не тот же.
3969.12 3975.76 "Игорь Лабутин" То есть я подозреваю, что это работает где-то рядом с getHashCode, но возможно это какая-то довеска именно дебаггерной.
3975.76 3976.76 "Анатолий Кулаков" Не знаю.
3976.76 3988.00 "Анатолий Кулаков" Слушай, это совсем не getHashCode, потому что если ты сождашь два экземпляра полностью идентичных по набору полей и вызовешь у них getHashCode, то естественно он будет одинаковый.
3988.00 3990.40 "Анатолий Кулаков" А ObjectId, он всегда уникальный.
3990.40 3996.56 "Анатолий Кулаков" То есть что бы ты ни сделал, как бы ты ни вытворялся, ты никогда не создашь две разных переменные с одинаковым ObjectId.
3996.56 4001.80 "Анатолий Кулаков" И это, наверное, моя самая любимая фишка дебага Visual Studio, я пользуюсь просто всегда.
4001.80 4010.76 "Анатолий Кулаков" То есть у меня очень часто напарываются такие вещи, когда нужно понять, что же там произошло с инстанциями, экземплярами одних и тех же объектов или разных объектов.
4010.76 4012.92 "Анатолий Кулаков" То есть она мне выручала не один раз.
4012.92 4013.92 "Игорь Лабутин" Ну прикольно, прикольно.
4013.92 4019.52 "Игорь Лабутин" У меня как-то вот такое было давно, в последнее время не попадалось необходимости, но буду знать.
4019.52 4053.08 "Игорь Лабутин" Последний совет, предпоследний, это про PDB, то есть он про то, что иногда, вижу, студия не подхватывает на лету правильные PDB, то есть когда вы пытаетесь поотлаживать там тот же SDK, либо еще что-нибудь, по-хорошему у вас, если правильно настроены символы, символы должны подтянуться из сайтов серверов Microsoft, и хотя бы в стектрейсах должны показываться все нормально, но, как известно, наши все такие низкоуровневые библиотеки, типа MS Core, либо они оптимизируются, ингенируются, и вот это все.
4053.08 4060.56 "Игорь Лабутин" И если этих символов вдруг нету, то если у вас стоит ReSharper, можно попросить ReSharper генерить, задезассемблить.
4060.56 4071.68 "Игорь Лабутин" 19-ая студия вроде бы должна позволять даже сама, ну и кроме того, я, например, иногда, в последнее время, правда, все реже, использую dotpeak RedPrint-овский как PDB-сервер.
4071.68 4077.36 "Игорь Лабутин" Можно его так настроить и попросить студию брать символы оттуда, а он на лету вам будет генерить, декомпилировать.
4077.36 4083.40 "Игорь Лабутин" Но это уже такая advanced штука, когда вы отлаживаете совсем не свой код, либо код, который там сильно заоптимизирован.
4083.40 4087.16 "Анатолий Кулаков" А я как раз-таки наоборот пользуюсь dotpeak-ом в этом плане наиболее часто.
4087.16 4089.80 "Анатолий Кулаков" Ты говоришь, что студия умеет сама хорошо декомпилировать?
4089.80 4091.68 "Игорь Лабутин" Ну вот 19-ашка вроде начала.
4091.68 4093.28 "Анатолий Кулаков" Ты видел код, который получается?
4093.28 4095.28 "Анатолий Кулаков" Он в меня, он хорош?
4095.28 4105.52 "Игорь Лабутин" Нет, пока 19-ая, пока идет немножко мимо меня, у нас продукт по какой-то причине пока не может на ней собраться, поэтому мы пока не переходим, и у меня ее не стоит еще на основном ноутбуке.
4105.52 4121.40 "Игорь Лабутин" Поэтому пока ничего не могу сказать, но то есть я вижу, что 19-ая студия вот в последнем 16.2, по-моему, апдейте получила хороший юнитест раннер практически, ну очень похожий на решарперный.
4121.40 4128.12 "Игорь Лабутин" Соответственно, я так подозреваю, что, наверное, декомпилятор там тоже должен подтянуться.
4128.12 4139.24 "Игорь Лабутин" Я понимаю, что это несвязные вещи, и я понимаю, что решарпер - это своя модель кода, и возможно она позволяет ему чуть больше и чуть красивее писать код после декомпиляции.
4139.24 4140.24 "Игорь Лабутин" Ну не знаю, надо пробовать.
4140.24 4153.52 "Игорь Лабутин" То есть dotpeak-ом я пользуюсь, когда у нас есть всячески разный код, который я забираю из production, скажем, которому почему-то либо потеряны pdb, либо нет pdb, тогда dotpeak конечно спасает.
4153.52 4157.52 "Анатолий Кулаков" Надо попробовать, да, я соценил, как студия справляется с декомпилом.
4157.52 4163.56 "Игорь Лабутин" Да, и последний пункт - это на самом деле прям вот боль-боль-боль.
4163.56 4167.60 "Игорь Лабутин" Очень многие разработчики неправильно логируют эксепшены.
4167.60 4179.24 "Игорь Лабутин" То есть первое, с чего мы всегда начинаем разбор любого инцидента - это, понятно, чтение логов, если они есть, по крайней мере, error-ного stacktrace.
4179.24 4195.64 "Игорь Лабутин" И вот тут прям беда-беда, потому что до сих пор встречается, ну у нас, во-первых, исторически встречается по кодовой базе код, хотя вроде бы его должны уже были вычистить окончательно, когда логируют только e-message или e-message+e-stacktrace.
4195.64 4201.48 "Игорь Лабутин" Это уже лучше, но тоже недостаточно, потому что есть еще e-inner function.
4201.48 4202.48 "Игорь Лабутин" И вот это все.
4202.48 4211.00 "Игорь Лабутин" То есть, в общем, совет такой - всегда логируйте e.toString и в общем, не надо пытаться сэкономить.
4211.00 4214.40 "Анатолий Кулаков" Слушай, а я бы сказал, что всегда логируйте e.
4214.40 4219.20 "Анатолий Кулаков" То есть всегда засовывайте объект эксепшена в логер, а логер уже сам знает, что с ним сделать.
4219.20 4222.68 "Анатолий Кулаков" Если нужно, он сделает там toString, если нужно, он из него что-то другое выберет.
4222.68 4233.72 "Анатолий Кулаков" А вообще он может его вполне разобрать на какие-то структуры и отправить уже посредственно на сервер все, что он найдет в этом эксепшене, даже то, что не попадает в toString.
4233.72 4234.72 "Игорь Лабутин" Все так.
4234.72 4243.16 "Игорь Лабутин" У нас, на самом деле, собственно, реализация toString для эксепшенов в своей прослойке логерной, потому что стандартный toString не пишет всего содержимого.
4243.16 4244.16 "Анатолий Кулаков" Да, именно так.
4244.16 4251.08 "Анатолий Кулаков" Поэтому отдавайте на откуп логеру, что он хочет залогировать из вашего эксепшена, и то есть бросайте в логер прямо целый эксепшен.
4251.08 4254.48 "Анатолий Кулаков" Не выбирайте каких-то полей, каких-то свойств или каких-то методов.
4254.48 4255.48 "Игорь Лабутин" Да.
4255.48 4262.96 "Игорь Лабутин" Ну, это вот были 6 таких довольно простых, с одной техникой отладки, но, наверное, про них надо помнить.
4262.96 4265.24 "Игорь Лабутин" Ну, опять же, чтобы новенькая узналась.
4265.24 4267.16 "Анатолий Кулаков" Да, мне, по крайней мере, было очень полезно.
4267.16 4268.16 "Анатолий Кулаков" Спасибо.
4268.16 4269.16 "Анатолий Кулаков" Классная статья.
4269.16 4280.80 "Игорь Лабутин" И у меня последняя в списке статья на сегодня - это чуть более общая тема про отладку, а про то, а как вообще подходить к отладке.
4280.80 4290.56 "Игорь Лабутин" То есть я замечаю, на самом деле, иногда это довольно сложно понять разработчикам, особенно начинающим.
4290.56 4295.08 "Игорь Лабутин" Вот у вас что-то не работает, а что с этим делать?
4295.08 4302.24 "Игорь Лабутин" Замечаю, что иногда некоторые получают, допустим, баг там из трекера, смотрят на него и тут же пытаются повторить его в дебаггере.
4302.24 4307.00 "Игорь Лабутин" Ну, то есть пытаются использовать дебаггер, чтобы понять вообще, что происходит и так далее.
4307.00 4309.12 "Игорь Лабутин" И мне кажется, это неправильно.
4309.12 4316.56 "Игорь Лабутин" Это некая, ну скажем так, трата времени и сил, которая при...
4316.56 4325.36 "Игорь Лабутин" Особенно если вы начинающий разработчик и не очень хорошо знакомы с общей кодовой базой, возможно, вы не совсем угадали, куда нужно смотреть дебаггеры и просто зря потратите время.
4325.36 4334.60 "Игорь Лабутин" Поэтому я бы предложил использовать чуть более системный подход к тому, как вообще все это отлаживать и искать проблемы.
4334.60 4344.20 "Игорь Лабутин" Есть статья, она будет в шоу-ноутсах, которая довольно неплохо описывает это применительно вообще к любой проблеме по большому счету в программировании.
4344.20 4346.48 "Игорь Лабутин" Да, наверное, не только в программировании.
4346.48 4353.44 "Игорь Лабутин" И на самом деле я еще дополнительно тоже поищем и включим, рекомендую почитать Джона Скита.
4353.44 4365.96 "Игорь Лабутин" У него была на его блоге серия статей под тегом Diagnostics, где он просто по шагам показывал, как он искал несколько примеров багов у себя в Not-A-Time и другие библиотеках, которые он отлаживал.
4365.96 4372.32 "Игорь Лабутин" То есть прям со всеми тутпиковыми входами, куда он заходил по ложному следу и так далее.
4372.32 4377.96 "Игорь Лабутин" Очень прям занимательная чтива, которая показывает, как нужно подходить к тому, как искать проблемы.
4377.96 4386.24 "Анатолий Кулаков" Да, Джон Скит, он знаменитый популяризатор именно техники подхода, как правильно задавать вопросы, например, на stack overflow или как правильно дебажить.
4386.24 4390.96 "Анатолий Кулаков" То есть он искренне считает, что постановка правильного вопроса — это уже половина ответа.
4390.96 4396.96 "Анатолий Кулаков" И у него много интересных статей есть, как ставить правильный вопрос или как делать правильные дебаги или как писать правильные тесты.
4396.96 4398.52 "Анатолий Кулаков" Да, действительно очень интересно.
4398.52 4401.48 "Игорь Лабутин" Ну, в общем, можем чуть-чуть быстренько пробежаться.
4401.48 4406.48 "Анатолий Кулаков" Я на самом деле… Давай, у нас времени уже мало, поэтому давай быстренько пробежимся по интересным.
4406.48 4409.48 "Игорь Лабутин" Мне больше всего понравились первые два пункта.
4409.48 4415.40 "Игорь Лабутин" То есть если у вас есть какая-то проблема и кажется, что что-то не работает, пункт первый — а поймите, что работает.
4415.40 4424.84 "Игорь Лабутин" То есть на самом деле, возможно, то, что вы видите, это только маленький кусочек общей большой картины того, что не работает.
4424.84 4432.60 "Игорь Лабутин" И тот факт, что у вас там не работает конкретный endpoint в вашем конкретном backend приложении на самом деле может означать, что у вас там упал firewall и на самом деле не работает ничего.
4432.60 4433.60 "Игорь Лабутин" Все приложение.
4433.60 4434.60 "Игорь Лабутин" Все приложение, да.
4434.60 4435.60 "Игорь Лабутин" Или еще как-то.
4435.60 4440.32 "Игорь Лабутин" Или вы это тестируете изнутри сетки, а снаружи сетки вас не видно.
4440.32 4441.32 "Игорь Лабутин" В таком духе.
4441.32 4443.80 "Игорь Лабутин" То есть сначала поймите, а что вообще работает.
4443.80 4445.76 "Игорь Лабутин" Это важно для понимания контекста.
4445.76 4446.76 "Игорь Лабутин" Отличный совет.
4446.76 4450.72 "Игорь Лабутин" После этого поймите, что конкретно не работает.
4450.72 4454.32 "Игорь Лабутин" То есть не работает конкретный запрос с конкретными параметрами.
4454.32 4462.56 "Игорь Лабутин" Не работает в целом все, что касается пользователей каких-нибудь продуктов, корзин, если это какой-нибудь интернет-магазин.
4462.56 4471.16 "Игорь Лабутин" То есть постараться четко сформулировать для себя или возможно для других, что точно не работает.
4471.16 4482.52 "Игорь Лабутин" Не в терминах к вам пришел пользователь и говорит «а, все не работает», а прямо вот четко, конкретно вот такой-то запрос с такими-то параметрами выдает странный результат или занимает много времени или еще что-нибудь.
4482.52 4491.52 "Игорь Лабутин" Когда у вас это есть, у вас как минимум есть некоторый признак, который вы можете использовать потом для понимания, решили вы конкретно эту проблему или нет.
4491.52 4492.84 "Игорь Лабутин" Следующий пункт простой.
4492.84 4493.84 "Игорь Лабутин" Упростите проблему.
4493.84 4498.40 "Игорь Лабутин" То есть у вас есть запрос, например, который с такими-то параметрами не работает.
4498.40 4506.24 "Игорь Лабутин" Возможно все сходится к исходе запроса внутри в базу, который с такими-то параметрами выбирает неоптимальный экзекьюшн план, либо еще что-то.
4506.24 4509.24 "Игорь Лабутин" То есть упрощаем проблему максимально насколько можем.
4509.24 4519.68 "Игорь Лабутин" Дальше тот самый стандартный, вот где-то отсюда мне казалось включается идея Джона Скита, про то, что дальше генерируем гипотезу, проверяем гипотезу.
4519.68 4524.84 "Игорь Лабутин" И так до тех пор, пока не убедимся, что мы нашли более-менее правдоподобную гипотезу.
4524.84 4528.08 "Игорь Лабутин" Казалось бы, следующий шаг надо фиксить, но нет.
4528.08 4530.84 "Игорь Лабутин" Есть еще два шага перед этим.
4530.84 4531.84 "Игорь Лабутин" Шаг первый.
4531.84 4536.16 "Игорь Лабутин" Это нужно понять, если ваша гипотеза верна.
4536.16 4541.60 "Игорь Лабутин" Где еще в приложении вашем есть или могут быть подобные места?
4541.60 4542.60 "Игорь Лабутин" Почему это важно?
4542.60 4548.32 "Игорь Лабутин" Важно это, во-первых, для того, чтобы их потом пофиксить в остальных местах, если это, так скажем, актуально.
4548.32 4568.88 "Игорь Лабутин" А второе, и мне это на самом деле пару раз сильно помогало, если вы в какой-то очень сложной части приложения нашли баг, или у него какие-то там сложные репора, но вы понимаете идеологию бага, вы понимаете, почему он произошел, и вы понимаете, что похожее место есть в другой части системы, где все гораздо проще, то можно сначала попробовать проверить там.
4568.88 4578.12 "Игорь Лабутин" И если оно похоже, и там, и сям, все примерно одинаково, то есть шанс, что на более простой версии будет просто быстрее и проще проверять фиксы и гипотезы.
4578.12 4589.60 "Анатолий Кулаков" А я бы добавил, это еще помогает немножко генерализировать проблему, то есть понять, как ты ее будешь фиксить, не с точки зрения одного какого-то маленького кусочка, а уже с точки зрения всей системы.
4589.60 4595.48 "Анатолий Кулаков" Может быть, на уровне всей системы фикс нужен совершенно другой, а не такой, как бы ты залатал в этом локальном костыле.
4595.48 4596.48 "Игорь Лабутин" И это тоже верно.
4596.48 4597.48 "Игорь Лабутин" Следующий шаг.
4597.48 4602.08 "Игорь Лабутин" Некоторый намек на TDD, можно сказать, мы пишем тест, который будет падать.
4602.08 4604.60 "Игорь Лабутин" После этого фиксим баг и проверяем, что тест работает.
4604.60 4616.96 "Игорь Лабутин" Понятно, что такое получится не всегда, понятно, что есть, наверное, кусочки, которые сложно тестируемые, или только интеграция тестированная, и все такое прочее, но если тест написать можно, лучше его написать.
4616.96 4620.36 "Игорь Лабутин" Заодно будет потом падать, если что-то вдруг.
4620.36 4623.32 "Игорь Лабутин" Дальше проверяем, что после фикса тест работает.
4623.32 4628.48 "Игорь Лабутин" После этого проверяем, что упрощенные, так скажем, наши проблемы работают.
4628.48 4633.20 "Игорь Лабутин" То есть вот та самая, точно тот запрос, вот с ровно с теми параметрами работает.
4633.20 4635.52 "Игорь Лабутин" После этого проверяем исходный.
4635.52 4637.84 "Игорь Лабутин" Пользователь нажимает на кнопку, все висит.
4637.84 4639.56 "Игорь Лабутин" Окей, теперь не висит.
4639.56 4646.64 "Игорь Лабутин" Хорошо, это значит, что был виноват только один тот запрос, а не несколько их, допустим, в цепочке друг с другом.
4646.64 4652.88 "Игорь Лабутин" И после этого наступает скучная часть, нужно задокументировать, что вы пофиксили.
4652.88 4655.92 "Игорь Лабутин" Тут уже сильно зависит, конечно, от процесса, который у вас используется в проекте.
4655.92 4682.48 "Игорь Лабутин" И, возможно, хотя бы теста будет достаточно, но у нас, например, принято, чтобы все-таки в том числе в Backtracker какие-то минимальные описания, что, собственно, было пофикшено, было указано не только в коммите, потому что, ну в идеале это, конечно, делается единым кусочком, но если не получается в коммите хорошо расписать, то в трекер дополнительно дописать, что было сделано, зачем, почему.
4682.48 4684.96 "Анатолий Кулаков" Слушай, интересный подход, я просто с таким не сталкивался.
4684.96 4689.68 "Анатолий Кулаков" А нельзя просто, то есть не легче ли будет тогда отдельно код открыть просто и посмотреть, что пофикшено?
4689.68 4692.12 "Анатолий Кулаков" Или у тебя бывает большой слишком фильм?
4692.12 4694.16 "Игорь Лабутин" Нет, ну это две разных цели.
4694.16 4703.12 "Игорь Лабутин" Когда я пытаюсь понять, почему в этом месте код написан так, я, конечно, смотрю историю этого места кода и пытаюсь понять, что там менялось.
4703.12 4705.48 "Игорь Лабутин" И да, тогда я буду смотреть на коммиты.
4705.48 4722.52 "Игорь Лабутин" А вот недавний пример, у нас есть некая своя система, не система, а схема версионирования записи в базе данных, и там у нас были некоторые проблемы с тем, как назначать таймстемпы на изменяемые сущности.
4722.52 4744.88 "Игорь Лабутин" Мне было проще найти по всему Backtracker все айтемы, которые были хоть как-то связаны с изменением этого поля, ну у нас колоночка довольно уникально называется, то есть просто поиск по колоночке, либо по каким-то ключевым словам, я знаю, как называется этот алгоритм и так далее, находит мне все сразу work-item, tasks, баги, которые этого касались.
4744.88 4752.24 "Игорь Лабутин" Из кода слишком сложно, потому что мы несколько раз меняли это поведение, так сложилось по требованиям.
4752.24 4758.92 "Игорь Лабутин" Первое изменение было где-то в 2011 году, потом в 2014, потом в 2018, что-то по-моему так.
4758.92 4760.20 "Игорь Лабутин" По коду далеко очень копать.
4760.20 4766.28 "Анатолий Кулаков" Ну то есть вы используете Task Tracker как еще одну некую часть истории, ваших требований, истории изменений.
4766.28 4767.28 "Анатолий Кулаков" Да, да.
4767.28 4768.28 "Анатолий Кулаков" Интересно.
4768.28 4771.76 "Игорь Лабутин" И в принципе оно более или менее неплохо работает.
4771.76 4774.40 "Анатолий Кулаков" Отлично, что делать после документирования?
4774.40 4799.08 "Игорь Лабутин" После документирования, соответственно, посмотреть еще раз вокруг, понять, когда вы уже знаете fix, то есть вспомните, когда мы знали баг, когда мы предположили гипотезу, поняли, что вот она есть и подумали в разрезе всей системы, это первый шаг, а момент теперь, когда вы знаете fix, возможно, стоит еще раз подумать про всю систему и понять, fix-то может еще куда-то применим или нет.
4799.08 4805.28 "Игорь Лабутин" Ну и если да, то там продолжить fix на системном уровне, либо все, все готово, релизим.
4805.28 4812.96 "Игорь Лабутин" По большому счету вот, то есть реально, как мне кажется, здесь ключевой момент для меня это самое начало.
4812.96 4815.64 "Игорь Лабутин" Поймите, что реально работает, что реально не работает.
4815.64 4820.20 "Игорь Лабутин" Не надо бежать и фиксить первое попавшееся место, которое вам кажется, что все исправит.
4820.20 4828.20 "Игорь Лабутин" Экономит кучу времени, хотя казалось бы, тратишь там полчаса, час, сидишь, пытаешься понять вообще, что происходит, вместо того, чтобы в вижу студию что-то делать.
4828.20 4830.96 "Игорь Лабутин" Это же как-то неэффективно вроде бы, но нет.
4830.96 4850.32 "Анатолий Кулаков" Да, хорошая рекомендация, мне твоя статья напомнила доклад Сергея Щегельковича, который называется "Отладка как процесс", кстати, недавно его пересматривал, вот, я думаю мы приложим его к шоу-нотам, тоже, если кому интересно эта тема, посмотрите, он раскрывает практически эту же тему с довольно интересной точки зрения.
4850.32 4852.48 "Анатолий Кулаков" У Сергея очень богатый опыт, этому крайне рекомендую.
4852.48 4856.52 "Анатолий Кулаков" Ну что, пора завершаться, мы и так с тобой наговорили больше, чем на час.
4856.52 4871.68 "Игорь Лабутин" Да, я думаю, что завершаемся, ждем новых новостей, новостей должно быть много, скоро состоится Дотнат Конф, 23-25 сентября, там мы узнаем все официальные новости и анонсы и пообсуждаем их, конечно же.
4871.68 4873.12 "Анатолий Кулаков" Да, будет что обсудить.
4873.12 4885.64 "Анатолий Кулаков" Ну а мы ждем ваших комментариев, пишите нам в ВКонтакте, кстати, больше новостей вы можете найти в нашей группе ВКонтакте dotnet.ru, вот, там же будет этот выпуск, там же мы ждем ваших комментариев, пожеланиев и советов.
4885.64 4892.64 "Анатолий Кулаков" А на сегодня все, если кто желает, пишите нам письма на радио@dotnet.ru.
4892.64 4893.64 "Анатолий Кулаков" Всем пока.
