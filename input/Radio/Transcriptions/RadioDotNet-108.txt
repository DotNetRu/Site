6.00 14.00 "Анатолий Кулаков" приветствую дорогие друзья в эфире радио дотнет выпуск номер 108 в студии как всегда ее постоянный ведущий Анатолий Кулаков
14.00 16.00 "Игорь Лабутин" и Игорь Лабутин, всем привет
16.00 61.00 "Анатолий Кулаков" а за нашими плечами большая толпа помогаторов, среди них Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Лазарев Илья, Шевченко Антон, Ольга я люблю стринг билдер Бондаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей, Дмитрий Сорокин, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Тимофей и много-много еще замечательных людей которые пожелали остаться неизвестными всем вам большое спасибо, что поддерживаете подкаст, а если вдруг не поддерживаете задумайтесь, может уже пора, может уже стоит итак, что у нас там сегодня, микрософт все еще не проснулся, больших новостей от него ожидать не стоит
61.00 84.00 "Игорь Лабутин" да, больших нету, там есть какая-то движуха потихонечку в репозитории, но пока не настолько всего много, чтобы обращать на это внимание ну в смысле, мы можем конечно начать разбирать индивидуальные пул реквесты, но это прям будет совсем детально и наверное не стоит того лучше мы подождем какого-нибудь превью 1 в котором что-нибудь выйдет, а еще кстати Aspire обещали 9.1 буквально что-то тут вот в феврале-марте
84.00 91.00 "Анатолий Кулаков" они прям Aspire так сделали, чтобы как раз вопреки всем релизам, всем каким-то ивентам выдавать нам инфоповоды
91.00 100.00 "Игорь Лабутин" ну типа того, да, посмотрим как будет может выйдет, может не выйдет, но где-то в твиттере я такое встречал, что вот мы скоро планируем
100.00 102.00 "Анатолий Кулаков" ну пока статей хватает, давай посмотрим
102.00 540.00 "Игорь Лабутин" да, статей хватает, поэтому пойдем к первой статье первая статья у нас сегодня про object пулы и вообще про пулы объектов в дотнете не то чтобы сильно часто приходится ими пользоваться но иногда попадаются кейсы, когда они нужны и тогда несомненно нужно рассмотреть их использовать давайте подумаем, посмотрим, что же это такое зачем использовать и как использовать и как оно внутри реализовано вообще пулы объектов это вообще говоря, паттерн который позволяет вам повторно использовать какие-то объекты вместо того, чтобы их создавать это может быть полезно в ситуациях, когда объект у вас какой-то очень тяжелый и дорогой для создания то есть он требует какого-то огромного ресурсов CPU или просто сложных каких-то расчетов для инициализации своей ну либо если у вас объекты-то создаются дешево как у нас в дотнете во многом и есть если вы создаете объекты и у него нет конструктора например, то создание объекта, локации это очень дешево, но если вы это делаете тысячи и миллионы раз за короткий промежуток времени то это может создавать некоторую дополнительную нагрузку на garbage collector это может создавать такой эффект который называется memory traffic когда вроде как garbage collector конечно удаляет все ваши свежесозданные объекты, которые живут очень коротко но просто за счет того, что этих объектов становится очень много время, которое затрачивается на garbage collector становится каким-то заметным и в этом случае для того, чтобы уменьшить memory traffic может быть полезно использование пула само по себе использование оно в общем довольно тривиально вы получаете объект оттуда, вы как-то его используете и самое главное вы объект обратно в пул возвращаете не просто его выкидываете, а возвращаете чтобы он не потерялся, не собрался к garbage collector, а все-таки остался для последующего использования иногда в некоторых пулах может присутствовать логика, что при возврате объекта с ним производят некоторые дополнительные действия, ну например если вы там возвращаете какой-нибудь список то вам при возврате вы можете список очистить, или если вы возвращаете массив, то массив при возврате могут обнулить, ну в смысле заполнить там все элементы дефолтными значениями но это опционально в коде это обычно выглядит, что вы где-то в какую-то переменную затягиваете себе объект из пула методом get, take, rent как угодно, после чего в блоке try делаете с ним что-нибудь и в блоке finally обязательно делаете в pool.return ну наверное кроме return я что-то не видел больше других вариантов, обычно return, передаете сюда этот объект и в общем все, на этом работа закончена, почему это важно делать в finally а потому чтобы объект в любом случае вернулся в pool, ну и надо понимать, что с объектом вы можете работать только внутри этого try.finally все сохранять ссылки на такие объекты за пределами такого try.finally конечно не стоит потому что в этом объекте может оказаться что угодно, потому что этот же объект может взять какой-нибудь соседний кусочек кода и с ним тоже что-то поделать в dot net есть два встроенных класса, которые вам доступны с точки зрения пулинга, это object pool и это array pool рассмотрим их по очереди object pool исходно доступен в span @query, а если вы используете span @query и он у вас есть, ну либо можно подключить get_packet_microsoft_extensions в object pool, тогда он у вас будет где угодно для того чтобы создать сам pool, вы сначала вызывайте статический метод у класса object pool, то есть objectpool.create и указываете в дженериковом так сказать в этих угловых скобочках какого типа объекта вы там будете хранить после чего у поола можно вызвать метод get и получить собственно объект, и для того чтобы вернуть, можно сделать return дальше вы можете реализовать специальный интерфейс ipooled_object_policy и в нем реализовать два метода create и return, в котором вы можете производить какие-то дополнительные действия с объектами например именно как раз в return вы можете объект перед тем как он возвращается непосредственно в pool почистить, это делается по сути в итоге, ну как бы в инфраструктурном коде, да, и в вашем коде вы просто пишете pool.return и ссылка на объект, а за счет наличия вот этого policy этой policy происходит какая-то дополнительная очистка при возвращении как он внутри устроен этот самый object_pool, он устроен довольно ну, незатейливо так скажем у него есть всего два поля, одно поле называется fast_item, а второе называется items, и является очередью как происходит получение объекта ну, оно тоже максимально простое, если у нас в поле fast_item лежит не null то мы достаем оттуда объект и его возвращаем естественно, поскольку pool потока безопасный то вы можете доступаться к нему из нескольких разных потоков и для того, чтобы все это было синхронно и безопасно используется interlocked compare_exchange то есть, грубо говоря, мы делаем interlocked compare_exchange на fast_item с null если в ответ вернулся не null, все отлично, можно этот объект вернуть, и если вернулся null, ну, значит уже как это, оттуда занято было, там не было свободного объекта, и тогда мы берем из items, items_set_concurrent_queue, просто конкурентная очередь, которая, понятно, потока безопасна, мы оттуда просто вытаскиваем если и там ничего нет, то есть очередь пуста, то создаем объект фабрикой надо сказать, что объекты не могут накапливаться бесконечно если вы это сделаете, у вас будет, по большому счету может быть утечка памяти, и поэтому обычно pool как-то ограничивается по размеру каким-то разумным пределам когда вы поработали с объектом и хотите его вернуть обратно, вы во-первых, ну, вы просто вызываете метод return там, соответственно, происходит проверка объекта и какие-то дополнительные действия благодаря policy после чего, если точно так же через interlock_compare_exchange fast_item был null, то мы сохраним туда если же fast_item уже не null, то есть кто-то туда успел до вас сохранить объект ну, тогда запихнем в очередь items но опять же, если вдруг размер очереди превысил незаданное значение, то объект просто выкинет, ну, то есть он никуда не сохранится и его рано или поздно соберет garbage_collector с точки зрения производительности в статье приводится некоторые графики производительности, графики очень тяжело обсуждать, поэтому тут просто приведу общий вывод статьи про то, что в однопоточном сценарии он позволяет увеличить скорость на там 10-50% по сравнению с созданием нового объекта для каждой интерации того цикла, в котором это все тестируется но при многопоточном доступе понятно, что на маленьких объектах результаты хуже, хотя опять же размер самого объекта по большому счету может быть даже не сильно важен, потому что затраты garbage_collector на allocate маленького и большого объекта по большому счету одинаковые если мы говорим, например, о каких-нибудь массивах просто разного размера потому что garbage_collector неважно, сколько allocate, разве что там будут небольшие затраты на allocate новых регионов, если их вдруг почему-то не хватает но
540.00 544.00 "Анатолий Кулаков" - Когда ты говоришь про 10-50%, это имеется ввиду объекты, которые создаются мгновенно, да?
544.00 546.00 "Анатолий Кулаков" То есть пустые какие-то
546.00 562.00 "Игорь Лабутин" объекты? - Ну да, да, там довольно синтетический тест, поэтому понятно, что и там в комментариях, кстати, справедливо замечено, что все эти приросты, они конечно надо мерить на реальных живых приложениях просто потому, что мы, по факту, меряем в том числе производительность garbage_collector
562.00 572.00 "Анатолий Кулаков" - Ну типа, типа Apple использует, когда, как ты сказал, у тебя большие весомые объекты, и там твои 10-50% уже превратятся как бы в 500 миллионов процентов - Да, либо
572.00 588.00 "Игорь Лабутин" у тебя очень много allocates и тогда действительно уже становится важно что ты не генерируешь там memory_traffic на 2 гига памяти allocates на один входящий запрос в твое, а что это в смысле, один входящий запрос в твое приложение
588.00 594.00 "Анатолий Кулаков" - Вероятно, там уже pool нужен более какой-то умный чем просто обычный concurrent_queue
594.00 682.00 "Игорь Лабутин" - Там может быть достаточен concurrent_queue, у меня есть опыт работы с такой оптимизацией, мы object_pool использовали, правда, у нас был такой полусамописный, но тоже, по сути, на concurrent_queue и там все было нормально, все можно было улучшить просто за счет того, что мы переиспользовали некоторые наши внутренние объекты, которых мы знали что нам нужно создавать за время работы алгоритма много но одновременно в памяти живет их не очень много, но там были некоторые специфические математические вычисления и некоторые наши объекты ну, представь, какие-нибудь комплексные числа, грубо говоря структурка из пары полей у нас была структурка, по-моему, из 5 или 6 полей если я правильно помню но их в процессе вычисления приходилось allocate много и там pool реально прям хорошо спасал потому что можно было их переиспользовать, фактически а иначе на одно вычисление там действительно профайлер показывал 2-2,5 гига memory traffic у нас не было цели вложить какой-нибудь чтобы этот http метод возвращался за 100 миллисекунд, нет, это заранее было известно, что это долгое, сложное вычисление оно выполнялось несколько секунд но все равно, если можно за счет pool я сейчас навру, наверное, в числах, но грубо говоря из 2-2,5 гигабайта memory traffic мы снизили до 130 или 150 что приятно
682.00 690.00 "Анатолий Кулаков" да, тогда просто цифры, что ты на пустом поле собираешь 50% перформанса, наверное, вообще ничего не значит да-да-да
690.00 912.00 "Игорь Лабутин" ну то есть на графике, может быть, посмотреть полезно, как, например, это меняется в зависимости от размера чего-нибудь или от количества или еще чего-нибудь, но тут скорее я все это рассказываю больше ради именно принципа работы, чтобы просто те, кто не знал возможно, знают, что есть такая штука как objectPool потому что, как мне кажется, про следующую конструкцию rayPool, про него говорят много кто ну он во всяких докладах встречается rayPool, он там когда появился нормальный rayPool, там про него статьи были, все такое, а objectPool он, мне кажется, довольно давно уже с нами и как-то его, вот почему-то он был написан свой, ну, может быть потому, что проект начинался, но тут найти 3,5 его там еще не было, тут я уже не знаю да, может, не так давно да, да, ну, неважно, ладно давай дальше, дальше у нас есть rayPool это уже специализированный класс точнее, это, на самом деле, абстрактный базовый класс, у него есть две реализации и он предназначен для пулинга только массивов и больше ничего у него есть две реализации, как я сказал, это sharedRayPool и configurableRayPool, они отличаются немножко поведением внутренним устройством значит, sharedRayPool используется как такой единый статический синглтон на все приложение, то есть если у вас нет каких-то супер специальных требований к тому вы точно знаете, какого размера pool вам нужен и так далее, я сейчас чуть дальше расскажу как можно настраивать rayPool то обычно рекомендуется начать с sharedRayPool с ним, скорее всего, у вас получится уже все хорошо и только если вам его не хватает тогда идите в какую-нибудь кастомную настройку или, например, вам нужны разные пулы по каким-то причинам с разными настройками но если вам достаточно shared, а с него желательно начать, то вы просто говорите везде, где вам нужен pool, вы используете rayPool.t.shared и это потокобезопасный instance, который можно от него просто вызывать rent и return точно так же в Trifinal если вам нужен configurable, то вы вызываете статический метод rayPool.create и тогда передаете настройки настройок всего 2, это максимальная длина массива которую нужно хранить в пуле это как раз может быть полезно если, например, вы знаете, что вам нужен pool большого количества не очень длинных массивов, то дефолтные настройки которые по дефолту, если я правильно помню, локетят массивы до по-моему, 4 мегабайт или 2 мегабайта я сейчас не вспомню точно если вам такие большие массивы не нужны в пуле, то можно настроить, сколько их там будет а еще можно настроить количество массивов на один бакет то есть, сколько, грубо говоря, каждого размера будет массивов в пуле содержаться а все, что больше, будут выкидываться если вы вдруг налокетите больше, то будет выкидываться размер возвращаемого массива при работе с rayPool нужно быть внимательно, потому что размер будет не тот который вы запросили с наибольшей вероятностью как обычно работают пришел какой-нибудь запрос, вы понимаете, что для обработки данных вам нужен массив длиной, не знаю, 3 килобайта договорите raypool.share.rent от 3 килобайт вам вернется с 99% вероятностью, если не со 100% массив из 4 килобайт потому что длины массивов они фиксированы макетов много сильно плодить не хочется поэтому они, грубо говоря, по степеням двойки там аллоцируются и вам вернется больший, возможно, массив, поэтому когда вы пишете код, надо понимать, что там ray.length писать будет нельзя, нужно будет знать, сколько вы в этом массиве заполнили сами по себе как устроен shared raypool внутри?
912.00 1314.00 "Игорь Лабутин" они немножко по-разному устроены с configurable shared, он такой, довольно затейливый во-первых, есть для каждого потока аналог вот этого fastitem поля, который был в objectpool, но для каждого размера массива у вас есть ссылка, которая хранит ваш локальный кэш для каждого потока то есть, грубо говоря массив массивов по количеству размеров, которые вы настроили, или которые настроены в sharedpool то есть один массив каждого размера в каждом потоке может содержаться локально свой и потом поверх этого есть еще общий кэш, в котором есть массив partitions это, точнее, массив partitions если быть точно, это, соответственно, для каждого размера свои, а каждый partitions это массив уже partitions по числу cpu-шек а в каждом cpu это, по сути набор из 32 элементов максимум, значит в shared raypool он не настраивается, он как бы зафиксирован то есть как работает в данном случае, условно говоря сохранение, например, при возврате мы пытаемся сохранить сначала в thread local storage в тот самый кэш, который локального потока помним, что там для каждого размера массива есть только одна ячейка куда его можно сохранить дальше внезапно, если там в этой ячейке что-то есть, то казалось бы нам нужно пойти и положить его в далекое куда-нибудь хранилище но нет почему? если мы этот массив установили, значит мы недавно с ним работали и с хорошей вероятностью если мы прямо сейчас возьмем этот массив снова, то он же будет где-то там в кэшах процессора, вот это все и поэтому очень желательно то есть то, что вы сейчас возвращаете положить в тот самый thread local storage а то, что лежит в thread local storage переложить подальше, то есть при сохранении происходят два действия то, что уже лежит в thread local storage забирается в дальнее хранение а то, что вы только что сохраняете, сохраняется в tls вот, то есть сохраненный последний массив массив, который вы последний вернули он всегда лежит в thread local storage вот внутри бакетов вот этих вот которые партишены мы находим нужный партишен для своего цпу в нужном размере и пытаемся сохранить, вот если там нет места ну тогда попробуем запихнуть в какой-нибудь соседний партишен для какого-нибудь другого цпу чтобы не потерять вот, если понятно, что все места заполнены ну все, объект просто соберется в garbage collector в какой-то момент нужно понимать, что если вы алакцируете массивы то вам будет подбираться массив грубо говоря минимально возможного размера, который есть в наличии в пуле и который можно вам вернуть но вы же вольны попросить массив и большего размера которого нет в пуле ну или которого по какой-то причине не нашлось, то в таком случае массив будет вам залокичен вы сможете его использовать, но при ретурне такой массив просто соберется в garbage collector поэтому важно следить что когда вы работаете с RayPool то у вас на самом деле не происходит вот этой вот фоновой аллокации а вы реально используете массивы из пула, я про это чуть попозже поговорю возвращаясь к RayPool второй вид RayPool Lite там все попроще там есть только одно поле бакетс это просто массив бакетов для каждого размера и в каждом бакете это собственно массив того, где лежат ссылочки на уже готовые массивы в нужном количестве, который вы задали в конфигурацию то есть просто двумерный массив ссылок на массивы по сути говоря и здесь уже нет никакой там хитрой магии thread local storage, вот эти все cpu specific, это все такое здесь используется тупо spinlock для синхронизации то есть считается, что надолго синхронизации не будет и по большому счету там действительно надолго никакой синхронизации не нужно либо есть место, либо нет места и соответственно при получении массива либо есть массив в массиве, либо нету ну как бы если нету - все, пошли в фабрику, дернули, создали с точки зрения скорости здесь как раз, ну тоже синтетические тесты, конечно но было интересно, что RayPool довольно шустрый только на совсем уж маленьких массивах, там видимо overhead на вот эту всю магию синхронизации становится заметен и тогда как бы не очень эффективно в общем так же как в прошлом случае скорость меряете в вашем приложении вот, и внимательно смотрите значит возвращаясь к метрикам я сейчас не вспомню, но изучу что там в ObjectPool но ObjectPool по опыту нужен все-таки достаточно редко потому что в большинстве случаев проблемы возникают с memory-трафиком а memory-трафик - это как правило большие объекты, большие объекты в дотнете это там на 90% это либо строки, либо массивы в строке pool'ить смысла нет, потому что строки у нас read-only, а вот массивы pool'ить смысла есть, поэтому в большинстве случаев конечно вы всегда будете начинать с RayPool'а и pool'ить массивы, так вот в RayPool'е точно есть метрики, и метрики есть как раз таки вида, во-первых, сколько массивов отдано из pool'а сколько массивов вернули в pool, и сколько массивов залокейтили потому что может быть две причины потому что а) у вас закончился pool, и потому что б) вы просите массивы размера, которых просто нет физически в pool'е, то есть у вас pool настроен там, как я говорил, до 2 или до 4 мегабайт по умолчанию, а вы все время просите 10 мегабайт, pool в таком случае бесполезен, на эти метрики надо хотя бы в тестах обязательно смотреть, потому что вы можете думать, что вы круто что-то соптимизировали и настроили pool, хотя по факту там просто будет тупо работать New под капотом, и никакого pool'инга не будет на это важно смотреть, и если вы видите, что SharedRayPool по какой-то причине не вывозит в том плане, что дефолтные настройки приводят к большому количеству того, что либо у вас не хватает вечно массивов в pool'е, то есть вам нужен действительно какой-то большой pool, хотя это может быть алгоритм пересмотреть либо вы там с размерами, что-то не дефолтный набор размеров вас не устраивает ну тогда смотрите в сторону ConfigurableArrayPool но опять же, после его внедрения, даже если вы что-то протестировали на SharedArrayPool'е, на Configurable'е надо тестировать отдельно, потому что у него другая внутренняя структура другое устройство, другие примитивные синхронизации, он работает чуток по-другому вот такие вот дела про pool'инг на этом тут все
1314.00 1326.00 "Анатолий Кулаков" ну, отлично этот стандартный урок по ликбезу в дотнет, можно считать завершенным на этом можно переходить к другим, более практичным темам
1326.00 1328.00 "Игорь Лабутин" давай, практичная тема
1328.00 1330.00 "Анатолий Кулаков" что у нас сегодня за практичность отвечает?
1330.00 1342.00 "Анатолий Кулаков" ну, получается судя по темам, я, наверное, да а как тебе часто приходилось html рендерить в pdf, ну или вообще в pdf документы любые генерировать
1342.00 1344.00 "Игорь Лабутин" приходилось?
1344.00 1356.00 "Игорь Лабутин" честно скажу, что pdf генерить мне было нужно, но это было настолько в древние времена то, что я тебе назову технологию Crystal Reports и ты поймешь, насколько это были древние
1356.00 1362.00 "Анатолий Кулаков" времена и половина слушателей сейчас отваливаются не понимая, что это и зачем
1362.00 1376.00 "Игорь Лабутин" да-да-да, вот, а еще там был Lock4Net и вот это все а еще Lock4Net с Crystal Reports конфликтовали, потому что у них был одинаковый public key помнишь такой public key в подписях, в стронгнеймах?
1376.00 1386.00 "Игорь Лабутин" конечно, конечно там, короче, было много интересного в те времена ну да ладно, да, в общем, в современном мире нет pdf, я не генерил последние лет 6
1386.00 1560.00 "Анатолий Кулаков" 7 ну, в общем, это довольно нормальная практика, когда нужно генерить какой-то pdf документ потому что pdf они много чем удобны ну и в частности они удобны, потому что много разных организаций их требуют потому что все привыкли обмениваться в этом формате, потому что в обычных документах, не знаю, Word или что там у нас еще есть, Excel какие-нибудь HTML-странички они слишком такие непрактичные, ну то есть у них там шрифты могут по дороге потеряться, у них может верстка поехать у них может еще что-нибудь а pdf это, наверное, такой самый практичный формат, который вам более-менее гарантирует, что вы получите на печати а мы любим печатать все подряд и более-менее там таскает с собой все, что ему нужно, там, картинки, шрифты всякую векторную графику умеет поддерживать, в общем, формат довольно полезный, если так разобраться для некоторых кейсов довольно уникальный поэтому существует очень много библиотек, которые помогают там стряпать pdf, но на самом деле в принципе, самым простым способом получить красивенький pdf это через HTML потому что HTML обладает довольно богатым способом рендеринга вы там можете всякие таблички делать картинки вставлять, отступы выравнивать, даже разноцветности какие-нибудь применять, и при этом стандартный браузер умеет просто HTML страничку сохранить в pdf поэтому самым большим лайфхаком таким бывает если у вас не какие-то большие, там, отчеты там, не выпираетесь сильно в перформансе, у вас хватает простой простой верстки обычной HTML странички то есть самый простой лайфхак - это возьмите HTML и просто сохраните в виде pdf и обычно этого хватает в 80% случаев именно такими случаями и пользовался Рик Страхл автор как раз статьи, которую хочется обсудить он для себя выработал что ему всегда хватало такого подхода, поэтому у него была библиотечка то есть не его библиотечка, а он использовал специальную тулзу, которая называется WKHTML2PDF и ему его всегда хватало прелесть этой библиотеки была в том, что она была resource, это была обычная такая командлайнерская утилита, которая под капотом запускала QtWebKit и этот QtWebKit просто рендерил страничку HTML в pdf и все были счастливы и это продолжалось много-много лет, пока эта библиотека перестала поддерживаться, то есть она остановилась на какой-то старой версии хромиума, она больше не поддерживалась, там накопились какие-то уже старчерские баги, ну в общем, морально устарела и тогда пришла пора переходить на какие-то новые инструменты, но все новые инструменты тем или иным способом оказались плохие ну то есть да, действительно, они тащили с собой новый хром, они там предлагали какие-то новые функциональности, которые нужна была, но базовые вещи, такие как, например, составление table of content как на русском переводится table of content?
1560.00 2148.00 "Анатолий Кулаков" какое-то содержание что-то ты меня подвесил, table of contents оглавление оглавление, да, ну вот типа автоматическое составление оглавления, допустим, по всем нашим заголовочкам ни у кого нет, правильно расставлять переносы именно страниц, тоже мало у кого встречается, а если заинжектировать какой-нибудь css для того, чтобы как-нибудь подправить, чтобы страничка уже готовая, выглядела получше вообще мелко у кого есть и если есть, то за деньги казалось бы, для такой вроде бытовой задачи использовать какой-нибудь close source или платить деньги, слишком как-то оверкильно было, и поэтому Ник придумал, что в принципе у него есть WebView2 WebView2 это компонент для Windows встроенный, чем он прекрасен? На самом деле он прекрасен тем, что это стандартный хромиум под капотом и этот хромиум в принципе вам ничего не стоит, то есть он у вас уже стоит, он не требует никаких денег он бесплатный и он может сделать вам банальное сохранение, чтобы странички в pdf и этого в большинстве случаев хватало, ну то есть по крайней мере то, что делали многие продукты за деньги вот это можно было сделать с помощью данного компонента совсем без денег поэтому он решил, естественно написать свою библиотечку, которая лучше всех остальных и объединит всех остальных и давайте посмотрим, что же у него получилось во-первых, остановимся поподробнее на WebView2 WebView2 - это специальный контрол который у нас встроен в систему Windows и он по сути является в Windows оберткой над хромиумом если кто не знал, то хромиум с последних версий 10 и 11 винды поставляется как системный компонент для компонента, который называется Microsoft Edge WebView2 Runtime, то есть на самом деле под капотом там хромиум и поэтому мы можем его использовать если мы понимаем, что мы запускаемся на винде мы можем рассчитывать, что он там уже есть то есть мы можем его полноценно использовать, при этом не таская с собой большой, изжирный хромиум настоящий, при этом этот компонент инсталируется автоматически в последних версиях, если его нет и самое прекрасное, он обновляется автоматически с помощью системы Windows Update то есть он всегда будет свеженький, красивый хромиум поэтому WebView2 для Windows среды является довольно-таки заманчивым таким кусочком если копнуть поглубже, то это полноценный компонент, который используется в Microsoft Edge именно поэтому он всегда поддерживается в актуальном новом красивом состоянии так как это полноценный хромиум с Microsoft Edge, у него есть нативная поддержка принтинг диалога и вы можете там настроить, каким образом вы хотите печатать HTML и частной функцией печати является экспорт в PDF то есть там тоже настраиваются какие-то стандартные вещи, то есть там отступы цвета хедра, футеры вот это все, вот эти все настройки там уже есть просто из коробки, то есть вам достаточно просто взять этот компонент проставить вот эти настройки и вызвать одну функцию и оно все заработает, вроде казалось половину тулзов, за которые мы раньше хотели платить, мы уже заменили но можно копнуть немножко и дальше, у WebView есть прекрасный API который позволяет вам также внедряться хорошо в принт, в PDF экспорт и благодаря этому API вы можете избежать какой-то показки вот этого диалогового окна для печати, для выбора, для еще чего-то вы можете в вашем приложении настроить неинтерактивный режим для того, чтобы HTML конвертить в PDF без участия пользователя, без ничего что в большинстве случаев как раз таки и хочется и по всем замерам это происходит довольно быстро то есть сам компонент довольно хороший очень часто возникает ситуация, когда вы не сами стряпаете какой-то HTML документ, который хотите сконвертить, а вам уже нужно какой-то готовый, например, веб-сайт или страничку сконвертировать, или пользователь вам подсовывает свою страничку, которую вы должны сконвертировать и очень часто эти странички писались именно для веба на HTML то есть не были рассчитаны на то, чтобы их печатать у них, например, могут быть какие-то шрифты определенные, которые на принтере или на PDF выглядят плохо или не подгружаются у них могут быть неправильные разбиения по страницам вообще, если мы начнем разбираться, то HTML в HTML отсутствует понятие страниц, если вы вдруг не замечали то в интернете у вас вся веб-страничка рассчитана как один сплошной контент то есть у нее нет первой, второй, третьей, десятой страницы а когда вы печатаете в PDF по сути экспортируете в PDF, там используется уже более типографическая система, там уже есть страницы стандартного соотношения A4 обычно и так далее, то есть разбиение на страниц становится довольно важным и, например да, почему это важно? Ну, потому что когда вы пользуетесь стандартным гугловским экспортером в PDF, он вообще не загоняется о разбиениях он может вам разбить посередине допустим, какой-то параграф или перечисление из списка разбить посередине, или, например заголовок вашего абзаца оставить на одной странице а весь контент перенести на другую страницу то, что нормальный верстальщик, нормальный человек никогда бы так не сделал, в общем у Хрома это поведение по умолчанию вот, и очень полезно бывает это подсунуть свой CSS-стиль свой CSS-стиль, в котором вы можете объявить такие атрибуты как "page break inside" и "break inside" да, то есть вы можете выключить возможность брейка внутри, например, параграфов или после заголовков в общем, что тоже бывает очень-очень полезно и тогда переносы начинают работать правильно. В общем, зная всю эту магию, Ник написал свою библиотечку, которую вы в принципе можете легко использовать это пакет "HTML to PDF library" он устанавливается через NuGet и позволяет вам довольно легко, быстро и просто сконвертить HTML в PDF с довольно интересными хорошими настройками, которые вы из коробки сразу не достанете. У него есть ограничения, как я уже сказал, он использует Waview2, это значит, что он работает только под Windows, но у него есть плюсы и благодаря этому ограничению он не тащит с собой весь вот этот хромиум, что обычно таскают другие инструменты то есть это использует нативный компонент, который есть у винды. Ну, естественно он open-source этот пакет, он бесплатный к использованию, все такое из интересной кастомизации он может настраивать очень гибко отступы ориентацию, какие страницы печатать и так далее из неочевидных моментов но, наверное, каждый из вас это ожидает то, что он поддерживает хорошую асинхронность во всех своих методах, может писать как файлы стримы и много еще куда и поддерживает неинтерактивный режим, то есть вы можете, например, генерить PDF внутри ASP.NET Core приложения и это на самом деле не так уж и просто, как кажется на первый взгляд, потому что сам компонент, вот этот Waview2, он очень сильно прибит к десктоп-приложениям, то есть он поставляется как Windows UI компонент, а это значит что ему нужен Windows Event Loop как известно, в ASP.NET никакого Event Loop нет и пол статьи как раз посвящено тому, а как Ник пытался побороть эту проблему, даже не пытался, как он ее поборол да, то есть у него там были очень суровые хаки и по запуску потоков с правильными флажочками и по перехвату консолейшн-токенов в общем, если кому-то интересно, посмотрите но факт остается фактом, он добился того, что можно это использовать в ASP.NET Core приложении и это одна, наверное, из киллер-фичей в этой библиотеке а дополнительные фичи, которые у него есть, он добился того, чтобы можно было генерить содержимое документа, если вам это сильно нужно, которое автоматически собирается по всем заголовкам документа и в принципе если вы откроете такой PDF-чик, у вас там будут такие букмарки, закладочки, по которым вы хорошо и легко сможете навигироваться как я уже говорил, стандартный хромим из коробки такого делать не умеет также он добился того, что можно легко и красиво сделать CSS Injection, то есть вы можете поднастроить тот документ перед рендерингом, который вам дали как раз внести туда какие-то дополнительные вещи, какие-то дополнительные атрибуты которых там раньше не было, например вставить правильные разбиения в правильное разбиение страниц давайте же посмотрим на альтернативы если вдруг перед вами стала такая задача, какие альтернативы у вас есть? Ну, во-первых вы можете использовать специальный DevTools Automation Tools это, например инструменты, которые с помощью DevTools API могут управлять хромиумом. Эти инструменты используются, например, в частности, очень сильно при тестировании например, Microsoft Playwright использует такую штуку и Puppeteer Sharp библиотечка, что они делают? Они запускают хром к этому хрому подключаются через DevTools API в качестве клиента то есть хром запускается в качестве сервера они подключаются в качестве клиента и начинают его автоматизировать, то есть гонять хром и делать с ним всякое также, если в принципе вам не нужна какая-то большая кастомная настройка, вам просто хочется без лишних каких-то усложнений сконвертить существующую альтернативную страничку в PDF то это можно сделать с командной строки любого хромиума приложения. Хром, Edge, Vivaldi еще что-нибудь. У него есть специальный параметр с помощью которого вы можете запустить его и сконвертить все, что хотите но если вам нужна уже какая-то кастомизация если вам нужны вот эти вот дополнительные фишечки, разбиение в CSS Injection и прочее, то вот смело можно порекомендовать пакет Nika поэтому если вдруг перед вами такая задача стояла, то рассмотрите. Данная библиотечка, по-моему, довольно интересная, элегантная и хорошее решение для многих случаев
2148.00 2154.00 "Игорь Лабутин" Да уж, я смотрю, в современном мире прям непросто, непросто генерировать PDF. Хорошо, что мне этого не надо делать
2154.00 2162.00 "Анатолий Кулаков" Ну, да, да, в принципе задача в общем случае довольно сложная. Сложно, когда ты начал говорить
2162.00 2172.00 "Игорь Лабутин" про Windows Event Loop вот это все вот, да тяжело. Так а ну ладно, то есть это все только на
2172.00 2180.00 "Анатолий Кулаков" винде? Да, это все на винде если хочется какой-то кроссплатформенности гибкости и все такое, то там только платные компоненты, там уже надо идти в деньги
2180.00 2334.00 "Игорь Лабутин" Понятно, ну ладно, пойдем пока тогда в другую сторону а в другую сторону мы пойдем все-таки в SPNet Core и в Web API и в аутентификацию Не помню, когда мы последний раз касались темы аутентификации, но мне кажется, про всякие authentication handlers мы говорили как-то очень давно а тут попалась тоже небольшая статейка про то, а что делать, если вам нужна не модная молодежная аутентификация по GVT, вот этому всему кухе там, а просто по обычному APQ, то есть у вас есть APK и в зависимости от того валидный он или не валидный нужно разрешить или запретить действие. Автор статьи говорит, что есть несколько способов это сделать и один из способов который он упоминает первым и говорит, что не надо им пользоваться, это реализация фильтров, то есть вы можете реализовать IAuthorization фильтр и в нем что-то проверять, что-то отклонять и так далее, но это как бы неправильная часть, потому что все-таки это авторизация автор считает, что по APQ возможно вы определяете в том числе кто такой этот пользователь и значит, что это скорее в том числе аутентификация, поэтому лучше использовать для этого специализированное средство, а именно Authentication Handler для этого вы можете сделать свой собственный хендлер для этого вы создаете новый класс наследуетесь от Authentication Handler это стандартный ASP.NET Core класс и дальше вы таким образом встраиваетесь в pipeline основного ASP.NET понятно, что там есть всякие разные тоже практики для AP ключей, если вы вдруг решите пользоваться, что они там должны правильно генерироваться криптобезопасно вот это все, только что TPS, их нужно ротировать, при логировании нужно быть очень аккуратным чтобы эти AP ключи не посвятились в каких-нибудь урлах, в сообщениях об ошибках или в логах вот, но тем не менее, если вы вдруг решили ими пользоваться и вы решили реализовать свой Authentication Handler, для начала вы в этом Authentication Handler валидируете ключи, вероятно для этого у вас будет какой-то свой собственный интерфейс APK валидатор который собственно возвращает валидный ключ или не валидный и возможно возвращает например, что это за пользователь, проверив по какой-нибудь внутренней базе данных а после этого вы в этом месте в этом Handler создаете объекта принципала как я люблю эту терминологию принципалы с клеймами как перевести клейм на русский?
2334.00 2338.00 "Анатолий Кулаков" утверждение утверждение, наверное, да, самое близкое
2338.00 2350.00 "Игорь Лабутин" ну вот по-моему в книжке по ASP.Core мы переводили как утверждение, но я тут где-то встретил а по-моему чуть ли не в этой статье, нет где-то в интернете я встретил перевод как претензии, и там был типа принципал с претензиями
2350.00 2358.00 "Анатолий Кулаков" в тексте статьи претензия, что твой юзер ID равен такому, это как-то не звучит вот утверждение, что моего юзера айдишник такой-то, это в принципе нормально
2358.00 2522.00 "Игорь Лабутин" но клейм это же как бы действительно претензия то есть ты когда действительно куда-то посылаешь какую-нибудь там претензию, по-английски это будет клейм это тоже верно, поэтому видимо был какой-то автоперевод и в итоге получился такой, да вот этот самый токен с претензиями ну да ладно короче, создаете принципал, создаете клейм его возвращаете, и все нормально дальше помимо вот этого самого хендлера, помимо основного метода, нужно еще переопределить метод handle_challenge_async который как раз-таки нужен для того, когда он будет вызываться в тот момент, когда у вас по какой-то причине нету вообще например apk или еще что-то, именно в нем вы отвечаете 401 authorized с нужными заголовками которые подскажут клиенту вообще с какой авторизацией к вам нужно приходить естественно нужно использовать problem_details, если что, вот это все но дальше, вот вы имеете authentication_handler и что с ним делать, его нужно как-то зарегистрировать оно делается все через метод add_authentication и там есть следующие варианты, если вы просто сделаете add_authentication, то понятно, что будет использоваться стандартный, обычный автоавтентификация, стандартный pipeline aspen_addcore, то есть по моему, по дефолту только cookie добавляется, мне кажется но сейчас не скажу я давно стандартного уже не пользовал но вы можете указать вашу схему как раз таки туда вы передаете apk функцию add_scheme, вы передаете apk, ваш authentication_handler в качестве типа параметра и передаете, соответственно дефолтная схема это ваша схема и все будет работать по дефолту дальше понятно, что еще в ашке этот самый валидатор нужно закинуть тоже в di и все бы хорошо но такой способ будет хорошо и прекрасно работать только если у вас только apk и аутентификация если же у вас вдруг, например поддержана вы хотите поддержать в вашем сервисе аутентификацию и по apk ключу и по gvt и по допустим cookie то не будет достаточно закинуть 3 схемы аутентификации и с этим работать но вернее как, на самом деле будет и работать оно будет но оно будет работать очень своеобразно вы будете получать эрроры в логах потому что asp.cor по дефолту он начинает перебирать схемы аутентификации одну, вторую, третью пока не найдет либо ту, которая скажет ok либо пока не переберет все и не скажет, типа, все, тогда нельзя вот, а зачем нам эрроры в логах?
2522.00 2626.00 "Игорь Лабутин" и для того, чтобы это все нормально работало там нужно тогда уже регистрировать свою политику по выбору своей authentication то есть там регистрируются дополнительные классы которые могут изучить ваш реквест и по, допустим, наличию нужных заголовков выбрать нужную схему аутентификации и так далее автор сказал, что это все очень сложно будет в следующей статье как только она будет, мы обязательно про нее расскажем но на самом деле мне очень понравился комментарий к этой статье и это интересный вопрос, который я тоже в какой-то момент задавал ну вот я тут рассказал, что нам нужно переопределить стандартный класс написать его, значит, куда-то там закинуть di хитрым способом добавить эту дефолтную схему авторизации вот это все внутри этого аутентификация создавать там прицепало с клеймами вот этим всем вместо всего этого, написано в комментарии, а почему не сделать просто в самом медлеварке получили из заголовка просто написать свою медлеварку, которую получили из заголовка APK проверили его, ну тем же, допустим, валидатором окей, если окей, то пошли дальше, если не окей, ну значит как бы ответили 401 нафига вот это все устраивать и так далее я для себя в какой-то момент ответил, что ну если вы гарантированно знаете, что у вас будет всего один вариант, то, наверное, можно и так, но поскольку заранее требования не знаешь, то проще встроиться в стандартный и получать стандартный принципал, стандартный клейм, стандартный все и работать дальше независимо от того, как там прошла аутентификация но не знаю, возможно есть другие мнения
2626.00 2632.00 "Анатолий Кулаков" слушай, ну у тебя же вот этот хендлер он же появился, получился по сути только более такой, строго типизированный
2632.00 2646.00 "Игорь Лабутин" ну она, да, да, да и тут скорее вопрос сама-то middle-varic она простая, там понятно, что ты взял запрос и там, я не помню, что он возвращает он, по-моему, какой-то там результат возвращает, если я правильно помню, или исключение кидает, что-то такое там было, по-моему, вот
2646.00 2650.00 "Анатолий Кулаков" ну как просто, тебе все равно нужно будет сходить в базу, проверить подпись, сделать принципалы, все то же самое
2650.00 2656.00 "Игорь Лабутин" ну вот вопрос сделать принципалы как бы, может быть, можно было и без принципа ну то есть вот, мне кажется, вот это
2656.00 2658.00 "Анатолий Кулаков" а как ты current-юзера будешь использовать?
2658.00 2660.00 "Игорь Лабутин" не знаю, прокину асинк локалом
2660.00 2664.00 "Анатолий Кулаков" ну так то же самое ты же асинк локалом прокинешь
2664.00 2704.00 "Игорь Лабутин" как раз принципалы ну вот асинк локалом я прокину свою объектику тут какой-то принципал с какими-то клеймами да нет, я понимаю, о чем ты и вот это то же самое, в каком-то смысле о чем размышляю я, что проще встроиться в стандартные и тогда любой стандартный компонент знает где достать стандартного пользователя в цепочке спнет и со стандартными клеймами и всем добром, несмотря на то, что вся эта монструозная конструкция с принципалом всеми клеймами, скоупами, что им можно задать, она смотрится возможно оверкиллом для каких-то простых приложений и действительно у вас там будет всегда один клейм и все и больше ничего, ну значит так и будет но зато стандартно
2704.00 2822.00 "Анатолий Кулаков" ну да, там же целая обвязка, целая инфраструктура вокруг, которая на это рассчитана и на это работает, вы получаете кучу там всех дополнительных бенефитов ну и это более становится очевидным, когда система усложняется, когда у вас действительно не один способ входа, а несколько способов входа а еще лучше, когда у вас есть не одно приложение, а несколько приложений, которые должны аутентифицироваться через единый сервер например, мы недавно прикручивали опеки для идентити сервера тоже очень увлекательное занятие, вообще не устаю поражаться, насколько гибок и прекрасен идентити сервер вообще то есть мы опеки прикрутили довольно легко, просто там и свободно вот, и там у вас уже несколько вариантов, то есть, допустим, приложение приложение приходит куда-то к стороннему, к другому ресурсу и оно хочет тоже обращаться к этому ресурсу по API-ключам у вас есть вариант сделать как здесь, допустим, на каждый запрос идти к идентити сервера, отдавать ему API-ключ, просить можно или не можно получать принципала и доступаться к ресурсам, но делать это на каждый запрос, это мобитон для этого и появились у нас JWT-ключи поэтому мы легко сделали так, что сначала ты, как клиент можешь через опеки обменять себе его на какой-то временный аксесс-токен а потом по этому аксесс-токену уже ходить непосредственно к ресурсному приложению при этом ресурсное приложение, этот аксесс-токен вполне способно провалидировать по цифровой подписи и работать с ним точно так же как с обычным JWT в общем, гибкость там обалденная в общем, и встраиваемость в идентити сервер тоже прекрасная и там у нас, естественно, куча там всяких схем куча челленджей, подключены какие-то сторонние системы и на вот такой большой сложности ты понимаешь, что все вот эти принципалы клеймы, мапперы, хендеры, аутентификаторы они имеют смысл потому что каждый из них выполняет свою работу и когда они все вместе связываются, получается довольно такая хорошая, мощная интерфейс-система ну а если вы делаете, конечно, свое какое-то приложение которое раздает котиков то, наверное, в middleware проверить какую-нибудь базик аутентификацию, и этого для вас
2822.00 2828.00 "Игорь Лабутин" достаточно будет. Ну, может быть и так но будьте готовы, если что, перейти на более полноценное решение. Почему нет?
2828.00 2834.00 "Игорь Лабутин" Ну что, давай дальше продолжаем про практические прикладные штуки
2834.00 2838.00 "Анатолий Кулаков" Практические прикладные штуки, говорим практически про тестирование, да?
2838.00 2840.00 "Анатолий Кулаков" Как ты часто, Игорь, любишь тестировать?
2840.00 2850.00 "Анатолий Кулаков" Да, ну unit test пишу, да Вот, и насколько часто тебе подводились инструменты для ассертинга?
2850.00 2858.00 "Игорь Лабутин" Никогда Ну, в смысле, нет, я путал expected и actual было, наверное, все путали
2858.00 2864.00 "Анатолий Кулаков" Пока не составился, я запомнил все-таки, в каком порядке Или ты начал какую-то стороннюю либу использовать?
2864.00 2888.00 "Игорь Лабутин" Нет, я, по-моему ни в одном проекте я никогда не использовал сторонних либов У меня очень много тестов было на inunity мне кажется, что в inunity ассершены в какой-то момент или вообще все время вынесены в отдельную либу inunity assertions, или namespace там только отдельно что-то я не помню, честно говоря но каких-то прям совсем сторонних я не использовал только то, что идет в комплекте с фреймворком
2888.00 2984.00 "Анатолий Кулаков" Ну, я думаю, что все вы уже догадались что мы пытаемся рассказать про нашумевшую новость, которой в принципе у нас не было но про нее каждый обязан знать это то, что fluent assertion сменили лицензию и сменили ее довольно интересно странно, безумно давайте поговорим об этом Начиная с версии восьмой fluent assertion распространяется под двойной лицензией и что это для них значит они выбрали себе коммерческий путь с восьмой ветки, бесплатно вы можете использовать теперь только в некоммерческих продуктах fluent assertion, а вот если у вас коммерческий продукт, то там вы должны отвалить практически 130 долларов за каждого разработчика в год это довольно-таки большая сумма данное предложение действует в связке с компанией XSEED, я так чисто по документам не очень понял они то ли продались компании XSEED то ли XSEED выкупила право на ту часть которая коммерческая, то ли они с ними взаимодействуют, в общем там как всегда хитрожопные какие-то английские высказывания из которых ничего не понятно, ну в общем казалось бы, это компания XSEED, которая продает уже очень долго большие качественные компоненты для интерпрайс всяких winform, dpf-форм и прочих форм, ну в общем контроллы для этих интерфейсов довольно мощные она должна уметь в цену как-то играть у нее должны быть какие-то эксперты, которые понимают сколько можно выставлять цену, сколько нельзя выставлять цену, в общем ну 130 баксов за библиотеку, которая сравнивает объектики циферки, константы это как-то слишком много
2984.00 2992.00 "Игорь Лабутин" ну она интерпрайсно сравнивает это с безопасностью как-нибудь с поддержкой интерпрайсной
2992.00 3066.00 "Анатолий Кулаков" вот вообще-то да, наверное, но то, что было, обычно людям хватало вряд ли кому-то нужна была интерпрайсная никто не догадывался, что им нужна была интерпрайсная поддержка для Assertion Library, который сравнивает два числа теперь, наверное, ко многим такая мысль начала постепенно приходить что если вам нужно сравнить результат, который вы ожидаете, результат, который у вас имеется, для этого нужно заплатить 130 баксов вот интересно у всех не вызывает в основном возмущение то, что она стала платной, но в принципе много сейчас пытается библиотеку Open Source стать платными это мелочи, у всех возникает возмущает очень сильно эта цена мне понравился ролик Ника Чапсоса когда он там, тоже у него подгорал рассказывал, что, а думаетесь люди как бы это не DE, это не Photoshop это не какой-то редактор видео или 3D Studio Max там, нет, это простая библиотечка которая сравнивает пару объектов, в общем из-за этого вы должны платить как бы 130 баксов в общем, довольно какое-то странное решение, пока оно кажется мега-безумным для любого человека, который умеет думать но почему-то все с серьезным рылом обсуждают, что да, да что такое коммерциализация, это хорошо и прочие вещи ну, опять же, что нам делать?
3066.00 3068.00 "Анатолий Кулаков" Игорь, как нам теперь осерт это делать?
3068.00 3078.00 "Игорь Лабутин" руками, ну слушай если нужны какие-то экстенджеры, пишем сами что, нет? за 130 долларов на человека в год можно, мне кажется, и написать
3078.00 3082.00 "Анатолий Кулаков" можно нанять Джуна и пусть он как бы пишет
3082.00 3108.00 "Игорь Лабутин" ну, я не знаю, видишь, я не пользовался флуентами, для меня синтаксис выглядит, ну скажем так мне не нравится, короче, такой синтаксис совсем, он очень многословный и вот это все но, опять же я не думаю, что там какой-то миллион разных экстенджер-методов то есть там, наверное, самое сложное это только сама логика сравнения объектов по сути, там с ходом полей рекурсивно, вот это все
3108.00 3122.00 "Анатолий Кулаков" да, это иерархия, это сравнение иерархии объектов, какие-то поля можно выкинуть какие-то сравнить, для которых основной компайр настроить, вот иерархическое наследование, да, это вот киллер-фича, который мало у кого есть, можно даже сказать, ни у кого такой нет
3122.00 3140.00 "Игорь Лабутин" но тут вопрос, ну подожди, тут, наверное, вопрос у нас наверняка есть, библиотеки, которые позволяют именно просто сравнить, не в формате, что это осершено, просто сравнить, ну вот библиотека сравнения, надо как-то порыться может есть, может нет, я не знаю вот, и поверх этого построить экстенджент-методы именно с осертами, ну мне кажется, несложно
3140.00 3284.00 "Анатолий Кулаков" ну, наверное, несложно, но, опять же, есть, наверное, отдельные библиотеки, просто стандартных осерт-лайбер такого нет, да, то есть это можно сказать вот конкурентное преимущество было вот, насколько там часто вы этим пользовались, это уже вам решать, это уже вам смотреть, я, кстати, тоже не особый любитель того, чтобы сравнить два числа, для этого писать как бы fluent syntaxes на нативном английском языке через точки поэтому я тоже предпочитаю стандартный осерт-лайбер и мне, в принципе, ее хватало но надо признать, что библиотека довольно распространенная, там, по скачиваниям Snuget'а, она там входила в какие-то топы, поэтому многие, многим людям, видать, нравятся что же им делать? Ну, во-первых нужно запретить обновление пакета старше, чем ветка 7 на 8-ую версию не переходить я надеюсь, у вас у всех есть локальные пакетч менеджеры с помощью которых вы контролируете свои зависимости и кэшируете локально все, чтобы не лазить в интернет на каждый билд, и вот там практически у всех этих пакетч менеджеров есть настройка что какие версии пускать, какие не пускать. Можете смело блокировать все, что больше 8-ой ветки, потому что 7-ая официально как бы остается всегда свободной Также точно можно посоветовать прекрасную библиотечку, которая умеет мигрировать fluent ассершины под стандартные XUnit ассершины в общем, если вам интересно, то будут ссылки в шоу-нотах, посмотрите Библиотека на Рослине, которая просто одним движением руки мигрирует все, что есть Какие-то сложные вещи наверное она не сможет перенести в качестве примера это какое-нибудь иерархическое сравнение Но если вы пользовались только какими-то стандартными вещами то она очень много всего умеет и постоянно развивается, там автор хорошо дописывает поэтому возможно вам ее хватит Если вдруг вы любитель все-таки вот этого fluent синдекса и не хотите возвращаться на стандартные ассерты то сейчас самым популярным решением, которое все рекомендуют является Библиотека Шудли Она практически с тем же самыми словами, с теми же самыми точками и наворотами, как и fluent ассершин помогает вам делать практически все то же самое. У нее сейчас тоже не хватает иерархического сравнения такого мощного, как во fluent ассершине но я думаю, что авторы на волне хайпа в ближайшее время все это допилят В принципе такие альтернативы, я думаю не слишком большая потеря все найдут куда перейти поэтому пользуйтесь, смотрите и наблюдайте почаще за новостями в ваших любимых open-source библиотеках потому что они могут стать вдруг нечаянно а не только не open-source, но и очень-очень дорогими
3284.00 3340.00 "Игорь Лабутин" Супер! Минус еще одна библиотечка плюс возможно многие новые а может и нет, действительно непонятно. Ладно Поглядим как пойдет. Пойдем в новости на самом деле неожиданная. Не то что новость неожиданная, но вполне ожиданная на самом деле довольно старая это новость про nullable reference type в f# и вот это как раз странно и мне это что-то... мы обычно не берем какие-то большие темы про f# потому что не то, что мы в нем большие специалисты но тут мне как-то что-то стало интересно разобраться как это все устроено я статью прочитал наверное даже в ней почти все понял, поэтому давайте красненько пробежимся, потому что я на самом деле считал что snullable reference type в f# проблем нет потому что в f# нет проблем с nullами но оказалось все не так просто
3340.00 3342.00 "Анатолий Кулаков" в f# нет nullов, поэтому проблем с ними нет
3342.00 3572.00 "Игорь Лабутин" в f# действительно нет nullов но проблема в том что если ты пишешь только на f# тогда нет nullов, но стоит тебе заиспользовать хоть что-то написанное например на c# а у нас языки же все-таки на одной платформе, поэтому бывает такие случаи то в этом случае сразу становится возможно nullы, потому что в c# это у тебя могут быть nullы более того, дефолтный тип string например, в c# он же может содержать nullы поэтому если тебе какой-нибудь метод из c# библиотечки возвращает string то в f# добро пожаловать, потенциальный null reference вот, и с этим надо что-то делать значит соответственно, исторически f# действительно старался все это минимизировать и запроверять в compile-time как можно больше особенно потому что все стандартные, грубо говоря наиболее популярные типы - это рекорды discriminated union, которых мы все еще ждем в c#, таплы функции, анонимные рекорды - они все не позволяют туда запихнуть null никак можно повесить атрибут allow null literal и тогда можно в такие штуки запихнуть null, но во-первых, этот атрибут можно повесить только на кастомный тип, и он все еще недоступен на рекордах, юнионах и там еще на некоторых вариантах если же вам нужно что-то, где вы бы использовали например null в c#, то в f# вместо этого лучше использовать какой-нибудь там тип option в котором, соответственно, есть sum когда есть какие-то результаты - none, и дальше паттерн-матчингом с этим что-то делать но f# мир был бы хорош, если бы не было c# в каком-то смысле потому что есть interrupt и если у вас есть reference type, который приходит из c# то в f# компилятору не остается ничего другого, кроме как считать, что на нем висит атрибут allow null literal потому что, ну, кто его знает, что там от этого c# придет, враждебного так сказать, мира но бонус и хорошая новость состоит в том, что со времен как бы того, как зарелизили первые версии c# с такой парадигмой f#, прошу прощения c# тоже не стоял на месте, и потихонечку потихонечку кодовая база c# размечена такими атрибутами nullable reference types они там довольно заговористые бывают, там всякие null if not null и вот это все, но по крайней мере есть разметка, которая позволяет понять а может ли вот из этого c# кода прилететь хоть какой-то null и теперь f# научился этому тоже немножко следовать и можно теперь в f# проекте включить специальную настройку nullable enable, как у нас собственно это делается в c# и после этого у вас с одной стороны компилятор будет пытаться понимать, что же там делает этот самый c# код, в том смысле, что какие атрибуты на нем развешены а с другой стороны появился новый синтаксис, т.е. в f# появился синтаксис или null т.е. вы можете теперь по сути сделать юнион с null'ом, грубо говоря т.е. вы пишете вертикальную черту, как вы обычно это делаете для создания обычных юнионов но вместо второго типа вы пишете слово null, ключевое и да, соответственно в этом случае у вас reference type будет явно уметь содержать null, без необходимости повесить атрибуты lau null literal вот, таким образом это более языковая фича становится нежели чем такая не знаю, компиляторно-рантаймная что ли, компиляторная скорее
3572.00 3582.00 "Анатолий Кулаков" а не рассказывается, почему они по умолчанию не включили вроде кажется логичная штука, что тебе через c# может прийти любой reference type в виде null'а и она должна по умолчанию быть включена
3582.00 3602.00 "Игорь Лабутин" ну, нет, как раз наоборот если включить по умолчанию nullable enable то у тебя получится, что тип ну, т.е. ты вроде как объявляешь ну, у тебя там string, да допустим из функции возвращается но string, если ты включишь nullable enable то string будет означать ненулябельный string
3602.00 3608.00 "Анатолий Кулаков" обязательно. Да, но теперь стандартная библиотека она вся размечена и тебе там вернулся бы нулябельный string, а не просто string
3608.00 3624.00 "Игорь Лабутин" и если тебе вернулся нулябельный string то ты его обязан объявить в c# теперь с ты должен его объявить как string вертикальной черта null и тогда включить nullable enable и пожалуйста. Т.е. грубо говоря, это аналог того, что ты бы в c# написал string вопросик
3624.00 3648.00 "Анатолий Кулаков" да, просто я про то, что сейчас в c#, если ты создаешь новый проект по дефолту, то у тебя nullable enable включены, поэтому string и nullable string, это в принципе два разных понятных типа. По идее, такой же по дефолту в f# интерпретация c# кода должна быть включена, т.е. он должен понимать string и nullable string, что это два разных нулябельных типа по дефолту это поведение выключено
3648.00 3704.00 "Игорь Лабутин" ну вроде как да, по крайней мере пока я так понял что ровно так может они просто пробуют, а потом вероятно, да, вероятно, не знаю но по дефолту вроде как выключено значит дальше, соответственно, если ну f# компилятор, понятно, научился там правильно генерить нужные strings для всяких potential dereference null, т.е. если он понимает, что тут как раз нулябельный вариант, т.е. типа string вопросик в терминале c# а вы к нему просто dereference его, и там будет null потенциально, то он конечно вас предупредит и скажет, что тут надо вообще-то попроверить что там и кто там вот, а еще там есть всякие кастомные штуки, типа, например, он будет проверять, что string всегда возвращает ненулябельную строчку, т.е. string не имеет права возвращать null в f# и, соответственно, я, кстати, не знаю все шарпи, можно из ту стринга null вернуть?
3704.00 3710.00 "Анатолий Кулаков" ну если он раньше всегда обычный string возвращал, который, по сути, может быть ну да, да, да, вот в f#
3710.00 3846.00 "Игорь Лабутин" короче, нельзя, и это будет ворвание компилятора, если вы включили nullability дальше, ну, соответственно pattern matching улучшили, теперь можно нормально написать null в тех местах, где нужно вот, и самое интересное про type inference, т.е. f# вообще известен ну, не то, что одна из ключевых фичей, но довольно важная фича в том, что очень часто не нужно писать типа, потому что компилятор практически очень умный и выводит ну, все, что можно, сам но с nullable reference type проблема вот в чем допустим, у тебя на вход функции пришла какая-нибудь функция какой-нибудь тип, который нулябельный если ты в c# напишешь if там s какая-нибудь строка пришла не равно null, да, и дальше что-то внутри if, а внутри if компилятор умный и знает что внутри if у нас строка точно не null да, и к ней можно безопасно dereferencing ее, и вот это все не будет никаких warning, ничего f# компилятор, несмотря на крутой вывод типов и всего такого, не умеет пока, по крайней мере, во flow анализис, и это поэтому всякие if, when, else и while, если вы напишете внутри с if-ами вот эти все то там не оно никак, короче, не влияет на nullability вот, и даже если вам пришла нулябельная строка, вы напишите if, проверите на null, внутри она все равно будет считаться нулябельной, и на dereferencing будет все равно warning ну, пока неудобно, да но, видимо, ресурсов не было, для пилить компилятор до такого уровня, пока для того, чтобы это обойти, рекомендуется все-таки делать это нормально через pattern matching, там все вроде неплохо, ну, в случае с pattern matching, и может быть это чуть более такой функционально правильный подход, чем писать императивные if-ы в pattern matching там нулябельность нормально выводится вот, в будущем, соответственно ну, да, вот они явно пишут, что типа мы посмотрим на юзер фидбэк мы посмотрим, как это вообще все взлетит-не взлетит и будем думать то, над чем они сейчас уже точно думают это над аналогом наших операторов вопросик .
3846.00 3878.00 "Игорь Лабутин" то есть это вызов методов, если у вас ссылка на объект может быть null и двойной вопросик как он там, не помню, как он называется, который позволяет вернуть, соответственно, левую часть выражения, если она не null и правую часть выражения, если левая часть оказалась null как они будут выглядеть и какое количество стрелочек, минусиков и прочих спецсимволов они будут выражены в f-шарпе, я пока не знаю они пока думают, возможно, есть где-то пропозал, где можно это все посмотреть, я так сходу не смотрел
3878.00 3888.00 "Анатолий Кулаков" ну, да, это же чисто императивная такая штука вызвать, если не null то у них же там должна быть какая-нибудь monando, lambda да, да, да, да, да ну и
3888.00 4004.00 "Игорь Лабутин" опять же, идут разговоры будут смотреть на фидбэк на тему того, как это все работает со всякими проверками типов в рантайме, с анбоксингом и вот этим всем, потому что это все рантаймовые штуки, компилятору, ну, в общем очень сложно в этом месте понять, что там будет с nullability потому что какой реальный объект туда придет, может быть понятно только в самом рантайме так что тут будем думать, в общем, на удивление оказалось, резюмируя всю статью, что несмотря на то, что я так считал f# таким null safe языком все дела, оказалось, там есть о чем есть что посмотреть там все не очень тривиально, несмотря на очень умный компилятор, он не всемогущий и много где не может пока захандлить nullability так что последим-последим, посмотрим, во что это выльется и еще такой момент что, как я понял, статью есть пока некоторые с одной стороны есть штука, что f# будет стараться на своих сборках размечать метаданными свои типы с учетом вот этих атрибутов nullable reference types то есть, грубо говоря, если вы наружу выставляете неналовый какой-нибудь там union то f# повесит на эту сборку метаданные для этого там ретурнозначения, что оно non-null так что c# компилятор, соответственно будет знать, что вот если эту сборку позвать, там будет правильная метаданная и точно не null вот это с одной стороны, а с другой стороны в обратную сторону соответственно, как я понял, там не все атрибуты пока поддержаны, то есть всякие вот эти хитрые вывернутые null if not null вот это все может быть там тоже не до конца еще все поддержано поэтому тут тоже будут развиваться в общем, последим-посмотрим мне стало прям интересно, чем это закончится, надо поглядеть в мир f# тоже немножко, хотя бы одним глазком кстати, да, если я вдруг в чем-то сильно наврал или все переврал и все на самом деле совсем не так, пишите на моих комментах приходите, расскажите, как на самом деле
4004.00 4018.00 "Анатолий Кулаков" ну да, действительно, язык интересный к сожалению, мало у нас экспертов к нему, поэтому заходите, особенно если вы захотите прям что-то вообще экспертное донести то будет красота можно прям докладик даже организовать
4018.00 4026.00 "Игорь Лабутин" ты сразу на докладик давайте хотя бы на 5-10 минут в подкастик прийти, а может крутой подход, ну давай, книгу сразу писать
4026.00 4036.00 "Анатолий Кулаков" после доклада засядем обязательно, а в аудиоформате очень легко пишется, точно ты пробовал читать код на f#?
4036.00 4038.00 "Игорь Лабутин" голосом
4038.00 4044.00 "Анатолий Кулаков" голосом, да я слушай, на c# то он голосом не очень выглядит а если так визуально, то
4044.00 4052.00 "Игорь Лабутин" а на f# вертикальная палочка скобочка, угловая вот это все, ну короче
4052.00 4060.00 "Анатолий Кулаков" специфично, ты просто будешь называть не вертикальная скобочка типа применение монады третьего уровня к пятому эквивалентному преобразованию
4060.00 4064.00 "Игорь Лабутин" хорошо, ладно давай какую-нибудь тему попроще
4064.00 4334.00 "Анатолий Кулаков" давай попроще, если как раз поговорить это топ 10 ошибок найденных в c# проектах, нормальная же тема, за 2004 год 2024, да, то есть как раз 25 начался, интересная тема как раз про то, чтобы завершить прошлый год и посмотреть, а что же в нем такого интересного было найдено, найдено по версии pwstudio pwstudio это анализатор, не только c#, но и много всего там прежде всего плюсовый, c# код java код, в общем они много чего умеют анализировать нам интересно, естественно c# проекты, они очень много пишут на хабар про свой анализатор и так далее в принципе, меня всегда, когда я смотрю вот эти отчеты pwstudio, у меня такое ощущение, что нормальные люди так не пишут, это какие-то просто идиоты, но когда мы видим настоящие большие проекты которые мы сегодня в том числе рассмотрим и видим вот эти идиотские ошибки, которые там есть просто диво дарю, даешь себе как это все работает, а некоторые даже не идиотские ошибки, некоторые ошибки в принципе вполне нормальные, я тут парочку нашел прям таких ого-го, о которых даже как-то не задумывался, поэтому я тебе предлагаю давай посмотрим, чем люди дышат как бы, какие до сих пор продолжают делать ошибки уже в 2024 году и что из этого получается автор расставил ошибки по 10 местам я бы их расставил по другому, но в принципе почему бы и нет какая разница, тут главная формальность поэтому пойдем точно так же по порядочку посмотрим, с 10 начнем место на 10 месте находится unity 6 и его интересная ошибка об equals, вот это кстати мне кажется довольно неочевидная штука и вот она могла бы там в каких-то первых местах вполне сиять давайте поподробнее сейчас у нас будет много кода словами поэтому приготовьтесь, насторожитесь, наострите ушки и погнали когда вы переопределяете класс или структуру когда вы хотите переопределить метод equals обычно у вас есть два метода equals один строго типизированный и другой, который принимает объект который принимает объект, он объявлен в созданном объекте и обычно что он делает он проверяет, что если этот объект равен нашему типу то вызывает уже строго типизированный equals, который принимает уже строго типизированный наш объект и начинает у него какие-то поля проверять и очень интересная ошибка может с вами случиться когда вы в метод equals от объекта пытаетесь понять, а ваш это объект или не ваш это объект обычно как это делается? это делается переменная которая к нам пришла other, is например в данном случае это был searchIndex и тогда вызвать equals непосредственно с этой переменной но проблема заключается в том, что если вдруг вы этот метод скопипастили и на самом деле он находится не в классе searchIndex, на который проверяет оператор is, а в классе searchField, и строго типизированный метод как раз переопределен для searchField, и вы-то думаете, что equals вы вызываете со строго типизированным searchField, но на самом деле вы вызываете equals с searchIndex а это значит, что вызовется метод equals от объекта, в котором вы как раз таки сейчас находитесь, если у вас мозги не свернулись трубочкой и вы проследили весь мой workflow, то вы понимаете, что это рекурсия, это рекурсия, которая легко приводит к stackoverflow, если вдруг вам реально в ваш equals придет searchIndex, то есть тот тип с которым вы по идее должны были просто вернуть false, все это упадет как бы в stackoverflow exception. Довольно занятная штука опять же, если без какого-то инструментария, который подскажет вам, что здесь рекурсия мог глазками, это не всегда очевидно можно найти, тем более кто там всматривается в эти equals на code review, наверное никто. Хорошая ошибочка девятое место тоже вот просто должно в первых наверно быть и список проектов в которых была найдена эта бага оно подтверждает мои слова только вдумайтесь, эта бага была найдена в проектах Garnet, RavenDB, MSBuild, Roslyn и, внимание, сама PVS-студия. В общем, хорошая такая бага и она как раз нами говорит, что многие разработчики не знают, что это вообще ошибка поэтому внимательно, в общем возможно в ваших проектах она тоже есть ошибка заключается с тем, что ForEach не умеет работать с null'ами. Как она выражается? Если вы возьмете некий контекст, из этого контекста запросите какой-то там элемент и у этого элемента попросите список реквестов и все это хотите проключить в ForEach но есть одна тонкость, когда вы запрашиваете контекст, реквеста у этого контекста может не быть то есть элемента, к которому вы хотите обратиться, может не быть и в таком случае вы можете поставить вопрос. и уже у этого вопрос.
4334.00 4514.00 "Анатолий Кулаков" запрашиваете список элементов то есть вы пытаетесь прокрутиться по условному оператору, который в случае, если вдруг реквеста не существует, вернет вам null а если существует, то вернет полноценную коллекцию реквестов. Когда он вернет полноценную коллекцию реквестов, вопросов нет но вот если реквеста не существует и полноценную коллекцию он вам вернуть не сможет то вернется из-за оператора вопросик, вам вернется null и на самом деле forEach с nullом работать не умеет он возьмет вам и выбросит исключение и исключение-то будет выбрасываться в методе getEnumerator, потому что Enumerator-то брать не у кого больше вот таким образом, якобы защищаясь от nullReferenceException мы здесь получаем nullReferenceException только немножко в другом месте, в getEnumerator в общем кажется, что разработчики не понимают что forEach-ить по коллекции, которой может быть null, не стоит это большая-большая ошибка вот именно поэтому у нас столько много проектов, которые были ей подвержены так, что у нас еще есть, восьмое место заслужил NobCommerce это такой интернет-магазин ну он сделал довольно банальную штуку он сделал query в базу данных там join на всяких наставил фильтров, выбрал объект а потом это все сохранил в переменную и сделал этой переменной точкой distinct точка distinct это метод, который не модифицирует самую переменную он возвращает результат уже модифицированный то есть по-хорошему, как это исправить это нужно было положить query=queryDistinct то есть вот этот запрос сохранить в переменную это тоже, наверное, частая ситуация, но мне кажется, большинство анализаторов уже научились не исправляться и разработчики уже в этих местах более-таки внимательные седьмое место - это Unity извечная проблема с string-форматом мне кажется, со string-форматом больше всего каких-то проблем возникает но вот и здесь, в string-формате пользователь, программист пытался вывести 4 элемента сделал даже template, в котором указал 4 placeholder и даже передал 4 переменных но проблема в том, что у этих 4 холдеров он указал всего лишь навсего индексы 0 и 1 у третьего тоже 0 и у четвертого тоже 1 то есть, несмотря на то, что передаются 4 переменные и 4 placeholder покажутся реально только 2 первых аргумента 0 и 1 ну, 0 и 1, такая тоже довольно банальная ошибка со string-форматом вечная, наверное, мы их никогда не заведем на шестом месте подвергся анализу сервер Diablo 3 слушай, кстати, я вот поймал себе на мысль, знаешь, когда мы с тобой все время пытаемся вспомнить, какие большие интересные проекты написаны там на Avalone написаны на C# в конце-то концов где вот все эти разработчики, которые миллионами пишут на C# проекты мне кажется, из отчета PV Studio я вот узнал больше интересных, открытых open-source там, больших проектов которые написаны на C#, чем из рекламы Microsoft
4514.00 4532.00 "Игорь Лабутин" ну, это да, хотя с другой стороны слушай, ну вот для меня, ну, Unity, понятно но Commerce, ну, тоже понятно оно звучало Garen Draven DBMS Build, окей но вот сервер Diablo 3 наверное, пожалуй, самое удивительное из этого списка, честно скажу
4532.00 4574.00 "Анатолий Кулаков" ну да, хороший, такой большой, полноценный сервачок, нормально поддерживается, нормально пишется на C#, в принципе, быстрый, красивый нормальный проект погнали, ближе к нашей теме, итак, что же там случилось ну, там случилась тоже такая банальная вещь которую очень часто, я не знаю в плюсах еще видел это когда мы вызываем какой-то метод и передаем эту переменную, в данном случае передаем переменную count и поставим два плюсика, то есть в надежде на то, что мы передадим переменную инкрементированную на +1 но так как два плюсика у нас поставлены справа то у нас сначала произойдет передача значения в метод а после того, когда мы из метода вернемся эта переменная увеличится на 1 это явно не то, что хотел по коду разработчик
4574.00 4582.00 "Игорь Лабутин" ну, непонятно, слушай иногда это как раз то, что хочется передать, а потом увеличить на единичку не зря же изобрели Postfix на оператор
4584.00 4868.00 "Анатолий Кулаков" да, там по коду было видно, что он все-таки ошибся ему надо было сначала заинкрементировать а потом передать это можно было бы сделать, написав эти два плюсика слева, то есть сначала заинкрементировать а потом передать, и так как вообще это была локальная переменная, можно было просто написать all count +1 и вот его передать, никакого смысла там выпендриваться и Postfix на оператор делать смысла не было так, под пятое место у нас под раздачу попал сам dotnet 8 вот, ниху хрему хрым давайте рассмотрим немножко код что, что сделал программист программист проверил, что если stack count меньше определенной длины, он возвращает null то есть выходит из метода а потом у этого стека делает метод pop но здесь есть небольшие тонкости stack в нашем случае это нулябельная переменная, то есть он проверяет if stack вопросик наш, вопросик .count меньше длины тогда выходим, иначе stack, и здесь подавление компилятора восклицательный знак pop то есть разработчик рассчитывал на то, что строка stack вопросик count при стеке равном null вернет ему true, при сравнении с длиной, но на самом деле это не так естественно у нас терминальная логика и вернет эта строка false, то есть по сути нулябельный стек вполне не пройдет это условие, и нулябельный стек провалится в следующую операцию, а следующая операция это pop, при том с подавлением компилятора, то есть тут чистой воды будет null reference exception отсюда можно сделать два вывода в микрософте тоже работают непонятно кто, но самый главный вывод это в том, что никогда нельзя пользоваться оператором подавления анализа нулябельных переменных у меня в многих проектах запрещено использовать оператор восклицательный знак и прекрасно живется на современных фреймворках вообще без проблем, поэтому если у вас есть такая возможность, обязательно ставьте восклицательный знак оператор в качестве ROR'а анализатор пришарпера позволяет такую штуку делать, в общем и никогда не используйте, прямо на руках сразу через поиск и бейте по рукам на ревью вот это самый главный вывод, наверное, который можно сделать из этой статьи, в общем, никогда нельзя подавлять компилятор, компилятор ваш друг если вы не умеете писать код, который удовлетворяет компилятор, значит, вы плохой программист четвертое место опять dotnet 8 попал под раздачу да что ж такое, ну здесь ошибка тоже довольно банальная мы крутим в цикле все инстансы, при том цикл через for по индексу и когда мы проходимся по всем этим инстансам, мы пытаемся обратиться к какому-то, к текущему инстансу и вместо того, чтобы написать инстанс от i, то есть от текущего счетчика мы обращаемся по статическому индексу instance от 0, то есть всегда возвращается нулевой элемент данной коллекции, ну бага такая понятная, примитивная, в принципе, довольно старая могла бы быть когда угодно, не только в 2020 году и, скорее всего, и была. Третье место опять unity 6 попал под раздачу вот тут уже веселее, потому что нам встречается вик референс, наверное, не все наши слушатели знают, что такое вик референс поэтому я немножко объясню вик референс - это специальный такой тип используется он довольно редко, вообще чаще, наверное, я его встречал когда мы писали под винформы еще вот в винформах, когда нужно подписаться на какие-то события и при этом не словить утечку ресурсов вот там таблицы на вик референсах это было прям, что must have обязаны были все знать и спрашивали даже на собеседованиях. Как только мы переехали под какой-то там backend вик референсов я, наверное, не встречал просто никогда ну, опять же, если вы кто-то разработчик то вы, скорее всего, про них знаете вик референс - это такой интересный объект, который сохраняет ссылку на ваш объект, то есть можно представить, что это какой-то тип переменной который сохраняет ссылку на объект но в отличие от других переменных то есть филдов или пропертей garbage collector имеет полное право у вас этот объект собрать если вы присвоите если вы присвоите значение переменной какое-то значение, то это значение собираться не будет если вы присвоите это значение переменной вик референс, то оно может собраться. Это как раз нужно для того, чтобы не удерживать переменную, если вдруг нам не хватает памяти, то есть вполне можно освободить эту переменную, но вдруг garbage collector еще не собирался, а там какая-то большая переменная, которой нам создавать второй раз лень, мы можем ее вполне заиспользовать. В общем, довольно хороший use case и он часто пригождался но в коде соответственно, с такими вик референсами нужно правильно работать. Это нужно знать и уметь. Что же написали у нас в Unity 6?
4868.00 5192.00 "Анатолий Кулаков" В Unity 6 написали обращение как раз работы с этим вик референсом Во-первых, все взяли в лог и в этом логе сказали, что вот у нас есть перемена вик референса. Давайте мы у нее проверим флаг, который называется is_alive это действительно флаг, который говорит, что собрал garbage collector эту переменную или не собрал а дальше обращаемся к этому референс-таргету, то есть тому объекту, который мы храним и который garbage collector может собрать. Кастим его к необходимому нам типу и вызываем у него прямо через точку метод который мы хотим у этого типа вызвать Ошибка заключается в том, что с тех пор, когда if проверил is_alive и до того момента, когда мы вызвали у этой переменной метод garbage collector вполне легально мог ее собрать. Поэтому мы в этот момент рухнули с null_reference_exception Здесь как вообще нужно работать с вик референсом и в частности в этом случае. Нужно было сохранить эту переменную в не так, не переменную а вот этот target. Нужно было сохранить target из вик референса в обычную переменную. И как только вы сохраняете ее в обычную переменную уже garbage collector этот объект не имеет права собрать, так как на него уже есть нормальная ссылочка, которая уже внутри вашего скопа. И тогда уже можно его как-то проверить и что-то с ним делать, как-то использовать Здесь еще также есть лог и возможно автор надеялся, что лог его каким-то образом спасет. То есть может это какая-то критическая секция, в которой egc не работает Но на самом деле лог здесь абсолютно ничего не делает. Естественно лог никак на garbage collector не влияет. Поэтому сборщик вполне может это все собрать и точно так же вы получите null_reference_exception Довольно интересная штука. Несмотря на то, что вик референс пользуется мало, но ошибка нетривиальная и интересная из-за этого. Второе место - Redos. Это тоже довольно оригинальная вещь, про которую нужно знать и многие разработчики про это не знают Что же такое Redos? Нашли, кстати, эту ошибку в screen-to-gif утилите Опять же, новая утилита для нас. Смотри, в которой написано C#, которая довольно хорошо пользуется. То есть она записывает экран в гифку, чтобы там удобно кому-то отправить там какую-нибудь службу поддержки, допустим или друзьям показать, что красиво на десктопе у нас происходит Итак, в чем же, соответственно, заключается смысл Redos атаки? Эта атака способна замедлить или даже вообще повесить ваше приложение на основании уязвимого регулярного выражения Если в это регулярное выражение передать какую-то произвольную строку, есть возможность передать какую-то произвольную строку и узлом мышленника есть возможность сформировать эту строку где-то там далеко и передать ваше приложение, то в принципе у него есть большой шанс ваше приложение завесить Это актуально только для регэкспов, которые вычисляются на основе недетерминированного конечного автомата. Такие тоже есть. И это актуально только если в вашем регэкспе используется определенная конструкция. Например, в нашем случае это произвольный объект с плюсом и группировка с плюсом Получается такая рекурсивный автомат Если у вас такая штука используется, то вам необходимо все-таки немножко подстраховаться. Есть специальные флаги для регэкспа, есть специальные флаги для эскейпов и так далее Есть способы как это решить В данном случае в утилиту screen2give этим регэкспом проверялся название входного файла и поэтому просто можно было в интерфейсе ввести специальную сформированную строчку, она довольно несложная и завесить приложение с помощью вот этого регэкспа, то есть полностью вывести настрой. Для десктоп-приложений, конечно, это не так критично, но если вдруг у вас такой регэксп используется на сервере, то вообще легко можно вывести ваш сервер в отказ в обслуживании. Поэтому тоже повнимательнее, если вы используете сложные какие-то регулярные выражения с рекурсией обязательно должны про эту штуку знать И тут интересно, что это не какая-то банальная, там какой-то паттерн-матчинг по коду или анализатор токенов Это нормальный такой security flow, где PV-студия проверила, откуда к нам пришел этот параметр, какое там регулярное выражение, есть ли в нем рекурсия Вот, и на самом деле в принципе PV-студия умеет проверять в том числе дефекты безопасности. Она может искать SQL-инъекции, LDAP-инъекции XSS, XAE и многие другие. То есть такой, в принципе, не то что полноценный flow-анализ security, но показывает, что с многими частыми распространенными вещами управляется. Ну и на первое место попал .NET 8 Не слишком экстравагантная ошибка, но в принципе тоже интересная. Ошибка заключается в том, что разработчик использовал интерполяцию строк вместе с форматом строки То есть он написал у текст-райтера, вызвал метод write, который принимает первым аргументом формат и остальными аргументами он принимает непосредственно значение, которое он должен подставить в этот формат. И в данном случае разработчик написал формат, поставил правильно placeholder в фигурных скобочках нолик, но при этом он задал знак доллара в начале строки. А это значит, что компилятор будет эту строку считать строкой интерполяции.
5192.00 5204.00 "Анатолий Кулаков" И если в этой строке интерполяции в фигурных скобочках задан нолик, то он не пойдет вам подставлять какой-то первый параметр. Он просто этот нолик заинтерпретирует как C# код и в частности просто как обычное число 0.
5204.00 5212.00 "Анатолий Кулаков" Поэтому в качестве конечного результата мы получим просто-напросто строку, в которой вместо placeholder поставлено число 0.
5212.00 5214.00 "Анатолий Кулаков" Вместо того, чтобы подставить какие-то аргументы.
5214.00 5218.00 "Анатолий Кулаков" Не то чтобы критично в данном случае, но в некоторых ситуациях это может быть довольно опасно и довольно
5218.00 5220.00 "Игорь Лабутин" страшно. Вот такой интересный топ.
5220.00 5226.00 "Игорь Лабутин" Да, мне интересно, почему это стало топ-1. То есть я бы вот как раз второй пунктик поместил на первое место.
5226.00 5230.00 "Игорь Лабутин" Она такая более и технически сложная и с точки зрения опасности.
5230.00 5234.00 "Игорь Лабутин" Такая простая штука с интерполяцией. Не знаю.
5234.00 5240.00 "Анатолий Кулаков" Ну да, я согласен с тобой, что нумерование здесь как-то выбрано странно. Может потому, что это dotnet 8.
5240.00 5242.00 "Анатолий Кулаков" Знаешь, базовый фреймворк, который везде есть.
5242.00 5254.00 "Игорь Лабутин" Либо dotnet 8, либо может быть еще... Может быть там как-то учитывалась частотность. То есть, грубо говоря, если... Ну, конкретно это вот пример типа в dotnet 8, а фактически их таких было дофигища разных всяких.
5254.00 5258.00 "Игорь Лабутин" Не знаю, может быть в этом еще фишечка.
5258.00 5264.00 "Анатолий Кулаков" Ну, может быть. Автор говорит, что он в принципе учитывал все. И популярность библиотеки, и чисточность, и критичность.
5264.00 5270.00 "Анатолий Кулаков" И все это с коэффициентом на его усмотрение. Поэтому не будем сильно придираться именно к местам.
5270.00 5284.00 "Анатолий Кулаков" Если вы хотите подробнее этот код все-таки послушать не ушами, а посмотреть глазками, посмотреть в каких проектах он есть, и подробнее статьи прочитать. Там практически есть подробная статья про каждую уязвимость. Тем более про сложные уязвимости там есть прям отдельные статьи.
5284.00 5292.00 "Анатолий Кулаков" Чтобы как раз себя просветить и в своем коде такого не делать. В общем, поэтому милости просим по ссылке. Все, мы предоставим шоу-ноутов.
5292.00 5294.00 "Игорь Лабутин" Да, все сделаем.
5294.00 5296.00 "Игорь Лабутин" И что у нас на сегодня?
5296.00 5298.00 "Игорь Лабутин" Кратко о разном осталось только?
5298.00 5302.00 "Анатолий Кулаков" Да, давай кратко пробежимся о разном.
5302.00 5304.00 "Анатолий Кулаков" И уже, наверное, хватит.
5304.00 5306.00 "Анатолий Кулаков" Ну что ж, начнем.
5306.00 5310.00 "Анатолий Кулаков" Тогда, наверное, из интересного у нас будет...
5310.00 5312.00 "Анатолий Кулаков" А вот закончился второй сезон книжного клуба.
5312.00 5318.00 "Анатолий Кулаков" Кто не знал, у нас на dotnet.ru портале есть еще подкаст, который называется "Книжный клуб".
5318.00 5332.00 "Анатолий Кулаков" Ведем его не мы, но ведут его замечательные парни. Это Роман Гошков, Григорий Кузьмин и Роман Щерваков. И они разбирают книги. Сейчас закончился второй сезон. Они разбирали книги Алекса Сюй.
5332.00 5336.00 "Анатолий Кулаков" "Систем дизайн", "Подготовка к сложному интервью". Очень популярная книга.
5336.00 5342.00 "Анатолий Кулаков" Интересные кейсы. И, в общем, ребята проходились довольно-таки плотно по всему материалу, который там есть.
5342.00 5356.00 "Анатолий Кулаков" Если для вас тема актуальная, то в виде такого аудиокниги, которую мы сегодня уже упоминали, вы можете послушать, как реально практические инженеры, которые сталкиваются с систем дизайном, но не только в собеседованиях, но и в реальной жизни.
5356.00 5358.00 "Анатолий Кулаков" В общем, что они об этом, обо всем думают.
5358.00 5362.00 "Анатолий Кулаков" Кстати, первый выпуск был 26 ноября 2023 года.
5362.00 5366.00 "Анатолий Кулаков" Больше, чем год. Ребята обсуждали эту книгу. Основательно хорошо подходили.
5366.00 5368.00 "Анатолий Кулаков" Все разбирали.
5368.00 5376.00 "Анатолий Кулаков" И, как я уже упомянул, это был второй сезон, а в первом сезоне была книга ".NET Microservices. Architecture and Containerized .NET Applications".
5376.00 5384.00 "Анатолий Кулаков" Несмотря на название, никакого уклона на "Containerized" там нет.
5384.00 5388.00 "Анатолий Кулаков" В общем, не только контейнерные приложения рассматриваются в этой книге.
5388.00 5396.00 "Анатолий Кулаков" Эта книга вообще про микросервисы, про то, как нужно строить архитектуру приложений, про то, как взаимодействовать с внешним миром.
5396.00 5398.00 "Анатолий Кулаков" В том числе и про контейнеры.
5398.00 5406.00 "Анатолий Кулаков" Поэтому, даже если вы не сильно используете контейнеры в вашем приложении, первый сезон тоже про .NET архитектуру, .NET приложения. Тоже интересно послушать.
5406.00 5408.00 "Анатолий Кулаков" Книга популярная, интересная.
5408.00 5412.00 "Анатолий Кулаков" И, опять же, ребята проходились по ней довольно плотненько и основательно.
5412.00 5422.00 "Анатолий Кулаков" Такие два сезона книжного клуба у нас закончились. Те, кто ждал окончания сезона для того, чтобы послушать все подряд, а не ждать через недельку, вот. Те дождались.
5422.00 5424.00 "Анатолий Кулаков" Можете начинать.
5424.00 5428.00 "Анатолий Кулаков" Так, еще одна у нас в чате интересная толза сплыла, называется она VELOPACK.
5428.00 5440.00 "Анатолий Кулаков" VELOPACK - это инсталлятор, который может сделать оффлайн-инсталлятор в вашем приложении. Опять же, речь про десктоп, скорее всего, приложения. Никакому ISP.NET, Backend, Frontend, вот это все не надо.
5440.00 5442.00 "Анатолий Кулаков" Но у нас много десктоп-приложений, почему нет?
5442.00 5444.00 "Анатолий Кулаков" И им часто нужен способ распространения.
5444.00 5454.00 "Анатолий Кулаков" Это какая-то больная тема, как бы в .NET было очень много инсталляторов, было очень много чего-то предложено, но как-то они то ли устаревают, то ли не поддерживаются, то ли бросают их.
5454.00 5468.00 "Анатолий Кулаков" В общем, с первого виду хороший инсталлятор, но умирает. И вот, кстати, появился очередной VELOPACK. Он позволяет вам не только заинсталлировать ваше приложение, но и также хорошо и легко его обновлять. Инсталлятор кроссплатформенный, естественно.
5468.00 5470.00 "Анатолий Кулаков" Практически не требует никакой конфигурации.
5470.00 5472.00 "Анатолий Кулаков" Все довольно просто.
5472.00 5494.00 "Анатолий Кулаков" Настраивается и просто делается. Там с полпинка заводится. Он умеет инсталлировать, обновлять, при этом обновляет он именно дельтами может, а не целыми пакетами закачивать, что важно, если у вашего клиента, кастомера, не такая стабильная связь. И все это делает он самостоятельно, без всяких настроек. Распространяется на Windows, OS X и Linux, поддерживается.
5494.00 5508.00 "Анатолий Кулаков" Никак не зависит от языка. Вы можете туда засунуть абсолютно любой язык, не только C# проекты. Безусловно, инсталлятор справится с чем угодно. Легко переиспользовать и умеет обновлять ваши пакетжи, ваши артефакты прямо с GitHub, что тоже удобно.
5508.00 5520.00 "Анатолий Кулаков" Устраиваете на GitHub пайплайн, в пайплайне у вас выдаются какие-то бинарники, и эти бинарники непосредственно подхватываются инсталлятором, и ваши клиенты счастливы, что у них всегда хорошая последняя версия. Тоже прекрасно.
5520.00 5522.00 "Анатолий Кулаков" Новость от Микрософта.
5522.00 5552.00 "Анатолий Кулаков" WinForms продолжает нас радовать, развиваться и прыгать семимиллионными шагами, ибо для WinForms вышел WinForms Roslyn Analyzer, который теперь умеет какие-то специфичные вещи для WinForms делать. Например, в девятом дотнете у WinForms появился асинхронный API, и вот аналайзер прекрасно с этим асинхронным API уже работает, он может рассказать, как там cancellation токены необходимо пробрасывать в этот асинхронный API, и так далее.
5552.00 5586.00 "Анатолий Кулаков" Если вы переводите, например, свой асинхронный API на асинхронный, аналайзер вам прекрасно зафиксит все места, куда надо пробросить cancellation токены. Ну и прочие тоже интересные вещи чисто для WinForms, для дизайнеров, для сериализации правильной для WinForms, в общем, там тоже у него поддерживается. Это только начало, типа первый анонс какой-то, автор обещает, что будет его поддерживать, сам Microsoft, автор, между прочим, сам Microsoft обещает, что будет его поддерживать, развивать и писать новые анализы. Поэтому WinForms живее всех живых, умирать не собирается, заводится на Roslyn анализаторами, ну, в добрый путь. Почему бы и нет? Больше хороших анализаторов, хороших разных.
5586.00 5588.00 "Игорь Лабутин" Да, все прекрасно.
5588.00 5590.00 "Игорь Лабутин" Ну, что, на этом будем заканчивать.
5590.00 5616.00 "Игорь Лабутин" Поговорили сегодня про пулы проектов, поговорили про то, как конвертить HTML в PDF, немножко затронули тему аутентификации в S/4HANA, обсудили измену лицензии Fluent Assertion, поговорили про nullable reference type в F# 9, обсудили список ошибок, найденных POS в проектах за 2024 год, ну и кратко пробежались по таким небольшим новостям.
5616.00 5618.00 "Игорь Лабутин" На этом, наверное, все на сегодня.
5618.00 5620.00 "Анатолий Кулаков" Да, да, точно все.
5620.00 5634.00 "Анатолий Кулаков" А также подписывайтесь, рассказывайте о нас своим друзьям, если вдруг там поставите нам где-нибудь пятерочки, звездочки, яблочки, что вы там ставите, мы будем очень признательны, потому что это увеличивает наши рейтинги в поиске, нас чаще находят, чаще слушают, и это хорошо.
5634.00 5636.00 "Анатолий Кулаков" Будем просвещаться все вместе.
5636.00 5648.00 "Анатолий Кулаков" Если у вас есть какие-то интересные статьи или интересные какие-то блоги, за которыми вы следите, читаете и хотите, чтобы они появились в наших выпусках, то смело присылайте нам на почту, почту указанная во всех шоу-нотах.
5648.00 5650.00 "Анатолий Кулаков" Мне кажется, все. Всем ша-шари, лайки, репосты.
5650.00 5652.00 "Анатолий Кулаков" До новых встреч. Пока.
5652.00 5654.00 "Игорь Лабутин" Всем пока.
