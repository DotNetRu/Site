0.00 10.08 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер
10.08 13.34 "Анатолий Кулаков" восемьдесят четыре и его ведущий Анатолий Кулаков
13.34 16.24 "Игорь Лабутин" и Игорь Лабутин, всем привет.
16.24 18.48 "Анатолий Кулаков" Приветствую, а также огромное спасибо всем тем, кто у
18.48 19.48 "Анатолий Кулаков" нас помогает.
19.48 22.92 "Анатолий Кулаков" Если вы еще не среди них, то заходите на Boosty и посмотрите,
22.92 25.52 "Анатолий Кулаков" как можно поддержать любимый подкаст, в частности, как
25.52 28.36 "Анатолий Кулаков" это сделали дорогие наши друзья Александр, Сергей,
28.36 31.44 "Анатолий Кулаков" Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин,
31.44 34.16 "Анатолий Кулаков" Виктор, Руслан Артамонов, Александр Ерыгин, Сергей
34.16 36.56 "Анатолий Кулаков" Бензенко и Александр Лапердин.
36.56 39.40 "Анатолий Кулаков" Спасибо, друзья всех у нас поддерживают, а также тех,
39.40 40.92 "Анатолий Кулаков" кто остался неназванным.
40.92 46.00 "Анатолий Кулаков" Так, ну что, сегодня у нас вроде Microsoft прогремел, все
46.00 50.12 "Анатолий Кулаков" темы интересные мы рассказали, но осталось много еще небольших
50.12 52.40 "Анатолий Кулаков" хвостов, которые не менее интересны, чем основная
52.40 55.04 "Анатолий Кулаков" его вот эта повесточка на dotnet.conf.
55.04 58.04 "Анатолий Кулаков" Я думаю, мы здесь немножко еще подметем, как раз на
58.04 59.12 "Анатолий Кулаков" несколько выпусков хватит.
59.12 62.76 "Игорь Лабутин" Ну я не уверен, честно говоря, что хватит прямо на несколько
62.76 65.44 "Игорь Лабутин" выпусков именно хвостов от dotnet.conf, но уже начинают
65.44 68.38 "Игорь Лабутин" появляться всякие интересные штуки, про которые можно
68.38 69.38 "Игорь Лабутин" разговаривать.
69.38 75.04 "Игорь Лабутин" И начнем мы сегодня с штуки, которая называется Async2
75.04 76.04 "Игорь Лабутин" Experiment.
76.04 80.52 "Игорь Лабутин" Живет это все в репозитории .NET Runtime Lab в соответствующей
80.52 81.52 "Игорь Лабутин" ветке.
81.52 85.64 "Анатолий Кулаков" И это репозитория… Имеется в виду, что Async1
85.64 89.40 "Анатолий Кулаков" уже был, или это вторая часть не эксперимента,
89.40 91.12 "Анатолий Кулаков" а именно Async2 часть?
91.12 95.10 "Игорь Лабутин" Это эксперимент по тому, как можно сделать Async чуть
95.10 98.44 "Игорь Лабутин" по-другому, и чтобы не мудрствовать с каким-нибудь новым клевым
98.44 102.68 "Игорь Лабутин" названием, как в Java Project Loom, который про гриндреды
102.68 106.80 "Игорь Лабутин" или еще в таком же духе, или там Project Valhalla про нечто
106.80 110.72 "Игорь Лабутин" структуроподобное, насколько я понимаю, чтобы не придумывать
110.72 114.12 "Игорь Лабутин" такие красивые имена, мы в смысле Microsoft поступили
114.12 116.96 "Игорь Лабутин" по-программистски, Async есть, но будет Async2, потом Async3,
116.96 121.80 "Игорь Лабутин" там Async2 в скобочках New, Async2 Final, ну все как мы любим.
121.80 124.44 "Анатолий Кулаков" А если взлетит, потом маркетологи что-нибудь накрутят на
124.44 125.44 "Игорь Лабутин" это?
125.44 126.44 "Игорь Лабутин" Да.
126.44 127.52 "Игорь Лабутин" На самом деле я так понимаю, что если взлетит, то может
127.52 131.96 "Игорь Лабутин" быть даже почему бы не оставить старое название,
131.96 135.04 "Игорь Лабутин" просто сейчас это сделано, потому что нужно явно
135.04 137.92 "Игорь Лабутин" отличать в коде, потому что чтобы runtime и компилятор
137.92 140.48 "Игорь Лабутин" понимали, что это разные штуки, просто если оставить
140.48 143.24 "Игорь Лабутин" просто Async, то там есть тонкости, почему они не
143.24 144.68 "Игорь Лабутин" захотели оставить именно Async.
144.68 146.92 "Игорь Лабутин" Может быть даже про них сейчас попробую рассказать.
146.92 149.16 "Анатолий Кулаков" Интересно, да-да, давай про эксперименты, что там
149.16 150.92 "Анатолий Кулаков" экспериментируют с нашими Async'ами?
150.92 155.60 "Игорь Лабутин" Так вот, значит, исторически у нас есть понятие тасков,
155.60 159.16 "Игорь Лабутин" ну все обычные таски, библиотека тасков, которую мы знаем,
159.16 162.78 "Игорь Лабутин" и у нас есть поддержка синтексис Async/await, который
162.78 164.68 "Игорь Лабутин" нам предоставляет Roslyn, то есть таски у нас идут
164.68 170.92 "Игорь Лабутин" из Base Class Library, можно сказать из runtime, а Async'и как таковые
170.92 174.08 "Игорь Лабутин" существуют только на уровне компилятора и Roslyn'а, и когда
174.08 177.44 "Игорь Лабутин" вы скомпилируете это все в ill-code, никаких Async/await'ов
177.44 181.56 "Игорь Лабутин" там, конечно же, нет, потому что для того, чтобы эмулировать
181.56 186.16 "Игорь Лабутин" Async'и, Roslyn делает некоторую магию и генерирует вам кучу
186.16 189.80 "Игорь Лабутин" state машинок на каждый Async вызов, точнее, на каждый
189.80 192.60 "Игорь Лабутин" Async вызов, конечно, одну state машинку, которая и заменяет
192.60 195.76 "Игорь Лабутин" собой этот самый Async вызов, то есть там при первом вызове
195.76 199.76 "Игорь Лабутин" создается state машина, запоминается state, когда мы в нее вернемся,
199.76 203.60 "Игорь Лабутин" после того как дождемся какого-то события на await'е,
203.60 209.04 "Игорь Лабутин" то мы продолжим выполнение со старого места, ну и так
209.04 210.04 "Игорь Лабутин" далее.
210.04 211.12 "Игорь Лабутин" Все это дело состоит в машинах, внутри компилятора, в результате
211.12 214.90 "Игорь Лабутин" это просто обычные объекты в куче, с callbacks'ами, ну по
214.90 219.64 "Игорь Лабутин" сути своей, которые как-то там работают, и за время
219.64 222.80 "Игорь Лабутин" существования всех этих тасков и Async/await'ов было
222.80 225.80 "Игорь Лабутин" несколько попыток предпринято для того, чтобы ускорить
225.80 226.92 "Игорь Лабутин" производительность.
226.92 229.72 "Игорь Лабутин" Современный код, как, наверное, многие видели, это довольно
229.72 233.04 "Игорь Лабутин" большая портянка, обычно, всяких Async/await'ов, все основные
233.04 235.84 "Игорь Лабутин" API'шки у нас Async'и, потому что так или иначе, там,
235.84 240.72 "Игорь Лабутин" если мы говорим про какой-то SPNADCore, мы работаем с сетью,
240.72 243.04 "Игорь Лабутин" даже если мы работаем с десктопом, то мы очень
243.04 245.12 "Игорь Лабутин" часто работаем с файлами, то есть это все равно какой-то
245.12 249.48 "Игорь Лабутин" I/O, ввод-вывод, и тогда там Async самое дело.
249.48 253.80 "Игорь Лабутин" Так вот, для того, чтобы скорость работы этих Async'ов,
253.80 256.32 "Игорь Лабутин" то есть структурок, точнее, не структурок, а вот этих
256.32 261.56 "Игорь Лабутин" вот StateMachines поменять, улучшить, вокруг этих структур и вокруг
261.56 265.64 "Игорь Лабутин" этих StateMachines было много-много-много разных оптимизаций, начиная
265.64 269.44 "Игорь Лабутин" с того, что они, собственно, там, с структурами иногда
269.44 272.92 "Игорь Лабутин" делаются, появлялись всякие штуки, там, ладно, value таски
272.92 275.88 "Игорь Лабутин" немножко в стороне, но тем не менее, тоже можно их
275.88 278.68 "Игорь Лабутин" использовать, в том числе для того, чтобы Async/await'ы
278.68 279.68 "Игорь Лабутин" пошустрее работали.
279.68 284.36 "Игорь Лабутин" Там же, в ту же степь идет, значит, генерация каких-то,
284.36 289.32 "Игорь Лабутин" скажем так, Roslyn генерирует для StateMachines какой-то довольно
289.32 293.28 "Игорь Лабутин" узнаваемый с точки зрения паттернов код, и в итоге
293.28 296.12 "Игорь Лабутин" JIT может оптимизировать его, например, чуть лучше.
296.12 299.40 "Игорь Лабутин" Ну, то есть такая смесь компилятора и JIT-компилятора,
299.40 304.04 "Игорь Лабутин" в смысле их такой союз, синергия, как хотите назовите.
304.04 312.16 "Игорь Лабутин" И в целом, ну, улучшения были, но не то чтобы суперзначительные.
312.16 316.24 "Игорь Лабутин" И поэтому родился этот эксперимент, цель которого
316.24 320.88 "Игорь Лабутин" состоит, в общем-то, в двух вещах, две цели.
320.88 328.44 "Игорь Лабутин" Значит, первая цель — можно ли как-нибудь переместить
328.44 334.12 "Игорь Лабутин" вот эту логику генерации StateMachines с компилятора на
334.12 337.80 "Игорь Лабутин" runtime, потому что runtime внутри себя знает довольно много
337.80 339.72 "Игорь Лабутин" о том, как этот код исполняется.
339.72 342.52 "Игорь Лабутин" Статистику вокруг него, в отличие от компилятора,
342.52 344.40 "Игорь Лабутин" который не знает ничего, кроме исходного кода.
344.40 349.88 "Игорь Лабутин" И, возможно, внутри рантайма будет гораздо проще генерить
349.88 353.00 "Игорь Лабутин" эти все StateMachines, например, если это будут StateMachines,
353.00 355.24 "Игорь Лабутин" и как-то с ними более оптимально работать.
355.24 357.92 "Игорь Лабутин" Вторая штука, которая может помочь, например, что рантайм
357.92 360.08 "Игорь Лабутин" довольно тесно, естественно, интегрирован с каким-нибудь
360.08 363.04 "Игорь Лабутин" garbage-коллектором, и он может напрямую garbage-коллектору
363.04 365.24 "Игорь Лабутин" не просто использовать обычное место в куче, а,
365.24 368.40 "Игорь Лабутин" например, генерить все эти машинки в какой-нибудь
368.40 370.72 "Игорь Лабутин" области памяти, которая не принадлежит хипу, или
370.72 373.40 "Игорь Лабутин" принадлежит какому-то очень специальному хипу, и тем
373.40 375.80 "Игорь Лабутин" самым снизить нагрузку на ГЦ от того, что мы нагенерили
375.80 378.16 "Игорь Лабутин" ему миллиарды этих структурок, потому что у нас async/await
378.16 379.16 "Игорь Лабутин" много.
379.16 383.00 "Игорь Лабутин" Это первая цель — попробовать это все сдвинуть в рантайм.
383.00 387.56 "Игорь Лабутин" А вторая цель этого эксперимента — попробовать найти, может
387.56 392.48 "Игорь Лабутин" быть, дело не только в структурах, в смысле, может быть, асинки
392.48 394.80 "Игорь Лабутин" можно реализовать не только структурами, вот такими
394.80 397.00 "Игорь Лабутин" структурами, которые живут в хипе и помнят некоторый
397.00 401.84 "Игорь Лабутин" индекс, по которому нужно вернуться и внутри, соответственно,
401.84 405.36 "Игорь Лабутин" по сути, свитч-кейса в этой стейт-машинке выполнить
405.36 408.76 "Игорь Лабутин" следующую ветку кейса, а, может быть, можно придумать
408.76 413.68 "Игорь Лабутин" что-то, что имеет, возможно, небольшие отличия в семантике,
413.68 416.44 "Игорь Лабутин" но которые не будут сильно отличаться от, так сказать,
416.44 419.96 "Игорь Лабутин" мейнстримного поведения текущих async/await, и в итоге
419.96 422.88 "Игорь Лабутин" то, что мы сейчас знаем как async/await, продолжит работать
422.88 424.80 "Игорь Лабутин" так, как оно работало, но внутри оно будет работать
424.80 427.12 "Игорь Лабутин" уже не на стейт-машинах, а на чем-то другом.
427.12 429.80 "Игорь Лабутин" Вот две таких цели эксперимента.
429.80 435.44 "Анатолий Кулаков" Звучит вполне бодренько, молодцы, хорошее направление.
435.44 440.64 "Игорь Лабутин" Хорошо, что они начали это довольно заранее, я бы сказал.
440.64 443.16 "Игорь Лабутин" Подход к этому эксперименту у них декларируется такой.
443.16 446.56 "Игорь Лабутин" Во-первых, давайте придумаем вот эти самые новые семантики
446.56 448.80 "Игорь Лабутин" или механику генерации этих стейт-машинок.
448.80 453.92 "Игорь Лабутин" Потом давайте попробуем реализовать, как у них
453.92 457.72 "Игорь Лабутин" написано забавно, одну или более имплементации рентайма,
457.72 460.16 "Игорь Лабутин" которые, собственно, реализуют эти новые семантики.
460.16 462.80 "Игорь Лабутин" То есть придумаем 20, будем реализовывать 20 рентаймов
462.80 463.80 "Игорь Лабутин" новых.
463.80 466.08 "Игорь Лабутин" Ну, не реализовывать, конечно, форкаем обычный рентайм
466.08 469.04 "Игорь Лабутин" и в нем как бы меняем поведение.
469.04 472.30 "Анатолий Кулаков" Ну как раз все должно строиться на бенчмарках, на доказательной
472.30 473.30 "Анатолий Кулаков" математике.
473.30 475.16 "Игорь Лабутин" Все так, сейчас до бенчмарков доберемся.
475.16 478.84 "Игорь Лабутин" Дальше нужно будет поправить Рослин, потому что для
478.84 481.60 "Игорь Лабутин" того, чтобы Рослину сказать, что вот этот async/await метод,
481.60 484.20 "Игорь Лабутин" не нужно на него генерировать стейт-машину, а нужно как-то
484.20 486.52 "Игорь Лабутин" по-другому теперь писать вызовы, ты же не можешь
486.52 491.80 "Игорь Лабутин" просто сказать обычную инструкцию call или call_virt.
491.80 496.24 "Игорь Лабутин" Нельзя, нужно каким-то образом дать понять G2 потом, что
496.24 499.12 "Игорь Лабутин" этот метод, ну рентайм G2 в частности, что этот метод
499.12 501.76 "Игорь Лабутин" вообще-то был обозначен как какой-то специальный
501.76 504.28 "Игорь Лабутин" вот тот самый async2.
504.28 507.08 "Игорь Лабутин" Дальше нужно сделать действительно бенчмарки, причем бенчмарки
507.08 509.12 "Игорь Лабутин" нужно сделать нескольких видов.
509.12 512.76 "Игорь Лабутин" Это набор микробенчмарков, потому что прям, ну поскольку
512.76 515.24 "Игорь Лабутин" затрагивается рентайм, то там довольно много всяких
515.24 517.64 "Игорь Лабутин" тонкостей есть, которые нужно микробенчмаркать.
517.64 522.24 "Игорь Лабутин" А кроме того, нужно все-таки бенчмаркать и большие сценарии,
522.24 524.96 "Игорь Лабутин" то есть полноценные большие сценарии в приложениях,
524.96 527.16 "Игорь Лабутин" там всякие, ну как минимум, не знаю, какой-нибудь там
527.16 530.28 "Игорь Лабутин" endpoint, WSP, netcore, которые делают JSON с реализацией, потому
530.28 532.92 "Игорь Лабутин" что там async/await по пути довольно много, пока он
532.92 537.90 "Игорь Лабутин" там вычитает контент из сокета, да, конвертнет его
537.90 544.22 "Игорь Лабутин" куда надо, десериализует JSON, потом обратно, в общем
544.22 547.60 "Игорь Лабутин" там делается довольно много, и вот бенчмаркать такую
547.60 549.36 "Игорь Лабутин" штуку вполне можно.
549.36 552.04 "Игорь Лабутин" Это цели и подход соответственно бенчмарка.
552.04 555.48 "Игорь Лабутин" Что сейчас, статья вообще говоря очень большая, поэтому
555.48 558.88 "Игорь Лабутин" я прям ее совсем в деталях пересказывать не буду,
558.88 561.36 "Игорь Лабутин" если вас тема заинтересовала, почитайте, там эксперимент
561.36 565.24 "Игорь Лабутин" понятно, он еще идет и все это будет, я надеюсь, обновляться
565.24 567.52 "Игорь Лабутин" по результатам, какие-то первые результаты там
567.52 568.52 "Игорь Лабутин" уже есть.
568.52 572.32 "Игорь Лабутин" Значит, во-первых, что мы делаем с новой семантикой?
572.32 574.88 "Игорь Лабутин" Ну, как минимум, как сказано, нужно каким-то образом
574.88 576.04 "Игорь Лабутин" помечать эти новые методы.
576.04 581.84 "Игорь Лабутин" В C# сделали просто, придумали новое ключевое слово, внезапно
581.84 582.84 "Игорь Лабутин" async2.
582.84 585.24 "Игорь Лабутин" Ну, собственно, как эксперимент называется, он так и сделали,
585.24 589.36 "Игорь Лабутин" то есть в C# теперь есть ключевое слово async2 вот в этом экспериментальном
589.36 593.48 "Игорь Лабутин" рослинг-компиляторе, который по сути единственное, что
593.48 596.52 "Игорь Лабутин" делает внутри C#, это навешивать на соответствующий метод
596.52 604.12 "Игорь Лабутин" C# некоторый специальный новый атрибутик, модифаер
604.12 605.12 "Игорь Лабутин" точнее это называется.
605.12 610.80 "Игорь Лабутин" Но я вообще-то забегаю вперед, насколько я так смотрю по
610.80 615.68 "Игорь Лабутин" своим заметочкам, и давайте-ка мы немножко вернемся назад,
615.68 619.28 "Игорь Лабутин" вернемся к нашим любимым async/await и вспомним, а что
619.28 623.16 "Игорь Лабутин" же происходит, что же такое текущая семантика с async/await?
623.16 629.42 "Игорь Лабутин" А текущая семантика выражается в специфической обработке
629.42 634.76 "Игорь Лабутин" двух концепций, это синхронизейшн-контекст и экзекьюшн-контекст.
634.76 638.24 "Игорь Лабутин" С синхронизейшн-контекстом известная штука, если вы
638.24 641.36 "Игорь Лабутин" позвали await внутри синхронизейшн-контекста, и у вас конфигурация
641.36 648.72 "Игорь Лабутин" await стоит true, ну или в новой редакции исполнить в закепчерном
648.72 651.32 "Игорь Лабутин" синхронизейшн-контексте, то продолжение, то есть
651.32 653.64 "Игорь Лабутин" то, что будет выполнено после await будет исполняться
653.64 656.40 "Игорь Лабутин" в том же синхронизейшн-контексте.
656.40 660.48 "Игорь Лабутин" А еще у нас есть экзекьюшн-контекст, экзекьюшн-контекст это
660.48 664.92 "Игорь Лабутин" штука, которая гуляет с вами вместе по всему стеку
664.92 669.12 "Игорь Лабутин" этих самых async-вызовов и ровно в ней хранятся те
669.12 672.08 "Игорь Лабутин" самые async-локалы, то есть это некоторый аналог thread-локалов,
672.08 677.28 "Игорь Лабутин" но для async-вызовов, то есть при каждом соответственно
677.28 680.60 "Игорь Лабутин" уходе метода в await, когда мы реально прекращаем выполнение
680.60 684.12 "Игорь Лабутин" метода на потоке и отправляемся ожидать что-то куда-то,
684.12 686.96 "Игорь Лабутин" мы capture синхронизейшн-контекст, если конфигурирует у нас
686.96 692.72 "Игорь Лабутин" true, и мы capture экзекьюшн-контекст безусловно всегда при восстановлении
692.72 694.96 "Игорь Лабутин" метода на стеке, когда мы продолжаем его выполнять,
694.96 697.64 "Игорь Лабутин" мы соответственно восстанавливаем синхронизейшн-контекст
697.64 700.04 "Игорь Лабутин" и всегда восстанавливаем экзекьюшн-контекст.
700.04 705.32 "Игорь Лабутин" Что мы теперь делаем в новой семантике?
705.32 709.00 "Игорь Лабутин" Во-первых, я не знаю почему так было сделано, возможно
709.00 713.16 "Игорь Лабутин" для упрощения, у нас появляется штука, которую мне кажется
713.16 716.68 "Игорь Лабутин" даже если они хотя бы ее перенесут в основной dotnet,
716.68 719.52 "Игорь Лабутин" это будет уже штука, которую ждали многие, у них появляется
719.52 724.88 "Игорь Лабутин" новый атрибут configure-await, system.runtime.compile.services.configure.await,
724.88 728.12 "Игорь Лабутин" который может быть навешан на сборку модуль, тип или
728.12 732.28 "Игорь Лабутин" метод, и который говорит глобальное поведение configure-await.
732.28 734.40 "Игорь Лабутин" То есть если ты на assembly навесишь вот такой атрибут
734.40 738.28 "Игорь Лабутин" со словами false, то как бы все await внутри этой assembly
738.28 740.12 "Игорь Лабутин" будут как будто бы сконфигуровать фалзом.
740.12 743.64 "Анатолий Кулаков" Ну наконец-то, они то есть специально не делают нам
743.64 747.40 "Анатолий Кулаков" эту штуку, чтобы мы начали пользоваться ими, их экспериментами,
747.40 748.40 "Анатолий Кулаков" да?
748.40 749.40 "Анатолий Кулаков" Да.
749.40 751.16 "Анатолий Кулаков" Я имею ввиду в старом коде, да, в существующем?
751.16 753.44 "Игорь Лабутин" Ну как бы экспериментами пользоваться сложновато,
753.44 756.92 "Игорь Лабутин" ну можно нужно клонировать этот runtime специальный,
756.92 759.56 "Игорь Лабутин" но в целом, да, я надеюсь, что хотя бы это может так
759.56 763.72 "Игорь Лабутин" и переедет в основной dotnet, в основной runtime, в девятом
763.72 764.72 "Игорь Лабутин" dotnet.
764.72 766.28 "Игорь Лабутин" Но тем не менее, ладно, давай дальше.
766.28 769.08 "Игорь Лабутин" Дальше с, ну и эта штука, понятно, влияет на синхронизацию
769.08 770.08 "Игорь Лабутин" контекста.
770.08 779.16 "Игорь Лабутин" Второй момент, это execution-контекст, который, как я сказал, сохраняется,
779.16 783.44 "Игорь Лабутин" восстанавливается при каждом, при каждом вызове
783.44 786.16 "Игорь Лабутин" и, ну, suspension'е, и, соответственно, восстановлении функции
786.16 787.16 "Игорь Лабутин" асинхронной.
787.16 789.42 "Игорь Лабутин" При этом у него есть одна особенность, он обладает
789.42 793.36 "Игорь Лабутин" функциональностью, точнее, особенностью, как copy-on-write,
793.36 796.80 "Игорь Лабутин" то есть если вы в него начинаете писать, то есть вы, например,
796.80 799.20 "Игорь Лабутин" взяли execution-контекст, в него записали какое-нибудь
799.20 803.24 "Игорь Лабутин" async-local значение, вызвали async-метод, внутри этого
803.24 806.88 "Игорь Лабутин" async-метода записали в это же значение, то есть с тем
806.88 810.48 "Игорь Лабутин" же ключом другое значение, так вот вызывающий метод
810.48 812.88 "Игорь Лабутин" не будет видеть это новое значение, потому что в
812.88 817.14 "Игорь Лабутин" момент записи для внутреннего вызванного async-метода execution-контекст
817.14 818.14 "Игорь Лабутин" внутри копируется.
818.14 822.76 "Игорь Лабутин" И в итоге у вас вызывающий метод никогда не, вы не можете
822.76 826.68 "Игорь Лабутин" через этот async-local и, по сути, никогда не возвращаются
826.68 828.52 "Игорь Лабутин" наружу через границу async-writes.
828.52 832.96 "Игорь Лабутин" В новой концепции этого не будет, и async-local — это
832.96 835.44 "Игорь Лабутин" просто такой thread-local, который гуляет, ну, куда угодно,
835.44 837.72 "Игорь Лабутин" хоть в самой глубокой точке вызова поставь, и он будет
837.72 838.72 "Игорь Лабутин" вытащен наружу.
838.72 842.92 "Игорь Лабутин" Опять же, видимо, было сделано для упрощения пока.
842.92 845.80 "Игорь Лабутин" При этом они не забывают про интероперабельность,
845.80 849.18 "Игорь Лабутин" то есть любой метод, который помечен как async2, может быть
849.18 852.32 "Игорь Лабутин" вызван как будто это обычный async-метод, который возвращает
852.32 856.88 "Игорь Лабутин" task, ну и наоборот, там, соответственно, тоже можно делать и так,
856.88 860.30 "Игорь Лабутин" но там для этого генерируются некоторые разные заглушки.
860.30 864.00 "Игорь Лабутин" Для попростоты эксперимента там ввели некоторое количество
864.00 867.84 "Игорь Лабутин" ограничений на разрешимый ill внутри таких методов.
867.84 874.56 "Игорь Лабутин" Ну и, в целом, какие-то моменты нам, в принципе, знакомы,
874.56 879.00 "Игорь Лабутин" то есть, например, всякие refstructs — это спаны, например,
879.00 882.24 "Игорь Лабутин" все еще не разрешены, хотя там так написано, что, ну,
882.24 884.24 "Игорь Лабутин" может быть, мы и разрешим в зависимости от реализации.
884.24 889.24 "Игорь Лабутин" Ну, например, там запрещены так называемые tail calls, и
889.24 893.48 "Игорь Лабутин" это значит, что, например, в f#, который довольно сильно
893.48 895.72 "Игорь Лабутин" ими оперирует, как функциональный язык, там это очень важная
895.72 898.72 "Игорь Лабутин" оптимизация, иначе там все будет уходить в какую-то
898.72 902.20 "Игорь Лабутин" большую рекурсию, насколько я понимаю, f# на этом рентайме
902.20 904.24 "Игорь Лабутин" не заведется, грубо говоря.
904.24 908.00 "Игорь Лабутин" Ну, это, опять же, ограничения сейчас на первом этапе
908.00 909.68 "Игорь Лабутин" эксперимента, я надеюсь, что это все, понятное дело,
909.68 913.04 "Игорь Лабутин" будет снято, если это все пойдет куда надо.
913.04 916.88 "Игорь Лабутин" И дальше есть еще отдельная семантика, которая очень
916.88 918.96 "Игорь Лабутин" важна для рентайма — это exception handling, то есть как
918.96 924.76 "Игорь Лабутин" вообще делать отлавливание эксепшенов, и что с ними,
924.76 925.76 "Игорь Лабутин" что где разрешено.
925.76 927.92 "Игорь Лабутин" Так вот, в той семантике эксперимента, которую они
927.92 932.88 "Игорь Лабутин" сейчас рассматривают, все вот эти async2 методы нельзя
932.88 939.92 "Игорь Лабутин" будет вызывать из finally, из catchy, из фильтров на эксепшенах,
939.92 943.72 "Игорь Лабутин" короче, ну, никак нельзя, то есть только в тройблоках,
943.72 944.72 "Игорь Лабутин" грубо говоря.
944.72 947.52 "Игорь Лабутин" Ну, пока так, опять же.
947.52 950.96 "Игорь Лабутин" При этом async2 методы не будут видны через reflection, если
950.96 957.48 "Игорь Лабутин" вы позовете get метод или declared метод, или declared members,
957.48 961.04 "Игорь Лабутин" при этом если вы позовете type get members, то будут видны,
961.04 964.08 "Игорь Лабутин" но только если вы поставите специальный binding flag async2
964.08 965.08 "Игорь Лабутин" visible.
965.08 966.58 "Игорь Лабутин" Я не очень понимаю, почему так делается, ну, в том
966.58 970.84 "Игорь Лабутин" плане, что, казалось бы, это экспериментальный
970.84 973.08 "Игорь Лабутин" рентайм, зачем там прям это вот так, закрывать эту
973.08 975.00 "Игорь Лабутин" фичу, ну, видны были и видны.
975.00 977.48 "Игорь Лабутин" Возможно, есть там какие-то трудности, что у них другой
977.48 980.12 "Игорь Лабутин" там будет, не знаю, возвращаемый тип, еще какая-нибудь фигня,
980.12 981.12 "Анатолий Кулаков" не знаю.
981.12 983.08 "Анатолий Кулаков" Ну, мне кажется, да, просто не захотели заморачиваться,
983.08 984.96 "Анатолий Кулаков" описывать их деревья там полностью, может, у них
984.96 985.96 "Анатолий Кулаков" там какая-то специфика.
985.96 986.96 "Анатолий Кулаков" Ну да.
986.96 988.64 "Анатолий Кулаков" На момент эксперимента, мне кажется, это все вообще
988.64 991.20 "Анатолий Кулаков" мелочи, то есть не важно, если им так легче, то пусть
991.20 992.20 "Анатолий Кулаков" будет так.
992.20 993.20 "Игорь Лабутин" Вот.
993.20 995.60 "Игорь Лабутин" Теперь, соответственно, что касается реализаций.
995.60 999.36 "Игорь Лабутин" Сейчас, я так понимаю, у них в разработке, и плюс-минус
999.36 1003.24 "Игорь Лабутин" уже в каком-то виде живет, есть две реализации возможного
1003.24 1005.68 "Игорь Лабутин" подхода к тому, как эти штуки делать.
1005.68 1009.16 "Игорь Лабутин" Первая, она называется по-английски unwinder-based, то
1009.16 1017.60 "Игорь Лабутин" есть есть такая, такой термин, это stack unwind, по-русски переводится
1017.60 1020.60 "Игорь Лабутин" это, по-моему, обычно как «размотка стека» или что-то
1020.60 1021.60 "Игорь Лабутин" в таком духе.
1021.60 1023.66 "Игорь Лабутин" Ну, смысл в том, что, например, такое происходит, когда
1023.66 1026.48 "Игорь Лабутин" кидается исключение, и понятно, что для того, чтобы найти
1026.48 1028.56 "Игорь Лабутин" обработчик исключения, собственно, код рентайма
1028.56 1032.08 "Игорь Лабутин" идет по call stack и пытается найти, нет ли где-то правильного
1032.08 1034.62 "Игорь Лабутин" обработчика исключения на каком-то из уровней.
1034.62 1038.28 "Игорь Лабутин" Так вот, здесь делается примерно следующая конструкция.
1038.28 1043.84 "Игорь Лабутин" Значит, если вы вызвали async метод, в котором попался
1043.84 1048.36 "Игорь Лабутин" await, и вам, ну и рентайм понимает, что тот, кого мы
1048.36 1051.84 "Игорь Лабутин" ждем, он еще не закомпличен, и нам реально надо подождать,
1051.84 1053.08 "Игорь Лабутин" то он делает следующее.
1053.08 1056.96 "Игорь Лабутин" Он берет и начинает реальный stack реального потока потихонечку
1056.96 1060.20 "Игорь Лабутин" обратно раскручивать, сохраняя его в некоторое специальное
1060.20 1061.20 "Игорь Лабутин" хранилище.
1061.20 1064.20 "Игорь Лабутин" Когда он дойдет до некоторого определенного метода, где
1064.20 1067.98 "Игорь Лабутин" он понимает, что ага, тут как бы окей, можно и что-нибудь
1067.98 1070.64 "Игорь Лабутин" другое выполнить уже, ну как минимум он может дойти
1070.64 1074.20 "Игорь Лабутин" до, не знаю, метода thread pool'а, который, собственно,
1074.20 1075.20 "Игорь Лабутин" возьмет следующую задачку.
1075.20 1076.20 "Игорь Лабутин" Понятное дело, да?
1076.20 1080.32 "Игорь Лабутин" То есть там, где он не ждет уже ничего, где нет await'а,
1080.32 1082.88 "Игорь Лабутин" он с этого места продолжит исполнение.
1082.88 1086.28 "Игорь Лабутин" Когда же придет пора что-то там резюмить, он аккуратненько
1086.28 1088.64 "Игорь Лабутин" из этого хранилища stack обратно на реальный stack потока
1088.64 1091.44 "Игорь Лабутин" накрутит поверх, восстановит все регистры и продолжит
1091.44 1092.52 "Игорь Лабутин" исполнение, как было.
1092.52 1098.40 "Игорь Лабутин" Вот такая вот магия, я бы сказал, с реальной работой
1098.40 1099.40 "Игорь Лабутин" с астеком.
1099.40 1103.80 "Игорь Лабутин" Значит, а с другой стороны есть другой вариант, то,
1103.80 1107.72 "Игорь Лабутин" что исходно, как я понял и постулировалось в эксперименте,
1107.72 1110.16 "Игорь Лабутин" то есть то, как бы первая начальная идея, которая
1110.16 1112.96 "Игорь Лабутин" звучала, это попробовать генерить state машины прямо
1112.96 1113.96 "Игорь Лабутин" в GT.
1113.96 1117.48 "Игорь Лабутин" И тут тоже довольно хитрая конструкция, то есть здесь
1117.48 1125.28 "Игорь Лабутин" нету индексов как таковых, то есть у вас тело, как я
1125.28 1127.84 "Игорь Лабутин" понял, тело вот этого async метода, оно компилится
1127.84 1130.80 "Игорь Лабутин" как будто это единый async метод, в смысле что это
1130.80 1135.44 "Игорь Лабутин" единый обычный синхронный метод, а в качестве индекса,
1135.44 1140.80 "Игорь Лабутин" с которого нужно продолжить исполнение, выступает
1140.80 1146.72 "Игорь Лабутин" pointer, ну как он называется-то, instruction pointer, короче, реальный
1146.72 1149.76 "Игорь Лабутин" регистр процессора, откуда нужно начать исполнение.
1149.76 1152.04 "Игорь Лабутин" То есть, грубо говоря, в state машинку, которая генерирует
1152.04 1154.72 "Игорь Лабутин" GIT, записывается реальный адрес того места, с которого
1154.72 1156.44 "Игорь Лабутин" надо продолжить исполнение.
1156.44 1160.38 "Игорь Лабутин" И все такие методы, которые вот эти, вот async2, они всегда
1160.38 1164.52 "Игорь Лабутин" принимают еще один аргумент, неявно при генерации, когда
1164.52 1168.08 "Игорь Лабутин" GIT все это генерирует, который, собственно, обозначает
1168.08 1170.72 "Игорь Лабутин" некоторую внутреннюю структуру continuation, в которой как раз
1170.72 1173.92 "Игорь Лабутин" и записано, с какого instruction pointer нужно начинать.
1173.92 1175.16 "Игорь Лабутин" То есть, грубо говоря, у тебя такой специальный
1175.16 1178.68 "Игорь Лабутин" calling convention, который говорит, возьми последний аргумент,
1178.68 1181.28 "Игорь Лабутин" посмотри в нем по такому-то смещению твой instruction
1181.28 1183.80 "Игорь Лабутин" pointer, прыгни на него, и оттуда начинай исполнять метод.
1183.80 1186.36 "Игорь Лабутин" Такой очень затейливый calling convention.
1186.36 1189.80 "Анатолий Кулаков" Ну, если все параметры вокруг нормально подготовлены,
1189.80 1190.80 "Игорь Лабутин" то почему бы и нет?
1190.80 1193.56 "Игорь Лабутин" Да, ну, как бы он такой, очень специальный получается,
1193.56 1194.56 "Игорь Лабутин" но тем не менее.
1194.56 1197.20 "Игорь Лабутин" То есть, это тоже, видимо, позволяет какие-то магию
1197.20 1199.52 "Игорь Лабутин" делать со стэками и всем остальным.
1199.52 1205.64 "Игорь Лабутин" Ну, вот примерно такое дело.
1205.64 1207.64 "Игорь Лабутин" Что еще касается C#?
1207.64 1211.52 "Игорь Лабутин" В C#, конечно, async2 ключевое слово сделали, но там возникло
1211.52 1212.52 "Игорь Лабутин" тоже ряд проблем.
1212.52 1216.52 "Игорь Лабутин" Не то чтобы проблема, а пока неразрешенных вопросов.
1216.52 1217.52 "Игорь Лабутин" Вопрос первый.
1217.52 1221.16 "Игорь Лабутин" У нас в C# можно объявить метод, который возвращает
1221.16 1222.76 "Игорь Лабутин" таск, который возвращает таск, который возвращает
1222.76 1223.76 "Игорь Лабутин" таск от t.
1223.76 1225.12 "Игорь Лабутин" Ну, то есть, такой, типа, вложенные таски.
1225.12 1227.40 "Игорь Лабутин" Вот вложенные таски пока не очень понятно, как моделировать
1227.40 1228.40 "Игорь Лабутин" в такой ситуации.
1228.40 1230.60 "Игорь Лабутин" Как я понимаю, у них пока нет каких-то выводов на
1230.60 1231.60 "Игорь Лабутин" эту тему.
1231.60 1233.20 "Игорь Лабутин" Возможно, работа ведется, но пока вопрос открытый
1233.20 1234.20 "Игорь Лабутин" стоит.
1234.20 1235.20 "Игорь Лабутин" С value-тасками непонятно.
1235.20 1238.16 "Игорь Лабутин" Ну, они просто, как, отмечены, типа, вот есть такой концепт
1238.16 1240.08 "Игорь Лабутин" value-таски, надо подумать, что с ним делать.
1240.08 1246.60 "Игорь Лабутин" И асинквоиды, которые, похоже, в одной, по крайней
1246.60 1250.16 "Игорь Лабутин" мере, из вот этих вот реализаций, невыразимы, насколько я
1250.16 1251.16 "Игорь Лабутин" понял, статью.
1251.16 1255.08 "Игорь Лабутин" Ну, не получится там, потому что идея в том, что там
1255.08 1257.88 "Игорь Лабутин" все-таки функции должны что-то возвращать.
1257.88 1260.60 "Игорь Лабутин" В общем, как-то пока асинквоиды у них не складываются.
1260.60 1264.76 "Игорь Лабутин" Дальше, соответственно, есть набор бенчмарков.
1264.76 1270.00 "Игорь Лабутин" В статье уже приведен ряд бенчмарков, которые получились
1270.00 1275.08 "Игорь Лабутин" в результате каких-то первоначальных экспериментов, запусков,
1275.08 1276.96 "Игорь Лабутин" не знаю, как сказать.
1276.96 1280.08 "Игорь Лабутин" И там довольно интересный результат, я сейчас кратенько
1280.08 1282.40 "Игорь Лабутин" пробегусь по результатам.
1282.40 1284.92 "Игорь Лабутин" Нужно прям довольно сильно все это вчитываться.
1284.92 1287.58 "Игорь Лабутин" Основные бенчмарки, которые пока прогнали, это бенчмарки
1287.58 1288.58 "Игорь Лабутин" на exception-хэндлинг.
1288.58 1298.48 "Игорь Лабутин" И exception-хэндлинг там прям, короче, операции, сейчас
1298.48 1303.98 "Игорь Лабутин" я сформулирую правильно, значит, скорость выполнения
1303.98 1309.80 "Игорь Лабутин" операций, когда у нас, соответственно, вот эти асинк-2 работают,
1309.80 1316.80 "Игорь Лабутин" кажется, что ну прям резко быстрее, вот так скажу.
1316.80 1321.96 "Игорь Лабутин" То есть на больших глубинных стеках асинк-2, вот это вот,
1321.96 1324.92 "Игорь Лабутин" соответственно, асинк-2 производительность прям
1324.92 1326.44 "Игорь Лабутин" супербыстрая.
1326.44 1332.40 "Игорь Лабутин" Почему непонятно, надо смотреть и понимать.
1332.40 1336.04 "Игорь Лабутин" То есть я пока не очень понял, почему прям такая
1336.04 1337.04 "Игорь Лабутин" большая разница.
1337.04 1341.48 "Игорь Лабутин" Вот, если смотреть на скорость выкидывания исключений,
1341.48 1344.56 "Игорь Лабутин" там тоже асинк-2 пока, по крайней мере, на вид выглядит
1344.56 1350.76 "Игорь Лабутин" получше, чем обычные таски, прям получше.
1350.76 1354.12 "Игорь Лабутин" Это надо понимать, что там, допустим, там, где обычные
1354.12 1360.04 "Игорь Лабутин" таски выдают что-то типа 5000, около 5000 итераций в
1360.04 1363.92 "Игорь Лабутин" 250 миллисекунд, вот такое у них измерение итераций
1363.92 1366.84 "Игорь Лабутин" в 250 миллисекунд, видимо, график как раз аккуратного
1366.84 1367.84 "Игорь Лабутин" масштаба получался.
1367.84 1371.42 "Игорь Лабутин" Короче, 5000, там, где обычные таски, вот эти вот новые
1371.42 1375.84 "Игорь Лабутин" асинк-2 штуки, они выдают 20000 исключений можно выкинуть,
1375.84 1377.92 "Игорь Лабутин" ну как бы, типа в четыре раза круче.
1377.92 1382.72 "Игорь Лабутин" Ну и там довольно много всяких разных этих меряется,
1382.72 1386.40 "Игорь Лабутин" там саспенды, не саспенды, контекст кепчер, не контекст
1386.40 1389.08 "Игорь Лабутин" кепчер, трайфайнали, вот у трайфайнали тоже очень
1389.08 1392.92 "Игорь Лабутин" забавный перформанс, потому что почти все графики
1392.92 1396.56 "Игорь Лабутин" горизонтальны, кроме как асинк-2 throw, тут он такой
1396.56 1399.56 "Игорь Лабутин" плавненько снижается, но снижается все равно, оставаясь
1399.56 1401.84 "Игорь Лабутин" выше, чем обычные таски.
1401.84 1404.84 "Игорь Лабутин" То есть, короче, на вид смотришь, думаешь, блин, вообще все
1404.84 1405.84 "Игорь Лабутин" зашибись.
1405.84 1411.68 "Игорь Лабутин" Но там есть всякие разные тонкости, как с этим всем
1411.68 1412.68 "Игорь Лабутин" жить и быть.
1412.68 1416.28 "Игорь Лабутин" Поэтому, если интересны конкретные числа про exception
1416.28 1418.32 "Игорь Лабутин" handling, посмотрите графики, там нужно вчитываться
1418.32 1420.76 "Игорь Лабутин" прямо довольно внимательно, потому что там не всегда
1420.76 1422.52 "Игорь Лабутин" очень понятные обозначения.
1422.52 1426.24 "Игорь Лабутин" А вот с памятью и garbage-коллектором довольно интересно, потому
1426.24 1432.24 "Игорь Лабутин" что надо понимать, что если мы генерим эти структуры
1432.24 1434.80 "Игорь Лабутин" в heap, то это нагрузка на garbage-коллектор, если мы
1434.80 1438.20 "Игорь Лабутин" генерим внутри каким-то своим странным образом,
1438.20 1441.12 "Игорь Лабутин" это уже нагрузка не совсем на garbage-коллектор.
1441.12 1445.00 "Игорь Лабутин" И вот в примере, который они гоняли, надо сказать,
1445.00 1452.40 "Игорь Лабутин" что у них использовался x64, какая-то AMD провод, типичная
1452.40 1456.16 "Игорь Лабутин" пауза в сборке нулевого поколения была 120 микросекунд
1456.16 1458.00 "Игорь Лабутин" на обычных наших async-тасках.
1458.00 1461.00 "Игорь Лабутин" Ну, самый обыкновенный C#, там восьмой дотнет берете
1461.00 1463.52 "Игорь Лабутин" или девятый последний, какой есть, и вот там будет
1463.52 1465.84 "Игорь Лабутин" 120 микросекунд в их сценарии.
1465.84 1470.48 "Игорь Лабутин" При этом размер кучи стабильно 130 мегабайт, а размер воркингсета,
1470.48 1475.04 "Игорь Лабутин" то есть примерно объем памяти приложения, это 148 мегабайт.
1475.04 1479.92 "Игорь Лабутин" Если мы берем тот самый первый способ реализации
1479.92 1487.00 "Игорь Лабутин" с stack capturing, когда мы при встрече async-метода начинаем
1487.00 1489.92 "Игорь Лабутин" раскручивать стек назад, сохраняя его куда-то в специальное
1489.92 1494.24 "Игорь Лабутин" хранилище, то пауза на ген 0 просто на первых экспериментах
1494.24 1498.44 "Игорь Лабутин" была 48 тысяч микросекунд, что как бы в 400 раз хуже.
1498.44 1503.52 "Игорь Лабутин" Вот, и вообще говоря, абсолютно недопустимо.
1503.52 1506.80 "Игорь Лабутин" Ну, выяснилось это потому, что, понятно, как бы там
1506.80 1509.52 "Игорь Лабутин" огромное количество вот этих кусочков стека, которые
1509.52 1514.48 "Игорь Лабутин" они называются tasklets, все это кидается в кучу, и поскольку
1514.48 1518.84 "Игорь Лабутин" каждый из них он самостоятелен, в нем нет ни одного, ни одной
1518.84 1523.76 "Игорь Лабутин" ссылки на объекты, хотя вообще это, кстати, могут
1523.76 1525.72 "Игорь Лабутин" быть, что-то я сейчас подумал, это же кусочки стека, там
1525.72 1528.12 "Игорь Лабутин" могут быть ссылки на локальные переменные, которые держат
1528.12 1531.72 "Игорь Лабутин" объекты, но при этом каждый из этих вот tasklets, то есть
1531.72 1533.88 "Игорь Лабутин" кусочков стека, является самостоятельным рутом.
1533.88 1537.20 "Игорь Лабутин" Если в обычной жизни у нас gcroot это, собственно, стек
1537.20 1539.84 "Игорь Лабутин" одного потока, его линейно пробегают, то сейчас у нас
1539.84 1542.44 "Игорь Лабутин" как бы каждый такой кусочек, лежащий отдельно в хипе,
1542.44 1547.00 "Игорь Лабутин" это отдельный рут, и на garbage collector это прям суперогромная
1547.00 1548.00 "Игорь Лабутин" нагрузка.
1548.00 1550.52 "Игорь Лабутин" В итоге они там немножко это оптимизировали, подхатчили,
1550.52 1555.32 "Игорь Лабутин" добавили некоторых специальных флагов, и gc стал знать, где
1555.32 1558.96 "Игорь Лабутин" какие там промоушены случались в этих самых tasklets, и в итоге
1558.96 1563.44 "Игорь Лабутин" они смогли все это снизить до 480 секунд, но все еще
1563.44 1567.80 "Игорь Лабутин" в 4 раза хуже, чем таски, но при этом, если посмотреть
1567.80 1571.72 "Игорь Лабутин" на managed heap, который был 130 мегабайт, в обычной жизни
1571.72 1575.64 "Игорь Лабутин" он стал 28 мегабайт, то есть вот в этих сценариях 100
1575.64 1579.76 "Игорь Лабутин" мегабайт хипа, это чисто async стейк машины, грубо
1579.76 1580.76 "Анатолий Кулаков" говоря.
1580.76 1581.76 "Игорь Лабутин" Нормально жрут.
1581.76 1588.72 "Игорь Лабутин" Но, при этом, общий размер working set получился 500 мегабайт,
1588.72 1593.16 "Игорь Лабутин" по сравнению со 148 в обычной жизни, что как бы в 3 там
1593.16 1595.76 "Игорь Лабутин" почти с половиной раза хуже, чем таски, просто потому
1595.76 1601.60 "Игорь Лабутин" что вот это все, мы все, мы кепчурим весь стек, неважно
1601.60 1607.48 "Игорь Лабутин" что там было, мы кепчурим все регистры, и, соответственно,
1607.48 1610.12 "Игорь Лабутин" это довольно много, в отличие от стейк машин, которые
1610.12 1612.88 "Игорь Лабутин" сейчас генерит Рослинн, который понимает, где какие
1612.88 1615.00 "Игорь Лабутин" штуки есть, если, например, у вас локальная переменная
1615.00 1617.64 "Игорь Лабутин" используется между двумя эвейтами, и больше нигде
1617.64 1619.76 "Игорь Лабутин" не используется, технически Рослинн может понять, что
1619.76 1621.44 "Игорь Лабутин" ее можно не запихивать в эту самую стейк машинку
1621.44 1622.44 "Игорь Лабутин" и сохранять.
1622.44 1625.56 "Анатолий Кулаков" Ну, наверное, ГЦТ тоже может это понять, ну, то есть я
1625.56 1628.12 "Анатолий Кулаков" имею в виду те стейки, которые они, стеклеты, которые
1628.12 1629.12 "Анатолий Кулаков" они реализуют.
1629.12 1631.72 "Игорь Лабутин" Да, может, но, видимо, пока не сделали, то есть вот
1631.72 1632.72 "Игорь Лабутин" наивная реализация.
1632.72 1634.12 "Анатолий Кулаков" То есть это просто оптимизация будет.
1634.12 1636.96 "Игорь Лабутин" Наивная реализация пока вот такая.
1636.96 1640.12 "Игорь Лабутин" Дальше, соответственно, если мы берем вот ту самую
1640.12 1647.04 "Игорь Лабутин" джит стейк машину, то, соответственно, тут все неплохо, потому
1647.04 1653.40 "Игорь Лабутин" что паузы были порядка ста микросекунд, это лучше,
1653.40 1656.60 "Игорь Лабутин" пиковое значение воркингсета стало 328 мегабайт, то есть
1656.60 1660.32 "Игорь Лабутин" это где-то в два примерно раза больше, чем было.
1660.32 1665.08 "Игорь Лабутин" Но тут они сами говорят, что тут как бы непонятно
1665.08 1670.36 "Игорь Лабутин" какие-то, может быть, transient locations и, в общем, need some more
1670.36 1671.36 "Игорь Лабутин" follow-up.
1671.36 1675.56 "Игорь Лабутин" Так что, будут думать, будут смотреть, плюс там есть
1675.56 1678.88 "Игорь Лабутин" некоторые проблемы пока со всякими штуками типа
1678.88 1683.32 "Игорь Лабутин" tier компиляции, потому что у нас есть штуки под названием
1683.32 1688.00 "Игорь Лабутин" on stack replacement, как мы помним, которые заменяют код, пока
1688.00 1691.72 "Игорь Лабутин" у тебя исполняется тело метода, и тут возникают
1691.72 1696.08 "Игорь Лабутин" вопросы, как заменять код, если ты запоминал в стейт
1696.08 1701.32 "Игорь Лабутин" машине instruction pointer внутри body функции в качестве точки
1701.32 1705.36 "Игорь Лабутин" восстановления, а ты заменил код функции, ну, причем он
1705.36 1707.44 "Игорь Лабутин" находится уже совершенно в другом месте, понятное
1707.44 1708.44 "Игорь Лабутин" дело.
1708.44 1710.60 "Игорь Лабутин" Короче, там есть понятное, что начинается огромное
1710.60 1714.06 "Игорь Лабутин" количество всяких этих странных вопросов, и пока
1714.06 1717.36 "Игорь Лабутин" на них ответов особого я не вижу, но понятно, что
1717.36 1720.60 "Игорь Лабутин" эксперимент только начался, и все это будет продолжаться.
1720.60 1727.72 "Игорь Лабутин" Вот, такая вот песня, с этими async 2, как минимум
1727.72 1731.20 "Игорь Лабутин" это интересно, как минимум я думаю, что это приведет
1731.20 1734.96 "Игорь Лабутин" к каким-то изменениям в обычном нашем рантайме,
1734.96 1739.32 "Игорь Лабутин" я не думаю, пока по крайней мере, что этот эксперимент
1739.32 1742.12 "Игорь Лабутин" постигнет участь грейнтрейдов, которым поэкспериментировали,
1742.12 1744.16 "Игорь Лабутин" сказали, ну, короче, мы поняли, что это сделать
1744.16 1746.72 "Игорь Лабутин" можно, но мы ничего делать не будем, типа, текущая
1746.72 1749.92 "Игорь Лабутин" модель и так сойдет, достаточно эффективно.
1749.92 1752.36 "Игорь Лабутин" Я надеюсь, как я сказал, что хотя бы конфигурирует
1752.36 1755.28 "Игорь Лабутин" атрибуты у тащитов основной рантайм, не знаю.
1755.28 1758.40 "Анатолий Кулаков" Ну, кажется, что это какой-то слишком минимум для такой
1758.40 1761.44 "Анатолий Кулаков" пушки, которую они там делают, утащить и конфигурировать
1761.44 1762.44 "Анатолий Кулаков" атрибуты.
1762.44 1765.76 "Игорь Лабутин" Слушай, это эксперименты, которые как бы, это нормально,
1765.76 1768.64 "Игорь Лабутин" что они идут и могут не принести никаких результатов,
1768.64 1772.28 "Игорь Лабутин" т.е. с другой стороны, это нормально будет, если, например,
1772.28 1775.20 "Игорь Лабутин" этот эксперимент займет больше года, тот же Project
1775.20 1777.68 "Игорь Лабутин" Loom, который в Java, да, про грейнтрейды, он же много
1777.68 1780.80 "Игорь Лабутин" лет длился, пока вот он тут наконец-таки доехал
1780.80 1781.80 "Игорь Лабутин" до релиза.
1781.80 1784.80 "Игорь Лабутин" Т.е. они тщательно, аккуратно все проверяли, тестировали,
1784.80 1787.40 "Игорь Лабутин" переделывали, превью делали и так далее.
1787.40 1789.88 "Игорь Лабутин" Поэтому я не удивлюсь, если, например, они сейчас в девятом
1789.88 1794.08 "Игорь Лабутин" дотнете там, даже если кто-то сделает что-то очень маленькое,
1794.08 1796.72 "Игорь Лабутин" а к десятке что-нибудь придумают прикольное, наконец-таки.
1796.72 1799.96 "Игорь Лабутин" А может, не придумают, может, скажут, что не мы что-то.
1799.96 1802.96 "Игорь Лабутин" Поняли, что Async/await сделано не так, надо все переделывать,
1802.96 1805.44 "Игорь Лабутин" но мы уже не будем, ибо backward compatibility.
1805.44 1808.88 "Анатолий Кулаков" Да нет, слушай, мне кажется, надо смотреть более оптимистично,
1808.88 1811.36 "Анатолий Кулаков" тем более, что первые цифры показывают, что направление
1811.36 1812.36 "Анатолий Кулаков" перспективное.
1812.36 1815.76 "Анатолий Кулаков" Ну и вообще кажется, что такие глобальные вещи
1815.76 1816.76 "Анатолий Кулаков" так и надо делать.
1816.76 1819.64 "Анатолий Кулаков" Т.е. долгую, нормальную, экспериментировать, битчмаркать,
1819.64 1821.32 "Анатолий Кулаков" compatibility делать и так далее.
1821.32 1823.92 "Анатолий Кулаков" Лучше уж пусть посидят подольше, но сделают хорошо,
1823.92 1825.96 "Анатолий Кулаков" чем выплевывают каждый релиз непонятно что.
1825.96 1829.40 "Анатолий Кулаков" Так что мне кажется, эксперимент хороший, в принципе, циферки
1829.40 1830.40 "Анатолий Кулаков" первые хорошие.
1830.40 1831.40 "Анатолий Кулаков" Будем смотреть.
1831.40 1835.40 "Игорь Лабутин" Будем смотреть, а пока давай пойдем дальше посмотрим,
1835.40 1841.04 "Игорь Лабутин" потому что остатками от dotnet.conf мы все еще можем
1841.04 1844.08 "Игорь Лабутин" наслаждаться, и давай посмотрим про Service Discovery.
1844.08 1847.40 "Анатолий Кулаков" Да, одна из самых интересных фич, которая там появилась
1847.40 1850.36 "Анатолий Кулаков" мельком, когда нам показывали Project Aspire, это в том, что вдруг
1850.36 1853.12 "Анатолий Кулаков" внезапно казалось, что у Microsoft есть стандартные
1853.12 1854.64 "Анатолий Кулаков" компоненты для Service Discovery.
1854.64 1857.92 "Анатолий Кулаков" Вот и давайте подробнее же с ними и разберемся,
1857.92 1859.40 "Анатолий Кулаков" что же там такое есть.
1859.40 1862.32 "Анатолий Кулаков" Прежде всего нужно осознать, что такое Service Discovery.
1862.32 1865.32 "Анатолий Кулаков" Это способ, как превратить логическое имя какого-нибудь
1865.32 1868.52 "Анатолий Кулаков" сервиса, ну, в частности, endpoint, в его физический
1868.52 1872.60 "Анатолий Кулаков" адрес, то есть в IP-адрес, порт, может быть, DNS-имя,
1872.60 1875.68 "Анатолий Кулаков" где на самом деле этот сервис находится, где этот endpoint
1875.68 1877.44 "Анатолий Кулаков" находится, который готов вам предоставить какие-то
1877.44 1878.64 "Анатолий Кулаков" свои ресурсы.
1878.64 1881.28 "Анатолий Кулаков" Ну, и обычно это какой-то внешний сервис, вам никакого
1881.28 1885.04 "Анатолий Кулаков" смысла через Service Discovery, Discovery самого себя нет.
1885.04 1886.04 "Анатолий Кулаков" Почему такая проблема встала?
1886.04 1889.24 "Анатолий Кулаков" Да потому что в наши века микросервисов, вокруг нас
1889.24 1891.24 "Анатолий Кулаков" поднимается очень много сервисов, с таким же точным
1891.24 1895.00 "Анатолий Кулаков" успехом они опускаются, переподнимаются, балансируются,
1895.00 1898.56 "Анатолий Кулаков" переезжают из одного кластера, из одного дата-центра в
1898.56 1899.56 "Анатолий Кулаков" другой.
1899.56 1901.92 "Анатолий Кулаков" То есть задача, на самом деле, найти тот сервис,
1901.92 1905.04 "Анатолий Кулаков" с кем тебе нужно взаимодействовать, становится не такой уж
1905.04 1906.04 "Анатолий Кулаков" тривиальной.
1906.04 1908.40 "Анатолий Кулаков" Если раньше у тебя там поднималось два монолитных кластера
1908.40 1911.64 "Анатолий Кулаков" и ты точно знал, что их IP-адреса пробиты в коде
1911.64 1915.32 "Анатолий Кулаков" и никогда этот код не менялся, IP-адреса никогда не менялись,
1915.32 1919.56 "Анатолий Кулаков" то когда у вас сервисы подскакивают внезапно, потому что увеличилась
1919.56 1922.52 "Анатолий Кулаков" нагрузка и также точно исчезают, когда нагрузка
1922.52 1926.00 "Анатолий Кулаков" уменьшилась, уже дает вам такую картину мира, что
1926.00 1928.64 "Анатолий Кулаков" вы, в принципе, не знаете, с кем вам нужно общаться
1928.64 1931.04 "Анатолий Кулаков" для того, чтобы получить те данные, которые нужны.
1931.04 1934.52 "Анатолий Кулаков" Вот эту самую проблему решает сервис Discovery, он вас полностью
1934.52 1936.68 "Анатолий Кулаков" абстрагирует, то есть поабстрагирует ваше взаимодействие за
1936.68 1937.68 "Анатолий Кулаков" логическим именем.
1937.68 1940.32 "Анатолий Кулаков" Вот вы знаете, что вам нужно обратиться к сервису, которого
1940.32 1944.92 "Анатолий Кулаков" зовут там каталог, например, и вы просто к нему обращаетесь.
1944.92 1948.68 "Анатолий Кулаков" На каком IP-адресу он висит, на каком порту, по какому
1948.68 1951.92 "Анатолий Кулаков" протоколу к нему нужно ходить и вообще может файликами
1951.92 1956.04 "Анатолий Кулаков" по ФТП пересылать, в общем, это все, вы уже не загоняетесь,
1956.04 1958.60 "Анатолий Кулаков" это все уже решает за вас какой-то транспортный уровень
1958.60 1959.60 "Анатолий Кулаков" другой.
1959.60 1962.28 "Анатолий Кулаков" Вот на эту поляну Microsoft и пошел.
1962.28 1966.48 "Анатолий Кулаков" На самом деле, как бы сама реализация очень даже проста,
1966.48 1969.84 "Анатолий Кулаков" и многие большие компании уже у себя внутрях такой
1969.84 1972.84 "Анатолий Кулаков" же сервис Discovery и внутри себя имеют.
1972.84 1975.44 "Анатолий Кулаков" В общем, поэтому Microsoft не сделал ничего такого большого,
1975.44 1978.80 "Анатолий Кулаков" кроме того, что взял и объединил это все под одними интерфейсами,
1978.80 1979.92 "Анатолий Кулаков" что тоже многого стоит.
1979.92 1983.96 "Анатолий Кулаков" Как же в нашем коде теперь это может выглядеть?
1983.96 1986.52 "Анатолий Кулаков" Прежде всего, вам нужно зарегистрировать все классики,
1986.52 1989.48 "Анатолий Кулаков" которые вам обеспечат сервис Discovery среди ваших компонентов.
1989.48 1993.16 "Анатолий Кулаков" Делается это в момент регистрации сервисов у Service Collection с
1993.16 1995.96 "Анатолий Кулаков" помощью специального метода AddServiceDiscovery.
1995.96 1999.12 "Анатолий Кулаков" После этого вам уже нужны какие-то потребители, ну
1999.12 2001.84 "Анатолий Кулаков" и в частности самым первым потребителем сервис Discovery
2001.84 2006.04 "Анатолий Кулаков" выступает HTTP Client, то есть HTTP Client нужно знать, куда
2006.04 2008.80 "Анатолий Кулаков" свои запросы посылать и хочет он это сделать по
2008.80 2010.36 "Анатолий Кулаков" логическому имени.
2010.36 2014.76 "Анатолий Кулаков" Поэтому при использовании метода AddHttpClient, это тоже
2014.76 2019.68 "Анатолий Кулаков" метод расширения для сервиса Collection, появилась возможность
2019.68 2022.72 "Анатолий Кулаков" у base адреса, то есть когда вы настраиваете этот HTTP
2022.72 2026.84 "Анатолий Кулаков" Client, указать HTTP адрес и в качестве хоста этого
2026.84 2029.44 "Анатолий Кулаков" HTTP адреса указать логическое имя некое.
2029.44 2032.20 "Анатолий Кулаков" То есть на данном уровне мы вообще никак не можем
2032.20 2035.44 "Анатолий Кулаков" отличить это логическое имя или настоящий хост.
2035.44 2038.40 "Анатолий Кулаков" И после того, как вы этот HTTP Client зарегистрировали,
2038.40 2043.08 "Анатолий Кулаков" нужно вызвать еще в конце метод UseServiceDiscovery у этого
2043.08 2044.72 "Анатолий Кулаков" HTTP Client Builder.
2044.72 2050.52 "Анатолий Кулаков" Это если вы хотите индивидуально для каждого HTTP Client подставить,
2050.52 2052.88 "Анатолий Кулаков" используя этот сервис Discovery и не используя этот флажок.
2052.88 2055.32 "Анатолий Кулаков" Но скорее всего все будут использовать проще, они
2055.32 2057.20 "Анатолий Кулаков" будут выставлять этот флажок глобально.
2057.20 2059.44 "Анатолий Кулаков" И глобально тоже можно сделать, для этого достаточно
2059.44 2064.72 "Анатолий Кулаков" вызвать у сервисов конфигуру HTTP Client Defaults, который оперирует
2064.72 2067.12 "Анатолий Кулаков" различными настройками и в частности у этих настроек
2067.12 2071.64 "Анатолий Кулаков" можно вызвать метод UseServiceDiscovery, что включит сервис Discovery
2071.64 2074.04 "Анатолий Кулаков" по умолчанию для всех HTTP Client.
2074.04 2076.84 "Анатолий Кулаков" И поэтому все HTTP Client в хосте могут использовать
2076.84 2079.24 "Анатолий Кулаков" логическое некое имя.
2079.24 2082.32 "Анатолий Кулаков" Теперь нам вот это логическое имя нужно превратить в
2082.32 2084.74 "Анатолий Кулаков" настоящий физический какой-то Endpoint.
2084.74 2087.80 "Анатолий Кулаков" Это можно сделать несколькими способами и самый банальный
2087.80 2091.48 "Анатолий Кулаков" способ, который приходит на ум, это через нашу конфигурацию.
2091.48 2095.96 "Анатолий Кулаков" Ну естественно у нас есть довольно мощная IOptions конфигурация,
2095.96 2098.16 "Анатолий Кулаков" которая умеет подтаскивать свои значения просто отовсюду,
2098.16 2103.08 "Анатолий Кулаков" прежде всего там из AppSettings файла JSON, из Environment Variables
2103.08 2105.60 "Анатолий Кулаков" и вообще из любого IConfiguration Source.
2105.60 2107.96 "Анатолий Кулаков" Этих IConfiguration Source уже в интернете целая-целая
2107.96 2108.96 "Анатолий Кулаков" куча.
2108.96 2110.68 "Анатолий Кулаков" То есть хоть из базы данных их затаскивай, хоть там
2110.68 2116.00 "Анатолий Кулаков" из консула, хоть из DNS сервера, откуда хочешь.
2116.00 2120.12 "Анатолий Кулаков" И стандартная поставка, которая достает эти адреса
2120.12 2124.80 "Анатолий Кулаков" из IConfiguration, она входит из коробки в те библиотеки,
2124.80 2126.84 "Анатолий Кулаков" которые нам предлагает использовать Microsoft.
2126.84 2130.48 "Анатолий Кулаков" В частности можно например в AppSettings описать подобный
2130.48 2131.48 "Анатолий Кулаков" байдинг.
2131.48 2134.50 "Анатолий Кулаков" Вы заводите там группу сервисов и у этой группы
2134.50 2136.64 "Анатолий Кулаков" есть специальный ключ, который совпадает с именем
2136.64 2138.76 "Анатолий Кулаков" вашего логического сервиса, например в нашем случае
2138.76 2139.84 "Анатолий Кулаков" каталог.
2139.84 2144.04 "Анатолий Кулаков" Пишите каталог и перечисляете все возможные IP-адреса,
2144.04 2147.48 "Анатолий Кулаков" порты, DNS-имена, по которым он может быть доступен.
2147.48 2151.44 "Анатолий Кулаков" То есть адрес может быть не один, их может быть несколько.
2151.44 2152.88 "Анатолий Кулаков" Это в принципе тоже нормально.
2152.88 2157.84 "Анатолий Кулаков" Вот эта секция Services довольно странно называется, потому
2157.84 2160.84 "Анатолий Кулаков" что слово Services уже довольно затерто, заюзано и может
2160.84 2164.40 "Анатолий Кулаков" быть в вашем конфиг-файле оно уже давно используется.
2164.40 2166.56 "Анатолий Кулаков" Поэтому существует класс, который называется Configuration
2166.56 2171.84 "Анатолий Кулаков" Service Point Resolver Options, помогающий вам переопределить это
2171.84 2172.84 "Анатолий Кулаков" название.
2172.84 2174.96 "Анатолий Кулаков" То есть вы можете любое название этой секции выбрать.
2174.96 2177.48 "Анатолий Кулаков" Главное укажите, что вы хотите, из какой части
2177.48 2178.48 "Анатолий Кулаков" загружать.
2178.48 2179.48 "Анатолий Кулаков" И он это сделает.
2179.48 2183.84 "Анатолий Кулаков" Теперь, что же нам делать, если там этих end-point-ов может
2183.84 2184.84 "Анатолий Кулаков" быть несколько.
2184.84 2187.48 "Анатолий Кулаков" В конце концов, наш запрос должен уйти только на какой-то
2187.48 2188.48 "Анатолий Кулаков" один end-point.
2188.48 2191.18 "Анатолий Кулаков" Когда у нас указано их несколько, мы с ними хотим сделать
2191.18 2192.18 "Анатолий Кулаков" что-то полезное.
2192.18 2196.44 "Анатолий Кулаков" Например, таким образом можно легко делать load-балансинг.
2196.44 2199.16 "Анатолий Кулаков" То есть не один из этих адресов, там у вас есть
2199.16 2202.04 "Анатолий Кулаков" допустим 10 адресов каталогов, которых вы можете достать
2202.04 2203.04 "Анатолий Кулаков" информацию.
2203.04 2207.00 "Анатолий Кулаков" Мы можем не один из них напрягать, а все 10 по какому-то определенному
2207.00 2208.00 "Анатолий Кулаков" алгоритму.
2208.00 2210.46 "Анатолий Кулаков" Адрес называется как раз load-балансингом.
2210.46 2212.96 "Анатолий Кулаков" Вы можете сами запрограммировать этот алгоритм, который
2212.96 2216.40 "Анатолий Кулаков" будет из 10 IP-адресов выбирать тот, на который будет идти
2216.40 2217.40 "Анатолий Кулаков" текущий запрос.
2217.40 2219.96 "Анатолий Кулаков" Но по дефолту используется around robin.
2219.96 2223.24 "Анатолий Кулаков" Это когда мы все адреса, все end-поинты, которые у
2223.24 2225.60 "Анатолий Кулаков" нас есть, перебираем по порядку.
2225.60 2227.76 "Анатолий Кулаков" Это обычно дает какое-то равномерное распределение
2227.76 2228.84 "Анатолий Кулаков" нагрузки.
2228.84 2232.36 "Анатолий Кулаков" Из коробки также еще идет несколько селекторов так
2232.36 2235.84 "Анатолий Кулаков" называемых, которые способны выбрать адрес из нескольких.
2235.84 2239.08 "Анатолий Кулаков" Прежде всего это селектор, который называется pick-first,
2239.08 2241.44 "Анатолий Кулаков" который берет всегда только самый первый адрес.
2241.44 2242.96 "Анатолий Кулаков" Ранее упомянутый round robin.
2242.96 2246.16 "Анатолий Кулаков" Также не могли обойтись с прекрасным селектором,
2246.16 2247.16 "Анатолий Кулаков" не завязать его.
2247.16 2251.88 "Анатолий Кулаков" Это random, который выбирает случайный адрес, который
2251.88 2253.08 "Анатолий Кулаков" у вас указан в этом массиве.
2253.08 2255.60 "Анатолий Кулаков" И power of two choices.
2255.60 2258.00 "Анатолий Кулаков" Это специальный алгоритм load-балансинга.
2258.00 2262.72 "Анатолий Кулаков" Он выбирает два каких-то end-поинта по случайности.
2262.72 2266.56 "Анатолий Кулаков" И из каждого из этих end-поинтов смотрит нагрузку.
2266.56 2270.12 "Анатолий Кулаков" И на каком из них нагрузка меньше, тот и отдает свой
2270.12 2271.12 "Анатолий Кулаков" запрос.
2271.12 2275.20 "Анатолий Кулаков" Этот end-пойнт, то есть эта технология сервис-дискавери
2275.20 2277.08 "Анатолий Кулаков" в принципе на этом и заканчивается.
2277.08 2279.72 "Анатолий Кулаков" Как я уже сказал, что вы очень легко можете у себя
2279.72 2283.76 "Анатолий Кулаков" это сделать, если не хотите тащить к себе эти библиотеки.
2283.76 2285.60 "Анатолий Кулаков" А сейчас они находятся в превью.
2285.60 2287.92 "Анатолий Кулаков" И в тот момент, когда они в превью, они поддерживают
2287.92 2289.72 "Анатолий Кулаков" только дотнет восьмой.
2289.72 2291.92 "Анатолий Кулаков" Поэтому наверняка многие из вас не захотят их себе
2291.92 2292.92 "Анатолий Кулаков" тащить.
2292.92 2298.80 "Анатолий Кулаков" Она легко реализуется с помощью обычных месседж делегатов.
2298.80 2300.76 "Анатолий Кулаков" Которые могут перехватывать абсолютно любой запрос.
2300.76 2303.04 "Анатолий Кулаков" И в зависимости от того, что в этом запросе стоит
2303.04 2306.56 "Анатолий Кулаков" в хате, логическое имя или физическое имя, могут
2306.56 2308.64 "Анатолий Кулаков" подменять вам значение.
2308.64 2311.36 "Анатолий Кулаков" Делается легко, но у Microsoft прекрасно, что они сделали
2311.36 2315.24 "Анатолий Кулаков" это все единым интерфейсом и собрали в единой коробке.
2315.24 2318.08 "Анатолий Кулаков" Как я уже сказал, сейчас в превью все-таки есть
2318.08 2321.80 "Анатолий Кулаков" большой шанс, что когда из превью оно выйдет, то
2321.80 2324.52 "Анатолий Кулаков" поддержка фреймворков будет шире.
2324.52 2327.36 "Анатолий Кулаков" Как минимум три последних Microsoft обычно поддерживает
2327.36 2328.60 "Анатолий Кулаков" в своих библиотеках.
2328.60 2331.44 "Анатолий Кулаков" Ну и ничего не мешает это все поддержать в дотнет-стандарте.
2331.44 2333.52 "Анатолий Кулаков" Потому что все интерфейсы довольно примитивные.
2333.52 2337.12 "Анатолий Кулаков" И, скорее всего, тоже совместимость со стандартом вполне может
2337.12 2338.12 "Анатолий Кулаков" и будет.
2338.12 2345.12 "Анатолий Кулаков" Сейчас же этот пакет разрабатывается внутри репозитория с Project
2345.12 2346.12 "Анатолий Кулаков" Expire.
2346.12 2350.56 "Анатолий Кулаков" Наверняка, когда он оттуда уйдет, переедет куда-нибудь
2350.56 2353.44 "Анатолий Кулаков" в более свое место, может быть, куда-нибудь в ISP или
2353.44 2354.84 "Анатолий Кулаков" в какой-то из этих репозиториев.
2354.84 2356.84 "Анатолий Кулаков" Кстати, о Project Expire.
2356.84 2360.96 "Анатолий Кулаков" Project Expire тоже использует очень нативно Search Discovery.
2360.96 2364.24 "Анатолий Кулаков" Каждый проект, каждый компонент, который есть в Expire, у него
2364.24 2368.00 "Анатолий Кулаков" есть так называемый name, то есть имя компонента.
2368.00 2370.80 "Анатолий Кулаков" Это является логическим свойством, к которому можно
2370.80 2374.48 "Анатолий Кулаков" обратиться из абсолютно любого другого компонента.
2374.48 2377.16 "Анатолий Кулаков" И если компоненты связать с помощью специального
2377.16 2381.56 "Анатолий Кулаков" метода, который называется Weave Reference, то Expire пробрасывает
2381.56 2385.12 "Анатолий Кулаков" соответствующее знание о логическом имени и о физическом
2385.12 2388.84 "Анатолий Кулаков" адресе, где он поднял этот компонент, в те компоненты,
2388.84 2390.12 "Анатолий Кулаков" которые ссылаются на данный.
2390.12 2393.76 "Анатолий Кулаков" В принципе, и все.
2393.76 2396.76 "Анатолий Кулаков" Его довольно элементарно использовать.
2396.76 2399.36 "Анатолий Кулаков" Используется он довольно прозрачно, вы о нем даже
2399.36 2401.96 "Анатолий Кулаков" не задумываетесь, главное просто договориться, что
2401.96 2404.20 "Анатолий Кулаков" в вашем приложении используется Search Discovery и все, и задать
2404.20 2406.40 "Анатолий Кулаков" точку там, где это будет конфигурироваться.
2406.40 2410.40 "Анатолий Кулаков" В общем, ждем релиза, тем, кому не терпится, уже могут
2410.40 2413.40 "Анатолий Кулаков" его достать из Project Espire, уже есть как бы отдельные
2413.40 2416.68 "Анатолий Кулаков" пакеты, которые на самом деле сейчас в превью, если
2416.68 2418.72 "Анатолий Кулаков" вы не боитесь превью, то можете поставить, попробовать
2418.72 2422.06 "Анатолий Кулаков" подергать и подготовиться уже к тем нововведениям,
2422.06 2423.40 "Анатолий Кулаков" которые наверняка скоро уже будут ожидать всех
2423.40 2424.40 "Анатолий Кулаков" нас в релизе.
2424.40 2430.04 "Игорь Лабутин" Ну и прекрасно, да, действительно полезная небольшая библиотечка.
2430.04 2432.36 "Игорь Лабутин" На крайняк, даже если вы не хотите ее писать сами,
2432.36 2436.16 "Игорь Лабутин" ну просто заберите исходники из Espire, мне кажется.
2436.16 2438.36 "Игорь Лабутин" Несмотря на то, что превью, скорее всего, там все плюс-минус
2438.36 2439.36 "Игорь Лабутин" работоспособно.
2439.36 2443.56 "Анатолий Кулаков" Да, да, может вам просто их избыточно немножко
2443.56 2445.84 "Анатолий Кулаков" будет, но скорее всего, это небольшая проблема.
2445.84 2448.44 "Игорь Лабутин" Пойдем дальше, и дальше поговорим про NativeOut.
2448.44 2451.44 "Игорь Лабутин" В одном из прошлых выпусков мы как раз обсуждали, что
2451.44 2453.48 "Игорь Лабутин" NativeOut – это хорошо, это круто, это там меньший
2453.48 2456.64 "Игорь Лабутин" размер, лучший стартап-тайм, вот это все.
2456.64 2458.78 "Игорь Лабутин" Осталась одна проблема, у нас далеко не все библиотеки
2458.78 2464.28 "Игорь Лабутин" поддерживают NativeOut, и тут как раз попалась статья
2464.28 2468.96 "Игорь Лабутин" в официальной документации Microsoft на предмет того, даже
2468.96 2471.56 "Игорь Лабутин" не совсем документация, это все-таки в блоге, но
2471.56 2473.92 "Игорь Лабутин" все-таки это официальная статья от Microsoft на предмет
2473.92 2477.28 "Игорь Лабутин" того, как же делать библиотеки NativeOut-компатибл.
2477.28 2480.60 "Игорь Лабутин" И я, признаться, ожидал там всяких супер-крутых
2480.60 2482.96 "Игорь Лабутин" гайдов, но все оказалось довольно просто, прозаично
2482.96 2486.36 "Игорь Лабутин" и в некоторой степени неинтересно, но давайте расскажу по
2486.36 2487.36 "Игорь Лабутин" порядку.
2487.36 2488.92 "Игорь Лабутин" Во-первых, в чем проблема с NativeOut?
2488.92 2490.84 "Игорь Лабутин" У нас есть несколько ограничений.
2490.84 2496.56 "Игорь Лабутин" Во-первых, код должен быть то, что Microsoft называет Trim-компатибл,
2496.56 2499.40 "Игорь Лабутин" то есть никакой динамической загрузки сборок, рефлекшн
2499.40 2503.28 "Игорь Лабутин" использовать можно, но нельзя гулять по типам,
2503.28 2506.80 "Игорь Лабутин" то есть те типы, которые у вас есть в рантайме, которые
2506.80 2508.96 "Игорь Лабутин" точно используется для выполнения кода, они доступны
2508.96 2512.36 "Игорь Лабутин" для рефлекшна, потому что все метаданные по ним есть,
2512.36 2514.24 "Игорь Лабутин" но вы не можете, например, взять и получить все типы
2514.24 2517.72 "Игорь Лабутин" в сборке, потому что концепта сборки нет, у вас все уже
2517.72 2520.64 "Игорь Лабутин" собрано, никаких метаданных нет.
2520.64 2523.28 "Анатолий Кулаков" Какие способы решения этого?
2523.28 2525.94 "Анатолий Кулаков" Допустим, мне нужно собрать все контроллеры в моей
2525.94 2531.24 "Анатолий Кулаков" сборке, чтобы потом лентпоинты к ним сделать, как это решать?
2531.24 2535.32 "Игорь Лабутин" Это решать какой-то, сорс-генератор, статическая генерация,
2535.32 2536.32 "Игорь Лабутин" вот это все.
2536.32 2539.44 "Анатолий Кулаков" Угу, то есть в принципе писать, а вот совместимые
2539.44 2543.12 "Анатолий Кулаков" библиотеки, наверное, нужно в паре с каким-нибудь сорс-генератором,
2543.12 2544.12 "Игорь Лабутин" который будет представлять типики.
2544.12 2545.12 "Игорь Лабутин" Да-да-да.
2545.12 2546.80 "Игорь Лабутин" Какие-то сорс-генераторы делать, но у тебя как раз
2546.80 2549.48 "Игорь Лабутин" второй момент, второе ограничение, которое натуральным образом
2549.48 2551.32 "Игорь Лабутин" ведет к сорс-генераторам, это то, что вы не можете
2551.32 2553.16 "Игорь Лабутин" генерировать код в ран-тайме.
2553.16 2555.24 "Игорь Лабутин" Никакого систем рефлекшн иметь, поэтому если вам
2555.24 2558.40 "Игорь Лабутин" нужно генерировать какой-то код, то делайте это в компайл-тайме,
2558.40 2559.40 "Игорь Лабутин" то бишь сорс-генераторы.
2559.40 2562.12 "Игорь Лабутин" Значит, что Microsoft говорит дальше?
2562.12 2566.48 "Игорь Лабутин" Дальше они говорят следующее, что в принципе при сборке,
2566.48 2569.60 "Игорь Лабутин" когда вы собираете ваше приложение, и для него включен
2569.60 2573.12 "Игорь Лабутин" флажок, что я хочу собрать его в nativeout, то, естественно,
2573.12 2576.18 "Игорь Лабутин" там происходит процесс самой компиляции, выполняются
2576.18 2581.20 "Игорь Лабутин" всякие рослин-аналайзеры на вашем коде, и также,
2581.20 2583.68 "Игорь Лабутин" естественно, компилятор еще смотрит в момент собственной
2583.68 2586.84 "Игорь Лабутин" компиляции, что ему все понятно, и он все смог найти.
2586.84 2592.08 "Игорь Лабутин" И Microsoft говорит, что в принципе, если вся эта троица не выдала
2592.08 2598.20 "Игорь Лабутин" никаких ворнингов про nativeout, то с практически стопроцентной
2598.20 2602.40 "Игорь Лабутин" вероятностью ваше приложение в nativeout-режиме заработает.
2602.40 2607.76 "Игорь Лабутин" А вот если такие ворнинги были, то это не значит,
2607.76 2609.44 "Игорь Лабутин" что оно не заработает.
2609.44 2612.16 "Игорь Лабутин" Возможно, заработает, возможно, не все сценарии, а может
2612.16 2613.16 "Игорь Лабутин" и не заработает.
2613.16 2614.16 "Игорь Лабутин" Никто не знает.
2614.16 2620.76 "Игорь Лабутин" Дальше, собственно, из этого делается вывод, что единственное,
2620.76 2622.84 "Игорь Лабутин" что нам нужно, это получить ворнинги.
2622.84 2625.72 "Игорь Лабутин" То есть, если вы делаете приложение, тут вроде все
2625.72 2626.72 "Игорь Лабутин" понятно.
2626.72 2628.68 "Игорь Лабутин" Ну, берем приложение, ставим флажок, компилируем в nativeout,
2628.68 2633.40 "Игорь Лабутин" и вуаля, получаем все анализаторы, все дела и ворнинги, а мы
2633.40 2634.40 "Игорь Лабутин" же пишем библиотеку.
2634.40 2637.04 "Игорь Лабутин" И что же в этом случае делать?
2637.04 2639.72 "Игорь Лабутин" Ну, во-первых, нужно включить розлин аналайзер.
2639.72 2642.60 "Игорь Лабутин" Для этого можно поставить такую пропертию, называется
2642.60 2646.04 "Игорь Лабутин" isout-compatible, поставить ее в true, это автоматически
2646.04 2649.36 "Игорь Лабутин" включает три аналайзера, trim-аналайзер, single-file-аналайзер
2649.36 2651.32 "Игорь Лабутин" и out-аналайзер.
2651.32 2655.88 "Игорь Лабутин" Работает эта штука только с седьмым дотнетом и выше,
2655.88 2658.80 "Игорь Лабутин" и, к сожалению, аналайзеры, они довольно ограничены
2658.80 2662.28 "Игорь Лабутин" в том плане, что они не смотрят вообще на всю программу
2662.28 2665.36 "Игорь Лабутин" целиком, они смотрят только на сборки индивидуальные,
2665.36 2667.52 "Игорь Лабутин" и поэтому совсем все они не могут сделать, все то
2667.52 2669.44 "Игорь Лабутин" же самое, что делает компилятор.
2669.44 2672.76 "Игорь Лабутин" Поэтому, конечно же, нужно в идеале получить все предупреждения,
2672.76 2674.56 "Игорь Лабутин" в том числе и от nativeout-компилятора.
2674.56 2677.48 "Игорь Лабутин" А мы делаем библиотеку, как мы помним.
2677.48 2681.72 "Игорь Лабутин" И поэтому Microsoft говорит, ну что, делаем простой способ.
2681.72 2684.56 "Игорь Лабутин" Берете тестовое приложение, точнее, они называют даже
2684.56 2690.60 "Игорь Лабутин" не testapp, а dummyapp, то есть такое пустое приложение,
2690.60 2694.40 "Игорь Лабутин" из которого референсите вашу сборку и говорите
2694.40 2698.16 "Игорь Лабутин" специальным образом out-компилятору в Cessproje этого приложения,
2698.16 2701.48 "Игорь Лабутин" что всю вашу библиотеку было бы неплохо оставить,
2701.48 2703.52 "Игорь Лабутин" то есть не надо ее trim-ать.
2703.52 2705.76 "Игорь Лабутин" Таким образом, out-компилятор будет вынужден проверить
2705.76 2709.12 "Игорь Лабутин" всю вашу библиотеку на предмет out-совместимости.
2709.12 2710.84 "Игорь Лабутин" Ну и выдать, возможно, какие-то ворнинги.
2710.84 2716.44 "Игорь Лабутин" В статье приводится несколько примеров того, как это можно
2716.44 2718.56 "Игорь Лабутин" сделать, как это сделано уже для разных библиотек,
2718.56 2720.68 "Игорь Лабутин" типа OpenTelemetry, еще кого-то.
2720.68 2723.04 "Игорь Лабутин" И можно там просто посмотреть, как это сделано с точки
2723.04 2725.04 "Игорь Лабутин" зрения, как пишется вот это вот dummy-приложение
2725.04 2727.72 "Игорь Лабутин" и что нужно написать в его Cessproje файл.
2727.72 2731.52 "Игорь Лабутин" Там довольно многословный текст, но он прямолинейный,
2731.52 2735.24 "Игорь Лабутин" ну просто много писать, если у вас большая библиотека.
2735.24 2739.36 "Игорь Лабутин" Ну, хорошо, мы, допустим, даже собрали наше приложение,
2739.36 2742.12 "Игорь Лабутин" севдо-приложение, то бишь, по сути, собрали нашу библиотеку
2742.12 2745.48 "Игорь Лабутин" в native-auto-варианте, попробовали, и выдали нам гору ворнингов
2745.48 2747.56 "Игорь Лабутин" про то, что это не работает, то не работает, это вообще
2747.56 2749.92 "Игорь Лабутин" не out-компайт был, вот это все.
2749.92 2753.36 "Игорь Лабутин" Нужно с этим всем что-то делать, и делать с этим
2753.36 2755.84 "Игорь Лабутин" можно, собственно, следующую штуку.
2755.84 2760.12 "Игорь Лабутин" Единственное, что вы с этим можете делать, с точки зрения
2760.12 2763.84 "Игорь Лабутин" именно ворнингов компилятора, это расставлять атрибуты.
2763.84 2771.60 "Игорь Лабутин" Атрибут номер один называется requiresUnreferencedCode, типа требует
2771.60 2772.60 "Игорь Лабутин" код, на который нет ссылок.
2772.60 2778.80 "Игорь Лабутин" И я, честно говоря, вот глядя на название атрибута, сложно
2778.80 2783.72 "Игорь Лабутин" понять, что он делает и зачем он нужен, но объяснение
2783.72 2789.88 "Игорь Лабутин" такое, если на вашем методе стоит такой атрибут, то
2789.88 2793.60 "Игорь Лабутин" компилятор будет выдавать ворнинг не на вашем методе,
2793.60 2796.28 "Игорь Лабутин" а на любом методе, который вызовет этот метод.
2796.28 2801.20 "Игорь Лабутин" Ну то есть это не подготовка вашей библиотеки к тому,
2801.20 2805.36 "Игорь Лабутин" чтобы она была native-out-компатибл, а отметка этого метода,
2805.36 2808.72 "Игорь Лабутин" что если вы вызовете этот метод, то, короче, все плохо
2808.72 2809.80 "Игорь Лабутин" и не надо его использовать.
2809.80 2814.56 "Анатолий Кулаков" Зачем его оставлять в библиотеке, сделали бы его под ифдевом
2814.56 2815.56 "Игорь Лабутин" каким-нибудь.
2815.56 2818.12 "Игорь Лабутин" Нет, подожди, ты не можешь сделать его, ифдев не работает
2818.12 2819.12 "Игорь Лабутин" с native-out.
2819.12 2821.24 "Игорь Лабутин" Ну в смысле, ты не можешь ифдевать в зависимости
2821.24 2822.24 "Игорь Лабутин" от native-out.
2822.24 2824.44 "Анатолий Кулаков" Мы же знаем, когда нашу библиотеку компилируют
2824.44 2825.44 "Анатолий Кулаков" под native-out.
2825.44 2826.44 "Анатолий Кулаков" Нет.
2826.44 2827.44 "Игорь Лабутин" Не знаем.
2827.44 2828.44 "Игорь Лабутин" Не знаем, в том-то и дело.
2828.44 2829.44 "Игорь Лабутин" Мы не знаем.
2829.44 2831.44 "Игорь Лабутин" Поэтому мы размечаем нашу библиотеку атрибутами
2831.44 2835.36 "Игорь Лабутин" так, чтобы вызывающий код знал, какие методы native-out
2835.36 2839.92 "Игорь Лабутин" safe, а они будут без атрибутов, а какие методы native-out unsafe.
2839.92 2843.08 "Анатолий Кулаков" То есть, по сути, этот атрибут говорит, что я несовместим
2843.08 2844.08 "Анатолий Кулаков" с native-out.
2844.08 2846.36 "Игорь Лабутин" Да, вот этот метод несовместим с native-out, да.
2846.36 2848.44 "Игорь Лабутин" То есть ты должен библиотеку разметить именно таким
2848.44 2849.44 "Игорь Лабутин" образом.
2849.44 2854.28 "Игорь Лабутин" Второй атрибут, он как бы прям вот напрямую говорит,
2854.28 2858.76 "Игорь Лабутин" что метод is not compatible with out, это requires dynamic code.
2858.76 2861.96 "Анатолий Кулаков" Так, а в чём разница тогда с первым методом?
2861.96 2866.32 "Игорь Лабутин" Потому что есть третий атрибут, называется dynamically
2866.32 2867.32 "Игорь Лабутин" accessed members.
2867.32 2873.28 "Игорь Лабутин" И я так понял историю, что если ты, если у тебя есть
2873.28 2875.96 "Игорь Лабутин" метод, который помечен requires dynamic code, то есть он
2875.96 2878.52 "Игорь Лабутин" требует, ну прям вот рефлексии, условно говоря, да или кода
2878.52 2881.36 "Игорь Лабутин" генерации какой-нибудь, то вот такое, использование
2881.36 2885.62 "Игорь Лабутин" такого метода в принципе невозможно в native-out.
2885.62 2890.44 "Игорь Лабутин" А вот requires unreferenced code, это штука следующая, то есть
2890.44 2895.80 "Игорь Лабутин" если ты сможешь заставить native-out компилятор оставить
2895.80 2902.08 "Игорь Лабутин" в рантайме все те нужные тебе метаданные, которые
2902.08 2905.84 "Игорь Лабутин" нужны методу, который помечен как requires unreferenced code, то
2905.84 2907.40 "Игорь Лабутин" он заработает.
2907.40 2909.76 "Игорь Лабутин" Именно поэтому вординг перемещается на уровень
2909.76 2910.76 "Игорь Лабутин" выше.
2910.76 2911.76 "Анатолий Кулаков" Откуда мы узнаем?
2911.76 2913.76 "Анатолий Кулаков" Откуда компилятор узнает, что именно все метаданные
2913.76 2914.76 "Анатолий Кулаков" оставлены?
2914.76 2915.76 "Игорь Лабутин" Вот.
2915.76 2920.52 "Игорь Лабутин" А дальше ты туда пишешь, есть третий атрибут, называется
2920.52 2925.32 "Игорь Лабутин" dynamically accessed members, и он показывает, он подсказывает
2925.32 2928.48 "Игорь Лабутин" компилятору, что нужно оставить.
2928.48 2931.12 "Игорь Лабутин" То есть, например, у тебя есть метод, который говорит
2931.12 2938.80 "Игорь Лабутин" generic_method, который принимает t, или даже type, ну можно
2938.80 2944.20 "Игорь Лабутин" t, для простоты, и внутри вызывает активатор @t_create_instance,
2944.20 2945.20 "Игорь Лабутин" без аргументов.
2945.20 2948.28 "Игорь Лабутин" Спрашивается, совместим ли этот метод с native-out?
2948.28 2951.36 "Анатолий Кулаков" Ну, по идее, активатор - это reflection, поэтому совместить
2951.36 2952.80 "Анатолий Кулаков" не должен быть.
2952.80 2953.80 "Анатолий Кулаков" Вот.
2953.80 2954.80 "Игорь Лабутин" Но!
2954.80 2957.84 "Игорь Лабутин" Если ты этот метод пометишь атрибутом dynamically accessed
2957.84 2960.88 "Игорь Лабутин" members, а это атрибут, который принимает янучек, и ты
2960.88 2963.80 "Игорь Лабутин" туда передашь, я не помню, как называется, помню, что-то
2963.80 2968.60 "Игорь Лабутин" типа dynamic_members.constructors, то ты у всех типов в своей
2968.60 2972.48 "Игорь Лабутин" сборке сохранишь конструкторы, и тогда этот метод становится
2972.48 2973.48 "Игорь Лабутин" native_out_friendly.
2973.48 2976.12 "Анатолий Кулаков" То есть, там какой-то режим рефлекшена, который умеет
2976.12 2980.48 "Анатолий Кулаков" сохранять некие мембры, в частности, конструкторы.
2980.48 2985.40 "Игорь Лабутин" Смотри, та метаинформация, которая нужна рантайму,
2985.40 2987.88 "Игорь Лабутин" те методы, которые реально будут исполняться, по ним
2987.88 2991.32 "Игорь Лабутин" метаинформация есть, необходимая для рефлекшена.
2991.32 2996.68 "Игорь Лабутин" Просто если эта информация native-out компилятором сохраняется,
2996.68 2998.80 "Игорь Лабутин" только в том случае, если native-out компилятор может
2998.80 3002.04 "Игорь Лабутин" статически доказать, что этот метод, что этот тип,
3002.04 3003.64 "Игорь Лабутин" этот метод будет использоваться.
3003.64 3006.36 "Игорь Лабутин" Ну, путем анализа, значит, этого вызова там друг друга
3006.36 3007.36 "Анатолий Кулаков" зависимости.
3007.36 3010.76 "Анатолий Кулаков" Почему нельзя тогда просто все методы сохранить, и
3010.76 3013.84 "Анатолий Кулаков" все конструкторы сохранить, и все, и тогда сотни ваутов
3013.84 3014.84 "Анатолий Кулаков" будут?
3014.84 3015.84 "Анатолий Кулаков" Потому что это будет огромнейший объем.
3015.84 3018.64 "Анатолий Кулаков" Ну, то есть, объем — это единственная причина, а на самом деле
3018.64 3021.16 "Анатолий Кулаков" сделать программу совместимую с native-out никаких проблем
3021.16 3022.16 "Анатолий Кулаков" нет.
3022.16 3023.16 "Анатолий Кулаков" Сохраняй весь рефлекшен и все.
3023.16 3024.16 "Игорь Лабутин" Да.
3024.16 3025.84 "Игорь Лабутин" Но только ты умучаешься расставлять эти naming-access-members,
3025.84 3028.84 "Игорь Лабутин" а ты не можешь сделать… То есть, смотри, как только
3028.84 3031.16 "Игорь Лабутин" ты включаешь native-out, у тебя автоматически включается
3031.16 3032.16 "Игорь Лабутин" тримминг.
3032.16 3034.60 "Игорь Лабутин" Ты не можешь выключить тримминг в native-out.
3034.60 3038.92 "Игорь Лабутин" И именно тримминг как раз в том числе не дает возможность
3038.92 3041.76 "Игорь Лабутин" делать вот этот произвольный рефлекшен, потому что казалось
3041.76 3043.24 "Игорь Лабутин" бы, действительно, окей, мы не можем генерировать
3043.24 3047.04 "Игорь Лабутин" новый код через этот рефлекшен-эмит, ну, потому что джета у нас
3047.04 3053.08 "Игорь Лабутин" нет в науоте, но вроде бы, ну, доступаться к метаданным,
3053.08 3054.08 "Игорь Лабутин" что сохранили метаданные.
3054.08 3057.84 "Игорь Лабутин" Просто если ты берешь какой-нибудь system-collections-generic условный,
3057.84 3059.40 "Игорь Лабутин" ты же понимаешь, сколько там коллекций.
3059.40 3064.44 "Игорь Лабутин" Часто ли ты пользуешься, не знаю, ну ладно, конкурент-дикшен,
3064.44 3068.52 "Игорь Лабутин" наверное, пользуешься каким-нибудь хэш-сетом или кто-то, хэш-мап,
3068.52 3069.52 "Игорь Лабутин" хэш-сет.
3069.52 3073.20 "Анатолий Кулаков" Все равно, смотри, это же звучит как некая оптимизация.
3073.20 3075.60 "Анатолий Кулаков" Допустим, я жирный, у меня много памяти, много дисков,
3075.60 3079.60 "Анатолий Кулаков" мне наплевать, я хочу nativeout, я за гостов, что мое приложение
3079.60 3082.12 "Анатолий Кулаков" весит 5 гигабайт, меня это не напрягает ни разу.
3082.12 3083.12 "Игорь Лабутин" Могу ли я так сделать?
3083.12 3085.76 "Игорь Лабутин" Это тебя напряжет, потому что приложение nativeout в 5
3085.76 3089.68 "Игорь Лабутин" гигабайт будет стартовать дольше, чем дотнетное обычное
3089.68 3090.68 "Игорь Лабутин" менеджмент-приложение.
3090.68 3093.76 "Анатолий Кулаков" Ну, время старта меня тоже не волнует, я ж не дисктопное
3093.76 3094.76 "Анатолий Кулаков" какое-то дерьмо напишу.
3094.76 3095.76 "Анатолий Кулаков" А зачем тогда тебе nativeout?
3095.76 3098.56 "Анатолий Кулаков" Дай подумать, может, перформанс у меня улучшится в рантайме
3098.56 3100.28 "Анатолий Кулаков" уже, когда оно стартанет, прогреется.
3100.28 3105.28 "Игорь Лабутин" Так нет, стоять, стоять, nativeout нет понятия прогреется.
3105.28 3109.84 "Игорь Лабутин" Nativeout, там нет жита, то, что скомпилировано, то и выполняется,
3109.84 3112.44 "Игорь Лабутин" там уже никакого прогреве не идет.
3112.44 3116.40 "Игорь Лабутин" Вообще цели nativeout конкретно у Microsoft заявлены две.
3116.40 3119.44 "Игорь Лабутин" Первое – быстрый старт, и для этого нужно в том
3119.44 3123.88 "Игорь Лабутин" числе уменьшать размер сборки, и второе – это уменьшение
3123.88 3125.92 "Игорь Лабутин" размера, занимаемого.
3125.92 3130.24 "Анатолий Кулаков" Погоди, а то, что мы избавляемся от gc и от jita, то есть нам
3130.24 3131.24 "Анатолий Кулаков" не дает быстрее выполнение…
3131.24 3132.24 "Игорь Лабутин" От gc мы не избавляемся.
3132.24 3133.24 "Анатолий Кулаков" От jita.
3133.24 3136.92 "Анатолий Кулаков" Нам не дает быстрее выполнение нашей программы, и не надо
3136.92 3140.72 "Анатолий Кулаков" там приджитить и прочие вот эти вещи делать.
3140.72 3143.68 "Игорь Лабутин" Оно дает более быстрый старт, потому что на старте
3143.68 3147.68 "Игорь Лабутин" тебе не нужно джитить, но оно не дает более быстрое
3147.68 3149.12 "Игорь Лабутин" время исполнения.
3149.12 3151.52 "Игорь Лабутин" Мы с тобой обсуждали это в прошлом подкасте, было
3151.52 3155.98 "Игорь Лабутин" видно, что если мы делаем nativeout версию ISP netcore, то его
3155.98 3159.32 "Игорь Лабутин" пропускная способность в реквестах в секунду снижается
3159.32 3161.84 "Игорь Лабутин" по сравнению с jit версией, менеджд версией.
3161.84 3162.84 "Игорь Лабутин" Вот.
3162.84 3165.72 "Игорь Лабутин" И там есть на самом деле, если ты помнишь, я рассказывал,
3165.72 3168.28 "Игорь Лабутин" у nativeout компилятора есть два режима – optimize_for_size
3168.28 3169.28 "Игорь Лабутин" и optimize_for_speed.
3169.28 3172.36 "Анатолий Кулаков" Ну, speed имеется здесь в виду именно старт, да?
3172.36 3173.36 "Игорь Лабутин" Да.
3173.36 3174.36 "Игорь Лабутин" Да-да-да.
3174.36 3175.36 "Игорь Лабутин" Не просто время работы.
3175.36 3176.36 "Игорь Лабутин" Да.
3176.36 3177.36 "Игорь Лабутин" Вот.
3177.36 3178.36 "Игорь Лабутин" Поэтому смысл в том, что тримминг будет всегда,
3178.36 3183.24 "Игорь Лабутин" и основная магия разметки библиотеки при подготовке
3183.24 3187.88 "Игорь Лабутин" ее к nativeout – это разметить, а что же можно безболезненно
3187.88 3188.88 "Игорь Лабутин" откусить.
3188.88 3193.28 "Игорь Лабутин" И вот этот атрибут dynamic_access_members позволяет тебе на дженерик-коде
3193.28 3197.60 "Игорь Лабутин" типа вызова активатора create_instance сказать, что вот если ты
3197.60 3201.52 "Игорь Лабутин" эту лебузу юзал, то будь добр, оставь все конструкторы,
3201.52 3204.96 "Игорь Лабутин" что как бы может быть додуре все еще, но всяко меньше,
3204.96 3207.00 "Игорь Лабутин" чем все мемберы всех типов.
3207.00 3208.00 "Игорь Лабутин" Вот.
3208.00 3211.64 "Анатолий Кулаков" А можно как-нибудь специализировать, какие конструкторы именно
3211.64 3212.64 "Игорь Лабутин" я хочу оставить?
3212.64 3213.64 "Игорь Лабутин" Да-да-да.
3213.64 3214.64 "Игорь Лабутин" Там как-то можно.
3214.64 3215.64 "Игорь Лабутин" Там более того, можно дойти до конкретных типов, то
3215.64 3218.84 "Игорь Лабутин" есть можно сказать типа вот пожалуйста оставь
3218.84 3219.84 "Игорь Лабутин" только этот тип.
3219.84 3222.24 "Игорь Лабутин" Там как-то это можно все сделать, там если почитать
3222.24 3223.32 "Игорь Лабутин" статью, там примеры есть.
3223.32 3224.32 "Игорь Лабутин" Вот.
3224.32 3229.12 "Игорь Лабутин" В итоге у тебя, возвращаясь собственно к атрибутам,
3229.12 3231.96 "Игорь Лабутин" получится размеченный код, для которого либо известно,
3231.96 3234.40 "Игорь Лабутин" что нужно ставить для reflection, либо известно, что он не
3234.40 3236.48 "Игорь Лабутин" поддерживает nativeout.
3236.48 3241.40 "Игорь Лабутин" И сейчас еще про атрибуты важно сказать следующее.
3241.40 3244.00 "Игорь Лабутин" Эти атрибуты поддержаны только с дотнет пятого,
3244.00 3247.40 "Игорь Лабутин" а некоторые, кто-то один из них поддержан с дотнет
3247.40 3248.40 "Игорь Лабутин" седьмого.
3248.40 3252.96 "Игорь Лабутин" И возникает вопрос, ну библиотеки у нас, мы же таргетим-то
3252.96 3255.72 "Игорь Лабутин" их возможно не только на последний восьмой дотнет,
3255.72 3256.72 "Игорь Лабутин" но еще куда-то.
3256.72 3257.72 "Игорь Лабутин" Вот.
3257.72 3262.42 "Игорь Лабутин" И здесь возникает вопрос, а что делать с библиотеками,
3262.42 3264.52 "Игорь Лабутин" которые мультитаргетят, например?
3264.52 3267.32 "Игорь Лабутин" Ну мы же можем написать полезную библиотеку, которая
3267.32 3269.32 "Игорь Лабутин" если использована из дотнет восьмого, она будет все
3269.32 3271.92 "Игорь Лабутин" такая удобная, размеченная этими атрибутами, но если
3271.92 3277.08 "Игорь Лабутин" ты ее используешь из дотнет, не знаю, третьего, четвертого,
3277.08 3280.36 "Игорь Лабутин" не было четвертого, ну в смысле, фулл дотнет, 4.8,
3280.36 3283.68 "Игорь Лабутин" если она там нетстандарт таргетит, то там она, соответственно,
3283.68 3284.68 "Игорь Лабутин" просто обычная библиотека.
3284.68 3285.68 "Анатолий Кулаков" Почему нет?
3285.68 3288.28 "Анатолий Кулаков" Ну вынесли, вынесли атрибуты в отдельную сборку, которая
3288.28 3289.76 "Анатолий Кулаков" будет поддержана абсолютно всеми.
3289.76 3290.76 "Игорь Лабутин" Нет.
3290.76 3291.76 "Игорь Лабутин" Так нельзя.
3291.76 3294.32 "Игорь Лабутин" Делать два способа всего существует.
3294.32 3297.80 "Игорь Лабутин" Способ первый, соответственно, ifdef-ами атрибутики вырезаем
3297.80 3300.48 "Игорь Лабутин" аккуратно, вот, то есть все эти атрибутики вешаются
3300.48 3303.84 "Игорь Лабутин" на свои места, но они окружены аккуратненьким ifdef соответствующего
3303.84 3304.84 "Игорь Лабутин" таргета.
3304.84 3306.76 "Анатолий Кулаков" Это же не будет аккуратненько, это будет мегагрязь.
3306.76 3308.92 "Игорь Лабутин" Это будет грязненько, да.
3308.92 3311.80 "Игорь Лабутин" Второй вариант более красивый, ты эти же атрибуты просто
3311.80 3315.32 "Игорь Лабутин" дефайнишь в своей сборке, компилятор при сборке не
3315.32 3317.16 "Игорь Лабутин" смотрит, откуда эти атрибуты пришли.
3317.16 3320.12 "Игорь Лабутин" Ему главное важно, что он называется, там, system-compiler-services,
3320.12 3324.64 "Игорь Лабутин" что-то там, что-то там, dynamic-access-members.
3324.64 3327.36 "Игорь Лабутин" Заводишь такие атрибуты у себя в сборке прямо, компилятору
3327.36 3328.36 "Игорь Лабутин" этого достаточно.
3328.36 3330.64 "Анатолий Кулаков" Ну, вот я и говорю, вынесли бы в отдельную сборку,
3330.64 3333.00 "Анатолий Кулаков" называли бы Microsoft-атрибутицы и все, точно так бы всем
3333.00 3334.00 "Анатолий Кулаков" отдали.
3334.00 3335.44 "Анатолий Кулаков" Ну, ты делаешь у себя, короче, такое штуковое.
3335.44 3336.44 "Анатолий Кулаков" Или делаешь у себя.
3336.44 3337.44 "Игорь Лабутин" Вот.
3337.44 3338.44 "Игорь Лабутин" И тогда у тебя все получается красиво.
3338.44 3340.60 "Игорь Лабутин" Собственно, теперь нам возникает вопрос, ну, разметили
3340.60 3346.16 "Игорь Лабутин" мы свою сборку, свою библиотеку и поняли, что у нас, там,
3346.16 3349.76 "Игорь Лабутин" не знаю, 3/4 библиотеки требуют reflection и все такое прочее.
3349.76 3352.40 "Игорь Лабутин" Нужно предоставлять альтернативу в таком случае.
3352.40 3356.48 "Игорь Лабутин" И да, source-генераторы, где-то, может быть, интерсепторы,
3356.48 3359.64 "Игорь Лабутин" если вам нужна какая-то хитрая, значит, производительность,
3359.64 3361.64 "Игорь Лабутин" хотя, смотри, мы чуть дальше будем обсуждать интерсепторы,
3361.64 3362.64 "Игорь Лабутин" там все не так просто.
3362.64 3363.88 "Игорь Лабутин" Ну, это preview-фича.
3363.88 3368.80 "Игорь Лабутин" То есть вы желательно предоставьте альтернативы вашим методам
3368.80 3372.48 "Игорь Лабутин" в виде методов, которые native-outcompatible.
3372.48 3375.64 "Игорь Лабутин" Возможно, они будут неполноценны по фичам.
3375.64 3379.44 "Игорь Лабутин" То есть, например, я вам рассказывал уже много раз,
3379.44 3382.80 "Игорь Лабутин" что у нас есть, например, regex, у которых есть вариант
3382.80 3385.44 "Игорь Лабутин" вот стареньких наших обычных regex, которые, там, можем
3385.44 3388.56 "Игорь Лабутин" сказать, compiled, некомпайлд, но тем не менее, у нас есть
3388.56 3392.32 "Игорь Лабутин" source-генератор regex, и у нас есть теперь вот этот последний,
3392.32 3397.08 "Игорь Лабутин" как его там, директ, что-то там стоит, машин, забыл,
3397.08 3398.64 "Игорь Лабутин" короче, как называется, но смысл в том, что который
3398.64 3399.64 "Игорь Лабутин" однопроходный.
3399.64 3403.40 "Игорь Лабутин" И вот source-генераторная версия, она не полноценная
3403.40 3407.24 "Игорь Лабутин" замена, там есть некоторые вещи, которые не поддержаны.
3407.24 3410.56 "Игорь Лабутин" Но тем не менее, для, там, 99%, наверное, случаев, они
3410.56 3414.56 "Игорь Лабутин" работают прекрасно, и это отличный вариант для ваших
3414.56 3415.56 "Игорь Лабутин" пользователей.
3415.56 3419.32 "Игорь Лабутин" Поэтому, если можете, предоставьте альтернативные, не reflection-based
3419.32 3422.04 "Игорь Лабутин" или, там, out-friendly версии вашего кода.
3422.04 3427.28 "Игорь Лабутин" И для того, чтобы вас в этом поддержать, дальше у Майкрософта
3427.28 3430.44 "Игорь Лабутин" в этой статье, это, наверное, занимает 2/3 статьи, по-моему,
3430.44 3433.72 "Игорь Лабутин" по ощущениям, если не половину, точно, приведены прям примеры
3433.72 3436.76 "Игорь Лабутин" конкретные, примеры того, как разные библиотеки
3436.76 3442.20 "Игорь Лабутин" в .NET stack приводили себя в состояние native out-compatibility.
3442.20 3447.44 "Игорь Лабутин" И там примеры, ну, понятно, что там этого System Text JSON,
3447.44 3449.84 "Игорь Лабутин" но это не очень интересно, это внутренняя библиотека
3449.84 3450.84 "Игорь Лабутин" Майкрософта.
3450.84 3454.20 "Игорь Лабутин" Но там есть примеры, там, Aztec Exchange, Redis-клиент который,
3454.20 3457.36 "Игорь Лабутин" там есть примеры OpenTelemetry библиотеки, прям вот конкретно,
3457.36 3461.28 "Игорь Лабутин" чуть ли не с ссылками на конкретные дифы в GitHub,
3461.28 3463.40 "Игорь Лабутин" что нужно было сделать в библиотеке, какие изменения
3463.40 3465.88 "Игорь Лабутин" внести, какие атрибуты как расставить, почему
3465.88 3468.76 "Игорь Лабутин" и зачем, для того, чтобы он стал native out-compatible.
3468.76 3471.16 "Анатолий Кулаков" Ну, или, по крайней мере, ее часть.
3471.16 3473.92 "Анатолий Кулаков" Мне кажется, это, наверное, да, самая интересная часть,
3473.92 3476.16 "Анатолий Кулаков" это то, каким образом настоящие юзкейсы, которые у нас
3476.16 3479.12 "Анатолий Кулаков" на практике уже давно сложились, мы уже все знаем, там, как
3479.12 3482.12 "Анатолий Кулаков" Reflection это все сделать, вот как их перевести теперь,
3482.12 3485.08 "Анатолий Кулаков" не отчитывая native out-compatible, да, интересные-интересные
3485.08 3486.08 "Анатолий Кулаков" кейсы, надо посмотреть примеры.
3486.08 3487.40 "Игорь Лабутин" Да, вот нужно как бы, ну, там надо действительно
3487.40 3490.36 "Игорь Лабутин" вчитываться уже в код, да, я подумал сначала разобрать
3490.36 3492.52 "Игорь Лабутин" там один-два примера, но что-то там прямо, ну, надо
3492.52 3494.32 "Игорь Лабутин" действительно вчитаться, посмотреть, какой код был,
3494.32 3497.84 "Игорь Лабутин" да, а код читать вслух не очень благодарное дело.
3497.84 3501.04 "Игорь Лабутин" И последняя мысль в статье, она заключается в следующем,
3501.04 3503.28 "Игорь Лабутин" надо понимать, что есть библиотеки, которые никогда
3503.28 3506.04 "Игорь Лабутин" не будут native out-compatible, и это нормально.
3506.04 3509.64 "Игорь Лабутин" Ну, то есть, действительно, есть какие-то подходы, какие-то
3509.64 3512.36 "Игорь Лабутин" библиотеки, которые выполняют свою работу только с применением
3512.36 3516.04 "Игорь Лабутин" кода генерации в рантайме, и да, к сожалению, их невозможно
3516.04 3518.92 "Игорь Лабутин" сделать в native out-compatible, ну, такова судьба, это надо
3518.92 3522.00 "Игорь Лабутин" принять и либо придумать альтернативы, ну, либо просто
3522.00 3525.40 "Игорь Лабутин" так и использовать, не весь код обязан быть native out-compatible.
3525.40 3528.16 "Анатолий Кулаков" Слушай, я тоже так думал, но после того, как они выпустили
3528.16 3531.96 "Анатолий Кулаков" сервизатор и ISP net core в native out-compatible, я что-то уже
3531.96 3534.88 "Анатолий Кулаков" усомнился, а действительно ли такие ситуации есть?
3534.88 3537.80 "Игорь Лабутин" Ну, смотри, для того, чтобы выпустить ISP net core, который
3537.80 3542.52 "Игорь Лабутин" native out-compatible, пришлось заюзать в production в stable варианте
3542.52 3548.80 "Игорь Лабутин" экспериментал фичу, которая, блин, ну, такая, я про интерсепторы.
3548.80 3551.60 "Игорь Лабутин" Без них бы никакого native out-compatibility не было бы.
3551.60 3553.52 "Анатолий Кулаков" Ну, ладно, но сделали же.
3553.52 3557.32 "Игорь Лабутин" Ну, нет, сделали, но как-то оно всё пока такое, не знаю.
3557.32 3560.20 "Игорь Лабутин" Нет, понятно, что, наверное, действительно много чего
3560.20 3566.24 "Игорь Лабутин" можно сделать native out-compatible, не знаю, насколько это прям
3566.24 3567.24 "Игорь Лабутин" нужно.
3567.24 3569.36 "Игорь Лабутин" То есть, ну, опять же, надо понимать, ну, заотносить
3569.36 3572.64 "Игорь Лабутин" усилия, да, и пользу, чего ты и набиваешься, то есть
3572.64 3575.84 "Игорь Лабутин" ISP net core, ну, действительно, наверное, нужно, потому
3575.84 3579.72 "Игорь Лабутин" что, если ты пишешь, не знаю, странный, наверное, вариант,
3579.72 3584.96 "Игорь Лабутин" ну, например, serverless функции, да, с ISP net core внутри, ну,
3584.96 3587.64 "Игорь Лабутин" там, наверное, полезно, чтобы она быстро стартовала,
3587.64 3590.72 "Игорь Лабутин" а при этом у тебя полноценный ISP net core runtime, ну, в смысле,
3590.72 3592.44 "Игорь Лабутин" framework, да, для того, чтобы писать свои функции.
3592.44 3594.16 "Игорь Лабутин" Это, наверное, полезно.
3594.16 3596.52 "Игорь Лабутин" Насколько вообще любую библиотеку стоит так делать,
3596.52 3597.52 "Игорь Лабутин" я не знаю.
3597.52 3600.96 "Игорь Лабутин" Я пока свой код особо в native out никуда не гоню.
3600.96 3603.40 "Игорь Лабутин" Ну, посмотрим за трендами, посмотрим, куда всё это
3603.40 3605.80 "Игорь Лабутин" выльется, потому что, по сути, восьмёрка - это первая
3605.80 3607.84 "Игорь Лабутин" версия, где у нас появился полноценный такой native
3607.84 3611.48 "Игорь Лабутин" out, который плюс-минус широко поддержан, с учётом всех
3611.48 3614.56 "Игорь Лабутин" этих атрибутов, да, вордингов, компиляторов и всего остального.
3614.56 3615.56 "Игорь Лабутин" Так что будем смотреть.
3615.56 3620.24 "Анатолий Кулаков" Опять же, не забывай про blazer, про браузер, про webasm,
3620.24 3623.12 "Анатолий Кулаков" про мобилки, где native out, наверное, более актуален,
3623.12 3625.44 "Анатолий Кулаков" чем для наших серверных больших enviroments.
3625.44 3626.44 "Анатолий Кулаков" Да.
3626.44 3629.24 "Игорь Лабутин" Ну, и всякие command line тулы там простые тоже, может
3629.24 3632.60 "Игорь Лабутин" быть, или не очень простые, но тот же dot net, какой-нибудь
3632.60 3634.92 "Игорь Лабутин" билд, который просто за счёт того, что встанет native
3634.92 3637.00 "Игорь Лабутин" out, или, может быть, уже встал, кстати, и не смотрел native
3637.00 3640.16 "Игорь Лабутин" out, скомпилирован, он будет просто быстрее стартовать
3640.16 3642.04 "Игорь Лабутин" и более приятный экспириенс команд лайн.
3642.04 3645.96 "Анатолий Кулаков" Да, да, так и есть, ну, и в принципе, да, те же самые
3645.96 3647.56 "Анатолий Кулаков" клауды никуда не деваются.
3647.56 3649.48 "Анатолий Кулаков" Кстати, давай про клауды дальше тоже поговорим.
3649.48 3653.72 "Анатолий Кулаков" Есть интересная статейка про построение отказоустойчивых
3653.72 3654.72 "Анатолий Кулаков" приложений.
3654.72 3658.12 "Анатолий Кулаков" Тут, конечно, приговаривают про клауд, но, естественно,
3658.12 3659.84 "Анатолий Кулаков" отказоустойчивые приложения нужны не только в облаках,
3659.84 3662.08 "Анатолий Кулаков" они нужны всем нам, даже в локальной сети и так
3662.08 3663.08 "Анатолий Кулаков" далее.
3663.08 3666.40 "Анатолий Кулаков" И к чему же приурочено это событие?
3666.40 3668.96 "Анатолий Кулаков" Нет, давайте начнём более сначала, это вообще что
3668.96 3671.12 "Анатолий Кулаков" такое отказоустойчивые приложения.
3671.12 3673.80 "Анатолий Кулаков" Как вам всем известно, все наши приложения в большинстве
3673.80 3675.88 "Анатолий Кулаков" случаев в своём общаются по сети.
3675.88 3678.60 "Анатолий Кулаков" И в последнее время самым популярным протоколом
3678.60 3682.92 "Анатолий Кулаков" общения по сети у нас является HTTP в том или ином виде.
3682.92 3686.48 "Анатолий Кулаков" И когда программисты разрабатывают свои программы, они обычно
3686.48 3688.84 "Анатолий Кулаков" запускают или тестируют или пробуют свои программы
3688.84 3692.32 "Анатолий Кулаков" на локальном компьютере, который, может быть, связывается
3692.32 3695.28 "Анатолий Кулаков" сам с собой, то есть я имею в виду с localhost, или, может
3695.28 3698.40 "Анатолий Кулаков" быть, с базой данных, которая сидит на локальном компьютере,
3698.40 3700.76 "Анатолий Кулаков" и у программистов всё хорошо, никаких проблем они при
3700.76 3703.60 "Анатолий Кулаков" этом не испытывают, у них при этом сеть не падает,
3703.60 3706.88 "Анатолий Кулаков" работает мега быстро, и никаких там ДНС-имен не
3706.88 3708.76 "Анатолий Кулаков" теряется, и роуты никуда не пропадают.
3708.76 3712.24 "Анатолий Кулаков" В настоящем же мире всё абсолютно наоборот.
3712.24 3715.96 "Анатолий Кулаков" Сеть, она ненадёжна, у нас случаются как ошибки внутри
3715.96 3719.04 "Анатолий Кулаков" сети, у нас случаются ошибки оборудования, и не нужно
3719.04 3721.28 "Анатолий Кулаков" забывать вообще, что сам сервер, который там где-то
3721.28 3724.04 "Анатолий Кулаков" поднимается, у него тоже есть свойства иметь какие-то
3724.04 3727.16 "Анатолий Кулаков" ошибки, баги или, может быть, сверхнагруженность, в общем,
3727.16 3729.04 "Анатолий Кулаков" с ним тоже часто бывает что-то не так.
3729.04 3732.58 "Анатолий Кулаков" И поэтому все запросы, которые вы делаете, у них есть немаленький
3732.58 3734.96 "Анатолий Кулаков" шанс окончиться с ошибкой.
3734.96 3741.88 "Анатолий Кулаков" А если мы берём некий какой-то объёмный кластер взаимодействия
3741.88 3745.04 "Анатолий Кулаков" нескольких хостов, т.е. если у нас там много сервисов,
3745.04 3748.68 "Анатолий Кулаков" которые общаются друг с другом, то у нас может быть
3748.68 3751.68 "Анатолий Кулаков" вообще каскадная ошибка, т.е. когда у каждого сервиса
3751.68 3755.16 "Анатолий Кулаков" шанс отказа очень маленький, но для того, чтобы выполнить
3755.16 3757.80 "Анатолий Кулаков" вам запрос, вам таких сервисов нужно затронуть очень-очень
3757.80 3763.36 "Анатолий Кулаков" много, то все эти шансы, они очень некрасиво складываются.
3763.36 3766.84 "Анатолий Кулаков" И поэтому у каждого запроса уже шанс на ошибку получается
3766.84 3768.86 "Анатолий Кулаков" довольно-таки весомый.
3768.86 3771.36 "Анатолий Кулаков" Для того, чтобы каким-то образом избежать вот этих
3771.36 3775.20 "Анатолий Кулаков" проблем с сетью, с сервисами, с оборудованием, было придумано
3775.20 3779.60 "Анатолий Кулаков" множество различных стратегий, ухищрений, что можно такого
3779.60 3780.60 "Анатолий Кулаков" поделать.
3780.60 3783.32 "Анатолий Кулаков" Ну, в самом банальном случае, допустим, если у вас медленная
3783.32 3786.72 "Анатолий Кулаков" сеть, то можно увеличить тайм-аут, т.е. дольше подождать,
3786.72 3789.24 "Анатолий Кулаков" когда вам сервис ответит, это тоже нормально.
3789.24 3792.52 "Анатолий Кулаков" Или если у вас какая-то мимолетная ошибка в сети,
3792.52 3795.12 "Анатолий Кулаков" т.е. сеть моргнула, сервер вывалился, потом снова
3795.12 3798.36 "Анатолий Кулаков" оказался в строю, здесь вам легко поможет ретрай.
3798.36 3804.20 "Анатолий Кулаков" Т.е. повторная попытка послать ваш запрос еще раз, если
3804.20 3807.26 "Анатолий Кулаков" первая окончилась неудачей.
3807.26 3812.48 "Анатолий Кулаков" Если же вы видите, что сервис, например, высыпет вам ошибки
3812.48 3815.40 "Анатолий Кулаков" на все ваши ретрай, то здесь очень хорошая стратегия
3815.40 3818.28 "Анатолий Кулаков" есть типа "отстаньте от него, немножко подождите,
3818.28 3820.64 "Анатолий Кулаков" дайте ему возможность прийти в себя".
3820.64 3823.80 "Анатолий Кулаков" Все эти стратегии, их есть намного больше, их можно
3823.80 3826.10 "Анатолий Кулаков" применять индивидуально, в зависимости от того, если
3826.10 3828.12 "Анатолий Кулаков" вы знаете, что у вас вшей сети происходит.
3828.12 3830.84 "Анатолий Кулаков" Или же комбинировать вместе, выстраивать какие-то сложные
3830.84 3835.40 "Анатолий Кулаков" цепочки различных политик, пайплайнов и т.д.
3835.40 3841.20 "Анатолий Кулаков" И, к нашему счастью, в экосистеме Дотнета есть прекрасная
3841.20 3843.04 "Анатолий Кулаков" библиотека, которая называется Поли.
3843.04 3847.00 "Анатолий Кулаков" И Поли уже многие годы является стандартной библиотекой
3847.00 3850.16 "Анатолий Кулаков" для того, чтобы построить отказоустойчивую приложение.
3850.16 3853.12 "Анатолий Кулаков" И если вам вдруг это нужно, то первым делом вам нужно
3853.12 3856.68 "Анатолий Кулаков" смотреть именно на нее.
3856.68 3862.48 "Анатолий Кулаков" И вышла восьмая версия недавно, в сентябре, восьмая
3862.48 3867.96 "Анатолий Кулаков" версия этой библиотеки, Поли, которая заиспользовалась
3867.96 3869.88 "Анатолий Кулаков" непосредственно самим Микрософтом.
3869.88 3873.60 "Анатолий Кулаков" И Микрософт, он очень нечасто в своих сборках ссылается
3873.60 3874.60 "Анатолий Кулаков" на другие библиотеки.
3874.60 3876.56 "Анатолий Кулаков" Я могу вспомнить буквально по пальцам, там, может быть,
3876.56 3878.30 "Анатолий Кулаков" это Ньютон Софт Джессон был.
3878.30 3879.30 "Анатолий Кулаков" Вот.
3879.30 3882.40 "Анатолий Кулаков" И сейчас у нас на глазах рождается новая коллаборация,
3882.40 3884.40 "Анатолий Кулаков" это Микрософт и Поли.
3884.40 3888.76 "Анатолий Кулаков" Микрософт выпустил два пакета, Microsoft Extension Resilience
3888.76 3892.32 "Анатолий Кулаков" и Microsoft Extension HTTP Resilience.
3892.32 3896.16 "Анатолий Кулаков" Все обе эти библиотеки под капотом используют
3896.16 3899.20 "Анатолий Кулаков" новейшие изобретения восьмой версии из библиотеки
3899.20 3900.20 "Анатолий Кулаков" Поли.
3900.20 3905.60 "Анатолий Кулаков" В коде это все выражается в виде простых Extension методов,
3905.60 3909.84 "Анатолий Кулаков" которые помогают превратить ваш обычный HTTP Client, который
3909.84 3913.24 "Анатолий Кулаков" уже сегодня упоминался, в отказоустойчивый HTTP
3913.24 3914.24 "Анатолий Кулаков" Client.
3914.24 3917.08 "Анатолий Кулаков" Для этого вам достаточно у HTTP Client Builder вызвать метод
3917.08 3922.16 "Анатолий Кулаков" @StandardResilientHandler, который добавляет пачку стандартных
3922.16 3925.72 "Анатолий Кулаков" стратегий для того, чтобы ваши запросы теперь ходили
3925.72 3926.96 "Анатолий Кулаков" по сети более надежно.
3926.96 3933.80 "Анатолий Кулаков" В частности добавляются rate limiters, total timeout, retry policy,
3933.80 3937.08 "Анатолий Кулаков" circle breakers, timeout на конкретные запросы.
3937.08 3940.88 "Анатолий Кулаков" У вас, безусловно, есть возможность все эти самостоятельно
3940.88 3943.48 "Анатолий Кулаков" поднастроить и настроить, если вам вдруг не нравятся
3943.48 3946.48 "Анатолий Кулаков" те стандартные, которые добавляет сам Микрософт.
3946.48 3949.48 "Анатолий Кулаков" Или же, естественно, вы можете вообще свой кастомный
3949.48 3953.68 "Анатолий Кулаков" пайплайн сделать и с помощью метода @ResilientHandler и там
3953.68 3957.40 "Анатолий Кулаков" настроить абсолютно все с точностью каждого свойства,
3957.40 3961.04 "Анатолий Кулаков" все то, что умеет делать Polly, все это поднастраивать.
3961.04 3963.44 "Анатолий Кулаков" А как же Микрософт к этому пришел?
3963.44 3967.52 "Анатолий Кулаков" Вообще у Микрософта есть очень много различных сервисов,
3967.52 3971.04 "Анатолий Кулаков" тот же самый Azure, тот же самый Bing, тот же самый миллион
3971.04 3972.04 "Анатолий Кулаков" их.
3972.04 3976.24 "Анатолий Кулаков" И все эти сервисы обычно такие популярные и высоко
3976.24 3977.24 "Анатолий Кулаков" нагруженные.
3977.24 3979.94 "Анатолий Кулаков" И большинство из них под капотом используют именно
3979.94 3980.94 "Анатолий Кулаков" Polly.
3980.94 3984.28 "Анатолий Кулаков" И многие команды переизобретали различные стратегии, каким
3984.28 3988.34 "Анатолий Кулаков" образом им свои запросы сделать более отказоустойчивыми.
3988.34 3991.70 "Анатолий Кулаков" И вот постепенно все эти команды свои изобретения
3991.70 3996.32 "Анатолий Кулаков" сводили в одну кучку, в один какой-то набор утилит,
3996.32 3999.02 "Анатолий Кулаков" которые вокруг Polly настраивали различные пайплайны, как
3999.02 4000.02 "Анатолий Кулаков" себя стоит вести.
4000.02 4004.58 "Анатолий Кулаков" Например, они не только выдумывали стратегии, они
4004.58 4007.90 "Анатолий Кулаков" расширяли стандартную телеметрию из Polly для того, чтобы ее
4007.90 4010.42 "Анатолий Кулаков" можно было, например, в OpenTelemetry загнать и увидеть
4010.42 4012.46 "Анатолий Кулаков" какие-то более интересные корреляции.
4012.46 4017.18 "Анатолий Кулаков" Они начали интегрировать Polly с iServiceCollection, стандартным
4017.18 4021.42 "Анатолий Кулаков" dependency injection фреймворком из Microsoft.
4021.42 4023.74 "Анатолий Кулаков" Они начали его настраивать с помощью option-based нашей
4023.74 4024.74 "Анатолий Кулаков" конфигурации.
4024.74 4029.02 "Анатолий Кулаков" В общем, постепенно Polly обрастала такой инфраструктурой
4029.02 4031.72 "Анатолий Кулаков" Microsoft, создан стандартными интерфейсами, какими-то
4031.72 4035.38 "Анатолий Кулаков" стандартными договоренностями, и все это постепенно вылилось
4035.38 4039.30 "Анатолий Кулаков" в некую общую библиотеку, которой Microsoft решил открыть
4039.30 4041.74 "Анатолий Кулаков" сообществу и решил дать до нее доступ.
4041.74 4044.74 "Анатолий Кулаков" Но проблема была в том, что Microsoft там накрутил столько
4044.74 4048.58 "Анатолий Кулаков" всего, что для того, чтобы это все выглядело красиво
4048.58 4051.54 "Анатолий Кулаков" и элегантно вписывалось в текущую инфраструктуру,
4051.54 4055.14 "Анатолий Кулаков" необходимо было полностью переделать API Polly, потому
4055.14 4058.78 "Анатолий Кулаков" что API Polly изначально был такой более в сторонке стоящий,
4058.78 4062.10 "Анатолий Кулаков" меньше использовал вот этих всех возможных интеграций.
4062.10 4065.74 "Анатолий Кулаков" И вот восьмая версия как раз таки и является тем
4065.74 4070.58 "Анатолий Кулаков" релизом, который Microsoft вместе с сообществом переделал
4070.58 4072.82 "Анатолий Кулаков" вот те наработки, которые у него есть.
4072.82 4075.54 "Анатолий Кулаков" Плюс сам Polly там немножко изменился, например у него
4075.54 4079.40 "Анатолий Кулаков" выделился отдельный пакет PolyCore, который использует
4079.40 4083.94 "Анатолий Кулаков" стандартные и независимые ни от чего стратегии, и PolyExtensions,
4083.94 4088.02 "Анатолий Кулаков" который уже внедряет знания об OS Service Collections, о стандартных
4088.02 4091.92 "Анатолий Кулаков" .NET метриксах, в общем, уже какие-то у него там эндпойнты
4091.92 4093.62 "Анатолий Кулаков" и расширения для этих целей есть.
4093.62 4099.26 "Анатолий Кулаков" В общем, в результате вот этой коллаборации и родился
4099.26 4102.34 "Анатолий Кулаков" Poly версии восьмой и вот это пакеты с микрософтовскими
4102.34 4103.34 "Анатолий Кулаков" обвязками.
4103.34 4107.46 "Анатолий Кулаков" Как я уже говорил, что есть прям стандартные настройки,
4107.46 4108.46 "Анатолий Кулаков" что вы хотите сделать.
4108.46 4112.16 "Анатолий Кулаков" Например, для стандартного HTTP клиента добавляется
4112.16 4113.50 "Анатолий Кулаков" определенный pipeline.
4113.50 4118.46 "Анатолий Кулаков" В этом pipeline rate limiter, как я уже говорил, он ограничивает
4118.46 4121.82 "Анатолий Кулаков" вам максимальное количество реквестов, которые ваш
4121.82 4124.50 "Анатолий Кулаков" HTTP клиент может послать на сервер.
4124.50 4127.74 "Анатолий Кулаков" Это нужно для того, чтобы сервер не завалить каким-то
4127.74 4131.02 "Анатолий Кулаков" флудом или каким-то количеством однотипных бесполезных
4131.02 4133.26 "Анатолий Кулаков" запросов, которые просто приведут его в негодность
4133.26 4134.26 "Анатолий Кулаков" и все.
4134.26 4138.62 "Анатолий Кулаков" Также есть тайм-аут на общее время, которое исполняется
4138.62 4144.74 "Анатолий Кулаков" ваш запрос, включая то время, на которое идут retry policy.
4144.74 4146.74 "Анатолий Кулаков" То есть, если вы там ретрайлись несколько раз, все это
4146.74 4150.10 "Анатолий Кулаков" входит в этот тайм-аут, чтобы в конце концов рано
4150.10 4152.30 "Анатолий Кулаков" или поздно этот запрос закончился, и ваш клиент
4152.30 4153.66 "Анатолий Кулаков" не висел вечно.
4153.66 4156.98 "Анатолий Кулаков" Естественно, входит retry policy, которое помогает вам
4156.98 4161.94 "Анатолий Кулаков" добиться работоспособности при каких-то мелких, кратковременных
4161.94 4165.50 "Анатолий Кулаков" ошибках или если, допустим, ваша зависимость слишком
4165.50 4166.50 "Анатолий Кулаков" слабая.
4166.50 4168.90 "Анатолий Кулаков" В общем, retry policy здесь тоже может помочь.
4168.90 4173.90 "Анатолий Кулаков" Circle breaker, то есть он прерывает выполнение, если видит,
4173.90 4177.26 "Анатолий Кулаков" что серверу совсем плохо, если от сервера летит слишком
4177.26 4181.38 "Анатолий Кулаков" много ошибок, если от сервера летит слишком много тайм-аутов,
4181.38 4186.06 "Анатолий Кулаков" то breaker немножко на какое-то время прекращает насиловать
4186.06 4188.02 "Анатолий Кулаков" сервис и дает ему время отдышаться и после этого
4188.02 4189.02 "Анатолий Кулаков" пробует еще.
4189.02 4191.70 "Анатолий Кулаков" В зависимости от результата, там тоже что-то может быть.
4191.70 4198.02 "Анатолий Кулаков" И также этот стандартный пайплайн навешивает индивидуальные
4198.02 4200.66 "Анатолий Кулаков" тайм-ауты на каждый конкретный запрос.
4200.66 4203.94 "Анатолий Кулаков" Также появился еще интересный пайплайн, который называется
4203.94 4204.94 "Анатолий Кулаков" пайплайн-хеджирование.
4204.94 4209.94 "Анатолий Кулаков" Это специальная стратегия, которая помогает вам уменьшить
4209.94 4215.04 "Анатолий Кулаков" latency запроса путем того, что посылает запрос сразу
4215.04 4216.04 "Анатолий Кулаков" на несколько сервисов.
4216.04 4219.62 "Анатолий Кулаков" То есть, допустим, если у вас есть 10 серверов, каждый
4219.62 4222.50 "Анатолий Кулаков" из этих 10 серверов способен дать вам правильный легальный
4222.50 4225.10 "Анатолий Кулаков" ответ, но, допустим, вы не знаете, кто из них насколько
4225.10 4226.10 "Анатолий Кулаков" нагружен.
4226.10 4228.94 "Анатолий Кулаков" А ответ вам нужно получить максимально быстро, пользователь
4228.94 4229.94 "Анатолий Кулаков" супер ждет.
4229.94 4232.82 "Анатолий Кулаков" И куда посылать - непонятно.
4232.82 4234.66 "Анатолий Кулаков" Обычный раундробин в этом случае не помогает.
4234.66 4235.66 "Анатолий Кулаков" Очень просто.
4235.66 4238.06 "Анатолий Кулаков" Посылаете на всех, или на какое-то большее количество,
4238.06 4240.50 "Анатолий Кулаков" и тот ответ, который придет первым, от какого сервиса
4240.50 4242.50 "Анатолий Кулаков" придет первым, тот и забираете.
4242.50 4244.02 "Анатолий Кулаков" Все остальные просто теряются.
4244.02 4248.30 "Анатолий Кулаков" Да, ресурсов тратится намного больше, но есть такие ситуации,
4248.30 4251.86 "Анатолий Кулаков" где это абсолютно неважно, где уменьшить latency намного
4251.86 4254.06 "Анатолий Кулаков" важнее, чем то, сколько ресурсов мы потратим.
4254.06 4256.90 "Анатолий Кулаков" И вот здесь хеджированный пайплайн, хеджированная
4256.90 4258.98 "Анатолий Кулаков" стратегия, она очень хорошо работает.
4258.98 4260.94 "Анатолий Кулаков" При том здесь есть очень много интересных настроек,
4260.94 4264.42 "Анатолий Кулаков" то есть что такое, что можно считать, например, одним
4264.42 4265.42 "Анатолий Кулаков" сервисом.
4265.42 4267.26 "Анатолий Кулаков" Эти сервисы, например, можно объединить в некие группы.
4267.26 4270.14 "Анатолий Кулаков" У каждой этой группы установить ее собственный вес, то
4270.14 4272.74 "Анатолий Кулаков" есть с каким приоритетом туда можно исполнять запрос.
4272.74 4275.70 "Анатолий Кулаков" Например, на первые три группы можно бросать первые
4275.70 4278.86 "Анатолий Кулаков" там 10 миллисекунд, если там через 50 миллисекунд
4278.86 4281.74 "Анатолий Кулаков" ответ не вернулся, бросить на третьи 4 группы и так
4281.74 4282.74 "Анатолий Кулаков" далее.
4282.74 4285.82 "Анатолий Кулаков" В общем, этот алгоритм можно довольно гибко конфигурировать.
4285.82 4290.62 "Анатолий Кулаков" Вот, это как бы два стандартных пайплайна, то есть хеджированный
4290.62 4291.62 "Анатолий Кулаков" и обычный.
4291.62 4293.94 "Анатолий Кулаков" В общем, там есть еще другие пайплайны, можно настроить
4293.94 4296.22 "Анатолий Кулаков" свои собственные пайплайны, как я уже говорил, и все
4296.22 4298.90 "Анатолий Кулаков" вот эти настройки, все вот эти гибкости помогают вам
4298.90 4301.14 "Анатолий Кулаков" сделать ваше приложение более отказоустойчивым.
4301.14 4304.46 "Анатолий Кулаков" В данном случае, вот как раз конкретно клиенты.
4304.46 4306.54 "Анатолий Кулаков" Стратегий этих существует огромное количество.
4306.54 4309.26 "Анатолий Кулаков" У них, у всех, у каждой там огромное количество
4309.26 4312.10 "Анатолий Кулаков" настроек, специальные какие-то интересные алгоритмы, куча
4312.10 4313.62 "Анатолий Кулаков" тайм-аутов, куча крутилок.
4313.62 4316.62 "Анатолий Кулаков" В общем, все это детально описано на сайте Poly в его
4316.62 4317.94 "Анатолий Кулаков" прекрасной документации.
4317.94 4320.42 "Анатолий Кулаков" В общем, если вам тема интересна, то обязательно ознакомьтесь
4320.42 4324.02 "Анатолий Кулаков" и с этим инструментом, и с документацией Poly, и используйте
4324.02 4326.46 "Анатолий Кулаков" в своих приложениях, если вам вдруг действительно
4326.46 4330.98 "Анатолий Кулаков" нужна такая отказоустойчивость жесткая в современных сетях.
4330.98 4339.02 "Игорь Лабутин" Вообще, мне, как это, меня удивило, что здесь Microsoft,
4339.02 4341.98 "Игорь Лабутин" одно из немногих примеров, когда Microsoft пошла и по сути
4341.98 4344.66 "Игорь Лабутин" законтрибьютила в том или ином виде в стороннюю какую-то
4344.66 4350.26 "Игорь Лабутин" библиотеку, не постигли для Poly участь тех самых,
4350.26 4351.26 "Игорь Лабутин" кто там был-то.
4351.26 4353.82 "Игорь Лабутин" А, ну, Newtonsoft, да, которые долго-долго использовали
4353.82 4357.10 "Игорь Лабутин" внутри, потом сказали, а нет, будем писать свой,
4357.10 4358.10 "Игорь Лабутин" ну и прочих таких.
4358.10 4359.10 "Игорь Лабутин" Интересно.
4359.10 4361.02 "Игорь Лабутин" Хотя я так понимаю, что все-таки они затащили именно
4361.02 4365.02 "Игорь Лабутин" экстенджены, главное, то есть как бы не хочешь – не
4365.02 4366.02 "Анатолий Кулаков" используй.
4366.02 4368.34 "Анатолий Кулаков" Не только, видишь, экстенджены они в своих пакетах как
4368.34 4372.54 "Анатолий Кулаков" бы оставили, а вот их контрибьют, возвращаясь к твоей фразе,
4372.54 4374.70 "Анатолий Кулаков" да, их контрибьют заключался в том, что они пришли как
4374.70 4377.30 "Анатолий Кулаков" сон в посудной лавке и все переделали, они полностью
4377.30 4381.82 "Анатолий Кулаков" изменили API, они там полностью что-то с ментейнерами терли
4381.82 4384.80 "Анатолий Кулаков" там один к одному, то есть это больше похоже на какой-то
4384.80 4387.26 "Анатолий Кулаков" рейдерский захват, чем на какой-то контрибьют в
4387.26 4388.26 "Анатолий Кулаков" open-source проект.
4388.26 4389.26 "Игорь Лабутин" Ну, тем не менее, все-таки.
4389.26 4391.34 "Анатолий Кулаков" Никто другой так бы не смог бы прийти, кроме Майкрософта.
4391.34 4394.34 "Игорь Лабутин" Все-таки они оставили ее пока внешне, ну и я так
4394.34 4397.06 "Игорь Лабутин" понимаю, что на нее именно не ссылаются, да, в смысле
4397.06 4399.58 "Игорь Лабутин" что в отличие от Newtonsoft, который прям был using вот
4399.58 4403.50 "Игорь Лабутин" прям в Core, на MySQL на Core, здесь такого нету, то есть это
4403.50 4406.86 "Игорь Лабутин" все-таки как бы только в экстендженах, ну, в общем,
4406.86 4407.86 "Игорь Лабутин" понятно?
4407.86 4408.86 "Игорь Лабутин" Да, конечно, конечно.
4408.86 4409.86 "Игорь Лабутин" Посмотрим, как будет развиваться, но штука интересная, по
4409.86 4411.38 "Игорь Лабутин" крайней мере, удобно, что действительно можно просто
4411.38 4417.06 "Игорь Лабутин" написать там addStandardResilience, и оно все само по сути работает.
4417.06 4419.50 "Анатолий Кулаков" Действительно, потому что тут надо включать как бы
4419.50 4421.98 "Анатолий Кулаков" голову и думать, а что там может быть, а какие таймауты
4421.98 4424.86 "Анатолий Кулаков" выставлять, а что если их не выставить, а какие retry
4424.86 4426.82 "Анатолий Кулаков" должны быть, в общем, это слишком много вопросов
4426.82 4429.42 "Анатолий Кулаков" нужно отвечать, в общем, один метод, как бы сделай
4429.42 4432.34 "Анатолий Кулаков" мне хорошо, он всегда приятнее, а если вдруг тебе чем-то
4432.34 4434.82 "Анатолий Кулаков" это на практике не поможет, вот тогда уже иди дать у
4434.82 4435.82 "Игорь Лабутин" него.
4435.82 4437.18 "Игорь Лабутин" А какие-то разумные дефолты, да?
4437.18 4439.50 "Анатолий Кулаков" Да-да, там дефолты вполне нормальные, вполне можно
4439.50 4440.90 "Анатолий Кулаков" использовать обычным приложением.
4440.90 4441.90 "Игорь Лабутин" Прикольно, прикольно.
4441.90 4445.70 "Игорь Лабутин" Ну, просто понятно, что я там допускаю, что разумный
4445.70 4450.14 "Игорь Лабутин" дефолт по retry, окей, разумный дефолт по circuit breaker, может
4450.14 4454.42 "Игорь Лабутин" быть, окей, но не знаю, там по таймаутам, ну фиг знает.
4454.42 4456.70 "Игорь Лабутин" Типа или мы считаем в среднем, что любой сервис должен
4456.70 4459.42 "Игорь Лабутин" отвечать, не знаю, за 500 миллисекунд хотя бы, если
4459.42 4462.26 "Игорь Лабутин" мой сервис такой специфичный, он думает, не знаю, полторы
4462.26 4464.46 "Игорь Лабутин" минуты, ну тогда придется настроить руками.
4464.46 4467.50 "Игорь Лабутин" Да, конечно, тогда ты уже настраиваешь под себя.
4467.50 4468.50 "Игорь Лабутин" Ну ладно.
4468.50 4469.50 "Игорь Лабутин" Тут уж тебе никто не поможет.
4469.50 4474.32 "Игорь Лабутин" Либо переписать сервис, да, Майкрософтом желательно.
4474.32 4475.32 "Игорь Лабутин" Ладно, давай.
4475.32 4476.32 "Игорь Лабутин" Под найти ваут.
4476.32 4479.82 "Игорь Лабутин" Ну, это уж как пойдет, в зависимости от сервиса.
4479.82 4480.82 "Игорь Лабутин" Давай пойдем дальше.
4480.82 4484.58 "Игорь Лабутин" Дальше у нас статья от Андрю Лока, одна из немногих
4484.58 4488.18 "Игорь Лабутин" статей, где у него ничего не получилось, он пытался,
4488.18 4489.18 "Игорь Лабутин" но у него ничего не получилось.
4489.18 4490.18 "Анатолий Кулаков" В чём история?
4490.18 4492.70 "Анатолий Кулаков" Ну парень уже не молодой, когда-то это должно было
4492.70 4493.70 "Анатолий Кулаков" начаться.
4493.70 4497.30 "Игорь Лабутин" Ну и Дотнет уже тоже не молодой, видимо, непонятно, у кого
4497.30 4498.30 "Игорь Лабутин" первым началось.
4498.30 4502.30 "Игорь Лабутин" Тем не менее, короче, есть у Андрю Лока есть библиотечка,
4502.30 4505.88 "Игорь Лабутин" ну GetPackage, называется EnumExtensions, которая решает следующую
4505.88 4506.88 "Игорь Лабутин" проблему.
4506.88 4509.30 "Игорь Лабутин" Вообще в Дотнете, если вы вдруг не знали, у Enum есть
4509.30 4512.18 "Игорь Лабутин" всякие разные методы, ну понятно, что это ToString, как
4512.18 4514.46 "Игорь Лабутин" у любого объекта, и есть специфические методы
4514.46 4519.62 "Игорь Лабутин" типа TryPars, GetValues, GetNames, которые позволяют вам получить
4519.62 4523.46 "Игорь Лабутин" собственно текстовые значения Enum, ну либо набор его значений,
4523.46 4527.02 "Игорь Лабутин" набор имён этих самых значений, ToString, он там умный, он умеет
4527.02 4531.10 "Игорь Лабутин" правильно выводить значения Enum в строчку, но они все
4531.10 4532.10 "Игорь Лабутин" жутко медленные.
4532.10 4534.58 "Игорь Лабутин" И как правило, если вам действительно нужна такая
4534.58 4536.86 "Игорь Лабутин" функциональность, то стандартной рекомендацией было пишите
4536.86 4539.94 "Игорь Лабутин" свои экстенджин методы в словарике там, либо пишите
4539.94 4543.14 "Игорь Лабутин" в обычной свечке, если вы просто предпосчитаете
4543.14 4545.90 "Игорь Лабутин" всё это каким-нибудь статическим методом, сохраните в статическое
4545.90 4550.42 "Игорь Лабутин" поле и используйте его, лукап, короче, в словаре
4550.42 4554.14 "Игорь Лабутин" быстрее, чем будет вам вот этот вот стандартный
4554.14 4557.10 "Игорь Лабутин" reflection-based методы из Enum.
4557.10 4560.42 "Игорь Лабутин" И Эндрю Лоук собственно имел вот эту замечательную
4560.42 4564.34 "Игорь Лабутин" библиотечку, которая делала следующее — вы вешаете
4564.34 4568.50 "Игорь Лабутин" на Enum атрибутик, и вам автоматически с URL-генератором генерятся
4568.50 4569.50 "Игорь Лабутин" эти экстенджин методы.
4569.50 4573.90 "Игорь Лабутин" То есть работает, в чём плюс?
4573.90 4576.22 "Игорь Лабутин" Вам не нужно помнить, что эти методы нужно обновить,
4576.22 4578.18 "Игорь Лабутин" то есть если, например, вы написали эти экстенджин
4578.18 4580.86 "Игорь Лабутин" методы через switch.js, то добавляя новое значение в Enum, ну
4580.86 4583.14 "Игорь Лабутин" легко забыть, сходить и там поменять тоже, вывод
4583.14 4585.70 "Игорь Лабутин" там какого-нибудь nameof, да, если вы toString пишете.
4585.70 4588.30 "Игорь Лабутин" А с URL-генератором такой проблемы нет, он естественно
4588.30 4590.62 "Игорь Лабутин" при следующей компиляции посмотрит на Enum и сгенерирует
4590.62 4592.02 "Игорь Лабутин" собственно тело метода заново.
4592.02 4594.74 "Игорь Лабутин" Всё хорошо, всё замечательно, отлично работает, быстро
4594.74 4597.16 "Игорь Лабутин" всё замечательно, кроме одной проблемы — надо не
4597.16 4599.38 "Игорь Лабутин" забывать, что теперь нельзя использовать toString, нужно
4599.38 4601.90 "Игорь Лабутин" использовать специальную функцию toString.fast, которая
4601.90 4603.78 "Игорь Лабутин" собственно генерируется с URL-генератором, это экстенджин
4603.78 4604.78 "Игорь Лабутин" метод, но тем не менее.
4604.78 4611.42 "Игорь Лабутин" И Эндрю подумал, логично, что мы генерируем новые
4611.42 4614.66 "Игорь Лабутин" методы, хорошо, и нам осталось решить одну единственную
4614.66 4618.22 "Игорь Лабутин" проблему, как бы так, пользователю дать возможность не забыть
4618.22 4620.54 "Игорь Лабутин" использовать новые методы, ну и конечно же мы можем
4620.54 4622.94 "Игорь Лабутин" взять интерсепторы, то есть если мы видим где-то в коде
4622.94 4626.86 "Игорь Лабутин" вызов .toString, то мы можем его заинтерсептить на вызов
4626.86 4628.42 "Игорь Лабутин" нашего метода toString.fast.
4628.42 4631.34 "Анатолий Кулаков" То есть анализаторы для лохов, да, вот анализаторы,
4631.34 4633.46 "Анатолий Кулаков" если бы тебе подсказали, было бы всё хорошо, а тут
4633.46 4634.46 "Анатолий Кулаков" он пошёл выпендриваться.
4634.46 4636.52 "Игорь Лабутин" Может быть у него даже есть анализатор, я не знаю,
4636.52 4639.06 "Игорь Лабутин" но типа да, пошёл выпендриваться.
4639.06 4642.82 "Игорь Лабутин" И как, напомню, работают интерсепторы, вы пишете
4642.82 4647.10 "Игорь Лабутин" метод, который имеет точно такую же сигнатуру, как
4647.10 4649.86 "Игорь Лабутин" соответственно тот, который вы собираетесь подменить,
4649.86 4654.70 "Игорь Лабутин" и вы на него навешиваете специальный атрибут interceptLocation,
4654.70 4657.66 "Игорь Лабутин" указываете там имя файлика, номер строчки, смещение
4657.66 4661.18 "Игорь Лабутин" в строчки, и если всё хорошо, то ваш метод будет вызываться
4661.18 4664.78 "Игорь Лабутин" вместо метода того, который нам написан.
4664.78 4668.70 "Игорь Лабутин" Он сделал простой вариант, собственно, написал метод
4668.70 4674.02 "Игорь Лабутин" toString, у которого сделал первым параметром это
4674.02 4679.50 "Игорь Лабутин" this с типом того enum, у которого он переопределил toString,
4679.50 4682.34 "Игорь Лабутин" ну в смысле для которого он писал его свой toString.
4682.34 4685.66 "Игорь Лабутин" Казалось бы, всё хорошо, сигнатура совпадает, всё
4685.66 4690.14 "Игорь Лабутин" замечательно, всё круто, но нет, не работает, потому
4690.14 4695.90 "Игорь Лабутин" что он компилятор, компилятор ему, честно говорит, дорогой.
4695.90 4699.78 "Игорь Лабутин" На самом деле, когда мы вызываем на любом enum метод
4699.78 4703.42 "Игорь Лабутин" toString, мы не вызываем метод toString, у которого первый
4703.42 4707.68 "Игорь Лабутин" аргумент это this и тип этого enum, на самом деле мы вызываем
4707.68 4710.34 "Игорь Лабутин" специальный extension метод, у которого первый аргумент
4710.34 4714.86 "Игорь Лабутин" это тип system.enum, потому что reflection на самом деле глубоко
4714.86 4715.86 "Игорь Лабутин" плевать.
4715.86 4720.78 "Игорь Лабутин" Туда передал ты enum, не знаю, цвета, enum форм, enum кого-то
4720.78 4723.64 "Игорь Лабутин" ещё, ему всё равно надо reflection просто обойти нужные поля
4723.64 4725.02 "Игорь Лабутин" и тебе всё сгенерить.
4725.02 4731.18 "Игорь Лабутин" Эндрю такой, окей, ну расспросит enum this, давай передадим enum
4731.18 4732.18 "Игорь Лабутин" this.
4732.18 4735.98 "Игорь Лабутин" Выглядит, конечно, как-то кривато, но расспросит
4735.98 4737.42 "Игорь Лабутин" компилятор, давай.
4737.42 4740.34 "Игорь Лабутин" И надо сказать, что после такой замены код компилируется.
4740.34 4743.86 "Игорь Лабутин" Но тут как раз возникает та самая штука, почему
4743.86 4746.62 "Игорь Лабутин" интерсепторы всё ещё preview-фича.
4746.62 4752.82 "Игорь Лабутин" Ты компилируемый код запускаешь и тебе говорят, извини,
4752.82 4757.70 "Игорь Лабутин" exception system_invalid_program_exception, потому что CLR detected an invalid
4757.70 4758.70 "Игорь Лабутин" program.
4758.70 4762.14 "Игорь Лабутин" И надо сказать, обычно такой exception ты видишь, когда
4762.14 4765.62 "Игорь Лабутин" ты или как-то руками пытаешься генерить и там что-нибудь
4765.62 4768.90 "Игорь Лабутин" напутал со всякими конвенционными вызовами, там аргументы
4768.90 4771.06 "Игорь Лабутин" со стэка не снял или не доложил аргументов на
4771.06 4772.06 "Игорь Лабутин" стэк, вот это всё.
4772.06 4775.14 "Игорь Лабутин" А тут тебе, казалось бы, использовалось только
4775.14 4778.42 "Игорь Лабутин" языковые фичи, а вот на тебе invalid_program_exception.
4778.42 4784.44 "Игорь Лабутин" Ну и выяснилось, что делается следующее, когда мы вызываем
4784.44 4790.10 "Игорь Лабутин" вот этот самый extension метод в интерсепторе, то ill-код
4790.10 4791.86 "Игорь Лабутин" действительно генерится правильно, в смысле что
4791.86 4794.62 "Игорь Лабутин" он вызывает действительно нужный extension метод, но,
4794.62 4797.86 "Игорь Лабутин" к сожалению, он туда передаёт аргументы из изыс, как
4797.86 4798.86 "Игорь Лабутин" он есть.
4798.86 4801.68 "Игорь Лабутин" И у тебя получается, что с точки зрения ill-кода тебе
4801.68 4805.22 "Игорь Лабутин" нужно взять переменную типа color в его примере и
4805.22 4808.30 "Игорь Лабутин" положить в аргумент функции, где у тебя тип перемен - это
4808.30 4809.30 "Игорь Лабутин" system.enum.
4809.30 4813.26 "Игорь Лабутин" И несмотря на то, что color наследуется неявно от
4813.26 4816.14 "Игорь Лабутин" system.enum, а, как мы помним, каждый enum он неявно наследует
4816.14 4821.46 "Игорь Лабутин" system.enum в дотнете, это преобразование невалидно в ill-е, там нужно
4821.46 4822.56 "Игорь Лабутин" писать честную конвертацию.
4822.56 4827.22 "Игорь Лабутин" И команда рослина сказала, да, это баг императора,
4827.22 4831.88 "Игорь Лабутин" сорян, но типа в релизном 2008-м, правда, в превью фича,
4831.88 4834.58 "Игорь Лабутин" у нас есть баг императора, sorry, на тустрингах и enum-ах
4834.58 4836.16 "Игорь Лабутин" это работать не будет.
4836.16 4838.08 "Игорь Лабутин" Ты выбрал самый очевидный пример для интерсептора,
4838.08 4839.32 "Игорь Лабутин" и он конкретно не работает.
4839.32 4843.92 "Игорь Лабутин" Sorry, Andrew, мы будем что-нибудь с этим делать.
4843.92 4846.40 "Игорь Лабутин" Вот такая вот печальная история, баг действительно
4846.40 4850.08 "Игорь Лабутин" есть, сейчас он находится в состоянии, что Jared Parsons,
4850.08 4853.84 "Игорь Лабутин" это лид императора, попросил кого-то из императорщиков
4853.84 4859.68 "Игорь Лабутин" посмотреть вообще на это, вот это вот состояние,
4859.68 4861.88 "Игорь Лабутин" по состоянию час до записи подкаста, ничего нового
4861.88 4863.08 "Игорь Лабутин" с тех пор там не произошло.
4863.08 4867.44 "Игорь Лабутин" Будем ждать, интересно, во что это выльется.
4867.44 4873.56 "Анатолий Кулаков" Специально выпустят патч для андрелока, скажут вот,
4873.56 4875.32 "Анатолий Кулаков" к превью фичам, смотрите.
4875.32 4876.32 "Игорь Лабутин" Да-да-да.
4876.32 4877.84 "Игорь Лабутин" Ну нет, на самом деле действительно могут это сделать, потому
4877.84 4880.52 "Игорь Лабутин" что патчи на компилятор выходят, в том числе в каком-нибудь
4880.52 4885.64 "Игорь Лабутин" следующем студии 17.8 что-нибудь, ну либо в SDK, соответственно,
4885.64 4887.92 "Игорь Лабутин" там же регулярно security патчи выходят, могут и выпустить
4887.92 4890.32 "Игорь Лабутин" обновление компилятора, если поймут, как это фиксить,
4890.32 4894.08 "Игорь Лабутин" там тоже как бы не очевидно, насколько это там легко-нелегко,
4894.08 4895.08 "Игорь Лабутин" фиг его знает.
4895.08 4898.48 "Игорь Лабутин" Это же надо, если выясняется, что у тебя с одной стороны
4898.48 4902.60 "Игорь Лабутин" Roslyn хочет там один тип, а при наивной генерации
4902.60 4906.56 "Игорь Лабутин" или кода у тебя нарушается поведение программы, ну
4906.56 4908.76 "Игорь Лабутин" в смысле ты генеришь некорректную программу с точки зрения
4908.76 4911.00 "Игорь Лабутин" ль-кода, то может быть там все будет гораздо более
4911.00 4913.48 "Игорь Лабутин" сложнее фиксить, тебе надо будет увязывать две стадии
4913.48 4915.32 "Игорь Лабутин" компилятора, то есть либо чтобы исходная стадия не
4915.32 4919.44 "Игорь Лабутин" ругалась и понимала, что в GT, в смысле в ль-коде все
4919.44 4924.08 "Игорь Лабутин" само конвертнется как надо, либо наоборот, стадия генерации
4924.08 4928.32 "Игорь Лабутин" ль-кода понимала, что на самом деле там попросили,
4928.32 4930.04 "Игорь Лабутин" и поэтому надо заимитить дополнительную инструкцию
4930.04 4931.04 "Игорь Лабутин" конвертации.
4931.04 4935.64 "Игорь Лабутин" Короче, веселая жизнь у компиляторщиков, посмотрим,
4935.64 4936.64 "Игорь Лабутин" как справится.
4936.64 4940.28 "Анатолий Кулаков" Да-да, тем веселее за ними наблюдать, а пока не вопендривайтесь
4940.28 4941.80 "Анатолий Кулаков" и пишите анализаторы.
4941.80 4943.28 "Анатолий Кулаков" Они работают всегда и хорошо.
4943.28 4944.28 "Игорь Лабутин" Да.
4944.28 4949.96 "Анатолий Кулаков" Ну что, давай посмотрим, у нас тут еще вышел до вече
4949.96 4954.28 "Анатолий Кулаков" интересный отчет, State of Developer Ecosystem 2023.
4954.28 4957.24 "Анатолий Кулаков" О, регулярная штука, да, от JetBrains, да ведь?
4957.24 4960.56 "Анатолий Кулаков" Да, ежегодный отчет от JetBrains, который показывает
4960.56 4965.08 "Анатолий Кулаков" о том, как те, кто пользуется JetBrains, любители приходить
4965.08 4969.44 "Анатолий Кулаков" на сайт JetBrains, как они используют инструменты, языки, сколько
4969.44 4971.88 "Анатолий Кулаков" им лет, сколько они получают зарплату, где они живут
4971.88 4974.24 "Анатолий Кулаков" и прочее-прочее, много интересных вещей.
4974.24 4978.92 "Анатолий Кулаков" В общем, если вы хотите узнать больше и разнообразнее,
4978.92 4982.08 "Анатолий Кулаков" то я вас приглашаю на сайт компании, а мы же коснемся
4982.08 4985.76 "Анатолий Кулаков" только тех аспектов, которые включают в себя .NET, C# и вот
4985.76 4987.24 "Анатолий Кулаков" все, что ежесниме связано.
4987.24 4988.24 "Анатолий Кулаков" Давай.
4988.24 4989.92 "Анатолий Кулаков" Да, давайте посмотрим.
4989.92 4993.44 "Анатолий Кулаков" Опять же, еще раз хочу напомнить, что это как бы не отражение
4993.44 4996.60 "Анатолий Кулаков" мира, это отражение вот тех респондентов, которых
4996.60 4997.88 "Анатолий Кулаков" JetBrains каким-то образом достало.
4997.88 5001.28 "Анатолий Кулаков" Ну, точно так же, как и отчеты Stack Overflow и прочие другие
5001.28 5002.28 "Анатолий Кулаков" отчеты.
5002.28 5005.76 "Анатолий Кулаков" Но обычно это как-то коррелирует с тем, что происходит в
5005.76 5009.76 "Анатолий Кулаков" мире, поэтому за не менеем лучшим рассматриваем, что
5009.76 5010.76 "Анатолий Кулаков" есть.
5010.76 5011.76 "Анатолий Кулаков" Начнем немножко с общего.
5011.76 5013.96 "Анатолий Кулаков" Во-первых, где C# находится в экосистеме вообще всех
5013.96 5014.96 "Анатолий Кулаков" языков.
5014.96 5018.32 "Анатолий Кулаков" На вопрос, какие языки вы использовали последние
5018.32 5020.08 "Анатолий Кулаков" 12 месяцев.
5020.08 5026.28 "Анатолий Кулаков" 61% ответила JavaScript, и по убыванию идут Python, HTML, CSS,
5026.28 5028.36 "Анатолий Кулаков" ну там языки разметки тоже были в вопросах.
5028.36 5033.32 "Анатолий Кулаков" Тут другое интересно, что JavaScript у нас 61%, ну по сути,
5033.32 5037.24 "Анатолий Кулаков" кто использовал JavaScript, а вот HTML и CSS касались 52%,
5037.24 5040.64 "Анатолий Кулаков" т.е. у нас JavaScript уже не касаются HTML и CSS.
5040.64 5044.60 "Игорь Лабутин" Ну как, 9% бэкендеров на ноде, там тебе не нужно
5044.60 5046.84 "Игорь Лабутин" HTML и CSS, наверное.
5046.84 5048.72 "Анатолий Кулаков" Бэкендеров на ноде?
5048.72 5049.72 "Анатолий Кулаков" Да.
5049.72 5050.72 "Анатолий Кулаков" Хорошо.
5050.72 5059.00 "Анатолий Кулаков" Ну и где-то там далеко-далеко с 21% идет C#, и 4% сказали,
5059.00 5061.28 "Анатолий Кулаков" что они планируют его еще попробовать в будущем году.
5061.28 5064.36 "Анатолий Кулаков" В общем, далеко-далеко, на каких-то десятых позициях
5064.36 5065.36 "Анатолий Кулаков" там около того.
5065.36 5067.36 "Игорь Лабутин" Ну слушай, мне кажется, мы всегда где-то там были
5067.36 5071.16 "Анатолий Кулаков" в районе 20 с чем-то, нет?
5071.16 5072.16 "Анатолий Кулаков" Затрудняюсь ответить.
5072.16 5073.16 "Анатолий Кулаков" Ну ладно.
5073.16 5077.76 "Анатолий Кулаков" А другой интересный сосед у нас есть с 1%, т.е. 1% всех
5077.76 5082.02 "Анатолий Кулаков" опрошенных сказали, что они используют F#, и более
5082.02 5084.92 "Анатолий Кулаков" интересный второй показатель, что планируют его в будущем
5084.92 5087.40 "Анатолий Кулаков" году попытаться использовать 0%.
5087.40 5088.40 "Анатолий Кулаков" А C#?
5088.40 5089.40 "Анатолий Кулаков" C# 4.
5089.40 5090.40 "Анатолий Кулаков" А, ну, немало.
5090.40 5091.40 "Анатолий Кулаков" Хотят хотя бы попробовать.
5091.40 5096.40 "Игорь Лабутин" Ты так, конечно, сказал, сосед 21% и 1%.
5096.40 5101.84 "Анатолий Кулаков" 0%, что здесь замечательно, плохое слово здесь, да,
5101.84 5105.72 "Анатолий Кулаков" что можно заметить в этом отчете, что 0% планируют
5105.72 5109.60 "Анатолий Кулаков" использовать обычно такие мёртвые языки, как Objective-C,
5109.60 5114.24 "Анатолий Кулаков" Acaml, и вот Cabal, и вот туда ближе.
5114.24 5118.80 "Анатолий Кулаков" И, к сожалению, кажется, что F# приближается больше
5118.80 5120.00 "Анатолий Кулаков" к судьбе Cabal.
5120.00 5123.68 "Игорь Лабутин" Ну ладно уж, Cabal, там пока не настолько всё печально,
5123.68 5128.96 "Игорь Лабутин" мне кажется, есть там жизнь, но, наверное, да, Objective-C,
5128.96 5129.96 "Игорь Лабутин" не знаю.
5129.96 5133.84 "Игорь Лабутин" Я, правда, не разработчик на iOS, но тем не менее.
5133.84 5136.32 "Анатолий Кулаков" По крайней мере, никто не хочет, используют, естественно,
5136.32 5139.84 "Анатолий Кулаков" их много, но никто не хочет пробовать эту штуку, никто
5139.84 5140.84 "Анатолий Кулаков" не хочет в будущем её касаться.
5140.84 5141.84 "Игорь Лабутин" Интересно.
5141.84 5142.84 "Игорь Лабутин" А хотя бы, наверное, Rust, да?
5142.84 5146.24 "Анатолий Кулаков" Это мы с тобой посмотрим дальше, подожди, не торопись.
5146.24 5150.40 "Анатолий Кулаков" Вот, и насчёт того, как часто, ой, что мы в прошлом году
5150.40 5154.24 "Анатолий Кулаков" так, что у нас было, да, вообще последние 7 лет C# не выходит
5154.24 5157.28 "Анатолий Кулаков" из этой волны, у него 20-24% постоянно.
5157.28 5160.88 "Анатолий Кулаков" А, ну, как я и говорил, да, при этом 20.
5160.88 5162.96 "Анатолий Кулаков" Набрал какую-то популярность и ни вниз, ни вверх никуда
5162.96 5163.96 "Анатолий Кулаков" не движется.
5163.96 5165.88 "Анатолий Кулаков" В принципе, это тоже не очень хорошо, потому что с теми
5165.88 5168.60 "Анатолий Кулаков" новыми фичами, которые там у нас каждый год появляются,
5168.60 5171.04 "Анатолий Кулаков" должен быть взрывной рост, но, видимо, что-то не те
5171.04 5172.04 "Анатолий Кулаков" фичи появляются.
5172.04 5175.52 "Анатолий Кулаков" Ну, такие микровзрывы только, и в том, по-моему, внутри
5175.52 5176.52 "Анатолий Кулаков" дотнет комьюнити.
5176.52 5179.04 "Анатолий Кулаков" Мне кажется, да, и только в пуканах всех фанатов
5179.04 5180.04 "Анатолий Кулаков" дотнета.
5180.04 5185.00 "Анатолий Кулаков" Посмотрим, кто хочет мигрировать, нет, куда хотят мигрировать
5185.00 5189.00 "Анатолий Кулаков" C#-исты, если вдруг вас припечёт и завтра вам скажут "мигрируйте",
5189.00 5190.00 "Анатолий Кулаков" то куда хотят.
5190.00 5197.44 "Анатолий Кулаков" Хотят 10% на Rust, 8% на Go и 6% на TypeScript.
5197.44 5199.28 "Анатолий Кулаков" Тут довольно, наверное, удивительная картина, да,
5199.28 5202.08 "Анатолий Кулаков" как с высокоуровневого C# люди хотят мигрировать
5202.08 5203.56 "Анатолий Кулаков" на низкоуровневый Rust.
5203.56 5207.56 "Игорь Лабутин" Тут тоже интересная интерпретация, ты так говоришь, типа куда
5207.56 5208.56 "Игорь Лабутин" мигрировать, если вам скажут "мигрировать".
5208.56 5210.72 "Игорь Лабутин" Скорее всего, если вам скажут "мигрировать", вам скажут
5210.72 5211.72 "Игорь Лабутин" куда.
5211.72 5215.16 "Игорь Лабутин" Кстати, "хотеть" - это одно, а куда вы на самом деле
5215.16 5218.88 "Игорь Лабутин" мигрируете в Java или JavaScript, это уже питон какой-нибудь,
5218.88 5219.88 "Игорь Лабутин" это другое.
5219.88 5222.80 "Игорь Лабутин" Может, Go и Rust, а вот по факту вы будете писать на чём-то
5222.80 5223.80 "Анатолий Кулаков" другом.
5223.80 5226.00 "Анатолий Кулаков" Но всё равно, зачем тебе хотеть в Rust, если ты на C#?
5226.00 5227.00 "Анатолий Кулаков" Ты бы хотел на Rust?
5227.00 5230.64 "Игорь Лабутин" Нет, на Rust нет, наверное, не хотел бы.
5230.64 5232.76 "Игорь Лабутин" Можешь объяснить, почему больше всего хотят именно
5232.76 5233.76 "Игорь Лабутин" туда?
5233.76 5238.48 "Игорь Лабутин" Ну типа, сейчас, наверное, скажу, давай так, мне хотелось
5238.48 5241.48 "Игорь Лабутин" бы побольше его изучить, я особо не знаю Rust, прямо
5241.48 5242.48 "Игорь Лабутин" скажем.
5242.48 5244.32 "Игорь Лабутин" То есть я так его читаю со словарём, как я люблю
5244.32 5245.32 "Игорь Лабутин" говорить.
5245.32 5248.52 "Игорь Лабутин" Наверное, я когда-нибудь что-нибудь на нём такое
5248.52 5250.60 "Игорь Лабутин" поэкспериментирую в качестве pet-проектов, но это не тот
5250.60 5252.80 "Игорь Лабутин" язык, на котором я бы хотел писать каждый день.
5252.80 5255.92 "Игорь Лабутин" То есть он интересен для, как бы, для посмотреть,
5255.92 5256.92 "Игорь Лабутин" что бывает.
5256.92 5260.84 "Игорь Лабутин" Ну там вот своя модель, значит, владения, вот это всё, это
5260.84 5264.16 "Игорь Лабутин" всё интересно, но это не то, что хочется для каждодневной
5264.16 5265.16 "Игорь Лабутин" работы использовать.
5265.16 5269.60 "Анатолий Кулаков" Ну и Rust уже многие годы входит в список топ-один
5269.60 5272.12 "Анатолий Кулаков" языков, которые все хотят попробовать, но никто не
5272.12 5273.12 "Анатолий Кулаков" пробует.
5273.12 5276.20 "Анатолий Кулаков" Поэтому популярность у него большая.
5276.20 5277.80 "Игорь Лабутин" Кто-то, наверное, может и пробует именно что пробует,
5277.80 5280.08 "Игорь Лабутин" но это же не то, что я там на работе им каждый день
5280.08 5281.08 "Игорь Лабутин" пользуюсь.
5281.08 5282.32 "Игорь Лабутин" Поэтому, наверное, в таких опросах никто не отвечает,
5282.32 5284.32 "Игорь Лабутин" что да, я типа Rust-программист.
5284.32 5287.12 "Анатолий Кулаков" Ну да-да, так и есть.
5287.12 5290.20 "Анатолий Кулаков" Куда, то есть люди из каких языков хотели бы прийти
5290.20 5291.20 "Анатолий Кулаков" в C#?
5291.20 5292.56 "Анатолий Кулаков" То есть кто хочет попробовать C#?
5292.56 5297.84 "Анатолий Кулаков" Это, прежде всего, C+исты, JS-ники, PHP-шники и питонячники,
5297.84 5298.84 "Анатолий Кулаков" да?
5298.84 5299.84 "Анатолий Кулаков" Питонисты.
5299.84 5300.84 "Анатолий Кулаков" Питонисты.
5300.84 5301.84 "Анатолий Кулаков" Питонщики.
5301.84 5302.84 "Анатолий Кулаков" Питонщики.
5302.84 5303.84 "Анатолий Кулаков" Питонщики.
5303.84 5307.72 "Анатолий Кулаков" А вот люди этих профессий тоже заглядываются на C#
5307.72 5308.72 "Анатолий Кулаков" и хотят попробовать.
5308.72 5314.40 "Анатолий Кулаков" Тут не знаю, что комментировать, но плюсовики всегда к нам
5314.40 5318.40 "Анатолий Кулаков" как бы тянулись, скапывались, для этого и был там C# задизайнен
5318.40 5319.80 "Анатолий Кулаков" именно под C.
5319.80 5322.80 "Анатолий Кулаков" В общем, а все остальные, ну, скорее всего, они просто
5322.80 5323.80 "Анатолий Кулаков" берут свои марсы.
5323.80 5325.72 "Игорь Лабутин" Их так много, что они везде хотят.
5325.72 5329.20 "Игорь Лабутин" Ну JS, может, немножко на Blazor смотрит, так типа одним
5329.20 5330.20 "Игорь Лабутин" краешком глаза.
5330.20 5331.20 "Игорь Лабутин" Вот.
5331.20 5335.64 "Анатолий Кулаков" Может, им этот TypeScript нравится JS-никам, поэтому они решили
5335.64 5339.48 "Анатолий Кулаков" вот что-то подобное на Backend поискать, и C# здесь попался.
5339.48 5340.48 "Игорь Лабутин" Может быть.
5340.48 5342.68 "Игорь Лабутин" То есть я думаю, что это такое, если бы тут было
5342.68 5345.20 "Игорь Лабутин" 50%, вот это, да, так.
5345.20 5349.32 "Игорь Лабутин" И даже, тем более, ты говоришь, 5% на все 4 этих языка вместе
5349.32 5350.32 "Игорь Лабутин" взятых?
5350.32 5352.96 "Анатолий Кулаков" Ну нет, не на все взятых, а из каждого языка, по 5%.
5352.96 5353.96 "Игорь Лабутин" А, из каждого.
5353.96 5354.96 "Игорь Лабутин" Всё, понял.
5354.96 5355.96 "Игорь Лабутин" Хорошо.
5355.96 5356.96 "Игорь Лабутин" А то я думал, значит, из каждого по 1%.
5356.96 5357.96 "Анатолий Кулаков" Нет.
5357.96 5358.96 "Анатолий Кулаков" Нет, всё-таки каких-то 5 там есть, да?
5358.96 5359.96 "Анатолий Кулаков" Ладно, хорошо.
5359.96 5360.96 "Анатолий Кулаков" Поэтому это совсем было бы плохо.
5360.96 5363.08 "Анатолий Кулаков" А ещё один интересный пункт – это популярность баз
5363.08 5366.00 "Анатолий Кулаков" данных в России, немножко не связанная с C#, но связанная
5366.00 5368.24 "Анатолий Кулаков" с Россией, поэтому почему бы и нет.
5368.24 5371.52 "Анатолий Кулаков" Плюс 58% популярности прибавил PuzzleWiz.
5371.52 5372.52 "Анатолий Кулаков" Удивительно.
5372.52 5373.52 "Анатолий Кулаков" Почему бы и так?
5373.52 5374.52 "Анатолий Кулаков" Удивительно.
5374.52 5383.24 "Анатолий Кулаков" И плюс 21% SQLite, и рухнули MySQL – -45%, Oracle – -53%, MS SQL – -25%.
5383.24 5385.24 "Анатолий Кулаков" Тоже сразу видно интересный отток.
5385.24 5388.08 "Анатолий Кулаков" Кстати, MS SQL не так сильно падал, да?
5388.08 5391.64 "Анатолий Кулаков" На 25%, но по сравнению с Oracle, на 53%.
5391.64 5395.20 "Игорь Лабутин" Странно, что, кстати, MySQL так много упал.
5395.20 5399.56 "Игорь Лабутин" Ну в смысле, что его так много, то есть я бы ожидал,
5399.56 5400.56 "Игорь Лабутин" что MS SQL… И что с ним вообще?
5400.56 5401.56 "Игорь Лабутин" Упал бы.
5401.56 5402.56 "Анатолий Кулаков" Мне казалось, MySQL… А, MySQL уже Oracle купил.
5402.56 5403.56 "Анатолий Кулаков" Он Oracle, он там Cloud Source, вот это всё.
5403.56 5404.56 "Анатолий Кулаков" Тогда понятно, почему он падает.
5404.56 5415.56 "Анатолий Кулаков" Я понимаю, почему он падает, я бы ожидал, что MS SQL больше
5415.56 5417.96 "Игорь Лабутин" упадёт, чем MySQL, но, видимо, MySQL действительно очень
5417.96 5420.56 "Игорь Лабутин" много в C# используется, просто мне особо не попадается
5420.56 5421.56 "Игорь Лабутин" на самом деле на работе.
5421.56 5422.56 "Анатолий Кулаков" Да, мне как-то тоже.
5422.56 5426.76 "Игорь Лабутин" Ну вот у меня один проект есть, где много MySQL, но это
5426.76 5427.76 "Игорь Лабутин" как-то решается.
5427.76 5428.76 "Анатолий Кулаков" Наверное, да.
5428.76 5430.96 "Анатолий Кулаков" Может, я думаю, может, в сериале есть Sharpies, он не
5430.96 5431.96 "Анатолий Кулаков" такой популярный.
5431.96 5432.96 "Анатолий Кулаков" Я знаю, что на PHP его очень сильно любят.
5432.96 5433.96 "Игорь Лабутин" Да.
5433.96 5437.04 "Игорь Лабутин" Ну вот у нас как раз то, где я сейчас немножко смотрю
5437.04 5440.60 "Игорь Лабутин" архитектуру, там как раз, да, всякие WordPress, PHP и прочее,
5440.60 5443.16 "Игорь Лабутин" там MySQL во весь рост.
5443.16 5444.92 "Анатолий Кулаков" Какую версию C# вы используете?
5444.92 5446.76 "Анатолий Кулаков" И здесь, в принципе, у нас стабильно всё хорошо.
5446.76 5450.08 "Анатолий Кулаков" 42% большинство используют самую последнюю хорошую
5450.08 5454.08 "Анатолий Кулаков" версию C# 11, ну, на момент выхода, формирования, естественно,
5454.08 5455.08 "Анатолий Кулаков" отчёта, самая последняя.
5455.08 5460.44 "Анатолий Кулаков" В общем, C# 10 – 32%, C# 9 – 17%, т.е. такой прям хороший
5460.44 5461.44 "Анатолий Кулаков" разброс, хорошую ступень.
5461.44 5462.44 "Игорь Лабутин" Хорошую ступень.
5462.44 5464.40 "Игорь Лабутин" Ну подожди, это версия C#, а у нас же есть ещё версия
5464.40 5465.40 "Игорь Лабутин" Runtime.
5465.40 5468.84 "Анатолий Кулаков" Runtime тоже почти прекрасно, т.е. на последней версии
5468.84 5474.08 "Анатолий Кулаков" большинство, ну ладно, 38% на .NET 7, на .NET 6 тоже 38%,
5474.08 5478.12 "Анатолий Кулаков" но вот с .NET 5, например, там осталось 10%, и это прекрасно,
5478.12 5480.60 "Анатолий Кулаков" т.е. люди бегут прямо на самые последние две версии.
5480.60 5484.08 "Игорь Лабутин" Ну, потому что легко обновляться, с 5 на 6 легко, с 5 на 7 тоже
5484.08 5485.08 "Анатолий Кулаков" неправильно.
5485.08 5487.56 "Анатолий Кулаков" Ну, не сложно, не просто хотел сказать.
5487.56 5488.56 "Анатолий Кулаков" Да, да, там просто.
5488.56 5491.96 "Анатолий Кулаков" А вот откуда сложно обновляться, это, как ни странно, даже
5491.96 5496.60 "Анатолий Кулаков" с .NET Core, и на .NET Core висит 35%, т.е. это почти столько
5496.60 5499.20 "Анатолий Кулаков" же, сколько висит на самой последней версии, на последней
5499.20 5503.92 "Анатолий Кулаков" версии 38 на .NET 7, а на вот над Core, там где треть, тройка
5503.92 5507.24 "Анатолий Кулаков" и так далее, там всё ещё 35%, т.е. люди как-то хорошо
5507.24 5511.56 "Анатолий Кулаков" перепрыгнули на какой-то кроссплатформенный .NET,
5511.56 5514.96 "Анатолий Кулаков" и там до сих пор сидят, и как-то всё не двигается,
5514.96 5515.96 "Игорь Лабутин" это не очень хорошо.
5515.96 5518.64 "Игорь Лабутин" Ну либо есть ощущение, что, может быть, будет сложно,
5518.64 5521.20 "Игорь Лабутин" потому что, ну казалось бы, там, да, .NET Core, там тройка,
5521.20 5523.04 "Игорь Лабутин" да, а тут 8, ну хорошо, LTS.
5523.04 5525.28 "Анатолий Кулаков" Нет, между тройкой и пятёркой действительно там нормально
5525.28 5526.28 "Анатолий Кулаков" так.
5526.28 5529.12 "Игорь Лабутин" Там много было, это, конечно, не фреймворк в Core, но тем
5529.12 5531.80 "Игорь Лабутин" не менее, да, а с другой стороны, если у тебя был
5531.80 5536.32 "Игорь Лабутин" какой-то продукт, который ты мигрировал на Core, допустим,
5536.32 5540.56 "Игорь Лабутин" там несколько лет назад, когда там всё активно двигалось,
5540.56 5543.20 "Игорь Лабутин" а сейчас он у тебя в каком-нибудь мейнтенсе, ну как бы он
5543.20 5544.88 "Игорь Лабутин" и будет Core, чё.
5544.88 5548.04 "Анатолий Кулаков" Ну, может быть, конечно, да, но всё равно цифра слишком
5548.04 5549.04 "Анатолий Кулаков" большая.
5549.04 5550.04 "Анатолий Кулаков" Ну да.
5550.04 5552.96 "Анатолий Кулаков" Но, к сожалению, какая цифра ещё больше, это не подъём
5552.96 5555.92 "Анатолий Кулаков" их просто 45%, знаете где?
5555.92 5559.64 "Анатолий Кулаков" На .NET фреймворке, товарищ, .NET фреймворк становится
5559.64 5564.68 "Анатолий Кулаков" с каждым годом его меньше и меньше, но всё ещё 45% – это
5564.68 5569.44 "Анатолий Кулаков" просто огромное, большое, как это, скопление проектов.
5569.44 5571.36 "Игорь Лабутин" Там интересно ещё, наверное, посмотреть раскладку по
5571.36 5573.40 "Игорь Лабутин" версиям, потому что там тоже, я боюсь, что какие-нибудь
5573.40 5574.40 "Игорь Лабутин" там 4-5.
5574.40 5575.40 "Игорь Лабутин" Два.
5575.40 5576.40 "Игорь Лабутин" Если не 4-0.
5576.40 5577.40 "Игорь Лабутин" Ну ладно.
5577.40 5578.40 "Игорь Лабутин" Да, да, именно так.
5578.40 5585.64 "Анатолий Кулаков" И вот здесь уже точно шансов мало, что его переведут
5585.64 5588.32 "Анатолий Кулаков" на Core, потому что, скорее всего, все, кто хотели перевестись
5588.32 5591.92 "Анатолий Кулаков" на Core, уже перевелись, в частности, вот эти 35%, которые
5591.92 5597.24 "Анатолий Кулаков" там застряли, а вот эти большие монструозные 45% кажется
5597.24 5598.24 "Анатолий Кулаков" уже никуда не денутся.
5598.24 5604.00 "Анатолий Кулаков" И это грустно, да, поэтому, если вдруг у вас есть .NET
5604.00 5606.44 "Анатолий Кулаков" фреймворк, переводите, улучшайте статистику.
5606.44 5607.44 "Анатолий Кулаков" Обязательно.
5607.44 5608.44 "Игорь Лабутин" На .DOE.
5608.44 5610.64 "Игорь Лабутин" Не смотрите на бизнес-цели, нам нужна статистика.
5610.64 5613.44 "Анатолий Кулаков" Кому нужны ваши бизнес-цели, у нас тут как бы статистика
5613.44 5614.44 "Анатолий Кулаков" гниёт.
5614.44 5619.72 "Анатолий Кулаков" Так, что у нас используется в качестве фреймворков?
5619.72 5622.72 "Анатолий Кулаков" Ну там стандартный комплект ISP.NET Entity Framework, там никаких
5622.72 5624.92 "Анатолий Кулаков" конкурентов нет, всё от Microsoft, естественно.
5624.92 5630.64 "Анатолий Кулаков" Внутри ISP.NET 78% это Web API больше всего, MVC 64, в принципе,
5630.64 5632.92 "Анатолий Кулаков" тоже много, я что-то ожидал, что MVC у нас поменьше.
5632.92 5635.84 "Игорь Лабутин" Я бы сказал, что для меня сюрприз, что Razor Pages так
5635.84 5636.84 "Игорь Лабутин" много.
5636.84 5637.84 "Анатолий Кулаков" 40%.
5637.84 5641.00 "Анатолий Кулаков" А вот Razor Pages хорошо отхапали, да, казалось, какой-то Excel,
5641.00 5645.60 "Анатолий Кулаков" то есть, даже Access для секретарш, но, как ни странно, 40% рынка,
5645.60 5646.60 "Анатолий Кулаков" неплохо, неплохо.
5646.60 5647.60 "Анатолий Кулаков" Да.
5647.60 5652.60 "Анатолий Кулаков" Вот все потуги с минимум LPI дали нам 20%, а Blazor сервер
5652.60 5657.32 "Анатолий Кулаков" 16%, и он популярнее, чем Blazor WebAssembly, который 12%.
5657.32 5661.52 "Анатолий Кулаков" Ну сервер, я так понимаю, попроще в каком-то, ну не
5661.52 5662.52 "Игорь Лабутин" знаю, ладно.
5662.52 5664.44 "Игорь Лабутин" Попроще, наверное, неправильное слово.
5664.44 5667.24 "Анатолий Кулаков" А с точки зрения разработки там сейчас одинаково всё.
5667.24 5669.60 "Игорь Лабутин" Мне кажется, что да, сейчас студия хорошо подтянулась,
5669.60 5672.24 "Игорь Лабутин" и не только студия, я так понимаю, в общем, всё вроде
5672.24 5673.24 "Игорь Лабутин" нормально.
5673.24 5675.04 "Игорь Лабутин" Ну WebAssembly, возможно, это всё-таки пока такая чуть-чуть
5675.04 5677.44 "Игорь Лабутин" менее изведанная технология, сервер-сайт-рендеринг всё-таки
5677.44 5680.68 "Игорь Лабутин" более понятен, такой же, как Razor, по сути, Pages, да.
5680.68 5684.64 "Игорь Лабутин" И тут вроде вопросов и проблем никаких нет, но мне на самом
5684.64 5687.88 "Игорь Лабутин" деле удивительно, что 16% Blazor пользуются, ну прикольно,
5687.88 5688.88 "Игорь Лабутин" прикольно.
5688.88 5691.80 "Игорь Лабутин" Хотя если Razor 40, блин, ну тут, конечно.
5691.80 5693.64 "Анатолий Кулаков" Технология, технология, это прекрасно, если тебе
5693.64 5696.72 "Анатолий Кулаков" нужно запилить, например, какую-то вебку, а фронтов
5696.72 5699.36 "Анатолий Кулаков" дёргать не хочется, и вымазываться в GSC тоже не хочется.
5699.36 5702.56 "Анатолий Кулаков" У тебя один выбор был, ну Razor Pages, естественно, это
5702.56 5704.68 "Анатолий Кулаков" не выбор, да, а Blazor Server вполне себе выбор.
5704.68 5707.60 "Игорь Лабутин" Ну вот статистика говорит об обратном, 40%, однако.
5707.60 5710.76 "Анатолий Кулаков" Ну, в принципе, да, может быть для кого-то и выбор.
5710.76 5713.92 "Анатолий Кулаков" Но смотри, если сложить Blazor Server и Blazor WebAssembly, да,
5713.92 5716.56 "Анатолий Кулаков" то есть это 16+12 уже, не хухры-мухры.
5716.56 5717.56 "Анатолий Кулаков" 28.
5717.56 5718.56 "Игорь Лабутин" 28%, да.
5718.56 5719.56 "Анатолий Кулаков" Приближается, да.
5719.56 5720.56 "Анатолий Кулаков" Посмотрим через годик.
5720.56 5724.36 "Анатолий Кулаков" Ну и GRPC 9%, там где-то притётся.
5724.36 5726.52 "Игорь Лабутин" Ну, кстати, про него я давно уже ничего не слышал, то
5726.52 5728.16 "Игорь Лабутин" есть, видимо, он довольно узко используется для
5728.16 5732.04 "Игорь Лабутин" какой-нибудь нижсервисной коммуникации, и как-то,
5732.04 5735.36 "Игорь Лабутин" вот было одно время там хайп со всякими, как там
5735.36 5738.36 "Игорь Лабутин" они назывались-то, короче, бриджи, чтобы из фронт-энда
5738.36 5741.76 "Игорь Лабутин" его дёргать, вот это всё, но чё-то как-то всё затихло.
5741.76 5745.44 "Анатолий Кулаков" Ну да, переписали, прооптимизировали, ускорили, и вроде, наверное,
5745.44 5746.44 "Анатолий Кулаков" и забили, скорее всего.
5746.44 5749.72 "Игорь Лабутин" Ну, как бы своё нишу имеют, и всё, да.
5749.72 5751.60 "Анатолий Кулаков" Ну и ладно.
5751.60 5752.60 "Анатолий Кулаков" Так и есть.
5752.60 5753.60 "Анатолий Кулаков" Так, с EDE-шками.
5753.60 5756.60 "Анатолий Кулаков" Там у нас по-прежнему борются три редактора, на первом
5756.60 5762.72 "Анатолий Кулаков" месте 48% Visual Studio, на 32-м Raider и 14% Visual Studio Code.
5762.72 5766.52 "Игорь Лабутин" Тут, наверное, удивительно, что Visual Studio Code что-то не
5766.52 5767.52 "Игорь Лабутин" занимает.
5767.52 5770.44 "Игорь Лабутин" Если тебя послушать, ты услышал, что ты сказал,
5770.44 5771.44 "Игорь Лабутин" да?
5771.44 5775.88 "Игорь Лабутин" 48% занимает Visual Studio, на 32-м месте Raider, нет, Raider всё-таки
5775.88 5780.14 "Игорь Лабутин" у нас 32%, на самом деле, по-моему, в рост мне, я, конечно,
5780.14 5782.24 "Игорь Лабутин" не сверял цифры, но, по-моему, в прошлом году было порядка
5782.24 5787.00 "Игорь Лабутин" 25 или 7, я могу ошибаться сейчас, т.е. он подрос.
5787.00 5789.64 "Анатолий Кулаков" Да, он каждый год растёт, стабильно, хорошо.
5789.64 5791.72 "Игорь Лабутин" Да, логично, растёт, тем более Visual Studio Format теперь
5791.72 5792.72 "Игорь Лабутин" нету.
5792.72 5795.64 "Игорь Лабутин" Ну, есть пока ещё формально, но считайте, что уже нету
5795.64 5796.64 "Игорь Лабутин" она.
5796.64 5797.64 "Игорь Лабутин" Visual Studio Code теперь.
5797.64 5800.36 "Игорь Лабутин" Ну, теперь, да, Visual Studio Code, Diffbox, вот это всё, или как
5800.36 5801.36 "Игорь Лабутин" там оно называется?
5801.36 5802.36 "Игорь Лабутин" Не Diffbox.
5802.36 5803.36 "Игорь Лабутин" Да, как-то так.
5803.36 5805.80 "Игорь Лабутин" Как-то так называется, ладно, неважно.
5805.80 5808.52 "Игорь Лабутин" Короче, можно, да, брать Visual Studio Code вместо либо
5808.52 5809.52 "Игорь Лабутин" Raider.
5809.52 5810.52 "Игорь Лабутин" Операционка.
5810.52 5821.08 "Анатолий Кулаков" C# разработчики предпочитают Windows, 78%, да, macOS, 32%, и Linux,
5821.08 5822.08 "Анатолий Кулаков" 19%.
5822.08 5827.04 "Анатолий Кулаков" И, в принципе, здесь всё ожидаемо, всё нормально.
5827.04 5829.50 "Анатолий Кулаков" Какие-то там маргиналы нашли себе Mac, остальные давно
5829.50 5832.12 "Анатолий Кулаков" сидят под Windows, потому что дотная только под Windows,
5832.12 5834.64 "Анатолий Кулаков" ну а Linux откуда взялся, я вообще не пойму.
5834.64 5837.60 "Игорь Лабутин" Не, ну как раз маргиналы нашли Linux, и мне кажется,
5837.60 5839.64 "Игорь Лабутин" что их стало больше, чем было.
5839.64 5840.64 "Анатолий Кулаков" МакОС.
5840.64 5844.40 "Анатолий Кулаков" Да, Linux растёт, кстати, насколько я помню, а Windows и макОС падают.
5844.40 5847.56 "Игорь Лабутин" Ну, они примерно сохраняются, макОС, наверное, тоже подрастает
5847.56 5848.56 "Игорь Лабутин" немножко.
5848.56 5852.76 "Игорь Лабутин" МакБуки всё-таки плюс кроссплатформа даёт о себе как бы знать,
5852.76 5857.80 "Игорь Лабутин" и, наверное, там приятнее местами на маковских ноутах
5857.80 5861.20 "Игорь Лабутин" кому-то больше нравится работать, вот, но Linux действительно
5861.20 5862.20 "Игорь Лабутин" отрастает.
5862.20 5863.20 "Игорь Лабутин" Ну и чё, приятно, кроссплатформа, хорошо.
5863.20 5866.00 "Анатолий Кулаков" Да, наверное, хоть как-то себя показывает.
5866.00 5871.32 "Анатолий Кулаков" Юнит тестинг, итак, фреймворки используемые для юнит-тестирования.
5871.32 5879.20 "Анатолий Кулаков" 37% XUnit, 36% NUnit, 14% непобедимый МС-тест, в принципе, тоже
5879.20 5880.20 "Анатолий Кулаков" много-много.
5880.20 5883.28 "Анатолий Кулаков" Но самое примечательное в этом опросе, это то, что
5883.28 5889.32 "Анатолий Кулаков" 19% не пишут юнит-тесты вообще, и мало того, что 19% не пишут
5889.32 5893.40 "Анатолий Кулаков" юнит-тесты вообще, то это ещё на 3% больше, чем не писали
5893.40 5894.40 "Анатолий Кулаков" их в прошлом году.
5894.40 5898.32 "Анатолий Кулаков" То есть не писать стали на 3% больше программистов.
5898.32 5900.48 "Анатолий Кулаков" Тут, соответственно, возникает резонный вопрос.
5900.48 5902.96 "Анатолий Кулаков" Да вы чё там, обезумели все, что ли, ну-ка все писать
5902.96 5903.96 "Анатолий Кулаков" юнит-тесты.
5903.96 5904.96 "Анатолий Кулаков" Хотя бы на МС-тесте.
5904.96 5907.96 "Анатолий Кулаков" Да хотя бы уже на чём-нибудь, там даже есть ответ как
5907.96 5909.76 "Анатолий Кулаков" бы на своих собственных фреймворках, пишите хотя
5909.76 5910.76 "Анатолий Кулаков" бы там.
5910.76 5911.76 "Игорь Лабутин" Ну что это такое?
5911.76 5912.76 "Игорь Лабутин" Да.
5912.76 5915.36 "Игорь Лабутин" XUnit и NUnit традиционно идут плюс-минус одинаково, там
5915.36 5917.92 "Игорь Лабутин" то один чуть выше, то другой чуть выше, причём там, по-моему,
5917.92 5921.04 "Игорь Лабутин" действительно паритет чуть ли не 50 на 50, ну, относительно
5921.04 5923.40 "Игорь Лабутин" друг друга уже много-много лет.
5923.40 5928.72 "Анатолий Кулаков" Да, ну тут у NUnit вышла новая версия, вот XUnit мы никак
5928.72 5931.32 "Анатолий Кулаков" не можем дождаться многолетнего версии, поэтому может в
5931.32 5933.72 "Анатолий Кулаков" следующем году этот паритет и немножко изменится.
5933.72 5935.48 "Игорь Лабутин" Про NUnit и новую версию мы чуть попозже поговорим.
5935.48 5940.68 "Игорь Лабутин" Там было же так, что долго NUnit не выходил, XUnit там активно
5940.68 5944.14 "Игорь Лабутин" развивался как раз во времена начального кора, когда
5944.14 5947.84 "Игорь Лабутин" Microsoft его активно адоптили, потом наоборот, XUnit сейчас
5947.84 5950.96 "Игорь Лабутин" что-то подзахерел с точки зрения новых версий, зато
5950.96 5955.48 "Игорь Лабутин" NUnit вот тут как бы прям возродился, можно сказать.
5955.48 5958.60 "Игорь Лабутин" Поэтому да, видимо сейчас, если XUnit выпустится, третья
5958.60 5959.60 "Игорь Лабутин" сейчас готовится.
5959.60 5962.44 "Анатолий Кулаков" Да, слушай, она готовится уже лет 5, поэтому я не думаю,
5962.44 5963.44 "Игорь Лабутин" что сейчас.
5963.44 5966.20 "Игорь Лабутин" Ну сейчас, в смысле, начиная с текущего момента и когда-то
5966.20 5968.20 "Игорь Лабутин" в будущем, возможно, года через три.
5968.20 5969.20 "Игорь Лабутин" Да-да-да.
5969.20 5970.20 "Игорь Лабутин" Вот, я не знаю.
5970.20 5972.64 "Игорь Лабутин" Ну сейчас вот выпустит, как только, так сразу вырвется
5972.64 5973.64 "Игорь Лабутин" вперёд, возможно.
5973.64 5975.24 "Игорь Лабутин" Ну просто потому что народ пойдёт смотреть новую.
5975.24 5976.88 "Игорь Лабутин" Я, допустим, ожидаю, что, может быть, NUnit чуть-чуть
5976.88 5980.32 "Игорь Лабутин" подрастёт, потому что новая версия, там, всякие интересные
5980.32 5982.92 "Игорь Лабутин" фичи завезли, ну, так себе интересные.
5982.92 5985.64 "Анатолий Кулаков" Ну и вообще, товарищи, которые не пишут её тесты, видите,
5985.64 5987.88 "Анатолий Кулаков" сколько у нас много интересного тут происходит в тестировании?
5987.88 5989.36 "Анатолий Кулаков" Ну-ка, быстренько забегайте.
5989.36 5993.08 "Анатолий Кулаков" Тут понаходили, там, с PHP и Python, теперь тесты не пишут,
5993.08 5994.08 "Анатолий Кулаков" статистику нам портят.
5994.08 5997.20 "Анатолий Кулаков" Нет, вообще, на самом деле, 19% — это практически позор
5997.20 5998.20 "Анатолий Кулаков" какой-то.
5998.20 5999.20 "Анатолий Кулаков" Так жить нельзя.
5999.20 6003.28 "Анатолий Кулаков" Я не знаю, может, мы с тобой мало этих статей про тестирование
6003.28 6004.28 "Анатолий Кулаков" рассказываем.
6004.28 6006.08 "Анатолий Кулаков" Мне кажется, новостей там какие-то освещаем.
6006.08 6009.56 "Игорь Лабутин" Да, 25 кадров в звуке бывает.
6009.56 6012.20 "Игорь Лабутин" Пишите Юнит тесты, пишите Юнит тесты.
6012.20 6013.20 "Анатолий Кулаков" Сделаем.
6013.20 6014.20 "Анатолий Кулаков" Сделаем, сделаем.
6014.20 6016.44 "Анатолий Кулаков" В общем, да, наверное, надо как-то больше добавлять
6016.44 6018.84 "Анатолий Кулаков" статейочек, потому что, я не знаю, правда, про что
6018.84 6021.04 "Анатолий Кулаков" там можно рассказывать, мне казалось, что это очевидно,
6021.04 6022.04 "Анатолий Кулаков" что всем надо писать тесты.
6022.04 6023.04 "Игорь Лабутин" Я тебе всё рассказал.
6023.04 6024.04 "Игорь Лабутин" Ну, как видишь.
6024.04 6025.04 "Анатолий Кулаков" Пишите Юнит тесты.
6025.04 6026.04 "Анатолий Кулаков" Ну, это не работает.
6026.04 6027.04 "Анатолий Кулаков" Это не работает.
6027.04 6028.04 "Анатолий Кулаков" Надо завлекать другим пряником.
6028.04 6029.04 "Анатолий Кулаков" Да.
6029.04 6030.60 "Анатолий Кулаков" Ну, вот такие основные темы, в принципе, вот такие основные
6030.60 6031.60 "Анатолий Кулаков" цифры.
6031.60 6034.00 "Анатолий Кулаков" Опять же, если мы в прошлом году зазывали вас прийти
6034.00 6036.84 "Анатолий Кулаков" хотя бы на графики покликать, и там были безумные анимации,
6036.84 6039.44 "Анатолий Кулаков" там разноцветные, красивые, то в этом году отчёт безумно
6039.44 6043.72 "Анатолий Кулаков" унылый, и если вам неинтересны просто голые непонятные
6043.72 6045.80 "Анатолий Кулаков" цифры, то делать вам там нечего особо.
6045.80 6048.00 "Игорь Лабутин" Ну всё, основное вы услышали.
6048.00 6050.48 "Игорь Лабутин" Ладно, пойдём, на самом деле, на последнюю тему, кратко
6050.48 6051.48 "Игорь Лабутин" о разном.
6051.48 6054.04 "Игорь Лабутин" У нас накопилось некоторое количество мелких, ну,
6054.04 6056.08 "Игорь Лабутин" на самом деле, они не только не очень мелкие статьи,
6056.08 6057.08 "Игорь Лабутин" но тем не менее.
6057.08 6059.40 "Игорь Лабутин" Поэтому быстро пробежимся, чтобы не сильно много тратить
6059.40 6060.40 "Игорь Лабутин" времени.
6060.40 6064.40 "Игорь Лабутин" Во-первых, попался мне интересный экстенджер к Visual Studio, называется
6064.40 6065.68 "Игорь Лабутин" Debug Output Filter.
6065.68 6068.64 "Игорь Лабутин" Если вы когда-нибудь собирали сложные, большие проекты,
6068.64 6073.40 "Игорь Лабутин" solution, точнее, я бы даже сказал, в студии, то вы, несомненно,
6073.40 6075.76 "Игорь Лабутин" особенно если там включён какой-нибудь Parallel Build, вот
6075.76 6078.16 "Игорь Лабутин" это всё, то вы, несомненно, видели вот эти вот префиксы
6078.16 6084.44 "Игорь Лабутин" в Output Build, типа, один больше, два больше, которые символизируют
6084.44 6087.80 "Игорь Лабутин" собой ноды, значит, этого MS Build-ового дерева, многопоточного
6087.80 6089.52 "Игорь Лабутин" исполнения, вот это всё, и пытались разобраться
6089.52 6092.20 "Игорь Лабутин" вообще, что у вас там происходило, то вот этот экстенджер вам
6092.20 6093.20 "Игорь Лабутин" точно в помощь.
6093.20 6095.00 "Игорь Лабутин" Он, во-первых, содержит всю историю ваших билдов,
6095.00 6098.44 "Игорь Лабутин" во-вторых, он умеет бодро фильтровать весь аутпут,
6098.44 6101.16 "Игорь Лабутин" в-третьих, он умеет его раскладывать, собственно, по нодам того,
6101.16 6102.16 "Игорь Лабутин" как что исполнялось.
6102.16 6105.36 "Игорь Лабутин" Короче, прям, вот если вы много работаете с билд аутпут
6105.36 6109.36 "Игорь Лабутин" окошком, must-have, мне кажется, я не пробовал, честно скажу,
6109.36 6112.12 "Игорь Лабутин" сейчас у меня нет таких больших проектов, на которых
6112.12 6116.20 "Игорь Лабутин" это бы пригодилось, но, возможно, вам будет полезно.
6116.20 6118.84 "Игорь Лабутин" Прям вот на скринах и по описанию выглядит прям
6118.84 6122.76 "Игорь Лабутин" как офигенная штука, там есть буквально по ссылочке
6122.76 6125.68 "Игорь Лабутин" на Marketplace, вижу, студийный пятиминутный видосик, где
6125.68 6129.04 "Игорь Лабутин" можно посмотреть, так сказать, как это быстро работает,
6129.04 6133.00 "Игорь Лабутин" там даже есть одноминутный видосик, ну точнее, 60-секундный
6133.00 6136.04 "Игорь Лабутин" видосик, где кратенько всё рассказано, так что
6136.04 6137.04 "Игорь Лабутин" пробуйте, смотрите.
6137.04 6143.84 "Игорь Лабутин" Дальше, полезная репозитория Дэмиэн Бода, или я не знаю,
6143.84 6147.28 "Игорь Лабутин" как его фамилия склоняется, Дэмиэн Бод, которая называется
6147.28 6151.42 "Игорь Лабутин" SpNetCore Hybrid Flow with API, и это штука про нашу любимую
6151.42 6156.28 "Игорь Лабутин" тему, в кавычках, OAuth 2.0, авторизация, токены, JVT, вот
6156.28 6162.68 "Игорь Лабутин" это всё, и это очень хорошие, давайте так, неплохие примеры
6162.68 6165.44 "Игорь Лабутин" того, как это нужно делать, там, по-моему, на примере
6165.44 6169.36 "Игорь Лабутин" идентити сервера и SpNetCore, но по большому счёту именно
6169.36 6172.86 "Игорь Лабутин" принципы одни и те же, то есть если вам вдруг было
6172.86 6180.50 "Игорь Лабутин" интересно, чем отличается веб-коуд Flow PCE от чего-нибудь
6180.50 6184.28 "Игорь Лабутин" там другого, вот идите туда и смотрите, там всякие
6184.28 6186.94 "Игорь Лабутин" нестандартные штуки типа Device Flow, раз смотрю на которые
6186.94 6192.32 "Игорь Лабутин" довольно редко попадаются, Multifactor Authentication и всё такое
6192.32 6195.02 "Игорь Лабутин" прочее, то есть если вам интересно посмотреть, как
6195.02 6199.22 "Игорь Лабутин" это всё нужно правильно работать с OAuth 2.0, на мой
6199.22 6202.66 "Игорь Лабутин" взгляд там вполне неплохие примеры, причём они регулярно
6202.66 6204.86 "Игорь Лабутин" обновляются на последний дотнет, сейчас он обновлён
6204.86 6209.86 "Игорь Лабутин" вот последнее обновление 17 ноября под 8 дотнет, вот,
6209.86 6212.34 "Игорь Лабутин" полезная штука, возможно оттуда можно что-то потягать
6212.34 6215.50 "Игорь Лабутин" себе, если вам вдруг что-то нужно.
6215.50 6219.76 "Игорь Лабутин" Сергей Тепляков выпустил интересную статичку на
6219.76 6224.66 "Игорь Лабутин" тему string and turning и вообще того, статья даже не столько
6224.66 6228.94 "Игорь Лабутин" про то, что же там делать со string and turning и почему
6228.94 6232.70 "Игорь Лабутин" он такой медленный или наоборот быстрый, статья
6232.70 6236.82 "Игорь Лабутин" про то, что надо внимательно относиться, вот мы сегодня
6236.82 6240.06 "Игорь Лабутин" уже говорили про native auth, про то, что надо понимать,
6240.06 6242.98 "Игорь Лабутин" что в native auth у вас приложение может начать вести себя
6242.98 6243.98 "Игорь Лабутин" вообще по-другому.
6243.98 6249.78 "Игорь Лабутин" Выводы из этой статьи, почитайте, там есть битчмарки, там
6249.78 6253.86 "Игорь Лабутин" есть объяснение, что, как и так далее, выводы довольно
6253.86 6259.50 "Игорь Лабутин" замавные, вывод первый, если вы используете обычный
6259.50 6264.22 "Игорь Лабутин" режим managed, то есть не auth, то string and turning он довольно
6264.22 6267.10 "Игорь Лабутин" таки медленный, потому что там он проверяет, что
6267.10 6269.30 "Игорь Лабутин" такое string and turning, да, я так всё говорю, говорю, это
6269.30 6273.38 "Игорь Лабутин" когда вы заменяете копию одной и той же строки с
6273.38 6275.22 "Игорь Лабутин" ссылками, ну, собственно, на одну единственную копию
6275.22 6278.06 "Игорь Лабутин" и тем самым уменьшаете количество строчек в памяти, все остальные
6278.06 6279.34 "Игорь Лабутин" собираются кормить коллектором.
6279.34 6281.30 "Игорь Лабутин" Для того, чтобы сделать string and turning, понятное дело,
6281.30 6283.54 "Игорь Лабутин" нужно найти, собственно, эту копию где-то в памяти.
6283.54 6285.86 "Игорь Лабутин" Для того, чтобы её не искать путём линейного проверки
6285.86 6288.30 "Игорь Лабутин" по памяти, они хранятся в некотором, грубо говоря,
6288.30 6290.78 "Игорь Лабутин" словарике, и вот там работать с этим словариком довольно
6290.78 6291.78 "Игорь Лабутин" сложно.
6291.78 6296.14 "Игорь Лабутин" Но если вы компилируете штуку, ваше приложение
6296.14 6300.10 "Игорь Лабутин" в native auth, то там начинает использоваться не какой-то
6300.10 6305.90 "Игорь Лабутин" там очень хитрый native code lock-free, а нет, lock-free это уже
6305.90 6312.22 "Игорь Лабутин" новая штука, короче, какой-то там C++-ный код, который называется
6312.22 6317.14 "Игорь Лабутин" string literal map, что-то там, а используется самый обыкновенный,
6317.14 6319.94 "Игорь Лабутин" в принципе, concurrent dictionary, по большому счёту.
6319.94 6325.34 "Игорь Лабутин" Он, короче, в, сейчас, чтобы не соврать, а, тут нету этой
6325.34 6331.94 "Игорь Лабутин" самой, ну, в общем, он быстрее процентов на 25, мне кажется,
6331.94 6335.42 "Игорь Лабутин" если не больше, вот, в native auth-варианте, но, к сожалению,
6335.42 6338.18 "Игорь Лабутин" он только в native auth используется.
6338.18 6342.50 "Игорь Лабутин" Поэтому надо теперь понимать, что как только мы начали
6342.50 6345.78 "Игорь Лабутин" компилировать приложение в native auth, Майкрософт может
6345.78 6349.18 "Игорь Лабутин" начать немножко экспериментировать и генерировать вам код,
6349.18 6351.66 "Игорь Лабутин" ну, который не совсем такой, как в менеджмент-варианте.
6351.66 6353.86 "Игорь Лабутин" И вы такие скомпилировали в native auth, и у вас код стал
6353.86 6357.06 "Игорь Лабутин" там, не знаю, в 5 раз быстрее, но не потому, что он в native
6357.06 6359.06 "Игорь Лабутин" auth стал, а потому что вам в native auth подсунули какую-то
6359.06 6361.74 "Игорь Лабутин" другую реализацию в стандартной библиотеке, такое может
6361.74 6362.74 "Игорь Лабутин" быть.
6362.74 6367.86 "Игорь Лабутин" В общем, смотрите внимательно, меряйте и бенчмаркайте.
6367.86 6368.86 "Игорь Лабутин" Смотрите, что получается.
6368.86 6371.90 "Игорь Лабутин" У нас статейка интересная, можно почитать, чтобы понять
6371.90 6375.26 "Игорь Лабутин" вообще, что там как работает.
6375.26 6380.42 "Игорь Лабутин" Вышла в блоге Майкрософта статья про .NET 8 Hardware Intrinsics,
6380.42 6382.78 "Игорь Лабутин" это одна из частей, которая была улучшена в рантайме,
6382.78 6386.22 "Игорь Лабутин" там завезли довольно много всяких разных новых интринсиков.
6386.22 6391.18 "Игорь Лабутин" Читать статью в аудиорежиме про Hardware Intrinsics с невыговариваемыми
6391.18 6395.38 "Игорь Лабутин" названиями этих интринсиков — это дело гиблые, поэтому
6395.38 6398.34 "Игорь Лабутин" если вам интересна эта тема, симды, вот это все,
6398.34 6402.72 "Игорь Лабутин" интринсики, почитайте туда, там в читабельном виде
6402.72 6405.82 "Игорь Лабутин" это гораздо лучше воспринимается.
6405.82 6410.38 "Игорь Лабутин" Внезапный, наверное, кандидат — неправильное слово, внезапная
6410.38 6413.02 "Игорь Лабутин" встреча в разделе «Кратко о разном» — это выпуск
6413.02 6416.98 "Игорь Лабутин" новой Visual Studio 17.9 Preview 2, я сначала хотел ее сделать
6416.98 6420.14 "Игорь Лабутин" отдельной темой, прям Preview 2 вышла, что вот Preview 1 когда
6420.14 6423.42 "Игорь Лабутин" мы две недели назад, словом говоря, записывали выпуск,
6423.42 6427.54 "Игорь Лабутин" и там было Preview 1, а тут уже Preview 2, как бы быстро, чё
6427.54 6433.30 "Игорь Лабутин" как, но в нем ничего нет, вот, ну то есть там есть
6433.30 6437.86 "Игорь Лабутин" какие-то улучшения при плюсы, плюс там есть целых две
6437.86 6442.82 "Игорь Лабутин" фичи для .NET, одна фича называется Auto-Surround with Quotes or Brackets, то
6442.82 6445.90 "Игорь Лабутин" есть вы можете окружить ваше, видимо, селекшен
6445.90 6450.26 "Игорь Лабутин" автоматически скобками или кавычками, это с одной
6450.26 6454.18 "Игорь Лабутин" стороны такая крутая фича, наверное, не знаю, а с другой
6454.18 6458.54 "Игорь Лабутин" стороны Live Property Explorer supports .NET MAUI, еще маленький какой-то
6458.54 6462.50 "Игорь Лабутин" кусочек подержали для MAUI, для Property Explorer, видимо,
6462.50 6465.06 "Игорь Лабутин" в дебаге там в визуальном редакторе, не знаю уж где,
6465.06 6468.54 "Игорь Лабутин" вот и все, что появилось в VS Preview 2, поэтому очень
6468.54 6471.58 "Игорь Лабутин" кратко, скорее всего там просто пофиксили какие-то
6471.58 6473.46 "Игорь Лабутин" много багов, поэтому и вышло.
6473.46 6479.02 "Игорь Лабутин" И, наконец-таки, действительно, NUnit, NUnit вышла версия 4, которую
6479.02 6487.58 "Игорь Лабутин" тоже довольно давно ожидали, и NUnit версия 4, она, как сказать,
6487.58 6492.82 "Игорь Лабутин" она, короче, гораздо более приятная в некоторых аспектах,
6492.82 6498.54 "Игорь Лабутин" но там есть некоторое количество изменений, улучшений, добавлений
6498.54 6499.54 "Игорь Лабутин" и изменений.
6499.54 6501.02 "Игорь Лабутин" Что там поменялось?
6501.02 6506.34 "Игорь Лабутин" Во-первых, там сильно улучшили ассерты, во-первых, ассерты
6506.34 6508.30 "Игорь Лабутин" теперь, раньше ассерты писались как?
6508.30 6511.66 "Игорь Лабутин" Ну, писали ассерт что-нибудь, что-то, equals что-то, и вон
6511.66 6516.02 "Игорь Лабутин" писалось expected 4, but was 42, как у них в примере в статье,
6516.02 6520.26 "Игорь Лабутин" ну и ты так сидишь, думаешь, что expected, что was, и так далее.
6520.26 6523.30 "Игорь Лабутин" Теперь, во-первых, а и была, вот у нас, например, на проекте
6523.30 6526.02 "Игорь Лабутин" всегда была рекомендация, что ни один ассерт не имеет
6526.02 6528.74 "Игорь Лабутин" права быть написанным без дополнительного аргумента,
6528.74 6530.50 "Игорь Лабутин" куда можно было передать, собственно, строчку, которая
6530.50 6533.54 "Игорь Лабутин" описывала семантику того, что здесь сравнивалось,
6533.54 6535.74 "Игорь Лабутин" чтобы было хоть какое-то объяснение, когда вот я
6535.74 6537.70 "Игорь Лабутин" там попадал в Unit Tester, чтобы можно было хоть понять,
6537.70 6540.70 "Игорь Лабутин" особенно если у вас в тесте несколько ассертов, что
6540.70 6544.94 "Игорь Лабутин" как бы в идеальных условиях не рекомендуется, но у нас
6544.94 6545.94 "Игорь Лабутин" так было.
6545.94 6549.90 "Игорь Лабутин" Сейчас, благодаря, значит, магии всяких, как там, caller
6549.90 6554.82 "Игорь Лабутин" name, attribute и так далее, у вас прямо в аутпуте будет
6554.82 6557.46 "Игорь Лабутин" писаться полная строчка ассерта, как он выглядел
6557.46 6558.46 "Игорь Лабутин" в коде.
6558.46 6560.70 "Игорь Лабутин" То есть если у вас написано ассертом что-нибудь, что-то
6560.70 6563.52 "Игорь Лабутин" там, equals что-то, то прямо вот эта строчка будет выведена
6563.52 6570.10 "Игорь Лабутин" а не только expected и actual value, это прямо приятно.
6570.10 6573.70 "Игорь Лабутин" Вот, и даже если вы допишите ваш кастомный текст, то
6573.70 6576.22 "Игорь Лабутин" будет вам и кастомный текст выведен, и эта строчка,
6576.22 6581.78 "Игорь Лабутин" и более того, если у них написано, например, если
6581.78 6585.06 "Игорь Лабутин" вы сравниваете double с какой-то дельтой, то у вас прям будет
6585.06 6588.42 "Игорь Лабутин" написано, что ожидалось такое-то, было такое-то,
6588.42 6591.70 "Игорь Лабутин" дельта была такая-то, а ваше значение больше дельты
6591.70 6594.94 "Игорь Лабутин" на столько-то, грубо говоря, поэтому типа, мол, сорян,
6594.94 6595.94 "Игорь Лабутин" ассерт не выполнен.
6595.94 6605.10 "Игорь Лабутин" Вот, дальше, если вы, если вы, если вы, а вот, я уж совсем
6605.10 6607.42 "Игорь Лабутин" не буду залезать в детали ассертов, давайте пойдем
6607.42 6608.42 "Игорь Лабутин" дальше.
6608.42 6615.30 "Игорь Лабутин" Дальше интересное, называется раздел proper async await, и теперь
6615.30 6619.74 "Игорь Лабутин" вы можете await'ить ассерты, то есть теперь вы можете
6619.74 6624.22 "Игорь Лабутин" написать await assert.that_async, то есть раньше вы писали
6624.22 6626.82 "Игорь Лабутин" assert.that, но если использовать fluent syntax, то теперь можно
6626.82 6632.06 "Игорь Лабутин" написать assert.that_async, и внутри дождаться лямбды, которая
6632.06 6637.74 "Игорь Лабутин" возвращает task, ну и сравните ее с чем-то, что вы возвращаете.
6637.74 6641.94 "Игорь Лабутин" Вот, теперь у вас есть асинхронные ассерты, таким образом вам
6641.94 6644.98 "Игорь Лабутин" не нужно писать, как бы, await до этого, вы можете
6644.98 6648.74 "Игорь Лабутин" спокойненько прям await'ить внутри ассерта.
6648.74 6652.34 "Игорь Лабутин" Поскольку в последних версиях дотнета убрали
6652.34 6657.94 "Игорь Лабутин" фичу thread-абортов, то n-unit был вынужден сказать, эх,
6657.94 6662.74 "Игорь Лабутин" придется нам делать кооператив консолейшн, ну и, соответственно,
6662.74 6666.82 "Игорь Лабутин" теперь есть специальный атрибут, называется канцелавтор,
6666.82 6669.38 "Игорь Лабутин" который позволяет вам там правильно все заканцелить,
6669.38 6670.38 "Игорь Лабутин" вот это все.
6670.38 6672.34 "Игорь Лабутин" Короче, надо читать детали, я особо не вчитывался,
6672.34 6675.06 "Игорь Лабутин" я пока еще на четвертый ньюнит не перехожу, но надо
6675.06 6676.98 "Игорь Лабутин" будет посмотреть, что там с консолейшном тестом,
6676.98 6679.58 "Игорь Лабутин" то есть если вы подвесили тест на вечно, то n-unit надо
6679.58 6682.90 "Игорь Лабутин" как-то его абортить, а thread-аборта нет, непонятно.
6682.90 6686.74 "Игорь Лабутин" Ну, лоббилити, понятно, что они прокачали и разметили,
6686.74 6690.82 "Игорь Лабутин" и, наверное, самое интересное, это платформ-саппорт, n-unit
6690.82 6693.62 "Игорь Лабутин" четвертый поддерживает либо дотнет-фреймворк 462
6693.62 6698.74 "Игорь Лабутин" и новее, ну, это вроде бы нормально, а в обычном дотнете
6698.74 6701.58 "Игорь Лабутин" он поддерживает шестерку и новее, поэтому если вы
6701.58 6705.50 "Игорь Лабутин" сидите, например, на пятерке или на дотнет-коре, то n-unit
6705.50 6706.66 "Игорь Лабутин" четвертый вам не доступен.
6706.66 6711.22 "Игорь Лабутин" Ну, вот такие дела про n-unit.
6711.22 6715.22 "Анатолий Кулаков" Слушай, я бы еще хотел добавить отличную-то статейщику
6715.22 6719.38 "Анатолий Кулаков" на CodeProject, и называется она довольно-таки заманчиво,
6719.38 6727.62 "Анатолий Кулаков" это как написать свой собственный ГЦ на C#, и на самом деле
6727.62 6730.66 "Анатолий Кулаков" очень хорошо, так и плавно вводит в тему, то есть вообще
6730.66 6733.70 "Анатолий Кулаков" что такое garbage-collector, зачем он нужен, какие garbage-collectors
6733.70 6739.42 "Анатолий Кулаков" в каких языках есть, что там происходит, и, соответственно,
6739.42 6742.70 "Анатолий Кулаков" какие задачи стоят перед ним, на чем должен garbage-collector
6742.70 6745.18 "Анатолий Кулаков" фокусироваться, а также такие базовые алгоритмы,
6745.18 6747.74 "Анатолий Кулаков" как что такое compare-and-swap, как его реализовать прямо
6747.74 6752.18 "Анатолий Кулаков" на C#, как его засунуть к определенной структуре,
6752.18 6754.74 "Анатолий Кулаков" то есть в определенной нагрузке, и, соответственно,
6754.74 6758.22 "Анатолий Кулаков" как все это написать все-таки и подключить к вашей программе
6758.22 6761.06 "Анатолий Кулаков" и посмотреть, что оно действительно убедится, что оно действительно
6761.06 6763.90 "Анатолий Кулаков" работает или не работает, поэтому если вы хотели
6763.90 6766.18 "Анатолий Кулаков" как-нибудь написать свой собственный ГЦ, может быть,
6766.18 6769.14 "Анатолий Кулаков" нужный для каких-то конкретных ваших узких целей или просто
6769.14 6772.22 "Анатолий Кулаков" покорить весь мир и написать новый, самый лучший ГЦ
6772.22 6774.94 "Анатолий Кулаков" на свете, не знали, с чего начать, то вот эта статья
6774.94 6778.78 "Анатолий Кулаков" кажется, что даст вам идеальный вообще вход, и в конце ее
6778.78 6781.14 "Анатолий Кулаков" вы даже напишите свой собственный пример, который потом
6781.14 6783.90 "Анатолий Кулаков" можно будет как-нибудь оптимизировать и подгонять
6783.90 6784.90 "Анатолий Кулаков" под ваши реальности.
6784.90 6788.02 "Игорь Лабутин" Подожди, ты хочешь сказать, что ГЦ на C# можно подключить
6788.02 6790.46 "Игорь Лабутин" к нормальной программе на C#?
6790.46 6791.46 "Игорь Лабутин" Круто.
6791.46 6794.02 "Игорь Лабутин" Потому что я помню, у нас же был когда-то на ДотНексе
6794.02 6799.90 "Игорь Лабутин" доклад от Конрада про ZeroGC, но он там, по-моему, его писал
6799.90 6802.06 "Игорь Лабутин" все-таки на плюсах, мне кажется.
6802.06 6806.14 "Анатолий Кулаков" Здесь написано на C#, но может есть какие-то тонкости,
6806.14 6808.98 "Анатолий Кулаков" может через какие-то биннинги или еще что-то, я так быстро
6808.98 6812.02 "Анатолий Кулаков" не нашел каких-то подводных камней, но если что, напишите
6812.02 6813.02 "Анатолий Кулаков" в комментариях.
6813.02 6815.18 "Игорь Лабутин" Просто интересно, надо же понимать, что коду на
6815.18 6819.06 "Игорь Лабутин" C#, который реализует ГЦ, тоже нужен ГЦ.
6819.06 6820.06 "Игорь Лабутин" Не придирайся.
6820.06 6822.74 "Игорь Лабутин" Звучит интересно, на самом деле надо почитать.
6822.74 6824.98 "Анатолий Кулаков" Может они ГЦ написали как бы в отдельном процессе.
6824.98 6828.14 "Игорь Лабутин" А, кстати, точно, слушай, это идея, надо, вот смотри,
6828.14 6830.46 "Игорь Лабутин" у нас есть шарит фреймворк, а теперь давай мы еще сделаем
6830.46 6831.46 "Игорь Лабутин" шарит ГЦ.
6831.46 6832.78 "Игорь Лабутин" Что мы в каждом процессе по ГЦ держим?
6832.78 6834.86 "Игорь Лабутин" Пусть у нас будет один ГЦ на весь сервер, и он будет
6834.86 6839.58 "Игорь Лабутин" это, чистить это каждому процессу с памяти.
6839.58 6841.22 "Анатолий Кулаков" Ну, действительно, да.
6841.22 6843.46 "Игорь Лабутин" И string and turning между процессами.
6843.46 6845.66 "Игорь Лабутин" А что, тп-хедр это вообще… Вообще, еще много всего
6845.66 6847.10 "Анатолий Кулаков" можно переюзать между процессами.
6847.10 6850.02 "Игорь Лабутин" Ну, на самом деле же переюзывается, там, dll и прочие исполнительные
6850.02 6853.06 "Игорь Лабутин" немы код общих библиотек, он же, на самом деле, в одной
6853.06 6855.22 "Игорь Лабутин" копии только загружается, и операционка просто хитро
6855.22 6856.22 "Игорь Лабутин" мапит памяти.
6856.22 6857.22 "Анатолий Кулаков" Ну, вот только вход.
6857.22 6858.22 "Анатолий Кулаков" А вот в рантайме довольно таки мало.
6858.22 6861.02 "Анатолий Кулаков" Но вот если мы только не вспомним про memory grid, вообще
6861.02 6863.62 "Анатолий Кулаков" в рантайме довольно мало переиспользуется, а могло
6863.62 6864.62 "Анатолий Кулаков" бы вполне бы много.
6864.62 6869.58 "Анатолий Кулаков" Тоже самое и string and turning, зачем тебе для каждого
6869.58 6871.54 "Анатолий Кулаков" дотлинного приложения свой собственный.
6871.54 6873.70 "Анатолий Кулаков" Естественно, одного на машину хватит, или даже
6873.70 6875.30 "Анатолий Кулаков" может на сеть, на кластер.
6875.30 6877.70 "Игорь Лабутин" На кластер, точно.
6877.70 6880.18 "Игорь Лабутин" Ну и единственное правильное место, там, не знаю, в Microsoft
6880.18 6884.34 "Игорь Лабутин" облаке или в АВС, где лежит та самая строчка с authorization
6884.34 6885.34 "Игорь Лабутин" header.
6885.34 6886.34 "Игорь Лабутин" Да-да.
6886.34 6887.34 "Игорь Лабутин" И все на нее ссылаются.
6887.34 6888.34 "Игорь Лабутин" Микросервис.
6888.34 6889.34 UNKNOWN Для строчек.
6889.34 6890.34 "Игорь Лабутин" Ладно.
6890.34 6896.82 "Игорь Лабутин" Шуткой, шутками, но на самом деле, да, может быть действительно
6896.82 6897.82 "Игорь Лабутин" интересная тема.
6897.82 6898.82 "Игорь Лабутин" На самом деле, почитать.
6898.82 6899.82 "Игорь Лабутин" Я как-то, да.
6899.82 6902.18 "Игорь Лабутин" Я не успел увидеть эту тему, не почитал.
6902.18 6903.18 "Игорь Лабутин" Надо будет глянуть.
6903.18 6904.18 "Игорь Лабутин" Интересно звучит.
6904.18 6906.62 "Игорь Лабутин" Ну, ладно, на самом деле, на сегодня все.
6906.62 6912.66 "Игорь Лабутин" Мы посмотрели на эксперименты с Async 2 и тем, как можно по-другому
6912.66 6916.58 "Игорь Лабутин" работать с тасками и Async'ами в .NET, если спуститься на
6916.58 6917.58 "Игорь Лабутин" уровень рантайма.
6917.58 6922.62 "Игорь Лабутин" Мы посмотрели на новую библиотечку Service Discovery, которую Microsoft написал
6922.62 6927.78 "Игорь Лабутин" для Aspire, но она вполне юзабельна и без него.
6927.78 6929.94 "Игорь Лабутин" Посмотрели рекомендации Microsoft про то, что делать
6929.94 6932.94 "Игорь Лабутин" с библиотеками, чтобы вы могли разметить их для
6932.94 6934.86 "Игорь Лабутин" совместимости с Native Out.
6934.86 6939.98 "Игорь Лабутин" Узнали про то, как Microsoft запушил Poly, так скажем,
6939.98 6943.58 "Игорь Лабутин" и написал кучку экстенджеров к ней, чтобы удобно их использовать
6943.58 6946.60 "Игорь Лабутин" из стандартных наших ASP.NET'ных пайплайнов.
6946.60 6950.18 "Игорь Лабутин" Посмотрели, как Andrew Lock не смог применить интерсепторы
6950.18 6954.12 "Игорь Лабутин" для Enum2String'ов, узнали, что народ думает про всякие
6954.12 6958.42 "Игорь Лабутин" языки, платформы, базы данных EDE и прочее с точки зрения
6958.42 6959.42 "Игорь Лабутин" разработки.
6959.42 6961.74 "Игорь Лабутин" Ну и кратенько пробежались по всяким там NUnit'ам, новым
6961.74 6965.70 "Игорь Лабутин" студиям и прочим другим мелким и интересным, ну
6965.70 6967.42 "Игорь Лабутин" или может быть не очень интересным, но тем не менее
6967.42 6968.42 "Игорь Лабутин" мелким новостям.
6968.42 6973.18 "Анатолий Кулаков" Да, на этом все, всем спасибо, до новых встреч, не забывайте
6973.18 6975.58 "Анатолий Кулаков" нас шарить, репостить, лайкать и рассказывать
6975.58 6977.50 "Анатолий Кулаков" друзьям и коллегам о нашем подкасте.
6977.50 6979.42 "Анатолий Кулаков" Все, всем до новых встреч, пока.
6979.42 6979.82 "Игорь Лабутин" Пока.
6979.82 6989.82 "Игорь Лабутин" [музыка]
