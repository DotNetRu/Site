0.00 12.48 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Radio.net и у нас сегодня в студии, как всегда, Анатолий Кулаков.
12.48 13.48 "Игорь Лабутин" И Игорь Лабутин.
13.48 14.48 "Игорь Лабутин" Всем привет.
14.48 15.48 "Анатолий Кулаков" Выпуск номер 72.
15.48 20.28 "Анатолий Кулаков" Я не помню, сказал или нет, но я думаю, вы уже в курсе.
20.28 23.52 "Анатолий Кулаков" Каждый из вас наверняка считает все наши выпуски по пальчикам.
23.52 34.44 "Анатолий Кулаков" И я знаю тех, кто считает наши выпуски больше всего, а это Александр Сергей, Владислав, Алексей, Шевченко, Антон, Лазарев, Илья, Гурий, Самарин, Виктор и Руслан Артамонов.
34.44 46.52 "Анатолий Кулаков" Большое спасибо вам, вышеназванным товарищам, а также всем остальным, кто пожелал остаться анонимными и помогает нашему подкасту, не покладая рук на нашем сайте на Boosty.
46.52 61.16 "Анатолий Кулаков" У нас там как раз вышла в прошлый раз статейка о том, какие новости мы хотели бы вам рассказать, но по той или иной причине они уже стали или неактуальными, или для нас они перестали быть интересными.
61.16 65.36 "Анатолий Кулаков" Мы их собрали в такой бэклог и выложили на страничку по подписке.
65.36 67.44 "Анатолий Кулаков" Кому интересно, можете пройтись, посмотреть.
67.44 72.00 "Анатолий Кулаков" И наверное сегодня у нас тоже будут статейки немножко оттуда.
72.00 73.00 "Анатолий Кулаков" Мы затронем наш бэклог.
73.00 77.24 "Игорь Лабутин" Не оттуда, откуда мы выложили, но да, действительно из бэклога.
77.24 81.32 "Игорь Лабутин" Майкрософт ленится, ничего не делает, никаких превью не выпускает.
81.32 83.72 "Игорь Лабутин" Ну, они внутри, конечно, что-то делают.
83.72 94.88 "Игорь Лабутин" Я собирался перед подкастом пойти посмотреть, как там проживает бранч превью, какой-то четвертый у нас должен быть по очереди вроде бы, но что-то забегался, особо не посмотрел.
94.88 101.92 "Игорь Лабутин" Но действительно, я на самом деле ожидал, что к этому выпуску у нас уже будет четвертый превью, но его все еще нет.
101.92 105.52 "Игорь Лабутин" Приходится выискивать новости, вообще понимать, что происходит в данном мире.
105.52 110.76 "Игорь Лабутин" А даже по моей ленте твиттера я бы сказал, что как-то что-то не очень много всего происходит.
110.76 117.20 "Игорь Лабутин" Тишина, затишье, никаких особых там анонсов, новых нугетов, новых библиотек, новых тулов.
117.20 118.20 "Анатолий Кулаков" Почти нету.
118.20 122.16 "Анатолий Кулаков" Смотри, как раз вот интересный момент, когда наконец-то пригодился бэклог.
122.16 133.64 "Анатолий Кулаков" Знаешь, во всей моей практике всегда есть такое место, куда спихиваются таски с надеждой, что когда-нибудь вот у нас будет свободное время, мы дойдем и эту фичечку фишечку наконец-то сделаем.
133.64 141.16 "Анатолий Кулаков" И вот на практике у меня никогда не было такого времени, что у нас наконец-то мы могли бы обратиться к бэклогу и оттуда достать какую-нибудь фишку.
141.16 154.08 "Анатолий Кулаков" А вот здесь, пожалуйста, вот первый раз, хоть где-то будет пример у нас, что вот новостей нету, поэтому можно зайти с честной совестью в бэклог, поискать интересные статейки, которые не доходили руки по той или иной причине, и наконец почитать и осветить.
154.08 168.36 "Игорь Лабутин" Ну, надо сказать, что это не только статейки, это некоторые из них были вполне себе новостями в свое время, но мы, они либо не впихивались в объем выпуска, либо мы считали их не очень важными, и поэтому просто откладывали и про них особо не рассказывали.
168.36 171.32 "Игорь Лабутин" Либо не было времени просто прочитать и понять вообще о чем это.
171.32 174.12 "Игорь Лабутин" Поэтому на дату не смотрите, тут главный смысл.
174.12 185.72 "Игорь Лабутин" Ну да, смысл не поменялся, если бы были какие-то новости, которые уже стали неактуальными, вот они все были выкинуты безжалостно и отосланы в архив.
185.72 191.68 "Анатолий Кулаков" Слушай, а еще мне нравится в некоторых темах, они постепенно копятся.
191.68 209.48 "Анатолий Кулаков" Вот то есть ты одну ссылочку добавляешь, потом видишь, что тема висит, и про нее какая-то новость проскочила, ты ее добавляешь, и у нас некоторые карточки там бывает по 10 ссылок, прям накапливаются, ну то есть можно прям как книгу садиться читать от того момента, как фича появилась, как она зарелизилась, развивалась, потом на нее еще патчи приходили, статьи, комментарии
209.48 217.56 "Игорь Лабутин" писали. Да, но зато готовить такую к выпуску сложнее, ты смотришь, а вот 10 ссылок надо прочитать, ух, и как-то уже не хочешь ее брать в выпуск.
217.56 224.76 "Анатолий Кулаков" Ну ладно, давай, наверное, начинать, чтобы сильно выпуск нам не растягивать.
224.76 226.08 "Анатолий Кулаков" Пойдем посмотрим, что у нас есть.
226.08 227.08 "Анатолий Кулаков" С чего начнем?
227.08 228.40 "Игорь Лабутин" Начнем мы с консольки.
228.40 232.88 "Игорь Лабутин" Одна из… Неожиданно, hello world, прям такой, да?
232.88 245.16 "Игорь Лабутин" Да, довольно старая тема, я ее добавлял в… вот я сейчас специально смотрю на карточку, я ее добавлял в идеи 13 мая 2021 года, а мы сейчас пишемся 14 мая 2023 года, прикинь?
245.16 250.68 "Анатолий Кулаков" Так, ты там сейчас всех слушателей распугаешь такими датами, такими цифрами.
250.68 252.76 "Игорь Лабутин" Нормально, два года, ровненько.
252.76 257.08 "Анатолий Кулаков" Ну смысл в том, что за два года не изменилось ничего, такая консоль, где была, там и осталась.
257.08 262.08 "Игорь Лабутин" Ну да, на самом деле что-то изменилось, поэтому я расскажу, что произошло, в чем вообще была проблема.
262.08 321.88 "Игорь Лабутин" На самом деле она и есть до сих пор проблема, системконсоль, которую мы знаем на namespacing, он был задизайнен во времена, понятное дело, дотнетфреймворка, его особо не меняли, когда переходили на дотнеткор, там были небольшие изменения, насколько я помню, но не особо сильно и много, и поэтому, собственно, его дизайн во многом влиял на его винда, че скрывать, дотнет был на винде, и поэтому во многом все писалось, чтобы просто работало на винде, поэтому не было такого большого различия, например, между консолью и терминалом, то есть во всем мире, там, линуксом, окоси, есть отдельно консоль, есть отдельно терминал, терминалка это, собственно, программка, которая внутри работает с вашим вводом, в смысле клавиатурой и всем остальным, а консоль это, не, наоборот, я вот вечно путаю, кто из них консоль, а кто терминал, короче, одно из них это программка снаружи, другое это программка внутри, одно рисует окошечки, другая, собственно, взаимодействует с вашими процессами.
321.88 333.80 "Анатолий Кулаков" Имплементации, я имею в виду представителей, альтернатив и консолей терминала под линуксом существует огромное количество, и так как под винду один кмд запустил, и все же им пользуешься.
333.80 359.84 "Игорь Лабутин" Ну под винду есть всякие, типа, там, cmdr, и вот эти прочие, но они все на самом деле, если внимательно посмотреть, либо очень страдают для того, чтобы реализовать все то, что реализует cmd, либо на самом деле они реально используют cmd под капотом, просто рисуют его вне экрана гарантированно, и считывают уже с него, просто что там нарисовало приложение, и уже рендерят его вам красиво в своем окошке.
359.84 361.84 "Игорь Лабутин" Там даже такие техники используются.
361.84 368.04 "Игорь Лабутин" Ну так вот, короче, в дотнете все как бы заточено под то, что это винда, и так далее.
368.04 389.24 "Игорь Лабутин" Плюс класс статический, его особо не переопределить, и из-за этого даже всякие, ну вот есть там, допустим, проект, называется Spectre.console, это прям такая очень продвинутая утилитка работы с консолью, и там, ну приходится очень сильно извращаться, чтобы это все хорошо работало в cmd и в прочих других вещах.
389.24 402.88 "Игорь Лабутин" А еще есть такая штука под названием, ох, сейчас боюсь наврать, gui.cs, по-моему, это такой простой набор кода от Мигель де Иказа, который позволяет рисовать такой GUI в текстовом стиле.
402.88 411.24 "Игорь Лабутин" Там тоже прям отдельные заморочки, как чтобы это работало нормально с консолью, просто потому что консоль вот у нас такая кривая.
411.24 425.64 "Игорь Лабутин" И в 21 году, собственно, когда мы это добавили, Адам Ситник создал ishu, точнее, тогда это было ishu, потом это преобразовалось с discussion, про то, что мол, давайте что-нибудь сделаем с этим.
425.64 446.20 "Игорь Лабутин" И что-то было сделано, то есть с тех пор у нас успел выйти седьмой .NET, и мы на самом деле очень подробно рассказывали про то, как Адам долго, упорно и небезуспешно менял поведение консоли .readkey.
446.20 460.36 "Игорь Лабутин" Если помните, я там рассказывал, как бы были сложности про обработку всяких там ctrl-c, ctrl-v и прочих ctrl-z, как это все сложно работает, как там все эти специальные клавиши, специальные последовательности нужно обрабатывать, на разных операционках все по-разному.
460.36 475.52 "Игорь Лабутин" В общем, это была большая работа, она проделана, она зарелижена, но там, если я вот сейчас боюсь наврать, там по-моему 22 проблемы было обозначено, из них по-моему 9 только успели пофиксить к семерке, остальные пока ждут своего часа.
475.52 481.08 "Игорь Лабутин" Они все помечены как future backlog, но потихонечку делаются, все попадет что-то восьмое.
481.08 493.92 "Игорь Лабутин" Там, например, есть всякие интересные штуки, например, там одна из проблем называется то, что у нас right line сейчас нетридсейфовый, т.е. если вы делаете из двух тридов right line, то строчки могут, так сказать, смешаться.
493.92 497.12 "Анатолий Кулаков" Ну как нетридсейфовый, оно не падает, просто смешиваете
497.12 509.32 "Игорь Лабутин" буквки, но работает все нормально. Ну вот они, одна из идей сделать так, чтобы right line были такие, как сказать, атомарные, наверное, если ты сказал right line, то он не будет перемежаться с другими right line.
509.32 514.68 "Игорь Лабутин" Понятно, что это можно сделать каким-то простым способом, локами внутренними, но это тогда замедлит все.
514.68 518.12 "Анатолий Кулаков" Да там, мне кажется, вся консолька и так на локах сделана, там уже сильнее не замедлится.
518.12 531.24 "Игорь Лабутин" Не, там консолька сделана хитрее, там же консолька сделана на внутренней, т.е. все вот эти right line и прочие, они же пишут во внутреннюю очередь, которая под локом, но только под right локом и относительно быстрым.
531.24 539.40 "Игорь Лабутин" И есть разгребающий read lock, ну короче, и разгребающий с другого конца, соответственно, поток, который все это отдельно пишет.
539.40 547.92 "Игорь Лабутин" Там, в общем, архитектура на самом деле консольки, если вы думаете, что она простая, загляните в исходники вот систем консоли дальше, что там делает right line, там прям очень интересно.
547.92 556.92 "Игорь Лабутин" Я один раз отлаживал, что он там делает, и с тех пор, да, вспоминаю это место такое, очень запутанное, надо сказать.
556.92 579.76 "Игорь Лабутин" Плюс у них на самом деле довольно много проблем, именно с точки зрения вот той самой там консоли versus terminal, потому что вот эти самые консоль read key и все остальные методы работы с консолью, они же используются в том числе, например, когда вы делаете какое-нибудь там интерактивное приложение в консольке, чтобы там вот ввод какой-то пользовательский принимать и так далее.
579.76 590.88 "Игорь Лабутин" И там становится важным, чтобы, например, когда вы делаете консоль read line, у вас там правильно работала всякая навигация по словам, ну клавиши влево-вправо условно минимально работали, и вот это все.
590.88 597.84 "Игорь Лабутин" Вот, там с этим сейчас пока проблемы, поэтому это все, они будут стараться фиксить.
597.84 613.76 "Игорь Лабутин" Посмотрите, последите, я бы сказал, если вы как-то работаете с консолькой, там есть вот у нас в шоу-ноутах будет ссылка на объемную щищу, и там есть просто ссылочки на все разные проблемы, которые были найдены, которые нужно все еще пофиксить, про которые они знают, по крайней мере, что нужно пофиксить.
613.76 614.76 "Игорь Лабутин" Вот так скажу.
614.76 631.80 "Игорь Лабутин" Вот, но когда я добавлял эту карточку, на самом деле я тогда хотел добавить другую тему, про которую я тогда на самом деле читал, и которая до сих пор актуальна, я ее нашел отдельно, и она тоже связана с консолькой, но немножко с другой стороны.
631.80 632.80 "Игорь Лабутин" Это command line API.
632.80 643.32 "Игорь Лабутин" То есть, смотрите, у нас есть, ну естественно, наша функция main, куда передается массив строчек args, из которого можно получить все ваши аргументы.
643.32 669.08 "Игорь Лабутин" Но, как правило, вам хочется какой-то более продвинутой обработки аргументов, вам хочет то, что иногда называется по-ex style аргумент, когда вы можете указать флажки различные, либо опции с ключиками, в смысле, со значениями, причем поддержать и длинную, и короткую форму, и все это, чтобы работало желательно автоматически, и опции можно было указывать в любом порядке, и писать это все вручную на самом деле очень заморочено.
669.08 672.52 "Игорь Лабутин" При этом есть несколько сторонних пакетов для этого.
672.52 688.44 "Игорь Лабутин" То есть, есть, например, пакет, которым я пользуюсь обычно, когда мне нужно такое сделать, он называется на GitHub, это command-line-parser/command-line, репозиторий довольно популярный, 4к звездочек, и регулярно обновляется.
688.44 703.20 "Игорь Лабутин" Есть еще command-line-utils, он чуть менее популярным и чуть реже обновляется, но тоже, по-моему, я в одном из проектов его использовал, он попроще, в смысле, что он позволяет поменьше всех разных кастомизаций, но для простых сценариев тоже был неплох.
703.20 714.72 "Игорь Лабутин" Но Microsoft решил, что как с JSON, с реализацией, все хорошо, но это надо все-таки сделать свое, а то как же мы так, базовая библиотека и без возможности парсинга command-line.
714.72 715.72 "Игорь Лабутин" Нехорошо.
715.72 716.72 "Игорь Лабутин" И сделал это.
716.72 717.72 "Игорь Лабутин" Ну как, решил это делать.
717.72 723.72 "Игорь Лабутин" Решили они это 5 лет назад, приблизительно.
723.72 731.36 "Игорь Лабутин" Но, как это, скоро сказка сказывается, но не быстрые библиотеки пишутся.
731.36 738.12 "Игорь Лабутин" Короче, года 2 они этим занимались, или 3, как я понял, вот тут я запутался, но в общем, сколько-то они думали, а потом сколько-то писали.
738.12 744.96 "Игорь Лабутин" Писали они это где-то внутри, внутри, внутри, никому ничего не показывали, и потом выкатили со словами, ну вот-вот-вот, мы это будем релизить в семерке.
744.96 747.00 "Игорь Лабутин" И все такие, че?
747.00 772.92 "Игорь Лабутин" То есть там прям был, наверное, неделька что-ли такого шторма легкого в Твиттере, я уж не знаю, что там было на Reddit и прочих сайтах, про то, что как бы, чуваки, вы взяли концепции из, по-моему, типа всех возможных существующих команд-лайн парсеров в Нотетнете, причем из каждого вы взяли худшие, и получили, значит, API, который вы собираетесь включить в BCL.
772.92 773.92 "Игорь Лабутин" Вы че, серьезно?
773.92 779.56 "Игорь Лабутин" А те как-то такие, ну вы типа ничего не понимаете, все вот это вот, все.
779.56 785.56 "Игорь Лабутин" Но на самом деле, push был, на самом деле, довольно сильный, что в итоге произошло следующее.
785.56 797.96 "Игорь Лабутин" Значит, главный мейнтейнер, ну не мейнтейнер, а такой какой-то координатор, наверное, вот этого всего процесса, это та самая Кэтлин Доллард, которая, помнишь, нам нравилась, когда она отвечала на всякие вопросы, почему бы и не
797.96 801.80 "Анатолий Кулаков" это? Да, очень правильно наученная, да, для ответов.
801.80 815.08 "Игорь Лабутин" Она, короче, может быть, ее тоже привлекли именно вот в качестве такого паблика лица, она, конечно, написала отличные иши в репозитории, это все делается в отдельном репозитории, со словами, что… Решатель негатива, да, решатель проблем.
815.08 834.72 "Игорь Лабутин" Ну, возможно, может быть, она и исходно это все травила своим, я в этом не разбирался, но она написала такой большой пост со словами, что типа, короче, мы думали, что все будет просто, и самая сложность будет, собственно, написать нормальный парсер, ну, который будет все эти минус-минусу опции обрабатывать, да, там, понимать, где там длинная опция, где короткая.
834.72 841.28 "Игорь Лабутин" Ну, короче, выяснилось, что парсер, это типа там 10% проблем, да, остальные 90% это то, как комьюнити его использует.
841.28 843.00 "Игорь Лабутин" И кому че надо.
843.00 849.72 "Игорь Лабутин" Внезапно оказалось, что разным кускам компаний, разным комьюнити, ну, в смысле, разным частям комьюнити нужно разное.
849.72 852.08 "Игорь Лабутин" Кто бы мог подумать.
852.08 865.76 "Игорь Лабутин" Кому-то нужна простота конфигурации, кому-то нужны сложные варианты, кому-то нужна поддержка вот этих вот под команд, ну, типа, вот там в дотнетуле у нас есть, да, есть там дотнет, там какой-нибудь workload install, и дальше уже опции идут.
865.76 872.52 "Игорь Лабутин" Вот, кому-то такое нафиг не нужно, и если вы по дефолту будете требовать такое, то это как бы всех раздражает.
872.52 884.60 "Игорь Лабутин" В общем, они для себя выяснили, что вообще бывает много разных дизайнов для командлайн-приложений, ну, так сказать, что, мол, не все приложения одинаковые, не все такие как дотнет, экзе, внезапно.
884.60 890.56 "Игорь Лабутин" И по результату они сделали два вывода, так скажем.
890.56 904.24 "Игорь Лабутин" Во-первых, они провели довольно качественный API-ревью, где описали, ну, в том числе, я так понимаю, привлекая, так сказать, комьюнити, в смысле, расскажите нам, где там проблемы вы видите, и как вы собираетесь все использовать.
904.24 910.04 "Игорь Лабутин" Это был большой API-ревью-ишью, где описали 56 проблем, которые они нашли.
910.04 916.48 "Игорь Лабутин" Напоминаю, это было API, которое было со словами типа "ща, мы его включим в семерку для релиза" практически.
916.48 918.68 "Игорь Лабутин" 56-шью они там нашли.
918.68 936.12 "Игорь Лабутин" Они притащили в этот проект, помимо тех, я так понимаю, там что-то двое или трое каких-то чуваков писало, притащили людей уровня Адама Ситника и других, вот, из команды BCL со словами "давайте вы типа справитесь, поможете".
936.12 938.12 "Игорь Лабутин" Хорош пилить фичи, давайте консольку посадим.
938.12 944.08 "Игорь Лабутин" Да, и они сказали "не-не-не-не-не, в общем, мы, короче, непонятно когда чего".
944.08 1017.64 "Игорь Лабутин" Эта штука до сих пор в превью стоит, то есть у нее есть документация на Microsoft Learn, потому что они же собирались все релизить, и поэтому оно есть официальная документация Microsoft Learn, где большими буквами, ну или не очень большими, написано, что типа "версия 2.0", потому что 1.0 вот была та самая, стоит и превью, превью бета 4, по-моему, у них сейчас называется, или бета 5, и нет никаких пока планов, когда они это все срелизят окончательно, потому что из этих 56 проблем решены, по-моему, порядка 40, ну и еще закрыто, по крайней мере, на GitHub, то есть еще 16 требуют какого-то решения, плюс я почитал GitHub, там народ как бы прям пишет, и это не работает, и вот это не работает, а че, вы тут что-то какую-то фигню сделали, и вот тут у вас какое-то странное решение, в общем, там, судя по всему, еще будет долг и упор, так что пока пользуйтесь Command Line Parser, и ждите, когда Microsoft притащит официальный систем Command Line, все живет на InSpace систем Command Line, то есть если вы вдруг, ну можете попробовать, на самом деле, может вам зайдет, я бы так сказал, но будьте готовы, что это все превью, и когда будет оно финально готово, никто не знает, может к восьмерке успеют добить, а может и не успеют, не знаю, кто знает.
1017.64 1020.96 "Игорь Лабутин" Примерно такие дела у нас с консолькой и вокруг нее.
1020.96 1039.60 "Анатолий Кулаков" Слушай, ну обидно действительно, тема такая, которая должна была еще появиться в первых дотнетах, потому что, ну как минимум в первых корах, давай так, потому что там все начинали всегда с консольки, у консольки есть по-любому аргументы, как ни крути, и то есть стандартная библиотека просилась, вот почему появилось очень много сторонних.
1039.60 1047.84 "Игорь Лабутин" Так вот, ну видишь, я не вижу проблемы, что есть сторонние, то есть вот есть этот Command Line Parser, он на самом деле очень классный, он позволяет сделать много чего.
1047.84 1076.28 "Игорь Лабутин" Он может быть не такой простой, что ли, ну я не знаю, действительно наверное можно придумать еще более простой API для простых случаев, но я в общем не, ну то есть я понимаю желание втянуть к себе, ну видимо это им нужно самим в том числе, чтобы какой-нибудь развесистый Command Line хороший писать для своих тулов, ну потому что у них сейчас довольно много всего стало ориентировано с точки зрения Command Line, развесистый всякий дотнет тул, да, появился и так далее.
1076.28 1079.92 "Игорь Лабутин" И им самим понятно, что проще написать, если у них будет своя собственная библиотека.
1079.92 1083.36 "Игорь Лабутин" Но не знаю, не знаю.
1083.36 1105.36 "Анатолий Кулаков" Видишь, с другой стороны кажется, что это одна из тех штук, которые Microsoft когда не сделала, оставила свободную нишу, свободный рынок и появились очень классные альтернативы, которых в принципе, не знаю, я лично не наблюдал вот те библиотечки, которые у нас там появились такие Command Line Parsers, я лично не видел, что в других языках такие делали.
1105.36 1113.72 "Анатолий Кулаков" То есть, кажется, что это такой глоток свежей мысли, которые там были применены всякие приемы, структуры, описания, автогенерация всего подряд.
1113.72 1127.88 "Анатолий Кулаков" В общем, очень много различных, абсолютно с разных сторон заходилось идей типа генерации из документации командных аргументов и наоборот по аргументам документации там автоматическое заполнение, флажочки, в общем, много там светлых каких-то мыслей было.
1127.88 1138.08 "Анатолий Кулаков" И может быть это как раз таки хорошо, что у нас такая ниша, которая всем нужна, была не занята вегемоном, и поэтому свободные авторы могли каким-то образом себя проявить.
1138.08 1150.72 "Анатолий Кулаков" Но действительно хотя бы какой-то банальный, какой-то простой парсер из коробки быть должен, потому что ситуация довольно необходимая каждому практически консольному проекту.
1150.72 1157.96 "Анатолий Кулаков" Зачем бы на месте Микрософта сделать что-нибудь такое простое, нормальное для простых кейсов, а что для сложных уже можно ставить стороннюю библиотеку.
1157.96 1172.40 "Игорь Лабутин" Вот мне кажется, я с тобой согласен, что такой вариант с простыми кейсами был бы, может быть, оптимален, ну с нашей внешней стороны, но кажется, что если им самим нужны сложные кейсы для внутренних тулов, ну что, они будут внешнюю библиотеку тянуть?
1172.40 1183.88 "Анатолий Кулаков" Ну для внутренних тулов, конечно, ну то есть в BCL ты бы не тяни, это не твоё, а вот если у нас .NETXD будет юзать какую-нибудь внешнюю библиотеку, да кто об этом узнает даже.
1183.88 1187.16 "Анатолий Кулаков" Там же никаких конфликтов не будет, всё хорошо.
1187.16 1189.88 "Игорь Лабутин" Ну неаккуратненько как-то внешнюю библиотеку юзают.
1189.88 1204.40 "Анатолий Кулаков" Ну вот когда, смотри, Newton Soft JSON юзали, вот это неаккуратненько было, когда у тебя в MVC потащили внешнюю библиотеку, которая там 100% будет твоим приложением тоже использоваться, и там куча конфликтов, версий и всего вот этого страшного.
1204.40 1217.80 "Анатолий Кулаков" Вот там проблемы явные и очевидные, но если бы это был не фреймворк, а отдельный .EXE-шник, допустим, тот же самый .NETXD, поюзал бы он Newton Soft JSON, да может он его юзает под капотом, я вообще без понятия, никаких проблем здесь нет.
1217.80 1235.00 "Игорь Лабутин" Угу, ну непонятно, ну видишь, здесь как всегда, с одной стороны, как мы обсуждали много раз, мы вроде как ждём от Microsoft полноценной инфраструктуры, чтобы не надо было искать на Nuget чего-нибудь, ты взял бы цель, и у тебя всё есть, всё из коробки.
1235.00 1250.52 "Игорь Лабутин" А с другой стороны, ну как-то тоже обидно брать, например, ну вот предположим, что интерфейс там систем, ой, не систем, а коммодлайн парсера, всем нравится, взять его и просто к себе затащить, ну тоже, наверное, обидно будет автору.
1250.52 1254.88 "Анатолий Кулаков" Не, ну всё в любом случае тащить не надо, это будет уже какой-то оверкил.
1254.88 1260.60 "Анатолий Кулаков" В общем, нужны какие-то базовые вещи, а всё сложное пусть комьюнити предоставляет, может она хоть расшевелится.
1260.60 1264.16 "Игорь Лабутин" Ну, может быть, но вот пока Microsoft, этого не следует.
1264.16 1270.24 "Анатолий Кулаков" Хорошо, ждём консольку, надеюсь, будет какое-то хорошее красивое решение, я думаю, что ребята сообразят.
1270.24 1275.88 "Игорь Лабутин" Ну, Адаму идея должна помочь, я так понимаю, что он сейчас на этом специализируется, похоже.
1275.88 1278.40 "Анатолий Кулаков" Ну, тем более, специалист по консоли будет.
1278.40 1279.40 "Игорь Лабутин" Да.
1279.40 1290.04 "Игорь Лабутин" Давай дальше, дальше у нас из новостей уже действительно прям совсем новостей свеженьких, свеженьких, это очередные род мапы от команды SharperRider.
1290.04 1304.24 "Игорь Лабутин" Тут не так много новостей, ну как не так много, это же род мапы, поэтому что из этого будет сделано и что-то будет сделано поверх этого, тоже непонятно, потому что они смотрят на то, что творит команда, и вероятно, также как и мы ждут превью, чтобы понять, что там будет происходить.
1304.24 1321.32 "Игорь Лабутин" Но тем не менее, решарпере пока предполагается, что они будут поддерживать превью фичи 12-го C#, это дефолтные параметры в лямбдах, primary конструкторы и алиасы для любых типов, мы, кстати, по-моему, всё это не очень обсуждали, надо будет как-нибудь вернуться и посмотреть.
1321.32 1323.32 "Игорь Лабутин" Да нет, ну в превьюшках же было, кажется.
1323.32 1331.60 "Игорь Лабутин" Ну, что-то было, ну короче, посмотрим, надо будет, ждём следующего превью, если там ничего не будет про C#, надо может вернуться, ну в репозиторий сходить, посмотреть, что там происходит.
1331.60 1333.84 "Игорь Лабутин" Наверняка же что-нибудь происходит за эти месяцы.
1333.84 1335.64 "Анатолий Кулаков" Ну всё равно это всё мелочи, мелочи.
1335.64 1337.08 "Анатолий Кулаков" Где наша главная фича?
1337.08 1339.68 "Анатолий Кулаков" Должны же какую-то для маркетинга главную фичу выпустить.
1339.68 1340.68 "Анатолий Кулаков" Вот мы её ждём.
1340.68 1343.68 "Игорь Лабутин" Ну, к ноябрю дождёмся.
1343.68 1360.88 "Игорь Лабутин" Ладно, перформанс решарпере улучшится, мы как-то, по-моему, обсуждали штуку под названием асинхронного стайпинга, то есть так, чтобы все события, которые происходят по мере вашего печатания, не синхронно обрабатывались в главном траде, а всё-таки как-то асинхронно немножечко.
1360.88 1376.00 "Игорь Лабутин" И работа над этим продолжается, плюс они начали работу, ну или запланировали, давайте так, работу над асинхронной загрузкой компонентов в Visual Studio, то есть когда вы открываете проект, чтобы если решарпер что-то нужно грузить в бэкграунде, он делал это асинхронно.
1376.00 1377.08 "Игорь Лабутин" В Visual Studio будет более отзывчиво.
1377.08 1384.92 "Игорь Лабутин" Фича, которую они анонсировали вот в этом, ну я раньше её не встречал, называется предиктив дебанкер.
1384.92 1397.60 "Игорь Лабутин" Это такая штука, не знаю, звучит интересно, то есть когда вы остановились на точке останова, в принципе решарпер достаточно умный, чтобы посмотрев на значения например текущих переменных, прикинуть куда дальше пойдёт исполнение.
1397.60 1401.64 "Игорь Лабутин" Ну то есть типа, выполнится следующий if или следующий else.
1401.64 1421.48 "Игорь Лабутин" И он вот обещается, что он будет там затемнять те куски кода, которые по его мнению больше не будут выполняться на следующем шаге, предсказывать эксепшены, которые там будут происходить, смотреть будущие значения переменных, ну в общем, возможно будет интересно, надо будет посмотреть, когда доберёмся, хотя решарпер не пользуемся.
1421.48 1422.48 "Игорь Лабутин" Будем ждать статьи.
1422.48 1429.12 "Анатолий Кулаков" Да, интересно, насколько это практично будет или нет, вот тут я не могу предсказать, но звучит забавно, как минимум интересно было бы посмотреть.
1429.12 1458.32 "Игорь Лабутин" Ну я помню, что я ловил себя на мысли, типа вот я стою на каком-то breakpoint перед if, и мне, чтобы понять условно куда пойдёт исполнение, я, ну в какой-нибудь intermediate до окошка, закидывал какие-нибудь кусочки выражения, чтобы понять, вот оно сейчас вычислиться в true/false, или ну чуть более сложное, если там не простой if, да, true/false, чуть более развесистый, чтобы понять, какая ветка какого-нибудь хитрого свеча выполнится.
1458.32 1463.32 "Анатолий Кулаков" Да, я тоже часто из выражения языкчика забрасывал, чтобы посмотреть, куда оно разрезалось.
1463.32 1467.12 "Игорь Лабутин" А тут он тебе прям хайлайтом отметит, вот ещё пойдёшь туда.
1467.12 1469.64 "Игорь Лабутин" Ну, хорошо, пойду туда.
1469.64 1474.80 "Анатолий Кулаков" Ну и чего ты привязываешь это к решаперу, это же ядро решапера, этим же будет пользоваться и райдер.
1474.80 1477.48 "Игорь Лабутин" А вот в райдере, кстати, этого не обещано.
1477.48 1482.16 "Игорь Лабутин" Ну, значит сначала реализуют решапер, а потом поддержат райдер.
1482.16 1487.00 "Игорь Лабутин" Хотя, может быть, это надо, там будет ещё как-то UI-чики хитрые поддерживать, чё ж знать, ладно, не важно.
1487.00 1516.60 "Игорь Лабутин" Решапер ещё добавит нормальный, ну точнее, импровид поддержку этих самых stylecopic аналайзеров, которые, пакет есть такой stylecopic аналайзер, там что-то там сотни, больше сотни аналайзеров, которые иногда используются в проектах, они, я не знаю, насколько они популярны, честно говоря, но вроде как довольно популярная штука, и он будет автоматически детектить, что там используется, читать про описание этих правил из Editor Config, их там можно настраивать, в общем, будет больше совместим с обычными аналайзерами.
1516.60 1565.60 "Игорь Лабутин" А райдер, соответственно, та же фигня про C# 12 поддержка, переделывают Build Tool Window, чтобы там пооптимизировать UI, UX и Performance, там фризы были раньше, могли быть, которым надо убирать, импровменты в UI, новый Solution Wizard, GameDev, если вам зачем-то это нужно тоже, планировались, мы уже обсуждали, планировался в прошлый релиз поддержка сеттинг-хинков, чтобы ваши сеттинги синхронизировались нормально между всеми вашими IDE-шками, но не успели, будут делать сейчас, для MAUI Hot Reload, и из ReSharper в райдер перенесут то, как работает Find Usages Advanced, типа там он работает более advanced, в ReSharper будет такой же advanced в райдере теперь.
1565.60 1573.44 "Игорь Лабутин" Ну вот, как-то так, так что ждем, но надо понимать, что это roadmap, что реально получится, ну когда зарелизит, обсудим новости.
1573.44 1605.92 "Анатолий Кулаков" Ну, отлично, погнали еще новости, у меня тут из 2021 года еще один приветик, хотелось с вами обсудить новую концепцию, блин, даже не концепцию, а парадигму как купит, но она из себя представляет как альтернативу солида, ну как бы нельзя обсуждать купит без солида, а я так вспомнил, что солид-то мы в нашем подкасте никогда не обсуждали, и такая базовая, большая, интересная, необходимая для любого собеседования тема, должна быть поднята, ты как считаешь?
1605.92 1616.00 "Игорь Лабутин" Да, обязательно должна быть поднята, я просто так немножко напрягся, когда ты сказал, что новости из 21 года и солид, ну как бы, кажется, это чуть пораньше.
1616.00 1659.44 "Анатолий Кулаков" Не, солид совсем пораньше, это где-то 2000-е годы, дядюшка Роберт Мартин, наверное, сначала в своих статьях, в своих лекциях, потом уже в книге твердо укоренил несколько солид принципов, ну как несколько, пять, и эти принципы, они описывали качество объектно ориентированной программы, и вот эти принципы были настолько, не знаю, сказать понятные, это солгать, наверное, настолько простые, может быть, и казалось бы, применимы, и очень распространенные, что стали безумно популярными, и с тех самых пор, как только они появились, мне кажется, на любом собеседовании такая штука спрашивается, ты не знаешь, ты спрашиваешь своих героев про солид?
1659.44 1660.44 "Игорь Лабутин" Особо нет.
1660.44 1661.44 "Анатолий Кулаков" Нет?
1661.44 1662.44 "Игорь Лабутин" Нет.
1662.44 1663.44 "Игорь Лабутин" Нет.
1663.44 1698.76 "Игорь Лабутин" Но у нас на самом деле одна из частей — это код-ревью того кода, который мы выдаем, и там, ну, так сказать, во время этого ревью это натурально получается обсудить, я бы так сказал, там есть некоторые ошибки, которые, ну, немножко там про single-responsibility, немножко про, ну, наверное, про интерфейс, ну хотя про интерфейс, segregation чуть-чуть, наверное, можно отнести туда, ну, короче, там можно вывести на разговор о солиде, как правило, мы вот оттуда где-то, если кто-то что-то упоминает про это, но вы тут нарушаете солид, мы такие… Ну всё, ты попал.
1698.76 1699.76 "Игорь Лабутин" Да-да.
1699.76 1700.76 "Игорь Лабутин" Рассказывай.
1700.76 1704.88 "Игорь Лабутин" Ну раз ты сказал это слово, расскажи, что это, да, если бы не сказал, обошёлся бы без вопросов.
1704.88 1723.24 "Анатолий Кулаков" Мне тоже кажется, вот так переосмысливая солид, мне кажется, что настолько он сейчас влился в повседневный код, настолько гармонично представляется всем тем синтексисом и подходами, которые у нас устоялись в языке и в платформе, что учить его как бы как отдельный принципе может быть и не нужно.
1723.24 1734.56 "Анатолий Кулаков" Но если мы вернёмся в далёкие 2000-е годы, раньше это было не так, раньше вот люди ещё не понимали, зачем что-то делить, ответственности группировать, зависимости и так далее.
1734.56 1737.48 "Анатолий Кулаков" Поэтому тогда это было таким хорошим откровением.
1737.48 1744.28 "Анатолий Кулаков" И тогда на рынке царствовали как раз-таки объектно-ориентированные языки в большинстве своём, такие как C#, Java, C++.
1744.28 1753.92 "Анатолий Кулаков" И в принципе, когда Роберт Мартин расформулировал эти принципы, он опирался именно на мейнстрим, на мейнстрим языков.
1753.92 1759.80 "Анатолий Кулаков" И с тех пор, нужно сказать, что многое поменялось.
1759.80 1767.76 "Анатолий Кулаков" И вот чтобы не обсуждать чистый солид, я как раз-таки нашёл статейку, которая немножко пытается солид за уши подтянуть к современной реальности.
1767.76 1772.12 "Анатолий Кулаков" Давайте как раз и посмотрим, как у неё это получается.
1772.12 1775.68 "Анатолий Кулаков" Прежде всего, что поменялось с тех магнатых годов?
1775.68 1781.56 "Анатолий Кулаков" Появились, даже не появились, а стали популярными динамические языки программирования, прежде всего.
1781.56 1786.92 "Анатолий Кулаков" Как я уже сказал, Роберт Мартин прежде всего смотрел там на плюсы, на Java, на C#.
1786.92 1794.32 "Анатолий Кулаков" А в наше время цветёт и пахнет питон, уже отживает, наверное, свой век Ruby и взрывается JavaScript.
1794.32 1804.64 "Анатолий Кулаков" То есть такие динамические языки программирования, которые тоже довольно популярны в некоторых аспектах, в некоторых областях намного популярнее, чем объектно-ориентированные статические языки.
1804.64 1810.16 "Анатолий Кулаков" И они как раз-таки не были учтены, когда формулировались принципы солида.
1810.16 1814.96 "Анатолий Кулаков" Также нужно сказать, что довольно хорошо поднялось функциональное программирование.
1814.96 1820.60 "Анатолий Кулаков" Нельзя сказать, что оно так же выстрелило, как JavaScript, но стало намного более заметнее.
1820.60 1840.80 "Анатолий Кулаков" Многие парадигмы перекочевали в наши стандартные языки, если вспомнить те же самые linq, лямбды, замыкания, фильтры, кондишены, экшены, фанки и прочие эти вещи функциональные, то они уже настолько плотно влились в нашу повседневную жизнь, что невозможно представить программирование на C# без функциональных аспектов.
1840.80 1841.80 "Анатолий Кулаков" И это прекрасно.
1841.80 1846.32 "Анатолий Кулаков" За эти годы сильно расцвел open source.
1846.32 1857.00 "Анатолий Кулаков" И то, что раньше приходилось скрывать за какими-нибудь там корпоративными стандартами или сложно подчиненными лицензиями, в общем, сейчас стало проще.
1857.00 1867.28 "Анатолий Кулаков" Сейчас можно найти исходники, продебажить, посмотреть, предложить pull request и это тоже может влиять на те принципы, с помощью которых вы пишете программное обеспечение.
1867.28 1876.40 "Анатолий Кулаков" Также появились и популяризировались, правильнее сказать, микросервисы и вообще программное обеспечение, которое вам дается где-то на стороне.
1876.40 1878.24 "Анатолий Кулаков" То есть программное обеспечение как сервис.
1878.24 1893.16 "Анатолий Кулаков" То есть раньше вы могли запускать свое приложение только как какой-нибудь большой кусок запускабельного файла со всеми своими зависимостями в одном дистрибутиве, на одном компьютере.
1893.16 1901.16 "Анатолий Кулаков" То сейчас в большинстве случаев это будут какие-то маленькие сервисы, скорее всего распределенные на многих каких-то нодах с различными базами данных.
1901.16 1907.88 "Анатолий Кулаков" В общем, тоже вот эта парадигма распределенных микросервисов, она немножко может пошатнуть принципы, по которым пишется ваша программа.
1908.74 1918.14 "Анатолий Кулаков" Но так как мир меняется, с другой стороны есть вещи, которые всегда стабильны, никогда не изменятся и до сих пор становятся актуальными.
1918.14 1922.38 "Анатолий Кулаков" И они тоже влияют на принципы разработки программного обеспечения.
1922.38 1928.86 "Анатолий Кулаков" Прежде всего это то, что мы пишем код все-таки один раз, а читаем его много-много-много раз.
1928.86 1931.54 "Анатолий Кулаков" Эта парадигма до сих пор не изменилась.
1931.54 1942.42 "Анатолий Кулаков" И пока хорошо задокументированный код, понятный код, выразительный код, он намного важнее, намного главнее, чем та скорость, с которой вы будете его писать.
1942.42 1947.70 "Анатолий Кулаков" Именно поэтому больше времени нужно уделять продумыванию дизайну вашего кода.
1947.70 1953.50 "Анатолий Кулаков" Дальше у нас код по-прежнему организуется в классы или ну какие-то подобия групп.
1953.50 1960.94 "Анатолий Кулаков" Давайте так, все шарпи - это классы, это могут быть модули, это могут быть отдельные файлы какие-нибудь, может быть даже целые директории.
1960.94 1965.22 "Анатолий Кулаков" В общем, нам нужен способ группировки кода в какие-то понятные модули.
1965.22 1967.42 "Анатолий Кулаков" Это тоже никуда не делать.
1967.42 1977.78 "Анатолий Кулаков" И до сих пор мы хотим скрывать некий код от внешнего наблюдателя и наоборот показывать, выставлять какой-то API для внешнего наблюдателя.
1977.78 1982.42 "Анатолий Кулаков" То есть у нас должен код делиться на тот, который мы видим, и на тот, который мы не видим.
1982.42 1984.78 "Анатолий Кулаков" И это по-прежнему осталось так, никуда не делать.
1984.78 1994.30 "Анатолий Кулаков" А теперь давайте повторим немножко принципы солида и разберем немножко каждого из них и посмотрим изменилось ли он со временем, или не изменился.
1994.30 2000.54 "Анатолий Кулаков" И первый принцип - это SRP - Single Responsibility Principle, то есть принцип единственности ответственности.
2000.54 2006.62 "Анатолий Кулаков" И звучит он следующее - у вас должна быть только одна причина для того, чтобы поменять класс.
2006.62 2010.26 "Анатолий Кулаков" То есть в принципе довольно все логично.
2010.26 2017.06 "Анатолий Кулаков" То есть если вы что-то поменяли в одном месте, очень бы сильно не хотелось, чтобы в другом месте все развалилось.
2017.06 2020.66 "Анатолий Кулаков" Поэтому чем меньше, чем гранулярный код у вас будет, тем лучше.
2020.66 2037.06 "Анатолий Кулаков" Если вы представите какой-нибудь мега-сервис, мега-класс, который умеет одновременно и описывать ордер, и выполнять ордер, и отправлять товары, которые были куплены по этому ордеру, то есть все это вместе собрано в одном супер-супер-сервисном классе, то такой класс будет очень хрупок.
2037.06 2041.82 "Анатолий Кулаков" Вы поменяете ему один метод и скорее всего другие методы это тоже может зааффектить.
2041.82 2048.34 "Анатолий Кулаков" Или завнедрите новую зависимость и она каким-то образом повлияет на его поведение в совсем иных местах.
2048.34 2051.22 "Анатолий Кулаков" Поэтому такого лучше не делать.
2051.22 2054.54 "Анатолий Кулаков" Классик должен отвечать за что-то одно и за что-то понятнее.
2054.54 2058.30 "Анатолий Кулаков" Но здесь сразу возникает множество критики.
2058.30 2065.94 "Анатолий Кулаков" Вот на этом месте, что значит один классик, что значит одна вещь.
2065.94 2070.74 "Анатолий Кулаков" То есть у вас должна быть только одна причина для того, чтобы поменять класс.
2070.74 2075.22 "Анатолий Кулаков" В большинстве случаев класс он недоторминированный.
2075.22 2077.22 "Анатолий Кулаков" То есть у нас в C# есть класс.
2077.22 2082.10 "Анатолий Кулаков" В общем концепция звучит как бы поменять какой-то модуль.
2082.10 2085.90 "Анатолий Кулаков" Поэтому непонятно какую именно вещь вы хотите поменять.
2085.90 2089.18 "Анатолий Кулаков" Ну например, допустим у нас есть процесс ETL.
2089.18 2091.34 "Анатолий Кулаков" Это Extract, Transform, Load.
2091.34 2095.46 "Анатолий Кулаков" Вот это одна вещь, которую вы хотите поменять или это целых три вещи.
2095.46 2100.46 "Анатолий Кулаков" То есть если одна, то это вполне может быть класс процессор, который делает и то и другое.
2100.46 2103.26 "Анатолий Кулаков" Нормально его сделать одним классиком или не нормально?
2103.26 2110.14 "Анатолий Кулаков" Или это три вещи, где должно быть три разных классика, которые потом сходятся, композируются в какой-то один.
2110.14 2113.22 "Анатолий Кулаков" В общем на этот вопрос, этот принцип не отвечает.
2113.22 2115.06 "Анатолий Кулаков" Он слишком размытый и слишком неочевидный.
2115.06 2116.06 "Анатолий Кулаков" Вот.
2116.06 2123.42 "Анатолий Кулаков" И соответственно новое определение, которое учитывало бы все современные тенденции, должно звучать примерно так.
2123.42 2130.46 "Анатолий Кулаков" Каждый модуль должен выполнять только одну вещь, но должен делать это правильно.
2130.46 2140.02 "Анатолий Кулаков" Здесь слово класс было заменено на модуль, чтобы подчеркнуть некую функциональную и динамически языковую парадигму.
2140.02 2145.86 "Анатолий Кулаков" Во всем остальном, в принципе, суть должна по идее остаться такая же точно.
2145.86 2151.56 "Анатолий Кулаков" То есть не смешивайте различные роли и различные ответственности вместе в каком-то одном модуле.
2151.56 2152.56 "Анатолий Кулаков" Разделяйте их.
2152.56 2155.90 "Анатолий Кулаков" И здесь по-прежнему остается непонятно, что же такое этот маленький модуль.
2155.90 2157.46 "Анатолий Кулаков" Насколько он должен быть маленький.
2157.46 2158.46 "Анатолий Кулаков" Что такое одна вещь.
2158.46 2166.10 "Анатолий Кулаков" То есть до тех пор, пока мы не определим, что такое одна вещь, SRP довольно размытый и фантазировать над ним можно сколько угодно.
2166.10 2169.10 "Анатолий Кулаков" Следующий принцип Open-close.
2169.10 2172.10 "Анатолий Кулаков" Как он на русском переводится, Игорь?
2172.10 2173.10 "Анатолий Кулаков" Принцип открытости-закрытости?
2173.10 2176.90 "Игорь Лабутин" Обычный перевод, да, принцип открытости-закрытости.
2176.90 2178.62 "Анатолий Кулаков" Хорошо, Open-close принцип.
2178.62 2183.22 "Анатолий Кулаков" Название странное, но суть, как и у всех принципов, довольно простая.
2183.22 2191.30 "Анатолий Кулаков" То есть программное обеспечение должно быть открыто для расширения, но закрыто для модификации.
2191.30 2195.34 "Анатолий Кулаков" Так как это все писалось для OOP, легче всего это представить как раз таки на OOP.
2195.34 2204.90 "Анатолий Кулаков" Это значит, что мы должны легко уметь пронаследоваться от какого-то классика, но при этом наше наследование не должно изменять поведение оригинального класса.
2204.90 2207.30 "Анатолий Кулаков" То есть то, что есть в оригинальном, мы понять не можем.
2207.30 2210.82 "Анатолий Кулаков" А вот расширить, добавить, вот это мы можем.
2210.82 2223.02 "Анатолий Кулаков" И если вы заходите вдруг классик поменять, то вы не должны бежать ко автору оригинального класса, просить его поменять код, перекомпилировать, может быть что-то еще добавить.
2223.02 2225.22 "Анатолий Кулаков" Вы просто от него наследуетесь и делаете то, что вам нужно.
2225.22 2237.86 "Анатолий Кулаков" Довольно удобно, особенно если мы говорим, что это OOP, если мы говорим, что это в те времена, когда еще все программное обеспечение там было закрыто и писалось как бы где-то далеко-далеко в лабораториях.
2237.86 2242.38 "Анатолий Кулаков" Расширять какие-то классы довольно удобно.
2242.38 2246.90 "Анатолий Кулаков" Почему мы хотим закрыть класс для изменения?
2246.90 2254.02 "Анатолий Кулаков" Во-первых, мы не хотим доверять всем подряд, чтобы кто угодно мог зайти в наш класс и поменять его.
2254.02 2260.46 "Анатолий Кулаков" То есть в большинстве случаев это могут быть люди, которые не обладают соответствующей компетенцией.
2260.46 2263.54 "Анатолий Кулаков" Мы хотим защитить наш код обычно от неквалифицированных людей.
2263.54 2268.66 "Анатолий Кулаков" В общем, если мы написали какой-то кусок и закрыли его для изменения, значит он такой должен быть.
2268.66 2272.94 "Анатолий Кулаков" Идите расширяйте как хотите, а вот эту часть не трогайте, это в принципе наше.
2272.94 2280.14 "Анатолий Кулаков" И обычно такие куски, они бывают сложные для понимания, но нужны какие-то определенные скиллы для того, чтобы это прочитать.
2280.14 2286.54 "Анатолий Кулаков" И если мы пытаемся это потянуть под новую парадигму, то данное правило должно было бы звучать примерно следующим образом.
2286.54 2296.42 "Анатолий Кулаков" У вас должна быть возможность использовать и добавлять модуль без его переписывания.
2296.42 2307.74 "Анатолий Кулаков" То есть здесь немножко заменен подход именно в наследовании, потому что наследование, например, в функциональных языках не принято, там принято переиспользование.
2307.74 2318.46 "Анатолий Кулаков" Вот вы должны уметь переиспользовать модуль и должны его каким-то образом добавлять к нему какую-то новую функциональность без его переписывания.
2318.46 2327.58 "Анатолий Кулаков" Естественно для объектно-литийно-радных языков ничего не меняется, смысл остается тот же самый, пожалуйста, используйте, переписывайте, то есть используйте и добавляйте, что хотите.
2327.58 2332.34 "Анатолий Кулаков" А вот для функциональных языков появляется такая небольшая парадигма как hook-пойнты.
2332.34 2344.38 "Анатолий Кулаков" Там, чтобы, например, ставить точки расширения, допустим, сделать какой-то экшен между сохранением файлика, то есть перед сохранением файлика и после сохранения файлика.
2344.38 2345.82 "Анатолий Кулаков" Там это просто так, методы не перекрыть.
2345.82 2355.38 "Анатолий Кулаков" Туда обычно передаются некие экшены дополнительные, которые процессор выполнит, соответственно, во время, перед и после сохранения файлика.
2355.38 2361.06 "Анатолий Кулаков" Таким образом вы изменяете pipeline работы этого экшена.
2361.06 2376.06 "Анатолий Кулаков" Если почитать комментарии, если почитать какие-нибудь критику данного подхода, то здесь можно найти такой интересный момент, что люди говорят, что это в принципе в давние времена код было сложно модифицировать.
2376.06 2389.14 "Анатолий Кулаков" Когда у вас действительно там была лаборатория, выпустила какую-то библиотечку под ядро, у которого миллионы строк на C++, то фиг вы там что измените.
2389.14 2395.22 "Анатолий Кулаков" И поэтому там действительно нужно было каким-то образом расширять и не повредить то, что уже написали высоколобые глазастые дядьки.
2395.22 2406.74 "Анатолий Кулаков" Также не было распространены умные IDE, которые позволяли рефакторить все вместе с зависимостью, с переменками, с учетом синтаксиса, с учетом кучи тестов и так далее.
2406.74 2414.62 "Анатолий Кулаков" Не был распространен git, который позволял очень удобно бранчить, проверять гипотезы, заливать их обратно, тестировать, опять же, ревьювить.
2414.62 2417.94 "Анатолий Кулаков" И поэтому тоже изменение кода было довольно сложно.
2417.94 2421.82 "Анатолий Кулаков" Поэтому люди концентрировались именно на расширении, но не на изменении.
2421.82 2432.14 "Анатолий Кулаков" И авторы говорят, что в принципе в современном мире, когда у вас IDE сама рефакторит, git все версионирует, помнит и всегда можно откатить.
2432.14 2434.58 "Анатолий Кулаков" У нас вообще кругом open source и все такое.
2434.58 2439.98 "Анатолий Кулаков" Если вам вдруг нужно поменять поведение какого-то класса, то вы идете в исходный код и меняете.
2439.98 2446.22 "Анатолий Кулаков" И этот подход такой дерзкий дает нам то преимущество, что код становится намного проще.
2446.22 2453.14 "Анатолий Кулаков" Я думаю, все вы замечали, что когда мы концентрируемся на расширении, все наши классы и весь наш код становится сложным.
2453.14 2462.98 "Анатолий Кулаков" Какие-то появляются виртуальные методы, которые можно перекрыть, новые зависимости, которые слишком абстрактные, новые экшены, которые можно принять и выполнить их в определенный момент.
2462.98 2463.98 "Анатолий Кулаков" Это все слишком сложно.
2463.98 2474.54 "Анатолий Кулаков" Если мы концентрируемся на том, что никто этот класс расширять не будет, а тем, кому надо, они придут и просто-напросто поменяют, то код становится проще.
2474.54 2480.62 "Анатолий Кулаков" Поэтому авторы говорят, делайте код проще, планируйте его проще для изменений, просто-напросто.
2480.62 2486.34 "Анатолий Кулаков" Делайте так, чтобы изменения вносились легко, понятно, красиво, и не нужно вам всей этой глупости.
2486.34 2490.62 "Анатолий Кулаков" Не нужен вам никакой принцип открытости и закрытости.
2490.62 2492.58 "Анатолий Кулаков" Такие интересные мнения тоже бывают.
2492.58 2497.02 "Анатолий Кулаков" Следующий принцип интересный, это Liskov substitution principle, принцип замещения лисков.
2497.02 2500.50 "Анатолий Кулаков" Тоже довольно простая штука.
2500.50 2509.86 "Анатолий Кулаков" Она говорит о том, что каждый класс S, который пронаследован от T, должен быть мочью использоваться в тех местах, где ожидается T.
2509.86 2518.70 "Анатолий Кулаков" То есть, допустим, у вас есть какой-то классик, который на вход требует некий базовый класс.
2518.70 2523.86 "Анатолий Кулаков" Это значит, что вы должны мочь ему туда подсунуть любого наследника, который наследуется от этого класса.
2523.86 2530.86 "Анатолий Кулаков" И при этом поведение нашего процессора не должно поменяться, оно не должно сильно изменить поведение программы.
2530.86 2534.06 "Анатолий Кулаков" То есть не то, чтобы сильно изменить, а привести к неправильному поведению программы.
2534.06 2535.06 "Анатолий Кулаков" Давайте так.
2535.06 2539.86 "Анатолий Кулаков" То есть, поэтому любого наследника можно подсунуть туда, где ожидается T.
2539.86 2543.94 "Анатолий Кулаков" И новый принцип гласит следующее.
2543.94 2556.22 "Анатолий Кулаков" У вас должна быть возможность заменить одну штуку на некую другую штуку, если эта другая штука декларирует то же самое поведение с предыдущей штукой.
2556.22 2565.38 "Анатолий Кулаков" То есть то же самое, что я сказал про наследование пропарента и базовый класс, но только с учетом функциональных и динамических языков.
2565.38 2569.74 "Анатолий Кулаков" Потому что там нет наследования, не так распространено наследование.
2569.74 2577.62 "Анатолий Кулаков" И поэтому, например, динамические языки программирования, у них вся эта парадигма построена на дактайпинге.
2577.62 2585.26 "Анатолий Кулаков" То есть если вы передали некий класс, у которого есть метод крякой, значит его будут использовать как утка.
2585.26 2588.34 "Анатолий Кулаков" Важно, пронаследован он от утки, там не пронаследован от утки.
2588.34 2589.66 "Анатолий Кулаков" Имплементирую интерфейс или нет.
2589.66 2591.50 "Анатолий Кулаков" В динамических языках наплевать.
2591.50 2594.86 "Анатолий Кулаков" Главное, чтобы он декларировал, что у меня есть метод крякания.
2594.86 2597.38 "Анатолий Кулаков" Значит можно его засовывать во все эти места.
2597.38 2601.82 "Анатолий Кулаков" И функциональные языки используют для этих целей просто-напросто функции.
2601.82 2607.66 "Анатолий Кулаков" Если сигнатура функции совпадает с той сигнатурой функции, которую ожидает некий метод, значит отлично.
2607.66 2612.86 "Анатолий Кулаков" Засовывайте туда эту сигнатуру и опять же ни о каком наследовании, ни о каких интерфейсах мы не говорим.
2612.86 2618.46 "Анатолий Кулаков" Поэтому это новое определение получается более объемлющее.
2618.46 2637.42 "Анатолий Кулаков" Interface segregation principle гласит нам о том, что множество интерфейсов для разных клиентов это намного лучше, чем один большой интерфейс, который покрывает требования абсолютно всех клиентов.
2637.42 2647.06 "Анатолий Кулаков" В OOP мире это легко представить как несколько точек, с помощью которых вы можете смотреть на ваш большой класс.
2647.06 2652.94 "Анатолий Кулаков" Допустим если у нас есть там какой-то класс процессоров, который умеет делать абсолютно все.
2652.94 2670.42 "Анатолий Кулаков" Допустим вы свалили это все в такой большой ком грязи, то намного полезнее будет, если вы этот большой ком грязи не будете отдавать всем клиентам в виде одного конкретного класса или даже в виде одного большого интерфейса.
2670.42 2677.58 "Анатолий Кулаков" А вы разделите на кучу-кучу маленьких интерфейсиков, которые уже будут выполнять каждый какую-то маленькую роль.
2677.58 2682.18 "Анатолий Кулаков" Один читает документы, другой сохраняет документы, третий отправляет документы на печать.
2682.18 2686.22 "Анатолий Кулаков" И вот эти маленькие интерфейсики уже можно раздать клиентам.
2686.22 2690.70 "Анатолий Кулаков" То есть клиенты будут зависеть от довольно ограниченной области зависимости.
2690.70 2700.58 "Анатолий Кулаков" И поэтому по этому принципу у них не будет доступно никаких других методов, которые им и даром не нужны, но при этом которые будут накладывать какую-то дополнительную ответственность.
2700.58 2705.70 "Анатолий Кулаков" Таким образом мы снижаем связанность между всей системой.
2705.70 2713.30 "Анатолий Кулаков" У нас не все зависят, все огромные куски зависят от всех огромных кусков, а как раз таки мы уменьшаем вот эту область зависимости.
2713.30 2719.34 "Анатолий Кулаков" И новое определение, которое автор хотел бы дать данному принципу звучит так.
2719.34 2723.30 "Анатолий Кулаков" Не показывайте клиентов больше, чем им нужно.
2723.30 2734.42 "Анатолий Кулаков" В принципе похоже на то, что если вы можете сделать минимальный интерфейс, который нужен клиенту, сделайте ему этот интерфейс, не отдавайте абсолютно все, что только у вас содержится в этом классике.
2734.42 2739.54 "Анатолий Кулаков" И кульминацией данного принципа, это конечно же является функциональные языки программирования.
2739.54 2744.82 "Анатолий Кулаков" По той простой причине, что у них каждая зависимость это одна функция.
2744.82 2753.46 "Анатолий Кулаков" То есть можно представить, что как будто у них все интерфейсы реализованы в виде интерфейсика с одной единственной функцией, с одним единственным методом.
2753.46 2758.14 "Анатолий Кулаков" Поэтому у них вообще это кульминация данного принципа.
2758.14 2764.62 "Анатолий Кулаков" И последнее, при последней принципе, который у нас есть, это Dependency Inversion принцип.
2764.62 2771.22 "Анатолий Кулаков" Принцип этот гласит, что лучше зависеть от абстракции, чем от какой-то конкретной имплементации.
2771.22 2775.66 "Анатолий Кулаков" И на основании объектно-ориентированных языков все тоже довольно просто.
2775.66 2783.22 "Анатолий Кулаков" То есть лучше передавать интерфейс в конкретный класс, чем реализацию, чем сам конкретный класс.
2783.22 2786.74 "Анатолий Кулаков" То есть все зависимости лучше передавать по интерфейсу.
2786.74 2794.06 "Анатолий Кулаков" Это опять же делает код зависимым с наиболее меньшей сцепленностью.
2794.06 2799.30 "Анатолий Кулаков" То есть вы передавите только то подмножество контракта, которое описано в интерфейсе.
2799.30 2810.62 "Анатолий Кулаков" Если даже сам конкретный класс реализует еще много чего вокруг, то есть клиент получит только определенный интерфейс с минимальным контрактом.
2810.62 2822.34 "Анатолий Кулаков" И соответственно это уменьшает риск того, что будут какие-то breaking changes произведены в классе, которые изначально не должны были повлиять на его потребителей, но случайно почему-то кто-то завязал и оно повлияло.
2822.34 2824.34 "Анатолий Кулаков" За примером ходить долго не нужно.
2824.34 2830.86 "Анатолий Кулаков" Все мы используем логеры и обычно передаем в наш класс какой-нибудь интерфейс типа iLogger.
2830.86 2839.30 "Анатолий Кулаков" Было бы глупо, если бы мы туда, например, передали конкретный или файл логгер, или какой-нибудь датабейс логгер, который в базу данных пишет логи.
2839.30 2841.70 "Анатолий Кулаков" В общем, это ни к чему.
2841.70 2847.30 "Анатолий Кулаков" Тот класс, который именно записывает логи, ему по большому счету наплевать, куда они в конце концов попадут.
2847.30 2854.26 "Анатолий Кулаков" Ему нужен только буквально один метод, который умеет писать то, что нужно этому клиенту.
2854.26 2867.82 "Анатолий Кулаков" И много-много сервисов, практически все сервисы, практически все какие-то вспомогательные классы, менеджеры, хелперы, их обычно и перечат за интерфейсом именно по этой причине.
2867.82 2874.50 "Анатолий Кулаков" И новое звучание данного принципа должно быть следующим.
2874.50 2877.94 "Анатолий Кулаков" Необходимо передавать в качестве зависимости что-то абстрактное, а не конкретное.
2877.94 2881.10 "Анатолий Кулаков" Ну, то есть, определение осталось то же самое, здесь ничего не выдумаешь.
2881.10 2888.62 "Анатолий Кулаков" Оно довольно хорошо подходит и для функциональных языков, и для динамических, и для объектно-ориентированных.
2888.62 2894.62 "Анатолий Кулаков" То есть, это максимально абстрактное определение, которое там немножко похоже на LISCOV-Substitute принцип.
2894.62 2899.38 "Анатолий Кулаков" В общем, если их соединить на абстрактном уровне, но вполне самостоятельно.
2899.38 2902.62 "Анатолий Кулаков" Ну, вот как-то так.
2902.62 2909.18 "Анатолий Кулаков" Такая классика, вот такие у нее есть комментарии, такие у нее есть критики.
2909.18 2918.34 "Анатолий Кулаков" И вот так ее можно немножко подтянуть к современному миру с динамическими языками, с функциональными языками, с парадигмами open-source и прочему.
2918.34 2919.86 "Анатолий Кулаков" В принципе, сильно не меняется.
2919.86 2922.86 "Анатолий Кулаков" Эти принципы до сих пор все еще актуальны.
2922.86 2931.98 "Анатолий Кулаков" Единственное, что некоторые из них слишком размыты, и нельзя четко сказать, кто такой класс, кто такой модуль, что такое минимальное, что такое максимальное.
2931.98 2937.42 "Анатолий Кулаков" То есть, когда мы оперируем нечисленными какими-то счетчиками, показателями, а интуитивными.
2937.42 2940.94 "Анатолий Кулаков" Это всегда, конечно, плохо, но лучшего пока не имеем.
2940.94 2959.34 "Игорь Лабутин" Ну да, причем надо еще понимать, что, не знаю, по-моему, кроме SRP я вот так что-то не могу припомнить, что мы какие-то остальные принципы, прям вот так вот, знаешь, там типа в код-ревью писали "ты здесь нарушаешь open-closed principle".
2959.34 2971.34 "Игорь Лабутин" Вот все остальное, мне кажется, воспринимается на каком-то таком внутреннем уровне, типа ну да, как бы не надо переопределять класс так, чтобы у него принципиально менялось поведение, вроде этому все следуют.
2971.34 2976.46 "Игорь Лабутин" То есть вот там Лисков в этом смысле какой-то довольно очевидный принцип, мне кажется.
2976.46 2983.58 "Игорь Лабутин" А вот SRP, он, пожалуй, такой единственный из всех, который типа вот, single responsibility, ну его, видимо, может проще всего детектить.
2983.58 2998.54 "Анатолий Кулаков" Видишь, мне кажется, что как раз-таки то, что я в начале сказал, что когда у тебя язык растет на этих принципах, и у тебя вся парадигма, все книги пишутся с такими примерами, и во всех статьях это учитывается, ты на интуитивном уровне их уже понимаешь.
2998.54 3004.46 "Анатолий Кулаков" И может быть даже люди, которые никогда их не изучали и не разбирались, они тебе все равно напишут код идеальный по солиду.
3004.46 3011.94 "Анатолий Кулаков" А вот проблема с SRP в том, что непонятно, как бы, непонятно минимальная единица, что значит ответственность.
3011.94 3016.38 "Анатолий Кулаков" Что такое минимальная одна единица ответственности?
3016.38 3018.02 "Анатолий Кулаков" Вот поэтому к нему больше всего вопросов.
3018.02 3020.94 "Игорь Лабутин" Ну да, мое приложение ответственное за выполнение всех бизнес-функций.
3020.94 3026.58 "Анатолий Кулаков" Ну конечно, я пишу приложение, которое должно зарабатывать деньги, вот его ответственность.
3026.58 3027.58 "Игорь Лабутин" Да.
3027.58 3028.58 "Игорь Лабутин" Вперед.
3028.58 3031.46 "Игорь Лабутин" Остальное детали реализации open, close, principal, вот это все.
3031.46 3033.74 "Игорь Лабутин" Конечно, конечно, остальное все скрыто.
3033.74 3038.06 "Игорь Лабутин" Ну да, ладно, к второй части мы перейдем чуть попозже.
3038.06 3040.06 "Игорь Лабутин" Давай немножко вернемся к дотнету.
3040.06 3053.94 "Игорь Лабутин" Опять же из, ну давай скажем, старых новостей карточка была добавлена, ну кстати, не такие старые, смотри-ка ты, август 22 года, то есть почти год она промариновалась, но тем не менее.
3053.94 3054.94 "Игорь Лабутин" Это про rate limiting.
3054.94 3066.54 "Игорь Лабутин" И это один из тех примеров нашего, так сказать, бэклога, где скопилось довольно большое количество всяких разных ссылочек, пока эта карточка лежала и ждала своего часа.
3066.54 3082.42 "Игорь Лабутин" И поэтому получилось скомпилировать некоторый такой обзор, ну не то что текущего состояния rate limiting в дотнете, но по крайней мере описание, что сейчас происходит или происходило в той части, которая нам показалась интересной.
3082.42 3088.34 "Игорь Лабутин" Поэтому давайте пробежимся и посмотрим, что мы можем рассказать про это.
3088.34 3093.42 "Игорь Лабутин" Во-первых, давай начнем с того, что мы в принципе поймем, а что такое rate limiting.
3093.42 3101.14 "Игорь Лабутин" Потому что может быть не все с этим сталкиваются, не все пишут веб-приложения, а даже те, кто пишут, не все пишут настолько high-load, что прям нужен rate limiting.
3101.14 3107.38 "Игорь Лабутин" Я вот не могу сказать, что у меня, по-моему, у меня был всего один проект, где мы хоть как-то думали над rate limiting.
3107.38 3116.50 "Игорь Лабутин" Во всех остальных у нас были настолько небольшие RPS, что в общем-то, ну или это не было требований, по крайней мере, чтобы нам что-то надо было имитировать.
3116.50 3130.78 "Анатолий Кулаков" Ну тут нужно сначала сказать, что такое rate limiting, это когда тебе валится куча запросов, это может быть валидные запросы, невалидные запросы, это уже десятый шаг, но главное, что их нужно каким-то образом залимитировать.
3130.78 3133.14 "Анатолий Кулаков" И залимитировать можно по разным причинам.
3133.14 3137.34 "Анатолий Кулаков" Или приложение просто-напросто упадет, не сможет это вытянуть.
3137.34 3143.62 "Анатолий Кулаков" Или бывает, если у нас облачные сервисы есть, ты можешь попасть на большое бабло по трафику, по CPU, по памяти.
3143.62 3148.94 "Анатолий Кулаков" Или, допустим, твоя лицензия не позволяет тебе, например, выполнять больше 5 запросов в секунду.
3148.94 3150.54 "Анатолий Кулаков" То есть причины тоже есть разные.
3150.54 3165.02 "Игорь Лабутин" Да, причин может быть много, или то API, которое за тобой стоит, оно ограничено каким-то rate-лимитом, и ты, хоть тебя и вызовут миллион раз, ты все равно не сможешь ничего сделать, там, не знаю, положишь в очередь, это все и будет долго-долго ждать, и пользователям будет неудобно.
3165.02 3170.58 "Анатолий Кулаков" Ну и действительно, вот ты когда сказал, что в принципе не всем приложениям это нужно.
3170.58 3182.42 "Анатолий Кулаков" Мне кажется, всем приложениям нужно точно защититься как-нибудь от DDoS, если коммерческое приложение мы какое-нибудь пишем, то скорее всего может быть даже покупается обычный внешний сервис, который просто защищает тебя от DDoS.
3182.42 3190.30 "Анатолий Кулаков" И это первая ступень, которая в принципе решает 80% ваших проблем, а все остальное это уже специфика, которая может понадобиться, может не понадобиться.
3190.30 3201.02 "Игорь Лабутин" Да, и иногда rate-лимит еще называют request throttling, то есть, или по-русски throttling, тоже в принципе один из вариантов.
3201.02 3212.22 "Игорь Лабутин" То есть rate-лимит это в каком-то смысле более общий термин, но мне кажется, что в большинстве своем оно применяется именно к request rate-лимиту, а не к тому, насколько часто сообщение в очередь падает.
3212.22 3221.82 "Анатолий Кулаков" Это, например, когда вы к GitHub обращаетесь, он вам постоянно в ответе возвращает, что вот вы запрос сделали, а теперь у вас осталось 29 запросов.
3221.82 3224.30 "Анатолий Кулаков" Еще один сделали, а теперь у вас осталось 28 запросов.
3224.30 3225.66 "Анатолий Кулаков" Есть какое-то ограничение.
3225.66 3230.54 "Игорь Лабутин" Да, мы к этому еще вернемся, кстати, к GitHub и к респонсам.
3230.54 3235.42 "Игорь Лабутин" Давай посмотрим, во-первых, на эту проблему, на эту задачу с разных сторон.
3235.42 3237.78 "Игорь Лабутин" Давай начнем с того, а что нужно rate-лимитить.
3237.78 3245.78 "Игорь Лабутин" Ну вот если мы говорим про реквесты, у вас, наверное, приложение состоит не из одного единственного реквеста, а их много, ну, endpoints, да?
3245.78 3247.70 "Игорь Лабутин" Что нужно rate-лимитить?
3247.70 3263.66 "Игорь Лабутин" И есть разные мнения на этот счет, но вот мнение, я, пожалуй, соглашусь с мнением Марта на Baleo, статью которую мы как раз-таки в том числе включили в шоу-ноуты, про то, что rate-лимитить на самом деле нужно все.
3263.66 3277.34 "Игорь Лабутин" Но все со звездочкой, потому что фактически нужно rate-лимитить все, что может как-то повлиять на использование ресурсов вашего приложения, либо на его, так сказать, жизнеспособность.
3277.34 3278.34 "Игорь Лабутин" То, про что говорил Толя.
3278.34 3296.46 "Игорь Лабутин" Если, может быть, даже сам факт, не знаю, того, что дернули endpoint, у вас endpoint ничего не делает, возвращает всегда константную строку, но вы платите там сколько-то денег за каждый факт вызова, это уже может быть поводом rate-лимита, хотя ни CPU, ни память особо не тратится на то, чтобы быстро вернуть константную строчку.
3296.46 3307.10 "Игорь Лабутин" Поэтому только внутри приложения, только зная особенности приложения и того места, где вы хоститесь, вы можете сказать, что нужно rate-лимитить.
3307.10 3309.66 "Игорь Лабутин" Допустим, вы поняли, что нужно rate-лимитить.
3309.66 3315.38 "Игорь Лабутин" Мы сейчас к этому еще вернемся, на самом деле, но так, в целом вы поняли, все или не все.
3315.38 3317.54 "Игорь Лабутин" Возникает вопрос, как?
3317.54 3326.30 "Игорь Лабутин" Ну, то есть, есть наивные алгоритмы, например, это называется concurrency limit, то есть вот такой алгоритм.
3326.30 3332.82 "Игорь Лабутин" Я сейчас называю по тем именам, которые, во-первых, общедоступны, во-вторых, они же используются в интернетной реализации, которую мы потом обсудим.
3332.82 3343.06 "Игорь Лабутин" Вот этот алгоритм, concurrency limit, он довольно простой, он просто ограничивает количество одновременных запросов в каждый момент времени.
3343.06 3347.34 "Игорь Лабутин" То есть в один момент времени не может быть больше 10 запросов, точка.
3347.34 3364.26 "Игорь Лабутин" Это довольно простой алгоритм, он работает тривиально, но дальше возникает вопрос, что делать, если у вас хочется ограничить… Ну, то есть он довольно, с одной стороны, простой, с другой стороны, и ограниченный, в том смысле, что он не позволяет ничего гибко настроить.
3364.26 3387.54 "Игорь Лабутин" Он не позволяет, например, поддерживать так называемые, то что на английском называется bursts, по-русски пики трафика, то есть если у вас внезапно пришло 100 клиентов, и вообще-то вы бы и рады были их обслужить, но в среднем вы не хотите обслуживать больше 10, ну как бы 90 уйдут ни с чем в какой-то момент, или будут дальше ждать.
3387.54 3390.02 "Игорь Лабутин" Поэтому дальше возникают разные вариации алгоритмов.
3390.02 3420.54 "Игорь Лабутин" Есть алгоритм fixed window limit, то есть когда вы говорите, что на фиксированное окошечко, например, одну минуту, у вас есть определенный резерв реквестов, которые вы можете обслужить, определенное число, например, вы в минуту можете обслужить 100, и факт того, что окно фиксировано, означает то, что если в первую секунду этой минуты к вам придут все 100, ну значит остальные 59 секунд ваше приложение не сможет обслуживать никого, пока не наступит следующее окошко, в начале которого восстановится лимит в 100 разрешенных.
3420.54 3423.98 "Игорь Лабутин" То есть если реквесты в среднем приходят равномерно, ну как бы и окей.
3423.98 3428.06 "Игорь Лабутин" А вот если они таким пиком пришли в начале окна, ну сори, все плохо.
3428.06 3433.34 "Игорь Лабутин" Для того, чтобы с этим всем побороться, можно использовать алгоритм sliding window, то есть скользящее окно.
3433.34 3451.14 "Игорь Лабутин" Он примерно похож, но просто окошко делится на более мелкие, и вот эти части в окошко выливаются обратно, разрешенные реквесты закидываются в число разрешенных по мере вот этого прохождения окошка дальше, то есть чуть лучше.
3451.14 3472.70 "Игорь Лабутин" И есть еще алгоритм, ну такой тоже довольно популярный, может быть вы его тоже слышали, алгоритм протекающего ведра, токен-бакет, штука, которая позволяет, не протекающего ведра, просто ведра, токен-бакет, в которой говорит следующее, представьте, что у вас есть ведро, там лежит как бы сотня токенов, и логика работы следующая.
3472.70 3480.38 "Игорь Лабутин" Каждый реквест приходящий смотрит, есть в ведре свободный токен, если есть, забирает и выполняется, если нет, ну как бы не выполняется.
3480.38 3491.66 "Игорь Лабутин" И при этом у вас регулярно раз в n чего-нибудь, секунд, там как настроите, в это самое ведро докидывается определенное число токенов, но не больше, чем максимум, который вы хотите обрабатывать.
3491.66 3516.46 "Игорь Лабутин" Ну и таким образом там и пики как-то, то есть если у вас ведро достаточно наполненное, то пик вы обслужите, а потом потихонечку начнете обслуживать поменьше запросов, но все-таки все еще будете обслуживать по чуть-чуть, потихоньку восстанавливаясь до обычного вашего лимита и скорости обработки запросов.
3516.46 3530.22 "Игорь Лабутин" В общем, алгоритмов есть великое множество на самом деле, и выбор их, он на самом деле тоже довольно специфичен к тому, как ваше приложение должно себя вести, и что вы будете делать с реквестами, которые не прошли.
3530.22 3533.62 "Игорь Лабутин" От этого тоже может зависеть выбор алгоритма.
3533.62 3544.98 "Игорь Лабутин" Но прежде чем, одна из частей выбора алгоритма, это на самом деле некоторое решение того, а сколько вообще в принципе реквестов, где вы должны эти лимиты поставить.
3544.98 3550.38 "Игорь Лабутин" То есть вот я так все говорю, привожу пример, 10, 100, а какое число должно быть в вашем случае?
3550.38 3558.54 "Игорь Лабутин" Сколько реквестов в минуту, в секунду, в час, в день, вы должны лимитировать или обрабатывать наоборот.
3558.54 3564.06 "Игорь Лабутин" И здесь рекомендация довольно банальная, что ли, измеряйте.
3564.06 3578.74 "Игорь Лабутин" То есть если у вас есть уже настроенный мониторинг, там какая-нибудь графана, в которую вы можете посмотреть или выгрузить просто данные с запросом, сколько у вас там в среднем в минуту, например, обрабатывается запросов, это будет хорошая первая точка.
3578.74 3585.94 "Игорь Лабутин" Если вы понимаете, что приложение в среднем работает, так и смотрите за это время, сколько у вас было реквестов, ну померили, посмотрели, попробовали.
3585.94 3590.14 "Игорь Лабутин" Причем попробовали, Мартам предлагает следующее.
3590.14 3597.38 "Игорь Лабутин" Вы настраиваете rate limit, вы настраиваете все вот эти алгоритмы, все дела, но вы не блокируете запросы.
3597.38 3600.10 "Игорь Лабутин" То есть единственное, что нужно сделать, это просто залогировать.
3600.10 3605.26 "Игорь Лабутин" Заблокировался ли бы этот реквест или не заблокировался.
3605.26 3607.26 "Игорь Лабутин" Вот и смотрите, что получилось.
3607.26 3613.86 "Игорь Лабутин" Если вам кажется, что слишком много блокируется, ну окей, подкручивайте лимиты до тех пор, пока вам не покажется нормальным.
3613.86 3638.90 "Игорь Лабутин" Вкупе с вашим мониторингом приложения, того, как у вас тратятся ресурсы, там, не знаю, деньги и все остальное, вы добивайтесь тех самых чиселок, на которых у вас вроде как все должно работать хорошо, по вашему мнению, и вот тогда вы включаете уже блокирование, и ваше приложение начинает уже нормально, так сказать, использовать rate limiting, но при этом надо не забывать все равно мониторить все эти ивенты блокировки запросов, чтобы понимать, не стало ли их что-то слишком много.
3638.90 3652.46 "Игорь Лабутин" Потому что если вдруг стало слишком много, это может означать, например, атаку на вас, либо это может означать, что паттерны поведения, вы там, не знаю, выкатили новую фичу, у вас стало в 10 раз больше клиентов, а rate limiting вы забыли подкрутить.
3652.46 3657.58 "Игорь Лабутин" И, наверное, все-таки надо было, может, подкрутить, потому что к вам просто органически стало больше запросов.
3657.58 3664.90 "Игорь Лабутин" Следующий вопрос, который нужно обязательно подумать, должны ли вы разрешать вот те самые пики или всплески активности.
3664.90 3676.74 "Игорь Лабутин" Потому что, может быть, это зависит от вашей бизнес-логики, но может случаться так, что у вас будут пики, вы можете хотеть их разрешать, можете не хотеть.
3676.74 3685.58 "Игорь Лабутин" И даже если вы не хотите разрешать пики, есть рекомендация подумать над лимитами с точки зрения разных длительностей.
3685.58 3699.26 "Игорь Лабутин" То есть, например, если вы скажете, что вы хотите разрешать 10 запросов в секунду, то если вы посчитаете, сколько это запросов в час, это будет 36 тысяч по идее.
3699.26 3703.30 "Игорь Лабутин" Но может быть вам будет казаться, что 36 тысяч в час это все-таки многовато.
3703.30 3709.06 "Игорь Лабутин" То есть никто не запрещает вам поставить 10 запросов в секунду, но не более чем, не знаю, 5 тысяч в час.
3709.06 3711.70 "Игорь Лабутин" То есть вот такой вот странный, казалось бы, рейтлимит.
3711.70 3729.74 "Игорь Лабутин" Но тем не менее, я встречал такие в некоторых, так скажем, API-описаниях, что он позволяет вам, допустим, кратковременную сессию работы с вашей API сделать довольно интенсивной, но не позволяет этой интенсивной сессии длиться дольше, не знаю, 5-10 минут.
3729.74 3732.22 "Игорь Лабутин" То есть оно натурально в течение часа.
3732.22 3735.62 "Игорь Лабутин" Дальше делаете перерывчик и через час можно снова пробовать.
3735.62 3736.98 "Игорь Лабутин" Ну, если вы как клиент выступаете.
3736.98 3739.58 "Игорь Лабутин" Все это тоже надо решить.
3739.58 3743.94 "Игорь Лабутин" Следующий момент, если вы думаете, что все просто, все очень непросто.
3743.94 3752.42 "Игорь Лабутин" Следующий момент, что нужно решить, это мы уже договорились, что окей, мы вроде хотим рейтлимитить все реквесты.
3752.42 3768.18 "Игорь Лабутин" Вопрос, не хотим ли мы их как-то кластеризовывать или разделять, партиционировать, выбирайте какое угодно русское слово, на какие-то группы, партиции, кластеры, отделы категории, которые нужно как-то по-разному рейтлимитить.
3768.18 3782.22 "Игорь Лабутин" То есть, например, вы хотите, ну, самый очевидный пример, каждый endpoint по-своему, возможно, вы хотите как-то их кластеризовать по IP-адресам, возможно, по пользователям, возможно, по браузерам, возможно, по каким-то заголовкам в браузере.
3782.22 3790.42 "Игорь Лабутин" То есть, это все нужно решить, поняв, опять же, кто ваши IP-клиенты, кто к вам ходит, с какими целями.
3790.42 3814.70 "Игорь Лабутин" Потому что даже если вы просто выставляете публичные IP для использования, не знаю, из вашего веб-сайта или каких-то других клиентов, к вам могут ходить те, кто хотят забродфорсить ваше приложение, те, кто хотят просто побаловаться IP-шкой, поисковики к вам могут ходить, вообще говоря, краулеры, которые пытаются собрать у вас какую-нибудь клевую информацию с вашего сайта, и для них, для всех, возможно, нужны какие-то разные рейд-лимиты.
3814.70 3815.86 "Игорь Лабутин" Тоже нужно решить.
3815.86 3832.98 "Игорь Лабутин" И неотъявлемой частью вот этого протекционирования и решения, все ли реквесты делать или не делать, является то, какие лимиты им всем поставить, нет ли каких-то выделенных категорий, которым, может быть, на самом деле лимиты нужно ставить, ну, очень расслабленные, а может быть, не надо ставить вообще.
3832.98 3838.10 "Игорь Лабутин" Например, если у вас есть холстчеки, нужно ли рейд-лимитить холстчеки?
3838.10 3839.78 "Игорь Лабутин" Вот, Толь, ты что думаешь?
3839.78 3841.34 "Игорь Лабутин" Можно же рейд-лимитить или нет?
3841.34 3850.50 "Анатолий Кулаков" Я думаю, не нужно, иначе тебя завалит какой-нибудь кубернетес или другой оркестратор твое приложение, еще до того, как ты успеешь его залимитировать.
3850.50 3865.58 "Игорь Лабутин" Правильно, его действительно, если вы его жестко залимитите, то, понятное дело, получив несколько раз 429 или 503 от вашего приложения, его просто прибьет и скажет, нет, дайте мне новое приложение, которое ведет себя лучше.
3865.58 3880.14 "Игорь Лабутин" Но, с другой стороны, может быть, имеет смысл поставить на него какой-нибудь очень расслабленный рейд-лимитер, и если уж вы в него уперлись, то это может означать, что у вас с приложением совсем плохо, его надо прибить, действительно.
3880.14 3882.74 "Игорь Лабутин" Ну или как бы, алерт какой-нибудь сработает.
3882.74 3887.06 "Игорь Лабутин" То есть тут надо посмотреть, но скорее всего, конечно, нет.
3887.06 3900.62 "Игорь Лабутин" Второй момент, если у вас есть какие-нибудь специальные эндпойнты для команды админов или саппорта, внутренние API, которыми пользуется саппорт, нужно ли их рейд-лимитить?
3900.62 3904.34 "Анатолий Кулаков" Ну, скорее всего, это зависит все-таки от сети.
3904.34 3914.22 "Анатолий Кулаков" Если эти админы пользуются только из внутренней сети, то прежде всего я бы их не лимитил, а ограничил бы firewall, чтобы можно было ходить только из внутренней сети, допустим.
3914.22 3915.22 "Анатолий Кулаков" Да, все так.
3915.22 3917.14 "Анатолий Кулаков" Это было бы более надежно, чем лимиты.
3917.14 3928.90 "Анатолий Кулаков" Ну а потом, конечно, с точки зрения, если мы обращаемся к нему просто как к API, ну, наверное, можно лимитить, но кто-то не мешает, допустим, или забредфорсить, или вычистить все деньги из внутренней сети, в том числе даже из-под легитимного пользователя.
3928.90 3929.90 "Игорь Лабутин" Все так, все так.
3929.90 3945.38 "Игорь Лабутин" То есть, как раз-таки, казалось бы, с одной стороны, саппорту может быть полезно иметь относительно неограниченный доступ, чтобы, например, в каком-нибудь батч-режиме что-то оперативно фиксить для многих пользователей, но с другой стороны, нужно, может быть, действительно привинтить, когда у вас это быстро выкачивают все данные.
3945.38 3947.30 "Игорь Лабутин" Поэтому тоже взвешивайте за и против.
3947.30 3951.50 "Игорь Лабутин" Веб-краулеры, нужно ли их ограничивать, не нужно.
3951.50 3965.78 "Игорь Лабутин" Надо подумать, насколько ваши данные с сайта полезны поисковикам, может быть, вы там как-то на этом строите вашу оптимизацию, и отдел маркетинга будет очень несчастлив, если вы залимитите, когда к вам приходит Google или кто-то другой.
3965.78 3988.58 "Игорь Лабутин" Опять же, если вы, например, знаете, что вы ходите к вашим API-шкам только из ваших бэкэндов, которые вы знаете где расположены, ну на каких пабликах API, то вы можете зарейтлимитить все остальные API, кроме них, но дальше возникает тонкость, если к вам, например, идут через какие-нибудь VPN, которые обычно хостятся у всяких больших провайдеров, а вы зарейтлимитите их.
3988.58 3992.30 "Игорь Лабутин" В общем, надо смотреть, все непросто.
3992.30 4004.54 "Игорь Лабутин" Допустим, вы все это решили, решили, как рейтлимитить, решили, кого рейтлимитить, решили, с какой частотой, как их всех поделить на группы, что каждой группе выдать, какие лимиты.
4004.54 4010.66 "Игорь Лабутин" Все сделали, возникает вопрос, а как реагировать на тот факт, что лимит превышен?
4010.66 4014.22 "Игорь Лабутин" Ну вот вы нашли реквест, который нужно зарейтлимитить, что с ним сделать?
4014.22 4021.14 "Анатолий Кулаков" Мобильный оператор поступает очень хорошо, они тебе просто подключают пакет в два раза дороже, и вперед,
4021.14 4028.26 "Игорь Лабутин" и дальше. Ну, мобильный оператор контролирует, как ты ходишь к ним, поэтому у них есть такая возможность.
4028.26 4034.02 "Анатолий Кулаков" Так и здесь нужно, если твои реквесты пользуются спросом, то не надо их блокировать, просто чарджи их подороже,
4034.02 4037.86 "Игорь Лабутин" да и все. Все верно, если у тебя API, который ты продаешь.
4037.86 4045.30 "Игорь Лабутин" А вот если у тебя не API, который ты продаешь, то в любом случае, на самом деле, у вас есть несколько вещей, которые вы можете сделать.
4045.30 4046.70 "Игорь Лабутин" Во-первых, вы можете реквест просто выкинуть.
4046.70 4051.66 "Игорь Лабутин" В сети это называется black hole, то есть черная дыра.
4051.66 4054.94 "Игорь Лабутин" Вы вообще ничего не возвращаете на этот реквест, просто закрываете connection и все.
4054.94 4056.78 "Игорь Лабутин" Наверное, это не очень вежливо.
4056.78 4061.90 "Игорь Лабутин" Но может быть в каких-то случаях приемлемо для
4061.90 4064.94 "Анатолий Кулаков" каких-то… Ну, если вас, допустим, дедосят, ну какой смысл им рассказывать?
4064.94 4065.94 "Игорь Лабутин" Ну, конечно, конечно, конечно.
4065.94 4067.62 "Игорь Лабутин" Просто дропаешь connection и все.
4067.62 4070.82 "Игорь Лабутин" Ну, как можно им ответить в хедере "приходите за дедосом завтра".
4070.82 4071.82 "Игорь Лабутин" Следующий дедос в расписании завтра.
4071.82 4076.34 "Анатолий Кулаков" Слишком много чести, как бы столько хедеров раздавать на халяву.
4076.34 4079.62 "Игорь Лабутин" У нас переучет обед, дедос завтра.
4079.62 4082.02 "Игорь Лабутин" Дедос работает с 10 до 11.
4082.02 4100.74 "Игорь Лабутин" Дальше, второй момент, на самом деле, с такой оверфлоутом делает, как в статье, по крайней мере, написано, что если они понимают, что какая-то API сильно дедосится, и тот, кто приходит, просит в ответ текст HTML, ну, то есть это, скорее всего, браузер, то они покажут капчу про то, чтобы подтвердить, что вы не роботы.
4100.74 4109.34 "Игорь Лабутин" Вот если ты приходишь с application.json, ну, как бы, нет, тут тебя просто, значит, ответят, что, сорян, нельзя.
4109.34 4117.26 "Игорь Лабутин" Ну и да, вернуть какой-нибудь response code с дополнительной опциональной информацией, желательно в хедерах, так делает GitHub.
4117.26 4134.62 "Игорь Лабутин" GitHub действительно присылает даже не только прям когда уже за рестрикт твой реквест, но на самом деле и до, действительно, в любом респонсе присылает тебе, что ты сделал столько реквестов, осталось столько-то, лимит, значит, заресетится через столько-то времени.
4134.62 4142.94 "Игорь Лабутин" Респонс коды тоже бывает разный, GitHub присылает 403, если реквест не смог пройти.
4142.94 4147.98 "Анатолий Кулаков" Ну, довольно странно 403, потому что, ну, по сути, 403 это forbidden.
4147.98 4148.98 "Анатолий Кулаков" Да.
4148.98 4149.98 "Анатолий Кулаков" Ну, как бы.
4149.98 4156.42 "Анатолий Кулаков" С точки зрения GitHub, может, потому что ты израсходовал все токены, которые он тебе выдал.
4156.42 4161.78 "Игорь Лабутин" Типа тебе запрещено делать, вот сейчас тебе запрещено по любой причине использовать этот ресурс.
4161.78 4170.90 "Игорь Лабутин" Не залогинился ты, ну, в смысле, не авторизован ты, потому что ты смотришь там чужое недоступное, тебе правят репозиторий, либо у тебя токены кончились, ну, тебе просто не запрещено.
4170.90 4174.58 "Анатолий Кулаков" Ну, это слишком неправильный ответ.
4174.58 4175.58 "Игорь Лабутин" Я осуждаю GitHub.
4175.58 4176.58 "Игорь Лабутин" Ну, вот.
4176.58 4178.26 "Игорь Лабутин" Тем не менее, GitHub присылает ровно это.
4178.26 4179.26 "Игорь Лабутин" Бывает вариант 503.
4179.26 4181.26 "Анатолий Кулаков" По-моему, это service unavailable.
4181.26 4189.74 "Анатолий Кулаков" Да, 503 это service unavailable тоже не очень правильно, потому что, как бы, браузер или другой там клиент может совершенно по-другому поступить на этот повод.
4189.74 4198.50 "Анатолий Кулаков" Он может пойти в какую-нибудь следующую ноду, которая резолвится в DNS по этому имени, потому что он думает, что просто сервис напросто упал, и, может быть, другая нода сможет ему ответить.
4198.50 4205.34 "Анатолий Кулаков" Но на самом деле, если у вас кончились там токены, то это не решит вашу проблему, поэтому это тоже плохой подход.
4205.34 4209.18 "Игорь Лабутин" Да, кстати, дотнетовская версия по дефолту 503 возвращается сейчас.
4209.18 4219.54 "Игорь Лабутин" Но есть опция для того, чтобы переключить в тот вариант, который обычно используют все, ну, большинство, да, все неправильно, это 429, too many requests.
4219.54 4220.54 "Анатолий Кулаков" Too many requests.
4220.54 4235.86 "Анатолий Кулаков" Да, вот это самый правильный статус код, который как раз-таки должен сообщать клиенту, типа, приходите попозже, у меня тут небольшой перегруз, у меня слишком много реквестов, и в частности, 423, по-моему, даже… 429.
4235.86 4236.86 "Анатолий Кулаков" 429, да, да.
4236.86 4245.62 "Анатолий Кулаков" По-моему, даже в РФЦ имеют ссылку на то, что рекомендуется возвращать специальный хедр, который рассказывает, а через сколько к вам можно прийти, когда вы освободитесь.
4245.62 4248.82 "Анатолий Кулаков" В общем, и вот это прекрасная… После праздников.
4248.82 4249.82 "Игорь Лабутин" Да.
4249.82 4259.66 "Игорь Лабутин" Ну, в общем, вот, решили вы, что возвращаете, хорошо, дальше возникает… Это еще не все.
4259.66 4261.66 "Игорь Лабутин" Возникает вопрос следующий.
4261.66 4276.38 "Игорь Лабутин" Для того, чтобы все эти rate limits enforcing, вам нужно где-то хранить информацию о том, сколько сейчас реквестов, ну, то есть какие-то внутренние счетчики, по которым решать, пора или не пора всех, значит, блокировать, или не всех, а конкретную группу пользователей.
4276.38 4290.06 "Игорь Лабутин" И возникает вопрос, предположим, что у вас приложение, ну, если у вас возникает вопрос rate limits, с некоторой вероятностью оно у вас довольно нагружено и выполняется на нескольких нодах, да, в нескольких инстанциях, где вы будете хранить все эти счетчики?
4290.06 4300.74 "Игорь Лабутин" Вы можете хранить их, понятно, в памяти на каждом инстанции, вы можете их складывать в какую-нибудь прям SQL-ную базу данных или там, что у вас в качестве базы данных используется, вы можете какой-нибудь распределенный кэш типа Redis-а завязать.
4300.74 4307.26 "Игорь Лабутин" Тоже вопрос интересный, открытый и на самом деле зависит от вашего бизнеса.
4307.26 4320.62 "Игорь Лабутин" То есть если, как только раньше ваша цель продажи API, то скорее всего вам все-таки нужен какой-нибудь условный Redis, чтобы все вот эти значения счетчиков и так далее были довольно точными.
4320.62 4331.34 "Игорь Лабутин" То есть чтобы ваши лимиты действительно совпадали с тем, что вы обещаете в ваших прайсинг-планах, а не плюс-минус, значит, полсотни реквестов, наверное.
4331.34 4335.38 "Анатолий Кулаков" Ну, если ты хочешь довольно точные за деньги, то это уже лучше в базу данных тогда.
4335.38 4339.74 "Игорь Лабутин" Ну, слушай, Redis, мне кажется, даст тебе нормальный плюс-минус.
4339.74 4347.82 "Анатолий Кулаков" Прежде всего, Redis обычно ставится без persistence, это in-memory, то есть вполне вероятно может рухнуть, перезагрузиться и даже не заметить, и все твои лимитеры потрутся.
4347.82 4355.42 "Игорь Лабутин" Это правда, но база данных требует, ну, база данных все равно потребует, ну, тогда это будет медленнее, опять же.
4355.42 4361.06 "Анатолий Кулаков" Ну да, у баз данных интересная фишка в том, что как только тебя начинают дедосить, и ты начинаешь записывать это все в базу данных, то по сути ты дедосишь свою
4361.06 4368.14 "Игорь Лабутин" базу данных. Ну и тем самым нормально всем будешь возвращать 500 саян, я тут медленно напишу.
4368.14 4372.94 "Игорь Лабутин" Подождите, тетрадочка эта, тетрадочку быстро не записать, не видите?
4372.94 4385.14 "Игорь Лабутин" Значит, на самом деле мысль в том, что да, если у вас прям бизнес-модель на этом построена, конечно, делайте все точно, в большинстве случаев, на самом деле достаточно in-memory на каждой ноде, независимо от остальных нод.
4385.14 4396.74 "Игорь Лабутин" То есть даже если у вас будет легкий там дисбаланс, и из-за того, что у вас на разных нодах чуть-чуть разъедутся счетчики, и вы не получите прям точное-точное соответствие, вот прям идеальное, это не страшно.
4396.74 4403.58 "Игорь Лабутин" То есть если вы просто, ваша задача запротектиться от там overuse, прям такого DDoS, то в принципе и норм.
4403.58 4407.82 "Анатолий Кулаков" Да, зато это будет быстро и без сильного расхода жизненно важных ресурсов.
4407.82 4408.82 "Игорь Лабутин" Да.
4408.82 4416.14 "Игорь Лабутин" И, наконец, последний вопрос, который нужно для себя решить, это где применять весь этот rate-limiting.
4416.14 4425.02 "Игорь Лабутин" Потому что понятно, что от момента, когда, если мы берем браузер, например, запрос доходит до вашего приложения, там по пути проходится дофига всего.
4425.02 4443.50 "Игорь Лабутин" Там есть всякие там firewall, IP-gateway, CDN, если через них еще что-то, ну CDN скорее всего в ваш обычный реквест обыкновенный не придет, но тем не менее, там могут быть reverse proxy перед этим стоящие, и только потом все это дойдет до вашего приложения.
4443.50 4452.18 "Игорь Лабутин" И даже внутри приложения, там это можно, грубо говоря, на первой стадии билдварьки ловить, а можно уже в контроллере решать, что делать с реквестом.
4452.18 4454.74 "Игорь Лабутин" И тут вопрос простой.
4454.74 4460.82 "Игорь Лабутин" Чем ближе к вашему приложению, чем ближе к коду условного контроллера, тем больше у вас знаний об этом реквесте есть.
4460.82 4467.10 "Игорь Лабутин" Внутри контроллера вы вообще все параметры и все данные от релиза реквеста знаете, включая body.
4467.10 4473.26 "Игорь Лабутин" Но чем ближе вы к этой точке, тем больше вы потратите ресурсов на каждый запрос.
4473.26 4481.54 "Игорь Лабутин" Если вас rate-limiting жестко дедосит, то наверное решать о том, дедосит вас или нет в контроллере, будет уже поздновато.
4481.54 4483.82 "Игорь Лабутин" Лучше это делать чуть раньше.
4483.82 4497.14 "Игорь Лабутин" Поэтому обычно применяется такая иерархическая система, то есть, как вот Толя говорил, что-то дедос, такой базовый детект дедоса делается на каких-то внешних контурах вашего приложения, чтобы даже до приложения вообще ничего не доходило.
4497.14 4501.26 "Игорь Лабутин" А внутри уже можно по клиентам сортировать в зависимости от того, кто сколько заплатил.
4501.26 4506.30 "Анатолий Кулаков" То есть перефразировать лучше, что чем раньше вы задетектите, тем лучше.
4506.30 4516.46 "Анатолий Кулаков" Вообще самый идеальный детект был бы, допустим, если мы говорим про браузер пользователя, прямо в браузере пользователя, чтобы этот браузер даже запросы на вашу страничку не выплевывал.
4516.46 4526.34 "Анатолий Кулаков" Если вдруг вы каким-то образом сообщили браузеру, например, через определенные HTTP заголовок, что не приходи к этому сервису в ближайшую минуту, и вот браузер вообще даже не посылает никакие запросы.
4526.34 4532.14 "Анатолий Кулаков" Это в принципе самый идеальный rate-limiter, который лимитит прямо непосредственно клиента.
4532.14 4535.70 "Анатолий Кулаков" Ну а все остальное уже насколько сможете там и ставить.
4535.70 4537.46 "Анатолий Кулаков" Ну и чем раньше, тем лучше.
4537.46 4597.02 "Игорь Лабутин" Ну и последняя рекомендация, я, ну опять же, я говорю, что я не очень сильно много работал с rate-limiting, Мартин рекомендует иметь то, что он называет emergency switch, то есть он говорит, что представьте, что вы там что-нибудь зарелизили, у вас там резко все посыпалось, потому что вы там что-нибудь либо напортачили с rate-limit, либо наоборот, у вас там что-то произошло, и вы ничего не релизили, но у вас почему-то внезапно выросла нагрузка, легитимно выросла нагрузка от пользователей, потому что какая-то там рекламная кампания прошла, имейте возможность либо быстро выключить rate-limit на время, либо быстренько тюнить конфигурацию без особых как бы, ну типа без необходимости там полдня передеплоить весь софт, не знаю, перекомпилировать что-нибудь, то есть все держитесь в конфигурации и имейте возможность быстро все подкрутить, потому что возможно вам нужно будет подкручивать, особенно на этапе подстройки, когда вы только-только понимаете, или например вы заключили какой-нибудь новый контракт с новым заказчиком, и вы еще не понимаете, что он будет с вами делать.
4597.02 4602.14 "Анатолий Кулаков" Ну, звучит как имейте фича-флаг на любую вашу фичу.
4602.14 4603.14 "Игорь Лабутин" Да, почему нет?
4603.14 4607.02 "Игорь Лабутин" Рекомендации-то полезные, а вопрос, насколько дорого их следовать.
4607.02 4614.82 "Анатолий Кулаков" Да, потому что обычно это всегда дорого и поддерживать, и как бы включать, и выключать, и следить, и не забывать,
4614.82 4618.74 "Игорь Лабутин" это дорого. Ну, слушай, как всегда вопрос вашей бизнес-модели.
4618.74 4640.82 "Игорь Лабутин" Если бизнес-модель зарабатывает на этом деньги, ну в смысле на том, что вы честно выполняете свои слои по предоставлению вашего IP, то наверное вы будете иметь возможность выключить быстро rate limit, если вдруг что-то происходит такое, что нужно временно кастомеру выдать много, ну то есть типа, если вы по ошибке rate limited какого-то кастомера, то что вы имеете возможность быстро ему включить, а там разбираться.
4640.82 4644.50 "Игорь Лабутин" В общем, понятно, что все зависит от бизнес-модели.
4644.50 4648.18 "Игорь Лабутин" Давай теперь пойдем в, собственно, тутнет, и что у нас произошло.
4648.18 4659.38 "Игорь Лабутин" А произошло у нас то, что в седьмом тутнете нам завезли штатную медлеварку по rate limiting, причем нам это завезли в виде аж двух Nuget пакетов.
4659.38 4674.46 "Игорь Лабутин" Поддержаны сейчас четыре алгоритма, ну на момент того, что я читал, поддержаны четыре алгоритма, это concurrency limit, это самое простое, что я говорил, просто условно тупо счетчик тиросимофор, есть token bucket limit, есть fixed window и sliding window.
4674.46 4678.50 "Игорь Лабутин" И те, кто не попал, он как, отбрасывает или ждет?
4678.50 4691.90 "Игорь Лабутин" Те, кто не попал, по-моему, сейчас же отбрасывают, ну в смысле, респонс присылается, тот самый, который по дефолту 503, но есть опция при настройке, можно сказать, нет, все-таки шли к 429.
4691.90 4700.50 "Игорь Лабутин" Для всего вот этого базовые алгоритмы, вот это все запаковано в Nuget пакет под названием system trading rate limiting.
4700.50 4706.06 "Игорь Лабутин" Там есть всякие базовые классы, примитивы для этого и так далее.
4706.06 4723.18 "Игорь Лабутин" Базовый класс для всего этого rate limiter, там есть стандартный набор методов, require, это типа получить, так сказать, токен на исполнение, если require вам вернул условный окей, то значит можно выполнять реквест, если не вернул, значит надо что-то с ним сделать.
4723.18 4734.62 "Игорь Лабутин" Можно вызвать wait_async, и тогда мы будем ждать, когда у нас освободится токен, то есть ты это можешь контролировать в принципе у себя в логике, что делать, если не случилось.
4734.62 4743.06 "Игорь Лабутин" И можно там всякие специфические методы, idle_duration, get_awaited_permits, они уже более специфичны для различных алгоритмов.
4743.06 4749.98 "Игорь Лабутин" Ну на самом деле во всех этих алгоритмах, которые я из 4 перечислил, есть понятие, сколько у тебя есть пермитов этих самых, то есть сколько реквестов.
4749.98 4752.06 "Анатолий Кулаков" То есть ты перечислил только один, ты сказал concurrency_limit
4752.06 4754.06 "Игорь Лабутин" и все. Token_bucket, fixed_window и sliding_window.
4754.06 4756.06 "Игорь Лабутин" Ну которых ты вначале еще говорил.
4756.06 4758.70 "Игорь Лабутин" Да-да-да, вот их 4 есть, они в дотнете реализованы.
4758.70 4764.70 "Игорь Лабутин" Ну в дотнете нет leaking_bucket, или как он называется, leak_bucket.
4764.70 4765.70 "Игорь Лабутин" Протекающего ведра.
4765.70 4766.70 "Игорь Лабутин" Протекающего, да, ведра.
4766.70 4772.34 "Игорь Лабутин" Вот его не сделали, по крайней мере я не видел, может быть сделали в последнем, там в 8 превью, не следил.
4772.34 4777.54 "Игорь Лабутин" Все, значит, вот эти все базовые короче абстракции запихнуты в system_training_rate_limiting.
4777.54 4794.10 "Игорь Лабутин" А дальше есть еще штука, там же называется partition_trait_limiter, это тот самый, который умеет партиционировать реквесты, входящие по каким-то данным, по юзерам, по хедрам и так далее, а дальше отдавать решение одному из внутренних rate-limiter.
4794.10 4802.26 "Игорь Лабутин" Есть еще такое понятие как chain_limiter, это вот для случаев, когда я говорил, что вы хотите там 10 в секунду, но 5000 в час.
4802.26 4806.66 "Игорь Лабутин" То есть вы сначала проверяете, что 10 в секунду не превышено, потом что 10 в час не превышено.
4806.66 4809.74 "Игорь Лабутин" Если хотя бы один сработал, значит точно нельзя.
4809.74 4812.82 "Игорь Лабутин" А если все пропустили, значит можно.
4812.82 4822.66 "Игорь Лабутин" После этого у вас есть пакет от ASP.NET части, называется Microsoft ASP.NET Core Rate Limiting, который уже предоставляет middleware и все нужные методы расширения.
4822.66 4844.10 "Игорь Лабутин" Для того, чтобы все это заиспользовать, нужно во-первых позвать add_rate_limiter, чтобы добавить как обычно в service collection все настройки для rate-limiting, вы туда передаете rate-limiter options, это такой, ну это класс options, но это на самом деле, я так понимаю, билдер, по сути, куда вы дальше накидываете всякие разные полиси.
4844.10 4861.66 "Игорь Лабутин" Полиси по сути именуются строчками, и дальше вы эти самые полиси задаете, в каждой полиси можно задать коллекцию rate-limiter, которые будут исполняться, если найдется endpoint с нужной полиси, в смысле, если в endpoint будет написано применить rate-limiter с нужной полиси.
4861.66 4873.10 "Игорь Лабутин" Дальше вы вызываете как обычно use_rate_limiter для добавления middleware, но это еще не будет ничего, ни на что влиять, то есть если вы просто позовете use_rate_limiter, ничего не будет происходить.
4873.10 4878.86 "Игорь Лабутин" Дальше вам нужно такие, эти самые полиси где-то указать на конкретных endpoints.
4878.86 4904.54 "Игорь Лабутин" Для этого, если вы используете minimal API, вы пишете require_rate_limiting - метод расширения после каждого endpoint или группы endpointer, которые вы хотите, за rate-limiter указывая имя полиси, либо если вы в контроллере работаете, там есть два атрибута enable_rate_limiting и disable_rate_limiting, которые могут использоваться на уровне контроллера, либо методов, так чтобы вы могли разрешать или соответственно отключать rate-limiting для конкретных методов или контроллеров.
4904.54 4908.78 "Игорь Лабутин" И эта штука также может использоваться в Razor Pages, там тоже можно rate-limiting накручивать.
4908.78 4918.54 "Игорь Лабутин" Это то, что было заведено в 7-м, по-моему каких-то сильных улучшений я не видел в 8-м, поэтому посмотрим, может что еще улучшат.
4918.54 4942.34 "Игорь Лабутин" В принципе, если вы раньше работали на sp.netcore, вы наверняка встречались с пакетом sp.netcore_rate_limit, называется он, это, ну, я бы сказал, что по-моему это чуть ли не единственный пакет с rate-limiting, он такой плюс-минус популярный, который я встречал на GitHub, когда я исследовал эту штуку, год-два назад, наверное, еще до выпуска микрософтской версии.
4942.34 4967.34 "Игорь Лабутин" Но там есть по сути только алгоритм фиксированного окна, и автор на самом деле сказал, что ну, в общем, с выходом .NET 7 API нет смысла как-то сильно продолжать разработку вот именно старого лимитера, потому что новый круче, шире, глубже и лучше, и поэтому он сконцентрировался на другой библиотеке, которая позволяет как раз-таки делать удобный интерфейс для шаринга всех вот этих конфигурационных данных через RACE.
4967.34 4986.54 "Игорь Лабутин" То есть чтобы у вас, если вы таки, вам нужно хорошее консистентное состояние всех rate-лимитеров на всех ваших нодах, то вы скорее всего захотите как-то все это консистентно синхронизировать через общий кэш, и вот у него там есть библиотечка, которая использует .NET 7 API rate-limiting, чтобы это все работало.
4986.54 4996.26 "Игорь Лабутин" На этом, наверное, все, если вы хотите послушать еще побольше вокруг rate-лимитинга, немножко с внутренней стороны, как раз про алгоритмы, про то, как оптимально это все реализовывать.
4996.26 5004.38 "Игорь Лабутин" У нас есть отличный доклад на SPB.net от Жени Пешкова, который он рассказывал буквально недавно, ссылочка тоже есть в описании.
5004.38 5013.66 "Игорь Лабутин" Смотрите, слушайте, там прям час очень внутренней технологической штуки про то, как все эти токен-бакеты и прочие штуки делаются достаточно оптимально.
5013.66 5021.26 "Анатолий Кулаков" Ну и там красиво это все, с картинками, с примерами, с рассказами, то есть можно не только на слуг воспринимать, но и визуальный свой взор тоже потешить.
5021.26 5025.70 "Игорь Лабутин" Я боюсь, что там только на слух не воспринять.
5025.70 5026.70 "Игорь Лабутин" Там нужно смотреть.
5026.70 5038.46 "Анатолий Кулаков" Именно смотреть и вникать, потому что там Женя рассказывает очень интересные глубокие корни, а также прекрасно то, что он там находит кучу проблем у этих алгоритмов и у их реализации.
5038.46 5048.66 "Анатолий Кулаков" И еще более прекрасно то, что Женя сейчас готовит специальную библиотеку с примитивами для concurrency, которые такие могут использоваться в том числе для rate-лимитинга.
5048.66 5055.46 "Анатолий Кулаков" В общем, если вам все это интересно, то обязательно посмотрите доклад и напомню, что уже есть хороший блог в Телеграме.
5055.46 5058.46 "Анатолий Кулаков" В общем, тоже подписывайтесь, если вы еще не сделали этого.
5058.46 5060.86 "Игорь Лабутин" Да, а мы пойдем дальше.
5060.86 5066.94 "Игорь Лабутин" Продолжаем разгребать старые и темы, которые все еще на самом деле актуальны.
5066.94 5072.58 "Игорь Лабутин" И следующая наша тема тоже, кстати, двухлетней давности.
5072.58 5082.62 "Игорь Лабутин" Но тем не менее, она все еще, наверное, актуальна, хотя не сказать, чтобы я сильно видел прям широкое ее использование, но кажется, она довольно нишевая и может быть кому-то, тем не менее, пригодится.
5082.62 5085.22 "Игорь Лабутин" Называется она .NET Reproducible Builds.
5085.22 5090.54 "Игорь Лабутин" Что вообще такое reproducible билды и зачем это все делалось?
5090.54 5108.06 "Игорь Лабутин" Есть отдельный репозиторий, который называется Reproducible Defense Builds, ну, в .NET, понятное дело, организации, и у них есть прям отдельные статейки или части видми, которые описывают, что это, зачем это и как это работает.
5108.06 5114.26 "Игорь Лабутин" И принципы, цели, можно сказать, которым они следуют, заключаются в следующем.
5114.26 5115.62 "Игорь Лабутин" Вообще, что они хотят построить?
5115.62 5133.74 "Игорь Лабутин" Они хотят построить штуку, которая, пакет, точнее, Nuget пакет, по сути, который позволяет сделать так, что если вы его включите к себе в ваш продукт, в ваше там, да или лень, приложение, то ваше приложение будет собираться, предсказуя, на любой машине.
5133.74 5140.66 "Игорь Лабутин" То есть это значит, что на какой бы машине вы не собрали конкретную гидревизию, у вас получится абсолютно одинаковый бинарный код.
5140.66 5151.50 "Игорь Лабутин" Ну, с точностью до того, что в PE-формате там пишется дата на самом деле сборки, поэтому понятно, что дата будет разная, там 4 байта будут отличаться, все остальное должно быть теоретически идентично.
5151.50 5155.90 "Игорь Лабутин" Для того, чтобы этого добиться, нужно на самом деле довольно много.
5155.90 5159.90 "Игорь Лабутин" Как ни странно, вот тут, знаете, это особенно актуально, особенно если мы говорим про дотант фреймворк.
5159.90 5160.90 "Игорь Лабутин" Там вообще все сложно.
5160.90 5173.22 "Игорь Лабутин" Во-первых, нужно, чтобы билд не использовал по возможности любой софт, установленный на компе и настройке.
5173.22 5197.82 "Игорь Лабутин" Это прям звучит, может быть, контринтуитивно, но тем не менее, это так, то есть репозиторий должен на самом деле полностью описывать все, что нужно для его сборки, и желательно, причем прям устанавливал бы, был бы какой-нибудь либо скриптик, либо что-нибудь, который бы устанавливал все эти тулы, и желательно не глобально, а как-нибудь локально, так, чтобы они не мешали основным возможному воркфлоу пользователю.
5197.82 5204.62 "Игорь Лабутин" Понятно, что если это ваш родной репозиторий, на котором вы работаете каждый день, может быть, все эти тулы у вас и будут стоять прямо глобально на компе.
5204.62 5221.74 "Игорь Лабутин" Но если вы просто склонировали какой-то левый репозиторий, который вам нужно просто быстренько собрать, посмотреть, что он делает, и потом забыть про него, ну или результат сборки заиспользовать, и больше он вам не нужен будет как репозиторий, то понятно, что ставить там гору каких-то странных версий .NET SDK или еще чего-нибудь будет странно.
5221.74 5226.46 "Игорь Лабутин" Ну вот, было бы лучше, чтобы можно было обойтись без этого.
5226.46 5235.98 "Игорь Лабутин" С другой стороны, если билд такого репозитория что-нибудь ставит, то было бы неплохо иметь возможность это все почистить.
5235.98 5247.18 "Игорь Лабутин" Но подставить обычно подразумевается в идеале это как-нибудь скопировать или распаковать папочку в этом же репозитории, которая добавлена в gitignore и больше никак ничего не происходит.
5247.18 5251.06 "Игорь Лабутин" Потому что тогда gitclean вам вообще все почистит в идеальном виде.
5251.06 5261.46 "Игорь Лабутин" Дальше, третий принцип, что репозитория должен быть самописываемой.
5261.46 5272.78 "Игорь Лабутин" Во-первых, если вам таки требуются какие-то внешние зависимости, которые невозможно поставить, кроме как глобально, сделайте отдельный скриптик, который желательно это сможет поставить без участия пользователя.
5272.78 5276.10 "Игорь Лабутин" Ну или по крайней мере проверить, что у вас там все поставлено.
5276.10 5288.34 "Игорь Лабутин" Если скриптиков не получается, напишите это нормально в редми прям прямым текстом для того, чтобы собрать этот репозиторий вам нужно, чтобы на компе стояли такой-то там не знаю visual studio обязательно такая-то с такими-то ворклоудами, с такими-то галочками проставленными.
5288.34 5298.70 "Игорь Лабутин" Потому что догадываться, что вам там нужно, что вам нужно какая-нибудь там не знаю C++, что-нибудь там поддержка совместимости 2015 студии никто не будет.
5298.70 5300.50 "Игорь Лабутин" Ну и перебирать их там миллион разных.
5300.50 5316.54 "Игорь Лабутин" И каждый тул, который используется во время сборки, желательно, чтобы все тулы, точнее, чтобы для всех тулов, которые используются во время сборки, можно было бы зафиксировать версию, то есть поставить ту версию, которая именно нужна для сборки.
5316.54 5321.46 "Игорь Лабутин" Потому что бывает такое, что в новых версиях тулов ну чё-нибудь ломают.
5321.46 5329.70 "Игорь Лабутин" Или они перестают там поддерживать нужные командлайны, или там закрадываются какие-нибудь баги, которые не позволяют собрать старый какой-нибудь репозиторий.
5329.70 5331.82 "Игорь Лабутин" Даже если он старый, в смысле годичной давности.
5331.82 5338.22 "Игорь Лабутин" Вам нужно было делать чё-нибудь под правильный или ну гетерестор, но сюда ресторить по-другому и как бы все привет.
5338.22 5340.14 "Игорь Лабутин" Вот это все принципы и цели.
5340.14 5346.74 "Игорь Лабутин" Это все очень хорошо описывается, было бы здорово жить в таком мире, но мы живем в практическом мире, надо что-то делать практически.
5346.74 5349.14 "Игорь Лабутин" И практически возникает следующий момент.
5349.14 5363.90 "Игорь Лабутин" Оказывается, дотнетная сборка, она довольно-таки самостоятельна, в том смысле, что она довольно много всего пытается о вашем компе узнать, и чтобы всеми силами хоть чё-нибудь, но собрать.
5363.90 5374.54 "Игорь Лабутин" Это очень полезное свойство, в смысле что чё-нибудь она в любом случае попытается собрать, найти подходящие языка и еще что-нибудь в таком духе, но проблема в том, что возможно она соберет не тем, чем вы ожидаете.
5374.54 5382.10 "Игорь Лабутин" И чтобы с этим бороться, на самом деле оказывается есть несколько способов подавить такое поведение, и в этом репозитории они как раз собраны.
5382.10 5386.22 "Игорь Лабутин" И запакованный в NuGet пакет, сейчас мы про это потом попозже поговорим.
5386.22 5398.82 "Игорь Лабутин" Сначала расскажу про то, а какие же способы и что на самом деле оказывается умеет делать дотнетная сборка, от чего вы хотите отказаться, если вы хотите получать предсказуемые билды.
5398.82 5401.86 "Игорь Лабутин" И те, которые можно зарепродичить у кого угодно.
5401.86 5409.74 "Игорь Лабутин" Ну во-первых, это наверное всем очевидно, и первым, кто работает над фреймворком, первое, что придет в голову, нельзя искать ничего в гаке.
5409.74 5416.06 "Игорь Лабутин" GlobalAssemblyCache, потому что нет никакой гарантии, что у другого пользователя что-то в этом GlobalAssemblyCache будет.
5416.06 5426.46 "Игорь Лабутин" Для того, чтобы это сделать, нужно заверрайдить NuGet, ой, не NuGet, а то скажу, MSBuildableProperty под названием AssemblySearchPath, убрать оттуда гак, и тогда все будет хорошо.
5426.46 5429.46 "Игорь Лабутин" Второй момент.
5429.46 5447.94 "Игорь Лабутин" Dotnet.exe, по крайней мере, как указано в статье версии 5.0 или раньше, я не знаю, может быть они это убрали из более новых версий, но если вы что-то собираете еще в 5.0, например, с DK или в 3.0 и так далее, поставьте dotnet.multilevellookup переменную в 0.
5447.94 5453.02 "Игорь Лабутин" Это такое переменное окружение, потому что иначе dotnet.exe работает следующим образом.
5453.02 5466.26 "Игорь Лабутин" Он пытается собраться тем из DK, которые у него есть рядышком, но если его нет, он заглянет в реестр равенды и посмотрит, нет ли там какого-нибудь из DK другого, где-нибудь установленного случайно.
5466.26 5476.26 "Игорь Лабутин" Он попробует подтянуть из DK из студии, даже если вы собираете коммонлайн, и никак не связывается со студией, там даже solution файла нету, неважно.
5476.26 5480.54 "Игорь Лабутин" То есть он будет всеми силами пытаться найти хоть какой-нибудь из DK, чтобы собрать ваш проект.
5480.54 5486.10 "Игорь Лабутин" Это очень полезно, если вы как бы девелопер, но это не очень полезно для воспроизводимости потом.
5486.10 5489.02 "Игорь Лабутин" Потому что каким из DK он соберет, это надо будет еще угадать.
5489.02 5490.02 "Игорь Лабутин" Дальше.
5490.02 5512.10 "Игорь Лабутин" По дефолту, когда вы используете NuGet пакеты, есть такой файлик Microsoft.net/nuget/flyoncachetargets, и он добавляет в путь поиска NuGet пакетов папочку под названием NuGet fallback folder внутри папочки SDK из вашей инсталляции dotnet.
5512.10 5515.82 "Игорь Лабутин" И что туда попадет, на самом деле неизвестно.
5515.82 5524.54 "Игорь Лабутин" То есть вы думаете, что вы все контролируете через NuGet конфиг, вы там показали, что в NuGet конфиге, который лежит у вас в репозитории, искать только вот в моем NuGet source.
5524.54 5533.94 "Игорь Лабутин" Но на самом деле он всегда будет искать в этом NuGet fallback фолдере, и как бы что он там найдет, кто туда что поставит, неизвестно.
5533.94 5536.98 "Игорь Лабутин" Для этого есть отдельная пропертиа, называется DisableImplicitNugetFallbackFolder.
5536.98 5550.90 "Игорь Лабутин" И такая же есть для DisableImplicitLibrary.px, потому что помимо того, чтобы искать пакеты в этом NuGet fallback фолдере, на самом деле он их еще ищет в другой папочке.
5550.90 5554.22 "Игорь Лабутин" Никогда не догадаешься, он ищет в папочке под названием SDK/F#.
5554.22 5555.22 "Игорь Лабутин" Вот.
5555.22 5556.22 "Игорь Лабутин" Ух ты.
5556.22 5557.22 "Игорь Лабутин" Вот, внезапно так.
5557.22 5569.22 "Игорь Лабутин" Потому что там туда обычно складывается F# core, обычно именно оттуда дистрибьютизируется типа F# core, он же NuGet пакетом, но он нужно, чтобы он стоял везде.
5569.22 5572.46 "Игорь Лабутин" Поэтому он туда складывается или складывался.
5572.46 5579.74 "Игорь Лабутин" И какая там версия будет лежать, из какого там сервис пака, условно говоря, патч-версии, никто не знает.
5579.74 5583.02 "Игорь Лабутин" Можно тоже задезайпить.
5583.02 5590.34 "Игорь Лабутин" Следующая штука относится к NuGet Restore, и это прям такой, есть промышленное GitHub, которое обсуждает, баг это или не баг.
5590.34 5595.30 "Игорь Лабутин" Есть такое переменное окружение, называется NuGet_XMLDoc_Mode.
5595.30 5602.22 "Игорь Лабутин" Ее можно задать значение None, ну или пустое, либо туда можно передать параметр skip.
5602.22 5611.74 "Игорь Лабутин" И если туда передать параметр skip, то при NuGet-ресторе не будут ресториться XML-файлы XML-доков.
5611.74 5622.94 "Игорь Лабутин" То есть если вы в NuGet пакет запаковали XML-доки, то если вы ресторите такой NuGet пакет, когда NuGet XML-док-мод поставлен в skip, то ваши XML-доки не заресторятся.
5622.94 5624.90 "Анатолий Кулаков" Интересно, а для чего вообще такой флажок был выдуман?
5624.90 5626.86 "Игорь Лабутин" Какую проблему решали?
5626.86 5636.98 "Игорь Лабутин" Решали проблему дисков и времени места, и времени сборки, когда это делается в докере.
5636.98 5657.34 "Игорь Лабутин" Дело в том, что в базовом имидже .NET SDK, сейчас не скажу точно каких версий, но по-моему всех относительно, включая современные, это переменное как раз стоит в skip, чтобы когда ты собираешь внутри докера, ты не тратил время на распаковку XML-доков, которые нафиг никому не нужны внутри докера.
5657.34 5659.58 "Анатолий Кулаков" Ну да, в таком случае логично.
5659.58 5664.30 "Анатолий Кулаков" Просто странно, почему ее не сделали опцией NuGet рестора, допустим, а через какой-то странный переменный.
5664.30 5669.78 "Игорь Лабутин" Ну потому что она нужна только внутри типа этого, решили вот так перейти через переменное окружение.
5669.78 5673.66 "Игорь Лабутин" Но к сожалению, закралась одна проблема.
5673.66 5678.02 "Игорь Лабутин" Как ты поймешь, что файлик, который лежит внутри, это XML-док?
5678.02 5679.02 "Игорь Лабутин" Погоди, внутри чего?
5679.02 5680.02 "Игорь Лабутин" Внутри пакета?
5680.02 5681.02 "Игорь Лабутин" У него расширение XML будет.
5681.02 5684.54 "Игорь Лабутин" Ну у тебя могут быть какие-нибудь, так сказать, контент-файлы с расширением XML.
5684.54 5688.30 "Анатолий Кулаков" Ну тогда никак, по-моему, XML-доки больше никак себя
5688.30 5695.14 "Игорь Лабутин" не распознают. Ну в общем проблема в том, что если эта опция стоит в skip, то контент-файлы с XML тоже не распаковываются и не ресторятся.
5695.14 5697.14 "Игорь Лабутин" И у тебя билд, ясное дело, ломается.
5697.14 5699.50 "Игорь Лабутин" Ну в смысле, у тебя NuGet-пакет получается неполноценный.
5699.50 5702.14 "Анатолий Кулаков" То есть он просто все XML нафильтрует, ему все равно
5702.14 5712.62 "Игорь Лабутин" доки и цели не дают? Ну там есть какая-то эвристика, но народ пишет реальную ищу со словами типа, чуваки, мой NuGet-пакет не ресторится, но мы там поставляем XML-файлы, они нам нужны.
5712.62 5716.42 "Игорь Лабутин" Это кусок там внешней конфигурации, условно говоря, нам нужен XML-файл, это не XML-док.
5716.42 5718.42 "Игорь Лабутин" А он не ресторится из-за этой опции.
5718.42 5719.42 "Игорь Лабутин" Ставлю в none, ресторится.
5719.42 5732.50 "Игорь Лабутин" Вот, поэтому если вы хотите повторяемых билдов, чтобы ничего не ломалось, вы заплатите тем, что все там заресторится ну большим объемом, но зато точно целиком.
5732.50 5733.50 "Игорь Лабутин" Вот.
5733.50 5741.22 "Игорь Лабутин" Дальше есть еще всякие штуки типа target-framework-root-path и net-core-targeting-pack-root.
5741.22 5749.26 "Игорь Лабутин" Тут примерно то же самое тема, что с тем как .NET XE Multilevel Lookup, то что я говорил раньше.
5749.26 5756.90 "Игорь Лабутин" Есть такой target, под названием get-reference-assembly-path, то есть где искать референсные сборки.
5756.90 5772.94 "Игорь Лабутин" Он тоже, короче, очень умный, он пытается найти хоть что-нибудь, он слазает во все программ-файлы, он слазает в Windows, ну в реестр, чтобы найти хоть какие-нибудь референс-эссембли, ну, чтобы скомпилировать ваше приложение.
5772.94 5777.82 "Игорь Лабутин" Лучше всего это делать не так, если вы хотите reproducible билдов.
5777.82 5792.70 "Игорь Лабутин" Есть специальный NuGet пакет, название Microsoft.NET Framework для .NET, если точка reference-assemblies, куда включены все нужные reference-assemblies для .NET Framework конкретно, и для всех дескопных вот этих вот фреймворковых версий.
5792.70 5803.50 "Игорь Лабутин" Соответственно, используйте его явно и выключите нафиг этот target-framework-root-path, ставите его в undefined, по-моему, его надо поставить, и тогда у вас будет счастье и хорошо.
5803.50 5806.94 "Игорь Лабутин" Вот ваш билд будет типа reproducible.
5806.94 5812.26 "Игорь Лабутин" И я вот так вот говорю, все тут надо вот кажется поставить в то, кажется поставить в это.
5812.26 5818.78 "Игорь Лабутин" Про некоторые эти опции, они на самом деле хорошо документированы в официальной документации Microsoft, а некоторые не документированы совсем.
5818.78 5828.02 "Игорь Лабутин" Поэтому, чтобы это все правильно делать, Microsoft выпустила два пакета, один называется .NET Reproducible Builds, другой называется .NET Reproducible Builds.isolated.
5828.02 5841.14 "Игорь Лабутин" Вот тот, который isolated, он как раз добавляет в ваш проект все нужные переопределения, всех вот этих переменных окружения и прочего, всего того, что вы видите, что я рассказал выше.
5841.14 5846.98 "Игорь Лабутин" То есть, assembly_search_path подправить, всякие disable, implicit, nuget, fullback_folder поставить в true.
5846.98 5850.58 "Игорь Лабутин" Единственное, что он не может сделать, это, понятно, поставить переменные окружения.
5850.58 5860.50 "Игорь Лабутин" То есть, ну, nuget.xml.doc и .NET Multilevel Lookup вам придется поставить самому, когда вы там собираете у себя где-то в докере или в скриптах.
5860.50 5863.90 "Игорь Лабутин" А .NET Reproducible Builds пакет, он делает немножко другое.
5863.90 5889.38 "Игорь Лабутин" Он на самом деле делает ваш nuget, ну, так скажем, красивым и аккуратным, в том смысле, что он туда добавит всякие опции в CSS-продж, типа Embedded Tracked Sources, то есть те сурсы, которые там каким-то образом не лежат в репозитории почему-то, например, там генерятся тулами или еще как-то.
5889.38 5896.82 "Игорь Лабутин" Видимо, я уже не знаю, как они могут, если генерятся тулами, они должны, значит, при следующем билде генериться.
5896.82 5903.26 "Игорь Лабутин" Но, в общем, есть такая опция Embedded Tracked Sources, которая почему-то не трекается с форс-контролем, но почему-то должны быть включены в пакет.
5903.26 5914.42 "Игорь Лабутин" Они будут включены, он ставит debug_type Embedded, он добавляет волшебную опцию include_package_references_during_markup_compilation, которая позволяет правильно собирать XAML, чтобы это было reproducible.
5914.42 5924.94 "Игорь Лабутин" В общем, ставит такой набор каких-то правильных опций, которые позволяют потом получать nuget-пакет, который правильно, значит, хорошо дебажится, там, с source-link и всем добром.
5924.94 5940.54 "Игорь Лабутин" Вот такая история, если вы заинтересованы в том, чтобы распространять nugets, которые легко собираются, распространять репозиторий, которые тривиально собираются без необходимости настройки кучи tools для .NET.
5940.54 5944.02 "Игорь Лабутин" Ну вот посмотрите в эту сторону, я думаю...
5944.02 5945.90 "Игорь Лабутин" Нет, давай так.
5945.90 5960.34 "Игорь Лабутин" Мне кажется, что они планировали больше движухи в этом направлении, потому что это все на самом деле начиналось из-за того, что им нужно было собирать reproduce с возможностью повторения из сам .NET для Linux, потому что это требование.
5960.34 5965.94 "Игорь Лабутин" Для того, чтобы быть включенным в официальный Linux-репозиторий, ты должен быть уметь собранным из исходников.
5965.94 5976.70 "Игорь Лабутин" Я надеялся, что они побольше немножко сделают в этом направлении, то есть как раз-таки покажут примеры скриптов, как там, ну, условно, .NET SDK ставить изолированно от всех на машине.
5976.70 5990.78 "Игорь Лабутин" Но, видимо, такие штуки надо собирать уже по нормальным репозиториям обычным, .NET-овским или каким-нибудь общим вот этим вот сборным, которые собирает весь .NET SDK или Runtime, чтобы там эти примеры посмотреть.
5990.78 6000.18 "Игорь Лабутин" Пока репозитория выглядит немножко заброшенным, ну, то есть там какие-то раз в месяц-два какие-то коммиты бывают, но по большому счету основной документацией и несколько там props и target files.
6000.18 6007.98 "Анатолий Кулаков" Погоди, ну так а вообще статус этой движухи они доделали, то есть действительно, выставив все эти опции, мы получим reproducible build?
6007.98 6026.38 "Игорь Лабутин" Мы получим reproducible build на уровне .NET, то есть тебе все равно нужен какой-то, то есть у тебя будет там, допустим, global.json, который тебе скажет, что для того, чтобы собрать это, тебе нужно обязательно SDK версии там 6.0, 7.0, какая там сейчас 1.
6026.38 6034.46 "Игорь Лабутин" И если ты такую версию сам себе поставишь, то после этого у тебя такой пакет, который используют на reproducible build, он соберется.
6034.46 6043.14 "Анатолий Кулаков" Ну, в любом случае, конечно, тебе нужен SDK, но понятное дело, что без компилятора там и без BCL ты ничего не сделаешь.
6043.14 6050.14 "Анатолий Кулаков" Другой вопрос, что могу ли я все-таки собирать свои приложения предсказуемо уже сейчас, вот с теми опциями,
6050.14 6053.86 "Игорь Лабутин" которыми ты рассказал. Кажется, что можешь, они будут более предсказуемы.
6053.86 6055.78 "Игорь Лабутин" Вопрос, зачем?
6055.78 6057.82 "Игорь Лабутин" Ну, то есть… Так, чисто по фану.
6057.82 6058.82 "Игорь Лабутин" Чисто по фану точно можешь.
6058.82 6059.82 "Игорь Лабутин" Все посвятствует себе линксоидам.
6059.82 6076.62 "Игорь Лабутин" Они, вот я говорю, что мне просто хотелось, наверное, как-то внутренне, когда все это начиналось 2 года назад, казалось, что они будут пушить это более активно, но, видимо, это действительно чисто внутренняя движуха для вот linksway, для попадания в их репозиторий, а на паблик для всех остальных на самом деле это почти никогда не нужно.
6076.62 6083.62 "Игорь Лабутин" Ну, то есть мне кажется, редко, когда тебе нужно прямо вот так вот собирать, репродюсно, с бинарной точностью, все остальное.
6083.62 6085.46 "Игорь Лабутин" Ну, какие-то свои блятьики.
6085.46 6086.46 "Игорь Лабутин" Собралось и ладно.
6086.46 6097.10 "Игорь Лабутин" Здесь скорее больше вот интересны именно принципы и цели, когда там говорится, что желательно не требовать от пользователя установки миллион тулов, там, неизвестных версий, типа.
6097.10 6100.66 "Игорь Лабутин" Для сборки этого репозитория нам нужен, там, не знаю, MATLAB.
6100.66 6105.86 "Игорь Лабутин" Когда-то давно у нас был такой, типа, какой MATLAB, какой runtime.
6105.86 6110.10 "Игорь Лабутин" Runtime MATLAB, не runtime MATLAB, SDK, не SDK.
6110.10 6112.98 "Игорь Лабутин" 32 бита, 64 бита, укажите вы это все.
6112.98 6115.30 "Игорь Лабутин" Их там миллион версий разных.
6115.30 6118.38 "Игорь Лабутин" Четкую версию желательно с ссылкой на инсталлер.
6118.38 6119.38 "Игорь Лабутин" Было бы идеально.
6119.38 6121.02 "Игорь Лабутин" Вот, скорее, про это речь.
6121.02 6122.58 "Игорь Лабутин" Это, конечно, полезные практики.
6122.58 6132.50 "Анатолий Кулаков" Не, ну вообще интересно было посмотреть, а почему сборка сама по себе может быть меняющейся, вот от чего это зависит, поэтому все вот эти пункты, которые я прочитал, они абсолютно неинтуитивны.
6132.50 6134.50 "Игорь Лабутин" Ну, это правда, да.
6134.50 6140.86 "Игорь Лабутин" Тут факт, что у меня там, типа, вроде не стоит SDK, а вроде откуда-то он волшебным образом найдется.
6140.86 6163.94 "Игорь Лабутин" Причем там же фишка же в чем, .NET.EXE это найдет, а вот когда MS Build какой-нибудь в кастомной таске полезет что-нибудь делать, выяснится, что MS Build не той версии, если я к ним встречался, что подтягивается MS Build из студии, и поэтому он там не 16-ый, а 15-ый, или такой там был не 15-ый, а 14-ый, и вот нужная в версии таска несовместима, сборка не грузится, все пропало.
6163.94 6167.86 "Игорь Лабутин" И ты сидишь и думаешь, я же вроде в 15-ом собираю, а чего он в 14-ом полез?
6167.86 6173.30 "Игорь Лабутин" А вот он там сделал тебе приятное и нашел подходящий MS Build.
6173.30 6184.62 "Анатолий Кулаков" Да, на самом деле, Build это большая интересная тема, особенно если у вас там уже несколько версий .NET накопилось с разными зависимостями, под разные операционные системы, с разными либоми нативными.
6184.62 6185.62 "Анатолий Кулаков" Это всегда весело.
6185.62 6194.58 "Игорь Лабутин" Да, ну что, давай таки вернемся к… Закончим про Solid и вот это все, позанимались мы .NET.
6194.58 6219.66 "Анатолий Кулаков" Да-да-да, как я уже обещал, интересная альтернатива к Solid возникла, в общем, про которую интересно вам рассказать и обсудить, насколько она действительно альтернатива, насколько она будет более понятная, чем те принципы, которые мы обсуждали с вами в начале выпуска, а по идее она стремилась именно к этому, то есть сделать более какой-то понятный подход и более простой, более очевидный.
6219.66 6229.42 "Анатолий Кулаков" Штука называется Cupid, точно так же в Ependelus, и по первым названиям различных принципов авторы собрали 5 принципов.
6229.42 6236.86 "Анатолий Кулаков" Это прежде всего Composal, далее это Unix Philosophy, Predictability, Ideomatic и Domain Based.
6236.86 6239.86 "Анатолий Кулаков" Сейчас мы по каждому пункту с вами пробежимся.
6239.86 6265.46 "Анатолий Кулаков" Прежде всего автор хотел сделать нам такие принципы, которые позволяли бы все делать проще, абсолютно все, и чтобы у вас код стал сам проще, чтобы навигация по нему была проще, чтобы он был более предсказуемый, чтобы давал понятный результат, и чтобы мы были уверены, что когда мы меняем код, то сайд-эффекты от того, что мы поменяли, соответствовали тому, что мы ожидаем из какой-то непредсказуемости.
6265.46 6278.22 "Анатолий Кулаков" Ну и как сказал великий Мартин Фаулер, что написать код, который способен поднять компьютер, сможет любой дурак, а хороший программист должен уметь писать код, который поймет другой человек.
6278.22 6282.58 "Анатолий Кулаков" Ну или ты же сам в будущем, это тоже будет другой человек.
6282.58 6286.90 "Анатолий Кулаков" Всегда, когда пишете код, думайте о ком-то другом.
6286.90 6289.86 "Анатолий Кулаков" Давайте теперь рассмотрим принципы немножко поближе.
6289.86 6296.86 "Анатолий Кулаков" Composable - это принцип говорит о том, что ваш код должен быть хорошо используем и интегрируем.
6296.86 6313.82 "Анатолий Кулаков" Чтобы это сделать, желательно выделять очень узкий API, то есть выделять какую-то ответственность, очень узкую, которая поможет этот код легко выучить, которая поможет его легко осознать, и сложно сделать что-то с этим кодом такое, что может пойти не так.
6313.82 6318.82 "Анатолий Кулаков" То есть он должен быть четкий, понятный и довольно предсказуемый.
6318.82 6337.78 "Анатолий Кулаков" Также у такого узконаправленного API будет меньше конфликтов и при этом будет меньше неконсистентности, когда он будет взаимодействовать с другими какими-то кусками, потому что он будет полностью отвечать только за ту область, где он компетентен.
6337.78 6359.46 "Анатолий Кулаков" Автор также говорит, что нужно на ранней стадии раскрывать намерения в своем коде, то есть чтобы код был очень легко понятен, для чего он существует, как его использовать, чтобы очень было легко найти компонент, который вам нужен, и четко в первые секунды понять, тот ли это компонент или не тот, нужен он для вашей цели или не нужен, подходит или не подходит.
6359.46 6371.14 "Анатолий Кулаков" И в качестве примера он показывает нам open-source проекты, которые сейчас есть, и большинство из этих проектов, например, содержит краткое описание, которое есть у каждого репозитория.
6371.14 6379.78 "Анатолий Кулаков" Дальше мы можем спуститься в readme, в котором прочитать про что вообще данной репозитории, что она умеет делать, и может быть пройти какие-нибудь туториалы.
6379.78 6395.62 "Анатолий Кулаков" Туториал тоже очень полезно делить на глубину вложенности, там двухминутный туториал, просто чтобы узнать про что данная ваша библиотека сделана, десятиминутный какой-нибудь и как дипдайв на сколько угодно часов, где вы можете копаться в тонкости библиотеки.
6395.62 6401.22 "Анатолий Кулаков" И все это позволяет вам погружаться в репозиторию, в приложение, в библиотеку инкрементально.
6401.22 6408.82 "Анатолий Кулаков" То есть вы можете на первые секунды осознать, что это не ваше, сделать двухминутный обзор, понять, что это не ваше, потом десятиминутный и так далее.
6408.82 6416.46 "Анатолий Кулаков" То есть на любом шаге вы можете отвалиться и это правильно, это хорошо, когда вы осознаете, что не тот инструмент, который вы искали.
6416.46 6423.02 "Анатолий Кулаков" Или же наоборот, можете заходить углубиться подальше в тонкости библиотеки и постепенно можете себе это позволить.
6423.02 6425.90 "Анатолий Кулаков" В общем это тоже прекрасно.
6425.90 6431.02 "Анатолий Кулаков" Дальше что касается Composable, у него должно быть минимум зависимости.
6431.02 6449.34 "Анатолий Кулаков" То есть очень плохо, когда ваша библиотека тащит какие-то большие зависимости, вот как мы обсуждали, например, ISP.NET Core, который раньше тащил Newtonsoft JSON, который мог вполне пересекаться с вашим Newtonsoft в вашем приложении и от этого могли быть различные страшные некрасивые ошибки.
6449.34 6453.58 "Анатолий Кулаков" В общем, чем меньше зависимостей у той библиотеки, которую вы используете, тем лучше.
6453.58 6463.86 "Анатолий Кулаков" Тем меньше вы беспокоитесь о том, что потащите какую-то несовместимость, тем меньше вы будете беспокоиться о каких-то версиях, которые могут быть там уже уязвимы и никто их не может пропатчить.
6463.86 6466.54 "Анатолий Кулаков" В общем, тем меньше проблем будет.
6466.54 6470.58 "Анатолий Кулаков" Поэтому как можно меньше зависимости старайтесь делать в ваших компонентах.
6470.58 6473.54 "Анатолий Кулаков" Следующий, второй принцип это философия Unix.
6473.54 6476.06 "Анатолий Кулаков" Unix, да, притащили не просто так.
6476.06 6479.06 "Анатолий Кулаков" У Unix есть несколько обалденных принципов.
6479.06 6486.78 "Анатолий Кулаков" Один из них, это мы с вами уже обсудили, это делать и компоненты, которые прекрасно работают вместе, в связке с другими компонентами.
6486.78 6488.74 "Анатолий Кулаков" Это как раз был первый принцип.
6488.74 6500.14 "Анатолий Кулаков" И второй принцип здесь, кажется, у Unix он первый, это делайте инструменты так, чтобы они делали одну вещь, но эту одну вещь они должны делать хорошо.
6500.14 6514.42 "Анатолий Кулаков" У Unix вот тоже гранулярность, грубо говоря, микросервисов или микроинструментов, которые делают всего лишь на все что-то одно, но делают это со всех сторон прекрасно, вот она возведена просто в культ, просто в абсолют.
6514.42 6523.18 "Анатолий Кулаков" Ну и по крайней мере не все инструменты, которые в Linux и в Unix есть, этому соответствуют, но стандартные обычно так и делают.
6523.18 6539.14 "Анатолий Кулаков" Например, если взять команду ls, которая показывает список файлов и директорий в определенной папочке, то на самом деле, когда мы начнем разбираться в ее строении, в том, как она работает, на самом деле она вообще ничего не знает, ни о файликах, ни о директориях.
6539.14 6549.06 "Анатолий Кулаков" На самом деле она дергает специальную другую утилиту, которая называется stat, и вот утилита stat уже предоставляет различную информацию об операционной системе и так далее.
6549.06 6555.26 "Анатолий Кулаков" А ls всего лишь на все, что делает, она форматирует информацию из stata в текстовое представление.
6555.26 6556.26 "Анатолий Кулаков" Вот и все.
6556.26 6568.30 "Анатолий Кулаков" Также есть, например, утилита cat, которая печатает вывод одного или нескольких файликов на стандартный output или объединяет их в какой-нибудь другой файлик.
6568.30 6575.98 "Анатолий Кулаков" grep, которая ищет текст по заданному шаблону set, которая меняет текст по шаблону.
6575.98 6592.90 "Анатолий Кулаков" И таким образом, если собрать все эти утилитки в кучу, мы вполне можем написать такой довольно сложный текстовый процессор, который возьмет каждую вот эту утилитку, которая будет практически командой, одной командой, одной менюшкой у этого текстового процессора и заколбасит вам целый ворд.
6592.90 6596.42 "Анатолий Кулаков" Таким образом можно из вот этих утилиток и собирать целую операционную систему.
6596.42 6603.94 "Анатолий Кулаков" В принципе, если вы когда-нибудь сидели под Linux, то разработчик чувствует из себя, как будто он сидит под dde.
6603.94 6612.82 "Анатолий Кулаков" Он может посмотреть абсолютно все, от модуля ядра, заканчивая там командами, заканчивая информацией о том, посмотреть статистику от текущей операционной системы.
6612.82 6619.38 "Анатолий Кулаков" То есть все сделано таким образом, как будто ты сидишь внутри программы, можешь сходить в ее модуль, можешь ее там продебажить, можешь ее там просмотреть.
6619.38 6631.58 "Анатолий Кулаков" И все это с помощью вот таких вот мелковыделенных командлетов, инструментов, дает разработчику полный контроль над тем, что он может сделать.
6631.58 6639.06 "Анатолий Кулаков" То есть это тоже такой хороший принцип, который как раз таки говорит, что ваш компонент должен делать одну маленькую узкую вещь.
6639.06 6645.42 "Анатолий Кулаков" Это очень похоже на Single Responsibility принцип, который мы рассматривали чуть выше.
6645.42 6655.74 "Анатолий Кулаков" Автор говорит, да, Single Responsibility и вот единственная цель, которую ты должен делать, они похожи, но на самом деле немножко разные.
6655.74 6663.70 "Анатолий Кулаков" Потому что SRP отвечает, он требует того, чтобы у вас была только одна причина для изменения вашего компонента.
6663.70 6673.62 "Анатолий Кулаков" Но это значит, что вы получаете в результате много связанных классиков, если вы пытаетесь это загранулировать.
6673.62 6681.30 "Анатолий Кулаков" А вот его подход, который говорит, что у вас должна быть одна вещь, которую делает этот компонент, она более гибкая.
6681.30 6686.58 "Анатолий Кулаков" То есть вы можете сделать эту одну вещь и внутри одного компонента, независимо от его размера.
6686.58 6691.98 "Анатолий Кулаков" То есть здесь вам не нужно отвечать на вопрос, что такое маленькая штучка, что такое маленький компонент.
6691.98 6696.46 "Анатолий Кулаков" Здесь вы просто смотрите, что это помещается в один компонент, делаете в одном.
6696.46 6704.86 "Анатолий Кулаков" Если вы видите, что вам это нужно разносить, что у вас появляется какой-то огромный комок, то значит разносите, уже по какому-то другому принципу делите.
6704.86 6711.10 "Анатолий Кулаков" То есть вы в любой момент можете это все разделить, в зависимости от того, насколько быстро растет ваш компонент, ваше приложение.
6711.10 6718.50 "Анатолий Кулаков" Это делает этот подход отличимым от SRP и может быть дает как раз большую конкретику того, что такое маленькая штучка.
6718.50 6722.22 "Анатолий Кулаков" Следующий принцип у купида это predictable.
6722.22 6726.18 "Анатолий Кулаков" То есть код должен делать то, что вы от него ожидаете.
6726.18 6733.10 "Анатолий Кулаков" Он не должен выдавать вам каких-то странных выводов, не должен предоставлять каких-то сюрпризов.
6733.10 6735.82 "Анатолий Кулаков" Он должен быть детерминированным и обозримым.
6735.82 6740.58 "Анатолий Кулаков" То что вы рассчитываете, то вы в конце концов должны получить.
6740.58 6750.78 "Анатолий Кулаков" Например, структура именования у вашего кода, она должна быть соответствующая, которая положена в вашем freework, в вашем языке.
6750.78 6771.22 "Анатолий Кулаков" И авторы приводят интересный пример, что даже когда у вас нет еще ни одного теста, вы не написали еще ни одного теста, но при этом уже создаете какой-то класс, даже пустой, то давая название классу, вы должны четко понимать, что это название должно полностью описывать то, что будет делать этот класс.
6771.22 6776.46 "Анатолий Кулаков" И это по сути является первым вашим тестом, которых у вас в Solution еще нет.
6776.46 6779.42 "Анатолий Кулаков" Первый тест этого, вы тестируете имя класса.
6779.42 6790.78 "Анатолий Кулаков" Если по имени вы понимаете, что класс делает, значит tdd у вас прошел, то есть первый тест вы уже сами для себя вывели и он уже работает, он уже зеленый.
6790.78 6794.22 "Анатолий Кулаков" Итак, давайте же немножко еще обсудим, что такое детерминированность.
6794.22 6805.02 "Анатолий Кулаков" Это значит, что ваш компонент должен делать одну и ту же задачу, одну и ту же вещь каждый раз, когда вы вызываете его с определенными одними и теми же аргументами.
6805.02 6809.74 "Анатолий Кулаков" И что вы можете предсказать про ваш компонент?
6809.74 6835.18 "Анатолий Кулаков" Глядя на компонент или почитав его документацию, вы должны четко предсказать, например, какая память ему нужна, сколько памяти и в каких ситуациях он будет жрать, какой ему нужен нетворк, какое ему нужно хранилище, насколько интенсивно он будет использовать CPU, какие временные задержки он вам выдаст, какие зависимости он имеет и какие у этих зависимостей тоже есть ожидания от ресурсов.
6835.18 6846.82 "Анатолий Кулаков" В общем, чем больше вы предскажете того, какие ресурсы он будет потреблять, в каком виде и в каких ситуациях и когда, тем лучше, тем больше у вас понимание о том, как правильно или неправильно работает компонент.
6846.82 6849.10 "Анатолий Кулаков" Еще один важный аспект - это Observability.
6849.10 6852.94 "Анатолий Кулаков" Это то, каким образом мы сможем за этим компонентом наблюдать.
6852.94 6862.18 "Анатолий Кулаков" То есть, каким образом мы можем узнать о внутреннем состоянии вашего приложения, вашего компонента, опираясь только на его какие-то внешние показатели.
6862.18 6868.50 "Анатолий Кулаков" И обычно Observability потом добавлять или слишком сложно, или слишком затратно, а в большинстве случаев вообще невозможно.
6868.50 6873.22 "Анатолий Кулаков" Поэтому об Observability вашего компонента нужно задумываться на этапе его проектирования.
6873.22 6876.86 "Анатолий Кулаков" Это будет самая правильная и самая нужная точка.
6876.86 6879.54 "Анатолий Кулаков" Следующая буковка - это Idiomatic.
6879.54 6884.18 "Анатолий Кулаков" Она нам говорит о том, что весь компонент должен ощущаться натурально.
6884.18 6892.66 "Анатолий Кулаков" То есть, он должен быть написан в идиоматичном коде, который принят в вашем сообществе, в вашем языке программирования, в вашем фреймворке.
6892.66 6895.38 "Анатолий Кулаков" То есть, типичный пример, например, это CodeStyles.
6895.38 6905.98 "Анатолий Кулаков" Там табы вы используете или пробелы, какой размер отступов, какие naming convention у вас бывают, какие принято использовать в библиотеке, какими инструментами собирать.
6905.98 6921.74 "Анатолий Кулаков" Все это важно, если это будет различаться, если это будет из проектов, проекты разные, если каждый человек будет использовать что-то другое, это будет добавлять когнитивную нагрузку и в вашей команде будет работать довольно дискомфортно.
6921.74 6932.82 "Анатолий Кулаков" Особенно, когда нас сталкивается с каким-то непонятным кодом, который написан по другим совершенным стилям, по другим naming convention, собирается с помощью других инструментов.
6932.82 6943.98 "Анатолий Кулаков" Это все будет новая нагрузка, которой придется обучаться, где не будут добавлять больше ошибок, где не будут чувствовать себя дискомфортно.
6943.98 6945.94 "Анатолий Кулаков" В общем, этого старайтесь избегать.
6945.94 6956.90 "Анатолий Кулаков" Код должен быть написан так, чтобы его понимали другие люди, в том числе вы сами в будущем.
6956.90 6969.54 "Анатолий Кулаков" Когда вы пишете код и думаете о том, что его будет читать кто-то другой, это как раз таки и называется забота об идиоматичности кода.
6969.54 6974.22 "Анатолий Кулаков" Дальше это языковые идиомы, нужно учитывать в идиоматичности.
6974.22 6981.18 "Анатолий Кулаков" То есть это не только форматирование и наименование, которые мы с вами обсудили, но это еще и структура проектов.
6981.18 7007.02 "Анатолий Кулаков" То, какие типы у вас есть, где они располагаются, какие существуют модули, как принято группировать различные модули, какая структура ваших проектов, какая экосистема, в том числе как у вас принято общаться в сообществе и какие в сообществе приняты стили, которые тоже кстати могут меняться, они могли быть раньше одни, теперь стали совершенно другими.
7007.02 7013.82 "Анатолий Кулаков" И за этим тоже нужно следить и постоянно обновлять и подтягивать ваши компоненты к стилям, которые сейчас приняты в сообществах.
7013.82 7026.46 "Анатолий Кулаков" И последняя буковка это domain-based, рассказывает нам о том, что ваш код должен рассказывать, передавать, что делается в вашей бизнес-логике обычно.
7026.46 7032.58 "Анатолий Кулаков" То есть он должен быть как можно ближе связан с вашим доменным языком.
7032.58 7037.58 "Анатолий Кулаков" Здесь в качестве примеров приводятся примитивые обсешины, которым уже много раз обсуждали.
7037.58 7048.10 "Анатолий Кулаков" То есть если у вас есть какой-то тип, который описывает фамилию пользователя, то его можно представить в виде класса фамилия, а можно представить в виде строки.
7048.10 7051.22 "Анатолий Кулаков" И вот если вы представите в виде строки, это не очень описательно.
7051.22 7054.74 "Анатолий Кулаков" Вот если вы сделаете класс фамилия, это будет более явно.
7054.74 7060.46 "Анатолий Кулаков" Тоже касается класса деньги, адресов, e-mail и так далее.
7060.46 7070.26 "Анатолий Кулаков" Создавая такие конкретные классики, избавляясь от примитивых обсешин, мы делаем код не только более устойчивым к ошибкам, но и снимаем когнитивную нагрузку.
7070.26 7075.74 "Анатолий Кулаков" Читающий человек будет лучше понимать доменную область, в которой он работает.
7075.74 7080.18 "Анатолий Кулаков" Также для снятия когнитивной нагрузки часто делают скелет проекта.
7080.18 7090.86 "Анатолий Кулаков" В этом скелете уже зашивают определенную структуру, которая соответствует вашей доменной области или вашему приложению, или той стратегии, которую ваше приложение должно выполнять.
7090.86 7097.58 "Анатолий Кулаков" Там же добавляют какие-нибудь квик старты, какую-нибудь документацию, которая помогает быстро разобраться в приложениях.
7097.58 7105.98 "Анатолий Кулаков" И обычная эта структура, она как раз таки отражает те бизнес принципы, которые приняты в вашем приложении.
7105.98 7109.42 "Анатолий Кулаков" И вот дальше автор идет расписываться как прекрасен MVC.
7109.42 7117.82 "Анатолий Кулаков" Потому что MVC, по его мнению, он хорошо разделяет и модельку, в которой происходит бизнес логика, и представления, о которых мыслят пользователи.
7117.82 7120.82 "Анатолий Кулаков" Там и контроллер, который пытается все это вместе соединить.
7120.82 7124.86 "Анатолий Кулаков" Но здесь, конечно, можно с ним поспорить, насколько MVC близок к бизнесу.
7124.86 7130.30 "Анатолий Кулаков" Есть более интересные и более хорошие подходы, о которых мы с вами, наверное, поговорим уже в следующих выпусках.
7130.30 7132.70 "Анатолий Кулаков" В общем, вот такой вот купид получился.
7132.70 7140.70 "Анатолий Кулаков" Есть некоторые хорошие идеи, есть некоторые хорошие задатки, которые могут позволить вам спроектировать приложение более интересно.
7140.70 7158.82 "Анатолий Кулаков" Я бы не сказал, что он полностью заменяет Solid, но если вы будете сочетать оба этих подхода, то наверняка сможете делать ваши компоненты еще более лучше, поддержим архитектурно красивше и, соответственно, стабильнее и развиваемее в будущем.
7158.82 7168.74 "Игорь Лабутин" Звучит еще как один набор принципов, которые надо не то чтобы помнить, но они тут уже такие низкоуровневые практически.
7168.74 7176.10 "Игорь Лабутин" Мне кажется, опять же, они все, ну может быть, кроме такого последнего, про domain-based, хотя тоже практически вполне себе.
7176.10 7182.18 "Игорь Лабутин" Вот, с одной стороны, это хорошо, потому что практические штуки, их можно на практике сделать.
7182.18 7186.74 "Анатолий Кулаков" Их хотя бы можно как-то ассоциировать с тем, что ты делаешь, это не какая-то абстрактная вещь.
7186.74 7191.54 "Игорь Лабутин" А с другой стороны, мне кажется, что это тоже из разряда "либо этому следуешь, либо этому".
7191.54 7193.54 "Игорь Лабутин" Ну нет, хотя, наверное, этому можно учить.
7193.54 7195.82 "Игорь Лабутин" Посмотрим, как-то не задумывался.
7195.82 7200.70 "Анатолий Кулаков" Вот здесь многие аспекты, про которые ты не думаешь.
7200.70 7203.58 "Анатолий Кулаков" Взять, к примеру, ту же самую observability.
7203.58 7212.86 "Анатолий Кулаков" Когда ты проектируешь какой-то компонент, мы не говорим про полностью приложение, а вот просто компонент, ты обычно не задумываешься, что за ним нужно будет наблюдать.
7212.86 7237.22 "Анатолий Кулаков" То есть, если ты делаешь какой-то CPU-bound intensive компонент, который начинает там алгоритмы какие-то жуткие у тебя молоть, какую-то числоторобилку делает, было бы неплохо, конечно, выставить ему некие показатели, типа сколько он сейчас там у него буферы, на сколько он сейчас еще может принять дополнительных орешков, которые сможет поколоть, может сколько он памяти там потратил, может на сколько процессор ему еще нужно будет как-то подготовиться.
7237.22 7241.18 "Анатолий Кулаков" То есть, именно компонент обеспечивать этими observability штуками.
7241.18 7244.50 "Игорь Лабутин" Ну, вот, может быть, да, может быть.
7244.50 7254.82 "Игорь Лабутин" Не знаю, я вот как-то ко всем этим принципам действительно, может быть просто потому, что они так уже где-то внутри сидят и аккуратно просто пользуешься и все, даже не осознавая, что ты ими пользуешься.
7254.82 7258.90 "Игорь Лабутин" Как всегда, объяснить, что ты делаешь, я не могу объяснить, что ты делаешь.
7258.90 7262.38 "Игорь Лабутин" Так, в принципе, будет какая-то общая терминология, как раз, может быть, для объяснения.
7262.38 7264.14 "Игорь Лабутин" Может быть, для этого они будут полезны.
7264.14 7265.14 "Игорь Лабутин" Чисто как общий язык.
7265.14 7266.14 "Анатолий Кулаков" Ну, может быть.
7266.14 7269.14 "Анатолий Кулаков" Так, у нас еще что-нибудь осталось?
7269.14 7272.50 "Игорь Лабутин" Да нет, пойдем разбегаться.
7272.50 7274.18 "Игорь Лабутин" Нет, на самом деле есть еще одна маленькая тема.
7274.18 7279.66 "Игорь Лабутин" Это наши традиционные, кратко о разном, мы сегодня прям совсем о разном.
7279.66 7291.90 "Игорь Лабутин" Но у нас есть сильные краткие новости, вышло, Microsoft все-таки что-то делает, и вышло две статьи, на самом деле вышло больше, конечно, но я вот конкретно отобрал две статьи на их блоге.
7291.90 7295.50 "Игорь Лабутин" Обе относятся к Visual Studio, и одна из них это очередной эксперимент.
7295.50 7305.90 "Игорь Лабутин" Как вы помните, я уже несколько раз рассказывал про всякие эксперименты, которые они проводят в виде того, что Mads Christensen сначала пишет какой-нибудь экстенджин, а потом он затягивается в основную версию Visual Studio.
7305.90 7310.46 "Игорь Лабутин" И вот мы дождались наш очередного экстенджина, он называется Surround Selection Experiment.
7310.46 7312.86 "Игорь Лабутин" О чем речь?
7312.86 7331.78 "Игорь Лабутин" Речь идет о том, что очень часто вы хотите какое-нибудь выражение взять, например, в кавычки, или в скобки, или еще во что-нибудь такое парное, и делать это надо, ну как сначала кликнул, или как-то курсором перешел в начало выражения, потом, значит, опять же кликнул, или курсором перешел в конец выражения.
7331.78 7336.86 "Игорь Лабутин" Это все здорово и хорошо, но не очень удобно.
7336.86 7341.46 "Игорь Лабутин" Поэтому теперь в студии, если включить, поставить разрешение, делается следующее.
7341.46 7371.38 "Игорь Лабутин" Если вы захалайтили какой-то текст, и после этого нажали на клавиатуре один из символов, который является парным, то есть вы нажали кавычку, двойную, в смысле двойную кавычку, одинарную кавычку, апостроф он же, скобочку, открывающую круглую, квадратную, фигурную, угловую, ну в общем, все, что может оказаться на самом деле парным символом, то все это выражение просто берется как бы внутрь этих пары символов, то есть автоматически добавляется символ такой же справа, ну соответствующий для скобочек.
7371.38 7375.22 "Игорь Лабутин" Вот, можно поставить такой себе экстенд, попробовать посмотреть, вдруг будет полезно.
7375.22 7380.38 "Игорь Лабутин" Думаю, что это, скорее всего, найдет свою нишу и будет затащено в основную студию.
7380.38 7393.98 "Игорь Лабутин" А вот вторая статья, которая вышла, она пока еще, ее пока нельзя потрогать, зато ее можно почитать и пойти на дискашен с Microsoft.com, высказать свое веское мнение.
7393.98 7405.70 "Игорь Лабутин" Кажется, что это одна из тех, не знаю, статей-ишизов в этом самом дискашен, с которой прям породила хороший такой дискашен, потому что это про новый UI.
7405.70 7406.70 "Игорь Лабутин" Ну, как новый.
7406.70 7420.26 "Игорь Лабутин" Она называется Visual Studio UI Refresh, и начинается с статьи про то, что мы вообще говоря, вот с 2000 какого-то там дряхлого года не меняли уже давным-давно интерфейс студии, ну так, серьезно.
7420.26 7421.26 "Игорь Лабутин" Давно пора это сделать.
7421.26 7433.02 "Игорь Лабутин" И мы тут, мол, придумали, пока еще не реализовали, но вот, типа, вам картиночки посмотрите, у нас будет больше пространства, больше спейсинга, короче, проще попадать мышкой.
7433.02 7437.90 "Игорь Лабутин" Меню стало длиннее, табы стали выше, места помещается на экране меньше.
7437.90 7439.22 "Игорь Лабутин" Смотрите, как стало круто.
7439.22 7451.10 "Анатолий Кулаков" Да, и тут интересные картинки, что у вас на картинке две менюшки, одна, которая была, которая стала, и прямо на картинках видно, что менюшка, которая была, она помещается в определенные фреймы, которая стала, не помещается.
7451.10 7454.18 "Анатолий Кулаков" Список файлов раньше помещался, а сейчас он не помещается.
7454.18 7457.26 "Анатолий Кулаков" Это просто потому, что они добавили там кучу паддингов.
7457.26 7469.22 "Игорь Лабутин" Ну, то есть, местами оно выглядит действительно стало, ну может быть, не то чтобы удобнее, а привычнее, да, по сравнению со всеми обычными там веб-приложениями и прочим, чем мы пользуемся.
7469.22 7477.82 "Игорь Лабутин" Это, в принципе, в тренде текущего UI, но проблема в том, ну не проблема, а вообще особенность в том, что Visual Studio Tool Developer, где важно место на экране.
7477.82 7498.30 "Игорь Лабутин" И действительно, там вот в этих комментариях, там народ разделился на два лагеря, и где-то ближе к концу, ну на момент, когда я читал этот дискашен, там был такой правильный комментарий, который подводил такой промежуточный итог со словами, ну, кажется, что все поделились на два лагеря, одни тем, кому это нравится, но видимо, это те, кто работают за большими 4К мониторами с мелким разрешением.
7498.30 7506.70 "Игорь Лабутин" Для них понятно, ну как бы, и так места дофига, но зато станет удобнее иконки видеть, а то очень мелко для них было, если они зумом не пользовались.
7506.70 7514.30 "Игорь Лабутин" Ну, в смысле, зумом, 100% этим зумом видны программно, что в принципе, всегда было крупнее.
7514.30 7530.02 "Игорь Лабутин" Вот, а второй набор тех, кто работает за ноутбуком, и там понятно, что, ну, как бы, любое сжирание места это плохо, и поэтому вот эти все ваши увеличенные спейсинги и расширенные табы, ну, как бы, нафиг не сдалитесь, дайте место покодировать.
7530.02 7545.30 "Игорь Лабутин" Вот посмотрим, во что это выльется, прислушается Microsoft или не прислушается, сделает, не сделает, будем следить, как только выйдет, ну, я думаю, что это точно будет какой-нибудь, если сделан большой, значит, апдейт в статье про новую версию Visual Studio, так что будем смотреть и ждать.
7545.30 7556.18 "Анатолий Кулаков" Ну, и за последние годы, мне кажется, это статья, которая набрала больше всего комментариев, там 122 комментария, тут открываешь статейчика всего буквально на три абзаца, а потом идет огромный скролл с комментариями.
7556.18 7568.70 "Игорь Лабутин" Ну, и это вот только комментарии к статье, а еще можно сходить в саму ищу, которая идет на дискашенс, и там еще миллион комментариев, ну, не миллион, в смысле, там действительно по несколько комментариев в день, обычно это редкость.
7568.70 7575.66 "Анатолий Кулаков" Да, в общем, как здесь делать людям весело, возьмите и выпустите Redesign, их любимые инструменты.
7575.66 7578.62 "Игорь Лабутин" А потом откатите следующие версии обратно, и все будут
7578.62 7583.18 "Анатолий Кулаков" счастливы. Наверняка да, вот на что тратиться время, нет бы и какие-нибудь хорошие вещи делать.
7583.18 7626.22 "Анатолий Кулаков" Кстати, о хороших вещах, вот я тоже хотел вам отдать еще одну интересную ссылочку, мы часто в наших подкастах упоминаем Эндрю Лока, и в частности, в одном из прошлых выпусков мы обсуждали серию статьей за кулисами Minimal API, в общем, для тех, кому еще пока сложно читать на английском, появился замечательный перевод этой серии, в котором переведены как раз такие статейки, именно Эндрю Локовский, ну и плюс на этом сайте, сайт называется zzinob.ru, там есть еще переводы других интересных статей, в общем, если вам тяжело читать на английском, зайдите, посмотрите, ссылочка будет в шоу-ноутах.
7626.22 7673.18 "Игорь Лабутин" Ну, а на этом мы таки точно будем заканчивать, сегодня мы не дождались новостей от Microsoft, каких-то очень важных, кроме дизайна UI, и поэтому мы пообсуждали, что происходит с консолькой и вообще обработкой коммонлайна в дотнете, что нам ждать от RedSharper, предположительно, в 2023.2 версии, вспомнили, что такое Solid, и как он появился, и о чем это вообще, обсудили rate-limiting, какой он вообще бывает, о чем нужно думать, и что сейчас происходит в дотнете с ним, поговорили про dotnet reproducible builds, которые, может быть, вам не очень пригодятся, но узнать интересно, что такое существует, узнали про новый набор аббревиатур, не знаю, кто это.
7673.18 7674.18 "Игорь Лабутин" Принципов.
7674.18 7680.54 "Игорь Лабутин" Принципов, ладно, хорошо, важные принципы проектирования и разработки софта под названием kpid.
7680.54 7684.42 "Анатолий Кулаков" Которые тоже вам, наверное, не пригодятся, но интересно знать, что они существуют.
7684.42 7691.30 "Игорь Лабутин" Ну и проговорили по какие-то совсем мелкие новости, тоже, может быть, интересно заглянуть, почитать, попробовать.
7691.30 7692.30 "Игорь Лабутин" Вот так вот.
7692.30 7703.78 "Анатолий Кулаков" Отлично, на этом все, давай разбегаться, большое спасибо, друзья, что нас слушали, заходите, комментируйте наши выпуски на YouTube, ставьте там лайки, шарьте нас везде, и любите всячески.
7703.78 7704.78 "Анатолий Кулаков" Нам это нравится.
7704.78 7705.78 "Анатолий Кулаков" Всем пока.
7705.78 7706.78 "Игорь Лабутин" Всем пока.
7706.78 7716.78 None Пока.
