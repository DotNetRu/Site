0.00 8.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья.
8.36 12.08 "Анатолий Кулаков" В эфире Radio.net выпуск номер 66.
12.08 14.84 "Анатолий Кулаков" Ну что ж, пора оттаивать.
14.84 20.80 "Анатолий Кулаков" Вроде январь кончился, праздники прошли, статейки уже должны посыпаться, релизы и все такое.
20.80 23.00 "Анатолий Кулаков" Поэтому начинаем наш эфир.
23.00 31.08 "Анатолий Кулаков" Я напомню, что здесь мы обсуждаем различные статьи, новости, а также интересные какие-то нововведения из мира .NET.
31.08 42.44 "Анатолий Кулаков" Но прежде всего хотелось бы поблагодарить за помощь наших постоянных помогаторов, которые не забывают про кнопочку на бусти и радостно подписываются на помощь любимому подкасту.
42.44 48.52 "Анатолий Кулаков" Прежде всего это Александр, Сергей и Владислав, Алексей, Шевченко, Антон, Илья, Гурий, Самарин и Виктор.
48.52 62.32 "Анатолий Кулаков" Спасибо большое, друзья, а также всем, кто поддерживает нас не только на бусти, но и комментариями, шарами, со своими друзьями и всячески помогает нам распространить и увеличить популярность нашего подкаста.
62.32 67.28 "Анатолий Кулаков" Мы это очень ценим, спасибо большое всем, друзья, мы рады, что вы у нас есть.
67.28 72.88 "Анатолий Кулаков" Ну что, Microsoft, выкатил нам наконец новый .NET, новый C#, что-нибудь новенькое?
72.88 84.16 "Игорь Лабутин" Ничего пока не выкатил, но по крайней мере все обещают, обещают, но пока все нету, но выкатил интересную статью, которая прям очень громко называлась, я прям побежал ее сразу читать, как только нашел.
84.16 91.44 "Игорь Лабутин" Она называется "Обновление стратегии поддержки языков на платформе .NET", ну это я так вольно перевел.
91.44 96.12 "Анатолий Кулаков" Ну звучит солидно, прям и стратегия, и… И обновление, то есть казалось бы…
96.12 100.72 "Игорь Лабутин" И обновление, и языков, как будто там целая пачка. Что-то поменялось и что-то очень важное случилось.
100.72 114.08 "Игорь Лабутин" На самом деле по факту случилось не очень важное и не очень поменялось, но тем не менее интересно, давайте немножко расскажу, чтобы вы понимали, что же у нас с поддержкой языков на платформе .NET с точки зрения Microsoft.
114.08 127.80 "Игорь Лабутин" Вообще, стратегию как таковую Microsoft запостила первый раз в 2017 году, то есть это уже получается 5-6 лет назад, и это была просто статья в блоге.
127.80 141.68 "Игорь Лабутин" Обычный вот этот он DevBlogs, или как он тогда назывался, возможно это был уже еще MSDN или еще кто-то, я уже не помню, но тем не менее это была статья, где описывалось, что вот у нас на платформе .NET есть 3 плюс-минус основных языка, это C#, F# и Visual Basic.
141.68 150.12 "Игорь Лабутин" И вот наши мнения на тему того, как мы с ними будем работать и как мы будем поддерживать эти 3 языка дальше.
150.12 167.64 "Игорь Лабутин" Ну, была и была эта статья, и в этом году сейчас Microsoft к этому моменту поняли, что вообще говоря на ту статью они, во-первых, довольно часто ссылаются, ну видимо в каких-то переписках, когда им вопрос задают, в ответах, в саппортах и так далее.
167.64 187.04 "Игорь Лабутин" А с другой стороны, ну статус статьи в блоге от 2017 года не очень позволяет понять, это все еще официальная стратегия и позиция, или все-таки это было в 2017 году, а сейчас стратегия другая, потому что никакой такой официальной стратегии в, так скажем, основном сайте документации, да, Learn Microsoft, ничего не было.
187.04 203.36 "Игорь Лабутин" И вот пробелы решили восполнить, и поэтому обновили стратегию путем, во-первых, размещения ее теперь на Learn Microsoft, а во-вторых, еще раз повторили, так сказать, что в ней такого и с чем она состоит.
203.36 211.56 "Игорь Лабутин" Фактически именно с точки зрения поменялось, не поменялось, в общем-то ничего, как я понимаю, по сравнению с прошлым разом, но давайте пробежимся.
211.56 219.08 "Игорь Лабутин" Во-первых, у нас есть C#, который по мнению Microsoft является наиболее популярным дотнет языком, ну что, наверное, близко к правде.
219.08 235.04 "Игорь Лабутин" Это объектно ориентированный язык, там есть кусочки в каких-то функциональных программированиях, есть кусочки всяких низкого уровня фич, позволяют писать high-performance код, вот это все, все, что вы знаете про C#, оно там есть, и это все будет продолжать развиваться.
235.04 238.72 "Игорь Лабутин" То есть они так, у них это называется will keep evolving.
238.72 242.48 "Игорь Лабутин" Когда я это увидел, ну да, как бы, что, будет развиваться язык.
242.48 255.00 "Игорь Лабутин" Следующее предложение звучало как innovate eagerly and broadly, то есть они там будут аж все эти инновации во все углы запихивать, и это будет все очень инновационно по всем фронтам и так далее.
255.00 278.68 "Игорь Лабутин" Это звучало уже немножко более стрёмно, в плане, что язык будет добавляться в фичи в разные места, с разными векторами, так скажем, направлениями из разных мест, но потом последовало уточнение, что но мы все-таки будем оставаться, так сказать, в духе языка, то есть он все еще будет объектно ориентированным в основном, и все, что мы знаем, так сказать, про C# и то, что мы в нем любим, более-менее будет оставаться.
278.68 300.68 "Игорь Лабутин" Понятно, что там будет добавляться новый сахар, будут добавляться новые возможности, будут добавляться новые языковые конструкции, но при добавлении всех этих штук, Microsoft будет руководствоваться все-таки позицией, что нужно удовлетворить, ну не то, чтобы удовлетворить, нужно принести пользу как можно большему количеству девелоперов, либо вообще всем, если особо хорошо угадать с фичей.
300.68 315.72 "Игорь Лабутин" То есть не то, что там будут добавляться какие-то прямо узкоспециализированные фичи в язык, а все-таки возможности будут пытаться оставить его таким широко применимым языком.
315.72 323.40 "Игорь Лабутин" И важный момент, от которого Microsoft не отказывается и который был девизом C# все это время, это обратная совместимость.
323.40 330.00 "Игорь Лабутин" Обратная совместимость будет, она никуда не девается, и над ней будут хорошо работать и поддерживать ее.
330.00 350.24 "Игорь Лабутин" Так что фактически все, что вы знаете про C#, ничего не меняется, единственный момент, что да, там инновации будут, инноваций будет видимо много, но с какой скоростью они будут прибегать, мы пока не знаем, потому что команда компилятора и дизайнеров языка не такая большая, и команде компилятора нужно успевать все это имплементировать, поэтому слишком быстро, наверное, прилетать не будет.
350.24 353.24 "Игорь Лабутин" Второй язык это F#.
353.24 415.88 "Игорь Лабутин" F# по мнению Microsoft, это такой очень, они это назвали expressive performance language, с одной стороны очень такой выразительный, с другой очень быстрый, который основан на выражениях, функциях и на неизменяемости, иммьютабилити, то есть в основе своей все-таки лежат эти штуки, функциональные подходы, они очень сильно опираются на комьюнити в деле F#, то есть не так много внутренних ребят, которые работают над F#, в основном много чего приносится комьюнити, в том числе реализация многих фич, я так понимаю, идет со стороны комьюнити, они коммитятся на то, что они будут очень стараться поддерживать интероперабилити с C# на достойном уровне, и важная цель для F# в ближайшее или не очень ближайшее время это понизить порог входа, то есть сейчас он довольно высок по их мнению, и нужно понижать, упрощать и делать так, чтобы F# было проще начинать пользоваться.
415.88 425.04 "Игорь Лабутин" Мы сегодня чуть дальше посмотрим на некоторую статистику adoption, кто как пользуется, чем, увидим, что может быть действительно F#, можно было бы и попроще пользоваться.
425.04 448.40 "Игорь Лабутин" Ну и третий язык это Visual Basic, с ним все просто, это давний язык, который был задизайнен, ну понятно, что на основе Basic, и его цель была в основном, ну скажем так, понятность, то есть они это называют clarity over brevity, то есть пусть это будет более многословно, пусть это будет более явно, но зато все будет всем понятно.
448.40 482.72 "Игорь Лабутин" С Visual Basic'ом штука такая, что основные библиотеки, то есть BCL и прочее такое ядро будет поддерживать Visual Basic, некоторые .NET ворклоды поддерживать его не будут, никаких новых синтексов туда добавляться не будет, и как бы расширять его особо не планируют, то есть базовая библиотека будет дизайнится с оглядкой на Visual Basic, то есть туда не будут добавляться фичи, которые могут сломать Visual Basic, но сам Visual Basic развиваться не будет, хотя кода на нем еще много, так что видимо ему еще какое-то время жить.
482.72 497.52 "Игорь Лабутин" Вот такой вот апдейт по стратегии, не то чтобы мы сильно узнали что-то новое, но по крайней мере это официальная позиция Microsoft сейчас, которую было интересно еще раз озвучить и запомнить, я бы сказал, посмотрим, что изменится года через 3-4 может быть.
497.52 504.36 "Анатолий Кулаков" А ничего не слышал про то, может она там какой-нибудь четвертый язык планирует, ну не зря же она там подсуетилась, стратегию сделала.
504.36 505.36 "Игорь Лабутин" Нет.
505.36 513.16 "Анатолий Кулаков" Не, ну на самом деле там у него экспериментальных в лаборатории языков много, там тот же F# со звездочкой, прям очень перспективная штука.
513.16 522.04 "Анатолий Кулаков" И много других, которые там помогают какие-то анализаторы строить, и те же самые на кубитах языки хорошенькие у них есть, то есть для квантовых компьютеров.
522.04 525.40 "Анатолий Кулаков" Ну пока это все кажется далеко от мейнстрима и какой-то поддержки.
525.40 531.96 "Анатолий Кулаков" Ну хорошо, что стратегия появилась, я думаю полезная штука, почему нет.
531.96 538.36 "Анатолий Кулаков" А давай теперь посмотрим на стратегию того, какие коллекции и какие типы мы должны использовать в наших программах.
538.36 542.04 "Игорь Лабутин" Это более приземлённая тема, давай, да, конечно.
542.04 550.28 "Анатолий Кулаков" Я имею в виду, что ты много лет уже пишешь программы и до сих пор без понимания стратегии, какие же типы надо писать в своей программе, ты вообще стартал от этого?
550.28 553.88 "Игорь Лабутин" Нет, всегда использую стринг, будь тебе счастье.
553.88 561.00 "Анатолий Кулаков" Ну ты же не на пайтоне пишешь или не на PHP, чтобы всегда стринги-то использовать, ну что это такое?
561.00 570.12 "Игорь Лабутин" Не, ну да, конечно, ну я на самом деле, как сказать, я делал даже доклад же на эту тему, когда давно на митапе.
570.12 577.80 "Анатолий Кулаков" Погоди, погоди, давай сначала скажем тему, тема прежде всего называется, то есть какую коллекцию, какой интерфейс от коллекции мы должны использовать в наших программах.
577.80 579.40 "Игорь Лабутин" Ну или просто какие коллекции, да.
579.40 628.96 "Игорь Лабутин" Я про это дело делал доклад, когда давно на SPB.net можно найти видосики где-то в записях в архивах ютуба, ну в смысле на канале dotnet.ru, и я тогда как раз говорил, что смотрите, IEnumerable, это конечно здорово, все решарперы и прочие советуют, типа смотри, ты делаешь одну итерацию for each по параметру, давай там возьмем IEnumerable, это же круче, потому что там можно передать все что угодно, а я говорил нет, потому что в нашем случае это было важно с точки зрения перформанса, то есть я, поскольку человек, который всегда думает о перформансе, и может быть иногда там где-то не нужно, то я конечно стараюсь писать как бы там какие-нибудь листы использовать, иногда получается поиспользовать какие-нибудь там Iredown или Elise, но блин, он очень длинный, лист короче, можно и Elise написать в своем коде.
628.96 633.84 "Игорь Лабутин" Но я мало пишу в библиотеках, это правда, для библиотек наверное какие-нибудь другие требования.
633.84 637.44 "Игорь Лабутин" Ну давай, расскажи что в статье, а мы по пути что-нибудь обсудим.
637.44 662.48 "Анатолий Кулаков" Я думаю да, у тебя уже там будут точки, где ты сможешь ставить свои замечания про перформансы, на самом деле тема кажется, что на первый взгляд довольно банальная, все мы пишем программы и все мы знаем какие типы где использовать, но базируясь на этой банальности, мы постепенно выходим уже на какой-то более высокий уровень, когда те типы, которые нам кажется можно сюда засунуть, они здесь будут как бы вполне в тему, уже становится не так.
662.48 669.28 "Анатолий Кулаков" То есть я общался с многими сеньорами, там и на собеседованиях часто спрашиваю, какие типы в том или ином случае нужно использовать.
669.28 678.48 "Анатолий Кулаков" И в голове у людей всегда возникают очень разные ответы, это значит, что в индустрии творится бардак, и этот бардак нужно упорядочивать.
678.48 687.64 "Анатолий Кулаков" И вот как раз следующая статейка, а точнее прям целых две статейки, помогут нам упорядочить такие банальные простые вещи, какие типы когда нужно использовать.
687.64 701.92 "Анатолий Кулаков" И поможет нам никто иной, как Владимир Хориков, очень замечательный человек в том плане, когда вам нужно в голове что-то упорядочить, особенно если это касается какой-нибудь архитектуры языка, типов и все что с этим связано.
701.92 705.76 "Анатолий Кулаков" Ну что ж, давайте начнем как обычно с банального.
705.76 711.40 "Анатолий Кулаков" То есть допустим вы пишете функцию, и у вас возникает вопрос.
711.40 714.32 "Анатолий Кулаков" Эта функция обычно принимает какие-то аргументы и возвращает какие-то типы.
714.32 722.20 "Анатолий Кулаков" И вот у вас есть обычная иерархия наследования, так как мы в объектно-ориентированном языке работаем, у нас есть обычная иерархия наследования.
722.20 729.20 "Анатолий Кулаков" И вы обычно задаетесь вопросом, а какие типы вам нужно принимать в аргументы, и какой тип вам нужно вернуть.
729.20 732.28 "Анатолий Кулаков" Особенно если в этой иерархии тип не один, а их там много.
732.28 746.24 "Анатолий Кулаков" И вот общий совет для таких случаев, то что принимать нужно самый общий тип в качестве аргументов, а возвращать нужно как можно более специфический тип, то есть как можно более узкий тип.
746.24 748.84 "Анатолий Кулаков" И вот давайте же разберемся, почему это так происходит.
748.84 753.88 "Анатолий Кулаков" В C# такая штука называется ковариантность и контравариантность.
753.88 760.16 "Анатолий Кулаков" Когда, соответственно, мы можем подменять один тип его наследником в том или ином случае.
760.16 762.16 "Анатолий Кулаков" Допустим, у нас есть стандартная иерархия.
762.16 766.16 "Игорь Лабутин" Давай я тут немножко откорректирую, ну не точно откорректирую, а поясню.
766.16 773.56 "Игорь Лабутин" Ковариантность и контравариантность – это как раз это свойство типов быть возможным, подмененным, когда мы говорим про коллекции.
773.56 787.44 "Игорь Лабутин" То есть просто то, что ты можешь подменить наследника на базовый тип или наоборот, подставить наследника вместо какого-то места, где ожидается базовый тип – это как бы здорово.
787.44 797.32 "Игорь Лабутин" Но важно это дело именно про коллекции, то есть когда ты можешь коллекцию объектов наследников передать в функцию, которая принимает коллекцию объектов родителей.
797.32 803.64 "Анатолий Кулаков" Мне казалось, что как раз ковариантность – это просто вот поворот возможность замены иерархических типов.
803.64 808.96 "Анатолий Кулаков" Коллекция – это ее частный случай в дотнете, который просто имеет ключевые слова и ключевую спецификацию.
808.96 811.24 "Анатолий Кулаков" Но вообще это в теории типов относится к любым типам.
811.24 812.24 "Анатолий Кулаков" Ну, возможно.
812.24 819.80 "Игорь Лабутин" Я на это смотрю обычно с точки зрения практического дотнета, и там обычно ковариантность и контравариантность вылезает именно в момент коллекции.
819.80 821.48 "Игорь Лабутин" Да, да, именно так.
821.48 825.56 "Анатолий Кулаков" Хорошо, давай на этом остановимся, потому что нас это определение вполне устраивает.
825.56 832.52 "Анатолий Кулаков" Разберем типичную иерархию наследования, когда у нас есть некая живность, и от нее наследуется кошечка и собачка.
832.52 836.16 "Анатолий Кулаков" Пэт, это же живность, да, подойдет?
836.16 837.16 "Игорь Лабутин" Нормально?
837.16 838.16 "Игорь Лабутин" Ну, домашнее животное, но живность.
838.16 843.04 "Анатолий Кулаков" Домашнее животное тоже живность, так что сойдет.
843.04 850.72 "Анатолий Кулаков" И соответственно нам нужно выбрать, что же в этом случае мы должны передавать, допустим, в качестве аргумента к коллекции.
850.72 852.88 "Анатолий Кулаков" Не коллекции, а метод.
852.88 855.00 "Анатолий Кулаков" Ответ в принципе довольно очевиден.
855.00 861.64 "Анатолий Кулаков" Если ваш метод умеет работать с абстрактным базовым домашним животным, то вы должны передавать ему тип PET.
861.64 876.52 "Анатолий Кулаков" Если же ваш метод умеет работать только с собачками, например, заставлять гавкать это домашнее животное, то скорее всего ваш метод должен принимать собачек, потому что кошечек заставить гавкать довольно сложно, практически в нашей реальности невозможно.
876.52 880.20 "Анатолий Кулаков" Со входными аргументами кажется, что здесь все довольно понятно.
880.20 885.40 "Анатолий Кулаков" Вы должны использовать максимально возможно широкий тип, который ваш метод может принять.
885.40 899.08 "Анатолий Кулаков" Если ваш метод не может работать с домашними животными, может работать только с собачками, то никакого смысла домашних животных принимать в аргументах у него и нет.
899.08 900.28 "Анатолий Кулаков" Довольно все просто.
900.28 903.00 "Анатолий Кулаков" Теперь давайте подумаем насчет возвращаемых значений.
903.00 907.28 "Анатолий Кулаков" В возвращаемых значениях все немножко наоборот.
907.28 919.20 "Анатолий Кулаков" Допустим, если ваш метод ищет какого-нибудь домашнее животное, которое ищет просто домашнее животное, тогда вы, естественно, должны вернуть ему PET.
919.20 930.88 "Анатолий Кулаков" Если же ваш метод ищет домашнее животное, которое умеет гавкать, то вы, конечно, можете вернуть ему и PET, потому что PET включает в себя… Он более широкий, он не позволяет себе в том числе гавкать животных.
930.88 941.76 "Анатолий Кулаков" Но скорее всего тот кот, который потребляет вашу функциональность, он ждет, что вы вернете ему непосредственно конкретный тип, то есть как можно более узкий тип самого последнего наследника, который умеет как раз таки гавкать.
941.76 942.76 "Анатолий Кулаков" То есть в нашем случае это ДОГ.
942.76 951.32 "Анатолий Кулаков" И вот здесь как раз подтверждается это правило, что когда мы принимаем, мы хотим принять наиболее общее животное, с которым мы можем работать.
951.32 957.00 "Анатолий Кулаков" А когда возвращаем, мы должны вернуть именно конкретное животное, которое мы нашли в результате нашей работы.
957.00 965.92 "Анатолий Кулаков" Это обосновывается еще тем, что если посмотреть с точки зрения потребителя нашего метода, то потребитель всегда хочет получить максимальную функциональность.
965.92 975.64 "Анатолий Кулаков" И вот когда он передает значение ваш метод, для него максимальная функциональность означает то, что ваш метод может принять как можно больше различных типов.
975.64 981.00 "Анатолий Кулаков" То есть вот здесь как раз таки встает, что аргументы должны быть как можно более общими.
981.00 990.28 "Анатолий Кулаков" А когда потребляющий кот забирает из вашей функции какое-то значение, то для него расширенная функциональность это как раз таки конкретный тип.
990.28 996.56 "Анатолий Кулаков" Потому что у типа собачки будет намного больше методов, намного больше свойств, чем у типа pet.
996.56 1006.36 "Анатолий Кулаков" Поэтому ему, потребляющему коду, соответственно нужно как можно более конкретный тип, чтобы иметь возможность наступиться к более общей функциональности у этого типа.
1006.36 1011.80 "Анатолий Кулаков" Таким образом, с точки зрения потребителя мы можем тоже обосновать, почему это правило верно.
1011.80 1020.40 "Анатолий Кулаков" Если мы вспомним принципы по сравнению публичных API, то там есть такое интересное правило.
1020.40 1028.56 "Анатолий Кулаков" Будьте как можно более терпимыми к входным данным, и будьте как можно более строгими к выходным данным.
1028.56 1039.44 "Анатолий Кулаков" То есть вы должны потреблять как можно те данные, которые к вам пришли, и быть к ним более или менее терпимыми, и обрабатывать хотя бы то, что вам дали.
1039.44 1045.08 "Анатолий Кулаков" Но к своим данным, которые вы возвращаете из вашего публичного API, вы должны придерживаться максимальной строгости.
1045.08 1046.40 "Анатолий Кулаков" Прямо насколько можно.
1046.40 1054.68 "Анатолий Кулаков" И вот это же правило, оно по сути и говорит нам, то есть оно подтверждает наши выводы, которые мы сделали выше для объектно-ориентированных принципов вызова.
1054.68 1062.92 "Анатолий Кулаков" Что значит будьте как можно более терпимыми к входу, который подается в ваш API, в нашем случае в нашу функцию.
1062.92 1067.84 "Анатолий Кулаков" Это значит, что мы должны принимать как можно более широкий спектр различных значений.
1067.84 1073.96 "Анатолий Кулаков" То есть мы должны принимать как можно более общий тип из всех возможных, если мы оперируем в терминах типов.
1073.96 1080.92 "Анатолий Кулаков" Что значит, что мы должны максимально строго относиться к выходному результату работы нашего метода.
1080.92 1090.04 "Анатолий Кулаков" Это как раз значит, что выходной результат должен быть каким-то строгим набором всех возможных значений, которые может сгенерировать наша функция.
1090.04 1096.48 "Анатолий Кулаков" То есть как можно более специфичными значениями должны оперировать наши функции на выходе.
1096.48 1103.68 "Анатолий Кулаков" То есть мы как раз-таки находим подтверждение в принципах построения публичного API тоже наш метод подтверждается.
1103.68 1108.80 "Анатолий Кулаков" Теперь давайте немножко поговорим о что же такое возможные значения.
1108.80 1117.84 "Анатолий Кулаков" Ну допустим, если наш метод хочет принимать самый общий аргумент, самый общий возможный тип.
1117.84 1120.36 "Анатолий Кулаков" Вот пытались мы покормить животного.
1120.36 1127.20 "Анатолий Кулаков" Какое животное, даже не так, что мы можем принять в качестве типа, для того чтобы его покормить.
1127.20 1133.92 "Анатолий Кулаков" Наверное, если мы будем следовать закону самый общий тип, который мы можем принять, это будет object.
1133.92 1135.92 "Анатолий Кулаков" Мы же действительно object - это самый общий тип.
1135.92 1138.60 "Анатолий Кулаков" И мы по сути можем всегда принимать только его.
1138.60 1146.92 "Анатолий Кулаков" Но тогда мы сталкиваемся с той дилеммой, что мы не понимаем, а как в методе покормить, кормить object.
1146.92 1148.92 "Анатолий Кулаков" Потому что по сути object кушать у нас не умеет.
1148.92 1151.40 "Анатолий Кулаков" У нас умеет кушать только домашнее животное.
1151.40 1157.76 "Анатолий Кулаков" Эта проблема легко решается, если мы попробуем object кастить к pet, то есть к домашнему животному.
1157.76 1170.56 "Анатолий Кулаков" Но если мы так сделаем, у нас появляется очень плохой запах, то есть появляется bad pattern, который называется leaky abstractions, то есть текущая абстракция.
1170.56 1172.08 "Анатолий Кулаков" Почему же это происходит?
1172.08 1176.52 "Анатолий Кулаков" Прежде всего потому, что что такое абстракция?
1176.52 1177.52 "Анатолий Кулаков" Давайте разберемся с этим.
1177.52 1190.04 "Анатолий Кулаков" Абстракция - это как раз та свойства модели, которая помогает нам усилить важные свойства этой модели, то есть что код по-настоящему делает.
1190.04 1195.76 "Анатолий Кулаков" И позволяет скрыть неважные свойства этой модели, то есть детали ее имплементации.
1195.76 1200.72 "Анатолий Кулаков" То есть нормальная хорошая абстракция подчеркивает важные свойства и скрывает неважные.
1200.72 1204.72 "Анатолий Кулаков" В нашем случае важные свойства - это наша сигнатура и строгость типов.
1204.72 1207.88 "Анатолий Кулаков" И неважные свойства - это имплементация, это детали реализации.
1207.88 1214.96 "Анатолий Кулаков" И вот текущая абстракция специфична потому, что она нарушает вот эти принципы абстракции.
1214.96 1227.44 "Анатолий Кулаков" То есть она внутри себя заставляет код, который ее вызывает знать о деталях реализации, что в принципе в объектно-ориентированном языке совсем не поощряется.
1227.44 1241.40 "Анатолий Кулаков" То есть если мы внутри метода покормить будем начинать кастить объект какому-то животному, к собачке, к кошечке или может быть к базовому пету, это уже детали имплементации.
1241.40 1251.76 "Анатолий Кулаков" И тот код, который нас вызывает с объектом, он должен понимать, что если мы передали туда правильный объект, правильный инстанс, то наша функция более-менее отработает.
1251.76 1260.42 "Анатолий Кулаков" А если мы туда передали какой-нибудь string или int, который физически невозможно кормить, то функция может сделать все что угодно, в том числе бросить какое-нибудь исключение.
1260.42 1269.04 "Анатолий Кулаков" И если вызывающий код вынужден знать о деталях реализации, то значит эта функция реализована плохо.
1269.04 1272.76 "Анатолий Кулаков" Значит она пахнет протекающей абстракцией.
1272.76 1288.76 "Анатолий Кулаков" То есть в нашем случае, когда мы говорим, что метод должен принимать самый общий из возможных аргументов, это значит, что возможный аргумент это тот аргумент, который позволяет все-таки сигнатуре остаться честной.
1288.76 1291.16 "Анатолий Кулаков" Сигнатура не будет обманывать вызывающий метод.
1291.16 1295.04 "Анатолий Кулаков" Если она говорит, что она принимает object, значит она должна уметь работать с object.
1295.04 1299.08 "Анатолий Кулаков" Если она говорит, что она умеет принимать домашних животных, значит только с домашними животными.
1299.08 1306.16 "Анатолий Кулаков" То есть реализован без того, чтобы абстракция протекла.
1306.16 1316.92 "Анатолий Кулаков" Вот такие базовые свойства, казалось бы, для обычных функций, которые мы каждый раз с вами пишем, и я думаю все из вас их более-менее интуитивно понимают и в своем коде следует.
1316.92 1325.64 "Анатолий Кулаков" Вот эти базовые основы помогают нам подойти к более сложной теме, которая как раз-таки относится к коллекциям.
1325.64 1334.04 "Анатолий Кулаков" То есть что же мы должны возвращать у коллекций и что мы должны принимать в качестве аргументов, если нам необходим какой-то набор значений.
1334.04 1337.72 "Анатолий Кулаков" И вот тут уже начинаются разброты шатания у многих людей в голове.
1337.72 1340.72 "Анатолий Кулаков" Давайте начнем разбираться с этой частью.
1340.72 1348.24 "Анатолий Кулаков" Итак, если мы относимся к коллекциям, то здесь действуют те же самые правила.
1348.24 1354.36 "Анатолий Кулаков" То есть мы должны возвращать как можно более специфичный тип и принимать как можно более обобщенный тип.
1354.36 1359.00 "Анатолий Кулаков" Но что значит в нашем случае более специфичный тип?
1359.00 1365.24 "Анатолий Кулаков" Потому что у нас коллекции, наборы, они представлены в виде множества всяких интерфейсов и классиков.
1365.24 1371.24 "Анатолий Кулаков" Основные из них это iQueryable, ilist, massive или ireadonlylist.
1371.24 1376.92 "Анатолий Кулаков" Есть куча других, там iset, icollection, но смысл у них в принципе тот же самый.
1376.92 1387.84 "Анатолий Кулаков" Давайте на примере вот этих четырех, которые концептуально отличаются друг от друга, мы как раз-таки рассмотрим, каким же образом работать с аргументами и возвращениями типами коллекций.
1387.84 1391.04 "Анатолий Кулаков" Прежде всего давайте начнем с iQueryable.
1391.04 1400.36 "Анатолий Кулаков" Интересный такой интерфейс, который прежде всего используется там, где нам нужна абстракция над различными источниками данных.
1400.36 1416.72 "Анатолий Кулаков" Когда мы хотим работать, например, с базой данных и с in-memory коллекцией и с каким-нибудь OData REST API в одном и том же интерфейсе, с одним и тем же подходом, не зная какой источник данных лежит под капотом.
1416.72 1428.92 "Анатолий Кулаков" И мы хотим абстрактно дергать уже привычные для нас методы select, where, map и прочей фильтрации агрегаций, не задумываясь о том, какие данные у нас под капотом и где они лежат.
1428.92 1438.52 "Анатолий Кулаков" В принципе очень удобная штука во многих местах, но подходит ли она нам как какой-нибудь базовый тип для наших функций.
1438.52 1439.52 "Анатолий Кулаков" Давайте разбираться.
1439.52 1443.28 "Анатолий Кулаков" Прежде всего iQueryable очень популярен во всяких репозиториях.
1443.28 1452.56 "Анатолий Кулаков" Когда вы делаете репозиторий, очень часто можно встретить какой-нибудь метод у юзеров, который, например, называется user_repository, который называется get_all.
1452.56 1456.64 "Анатолий Кулаков" И этот get_all часто возвращает iQueryable от юзеров.
1456.64 1464.48 "Анатолий Кулаков" Дело в том, что iQueryable имеет очень большой минус.
1464.48 1469.04 "Анатолий Кулаков" А минус заключается в том, что он тоже является текучей абстракцией.
1469.04 1476.76 "Анатолий Кулаков" Дело в том, что используя iQueryable, вы должны точно знать, какой источник данных под ним находится.
1476.76 1488.28 "Анатолий Кулаков" Это нужно потому, что сама сигнатура, сама мощь всего iQueryable опирается на экспрессионах.
1488.28 1493.24 "Анатолий Кулаков" Экспрессионы конвертируются в какой-то уже конкретный вызов конкретного провайдера.
1493.24 1499.68 "Анатолий Кулаков" Например, в SQL или в REST API, или в какой-нибудь gRPC, или в Protobuf.
1499.68 1500.68 "Анатолий Кулаков" Не суть важно.
1500.68 1505.96 "Анатолий Кулаков" Главное, что эти экспрессионы должны скомпилироваться, например, в SQL.
1505.96 1514.00 "Анатолий Кулаков" И для того, чтобы они скомпилировались в SQL, для этого экспрессионным методом нужно поддерживать абсолютно все подмножество SQL.
1514.00 1516.56 "Анатолий Кулаков" Что, в принципе, никогда невозможно.
1516.56 1525.40 "Анатолий Кулаков" Потому что многие базы данных поддерживают абсолютно разные какие-нибудь наборы различных свойств, различных методов.
1525.40 1531.84 "Анатолий Кулаков" И полный набор абсолютно всего, что только возможно задать в экспрессионах, не поддерживает никто.
1531.84 1543.56 "Анатолий Кулаков" Поэтому, когда вы вызываете какой-нибудь фильтр или какой-нибудь селект на iQueryable интерфейсе, вы должны точно понимать, какой провайдер там лежит у вас под капотом.
1543.56 1547.68 "Анатолий Кулаков" Что там у вас, Postgres, или InMemory какой-то, или еще что-то.
1547.68 1556.36 "Анатолий Кулаков" И именно поэтому iQueryable — это не просто интерфейс, который скрывает источник данных, а как раз-таки наоборот.
1556.36 1565.96 "Анатолий Кулаков" Это интерфейс, который этот источник данных, конечно, может быть и скрывает, но вы обязаны знать про то, какой на самом деле у вас там лежит под капотом источник данных.
1565.96 1568.72 "Анатолий Кулаков" Иначе вы можете наткнуться на какие-нибудь ошибки.
1568.72 1570.76 "Анатолий Кулаков" Ошибки могут быть разного рода.
1570.76 1573.84 "Анатолий Кулаков" Например, у Entity Framework эта штука настраивается.
1573.84 1579.24 "Анатолий Кулаков" Если он не поддерживает, например, определенный expression, он может бросить исключение.
1579.24 1592.20 "Анатолий Кулаков" Или же в зависимости от настройки он может затянуть к вам в память абсолютно всю таблицу из базы данных и в памяти уже, допустим, отфильтровать или отмапить то, что он не поддерживает в виде SQL.
1592.20 1599.96 "Анатолий Кулаков" И та и та ситуация не очень хорошая, но тут главное как бы быть готовым к чему-то одному и защищаться от этого и иметь это в виду.
1599.96 1601.16 "Анатолий Кулаков" И тогда все нормально.
1601.16 1607.28 "Анатолий Кулаков" Но речь не про это, речь про то, что вам в любом случае необходимо знать, что у вас лежит под queryable.
1607.28 1613.76 "Анатолий Кулаков" Поэтому данный интерфейс как универсальный определитель любой коллекции для ваших функций абсолютно не подходит.
1613.76 1622.72 "Анатолий Кулаков" Да, его можно использовать в репозиториях, особенно в приватных методах и в internal методах репозиториев.
1622.72 1625.88 "Анатолий Кулаков" Там где репозиторий знает про ORM.
1625.88 1629.08 "Анатолий Кулаков" Репозитории обычно знают, куда они ходят и что они используют.
1629.08 1631.64 "Анатолий Кулаков" Они обычно знают, какая под ним лежит ORM.
1631.64 1636.76 "Анатолий Кулаков" Потому что как ни крути, они используют и методы оптимизации, и построение индексов, и все в этом духе.
1636.76 1643.32 "Анатолий Кулаков" Поэтому репозитории знают, какой провайдер данных сейчас используется.
1643.32 1647.96 "Анатолий Кулаков" Поэтому они могут использовать iQueryable в своих внутренних каких-то нуждах.
1647.96 1654.24 "Анатолий Кулаков" Но нельзя выставлять iQueryable наружу из репозитория.
1654.24 1660.32 "Анатолий Кулаков" Потому что как только вы вставляете наружу, как только превращаете его в публичный API, у вас появляется текущая абстракция.
1660.32 1664.56 "Анатолий Кулаков" То есть iQueryable не должен пересекать границы репозитория.
1664.56 1666.68 "Анатолий Кулаков" И тогда все в принципе будет хорошо.
1666.68 1674.08 "Игорь Лабутин" Ну тут надо сказать, что есть альтернативное мнение, что если вы используете entity framework, то вам не нужны репозитории вообще.
1674.08 1679.80 "Игорь Лабутин" И вы должны работать с entity framework как с репозиториями, тогда iQueryable у вас будет торчать изо всех мест.
1679.80 1681.52 "Игорь Лабутин" Там где вы будете его использовать.
1681.52 1686.60 "Игорь Лабутин" Ну такое тоже возможно, и такое вполне тоже работает.
1686.60 1691.72 "Игорь Лабутин" Но у меня не было опыта работать с таким подходом в больших проектах.
1691.72 1695.92 "Игорь Лабутин" В больших проектах у меня был репозиторий поверх entity framework, исторически сложившийся.
1695.92 1705.52 "Игорь Лабутин" Поэтому не могу ничего сказать по опыту работы прям с огромным количеством проектов, с огромными большими проектами, с кучей репозиторий, с кучей кода, логики и так далее.
1705.52 1708.24 "Игорь Лабутин" Правда может быть в мире микросервисов сейчас таких мало.
1708.24 1711.64 "Анатолий Кулаков" Видишь, здесь тоже ты не избавляешься от этой проблемы.
1711.64 1718.24 "Анатолий Кулаков" Даже если ты знаешь, что в твоем проекте используется entity framework, ты понятия не имеешь, какой там провайдер базы данных.
1718.24 1724.32 "Анатолий Кулаков" Можешь ли там по-сгрёбой какие-нибудь функции выполнять, или там SQLite запущен, или там в in-memory всё работает.
1724.32 1737.44 "Игорь Лабутин" Смотри, я согласен, что… Давай так, я на 100% уверен, какая BD используется в PROD, ну и в тестах, в тесте, в смысле в окружениях, за дипломинах.
1737.44 1754.68 "Игорь Лабутин" Единственное, где я действительно могу быть не уверен, или где я на 100% буду уверен, что там, например, не по-сгря, если это какой-нибудь там in-memory, ну короче, unit-тест с in-memory BD какой-нибудь, который не совсем по-сгря.
1754.68 1759.08 "Игорь Лабутин" А какой-нибудь там, не знаю, SQLite на лету работающий.
1759.08 1762.32 "Игорь Лабутин" Тут да, тут такое может быть, и тут может не заработать.
1762.32 1771.52 "Игорь Лабутин" Но мы всегда писали unit-тесты на слой доступа к базе данных, с живой базы данных, поэтому запущенный в контейнере или ещё как-то.
1771.52 1779.44 "Игорь Лабутин" Поэтому у меня не было проблем, я никогда не тестировал код особо, ну то есть на вот такой in-memory простенькой BD.
1779.44 1784.84 "Игорь Лабутин" Если уж мы хотим тестировать запросы, мы тестируем его на живой или нормальной базе данных, полноценно, такой же, как в PROD.
1784.84 1788.12 "Игорь Лабутин" Но по версии и механизмам.
1788.12 1790.64 "Игорь Лабутин" Понятно, что данных меньше, данные только тестовые.
1790.64 1792.00 "Анатолий Кулаков" Да, да, понятно.
1792.00 1794.80 "Анатолий Кулаков" Ну смотри, здесь мы именно говорим о чистоте архитектуры.
1794.80 1803.04 "Анатолий Кулаков" Естественно, всей этой чистотой на практике многие люди пренебрегают, и в многих условиях это может быть, возможно, это может быть не так уж и плохо.
1803.04 1811.68 "Анатолий Кулаков" Но если мы берём какой-нибудь проект в вакууме, в абстрактного коня, то там наличие текущих абстракций – это обычно плохо.
1811.68 1818.16 "Анатолий Кулаков" Потому что ты не можешь предсказать, выполнится твой код или не выполнится, или он упадёт в тестах, и она PROD сработает, или наоборот.
1818.16 1820.12 "Анатолий Кулаков" Пока не запустишь, грубо говоря, не узнаешь.
1820.12 1831.88 "Игорь Лабутин" Или если у вас большой какой-то, унаследованный, например, проект, в котором… одно дело, проект, который вы сами писали с нуля, и вы точно знаете, что там происходило за всё время его развития, и что происходит сейчас.
1831.88 1837.72 "Игорь Лабутин" Другое дело, когда вам досталось что-то большое, вы понятия не имеете, что там внутри и как, в разных уголках.
1837.72 1847.52 "Игорь Лабутин" То может быть, да, имеет смысл использовать такую технику в качестве, так сказать, предотвращения каких-либо проблем, дополнительного предотвращения проблем.
1847.52 1852.08 "Анатолий Кулаков" Да, да, именно так.
1852.08 1858.16 "Анатолий Кулаков" Мы остановились на том, что как раз подбираем хороший универсальный тип для того, чтобы использовать его на входе и выходе наших функций.
1858.16 1863.04 "Анатолий Кулаков" Как мы выяснили, iQueryable нам абсолютно не подходит, потому что это страшная дырявая абстракция.
1863.04 1865.80 "Анатолий Кулаков" У нас остались листы, массивы и read-only листы.
1865.80 1868.16 "Анатолий Кулаков" Вот давайте среди них что-нибудь определимся.
1868.16 1872.24 "Анатолий Кулаков" Продолжим дальше разбираться, например, с листами и массивами.
1872.24 1878.04 "Анатолий Кулаков" Итак, можем ли мы использовать листы и массивы в возвращаемых типах, то есть в ретурнить его?
1878.04 1885.04 "Анатолий Кулаков" Вот это вот очень частая штука, которую не пренебрегают абсолютно сеньорные разработчики.
1885.04 1888.64 "Анатолий Кулаков" То есть они ретурнят листы и массивы абсолютно направо и налево.
1888.64 1890.04 "Анатолий Кулаков" Это дефолтное их поведение.
1890.04 1898.64 "Анатолий Кулаков" Давайте же расперемся, нормально ли так делать или не очень, или стоит задуматься о своем поведении еще немножечко получше.
1898.64 1907.80 "Анатолий Кулаков" Прежде всего, когда вы возвращаете лист или массив из функции, вы должны задуматься, что ожидает клиент?
1907.80 1909.08 "Анатолий Кулаков" Какое поведение?
1909.08 1911.24 "Анатолий Кулаков" Какие ожидания у него по этому поводу есть?
1911.24 1917.08 "Анатолий Кулаков" То есть что он может сделать с этим возвращаемым результатом и чего он делать не должен?
1917.08 1919.20 "Анатолий Кулаков" Вернемся к тем же самым нашим репозиториям.
1919.20 1925.40 "Анатолий Кулаков" Допустим, наш репозиторий на метод getAllUsers вернул нам список всех юзеров.
1925.40 1929.96 "Анатолий Кулаков" И вернул этот список всех юзеров в виде i-листа от юзеров.
1929.96 1934.04 "Анатолий Кулаков" От querible мы избавились, вот он нам вернул обычный списочек.
1934.04 1937.24 "Анатолий Кулаков" Что потребляющий код захочет сделать?
1937.24 1946.84 "Анатолий Кулаков" Если он захочет добавить туда нового юзера, он скорее всего возьмет этот лист юзеров, вызовет метод add, сделает new user и запихнет туда нового юзера.
1946.84 1958.32 "Анатолий Кулаков" Или, может быть, если он захочет удалить первого юзера, он возьмет лист всех юзеров и по индексу 0 присвоит туда null, допустим, или подменит каким-то другим юзером.
1958.32 1964.04 "Анатолий Кулаков" То есть он начнет работать с этой коллекцией как с нормальным представлением таблицы в базе данных.
1964.04 1975.28 "Анатолий Кулаков" Добавлять, удалять, изменять пользователей в интуитивной надежде на то, что это каким-то образом повлияет на настоящую коллекцию, что таким образом ее отмодифицируют.
1975.28 1976.80 "Анатолий Кулаков" Естественно, это не так.
1976.80 1997.60 "Анатолий Кулаков" Когда мы возвращаем какую-нибудь изменяемую коллекцию, например, лист или массив, то эта коллекция возвращается оторванной от настоящего источника базы данных обычно и любая модификация этой коллекции не приведет никакому изменению настоящих оригинальных данных там, где они хранятся и там, откуда они вычитываются.
1997.60 2016.12 "Анатолий Кулаков" Поэтому данное поведение, которое сможет сделать на потребляющий код, оно абсолютно противоречит технике строго типизированности языка и предсказуемости поведения, потому что как раз-таки дает потребляемому коду ту возможность, которую на самом деле он иметь не должен.
2016.12 2019.24 "Анатолий Кулаков" Он не должен модифицировать эту коллекцию именно таким способом.
2019.24 2027.80 "Анатолий Кулаков" Если он хочет удалить пользователя, он, скорее всего, обратится к методу репозитория и попросит этого пользователя удалить, но ни в коем случае не через модификацию коллекции.
2027.80 2043.52 "Анатолий Кулаков" Таким образом, для возвращаемых значений в большинстве случаев, когда нам нужно пользователя оградить от тех действий, которые ни к чему не приведут и никакого смысла вообще не имеют, все-таки изменяемые коллекции нам не помогут.
2043.52 2045.48 "Анатолий Кулаков" Они здесь не очень подходят.
2045.48 2053.88 "Анатолий Кулаков" Далее давай разберем ситуацию, когда мы хотим принять на вход изменяемую какую-то коллекцию, например, тот же самый лист.
2053.88 2056.12 "Анатолий Кулаков" Что это за ситуация?
2056.12 2064.36 "Анатолий Кулаков" Скорее всего, это ситуация, когда мы хотим этот изменяемый лист чем-нибудь наполнить или каким-нибудь образом его отфильтровать или применить какие-то другие действия.
2064.36 2074.40 "Анатолий Кулаков" Фильтрация бесполезна, так как у нас данные в этом списке никуда не денутся, даже если мы их локально отфильтруем, то во внешнем списке, в вызывающем коде они точно так же останутся на месте.
2074.40 2085.64 "Анатолий Кулаков" А вот ситуация, когда мы хотим этот лист наполнить какими-то данными или модифицировав удалить оттуда какие-то данные, вот эта ситуация на практике часто встречается.
2085.64 2103.20 "Анатолий Кулаков" Здесь есть следующее замечание, что как только вы расшариваете некое состояние, начинаете бросать его через различные методы, каждый метод с этим состоянием что-то делает, это очень сильно сказывается на частоте появления каких-нибудь сложно отлавливаемых багов.
2103.20 2110.72 "Анатолий Кулаков" То есть это такой расшаренный стейд, который везде бегает, непонятно кто его изменяет и в какой момент времени и в каком потоке.
2110.72 2122.72 "Анатолий Кулаков" И это может быть не только проблемой среди многопоточного кода, но и проблемой, если у вас вдруг появляются данные какие-то или исчезают какие-то данные, и вам нужно понять в каком месте это произошло.
2122.72 2125.68 "Анатолий Кулаков" Кто этот негодяй, кто испортил мою коллекцию.
2125.68 2130.64 "Анатолий Кулаков" И на практике такие проблемы встречаются довольно часто.
2130.64 2135.72 "Анатолий Кулаков" И вот сесть с дебаггером и разобраться получается вообще не всегда.
2135.72 2141.88 "Анатолий Кулаков" Потому что сложно следить за таким расшаренным стейдом, который меняется со всех возможных мест.
2141.88 2145.28 "Анатолий Кулаков" И поэтому совет такой, что не делайте так.
2145.28 2148.80 "Анатолий Кулаков" Не передавайте какой-то расшаренный стейд, который могут менять все кто угодно.
2148.80 2151.12 "Анатолий Кулаков" Используйте обычный immutable объект.
2151.12 2160.96 "Анатолий Кулаков" Если вам нужно что-то поменять в изначальном объекте, то возьмите и создайте новый объект, скопируйте туда изначальный и поменяйте уже в нем.
2160.96 2165.80 "Анатолий Кулаков" Это немножко соответствует принципу immutable коллекциям, которые есть у нас в дотнете.
2165.80 2167.28 "Анатолий Кулаков" Они поступают именно так.
2167.28 2179.44 "Анатолий Кулаков" Если вам и нужна коллекция, но нежелательно модифицировать оригинал, то она создает такую копию, которая оптимизирована там под удаление и под добавление, при этом не меняя оригинала.
2179.44 2183.00 "Анатолий Кулаков" Есть иногда исключения.
2183.00 2186.92 "Анатолий Кулаков" Например, исключение, как ты уже вначале упоминал, это performance.
2186.92 2192.32 "Анатолий Кулаков" Если у вас есть какие-то performance проблемы с этим, то наверное можно пойти на уступки и сделать так.
2192.32 2203.12 "Анатолий Кулаков" Но опять же, если мы говорим про чистоту архитектуры, про чистоту вашего кода и про прелесть, как он написан, то immutable входные коллекции - это зло.
2203.12 2209.00 "Анатолий Кулаков" Это тоже code smell и использовать его они не советуются нигде.
2209.00 2210.00 "Анатолий Кулаков" Подведем итоги.
2210.00 2227.28 "Анатолий Кулаков" Под iList и Massive получается, что их нельзя использовать ни на вход, ни на выход, потому что на входе они могут привести к непредсказуемым сайдэффектам, а на выходе они дают скорее всего неожидаемое поведение, то есть их можно будет использовать неправильно.
2227.28 2233.64 "Анатолий Кулаков" Таким образом, что они не дадут тех сайдэффектов, на которые обычно ожидает потребитель.
2233.64 2237.04 "Анатолий Кулаков" Итак, у нас остались только read-only списки.
2237.04 2241.92 "Анатолий Кулаков" Это iEnumerable, iReadonlyCollection и iReadOnlyList.
2241.92 2244.16 "Анатолий Кулаков" Скорее всего, эти парни нам все-таки дадут ответ.
2244.16 2249.60 "Анатолий Кулаков" Универсальный какой-нибудь интерфейс, который мы должны принимать на вход и на выход.
2249.60 2252.04 "Анатолий Кулаков" Ну что ж, попробуем их померить.
2252.04 2261.12 "Анатолий Кулаков" Итак, если следовать нашему правилу, что на вход у нас должен поступать как можно более обобщенный тип, значит на вход к нашим функциям должен приходить iEnumerable.
2261.12 2266.20 "Анатолий Кулаков" Уж ничего обобщения в коллекциях, чем наш iEnumerable вообще нет и представить вообще сложно.
2266.20 2275.00 "Анатолий Кулаков" И так как на выходе у нас должен быть как можно более специфичный тип, то из всех этих трех друзей самый специфичный – это iReadOnlyList.
2275.00 2277.92 "Анатолий Кулаков" Это неизменяемая коллекция.
2277.92 2281.40 "Анатолий Кулаков" Она более специфична, чем iReadOnlyCollection.
2281.40 2287.44 "Анатолий Кулаков" И у нее есть большую… То есть она предоставляет больше функциональности, чем какой-то iEnumerable.
2287.44 2290.16 "Анатолий Кулаков" У нее есть count, у нее есть index.
2290.16 2298.08 "Анатолий Кулаков" То есть если мы говорим про более специфичный, более мощный тип с большим набором функциональности, то это безусловно iReadOnlyList.
2298.08 2308.52 "Анатолий Кулаков" И, соответственно, если мы говорим про метод, который должен вернуть нам всех юзеров, то у него сигнатура должна поменяться на то, что он должен возвращать нам iReadOnlyList от юзеров.
2308.52 2311.16 "Анатолий Кулаков" И тогда в принципе все будут счастливы.
2311.16 2314.56 "Анатолий Кулаков" Теперь пару слов об iEnumerable.
2314.56 2321.24 "Анатолий Кулаков" Казалось бы, да, по правилам принимайте на вход в качестве аргументов iEnumerable и все, жизнь ваша будет счастлива.
2321.24 2326.16 "Анатолий Кулаков" Но на самом деле существует очень много корнер-кейсов, когда это не так.
2326.16 2334.84 "Анатолий Кулаков" Прежде всего нужно упомянуть, опять же, то обои, засполенные в начале кейс, когда у нас есть проблемы с перформансом.
2334.84 2347.56 "Анатолий Кулаков" Как только у нас появилась линка, вот этот с .NET 3, как только появились линки, вот эти expression-методы, то я помню, что была массовая лихорадка того, что люди переделывали все на вход и на выход с iEnumerable.
2347.56 2355.40 "Анатолий Кулаков" Они считали, что lazy исполнение, такое ленивое исполнение, оно всех спасет, оно лучше всех, и нужно его в каждую функцию использовать.
2355.40 2361.76 "Анатолий Кулаков" Но спустя несколько лет, абсолютно во всех компаниях без исключения, был другой тренд.
2361.76 2367.08 "Анатолий Кулаков" Нужно было пройтись по всем методам и заменить iEnumerable на какие-нибудь redundant листы.
2367.08 2369.96 "Анатолий Кулаков" Сталкивался ли ты с такой задачей?
2369.96 2372.72 "Игорь Лабутин" Так, я пытаюсь вспомнить.
2372.72 2376.24 "Игорь Лабутин" Наверное, да, было что-то подобное.
2376.24 2388.84 "Анатолий Кулаков" Когда ты, представляешь, из базы данных какой-нибудь затаскивал какой-нибудь iEnumerable, потом отдавал его дальше, он где-то там ходил, ходил, ходил, потом его в конце кто-то начинал материализовать, а потом в другой методе его кто-то начинал материализовать еще раз, а потом еще раз.
2388.84 2397.92 "Анатолий Кулаков" И так у тебя из базы данных происходила не одна загрузка, а 10 загрузок, потому что все принимали iEnumerable, а всем на самом деле нужно было пробежаться по этому списку и сделать какие-то вычисления.
2397.92 2401.44 "Игорь Лабутин" Ну да, да, да, было такое, точно.
2401.44 2403.60 "Игорь Лабутин" Поэтому я не люблю iEnumerable.
2403.60 2406.40 "Анатолий Кулаков" Да, типичная проблема, которую приводит iEnumerable.
2406.40 2412.84 "Анатолий Кулаков" И поэтому, если кажется, что на вход требовать iEnumerable это хорошая идея, то на практике обычно это не так.
2412.84 2422.88 "Анатолий Кулаков" К сожалению, Владимир почему-то не докрутил эту тему, он все-таки остановился, что iEnumerable это за исключением там каких-то corner keys это нормальная, нормальная тема.
2422.88 2427.68 "Анатолий Кулаков" Но мне кажется, что таких corner keys их очень много, тем более на практике.
2427.68 2433.24 "Анатолий Кулаков" И поэтому в своих проектах я как раз таки придерживаюсь абсолютно другого подхода в этом плане.
2433.24 2436.36 "Анатолий Кулаков" Я всегда вместо iEnumerable требую AridonlyList.
2436.36 2444.44 "Анатолий Кулаков" Ну естественно, если мой метод, я точно знаю, что ему нужен понятный конечный список, значит нужно требовать понятный конечный список.
2444.44 2448.36 "Анатолий Кулаков" Не нужно притворяться, что дайте мне iEnumerable, а я с ним как-нибудь поработаю.
2448.36 2449.36 "Анатолий Кулаков" Нет, это не так.
2449.36 2456.32 "Анатолий Кулаков" Если вам нужен список, вы все равно будете обходить весь iEnumerable или все равно будете у него count считать, или все равно будете у него что-то делать.
2456.32 2459.00 "Анатолий Кулаков" Такое для чего вам нужен понятный конечный список.
2459.00 2468.24 "Анатолий Кулаков" А это значит, что возвращаясь к нашему object, нужно принимать не object, а нужно принимать максимально абстрактный, но тот тип, который вам нужен.
2468.24 2471.28 "Анатолий Кулаков" И обычно в наших функциях не нужны iEnumerables.
2471.28 2474.32 "Анатолий Кулаков" В наших функциях обычно нужны именно AridonlyLists.
2474.32 2478.08 "Анатолий Кулаков" iEnumerables нужны в некоторых случаях.
2478.08 2479.08 "Анатолий Кулаков" Они все-таки бывают нужны.
2479.08 2480.24 "Анатолий Кулаков" Сейчас мы с вами поговорим в каких.
2480.24 2490.56 "Анатолий Кулаков" Итак, прежде всего iEnumerables нужны там, где у нас есть ленивость, lazy.
2490.56 2507.04 "Анатолий Кулаков" Если мы вспомним стандартные методы .NET Framework и LINQ, то вам на ум прежде всего придут VE, Select, Sum, Aggregate и прочие LINQ штуки, которые умеют работать с lazy коллекциями.
2507.04 2515.88 "Анатолий Кулаков" И они вычисляют значение не тогда, когда вы вызываете эту функцию, а лишь тогда, когда происходит непосредственно материализация этой коллекции.
2515.88 2517.92 "Анатолий Кулаков" И тогда все эти функции вызываются.
2517.92 2526.20 "Анатолий Кулаков" Вот если вам нужно работать с ленивостью, вот тогда в принципе iEnumerables – это ваш выбор.
2526.20 2529.44 "Анатолий Кулаков" Тогда вам в принципе нечего здесь выбирать.
2529.44 2530.92 "Анатолий Кулаков" И вы даже можете возвращать iEnumerables.
2530.92 2534.16 "Анатолий Кулаков" Ну, то есть вы должны возвращать iEnumerables для того, чтобы сделать lazy.
2534.16 2538.64 "Анатолий Кулаков" В противном случае здесь опять же AridonlyLists обязательно должен быть.
2538.64 2549.52 "Анатолий Кулаков" Вторая интересная проблема с iEnumerables, который приходит, допустим, вам iEnumerables на вход, и вы к нему обращаетесь, пытаясь его, допустим, раскрутить, вполне можете словить DisposedException.
2549.52 2553.24 "Анатолий Кулаков" Игорь, не сталкивался с такой ситуацией ни разу?
2553.24 2554.24 "Анатолий Кулаков" Не знаешь, что это может быть?
2554.24 2558.24 "Анатолий Кулаков" Вот iEnumerables принимаешь, начинаешь его фурычить, а он тебе DisposedException бросает.
2558.24 2561.24 "Игорь Лабутин" Да, бывало, это точно бывало.
2561.24 2563.84 "Игорь Лабутин" Или Disposed, или что-нибудь какое-нибудь.
2563.84 2570.40 "Игорь Лабутин" Ну да, вообще любое такое lazy вычисление может привести к странным эффектам.
2570.40 2576.64 "Игорь Лабутин" Типа задиспоузленного DB-контекста или там реквест-контекст уже давно переиспользовался и так далее.
2576.64 2581.04 "Анатолий Кулаков" Да, да, самый частый случай это наш ORM, потому что Entity Framework любит такие штуки.
2581.04 2584.56 "Анатолий Кулаков" Как получить эту ситуацию?
2584.56 2586.16 "Анатолий Кулаков" Да, достаточно просто.
2586.16 2602.76 "Анатолий Кулаков" Вы просто открываете сессию, выбираете оттуда все данные, эти данные выбираются в виде iEnumerable, то есть, как я уже сказал, лениво, отдаете какую-то функцию на обработку и завершаете при этом функцию, которая открывала сессию, то есть открывала DB-контекст.
2602.76 2613.40 "Анатолий Кулаков" При этом сессия закрывается, данные еще не догружены, они будут догружаться лениво и функция, которая уже приняла от вас iEnumerable и радостно начинает с ним работать, получает вот этот как раз Disposed Exception.
2613.40 2619.44 "Анатолий Кулаков" Потому что сессия закрылась, коннекция к базе данных закрылась, DB-контекст уже давно задиспоузился, что ты от меня хочешь?
2619.44 2620.80 "Анатолий Кулаков" Зачем ты меня enumerate?
2620.80 2631.72 "Анатолий Кулаков" И тот метод, который принимает iEnumerable на вход, он, к сожалению, никак не может понять, а можно к этому iEnumerable обращаться уже или уже нет.
2631.72 2634.56 "Анатолий Кулаков" То есть, еще он открыт или уже закрыт.
2634.56 2643.80 "Анатолий Кулаков" И вот такое непредсказуемое, по сути, поведение, опять же, это одна из причин поставить крест на том, чтобы iEnumerable принимать в качестве входного аргумента.
2643.80 2650.84 "Анатолий Кулаков" Потому что вы никогда не знаете, он выстрелит вам ошибкой или может быть что-то еще странное сделает.
2650.84 2652.72 "Анатолий Кулаков" А что-то еще странное сделать он может.
2652.72 2657.20 "Анатолий Кулаков" С iEnumerable есть еще одна проблема, и я думаю, она не одна даже, их много.
2657.20 2660.04 "Анатолий Кулаков" Но это вот одна из самых таких показательных.
2660.04 2666.88 "Анатолий Кулаков" Еще, когда многие разработчики используют iEnumerable, они наивно считают, что он конечный.
2666.88 2668.68 "Анатолий Кулаков" На самом деле-то это не так.
2668.68 2672.20 "Анатолий Кулаков" На самом деле iEnumerable вполне может быть бесконечный.
2672.20 2674.96 "Анатолий Кулаков" И мы знаем кучу примеров, когда это так.
2674.96 2684.16 "Анатолий Кулаков" У нас есть и бесконечные генераторы случайных чисел, и бесконечные какие-то перечислятели слов, и много-много всего бесконечного.
2684.16 2703.08 "Анатолий Кулаков" И когда человек в здравом уме твердой памяти просит на вход какой-нибудь iEnumerable и начинает, например, считать какую-нибудь агрегацию или какую-нибудь сумму, то нужно задаться вопросом, а что будет, если iEnumerable туда зайдет бесконечный?
2703.08 2706.28 "Анатолий Кулаков" Ваша функция не умеет работать с бесконечными перечислениями?
2706.28 2709.76 "Анатолий Кулаков" Ну тогда непонятно, зачем вы требуете iEnumerable.
2709.76 2720.20 "Анатолий Кулаков" Требуйте конечный, понятный список, у которого есть count, у которого можно обратиться к какому-то понятному элементу и вообще сделать любую агрегацию.
2720.20 2724.86 "Анатолий Кулаков" С бесконечностью понятно.
2724.86 2735.32 "Анатолий Кулаков" Еще одно ожидание, которое программисты часто допускают, это то, что MoveNext у iEnumerable возвращает вам сразу значение.
2735.32 2737.20 "Анатолий Кулаков" На самом деле это тоже не так.
2737.20 2758.48 "Анатолий Кулаков" Легко вспомнить Blocking Collection, которая входит в стандартную поставку BCL, и Blocking Collection как раз-таки на MoveNext, и когда вы пытаетесь достать очередной элемент из этой коллекции, и этого элемента в коллекции еще нет, у вас просто-напросто заблокируется ваш вызов, и вы будете ждать там неопределенное время.
2758.48 2760.36 "Анатолий Кулаков" По сути непредсказуемое время.
2760.36 2776.64 "Анатолий Кулаков" И когда разработчики опять же принимают на вход iEnumerable и начинают фурычить по этой коллекции с надеждой на то, что они сейчас быстренько вернутся и ответят на какой-либо запрос через 0,3 миллисекунды, они совсем не подозревают, что этот iEnumerable может замереть на минуты.
2776.64 2778.24 "Анатолий Кулаков" Тоже в их головах такого нет.
2778.24 2789.80 "Анатолий Кулаков" То есть на самом деле мы к iEnumerable ментально накладываем намного больше ограничений, намного больше требований, которых у него никогда не было и не будет.
2789.80 2802.88 "Анатолий Кулаков" Поэтому если вы рассчитываете на то, что ваш iEnumerable конечный, если ваш iEnumerable должен быстро отдавать значения, а не блочиться и не ходить куда-то в сеть, или еще какие-то предпосылки есть, что он не должен бросать Disposed Exception, то скорее всего вы не хотите iEnumerable.
2802.88 2805.76 "Анатолий Кулаков" Скорее всего вы хотите понятную коллекцию.
2805.76 2811.36 "Анатолий Кулаков" И на вход вам следует принимать какой-нибудь irredundly list.
2811.36 2821.96 "Анатолий Кулаков" Это уже, наверное, из практических таких убеждений, потому что автор останавливается на том, что на вход вам нужен iEnumerable, но при этом приводит кучу вот таких вот минусов iEnumerable.
2821.96 2830.96 "Анатолий Кулаков" И на практике легче, чем учитывать все эти минусы iEnumerable, на самом деле намного легче приростно принимать list и забить вообще.
2830.96 2840.92 "Анатолий Кулаков" И избавить себя навсегда от этих страданий и выбора того, когда мне нужно, когда не нужно, когда обрабатывать исключения, когда ждать какого-нибудь подвоха, вот забейте.
2840.92 2843.56 "Анатолий Кулаков" Просто принимайте всегда irredundly list и возвращайте irredundly list.
2843.56 2846.76 "Анатолий Кулаков" И на этом все ваши проблемы с коллекциями закончатся.
2846.76 2847.76 "Анатолий Кулаков" Ну как тебе вывод?
2847.76 2848.76 "Игорь Лабутин" Ну хороший вывод.
2848.76 2856.84 "Игорь Лабутин" Мне нравится iEnumerable, не надо использовать, только если вы действительно не хотите лейзи и готовы к тому, что все будет выполняться лейзи.
2856.84 2860.36 "Игорь Лабутин" И это прям бизнес-суть того, что вы пишете.
2860.36 2862.44 "Анатолий Кулаков" Да, именно так.
2862.44 2864.88 "Анатолий Кулаков" Избавляйте irredundly list, возвращайте irredundly list.
2864.88 2872.64 "Анатолий Кулаков" Если вам нужен лейзи, то посмотрите на iEnumerable, но помните, что это безумно текущая абстракция просто со всех сторон.
2872.64 2887.48 "Анатолий Кулаков" Если же вы захотели подумать о iQueryable, то тоже помните, что это безумно текущая абстракция и использовать ее вообще практически никогда нельзя, кроме внутри какого-то репозитория, который точно знает об имплементации провайдера ваших данных.
2887.48 2898.64 "Анатолий Кулаков" А список, который iList и массивы в принципе не подходят для того, чтобы с помощью них городить какие-то понятные красивые архитектурные сигнатуры.
2898.64 2901.20 "Анатолий Кулаков" Вот такая отличная статья.
2901.20 2904.60 "Анатолий Кулаков" Большое спасибо Владимиру, как всегда, за шикарные разборы.
2904.60 2913.76 "Анатолий Кулаков" Если вам нужны больше примеров, больше доказательств красивых картинок и ссылок, куда можно посылать коллег, то всегда обращайтесь в блог Владимира.
2913.76 2916.00 "Анатолий Кулаков" Статьи хорошие, статьи приличные.
2916.00 2921.04 "Анатолий Кулаков" Нужно будет срочно добавлять ее в какой-нибудь mail-list наших компаний.
2921.04 2922.04 "Анатолий Кулаков" Круто.
2922.04 2927.44 "Игорь Лабутин" А мы вернемся к блогу Microsoft, где вышла статья про WinForms.
2927.44 2943.36 "Игорь Лабутин" Как мы где-то упоминали уже видимо в обзоре каких-нибудь новинок, WinForms завезли байдинги, WinForms поддерживает MVVM, и это что-то новенькое, и про это вышла прям отдельная статья с примерами и разбором того, как это на самом деле
2943.36 2956.52 "Анатолий Кулаков" работает. WinForms это вообще новый UI-фреймворк, я так подозреваю, потому что частота мою все еще не летит, как-то его вообще не слышно, несмотря на все потоки, а вот WinForms обрастает новыми крутыми фишками.
2956.52 2968.84 "Игорь Лабутин" Да, WinForms это новый UI-фреймворк, точнее это конечно же старый UI-фреймворк, но который дорабатывают и пытаются сделать еще более привлекательным по вполне понятным причинам.
2968.84 2973.44 "Игорь Лабутин" Мы к ним сейчас придем еще в процессе, они даже в приеденных статье, зачем это все делается.
2973.44 2983.44 "Игорь Лабутин" Но давай начнем с того, что MVVM, это штука, которая не знаю, наверное может быть почти всем знакома, но если вдруг кто-то не знаком, давай кратенько напомним.
2983.44 3011.00 "Игорь Лабутин" Вообще исторически WinForms это штука, которая ассоциируется со словом "code behind", наверное много кто про это слышал, и смысл тут такой, что WinForms позволяет очень быстро накидать приложение, но за это мы платим следующей штукой, что почти весь код находится в хендлерах, то есть если вы накинули на форму кнопочку, у кнопочки будет какой-то ивент, на этот ивент нужно подписаться, у вас будет функция, которая будет являться обработчиком этого ивента, и в этой функции вы пишете код.
3011.00 3029.20 "Игорь Лабутин" Этот код может содержать как собственно UI, как какие-то логики, типа там показать какой-нибудь диалог выбора файла, так и бизнес какую-то часть, там что-то с ним сделать, что-нибудь куда-нибудь послать, а потом выложить результат на формочку, какой-нибудь грид положить, например.
3029.20 3051.20 "Игорь Лабутин" Писать это все быстро, но если приложение становится очень большим, на практике знаю, это становится очень тяжело поддерживать, приходится прям достаточно сурово пытаться выносить вот эти кусочки бизнес логики наружу, какие-то отдельные сервисы, их как-то инжектить, назовем это, в формочки, и это все, ну WinForms к этому не очень приспособлен.
3051.20 3060.24 "Игорь Лабутин" Кроме того, это очень тяжело тестировать, в смысле модульных тестов, потому что протестировать формочку как-то очень сложно.
3060.24 3090.28 "Игорь Лабутин" Есть альтернатива, она была сделана в WPF в дот-нет мире, и это новый, так сказать, паттерн был придуман, ну не придуман, а реализован именно в WPF, когда мы отделяем код от UI, то есть UI у нас живет в отдельном слое, которое называется view, всякая доменная логика, доменно-специфичная логика живет в слое, называемом view-модул, есть еще модели, это собственно классы, где хранятся данные, ну иногда туда тоже логику немножко помещают, это модул.
3090.28 3093.48 "Игорь Лабутин" В итоге получается MVV, Model View View Model.
3093.48 3104.92 "Игорь Лабутин" И здесь получается такая конструкция, что view-модельки и модельки, они понятия не имеют, какой UI к ним будет приспособлен, то есть кто будет реально заниматься отображением.
3104.92 3124.80 "Игорь Лабутин" Это и у вас нет зависимости в модельках и view-модельках от непосредственно UI-фреймворка, что позволяет, во-первых, переиспользовать эти view-модели и модели между разными проектами, продуктами, если вам очень нужно, даже если они основаны на разных UI-фреймворках, а во-вторых, позволяет нормально тестировать, потому что вы не зависите от всяких странностей UI-фреймворков.
3124.80 3149.44 "Игорь Лабутин" Технически в WinForm было некоторое подобие такого разделения на view и модели в виде типизированных датасетов, когда можно было забайндить такой датасет к гриду, и грид как-то сам разбирался, какие колонки, куда показать, но это было только для таких вот, только для датасетов в очень ограниченном объеме.
3149.44 3158.08 "Игорь Лабутин" Дальше возникает вопрос, ну хорошо, есть же WPF, зачем нам все это радость в WinForm, тем более что WinForm исходно для этого не были предназначены.
3158.08 3187.68 "Игорь Лабутин" И многие говорят, да вообще зачем нам поддерживать старые WinForm-приложения, все переписываем на новомодные веб-фреймворки, все к ним привыкли, все будет хорошо, но есть несколько аргументов, видимо, от заказчика Microsoft, какие-то, может быть, First-tier-customers или просто customers, которые приходили в Microsoft, выкатили следующий список, ну скажем так, причин, почему, может быть, имеет смысл остаться на WinForm-ах, даже если вы живете в современном мире и пишете на современном интернете.
3187.68 3190.80 "Игорь Лабутин" Вот это уже интересно, давай.
3190.80 3202.48 "Игорь Лабутин" Да, во-первых, есть большие приложения, к которым пользователи давно привыкли, и далеко не всегда можно веб-UI обеспечить абсолютно такой же, ну что называется, flow работы.
3202.48 3212.32 "Игорь Лабутин" То есть вот привыкли там пользователи, типа пять раз нажал Tab, ввел число, три раза нажал Enter, ну вот все вы это видели, как там на каких-нибудь кассах работают, да?
3212.32 3240.44 "Игорь Лабутин" И вот переделать такое на веб-фреймворк можно, но не всегда возможно идеально один к одному, не факт, что это будет работать прям идеально так же, не факт, что это работать будет так же идеально быстро и гладко, а если вдруг что-то поменяется, ну то есть из-за особенности фреймворка вам придется что-то поменять в реализации, то там возможно какие-нибудь тысячи пользователей вашей организации, вашего софта в вашей организации придется переучивать.
3240.44 3243.20 "Игорь Лабутин" Это как бы дорого, ну деньги дорого.
3243.20 3244.20 "Анатолий Кулаков" Может быть проще.
3244.20 3257.44 "Анатолий Кулаков" Не, ну то, что нативные приложения, они всегда намного лучше, чем вебные, это ежу понятно, непонятно другое, почему не сравнивать с веб-фреймворками, а не с тем же самым WPF-ом, или Mayu-ем, или Avalon-е, или все чем-нибудь нативным.
3257.44 3258.44 "Игорь Лабутин" Вот.
3258.44 3260.12 "Игорь Лабутин" Следующий пункт, хорошо.
3260.12 3264.68 "Игорь Лабутин" А можно это все попытаться переписывать, но тут возникает вопрос переписывания.
3264.68 3272.24 "Игорь Лабутин" Переписать огромное, большое, сложное приложение стоит опять же денег, и опять же дорого, возможно.
3272.24 3278.92 "Игорь Лабутин" С сохранением логики, с сохранением всего, это все нужно будет как-то распилить, раздербанить, ну и так далее.
3278.92 3290.52 "Игорь Лабутин" То есть это можно делать, но по сути у вас будет, вы должны полностью переписать приложение, и только после этого вы сможете подменить, да, старое приложение на новое, полностью переписанное.
3290.52 3298.16 "Игорь Лабутин" Если ваше приложение старое, достаточно большое, у вас займет просто много времени это все переписать, потом, соответственно, ну, надо будет заменить одноразово.
3298.16 3299.16 "Игорь Лабутин" Ну и есть…
3299.16 3313.88 "Анатолий Кулаков" У WinForm есть прекрасные эти, забыл, как называются, островки, короче, компоненты, когда ты можешь просто на WinForm или наоборот на WPF-приложение бросить компонент, который в тебя заинлайнит, или WinForm-овское, или WPF-овское окошко по сути.
3313.88 3314.88 "Анатолий Кулаков" Молодец.
3314.88 3315.88 "Анатолий Кулаков" То есть вы как раз продавали.
3315.88 3321.08 "Игорь Лабутин" Ты прав, но для этого нужно, чтобы код был оформлен в виде компонента.
3321.08 3326.44 "Игорь Лабутин" Много ты видел бизнес-больших приложений, где все аккуратно разложено по компонентам?
3326.44 3332.48 "Анатолий Кулаков" Ну хотя бы окошки там у них разные, я могу окошко использовать как минимальную единицу компонентов.
3332.48 3338.76 "Игорь Лабутин" Ну, возможно, возможно, но на самом деле, не знаю, мой опыт говорит, что очень тяжело.
3338.76 3351.56 "Игорь Лабутин" То есть я такое делал в каких-то небольших приложеньках, но стоило взяться за какое-то очень большое бизнес-приложение, ну я не знаю, сотен на пять формочек, WinForm-овых, и это становится прям не очень удобно делать.
3351.56 3359.04 "Игорь Лабутин" Ну в смысле, это просто сложно, там они все друг на друга завязаны, кто кого куда вызывает, это все как-то держится на костылях и подпорках.
3359.04 3360.40 "Игорь Лабутин" Ну и в общем сложно.
3360.40 3379.52 "Игорь Лабутин" Это надо переписывать, понятное дело, и это можно и нужно делать, и мы сейчас перейдем к тому, что даже если вы внедряете MVVM в WinForm-ах, вам все равно придется это дело переписывания делать, но плюс здесь состоит в том, что переписывание в рамках перехода на MVVM внутри WinForms позволяет вам это делать поэтапно.
3379.52 3388.64 "Игорь Лабутин" Переписали кусочек, вы все еще можете релизить ваше приложение, а не сидеть там полгода в углу, переписывая приложение с WinForms на WPF, а потом его разово выкатить.
3388.64 3392.84 "Игорь Лабутин" Можно это делать параллельно с разработкой на обычных бизнес-фичей.
3392.84 3412.24 "Игорь Лабутин" Ну и последний пункт, это видимо уже не то чтобы какие-то требования заказчиков, это просто хотелка уже самого Microsoft-а про то, что если у вас есть десктопное приложение WinForms, то современные тенденции приводят к тому, что много пользователей начинают требовать мобильное приложение.
3412.24 3430.96 "Игорь Лабутин" Если у вас вдруг десктопное приложение написано с использованием технологии MVVM, то вы просто берете Model и ViewModel, накидываете на это сверху View-шки от MAUI, и у вас получается отличное нативное, ну такое, ну да, по сути нативное, хоть и на дотнете, приложение для мобильничков.
3430.96 3451.60 "Анатолий Кулаков" Ну звучит, конечно, неплохо, на практике не все так радужно, потому что во View-шках, то есть во View-моделях, там столько логики для десктопа пишут, обычной же, которая для мобилки абсолютно не нужна, поэтому скорее всего View-модели надо будет другие, но факт в том, что вы действительно можете их взять, скопировать и убрать все лишнее, и это будет все равно намного быстрее и легче.
3451.60 3452.60 "Анатолий Кулаков" Это так.
3452.60 3466.44 "Игорь Лабутин" Да, ну и мы уже обсуждали в этом подкасте, что MAUI пока как-то непонятно как летит, то есть мы обсуждали вот пример приложения, где товарищ попробовал, но пока что-то как-то не впечатляет, поэтому посмотрим.
3466.44 3470.48 "Игорь Лабутин" Microsoft этого хочет, но тем не менее посмотрим, куда выйдет.
3470.48 3473.96 "Игорь Лабутин" Так вот, давай вернемся к технической части, собственно, а что с этим всем делать.
3473.96 3495.88 "Игорь Лабутин" То есть мы обсуждали, только что обсудили, что в Informах, если вы кликаете на кнопочку, у вас есть там метод какой-то ваш CodeBehind, да, то есть по сути это тот же самый класс формочки, в котором написано, он просто лежит в отдельном файлике, но фактически это тот же PartialClass, в котором вы пишете какую-то логику и у контроллера есть, соответственно, Event, на который этот метод подписан.
3495.88 3498.48 "Игорь Лабутин" Он клик какой-нибудь в случае кнопочки.
3498.48 3503.12 "Игорь Лабутин" В случае с разделением ViewModel и UI нам надо как-то разнести.
3503.12 3506.92 "Игорь Лабутин" ViewModel отдельно, UI отдельно, форма отдельная, а обработчики отдельно.
3506.92 3511.92 "Игорь Лабутин" Для этого в MVVM существует концепция команд, и binding, соответственно.
3511.92 3524.92 "Игорь Лабутин" Команды - это реакция на то, что что-то произошло в UI, а UI наоборот реагирует на изменения в модели путем подписки на какие-то, значит, properties через механизм binding.
3524.92 3529.60 "Игорь Лабутин" Командочки все в .NET мире, когда мы говорим о UI-фреймворках, реализуют ICommand.
3529.60 3554.72 "Игорь Лабутин" Есть такой интерфейс, он находится, по-моему, в систем MediaInput, по-моему, namespace называется, или в систем WindowsInput, он какой-то такой не очень очевидный namespace, но тем не менее, есть ICommand, у него есть, собственно, три метода execute, выполнить действие, canExecuteProperty - это можно ли выполнять действие, на основе этого UI может enable либо disable кнопочку.
3554.72 3567.36 "Игорь Лабутин" Ну и canExecuteChanged - это ивент, который срабатывает, когда canExecute меняется, чтобы UI не опрашивал все время, можно нельзя, можно нельзя, а реагировал только на изменения в состоянии.
3567.36 3588.72 "Игорь Лабутин" Соответственно, как только вы реализуете ваш набор действий именно как команды, то есть вы можете реализовать их отдельными классами, если у вас какие-то суперсложные команды, либо можно использовать helper-классы, я сейчас чуть дальше расскажу, после чего в вашей View-модельке вы объявляете набор пропертий, где типами этих пропертий являются эти команды.
3588.72 3593.44 "Игорь Лабутин" И это будет для View-шки потом, так сказать, местами, за что можно подергать.
3593.44 3615.00 "Игорь Лабутин" Ну и если вы хотите во View-шке к чему-то прибандиться из View-модели, вы во View-модели эти свойства объявляете как свойства, которые должны emitить или, как сказать, fire-ить, используйте любое русское слово на ваш выбор, ивент, когда они изменяются.
3615.00 3629.76 "Игорь Лабутин" Всем известный интерфейс INotifyPropertyChanged, моделька должна его реализовывать, и когда меняется определенная пропертия, нужно вызвать метод onPropertyChanged с именем пропертий, которая поменялась, и UI будет знать, что надо что-то там у себя перерисовать или обновить.
3629.76 3639.52 "Игорь Лабутин" Все хорошо, это теория, такая полу-теория, которая к Informs имела мало отношения до .NET 7, потому что Informs ничего этого не умел.
3639.52 3643.90 "Игорь Лабутин" Команды мы, конечно, могли создать, но никуда их привязать было нельзя.
3643.90 3646.00 "Игорь Лабутин" Что сделали все в .NET 7?
3646.00 3667.72 "Игорь Лабутин" В .NET 7 сделали новый базовый класс, называется BindableComponent, то есть как ты говорил правильно, есть базовый класс Component, и где-то на этом уровне можно, грубо говоря, реализовать какой-нибудь WPF Component, и в него, ну дальше по сути Informs работает с компонентом просто как с компонентом, там у него layout умеет делать, какие-то размеры брать, а что компонент делает внутри - его дело.
3667.72 3675.48 "Игорь Лабутин" Хочет WPF рисует, хочет Blazor рисует, хочет вообще как бы сам по себе что угодно делать, браузер отображает.
3675.48 3706.08 "Игорь Лабутин" Теперь есть новый базовый класс BindableComponent, и у части он наследуется от компонента, и у части классов, типа например ButtonBase, то есть это базовый класс вообще для всех кнопок, ну то есть всего что выглядит логически как кнопка - это радиобаттоны, чекбоксы, просто кнопки, и для элементов, это вот, Toolbars, который ToolstripItem класс называется, у них поменяли базовый класс, он теперь не от компонента наследуется, а от BindableComponent.
3706.08 3714.68 "Игорь Лабутин" Кроме того, там есть теперь новая пропертия, которая называется Command, куда мы собственно будем подвешивать команду, которую нужно выполнить.
3714.68 3723.28 "Игорь Лабутин" Это пока не всё, это пока только изменения в базовых классах, то есть у вас автоматически у кнопочек появились новые пропертии, куда можно что-то подвесить.
3723.28 3724.28 "Игорь Лабутин" Подвешивать будем позднее.
3724.28 3739.32 "Игорь Лабутин" Дальше, с точки зрения байндинга в обратную сторону, появилась необходимость, а как-то нужно вообще говоря рассказать формочке про то, где брать данные, где ViewModel-то живёт.
3739.32 3775.92 "Игорь Лабутин" Для этого появилось свойство под названием DataContext, которое, или DataSource, сейчас не вспомнил, надо по статье посмотреть, это пропертия контрола, куда можно теперь присвоить соответственно какой-то контекст, он будет виден всем элементам, причём поскольку контролы у нас иерархичны в InForm, то есть у нас может быть формочка, на ней панелька, в панельке какой-нибудь там layout панелька, внутри ещё какой-нибудь компонент, внутри ещё компонент, то вот этот контекст, он доступен прозрачно всем детям, автоматически прокидывается, если не переопределён в детях.
3775.92 3781.36 "Игорь Лабутин" Соответственно, собирая всё это вместе, мы можем теперь работать следующим образом.
3781.36 3793.68 "Игорь Лабутин" Как и раньше в дизайнере, мы создаём формочку, в InForm, накидываем компоненты, он там автоматически генерирует этот код бехайнд класс, где эти компоненты по сути записаны c# кодом, больше мы ничего не делаем.
3793.68 3804.48 "Игорь Лабутин" Дальше мы создаём view модельный класс, реализуем identify property change, создаём команды, если надо, вот это всё, проперти, которые мы хотим потом видеть, отображаем на каком-то UI.
3804.48 3806.60 "Игорь Лабутин" И осталось теперь их склеить.
3806.60 3809.12 "Игорь Лабутин" Склеивается это всё через дизайнер.
3809.12 3819.48 "Игорь Лабутин" По крайней мере в большой, вижу, студии, в основной, у объекта, у контроллера, у формочки, у кого угодно, есть теперь секция, называется data bindings.
3819.48 3831.56 "Игорь Лабутин" Если в неё кликнуть, там, во-первых, можно добавить data source, если вы говорите select data source, вам выпадает список классов в вашем приложении, которые могут быть источником данных.
3831.56 3835.08 "Игорь Лабутин" То есть, видимо, те, которые реализуют identify property change.
3835.08 3852.00 "Игорь Лабутин" Вы выбираете какой-нибудь класс, и дальше он, видя этот класс, вытаскивает из него все команды, то есть те проперти, которые реализует iCommand, и показывает вам прямо в дизайнере, вот давайте вот к этой кнопочке какую командочку будем исполнять, и вы выбираете, так сказать, в дизайнере, какую кнопочку вы это делаете.
3852.00 3878.96 "Игорь Лабутин" Это всё, конечно же, записывается в том или ином виде в CodeBehind, но вы это руками не пишете, теперь не нужно прямо в коде в вашем классе руками всё писать, это всё автогенерится, и единственная строчка, которая, собственно, нужно, непосредственно появляется в вот этом основном CodeBehind файле, это про то, что, ну, ViewModel, собственно, нужно создать и присвоить в качестве CodeBehind, или откуда-то взять, и в этот самый датаконтекст записать.
3878.96 3924.92 "Игорь Лабутин" Если это всё делать вручную, то есть реализовать команды, вот это всё, это всё на самом деле довольно многословно, потому что вам нужно, ну что, например, если у вас было проперти, не знаю, там, лейбл какой-нибудь, да, EditBox, куда нужно в этот EditBox что-нибудь выдать, допустим, он даже read-only, вам нужно сделать проперти, у которой будет getter, который будет из какого-то, возможно, своего источника данных забирать данные и их выдавать наружу, плюс вам нужно написать на, вы не можете просто написать afterproperty, вам нужно в сеттере обязательно написать notifyProperty, change реализацию, и так далее, ну не реализацию, а вызвать метод, это самый notifyPropertyChange.
3924.92 3941.48 "Игорь Лабутин" В общем, это всё сложно и довольно многословно, с командами тоже самое, то есть вам нужно для каждой команды реализовать саму команду, вам нужно реализовать пропертью, когда её можно исполнять, и вам нужно реализовать notification, что эта пропертя поменялась.
3941.48 3959.32 "Игорь Лабутин" Поэтому есть такая штука под названием MVVM Community Toolkit, он пользовался некоторой популярностью в WPF, его можно, он был адаптирован, чтобы его теперь можно было использовать в информах тоже, это некоторый NuGet пакет, который позволяет попроще писать код для MVVM подхода.
3959.32 4012.96 "Игорь Лабутин" Это набор некоторых базовых классов плюс полезных атрибутиков и хелперов, то есть, например, если у вас есть пропертя, то вы просто на неё навешиваете атрибутик, что, мол, вот эта пропертя должна быть observable, и он автоматически сгенерит код, сурс-генератор, я так понимаю, в современной версии, который будет там все can что-то, ну, типа, если, например, она, ой, не can, она будет автоматически обновляться, когда там обновляется в сеттере и так далее, плюс, если это командочка, то там есть специальный класс RelayCommand, куда вы можете передать в конструктор просто обычную лямточку или ваш метод в вашей ViewModel, а это RelayCommand сама будет говорить, например, что она там всегда доступна или еще что-то, в общем, трекать статус и так далее на основе ваших переданных лямб, то есть, в общем, если вы засматриваетесь на MVVM, посмотрите на MVVM Community Toolkit, полезная штука.
4012.96 4021.08 "Игорь Лабутин" Теперь давай разберемся, как это все, радость, включить, ну, она, конечно, вышла в 7.NET, но это все еще превью.
4021.08 4024.72 "Игорь Лабутин" Можно ожидать всяких разных изменений до релиза 8.
4024.72 4041.16 "Игорь Лабутин" Они надеются, что в 8.NET это все зарелизится уже полноценно, но тем не менее, пока это превью фичит, это означает, что вам нужно пойти в Cessproj файл и там написать Enable Preview Features, ну или, может быть, там можно как-то галочку поставить в View-айчике, я давно не пробовал в студии, я обычно Cessproj правлю прямо в редакторе.
4041.16 4056.32 "Игорь Лабутин" После того, как будет включена превью, превью причем должна быть включена и в том ходе, где у вас, в том проекте, где живут ViewModel, если они вдруг живут не в том проекте, где формочки сами, и в том проекте, где формочки, потому что там требуется превью фичи и там и там.
4056.32 4062.60 "Игорь Лабутин" Ну и, наконец, в статье показывается пример, как можно переиспользовать эту же ViewModel в Maui коде.
4062.60 4077.56 "Игорь Лабутин" Ну, там ничего такого, единственная тонкость там сказано, что понятно, что ViewModel может иметь какую-то логику, ну, например, в ViewModel может быть бизнес-логика, а вот в этом месте я хочу показать диалог, там, не знаю, выбора файла или там, MessageBox показать.
4077.56 4083.36 "Игорь Лабутин" И в разных фреймворках это делается, вообще говоря, по-разному, а в некоторых фреймворках каких-то вещей может не быть.
4083.36 4106.04 "Игорь Лабутин" И единственный простой способ сейчас это абстрагироваться, ну, вносите такие штуки в какой-то UI-специфичный сервис, ну, в смысле, что-то скрыто за интерфейсиком, да, и инжектить это дело при создании вашей ViewModel, инжектить соответствующий сервис, чтобы он знал, там, как показывать диалоги файловые или MessageBox или еще что-нибудь.
4106.04 4118.68 "Игорь Лабутин" Заодно это позволяет юнитестировать нормально, то есть вместо того, чтобы реально выбирать файл, понятно, в юнитестах просто проверить, что эта штука вызвана, а вернете в Моке какой-нибудь, выбрали какой-то файл, давай, делай с ним что-нибудь.
4118.68 4120.52 "Игорь Лабутин" В общем, такие дела.
4120.52 4153.20 "Игорь Лабутин" Итого, это все позволяет попытаться ваш большой, сложный винформовый проект на много-много формочек и кучи лапши кодов в CodeBehind попытаться преобразовать в более толковый MVVM подход, когда у вас ViewModel и ModelKey лежат отдельно, там лежит бизнес-логика, ее можно потестировать, а UI, он лежит отдельно, и дальше, если вы хотите, вы можете этот UI каким-то образом заменять на что-нибудь, будь это MAUI, будь это, не знаю, WPF, будь это еще что-нибудь в будущем, кто знает.
4153.20 4156.92 "Анатолий Кулаков" Мобилки те же.
4156.92 4176.16 "Анатолий Кулаков" Отличная тема, прям у меня скупая мужская ухмылка прям вспомнилась, я много программировал и под WinForms, и про WPF, и мне очень понравилась концепция MVVM, когда она появилась, я прямо несколько своих фреймворков писал, переспользовал абсолютно все, что есть на рынке, чтобы понять основные нововведения и сложности.
4176.16 4206.84 "Анатолий Кулаков" И в принципе пришел к такой стратегии, что намного легче потратить там одну недельку, написать какой-то базовый MVVM фреймворк для WinForms и дальше WinForms уже клипать вместе с тестированием, с моделями, с переиспользованием, в общем, тема близкая, мне эта штука безумно нравилась, и наверное хорошо, что больше разработчиков теперь познакомятся с концепцией MVVM, поймут, как можно тестировать логику, которая находится во Vue-шках, то есть такой Vue-логик.
4206.84 4212.36 "Анатолий Кулаков" Хорошая вещь, в принципе, на правильной дороге идем.
4212.36 4220.12 "Игорь Лабутин" Ну хорошо, пойдем дальше той же правильной дорогой, у нас сегодня прям день каких-то там статей про бестпрактисы, давай еще про бестпрактисы поговорим.
4220.12 4230.88 "Анатолий Кулаков" Да, статья про лучшие практики в серилоге, как хорошо логировать, как хорошо настраивать и использовать серилог, и все об этом.
4230.88 4242.48 "Анатолий Кулаков" В принципе статья не то, чтобы совсем новая, но я ее давно видел, я ее давно читал и в принципе ждал, когда же появится все-таки что-то новое, что-то более интересное, что-то более мне близкое.
4242.48 4248.56 "Анатолий Кулаков" Ну так как за все эти годы ничего лучше не появилось, поэтому обсудим то, что есть.
4248.56 4261.32 "Анатолий Кулаков" В принципе по случайному стечению обстоятельств, то есть предыдущая статья была по твоему докладу, ну то есть та, которая про коллекции, по твоему докладу, по странному стечению обстоятельств, вот эта статья, она по моему докладу.
4261.32 4273.44 "Анатолий Кулаков" Опять же, если кто-то вдруг захочет, погуглите мой доклад про серилог, он называется, по-моему, Structure Logging, тоже будет приятно, если кто-то вспомнит и зайдет, посмотрит лишний раз.
4273.44 4289.04 "Анатолий Кулаков" Вообще, я думаю, что все давно знают, что серилог стал уже стандартным де-факто в дот-нете, и если вы почему-то еще не используете его, значит вы сидите на каком-то мамонте 20-летней давности, и вас приковали цепями и не выпускают на улицу.
4289.04 4303.24 "Анатолий Кулаков" Потому что в любом проекте, даже в старых уже, даже в новых тем более, серилог это дефолтный общологер, который только существует, и никто близко к нему пока не подбирается, поэтому в ближайшие годы, я думаю, он будет главным монополистом в сфере логирования.
4303.24 4317.72 "Анатолий Кулаков" Может быть, в каких-то маленьких проектах, когда вам не нужно что-то кроме вывода на консоль и достаточно микрософтовского логинга, может быть, вы на серилог не посмотрите, но во всех других случаях вы просто обязаны про него знать.
4317.72 4326.52 "Анатолий Кулаков" И, наверное, мы затронем сегодня какие-то аспекты, которые должны вас подвигнуть, посмотреть в эту сторону, если вы никогда не слышали такого странного сочетания букв.
4326.52 4339.52 "Анатолий Кулаков" Итак, прежде всего, прежде чем говорить о каких-то бестпрактисах, я думаю, каждый из вас должен зайти на официальный гитхаб серилога и посмотреть вообще, какие компоненты у него есть.
4339.52 4341.88 "Анатолий Кулаков" Как вы поняли, это уже движок для логирования.
4341.88 4350.56 "Анатолий Кулаков" Он очень расширяемый, очень гибкий, очень настраиваемый, под него написано миллиарды провайдеров, и умеет он практически все, что только может прийти вам в голову.
4350.56 4356.12 "Анатолий Кулаков" Опять же, в стандартном репозитории вы найдете все, наверное, что ожидаете.
4356.12 4362.64 "Анатолий Кулаков" Это стандартные какие-то расширения для ISP.NET, запись в файл, запись в консоль, настройка через AppSettings, замерка времени.
4362.64 4367.96 "Анатолий Кулаков" Вот такие базовые вещи есть и в документации, и в его официальном репозитории.
4367.96 4373.84 "Анатолий Кулаков" И, естественно, есть куча неофициальных репозиториев, контрибьюторов и прочее, прочее.
4373.84 4376.88 "Анатолий Кулаков" Итак, давайте же начнем сначала.
4376.88 4380.36 "Анатолий Кулаков" Если вдруг у вас в руках появился логер, что же мы с ним будем делать?
4380.36 4382.84 "Анатолий Кулаков" Прежде всего, мы должны что-то логировать.
4382.84 4385.92 "Анатолий Кулаков" Прежде всего, автор нам советует логировать следующие вещи.
4385.92 4389.76 "Анатолий Кулаков" Это, во-первых, какое-то логическое ветвление в вашем коде.
4389.76 4400.68 "Анатолий Кулаков" То есть, если вы нашли какую-то точку, где очень важно, куда вы ушли налево или направо, приняли то или иное решение, воспользовались той или иной цифрой, вот это бизнес-решение желательно залогировать.
4400.68 4411.84 "Анатолий Кулаков" Для того, чтобы когда вы будете смотреть на свои логи и дебажить данное поведение, вы примерно понимали, в какую сторону движется ваш код, как идет ваш поток управления и что ожидать на следующих шагах.
4411.84 4420.32 "Анатолий Кулаков" Если же вы вдруг столкнулись с какими-то ошибками или непредсказуемым поведением вашей программы, то такие моменты тоже очень полезно логировать.
4420.32 4424.64 "Анатолий Кулаков" Это, наверное, одни из самых вещей, которые нужно будет логировать.
4424.64 4427.44 "Анатолий Кулаков" Это какое-то непредсказуемое поведение и ошибки.
4427.44 4452.08 "Анатолий Кулаков" Если у вас есть какие-нибудь data intensive операции, то есть операции, которые работают с нагруженными данными, например, ходят куда-нибудь в input-output или делают какие-нибудь вычисления долгие, вот такие операции тоже бывают очень полезно залогировать, чтобы понимать, где тратится время в вашем запросе, как работает ваша программа и на что уходят основные ее силы.
4452.08 4463.80 "Анатолий Кулаков" Если же у вас произошли какие-то значимые события в домене, появился новый пользователь, зарегистрировался новый payment или еще что-то такое произошло, то такие изменения тоже очень полезно логировать.
4463.80 4472.80 "Анатолий Кулаков" Если у вас, допустим, вы пошли куда-нибудь в сеть и реквест не удался, и вы пытаетесь сделать retry, то такие места тоже очень полезно бы залогировать.
4472.80 4502.84 "Анатолий Кулаков" Если у вас есть какие-то батчи, которые вы выполняете, то есть огромное число данных, которые вы будете обрабатывать и понимаете, что завершится это не за одну миллисекунду, то можно воспользоваться специальными time операциями, которые есть в серилоге, которые позволяют вам померить, сколько будет проходить операции с этим батчем и в конце вывести удобную понятную статистику, которая вам тоже покажет, действительно ли батч укладывается в то время, в которое вы рассчитывали и не нужно ли здесь что-то поменять.
4502.84 4510.80 "Анатолий Кулаков" Здесь вот эти ситуации про логирование, они как-то описаны довольно скомканно, тут они наверняка не все.
4510.80 4523.56 "Анатолий Кулаков" Отличная тема про логирование есть у Марка Симона, может быть, когда-то мы к нему придем, подойдем и там он прям выводит концепцию, в каких точках нужно вставлять логи, а в каких точках логи вставлять ни в коем случае нельзя.
4523.56 4527.26 "Анатолий Кулаков" И естественно он покрывает это гораздо более концептуально и более хорошо.
4527.26 4538.64 "Анатолий Кулаков" Но я думаю на каком-нибудь базовом уровне, на примитивном уровне вот эти вещи у вас должны скорее всего быть в программе покрыты и плюс какие-то на ваше усмотрение.
4538.64 4545.52 "Анатолий Кулаков" Далее стоит рассмотреть о том, под каким уровнем вы должны логировать то или иное событие.
4545.52 4561.46 "Анатолий Кулаков" На самом деле, к сожалению, все вот эти стандартные уровни, которые есть практически в любом логере, в том числе даже в микрософтском интерфейсе, там дебаг, информейшн, трор, фатал, вот это все, все-таки не так однозначны, как нам хотелось бы.
4561.46 4578.26 "Анатолий Кулаков" Каждая библиотека их описывает по 100 миллионов раз, вы найдете 100 миллионов в любой статье про логинг, описаний этих уровней, но нигде нет нормального, однозначного, исчерпывающего описания под все возможные кейсы, которые только к вам придут.
4578.26 4605.38 "Анатолий Кулаков" И поэтому здесь статья тоже не берещет какой-то оригинальности, она практически перепечатывает там стандартные серилоговские рекомендации и сводятся они к следующему, что по умолчанию все логи вы должны писать в дебаге, потому что это такой многословный режим, он помогает вам в тот момент, когда вы обнаружили какую-то ошибку и вам нужно отладить вашу программу, вы обычно включаете дебаг режим и тут у вас должно как раз-таки случиться максимальное число логов, которые помогут вам максимально понять, что же все-таки происходит.
4605.38 4611.30 "Анатолий Кулаков" Поэтому дефолтный режим для любого логирования, который вам только придет в голову, это дебаг.
4611.30 4621.06 "Анатолий Кулаков" Режим информейшн вы должны использовать для того, чтобы осознать в каком состоянии сейчас работает ваше приложение или для того, чтобы определить корректность работы вашего приложения.
4621.06 4630.58 "Анатолий Кулаков" Ну или скорее всего какие-то концептуальные бизнес-точки, бизнес-ивенты или принятие решений или изменение главных бизнес-антитей вас тоже будут под информейшном.
4630.58 4642.02 "Анатолий Кулаков" То есть такие точки, которые в принципе меняют состояние вашего приложения и это состояние важно для того, чтобы в будущем понимать, как оно должно работать или почему такое поведение, такие ошибки у него выдались.
4642.02 4648.74 "Анатолий Кулаков" Ворнинги и эроры - это какие-то непредсказуемые ивенты, которые произошли в вашем исключении.
4648.74 4650.42 "Анатолий Кулаков" Например, случился какой-то эксепшн.
4650.42 4656.74 "Анатолий Кулаков" Эроры - это те события, на которые вы обязательно будете реагировать.
4656.74 4673.54 "Анатолий Кулаков" То есть если произошло в вашем приложении эрор, вы записали его в логи, то это значит, что скорее всего какой-нибудь SRE или кто-нибудь другой или система мониторинга, которая наблюдает за вашим приложением, разбудит вас там среди ночи и скажет "чувак, у тебя проблемы, давай иди чини".
4673.54 4677.04 "Анатолий Кулаков" То есть эрор - это должна быть такая солидная большая проблема.
4677.04 4685.30 "Анатолий Кулаков" Ворнинги же наоборот - это какое-то предупреждение, что ваша программа встретилась с какой-то непредсказуемой ситуацией, но она вполне способна ее обработать.
4685.30 4695.58 "Анатолий Кулаков" Если у вас там будут какие-то непонятки по данному workflow или по данному реквесту, вы сходите посмотрите его ворнинги, но если пройдет все хорошо, то в принципе да и ладно.
4695.58 4697.50 "Анатолий Кулаков" То есть ошибка такая не совсем критичная.
4697.50 4717.58 "Анатолий Кулаков" И так, в нормальном приложении вы должны понимать, что если вдруг произошла ошибка валидации, например, у вас пользовательский запрос какой-то приходит и пользователь ввел там те данные, которые в вашей системе считаются некорректными, то это в принципе не эрор.
4717.58 4726.54 "Анатолий Кулаков" То есть это не ошибка вашей программы, никого будить не надо, никакую мониторинговую систему поджигать не надо, это обычное поведение.
4726.54 4730.46 "Анатолий Кулаков" И существует даже такая концепция, что валидация не является исключительной ситуацией.
4730.46 4738.30 "Анатолий Кулаков" То есть валидация это нормальное предсказуемое поведение всей системы, система должна проверять весь input, который в нее входит, и тут никаких исключений быть не может.
4738.30 4741.66 "Анатолий Кулаков" Поэтому тут не по таким эрорам лагировать ничего не нужно.
4741.66 4742.66 None Интересно.
4742.66 4744.66 "Игорь Лабутин" Так, я уже вышел.
4744.66 4759.74 "Игорь Лабутин" Смотри, а вот такой вопрос, если я правильно помню, то если мы кидаем какую-то совсем невалидную штуку, а S/P/Net сам не лагирует какие-то ошибки именно, если что-то невалидное, или он все-таки нормальный и эроры не пишет?
4759.74 4773.46 "Анатолий Кулаков" У S/P/Net нет, он просто тебе напишет, что он вернул статус, что модель не с теми, допустим, аннотациями, с которыми он рассчитывает, или там поле не заполнено, обязательно required поле.
4773.46 4776.62 "Анатолий Кулаков" То есть он просто возвращает нормальный респонс, где все это описано.
4776.62 4780.02 "Анатолий Кулаков" Но для него это не считается как эрор в логах.
4780.02 4792.34 "Игорь Лабутин" Хорошо, может я с чем-то путаю, я просто помню, что он какой-то, да, вполне себе безобидный, ну, безобидный неправильный input, какой-то из фреймворков писал прям эрор, жор, все плохо.
4792.34 4795.14 "Игорь Лабутин" Но может быть это был ВЦФ какой-нибудь, или еще что-нибудь.
4795.14 4801.38 "Анатолий Кулаков" Я знаю, что знаешь, и DTT-сервер, например, этим грешит, если ты там неправильный токен засунул или неправильный клиент в его запрос подсунул.
4801.38 4802.38 "Анатолий Кулаков" Вот, вот, вот, да, да.
4802.38 4805.74 "Анатолий Кулаков" Он там ругается прям капитально, что типа ай-яй-яй, эроры тут все такое.
4805.74 4820.86 "Анатолий Кулаков" Вот, я поэтому и говорю, что видишь, несмотря на то, что все миллион раз знают про эти там пять типов, которые есть в логировании, нет общей понятной концепции, в которой ясно, кого когда писать и кого когда использовать.
4820.86 4834.22 "Анатолий Кулаков" Микрософт использует одно, а DTT-сервер другое, там, я уверен, что внутри микрософтовских компонентов тоже поведение может быть абсолютно третье, то есть это даже внутри одной компании тоже сложно, сложно как-то обозначить.
4834.22 4840.54 "Анатолий Кулаков" К сожалению, в индустрии у нас до сих пор нет такого документа, который исчерпывающий, всем бы объяснил, что, кого под каким уровнем логировать.
4840.54 4843.74 "Игорь Лабутин" Может, он и есть, но им не все следуют.
4843.74 4844.74 "Игорь Лабутин" Давай так.
4844.74 4852.34 "Анатолий Кулаков" Ну, может быть, если вы знаете такой документ, присылайте, мы его обязательно популяризируем и будем придерживаться, но я, к сожалению, не встречал.
4852.34 4854.18 "Анатолий Кулаков" Ну, вернемся к нашей статье.
4854.18 4881.18 "Анатолий Кулаков" Как я уже немножко выше упоминал, что существует интересный тайминг операции, и если вдруг в вашем приложении есть какая-то операция, которая требует какого-то времени, ну, например, HTTP request – это стандартная штука, обычно HTTP request все-таки требует какого-то времени, каким бы быстрым он не был, или если у вас есть какая-то I/O операция, допустим, вы ходите в внешнее хранилище, загружаете туда какие-нибудь файлы, что-то еще, очень полезно это залогировать.
4881.18 4883.82 "Анатолий Кулаков" И логирования там бывают нескольких типов.
4883.82 4890.78 "Анатолий Кулаков" Допустим, вы хотите залогировать, что вы начали ходить, если это очень длинная операция, то это тоже бывает полезно, чтобы понимать, а где вы зависли.
4890.78 4901.90 "Анатолий Кулаков" И в конце вы закончили ходить, и в этом случае обычно вы ожидаете увидеть время, которое вы потратили на поход вот этой, на исполнение вот этой долгой операции.
4901.90 4914.74 "Анатолий Кулаков" Для этого существует специальный extension у SiriLog, который позволяет вам вместо, например, метода debug вызвать метод, который называется time debug, и залогировать время, которое уходит на эту операцию.
4914.74 4927.62 "Анатолий Кулаков" Он реализует этот метод, то есть возвращает удобный disposable, в результате чего вы можете использовать ключевое слово using, и буквально в одну строчку залогировать и начало, и окончание операции, что тоже бывает удобно.
4927.62 4932.10 "Анатолий Кулаков" Еще одно знаменитое свойство, которое публикуется SiriLog, это source context.
4932.10 4940.46 "Анатолий Кулаков" Source context рассказывает вам про тот класс, который непосредственно стал инициатором данного сообщения о логировании.
4940.46 4943.18 "Анатолий Кулаков" Ну, то есть, по сути, тот класс, из которого вы логируете.
4943.18 4953.26 "Анатолий Кулаков" Безусловно, одно из самых полезных свойств, именно на него люди обычно смотрят, когда пытаются найти источник той информации, которая была записана в логах.
4953.26 4960.86 "Анатолий Кулаков" И здесь, в принципе, нечего добавить, кроме того, что по умолчанию принято записывать в это свойство full name от класса.
4960.86 4967.26 "Анатолий Кулаков" Это часто не очень удобно, особенно если вы это свойство часто используете.
4967.26 4970.74 "Анатолий Кулаков" Например, выводить его в консоль для того, чтобы посмотреть, откуда пишутся логи.
4970.74 4976.94 "Анатолий Кулаков" Или ищите по этому свойству в вашей базе данных всех логов и искать по полному нейму.
4976.94 4981.22 "Анатолий Кулаков" Иногда даже целого монитора не хватит, чтобы поместить full name в ваш монитор.
4981.22 4989.90 "Анатолий Кулаков" Поэтому часто пишут маленький enricher, который просто-напросто записывает не full name от класса, а просто name от класса.
4989.90 4991.54 "Анатолий Кулаков" Обычно такого вполне хватает.
4991.54 4998.38 "Анатолий Кулаков" Да, теоретически могут быть конфликты, но практически это ситуация, которая не страшная и безумно редко случается.
4998.38 5003.66 "Анатолий Кулаков" Поэтому short namer здесь тоже полезное свойство, которое добавляют вручную.
5003.66 5009.02 "Анатолий Кулаков" Есть также возможность логирования HTTP.
5009.02 5013.90 "Анатолий Кулаков" Безусловно, наша ASP.NET это богатый такой фреймворк, который делает кучу всего полезного.
5013.90 5018.50 "Анатолий Кулаков" И очень полезно за этим фреймворком наблюдать и следить.
5018.50 5029.38 "Анатолий Кулаков" То есть, какие запросы к вам входят, с какими полями, какие они экспозят интересные данные, с какими респонсами возвращаются, с какими кодами, с какими кодерами.
5029.38 5034.66 "Анатолий Кулаков" То есть куча полезной информации, которые вам, возможно, будет полезно увидеть в логах.
5034.66 5046.06 "Анатолий Кулаков" Для этого есть отдельное расширение, отдельный медлеварька, который подключается к вашему приложению буквально одной строчкой и экспозит в ваши логи кучу полезной HTTP атрибутов.
5046.06 5050.26 "Анатолий Кулаков" Соответственно с респонсом, который приходит и с респонсом, который уходит.
5050.26 5052.74 "Анатолий Кулаков" Здесь есть тоже одно маленькое замечание.
5052.74 5060.62 "Анатолий Кулаков" Данную медлеварьку надо подключать после того, как вы подключили health-чеки и мониторинг с помощью метрик.
5060.62 5072.66 "Анатолий Кулаков" Потому что иначе она вам начнет логировать каждый раз, когда к вам приходит какой-нибудь кубернетис или load balancer за health-чеками или каждый раз, когда вас спрашивают метрики и это будет просто огромная-огромная помойка из логов.
5072.66 5075.42 "Анатолий Кулаков" Поэтому этим тонкости тоже нужно учитывать.
5075.42 5085.18 "Анатолий Кулаков" Если ваше приложение пользуется health-чеками и пользуется метриками, не забывайте подключать их перед тем, как начнете логировать все запросы, поступающие в ваше приложение.
5085.18 5092.90 "Анатолий Кулаков" Еще один интересный аспект серилога – это наличие так называемых enrichers, то есть обогатителей, расширяторов.
5092.90 5100.42 "Анатолий Кулаков" И как раз-таки огромный набор этих обогатителей делает его очень полезной такой мощной тулзой.
5100.42 5117.38 "Анатолий Кулаков" Кроме стандартной поставки, в стандартную поставку у него входят environment enricher, он помогает в ваши логи добавлять такие полезные свойства, как имя компьютера, имя машины, на которой вы запускаетесь, имя текущего пользователя, еще что-то, что можно вытащить из environment среды окружения.
5117.38 5129.06 "Анатолий Кулаков" Thread id enricher тоже полезная вещь, когда вы особенно отлаживаете какой-нибудь параллельный код, если у вас очень много параллельностей, concurrency, то без thread id вообще никуда.
5129.06 5131.94 "Анатолий Кулаков" И вы любите отлаживать это, естественно, все.
5131.94 5167.78 "Анатолий Кулаков" Exception details enricher – это прикольное расширение, которое позволяет записывать в ваши логи не только какую-то базовую информацию об исключении stack trace, messages и так далее, но и если вы используете custom exceptions, то есть exceptions, которые специфичны под конкретно ваши бизнес задачи или под вашу инфраструктуру, и у них есть в этих исключениях определенные поля, к которым вы складываете полезные данные, с помощью этого enricher в ваших логах будут храниться, в том числе будут записываться вот эти поля дополнительные.
5167.78 5171.62 "Анатолий Кулаков" Тоже очень удобно, если вы используете custom exceptions, как я сказал.
5171.62 5176.74 "Анатолий Кулаков" Еще одно полезное расширение – это log-контекст enricher, но о нем мы поговорим немножко попозже.
5176.74 5184.58 "Анатолий Кулаков" Одно из полезных свойств – это добавление статических свойств.
5184.58 5192.26 "Анатолий Кулаков" То есть, если мы про enricher и говорим, то это какие-то динамические свойства, которые могут отличаться в зависимости от того, где они логируются и при каких условиях.
5192.26 5199.78 "Анатолий Кулаков" Также у нас есть статические свойства, которые никогда не меняются после того, как ваше приложение запустилось, но вполне может быть полезным.
5199.78 5202.26 "Анатолий Кулаков" Типичный пример – это application name.
5202.26 5209.94 "Анатолий Кулаков" Оно никогда у вас не меняется, у вас есть какое-то строго определенное имя этого приложения, и это имя очень помогает видеть его всегда в логах.
5209.94 5224.74 "Анатолий Кулаков" Потому что обычно логи централизованы, туда сыпятся записи с абсолютно разных приложений, и если вы хотите найти только те логи, которые относятся к вашему конкретному приложению, то отфильтровать их по application name не составит никакого труда.
5224.74 5234.54 "Анатолий Кулаков" Поэтому это одно из тех свойств, которое должно быть абсолютно во всех записях, и оно статическое никогда не меняется со временем.
5234.54 5238.42 "Анатолий Кулаков" Еще одно интересное свойство – это instance ID.
5238.42 5242.94 "Анатолий Кулаков" Это тоже не очень стандартное свойство, может быть, недостаточно распространенное.
5242.94 5244.98 "Анатолий Кулаков" Суть его сводится к следующему.
5244.98 5259.70 "Анатолий Кулаков" В наш век кубернетисов, клаудов и перезапускаемых инстансов иногда бывает важно знать, в каком экземпляре приложения происходит вся эта работа.
5259.70 5265.82 "Анатолий Кулаков" Допустим, у вас в кубернетисе стоит избыточность, и вы запускаете сразу 10 инстансов вашего приложения.
5265.82 5271.02 "Анатолий Кулаков" И вот один инстанс пишет все время с ошибками, а другой работает нормально.
5271.02 5279.14 "Анатолий Кулаков" И в ваших логах, если вы отфильтруете просто по application name, это все сведется в кучу и будет показываться как просто непонятное месиво.
5279.14 5289.82 "Анатолий Кулаков" Если же вы отсортируете это по instance ID, то вы сможете понять, что один инстанс постоянно сбоит, а другой работает абсолютно нормально.
5289.82 5296.98 "Анатолий Кулаков" И пойти копать эту тему, может у него сеть недоступна, может старая версия приложения в этом инстансе работает, может еще что-то не так с этим инстансом.
5296.98 5310.70 "Анатолий Кулаков" В общем, дальше уже можно разбираться непосредственно с конкретным экземпляром на конкретной подиске, в конкретном нетворке, в конкретном дата-центре, то есть уже выходить на какую-то более низкоуровневую конкретику.
5310.70 5322.18 "Анатолий Кулаков" Instance ID – это по сути обычный гуид-неугуид, который каждый раз при запуске приложения выдается новый и нужен только для того, чтобы различать различные экземпляры одного и того же запущенного приложения.
5322.18 5325.30 "Анатолий Кулаков" Тоже бывает полезная штука.
5325.30 5340.38 "Анатолий Кулаков" При частых запросах, особенно если эти запросы идут между разными приложениями, ну даже внутри одного приложения, нам полезно знать, какие действия, какие логи были записаны в рамках одного запроса.
5340.38 5350.78 "Анатолий Кулаков" Потому что запросов у нас параллельно может быть миллионы и если вдруг ошибка произошла в каком-то одном из миллионов, нам хотелось бы все-таки проследить полный путь этого запроса.
5350.78 5360.82 "Анатолий Кулаков" Как он к нам пришел, какие данные изменял, куда пошел, какое было исключение, как отреагировала HTTP на это исключение, какой код вернул.
5360.82 5364.86 "Анатолий Кулаков" Все это можно сделать с помощью так называемой концепции корреляционов.
5364.86 5373.06 "Анатолий Кулаков" То есть есть Correlation ID, который пронизывает абсолютно все записи логов в рамках какого-то определенного скопа.
5373.06 5387.66 "Анатолий Кулаков" Типичным скопом является HTTP Request или может быть, например, SQL транзакция или что-то еще такое, что охватывает собой какой-то промежуток, какой-то набор действий, связанных чем-то одним.
5387.66 5402.46 "Анатолий Кулаков" В общем, у Serie.log тоже есть куча экстеншн методов, которые позволяют вам протянуть этот Correlation ID среди всех этих сообщений, в том числе HTTP Middleware, про которым я упоминал выше.
5402.46 5405.54 "Анатолий Кулаков" Так как статья довольно старая, здесь не рассматривается OpenTelemetry.
5405.54 5417.06 "Анатолий Кулаков" Я напомню, что в OpenTelemetry есть стандарт Distributed Tracing, и скорее всего для того, чтобы соответствовать этому стандарту, нужно будет подключать эту библиотеку.
5417.06 5426.42 "Анатолий Кулаков" В общем, это тоже, наверное, тема на проработать и посмотреть, как правильно OpenTelemetry подключить к Serie.log.
5426.42 5434.66 "Анатолий Кулаков" Там у Женя нет какой-то готовой, понятной рекомендации, и он используется OpenTelemetry только на ранней стадии разработки, я имею в виду в Serie.log.
5434.66 5439.94 "Анатолий Кулаков" И его поддержка сейчас только намечается какими-то штрихами, такими высокоуровнями.
5439.94 5441.74 "Анатолий Кулаков" Поэтому пока глубокой интеграции нет.
5441.74 5444.50 "Анатолий Кулаков" Но я думаю, в скором времени появится.
5444.50 5447.74 "Анатолий Кулаков" Теперь давайте вернемся к уровню разработчика.
5447.74 5463.06 "Анатолий Кулаков" На самом деле, люди, которые писали логи до появления Serie.log, в принципе, это довольно, можно сказать, новая технология, которая появилась по меркам всего программирования, а не только в DotNet не так уж давно.
5463.06 5478.34 "Анатолий Кулаков" Они могут сталкиваться, такие люди могут сталкиваться с небольшими неожиданностями, которые были нормальными в старых фреймворках логирования и совсем ненормальными в новых фреймворках, таких как Microsoft Logging, такие как Serie.log и, в принципе, много-много других.
5478.34 5486.22 "Анатолий Кулаков" Сейчас в Structured Logging фреймворков появляется огромное количество, поэтому они применимы не только даже к DotNet, но и к другим языкам.
5486.22 5489.74 "Анатолий Кулаков" Итак, давайте же подумаем, посмотрим, что это за основные принципы.
5489.74 5492.42 "Анатолий Кулаков" Они простые, но очень-очень важные.
5492.42 5513.02 "Анатолий Кулаков" Итак, во-первых, нужно использовать сообщения в повествовательном стиле и нужно свойства, которые вы пытаетесь залогировать, вписывать в это сообщение, в это предложение так, чтобы это все читалось как единый, понятный, человеко-читабельный контекст.
5513.02 5526.50 "Анатолий Кулаков" То есть, когда вы говорите, что пользователь вошел в систему, вы не говорите «пользователь = Вася совершил вход в систему», вы пишете нормальным человеческим русским или английским языком.
5526.50 5530.86 "Анатолий Кулаков" Типа, пользователь там name вошел в систему, где name = Вася.
5530.86 5552.46 "Анатолий Кулаков" В общем, структурное логирование сделано таким образом, что оно, этот template преобразует в человеко-читабельное сообщение и отдаст человеку, а извлеченное имя и значение это имени Вася, оно запишет в понятные структурные свойства и отдаст уже непосредственно алгоритмам или тем механизмам, которые будут их обрабатывать.
5552.46 5554.38 "Анатолий Кулаков" То есть, оно само все красиво разделит.
5554.38 5560.30 "Анатолий Кулаков" Ваше задание только лишь сформировать правильное повествовательное предложение.
5560.30 5569.74 "Анатолий Кулаков" Следующая тема это в том, что логи, записи в логах, они оперируют фрагментами, а не правильными синтактическими предложениями.
5569.74 5572.98 "Анатолий Кулаков" Поэтому нужно в конце избегать ставить точки.
5572.98 5581.30 "Анатолий Кулаков" Это не какое-то предложение, которое закончено или какое-то, которое о чем-то спрашивает или какое-то чему-то радуется или о чем-то повествует.
5581.30 5582.30 "Анатолий Кулаков" Нет.
5582.30 5583.30 "Анатолий Кулаков" Это всего лишь на все фрагмент.
5583.30 5584.30 "Анатолий Кулаков" Фрагмент какого-то сообщения.
5584.30 5590.62 "Анатолий Кулаков" Эти сообщения могут быть упорядочены, они могут там исследовать друг за другом, они могут выдавать там разную какую-то мысль.
5590.62 5597.86 "Анатолий Кулаков" Но смысл в том, что не нужно делать из этого какую-то правильную синтактическую конструкцию и ставить точки в конце.
5597.86 5601.02 "Анатолий Кулаков" Простое правило, но часто нарушается.
5601.02 5609.26 "Анатолий Кулаков" И наверное самое главное правило, все это в принципе были рюшечки, цветочки и никакого отношения к техническим проблемам не имеют.
5609.26 5622.78 "Анатолий Кулаков" Но вот это правило имеет непосредственно технические стороны и его нужно соблюдать очень тщательно и именно оно чаще всего нарушается старыми людьми, которые логировали в старом стиле.
5622.78 5627.54 "Анатолий Кулаков" Это правило, которое называется templates против messages.
5627.54 5638.46 "Анатолий Кулаков" Суть в том, что ту строчку, которую вы отдаете в Serilog в качестве читабельной строки, на самом деле она должна быть template, она не должна быть сообщением.
5638.46 5640.14 "Анатолий Кулаков" Что это значит?
5640.14 5642.54 "Анатолий Кулаков" Допустим вы хотите залогировать текущее время.
5642.54 5651.34 "Анатолий Кулаков" В старых фреймворках вы бы сделали такую штуку, вы бы написали time is и сделай плюсик data time utc now.
5651.34 5658.90 "Анатолий Кулаков" То есть вы бы залогировали строчку уже с отрендеренным понятным, но сплюсованным контентированным временем.
5658.90 5663.22 "Анатолий Кулаков" В структурном логировании так делать ни в коем случае нельзя.
5663.22 5669.62 "Анатолий Кулаков" В структурном логировании вы должны записать строчку, которая звучит time is и в фигурных скобочках слово now.
5669.62 5671.50 "Анатолий Кулаков" То есть имя property now.
5671.50 5677.06 "Анатолий Кулаков" А дальше через запятую вы передаете значение этого now, то есть то же самое data time utc now.
5677.06 5683.42 "Анатолий Кулаков" Не такая уж большая разница на первый взгляд, но на самом деле технически это разница просто огромна.
5683.42 5688.46 "Анатолий Кулаков" Технически каждый месседж, который вы передаете на самом деле является темплейтом.
5688.46 5694.30 "Анатолий Кулаков" Это значит, что любая строка, которая передается, она должна быть как можно менее изменяемой.
5694.30 5698.10 "Анатолий Кулаков" Потому что каждый темплейт серилок парсит и кэширует.
5698.10 5702.58 "Анатолий Кулаков" В зависимости от лимитов конечно, но все же он парсит и кэширует.
5702.58 5721.82 "Анатолий Кулаков" Поэтому если эта строчка будет постоянно меняться, то есть в следующий раз, когда ее вызовут, количество секунд изменится и по сути сама строчка изменится, ее придется заново парсить и заново кэшировать и соответственно из кэша выталкивать те строчки, те темплейты, которые нам нужны и вставлять вот эту непонятную, ненужную штуку.
5721.82 5728.18 "Анатолий Кулаков" Если же строчка будет все время состоять из time и слова now, то темплейт будет один и тот же.
5728.18 5729.18 "Анатолий Кулаков" Он никогда не меняется.
5729.18 5731.54 "Анатолий Кулаков" Им будет меняться только значение property.
5731.54 5735.66 "Анатолий Кулаков" И внутренний механизм кэширования парсинга сможет отлично отработать.
5735.66 5737.90 "Анатолий Кулаков" Вот здесь нужно быть очень внимательным.
5737.90 5745.90 "Анатолий Кулаков" Уже есть анализаторы, которые более-менее стараются такие штуки анализировать и подсказывать вам, но опять же, наверное, не все ими могут пользоваться.
5745.90 5773.10 "Анатолий Кулаков" Если вдруг не пользуетесь, подключите такой анализатор или будьте аккуратнее на код-ревью, потому что ошибка может привести не только к банальным времени парсинга и времени кэширования, но она легко может навредить вашему хранилищу, потому что все хранилища логов они в основном рассчитывают на то, что этот темплейт будет очень редко меняться и поэтому не могут по нему строить индексы и поэтому там могут вычислять его и в IntID.
5773.10 5783.26 "Анатолий Кулаков" Если же это не так, движок вполне может сойти с ума, сделать огромные размеры, перестать искать и прочие странные чудеса будут с ним твориться.
5783.26 5789.10 "Анатолий Кулаков" И вы даже не увидите, то есть не поймете с первого раза в чем, собственно, проблема.
5789.10 5795.70 "Анатолий Кулаков" И последнее такое мелкое замечание, за которым тоже мало следят.
5795.70 5797.42 "Анатолий Кулаков" Это все свойства должны называться Pascal Cases.
5797.42 5800.54 "Анатолий Кулаков" Ну как у нас в C# принято называть всякие свойства.
5800.54 5802.82 "Анатолий Кулаков" Вот Serilog в этом плане не исключение.
5802.82 5807.06 "Анатолий Кулаков" В строках, в фигурных скобках должны названия быть Pascal Cases.
5807.06 5809.70 "Анатолий Кулаков" Итак, переходим к интересному.
5809.70 5810.70 "Анатолий Кулаков" Про лог-контекст.
5810.70 5824.74 "Анатолий Кулаков" Лог-контекст, уже упоминал со мной ранее, это специальная система, которая позволяет вашим логам динамически добавлять свойства в зависимости от текущего контекста.
5824.74 5827.74 "Анатолий Кулаков" Это дизайн-паттерн, который называется Ambient Context.
5827.74 5830.94 "Анатолий Кулаков" Вот он здесь применяется очень активно.
5830.94 5834.38 "Анатолий Кулаков" Например, в HTTP-реквестах.
5834.38 5841.62 "Анатолий Кулаков" Вы можете записать в самом начале, как только у вас HTTP-реквест начинается, записать в лог-контекст Request ID.
5841.62 5848.50 "Анатолий Кулаков" Как я уже говорил выше, и он будет пронизывать абсолютно все ваши последующие ивенты, которые вы будете записывать.
5848.50 5856.98 "Анатолий Кулаков" Даже тот код в бизнес-логике, в котором вы напишите, что товарищ Вася успешно провел такую-то платежку, которая ничего не знает ни про какой Request ID.
5856.98 5864.10 "Анатолий Кулаков" SiriLog прозрачно в это сообщение запишет Request ID, в рамках которого была совершена вот эта проводка.
5864.10 5869.82 "Анатолий Кулаков" Очень полезная штука, особенно для отладки, для какой-нибудь диагностики и так далее.
5869.82 5871.90 "Анатолий Кулаков" Это все делается благодаря лог-контексту.
5871.90 5875.34 "Анатолий Кулаков" Естественно, вы тоже можете делать подобные штуки.
5875.34 5889.58 "Анатолий Кулаков" Например, если вы захотите в каждый реквест вставить имя пользователя или айдишник пользователя, от имени которого все эти действия будут делаться, это точно так же легко делается с помощью пары строчек в лог-контексте.
5889.58 5896.58 "Анатолий Кулаков" Немножко отличающаяся концепция, но близко к лог-контексту и существует еще диагностик-контекст.
5896.58 5902.26 "Анатолий Кулаков" Это штука, которая позволяет вам соединить множество информации в один ивент.
5902.26 5928.62 "Анатолий Кулаков" Если вы хотите, чтобы в конце вашего HTTP-запроса, допустим, было максимум информации, которую мы смогли собрать в рамках этого HTTP-запроса, в выполнении всего пайплайна, в выполнении всего реквеста, допустим, и какие заявки были проведены, и каким пользователем это было сделано, какой у него кастомер, какой у него пеймент-айди и так далее, то вы можете всю эту информацию запихивать в диагностик-контекст.
5928.62 5940.86 "Анатолий Кулаков" И к самому конце HTTP-респонс, когда будет уже логироваться вот этот HTTP middleware, в самом конце оно соберет все свойства, все свои визуальные действия в диагностик-контексте и залогирует вам одним ивентом.
5940.86 5950.46 "Анатолий Кулаков" Иногда такая штука бывает полезна, несмотря на то, что из-за этого получается какая-то огромная несвязанная помойка из всех свойств, которые вы туда забросили.
5950.46 5954.82 "Анатолий Кулаков" Существуют такие моменты, когда это действительно может быть полезно.
5954.82 5957.54 "Анатолий Кулаков" Поэтому посмотрите, что там получится у вас.
5957.54 5961.66 "Анатолий Кулаков" Стоит еще упомянуть об одной концептуальной вещи, это event type.
5961.66 5975.86 "Анатолий Кулаков" Как я уже сказал, каждый темплейт в нашем сообщении представляет собой, ну по крайней мере должен представлять какую-то уникальную неизменяемую строку, неизменяемый темплейт.
5975.86 5981.90 "Анатолий Кулаков" Раз он неизменяемый, то по нему можно сделать некую фильтрацию.
5981.90 5987.50 "Анатолий Кулаков" То есть, допустим, найти все ивенты, у которого есть этот темплейт.
5987.50 5992.42 "Анатолий Кулаков" То есть, по сути, мы найдем все ивенты, которые проходили через эту строчку логирования.
5992.42 5999.02 "Анатолий Кулаков" Чтобы немножко упростить эту концепцию, ищут не самому темплейту, а ищут по хэшу от этого темплейта.
5999.02 6004.90 "Анатолий Кулаков" То есть, обычно это какое-то просто int значение, по которому очень удобно индексировать.
6004.90 6014.74 "Анатолий Кулаков" Такие тулзы, как например, SICK, он автоматически высчитывает хэш от темплейта, и вам не нужно каким-то образом отдельно заморачиваться.
6014.74 6018.50 "Анатолий Кулаков" Там функциональность поиска по темплейту, она просто встроена из коробки.
6018.50 6032.06 "Анатолий Кулаков" Если же вы хотите подобного же поведения для каких-то других хранилищ, у которых такого поведения нет, существует отдельный инричер, который добавляет вам это свойство в каждый ваш лог, в каждую вашу запись.
6032.06 6036.06 "Анатолий Кулаков" Просто добавляет хэш, который называется event type.
6036.06 6038.86 "Анатолий Кулаков" По этому хэшу вы можете построить индекс и удобно искать.
6038.86 6043.42 "Анатолий Кулаков" Конфигурация Siri Лога поддерживает кучу всяких конфигураций.
6043.42 6051.42 "Анатолий Кулаков" Вы можете настроить через Fluent API, можете воспользоваться микрософтовской системой конфигурирования через вот эти конфигурации, options и так далее.
6051.42 6062.78 "Анатолий Кулаков" То есть можно благодаря микрософтской системе загружать конфигурацию абсолютно откуда угодно, начиная от апп-сеттингсов, инвайрментов, каких-нибудь консулов, баз данных.
6062.78 6067.02 "Анатолий Кулаков" В общем, откуда только поддерживается эта конфигурация, поддерживается она абсолютно везде.
6067.02 6081.06 "Анатолий Кулаков" И в принципе в эту систему, в это хранилище, например в апп-сеттингсе, советуется выносить только те параметры, которые вы хотите менять без перезапуска приложения.
6081.06 6088.58 "Анатолий Кулаков" Если же у вас какие-то параметры, которые вы менять не собираетесь, такие как application name, допустим, его никакого смысла в сеттинге выносить нет.
6088.58 6095.50 "Анатолий Кулаков" Вы его можете с помощью Fluent API нормально задать в коде и красиво в одном месте конфигурировать и наблюдать, если вам вдруг это нужно.
6095.50 6103.46 "Анатолий Кулаков" Опять же, все конфигурации элементарно подключаются, загружаются, для этого есть определенные enrichers и библиотечки.
6103.46 6108.46 "Анатолий Кулаков" Итак, насчет production логирования.
6108.46 6120.12 "Анатолий Кулаков" Рекомендуется в консоль, если вы логируете, включать только эрроры и все, что больше эрроров, по той простой причине, что в дот-нете консоль это блокирующий вызов.
6120.12 6126.30 "Анатолий Кулаков" И запись в консоль может приводить к очень большим тормозам, если вы в консоль пишите очень-очень много.
6126.30 6131.98 "Анатолий Кулаков" Поэтому если вы следите за перформансом, то есть консоль безумно медленная, чтобы вы понимали.
6131.98 6134.18 "Анатолий Кулаков" То есть на этом уровне все следят за перформансом.
6134.18 6141.90 "Анатолий Кулаков" То есть по данной причине в production, в консоли ограничение на консоль ставьте в log level error.
6141.90 6149.14 "Анатолий Кулаков" Глобально же, то есть ваше хранилище логов обычно пишется с лог левелом информация и выше.
6149.14 6162.26 "Анатолий Кулаков" Если вдруг вы какие-то ошибки нашли и собираетесь их отдебашить с помощью логов, тогда переключаете ваш конкретный инстанс в дебаг и тогда ваши логи будут полны каких-то интересных подробностей.
6162.26 6164.74 "Анатолий Кулаков" Вы соответственно логируете уже в дебаге.
6164.74 6170.90 "Анатолий Кулаков" Обязательно не забудьте выключать, возвращайте обратно на информацию, потому что дебаг это страшная штука.
6170.90 6176.74 "Анатолий Кулаков" Она может за считанные часы заспамить абсолютно все хранилище с самыми огромными дисками.
6176.74 6180.34 "Анатолий Кулаков" И в конце хотелось бы по пару слов сказать о SICK.
6180.34 6182.82 "Анатолий Кулаков" SICK это прекрасный инструмент.
6182.82 6186.90 "Анатолий Кулаков" Он бесплатен для локального использования, также у него есть коммерческие лицензии.
6186.90 6189.90 "Анатолий Кулаков" Инструмент для хранения логов.
6189.90 6200.34 "Анатолий Кулаков" Вся его прелесть заключается в том, что он сделан автором серилога Николасом Блумхартом, тем же человеком, который придумал серилог, он же пишет SICK и он же поддерживает эту компанию, он зарабатывает на этом.
6200.34 6206.38 "Анатолий Кулаков" И этот инструмент безумно приятен для того, чтобы с ним работать.
6206.38 6215.34 "Анатолий Кулаков" У него поиски, фильтрации, какие-то мониторинги, графики, фильтры, нативная поддержка из коробки, естественно сразу структурного логирования.
6215.34 6222.78 "Анатолий Кулаков" То есть абсолютно тот максимум, который должны давать структурные логи, как они должны выглядеть, как они должны фильтроваться, запоминаться.
6222.78 6225.38 "Анатолий Кулаков" А там в SICK все гениально реализовано.
6225.38 6232.38 "Анатолий Кулаков" Его единственная проблема, очень критичная такая проблема в том, что у него нет распределенного хранилища.
6232.38 6247.66 "Анатолий Кулаков" То есть это всегда синглпот такое хранилище, которое очень легко может выйти за границы допустимого значения и соответственно не может больших нагрузок выдерживать.
6247.66 6258.58 "Анатолий Кулаков" То есть как локальный инструмент для отладки, он все еще без всяких претензий, никто его не обгонит, это действительно самая удобная штука.
6258.58 6263.30 "Анатолий Кулаков" Но в продакшене, скорее всего, при интенсивном логировании, при больших нагрузках вы его использовать не сможете.
6263.30 6276.30 "Анатолий Кулаков" Локально он элементарно поднимается в докере, можно настроить докер комполс, запустить одной командой, он работает под линуксом и запускается абсолютно прозрачно рядышком и для отладки, как я уже сказал, прекрасная штука.
6277.14 6293.70 "Анатолий Кулаков" Вот так вот кратенько про логи, про бестпрактисы, про инструменты, которые есть, про инричеры, про сик и надеюсь, что сейчас ваше знание о логировании, если не улучшить, то по крайней мере упорядочились.
6293.70 6302.34 "Игорь Лабутин" Да, это действительно отличное саморе, сам с удовольствием послушал, честно говоря, поприкидывал, а это используем, а это не используем.
6302.34 6330.42 "Игорь Лабутин" У нас на самом деле, для информации какой-то может быть альтернативной точки зрения, у нас, например, в большинстве проектов серилог использовался именно в качестве, назовем это бэкэнда для вот этого майкрософтского стандартного логера, то есть везде у нас только стандартный логер и только в самом конце у нас серилог, потому что он классно умеет там и файлы писать со всяким роллингом и в тот же сек кидать или еще куда-нибудь.
6330.42 6342.54 "Игорь Лабутин" То есть внутри кода мы нигде не использовали, в основном вот эти все серилоговские фишечки про тайминги и получение логера через свои штуки, через серилоговский, только через стандартный iLogger.
6342.54 6343.54 "Игорь Лабутин" Да.
6343.54 6351.94 "Игорь Лабутин" Имеет свои минусы, это понятное дело, что недоступно весь большой функционал, но в принципе хотя бы так уже жить хорошо.
6351.94 6358.54 "Анатолий Кулаков" Там действительно функционал логера это все-таки пять вот этих методов, которые логируют, вот это вот его
6358.54 6365.90 "Игорь Лабутин" основная работа. Тайминги все-таки удобно, понятно, что удобно написать using time debug или time info, что там еще есть.
6365.90 6374.30 "Игорь Лабутин" Но понятно, что enricher это в основном middleware и вот это все, именно вот эта невидимая часть, которую писать не надо.
6374.30 6393.06 "Анатолий Кулаков" У нас та же самая система, то есть во всех своих приложениях я придерживаюсь той же самой концепции, везде таскается абстрактный Microsoft Logger и он прокидывается даже в библиотеках, и его же используют сами микрософтовские фреймворки, и ISP-неты, и entity-фреймворки, и все подряд, поэтому он очень гармонично встраивается в существующую концепцию.
6393.06 6397.86 "Анатолий Кулаков" Serialog светится только в одном единственном месте, это в начале приложения, где идут все его настройки.
6397.86 6400.82 "Анатолий Кулаков" Enricher и, как ты сказал, логи и все такое.
6400.82 6413.02 "Анатолий Кулаков" Действительно, больше от него ничего не надо, если ты хочешь те же самые методы расширения, если ты хочешь те же самые тайминги, то к ним пишутся элементарно методы расширения, которые делают абсолютно то же самое уже для микрософтовского логера, это и все.
6413.02 6419.02 "Игорь Лабутин" Ну понятно, что внутри Serialog они, может быть, сделали бы это чуть-чуть более эффективно, но ладно, мы как бы...
6419.02 6430.46 "Игорь Лабутин" Если ваше логирование занимает вам очень много времени и влияет на перформанс приложения, наверное, тут не проблема, какой экстенджер-метод вы используете, наверное, вам нужно что-то посмотреть в чистоте ваших логов.
6430.46 6432.38 "Игорь Лабутин" Это точно.
6432.38 6443.38 "Игорь Лабутин" Давай пойдем дальше, на последнюю, наверное, такую большую темку, хотя она такая не очень большая, но, наверное, будет, я не знаю, сколько будет ее удобно воспринимать на слух, но мы попробуем.
6443.38 6462.98 "Игорь Лабутин" Короче, прошел очередной JetBrains Developer Ecosystem Survey, в 22 году подвели все итоги, и в блоге JetBrains вышла статья про результаты, выжимки из этого ecosystem обзора для Дотонатмира.
6462.98 6470.38 "Анатолий Кулаков" Я думаю, наши слушатели уже привычные, мы же каждый год этот обзор делаем, поэтому я думаю, сейчас они все циферки быстренько представят и графики нарисуют.
6470.38 6471.38 "Анатолий Кулаков" Не, ну погоди.
6471.38 6473.58 "Игорь Лабутин" Кое-кто даже перейдет по ссылочке и посмотрит.
6473.58 6479.74 "Игорь Лабутин" Погоди, я очень надеюсь, что с момента прошлого такого обзора у нас прибавилось, слушатели, они не такие привычные.
6479.74 6483.14 "Игорь Лабутин" А то если это все те же самые слушатели, они уже не так интересны.
6483.14 6489.86 "Игорь Лабутин" Я надеюсь, что есть кто-то новый, который не слушал прошлые обзоры всех этих серверов и всех наших замечательных процентов.
6489.86 6490.86 "Анатолий Кулаков" Ну ладно, давай на дело.
6490.86 6492.90 "Анатолий Кулаков" Хорошая тема, надо перепись как-нибудь устроить, да,
6492.90 6504.58 "Игорь Лабутин" но это, наверное, в следующем выпуске. Смотри, C#, был вопрос, я так понимаю, каким версии C# вы пользуетесь, и можно было выбирать несколько вариантов ответов, иначе проценты вообще никак не сходятся.
6504.58 6511.82 "Игорь Лабутин" Но, что интересно, C# 10 пользоваются отметили C# 10 50% ответивших, и это прям как-то много.
6511.82 6517.42 "Анатолий Кулаков" Ну, это хорошо, у нас всегда был adoption отличный, мне кажется, что он не падает.
6517.42 6529.26 "Игорь Лабутин" Дальше он, соответственно, потихонечку уменьшается, 9 пользуется 32%, 8 33, 7 24, 6 16 и 5 всем чем раньше, это 17%.
6529.26 6534.42 "Игорь Лабутин" Это очень много, там на самом деле в статье приводится сравнение с прошлым годом, если интересно, посмотрите.
6534.42 6543.78 "Игорь Лабутин" Примерно, я не помню, по-моему, adoption, короче, очень много народу переключилось с восьмёрки на десятку прыгнуло.
6543.78 6547.98 "Игорь Лабутин" То есть в прошлый раз лидировала восьмёрка, а теперь лидирует десятка.
6547.98 6552.14 "Игорь Лабутин" Ну, видимо, LTS опять же влияет, вот это всё, так что как-то…
6552.14 6558.46 "Анатолий Кулаков" Ну вот с другой стороны, не нужно путать, что новый язык, он совсем не требует нового фреймворка.
6558.46 6563.90 "Анатолий Кулаков" Поэтому если вы вдруг хотите на десятку, но вы при этом обязаны сидеть на каком-нибудь старом фреймворке, ничего вам не мешает.
6563.90 6566.10 "Анатолий Кулаков" Переключайтесь на десятку языка, оставайтесь на старом
6566.10 6572.10 "Игорь Лабутин" фреймворке. Да, таргетить вы должны, можете старый фреймворк, а использовать уже новый язык, да, так можно.
6572.10 6578.54 "Игорь Лабутин" Для там, есть тонкие фичи языка, типа, ну не знаю, что, у меня только спаны сейчас вспоминаются.
6578.54 6581.50 "Анатолий Кулаков" Какие-нибудь рефы и спаны, да, ну, скорее всего вам
6581.50 6585.50 "Игорь Лабутин" это не нужно. Скорее всего вам нужен паттерн-матчинг или ещё что-нибудь в таком духе.
6585.50 6598.62 "Игорь Лабутин" По статистике распределения, какими языками пользуются, значит, дотнет-разработчики, 99% ответили, что C#, 6% ответили, что Visual Basic дотнет, и только 3% ответили, что F#.
6598.62 6602.18 "Анатолий Кулаков" Да, F# никак не может даже Visual Basic умирающего догнать.
6602.18 6603.18 "Игорь Лабутин" Обидно.
6603.18 6610.18 "Игорь Лабутин" Да, там на самом деле в результатах были ещё всякие TypeScript и JavaScript, которые там по 30-35% занимали, но я их решил не упоминать.
6610.18 6619.86 "Игорь Лабутин" Фреймворки, ну, в смысле, кто на чём сидит, на дотнет-фреймворке, дотнет-корп, пятёрка, шестёрка и вот это всё.
6619.86 6631.46 "Игорь Лабутин" По сравнению, здесь будут цифры из прошлого года и этот год, значит, в прошлом году дотнет-фреймворку любых версий на него приходилось 62%, а ответивших в этом году уже 49%.
6631.46 6635.82 "Игорь Лабутин" То есть популярность дотнет-фреймворка неуклонно падает.
6635.82 6639.66 "Анатолий Кулаков" От большого фреймворка избавляются, переходят все на новенький модненький.
6639.66 6645.82 "Игорь Лабутин" Да, в дотнет-шестой отметили 47% ответивших, то есть довольно большой adoption.
6645.82 6646.82 "Игорь Лабутин" Ну, то есть LTS, видимо, не зря.
6646.82 6650.70 "Анатолий Кулаков" Да, да, это прям много, прям хорошо, отлично.
6650.70 6663.10 "Игорь Лабутин" Вот, дотнет-корп, это, видимо, подразумевается 3x и старше, было 66, опять же, видимо, потому что это был LTS, стал 43, тут, видимо, как раз уменьшило за счёт тех, кто прыгал на шестёрку сразу.
6663.10 6670.86 "Игорь Лабутин" А дотнет-пять тоже было 33, стало 24, уменьшается, тоже им перешли на шестёрку.
6670.86 6673.54 "Игорь Лабутин" И моно было 12, стало 10.
6673.54 6677.90 "Игорь Лабутин" То есть ещё довольно немало народу пользуется моно, но тоже начало уменьшаться.
6677.90 6684.02 "Анатолий Кулаков" Будем надеяться, что все не отваливаются куда-то далеко-далеко, а все всё-таки переходят на шестёрку.
6684.02 6692.10 "Игорь Лабутин" Ну да, ну, скорее всего, моно те, кто отвалился, это те, кто в качестве кроссплатформы пришёл просто на нормальный дотнет сейчас.
6692.10 6695.66 "Игорь Лабутин" Те, кто использовал моно именно для кроссплатформы, например.
6695.66 6696.66 "Игорь Лабутин" По EDE-шкам.
6696.66 6700.14 "Игорь Лабутин" Значит, по EDE-шкам ситуация следующая.
6700.14 6709.14 "Игорь Лабутин" У Visual Studio за последние три года проценты меняются как 65, 62, 54, то есть популярность Visual Studio потихонечку падает,
6709.14 6710.14 "Анатолий Кулаков" она всё ещё больше 50%.
6710.14 6714.14 "Игорь Лабутин" То есть Visual Studio теряет, да, получается? Да, 65, 62, 54.
6714.14 6715.14 "Игорь Лабутин" Интересно.
6715.14 6718.42 "Игорь Лабутин" То есть она теряет, она больше 50% пока занимает, но всё-таки теряет.
6718.42 6735.02 "Игорь Лабутин" Rider наоборот, за три года у него чиселки 20, 27, 33, то есть он растёт, процентов по 6 в год получается, то есть студия где-то процента по 3, ну нет, она кстати между 20 и 21 потеряла 3%, а между 21 и 22 потеряла 8%.
6735.02 6737.50 "Игорь Лабутин" Rider стабильно по 6-7% в год набирает.
6737.50 6741.98 "Игорь Лабутин" Если так продолжится, то в следующем году они должны сравняться.
6741.98 6742.98 "Игорь Лабутин" Ну посмотрим.
6742.98 6743.98 "Игорь Лабутин" Не уверен пока.
6743.98 6748.78 "Игорь Лабутин" Нет, в следующем не сравняются, между ними 20% разница, но в общем через пару лет сравняются.
6748.78 6755.62 "Игорь Лабутин" Visual Studio код довольно стабильный, 11, 9, 10%, ну и Visual Studio for Mac стабильнее не бывает по 2% каждый год.
6755.62 6757.98 "Игорь Лабутин" Видимо преданные фанаты так и сидят на нём.
6757.98 6761.66 "Игорь Лабутин" Или это команда разработчиков Microsoft ответила, я не знаю.
6761.66 6766.14 "Анатолий Кулаков" Скорее всего да, разработчики-тестеры Visual Studio for Mac, да.
6766.14 6767.14 "Игорь Лабутин" Она ещё нужна.
6767.14 6777.22 "Игорь Лабутин" Плагинчики для IDE, ну в основном это понятно, речь идёт о большой Visual Studio, там удивительно, но 47% не используют.
6777.22 6780.70 "Игорь Лабутин" Ну плагины здесь имелось в виду понятно всякие, а-ля ReSharper.
6780.70 6790.14 "Игорь Лабутин" То есть понятно, что есть там миллион плагинов, типа каких-нибудь там Markdown Editor, но здесь имелось именно в виду те, которые помогают в работе с C# кодом.
6790.14 6798.98 "Игорь Лабутин" 47% не используют ничего, 36% используют ReSharper, остальные там меньше 10% всякие там Codemade, ну и прочие такие.
6798.98 6804.14 "Игорь Лабутин" Visual Assist, я уже забыл все эти названия, даже не выписывал себе.
6804.14 6809.70 "Анатолий Кулаков" По сути у нас есть один плагин, это ReSharper, да, всё остальное, это настолько над ним отстаёт, что можно даже и не считать.
6809.70 6813.30 "Игорь Лабутин" Ну и грубо говоря пользуются треть, и почти половина пользуются ничем.
6813.30 6828.62 "Игорь Лабутин" В Unit тестировании распределение следующее, XUnit и NUnit примерно по 38%, в прошлом году они были ровно по 38, в этом году XUnit типа 39, но я думаю, что это просто погрешность измерения, можно считать, что они равны.
6828.62 6836.26 "Игорь Лабутин" Ну и где-то в хвосте плетутся MSTest и MSTest v2, причём MSTest больше, 14%, а v2 9% всего.
6836.26 6846.94 "Игорь Лабутин" Ну MSTest как-то не полетел, я думаю, что его используют только те, кто исторически его использует, либо те, кто, не знаю, на каких-нибудь курсах его научили, именно MSTest, ну вот он на нём и пишет.
6846.94 6851.06 "Анатолий Кулаков" Ну здесь никаких революций нет, поэтому странно ожидать какие-то изменения, да.
6851.06 6852.06 "Игорь Лабутин" Да.
6852.06 6870.26 "Игорь Лабутин" И последний вопрос был про то, ну понятно, поскольку это джетбрейнс, им интересно про свои тулы, был про то, как часто вы пользуетесь профайлерами, и тут интересно, что 75% в 74 сказали, ну и время от времени, нормально, три четверти народу считай иногда пользуются какими-то профайлерами, это прям больше, чем я ожидал.
6870.26 6886.22 "Анатолий Кулаков" Погоди, то есть ты хочешь сказать, что в Visual Studio чисто и без плагинов сидит 50% и 74% пользуются профайлерами, то есть те люди, которые не ставят плагин для улучшения, для продуктивности разработки, они пользуются профайлерами, что ты как-то не без них?
6886.22 6895.18 "Игорь Лабутин" Ну по математике получается так, ну послушай, ну что значит пользуются, вот смотри, ты когда-нибудь запускал голую Visual Studio без плагинов, да, и просто запустить стандартный там в отладку приложение?
6895.18 6898.42 "Анатолий Кулаков" Ну я обычно сразу ставлю ReSharper, поэтому исключено.
6898.42 6902.10 "Игорь Лабутин" А по-моему, кстати, ReSharper на это, может быть, даже не влияет.
6902.10 6909.70 "Игорь Лабутин" Современная Visual Studio, она тебе сразу начинает показывать график, там память ползёт туда, там эксепшены случаются, вот это всё.
6909.70 6913.94 "Анатолий Кулаков" Ну вот встроенный Visual Studio профайлер, вот этот я никогда не запускал.
6913.94 6914.94 "Анатолий Кулаков" Вот.
6914.94 6916.94 "Анатолий Кулаков" То есть я не пользуюсь, по сути, у меня отдельно есть профайлер.
6916.94 6923.18 "Игорь Лабутин" Это понятно, но вот, а он есть, и кто-то может сказать, о, я тогда там тыкнул пару раз, я пользовался профайлером.
6923.18 6924.18 "Игорь Лабутин" А, ну может быть.
6924.18 6927.94 "Игорь Лабутин" Так, может, тут, может быть, из этого ещё немножко чиселки куда-то подвигались.
6927.94 6942.62 "Игорь Лабутин" Но тем не менее, 20% ответило, что регулярно пользуюсь профайлером, то есть прямо, скажем так, типа не просто захотелось, а довольно на регулярной основе, и 6% ответили постоянно, по нескольку раз на дню.
6942.62 6947.62 "Игорь Лабутин" Ну это, видимо, те, кто оптимизирует, не знаю, что, ReSharper, Raider.
6947.62 6951.06 "Анатолий Кулаков" Ну 6% это тоже довольно много, представляешь, от всех разработчиков.
6951.06 6952.06 "Игорь Лабутин" Да, да, да, это многовато.
6952.06 6966.10 "Игорь Лабутин" Ну понятно, что это немножко, наверное, байз, да, такие вопросы, не знаю, насколько они сильно байз в пользу там тех, кто действительно там сеньоры, которые много занимаются таким, ну фиг знает, непонятно.
6966.10 6972.30 "Игорь Лабутин" Я, надо почитать полный отчёт для того, чтобы понять картинку по разработчикам, сколько там было всего народа и так далее.
6972.30 6987.70 "Игорь Лабутин" Ну, в общем, примерно такие чиселки для тутснек мира получаются, то есть я бы сказал, интересный тренд про студию и Raider, интересный тренд для меня, что так быстро адаптятся новые фреймворки и версии языка.
6987.70 7009.02 "Анатолий Кулаков" Да, это хорошо, мне тоже адаптацию началом понравился, в принципе, это не какой-то всплеск, он всегда был большой и из самых первых версий, я думаю, что это как раз таки заслуга и Microsoft, что она облюдет совместимость очень хорошо со старыми версиями, инструментарий отличный и, в общем, всё, что нужно для перевода, для переиспользования новых версий, всегда у нас работало прекрасно и продолжает работать тоже.
7009.02 7022.54 "Игорь Лабутин" Хорошо, ну и пойдём, наконец, к самой последней теме, возьмём кратенькую тему, наш традиционная тема про кратко о разном, собрали мы несколько ссылочек на интересные.
7022.54 7025.54 "Игорь Лабутин" Толь, начни, наверное, ты.
7025.54 7051.06 "Анатолий Кулаков" Да, прежде всего хотелось упомянуть о debug-encoded-text, это новая фича в последнем превью Visual Studio, я думаю, что каждый из вас знаком с debug-окошком и когда у вас есть какая-то текстовая переменная или поле текстовое, вы можете чпокнуть по кнопочке, посмотреть её содержимое и открывается такое окно, которое называется debugger-text-visualizer.
7051.06 7058.26 "Анатолий Кулаков" Ну, в принципе, это окно довольно примитивное, там формочка и внутри этой формочки просто текст многострочный.
7058.26 7061.26 "Анатолий Кулаков" И это всё, что вам нужно было до этого.
7061.26 7072.98 "Анатолий Кулаков" Теперь же Visual Studio расширила функциональность этого окошка и в этом окошке у нас появилось drop-down меню выпадающее, которое может творить просто чудеса.
7072.98 7081.90 "Анатолий Кулаков" Во-первых, это B64 encoder и decoder, то есть вы можете существующую строчку закодировать, а также, что, наверное, более практично, раскодировать.
7081.90 7096.02 "Анатолий Кулаков" Если к вам пришёл из интернета какая-нибудь строка, закодированная B64, обычно я лазил куда-нибудь в B64 online, декодер, запускал его, вставлял эту строчку, смотрел, что получается, приходил обратно.
7096.02 7099.58 "Анатолий Кулаков" Теперь это же можно сделать прямо из Visual Studio, из удобного окошка.
7099.58 7107.70 "Анатолий Кулаков" И точно такие же манипуляции можно сделать с URL-энкодингом, URL-декодингом и очень прекрасной штукой - это JVT-декодер.
7107.70 7112.82 "Анатолий Кулаков" Тоже незаменимая вещь вообще в работе, особенно если вы занимаетесь более-менее безопасностью.
7112.82 7126.90 "Анатолий Кулаков" Мне почему-то очень много в последнее время сталкивалось со всякими JVT-токенами, JOT-токенами, как модно говорить, и не может не радовать функциональность прям встроенного декодирования его в Visual Studio, это просто прелесть какая-то.
7126.90 7133.02 "Анатолий Кулаков" В общем, такое окошко нас ждёт, в превью оно уже есть, я думаю, что в ближайших релизах Visual Studio мы его тоже увидим.
7133.02 7139.50 "Анатолий Кулаков" Так, ещё мы нашли прекрасный GitHub-репозиторий.
7139.50 7143.62 "Анатолий Кулаков" Ну не то, чтобы он сильно от нас спрятался, просто хотелось бы, чтобы все другие о нём тоже знали.
7143.62 7146.66 "Анатолий Кулаков" Называется он ISP.NET Security OAuth Providers.
7146.66 7164.70 "Анатолий Кулаков" И как вы, наверное, догадались, в нём есть огромнейший список OAuth провайдеров, которые можно подключить к вашему ISP.NET приложению, и оно магическим образом станет поддерживать аутентификацию с помощью других различных социальных сетей.
7164.70 7176.70 "Анатолий Кулаков" Здесь, я уже сказал, их миллионы, но стоит упомянуть, какие-нибудь громкие из них это Amazon, Apple, Battle.net, что довольно хорошая сеть, и я думаю, многие знают, зачем она нужна.
7176.70 7181.42 "Анатолий Кулаков" Так, Discord, GitHub, GitLab, Mail.ru обязательно, Одноклассники, куда ж мы без бабулек.
7181.42 7185.62 "Анатолий Кулаков" Slack, StackExchange, Twitter, ВКонтакте есть, Яндекс.
7185.62 7188.42 "Анатолий Кулаков" К сожалению, искал госуслуги, так и не нашёл.
7188.42 7192.02 "Анатолий Кулаков" Сбербанка.ид тоже почему-то нет, но я думаю, прикрутим, сделаем.
7192.02 7206.82 "Анатолий Кулаков" В общем, полезный репозиторий, если вдруг вы используете его в провайдере, и вашим клиентам срочно не хватает какой-то нативной социалочки, где они обитают, то есть шанс легко и без всяких проблем прикрутить уже готовые тестированные провайдеры.
7206.82 7209.82 "Игорь Лабутин" Да, прекрасно.
7209.82 7239.92 "Игорь Лабутин" А последняя новость про то, что вышла очередной превью, третий по-моему, для Visual Studio for Mac, про которую мы говорили, что ей стабильно пользуются 2%, вот если вы входите в эти 2% или хотите в них внезапно войти, то завезли 2 новых изменения, это улучшение работы с Git, то есть теперь можно выбирать Git-бранч нормально в специальном Git-статус-баре, когда вы работаете с Solution, который находится в Git.
7239.92 7247.80 "Игорь Лабутин" И можно переключаться, можно смотреть, какой сейчас бранч, какие вообще бранчи есть, в общем, всячески работать с Git получше теперь стало.
7247.80 7262.84 "Игорь Лабутин" А дальше, кроме того, они улучшили довольно много всего в тестах плори, я так понимаю, что там были довольно большие тормоза и баги с поиском тестов и с тем, как они там все отображались и ранятся.
7262.84 7278.04 "Игорь Лабутин" Ну теперь как бы работает хорошо, специально не отмечать, что они улучшили Test Discovery для проектов, где используются wild карты в Nuget пакетах, ну и уменьшили UID light, так что все должно работать быстрее, лучше, сильнее, выше и так далее.
7278.04 7286.44 "Игорь Лабутин" Так что Visual Studio for Mac, но они потихонечку туда допиливают всякие разные фичи, становится Polymer получше, поинтереснее, надо будет как-то попробовать, может быть.
7286.44 7342.16 "Игорь Лабутин" Ну а на этом, я думаю, надо заканчивать, мы сегодня уже довольно долго сидим, по крайней мере, мы тут во время записи, посмотрим, во что это выглядит после обработки, но за этот подкаст мы успели обсудить обновленную и, может быть, не сильно измененную стратегию по поддержке разных зонад языков, дальше обсудили, какими коллекциями нужно пользоваться, если вы пишете API или даже просто пишете код, какие коллекции принимать, какие коллекции возвращать, если у вас вдруг старый код на геймфорумах, вы теперь можете его переделать на MVVM благодаря новым байдингам, которые появились в DotNet 7, если вы пишете логи, вы наверняка пишете логи, вы теперь точно знаете, как это делать правильно с точки зрения сериолога, узнали, какие тренды у нас в C# с точки зрения опроса от JetBrains, ну и посмотрели всякие разные мелкие новости про близняшки, которые могут вам интересны в повседневной работе.
7342.16 7344.48 "Игорь Лабутин" На этом, наверное, на сегодня всё.
7344.48 7353.92 "Анатолий Кулаков" Да, давай закругляться, вроде темп обсудили немного, подкаст получился большой, я надеюсь, что к следующему выпуску Microsoft сделает уже какие-то анонсы, иначе придётся нам до трёх часов расширяться.
7353.92 7358.72 "Игорь Лабутин" Ну мы найдём какую-нибудь большую длинную статью и будем её долго-долго обсуждать.
7358.72 7359.72 "Анатолий Кулаков" По ролям читать.
7359.72 7394.32 "Анатолий Кулаков" Ну ладно, всем большое спасибо, что да, сидели до этого момента, если вы вдруг очутились здесь, то, скорее всего, подкаст вам нравится, поэтому не забывайте делиться с ним, с друзьями, ставить нам лайки, если у вас есть какой-нибудь айфончик, вы жмакните нам плюсик или сердечки, что там у них, звёздочки на Вайтюнте, в Гугле тоже есть какие-то лайки, если у вас есть Яндекс, там тоже есть сердечки, поэтому ставьте нам приятные оценки, пишите приятные отзывы, ну или неприятные, если вдруг мы вызываем у вас какие-то негативные ассоциации, мы тоже всё будем учитывать.
7394.32 7398.48 "Анатолий Кулаков" И большое спасибо, что слушаете нас, поддерживаете нас, шарите среди своих друзей.
7398.48 7400.56 "Анатолий Кулаков" Всем до новых встреч, всем пока!
7400.72 7401.72 "Игорь Лабутин" Всем пока!
