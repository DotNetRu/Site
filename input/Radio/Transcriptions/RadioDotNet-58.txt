0.00 12.68 "Анатолий Кулаков" Приветствую всех, дорогие друзья, в эфире Радио.нет, выпуск номер 58.
12.68 15.84 "Анатолий Кулаков" В студии для вас сегодня будут Анатолий Кулаков
15.84 17.84 "Игорь Лабутин" и Игорь Лабутин. Всем привет!
17.84 22.24 "Анатолий Кулаков" Вначале, как всегда, хотелось бы поблагодарить наших постоянных помогаторов.
22.24 28.84 "Анатолий Кулаков" Это Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Илья и Егорий Самарин.
28.84 35.20 "Анатолий Кулаков" А также всех тех других, кто нам помогает на Boosty и не оставляет нас в трудные времена.
35.20 36.80 "Анатолий Кулаков" Большое спасибо, друзья!
36.80 48.72 "Анатолий Кулаков" А также спасибо всем, кто лайкает, шарает, комментирует, рассказывает про наш подкаст своим друзьям и всячески, по мере сил, поддерживает этот нелегкий труд.
48.72 50.80 "Анатолий Кулаков" Давай непосредственно к новостям.
50.80 56.64 "Анатолий Кулаков" Первая новость, как всегда, у нас пора о следнее время про релизы .NET Framework.
56.64 62.20 "Анатолий Кулаков" И к данному выпуску Microsoft не подкачал и выпустил целый релиз-кандидат первый.
62.20 68.88 "Игорь Лабутин" Да, как и обещали, они сказали, что прошлое превью было последним и теперь у нас есть релиз-кандидат один.
68.88 75.24 "Игорь Лабутин" Мы потихонечку движемся к собственному релизу, мы про это поговорим ближе к концу выпуска.
75.24 98.80 "Игорь Лабутин" И в этом релизе не так, чтобы много новых фич, они по мере того, как мы продвигаемся к релиз-кандидатам и непосредственно к релизу, понятное дело уменьшается количество фич, которые новые добавляются и больше происходит полировки каких-то, фиксы последних багов или не последних багов, решение, что какие-то баги будут затложены, какую-то функциональность нужно откатить.
98.80 102.52 "Игорь Лабутин" Так что каких-то революционных и новых штук не ждите.
102.52 103.52 "Игорь Лабутин" Но, тем не менее.
103.52 109.84 "Игорь Лабутин" Поддержан релиз-кандидат один будет в Visual Studio 17.4 Preview 2.
109.84 117.44 "Игорь Лабутин" И, как мы сказали, скоро будет, вообще говоря, .NET Conf 8-10 ноября.
117.44 119.84 "Игорь Лабутин" Это уже не так много, что бы осталось.
119.84 121.24 "Игорь Лабутин" Именно там будет The Religion.NET.
121.24 132.24 "Игорь Лабутин" Надо напомнить, что .NET 7 это не LTS-релиз, поэтому он будет поддержан только 18 месяцев, и мы все будем ждать .NET 8, который выйдет через год, и вот он уже будет новым LTS-ом на замену шестерки.
132.24 136.64 "Игорь Лабутин" Ну а пока посмотрим, что же нам принес .NET 7.
136.64 140.04 "Игорь Лабутин" Среди основных тем это, конечно же, Maui.
140.04 143.92 "Игорь Лабутин" В Maui добавили новый контролл для отрисовки карт.
143.92 156.92 "Игорь Лабутин" Дальше Microsoft поняли, по фидбэку или еще как-то, не знаю, что народу сильно не хватает Desktop Development, и поэтому они завезли некоторое количество фич, которые нужны прям конкретно для Desktop.
156.92 169.88 "Игорь Лабутин" То есть всякий контекст, менюшки поверх, по-моему, чуть ли не всех элементов возможных, Tooltip-чики, жесты, которые, мне немножко странно, но как у них было написано в статье, типа жесты, которые могут быть только на Desktop актуальны.
169.88 175.80 "Игорь Лабутин" Не знаю, какие жесты могут быть актуальны только на Desktop, но может на каких-нибудь Touch ноутбуках, вполне может быть.
175.80 182.04 "Игорь Лабутин" И самое интересное, завезли возможность контролировать размер и положение окошка.
182.04 185.96 "Игорь Лабутин" Раньше было нельзя, как я понял из статьи.
185.96 193.56 "Игорь Лабутин" Естественно, еще одной темой такой, топиком, важным во всем .NET 7 стал Cloud Native.
193.56 203.12 "Игорь Лабутин" То есть мы обсуждали такие фичи, как встроенная поддержка контейнеров, буквально, по-моему, в прошлом выпуске, или gRPC JSON-транскодинг.
203.12 214.08 "Игорь Лабутин" Вот эти все штуки, они продвигают это все дело .NET в ту область, в которой мы можем смело сказать, что он Cloud Native, и можно его использовать для любых Cloud Native приложений.
214.08 220.48 "Игорь Лабутин" Конечно же, важным кусочком является ARM64, про него сегодня будет отдельный раздел, ну и перформанс, куда же без него.
220.48 224.32 "Игорь Лабутин" Мы все помним статью Стивена Тауба про улучшение перформанса.
224.32 229.88 "Игорь Лабутин" Вот этой статьей дело не ограничилось, продолжается работа над перформансом и дальше.
229.88 242.92 "Игорь Лабутин" Что касается ASP.NET Core, там поинтереснее, в том смысле, что там все еще идут какие-то, ну скажем так, изменения, которые мы можем приравнять, можно сказать, практически к новым фичам.
242.92 249.16 "Игорь Лабутин" В Blazor в WebAssembly завели штуку под названием Dynamic Authentication Requests.
249.16 263.88 "Игорь Лабутин" Это, короче, штука, которая, как они говорят, поддерживает OpenID Connect прямо из коробки, out of the box, то есть вам практически вообще ничего не надо сделать, там пара строчек это все подключить и все будет работать с любыми внешними OpenID серверами, OpenID Connect серверами.
263.88 267.72 "Игорь Лабутин" И можно передавать там какие-то кастомные параметры теперь.
267.72 274.84 "Игорь Лабутин" Если вы как-то используете OpenID Connect в Blazor в WebAssembly, посмотрите статью повнимательнее, там будет написана деталь.
274.84 293.76 "Игорь Лабутин" Для навигации в Blazor теперь поддерживаются ивенты о том, что вы поменяли локейшн, локейшн в смысле внутри иерархии ваших окон, и, соответственно, это позволяет вам предупреждать пользователю, что он сейчас данные потеряет, ну все эти окошечки, там типа вы точно хотите закрыть окно или вкладку или что-нибудь в таком духе.
293.76 297.00 "Игорь Лабутин" Вот теперь это все можно делать в Blazor.
297.00 302.36 "Игорь Лабутин" Сильно улучшили дебаггинг для Blazor в Asmo, то есть всякие работают теперь JustMyCode.
302.36 308.32 "Игорь Лабутин" Если у вас используются async методы, куда же без них сейчас, то там теперь будут нормальные имена в ColdStake.
308.32 325.40 "Игорь Лабутин" Улучшили expression evaluation в студии, и кроме того, стали поддерживаться штуки из namespace и system diagnostics, то есть всякие там, я уже не помню, что там есть, кроме как output debug string или что-то в таком духе.
325.40 331.56 "Игорь Лабутин" Ну короче, всякие такие debug-related штуки из system diagnostics, они теперь поддержаны для Blazor в Asmo.
331.56 338.76 "Игорь Лабутин" Появился новый workload, который называется wasm-tools.net6.
338.76 343.48 "Игорь Лабутин" Это позволяет собирать проекты, которые таргетят .net6, используя 7 SDK.
343.48 347.00 "Игорь Лабутин" Вот без этого workload вы так делать не сможете.
347.00 350.88 "Игорь Лабутин" Отдельный workload wasm-experimental нужен для того, чтобы из Wasm дергать JavaScript.
350.88 360.24 "Игорь Лабутин" Ну короче, как вы видите, с Wasm огромная работа происходит, Blazor, Microsoft в него верит и пытается всячески сделать так, чтобы на нем было удобно и хорошо писать.
360.24 361.24 "Игорь Лабутин" Посмотрим.
361.24 365.32 "Игорь Лабутин" Для Kestrel тоже есть некоторые улучшения.
365.32 371.20 "Игорь Лабутин" Во-первых, у вас теперь есть доступ к полной цепочке сертификатов при валидации сертификатов.
371.20 377.56 "Игорь Лабутин" То есть вы можете проверить сертификат или еще как-то всю цепочку, а не только конечный.
377.56 389.44 "Игорь Лабутин" Для HTTP/2 улучшили скорость upload, простым изменением размера окна, размер буфера, размера окна из 128 кВт до 1 МБ, это какой-то мега прижат в скорости.
389.44 394.28 "Игорь Лабутин" И стали завозить очередные HTTP/3 импрувменты, мы про это тоже немножко сегодня поговорим.
394.28 409.76 "Игорь Лабутин" Помимо того, что мы раньше JRPC, JSON-транскодинг тоже завезли в фичу, теперь, по крайней мере в некотором ограниченном функционале, SPNet умеет генерировать Open API спецификацию по JRPC-эндпоинтам.
409.76 418.32 "Игорь Лабутин" То есть он JRPC транскодирует в JSON, ну в смысле выставляет JRPC-эндпоинты как JSON-эндпоинты и по ним же умеет генерировать Open API спецификацию теперь.
418.32 421.40 "Игорь Лабутин" То есть вы можете получить Open API спецификацию на ваш JRPC-контракт.
421.40 429.48 "Анатолий Кулаков" Интересно, а через Swagger UI можно зайти, ввести какие-нибудь данные, нажать кнопочку "Execute", чтобы JPC-эндпоинт
429.48 435.64 "Игорь Лабутин" дёрнулся? Ну по идее можно, потому что ты дёрнешь JSON-эндпоинт, а он автоматически превратится в JRPC, да.
435.64 445.88 "Анатолий Кулаков" Так что… Не, ну одно дело тебе на Read-only Open ID, Open API спецификацию сгенерить, это Swagger спецификацию сгенерить, а другое, всё-таки поддержать вызов.
445.88 448.28 "Анатолий Кулаков" Это может быть не совсем то же самое.
448.28 456.12 "Игорь Лабутин" Ну надо посмотреть, но по идее JSON-JRPC-транскодинг как раз была задумана в том, чтобы ты выставлял JRPC в качестве JSON-эндпоинтов.
456.12 462.08 "Анатолий Кулаков" В принципе да, если через транскодер это кидать, то он всё равно в HTTP-эндпоинт будет выставлять и транскодировать.
462.08 464.88 "Игорь Лабутин" Так что вполне может работать.
464.88 485.40 "Игорь Лабутин" Rate-limiting Middleware тоже получила некоторое количество улучшений, и если вы сидите на Mac-оси и используете кусочек .NET Tool под названием Dev-serts, то есть это управление сертификатами для разработчика, чтобы у вас всякие там на localhost оправились сертификаты, работали, что-то поясное, то там тоже завезли часть импрувментов.
485.40 489.60 "Игорь Лабутин" Посмотрите, возможно с этим станет работать получше, если вы это используете.
489.60 494.96 "Игорь Лабутин" EF Core с ним… Чем ближе к релизу, тем меньше каких-то мега-фичей.
494.96 515.76 "Игорь Лабутин" Ну и вообще EF Core в течение года в целом не сильно радует, скажем так, нас прям вот хайлайтами конкретных фич, в среднем они их… статьи про их релизы заключаются в том, что ну мы пофиксили очередные там 10, 20, 30, 100 багов, ну не обязательно багов, но issues на GitHub.
515.76 522.04 "Игорь Лабутин" И в этот раз примерно то же самое, 55 issues закрыто, ну как бы смотрите, детали там есть подробно, четкакие.
522.04 542.64 "Игорь Лабутин" Я по ним пробежался, ничего такого не увидел, на первый взгляд, но потом мне попался твит, он будет в шоу-ноутах про то, что наконец-таки в седьмом EF добавляются операции bulk_updates и bulk_deletes, то есть мы все знаем, что можно удалять по одному, ну либо можно удалить несколько раз, вызвать delete, delete, delete, delete, а потом save changes.
542.64 546.80 "Игорь Лабутин" Так вот теперь у нас есть прям методы bulk_updates и bulk_deletes.
546.80 550.48 "Игорь Лабутин" Я могу сейчас сожраться в названиях, посмотрите потом точнее.
550.48 571.52 "Игорь Лабутин" Там есть ряд ограничений, потому что для этих методов не будут трекаться изменения объектов, соответственно если у вас есть какой-то tracked entity ваш, то удалив его через bulk_delete, например, EF будет все еще считать, что внутри он трекает его.
571.52 580.12 "Игорь Лабутин" То есть в общем там есть некоторое количество тонкостей, если вы работаете таким образом с ним, но по крайней мере поддержка такая уже радует.
580.12 590.08 "Игорь Лабутин" То есть раньше такое можно было сделать, прям что были куча разных экстанженов к entity framework, которые по сути просто выполняли нужные несколько кодов, ну вот теперь часть из них перекачевывает в основной EF.
590.08 603.08 "Анатолий Кулаков" Слушай, а почему у них вообще-то данных так мало, если они такие базовые вещи не поддерживают официально и как бы в течение года даже не загнались для того, чтобы поддержать таких вещей побольше?
603.08 607.76 "Игорь Лабутин" Мне кажется они поддерживаются, но они как-то меньше пиарятся что ли.
607.76 614.28 "Игорь Лабутин" Ну то есть у них большой фокус на performance, это как бы о них было прям постулировано, что у нас фокус на performance.
614.28 622.08 "Игорь Лабутин" Мы про это обсуждали несколько выпусков назад, что в прошлый раз у них был performance select части, а сейчас был performance insert и delete части.
622.08 628.28 "Игорь Лабутин" Вот к частности bulk update, так сказать, в тему получились, ну согласно начальным планам.
628.28 639.52 "Игорь Лабутин" Но если сравнить например какой-нибудь .NET, не знаю, пятый мне кажется, когда мы с тобой также обозревали, там про EF Core были гораздо более развисистые статьи.
639.52 648.96 "Игорь Лабутин" Мы поддержали там такие-то миграции, мы там теперь вот такие атрибутики на классах теперь умеем, и вот такие функции мы теперь тоже умеем кодировать в SQL.
648.96 650.40 "Игорь Лабутин" А сейчас вот такого чего-то мало стало.
650.40 660.00 "Игорь Лабутин" То ли действительно вся команда перформансом увлеклась и особо фичи не пилит, то ли фичи такие маленькие местечковые, что про них как-то вроде отдельно писать странно.
660.00 665.32 "Анатолий Кулаков" Слушай, а расскажи мне, я знаю ты умный, ты вроде даже книгу по EF Core читал.
665.32 672.48 "Анатолий Кулаков" Вот я недавно столкнулся с такой проблемой, что мне нужно было сделать optimistic concurrency, то есть апдейт с условием.
672.48 678.96 "Анатолий Кулаков" Хочу проапдейтить, соответственно, запись в базе данных, где версия этой записи такая-то.
678.96 682.72 "Анатолий Кулаков" Если версия не такая, соответственно, апдейт бы ничего не сделал.
682.72 691.32 "Анатолий Кулаков" Вот такую элементарную штуку, которая, казалось бы, основа вообще всех основ, всех optimistic concurrency, вот её невозможно сделать через NTT Framework.
691.32 692.32 "Анатолий Кулаков" Это вообще нормально?
692.32 693.32 "Анатолий Кулаков" Нет, почему?
693.32 694.32 "Игорь Лабутин" Можно, можно, можно, можно.
694.32 698.48 "Игорь Лабутин" Это точно в книжке рассмотрено, надо будет почитать, вспомнить.
698.48 712.28 "Игорь Лабутин" Если тебе не вспомнить точно, как это делается, но в EF есть механизм, когда ты EF можешь объяснить, что вот это поле, это колонка, это ключ для optimistic concurrency и он при вот таких апдейтах будет сверять.
712.28 714.56 "Анатолий Кулаков" Вот, это совсем другой механизм.
714.56 723.80 "Анатолий Кулаков" Про этот механизм я тоже читал, это optimistic concurrency key, он основан на том, что если ты обновляешь и этот ключ там не совпадает, он тебе бросает exception.
723.80 732.60 "Анатолий Кулаков" Вот я такого не хочу, я не хочу exception, я хочу обновить и понять, например, сколько row зааффектилось, то есть сколько он обновил в итоге.
732.60 736.68 "Анатолий Кулаков" Я хочу сравнить там 0, 1 или может быть там 10, если у меня условие там слишком широкое.
736.68 740.20 "Анатолий Кулаков" Вот, без исключений и без вот этих дурацких его проверок.
740.20 745.52 "Игорь Лабутин" Без исключений, по-моему, обойтись можно, потому что, ну, не так.
745.52 765.12 "Игорь Лабутин" Ты по-моему не можешь обойтись совсем без исключения, но ты можешь внутрь EF запихнуть обработчик, который будет вызываться, вот я не помню, то ли сразу после выкидывания или то ли до выкидывания исключения, который позволит тебе захендлить этот кейс и что-то с ним сделать, ну в втором случае просто посчитать.
765.12 777.28 "Анатолий Кулаков" Ну и насколько я помню, что в этом случае, в этом подходе, когда ты делаешь на такой штуке, там поле должно быть определенное, то есть там, по-моему, то ли timestamp, то ли что-то в этом духе проставляется.
777.28 778.28 "Анатолий Кулаков" Ну это что-то такое, да?
778.28 783.32 "Анатолий Кулаков" Ты не можешь использовать, ты не можешь использовать свою версию, я обычно версию как бы использую осмысленную и понятную.
783.32 787.08 "Анатолий Кулаков" Вот я хочу свое поле со своей версией, со своим кондишеном произвольным.
787.08 795.96 "Анатолий Кулаков" Мне не обязательно кондишен должен, что это поле обязательно совпадает, у меня может быть кондишен, что это поле меньше или больше, допустим, и вот это уже невозможно сделать.
795.96 803.64 "Игорь Лабутин" Ну давай так, не будем говорить невозможно, потому что кажется, что EF Core, но про расширяемость, если не WCF, то где-то близко.
803.64 806.84 "Анатолий Кулаков" Ну опять же, ты всегда можешь, конечно, написать SQL руками.
806.84 813.08 "Игорь Лабутин" Не-не-не, я даже не про SQL, я именно про встраивание вот этого механизма оптимистик всяких concurrency и прочих.
813.08 817.04 "Игорь Лабутин" Я вполне допускаю, что там может быть какой-то интерфейсик, который это делает.
817.04 819.52 "Игорь Лабутин" Ну грубо говоря, и можно как-нибудь что-нибудь заинжектить.
819.52 823.32 "Игорь Лабутин" Но настолько глубоко я не копал, я не настолько профессионально использую EF Core.
823.32 828.24 "Анатолий Кулаков" Хорошо, давай вернемся к книге, может быть в комментах нам что-нибудь еще подскажут.
828.24 835.16 "Анатолий Кулаков" Короче, если уважаемые слушатели делали оптимистик конкуренции на EF Core, расскажите мне, как это хорошо делается.
835.16 836.48 "Игорь Лабутин" Окей, пойдем дальше.
836.48 843.00 "Игорь Лабутин" Как раз я упоминал, что у нас завезли улучшение по HTTP/3, вот давай расскажи, что у нас в HTTP/3.
843.00 850.52 "Анатолий Кулаков" Слушай, ну не то чтобы про HTTP/3, но на базе HTTP/3 нам завезли новый протокол, который называется WebTransport.
850.52 853.24 "Анатолий Кулаков" И об этом наша следующая статья и следующая тема.
853.24 861.48 "Анатолий Кулаков" Дело в том, что вместе с релиз-кандидатом первым заанонсировали экспериментальный протокол.
861.48 869.56 "Анатолий Кулаков" Интересен вообще сам факт, что у нас как бы релиз-кандидат, казалось бы, давайте стабилизировать, давайте тюнить перформанс, а тут вводят новый протокол, экспериментальный.
869.56 871.16 "Анатолий Кулаков" Ну вот так вот.
871.16 886.68 "Анатолий Кулаков" Я думаю, что, конечно же, этот протокол не допилят до основного релиза и он введен только потому, что наверное уже были готовы какие-то части и только потому, что он останется по-прежнему экспериментальной фичей, которую можно будет включать, в том числе и в релизе.
886.68 888.76 "Анатолий Кулаков" И тюнить его, естественно, продолжат еще и дальше.
888.76 893.88 "Анатолий Кулаков" Ну давайте подробнее разберемся вообще, что такое этот самый WebTransport.
893.88 908.16 "Анатолий Кулаков" Прежде всего, WebTransport астован на черновой спецификации, он до конца даже не заапрублен мировыми стандартами и он вполне похож на WebSockets, если вы общались с WebSockets.
908.16 921.40 "Анатолий Кулаков" Если вы не общались с WebSockets, то это такая своеобразная надстройка над транспортным уровнем, который позволяет соединять веб-браузер и ваш backend-сервер для того, чтобы организовать real-time коммуникацию.
921.40 930.36 "Анатолий Кулаков" Особенностью и WebTransport, и WebSockets является то, что они позволяют запускать несколько стримов на одно соединение.
930.36 937.76 "Анатолий Кулаков" Но если мы все-таки начинаем сравнивать, то у WebSockets есть небольшое ограничение.
937.76 947.44 "Анатолий Кулаков" Их наверное много, но принципиально вот это небольшое ограничение заключается в том, что WebSockets основывается на протоколе HTTP/2.
947.44 958.20 "Анатолий Кулаков" Они позволяют сделать несколько стримов в рамках одного соединения, но все эти стримы и вообще сами WebSockets работают по TCP и TLS.
958.20 967.08 "Анатолий Кулаков" Проблема этого подхода в том, что когда вы делаете в рамках одного соединения несколько стримов, они выстраиваются в определенную очередь.
967.08 974.44 "Анатолий Кулаков" И когда теряются пакеты, допустим, от одного стрима, то все остальные стримы тоже задерживаются.
974.44 981.16 "Анатолий Кулаков" Задерживаются они ровно настолько, насколько первый стрим потерял пакетов и через сколько ему их вернут.
981.16 986.96 "Анатолий Кулаков" Поэтому потеря пакетов в одном стриме может соэффектить соответственно все остальные стримы.
986.96 996.40 "Анатолий Кулаков" В WebTransport, в нашем новом протоколе, эту проблему решили тем, что WebTransport ассоциируется с HTTP/3 и QWIKI.
996.40 1000.68 "Анатолий Кулаков" А те в свою очередь используют UDP вместо TCP.
1000.68 1008.08 "Анатолий Кулаков" И там соответственно нет никаких досылок пакетов, там все управляется вручную и управляется более грамотно, чем стандартом TCP.
1008.08 1012.96 "Анатолий Кулаков" Ну, в нашем конкретном случае более подходящая стратегия.
1012.96 1021.40 "Анатолий Кулаков" И WebTransport таким образом тоже поддерживает несколько стримов в рамках одного единственного соединения, но при этом эти стримы независимы друг от друга.
1021.40 1031.92 "Анатолий Кулаков" Если какой-то один стрим тормозит, то все остальные шлются без всяких проблем и потери пакетов в каком-то одном направлении не влияют никак на всех других.
1031.92 1044.80 "Анатолий Кулаков" Например, хорошая иллюстрация применения этих стримов есть во всяких онлайн играх, когда вам нужно передавать некий стейт, некое состояние между браузером и бэкэндом.
1044.80 1049.12 "Анатолий Кулаков" Например, у вас есть голосовой чатик и там, где игроки обмениваются.
1049.12 1050.52 "Анатолий Кулаков" Это типичный пример стрима.
1050.52 1059.56 "Анатолий Кулаков" И также у вас есть стрим, например, с управлением, где игрушка вам передает специальные контрол-коды для того, чтобы управлять процессом.
1059.56 1066.32 "Анатолий Кулаков" Соответственно, если мы берем WebSocket, то у нас появляется сразу дилемма.
1066.32 1072.72 "Анатолий Кулаков" Мы можем установить одно соединение и при этом взять все стримы и засунуть в это одно соединение.
1072.72 1098.92 "Анатолий Кулаков" При этом мы сделаем таким образом следующую ошибку, что когда у нас один стрим начинает терять пакеты, например, когда разговор между игроками теряет пакеты, в этот момент у нас может тупить сама игра, потому что теряется контроль, теряется команда управления в стриме контролов, что не очень хорошо.
1098.92 1109.08 "Анатолий Кулаков" Или же мы можем поднять несколько коннекций и в каждую коннекцию пустить свой тип стримов, что, конечно, немножко решает проблему, но опять же у нас открывается много коннекций.
1109.08 1120.36 "Анатолий Кулаков" Это довольно истощаемый ресурс, довольно редкий, довольно дорогой и что, в свою очередь, может привести к абсолютно другим проблемам, другого порядка абсолютно.
1120.36 1134.80 "Анатолий Кулаков" Если же мы для решения этой проблемы используем наш новый веб-транспорт, то вы всего лишь на все можете установить одно соединение и это одно соединение обеспечит вас абсолютно всеми теми же плюсами, которые давал бы WebSocket только при многих соединениях.
1134.80 1152.68 "Анатолий Кулаков" В рамках одного соединения у вас будут несколько стримов и проблемы в одном стриме, потеря пакетов, например, в голосовых сообщениях никак не повлияет на другие стримы, которые передают или другие сообщения голосовые или передают контроль над самой игрой.
1152.68 1154.88 "Анатолий Кулаков" Что, соответственно, прекрасно.
1154.88 1165.52 "Анатолий Кулаков" Чтобы попробовать поэкспериментировать с этим новым протоколом в вашей свежей последней сборочке в RC1, вам нужно совершить небольшие приседания.
1165.52 1168.60 "Анатолий Кулаков" Во-первых, это разрешить экспериментальные фичи.
1168.60 1172.52 "Анатолий Кулаков" Делается это с помощью специальных флажков и модификации css-прош файла.
1172.52 1175.64 "Анатолий Кулаков" Об этом можно, напоминаю, почитать подробнее в статье.
1175.64 1191.48 "Анатолий Кулаков" Затем вам нужно настроить, соответственно, ваш хост, чтобы он слушал HTTP/3 протоколы, но чтобы он мог работать по HTTP/3 и, соответственно, определить в коде, каким образом Kestrel будет реагировать на вот эти новые веб-транспорт-соединения.
1191.48 1199.28 "Анатолий Кулаков" Также сделать обработчик для сессии, написать клиента и обработать непосредственно сами стримы.
1199.28 1203.24 "Анатолий Кулаков" Сделать стримы, записать стримы, зафлажить стримы и все в этом духе.
1203.24 1215.16 "Анатолий Кулаков" Сейчас в RC это все сделано довольно так, чопорно, через какую-то лямбу, через замыкание, но, скорее всего, в будущем это прилепят к каким-то более понятным хабам, контроллерам или чему-то еще.
1215.16 1225.84 "Анатолий Кулаков" У разработчиков в планах уже прикрутить это к какой-то прозрачной технологии типа SignalR, чтобы для конечных пользователей это все было прозрачно и понятно.
1225.84 1240.16 "Анатолий Кулаков" Еще один интересный кейс, если вы будете локально запускать, это то, что Kestrel Development Certificates, они не подходят к данному протоколу, к данному веб-транспорту из-за его определенных требований.
1240.16 1250.72 "Анатолий Кулаков" Поэтому в статейке вы можете найти код, как сгенерить свой собственный сертификат с подходящими параметрами и который можно уже использовать непосредственно локально для отладки и для ваших тестов.
1250.72 1256.16 "Анатолий Кулаков" Авторы также любезно предоставляют нам на GitHub два приложения.
1256.16 1266.68 "Анатолий Кулаков" Эти приложения показывают, как в интерактивном режиме и в Console-based режиме работать с сервером и клиентом по протоколу веб-транспорта.
1266.68 1271.12 "Анатолий Кулаков" Это довольно интересно, очтиво, посмотрите, если для вас эта тема актуальна.
1271.12 1284.72 "Анатолий Кулаков" Вот такой новый протокольчик внезапно попал к нам в релиз кандидат первый и который обещает нам в будущем хорошую и безблокировочную реал-тайм коммуникацию между браузером и сервером.
1284.72 1293.60 "Игорь Лабутин" Ну, вообще интересно, потому что HTTP/3, мне кажется, пока тоже не то, чтобы сильно задоптили.
1293.60 1301.88 "Игорь Лабутин" Даже HTTP/2 далеко не везде есть, мне кажется, еще до сих пор, а мы уже про HTTP/3 и какие-то новые протоколы.
1301.88 1319.52 "Анатолий Кулаков" Видишь, они там не стремятся их по очереди как бы внедрять, они скорее всего, HTTP/2 пойдет как переходный протокол, а HTTP/3 как уже совсем новый, поэтому если кто-то делает что-то совсем новое, вот как, например, игрушки браузерные, то они скорее всего даже на HTTP/2 смотреть не будут, они сразу с первого пойдут на третий.
1319.52 1322.64 "Игорь Лабутин" Ну, тоже верно, да.
1322.64 1324.40 "Игорь Лабутин" Наверное, может быть и так.
1324.40 1327.32 "Игорь Лабутин" Ну, зависит опять же, что браузеры будут поддерживать.
1327.32 1332.36 "Игорь Лабутин" Тут проблема-то в том, что даже браузеры, HTTP/2 тоже не все, ну, хотя вроде начали как-то поддерживать.
1332.36 1337.00 "Анатолий Кулаков" Сейчас все браузеры, это скорее всего Хром, поэтому Хром поддерживает, поэтому я думаю, с этим проблем
1337.00 1340.00 "Игорь Лабутин" не будет. Хорошо, пойдем дальше тогда.
1340.00 1344.12 "Игорь Лабутин" Дальше у нас по планам очередные перформанс-импрувменты.
1344.12 1357.00 "Игорь Лабутин" В DotNet 7 мы обсуждали отдельно большую статью Стивена Тауба, как я уже сегодня упоминал, про перформанс-импрувменты в целом, а сейчас вышла отдельная статья про то, какие перформанс-импрувменты в DotNet 7 завезли для ARM64.
1357.00 1360.16 "Игорь Лабутин" И там своя отдельная песня.
1360.16 1370.24 "Игорь Лабутин" Во-первых, довольно большая часть статьи посвящена методологии, вообще зачем они делали это и какими средствами они этого достигали, так сказать, какие цели ставили.
1370.24 1378.56 "Игорь Лабутин" Цель у них на самом деле простая, это сделать так, чтобы на ARM64 перформанс был примерно похож на x64.
1378.56 1388.52 None Ну и естественно путем ускорения ARM64, а не замедления x64, потому что на x64 DotNet довольно неплох, довольно быстро, поэтому хочется, чтобы на ARM он был таким же.
1388.52 1392.64 "Игорь Лабутин" А вторая цель, она такая немножко второстепенная, но тоже важная.
1392.64 1406.00 "Игорь Лабутин" Это про более прозрачные рекомендации и более прозрачное формирование ожидания от того, что произойдет с вашим приложением, если вы его перенесете на ARM.
1406.00 1417.88 "Игорь Лабутин" Ну потому что ты просто берешь, перекомпилируешь под другую архитектуру и вроде как оно может начать работать быстрее, начать работать медленнее, или какие-то паттерны начнут работать медленнее или быстрее, потому что архитектура процессора другая.
1417.88 1428.20 "Игорь Лабутин" Вот цель, собственно, всех этих измерений и импрувментов тоже в том числе понять вообще для них самих, авторов фреймворка, а как же он себя ведет при смене архитектуры.
1428.20 1446.20 "Игорь Лабутин" И в частности они говорят, что для этого они используют ряд бенчмарков, хоть это не микробенчмарки, прямо скажем, это несколько продуктов, которые они используют для того, чтобы понять стало ли быстро или медленно.
1446.20 1461.52 "Игорь Лабутин" Для них идеальный бенчмарк это как раз-таки кусок кода или приложения, которое представляет собой нормальный обычный промышленный код, который легко на самом деле выполнить, потому что есть продукты, которые представляют хороший промышленный код, но их замучаешься выполнять.
1461.52 1468.12 "Игорь Лабутин" А им нужно что-то простое, простой продукт, который работает на всех платформах и при этом довольно легко исполняется.
1468.12 1471.56 "Игорь Лабутин" Поэтому у них сформировался некоторый финальный лист бенчмарков.
1471.56 1480.28 "Игорь Лабутин" Первый это проект, называется Benchmark Games, это там несколько ну довольно стандартизированных бенчмарков, которые они могут запускать на разных платформах.
1480.28 1482.80 "Игорь Лабутин" Tech Empower, куда же без него.
1482.80 1485.32 "Игорь Лабутин" Как ни странно, в бенчмарки входит Bing.
1485.32 1489.88 "Игорь Лабутин" Не то чтобы это продукт… Bing это интересный бенчмарк, да.
1489.88 1494.44 "Игорь Лабутин" Он может запуститься быстро на всех платформах, но тем не менее это бенчмарк.
1494.44 1500.04 "Игорь Лабутин" Дальше два совершенно нормальных продукта, которые как раз попадают в категорию «легко запустить» это ImageSharp и Paint.net.
1500.04 1501.04 "Игорь Лабутин" Ну это два продукта.
1501.04 1505.92 "Анатолий Кулаков" Блин, они же тестируют не только время запуска, то есть как можно протестировать Paint.net?
1505.92 1507.76 "Анатолий Кулаков" Где там бенчмарки, кроме времени запуска?
1507.76 1510.76 "Игорь Лабутин" Я не понимаю, что это можно померить.
1510.76 1525.92 "Игорь Лабутин" Потребление памяти, возможно, какие-то сценарии, то есть они, возможно, прогоняют там какие-то сценарии, не знаю, нарисовать что-то, там заоткрыть файлик большой, не знаю, применить к нему какие-то трансформации, что там Paint.net умеет, не знаю, в Grayscale перевести, что-то сделать, ещё что-нибудь, потом сохранить файлик и выйти из Paint.
1525.92 1529.24 "Анатолий Кулаков" И посмотреть сколько… Ну ладно, то есть такие UI-тесты уже пошли какие-то, да?
1529.24 1532.80 "Игорь Лабутин" Они не столько UI, сколько это просто, ну вот то, что будет делать конечный пользователь.
1532.80 1541.36 "Игорь Лабутин" И вот как бы на x64 эта процедура занимает, не знаю, там 10 секунд, да, вот, ну открыть, там трансформировать, закрыть, сохранить, закрыть.
1541.36 1544.72 "Игорь Лабутин" А на ARM она будет занимать, не знаю, 30 секунд, ну явная фигня.
1544.72 1556.56 "Игорь Лабутин" Понятно, что если она будет занимать тоже 10 или там 11, ну тут уже как бы окей, одна секунда, возможно, это влияет вообще, ну общий комп там, да, поведение.
1556.56 1559.68 "Игорь Лабутин" Именно поэтому у них есть ещё 4600 примерно микробенчмарков.
1559.68 1567.36 "Игорь Лабутин" То есть продукт это такой, просто посмотреть, как пользователь это видит, но есть ещё микробенчмарки, конечно, отдельные.
1567.36 1579.44 "Анатолий Кулаков" Ну хорошо, то есть комплексы подошли, так и про микробенчмарки мы оптимизируем, ты уже по конкретному юзкейсам пользователей продуктов, прям целых систем, сервисов, интересно, да.
1579.44 1585.68 "Игорь Лабутин" Да, дальше есть огромнейший, собственно, раздел про то, что делали в рантайме.
1585.68 1588.92 "Игорь Лабутин" На самом деле, практически вся статья это про то, что сделали в рантайме.
1588.92 1601.64 "Игорь Лабутин" В рантайме, соответственно, пофиксили определение L3 КШ, потому что на ARM он не тривиально определяется, пофиксили thread pool scaling, он тоже не совсем корректно работал на ARM архитектурах.
1601.64 1614.24 "Игорь Лабутин" Внезапно на ARM не были нормально поддержаны операции типа атомиков, ну то есть interlock exchange, теперь они компилируются в нормальной инструкции и адекватно поддержаны.
1614.24 1615.88 "Игорь Лабутин" Там точно дотнет работал?
1615.88 1619.72 "Игорь Лабутин" Ну он работал, но как бы медленнее.
1619.72 1625.52 "Игорь Лабутин" То есть там оно компилировалось в эмуляцию, грубо говоря, атомика, который на самом деле был очень медленным из нескольких конструкций.
1625.52 1629.32 "Игорь Лабутин" Сейчас они компилируют то ли в одну, то ли в две, вот сейчас не буду с удовольствием врать.
1629.32 1643.20 "Игорь Лабутин" Дальше в ARM компах, как ты может быть знаешь, бывают разные ядра разного качества, одни быстрые, другие, как там у Apple, одни fast, другие performant, или как-то так они забавные делили.
1643.20 1651.04 "Анатолий Кулаков" Ну да, которые могут во время больших нагрузок включаться, а некоторые могут во время никаких нагрузок включаться и экономить при этом батарейку.
1651.04 1655.32 "Игорь Лабутин" Да, и одна из больших проблем была в том, а что возвращать в environment.processorcount.
1655.32 1658.32 "Игорь Лабутин" Наверное, общие суммы этих.
1658.32 1661.12 "Игорь Лабутин" А возвращалась на самом деле нет.
1661.12 1669.24 "Игорь Лабутин" Короче, вот эти группы, они объединялись в affinity группы, и тебе в процессе возвращалась размер твоей affinity группы.
1669.24 1681.52 "Игорь Лабутин" Поэтому, если ты запустился, грубо говоря, во время, когда у тебя комп в среднем или сервер простаивает, он запускался на энергосбегающих ядрах, ты там получал, не знаю, у тебя 20 ядер.
1681.52 1687.40 "Игорь Лабутин" Потом ты перезапускал приложение, а он попадал в другую affinity группу, у тебя там типа 16 ядер или 40 ядер.
1687.40 1689.88 "Игорь Лабутин" Ну, то есть, короче, нестабильно, непредсказуемо.
1689.88 1691.04 "Игорь Лабутин" Теперь стало предсказуемо.
1691.04 1702.24 "Анатолий Кулаков" Вообще, надо признать, что в дотнете как-то очень плохо с этим совсем, именно с ядрами, affinity группами, гипертрейдингом, и там активные ядра, сляпящие ядра и так далее.
1702.24 1708.00 "Анатолий Кулаков" Конечно, хотелось бы какую-то более развесистую структуру, которая могла бы все это описать, и программа под это все подстроится.
1708.00 1710.28 "Игорь Лабутин" Ну, как?
1710.28 1714.12 "Анатолий Кулаков" Ну, потому что сейчас приходится дергать какие-то нативные API для того, чтобы всю эту информацию выяснить.
1714.12 1716.24 "Анатолий Кулаков" А часто тебе это надо?
1716.24 1718.00 "Анатолий Кулаков" Не часто, но приходилось, сталкивался.
1718.00 1727.96 "Игорь Лабутин" Интересно, я не сталкивался, то есть мне никогда не надо было настолько детально знать, что же там железо снизу работает, как оно там расположено, сколько процессоров.
1727.96 1728.96 "Игорь Лабутин" Ну, ладно.
1728.96 1735.44 "Игорь Лабутин" Естественно, какие-то улучшения в библиотечках завезли, ну, код пооптимизировали и так далее.
1735.44 1747.28 "Игорь Лабутин" И, конечно же, наибольшие улучшения в CodeGeni я даже не буду сейчас просматривать всю статью, в смысле, рассказывать все улучшения, просто берите статью, это самое большое разделство во всей статье.
1747.28 1754.80 "Игорь Лабутин" Все, что наисправляли в CodeGeni, там, понятное дело, это основа оптимизации перформанса под арм.
1754.80 1788.40 "Игорь Лабутин" Помимо, собственно, рантайма, улучшился на самом деле тулинг, ну, не столько улучшился, все мы знаем про Sharp Lab, ну, я надеюсь, что вы знаете про Sharp Lab, если не знаете, знайте, есть такой сайт sharplab.io, он позволяет взять кусок кода на C#, туда записать его, ну, в смысле, вы туда пишете кусочек кода на C#, и он его либо декомпилит в EL, в Intermediate Language, либо он его может прямо в Assembler декомпилировать, но только для архитектуры AMD64, ну, или x86, там вот, по-моему, и так, и сяк можно.
1788.40 1790.36 "Игорь Лабутин" А для арма там нету.
1790.36 1791.36 "Игорь Лабутин" Вот.
1791.36 1806.48 "Игорь Лабутин" Но теперь они завезли поддержку, есть такой сайт gotbolt.org, обычно он использовался для такого рода работы с плюсами, но вот теперь туда завезли поддержку дотнета, и там как раз можно посмотреть на disassembly для ARM64.
1806.48 1813.56 "Игорь Лабутин" Ну, либо используйте экстенджер для Visual Studio, от Егора Богатого, он тоже умеет.
1813.56 1816.32 "Анатолий Кулаков" В сам Sharp Lab они не могли завести такую поддержку?
1816.32 1826.28 "Игорь Лабутин" Вроде как нет, я так понимаю, что Sharp Lab то ли на журе, то ли на чем-то, и там то ли нет пока арма, ну, короче, я не знаю.
1826.28 1833.28 "Анатолий Кулаков" Ну, пусть выставят API какой-нибудь, пусть он сходит в соседний сервис, но там главное, чтобы конечный пользователь был доволен, или чтобы ему там десяток инструментов
1833.28 1838.52 "Игорь Лабутин" заводить. Ну, может, когда-нибудь и завезут, просто там, видимо, было проще всего и быстрее, потому что там уже вроде
1838.52 1841.72 "Анатолий Кулаков" как был ARM. Понятно, ленивец и дармоеды.
1841.72 1866.48 "Анатолий Кулаков" Ну, ладно, слушай, ARM это хорошая платформа уже не только для десктопов, но и для серверов, то есть серверы тоже, Amazon прекрасно продаёт армовские, которые и электричество меньше жрут, и говорят, что работают быстрее, и вообще это красотень, и если дотнет будет себя прекрасно чувствовать на всех платформах, в том числе на ARM, это, естественно, большой плюс, и может быть, даже плюс в деньгах будет для тех, у кого есть большие и большие сервисы.
1866.48 1869.00 "Игорь Лабутин" Пойдём дальше, да.
1869.00 1877.64 "Анатолий Кулаков" Так, из новомодных классиков ARM оптимизации хочется поговорить про что-нибудь старое, доброе, знакомое, например, про систему рандом.
1877.64 1881.28 "Анатолий Кулаков" Как ты думаешь, сможем мы хорошую тему системы рандома вытащить?
1881.28 1886.28 "Игорь Лабутин" Ну, 50 на 50, или сможем, или не сможем, рандом покажет.
1886.28 1891.36 "Анатолий Кулаков" Ладно, давай посмотрим, если это хороший рандом с нормальным распределением, то да.
1891.36 1894.28 "Анатолий Кулаков" И поможет нам в этом Andry Log.
1894.28 1902.44 "Анатолий Кулаков" Вот, внезапно наткнулся на поведение рандомов, разное поведение рандомов в различных версиях фреймворков, и решил с нами поделиться.
1902.44 1917.24 "Анатолий Кулаков" В принципе, оно всё довольно известно, но так как классик очень популярный, использует его практически, мне кажется, все, но не все могут знать о его специфическом поведении в различных параллельных мультитрейдинговых задачах.
1917.24 1928.40 "Анатолий Кулаков" Поэтому не грех будет повторить, а для кого-то даже узнать о том, а что же именно вас поджидает, как только вы начинаете использовать стандартный система рандом, и как от этого защититься.
1928.40 1938.24 "Анатолий Кулаков" Как я уже сказал, классик довольно старый, он появился у нас ещё с первого .NET фреймворка, ну, то есть, по сути, всегда был с нами, и используют его абсолютно все.
1938.24 1943.76 "Анатолий Кулаков" Но мало кто знает, что на самом деле этот классик ни разу не трейдсейф по дефолту.
1943.76 1945.80 "Анатолий Кулаков" Что это значит?
1945.80 1952.36 "Анатолий Кулаков" Это значит, что когда вы работаете параллельно с инстансом этого класса, то у вас могут возникнуть кое-какие проблемы.
1952.36 1973.20 "Анатолий Кулаков" Нужно сразу договориться, что все или большинство из известных проблем были решены в .NET 6, и для того, чтобы их избежать, в вашем новом коде рекомендуется, как только вы перейдёте на .NET 6 или больше, появилась новое статическое свойство - random.shared.
1973.20 1985.36 "Анатолий Кулаков" И вот, обращаясь к этому shared экземпляру, shared instance, вы можете вызывать стандартный метод next или что вам там угодно, и вам будут возвращаться стандартные значения.
1985.36 1998.84 "Анатолий Кулаков" Вот это рекомендуемый способ, и он работает, и практически никаких проблем из тех, которые мы будем сегодня обсуждать, у вас не возникнет, если вы будете использовать этот random.shared из 6 фреймворка.
1998.84 2006.04 "Анатолий Кулаков" Во всех наших приложениях мы будем придерживаться примерного snippet.
2006.04 2009.16 "Анатолий Кулаков" Попробуйте представить это в голове, описываем код.
2009.16 2028.44 "Анатолий Кулаков" Итак, у нас есть параллель for, который принимает количество, сколько параллельных итераций мы должны запустить, и в качестве следующего аргумента он принимает лямбду, которая как раз таки декларирует собой тот делегат, который нужно будет запустить.
2028.44 2051.88 "Анатолий Кулаков" Вот если мы, например, сделаем параллель for от 0 до 10, и в качестве делегата мы воспользуемся строчкой random_shared_next, то есть сгенерим по сути следующее случайное int-овое значение из стандартного статического свойства, и выведем его в консольку здесь же, мы, соответственно, получим в консоли большой-большой список рандомных значений.
2051.88 2060.24 "Анатолий Кулаков" Все эти значения будут прекрасны, все хорошо, и это то, как должен работать нормальный рандом, как вы ожидаете, чтобы это, соответственно, у вас было.
2060.24 2066.08 "Анатолий Кулаков" Как я уже сказал, в Dota 6 все так и работает, как вы предполагали, и никаких проблем нет.
2066.08 2086.44 "Анатолий Кулаков" Здесь еще одну уговорочку стоит сказать, что мы сейчас говорим только про стандартный системы рандом, это никак не относится к криптографическому рандому, поэтому если вам нужна криптография, безопасность, security, то вам нужно смотреть в класс System Security Cryptography Random Number Generator.
2086.44 2091.64 "Анатолий Кулаков" Это специальный рандомер, который нужен именно для криптографии.
2091.64 2104.72 "Анатолий Кулаков" У него там уже повышенная энтропия, у него там уже специальные методы для генерации более распределенных и более защищенных, соответственно, байтиков, битиков, и, соответственно, он работает намного медленнее.
2104.72 2110.12 "Анатолий Кулаков" Про него мы и сегодня говорить не будем, может быть, как-нибудь коснемся в другой раз.
2110.12 2114.92 "Анатолий Кулаков" Продолжаем про наш любимый системы рандом.
2114.92 2124.36 "Анатолий Кулаков" Прежде всего давайте окунемся и посмотрим, а что было до .NET 6, и до .NET 6, как вы, наверное, догадываетесь, был .NET Core и .NET 5.
2124.36 2126.44 "Анатолий Кулаков" Попробуем провести тот же самый эксперимент.
2126.44 2153.92 "Анатолий Кулаков" Но так как у нас там нет этого статического свойства Shared, мы просто-напросто создадим рандом, instance этого экземпляра нашего рандома, и точно так же в параллель .NET 4 запустим цикл из 10 итераций, и уже непосредственно внутри делеганта возьмем instance, который мы чуть выше создали, вызовем там next, и выведем на консольку получимое значение.
2153.92 2158.04 "Анатолий Кулаков" Соответственно, instance мы будем использовать один и тот же для всех итераций.
2158.04 2161.64 "Анатолий Кулаков" Прежде всего, если вы запустите этот тест, то, скорее всего, не увидите никаких проблем.
2161.64 2166.12 "Анатолий Кулаков" Но при этом данный код все еще является нетредсейв.
2166.12 2185.64 "Анатолий Кулаков" И именно вот эта нетредсеивость его, она заключается в том, что как только несколько потоков пытаются дернуть random next, то есть получить следующее int значение одновременно, есть такая задекларированная бага, даже задекларированное поведение, что рандом возвращает нолик.
2185.64 2187.72 "Анатолий Кулаков" Вот просто-напросто нолик.
2187.72 2194.36 "Анатолий Кулаков" Для того, чтобы нам воспроизвести это в нашем делегате, его достаточно очень просто модифицировать.
2194.36 2201.40 "Анатолий Кулаков" Внутри вот этих 10 итераций, внутри этого делегата просто-напросто запустим цикл от 0 до 10 тысяч.
2201.40 2206.24 "Анатолий Кулаков" И в этом цикле от 0 до 10 тысяч просто дернем random next.
2206.24 2213.60 "Анатолий Кулаков" А дальше попробуем в конце не просто вывести эти циферки, а посчитать, сколько в этих циферках есть ноликов.
2213.60 2217.36 "Анатолий Кулаков" То есть, сколько random next вернул нам все-таки обычных ноликов.
2217.36 2223.84 "Анатолий Кулаков" Вот, и если вы уже выведите на консоль количество ноликов, то результат вас довольно сильно удивят.
2223.84 2230.20 "Анатолий Кулаков" Потому что ноликов может быть как совсем чуть-чуть, как и несколько тысяч, как и 10 тысяч ноликов.
2230.20 2237.48 "Анатолий Кулаков" То есть, это значит, что все 10 тысяч get next, которые мы запустили в цикле, вернули нам нулевые результаты.
2237.48 2243.96 "Анатолий Кулаков" Это значит, что абсолютно всегда random возвращает нулевые результаты в определенных случаях.
2243.96 2246.16 "Анатолий Кулаков" В общем, это страшно, господа.
2246.16 2250.52 "Анатолий Кулаков" Но вот такая вот задекларированная бага есть.
2250.52 2256.76 "Анатолий Кулаков" Давайте подумаем, как же мы можем этого избежать, обезопасить нас от подобных ситуаций.
2256.76 2257.76 "Анатолий Кулаков" Все очень просто.
2257.76 2265.92 "Анатолий Кулаков" Как вы, наверное, заметили, в предыдущем примере мы создали один-единственный экземпляр рандома, который переиспользовался всеми итерациями.
2265.92 2270.64 "Анатолий Кулаков" Достаточно всего лишь навсего сделать новый random для каждой итерации.
2270.64 2272.52 "Анатолий Кулаков" То есть, мы немножко меняем наш делегат.
2272.52 2281.00 "Анатолий Кулаков" Мы засовываем new random не сверху нашего делегата, мы его замыкаем, а засовываем его внутрь делегата.
2281.00 2285.16 "Анатолий Кулаков" То есть, он теперь крутится от нуля до десяти.
2285.16 2286.88 "Анатолий Кулаков" Каждую итерацию создается новый random.
2286.88 2293.96 "Анатолий Кулаков" И здесь мы уже точно так же бежим по 10 тысячам наших get random и запускаем и считаем, сколько нуликов получится.
2293.96 2303.68 "Анатолий Кулаков" Как вы, наверное, догадались, что при том условии, что у нас нет расшаренных random, соответственно, у нас нет никаких thread-save проблем.
2303.68 2309.00 "Анатолий Кулаков" И соответственно, вот этих нуликов, важных нуликов при одновременном доступе их совсем не будет.
2309.00 2312.00 "Анатолий Кулаков" То есть, мы все-таки решили поставленную задачу.
2312.00 2316.00 "Анатолий Кулаков" Но здесь у нас возникли немножко другие трудности.
2316.00 2324.56 "Анатолий Кулаков" Как только мы внесли random внутрь вот этих циклов, внутрь итераций, у нас начало создаваться множество экземпляров класса random.
2324.56 2332.40 "Анатолий Кулаков" И соответственно, множество этих экземпляров могут порождать множество garbage-коллекторов, что не очень хорошо.
2332.40 2341.00 "Анатолий Кулаков" Эту проблему легко решается, если мы, допустим, будем создавать экземпляр random один на thread.
2341.00 2345.60 "Анатолий Кулаков" Это легко сделать, если мы заведем поле и обозначим его атрибутом thread_static.
2345.60 2354.60 "Анатолий Кулаков" thread_static как раз-таки и дает нам возможность переиспользовать random в конкретный один random в конкретном одном инстанси thread.
2354.60 2365.44 "Анатолий Кулаков" То есть, для различных thread у нас будут созданы различные инстансы random, но их будет не больше, чем, соответственно, количество thread.
2365.44 2369.88 "Анатолий Кулаков" Это обычно меньше, чем количество итераций.
2369.88 2372.16 "Анатолий Кулаков" Поэтому это очень хорошая оптимизация.
2372.16 2377.56 "Анатолий Кулаков" И каждый thread будет доступаться только до своего инстанса.
2377.56 2389.84 "Анатолий Кулаков" Автоматически это значит, что у нас не будет никаких multi-threading доступов и, соответственно, не будет никаких multi-threading багов.
2389.84 2395.60 "Анатолий Кулаков" Если мы так сделаем, то, соответственно, баги все уйдут, у нас все станет хорошо.
2395.60 2421.64 "Анатолий Кулаков" И обычно, чтобы не огородить такие thread_static атрибуты с приватными полями в каждом классе, очень удобно просто-напросто сделать новый классик, обернуть все thread_static поля, засунуть туда же random, обернуть это все в какие-то понятные методы и выставить наружу, чтобы все остальные могли им пользоваться довольно прозрачно и не зная, что там внутри происходит.
2421.64 2437.40 "Анатолий Кулаков" Единственная рекомендация от автора, если вы будете делать такой классик, не возвращайте как раз экземпляр того random, который вы сгенерировали, специфичного для этого thread, то есть для thread_static поля.
2437.40 2449.40 "Анатолий Кулаков" Потому что пользовательский код вполне может взять этот random и передать его в другой thread, в другое замыкание или как-то каким-то образом неявно, опять же, доступиться к нему из другого thread.
2449.40 2460.68 "Анатолий Кулаков" Гораздо лучше выставить тот же самый метод next и передать его текущему инстанцу, который 100% будет выполняться в том thread, из которого вы его попросили.
2460.68 2465.72 "Анатолий Кулаков" В общем, это такая хорошая оптимизация, которая даст вам понятный API, а не только избавит от багов.
2465.72 2474.76 "Анатолий Кулаков" Если вы думали, что это все, то вы ошиблись, потому что еще был у нас такой замечательный штук, как .NET Framework большой.
2474.76 2478.64 "Анатолий Кулаков" И в .NET Framework большом было еще больше проблем.
2478.64 2503.88 "Анатолий Кулаков" В частности, одна из самых известных проблем в большом фреймворке заключалась в том, что при каждом вызове newRandom, то есть когда вы создавали экземпляр, instance, но вот этого классика random, сгенерился новый классик, и в качестве начального значения, seed, у этого классика бралось значение системных часов.
2503.88 2512.00 "Анатолий Кулаков" Если кто не знает, что random можно инициализировать неким начальным значением, так называемым seed.
2512.00 2521.08 "Анатолий Кулаков" И если вдруг вы этот seed передадите один и тот же, то все последующие цифры, которые будут выходить из next, они будут одинаковыми.
2521.08 2523.28 "Анатолий Кулаков" То есть в этом есть весь смысл seed.
2523.28 2528.64 "Анатолий Кулаков" Если вам это не нужно, соответственно, вы должны засунуть какое-то рандомное абсолютное значение.
2528.64 2540.72 "Анатолий Кулаков" В данном случае использовались как раз системные часы, потому что казалось, что системные часы довольно гранулярны для того, чтобы получать различный seed и при этом не упираться в одни и те же значения.
2540.72 2548.56 "Анатолий Кулаков" Но, как мы можем прочитать из документации, системные часы-то в принципе и гранулярны, но не настолько, насколько вам может понадобиться.
2548.56 2571.92 "Анатолий Кулаков" Например, если вы параллельно начнете создавать экземпляры класса random, как в нашем случае, параллель 4, 10 циклов, и внутри этого параллель 4 создаете новый классик, новый random, и у него дергаете getNext, то есть получение следующего интового числа.
2571.92 2591.20 "Анатолий Кулаков" И если вы скомпилируете этот классик под 461, то вы получите тот эффект, когда классики random будут создаваться в параллельных потоках одновременно, и соответственно у них будет один и тот же seed, который возьмется из системных часов.
2591.20 2598.12 "Анатолий Кулаков" И соответственно это значит, что они будут выдавать вам одни и те же числа, одни и те же инты.
2598.12 2610.08 "Анатолий Кулаков" В частности, в нашем примере, если вы запустите всего лишь навсего 10 параллельных потоков, то вы увидите, что все эти 10 параллельных потоков схватили 4 различных седа.
2610.08 2626.60 "Анатолий Кулаков" То есть, если они схватили 4 различных седа, то сколько бы random-ных чисел вы не выводили, они всегда будут в пределах тех 4 седов, которые мы только что с вами захватили, и которые эти random будут использовать в течение всей своей жизни.
2626.60 2629.60 "Анатолий Кулаков" Решение тут довольно примитивное.
2629.60 2637.68 "Анатолий Кулаков" То есть, так как я уже сказал, вот этот seed, который передается внутрь random по-хорошему, должен быть случайным.
2637.68 2646.52 "Анатолий Кулаков" Решение простое – создайте random, который будет выдавать вам случайный seed для того, чтобы породить следующий экземпляр random.
2646.52 2650.84 "Анатолий Кулаков" Вот таким примитивным способом эта задача довольно базово решается.
2650.84 2658.36 "Анатолий Кулаков" И опять же, этот хак можно внедрить в классик, если вы вдруг делаете такой враппер для совместимости со старыми фреймворками.
2658.36 2662.04 "Анатолий Кулаков" Более того, именно такой подход используется по дефолту в .NET Core.
2662.04 2674.52 "Анатолий Кулаков" То есть, там тоже создается random, который как раз-таки и обеспечивает seed во все новые инстансы всех других random, а не используется больше System Clock – системные часы.
2674.52 2677.44 "Анатолий Кулаков" Вот такие интересные баги.
2677.44 2683.84 "Анатолий Кулаков" Здесь я хочу еще раз напомнить, что если у вас есть .NET 6, то используйте в нем random.shared.
2683.84 2687.52 "Анатолий Кулаков" Это спасет вас практически от всех описанных проблем.
2687.52 2695.76 "Анатолий Кулаков" И еще, если вдруг вам тема random очень интересна, то я настоятельно рекомендую доклад Стэна Драбкина, который он делал на .NEXT.
2695.76 2698.56 "Анатолий Кулаков" Называется он How Random is Random?
2698.56 2702.52 "Анатолий Кулаков" И Pitfalls of Random in .NET 6.
2702.52 2707.12 "Анатолий Кулаков" Там Стэн подробно проходится по всем random, которые были во всех версиях .NET.
2707.12 2718.84 "Анатолий Кулаков" И самое интересное, что он не останавливается на утверждении, что в .NET 6 random прекрасен, он его тоже разносит в клочья и показывает, что random даже в .NET 6 недостаточно идеален.
2718.84 2723.24 "Анатолий Кулаков" Там будут проблемы не только с повторяющимися ноликами, там намного интереснее.
2723.24 2728.12 "Анатолий Кулаков" Он рассматривает и энтропию, и повторяемость, и баги, и все-все-все в этом духе.
2728.12 2729.44 "Анатолий Кулаков" В общем, доклад интересный.
2729.44 2746.20 "Анатолий Кулаков" Если вы захотите посмотреть что-то легенькое перед сном, при этом практичное, полезное, и то, что вас удивит в старых добрых классах, в том коде, который вы давно используете, то вот доклад Стэна это то, что нужно.
2746.20 2747.20 "Игорь Лабутин" Звучит прекрасно.
2747.20 2752.04 "Игорь Лабутин" Ну то есть, да, используйте random.shared и живите на последних .NET.
2752.04 2755.08 "Игорь Лабутин" Хорошая краткая рекомендация из всего вышеперечисленного,
2755.08 2757.88 "Анатолий Кулаков" мне кажется. В принципе, работает для любых классов, да?
2757.88 2761.04 "Игорь Лабутин" Ну да, берите последний фреймворк и там, наверное, все будет хорошо.
2761.04 2762.44 "Игорь Лабутин" Пойдем дальше.
2762.44 2794.92 "Игорь Лабутин" Помимо последних фреймворков, естественно, у нас потихонечку двигается в сторону релиза и разных всяких версий Visual Studio, и вышла новая свежая версия Visual Studio 17.4 Preview 2, в которой на самом деле добавили много всяких разных штук, которые, ну, к сожалению, в превью, то есть я, например, не живу на превью версиях, поэтому до меня они будут ехать еще довольно долго, но посмотрим, посмотрим.
2794.92 2803.52 "Игорь Лабутин" Во-первых, конечно же, прогресс по ARM64, всяческие улучшения ARM64 должны потихонечку туда заезжать.
2803.52 2822.76 "Игорь Лабутин" Дальше в Git завезли одновременно работу с несколькими репозиториями, не знаю, зачем вам это может быть надо, но вдруг надо, то есть, например, одну и ту же операцию вроде как можно сделать с несколькими репозиториями теперь, там, pool какой-нибудь или push, не знаю.
2822.76 2837.12 "Игорь Лабутин" Если вы работаете с GitHub или с Azure DevOps, то теперь, когда вы пишете comment к commit, там подтягиваются автоматические пишизы по номеру, ну, как в GitHub, вы решеточку пишете, там номер сразу появляется, можно выбрать такой же, теперь в Visual Studio.
2837.12 2847.88 "Игорь Лабутин" Еще быстрее стал Git branch switch, улучшили то, что называется all in one search, которое вызывается по ctrl-t, там теперь получше все ищется.
2847.88 2856.04 "Игорь Лабутин" Добавили самую полезную фичу, помнишь, мы обсуждали про, по-моему, это была 22 студия, когда там иконки завезли или эмоции, эмоджи, что-то в таком духе.
2856.04 2857.84 "Игорь Лабутин" Короче, теперь в студию завезли звуки.
2857.84 2862.60 "Анатолий Кулаков" Звуки, неужели кто-то пользуется вообще звуками?
2862.60 2870.52 "Игорь Лабутин" Да, выяснилось, что вроде как в прошлой даже версии, как я понял, завезли звуки на три события.
2870.52 2883.16 "Игорь Лабутин" Когда ты в дебаге достигаешь breakpoint, когда у тебя при компиляции появляется warning или error, ну, типа компиляция закончилась, она типа вот, мол, обрати на меня внимание, компиляция закончилась.
2883.16 2889.72 "Игорь Лабутин" Короче, эта штука получила позитив фидбэк, согласно статье, и поэтому теперь они добавили новые звуки.
2889.72 2892.56 "Игорь Лабутин" Но место добавления для меня какое-то странное.
2892.56 2905.64 "Игорь Лабутин" Короче, звук появляется, когда ты в режиме сравнения файлов, ну, например, в GTA, перед коммитом ты сверяешь, если ты ставишь курсор на строчку, которая отличается.
2905.64 2907.44 "Анатолий Кулаков" Для этого тебе нужен звук.
2907.44 2915.92 "Анатолий Кулаков" Не, я понимаю звуки, которые нужны, когда ты чего-то ждешь, ты там отвлекся, допустим, тот же самый breakpoint, там ловятся какие-то часы, и бац, у тебя вот он поймался.
2915.92 2918.28 "Анатолий Кулаков" Ну, понятно, что тебе нужно как-то сообщить.
2918.28 2922.84 "Анатолий Кулаков" Я, например, лично ставил какие-нибудь попапы, когда у меня заканчивалась компиляция C++ проекта.
2922.84 2928.44 "Анатолий Кулаков" Как-то он действительно компилируется там целый час, ты идёшь, занимаешься своими делами, и было бы неплохо узнать, когда он закончится.
2928.44 2934.12 "Анатолий Кулаков" Но когда это какой-то интерактивный процесс, когда ты ставишь мышкой на какую-то строчку, зачем тебе звук?
2934.12 2936.28 "Анатолий Кулаков" Ты и так уже здесь, ты понимаешь, что ты делаешь.
2936.28 2938.24 "Игорь Лабутин" Не знаю, но подтверждаю, что ты не промазал.
2938.24 2939.24 None Окей.
2939.24 2940.24 "Игорь Лабутин" Я не знаю, да.
2940.24 2944.72 "Игорь Лабутин" Ну, короче, вот посмотрим, насколько позитивный фидбэк будет на такую фичу.
2944.72 2960.84 "Игорь Лабутин" Дальше добавили превью Markdown, то есть если вы помните, мы обсуждали решение Мэтта Кристенсена, Markdown, он назывался ли как-то так, теперь превью Markdown есть встроенная в студию.
2960.84 2963.68 "Анатолий Кулаков" Надеюсь, они его поглотили, они заново написали своё?
2963.68 2965.24 "Игорь Лабутин" Да фиг их знает, непонятно пока.
2965.24 2971.76 "Игорь Лабутин" Дальше, ну в принципе Мэтт, он же вроде как в Майкрософте, поэтому ну наверное он как-то кодом поделился.
2971.76 2978.84 "Анатолий Кулаков" Не, ну подожди, он-то пишет, наверное, open source свободное от работы времени на рабочем компьютере и не подглядывая в рабочий код?
2978.84 2980.52 "Анатолий Кулаков" Как там всё положено по лицензии?
2980.52 2989.40 "Игорь Лабутин" Да, но у него экстенджер, скорее всего, под метом, и поэтому в рабочее время взять свой экстенджер и переписать его, подглядывая в код под метом, он может.
2989.40 2991.08 "Игорь Лабутин" Поэтому фиг его знает, не знаю.
2991.08 2996.04 "Игорь Лабутин" Но мы немножко ещё про экстенджеры попозже поговорим, там непонятно, тема с рабочим или нерабочим временем.
2996.04 2999.92 "Игорь Лабутин" Может быть и в рабочее время, но это на самом деле делает.
2999.92 3006.68 "Игорь Лабутин" Дальше, помните мы обсуждали, что у нас был новый AI-нумер, по-моему, визуалайзер, который позволяет коллекцию посмотреть?
3006.68 3010.24 "Игорь Лабутин" И там можно было фильтровать, сортировать, короче, вот это все дела.
3010.24 3011.24 "Игорь Лабутин" Теперь такой же завезли в дататейбл.
3011.24 3018.04 "Игорь Лабутин" Если вы до сих пор пользуетесь дататейблами, то теперь у него есть клёвый визуалайзер, который прям табличками будет показывать, что там в этом дататейбле лежит.
3018.04 3028.96 "Игорь Лабутин" Дальше, если вы в студии поймали эксепшн и вам нужно посмотреть call stack, то теперь у вас прямо в окошке эксепшна будет call stack, как вы привыкли в дебаггере полностью.
3028.96 3034.40 "Игорь Лабутин" Так, очередные улучшения Unit Test Performance.
3034.40 3041.20 "Игорь Лабутин" Там быстрее ищет тесты, быстрее исполняет их, потому что они оптимизировали коммуникацию с этим тестранером.
3041.20 3048.28 "Игорь Лабутин" Так, Inline Rename Controller, ну, шарперов и райдеров этим не удивишь.
3048.28 3053.08 "Игорь Лабутин" Интересная опция, вот есть предположение, зачем она может быть.
3053.08 3059.56 "Игорь Лабутин" Теперь можно задизейблить поддержку Source Link и встроенных этих Embedded Sources в CDB-шке?
3059.56 3075.12 "Анатолий Кулаков" Ну, во-первых, это может быть для безопасности, я не удивлюсь, если может там какую-нибудь дыру заэксплуатировать, которая выполнит тебе код или начнет тебя обнаруживать, например, тащить Source Link из злонамеренного сервиса, а ты там уже можешь затрекать какую-то активность.
3075.12 3083.16 "Анатолий Кулаков" Во-вторых, обычно это долго, когда ты тащишь Source Link, загрузка может занимать многие-многие минуты и может кому-то это не нравиться.
3083.16 3096.60 "Игорь Лабутин" Согласен, и плюс, ну, оно, конечно, там все гарантирует технически, наверное, что чексумы совпадут и так далее, но иногда надежнее довериться дезассемблеру и посмотреть на реальную длельку, которая исполняется.
3096.60 3097.60 "Игорь Лабутин" Да, наверное.
3097.60 3106.80 "Игорь Лабутин" Ну, в общем, теперь есть такая опция, ну и если вы занимаетесь C++ вдруг и почему-то слушаете наш подкаст, то там C++ тоже завезли.
3106.80 3120.04 "Игорь Лабутин" Примерно параллельно, вот тут я что-то не очень понял, но вышло Visual Studio for Mac 17.4 Preview 2.1, то есть у нас теперь превью тоже минорной версии имеют.
3120.04 3122.04 "Игорь Лабутин" Превью минорной версии, ну, допустим.
3122.04 3133.08 "Игорь Лабутин" Да, то есть я не очень понял, как бы, куда делась версия для Windows 2.1, ну, как бы, куда тут делась, ладно.
3133.08 3144.12 "Игорь Лабутин" Итак, там завезли всякие улучшения в дебаггинге, там теперь есть кнопочка Single Click to Restart, ну, то есть типа рестарт дебаггинг заново.
3144.12 3158.08 "Игорь Лабутин" Дальше, ну, как сказать, улучшение, то, что они называют Shell, то есть во всей этой оболочке студии можно там таскать окошечки, сайт-бай-сайт эдитеры теперь ставить, вот это все.
3158.08 3171.56 "Игорь Лабутин" В самих эдитеров появились улучшения, то есть там он понимает подсветки всяких C# фич типа 11, типа там Rowstring и Literals и всякие другие, не будет на них ругаться.
3171.56 3178.76 "Игорь Лабутин" Ну и теперь Visual Studio for Mac можно поставить даже не включая Rosetto.
3178.76 3190.08 "Игорь Лабутин" Это слой эмуляции для Mac'ов на M1, чтобы он эмулирует AMD64 и позволяет, соответственно, запускать код, который был раньше под Intel скомпилирован, на M1.
3190.08 3192.64 "Игорь Лабутин" Теперь все, Visual Studio Rosetto не требует.
3192.64 3206.20 "Анатолий Кулаков" Ну, вообще позор, что до самого этого времени требовало, потому что .NET вроде и раньше нормально на армии мог компилиться и запускаться, а студия полностью зависит только от .NET, на котором она работает, то есть какого черта только сейчас.
3206.20 3216.16 "Игорь Лабутин" Ну вот, да, при этом отдельно отмечено, что некоторые компоненты, например Mobile Development, все еще требуют Rosetto.
3216.16 3222.24 "Анатолий Кулаков" Ну да, наверное используются какие-то нативные библиотеки или что-то в этом духе, которые все еще нужны слой эмуляции.
3222.24 3230.48 "Игорь Лабутин" Да, короче вот, ну и да, семерка, соответственно, DotentMaui, вот это все, там есть.
3230.48 3237.84 "Игорь Лабутин" Так что заходите, смотрите, это была студия 17.4, Preview 2 или Preview 2.1, смотря под каким углом посмотреть.
3237.84 3239.84 "Игорь Лабутин" То есть с какой стороны считать.
3239.84 3240.84 "Игорь Лабутин" Да.
3240.84 3244.00 "Игорь Лабутин" Ну ладно, что ты там говорил про экстеншены?
3244.00 3252.56 "Игорь Лабутин" Да, экстеншены, про экстеншены прям выделили отдельно темы, потому что, как выяснилось, это как-то прошло немножко мимо нас.
3252.56 3258.72 "Игорь Лабутин" У нас, оказывается, до текущего момента шла новая фаза работы с Visual Studio экстеншенами.
3258.72 3273.44 "Игорь Лабутин" То есть, короче, они переделывают то, как у Visual Studio работает модель вообще экстеншенов, и оказывается шла фаза номер один, где были представлены новые API для редакторов, в смысле, новая API редактора, которая позволяла писать линкеры и форматоры.
3273.44 3276.28 "Игорь Лабутин" А раньше нельзя было, что ли?
3276.28 3278.40 "Игорь Лабутин" Как раньше работали форматоры и линкеры?
3278.40 3280.80 "Игорь Лабутин" Можно, но в смысле это новые API.
3280.80 3284.84 "Игорь Лабутин" Ну, как не знаю, у тебя там… Чем вам старая не угодила, расскажи.
3284.84 3287.56 "Игорь Лабутин" Сейчас, мы доберёмся, чем она не угодила.
3287.56 3290.28 "Игорь Лабутин" Так вот, сейчас у нас началась фаза два.
3290.28 3300.56 "Игорь Лабутин" Чего вообще происходит с точки зрения угодила/не угодила?
3300.56 3305.96 "Игорь Лабутин" Во-первых, что позволяет, что будет позволено теперь, когда вот фаза два завершится до конца.
3305.96 3312.00 "Игорь Лабутин" Вот она сейчас началась, я не очень понимаю, в каком состоянии все ли API доступны, но тем не менее, она началась.
3312.00 3318.92 "Игорь Лабутин" Во-первых, теперь у нас для написания экстендеров используется, как у них это называется, WPF-based remote UI framework.
3318.92 3333.28 "Игорь Лабутин" Я никогда не писал экстенджеры, я не знаю, на чем они писались раньше, было ли это WPF или не WPF, но тем не менее, сейчас это всё так же, WPF-based вроде как, но важное упоминание, что на remote.
3333.28 3335.96 "Игорь Лабутин" Экстенджер теперь out of process.
3335.96 3338.96 "Анатолий Кулаков" Они уже не помещаются в 64-разрядную студию.
3338.96 3342.16 "Игорь Лабутин" Видимо, я не знаю, короче, они out of process.
3342.16 3345.36 "Игорь Лабутин" Это первая фича, изменение большое.
3345.36 3351.04 "Игорь Лабутин" Второе большое изменение, экстенджеры теперь могут генерить кастомный tool window.
3351.04 3364.80 "Игорь Лабутин" То есть, насколько я понимаю, раньше экстенджеры могли встраиваться в существующий tool window, ну там, не знаю, добавлять кнопочки в какой-нибудь там build output, там еще что-нибудь в таком духе, но экстенджеры не могут генерировать свое tool window.
3364.80 3368.88 "Анатолий Кулаков" Да посмотри на решапера, там этих tool window штук 100 своих собственных.
3368.88 3372.16 "Игорь Лабутин" По папам, да, а tool window?
3372.16 3373.16 "Анатолий Кулаков" Почему по папам?
3373.16 3377.64 "Анатолий Кулаков" Ну вот любое окошко, которое там коннектится к краям, это и есть tool window.
3377.64 3380.64 "Игорь Лабутин" Ну, сейчас, погоди, дай я подумаю.
3380.64 3382.96 "Игорь Лабутин" Я решапер так давно не видел.
3382.96 3383.96 "Игорь Лабутин" Давай пример.
3383.96 3389.76 "Анатолий Кулаков" Ну, пример там, find usage те же самые, типа shift F12, который тебе список всех usage дает.
3389.76 3390.76 "Игорь Лабутин" Да, согласен.
3390.76 3395.76 "Игорь Лабутин" Вообще непонятно, то есть, либо они были прям какие-то…
3395.76 3401.60 "Анатолий Кулаков" Ну и вообще любой экстенджер, если запустить такой более-менее серьезный, он всегда создавал свое какое-то окошко, там невозможно было отбежать.
3401.60 3404.80 "Игорь Лабутин" Непонятно, они прям показывают, что это прям big deal, big deal.
3404.80 3407.88 "Игорь Лабутин" Что типа раньше вообще никак нельзя было, не знаю.
3407.88 3414.44 "Игорь Лабутин" Ладно, я не буду врать, я небольшой специалист, но вот типа такая штука у них теперь есть, как они говорят.
3414.44 3436.20 "Игорь Лабутин" И типа, если вам очень надо, то все еще можно делать in-proc экстенджеры, ну в смысле, что вы пишете свой экстенджер и ему просто указываете, что вот вообще-то он out-of-proc, ну если писать его, вы можете как будто он out-of-proc, но при инсталляте в студию поставить галочку, что он типа in-proc, и он будет запускаться in-proc, ну или при сборке, чтобы типа плавно мигрировать.
3436.20 3446.96 "Игорь Лабутин" То есть вы сначала все переписываете, пока у вас есть части, которые зависят от in-proc API, вы пока его держите in-proc, только все переписали на новый API, можно просто снять галочку, и он начнет работать out-of-proc.
3446.96 3456.60 "Анатолий Кулаков" Слушай, может вот эта концепция tool window, она актуальна, когда у тебя extension в out-of-process, ну то есть по сути ты создаешь удаленное окно, и вот этого может раньше там не было.
3456.60 3462.28 "Анатолий Кулаков" А теперь ты можешь удаленные окна, которые понимает Visual Studio и может их пинить, соответственно, куда угодно.
3462.28 3470.28 "Игорь Лабутин" Ну, кстати, может быть, действительно, и out-of-proc штука, ну да, действительно, out-of-proc сложно создавать окошко в студии.
3470.28 3472.92 "Анатолий Кулаков" Ну да, да, то есть все-таки другой процесс вообще
3472.92 3475.80 "Игорь Лабутин" такой. Вот, может быть, дело в этом, да.
3475.80 3484.64 "Игорь Лабутин" И, соответственно, недавно добавили поддержку ARM64 в extension, то есть теперь можно писать extension для ARM64 студии.
3484.64 3524.56 "Игорь Лабутин" Вот, и возвращаясь к Мэтцу Кристенсену, у меня есть ощущение, что ему сейчас выдали какую-то новую работу, значит, вида, а давай мы фичи, которые вроде как, наверное, хотят пользователи Visual Studio, мы не просто будем собирать на вот этом портале, как там, vote.microsoft, не помню, как называется, ну, короче, там, где можно голосовать за фичи, а будем делать что-то более умное, и Мэтц сейчас, короче, фигачит экстенджеры, как не в себя, со словами, типа, а вот такая вот штука, а вот давайте вот так еще попробуем, типа, вам понравится, не понравится, если, типа, понравится, мы эту фичу внесем в основную студию.
3524.56 3531.72 "Анатолий Кулаков" Ну да, то есть идея хорошая, давайте перестанем голосовать, когда там уже по 10 лет голосуют за одну и ту же фичу, и, наконец, сделаем ее.
3531.72 3548.38 "Игорь Лабутин" Вот, и вот он, короче, сделал недавно буквально три экстенджера, ну, там, знаешь, это, типа, причем выглядело примерно так, типа, он там, условно, утром пишет там в твиттере, типа, чуваки, а было бы вам интересно экстендер, который делает вот такое, ну, там, какой-то фидбэк, значит, этот самый, проходит там день или два, типа, ну, короче, я сделал.
3548.38 3551.54 "Анатолий Кулаков" Отлично, мне кажется, так и надо работать с аудиторией.
3551.54 3560.46 "Игорь Лабутин" Вот, он, как бы, я так понимаю, ну, он же, как бы, один из самых гуру этих экстенджеров, у него там их сотни, мне кажется, уже, ну, в общем, короче, вот он с легкостью добавляет еще.
3560.46 3561.46 "Игорь Лабутин" Рука набита, да?
3561.46 3565.80 "Игорь Лабутин" Да, у него, короче, появилось три экстенджера, которые интересные с моей точки зрения.
3565.80 3566.80 "Игорь Лабутин" Ну-ка, давай.
3566.80 3578.56 "Игорь Лабутин" Во-первых, экстенджер под названием My Keyboard Shortcut, если вы как-то кастомно настраивали, короче, вашу студию, то теперь можно заэкспортить все ваши шорткаты в четырех форматах.
3578.56 3582.20 "Игорь Лабутин" Новый сеттинг, но этим никого не удивишь, это чтобы перенести на другую студию.
3582.20 3586.36 "Игорь Лабутин" Ну, теперь еще их можно заэкспортировать в html, в txt и в json.
3586.36 3590.36 "Игорь Лабутин" То есть, ты экспортишь такое какое-нибудь там html, txt, и можно красиво напечатать.
3590.36 3595.10 "Игорь Лабутин" У тебя прям вот твой комплект экстенджеров этих шорткатов личный.
3595.10 3599.70 "Анатолий Кулаков" Да, могу представить, ты распечатываешь на принтере, вешаешь перед собой и заучиваешь экстенджеры.
3599.70 3600.70 "Анатолий Кулаков" Прекрасная штука.
3600.70 3601.70 "Анатолий Кулаков" Вот.
3601.70 3604.94 "Анатолий Кулаков" Слушай, в рамках вот этого плагина не могу не поделиться своей болью.
3604.94 3616.66 "Анатолий Кулаков" Вообще, я огромный фанат шорткатов, у меня там настроено абсолютно много всего, и столько же, насколько я фанат шорткатов, я чувствую, как и Visual Studio и товарищи JetBrains ненавидят шорткаты.
3616.66 3626.24 "Анатолий Кулаков" Потому что часто бывает, слетают они в дефолтное положение, часто бывает, что студийные шорткаты PE мешаются с JetBrains'овскими шорткатами.
3626.24 3629.00 "Анатолий Кулаков" В общем, и там, и там все очень-очень плохо.
3629.00 3631.00 "Анатолий Кулаков" А казалось бы, решение простое.
3631.00 3632.00 "Анатолий Кулаков" Чего хочется?
3632.00 3647.16 "Анатолий Кулаков" Хочется просто нормальный какой-то файлик, например, тот же самый json, где можно в человеческом понятном виде все эти шорткаты описать, и который стабильно, 100% всегда будет загружаться и перебивать любое чудо, которое настроено внутри студии, внутри шапера.
3647.16 3649.16 "Анатолий Кулаков" То есть иметь самый высший приоритет.
3649.16 3650.16 "Анатолий Кулаков" Вот единственное, что хочется.
3650.16 3653.44 "Анатолий Кулаков" И, например, Visual Studio Code, вот это осилило.
3653.44 3662.48 "Анатолий Кулаков" С Visual Studio Code, если кто не знает, можно прям положить хоть файл настроек самой Visual Studio в json, где будут описаны все ваши шорткаты, хоть сделать намного гибче.
3662.48 3677.32 "Анатолий Кулаков" Положить специальный файл рядом с проектом, который вы открываете, и Visual Studio подхватит этот файлик, который называется в определенном образом, и режиссирует в определенной бабочке, и добавит вам ваши шорткаты только для этого проекта, допустим, только для этого расширения файлов и так далее.
3677.32 3702.32 "Анатолий Кулаков" Вот если бы товарищи из Visual Studio или товарищи из ReSharper сделали бы такую штуку, то есть нормальный файлик с понятным синтексисом для ручного редактирования, не вот этот страшный WS Settings, с шорткатами, я был бы, наверное, самым счастливым человеком на свете, потому что я уже задолбался их перестраивать и назначать, и я, кажется, скоро откажусь от этой идеи, придется использовать какими-нибудь стандартные, убогие, никому не нужные шорткаты.
3702.32 3717.56 "Игорь Лабутин" Ну вот я, как ни странно, использую практически, я бы сказал, стандартные, мне кажется, я там чуть-чуть только, ну вот в Райдере точно, по-моему, в Райдере у меня настроен один единственный кастомный шорткат, называется "Скопируй, пожалуйста, то, что выделено, но без цвета".
3717.56 3718.56 "Игорь Лабутин" Очень мило.
3718.56 3726.36 "Игорь Лабутин" Ну вот типа он по дефолту, понятно, копирует с подсветкой синтексиса, у него есть команда скопировать без подсветки синтексиса, но вот на ней шортката не было.
3726.36 3729.52 "Игорь Лабутин" Вот она у меня была, зачем-то мне это было надо.
3729.52 3741.72 "Анатолий Кулаков" Я обычно пользуюсь противоположной стороной, я вставляю без форматирования, Control + Shift + V обычно работает во всех редакторах, которые позволяют тебе вставить уже без цвета, без формата, без болда, без подчеркивания, без всего.
3741.72 3754.08 "Игорь Лабутин" Да, мне нужно было, слушай, я, по-моему, что-то типа из кода, там был какой-то то ли Enum большой, то ли что-то такое, и мне нужно было оттуда перегнать в, грубо говоря, в Excel-ку, ну типа в нужные места Excel-ки.
3754.08 3761.72 "Игорь Лабутин" И когда у тебя темная тема студии, он копируется с чёрным бэкграундом, ты вставляешь в Excel, ну короче, работало так себе.
3761.72 3762.72 "Анатолий Кулаков" Мне нужно было иметь текст.
3762.72 3766.68 "Анатолий Кулаков" В том-то и том, ты тоже Control и буковку T нажимаешь, и он тебе клеит формат.
3766.68 3770.20 "Игорь Лабутин" Я знаю, но мне быстрее было, чтобы он копировал правильно.
3770.20 3789.48 "Анатолий Кулаков" Ну в общем, все экстеншены, которые касаются шорткатов, очень мною одобряемы, и я надеюсь, что это приведёт к какому-нибудь такому понятному импорту и экспорту шорткатов в понятном формате, и который будет работать стабильно, а не через каждую неделю слетать от неведомых обновлений.
3789.48 3790.48 "Игорь Лабутин" Ну посмотрим.
3790.48 3794.56 "Игорь Лабутин" Второй экстеншен мне показался забавным, я не знаю, сколько он полезный.
3794.56 3802.28 "Игорь Лабутин" Во всех редакторах, собственно, что в райвере, что в студии есть фича, когда на одну скобочку встаёшь, да, у тебя другая скобочка хайлайтится.
3802.28 3803.84 "Игорь Лабутин" Ну чтобы хоть как-то парность проверять.
3803.84 3805.48 "Игорь Лабутин" Ну да, полезно, что ли.
3805.48 3806.48 "Игорь Лабутин" Вот.
3806.48 3810.88 "Игорь Лабутин" А есть, короче, теперь экстеншен от Мэдса, что теперь у тебя скобочки можно раскрасить во всё цвета радуги.
3810.88 3815.20 "Игорь Лабутин" Ну в смысле, вот у тебя там выражение, не знаю, 10 вложенных скобочек, они все будут разноцветные.
3815.20 3822.32 "Анатолий Кулаков" Угу, я видел такой экстеншен, и насколько я помню, у него было гигантское количество звёзд, ну то есть это популярная
3822.32 3825.20 "Игорь Лабутин" штука. То есть, ну вот, короче, Мэдс написал ещё один.
3825.20 3827.92 "Игорь Лабутин" Ну или перенёс свой, если я не удивлюсь.
3827.92 3829.76 "Игорь Лабутин" Или перенёс свой, может быть, это был его, действительно.
3829.76 3833.48 "Игорь Лабутин" Ну короче, кажется, что эта фича может появиться в студии, судя по всему.
3833.48 3845.44 "Игорь Лабутин" И последний есть довольно, насколько я понимаю, популярный экстеншен, который называется Peacock, то есть павлин, для VS Code, опять же, который позволяет раскрашивать VS Code в разные цвета, в зависимости от того, где вы его открыли.
3845.44 3854.12 "Игорь Лабутин" Ну, видимо, примерно таким же способом, как ты говоришь, файлик лежит рядышком, да, с проектом, и там какая-нибудь настройка лежит, типа, покрась VS Code в зелёный цвет.
3854.12 3855.12 "Игорь Лабутин" Вот.
3855.12 3856.12 "Игорь Лабутин" А для студии такого не было.
3856.12 3858.96 "Игорь Лабутин" Ну или опять же, я не знал.
3858.96 3870.68 "Анатолий Кулаков" Насколько я знаю, это применяется людьми, когда они открывают разные проекты, например, проект на работе, у тебя в студии, короче, с одним цветом, проект домашний, какой-нибудь, Bad Project, другим цветом, или проект напрямую на продакшене.
3870.68 3876.56 "Анатолий Кулаков" Ты открываешь, и у тебя тут всё должно мигать красным, чтобы ты чётко понимал, что ты делаешь сейчас, и какую кнопочку, и зачем ты это нажимаешь.
3876.56 3886.16 "Игорь Лабутин" Ну, в студии, мне кажется, проект на продакшен это не так актуально, в отличие от какой-нибудь SQL Server Management студии, там-то да, там вот как раз очень актуально, что ты законнактивался к продакшен базе.
3886.16 3916.36 "Игорь Лабутин" Но, тем не менее, теперь есть экстенджинг, называется Solution Colors, и если вы открыли солюшен, и у вас поставлен этот экстенджинг, можно теперь выбрать для этого солюшен какой-то цвет, и у вас студия, ну вот этот футер, насколько я понимаю, будет покрашен в нужный цвет, и вы будете, он будет запоминаться, что именно этим солюшеном нужно открывать именно с этим цветом, там по-моему на выбор типа этих 16 или скольких цветов, не знаю, насколько кастомизируется, но, наверное, можно выбрать любой, и, короче, будет у вас в студии разноцветная зависимость от того, где вы её открыли, какой солюшен, точнее, вы открыли.
3916.36 3924.40 "Игорь Лабутин" Наверное, это действительно полезно так, чтобы помнить, визуально чисто видеть, какой, куда, что за студия.
3924.40 3927.92 "Игорь Лабутин" Ну, пробуем, смотрим, может быть, опять же, заедет в основной версию.
3927.92 3941.28 "Анатолий Кулаков" Ну, вот это интересно, каким образом это будет связано с основной версией студии, потому что всё-таки такие вещи довольно специфичны, хотелось бы, чтобы они оставались в виде плагинов, а не пытались это всё засунуть в студию, которая и так довольно монструозная.
3941.28 3956.80 "Игорь Лабутин" Всё так, ну, давай посмотрим, что будет, как только будут какие-то изменения, закончится фаза 2, может быть, там будет фаза 3, мы узнаем, во что это вылезет, будем следить, я на МЭДСа подписан в Твиттере, так что новые экстенджеры у меня не пройдут.
3956.80 3957.80 "Игорь Лабутин" Давай дальше.
3957.80 3968.36 "Анатолий Кулаков" Так, дальше хотелось вас познакомить с одной интересной статейкой, немножко не про чистый .NET, код, плагины, немножко про архитектуру.
3968.36 3984.44 "Анатолий Кулаков" Собрались недавно три интересных человека и побеседовали на какие-то вопросы, которые, в общем, можно охарактеризовать, как связана простота и архитектура, и вообще, какие здесь есть аспекты и куда надо придерживаться.
3984.44 3992.52 "Анатолий Кулаков" И несколько таких интересных идей, каких-то базовых концепций хотелось вам озвучить быстренько так, и легенько, и ненапряжно.
3992.52 4003.44 "Анатолий Кулаков" Во-первых, была назвучена такая мысль, что, соответственно, каждая архитектура, она должна прежде всего преследовать цель простоты.
4003.44 4012.28 "Анатолий Кулаков" И чем проще результирующее значение, результирующие проекты, solution у вас получатся, тем вообще лучше со многих сторон.
4012.28 4021.16 "Анатолий Кулаков" И когда вы смотрите на какой-то код, вы должны постоянно себя спрашивать, а достаточно ли здесь все делано все просто, а нельзя ли что-то упростить, а нельзя ли что-то убрать.
4021.16 4034.72 "Анатолий Кулаков" И делать это нужно постоянно, потому что код меняется, код живет, и если однажды вы ответили себе, нет, тут и так все оптимально, то где-то через месяц, через полгодика, через год ваше мнение вполне может измениться.
4034.72 4044.84 "Анатолий Кулаков" Также этот вопрос нужно себе задавать на нескольких уровнях, там на высоком, на низком, и на уровне API, и на уровне построения компонентов, и везде-везде.
4044.84 4050.76 "Анатолий Кулаков" То есть упрощать можно абсолютно везде, и каждый из нас должен стремиться это сделать.
4050.76 4066.28 "Анатолий Кулаков" Потому что когда человека будет, например, в 3 часа ночи кричат, у нас production лежит, давай бегом что-нибудь делай, и он не в состоянии отладить, продебажить, или понять вообще состояние системы, вот когда такая ситуация происходит, это говорит о сложности вашей системы.
4066.28 4073.28 "Анатолий Кулаков" Соответственно, чем сложнее система, тем больше времени уйдет на ее починку, на ее диагностику, на ее отладку и тестирование.
4073.28 4081.40 "Анатолий Кулаков" Соответственно, чем проще система, чем проще концепции и подходы, тем легче все это содержать в порядке.
4081.40 4082.84 "Анатолий Кулаков" Я думаю, с этим никто спорить не будет.
4082.84 4085.32 "Анатолий Кулаков" Другой вопрос, как этого добиться.
4085.32 4091.12 "Анатолий Кулаков" Одним из способов добиться этого является концепция, когда вы думаете о самом потребителе.
4091.12 4101.44 "Анатолий Кулаков" То есть вы думаете не о том, как бы этот код написать, чтобы он хоть как-то заработал, а о том, как потребитель, как ваши кастомеры, как ваши клиенты будут им пользоваться.
4101.44 4109.48 "Анатолий Кулаков" И о том, каким образом вы заставляете пользоваться этим кодом, и каким образом они бы хотели им пользоваться.
4109.48 4117.92 "Анатолий Кулаков" То есть вам полезно очень ставить себя на место ваших клиентов и придумывать, какой самый простой, самый понятный, самый очевидный путь – заюзать вот эту функциональность.
4117.92 4128.72 "Анатолий Кулаков" А потом сравнить с тем, что у вас получилось на выходе и примерно прикинуть, а можете вы как-то подвинуть это ближе к тому, что вам самим же хотелось бы видеть с другой стороны.
4128.72 4133.52 "Анатолий Кулаков" В частности, это касается там, например, всяких интеграций.
4133.52 4148.40 "Анатолий Кулаков" Чем больше у вас есть требований к сложным интеграциям, например, для того, чтобы вызвать просто ваш API, тем, соответственно, больше проблем будет у вызывающей стороны и тем скорее клиент сдастся и не будет вообще им пользоваться.
4148.40 4160.04 "Анатолий Кулаков" Соответственно, если у вас есть какой-то компонент, который обладает большим, широким API, который умеет абсолютно все, тем, скорее всего, сложнее будет с ним интеграция.
4160.04 4175.88 "Анатолий Кулаков" Потому что, если вы хотите сделать каких-то два компонента, говорящих друг с другом, то, соответственно, вам придется каким-то образом их объединить, как-то с ними общаться и чем больше таких точек общения, тем сложнее сама коммуникация в результате в итоге получится.
4175.88 4183.60 "Анатолий Кулаков" Соответствует ли напрямую сложность приложения с теми фичами, которые у нее есть?
4183.60 4189.72 "Анатолий Кулаков" То есть, допустим, когда вы добавляете фичу, обязательно ли приложение и сложность самого приложения должна увеличиваться?
4189.72 4192.32 "Анатолий Кулаков" На самом деле, не обязательно.
4192.32 4197.20 "Анатолий Кулаков" Фичи могут добавляться без увеличения сложности.
4197.20 4202.32 "Анатолий Кулаков" Авторы вводят такую концепцию, как, например, та зона, куда добавляется фича.
4202.32 4219.92 "Анатолий Кулаков" Например, если мы возьмем какой-нибудь стандарт Open API, в который контроллеры, например, добавляются у нас, HTTP, и по Open API публикуют свой контракт наружу, и с этим контрактом уже может интегрироваться какой-то браузерный клиент, JavaScript клиент.
4219.92 4229.16 "Анатолий Кулаков" И, соответственно, если у вас перед вами стоит задача добавить еще один какой-то контроллер или прописать еще один какой-то метод, то эта задача абсолютно никак не увеличивает сложность.
4229.16 4239.52 "Анатолий Кулаков" Потому что вы добавляете контроллер, он автоматически продвигается, пушится в Open API, в Swagger, и, соответственно, интеграция с ним довольно простая.
4239.52 4251.08 "Анатолий Кулаков" Какой-нибудь HTTP клиент идет, читает документацию, смотрит параметры, все понятно, все известно, и сложность системы никаким образом не увеличивается, потому что у нас есть стандарт, некий стандарт между уровнями.
4251.08 4253.60 "Анатолий Кулаков" Другой пример – это EventBase система.
4253.60 4259.52 "Анатолий Кулаков" Если у вас есть EventSourcing, и у вас поступает задача как-то обработать еще один ивент.
4259.52 4261.68 "Анатолий Кулаков" Казалось бы, сложность должна увеличиться.
4261.68 4263.92 "Анатолий Кулаков" Чем больше ивентов, тем больше сложности, все такое.
4263.92 4277.04 "Анатолий Кулаков" Но если у вас грамотно выстроена инфраструктура, вы просто-напросто идете, декларируете какой-то классик, декларируете какой-то обработчик, в этом обработчике вы имеете понятные какие-то зависимости, опять же, сложность системы никак не увеличивается.
4277.04 4282.32 "Анатолий Кулаков" У вас просто добавляется множество функционала, но сложность остается на месте.
4282.32 4288.96 "Анатолий Кулаков" Все ивенты у нас структурированы, они простые, они понятные, и, соответственно, легко добавляется.
4288.96 4305.48 "Анатолий Кулаков" И отсюда вытекает, что сложность, она привносится часто тогда, когда вы смешиваете множество технологий, которые или взаимоисключающие, или, может быть, каким-то образом плохо интегрируются.
4305.48 4322.68 "Анатолий Кулаков" Например, если вы одно предложение возьмете, сделаете там REST API, туда же подсунете SOAP протокол, XML скомбинируете с JSON, плюс это еще будет у вас общаться с CSV файлами, вот тогда, скорее всего, у вас будет сложность увеличиваться.
4322.68 4337.72 "Анатолий Кулаков" Но если вы будете все держать в строгой, понятной, стандартизированной структуре, если ваше приложение будет придерживаться какой-то определенной согласованности, то в этих условиях простоту обеспечить гораздо-гораздо легче.
4337.72 4344.24 "Анатолий Кулаков" Еще вводится интересное понятие, которое называется количество концептов.
4344.24 4359.28 "Анатолий Кулаков" Под количеством концептов подразумевается то, со сколькими концептами вам нужно взаимодействовать для того, чтобы понять происходящее, для того, чтобы проинтегрировать какую-то фичу, добавить какую-то фичу и, соответственно, заиспользовать какую-то фичу.
4359.28 4369.00 "Анатолий Кулаков" Например, концептами могут быть API, какие-нибудь ивенты, девайсы, другие протоколы.
4369.00 4371.68 "Анатолий Кулаков" И выведено магическое число 5.
4371.68 4387.16 "Анатолий Кулаков" Вот если как разработчик взаимодействует с 5 различными концептами, то это уже сложно, это уже долго и люди обычно бросают такие вещи или такие интеграции даются им намного сложнее.
4387.16 4397.28 "Анатолий Кулаков" Поэтому рекомендуется иметь какую-то одну главную концепцию, ну и может быть 2-3 там вокруг навешанной, которые второстепенные и сильно не влияют на основную.
4397.28 4403.20 "Анатолий Кулаков" И таким образом любая интеграция, любое взаимодействие с вашим компонентом, оно будет понятным.
4403.20 4414.20 "Анатолий Кулаков" Например, если у нас есть концепция каких-нибудь HTTP контроллеров и свагер API, то добавить контроллер должно быть довольно понятно и очевидно.
4414.20 4431.44 "Анатолий Кулаков" Если мы сюда же начнем наворачивать какие-то дополнительные уровни абстракции или какие-то дополнительные взаимодействия или нужно сходить в какое-то место, как-то там зарегистрироваться для того, чтобы этот контроллер добавить, это уже все наворачивает какие-то сложности и может отпугнуть разработчиков.
4431.44 4448.72 "Анатолий Кулаков" Еще одна интересная мысль, которая продвигается, это то, что вы не можете выдумать какую-то себе архитектуру, даже если она самая прекрасная, самая хорошая, самая свежая и красивая, прийти к команде и сказать, вот смотрите, новая архитектура, она крутая, давайте юзайте ее и придерживайтесь того, что я здесь вам напридумывал.
4448.72 4450.32 "Анатолий Кулаков" Обычно это не работает.
4450.32 4467.32 "Анатолий Кулаков" Обычно вы все-таки должны показать, в чем основные концепции того дизайна, который вы придумали, какие подходы вы еще рассматривали, как вы их сравнивали, объяснить, почему вы выбрали именно вот это, почему не какие-то альтернативы, какие есть плюсы и минусы у этого подхода.
4467.32 4474.08 "Анатолий Кулаков" Может быть вам понравилась простота, может у вас там удобство интеграции, может удобство поддержки, еще что-то.
4474.08 4496.00 "Анатолий Кулаков" Обычно рекомендуется это все описывать и рассказывать, чтобы все разработчики, вся команда, которая непосредственно будет придерживаться этой концепции, она ее понимала и разделяла, понимала ее плюсы, минусы и в будущем, когда придут какие-то другие разработчики, очень полезно, чтобы эта концепция вся осталась, то есть понимание, почему был выбран такой подход осталось.
4496.00 4500.96 "Анатолий Кулаков" Именно поэтому, например, в последнее время часто популярна такая вещь, как ADR.
4500.96 4517.12 "Анатолий Кулаков" Это специальные документы, которые декларируют Architecture Decision Records, то есть те результаты вашего дизайна, которые вы в конце концов вывели и самое главное, те альтернативы, которые вы рассматривали вместе с их плюсами и минусами.
4517.12 4530.12 "Анатолий Кулаков" Это помогает, соответственно, вникнуть в концепцию происходящего дизайна, происходящей архитектуры в этом солюшене, даже без участия вот этих всех архитекторов, обоснований и так далее.
4530.12 4538.76 "Анатолий Кулаков" Просто люди заходят, читают документы, к ним понятно, почему здесь был выдуман Event Sourcing, почему здесь мы интегрируемся через Open API и так далее.
4538.76 4541.04 "Анатолий Кулаков" В общем, тоже полезная, интересная концепция.
4541.04 4544.16 "Анатолий Кулаков" Вот такие идеи насобирали у нас три архитектора.
4544.16 4556.84 "Анатолий Кулаков" Если вам идеи близки или понравились, у них еще есть множество интересных статей, множество интересных видео, как они собираются, обсуждают какие-то концепции и пытаются нас научить строить современные приложения.
4556.84 4561.20 "Анатолий Кулаков" Можете пройти по ссылочке и посмотреть еще что-нибудь, что вам приглянулось.
4561.20 4578.48 "Игорь Лабутин" Ну да, потому что вообще вопрос проектирования и качественного проектирования, он очень широк, я боюсь, что если можно вообще, чуть ли не отдельный подкаст написать, да, наверное, уже и пишет где-нибудь кто-нибудь, если вы вдруг знаете, кстати, киньте линки, послушаю с удовольствием.
4578.48 4581.08 "Игорь Лабутин" Пойдем мы дальше.
4581.08 4584.24 "Игорь Лабутин" Мы поговорили про Visual Studio, теперь давай поговорим про ReSharper Rider.
4584.24 4591.24 "Игорь Лабутин" В прошлый раз мы анонсировали же что-то там про ReSharper, да, что-то мне казалось, там были какие-то новости.
4591.24 4592.24 "Игорь Лабутин" А, релиз был.
4592.24 4594.48 "Игорь Лабутин" Ну у него там Roadmap задекларировался.
4594.48 4598.88 "Игорь Лабутин" Вот сейчас мы поговорим про Roadmap.
4598.88 4603.36 "Игорь Лабутин" Мне кажется, мы его еще не обозревали, но даже если вы обозревали, послушайте его еще разок, это не страшно.
4603.36 4604.36 "Игорь Лабутин" Не, не, не обозревали.
4604.36 4605.36 "Игорь Лабутин" Не обозревали?
4605.36 4606.36 "Игорь Лабутин" Ну отлично.
4606.36 4607.36 "Игорь Лабутин" Да, поехали.
4607.36 4636.96 "Игорь Лабутин" ReSharper 2022.3 планирует поддержать C# 11, это всякие Rostring, Language Injections, это когда вы можете, поскольку у вас будут Rostring, то скорее всего в эти Rostring вы будете писать, не знаю, JSON или SQL, и там точно нужно делать полезную фичу Language Injections, это значит, что ReSharper будет понимать, что в этой внутри строчки и анализировать ее соответственно тому ленгвиджу, который там внутри, там SQL или так далее.
4636.96 4650.24 "Игорь Лабутин" Можно будет конвертировать туда-обратно в обычные стринги, будут поддержаны default interface методы, UTF-8, строки, reffield, файл local type, в общем, куча всяких фич, все то, что завезут в C# 11.
4650.24 4675.44 "Игорь Лабутин" Планируют улучшить Razor Formatter, дальше планируют улучшить ReSharper, это на самом деле тоже интересная важная штука, сосуществование с Rostring, потому что сейчас хайлайты и вот эти вот подчеркивания от Rostring и ReSharper периодически перемешиваются, и там аналайзеры одно говорят, ReSharper аналайзеры другое говорят, короче, они пытаются это сделать так, чтобы это было более красиво и едино, посмотрим.
4675.44 4688.92 "Игорь Лабутин" Out of process, миграция, все еще в процессе, и непонятно, когда это закончится, какой будет статус, ну то есть что-то еще успеют сделать, но что непонятно пока.
4688.92 4703.84 "Игорь Лабутин" Для юни тестинга постараются уменьшить memory usage, в EF Core там идет работа, есть интересная идея, попытаться детектировать, когда у вас проявляется проблема 1+n, то есть когда вы на один запрос дальше делаете n дочерних запросов, чтобы вместо одного join.
4703.84 4709.84 "Игорь Лабутин" Вот ReSharper собирается попытаться это детектировать, прямо глядя на код, но посмотрим.
4709.84 4719.28 "Игорь Лабутин" Завезут более качественный декомпилятор, они на самом деле туда просто захватят часть кусочка дотпика, прямо в ReSharper, соответственно, он будет получше.
4719.28 4721.68 "Анатолий Кулаков" Непонятно, почему часть кусочков, а не просто дотпик,
4721.68 4729.60 "Игорь Лабутин" что это за полумеры? Ну типа от дотпика им не нужен UI выбора этих сборок, ну то есть… Ну UI-то ладно, мы переживем.
4729.60 4738.52 "Игорь Лабутин" Скорее всего внутренний механик вся возьмется, конечно же, то есть у них просто так написано, типа borrow from dotpick, соответственно, borrow подразумевает, ну мы что-то возьмем.
4738.52 4741.12 "Игорь Лабутин" Весь backend, да, весь фонда достаем.
4741.12 4742.12 "Игорь Лабутин" Да, возможно.
4742.12 4751.24 "Игорь Лабутин" Опять же, dotpick же тоже основан на той же, скорее всего, в райдере как ReSharper, то есть там не так много забирать то надо, только сам декомпилятор.
4751.24 4758.64 "Игорь Лабутин" DotTrace тоже претерпит изменения, это не совсем ReSharper, но это весь набор tools.
4758.64 4766.68 "Игорь Лабутин" Там, если вы пользовались вьюшкой под названием performance view, то ее потихонечку будут убирать и надо смотреть в timeline viewer.
4766.68 4769.20 "Игорь Лабутин" Он типа основной и главный будет.
4769.20 4774.80 "Игорь Лабутин" В райдере примерно то же самое, тоже C# 11, EF Core, и viewer из dotpick, вот это все.
4774.80 4778.60 "Игорь Лабутин" Дальше нужен startup performance, чтобы райдер побыстрее стартовал.
4778.60 4792.48 "Игорь Лабутин" Нужны изменения в multimonitor support, то есть поддержка нескольких мониторов, докинг вот этих всех туловых плавающих окошек и, в общем, вокруг этого всего будет улучшение.
4792.48 4796.80 "Анатолий Кулаков" Это вообще киллер фича, они вот обещают в этом 22.3?
4796.80 4799.80 "Анатолий Кулаков" Ну это в roadmap, ну то есть как бы обещать.
4799.80 4808.08 "Анатолий Кулаков" В roadmap, по-моему, этой баги уже где-то 500, ну столько сколько существует райдер, столько и существует эта бага, что там не поддерживаются мультимониторы.
4808.08 4811.08 "Анатолий Кулаков" И хотелось бы движение, конечно, в эту сторону.
4811.08 4812.96 "Игорь Лабутин" Ну вот, собираются.
4812.96 4816.80 "Игорь Лабутин" Собирается поддержка VSL, если вы на винде.
4816.80 4823.52 "Игорь Лабутин" Dot memory будет встроенной профайлером в райдер теперь на linux и на macOS, прямо внутри.
4823.52 4833.92 "Игорь Лабутин" Early support работы на ARM64 на linux, поддержка maui, можно будет открыть проектики, запускать, подебажить, но пока только winui.
4833.92 4840.36 "Игорь Лабутин" Проекты, поддержка SQL server projects, я даже не знаю, что это такое, у нас в студии был.
4840.36 4848.20 "Анатолий Кулаков" Ну подожди, это же обычный SQL server management студия и у неё можно завести проект SQL, где ты можешь схему разворачивать, запросики писать.
4848.20 4850.48 "Анатолий Кулаков" О, точно, блин, так давно было, я тогда уже.
4850.48 4851.48 "Игорь Лабутин" Наверное, кажется, сталкивался.
4851.48 4860.24 "Игорь Лабутин" Нет, кстати, ты знаешь, вот именно проектами нет, у меня лично обычно всё, ну, как бы с кольками одинокими лежало.
4860.24 4861.24 "Анатолий Кулаков" Файликами в папочке, да?
4861.24 4862.24 "Игорь Лабутин" Да, да, да, конечно.
4862.24 4863.24 "Игорь Лабутин" По старинке, без всяких проектов.
4863.24 4873.44 "Игорь Лабутин" А я объясню, почему, эти же файлики в папочке, они же, эта же папочка была настроена в линкпаде, что это мои сниппеты.
4873.44 4878.96 "Игорь Лабутин" И, соответственно, из линкпада я мог тоже дёргать их же, иногда я этим пользовался.
4878.96 4889.32 "Анатолий Кулаков" Насколько я помню, это не мешает, ну то есть я тоже SQL server проектами пробовал, пользовался практически никогда, но, насколько я помню, это просто лежит ещё один XML файлик, вот как рядом с твоими CSS файликами.
4889.32 4895.16 "Игорь Лабутин" Я понимаю, что это такой же CSS-проч, ну или кто он там, SQL-проч, или как он зовётся, я уже не знаю, S-проч.
4895.16 4898.40 "Игорь Лабутин" Вот, ну что-то вот я действительно никогда не пользовался, не надо было.
4898.40 4907.24 "Игорь Лабутин" И последнее, это Blazor Hot Reload Server + WASM, то есть, короче, если вы пользуетесь Blazor, то в райдере будет Hot Reload.
4907.24 4924.44 "Игорь Лабутин" И, надо сказать, когда я добавлял эту новость в выпуск, это был просто roadmap, но roadmap roadmap, но вот буквально на днях JetBrains выпустил EAP уже райдера, так что это, конечно, первый EAP, поэтому, ну, как бы, будьте осторожны и вот это всё.
4924.44 4931.40 "Игорь Лабутин" Но, тем не менее, можно пытаться попробовать туда зарегаться, там все дела, получить EAP.
4931.40 4941.00 "Игорь Лабутин" Я не знаю, доступен ли уже прямо сейчас инсталлятор или это пока только собирают желающих, не проверял, честно скажу, но раз уже объявили, то, скорее всего, скоро будет.
4941.00 4945.56 "Анатолий Кулаков" Я только что проверил, действительно, инсталлятор доступен, поэтому можно, честно, идти скачивать.
4945.56 4953.80 "Анатолий Кулаков" И ещё одна интересная, актуальная фишка EAP от JetBrains, может быть, кто-то не знал, что для них не нужна лицензия.
4953.80 4971.60 "Анатолий Кулаков" Поэтому, если у вас какие-то вдруг почему-то проблемы с лицензиями райдеров или решаперов, то можно чисто, легально, без всяких проблем ставить себе последние EAP, они выходят довольно регулярно и, в принципе, они довольно стабильные, поэтому это может быть...
4971.60 4980.76 "Анатолий Кулаков" И эти EAP, они не требуют лицензии, они полностью бесплатные, они работают на то, чтобы как можно больше людей их подтестировало, попробовало и сообщило о багах.
4980.76 4990.08 "Анатолий Кулаков" Поэтому это вполне легальный способ использовать легальные инструменты без всяких минусов, без всяких проблем, всё легально и красиво.
4990.08 4993.64 "Анатолий Кулаков" В общем, если у вас какие-то проблемы, воспользуйтесь этим хаком.
4993.64 5004.00 "Игорь Лабутин" Так, ну и на этом, мне кажется, основная, так сказать, подкасть у нас закончена, давай у нас ещё есть в этот раз подкастики.
5004.00 5007.36 "Анатолий Кулаков" Да, выходим на финишную прямую.
5007.36 5012.76 "Анатолий Кулаков" Было несколько интересных выпусков в разных подкастах, с которыми мне хочется с вами поделиться.
5012.76 5017.12 "Анатолий Кулаков" Прежде всего, это «Подлодка-260» выпуск, где говорят про криптовалюты.
5017.12 5026.66 "Анатолий Кулаков" И, наконец-то, это не просто тупой баззворт про биткоины как-то, а нормально рассказывает про блокчейн, вообще продолжает разбираться, что это такое.
5026.66 5035.38 "Анатолий Кулаков" Мы эту тему поднимали у нас в закулисье уже, но это более верхневоротовая концепция в «Подлодке» была.
5035.38 5046.30 "Анатолий Кулаков" То есть, там много интересных фактов с позиций безопасности, то есть, почему это нужно, почему это безопасно, как можно нарушить эту безопасность, что можно там сломать, как можно распределить голоса.
5046.30 5056.42 "Анатолий Кулаков" Рассказывается вообще об основании экономических моделей, например, как блокчейн можно применять в экономике, в доказательствах, в юриспруденции.
5056.42 5057.42 "Анатолий Кулаков" В «Академии Доктора» где-то.
5057.42 5062.70 "Анатолий Кулаков" То есть, показаны нормальные практические примеры, где это применяется вообще, кроме денег.
5062.70 5071.78 "Анатолий Кулаков" Потому что про деньги слышали все, а вот куда это можно воткнуть и нужно, самое главное, втыкать в другие сферы, вот там, в принципе, более-менее хорошо рассказывается.
5071.78 5081.58 "Анатолий Кулаков" Также отвечаются навечные вопросы про победит ли proof of stake, proof of work, и вообще выживет ли биткоин после этого.
5081.58 5084.34 "Анатолий Кулаков" В общем, такие интересные темы там тоже затрагивались.
5084.34 5089.10 "Анатолий Кулаков" Другой подкаст – это «DotNet Rocks».
5089.10 5090.78 "Анатолий Кулаков" Ребята пригласили Стива Сандерсона.
5090.78 5098.38 "Анатолий Кулаков" Это автор много всего, и в частности, нам он известен как автор Blazer.
5098.38 5102.66 "Анатолий Кулаков" И поговорили они про WASM Everywhere.
5102.66 5115.30 "Анатолий Кулаков" Актуальные новости из мира WASM обсудили, соответственно, куда он движется, какие стандарты, кто там участвует в этих стандартных, как обстоят дела не только в дотнете, но и в окружающих языках.
5115.30 5121.02 "Анатолий Кулаков" Узнали, как связаны Blazer и MyUI, чем они там занимаются, как собираются интегрироваться.
5121.02 5133.18 "Анатолий Кулаков" И выработали несколько, пообеседовали на несколько интересных концепций, в частности, к тому, что WASM приводит нас к… Я бы не сказал, что это новая парадигма.
5133.18 5145.30 "Анатолий Кулаков" Эта парадигма давно есть, но для дотнетчика, может быть, она будет неким откровением, что мы обычно держим код на сервере, и данные у нас обмениваются между кодом.
5145.30 5150.10 "Анатолий Кулаков" Данные бегают между браузером и сервером, данные бегают между различными сервисами.
5150.10 5152.22 "Анатолий Кулаков" Это как бы для нас нормальное приложение.
5152.22 5160.10 "Анатолий Кулаков" Но если к нам приходит WASM, то мы уже WASM-ом оперируем как кодом, который можно куда-то передавать.
5160.10 5163.90 "Анатолий Кулаков" И, соответственно, у нас рождается немножко другая концепция.
5163.90 5168.26 "Анатолий Кулаков" Когда у нас не данные бегают между сервисами, а наоборот, сервисы бегают между данными.
5168.26 5173.14 "Анатолий Кулаков" Мы можем сделать сервис на WASM-е и передать его в то место, где у нас сейчас лежат данные.
5173.14 5176.70 "Анатолий Кулаков" И это открывает тоже интересные какие-то возможности.
5176.70 5182.54 "Анатолий Кулаков" Например, мы можем использовать CDN-ы для того, чтобы кэшировать ваш код вместо данных.
5182.54 5186.06 "Анатолий Кулаков" Для того, чтобы приложение к пользователю загружалось намного быстрее.
5186.06 5193.70 "Анатолий Кулаков" Не потому, что оно код грузит быстрее, а потому, что само тело приложения уже будет находиться непосредственно на том CDN-е, который ближе к пользователю.
5193.70 5202.90 "Анатолий Кулаков" Это, соответственно, делает не только время загрузки поменьше, но также, например, уменьшает время установки обновлений вашего приложения и увеличивает приватность.
5202.90 5206.74 "Анатолий Кулаков" Потому, что у нас есть огромное число приватных данных.
5206.74 5215.70 "Анатолий Кулаков" Начиная от медицинских данных, кончая приватной информацией, персональными данными, которые вообще нежелательно бы передавать по сети, а давать неким сервисам.
5215.70 5220.90 "Анатолий Кулаков" Теперь у вас есть возможность просто-напросто передать вашу программу к вашему клиенту.
5220.90 5223.10 "Анатолий Кулаков" Допустим, в тот же самый мобильный телефончик.
5223.10 5228.90 "Анатолий Кулаков" Эта программа на мобильном телефончике что-то там обработает проанализирует, при этом данные никуда не уйдут.
5228.90 5232.70 "Анатолий Кулаков" Программа загружается быстро, обновляется быстро, вроде все счастливы.
5232.70 5234.46 "Анатолий Кулаков" Вот такие подобные вещи.
5234.46 5238.90 "Анатолий Кулаков" Еще задумали интересную тему, это WebAssembly System Interface, так называемый WASI.
5238.90 5245.70 "Анатолий Кулаков" WASI - это специальный интерфейс, который позволяет вам запускать WebAssembly вне веба, вне браузера.
5245.70 5252.50 "Анатолий Кулаков" Я напомню, что WebAssembly разрабатывался именно как некая концепция для веба, именно поэтому его назвали WebAssembly.
5252.50 5261.10 "Анатолий Кулаков" Но люди быстро поняли, что на самом деле WebAssembly позволяет вам запускать все, что угодно, независимо от операционной системы и независимо от языка.
5261.10 5270.34 "Анатолий Кулаков" Это получился такой межмировой язык, если вы научились с него компилироваться, то, соответственно, вы можете взаимодействовать со всеми другими языками.
5270.34 5273.06 "Анатолий Кулаков" И вам, соответственно, уже не нужен только браузер.
5273.06 5277.18 "Анатолий Кулаков" Вы можете взять абсолютно любую операционную систему или абсолютно любой запускальщик.
5277.18 5285.78 "Анатолий Кулаков" В частности, интересная концепция есть, что вы WebAssembly можете использовать в качестве ворклоуда для вашего Kubernetes кластера.
5285.78 5292.66 "Анатолий Кулаков" То есть вам не нужны докер-контейнеры, на самом деле, вы можете просто-напросто брать в WebAssembly сборку, WebAssembly файл и запускать в Kubernetes.
5292.66 5294.86 "Анатолий Кулаков" Ну, почему бы и нет?
5294.86 5302.38 "Анатолий Кулаков" Вот такие вот интересные концепции, взгляды будущего, обзор рынка в Asmo обсуждались, поэтому если вам тема интересная, обязательно послушайте.
5302.38 5312.42 "Анатолий Кулаков" Ну, еще одна прекрасная лекция, которую абсолютно всем можно порекомендовать, это Михаил Васильевич Попов «Введение в науку логики Гегеля».
5312.42 5316.06 "Анатолий Кулаков" Прекрасная книга, прекрасная наука, прекрасное введение.
5316.06 5326.18 "Анатолий Кулаков" Вообще рассказывается, что такое формальная логика, почему она существует, как она связана с диалектикой, почему каждому из нас нужна диалектика и без нее, в принципе, ни один программист не должен мочь жить.
5326.18 5330.78 "Анатолий Кулаков" Но, к сожалению, программисты явно ее таким образом не изучают.
5330.78 5339.46 "Анатолий Кулаков" Они изучают ее не явно, безусловно, но вот именно введение в логику, именно сама формальная логика очень хорошо открывает глаза.
5339.46 5350.86 "Анатолий Кулаков" Например, там вводится буквально базовые концепции, что такое бытие, что такое ничто, как ничто может перейти в бытие, возникновение и прихождение, становление.
5350.86 5355.62 "Анатолий Кулаков" И вот таких буквально пяток концепций, из которых вырабатывается весь основной мир.
5355.62 5361.82 "Анатолий Кулаков" То есть, как можно из своих собственных наблюдений и ощущений вырабатывать основные правила взаимодействия мира.
5361.82 5371.82 "Анатолий Кулаков" Очень прекрасная тема для того, чтобы просто размять голову или если вы хотите ее сломать, то тоже это тот путь, с помощью которого можно все это сделать.
5371.82 5380.86 "Анатолий Кулаков" Если вам понравится, хочу обратить внимание, что у Михаила Васильевича очень много лекций и по этой теме, и немножко в соседней теме, и есть ответы на вопросы.
5380.86 5384.82 "Анатолий Кулаков" В общем, логика Гигеля у него представлена довольно хорошо.
5384.82 5395.62 "Анатолий Кулаков" Поэтому, если вам интересно или хотя бы вы хотите для себя уяснить, что такое формальная логика и диалектика, вот эта вводная лекция для вас будет наверняка интересна.
5395.62 5400.42 "Игорь Лабутин" Да, звучит прям, уже сейчас можно сломать голову.
5400.42 5404.62 "Игорь Лабутин" Не знаю, может быть, даже послушаю, посмотрю.
5404.62 5419.90 "Анатолий Кулаков" Ну вот сам факт того, что знаешь, из ничего вырастить бытие и как бытие перевести в небытие, вот казалось бы, такие элементарные вещи на уровне обычной формальной логики даются довольно интересно.
5419.90 5424.46 "Игорь Лабутин" Окей, это можно как-то привязать к Nullability, там вот это все, как из Null, Proof, Inal.
5424.46 5432.70 "Анатолий Кулаков" Безусловно, все там есть, откуда что берется, откуда все исчезает, и как перейти из одного состояния в другое, это все очень программистам знакомо.
5432.70 5434.62 "Анатолий Кулаков" Просто оно не формализовано, к сожалению.
5434.62 5441.66 "Анатолий Кулаков" Мы это делаем на интуитивном уровне и с слишком высокоуровневых концепций, вот концепции кода, процессора и так далее.
5441.66 5445.66 "Анатолий Кулаков" Но было бы прекрасно понимать именно низкоуровневую природу всей логики.
5445.66 5448.82 "Игорь Лабутин" Окей, хорошо.
5448.82 5468.74 "Игорь Лабутин" Давай пойдем дальше, и на самый конец у нас, не знаю, насколько будет традиционно, но тем не менее, нам понравилось, и вам видимо тоже, поэтому мы продолжим делать рубрику кратко о разном, куда собраны все новости, про которые вроде долго не расскажешь, но новости там, может быть, кому-то интересны, и поэтому упомянуть стоит.
5468.74 5473.22 "Игорь Лабутин" Во-первых, новость, которая зацепила лично меня.
5473.22 5476.90 "Игорь Лабутин" Не знаю, насколько много из вас работает с Ажуром.
5476.90 5488.14 "Игорь Лабутин" В Ажуре есть так называемые Azure Resource Management Templates, или ARM Templates, если коротко, и это такие большие, обычно очень вербозные XML-файлики.
5488.14 5491.86 "Игорь Лабутин" Мы их когда-то писали руками, так себе удовольствие.
5491.86 5503.94 "Игорь Лабутин" Их можно, не обязательно делать все через ARM Templates, можно делать через tools, например, типа Pulumi, он позволяет на C# писать управление ресурсами в Ажуре.
5503.94 5506.94 "Игорь Лабутин" Но есть еще, так скажем, промежуточный вариант.
5506.94 5516.94 "Игорь Лабутин" Microsoft в качестве такого эксперимента делала язычок под названием Bicep, не знаю, как правильно, нормально произносится.
5516.94 5523.02 "Игорь Лабутин" Короче, он добрался из такого превью и стороннего проекта в совершенно нормальный продукт.
5523.02 5530.86 "Игорь Лабутин" Есть теперь официальный экстенджер, я вижу, у студии вот 17.3 и выше, который позволяет писать на таком гораздо более коротком языке.
5530.86 5548.70 "Игорь Лабутин" Это немножко, не знаю, я давно не писал, но мне казалось, что это смесь из ямля, с чем-то таким, ну то есть что-то иерархическое, которое позволяет вам написать нормальные темплейты, не погружаясь в дебри вот этих вот прям ужасов-ужасов XML.
5548.70 5554.74 "Игорь Лабутин" Если вы вдруг работаете с Ажурами темплейтами, посмотрите обязательно, очень полезная штука.
5554.74 5557.66 "Игорь Лабутин" Ну либо в Pulumi и схожие tools.
5557.66 5572.34 "Игорь Лабутин" Дальше, если вы пользуетесь Linkpad, то вышел Linkpad 7.4, там тоже всякие там улучшенные IntelliSense, короче, много всего интересного, смотрите детали на сайте и забирайте.
5572.34 5577.34 "Игорь Лабутин" Там есть бесплатная версия, насколько я помню, ну и если вы хотите, то бесплатная IntelliSense.
5577.34 5589.82 "Игорь Лабутин" Также из tools мы, по-моему, упоминали когда-то DensPy, как хороший декомпиль, ну то есть я, например, пользуюсь практически всегда DensPy, потому что тут пик, как раз, очень долго стартует, прям очень долго.
5589.82 5593.02 "Игорь Лабутин" А у меня кейс такой, что мне нужно быстренько вычинить что-то, посмотреть.
5593.02 5606.70 "Игорь Лабутин" Вот, и DensPy в этом смысле очень шустрый, но с помощью DensPy есть проблема, что его автор заархивировал проект, то есть на GitHub он все закрыто заархивирован, ну исходники есть, но как бы висит плашка, что все, проект архивный.
5606.70 5617.30 "Игорь Лабутин" Но от него создали форк, он называется DensPyX, и он живет, растет, развивается, так что если вы пользуетесь DensPy, посмотрите на DensPyX, я думаю, что он продолжит жить дальше.
5617.30 5643.82 "Игорь Лабутин" Так, из таких около библиотечно-туловых новостей, есть Core WCF 1.2, это новый релиз Core WCF, там еще добавили поддержки всяких штук, которых раньше не было, так что если вы как-то сидите на WCF и подумываете, переходя на нормальный последний .NET, периодически заглядываете в Core WCF, вдруг там поддержат то, что нужно вам, и будет хорошо.
5643.82 5653.06 "Игорь Лабутин" И если вы пользуетесь VSL, ну мне кажется, довольно много кто сейчас этим пользуется, то в VSL завезли поддержку SystemD.
5653.06 5664.02 "Игорь Лабутин" SystemD - это по сути способ запускать демоны, ну то бишь аналог службы в Windows, то есть запускать процессы, которые вроде как работают не от имени пользователя, а где-то там просто в системе.
5664.02 5669.74 "Игорь Лабутин" Да, они конечно от имени какого-то пользователя работают, но в смысле, что они не привязаны к сессии пользователя.
5669.74 5681.18 "Игорь Лабутин" Вот, и теперь это поддержано, пока это доступно только если вы VSL поставили из Microsoft Store и включили отдельный флаг, там поддержка пока еще такая, типа ее надо включать явно.
5681.18 5684.82 "Игорь Лабутин" Но тем не менее, возможно, это вам зачем-то будет нужно.
5684.82 5705.34 "Игорь Лабутин" Ну и, наверное, если вы интересуетесь, что происходит в соседних экосистемах, я говорю сейчас про Java, там давно известен проект Project LUM, это так называемые green-thread, которые вроде как вот-вот-вот готовы заехать или уже заехали в ту Java, которая сейчас будет релизиться.
5705.34 5722.30 "Игорь Лабутин" И видимо, дотнет-команда на это посмотрела, и в репозитории dotnet runtime labs, или runtime lab, тоже появился pull-request со словами типа начальная, типа initial implementation, по-моему, или как-то так, green-thread для дотнета.
5722.30 5739.70 "Игорь Лабутин" Так что это пока runtime lab, это никаких гарантий того, что это хоть куда-то в какой-то дотнет приедет, нет, но тем не менее, интересно, что дотнет-команда начала смотреть на то, как это можно сделать, что из этого можно сделать, как это все подружить с тасками, потому что надо помнить, у нас есть async/await и таски, вот это все.
5739.70 5745.46 "Игорь Лабутин" И там уже пришел Стивен Тауп чё-то ревьюить, так что движуха какая-то началась.
5745.46 5750.38 "Анатолий Кулаков" А ты уже примерно понимаешь, чем отличается green-3d от тасков?
5750.38 5751.74 "Игорь Лабутин" Пока не очень.
5751.74 5761.78 "Игорь Лабутин" Ну, то есть там pull-request это какие-то дебри рантайма и плюсов, ну в смысле это там нет какого-то внятного ища и описания, пока это чисто эксперименты.
5761.78 5764.06 "Игорь Лабутин" Вот, поэтому пока не ясно.
5764.06 5771.42 "Игорь Лабутин" Там есть какие-то кусочки текста про то, что ну мы скорее всего будем green-3d делать через таски, но это не точно.
5771.42 5772.42 "Игорь Лабутин" Вот.
5772.42 5787.42 "Игорь Лабутин" Я так понимаю, что сейчас, то есть идея green-3d в том виде, как она у них сейчас есть, это грубо говоря автоматическая асинхронность в визуально-синхронном коде.
5787.42 5816.22 "Игорь Лабутин" Ну то есть сейчас, если тебе нужно там, не знаю, сделать функцию, которая пошлет запрос на сервер через HTTP client, ты напишешь там какой-нибудь public async task, что-нибудь там send request, да, внутри ты скажешь там await HTTP client.sendasync и передашь какой-нибудь там реквест, да, в боди и там return, не знаю, там, response is ok, ну грубо говоря, я так очень грубо сейчас псевдокод накидываю.
5816.22 5817.22 "Игорь Лабутин" Вот.
5817.22 5826.78 "Игорь Лабутин" Но тебе нужно объявить функцию, что она async, она должна возвратить task, да, обязательно внутри надо написать await, вызвать обязательно версию sendasync, вот это все.
5826.78 5840.42 "Игорь Лабутин" Я так понимаю, что идея green-3d в том, что ты напишешь функцию public, там, bool sendrequest, да, внутри напишешь HTTP client.sendasync и типа return response.isok.
5840.42 5852.98 "Игорь Лабутин" То есть казалось бы, простой синхронный код, но он внутри будет знать, что sendasync у HTTP client, это функция, которая на самом деле должна быть выполнена синхронно и фактически автоматически преобразует эти две таски, ну до и после.
5852.98 5853.98 None Вот.
5853.98 5861.38 "Игорь Лабутин" Это, как я это для себя объясняю на данный момент, не знаю, насколько это соответствует той концепции, которую команда .NET знает.
5861.38 5876.34 "Игорь Лабутин" То есть, по сути, вот если ты возьмешь современный код, который сейчас напичкан асинкэвэйтами, выкинешь все асинкэвэйты, но сделаешь так, что они там останутся, в смысле runtime будет сам догадываться, что они там должны быть.
5876.34 5877.34 "Игорь Лабутин" Вот.
5877.34 5886.38 "Игорь Лабутин" Понятно, что такое можно сделать на API фреймворка, ну в смысле в STDlib, назовем это так, да?
5886.38 5898.34 "Игорь Лабутин" То есть известно, что там операции HTTP client какие могут быть асинхронные, что они будут приводить скорее всего к вводу-выводу на сокетах, там на, не знаю, на файл стрима, ну на файлах.
5898.34 5916.62 "Игорь Лабутин" То есть все такие места, если только в них хотя бы не нужно будет писать вейтов явных, мне кажется, для большого количества программ это будет прям, ну в каком-то смысле упрощение, потому что меньше boilerplate вот этого, ключевых слов, асинкэвэйтов.
5916.62 5921.74 "Анатолий Кулаков" Ну, если бы так можно было сделать, мне кажется, уже давно бы так сделали, даже сначала, когда сам концепцию
5921.74 5924.50 "Игорь Лабутин" изобретали. Ну, наверное, там все не так просто.
5924.50 5931.22 "Анатолий Кулаков" Конечно, ты же не можешь, например, запустить, не сможешь запустить несколько тасков и все их вместе подождать.
5931.22 5932.90 "Игорь Лабутин" Если у тебя нечего ждать, все не будет тасков.
5932.90 5936.54 "Игорь Лабутин" Погоди, тебе никто не запре… green3d не означает, что таски запрещены, ты можешь.
5936.54 5939.30 "Анатолий Кулаков" Ну как, если у тебя в сигнатуре их больше не будет?
5939.30 5940.78 "Анатолий Кулаков" Как ты их явно сделаешь?
5940.78 5946.02 "Анатолий Кулаков" У тебя возвращают метод bool, явно, а не явно, там идет под капотом, он запускает таски.
5946.02 5948.66 "Анатолий Кулаков" Как ты эти таски заиспользуешь для того, чтобы подождать?
5948.66 5954.62 "Игорь Лабутин" Пока не знаю, вот это вопрос API surface, ну вот этого всего, то есть, короче, не знаю.
5954.62 5963.02 "Игорь Лабутин" Возможно, метод будет возвращать таск от bool, да, и он автоматически будет понимать, что, ага, если ты написал return bool, то надо его обернуть в return tasks.fromresult от bool.
5963.02 5966.18 "Анатолий Кулаков" Ну, это слишком сложно, неявно будет и вообще непонятно.
5966.18 5972.18 "Игорь Лабутин" Вот именно поэтому, я так понимаю, что это одна из причин, почему эта фича настолько долго не делалась никак.
5972.18 5978.58 "Анатолий Кулаков" Ладно, давай посмотрим, как это будет развиваться, я думаю, что статейки тоже выйдут о том, зачем это вообще нужно.
5978.58 5986.86 "Игорь Лабутин" Пока это в runtime лобби, я думаю, что это будет максимум где-то какие-нибудь кусочки твиттера и так далее, вряд ли будут статьи, пока это настолько ранний прототип.
5986.86 5999.38 "Анатолий Кулаков" Я думаю, что статьи в Java нам примерно помогут сравнить эту штуку, потому что в любом случае люди будут сравнивать имплементацию в различных рантаймах, и скорее всего, какое-нибудь сравнение с дотнетом обязательно должно быть.
5999.38 6000.38 "Игорь Лабутин" Это да, ну посмотрим.
6000.38 6009.50 "Игорь Лабутин" Так, и дальше есть еще одна статья, которая практически не относится к дотнету, но на самом деле довольно полезная.
6009.50 6018.46 "Игорь Лабутин" Это на самом деле, по-моему, на гитхабе какая-то небольшая статейка про то, как выбирать open-source лицензию для своего проекта.
6018.46 6042.38 "Игорь Лабутин" То есть вот если вы задумываете свой open-source проект, то там гитхаб будет периодически писать, мол, типа вот, у вас не выбрана лицензия для этого проекта, надо выбрать, ну чтобы там правильно плашечка показывалась справа, и у вас возникнет вопрос, что выбирать, BSD, MIT, GPL, LGPL, их там, короче, очень много, а BSD бывает тоже разный на самом деле, если вы не знали.
6042.38 6051.74 "Игорь Лабутин" Так вот, это, короче, простая статья, в которой прям практически написан алгоритм типа, если то выбирать такую, если выбирать такую, иначе выбирать сякую.
6051.74 6057.14 "Игорь Лабутин" Короче, прям четко по шагам расписано, какую open-source лицензию, и чем они кратенько отличаются по смыслу.
6057.14 6061.34 "Игорь Лабутин" Вот, если вы когда-то интересовались этим вопросом, почитайте, будет интересно.
6061.34 6065.62 "Игорь Лабутин" Ну и на самый конец это конференции.
6065.62 6073.10 "Игорь Лабутин" У нас осень, осень это сезон конференций, и есть прям три штуки, про которые хочется рассказать.
6073.10 6082.90 "Игорь Лабутин" Во-первых, ну на самом деле четыре, да, во-первых, будет .NET Conf, конечно же, в ноябре, да, по-моему, с 8 по 10, это там, где будет объявлен релиз .NET.
6082.90 6089.38 "Игорь Лабутин" Выбор о него будем отдельно говорить, скорее всего, какие-нибудь хайлайты оттуда, естественно, расскажем, когда оно пройдет.
6089.38 6107.86 "Игорь Лабутин" Дальше JetBrains традиционно делает .NET Days, в этот раз это занимает онлайн-эвент, три дня, бесплатный, от 25 до 26 октября будет, собственно, часть, посвященная .NET, а 27 октября часть, точнее, целый день посвященный GameDev, Unity, вот это все, Unreal Engine, короче, туда.
6107.86 6116.10 "Игорь Лабутин" Если вы интересуетесь, заходите, смотрите, обычно там хорошие докладчики, и в .NET части, и, наверное, в GameDev тоже будет.
6116.10 6143.14 "Игорь Лабутин" Дальше Microsoft делает еще один, один ивент, называется Microsoft Ignite, он далеко не всегда .NET, он вообще, ну, вообще просто про какие-то новинки, нововведения, но в этот раз он довольно технический, мне кажется, он пройдет в октябре с 12 по 14, и там есть и .NET, в том числе, доклады, но и не только, там, например, будет, по-моему, Марк Русинович выступать, рассказывая про System Ternals, какую-то очередную штуку.
6143.14 6154.02 "Игорь Лабутин" Ну, в общем, если вы ждете от Microsoft каких-то более такого технического контента, кажется, что можно заглянуть на Microsoft Ignite и посмотреть, что там будет, по-моему, бесплатная абсолютно кафа онлайн.
6154.02 6156.90 "Анатолий Кулаков" А если мы хотим вообще более технического контента?
6156.90 6170.42 "Игорь Лабутин" Более технически известно, 3-4 ноября .NET будет в Москве, точнее, 3-4 он будет онлайн, а 20-го он будет и онлайн, и в Москве офлайн, ну, по крайней мере, пока план такий.
6170.42 6176.86 "Игорь Лабутин" Так что заходите на .NET, там будет технический контент на русском, все дело.
6176.86 6177.86 "Игорь Лабутин" Как мы привыкли.
6177.86 6181.62 "Анатолий Кулаков" Ну, и, скорее всего, нас с игре вы тоже там сможете поймать.
6181.62 6187.02 "Игорь Лабутин" Да, мы там будем стараться, ну, нас даже особо ловить не надо будет, убегать мы не будем, мы так.
6187.02 6188.46 "Игорь Лабутин" Ну, смотря кто вы такой.
6188.46 6192.46 "Игорь Лабутин" Есть какие-то цели, вы нас будете догонять, да.
6192.46 6193.46 "Игорь Лабутин" Может, и не будем.
6193.46 6194.46 "Анатолий Кулаков" Ладно.
6194.46 6197.22 "Анатолий Кулаков" Давай закругляться, счет у нас тут уже лимиты все прошли.
6197.22 6200.66 "Игорь Лабутин" Да, ну, как, место на диске не закончил, значит, еще не прошли.
6200.66 6201.66 "Игорь Лабутин" Так что нормально.
6201.66 6202.66 "Игорь Лабутин" Еще можно.
6202.66 6223.22 "Игорь Лабутин" Да, сегодня мы поговорили про .NET 7, Redis Candidate 1, узнали про новый протокол экспериментальный веб-транспорт, который будет работать поверх HTTP/3, посмотрели, какие улучшения перфоманса завезли в 7 .NET для ARM64 платформы, узнали про систему рандома и как с ним все плохо и чем нужно пользоваться.
6223.22 6231.34 "Игорь Лабутин" Для Visual Studio 2022 вышли превью 17.4, превью 2 и 2.1 для Mac, главное не запутаться.
6231.34 6247.30 "Игорь Лабутин" При этом в Visual Studio 2022 у нас новая модель расширений и Мэтт с Кристенсом там фигачит их с неверенной скоростью, так что смотрите, следите за ним, может какой-то новый интересный экстенджер появится и вы его тут же первым схватите.
6247.30 6265.62 "Игорь Лабутин" Поговорили про архитектуру и как там поддерживать простоту, узнали про ReSharper, Rider, Roadmap и то, что вышел первый E-App, послушали о чем же слушает Толя, какие подкасты и пробежались по мелким новостям, которые тоже могут быть интересными, ктузы, конференции, полезные статьи.
6265.62 6281.58 "Анатолий Кулаков" Прекрасно, большой интересный содержательный выпуск, спасибо всем, кто дослушал нас до конца, напоминаю, что нас нужно слушать больше, рассказать друзьям, шарить, репостить, лайкать, писать комменты и всячески присылать нам какие-нибудь новые интересные статьи и новости.
6281.58 6286.38 "Игорь Лабутин" Да, это был 58 выпуск радио Тутнет, с вами были Игорь
6286.38 6289.42 "Анатолий Кулаков" Лaбутин и Анатолий Кулаков, всем пока.
6289.42 6289.78 "Игорь Лабутин" Всем пока.
