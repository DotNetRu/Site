0.00 10.66 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет выпуск номер 49.
10.66 13.28 "Анатолий Кулаков" И сегодня в студии будут Анатолий Кулаков.
13.28 16.00 "Анатолий Кулаков" И Игорь Лабутин, привет.
16.00 21.92 "Анатолий Кулаков" Выражаем особую благодарность за помощь и спасибо вам большое, друзья, за то, что поддерживаете нас.
21.92 28.48 "Анатолий Кулаков" Сейчас в основном Патреон нас практически забанил, поэтому в основном наши патроны перелезли на бусте.
28.48 31.76 "Анатолий Кулаков" И вот именно этих драгоценных наших любимых слушателей.
31.76 37.24 "Анатолий Кулаков" Александр Сергеев, Владислав, Алексей, Шевченко Антон, Илья и Игорь Исамарин.
37.24 45.28 "Анатолий Кулаков" Большое спасибо, что находитесь с нами и соответственно поддерживаете нас и пишите в чате эти интересные штучки.
45.28 53.84 "Анатолий Кулаков" Вот если вы захотите присоединиться к этому списку, то заходите на бусте и там прочитайте, как попасть в наш секретный чат и что еще можно за это получить.
53.84 58.24 "Анатолий Кулаков" Так, непосредственно к темам.
58.24 68.76 "Анатолий Кулаков" У нас сегодня ожидается хардкорчик, я смотрю здесь и статьи про символы и про майони.
68.76 80.68 "Анатолий Кулаков" Я думаю, самое главное, самое долгожданное, это, конечно же, все-таки обсудить то, что у нас скоро прекращается поддержка Дотнет 5.
80.68 84.64 "Анатолий Кулаков" Казалось бы, не только недавно вышло и уже все, конец.
84.64 87.00 "Анатолий Кулаков" Как такое произошло, Игорь, куда дели наш Дотнет 5?
87.00 90.48 "Игорь Лабутин" Ну, пятый Дотнет был зарелизлен уже давным-давным-давно.
90.48 96.64 "Игорь Лабутин" Это в 2000, получается, в каком, в 2010 году, ой, в 2020 году,
96.64 99.16 "Анатолий Кулаков" не настолько конечно давно. Ну, всего два года, не то чтобы совсем давно прямо.
99.16 114.92 "Игорь Лабутин" Ну да, но тем не менее, Дотнет 5 это не LTS на релиз, это означает, что он поддерживается 18 месяцев после релиза или ну, фактически 6 месяцев после следующего релиза, который был LTS, это Дотнет 6.
114.92 126.00 "Игорь Лабутин" И 6 месяцев с этого момента как раз заканчивается 8 мая 2022 года, так что в этот момент пятый Дотнет перестанет поддерживаться, к нему перестанут выходить секьюрити апдейты.
126.00 140.80 "Игорь Лабутин" Надо понимать, что у нас, конечно, есть шестой Дотнет, это текущая LTS-версия, которая будет поддерживаться 3 года, но есть еще и более старые, это Дотнет Core 3.1, который тоже LTS и тоже пока еще поддерживается.
140.80 170.88 "Игорь Лабутин" Но он тоже не вечен, и Дотнет Core 3.1, у него поддержка истечет в декабре 2022 года, то есть уже к концу этого года, поэтому если у вас есть какие-то проекты на пятом Дотнете, то вам нужно уже довольно срочно их переделывать на шестой, что должно быть довольно просто, потому что переход практически безболезненный, есть официальная страничка со списком breaking changes, но их не так много, и в целом все должно завестись для большинства проектов прямо так.
170.88 185.72 "Игорь Лабутин" А если же у вас проект на Дотнет Core 3.1, то тогда нужно, возможно, будет чуть больше поработать, но тоже по опыту, по статьям в интернете вижу, что с 3.1 на 6.0 переход тоже не такой, что прям суперсложный.
185.72 208.56 "Анатолий Кулаков" У меня как-то в памяти отложилось, вот все такие основные Дотнет Core проекты, они как раз такие держатся на 3.1 и пятом, ну наверное, потому что 3.1 это такой самый быстрый, самый популярный, самый доделанный SEO Дотнет Core, а пятый это первая версия, которая попыталась объединить вот это все, что у нас там накопилось, и в том числе даже сам ребрендинг, то есть первое новое имя, первая ветка, это как раз пятый.
208.56 219.44 "Анатолий Кулаков" Вот и как-то поразительно так совпало, что именно в один и тот же год они заканчиваются, и все дружно, наверное, как раз летят на Дотнет 6 LTS, который с нами еще надолго.
219.44 259.84 "Игорь Лабутин" Да, но надо помнить, что Дотнет 6 у нас поддержан только в студии 22, а соответственно студия, которая 2019, то есть 16.11, она использует пятый SDK, потому что была выпущена, когда шестого еще не было, и поэтому пятый SDK продолжит подставляться вместе со студией, и она будет его ставить, но при этом это нужно только для того, чтобы поддерживать сборку для Дотнет Core 3.1, чтобы студия продолжила работать, и это будет продолжаться собственно до декабря 2022 года, после чего, видимо, все должны будут строго перейти на 22 студию, потому что только она будет поддерживаться дальше.
259.84 272.00 "Анатолий Кулаков" Ну, хорошо, отлично, я думаю, что все, кто хотел, должны уже запланировать переход на Дотнет 6, все, кто не хотел, уже самое время захотеть, поэтому не отставайте.
272.00 291.40 "Игорь Лабутин" Ну да, как я сказал, переход на 6 должен быть достаточно безболезненным, если будет что-то совсем попадаться в интернете вопиющее и сложно переводимое, мы про это обязательно будем рассказывать, чтобы все знали, как же это сложно, но пока создается впечатление, что все происходит довольно гладко.
291.40 302.44 "Анатолий Кулаков" Ладно, это все лирика, давай, и вот самое того, чего я жду, это новые заметки от Маони, я видел, ты добавил, это всегда прекрасно, всегда интересно, ну просто нам сегодня зажжешь.
302.44 320.52 "Игорь Лабутин" Маони, я так понимаю, что в 7 Дотнете сейчас активно занимается тем, что пушит новую тему с регионами, значит, давайте вспомним, во-первых, вообще, что такое Garbage Collector, да, как он работает, и что внутри него находится, чтобы понять вообще, о чем статья.
320.52 340.76 "Игорь Лабутин" Мы уже когда-то давно упоминали предыдущую статью Маони, где она говорила, что вот работая с сегментами внутри Managed Heap, она не очень удобная, есть свои недостатки, и поэтому надо как-то с этим что-то делать, и вот придумали штуку с регионами.
340.76 356.76 "Игорь Лабутин" Значит, давайте вспомним, что у нас Garbage Collector, да, Heap, над которым он, так сказать, заведует, состоит из нескольких поколений, да, 0, 1, 2, ну и отдельно Large Object Heap, и теперь у нас есть еще Pinned Object Heap.
356.76 393.84 "Игорь Лабутин" Соответственно, 0 и 1 поколение исторически до текущего момента, до 6-го Дотонета включительно, живут в так называемых, ну вообще, на самом деле, все поколения живут в сегментах, это такие длинные куски памяти, которые достаточно большие, их количество зависит от количества там процессоров, кучи и так далее, но мы всегда знаем, что 0 и 1 поколение всегда живет в рамках одного сегмента, и не может быть никак иначе, ну а 2 поколение имеет, соответственно, столько сегментов, сколько надо, так же, как и Large Object Heap.
393.84 418.04 "Игорь Лабутин" Вот, проблема состоит в том, что эти сегменты по дефолту, ну, довольно большие, то есть, если мы берем такое нормальное серверное приложение, да, на хорошем сервере, у вас один сегмент будет 1 ГБ по дефолту памяти, и это довольно много, если у вас при этом есть серверное приложение, которое кушает не очень много памяти, у вас будет, ну, по сути, зааллоцирован на 1 ГБ памяти.
418.04 425.72 "Игорь Лабутин" Дальше надо вспоминать, что такое allocate памяти в Windows, ну и не только в Windows, на самом деле.
425.72 432.04 "Игорь Лабутин" Вы можете зааллоцировать кусочек виртуальной памяти, но вы не обязательно будете ставить в соответствие физическую память.
432.04 449.48 "Игорь Лабутин" Это называется committed, committed или uncommitted memory, то есть, если у вас есть соответствие с физической памятью, это называется committed memory, и именно это, понятное дело, тратит реальную память вашей железки, потому что пока вы аллоцируете в виртуальную память, это, в общем-то, бесплатно.
449.48 472.96 "Игорь Лабутин" И дальше возникает такой момент, если ваше приложение активно работает с памятью, особенно во всяких там вторых поколениях, или в large object heap, то вы можете, например, какие-то создавать большие массивы, потом их освобождать, потом их снова создавать, потом снова освобождать, и у вас в этих вот сегментах, которые довольно большие по размеру, могут образовываться дырки в середине из неиспользуемых областей.
472.96 495.16 "Игорь Лабутин" И было бы неплохо их отдать обратно Windows, и это, в принципе, технически можно сделать, мы можем декоммитнуть кусочек серединки, например, этого области, но это не очень удобно, это все нужно будет, опять же, драггать, это все нужно будет помнить, и поэтому дефолтное поведение, оно простое, мы всегда декоммитим только в конце.
495.16 508.52 "Игорь Лабутин" То есть, если у вас есть большой сегмент, в нем, допустим, занята первая треть, ну, последние две трети по определенным сценариям, garbage collector может декоммитнуть и отдать обратно операционной системе для других приложений.
508.52 534.64 "Игорь Лабутин" Поскольку сегменты большие, то вероятность того, что все у вас будет сгруппировано в самом начале, ну, она, откровенно говоря, не очень велика для нулевого и первого поколения, это еще хоть как-то, потому что они по дефолту являются, соответственно, сборкой мусора с уплотнением, compacting garbage collection, и, соответственно, объекты будут подвинуты вперед в начало сегмента, если нет пининга, то есть нету каких-нибудь нативных вызовов.
534.64 542.00 "Игорь Лабутин" А вот с large object heap там все не очень здорово, потому что по дефолту large object heap, как мы знаем, не компактится.
542.00 558.84 "Игорь Лабутин" В результате все это приводит к тому, что вроде как ваше приложение памяти-то может использовать не очень много в реальной работе, но за счет всяких таких пауз, дырок и всего остального внутри сегментов реальный размер физической памяти, который использует ваше приложение довольно велико.
558.84 561.24 "Игорь Лабутин" И родилась идея, давайте уменьшим размер сегментов.
561.24 567.64 "Игорь Лабутин" Но тогда с ними можно будет работать по-другому.
567.64 582.72 "Игорь Лабутин" Плюс, ну или минус этого подхода заключается в том, что мы уже не можем больше говорить, что, например, поколение 0 и поколение 1 будут влезать в один такой сегмент, потому что он будет довольно маленький.
582.72 594.92 "Игорь Лабутин" И это действительно так, потому что размер одного такого сегмента, который теперь будет называться регионом, он всего 4 мегабайта по дефолту на 64-битной операционке.
594.92 601.80 "Игорь Лабутин" И понятно, что в 4 мегабайта ни одно поколение целиком скорее всего не влезет для такого типичного приложения.
601.80 606.28 "Игорь Лабутин" Поэтому каждое поколение будет состоять из кучи таких регионов.
606.28 616.36 "Игорь Лабутин" И минус состоит в том, что теперь нельзя так, например, легко управлять, допустим, нулевым первым поколением, зная, что они всегда в одном сегменте.
616.36 633.04 "Игорь Лабутин" А другой бонус состоит в том, что, например, если вы в нулевом поколении нашли какие-то объекты, на которые есть ссылка, скажем, из второго поколения, то сейчас вам ничто не мешает взять и запромоутить его сразу во второе поколение, просто пометив, что эти регионы теперь во втором поколении.
633.04 641.72 "Игорь Лабутин" То есть появляется возможность довольно динамично и гибко работать с тем, как объекты гуляют туда-сюда между поколениями.
641.72 644.80 "Игорь Лабутин" Про это, собственно, и была прошлая статья от Маони.
644.80 653.00 "Игорь Лабутин" А в этой статье разговор идет про то, а как же мы, собственно, будем отдавать память обратно Windows, ну или определенно на системе.
653.00 657.28 "Игорь Лабутин" В основном это пока, конечно, про Windows, но я про это чуть дальше скажу.
657.28 666.00 "Игорь Лабутин" И как это позволит, собственно, улучшить или изменить, точнее, работу с памятью.
666.00 668.92 "Игорь Лабутин" А улучшить или нет, это будет зависеть уже от ваших сценариев.
668.92 675.32 "Игорь Лабутин" Итак, во-первых, про регионы и то, в каком состоянии они сейчас находятся.
675.32 681.00 "Игорь Лабутин" Регионы сейчас находятся в состоянии, что в следующем .NET 7 Preview они будут включены по умолчанию.
681.00 691.24 "Игорь Лабутин" Вот сейчас у нас актуально, если я правильно помню, .NET 7 Preview 2, вот ближайший, который выйдет, я надеюсь, в апреле, там будут уже включены регионы.
691.24 692.24 "Игорь Лабутин" Это первое.
692.24 697.48 "Игорь Лабутин" Второе, они доступны только на 64-битных операционках.
697.48 702.24 "Игорь Лабутин" То есть если вы возьмете какой-нибудь 32-битный SDK, там регионов нет, там все по старинке.
702.24 709.12 "Игорь Лабутин" И третье, они не работают сейчас на MacOS.
709.12 716.00 "Игорь Лабутин" Непонятно почему, я не копал настолько детально, но вот не работают пока.
716.00 733.76 "Игорь Лабутин" Надо понимать, что это все очень предварительно, именно поэтому эти все регионы так включаются заранее в релизном цикле, фактически за полгода до релиза, чтобы посмотреть, как это все будет вести себя на больших ворклоудах, на маленьких ворклоудах, не нужно ли что-то тюнить, и все это может поменяться.
733.76 738.04 "Игорь Лабутин" То есть то, что мы сейчас рассказываем, может быть, будет актуально в течение условного апреля-мая, и потом все поменяется.
738.04 740.32 "Игорь Лабутин" Но от этого тема не становится менее интересной.
740.32 759.32 "Игорь Лабутин" И самая главная метрика, за которой будут следить, это конечно размер кучи, потому что фактически тот самый размер кучи, это то, сколько реальной памяти кушает приложение, сколько вы закоммитили у операционной системы.
759.32 764.96 "Игорь Лабутин" Как ведет себя Garbage Collector, когда ему нужно больше памяти?
764.96 780.60 "Игорь Лабутин" То есть вот представим, что мы выделили на виртуальной памяти какой-то кусочек, будь то это сегмент или будь это регион, и дальше мы дошли до места в этом регионе, в котором нет еще ассоциированной физической памяти, то есть мы еще не закоммитили этот кусочек.
780.60 781.84 "Игорь Лабутин" Какие могут быть сценарии?
781.84 787.84 "Игорь Лабутин" Ну можно сделать простой сценарий, закоммитить одну страничку, 4-8 килобайт, и пойти дальше.
787.84 800.04 "Игорь Лабутин" Но понятно, что это не очень эффективно, потому что коммит памяти - это системный вызов, и поэтому было бы здорово коммитить их несколько штук сразу.
800.04 818.88 "Игорь Лабутин" Выбрана волшебная константа 16, как любят программисты, и поэтому по дефолту конечно коммитится либо 16 страниц, либо минимальное необходимое количество, если размер объекта превышает 16 страниц, например, если вы аллоцируете в какой-нибудь очень большой массив, в large object heap, сразу он там конечно зааллоцирует нужное количество, закоммитит нужное количество страничек.
818.88 823.00 "Игорь Лабутин" А вот интересно с декоммитом.
823.00 832.12 "Игорь Лабутин" Допустим прошел garbage collector, и он почистил какие-то объекты в конце региона или сегмента.
832.12 835.80 "Игорь Лабутин" Когда можно отдать операционке обратно эту память?
835.80 847.96 "Игорь Лабутин" С одной стороны, было бы странно отдавать эту память, если мы понимаем, что эта память нам будет сейчас тут же сразу нужна, потому что, например, на следующей итерации какого-нибудь алгоритма мы снова выделим большой объект.
847.96 852.88 "Игорь Лабутин" Но мы не знаем заранее, сделали мы это или нет.
852.88 865.12 "Игорь Лабутин" С другой стороны, долго держать закоммиченную память тоже как-то не хочется, потому что мы бесполезным образом отбираем у других приложений и у операционной системы физическую память.
865.12 867.56 "Игорь Лабутин" Но мы тоже не знаем, на сколько долго мы будем это все держать.
867.56 886.44 "Игорь Лабутин" И последний момент, который я уже говорил, мы хотим декоммититься только в конце сегмента или региона, потому что держать еще один какой-нибудь список декоммитнутых кусочков из серединки это довольно сложно, поэтому делается такое только в конце.
886.44 890.76 "Игорь Лабутин" Что мы делаем с сегментами?
890.76 902.40 "Игорь Лабутин" Сегментами, как я сказал, что для нулевого первого поколения дефолтный размер — это 1 гиг для сегмента.
902.40 910.60 "Игорь Лабутин" Для large object heap и pinned object heap там по дефолту 256 мегабайт выделяется, но очевидно, что поскольку это large object heap, то она может довольно быстро вырасти.
910.60 917.60 "Игорь Лабутин" Дальше, policy для decommit довольно простая.
917.60 934.24 "Игорь Лабутин" После того, как прошел полный блокирующий garbage collector, то есть вообще full GC, то мы возьмем сегмент, где живет нулевое и первое поколение, то есть это, соответственно, то, что называется ephemeral segment.
934.24 946.72 "Игорь Лабутин" У garbage collector есть так называемый allocation budget, то есть это некоторая эвристика, сколько может выделить памяти garbage collector до следующего срабатывания garbage collector.
946.72 952.52 "Игорь Лабутин" Ну, не garbage collector, конечно, выделить память, сколько можно выделить памяти до следующего срабатывания garbage collector.
952.52 961.72 "Игорь Лабутин" Именно столько памяти мы оставляем за коммитменты, а все остальное из хвоста сегмента декоммитим обратно операционке.
961.72 968.68 "Игорь Лабутин" Именно это вы видите, когда вы, например, вызываете garbage collector и у вас уменьшается потребление памяти процесса.
968.68 970.88 "Игорь Лабутин" Вот это значит, что произошел декоммит.
970.88 982.60 "Игорь Лабутин" Бывают случаи, когда вы вызываете GC, вроде как, ну там, вы знаете по логике вашей работы кода, что у вас должны освободиться какие-то объекты, но при этом количество памяти, видимо, у какого-то task manager не уменьшается.
982.60 987.40 "Игорь Лабутин" Это значит, что освободилось настолько мало, что garbage collector принял решение не декоммитить память.
987.40 999.20 "Игорь Лабутин" Или его allocation budget, то есть эвристика, сколько он скоро будет allocated, она довольно большая и, соответственно, он тоже себе придерживает пока память, потому что нужно будет снова коммитить.
999.20 1009.64 "Игорь Лабутин" И раньше, до пятого .NET, декоммит происходил прямо во время garbage collection, то есть он входил в garbage collection.
1009.64 1033.36 "Игорь Лабутин" Начиная с пятого .NET, политика немножко поменялась и теперь декоммит происходит после того, как garbage collector закончился, все трэды приложения запустились, а один из garbage collector трэдов, но он же всё равно ничего не делает до следующего garbage collector, он будет заниматься как раз таки тем, что будет декоммитить память, выбранную во время garbage collection.
1033.36 1043.88 "Игорь Лабутин" Для при этом, кстати, сегментов, в которых лежат второе поколение, large object heap и pinned object heap, там всё просто, мы нашли последний живой объект и после него всё декоммитнули.
1043.88 1053.72 "Игорь Лабутин" Там всё просто, потому что в large object heap и во втором поколении там могут быть дырки в серединке и аллокатор надеется, что он в эти дырки будет аллокиятить объекты.
1053.72 1073.24 "Игорь Лабутин" С регионами ситуация другая, с регионами соответственно они там могут быть 4 мегабайта, ну либо 32 мегабайта для large object heap, и они вроде как очень маленькие, там прям такую же логику применять сложно, потому что allocation budget может быть тупо больше даже, чем размер региона.
1073.24 1075.96 "Игорь Лабутин" Поэтому garbage collector работает немножко по-другому.
1075.96 1084.52 "Игорь Лабутин" Когда он понимает, что например какой-то регион полностью освободился от объектов в результате сборки мусора, он этот регион записывает просто в список свободных регионов.
1084.52 1089.28 "Игорь Лабутин" Ну такой типа как Raypool, да, в нормальном, знаете, такой пул таких свободных регионов.
1089.28 1093.88 "Игорь Лабутин" И здесь возникает тот же вопрос.
1093.88 1109.44 "Игорь Лабутин" С одной стороны мы не хотим держать слишком много этих свободных регионов, с другой стороны мы не хотим держать их слишком мало, потому что они могут потребоваться, а с третьей стороны возникает еще одна задачка, которой не было в прошлый раз.
1109.44 1111.20 "Игорь Лабутин" У нас есть список регионов.
1111.20 1122.72 "Игорь Лабутин" В некоторых из них, например, закоммичен первый мегабайт только, ну потому что там жил всего мегабайт, и так он и остался, всего один мегабайт из четырех, а в некоторых закоммичены все четыре мегабайта.
1122.72 1128.96 "Игорь Лабутин" Мы сейчас выделяем память, где нам нужно выделить, например, не знаю, один мегабайт.
1128.96 1135.92 "Игорь Лабутин" Возникает вопрос, какой регион взять, там где закоммичен ровно один мегабайт или там где закоммичены четыре мегабайта.
1135.92 1138.88 "Игорь Лабутин" Тоже логика, которую нужно где-то выбирать.
1138.88 1149.44 "Игорь Лабутин" Сейчас в дотнете решение такое, что всегда выбирается максимально закоммиченный регион, то есть если у вас есть выбор из двух, где есть один мегабайт, четыре мегабайта, то будет выбрано четыре мегабайта, даже если вам нужен всего один.
1149.44 1158.68 "Игорь Лабутин" Потому что, видимо, предположение в том, что если вам нужен один, вам возможно потребуется в этом же поколении скоро еще, а там уже память подготовлена.
1158.68 1165.36 "Игорь Лабутин" Дальше нужно понять, сколько регионов брать, тут все просто.
1165.36 1171.36 "Игорь Лабутин" Мы берем тот самый allocation budget и по нему, собственно, считаем, сколько регионов надо.
1171.36 1176.56 "Игорь Лабутин" Сколько целых регионов вмести allocation budget, ну столько и берем.
1176.56 1182.36 "Игорь Лабутин" А те регионы, которые висят в списке свободных, их когда-нибудь нужно возвращать.
1182.36 1183.36 "Игорь Лабутин" Вопрос когда.
1183.36 1200.00 "Игорь Лабутин" А тут опять же есть некоторая такая, ну не метрика, а эвристика, где сказано, что на данный момент, если регион пережил 20 сборов мусора, значит считаем, что он не нужен и можно его выкидывать.
1200.00 1203.04 "Игорь Лабутин" Ну пережил в смысле 20 штук в статусе свободного.
1203.04 1208.52 "Игорь Лабутин" То есть если он довольно долго висит в списке свободных, ну как бы выкидываем пока.
1208.52 1222.20 "Игорь Лабутин" Пока это фиксированная константа, но говорят, что это скорее всего к релизу поменяется, если вся эта идея вообще будет жить, то скорее всего это все будет как-то динамически джаститься в зависимости от паттернов использования.
1222.20 1224.88 "Игорь Лабутин" Какие из этого всего можно сделать выводы?
1224.88 1231.76 "Игорь Лабутин" Ну выводы в смысле к чему приведет вся эта история с регионами и изменением того, как кормить коллектор.
1231.76 1235.24 "Игорь Лабутин" Казалось бы, всего лишь декоммитит обратно память в операционную систему.
1235.24 1257.08 "Игорь Лабутин" Во-первых, вы увидите в вашем приложении, что на старте, поскольку на старте у нас память аллокейтится довольно активно, allocation budget растет, то скорее всего у вас committed память будет расти чуть более агрессивно, чем она растет с сегментами.
1257.08 1271.08 "Игорь Лабутин" Потому что мы аллокейтим целым количеством регионов, да, и если у вас там allocation budget, не знаю, 5 мегабайт, то вам нужно в данном случае будет аллокейтить 8, потому что регионы по 4 мегабайта.
1271.08 1285.12 "Игорь Лабутин" Второй момент, когда у вас приложение переходит в стабильное состояние, то у вас будет происходить, то есть дальше будет сильно зависеть от паттерна использования памяти.
1285.12 1289.44 "Игорь Лабутин" И вот это как раз-таки тот самый момент, где команда не очень уверена, что будет.
1289.44 1300.12 "Игорь Лабутин" Будет ли чуть-чуть больше потребление по сравнению с сегментами или чуть-чуть меньше потребления по сравнению с сегментами, это то, что нужно будет мониторить и надо будет смотреть.
1300.12 1323.24 "Игорь Лабутин" Поскольку есть тоже вопрос и проблема вот этого commit хвоста региона, надо его коммитить, не надо коммитить, и для регионов это может быть важно, потому что если у вас есть много свободных регионов и в каждом из них там закоммичен лишний хвостик, это на самом деле может, так скажем, добавлять довольно много к использованию памяти.
1323.24 1330.60 "Игорь Лабутин" У вас есть возможность влиять на размер региона, то есть на размер сегмента, насколько я помню, влиять было нельзя, ну или я по крайней мере не знаю таких настроек.
1330.60 1348.16 "Игорь Лабутин" Но на размер региона можно менять, можно поставить переменное окружение dotnet подчеркивание gc_region_size, она должна быть обязательно степенью двойки, значение естественно, в 16-ти ричном виде, и вы можете, например, создать его размер региона равным 1 мегабайтам.
1348.16 1366.88 "Игорь Лабутин" Он будет меньше, у вас будет меньше этих хвостиков, которые возможно закоммичены, но не используются, но за счет естественно, оверхеда на то, что у вас списки свободно будут расти, время поиска в этих списках будет расти, ну и надо смотреть на то, как ваше приложение себя ведет.
1366.88 1367.88 "Игорь Лабутин" Вот.
1367.88 1400.80 "Игорь Лабутин" И пока предположение состоит в том, что если у вас есть приложение, у которого есть много сборок второго поколения, которые бэкграундные, то есть не full-world, которые полностью top-the-world делают, а именно если он справляется в бэкграунде, в этом случае не делается компакшена, и как раз таки в случае с сегментами у вас образовывались бы много-много-много дырок в серединке.
1400.80 1406.96 "Игорь Лабутин" В случае с регионами эта штука должна помочь и скорее всего уменьшить потребление памяти.
1406.96 1407.96 "Игорь Лабутин" Вот.
1407.96 1437.40 "Игорь Лабутин" То есть пока, вообще по результатам прочтения статей, ну остальных статей на эту тему, кажется, что мнение команды, ну и Maoni в частности, примерно такое, что кажется штука прикольная, должна чему-то помочь, вроде по экспериментам помогает, но мы окончательно не уверены в результате для, так сказать, большинства приложений и непонятно вообще в каком состоянии это выкатывать в дот над 7, в финальный.
1437.40 1438.40 "Игорь Лабутин" Вот.
1438.40 1444.96 "Игорь Лабутин" Сейчас вы можете это попробовать, ну в смысле когда выйдет превьюшка, значит, как это можно попробовать?
1444.96 1454.80 "Игорь Лабутин" Можно дождаться превью 7 и поставить его и в нем это все будет, но на самом деле можно это даже сделать на шестерке, на дот над 6.
1454.80 1529.64 "Игорь Лабутин" Для этого нужно всего лишь собрать библиотечку CLRGC самостоятельно из исходничков, вот, и поставить переменное окружение com+ подчеркание gcname CLRGC.dll, в смысле, ну присвоить значение CLRGC.dll и тогда для gc будет использоваться эта собранная специальная библиотечка, как мы помним, начиная с какого-то дот нада, не помню, с 5, 6, gc сделали практически полностью pluggable, то есть мы можем подменять свой собственный и, соответственно, вот можно подменить на новый gc из 7 дот нада и он будет дальше прекрасно работать с 6 дот надом и посмотреть, как поменялось, причем, по мнению Маони это даже более правильный способ, хотя он и более сложный, потому что нужно собрать себе свой собственный gc, потому что вы не меняете весь остальной рантайм, то есть весь остальной рантайм остается шестеркой, вы только меняете gc, и это позволит вам более качественно посмотреть, поменялось ли что-то конкретно в вашем приложении из-за вот этих новых регионов и так далее, или не поменялось, потому что если взять 7 дот над, то это будет не очень честно сравнивать с текущим приложением на 6 дот над, потому что поменялся джит, поменялась там какие-нибудь оптимизации добавились, поменялась базовая библиотека и так далее, а тут вы только меняете один garbage коллектор и смотрите, что стало по-другому.
1529.64 1554.80 "Игорь Лабутин" Вот, так что если вы задумывались когда-нибудь, почему ваше приложение, например, использует столько памяти, хотя вроде не должно по логике, если вы знаете, что у вас большая фрагментация кучи, то посмотрите в эту сторону, поэкспериментируйте, может быть, это способ как раз-таки уменьшить фрагментацию кучи и существенно снизить память, которая потребляет ваше приложение.
1554.80 1559.56 None Ну что, достаточно ли это было хардкорно?
1559.56 1570.68 "Анатолий Кулаков" Да-да-да, прям хорошо пробрало, давно у нас такого не было, надеюсь меня на собеседованиях никогда об этом спрашивать не будут, но так чисто, чтобы развлечься, послушать всегда интересно.
1570.68 1593.00 "Анатолий Кулаков" Слушай, скажи, а вот у тебя, ну вот они сейчас собираются сделать такой большой шаг в седьмом дот-нете, если все-таки решаться и соберутся, и внедрять такую штуку, не слышал ли ты где-то, не читал, что достаточно у них статистики для того, чтобы принять подобное решение, потому что действительно все проекты разные и непонятно на каких нагрузках, в какое время года, при каком фазе луны это все вообще повлияет.
1593.00 1596.12 "Анатолий Кулаков" Как они будут все-таки в конце концов выбирать?
1596.12 1603.40 "Игорь Лабутин" Я подозреваю, что во-первых, уже были какие-то ранние прототипы, эксперименты, МАО не вряд ли бы просто так это бы внедряло.
1603.40 1632.36 "Игорь Лабутин" Второе, как я сказал, кажется, что они это внедряют на такой ранней превью стадии, чтобы успеть на вот этом дот-нете семь превью, там какой-нибудь третий или четвертый, успеть на нем опробовать какие-нибудь больших либо внутренние проекты, ну условный бинг завести на седьмом дот-нете, посмотреть что получится, да, или такая подопытная лошадка, или кто там, подопытная крыса, мышка, на которой тестируют все новые дот-нет венья.
1632.36 1645.52 "Игорь Лабутин" Вот, плюс, наверняка у них есть правильный набор каких-нибудь ферст-пати кастомеров, которые готовы пробовать ранний превью и смотреть, как их продукты ведут на новых версиях, где стало быстрее, где медленнее и так далее.
1645.52 1648.62 "Игорь Лабутин" Вряд ли они будут выкатывать это в релиз без хорошего тестирования.
1648.62 1655.88 "Анатолий Кулаков" Ну, просто я надеялся, что они не будут ждать, когда кастомеры скажут, что на наших данных вот здесь немножко что-то просело, что непонятно.
1655.88 1663.16 "Анатолий Кулаков" Все-таки мне казалось, что у них должно быть какой-то телеметрия, которую они постоянно отсылают и сами могут это мониторить и сами отслеживать.
1663.16 1670.76 "Игорь Лабутин" Ну, они-то это, может быть, и могут мониторить, но для того, чтобы что-то мониторить, нужно это что-то где-то запустить.
1670.76 1676.64 "Игорь Лабутин" То есть, все равно тебе нужен кастомер, который будет готов поставить, ну, перекомпилить свой продукт под седьмой превью.
1676.64 1681.92 "Анатолий Кулаков" Да, да, безусловно, вот внедрение в превью, это помогает вот эту часть проблем решить.
1681.92 1684.36 "Анатолий Кулаков" Главное, чтобы они потом понимали, что с этим делать.
1684.36 1685.84 "Анатолий Кулаков" Превью-то мы поставим.
1685.84 1701.04 "Игорь Лабутин" По тому, как рассказывала Маони, да, и в своих каких-то докладах, и когда я с ней общался, она говорила, что ну, у них есть, так скажем, правильный набор, правильные способы сбора метрик вот с таких вот early adopters.
1701.04 1711.20 "Игорь Лабутин" Они тщательно мониторят, что там происходит и собирают, я так понимаю, довольно большую инфу о garbage collection, чтобы понимать вообще, стоит или не стоит такие изменения делать.
1711.20 1736.56 "Игорь Лабутин" Потому что, как мы помним, по-моему, я это где-то говорил, что вообще подход .NET, ну и Маони в частности, да, к тому, как делать garbage collection, он разительно отличается от Java, да, задавали такой вопрос, как бы вот в Java там огромное количество разных garbage collectors заточенных то на то, то на это, то на там минимальные паузы, то на минимальное потребление памяти, то еще на что-нибудь.
1736.56 1741.04 "Игорь Лабутин" И Маони говорила, что наша цель сделать максимально универсальный, который просто работает.
1741.04 1765.00 "Игорь Лабутин" В там 99% случаев, 99,99,99% случаев, а если вы там попадаете в те доли процента кастомеров, в котором все-таки что-то надо подхачить, ну у нас есть там 5 или там 10-15 этих переменных окружений, которые позволят вам, ну вот например, как я говорил, поменять размер региона зачем-то, вот.
1765.00 1772.60 "Игорь Лабутин" Или поменять, можно же вот эту волшебную константу 85 тысяч, да, где граница в Arch Object Hipe, ее тоже можно поменять.
1772.60 1781.20 "Игорь Лабутин" Но шансов, что вы именно такой кастомер, должно быть очень мало, ну в смысле, что .NET garbage collector дизайнится так, чтобы большинству хватало дефолтов.
1781.20 1782.44 "Игорь Лабутин" И вроде пока справляются.
1782.44 1785.48 "Анатолий Кулаков" Да, да, пока отлично получается, полностью согласен.
1785.48 1788.84 "Игорь Лабутин" Ну что, пойдем дальше во что-нибудь более простенькое?
1788.84 1791.64 "Анатолий Кулаков" Да, да, давай немножко отдохнем, расслабимся.
1791.64 1805.44 "Анатолий Кулаков" Как ты, наверное, знаешь, и, наверное, наши слушатели тоже, я часто ставлю над собой всякие эксперименты, регулярно, например, пытаюсь сидеть на Visual Studio без ничего, без всяких плагинов, чтобы посмотреть, что там все-таки наделали.
1805.44 1809.52 "Анатолий Кулаков" Вот, в этот раз у меня там какой-то огромный рекорд, это где-то около 50 минут.
1809.52 1825.08 "Анатолий Кулаков" Ну, то есть, пока я писал код, было все нормально, как только я пошел навигироваться, и особенно, когда пошел смотреть внутрь других проектов, не моих, соответственно, код, который я хотел бы увидеть, декомпилировать, у меня тут же начались проблемы.
1825.08 1833.36 "Анатолий Кулаков" И такое ощущение, что за все эти годы Visual Studio все-таки нормально не научилась ходить по сторонним сорцам и по сторонним символам.
1833.36 1839.32 "Анатолий Кулаков" И как раз в эту тему тут наткнулся на статейку, которую просто обязательно нужно осветить.
1839.32 1846.72 "Анатолий Кулаков" Тем более, что я знаю, что не все разработчики до сих пор понимают, как правильно делать так, чтобы их библиотечке легко было дебажить.
1846.72 1854.44 "Анатолий Кулаков" Потому что обычно там пишут какое-нибудь приложение под себя, оно одно, дебажится прекрасно и никаких проблем не испытывает.
1854.44 1868.76 "Анатолий Кулаков" Если у вас там есть какие-нибудь микросервисы с SDK, с клиентами или сторонние пакеты, которые вы ставите из Nuget, у вас очень часто возникает такое желание посмотреть внутрь и узнать, как та или иная штука работает.
1868.76 1872.60 "Анатолий Кулаков" И смотреть вам хочется все это как-то более-менее в приличном виде.
1872.60 1875.28 "Анатолий Кулаков" Ну, давайте начнем сначала.
1875.28 1893.56 "Анатолий Кулаков" Как вы уже, наверное, поняли, говорить мы будем про Go to Definition, Find Symbol Usages и прочие вот эти вещи, которые позволяют не на синтаксическом уровне, а уже непосредственно символьном определить все зависимости какого-то элемента и более того пройти внутрь и посмотреть из чего он состоит.
1893.56 1897.44 "Анатолий Кулаков" То есть заглянуть внутрь метода, который вам не принадлежит.
1897.44 1908.72 "Анатолий Кулаков" И если в принципе все эти символы объявлены внутри вашего какого-то проекта или референсные проекты, которым у вас есть исходники, и они компилятся в рамках вашего solution, то проблем никаких нет.
1908.72 1917.08 "Анатолий Кулаков" Вы просто нажимаете F12 и проваливаетесь спокойно в боди того метода или того свойства, или того класса, который вы хотите посмотреть.
1917.08 1919.00 "Анатолий Кулаков" Visual Studio с этим прекрасно справляется.
1919.00 1928.28 "Анатолий Кулаков" Но что делать, когда исходников искомой библиотеки, интересующего вас метода, у вас нет?
1928.28 1930.52 "Анатолий Кулаков" Соответственно, Visual Studio пытается их найти.
1930.52 1942.64 "Анатолий Кулаков" И если ей найти не удалось, то она запускает lspy, который декомпилирует lcode из сборки и пытается вам его показать в более-менее читабельном виде.
1942.64 1951.84 "Анатолий Кулаков" К сожалению, это обычно очень плохой код, в том плане, что он совсем далек от настоящего кода, который пишал разработчик.
1951.84 1967.20 "Анатолий Кулаков" Прежде всего, там нет таких полезных штук, как комментарии, красивые, хорошие, правильные имена переменных и вот такие вещи, которые в ILLE не сохраняются, которые ILLE вообще не нужны для исполнения, для рантайма, поэтому он их и там не хранит.
1967.20 1989.80 "Анатолий Кулаков" А также lspy очень плохо справляется с каким-нибудь высокоуровневым кодом, например, если мы говорим про interpolated strings, он их представляет не в виде доллара и стресс-строчки, с которыми мы с вами привыкли, а в виде string-формата, в который, соответственно, раскладываются все эти interpolated на ILLE уровни.
1989.80 1992.20 "Анатолий Кулаков" Или те же самые async/await.
1992.20 2001.80 "Анатолий Кулаков" Скорее всего, вы их увидите в виде straight машины, которая более или менее там причесана, но выглядит все еще не как нормальный асинхронный код, который мы каждый день с вами пишем.
2001.80 2011.92 "Анатолий Кулаков" Вот такие вот маленькие баги, в принципе, делают ILLE SPY на практике очень слабо юзабельным.
2011.92 2013.60 "Анатолий Кулаков" Поэтому это выход плохой.
2013.60 2029.88 "Анатолий Кулаков" Правильный выход, это, конечно, найти исходники, найти исходные файлы того класса методов, свойств, которые изначально послужили сорцом для того, чтобы скомпилить эту дейлерку и смотреть непосредственно в них.
2029.88 2034.48 "Анатолий Кулаков" Для этого нам нужно проделать такой немаленький путь.
2034.48 2038.68 "Анатолий Кулаков" Прежде всего, нам нужно знать, что такое PDB.
2038.68 2049.24 "Анатолий Кулаков" Для того, чтобы хранить какую-то мета-информацию дополнительную о библиотеке, соответственно, был придуман формат, который расшифровывается как Programmed Database.
2049.24 2053.84 "Анатолий Кулаков" Это специальный формат, который хранит в себе разную дополнительную информацию.
2053.84 2062.40 "Анатолий Кулаков" Как вы знаете, наверное, в обычной сборке .NET, там благодаря Reflection сохраняется очень много всего полезного.
2062.40 2068.88 "Анатолий Кулаков" То есть практически все, что вы можете вытащить из Reflection, именно методов, типы, они там уже и так хранятся.
2068.88 2079.28 "Анатолий Кулаков" Вот если мы возьмем, например, плюсы, то там хранится вообще какой-то голый ассемблер, и абсолютно вся информация про именование и типы, она находится только в PDB.
2079.28 2088.32 "Анатолий Кулаков" У C# PDB содержат намного меньше полезной информации, но все еще являются неотъемлемой частью, если вы хотите чего-то подебажиться.
2088.32 2096.36 "Анатолий Кулаков" Соответственно, очень популярной практикой распространения PDB было просто-напросто хранить их рядом с DLL.
2096.36 2103.80 "Анатолий Кулаков" И это первый путь, куда Visual Studio пойдет искать PDB, просто посмотрит, лежат они рядом с DLL или нет.
2103.80 2111.72 "Анатолий Кулаков" И в принципе точно так же их вполне можно упаковать прямо в NuGet пакет, тоже вместе с DLL, и Visual Studio их прекрасно найдет.
2111.72 2118.60 "Анатолий Кулаков" Если же, тут нужно еще заметить, что PDB никак не влияют на рантайм.
2118.60 2126.04 "Анатолий Кулаков" То есть, чтобы вам не говорили, их можно распространять безболезненно, и это не зависит, по крайней мере, в худшую сторону.
2126.04 2132.76 "Анатолий Кулаков" Ни от чего не зависит, что рантайм вдруг случайно почему-то изменится, если вдруг PDB будет лежать рядом.
2132.76 2136.40 "Анатолий Кулаков" Есть некоторые тонкости, но они, наверное, больше в плюс, чем в минус.
2136.40 2142.92 "Анатолий Кулаков" Например, там более красивые стеки, стектрейсы у вас появятся, и вы можете более качественные сообщения об ошибках получать.
2142.92 2146.16 "Анатолий Кулаков" Но это, скорее всего, все.
2146.16 2153.72 "Анатолий Кулаков" Следующее место, где можно найти PDB, если вдруг рядом с DLL она не таскается, это посмотреть внутрь самой DLL.
2153.72 2168.12 "Анатолий Кулаков" Потому что появилось такое понятие, как Embedded PDB, и это можно увидеть только Portable PDB, и, соответственно, она попадает внутрь сборки и таскается вместе с ней.
2168.12 2185.52 "Анатолий Кулаков" Сделать это довольно легко, достаточно добавить XML-элемент DebugType Embedded внутри вашего проекта, и проект будет непосредственно внутри себя содержать PDB, она не очень большая, если мы говорим про Portable, и получаем довольно очевидные плюсы.
2185.52 2195.08 "Анатолий Кулаков" Очень легко распространять, то есть, вы можете действительно скопировать одну DLL, не заботиться о том, что рядом должен лежать какой-то PDB файл, какой-то XML файл, еще что-то.
2195.08 2196.48 "Анатолий Кулаков" Просто DLL копируете и все счастливы.
2196.48 2211.44 "Анатолий Кулаков" Ну и, соответственно, ваш уровень дебага, отладки, он очень сильно увеличивается, потому что уже отладчик знает о вашей программе намного больше информации, чем он мог бы знать из голой DLL.
2211.44 2217.40 "Анатолий Кулаков" Ну и, опять же, на рантайм это никак не влияет, поэтому минусов практически нет.
2217.40 2225.60 "Анатолий Кулаков" Единственный минус, да, это немножко увеличивается размер DLL, но обычно это не настолько критично, чтобы этим загоняться.
2225.60 2229.92 "Анатолий Кулаков" Третий путь найти PDB из популярных, это символ сервера.
2229.92 2249.52 "Анатолий Кулаков" Это специально выделенное какое-то программообеспечение, которое выставлено наружу, и оно позволяет вам сохранять, а также индексировать PDB для того, чтобы впоследствии дебагеры или любые другие DE могли ее скачать из этого общепринятого места и, соответственно, использовать в своих нуждах.
2249.52 2256.48 "Анатолий Кулаков" Символ сервера легко настраивается, вы их можете найти в Visual Studio, если зайдете по пути Tools, Options, Debugger, Symbols.
2256.48 2262.68 "Анатолий Кулаков" По умолчанию там есть символ сервера от Microsoft и Nuget, и, соответственно, вы можете их вязать.
2262.68 2284.72 "Анатолий Кулаков" Здесь нужно сказать, что практически у каждого уважающего себя какого-нибудь storage пакетов есть свой символ сервер, то есть вы можете подключить всякие ажуровские, магетовские символ сервера и свой приватный корпоративный символ сервер для того, чтобы таскать символы из ваших DLL-ик, из ваших проектов.
2284.72 2287.00 "Анатолий Кулаков" Все это тоже имеется.
2287.00 2299.64 "Анатолий Кулаков" Ну и бесплатный Nuget.org тоже поддерживает символы, если вдруг захотите их распространять с помощью вот такого пути, и ваш проект лежит, допустим, на GitHub, то обязательно это делайте.
2299.64 2304.92 "Анатолий Кулаков" Обязательно декларируйте миру о том, где и как у вас лежат символы и что с ними дальше надо делать.
2304.92 2315.12 "Анатолий Кулаков" Интересно, что вот этот весь путь, то есть где студия ищет PDB-шки, как она их проходит, как она их находит, его очень легко можно отследить.
2315.12 2323.08 "Анатолий Кулаков" Если вы зайдете, например, в Output Window, то там можно легко увидеть, где студия ищет все символы.
2323.08 2344.12 "Анатолий Кулаков" Или, если вы находитесь сейчас под дебаггером, то есть специальный ComboBox, где вы можете выбрать Show Symbol Load Information в Output, и там будет очень легко и подробно описано, что он пытался сделать, как студия пыталась найти, эти файлы нашла или нет, и куда она дальше пошла.
2344.12 2362.08 "Анатолий Кулаков" Если же вы находитесь без дебага, то, например, GoToDefinition делаете и пытаетесь зайти внутрь метода, то вы можете выбрать в том же Output, ComboBox Navigate to External Sources, и там тоже Visual Studio вам расскажет, каким образом она пыталась найти эти символы.
2362.08 2373.40 "Анатолий Кулаков" Очень полезная штука для того, чтобы отладить правильный процесс, для того же, чтобы настроить вашу студию под поиск правильных символов в правильных местах с правильными серверами.
2373.40 2379.04 "Анатолий Кулаков" И еще очень полезная окошко, это, конечно, Modules, которые тоже в Visual Studio находятся.
2379.04 2385.32 "Анатолий Кулаков" Она в Run-Time, то есть в Debug-Time, позволяет вам определить, какие символы и откуда она пыталась подтащить.
2385.32 2393.48 "Анатолий Кулаков" Там вы можете в окне модулей увидеть этот лог и непосредственно что-то, может быть, сделать, поправить ее или направить в нужное направление.
2393.48 2397.52 "Анатолий Кулаков" Тоже такая часто используемая вещь.
2397.52 2421.80 "Анатолий Кулаков" Так, после того, как мы нашли символы, в принципе, этого еще недостаточно для того, чтобы получить красивые исходники, потому что в символах хранится, конечно, очень много полезной информации для того, чтобы связать или код, связать непосредственно Assembly с вашими исходниками, но не сами исходники, а без того, чтобы получить вот непосредственно вот этот текст вместе с комментариями, с отступами, с пробельщиками, как положено.
2421.80 2428.72 "Анатолий Кулаков" Легче всего это сделать, получив просто непосредственно действительно настоящий текст, из которого это все компилировалось.
2428.72 2433.08 "Анатолий Кулаков" Поэтому следующий шаг, это нам нужно найти все-таки Source Code.
2433.08 2438.48 "Анатолий Кулаков" Как студия, соответственно, ищет Source Code?
2438.48 2440.56 "Анатолий Кулаков" Прежде всего, так же, как и PDB.
2440.56 2446.20 "Анатолий Кулаков" Если он хранится на диске и находится рядом с DLL, то она его найдет.
2446.20 2452.28 "Анатолий Кулаков" Если он за Embedded, что тоже как бы можно сделать, то она его тоже найдет.
2452.28 2459.96 "Анатолий Кулаков" И следующее, соответственно, она может сама скачать код с помощью технологии Source Link.
2459.96 2465.84 "Анатолий Кулаков" Source Link - это техника, которая дает возможность разработчикам выполнить отладку исходного кода.
2465.84 2476.96 "Анатолий Кулаков" Соответственно, Source Link внедряется при создании NuGet пакета и дописывает всякие различные метадаты, достает их из системы управления версиями.
2476.96 2479.16 "Анатолий Кулаков" В банальном случае это Git.
2479.16 2491.76 "Анатолий Кулаков" И, соответственно, разработчики, которые загрузили пакет, у которого включены Source Link, они могут отлаживать непосредственно тот исходный код, который во время билда был туда сложен.
2491.76 2499.76 "Анатолий Кулаков" Самая простая ассоциация - это когда вы билдите на GitHub, допустим, ваш проект, ну или вашем локальном Git-репозиторе, не суть важно.
2499.76 2507.36 "Анатолий Кулаков" У вас сохраняется имя репозитория, у вас сохраняется коммит, и соответственно, вот хэш-коммита.
2507.36 2530.04 "Анатолий Кулаков" И, соответственно, зная имя репозитория, и зная хэш-коммита, и зная имя файла, который вы хотите сейчас вытащить, студия вполне может пойти к удаленному серверу, например, к GitHub, попросить его именно вот этот репозиторий, который нужен, вот этот коммит, который нужен, и файлик, и закачать его непосредственно в ваше окно отладки.
2530.04 2537.32 "Анатолий Кулаков" И, соответственно, вы получаете идеальный тот код, прямо с которого это все компилировалось, с которого это все собиралось непосредственно в вашем окне отладки.
2537.32 2558.92 "Анатолий Кулаков" И третий способ, где студия может поискать, это, соответственно, если вы сделаете директиву Embed All Sources в вашем csproj файле или поставите ее в true, то, соответственно, все срцы упакуются вместе с SMLE внутрь пакета.
2558.92 2563.64 "Анатолий Кулаков" Вот это тоже очень популярный был способ распространения до того, как появился SourceLink.
2563.64 2566.12 "Анатолий Кулаков" Итак, немножко еще про SourceLink остановимся.
2566.12 2583.28 "Анатолий Кулаков" Как я уже сказал, это маппинг, который представляет из себя всего лишь на все небольшой документик, и в этом документике вот буквально есть абсолютный URL того репозитория и провайдер, каким образом к этому репозиторию обращаться, где лежат исходные коды.
2583.28 2592.68 "Анатолий Кулаков" И, соответственно, зная вот этот абсолютный URL, мы можем пойти и в непосредственно PDB-шках найти относительные пути.
2592.68 2596.12 "Анатолий Кулаков" Относительно этого URL мы знаем, какие классы в каких файликах лежали.
2596.12 2601.72 "Анатолий Кулаков" И, соответственно, это все, что нам нужно.
2601.72 2606.96 "Анатолий Кулаков" Коммит непосредственно Github URL, по которому лежит репозиторий и имя файлика.
2606.96 2618.36 "Анатолий Кулаков" С помощью SourceLink уже поддерживается огромное число провайдеров, например, GitHub, Azure DevOps, GitLab, то есть любой этот репозиторий.
2618.36 2639.12 "Анатолий Кулаков" Для него уже есть стандартный пакет, который достаточно подключить к вашему проекту, и во время билда он сам пропишет все необходимые SourceLink в NuGet Package для того, чтобы любой клиент, который отлаживает ваше приложение, мог скачать исходный код непосредственно из сервиса хранения исходников.
2639.12 2640.88 "Анатолий Кулаков" Кажется, что решение просто гениальное.
2640.88 2647.36 "Анатолий Кулаков" Не нужно не таскать их с собой, не нужно не заботиться о том, чтобы они где-то там лежали в сторонке, постоянно их хранить.
2647.36 2651.52 "Анатолий Кулаков" У нас уже есть гид, который хранит все версии всех исходных кодов.
2651.52 2653.88 "Анатолий Кулаков" Мы из этих версий автоматически собираем.
2653.88 2656.88 "Анатолий Кулаков" Вот мы у него и будем все эти файлики запрашивать.
2656.88 2661.16 "Анатолий Кулаков" Вот самая, по-моему, очевидная и понятная технология.
2661.16 2663.48 "Анатолий Кулаков" Жалко, что она появилась не с самого начала.
2663.48 2668.24 "Анатолий Кулаков" Но, в принципе, уже достаточно давно, поэтому можно использовать на любых проектах независимо.
2668.24 2670.12 "Анатолий Кулаков" Нет фреймворка, нет чего-то еще.
2670.12 2679.56 "Анатолий Кулаков" Соответственно, SourceLink поддерживает аутентификацию, кэширование и, в принципе, все как и положено.
2679.56 2684.36 "Анатолий Кулаков" Для того, чтобы его включить, вам нужны отдельные галочки в зависимости от IDE, которой вы пользуетесь.
2684.36 2688.36 "Анатолий Кулаков" Но обычно IDE-шки настроены так, что SourceLink потаскивает по умолчанию.
2688.36 2691.40 "Анатолий Кулаков" Вот, такая полезная технология.
2691.40 2694.60 "Анатолий Кулаков" Казалось бы, каждый разработчик должен о ней знать.
2694.60 2696.92 "Анатолий Кулаков" И поэтому, надеюсь, что вы теперь знаете тоже.
2696.92 2704.60 "Анатолий Кулаков" У меня, в принципе, для всех дефолтных проектов я использую Embedded PDB для того, чтобы таскать это все внутрь непосредственно Assembly.
2704.60 2710.48 "Анатолий Кулаков" И, соответственно, SourceLink для того, чтобы непосредственно доставать исходные коды из моего репозитория.
2710.48 2714.60 "Анатолий Кулаков" Вот, Игорь, ты пользуешься SourceLink?
2714.60 2724.12 "Игорь Лабутин" Да, для наших проектов внутренних у нас собирается все с SourceLink на наш внутренний репозиторий.
2724.12 2727.92 "Игорь Лабутин" Может, он не будет доступен извне, но так и задумано.
2727.92 2733.04 "Игорь Лабутин" Поэтому, если кто-то будет отлаживать наши DLL-ки со стороны, они будут видеть только PDB-шки.
2733.04 2736.64 "Игорь Лабутин" Ну, то есть, какие-то информации о символах они увидят, но не более того.
2736.64 2743.92 "Игорь Лабутин" А если они имеют доступ к нашему внутреннему серверу с исходниками, ну тогда будут и исходники.
2743.92 2756.88 "Анатолий Кулаков" Ну и все DLL-ки, в том числе, микрософтовские, в том числе практически все, что вы найдете из популярных библиотек на GitHub, что написано на C#, практически все это уже давно поддерживает SourceLink.
2756.88 2772.92 "Анатолий Кулаков" Поэтому так легко можно дебажить и ваши логеры, и ваши ISP-нет фреймворки, и Entity фреймворки, и JSON-сериализаторы, в общем, все, что вы используете каждый день, именно с помощью SourceLink вы можете подебажить, посмотреть, понавидироваться.
2772.92 2774.76 "Анатолий Кулаков" Все это удобно, красиво.
2774.76 2776.48 "Анатолий Кулаков" В общем, технология замечательная.
2776.48 2778.16 "Анатолий Кулаков" Не представляю, как мы раньше без нее жили.
2778.16 2783.64 "Анатолий Кулаков" Действительно перекладывали вот эти архивы с исходниками из одного пакетча в другой пакетч.
2783.64 2791.32 "Игорь Лабутин" Да, а потом студия говорила "Мне нужен файлик такой-то, такой-то .cs, что-то я не вижу его на диске, давай мы его найдем".
2791.32 2801.56 "Игорь Лабутин" И ты шел по дереву папочек, искал, где же этот файлик есть, потом находил, подсовывал, она говорила "Нет, это не та версия, она не подходит, собиралась не из того, ищи другой".
2801.56 2810.16 "Анатолий Кулаков" Да-да-да, самое обидное, что там если к такой-то пробельчик был в конце добавлен, то хэш уже не совпадал, и она уже начинала у него крышу сносить, не считала ее той же самой версией.
2810.16 2818.48 "Игорь Лабутин" Да, но там была волшебная галочка, позволять любую, но тогда возникало это прекрасное это f10f10f10 через пустые строчки внутри файла.
2818.48 2822.32 "Анатолий Кулаков" Да, много романтики мы потеряли, но почему-то мы по ней не скучаем.
2822.32 2824.80 "Игорь Лабутин" Ладно, пойдем дальше.
2824.80 2831.36 "Игорь Лабутин" Дальше у нас еще одна такая полезно-практическая тема, а именно JVT, ли авторизация, аутентификация.
2831.36 2850.12 "Игорь Лабутин" Мы про него периодически говорим, обычно в разрезе каких-нибудь новостей про Identity Server, но сейчас мы хотели бы про это поговорить немножко с другой стороны, а именно как вообще использовать JVT, ну и делать авторизацию на токенах, если мы не используем ASP.NET Core Identity.
2850.12 2861.24 "Игорь Лабутин" То есть ASP.NET Core Identity — это такая большая библиотека, можно сказать, которая позволяет сделать много чего, но на самом деле она не то чтобы обязательно, можно сделать довольно много без нее.
2861.24 2874.44 "Игорь Лабутин" И есть две статьи, на одной из них я наткнулся совсем недавно, она действительно вышла не очень давно, она была второй в серии, как выяснилось, первая статья в этой, назовем это, серии вышла ровно практически год назад.
2874.44 2898.00 "Игорь Лабутин" Но обе они довольно полезны, если вы занимаетесь тем, что в вашем C# приложении используете авторизацию на токенах, я советую вам почитать, потому что там есть некоторое количество полезных мыслей, и она довольно неплохо рассказывает о, так скажем, минимально необходимом наборе действий, про то, чтобы добавить авторизацию и аутентификацию в ваше приложение.
2898.00 2911.04 "Игорь Лабутин" Итак, мы конкретно в этой статье, это про Web API говорится и про то, что называется role-based authorization, то есть авторизация на основе ролей.
2911.04 2924.96 "Игорь Лабутин" Когда вы на ваших контроллерах или методах контроллера расставляете, соответственно, атрибутики authorize и указываете имя роли, вот сюда может пойти человек с такой-то ролью, сюда может пойти с такой-то ролью, ну или с набором ролей.
2924.96 2931.08 "Игорь Лабутин" Для того, чтобы это все сделать, во-первых, вам нужно включить аутентификацию.
2931.08 2938.96 "Игорь Лабутин" Мы помним, что у нас есть аутентификация, это выяснение, кто же к нам пришел, и авторизация - это выяснение, а что он имеет право у нас делать.
2938.96 2967.48 "Игорь Лабутин" Для того, чтобы сделать аутентификацию, мы делаем следующее, мы идем в method-configure-services, если вы пользуетесь еще старыми шаблончиками без minimal API, и задаем там огромное количество разных всяких параметров, но среди них довольно важные - это issuer, audience и ключик подписи, это то, что жизненно необходимо для того, чтобы ваши токены начали выдаваться вашим пользователям.
2967.48 2973.36 "Игорь Лабутин" При этом, ну как бы мы еще ничего не сделали для выдачи этих токенов, мы просто настроили некоторые параметры.
2973.36 2984.04 "Игорь Лабутин" В этом месте еще пока нет вообще ничего специфичного для каких-то конкретных ролей, это все будет позднее, это уже будет авторизация, мы пока говорим про аутентификацию.
2984.04 2997.20 "Игорь Лабутин" Дальше нам нужно конфигурировать middleware, в SPNetCore есть стандартный middleware, сначала нужно сказать useAuthentication, потом нужно сказать useAuthorization, использовать два экстендерных метода, там подключится правильный middleware.
2997.20 3001.24 "Игорь Лабутин" Нужно знать и помнить, что порядок очень важен.
3001.24 3019.64 "Игорь Лабутин" Классический рекомендуемый порядок в современном .NET, в современном SPNetCore, это сначала мы делаем useRouting, то есть чтобы мы уже в аутентификации понимали, с каким маршрутом мы имеем дело, и возможно в зависимости от маршрута использовали разные методы аутентификации, например.
3019.64 3028.40 "Игорь Лабутин" Дальше мы говорим useAuthentication, потом useAuthorization, и только после этого мы уже начинаем процесс маппинга в наши контроллеры.
3028.40 3044.72 "Игорь Лабутин" Для аутентификации мы, собственно, обычно делаем какой-нибудь анонимный контроллер, где есть какой-нибудь метод под названием логин или что-нибудь в таком духе, который принимает логин-пароль, условно говоря, от пользователя и возвращает токен.
3044.72 3064.12 "Игорь Лабутин" В токене мы сохраняем какую-то стандартную, скажем так, информацию для JWT токена, это кто пришел, то есть это subject name, логин пользователя или его ID, какой-то ваш внутренний, по которому вы будете потом понимать, кто это.
3064.12 3069.28 "Игорь Лабутин" А кроме этого вы можете туда добавить некоторое количество так называемых клеймов.
3069.28 3082.08 "Игорь Лабутин" Это некоторые свойства, которые токен подтверждает для заданного пользователя, то есть пользователь, который будет использовать такой токен, будет считаться имеющими или обладающими этими свойствами.
3082.08 3102.12 "Игорь Лабутин" В эти клеймы как раз можно запихнуть, в частности, в клейм-роли, то есть при аутентификации, то есть когда вы говорите логин, когда пользователь вам присылает свой логин-пароль, вы можете посмотреть свою локальную базу и понять, что, например, этот пользователь администратор или этот пользователь имеет право только на чтение, и соответствующую роль ему выдать в виде клейма и запихнуть его в токен.
3102.12 3115.12 "Игорь Лабутин" Вы можете запихивать как кастомные клеймы, но если вы будете использовать стандартное имя клейма, роль, то S/P/Naddcore будет работать лучше в том смысле, что вам не придется писать кастомный код.
3115.12 3116.12 "Игорь Лабутин" Дальше.
3116.12 3131.96 "Игорь Лабутин" После этого вы, собственно, нужно засекюрить саму API, и для этого вы навешиваете знакомые всем атрибуты Authorize, для каждого атрибутика прописываете, какие роли там нужны.
3131.96 3137.44 "Игорь Лабутин" Если не прописать, то будет достаточно любой, если прописать какие-то конкретные, то будет нужна конкретная роль.
3137.44 3154.28 "Игорь Лабутин" Ну а если вам вдруг нужен контроллер, которым нужно или должно быть заходить без авторизации и аутентификации, то вы пишете на нем allowAnonymous атрибутик, обычно как раз таки логин метод таким обладает, и после этого для него не нужна будет авторизация.
3154.28 3172.48 "Анатолий Кулаков" Я не могу тут не вставить Best Practice, потому что обычно рекомендуют как бы все к чертовой матери закрывать с помощью Authorize, то есть все API на уровне прямо фильтра, и только для тех контроллеров, которые вам специально нужно открыть, типа логина, вот там ставите только доступ для анонимуса, а по умолчанию должно быть все закрыто авторизацией.
3172.48 3187.20 "Игорь Лабутин" Да, но видишь, ты не можешь фильтром проставить, ну нет, технически ты можешь фильтром проставить авторизацию с разными ролями, но действительно полезно сделать фильтр глобальный на все, чтобы он точно был авторизацией, и где нужно кастомизировать уже с нужными ролями.
3187.20 3196.80 "Анатолий Кулаков" Да, действительно, роли потом отдельно все равно придется прописывать, но хотя бы ты знаешь, что если ты забыл поставить этот атрибут, забыл указать какую-то роль, у тебя туда никто не войдет.
3196.80 3199.16 "Анатолий Кулаков" И это уже хорошее поведение по дефолту.
3199.16 3215.16 "Игорь Лабутин" Ну или, например, по дефолту ставить authorize с ролью с минимальными привилегиями, то есть, например, по дефолту всем можно читать, но если ты авторизован, то можно читать, а для записи или для каких-то изменений ты должен быть админом или иметь claims с возможностью записи и так далее.
3215.16 3230.20 "Игорь Лабутин" Дальше, когда мы говорим про логин, логин, все, теперь у нас есть готовый логин, у нас есть готовый контроллер, и можно заходить и что-то авторизовываться, очень часто возникает вопрос логаута.
3230.20 3244.20 "Игорь Лабутин" И тут штука состоит в том, что авторизация на вот этих самых токенах, GVT, она сама по себе вот в том минимальном виде, как мы описали, логаут не поддерживает.
3244.20 3256.76 "Игорь Лабутин" То есть пока у токена не истекло время его жизни, а внутри каждого токена написано, на сколько он выдан, на сколько долго, когда он выдан и сколько он действует, то пока этот токен не истек, он будет валидный.
3256.76 3273.60 "Игорь Лабутин" И в принципе, вот та реализация, которую мы описали, будет такой токен принимать, даже если пользователь там, не, ну если вы его физически удалите из базы, ну наверное, по вашей логике, это уже дальше ваша логика контроллеров, допустим, в каком-нибудь кастомной авторизации уже поймет, что такого пользователя нет в базе.
3273.60 3275.76 "Игорь Лабутин" Но нативного алгоритма логаута нет.
3275.76 3300.04 "Игорь Лабутин" Если вам он нужен, то, во-первых, вы можете трекать выдаваемые токены в вашей базе, например, если пользователь нажмет кнопку логаут, то там помечать все выдаванные токены, как невалидные и это будет работать, но это будет работать ценой того, что на каждый вызов вашего API вам нужно будет ходить в базу и проверять вообще, валиден ли токен.
3300.04 3302.20 "Игорь Лабутин" Не только сам токен, сам по себе.
3302.20 3306.28 "Игорь Лабутин" Это можно проверить без дополнительных походов в базу, либо куда-либо еще.
3306.28 3313.16 "Игорь Лабутин" Но и валиден ли он логически для этого пользователя, или не валиден ли он отозван каким-то образом.
3313.16 3335.12 "Игорь Лабутин" Поэтому очень часто рекомендация говорит про то, что если вам не нужен прям строгий бизнес логаут, то просто выдавайте токены не очень долгие, то есть не надо выдавать токены на 24 часа, выдавайте их на 10-15 минут, 30 минут, в зависимости от ваших бизнес-условий, и тогда, возможно, именно честный логаут прям как таковой вам не нужен.
3335.12 3336.52 "Игорь Лабутин" Но это бизнес-требования.
3336.52 3340.08 "Игорь Лабутин" И все было бы хорошо.
3340.08 3341.68 "Игорь Лабутин" Собственно, на этом заканчивается первая статья.
3341.68 3350.52 "Игорь Лабутин" И она действительно такая хорошая статья, которая описывает базовые основы авторизации аутентификации понятным языком и с понятным примером.
3350.52 3352.12 "Игорь Лабутин" Но дальше возникает вопрос.
3352.12 3363.60 "Игорь Лабутин" У токены, вот эти самые JWT, их можно использовать только когда у вас клиент, ну он такой современный, там не знаю, single-page application, например.
3363.60 3367.16 "Игорь Лабутин" Это вот классический случай, когда используются такие токены.
3367.16 3375.68 "Игорь Лабутин" Но у вас может быть на самом деле, например, какая-нибудь простая админка на условно чистом HTML без какого-нибудь там Angular React или еще чего-нибудь.
3375.68 3382.96 "Игорь Лабутин" Или еще какие-то случаи, когда вы не сможете использовать такие токены, потому что эти токены надо где-то хранить на стороне клиента, их нужно посылать там.
3382.96 3388.96 "Игорь Лабутин" И браузеры, конечно, у нас сейчас модные и современные, и много чего могут.
3388.96 3399.44 "Игорь Лабутин" Но, например, вот конкретно у автора нужно было одновременно с авторизацией по токену для некоторых endpoints сделать возможность авторизации по cookie.
3399.44 3401.96 "Игорь Лабутин" То, как мы всегда давно работали.
3401.96 3402.96 "Игорь Лабутин" Вот.
3402.96 3404.76 "Игорь Лабутин" А SP.NET Core это все поддерживает.
3404.76 3413.36 "Игорь Лабутин" Но нам же нужно как-то знать, вот нам пришел запрос, что нам нужно проверять, то нам нужно проверять токены или нам нужно проверять cookie.
3413.36 3427.64 "Игорь Лабутин" Причем мы-то, может быть, мы это и знаем, но нам нужно сказать SP.NET Core, потому что не мы сами проверяем, мы всего лишь, если помните, добавили useAuthorization и мы добавили authenticate на контроллеры, и больше ничего.
3427.64 3428.64 None Вот.
3428.64 3431.88 "Игорь Лабутин" Как же об этом, собственно, сказать?
3431.88 3435.32 "Игорь Лабутин" Для этого есть специальная штука.
3435.32 3445.36 "Игорь Лабутин" И когда мы говорим configure services add authentication, нужно на самом деле указать кастомную схему авторизации.
3445.36 3454.84 "Игорь Лабутин" Мы используем атрибутики опции default schema и default challenge schema, указываем там некоторые специальные имена.
3454.84 3463.52 "Игорь Лабутин" После этого вызываем add cookie, прям как следующий экстенджер-метод по цепочке, и add JWT-bearer, как раньше.
3463.52 3476.44 "Игорь Лабутин" То есть у нас получается, что мы на одну эту, на add authentication добавили возможность и cookie, и JWT-bearer авторизации, аутентификации, но мы пока не сказали, когда что использовать.
3476.44 3490.76 "Игорь Лабутин" И для этого используется экстенджер-метод add policy схема, где вы используете то имя, которое вы дали default schema чуть выше, и указываете специальную лямточку для опции под названием forward default selector.
3490.76 3495.52 "Игорь Лабутин" Не очень понимаю, почему он называется forward, ну, видимо, потому что он куда-то forwarded.
3495.52 3496.52 "Игорь Лабутин" Вот.
3496.52 3516.88 "Игорь Лабутин" Там как раз-таки в этом селекторе единственное, что он делает, он берет, принимает на вход, что-то по контексту, где есть вся информация о запросе, хдра, там все дела, и на выходе вы должны вернуть строчку, по сути, просто имя схемы, которую нужно использовать, либо cookie, либо bearer для JWT.
3516.88 3555.80 "Игорь Лабутин" Соответственно, у вас получается в итоге следующая штука, что когда к вам придет запрос, а SpernatCore посмотрит, что default policy для того, чтобы что-то сделать, нужно вызвать этот forward default selector, вызовет его на вашем запросе, вы проанализируете ваш запрос, например, посмотрев в хдра и проверив, есть там cookie или нет там cookie, если там есть cookie, вы вернете, что, окей, авторизуемся через cookie, если нет cookie, или если есть инфа про токен, вы вернете, что нужно авторизоваться по токену, после чего SpernatCore выберет правильную из авторизаций, которая была добавлена.
3555.80 3563.36 "Игорь Лабутин" Все будет работать хорошо, если к вам придут запросы с токеном или с cookie.
3563.36 3564.80 "Игорь Лабутин" Теперь следующий момент.
3564.80 3578.68 "Игорь Лабутин" Логин метод, он в принципе нормальный, ну вот тот самый, который должен вам возвращать токен, но было бы неплохо, чтобы его тоже можно было использовать из других методов, чтобы он и cookie тоже возвращал, cookie-то как-то получить надо, чтобы его потом дальше использовать.
3578.68 3585.44 "Игорь Лабутин" Поэтому внутри authenticate метода вы делаете, ну по программе, автор делает следующее.
3585.44 3621.88 "Игорь Лабутин" Метод authenticate, он генерирует токен, как и раньше, а кроме этого он вызывает метод httpcontext.signin_async, это стандартный метод логина, который в итоге вам вернет cookie, который нужно положить в нужное место хеддера, точнее он сам это положит на самом деле в респонс хеддер, и вы возвращаете токен, как и раньше, в итоге откуда бы вы не логинились, вам вернется и токен, и cookie, ну просто та часть, которая хочет cookie, она будет игнорить респонс с токеном, та часть, которая хочет токен, она будет игнорить респонс с cookie, и все будут счастливы.
3621.88 3630.48 "Игорь Лабутин" Технически вы конечно можете сделать это вообще двумя разными методами, если вы знаете, что у вас никогда их смешивать не нужно, и разные клиенты используют разные методы.
3630.48 3667.32 "Игорь Лабутин" Если вам нужно проверить, что пользователь аутентифицирован, и вы не имеете доступ к контроллерам, например, это такое может быть, если вы используете свашбакл, который сгенерит вам сваггер спецификацию на ваш API, и будет некоторый специальный контроллер, идеально который вы получите описание вашей апишки, и вы например хотите, чтобы это описание апишки видели только авторизованные пользователи, тогда контроллера нет, на которые навесить атрибут authorize.
3667.32 3706.36 "Игорь Лабутин" Тут вариантов два, либо использовать фильтры, как говорил Толя выше, либо, если например для разных раутов вам нужно какие-то разные правила делать, можно использовать extension метод use, то есть добавить свою собственную небольшую middleware в виде лямбдочки, где внутри проверить просто, что ваш cdb-контекст .user, .identity, .authenticated, .polia = true, это значит, что пользователь авторизован, там можно даже у него в идентите проверить набор клеймов и понять, что там у него внутри, какие клеймы есть, на основе этого принять решение вызывать следующий middleware, то есть идти по нужному маршруту или не идти.
3706.36 3707.36 "Игорь Лабутин" Такие дела.
3707.36 3728.72 "Игорь Лабутин" Так что если вы используете JWT-авторизацию, даже если вам сейчас пока не нужно делать двойную такую аутнотификацию, я на самом деле очень рекомендую прочитать обе этих статьи, они довольно хорошо суммируют простым языком, что и как нужно делать, чтобы у вас работала авторизация и как она работает внутри.
3728.72 3743.96 "Игорь Лабутин" Не очень глубоко забираюсь, это не Andrew Locke, который там залезет в каждый метод внутри фреймворка, но этого понимания более чем достаточно, на мой взгляд, по крайней мере, чтобы понять, как все это работает и применять в реальных проектах.
3743.96 3766.36 "Анатолий Кулаков" Да, там хотя бы для того, чтобы поверхностно понять, как настраивать уже то, что есть в плане авторизации и аутентификации, уже нужно там какую-то ученую степень получить, потому что там очень много всяких тонкостей существует и хорошо, когда есть такие готовые рецепты, которые точно авторам проверены, отлажены и покрывают такие бытийские кейсы, как действительно довольная аутентификация.
3766.36 3770.20 "Анатолий Кулаков" Так, это прекрасно.
3770.20 3771.72 "Анатолий Кулаков" У меня нашел еще одну статейку.
3771.72 3779.08 "Анатолий Кулаков" Я все время рекомендую всем по дефолту сделать себе сниппет для создания классов, который делает классы InternalSilt.
3779.08 3790.92 "Анатолий Кулаков" Вроде про зачем Internal мы с тобой разбирали в прошлых выпусках, а теперь мне попалась статья, которая популярным языком объясняет, а зачем же все-таки делать Silt.
3790.92 3796.56 "Анатолий Кулаков" Неужели это действительно такое полезное свойство, и может оно все-таки и не нужно нам совсем.
3796.56 3799.80 "Анатолий Кулаков" И вот хотелось бы тоже немножко поговорить об этом.
3799.80 3807.28 "Анатолий Кулаков" Итак, для начала, для тех, кто не в курсе, классы C# по умолчанию не Silt, то есть они не запечатываются, не закрываются.
3807.28 3815.24 "Анатолий Кулаков" Это значит, что от любого класса вы можете пронаследоваться и со всеми вытекающими, перекрыть, вызвать и так далее.
3815.24 3819.12 "Анатолий Кулаков" Вот, и кажется вообще, на самом деле, что это не самый правильный дефолт.
3819.12 3831.04 "Анатолий Кулаков" Намного умнее было бы по умолчанию классы запечатывать, то есть запрещать наследование, и если вдруг вам нужно, то дальше вы уже ставите специальное слово и начинаете от него наследоваться.
3831.04 3842.28 "Анатолий Кулаков" Вот, это можно добиться с помощью каких-то костылей, вроде создания snippet, который по умолчанию вам все классы создает по словам Silt.
3842.28 3846.08 "Анатолий Кулаков" И если вам вдруг нужно наследоваться, вы всего-лишь навсего это слово убираете.
3846.08 3848.08 "Анатолий Кулаков" Зачем же это нужно?
3848.08 3859.92 "Анатолий Кулаков" На самом деле, JIT в рантайме способен сделать огромную кучу оптимизаций, если у вас класс, соответственно, конкретный, запечатанный, и у него точно никогда не будет наследников.
3859.92 3865.12 "Анатолий Кулаков" И в результате этих оптимизаций очень часто, например, можно методы inline.
3865.12 3870.04 "Анатолий Кулаков" А inline, как известно, это один из самых крутых увеличителей перформанса.
3870.04 3875.20 "Анатолий Кулаков" Но давайте разберемся на примере, какие же все-таки оптимизации у нас могут сработать в рантайме.
3875.20 3878.72 "Анатолий Кулаков" Во-первых, самая главная оптимизация – это вызов виртуальных методов.
3878.72 3897.12 "Анатолий Кулаков" На самом деле, когда вы вызываете виртуальный метод у вашего класса, то какой настоящий метод вызовется, зависит полностью от рантайма, потому что вы можете вполне оперировать базовыми классами, абстрактными классами, у которых нет никакого боди для этого метода.
3897.12 3909.16 "Анатолий Кулаков" И чтобы его вызвать, у актуального типа есть специальная штука, которая называется virtual method table, то есть это таблица виртуальных методов, где хранятся адреса всех виртуальных методов.
3909.16 3921.76 "Анатолий Кулаков" И, соответственно, для того, чтобы рантайму получить какой-то результат, этот метод необходимо по этой таблице найти и дернуть непосредственно от того экземпляра, который сейчас у нас в рантайме представлен.
3921.76 3937.68 "Анатолий Кулаков" И если джит знает о том, что данный класс сейчас sealed, то он может пропустить эту таблицу виртуальных методов и вызвать метод напрямую, что очень сильно сказывается на перформансе.
3937.68 3941.76 "Анатолий Кулаков" Не нужно бегать искать виртуальные таблицы, не нужно бегать по этим методам, искать там что-то.
3941.76 3946.96 "Анатолий Кулаков" Можно просто дернуть непосредственно указатель на метод.
3946.96 3959.24 "Анатолий Кулаков" И класс, который говорит, что у него нет больше наследников, не надо никуда там бегать, не ищи, это последний sealed, у него метод можно дернуть напрямую.
3959.24 3962.96 "Анатолий Кулаков" Соответственно, это очень хорошая оптимизация.
3962.96 3968.88 "Анатолий Кулаков" Другая оптимизация, когда мы используем слова для каста, такие как s и is.
3968.88 3981.56 "Анатолий Кулаков" Когда мы кастаем объект, опять же мы в рантайме должны будем в том числе проверить тип того объекта, который мы начинаем приводить наш экземпляр.
3981.56 3991.72 "Анатолий Кулаков" И если у нас класс вдруг не sealed, то рантайм обязан пробежаться про все иерархии типов и попытаться их скастить к тому экземпляру, который у нас сейчас есть.
3991.72 4009.40 "Анатолий Кулаков" Если же у нас класс sealed, то всю эту глупость можно пропустить и непосредственно проверить на тип объекта, который у нас под рукой и очень быстро, с точки зрения перформанса, в порядке раз увеличить производительность непосредственно операторов каста.
4009.40 4013.88 "Анатолий Кулаков" Еще есть такая прекрасная штука, как массивы.
4013.88 4016.24 "Анатолий Кулаков" И массивы у .NET они ковариантные.
4016.24 4024.52 "Анатолий Кулаков" То есть, если мы, допустим, создадим массив от базовых типов, мы можем в этот массив присвоить типы наследников.
4024.52 4028.16 "Анатолий Кулаков" И это будет валидный код, с этим все хорошо.
4028.16 4029.60 "Анатолий Кулаков" Но есть тонкость.
4029.60 4031.52 "Анатолий Кулаков" Не все коллекции одинаково полезны.
4031.52 4041.16 "Анатолий Кулаков" То есть, если мы уже создадим не массив, а лист базовых типов и попытаемся присвоить ему лист наследников, то этот код уже не валидный, так у нас сделать не получится.
4041.16 4056.92 "Анатолий Кулаков" И соответственно, JIT должен проверять типы этих объектов перед тем, как присвоить элементу массива новый элемент, для того, чтобы собрести вот это правило.
4056.92 4071.30 "Анатолий Кулаков" Если уже у нас будут запечатанные классы, то JIT вполне может удалить эту проверку и, соответственно, никаких лишних расходов на эти проверки тратиться больше не будет.
4071.30 4077.92 "Анатолий Кулаков" Практически та же самая ситуация у нас происходит, когда мы пытаемся сконвертировать массив в спан.
4077.92 4090.32 "Анатолий Кулаков" Если кто не знал, то массивы легко конвертируются в спан и в редонный спан, и JIT по тем же самым причинам обязан проверять тип каждого элемента, каждого объекта перед тем, как его сконвертить в спан от T.
4090.32 4095.20 "Анатолий Кулаков" Если же у нас класс SILT, то опять этой проверки можно избежать и все счастливы.
4095.20 4105.40 "Анатолий Кулаков" Не только JIT, даже компилятору иногда бывает полезно знать о SILT типах, например, когда происходит некие конвертации.
4105.40 4115.68 "Анатолий Кулаков" То есть, он может вам отрапортовать в такие ситуации, когда вы пытаетесь в SWITCH или в ETH проверить объект, который должен, по идее, наследовать какой-то интерфейс.
4115.68 4134.00 "Анатолий Кулаков" Но если этот объект запечатанный, если он SILT, и компилятор видит, что никакого интерфейса у него уже нет, и значит, никакие наследники этого интерфейса у него не заимплементируют, он здесь же вам может набросить предупреждение или может быть даже ошибку, что типа вы делаете какую-то чушь, прекратите так делать.
4134.00 4138.36 "Анатолий Кулаков" Но компилятор тоже это ключевое слово использует.
4138.36 4145.60 "Анатолий Кулаков" И если вы хотите конкретных цифр, то в этой статье есть по каждому пункту бенчмарки, есть ссылки.
4145.60 4154.12 "Анатолий Кулаков" И вы можете зайти и убедиться, что цифры там действительно различаются в некоторых случаях просто на порядке.
4154.12 4156.84 "Анатолий Кулаков" Буквально из-за такого маленького коротенького слова.
4156.84 4161.20 "Анатолий Кулаков" Как мы можем помочь дню сегодняшнему?
4161.20 4164.56 "Анатолий Кулаков" Во-первых, существует специальный анализатор, наверное, один из миллиона.
4164.56 4168.68 "Анатолий Кулаков" Ну вот в частности анализатор от автора, статейку которую я нашел.
4168.68 4171.92 "Анатолий Кулаков" Называется он Mediantool Analyzer.
4171.92 4174.08 "Анатолий Кулаков" Может быть неправильно вы читал.
4174.08 4179.76 "Анатолий Кулаков" И он содержит правила для того, чтобы как раз таки рекомендовать запечатывать классы в определенных ситуациях.
4179.76 4187.24 "Анатолий Кулаков" Там у него есть небольшие настроечки, небольшая heuristica, ну вполне крайне полезная и интересная штука, можно на нее посмотреть.
4187.24 4201.08 "Анатолий Кулаков" Но более интересная штука это то, что в DotNet 7 решили сделать стандартный анализатор и сейчас команда DotNet Team активно его обсуждает, даже есть уже pull request, ревьюет, комментирует.
4201.08 4209.04 "Анатолий Кулаков" В общем, в 7 DotNet у нас будет стандартный анализатор, который будет советовать запечатывать те классы, которые очевидно могут такими быть.
4209.04 4218.64 "Анатолий Кулаков" То есть если там класс Internal, если на него нет ссылок там из других библиотек, еще там совпадают некоторые атрибуты и прочая магия.
4218.64 4231.68 "Анатолий Кулаков" В целом очевидно, что можно было бы его запечатать, анализатор будет это рекомендовать и в принципе тоже такая банальная маленькая штучка вполне ощутимо может увеличить производительность вашего кода.
4231.68 4256.32 "Игорь Лабутин" Ну звучит действительно разумно, я честно скажу, не отношусь к тем, кто по дефолту делает классы sealed и понятно, что в наших приложениях это наверное не столь важно с точки зрения перформанса, но с другой стороны действительно теряем мы немного от того, что мы делаем их sealed, поэтому наверное ты прав и может быть надо будет попробовать по дефолту всегда делать
4256.32 4263.08 "Анатолий Кулаков" sealed. Так наверное мы только приобретаем немножко больше текста, но в основном это одни плюсы из этого подхода.
4263.08 4266.52 "Игорь Лабутин" Ну одно слово, не так важно, в общем-то.
4266.52 4271.80 "Игорь Лабутин" Тем более в заголовке класса, ну в смысле в объявлении, где не так часто туда смотришь.
4271.80 4280.56 "Игорь Лабутин" Ладно, давай пойдем дальше и дальше у нас новости, не новости, про Visual Studio и вокруг.
4280.56 4296.56 "Игорь Лабутин" Ты говоришь, что ты попробовал Visual Studio без ReSharper, но на самом деле совсем уж прям пустая Visual Studio может быть не очень прям здорово и какие-то полезные расширения к ней можно ставить, не ReSharper единым.
4296.56 4315.60 "Игорь Лабутин" И в частности есть такой автор, Мэттс Кристенсен, мы от него выпуска три назад рекомендовали курс по поводу того, как начать писать свои расширения для Visual Studio, а он вообще сам по себе какой-то очень продуктивный чувак, у него там какое-то огромнейшее количество экстендженов и он выпустил как раз два новых.
4315.60 4340.12 "Игорь Лабутин" Во-первых, у него был экстенджен Markdown Editor, то есть если вы редактируете маркдауны, то в студии возможно вы пользуетесь Markdown Editor, если вы живете на 22 студии, я рекомендую взять Markdown Editor V2, который полностью переписанный экстенджен на какой-то правильный современный движок маркдауна, который должен поддерживать все что надо, ну он поддерживает по сути гидхабовский флейвор, на какой я понимаю.
4340.12 4348.40 "Анатолий Кулаков" Я тебе даже больше скажу, что этот движок это MarkDig, который поддерживает наш любимый Muteal, Alexander Muteal.
4348.40 4349.92 "Игорь Лабутин" А, ну вообще прекрасно.
4349.92 4355.24 "Игорь Лабутин" Вот, то есть, ну, значит, экспириенс должен быть наверное еще лучше.
4355.24 4383.00 "Игорь Лабутин" Они, что, что сделал, точнее, что сделал Мэтц, он сделал по сути, если вы редактируете Markdown файлик, то у него открывается справа панелька с превьюшкой браузерной, и при этом у вас есть в той части, в левой части, где вы редактируете сам файлик, у вас есть навигация, ну, немножко напоминающая то, как вы видите чертовой файлик, то есть сверху появляется дропдаун, где есть все хедера в этом Markdown, и вы можете быстренько переключаться между ними.
4383.00 4397.16 "Игорь Лабутин" Плюс у вас есть какой-никакой интеллисенс внутри Markdown, плюс у вас есть шорткаты для форматинга, то есть всякие Ctrl+B и так далее, вполне работают для всяких балдов, подчеркивания и так далее.
4397.16 4400.76 "Игорь Лабутин" Ну, то есть, короче, писать Markdown должно быть чуть более приятно.
4400.76 4412.36 "Игорь Лабутин" Вот, поэтому если вы пишете Markdown, я знаю, что, например, там, нас в команде использовали VS Code для этого, ну вот вижу, в студии теперь есть хороший экстенджер, который точно позволяет делать неплохо.
4412.36 4415.44 "Игорь Лабутин" Я попробовал, но, в принципе, хорошо работал.
4415.44 4422.28 "Игорь Лабутин" Но мне гораздо больше понравился второй экстенджер, под названием Twix 2022.
4422.28 4447.28 "Игорь Лабутин" Вот, это экстенджер, в котором здесь собрано какое-то немеренейшее количество, то есть тут порядка трех или даже, может быть, четырех, десятков, ну, трех, наверное, все-таки, десятков мелочей, которые действительно мелочи, но при этом, как минимум, половина из них я понял, что действительно это была проблема, или я натыкался на какие-то сложности или недостающую функциональность.
4447.28 4450.96 "Игорь Лабутин" Я поставил этот экстенджер и прям не могу нарадоваться.
4450.96 4459.24 "Игорь Лабутин" Значит, давайте быстренько попытаюсь рассказать буквально по одному-два предложения, по каждому из твиков, которые есть.
4459.24 4464.36 "Игорь Лабутин" Во-первых, добавился шорткатик на переоткрытие только что закрытого файла.
4464.36 4473.12 "Игорь Лабутин" Казалось бы, мелочь, но как бы, бывало, что попадал он случайно на крестник, закрывал файлик, и нужно быстренько открыть его обратно.
4473.12 4488.64 "Игорь Лабутин" Понятно, что есть там Ctrl+Shift, что там запятая, да, или какой там последний список редактирований, вот, но просто переоткрыть файлик, примерно как вы это делаете в браузере, когда закрываете тапку случайно, это тоже неценно, бывает нужно.
4488.64 4491.72 "Анатолий Кулаков" Я, кстати, в браузере часто пользуюсь, да, часто ошибаюсь.
4491.72 4494.36 "Игорь Лабутин" Вот, второе, Толя, тебе, наверное, понравится.
4494.36 4514.08 "Игорь Лабутин" Теперь, вот, если у тебя стоит экстенджер, как только ты переключаешься с тапки, ну, в смысле, фокус у тебя уходит из тапочки с файликом, да, куда угодно, в Solution Explorer на другую тапку, в окошко output тыкаешь мышкой, ну, или выполняешь какую-то команду шорткатом, так что фокус смещается, у тебя происходит автосейв.
4514.08 4520.84 "Анатолий Кулаков" О, автосейв, наконец-то ставлю, все, продал, Игорь, молодец, отлично, я нашел его.
4520.84 4525.44 "Игорь Лабутин" Дальше, закрытие тапа по Ctrl+W, ну, так же, как в браузере.
4525.44 4526.80 "Анатолий Кулаков" Да, удобная штука.
4526.80 4544.56 "Игорь Лабутин" Вот, у меня, правда, не заработало, но, возможно, у меня какой-то кастомный шорткат, ну, в смысле, что он что-то там сконфликтовал с моими, может быть, я настраивал что-то похожее, у меня по Ctrl+W почему-то открывалось какое-то магическое окошко, то ли фидбэка, то ли, ну, короче, какая-то странная штука, но это, может быть, глюк моей студии.
4544.56 4557.84 "Анатолий Кулаков" Да, надо почистить окно шортката, оно часто засоряется, и не очень удобно сделано в этом плане, потому что очень часто конфликтуют шорткаты, и отслеживать, чистить, выбирать правильный, совсем неудобно в Visual Studio,
4557.84 4573.08 "Игорь Лабутин" конечно. Да, дальше, при загрузке Solution автоматически будет фокус на Solution Explorer, то есть не на чем, что у вас там последнее было, а, то есть у меня, например, если там какой-нибудь там с Git'ом или с Azure DevOps работал, то обычно открывается Team Explorer по умолчанию.
4573.08 4578.12 "Игорь Лабутин" Вот можно настроить, чтобы открывался сразу Solution Explorer, неважно, что у вас было.
4578.12 4585.32 "Игорь Лабутин" В менюшках Recent Files и Проектов появились теперь пунктики Почистить, их можно очистить.
4585.32 4590.88 "Анатолий Кулаков" Ну, как-то ни разу не пригождалось, если ты, наверное, хочешь что-то спрятать, иначе зачем оно тебе нужно?
4590.88 4598.56 "Игорь Лабутин" Ну да, возможно, не знаю, либо ты там, на самом деле у меня такое бывало нужно, когда, не, наверное, кстати, в студии не нужно было.
4598.56 4609.48 "Игорь Лабутин" У меня такое было нужно иногда с Git-репозиториями, когда ты там поработал с чем-нибудь отключенным, и теперь тебе хочется все это почистить, нафиг, потому что, ну, конечно, переключился на другой проект, не знаю.
4609.48 4612.08 "Игорь Лабутин" Наверное, если ты часто переключаешься между проектами, может быть ценно.
4612.08 4622.84 "Игорь Лабутин" Дальше, в Solution Explorer можно теперь нажать, если у тебя сейчас курсор стоит на каком-то файлике, если ты нажмешь Enter на него, да, он откроет просто табочку, правильно?
4622.84 4623.84 "Игорь Лабутин" Да.
4623.84 4639.28 "Игорь Лабутин" А если ты нажмешь Alt+Enter, то он откроет, так скажем, табочку, то, что называется, side view, то есть у тебя будет две табочки рядышком открыты, ну, одна старая, и вторая новая, то есть он открывает файлик типа рядышком с предыдущим.
4639.28 4640.28 "Игорь Лабутин" На широком…
4640.28 4647.52 "Анатолий Кулаков" Ну, в Visual Studio можно так потащить за правый верхний угол скроллбара, и он тебе сделает просто-напросто два файлика рядом.
4647.52 4648.52 "Анатолий Кулаков" Да, да-да-да.
4648.52 4653.00 "Анатолий Кулаков" И ты можешь там скомпарить, там удобно такую штуку делать для того, чтобы переносить код, там, подсматривать
4653.00 4675.72 "Игорь Лабутин" и печатать. Вот, и вот если ты что-то открываешь, например, я таким, вот я эту неделю работал с этим экстенджером, или около того, и я этим Alt+Enter действительно начал пользоваться, когда я, знаешь, что-нибудь именно из Solution Explorer открываю файлик временно посмотреть, чтобы не закрывать мой основной, он как бы открывается, ну, вторым табом, по сути, да, рядышком, ты на него смотришь и закрываешь.
4675.72 4679.12 "Игорь Лабутин" В принципе, ну, как бы… Да, да, хороший эскейс.
4679.12 4695.44 "Игорь Лабутин" Другое дело, что не часто ты открываешь именно из Solution Explorer, но вот я тут некоторое время потратил на проекте на WinForms, и там как бы ты ходишь по этим формочкам все-таки из Solution Explorer, по Ctrl+T там далеко не все можно открыть.
4695.44 4699.20 "Игорь Лабутин" Добавились пункты меню "Рестарт в Visual Studio" и "Рестарт как админ".
4699.20 4708.72 "Игорь Лабутин" Это, наверное, я не знаю, для разработчиков экстенджеров столько сильно важно, никогда как-то не нужно было перезапускать студию, вот, но, наверное, кому-то надо.
4708.72 4718.12 "Игорь Лабутин" Дальше, если ты… В студии есть сейф-мод, знал ты про это?
4718.12 4725.32 "Анатолий Кулаков" Да, конечно, тоже, наверное, времена, когда я делал экстенджеры к Visual Studio, скорее всего, тоже оттуда я все это знаю.
4725.32 4754.08 "Игорь Лабутин" Вот, теперь, соответственно, можно в этот сейф-мод, раньше нужно было там находить, где у тебя находится этот Deviance.exe, передавать это все из Command Line ключик, теперь если ты на винде, ну, а с Visual Studio ты на винде, да, конкретно с этой, то, райт-кликнув на кнопочку на Taskbar, там же есть так называемый Jump List, да, это вот часто вызываемые команды, да, относящиеся к этому приложению, там теперь для студии появилось два пункта, один называется сейф-мод, а другой называется Presentation Mod.
4754.08 4761.64 "Игорь Лабутин" Это, по сути, просто запуск с другими настройками, с ключиком root suffix, да, и демо.
4761.64 4773.60 "Анатолий Кулаков" Кстати, да, действительно, для всяких демо-вещей, вот, меняют root, ну, root это, по сути, то место в реестре, куда сохраняет Visual Studio все свои настройки.
4773.60 4782.52 "Анатолий Кулаков" Соответственно, вы можете с помощью специального ключика запускать Visual Studio с разными настройками, которые у вас, например, для одного монитора или для двух, или в Presentation Mod, или в рабочем моде.
4782.52 4788.64 "Анатолий Кулаков" В общем, тоже удобная штука, если, опять же, есть разные environment, и вам нужны разные настройки Visual Studio.
4788.64 4797.48 "Анатолий Кулаков" В общем, этим тоже очень удобно пользоваться, и если это вдруг можно сделать с помощью кнопочки, удобно и весело, то большой плюс.
4797.48 4808.32 "Игорь Лабутин" Ну вот, да, это конкретно для одного-единственного рута, да, под названием демо, это всё за hard-coded, как я понимаю, но, действительно, это довольно частый, наверное, кейс, который можно использовать.
4808.32 4816.72 "Игорь Лабутин" Не очень нужная мелочь, как мне кажется, но из Help меню теперь можно посмотреть на roadmap студии и на релиз нот, последний, не надо гуглить, а можно прямо из студии открыть.
4816.72 4822.24 "Анатолий Кулаков" А ещё можно из студии не смотреть, а просто послушать наш подкаст, и мы обо всём вам расскажем, не загоняйтесь.
4822.24 4825.00 "Игорь Лабутин" Ну, тоже верно, да.
4825.00 4829.16 "Игорь Лабутин" Дальше некоторое количество улучшений вокруг билда.
4829.16 4836.68 "Игорь Лабутин" Часто ли тебе приходилось менять verbosity, вот того, что пишется в build output?
4836.68 4844.36 "Анатолий Кулаков" Каждый раз, когда я переустанавливаю Visual Studio, я захожу и ставлю его в самый минимальный, в Qt, по-моему, и всё, больше я его не трогаю.
4844.36 4860.48 "Игорь Лабутин" Понятно, нет, мне на самом деле иногда требовалось, когда тебе нужно понять каким-то очень хитро вывернутым, почему что-то пересобирается, или почему оно не собирается, или у тебя какие-то кастомные MSBuild action, и почему они не срабатывают, приходилось ставить какой-нибудь verbose или что-нибудь.
4860.48 4867.12 "Анатолий Кулаков" Слушай, ты человек, который дебажит MSBuild, да, я с тобой не могу ни в коем случае с этим состязаться.
4867.12 4879.00 "Игорь Лабутин" Ну вот если вдруг кто-то, как я, то теперь прямо в build output окошечки, в тулбарчике этого окошечка, справа есть drop-down, где можно просто настроить verbosity.
4879.00 4883.68 "Игорь Лабутин" Не надо идти в глубоком настройке студии, оно прямо из drop-down настраивается.
4883.68 4887.68 "Игорь Лабутин" Следующий пункт, при build автоматически сохранять solution.
4887.68 4892.32 "Анатолий Кулаков" Всегда автоматически сохранять solution, и при build, и при unfocus, и при любом чихе.
4892.32 4900.32 "Игорь Лабутин" Ну вот здесь конкретно, это был на самом деле фишка Visual Studio, что по-моему CS-ники, у меня как-то было такое поведение, что CS-ники сохранились, а CS-project нет.
4900.32 4904.12 "Игорь Лабутин" И ты такой, что-нибудь поменял в CS-project, говоришь build, оно не применяется.
4904.12 4914.68 "Игорь Лабутин" Блин, я же забыл сказать save all, то есть у меня был принцип, ну как обычно, да, там код редактируешь, жмешь ctrl+s, а все, там ctrl+shift+s, да, по-моему, save all.
4914.68 4915.68 "Анатолий Кулаков" Что-то такое было.
4915.68 4916.68 "Анатолий Кулаков" Да, ctrl+shift+s.
4916.68 4923.56 "Игорь Лабутин" Вот, вот перед build всегда нажми ctrl+shift+s, мало ли что, особенно когда ты работаешь с solution или с CS-project много.
4923.56 4926.48 "Игорь Лабутин" Вот, теперь это можно сделать автоматом.
4926.48 4929.36 "Игорь Лабутин" Дальше, фишка, которой тоже очень давно не хватало.
4929.36 4934.24 "Игорь Лабутин" Если ты говоришь clean solution, удалять bin и obj в папочке целиком.
4934.24 4940.12 "Анатолий Кулаков" Да, да, да, большой WTF, почему-то сразу, прямо с начала времена вот это вот так вот не делать.
4940.12 4941.12 "Анатолий Кулаков" Всегда и всеми.
4941.12 4942.12 "Игорь Лабутин" Да, теперь можно.
4942.12 4950.68 "Игорь Лабутин" В конце билда показывать статистику по времени, то есть на сайлум пишешь там две чиселки, во сколько билд начался и сколько все заняло.
4950.68 4952.76 "Анатолий Кулаков" Да, сильная статистика, ну допустим.
4952.76 4967.12 "Игорь Лабутин" Ну не то, чтобы это было сильно нужно, но может быть, если ты там, не знаю, каждый день смотришь на нее, там перебилдиваешь много-много-много раз, то ты, ну, примерно будешь знать, сколько оно должно билдиться, если, например, стало билдиться дольше, может быть, это намекнет тебе, что надо что-то проверить.
4967.12 4977.20 "Анатолий Кулаков" Не, ну, знать это грустно, он бы мог историю какую-нибудь соблюсти, там историю сохранять, и вот эти столбики красивые, зелененькие строить, чтобы хоть какое-то развлечение было.
4977.20 4978.20 "Анатолий Кулаков" А так две циферки показывать, ну, не серьезно.
4978.20 4994.24 "Игорь Лабутин" Слушай, ну, все эти идеи, на самом деле, взяты из какого-то, я так понимаю, фидбэка для студий, то есть он просто взял сайтик типа вижу в студии какой-нибудь там фидбэк, да, куда собираются всякие хотелки, и просто взял там топ сколько-то, которые были не очень сложно реализовать.
4994.24 4996.64 "Анатолий Кулаков" Да, очень отличная идея.
4996.64 4997.64 "Игорь Лабутин" Дальше.
4997.64 5003.92 "Игорь Лабутин" Штука, которая у меня не заработала, поэтому я не смогу сильно много рассказать, но идея в следующем.
5003.92 5020.64 "Игорь Лабутин" Вот когда ты собираешь проект, у тебя он там очень часто, если у тебя там в салюшене там дофига себе CS Project, он быстренько по ним по всем пробегает, говорит, что типа, а ну тут все собрано, собрано, собрано, собрано, да, то есть сразу пишет, особенно в минимал-варианте output, он пишет сразу, ну, типа, да лялька там на месте.
5020.64 5022.32 "Игорь Лабутин" А иногда начинает пересобирать.
5022.32 5025.40 "Игорь Лабутин" И вот ты такой, блин, а че ж он пересобирает-то?
5025.40 5027.68 "Игорь Лабутин" Вот, столкнулся с таким?
5027.68 5029.40 "Анатолий Кулаков" Да, конечно, очень часто.
5029.40 5033.92 "Анатолий Кулаков" Мне кажется, что наоборот, как раз увижал в студии, вот этот анализатор, он мега тупой.
5033.92 5036.48 "Игорь Лабутин" Вот, ну допустим, вот он пошел пересобирать.
5036.48 5039.24 "Игорь Лабутин" Ты как будешь понимать, почему он пошел пересобирать?
5039.24 5047.80 "Анатолий Кулаков" Ну, к сожалению, я скорее всего плюну, и все, если это нет, нет у меня какой-то цели ускорить билд и разобраться вот в какой-то там понятном случае.
5047.80 5048.80 "Анатолий Кулаков" Волт.
5048.80 5051.20 "Анатолий Кулаков" Я обычно этим не загоняюсь, я стараюсь делать салюшены поменьше.
5051.20 5064.44 "Игорь Лабутин" Вот, а я таким занимался, и стандартный способ это сделать, ты ставишь вербосити как раз-таки там хотя бы, ну я обычно ставил диагностик такой, что прям это самый такой, там все написано.
5064.44 5066.80 "Игорь Лабутин" И потом долго… Чтоб на гигабайты прямо анализа можно было.
5066.80 5080.84 "Игорь Лабутин" Да, да, да, и потом ты долго вычитываешь этот лог, чтобы понять, значит, что ж там, какой цестник там, где-то что-то в каком-нибудь кастомном опять же без билд экшене или даже не кастомном, он не понял, что какой-нибудь там xsd файлик не преобразовался.
5080.84 5095.08 "Игорь Лабутин" Вот, этот экстеншн, вот этот кусочек экстеншна призван в минимал даже варианте написать, что хей, мы поняли, что в этом, короче, проекте поменялся этот цестный файл, поэтому мы пересобираем.
5095.08 5100.16 "Игорь Лабутин" Ну то есть в минимал варианте написать там одну-две строчки, почему он, собственно, решил его пересобрать.
5100.16 5101.16 "Игорь Лабутин" У меня не смогло.
5101.16 5104.56 "Игорь Лабутин" Ну то есть не писал, не знаю почему.
5104.56 5111.32 "Анатолий Кулаков" Идея хорошая, да, я бы в принципе в бэкграунде всегда бы хотел чекать такую строчку, если бы можно было ее всегда выводить.
5111.32 5124.52 "Игорь Лабутин" Ну вот, да, считается, что вроде должно выводить, но почему-то не заработало, не знаю, почему может у нас проект какой-то сильно сложный или там какие-нибудь зависимости, ну те же кастомные мс билды, я не смотрел, как это работает, вот, поэтому не могу сказать.
5124.52 5127.52 "Игорь Лабутин" Ну ладно, пошли дальше.
5127.52 5132.36 "Игорь Лабутин" Штука под названием "когда закончили билд, покажи вкладочку build order".
5132.36 5138.72 "Игорь Лабутин" Вот ты сегодня много про всякие pdb-шные вкладочки рассказывал, да, там, такая-сякая, эдакая.
5138.72 5143.84 "Игорь Лабутин" Для билда вот у нас есть стандартный билда-оутпут, ну который все видят, да, когда все собирается.
5143.84 5147.60 "Игорь Лабутин" А многие ли знают, что у нас есть еще вкладочка build order?
5147.60 5148.60 "Игорь Лабутин" Видел такую?
5148.60 5151.80 "Анатолий Кулаков" Build order, нет, мне что-то как-то не сталкивалось.
5151.80 5154.80 "Игорь Лабутин" Ну смотри, когда у тебя solution там.
5154.80 5175.72 "Игорь Лабутин" Смотри, когда у тебя solution в каком-нибудь там, не знаю, ну в несколько csproj, да, особенно когда их много, там не знаю, 40 штук, у тебя когда он собирается, у тебя msbuild начинает их собирать относительно параллельно, да, ты вот видишь в аутпуте, там эти префиксы такие пишутся, там, проект номер один, проект номер два, проект номер три, ну и они так все потихонечку собираются до конца.
5175.72 5176.72 "Игорь Лабутин" Вот.
5176.72 5183.68 "Игорь Лабутин" И если у тебя что-то идет не так, то вот в этом вот миксе параллельно собираемых проектов что-то найти на самом деле сложно.
5183.68 5189.36 "Игорь Лабутин" Так вот есть вкладочка build order, где они будут все упорядочены по порядку, как будто они собирались последовательно.
5189.36 5193.44 "Анатолий Кулаков" Да, понятно, но это все для спецов, которые любят отложивать msbuild.
5193.44 5197.60 "Игорь Лабутин" Ну это иногда нужно, когда у тебя какие-то сложные зависимости между проектами.
5197.60 5200.08 "Игорь Лабутин" Бывает нужно понять, кто же упал первым.
5200.08 5201.08 "Игорь Лабутин" Вот.
5201.08 5203.12 "Игорь Лабутин" И эта вот штука помогает.
5203.12 5204.12 "Игорь Лабутин" Дальше.
5204.12 5224.72 "Игорь Лабутин" Мы сегодня обсуждали немножко дебаггинг и source link, да, есть еще связанная штука под названием just my code, когда вы дебажите, вы можете включить или выключить, так сказать, возможность вообще показа в call stack, как например, только фреймов, относящихся к вашему коду, то есть к вашему текущему проекту или вообще всех.
5224.72 5231.84 "Игорь Лабутин" Для того, чтобы это менять во время дебага, нужно было идти в настройки студии, находить волшебную галочку, ставить.
5231.84 5240.12 "Игорь Лабутин" Иногда это хочется делать туда-сюда, то есть вы там поотложили какой-то кусочек, потом сказать, ладно, все, я понял, что там во фреймворке происходит, дальше отложим только мой код.
5240.12 5245.08 "Игорь Лабутин" Вот теперь во время дебага у тебя будет кнопочка прямо на тулбаре enable/disable just my code.
5245.08 5251.40 "Анатолий Кулаков" Ну опять же, это из той серии, что при инсталляции студии я эту галочку снимаю и всегда наслаждаюсь полным стэком.
5251.40 5253.44 "Анатолий Кулаков" В общем, я люблю смотреть, что там происходит на самом
5253.44 5262.08 "Игорь Лабутин" деле. Ну я тоже люблю, но иногда на самом деле я выключаю только just my code, но да, я это делаю действительно редко.
5262.08 5268.04 "Игорь Лабутин" Дальше, как часто ты начинал дебаг, случайно нажав f11?
5268.04 5269.76 "Анатолий Кулаков" Да, да, очень часто.
5269.76 5272.32 "Игорь Лабутин" Теперь не будет, то есть на f10, f11.
5272.32 5273.32 "Игорь Лабутин" Дебага вообще не будет?
5273.32 5275.76 "Игорь Лабутин" Нет, он не будет начинаться по f10, f11.
5275.76 5278.12 "Анатолий Кулаков" То есть для этого надо было специальный плагин ставить,
5278.12 5281.12 "Игорь Лабутин" чтобы hotkey выключить. Да, да, это прям экстенджинг для этого.
5281.12 5290.48 "Игорь Лабутин" Вот, дальше, штука под названием run_code_cleanup_on_formats, то есть когда ты форматируешь shortcut-иком файлик, он автоматически будет запускать код cleanup на нём.
5290.48 5295.60 "Игорь Лабутин" Ну я так понимаю, что ReSharper примерно такое делает, вроде бы.
5295.60 5306.60 "Анатолий Кулаков" Да, это хорошая штука, но ей в помощь неплохо бы вот всё-таки регион, что форматировать, то есть не весь файлик, а примерно то, где ты менял, например, один метод или два метода.
5306.60 5310.68 "Анатолий Кулаков" Весь файлик бывает довольно напряжно, но в общем случае почему бы и нет.
5310.68 5316.28 "Игорь Лабутин" Ну я согласен, да, ты там пошёл, пофиксил один метод, а потом переформатировал все остальные тысячу строк.
5316.28 5318.28 "Игорь Лабутин" И теперь комить.
5318.28 5319.28 "Игорь Лабутин" Вот, согласен.
5319.28 5326.60 "Игорь Лабутин" Ну, по крайней мере, раньше нужно было code cleanup делать как-то отдельно, а теперь это всё прямо одновременно с форматом.
5326.60 5336.44 "Игорь Лабутин" Дальше, некоторое количество связанного с копированием, то есть если ты стоишь на пустой строчке и скажешь control+c, то ничего не произойдёт.
5336.44 5338.44 "Игорь Лабутин" Вот, в текущем варианте…
5338.44 5343.20 "Анатолий Кулаков" Это полезная штука, потому что затирается буфер очень часто по такой причине.
5343.20 5346.24 "Анатолий Кулаков" И в общем многие программы именно отключают пустой control+c.
5346.24 5354.60 "Игорь Лабутин" Да, и такая же штука, если ты ничего не выделил, control+c, в обычном варианте скопирует текущую строчку, можно настроить, чтобы ничего не делал тоже.
5354.60 5358.32 "Игорь Лабутин" То есть только если у тебя есть selection, тогда это control+c будет работать.
5358.32 5373.32 "Анатолий Кулаков" Да, признаться, я никогда не копирую строку без selection, то есть всё равно или паранойя, или надежда на другие редакторы, то есть привычка в других редакторах, всё равно заставлять меня выделять полную строку и переучиваться ради одной студии, наверное, странно.
5373.32 5375.24 "Анатолий Кулаков" Поэтому тоже полезная, полезная фишка.
5375.24 5377.24 "Игорь Лабутин" А как ты выделяешь одну строку?
5377.24 5381.92 "Анатолий Кулаков" Shift+N или Shift вниз, смотря что мне нужно.
5381.92 5387.84 "Игорь Лабутин" Ну у тебя же курсор не обязательно стоить в начале строки, или надо сначала сказать home, потом shift+N, да, ну типа.
5387.84 5391.00 "Анатолий Кулаков" Да, да, наверное уже набил на home, shift+N.
5391.00 5394.80 "Игорь Лабутин" Вот, запомни новый шорткард, Alt+Shift+E выделить текущую строку.
5394.80 5397.56 "Анатолий Кулаков" Да я пальцы скорее поломаю, чем home+N нажму.
5397.56 5399.80 "Анатолий Кулаков" У меня вот home+N летает просто на ура.
5399.80 5401.80 "Игорь Лабутин" Нет, ну Alt+Shift+E, кстати, нормально, он удобный.
5401.80 5402.80 "Игорь Лабутин" Вот.
5402.80 5405.80 "Игорь Лабутин" Так, что ещё у нас про копирование?
5405.80 5408.80 "Игорь Лабутин" А, вот, вот это, кстати, клёвая тема.
5408.80 5416.36 "Игорь Лабутин" Если ты выделил, например, не знаю, у тебя есть там какой-нибудь ивчик, да, ну в смысле внутри метода, который тебе нужно скопировать.
5416.36 5427.00 "Игорь Лабутин" Если ты сейчас выделишь там все строчки, которые включают этот ив, скажешь Ctrl+C, но он так и скопируется всеми, собственно, пробильчиками или табами, да, чё он ты используешь для того, чтобы сделать, собственно, выравнивание.
5427.00 5428.00 "Игорь Лабутин" Правильно?
5428.00 5429.00 "Анатолий Кулаков" Да, конечно.
5429.00 5430.00 "Игорь Лабутин" Вот.
5430.00 5443.32 "Игорь Лабутин" Если ты теперь с этим экстенджером начнёшь выделение, начиная, собственно, с буквы i, ну то есть в первой строке не будешь выделять вот это вот выравнивание, пробелы выравнивания, то он отрежет от всех скопированных строк вот это выравнивание.
5443.32 5444.32 "Игорь Лабутин" Да, да, удобно.
5444.32 5452.04 "Анатолий Кулаков" Это когда ты будешь вставлять в то место, где у тебя отступы отличаются от того, что у тебя есть в оригинале.
5452.04 5453.04 "Анатолий Кулаков" Да, например, слайды.
5453.04 5454.04 "Игорь Лабутин" Верно.
5454.04 5455.04 "Игорь Лабутин" Вот.
5455.04 5458.16 "Игорь Лабутин" Очень удобная штука, я попробовал, причём сколько отступишь, столько он и отрежет.
5458.16 5460.16 "Игорь Лабутин" То есть это прям прекрасно.
5460.16 5466.40 "Анатолий Кулаков" Ну или в чатик, честно, можно, чтобы коллеге бросить там небольшие пару строчек, тоже бывает полезно.
5466.40 5468.48 "Игорь Лабутин" Ну да, да.
5468.48 5472.60 "Игорь Лабутин" Теперь если… А, часто ли ты двигаешь строчки по коду шорткатами?
5472.60 5476.44 "Игорь Лабутин" Знаешь ли ты, что есть шорткат, подвинуть строчку вверх-вниз?
5476.44 5477.44 "Анатолий Кулаков" Да, да.
5477.44 5480.80 "Анатолий Кулаков" Не то чтобы часто, но знаю и двигаю, да.
5480.80 5484.88 "Игорь Лабутин" Вот теперь он будет следить за, так сказать, отступами.
5484.88 5492.12 "Игорь Лабутин" То есть если ты этой строчкой вдвинул его в какой-нибудь, например, тот GIF, то она автоматически задвинется вправо автоматом.
5492.12 5494.12 "Анатолий Кулаков" То есть форматируется в этот момент.
5494.12 5495.12 "Игорь Лабутин" Ну типа того, да.
5495.12 5496.12 "Игорь Лабутин" Удобно, конечно.
5496.12 5497.12 "Игорь Лабутин" Так, что ещё?
5497.12 5498.12 "Игорь Лабутин" О, дальше про мышку.
5498.12 5499.12 "Игорь Лабутин" Мышка, мышка, мышка.
5499.12 5509.44 "Игорь Лабутин" Это клёвая штука, я на неё много раз попадал, соответственно, крутишь когда мышой, скроллишь.
5509.44 5511.72 "Игорь Лабутин" Периодически у меня на зум попадало.
5511.72 5516.32 "Игорь Лабутин" Ну в смысле, что я это Ctrl случайно нажмёшь и тут же зумишься.
5516.32 5518.56 "Игорь Лабутин" Вот теперь это можно отключить вообще полностью.
5518.56 5519.56 "Игорь Лабутин" Вот.
5519.56 5526.80 "Игорь Лабутин" И добавили почему-то шорткатик, видимо, если не полностью выключил, то можно заресетить зум в нужное место.
5526.80 5530.32 "Игорь Лабутин" Типа Ctrl+0 нажимаешь, у тебя зум ресетится в 100%.
5530.32 5531.32 "Игорь Лабутин" Вот.
5531.32 5532.96 "Игорь Лабутин" Ну или можно настроить куда, кстати.
5532.96 5537.04 "Игорь Лабутин" Можно настроить там, что по Ctrl+0, ну тебя там, не знаю, в 200% делается.
5537.04 5538.04 "Анатолий Кулаков" Вот.
5538.04 5541.80 "Анатолий Кулаков" Ну да, тоже удобно переключать, например, для проекторов, для презентации, потом возвращать обратно.
5541.80 5542.80 "Игорь Лабутин" Да-да.
5542.80 5558.48 "Игорь Лабутин" Так, ну выделение текущего файла в Solution Explorer, сдублировать текущее окошко, это всё, короче, экшены, которые были раньше, просто их не было в контекстной менюшке окошка.
5558.48 5561.44 "Игорь Лабутин" А, вот, теперь ещё можно сделать следующую штуку.
5561.44 5572.12 "Игорь Лабутин" Если ты, короче, райт кликнешь в любом месте C# файла, то теперь у тебя нижним пунктом этого контекстной менюшки будет сразу шорткат в настройке C# сеттингов в студии.
5572.12 5573.12 "Игорь Лабутин" Вот.
5573.12 5577.92 "Игорь Лабутин" Ну и в любом языке, по идее, это должно работать.
5577.92 5578.92 "Игорь Лабутин" Угу.
5578.92 5582.04 "Игорь Лабутин" Ну, в общем-то, и всё.
5582.04 5587.12 "Игорь Лабутин" Там всякие добавили ещё менюшки, которые были в главном меню, но не было в контекстной менюшке.
5587.12 5588.12 "Игорь Лабутин" Типа там.
5588.12 5592.88 "Игорь Лабутин" Пользоваться-то, кстати, иногда, я фичу видел, но ни разу не пользовался.
5592.88 5601.72 "Игорь Лабутин" Если скопировать в клейборд JSON-чик и сказать специальную командочку "Past Special", то можно из этого JSON-чика сразу сгенерить класс.
5601.72 5605.92 "Игорь Лабутин" Ну, в смысле, он при пасте, на самом деле, сгенерит класс, соответствующий этому JSON-чику.
5605.92 5612.16 "Анатолий Кулаков" Да, я такую штуку пользовался, но когда-то в далёкие студии, когда лет 10 назад, как минимум.
5612.16 5614.20 "Анатолий Кулаков" Почему-то мне раньше это было нужно.
5614.20 5616.20 "Игорь Лабутин" Там, наверное, было про XML ещё.
5616.20 5617.20 "Анатолий Кулаков" Да, да, наверное.
5617.20 5623.48 "Игорь Лабутин" Ну, в общем, короче, вот эти все странные фичи, они поближе перенесли в контекстную менюшку.
5623.48 5635.68 "Игорь Лабутин" А, ещё, кстати, можно теперь, если у тебя на методе, допустим, гора или на классе гора атрибутов, то теперь их можно сколлапсить, типа в одну строчку, ну, визуально.
5635.68 5636.68 "Игорь Лабутин" Вот.
5636.68 5637.68 "Игорь Лабутин" Чтобы скрыть их.
5637.68 5640.96 "Игорь Лабутин" Хотя я не знаю, зачем, потому что мне обычно интересно видеть атрибутчики.
5640.96 5647.24 "Анатолий Кулаков" Ну да, я давно же, со времен ВСФ, наверное, не встречал, чтобы у меня была гора прям атрибутов.
5647.24 5651.72 "Анатолий Кулаков" Как-то ASP не грешит этим.
5651.72 5657.92 "Игорь Лабутин" Нет, слушай, со временом ASP над коре, мне кажется, там рауты навесил, авторизацию навесил.
5657.92 5661.48 "Игорь Лабутин" Чё ещё можно навесить?
5661.48 5663.60 "Анатолий Кулаков" Респонс тайпы какие-нибудь ещё, да?
5663.60 5675.28 "Игорь Лабутин" Респонс тайпы в новой этой, про диггер минимум, там свагер что-нибудь, ну, или даже в старой варианте тоже это было, можно было свагером же навесить это уточнение про то, как теперь изгенерить метод.
5675.28 5682.04 "Игорь Лабутин" Там, знаешь, это ещё в свагер напиши какой-нибудь, если в свагер это атрибут, напиши какой-нибудь длиннющий дескрипшн, который ты перенесёшь на много строк.
5682.04 5687.84 "Игорь Лабутин" Не, я думаю, что там строк на 10 можно легко придумать каких-нибудь таких атрибутов.
5687.84 5690.56 "Игорь Лабутин" И в таком случае может быть действительно ценно, что их можно сколлапсить.
5690.56 5698.68 "Анатолий Кулаков" Я предпочитаю контроллеры держать чистыми, если у меня действительно много атрибутов над каждым методом, то я скорее всего вынесу это в фильтр или куда-нибудь туда.
5698.68 5706.00 "Анатолий Кулаков" Ну, то есть я предпочитаю какое-нибудь декларативное решение, которое обернёт всю эту штуку, а всё-таки контроллеры оставить чистенькими.
5706.00 5712.40 "Анатолий Кулаков" Поэтому у меня там практически никогда, кроме роута и соответственно HTTP метода, ничего больше нет.
5712.40 5713.40 "Игорь Лабутин" И фильтра.
5713.40 5717.04 "Анатолий Кулаков" Ну, фильтр где-то там зарегистрирован в стартапе, да.
5717.04 5722.96 "Игорь Лабутин" Ну, ты же можешь его тоже хотеть применять не ко всем методам и не ко всем контроллерам, поэтому будешь размечать атрибутами.
5722.96 5726.92 "Анатолий Кулаков" Опять же, напишу лямбдочку, которая отсеет ненужные контроллеры, да и всё.
5726.92 5727.92 "Игорь Лабутин" Понятно, ладно.
5727.92 5729.20 "Игорь Лабутин" Ну, вот примерно так.
5729.20 5734.76 "Игорь Лабутин" То есть всё то, что я перечислил в настройках этого экстенджена, можно включить/выключить индивидуально.
5734.76 5741.96 "Игорь Лабутин" То есть там каждая из этих вот штук имеет, по сути, каждая из этих опций имеет ключик там включено/выключено.
5741.96 5747.36 "Игорь Лабутин" Поэтому если вам что-то не надо или вам нравилось, чтобы в 10 начинается отладка, пожалуйста, отключите эту опцию.
5747.36 5752.88 "Игорь Лабутин" А так в целом, я говорю, что я прям вот со всей...
5752.88 5756.56 "Игорь Лабутин" Некоторые странные штуки, да, а некоторые прям очень ценные.
5756.56 5758.92 "Игорь Лабутин" Я порадовался, что поставил такую штуку.
5758.92 5764.28 "Игорь Лабутин" А главное, что экстенджен, вот эти все экстенджены от Мэтца, они все очень лёгкие.
5764.28 5768.84 "Игорь Лабутин" То есть их там можно, не знаю, десятками иметь в студии, и это как-то сильно ни на что не влияет.
5768.84 5771.92 "Анатолий Кулаков" Отличная, богатая тема.
5771.92 5780.92 "Анатолий Кулаков" Слушай, мы прям на ней так и просидели здорово, и ощущения такие, знаешь, как будто полгалерии экстендженов с тобой просмотрели и обсудили.
5780.92 5804.08 "Анатолий Кулаков" Да, много полезных фишек, как раз таки весь опыт разработчиков, он и складывается из таких маленьких фишек, которые позволяют тебе экономить по 200 миллисекунд на каждый твой тайп, но в конце концов это как раз и даёт все то ощущение, что код пишется быстро, стабильно, красиво, и ты не отвлекаешься на разные раздражающие мелочи.
5804.08 5806.92 "Игорь Лабутин" Да, например, придумать, какой код писать.
5806.92 5810.92 "Анатолий Кулаков" Да, об этом мы какую-нибудь другую тему, наверное, расскажем, не о этом.
5810.92 5813.08 "Игорь Лабутин" Да, если вы уже придумали, то действительно.
5813.08 5820.80 "Игорь Лабутин" Ну, на самом деле, половина этих фишечек — это не только про скорость кода, написание кода, а именно просто про какое-то удобство.
5820.80 5828.80 "Игорь Лабутин" То есть, если вы просто ходите по вашему коду или там отлаживаете его, или даже билдите, то даже такие мелочи тоже помогают.
5828.80 5841.00 "Анатолий Кулаков" Кстати, насчёт удобства, как я уже говорил, что в Visual Studio регулярно пытаюсь пользоваться, вот она мне кажется безумно неудобной и безумно плохой, я вполне допускаю, что просто-напросто не умею её готовить.
5841.00 5853.00 "Анатолий Кулаков" Поэтому если вы встречали какие-нибудь статьи по том, как настроить чистый Visual Studio с нуля, чтобы она была более или менее приличная, то тоже присылайте, кидайте, и, соответственно, попробуем.
5853.00 5859.44 "Анатолий Кулаков" Всё-таки хочется дать студии хоть какой-то шанс продержаться у меня больше часа в рабочем проекте, пока у неё это не получается.
5859.44 5863.24 "Игорь Лабутин" Я сейчас живу 50 на 50 в студии Ryder.
5863.24 5876.40 "Игорь Лабутин" В принципе, ну вот тот проект, которым я сейчас чуть более активно занимаюсь, там, к сожалению, ещё есть некоторое количество винформов, и тут Ryder пока не очень хорош для винформов, не всё умеет.
5876.40 5893.52 "Игорь Лабутин" А если мне нужно, например, много отлаживать особенно сторонний код, особенно какой-нибудь фреймворк сам по себе, ну тут Ryder получше, как мы обсуждали сегодня, вот сети GoToDefinition, это всё, оно пока получше работает.
5893.52 5896.88 "Игорь Лабутин" Поэтому у меня получается 50/50.
5896.88 5900.76 "Игорь Лабутин" Ладно, что у нас, есть ещё темы?
5900.76 5906.32 "Игорь Лабутин" Есть не очень техническая тема.
5906.32 5917.40 "Игорь Лабутин" Это наш такой нерегулярный блог про то, что мы ещё слушаем, и что мы ещё где-то услышали полезного и интересного, не обязательно относящегося к Дотонету.
5917.40 5930.40 "Игорь Лабутин" И сегодня оно прям практически совсем не относится к Дотонету, но у меня накопилось некоторое количество выпусков других подкастов, которые мне бы, наверное, было интересно порекомендовать, возможно, кого-то они заинтересуют.
5930.40 5955.80 "Игорь Лабутин" И если вы помните, я когда-то уже рекомендовал один из выпусков подкаста под названием «Новый подкаст-2», где Леонид Игольник рассказывал про то, как относиться к тому вот всем этим инвестициям в стартапы, в смысле, что такое раунды инвестиций, как это всё происходит, а что это значит для стартапов, для фаундеров и так далее.
5955.80 5966.60 "Игорь Лабутин" Оно было достаточно теоретично, ну в том смысле, что не каждый у нас начинает свой собственный стартап, да, и будет там выпускать свои акции, вот это всё, свои компании.
5966.60 5967.60 "Игорь Лабутин" Вот.
5967.60 5985.16 "Игорь Лабутин" Поэтому они записали ещё вторую часть, то есть ещё один полноценный большой выпуск про то, а что делать и как ко всему этому относиться, когда вы идёте в какую-то такую компанию, будь это стартап или просто какая-то уже большая компания, где вам, возможно, например, часть оффера будут предлагать акциями, ну или опционами.
5985.16 6023.84 "Игорь Лабутин" Что вообще это такое, как такие офферы оценивать, потому что далеко не всегда вы можете получить некоторое денежное выражение этого, и как вообще вот вести себя, на что смотреть, если вам вдруг почему-то это актуально, если вы раздумываете о том, чтобы, возможно, поработать где-то, ну не обязательно даже за границей, может быть, даже и у нас, но получите оффер, где будет написано, а ещё мы вам даём опционы, то вот в подкасте есть рекомендации, что с этим делать и как оценивать разные такие офферы, ну и сравнивать их, например, с соседним оффером, где дают только деньги.
6023.84 6027.72 "Игорь Лабутин" Вот, послушайте, вполне интересно.
6027.72 6048.32 "Игорь Лабутин" Второй подкаст, который меня хорошо зацепил, это .net rocks, выпуск номер 1780 с Андерсом Хейлсбергом, который, как известно, у нас автор кучи очень клёвых и весьма популярных языков, ну а именно трёх, вот, и в частности в этом подкасте он рассказывает про историю C#.
6048.32 6064.28 "Игорь Лабутин" Понятно, что подкаст был записан потому что 20 лет до .net и вот это всё, но они как-то довольно быстро скатились к тому, как всё это создавалось, почему в C# те длинные решения были приняты, как это повлияло на будущее, что ждёт C# в будущем, ну и так далее.
6064.28 6079.76 "Игорь Лабутин" То есть, очень здорово, Андерс отлично подробно всё это рассказывает, очень понятно, английского бояться не стоит, там всё хорошо и понятно, и если вам интересно, как это всё начиналось, послушайте внимательно, там всё прям, я запомнил, в общем, прослушал.
6079.76 6090.12 "Анатолий Кулаков" Ну и от самого автора это всегда интересно послушать, там с байками, с шутками, с прибаутками, в общем, чтобы быть в теме, как оно всё зарождалось, далёкие 20 лет назад.
6090.12 6097.48 "Игорь Лабутин" Да, даже больше, то есть это 20 лет назад релиз был, и всё это зарождалось, это ещё давнее.
6097.48 6099.52 "Анатолий Кулаков" Ещё во времена Дельфи?
6099.52 6103.68 "Игорь Лабутин" Ну не Дельфи, наверное, всё-таки, хотя про Дельфи он тоже немножко рассказывал.
6103.68 6108.12 "Анатолий Кулаков" Там очень много идей, кстати, у Дельфи было взято, поэтому это зря-жря.
6108.12 6111.08 "Анатолий Кулаков" Я думаю, он принёс оттуда очень хороший багаж знаний.
6111.08 6122.24 "Игорь Лабутин" Ну да, он принёс оттуда, они, конечно же, смотрели на Java, они, конечно же, смотрели на C++, они, конечно же, смотрели на кучу других вещей и пытались сделать что-то новое.
6122.24 6130.72 "Игорь Лабутин" И вот он как раз рассказывает, как и что, и пытались, и на что они смотрели тогда, какие задачи они пытались выполнить для себя.
6130.72 6143.52 "Игорь Лабутин" Вот, и последний блок, он на самом деле, это рекомендации от Макса Шошена, который, спасибо ему, обрабатывает частенько наш подкаст.
6143.52 6149.64 "Игорь Лабутин" Вот, это вообще не про IT, в каком-то смысле, это про биопротезирование.
6149.64 6163.88 "Игорь Лабутин" То есть Макс услышал выпуск подкаста "Запуск завтра", а я в какой-то момент услышал выпуск "Подлодки" 255-й, и как-то темы были подозрительно похожи.
6163.88 6172.84 "Игорь Лабутин" В итоге оказалось, что и туда, и туда пришли двое ребят-основателей компании Моторика, которые, собственно, занимаются биопротезированием и делают современные протезы.
6172.84 6178.84 "Игорь Лабутин" И тема вообще, с одной стороны, от IT очень далёкая, а с другой стороны оказалась довольно близкая, то есть там довольно много всякой IT.
6178.84 6188.44 "Игорь Лабутин" И я рекомендую на самом деле послушать оба выпуска, они немножечко проразные с разных сторон, ну просто потому что двое людей по-разному смотрят на это.
6188.44 6200.28 "Игорь Лабутин" Но прям такой, то, что я, наверное, люблю в проектах, которыми я занимаюсь, это очень такое практическое применение к реальной жизни.
6200.28 6201.28 "Игорь Лабутин" Назовём это так.
6201.28 6210.16 "Игорь Лабутин" То есть это не какая-то там виртуальный очередной интернет-магазин, да, ну он, конечно, тоже применим к реальной жизни, но всё-таки это такой далеко вот...
6210.16 6226.12 "Игорь Лабутин" Это ещё один просто магазин, а здесь прям такой хороший, прикольный практический продукт, который помогает людям послушать и посмотреть, как это всё живёт и чем вообще сейчас занимаются в этой области науки и медицины в том числе.
6226.12 6233.00 "Игорь Лабутин" Вот, это такие рекомендации на сегодня из того, что у меня тут подкопилось за последний месяц.
6233.00 6236.64 "Игорь Лабутин" Может быть, к следующему разу ещё чем-нибудь дослушаю и порекомендую.
6236.64 6237.64 None Отлично.
6237.64 6244.04 "Анатолий Кулаков" Я надеюсь, друзья, мы дали вам пищу и для прослушивания, и для размышления, и для чтения.
6244.04 6257.52 "Анатолий Кулаков" А вы, соответственно, в свою очередь, если вам не сложно, опять же, рекомендуйте нас своим друзьям, расшаривайте, делитесь, в общем, нашим подкастом, высказывайте своё мнение, пишите комментарии.
6257.52 6259.48 "Анатолий Кулаков" В общем, это всё для нас очень важно.
6259.48 6261.48 "Анатолий Кулаков" Ну что ж, пробежимся по списку.
6261.48 6264.08 "Анатолий Кулаков" Чего мы там ещё с тобой сегодня обсудили?
6264.08 6265.08 "Анатолий Кулаков" Да давай прощаться.
6265.08 6277.92 "Игорь Лабутин" Да, сегодня мы вспомнили, что дотнет 5.0 пора выкидывать на помойку, и через месяц он уже станет абсолютно неподдерживаемым, и срочно все бежим на 6.0, а особо готовые могут сразу на 7.0 уже.
6277.92 6281.00 "Игорь Лабутин" Я надеюсь, скоро выйдет очередной превью.
6281.00 6297.44 "Игорь Лабутин" Дальше узнали как раз-таки, что в следующем превью 7.0 дотнета будет новый подход к тому, как garbage collector оперирует памятью, мы забыли теперь про сегменты и стали пользоваться регионами, или станем пользоваться регионами.
6297.44 6316.24 "Игорь Лабутин" В Rostlinе завезли улучшение в GoToDefinition, и мы посмотрели вообще, как обычно всё это работает, и что такое PDB, как всё это связано, зачем SourceLink, и как правильно упаковывать свои исходнички и свои проекты, так чтобы с ними было удобно работать.
6316.24 6330.28 "Игорь Лабутин" Если вы используете авторизацию в SPM.Core, то мы посмотрели на пару статей, как это можно сделать с минимальным количеством кода, и как правильно сделать, если вам нужно несколько видов авторизации в приложении.
6330.28 6342.48 "Игорь Лабутин" Узнали, зачем делать классы по умолчанию sealed, потому что ваш код ускорится во много-много раз, может быть вы этого не заметите, но тем не менее он будет быстрее, и G2 будет полегче, G2 будет вам благодарен.
6342.48 6348.92 "Игорь Лабутин" Если вы работаете в Visual Studio, то посмотрите на два полезных экстенджина, Twix 2022 и Markdown Editor.
6348.92 6361.12 "Игорь Лабутин" Если вы редактируете Markdown, притаскивают они очень много мелких улучшений, которые действительно полезны, ну и некоторые рекомендации по подкастам, которые мы послушали и которые нам понравились.
6361.12 6379.12 "Анатолий Кулаков" Я напомню, что нас можно слушать практически на всех подкаст-площадках, Google подкаст, Apple подкаст, Яндекс.Музыка в YouTube, если что, ищите нас даже в ВКонтакте, у нас есть телеграммчик, там можно подписаться на наши анонсы и соответственно на бусти тоже.
6379.12 6382.52 "Анатолий Кулаков" Поэтому я думаю не потеряемся, в любом случае друг друга найдем.
6382.52 6387.64 "Анатолий Кулаков" Вот, на этом, наверное, все на сегодня, давайте прощаться и до новых встреч, всем пока.
