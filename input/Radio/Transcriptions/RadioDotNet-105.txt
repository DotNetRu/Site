0.00 11.64 SPEAKER_01 Здравствуйте, уважаемые слушатели, в эфире Радио.нет и выпуск номер 105.
11.64 15.08 SPEAKER_01 В студии, как всегда, постоянные ведущие – Анатолий Кулаков.
15.08 16.20 SPEAKER_00 И Игорь Лабутин.
16.20 17.20 SPEAKER_01 Всем привет!
17.20 36.76 SPEAKER_01 За нашими спинами гордые банда наших помогаторов, а именно… Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Павел, Лазарев Илья, Шевченко Антон, Ольга Бонаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей, Дмитрий Сорокин и Александр Ерыгин.
36.76 39.24 SPEAKER_01 Спасибо, друзья, а также всем, кто нас поддерживает.
39.24 45.08 SPEAKER_01 Очень приятно иметь такую шикарную поддержку нашего творчества.
45.08 52.80 SPEAKER_01 Ну что ж, прошлый выпуск у нас получился какой-то аномально огромный, постараемся больше так сильно не напрягать наших слушателей.
52.80 54.36 SPEAKER_01 Постоянно жалуются на какие-то большие выпуски.
54.36 57.20 SPEAKER_01 Сегодня попробуем пробежаться быстренько по темам.
57.20 62.84 SPEAKER_00 Да, компенсируем, сделаем сегодня маленький коротенький выпуск, но это мы сейчас вначале так говорим, посмотрим, что будет к концу.
62.84 73.56 SPEAKER_00 Давай-давай, пойдем, у нас новостей особо нет, ну в смысле, у Майкрософта, понятное дело, релиз вышел, новых релизов пока не было, поэтому пойдем по разным статьям.
73.56 81.24 SPEAKER_01 Ну да, пока Майкрософт отдыхает, он в принципе наплодил очень много интересных фич, которые вполне могут обсуждать и другие авторы.
81.24 94.08 SPEAKER_01 И вот другие авторы решили взяться за обсуждение транзакций, даже не транзакций, локов, для обсуждения локов, реализованных в Entity Framework, поэтому есть прекрасная статейка, которую мы с вами сегодня затронем.
94.08 116.20 SPEAKER_01 Статейка называется "Оптимистик лок против пессимистик лок ин дотнет", в общем под названием все звучит довольно широко и оптимистично, но на самом деле кейс получился довольно-таки узкий, ну и посмотрим по дороге тогда, не хочу сейчас рассусоливать, пойдемте посмотрим что такое оптимистик и пессимистик лок в разрезе Entity Framework в нашем случае.
116.20 119.32 SPEAKER_01 Итак, откуда вообще пошла проблема?
119.32 160.44 SPEAKER_01 Ну как известно, не было бы никаких проблем с параллелизмом, конкуренцией, если бы у нас был всегда один поток и мы бы работали всегда в одном workflow данных, то есть раньше, наверное, когда-то так даже и было, у нас была какая-то база данных, приложение в нее писало, приложение в нее читало и все в принципе было хорошо, но потом кто-то придумал многопоточность и мы пошли писать в эту базу данных из нескольких потоков и уже база данных стала как-то немножко поднапряжней, потом кто-то придумал сервер клиент приложения и в сервер пошли писать не просто многопотоков, а еще много клиентов в многопотоков и база данных вообще могла становиться очень-очень плохо.
160.44 181.44 SPEAKER_01 А база данных, как известно, это центр обычно самых главных, то есть главный источник всех данных, которые есть в приложении, в большинстве случаев это так и поэтому хочется, чтобы данные там всегда оставались консистентными и непротиворечимыми, поэтому необходимо было каким-то образом, какими-то механизмами обеспечивать непротиворечивость данных.
181.44 215.30 SPEAKER_01 Противоречивость могла возникнуть, когда, опять же, несколько потоков или несколько клиентов начинают писать одни и те же данные, вот представьте у вас есть какая-то один бакет или одна строчка в таблице и один клиент пишет туда статус номер один, а второй пишет статус номер два, нечто же произойдет, а неизвестно что произойдет, в зависимости от реализации, иногда данные покарабкаться, иногда выиграет последний, а данные предыдущего клиента потеряются, в общем, может быть все что угодно, поэтому придумали механизмы борьбы с конкарнси, которые позволяют вот эту самую консистентность обеспечить.
215.30 224.50 SPEAKER_01 Итак, автор утверждает, что у нас есть только два способа борьбы с конкарнси, это pessimistic log и optimistic log.
224.50 257.54 SPEAKER_01 Ну, естественно, на самом деле это не так, существует огромное подможество алгоритмов, которые помогают писать одновременно в одну и ту же область данных, то есть какую-то конкарнси делать, или структур или еще чего-то, например там multiversion concurrency control, который используется в постгре, или conflict-free replicated data types, более известный как CRDT, в общем, много способов существует, кроме локов для того, чтобы работать с параллельным потоком данных, с конкурентным потоком данных.
257.54 269.50 SPEAKER_01 Но локи действительно это самый, наверное, узнаваемый, примитивный и максимально используемый подход, максимально используемый механизм, поэтому как раз сосредоточимся на локах.
269.50 282.58 SPEAKER_01 Итак, все примеры будут запускаться на Entity Framework, под капотом будет SQL-сервер, но в принципе это не особо важно, потому что Entity Framework обеспечивает довольно хороший такой уровень абстракции, под который вы можете зарядить любую базу данных.
282.58 285.70 SPEAKER_01 В данном случае, конечно же, про реалиционно идет речь.
285.70 289.94 SPEAKER_01 Итак, разберемся для начала с pessimistic lock.
289.94 296.90 SPEAKER_01 Pessimistic lock - это когда несколько процессов пытаются модифицировать один и тот же ресурс параллельно.
296.90 301.34 SPEAKER_01 Pessimistic lock решает эту проблему с помощью эксклюзивного доступа.
301.34 323.30 SPEAKER_01 То есть он позволяет взять лок на этом ресурсе какому-то одному процессу, который пришел к нему первым, и до тех пор, пока этот лок не будет отпущен первым процессом, все остальные процессы, которые придут с претензией на взятие этого ресурса, они будут ждать в очереди и ждать, пока лок отпустится.
323.30 332.86 SPEAKER_01 Как только лок отпускается первым клиентом, второй клиент берет этот лок, заходит, начинает модифицировать и все остальные ждут, пока он отпустится.
332.86 339.46 SPEAKER_01 То есть, по сути, мы выстраиваем все наши параллельные процессы, все наши параллельные изменения в такую своеобразную очередь.
339.46 347.18 SPEAKER_01 Но у этого подхода, кажется, все хорошо, выстроили в очередь, все стоят, все ждут своей очереди, по одному меняют.
347.18 350.78 SPEAKER_01 В принципе, плюсы тут очевидны, но у этого подхода есть и минусы.
350.78 355.70 SPEAKER_01 Во-первых, как только мы их начинаем выстраивать в очередь, то у нас появляется ожидание.
355.70 357.66 SPEAKER_01 Таким образом, появляется замедление.
357.66 372.50 SPEAKER_01 То есть программы, которые используют pessimistic lock, они обычно, у них обычно вот это место, где сосредоточен сам лок, является bottleneck, то есть они в этом месте начинают медленнее работать, потому что ждут, пока другие потоки освободят им занятый ресурс.
372.50 375.42 SPEAKER_01 Другая распространенная проблема с этим алгоритмом - это deadlock.
375.42 389.74 SPEAKER_01 Если вам нужно взять несколько локов на различные записи, то тут очень важно соблюдать правильный порядок, иначе можно взять локи в таком порядке, что первый и второй клиент никогда друг друга не дождутся, то есть никогда ресурс не освободят.
389.74 397.98 SPEAKER_01 Таким образом, мы получаем, что в принципе алгоритм рабочий, но у него есть какие-то понятные минусы.
397.98 399.90 SPEAKER_01 Как его реализовать в Entity Framework?
399.90 401.70 SPEAKER_01 На самом деле, достаточно просто.
401.70 420.58 SPEAKER_01 Этот подход авторы предлагают реализовать с помощью serializable isolation level в Entity Framework, то есть мы открываем транзакцию с этим уровнем доступа, запрашиваем компонент из базы данных, изменяем каким-то образом его поля, сохраняем все изменения, коммитим транзакцию, и в принципе все хорошо.
420.58 431.22 SPEAKER_01 Если вдруг в этот момент пришел какой-нибудь параллельный поток, который пытается проделать все то же самое, у него выкинется exception соответствующий.
431.22 453.82 SPEAKER_01 Таким образом, мы под этим уровнем транзакции можем модифицировать данные в гарантии того, что никакой другой поток, никакой другой клиент не промодифицирует те же самые куски вместе с нами, те же самые таблицы вместе с нами, и таким образом получим своеобразный пессимистик лог.
453.82 461.42 SPEAKER_01 Но здесь есть небольшие, я бы даже сказал, большие проблемы, минусы у этого уровня.
461.42 470.22 SPEAKER_01 Во-первых, serializable уровень может заблокировать больше записей, чем мы его попросили.
470.22 477.44 SPEAKER_01 Это связано с низкоуровневой реализацией того, как база данных хранит свои записи и каким образом она ставит локи.
477.44 488.54 SPEAKER_01 Также он приводит к уменьшению производительности, потому что приходится брать дополнительные какие-то расходы на поддержку такого высокого, самого мощного уровня сериализации.
488.54 494.22 SPEAKER_01 И он одновременно уменьшает риск дедлоков.
494.22 499.08 SPEAKER_01 В принципе, дедлоков тут может быть как-то немножко поменьше.
499.08 506.64 SPEAKER_01 Данный уровень также предусматривает ручную обработку всяких эксепшенов, которые при этом могут вывалиться.
506.64 516.56 SPEAKER_01 Потому что как только к вам придет второй поток, который начнет модифицировать те же самые данные, которые сейчас находятся под транзакцией, то обычно база данных выкидывает исключения.
516.56 525.48 SPEAKER_01 Поэтому каждый кусок кода, который хочет использовать данный уровень транзакции, он обязан уметь обрабатывать соответствующие исключения.
525.48 529.10 SPEAKER_01 И на это исключение обычно делается какой-то повтор.
529.10 531.48 SPEAKER_01 Но при этом код довольно сильно усложняется, понимаете?
531.48 539.36 SPEAKER_01 Потому что каждая модификация обрастает какими-то непонятными эксепшен, хендлерами, какими-то повторами, какими-то ретрайвами, еще чем-то.
539.36 545.32 SPEAKER_01 В общем, код превращается в довольно-таки сложный для поддержки, для чтения.
545.32 552.08 SPEAKER_01 Но на самом деле кажется, что авторы реализуют вот этот pessimistic log как-то довольно странно.
552.08 565.52 SPEAKER_01 Ну потому что про их же определение pessimistic лока параллельный поток, который пришел модифицировать ожиданные, должен ожидать, пока первый закончит, а потом выстроится в очередь, а потом начать что-то свое писать.
565.52 572.96 SPEAKER_01 Если мы используем уровень serializable у транзакции, то она вам выбросит исключения, никакого ожидания не будет.
572.96 581.32 SPEAKER_01 И обязанность на том, чтобы подождать и снова попытаться, уже стоит на вашем приложении, что не так уж удобно, как обычный, например, pessimistic log.
581.32 585.16 SPEAKER_01 Как бы вы могли в голове себе представить пессимистичный лог?
585.16 597.00 SPEAKER_01 Это то, что каждый из вас, наверное, ощущает, когда вызывает стандартный кейворд в C# - log, ставит этот лог на какой-то ресурс, пишет безопасный код внутри и закрывает скоб.
597.00 598.00 SPEAKER_01 Все.
598.00 601.20 SPEAKER_01 Он гарантирует, что никто туда больше никогда не войдет.
601.20 609.88 SPEAKER_01 Поэтому здесь нет никаких исключений, здесь нет никакой заботы о каких-то там параллельных вхождениях, еще чего-то.
609.88 612.84 SPEAKER_01 В общем случае, мы просто ставим лог и забываем о всех проблемах.
612.84 614.52 SPEAKER_01 Вот хотелось бы чего-то именно такого.
614.52 615.52 SPEAKER_01 Здесь же нет.
615.52 626.04 SPEAKER_01 Здесь какие-то появляются эксепшены, ретраи, не забыть взять, не забыть отпустить, не забыть, что может быть залочатся какие-то другие записи, которые вы не ожидаете лочить.
626.04 630.44 SPEAKER_01 В общем, как-то слишком сложное решение.
630.44 635.32 SPEAKER_01 Можно было бы предложить более похожее что-то на то, что мы хотим.
635.32 636.60 SPEAKER_01 Это, например, advisory log.
636.60 644.12 SPEAKER_01 В PostgreSQL есть такая штука как advisory log, который в принципе очень сильно похож на тот лог, который есть в C#.
644.12 647.56 SPEAKER_01 Можно его взять, можно его отпустить, это буквально одна операция.
647.56 653.20 SPEAKER_01 Естественно, она не поддерживается Entity Framework, поэтому вам ее нужно как-то реализовать кастомно, но реализуется она довольно просто.
653.20 657.48 SPEAKER_01 И в интернете полно уже схем, как это сделать.
657.48 660.64 SPEAKER_01 Другой подход - это, например, можно сделать select for update.
660.64 669.44 SPEAKER_01 Если вам нужен какой-то пессимистичный лог в рамках довольно понятного и ограниченного количества данных, то может быть select for update вам подойдет еще даже больше.
669.44 674.68 SPEAKER_01 Можно еще сделать пессимистичный лог с помощью ручной таблицы.
674.68 677.64 SPEAKER_01 То есть у вас есть таблица, в которой вы записываете логи.
677.64 685.36 SPEAKER_01 И когда вы берете лог, вы в этой таблице делаете update и говорите, что я вот такой вот обработчик, такой вот хендлер взял лог.
685.36 690.84 SPEAKER_01 И все другие клиенты, которые к вам приходят, они должны сначала update в этой таблице смочь сделать.
690.84 692.64 SPEAKER_01 Если не могут сделать, значит ждут.
692.64 696.08 SPEAKER_01 Если могут, значит запись свободна и пошли дальше модифицировать.
696.08 697.32 SPEAKER_01 Такие тоже вещи существуют.
697.32 701.36 SPEAKER_01 В общем, способов сделать пессимистичный лог их довольно таки много.
701.36 706.20 SPEAKER_01 И serializable isolation level, наверное, не самый первый, который мне пришел бы в голову.
706.20 708.46 SPEAKER_01 В общем, непонятно, почему авторы сюда полезли.
708.46 710.32 SPEAKER_01 Но, в общем, это так.
710.32 713.56 SPEAKER_01 Итак, с пессимистичным логом мы разобрались.
713.56 719.40 SPEAKER_01 То есть это лог, который сначала ставится на ресурс, потом ресурс модифицируется и после этого лог отпускается.
719.40 723.76 SPEAKER_01 Его проблемы как раз таки в основном в том, что он оказывается bottleneck.
723.76 728.56 SPEAKER_01 То есть пока ресурс модифицируется, то есть под логом может быть не только модификация ресурсов.
728.56 734.16 SPEAKER_01 Например, сама модификация ресурсов довольно таки может быть и быстрой, но обычно под лог засовывают чего-то еще.
734.16 740.88 SPEAKER_01 Ну, например, загрузить данные, проверить эти данные, проанализировать, что это те данные, которые нам нужны.
740.88 750.40 SPEAKER_01 Взять новый модификатор, заапдейтить данные, потом может быть запустить какой-то верификатор, потом может еще что-то сделать.
750.40 754.76 SPEAKER_01 В общем, и вот эти дополнительные накладные расходы, на которых в принципе лог-то на самом деле и не нужен был.
754.76 756.48 SPEAKER_01 Лог нужен был только на сам апдейт записи.
756.48 762.64 SPEAKER_01 И вот они приводят к вот этим дополнительным расходам, которые возникают при пессимистичных логах.
762.64 765.64 SPEAKER_01 Этих минусов более-менее лишен оптимистичный лог.
765.64 771.40 SPEAKER_01 Вместо того, чтобы брать лог на ресурс, пессимистичный лог делает другую штуку.
771.40 779.76 SPEAKER_01 Он во время сохранения самой записи определяет, а была ли версия записи, которую мы сохраняем, точно такая же, которая лежит в базе данных.
779.76 787.48 SPEAKER_01 Ну то есть, по факту, не успел ли кто-то другой модифицировать ее, пока мы что-то там, какую-то магию с ней творили, каким-то образом ее изменяли.
787.48 798.36 SPEAKER_01 И если вдруг система детектирует, что да, запись в этот момент поменялась, она только в этот момент выбрасывает исключение, что типа, чувак, давай сделать что-нибудь другое, твоя запись была изменена.
798.36 811.20 SPEAKER_01 Но если никаких конфликтов других не было, ну то есть параллельно никто эту запись изменить не смог, то транзакция проходит практически с той же скоростью, с теми же накладными расходами, которые были бы и абсолютно без нее.
811.20 813.24 SPEAKER_01 Это безусловный плюс оптимистик логов.
813.24 816.16 SPEAKER_01 Теперь давайте же разберемся, каким образом их реализовать в Entity Framework.
816.16 820.36 SPEAKER_01 Во-первых, нам понадобится дополнительная колонка, которая обозначает версию.
820.36 831.08 SPEAKER_01 Глядя на эту колонку, Entity Framework будет сам трекать то, какой версии данные были закружены, то, какой версии данные сейчас сохраняются в базу данных и сам будет каким-то образом на это реагировать.
831.08 836.84 SPEAKER_01 То есть с каждой записью, которую вы считаете с базы данных, он плюс считает вот эту колонку с версией.
836.84 846.92 SPEAKER_01 Для того, чтобы это сделать, вам необходимо в вашу модельку добавить новое полик, который называется, допустим, Raw Virgin, и навесить на него специальный Entity Framework атрибут, который называется Timestamp.
846.92 857.88 SPEAKER_01 Это специальный атрибут, который рассказывает Entity Framework как раз таки, что и нужно включить автоматическую обработку concurrency-чеков, и она начинает автоматически это делать.
857.88 863.28 SPEAKER_01 Безусловно, можно это сделать не с помощью Attribute, а с помощью Fluent API, но смысл остается тот же самый.
863.28 867.52 SPEAKER_01 Что произойдет, например, если вдруг у вас выполняется метод.
867.52 868.52 SPEAKER_01 Как вы можете это симулировать?
868.52 878.88 SPEAKER_01 Например, перед изменением своей записи, вы сначала запись загружаете в память, в это время загружается, естественно, вместе с вашей Entity и версия.
878.88 886.36 SPEAKER_01 Затем можно выполнить сырой запрос, для того, чтобы Entity Framework его не заметил, который обновляет эти данные, которые хранятся в вашей базе данных.
886.36 892.16 SPEAKER_01 После этого вы меняете у своей Entity необходимые вам поля и пытаетесь сохранить.
892.16 906.00 SPEAKER_01 В данный момент вы получите db_update_concurrency_exception, Entity Framework сам узнает, то есть определит вот этот конфликт, что у вас теперь raw_version поменялось, и выбросит вам exception.
906.00 909.60 SPEAKER_01 В этот момент вы должны подумать, что с этим exception вам делать.
909.60 911.68 SPEAKER_01 В большинстве случаев вы хотите просто-напросто заретраиться.
911.68 929.16 SPEAKER_01 Если же вы хотите не такой большой магии по контролированию вот этого поля version, то есть у нас Entity Framework сам его загружает, сам его при сохранении проверяет, сам его инкрементирует, если уже не было конфликтов, в общем, это он делает все сам.
929.16 939.44 SPEAKER_01 Если вы хотите более ручное управление, более гибкое управление, то существует небольшая альтернатива нашему таймстэмпу, который называется Concurrency Check.
939.44 947.88 SPEAKER_01 Этот атрибут точно также нужно нацепить над каким-нибудь новым полем типа version и можете дальше использовать его абсолютно так же, как и при ведущем варианте.
947.88 952.00 SPEAKER_01 С одним единственным исключением, Entity Framework не будет вам это поле автоматически инкрементировать.
952.00 959.20 SPEAKER_01 Если вы хотите сказать, сообщить, что версия вашей Entity поменялась, значит, вы должны это сказать вручную, сообщить вручную.
959.20 965.44 SPEAKER_01 И если вдруг он обнаружит конфликт, то у вас будет точно такой же db.concurrency.exception.
965.44 975.88 SPEAKER_01 Нужно сказать, что при этом, если у вас включены логики Entity Framework, то там подробно будет описано, какой SQL-запрос это преобразуется, какой конфликт был вызван, почему был вызван.
975.88 983.12 SPEAKER_01 Поэтому в логах много всего пишется, если вы хотите, то отладку обязательно включите для того, чтобы посмотреть, что там, собственно, происходит под капотом.
983.12 984.96 SPEAKER_01 Вот таких есть два подхода.
984.96 1000.08 SPEAKER_01 Опять же, к optimistic log у меня тоже есть большие вопросы, потому что реализация, то есть мы никак не можем работать с optimistic логом, кроме эксцепшенов в Entity Framework.
1000.08 1001.08 SPEAKER_01 И это довольно-таки плохо.
1001.08 1009.72 SPEAKER_01 Потому что любой человек, который хоть раз в жизни в SQL реализовал optimistic логи на чистом SQL, он, естественно, никакие эксцепшены не бросает и ничего не делает.
1009.72 1011.88 SPEAKER_01 Как реализуется нормальный optimistic лог?
1011.88 1017.76 SPEAKER_01 Вы обновляете запись и в апдейте пишите условие vaversion = 1.
1017.76 1028.76 SPEAKER_01 Таким образом, когда вы обновляете эту запись и запись в базе данных находится под версией 1, у вас количество измененных элементов будет 1.
1028.76 1036.76 SPEAKER_01 Если же вы обновляете запись и в это время уже параллельный поток какой-то увеличил эту версию, то количество измененных элементов будет 0.
1036.76 1046.64 SPEAKER_01 Таким образом, анализируя количество измененных элементов после вот этого апдейта, вы можете определить, была ли успешна ваша optimistic транзакция, даже не транзакция, а апдейт.
1046.64 1047.64 SPEAKER_01 Оптимистик апдейт.
1047.64 1049.40 SPEAKER_01 Был ли он успешен или неуспешен.
1049.40 1056.40 SPEAKER_01 Таким образом, просто-напросто вернув количество измененных записей, можно, анализируя это количество, обойтись без всяких эксцепшенов.
1056.40 1063.24 SPEAKER_01 Можно просто сделать нормальный анализ и немножко сэкономить себе там перформансы и удобства, не используя эксцепшены.
1063.24 1069.72 SPEAKER_01 В Entity Framework такой штуки очень долго не было, потому что как раз-таки не было апдейта с условиями.
1069.72 1080.20 SPEAKER_01 Недавно появился апдейт, в который мы можем вставить where, то есть, по сути, вставить условия, и вы можете сделать свой нормальный оптимистик апдейт теперь без всяких эксцепшенов.
1080.20 1083.92 SPEAKER_01 Почему-то, опять же, в никаких примерах этого не сообщают, не дают.
1083.92 1087.12 SPEAKER_01 И говорят нам, что мы обязаны сидеть на каких-то только db-конкуренции эксцепшенах.
1087.12 1095.72 SPEAKER_01 В общем, если вы не любите эксцепшены, то вот это тоже подход очень хороший, и он работает, и, в принципе, сейчас его в EFI можно легко заиспользовать.
1095.72 1098.40 SPEAKER_01 Ну и так, с чем же мы пришли?
1098.40 1100.88 SPEAKER_01 У нас есть, в принципе, три варианта.
1100.88 1103.04 SPEAKER_01 Один пессимистик и два оптимистик лока.
1103.04 1106.12 SPEAKER_01 Посмотрим же, кто из них лучше и кого нужно использовать.
1106.12 1109.16 SPEAKER_01 Ну, на самом деле, нет однозначного ответа, как всегда.
1109.16 1121.96 SPEAKER_01 Все зависит от вашего способа, от того, насколько часто у вас конфликты, какой у вас большой уровень конкуренции, от перформанса вашего приложения и прочих таких факторов.
1121.96 1130.80 SPEAKER_01 Например, пессимистик лок, наверное, хорош, потому что он может работать без образования конфликтов.
1130.80 1134.16 SPEAKER_01 То есть никаких у вас, по сути, конфликтов в данных не будет.
1134.16 1141.48 SPEAKER_01 Все апдейтеры будут выстраиваться в очередь, а когда есть очередь, писатель получается по факту один, и конфликтов нет.
1141.48 1142.48 SPEAKER_01 Это бесспорный плюс пессимистик локов.
1142.48 1153.60 SPEAKER_01 Также он, если он реализован, допустим, с помощью каких-то механизмов, которые позволяют затронуть вам несколько записей.
1153.60 1161.52 SPEAKER_01 То есть не одну версию в одной сущности вам нужно поменять, а в вашей транзакции, допустим, участвуют несколько таблиц.
1161.52 1164.98 SPEAKER_01 В общем, здесь тоже пессимистик лок, в принципе, довольно хорошо себя показывает.
1164.98 1172.44 SPEAKER_01 Из минусов – это образование bottle neck, то есть то место, где стоит ваша очередь, оно как раз будет тормозить во всем вашем приложении.
1172.44 1175.64 SPEAKER_01 Ну и, возможно, дедлоков, куда же без этого.
1175.64 1180.84 SPEAKER_01 Оптимистик локи в плане минусов намного лучше, потому что у них есть свои проблемы.
1180.84 1188.20 SPEAKER_01 Если брать оптимистик лок, то безусловным его плюсом является в том, что нет никакой блокировки.
1188.20 1194.92 SPEAKER_01 В лучшем случае вы пройдете обновление, даже не заметив его, в худшем случае у вас будет ретрай.
1194.92 1199.32 SPEAKER_01 Поэтому при большой конкурентности данный способ более предпочтителен.
1199.32 1210.60 SPEAKER_01 Если мы берем вариант с raw version, то здесь Entity Framework на себя полностью берет автоверсионирование, то есть слежка за версией, закачивание версии, модификация версии.
1210.60 1213.36 SPEAKER_01 Все это берет на себя Entity Framework, что достаточно таки удобно.
1213.36 1219.72 SPEAKER_01 Из минусов у вас могут возникнуть конфликты, и вам нужно думать, как эти конфликты обработать.
1219.72 1222.72 SPEAKER_01 Не всегда повтор – это самое лучшее решение.
1222.72 1225.36 SPEAKER_01 Тут зависит уже конкретно от вашего кейса.
1225.36 1231.64 SPEAKER_01 И из минусов, если вы неправильно обработаете конфликт, вы можете потерять данные, что тоже в предыдущем случае было бы невозможно.
1231.64 1238.68 SPEAKER_01 Это тоже такой очень большой минус оптимистик лока, которым приходится расплачиваться за производительность.
1238.68 1251.32 SPEAKER_01 И оптимистик лок с concurrency токеном, в принципе, наследует все плюсы оптимистик лока, но плюсы, и также дополнительным плюсом он дает вам более гибкое управление версиями.
1251.32 1266.28 SPEAKER_01 Очень сложно придумать, зачем это могло бы пригодиться на практике, но, наверное, если у вас какая-то изощренная система типа совместного онлайн-редактирования одного документа несколькими пользователями или что-то в этом духе, то, наверное, ручное управление вам зачем-то может быть нужно.
1266.28 1274.32 SPEAKER_01 Ну и из минусов, конфликты вы точно также должны управлять вручную и каким-то образом их разруливать.
1274.32 1297.08 SPEAKER_01 Такой небольшой обзорчик, в принципе, мы так кратко с верхнего уровня познакомились, как это реализовано в Entity Framework и что с этим можно сделать, но, в принципе, держите в уме, что реализации оптимистик и пессимистик лока можно сделать на SQL и на Entity Framework гораздо больше и они будут обладать более такими гибкими и удобными свойствами, чем те, которые представлены в статье.
1297.08 1323.32 SPEAKER_00 Вообще, в общем, полезно изучать те инструменты, с которыми вы работаете, не думать, что Entity Framework все решит за вас, хотя, не знаю, 90%, наверное, проблема, если не 95% для некоторых проектов он решает, но для тех самых оставшихся 5% или 10% нужно действительно хорошо знать, за какими инструментами пойти в базу быть той адвайзери локи или еще что-нибудь и в каких ситуациях что нужно применять, а тут…
1323.32 1349.72 SPEAKER_01 Наверное, смотри, этим как раз и отличается хороший программист от плохого, потому что плохой он остановится где-то на уровне Entity Framework и не понимая то, как работает SQL, что там происходит под капотом, он сильно много хорошего сделать не сможет, а хороший программист он всегда понимает на уровень дальше, т.е. он знает, как работает SQL, он знает, что от него ожидать, он знает, каким образом на чистом SQL реализовать те или иные паттерны и тогда он их сможет грамотно использовать в высокоуровневом фреймворке.
1349.72 1367.08 SPEAKER_00 Я тут даже, наверное, сказал не хороший-плохой, а скорее опытный и неопытный, т.е. ты можешь быть хорошим, но пока еще неопытным программистом, но вот когда ты обретешь этот опыт работы напрямую с SQL, понимание, когда какой лок применить, ты хотя бы в этой части становишься уже опытным.
1367.08 1373.16 SPEAKER_01 Согласен, да, но просто тебе нужно хотеть этот опыт обрести, тебе не нужно останавливаться на этом уровне.
1373.16 1374.16 SPEAKER_00 Это правда.
1374.16 1388.00 SPEAKER_00 Ну давайте будем становиться более опытными программистами в разных областях и погрузимся в ту часть, в которую мы на самом деле довольно давно не ныряли, а именно ивенты, ETV, dotnet monitor и вот это вот все.
1388.00 1457.68 SPEAKER_00 Потому что вышла статья Кристофа Назаре, а как вы знаете, эта фамилия обычно ассоциируется со всякими низкоуровневыми штуками, профайлерами, garbage-коллектором и прочим таким интересным контентом, и он не подвел в этот раз, он написал toolzoo, toolzoo называется dotnet.txt, это такой очень кастомный command-line профайлер, который выполняет довольно узкую задачу, а именно он берет ваше приложение и пока оно работает, он логирует на каждый внешний вызов вашего приложения, что произошло, ну в смысле что произошло, на какой уровень мы сходили, какой был код ответа, но это все неинтересно и в общем-то это вы можете узнать какими-то другими способами, а вот что более интересно, это внутрянка дотнета, а именно сколько времени потратилось на DNS, сколько времени потратилось на установление соединений, сколько времени потратилось на любые security штуки, там tls-handshake, либо еще что-то, и возможно сколько времени потратилось на всякие редиректы до тех пор, пока мы собственно не начали качать непосредственно контент того, чего вы там запрашивали, а что-то по клиентам.
1457.68 1473.52 SPEAKER_00 Это может быть полезно для понимания, где ваше приложение тормозит, если, например, вы видите по какой-то статистике, там не знаю, в каких-нибудь графаниях, в каких-нибудь трейсах, что почему-то внешние вызовы выполняются долго, и вам нужно понять, что там происходит более точно.
1473.52 1492.64 SPEAKER_00 Но сама статья, она не про то, зачем вам это может быть надо, а про то, как это реализовать, и это, конечно же, как обычно, для программистов наиболее интересная часть, потому что вот это все, почему там и так далее, это может быть скучновато, а вот как это работает внутри, это может быть интересно, особенно в контексте нашего подкаста, где мы в том числе рассказываем, как это все устроено.
1492.64 1503.08 SPEAKER_00 Итак, надо вспомнить, что и Runtime, и BaseClassLibrary, и PCL, они генерят довольно большое количество ивентов.
1503.08 1519.56 SPEAKER_00 Ивенты эти генерятся разными способами, у нас есть механизм ETV, Event Tracing for Windows, у нас есть механизм просто ивентов, которые потом вы можете, они кросс-платформенные, можно словить дотнет-монитором, например, и посмотреть на них.
1519.56 1540.08 SPEAKER_00 И если вы посмотрите в документацию Microsoft, то там будет написано довольно много разных ивентов, в статье у Кристофа приведены эти ссылочки, но там просто написано, что, мол, когда HTTP-реквест начинается, эмитится вот такой-то ивент, а когда HTTP-реквест заканчивается, эмитится вот такой-то ивент, в смысле названия.
1540.08 1558.56 SPEAKER_00 Но, таким образом, вы можете понять, сколько это тот же самый HTTP-реквест длился, но нет никакого описания о какой payload у этих ивентов, и поэтому понять, собственно, что был за URL в этом HTTP-реквесте, это на самом деле требует некоторого исследования.
1558.56 1566.12 SPEAKER_00 Поэтому первая часть — это то, как понять, о какой вообще payload у этих ивентов, ну, благо дотнет у нас сейчас кросс-платформенный, поэтому надо смотреть в код.
1566.12 1585.56 SPEAKER_00 И в коде мы можем заметить, что все классы, ну или по крайней мере те, которые нас сейчас интересуют для той области в сетевом стеке, которые нас сейчас интересуют, для того, чтобы имитить эти ивенты, они все наследуются от класса EventSource и имеют суффикс телеметрии.
1585.56 1587.88 SPEAKER_00 Это очень удобно для поиска.
1587.88 1602.72 SPEAKER_00 Дальше можно убедиться, что, как и положено по документации, все они декорированы атрибутом EventSource, в котором написано то самое имя провайдера, который вы можете найти в документации, и GUID, который нам там может чуть позднее понадобиться.
1602.72 1613.60 SPEAKER_00 Также там есть публичные методы, которые используются для того, чтобы вызывать генерацию этих ивентов, но в публичных методах ничего интересного нет, потому что они делегируют свою работу приватным методом.
1613.60 1633.16 SPEAKER_00 А приватные методы, они делегируют все это в метод writeEvent обычно, который внутри как раз собирает структурку под названием eventData, дополняет ее нужными полями, и после этого вызывает уже writeEventCore, это из базового класса из EventSource, который, собственно, и пишет все, что нужно.
1633.16 1644.96 SPEAKER_00 И вот как раз, если посмотреть в эти writeEvent методы, которые потом вызовут writeEventCore, то можно посмотреть, что же складывается в eventData.
1644.96 1660.40 SPEAKER_00 Кристоф это, соответственно, сделал, для нужных нам ивентов описал в табличках, где нам искать урлы, где нам искать там то, сё, пятое, десятое, поэтому я прям сейчас не буду перечислять, понятное дело, бинарный payload того, как это все там разложено, не так это сейчас принципиально.
1660.40 1683.68 SPEAKER_00 Важно то, что если вам вдруг зачем-то, вы знаете, что о, мою проблему можно решить, посмотрев, возможно, на нужные какие-то ивенты от BCL или Runtime, но вы нигде не можете найти описание, какие же там данные, можно просто посмотреть в код, вот таким способом найти вызовы writeEventCore, найти перед этим, как собирается eventData и узнать, что же там лежит.
1683.68 1698.80 SPEAKER_00 Понятно, что это может быть немножко непереносимо, понятно, что это может меняться с версиями, но в конце концов вы же отложите проблему вашу конкретно на конкретном дотнете, а не пишете универсальный тул для всего, ну и скорее всего, признаться, вряд ли они будут сильно меняться со временем.
1698.80 1708.72 SPEAKER_00 Итак, ну мы поняли, какие ивенты нам нужны, мы примерно поняли, что в них лежит, теперь надо понять, как этим всем работать, профайлер-то надо написать, чтобы он всё это слушал.
1708.72 1728.48 SPEAKER_00 Для этого делаем следующее, у нас есть nuget-пакет, который называется TraceEvent, а также есть еще nuget-пакет Microsoft Diagnostics NetCore Client, который позволяет, там есть класс под названием EventPipeClient, который позволяет подключиться к приложению и послушать все эти ивенты.
1728.48 1736.32 SPEAKER_00 Напомню, что они все через пайпы для кроссплатформенности засылаются в клиента.
1736.32 1767.80 SPEAKER_00 Дальше вы создаете SessionConfiguration, передаете список провайдеров, вызываете CollectTracing метод, он, собственно, стартует трейсинг и возвращает вам некий ридер, но ридер он бинарный, то есть это просто бинарный протокол, вы просто получите бинарный поток данных, который не очень интересно читать, точнее, читать-то может интересно, но неудобно разбирать и работать с ним практически, поэтому для этого вам нужен еще EventPipeEventSource класс, которым передается этот ридер, и оттуда вы уже получаете нормальные объекты.
1767.80 1772.00 SPEAKER_00 Ну как получаете, на них надо подписаться, но сейчас об этом чуть позднее.
1772.00 1780.36 SPEAKER_00 Для того, чтобы создать сессию, вам нужно туда передать список провайдеров, значит, что такое провайдеры?
1780.36 1797.16 SPEAKER_00 Провайдеры - это те самые имена или гуиды провайдеров, кого вы хотите слушать, потому что можно, конечно, передать и слушать все, но это будут, ну если не миллионы, то тысячи ивентов, и зачем вам это, если вы точно знаете, какие вам нужны?
1797.16 1836.24 SPEAKER_00 Вы вроде выяснили, что нам нужны там провайдеры из namespace.system.net.что-нибудь, ну там DNS, security, там их несколько в статье перечислены, все они будут перечислять, но если их добавить, то вы на самом деле не получите идеальной картинки, потому что вам будут приходить, допустим, HTTP request started, HTTP request stopped, но у нас же приложение многопоточное, как мы говорили при обсуждении прошлой статьи, и много параллельных внешних запросов могут быть, то есть ваши несколько там обработчиков ваших запросов могут одновременно отправлять запросы на внешние сервисы.
1836.24 1849.04 SPEAKER_00 И связать события про то, что request started и request stopped на самом деле не так просто, учитывая то, что у нас весь стэк асинхронный, как правило, это все может приходить из совершенно разных потоков, и как-то это нужно связывать.
1849.04 1856.00 SPEAKER_00 Для того, чтобы это все связывать в event вот этой инфраструктуре, существует понятие activity_id.
1856.00 1865.40 SPEAKER_00 Activity_id это некоторая строчка на самом деле, ну то есть точнее это на самом деле число, но вы можете ее считать строчкой.
1865.40 1869.32 SPEAKER_00 Я, кстати, не помню, как она в апишке выглядит, event source.
1869.32 1875.40 SPEAKER_00 В perfu просто это строчка обычно, ну допустим, в общем, потому что их в дерево можно объединять в итоге, потому что там собирается строка.
1875.40 1887.92 SPEAKER_00 Но по-моему все-таки activity_id это число, которое как раз навешивается при старте и стопе событий, которые связаны друг с другом, и для этого оно прокидывается везде.
1887.92 1900.44 SPEAKER_00 Но вот для того, чтобы оно все работало и все правильно прокидывалось, внезапно нужно еще в провайдере обязательно подписаться на специальный System Tracing Tasks TPL Event Source.
1900.44 1907.84 SPEAKER_00 Вот если вы на него подпишетесь, даже если вы не будете слушать ничего, у вас будет корректный activity_id везде.
1907.84 1909.52 SPEAKER_00 Вот такая вот особенность.
1909.52 1913.40 SPEAKER_00 Видимо считается, что если вам таски не нужны, то и activity_id вам не нужно.
1913.40 1920.44 SPEAKER_00 А так вы получите правильный activity_id из тасочков, из нужного провайдера.
1920.44 1943.20 SPEAKER_00 После того, как вы все это сделаете, дальше вы у этого event source говорите "хочу подписаться", можно подписываться на какие-то суперспецифичные штуки, но как правило проще всего подписаться на событие all_events, просто стандартная синтаксис mc# подписки, там source.all_events+=on_events.
1943.20 1953.32 SPEAKER_00 Внутри on_events вы будете получать событие, когда приходит любой из ивентов из тех провайдеров, на которые вы подписались.
1953.32 1969.12 SPEAKER_00 Но для того, чтобы дальше разобраться, а что это за ивент, потому что там же бинарный payload, и в on_event вам приходят в общем-то только некоторые метаинформации и бинарный payload этого ивента, вам нужно понять откуда этот ивент.
1969.12 1971.48 SPEAKER_00 И вот именно тут пригодятся гуиды.
1971.48 1994.60 SPEAKER_00 Вам нужно для… в классах провайдера вам нужно будет эти самые гуиды сравнивать, то есть вы берете… имени не приходят в ивенте, насколько я помню, приходят только гуиды провайдера, поэтому вы у каждого провайдера, который вы перечислили, спрашиваете гуид и сравниваете его с тем гуидом в ивенте, который пришел.
1994.60 1999.32 SPEAKER_00 И как только вы нашли совпадение, значит это ваш ивент, который вы ждете.
1999.32 2013.72 SPEAKER_00 Точнее, не то, что ваш, вы понимаете, от какого провайдера пришел гуид, вы понимаете какой это ивент, ну потому что ивент-код там есть, и тогда вы можете разобрать наконец-таки payload бинарный, децерализовать его и что-то с ним сделать.
2013.72 2021.16 SPEAKER_00 Например, посчитать те самые дельты по времени, сколько у нас занял DNS-запрос, сколько заняла security, вот это все.
2021.16 2058.92 SPEAKER_00 Такая вот история, то есть если вдруг вы думаете или вы уверены, что вы хотите попробовать какую-то вашу внутреннюю кухню, то есть вы видите какое-то странное поведение и вы по ивентам не хотите лазать по какому-нибудь перфью или еще что-нибудь в таком духе и хотите получить совсем супер детальную диагностику, то вы можете реализовать эту конструкцию, причем в принципе слушать можно же и внутри самого приложения, самого себя, вам никто не мешает прямо внутри приложения встроить такую диагностику самого себя, слушать это все и репортить наружу, например в виде каких-нибудь прометеусовских метрик.
2058.92 2069.88 SPEAKER_00 И тогда будет видно, что например у вас там тормозит, ну допустим, DNS или еще что-нибудь.
2069.88 2090.12 SPEAKER_00 Теперь вот есть такой достаточно понятная, хорошо написанная статья, которая позволит вам легко это сделать либо в своем приложении, либо в стороннем, либо взять просто готовый tool, он инсталится как global tool, как обычно это делается через command line и можно им пользоваться, благо что он command line и поэтому по идее он работает даже внутри контейнера, если очень интересно.
2090.12 2091.12 SPEAKER_00 Такие дела.
2091.12 2105.72 SPEAKER_01 Слушай, полезная штука, мне кажется, что она еще больше станет полезной, если ее включат в какой-нибудь стандартный профайлер, который там все пользуются, и чтобы она показывала вот эти все вещи, которые происходят именно в совокупности с другим вашим приложением.
2105.72 2113.20 SPEAKER_01 Потому что иногда, да, очень часто вот это место может быть bottleneck и не всегда понятно, что же там происходит внутри одного запроса.
2113.20 2135.52 SPEAKER_00 Ну вот я так понимаю, что таких супер детальных метрик можно напридумывать огромное количество, благо этих провайдеров там сотни, как я понимаю, ну ивентов как минимум точно, хотя по-моему провайдеров там за сотню точно, и я боюсь, что если мы начнем это все запихивать в профайлер какой-нибудь, то получится это.
2135.52 2140.96 SPEAKER_00 Ты Perf.U видел, да, скрин такой с миллионом галочек, эдитбоксов и прочего.
2140.96 2143.36 SPEAKER_00 То есть это будет какой-то очень сложный инженерный тул.
2143.36 2153.20 SPEAKER_00 Я не говорю, что они не нужны, и наверное, например, если мы говорим про Perf.U, если вы под виндой, то на Perf.U существует возможность сделать кастом вьюшки так называемые.
2153.20 2163.24 SPEAKER_00 То есть вы можете напрограммировать длл, которую Perf.U будет уметь загружать, скармливать ей, собственно, трейс этих ивентов этой вьюшки, а вьюшка может выводить, что хочет.
2163.24 2166.92 SPEAKER_00 То есть технически можно сделать такую вьюшку даже прям на базе Perf.U.
2166.92 2191.36 SPEAKER_00 Я никогда не пробовал такое делать, но вроде бы видел, что такое делают, вроде там есть какое-то extensibility, и соответственно это можно сделать на Perf.U, но Perf.U довольно ограниченный, в том смысле, что на Windows Only, и видимо поэтому Кристоф решил сделать это в виде такого отдельного онлайн-тула, которое причем на живую, прям на работающем приложении позволяет это делать.
2191.36 2198.60 SPEAKER_01 Ну, ты прав, если там все навалить как в Perf.U, наверное, это будет неюзабельно, в общем случае, по крайней мере.
2198.60 2214.88 SPEAKER_01 Но если сюда подключить какой-нибудь разум, который все-таки будет тебе данные места группировать, и если вдруг они будут выбиваться по статистике из нормального там какого-нибудь распределения, то есть если будет видно, что они занимают существенное время или выполняются дольше, чем обычно, вот тогда их детализировать уметь.
2214.88 2220.12 SPEAKER_01 Ну, без того, чтобы залезть в детали, он бы тебе просто показал как обычные запросы, и все.
2220.12 2234.72 SPEAKER_00 Ну, наверное, может быть, когда-нибудь это в трейсинг куда-нибудь влезет, то есть можно, допустим, будет включить опцию, у нас же сейчас уже спаны для всяких внешних вызовов отправляются нормально через OpenTelemetry, поставить галочку, и он тогда тебе будет это бить на микроспаны.
2234.72 2240.12 SPEAKER_00 Типа вот тут я сходил в DNS, тут я в Security, тут Connection, а тут, значит, вот он ушел, ушел наконец-таки наружу.
2240.12 2242.12 SPEAKER_00 Может быть так.
2242.12 2245.44 SPEAKER_01 Ну, хорошо, хорошо, пойдем к следующей теме.
2245.44 2249.76 SPEAKER_01 Хочется поговорить с вами о том, что не так с Яндекс.Клаудфанкшнами.
2249.76 2252.64 SPEAKER_01 Вот прям нормальная такая статья, прям сразу с наезда.
2252.64 2257.68 SPEAKER_01 Сразу видно, что автор опубликовал статью на Хабре, и это Андрей Порожняков.
2257.68 2272.56 SPEAKER_01 Андрей Порожняков рассказывает нам, как он попробовал Клаудфанкшены, и, в принципе, статья в основном не про Клаудфанкшены, а статья про NativeOut, поэтому если вам интересен NativeOut, а особенно как запустить его в Клаудфанкшенсах, то милости просим.
2272.56 2278.36 SPEAKER_01 Давайте немножко посмотрим на тот опыт, который возник у автора, тем более, что в некоторых местах он довольно-таки уникальный.
2278.36 2286.72 SPEAKER_01 Итак, как я уже сказал, Андрей решил в Клаудфанкшен запустить .NET и посмотреть, а что ж там такого с ними интересного происходит.
2286.72 2289.28 SPEAKER_01 Что такое функции, прежде всего?
2289.28 2298.72 SPEAKER_01 Ну, это функция как услуга, это один из компонентов без серверных вычислений, да, все мы на слуху уже давно имеем у себя Serverless какие-то вычисления, Serverless-функции.
2298.72 2305.12 SPEAKER_01 На самом деле это не тогда, когда у вас нет сервера, это тогда, когда вы просто об этом сервере не заботитесь, а о нем заботится кто-то другой.
2305.12 2314.28 SPEAKER_01 То есть ваша функция лежит на сервере и в этой функции описано на обычном C# коде то, что она должна делать.
2314.28 2316.60 SPEAKER_01 Запускается эта функция по неким событиям.
2316.60 2320.36 SPEAKER_01 Событиями могут быть все, что угодно, то есть очень много разных событий есть.
2320.36 2327.64 SPEAKER_01 Самым частым из них это HTTP-запрос, то есть если на какой-то определенный уровень приходит HTTP-запрос, то запускается ваша функция.
2327.64 2337.24 SPEAKER_01 Безусловно, она может проанализировать какие аргументы перед вашим HTTP-запросом и прочее-прочее, но не сильно отличается от ваших контроллеров, допустим.
2337.24 2341.44 SPEAKER_01 Может быть не такая навороченная, но в целом именно вид именно такой.
2341.44 2350.64 SPEAKER_01 А также событиями могут выступать какой-нибудь планировщик, который по времени запускает эту функцию или появление задачи в очереди задач, в какой-нибудь queue.
2350.64 2356.88 SPEAKER_01 Если задача появилась, то эта задача тоже может обрабатываться с помощью такой же в Cloud Function.
2356.88 2363.64 SPEAKER_01 Плюсы здесь в основном в том, что вам не нужно держать постоянно запущенным какой-то хостинг, какой-то сервер.
2363.64 2375.32 SPEAKER_01 Допустим, вы делаете какое-то маленькое приложение, которому нужно сжимать картинки, и таких картинок у вас там, допустим, раз в неделю вы бы пофотографировали, выложили там 10 картинок в ваш блог и все.
2375.32 2388.84 SPEAKER_01 Для того, чтобы сжать там, допустим, 10 картинок раз в неделю, хостить целый сервер, оставлять его включенным и ждать пока вы к нему пришлете запросы на изменение размеров, это довольно расточительно.
2388.84 2391.12 SPEAKER_01 Тогда вот на помощь приходят такие функции.
2391.12 2397.40 SPEAKER_01 Если к функциям не обращаются, они просто гаснут и вы не платите абсолютно за то время, пока они не используются.
2397.40 2399.48 SPEAKER_01 Ну, по крайней мере, у большинства операторов.
2399.48 2404.56 SPEAKER_01 А вот как только они вам понадобились, вы платите только за те 10 картинок, которые вы сжали.
2404.56 2410.72 SPEAKER_01 Во все остальное время функции, опять же, после сжатия выключаются, лежат и ничего не кушают, времени не требуют, ресурсы не потребляют.
2410.72 2412.04 SPEAKER_01 Что довольно-таки удобно.
2412.04 2421.44 SPEAKER_01 То есть, если у вас есть какие-то небольшие операции, которые случаются редко, то функции это один из хороших выборов, вам его нужно обязательно рассмотреть.
2421.44 2427.56 SPEAKER_01 Такие провайдеры, то есть, такая концепция функций естественно не Яндексом изобретена.
2427.56 2437.48 SPEAKER_01 Есть AWS Lambda, Microsoft Azure Functions, Google Cloud Functions и практически у всего облачного этого провайдера, у любого они есть.
2437.48 2440.00 SPEAKER_01 Но мы сосредоточимся именно на Яндексах.
2440.00 2443.92 SPEAKER_01 У Яндекс фанкшинов поддерживаются различные среды выполнения.
2443.92 2449.64 SPEAKER_01 Нас интересует именно .NET, .NET на данный момент поддерживается восьмой, шестой и триодин.
2449.64 2453.88 SPEAKER_01 В принципе, я думаю, из любых этих вариантов вам обязательно должен подойти.
2453.88 2457.04 SPEAKER_01 Создаются Яндекс.Функции очень просто.
2457.04 2469.16 SPEAKER_01 В удобном интерфейсе вы можете создать файл, и в этом файле вам необходимо будет написать класс, который называется Handler, и у этого класса Handler должна быть функция, которая называется FunctionHandler.
2469.16 2478.72 SPEAKER_01 И в этой уже как FunctionHandler, которая может принимать какие-нибудь аргументы, вы можете творить все, что угодно, например, вернуть строку Hello World.
2478.72 2483.80 SPEAKER_01 Дальше вы на чистом C# можете делать абсолютно любые вещи, которые вам приходят в голову.
2483.80 2488.20 SPEAKER_01 Допустим, посмотрим на то, как же ведет себя вот такой простенький Hello World.
2488.20 2493.92 SPEAKER_01 Если мы его запустим, то предсказуемо он нам ответит той строкой, которую мы в него захардкодили.
2493.92 2495.16 SPEAKER_01 Что здесь можно заметить?
2495.16 2505.84 SPEAKER_01 Если запускать его несколько раз, то время выполнения функции будет меньше при запуске несколько раз подряд одновременно, чем если бы мы запускали его в редких случаях.
2505.84 2509.60 SPEAKER_01 Это как раз демонстрирует тот концепт, который я упомянул выше.
2509.60 2519.40 SPEAKER_01 Если функция не используется, то весь инстанс, все виртуальная машина вашей функции, она гасится и не потребляет никаких ресурсов.
2519.40 2529.12 SPEAKER_01 Как только функцию вы захотели использовать первый раз, снова поднимается эта виртуальная машина, туда загружается ваше приложение, компилируется и начинает работать, то есть начинает выполняться.
2529.12 2544.48 SPEAKER_01 Если вы выполняете ваши запросы очень быстро, то виртуальная машина не гасится, поэтому ваши запросы выполняются быстрее, чем после холодного старта, то есть после вот такого первого запроса на пробуждение.
2544.48 2564.64 SPEAKER_01 Чтобы вы понимали разницу, то уже поднятый, прогретый экземпляр отвечает вам за одну миллисекунду, а вот холодный старт, первый запрос отвечает вам за 150 миллисекунд, то есть естественно в этот ответ входит не только сама работа функции, но и поднятие всей инфраструктуры, всего инвармента для вашей функции.
2564.64 2572.32 SPEAKER_01 Итак, что же входит в этот наш прогретый экземпляр, который может отвечать нам за одну секунду, за одну миллисекунду, извините.
2572.32 2593.08 SPEAKER_01 Естественно за одну миллисекунду ничего там такого быстрого сделать невозможно, то есть невозможно запустить ваше приложение и прогнать JIT и обработать хендлер, поэтому естественно JIT по идее должен был уже отработан, то есть ваше приложение должно уже висеть в памяти, и просто ваш хендлер вызывается несколько раз, при каждом запросе вызывается ваш хендлер.
2593.08 2609.48 SPEAKER_01 Но тут интересно задаться вопросом, а если ваше приложение уже поднято, то это значит, что по сути все данные, которые висят в этом приложении, допустим, которые в статическом контексте у этого приложения хранятся, то все данные они сохраняются.
2609.48 2629.84 SPEAKER_01 То есть любой другой запрос может иметь доступ к данным предыдущего запроса, что немножко противоречит самой концепции функций, потому что функции это по идее такие атомарные единицы работы, которые никаким образом не могут иметь некого непредсказуемого состояния.
2629.84 2641.92 SPEAKER_01 То есть состояние, которое вы явно не сохранили или явно где-нибудь не загрузили, и поэтому они не должны пересекаться, то есть их данные не должны пересекаться с другими параллельными запросами, которые идут к этим же функциям.
2641.92 2643.36 SPEAKER_01 Проведем следующий эксперимент.
2643.36 2652.64 SPEAKER_01 Если мы создадим статическое поле, каунтер, допустим, и начнем в хендлере этот каунтер увеличивать и сделаем несколько запросов подряд.
2652.64 2657.88 SPEAKER_01 Если бы функция была чистая и красивая, то этот каунтер всегда был бы 0.
2657.88 2664.72 SPEAKER_01 Но в нашем случае, когда мы начинаем делать несколько запросов подряд, мы видим, что каунтер увеличивается.
2664.72 2678.40 SPEAKER_01 Каунтер увеличивается, а это значит, что у нас действительно работает одно и то же приложение между разными запросами, и естественно, у этого приложения одни и те же статические свойства, которыми может доступиться абсолютно любой запрос, который придет в этот хендлер.
2678.40 2690.24 SPEAKER_01 Автор сначала подумал, что на самом деле класс хендлер создается каждый раз при входящем запросе, ну как у нас делают контроллеры обычно при входящем запросе, а просто статические свойства, естественно, в приложении никуда не выгружаются.
2690.24 2701.12 SPEAKER_01 Поэтому он убрал статик-модификатор из этого каунтера и вызвал еще несколько запросов, и несколько запросов продолжили увеличить счетчик.
2701.12 2702.36 SPEAKER_01 Что это значит?
2702.36 2710.32 SPEAKER_01 Это значит, что не просто класс хендлер не создается повторно, а класс хендлер используется один и тот же.
2710.32 2717.60 SPEAKER_01 То есть вы можете шарить даже в приватных свойствах класса хендлер, шарить какое-то состояние между запросами.
2717.60 2721.32 SPEAKER_01 То есть класс хендлер будет один и метод будет вызываться много-много раз.
2721.32 2726.64 SPEAKER_01 Это, в принципе, можно рассчитывать как и плюс, и как и минус.
2726.64 2745.88 SPEAKER_01 То есть из плюсов то, что вы в памяти держите какое-то состояние, а минус это в том, что вы на это состояние рассчитывать не можете, потому что как только функция выгрузится из памяти, а сделать она это может абсолютно любую секунду, то вы все это состояние потеряете, и если вы на это вдруг рассчитывали почему-то, то ваши ожидания обломятся.
2745.88 2749.40 SPEAKER_01 Поэтому в идеальной картине мира, естественно, это рассчитывать никогда нельзя.
2749.40 2752.92 SPEAKER_01 Но так как разработчики не идеальны, то просто так запретить нельзя.
2752.92 2756.52 SPEAKER_01 Поэтому хотелось бы, чтобы здесь была какая-то гарантия.
2756.52 2767.36 SPEAKER_01 Иначе на плечи разработчиков ложится такое время, как очищение ресурсов, и оно усугубится, если начнут использоваться ресурсы, например, Unmanaged.
2767.36 2776.96 SPEAKER_01 То есть подключение к базам данных, какие-то сетевые соединения, какое-нибудь сочтение, запись файла, какие-нибудь работы с хендлерами напрямую, в общем, все это очень сложно.
2776.96 2787.88 SPEAKER_01 И намного легче было бы, если бы все-таки вот этого расшаренного стейта не было, если бы весь стейт чистился, как положено в чистых функциях, и весь стейт заново загружался, как положено в чистых функциях.
2787.88 2790.60 SPEAKER_01 Что же мы можем придумать?
2790.60 2802.92 SPEAKER_01 К сожалению, в том конспекте, про который мы говорим сейчас, то есть в environment.net, в environment.cloud.function мы ничего придумать не можем, потому что они именно так работают.
2802.92 2805.40 SPEAKER_01 Они загружают .NET-приложение и просто держат его в памяти.
2805.40 2815.00 SPEAKER_01 Имея такой концепт, у нас руки связаны, мы никак очищать весь стейт не можем, как бы чистить все статические поля, которые существуют в приложении, это просто что-то невероятное.
2815.00 2825.92 SPEAKER_01 Ну и к тому же, там у нас не только статик, там уже у нас есть и какой-нибудь синхронизейшн контекст и какие-то неявные еще переменные, в общем, все не почистишь, так оно не работает.
2825.92 2831.52 SPEAKER_01 Единственный вариант - это гасить приложение полностью и запускать его заново, как только приходит новый год запроса.
2831.52 2834.24 SPEAKER_01 То есть запускать приложение на каждый запрос.
2834.24 2840.32 SPEAKER_01 Звучит якобы безумно, потому что это кажется, что все будет очень долго, но посмотрим, посмотрим.
2840.32 2841.32 SPEAKER_01 Попробуем.
2841.32 2842.56 SPEAKER_01 Запускать приложение на каждый запрос.
2842.56 2846.12 SPEAKER_01 Через .NET Environment яндекс функции мы такое сделать не можем.
2846.12 2850.52 SPEAKER_01 Значит, нам нужен свой Environment чистый и красивый.
2850.52 2857.08 SPEAKER_01 Мы нашли такой Environment с помощью Environment, который называется Bash, то есть запускается который-либо из скриптик.
2857.08 2858.08 SPEAKER_01 Что мы сделали?
2858.08 2861.60 SPEAKER_01 Мы скомпилировали .NET приложение, которое будет у нас вызываться каждый раз.
2861.60 2864.56 SPEAKER_01 Ну и естественно, в будущем мы хотим сделать так, чтобы оно вызывалось быстро.
2864.56 2868.24 SPEAKER_01 Как же нам это сделать быстро?
2868.24 2880.04 SPEAKER_01 Ну, во-первых, нам нужно все это положить в self-content, запустить стриминг и таким образом мы сможем подойти к тому, что сможем использовать native-out публикацию.
2880.04 2890.64 SPEAKER_01 Благодаря native-out публикации у нас весь код компилируется прямо в момент билда вашего приложения, а не в момент запуска, как это происходит обычно при JIT-компиляции.
2890.64 2896.24 SPEAKER_01 Таким образом, в момент именно билда весь ваш код будет преобразован в машинные команды.
2896.24 2906.48 SPEAKER_01 И когда приложение будет запускаться, то на старте не будет тратиться никакое время в JIT.
2906.48 2908.68 SPEAKER_01 Ну, сказано, сделано.
2908.68 2912.36 SPEAKER_01 Взяли баш-среду, написали скриптик, который вызывает наше приложение.
2912.36 2917.92 SPEAKER_01 Наше приложение мы скомпилировали заранее на локальной среде, зная целевую схему.
2917.92 2918.92 SPEAKER_01 Это можно сделать.
2918.92 2925.56 SPEAKER_01 Сохранили в Яндекс.ОбжектСтор и функция наша скачивает из Яндекс.ОбжектСтора приложение и запускает.
2925.56 2929.24 SPEAKER_01 Запускает дотнетное приложение как свое собственное.
2929.24 2945.44 SPEAKER_01 Так как мы использовали базовый образ баш, в нем уже не установлен дотнет-рантайм, именно поэтому нам сюда же подходит и селф-контейнт, потому что селф-контейнт таскает вместе с собой дотнет-окружение вместе с тем экзешником, в который он скомпилирован.
2945.44 2949.32 SPEAKER_01 Ну, и некий вагон, естественно, тоже как наследник от селф-контейнта.
2949.32 2956.68 SPEAKER_01 Поэтому у нас все дотнет-окружение таскается с собой, весь дотнет-код переведен в машинный код, и мы рассчитываем, что это будет работать быстро.
2956.68 2958.64 SPEAKER_01 Давай же посмотрим, как же оно будет работать.
2958.64 2977.36 SPEAKER_01 Вместе с NativeAuto Андрей также притащил обычное селф-контейнт приложение, то есть, у которого есть внутри себя весь полный дотнет-рантайм, у которого отработал тримминг, но не была доделана вот эта фаза компиляции или в нативный код.
2977.36 2978.36 SPEAKER_01 Вот.
2978.36 2979.36 SPEAKER_01 У нас есть три кандидата.
2979.36 2987.84 SPEAKER_01 При холодном старте Яндекс.Функция загружается примерно за 216 миллисекунд и выполняется.
2987.84 3001.28 SPEAKER_01 Селф-контейнт приложение выполняется за 100 миллисекунд, то есть, быстрее, чем Яндекс.Функция, а NativeAuto за 28 миллисекунд, то есть, в 10 раз быстрее холодный старт у приложения на NativeAuto.
3001.28 3010.52 SPEAKER_01 Это как раз-таки показатель того же, что в Яндекс.Дотнет-окружении у нас происходит JIT-компиляция нашего приложения, а в NativeAuto нет.
3010.52 3012.00 SPEAKER_01 Вот как раз выигрыш в 10 раз.
3012.00 3013.00 SPEAKER_01 Неплохо.
3013.00 3017.76 SPEAKER_01 Далее мы пробуем провести тот же самый эксперимент на горячем экземпляре.
3017.76 3022.58 SPEAKER_01 Здесь уже Яндекс.Функция выполняется за 1,2 миллисекунды, то есть, в оптимальное время.
3022.58 3032.60 SPEAKER_01 Селф-контейнт приложения 51 миллисекунда, то есть, здесь уже возможно JIT конкретно вот этого хендлера, который мы выполняем, играет свою роль.
3032.60 3037.04 SPEAKER_01 И NativeAuto 3 миллисекунды, где-то в 2 раза дольше, чем Яндекс.Окружение.
3037.04 3039.08 SPEAKER_01 В принципе, не критично.
3039.08 3042.04 SPEAKER_01 Что отдельно может порадовать, так это используемая память.
3042.04 3045.92 SPEAKER_01 Вот здесь используется 43 мегабайта против яндексовских 87.
3045.92 3050.74 SPEAKER_01 То есть, по памяти NativeAuto ест в 2 раза меньше, что тоже прекрасно.
3050.74 3056.04 SPEAKER_01 Этого автору показалось мало, и он начал унижать Яндекс дальше.
3056.04 3058.60 SPEAKER_01 Каким образом можно унизить Яндекс больше всего?
3058.60 3061.08 SPEAKER_01 Конечно же, заставить его гуглить.
3061.08 3073.64 SPEAKER_01 Поэтому мы взяли наш Hello World приложение, которое в принципе не показывает практически ничего, кроме времени ответа и времени прогрева, и написали более или менее интерпрайс приложения, которое перекладывает JSON.
3073.64 3087.92 SPEAKER_01 Наш Яндекс.Гугл приложение принимает на вход строку, идет в Google Search API, из Search API достает первые 10 результатов и возвращает пользователю заголовки с ссылками.
3087.92 3097.00 SPEAKER_01 То есть, здесь у нас участвует сериализация, децерализация, HTTP подходы, HTTP походы, парсинг входящих параметров, исходящих параметров.
3097.00 3104.28 SPEAKER_01 То есть, идет какая-то нормальная работа, а не сказать, что там какой-нибудь CPU Intensity в большой, но вполне интерпрайс, почему бы и нет.
3104.28 3108.20 SPEAKER_01 И на вот этом интерпрайсе попробуем перемерить наши показатели.
3108.20 3115.96 SPEAKER_01 Естественно, социальный контент нам больше неинтересен, он показывает что-то промежуточное, не то, не сё, а вот Яндекс с NetAuth вполне могут подраться.
3115.96 3120.00 SPEAKER_01 Итак, холодный старт вот этого большого жирного нашего интерпрайса приложения.
3120.00 3130.72 SPEAKER_01 У Яндекса занял больше секунды, NetAuth показал 583 миллисекунды, ну то есть в два раза быстрее, уже не в 10, а в 2, ну допустим.
3130.72 3151.68 SPEAKER_01 И прогретый экземпляр у Яндекса, вызов метода из прогретого экземпляра у Яндекса занял 354 миллисекунды и у NetAuth 486 миллисекунд, ну то есть совсем не сильно он отстал, так буквально процентиков на 30 отстал NetAuth, при этом со стартом в два раза больше.
3151.68 3174.04 SPEAKER_01 Итак, что же мы получаем, если вот кратко смотреть на эти результаты, то Яндекс, среда выполнения Яндекс функций дает лучшее время выполнения для уже разогретых для подготовленных экземпляров, но почему-то все еще больше, чем у NetAuth, но при этом достаточно долго отрабатывает холодные старты.
3174.04 3184.32 SPEAKER_01 У NetAuth лучшее время при холодном старте, прямо значительно лучшее, но почему-то несколько проигрывает в горячем экземпляре, то есть в прогретом, в подготовленном экземпляре.
3184.32 3188.36 SPEAKER_01 И вот здесь, наверное, довольно интересный вопрос, почему проигрывает-то?
3188.36 3202.92 SPEAKER_01 На самом деле, понятно, что JIT на старте не выполняется и понятно, почему оно выигрывает, но если у вас два приложения поднятых, то есть .NET на одно приложение поднято и NetAuth на приложение поднято, то дальше дело техники просто вызвать функцию и все.
3202.92 3212.04 SPEAKER_01 И для того, чтобы устранить некие вопросы, которые у нас возникли во время прочтения данной статьи, мы в эфир позвали ее автора, прямо вот непосредственно Андрея Порожнякова.
3212.04 3213.04 SPEAKER_01 Привет, Андрей!
3213.04 3217.48 SPEAKER_01 Да, всем привет, спасибо, что позвали, я готов дать разъяснения.
3217.48 3228.28 SPEAKER_01 Смотри, хорошая статья, но вот первое, что сразу бросается в глаза, это почему NetAuth все-таки медленнее стандартного .NET окружения на прогретом экземпляре?
3228.28 3236.16 SPEAKER_01 Казалось бы, они должны быть или одинаковыми, ну или NetAuth, раз он настолько оптимизированный, красивый и такое, должен быть даже быстрее.
3236.16 3238.12 SPEAKER_01 Откуда вот эта медленность?
3238.12 3242.84 SPEAKER_01 Да, хороший вопрос, на самом деле, начну немножко издалека.
3242.84 3257.28 SPEAKER_01 Смотри, в случае, когда мы используем в Яндекс.Функциях холодный старт, то приложение у нас каждый раз запускается заново, если мы работаем с JIT, вот, и происходит JIT-компиляция.
3257.28 3261.20 SPEAKER_01 Вот за счет этого холодный старт, он достаточно долго отрабатывает.
3261.84 3278.84 SPEAKER_01 Для подготовленного экземпляра, как я уже описал в статье, мы видим, что существует уже поднятый хост с приложением, которое скомпилировано, вот, и, собственно, это доказывается тем, что как раз там вылезает вот этот сайд-эффект, данные от одного запроса могут быть доступны другому запросу.
3278.84 3289.04 SPEAKER_01 Вот, это нам говорит о том, что хост с .NET-приложением, он поднят, вот, и мы, собственно, функции каждый раз вызывая, уже стреляем в этот поднятый хост.
3289.04 3306.60 SPEAKER_01 Вот, и вот для JIT-а из-за этого холодный старт сильно отличается по времени работы от подготовленного экземпляра, потому что, в первом случае, у нас поднят хост, запущено приложение, там, весь EL-код уже переведен в машинные команды, все, бери да отрабатывай.
3306.60 3310.60 SPEAKER_01 А в случае с холодным стартом все это нужно делать каждый раз.
3310.60 3319.60 SPEAKER_01 Вот, ну, и, собственно, когда мы говорим про AVT, у нас уже холодный старт от подготовленного экземпляра отличается фактически не сильно.
3319.60 3326.12 SPEAKER_01 Мы в первом и в втором случае полностью запускаем собранные AVT-приложения, там, из бар-скрипта.
3326.12 3338.56 SPEAKER_01 В случае с подготовленным экземпляром у нас разве что само окружение уже поднято, то есть, да, там, Linux какое-то, какой-то Linux-окружение, на котором приложение выполняется, оно поднято.
3338.56 3341.56 SPEAKER_01 Но, кстати, Яндекс.Функция его довольно быстро и так поднимает.
3341.56 3343.56 SPEAKER_01 Вот, поэтому разница небольшая.
3343.56 3351.64 SPEAKER_01 И вот почему у нас получается, отвечая, да, на вопрос, почему AVT медленнее в подготовленном экземпляре, чем JIT.
3351.64 3359.80 SPEAKER_01 У меня есть три, ну, как, не только предположения, три фактора, которые совершенно точно на это влияют.
3359.80 3372.32 SPEAKER_01 Во-первых, когда мы работаем с JIT-компиляцией, с встроенной .NET-средой, когда мы стреляем в подготовленный экземпляр, он, приложение на нем уже запущено.
3372.32 3377.44 SPEAKER_01 В случае с AVT, приложение нужно запустить, это все равно какой-то ресурс занимает.
3377.44 3384.88 SPEAKER_01 Нужно выделить память, ну, из вашего скрипта запускается приложение каждый раз заново, на это какие-то ресурсы тратятся.
3384.88 3385.88 SPEAKER_01 Вот.
3385.88 3409.16 SPEAKER_01 И вот это, я думаю, влияет, причем достаточно сильно, потому что, да, AVT у нас обгоняет JIT при старте, за счет того, что отсутствует необходимость компиляции, но в случае с подготовленным экземпляром у нас мало того, что там JIT уже скомпилирован, так он еще и запущен, а здесь нам нужно приложение запускать, поэтому вот какой-то ресурс на это тратится, я думаю, существенно.
3409.16 3428.16 SPEAKER_01 Во-вторых, что еще влияет, почему встроенный JIT, .NET-шески, в Яндекс.Функциях быстрее, это то, что в принципе вообще у нас AVT так работает, что он генерирует универсальный набор инструкций для какой-то указанной среды, которую мы вот указали, в Runtime Identifier.
3428.16 3432.64 SPEAKER_01 Мы там можем указать Linux x64, там Windows x64 и так далее.
3432.64 3433.64 SPEAKER_01 Вот.
3433.64 3444.68 SPEAKER_01 Такой подход, он не учитывает много особенностей какого-то конкретного окружения, то есть генерируется максимально универсальный набор инструкций для Linux x64, например.
3444.68 3461.92 SPEAKER_01 А .NET, современный JIT, встроенный в .NET, он более умный, он смотрит, где он запущен, да, он там понимает гораздо больше особенностей среды, это не просто там Linux x64, а еще какие-то особенности архитектуры и так далее.
3461.92 3466.00 SPEAKER_01 И он более оптимальный набор инструкций будет генерировать под эту среду.
3466.00 3467.00 SPEAKER_01 Вот.
3467.00 3485.68 SPEAKER_01 Но здесь стоит отметить, что .NET можно настраивать в ряде случаев, я вот этим не занимался, то есть можно там указать в csproj файле там набор атрибутов, если мы точно знаем, ну, некоторые особенности той среды, на которой он будет выполняться, то может быть вот здесь можно чуть-чуть соптимизировать.
3485.68 3495.32 SPEAKER_01 Я этим не занимался, но может быть небольшое ускорение здесь можно получить за счет того, что мы сразу укажем там какие-то наборы инструкций.
3495.32 3500.40 SPEAKER_01 Ты имеешь в виду инструкции именно процессора, который используется?
3500.40 3501.40 SPEAKER_01 Да-да-да.
3501.40 3508.60 SPEAKER_01 То есть мы должны понимать, ну, для этого нужно, конечно, знать архитектуру того, где Яндекс.функции запускает твое приложение.
3508.60 3510.00 SPEAKER_01 Я вот так глубоко не копал.
3510.00 3519.92 SPEAKER_01 Ну, так как у них там все равно виртуальные машины запускаются, то есть эта архитектура, скорее всего, у них не сильно меняется между запуском функций, то есть там какая-то виртуальная машина, которая подразумевает конкретный процессор, который она эмулирует.
3519.92 3523.24 SPEAKER_01 Ну и, наверное, эта информация более-менее стабильная, то есть на нее можно рассчитывать.
3523.24 3531.52 SPEAKER_01 Ну, я надеюсь, что да, скорее всего, да, то есть в эту сторону можно покопать и можно, может быть, чуть-чуть ускорить за счет этого.
3531.52 3543.00 SPEAKER_01 Но, тем не менее, я этим не занимался, я там указал условно максимально универсальное средоуполнение, Linux x64, и довольствовался тем, что мне AUT легенерирует.
3543.00 3567.80 SPEAKER_01 Ну и третий, третий фактор, который влияет, это, опять же таки, G в современном .NET-е, он имеет ряд оптимизаций в рантайме непосредственно, то есть когда приложение запущено, оно работает и, ну, условно говоря, в рантайме может перекомпилироваться, могут перекомпилироваться определенные участки кода по-другому, более оптимально в процессе работы.
3567.80 3579.20 SPEAKER_01 AUT, конечно, ничего такого не умеет, то есть вот как он сгенерировал машинные команды на этапе компиляции, так они будут выполняться, ничего там перекомпилироваться уже не будет, там никакой перекомпиляции нет.
3579.20 3592.84 SPEAKER_01 Вот, поэтому я думаю, что за счет этого еще тоже может определенный прирост производительности, ну, получаться, если GIT компилирует код, и приложение работает достаточно долго, то есть подготовленный экземпляр висит какое-то время.
3592.84 3619.96 SPEAKER_01 Угу, и смотри, мне кажется, что самым существенным — это первый пункт должен быть, да, то есть накладные расходы как раз на вызов, на загрузку самого приложения, на загрузку его с памяти, на выделение памяти, на загрузку с диска, на выделение памяти и так далее, а ты не знаешь, не смотрел ли, может быть, у других провайдеров, клауд-провайдеров есть какие-то, не знаю, хосты для нативных приложений, которые вот его уже загрузили, осталось там по какому-нибудь C-коду дернуть, правильный метод и все.
3619.96 3623.48 SPEAKER_01 Вот что-нибудь такое не видел, не встречал, есть ли решение этой проблемы принципиальной?
3623.48 3636.68 SPEAKER_01 Во-первых, я не считаю это проблемой, то есть если мы посмотрим на метрики в статье, то да, NativeUIT проигрывает по времени подготовленному экземпляру со встроенным дотнетом, но на мой взгляд проигрывает не сильно.
3636.68 3637.68 SPEAKER_01 Вот.
3637.68 3644.36 SPEAKER_01 И скорее всего, если поднять, ну то есть мы говорим о том, что приложение будет запущено и оно будет висеть какое-то время.
3644.36 3651.76 SPEAKER_01 Здесь у нас есть опасность попасть, ну получить тот же тайт-эффект, от которого я в статье и пытался избавляться.
3651.76 3655.20 SPEAKER_01 Если приложение уже запущено, оно может сохранять какие-то данные.
3655.20 3662.76 SPEAKER_01 И если данные можно сохранить внутри приложения в каких-то переменных, значит их можно шарить между запросами.
3662.76 3671.80 SPEAKER_01 А это уже нарушает один из основных принципов FaaS архитектуры, то, что вызовы должны быть изолированы вокруг.
3671.80 3672.80 SPEAKER_01 Вот.
3672.80 3673.80 SPEAKER_01 Ну да, да.
3673.80 3688.88 SPEAKER_01 Ну, да, я отвечаю на твой вопрос, я не смотрел, где можно прямо вот, чтобы у какого-то облачного провайдера было кто-то именно заточенное под native-UT приложение .NET, я вообще не думаю, что такое можно найти.
3688.88 3689.88 SPEAKER_01 Вот.
3689.88 3698.32 SPEAKER_01 Тут в Яндекс.Функциях, я не нашел в интернете абсолютно никаких следов, что кто-то когда-то в Яндекс.Функциях пытался хотя бы запускать native-UT приложение.
3698.32 3704.92 SPEAKER_01 Возможно, я сделал первый, может быть, даже до сих пор единственный, ну, видимо, людям это пока не очень нужно.
3704.92 3706.60 SPEAKER_01 Может быть, кому-то это решение поможет.
3706.60 3711.52 SPEAKER_01 Да, в любом случае, опыт прекрасный, поэтому хорошо, что ты его зафиксировал в виде отдельной статьи.
3711.52 3718.60 SPEAKER_01 Ну, я с тобой согласен, что если все-таки копать в переиспользование одного хаста, который будет запускать, это полностью уходит от цели статьи.
3718.60 3719.60 SPEAKER_01 Отлично.
3719.60 3737.04 SPEAKER_01 Так, давай напоследок, смотри, мы еще сошлемся на твой доклад, но ты в статье описал, что, в принципе, если вам этот подход понравился, то перед вами стоит ограничение, да, ограничение самого IoT, то есть вы не все, не весь ваш код сможете превратить, запаковать вот таким вот образом.
3737.04 3753.44 SPEAKER_01 Можешь назвать кратко вот три, не знаю, самых существенных ограничения, которые чаще всего встречаются в приложении, которые, с помощью которых, из-за которых невозможно будет таким образом упаковать ваше приложение и опубликовать в виде Яндекс-функции?
3753.44 3771.36 SPEAKER_01 Да, смогу назвать, на самом деле, у Native IoT собственных ограничений как таковых нет, но есть ограничения связанные с стримингом, то есть стриминг используется, есть ограничения связанные с публикацией, ну, с сингл-файл публикейшн.
3771.36 3772.36 SPEAKER_01 Вот.
3772.36 3779.80 SPEAKER_01 И все они перетекли к нам в наследование, если мы хотим собирать Native IoT приложение, то придется эти ограничения учитывать.
3779.80 3806.00 SPEAKER_01 Вот, могу дать такой универсальный совет, скорее всего, если кто-то будет писать приложение сразу под Native IoT, то придется учитывать, что JSON-сериализация, вот, часть всего, я вижу на проекте, который я пытался переводить уже готовый на Native IoT, или если пишут с нуля, то первое, что стоит учитывать, что нужно использовать source-генераторы для JSON-сериалайзеров.
3806.00 3807.00 SPEAKER_01 Вот.
3807.00 3816.76 SPEAKER_01 Это вот такое, ну, не то чтобы ограничение, а особенность разработки, да, то есть если это не учесть, если оставить JSON-сериализацию в рантайме, то оно в Native IoT не заработает.
3816.76 3817.76 SPEAKER_01 Вот.
3817.76 3822.72 SPEAKER_01 И если нужно там определенный атрибут добавлять, у меня в докладе это есть, как этим пользоваться.
3822.72 3823.72 SPEAKER_01 Вот.
3823.72 3830.44 SPEAKER_01 Поэтому это вот, ну, не только прям ограничение, но это, наверное, да, в каком-то смысле это какие-то дополнительные source-генераторы.
3830.44 3835.50 SPEAKER_01 То есть всю JSON-сериализацию нужно учесть и описать в виде source-генерации.
3835.50 3846.72 SPEAKER_01 А так, ну, не все поддерживается, да, то есть не получится развернуть какое-нибудь полноценное там Blazor или Razor Pages приложение, пока что не получится.
3846.72 3850.92 SPEAKER_01 То есть есть, опять же, такие… Ну, если мы говорим о функциях, наверное, это не так страшно.
3850.92 3872.56 SPEAKER_01 Да, в функциях, я вот даже так не могу навскидку сказать, чего может не хватить, если используем какие-то дополнительные решения, ну, то есть какие-то даже известные, там, видите, ну, GetPackets, условно, какой-нибудь медиатор, я не знаю, хочет ли кто-то в функциях использовать медиатор, мне кажется, функция это что-то такое быстрое, что отработало, один раз умерло, там, до следующего вызова.
3872.56 3873.56 SPEAKER_01 Вот.
3873.56 3876.32 SPEAKER_01 Ну, вот медиатор прям, он условно поддерживается в Native IoT.
3876.32 3877.32 SPEAKER_01 Там коктейлить придется.
3877.32 3878.32 SPEAKER_01 Ну, и да.
3878.32 3881.92 SPEAKER_01 Ну, хорошо, смотри, сервизатор, который ты назвал, это уже прекрасно.
3881.92 3884.00 SPEAKER_01 Ну, об остальном, я думаю, мы посмотрим в докладе.
3884.00 3885.00 SPEAKER_01 Хорошо.
3885.00 3888.16 SPEAKER_01 Спасибо, что помог разобраться.
3888.16 3892.92 SPEAKER_01 Так, я напомню, что с нами был Андрей Порожняков, автор статьи, которую мы обсуждаем.
3892.92 3893.92 SPEAKER_01 Спасибо большое.
3893.92 3894.92 SPEAKER_01 До новых встреч, Андрей.
3894.92 3896.44 SPEAKER_01 Да, спасибо, что позвали.
3896.44 3897.44 SPEAKER_01 Всем пока.
3897.44 3898.44 SPEAKER_01 Пока.
3898.44 3902.08 SPEAKER_01 Так, отлично, отлично, что Андрей нам все прояснил.
3902.08 3903.24 SPEAKER_01 Давайте подведем итоги.
3903.24 3904.76 SPEAKER_01 Итак, что же получается?
3904.76 3924.00 SPEAKER_01 Что если вы готовы принять на себе риски, когда ваше состояние в ваших функциях может смешиваться, вы понимаете, что вы или все контролируете, или для вас это не страшно, а также если для вас время холодного старта не особо критично, то, наверное, можно выбрать чистые Яндекс-функции с дотнет-окружением.
3924.00 3936.26 SPEAKER_01 Если же вы хотите все-таки, чтобы никакого состояния не смешивалось и ваши функции были наичистейшие, то вы можете использовать NativeOut в виде запускаемого файла.
3936.26 3945.64 SPEAKER_01 Здесь еще нужно иметь в виду, что действительно у NativeOut есть ограничения, то есть не любое приложение вы прям можете взять и прекомпилировать в NativeOut.
3945.64 3949.72 SPEAKER_01 Его необходимо или немножко подготовить, или может быть даже это совсем невозможно.
3949.72 3963.00 SPEAKER_01 Какие именно ограничения связаны с NativeOut, как его готовить и какие тонкости на этом пути вас могут встретить, вы можете посмотреть в прекрасном докладе Андрея Порожнякова «NativeOut. Возможности и ограничения», который мы упоминали выше.
3963.00 3976.04 SPEAKER_01 Если же вам интересно, как работают Яндекс-клаундфункшены под капотом, то есть шикарный доклад, который Максим Шошин делал на spb.net, который называется «Серверлесс под капотом клаундфункшенов».
3976.04 3996.44 SPEAKER_01 Макс работает в Яндексе и непосредственно участвовал в разработке клаундфункшенов, поэтому он красиво на картинках показывает, как же это все там работает, вся эта магия с виртуальными машинами, с засыпанием, с прогревом, с амортизацией, в общем, очень интересно, поэтому вот эти два доклада обязательно гляньте, если тема клаундфункшенов и аота вам интересна.
3996.44 4008.40 SPEAKER_00 Ну прям монументально, статья оказалась всего-то что не так, краткий ответ сначала думал, что все не так, но оказалось все гораздо сложнее и интереснее, действительно.
4008.40 4021.48 SPEAKER_00 Ну непонятно, насколько как бы хочется прям вкладываться в NativeOut для того, чтобы получить выигрыш, особенно если прогретые функции работают быстрее, ну да, надо смотреть.
4021.48 4025.76 SPEAKER_00 Потому что NativeOut все-таки требует некоторого приседания для того, чтобы все под ним заработало.
4025.76 4033.12 SPEAKER_01 С другой стороны, видишь, не талия, это прекрасная техническая задачка, на которую можно потратить выходные, а потом хвастаться перед пацанами.
4033.12 4041.68 SPEAKER_01 Ну или на первую неделю в NativeOut, ну или месяц, а потом еще баги отлавливать пару месяцев, да, это все тонкости.
4041.68 4096.12 SPEAKER_00 Да, ладно, давай пойдем дальше, дальше у нас, наверное, будет не очень профильная для нас статья, ну даже не статья, а это вышедший Technology Radar, он на самом деле вышел довольно давно, мне кажется, выходит он 2 раза в год, если я ничего не путаю, и я его проглядел, казалось бы, ну что там интересного может быть, все же будут говорить про LLM, и я в общем не ошибся, если мы посмотрим в раздел техники, напоминаю, что Technology Radar это такая штука, которая выпускается компанией ThoughtWorks, и там рассказано, грубо говоря, там все технологии, нетехнологии, в общем там 4 раздела под названием Technics, Platforms, Tools и Languages and Frameworks, и в каждом из разделов различные технологии, софт, подходы, языки и прочее разделены на 4 части.
4096.12 4109.56 SPEAKER_00 Adopt, это значит можно использовать, все нормально, Tryout — пробуйте, но присматривайтесь, и Hold — лучше пока прекратить использовать, если вы используете.
4109.56 4143.08 SPEAKER_00 И в разделе Technics, то есть всякие разные техники, не знаю, подходы, сложно на русском перевести каким-то одним словом сейчас сходу, там действительно прям засилье LLM-ок во всех разделах, то есть в трайле 6 из 8 пунктов про LLM, в ASS 5 из 7 пунктов про LLM, и даже в Hold пробрался LLM, где сказано, не надо заменять парное программирование парным программированием с AI, это пока не то.
4143.08 4153.12 SPEAKER_00 Это был неожиданный вывод, то есть пока ты читаешь, ты такой, и тут LLM, и тут LLM, и тут Tools для LLM, и тут надо LLM, и тут LLM, и тут в Hold, а вот для парного программирования не надо.
4153.12 4160.00 SPEAKER_01 То есть как раз та ситуация, когда ты технологию еще даже не начал использовать, а другие уже закончили
4160.00 4161.00 SPEAKER_00 использовать.
4161.00 4164.08 SPEAKER_00 Типа того, то есть как бы живой человек пока лучше.
4164.08 4183.88 SPEAKER_00 В Platforms я ничего интересного не нашел, там какие-то такие очень супер специфичные интерфразные какие-то платформы либо опять же все, что относящиеся к AI, а вот секция Tools она в принципе интересна, я планирую в нее заглянуть, посмотреть, ну в смысле я в нее уже заглянул, и даже какие-то кусочки из нее использую или пробовал.
4183.88 4201.00 SPEAKER_00 Значит в секции Adopt, то есть в секции давайте уже пора применять можно, мы разрешаем, или мы советуем, находится такой тул под названием Bruna, мы его уже упоминали по-моему в кратко разном в каком-то из выпусков с полгодика назад, когда он вышел, это замена Postman.
4201.00 4215.48 SPEAKER_00 Если вы пользуетесь Postman, Postman сейчас стал супертяжелый Postman, по-моему больше не разрешает никакого Local Only разработки, там нужно обязательно логиниться в их клауд, или что-то в таком духе, когда я давно уже не пользуюсь, но что-то такое слышалось.
4215.48 4226.32 SPEAKER_00 Это если вдруг у вас по какой-то причине нет интернета, то он там будет страдать и не запускаться, по крайней мере была такая версия у меня, которая без интернета не запускалась.
4226.32 4262.52 SPEAKER_00 В общем, кому-то это тоже надоело, и товарищ написал опенсурсный клиентик Bruna, там у него есть какие-то кусочки платных функций, которые не опенсурсные, но даже в бесплатном варианте он вполне себе функционален, активно очень дорабатывается, поэтому если вы пользовались Postman, можно посмотреть на альтернативы, я сейчас в основном пользуюсь клиентом Insomnia, который, если я правильно помню, по-моему тоже Electron, плюс кусочек .NET, мне казалось там был раньше, по крайней мере, вот, но на Bruna тоже поглядываю, он у меня стоит вторым, и в принципе более-менее работает.
4262.52 4268.96 SPEAKER_00 Значит, в разделе Trial тоже есть штука, которую я либо пробовал, либо планирую попробовать.
4268.96 4290.88 SPEAKER_00 Во-первых, это тулл, не знаю, на комплект туллов под названием Devbox, они называют это Isolated Environments Without Docker, то есть если вы хотите каким-то образом изолировать всякие разные ваши инвайорменты друг от друга, ну там, не знаю, .NET 5, .NET 8 или 9, без использования докера и чего-либо.
4290.88 4315.00 SPEAKER_00 В общем-то, идея не нова, таких штук существует довольно много и разных, .NET сам по себе довольно неплохо умеет изолироваться, у нас, как известно, SDK ставится каждый в свою папочку, такие же туллы существуют для Java, для Python, в Python, мне кажется, это наиболее развито со всякими их VN и прочими штуками, а здесь тулл, который вроде как для всего.
4315.00 4321.56 SPEAKER_00 Там у них на сайте указано, по-моему, типа 15 разных языков и он, мол, для всех умеет работать.
4321.56 4324.40 SPEAKER_00 Планирую посмотреть, попробовать, может быть, действительно что-то удобное.
4324.40 4327.32 SPEAKER_01 То есть ты не знаешь, как он внутри работает, да, как он изоляции добивается?
4327.32 4328.32 SPEAKER_01 Не смотрел.
4328.32 4329.32 SPEAKER_00 Гарантирует?
4329.32 4330.32 SPEAKER_00 Да, не смотрел.
4330.32 4369.44 SPEAKER_00 Ну, гарантировать там вряд ли, я думаю, что, скорее всего, там ничего более креативного, чем сим линками правильно разделять туллы и так далее, не придумали особо, понятное дело, просто вопрос, что оно делает это все единообразно для всех, потому что вот у меня там стоит, допустим, несколько версий Python, мне нужно помнить все команды, чтобы управлять ими, отдельно у меня стоит, ох, как его зовут, sdkman для управления версиями джавы, для .NET, понятно, у меня есть .NET tool, и в каждом из них нужно помнить свой синтаксис, как выбрать текущий, как поставить нужный, как посмотреть, какие доступны.
4369.44 4372.64 SPEAKER_00 Если это все будет сделано одним туллом, в принципе, будет удобно.
4372.64 4383.28 SPEAKER_00 Я планирую посмотреть, попробовать, мне приходится переключаться между разными технологиями, и если он будет выполнять свою задачу, будет хорошо, хотя бы даже в рамках одного моего ноутбука.
4383.28 4397.60 SPEAKER_00 Я не говорю про то, чтобы делать там стандартом на всю команду и вот это все, это как бы ладно, пусть остаются PyEnv, ну, допустим, если это про Python мы говорим, но даже хотя бы локально будет, может быть, полезно.
4397.60 4431.44 SPEAKER_00 Вторая штука – это продукт под названием divtastic, это open-source продукт, MIT лицензия, div differ, который умеет вроде как структурный div с учетом синтаксиса исходников, я бы сказал, то есть он умеет понимать синтаксис исходников и, соответственно, как-то показывает диффы более оптимально, нежели чем обычные дифферы, которые просто трочки сравнивают, не зная, что такое синтаксис.
4431.44 4483.96 SPEAKER_00 Пока выглядит, что вроде как командлайновский, и я так понимаю, что его главное предназначение это как раз таки, ну, либо для тех, кто фанат командлайн, да, и живет в командлайне, либо его иногда удобно использовать, настроить в качестве git div tool, я иногда действительно пользуюсь git div в командлайне, чтобы быстренько посмотреть, что я там собираюсь коммитить, и приятно будет, если это будет не, ну, как-то действительно красиво расцвечено, он цветами всё это рисует в консольке, если терминал поддерживает вот это всё, вот именно поэтому я его хочу попробовать прикрутить именно как div tool, чисто иногда смотреть в консольке, так, я обычно использую что-то стороннее и более развесистое, гуёвое, когда мне нужно особенно какие-то three-way merges делать, вот это всё, тут понятно, что одним простым диффом не обойдёшься.
4483.96 4493.08 SPEAKER_01 Да, я смотрю сейчас по документации, что это действительно больше он div, как раз действительно git tool, командлайновый без merge.
4493.08 4495.52 SPEAKER_01 Ну, без merge, это уже другой инструмент.
4495.52 4517.88 SPEAKER_00 Ну, это другой инструмент, но быстренько проглядеть, что же вы там собираетесь закоммитить, если вы, например, пользуетесь командлайновым git, а я знаю людей, которые именно коммитят git, то есть всякие там rebases, ну, сложные короче workflow делают всё-таки в UI, а базовую работу, да, там, checkout, бранчи посвечить, коммиты сделать, пуши сделать, вот из командлайн, я тоже, наверное, как-то так делаю,
4517.88 4518.88 SPEAKER_01 будет полезно.
4518.88 4522.44 SPEAKER_01 Я как раз наоборот, в rebase, в UI боюсь, я в rebase только командлайн не делаю.
4522.44 4524.36 SPEAKER_01 Ну и всё остальное тоже командлайн.
4524.36 4527.48 SPEAKER_01 Кстати, программинг-лэнгвич, который поддерживается, C# есть.
4527.48 4528.48 SPEAKER_01 Да, да, да.
4528.48 4529.48 SPEAKER_01 Наверное, будет удобно.
4529.48 4540.64 SPEAKER_01 Меня больше удивляет, почему это привлекло внимание почему-то техрадара, ну то есть утилиток миллиард, ну то есть любой студент пишет div, tool, zoo, и она консольная, и она примитивная, ну то есть при чём здесь техрадар-то, как она туда попала?
4540.64 4541.64 SPEAKER_00 Интересный вопрос, несомненно.
4541.64 4553.08 SPEAKER_00 Ну нет, у них 21 тысяча звёздочек, то есть видимо это хороший какой-то на репозитории, в гитхабе, то есть в общем так-то…
4553.08 4560.08 SPEAKER_01 Просто функциональность элементарная, ну что такое, посмотреть div в командной строке, ну это нужно, я не знаю, раз в день это максимально просто.
4560.08 4562.60 SPEAKER_01 Ну, может быть, потому что это написано на расте?
4562.60 4570.08 SPEAKER_01 Это можно сравнить с кубернетосом, который, допустим, тоже в техрадаре существует, то есть они где-то одного уровня tool, zoo, да, кубернетос, и диффер консольный.
4570.08 4575.08 SPEAKER_00 Один на год, другой на расте, ну что там, разницы-то никакой.
4575.08 4580.64 SPEAKER_00 Дальше, следующий из разряда – это терминал.
4580.64 4582.92 SPEAKER_00 Каким терминалом ты пользуешься, Анатолий?
4582.92 4587.92 SPEAKER_00 У меня коньему и фар, не, ну для терминала коньему.
4587.92 4598.16 SPEAKER_00 Ну, ты, соответственно, под виндой, я сейчас живу на маке, на маке у меня iTerm, iTerm2, который не стандартный терминал, а чуть-чуть более развесистый терминал.
4598.16 4600.40 SPEAKER_00 А техрадар рекомендует использовать варп.
4600.40 4616.88 SPEAKER_00 Это, ну правда, тебе не подойдет, у них виндовой версии еще нет пока, но уже в техрадаре, прикинь, то есть они тоже как-то очень активно развиваются, это тоже написано на расте, может, в этом причина, может, они из-за раст все, вот.
4616.88 4623.40 SPEAKER_01 Может, может, там этот фаулер перевел на раст всю свою компанию, теперь радуются любые фанюрки.
4623.40 4624.40 SPEAKER_00 Возможно, возможно.
4624.40 4638.24 SPEAKER_00 Я не знаю, что там происходит, потому что действительно там варп, ну действительно, выглядит прикольно, там, по-моему, не было квейк-режима, и это для меня сразу минус.
4638.24 4643.28 SPEAKER_01 Так, а как им, возможно, пользоваться-то они, по-американски?
4643.28 4651.68 SPEAKER_00 Не, ну кто-то, например, я видел, и в принципе иногда я так делаю, бывает такой, что моя терминалка просто на отдельном десктопе лежит, то есть я туда переключаюсь.
4651.68 4668.40 SPEAKER_00 Ну что на винде, что на макетах делал, просто кладешь его на отдельный десктоп, и туда-сюда переключаешься, просто свайпом вправо-вправо, ну не свайпом, как-то с клавиатурой там, я не помню, виндус, не виндус, вправо, там, короче, какая-то магическая комбинация клавиш, я уже забыл, переключение
4668.40 4669.40 SPEAKER_01 между десктопами.
4669.40 4674.56 SPEAKER_01 Ну да, да, я точно так же на макетках, типа переключаюсь на виртуальный второй экран, в принципе удобно, конечно,
4674.56 4675.56 SPEAKER_00 но.
4675.56 4713.16 SPEAKER_00 Ну в общем вот, и туда же текстовый редактор z, опять же, текстовых редакторов миллион, sublime, z, какие еще есть, наверняка еще какие-то есть, вот, я имею в виду таких, которые кроссплатформенные везде, понятно, что если мы берем каждую платформу, там много кого будет, еще notepad++, да, для винды и прочее, но z тоже написан на расте, и когда я третий продукт увидел, который написан на расте, у меня закрывалось подозрение, что видимо раст как-то их немножко проплатил, ну не проплатил наверное, но как-то что-то вот оно есть такое.
4713.16 4714.88 SPEAKER_01 Мельчает как-то, радар мельчает.
4714.88 4717.72 SPEAKER_00 Да, да, да, это меня тоже удивило.
4717.72 4722.64 SPEAKER_00 Дальше, ну не то, что интереснее, languages and frameworks, чтобы понимали масштаб.
4722.64 4749.92 SPEAKER_00 Там много всего очень узкоспецифичного, типа там граф QL опять появился в разделе trial, по-моему, если я правильно помню, как ни странно, но в adopt есть testcontainers, и тут, наверное, я соглашусь, testcontainers, технология хорошая, но опять же, сравниваем, да, масштаб testcontainers и command-line-differ, ну как бы да, берете, пользуйтесь testcontainers.
4749.92 4762.96 SPEAKER_00 А вот в trial, наверное, это редкий случай, но в trial затесалась дотнетная библиотека, причем это даже не tool, и не какой-то продукт, а это гитхабовская просто библиотечка.
4762.96 4767.20 SPEAKER_00 Библиотечка называется CAP, ну C-A-P, как CAP-теорема.
4767.20 4768.64 SPEAKER_00 Может, кстати, поэтому она так называется?
4768.64 4773.84 SPEAKER_00 Мы тут с тобой перед выпуском обсуждали, почему так называется, потому что распределенный система.
4773.84 4787.96 SPEAKER_01 Безусловно, да, безусловно, навеяно именно этим, но просто, знаешь, как CAP-теорема, это такая богатая абстракция, за которой кроется тонны научных статей, и вот одна из статей может вылиться в отбокс, но как бы слишком абстрактно названо.
4787.96 4820.24 SPEAKER_00 Ну, библиотечка, да, значит, это дотнетный нугет-пакет, который имеет там 6500 звездочек, 1500 форков, почти, ну, не то чтобы прям миллионы, но довольно много, и написано, что это distributed transaction solution in microservice based on eventual consistency, also an event bus with outbox pattern, короче, это и event bus тебе, и outbox, и eventual consistency там, и короче, чертовступе.
4820.24 4844.64 SPEAKER_00 Смысл в том, что, ну, основная идея, это, конечно, то, что эта библиотека будет работать в качестве outbox, тут прям написано, что вот CAP implements the outbox pattern described in the eShop eBook, но это классическая книжка Microsoft, внутренняя по архитектуре, модельный пример, eShop, он контейнер, и вот это все.
4844.64 4857.12 SPEAKER_00 И для того, чтобы это все поиспользовать, вы просто его ставите, dotnetcore.cap пакет называется, он тут поддерживает огромное количество очередей, надо напомнить, что такое outbox.
4857.12 4866.68 SPEAKER_00 Outbox - это когда вы вместе с основной транзакцией записи в вашу базу пишете в вашу же базу сообщение, которое надо отослать, а потом какой-то worker это сообщение таки отсылает куда-нибудь там, в какую-нибудь кавку, рэббит и еще кого-нибудь.
4866.68 4877.92 SPEAKER_00 Тут поддерживается и кавка, и рэббит, и эйджер, и амазон, и нац, и редис, и пульсар, а в качестве баса - сиквел, и майсиквел, и позгрей, и монго, ну и тут много чего еще.
4877.92 4884.36 SPEAKER_00 Короче, тут довольно простой интерфейс, если вам нужен outbox и вам лениво его писать самому, то пожалуйста.
4884.36 4890.60 SPEAKER_00 Причем он судя по всему, судя по тому, что тут есть всякие атрибутики капсабскрайб и вот это все, он еще и подписываться на что-то умеет.
4890.60 4898.84 SPEAKER_00 То есть он может и по архитектурной схеме, он, короче, может стоять на двух сторонах вашего outbox'а, в смысле и на отправляющей, и на принимающей стороне.
4898.84 4901.04 SPEAKER_00 В общем, интересно.
4901.04 4908.12 SPEAKER_01 Интересно, что по языкам здесь есть Vue и JavaScript, то есть у него еще какая-то и красивая мордочка, видимо,
4908.12 4909.12 SPEAKER_00 есть.
4909.12 4941.04 SPEAKER_00 Да, там есть дэшборд в отдельном пакете, не бойтесь, вы не затащите никакой vue.js в ваш бэкэнд, то есть это отдельный пакет, кап.дэшборд, если я правильно помню, называется, который позволяет, видимо, посмотреть, как это все живет, работает, может, какую-то статистику я не смотрел, но библиотечка интересная, я про нее не слышал раньше, мы как-то outbox всегда руками писали, но надо посмотреть, может, действительно полезно, если оно отлажено, работает, звездочек много, issues'ов не так много открытых, это значит, что либо никто не пользуется, но по звездочкам вроде пользуются, либо значит, автор хорошо, молодец, быстро закрывает, фиксит все.
4941.04 4954.68 SPEAKER_00 Так что вот такое вот внезапное отвлечение, наверное, на техрадар, который в этот раз мы довольно редко, мне кажется, последний раз перед этим мы смотрели на 28-ой что ли, то есть это получается года полтора-два назад, что это был 31-ый.
4954.68 4965.00 SPEAKER_01 Да, там что-то попадалось такое про dotnet, хотя непонятно, как они, если все везде любят раст, как они эту библиотечку с outbox'ом запихнут в свое приложение.
4965.00 4992.64 SPEAKER_00 Ну, непонятно, непонятно, у меня такое ощущение, что, ну, собственно, это не ощущение, мне кажется, то, как техрадары строятся, то есть они же компания, да, они же консультанты, то есть вот они поработали полгода, ну вот за полгода у них было много раста, вероятно, и, наверное, им попался какой-нибудь dotnet-ный проект, в котором они либо увидели эту библиотеку, либо ее заюзали, потому что им нужен был outbox, посмотрели, что это хорошо и решили, что это надо рекомендовать.
4992.64 4999.48 SPEAKER_00 Ну, тоже метод, даже просто их, по сути, список, чего они рекомендуют, это не то, что там вся индустрия обязана пользоваться.
4999.48 5001.60 SPEAKER_00 Просто хорошая практика.
5001.60 5020.40 SPEAKER_01 Ну, безусловно, нужно слушателям понимать, что это какой-то опыт определенный одной компании, это никаким образом не влияет ни на индустрию, ни на другие компании, ни на популярность библиотек, ни на что, просто компания довольно авторитетная и интересная, которая впервые выдумала этот самый техрадар, и за ней таким образом по интуиции все до сих пор следят.
5020.40 5052.00 SPEAKER_00 Ну и надо сказать, что вообще сама по себе идея хорошая, то есть если вы достаточно крупная компания, в которой есть там развесистый стек, то такую штуку полезно регулярно делать внутри компании самим, чтобы смотреть, следить за актуальным стеком, обновлять, иметь некоторые рекомендации, что мы используем, что не используем, чтобы знать, на каких версиях каких продуктов вы живете, ну или фреймворков, библиотек, какие подходы вы используете, и все такое прочее, чтобы идти в ногу со временем или наоборот не слишком его опережать.
5052.00 5055.04 SPEAKER_01 Да, так и есть.
5055.04 5069.08 SPEAKER_01 Так, чтобы нам идти в ногу со временем, не поверишь, у нас вторая статья с Хаббера, то как бы не дожидались мы целый год, а тут прям две сразу, ну, наверно авторы просыпаются после лета, загорелые, вдохновленные.
5069.08 5094.04 SPEAKER_01 И вторую статью с Хаббера мы нашли, которую написал Александр Кузнецов, называется она "Тюнинг запросы в EF-корс с помощью интерсепторов", а статья не то чтобы глубокая или мега страшная, просто она очень полезная, потому что как раз-таки не все разработчики знают о том, на что способен их Entity Framework, и поэтому могут упускать много возможностей, которые уже встроены в их фреймворк.
5094.04 5122.64 SPEAKER_01 На самом деле, Entity Framework очень мощный механизм, и с каждым новым релизом в нем добавляется еще множество-множество всего, поэтому если вдруг вы захотите каким-то образом в вашем приложении очень глубоко использовать этот фреймворк, то стоит, наверное, сесть и разобраться в нем, то есть по Entity Framework прям отдельно очень много книг даже выходит, и в книгах там тоже раскрываются такие аспекты, о которых рядовой разработчик наверняка никогда бы не узнал в своей жизни, если бы не пошел специально это копать.
5122.64 5155.80 SPEAKER_00 А еще, я тебя перебью, извини, что хорошо и полезно знать внутренности, чтобы не было некоторых неправильного понимания, наверное, вот так скажу, потому что когда я видел заголовок этой статьи, я сначала продумал про интерсепторы, которые фичи языка, и долго думал, каким образом фичи языка, которые, помните, интерсепторы, когда вы можете заинтерсептировать вызов произвольной функции с помощью source-генератора, сгенерив специальный атрибут со ссылкой на номер строки, и думаю, как так интересно, запросы-то приятные, чего-нибудь будут.
5155.80 5160.08 SPEAKER_00 Сейчас мы будем там что-нибудь переписывать в source-генераторах запросы.
5160.08 5179.64 SPEAKER_00 Ну вот, чтобы вы знали, чтобы вы так не путали, нужно знать, что внутри F-Core свои интерсепторы, и терминология очень полезна, когда вы работаете, ну, короче, да, когда вы работаете с каким-то фреймворком, знать вообще, что в нем бывает, чтобы вот так вот не путаться.
5179.64 5184.00 SPEAKER_01 Да, чтобы понимать вообще, куда это вообще относится, куда коней запрягать.
5184.00 5190.92 SPEAKER_01 В принципе, интерсепторы в Entity Framework'е появились еще до файл-генераторских интерсепторов.
5190.92 5196.08 SPEAKER_01 Грубо говоря, в ASP.NET'е вот эти, те же самые middleware, их тоже можно назвать интерсепторами в своем-то виде.
5196.08 5197.08 SPEAKER_00 Почему бы и нет?
5197.08 5202.24 SPEAKER_00 Ну, по логике, да, просто что по названию я их как-то никогда не пользовал в F-Core, и поэтому я напрочь забыл.
5202.24 5206.80 SPEAKER_00 Только уже когда начинаешь читать статьи, думаешь, а, точно, ну, что-то было такое, но мне как-то никогда не надо было.
5206.80 5208.84 SPEAKER_00 Давай послушаем, зачем это, может быть, надо.
5208.84 5212.40 SPEAKER_01 Ну, и как раз объявимся, что же это такое, чтобы в следующий раз вы их не путали.
5212.40 5214.44 SPEAKER_01 Итак, начнем сначала.
5214.44 5230.40 SPEAKER_01 Entity Framework — это довольно-таки богатый фреймворк, и он обладает богатыми возможностями по преобразованию вашей объектно-ориентированной модели, ваших DTO-шек, ваших объектных доменных сущностей в язык запросов, так, когда вы запрашиваете каких-нибудь юзеров и так далее.
5230.40 5241.48 SPEAKER_01 И иногда бывает таким образом, что вам не хватает этих запросов, потому что, как ни крути, Entity Framework — это некое среднее, это пересечение между всеми базами данных.
5241.48 5248.44 SPEAKER_01 Если мы берем любую базу данных, то в общем случае она будет мощнее, чем Entity Framework, у нее будет больше возможностей, она больше всего будет уметь.
5248.44 5256.72 SPEAKER_01 Но так как Entity Framework пытается объединить под своим крылом множество датабайс-провайдеров, он выбирает всю середину, которая есть.
5256.72 5267.84 SPEAKER_01 Поэтому иногда вы хотите чего-то, что Entity Framework не поддерживает, а конкретная база данных, которая используется в вашем приложении, это поддерживает, и как-то кажется странным терять эту возможность.
5267.84 5272.36 SPEAKER_01 И чтобы решить эту проблему, есть несколько вариантов.
5272.36 5277.04 SPEAKER_01 Наверное, самый популярный — это писать SQL-запросы напрямую.
5277.04 5279.00 SPEAKER_01 Entity Framework это позволяет.
5279.00 5282.88 SPEAKER_01 Второй вариант — это использовать хранимые процедуры.
5282.88 5290.68 SPEAKER_01 Еще не ясно, что из этого хуже, но опять же, если вы спускаетесь на такой низкий уровень, то с этим имеется куча проблем.
5290.68 5310.28 SPEAKER_01 Это, наверное, тема для другой отдельной статьи, почему сырые SQL-запросы — это плохо, но как показала практика, большинство компаний используют именно ORM в нашей инфраструктуре, как раз потому, что они поняли все плюсы ORM и не хотят лезть во все минусы ручного написания запросов и тем более хранимых процедур.
5310.28 5318.80 SPEAKER_01 Поэтому у нас есть третий выход, который избавляет нас от того, чтобы писать вручную SQL-код и каким-то образом сопровождать хранимые процедуры.
5318.80 5321.08 SPEAKER_01 Третий выход — это как раз-таки интерсепторы.
5321.08 5336.84 SPEAKER_01 Интерсепторы — это некие перехватчики, которые помогают вам немножко расширить функциональность, ту, которая идет из коробки к Entity Framework, немножко расширить функциональность благодаря тому, что вы в вашем приложении обладаете знаниями конкретной базы данных, которые вы используете.
5336.84 5343.12 SPEAKER_01 То есть Entity Framework сама это сделать не может, а вы можете, потому что вы знаете, что у вас за база данных под капотом.
5343.12 5346.96 SPEAKER_01 Давайте же разберемся на примере, каким же образом это сделать.
5346.96 5352.16 SPEAKER_01 Автору понадобилась необходимость добавить специальный оператор forUpdate.
5352.16 5357.72 SPEAKER_01 В PostgreSQL такой оператор поддерживается, а в Entity Framework не поддерживается.
5357.72 5359.00 SPEAKER_01 Что такое forUpdate?
5359.00 5361.24 SPEAKER_01 Это достаточно такая простая штука.
5361.24 5386.48 SPEAKER_01 Например, если мы хотим выбрать некое подмножество каких-то записей для того, чтобы их в будущем изменить, добавляя специальное окончание forUpdate, мы сообщаем базе данных, что эти записи заблокированы для другого запроса forUpdate, который попытается их изменить.
5386.48 5391.60 SPEAKER_01 Это немножко похоже на пессимистичную блокировку, которую мы обсуждали с вами несколько статей ранее.
5391.60 5396.42 SPEAKER_01 То есть это такая своеобразная блокировка берется на все эти записи.
5396.42 5410.80 SPEAKER_01 И пока мы эти записи этим forUpdate не отпустили, то есть по сути, пока мы не закрыли транзакцию, в которой вызван этот forUpdate, другой select forUpdate эти записи взять не сможет.
5410.80 5414.40 SPEAKER_01 Таким образом, мы получаем вот такой пессимистичный лог.
5414.40 5423.80 SPEAKER_01 Записи мы с forUpdate забираем, изменяем, сохраняем, закрываем транзакцию, и следующий клиент, уже следующий поток, следующий concurrency какой-то агент уже может дальше работать с этими записями.
5423.80 5430.32 SPEAKER_01 Итак, вроде все понятно, концепция простая, и на уровне кода она реализуется точно так же, все довольно просто.
5430.32 5435.24 SPEAKER_01 Естественно, необходимо добавить специальные ключевые слова forUpdate в конец запроса, в конец запроса селекта.
5435.24 5441.68 SPEAKER_01 Да, то есть вы получаете select, rollie, valise, from users, forUpdate, и все, в этом принципе и все, что нам нужно сделать.
5441.68 5448.52 SPEAKER_01 Итак, попробуем же научить Entity Framework добавлять вот такой префикс в конечный запрос, который он генерирует в базу данных.
5448.52 5453.48 SPEAKER_01 На самом деле кажется, что это довольно сложно, потому что Entity Framework большой, мощный, много всего умеет.
5453.48 5463.56 SPEAKER_01 Но на самом деле он большой и мощный не только потому, что много всего умеет, но и потому, что в нем очень хорошо продуманы различные точки расширения, которые вы можете делать из своего приложения.
5463.56 5467.00 SPEAKER_01 Поэтому данное расширение тоже работает довольно просто.
5467.00 5476.20 SPEAKER_01 И точек расширения таких очень много, да, интерсепторы это всего лишь одна из таких точек, но нам она лучше всего подходит.
5476.20 5477.20 SPEAKER_01 Что же такое интерсепторы?
5477.20 5484.32 SPEAKER_01 Это специальный промежуточный код, который позволяет вам модифицировать запрос до того, как этот запрос уйдет в базу данных.
5484.32 5489.44 SPEAKER_01 Для того, чтобы нам создать такой интерсептор и подключить его и использовать, нам необходимо сделать три шага.
5489.44 5492.20 SPEAKER_01 Ну, во-первых, это объявить сам класс интерсептора и наполнить его какой-то логикой.
5492.20 5497.00 SPEAKER_01 Во-вторых, зарегистрировать интерсептор в нашем датабейс-контексте.
5497.00 5503.88 SPEAKER_01 И в-третьих, это понять тот момент, а когда нужно этот интерсептор применить, то есть в какой момент он должен сработать.
5503.88 5509.76 SPEAKER_01 Если же вы хотите, чтобы он применялся на каждый ваш запрос, то в принципе последний пункт вам не нужен.
5509.76 5514.68 SPEAKER_01 Но обычно вы хотите, чтобы он применялся не на каждый запрос.
5514.68 5519.00 SPEAKER_01 В нашем случае, в For Update, мы не хотим его добавлять, например, к делитам.
5519.00 5521.68 SPEAKER_01 Более того, мы не хотим его добавлять ко всем селектам.
5521.68 5529.12 SPEAKER_01 Мы хотим его добавлять только к селектам, которые мы пометили каким-то специальным атрибутом для того, для For Update.
5529.12 5536.44 SPEAKER_01 То есть у нас уже какое-то маленькое подмножество запросов должно попадаться, попадать под наш интерсептор.
5536.44 5545.52 SPEAKER_01 Начнем с самого сложного пункта, это как раз таки с понимания того, какие запросы мы должны модифицировать с помощью нашего интерсептора.
5545.52 5554.00 SPEAKER_01 В самых простейших случаях, например, как в нашем, мы можем воспользоваться таким прикольным методом, как tag_div.
5554.00 5561.92 SPEAKER_01 У любого iQueryable интерфейса есть метод tag_div, который принимает в качестве параметра обычную строчку.
5561.92 5566.72 SPEAKER_01 И все, что он делает, это раскладывает эту строчку в SQL-комментарий.
5566.72 5568.64 SPEAKER_01 Это, например, полезно для диагностики.
5568.64 5577.68 SPEAKER_01 Когда вы посылаете какой-то запрос в базу данных, то Quantity Framework вам пишет в логах, какой запрос он сделал.
5577.68 5586.36 SPEAKER_01 И, например, в логах вы можете с помощью метода tag_div добавить какой-то понятный для вас комментарий.
5586.36 5591.44 SPEAKER_01 Например, указать какой-нибудь Trace ID, из-за которого породился этот SQL-запрос.
5591.44 5595.44 SPEAKER_01 Или добавить текущего пользователя, который инициировал этот SQL-запрос.
5595.44 5598.44 SPEAKER_01 В общем, какую-то добавочную интересную информацию.
5598.44 5601.08 SPEAKER_01 То есть обычный комментарий к SQL.
5601.08 5611.24 SPEAKER_01 В нашем же случае, в принципе, мы можем проанализировать этот tag_div, то есть, что этот комментарий мы туда добавили, и каким-то образом в интерсепторе, допустим, на это среагировать.
5611.24 5615.28 SPEAKER_01 Таким образом, мы можем написать метод расширения, который называется for_update.
5615.28 5617.40 SPEAKER_01 Этот метод расширения будет iQueryable.
5617.40 5626.56 SPEAKER_01 И в этом методе расширения, в его реализации мы просто добавим tag, который в качестве параметра принимает строчку for_update.
5626.56 5630.00 SPEAKER_01 То есть это какой-то специальный ключ для нашего будущего интерсептора.
5630.00 5632.80 SPEAKER_01 Мы его просто передаем iQueryable, и все.
5632.80 5637.56 SPEAKER_01 И больше, в принципе, никаких задач нам делать не нужно.
5637.56 5638.56 SPEAKER_01 Дальше.
5638.56 5639.92 SPEAKER_01 Как же этот метод расширения использовать?
5639.92 5640.92 SPEAKER_01 Очень просто.
5640.92 5645.44 SPEAKER_01 Вызываете у вашего DB-контекста метод users, допустим, если вы хотите выбрать всех пользователей.
5645.44 5650.00 SPEAKER_01 Определяете какие-нибудь там условия, where user_id = id.
5650.00 5651.00 SPEAKER_01 Пишите .for_update.
5651.00 5657.80 SPEAKER_01 В этот момент вызывается наш метод расширения, и под капотом добавляет специальный SQL-комментарий.
5657.80 5660.36 SPEAKER_01 Теперь перейдем к написанию самого интерсептора.
5660.36 5670.92 SPEAKER_01 Для того, чтобы написать свой интерсептор, нам нужно пронаследоваться от стандартного интерфейса или базового класса DBCommandInterceptor и перекрыть всего лишь на всего один метод.
5670.92 5673.16 SPEAKER_01 В нашем случае это reader_executing.
5673.16 5682.60 SPEAKER_01 Как раз этот интерсептор, этот метод вызывается как раз в тот момент, когда мы подготавливаем запрос для чтения из базы данных.
5682.60 5684.64 SPEAKER_01 Что же мы можем здесь сделать?
5684.64 5695.12 SPEAKER_01 На данном этапе у нас существует некий объект DBCommand, у которого есть common_text, и этот common_text содержит полный SQL-запрос, тот, который сейчас пойдет в базу данных.
5695.12 5705.56 SPEAKER_01 Автор предлагает нам просто-напросто взять этот common_text с помощью метода contains, понять, есть ли в нем тот SQL-оператор, который мы поставили, то есть в нашем случае contains for_update.
5705.56 5711.36 SPEAKER_01 И если вдруг он есть, мы просто в конец текста добавляем ключевые слова for_update.
5711.36 5714.52 SPEAKER_01 Вот, в принципе, вся реализация, буквально в три строчки.
5714.52 5734.60 SPEAKER_01 Ну, тут предположение довольно смелое, то есть, действительно, метод contains я бы, наверное, заменил все-таки на ends_with, потому что если мы будем обновлять в базе данных фамилию юзера, и эта фамилия будет называться --for_update, то данный интерсептор тоже нам что-нибудь нехорошее сделает.
5734.60 5754.16 SPEAKER_01 Ну и также, то есть нужно проверить прежде всего, что этот for_update, компилятор где-нибудь должен, for_update комментарий должен быть где-нибудь там внизу или в самом верху, в общем, как-то более подстраховаться, наверное, или, может быть, стоит уже как-то синтаксически проанализировать, именно семантически, то есть проанализировать данный запрос, а не просто contains-ом полагаться.
5754.16 5759.48 SPEAKER_01 Но в общем случае, в принципе, подход рабочий, почему бы и нет.
5759.48 5766.28 SPEAKER_01 Если все остальные условия вас не пугают, то пожалуйста, то есть мы просто добавляем ключевой текст в конец нашего запроса.
5766.28 5771.16 SPEAKER_01 И самое последнее, что нам осталось сделать, это просто-напросто зарегистрировать наш интерсептор.
5771.16 5772.16 SPEAKER_01 То есть это тоже элементарно.
5772.16 5787.96 SPEAKER_01 В наследнике db_context, вашем application db_context, при регистрации провайдера, при указании там, где вы ему указываете connection string, вы просто вызываете ключевое слово add_interceptor и туда передаете ваш новый созданный красивый испеченный интерсептор.
5787.96 5796.64 SPEAKER_01 Теперь во время каждого запроса ваш интерсептор будет вызываться, и он сам будет определять, хочет он этот запрос модифицировать, если хочет, то как он его будет модифицировать.
5796.64 5801.44 SPEAKER_01 Итак, интерсепторы довольно такая полезная, мощная, интересная штука.
5801.44 5808.76 SPEAKER_01 И если бы их не было, то вам бы пришлось больше писать чистого скейтс-кода или чистых хранимых процедур.
5808.76 5817.40 SPEAKER_01 Ну, в общем, в любом случае, вы бы спустились в этот низкоуровневый мир, и вам бы навалилась большая тонна проблем после этого.
5817.40 5829.08 SPEAKER_01 Интерсепторы же помогают остаться вам все-таки в менеджмент мире, все-таки остаться на каких-то ORM-ках, управлять вашими сущностями, как вы к этому привыкли, и при этом расширять функциональность до прямо низкоуровневых протоколов.
5829.08 5832.92 SPEAKER_01 Также стоит отметить, что существует множество разных интерсепторов.
5832.92 5857.92 SPEAKER_01 Кроме command-интерсептора, который мы рассмотрели, есть connection-интерсепторы, которые позволяют управлять коннекциями, то есть соединениями с базой данных, есть transaction-интерсепторы, которые позволяют там джонглировать транзакциями в различных их семантических значениях, в общем, много красивых интересных интерсепторов, которые позволяют не только там расширять, допустим, все электронные апдейты и делиты, и менять типы, и в общем, много-много всего интересного можно с ними поделать.
5857.92 5873.56 SPEAKER_01 Поэтому если вдруг вам нужно немножко подрегулировать entity-framework для того, чтобы он генерил какие-то новые скейт-запросы, или каким-то образом транзакции обрабатывал по-особому, или логировал все коннекции, в общем, то посмотрите в сторону интерсепторов, довольно богатый и мощный механизм.
5873.56 5907.12 SPEAKER_00 Единственный момент, который я хочу отметить, что если вы будете использовать интерсепторы вот с тем подходом, как показано в статье, то есть через теги, то вы можете, надо внимательно посмотреть, чтобы не потерялась еще одна полезная возможность, потому что вот эти самые теги интересно и полезно использовать, чтобы каким-то образом отличать запросы друг от друга, то есть у нас, например, одно время использовались вот эти конструкции with text, они явно были написаны, туда дописывался комментарий по сути о том, что это за запрос, кратко.
5907.12 5918.92 SPEAKER_00 Тогда у вас в логах или в SQL-серверных логах или еще где-то просто видны эти названия запросов, даже если у вас запрос отрезан в конце, вам все равно по первому комментарию видно, что это был за запрос.
5918.92 5931.72 SPEAKER_00 И вот если вы теги начинаете использовать для таких интерсепторов, то нужно будет внимательно посмотреть, чтобы вы правильно их находили и нужные теги заменяли на дописывание запроса в нужном месте.
5931.72 5932.72 SPEAKER_00 Вот.
5932.72 5933.72 SPEAKER_01 Это просто.
5933.72 5946.12 SPEAKER_01 Ну, текущая реализация, кажется, твоему примеру не противоречит, она, ну, мы можем много использовать тегов, и она их, ну, и она ключевое слово, этот ключевой строков update просто в конец записывает, поэтому все остальные теги останутся на месте.
5946.12 5951.80 SPEAKER_00 Ну да, да, главное, чтобы не было конфликта с чем-нибудь еще.
5951.80 5952.80 SPEAKER_00 Вот.
5952.80 5958.32 SPEAKER_00 Хорошо, давай пойдем напоследок расскажем у нас кратко о разном.
5958.32 5966.88 SPEAKER_00 Тут накопилось немножечко статей, не статей, и начнем мы с tools, опять же.
5966.88 5989.48 SPEAKER_00 Мы, наверное, давно уже не касались всяких разных дампов для дотнета, того, как это все собирать, как это все анализировать, но если вы этим занимались, вы наверняка знаете такой tool procdump из комплекта sysinternals, отличных тулов от Марка Русиновича, которые позволяют на винде творить много чего полезного.
5989.48 6023.88 SPEAKER_00 У нас были доклады на dotnext давно уже про то, что некоторые из этих тулов, прокмон, например, перенеслись на линукс, и у них существует линукс-версия, так вот теперь появилась версия procdump для macOS, то есть если вы вдруг запускаете ваше дотнет-приложение на macOS, и вам хочется собрать дампы, напомню, что procdump он умеет собирать очень умно, его можно настроить до первого исключения или до конкретного, или еще как-то, или по памяти собрать вам дамп, или по времени, в общем, полезная штука, теперь она есть на macOS, можно пользоваться.
6023.88 6024.88 SPEAKER_00 Дальше.
6024.88 6081.36 SPEAKER_00 Есть библиотечка, у нас, кстати, это, наверное, один из немногих выпусков, где вы еще ни разу не сказали слово dotnetspire, исправляемся, появилась библиотека, называется dotnetspire-community-toolkit, видимо, это те интегрейшены, то есть те самые расширения для dotnetspire, которые не нашли или по какой-то причине не были включены в основной комплект dotnetspire, я напомню, что основные интегрейшены живут в самом репозиторе dotnetspire, но здесь живут другие, и там, в частности, там живет всякие джаваскриптовые штуки типа bana, dno, gotem живет, java со спрингом, node.js, ollama, rust, в общем, всякие, если вы хотите вот такие штуки подключить к вашему ispire-проекту, вам в этот самый dotnetspire-community-toolkit возможно в этом что-то найдете.
6081.36 6082.36 SPEAKER_00 Далее.
6082.36 6113.00 SPEAKER_00 У нас есть в дотнете командлайновый способ создать новый проект из шаблончика, называется dotnetnew, дальше можно выбрать какой шаблон вам нужен, и что-то там сделать, но был запрос, я не знаю откуда, что нам нужен новый interactive CLI tool, то есть в dotnetnew, как правило, вы практически все передаете командлайн, там он вам спрашивает пару вопросов, но в целом обычно большую часть всего передаете командлайн.
6113.00 6136.28 SPEAKER_00 Здесь же это теперь interactive новый tool появился, называется dotnetscaffold, пока это превьюшка, устанавливается как обычно global tool, сейчас поддерживает пока ispire.net core, webapp, webapi и dotnetspire с blazor, то есть если вы хотите какой-то более такой wizard-стайл создания новых приложений из шаблонов, посмотрите в сторону dotnetscaffold, возможно вам понравится.
6136.28 6141.08 SPEAKER_01 При том из командной строки, не просто там wizard какой-нибудь с кнопочками, а командно-строковый wizard.
6141.08 6147.24 SPEAKER_00 Interactive CLI tool, прям подчеркнуто, то есть это как бы ньюайны, да, все в командной строчке.
6147.24 6174.28 SPEAKER_01 Опять же, немножко страшно, странно, да и страшно тоже, потому что обычно в языках scaffold это немножко другое, это штука, которая помогает тебе, например, у существующего приложения добавить, допустим, контроллер, который протянется в модельку и который зарегистрируется в базу данных и который сгенерит миграцию, вот это scaffold, а то, что мы создаем что-то с нуля, это уже больше какой-то действительно new, и лучше бы они там dotnet.new как-нибудь расширили, добавили бы и флажок interactive или что-нибудь в этом духе.
6174.28 6179.72 SPEAKER_00 Ну может потом переименуют и сделают его view, а scaffold за view, не знаю, посмотрим.
6179.72 6221.20 SPEAKER_00 Дальше, мы уже сегодня обсуждали статью Кристофа Назара про то, как сделать собственный профайлер узкоспециализированный, есть такой товарищ Александр Мютл, он периодически делает какие-то доклады, ну и вообще низкоуровневый товарищ про dotnet, он тоже сделал свой собственный профайлер, он доступен только на Windows, потому что он работает на Event Tracing for Windows, ему был нужен, я так понимаю, некоторый аналог perfview в каком-то смысле в более красивом виде, плюс который умеет работать одновременно и с ядерными функциями, и с нативным кодом, и с managed, короче, все вместе.
6221.20 6295.44 SPEAKER_00 В итоге он написал профайлер, который в качестве UI, ну чтобы не париться, использует профайлер из Firefox, то есть на самом деле он просто генерит некоторые трейсы в формате, который умеет понимать профайлер.firefox.com, это всякие там, как раз там будут, как они называются, flame graph и вот это все, короче, все умеется, там довольно неплохой UI, вот, он умеет профайлер в смысле категоризировать функции, что это dotnet, dotnet.jit, dotnet.garbage.collector, native, kernel, как-то умеет трекать память, умеет понимать где когда срабатывал JIT с точки зрения compile time и какую функцию он в этот момент компилировал, знает ивенты от garbage.collector, всякие allocation ticks и прочее, при этом довольно легковесный, как написано, ну он генерит всего несколько мегабайт за 10 секунд работы, вот, но единственное, что требует восьмого дотнета или позднее, ставится через dotnet global tool install, если вам нужен какой-то очень развесистый профайлер, точнее не столько развесистый, сколько профайлер, который хорошо умеет с нативным кодом и внутрянкой дотнета работать, вот возможно, а перфю вы боитесь по какой-то причине или непонятно, как с ним работать, вот посмотрите на эту штуку, может вам понравится.
6295.44 6317.52 SPEAKER_00 И последнее от меня, это забавный сайтик, я на него возлагал, ну как не сайтик, это очередной гитхаб репозиторий, такие встречаются практически для разных технологий, это build with maui, мы с тобой много раз про мауи говорили, про то, что ну что-то как-то развивается непонятно как, непонятно как, а есть ли какие-то продукты, которые на нем написаны.
6317.52 6318.52 SPEAKER_00 Ну в общем, короче, я нашел.
6318.52 6320.52 SPEAKER_01 Да, это хороший список, ну-ка, сколько там продуктов
6320.52 6321.52 SPEAKER_00 нахуй?
6321.52 6324.44 SPEAKER_00 Там 27 приложений, я не знаю ни одного.
6324.44 6328.84 SPEAKER_00 Это хороший показатель того, что нахуй никому этот мауи не нужен.
6328.84 6339.08 SPEAKER_00 Ну то есть, там они довольно узкоспециализированы, то есть там типа, какое-то приложение для что-то типа трекинга сна или что-то в таком духе, какое-то приложение для скалолазания.
6339.08 6362.20 SPEAKER_00 Ну то есть, конечно, очень узкоспециализированные приложения для ios и андроида в основном, там с указанием количества скачиваний, некоторые даже довольно неплохо скачиваются, там на десятки тысяч идет речь, но десятки тысяч в разрезе как бы плеймаркета и апстора ios, это мне кажется очень немного, надо сказать, там действительно какое-то узкоспециализированное.
6362.20 6373.16 SPEAKER_00 То есть, в общем, они есть, но их как-то очень пока мало и ничего суперизвестного я там не нашел, даже, ладно, супер, уберем приставку, ничего хоть как-то известного мне я не нашел.
6373.16 6374.16 SPEAKER_00 Такие дела.
6374.16 6375.16 SPEAKER_00 Да, жалко мауи, жалко.
6375.16 6376.16 SPEAKER_01 Ну что, пойдем дальше?
6376.16 6396.36 SPEAKER_01 Я хотел еще в коротко-разном немножко упомянуть парочку докладов, потому что у нас как бы есть рубрика «Прослушано», в которой мы обсуждаем о том, о чем поговорили другие подкасты, другие люди, а свои, собственно, лекции те, которые мы курируем и делаем, мы почему-то никогда не освещаем.
6396.36 6403.28 SPEAKER_01 Мне кажется, это несправедливо, поэтому вот с сотой, сотого митапа уже, мне кажется, мы начнем это делать.
6403.28 6404.28 SPEAKER_01 О чем я говорю?
6404.28 6427.92 SPEAKER_01 Мы в том числе участвуем в группе, которая тренирует докладчиков на .NET.RU всякие митапы, в частности на SPB.NET митап, и в этом году у SPB.NET митапа случился сотый выпуск, то есть мы уже сто раз собирались, и на каждом из этих митапов читаются уникальные, классные, интересные доклады, которые авторы сами изобретают, сами исследуют, сами рассказывают, сами готовят.
6427.92 6431.40 SPEAKER_01 Именно поэтому они такие аутентичные и довольно занимательные.
6431.40 6438.88 SPEAKER_01 В частности, чтобы вы понимали, о чем я говорю, и могли бы, может быть, тоже расширить свой кругозор, если вдруг тема вам интересна.
6438.88 6448.84 SPEAKER_01 На сотом выпуске на юбилейном у нас выступил Дмитрий Нестрюк, который рассказал про разработку с использованием искусственного интеллекта, как раз то, на чемся хайпит последние годы весь мир.
6448.84 6469.20 SPEAKER_01 Вот Дмитрий проанализировал, насколько это разработчикам полезно или не полезно, как это можно использовать в своей работе, куда это движется, и, в общем, такой практически философский доклад получился на весь митап, то есть на три часа почти, с рассуждениями о том, как это можно применять и куда нужно смотреть.
6469.20 6478.60 SPEAKER_01 Дальше есть доклад, вышел за запись Евгения Пешкова, это о синхронности не только о синковой, в котором Женя как раз таки рассказала, что еще можно знать про синхронность.
6478.60 6485.68 SPEAKER_01 И если вам так же точно интересно, о чем Женя Пешков внутри про синхронность мог рассказать, то обязательно посмотрите.
6485.68 6489.64 SPEAKER_01 У него доклады всегда свежие, интересные и полны каких-нибудь новых мыслей.
6489.64 6500.20 SPEAKER_01 Станислав Сидристый у нас был с рассказом о том, как писать плагины к сервисам и как сделать безопасное расширение функциональности в нашем 21-м веке.
6500.20 6520.68 SPEAKER_01 Когда-то в свое время, мне кажется, любое приложение обязательно выпускалось с помощью плагинов, более того, если мы делали какой-нибудь DI-контейнер, который подключал компоненты, то если у такой DI-контейнера не была возможность динамически в рантайме сканить диск и находить там какие-то сборки, подключать эти сборки в виде плагинов, то это считался плохой DI-контейнер.
6520.68 6543.68 SPEAKER_01 К счастью, те времена уже довольно-таки давно прошли, плагины уже не так популярны, как раньше, то есть каждый разработчик не мечтает сделать свою плагинную систему, но все-таки плагины никуда не делись и некоторым системам их все еще делать нужно, все еще поддерживать нужно, а после того, как Microsoft обрубил поддержку апдоменов .NET Core, может быть, для некоторых неочевидно, а как же, собственно, их делать.
6543.68 6552.08 SPEAKER_01 Оказывается, есть современные техники, как делать классные, хорошие, изолированные плагины, которые хорошо в рантайме подгружаются, более того, даже выгружаются.
6552.08 6555.96 SPEAKER_01 В общем, обязательно посмотрите доклад Станислава Сидористова, если вам это интересно.
6555.96 6572.84 SPEAKER_01 Андрей Порожняков рассказывал у нас про nativeout, тот доклад, который сегодня как раз-таки уже был отрекламирован, если вам вдруг интересен nativeout, интересно, откуда он берет такую шикарную производительность относительно основного большого .NET, а также какие подводные камни с ним связаны, в общем, в докладе Андрея вы все это увидите.
6572.84 6577.20 SPEAKER_01 Дмитрий Георгов рассказывал нам про использование AWP в .NET.
6577.20 6588.76 SPEAKER_01 В общем, здесь тоже тема довольно узкая, но достаточно интересно, если аспект на ориентированное программирование тоже каким-то образом вас касается, то доклад Дмитрия расскажет вам про много вещей, о которых вы даже не знали.
6588.76 6604.68 SPEAKER_01 Александр Гальдебаев рассказывал про Aspire in Action, поэтому Aspire Aspire, если вдруг вы до сих пор не знаете, что это, как это, с чем это едят, то, наверное, самый большой и самый глубокий обзор из лекций на русскоязычном языке, который есть, представлен в этом докладе.
6604.68 6651.56 SPEAKER_01 Виктор Греков читал доклад про анализ дампов, с чего начать, поэтому если вы вдруг боитесь дампов или профайлеров, про которые мы сегодня уже не раз упоминали, не знаете, что это такое, зачем они используются и в какое место их засовывать, то вот как раз доклад Виктора продемонстрирует вам о том, что это достаточно хороший инструмент, и он удобен для, может быть, каждодневного даже использования, он удобен для того, чтобы просто посмотреть, как ваша программа работает, что в ней происходит, и в критический момент, когда настанет день ЖО, вы уже будете знать, каким образом пользоваться дампером, пользоваться профайлером, куда копать, где лезть, и вообще научитесь как профессионал использовать весь свой инструмент разработчика в таком шикарном ключе, как анализ дампов или анализ профайлеров.
6651.56 6665.76 SPEAKER_01 Я напомню, что все эти доклады можно будет найти на ютубе в группе dotnet.ru, также все ссылочки у нас будут в шоу-ноутах, поэтому заходите, смотрите, комментируйте, лайкайте, а мы будем вас знакомить с будущими докладами, которые продолжим делать.
6665.76 6691.92 SPEAKER_01 Я напомню, что митапы у нас проводятся во многих городах, в частности, в СПБ, в Санкт-Петербурге мы делаем регулярно каждый месяц, если вы вдруг будете проездом в нашей культурной столице, то посмотрите, может быть, как раз в даты вашего посещения мы будем делать очередной митап, все они бесплатные, интересные, поэтому заходите на огонек, мы всегда рады посетителям других городов, ну и если вы из Петербурга и почему-то никогда не были у нас в гостях, тоже приходите, будем рады каждому.
6691.92 6700.60 SPEAKER_00 А если вы хотите что-нибудь рассказать, то мы точно будем рады, заходите, с удовольствием поможем и дадим возможность выступить.
6700.60 6704.48 SPEAKER_01 Ну вот так хорошо и подкаст провели, да, и себя порекламировали.
6704.48 6705.48 SPEAKER_01 Да, куда ж без этого.
6705.48 6706.48 SPEAKER_01 Это все митапы.
6706.48 6726.32 SPEAKER_00 Ну да, значит, на этом мы, наверное, будем на сегодня завершать, мы попробовали сделать короткий выпуск у меня на тайминге 1 час 47, что получится после монтажа я не знаю, но больше полутора часов мы точно, видимо, получим подкаст, так что да, наши планы, как всегда, не оправдываются, но как с любыми оценками в программировании, надо умножать.
6726.32 6733.04 SPEAKER_01 Мы подкаст завершать не будем, а будем еще тренироваться и тренироваться, то есть там есть куда расти, перспективы большие.
6733.04 6780.92 SPEAKER_00 Чтобы наши оценки совпадали с реальными ситуациями к концу подкаста, но тем не менее, за сегодня мы обсудили, какие у нас бывают подходы к оптимистичным и пессимистичным блокировкам и какие, может быть, альтернативы можно рассмотреть, посмотрели, как сделать довольно низкоуровневый такой полупрофайлер, чтобы понять какие-то внутренности того, как работает в данном конкретном случае HttpClient, порассуждали на тему, что не так с дотнетом в Яндекс.Клаудфункшнз и какой подход выбрать, если вы хотите размещать там дотнет-приложения, посмотрели кратенько на Technology Radar 31 выпуск, поразбирались с тем, как тюнить запросы в EF Core с помощью интерсепторов, ну и кратенько пробежались по всяким разным мелким тулам и статьям.
6780.92 6784.56 SPEAKER_00 На этом, кажется, 105-й выпуск подошел к концу.
6784.56 6785.56 SPEAKER_01 Кажется да.
6785.56 6795.56 SPEAKER_01 В общем, всем до новых встреч, подписывайтесь на наши каналы, ставьте комментарии, там лайки, репосты, скинуться на апельсины и кефир можно на Boosty, в общем, все вы знаете.
6795.56 6796.56 SPEAKER_01 До новых встреч, пока.
