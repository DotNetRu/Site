0.00 6.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
6.36 10.52 "Анатолий Кулаков" В эфире Радио.нет выпуск номер 41.
10.52 13.56 "Анатолий Кулаков" Сегодня в студии для вас будут работать Анатолий Кулаков и Игорь Лабутин.
13.56 14.56 "Анатолий Кулаков" Привет!
14.56 17.00 "Анатолий Кулаков" Большое спасибо всем, кто нас поддерживает.
17.00 23.04 "Анатолий Кулаков" У нас есть сайты на Patreon и Boosty, где мы выкладываем дополнительный материал и собираем вашу посильную помощь.
23.04 25.32 "Анатолий Кулаков" Заходите, посмотрите, что у нас там есть интересного.
25.32 29.04 "Анатолий Кулаков" И особая благодарность Александру Сергею Владиславу.
29.04 34.96 "Анатолий Кулаков" Если вы захотите присоединиться к списку этих благих ребят, то тоже все условия на сайтах.
34.96 35.96 "Анатолий Кулаков" Заходите, смотрите.
35.96 42.96 "Анатолий Кулаков" Ну что ж, у нас тут есть немножко легких новостей, из которых мы можем с тобой размяться, пока не прошли к основным темам.
42.96 47.12 "Анатолий Кулаков" И одна из таких мелких новостей – это мы стали доступны на Spotify.
47.12 49.64 "Анатолий Кулаков" Я знаю, что многие любят этот сервис.
49.64 52.96 "Анатолий Кулаков" Он недавно пришел в Россию и у него долго не работали подкасты.
52.96 53.96 "Анатолий Кулаков" Все остальное работало.
53.96 56.44 "Анатолий Кулаков" И вот, наконец-то он подключил к себе подкастов.
56.44 60.60 "Анатолий Кулаков" Просто постраняет он их не всем, а какими-то волнами это все дело идет.
60.60 65.64 "Анатолий Кулаков" Ну вот, уже дошло до большей части моих знакомых и вот до меня непосредственно тоже.
65.64 68.92 "Анатолий Кулаков" Радио.net теперь можно слушать прямо на Spotify.
68.92 75.28 "Анатолий Кулаков" Для всех любителей этого сервиса – присоединяйтесь, ставьте звездочки, лайкайте, шарьте нас или что-то можно еще делать.
75.28 81.12 "Анатолий Кулаков" В общем, поддерживайте на своей любимой площадке наш подкаст и не только на Spotify, в принципе везде, где вы слушаете.
81.12 88.96 "Анатолий Кулаков" Не забывайте там про 5 звездочек, про пальцы вверх и прочее безобразие, которое помогает нам подниматься в топе и захватывать новых слушателей.
88.96 92.44 "Игорь Лабутин" Еще я увидел какую-то новость про .net подкаст.
92.44 96.52 "Игорь Лабутин" Это очередной сайт, типа собери все подкасты вместе или как?
96.52 97.52 "Анатолий Кулаков" Нет, нет, не совсем.
97.52 106.72 "Анатолий Кулаков" Вот как раз недавно отгремел релиз .net 6 и там один из самплов новых, который появился, как раз было подкаст-приложение.
106.72 114.76 "Анатолий Кулаков" И это подкаст-приложение, оно создано специально для того, чтобы вы посмотрели, как делается настоящий современный приложение.
114.76 118.32 "Анатолий Кулаков" Там напихано просто все, что только можно представить.
118.32 127.16 "Анатолий Кулаков" Moyu, Blazer, Azure DevOps, Docker контейнеры, LOD, Balancers, мобильные приложения под все платформы, Webka, APIka.
127.16 133.44 "Анатолий Кулаков" В общем, все практически, наверное, технологии, которые есть у Microsoft, они постарались засунуть в этот сампл.
133.44 137.12 "Анатолий Кулаков" Ну, тем этот сампл и прекрасен, что он показывает, как это все вместе интегрироваться.
137.12 144.32 "Анатолий Кулаков" И, соответственно, этот сампл, это не просто какое-то там приложение в стол, это настоящее рабочее приложение.
144.32 153.40 "Анатолий Кулаков" Приложение для прослушивания подкастов и, соответственно, приложение для того, чтобы собирать библиотеку этих подкастов, распространять их и так далее.
153.40 159.04 "Анатолий Кулаков" На первый взгляд, кажется, все довольно красивеньким, ну, как и положено быть настоящему маркетинговому приложению.
159.04 168.48 "Анатолий Кулаков" Я, правда, еще не успел проверить, есть ли в этом списке Radio.net, поэтому если кто-то из наших слушателей сможет это проверить, приходите в комментарии и нам расскажите.
168.48 181.60 "Анатолий Кулаков" Или если нет, то отдельный большой вам респект, если вы сделаете pull request и добавите нас туда, потому что приложение, естественно, open source, лежит на GitHub, есть issues, pull requests и все коммиты всячески приветствуются.
181.60 187.48 "Анатолий Кулаков" Попробуйте протащить нас тоже туда, будет интересно, насколько там принимают русская диверсити.
187.48 195.72 "Игорь Лабутин" Возможно, придется добавить какой-нибудь там тег про язык или сделать новую категорию по разным языкам, но я думаю, что они будут вполне не против.
195.72 202.72 "Анатолий Кулаков" Мне кажется, да, потому что это приложение показательное и им интересно показать, что их слушают не только англоязычные слушатели.
202.72 208.24 "Анатолий Кулаков" Ну что ж, шуточки, наверное, закончились, мы размялись, давай поговорим, наконец-то, о серьезных темах.
208.24 217.40 "Анатолий Кулаков" Ну и что может быть серьезней, особенно после того, как в предыдущем выпуске у нас вышел C# 10, это, конечно же, объявить его легаси и поговорить про C# 11.
217.40 220.84 "Анатолий Кулаков" Что там известно у нас про этот замечательный новый язык?
220.84 228.32 "Игорь Лабутин" Ну, он не настолько, чтобы новый, но, тем не менее, да, C# 11 теперь будет нас преследовать весь ближайший год и мы про него будем много говорить.
228.32 235.24 "Игорь Лабутин" На самом деле история про C# 11 началась задолго до релиза C# 10.
235.24 246.68 "Игорь Лабутин" Первый митинг по его, так сказать, приоритизации фич для C# 11 произошел 30 августа 2021 года, то есть уже, ну, если не полгода назад, то где-то близко.
246.68 251.44 "Игорь Лабутин" И надо, наверное, пояснить сначала, что за митинг.
251.44 284.96 "Игорь Лабутин" В команде, собственно, разработчиков языка есть такая активность, называется Language Design Meeting, она не то чтобы сильно регулярна, но она происходит примерно раз в неделю, и там народ обсуждают, видев Мэтт Сторгерсон и приглашенные разные люди в зависимости от обсуждаемых фич, они обсуждают разные рода пропозлы в язык, что с ними делать, куда дальше их двигать, как с ними обходиться, какие доработки требуются, что отказать, что принять, что попробовать реализовать и так далее.
284.96 301.76 "Игорь Лабутин" По каждому митингу пишется небольшой документик, ну иногда экрана на 3-4 на GitHub, где в кратком виде емко изложено, что обсуждали, зачем обсуждали, к чему пришли, какие были сомнения, какие следующие шаги по каждому из обсуждаемых топиков.
301.76 308.16 "Игорь Лабутин" Соответственно, можно, если вам очень интересно, проследить всю историю обсуждения то ли иной фичи в том или ином виде.
308.16 320.52 "Игорь Лабутин" Это все снабжается линками на кучу других GitHub, на Roslyn компилятор, на какие-то issues в рантайме, в CoreFX, в смысле в стандартной библиотеке, и так далее.
320.52 329.68 "Игорь Лабутин" Если вам, например, интересно, как там живут дискриминденты unions, находите этот пропозл, и дальше по ссылкам там можно гулять просто, не знаю, часами.
329.68 336.64 "Игорь Лабутин" Так вот, 30 августа произошел митинг, который назывался C# Initial Triage.
336.64 352.16 "Игорь Лабутин" Они собрались, чтобы понять, какие фичи из тех, которые сейчас рассматриваются, наиболее приоритетны для того, чтобы быть включенными в C# 11, или точнее, для того, чтобы начать их прорабатывать для возможности включения в C# 11.
352.16 364.12 "Игорь Лабутин" Есть, конечно, мелкие штуки, которые там практически сразу можно заапровить, просто потому что не успели в 10, и там уже все обсуждено, а есть гораздо более абстрактные, которые вам еще исследовать и исследовать.
364.12 378.88 "Игорь Лабутин" Вот давайте пробежимся по тому, что было объявлено конкретно на этом, обсуждено, точнее, на этом митинге, плюс я на самом деле просмотрел все последующие, до, собственно, сегодняшнего дня записи, и подергал оттуда тоже немножко данных.
378.88 389.36 "Игорь Лабутин" Конечно, все полностью обозреть невозможно, там очень детальные рассуждения, которые надо смотреть с кодом на GitHub и пытаться понять аргументацию, собственно, тех, кто там участвовал.
389.36 397.04 "Игорь Лабутин" Итак, топики, которые рассматриваются для того, чтобы быть возможно, подчеркиваю, возможно включенными в C# 11.
397.04 401.28 "Игорь Лабутин" Первое — это generic attributes, то есть обобщенные атрибуты.
401.28 410.32 "Игорь Лабутин" На самом деле фича уже работает в C# 10, с ней все хорошо, но с ней все хорошо до тех пор, пока вы работаете только на C#.
410.32 419.04 "Игорь Лабутин" Если вы, например, дергаете C++ с manage C++, то manage C++ как только видит кусочек кода, в котором используется generic attribute, он просто падает.
419.04 432.84 "Игорь Лабутин" Это как бы не очень здорово, и поэтому фича пока включается только специально фича-флагом, а, соответственно, в C# 11 будет проводиться работа по тому, чтобы сделать их таки полностью нормально, чтобы вся экосистема .NET работала с ними нормально.
432.84 449.80 "Игорь Лабутин" Вторая штука — это field keyword, то есть у нас есть уже возможность сделать автопроперти, это очень удобная штука, но приходилось ли когда-нибудь, например, Толь, тебе отказываться от автопроперти просто потому, что в сеттере тебе нужно сделать какую-нибудь простую валидацию?
449.80 457.92 "Анатолий Кулаков" Да, безусловно, потому что автопроперти работают только для самых простых кейсов, и если шаг влево, шаг вправо, приходится возвращаться к back-end field.
457.92 468.88 "Игорь Лабутин" Вот, они предлагают сделать следующее, они предлагают оставить автопроперти, второе название этой фичи — semi-autoproperty, то есть полуавтоматические проперти, и сделать следующее.
468.88 479.96 "Игорь Лабутин" Если ты помнишь, внутри гетера и сеттера, нет, внутри гетера, это я вру, конечно, внутри сеттера есть специальное переменное под названием value, это то, что ей как бы передали.
479.96 494.80 "Игорь Лабутин" Так вот предлагается ввести новую переменную со специальным названием field, ключевое слово, она будет автоматически обозначать back-end field, то есть тебе не нужно будет его больше объявлять в классе, у тебя будет нормальная автопроперти, но внутри сеттера можно будет написать, по сути, field, присвоить value.
494.80 502.60 "Анатолий Кулаков" Ну да, действительно, это покроет очень большой пласт тех моментов, когда нам приходится разворачивать настоящую автопроперти.
502.60 507.36 "Игорь Лабутин" Да, и соответственно уменьшит количество кода, и будет всё замечательно.
507.36 516.48 "Игорь Лабутин" Так что штука полезная, я чуть позднее в самом конце этого блога расскажу, что на самом деле уже сейчас в процессе имплементации внутри рослина.
516.48 535.44 "Игорь Лабутин" Дальше есть большая работа по улучшению или расширению паттернов, паттерн-матчинга, то есть сейчас там рассматриваются два паттерна, это лист паттерны, можно будет написать из квадратная скобка открылась, там 1,2,3 квадратная скобка закрылась, и он будет матчить коллекцию с вот таким списком.
535.44 540.80 "Игорь Лабутин" Не очень понимаю, зачем это может быть нужно, прям такие явные списки, но, наверное, зачем это нужно.
540.80 559.72 "Игорь Лабутин" А второе, они хотят сделать slice pattern, это когда ты внутри этого списка можешь в качестве одного из элементов указать, допустим, var x, то есть допустим первый элемент явный, потом var x, потом последний элемент явный, и у тебя он будет матчиться тогда, если у тебя первые и последние элементы правильные, а внутри там что угодно.
559.72 562.44 "Игорь Лабутин" Ну и, соответственно, присваивать это в переменную x.
562.44 571.64 "Игорь Лабутин" Называется это слайсами, я не очень понял, какие там ограничения, сколько элементов там может быть и какого типа будет x, это отдельный интересный вопрос.
571.64 588.08 "Игорь Лабутин" И, судя по всему, там как раз все основные обсуждения и ведутся вокруг, собственно, типизации этого дела, потому что слишком много всего может быть, это могут быть спаны, это могут быть read-only спаны, это могут быть array, это могут быть листы, это может быть innumerable, ну то есть там слишком много всяких разных вариантов.
588.08 589.60 "Игорь Лабутин" Вот, работа еще ведется.
589.60 610.52 "Анатолий Кулаков" Я много таких pattern matching внутри листа видел во всяких OCaml-based языках и там List-based, например, где все в мире это списки, и когда ты со списками работаешь точно так же, как с обычными переменами, то есть тебе нужно эти списки каким-то образом match-ить, раскладывать, деструктурировать по переменным и так далее.
610.52 612.80 "Анатолий Кулаков" Там это становится очень полезным.
612.80 618.68 "Анатолий Кулаков" Но действительно в наших ежедневных каких-то шаблонах работы я такое встречаю довольно редко.
618.68 623.48 "Анатолий Кулаков" Ну, может ты опять знаешь из той системы, что пока у тебя этой фичи нет, ты не понимаешь, насколько сильна она тебе нужна.
623.48 636.44 "Игорь Лабутин" Ну, на самом деле ты абсолютно прав, что это есть в некоторых языках, и на самом деле ровно это написано прямо в Proposal, что есть языки, в которых список является, скажем так, first-class citizen, то, что называется.
636.44 638.24 "Игорь Лабутин" Прямо конструкция языка типа питона.
638.24 646.84 "Игорь Лабутин" В питоне, например, список — это список, там нет вариантов, это лист, массив или еще что-нибудь, это просто список, прямо у него есть синтаксис непосредственно.
646.84 651.12 "Игорь Лабутин" И там понятно, что это натурально, как у нас это будет, посмотрим.
651.12 652.12 "Игорь Лабутин" Дальше.
652.12 674.36 "Игорь Лабутин" Static abstracts and interfaces — это кусочек generic математики, которую мы много раз обсуждали, она уже присутствует в C# 10, но опять же, как initial preview, смотрим на фидбэк и по результатам фидбэка будем думать, точнее, команда языка будет думать, что с этим всем делать, нужно ли подносить какие-то изменения.
674.36 681.36 "Анатолий Кулаков" Лишний шаг, опять, чтобы сломать мозг всем на собеседовании, даже звучит страшно — static abstracts and interfaces.
681.36 682.80 "Игорь Лабутин" Да, да, да.
682.80 693.52 "Игорь Лабутин" Отдельный пункт, кстати, в Proposal, по-моему, если я не ошибаюсь, в этом как раз месте, относится к как соотносится static abstracts и interfaces с default interface методами.
693.52 697.00 "Игорь Лабутин" Вот-вот, точно, отдельные книги уже можно писать, начинайте.
697.00 698.00 "Игорь Лабутин" Вот.
698.00 699.00 "Игорь Лабутин" Подожди, там дальше будет интереснее.
699.00 700.00 "Игорь Лабутин" Дальше пошли.
700.00 705.20 "Игорь Лабутин" Дальше, декларейшнс в or паттернах при паттерн-матчинге.
705.20 706.52 "Игорь Лабутин" Это интересная штука.
706.52 724.08 "Игорь Лабутин" То есть, смотрите, например, вы хотите заматчить вариант, когда у вас, допустим, есть tuple, и вы хотите проверить, что tuple является видом переменной i, и второй элемент — 0, или первый элемент — 0, а вторая переменная — это какой-то i.
724.08 728.20 "Игорь Лабутин" То есть вам нужно, чтобы один из элементов tuple был 0, а второй вам, собственно, и интересен.
728.20 738.28 "Игорь Лабутин" Вы сейчас не можете написать, что это int i, запятая 0 в скобочках, как deconstruction для tuple, or 0, запятая int i снова.
738.28 744.80 "Игорь Лабутин" То есть вы не можете int i написать в двух частях, хотя понятно, что сработает только одна из них, потому что он либо один, либо другой.
744.80 749.20 "Игорь Лабутин" Ну а если tuple — 0, 0, ну как бы int все равно, и все равно 0 в обоих случаях.
749.20 751.20 "Игорь Лабутин" Вот, так нельзя, а будет можно.
751.20 756.96 "Игорь Лабутин" Сейчас вы вынуждены это разносить на два разных, допустим, кейса внутри свитча.
756.96 763.56 "Игорь Лабутин" То есть писать отдельно int i, запятая 0, стрелочка, что сделаешь что-то одно, 0, запятая int i, стрелочка, сделай, ну, собственно, то же самое.
763.56 765.08 "Игорь Лабутин" Можно будет писать через or.
765.08 766.08 "Анатолий Кулаков" Будет работать.
766.08 772.12 "Анатолий Кулаков" Полезная штука, особенно интересно, как они вот pattern matching среди всех версий до сих пор протаскивают, протаскивают по чуть-чуть, улучшают.
772.12 773.12 "Игорь Лабутин" Прям приятно смотреть.
773.12 777.56 "Игорь Лабутин" Да, отдельная и примерно такая же тема — это рекорды и инициализация.
777.56 787.44 "Игорь Лабутин" Тут прям они очень забавно написали, что типа «тема широкая, большая, нас интересует в этой теме примерно следующий раздел».
787.44 788.44 "Игорь Лабутин" Значит разделы.
788.44 793.96 "Игорь Лабутин" Required properties — это пропертиз, которым можно будет обозначить, что они обязательны для инициализации.
793.96 797.92 "Игорь Лабутин" Final initializers — не помню, ну, что это такое.
797.92 808.80 "Игорь Лабутин" Factories — это, видимо, что-то про более, ну, типа как сделать factory для рекордов и как сделать factories, которые гарантируют вам инициализацию классов тем или иным способом.
808.80 814.84 "Игорь Лабутин" Primary constructors, public init fields, immutable collection initializers.
814.84 818.04 "Игорь Лабутин" Как скомбинировать object initializers и collection initializers.
818.04 829.60 "Игорь Лабутин" Ну и в общем, а, еще они хотят сделать некоторую возможность подцепиться к ивентам, которые будут срабатывать в момент инициализации объектов.
829.60 833.04 "Игорь Лабутин" Говорят, очень полезная штука для чего-то, не знаю для чего.
833.04 841.12 "Игорь Лабутин" В общем, рекорд и инициализация, каждый из этих, ну, и названных топиков — это отдельный пропозал, который там отдельный на много-много-много экранов и кучу обсуждений.
841.12 844.12 "Игорь Лабутин" Что из этого куда пойдет, вообще непонятно.
844.12 860.48 "Анатолий Кулаков" Звучит интересно, мне только кажется, что зря они как-то на рекордах зациклились, потому что уже давно и для классов хочется, например, какой-нибудь атрибутик, который будет обозначать неизменяемые классы, immutable классы, чистые методы и прочие вот эти штуки, которые они пытаются навесить на рекорды.
860.48 862.44 "Анатолий Кулаков" Мне кажется, это должно быть на всех объектах.
862.44 865.28 "Игорь Лабутин" Они не пытаются, на самом деле, это навесить только на рекорды, в том-то и дело.
865.28 867.72 "Игорь Лабутин" То есть, если почитать пропозал, они все в том числе про классы.
867.72 873.56 "Игорь Лабутин" То есть, например, primary constructors вообще это все про классы даже, на самом деле, в основном, в частности.
873.56 876.56 "Игорь Лабутин" Потому что в рекордах они уже есть.
876.56 888.60 "Игорь Лабутин" Так что там будет интересно, и они на самом деле сгруппировали все эти топики в три больших раздела, типа абсолютно новые фичи, расширение существующих фич и типа сторонние фичи, но которые просто полезные.
888.60 893.00 "Игорь Лабутин" И вот они как бы будут как-то с ними всеми индивидуально работать.
893.00 895.00 "Анатолий Кулаков" Ну, усиление системы типа это всегда прекрасно.
895.00 901.36 "Анатолий Кулаков" Это вот как раз движение в эту сторону, после того, как у нас появились reference types, которые победоносно так как бы шагают по планете.
901.36 904.88 "Анатолий Кулаков" Вот, хочется еще дальше, мощнее, больше и так далее.
904.88 905.88 "Игорь Лабутин" Да, дальше.
905.88 909.72 "Игорь Лабутин" Discriminated unions, по ним пока непонятно, что будет.
909.72 913.70 "Игорь Лабутин" То есть, никаких отдельных дискуссий с момента августа не было.
913.70 920.04 "Игорь Лабутин" То есть, это point, который как бы обсуждается, будет обсуждаться в C# 11, но когда, непонятно.
920.04 929.32 "Анатолий Кулаков" Ну, очень жалко, потому что фича, мне кажется, это самая такая крупная и большая фича, которая осталась украсть у F#, и тогда его уже можно будет окончательно, наверное, закапывать.
929.32 932.20 "Анатолий Кулаков" Вот, но надо в эту сторону двигаться.
932.20 933.20 "Игорь Лабутин" Дальше.
933.20 955.08 "Игорь Лабутин" Spans для params, то есть, когда мы именем params, да, сейчас мы обязаны указывать там object и массивчик object, они хотят это сделать через span, и там прям тоже большая дискуссия, по-моему, 4 варианта имплементации они предложили всякой разной, которые потребуют в том числе, возможно, работы runtime, возможно, работы в GT.
955.08 961.44 "Игорь Лабутин" Короче, казалось бы, простая штука, передай через span, передай через массив, но, блин, там работы прям много.
961.44 966.52 "Игорь Лабутин" Вот, надеюсь, что она будет сделана, и мы получим params с паны.
966.52 977.76 "Игорь Лабутин" И как они говорят, это на самом деле очень прикольная фича, потому что это будет первая фича на span, которые будут пользоваться обычные пользователи, не понимая, что они пользуются, вообще говоря, клевые фичи про span.
977.76 986.12 "Игорь Лабутин" Ну, потому что сейчас, если тебе нужно, ты хочешь работать со span, ты это практически всегда делаешь явно, ты там начинаешь с какого-нибудь string.span, да, и дальше погнали.
986.12 987.12 "Игорь Лабутин" Вот.
987.12 994.72 "Анатолий Кулаков" Ну, я надеюсь, что они ради обратной совместимости тоже не забретут там какое-нибудь новое слово для params, типа spanparams или что-нибудь в этом духе.
994.72 999.96 "Игорь Лабутин" Не, пока план оставить params, там именно больше про особенности реализации, то есть как это реализовать.
999.96 1009.80 "Игорь Лабутин" С точки зрения calling convention, то есть используем ли мы стэк, и кто его использует, кто его освобождает, как это вообще все выдается, ну, то есть как-то так.
1009.80 1011.36 "Игорь Лабутин" Чисто вопрос реализации.
1011.36 1040.92 "Игорь Лабутин" Дальше, следующая штука, они хотят сделать, ну, не то, что они хотят, есть proposal, называется statement as expressions, то есть можно будет, ну, грубо говоря, написать, не знаю, там int x присвоить, if что-нибудь, бла-бла-бла, else что-нибудь, бла-бла-бла, и в этих бла-бла-бла если последнее выражение внутри это что-то, именно выражение, которое возвращает int, то это будет валидная конструкция.
1040.92 1043.48 "Анатолий Кулаков" Да, тоже удобная вещь, было бы неплохо получить такую
1043.48 1057.68 "Игорь Лабутин" штуку. Ну, вот не знаю, насколько удобная, честно сказать, потому что уж больно она, ну, короче, она очень будет видимо близка, не знаю, как это будет выглядеть финально, но она очень близка по синтезису к лямбде, согласись.
1057.68 1065.28 "Игорь Лабутин" То есть от такого до int x, ну, ты не можешь написать int x, ну, хорошо, var x, да, это все меняет.
1065.28 1071.28 "Игорь Лабутин" Присвоить круглые скобочки, стрелочка, if что-нибудь, да, и это уже лямбда, с совершенно другим семантикой.
1071.28 1074.40 "Игорь Лабутин" Короче, не знаю пока, я пока не уверен.
1074.40 1077.56 "Игорь Лабутин" Надо смотреть, как это будет выглядеть.
1077.56 1092.12 "Игорь Лабутин" Дальше expression trees, казалось бы, что с expression, ну, там проблема просто в том, что expression trees давно не обновлялись, и они очень слабо сейчас поддерживают весь вот огромный набор features и sharp, который был добавлен.
1092.12 1096.60 "Игорь Лабутин" То есть через них можно это все выразить, но это получается очень некрасиво и нелегантно.
1096.60 1105.52 "Игорь Лабутин" Они собираются обновить, собственно, app и набор в expression trees, чтобы было проще работать в современном C#.
1105.52 1110.12 "Игорь Лабутин" Видимо, добавить каких-нибудь новых классиков, там, не знаю, операции, еще что-нибудь.
1110.12 1113.80 "Игорь Лабутин" Большая тема — это расширение системы типов.
1113.80 1120.00 "Игорь Лабутин" Там есть тоже огромное количество направлений, назовем это так.
1120.00 1123.92 "Игорь Лабутин" Одна большая тема, это называется roles and extensions, сейчас я про нее отдельно скажу.
1123.92 1133.00 "Игорь Лабутин" И есть, вот они сейчас, основная работа у них, я так понимаю, ведется вокруг унификации типов.
1133.00 1137.32 "Игорь Лабутин" Ну, то есть у нас, например, есть пара типов, там, например, task и дальше task t.
1137.32 1145.00 "Игорь Лабутин" Или у нас есть целое семейство функций, типов action, да, от одного аргумента, двух аргументов, трех аргументов, и так далее.
1145.00 1153.72 "Игорь Лабутин" Есть func, тоже от одного аргумента, двух, и они, по сути, отличаются только тем, что у func есть еще один тип, это, который типа возвращаемое значение.
1153.72 1162.00 "Игорь Лабутин" Так вот, команда думает о том, не сделала ли я некую унификацию и добавить некоторые, грубо говоря, типа void.
1162.00 1165.96 "Игорь Лабутин" То есть можно будет написать task от void, и это будет то же самое, что task.
1165.96 1169.40 "Игорь Лабутин" Или там, можно будет написать func от void, и это будет то же самое, что action.
1169.40 1174.56 "Игорь Лабутин" То есть такой типа, unit type, как они его называют.
1174.56 1179.52 "Игорь Лабутин" Пока рабочий пропозвал использует ключевое слово void для этого, ну оно логично.
1179.52 1181.52 "Игорь Лабутин" Но, посмотрим.
1181.52 1188.16 "Анатолий Кулаков" Нужно сказать, что такой тип, он изначально есть уже в f#, и вот, наверное, оттуда ноги растут.
1188.16 1197.48 "Анатолий Кулаков" То есть действительно, ты должен, это полезно, когда ты можешь указать, что твоя функция в данный момент, обычно она возвращает что-то, но в данный момент возвращает ничего.
1197.48 1215.16 "Игорь Лабутин" Я думаю, что это еще полезно для собственной BCL, да, Base Class Library, потому что это, по сути, возможность в два раза сократить количество методов, потому что любой метод, который принимает task, обязан принимать еще и task t, ну в смысле у него обычно делается пара, которая принимает task от t, ну если это как-то логично по смыслу.
1215.16 1216.16 "Анатолий Кулаков" А так можно.
1216.16 1237.52 "Анатолий Кулаков" У меня на практике приходилось в многих проектах делать свой такой тип, такой юнит, и, соответственно, его как-то уже передавать по pipeline, то есть в тот момент, когда у вас появляются какие-то сложные pipeline, сложная обработка, сложные handlers, вот вы постепенно приходите к тому, что вам нужен такой тип, иначе вам нужно будет очень много писать какого-то дублирующегося кода, который писать абсолютно бессмысленно.
1237.52 1238.52 "Игорь Лабутин" Ну вот посмотрим.
1238.52 1245.08 "Игорь Лабутин" Еще там есть какие-то рассуждения про pointer и abstract, но там пока все очень на ранней стадии и непонятно, что будет.
1245.08 1250.20 "Игорь Лабутин" А вот тема, которая тоже, кстати, по-моему, частично F# упоминается в ней, это литералы для коллекций.
1250.20 1256.72 "Игорь Лабутин" То есть у нас сейчас есть литералы для стровочек, чисел, понятное дело, но у нас нет литералов для коллекций.
1256.72 1262.88 "Игорь Лабутин" То есть можно написать фигурные скобочки через запятую элементы, но это называется collection initializer syntax.
1262.88 1267.88 "Игорь Лабутин" Он подразумевает, что он на самом деле заменяется компилятором на просто вызов .add.
1267.88 1278.52 "Игорь Лабутин" А хочется иметь именно литералы для коллекции, потому что это позволит написать инициализацию для всяких immutable типов.
1278.52 1283.72 "Игорь Лабутин" То есть сейчас мы не можем написать там immutable какой-нибудь там лист или immutable array, immutable листа не бывает.
1283.72 1289.28 "Игорь Лабутин" Immutable array там x от int до x присвоить и что?
1289.28 1298.32 "Игорь Лабутин" Фигурную скобку писать нельзя, потому что add на immutable вызывать можно, но смысла не имеет, потому что надо возвращаемое значение сохранять.
1298.32 1303.92 "Игорь Лабутин" Поэтому вот они думают над тем, чтобы сделать вариант какого-то такого литерала для списков.
1303.92 1319.36 "Анатолий Кулаков" Может они могли бы тогда старый синтезис просто поддержать для immutable структур, да и все, те же самые фигурные скобки, они уже прижились, их уже по-моему все привыкли и не мучаются, чтобы выбирать между тем, а квадратные писать скобки, или круглые, или треугольные.
1319.36 1324.76 "Игорь Лабутин" Нет, сейчас они склоняются к квадратным, потому что это тот же формат, который они используют в pattern matching для списков.
1324.76 1328.48 "Игорь Лабутин" Там как раз по сути литералы ты указываешь списков при pattern matching.
1328.48 1333.16 "Игорь Лабутин" То есть они как раз исходят из того, что это натурально будет именно в эту сторону.
1333.16 1337.28 "Игорь Лабутин" Что там литералы, ну и заодно и инициализация тоже через это будет.
1337.28 1341.60 "Анатолий Кулаков" Ну в общем звучит правильно, но опять же на практике что-то я мало с таким сталкивался, посмотрим.
1341.60 1344.16 "Игорь Лабутин" Ну да, тоже верно.
1344.16 1348.24 "Игорь Лабутин" Дальше и вот как раз-таки большая тема, это roles and extensions.
1348.24 1357.00 "Игорь Лабутин" Это переосмысление фичи, которая еще называется шейпами, можно ее назвать трейтами до некоторой степени.
1357.00 1362.20 "Игорь Лабутин" В этом design proposal есть ссылки на все другие, где она называется по-моему четырьмя разными способами.
1362.20 1369.48 "Игорь Лабутин" Короче сейчас есть два варианта, ну не два варианта, два по идее этапа этой фичи в данном случае.
1369.48 1379.60 "Игорь Лабутин" Этап первый, то есть это по сути возможность реализовывать интерфейс на классе, не меняя класс, грубо говоря.
1379.60 1382.52 "Игорь Лабутин" То есть добавлять функциональность в класс, не меняя сам класс.
1382.52 1383.88 "Игорь Лабутин" Похоже на extension методы?
1383.88 1401.92 "Игорь Лабутин" Ну типа того, но только extension метод не дает тебе возможность передать этот сторонний класс, то есть ты не можешь на стороннем классе написать, что он теперь у тебя реализует, не знаю там, my клевый интерфейс, какой-нибудь my serializable, передавать внутри своего кода, где хочется my serializable.
1401.92 1403.92 "Игорь Лабутин" Ну не можешь ты так сделать.
1403.92 1406.16 "Игорь Лабутин" Да, приходится делать какой-нибудь адаптер.
1406.16 1407.16 "Анатолий Кулаков" Именно.
1407.16 1417.08 "Игорь Лабутин" А здесь будет можно такое делать, но у них есть два этапа, которые они рассматривают, и они сейчас рассматривают первый этап, когда такое будет нельзя делать на классах, которые не ты сам писал.
1417.08 1420.44 "Игорь Лабутин" Ну то есть на бцельные классы такого делать будет нельзя.
1420.44 1422.16 "Игорь Лабутин" А на свои можно.
1422.16 1429.96 "Игорь Лабутин" И они говорят, что это вообще как бы потребует, либо вообще не потребует изменений в рантайме, либо потребует, но очень маленького.
1429.96 1436.32 "Игорь Лабутин" Ну то есть ты можешь такое делать, но на классах, которые из твоих же сборок, которые ты сам же и собираешь.
1436.32 1444.24 "Игорь Лабутин" Я не вчитывался, почему именно такое ограничение, и чем это как бы отличается, и почему я тогда не могу просто пойти и поменять свой же класс, собственно зачем такая фича тогда.
1444.24 1450.48 "Игорь Лабутин" Но вот они считают, что она все равно нужна, но тем не менее как бы сильно упростит жизнь.
1450.48 1456.52 "Игорь Лабутин" А вот потом, вторым этапом, можно будет сделать имплемент интерфейсов на любых классах.
1456.52 1461.04 "Игорь Лабутин" И это открывает прям огромное поле для возможностей, но и для проблем.
1461.04 1468.56 "Игорь Лабутин" Как они говорят, надо очень хорошо думать, и это потребует огромных изменений, скорее всего и рантайма, и джета, и чего только не потребует, и метод данных для сборок.
1468.56 1472.56 "Игорь Лабутин" Короче, они очень сильно размышляют, как бы это сделать ничего не сломав.
1472.56 1476.60 "Анатолий Кулаков" Особенно мне кажется, огромное поле открывает для анализаторов, типа ReSharper.
1476.60 1482.08 "Анатолий Кулаков" Теперь им нужно будет искать, а где же вот это чудо определено, почему именно такое применилось, и не применилось что-то
1482.08 1484.08 "Игорь Лабутин" другое. Да, это все так.
1484.08 1489.16 "Игорь Лабутин" Так что скорее всего, конечно, в полном виде эта фича никак не заедет, ни в какой одиннадцатый C#.
1489.16 1497.20 "Игорь Лабутин" Хорошо, если только они успеют сделать первую часть, и то, они не могут ее сделать просто так, а бы как, а потом начать думать о второй.
1497.20 1503.44 "Игорь Лабутин" Нужно сначала придумать, как все будет сделано целиком, чтобы, сделав первую, можно было к ней потом добавить вторую.
1503.44 1505.64 "Игорь Лабутин" И вот это прям большой челлендж для них.
1505.64 1511.64 "Анатолий Кулаков" Слушай, а есть уже какие-нибудь понятные сэмплы, где это вот точно, сто процентов необходимо и решает какую-то огромную боль?
1511.64 1515.48 "Анатолий Кулаков" Ну потому что передела кажется много, работы кажется много, а ради чего все это делается?
1515.48 1519.12 "Игорь Лабутин" Та самая generic математика, в первую очередь, как я понял.
1519.12 1535.44 "Игорь Лабутин" То есть сейчас у них крутится все вокруг вот этой generic математики, что ты можешь какой-нибудь сторонний класс, допустим, ты взял какую-нибудь клевую библиотеку, не знаю, интересной математики, но она не поддерживает вот это вот новые, не знаю, iedible, ты не можешь ее использовать в generic методах через плюсик.
1535.44 1537.72 "Игорь Лабутин" А вот ты взял, дописал, и ты молодец.
1537.72 1543.88 "Анатолий Кулаков" Ну, наверное, звучит хорошо, да, потому что как только появились extension методы, мы решили огромную кучу проблем с помощью extension методов.
1543.88 1550.36 "Анатолий Кулаков" Если у нас появится какой-то более мощный механизм, но с той же направленностью, наверное, мы и придумаем, куда его применить.
1550.36 1555.48 "Игорь Лабутин" Конечно, была бы это, был бы гвоздь, там его только найдется, да.
1555.48 1561.48 "Игорь Лабутин" Последняя штука — это литералы в UTF-8 кодировке.
1561.48 1575.84 "Игорь Лабутин" То есть, как сделать так, чтобы можно было прямо в коде писать UTF-8 литералы, они прямо сохранялись бы в виде UTF-8 строчек, а не UTF-16 строк, которые сейчас по дефолту тутнет использует внутри, двухбайтовые, где по 2 байта на символ.
1575.84 1577.84 "Игорь Лабутин" Там есть несколько вещей.
1577.84 1601.92 "Игорь Лабутин" Во-первых, они говорят, что это нужно для проектов, где у нас очень много строк в ресурсах, например, потому что, или даже не в ресурсах, а в коде именно, потому что это все будет сначала локетиться в нормальные дотнетные строки UTF-16, а потом конвертиться обычно в рантайме в UTF-8 строки, и это типа прям, ну зачем это, лишний расход памяти, при том, что UTF-16 строку мы после этого еще больше ни разу не используем, мы используем везде UTF-8.
1601.92 1608.44 "Игорь Лабутин" То есть, пропозал есть, над ним работают, так что, но пока еще именно над пропозлом, кода пока еще там не пишется.
1608.44 1621.16 "Игорь Лабутин" Вот, это то, что обсуждалось, начиная с августа, вокруг C# 11, в разных фитах, я пропустил многое, наверное, но основные фичи, мне кажется, я точно упомянул.
1621.16 1626.24 "Игорь Лабутин" И отдельно иногда полезно смотреть в Roslyn репозиторий.
1626.24 1642.56 "Игорь Лабутин" Из вот этого C# Plain репозиторий есть ссылочка на специальную страничку в Roslyn репозитории, где есть прям список фич языка, ну языка и, скажем так, компилятора, которые сейчас в том или ином виде либо in progress, либо планируются, либо уже сделаны.
1642.56 1649.24 "Игорь Лабутин" И вот там сейчас есть список тех фич, над которыми они работают уже прямо в репозитории, в отдельных бранчах пока еще.
1649.24 1668.60 "Игорь Лабутин" То есть, это не значит, что они будут вольются в финальный мастер, или даже в промежуточный какой-нибудь превью, но тем не менее, во-первых, мы уже обсуждали, они работают над расширением скоупа для конструкции nameof для параметров, то есть сейчас вы можете использовать nameof, да, все же писали какой-нибудь там argument null exception, да, от nameof от параметра.
1668.60 1680.40 "Игорь Лабутин" Так вот, с распространением nullability вам очень хотелось бы, наверное, использовать nameof от параметра во всяких not null, if not null и вот это все, а сейчас там нельзя их использовать, там вы должны писать литералы пока.
1680.40 1683.84 "Игорь Лабутин" Вот будет можно, когда доделают.
1683.84 1697.08 "Игорь Лабутин" Куча мелких вещей типа, ну вот generic attributes пока еще живут в отдельном бранче, до доделки, list patterns живут, немножко хотят ослабить, так сказать, требования по ref, partial и вот этим всем.
1697.08 1709.68 "Игорь Лабутин" У нас теперь может быть огромное количество модификаторов, и не всегда нужно, можно будет помнить вообще в каком порядке их нужно указать, поэтому они там работают над тем, чтобы можно было чуть в более произвольном порядке указывать.
1709.68 1711.68 "Игорь Лабутин" Интересный proposal про параметр null checking.
1711.68 1746.04 "Игорь Лабутин" Сейчас вы знаете, что нужно проверить параметр на null, ну там есть несколько вариантов, либо через if, да, и потом throw an argument, throw argument null exception, либо через null, как он красиво называется, null coalescing, короче через два вопросика, но можно будет сделать еще круче, можно будет прямо в сигнатуре метода написать что-нибудь там, метод do something, потом там object x и два восклицательных знака после имени переменной, имени параметра, и это будет автоматически добавлять на аргумент null проверку начала метода.
1746.04 1748.44 "Игорь Лабутин" Два восклицательных знака мне уже нравятся.
1748.44 1768.64 "Игорь Лабутин" Так, что еще интересного, идет работа над raw string literals, то есть у нас сейчас есть уже литеральные строки через собачку перед кавычкой, а можно будет начинать строку с трех кавычек, ну или там сказано минимум трех, количество не ограничено, хотите хоть 20 кавычек подряд, дальше соответственно сколько угодно строк текста
1768.64 1775.04 None и потом еще три кавычки или сколько бы там указали в самом начале, ну соответственно многострочные прям литералы там, будет круто.
1775.04 1778.72 "Игорь Лабутин" Так а в чем отличие от собачки-то?
1778.72 1790.40 "Игорь Лабутин" Потому что собачка там как-то не совсем правильно использует, короче, собачка не совсем корректно обрабатывает то ли переносы строк, то ли что-то.
1790.40 1809.44 "Игорь Лабутин" А здесь прям будет меньше экранирования, больше экранирования, короче, надо почитать, там есть прям детальное описание этого пропозла, я не вчитывался, потому что дальше это еще, там народ пошел спрашивать, будет ли это дружить с string interpolation, можно ли будет написать доллар, три кавычки, и дальше туда еще повставлять эти replacement.
1809.44 1820.84 "Игорь Лабутин" Короче, ну не читал прям пропозл, зачем это надо, потому что действительно вроде как через собачку есть и она поддерживает, насколько я помню, многострочные
1820.84 1831.40 "Анатолий Кулаков" строки, да ведь? Да, да, безусловно, собачка поддерживает многострочные строки, поддерживает string interpolation и много чего еще, поэтому странно иметь, знаешь, два синтексиса для по сути примерно одного и того же, вот хотелось бы их четко разводить.
1831.40 1833.56 "Игорь Лабутин" Ну вот надо почитать тогда, что там происходит.
1833.56 1834.56 "Игорь Лабутин" Все не успевал.
1834.56 1837.24 "Анатолий Кулаков" Я думаю, еще в будущем рассмотрим, как бы не последний день.
1837.24 1842.72 "Игорь Лабутин" Да, ну про всякие фичи там по полу-автопроперти, все это работа ведется, да.
1842.72 1849.32 "Игорь Лабутин" А, и вот последнее, интересно, это разрешить те самые переносы строк внутри interpolation strings.
1849.32 1867.12 "Игорь Лабутин" Это, короче, вот про что, если у вас внутри, когда вы пишете interpolated строчку и у вас внутри фигурных скобок есть выражение на C#, то сейчас вы в нем не имеете права переносить строки, то есть если вы внутри фигурных скобок внутри строки написали что-то очень длинное и развесистое, то это все обязано быть в одну строку.
1867.12 1868.80 "Игорь Лабутин" Вот сделать так, что можно будет.
1868.80 1874.44 "Игорь Лабутин" И это будет, ну это не будет считаться естественно переносом, это будет все целиком заменяться на результат выражения.
1874.44 1877.48 "Анатолий Кулаков" Ну, таким образом тогда, соответственно, можно будет писать темплейты.
1877.48 1884.32 "Анатолий Кулаков" Ты задал где-то вверху открытие строчки, внутри пишешь какой-то произвольный код абсолютно любой и внизу закрыл строчку.
1884.32 1887.68 "Анатолий Кулаков" И вот у тебя получился темплейт с произвольной бизнес-логикой внутри.
1887.68 1888.68 "Игорь Лабутин" Типа того.
1888.68 1889.68 "Игорь Лабутин" Да.
1889.68 1890.68 "Игорь Лабутин" На весь файл, при чем так?
1890.68 1891.68 "Игорь Лабутин" Да, да, да.
1891.68 1892.68 "Игорь Лабутин" На весь файл.
1892.68 1909.68 "Игорь Лабутин" Ну в общем вот, что нас ждет, не ждет, непонятно, как это все будет в 11 C#, но посмотрим, куда все подвинется, будем периодически туда заглядывать, смотреть какие новости, что появляется в превью, как только начнет появляться .NET 7 превью, мы будем естественно встречать какие-то новиночки в C# языка.
1909.68 1921.48 "Анатолий Кулаков" Ну интересно, да, потому что все-таки 10 .NET нас не побаловал какими-то крутыми фичами, то есть не .NET, а 10 C# нас не побаловал чем-то интересным в плане языка, чем-то конструктивным и чем-то фундаментальным.
1921.48 1934.96 "Анатолий Кулаков" Вот, я все-таки надеялся, что они там что-то в бэкграунде пилят и уже в 11 как выдадут, как выдадут, а тут что-то кажется, что над всеми большими фичами они все еще до сих пор как-то сомневаются, и что они будут выдавать как какой-то бигдил, пока не ясно.
1934.96 1944.00 "Игорь Лабутин" Ну вряд ли они смогли бы это пообещать, знаешь, это в августе еще до релиза 10 C#, раз так и сказать, а через год мы вам выкатим дискриминитед юнионс или там еще что-нибудь.
1944.00 1947.44 "Игорь Лабутин" Что успеют попрототипировать, то и выкатят.
1947.44 1953.96 "Анатолий Кулаков" Ну ладно, пожелаем команде удачи, пусть стараются, мы их все любим, поддерживаем, пусть делают нам много интересных крутых фич.
1953.96 1954.96 "Анатолий Кулаков" Пойдем дальше?
1954.96 1955.96 "Анатолий Кулаков" Давай.
1955.96 1972.72 "Анатолий Кулаков" Я бы хотел поговорить про мониторинг, потому что мне кажется, что это очень важная тема и она довольно новая, особенно в дотнете, многие люди к ней не привыкли, многие разработчики как бы еще не научились смотреть на свое приложение со стороны и каким-то образом пытаться анализировать его поведение.
1972.72 1983.68 "Анатолий Кулаков" Вот, а это важно, это нужно, поэтому давайте будем больше говорить про мониторинг, про метрики и про прочие вещи вокруг наших приложений, а не только про код внутри.
1983.68 1999.48 "Анатолий Кулаков" И безусловно, почему сейчас именно дотнет разработчикам стоит об этом начинать говорить, потому что OpenTelemetry зарядилась первая версия, дотнет ее прекрасно поддерживает и внедряет, наверное, первее всех языков в мире, поддержку этого протокола.
1999.48 2025.52 "Анатолий Кулаков" Прежде всего, что же такое OpenTelemetry, напомню кратко, что это набор API, SDK, тулинга, интерфейсов, интеграций и прочего всего другого, то что помогает вам и приложениям вокруг, которые интегрируются с вашим кодом, помогает как-то отслеживать то, чем занимается ваше приложение, отслеживать его здоровье, смотреть, чем оно занимается и собирать прочую телеметрию.
2025.52 2030.40 "Анатолий Кулаков" Вот это все объединили под неким названием OpenTelemetry.
2030.40 2033.44 "Анатолий Кулаков" Почему это может быть хорошо для вашего приложения?
2033.44 2053.76 "Анатолий Кулаков" Прежде всего, потому что эта система, этот протокол, эти технологии, они никак не завязаны ни на каком вендоре, то есть вы не завязываетесь ни на какое-то конкретное облако, ни какие-то контейнеры, ни какой-то провайдер, ни какую-то систему оповещений, это все абстракция, которая позволяет вам все это разделить.
2053.76 2062.94 "Анатолий Кулаков" Вы пишете свое приложение универсально с поддержкой OpenTelemetry, а все остальные вендоры уже подстраиваются непосредственно под этот протокол, что безусловно прекрасно.
2062.94 2071.12 "Анатолий Кулаков" Сейчас OpenTelemetry объединяет под собой три главных кита, это трейсы, метрики и локирование.
2071.12 2079.80 "Анатолий Кулаков" Прелесть того, что они каким-то образом объединены, заключается в том, что сквозной нитью через I всех проходит TraceID и SpanID.
2079.80 2098.08 "Анатолий Кулаков" Это такие штуки, которые позволяют вам, например, заглянуть в распределенную трассировку, найти там какой-то всплеск по CPU, который был залогирован с помощью метрик, перейти на конкретные логи, которые вызвали этот всплеск в CPU на конкретный момент времени и посмотреть, что же у вас в этом приложении происходило.
2098.08 2106.32 "Анатолий Кулаков" То есть объединить все вот эти метрики, все вот эти артефакты, объединить неким понятным одним идентификатором.
2106.32 2109.76 "Анатолий Кулаков" И можно, соответственно, между ними всем бегать.
2109.76 2119.88 "Анатолий Кулаков" И таким образом переключаться и диагностировать проблемы намного быстрее, особенно в сфере распределенных микросервисных приложений, и намного легче и понятнее.
2119.88 2139.20 "Анатолий Кулаков" И благодаря тому, что вы можете передавать некую информацию не только внутри своего приложения, но и между разными приложениями с помощью V3C специального контекста, вы, соответственно, можете строить трассировки между различными приложениями, между различными языками.
2139.20 2147.68 "Анатолий Кулаков" И уже сейчас очень много инструментов в настоящий момент поддерживают OpenTelemetry, особенно если мы говорим про .NET.
2147.68 2156.44 "Анатолий Кулаков" В .NET у нас уже есть Namespaces, System Diagnostics и Microsoft Extension Login, Login to Abstractions.
2156.44 2163.60 "Анатолий Кулаков" Вот, если вы используете уже или какие-то ваши инструменты уже используют эти Namespaces, значит вы уже поддерживаете OpenTelemetry, явно или не явно.
2163.60 2167.84 "Анатолий Кулаков" И большинство, соответственно, .NET инструментов уже это делают.
2167.84 2179.04 "Анатолий Кулаков" Например, HTTP Client, ISP NetCore, SQL Server, Redis Client, JLPC Client, AWS Client, Elastic Search Client и многие другие клиенты, они уже прозрачны для вас.
2179.04 2183.24 "Анатолий Кулаков" Все необходимые диагностические информации добавляют и инструментируют.
2183.24 2207.40 "Анатолий Кулаков" Соответственно, как только ваше приложение сходит, например, к SQL Server или обратится по HTTP в какому-нибудь другому сервису, поддерживающему OpenTracing и OpenTelemetry и даже написанное в абсолютно другом языке, все это вы сможете увидеть в каком-нибудь одном глобальном окне и проанализировать единым способом, что, безусловно, приятно и полезно.
2207.40 2215.72 "Анатолий Кулаков" Для того, чтобы проинструментировать ваше приложение, нужны элементарные вещи, особенно если мы говорим о .NET, там уже практически обо всем перезабытался Microsoft.
2215.72 2229.08 "Анатолий Кулаков" Если вы используете Logging Abstractions, то есть новый универсальный интерфейс для логирования от компании Microsoft, то уже у вас есть поддержка OpenTelemetry в логировании.
2229.08 2238.88 "Анатолий Кулаков" Там вам нужно использовать структурное логирование для того, чтобы лучше и удобнее выбирать те логи с теми параметрами, которые вы недавно записали.
2238.88 2245.04 "Анатолий Кулаков" Что касается трассировки, это тоже уже практически везде встроено, на всех основных endpoint.
2245.04 2256.88 "Анатолий Кулаков" Единственное, что нужно помнить насчет трассировки, это то, что терминология Microsoft отличается от OpenTelemetry, то есть здесь вы не увидите каких-то трейсов и прочего.
2256.88 2265.20 "Анатолий Кулаков" Это все будет называться Activity Source, Activity Tags, багажи и вот эти прочие вещи.
2265.20 2270.36 "Анатолий Кулаков" Метрики – это один из самых свежих и интересных релизов.
2270.36 2281.64 "Анатолий Кулаков" Как раз OpenTelemetry Metrics, они поддержались буквально вот в свежем .NET 6 и привнесли как раз много всего интересного и много всего полезного.
2281.64 2287.72 "Анатолий Кулаков" Интересно в метриках то, что они интегрированы непосредственно в .NET Runtime, в отличие от предыдущих собратьев.
2287.72 2294.88 "Анатолий Кулаков" И поэтому .NET Runtime сообщает и репортит вам кучу разной информации, которую точно так же можно считывать.
2294.88 2298.56 "Анатолий Кулаков" Сейчас у нас в фреймворке есть четыре основных типа.
2298.56 2310.56 "Анатолий Кулаков" Прежде всего это Counter, это монотонно возрастающий счетчик, который, например, можно использовать в приложении для того, чтобы обозначать количество реквестов, которые поступили к вам в приложение и прочие такие монотонно возрастающие вещи.
2310.56 2316.16 "Анатолий Кулаков" Observable Counter – это практически то же самое, единственное его исключение, то, что он асинхронный.
2316.16 2317.16 "Анатолий Кулаков" Гистограмма.
2317.16 2327.68 "Анатолий Кулаков" В основном используется для всяких статистических значений, вроде времени длительности реквеста, разных Summaries, персентилей и вот таких прочих изменений.
2327.68 2331.32 "Анатолий Кулаков" И четвертое – это Observable Gauge.
2331.32 2335.60 "Анатолий Кулаков" Это специальный счетчик для неаддитивных значений.
2335.60 2343.40 "Анатолий Кулаков" То есть, если вы пишете, например, количество сейчас запущенных в настоящий момент тасков или количество трейдов в приложении.
2343.40 2345.64 "Анатолий Кулаков" То есть это такой счетчик, который гуляет туда-сюда.
2345.64 2348.24 "Анатолий Кулаков" И соответственно теги тоже поддерживаются.
2348.24 2358.92 "Анатолий Кулаков" Можно все эти метрики обогащать каким-то контекстом, например, на каком хосте это запустилось, с каким параметром пришел URL и прочие вот такие полезные метаинформации тоже поддерживаются.
2358.92 2370.78 "Анатолий Кулаков" Для того, чтобы заэкспортировать все вот эти данные, трейсы, логи, метрики в какой-то сторонний агрегатор, который будет их хранить и визуализировать, существует два основных подхода.
2370.78 2374.76 "Анатолий Кулаков" Во-первых, это использовать инструмент, который называется Open Telemetry Collector.
2374.76 2386.04 "Анатолий Кулаков" Это специальная штука, которая написана для того, чтобы собирать метрики и прочие вещи из вашего приложения и непосредственно передавать их в какой-то целевой сторидж.
2386.04 2394.00 "Анатолий Кулаков" В Zipkin, в Jaeger, в Prometheus и куда угодно еще, что любой хранилищик, который поддерживает Open Telemetry.
2394.00 2399.00 "Анатолий Кулаков" И второй вариант - это непосредственно из вашего приложения брать и писать напрямую.
2399.00 2406.56 "Анатолий Кулаков" Вот как вы пишете в базу данных, например, вы можете также напрямую писать в той же самой Zipkin, в Prometheus, в Jaeger и везде-везде записываться.
2406.56 2411.20 "Анатолий Кулаков" Естественно, рекомендуемый способ - это все-таки использовать промежуточный слой, использовать коллектор.
2411.20 2413.40 "Анатолий Кулаков" Чему это может быть полезно?
2413.40 2418.56 "Анатолий Кулаков" Во-первых, вы абстрагируетесь от того, на каком языке и с какими технологиями пишется ваш бэкэнд.
2418.56 2422.72 "Анатолий Кулаков" Вам не нужно искать конкретные библиотеки для того, чтобы писать в конкретную базу данных.
2422.72 2432.24 "Анатолий Кулаков" Вы просто поддерживаете стандартный протокол Open Telemetry, а он продержан практически везде, и дальше коллектор уже сам с любого приложения собирает эти данные, что безусловно полезно.
2432.24 2445.52 "Анатолий Кулаков" Во-вторых, это какая-то определенная консистентность для того, чтобы все данные можно было складывать в один понятный протокол и ожидать от него каких-то одних и тех же понятных вещей.
2445.52 2451.28 "Анатолий Кулаков" Во-вторых, это, в-третьих уже получается, это некая упрощенность в интеграции.
2451.28 2457.24 "Анатолий Кулаков" Вам не нужно писать конкретного клиента под конкретную базу данных, искать его, поддерживать, версионировать и так далее.
2457.24 2463.68 "Анатолий Кулаков" Вы просто все экспортируете в абстрактный протокол, и дальше со всем этим уже все остальное разбирается.
2463.68 2466.96 "Анатолий Кулаков" Еще один плюс коллектора в том, что он поддерживает сложные процессоры.
2466.96 2472.52 "Анатолий Кулаков" Например, вы можете организовать батчинг для того, чтобы передавать на сервер не по одной записи, а какими-то целыми кусками.
2472.52 2491.76 "Анатолий Кулаков" Сэмплинг, вы можете фильтринг сделать, то есть отфильтровать какие-то значения, захешировать какие-нибудь секьюрные данные, например, пароли, имена пользователя и много прочих каких-нибудь таких преобразований провести, опять же общих для всех ваших приложений, независимо нет языка, отстег, от версии, ничего.
2491.76 2495.44 "Анатолий Кулаков" Это будет у вас в одном понятном удобном месте, настраиваем и конфигурируем.
2495.44 2510.40 "Анатолий Кулаков" Ну и если вы вдруг захотите ручками это все экспортировать и писать в каждую конкретную базу, то существует целая серия пакетов, которые объединены под названием OpenTelemetry Exporters, и там вы можете найти их кучу-кучу всего.
2510.40 2517.44 "Анатолий Кулаков" Итак, давайте же посмотрим, что нужно сделать для того, чтобы ваше приложение поддержать различные OpenTelemetry.
2517.44 2525.44 "Анатолий Кулаков" Во-первых, вам нужно сконфигурировать ваше приложение для того, чтобы оно начало эти счетчики собирать и начало их наружу выставлять.
2525.44 2531.72 "Анатолий Кулаков" Во-первых, вам нужно разрешить OpenTelemetry, во-вторых, сконфигурировать и добавить некие лиссенеры.
2531.72 2536.80 "Анатолий Кулаков" Это все делается в Application Builder и в настройках сервисов.
2536.80 2547.40 "Анатолий Кулаков" То есть вам банально нужно в ваш iService Collection добавить специальные методы, которые называются @OpenTelemetryMetrics, @OpenTelemetryTracing и в логин @OpenTelemetryTracing.
2547.40 2555.84 "Анатолий Кулаков" Вот, в принципе, все-таки буквально три строчки и ваше приложение уже пошло собирать и раздавать телеметрию.
2555.84 2565.08 "Анатолий Кулаков" Напомню, что для нескольких сервисов вам нужно будет еще заботиться о неком межсервисном TraceID, который будет их всех объединять.
2565.08 2581.60 "Анатолий Кулаков" Сейчас поддерживаются протоколы общения как REST, так и gRPC, то есть Correlation ID, это вы непосредственно можете передавать между ними и ничего специального такого вам писать не нужно, главное использовать уже понятные фреймворки на обоих сторонах.
2581.60 2591.44 "Анатолий Кулаков" Со стороны клиента вам нужно ждать API Client, который точно так же прозрачно принимает и передает все необходимые Correlation ID дальше по стеку.
2591.44 2600.00 "Анатолий Кулаков" Если у вас там дальше на стеке кто-нибудь, кто поддерживает @OpenTelemetry, то, соответственно, все пойдет как под накатами.
2600.00 2625.72 "Игорь Лабутин" Ну а если вы вдруг используете какие-то библиотеки, например, не знаю, очередь сообщений или еще что-нибудь, которые не поддерживают липов, вам как-то нужно коррелировать ваши сервисы, допустим, обработки одного и того же сообщения, точнее коррелировать сервис, который положил сообщение и сервис, который его обработал, вам придется этот самый Correlation ID ручками таскать внутри сообщения.
2625.72 2645.72 "Анатолий Кулаков" Действительно, ну и хорошая новость в том, что Microsoft позаботился, чтобы это можно было сделать максимально удобно, то есть у нас есть разные вспомогательные утилитки, которые помогают вам не только Correlation ID протащить, но и дополнительную мета-информацию, такие как теги, багажи, все это сделать, проставить в нужном месте и доступиться там практически с любого места.
2645.72 2658.04 "Анатолий Кулаков" Например, вы можете в ISP.NET Core вызвать специальную фичу, которая называется HTTP Activity Feature и настроить ее так, как удобно вам, записать дополнительную информацию или, может быть, сделать вложенные скоупы или что-то еще.
2658.04 2667.48 "Анатолий Кулаков" В общем, в этом плане тоже все довольно гибко, настраивается под каждое конкретное приложение и, я думаю, покроет абсолютно любые надобности, которые могут возникнуть в вашем приложении.
2667.48 2680.08 "Игорь Лабутин" Ну, в общем, действительно здорово, мы прям OpenTelemetry не пользуемся, но мы пользуемся всем этим, Microsoft-овской радостью про корреляцию, возможность переноса контекста к контексту и так далее, и оно действительно неплохо работает.
2680.08 2684.08 "Игорь Лабутин" И хорошо интегрировано, например, в ажурные штуки, которыми мы пользуемся довольно активно.
2684.08 2691.04 "Игорь Лабутин" И в логах в итоге, конечно, очень приятно смотреть и диаграмму вызовов, кто кого как вызывал, сколько это длилось по спанам.
2691.04 2694.52 "Игорь Лабутин" Ну и логи, соответственно, тоже связаны.
2694.52 2695.52 "Игорь Лабутин" Пойдем дальше.
2695.52 2703.04 "Игорь Лабутин" Дальше тема вообще интересная, которую я не ожидал, что я буду рассказывать в конце 21 года, но тем не менее я это делаю.
2703.04 2707.24 "Игорь Лабутин" Update.net Framework 4.8, кто бы мог подумать.
2707.24 2710.32 "Анатолий Кулаков" Где-то же последний уже, все, что там, что-то .9 выпустили?
2710.32 2726.92 "Игорь Лабутин" Не, он все еще 4.8, более того, это не вошло прямо во Framework, это отдельный патчик, который нужно ставить, и иметь там стандартный Microsoft номер, KB и дальше много цифр, причем он не входит через Windows Update, то есть его нужно руками прям качать с сайта и обязательно руками ставить.
2726.92 2729.36 "Игорь Лабутин" Но тем не менее, о чем речь?
2729.36 2735.20 "Игорь Лабутин" В 6.00.net было сделано довольно много изменений, которые улучшили поддержку винтовых контейнеров.
2735.20 2752.20 "Игорь Лабутин" То есть, во-первых, добавили возможность сделать ограничения на CPU и на память, дальше немножко потюнили garbage коллектор, чтобы он поменьше аллоцировал кучи, потому что, ну память это меньше, да, в контейнере, и она может закончиться быстрее.
2752.20 2766.12 "Игорь Лабутин" Дальше сделали возможность руками указывать значение переменной environment.processorcount, что может быть важно в случае, когда у вас очень много контейнеров крутится на одной машинке, чтобы каждому их очень сильно ограничить.
2766.12 2781.64 "Игорь Лабутин" И в 6.00.net завезли такую штуку, как process isolated container support, то есть изоляцию контейнеров не средствами Hyper-V, да, виртуальных машин, а изоляцию средствами, я так понимаю, Windows-джобов, чтобы процессы друг друга не видели.
2781.64 2804.12 "Игорь Лабутин" Так вот, это все было здорово, и это все было нужно, ну во-первых, просто потому что так винтовые контейнеры запускаются приятнее, ими используют меньше ресурсов, потому что Hyper-V все-таки побольше требуется в себя, а во-вторых, это было нужно для ажуров, понятное дело, Azure Kubernetes Service с ними, он как раз работает через process isolation, и это позволило запускать винтовые контейнеры под ним.
2804.12 2823.88 "Игорь Лабутин" Так вот, все эти изменения были бэкпортнуты в .NET 4.8, они доступны в виде патча, когда-нибудь они заедут в какой-нибудь очередной апдейт именно фреймворка 4.8, в смысле, что сейчас если вы скачаете фреймворк 4.8, их там не будет, нужно поставить патчик, но рано или поздно они его обновят, не обещаю, когда.
2823.88 2840.24 "Игорь Лабутин" Если вы, соответственно, контролируете как-то там в ГЦ или что-то с помощью переменных окружений, и вы знаете какие-нибудь хитрые переменные окружения, которые начинаются с .NET подчеркивания, то для 4.8 нужно использовать старые варианты, которые начинаются с COM+ подчеркивания.
2840.24 2844.16 "Игорь Лабутин" Тут они решили пока не менять и оставить старые переменные окружения.
2844.16 2863.92 "Игорь Лабутин" Ну вот, как-то так, так что если вы используете контейнеры винтовые и пишете все еще на .NET фреймворке, посмотрите на это дело, поставьте себе эти патчики, и скорее всего вы получите какие-то явно новые прикольные фичи, которых вы из… потому что просто сайты наладят в контейнеры и реально вы должны потреблять поменьше ресурсов.
2863.92 2875.00 "Анатолий Кулаков" Видимо действительно много кастомеров использует эту штуку, раз Микрософт заморочился, в принципе такой, наверное, нехилый патч, backport null на фреймворк, которым уже осталось там жить, совсем недолго.
2875.00 2880.92 "Игорь Лабутин" Ну как совсем недолго, как известно, .NET фреймворк живет столько же, сколько живет официальная винда, под которой он был выпущен.
2880.92 2891.92 "Игорь Лабутин" 4.8 был выпущен под какой-нибудь, во-первых, десяткой, во-вторых, серверной виндой, на серверной винду у Микрософта обычно там лет каких-нибудь 5-10 минимум, сервис период, поэтому столько будет жить точно.
2891.92 2897.40 "Анатолий Кулаков" Ну за этим временем за Микрософтом не встанет, я думаю, скоро он выпустит еще пару виндов.
2897.40 2901.32 "Игорь Лабутин" Так, а это не важно, старые-то при этом они не снимают в поддержке.
2901.32 2904.00 "Анатолий Кулаков" Ладно, 5 лет это немного, опять же, что будем заморачиваться
2904.00 2912.24 "Игорь Лабутин" еще. Ну, действительно, ну кастомеры видимо хотят, больше народ придет в ажур, будет прикольнее, больше денег Микрософту.
2912.24 2915.28 "Игорь Лабутин" Ладно, пошли дальше, обратно к современности.
2915.28 2928.28 "Анатолий Кулаков" Так, нас догоняют все еще прошлые релизы, до релиз .NET 6, как мы уже упоминали в прошлом выпуске, вышло огромное число других каких-то новых инструментов, каких-то библиотек, еще чего-то.
2928.28 2931.96 "Анатолий Кулаков" Вот, и соответственно, мы немножко, потихоньку начинаем вот этот пул разгребать.
2931.96 2937.76 "Анатолий Кулаков" И один из самых интересных релизов, который вышел на новом фреймворке, это YARP 1.0.
2937.76 2939.72 "Анатолий Кулаков" Он, наконец-то, зарелизился.
2939.72 2941.40 "Анатолий Кулаков" Что это такое?
2941.40 2945.24 "Анатолий Кулаков" Прежде всего YARP, это расшифровывается как Yeti Navi Reverse Proxy.
2945.24 2947.24 "Анатолий Кулаков" Ну, то есть, это реверс прокси.
2947.24 2958.68 "Анатолий Кулаков" И отличается оно от других тем, что он очень кастомизированный, и очень гибкий, и очень крутой, и построен прежде всего на .NET технологиях, на .NET стеке.
2958.68 2974.36 "Анатолий Кулаков" Самое главное отличие от всех других реверс прокси, а мы говорим сейчас про такие имена, как Nginx, Haproxy, Convoy, вот, он от них отличается тем, что это не какой-то готовый же инструмент, который вы можете себе поставить на сервер и радоваться.
2974.36 2976.12 "Анатолий Кулаков" Это набор библиотек.
2976.12 2978.76 "Анатолий Кулаков" Это набор библиотек самплов и документации.
2978.76 2985.48 "Анатолий Кулаков" То есть, из которых вы можете собрать, как из кубиков, то, что нужно именно вам под ваши специфичные сценарии.
2985.48 2987.76 "Анатолий Кулаков" Именно под ваше приложение то, что нужно.
2987.76 2991.88 "Анатолий Кулаков" Мне это сильно напоминает подход, который использовался в Identity Server.
2991.88 2999.28 "Анатолий Кулаков" То есть, вместо того, чтобы поставить какой-то готовый продукт, там есть куча полезных библиотек, из которых вы можете собрать то, что нужно именно вам.
2999.28 3004.24 "Анатолий Кулаков" И кажется, что это понятный путь и понятное конкурентное преимущество.
3004.24 3009.32 "Анатолий Кулаков" Вообще, мало кто так делает, и те, кто делают, мне кажется, добиваются хороших успехов.
3009.32 3011.96 "Анатолий Кулаков" В общем, Microsoft пошел по такому пути.
3011.96 3014.48 "Анатолий Кулаков" Давайте для начала обсудим, что такое реверс прокси.
3014.48 3022.12 "Анатолий Кулаков" Потому что мне кажется, что в нашем подкасте мы никогда это слово не обсуждали, никогда такую терминологию не вводили, поэтому, безусловно, будет полезно.
3022.12 3023.12 "Анатолий Кулаков" Давайте вместе учиться.
3023.12 3029.64 "Анатолий Кулаков" Итак, реверс прокси - это специальное программное обеспечение, которое слушает входящие HTTP-реквесты.
3029.64 3038.36 "Анатолий Кулаков" После того, как оно их услышало, оно может перенаправить эти реквесты на ваши какие-то внутренние сервера, внутренние приложения.
3038.36 3044.52 "Анатолий Кулаков" И куда это перенаправить - зависит от того контекста, который к ним пришел.
3044.52 3054.36 "Анатолий Кулаков" Реверс прокси, в данном случае YARP, он работает на седьмом уровне, то есть на Application Layer, поэтому у него есть доступ ко всем HTTP-полям.
3054.36 3060.96 "Анатолий Кулаков" Он знает про HTTP-протокол, он знает про хедеры, про урлы, про query, про body и прочие такие вещи.
3060.96 3067.24 "Анатолий Кулаков" И на основании вот этого всего может вам рассказать, а куда же дальше перенаправлять ваш запрос.
3067.24 3074.44 "Анатолий Кулаков" Прежде всего, такой подход имеет несколько больших плюсов и мест, где его можно использовать.
3074.44 3083.60 "Анатолий Кулаков" Во-первых, публичные урлы, они не зависят от того, какие урлы по-настоящему выставляет ваше приложение во вашей внутренней сети.
3083.60 3096.80 "Анатолий Кулаков" То есть у вас там, допустим, есть целый мэш каких-то микросервисов, у них могут быть какие-нибудь страшные, непонятные длинные урлы, но все это пользователи вы хотите выставить в виде красивого, модного, коротенького API.
3096.80 3098.48 "Анатолий Кулаков" Вот реверс прокси как раз это и делает.
3098.48 3111.60 "Анатолий Кулаков" Он вам выставляет красивый API, после того, как запрос приходит на красивый API, он понимает по своей таблице маппинга, куда его нужно перенаправить, как его правильно нужно переписать и отправляет на вашу внутреннюю сеть.
3111.60 3116.76 "Анатолий Кулаков" Он задает какие-то вопросы, какие-то ответы и отвечает, соответственно, клиенту, который к нему пришел.
3116.76 3118.52 "Анатолий Кулаков" Вот это его основная задача.
3118.52 3121.48 "Анатолий Кулаков" Также он может заниматься лодбалансингом.
3121.48 3145.48 "Анатолий Кулаков" Неудивительно, если у вас одна точка, куда ломятся все клиенты, а за ней стоят огромная куча микросервисов, логично повесить на эту точку распределение трафика, чтобы он не каждому вашему микросервису запросы гонял, а поднял их какой-то кластер из 10 одинаковых микросервисов и по одному раскидывал, и при этом вы можете уменьшать нагрузку или еще делать какие-нибудь хитрые манипуляции.
3145.48 3151.68 "Анатолий Кулаков" Также Reverse Proxy может снимать нагрузку, общую нагрузку с различных микросервисов.
3151.68 3164.96 "Анатолий Кулаков" Например, делать TLS шифрование, делать аудентификацию и авторизацию, делать компрессию, сделать кэширование и прочие такие вещи, которыми загоняются каждое приложение.
3164.96 3170.68 "Анатолий Кулаков" Каждое приложение должно задумываться, нужно ли ему кэшировать, нужно ему компрессию включать, где брать роли пользователей.
3170.68 3181.00 "Анатолий Кулаков" Можно это все свалить просто на Reverse Proxy и он этим будет полностью заниматься, а вы будете уже крепать непосредственно бизнес-логику в ваших приложениях и будете счастливы.
3181.00 3184.00 "Анатолий Кулаков" Вот примерно такими штуками занимается Reverse Proxy.
3184.00 3185.60 "Анатолий Кулаков" Но у нас же есть Nginx.
3185.60 3191.92 "Анатолий Кулаков" Да, у нас есть Nginx, но опять же у него это готовый инструмент, ты его не можешь так гибко настраивать под свои нужды.
3191.92 3199.04 "Анатолий Кулаков" Во-вторых, самое большое, даже во-первых я бы сказал, самое большое недостаток Nginx, он не написан на дотнете.
3199.04 3207.80 "Анатолий Кулаков" Вот, как мы знаем, дотнет круче всех, он убьет всех на бичмарках, он быстрее всех и должен рвать Nginx как тузик грелку.
3207.80 3210.64 "Анатолий Кулаков" Поэтому все-таки все должно быть в мире написано на дотнете.
3210.64 3225.72 "Анатолий Кулаков" Ну и опять же Nginx, это не знаю, если вам нравится писать скрипты, обновления, темплейтов с помощью Lua, который пишет на какие-то файлы, которые Nginx перечитывает для того, чтобы новый контейнер у себя зарегистрировать, то это какой-то лютый ад.
3225.72 3232.88 "Анатолий Кулаков" В общем, в 21 веке люди не должны так делать и как раз YARP вам помогает такими глупостями не страдать, а делает все так, как положено.
3232.88 3236.92 "Анатолий Кулаков" Из YARP, интересная у него история, конечно.
3236.92 3256.28 "Анатолий Кулаков" Во-первых, он появился внутри, в командах Microsoft, потому что очень много сервисов, Microsoft очень много сервисов пишет и очень много команд в этих сервисах хотели написать свой Reverse Proxy и даже писали свой Reverse Proxy для того, чтобы вышеописанные проблемы каким-то образом решать.
3256.28 3275.48 "Анатолий Кулаков" И вот писали-писали, потом походили между другом, посмотрели и решили, что все-таки нужно как-то это в общую библиотечку вынести, потому что пока мы пишем поддержку HTTP 1, нам уже была нужна поддержка HTTP 2, там еще RPC пришел и все это, естественно, поддерживать никакого, никаких сил не хватит.
3275.48 3282.92 "Анатолий Кулаков" Поэтому решили выделить это в отдельный продукт и внутри Microsoft, в принципе, изначально сам для себя Microsoft сделал YARP.
3282.92 3303.64 "Анатолий Кулаков" Несмотря на то, что вынесли кучу каких-то общих вещей, благодаря которым появился проект, команда YARP походила по другим разработчикам и выяснила, что у каждого сервиса есть какие-то свои предпочтения, какие-то свои хотелки, что-то они там хотели именно такого, чего сделать не могли.
3303.64 3315.52 "Анатолий Кулаков" И вот пытались, например, если брали Nginx, то пытались его поднастроить под такие свои желания, к которым он был не готов, скажем мягко так.
3315.52 3330.56 "Анатолий Кулаков" И, соответственно, отсюда и родилась основная философия YARP, что, в принципе, нам всем нужен Reverse Proxy, но одновременно у всех у нас, у всех проектов какие-то свои собственные загоны, какие-то свои собственные хотелки и всех почесать под одну гребенку все равно не получится.
3330.56 3336.08 "Анатолий Кулаков" Невозможно написать такой конфиг, который удовлетворит абсолютно всех, вот как пытается сделать Nginx.
3336.08 3340.04 "Анатолий Кулаков" Поэтому решили именно подставлять в виде библиотек и в виде расширяемого API.
3340.04 3355.20 "Анатолий Кулаков" Вот, все это делается на базе ISP.NET Core, то есть YARP это всего лишь навсего обычный middleware, который вы можете проинсталлировать из NuGet пакета, зарегистрировать у себя в ISP.NET Core приложении и пользоваться всеми благами.
3355.20 3366.60 "Анатолий Кулаков" Соответственно, мы получаем автоматически все ускорения перформанса и все фишки и все вот эти минимумы API, которые есть в ISP.NET Core и, соответственно, получаем клевую гибкость и функциональность ReverseProxy.
3366.60 3370.96 "Анатолий Кулаков" Также и ReverseProxy может работать как некая база для IP Gateway.
3370.96 3373.84 "Анатолий Кулаков" Это тоже один из его сценариев использования.
3373.84 3381.08 "Анатолий Кулаков" Я думаю, многие сталкивались с тем, что компании любят выставлять какой-то IP Gateway наружу к пользователю, а все остальное прятать именно за ним.
3381.08 3383.88 "Анатолий Кулаков" Там тоже куча преимуществ и этого подхода есть.
3383.88 3388.56 "Анатолий Кулаков" Итак, существует два способа основных использования YARP.
3388.56 3391.68 "Анатолий Кулаков" Во-первых, это полнофункциональный ReverseProxy.
3391.68 3402.16 "Анатолий Кулаков" То есть, все, что вам нужно, это просто-напросто отконфигурировать уже готовую библиотеку с помощью набора каких-то правил, с помощью набора каких-то роутов.
3402.16 3412.28 "Анатолий Кулаков" И отконфигурировать это можно обычным стандартным файликом, у которого там тоже уже зарегистрирован, задокументирован формат, который описывается довольно-таки легко.
3412.28 3420.52 "Анатолий Кулаков" В этом файлике вы должны описать, какие роуты ему необходимо ловить, каким образом эти роуты смапить на кластера серверов назначения.
3420.52 3427.32 "Анатолий Кулаков" И у каждого вот этого кластера назначения должны быть какие-то обработчики запросов.
3427.32 3431.42 "Анатолий Кулаков" То есть, в какие обработчики необходимо все эти запросы посылать.
3431.42 3434.68 "Анатолий Кулаков" Сервера назначения тоже выбираются по хитрым стандартам.
3434.68 3437.28 "Анатолий Кулаков" Во-первых, можно сделать Sticky Session.
3437.28 3443.84 "Анатолий Кулаков" То есть, вы определенную сессию пользователя все время отправляете на один и тот же адрес.
3443.84 3446.96 "Анатолий Кулаков" Если у вас стоит Full Service, вам это нужно.
3446.96 3450.48 "Анатолий Кулаков" В общем, стараются сейчас так не делать, но часто такое нужно.
3450.48 3455.56 "Анатолий Кулаков" Вы будете получать своего пользователя все время на один и тот же сервис.
3455.56 3458.20 "Анатолий Кулаков" Дальше он умеет делать проверку хелсчеков.
3458.20 3465.40 "Анатолий Кулаков" То есть, он понимает, как только из кластера отвалился какой-то сервак по какой-либо причине, туда запросы больше не пойдут.
3465.40 3469.80 "Анатолий Кулаков" Соответственно, пользователь будет перенаправляться только на те дестинейшны, которые живы.
3469.80 3481.04 "Анатолий Кулаков" Ну и также будет участвовать в этом процессе из всех тех, кто выжил, Load Balancing алгоритм, которых очень много и которые размажут нагрузку именно так, как вы хотели по всем вашим точкам.
3481.04 3484.08 "Анатолий Кулаков" Вот все эти части, они безумно кастомизированы.
3484.08 3490.80 "Анатолий Кулаков" Каждый из них вы можете подкнуться, подкрутить гайки, подвинтить винтики и посмотреть, что там внутри можно изменить.
3490.80 3499.48 "Анатолий Кулаков" Второй подход, каким образом можно использовать YARP, это максимально конфигурируемым.
3499.48 3520.72 "Анатолий Кулаков" То есть, все вот эти Routes, Load Balancing, модули, вы можете брать не непосредственно из файла конфигурации, где вы это все легко и понятно пишите, а сами собрать весь этот pipeline, сами сказать, на каком степе нужно конфигурировать, как написать сложную логику прямо на .NET, куда нужно перенаправлять и прочее, прочее, прочее.
3520.72 3539.96 "Анатолий Кулаков" Такой подход используется, например, в Azure App Services, там где инстанции всяких контейнеров, сервисов, они появляются динамически в зависимости от чего-то и также динамически они регистрируются в Reverse и также динамически они оттуда разрегистрироваются, исчезают и в общем такой очень живой и гибкий сценарий получается.
3539.96 3555.56 "Анатолий Кулаков" Соответственно, оба этих подхода и конфигурация через понятный файл и мега кастомизированный pipeline, они могут использоваться вместе, в этом нет никаких проблем, вы можете выбрать в зависимости от того, какой Route к вам пришел, вы можете выбрать использовать тот или иной способ.
3555.56 3569.16 "Анатолий Кулаков" И начать пользоваться YARP очень легко, как я уже сказал, это все iSpin App приложение, у него нет никакого executable запускаемого файла, который вы можете скачать и заинсталлировать куда-то.
3569.16 3598.64 "Анатолий Кулаков" Вы просто создаете веб-приложение, добавляете из NuGet пакет, YARP специальный, регистрируете в сервисах, add Reverse Proxy, регистрируете в аппликейшене, map Reverse Proxy, сделаете конфигурационный файл, в котором вы можете указать все те же Routes, Clusters, Matches, Destinations, все это идеально описано в документации, и все, на этом ваш Reverse Proxy готов.
3598.64 3606.84 "Анатолий Кулаков" Итак, в этой новости, как я уже сказал, зарелизовалась первая большая мажорная версия вот этого прекрасного сервера.
3606.84 3611.28 "Анатолий Кулаков" В экспериментах, в разработке он находится уже довольно давно, сейчас мы празднуем релиз.
3611.28 3617.52 "Анатолий Кулаков" Итак, что же такого в этом релизе изменилось по сравнению с предыдущими версиями?
3617.52 3619.00 "Анатолий Кулаков" Во-первых, это конфигурация.
3619.00 3638.32 "Анатолий Кулаков" Как я уже сказал, есть конфигурация из файла, примечательно то, что используется слежение за файлами, то есть если файлики поменялись, вы там подавили какой-то новый Route, то YARP способен это динамически перечитать, обновить свои все пути и подхватить, и начать обрабатывать новые запросы.
3638.32 3647.36 "Анатолий Кулаков" И естественно конфигурация есть программная, то есть с абсолютно любого источника, не только с файла, а с API, с базы данных, с каких-то сигналов еще.
3647.36 3652.96 "Анатолий Кулаков" Вы можете все эти Routes собирать, динамически обновлять и естественно перенаправлять куда надо.
3652.96 3660.72 "Анатолий Кулаков" Следующая интересная фишка это то, что Routes теперь могут читать хидра из HTTP.
3660.72 3668.00 "Анатолий Кулаков" Вот, также появились активные и пассивные health-чеки, которые проверяют узлы назначения на их живучесть.
3668.00 3677.72 "Анатолий Кулаков" Появился как раз таки стикер Session, Session Affinity он еще называется, и позволяет привязывать вам к конечному узлу определенные запросы.
3677.72 3685.24 "Анатолий Кулаков" Добавилось еще много алгоритмов load balancing, теперь это не простые раундромины, а можно что-то похитрее выдумать.
3685.24 3695.56 "Анатолий Кулаков" Про апдейт или авторизацию, идентификацию и корсы для определенных Routes сделали так, чтобы к конкретному Route можно было настраивать абсолютно разные вот эти процессы.
3695.56 3720.08 "Анатолий Кулаков" Интересно, что теперь можно очень удобно трансформировать URL, с которым к вам пришли, а также можно теперь трансформировать хидра, которые к вам пришли, а еще можно трансформировать HTTP методы, которые к вам пришли, то есть вот эти GET, POST, PUT, вот их он тоже может переделывать, и если к вам запостили какой-то запрос, то вы ему можете передать, например, GET на какие-то другие сервера.
3720.08 3736.56 "Анатолий Кулаков" Дальше улучшилась поддержка gRPC, а также WebSockets, включая стриминг, поправдавилась диагностика, вот метрики, логи, вот про что мы говорили в предыдущем, в предыдущий топик, вот там это тоже все улучшилось.
3736.56 3747.92 "Анатолий Кулаков" Сделали хорошую, написали хорошую документацию, она действительно хорошая, большая, четко, понятно написана, поэтому я думаю разобраться никаких проблем не будет.
3747.92 3748.92 "Анатолий Кулаков" Ну и конечно Performance.
3748.92 3764.36 "Анатолий Кулаков" Интересно, что у них есть специальные стенды, где они меряют Performance каждый день, и меряют они это с помощью определенных бичмарков, которые настроены на таком же environment, как делает Teck Empower, знаменитая бичмаркалка.
3764.36 3773.08 "Анатолий Кулаков" Безусловно, Performance полностью зависит от размера боди, от использования шифрования, от использования компрессии и прочей-прочей кучей всяких мелочей.
3773.08 3774.60 "Анатолий Кулаков" Ну, когда нас это останавливало.
3774.60 3776.72 "Анатолий Кулаков" Сравнивать-то хочется, сравнить мы хотим.
3776.72 3791.56 "Анатолий Кулаков" Поэтому немножко цифр, они сделали большой отчет на 21 странице в Power BI, вот можете потыкать, отчет действительно интересный, то есть со всеми этими параметрами они поигрались, и самый интересный отчет находится на 16 странице.
3791.56 3794.60 "Анатолий Кулаков" На 16 странице они как раз таки сравниваются с конкурентами.
3794.60 3797.80 "Анатолий Кулаков" В общем, пока результат кратко такой.
3797.80 3801.60 "Анатолий Кулаков" Invoy мы обогнали очень легко, вообще даже не напрягаясь.
3801.60 3806.44 "Анатолий Кулаков" И совсем немножко осталось до Haproxy и Nginx.
3806.44 3809.32 "Анатолий Кулаков" В общем, они пока обходят YARP.
3809.32 3819.64 "Анатолий Кулаков" Но у разработчиков уже есть огромные планы на следующую версию, и у них уже есть какие-то идеи, как можно хорошо прокачать перформанс.
3819.64 3824.36 "Анатолий Кулаков" Поэтому пока не сдаемся, может быть все-таки Nginx мы через полгодика или годик победим.
3824.36 3828.96 "Анатолий Кулаков" В общем, пока ждем оптимизаций.
3828.96 3834.72 "Анатолий Кулаков" Также на следующей версии нам обещают поддержку HTTP3 и более тесную интеграцию с Kubernetes.
3834.72 3837.28 "Анатолий Кулаков" Вот такое будущее ждет YARP.
3837.28 3840.40 "Анатолий Кулаков" Проект интересный, проект open-source, под хорошей лицензией.
3840.40 3848.60 "Анатолий Кулаков" В общем, заходите, смотрите, пользуйтесь и подписывайтесь, если вдруг у кого-то это уже есть где-то в продакшене, кроме как у Microsoft в Ажуре.
3848.60 3850.48 "Анатолий Кулаков" Тоже пишите свои впечатления.
3850.48 3854.52 "Игорь Лабутин" Я как раз хотел заиспользовать его для, так скажем, локальной разработки.
3854.52 3875.56 "Игорь Лабутин" У нас когда запускаем всю эту кучку микросервисов локально, было бы прикольно иметь некоторые, скажем так, Reverse Proxy, чтобы локально всем ходить по одному и тому же курлу, а он пусть сам переписывает порты и адреса, раскидывает по разным localhost портам, где слушают разные микросервисы, которые ты локально запустил.
3875.56 3878.88 "Игорь Лабутин" Это в принципе удобно должно быть.
3878.88 3881.48 "Анатолий Кулаков" Да, в нашем мире микросервисов идея довольно здравая.
3881.48 3890.64 "Анатолий Кулаков" Мне кажется, довольно нездравый подход начинать на это все натягивать обычные HTTP сервера, которым изначально являлся Nginx.
3890.64 3895.16 "Анатолий Кулаков" Потому что немножко у него свои ограничения, немножко у него своя технология.
3895.16 3899.92 "Анатолий Кулаков" И вот написать что-то с нуля правильное, красивое и модное – вот это правильное направление.
3899.92 3911.64 "Игорь Лабутин" Ну, значит, как раз-таки набросаю простую spnet6 приложенку, закину туда этот ярп, скомпилирую его, соответственно, и будет он умеет запускаться.
3911.64 3916.16 "Игорь Лабутин" У меня уже сейчас используется этот самый тай для запуска пачки микросервисов локально.
3916.16 3921.16 "Игорь Лабутин" Ну, соответственно, туда докину еще один компонент, будет запускать еще ярп перед ним.
3921.16 3923.92 "Анатолий Кулаков" Да, прекрасно, такой маленький кубернетик получится.
3923.92 3924.92 "Анатолий Кулаков" Ну, типа того.
3924.92 3929.52 "Игорь Лабутин" Так, погнали дальше.
3929.52 3935.76 "Игорь Лабутин" Дальше у нас тема, опять такая, более что ли к разработке относящаяся – это про MS Build.
3935.76 3939.84 "Игорь Лабутин" Смотрите, у нас есть Visual Studio 22, и она теперь 64-битная.
3939.84 3944.00 "Игорь Лабутин" И это означает, что она теперь будет запускать 64-битный MS Build.
3944.00 3950.32 "Игорь Лабутин" И все было бы хорошо, казалось бы, а что беспокоиться-то, какая разница, какой битности MS Build.
3950.32 3953.32 "Игорь Лабутин" Но проблемы начинаются, если вы вдруг используете какие-то таски.
3953.32 3963.76 "Игорь Лабутин" Напомню, что таски для MS Build, да, это просто дотонатная DLL, которую MS Build процесс грузит в себя и сообразно некоторому стандартному API дергает нужные методы.
3963.76 3980.64 "Игорь Лабутин" Так вот, если у вас вдруг используется таска, которая собрана как 32-битную, например, используют какие-то нативные библиотечки 32-битные, и она сама себя неправильно помечает, что она 32-битная, то билды, начиная с 2-й студии, начнут падать.
3980.64 3985.52 "Игорь Лабутин" Про это надо знать и к этому надо быть готовым, особенно если вы используете много кастомных тасков.
3985.52 3995.24 "Игорь Лабутин" И касается это только Visual Studio, то есть при этом, если вы скажете "дотонат билд" в командной строке, у вас все будет хорошо, потому что там он выполнит все правильно.
3995.24 4002.84 "Игорь Лабутин" Но вот Visual Studio, она использует такую специфическую, так сказать, особенность для MS Build.
4002.84 4004.08 "Игорь Лабутин" Давайте разбираться подробнее.
4004.08 4007.88 "Игорь Лабутин" В MS Build есть две версии, собственно, 32-битные и 64-битные.
4007.88 4015.76 "Игорь Лабутин" Когда вы ставите себе MS Build, ставятся на самом деле обе, когда вы ставите себе Visual Studio, точнее, или Visual Studio Build Tools.
4015.76 4028.40 "Игорь Лабутин" И если вы используете скриптов, какие-нибудь PowerShell скриптики, или CMD, или еще что-нибудь, вы можете прямо указать явный путь к MS Build, соответственно, либо 32-битный, либо 64-битный, и будет использоваться тот, который вы указали.
4028.40 4033.20 "Игорь Лабутин" В Visual Studio версия MS Build, в смысле битность, прибита гвоздями.
4033.20 4038.84 "Игорь Лабутин" В 2019-й студии это был 32-битный MS Build, это последняя студия, где он используется.
4038.84 4044.24 "Игорь Лабутин" И он же используется по дефолту, например, в Azure Pipelines.
4044.24 4058.72 "Игорь Лабутин" Если вы используете Visual Studio Build или MS Build-овую тасочку в Azure DevOps Pipelines, то там тоже будет 32-битный, и для того, чтобы это поменять, нужно указать специальный тег в ямле, когда вы пишете job definition, чтобы он был x64 там.
4058.72 4060.68 "Игорь Лабутин" Тег называется MS Build Architecture.
4060.68 4074.00 "Игорь Лабутин" А если вы используете GitHub Actions, то когда вы говорите setup MS Build Action, который, собственно, вам поднимет MS Build окружение, там тоже нужно указывать MS Build Devices Architecture 2.x64, чтобы запустился 64-битный.
4074.00 4084.64 "Игорь Лабутин" Так вот, если у вас при этом есть таски, которые делают, например, painwalk в нативной библиотеке, и эти нативные библиотеки 32-битные, то x64, естественно, ничего не заработает.
4084.64 4093.96 "Игорь Лабутин" И Microsoft говорит, что, казалось бы, с одной стороны, возможно, редкая штука, но мы-то все свои таски, конечно же, поправим.
4093.96 4109.40 "Игорь Лабутин" И во-первых, на что они наскнулись, когда тестировали ранние превьюшки 22-й студии, это то, что их собственный Visual Studio SDK, собственно, не собирался в Visual Studio, потому что как раз там были 32-битные таски, которые были несовместимы с 64-битным билдом.
4109.40 4119.12 "Игорь Лабутин" Они, конечно, все это уже поправили, но кто знает, какие кастомные таски вы используете в тех нугетах, которые вы притаскиваете к себе, и кто знает, где там что выстрелит.
4119.12 4124.36 "Игорь Лабутин" Если вы с таким столкнетесь, то, скорее всего, вы можете увидеть два варианта ошибок.
4124.36 4133.20 "Игорь Лабутин" Либо у вас будет ошибка 4018 про то, что system.dll not found, либо 4062 про task.code not be loaded.
4133.20 4134.20 "Игорь Лабутин" Их там два варианта.
4134.20 4137.12 "Игорь Лабутин" И у вас есть два варианта.
4137.12 4159.20 "Игорь Лабутин" Вы можете взять таску, особенно если это ваша таска и у вас есть ее код, вы можете ее переписать и сделать так, чтобы она просто, ну, как обычная dll-ка, нугет, который таргетит и 32-бит, и 64-бита, там будет две версии вашей unmanaged dll-ки, вы будете дергать правильную в зависимости от битности, под которой вы сейчас работаете.
4159.20 4163.24 "Игорь Лабутин" Это все можно в дот найти, выяснить в рантайме.
4163.24 4165.08 "Игорь Лабутин" Но это прям сложный путь.
4165.08 4171.00 "Игорь Лабутин" Второй вариант — это, соответственно, намекнуть msbuild, что вообще-то таска 32-битная.
4171.00 4177.36 "Игорь Лабутин" Это можно сделать, когда вы используете statement using task в xml-ке msbuild-а.
4177.36 4182.04 "Игорь Лабутин" Там есть, вы указываете task name, вы указываете assembly file, собственно, как его вызывать.
4182.04 4185.12 "Игорь Лабутин" Там же есть теперь тег, который называется architecture.
4185.12 4198.92 "Игорь Лабутин" Там можно написать x86, и тогда msbuild автоматически запустит 32-битный процесс, который загрузит вашу таску, сделает все, что с ней надо, прозрачно из этого процесса заберет все окружение, которое таска произвела, и дальше продолжит в 64-битном виде исполняться.
4198.92 4202.36 "Игорь Лабутин" Я сказал, что теперь есть такой тег, я не совсем прав.
4202.36 4218.36 "Игорь Лабутин" Этот тег есть очень давно, начиная с Visual Studio 2012 и .NET 4.5, поэтому вы можете совершенно спокойно его использовать, и даже если этот код будет запускаться 32-битным msbuild-ом, там какой-нибудь старой студией, ничего страшного не произойдет, все будет работать.
4218.36 4227.60 "Игорь Лабутин" И при этом это не поможет, если у вас сама таска определена в .NET сборке, которая собрана как 32-бит only.
4227.60 4234.60 "Игорь Лабутин" То есть если сама .NET сборка помечена битиком, что она не работает, то msbuild такой загрузить не сможет.
4234.60 4244.20 "Игорь Лабутин" И это известная проблема, есть тишины GitHub, с которой они работают, чтобы все-таки это не мешало загружать, то есть можно это пытаться сделать тоже из отдельного процесса.
4244.20 4250.04 "Игорь Лабутин" И если вы с таким столкнулись, и это ваша таска, ну просто перекомпилируйте ее по .NET CPU, если вы можете.
4250.04 4263.12 "Игорь Лабутин" Но как правило в .NET это возможно, в .NET обычно помечают 32-бит only, только если вы действительно работаете с unmanaged delete-ками, чтобы гарантированно ваш .NET сборка тоже грузил только 32-битные процессы.
4263.12 4266.92 "Игорь Лабутин" В этом случае просто перекомпилируйте по .NET CPU.
4266.92 4285.40 "Игорь Лабутин" Но к сожалению, если вы например такое встретили не со своей таской, то или вы не контролируете, где написано using task, например это написано в каком-нибудь NuGet пакете внутри, какого-нибудь props файла, который вам подтягивается автоматически во время билда.
4285.40 4307.60 "Игорь Лабутин" Но тут пока сделать ничего нельзя, можно только сходить к авторам NuGet пакета, но есть еще на GitHub, где Microsoft думает как бы так можно сделать, типа зааверрайдить этот using task и указать ему, что все-таки вот пожалуйста в том using task и в том файле все-таки используй x86 архитектуру и соответственно отдельно MSBuild с 32-битный процесс и когда будешь собирать.
4307.60 4313.40 "Игорь Лабутин" Пока это все на стадии рассмотрения, как бы это сделать, там либо через какие-нибудь .overwrite файлы, либо еще что-нибудь.
4313.40 4332.44 "Игорь Лабутин" Но в общем дело такое, это еще один момент такого сюрприза при переходе на 64-битную студию, которую не то чтобы может быть никто не ожидал, но я например про которую не знал, что битность MSBuild поменялась и это может действительно повлиять на то, как собирается
4332.44 4337.48 "Анатолий Кулаков" ваш проект. Да, особенно если вы такие умные и кастомизировали себе процессы и могли это делать.
4337.48 4340.16 "Игорь Лабутин" Ну все у нас такие умные, что ты.
4340.16 4342.44 "Анатолий Кулаков" Я думаю да, да, безусловно.
4342.44 4351.52 "Анатолий Кулаков" Так, я что-то чувствую себя каким-то пропагандистом, но я по-прежнему продолжаю убеждать вас в необходимости мониторинга, телеметрии и прочей глупости.
4351.52 4356.32 "Анатолий Кулаков" И в качестве одного из аргументов я решил привести статью Конрада Кокоса.
4356.32 4360.72 "Анатолий Кулаков" Конрад известен в нашем мире как мега-хардкорный парень.
4360.72 4363.00 "Анатолий Кулаков" Это тот человек, который писал свой ГЦ.
4363.00 4368.88 "Анатолий Кулаков" Это наверное единственный человек, кроме Майони, который разбирается, как он действительно этот ГЦ работает.
4368.88 4369.88 "Анатолий Кулаков" Он выпустил книгу по ГЦ.
4369.88 4374.60 "Анатолий Кулаков" Ну то есть хардкорнее человека в индустрии, наверное, сложно еще поискать.
4374.60 4380.88 "Анатолий Кулаков" И даже он занялся мониторингом, докерами и вот этой прочей инфраструктурной безобразией.
4380.88 4383.40 "Анатолий Кулаков" Поэтому вот как показательный элемент смотрите.
4383.40 4388.36 "Анатолий Кулаков" Дело в том, что Конрад написал интересную статейку, где как раз таки объединил все вот эти базворды.
4388.36 4390.12 "Анатолий Кулаков" Ну не все, большинство этих базвордов.
4390.12 4394.52 "Анатолий Кулаков" Статейка называется «Каким же образом нам к дотнет-мониторингу прицепить красивенькую горофану?».
4394.52 4397.00 "Анатолий Кулаков" И оказалось, что это не так уж и сложно.
4397.00 4408.16 "Анатолий Кулаков" На самом деле дотнет-монитор, напомню, это специальный инструмент, который с помощью удобного REST API выставляет наружу информацию о метриках вашего приложения.
4408.16 4415.24 "Анатолий Кулаков" О метриках, о логах, о трейсингах, в общем, о всей диагностической информации, которую он может наскрести из вашего дотнет-приложения.
4415.24 4424.08 "Анатолий Кулаков" Это очень удобно, потому что у него есть специальная вебка, куда вы можете зайти, и мышка, перекликивая, посмотреть базовую информацию.
4424.08 4432.80 "Анатолий Кулаков" И вы даже теперь без помощи дебаггера, без помощи профайлера можете очень много интересного узнать о вашем приложении.
4432.80 4446.76 "Анатолий Кулаков" Конрад воспользовался той ситуацией, что дотнет-монитор выставляет наружу некий endpoint, который по описанию выдает метрики вашего приложения в формате Prometheus.
4446.76 4469.68 "Анатолий Кулаков" Вот именно он и решил прицепиться к этому endpoint и собрать вместе все эти кусочки, и сделать так, чтобы вам выдавался не просто какой-то непонятный текстовый Prometheus формат, а сделать так, чтобы эти метрики вашего приложения напрямую писались в Storage Prometheus и отображались в графане в виде красивых, прекрасных графиков.
4469.68 4471.68 "Анатолий Кулаков" Графаны просто великолепные графики.
4471.68 4485.48 "Анатолий Кулаков" Как только вы первый раз их увидите, вы обязательно в них любитесь и не сможете просто ни одного дня больше проживать без того, чтобы за чашечкой чая утром посмотреть на графики графаны и насладиться, что ваше приложение красиво и успешно работает.
4485.48 4486.48 "Анатолий Кулаков" Или не работает.
4486.48 4487.48 "Анатолий Кулаков" Итак, шаг первый.
4487.48 4489.92 "Анатолий Кулаков" Прежде всего вам нужно приготовить приложение.
4489.92 4492.76 "Анатолий Кулаков" Для демки Конрад взял Memory League.
4492.76 4494.48 "Анатолий Кулаков" Это приложение под Net5.
4494.48 4496.24 "Анатолий Кулаков" Тоже очень интересная штука.
4496.24 4499.88 "Анатолий Кулаков" Игорь, ты когда-нибудь слышал о таком демо-приложении как Memory League?
4499.88 4511.48 "Игорь Лабутин" Слушай, я его встречал в какой-то одной или двух статьях или видосике, где то ли перфью показывали, то ли… В общем, я вот когда смотрел то ли ролик про перфью, то ли что-то, я его встречал.
4511.48 4518.72 "Игорь Лабутин" Но я себе тоже добавил в закладки, потому что действительно штука полезная для всяких демонстраций и проверок того, что можно сделать с тулом.
4518.72 4522.92 "Игорь Лабутин" А то в продакшене не всегда найдешь подходящий Memory League, на котором потренироваться.
4522.92 4523.92 "Анатолий Кулаков" Именно так.
4523.92 4527.72 "Анатолий Кулаков" И в этом приложении собраны довольно интересные поведения Garbage Collector.
4527.72 4534.36 "Анатолий Кулаков" То есть когда он собирает мусор, когда не собирает, в какие моменты, что там с поколениями происходит.
4534.36 4536.20 "Анатолий Кулаков" И это все визуализируется красиво.
4536.20 4544.24 "Анатолий Кулаков" И внутри этого приложения есть очень много диагностики, много диагностики, которые позволяют вам визуально показать, а что же собственно происходит с Garbage Collector.
4544.24 4550.96 "Анатолий Кулаков" Вот, на довольно типичных ситуациях, включая утечки памяти.
4550.96 4553.40 "Анатолий Кулаков" В общем, приложение заслуживает тоже отдельного обсуждения.
4553.40 4554.84 "Анатолий Кулаков" Посмотрите на него обязательно.
4554.84 4557.04 "Анатолий Кулаков" Конор очень часто использует это приложение.
4557.04 4562.28 "Анатолий Кулаков" И вот в этот раз он тоже взял Memory League, упаковал его в Docker, что делается довольно просто.
4562.28 4568.76 "Анатолий Кулаков" Единственная хитрость, которую пришлось ему сделать, он создал Volume, Docker Volume и примаунтил его в Temp папку.
4568.76 4580.68 "Анатолий Кулаков" С помощью этой Temp папки как раз-таки диагностика внутри приложения и будет обмениваться с помощью с контейнером .NET Monitor, который будет запущен рядом.
4580.68 4583.36 "Анатолий Кулаков" И во втором степе он запускает .NET Monitor.
4583.36 4586.36 "Анатолий Кулаков" .NET Monitor уже имеет свой собственный контейнер.
4586.36 4589.16 "Анатолий Кулаков" Этот контейнер располагается в Microsoft Container Registry.
4589.16 4591.76 "Анатолий Кулаков" Опять же, устанавливается, запускается одной командой.
4591.76 4598.72 "Анатолий Кулаков" Единственное, что он мапит ту же самую папку, которую он сделал на шаге 1 с нашим приложением и к .NET Monitor.
4598.72 4611.20 "Анатолий Кулаков" И именно благодаря вот этому, то что у них одинаковый ShareIt Volume используется, случается магия и .NET Monitor умеет читать данные с абсолютно другого контейнера с нашего приложения.
4611.20 4613.16 "Анатолий Кулаков" На третьем шаге мы запускаем Prometheus.
4613.16 4616.60 "Анатолий Кулаков" Опять же, стандартный Docker контейнер, уже все есть, просто скачиваем.
4616.60 4620.40 "Анатолий Кулаков" Единственное, что вам нужно, это изменить его конфигурационный файл.
4620.40 4625.40 "Анатолий Кулаков" Написать там условия, от какого endpoint, как часто вам нужно забирать метрики.
4625.40 4629.36 "Анатолий Кулаков" Здесь очень полезен специальный магический хост, который называется host.docker.internal.
4629.36 4643.16 "Анатолий Кулаков" Это специальный адрес, который позволяет обмениваться информацией, коннектиться к другим контейнерам в рамках вашего локального хоста и общаться друг с другом.
4643.16 4645.32 "Анатолий Кулаков" Все, дальше Docker Run, Prometheus работает.
4645.32 4648.88 "Анатолий Кулаков" И четвертый шаг, это непосредственно сама Grafana.
4648.88 4652.40 "Анатолий Кулаков" Разумеется, у Grafana тоже есть свой собственный Docker контейнер.
4652.40 4659.56 "Анатолий Кулаков" Мы Grafana просто-напросто запускаем, заходим, создаем Data Source, Data Source указываем на Storage, на наш Prometheus.
4659.56 4663.16 "Анатолий Кулаков" Опять же используется тот же самый хак host.docker.internal.
4663.16 4668.88 "Анатолий Кулаков" И наши контейнеры умеют уже обмениваться информацией по сети, по стандартным протоколам абсолютно прозрачно.
4668.88 4674.36 "Анатолий Кулаков" Нужно упомянуть, что это подход больше такой разработческий, больше тестовый, больше демонстрационный.
4674.36 4679.36 "Анатолий Кулаков" Естественно, в продакшене вам нужно загнаться и настроить сеть между контейнерами более серьезно.
4679.36 4691.00 "Анатолий Кулаков" Все, открываем браузер Metric, создаем дашборд и уже непосредственно можем наблюдать в реальном времени все те метрики, которые в нашем приложении сейчас в данный момент генерятся.
4691.00 4699.20 "Анатолий Кулаков" И следить соответственно за всеми этими диагностиками, которые происходят в мемориалике, следить за тем, как он теряет память, как это может чиниться и прочее-прочее.
4699.20 4710.68 "Анатолий Кулаков" Если вам лень создавать свои дашборды в Grafana, то Конор любезно предоставил JSON файлик, который вы можете заимпортить и увидеть все те графики, которые он уже настроил под именно конкретно это приложение.
4710.68 4712.56 "Анатолий Кулаков" В принципе, это и все.
4712.56 4715.44 "Анатолий Кулаков" Все это он делал на своей Windows машине.
4715.44 4718.08 "Анатолий Кулаков" Docker прекрасно работает с Linux контейнерами.
4718.08 4720.92 "Анатолий Кулаков" Linux контейнеры прекрасно совместимы друг с другом.
4720.92 4731.88 "Анатолий Кулаков" И вот, чтобы поднять такую сложную систему из четырех приложений с абсолютно разными языками, разными инфраструктурами, вот для этого уходит буквально пару минут, если вы понимаете, что делаете.
4731.88 4741.48 "Анатолий Кулаков" А если не понимаете, то пройдите все эти шаги вместе с Конором и этого достаточно для того, чтобы прекрасно уже научиться разбираться с подобными инфраструктурами.
4741.48 4758.20 "Игорь Лабутин" Но да, я почитал действительно статью, как-то даже независимо от подготовки к подкасту, и честно сказать, во-первых, действительно захотелось подергать мемориалик, во-вторых, собрать что-нибудь подобное на самом деле у себя, чисто ради прикола.
4758.20 4760.76 "Анатолий Кулаков" Ну, будут какие-то интересные у тебя открытия, обязательно
4760.76 4764.36 "Игорь Лабутин" расскажи. Надо статью писать, я знаю.
4764.36 4765.84 "Игорь Лабутин" Но так лень, так лень.
4765.84 4767.44 "Игорь Лабутин" Ладно, давай дальше.
4767.44 4770.72 "Анатолий Кулаков" Как раз тем, кому лень писать статью, те делают подкасты.
4770.72 4772.28 "Анатолий Кулаков" Вот мы и с вами здесь сегодня.
4772.28 4790.40 "Анатолий Кулаков" И, видимо, не зря, потому что буквально прошлым декабрем, вот прямо перед самым Новым Годом, по-моему, это даже был последний выпуск прошлого года, в Радио.нет номер 19 мы с тобой обратили внимание на интересную тулу, точнее баннинги, штука, которая называется InferSharp.
4790.40 4802.36 "Анатолий Кулаков" Это баннинги к кросс-процедурному инструменту для анализа кода, который называется просто Infer от компании Facebook, изначально он выпустился, но сейчас уже развивается сообществом во все стороны.
4802.36 4807.00 "Анатолий Кулаков" В частности, он поддерживает C, Java, Objective-C и много других разных языков.
4807.00 4812.12 "Анатолий Кулаков" Суть этого инструмента заключается в том, что он сосредоточен на анализе кода.
4812.12 4814.24 "Анатолий Кулаков" И на анализе довольно сложном.
4814.24 4824.64 "Анатолий Кулаков" Такие как взаимные блокировки, какие-то еще дедлоки и прочие-прочие-прочие, в общем, такие высоколобые вещи, по которым пишут просто пейперы.
4824.64 4830.24 "Анатолий Кулаков" Из интересного он написан на Acamly, но, к счастью, разработчикам Acamly изучать не нужно.
4830.24 4846.40 "Анатолий Кулаков" У нас есть прекрасные биндинги, которые абсолютно прозрачно ваше дотнет-приложение могут анализировать с помощью вот этого инструмента, в который вложились очень много различных ученых и просто умных дядек, и умных тетек, и придумали кучу разных анализов.
4846.40 4858.40 "Анатолий Кулаков" Вот, InferSharp можно использовать из Visual Studio, из Visual Studio кода в основном, или с помощью отдельного Docker Image, или уже встроенного GitHub Action.
4858.40 4861.96 "Анатолий Кулаков" Как раз-таки новость заключается в том, что InferSharp за этот год не умер.
4861.96 4871.80 "Анатолий Кулаков" Кстати, если вы хотите подробнее узнать, мы в девятнадцатом выпуске радио обсуждали подробнее, что это такое, с чем его идет и для чего, вот, можете перейти по ссылочке и переслушать.
4871.80 4875.64 "Анатолий Кулаков" К счастью, у нас есть хорошие шоуноуты, которые легко вам позволяют это найти.
4875.64 4878.28 "Анатолий Кулаков" Соответственно, в чем заключается новость?
4878.28 4882.60 "Анатолий Кулаков" Вышла версия 1.2, и здесь есть немножко улучшений.
4882.60 4891.44 "Анатолий Кулаков" Хочется бы вам рассказать, что проект жив, проект развивается, и может быть для ваших инструментов, для вашего продукта его анализаторы будут полезны.
4891.44 4899.32 "Анатолий Кулаков" Прежде всего, появилась поддержка InferSharp под VSL2, который под Windows.
4899.32 4901.76 "Анатолий Кулаков" Дальше завезли интеграцию с Azure Pipelines.
4901.76 4904.36 "Анатолий Кулаков" Теперь вы можете там его красиво быстренько подключить.
4904.36 4909.80 "Анатолий Кулаков" Добавлена поддержка нового анализа по обнаружению race conditions.
4909.80 4915.28 "Анатолий Кулаков" Это когда мы можем читать какую-то переменную без блока синхронизации.
4915.28 4928.72 "Анатолий Кулаков" Если в одном методе вы какую-то переменную обернули локом и под локом туда что-то записали, в другом публичном методе вы пытаетесь эту переменную прочитать без лока, вот подобную ошибку может найти теперь этот инструмент.
4928.72 4935.24 "Анатолий Кулаков" Также научился сообщать о проблемах в методах, у которых есть exception handling.
4935.24 4949.00 "Анатолий Кулаков" То есть если вы создали какой-то новый стрим, потом вызвали try, try-catch и finally забыли этот стрим задиспоузить, это подобные ошибки он тоже вам может сообщить.
4949.00 4954.64 "Анатолий Кулаков" И соответственно у него еще осталась куча старых проверок, которые тоже вам могут быть полезными.
4954.64 4958.76 "Анатолий Кулаков" Поэтому если вы загоняетесь с анализаторами, можете посмотреть еще на вот этот улун.
4958.76 4961.52 "Игорь Лабутин" Ну, особенно если вас не пугает Akamal.
4961.52 4975.40 "Анатолий Кулаков" Ну, на Akamal тебе смотреть не нужно, на Akamal мы уже позаботились, люди из Microsoft, они нам все оттранцлепилировали из нашего силя в Akamal и соответственно больше с этим никаких проблем вроде нет.
4975.40 4976.40 "Игорь Лабутин" Ну, хорошо.
4976.40 4977.40 "Игорь Лабутин" Ну тогда да, интересно.
4977.40 4980.68 "Игорь Лабутин" Можно попробовать подергать, посмотреть.
4980.68 4990.16 "Игорь Лабутин" Хотя конечно все такие tools, каждый раз смотришь на список варнингов или ошибок, которые он выдает, и начинаешь думать, что из этого реально, что нереально.
4990.16 4997.44 "Игорь Лабутин" Вот мне вот сейчас там SonarCoop ругается, что убери этот юзинг, убери юзинг, он тебе не нужен, убирай юзинг, компилироваться перестает.
4997.44 5000.60 "Игорь Лабутин" Возвращай юзинг, SonarCoop ругается, убери юзинг, он не нужен.
5000.60 5001.60 "Анатолий Кулаков" Вот как бы.
5001.60 5009.20 "Анатолий Кулаков" Да, к сожалению, вот кстати всем этим tools еще нужно как-то подключать голову, подключать комментарии, аналитиков, еще чего-то.
5009.20 5012.16 "Анатолий Кулаков" По волшебной палочке они все еще не научились работать.
5012.16 5013.16 "Игорь Лабутин" Ну и ладно.
5013.16 5015.16 "Игорь Лабутин" Давай дальше, Nuget.
5015.16 5024.28 "Анатолий Кулаков" Nuget по идее продолжают двигать security тему после ряда громких взломов с помощью всяких supply chain attack.
5024.28 5030.00 "Анатолий Кулаков" Вот, и еще один интересный фича, которая появилась в Nuget, теперь у нас есть package ID.
5030.00 5039.28 "Анатолий Кулаков" Это специальная сигнатура, которая подтверждает, что этот пакет мантенится действительно тем человеком или той организацией, которой вы рассчитываете.
5039.28 5050.04 "Анатолий Кулаков" Что, например, пакеты, которые начинаются на слово Microsoft, мантенятся действительно Microsoft, и никакой другой разработчик под этим именем этот пакет выложить не может.
5050.04 5054.92 "Анатолий Кулаков" Для этого у нас теперь ввели такое понятие, как package ID prefix.
5054.92 5058.68 "Анатолий Кулаков" И package ID prefix можно зарезервировать.
5058.68 5078.52 "Анатолий Кулаков" После того, как вы его зарезервируете, у Nuget.org и у Visual Studio появится красивый визуальный индикатор, который вам покажет, что это действительно approve пакет от знатного дядьки там или от знатой группы, которые вот они гарантируют, что это действительно так.
5078.52 5094.32 "Анатолий Кулаков" Если вдруг вы пытаетесь запушить в Nuget пакет, у которого есть package ID, то есть вы попадаете под его маску, под маску этих пакетов, то, соответственно, ваш пакет будет зареджектен и ничего не произойдет.
5094.32 5095.96 "Анатолий Кулаков" То есть вы не сможете этого сделать.
5095.96 5112.04 "Анатолий Кулаков" Если мы говорим про предыдущие пакеты, которые уже были запушены в Nuget и потом автор post-factum зарегистрировал на себя package ID, то они также останутся в Nuget, останутся там навечно, никакой разрегистрации так называемой не будет.
5112.04 5118.28 "Анатолий Кулаков" Потому что мы очень много знаем примеров, когда тот же самый принцип разрегистрации абсолютно ломал пол интернета.
5118.28 5126.60 "Анатолий Кулаков" Дальше из интересного, для того, чтобы за вам зарегистрировать префикс, абсолютно каждый может это сделать.
5126.60 5140.36 "Анатолий Кулаков" Если у вас есть какие-то пакеты, начинающие с именем вашей компании, которые почему-то в паблике, или еще с вашего личного имени начинающиеся, то есть вы можете зарегистрировать для себя этот package ID, указав всего лишь на всю маску, которую вы хотите под себя подмять.
5140.36 5152.64 "Анатолий Кулаков" И интересная тема в шагах для регистрации заключается в том, что одним из шесть шагов там написано «отправьте email по такому-то адресу, для того, чтобы мы вас зарегистрировали».
5152.64 5157.40 "Анатолий Кулаков" Вот, мне кажется, очень хорошо отражает уровень современной автоматизации для разработчиков.
5157.40 5170.64 "Игорь Лабутин" Но с другой стороны позволяет точно пройти какой-то человеческий фактор проверки, потому что начнешь ты регистрировать какие-нибудь префиксы, типа Microsoft через русскую О, ну и вот такие штуки, знаешь.
5170.64 5174.64 "Анатолий Кулаков" Ну тебе же ничего не мешает после этого API отправить это человеку, правда?
5174.64 5175.64 "Анатолий Кулаков" Ну, выстави API.
5175.64 5179.64 "Игорь Лабутин" Ну, да, не знаю, не знаю.
5179.64 5189.76 "Игорь Лабутин" Видимо, решили посмотреть, как будет early preview, вот это все, landing page, типа присылайте ваши мейлы, а мы посмотрим, писать продукт, не писать продукт.
5189.76 5211.04 "Анатолий Кулаков" Ну, несмотря на early preview, уже знатные пакетописатели такие, как Bogart, Blumhart и прочие вот эти большие люди, которые пишут там топ-нугет пакетов, они уже зарегистрировали свой package ID и в твиттерах активно делятся мнениями о том, что там интересного, что у них получилось, что не так, что хотели бы изменить.
5211.04 5213.00 "Анатолий Кулаков" В общем, тоже интересно послушать.
5213.00 5220.04 "Анатолий Кулаков" Короче, сильный мир и миро-сего уже имеют свой package ID, ну и соответственно, нам тоже надо подтягиваться, надо свой собственный package делать.
5220.04 5223.96 "Игорь Лабутин" Срочно, срочно бежать, да, что-нибудь придумывать, почти как с доменными именами.
5223.96 5232.96 "Игорь Лабутин" Теперь будет, есть же в твиттере популярная, ну и не только в твиттере, наверное, тема, что это начиная новый сайт-проект, самое главное зарегистрировать правильный домен.
5232.96 5238.80 "Анатолий Кулаков" Именно так, а потом его еще верифицировать, чтобы стояла красивая какая-нибудь галочка, там или зеленый замочек или еще что-нибудь.
5238.80 5241.72 "Игорь Лабутин" Да, а потом забить и начать следующий сайт-проект.
5241.72 5246.88 "Игорь Лабутин" Вот, здесь будет так же, типа давай зарегистрируем значит какой-нибудь package ID, ну как более.
5246.88 5252.48 "Игорь Лабутин" Ну хотя здесь только маска, да, поэтому пакетов можно много делать, согласен.
5252.48 5263.40 "Игорь Лабутин" Ладно, давай потихонечку сворачиваться, у нас осталась последняя, пожалуй, тема, которую мы периодически поднимаем и в этот раз, наверное, тоже довольно важно рассказать.
5263.40 5266.16 "Игорь Лабутин" Это про другие подкасты, немножечко.
5266.16 5279.40 "Игорь Лабутин" Во-первых, наш дружественный подкаст, вот на этом More, в нем выходит огромное количество выпусков, но мы, я и Толя, с огромным удовольствием послушали выпуск про, не про, а с Сергеем Тепляковым.
5279.40 5294.68 "Игорь Лабутин" О, это прям супер выпуск, где Сергей, по-моему, чуть ли не 2 часа, довольно подробно рассказывал про свою историю, про то, как он дошел до жизни такой, до написания книжек, до работы в Microsoft и вот этого всего.
5294.68 5315.32 "Игорь Лабутин" А с другой стороны, как вообще подходить к поглощению всей этой информации, к получению этой информации и просто рекомендую послушать отличного умного человека, который много и хорошо рассказывает про какие-то такие практические вещи, которые довольно сильно откликаются, я бы сказал.
5315.32 5328.92 "Анатолий Кулаков" Несмотря на то, что я надеялся на какое-то техническое интервью в самом начале, когда я только увидел анонс, по факту в интервью очень много упоминались soft skills и вообще место разработчика среди различных команд, общения и так далее.
5328.92 5348.08 "Анатолий Кулаков" И это действительно было одно из лучших интервью, которые только я видел, несмотря на то, что там немного технических деталей, но очень много действительно такой программистской жизни, которую там и Сергей рассказывал и от Саши добавлял.
5348.08 5360.20 "Анатолий Кулаков" В общем, отлично действительно интервью и мы правда часто упоминаем рубрику нашу подслушанно и каким-то, наверное, само собой разумеющейся вещью считаем, что про .NET.RMO вы уже все знаете.
5360.20 5362.12 "Анатолий Кулаков" Вот, наверное, это не так.
5362.12 5365.92 "Анатолий Кулаков" Наверное, многие из наших слушателей не знают, а я напомню, что у нас есть дружественный подкаст.
5365.92 5374.24 "Анатолий Кулаков" В общем, у него тоже классные выпуски, они сейчас делают стримы на YouTube и их можно теперь не только слушать, как нас, но и немножко смотреть.
5374.24 5384.36 "Анатолий Кулаков" В общем, заходите, посмотрите, у них тоже и там темы поднимаются такие технические и не только технические, берутся интервью и много всего интересного проходит, поэтому тоже обратите внимание.
5384.36 5386.48 "Анатолий Кулаков" Вот, у нас еще есть одна новость.
5386.48 5391.08 "Анатолий Кулаков" Опять же, наверное, остаемся в рамках наших подкастов дружественных.
5391.08 5395.44 "Анатолий Кулаков" Вот, наши друзья запустили еще один подкаст.
5395.44 5399.48 "Анатолий Кулаков" Этот подкаст будет иметь формат книжного клуба.
5399.48 5407.92 "Анатолий Кулаков" Они выбрали прекрасную книгу от Microsoft «Как нужно писать красивую архитектуру», с учетом всяких докеров, шинок, интерпрайза и прочего этого.
5407.92 5411.72 "Анатолий Кулаков" В общем, книга действительно замечательная, в ней много чего рассматривается полезного.
5411.72 5424.36 "Анатолий Кулаков" И вот они в каждом выпуске берут какую-то часть, например, главу, читают ее и вместе с гостями обсуждают, какие выводы они из этого сделали, что им понравилось, что не понравилось, делятся своими практическими кейсами.
5424.36 5427.88 "Анатолий Кулаков" В общем, такой живой читальный клуб получается.
5427.88 5436.20 "Анатолий Кулаков" У них вышло сейчас буквально на данный момент первый выпуск, может быть, когда вы слушаете наш этот выпуск, может уже будет готов второй.
5436.20 5445.56 "Анатолий Кулаков" Поэтому зайдите, посмотрите, может вам тоже такая тема зайдет и вы к своему плейлисту добавите еще один замечательный подкаст.
5445.56 5448.48 "Игорь Лабутин" Ну а на этом мы будем завершаться.
5448.48 5455.00 "Игорь Лабутин" Я думаю, что хватит на сегодня рассмотрения разных тем.
5455.00 5466.20 "Игорь Лабутин" Мы поговорили про то, что нас, возможно, ждет в 11 C#, мы поговорили про мониторинг с разных сторон и про Open Telemetry, про то, как это все использовать с дотнет-монитором Prometheus и Меграфоной.
5466.20 5471.56 "Игорь Лабутин" Вспомнили старенький дотнет-фреймворк 4.8, куда внезапно забэкпортили много контейнерных улучшений.
5471.56 5481.20 "Игорь Лабутин" Обсудили YARP, релиз 1.0, это Toolkit, я бы сказал, да, или SDK для разработки, библиотека для разработки Reverse Proxy.
5481.20 5489.36 "Игорь Лабутин" Узнали, что MS Build внезапно Visual Studio 2022 может сломаться для вас, если вы используете 32-битные таски.
5489.36 5497.00 "Игорь Лабутин" Ну и посмотрели на InferSharp, который тоже вышел очередной релиз, это анализ из тул очередной для C#.
5497.00 5501.48 "Игорь Лабутин" Ну и узнали, что в Nuget'е вы теперь можете зарезервировать свой собственный префикс для пэкэджей.
5501.48 5514.36 "Анатолий Кулаков" Наверное, еще хотелось бы сказать, что не поверишь, но скоро Новый год, и по старинной многолетней традиции, точно так же, как и первый раз в прошлом году, мы планируем записать новогодний выпуск нашего подкаста.
5514.36 5534.64 "Анатолий Кулаков" Соответственно, в этом выпуске не будет никаких новостей, и мы обычно там рассказываем про внутреннюю кухню, что мы делали, как наш подкаст живет, сколько и где нас слушают людей, что внутри происходит, как мы делаем вообще этот подкаст, как мы собираем темы, и вот такие вот прочие вещи, которые касаются внутренней кухни, мы там обсуждаем.
5534.64 5547.92 "Анатолий Кулаков" Соответственно, у нас есть большой вопрос, что бы вы хотели в таком подкасте услышать, может быть, кого вы бы хотели услышать, и о чем бы нам интересным таком всем с вами вместе поговорить, для того, чтобы он был еще немножко и полезен для вас.
5547.92 5568.88 "Анатолий Кулаков" Соответственно, если у вас есть какие-то пожелания, о чем вы хотите нас расспросить, что вы хотите узнать о нас, о подкасте, о технологиях, об оборудовании, который мы используем, вот пишите это все в YouTube комментарии, мы все обязательно читаем, все обязательно отвечаем, и соответственно вместе потом подготовим такой интересный новогодний выпуск.
5568.88 5584.60 "Игорь Лабутин" Я бы даже сказал, не если вы что-то хотите узнать, а прям строго пишите, пишите, пишите, потому что иначе получится очередной какой-нибудь скучный выпуск, где мы поговорим, как мы находим темы в интернете, раскладываем их в трейлапах столбиком и потом обсуждаем, а потом монтируем.
5584.60 5589.88 "Анатолий Кулаков" Действительно, это не надо ни нам, ни вам, поэтому давайте сделаем что-нибудь интересное.
5589.88 5605.04 "Игорь Лабутин" Да, кидайте любые идеи, о чем можно поговорить, не обязательно про тот момент, не обязательно в формате, как мы делаем обычные выпуски, все что угодно, кидайте, мы из этого что-нибудь обязательно выберем, соорудим, придумаем новое, настроим сверху, сбоку, снизу и в общем,
5605.04 5614.48 "Анатолий Кулаков" что-нибудь получится. Ну, кстати, а если вы не знаете, каким образом готовится наш подкаст и присоединились к нам недавно, то послушайте прошлый новогодний выпуск, он получился довольно-таки миленьким.
5614.48 5617.84 "Игорь Лабутин" На этом, я думаю, 41 выпуск мы заканчиваем, с вами
5617.84 5621.78 "Анатолий Кулаков" был Игорь Лабутин и Анатолий Кулаков, всем пока! Пока!
5621.78 5628.02 None [музыка]
