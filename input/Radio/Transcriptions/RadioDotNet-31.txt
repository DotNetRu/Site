0.00 11.22 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер 31.
11.22 14.76 "Анатолий Кулаков" И я рад приветствовать вас в нашей студии.
14.76 17.48 "Анатолий Кулаков" И как всегда с вами Анатолий Кулаков.
17.48 18.48 "Анатолий Кулаков" И Игорь Лабутин.
18.48 19.48 "Анатолий Кулаков" Привет.
19.48 22.28 "Анатолий Кулаков" И вначале мы по традиции представляем наших патронов.
22.28 25.96 "Анатолий Кулаков" Огромное спасибо за помощь всем, кто нам помогает на Patreon и Boosty.
25.96 31.32 "Анатолий Кулаков" Всем, кто не помогает, заходите, заходите, посмотрите, может вам вдруг резко захочется помочь.
31.32 36.56 "Анатолий Кулаков" И самые наши любимые помогальщики - это Александр, Сергей и к ним добавился Владислав.
36.56 41.32 "Анатолий Кулаков" Приветствуем Владислав, спасибо, что присоединились к нашей дружной команде и интересному чатику.
41.32 55.36 "Анатолий Кулаков" Ну что ж, я надеялся за это время как-то отдохнуть, но команда Microsoft, наверное, решила нас загубить и поэтому наклепает анонсы нового .NET фреймворка с такой скоростью, что в принципе никаких сил не хватит это все обозревать.
55.36 58.72 "Анатолий Кулаков" Но в принципе мы, наверное, сможем.
58.72 59.72 "Анатолий Кулаков" Как Игорь, сможем?
59.72 66.12 "Игорь Лабутин" Постараемся, как раз к концу моего отпуска действительно Microsoft выкатила новый превью, это .NET 6 превью 5.
66.12 76.00 "Игорь Лабутин" Там довольно много разных изменений, в основном они в этот раз касаются основного .NET SDK и всего, что вокруг него, но мы пробежимся, как обычно, по всем кусочкам .NET.
76.00 85.84 "Анатолий Кулаков" Я заметил, стало много всяких именно tools, уже релизится, ну не релизится, а выпускаться в какие-то пробные беты и именно уже таких полноценных законченных каких-то историй.
85.84 87.72 "Анатолий Кулаков" Сразу видно, что уже скоро ревелис.
87.72 97.84 "Игорь Лабутин" Ну да, я думаю, что все эти tools как-то прототипировались в процессе прошлых превью и теперь обрели достаточно, так сказать, совершенства, чтобы быть показанными публике нормально.
97.84 98.84 "Игорь Лабутин" Пойдем по порядку.
98.84 105.16 "Игорь Лабутин" Порядок достаточно произвольный, ровно в том виде, в каком он встречается в статье.
105.16 127.40 "Игорь Лабутин" В прошлый раз мы упоминали, что в .NET SDK появилась концепция workloads, то есть вы теперь, когда ставите SDK, у вас появляется, как обычно, команда .NET, к которой вы можете говорить там .NET run, .NET watch, .NET build и все остальное, и у нее появилась новая подкоманда .NET workload, которая позволяет добавить к SDK какие-то недостающие или опциональные кусочки.
127.40 132.72 "Игорь Лабутин" Таким образом, например, добавляется MAUI, добавляется Ahead of Time Compilation, если я правильно помню.
132.72 145.88 "Игорь Лабутин" Так вот, теперь появилось две новых команды, можно теперь сказать .NET workload list, он покажет все возможные workloads, которые у вас есть, и .NET workload update, который проапдейтит их до последней версии.
145.88 149.16 "Игорь Лабутин" Ну, там есть набор ключиков, которые позволяют всем управлять.
149.16 164.32 "Игорь Лабутин" Это, ну, до некоторой степени очень похоже, как говорит Microsoft, на всякую работу package manager в Linux, типа apt-get, когда вы выберете apt-get update, он, соответственно, обновляет все это до последней, не breaking, так скажем, версии, да, в рамках текущей мажорной версии.
164.32 165.88 "Игорь Лабутин" То же самое происходит здесь.
165.88 180.58 "Анатолий Кулаков" Кстати, Microsoft тут недавно опять анонсировал, что они начинают снова уже какой круг двигать свой Windows package manager, который Vinget, и, в принципе, непонятно, они, получается, конкурировать у нас будут, потому что там тоже полноценный package manager, который есть в системе.
180.58 191.14 "Игорь Лабутин" Ну, я думаю, что Vinget это все-таки больше для приложений, например, и других вещей, а workload это именно кусочки SDK, то есть это такие чисто для программистов штуки.
191.14 199.10 "Анатолий Кулаков" Ну, workload ладно, а если у тебя там будут какие-нибудь tools, например, снять dump или проанализировать dump, то это вполне инструменты.
199.10 216.12 "Игорь Лабутин" Ну, и как раз-таки ты будешь ставить, то есть ты через .NET workload, я так понимаю, можно добавить новые команды, но workload это именно больше про-разработческую часть, а если тебе надо добавить новый .NET tool, то это действительно можно будет, наверное, сделать через Vinget и каким-то образом они будут решать, что с этим делать.
216.12 226.56 "Анатолий Кулаков" Да, workload я с тобой согласен, мне вот больше интересует там .NET dump и .NET trace и вот эти вот вещи, потому что это уже идут как полноценный инструмент для разработчика, и вот кому их отдадут?
226.56 229.86 "Игорь Лабутин" Посмотрим, пока непонятно на самом деле.
229.86 231.98 "Игорь Лабутин" Но пока пойдем дальше.
231.98 238.50 "Игорь Лабутин" Выкатили интересную штуку, новый кусочек тулинга, раз уж мы говорим про tooling, называется Nuget Package Validation.
238.50 245.22 "Игорь Лабутин" Есть вообще отдельная даже статья, без относительно анонса превью 5, которая описывает детали.
245.22 279.18 "Игорь Лабутин" И смысл этой штуки заключается в следующем, что поскольку у нас Nuget пакеты, мы теперь умеем, вообще всегда умели, но сейчас это становится очень важным, мультитаргетить на разные фреймворки SDK, и часть из них являются вообще говоря совместимыми, то есть если, например, вы что-то таргетите на .NET Standard и на .NET 5, то оба этих вариантов в принципе совместимы с .NET 6, и дальше там есть определенные правила по каким образом MSBuild при сборке будет выбирать ту или иную версию .DLL из вашего Nuget пакета, становится чрезвычайно важным.
279.18 294.62 "Игорь Лабутин" Пока вы жонглируете всякими if net standard и if net core внутри вашего кода сделать так, чтобы итоговые DLL выглядели одинаковыми с точки зрения API, то есть если у вас есть что-то в .NET Standard DLL, то было бы неплохо, чтобы это же самое было в .NET 5 DLL.
294.62 311.06 "Игорь Лабутин" Причем в .NET 5 DLL можно добавлять что-то новенькое, например, какой-нибудь там Span Based API, которого нет в .NET Standard, или какую-то очень специфичную штуку, которую вы хотите использовать конкретно в .NET 5, но поскольку они совместимы до некоторой степени, то все, что есть в .NET Standard нужно, чтобы было в .NET 5.
311.06 318.90 "Игорь Лабутин" И тут прям простор для творчества с точки зрения что можно сломать и простор для творчества с точки зрения что можно проверить.
318.90 325.78 "Игорь Лабутин" Тулинг сейчас поддерживает несколько валидаций и для начала нужно рассказать как его подключать.
325.78 337.98 "Игорь Лабутин" Подключается это через новый элемент, то есть если вы видели ваш .tsproj файлик, он у нас как всегда начинается с тега .project и там указывается SDK = attribute, Microsoft.NET SDK, например.
337.98 353.94 "Игорь Лабутин" Теперь внутри этого project элемента на уровне всех ваших property group и всего остального можно указать новый тег под названием SDK и там указать Microsoft.dotnet.package validation и указать там превьюшную версию специальную.
353.94 355.50 "Игорь Лабутин" В статье она написана.
355.50 365.18 "Игорь Лабутин" После этого у вас эта штука появится и будет автоматически при выполнении .NET Build или .NET Pack, я сейчас не вспомню, все это дело проверять.
365.18 366.70 "Игорь Лабутин" Что она умеет?
366.70 370.94 "Игорь Лабутин" Она умеет проверять Compatible Framework, как у них это называется.
370.94 397.18 "Игорь Лабутин" То есть то, про что я говорил, если у вас есть два фреймворка, они в каком-то смысле совместимы, то все методы из, как я говорил, примера .NET Standard должны присутствовать в .NET 5, потому что иначе при обновлении, допустим, какого-то приложения, которое раньше использовало .NET Standard версию, а теперь у него target поменяется на .NET 5, MS Build автоматически подхватит новую версию вашей .dll из NuGet пакета и что-то не соберется.
397.18 402.74 "Игорь Лабутин" Такого быть не должно у хороших NuGet пакетов, поэтому теперь это будет валидироваться и будет сыпаться ошибками во время сборки.
402.74 410.22 "Игорь Лабутин" Дальше они добавили штуку под названием Validation Against Baseline Package Version.
410.22 422.06 "Игорь Лабутин" То есть прямо там же в CSS Project можно указать специальную пропертиву под названием Package Validation Baseline Version и указать там версию пакета, NuGet пакета вашего, с которым нужно сравнить.
422.06 430.60 "Игорь Лабутин" И тогда эта штука будет проверять, ну, до некоторой степени соответствующей вере, насколько это можно сделать автоматическими средствами.
430.60 439.04 "Игорь Лабутин" То есть она будет говорить, что вы увеличили патч-версию, но при этом у вас удалился метод.
439.04 441.12 "Игорь Лабутин" Наверное, это нехорошо и ошибка.
441.12 442.12 "Игорь Лабутин" Ну, в таком духе.
442.12 447.24 "Игорь Лабутин" Еще одна штука, которая поддержана, это валидация для рантаймов.
447.24 471.48 "Игорь Лабутин" В NuGet пакете можно запихать специальные версии .dll для конкретных рантаймов, то есть у вас будет структура видна, как у вас там lib/net 5.0 или 6.0/bla-bla.dll, но конкретно для Linux, например, или для Windows вы можете запихать такую же .dll, но собранную специально для этого рантайма, в папочку под названием runtime/unix/lib/net 5.0/bla-bla.dll.
471.48 480.20 "Игорь Лабутин" И фишка заключается в том, что в Compile Time никогда не используется рантайм-версия, в Compile Time используется генерик-версия из просто lib.net что-нибудь.
480.20 489.96 "Игорь Лабутин" А вот в runtime, когда вы паблишите под конкретную операционку, то в runtime будет, конечно же, использоваться runtime/unix/lib/net 5.0/bla-bla.
489.96 500.52 "Игорь Лабутин" И если вдруг выясняется, что в .dll, который лежит в папочке runtime, нет каких-то методов, которые есть в генерик .dll, то у вас будет ошибка runtime, что метод не найден.
500.52 508.24 "Игорь Лабутин" Это нехорошо, поэтому когда вы делаете .netpack, вам будет ошибка, что на самом деле надо такое сделать и такой метод добавить.
508.24 511.72 "Игорь Лабутин" В общем, скорее всего, набор этих всех проверок будет, конечно, увеличиваться потихонечку.
511.72 518.68 "Игорь Лабутин" И думаю, что в следующих апдейтах, в следующих превью мы увидим еще больше улучшений вокруг этого.
518.68 520.96 "Игорь Лабутин" Но вообще направление правильное, мне кажется.
520.96 522.32 "Игорь Лабутин" Собирать хорошие nuget-пакеты.
522.32 531.52 "Анатолий Кулаков" Да, вообще хорошо, что такой инструмент появился, то есть задумались о том, что nuget-пакеты это уже давно не просто zip-архивчик, это очень сложная структура.
531.52 538.24 "Анатолий Кулаков" На сборку nuget-пакета иногда уходят огромные скрипты с тысячами строк для того, чтобы собрать правильные nuget-ики.
538.24 541.52 "Анатолий Кулаков" И совсем же очевидно, что действительно нужны какие-то проверки.
541.52 547.08 "Анатолий Кулаков" Меня пока из этого списка больше всего радует эта проверка для 7Vera.
547.08 550.92 "Анатолий Кулаков" Если оно действительно будет хорошо работать и сравнить API, то это будет просто бомба.
550.92 560.32 "Анатолий Кулаков" Потому что раньше уже были инструменты, которые пытались это сделать, пытались найти автоматический дифф между какими-то API и даже работали в другую сторону.
560.32 567.72 "Анатолий Кулаков" То есть они смотрели, что если есть breaking changes, они предлагали увеличить мажорную версию, если нет, увеличивали только патч-версию и так далее.
567.72 571.48 "Анатолий Кулаков" Ну почему-то все эти инструменты бросались, не допиливались и так далее.
571.48 575.04 "Анатолий Кулаков" Опять же, ни на кого нет надежды, кроме как на благословенный Microsoft.
575.04 577.84 "Анатолий Кулаков" Если он не сделает, то, наверное, никто не сделает.
577.84 586.00 "Игорь Лабутин" Но вот в статье у них пример как раз таки с тем, что вы берете и в существующий метод добавляете аргумент с дефолтным значением.
586.00 590.44 "Игорь Лабутин" С точки зрения compile-тайма это не breaking change.
590.44 595.60 "Игорь Лабутин" То есть вы просто перекомпилируете, ну как прокомпилировался, так он и останется компилироваться.
595.60 598.36 "Игорь Лабутин" Но с точки зрения бинарной compatibility это breaking change.
598.36 606.04 "Игорь Лабутин" Если у вас есть кто-то, кто зависит от ваших этих тейлелек, то бинарно он уже не сможет работать, потому что метод по сигнатуре не будет найден.
606.04 607.44 "Игорь Лабутин" Такое будет найдено.
607.44 633.60 "Игорь Лабутин" Плюс они говорят, что они также пытаются проверить, что код, который вы использовали, например, в версии вашей baseline, в текущей версии пакета и target framework, который вы теперь target, например, больше не работает или из-за deprecation или что-нибудь они там drop, ну как пример, не знаю, там WCF drop-нули, наверное WCF я никогда не буду анализировать, но тем не менее, как пример.
633.60 641.40 "Игорь Лабутин" Если вы target на 5.0, вам скажут "эээ, нет, в этом версии Nuget пакета вы WCF не можете target, потому что вы drop-нули support".
641.40 643.52 "Игорь Лабутин" Такие штуки они собираются проверять.
643.52 645.76 "Игорь Лабутин" Так что будем посмотреть.
645.76 646.76 "Игорь Лабутин" Поехали дальше.
646.76 660.96 "Игорь Лабутин" Ну, досыпали еще какое-то количество розлин аналайзеров, я не буду перечислять поименно, там порядка 6, по-моему, новых аналайзеров и добавили то, что называется custom guards для Platform Compatibility Analyzer.
660.96 676.80 "Игорь Лабутин" Мы рассказывали про Platform Compatibility Analyzer, это штука, которая позволяет атрибутикам supported-on-platform или unsupported-on-platform помечать какие-то методы, как доступны или недоступны на определенных платформах, на Linux, на Windows или еще на чем-то.
676.80 700.76 "Игорь Лабутин" И если аналайзер детексит, то вы, допустим, в каком-то из кусочков кода используете что-то, что только для Windows, но при этом вы это пакуете в какой-нибудь там дженериковый Nuget пакет без указания конкретной платформы, то это warning, и он предупредит, что вообще-то так, может быть, нельзя, потому что фактически, если вы этот метод дернете на неподдерживаемой платформе, вам прилетит платформа от support.
700.76 708.60 "Игорь Лабутин" Так вот теперь они добавили еще два новых атрибутика support.platform.guard и unsupported.platform.guard, который позволяет сделать следующее.
708.60 725.72 "Игорь Лабутин" Вы можете сделать явный API теперь, ну, грубо говоря, сделать у вас какой-нибудь флажок типа из Linux и на нем повесить этот атрибутик с суффиксом guard, а на методе, который рядом, поместить нормальный старенький атрибутик support.platform и только Linux.
725.72 731.68 "Игорь Лабутин" И это, по сути, очень похоже на nullable всякие annotation, там null if not null и так далее.
731.68 737.04 "Игорь Лабутин" И если guard вернул false, то это значит, что вот тот метод вызывать нехорошо.
737.04 748.80 "Игорь Лабутин" И аналайзер теперь умеет, видимо, проверять, что если вы этот метод вызываете только при условии проверки этого булевского флажка, который помечен на атрибутикам guard, то тогда этот метод вызывает типа ok даже из дженериковой версии.
748.80 767.84 "Игорь Лабутин" Ну, короче, Microsoft делает более сложными все свои аналайзеры, не знаю, на сколько это будет распространено, но скорее всего это нужно больше для каких-то таких вот действительно generic NuGet пакетов, где есть какая-то OS-specific штука, которую вы нормально в коде обрабатываете.
767.84 771.92 "Игорь Лабутин" И в Windows делай то, и в Linux делай сё, и тогда вот эти атрибутики помогут.
771.92 780.40 "Анатолий Кулаков" Ну, вообще, cross-platform это действительно тяжелая и сложная штука, и поэтому чем больше аналайзеров, чем больше инструментов туда внедрится, тем меньше у нас будет ошибок.
780.40 781.40 "Игорь Лабутин" Да.
781.40 786.64 "Игорь Лабутин" Следующая штука - это библиотечки, которые поставляет сам Microsoft.
786.64 800.32 "Игорь Лабутин" Если мы сейчас возьмем любой большой NuGet пакет официально от Microsoft, вы можете увидеть, что там поддержаны и какой-нибудь netstandard 1.1 в этом NuGet лежит, и там какой-нибудь netframework 4.5.1, и вот всякая такая штука.
800.32 811.96 "Игорь Лабутин" Теперь такого больше не будет, Microsoft сказал, что все официальные NuGet пакеты будут выходить только с таргетом не старее чем netframework 4.6.1, netcore 3.1 и netstandard 2.0.
811.96 817.44 "Игорь Лабутин" То есть никаких там таргетов netstandard 1.1 или netframework 4.5
817.44 819.44 "Анатолий Кулаков" уже не будет. Почему?
819.44 820.92 "Игорь Лабутин" Они даже объяснили, почему так сделано.
820.92 827.64 "Игорь Лабутин" На самом деле, если вы думали, что эти библиотечки все еще пересобираются для всяких старых фреймворков, это неправда.
827.64 850.00 "Игорь Лабутин" Они используют технологию, которую они называют harvesting, то есть если вы, например, они точнее собирают версию какого-нибудь NuGet пакета для очередной мажорной версии, то они делают следующее - сборки для 4.6.1, netcore 3.1, netstandard они делают по-честному, а например, длл для net какого-нибудь стандарта 1.1 они берут из прошлой версии пакета.
850.00 865.32 "Игорь Лабутин" Таким образом, как они говорят, во-первых, они уменьшат размер пакетов, потому что NuGet будет поменьше, во-вторых, они не будут вводить кастмеров в заблуждение, потому что может показаться, что раз версия NuGet пакета обновилась, ну наверное там какие-то патчи могут быть.
865.32 873.76 "Игорь Лабутин" Хотя на самом деле бинарно там длл лежат те же самые, которые лежали в прошлых версиях для старых фреймворков, потому что их никто не пересобирает никогда, они просто берутся из старых пакетов.
873.76 876.28 "Анатолий Кулаков" Погоди, а как же security там патчи и так далее?
876.28 878.28 "Анатолий Кулаков" Где support, где поддержка?
878.28 883.28 "Игорь Лабутин" Поддержка, support они в SDK и в этом самом, в самом фреймворке.
883.28 887.12 "Игорь Лабутин" То есть SDK поставь новый, там все будет, а в NuGet уже не будет.
887.12 900.60 "Анатолий Кулаков" Если у библиотечки, например, появилась security дыра и этот API торчит из стандарта 1.1, Microsoft зафиксил эту security дыру, он по твоему описанию для стандарта 1.1 не подложит уже правильную dll?
900.60 902.64 "Игорь Лабутин" Вроде как получается, что да.
902.64 904.00 "Анатолий Кулаков" Ну, это странно.
904.00 915.44 "Игорь Лабутин" Это действительно звучит странно с точки зрения саппорта, потому что формально эти самые старые фреймворки поддерживают столько, сколько поддерживается операционка, на которой они сделаны, для которой они были сделаны.
915.44 923.84 "Игорь Лабутин" То есть мы обсуждали это, что .NET фреймворк 3, 5, какой там, сервис пак 1 будет поддерживаться еще 5 или 6 лет что ли.
923.84 924.84 "Игорь Лабутин" Вот.
924.84 928.96 "Игорь Лабутин" Как вот это механизм NuGet'ов дружит с security патчами, я пока не понимаю.
928.96 929.96 "Игорь Лабутин" Как вот отсутствие.
929.96 932.20 "Игорь Лабутин" Но они утверждают, что этого и не было раньше.
932.20 937.32 "Игорь Лабутин" То есть все NuGet'ы, которые собирались до этого, там не было пересборки с патчами.
937.32 950.28 "Анатолий Кулаков" Ну, тогда действительно намного честнее было бы вообще не распространять старые стандарты, на которые они dll перекладывают, чтобы потребители хотя бы задумались, а почему ее нет, давайте или мигрировать, или как-то по-другому ставить.
950.28 959.04 "Анатолий Кулаков" Ну, не обманывать клиентов, потому что клиенты могут думать, что они получают фиксы со свежими NuGet пакетами, а они по правде ничего не получают.
959.04 960.04 "Игорь Лабутин" Да, вот.
960.04 963.04 "Игорь Лабутин" Это одна из причин, почему они перестают это делать теперь.
963.04 965.20 "Игорь Лабутин" Это прямо явно написано в статье.
965.20 966.20 "Игорь Лабутин" Пошли дальше.
966.20 967.20 "Игорь Лабутин" По библиотечкам.
967.20 970.00 "Игорь Лабутин" По библиотечкам очень много изменений.
970.00 978.84 "Игорь Лабутин" Во-первых, в Dependency Injection и API'шечках сделали в довесок к функции CreateScope, когда вы можете создать свой собственный скоп для DI.
978.84 982.24 "Игорь Лабутин" Теперь есть CreateAsyncScope, который корректно обрабатывает всякие iAsyncDisposable.
982.24 992.52 "Игорь Лабутин" Поэтому если вы что-то регистрировали в стандартном DI-контейнере, что реализовывало iAsyncDisposable, то теперь вы можете использовать CreateAsyncScope для правильного dispose.
992.52 997.72 "Игорь Лабутин" В JSON-сериалайзере стандартном, который System.Txt.JSON, заюзали Source-генераторы.
997.72 998.72 "Игорь Лабутин" Наконец-таки.
998.72 1004.04 "Игорь Лабутин" Пока это только в превью-версии, то есть вам нужно явно референсить превьюшную версию NuGet пакета.
1004.04 1008.24 "Игорь Лабутин" Но смысл заключается в том, что вы теперь делаете следующим образом.
1008.24 1021.16 "Игорь Лабутин" Вы берете, если вы хотите какой-нибудь классик сериализовывать через Source-генераторы, вы пишете, точнее, partial class, который вы наследуете от JSON-сериалайзер.Context.
1021.16 1030.04 "Игорь Лабутин" И у этого partial класса атрибутиком указываете тип того класса, который вы хотите, чтобы сериализовывался через Source-генераторы.
1030.04 1039.92 "Игорь Лабутин" Source-генератор дегенерирует, соответственно, код, который позволяет дальше написать JSON-контекст.default.имя типа вашего класса.serialize.
1039.92 1042.20 "Игорь Лабутин" Ну и передать туда, соответственно, ваш класс.
1042.20 1043.76 "Игорь Лабутин" То есть вы для сериализации...
1043.76 1055.08 "Игорь Лабутин" Можно вызвать, в принципе, и старенький метод, просто как обычный serialize, но туда тогда придется передать вот этот вот JSON-контекст.default, чтобы сериалайзер знал, откуда брать код для эффективной сериализации.
1055.08 1059.28 "Анатолий Кулаков" А есть уже performance замеры, потому что это должна быть просто бомба.
1059.28 1065.56 "Анатолий Кулаков" Она там в 100 тысяч 500 миллиардов раз быстрее, память не выделяет и вообще волосы делает шелковистыми и красивыми.
1065.56 1068.00 "Игорь Лабутин" Это правда должна делать.
1068.00 1069.56 "Игорь Лабутин" Мечмарки есть?
1069.56 1071.16 "Игорь Лабутин" Прям таких, чтоб в статье?
1071.16 1072.36 "Игорь Лабутин" Я не видел.
1072.36 1076.60 "Игорь Лабутин" Вот наверняка есть в каких-нибудь issues на GitHub.
1076.60 1080.92 "Анатолий Кулаков" Может пока превью, пока мерить рано, подождем релизика и сравним тогда.
1080.92 1082.96 "Игорь Лабутин" Ну там довольно много всего еще не поддержано.
1082.96 1087.44 "Игорь Лабутин" То есть там есть ряд limitations, которые не работают в этой штуке.
1087.44 1097.76 "Игорь Лабутин" Но по сути вот код, который генерится, соответственно, начинает использовать F8 JSON Writer напрямую и используется пока только для сериализации.
1097.76 1100.00 "Игорь Лабутин" Для deserializaci такого пока не придумали.
1100.00 1102.36 "Игорь Лабутин" То есть это только быстрая сериализация.
1102.36 1103.64 "Игорь Лабутин" Deserializaci все еще медленная.
1103.64 1112.92 "Игорь Лабутин" Но это действительно превью и скорее всего это может быть будет включено даже в основное SDK, а не как такой левый get-пакетик.
1112.92 1116.72 "Игорь Лабутин" Так что будут думать, что с этим делать.
1116.72 1123.00 "Игорь Лабутин" Дальше добавили WebSocket Compression, если вы пользуетесь WebSockets, то теперь можно их сжимать.
1123.00 1125.92 "Игорь Лабутин" Ну в смысле, трафик сжимать в них.
1125.92 1127.68 "Игорь Лабутин" Добавили поддержку SocksProxy.
1127.68 1137.20 "Игорь Лабутин" Если вы когда-нибудь пользовались классом WebProxy, ему можно было указать Socks.tp на стандартной прокси, теперь можно указать Socks4, Socks5 proxy и все будет работать само.
1137.20 1141.04 "Игорь Лабутин" И то, о чем мы довольно много говорили, поддержка OpenTelemetry.
1141.04 1147.24 "Игорь Лабутин" OpenTelemetry для всяких трейсов было поддержано уже довольно давно, сейчас добавили поддержку для метриков.
1147.24 1155.00 "Игорь Лабутин" То есть есть теперь специальный namespace SystemDiagnostics.metrics, где есть класс, который называется Meter.
1155.00 1166.24 "Игорь Лабутин" Создаете инстанс этого класса, у него вызывайте метод createCounter, ну и дальше этому каунтеру говорить там addD или еще что-нибудь, и он садестон репортит метрики по стандарту OpenTelemetry в нужное место.
1166.24 1171.92 "Игорь Лабутин" Так что теперь еще удобнее должно стать все это сводить в единое место в соответствии со всеми стандартами.
1171.92 1181.60 "Игорь Лабутин" Есть еще пачка изменений в библиотечках, это там улучшили performance работы с BigInteger в основном, со строчками, типа parsing, строчек с ними.
1181.60 1202.24 "Игорь Лабутин" А если вы помните, в .NET завезли нативные int, это два типа nint и nuint, с ними теперь умеет работать тип Vector, соответственно SIMD стали еще ближе, поддержку OpenSSL 3 и поддержку всяких специальных новых криптографических алгоритмов тоже завезли, посмотрите анонс там более детально.
1202.24 1206.60 "Игорь Лабутин" Так, чтобы еще интересного захайлайтить из изменений, interop.
1206.60 1218.52 "Игорь Лабутин" Я не знаю зачем, но скорее всего опять же ради кроссплатформенности и возможности написания кроссплатформенного C# кода у нас теперь есть нативный interop с Objective-C.
1218.52 1219.52 "Анатолий Кулаков" Ну погоди, как это зачем?
1219.52 1225.16 "Анатолий Кулаков" Единственная причина это IOS и прочие макофильские устройства.
1225.16 1227.60 "Анатолий Кулаков" Какая еще причина тебе нужна?
1227.60 1231.96 "Игорь Лабутин" Ну не знаю, писать все на C# и с Objective-C.
1231.96 1235.04 "Игорь Лабутин" Но видимо UI-чик все равно не написать без нативных вставок, поэтому приходится.
1235.04 1244.72 "Анатолий Кулаков" Ну там нативные сервисы наверняка, обращение к камере, OpenFileProvider и все вот эти духи, то есть взаимодействие с системой эти все равно нужно делать.
1244.72 1245.72 "Игорь Лабутин" Да, это правда.
1245.72 1250.48 "Игорь Лабутин" Ну в общем теперь есть, в каком-то начальном виде по крайней мере будет дальше улучшаться.
1250.48 1251.48 "Игорь Лабутин" Диагностика.
1251.48 1263.48 "Игорь Лабутин" Мы много говорили про всякие InventPipe и прочие современные методы диагностики Core-CLR, но надо помнить, что у нас есть два рантайма, есть Core-CLR и есть Mono, которые используются для кроссплатформенности во многих местах.
1263.48 1290.32 "Игорь Лабутин" Так вот теперь в Mono Runtime завезли все те уже улучшения, которые были раньше мы знали в обычном CLR Runtime, то есть там теперь есть EventPipe и всякие диагностики и соответственно теперь можно использовать всякие тулы типа .NET Trace, Perfuse, Pitscope и все остальные штуки с Mono и получать такие же обычные файлики, как мы получали от Core-CLR и их анализировать всеми уже известными и готовыми тулами.
1290.32 1291.32 "Игорь Лабутин" Это прям хорошо.
1291.32 1304.60 "Игорь Лабутин" И чуть-чуть или не чуть-чуть на самом деле улучшили код кен, всякие там Head of Time и прочие штуки, про которые я не буду сильно распространяться, там просто огромный список изшисов на GitHub, что улучшили, посмотрите, если интересно.
1304.60 1307.40 "Игорь Лабутин" Так, на этом все про основной .NET SDK.
1307.40 1310.40 "Анатолий Кулаков" Что у нас интересного появилось в ASP.NET?
1310.40 1318.44 "Игорь Лабутин" В ASP.NET, если помните, мы обсуждали горячую тему .NET Hot Reload, там добавилось несколько улучшений.
1318.44 1339.20 "Игорь Лабутин" Во-первых, в прошлый раз, некоторое время назад мы рассказывали, что чтобы включить Hot Reload для сценариев с .NET Watch нужно было менять Launch Settings JSON, теперь этого не нужно и это работает само, но тогда нужна возможность это отключить, если вам это не надо, в .NET Watch появился новый параметр No Hot Reload, если вам это вдруг почему-то не надо.
1339.20 1345.92 "Игорь Лабутин" Дальше Single Page Application Template обновили на 11-й Angular и 17-й React, если это кому-то важно.
1345.92 1350.92 "Игорь Лабутин" Дальше взяли Blazor WebAssembly и уменьшили ее размер.
1350.92 1352.40 "Игорь Лабутин" Смысл в чем?
1352.40 1366.52 "Игорь Лабутин" Мы много рассказывали про всякий там Trimming, убивание ненужных сборок и всего остального, но в случае с WebAssembly есть еще основной собственно код WebAssembly, который распространялся, который в виде Delay грузился один раз.
1366.52 1372.88 "Игорь Лабутин" И в нем на самом деле довольно много функциональности, которые отжирают кучу места, но которые пользуются не так много приложений.
1372.88 1382.84 "Игорь Лабутин" Например, если ваше приложение не использует ничего из глобализации, то есть всяких переводов на кучу языков и так далее, то зачем вам грузить кучу лишнего кода, а кода там много.
1382.84 1392.00 "Игорь Лабутин" И теперь компилятор на самом деле умеет выкинуть лишнее и в Publish папочку сложить только нужные кусочки от этого WebAssembly Runtime.
1392.00 1395.84 "Игорь Лабутин" Там что-то типа процентов до 50 улучшения по размеру.
1395.84 1396.84 "Игорь Лабутин" Впечатляет.
1396.84 1408.36 "Игорь Лабутин" Дальше в Kestrel добавили подкатегории для локирования, то есть раньше Kestrel все локировал под Microsoft S/P/NetCore и Server Kestrel с такой категорией.
1408.36 1414.60 "Игорь Лабутин" Теперь есть несколько дополнительных подкатегорий, которые позволят более точно настроить вам логи, если надо.
1414.60 1423.00 "Игорь Лабутин" Для HTTP-хедеров завезли более быстрые getter, inter, и setter, там чуть-чуть оптимизировали доступ к внутренним словарикам и кэшам.
1423.00 1426.92 "Игорь Лабутин" Соответственно, теперь для основных хедеров у вас есть просто готовые прямо property.
1426.92 1437.04 "Игорь Лабутин" То есть можно будет писать там что-нибудь типа reqwest.headers.to или там reqwest.headers.cache.
1437.04 1446.00 "Игорь Лабутин" Какие-то были доступны и раньше, но сейчас добавили несколько новых популярных хедеров, которые так и делают, и с которыми так нужно работать теперь, будет быстрее.
1446.00 1458.60 "Игорь Лабутин" И для EISA, именно для конфигурации EISA теперь буфер по умолчанию на прием данных он 1 мегабайт, а не 64 килобайта, потому что приложения стали больше, данных пересылается больше, 64 килобайта уже не так много.
1458.60 1472.92 "Игорь Лабутин" Если же у вас приложение все-таки потребляет не очень много на каждый запрос, и вам не хочется тратить по мегабайту буфера на каждый входящий запрос, который уже не используется, все это все еще можно настроить через конфигурацию EISA server options.
1472.92 1474.68 "Игорь Лабутин" И это все в S/Penet Core.
1474.68 1476.92 "Анатолий Кулаков" Так, и Entity Framework нас чем-нибудь порадовал?
1476.92 1485.32 "Игорь Лабутин" Да, по сравнению с 4-й версией, 4-й превью, где особо их изменений не было и были bugfixes, в 5-й появилась одна фича, называется compiled models.
1485.32 1490.12 "Игорь Лабутин" То есть во время выполнения запроса, что делает Entity Framework?
1490.12 1515.12 "Игорь Лабутин" Он, понятно, настраивает db-контекст, в частности вызывает такой метод, называется он model creating, где вы можете переопределить все ваши связи моделей друг с другом, какие-то constraints, вот он все это и выполняет, анализирует и строит некоторое внутреннее дерево того, как выглядит ваша модель, что позволяет ему потом нормально переводить ваши link-use-запросы в нормальный SQL.
1515.12 1519.84 "Игорь Лабутин" Так вот, эта сборка модели занимает довольно ощутимое время.
1519.84 1520.84 "Игорь Лабутин" Теперь можно сделать следующее.
1520.84 1551.20 "Игорь Лабутин" Можно сказать .NET EF db-контекст optimize и в вашей папочке с вашим проектом указать output, директорию и namespace, и там сгенерятся некоторые файлики, которые потом вы в своем коде пишите options.use_model от вот этого нового namespace.tot_class, который сгенерится, .instance, и по сути там лежит некоторое бинарное представление этих моделей, уже собранных один раз заранее.
1551.20 1552.88 "Игорь Лабутин" То есть, что делает этот tool?
1552.88 1574.64 "Игорь Лабутин" Он на самом деле грузит ваш код в память, исполняет его, то есть выполняет все ваши onModel_creating, вот это все, и полученный результат в некотором бинарном виде записывает туда, в специальный кэш-файлик, грубо говоря, который потом во время исполнения, во время в рантайме, можно быстро загрузить, быстро распарсить, и не нужно уже выполнять ваш код, у вас все есть.
1574.64 1584.88 "Игорь Лабутин" Там прям какой-то супер-буст по производительности, миллисекунды до старта, до результата первого запроса получаются, в отличие от долей секунды до этого.
1584.88 1600.00 "Игорь Лабутин" Но есть некоторое количество ограничений, есть всякие неподдержимые фичи, типа там lazy-loading неподдержанно, если у вас есть какие-то кастомные model-cache, тоже не будут поддержаны.
1600.00 1611.68 "Игорь Лабутин" И естественно, вот этот .NET EF нужно вызывать каждый раз, когда вы меняете модель, потому что иначе модель и ее кэш, который бинарно лежит на диске, разойдутся и работать будет не очень много всего.
1611.68 1629.28 "Игорь Лабутин" Но тем не менее, если вам важно стартап-тайм, если вам важно, чтобы ваши запросы выполнялись очень быстро и не тратилось время на воссоздание db-контекста, а мы помним, что db-контекст мы создаем довольно часто, хотя его там теперь пулят, и может быть это уже не так критично, то посмотрите в сторону Compiled Models, может быть будет интересно.
1629.28 1631.96 "Игорь Лабутин" Для больших моделей, для больших баз, наверное, это актуально.
1631.96 1634.00 "Анатолий Кулаков" Ну что, со всеми новинками ты закончил?
1634.00 1639.32 "Игорь Лабутин" В MAUI еще обновилось, тоже вышло превью 5.
1639.32 1649.80 "Игорь Лабутин" Там просто некоторое количество добавлений и обновлений, они добавили анимации, они обновили некоторые UI-компоненты, которые теперь полностью поддерживают архитектуру хендлеров, про которые мы рассказывали несколько выпусков назад.
1649.80 1655.44 "Игорь Лабутин" И они еще больше приблизились к Single Project Template.
1655.44 1671.64 "Игорь Лабутин" То есть, как я рассказывал, у них есть цель, чтобы, несмотря на всю кроссплатформенность, у вас был единый проект, из которого можно запустить любой UI, ну в смысле любой платформы для Android, для iOS, сейчас они добились того, что все можно сделать из одного проекта, кроме WinUI.
1671.64 1674.16 "Игорь Лабутин" WinUI сейчас отдельный проект, теперь вам нужно всего два.
1674.16 1677.36 "Игорь Лабутин" Но обещают, что постараются сделать, чтобы все-таки было ровно один.
1677.36 1678.36 "Игорь Лабутин" И на этом все.
1678.36 1683.20 "Анатолий Кулаков" Все равно как-то для новых UI, которые должны объединить всех, мало-мало новостей выходит.
1683.20 1689.56 "Анатолий Кулаков" А где там новые компонентики, новые интересные связки, какие-то интеграции, что это такое, добавили анимации.
1689.56 1690.72 "Анатолий Кулаков" Как-то не глобально это.
1690.72 1698.56 "Игорь Лабутин" Но я думаю, что им бы пока привести старый в нормальный вариант, так сказать, и поддержать все, что они обещали с изменением архитектуры и так далее.
1698.56 1705.48 "Игорь Лабутин" Поэтому я думаю, что они там плотно заняты допиливанием существующего под новую архитектуру, а потом уже будут добавлять новые.
1705.48 1706.48 "Анатолий Кулаков" Ну, ясно.
1706.48 1709.76 "Анатолий Кулаков" Давай попробуем ближе посмотреть непосредственно к классикам.
1709.76 1716.04 "Анатолий Кулаков" Я тут набрал на статейку, где немножко описывается новые нововведения в коллекции.
1716.04 1719.52 "Анатолий Кулаков" Итак, в DotNet 6 что за нас ждет?
1719.52 1722.88 "Анатолий Кулаков" Прежде всего, интересный метод появился - nShu capacity.
1722.88 1728.12 "Анатолий Кулаков" Этот метод, который был добавлен в лист, в Дженни Нериковый лист - stack.eq.
1728.12 1736.36 "Анатолий Кулаков" Этот метод создан для того, чтобы вызывать его перед большой вставкой в коллекции какого-то большого сета.
1736.36 1743.40 "Анатолий Кулаков" И он принимает в качестве аргумента ожидаемый размер этой будущей коллекции.
1743.40 1754.40 "Анатолий Кулаков" Служит он для того, чтобы просто один раз заресадить коллекцию и не выполнять регулярные ресайзы, которые были бы у вас при вставке большого количества элементов.
1754.40 1757.28 "Анатолий Кулаков" Соответственно, метод очень полезный.
1757.28 1763.68 "Анатолий Кулаков" Относится он к нашей теме, которую мы давно тянем, про указывание каунта всегда при работе с большими коллекциями.
1763.68 1772.84 "Анатолий Кулаков" Вот теперь вы можете его не только указывать в конструкторе, но и если вам вдруг это стало известно где-то посреди операции, то тоже один раз заресайзить.
1772.84 1777.28 "Анатолий Кулаков" Интересно, что одним из особняков стоит generic collection.
1777.28 1778.76 "Анатолий Кулаков" То есть просто простая коллекция.
1778.76 1780.28 "Анатолий Кулаков" Ей такого метода не добавили.
1780.28 1786.00 "Анатолий Кулаков" А все потому, что по идеологии коллекция может быть неким враппером над другими коллекциями.
1786.00 1788.24 "Анатолий Кулаков" Например, над observable collection.
1788.24 1798.40 "Анатолий Кулаков" И observable collection никакого ensure capacity предоставить не может, потому что это не соответствует ее идеологическому предназначению.
1798.40 1808.80 "Анатолий Кулаков" Поэтому, если вы хотите работать с большими массивами данных, добавлять их, указывать размер и так далее, то не надо использовать collection, используйте list.
1808.80 1815.52 "Анатолий Кулаков" Итак, дальше есть интересное нововведение, но оно немножко скрытое.
1815.52 1816.52 "Анатолий Кулаков" Сейчас подробнее расскажу.
1816.52 1823.44 "Анатолий Кулаков" Наверное, многие из вас уже знают, что существует такая вещь как ref-returns.
1823.44 1826.52 "Анатолий Кулаков" Создан он в основном для специальных структур.
1826.52 1829.04 "Анатолий Кулаков" Со структурами есть большая проблема.
1829.04 1834.76 "Анатолий Кулаков" Нет, на самом деле со структурами огромное количество проблем, но мы сейчас с вами рассмотрим одну.
1834.76 1836.56 "Анатолий Кулаков" Наиболее популярную.
1836.56 1838.72 "Анатолий Кулаков" Это как мы изменяем структуры.
1838.72 1842.36 "Анатолий Кулаков" Очень часто при изменениях структуры неявно создаются копии этих структур.
1842.36 1847.84 "Анатолий Кулаков" И когда вы меняете какое-то поле в копии, естественно оригинал никаких изменений не получает.
1847.84 1851.60 "Анатолий Кулаков" И отсюда бывают иногда совсем неочевидные для новичков ошибки.
1851.60 1853.72 "Анатолий Кулаков" Есть специальный подход.
1853.72 1863.12 "Анатолий Кулаков" Вы просто-напросто создаете копию явно, продуманно, меняете там нужные поля, которые вам нужны и заменяете полностью старую структуру на новую ее копию.
1863.12 1866.40 "Анатолий Кулаков" Этот подход отлично работает, если структуры у вас небольшие.
1866.40 1870.88 "Анатолий Кулаков" Но если структуры большие, то каждый раз создавать копию уже становится накладно.
1870.88 1880.32 "Анатолий Кулаков" Вот для этого в 7 C# была придумана такая штука, как ревссылка на элемент массива.
1880.32 1890.88 "Анатолий Кулаков" То есть вы можете положить ваши структурщики в массив и вместо того, чтобы доставать элемент из массива, модифицировать его и обратно складывать, вы можете обратиться к элементам по ссылке.
1890.88 1896.68 "Анатолий Кулаков" По ссылке уже непосредственно отредактировать структуру без всякой копии и оставить его в массиве.
1896.68 1898.88 "Анатолий Кулаков" Все прекрасно будет работать.
1898.88 1905.52 "Анатолий Кулаков" Этот подход настолько понравился разработчикам, что они решили сделать ту же самую вещь, но для словарей, для дикшнери.
1905.52 1915.20 "Анатолий Кулаков" Подход им конечно понравился, но они не стали этот подход выставлять так же удобно, так же красиво, как и для массивов.
1915.20 1924.48 "Анатолий Кулаков" Они спрятали это за специальным страшным методом, который находится в классе Collection Marshall и метод называется Get Value Ref or Null Ref.
1924.48 1931.36 "Анатолий Кулаков" Это специальный метод, который обращается к элементу словаря и достает его оттуда по ссылке.
1931.36 1937.32 "Анатолий Кулаков" Таким образом вы можете этот элемент точно так же изменить не создавая копию и он изменится непосредственно в своем словаре.
1937.32 1951.64 "Анатолий Кулаков" Никакого экстеншн метода для словаря сделано не было специально, потому что оригинальные разработчики CLR испугались, что разработчики мы с вами можем неправильно его использовать.
1951.64 1963.36 "Анатолий Кулаков" Поэтому если вам это очень нужно, то для какой-то специальной тонкой оптимизации можете воспользоваться такими страшными неговорящими названиями.
1963.36 1967.80 "Анатолий Кулаков" Естественно в ежедневной практике вы этого использовать не будете.
1967.80 1977.32 "Анатолий Кулаков" Еще один интересный момент, что для того чтобы проверить Ref на результат, есть специальный метод CompileService.UnsaveIsNullRef.
1977.32 1984.20 "Анатолий Кулаков" Просто так вы не можете проверить Ref структуру, есть ли в ней результат или там вернулся какой-нибудь null.
1984.20 1989.80 "Анатолий Кулаков" То есть там вернулся какой-нибудь Default Value, обозначающий, что структура не была найдена в дикшенере.
1989.80 1990.80 "Анатолий Кулаков" Тоже забавный подход.
1990.80 1995.48 "Анатолий Кулаков" Следующее нововведение касается сериализации словарей.
1995.48 2006.96 "Анатолий Кулаков" В принципе, наверно для кого не секрет, что сериализовать обычную коллекцию с наполненными элементами это просто и этим занимаются уже практически все сериализаторы.
2006.96 2009.72 "Анатолий Кулаков" Никаких проблем изначально с этим не было.
2009.72 2015.56 "Анатолий Кулаков" Но старенькие разработчики наверняка помнят, что сериализовать дикшенери было не так уж и просто.
2015.56 2023.60 "Анатолий Кулаков" В первых версиях, когда у нас еще не было JSON, например в первых версиях XML сериалайзера, он не мог сериализовать дикшенери вообще.
2023.60 2025.16 "Анатолий Кулаков" И в принципе это неспроста.
2025.16 2036.16 "Анатолий Кулаков" Потому что в отличии от обычного списка, сериализация коллекций, которые имеют внутри себя хеширование, не так проста, как хотелось бы.
2036.16 2039.56 "Анатолий Кулаков" Например, это тот же самый хеш-сет или дикшенери.
2039.56 2046.92 "Анатолий Кулаков" У них внутри есть хеш, у них внутри есть и компараторы, которые сравнивают элементы, высчитывают хеш и так далее.
2046.92 2057.32 "Анатолий Кулаков" Сложность здесь заключается в том, что необходимо также вместе с контентом просериализовать алгоритм, который используется для хеширования, который используется для сравнения.
2057.32 2066.64 "Анатолий Кулаков" Например, это может быть компараторы, зависящие от культуры или независящие, которые используют культуру Ordinal.
2066.64 2071.60 "Анатолий Кулаков" Или компараторы, которые сравнивают строки с учетом регистра или без учета регистра.
2071.60 2080.14 "Анатолий Кулаков" Естественно децерализатор должен всю эту информацию иметь при децерализации для того, чтобы правильно восстановить дикшенери и сделать именно то, что рассчитывается.
2080.14 2087.04 "Анатолий Кулаков" В большинстве случаев всякие халатные сериализаторы этим пренебрегают, но по-хорошему это надо было бы учитывать.
2087.04 2093.72 "Анатолий Кулаков" Итак, в основном эти проблемы относятся к словарям, у которых ключ в виде строки.
2093.72 2098.12 "Анатолий Кулаков" В принципе, все остальные словари тут проходят нормально.
2098.12 2103.44 "Анатолий Кулаков" И именно для таких частных узких случаев и было добавлено некое нововведение.
2103.44 2108.64 "Анатолий Кулаков" А заключается оно в том, что теперь StringCompire приобрел два дополнительных метода.
2108.64 2116.20 "Анатолий Кулаков" Из WellNow OrdinalCompire, который принимает в качестве аргумента компаратор и из WellNow CultureAwareCompire.
2116.20 2126.04 "Анатолий Кулаков" Вот эти два метода помогают сериализаторам определить, используются ли в наших хеширующих компонентах уже стандартные какие-то дефолтные компараторы.
2126.04 2131.24 "Анатолий Кулаков" И если они используются, они могут эту информацию каким-то образом передать и при децерализации использовать.
2131.24 2144.48 "Анатолий Кулаков" Естественно, это покрывает не 100% случаев, но если мы с вами задумаемся, то в принципе в тех словарях, которые мы передаем по сети, которые мы стараемся децерализовать, обычно никакие извращенные компараторы не юзаются.
2144.48 2146.92 "Анатолий Кулаков" Юзаются максимум вот эти стандартные системные.
2146.92 2155.12 "Анатолий Кулаков" И в принципе тогда, имея вот этих два волшебных новых метода, мы покрываем 100% юзкейсов.
2155.12 2162.00 "Анатолий Кулаков" Вот если вы используете что-то страшное, что-то кастомное, что-то извращенное, то наверное не судьба.
2162.00 2164.72 "Анатолий Кулаков" Здесь это изменение вам все еще не поможет.
2164.72 2166.36 "Анатолий Кулаков" Но не делайте так.
2166.36 2169.68 "Анатолий Кулаков" Приорити-кью добавилась в дотнер 6.
2169.68 2172.08 "Анатолий Кулаков" В принципе мы ее уже упоминали.
2172.08 2175.20 "Анатолий Кулаков" Здесь хотелось бы упомянуть несколько забавных фактов, которые я нашел.
2175.20 2182.92 "Анатолий Кулаков" Прежде всего приорити-кью это очередь, в которую вы не просто можете добавить элементы, но и каждому элементу привязать какое-то приорити.
2182.92 2188.80 "Анатолий Кулаков" И элементы будут доставаться не по мере того, как вы их добавляли, а еще с учетом приоритета.
2188.80 2194.52 "Анатолий Кулаков" Прежде всего разработчики решили, что приоритет менять нельзя.
2194.52 2199.32 "Анатолий Кулаков" То есть бывают такие структуры, где вы сначала добавляете элементы, указываем приоритет, а потом можете его поменять.
2199.32 2200.32 "Анатолий Кулаков" Вот.
2200.32 2205.60 "Анатолий Кулаков" В дотнете приоритет менять нельзя, только его можно задавать при добавлении непосредственно самого элемента.
2205.60 2210.24 "Анатолий Кулаков" Это специально было сделано для того, чтобы увеличить скорость работы с этими структурами.
2210.24 2213.64 "Анатолий Кулаков" И скорость получилось увеличить в 2, а то и в 3 раза.
2213.64 2216.12 "Анатолий Кулаков" Вот благодаря такому маленькому решению.
2216.12 2221.16 "Анатолий Кулаков" Может быть для некоторых не очень удобно, но на практике очень даже хорошо для большинства.
2221.16 2233.12 "Анатолий Кулаков" И также если вы добавляете элементы с одним и тем же приоритетом, здесь встает вопрос, каким образом коллекция должна выдать вам эти элементы.
2233.12 2239.96 "Анатолий Кулаков" По мере добавления теперь уже считать, как настоящие АКЮ, или в принципе без всяких гарантий.
2239.96 2241.44 "Анатолий Кулаков" Как захочет, так и выдаст.
2241.44 2246.76 "Анатолий Кулаков" Главное, что приоритеты у нее совпадают, а элементы могут уже быть разными.
2246.76 2251.88 "Анатолий Кулаков" Опять же, разработчики пошли на то, что никакой стабильности и предсказуемости здесь нет.
2251.88 2259.80 "Анатолий Кулаков" Коллекция очередь выдает элементы в порядке приоритета, но порядок добавления элементов не учитывается.
2259.80 2267.84 "Анатолий Кулаков" Это сделано для того, чтобы не завязывать внутреннюю структуру, внутренние алгоритмы и внутренние оптимизации под вот это жесткое требование.
2267.84 2271.28 "Анатолий Кулаков" И благодаря этому тоже мы получили буст производительности.
2271.28 2275.56 "Анатолий Кулаков" Также у Priority Queue нет реализации интерфейса IEnumerable.
2275.56 2286.04 "Анатолий Кулаков" Это сделано для того, чтобы не гарантировать никакой порядок, не гарантировать правильный обход и не гарантировать того, что два обращения к Enurbal дадут тебе один и тот же результат.
2286.04 2291.64 "Анатолий Кулаков" То есть все это развязывает руки внутренней реализации для того, чтобы сделать ее максимально удобной по перформансу.
2291.64 2295.60 "Анатолий Кулаков" Но за это мы получаем вот такие небольшие минусы в API.
2295.60 2299.76 "Игорь Лабутин" Мне кажется, что Priority Queue ты будешь использовать вряд ли в тех местах, где тебе нужно.
2299.76 2308.88 "Игорь Лабутин" Честное IEnumerable, то есть это скорее какие-то промежуточные буферы и там скорее всего более сложная логика выборки, чем просто IEnumerable.
2308.88 2316.84 "Анатолий Кулаков" Скорее всего да, в принципе все эти решения довольно понятно почему были приняты.
2316.84 2321.00 "Анатолий Кулаков" То есть здесь понятны минусы и плюсы и решения, мне кажется,
2321.00 2323.00 "Игорь Лабутин" правильные. Окей, пошли дальше.
2323.00 2327.44 "Игорь Лабутин" Помимо DotNet 6 Preview 5 у нас вышли новые Visual Studio.
2327.44 2332.52 "Игорь Лабутин" Во-первых, вышла Visual Studio 2019, 2016, 2011 Preview 2.
2332.52 2334.52 "Игорь Лабутин" Это уже вторая превьюшка.
2334.52 2339.64 "Игорь Лабутин" Новый и на самом деле последний версии студии 2019.
2339.64 2346.76 "Игорь Лабутин" То есть Microsoft сказала, что 2019, 2016, 2011 будет последняя официальная версия 2019 студии.
2346.76 2349.16 "Игорь Лабутин" Все дальнейшее будет уже в 22 студии.
2349.16 2359.36 "Игорь Лабутин" Но сколько еще выйдет превью для 2016, 2011 мы не знаем и скорее всего финал конечно будет где-то в районе релиза DotNet 5, о, DotNet 6 в октябре.
2359.36 2368.88 "Игорь Лабутин" И в Preview 2 ничего нового, там только bugfixes, если интересно почитайте, вот с нее там все конкретно прописано, что конкретно они пофиксили и наверное может быть.
2368.88 2375.24 "Анатолий Кулаков" То есть ты намекаешь на то, что с новым DotNet нам новую студию не дадут, мы по-прежнему будем сидеть на 2019.
2375.24 2383.68 "Игорь Лабутин" Да, когда анонсировали 2022, по-моему были слова про то, что официальный релиз будет только в следующем году, она не зря называется 2022.
2383.68 2385.92 "Игорь Лабутин" То есть 64 бита мы все еще ждем.
2385.92 2386.92 "Игорь Лабутин" Ждем.
2386.92 2397.64 "Игорь Лабутин" Вышла на самом деле Preview 1, 64 битная, то есть это самый первый Preview и если вы хотите посмотреть что такое 64 битная студия, качайте версию 2022, она доступна.
2397.64 2404.88 "Игорь Лабутин" Это пока то, что они называют Initial Preview, там нет никаких функциональных изменений, кроме того, что она собственно 64 битная.
2404.88 2414.52 "Игорь Лабутин" Там конечно же не будут работать никакие экстенджины, потому что они еще не спортированы туда, но может какие-то уже, но их крайне мало.
2414.52 2422.64 "Игорь Лабутин" И основная цель это просто посмотреть как это все работает и возможность начать портировать эти экстенджины.
2422.64 2437.12 "Игорь Лабутин" В частности, Mads Christensen, я его считаю одним из самых плодовитых разработчиков экстенджинов, у него их там десятки разработаны, он же является одним из лидов в команде Visual Studio по экстенджинам.
2437.12 2456.96 "Игорь Лабутин" Он тут вот буквально скоро или к моменту выхода подкаста уже недавно будет вести лайв стрим на тему того, как мигрирует экстенджин, поэтому если вы вдруг являетесь автором какого-нибудь экстенджина и хотите спортировать его на 64 битную студию, посмотрите, скорее всего он расскажет все подробно, как, что и куда сделать.
2456.96 2465.60 "Игорь Лабутин" А вот в Preview 2, который будет, непонятно когда, но будет, Microsoft уже обещала какие-то новые фичи новой студии, но какие пока непонятно.
2465.60 2474.52 "Анатолий Кулаков" Отлично, ждем новую студию, хвала богам, что появился Preview 1, уже можно будет это потрогать, уже можно адаптировать экстенджины, в принципе красота.
2474.52 2475.52 "Анатолий Кулаков" Да.
2475.52 2495.92 "Анатолий Кулаков" И вот, Michel Lander продолжает нас радовать своим графоманством, у него запустилась интересная серия статей под темой конверсейшенов, здесь он собирает каких-то именитых людей в Microsoft по определенной теме и делает небольшой обзор того, что творится в той или иной области.
2495.92 2506.32 "Анатолий Кулаков" Несколько уже таких конверсейшенов мы с вами рассмотрели, и я предлагаю взглянуть на еще один занятный диалог, это Conversation about Diagnostics.
2506.32 2519.60 "Анатолий Кулаков" Ничего такого большого нового, что мы не обсуждали, наверное, в нем не будет, но подвести такой краткий самый, посмотреть, что творится в этой области до релиза, что нас ждет во время релиза, мне кажется, будет занятно и интересно.
2519.60 2522.80 "Анатолий Кулаков" Поэтому посмотрим, кого сегодня Michel Lander к нам пригласил.
2522.80 2537.76 "Анатолий Кулаков" Это специалисты, которые непосредственно участвуют в разработке тулзов для диагностики, они покрывают очень много всего, там и непосредственно рантаймы, и инструментарий, и классики, и много-много всего интересного.
2537.76 2543.52 "Анатолий Кулаков" Прежде всего разговор шел о трех вещах, о диагностике, дебаггинге и обсервабилите.
2543.52 2552.88 "Анатолий Кулаков" Наверное, для непосвященного слушателя, да даже, наверное, и для посвященного эти термины могут иметь какую-то путаницу между собой.
2552.88 2560.08 "Анатолий Кулаков" Игорь, давай попробуем, что для тебя является диагностик, дебаггинг и обсервабилити, что они значат?
2560.08 2566.44 "Игорь Лабутин" Диагностик для меня это в принципе любая деятельность по получению какой-то информации о том, что делает программа тем или иным способом.
2566.44 2573.68 "Игорь Лабутин" То есть для меня диагностик это совсем объемлющий термин, который включает в себя и дебаггинг, и обсервабилити, и китение логов, и я не знаю, что еще.
2573.68 2577.08 "Игорь Лабутин" Просто наблюдение за тем, что делает программа каким-то образом.
2577.08 2583.12 "Игорь Лабутин" Дебаггинг - это непосредственно, ну, дебаггинг, сидишь с дебаггером, смотришь, что делает программа, по шагам там выполняешь.
2583.12 2587.28 "Игорь Лабутин" Ну а обсервабилити - это там логи, метрики, вот это все, трейсы.
2587.28 2600.20 "Анатолий Кулаков" Да, да, я думаю, что в принципе, в сути ты высказал общую точку, но интересно то, что из шести специалистов Microsoft практически не нашлось одинаковых мнений, потому что все рассказывали свое, что он видит.
2600.20 2604.28 "Анатолий Кулаков" Знаешь, каждый со своего конца, что для него эти термины обозначают.
2604.28 2608.68 "Анатолий Кулаков" Но в общем, для большого круга пользователей действительно ты прав.
2608.68 2613.92 "Анатолий Кулаков" Итак, вот такие термины обсуждались, вот такие темы обсуждались.
2613.92 2616.08 "Анатолий Кулаков" Что же у нас есть?
2616.08 2621.88 "Анатолий Кулаков" Прежде всего, какие у нас есть библиотеки, какие у нас есть классы по работе в этих областях.
2621.88 2632.96 "Анатолий Кулаков" Для логинга у нас уже есть Microsoft Extension Login, там же недалеко бегает Diagnostic Tracing Event Source, и для логинга, кажется, все.
2632.96 2644.44 "Анатолий Кулаков" Дальше для метрик у нас используются Event Counters, и очень новая библиотечка, которую сегодня уже упоминали, это System Diagnostic Metrics, которая непосредственно плотно связана с OpenTelemetry.
2644.44 2648.80 "Анатолий Кулаков" И для Distributed Tracing это третий кит, на котором стоит Observability.
2648.80 2654.36 "Анатолий Кулаков" У нас есть System Diagnostic Activity, мы его тоже очень много и очень часто уже обсуждали.
2654.36 2660.88 "Анатолий Кулаков" Он тоже был сделан в честь релиза OpenTelemetry и сильно с ним связан.
2660.88 2673.04 "Анатолий Кулаков" Для профайлинга у нас есть iCore Profiler, это специальный интерфейс низкоуровневый, который с самых первых версий у нас есть, и в принципе профайлеры мы поддерживаем давно и надежно.
2673.04 2690.32 "Анатолий Кулаков" Но в большинстве случаев сейчас в современных системах iCore Profiler используется далеко не для профайлинга, а в основном для Observability, то есть специальные программы, которые еще называются EAPM, они подключаются с помощью этого интерфейса к вашему приложению и начинают его мониторинг.
2690.32 2695.84 "Анатолий Кулаков" Для профайлинга у нас также есть и TV-шки, и Event Pipes.
2695.84 2698.28 "Анатолий Кулаков" Вот такой богатый инструментарий вокруг нас собрался.
2698.28 2708.60 "Анатолий Кулаков" И дальше Лендер попросил своих коллег описать, а что же такого за импровизация значима в последние годы.
2708.60 2723.88 "Анатолий Кулаков" Прежде всего, народ отметил, что были выпущены прекрасные инструменты, которые позволили очень качественно работать с отладкой, с диагностикой наших дотнет-приложений кроссплатформенно.
2723.88 2735.88 "Анатолий Кулаков" Это уже так известные всем нам дотнет-дамп, дотнет-коллект, дотнет-каунтерс, дотнет-трейс, также и новые какие-то, например, дотнет-стек появился.
2735.88 2747.44 "Анатолий Кулаков" И одна из самых главных заслуг - это то, что весь этот тулинг работает под Linux, под macOS, под Windows и в принципе под всеми остальными платформами, где поддерживается новый дотнет.
2747.44 2758.00 "Анатолий Кулаков" Из последнего интересного был сделан диагностик IPC-сервер и заимпровленные Event Pipes, тоже кроссплатформенно.
2758.00 2769.20 "Анатолий Кулаков" Это позволяет отлаживать ваши программы кроссплатформенно, снимать с них какие-то диагностическую информацию, как-то ее обрабатывать и все это делать очень эффективно.
2769.20 2771.44 "Анатолий Кулаков" Дальше был вопрос о профайлинг.
2771.44 2774.12 "Анатолий Кулаков" Профайлинг нужен только для старых десктопных приложений.
2774.12 2785.40 "Анатолий Кулаков" Правда ли это, что новые предложения, которые сейчас запускаются в клауде, там никакой профайлинг не нужен, там они далеко и устаревшая технология.
2785.40 2789.64 "Анатолий Кулаков" На что гости, естественно, не согласились, потому что профайлинг в принципе нужен.
2789.64 2791.44 "Анатолий Кулаков" Они выделили два типа профайлинга.
2791.44 2793.12 "Анатолий Кулаков" Во-первых, это performance профайлинг.
2793.12 2800.32 "Анатолий Кулаков" Это когда мы определяем, сколько времени приложение проводит в том или ином месте, сколько оно памяти потребляет и так далее.
2800.32 2804.80 "Анатолий Кулаков" Безусловно, всем этим новым клауд технологиям performance профайлинг нужен.
2804.80 2809.52 "Анатолий Кулаков" Performance важен и был, и остается важен всегда, не только для десктопных приложений.
2809.52 2812.08 "Анатолий Кулаков" И второе – это iCore Profiler.
2812.08 2829.40 "Анатолий Кулаков" Это специальный интерфейс, как я уже упоминал, и он очень активно используется APM-вендорами, которые мониторят ваши приложения, которые помогают делать распределенные трассировки, которые помогают просто отслеживать, насколько хорошо ваше приложение работает, как живет и что в нем происходит.
2829.40 2836.44 "Анатолий Кулаков" Вот это тоже APM-вендоры научились делать прекрасно в облаках, и тоже для облаков тема вполне жива.
2836.44 2841.32 "Анатолий Кулаков" Итак, какие же нас новые инструменты и новые фичи ждут в новом .NET 6?
2841.32 2844.76 "Анатолий Кулаков" Прежде всего, ход релоудинг, о котором мы подробно говорили в прошлом выпуске.
2844.76 2847.68 "Анатолий Кулаков" Далее, новая утилитка .NET Stack.
2847.68 2856.96 "Анатолий Кулаков" Это очень простая утилитка, которая из командной строки дает вам понять, чем процесс занимается, то есть распечатывает вам все стэки этого процесса.
2856.96 2858.76 "Анатолий Кулаков" Безумная полезная вещь.
2858.76 2863.04 "Анатолий Кулаков" Я часто применял не ее, а ее аналог в текущих работах.
2863.04 2869.84 "Анатолий Кулаков" Очень помогает, когда вам нужно просто быстро под на продакшене понять, что собственно происходит, где висит, где тормозит.
2869.84 2872.80 "Анатолий Кулаков" Без всяких подручных средств.
2872.80 2874.48 "Анатолий Кулаков" Notification Profilers.
2874.48 2883.92 "Анатолий Кулаков" Это еще одна интересная штука, которая позволяет вам использовать несколько профайлеров, которые могут цепляться к интерфейсу iCore Profiler.
2883.92 2888.08 "Анатолий Кулаков" До этого момента такой профайлер мог быть только один.
2888.08 2891.44 "Анатолий Кулаков" С помощью Notification Profilers эта концепция немного расширяется.
2891.44 2898.32 "Анатолий Кулаков" У нас по-прежнему остается один главный профайлер, который имеет доступ ко всем API, может делать все то же, что и раньше.
2898.32 2909.36 "Анатолий Кулаков" И у нас появляется куча маленьких Notification Profilers, которые цепляются в режиме только чтения и могут, соответственно, читать, диагностировать ваше приложение.
2909.36 2917.16 "Анатолий Кулаков" В принципе, то, что нужно большинство API сред, как раз это тот базис, который есть в Notification Profilers.
2917.16 2923.20 "Анатолий Кулаков" И это поможет нам использовать несколько точек диагностики в нашем приложении одновременно.
2923.20 2925.20 "Анатолий Кулаков" Тоже прекрасная штука.
2925.20 2933.88 "Анатолий Кулаков" Ну и, конечно же, новый Metrics API, который тесно интегрирован с OpenTelemetry и вообще тесная интеграция OpenTelemetry в будущий релиз.
2933.88 2942.60 "Анатолий Кулаков" Это тоже такой big deal, который нам должен упростить много интересных повседневных задач и сильно упростить диагностику приложений, где бы они ни были.
2942.60 2945.36 "Анатолий Кулаков" Хоть на Desktop, хоть в Cloud, хоть еще где угодно.
2945.36 2946.36 "Игорь Лабутин" Прекрасно.
2946.36 2949.44 "Игорь Лабутин" И это прям довольно много полезных улучшений и изменений.
2949.44 2955.60 "Игорь Лабутин" И хороший обзор на самом деле того, что нам сейчас доступно про Notification Profilers, если кто-то не знал, например.
2955.60 2956.60 "Игорь Лабутин" Пойдем дальше.
2956.60 2965.20 "Игорь Лабутин" Дальше у нас такая слегка хардкорная тема, как мне кажется, статья от Maloney Stephens про то, что нас ждет в Garbage Collector в будущем.
2965.20 2975.40 "Игорь Лабутин" Я попробую не пересказать всю книгу Конрада Кокоса целиком про то, как работает Garbage Collector, но попробую напомнить, что сейчас у нас Garbage Collector работает на основе сегментов.
2975.40 2983.24 "Игорь Лабутин" То есть нулевое и первое поколение всегда лежат в одном сегменте, и он называется Ephemeral Segment.
2983.24 2991.36 "Игорь Лабутин" Второе поколение и Large Object Heap, они лежат дальше еще в большом количестве сегментов, и таким образом память распределяется.
2991.36 3001.08 "Игорь Лабутин" Для серверного Garbage Collector, когда он в серверном режиме, размер сегмента он либо 1, 2, либо 4 гигабайта, в зависимости от размера наличия памяти.
3001.08 3030.16 "Игорь Лабутин" И это означает, что даже если у вас какой-то, допустим, сегмент довольно сильно освобождается по какой-то причине в вашей бизнес-логике, Garbage Collector там все собрал, но в этом 1 гигабайтном сегменте осталось, не знаю, пару мегабайтов данных, весь этот гигабайт все еще занят, вы не можете его отдать операционной системе, потому что он коммитит целиком, и вы не можете это место переиспользовать в какие-то другие вещи, например, под растущее нулевое поколение, которое временно почему-то сильно выросло.
3030.16 3042.36 "Игорь Лабутин" И даже в Workstation режиме, когда размер сегмента всего 256 мегабайт, все равно это кажется довольно проблемным, по крайней мере, Moony считает, что это так для некоторых сценариев, которые она видела у кастомеров.
3042.36 3049.52 "Игорь Лабутин" Поэтому общий тренд сейчас, и есть уже некоторая тестовая реализация, это заменить сегменты на регионы.
3049.52 3050.52 "Игорь Лабутин" Что такое регионы?
3050.52 3056.56 "Игорь Лабутин" Регионы - это точно такой же блок памяти, где точно так же будут жить объекты, но размер региона всего 4 мегабайта.
3056.56 3061.32 "Игорь Лабутин" И регионы, соответственно, объединяются в цепочке, можно сказать.
3061.32 3074.56 "Игорь Лабутин" Свободные регионы, по мере освобождения, закидываются в пул свободных регионов, могут быть переиспользованы, и таким образом, поскольку мы приходим к большому количеству довольно небольших кусочков, то память можно расходовать более эффективно.
3074.56 3080.40 "Игорь Лабутин" Это, скорее всего, важно во всяких докер-сценариях, когда реальной памяти у вас на самом деле не так и много.
3080.40 3087.16 "Игорь Лабутин" И появляется возможность переиспользовать свободное пространство из ген 2 в ген 0, ген 1 или наоборот.
3087.16 3092.00 "Игорь Лабутин" Дальше, как все это будет происходить с точки зрения реализации?
3092.00 3097.92 "Игорь Лабутин" Как я сказал, уже эта реализация в некотором виде есть, но она сейчас не шипится внутри SDK.
3097.92 3108.08 "Игорь Лабутин" Для того, чтобы ее заиспользовать, вам нужно взять отдельную CLRJC DLL, указать runtime, что надо использовать ее, и включить экспериментальную фичу в конфиге.
3108.08 3122.00 "Игорь Лабутин" Дальше, видимо, в таком виде она именно переедет в SDK, но ее тоже нужно будет включать как экспериментальную фичу, и только потом уже, когда все будет хорошо отлажено, то тогда это будет, возможно, дефолтным победителем.
3122.00 3126.60 "Игорь Лабутин" Или garbage collector будет как-то сам решать для тех или иных сценариев, какой режим использовать.
3126.60 3134.40 "Игорь Лабутин" Но вообще Moony очень оптимистичен на предмет использования регионов, говорит, что там прям простор оптимизации и идей, что можно сделать.
3134.40 3139.52 "Игорь Лабутин" И одна из идей — это dynamic promotion и demotion.
3139.52 3145.08 "Игорь Лабутин" Если вы читали книжку Конрада или как-то интересовались garbage collector, то там есть понятие demotion.
3145.08 3150.32 "Игорь Лабутин" Все, конечно, знают, что объект, который пережил сборку мусора, продвигается в следующее поколение, это называется промоушеном.
3150.32 3155.00 "Игорь Лабутин" Но существует и обратный процесс, когда объект сдвигается обратно в предыдущее поколение.
3155.00 3159.72 "Игорь Лабутин" Такое может происходить, когда вы используете пиннинг.
3159.72 3176.72 "Игорь Лабутин" Когда у вас есть некоторый объект, который находится, например, в первом поколении, но вы его запиннили, и тогда при некоторых обстоятельствах в результате компакшена и перемещений объектов вокруг внутри этого сегмента, в котором это все находится, может случиться так, что этот запиненный объект окажется в нулевом поколении.
3176.72 3178.52 "Игорь Лабутин" Это называется demotion.
3178.52 3195.60 "Игорь Лабутин" Так вот, фактически, с demotion-ом-то ладно, обычно такого не приходится делать, а вот с промоушеном есть сценарии, когда хочется иметь возможность взять объекты из нулевого поколения и сразу запромоутить их во второе.
3195.60 3225.16 "Игорь Лабутин" Один из примеров — это если у нас есть, например, какой-нибудь массив, который большой и давно уже живет, и вы анвалоцируете новые объектики, маленькие, референсы на которые складываете в этот большой массив, с хорошей вероятностью, гораздо более эффективно с точки зрения garbage-коллектора, эти самые объектики сразу класть в второе поколение, чем держать их в нулевом, потом они пройдут в первое, потом они пройдут в второе, потому что на них есть ссылка из массива, который уже лежит во втором поколении.
3225.16 3242.24 "Игорь Лабутин" Поэтому, когда вы используете регионы, и они всего лишь 4 мегабайта, то есть велик шанс того, что если у вас таких объектиков много, то они как раз заполнят регион, и тогда весь регион можно будет быстренько переместить целиком из списка нулевого поколения в список второго поколения, и таким образом объект перепрыгнет в поколение.
3242.24 3243.24 "Игорь Лабутин" Неплохой хак.
3243.24 3266.12 "Игорь Лабутин" То есть это пока единственный сценарий, насколько я понимаю, который заимплеменчен и который описан в статье, но Маони говорит, что у нее в идеях еще два или три, и она вполне легко может заимплементировать, или может быть даже уже заимплементировала, просто не описывала в статье, и там еще какое-то количество идей, которые можно сделать вокруг этой штуки, чтобы оно все интереснее работало.
3266.12 3277.12 "Игорь Лабутин" То есть все наши стандартные вопросы на собеседованиях с внедрением этой штуки могут сильно потерять актуальность, потому что объекты теперь смогут прыгать туда-сюда и непонятно как.
3277.12 3279.04 "Игорь Лабутин" И надо будет заново все это изучать.
3279.04 3282.40 "Анатолий Кулаков" А лучше наконец-то забить и не спрашивать глупые вопросы на собеседованиях.
3282.40 3291.44 "Игорь Лабутин" Это правда, и еще с одной стороны Маони всегда утверждает, что Garbage Collector в Дотнете пытается его сделать так, чтобы про него не надо было думать вообще.
3291.44 3294.24 "Игорь Лабутин" Как он там работает внутри вас касаться не должно.
3294.24 3312.92 "Игорь Лабутин" Есть некоторые принципы, по которым вы должны писать код, чтобы не создавать много долгоживущих объектов, или те, которые доживают до первого поколения и так далее, но в целом Garbage Collector в Дотнете отличается тем, что он практически не требует настройки, и при этом работает очень хорошо.
3312.92 3320.20 "Анатолий Кулаков" Да, да, действительно, это правильный подход, потому что философия вот такая, что не лезьте туда, вот вам базовые понятия и вам этого должно хватить.
3320.20 3323.00 "Анатолий Кулаков" Вот так и должно быть, так и нужно придерживаться.
3323.00 3329.72 "Анатолий Кулаков" Ну что ж, спасибо Маони, а уже известно, когда это будет, это планируется к новому релизу Дотнета или просто эксперименты?
3329.72 3346.60 "Игорь Лабутин" Пока это эксперименты, я слышал про какие-то планы, что может быть это успеют выкатить в шестой Дотнет, но скорее всего, даже если это успеют включить в шестой Дотнет SDK к релизу, в реале это будет дефолтным поведением, скорее всего будет включаться конфигом пока еще.
3346.60 3350.76 "Игорь Лабутин" Слишком важное изменение, чтобы его так прям продакшн раскатить сразу на всех.
3350.76 3352.12 "Анатолий Кулаков" Ну что ж, поехали дальше.
3352.12 3366.48 "Анатолий Кулаков" Набрел на интересную статейку Мартина Белью, это известный адвокат из компании JetBrains, но в принципе, как и все адвокаты из компании JetBrains, он прежде всего разработчик, то есть там нет технических адвокатов, нет, и это радует.
3366.48 3373.48 "Анатолий Кулаков" Мартин написал прекрасную статейку про немножко необычную тему для Дотнета, про security.
3373.48 3377.80 "Анатолий Кулаков" Мы как-то мало затрагиваем security в наших выпусках и хотелось бы немножко исправиться.
3377.80 3383.36 "Анатолий Кулаков" Не то, чтобы здесь было что-то такое страшное и хардкорное, поэтому такие веселые и интересные истории.
3383.36 3386.36 "Анатолий Кулаков" Давайте немножко введения.
3386.36 3393.44 "Анатолий Кулаков" Прежде всего, атака, которую он пытается воспроизвести на Дотнет стэке, называется supply chain attack.
3393.44 3408.24 "Анатолий Кулаков" Я не встречал нормального перевода в русском, как это переводится, но в общем это атака на вашу инфраструктуру, атака на вспомогательные пакеты, на вспомогательные компоненты.
3408.24 3423.72 "Анатолий Кулаков" Заключается она в том, что атакуется именно процесс сборки или процесс сопровождения с помощью того, что в популярные фреймворки или из популярной компоненты инжектится какой-то зловредный код.
3423.72 3433.32 "Анатолий Кулаков" И атака производится непосредственно на ваше приложение с помощью того факта, что вы используете третий сторонние какие-то компоненты.
3433.32 3442.68 "Анатолий Кулаков" Главная, наверное, цель атакующего это не выявить себя, не задестроить, а все-таки скрыться, как можно дольше продержать скрытым.
3442.68 3454.52 "Анатолий Кулаков" И в зависимости от его намерений он может или уточнить ваши секреты или продержаться до продакшна и начать утягивать пользовательские данные или что-то в этом духе еще.
3454.52 3455.76 "Анатолий Кулаков" Чем интересна эта атака?
3455.76 3463.20 "Анатолий Кулаков" Тем, что в этом году, в 2021 очень много сервисов, очень много компаний от нее пострадали.
3463.20 3472.44 "Анатолий Кулаков" Это и SolarWinds, и Microsoft Exchange Server, и PayPal, и Apple, и очень-очень много различных других компаний.
3472.44 3474.56 "Анатолий Кулаков" Но давайте обо всем по порядку.
3474.56 3477.20 "Анатолий Кулаков" Прежде всего, Мартин сделал пакет.
3477.20 3481.64 "Анатолий Кулаков" Обычный Nougat пакет, который мы сделаем с вами каждый день, назвал его String Extensions.
3481.64 3493.72 "Анатолий Кулаков" Пакет был очень примитивный, он добавлял экстеншн методы к строчкам, которые умеют превращать строчки в цифры, в инты, шоты, лонги, ну в общем любые в намберы.
3493.72 3500.76 "Анатолий Кулаков" То есть вы могли написать строку 1, вызвать у нее метод toInt32 и получить какой-то результат.
3500.76 3506.36 "Анатолий Кулаков" Как не сложно догадаться, внутри она просто вызывала int tryParse и в принципе все, больше ничего.
3506.36 3514.04 "Анатолий Кулаков" Это естественно была такая обложка, чтобы не привлекать внимание к основному злонамеренному коду.
3514.04 3523.36 "Анатолий Кулаков" А основной код прячется у него в классике под сложным системным названием System Security Policy Discovery Manager.
3523.36 3530.60 "Анатолий Кулаков" Он рассчитывал на то, что этот NMSpace выглядит как обычный .NET классик и никто сильно лазить внутрь не будет.
3530.60 3532.72 "Анатолий Кулаков" Ну подумаешь там в какой-то policy какой-то discovery.
3532.72 3536.12 "Анатолий Кулаков" Ну раз security значит что-то нужное, что-то важное.
3536.12 3539.00 "Анатолий Кулаков" Что там лежит и всем обязательно нужно.
3539.00 3542.08 "Анатолий Кулаков" Внутри этого менеджера у него есть метод.
3542.08 3545.68 "Анатолий Кулаков" На этот метод навешена куча вспомогательных атрибутов.
3545.68 3550.16 "Анатолий Кулаков" Например Editor Browserable со значением NEDA.
3550.16 3557.28 "Анатолий Кулаков" Он этот атрибут рекомендательный, но по идее должен прятать данный класс от IntelliSense и всякого ContCodeCompletion.
3557.28 3560.48 "Анатолий Кулаков" Также у него там есть атрибут CompileGenerated.
3560.48 3567.36 "Анатолий Кулаков" Это позволяет спрятать данный класс от всяких статических анализов.
3567.36 3574.20 "Анатолий Кулаков" Дебаггер Hidden позволяет спрятать класс от дебаггера.
3574.20 3583.72 "Анатолий Кулаков" И как вы наверное заметили все эти атрибуты нацелены на то, чтобы максимально скрыть какое-то присутствие этого класса и какое-то действие от этого класса.
3583.72 3589.40 "Анатолий Кулаков" Внутри все естественно обернуто в try/catch, чтобы не выдавать и не своего присутствия в случае ошибки.
3589.40 3592.76 "Анатолий Кулаков" И самое главное это атрибут ModuleInitializer.
3592.76 3601.00 "Анатолий Кулаков" Он сообщает рантайму, что этот метод нужно запустить один единственный раз в то время как сборка будет загружена в память.
3601.00 3604.84 "Анатолий Кулаков" Этот магический атрибут был добавлен в DotNet 5.
3604.84 3608.20 "Анатолий Кулаков" Был добавлен он для SourceGenerator в основном.
3608.20 3612.80 "Анатолий Кулаков" Вместе с ними и используется максимально в них.
3612.80 3613.80 "Анатолий Кулаков" Не только.
3613.80 3624.08 "Анатолий Кулаков" Это полезный атрибут и для тестов, для того чтобы ваши тестовые данные приготовить и для того, чтобы подключить правильные фреймворки диагностики к вашему приложению.
3624.08 3625.92 "Анатолий Кулаков" В общем полезных функций у него достаточно.
3625.92 3631.28 "Анатолий Кулаков" Но как одна из функций это все-таки запускать код.
3631.28 3640.80 "Анатолий Кулаков" И запускать код теперь можно в вашем приложении только с входной точки main, но и с любого произвольного места, которое вы пометите вот этим магическим атрибутом.
3640.80 3654.24 "Анатолий Кулаков" Сейчас DotNet команда работает над тем, чтобы написать специальные анализаторы, которые вас как-то предупреждают или сообщают вам, что в вашем приложении или может быть в сторонних библиотеках используется этот атрибут, что вы хотя бы были предупреждены.
3654.24 3655.72 "Анатолий Кулаков" Что это дает?
3655.72 3664.80 "Анатолий Кулаков" А дает это то, что как только вы установите этот пакет и запустите свое приложение, неудивительно выполнится злонамеренный код.
3664.80 3668.72 "Анатолий Кулаков" Злонамерный код спрятанный внутри вот этого скрытого метода.
3668.72 3672.08 "Анатолий Кулаков" В принципе в этом и была главная идея Мартина.
3672.08 3679.74 "Анатолий Кулаков" Продемонстрировать то, что за референсив обычный ну гет пакет откуда-то из интернета можно выполнить произвольный код.
3679.74 3684.76 "Анатолий Кулаков" Ну и по сути сделать с вашим компьютером абсолютно все на что только у вас есть привилегии.
3684.76 3686.68 "Анатолий Кулаков" Наверное новость не новая.
3686.68 3699.20 "Анатолий Кулаков" Все мы давно с вами знаем и давно говорим и давно сообщаем, что любые там D, L и в принципе даже исходный код, который загружен из интернета может делать с вашей системой все что угодно.
3699.20 3706.76 "Анатолий Кулаков" Это никак не связано ни с появлением DotNet 5, ни коры, ни Source генераторов, ни даже с появлением самого C# и DotNet.
3706.76 3709.36 "Анатолий Кулаков" Эта атака не зависит ни от языка, ни от чего.
3709.36 3718.20 "Анатолий Кулаков" Она направлена как раз таки на инфраструктуру, на пакеты, на сборщиков, на билд агентов и вот на прочее прочее прочее.
3718.20 3728.04 "Анатолий Кулаков" Но в принципе ее можно делать не только основываясь на скомпилированных D, L, но как я уже сказал на основе непосредственно Source кода.
3728.04 3732.96 "Анатолий Кулаков" А вот атака на основе Source кода стала доступна только во время появления Source генераторов.
3732.96 3743.44 "Анатолий Кулаков" Действительно зачем нам качать какие-то сторонние D, L, какие-то бинарники, если мы можем заинжектить зловредный код прямо непосредственно в ваше приложение с помощью Source генераторов.
3743.44 3751.36 "Анатолий Кулаков" Для этого у Мартина есть другой пример, второй пакет, который делает точно такие же String Extensions, но при этом с помощью генераторов.
3751.36 3766.84 "Анатолий Кулаков" Это Source генератор, который вы точно также подключаете в виде пакета к вашему приложению и он непосредственно тот же самый Policy Discovery Manager из Namespace Security пишет, записывает, записывает ваше приложение, но в виде исходного кода.
3766.84 3781.00 "Анатолий Кулаков" Особенность Source генераторов заключается в том, что они способны инжектить вредоносный код не только когда вы запускаете ваше приложение, не только когда ваша библиотека непосредственно первый раз загружается в память, но и во время самого билд процесса.
3781.00 3786.28 "Анатолий Кулаков" Потому что Source генераторы как раз таки запускаются в момент билда.
3786.28 3793.56 "Анатолий Кулаков" А если мы говорим про Visual Studio, то там оно запускается просто по 100 раз в секунду даже без билда для того, чтобы дать вам правильный интеллисенс.
3793.56 3801.04 "Анатолий Кулаков" Соответственно вы можете даже не запуская код уже на компьютере жертвой творить абсолютно все что угодно.
3801.04 3809.80 "Анатолий Кулаков" Но, как я уже сказал, в принципе наибольшие выгоды вы получите, если сразу вас не заметят, а разработчики это одни из тех людей, которые способны заметить такой код.
3809.80 3823.68 "Анатолий Кулаков" Поэтому наиболее разумно на компьютере разработчика не делать нечего, а задетектить во время сборки то, что вы собираетесь на CI-сервере, задетективать с помощью переменных окружений, environment и все такое.
3823.68 3841.64 "Анатолий Кулаков" И уже непосредственно при сборке на CI-сервере внедрить любой зловредный код, сделать что-то еще, сгонять в базу данных, скопировать connection стринги, сходить в Security Store, достать оттуда все пароли и в принципе много-много чего еще можно полезного сделать.
3841.64 3846.84 "Анатолий Кулаков" Другой способ запустить произвольный код это MSBuild.
3846.84 3856.00 "Анатолий Кулаков" Ни для кого не секрет, что все проекты собираются в Visual Studio, да и не только, в принципе и в Raider, и с командной строки, все собираются в .NET с помощью MSBuild.
3856.00 3863.32 "Анатолий Кулаков" В ваш Nuget пакет вы можете подложить специальные файлы, которые заканчиваются на .target и .props.
3863.32 3865.96 "Анатолий Кулаков" Это те файлы, которые будет запускать MSBuild.
3865.96 3872.24 "Анатолий Кулаков" У них есть определенный naming convention, у них есть определенный формат, в общем запустить их никакой проблем не составляет.
3872.24 3886.44 "Анатолий Кулаков" А внутри NIG вы точно так же можете банально вызвать специальный экстеншн, который стандартный, который называется вrightline2file и записать в тот файл, который будет впоследствии скомпилирован, опять же произвольный код.
3886.44 3888.84 "Анатолий Кулаков" Все это можно сделать с помощью MSBuild.
3888.84 3894.64 "Анатолий Кулаков" Вот такие незамысловатые три входных точки для запуска произвольного кода показал нам Мартин.
3894.64 3900.12 "Анатолий Кулаков" И дальше еще интересное рассуждение насчет пейлоуда.
3900.12 3912.16 "Анатолий Кулаков" Наверное просто так внедрять код не интересно, интересно будет или украсть данные и куда-то их передать, или наоборот скачать какую-то полезную нагрузку, которая уже в безопасном контуре и не будет проверяться антивирусами или еще что-нибудь.
3912.16 3913.80 "Анатолий Кулаков" Каким образом это можно сделать?
3913.80 3921.12 "Анатолий Кулаков" Естественно банально просто обратиться по HTTP API к любому endpoint и оттуда скачать или отослать все что угодно.
3921.12 3928.20 "Анатолий Кулаков" Но если задуматься, обращение по HTTP API слишком тяжеловесно и слишком видимо.
3928.20 3954.60 "Анатолий Кулаков" Например, если у вас к вашему приложению подключен какой-нибудь диагностический обсервабилити тул, например Application Insight ажуровский, то он вам в Dashboard покажет четко, что из вашего приложения был совершен HTTP API к такому-то серверу с такими-то данными и разработчики, девопсы, кто угодно, кто наблюдает за системой, без проблем поймут, что уровень странный, момент странный и что-то здесь не то.
3954.60 3962.28 "Анатолий Кулаков" Поэтому Мартин предлагает немножко более низкоуровневый вариант, а именно обращение к обычному DNS серверу.
3962.28 3970.72 "Анатолий Кулаков" В примере он захешировал имена машин с помощью MD5 и обратился к DNS серверу с просьбой разрезовывать определенное имя.
3970.72 3980.88 "Анатолий Кулаков" В этом имени он зашифровал MD5 строку и плюс еще добавил свой адрес своего ханипота, своего DNS сервера, который все эти запросы должен был принять.
3980.88 3990.96 "Анатолий Кулаков" Его кастомный DNS сервер принимал эти респонсы, ой, эти реквесты, логировал их естественно и отдавал обычный банальный респонс с адресом на localhost.
3990.96 3999.60 "Анатолий Кулаков" В принципе ничего зловредного такого он не делал, но это помогло ему уже собрать всех, всех кто заразился с помощью такой атаки.
3999.60 4006.80 "Анатолий Кулаков" Естественно можно отдавать нормальный пейлоут в виде DNS ответа, а этот пейлоут уже собирать на клиенте и выполнять.
4006.80 4010.32 "Анатолий Кулаков" То есть это полноценный доступ к машине.
4010.32 4015.68 "Анатолий Кулаков" Вот такая атака, вот такой небольшой транспортный путь, как это все можно сделать незамысловато.
4015.68 4017.64 "Анатолий Кулаков" Что же с этим делать нам разработчикам?
4017.64 4024.52 "Анатолий Кулаков" В принципе, как я уже сказал, эта проблема не C#, не .NET, это большая проблема в принципе всей индустрии.
4024.52 4026.72 "Анатолий Кулаков" И хорошего ответа на это пока нет.
4026.72 4037.12 "Анатолий Кулаков" Есть куча best practice, куча рекомендаций, которые в принципе можно свести к тому, что знайте ваши зависимости, пробирайте по возможности все, что там написано.
4037.12 4048.00 "Анатолий Кулаков" Большинство разработчиков не будет этим пользоваться, поэтому пока так она остается очень опасной и очень популярной.
4048.00 4055.32 "Анатолий Кулаков" Может быть, ну, GED мог что-то с этим делать, то есть как-то проверять пакеты, как-то их сканировать, что-то с ними делать.
4055.32 4064.44 "Анатолий Кулаков" Но, скорее всего, обычные стандартные вирусы и прочий молдварь, но GED и так это все сканирует, но GED все делает.
4064.44 4066.72 "Анатолий Кулаков" Но если мы задумаемся, то что он может сделать с этим пакетом?
4066.72 4068.64 "Анатолий Кулаков" Он не может запретить source-генераторы.
4068.64 4074.20 "Анатолий Кулаков" Модуль инициалайзер - это тоже стандартная тема .NET, она не подозрительная.
4074.20 4077.04 "Анатолий Кулаков" MSBuild скрипты тоже никто запрещать не будет.
4077.04 4080.68 "Анатолий Кулаков" Обращение к DNS, ну, стандартная тоже операция из любого пакета может такой быть.
4080.68 4086.52 "Анатолий Кулаков" То есть со стороны сервера на что сканировать и что запрещать в принципе ничего сделать нельзя.
4086.52 4104.80 "Анатолий Кулаков" Существует очень много рекомендаций, будут в статье есть ссылки от Microsoft, от Linux Foundation, от всяких других security компаний, которые вам дают какие-то пункты, которые вы можете, опять же, отслеживать, которым вы можете придерживаться, какие-то best practices.
4104.80 4113.44 "Анатолий Кулаков" Пишутся Microsoft куча анализаторов, которые как-то по каким-то инвристикам будут что-то пытаться делать.
4113.44 4116.84 "Анатолий Кулаков" Но, опять же, здесь, скорее всего, хорошего выхода нет.
4116.84 4127.00 "Анатолий Кулаков" Вот, еще одно интересное добавление к этой истории, как раз таки, почему эта атака сейчас у всех на слуху, ну не сейчас, в принципе, наверное, с начала года.
4127.00 4131.72 "Анатолий Кулаков" Была такая интересная тема, когда один из ресерчеров сделал следующую штуку.
4131.72 4142.32 "Анатолий Кулаков" Он подсмотрел, что некоторые люди в презентациях, например, докладчики, часто используют какие-то слайды, на которых нарисованы имена внутренних пакетов.
4142.32 4149.68 "Анатолий Кулаков" Ну, наверное, у каждого из нас есть внутренние пакеты, которые актуальны только для этой компании, для этого продукта, для этой организации.
4149.68 4156.92 "Анатолий Кулаков" Например, какой-нибудь Microsoft Internals Data, который никогда за пределы Microsoft не выйдет, но внутри она есть.
4156.92 4165.44 "Анатолий Кулаков" И этот разработчик, этот ресерчер подумал, а что, если мы возьмем имя этого пакета и сделаем публичный такой пакет.
4165.44 4174.52 "Анатолий Кулаков" Он так и сделал, подсмотрел какие-то имена пакетов на слайдах разработчиков, достал еще откуда-то.
4174.52 4180.84 "Анатолий Кулаков" В общем, достать имя пакета, это не такая уж секьюрная информация, это делается довольно-таки легко из больших всяких контор.
4180.84 4193.12 "Анатолий Кулаков" И опубликовал на публичных серверах, в основном речь шла про всякие NPM и JavaScript, опубликовал на публичных серверах свои пакеты с таким же точным названием.
4193.12 4211.96 "Анатолий Кулаков" Фишка заключается в том, что большинство сборщиков, большинство пайплайнов настроены на то, чтобы пойти сначала в публичный сервер, поискать этот пакет там и только потом, если он не найден, вернуться в локальный сервер, в локальный кэш и поискать его среди локальных пакетов.
4211.96 4237.24 "Анатолий Кулаков" Эта атака, эта идея нашла очень быстро свое подтверждение, потому что очень много больших корпораций были скомпрометированы, то есть автор действительно получил специальные реквесты с их внутренних серверов, с их внутренних билд-агентов, где он имел доступ практически ко всем исходникам, ко всем ключам и прочее.
4237.24 4255.32 "Анатолий Кулаков" Здесь, наверное, основная мораль, что даже огромные корпорации оказались не готовы к этому, даже их настроенные security-инженеры и best-practices тоже оказались дырявыми и никто здесь не защищен.
4255.32 4271.32 "Анатолий Кулаков" Может быть, здесь есть рекомендация обязательно проверить, что ваши локальные Nuget-пакеты сначала берутся с локального сервера, а потом, если что, лезут на внешний сервер, но по-хорошему на внешний сервер они вообще никогда лазить не должны.
4271.32 4295.08 "Анатолий Кулаков" Если вы что-то собираете в вашем защищенном контуре, у вас обязательно должен быть локальный, в нашем случае Nuget-репозиторий, локальный кэш и если вдруг там какого-то нужного для вас глобального пакета не найдено, то должна быть отдельный workflow, каким образом этот внешний пакет в этот локальный кэш попадет, и этот workflow должен включать в себя какой-нибудь security аудит, проверку лицензий, гарантии и так далее.
4295.08 4311.96 "Анатолий Кулаков" Ну, в общем, постарайтесь сделать так, чтобы ваш локальный Nuget-кэш по дефолту не ходил в global space, а те зависимости, которые вы тогда загружаете, вы были бы в них уверены или как минимум просматривали бы на предмет обычных банальных закладок.
4311.96 4313.48 "Анатолий Кулаков" Наверное, как-то так.
4313.48 4315.56 "Игорь Лабутин" Я прям очень оптимистично рассказал.
4315.56 4318.64 "Игорь Лабутин" Теперь надо бояться использовать каждый новый Nuget-пакет.
4318.64 4320.72 "Игорь Лабутин" Вдруг Microsoft туда что-нибудь подложил.
4320.72 4336.08 "Анатолий Кулаков" Ну, наверное, от Microsoft-а такой подлянки ждать не стоит, а если вы вдруг leftpad какой-то очередной из GitHub-а скачиваете, то лишний раз подумайте, а кто такой автор, насколько у него много репутации и что ему стоит как бы подложить вам какой-нибудь вредоносный
4336.08 4342.76 "Игорь Лабутин" код. Да, и соберите себе Nuget-пакет тогда самостоятельно и запусти его к себе в локальный ваш Nuget-репозиторий.
4342.76 4351.64 "Анатолий Кулаков" Именно так, управление зависимостью - это большая сложная профессия, которыми нужно заниматься, если у вас действительно какой-то продукт, который влияет на ваш бизнес.
4351.64 4356.36 "Игорь Лабутин" Ну окей, на этой оптимистичной ноте я думаю, что мы будем заканчивать сегодня.
4356.36 4358.12 "Игорь Лабутин" Мы много сегодня чего обсудили.
4358.12 4365.44 "Игорь Лабутин" Вышел DotNet 6 Preview 5, где огромное количество изменений в самом дотнете и не так много в S/P/NadKore, EFKore и MAUI.
4365.44 4376.60 "Игорь Лабутин" Поговорили про то, какие изменения произошли в коллекциях в DotNet 6, множество различных новых методов и способов как-то более оптимизированно подходить к коллекциям.
4376.60 4384.56 "Игорь Лабутин" Узнали, что вышла новая превьюшка Visual Studio 2019, версия 16.11, но там особо ничего нового, только багфиксы.
4384.56 4389.88 "Игорь Лабутин" И вышла наконец-таки первая превью 1 от 64-битной новой 22-й студии.
4389.88 4396.80 "Игорь Лабутин" Будем ждать каких-то развития событий и того, как она будет адаптиться всеми вокруг, в том числе разработчиками экстенджеров.
4396.80 4404.92 "Игорь Лабутин" Поговорили про то, что у нас сейчас происходит в мире диагностики в дотнете, какие у нас есть тулы, куда все движется и что нам доступно.
4404.92 4414.20 "Игорь Лабутин" Узнали про планы Maoni и Stephens на предмет того, как наш Garbage Collector будет меняться и заменять сегменты на регионы.
4414.20 4425.16 "Игорь Лабутин" И поговорили про замечательный вариант атаки на вашу, по сути на вашу компанию путем встраивания в систему сборки, путем подмены Nuget пакетов.
4425.16 4428.28 "Игорь Лабутин" Так что на этом все по темам.
4428.28 4439.40 "Анатолий Кулаков" Давай еще в честь горячего, сладостного, страстного лета, я думаю нужно подогреть праздник и у нас тут как раз подоспели лицензии на любой продукт от компании JetBrains.
4439.40 4441.92 "Анатолий Кулаков" Друзья, давайте еще раз раздадим лицензии.
4441.92 4453.64 "Анатолий Кулаков" Еще почему-то много людей, которые не слушают наш замечательный подкаст, скорее всего потому, что они о нем не знают, поэтому мы попросим вас немножко помочь нам в распространении в наших социальных сетях.
4453.64 4462.12 "Анатолий Кулаков" Итак, для новослушающих объясняю правила, старенькие наверное уже знают, но все же не лишним будет повторить.
4462.12 4472.88 "Анатолий Кулаков" Прежде всего одну лицензию у нас получит рандомный человек из списка тех, кто расшарит этот выпуск из официальной группы .NET.RU вконтактике.
4472.88 4477.88 "Анатолий Кулаков" Второй список, который получит одну лицензию это репост в твиттере.
4477.88 4484.76 "Анатолий Кулаков" И следующий список это комментаторы на ютубе к этому выпуску.
4484.76 4493.60 "Анатолий Кулаков" Комментируйте все, что вы захотите, что было интересного, что неинтересного, чего вы ждете от подкаста, где вы слушаете подкаст, из какого города вы нас слушаете.
4493.60 4495.64 "Анатолий Кулаков" Все это нам очень интересно.
4495.64 4499.28 "Анатолий Кулаков" Просто пишите, хочется пообщаться с настоящими живыми людьми.
4499.28 4503.24 "Анатолий Кулаков" И в принципе у нас обычно в ютубе классная дискуссия, поэтому давай две лицензии.
4503.24 4505.00 "Анатолий Кулаков" Две лицензии уйдет ютуберам.
4505.00 4511.96 "Анатолий Кулаков" Итак, всего четыре лицензии, одна в ВК, вторая репост в твиттере и две лицензии уходят на комментаторам ютуба.
4511.96 4514.88 "Анатолий Кулаков" Ну что ж, на этом наверное действительно все.
4514.88 4521.08 "Анатолий Кулаков" Друзья, подписывайтесь, распространяйтесь, рассказывайте о нас вашим друзьям и обязательно слушайте нас.
4521.08 4522.56 "Анатолий Кулаков" До новых встреч, всем пока.
4522.56 4523.08 "Анатолий Кулаков" Всем пока.
