0.00 12.68 "Анатолий Кулаков" Здравствуйте, дамы и господа, в эфире Радио.нет, выпуск номер 68.
12.68 15.20 "Анатолий Кулаков" В студии, как всегда, Анатолий Кулаков.
15.20 17.84 "Анатолий Кулаков" И Игорь Лабутин, всем привет.
17.84 22.48 "Анатолий Кулаков" Прежде всего хотелось бы поблагодарить наших помощников, донаторов, помогаторов.
22.48 24.32 "Анатолий Кулаков" Спасибо большое, друзья, что нам помогаете.
24.32 30.68 "Анатолий Кулаков" Александр, Сергей, Владислав, Алексей Шевченко, Антон, Сергей, я, Гурий Самарин, Виктор, Руслан Нартомонов.
30.68 33.48 "Анатолий Кулаков" И также всем тем, кто пожелал остаться неизвестными.
33.48 42.76 "Анатолий Кулаков" Если вы не знаете, о чем мы говорим, то заходите на сайт Boosty и посмотрите, что наш подкаст может вам предложить, кроме того, что вы уже слушаете его.
42.76 46.04 "Анатолий Кулаков" Ну что ж, давай начнем.
46.04 52.56 "Анатолий Кулаков" Не успели мы разойтись, я не знаю, это мы долго отдыхали или Microsoft быстро работает, но уже вышел превью-2 восьмого .NET.
52.56 74.80 "Игорь Лабутин" Да, на самом деле в комментах к видео прошлого выпуска на YouTube был один из комментов, был про то, что, мол, что-то Microsoft только-только выпустил семерку, уже восьмерку, а здесь получилось действительно, что мы только записали выпуск, я не очень ожидал, что к этому выпуску будет еще какой-то превью-2, но вот внезапно вышел действительно .NET 8 превью-2.
74.80 94.80 "Игорь Лабутин" Но правда, в самой статье написано, что это quick follow-up, и это такой маленький превью, непонятно на самом деле, почему они так торопились с ним, ничего какого-то прорывного и важного в нем вроде как нету, но может быть какие-то важные баги были по фикшену, про которых почему-то решили прямо именно в статье анонсить и не говорить, но что-то исправили.
94.80 101.12 "Анатолий Кулаков" Может, по датам подходило, первое ревью затянули, в это время уже второе надо было выпускать, чтобы не подводить менеджеров.
101.12 104.64 "Игорь Лабутин" Ну может быть действительно в какой-то график обратно вернулись, не знаю.
104.64 111.60 "Игорь Лабутин" Но давай попробуем пройтись и посмотреть, что же все-таки есть, он хоть и небольшой, но все-таки там есть некоторые интересные штуки.
111.60 120.48 "Игорь Лабутин" В самом дотнете, то есть в статье, которая посвящена главному основному дотнету, там вообще говоря изменений вообще тьфу и очень мало.
120.48 135.56 "Игорь Лабутин" В основном изменилось набор экстенджеров, не экстенджеров, наборов внутри namespace и system.component.model.data.annotations, то есть добавились новые аннотации, которые вы обычно используете для того, чтобы разметить ваши модельки данных для валидации.
135.56 139.48 "Игорь Лабутин" И там появилось некоторое количество новых атрибутов.
139.48 153.52 "Игорь Лабутин" Во-первых, у атрибута required добавился новый вариант под названием, ну не вариант, а так сказать, enumчик внутри, опция называется disallow all default values.
153.52 167.04 "Игорь Лабутин" И эта штука проверяет, что если вы такой атрибут повесили, например, на структуру, то пришедшее значение не пройдет в валидацию, если оно полностью совпадает с дефолтным значением этой структуры.
167.04 181.48 "Игорь Лабутин" Как пример, если вы повесите такой атрибут required на GUID, то пришедший пустой GUID, тот который 0 0 0 0 0 0, который соответствует дефолтному значению структуры GUID, а GUID - это структура, не пройдет в валидацию.
181.48 185.36 "Игорь Лабутин" Ну, как бы удобная штука, так сказать, потому что налом она быть не может.
185.36 199.12 "Игорь Лабутин" Для range атрибута завезли флажки, которые говорят о том, что включать или не включать верхнюю и нижнюю границу, их теперь можно явно указать, это факт.
199.12 204.48 "Игорь Лабутин" Для атрибута length, то есть длина строки, теперь можно задать тоже нижнюю и верхнюю границу.
204.48 225.68 "Игорь Лабутин" Для пропертей есть, ну они все для пропертей в каком-то смысле, но появилось два новых атрибута, называется allowed values и denied values, то есть если, например, на какой-нибудь строковой проперти вы повесите такой атрибут, то валидатор будет проверять, что значение либо входит в заданный список, либо наоборот, не является ни одним из значений из одного списка.
225.68 233.00 "Игорь Лабутин" И еще один атрибут называется base64string attribute, он соответственно проверяет, что пришедшая строка является валидной base64 строкой.
233.00 240.36 "Игорь Лабутин" Поскольку в base64 довольно часто пересылаются бинарные данные внутри JSON, то это тоже, наверное, популярная штука.
240.36 247.72 "Игорь Лабутин" И второе, что добавили, это в system reflection донесли поддержку function pointers.
247.72 256.04 "Игорь Лабутин" Если вы зачем-то используете function pointer, которые появились в пятом дотнете и в девятом, соответственно, C#, то их не было в reflection, но теперь они появились.
256.04 258.04 "Игорь Лабутин" Стало хорошо, все прекрасно.
258.04 262.92 "Игорь Лабутин" Вот и все, что изменилось в основном дотнете.
262.92 267.28 "Анатолий Кулаков" Ну да, действительно, что-то там мало насобирали, зачем они-то выпускали.
267.28 269.76 "Игорь Лабутин" Ну, видимо, все-таки ради каких-то bugfixes.
269.76 274.08 "Игорь Лабутин" В ispnetcore более интересные штуки.
274.08 285.48 "Игорь Лабутин" В blazer завезли штуку под названием quickgrid, это компонент грида, по сути, который был экспериментальным в седьмом дотнете, но сейчас стал уже полноценной частью восьмого дотнета.
285.48 288.44 "Игорь Лабутин" Если вам нужны гриды в blazer, попробуйте использовать, может понравиться.
288.44 299.56 "Игорь Лабутин" Важное изменение, которое, в принципе, ну, такое обычного порядка для всяких превью, в blazer появилась штука под названием jitterpreter.
299.56 303.12 "Игорь Лабутин" Я даже не знаю, как это правильно произносить.
303.12 304.12 "Игорь Лабутин" Jitterpreter?
304.12 305.12 "Игорь Лабутин" Jitterpreter.
305.12 306.12 "Игорь Лабутин" Jitterpreter.
306.12 307.76 "Игорь Лабутин" Это прям такое нормальное английское слово.
307.76 309.24 "Игорь Лабутин" Посмотрите, в чем суть.
309.24 317.40 "Игорь Лабутин" У нас есть в blazer, когда вы туда компилируете дотнетный код, у вас с собой тащится, понятно, какой-то runtime, небольшой.
317.40 325.48 "Игорь Лабутин" Для того, чтобы он был небольшим, этот самый runtime, там, по сути, используется просто интерпретатор, который интерпретирует или код, и его исполняет.
325.48 331.52 "Игорь Лабутин" Альтернативно вы можете сделать nativeout компиляцию.
331.52 362.72 "Игорь Лабутин" Результат будет такой, что, в принципе, получится альтернативный восьмовый код, но сейчас получится, что размера итогового файла будет больше, и кроме того, на самом деле, некоторые, как они выражаются, dotnet coding patterns, то есть тот метод, стиль, которым вы пишете дотнет, те конструкции, не все они совместимы с head-of-time компиляцией, поэтому на самом деле интерпретатор все равно с собой тащится, чтобы там, если что, немножко доинтерпретировать, все-таки исполнить что-то.
362.72 376.64 "Игорь Лабутин" Но интерпретатор — штука медленная, и для того, чтобы ее ускорить, а это, я так понимаю, все-таки скорее дефолтный вариант использования Blazor в WebAssembly, без head-of-time компиляции, то появилась вот такая штука под названием giterpreter.
376.64 378.92 "Игорь Лабутин" Он не interpreter, он giterpreter.
378.92 394.12 "Игорь Лабутин" Это штука, которая, на самом деле, частично jitted код в кусочке WebAssembly кода на лету, но только тот, который исполняется, тот, который исполняется, видимо, нечасто, и за счет этого достигается хороший выигрыш в производительности.
394.12 408.24 "Игорь Лабутин" То есть не весь код jittits, как в отличие от нормального рантайма, а только по какой-то, значит, эвристикам, но даже это позволяет довольно сильно ускорить исполнение.
408.24 415.72 "Игорь Лабутин" Там есть бенчмарки, в которых они там чуть ли не раз в два все ускоряют, какие-то там довольно синтетические пока бенчмарки, на каких-то реальных примерах пока не видно.
415.72 421.32 "Игорь Лабутин" Но это только-только вышло, поэтому скорее всего статьи подъедут про то, как стало лучше.
421.32 432.76 "Игорь Лабутин" Эта штука, в отличие от многих фич, она вполне себе включена сразу, поэтому ничего не надо дополнительно включать, никаких ложков, просто берете и пользуйтесь.
432.76 436.84 "Игорь Лабутин" Кроме того, в ISP.NET Core завезли несколько новых аналайзеров.
436.84 452.16 "Игорь Лабутин" Один из них, например, он детектит, что вы несколько раз написали from body, пометили, точнее, несколько параметров с помощью атрибута from body, но это, как очевидно, не совсем хорошо, поэтому такое теперь будет детектировать в Visual Studio, но аналайзерами.
452.16 466.48 "Игорь Лабутин" В problem details.py завезли там некоторые тоже улучшения, хорошие функции про try, сделать что-нибудь, чтобы была возможность заблокироваться в другое поведение, если вдруг что-то не получилось.
466.48 479.28 "Игорь Лабутин" Если вы вдруг пользуетесь object pool, у меня есть такой класс object pool, это штука, которая позволяет, ну стандартная библиотека кусочек, которая позволяет пулить объекты, через него, например, реализованы всякие пулы в антреке стрелы, я так понимаю, и так далее.
479.28 487.44 "Игорь Лабутин" Так вот, теперь там есть поддержка интерфейса iresettable, это интерфейс, в котором есть единственный метод try_reset, по-моему, даже без аргументов, и ничего не возвращающий.
487.44 497.24 "Игорь Лабутин" Смысл в том, что object pool теперь, если вы на своем объекте реализуете этот интерфейс iresettable, то при возврате этого объекта в object pool, object pool автоматически будет дергать этот метод.
497.24 503.56 "Игорь Лабутин" Удобно для очистки объектов перед их возвращением в pool, автоматически, независимо от того, откуда вы их возвращаете.
503.56 523.40 "Игорь Лабутин" Ну и мы рассказывали, что в прошлом превью добавили поддержку named pipes в kestrel, в этом превью ее ускорили, в их бенчмарке то, что раньше занимало 5,9 секунд, стало занимать 2,3 секунды, то есть больше, чем в 2 раза получается на создание 100 тысяч connections.
523.40 528.80 "Игорь Лабутин" Так что не станет ребят на месте, improve performance, как обычно.
528.80 535.16 "Игорь Лабутин" Ну и EFCore, EFCore там прям в заголовке статьи было сказано, что релиз маленький, поэтому ничего серьезного не ждите.
535.16 537.84 "Игорь Лабутин" Добавили по сути две штуки, но хотя они не такие маленькие.
537.84 545.16 "Игорь Лабутин" Во-первых, добавили поддержку json-колонок для SQLite, она была для SQL и для Postgres, теперь и для SQLite.
545.16 572.64 "Игорь Лабутин" Для SQL Server добавили поддержку hierarchy, значит в SQL Server есть такой специальный тип базы данных, называется hierarchy id, точнее называется hierarchy, а в .NET ему соответствует тип hierarchy id, в котором есть пачка методов, которые теперь можно использовать в linq, достать всех детей, проверить является ли предком, проверить на какой глубине мы сейчас находимся относительно родителя.
572.64 582.16 "Игорь Лабутин" Вот это все теперь можно использовать в linq из этого типа и оно будет корректно транслироваться в соответствующие конструкции SQL Server для работы с типами иерархии.
582.16 586.16 "Игорь Лабутин" Ну в общем вот такой вот превью номер два.
586.16 603.24 "Анатолий Кулаков" Вот это кстати клевая штука, я hierarchy id очень часто использовал когда на мосэскейт жил и вообще удивляюсь как до сих пор не протащили во всех базах данных, потому что очень часто есть требование построить какую-то иерархию, не важно там ролей, пользователей, структуры компании, еще чего-то.
603.24 614.16 "Анатолий Кулаков" Довольно частый случай, не зря его внесли и он очень скоростной, он прям намного лучше чем обычно, намного лучше чем то что мы делаем руками обычно для построения иерархии в базах данных нормализированных.
614.16 620.36 "Игорь Лабутин" Ну потому что там обычно всякие запросы через эти CTE, Common Table Expression.
620.36 636.96 "Анатолий Кулаков" Не, ну там есть алгоритмы, там типа CLK, parent-child и так далее, там есть подходы где ты можешь нормально сделать, но они тоже в зависимости от того что ты там будешь делать, переставлять, переносить, вставлять, то есть там надо думать очень много о том как это будет использоваться, а этот чувак он оптимизирован почти подо все.
636.96 643.00 "Игорь Лабутин" Ну да, ну в общем вот теперь есть поддержка в Antity Framework, если вы вдруг этим пользуетесь, забирайте и используйте.
643.00 657.20 "Анатолий Кулаков" Мне кажется вот этот Blazor Grid, он наверно заставил вот этот весь Preview 2 и выпустить, потому что это такая самая большая фича, то есть ASP скорее всего продвинул то, чтобы вы увидели Preview 2 для всех остальных тузов.
657.20 662.32 "Игорь Лабутин" Ну Grid не уверен, а вот эта штука с интерпретатором, которая сильно все ускоряет, может быть.
662.32 671.64 "Анатолий Кулаков" Ну интерпретатор, ты же все равно не потащишь Preview 2 в продакшн, чтобы интерпретатор там показал всю свою скорость, а вот уже разрабатывать под новый Grid ты уже можешь на превьюшке начать.
671.64 674.64 "Игорь Лабутин" Тоже верно, да, может быть так.
674.64 676.64 "Игорь Лабутин" Ну мы типа и не узнаем этого.
676.64 686.20 "Игорь Лабутин" Давай пойдем дальше, у нас сегодня много статей и они некоторые, мягко говоря, не очень короткие, поэтому давай что-нибудь интересненькое пообсуждаем.
686.20 695.28 "Анатолий Кулаков" Да, хорошая тема, которую мы можем узнать, раскрылась нам благодаря новой мании Евгения Пешкова, за что им огромное спасибо.
695.28 698.60 "Анатолий Кулаков" Он теперь начал писать статейки, статейки годные, нужные.
698.60 702.84 "Анатолий Кулаков" И вот как раз одну из статей Жене хотелось бы с вами сегодня обсудить.
702.84 713.48 "Анатолий Кулаков" А статья называется "Нужен ли конфигурровейт?" Вот так незвано, негадано уже там, который десяток дотнету пошел, а мы все еще никак не можем разобраться с этим конфигурровейтом.
713.48 720.28 "Анатолий Кулаков" И вот Женя решил все-таки поднять тему, разобрать ее и найти какие-нибудь ответы на эти вопросы.
720.28 723.48 "Анатолий Кулаков" Давайте же присоединимся к нему и посмотрим, что вышло.
723.48 729.04 "Анатолий Кулаков" Прежде всего давайте вспомним, что же такое конфигурровейт, что он делает и зачем он нужен.
729.04 735.76 "Анатолий Кулаков" Прежде всего действительно не очень хорошо, когда ваш код измазан каким-то непонятным инфраструктурным изобилием.
735.76 744.04 "Анатолий Кулаков" То есть когда ваша бизнес-логика легко и хорошо читается, это хорошо, это всем понятно и легко отлаживать, легко писать, легко считать.
744.04 747.80 "Анатолий Кулаков" И обычно это воспринимается очень нормально.
747.80 755.16 "Анатолий Кулаков" Но когда ваша инфраструктура требует обилия каких-то непонятных символов, заклинаний, магических мантр, это плохо.
755.16 767.68 "Анатолий Кулаков" И вот конфигурровейт является наверное самым ярчайшим показателем того, что изобильные слова в вашем инфраструктурном коде портят абсолютно все, порчат читабельность, весь этот лаконичный красивый код.
767.68 776.60 "Анатолий Кулаков" А так как таски пронизывают обычно наши программы насквозь, то конфигурровейт фоллс обычно тоже пронизывает все наши программы насквозь.
776.60 784.12 "Анатолий Кулаков" И уже даже очень многие забыли, зачем мы его пишем, а может даже джуны подросли те, кто ни разу не помнил, зачем мы его пишем.
784.12 788.60 "Анатолий Кулаков" Поэтому данная тема обросла очень большим количеством всяких мифов.
788.60 797.24 "Анатолий Кулаков" Но несмотря на это, на код ревью все равно часто спрашивают, что это такое, зачем нужно, как используется и что будет, если неправильно использовать.
797.24 801.92 "Анатолий Кулаков" И давайте же все-таки разберемся, что это такое.
801.92 805.84 "Анатолий Кулаков" Прежде всего асинхронный код используют у нас ключевые слова async/await.
805.84 815.16 "Анатолий Кулаков" На самом деле это директивы компилятора, которые помогают ему осознать, что асинхронный код во время компиляции нужно разложить на стоит машину.
815.16 819.08 "Анатолий Кулаков" И он это успешно во время компиляции делает.
819.08 827.72 "Анатолий Кулаков" На каждый await происходит разделение блоков синхронного кода, так называемые continuation.
827.72 831.88 "Анатолий Кулаков" И эти continuation вызываются друг за другом.
831.88 848.08 "Анатолий Кулаков" И переход между ними происходит либо путем подписки на асинхронное действие, когда первый блок кончается, асинхронное действие вызывается, или если же асинхронное действие завершилось до await, то выполнение продолжается прямо там же.
848.08 850.80 "Анатолий Кулаков" Ничего не вызывается, никаких подписок не происходит.
850.80 856.20 "Анатолий Кулаков" Вот в принципе и все, на что раскладывается async/await.
856.20 864.16 "Анатолий Кулаков" Теперь давайте представим себе обычный банальный код, который, наверное, многие из вас, кто знает WinForm или другой UI, писали как в UI.
864.16 870.72 "Анатолий Кулаков" Допустим, нам нужно вызвать обычный, то есть обработать код, как обработчик на кнопочке.
870.72 883.32 "Анатолий Кулаков" Этот обработчик будет с помощью HTTP Client, допустим, ходить куда-то далеко в сеть, доставать какой-то документ, десерилизовывать его и итоговую строку, которую получили в результате десерилизации, засовывать в UI.
883.32 889.08 "Анатолий Кулаков" Вот чтобы выполнить такую простую штуку, мы сталкиваемся сразу с несколькими сложными концепциями.
889.08 897.92 "Анатолий Кулаков" Во-первых, вот если мы выполним такой банальный код с помощью нашего обычного await, то это все будет выполняться в UI потоке.
897.92 908.04 "Анатолий Кулаков" Это нужно для того, чтобы текст, который мы получили в результате хождения по сети и десерилизации, присвоить UI-ному контролу.
908.04 913.68 "Анатолий Кулаков" UI-ный контрол можно изменять только в том потоке, где был создан этот контрол, то есть в котором крутится event loop.
913.68 916.96 "Анатолий Кулаков" И именно для этого мы должны удерживать эту информацию.
916.96 921.24 "Анатолий Кулаков" И для этого в UI-фреймворках придуман так называемый синхронизейшн контекст.
921.24 925.68 "Анатолий Кулаков" Но это не только для UI-фреймворка он, конечно же, придумал, но он очень сильно там используется.
925.68 933.72 "Анатолий Кулаков" Синхронизейшн контекст он как раз таки знает, где находится UI-ный поток и куда нужно возвращаться асинхронному коду для того, чтобы продолжить с ним работать.
933.72 940.28 "Анатолий Кулаков" Если же мы начнем контролы менять вне UI-ного потока, то наша программа успешно рухнет, потому что C/E запрещено.
940.28 946.80 "Анатолий Кулаков" И синхронизейшн контекст, как я уже сказал, не только в UI используется.
946.80 952.80 "Анатолий Кулаков" Например, есть XUnit, замечательный тестовый фреймворк, который тоже работает с синхронизейшн контекстом.
952.80 956.16 "Анатолий Кулаков" Для того, чтобы работать с асинхронными тестами.
956.16 961.44 "Анатолий Кулаков" Учитывать параллелизмы, ловить ошибки, все это делать правильно, красиво, гибко.
961.44 962.60 "Анатолий Кулаков" В общем, там тоже использовался.
962.60 968.40 "Анатолий Кулаков" В старом ASP.NET тоже был асинхронизейшн контекст для доступа к HTTP-контексту.
968.40 970.92 "Анатолий Кулаков" В новом ASP.NET Core его нет.
970.92 981.08 "Анатолий Кулаков" Многие на собеседовании ошибочно считают, что в .NET Core удалили синхронизейшн контекст, и поэтому в .NET Core нам не грозят никакие дедлоки.
981.08 988.56 "Анатолий Кулаков" На самом деле, это заблуждение пошло из этого непонимания, что в .NET Core не может быть никакого синхронизейшн контекста.
988.56 991.08 "Анатолий Кулаков" Он был в ASP.NET Core, и оттуда его удалили.
991.08 993.56 "Анатолий Кулаков" Но к дедлокам мы вернемся еще немножко попозже.
993.56 1001.12 "Анатолий Кулаков" И таким же образом можно немножко поиграться с TaskScheduler, который примерно приведет к тем же последствиям.
1001.12 1003.52 "Анатолий Кулаков" Теперь давайте вспомним про дедлок.
1003.52 1010.28 "Анатолий Кулаков" Помните наш пример с обработчиком кнопочки, который в UI потоке лазит куда-то в сеть, децерализует и все это записывает.
1010.28 1034.00 "Анатолий Кулаков" Если мы вдруг не захотим этого делать с помощью наших асинхронных кейвардов, а захотим это сделать синхронно, например, вызовем метод getText и вызовем у него волшебную цепочку, которая называется getAwaiter, getResult, никогда так не делайте, то в этом случае UI поток заблокируется.
1034.00 1035.20 "Анатолий Кулаков" Почему так происходит?
1035.20 1042.88 "Анатолий Кулаков" В соответствии с синхронизейшн контекстом внутренний континьюэйшн метода, который мы уже говорили будет там выполняться, должен выполниться на UI потоке.
1042.88 1047.96 "Анатолий Кулаков" Но UI поток в этот момент заблокирован и не может выполнить данный континьюэйшн.
1047.96 1050.24 "Анатолий Кулаков" И в результате у нас происходит дедлок.
1050.24 1059.52 "Анатолий Кулаков" Я думаю, что любой человек, который программировал UI и конечно же сталкивался с асинхронным кодом, обязательно ловил этот дедлок.
1059.52 1065.20 "Анатолий Кулаков" Про него тоже очень часто спрашивают на собеседованиях, почему он происходит, как он получается и как от него самое главное избавиться.
1065.20 1070.08 "Анатолий Кулаков" И самое интересное, что этот дедлок может в некоторых случаях не произойти.
1070.08 1078.60 "Анатолий Кулаков" Если допустим мы успели выполнить getText, он выполнился синхронно или в нем произойдет переключение на другой контекст, то никакого дедлока не будет.
1078.60 1080.84 "Анатолий Кулаков" Но обычно он довольно легко воспроизводится.
1080.84 1093.52 "Анатолий Кулаков" Итак, если же мы все-таки делаем наш асинхронный метод, вызываем в UI потоке, то у нас происходит лишняя нагрузка на UI.
1093.52 1102.34 "Анатолий Кулаков" Например, если мы пойдем в сеть, начинаем децерализовываться, то в принципе никакой это блокировки не будет, но UI поток будет сильно перегружен вот этими ненужными ему операциями.
1102.34 1107.60 "Анатолий Кулаков" На самом деле он должен следить только за отрисовкой контролла, а мы его напрягаем еще сетью и децерализацией.
1107.60 1112.12 "Анатолий Кулаков" И это может привести к тому, что ваше приложение станет немножко неотзывчивым.
1112.12 1121.28 "Анатолий Кулаков" И вот, чтобы победить все эти проблемы и дедлоки, и загрузку UI потока, неотзывчивый юзерский интерфейс, и был придуман метод конфигура WaitFalls.
1121.28 1133.56 "Анатолий Кулаков" И как раз таки он и заставляет избавиться от синхронизации контекста, то есть не учитывать синхронизацию контекста при выполнении цепочек, при выполнении continuation, а выполнять все на ThreadPool.
1133.56 1146.88 "Анатолий Кулаков" Если мы добавим его к нашему волшебному методу, то все таски будут выполняться на ThreadPool, но тот код, который вернется, самый последний, который должен все-таки изменить UI контрол, он уже будет со своим правильным UI синхронизацией контекста.
1146.88 1155.16 "Анатолий Кулаков" Этот метод, конфигура WaitFalls, он полезен не только для тасков, его протащили для всего, что связано вокруг.
1155.16 1159.20 "Анатолий Кулаков" Это Value таски, это AsyncEnumerable, это AsyncDisposable.
1159.20 1169.28 "Анатолий Кулаков" Кстати, с AsyncDisposable есть небольшой интересный подводный камень, нам завезли такую прекрасную штуку, как AwaitUsing, в принципе, довольно-таки недавно.
1169.28 1176.32 "Анатолий Кулаков" С помощью него мы можем вызывать асинхронный Disposable метод у тех классов, которые его реализуют.
1176.32 1179.24 "Анатолий Кулаков" Но не до конца его довезли вообще.
1179.24 1180.60 "Анатолий Кулаков" Там есть определенный момент.
1180.60 1195.92 "Анатолий Кулаков" Если, допустим, мы получаем какой-то стрим, например, какой-то поток, какой-то класс, получаем с помощью асинхронного метода, например, OpenAsync делаем, возвращаем асинхронный стрим, то мы должны дождаться его с помощью ключевого слова Wait, естественно.
1195.92 1214.04 "Анатолий Кулаков" И если мы вот эту конструкцию, как обычно, пишем одной строчкой в Using, в нашем случае в AwaitUsing, и ставим конфигура WaitFalse, то на самом деле конфигура WaitFalse применяется только для получения этого объекта, только для Open, только для Create.
1214.04 1220.88 "Анатолий Кулаков" А вот AsyncDispose вызывается без конфигура WaitFalse, то есть вызывается не на ThreadPool.
1220.88 1230.20 "Анатолий Кулаков" И вот для того, чтобы и создание, и Dispose сделать асинхронным, нам придется все-таки наш AwaitUsing разбить на две строчки.
1230.20 1234.96 "Анатолий Кулаков" Первый мы получаем, вызываем конфигура WaitFalse, второй мы Dispose, вызывает конфигура WaitFalse.
1234.96 1247.12 "Анатолий Кулаков" Вот это ломает очень сильно код, выносит переменную за scope и так далее, в общем делает код не очень красивым, но без этого реально может быть плохо, без этого реально можно словить дедлоки.
1247.12 1256.44 "Анатолий Кулаков" Поэтому это тоже нужно знать, потому что дедлоки асинхронного кода, они безумно неинтуитивны, никакого стектрейса у вас не будет, вы просто зависнете непонятно где.
1256.44 1267.88 "Анатолий Кулаков" И существует очень мало способов, и очень мало людей, которые этими способами могут пользоваться для того, чтобы понять, что вы находитесь в асинхронном дедлоке, и где именно, и как его словить.
1267.88 1272.68 "Анатолий Кулаков" В общем лучше туда не попадать, это страшная яма.
1272.68 1281.00 "Анатолий Кулаков" Итак, Женя предлагает несколько способов, как мы можем обойтись без вот этой грязи в коде, как обойтись без конфигуровать фолт просто на каждый Await.
1281.00 1282.52 "Анатолий Кулаков" Есть несколько подходов.
1282.52 1286.50 "Анатолий Кулаков" Первый, прежде всего, это решить проблему на стороне вызывающего кода.
1286.50 1311.40 "Анатолий Кулаков" Это значит, что весь код, которому не нужен синхронизаторный контекст, мы это можем решить прямо в том месте, где мы вызываем другие библиотеки, другий код, например, в том же самом обработчике button click'a, мы знаем, что нам нужно текст выставить только в явном потоке, а все, что будет выполняться в методе получения строки, там get text какой-нибудь, ему не нужен никакой контекст, мы решили за него это сами.
1311.40 1315.76 "Анатолий Кулаков" Значит мы можем выполнить все остальные continuation'ы на ThreadPool.
1315.76 1318.88 "Анатолий Кулаков" Например, это можно сделать с помощью Tascran.
1318.88 1327.60 "Анатолий Кулаков" И делегат, который мы передаем в Tascran, он будет выполняться без какого-то либо контекста синхронизации, все его таски будут на ThreadPool'е, и мы добьемся желаемого результата.
1327.60 1335.48 "Анатолий Кулаков" Внутри него можно не ставить никакие configure await, потому что контекста нет, выйти нечего, и так все будет работать прекрасно.
1335.48 1339.24 "Анатолий Кулаков" Второй способ, это использовать правильное синхронное ожидание.
1339.24 1343.16 "Анатолий Кулаков" То есть можно сделать синхронную обработку над асинхронными методами.
1343.16 1349.64 "Анатолий Кулаков" Многие об этом мечтали, не у всех получалось, но если немножко подойти с головой к этому делу, то сделать такую штуку можно.
1349.64 1353.76 "Анатолий Кулаков" И она будет устойчива к дедлокам, к тем, что мы рассмотрели ранее чуть выше.
1353.76 1356.04 "Анатолий Кулаков" Это тоже обязательно нужно учитывать.
1356.04 1375.32 "Анатолий Кулаков" То есть вот эта страшная фраза getAwaiter, getResult, за которую нужно отбивать руки каждый раз, когда вы ее увидите в коде или на код-ревью, ее на самом деле можно написать правильно, так чтобы она учитывала текущий синхронизация контекст, и проверял там текущий task scheduler, и в определенных случаях ее можно вызывать, чтобы она не задедлочилась.
1375.32 1378.88 "Анатолий Кулаков" В общем, можно сделать хорошую оберточку над ней и использовать ее.
1378.88 1383.80 "Анатолий Кулаков" Третий способ – это однократный переход в тестпул.
1383.80 1398.84 "Анатолий Кулаков" Для обработчиков асинхронного кода в различных библиотеках, то есть для авторов различных библиотек, этот способ может быть наиболее приемлем, потому что они на самом деле, любая библиотека, она не знает, из какого кода она вызывается, будет там синхронизация контекста или не будет.
1398.84 1402.48 "Анатолий Кулаков" Но обычно библиотекам он не нужен.
1402.48 1406.72 "Анатолий Кулаков" Есть UI на библиотеке, там с ними вопрос не стоит, они сами знают, что им делать.
1406.72 1411.96 "Анатолий Кулаков" Но там 99,9% библиотек не UI, им этот контекст не нужен.
1411.96 1417.32 "Анатолий Кулаков" И естественно, нормальную красивую библиотеку так же точно засорять конфигурацию не хочется.
1417.32 1435.24 "Анатолий Кулаков" Поэтому можно один раз в начале метода, в точке входа в библиотеку, даже правильнее сказать, во всех публичных методах, в которых мы входим в библиотеку, выставить специальный метод расширения, который позволит нам отдетачиться от синхронизации контекста.
1435.24 1445.72 "Анатолий Кулаков" Он работает на основе ThreadPool, QUserWorkItem, не суть важная, но он как раз может перебросить все наши континьюшн в ThreadPool.
1445.72 1455.04 "Анатолий Кулаков" И четвертый подход, который нам поможет избавиться от всех конфигуровейтов, может помочь, это использовать бинарную кодогенерацию.
1455.04 1461.72 "Анатолий Кулаков" То есть, например, с помощью плагина Foddy, который умеет на лету, во время компиляции, менять IL-код ваших библиотек.
1461.72 1465.56 "Анатолий Кулаков" У него есть очень много возможностей, соответственно, очень много плагинов.
1465.56 1473.56 "Анатолий Кулаков" И один из плагинов, это который называется ConfigureAwait, который просто наверстка ко всем вашим авейтам дописывает вот эту магическую строчку ConfigureAwaitFalse.
1473.56 1480.48 "Анатолий Кулаков" То есть, в коде ее не будет, но в момент компиляции IL-код переписывается, и там она будет, и в runtime, естественно, она тоже появится.
1480.48 1485.08 "Анатолий Кулаков" В общем, вот такой тоже подход, он тоже есть.
1485.08 1488.68 "Анатолий Кулаков" Итак, какие же выводы делает Женя?
1488.68 1501.84 "Анатолий Кулаков" ConfigureAwaitFalse не является обязательным методом, то есть, можно перейти на ThreadPool с помощью экстеншен-метода Красивого и над своим собственным авейтором.
1501.84 1514.40 "Анатолий Кулаков" Можно сделать клиентский код, чтобы научить клиентский код, чтобы он сам перебрасывал контекст для всех внутренних вызовов и использовал синхронизацию контекст только там, где нужно.
1514.40 1523.24 "Анатолий Кулаков" Также нужно не забывать, что в SP Net Core нет больше синхронизации контекста, поэтому там ConfigureAwait вообще бесполезен, хоть вызывайте его, хоть не вызывайте.
1523.24 1532.76 "Анатолий Кулаков" И, в общем, опираясь на все эти выводы, он приходит к той мысли, что не используйте.
1532.76 1539.12 "Анатолий Кулаков" Не используйте и не нужен вам, и если вы не столкнулись с какими-то проблемами, с какими-то багами, то значит, он вам и не нужен.
1539.12 1541.84 "Анатолий Кулаков" Вот такой вывод.
1541.84 1545.72 "Анатолий Кулаков" Хотелось бы сразу вставить парочку замечаний к этому выводу.
1545.72 1554.04 "Анатолий Кулаков" Прежде всего, на мой взгляд, все предложенные решения в данной статье – это безумные костыли.
1554.04 1572.12 "Анатолий Кулаков" То есть очень легко можно забыть метод перескока в правильный синхронизационный контекст, очень легко можно забыть метод поставить перескока в ThreadPool, если мы говорим про автору библиотек или про UI разработчиков.
1572.12 1588.16 "Анатолий Кулаков" В общем, любой джун, который придет в ваш код, он легко забудет про вот эти ваши договоренности, которые магические, которые никто не знает и которые вообще непонятно кем придуманы, как называются и что они делают.
1588.16 1599.00 "Анатолий Кулаков" И это ничем не лучше тех магических строк, той грязи, которую мы сейчас проставляем конфигуровать в Folsom.
1599.00 1600.80 "Анатолий Кулаков" Ну, будет их на 50% меньше.
1600.80 1607.44 "Анатолий Кулаков" Но дело в том, что вот эти конфигурации в WhiteFolsom, они расписаны на каждом углу, они расписаны в каждой документации.
1607.44 1616.56 "Анатолий Кулаков" На них самое главное, что сейчас уже наконец появились нормальные анализаторы, которые позволяют вам анализировать код и на уровне компиляции все это проверять.
1616.56 1628.80 "Анатолий Кулаков" Ну, то есть такие анализаторы были давно, но, к сожалению, они поддерживались все достаточно слабо и сейчас и Microsoft, и ReSharper прямо одновременно договорились и сделали хорошие понятные анализаторы.
1628.80 1637.60 "Анатолий Кулаков" И, к сожалению, у нас нет сейчас никакого более надежного выхода, чем все-таки продолжать писать эти конфигурации в WhiteFolsom.
1637.60 1639.44 "Анатолий Кулаков" Я разверну, почему нет.
1639.44 1645.32 "Анатолий Кулаков" Ну, потому что даже сейчас придумали новый Blazor UI, который казалось бы, вот он новый.
1645.32 1651.08 "Анатолий Кулаков" И более того, он работает прямо на HTML доме, то есть там нет никакого event loop.
1651.08 1654.00 "Анатолий Кулаков" И все равно там у него есть synchronization контекст.
1654.00 1663.12 "Анатолий Кулаков" То есть новая технология, которая да, UI, но она все-таки какая-то нестандартная UI, довольно-таки модная и продвинутая UI, но там все равно нужен synchronization контекст.
1663.12 1670.56 "Анатолий Кулаков" Это как раз показатель того, что появляются новые фреймворки, появляются новые технологии, где вам нужно учитывать, что synchronization контекст может быть.
1670.56 1671.96 "Анатолий Кулаков" А что такое нужно учитывать?
1671.96 1683.92 "Анатолий Кулаков" Это значит, что если из Blazor кто угодно будет работать с вашей либо, и ваша либо будет наплевательски относиться к этому моменту, то он легко может попасть в какую-нибудь беду, например, задедлочиться.
1683.92 1694.76 "Анатолий Кулаков" Это значит, что абсолютно все либо должны учитывать, потому что вас могут использовать и из WinForm, из WPF, из Blazor, из откуда угодно еще, из Maya UI.
1694.76 1709.04 "Анатолий Кулаков" То, что synchronization контекста нет в ISP.NET Core, и там на все можно забить, ну с таким же точным аргументом можно сказать, что так как его оттуда выпилили, его могут легко так и обратно вернуть.
1709.04 1713.52 "Анатолий Кулаков" Или, например, вернуть, то есть добавить его в entity framework.
1713.52 1714.52 "Анатолий Кулаков" Почему бы и нет?
1714.52 1717.36 "Анатолий Кулаков" Как, например, сделали новый фреймворк Blazor UI и добавили его туда.
1717.36 1720.40 "Анатолий Кулаков" То есть так же как он ушел, он точно так же может и появиться.
1720.40 1730.12 "Анатолий Кулаков" Поэтому, опять же, в этом случае наш код должен рассчитывать на будущее, и должен рассчитывать на то, что в будущем его могут использовать в тех фреймворках, где синхронизация контекста все-таки появится.
1730.12 1733.04 "Анатолий Кулаков" И не нужно забывать все-таки про наш любимый XUnit.
1733.04 1735.20 "Анатолий Кулаков" Как бы вы ни крутили, но код ваш тестировать надо.
1735.20 1738.88 "Анатолий Кулаков" И многие тестируют код именно XUnit.
1738.88 1743.00 "Анатолий Кулаков" В XUnit есть синхронизация контекста, он у вас не всегда будет стрелять.
1743.00 1753.16 "Анатолий Кулаков" Он будет стрелять, если вы там начнете играться с параллельностью исполнения тестов, там какое-то количество захотите мерить, какие-то определенные асинхронные эксепшены у вас там будут бросаться.
1753.16 1759.36 "Анатолий Кулаков" В общем, по сути вы не всегда увидите, что у вас могут случиться дедлоки, но в какой-то момент они случатся.
1759.36 1767.12 "Анатолий Кулаков" И я на своей практике, наверное, штук пять уже раз сталкивался с вот этой проблемой, что в тестах случаются синхронные дедлоки.
1767.12 1771.20 "Анатолий Кулаков" Как я уже упоминал, синхронные дедлоки, это очень сложно их задетектить, практически нереально.
1771.20 1780.80 "Анатолий Кулаков" То есть то, что случилось там или магией, или комментированием, или лучше включать анализатор и просто во всем вашем коде ставить конфигуроват фоллс, и тогда дедлоки проходят.
1780.80 1794.24 "Анатолий Кулаков" И они прекрасны, например, тем, что на локальном компьютере они могут не воспроизводиться, а как только вы их заливаете на какой-нибудь off-air или team-site, где у вас ограниченное количество потоков, в которые выполняются тесты, вот там они прям сразу начинают выстреливать.
1794.24 1798.56 "Анатолий Кулаков" В общем, тоже довольно интересный юзкейс за этим за всем наблюдать.
1798.56 1808.32 "Анатолий Кулаков" Справедливости ради нужно сказать, что в принципе все вокруг понимают, что конфигуровать фоллс – это страшно, это грязно, это плохо.
1808.32 1816.84 "Анатолий Кулаков" И в микрософте тоже уже куча пропозов в гитхабе висит еще с давних лет, там уже по 10 лет им, как бы эту ситуацию исправить.
1816.84 1824.12 "Анатолий Кулаков" Самым адекватным, мне кажется, предложение – это добавить атрибут на уровне сборки или параметров CSproj.
1824.12 1836.16 "Анатолий Кулаков" Ну, представляете, была бы какая прелесть, вы добавляете атрибут на уровне assembly, там task-configure-await-falls, например, и все вызовы await вашей сборки автоматически помечаются этим атрибутом.
1836.16 1847.92 "Анатолий Кулаков" Или, допустим, прямо в проект добавляете xml-элемент configure-await-falls, и все, и проект знает, что компилировать его нужно с помощью специального вот этого магического окончания.
1847.92 1851.80 "Анатолий Кулаков" Была бы красота, потому что сборки очень легко разделить.
1851.80 1856.28 "Анатолий Кулаков" Вот эта сборка точно у меня работает с синхронизированным контекстом, там я добавлю такой атрибут.
1856.28 1864.52 "Анатолий Кулаков" Этой сборке он точно не нужен, она никакого RU не знает, ни с каким там ASP.NET не работает, там это все можно отключать.
1864.52 1866.96 "Анатолий Кулаков" Было бы очень замечательно.
1866.96 1890.44 "Анатолий Кулаков" Есть другие предложения, например, переопределение оператора await на уровне проекта, короткий синтаксис, укорочение для configure-await-falls с помощью или магических знаков, или новых ключевых слов, новый вид тасков даже предлагали сделать, который свободен от контекстов, то есть завести отдельные таски, в общем, много других пропозолов, но вот с атрибутом кажется самым адекватным.
1890.44 1903.76 "Анатолий Кулаков" Кстати, ссылочка будет в шоу-нотах, пройдите, кому не лень, проголосуйте за эту штуку, чтобы добавили такой атрибут, который делает таск configure-await-falls удобным и хорошо используемым.
1903.76 1913.60 "Анатолий Кулаков" В принципе, до статьи Жени там было, по-моему, около 20 лайков, сейчас их там под 190, то есть кажется, что Женя внес свой вклад в этот ish-ю.
1913.60 1925.60 "Анатолий Кулаков" В общем, я думаю, что если наши зрители тоже пройдут и проголосуют, может быть, Microsoft обратит внимание на такую штуку и запилит нам, это еще лучше почистит наш код, сделать его еще более мягким и шелковистым.
1925.60 1931.32 "Анатолий Кулаков" Ну что, Игорь, ты как относишься к тем предложениям, которые предложил Женя, и как ты вообще конфигура-ауэйт-вал?
1931.32 1934.04 "Анатолий Кулаков" Проставляешь, не проставляешь, забиваешь?
1934.04 1969.48 "Игорь Лабутин" Надо сказать, что скорее забиваю в основном, наверное, я не очень прав, но тем не менее, у меня практика в моей, ну, я не пользуюсь xUnit почти никогда, то есть я в основном фанат nUnit, и там нет проблем с этим самым, с синхронизейшн-контекстом, ну, по крайней мере, пока его там нету, и поэтому, видимо, на это особо не натыкался, UI я давно не пишу такой прям в продакшене в продакшене, а в SP его действительно нет, поэтому я бы сказал, что, наверное, в среднем я почти нигде не пишу.
1969.48 1985.60 "Игорь Лабутин" Вот, пропозал, да, больше всего мне, конечно, нравится вариант на уровне всего этого самого, я тоже только что поставил свой гол за это, 195 их тут, и целых 3 против почему-то, вот, но, да, надеюсь, что сделаем.
1985.60 2005.04 "Игорь Лабутин" Я еще хотел добавить такую штуку, что вот ты вначале расписал, как же работает async/await кратенько, за 3 минутки, я добавил в show notes статью, которая буквально сегодня вышла, от Стивена Тауба в его любимом стиле, про то, как на самом деле внутри работает async/await.
2005.04 2030.28 "Игорь Лабутин" Я сначала думал, что мы ее отложим до следующего выпуска и прям отдельно посмотрим, но внимательно ее просмотрев, пока ты рассказывал, понял, что мы не будем ее рассказывать голосом, это нереально рассказать, там, каждое второе слово - это ссылка на код, ну, в смысле, это там практически это, они сплошные имена классов, там, всякие вейтеры, не знаю, какой, значит, результат, там, и прочие штуки.
2030.28 2044.60 "Игорь Лабутин" То есть очень детальная статья от Стивена Тауба, как он любит, где все детально описано, как же оно работает на самом деле, в том числе тонкости вокруг configure/await, зачем он был сделан, и что такое synchronization context, и как это все вместе связано.
2044.60 2049.08 "Игорь Лабутин" Я добавил это в show notes, сходите почитайте, если...
2049.08 2056.92 "Игорь Лабутин" Я сам тоже ее пойду прочитаю внимательно после того, как мы закончим писать, чтобы напомнить самому себе, как же это все внутри работает.
2056.92 2083.52 "Анатолий Кулаков" Друзья, зайдите хотя бы даже посмотрите, как пишет Стивен Тауб, просто на скролл посмотрите, я сейчас ее мотаю, у меня уже палец устал мотать, поэтому просто нереальный человек, вот он такую примитивную, казалось бы, простую вещь, а что там этого configure/await, асинки, всего на все одно ключевое слово, он размотал, мне кажется, тут книга целая, жалко, нет плагина, который оценивает, значит, статьи в листах в А4, мне тут кажется, тут просто маленькая книга уже написана.
2083.52 2087.68 "Игорь Лабутин" Ну, я уже, ну, просто у всех листы разные, понятно, понятное дело, но в целом, да.
2087.68 2100.12 "Игорь Лабутин" В общем, вот, ну, посмотрим, во что превратится, в принципе, Microsoft иногда прислушивается к голосам на Гитхаме, и скорее всего, что-то может измениться.
2100.12 2108.56 "Игорь Лабутин" А пока пойдем дальше, я думаю, у нас не закончились анонсы, у нас есть еще анонсы для вас, и это Visual Studio.
2108.56 2127.16 "Игорь Лабутин" Visual Studio 17.6 Preview 1, по-моему, мы ее каким-то образом касались в прошлых выпусках, но, по крайней мере, сейчас у нас прям есть официальная статья, что вот, релиз 17.6 Preview 1, где есть несколько не очень больших на самом деле улучшений, но аккуратненько их распишем.
2127.16 2147.40 "Игорь Лабутин" Во-первых, IDE Productivity, туда затащили как основную функциональность раскраску парных скобочек, если вы помните, мы где-то, наверное, месяца три назад рассказывали, что Mads Christensen запилил такой экстенджер, ну, вот теперь это в основной поставке, скобочки теперь раскрашены разноцветным цветом, чтобы было понятно, где какая.
2147.40 2162.28 "Игорь Лабутин" В GTA можно теперь unstaged кусочки прям построчно, и в студии теперь умеет интегрироваться с GitHub в план issues, то есть там поудобнее можно на них ссылаться, она понимает все ссылки на issues, стало удобнее.
2162.28 2186.44 "Игорь Лабутин" А то, что касается .NET, в IntelliCode, вот эта штука, которая такая типа AlakaPilot, которая подсказывает вам, куда как надо писать и использовать, появилась штука под названием API Usage Examples, это работает пока только для C#, и это штука, которая на основе открытого кода на GitHub может показать, как эту API в среднем используют другие программисты.
2186.44 2191.04 "Игорь Лабутин" То есть такие примерчики, чтобы далеко в Google не ходить, чтобы посмотреть, как использовать.
2191.04 2198.20 "Игорь Лабутин" Студия теперь прямо сама может там тыкнуть, если в специальную плашечку, показать, как это примерно используется другими.
2198.20 2203.80 "Игорь Лабутин" Видим там какой-то тоже искусственный интеллект, все, который выбирает правильный пример использования, я надеюсь.
2203.80 2211.04 "Игорь Лабутин" Дальше, если вы работаете с удаленной отладкой, то теперь вы можете полноценно использовать визуалайзеры.
2211.04 2235.40 "Игорь Лабутин" Мы рассказывали в прошлых выпусках, что там появилось некоторое количество новых визуалайзеров, всякие там строки, там всякие JVT, вот это все, и нумеровый визуалайзер, теперь это все работает с удаленной отладкой, и если вы работаете с Maui, то на ARM64, то теперь есть в Visual Studio превьюшка для тулинга вокруг этого, то есть теперь Maui тулинг поддержан на ARM64.
2235.40 2243.72 "Игорь Лабутин" Ну для C++ тоже там завезли всякий гейминг и кроссплатформы разработки, улучшения, если занимаетесь C++, посмотрите, что поменялось.
2243.72 2251.08 "Игорь Лабутин" И так же как .NET 8 Preview 2 вышло 17.6, студия Preview 2 тоже.
2251.08 2272.08 "Игорь Лабутин" Довольно оперативно, здесь тоже не очень много изменений, во-первых, появилась штука, которая, я даже, кстати, не знал, я никогда не пытался делать это во время билда, но раньше, оказывается, нельзя было в студии делать staging и commit в git, пока идет билд.
2272.08 2274.44 "Игорь Лабутин" Да, я сталкивался с такой штукой, очень странная
2274.44 2279.92 "Анатолий Кулаков" была вещь, потому что я во время билда просто переходил в консоль и делал то же самое, а вот и в студии нельзя
2279.92 2286.80 "Игорь Лабутин" было. Я этого не сталкивался, я видимо, ну то ли у меня билды быстрые, то ли мне никогда не хотелось закоммитить до того, как прошел билд.
2286.80 2302.72 "Игорь Лабутин" И есть даже, так сказать, фидбэк на Microsoft Feedback сайте, как там называется, не помню, про то, что мол, что-то фигня почему так работает, и ответ от Microsoft это не баг, это фича, потому что мол, мало ли, что там билд нагенерит, может вы это хотите закоммитить.
2302.72 2305.48 "Игорь Лабутин" Ну что странная немножко логика, но тем не менее.
2305.48 2317.40 "Игорь Лабутин" Короче, этот фидбэк был закрыт со словами, ну не баг, а фича, но при этом сейчас в статье сослались на эту штуку, со словами "Мы слушаем кастомерский фидбэк, теперь можно".
2317.40 2321.12 "Игорь Лабутин" То есть теперь можно во время билда и стейджи коммитить.
2321.12 2324.80 "Игорь Лабутин" Пожалуйста, делайте.
2324.80 2332.40 "Игорь Лабутин" Чуть-чуть улучшили диалог мержа, добавили интересную штуку, вот это, наверное, я даже буду пользоваться, это брекпойнт группы.
2332.40 2338.60 "Игорь Лабутин" То есть можно теперь несколько брекпойнтов объединить в группу и прям целиком группой ее там enable и disable.
2338.60 2347.96 "Игорь Лабутин" Такой иногда надо, когда вы там, не знаю, отлаживаете какие-то странные сценарии, где у вас нужно то одни три брекпойнта заенеблить, то другие три, вот теперь их можно делать группами.
2347.96 2354.80 "Анатолий Кулаков" У меня еще в этот, не помню, то ли плагин был, то ли уже стандартная студия имеет, а ну-ка напомни мне.
2354.80 2358.96 "Анатолий Кулаков" Было желание сохранять пачку брекпойнтов и загружать их там, типа в файлик и из файлика.
2358.96 2360.84 "Анатолий Кулаков" Не помню, стандартная студия умеет такое делать или
2360.84 2366.20 "Игорь Лабутин" это плагин? Никогда не пользовался таким и не видел такого, так что, наверное, все-таки плагин.
2366.20 2371.04 "Анатолий Кулаков" Но смотри, в общем, сценарий банальный, мне нужно отладить какой-то юзкейс.
2371.04 2376.28 "Анатолий Кулаков" Этот юзкейс там безумно сложный, там мне нужно в 10 точках поставить брекпойнты, посмотреть где там что.
2376.28 2380.16 "Анатолий Кулаков" Но этот юзкейс у меня стабильный, допустим, он возникает там раз в три месяца.
2380.16 2389.24 "Анатолий Кулаков" Я вот эти брекпойнты все расставил и хотел бы их сохранить где-нибудь и загрузить их сразу все, когда в следующий раз через три месяца я к этому юзкейсу вернусь.
2389.24 2391.28 "Анатолий Кулаков" И таких юзкейсов у меня много, там десятых.
2391.28 2402.32 "Анатолий Кулаков" Вот хотелось бы по дате имя какой-нибудь сохранить файлик и при надобности загружать их уже расставленные красивые и удобные для отладки.
2402.32 2404.28 "Анатолий Кулаков" Такой у меня был сценарий на одном из проектов.
2404.28 2409.04 "Анатолий Кулаков" И вот с таким плагином он мне сильно довольно-таки помог.
2409.04 2411.44 "Анатолий Кулаков" Вот немножко похоже на вот эти группы, которые сейчас ты описываешь.
2411.44 2414.84 "Анатолий Кулаков" Но вот если бы их еще можно было сохранять, вообще красота была.
2414.84 2421.32 "Анатолий Кулаков" А, ну и плюс они сохраняются в файлике, их можно зачекинить, и соответственно не только ты их можешь загружать, но и вся твоя команда может пользоваться таким подходом.
2421.32 2425.36 "Игорь Лабутин" Интересно, а он как решает проблему того, что код может подвинуться?
2425.36 2431.28 "Игорь Лабутин" То есть он умно сохраняет не просто номер строчки, а какой-то контекст, в смысле там метод был такой-то?
2431.28 2434.80 "Игорь Лабутин" Или все-таки сохраняет тупо номера строчек?
2434.80 2437.48 "Анатолий Кулаков" Насколько я помню, он там сохранял метод плюс строка.
2437.48 2445.44 "Анатолий Кулаков" То есть если он не находит правильную строку, то есть не матчится у него там код, который должен быть на этой строке, он бросает просто на начало метода, который там есть.
2445.44 2447.88 "Анатолий Кулаков" Двойное, знаешь, двойная перестраховка получается.
2447.88 2449.40 "Игорь Лабутин" В принципе, тоже неплохой вариант.
2449.40 2451.04 "Игорь Лабутин" На практике нормально.
2451.04 2452.04 "Игорь Лабутин" Может быть и добавит.
2452.04 2454.96 "Игорь Лабутин" Я что-то не помню такое в студии, но мне как-то не надо было.
2454.96 2462.56 "Игорь Лабутин" Хотя я согласен, что кейс интересный и наверное я даже с таким сталкивался, но как-то мне не приходило в голову поискать плагин, который умеет их сохранять.
2462.56 2463.56 "Игорь Лабутин" Вот буду знать.
2463.56 2467.56 "Игорь Лабутин" Так, что еще у нас такого добавилось в студии?
2467.56 2475.92 "Игорь Лабутин" А, если вы отлаживаете чего-нибудь, что запущено на VSL, да, Windows Subsystem for Linux, то теперь у вас будут нормальные графики для профайлера.
2475.92 2483.40 "Игорь Лабутин" То есть он там использует .NET всякие, counters и прочее, и все это аккуратненько строит Visual Studio теперь.
2483.40 2492.44 "Игорь Лабутин" Также добавили какие-то вещи для game development, традиционно не будем останавливаться, для мобильной разработки Android manifest файли, которые можно редактировать.
2492.44 2499.00 "Игорь Лабутин" И добавили, почему-то они очень стали любить всякие добавки про Enterprise.
2499.00 2503.56 "Игорь Лабутин" Теперь можно, короче, что-то как-то хостить и деплоить.
2503.56 2507.08 "Игорь Лабутин" Вижу студию из интернета, layout из студии.
2507.08 2508.88 "Игорь Лабутин" Я вообще не очень понял, что там можно делать.
2508.88 2512.76 "Игорь Лабутин" В общем, если вы в Enterprise работаете, может вам это зачем-то надо, но не знаю.
2512.76 2513.76 "Игорь Лабутин" Я вообще не в Enterprise работаю.
2513.76 2523.56 "Игорь Лабутин" Я вообще не в Enterprise, в смысле я не ставлю Visual Studio как Enterprise, так сказать, продукт, в смысле что, там, раскатывай ее на миллионы машин внутри компаний.
2523.56 2530.12 "Игорь Лабутин" И вторая фича тоже для Enterprise менеджмента, можно ограничить, чего будет доступно в инсталлере.
2530.12 2537.20 "Игорь Лабутин" Ну, то есть ты такой запускаешь инсталлер в студии, вот такой вот, таким образом раскатанный, там будет нельзя поставить, не знаю, C++ или там Blazor.
2537.20 2538.20 "Игорь Лабутин" Или WinForms там.
2538.20 2542.36 "Игорь Лабутин" Или WinForms, например, чтобы никто не хотел вообще написать.
2542.36 2544.12 "Игорь Лабутин" Я не знаю, ну, вот, наверное, кому-то надо.
2544.12 2546.00 "Игорь Лабутин" Короче, это в превью 2 вошло.
2546.00 2549.64 "Игорь Лабутин" Ну вот, все это про Visual Studio.
2549.64 2552.92 "Игорь Лабутин" И второй анонс - это Nougat.
2552.92 2562.36 "Игорь Лабутин" Опять же, мне кажется, что мы почти все из этого уже каким-то образом проговаривали рано в разных выпусках, но соберем все вместе.
2562.36 2572.32 "Игорь Лабутин" Все называется анонс Nougat версии 6.5, но при этом тут есть не только про сам Nougat, но и про сопутствующие технологии, а именно Visual Studio.
2572.32 2578.36 "Игорь Лабутин" Первый кусочек - это про Visual Studio, про то, что Visual Studio теперь нормально поддерживает файлик directory-packages-props.
2578.36 2595.36 "Игорь Лабутин" Это тот самый Central Package Management, когда вы в одном месте указываете все версии ваших пакетов, а в одном месте в корне - в Solution, грубо говоря, файлик, который лежит в корне, а во всех проектах уже указываете только ссылки непосредственно на имена пакетов без указания версий.
2595.36 2602.88 "Игорь Лабутин" И Visual Studio теперь умеет нормально это дело менеджить и не будет вам давать внутри пакетов проглядеть на разные версии.
2602.88 2607.68 "Анатолий Кулаков" Да мне казалось, мы же это чуть ли не год назад обсуждали, что все умеют, все подтянули.
2607.68 2610.16 "Игорь Лабутин" Не, Studio как-то не очень быстро умело, мне кажется.
2610.16 2612.04 "Игорь Лабутин" Там вот был какой-то у них лэг.
2612.04 2615.56 "Игорь Лабутин" Но в общем, сейчас все умеет, все нормально.
2615.56 2618.24 "Игорь Лабутин" А вот следующая штука, по-моему, не была.
2618.24 2621.32 "Игорь Лабутин" Visual Studio теперь умеет нормально работать с package-source-mapping.
2621.32 2631.36 "Игорь Лабутин" Напомню, что это штука внутри Nougat-конфига, которая позволяет сказать, что вот если у вас Nougat пакет имя начинается с такой-то маски, то его можно забирать только из такого-то источника.
2631.36 2634.20 "Игорь Лабутин" Вот Visual Studio теперь есть редактор этой штуки.
2634.20 2637.28 "Игорь Лабутин" Можно настраивать, а не просто редактируя файлик в редакторе.
2637.28 2658.28 "Игорь Лабутин" Дальше Nougat теперь, если ваш Nougat-сервер вдруг отвечает с HTTP-кодом 429, про то, что я там типа слишком занят, позвоните попозже, то он обычно, такие сервера отвечают, вместе с ответом присылают заголовок под названием retry-author, где написано, собственно, через сколько, собственно, будет зановато.
2658.28 2668.60 "Игорь Лабутин" Вот Nougat теперь смотрит на этот заголовок и не будет как бы дедосить ваш Nougat-сервер, значит, этими всеми попытками retry, а будет учитывать этот заголовок.
2668.60 2682.36 "Игорь Лабутин" А .NET List Package, точно, я уже рассказывал, что поддерживает теперь JSON-output, то есть можно ему передать минус-минус формат пробел JSON, и список ваших пакетиков будет выдан в виде JSON-чика.
2682.36 2685.68 "Игорь Лабутин" Мало ли зачем-то это нужно.
2685.68 2689.32 "Игорь Лабутин" Большая забавная штука.
2689.32 2693.80 "Игорь Лабутин" Смотри, есть такая опция, называется warnings as errors.
2693.80 2695.80 "Анатолий Кулаков" Замечательная опция, да.
2695.80 2707.60 "Игорь Лабутин" Вот, в статье, кстати, написано, что это не очень часто, не очень частое явление, что ее используют, в большинстве случаев ее не используют, по мнению Microsoft, но может у них какая-то статистика есть.
2707.60 2710.60 "Анатолий Кулаков" Пусть телеметрию нормально соберут, по географии разделят.
2710.60 2715.84 "Игорь Лабутин" Тем не менее, оказывается, есть опция под названием warnings not as errors.
2715.84 2718.16 "Игорь Лабутин" Короче, используется она следующим образом.
2718.16 2727.72 "Игорь Лабутин" Ты, я так понимаю, представляешь функцию warnings as errors, в смысле опцию warnings as errors, у тебя все варнинги становятся эррорами, но некоторые варнинги, ты хочешь, чтобы они остались варнингами.
2727.72 2731.08 "Игорь Лабутин" Ну да, да, я знаю, такая штука бывает, я даже использовал.
2731.08 2739.44 "Игорь Лабутин" Вот я, мне как-то не было такого нужды, но теперь оно есть, в смысле оно есть, и теперь эта штука поддерживает нугетовские варнинги, которые с NU начинаются.
2739.44 2747.56 "Игорь Лабутин" Она их раньше не поддерживала, то есть если вы хотели какой-нибудь нугетный варнинг, который стал эррором, сделать обратно варнингом было нельзя, теперь можно.
2747.56 2769.36 "Игорь Лабутин" Так, Visual Studio, соответственно, теперь релодит Package Sources, когда вы поправили Nuget Config ручками, то есть она мониторит все Nuget Config, а вы помните, да, что Nuget Config собираются вверх по дереву, папочек, значит, она теперь мониторит, что все эти файлики поменялись и корректно будет перечитывать эти Package Sources.
2769.36 2791.16 "Игорь Лабутин" И последнее, Nuget.exe теперь нормально работает с Solution Filter файлами, это такие файлики SLNF, которые позволяют вам загружать не целиком Solution, а только какой-то сабсет проектов, вот Nuget.exe теперь может ресторить, например, только в рамках этого SLNF файлика, все пакетики в этих проектах, не затрагивая вообще целиком ваш Solution.
2791.16 2794.40 "Игорь Лабутин" Ну вот, примерно такие новости про Nuget.
2794.40 2798.40 "Анатолий Кулаков" Ну, хорошо, полезненько, улучшается, импровизируется.
2798.40 2817.84 "Игорь Лабутин" Ну, видишь, Nuget всегда какая-то такая странная штука, то есть он действительно вроде, мы почти в каждом превью про что-нибудь говорим, потому что оно там и в студию входит, и в command-line.net входит, и отдельный Nuget.exe есть, и поэтому вот эти вот анонсы Nuget какого-то версии, они какие-то иногда странноватые, что вроде про все уже рассказывал.
2817.84 2831.48 "Анатолий Кулаков" Не, ну я просто надеялся, что анонсы Nuget.exe этого, они обычно совпадают с анонсами студии, ну в том плане, что все фишки Nuget автоматически должны поддерживаться в новой студии, ну это должна быть фича Microsoft.
2831.48 2843.40 "Анатолий Кулаков" Ладно, там когда-нибудь Raider подтянется и все такое, но то, что он сначала в Nuget выходит, а потом через полгода студия только начинает его поддерживать, вот это странно, что это может создать даже некоторые баги и проблемы у людей.
2843.40 2846.72 "Игорь Лабутин" Ну может, да, теоретически.
2846.72 2850.96 "Анатолий Кулаков" Поэтому ставьте Nuget всегда только вместе со студией, она ставит только то, что поддерживает.
2850.96 2854.16 "Анатолий Кулаков" Ну конечно, да, но если вы поставите последний
2854.16 2866.48 "Игорь Лабутин" дотнет SDK, он как раз подтянет последний. И не факт, что та студия, особенно если вы не пользуетесь превью студии, не факт, что она поддержит все то, что завезли в каком-нибудь dotnet 8 превью x.
2866.48 2873.16 "Анатолий Кулаков" Мне кажется, люди, которые пользуются там превью Nuget и превью студиями, они готовы к таким безобразиям,
2873.16 2875.72 "Игорь Лабутин" поэтому или не пользуйтесь превью. Тоже верно, да.
2875.72 2876.72 "Анатолий Кулаков" Или ждите проблем.
2876.72 2881.20 "Анатолий Кулаков" Ну ладно, хорошо, давай дальше.
2881.20 2891.32 "Анатолий Кулаков" Постал интересную статичку про best practices, называется она «Безопасный диплоймент или как поддержать здоровье вашего приложения во время масштабирования».
2891.32 2893.72 "Анатолий Кулаков" Ну в общем, как-то замудренно называется.
2893.72 2901.84 "Анатолий Кулаков" Короче, это 9 best practices автор собрал, которые должны помочь каким-то образом вашему приложению оставаться сильным, здоровым и красиво диплоиться.
2901.84 2904.88 "Анатолий Кулаков" Тоже слабо понятно, в общем, давайте разбираться на практике.
2904.88 2918.04 "Анатолий Кулаков" Советы довольно странные, некоторые вообще не из той оберы, но я думаю, каждый из вас сможет найти какие-нибудь интересные советы и проанализировать, соответствует ли ваш проект этим советам или нет.
2918.04 2928.56 "Анатолий Кулаков" Прежде всего автор уточняет, что в принципе любое приложение на продакшене должно работать стабильно, это ожидание разработчиков, ожидание клиентов, это зарабатывание денег и так далее.
2928.56 2931.44 "Анатолий Кулаков" Думаю, ни у кого это вопросов никаких не вызывает.
2931.44 2943.00 "Анатолий Кулаков" А как же все-таки убедиться, что оно работает стабильно, что оно живо, что вы не выпускаете каких-нибудь там breaking changes, а если выпускаете, что вовремя узнаете о том, что это плохо, то есть что вы сделали, что-то плохое.
2943.00 2956.60 "Анатолий Кулаков" Естественным ответом на это является автоматизация, потому что приложений много, приложения большие и без автоматизации, без слежения за приложениями в автоматическом режиме вы ничего хорошего не добьетесь.
2956.60 2983.24 "Анатолий Кулаков" И именно благодаря автоматизации, благодаря автоматизации сборки, continuous deployment, quality gate, благодаря тому, что собираются метрики, пишутся на дашборды, мониторятся логи и происходит там магия, которая делает приложение стабильным или помогает разработчикам очень быстро реагировать на некие нестабильности и для кастомера все равно это со стороны все кажется стабильным.
2983.24 2996.28 "Анатолий Кулаков" И вот такие best practices, которые помогут вам сделать ваше приложение вот таким стабильным, красивым и мониторящимся, вот автор и собрал и нам их хочет представить.
2996.28 3000.88 "Анатолий Кулаков" Прежде всего нам говорят, что мы должны использовать фичи флаги.
3000.88 3014.44 "Анатолий Кулаков" И действительно, в принципе, когда вы маленький стартапчик и когда вы пишете маленькое приложение, то вы можете добавлять маленькую фичу в ваше приложение и никакие фичи флаги вам тут не нужны.
3014.44 3022.64 "Анатолий Кулаков" Вы эту маленькую фичу легко добавили, легко протестировали и выкатили на кастомера и скорее всего никаких проблем с вами не будет.
3022.64 3037.84 "Анатолий Кулаков" Но как только у вас появляется большое приложение и как только вы начинаете делать большие фичи, их нужно долго тестировать и может быть по чуть-чуть включать к кастомеру, то соответственно может пойти что-то не так.
3037.84 3041.24 "Анатолий Кулаков" И для того, чтобы такую проблему решить, придумали как раз таки фичи флаги.
3041.24 3047.32 "Анатолий Кулаков" Это может быть банальным булевым флагом, который лежит у вас в конфиге и вы к нему обращаетесь.
3047.32 3051.00 "Анатолий Кулаков" Если такой-то флаг включен, то мы начинаем эту фичу использовать.
3051.00 3053.04 "Анатолий Кулаков" Если он не включен, то не начинаем использовать.
3053.04 3059.16 "Анатолий Кулаков" У нас были несколько выпусков, посвященных фичи флагами, можете поискать, мы говорили про них подробнее.
3059.16 3066.20 "Анатолий Кулаков" Но в основном идея в том, что вы можете некую функциональность отгородить от ее использования.
3066.20 3067.44 "Анатолий Кулаков" Что это вам позволяет сделать?
3067.44 3079.44 "Анатолий Кулаков" Во-первых, это позволяет вам разрабатывать вашу фичу, допустим она огромная, допустим она большая, не целый месяц в отрыве от другой команды, которая в это время фигачит мастер вперед.
3079.44 3082.88 "Анатолий Кулаков" А заимплементить ее чуть-чуть и влить в мастер.
3082.88 3088.54 "Анатолий Кулаков" Так как она все равно под фичи флагом, никто этот фичи флаг включать не будет, то она в продакшене работать не будет.
3088.54 3090.44 "Анатолий Кулаков" Но код уже будет жить своей жизнью.
3090.44 3095.48 "Анатолий Кулаков" Он уже будет рефакториться, уже будет компилироваться, уже будет тестироваться.
3095.48 3100.96 "Анатолий Кулаков" То есть у вас этого расхождения через месяц, вот этих мерш-конфликтов уже не случится.
3100.96 3103.20 "Анатолий Кулаков" Вероятность, по крайней мере, их меньше.
3103.20 3106.34 "Анатолий Кулаков" Поэтому чем чаще вы будете вливаться в мастер, тем лучше.
3106.34 3112.34 "Анатолий Кулаков" И фича флага, это как раз-таки одна из тех штук, которая позволяет вам часто вливаться в мастер.
3112.34 3116.06 "Анатолий Кулаков" И потом, в конце концов, возможно, эту фичу флага вам можно будет удалить.
3116.06 3123.02 "Анатолий Кулаков" Может быть, вы ее даже и оставите для того, чтобы включать только некоторым кастомерам, допустим.
3123.02 3124.10 "Анатолий Кулаков" Следующий совет.
3124.10 3128.50 "Анатолий Кулаков" Добавляйте телеметрию для того, чтобы определять регрессию.
3128.50 3131.46 "Анатолий Кулаков" То есть какие-то проблемы, которые у вас возникают заново.
3131.46 3143.22 "Анатолий Кулаков" То есть вам, как разработчику или как наблюдателю за системой, необходимо знать, необходимо быть уверенным, что ваше приложение работает верно, правильно, так как вы рассчитываете.
3143.22 3148.90 "Анатолий Кулаков" И если вдруг оно работает неправильно, то вам об этом нужно узнать как можно быстрее.
3148.90 3153.42 "Анатолий Кулаков" И вот как раз с помощью телеметрии это и возможно сделать.
3153.42 3155.10 "Анатолий Кулаков" Существуют различные типы телеметрии.
3155.10 3157.90 "Анатолий Кулаков" Прежде всего, наверное, каждый из вас слышал, это логи.
3157.90 3161.34 "Анатолий Кулаков" В логах, прежде всего, должны быть исключения.
3161.34 3168.50 "Анатолий Кулаков" Если вдруг приложение работает неправильно, если вдруг приложение случилось какое-то непредсказуемое поведение, то есть так быть не должно.
3168.50 3170.42 "Анатолий Кулаков" Это тоже должно отражаться в логах.
3170.42 3175.74 "Анатолий Кулаков" И также за логами можно следить как за банальным счетчиком того, сколько приложение пишет.
3175.74 3180.46 "Анатолий Кулаков" Если оно пишет больше, чем обычно при таких сценариях, то это тоже какой-то показатель.
3180.46 3183.74 "Анатолий Кулаков" Если меньше, чем обычно, тем более показатель.
3183.74 3188.70 "Анатолий Кулаков" Полезно также в телеметрию засовывать время исполнения определенных операций.
3188.70 3193.42 "Анатолий Кулаков" Допустим, время исполнения реквеста, то есть какой-то заброс, который к вам пришел.
3193.42 3196.34 "Анатолий Кулаков" Или время похода в базу данных.
3196.34 3197.54 "Анатолий Кулаков" Или еще что-то.
3197.54 3201.74 "Анатолий Кулаков" В общем, такие времена очень часто помогают как раз таки отследить проблемы.
3201.74 3207.46 "Анатолий Кулаков" Если у вас нагрузка на приложение нормальная или слабая, то у вас будет одно время ответа.
3207.46 3219.42 "Анатолий Кулаков" Если вдруг железа начнет не хватать, и это во время много пользователей пришло, или какая-то нагрузка с многих клиентов начала валиться на ваше приложение, то обычно как раз таки увеличивается время ответа клиента, то есть реквест тайм.
3219.42 3226.38 "Анатолий Кулаков" И это обычно самый легкий и самый простой способ, как вы можете увидеть, что ваше приложение не справляется с чем-то.
3226.38 3241.30 "Анатолий Кулаков" Это как раз телеметрия на duration, на время, к различным ресурсам, к реквестам, к базам данных, к эшам, к формам, время ответа пользователю, время реагирования на UI.
3241.30 3242.94 "Анатолий Кулаков" То есть вот эти все времена желательно.
3242.94 3246.94 "Анатолий Кулаков" Чем больше вы их будете за ним следить, тем за большим количеством, тем лучше.
3246.94 3253.18 "Анатолий Кулаков" Также очень полезно иметь диагностику о том, что ваше приложение упало.
3253.18 3261.78 "Анатолий Кулаков" И чем быстрее вы среагируете на этот факт, что оно упало, тем естественно для вас лучше, тем больше вы сможете сделать чего-то полезного.
3261.78 3270.22 "Анатолий Кулаков" Ну и желательно, чтобы оно при падении притащило какую-то полезную информацию, то есть там stacktrace, dump, где упало, почему, какой-то контекст полезный и так далее.
3270.22 3288.78 "Анатолий Кулаков" Очень полезно каждому приложению также делать некий дешборд здоровья, некий график здоровья, который будет показывать те метрики, которые мы обсудили выше, там допустим всякие duration, request execution time, так и следить там например за машиной, следить за уровнем потребления CPU, memory, сколько было ошибок, сколько было падений.
3288.78 3306.94 "Анатолий Кулаков" Вот это все лучше выводить прямо на одном графике, на который по дефолту там смотрит ответственное лицо и может по этому одному графику определить, хорошо ваше приложение работает или плохо, или если найдет какую-то проблему, чтобы он мог в нее углубиться и дальше уже рассмотреть поподробнее.
3306.94 3330.58 "Анатолий Кулаков" Третий совет, который нам дает автор, это в том, что вам нужно добавлять алерты, то есть вам нужно добавлять какие-то триггеры, которые будут автоматически смотреть за вашей системой, находить какие-то аномалии, это могут быть появление ошибок, это могут быть краши приложения, это могут быть внезапные всплески количества пользователей или возросшее время ответа пользователю.
3330.58 3338.90 "Анатолий Кулаков" Какие угодно аномалии, которые вы настроите, которые вы зададите и главная задача вот этого третьего пункта это вовремя сообщать об этих проблемах.
3338.90 3347.78 "Анатолий Кулаков" То есть если мы в предыдущем пункте обсуждали телеметрию, это все-таки дешборд, на который вы можете зайти и посмотреть.
3347.78 3366.14 "Анатолий Кулаков" А смысл третьего пункта, алертов, это про активная защита, то есть он сам посмотрит самые ключевые, самые важные метрики и сообщит вам, неважно как, смс, почта, телеграмма, может быть чем-то еще подергает, позвонит, но алерты это довольно-таки важная штука.
3366.14 3368.26 "Анатолий Кулаков" Четвертый пункт, онкол инженеры.
3368.26 3371.54 "Анатолий Кулаков" Игорь, у вас вообще есть онкол инженеры?
3371.54 3378.78 "Игорь Лабутин" Да, но это эксплуатация живет немножко отдельно, поэтому в целом есть, но это не разработка.
3378.78 3385.78 "Анатолий Кулаков" Слушай, у нас по-моему тоже есть эксплуатация, но что-то я как-то не сталкиваюсь с онкол инженерами, почему-то слишком далеко.
3385.78 3403.34 "Анатолий Кулаков" Ну допустим, автор говорит, что онкол инженеры нужны, потому что если вы наделаете себе много красивых дашбордов, если вы наделаете себе безумно прекрасные алерты, но их некому будет слать, и на эти дашборды некому будет смотреть, и некому будет реагировать, то нафиг они никому не нужны.
3403.34 3415.42 "Анатолий Кулаков" Поэтому нужны некие инженеры, некие люди, которые в предсказуемое время обязаны смотреть на здоровье вашего приложения, обязаны следить за дашбордами, обязаны реагировать на алерты каким-то образом.
3415.42 3431.82 "Анатолий Кулаков" Они могут, не знаю, добавить банальное железо или оформить багу для того, чтобы когда пришел разработчик, посмотрел на эту проблему как-то получше, или просто зафиксировать, что были какие-то аномалии для каких-то будущих расследований, или зайти даже починить что-то, если для этого хватает компетенций.
3431.82 3435.70 "Анатолий Кулаков" Короче, заводите себе онкол инженеров, это вроде как тоже важно.
3435.70 3443.94 "Анатолий Кулаков" Пятый пункт – это использование вашего кастомера как прекрасного источника для фидбэка.
3443.94 3452.26 "Анатолий Кулаков" Многим, наверное, не задумывались, но кастомер – это замечательный коай-инженер, потому что если вдруг что-то не работает, он обязательно об этом скажет.
3452.26 3454.98 "Анатолий Кулаков" Поэтому эту возможность нужно использовать.
3454.98 3459.54 "Анатолий Кулаков" В частности, сделайте вашему приложению какую-нибудь удобную кнопку фидбэка.
3459.54 3463.70 "Анатолий Кулаков" Например, каждый из вас видел в Visual Studio, там есть прям такая кнопочка «послать фидбэк».
3463.70 3468.38 "Анатолий Кулаков" Там вы можете прикрепить скриншоты, дампы, какие-нибудь описания свои, собственно, делать.
3468.38 3470.22 "Анатолий Кулаков" Вот про это он говорит.
3470.22 3473.30 "Анатолий Кулаков" Что дайте кастомеру хорошую возможность дать вам фидбэк.
3473.30 3475.18 "Анатолий Кулаков" И, скорее всего, этим будут пользоваться.
3475.18 3479.54 "Анатолий Кулаков" То есть вы получите бесплатную обратную связь непосредственно тех людей, которые ее используют.
3479.54 3482.62 "Анатолий Кулаков" То есть, скорее всего, это какой-то будет полезный функционал.
3482.62 3494.42 "Анатолий Кулаков" Также позаботьтесь о том, чтобы как только кастомер каким-то образом с вами связывается, неважно по какому каналу связи, вы могли определить все метрики, которые связаны с этим кастомером.
3494.42 3505.26 "Анатолий Кулаков" Например, чтобы вы могли найти логи того процесса, который он вам описывает, чтобы вы могли найти там какой-то correlation ID, чтобы если он вам прислал какой-то тикет, то эти тикеты тоже бы с ним каким-то образом связались.
3505.26 3518.98 "Анатолий Кулаков" Это тоже интересная богатая тема, каким образом провязать все взаимодействие с кастомером в зависимости от того, как он увидел проблему, нашел ее в логах, завел вам тикет, позвонил по телефону, написал в форме обратной связи.
3518.98 3522.74 "Анатолий Кулаков" Все это нужно сделать, связать и создать единый кастомер экспириенс.
3522.74 3525.90 "Анатолий Кулаков" Шестой пункт.
3525.90 3527.14 "Анатолий Кулаков" Используйте канареечные релизы.
3527.14 3549.66 "Анатолий Кулаков" Когда ваше приложение растет и становится большим-большим-большим, например, Enterprise-Enterprise, и даже не важно, насколько вы хорошо его тестировали, даже не важно, как у вас там покрыто качество тестами, сколько вы используете анализаторов, сколько времени вы над ним попотели, если у вас много-много кастомеров, то возможность ошибки растет очень-очень сильно.
3549.66 3563.70 "Анатолий Кулаков" Ну, соответственно, много кастомеров, большое приложение, много нового кода, и даже если вы прекрасно протестировали, все равно ошибки там быть могут, и довольно-таки рискованно выкатывать это все абсолютно на всех ваших потребителей.
3563.70 3567.58 "Анатолий Кулаков" Лучше минимизировать риски и использовать так называемые канареечные релизы.
3567.58 3574.54 "Анатолий Кулаков" То есть, когда вы выкатываете новый релиз не на всех потребителей, а на какой-то там процент, на какую-то часть.
3574.54 3576.98 "Анатолий Кулаков" Обычно первая часть – это самые лояльные какие-то потребители.
3576.98 3582.06 "Анатолий Кулаков" И обязательно смотрите за монитором.
3582.06 3584.22 "Анатолий Кулаков" То есть, обязательно мониторите приложение.
3584.22 3592.78 "Анатолий Кулаков" Смотрите, все ли нормально, не увеличилось ли количество ошибок, не внесли ли вы какие-то breaking changes, не разрывается ли у вас телефон.
3592.78 3599.74 "Анатолий Кулаков" Если все хорошо, добавляете немножко кастомеров, которые сидят на новой версии, а кастомеров со старой версии уводите.
3599.74 3608.54 "Анатолий Кулаков" И таким образом, по чуть-чуть, по чуть-чуть добавляя, обязательно смотря за метриками, вы постепенно накатываете полностью новый релиз на всех кастомеров, которые у вас есть.
3608.54 3612.46 "Анатолий Кулаков" Это отличная практика, используется абсолютно всеми большими компаниями.
3612.46 3622.38 "Анатолий Кулаков" Может, вы даже встречали такое, что когда-нибудь вам там ВКонтакте показывают какую-то красивую кнопочку, а вашего коллеги рядышком еще даже не появилась, а потом через пару дней появляется у него.
3622.38 3626.66 "Анатолий Кулаков" Это вот и есть такие постепенные релизы.
3626.66 3627.66 "Анатолий Кулаков" Седьмой пункт.
3627.66 3631.14 "Анатолий Кулаков" Используйте эксперименты с помощью А/Б тестирования.
3631.14 3636.02 "Анатолий Кулаков" А/Б тестирование делается, когда ваши кастомеры точно так же делятся на несколько групп.
3636.02 3638.82 "Анатолий Кулаков" Ну, обычно на одну-две группы.
3638.82 3642.98 "Анатолий Кулаков" На одну группу делить, наверное, несерьезно, на две-три группы и так далее.
3642.98 3648.46 "Анатолий Кулаков" И вы одной группе даете какую-то инфункциональность, которую вы хотите проверить, а другой группе другую функциональность.
3648.46 3649.46 "Анатолий Кулаков" Это будет контрольная группа.
3649.46 3651.54 "Анатолий Кулаков" Может, даже оставляете ее на старой функциональности.
3651.54 3657.54 "Анатолий Кулаков" И в зависимости от того, какая задача перед вами стоит, ну, например, попробовать новый UI.
3657.54 3659.74 "Анатолий Кулаков" Будет он удобнее или неудобнее?
3659.74 3662.82 "Анатолий Кулаков" Будут выполняться там действия те же самые быстрее?
3662.82 3664.58 "Анатолий Кулаков" Будет пользователь там делать меньше ошибок?
3664.58 3667.38 "Анатолий Кулаков" Будет чаще ли он к ней кликать на кнопочки "задонати нам"?
3667.38 3671.50 "Анатолий Кулаков" В общем, все вот эти метрики вы выставляете и смотрите на А/Б тестирование.
3671.50 3681.22 "Анатолий Кулаков" То есть, код один, но в зависимости от определенных обстоятельств, например, от фичи флага или от фамилии клиента или от уровня его подписки, выдается разная функциональность.
3681.22 3686.66 "Анатолий Кулаков" И наблюдается, какие метрики в результате этого изменятся.
3686.66 3691.14 "Анатолий Кулаков" Следующее, восьмое.
3691.14 3693.14 "Анатолий Кулаков" Делайте пассивные тесты.
3693.14 3695.50 "Анатолий Кулаков" Пассивные тесты – интересная идея.
3695.50 3700.94 "Анатолий Кулаков" Мне на практике никогда не приходилось их делать, но мне кажется, когда-нибудь попробовать стоит.
3700.94 3703.02 "Анатолий Кулаков" Что ж такое пассивные тесты?
3703.02 3714.02 "Анатолий Кулаков" Дело в том, что когда у вас есть какой-то кусок кода, обычно это какой-нибудь большой кусок, легоси кусок, которому уже много-много никто не притрагивался, а автор давно уволился и забрал с собой всю документацию.
3714.02 3717.30 "Анатолий Кулаков" То есть, разбираться в нем практически нереально.
3717.30 3720.74 "Анатолий Кулаков" То есть, там что-то непонятное происходит, там что-то очень сложное происходит.
3720.74 3725.74 "Анатолий Кулаков" Я думаю, вот такие куски каждый из вас должен, наверное, был видеть.
3725.74 3727.74 "Анатолий Кулаков" Я, по крайней мере, очень часто такие штуки встречаю.
3727.74 3738.10 "Анатолий Кулаков" И любое изменение, любое привнесение в них чего-то нового – это большая-большая боль, которая сопровождается кучей разных приседаний для того, чтобы как-то ее минимизировать.
3738.10 3743.26 "Анатолий Кулаков" И есть способ, как минимизировать эту боль с помощью пассивных тестов.
3743.26 3746.46 "Анатолий Кулаков" Прежде всего, что вам нужно сделать?
3746.46 3755.14 "Анатолий Кулаков" Обычно самый адекватный способ – это переписать эту функциональность к чертовой матери, и задокументировать ее правильно, и правильные тесты настроить и так далее.
3755.14 3757.78 "Анатолий Кулаков" Но здесь кроется маленький момент.
3757.78 3769.06 "Анатолий Кулаков" Если мы будем это переписывать, не зная изначальной спецификации, мы можем повредить функциональность, потому что мы не знаем, как оно делается, с какими примочками, с какими трудностями, с какими костылями.
3769.06 3778.62 "Анатолий Кулаков" Поэтому обычно пишут новую версию этой функциональности и включают ее параллельно со старой версией.
3778.62 3783.26 "Анатолий Кулаков" То есть у вас параллельно работают две версии – старая активная и новая пассивная.
3783.26 3786.50 "Анатолий Кулаков" И в результате собирают результаты с обоих версий.
3786.50 3793.54 "Анатолий Кулаков" И эти результаты сравнивают между собой, таким образом определяют, что и новая и старая версия работают одинаково.
3793.54 3802.26 "Анатолий Кулаков" Этот период может длиться сколько угодно долго, насколько вы хотите убедиться, что все-таки они работают одинаково на каком-то определенном периоде времени.
3802.26 3815.82 "Анатолий Кулаков" И постепенно, когда вы видите, что новая версия примерно делает то же самое, что и старая версия, никаких расхождения нет, результаты одни и те же, у вас уже больше вероятности, что вы все сделали правильно, что вы предусмотрели все результаты.
3815.82 3823.46 "Анатолий Кулаков" Естественно это нужно проверять не только на тестах, не только на стейджинге, но и обязательно на продакшене, чтобы действительно вы проверили все результаты.
3823.46 3833.02 "Анатолий Кулаков" Ну и после этого уже старую версию выключают, замещают, удаляют и переключают всю новую функциональность на вашу новую написанную, переписанную, красивую, задокументированную версию.
3833.02 3838.14 "Анатолий Кулаков" И последний, девятый пункт – это тесты.
3838.14 3845.66 "Анатолий Кулаков" Как ни странно, да, автор говорит, что это слишком очевидно, чтобы это было делать первым пунктом, но не сказать про это все-таки нельзя.
3845.66 3846.98 "Анатолий Кулаков" Тесты очень важны.
3846.98 3850.54 "Анатолий Кулаков" Обязательно пишите тесты.
3850.54 3858.22 "Анатолий Кулаков" Код без тестов невозможно ни сопровождать, ни безбоязненно рефакторить, ни улучшать, ни добавлять новые фичи.
3858.22 3859.82 "Анатолий Кулаков" В общем, тесты – это наше все.
3859.82 3867.34 "Анатолий Кулаков" И обязательно тесты должны быть подключены к CI, чтобы они автоматически запускались во всех нужных и ненужных ситуациях.
3867.34 3876.94 "Анатолий Кулаков" Кроме юнит тестов учитывайте, что также есть еще и деградационные тесты, и end-to-end тесты, и в зависимости от пирамиды тестирования, все они у вас желательно должны быть.
3876.94 3879.66 "Анатолий Кулаков" Вот такие интересные советы.
3879.66 3890.90 "Анатолий Кулаков" Тут действительно смешано все сильно в кучу, но мне кажется, есть какие-то доли истины и полезные бестпрактисы в этой статейке, поэтому я думаю, что каждый из вас может почерпнуть что-нибудь интересное для своего проекта.
3890.90 3910.30 "Игорь Лабутин" Да, звучит действительно интересно, хотя тут, конечно, все смешано, намешано все прям очень много, но с другой стороны заголовок такой про безопасный деплой и keep application healthy, а раз keep application healthy, то и AB тесты имеют смысл и так далее.
3910.30 3914.30 "Игорь Лабутин" Так что да, пробуйте это все.
3914.30 3940.86 "Игорь Лабутин" Не всегда это может быть применимо, если вы делаете какой-нибудь там коробочный софт, с AB тестами может быть сложнее, но тем не менее, большинство продуктов, мне кажется, сейчас, ладно, не буду говорить большинство, много продуктов сейчас деплоится именно там, где можно использовать и канарейки, и AB тесты, так что изучайте, делитесь, пробуйте, приходите потом рассказывать про то, как у вас все это получилось сделать.
3940.86 3942.34 "Игорь Лабутин" Давай пойдем дальше.
3942.34 3948.38 "Игорь Лабутин" Дальше у нас интересная статейка про ВПФ.
3948.38 3952.74 "Анатолий Кулаков" Ну вот, нежданно-негаданно, ВПФ жив.
3952.74 3973.98 "Игорь Лабутин" Ну, ВПФ не совсем жив, это на самом деле статья не в блоге Microsoft, это статья на Medium от товарища, который довольно много писал на ВПФ, который был там Microsoft MVP во многом благодаря WPF, и вот он решил описать всего текущее понимание того, что вообще происходит с ВПФ, как мы дошли до жизни такой, и что ждать в будущем.
3973.98 3977.26 "Игорь Лабутин" И в целом, надо сказать, статья не то чтобы сильно оптимистическая.
3977.26 3991.18 "Игорь Лабутин" Начинается статья с того, что он приводит такую фразу про то, что ВПФ вообще говоря, когда он такой родился, предполагалось, что он заменит винформы.
3991.18 4001.18 "Игорь Лабутин" А сейчас состояние такое, что было бы, ну скажем так, было бы круто, если бы ВПФ прожил хотя бы столько же, сколько проживут винформы.
4001.18 4003.50 "Игорь Лабутин" Ну в смысле, пока живы винформы.
4003.50 4006.82 "Анатолий Кулаков" Ну судя по анонсам, сейчас винформы заменяют ВПФ.
4006.82 4008.78 "Игорь Лабутин" Да, кажется, что ВПФ умрет раньше.
4008.78 4012.38 "Игорь Лабутин" Значит, что вообще происходило?
4012.38 4013.38 "Игорь Лабутин" Много-много лет.
4013.38 4019.42 "Игорь Лабутин" Майкрософт всегда говорил, WPF, живее всех живых, короче, все нормальная технология, берите, пользуйтесь, пишите.
4019.42 4027.74 "Игорь Лабутин" Но сколько мы уже дотнет-релизов здесь в этом подкасте обозреваем, да и до этого так было, особо никаких новостей и апдейтов про WPF не было.
4027.74 4037.02 "Игорь Лабутин" То есть, с тех пор, как они стали опенсурсами, тоже не так давно, но тем не менее, пул реквесты как-то особо лениво довольно принимаются.
4037.02 4047.94 "Игорь Лабутин" Небольшая надежда была в седьмом релизе, в дотнет-седьмом, когда там тесты выкатили за опенсурс или все вот это все, но что-то как-то оно все тоже не сильно внушало оптимизм.
4047.94 4069.06 "Игорь Лабутин" А тут относительно недавно прошел так называемый комьюнити стендап, как мы уже рассказывали много раз, у Майкрософта есть много разных всяких движух и совещаний, которые на самом деле транслируются, это прям специально называется комьюнити стендап, то есть это специальный стрим, где обсуждают всякие разные вопросы вокруг опенсурса, работы с комьюнити и так далее.
4069.06 4081.78 "Игорь Лабутин" И в частности там прозвучала фраза про то, что WPF, во-первых, переводится в режим, что он комьюнити ран, то есть Майкрософт в него сильно вкладываться не будет, только то, что комьюнити принесет.
4081.78 4091.34 "Игорь Лабутин" А с другой стороны, если Майкрософт не вкладывается, то непонятно, кто будет эти самые пиары, которые принесут из комьюнити, собственно, мержить, ревьюить, мержить.
4091.34 4092.34 "Игорь Лабутин" Ну, наверное, кто-то будет.
4092.34 4104.06 "Игорь Лабутин" А второй момент, который там прозвучал, что WPF, его разработка и поддержка переведены в Developing Center в Индии Майкрософта.
4104.06 4113.10 "Игорь Лабутин" И это, по сути, место, где проекты, так сказать, уходят помирать, потому что там они просто на поддержке какой-то.
4113.10 4136.34 "Игорь Лабутин" И главный менеджер по всему этому делу написал такую фразу про то, что мы считаем, что WPF это вообще очень такой солидный готовый продукт, и именно поэтому нет там какой-то такой инновации, быстрых разработок, и каких-то суперкрутых нововведений, потому что там все готово.
4136.34 4141.74 "Игорь Лабутин" И мы будем поддерживать этот продукт до тех пор, пока у него есть пользователи.
4141.74 4146.86 None То есть он типа не помер, но развивать мы его не будем.
4146.86 4154.26 "Игорь Лабутин" Вот примерно такая ситуация складывается на текущий момент с точки зрения коммуникации Майкрософта вокруг WPF.
4154.26 4159.90 "Игорь Лабутин" И дальше автор задается интересным вопросом, надо ли вообще говоря сейчас WPF использовать?
4159.90 4161.90 "Игорь Лабутин" То есть особенно если вы его не знаете.
4161.90 4169.58 "Игорь Лабутин" Понятно, что если вы его знаете, вы все время на нем писали, вам нужно просто очередное написать WPF-приложение, ну, наверное, берете то, что вы хорошо знаете.
4169.58 4185.70 "Игорь Лабутин" Но если вы только начинаете свой путь в Desktop-разработку, то ответ нет, WPF, скорее всего, брать сегодня уже не стоит, потому что нет никаких шансов, что он как-то будет сильно развиваться дальше.
4185.70 4188.82 "Игорь Лабутин" И это вопрос относительно простой.
4188.82 4191.66 "Игорь Лабутин" Ответ может быть не такой радостный, но этот вопрос был простой.
4191.66 4194.30 "Игорь Лабутин" А вот более сложный вопрос, а что брать?
4194.30 4196.42 "Игорь Лабутин" Потому что есть несколько вариантов.
4196.42 4205.30 "Игорь Лабутин" Вообще под Desktop-разработку у Microsoft всегда было несколько вариантов, даже просто под Windows, когда это все было Windows-only, и это было довольно запутанно.
4205.30 4208.82 "Игорь Лабутин" Когда был один WinForms, там было все понятно.
4208.82 4220.42 "Игорь Лабутин" Не, ну был WinForms, потом появился WPF, потом был WinUI, потом был UVP, причем я говорю "потом", но на самом деле они же как-то там живут плюс-минус параллельно и вместе.
4220.42 4230.30 "Игорь Лабутин" Сейчас, если вы хотите разрабатывать чисто под Windows Desktop, причем под современный Windows, то есть там какие-нибудь ранние десятки уже не подойдут, то можно взять WinUI 3.
4230.30 4235.06 "Игорь Лабутин" А можно взять UVP, наверное, по-моему, он еще жив.
4235.06 4237.38 "Игорь Лабутин" Я уже путаться начинаю.
4237.38 4238.38 "Игорь Лабутин" Есть MAUI.
4238.38 4248.26 "Игорь Лабутин" С MAUI проблема в том, что кажется, что основной фокус MAUI - это все-таки мобилка, и Desktop - это такое типа по статусному принципу.
4248.26 4251.06 "Игорь Лабутин" Получится хорошо, не получится - сильно не вкладываемся.
4251.06 4261.46 "Игорь Лабутин" И в общем-то все от Microsoft такого прямо чисто Desktop-но UI-ного вроде особо больше и нет.
4261.46 4269.06 "Игорь Лабутин" Есть еще Avalon, хороший продукт, классно развивается, все дела, можно пробовать.
4269.06 4281.62 "Игорь Лабутин" Есть Uno Platform, который тоже очень неплохо абстрагируется от всяких разных платформ и использует как раз платформы специфические штуки, то есть например на Desktop они работают через WinUI на Windows Desktop.
4281.62 4294.06 "Игорь Лабутин" Но как ни странно, автор статьи приходит к выводу, что на самом деле кажется, что проще всего сейчас, если вы что-то новое учтите, то смотреть в сторону Blazor, потому что Blazor - это технология, которую Microsoft пушит довольно активно.
4294.06 4302.86 "Игорь Лабутин" Она, конечно, не Desktop-ная разработка, это в первую очередь браузеры, но тем не менее WebView, электрончик и у вас есть Desktop на Blazor.
4302.86 4308.86 "Анатолий Кулаков" Ну и у MoYu я есть, баннинги под Blazor, и WebView 2 там есть.
4308.86 4321.62 "Игорь Лабутин" И в целом по статьям и коммуникации Microsoft, как-то будущее Blazor кажется более радужным что ли по сравнению с будущим MoYu.
4321.62 4335.38 "Игорь Лабутин" Они как-то все время вместе, но вот Blazor как-то более, то ли он более успешен, то ли он кажется более законченным, то ли он действительно чуть более закончен, чем MoYu, который не допеределан Xamarin.Forms, непонятно.
4335.38 4348.82 "Игорь Лабутин" Но в общем рекомендация, что если вам нужен именно прям честный Desktop, то скорее это Avalon или Unuplatform, если вы готовы, что это будет Web, но который можно запустить на Desktop, то это Blazor.
4348.82 4350.58 "Игорь Лабутин" Вот примерно так.
4350.58 4386.30 "Игорь Лабутин" Ну и в конце статьи автор пытается понять, а почему собственно такая фигня случилась с WPF, и его вывод такой, что когда все это рождалось, хотелось, чтобы WPF, ну или по крайней мере его часть стала кроссплатформенным, там даже был Silverlight, который был вокруг этого построен, но Silverlight по понятным причинам браузерных стандартов и всего остального особо не взлетел, WPF в итоге стал Windows-only, а зачем нам еще один Windows-only-фреймворк, и видимо WPF из-за этого и постигла такая судьба.
4386.30 4391.78 "Игорь Лабутин" В конце он сравнивает, собственно, WPF кажется примерно такой же судьбой, как у Visual Basic.
4391.78 4403.18 "Игорь Лабутин" То есть он есть, его как бы вынуждено поддерживать, потому что есть какая-то кодовая база, но никаких улучшений, изменений как в Visual Basic, так и в WPF, видимо, не будет никогда.
4403.18 4406.42 "Игорь Лабутин" Как не в ловимый джо?
4406.42 4409.98 "Игорь Лабутин" Ну типа того, забытый и отправленный на пенсию, я бы сказал.
4409.98 4410.98 "Игорь Лабутин" Скорее.
4410.98 4422.10 "Анатолий Кулаков" Да, грустненько-грустненько, такая прекрасная технология, столько много у нее перспектив было бы, если бы допилили, бы-бы-бы-бы-бы, но к сожалению, что-то они продолбали опять все полимеры.
4422.10 4430.74 "Анатолий Кулаков" С таким отношением, конечно, в мою тоже мало людей будут верить, с таким закапыванием перспективных и расхваленных технологий, что-то я боюсь, что…
4430.74 4457.78 "Игорь Лабутин" Так вот, в том-то и дело, что с WPF-ом, по крайней мере, видно… Ну то есть, я не застал прям самых ранних моментов WPF, то есть мы на нем начинали писать, мы писали, когда он только-только вышел, еще был в превью, но я не настолько активно, во-первых, это делал, во-вторых, я… ну не то чтобы сильно помню риторику Microsoft вокруг этого, но и тогда она была поменьше, понятное дело, то есть что там, релиз выпустили, большой фреймворк выпустили, и все, и все счастливы.
4457.78 4466.50 "Игорь Лабутин" Но кажется, что WPF, он по крайней мере, ну то есть он доразвился до нормального стабильного состояния, вот.
4466.50 4475.10 "Игорь Лабутин" С MAUI кажется, что есть, я не знаю, все шансы, что Microsoft забьет на него до того, как он доберется до нормального развитого состояния, когда им начали пользоваться полноценно.
4475.10 4480.94 "Игорь Лабутин" Ну не знаю пока, что-то долго уже MAUI, так скажем.
4480.94 4488.18 "Игорь Лабутин" Хотя как долго, релиз был не так давно, в общем-то, год же назад, меньше года назад даже, в середине прошлого
4488.18 4497.14 "Анатолий Кулаков" года. Да, про него до этого долго кричали, в общем, он настолько громко про него кричали, настолько как бы пшик вышел, что возникают лишние вопросы.
4497.14 4501.02 "Игорь Лабутин" Ну да, ну в общем посмотрим, что будет, не знаю пока.
4501.02 4509.34 "Игорь Лабутин" Будем следить, посмотрим, что зарелизит нам в восьмерке, которая LTS, так что может там что будет хорошее, глянем.
4509.34 4510.34 "Анатолий Кулаков" Да, good.
4510.34 4522.26 "Анатолий Кулаков" Ну что, пойдем дальше, у меня есть еще одна интересная статейка, в этот раз опять с best practices, и на этот раз автор оттолкнулся от той мысли, что мы же все фиксим баги.
4522.26 4527.18 "Анатолий Кулаков" И если вы пофиксили баги, что вы должны сделать теперь?
4527.18 4566.98 "Анатолий Кулаков" Статейка не то, про что вы должны сделать теперь, а про общий процесс фиксания багов, но она написана настолько прекрасно и настолько много в ней дается полезных вопросов, которые как раз показывают, насколько ваш проект соответствует лучшим best practices, которые есть в этой сфере, то есть насколько он готов к тому, чтобы его удобно использовать для фиксания багов и насколько в него вы еще можете вложиться и улучшить, что я незамедлительно просто добавил ее к нам в эфир, для того чтобы просветить, обсудить и заставить вас задуматься, все ли у вас так же хорошо.
4566.98 4569.46 "Анатолий Кулаков" Давайте поподробнее.
4569.46 4579.38 "Анатолий Кулаков" Итак, я думаю, что никто не будет спорить о том, что чем больше кода мы пишем, тем больше багов мы производим, тем больше багов в нашем приложении, как бы сильно мы не старались.
4579.38 4589.62 "Анатолий Кулаков" Поэтому у нас есть баги, поэтому нам их необходимо фиксить и фикситься они обычно банально.
4589.62 4601.98 "Анатолий Кулаков" Прежде всего вы добываете информацию о том, что же случилось, потом вы обычно вас воспроизводите, фиксите и заливаете в новую версию приложения с уже пофикшенными багами.
4601.98 4616.02 "Анатолий Кулаков" Вот эти простые шаги, они на самом деле внутри себя включают кучу вопросов, на которые вы должны ответить для того, чтобы понять, случатся ли эти шаги легко и непринужденно или же будут долгие и спровоцируют много-много боли.
4616.02 4624.10 "Анатолий Кулаков" Давайте теперь подробнее разберемся, что же за вопросы у нас встают на каждом шаге, когда мы чиним какой-то баг.
4624.10 4630.42 "Анатолий Кулаков" Прежде всего, как легко вы сможете собрать информацию, необходимую для воспроизведения бага.
4630.42 4635.14 "Анатолий Кулаков" Есть ли у вас, допустим, версия вашего приложения в той информации, которая у вас доступна.
4635.14 4650.02 "Анатолий Кулаков" Есть ли у вас информация об окружении вашего приложения, где оно запускается, на какой операционной системе, версия дот нета, используемая культура, разрешение экрана, беспотребляемая память, наличие cpu свободного.
4650.02 4653.58 "Анатолий Кулаков" Какая конфигурация у вашего текущего приложения, с которым случилась проблема.
4653.58 4661.02 "Анатолий Кулаков" Есть ли у вас call stack, с которым случилась ошибка или же сообщение о самой ошибке.
4661.02 4662.70 "Анатолий Кулаков" Есть ли у вас логи вообще.
4662.70 4667.30 "Анатолий Кулаков" Легко ли вы можете получить эти логи и доступиться к ним.
4667.30 4669.34 "Анатолий Кулаков" Легко ли они у вас читаются.
4669.34 4673.54 "Анатолий Кулаков" Насколько у вас хорошо логи организованы, правильный ли у них уровень логирования.
4673.54 4679.98 "Анатолий Кулаков" Легко ли вы можете найти ту необходимую информацию, которая объясняет вам, в чем была проблема.
4679.98 4688.94 "Анатолий Кулаков" Достаточно ли в логах информации, описывающей контекст, которая рассказывает о том, в каком окружении было запущено приложение.
4688.94 4694.42 "Анатолий Кулаков" Достаточно ли той информации, которая опишет вам о том, что же с этим приложением все-таки случилось.
4694.42 4699.42 "Анатолий Кулаков" Есть ли у вас возможность проследить полный флоу вашего запроса.
4699.42 4710.74 "Анатолий Кулаков" Например, есть ли у вас correlation ID, есть ли у вас distributed tracing, который позволит связать этот запрос с другими приложениями или с другими сервисами в вашей системе.
4710.74 4714.14 "Анатолий Кулаков" Есть ли у вас доступ к телеметрии от этого приложения.
4714.14 4722.22 "Анатолий Кулаков" Собиралась ли вообще эта телеметрия и насколько автоматически собрана информация, она для вас полна и доступна.
4722.22 4729.26 "Анатолий Кулаков" Можете ли вы дополнить ваше исследование какими-нибудь пользовательскими данными.
4729.26 4737.34 "Анатолий Кулаков" То есть, мог ли пользователь внести какую-то дополнительную информацию, объясняющую, как случилась проблема или свои какие-то наблюдения.
4737.34 4761.46 "Анатолий Кулаков" И показатель того, что ваше приложение хорошо подготовлено к данному шагу, показатель того, что смотря лишь на эти данные, то есть налоги, телеметрию, форму финбэка, вы уже у себя в голове должны породить какую-то идею, которая отвечает вам на вопрос, а что же собственно с вашим приложением случилось.
4761.46 4778.06 "Анатолий Кулаков" То есть, если вы глядя только на телеметрию, только на отчеты, только на отчеты, смогли понять, что произошло, в чем проблема, то это значит у вас прекрасно поставленные логи, прекрасно поставленные отчеты и прочая телеметрия.
4778.06 4779.94 "Анатолий Кулаков" Переходим к следующему шагу.
4779.94 4785.94 "Анатолий Кулаков" Насколько легко будет воспроизвести эту проблему в вашем окружении разработчика.
4785.94 4804.58 "Анатолий Кулаков" На самом деле это тоже очень важная штука, потому что окружение разработчика очень часто отличается от того, что у вас есть на стейджинге или на продакшене, куча разных мелочей, начиная от операционной системы и заканчивая конечно же настройками.
4804.58 4815.54 "Анатолий Кулаков" И очень хорошо, что после того, как вы узнали, что же собственно случилось с вашим приложением, очень хорошо бы эту ситуацию воспроизвести или может быть даже отдебажить.
4815.54 4824.78 "Анатолий Кулаков" Соответственно, возможно ли отдебажить эту проблему и воспроизвести ее в настройках окружения ваших разработчиков.
4824.78 4826.82 "Анатолий Кулаков" Это тоже очень хороший и важный показатель.
4826.82 4831.26 "Анатолий Кулаков" Как легко вообще можно начать работать с вашим проектом?
4831.26 4838.18 "Анатолий Кулаков" Как легко можно доступиться к коду, открыть этот проект в WDE и вообще начать дебагинг без каких-то дополнительных приготовлений?
4838.18 4843.22 "Анатолий Кулаков" Есть ли корректная документация о том, как начать работать с вашим проектом?
4843.22 4855.34 "Анатолий Кулаков" Нужно ли вручную настраивать какие-то секреты, сертификаты, пароли, API ключи, которые нужны для того, чтобы доступиться к тем данным, которые позволят воспроизвести эту ситуацию?
4855.34 4862.06 "Анатолий Кулаков" Нужно ли дополнительно настраивать какое-то программное обеспечение на машине разработчика?
4862.06 4871.98 "Анатолий Кулаков" Насколько сильно нужно стараться, чтобы привести окружение к тому же самому инвайорменту, который на продакшене, который позволит воспроизвести всю эту ситуацию?
4871.98 4877.94 "Анатолий Кулаков" Сможет ли вы доступиться и как легко будет доступиться к анонимизированным данным из продакшен-системы?
4877.94 4880.02 "Анатолий Кулаков" Естественно, к анонимизированным.
4880.02 4884.22 "Анатолий Кулаков" Никто же вас не разрешит доступаться к настоящим данным, правда же?
4884.22 4887.10 "Анатолий Кулаков" У вас же это все защищено, анонимизировано, афицировано.
4887.10 4889.54 "Анатолий Кулаков" Насколько легко будет вам с этим работать?
4889.54 4896.86 "Анатолий Кулаков" Для того, чтобы воспроизвести именно вот этот специфичный баг, который может как раз таки опираться на данные, и эти данные вам нужны.
4896.86 4915.10 "Анатолий Кулаков" Если же вы не смогли воспроизвести ситуацию у себя на разработческой окружении, насколько легко и будет ли у вас вообще возможность отдебажить стейджинг или продакшен, или снять с него дамп, или получить другую какую-то низкоуровневую телеметрию?
4915.10 4917.38 "Анатолий Кулаков" Насколько ваше окружение к этому готово?
4917.38 4926.34 "Анатолий Кулаков" Вот это все важные вопросы, которые нужно задаться, если вы хотите хорошо воспроизводить и отлаживать ситуацию.
4926.34 4929.78 "Анатолий Кулаков" Следующий вопрос, это устранение бага.
4929.78 4935.94 "Анатолий Кулаков" И здесь возникает первый вопрос, насколько вообще хорошо организована ваша кодовая база?
4935.94 4939.02 "Анатолий Кулаков" Насколько легко читается код?
4939.02 4952.06 "Анатолий Кулаков" Насколько в вашей системе существует один словарь одинаковых терминов, то есть словарь бизнес терминов, из которых будет понятно, как методы в коде, как классы в коде связаны с вашими бизнес процессами?
4952.06 4956.58 "Анатолий Кулаков" Насколько хорошо у вас поставлено соглашение об именовании?
4956.58 4970.70 "Анатолий Кулаков" Насколько хорошо контролируется единый стиль кода во всех проектах вашей компании, для того, чтобы вы могли смотреть на каждый проект и понимать, основываясь на знаниях одного проекта, что происходит в другом проекте?
4970.70 4974.86 "Анатолий Кулаков" Для этого должны быть вот эти все соглашения и именования одинаковые во всех проектах компании.
4974.86 4981.54 "Анатолий Кулаков" Есть ли у вас какие-то скрытые зависимости для того, чтобы собрать, например, и запустить приложение?
4981.54 4993.54 "Анатолий Кулаков" И как быстро вы можете сделать изменения в коде, проверить результат локально и, например, запаблишить это все на какой-нибудь стейджинг на проверку для тестировщиков?
4993.54 5000.22 "Анатолий Кулаков" Насколько много нужно усилий для того, чтобы запустить отладку в вашем приложении, в вашей DE?
5000.22 5013.54 "Анатолий Кулаков" Эти вопросы все отвечают на проблему работы именно с кодовой базой, для того, чтобы устранить проблему и адекватно воспроизвести ее, и адекватно посмотреть, а что же, собственно, случилось?
5013.54 5028.52 "Анатолий Кулаков" Следующий вопрос после того, как вы зафиксили все это дело, у вас должен возникнуть обязательно пункт, почему, собственно, произошла эта бага и может ли она произойти снова, подобная бага в другом месте или может быть похожая.
5028.52 5035.84 "Анатолий Кулаков" То есть, если вы поймете причину, почему разработчик ее допустил, может быть вы сможете устранить потенциально будущие проблемы в вашем приложении.
5035.84 5051.96 "Анатолий Кулаков" То есть, вам необходимо после того, как вы пофиксили багу, взять небольшой перерывчик и подумать, сделать шаг назад и проанализировать вообще, в чем была изначальная причина возникновения бага.
5051.96 5067.72 "Анатолий Кулаков" Может быть, код был слишком сложный, слишком длинные методы, слишком большой код комплексити, может быть, использовалось неправильное место для решения проблемы, может быть, использовались неправильные инструменты для того, чтобы решить поставленную задачу.
5067.72 5072.24 "Анатолий Кулаков" Или, например, насколько код понятен.
5072.24 5081.72 "Анатолий Кулаков" То есть, не существует ли двух одинаковых имен в различных namespaces, правильно ли называются имена, правильно ли называются методы.
5081.72 5086.32 "Анатолий Кулаков" То есть, может быть, разработчик, который реализовал данную функциональность, он просто-напросто запутался.
5086.32 5094.92 "Анатолий Кулаков" Для него код был непонятный и он совершил ошибку по той простой причине, что было вообще не ясно, что делать, куда это вставлять, как это называется и вообще сущность перепуталась.
5094.92 5101.40 "Анатолий Кулаков" Также, насколько хорошо выполняются pre и post кондишены в ваших методах.
5101.40 5116.80 "Анатолий Кулаков" Например, метод ожидает или возвращает нулябельные перемены или насколько он готов к тому, что к нему придут null в аргументах или насколько его потребители готовы к тому, что null вернутся.
5116.80 5123.88 "Анатолий Кулаков" Насколько метод готов работать с локальными датами или он принимает данные только в UTC и готов работать только с ними.
5123.88 5128.20 "Анатолий Кулаков" Не имеет ли он работать с относительными путями или только с абсолютными.
5128.20 5138.92 "Анатолий Кулаков" То есть, все вот эти pre и post кондиции должны каким-то образом обязательно у вас быть зафиксированы, проверены, задокументированы или каким-то другим образом декларированы.
5138.92 5150.32 "Анатолий Кулаков" Потому что это тоже очень часто ситуация бывает, когда ошибка совершается, потому что вызывающий код был не до конца осведомлен с какими данными работает тот метод, куда он послал аргументы.
5150.32 5161.16 "Анатолий Кулаков" А этот метод, который работает, не вовремя может быть эти аргументы проверил или недостаточно хорошо выдал диагностическое сообщение об ошибке.
5161.16 5170.92 "Анатолий Кулаков" Может быть в вашем коде недостаточной документации, которая как раз таки могла бы помочь разработчику, добавляющему новую фичу, сделать это правильно и красиво.
5170.92 5190.60 "Анатолий Кулаков" Еще очень частая проблема бывает сильной связанности, когда вы в одном куске кода делаете какие-то изменения и совершенно не знаете, что эти изменения каким-то образом аффектят совершенно другой кусок кода, на который вы даже не смотрели, тесты на который не писали и может быть даже вообще пропустили из своей области зрения.
5190.60 5194.92 "Анатолий Кулаков" То есть сильная связанность это тоже большая проблема вашего текущего кода, ее нужно устранять.
5194.92 5204.80 "Анатолий Кулаков" Достаточно ли у вас вообще автоматизированных тестов, которые покрывают куски кода таким образом, что эта бага проникла куда-то дальше, проникла куда-то на продакшн.
5204.80 5214.68 "Анатолий Кулаков" Достаточно ли эти тесты читабельны, достаточно ли эти тесты поддерживаемы, не хрупкие ли они, то есть не в правильном ли вы месте расположили тестирование.
5214.68 5220.20 "Анатолий Кулаков" Очень часто бывает такая проблема, что люди надеются на интеграционные тесты, пренебрегая юнит тестами или наоборот.
5220.20 5226.58 "Анатолий Кулаков" Этого тоже нельзя делать, нужно тесты четко делить и четко понимать, где какую функциональность необходимо тестировать.
5226.58 5240.08 "Анатолий Кулаков" И вот последний интересный пункт, достаточно ли у разработчиков было много курсов, много уроков, много тренингов, достаточно ли посещали конференции и достаточно ли образовывались.
5240.08 5242.08 "Анатолий Кулаков" Это тоже задайте своим вопросом.
5242.08 5250.60 "Анатолий Кулаков" Достаточно ли вы посылаете разработчиков на тренинги, на какие-нибудь курсы, на повышение квалификации или только заставляете их все время работать, работать, работать.
5250.60 5257.40 "Анатолий Кулаков" При этом они могут вполне пропускать новые технологии, новые тактики, новые инструменты и из этого тоже могут получаться баги.
5257.40 5264.60 "Анатолий Кулаков" Итак, как же предотвратить баги в вашей кодовой базе?
5264.60 5265.88 "Анатолий Кулаков" Какие инструменты для этого есть?
5265.88 5277.36 "Анатолий Кулаков" Я думаю, автор, конечно, перечислил не все, но основные инструменты, на которые он хочет сконцентрировать наше внимание, это статический анализ, код-ревью, парное программирование и документация.
5277.36 5279.24 "Анатолий Кулаков" Пробежимся по нескольким примерам.
5279.24 5280.24 "Анатолий Кулаков" Код-ревью.
5280.24 5287.28 "Анатолий Кулаков" Код-ревью часто хорошая штука, оно может немножко заменяться парным программированием.
5287.28 5297.08 "Анатолий Кулаков" Это момент, когда вы можете обнаружить проблему еще до того, как она попала в продакшн, даже до того, как вы ее залили в репозиторий.
5297.08 5304.72 "Анатолий Кулаков" То есть это довольно ранняя стадия обнаружения проблемы и вот почему этот метод достаточно хороший, достаточно эффективен во многих ситуациях.
5304.72 5323.04 "Анатолий Кулаков" Также он помогает вам, помогает взглянуть другому человеку на ваш код, а это значит, что у него уже будет незабыленный глаз и он сможет свежим взглядом посмотреть, все ли вы правильно сделали, все ли вы учли и просто составить второе мнение.
5323.04 5324.12 "Анатолий Кулаков" Это тоже очень часто важно.
5324.12 5335.40 "Анатолий Кулаков" Также он может являться, то есть тот человек, который ревьюит ваш код, может являться большим экспертом в данной области, чем вы.
5335.40 5338.88 "Анатолий Кулаков" И поэтому он может учесть те ситуации, на которые вы вообще не рассчитывали.
5338.88 5345.52 "Анатолий Кулаков" И прежде всего, мне кажется, главная фишка код-ревью это прекрасная тема для обучения.
5345.52 5357.00 "Анатолий Кулаков" Если, допустим, у вас есть человек, который прекрасно разбирается в данной области и есть какой-то джун, которого надо научить разбираться в этой области, очень полезно дать все-таки задачу исправить джуну.
5357.00 5365.92 "Анатолий Кулаков" Он будет ее делать дольше, у него будет возникнуть больше проблем, но в результате этого вы получите уже двух экспертов, которые разбираются в данной области.
5365.92 5371.92 "Анатолий Кулаков" И вот как раз того ментора, который наблюдает за джуном, его полезно назначить код-ревьюером.
5371.92 5382.80 "Анатолий Кулаков" И в результате этого код-ревью, на конкретных примерах, уже будет происходить обучение и повышение квалификации первого.
5382.80 5393.92 "Анатолий Кулаков" На код-ревью не нужно проверять стили кодирования, не нужно придираться к скобочкам, к пробельчикам, еще к какой-то вот этой чуши, которую может сделать автоматизация.
5393.92 5396.68 "Анатолий Кулаков" Обязательно используйте инструменты для автоматизации.
5396.68 5404.64 "Анатолий Кулаков" У Дотнета есть стандартное форматирование, он поддерживает эдитер конфиги, который умеет переносить скобочки, убирать ненужные пробельчики и все это.
5404.64 5415.44 "Анатолий Кулаков" В общем, пользуйтесь, на здоровье и не отвлекайте людей настоящих, живых, для того чтобы спорить о табах или о пробелах уже непосредственно в код-ревью.
5415.44 5417.12 "Анатолий Кулаков" Это уже поздно.
5417.12 5421.36 "Анатолий Кулаков" Следующий пример, который автор приводит, это использование компилятора.
5421.36 5426.72 "Анатолий Кулаков" Он утверждает, и я тут не могу с ним согласиться, что компилятор - это лучший ваш друг.
5426.72 5435.88 "Анатолий Кулаков" Потому что компилятор - это один из первых защитников, которые встают на защиту вашего кода на пути багов.
5435.88 5447.56 "Анатолий Кулаков" То есть, чем больше компилятор умеет, чем лучше он знает ваш код, чем лучше он использует статические анализы и различные синтаксические реви, различные компиляции, тем лучше для вас.
5447.56 5451.44 "Анатолий Кулаков" Значит, тем ваш код будет строже, значит у него будет меньше ошибок.
5451.44 5453.92 "Анатолий Кулаков" Поэтому строгая типизация - это хорошо.
5453.92 5460.44 "Анатолий Кулаков" Выкручивайте все возможные опции компилятора на полную катушку, чтобы он проверял максимально все, что только может.
5460.44 5463.32 "Анатолий Кулаков" И обязательно ставьте "Treadwarning as Errors".
5463.32 5466.32 "Анатолий Кулаков" Мы много лет уже это повторяем и не устанем повторять.
5466.32 5470.52 "Анатолий Кулаков" Это первый флажок, который вы обязательно должны проставлять во всех ваших новых проектах.
5470.52 5471.52 "Анатолий Кулаков" Ворнингом нет.
5471.52 5475.76 "Анатолий Кулаков" Следующий пример - это Nullable Reference Types.
5475.76 5482.36 "Анатолий Кулаков" Тоже был не один выпуск подкаста, посвящен Nullable Reference Types и нашим дифференам к ним.
5482.36 5484.48 "Анатолий Кулаков" В общем, просто делайте это.
5484.48 5491.00 "Анатолий Кулаков" Просто делайте Nullable Reference Types и они защитят вас просто от огромной кучи проблем, которые встречаются в обычном коде.
5491.00 5496.80 "Анатолий Кулаков" Сейчас эта технология отлично допилена, все фреймворки уже практически размечены.
5496.80 5498.40 "Анатолий Кулаков" Никаких проблем с этим нет.
5498.40 5504.40 "Анатолий Кулаков" Если вы правильно умеете их использовать, то они сильно будут вас выручать в вашем коде.
5504.40 5507.12 "Анатолий Кулаков" Далее используйте статические анализаторы и линтеры.
5507.12 5516.48 "Анатолий Кулаков" Ну, я немножко упомянул, что есть определенные статические шаблоны, которые грамотные анализаторы умеют распаршивать, умеют осознавать, умеют понимать.
5516.48 5523.48 "Анатолий Кулаков" И какими бы мы уникальными себя не считали, в принципе, большинство ошибок, которые совершают разработчики, они типичные.
5523.48 5537.04 "Анатолий Кулаков" Благо, у Roslin анализаторов у нас есть огромная база всяческих уже готовых шаблонов, которые смогут детектировать обычные ошибки разработчиков и сообщать вам об этом на раннем этапе.
5537.04 5539.00 "Анатолий Кулаков" Еще даже, грубо говоря, до компиляции.
5539.00 5542.88 "Анатолий Кулаков" Потому что они это могут делать в результате непосредственно написания кода.
5542.88 5547.16 "Анатолий Кулаков" Это вообще самый ранний этап, о котором только можно желать и самая прекрасная стадия.
5547.16 5549.80 "Анатолий Кулаков" Безусловно, товарищ ReSharper не отстает.
5549.80 5552.84 "Анатолий Кулаков" У него, скорее всего, анализаторов даже больше, чем у Roslin.
5552.84 5554.12 "Анатолий Кулаков" Я давно что-то их не сравнивал.
5554.12 5556.36 "Анатолий Кулаков" В общем, тоже прекрасный инструмент.
5556.36 5558.72 "Анатолий Кулаков" Также вы можете писать свои собственные анализаторы.
5558.72 5561.44 "Анатолий Кулаков" Вы можете искать анализаторы различных авторов.
5561.44 5569.12 "Анатолий Кулаков" Очень много блогеров, которые пишут про дотанет много, часто имеют свой собственный набор анализаторов, которые нужны только им.
5569.12 5572.76 "Анатолий Кулаков" И у них там тоже находятся замечательные прямо самородки.
5572.76 5576.48 "Анатолий Кулаков" Поэтому смотрите вокруг, ищите много анализаторов.
5576.48 5582.24 "Анатолий Кулаков" Четвертый пример, который автор нам рекомендует использовать, это по максимуму используйте систему типов.
5582.24 5586.28 "Анатолий Кулаков" Опять же, много мы говорили в наших подкастах про primitive obsessions.
5586.28 5589.00 "Анатолий Кулаков" Ищите, смотрите, прекрасная тема.
5589.00 5596.12 "Анатолий Кулаков" Вкратце это то, что не нужно смешивать под int, string и guid вашей бизнес-сущности.
5596.12 5602.60 "Анатолий Кулаков" Потому что это приводит к тому, что их легко поменять порядок, перекинуть одну сущность вместо другой и так далее.
5602.60 5606.96 "Анатолий Кулаков" Типичный пример это user_id перепутать с order_id.
5606.96 5614.40 "Анатолий Кулаков" Элементарно сделать, если они int, и невозможно сделать, если вы под них заведете различные типы.
5614.40 5617.12 "Анатолий Кулаков" Стандартным примером являются email, телефон, адрес.
5617.12 5623.48 "Анатолий Кулаков" Вот все это должно быть не примитивными типами сделаны, а нормальными бизнес-типами.
5623.48 5628.12 "Анатолий Кулаков" Подробнее смотрите в наших предыдущих подкастах.
5628.12 5631.32 "Анатолий Кулаков" Постарайтесь поменьше делать ломающих изменений.
5631.32 5633.32 "Анатолий Кулаков" Они же breaking changes.
5633.32 5640.48 "Анатолий Кулаков" Казалось бы, такое элементарное добавление параметра с дефолтным выражением – это уже breaking changes.
5640.48 5646.20 "Анатолий Кулаков" Я думаю о breaking changes мы поговорим в наших будущих выпусках, у меня там есть интересные статички про это.
5646.20 5649.80 "Анатолий Кулаков" Но вкратце пробежимся, что breaking changes – это плохо.
5649.80 5651.32 "Анатолий Кулаков" Старайтесь их не делать.
5651.32 5658.12 "Анатолий Кулаков" Если вы разрабатываете плагины, то breaking changes для вас вообще ни в коем случае на пушечный выстрел недопустимы.
5658.12 5664.04 "Анатолий Кулаков" Вот это, кстати, упрек решаперу, который даже с минорной версией умудряется ломать все его плагины.
5664.04 5669.80 "Анатолий Кулаков" Таким образом, что авторы большинства крутейших плагинов просто отказались их поддерживать и они умерли.
5669.80 5672.44 "Анатолий Кулаков" Как можно было до этого додуматься, вообще непонятно.
5672.44 5673.76 "Анатолий Кулаков" Но не будем о плохом.
5673.76 5676.80 "Анатолий Кулаков" Автор вводит нам интересный инструмент, который называется BreakCop.
5676.80 5687.40 "Анатолий Кулаков" Это тулза, которая позволяет вам сравнить две сборки и рассказать о том, какие публичные API в этих двух сборках изменились на уровне breaking changes.
5687.40 5693.04 "Анатолий Кулаков" Ну, то есть, изменились – это фиг с ним, а вот что привело к breaking changes – вот это уже важная информация.
5693.04 5704.16 "Анатолий Кулаков" Ее можно встроить в CI/CD и автоматически проверять, что ваше приложение не допустило breaking changes, ну или если допустило, то в строго задекларированных областях, которые вы осознали.
5704.16 5709.64 "Анатолий Кулаков" Также у Microsoft есть хороший анализатор, который называется Code Analysis – Public API Analyzers.
5709.64 5715.96 "Анатолий Кулаков" Он создает специальный файлик, который называется Public API Shipped.txt.
5715.96 5720.32 "Анатолий Кулаков" В этом файлике находится список всех публичных API.
5720.32 5725.96 "Анатолий Кулаков" И в результате работы этого анализатора этот файлик обновляется.
5725.96 5737.12 "Анатолий Кулаков" И на код ревью вы сразу глазками видите, что публичный API поменялся, смотрите на API, анализируете, допустимо ли такое изменение с вашей точки зрения или нет.
5737.12 5740.32 "Анатолий Кулаков" То есть, в одном месте весь публичный API у вас задекларирован.
5740.32 5744.76 "Анатолий Кулаков" И благодаря системе контроля версии, благодаря pull-request вы видите все breaking changes.
5744.76 5753.20 "Анатолий Кулаков" Тоже безумно удобная штука, если вы понимаете, что от вас зависит очень много клиентов, которые следят за совместимостью, которыми важен ваш API.
5753.20 5758.92 "Анатолий Кулаков" В общем-то, подобный инструмент или какой-то на уровне его обязательно должен быть в вашей системе.
5758.92 5764.04 "Анатолий Кулаков" И еще один интересный пример – это фазе тестинг.
5764.04 5771.68 "Анатолий Кулаков" Это немножко не фазе тестинг, который обычно имеется в виду на уровне QA-инженеров и тестирования.
5771.68 5776.28 "Анатолий Кулаков" Автор здесь все-таки говорит больше про обобщенное тестирование.
5776.28 5778.20 "Анатолий Кулаков" Давайте на конкретном примере разберемся.
5778.20 5782.60 "Анатолий Кулаков" Допустим, у вас есть iMessageParser, который умеет парсить, не поверите, message.
5782.60 5786.48 "Анатолий Кулаков" Он принимает какую-то строчку и возвращает строкотипизированный класс.
5786.48 5792.48 "Анатолий Кулаков" И вот автор в своем коде нашел одну из имплементаций, таких имплементаций очень много.
5792.48 5809.88 "Анатолий Кулаков" В одной из имплементаций он нашел такую багу, что когда туда попадает неожиданное значение, то есть не просто строчка, а там какая-то кавычка или нечитабельный символ или какой-то конец строки или табуляция, короче, что-то такое неожиданное, у него этот парсер падал.
5809.88 5812.88 "Анатолий Кулаков" Естественно, он эту багу починил, но задался вопросом.
5812.88 5823.44 "Анатолий Кулаков" У меня же очень много наследников и несмотря на то, что такую ошибку я словил только в одном message.parser, скорее всего она же может быть во всех наследниках iMessageParser.
5823.44 5833.60 "Анатолий Кулаков" Поэтому хорошим правильным тестом здесь является не протестировать только ту имплементацию, в которой была найдена бага, но и протестировать все имплементации.
5833.60 5843.36 "Анатолий Кулаков" То есть вы легко можете в своих тестах собрать все классы, которые имплементирует iMessageParser и прогнать через них всех непредсказуемое вот это значение.
5843.36 5847.80 "Анатолий Кулаков" Конечно, вы не знаете, что вернет вам message.parser, но он 100% не должен падать.
5847.80 5852.04 "Анатолий Кулаков" Вот это точно, что вы знаете и должны гарантировать.
5852.04 5855.12 "Анатолий Кулаков" И вот этот тест является как раз-таки правильным.
5855.12 5860.88 "Анатолий Кулаков" Он немножко похож на контрактное программирование, но его ценность это не уменьшает.
5860.88 5863.40 "Анатолий Кулаков" Ну что ж, вот такая вот большая интересная статья.
5863.40 5878.24 "Анатолий Кулаков" Я надеюсь, что вы нашли для себя какие-то пункты, которые вы захотите улучшить в ваших приложениях, в ваших проектах для того, чтобы вам было легче отлаживать ваше приложение, было легче искать ошибки, исправлять ошибки и вообще, чтобы вы меньше делали ошибок.
5878.24 5879.68 "Игорь Лабутин" Да, хорошая подборка.
5879.68 5891.84 "Игорь Лабутин" Надо сказать, что много из этого, наверное, хорошие разработчики прям прогоняют в уме автоматически на тему того, что было ли мне достаточно логов, а вот заодно добавлю логи, там еще что-нибудь, трейсинг и так далее.
5891.84 5897.40 "Игорь Лабутин" Но некоторые моменты требуют некоторых, ну прям, отдельных усилий, типа такого тестирования.
5897.40 5900.24 "Игорь Лабутин" Но вероятно, оно тоже будет окупаться.
5900.24 5909.84 "Анатолий Кулаков" Ну тем более, если вы только становитесь хорошим разработчиком, то вы должны по идее знать все вот эти пункты и учитывать его действительно при написании, при отлаживании каждого проекта, каждой баги.
5909.84 5916.20 "Игорь Лабутин" Да, это окупится потом, когда вы будете разгребать что-нибудь упавшее на проде.
5916.20 5926.00 "Игорь Лабутин" Ну что, давай потихонечку завершаться, у нас остался последний момент, который мы хотели бы обсудить, это наша иногда появляющаяся рубрика «Кратко о разном».
5926.00 5930.92 "Игорь Лабутин" Здесь у нас есть статейка в блоге Microsoft про то, как правильно писать readme.
5930.92 5941.40 "Игорь Лабутин" Ну, get, сайт nuget.org какое-то время назад начал для, собственно, nuget пакетов показывать readme-шку на страничке самого пакета.
5941.40 5950.60 "Игорь Лабутин" И это очень важно, потому что вы не просто находите какой-то пакет и смотрите на количество, сколько раз его скачали, а можете сразу посмотреть вообще, что в этом пакете есть, как им пользоваться и так далее.
5950.60 5954.00 "Игорь Лабутин" И поэтому писать хорошие readme для nuget пакетов это очень важно.
5954.00 5985.92 "Игорь Лабутин" И как раз в этой статейке есть прям ряд рекомендаций, прям шаблончик в Markdown, как же писать хорошее readme, что в нем должно быть, что там должно быть нормальное хорошее описание, и не очень длинное при этом, что же пакет делает, объяснения, как им пользоваться, примеры, как им пользоваться, линки на какие-то дополнительные документации, может быть даже какие-то скриншотики или визуальные, значит, какими-то средствами обозначенные, показано как пользоваться, не знаю, какие преимущества и так далее.
5985.92 5992.20 "Игорь Лабутин" Важно указать какие-то, может быть, недостатки, ограничения, то есть в каких случаях он может быть неприменим.
5992.20 6002.88 "Игорь Лабутин" В общем, если вы создаете nuget пакетики или пишете readme, например, для вашей библиотеки на GitHub, загляните в статью, может быть вы там найдете что-нибудь полезное.
6002.88 6008.88 "Анатолий Кулаков" Я нашел два интересных source-генератора, о которых вам тоже очень хочу рассказать.
6008.88 6019.00 "Анатолий Кулаков" Первый называется медиатор, несмотря на то, что он звучит как медиатор, по правде он пишется немножко не так, он пишется с буквой "о", то есть медиатор.
6019.00 6035.64 "Анатолий Кулаков" И они не зря так называются, то есть я думаю, что многие из вас знают стандартный медиатор Джимми Богорда, это очень популярная система, используется во множестве проектах, и вот этот товарищ, он полностью по API-ю совместим с медиатором Богорда, именно поэтому он так и называется, очень близко к нему.
6035.64 6040.72 "Анатолий Кулаков" Но он совместим по API-ю, но отличается прекрасной реализацией.
6040.72 6046.72 "Анатолий Кулаков" Реализация полностью сделана на генерации исходников, на source-генераторах.
6046.72 6056.48 "Анатолий Кулаков" То есть он не с помощью reflection регистрирует все ваши там хендлеры, реквесты, респонсы, а с помощью source-генераторов.
6056.48 6069.24 "Анатолий Кулаков" В момент компиляции он проходится по всем вашим файликам, по всем вашим классикам и генерирует вот эту связочку, которую сможет потом вызывать фронтами, когда вы попросите выполнить какую-то команду или query.
6069.24 6083.48 "Анатолий Кулаков" Благодаря применению source-генераторов он дает вам производительность шикарную, где-то примерно в два раза быстрее медиатора, и где-то в шесть раз меньше жрет памяти, allocated памяти.
6083.48 6095.12 "Анатолий Кулаков" Также преимуществом source-генераторов является то, что он теперь out-friendly, а хейт-танк компиляция у него намного лучше на нем работает, потому что рефлекции там почти нет.
6095.12 6114.08 "Анатолий Кулаков" И еще одна прекрасная тема про source-генераторы, как только мы начинаем их использовать, то что все ошибки рантайма, которые раньше у вас случилось бы, если бы пришел какое-нибудь сообщение с неизвестным типом или провалилось бы какой-нибудь неизвестный хендлер, теперь все эти ошибки происходят в билд-тайме.
6114.08 6119.40 "Анатолий Кулаков" У вас просто-напросто не скомпилится код, если для определенного типа не будет найден определенный хендлер.
6119.40 6120.84 "Анатолий Кулаков" И это вообще прекрасно.
6120.84 6127.20 "Анатолий Кулаков" Чем раньше ошибки мы переносим, то есть чем ближе мы их переносим к моменту разработки, к моменту написания, тем прекраснее.
6127.20 6130.16 "Анатолий Кулаков" Желательно, чтобы оно вообще не ушло в репозитории или не ушло в продакшн.
6130.16 6135.36 "Анатолий Кулаков" И source-генераторы позволяют нам как раз этому добиться, и данный медиатор это отличный пример.
6135.36 6144.80 "Анатолий Кулаков" Если вы используете медиатор Bogorda в своих приложениях, посмотрите, судя по редмишке, он продерживает абсолютно все фичи.
6144.80 6149.64 "Анатолий Кулаков" Там пайплайны, интерсепторы, еще там какие-то страшные регистрации.
6149.64 6153.92 "Анатолий Кулаков" В общем, поддерживает практически все новейшие фишки, которые там вышли у Bogorda.
6153.92 6156.80 "Анатолий Кулаков" И полностью совместим по API.
6156.80 6162.96 "Анатолий Кулаков" То есть замена происходит просто переключением namespaces и практически все.
6162.96 6169.08 "Анатолий Кулаков" И вторая библиотечка, которую хочется вам рассказать, это контейнеры.
6169.08 6178.84 "Анатолий Кулаков" Dependency Injection контейнеры, я думаю, многие, наверное, абсолютно все знают, что такое Dependency Injection контейнеры, которые позволяют нам регистрировать типы, резолвить типы.
6178.84 6183.88 "Анатолий Кулаков" Это есть в нашем стандартном фреймворке, в ASP фреймворке уже давно.
6183.88 6186.64 "Анатолий Кулаков" Для этого есть много различных сторонних библиотек.
6186.64 6197.52 "Анатолий Кулаков" И естественно, обязан был появиться source-генератор, который просто-напросто вам генерирует вот эту связку, связку ваших типов.
6197.52 6205.28 "Анатолий Кулаков" То есть вам не нужен настоящий dependency контейнер, который там ходит рефлекшеном и их регистрирует, потом по рефлекшенам как-то каким-то создает.
6205.28 6206.88 "Анатолий Кулаков" Нет, это все глупости.
6206.88 6212.04 "Анатолий Кулаков" Все типы у вас известны в момент компиляции, никакого смысла лазить туда в них рефлекшеном, нет.
6212.04 6221.88 "Анатолий Кулаков" Вы их можете создать, сгенерировать какой-то файлик, где все типы будут поражаться просто с помощью new и будут пробрасываться их зависимости, которые мы тоже знаем в моменте компиляции.
6221.88 6227.80 "Анатолий Кулаков" И поэтому был обязан появиться di-контейнер, который по сути не является di-контейнером.
6227.80 6230.12 "Анатолий Кулаков" Это pure di.
6230.12 6241.44 "Анатолий Кулаков" То есть di, который на самом деле не библиотека, не фреймворк, он просто-напросто генерирует вам отдельный файлик, в котором прописаны все ваши зависимости и там вы можете точно так же, как вы привыкли уже, их резолвить.
6241.44 6248.08 "Анатолий Кулаков" Весь граф зависимости находится в статических методах, вы можете их напрямую создавать.
6248.08 6261.16 "Анатолий Кулаков" Никакого рефлекшена нет, очень много поддерживает всяких фишек, которые вы ожидаете от di, те же самые там unenumerable, lazy, task, резолвятся из контейнера прозрачно, все вот это.
6261.16 6265.48 "Анатолий Кулаков" Ну и плюс все те же самые плюсы, которые я говорил в предыдущем пункте.
6265.48 6279.20 "Анатолий Кулаков" Это out-friendly, это все ошибки у вас в build-time, это скорость исполнения естественно такая же, как если бы вы написали это руками, потому что по сути source-генерация это то, что вы написали бы руками.
6279.20 6282.16 "Анатолий Кулаков" Меньшая локация памяти и так далее.
6282.16 6287.12 "Анатолий Кулаков" Можно перечислять плюсы source-генераторов, все которые есть у любого source-генератора.
6287.12 6288.64 "Анатолий Кулаков" Вот такие две замечательные глибы.
6288.64 6290.36 "Анатолий Кулаков" Посмотрите, надеюсь вам понравится.
6290.36 6296.88 "Игорь Лабутин" Ну а на этом мы будем завершать наш сегодняшний выпуск.
6296.88 6304.60 "Игорь Лабутин" Мы успели сегодня посмотреть, обсудить dotnet 8 preview 2, который хоть и небольшой, но какие-то важные изменения в нем есть.
6304.60 6315.48 "Игорь Лабутин" Поговорили обстоятельно про то, что такое configure rate, зачем он нужен в async/await, что с ним делать в будущем и проголосуйте за тот вариант, который нравится вам.
6315.48 6320.64 "Игорь Лабутин" Узнали про выход в Visual Studio 17.6 preview 1 и preview 2.
6320.64 6325.72 "Игорь Лабутин" Обсудили что нового в NuGet, ну систематизировали, потому что обсуждали уже много раз.
6325.72 6335.48 "Игорь Лабутин" Узнали как лучше всего деплоить, безопасно деплоить и вообще следить за вашим приложением, когда оно уже работает, что с ним можно делать.
6335.48 6339.88 "Игорь Лабутин" Обсудили судьбу WPF, которая пока видимо не очень завидная.
6339.88 6351.36 "Игорь Лабутин" Ну и выяснили, что же делать, если у вас вдруг появился баг, который вы пофиксили, о чем еще нужно подумать, чтобы возможно поменьше фиксить таких багов в будущем.
6351.36 6354.40 "Игорь Лабутин" Ну и красненько пробежались по каким-то совсем коротким новостям.
6354.40 6357.72 "Игорь Лабутин" На этом видимо на сегодня у нас будет все.
6357.72 6360.60 "Анатолий Кулаков" Да, да, наверное давай заканчивать.
6360.60 6386.24 "Анатолий Кулаков" Я напомню, что мы есть на всех подкаст-площадках, обязательно шарьте нас, лайкайте, репостите, ставьте там звездочки, сердечки, что у вас там есть, давайте 5 баллов, давайте каким-то образом повышать популярность подкаста, пишите нам обязательно комментарии, в основном комментарии мы любим на YouTube, там у нас очень часто разгорятся интересные дискуссии, предлагайте свои статьи, предлагайте свои инструменты, делайте нам замечания, мы все обязательно будем учитывать.
6386.24 6390.32 "Анатолий Кулаков" Заходите на наш сайт на Boosty и посмотрите, что у нас там есть еще.
6390.32 6395.40 "Игорь Лабутин" Это был 68 выпуск радио.net, всем пока.
6395.40 6395.88 "Анатолий Кулаков" Счастливо.
6395.88 6405.88 "Анатолий Кулаков" Пока.
