0.00 14.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет выпуск номер 76 и ее бессмертный ведущий Анатолий Голоков.
14.36 16.84 "Анатолий Кулаков" И Игорь Лабутин, всем привет.
16.84 26.16 "Анатолий Кулаков" Также с нами большая служба поддержки аудитории, все, кто лайкает нас, репостит и всячески продвигает подкасты в массы.
26.16 27.16 "Анатолий Кулаков" Вот вам всем большое спасибо.
27.16 39.88 "Анатолий Кулаков" И в частности, большое спасибо товарищи Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Лазарев, Илья, Гурий, Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Беловский, Евгений.
39.88 44.32 "Анатолий Кулаков" Спасибо огромное всем, кто нас поддерживает.
44.32 47.32 "Анатолий Кулаков" А мы, наверное, перейдем к официальной части.
47.32 62.28 "Анатолий Кулаков" Прежде всего, хотелось бы пригласить всех .NET разработчиков на конференцию .NEXT, которая пройдет уже совсем скоро, в сентябре в Москве, 16 и 15 сентября.
62.28 66.60 "Анатолий Кулаков" У нее будет как офлайн, на который, безусловно, мы вас всех и приглашаем.
66.60 69.72 "Анатолий Кулаков" И также для тех, кто почему-то не сможет приехать, будет онлайн-трансляция.
69.72 88.36 "Анатолий Кулаков" И для тех, кто еще не купил билеты, только думает решиться или нет, у нас для вас есть хорошая скидка на персональный билет, поэтому заходите в наши заметки к выпуску, читайте промокоды, применяйте, приезжайте и встретимся как раз на этой замечательной конференции.
88.36 90.44 "Анатолий Кулаков" Может быть еще что-нибудь вместе там замутим.
90.44 93.44 "Анатолий Кулаков" И давай к темам.
93.44 96.76 "Анатолий Кулаков" Что у нас интересненького сегодня?
96.76 98.68 "Анатолий Кулаков" Микрософт себя как-нибудь проявил?
98.68 104.36 "Игорь Лабутин" Микрософт пока себя не очень хорошо проявляет в том плане, что новых превью почему-то пока не выходит.
104.36 111.08 "Игорь Лабутин" Хотя из вот той статьи, которую мы сейчас будем обсуждать, видно, что еще одно превью, видимо, должно быть.
111.08 125.40 "Игорь Лабутин" Но они выпустили интересный, это же не статья, это ишь ю в репозитории Рослина, в котором, который я заглавлю как список фич, которые команда Рослина ожидает увидеть в C# 12 релизе.
125.40 131.04 "Игорь Лабутин" То есть не то, чтобы ожидает увидеть, в смысле, что они ждут пока кто-то их сделает.
131.04 136.04 "Игорь Лабутин" Да, не то, чтобы ожидает, они должны были, должны бы их и делать.
136.04 146.68 "Игорь Лабутин" Ну вот они как раз оценивая свои там возможности, сроки, не знаю, сложность фич и так далее, написали список того, чего ждать, чего нам ждать, чего нам не ждать.
146.68 150.48 "Игорь Лабутин" И давайте мы по этому списку пробежимся.
150.48 159.08 "Игорь Лабутин" Начнем мы с тех фич, которые в общем-то уже есть, которые мы уже обозревали в превью, которые уже есть в вышедшем .NET 8 превью.
159.08 163.92 "Игорь Лабутин" И в этот список фич входит inline-массив, inline-arrays.
163.92 175.92 "Игорь Лабутин" Напоминаю, что это такая фича, когда вы объявляете класс с единственным полем, на него навешиваете атрибутик с размерностью этого массива, и дальше используете этот класс, как будто это массив с элементами того типа, который внутри объявлено поле.
175.92 180.84 "Игорь Лабутин" Это в превью, это сделано и вроде как это будет жить.
180.84 200.92 "Игорь Лабутин" Дальше, nameof может теперь использоваться для доступа к instance-мемберам, то есть теперь не нужно, например, если вам нужно имя какой-то проперти, писать лямбдочку, как обычно там, знаете, x*x.fill, да, внутри из этой лямбды выцеплять название этого поля.
200.92 204.44 "Игорь Лабутин" Теперь можно просто nameof написать, если хочется.
204.44 222.88 "Игорь Лабутин" Для любых типов можно использовать using-алиасы, то есть если вам теперь хочется задать какой-нибудь огромный дикшенари, дикшенари, дикшенари, можете у себя где-нибудь наверху в классе в файлике написать using что-то там равно, и дальше вот эту волшебную конструкцию, ну почти как typedef в C++ или в C.
222.88 228.20 "Игорь Лабутин" Любой тип можно теперь объявить через using и дальше его использовать.
228.20 238.40 "Игорь Лабутин" Primary конструкторы — это штука, которая позволяет вам не писать обычный конструктор, в котором вы просто берете всю пачку параметров конструктора и присваиваете всем локальным филдам класса.
238.40 253.96 "Игорь Лабутин" Такой конструктор теперь можно не писать, его можно просто как бы объявить, когда вы объявляете класс, то есть если вы объявляете класс, там, public class, my class, и внутри пишете там, дальше в круглых схобочках пишите int a,string b, круглая схобка закрылась, и дальше две фигурных пустых схобочки.
253.96 270.08 "Игорь Лабутин" Если у вас в классе больше нет никаких мемберов, то эта конструкция создаст там класс, где будет два private поля, a и b, соответственно, типов int и string, и будет сразу создан конструктор, который, соответственно, будет принимать a и b, int a и string b, и присваивать их локальной переменной в поля.
270.08 278.80 "Игорь Лабутин" Если вы, конечно, хотите дальше пропертизировать, чтобы доступаться к этим филдам и так далее, то, пожалуйста, дальше просто дописывайте как будто обычный.
278.80 285.16 "Игорь Лабутин" Можно добавлять новые конструкторы, любые другие, единственное требование они должны вызывать тот самый primary конструктор обязательно.
285.16 291.76 "Игорь Лабутин" Вот фича есть, она в превью, соответственно, ждем, оставят не оставят.
291.76 294.52 "Игорь Лабутин" В лямбдах появились дефолтные параметры.
294.52 299.28 "Игорь Лабутин" Я пока с трудом представлю, зачем это может быть нужно, но, наверное, бывает полезно.
299.28 308.96 "Игорь Лабутин" То есть, если у вас есть лямбда, теперь можно часть параметров добавить им дефолтные значения, как будто это обычный вызов функции, ну, в смысле, как функцию, где им дефолтные параметры делали.
308.96 311.88 "Игорь Лабутин" И тогда при вызове лямбда не обязательно передавать значения в эти параметры.
311.88 321.00 "Игорь Лабутин" Это те фичи, которые уже точно есть в превью версиях, и которые, надеюсь, останутся.
321.00 326.32 "Игорь Лабутин" Хотя что-то мне кажется, что, по-моему, я не помню, primary конструкторы, по-моему, мы в превью что-то не обсуждали.
326.32 328.36 "Игорь Лабутин" Может быть, еще это в каком-то превью, который не вышел.
328.36 329.36 "Игорь Лабутин" Не знаю.
329.36 331.96 "Игорь Лабутин" Был, по-моему, в самом начале, где-то в каких-то первых превью.
331.96 332.96 "Игорь Лабутин" А, окей.
332.96 334.52 "Игорь Лабутин" У вас действительно уже давно, поэтому я забыл.
334.52 338.92 "Анатолий Кулаков" Я больше боюсь, что они удалят то, что уже, как бы, заносили.
338.92 341.36 "Анатолий Кулаков" Потому что это похоже, чем что-то новое появится.
341.36 348.04 "Игорь Лабутин" Ну, по-моему, на моей памяти это первый раз, когда они вот так вот пишут список того, чего будет довольно задолго до релиза.
348.04 349.04 "Игорь Лабутин" Поэтому...
349.04 350.04 "Игорь Лабутин" Хотя как задолго?
350.04 351.04 "Игорь Лабутин" Месяца сколько?
351.04 352.04 "Игорь Лабутин" Три осталось.
352.04 353.04 "Игорь Лабутин" Ну, в ноябре у нас релиз ожидается.
353.04 354.72 "Игорь Лабутин" Ну, то есть три месяца, да, осталось.
354.72 359.96 "Игорь Лабутин" Поэтому, в общем-то, не так задолго, но, с другой стороны, надеюсь, что действительно не удалят.
359.96 361.92 "Игорь Лабутин" Но, тем не менее, дальше.
361.92 364.08 "Игорь Лабутин" Была такая фича под названием Collection Literals.
364.08 376.68 "Игорь Лабутин" Это штука, которая позволяет вам объявить коллекцию просто без указания типа вообще, то есть литералы, и пишете квадратные скобочки, и внутри, в квадратных скобочках, через запятую, указываете элементы коллекции.
376.68 378.16 "Игорь Лабутин" И это будет ваша новая коллекция.
378.16 389.36 "Игорь Лабутин" Дальше присваивайте это куда-нибудь в тип, который умеет быть коллекцией, или который соответствует некоторым конвенциям того, как он должен уметь создаваться.
389.36 390.84 "Игорь Лабутин" Там всякие методы и т.д.
390.84 391.84 "Игорь Лабутин" Вот это все.
391.84 394.88 "Игорь Лабутин" И, во-первых, фича теперь переименована.
394.88 397.40 "Игорь Лабутин" Она теперь называется Collection Expressions.
397.40 399.72 "Игорь Лабутин" Во-вторых, ее ожидают в C# 12.
399.72 404.20 "Игорь Лабутин" Ее пока еще нет, но скоро будет, надеемся.
404.20 409.12 "Игорь Лабутин" Там есть две штуки, которые не будут сделаны в C# 12.
409.12 411.84 "Игорь Лабутин" То есть она будет сделана, но не целиком.
411.84 413.80 "Игорь Лабутин" Во-первых, не будет сделана штука...
413.80 416.32 "Игорь Лабутин" Так, ладно, давайте с другой стороны начнем.
416.32 417.32 "Игорь Лабутин" Начнем немножко...
417.32 422.00 "Игорь Лабутин" Мы, конечно, это все еще подробно рассмотрим, когда она выйдет в каком-нибудь превью, но так, если это для краткости.
422.00 424.80 "Игорь Лабутин" Можно использовать просто две пары квадратных скобочек...
424.80 428.36 "Игорь Лабутин" Ой, пару квадратных скобочек, открывающих и закрывающих, для пустой коллекции.
428.36 434.40 "Игорь Лабутин" Единственное ограничение — нельзя написать там var collection, присвоить пустые квадратные скобки, потому что непонятно, какого же типа она должна стать.
434.40 437.80 "Игорь Лабутин" То есть для пустой коллекции нужно все-таки тип явно объявить.
437.80 440.92 "Игорь Лабутин" Во-вторых, можно просто перечислить элементы через запятую.
440.92 448.16 "Игорь Лабутин" В-третьих, можно перечислить элементы через двоеточие, пару элементов через двоеточие, все это разделить запятыми.
448.16 450.00 "Игорь Лабутин" Это будет синтекс инициализации словариков.
450.00 454.52 "Игорь Лабутин" То есть вы можете написать, квадратная скобка открылась, а двоеточие b, запятая c, двоеточие d.
454.52 457.80 "Игорь Лабутин" А и c станут ключами, а b и d — значениями.
457.80 459.88 "Игорь Лабутин" А можно еще сделать такую штуку.
459.88 465.36 "Игорь Лабутин" Можно написать, квадратная скобка открылась, а, запятая, дальше две точечки и b.
465.36 467.24 "Игорь Лабутин" Скобка закрылась, например.
467.24 476.44 "Игорь Лабутин" То есть это тот самый range оператор, он же оператор в collection pattern matching, когда мы хотим замачивать хвост, например, коллекции.
476.44 486.60 "Игорь Лабутин" Так вот здесь это будет означать, что нужно взять коллекцию b, та, которая указана с вот этим двоеточием, и вставить все ее элементы на место того, где они указаны.
486.60 489.48 "Игорь Лабутин" Таким образом замерзнуть пачку коллекций в единую.
489.48 497.84 "Игорь Лабутин" Они называются вложенными коллекциями, но они технически не вложенные, а именно они смерживаются в одну большую коллекцию в том порядке, в котором они встречаются в объявлении.
497.84 503.76 "Анатолий Кулаков" Мне здесь больше всего показался непривычным синтекс для dictionary, для словарей.
503.76 510.84 "Анатолий Кулаков" То есть когда ты рисуешь квадратные скобочки, интуитивно уже понятно, что это должен быть какой-нибудь array, какой-нибудь массив.
510.84 516.32 "Анатолий Кулаков" А здесь они в квадратные скобочки засунули синтексис для словарей и выглядит, конечно, очень непривычно.
516.32 521.40 "Игорь Лабутин" Да, выглядит непривычно, и это было большое обсуждение в начале этой фичи.
521.40 535.76 "Игорь Лабутин" Они очень хотели сделать это с фигурными скобочками, так как это принято в C#, и так по большому счету, как мы везде все это инициализировали, да, через всякие, new, там, массив, да, мы могли же инициализировать массив, но мы должны были написать вот эту волшебную конструкцию new квадратные скобочки в начале.
535.76 545.76 "Анатолий Кулаков" Ну да, то есть все массивы, dictionary, все объекты в C#, они инициализируются через фигурные именно скобочки, поэтому они бы здесь были более такими естественными.
545.76 554.76 "Игорь Лабутин" Да, но надо понимать, что collection literals будет в том числе использоваться, точнее, collection expressions для pattern matching, вероятно, когда мы будем матчить.
554.76 567.72 "Игорь Лабутин" И проблема возникала в том, что если там использовать фигурные скобочки, то там было огромное количество случаев, когда парсер невозможно написать, как это правильно называется-то, короче… Однозначно.
567.72 568.72 "Игорь Лабутин" Да-да-да-да-да.
568.72 578.08 "Игорь Лабутин" То есть фигурные скобки давали очень большое… Поскольку они очень много где используются в C#, да, это и… ну как много где, да, это по сути ограничитель блока, можно сказать.
578.08 579.08 "Анатолий Кулаков" Логический блок.
579.08 580.08 "Игорь Лабутин" Да, любой контент-блок.
580.08 583.00 "Игорь Лабутин" Вот, поэтому было сложно.
583.00 588.84 "Игорь Лабутин" Они поэтому решили всё-таки квадратную скобку, сказали, ну а заодно вообще-то так во многих языках, поэтому многим будет привыкнуть.
588.84 589.84 "Игорь Лабутин" Ну, привыкнем.
589.84 599.04 "Игорь Лабутин" Так вот, у этой штуки есть, да, как я сказал, можно создавать словарики, вот словарики нельзя будет создавать в 12-ом C#.
599.04 601.40 "Игорь Лабутин" Этого не сделают, ещё не успеют.
601.40 605.28 "Игорь Лабутин" А дальше есть ещё такая штука под названием natural type.
605.28 612.20 "Игорь Лабутин" Смотри, если ты создаёшь, ну вот, например, ты взял там квадратную скобочку, написал 1,2,3, и всё.
612.20 615.28 "Игорь Лабутин" И написал перед этим var x присвоить.
615.28 617.04 "Игорь Лабутин" Вот какого типа будет x?
617.04 620.84 "Анатолий Кулаков" Типа через запятую, если… может быть, сразу тапл какой-нибудь?
620.84 625.60 "Игорь Лабутин" Нет-нет-нет, ну у нас… мы создаём коллекцию, вот у тебя коллекция из трёх элементов.
625.60 626.60 "Игорь Лабутин" Один, два, три.
626.60 630.08 "Анатолий Кулаков" Ну, тогда array, наверное, от int.
630.08 633.92 "Игорь Лабутин" Вот array или list от int, или кто?
633.92 639.92 "Анатолий Кулаков" Ну, зная любовь автора к извращениям, я бы подумал, что array.
639.92 647.12 "Игорь Лабутин" Нет, на самом деле будет list, потому что обычно ты всё-таки инициализируешь коллекцию, но крайне редко она у тебя должна быть immutable.
647.12 649.52 "Игорь Лабутин" Прям вот так, чтобы нельзя было добавлять.
649.52 653.72 "Игорь Лабутин" А в array понятно, что ты не добавишь новых без перелокаций, поэтому всё-таки list.
653.72 655.00 "Анатолий Кулаков" Ну, это радует.
655.00 670.52 "Анатолий Кулаков" Это значит, что как бы все извращения, к которым я привык, они отбросили, потому что array — это довольно таки странная конструкция в нашем мире, потому что по сути изменять ты его можешь, добавляя элементы на текущие места, но добавлять элементы ты не можешь.
670.52 673.08 "Анатолий Кулаков" Кому такая структура нужна, вообще непонятно.
673.08 675.80 "Анатолий Кулаков" Поэтому list — это должно быть везде.
675.80 682.36 "Игорь Лабутин" Из этих соображений это будет list, и вот этот вот list от int, это называется natural type для такого литерала.
682.36 688.76 "Игорь Лабутин" То есть выведенный из типов элементов его, ну так сказать, натуральный тип.
688.76 699.48 "Игорь Лабутин" Дальше там возникают сложности, а что если ты перечислил там 1, строчка, запятая double, то видимо это будет list от object или ещё что-нибудь такое.
699.48 708.56 "Игорь Лабутин" А ещё если ты указал вот этот nested collection, когда ты можешь внутрь положить коллекцию, и она там какой-нибудь inumerable от чего-нибудь, или вообще просто inumerable.
708.56 712.96 "Игорь Лабутин" Короче, там возникают некоторые вопросы вывода типа, если ты слева использовал var.
712.96 723.28 "Анатолий Кулаков" Слушай, ну мне кажется эта проблема давно решена, потому что у нас есть анонимные массивы, когда ты создаёшь new, квадратные скобочки пишешь, и там перечисляешь непосредственно литералы.
723.28 734.24 "Анатолий Кулаков" И в принципе компилятор справляется, то есть он понимает, что когда double с int перемешивает, он по-моему позволяет это делать, когда ты даже какие-нибудь строки вгоняешь, что он говорит, чувак, давай укажи-ка явно, почему бы здесь так же не сделать.
734.24 741.60 "Игорь Лабутин" Ну вот всё можно сделать так же, но вот эту штуку они видимо не успевают, потому что сказано, что natural types не будет сделано в 12-ом C#.
741.60 745.48 "Анатолий Кулаков" Ну то есть можно использовать только что-то однотипное, да?
745.48 755.60 "Игорь Лабутин" Я понял это, я честно вчера пытался понять из обсуждения на гитхабе, что же там они успеют сделать, я не смог, там как бы огромное количество комментариев и обсуждений, половина про то, что вот.
755.60 761.16 "Игорь Лабутин" Короче, там много деталей всяких разных про то, что это не так, это не так, и вообще там сложно.
761.16 776.60 "Игорь Лабутин" Огромное описание самого пропозала, и я так понял, что либо вот то, что ты говоришь, либо нельзя будет вар слева написать в некоторых случаях, то есть он просто не сможет вывести и придётся таки написать нормальный тип коллекции.
776.60 789.40 "Анатолий Кулаков" Ну мне в этом подходе нравится, когда именно указываются явно типы, то есть не явно, что тебе не нужно вар использовать, а в том смысле, что все элементы должны быть однородными, одного и того же типа.
789.40 793.32 "Анатолий Кулаков" Если тебе не нравится, этот тип возьми и явно прикасть его к тому, который нужен.
793.32 800.48 "Анатолий Кулаков" Вот и всё, то есть все вот эти неявные преобразования вместе с фаром, они действительно дают слишком большой простор для трактования.
800.48 805.64 "Анатолий Кулаков" Поэтому если они не сделают вообще автоматически вот эти преобразования, это будет прекрасно.
805.64 815.68 "Игорь Лабутин" Ну вот посмотрим, я думаю, что когда эту фичу окончательно доделают, будет нормальный, как обычно, анонс, там в превью, в релиз кандидате мы это детально посмотрим и обсудим.
815.68 828.44 "Игорь Лабутин" Дальше, интерсепторы, которые мы немножко затронули в прошлый раз, обсуждали, они уже в превью и будут в превью до релиза, в смысле, что они и релизятся в статусе превью фичи.
828.44 832.60 "Анатолий Кулаков" Ну да, кажется, что им до основного релиза интерсепторам далеко.
832.60 839.24 "Анатолий Кулаков" Внезапно вскочили, наверняка какая-то такая закладочка на будущее, чтобы потом из них сделать что-нибудь человеческое.
839.24 843.20 "Игорь Лабутин" Да, они нужны для нейди фаута, мы про это поговорим сегодня чуть позднее.
843.20 846.20 "Игорь Лабутин" Ну основное их предназначение, но не только.
846.20 848.88 "Игорь Лабутин" Но они будут точно в превью.
848.88 850.80 "Игорь Лабутин" Дальше начинается...
850.80 855.04 "Игорь Лабутин" А, еще есть, соответственно, штука под названием ref_readonly parameters.
855.04 862.16 "Игорь Лабутин" Это возможность задавать ключевые слова ref и readonly для параметра.
862.16 869.48 "Игорь Лабутин" Давайте мы это пообсуждаем, когда оно выйдет, потому что там тоже всякие сложные штуки, как мне кажется, с тем, что куда можно передавать.
869.48 874.76 "Игорь Лабутин" Вспоминаем, что у нас уже есть модификаторы in, out, ref теперь будет ref_readonly.
874.76 875.76 "Игорь Лабутин" Так что доберемся.
875.76 886.96 "Игорь Лабутин" Ее ожидают в 12-ом C#, то есть она пока не доделана, хотя вроде как, вот сегодня я буквально с утра видел твит про то, что какая-то часть фичи уже вмерзлена в Visual Studio, поддержка ее.
886.96 888.88 "Игорь Лабутин" Так что, видимо, там все почти готово.
888.88 892.24 "Игорь Лабутин" И ждем в ближайшем превью.
892.24 899.96 "Игорь Лабутин" А теперь про фичи, которые точно не войдут в C# 12-ый по мнению команды, которые они планировали, но не смогли.
899.96 919.48 "Игорь Лабутин" Во-первых, была фича, планировалась, про то, чтобы сделать парамс вот тот самый наш, то, что многие знают под названием var_args, да, возможность создать последний аргумент в виде массивчика и туда компилятор будет автоматически подставлять все элементы, переданные сверх того, чего объявлено явно.
919.48 933.92 "Игорь Лабутин" Собирались сделать его в виде span(t), то есть не массив, как сейчас, который лоцируется, а через span, соответственно, если компилятор понимает, что там параметров немного, можно их на стэк, например, положить и избежать аллокации.
933.92 953.92 "Игорь Лабутин" Плюс к этой же фиче шла, так сказать, параллелика, фича под названием stack_alloc_any_array_type, то есть можно было бы, сейчас можно stack_alloc_any_array_type, только примитивные типы, насколько я помню, ну или bleedable, да, те, которые, по сути, имеют представление в памяти, ну то есть ровно, можно скопировать через memcpy, грубо говоря.
953.92 954.92 "Игорь Лабутин" Выровненные типа.
954.92 958.60 "Игорь Лабутин" Да, они не выровненные, именно смысл в том, что там нет референсов.
958.60 959.60 "Игорь Лабутин" Ну да.
959.60 960.60 "Игорь Лабутин" Внутри.
960.60 965.60 "Игорь Лабутин" Там поля лежат, вот как бы наборы примитивных типов, грубо говоря, они подряд лежат.
965.60 975.60 "Игорь Лабутин" И можно было бы сделать, они планировали сделать фичу stack_alloc_any_array_type, то есть хочешь массив объекта референсов, да не вопрос, делай stack_alloc на него.
975.60 978.60 "Игорь Лабутин" Но всё это не войдёт в C# 12.
978.60 981.60 "Игорь Лабутин" Что-то не сложилось.
981.60 982.60 "Игорь Лабутин" Дальше.
982.60 985.60 "Игорь Лабутин" В deconstruction собирались сделать дефолты.
985.60 1000.60 "Игорь Лабутин" То есть можно было бы написать такую штуку, как в левой части выражения там "круглоскопка открылась", там не знаю, "int x, а имя класс" там, "myClass b", "круглоскопка закрылась" происходит дефолт.
1000.60 1004.60 "Игорь Лабутин" И у тебя каждый элемент слева получал бы дефолтное значение.
1004.60 1005.60 "Игорь Лабутин" Зачем?
1005.60 1010.60 "Игорь Лабутин" Не знаю, ну такая быстрая интеллизация пачки всего не будет.
1010.60 1018.60 "Игорь Лабутин" Дальше и две больших фичи, которые много кто ждал, давно ждут, которые тоже не будет 12.
1018.60 1030.60 "Игорь Лабутин" Во-первых, сначала называлась фича semi-autoproperties, то есть наполовину автоматические пропертии, сейчас её переименовали в фичу под названием field-access in autoproperties.
1030.60 1033.60 "Анатолий Кулаков" Хотя бы теперь понятно стало, про что это.
1033.60 1036.60 "Анатолий Кулаков" Потому что semi-autoproperties так себе название было.
1036.60 1039.60 "Игорь Лабутин" Да, не автоматические, не ручные такие.
1039.60 1040.60 "Игорь Лабутин" Не то, не сё.
1040.60 1047.60 "Игорь Лабутин" Как мы помним, в set-блоке у вас есть специальное ключевое слово value, которое обозначает то самое значение, которое вы пытаетесь пересводить в пропертию.
1047.60 1058.60 "Игорь Лабутин" Теперь же там будет и в set, и в get специальное ключевое слово field, которое, собственно, позволяет достучаться до того самого backing-филда, который компилятор на самом деле автоматически создаёт.
1058.60 1068.60 "Игорь Лабутин" До текущего момента нам нужно было, если мы хотим иметь какую-то нетривиальную логику в get или в set, руками объявлять private-поле, писать какой-нибудь тривиальный get и чуть более сложный set.
1068.60 1069.60 "Игорь Лабутин" Или наоборот.
1069.60 1072.60 "Игорь Лабутин" Там будет getter, который что-то делает над полем.
1072.60 1076.60 "Игорь Лабутин" Теперь этого можно не делать и просто использовать ключевое слово field.
1076.60 1077.60 "Игорь Лабутин" Кода будет поменьше.
1077.60 1081.60 "Игорь Лабутин" Не будет этого в C# 12.
1081.60 1082.60 "Игорь Лабутин" И последнее.
1082.60 1089.60 "Игорь Лабутин" Они, видимо, надеялись, что смогут зайти в какой-нибудь части в фичу под названием rows-extensions.
1089.60 1094.60 "Игорь Лабутин" А ещё она называется extension-everything, ещё она называется...
1094.60 1097.60 "Игорь Лабутин" Ну, это не type-классы, но что-то вокруг этого.
1097.60 1099.60 "Игорь Лабутин" Но тоже ничего не будет.
1099.60 1100.60 "Игорь Лабутин" Ждём.
1100.60 1101.60 "Игорь Лабутин" Выкинули extension-everything?
1101.60 1102.60 "Игорь Лабутин" Выкинули.
1102.60 1103.60 "Игорь Лабутин" Ждём следующей версии.
1103.60 1112.60 "Анатолий Кулаков" Мне кажется, вот это единственная штука, которую можно было назвать какой-то значимой, потому что всё остальное – это такой мелочь, что даже стыдно её декларировать.
1112.60 1119.60 "Анатолий Кулаков" Может, поэтому не было никаких анонсов и на этих, на ребят из компенсаторов постоянно наезжали, ну что вы сделаете, на что вы сделаете.
1119.60 1122.60 "Анатолий Кулаков" Вот они себе ищу и накатали хотя бы, что они сделают.
1122.60 1124.60 "Анатолий Кулаков" Ну, может быть, может быть.
1124.60 1125.60 "Анатолий Кулаков" Грустно.
1125.60 1129.60 "Анатолий Кулаков" Какой-то вот для языка релиз полностью отстойный.
1129.60 1136.60 "Игорь Лабутин" Ну, другое, как бы проблема даже не в том, что он там какой-то отстойный, а в том, что это LTS-версия, которая выходит сейчас.
1136.60 1158.60 "Игорь Лабутин" И это значит, что даже если в 13 C# будет много каких-нибудь вкусных, больших, крупных фич, например, те же extensions или ещё что-нибудь, те же 7 autowrapper, field access, простите, в автопропертях, всё равно это значит, что кто-то не перелезет на какой-то будет уже 13 C#, потому что это будет 9-ый тутнет, который не LTS, вот это всё.
1158.60 1168.60 "Анатолий Кулаков" Ну да, конечно, хотя бы такую массовую фичу, как extension everything, если бы они внедрили, чтобы её уже можно было сидеть, осваивать как бы спокойно и без всякой опаски, вот было бы прекрасно.
1168.60 1170.60 "Анатолий Кулаков" Теперь её ещё ждать долго.
1170.60 1177.60 "Игорь Лабутин" Но с другой стороны, внедрят в 13 C#, обкатают на не LTS-версии и к LTS-ному какому-то 14-ому будет хорошо.
1177.60 1194.60 "Анатолий Кулаков" Конечно, да, но вот мне почему-то казалось, что вот extension, они там уже практически готовы, разрешите только их списать не на классах, а на всём подряд, там, блин, как-нибудь так, ну то есть там уже технически, по идее, всё для меня было сделано, и был вопрос лишь в синтоксическом сахаре, и всё.
1194.60 1198.60 "Анатолий Кулаков" Что там можно было не успеть, вот это интересно было бы разобраться.
1198.60 1211.60 "Игорь Лабутин" Ну скорее всего, как обычно, что наивная реализация фичи подразумевает наверняка огромное количество возможностей использовать её как-то криво, с каким-нибудь невалидным код-геном, ещё что-нибудь.
1211.60 1218.60 "Анатолий Кулаков" Ну хотя бы чуточку там на пропертях бы дали там сделать, или ещё что-нибудь, хотя бы не везде, а так наполовинку.
1218.60 1221.60 "Анатолий Кулаков" Семи-авто-экстеншн, знаешь.
1221.60 1224.60 "Игорь Лабутин" Да, да, да, не совсем extension, не совсем everything.
1224.60 1243.60 "Игорь Лабутин" Не знаю, не знаю, ну я попытался, честно говоря, вчера найти по некоторым фичам, что же там, почему так или иначе не успевают, но каких-то быстрых там больших постов, точнее, комментов на GitHub типа "Вот, вот это мы не успеваем потому-то, потому-то, быстро найти не смог".
1243.60 1257.60 "Игорь Лабутин" То есть это всё-таки, видимо, делается где-то во внутренних обсуждениях, наверняка там есть среди этих сотен комментариев на GitHub к пропозлам сообщение про то, что "Вот, всё-таки давайте мы перенесём", но, блин, тяжело найти, не смог.
1257.60 1261.60 "Анатолий Кулаков" Ну, хорошо, будем ждать релиза анонсов.
1261.60 1263.60 "Анатолий Кулаков" Чё, пойдём дальше?
1263.60 1264.60 "Анатолий Кулаков" Да, давай.
1264.60 1273.60 "Анатолий Кулаков" Давай, рассмотрим интересную статейку от Марка Симона, нырнём поглубже в архитектуру и узнаем, что такое ретроактивный континуитет.
1273.60 1274.60 "Анатолий Кулаков" Ты знаешь, кстати?
1274.60 1278.60 "Игорь Лабутин" Впервые слышу, ну ладно, ретроактивное слово слышу, а вот про...
1278.60 1280.60 "Игорь Лабутин" Кто, простите, это слово я первый раз слышу?
1280.60 1283.60 "Анатолий Кулаков" Континуитет, ну что ты, ну.
1283.60 1291.60 "Анатолий Кулаков" К тому пассажу, что Марк Симон иногда слишком сильно загоняется всякими хитровыдуманными фразами.
1291.60 1293.60 "Игорь Лабутин" Да, как раз хотябка звучит, как Марк Симон.
1293.60 1295.60 "Анатолий Кулаков" Да, да, да, это он и есть.
1295.60 1307.60 "Анатолий Кулаков" Ну что ж, друзья, несмотря на высокий слог, высокопарный слог, темы у него продолжают быть прекрасными, интересными и важными для дизайна ваших приложений, поэтому обсудим.
1307.60 1311.60 "Анатолий Кулаков" Обсудим небольшую интересную тему, которая называется "Validation and business rules".
1311.60 1320.60 "Анатолий Кулаков" То есть, в основном, чем отличаются валидация и бизнес правила, и вообще должны ли они отличаться, и вообще где роль валидации в нашей системе?
1320.60 1338.60 "Анатолий Кулаков" Очень важная штука, потому что часто путают люди в валидации и бизнес правила, и из-за этого наблюдается и неправильное размещение, то есть в неправильных сборках, и использование неправильных инструментов, которых не должно там быть, и вообще там выход другой, вход не тот, в общем, очень много здесь путаницы.
1338.60 1341.60 "Анатолий Кулаков" Поэтому я очень обрадовался, когда Марк взялся за эту тему.
1341.60 1352.60 "Анатолий Кулаков" Здесь вначале просто разбирается, в чем отличие, как определить, кто за что отвечает.
1352.60 1357.60 "Анатолий Кулаков" Больше конкретных примеров, я думаю, у нас будет в будущих статьях.
1357.60 1358.60 "Анатолий Кулаков" Погнали сначала.
1358.60 1362.60 "Анатолий Кулаков" Прежде всего, Марк дает определение, что же такое валидация.
1362.60 1371.60 "Анатолий Кулаков" Прежде всего, для него валидация – это чистая функция, Pure Function, которая, в принципе, много раз постоянно в функциональных языках программирования, но и в C# встречается уже довольно-таки часто.
1371.60 1378.60 "Анатолий Кулаков" То есть это чистая функция, которая определяет, какие данные доступны для обработки.
1378.60 1391.60 "Анатолий Кулаков" Здесь именно «доступны для обработки» специально сделан такой довольно обтекаемый термин, потому что те данные, которые доступны для обработки и данные, которые непосредственно ваша программа будет обрабатывать, они могут не совпадать.
1391.60 1407.60 "Анатолий Кулаков" Допустим, вы можете принимать более какие-то данные не структурированные, не типизированные, потом в процессе валидации каким-то образом их, например, преобразовать в то, что вам нужно, и потом передавать дальше.
1407.60 1411.60 "Анатолий Кулаков" То есть дополнять и как-нибудь обогащать, больше структурировать и так далее.
1411.60 1417.60 "Анатолий Кулаков" То есть принимать мы можем вообще какую-то непонятную кашу, а вот после валидации у нас должна выйти конфетка.
1417.60 1421.60 "Анатолий Кулаков" Итак, бизнес-правила.
1421.60 1423.60 "Анатолий Кулаков" Давайте начнем издалека.
1423.60 1432.60 "Анатолий Кулаков" Вообще эта статья опирается на такие фундаментальные концепции объектно-ориентированного программирования, да не только объектно-ориентированного уже, как и инкапсуляция.
1432.60 1434.60 "Анатолий Кулаков" То есть инкапсуляция – это довольно важный концепт.
1434.60 1439.60 "Анатолий Кулаков" Он помогает нам построить какие-то маленькие блоки, которые будут легко входить в нашу голову.
1439.60 1449.60 "Анатолий Кулаков" И внутри этих блоков будут инкапсулированы еще какие-то маленькие блоки, которые будут уже более низкоуровневые и о которых мы в большинстве случаев можем не задумываться.
1449.60 1455.60 "Анатолий Кулаков" То есть именно вот этот концепт маленьких блоков, вложенных в других блоков, позволяет нам строить именно сложные системы.
1455.60 1467.60 "Анатолий Кулаков" Поэтому инкапсуляция – это очень важная штука, которая помогает нам и код держать более-менее консистентным, каким-то иерархичным и в голове у нас укладывать мысли более-менее консистентно, не спускаясь на низкоуровневую имплементацию.
1467.60 1471.60 "Анатолий Кулаков" И одним из самых главной частей инкапсуляции является контракт.
1471.60 1484.60 "Анатолий Кулаков" Потому что именно контракт определяет вот этот переход, то, как инкапсуляция не будет течь, то есть не будет выдавать свою имплементацию наружу и при этом с ней можно будет взаимодействовать.
1484.60 1488.60 "Анатолий Кулаков" Поэтому продумывание контракта для инкапсуляции – это очень важно.
1488.60 1489.60 "Анатолий Кулаков" Что же такое контракт?
1489.60 1492.60 "Анатолий Кулаков" Контракт – это прежде всего набор из трех основных элементов.
1492.60 1498.60 "Анатолий Кулаков" Это предусловия, preconditions – это инварианты, и постусловия, postconditions.
1498.60 1511.60 "Анатолий Кулаков" И вот как раз preconditions, они очень важны для валидации, то есть при условии того, что у нас будет внутри этих данных, этих инкапсулированных объектов.
1511.60 1516.60 "Анатолий Кулаков" Итак, как же разделить валидацию и бизнес-правила?
1516.60 1518.60 "Анатолий Кулаков" Давайте посмотрим на конкретном примере.
1518.60 1536.60 "Анатолий Кулаков" Марк очень любит стандартный свой пример – это ресторан, система ресторанов, и у него там есть очень такой богатый на всякий пример эксперимент с резервацией ресторана, то есть с бронированием по-русски, с бронированием ресторанных мест.
1536.60 1547.60 "Анатолий Кулаков" И вот представьте, что вам нужно позвонить в ресторан или отправить какой-нибудь HTTP-запрос для того, чтобы забронировать столик на какой-нибудь вечер.
1547.60 1556.60 "Анатолий Кулаков" В конце концов, вы хотите получить в случае успешного бронирования некий класс, называемый reservation.
1556.60 1567.60 "Анатолий Кулаков" И этот класс должен внутри себя содержать то, что вам удалось забронировать, где забронировать, что забронировать, в общем, всю информацию о забронированном месте.
1567.60 1579.60 "Анатолий Кулаков" Итак, что же является предусловием для того, чтобы вот этот класс reservation, его можно было создать как настоящий нормальный агрегат со всеми вариантами.
1579.60 1585.60 "Анатолий Кулаков" Ну, наверное, вам нужно будет дата и время, в который ваш столик забронирован.
1585.60 1592.60 "Анатолий Кулаков" Скорее всего, вам нужно будет количество гостей, которые планируют посетить данный столик.
1592.60 1599.60 "Анатолий Кулаков" Может быть, имена контактов, имена, номера телефонов, e-mail, что угодно, вообще, какую-то связь с контактами.
1599.60 1604.60 "Анатолий Кулаков" В общем, вот такие базовые там какие-то свойства должны в этом классике наверняка сохраниться.
1604.60 1614.60 "Анатолий Кулаков" И очень часто советуют пойти дальше и сказать, что этот классик, в принципе, не может существовать, если в ресторане все столики уже заняты.
1614.60 1632.60 "Анатолий Кулаков" И также этот классик reservation не может существовать, если, допустим, столики заняты именно в это время, или ресторан в это время закрыт, или, допустим, не хватает столика в определенного размера для того, чтобы данное количество гостей посетить.
1632.60 1638.60 "Анатолий Кулаков" Но на самом деле все это не является предусловиями для создания класса reservation.
1638.60 1644.60 "Анатолий Кулаков" То есть класс reservation, его на самом деле можно создать, зная время, количество гостей и так далее.
1644.60 1649.60 "Анатолий Кулаков" И класс reservation, в принципе, все равно на то, открытый ресторан или закрытый ресторан.
1649.60 1652.60 "Анатолий Кулаков" Это уже более широкий контекст.
1652.60 1655.60 "Анатолий Кулаков" И вот этот более широкий контекст, это уже как раз таки есть бизнес-правило.
1655.60 1662.60 "Анатолий Кулаков" То есть валидация, она должна находиться только на уровне предусловий.
1662.60 1669.60 "Анатолий Кулаков" Давайте немножко тогда разберемся, в чем же разница между предусловиями, бизнес-правилами, валидацией, как они с друг другом соотносятся и так далее.
1669.60 1681.60 "Анатолий Кулаков" Из того примера, что мы видели, самым главным описателем, по которому вы можете определить валидацию, это по-английски называется self-content.
1681.60 1683.60 "Анатолий Кулаков" Игорь, можно как-то это на русский перевести?
1683.60 1685.60 "Анатолий Кулаков" Self-content.
1685.60 1689.60 "Анатолий Кулаков" Самодостаточный, наверное, в этом случае.
1689.60 1701.60 "Анатолий Кулаков" То есть в этих примерах можно четко выделить самодостаточные условия, которые являются частью объекта или частью конструктора этого объекта.
1701.60 1704.60 "Анатолий Кулаков" Вот, например, размер.
1704.60 1712.60 "Анатолий Кулаков" Допустим, мы точно не можем создать резервацию без даты, в которой она зарезервирована, и без количества гостей, например.
1712.60 1714.60 "Анатолий Кулаков" Это невозможно вообще создать этот класс.
1714.60 1725.60 "Анатолий Кулаков" А вот открыт ли ресторан, какое расположение столика в этом ресторане, какая очередь предзаказа в этот ресторан, то есть кто будет первый, кто второй.
1725.60 1733.60 "Анатолий Кулаков" И вот другие вещи - это уже бизнес-правила, потому что они требуют более широкого контекста, чем сам вот этот классик, сам классик резервейшн.
1733.60 1740.60 "Анатолий Кулаков" Им уже нужно знать и о текущем расписании, и о приоритетах, и о том, какие столики заняты или не заняты.
1740.60 1744.60 "Анатолий Кулаков" То есть здесь уже подгружается какой-то более весомый контекст.
1744.60 1747.60 "Анатолий Кулаков" Поэтому именно вот здесь проходит эта грань.
1747.60 1755.60 "Анатолий Кулаков" Когда вам нужно что-то большее, что выходит за ваш примитивный классик, за ваш примитивный ответ, то это уже не валидация, это уже бизнес-правила пошли.
1755.60 1763.60 "Анатолий Кулаков" И если вот смотреть на эту проблему так, то по сути валидация у нас сводится к проблеме парсинга.
1763.60 1765.60 "Анатолий Кулаков" Почему это так?
1765.60 1787.60 "Анатолий Кулаков" В принципе, не очень, может быть, интуитивно, но на самом деле, что любое наше приложение, у него задача, например, на входе, когда мы получаем какие-то данные с того же HTTP-запроса, это взять неструктурированные данные, ну или плохо структурированные данные, давайте так, это может быть там JSON, XML, CSV, вообще все что угодно.
1787.60 1793.60 "Анатолий Кулаков" Любой там формат описания данных, но по сути для приложения они являются слабо структурированными, потому что у них нет типов.
1793.60 1796.60 "Анатолий Кулаков" У них может быть не та структура, которую ожидает наша программа.
1796.60 1798.60 "Анатолий Кулаков" И так далее.
1798.60 1803.60 "Анатолий Кулаков" Так вот, приложение должно взять эти данные и превратить в более структурированные данные.
1803.60 1808.60 "Анатолий Кулаков" Например, в объекты в C# или в рекорды в F#.
1808.60 1818.60 "Анатолий Кулаков" Ну, то есть, что-то такое, что у нас уже есть какие-то типы, какая-то структура, в общем, то, с чем наша программа непосредственно уже может работать.
1818.60 1826.60 "Анатолий Кулаков" И вот в случае успешной этой фазы валидации, у нас preconditions, значит, прошли.
1826.60 1829.60 "Анатолий Кулаков" В случае неуспешной preconditions, значит, не прошли.
1829.60 1834.60 "Анатолий Кулаков" Можно ли засунуть в наши объекты, в наш валидатор больше preconditions?
1834.60 1842.60 "Анатолий Кулаков" Например, стоит ли, опять же, в валидацию запихивать то открытый ресторан или закрытый ресторан?
1842.60 1855.60 "Анатолий Кулаков" Здесь можно опереться на закон постула, который говорит, что мы должны быть как можно более терпимыми к тем данным, которые к нам приходят, и как можно более строгими к тем данным, которые от нас уходят.
1855.60 1870.60 "Анатолий Кулаков" Это значит, что мы не должны требовать каких-то данных, даже не должны требовать каких-то данных, каких-то условий, которые нам не нужны как объекту для своего создания.
1870.60 1884.60 "Анатолий Кулаков" То есть, мы не должны при создании резервации хотеть чего-то другого, что, по сути, не относится к нашим непосредственной резервации, вот именно в фазе валидации.
1884.60 1890.60 "Анатолий Кулаков" Но, естественно, мы не должны пропускать какие-то поля, которые нам необходимы.
1890.60 1895.60 "Анатолий Кулаков" Например, опять же, без даты никакая резервация невозможна, класс Reservation создать невозможно.
1895.60 1900.60 "Анатолий Кулаков" То есть, дата у нас точно нужна, количество гостей нам точно нужно, то есть, без них не создаться сам этот класс.
1900.60 1903.60 "Анатолий Кулаков" Но что-то более смотреть вне этой системы мы не должны.
1903.60 1906.60 "Анатолий Кулаков" Это уже не наша область ответственности как валидатора.
1906.60 1908.60 "Анатолий Кулаков" Это уже не область ответственности валидатора.
1908.60 1911.60 "Анатолий Кулаков" Давайте взглянем немножко с другой стороны.
1911.60 1923.60 "Анатолий Кулаков" Допустим, представим, что валидация это не процесс парсинга входящих данных, то есть, преобразование слабо структурированных данных в более структурированные, а это трансформация над входом.
1923.60 1929.60 "Анатолий Кулаков" Тогда мы получаем, что, в принципе, это трансформация над входом и она может быть из любых третисторонних систем, как я уже сказал.
1929.60 1938.60 "Анатолий Кулаков" Это может быть HTTP-запрос, это может быть файлик в FTP-хранилище, это может быть формочка, которой пользователь бил какие-то свои данные.
1938.60 1948.60 "Анатолий Кулаков" Все это внешние системы и их формат довольно слабо структурирован, как бы вы не пытались бы себя в этом убедить.
1948.60 1950.60 "Анатолий Кулаков" Прислать туда вам могут абсолютно все, что угодно.
1950.60 1960.60 "Анатолий Кулаков" Опять же, есть фазы тестирования и прочие такие вещи, которые шлют абсолютно билиберду именно для того, чтобы проверить ваш уровень валидации.
1960.60 1964.60 "Анатолий Кулаков" Вернемся немножко к нашей теме.
1964.60 1980.60 "Анатолий Кулаков" Посыл заключается в том, что если между вами и этой стороной нет каких-то формальных критериев, то вы должны смириться с тем, что настоящего контракта, строго типизированного в том смысле строгих типов, которые есть в вашем языке, его не существует.
1980.60 1981.60 "Анатолий Кулаков" Его нет.
1981.60 1994.60 "Анатолий Кулаков" И очень важная часть – обращать внимание именно на этот факт, что никаких гарантий, что вам придет в этом инпуте их не существует.
1994.60 2002.60 "Анатолий Кулаков" И чем явнее вы это обозначите, тем лучше для вашего контракта и для вашего приложения.
2002.60 2011.60 "Анатолий Кулаков" Из своего собственного примера можно привести сюда null reference type, который у нас возник в прошлых релизах C#.
2011.60 2019.60 "Анатолий Кулаков" Благодаря им мы получили очень много мощных всяких инструментов, которые помогают написать код без ошибок.
2019.60 2033.60 "Анатолий Кулаков" И, к сожалению, у нас нет каких-то наработанных уже best practice или докладов, или статьи хороших, которые нас учат, каким же образом у нас должно было измениться программирование из-за появления reference type.
2033.60 2044.60 "Анатолий Кулаков" И вот здесь, когда мы говорим о максимально явном использовании внешних контрактов, одно из главных преимуществ reference type, null reference type у нас выстреливает.
2044.60 2057.60 "Анатолий Кулаков" Оно нам говорит о том, что все DTO, которые мы принимаем снаружи, которые к нам могут прийти, они обязаны иметь нулябельные свойства во всех своих свойствах.
2057.60 2067.60 "Анатолий Кулаков" Именно по этой простой причине, если вы требуете, чтобы к вам пришел какой-то юзер с ID-шником, никто никогда не гарантирует, что этот ID-шник вам будет передан.
2067.60 2077.60 "Анатолий Кулаков" Естественно, у вас HTTP запрос можно выполнить, передать туда какой угодно объект, и в этом объекте, естественно, может не быть никакого ID-шника.
2077.60 2082.60 "Анатолий Кулаков" Правильно это или неправильно, валидный это запрос или не валидный, это уже определит следующий слой.
2082.60 2093.60 "Анатолий Кулаков" Но та DTO, которая стоит именно на границе десериализации, именно на границе парсинга, она должна давать максимум явной информации о том, что к вам пришло.
2093.60 2108.60 "Анатолий Кулаков" И именно поэтому у всех DTO выставляются обычно нулябельные свойства, и уже потом на процессе валидации проверяется, что если это ID-шник от пользователя нам обязательен для дальнейшей работы, то тогда мы уже бросаем ошибку валидации и так далее.
2108.60 2121.60 "Анатолий Кулаков" Вот эта часть про то, что ваш внешний контракт должен быть как можно более явным, и он должен как можно более явно подчеркивать, что снаружи к вам может прийти абсолютно любая дичь.
2121.60 2130.60 "Анатолий Кулаков" И чем больше у вас клиентов, тем больше у вас протоколов, тем больше у вас каких-то нестандартных, нештатных ситуаций, тем больше в вашем контракте будет этой дичи.
2130.60 2136.60 "Анатолий Кулаков" Поэтому чем лучше контракт это отразит, тем прекраснее для вашего приложения, тем легче его будет поддерживать.
2136.60 2139.60 "Анатолий Кулаков" Итак, возвращаемся дальше.
2139.60 2142.60 "Анатолий Кулаков" К нашей валидации.
2142.60 2146.60 "Анатолий Кулаков" Есть еще один тезис, что валидация должна быть детерминирована.
2146.60 2147.60 "Анатолий Кулаков" Что это значит?
2147.60 2162.60 "Анатолий Кулаков" Это значит, что если вы приняли какие-то данные единожды, вы не можете их не принять на следующий день с формулировкой, что это был плохо сформированный запрос, что это инвалид-запрос.
2162.60 2174.60 "Анатолий Кулаков" То есть, другими словами, если вы принимаете какие-то данные завтра, то это вполне могут быть те данные, которые вы не принимали сегодня.
2174.60 2176.60 "Анатолий Кулаков" То есть, вы можете расширять свой контракт.
2176.60 2185.60 "Анатолий Кулаков" Но если вы завтра какие-то данные отвергаете, то это не могут быть те данные, которые вы принимали сегодня.
2185.60 2195.60 "Анатолий Кулаков" Заумно он, конечно, выразился, но по сути это значит, что если вы сегодня принимаете какие-то данные, то вы не можете прекратить их принимать завтра с формулировкой, естественно, что это плохо созданный запрос.
2195.60 2198.60 "Анатолий Кулаков" То есть, что они не прошли валидацию.
2198.60 2203.60 "Анатолий Кулаков" Если ваши данные проходят валидацию сегодня, они обязаны проходить валидацию завтра.
2203.60 2205.60 "Анатолий Кулаков" Валидация именно про вот это.
2205.60 2207.60 "Анатолий Кулаков" То есть, она детерминирована.
2207.60 2213.60 "Анатолий Кулаков" Да, то есть, вы не можете принять данные в эту минуту и отвергнуть данные в следующую минуту.
2213.60 2214.60 "Анатолий Кулаков" Так не бывает.
2214.60 2216.60 "Анатолий Кулаков" Но отвергнуть с точки зрения валидации, безусловно.
2216.60 2220.60 "Анатолий Кулаков" Как отвергать данные, мы поговорим чуть дальше.
2220.60 2223.60 "Анатолий Кулаков" То есть, валидация должна быть детерминированная.
2223.60 2227.60 "Анатолий Кулаков" Один и тот же вход обязан выдавать один и тот же выход.
2227.60 2237.60 "Анатолий Кулаков" И независимо от даты, от времени, от версии вашего приложения, через год, через два года, все время принимая один и тот же вход, вы должны выдавать один и тот же выход.
2237.60 2239.60 "Анатолий Кулаков" Это основы внешнего контракта.
2239.60 2244.60 "Анатолий Кулаков" Валидация должна, у валидации не должно быть сайд-эффектов.
2244.60 2248.60 "Анатолий Кулаков" И таким образом мы приходим к тому, что валидация должна быть чистой функцией.
2248.60 2252.60 "Анатолий Кулаков" То есть, парсинг обычно тоже является чистой функцией.
2252.60 2264.60 "Анатолий Кулаков" И, соответственно, валидация как один из, как, наверное, не под множество, как один из представителей парсинга, вот она тоже должна быть чистой функцией.
2264.60 2276.60 "Анатолий Кулаков" То есть, если в вашей валидации встречаются какие-то изменения, какие-то изменения данных или другие признаки непьюрных функций, то значит вы делаете что-то не так.
2276.60 2278.60 "Анатолий Кулаков" Это уже не валидация.
2278.60 2283.60 "Анатолий Кулаков" Теперь подходим непосредственно к тому вопросу, а что же это такое.
2283.60 2297.60 "Анатолий Кулаков" То есть, если валидация это такой технический контракт между вашей системой и третьей сторонними приложениями, и валидация должна быть максимально стабильной, как только возможно, то как же все-таки вносить-то изменения?
2297.60 2300.60 "Анатолий Кулаков" А изменения как раз вносятся именно в бизнес-логику.
2300.60 2303.60 "Анатолий Кулаков" И это как раз бизнес-правила.
2303.60 2306.60 "Анатолий Кулаков" Вот они меняются, они могут меняться довольно часто.
2306.60 2309.60 "Анатолий Кулаков" И они должны меняться часто, это значит, что ваш бизнес живет.
2309.60 2310.60 "Анатолий Кулаков" Но не валидация.
2310.60 2311.60 "Анатолий Кулаков" На примере.
2311.60 2319.60 "Анатолий Кулаков" Допустим, у нас в резервации наших ресторанчиков есть такая функция, как зарегистрировать столик от другого пользователя.
2319.60 2321.60 "Анатолий Кулаков" Нет, того, от которого мы сейчас залогинили.
2321.60 2329.60 "Анатолий Кулаков" И ресторан становится популярным, и ему уже не хватает на мест, и поэтому функцию резервации от имени другого пользователя мы решили прикрыть.
2329.60 2338.60 "Анатолий Кулаков" Потому что нас стольково так не хватает, и чтобы увеличить там надежность и посещаемость, мы удалили эту возможность из нашего приложения.
2338.60 2340.60 "Анатолий Кулаков" Что, собственно, произошло?
2340.60 2343.60 "Анатолий Кулаков" Произошло то, что мы изменили бизнес-правила.
2343.60 2351.60 "Анатолий Кулаков" То есть, правило, что мы можем резервировать столик от имени другого пользователя, это именно бизнес-правило.
2351.60 2353.60 "Анатолий Кулаков" Потому что мы изменили поведение системы.
2353.60 2356.60 "Анатолий Кулаков" Но при этом мы никак не поменяли контракт.
2356.60 2367.60 "Анатолий Кулаков" Тот контракт, где мы резервировали столики, указывали у них количество гостей, указывали их желаемую дату и так далее, этот контракт остался на месте, он никуда не меняется, контракт никуда не уходит.
2367.60 2378.60 "Анатолий Кулаков" Но вот теперь то, что вчера мы могли под одним пользователем зарезервировать столик, а сегодня уже не можем под другим пользователем зарезервировать, это уже не ошибки валидации, это уже ошибки бизнес-правила.
2378.60 2384.60 "Анатолий Кулаков" И бизнес-правила именно этим отличаются от предусловий, от предвалидации.
2384.60 2388.60 "Анатолий Кулаков" Поэтому очень важно различать две этих концепции.
2388.60 2392.60 "Анатолий Кулаков" Валидация - это само...
2392.60 2396.60 "Анатолий Кулаков" Что бы нам придумали на self-content?
2396.60 2398.60 "Анатолий Кулаков" Самодостаточное.
2398.60 2408.60 "Анатолий Кулаков" Валидация - это описание самодостаточного контракта, который четко детерминирован, то есть, который не меняется со временем от зависимости от того, что нам захотел бизнес нам предложить.
2408.60 2411.60 "Анатолий Кулаков" У него нет эффектов, обычно это pure function.
2411.60 2413.60 "Анатолий Кулаков" Нет, это точно pure function, всегда.
2413.60 2415.60 "Анатолий Кулаков" И он не должен меняться.
2415.60 2423.60 "Анатолий Кулаков" То есть, валидация, контракт, они не должны меняться, потому что это уже breaking changes, и в эту степень уходим.
2423.60 2425.60 "Анатолий Кулаков" Бизнес-правила наоборот.
2425.60 2439.60 "Анатолий Кулаков" Они могут меняться, они меняются часто, они обычно никакая не pure функция, у них есть много всяких походов во внешние системы, у них есть модификация, может быть, каких-то данных, преобразование и так далее, и так далее.
2439.60 2441.60 "Анатолий Кулаков" То есть, вот это уже идут бизнес-правила.
2441.60 2444.60 "Анатолий Кулаков" У них разные жизненные циклы.
2444.60 2454.60 "Анатолий Кулаков" То есть, одни мы меняем часто, в зависимости от того, как потребовал бизнес, другие мы стараемся не менять никогда, потому что это наш контракт с внешними системами, и он должен меняться никогда.
2454.60 2461.60 "Анатолий Кулаков" Так как это у них разные жизненные циклы, то имеет большой смысл именно разделять две эти концепции.
2461.60 2465.60 "Анатолий Кулаков" Вот теоретически выделяются они именно так.
2465.60 2476.60 "Анатолий Кулаков" Как эти выделения будут реализованы на практике, и к чему это приведет непосредственно в коде, мы с вами посмотрим в следующей статье и в следующем, наверное, выпуске нашего подкаста.
2476.60 2493.60 "Анатолий Кулаков" Опять же, если тема вам понравилась, то напишите нам как-нибудь в YouTube, например, в комментарии, чтобы мы продолжали больше разбирать таких архитектурных вещей, потому что на слух кажется, что они не очень хорошо звучат, может быть, их лучше читать, смотреть, картинки и так далее.
2493.60 2496.60 "Анатолий Кулаков" Поэтому, если вам интересно, напишите, лайкните, репостните.
2496.60 2509.60 "Анатолий Кулаков" Если наберется достаточное количество заинтересованных слушателей, то в следующем выпуске мы как раз-таки обсудим на конкретных примерах различия между бизнес-правилами и валидацией.
2509.60 2513.60 "Игорь Лабутин" Это точно один лайк от меня, потому что пока я не очень понимаю.
2513.60 2521.60 "Игорь Лабутин" Ну, как бы, да, хорошо, одно - контракт, другое - бизнес-правила, но клиент, у него все равно запрос перестанет работать от того, что ты поменял бизнес-правила.
2521.60 2531.60 "Игорь Лабутин" Понятно, что он перестанет работать чуть по-другому, и, может быть, вернет бизнес-ошибку, вместо того, чтобы свалиться со словами "Я тут строчку жду, а ты число посылаешь".
2531.60 2535.60 "Игорь Лабутин" Но еще до акта. Не знаю, пока очень туманная тема.
2535.60 2538.60 "Анатолий Кулаков" Видишь, первый шаг - это для того, чтобы ты признал проблему.
2538.60 2544.60 "Анатолий Кулаков" То есть здесь первый шаг Марк делает для того, чтобы мы четко понимали, что есть две разные части.
2544.60 2549.60 "Анатолий Кулаков" Он очень много сил положил на то, чтобы их разделить и описать свойства двух этих частей.
2549.60 2555.60 "Анатолий Кулаков" Как только мы смиряемся с тем, что это две разные части, у них два разных свойства, тогда уже можно с ними работать дальше.
2555.60 2557.60 "Анатолий Кулаков" Потому что многие их просто смешивают.
2557.60 2559.60 "Анатолий Кулаков" Это самая первая, самая глобальная, самая большая ошибка.
2559.60 2565.60 "Анатолий Кулаков" Люди смешивают бизнес-правила и валидации в одну кучу и не делают никаких различий.
2565.60 2568.60 "Игорь Лабутин" Ну, хорошо, действительно ждем тогда следующей статьи.
2568.60 2573.60 "Игорь Лабутин" Посмотрим более детально на практических примерах, и, возможно, станет более понятно.
2573.60 2583.60 "Игорь Лабутин" Мы пойдем дальше, обратно в технические темы и в .NET, потому что у нас есть статья от Эндрю Лока, как раз про интерсепторы.
2583.60 2587.60 "Игорь Лабутин" Я обещал, что мы немножко к ним вернемся, и мы таки к ним возвращаемся.
2587.60 2592.60 "Анатолий Кулаков" Ну, надо, надо, потому что осталось какой-то осадочек, что это какая-то ненужная, недоделанная фича.
2592.60 2597.60 "Анатолий Кулаков" Надо все-таки разобраться, зачем они нужны, и почему именно в таком виде, и что у нас идет в будущем.
2597.60 2600.60 "Игорь Лабутин" Почему именно в таком виде - это прям сложный вопрос.
2600.60 2602.60 "Игорь Лабутин" Почему сделали именно так?
2602.60 2605.60 "Игорь Лабутин" Мы, наверное, не будем сильно обсуждать.
2605.60 2608.60 "Игорь Лабутин" Ну, хотя бы примеры, как использовать, для чего нужны.
2608.60 2610.60 "Игорь Лабутин" Про примеры как раз расскажу.
2610.60 2613.60 "Игорь Лабутин" Напомню сначала, зачем вообще, точнее, что это за фича.
2613.60 2627.60 "Игорь Лабутин" Она позволяет вам, по сути, заменить в момент compile time вызов одного метода на вызов другого метода прям вот без вариантов, без каких-либо условий, без всего, просто заменить.
2627.60 2629.60 "Игорь Лабутин" Зачем это, может быть, надо?
2629.60 2631.60 "Игорь Лабутин" Основная причина - это, конечно, ahead-of-time compilation.
2631.60 2637.60 "Игорь Лабутин" То есть проблема заключается в том, что у нас есть некоторое количество разных бизнес...
2637.60 2649.60 "Игорь Лабутин" Ну, не то, что бизнес-правил, а логики, которые завязаны на reflection и на поведение какого-то возможности кодогенерации либо того самого reflection в runtime.
2649.60 2657.60 "Игорь Лабутин" А в native autosolutions, когда мы компилируем это все, на некоторых платформах далеко не все доступно.
2657.60 2671.60 "Игорь Лабутин" Вы не можете код генерить, вы не можете полноценно использовать вообще весь reflection, и поэтому части фреймворков, часть библиотек, например, ASP.NET, не очень хорошо работали с OAUT или вообще не работали.
2671.60 2683.60 "Игорь Лабутин" И основная цель, основное применение сейчас этих самых интерсепторов заключается в том, что нам нужно заменять текущие вызовы того, что вы пишете в коде, как пример.
2683.60 2690.60 "Игорь Лабутин" Если вы пишете на minimal API, вы вызываете, например, функцию метод расширения map_get.
2690.60 2695.60 "Игорь Лабутин" Для вашего маршрута указываете маршрут и лямбдочку, которую нужно выполнить.
2695.60 2723.60 "Игорь Лабутин" Все хорошо, но map_get - это штука, которая под собой имеет довольно много разной внутренней логики, потому что ей нужно сходить, ей нужно понять, какие-то метаданные у вас, чем размечены, посмотреть, чем лямбда размечена, какими атрибутами, с точки зрения return type, еще чего-то, собственных атрибутов, которые относятся к всяким from body и прочему.
2723.60 2732.60 "Игорь Лабутин" Нужно сообразить, что пришло во входе, что мы хотим - JSON, не JSON, XML, не XML с точки зрения кодировки.
2732.60 2740.60 "Игорь Лабутин" На основе этого создать нужные обертки вокруг вашей лямбды и уже вызвать вашу лямбду.
2740.60 2745.60 "Игорь Лабутин" Все это делается с помощью reflection, и в SnakyFaod это не очень дружит.
2745.60 2767.60 "Игорь Лабутин" Но если вы достаточно внимательно следили за 8.net, вы могли бы узнать, что уже есть source generator, который позволяет для minimal API генерить, так сказать, нужные методы статически, без reflection, и каким-то магическим образом все работает, даже без этих самых интерсепторов.
2767.60 2769.60 "Игорь Лабутин" Как же это было сделано?
2769.60 2771.60 "Игорь Лабутин" К этому мы вернемся чуть-чуть позднее.
2771.60 2773.60 "Игорь Лабутин" Как же сделать это без интерсептора?
2773.60 2780.60 "Игорь Лабутин" Сначала давайте еще чуть-чуть детально вспомним, как же технический интерсептор работает внутри.
2780.60 2784.60 "Игорь Лабутин" Во-первых, вам нужен attribute intercepts location.
2784.60 2793.60 "Игорь Лабутин" Нестранно, несмотря на то, что интерсепторы уже в превью, они есть в SDK, вы можете их включить, но вот этого attribute intercepts location его нет в BCL.
2793.60 2796.60 "Игорь Лабутин" Его нужно объявить самому.
2796.60 2797.60 "Игорь Лабутин" По крайней мере, пока.
2797.60 2800.60 "Игорь Лабутин" Может быть, скоро добавят стандартный, но пока его нет.
2800.60 2804.60 "Игорь Лабутин" И это должен быть attribute, у которого есть три параметра.
2804.60 2810.60 "Игорь Лабутин" Это путь к файлу, номер строчки и номер колонки в этой строчке.
2810.60 2815.60 "Игорь Лабутин" Дальше мы должны создать, собственно, класс интерсептора.
2815.60 2817.60 "Игорь Лабутин" Это статический класс.
2817.60 2825.60 "Игорь Лабутин" В нем нужно объявить метод, который полностью совпадает по сигнатуре с тем методом, который вы собираетесь замещать.
2825.60 2836.60 "Игорь Лабутин" То есть если вам нужно повторить и ретурн значения, и все аргументы обязательно, то есть они должны быть полностью соответствовать, прямо буквально, побуквенно, потому что иначе компилятор скажет "не могу".
2836.60 2839.60 "Игорь Лабутин" Компилятор в этом смысле доработан хорошо.
2839.60 2845.60 "Игорь Лабутин" Он не будет пытаться вызвать якобы метод, хотя там ничего не совместимо, он аккуратно кинет ошибку компиляции.
2845.60 2858.60 "Игорь Лабутин" И после чего вы этот метод, который вы написали в этом статическом классе, декорируете тем самым attribute intercepts location и указываете location в ваших исходных кодах, что же нужно подвинуть.
2858.60 2866.60 "Игорь Лабутин" То есть буквально в файле или программ.cs замени, пожалуйста, вызов map.get на пятой строчке в 20-й колонке.
2866.60 2869.60 "Игорь Лабутин" Вот ровно прям таким образом пишите.
2869.60 2872.60 "Анатолий Кулаков" Очень низкого уровня, прямо ассимулятор вспоминается.
2872.60 2883.60 "Игорь Лабутин" Да. Казалось бы, это очень неудобно, но с другой стороны, предполагается, что эти самые интерсепторы вы не будете писать руками, а они будут генериться source-генератором.
2883.60 2890.60 "Игорь Лабутин" И тогда понятно, что source-генератор имеет нормальный доступ к вашим исходникам с учетом того, как оно расположено в файле.
2890.60 2893.60 "Игорь Лабутин" И при изменении файлов вы можете...
2893.60 2903.60 "Игорь Лабутин" source-генератор при сборке будет вызван заново, и он поймет новое значение положения ваших функций, которые нужно заинтерсептить, и обновить соответствующие атрибуты.
2903.60 2908.60 "Анатолий Кулаков" Ой, зная находчивость наших программистов, я уверен, что они будут писаться не только из source-генераторов.
2908.60 2909.60 "Анатолий Кулаков" Понятно.
2909.60 2917.60 "Анатолий Кулаков" Никто не побрезгует указать и абсолютные пути на своем диске, и строчку, и колонку, прямо независимо от форматирования, все это будут указывать ручками.
2917.60 2921.60 "Анатолий Кулаков" А потом удивляться, почему у нас все сломалось, как только мы отрефакторили наш код.
2921.60 2924.60 "Игорь Лабутин" Да ладно, отрефакторили, интернажал не в том месте, все.
2924.60 2931.60 "Анатолий Кулаков" Ну да, как только у решапера вышло новое правило форматирования, которое делает лишний пробельщик, то ваш интерсептор сломался.
2931.60 2936.60 "Игорь Лабутин" Все так. Но, по крайней мере, исходная идея была в том, что они генерятся source-генераторами.
2936.60 2959.60 "Игорь Лабутин" Давайте теперь посмотрим на тот самый minimal API source-генератор, который... у Andrew Locke на самом деле есть отдельная статья, предыдущая часть, где описывается детально, как работает minimal API source-генератор, она очень технически детальная, там как раз описывается, как же все эти тонкости создания метаданных и прочих хендлеров и делегатов происходят внутри.
2959.60 2961.60 "Игорь Лабутин" Но кратенько я постараюсь все здесь объяснить.
2961.60 2962.60 "Игорь Лабутин" Проблема первая.
2962.60 2975.60 "Игорь Лабутин" Вот вы написали в своем коде, в программ.cs, что-то там, ваш builder.map.get от какой-то строчки маршрута, запятая, лямбда, что нужно сделать, когда по этому маршруту кто-то придет.
2975.60 2977.60 "Игорь Лабутин" Возникает вопрос.
2977.60 2999.60 "Игорь Лабутин" Если... map.get, напоминаю, что это extension метод, стандартный, поставляемый ASP.NET Core, и теперь мы хотим сделать source-генерированную версию этого метода, чтобы компилятор вызвал... ну или runtime, в результате, в основном компилятор, вызвал именно нашу source-генерированную версию, при том, что extension метод все еще находится в скоупе.
2999.60 3001.60 "Игорь Лабутин" Это прям непростая задача.
3001.60 3011.60 "Игорь Лабутин" К счастью, в стандартном extension методе ASP.NET у метода map.get сигнатура заключается в том, что...
3011.60 3019.60 "Игорь Лабутин" ну там, понятно, есть this, первым параметром, поскольку это extension метод, потом есть string на маршрут, а потом есть делегат, который нужно выполнить.
3019.60 3028.60 "Игорь Лабутин" Так вот делегат, там аргументом, вида типа делегат, у нас есть такой тип system.delegate, вот он как раз там, в качестве аргумента.
3028.60 3043.60 "Игорь Лабутин" И ребята, которые писали minimal.API.source.Generator в Microsoft, они использовали, ну такой, это прям хитрый трюк, который можно использовать, по сути, только один раз, потому что дальше уже нету более специфичных типов.
3043.60 3052.60 "Игорь Лабутин" Они сказали, у нас есть правило разрешения перегрузок, то есть если у вас есть несколько подходящих методов, компилятор будет выбирать наиболее подходящий.
3052.60 3064.60 "Игорь Лабутин" Поэтому source-генерированная версия использует сигнатуру не вида string, делегат, а string, фанк, от того типа, который вы возвращаете из вашего API.
3064.60 3066.60 "Игорь Лабутин" Ну, это как-то совсем некрасиво.
3066.60 3067.60 "Игорь Лабутин" Фанк, стринг и так далее.
3067.60 3080.60 "Игорь Лабутин" В итоге, поскольку это source-генератор, он в моменте выполнения знает, что вы точно оттуда возвращаете, он может все проанализировать, изгенерить нужный фанк, а компилятор при вызове точно будет вызывать fang string.
3080.60 3089.60 "Игорь Лабутин" Но точно со звездочкой там есть способы сделать еще более специфичную версию, как пишут в статье, но я уже там не сильно закапывался в эти детали.
3089.60 3094.60 "Игорь Лабутин" Но на самом деле да, это построено на таком очень шатком фундаменте.
3094.60 3100.60 "Игорь Лабутин" И именно поэтому, собственно, началась тема с интерсепторами и всем добром.
3100.60 3101.60 "Игорь Лабутин" Есть еще один момент.
3101.60 3106.60 "Игорь Лабутин" Ну, допустим, мы сделали вот этот вот самый fang-от-string.
3106.60 3112.60 "Игорь Лабутин" Мы смогли сделать так, что map-get вызовется из нашего source-генерированного кода.
3112.60 3113.60 "Игорь Лабутин" Вопрос.
3113.60 3115.60 "Игорь Лабутин" А как нам понять?
3115.60 3125.60 "Игорь Лабутин" Мы же не знаем, по большому счету, внутри метода, в каком контексте его вызвали снаружи.
3125.60 3135.60 "Игорь Лабутин" То есть мы не получаем довольно много информации из-за того, что это fang-string, из-за того, что это не полноценный метод, который имеет доступ к reflection.
3135.60 3138.60 "Игорь Лабутин" В смысле, метод это полноценный, потому что он к reflection доступ не имеет.
3138.60 3151.60 "Игорь Лабутин" Поэтому из-за тонкости того, как могут вызываться эти map-get, результирующая функция, которая source-генерировалась, она на самом деле имела еще два параметра.
3151.60 3162.60 "Игорь Лабутин" Она имела string-овый параметр color_filepath, аннотированный атрибутиком color_filepath, и, соответственно, int-овый параметр color_line_number, аннотированный атрибутом color_line_number.
3162.60 3173.60 "Игорь Лабутин" В итоге в source-генерированной версии прилетал ваш маршрут, прилетала ваша лямбда, и прилетало два параметра под названием "откуда вас вызвали" — в компиляторах автоматически выставляет.
3173.60 3189.60 "Игорь Лабутин" После чего этот самый filepath и line_number использовались в качестве ключа словаря, который имел в качестве значения source-генерированный вариант хендлеров, который собирал всю нужную метаданную, вот это все, и вызывал фактически вашу лямбду.
3189.60 3191.60 "Игорь Лабутин" Ну да, чтобы однозначно определить,
3191.60 3197.60 "Анатолий Кулаков" а именно откуда нас вызвали, сделать и выдать именно тот код, который нужен для конкретного места.
3197.60 3214.60 "Игорь Лабутин" Да. И вот тут, во-первых, технически это не факт, что прям медленнее reflection, но все-таки не очень здорово, потому что, во-первых, передается некоторая дополнительная информация, во-вторых, есть lookup в словарик, в-третьих, есть расход накладной по памяти на этот самый словарик.
3214.60 3221.60 "Игорь Лабутин" Понятно, что endpoints там не миллионы, и словарик, скорее всего, маленький, но все-таки некоторый dictionary lookup есть.
3221.60 3235.60 "Игорь Лабутин" Но интерсепторы позволяют сделать это на уровне прям момент компиляции, то есть по сути мы как раз это и делаем, мы берем, указываем file path line number, ну там еще колоночку, да, и говорим, вот в этом месте замени.
3235.60 3257.60 "Игорь Лабутин" И тогда в момент компиляции source generator может как раз-таки правильно подставить нужные атрибутики в интерсептнутую версию, указать нужный файл, файл нейм, line number и column number, и интерсептор заменит вызов map.get ровно на нужную версию без необходимости дополнительных аргументов.
3257.60 3267.60 "Игорь Лабутин" Можно принимать теперь не функцию от чего-нибудь, а прям делегат, точнее не можно, а нужно, потому что иначе интерсептор не сработает, и сигнатура, напоминаю, должна полностью совпадать.
3267.60 3274.60 "Игорь Лабутин" И убираем lookup, убираем доступ к, ну, наличию словаря в памяти.
3274.60 3282.60 "Игорь Лабутин" То есть по сути это некоторая замена, такая compile time замена словаря в рантайме, по большому счету.
3282.60 3292.60 "Игорь Лабутин" Вы просто статически строите словарь, где, вы говорите, ключиками являются вот эти атрибуты, можно сказать, да, intercepts, location, значениями те методы, на которых они навешаны.
3292.60 3296.60 "Игорь Лабутин" А компилятор в нужный момент сам все подставит как надо.
3296.60 3298.60 "Игорь Лабутин" Вот такая вот штука.
3298.60 3311.60 "Игорь Лабутин" То есть это позволяет избежать необходимости использовать всякие странные трюки с компилятором из-за того, что мы знаем, что какие-то методы выбираются первыми в момент разрешения зависимости.
3311.60 3317.60 "Игорь Лабутин" Но это не гарантированно, это не точно, поэтому лучше все-таки без таких трюков уходиться.
3317.60 3320.60 "Анатолий Кулаков" Ну да, достаточно грязное решение, хорошо, что убрали.
3320.60 3324.60 "Игорь Лабутин" Ну и плюс тут повезло, что исходного из панете был делегаты.
3324.60 3326.60 "Игорь Лабутин" Да, это тоже случайность практически.
3326.60 3334.60 "Игорь Лабутин" Но это не случайность, потому что мы не можем на самом деле объявить, как ты объявишь func неизвестного типа, ты же не знаешь, сколько аргументов принимается у лямбды.
3334.60 3340.60 "Анатолий Кулаков" Потому что там очень много было делегатов с различными параметрами, с различными output-тайпами, то есть там ассигнатура абсолютно непредсказуемая была.
3340.60 3342.60 "Анатолий Кулаков" Да, source-генератор может их сгенерить
3342.60 3346.60 "Игорь Лабутин" в момент компиляции, а все-таки extension-метод написать невозможно.
3346.60 3352.60 "Анатолий Кулаков" Ну я имею в виду, что люди, которые писали вот этот делегат, они не думали о том, чтобы его можно было переопределить.
3352.60 3354.60 "Анатолий Кулаков" Случайность именно в этом заключается.
3354.60 3361.60 "Анатолий Кулаков" Они могли бы это сделать через, не знаю, через что, но через что-нибудь другое, и тогда бы были руки связаны у современных парней.
3361.60 3365.60 "Игорь Лабутин" Но дальше возникает вопрос интересный следующий.
3365.60 3371.60 "Игорь Лабутин" Andrew Law, когда написал эту статью, говорит, ну круто, да, вот как бы смотрите, как круто теперь работает minimal API source-gen.
3371.60 3374.60 "Игорь Лабутин" Ну короче, теперь прямо из словариков нету и все такое.
3374.60 3383.60 "Игорь Лабутин" Но ведь проблема-то в том, что интерсепторы, они же в превью-версии только, в восьмом тотнете.
3383.60 3394.60 "Игорь Лабутин" И поэтому, мол, ну это все, конечно, хорошо, я вот вам все это рассказал, но в релизе, наверное, все-таки будет опять версия со словариками, ну потому что, ну а как, превью все-таки ведь тогда.
3394.60 3412.60 "Игорь Лабутин" И тогда, и в титре такой написал, значит, на что ему ответил один из менеджеров, я так понимаю, как раз команды Рослина вроде как, я сейчас не помню кто точно, но смысл в том, что кто-то из команды Рослина, который всем этим занимается, который сказал, не я, ну все будет не так, смотрите.
3412.60 3414.60 "Игорь Лабутин" Интерсепторы, они в превью.
3414.60 3425.60 "Игорь Лабутин" Для того, чтобы их использовать в вашем коде, вы должны в CS Project обязательно включить флажок специальный, там интерсепторы в превью, вот это все, заенейблить, без этого не заработает.
3425.60 3432.60 "Игорь Лабутин" Но, минимал API Source Generator будет использовать интерсепторы в продакшене, в восьмом тотнете.
3432.60 3434.60 "Анатолий Кулаков" Интересно, то есть превью, оно больше не превью?
3434.60 3440.60 "Игорь Лабутин" Нет, оно превью, если ты хочешь использовать в своем коде, включай флажок превью.
3440.60 3444.60 "Игорь Лабутин" А если ты просто используешь минимал API Source Gen, то превью тебе включать не надо.
3444.60 3449.60 "Анатолий Кулаков" Не, ну подожди, превью и фича флаг, это абсолютно разные вещи.
3449.60 3455.60 "Анатолий Кулаков" Превью заключается в основном в том, что это нестабильный код, который может падать как угодно, и контракт его может меняться когда угодно, вот это превью.
3455.60 3466.60 "Анатолий Кулаков" И вот судя, если исходить из этого определения, то даже если его Microsoft сам использует в продакшене, у тебя это опять же получается нестабильный код, который может падать когда угодно.
3466.60 3468.60 "Игорь Лабутин" Как-то не стыкуется.
3468.60 3487.60 "Игорь Лабутин" Да, он может падать когда угодно, но поскольку единственный пользователь этого кода это Microsoft в виде минимал API Source Gen, в смысле, что если ты сам реально не включил своим флажком у себя в CSS Project, то Microsoft обязуется, естественно, если они что-то сломают в интерсепторах, тут же сломать это, в смысле поправить минимал API Source Gen.
3487.60 3493.60 "Анатолий Кулаков" Ну опять же, тут же это как бы непростое моего миллионного сервиса, что значит тут же.
3493.60 3495.60 "Анатолий Кулаков" Ну тут же в смысле, я думаю, что они это,
3495.60 3502.60 "Игорь Лабутин" ну подожди, ты же не забираешь это все из GitHub, из мастера-брача, все-таки ты забираешь это из вышедших SDK.
3502.60 3511.60 "Анатолий Кулаков" Ну вот, в вышедшем SDK вот нашли баг, который роняет при определенном запросе, при определенном HTTP сформированном запросе роняет мой сервак.
3511.60 3512.60 "Анатолий Кулаков" Что мне делать?
3512.60 3514.60 "Игорь Лабутин" Ждать hotfix'а, что?
3514.60 3516.60 "Анатолий Кулаков" Да, да, да, да, все.
3516.60 3518.60 "Анатолий Кулаков" Как ждать, я не могу ждать, у меня там
3518.60 3523.60 "Игорь Лабутин" клиенты с мешком денег. Ты можешь выключить минимал API Source Gen и использовать не Source Gen версию.
3523.60 3526.60 "Игорь Лабутин" Но если у тебя найти фаот, вот это все, то работать не будет.
3526.60 3528.60 "Игорь Лабутин" Ну хорошо, хорошо.
3528.60 3530.60 "Игорь Лабутин" То есть в общем, ну такая как бы, да.
3530.60 3550.60 "Игорь Лабутин" Там есть, я ссылочку приведу в шоу-ноутах, можете почитать, там Эндрю тоже говорит, ну блин, это как-то странно, а не будет ли еще такого, что типа, если минимал API Source Gen включает эту штуку неявно, то это значит, что если у меня, например, есть в проекте интерсептор, я с ним там побаловался, но выключил фичу в CSS Proj, он не работает.
3550.60 3555.60 "Игорь Лабутин" И тут я завязал минимал API Source Gen, он неявно включил фичу, и у меня неявно включился мой Source Gen.
3555.60 3556.60 "Игорь Лабутин" Типа будет, не будет?
3556.60 3560.60 "Игорь Лабутин" Вроде как пришли к выводу, что не будет тогда включаться ваш Source Gen, ой, ваш интерсептор.
3560.60 3563.60 "Игорь Лабутин" Но, короче, там много толких моментов.
3563.60 3565.60 "Анатолий Кулаков" Осадочек остался, да.
3565.60 3567.60 "Игорь Лабутин" Да, почитайте твиттер, там интересная дискуссия.
3567.60 3568.60 "Игорь Лабутин" Небольшой тренд.
3568.60 3571.60 "Анатолий Кулаков" Ну, в общем, да, мне кажется, нужно каких-то два разных слова внедрять.
3571.60 3577.60 "Анатолий Кулаков" Preview - это то, что нестабильное какое-нибудь, и FichuFlag - это то, что по дефолту выключено, вот как-нибудь так идти.
3577.60 3581.60 "Анатолий Кулаков" Потому что они сейчас смешали две этих концепции, и возникает больше вопросов, чем ответов.
3581.60 3582.60 "Игорь Лабутин" Ну в общем, вот.
3582.60 3587.60 "Игорь Лабутин" Тем не менее, штука есть, она выглядит действительно вот именно в контексте такого.
3587.60 3589.60 "Игорь Лабутин" И такой замены вполне полезный.
3589.60 3592.60 "Игорь Лабутин" Понятно, зачем оно сделано, понятно, как.
3592.60 3606.60 "Игорь Лабутин" Но оно явно оставлено в превью, потому что кажется, что действительно за пределами Source Generator, те, которых имеет точный доступ, информация о том, где у вас какие файлики расположены, тяжело будет использовать эту штуку.
3606.60 3607.60 "Анатолий Кулаков" Ну так я все еще не понял.
3607.60 3610.60 "Анатолий Кулаков" У меня есть Source Generator, и я хочу ее там использовать.
3610.60 3611.60 "Анатолий Кулаков" Почему она все-таки в превью?
3611.60 3612.60 "Анатолий Кулаков" Ее почему оставили в превью?
3612.60 3615.60 "Анатолий Кулаков" Она действительно нестабильная, она будет меняться или зачем?
3615.60 3619.60 "Игорь Лабутин" Я думаю, что они посмотрят, как оно будет, и может быть будут его менять.
3619.60 3627.60 "Игорь Лабутин" То есть скорее всего, она достаточно стабильна для использования сейчас, но они не хотят, как только они скажут, что все это паблик, они обязаны это поддерживать годы.
3627.60 3632.60 "Анатолий Кулаков" Да, да, это действительно так, но опять же, чувствуется какая-то смешень концепции.
3632.60 3639.60 "Анатолий Кулаков" Если это все стабильно работает, и как они запланировали, сделала хорошо, настолько, что они сами в своем продакшн коде рекомендуют это все.
3639.60 3641.60 "Анатолий Кулаков" Ну не рекомендуют, а используют это все.
3641.60 3646.60 "Анатолий Кулаков" То почему не разрешают другим пользователям также точно честно и открыто использовать?
3646.60 3649.60 "Анатолий Кулаков" То есть снимут флажок превью.
3649.60 3651.60 "Анатолий Кулаков" Странно, странно.
3651.60 3653.60 "Анатолий Кулаков" Ну ладно, посмотрим.
3653.60 3662.60 "Игорь Лабутин" Да, и Эндрю завершает статью с словами, что вообще метод хорош, все круто, замечательно, но все-таки есть гора ограничений.
3662.60 3666.60 "Игорь Лабутин" Во-первых, вы так можете интерсерсить только вызовы методов.
3666.60 3668.60 "Игорь Лабутин" Вы не можете подменять вызовы пропертей.
3668.60 3673.60 "Игорь Лабутин" Вы не можете, не знаю, подписки на ивенты, например, подменять или еще что-нибудь в таком духе.
3673.60 3675.60 "Игорь Лабутин" То есть только вызовы методов.
3675.60 3682.60 "Анатолий Кулаков" Ну кажется, что не так страшно, потому что все-таки основная цель должна быть именно методами, если ты хочешь заинтерсерить пропертей или еще что-то.
3682.60 3683.60 "Анатолий Кулаков" Тем не менее, нужно понимать,
3683.60 3686.60 "Игорь Лабутин" что это все-таки ограниченное решение. Второе.
3686.60 3687.60 "Игорь Лабутин" Да.
3687.60 3690.60 "Игорь Лабутин" Метод должен полностью совпадать по сигнатуре.
3690.60 3692.60 "Игорь Лабутин" Прямо вот, тут компенсатор поможет.
3692.60 3693.60 "Игорь Лабутин" Почему это плохо?
3693.60 3702.60 "Игорь Лабутин" Ну это типа ограничение, по его мнению, что если ты как бы меняешь что-то где-то, то, ну понятно, что да, иначе непонятно как.
3702.60 3711.60 "Игорь Лабутин" То есть как он пишет, типа могло бы быть так, что там по совместимым типам еще что-то куда-то, ну не знаю, ты там int на long заменил, ну как бы у тебя...
3711.60 3713.60 "Игорь Лабутин" Ты не можешь...
3713.60 3714.60 "Игорь Лабутин" Сейчас, смотри.
3714.60 3723.60 "Игорь Лабутин" У тебя есть, например, метод, который ты хочешь интерсептить, и у тебя есть два его варианта, с int, с long, да, в смысле два разных метода, которые ты хочешь интерсептировать.
3723.60 3725.60 "Игорь Лабутин" Ты интерсептишь одним сразу с long.
3725.60 3729.60 "Игорь Лабутин" Ну типа вроде оба влезают, должно бы влезать, но...
3729.60 3730.60 "Анатолий Кулаков" Да, ну это опять же...
3730.60 3732.60 "Анатолий Кулаков" Ну это такая микроавтомизация, да.
3732.60 3740.60 "Анатолий Кулаков" Да, с учетом того, что ты делаешь из source генераторов, тебе лишний раз на генерить 10 методов, как бы никаких проблем нет, который отличается просто int и long.
3740.60 3744.60 "Анатолий Кулаков" Ну то есть мне кажется, это хорошее ограничение, наоборот, оно дает меньший простор для ошибок.
3744.60 3745.60 "Анатолий Кулаков" Отлично.
3745.60 3746.60 "Игорь Лабутин" Следующее ограничение.
3746.60 3750.60 "Игорь Лабутин" Вы можете интерсептировать методы только в коде, который компилируется.
3750.60 3753.60 "Игорь Лабутин" То есть нельзя в библиотеках.
3753.60 3762.60 "Анатолий Кулаков" Да, это, наверное, они застраховались от того, чтобы как раз не прийти в тот ад, когда ты понятия не имеешь, кто откуда что вызывается.
3762.60 3766.60 "Анатолий Кулаков" Ты теперь хотя бы в том аду, когда ты понимаешь, что только твой код может измениться.
3766.60 3770.60 "Анатолий Кулаков" А вот какой-нибудь system.date.time ты уже не поменяешь таким образом.
3770.60 3782.60 "Игорь Лабутин" Это правда, но с другой стороны, есть неудобства, например, он приводит в статье такую штуку, например, во многих компаниях есть какой-нибудь стандартный NuGet, который, например, добавляет какие-нибудь стандартные health-чеки, health-endpoint в ваш SPNet.
3782.60 3785.60 "Игорь Лабутин" Там как раз будет тот же самый MapGet.
3785.60 3792.60 "Игорь Лабутин" То есть там extension method с каким-нибудь minimal API, там типа MapGet.to, MapGet.се, и вот в них тоже MapGet не подменится.
3792.60 3794.60 "Анатолий Кулаков" Да, действительно.
3794.60 3799.60 "Анатолий Кулаков" Наверное, ничего не мешает тебе вот эту стандартную библиотечку откомпилить с уже подменой.
3799.60 3804.60 "Игорь Лабутин" Ну вот там возникают тонкости, что ее как бы надо с одной стороны с sourcegen-ом откомпилить.
3804.60 3810.60 "Игорь Лабутин" Ну, в общем, там как бы есть ряд неудобств и тонкостей, но можно сделать, что заработает.
3810.60 3818.60 "Анатолий Кулаков" Может быть, это и хорошо, потому что ты не знаешь, вот эта библиотечка, она рассчитана на то, чтобы ее вот так вот заделать, или не рассчитана, может, у нее там какой-то лютый reflection внутри идет.
3818.60 3819.60 "Игорь Лабутин" Все так, все так.
3819.60 3828.60 "Игорь Лабутин" Дальше, ну он тоже не очень понял следующего пункта в том смысле, что он пишет, ну это not full aspect-oriented programming solution.
3828.60 3834.60 "Игорь Лабутин" Ну, то есть это какое-то очень зачаточное состояние такого аспектно-ориентированного программирования, да, то есть это не в фоде.
3834.60 3842.60 "Анатолий Кулаков" Да, безусловно, ты не можешь там подменить абсолютно все, что угодно, на как угодно, переписать код, как бы загрузить из сторонней библиотеки, такой функциональности здесь нет.
3842.60 3850.60 "Анатолий Кулаков" Кажется, что именно этого и хочется, то есть не хочется уходить в постшарпы в ходе, потому что это страшно, это неконтролируемо, это безобразно.
3850.60 3857.60 "Анатолий Кулаков" То есть чем больше у нас будет ограничений, чем уже мы будем эту штуку использовать, тем лучше, ну и безусловно она нужна, тут никуда не денешься.
3857.60 3874.60 "Игорь Лабутин" Дальше, то, что ты говорил про пути и про то, что они могут приводить к проблемам, действительно так, Эндрю говорит, что у нас, например, иногда делается так, что мы в pull-requests включаем сгенерированный выхлоп генератора, source-gen.
3874.60 3875.60 "Игорь Лабутин" Для ускорения?
3875.60 3881.60 "Игорь Лабутин" Для, в том числе, во-первых, для нормального ревью, чтобы мы видели все, что поменялось, включая сгенерированный код.
3881.60 3883.60 "Игорь Лабутин" Ну это хорошо, да, в лой-ревью.
3883.60 3897.60 "Игорь Лабутин" Но как только ты это включил в pull-request, у тебя, если этот файлик собирается, ну, грубо говоря, он подтягивается именно в сборку, то он уже не соберется, ну, в смысле, нормально не запустится, потому что пути-то поменялись, у тебя на CI другие пути совсем.
3897.60 3898.60 "Игорь Лабутин" Да, конечно.
3898.60 3899.60 "Игорь Лабутин" Там вообще концовка может быть другая.
3899.60 3900.60 "Игорь Лабутин" Вот.
3900.60 3913.60 "Игорь Лабутин" И он говорит, что я знаю компании, где есть практика прям коммитить код выхлопа генератора, видимо, как раз для скорости, не знаю, либо для уверенности в том, что вот точно, ровно так, и понятно, что такое не заработает.
3913.60 3924.60 "Анатолий Кулаков" Ну видишь, с другой стороны, я бы сказал, что это очень плохая практика, потому что ты уже не уверен, какой код у тебя будет использоваться, тот, который ты закоммитил, или тот, который на тем сети перегенерировал вот эти билды.
3924.60 3925.60 "Анатолий Кулаков" Да, это правда.
3925.60 3937.60 "Анатолий Кулаков" И поэтому вот даже та же самая проблема с Т4 возникала, что ты залил один код, а потом интерпретатор Т4 вызвался, код тебе абсолютно поменял, и в продакшене работает совсем другой код.
3937.60 3939.60 "Анатолий Кулаков" То есть это хреновая практика, от которой надо отходить.
3939.60 3952.60 "Анатолий Кулаков" Я согласен, что очень удобно ревью делать, это прям вообще классная штука, но, наверное, каким-то другим образом эту штуку придется делать, то есть не включать это в файлики, как компилированную часть этого процесса.
3952.60 3954.60 "Анатолий Кулаков" Вот, и последний пункт это секьюр...
3954.60 3958.60 "Анатолий Кулаков" А, погоди, я тебе еще одно интересное минус добавлю предыдущего пункта.
3958.60 3974.60 "Анатолий Кулаков" У многих компаний есть встроенный форматор во время коммита, то есть все твои строчки, которые ты напишешь, ты делаешь git push, и в этот момент запускается .NET формат, и он переформатирует тебе абсолютно весь код, и, соответственно, в результате форматирования у тебя строчки легко могут сбиться.
3974.60 3975.60 "Анатолий Кулаков" Да.
3975.60 3979.60 "Анатолий Кулаков" Вот это тоже такая штука, которая может повлиять вот сюда.
3979.60 3982.60 "Игорь Лабутин" И тут нужно уже генератор запускать заново, по-любому.
3982.60 3983.60 "Игорь Лабутин" Да.
3983.60 4004.60 "Игорь Лабутин" И последнее это security concerns, про это, по-моему, все писали, когда вышла новость про интерсепторы, про то, что ну теперь вы можете вообще, вам может прилететь пакет, который там заменит вам все что угодно, на что Эндрю говорит, так он и сейчас может прилететь, как бы extension метод вам подсунут с помощью вот того самого трюка с чуть более точным соответствием параметров, и все, или еще что-нибудь.
4004.60 4008.60 "Игорь Лабутин" Поэтому как бы тут каких-то дополнительных security concerns вроде быть не должно.
4008.60 4010.60 "Игорь Лабутин" Сурс-генератор уже может сделать много чего.
4010.60 4014.60 "Анатолий Кулаков" Конечно, мы много раз поднимали тему security через nuget.
4014.60 4017.60 "Анатолий Кулаков" В наших подкастах поищите, если вдруг не слышали.
4017.60 4020.60 "Анатолий Кулаков" То есть любой пакет, который вы загружаете из nuget, это по сути экзешник.
4020.60 4024.60 "Анатолий Кулаков" И всегда рассчитывайте, что это экзешник с каким-нибудь вирусом.
4024.60 4031.60 "Анатолий Кулаков" Он может абсолютно сделать все что угодно на вашей системе, в том числе как бы и стереть диск, и повредить данные, и зашифровать весь ваш компьютер без особых усилий.
4031.60 4036.60 "Анатолий Кулаков" Поэтому вы должны четко доверять тому пакету, который ставите из интернета.
4036.60 4038.60 "Игорь Лабутин" В общем, вот такая история про интерсепторы.
4038.60 4041.60 "Игорь Лабутин" Посмотрим, как она проживет при Vue.
4041.60 4046.60 "Игорь Лабутин" Посмотрим, что в ней еще успеет поменяться до выхода релиза, и как оно будет дальше развиваться в 9-ом дотнете.
4046.60 4048.60 "Игорь Лабутин" А пока пойдем дальше.
4048.60 4049.60 "Анатолий Кулаков" Отлично.
4049.60 4055.60 "Анатолий Кулаков" Так, дальше я хотел вам рассказать про долгожданную штукенцию, которую наконец завезли в ReSharper.
4055.60 4062.60 "Анатолий Кулаков" И, ну, соответственно, скоро или уже в Rider, пока анонсов не было на момент выпуска подкаста.
4062.60 4069.60 "Анатолий Кулаков" И это замечательная штука, которая называется Accelerate your Testing Workflow with Vue.Need.Testing Creation and Navigation.
4069.60 4079.60 "Анатолий Кулаков" Улучшите ваш опыт использования тестов при навигации и создании с помощью нашего чудесного инструмента.
4079.60 4086.60 "Анатолий Кулаков" В чем же заключается такая штука, которая нам очень всем нужна, и которую мы долго ждали?
4086.60 4088.60 "Анатолий Кулаков" Прежде всего, это тема про Unittesting.
4088.60 4094.60 "Анатолий Кулаков" Unittesting - это прекрасная вещь, которая позволяет вам держать код актуальным, красивым, поддерживаемым, тестабильным.
4094.60 4100.60 "Анатолий Кулаков" И, в общем, мне кажется, уже давно во всех проектах принято как стандарт, что тесты обязаны быть.
4100.60 4104.60 "Анатолий Кулаков" В том или ином виде еще можно обсуждать, но они там должны быть.
4104.60 4106.60 "Анатолий Кулаков" Чем больше они там есть, тем лучше.
4106.60 4112.60 "Анатолий Кулаков" И мы очень часто для того, чтобы написать тесты, предпринимаем довольно-таки скучные и нудные действия.
4112.60 4117.60 "Анатолий Кулаков" Например, переключение между тестовым классом и production кодом.
4117.60 4126.60 "Анатолий Кулаков" То есть production кодом JetBrains называют код, который не тестовый, который настоящий, который запускается, непосредственно выполняет вашу логику.
4126.60 4132.60 "Анатолий Кулаков" Естественно, он может крутиться не только в продакшене, но более, наверное, близкого и понятного слова не нашлось.
4132.60 4141.60 "Анатолий Кулаков" Поэтому production код в данной статье - это тот код, который непосредственно выполняет всю логику, и тестовый код - это тот код, который тестирует вот эту логику production кода.
4141.60 4148.60 "Анатолий Кулаков" Итак, очень часто мы навигируемся между production кодом и тестовым кодом, пытаемся их каким-то образом вместе синхронизировать.
4148.60 4152.60 "Анатолий Кулаков" Если поменяли входные аргументы, то бежим в тест, там меняем входные аргументы.
4152.60 4156.60 "Анатолий Кулаков" Переименовали классик, бежим в тест, там переименовываем классик.
4156.60 4160.60 "Анатолий Кулаков" И вот много такой нудной работы, которая, казалось бы, должна быть автоматизирована.
4160.60 4175.60 "Анатолий Кулаков" И, кажется, это не только нам, это кажется всем людям вокруг уже довольно-таки давно, потому что соответствующая issue в репозитории ReSharper была создана в 2010 году.
4175.60 4178.60 "Анатолий Кулаков" Может, были и позднее, но указано именно это.
4178.60 4181.60 "Анатолий Кулаков" То есть, 2010 - это больше 13 лет.
4181.60 4198.60 "Анатолий Кулаков" Больше 13 лет мы ждали сего момента, и вот, наконец, наступил релиз 2023.2, в котором, наконец, сделали нативную, с точки зрения ReSharper, поддержку как раз навигации между тестами и production кодом.
4198.60 4200.60 "Анатолий Кулаков" Ну, и не только навигацию.
4200.60 4210.60 "Анатолий Кулаков" Нативную в том смысле, что до этого был плагин от Matios Kołdsch, который назывался TestLinker, и он как раз помогал навигироваться между тестовым кодом и production кодом.
4210.60 4218.60 "Анатолий Кулаков" Если вдруг вы почему-то не можете использовать ReSharper в последней версии, то в плагин, по-моему, вполне рабочий и может вам помочь.
4218.60 4223.60 "Анатолий Кулаков" Ну, а мы давайте непосредственно рассмотрим лучше, что же ReSharper теперь умеет делать.
4223.60 4225.60 "Анатолий Кулаков" Прежде всего, это навигация.
4225.60 4229.60 "Анатолий Кулаков" Та же самая, что я упомянул выше, между вашим production кодом и тестовым кодом.
4229.60 4236.60 "Анатолий Кулаков" Вы можете выбрать в меню Navigate To и занавигироваться или в production код, или в тестовый код.
4236.60 4243.60 "Анатолий Кулаков" Также у нас есть shortcut, который называется Ctrl+U+F, и который просто переключает вас.
4243.60 4248.60 "Анатолий Кулаков" Если вы находитесь в тестовом коде, он вас возвращает в production и с production в тестовый.
4248.60 4250.60 "Анатолий Кулаков" Все понятно.
4250.60 4261.60 "Анатолий Кулаков" Безусловно, прекрасно, что добавился новый экшен, который называется ReSharper GoToLinked Type Action, на который вы можете забиндить абсолютно все, что угодно, в том числе любой shortcut, который вам нравится.
4261.60 4276.60 "Анатолий Кулаков" И при переключении, естественно, сохраняется каретка ввода, что тоже, безусловно, удобно, потому что половину метода можете написать, переключиться, пописать эту половину метода там, вернуться и начать писать там же, где были до этого, что, безусловно, приятно.
4276.60 4282.60 "Анатолий Кулаков" Также данная фича позволяет создавать новые юнитесты.
4282.60 4294.60 "Анатолий Кулаков" Допустим, вы можете на вашем production коде жмакнуть менюшку Generate, вызвать оттуда юнитест, то есть генерировать юнитест, вам откроется специальное окошко, где вы можете ввести там опции.
4294.60 4303.60 "Анатолий Кулаков" Если у вас вдруг не было проекта с тестами, он вам создастся, автоматически поставятся все нугет-пакеты, которые нужны для запуска этих тестов.
4303.60 4306.60 "Анатолий Кулаков" У вас спросится там фреймворк, у вас спросится имя проекта.
4306.60 4313.60 "Анатолий Кулаков" В этом диалогом окошке все будет четенько и красивенько, и соответствующий тест добавится в новосознанный проект.
4313.60 4320.60 "Анатолий Кулаков" Если уже проект был или тестовый классик уже был, то просто молча новый тест добавится к данному классику.
4320.60 4325.60 "Анатолий Кулаков" Еще одна потрясающая фича - это синхронное переименование.
4325.60 4332.60 "Анатолий Кулаков" То есть, когда вы переименовываете ваш production класс, очень легко можно забыть переименовать тестовый класс.
4332.60 4347.60 "Анатолий Кулаков" И всегда это довольно сильно раздражает, когда ты в процессе рефакторинга сделал какие-то красивые имена для своих production проектов, для production классиков, а вот тестовый забыл, и они там находятся с непонятным именем, с непонятным namespace и с непонятными методами.
4347.60 4360.60 "Анатолий Кулаков" В общем, теперь этой проблеме должен прийти конец, потому что когда вы запускаете стандартный рефакторинг решапера на rename, решапер прекрасно знает о связанных классах и может тестовый класс таким же точным образом переименовать в соответствующий.
4360.60 4373.60 "Анатолий Кулаков" Я не нашел информации о namespace, было бы еще прекрасно, если бы move класса в другую папочку, допустим, в соседнюю, точно так же перемещал и в соответствующем namespace и в тестовый класс.
4373.60 4384.60 "Анатолий Кулаков" Кажется, что это уже, наверное, слишком большие фантазии на какое-то большое будущее, но вдруг, если несложно добавить, может быть, дождемся и такого счастья.
4384.60 4394.60 "Анатолий Кулаков" То есть хотелось бы, чтобы namespace тоже синхронизировались и тестики перемещались сами в соответствующие папочки, чтобы было понятно, где их искать и как их искать, даже тем, у кого нет подобной навигации.
4394.60 4401.60 "Анатолий Кулаков" И потрясающим элементом данного нововведения являются настройки.
4401.60 4405.60 "Анатолий Кулаков" Соответственно, как мы навигируемся на тестовый класс.
4405.60 4415.60 "Анатолий Кулаков" Если вам кажется, что найти тестовый класс – это простая задача, то это не так, потому что в мире существует очень много подходов, каким образом именовать тесты, складывать тесты, делать тесты.
4415.60 4421.60 "Анатолий Кулаков" И, к сожалению, в нашей индустрии нет какой-то единой спецификации, которая бы всех подставила под одну гребенку.
4421.60 4423.60 "Анатолий Кулаков" Может, к счастью.
4423.60 4427.60 "Анатолий Кулаков" Есть какие-то более или менее стандартные вещи, и их тоже несколько.
4427.60 4429.60 "Анатолий Кулаков" Давайте рассмотрим несколько подходов.
4429.60 4430.60 "Анатолий Кулаков" Например, именование.
4430.60 4432.60 "Анатолий Кулаков" Можно класс назвать...
4432.60 4438.60 "Анатолий Кулаков" Если мы тестируем класс «Калькулятор», мы можем назвать класс «Тест-калькулятор», можно назвать «Калькулятор-тест».
4438.60 4442.60 "Анатолий Кулаков" Или же, наоборот, «Калькулятор-спек» есть у нас и такой подход.
4442.60 4449.60 "Анатолий Кулаков" Поэтому однозначно определить, кто из них тесты, может быть, так сходу и не получится.
4449.60 4453.60 "Анатолий Кулаков" Также можно определять с помощью...
4453.60 4459.60 "Анатолий Кулаков" То есть не определять, а можно называть классы, помечать классы с помощью специальных атрибутов.
4459.60 4466.60 "Анатолий Кулаков" Есть атрибут «Subject», у которого в качестве type of'а указывается тот класс, который мы тестируем.
4466.60 4476.60 "Анатолий Кулаков" Или можно пронаследоваться от generic класса, например, «TestBase», у которого в generic параметрах будет указан тот тип, который мы тестируем, например, «Калькулятор».
4476.60 4490.60 "Анатолий Кулаков" И на страничке опций как раз «Тест линкера» можно выбрать, каким же образом вы хотите помечать ваши новые тесты, или каким образом, наверное, линкеру необходимо будет искать эти тесты.
4490.60 4493.60 "Анатолий Кулаков" Он, скорее всего, будет искать по всем возможным параметрам.
4493.60 4495.60 "Анатолий Кулаков" И есть несколько способов.
4495.60 4500.60 "Анатолий Кулаков" Во-первых, самый простой, самый примитивный - это по naming convention.
4500.60 4507.60 "Анатолий Кулаков" Если у вас класс называется «Калькулятор» и тестовый класс называется «Калькулятор-тест», то все прекрасно.
4507.60 4511.60 "Анатолий Кулаков" Решапер сможет их найти без проблем по вот этому суффиксу.
4511.60 4514.60 "Анатолий Кулаков" И вот эти суффиксы, их можно вводить руками.
4514.60 4521.60 "Анатолий Кулаков" Стандартные уже есть суффиксы «тест», «спек», «спекс», «тестс» и прочие вот такие вот загогулины.
4521.60 4523.60 "Анатолий Кулаков" В общем, они уже известны, решапер их уже будет искать.
4523.60 4525.60 "Анатолий Кулаков" Здесь вам ничего делать не нужно.
4525.60 4548.60 "Анатолий Кулаков" Если вдруг вы от этой концепции по какой-то причине отходите, то от суффиксов и префиксов, например, это часто делают в интеграционных тестах, когда вы тестируете не какой-то один классик, а тестируете целый какой-нибудь сценарий или какой-нибудь модуль, или еще что-нибудь, где невозможно выделить конкретно одного классика, но навигироваться почему-то по нему очень хочется.
4548.60 4552.60 "Анатолий Кулаков" Тогда мы можем применять подход с атрибутами, которые я писал выше.
4552.60 4560.60 "Анатолий Кулаков" Например, есть стандартный теперь атрибут JetBrains Annotations, новенький, который называется «тестсабджект» атрибут.
4560.60 4570.60 "Анатолий Кулаков" И в NUnity, допустим, есть «тестоф» атрибут, который делает примерно то же самое, и решапер умеет понимать оба, естественно, из них.
4570.60 4583.60 "Анатолий Кулаков" Генерика аргументом, можно еще указать, какой класс, какой таргет мы тестируем, то есть, как я уже говорил, наследуемся от специального классика «тестбэйс», и в качестве генерика аргумента передаем таргет, то есть калькулятор, кого мы хотим тестировать.
4583.60 4594.60 "Анатолий Кулаков" Этот генерик класс тоже необходимо пометить специальным атрибутом, который называется «минстестсабджект» атрибут, и он тоже включен в новый пакет JetBrains Annotations.
4594.60 4605.60 "Анатолий Кулаков" С помощью таких вот атрибутов вы вполне можете и свою какую-то систему нагородить, и сделать нативную поддержку в решапере, и он сможет навигироваться туда-сюда, создавать классики и прочее-прочее.
4605.60 4614.60 "Анатолий Кулаков" То есть эта система намного гибче, чем просто какие-то хардкоды, вбитые уже авторами в этот плагин, что тоже не может не радовать.
4614.60 4615.60 "Анатолий Кулаков" Это прекрасно.
4615.60 4627.60 "Анатолий Кулаков" Вот такой вот долгожданный инструмент мы дождались, напомню, 13 лет ждали, поэтому всем счастья, всем пользуйтесь, всем навигируйтесь, не тратьте время на кликание мышками, или control-табами, или еще какие-то дурацкие поиски.
4627.60 4631.60 "Анатолий Кулаков" Все должно быть одним сочетанием, четко и красиво.
4631.60 4634.60 "Игорь Лабутин" Да, звучит удобно, надо будет попробовать на самом деле.
4634.60 4641.60 "Игорь Лабутин" Мне кажется, что в идее и в Java это было довольно давно, но вот спасибо, что наконец дошло до .NET.
4641.60 4643.60 "Игорь Лабутин" Пойдем на последнюю тему.
4643.60 4649.60 "Игорь Лабутин" Это кратко о разном, наша стандартная рубрика с кучей всяких мелких новостей.
4649.60 4656.60 "Игорь Лабутин" Тут я быстренько пробегусь по тем ссылкам, которые мне показались интересными, возможно они покажутся интересными и вам.
4656.60 4669.60 "Игорь Лабутин" Во-первых, мы про source-генераторы уже говорили много раз, есть некоторый проект на GitHub, где товарищи собирают ссылки на всякие разные полезные или не очень полезные source-генераторы.
4669.60 4683.60 "Игорь Лабутин" Интересно, мы его уже упоминали когда-то, просто сейчас там появилось порядка 80 или около сотни уже source-генераторов, поэтому если интересно посмотреть, как они написаны, как вообще их писать, как они работают, может быть что-то полезное для себя найдете, сходите, посмотрите.
4683.60 4695.60 "Анатолий Кулаков" Я удачу вам даю, что мы обсуждали этот репозиторий уже в 36-м выпуске, это было в 2021 году, как раз в сентябре, в конце сентября.
4695.60 4699.60 "Анатолий Кулаков" Поэтому если кто-то хочет там еще про source-генераторы послушать, то тоже можно посмотреть.
4699.60 4703.60 "Анатолий Кулаков" Там только source-генераторы начинались, и мы как раз много про них говорили.
4703.60 4706.60 "Игорь Лабутин" Да, и мне кажется, тогда он был совсем маленький, но действительно разросся.
4706.60 4717.60 "Игорь Лабутин" Дальше, Стивен Тауб добавил, без особых каких-то новостей или, не знаю, может быть будет в каком-то превью, релизе, в смысле в статье, новые опции в Configure Weight.
4717.60 4726.60 "Игорь Лабутин" Как мы помним, можно написать weight, там task что-нибудь, .configure_weight_at_false, да, и этот configure_weight_at_false, он прям много породил дискуссии в тот момент в мире.
4726.60 4732.60 "Игорь Лабутин" Теперь там есть, можно передавать не только true и false, теперь туда можно передавать полноценные configure_weight_options.
4732.60 4736.60 "Игорь Лабутин" Теперь есть новый такой енумчик, в котором есть 4 значения.
4736.60 4738.60 "Игорь Лабутин" Во-первых, там есть none.
4738.60 4742.60 "Игорь Лабутин" configure_weight_options.none - это то же самое, что configure_weight_at_false.
4742.60 4744.60 "Игорь Лабутин" То есть вообще без опций.
4744.60 4750.60 "Игорь Лабутин" Дальше, можно передать configure_weight_options.continue_on_captured_context.
4750.60 4758.60 "Игорь Лабутин" Ну то есть continuation должен выполняться на том самом захваченном контексте, это configure_weight_true - дефолтное поведение.
4758.60 4762.60 "Игорь Лабутин" Странно немножко, что none - это не дефолтное, а вот это вот дефолтное, но так получилось.
4762.60 4765.60 "Анатолий Кулаков" Ну зато теперь через эти опции более понятно, что там происходит.
4765.60 4769.60 "Анатолий Кулаков" Там не true, false, а настоящий capture или не capture.
4769.60 4770.60 "Игорь Лабутин" Да. Или none.
4770.60 4774.60 "Игорь Лабутин" Дальше, третье, то, ради чего всё это добавлялось, третье и четвёртое.
4774.60 4777.60 "Игорь Лабутин" Третья опция называется suppress_throwing.
4777.60 4779.60 "Игорь Лабутин" Штука делает следующее.
4779.60 4788.60 "Игорь Лабутин" Если вы выйдете таску, и она завершается с ошибкой, в смысле кидает исключение, то исключение не будет выкинуто наружу.
4788.60 4795.60 "Игорь Лабутин" У вас единственное, что вернётся, это вернётся тасочка в состоянии типа...
4795.60 4801.60 "Игорь Лабутин" Даже если вы не await, это же даже не await, если вы напишите await, как раз исключение кинется.
4801.60 4813.60 "Игорь Лабутин" А вот если вы напишите task присвоить что-то там, .configure_weight_suppress_throwing, то исключение не выкинется, таска просто приведёт в состояние fold, и всё.
4813.60 4822.60 "Игорь Лабутин" Сделано это было для внутренних нужд рантайма, потому что там довольно много мест, типа от вида try, что-то там, catch и пустой catch.
4822.60 4825.60 "Игорь Лабутин" Попробовали, ну свалилось с исключением, да и ладно.
4825.60 4830.60 "Анатолий Кулаков" Ну это довольно интересная штука, потому что обычно пустой catch - это признак плохого тона.
4830.60 4842.60 "Игорь Лабутин" Да, но видимо в каких-то местах есть, возможно где-то с какими-то внешними API взаимодействия, не знаю с чем, я не читал детально, там довольно много мест в пиаре поменено, файлов 30, мне кажется.
4842.60 4848.60 "Игорь Лабутин" И я так понимаю, что цена такая, что раньше создали исключение, кинули, дорогая операция, поймали и ничего не делаем.
4848.60 4854.60 "Игорь Лабутин" Если мы заранее знаем, что нам неважно, какое исключение выкинется, давай сразу напишем, что не надо его кидать и даже создавать.
4854.60 4858.60 "Игорь Лабутин" Мы просто по таске сможем понять, закончилась ли она успешно или нет.
4858.60 4867.60 "Игорь Лабутин" Там в большинстве мест код поменялся на то, что типа вот тот самый configure wait, suppress throw и не дальше, и в task.is_complete successful, и то тогда что-то делаем.
4867.60 4875.60 "Игорь Лабутин" И последняя опция называется force yielding, это по сути штука заключается в следующем.
4875.60 4889.60 "Игорь Лабутин" Если вы делаете wait на таске, то может случиться так, что таска не завершена еще, и тогда естественно исполнение метода приостановится, поток отдастся кому-то другому, и когда таска закончится, метод продолжит исполнение.
4889.60 4895.60 "Игорь Лабутин" Если таска уже в состоянии completed, то как правило поток не отдается и просто продолжается исполнение дальше.
4895.60 4904.60 "Игорь Лабутин" Но есть случаи, видимо это вот очень тонкая многопоточка, когда вам нужно сделать так, чтобы поток точно освободился, даже если таска уже completed.
4904.60 4907.60 "Игорь Лабутин" Вот на этот случай делается force yielding.
4907.60 4915.60 "Анатолий Кулаков" Я, кстати, часто встречал такой код, который там sleep 0 делает или что-то в этом духе, как раз-таки для этого, поэтому не такая редкая ситуация.
4915.60 4922.60 "Игорь Лабутин" Ну да, wait task делали от нуля, это классика для этого дела, раньше была, теперь можно написать аккуратно configure wait option.
4922.60 4926.60 "Анатолий Кулаков" Безусловно, пролетарии тогда ждали другого, когда уберется этот вообще конфигура wait.
4926.60 4932.60 "Игорь Лабутин" Ну да, там в комментах тоже, по-моему, написали ему, типа, если уж пошли трогать, ну потрогайте до конца.
4932.60 4935.60 "Игорь Лабутин" Да, это типа более дорогая, видимо, изменение.
4935.60 4937.60 "Игорь Лабутин" Ну да, безусловно.
4937.60 4944.60 "Игорь Лабутин" Дальше, Дэвид Фаулер написал очередной из своих репозиторий с демкой про то, как использовать identity endpoints новые.
4944.60 4953.60 "Игорь Лабутин" То есть если, мы, по-моему, это тоже уже обсуждали в каком-то из прошлых превью, когда в S/Panet добавили новые identity endpoints, с помощью которых можно логиниться, там токены создавать, вот это всё.
4953.60 4957.60 "Игорь Лабутин" Там речь не про JVT, но просто про какие-нибудь токены.
4957.60 4967.60 "Игорь Лабутин" То Дэвид вот написал репозиторий, где можно посмотреть, как это используется на практике, в лучших, так сказать, традициях того, как это предполагается команде S/Panet.
4967.60 4971.60 "Анатолий Кулаков" Такое ощущение, что у Дэвида как бы забрали права на микрософтовский блог и явно не выдают.
4971.60 4978.60 "Анатолий Кулаков" Дайте уже Дэвиду права, пусть нормальные статьи пишут, а не вот эти вот гисты в GitHub.
4978.60 4981.60 "Анатолий Кулаков" Хочется нормальной, развернутой, понятной, красивой статьи.
4981.60 4983.60 "Игорь Лабутин" Да, ему, видимо, лень.
4983.60 4985.60 "Игорь Лабутин" Судя по всему, да.
4985.60 4991.60 "Игорь Лабутин" Он играет и на вакейшенах, если судить по твиттеру, по крайней мере сейчас.
4991.60 4992.60 "Игорь Лабутин" Дальше.
4992.60 4994.60 "Игорь Лабутин" Понадобился мне тут csv_parser.
4994.60 5014.60 "Игорь Лабутин" Есть довольно много разных csv_parsers на дотнете, но тут же попалась новость про то, что вышел новый дотнет csv_parser под названием sep, который, мне кажется, вот знаете, есть это набор базовордов, вот если прочитать аннотейшн к этому новому парсеру, он звучит так.
5014.60 5025.60 "Игорь Лабутин" Это modern, minimal, fast, zero allocation, csv, соответственно, и parser, и writer, cross-platform, dreamable, и native, out, compatible.
5025.60 5026.60 "Анатолий Кулаков" Вот я тоже ждал.
5026.60 5030.60 "Анатолий Кулаков" Out обязательно должно быть, source-generator должен быть, вот это все должно быть.
5030.60 5034.60 "Игорь Лабутин" Из всех базовордов тут, по-моему, только машин-лернинга или AI нету.
5034.60 5036.60 "Игорь Лабутин" А так, в целом, все на месте.
5036.60 5040.60 "Игорь Лабутин" Короче, новый парсер, написан там действительно довольно неплохо.
5040.60 5047.60 "Игорь Лабутин" Я попробовал повязать, но в моем простом случае мне не нужен был ни fast, ни zero allocation, ни cross-platform, но работает парсер.
5047.60 5051.60 "Игорь Лабутин" Но посмотрите, если вы действительно парсите какие-то csv, может быть, действительно будет полезно.
5051.60 5058.60 "Игорь Лабутин" И последний от меня - это новый, я вижу, у студии, extension, который показывает вам ваши github-экшены.
5058.60 5059.60 "Игорь Лабутин" Что он делает?
5059.60 5068.60 "Игорь Лабутин" Он генерирует новое tool-окошечко, дальше он смотрит в ваш windows-credential-manager, чтобы найти какие-нибудь креды для github.
5068.60 5084.60 "Игорь Лабутин" Если они есть, то дальше он показывает вам ваш текущий бранч, на который у вас открыт бранч студии, он, соответственно, показывает, какие для этого бранча сейчас на github-е исполняются workflow, или какие исполнялись, там можно настроить, какую глубину истории показывать.
5084.60 5089.60 "Игорь Лабутин" Можно раскрыть каждый workflow, он показывает список джобов и внутри список стыпов.
5089.60 5097.60 "Игорь Лабутин" Плюс он показывает, в принципе, набор workflow, который у вас определён на github-е, и позволяет запустить их, просто прямо из этого tool-винду.
5097.60 5103.60 "Игорь Лабутин" Кроме этого, он показывает ещё список секретов в вашем репозиторе и позволяет их добавлять или редактировать.
5103.60 5109.60 "Игорь Лабутин" Так что, если вы работаете плотно с github-ом, у вас проект с ним, то, может быть, действительно будет удобно, чтобы не лазить в браузер каждый раз.
5109.60 5116.60 "Игорь Лабутин" Естественно, если вы хотите, например, посмотреть логи билда, то нужно открыть их, он откроет сразу в нужном месте в браузере.
5116.60 5119.60 "Анатолий Кулаков" Да, действительно удобная штучка.
5119.60 5127.60 "Анатолий Кулаков" Так, я ещё наткнулся на библиотечку, опять же, сам с ней не сталкивался, но, может быть, кому-то будет полезно, которая называется System Web Adapters.
5127.60 5130.60 "Анатолий Кулаков" У неё как раз вышел новый релиз 1.2.
5130.60 5138.60 "Анатолий Кулаков" Это специальная штука от Microsoft, официальная, которая позволяет вам упростить обновление ваших ISP.NET проектов на ISP.NET Core.
5138.60 5158.60 "Анатолий Кулаков" Если такие остались, я знаю просто, что много осталось, и многие люди до сих пор страдают, то есть такая библиотечка, которая за различными мидлвариями симулирует стандартные интерфейсы, стандарты какие-то, контексты, реквесты, и, может быть, с помощью этой библиотечки вам удастся более мягко, более быстро перейти.
5158.60 5161.60 "Анатолий Кулаков" В общем, сам не использовал, но Microsoft говорит, что многим помогает.
5161.60 5163.60 "Анатолий Кулаков" Ну и отлично.
5163.60 5165.60 "Игорь Лабутин" Давайте на сегодня завершать.
5165.60 5171.60 "Игорь Лабутин" Мы сегодня посмотрели на то, что нас ждёт в 12 C#, и нас там ждёт не очень много.
5171.60 5177.60 "Игорь Лабутин" Узнали от Марка Симонов, в чём разница в валидации и бизнес-рулов, и когда что можно и нужно менять, и каким образом.
5177.60 5179.60 "Игорь Лабутин" Мы ждём продолжения.
5179.60 5184.60 "Игорь Лабутин" Посмотрели с Andrew Locke, зачем нам могут быть нужны интерсепторы, которые используются в Minimal API с Rosgen.
5184.60 5191.60 "Игорь Лабутин" Узнали новости про ReSharper, про то, что теперь удобно можно навигироваться между юнитестами и вашим основным кодом.
5191.60 5197.60 "Игорь Лабутин" Ну и поговорили про много разных мелких полезных библиотечек, сайтов и так далее.
5197.60 5200.60 "Игорь Лабутин" На этом на сегодня будет всё.
5200.60 5202.60 "Анатолий Кулаков" Да, давай заканчивать.
5202.60 5208.60 "Анатолий Кулаков" И так, не забывайте шарить нас, репостить, советовать друзьям, переслушивать выпуски по 10 раз.
5208.60 5210.60 "Анатолий Кулаков" И обязательно оставляйте комментарии.
5210.60 5216.60 "Анатолий Кулаков" В основном мы их собираем на ютубчике, но можно в принципе в любой социальной сети нас найти и там покомментировать.
5216.60 5218.60 "Анатолий Кулаков" Да, на этом всё.
5218.60 5219.60 "Анатолий Кулаков" До новых встреч.
5219.60 5220.60 "Анатолий Кулаков" Всем пока.
5220.60 5221.60 "Игорь Лабутин" Всем пока.