0.00 26.52 SPEAKER_00 приветствую дорогие служители в эфире радио.нет выпуск номер 100 и в студии как всегда Анатолий Кулаков и Игорь Лабутин всем привет мы сегодня пришел посчитали что начинался нулевой выпуск в 2019 году то есть у нас пять лет своеобразный юбилейчик небольшой но все же и за
26.52 46.36 SPEAKER_01 причем практически ровно получилось то есть мы если не считать нашего нулевого выпуска который вышел немножко заранее мы практически ровно там пять лет и месяц примерно получается записали первый выпуск пять лет назад так что да пять лет выпусков 20 выпусков в год нормально
46.36 78.20 SPEAKER_00 да скорость хорошая если вы хотите больше послушать про брюзжание старых подкастеров то вам пришел пришел можно найти на нашем сайте бусти поэтому заходите покупайте и слушайте а во все удовольствие если найдете там что-то полезное конечно а в выпуске будем говорить про актуально про новости статьи личности и самое интересное из мира.нет то чем это тоже занимаемся многие-многие годы теперь можно прям так так рассказывать что с большой многомногогодовалой историей
78.20 87.20 SPEAKER_01 давай еще скажем спасибо всем нашим помогателям да за пять лет мы не одни мы насобирали
87.20 159.44 SPEAKER_00 огромное число доброжелателей в частности александр сергей владислав шевченко антон лазарев илья гурий самарин виктор руслан артамонов александр ерыгин сергей бензенко александр лапердин ольга бондаренко дмитрий сорокин сергей краснов константин ушаков андрей фазлеев басим альджевахири андрей маслов дмитрий павлов постарнаков андрей друзья всем огромное спасибо приятно что вы с нами о приятном мы были тут как раз на конференцию dot next и очень много подходило людей которые узнавали спрашивали фотографировались не знаю поймал себя до сих пор ловлю себя на чувстве на таком на детской радости как будто действительно нас кто-то слушает потому что мы когда говорим у нас какой-то такой односторонний канал есть там конечно какие-то просмотры на ютубе но кажется что это все и ботами можно накрутить и никому там кроме моей мамы этот подкаст не нужен а когда подходят настоящие люди и говорят что они по-настоящему нас слушают все равно какой-то щенчий щенечий восторг возникает так что друзья большое спасибо всем кто подходил было очень приятно увидеться с вами со всеми ну не со всеми но с каким-то активным нашим числом еще приятно что есть приятно что вы существуете да к сожалению пока
159.44 177.08 SPEAKER_01 еще прям на улицах совсем прям так чтобы на улицах не узнают но действительно на дот на кисти было много народу который подходила там отдельно кто ли отдельно ко мне иногда к нам вдвоем чтобы сказать много всяких разных приятных слов большое всем спасибо ну что пойдем по темам
177.08 185.28 SPEAKER_00 у нас тем более релиз завелся ну пока еще релиз кандидат номер один от майкрософта начались
185.28 673.92 SPEAKER_01 рт как обычная майкрософт в рт ну в общем-то ничего такого существенно серьезного не выпускает но давайте пробежимся посмотрим тут все-таки есть немножко то что это релиз кандидата казалось должен быть уже кот фриз все равно добавляются всякие новые интересные штуки которые может быть кому-то окажется полезным как обычно релиз ноутс разбит на несколько разделов как обычно сейчас все это лежит не очень удобно на гейдхабе в разных частях этого самого гейдхаба в виде мдф аликов к счастью наконец-таки для релиз кандидата первого майкрософт на своем дев блокс наконец-таки выпустила ну такую плюс-минус нормальную статью со ссылками конечно даже на гейдхаб но хотя бы в есть одна ссылка куда можно сходить и углядеть так сказать обзорный вид на все то что было сделано хотя бы по заголовкам но мы сходили не только в заголовки но и вовнутрь всех этих самых статей чей-то много и посмотрели что там есть и начнем мы с библиотек традиционно уже майкрософт начинается с раздела libraries там добавилось некоторое количество опишек то есть казалось бы кот фриз там уже релиз кандидат там стабилизирую стабилизирую и фикси баги но нет добавились новые опишки для client веб сокет options и для веб сокет creation options то есть если вы используете веб сокеты которые позволяют теперь включить на веб сокетах принудительные пинги и соответственно обрывать connection если ваш сосед ну в смысле этот то с кем вы коннектите да другая сторона не отвечает то есть там можно задать timeout в течение которого точнее через который веб сокеты сами друг друга пинговать если ответа нет то соединение будет оборвано удобно удобно будете вы в течение максимум этого timeout узнавать что клиент например отвалился также добавили новых compression options у нас уже была поддержка за либо и brotli но это было можно просто ее включить то есть можно было выбрать вы хотите зип злипли бротли теперь для злип и бротли добавились опции их можно чуть-чуть настроить не то чтобы там было очень много настроек но не есть можно настроить и также в поддержку tar архивов добавили тоже небольшое решение опишки data offset но это если вы уже совсем как бы копаетесь и руками распаковывать это архивы через dotnet или запаковывайте может быть полезно в http client factory добавилось изменение что если вы создаете что тп клиенты с http client factory то это factory не будет больше лагировать заголовки запросов по умолчанию но для того чтобы включить обратно есть теперь специальный метод называется редакт логгед headers куда вы передаете лямточку которая определяет нужно лагировать тот или иной заголовок или нет там по имени не знаю при гэксу значение возможно не помню можно значение добраться до имени точно можно добраться и дальше еще там немножко улучшение вокруг класса под названием метро это штука для всяких считывания метрик там каунтеров и всего остального он теперь умеет слушать на wild карте звездочку передать место конкретного названия счетчик и он будет слушать на всех например внутри какого-то namespace это все в библиотеках то есть вроде как кандидат опять же повторяю но некоторое количество новых опций опишек и так далее в SDK добавилась новая команда опять же релиз кандидата мы добавляем новое называется dotnet workload history и это до некоторой степени похоже на git history или даже может быть скорее на гид какой-нибудь reflog то есть когда вы теперь делаете всякие dotnet workload install uninstall и так далее у вас это все сохраняется мы видим какой-нибудь файлик на диске похоже можно теперь с помощью dotnet workload history посмотреть что когда как менялась и более того можно теперь сказать dotnet workload update - - from history и указать id из истории там они все нумерованы и ваш SDK конкретный вот к которому это все применяется будет приведен в то состояние которое он имел на момент этой записи в истории можно откатываться на нужное состояние workload не писать там uninstall uninstall uninstall просто сказать вот dotnet workload update - - from history 1 и вы получите исходный ваш SDK как вы его поставили первый раз так это все про SDK в SDK у нас к счастью не очень много SPNetCore в SPNetCore улучшили распределенные трассировки для сигналара значит теперь в dotnet'овский сигналар клиент умеет в activity sources там он называется microsoft SPNetCore SIGNALAR CLIENT неожиданно и он там правильно все создает нужные спаны пропагетит куда что нужно javascript'овый клиент пока этого не умеет но научится следующем версии то есть тот который работает в браузере пока сам спана не создает но научится вот и когда вы через хаб кого-то дергаете там тоже со спанами все хорошо работает контекст куда нужно пропагетиться и так далее в websocket middleware смотри выше про библиотеки добавили новые опишки про websocket options про всякие пинги в websocket middleware эти опции тоже добавили можно их теперь настраивать и там если вы пользуетесь именно через middleware в middleware же теперь можно использовать то что называется keyed.di то есть когда это когда вы создаете именованные не именованные но же раньше можно было именованные инстанцы добавить там add_named что-нибудь да а еще у нас есть теперь атрибутик который называется from_keyed.services по-моему это одно и то же что именно что add_named да согласен и потом ты для использования указываешь from_keyed.services и указываешь имя вот теперь эту штуку этот атрибут можно использовать в middleware, раньше было нельзя. я что-то сказал что можно видимо вот как раз доделали в последний момент или вмерзли, потому что я какие-то такие статьи про это видел чуть раньше, но может действительно не мерзли долго. так и на линуксе появилась возможность сказать .net_dev_certs.https--trust то что можно было давно сделать на windows и на mac оси и он там через некоторое количество приседаний плюс парочку ручных команд добавит вам ssl сертификаты которые используют .net когда запускается в дебажном варианте, ну не в дебажном, а у вас локально на компе, добавит эти сертификаты в trusted чтобы когда вы к ним обращаетесь в браузере, браузер считал что все хорошо. ну и куда же без .net_maui. .net_maui живет, в релиз кандидат вошло целое одно изменение добавили в лейблах можно теперь сказать что в многосрочных лейблах теперь можно выравнивать только по левому по правому краю по серединке но еще есть такой стиль как justify это когда он растягивает что право левые границы были одинаковые по ширине. да ради этого стоило релиз ноты выпускать. ну вот да такая же ну и конечно там more bug fixes там что-то там работаем над перформансом все дела но из такого что было важно отметить в релиз ноутах вот это одна фича в общем то и все вот это релиз кандидат я признаться не помню в этот раз явного ну правда может быть я это пропустил из-за того что релиз кандидат вот это разбросано по куче разных мест является ли он прям сейчас production supported раньше же у микрософта была тема что как только релиз кандидат он все support в production и можно тянуть в production он там типа подпадает в действие support основного релиза и вот это все но сейчас признаться не помню но я не думаю что кто-то кроме какого-нибудь ажура и внутренних других микрософтских сервисов тянет релиз кандидата в production так что наверное это не страшно что я про это не помню наизусть посмотрим
673.92 678.48 SPEAKER_00 ну давай исправлюсь посмотрю как там тем более нашим слушателям я думаю это точно не не это
678.48 685.12 SPEAKER_01 самое не критично так может у нас есть такие кто берут и типа ой рц1 вышел про него рассказали
685.12 698.44 SPEAKER_00 все берем впрод сейчас ну в принципе почему нет все новенькое нужно осваивать кстати новеньком он про dotnet aspire кстати по моему где-то на уровне релиз кандидатов же нам представили
698.44 709.12 SPEAKER_01 спайр в прошлом году правильно мне кажется это было чуть-чуть раньше в смысле что это был билд мне кажется же на билде показали билд у нас летом дачу там в июле релиз уже был ну то
709.12 715.32 SPEAKER_00 есть не еще в этом году на билде был релиза представили его где-то я понял первый раз его
715.32 721.72 SPEAKER_01 показали да наверно наверно в районе либо релиз кандидат либо вообще дотонат конфа нет не на
721.72 743.44 SPEAKER_00 кандидатах еще появился когда я помню мы обсуждали какой-то релиз унылый получается нам выдали вот хоть какой-то бриллиантик а я про то что как бы релиз унылый получается ничего интересного нет и если наши предположения были верными что товарищи из микрософта пилили как что-то целый год что-то крутое тоже пора представлять это крутое давайте давайте выкатывайте
743.44 756.80 SPEAKER_01 готовят готовят статью какую-нибудь крутую может быть спешки допиливают долго долго ну что ты как как в ночь перед экзаменом там готовимся готовимся там в последний нас весь год спасал
756.80 1131.98 SPEAKER_00 спайр я думаю что сейчас мы про него поговорим потому что статичка тоже интересная есть называется она в бсм были и контейнеры для спайра мы все знаем что такое спайр это у нас некий оркестратор который может ваше приложение хорошо и хорошенечко собирать по кусочкам из которых обычно сейчас состоят современные микросервисы и удобно запускать их особенно локально на локальном вашем компьютере для удобной отладки для удобной диагностики и прочее прочее так вот в принципе этот спайр он не сам по себе запускает ваше приложение особенно если они запускаются в докере он использует для этого контейнер runtime и сейчас подержится 2 контейнера тайма это докер десктоп и подман поэтому если вы хотите пользоваться спайром то один из них у вас должен стоять вот а теперь еще появилась клевая тема если вы помните из наших предыдущих выпусков за этот год у испара есть возможность подключать к себе для управления для оркестрации различные образы то есть мы можем просто обычный .net проект из салюши на за референсить и он у вас запустится как часть вашего микросервисного оркестратора или можно указать конкретный экзешник который лежит на диске или можно указать докер имидж который тоже будет скачан как бы запущен в общем очень много разных полезных функций компонентов которые можно спайре засунуть так вот есть еще один интересный компонент который называется в бсм и чтобы этот компонент завязать в испаре и существует специальная библиотечка которая называется фимьен спайр спин спин на самом деле это такой фреймворк который создан для того чтобы писать микросервисы на вбсм то есть по сути на васми чем хорош вас мы тоже об этом же часто говорили но тут не грех и повториться прежде всего это в том что асмы разрабатывался сразу как нечто что будет крутиться в песочнице то есть у него есть куча ограничений которые позволяют безопасно запускать код даже если он доступен из если вы взяли вдруг допустим из недоверенного источника таким образом там можно чуть ли не вирусы запускать они ничего не смогут вам сделать потому что они все будут крутиться в свои песочницы также в васму очень портабельный то есть его очень легко переносить на любые платформы и уже есть запускальщики практически под все под любые операционные системы под любые архитектуры под любые платформы то есть везде можно этот васм код хорошо и запускать плюс это все равно была какая-то цель на некий ассемблер пусть и даже на богомерзком джава скрипте но все равно это некий ассемблер и рассчитывали его как раз там для игр для виртуальной реальности для таких высоконагруженных приложений поэтому он всегда проектировался как нечто быстрое поэтому получилось получилось что программа на нем работает достаточно быстро ну и наверное самая главная фишка почему васм это не новый silverlight и почему он не умрет это то что всем разработчикам в мире не нужно учить никаких новых языков потому что все мейнстримовые языки сейчас умеют конвертировать копилировать транспилировать свой код умеет транспилировать васм и поэтому даже пипи тех кто пишет на каком-то своем языке на расти носи шарпи го они все могут использовать все всю мощь васма то есть они уже они уже по сути могут и вы могут им пользоваться даже не изучая ничего вот поэтому васм это такая хорошая платформа то есть это получается меж не только такой меж меж браузерный язык и квазом задумывали но и меж операционно системный меж языковой меж архитектурной ну то такое меж галактический язык у нас такой получается поэтому довольно хороший формат надо его заюзывать совсем во всех сторон что собственно и делает этот фирм сифе фирмен или фиген какой-то французский штоль фреймворк а фиген и спайр спин вы можете создать спин приложение соответственно вы можете написать это приложение на любом языке которая умеет компилироваться в бэсамбле в частности на си шарпи но в принципе если вы на си шарпи пишите то вам легче какой-нибудь project reference сделать но вдруг если у вас есть какие-то коллеги которые мне так повезло по жизни и они пишут на го или на плюсах или на расте то вы можете зареференцировать в спар их проект главное чтобы этот проект умел компилироваться в бэсамбле вы можете зареференцировать как прям исходный код или даже можете зареференцировать контейнер который специально у в бэсамбле у асмов есть контейнер регистрин такой же практически как и для докер контейнеров только для в бэсамбле контейнеров в общем этот этот формат должен отдельно поддерживать в репозиторий ваш например ажур регистри какой-то его вполне держит можно прямо из этого репозитория за референсить а для того чтобы добавить поддержку ваше стандартное спар приложение вам нужно будет установить пакет мы спар спин в вашем дистрибьют аппликейшене зарегистрировать всего-навсего одну строчку это этот спин ап которые которым передадите передадите источник того где брать этот в бэсамбле приложение есть гибкий runtime configuration файл то есть вы можете там конфигурации всякую подтяните в частности можно добавить open телеметрии экспортер чтобы все ваши приложения которые работают в свб сэмболи подключили стандартные стандартные экспортеры которые есть во всех из пар приложениях которых во всех экспорт компонентах и эти спортеры будут прекрасно видны в спар дашборде то есть вы можете смотреть трейсинги смотреть логи смотрите дашборды как запрос улетает между всякими компонентами чем все как вы привыкли в стандартном испарь дашборде но только при этом там у вас под капотом могут не клинить компоненты крутиться на web assembly вот такой межмеж языковой межплатформенный интересный у нас компонент получается в виде спайра ну
1131.98 1165.82 SPEAKER_01 действительно и кажется что какую-то популярность обретает раз появляются вот такие вот сторонние по большому счету как это это не библиотеки стены не компоненты как это называется теперь integration и до интеграции блин странный перевод компоненты короче раз народ пишет компоненты значит действительно это интересно поглядим насколько долго продержится такое такой интерес и насколько оно все вольется куда-либо за вольется в dotnet разработку и вольется в какую-нибудь
1165.82 1183.34 SPEAKER_00 не тут на это разработку сколько вылится за пределы интересно ну да наверное да не хватает на других платформах такого интересного дашборда который может объединять на разных языках оперировать контейнерами и показывать все удобно на локальной машине ну да ну видишь проблема
1183.34 1200.34 SPEAKER_01 только сразу с другими не тут на этими языками до платформами в том что если ты хочешь прям полноценный expire experience тебе нужно все-таки писать основной ап на дотнете который соберет все в кучку ну может быть и не так уже плохо другое дело что там простой там по сути 1 1 это
1200.34 1211.38 SPEAKER_00 юсто юзета юзун то наверняка появятся же эти какие-нибудь умельцы которые сделают конфигурацию на ямле все тебе надо будет писать конфигурацию на ямле для того чтобы спайр это все подтащил
1211.38 1217.18 SPEAKER_01 ну то есть как бы майкрософт создавала спайр чтобы не писать ямль чтобы не писать ямл дотнет
1217.18 1222.26 SPEAKER_00 разработчиком и они его писать не будут всякие отчепенцы пусть страдают ну хорошо ладно
1222.26 1358.86 SPEAKER_01 посмотрим давай пойдем дальше и дальше у нас статья который с ужасом ждем ждут подкастеры каждый год а именно степен талб перформанс импрувенц ин дотнет 9 ну все разбудишь меня через пару часиков типа того если бы я ее всю зачитывал кто-то на чатике подкаста выкладывал там по-моему ридер какой-то сказал что там сто шестьдесят восемь сто восемьдесят шесть страниц а4 в пдф напечатать из браузера короче прям большая статья и я и начал читать там очень интересно но я понял что рассказывать бенчмарки голосом я когда-то пробовал кажется что сейчас это уже совсем неблагодарное дело очень получается долго и не очень понятно тем более что как мы обсуждали в частности до перед подкастом что очень много изменений и они очень мелкие даже сам талб отмечает статье что очень сложно было сгруппировать все эти миллион и миллион сколько-то десятков сотен пул реквестов в какие-то логические блоки но то есть понятно что есть какие-то пул реквесты которые однозначно определяются вот это джит да там какая тир компиляция это явно джит вопросов нет но с другой стороны джит используется в найти фаут тоже и поэтому как бы эти же импрувенты залетают залетят найти фаут а с третьей стороны ну то есть получается так что куча всего оно относится ко всему и именно поэтому статья такая получается немножко ты вроде читаешь про одно про одно про одну портянку текста потом в конце раз и те говорят что у а заодно и на самом деле заимпровил еще и вон то такой ну блин и как это все рассказывать ну в общем я попробую очень кратко поверхам просто по сути почти по заголовкам рассказать что там где было и про что премьер напишет талб я точно все не затрону если интересно я вам рекомендую просто открыть статью не читайте ее сначала просто либо по разделам по оглавлению побегайте либо просто control f найдите нужные вам кусочки по ключевым словам и будет хорошо или бы какой-нибудь читальщика
1358.86 1366.14 SPEAKER_00 загнать вам на ротор как он справляется с такими статьями чтобы он не читал ассембленные листинги
1366.14 1390.02 SPEAKER_01 голосом там же куча 7 вставок там вот смотрите вот dotnet 8 генерил 2 атрибута 2 этих об кода цмп там не ассемблер понятно там или хотя там даже ассемблер есть а вот только один и до 9 и поэтому вот смотрите как классно ну короче я что-то сомневаюсь что это будет нормальной
1390.02 1395.26 SPEAKER_00 восприниматься прочитать он прочитает он денется ну то есть пока нас чё-то не заменит да с тобой
1395.26 2891.04 SPEAKER_01 мы тут пока живем да мы умные не расчетки говорим что мы не будем читать эту статью слух вы читайте ее сами смотрите точнее лучше на экране а мы просто пробежимся по заголовкам кстати ну такое может и чат джип это сможет заголовки выдернуть ну давайте пройдем по значит статье первый раздел этот жит с джитом все просто там довольно много изменений в но мелких справедливости ради профайл гайд от оптимизаций шанс в тир 0 компиляции баунт чеки убирают армы всячески поддерживают 64-битные поддерживают векторные инструкции на армах поддерживают авх 512 это викторизованные инструкции соответственно очень длинных ценности битные улучшают бранчинг но бранч предикшен да в смысле уменьшают количество бранчей который генерит жит жит умеет в некоторых случаях понимать что здесь всегда условия тру или условия false да и не будет генерить бранчинг интересный кусочек от жита это object stack allocation штука в следующем если у вас например создается объект внутри функции вы с ним что-то делаете внутри этой функции и никуда за пределы функции он не выходит то по большому счету вам можно этот объект создать было бы и на стеке потому что это быстро это почти бесплатно это не добавляет нагрузку никакую на garbage коллектор и все было бы хорошо единственная проблема она же самая сложная проблема нужно убедиться что это безопасно в том смысле что действительно что этот объект ссылка на него никуда не будет сохранена вы никуда его не передадите извне функции потому что как только вы из этой функции выйдите стек естественно разрушится и ну там будет мусор следующих вызовов и куда будет указать ссылка так нельзя в безопасной среда так нельзя эта штука называется escape анализис в английской терминологии и пока в девятом дотнете сейчас мы стали делать его ну дотнет в смысле стал делать его на очень пока базовом уровне а именно если у вас сдается объект который не покидает функцию то есть один стек frame в том смысле что вы его не передаете никуда в аргументы никому и не возвращаете то есть просто создали объект максимум там вызвали на нем пару функций и разрушили объект такой бывает нужно иногда не очень не может быть часто но бывает то в этом случае такой объект можно создать и на стеке почему нет вот понятно что дальше если там есть какие-нибудь осинки внутри вы и ты тут-то это вспоминается стать стейк машина и понятно что он тоже все точно надо кучи собирать но если у вас не осинк метод и внутри это делать то вот теперь качестве первого такого шага объекты предположительно будут создаваться только на стеке вот скорее всего там есть конечно же и в рейтика если у вас таких объектов дофигище тут тут вопрос размера стека и может быть какие-то нужно все-таки создать в куче не погружался детально в пол реквесты надо посмотреть и с инлайнингом тоже довольно много изменений значит во первых что с инлайнингом что стир 0 на компиляции там все в основном крутится вокруг хелперов значит не знаю заметили вы нет по моему мы кстати про это либо не упоминали либо где-то в самом далеком начале dotnet 9 сезона так скажем это все упоминали у наших эксцепшенов в дотнете которые есть всякие аргумент нал эксцепшен нал референс эксцепшен вот эти всем появились теперь статические методы которые на хелперы такие до throw if null например для аргумент для аргумент нал эксцепшен по моему не для нал референс конечно для это самое нул референс было бы интересно да нал референс эксцепшен throw if null ну в смысле это логично ну да аргумент нал эксцепшен конечно и для того чтобы не писать каждый раз код и в там чего-то там и равно равно на открыть фигурную скобочку на новой строчке еще на новой строчке написать throw new вот это все пишите в одну строчку аргумент нал эксцепшен . throw if null и название вашего выражения там не знаю параметра функции или чего чего угодно и вот джид обучился такие штуки довольно неплохо правильно инлайнить проблема с инлайнингом в чем что если вы инлайните вы раздуваете размер кода это может быть плохо вторая проблема в том что если throw if null сделать генериком а он сделан не генерик версии специально хотя казалось бы ну что-то фигня то да как бы у нас язык там генерики все типа безопасность но тогда если вдруг получается так что у вас в throw if null прилетает какой-нибудь value тип то согласно принципам реализации генериков в дотнете вы должны будете изменить версию кода для этого value типа и так для каждого value типа который туда случайно прилетит понятное дело что в вашем личном коде ну в смысле в коде приложения вы скорее всего не будет писать throw if null от какого-нибудь инта ну потому что вы знаете что он там не может быть null но если у вас этот код встречается внутри другого генерикового класса у которого нет constraints то вы не знаете что кто-то передадут инты не инты там стринги вот поэтому throw if null сделали не генериковым а jit научили правильно с ним обращаться в том смысле чтобы он не генерировал слишком много кода потому что throw if null довольно популярная штука стала и даже сам дотнет размечен довольно сильно если его везде инлайнить то с одной стороны он как бы и был сделан чтобы можно было бы заинлайнить а код при этом не был не выглядел большим с другой стороны сильно раздуется размер кода что может быть проблемой например для найти фаота где это все как делится правильно и где и так размер кода бывает проблемой короче сложно это все искать баланс вот пытаются искать баланс по мелочам дальше garbage коллектор garbage коллекторе каких-то супер сильных изменений нету тут на эти восьмом было внедрено решение под названием датас мы про него рассказывали несколько раз динамики dynamically adapting to application size то есть динамическое подстраивание под размер приложения в восьмом дотнете это было включено по дефолту только для найти фаот варианты сейчас это будет включено в девятом дотнете для любого серверного garbage collection и эта штука которая позволяет начать с минимального количества хипов напомню что в сервер garbage коллектор режиме у вас количество хипов равно количеству ядер процессора которые доступны вашему приложению и это не всегда хорошо потому что это прекрасно когда у вас одно приложение на весь большой жирный сервер это не очень здорово когда у вас много приложений небольших на один большой жирный сервер потому что каждое такое приложение сервер garbage коллектором выделяет себе там не знаю 16 32 сколько у вас там ядер хипов а при этом она сама маленькая и а хипов куча да и overhead на этом много поэтому теперь приложение будет стартовать тогда с одного хипа ну и по мере необходимости соответственно наращивать количество хипов это все можно отключить это все можно настроить можно указать фиксировано количество хипов если надо через конфиге все это документации есть но стало видимо сервер гц включать чуть более безопасно в смысле не так скажу раньше был была рекомендация что если сервер сервер garbage collection жрет у вас очень много памяти включить workstation это увеличит паузы но зато резко уменьшит охот памяти потому что будет один хип сейчас можно уже смело включать сервер гц не будет проблем с паузами но зато и хип и если у вас память используют не очень активно или не очень много будет там 1 2 и все в целом все будет хорошо с виртуальной машиной это еще одна часть которую очень сложно отделить от джета и гц потому что это все в целом где-то все вместе рядом крутится основное изменение это улучшение обработки исключений для на эти фаот версии была сделана так скажем отдельная специальная реализация по разным причинам и она оказалась настолько хорошей что и в 9 тут найти и забыть портили в обычный тут нет в курсе лар и теперь у нас исключения бросаются и ловится в три от трех с половиной до четырех раз быстрее и лучше там бичмарк прямо буквально в виде который кидает тысячи эксцепшенов и показывается что да там прирост бичмарк поможет побольше чем 4x но во-первых я могу уже забыть а во вторых но это прям синтетический бичмарк понятное дело что в реальной жизни 4x на эксцепшенах как-то вряд ли сильно скажется на общей производительности вашего приложения но в всем приятном так мона рантаем тоже получил некоторое количество улучшений потому что тот рантаем который живет на всяких там андроидах и прочим для тут на это все еще там тоже улучшение со скоростью сохранения и загрузка обратно всякой профайлинг дейда вот тот самый профайл гайд от оптимизации в тех окружениях где нельзя джитить приходится немножко поприседать и посохранять всякую разную полезную информацию которая может быть полезно для следующем запуске для ускорения работы вот теперь все работает точно так же там векторизация интринсики улучшили стартап тайм все дела все улучшили вы быстрее выше сильнее на эти фаут сны дефолтам интересно значит по результатам того как это все поработала в дотнет 8 выяснилось некоторое количество интересных мест которые надо убирать для того чтобы найти фаут код для найти фаута компилировался эффективнее занимал меньше места и работал быстрее ну например характерный пример это хаширование как в дотнете был устроен не сам алгоритм хаширования а вызов у вас был фунт была функция как чтобы я вспомнил название класса по моему назывался типа хэша алгоритм или как-то так короче можно было вызвать функцию хэш и передать туда условно говоря там спан стрим на основе чего вы там собираете свой хэш запятая и имя хэша внутри этой функции был свитч который соответственно смотрел на это имя хэша и вызывал собственно непосредственно саму функцию хэширование проблема в том что вот это вот огромная значит как сказать функция которая с огромным свечом найти фаут на нее сморясь видишь что ее вызывают ну хорошо ее вызывают а это значит что потенциально все что из нее вызывается тоже нужно оставить в коде и вы там например использовать какой-нибудь там ша один только допустим а нужно тащить с собой ша 256 и церце и мд 5 и ничего только не хотите да и суши это все вот такие функции такие диспатч функции которые вроде как по какому-то из параметров дальше делают огромный свитч внутри надо как-то ну убирать их в этом случае получилось хорошо там легко получилось убрать эту функцию передавать сразу вызывать точнее сразу правильную функцию и все стало замечательно в других местах выяснилось что ну линкью надо бы поубирать потому что линкью тоже не очень хорошо дженерик код местами несмотря на то что дженерик это хорошо и правильно как я уже говорил если в дженерик попадает в льютипы то мы получаем ну не взрыв конечно в объеме кода но довольно много нового кода потому что каждый дженерик тип для каждого нового в льютайпа компилиться заново по сути и складывается отдельно вот поэтому в стандартной библиотеке поубирали местами дженерики поубирали местами линкью и в итоге ну для вот приложения которые созданы через дот нет нью виво пи а вот та у которого отключена глобализация короче вы вы выкручен флажок что типа оптимайз сайз а в этот 8 получалось девять с половиной мегабайт стало получаться восемь с половиной мегабайт ну то есть понятно тут же речь идет о процентах но на 10 процентов все равно улучшили тоже неплохо в трейдинге изменения мы уже упомянули или мы пришел упоминали неважно короче добавили лог тайпа мы про него точно рассказывали специально выделенный новый тип желательно который использовать в конструкциях вида там лог что-нибудь потому что он поддерживает он более эффективный плюс он потом позволит оптимизировать на самом деле ронтайн довольно неплохо когда все на него перейдут не знаешь когда это случится но надежда есть добавили пачку методов таск when each when all и when any и утал бы довольно неплохое рассмотрение того почему и как они работают с точки зрения скорости да какие из них помедленнее какие бы быстрее как они внутри устроены почитайте если интересно и вместе с эти информацией там как-то плавный незаметно перетекли в обсуждение memory модели и волотайлов соответственно волотайл такой очень страшное ключевое слово который любят спрашивать на совещании на что значит волотайл и в целом обычно это все связывают с memory моделью то есть с тем как интерпретировать работу с памятью точнее какие гарантии предоставляет среда выполнения с точки зрения работы с памятью последовательности операций особенно многопоточном исполнении наконец-таки у нас есть задокументированная memory модель может про нее отдельно поговорить но наверное боюсь что в формате подкаста сложно докладик будет сделать просто такого задокументировали у нас была раньше задокументированная модель в формате спецификации но она была слишком общий реальные memory модель реального runtime она более строгая за счет чего там есть некоторые послабления которые можно делать когда вы пишете код довольно смешной оптимизации значит если мы пытаемся прочитать менеджер отойдим такая пропертия то раньше там код был примерно такой нужно было внутри пропертий сходить и сделать по инвоук ну по сути такой данном фаст холода внутрь сибирь плюс на части runtime и там внутри делается пара лукапов в итоге все это доходится до некоторой сишной структуры в котором лежит айдишник но это сишная структура memory map нута на пространство нет и можно было просто прочитать поперчу из нет аналогичной структуры причем если вы обращаетесь для в трет точка карантин точка менеджера дойти тот же знал про это и в этом случае он прямо читал ее из менеджер структуры вот если вы просто там соседний трет точка менеджера дойти вот проходил связи от хитрый хитрый путь это может быть нужно во всяких каких-нибудь алгоритмах которые основаны на текущий трет не текущий до всякий ворк стилинг вот это все теперь в общем менеджеры дойти до читать сотни раз быстрее чем раньше вот на каких-то таких это копеечка тут копеечка там оран тайм становится быстрее так это мы с вами прогресс бару прошли примерно 40 процентов статьи впереди еще 60 там на самом деле не так много также по верхам пробежимся стал побыстрее рефлекшн там добавили всякие специальные типы там что-то типа там или классы точнее конструктор ин волкер метод волкер который позволяет закашировать всю нужную информацию мета данные и в итоге вызывать с бешеной скоростью ну еще пока не сравнимые со скоростью нативного вызова но уже как-то существенно более приближающийся к ней по сравнению с обычным рефлекшн про номерек сильно не буду растекаться там в основном конечно тензор примитив тут как бы никаких сомнений быть не могло не то чтобы там есть еще рассказывать про перфоманс там по моему точки зрения перфоманс там вообще почти ничего не упоминает но вот тензор примитив с видим положено упомянуть и а и там все-таки все векторные вычисления даже без них со строками массивами спанами вот тут мне кажется мы довольно много упоминали search values это наверное пожалуй одна из основных оптимизаций что теперь всякие индексов куда можно передать search values они внутри могут зная содержимое search values прям очень оптимально делать и вот эту часть я прям если вам интересно всякие алгоритмы на строках рекомендую почитать там не только сравнение перфоманс там прямо это что-то не описание того какие внутри тут на это в разных случаях используются алгоритмы типа как он ищет под строки в строке и так далее там прям интересно чтиво я аж погрузился минут на 10 в чтение для риггексов все то же самое в смысле все оптимизации которые были для search values подходят и для риггексов а еще в риггексах довольно существенно улучшили одну из версий я напомню что риггекс тут на эти бывает четырех версий но то есть когда вы создаете класс риггекс внутри под ним может быть четыре разных реализации риггексового движка может быть стандартная обычная может быть на source генераторах может быть скомпилированная когда вы указываете сложок compiled он тогда компилирует делегат который соответственно будет разбирать риггекс не риггекс в смысле входную строку согласно риггексу а может быть так называемый non backtracking то есть то если вы знаете что ваш риггекс разбирается так что вам не нужно по нему ходить обратно у нас был прям про это отдельный выпуск я пытался это все объяснить на пальцах то при создании такого риггекса он внутри попытается построить конечный автомат из на основе вашего риггекса чтобы по нему влить за линейное время быстренько матчить строчки так вот конечный автомат тоже строится не просто так он строится с некоторыми внутренними ограничениями то есть как пока количество нодов в этом конечном автомате меньше 10000 он будет строиться как конечный автомат как только он станется больше 10000 он будет переключаться в режим недоторминированного конечного автомата по сути вот обычного уже варианта риггекса все еще non backtracking поэтому есть некоторые оптимизации но все равно так вот в девятом дотнете увеличили этот лимит с 10 тысяч который по словам того был выбран ну просто просто был выбран случайно видимо накопился какая-то опыт какая-то статистика и теперь сделали 125 тысяч лимит соответственно non backtracking риггексы стали гораздо более предсказуемы по скорости на больших длинных на более сложных риггексах давай так скажу от длины входа это не зависит это зависит от сложности риггекса более сложные риггексы теперь смогут нормально обрабатывать non backtracking с более предсказуемым временем по энкодингу добавили некоторое количество новых тоже методов и классов есть мы про это рассказывали base64 кодировка теперь у нас есть base64 url там где плюсик и слэш заменены на соответственно подчеркивание минус по моему или минус подчеркнули в каком порядке а также добавили специальный метод в класс конверт под названием to hex string lower потому что очень часто нужно преобразование в 16 строчку и очень часто нужно преобразование в lowercase и многие кто писал to hex string точка to lower или даже convert to hex а потом remove короче если делать через bitconverter to hex то он выдает hex строчку но с этими дефисами после каждого двух символов их нужно было убрать и там даже в статье приводит что в принципе эти всякие tools очень часто и подсказывает именно такой вариант но теперь есть в общем самый оптимальный метод to hex string lower он вам выдаст нормальную 16-ричную строку в нижнем регистре и есть еще и аналайзер который задетексит два других варианта и скажет вот используй новый метод все хорошо ну и говоря про строки array и спана нельзя не упомянуть конечно же span params ключевое слово params теперь можно использовать со спанами, redone spanами и там бесплатный boost в performance просто из-за перекомпиляции на новый .NET если вы использовали какие-нибудь там string форматы еще в таком духе так ну дальше пошло уже совсем высокоуровневые штуки в коллекциях добавили новых оптимизаций в linq у нас уже были некоторое количество оптимизации если вы смотрели дебаж или когда-нибудь linq то вы могли увидеть всякие конструкции вида where select iterator то есть когда вы пишете коллекция .where .select это на самом деле linq внутри понимает что вы вызвали select после where и соответственно заменяет это на единственный итератор а не на несколько вот таких оптимизаций добавили гораздо больше одна из основных это order by first понятно что если делать наивным способом то order by сначала сортирует всю коллекцию first возьмет естественно первый элемент но если мы знаем что после order by мы вызвали first то на самом деле нам не нужно сортировать коллекцию нужно просто найти минимальный элемент в коллекции все это будет достаточно и вот таких вот оптимизации прям довольно много за счет чего linq ускорился еще немножко и стал кушать поменьше памяти в основных коллекциях изменений довольно немного там какие-то мелочи совсем косметические пожалуй самое большое это вот в словарях добавили этот самый alternate lookup про него тоже отдельно рассказывали лучше почитайте там текстом довольно неплохо рассказано зачем нам нужен альтернативный ключ для лукапов про компрессию мы в прошлом выпуске говорили про that leap ng на всех платформах теперь одинаковый криптографии очень давно уже тоже упоминали random.getitems который стал теперь быстрее выше сильнее который появился во первых позволяет вам выбрать случайный набор из имеющегося и там тоже интересно рассказано как оптимизировали performance в нетворкинге прошлый релиз по словам того был посвящен в основном скорости работы основном так сказать flow когда мы ужас когда у нас установлены соединений нам нужно дальше распаковывать запаковывать соответственно пакетики которые уходят туда сюда этот релиз был больше основан в смысле сфокусирован на том чтобы быстрее устанавливать соединений то есть первый инициал хэншайк его ускорили побольше там тоже еще пофиге оптимизировали ну и джейсончик тоже куда же без него джейсончик оптимизировали и нумчики быстрее сериализует почти не тратя памяти по возможности старается utf-8 строчки писать без дополнительных аллокаций в общем дальше там ближе к концу статьи было там а вот еще то еще это и там есть даже прям отдельный раздел то что талк не смог в принципе никуда отнести и там тоже пунктов 20 мне кажется про то что вот здесь получше тут получше получше короче после прочтения этой статьи возвращаюсь к основной мысли вот нету какого-то такого 1 2 3 изменений которые прям дали супер буст производительности в этом релизе посмотрим как конечно все это будет еще печаться на рекламироваться на дотнет конфи в ноябре будут ли нам снова показывать графики как мы обгоняем год жаву питон кого мы еще должны обогнать котлин там не знаю раз вот и насколько мы стали быстрее но пока кажется что вот мы реально в этом релизе собирали прям какие-то крупицы там крупицы здесь они все нужны они все полезные может действительно было полезно именно в этом релизе там не знаю сесть и ну сложно говорить все эти мелочи наверняка там еще осталось что-нибудь не пофикшены таки пофиксить сделать вычистить ну и ждем каких-то еще больших изменений хороших радостных и которые не за этом 50 процентов сложно увеличить уже производительность хотя кто знает кто знает может и можно ну и в
2891.04 2903.20 SPEAKER_00 любом случае это самый большой раздел и самый динамичный судя по всему остальному то есть это перфоманс в языке столько нет с дека нет корли бахни хрена нет а вот перфоманс всегда у нас
2903.20 2942.40 SPEAKER_01 большой красивый да но при этом видишь он большой и красивые в статье тауба ну смысле что действительно много чего видно что новый чего изменили но оно не настолько большое чтобы быть прям отдельными пунктами большинство из этого понятно что и некоторые какие можно было понять из рассказа мы про них рассказывали в течение превьюшек то есть какие-то пункты из этого попадали в превью ну типа там все речь в алиус вот попадали по моему эксепшены попадали мне кажется в какой-то момент но в целом они все настолько мелкие что вот такие рядовые превью они конечно там вносится то что все в арте один сделали но не попадают в релиз ноут такие большие которые мы обозреваем все как-то
2942.40 4043.80 SPEAKER_00 по мелочи да ну хотя бы работает уже счастье тут уж много не требуем давай посмотрим на очередную страничку эндрю лока и заодно раз разовьемся от микрософта эндрю лог нам рассказал каким же образом он генеид и публичный личный пи и как для чего он это делает прежде всего и так зачем вам зачем вам нужно отслеживать ваш публичный пи зачем нужны все какие инструменты и вообще в чем ваша проблема о которой может быть большинство из нас еще не догадывались и так прежде всего у вас есть какая-нибудь библиотека дотнетовская ваше дотнетовское приложение которое наружу выставляет какой-то и пи это может быть не обязательно в пи про который могли все подумать это может быть просто интерфейсы с помощью которых общаются разные приложения с вашей библиотекой там или базовой классы или еще что-то короче любые паблик сущности классы структуры типа делегаты которые торчат из вашей библиотеки наружу и вы распространяете до свой библиотеку допустим через nuget пакет и при этом у вас появляется куча проблем потому что вы должны быть очень осторожными как только вы выставили какой-то публичный метод или публичное свойство автоматически он считается публичным и пи это значит что просто так менять его не получится его когда вы его поменяете тот код который использует ваши методы классики интерфейсики этот код может рухнуть это называется breaking changes и вообще в дотнете принято следить за breaking changes для этого используется симпатическое версионирование которое нам обещает что если поменялась версия библиотеки мажорная то вот только тогда допустимой библиотеки breaking changes изменения если мажорная версия не менялась вы обязаны соблюдать ваше версионирование и вроде ничего такого страшного произойти не должно в теории что же такое breaking changes ну на во первых это может быть самая банальная вещь это когда вы просто меняете сигнатуру метода метод раньше принимал инт теперь начал принимать стринг ни с того ни с сего это естественно breaking changes но бывает еще и менее очевидный breaking changes это когда вы меняете поведение то есть сигнатура метода остается такая же точно но при этом внутреннее поведение абсолютно меняется может быть даже на противоположное и это тоже считается breaking changes но такую штуку мы рассматривать в этом в этой статье не будем потому что это практически impossible это вот на уровне на уровне людей тут никак автоматизацию не придумаешь и так про breaking changes ну я думаю вы понимаете что если мы допустим у нас есть какой-то интерфейсик и мы к этому или классик и мы добавляем к этому классику допустим новый метод у этого метода есть какой-то новый параметр который раньше не было то это может быть еще не считаться breaking changes да то есть добавление обычно это безопасная операция а вот если мы удаляем какой-то метод какой-то параметр или изменяем тип меняем или еще что-то меняем то это очень часто скорее всего считается breaking changes то есть вот это уже breaking changes с добавлением все же не так то тоже не так все просто потому что если мы разбираем например интерфейсы и к интерфейсу добавляем метод то это уже тоже breaking changes потому что от этого интерфейса кто-то вдруг в приложении мог пронаследоваться и как только вы к интерфейсу добавили новый метод не указав ему никаких там дефолтов то этот наследник может рухнуть вот поэтому тоже нужно смотреть в зависимости от и так ну опять же если мы представим что вы автор какой-то библиотечки и в вас торчит наружу какой-то публичный пи то наверное если это библиотечка небольшая следить за тем что вы не нарушили ничего публичными пи довольно просто а вот если вы уже автор какой-то большой библиотечке или фреймворка вот тогда у вас появляется куча публичных методов и вы случайно можете задеть там с помощью рефактинга или по незнанию в общем каким-то способом задеть задеть ваш публичный пи и это может привести к плохим непоправимым последствиям и именно поэтому вам необходимо трекать ваш публичный пи за ним как-то следить и желательно использовать для этого конечно же какие-то тулзы для автоматизации в частности первым кому пришла в голову такая мысль это был микрософт я имею ввиду конечно же не в мире первым а так в нашей инфраструктуре потому что первым делом микрософт для нас делал корси ларда делал нет фреймворк и он понимал что за публичным пи им нужно следить потому что как только он сделал бы какой-то случайный breaking change то рухнула бы просто половина разработчиков во всем мире поэтому он выпустил такой пакет который называется код анализе с паблик а пи аналайзер с то есть это специальный пакет который помогает вам следить за тем нарушили ли вы публичный пи или не нарушили сделали дали там breaking change или нет он работает следующим образом вы добавляете пакет в ваше приложение и при первом билде у вас посыпется куча ошибок это куча ошибок говорит вам что в вашем приложении есть куча эпиаев публичных эпиаев про которую вы этот инструмент не уведомили то есть он считает их новыми а раз он считает их новыми значит это там практически breaking change для того чтобы это поведение его привести в нормальное состояние как-то устаканить вы должны создать вашего в вашем проекте два файлика 1 называется паблик и пи шипт текст и 2 паблик и пи аншипт текст и в этих двух файликах необходимо будет сохранять все все публичные пи и таким образом управлять вот этим анализатором как же это работает вот как только вы два этих файлика создали теперь у вас есть там инструментарий например у аналайзеров есть какие-то экшены код фиксы с помощью которых вы можете публичные пи и ваши которые существуют в коде добавить в файлик аншипт текст и как только вы добавляете в этот файлик и пи анализатор сразу успокаивается он понимает что вы знаете про эти пи он понимает что они еще не аншипнутые и при этом никаких предупреждений больше не выдает можно добавить на уровне салюши на типа добавьте мне все что есть сейчас можно добавлять по отдельному методом который у вас там есть в общем как вам удобно то есть в результате вот этого добавления у вас в файлике паблик и пи аншипт текст и появляются сигнатуры публичных эпиаев и с этого момента аналайзер начинает их отслеживать как только вы добавите новые публичные пи в вашем вашем проекте аналайзер сравнит это с файликом если он там не найдет он срочно тоже выдаст вам эррор какой-то и вы должны решить что вы будете делать с этим эррором или добавить новый пи или уберете изменения в публично в публичном эпиае уберете breaking change для того чтобы из файлика паблик аншипт тексти ваши сигнатуры переехали в паблик опи шипт тексти вот для этого разработчик должен пойти и ручками это все дело перенести в общем такой алгоритм предполагался авторами андрю увидел в этом подходе проблемы давайте же подумаем какие прежде всего ему не понравилось что анализатор меня убивает ваше ваше вашу компиляцию как только он добавляет новый тип в общем да хотел он просто публичный тип добавить для того чтобы что-то попробовать в намерении в будущем его убить но они тут-то было анализатор начинает сыпать еррорами перестает компили компилировать приложение и ведет себя крайне агрессивно вот это поведение ему не понравилось естественно это все можно было диагностиками заглушить до какого-нибудь информейшена и например локально сделать информейшен а на си и сиди о системе какой-нибудь при во время билда уже можно сделать иров в общем но андрю посчитал это довольно большим минусом дальше вот эта структура с двумя файликами которые есть shift unshift txt кажется что вот эти два файлика они какие-то слишком бессмысленные тем более что один из них разработчик должен ручками там что-то переносить что-то поддерживать то есть как только вы кастомеру зарелизили этот api то его нужно перенести в другой файлик при этом в этом в предыдущем файлике оставить сигнатуру если вы друг не зарелизили в общем все это ему показалось слишком сложно и в принципе не нужно потому что у нас всегда есть гид а зная гид то есть зная по сути текущий api мы всегда можем просчитать дифф между unshift файликом и текущим и пиарим ну то есть нам этого достаточно нам не нужна вот эта трехступенчатая прослойка ведь нескольких файликов но опять же это придумал микрософт для себя и возможно в таком в таких больших проектах как дотнет фреймворк это было как-то целесообразно но для обычного прикладного уровня кажется что это оверки какой-то дальше не понравился формат файлов в котором это все дело сохранялась форматом действительно какой-то самовыдуманный с какими-то стрелочками еще что-то он читаемый то есть он там действительно текстим человека читаемый но опять же у нас есть c-sharp c-sharp прекрасен у нас и шарпе прекрасно описываются сигнатуры и типы и классы и зачем было выдумать что-то новое непонятно поэтому здесь тоже как бы поставил большой минус этому инструменту ну и так как есть пачка минусов которые не понравились товарищу автору разумеется он нашел альтернативу и альтернативой является проект который называется public api генератор это тоже open-source проект лежит на гитхабе и он наверное с одной стороны намного проще с другой да нет и с другой тоже проще что же эта штука делает практически все тоже самое но не берет на себя какие-то большие функции то есть единственная его задача которая выполняет этот генератор это выдать вам строчку стринг обычный стринг в котором содержится все сигнатуры по public api в которой эта штука нашла и дальше с этой строчкой вы можете сами делать все что хотите то есть он не пытается никакие там файлики записать никак там проанализировать вот там просто строчка и дальше не берет verify это библиотека которая предназначена для snapshot тестирования то есть по сути библиотека которая сравнивает одну одно состояние с другим нашем случае но он сравнивает один отчет со строчками о сигнатурах с тем с предыдущим отчетом которые были до этого с предыдущими сигнатурами то есть процесс в общем выглядит следующим образом генератор вот этот public api генератор берет сборку находят в этой сборке все публичные сигнатуры превращает эти все публичные сигнатуры в некий отчет выдает этот отчет в виде строки дальше мы используем библиотеку verify библиотека verify умеет уже сама сохранять файлик например файлик идеального шаблона который должен быть умеет сохранять его на диск а дальше уже умеет с этим диском с этим диском файликом сравнивать сравнение самого происходит в юнит-тесте то есть мы запускаем юнит-тест просим наши текущие сигнатуры сравнить с тем снапшотом который библиотека верифай сохранила у себя в файлике и смотрим поменялся у нас этот снапшот то есть соответственному файлу или не соответствует если вдруг мы видим что у нас сигнатуры не соответствуют то у нас есть два пути во-первых если мы считаем что да этот публичный пи должен был поменяться или должен был измениться нам необходимо применить эти изменения то есть подтвердить нашему инструменту подтвердить что это действительно разумное изменение мы хотели его сделать и давайте вы теперь запомнишь и больше не ругаться не будешь если же вы видите что это изменение случайное там в виде рефактор инга как-то присосалось или просто по ошибке кто-то поправил то вы можете откатить этот публику публичное изменение вашим пи то есть это все можно откатить и тогда тест тоже будет проходить заново успешно и красиво и если мы сравним с предыдущими проблемами которыми обсуждали то здесь их в принципе нет у вас нет падений во время билда потому что вся проверка идет в юнит тесте и юнит тест гораздо более гибок в этом плане с другой стороны конечно не знаете о ваших проблемах момент написания кода но кажется что это та вещь о которых в момент написания знать и не очень хочется в принципе в тесте это нормальное место у вас нет концепции с двумя файликами который шипт и аншипт потому что у вас есть один файлик который лежит в репозитории и который прекрасно управляется с помощью тестов и этот файлик всего-навсего один вам не нужно 2 и формат формат аутпут вот этой утилитки вот этого генератора он очень похож на c-sharp там прямо есть классики типы у этих классиков есть методы у методов есть понятные сигнатуры это все сгруппировано по нам с пейсом то есть смотришь прям просто прям как на красивую сборочку со сигнатурами читать такой файлик одно удовольствие тем более каким-то образом его еще и сравнивать и смотреть а что же по все-таки поменялось немножко разберемся по глубже с тестом как пишется сам тест довольно просто там всего-навсего три строчки во-первых вам нужно взять assembly из которой вы будете доставать публичные сигнатуры дальше скормить этот assembly нашему опи-генератору опи-генератор возвращает вам стринг и этот стринг отдаете библиотеке verify библиотека verify сама знает с файлы с которыми она должна этот snapshot сравнивать и сама сравнивает и если вдруг что вам об этом сообщает когда вы устанавливаете всю эту композицию всю эту конструкцию происходит практически то же самое когда вы начинаете сравнивать verify текущий snapshot библиотека создаст вам пустой файлик и зафейлит тест ну потому что в этом пустом файлике нет никаких сигнатур которые она уже знает для того чтобы эти сигнатуры туда добавить так же существует множество инструментариев там всяких плагинов еще чего-то анализа аналайзеров зеров экшен айтемов который файлик записывает все сигнатуры и после того как вы перезапустите тест он вас должен пройти все сигнатуры запишется и еще одно интересное свойство этой библиотеки verify заключается в том что как только тест будет красным то есть как только она начнет найдет не совпадение с тем что собирается проверить она попытается отыскать на вашей вашей системе дефтул которым вы пользуетесь то есть средства для сравнения двух файликов и покажет откроет вам это дефтул и вы можете эти два файлика прям визуально сравнить и посмотреть какие сигнатуры поменялись какие вы хотите оставить какие не хотите оставить общем все это тоже довольно удобно вообще библиотека verify она поддерживает глубокое сравнение например не только файликов и строк это слишком просто было бы например различных си шарп классов с большой вложенностью там с разными типами и так далее в общем если вам нужно сравнить два си шарп дерева то есть классов все шарпе в рантайме прямо вот эта библиотека тоже вам может подойти какие здесь у нее есть проблемы проблемы у нее в том что она не различает breaking это change или не breaking change то есть она вам показывает абсолютно любые change в сигнатурах которые произошли в публичных сигнатурах андрю не считает это проблемой он говорит что я лучше буду сам визуально контролировать я лучше буду сам осознавать breaking он или не breaking потому что не дело это утилитки решать на ломает это что-то не или не ломает я лучше знаю как бы может у меня там все настолько прекрасно сделано что даже изменение публичных сигнатур ничего не сломает в общем но с одной стороны да может быть он и прав теперь посмотрим что эту библиотечку на самом деле которая составляет сигнатуры она все-таки настраивается там то есть это не такая глупая библиотека которая просто принимает сборку и все у нее можно настроить различные параметры например какие типы она будет включать в анализ какие исключать по содержанию например какой-то строчки или например по нам спейсом по дефолту микрософт и системном спейсы в сравнение не включаются чтобы нам какие-то системные классы сюда тоже не городить а также например по дефолту эта библиотечка сохраняет всякие assembly level атрибуты которые вполне тоже могут привести к breaking changes например там assembly metadata ресурс language internal visible to target framework и так далее в общем например internal visible to вы не хотите сохранять для для того чтобы сравнивать их сигнатуры вы можете попросить в настройках игнорировать эти типы игнорировать эти атрибуты и они сохраняться соответственно не будут а также в настрой интересная опция настройки это вы можете вручную передать те типы которые она должна анализировать то есть не просто отдать ей сборку и она будет брать из сборки все что найдет а отдать список типов и уже этот список типа вы сами можете подготовить по каким-то любым вашим критериям например типа у которых есть особые атрибуты типа и какие-то которые каким-то образом называются особенно и так далее в общем имея вот эту настроечку в принципе можно довольно гибко использовать этот аппи-генератор для того чтобы туда передать именно то что у вас должно быть проанализировано и в том виде в котором должно быть вот такое решение для себя нашел в принципе довольно полезно следить за публичным следить за вашими клиентами что вы им ничего не поломали вам все скажут только спасибо поэтому если у вас есть такая задача если у вас большое сложное приложение если вы не хотите другим командам сломать жизнь то посмотрите на эти библиотечки можно взять вариант от микрософта если он вам ближе можно взять вот этот более легкий более понятный вариант который предложил эндрю но в любом случае процесс хороший процесс понятный и применять его следует здорово я что-то
4043.80 4061.44 SPEAKER_01 как-то признаться сейчас пока рассказывал пытался прикинуть нужно ли это было бы где-нибудь мне я что-то понял что вроде бы не нужно но наверное потому что мы не делаем библиотек для внешних каких-то клиентов давай так скажем так а для своих неужели вас нет для лейки который
4061.44 4066.00 SPEAKER_00 называть там утилс или комон или что там у нас еще или хэлперс и вы решаете между всеми
4066.00 4184.44 SPEAKER_01 своими проектами нет нет такого но то есть оно если есть то но все-таки все в рамках одного проекта и там как такого не нужно прям формального паблика не паблик ну то есть у нас все в нашем монолите все хорошо не ну если в монолите тогда да ну нет конечно же не монолит там есть общие нгетов это все но как-то пока хватает так сказать просто уследить глазами где мы меняем паблик айпи а и что с этим нужно сделать в каких местах вот ладно давай пойдем чуть-чуть дальше у нас есть это еще не все от майкрософта майкрософт у нас расстаралась и выпустила превью 2 вижу студии 7 вижу студии 20 22 17.12 превью 2 я все жду как они вот 17. все теперь навечно с нами или все-таки будет какая-нибудь 18 20 да скажи спасибо что не будет уже уже счастье ну да там тоже какое-то количество разных изменений как обычно не сгруппированы по стандартным плюс-минус заголовком это productivity и здесь есть очень важная штука прям супер супер фичи которые как бы вот уровня не знаю какого тоже там кстати мэдс кристенсен главный автор всех разных экстендеров прям постит в твиттер чуть чуть ли не каждый день типа вот это вот это а вот это вы как делать а вот вам тут какие варианты как вам тут разные варианты короче он там тоже очень активно продвигает все эти кастомизацию вижу студии через экстендж на потом затаскивание этого добра в основные настройки в общем в итоге теперь вы можно вот ты пользуешься вот этим возможности свернуть например тело какого-нибудь там цикла или тело и фа в студии через если ты вдруг студии когда ты был в студии слева в левом тулбарчик называется короче слева откуда
4184.44 4194.88 SPEAKER_00 где номера строк там можно сворачивать ну я в студии да но нет никогда не пробовал я предпочитаю все контролировать и все видеть я лучше проскрою чем не буду знать что там в эфи за страсть
4194.88 4209.84 SPEAKER_01 происходит вот а теперь короче вот эти вот индикаторы того что там есть какой-то коллапс текст можно кастомизировать можно тер цвет ставить поставь себе ярко красный чтобы если вдруг случайно свернешь хотя был ярко красный это точечка прямоугольничек не знаю не помню что там
4209.84 4216.24 SPEAKER_00 плюсик минусик в левой части но мне больше понравилось бы если бы эту функцию можно было просто
4216.24 4261.44 SPEAKER_01 выключать можно выключить мне кажется но я не уверена 100 процентов дальше соответственно можно теперь обновлять результаты поиска в результатах поиска теперь появилась кнопочка где можно сказать обновить поищи заново добавили возможность убрать из нижнего тулбара под файликом некоторую доп. информацию относящийся код лензам за счет чего знаешь что изменится ну-ка ну-ка будет больше места для горизонтального скроллбара ты страдал что у тебя мало места для горизонтального скоба скроллбара в исходниках счастью не приходилось вот а вот это важная
4261.44 4275.24 SPEAKER_00 фича даже в релиз ноутс попала ну я лензами если и пользуюсь очень редко кстати их обычно выключаю чтобы тормозили зря а я их делаю с права текста они не сверху держу именно справа нет
4275.24 4286.28 SPEAKER_01 а там именно какие-то файл левел штуки которые внизу короче отжирают место от скроллбара и у тебя там типа на скроллбара приходится совсем мало пикселей но блин как бы нафига тебе скроллбар в
4286.28 4293.40 SPEAKER_00 поди горизонтальный не знаю как-то обычно ты программируешь на маленьких мониторов может быть
4293.40 4330.94 SPEAKER_01 на телефонах на планшетах может кстати конечно когда еще кое-нибудь диф открыт два файлика рядом там совсем мало места ну может быть иметь смысл ну не знаю у меня особо не было проблем дальше код клинап на сейве помнишь ты когда-то давно а ты по моему райдера допросил эту фичу лил студии короче чтобы при сохранении можно было автоматически запускать код клинап да полезная штука да она есть она была теперь она асинхронная смысле не блокирующая то есть она мгновенно тебе возвращает управление может дальше печатать она пока код почистит не знаю как это соотносится с тем это до
4330.94 4337.24 SPEAKER_00 сейва происходит после сейфа это хорошо что сейв я хочу синхронно сделать и перед ним я хочу убедиться
4337.24 4389.04 SPEAKER_01 что он отформатировался по-английски это называется он блокинг код клинап он сейв короче я не очень понимаю нет вероятно он все-таки сохранить сначала почистит сохранит но потом что еще раз но да тебе не хочу два но да тебе продолжить редактировать если очень надо то есть если просто дежурно нажимаешь control s чисто чтобы это сохранилась до на всякий случай и дальше продолжать печатать бешеной скоростью но ты продолжишь это не будешь ждать так да но я же хочу сохранить клян опченый код ну храни кто же тебе мешает ну как оси на синхронный кляна не мешает ну вот они пишут что когда у тебя во время сейва раньше запускался код клинап ты вообще ничего не мог делать в дне ну просто совсем вот не ну и проблема понятно клян опыта тяжелая
4389.04 4399.56 SPEAKER_00 операция как бы сохранение должно быть быстро но просто они должны были решиться что ты сохраняешь тогда без клинапа а клянап делаешь уже после сохранения на вас скорее всего не то
4399.56 4417.08 SPEAKER_01 что хочет не то что ожидает пользователь но вот даже следующее предложение меня немножко точнее тебя должно пугать она говорит что процесс клинапа будет запущен в бэкграунде и будет автоматически отменен если ты продолжишь таппинг так мы это делаем для того чтобы ты успел
4417.08 4421.92 SPEAKER_00 быстрее потапить после этого но будет отменен если ты будешь быстрее таппить ну типа короче я
4421.92 4498.48 SPEAKER_01 непонятно да типа не знаю как это соотносится с тем что же будет сохранено в итоге будет ли отменено сохранение нажал контроль тут же начал печатать от тебя это ты начал печатать не будем сохранять тогда что сохранять лишний раз короче непонятная фича надо побольше будет почитать может какие отзывы будут не знаю дальше ну там из гитхаб копайл там конечно много всяких интеграций ну и ай смарт варией был инспекцион еще ладно там как-то но по-умному смотрит на переменные хотя не знаю следующее фича дебаг тест витгет хапка пайлот по скриншотам выглядит примерно следующим образом ты такой типа у тебя чем-то палос эксепшен у тебя валится такой окошечко чата там говорят ну смотри чувак у тебя эксепшен такой печатаешь в чат что делать будем сейчас говорит ну смотри надо поставить брекпоинт и запустить дебаггинг типа поставил брекпоинт молодец запускай дебаггинг останавливаться на брекпоинте чат такой круто мы остановились на брекпоинте теперь давай думать почему она тут падла короче такой
4498.48 4506.28 SPEAKER_00 как бы похоже на уточку для которой ты задаешь вопрос она и сам себе на них отвечаешь да по
4506.28 4510.16 SPEAKER_01 скринкасту выглядел как-то очень странно но не знаю может быть там ну какая-то польза может
4510.16 4516.40 SPEAKER_00 быть есть особенно начинающих но типа джун не знает как ставить брекпоинт да где вот там он
4516.40 4533.44 SPEAKER_01 может действительно ну есть хам может сидеть на копайл подумайте сказать смотри пока поставим здесь и посмотрим в принципе может быть действительно полезно для обучения начального а вот последний это вообще и я и пауэрт айнумер был визуалайзер не ну а и номер был там очень
4533.44 4547.76 SPEAKER_00 много можно чего заповедить для этого но там были даже экстеншены всяких студий к райдеру которые добавляли коллекциям различных фильтры сортировки выборки и так далее но тут нормуль ну
4547.76 4577.48 SPEAKER_01 короче может быть может быть но в общем основная фича которые не говорят это можно короче теперь текстом написать вот ну айнумер визуалайзер это штука просто в окошечке в грязи покажется режим этого твоего айнумера был и дальше рядом в чатике можно написать ати текстом а теперь хочу это пофильтровать погруппировать и вот так вот значит короче поселектить и отсортировать и он сам тебе линку запрос напишет и выполнит ну неплохо можно те линку запрос такой главное
4577.48 4581.48 SPEAKER_00 что потом там формат цель куда-нибудь не встанул в этот линк запрос ну это уже как повезет
4581.48 4662.40 SPEAKER_01 там чат гпт и майкрософт openai ответственность не несут вы делаете все на свой страх риск вот это все подписывали лицензионное соглашение и все только про еще деньги на платите да дальше дебагинг диагностик там короче по счетчикам которые гистограммные добавили отображение с гитам с гитом поддержали мульти репа для гит хаба и рейдж диопса и также для гит хаба ежер диопса добавили полезнейшую фичу я прям очень часто пользуюсь ну правда в индейе там плагинчик для этого есть это копий гит линк это выделяешь кусочек кода и говоришь значит дай мне ссылку и он тебе как гирит ссылку на гит хаб который ты можешь послать коллеги если коллега перейдет он попадет ровно эти строчки да я тоже часто пользуюсь гениальная штука вот это прям очень удобно да то особенно спрашивать типа где вот это найти ну себя в студии там или в райдере или еще где находишь копируешь ссылочку и посылаешь чатик вот тут найдешь а дальше потому что сам пусть разбирается нужна еще обратная фича когда ты такой типа в студии в райдере еще где-то куда-нибудь какую-нибудь диалогу эту ссылочку вставляешь и он тебе автоматически
4662.40 4681.60 SPEAKER_00 навигейте в это место надо следующий как у решапера всегда был со стектрейсом если он обнаруживает я в клеймборде стектрейса у тебя сразу предлагает там по нему по навигейтится вот такая же ту штука если есть ссылка который ты понимаешь что это на твой репозиторий с твоим файлом и на твои строчки значит надо туда спозиционироваться но и может быть бранч зачекалочить
4681.60 4769.12 SPEAKER_01 нужно например если надо это кстати не обязательно может быть опциональной штука может предложить да не хотят так в самой идее добавили что если вы меняете тему там светлый на темную вас сохранятся настройки шрифта теперь но потому что казалось бы действительно темы там для клауда какие-то изменения и раб сервис и если вы пользуетесь http файлами это такие текстовые файлики которые позволяют хранить http запросы их исполнять обычно хранятся в файликах с оширением точка что то то теперь в них добавили возможность использовать так называемое общая крыша от инвалида общее окружение то есть напомню что вы можете задать несколько окружений там пишется отдельно специальный джейсон файлик где вы определяете значение каким-нибудь переменным и потом когда вы выполняете запросы вы можете выбрать в каком окружении они выполняются и для запросов будет подставляться значение из этих переменных если у вас есть например какой-нибудь какая-нибудь переменная которая должна быть у всех плюс-минус одинаковое во всех окружениях и например переопределяться только в одном окружении то теперь есть специальное так называемое шрифт окружение в котором можно ее задать джейсончики отдельное просто поле ну секция точнее да и она будет использоваться по умолчанию если не переопределена в каком-то конкретном окружении принципе удобная штука может быть вполне но вот такие дела студии потихонечку движется вперед
4769.12 5330.72 SPEAKER_00 тоже как-то без всякого прорывного но наш ответ постману типа того да так еще есть интересная статичка от джимми богарта я напомню что у нас целых три раздела уже прошло про джимми богарта товарищ не сидит без дела он мигрирует большой дотнет проект с легасей дотнет фреймворком четвертым на самый последний на из наилучший кор нами написание статьи конечно же и постепенно выпускает статички о том как он это делал как он переносил статьи хорошие интересные глубокие из много практических кейсов с которыми сталкивается в серии о которых мы почему-то мало кто говорит и вот заключительная серия вышла в нашем случае это уже четвертая часть где мы обсуждаем если вы хотите найти предыдущие то последний раз мы об этом говорили в выпуске девяносто восьмом а там найдете следующие статьи если хотите кратко напомню что у джимми было приложение на дотнет фреймворке со всеми его легаси зависимостями какими-то там сборками какими-то там еще наработками и при ним стояла задача перести это все на кор на восьмой кор на тот момент последний последний стабильный релиз и он постепенно по компонентам рассказывает а с чем он сталкивался что он делал как обходил как подходил в частности ему очень сильно помогла библиотечка который называется систем веб адаптерс в принципе там наверное 80 процентов всех проблем он решал с помощью нее в частности он с помощью нее сделал сессии которые транслировал на удален на удаленное приложение он с помощью нее сделал аутентификацию и естественно огромное количество всяких адаптеров middle varia в общем все что есть в сп также мы в предыдущих статьях в предыдущих выпусках обсудили прекрасный паттерн душитель который помогает вам как раз таки побороть какое-то огромное здоровый legacy наследие и постепенно не останавливая его работу не удаляя за раз постепенно переводить всю функциональность какой-то новый слой и он его тоже прекрасно писал на различных примерах мы посмотрели как выделялась там расширенная сборка как переносилась бизнес логика вот это вот все поэтому предыдущие выпуски были интересны и на последний выпуск на последнюю статью он оставил самое замечательное это как в конце концов все это завершить в предыдущем в предыдущей статье он обсуждал как переносить middle varia и здесь у него там остались какие-то контроллеры но он сказал что принципе миграция контроллеров после того же перенесли там все middle varia все аутентификацию то есть такие базовые базовые проблемы которые наверняка бы с каждой из вас столкнулся чем остались просто пользовательские контроллеры ну и он говорит что принципе пользовательские контроллер мы перенесли без особых проблем никаких специфик для конвертации там нет просто там пофиксили namespace и вот и все и все заработало но самая большая проблема была это все это протестировать потому что там была какая-то логика в этих контроллерах должно было все работать правильно сохраняться правильно возвращаться пользователю поэтому основной упор у нас был на тестирование тут принципе особо рассказывать нечего и теперь пора нам это все дело глушить что глушить прежде всего у нас на старом приложении я напомню у нас осталась сама аутентификация сам процесс аутентификации но при этом на новом приложении на уже на core там работал специальный проксик который прокидывал все все аутентификацию на старое там она делалась и на новом пользователь считался одобренным красивым и хорошим такая же ситуация у нас была и с пользовательскими сессиями теперь мы должны эту аутентификацию на старом приложении выключить удалить убить и в новом приложении убрать вот это проксирование чтоб мы больше не ходили к старому мы уже должны сделать аутентификацию на новом приложении в новом это все делается там легко с помощью двух стандартных строчек как бы здесь проблем никаких нет и поэтому в старом приложении до больше аутентификации нет затем мы должны из там были еще связаны middleware которые которые вот эту аутентификацию поддерживали в общем их тоже должны удалить после этого нас еще остается сессии которые точно так же ходили на удаленное приложение сессии мы должны отключить то есть больше мы не должны ходить на удаленное приложение за сессиями и в принципе на этот на этот момент когда мы убрали удаленную аутентификацию когда мы брали удаленные сессии мы уже можем и убрать из нашего из нашего проекта наш самый главный пакет это систем вэп адаптерс вэп адаптерс можно теперь выкинуть все прокси которые как раз-таки на дистанционное приложение ходили тоже можно выкинуть и дотнет приложение без всех прокси должен должен теперь сам обрабатывать все реквесты то есть ничего редирект ничего пересылать он не будет вот такое последнее изменение мне все-таки хотелось чтобы он был сделано как-то более плавно потому что на самом деле пока мигрировалось вот это приложение на процессе всего этой цикла статей пользователи не чувствовали никакой разницы то есть вся их аутентификация оставалась на месте она прокидывалась оба приложения все сессии у них оставались на месте они прокидывались оба приложения то есть для пользователя было абсолютно все прозрачно но в этот момент когда он нам предложил просто удалить как бы старое приложение с сессиями и удалить старое приложение с аутентификацией нужно понимать что он никаким образом не перенес ключи шифрования он никаким образом ну по крайней мере он об этом не написал он не перенес какие-то сохраненные сессии у пользователя он не принес не перенес какую-то работу с куками на которую он жаловал жаловался в прошлых проще их статьях то есть по факту все пользователи останутся без своих сессий и без аутентификации они должны будут или петь они должны быть перелогиниться прежде всего вот наверное это не очень большая проблема по сравнению с теми гигабайтами которые он ворочал но все же можно было бы это сделать как-то и красивше можно было бы это сделать совсем для пользователей незаметно ну понятно ладно сделал так сделал пойдем дальше что нам нужно ну во первых теперь вот это dotnet 8 красивое приложение со всеми отрезанными хвостами от старого legacy фреймворка мы должны задеплой на продакшен мы должны активно его мониторить при этом из 48 с продакшена еще не удаляем мы должны мониторить активность 4 8 мы должны убедиться что мы ничего не забыли и в 4 8 никакой активности нет запросы не приходят ответы не возвращаются в общем оно никому не нужно если вдруг это не так мы быстренько подпиливаем дотнет 8 для того чтобы он все-таки на 4 8 ничего не отправлял ничего не пропускал когда мы убедились что 4 8 нам уже совсем не нужен все запросы прекрасно живут в нашем корп кор аппликейшене подходит время окончательной очистки мы должны удалить из репозитория все остатки старого legacy приложения до 4 8 мы должны удалить и остатки из дотнет 8 всяких проксей бриджей шимов короче вот все что мы делали для того чтобы на момент перехода для пользователя все все казалось незаметным дальше у нас идет удаление старого приложения из системы сборки и системы диплоя а также и сосис и удаляемые ресурсы продакшена которые были тоже отведены под старое приложение то есть все по идее у нас больше старом приложении ничего нет никто ничего не знает и в случае в случае джимми богарда он заливал заливает в гид изменения очень прекрасное который добавляет 0 строчек и удаляет минус полмиллиона строчек это вот как раз вычищение старого приложения из гид репозитория это вот последний шаг который можно было сделать что же дальше напомню что вся концепция строилась вся концепция миграции этого приложения строилась лишь на том что наша задача стоит перенести на новую версию фреймворка не было задачи улучшить не было задачи пересмотреть существующие решения не было задачи каким-то образом перевести на новые модные технологии все в общем это все исключалось только для того чтобы просто изменить версию фреймворка и все а теперь пришло время как раз заняться всеми этими вещами нужно пересмотреть архитектуру адаптировать новые какие-то middleware и прав на обновить все библиотеки до новых последних версий и в общем чувствовать себя как хорошее новое современное приложение поэтому если вдруг у вас на проекте все еще есть большое старое монструозное dotnet фреймворчное приложение и у вас есть шанс что его можно каким-то образом переписать то попробуйте для начала знакомиться со статьей джимми богарда он дает очень много полезных советов и рассказывает об очень многих интересных подводных камнях на которых он споткнулся ну и кажется что действительно это те практически вещи которых нам не хватает в обычных статьях о том а как же правильно мигрировать ну да мне
5330.72 5344.52 SPEAKER_01 кажется к вопросу о том что для пользователей это может быть не очень прозрачно мне кажется что это может надоело просто сколько мы эти статьи уже почти ну не год но полгода точно читаем ну
5344.52 5349.08 SPEAKER_00 да да скорее всего там кома команда уже настолько замышлась что лишний раз перелогин пользователя
5349.08 5452.68 SPEAKER_01 не такая большая для них и задача да а может нам просто не рассказали пользователей так уже раз 20 там успели перелогиниться пока они там все это пытались красиво сделать в статье потом красиво описывается вот смотрите как здорово по факту тому что это все было плохо на правде непонятно но в общем действительно подход по крайней мере обзор подхода хороший из него можно много полезного почерпнуть насколько вы его в таком виде или в адаптированном примените у себя надо смотреть в каждом продукте по-своему ну чем последняя кратко о разном у нас тут всего две новости с одной закругляемся с одной стороны мы я сегодня уже про расширение рассказывал и вижу студия extensibility package 17.11 тоже обновился если вы вдруг пишите решение или вам друг интересно попробовать можно глянуть там насадили прикольные всякие штуки добавили напомню что в современной вижу студии экстенджины почти все исполняются аутов прок то есть они работают в отдельном процессе возникает вопрос а как же показывать окошки как же там сеттинги и вот это все и вот как раз это обновление добавляет поддержку сеттингов для аутов прок расширений и добавляет поддержку показа ремонт вая так называемого вы теперь пишите в пфные контроллы в своем экстенджине и они магическим образом показываются восстановить же у студии несмотря на то что ваш экстрим заработает аутов прок ну и туда же какие-то линдуту бар и вот это все короче если пишите решение это довольно интересное обновление но я не знаю мне кажется что среди наших слушателей не так много таких людей но почему нет наверняка найдутся то есть есть у нас на метапчики приходили
5452.68 5515.44 SPEAKER_00 люди которые решение для visual studio писали я думаю полезно будет а мне понравилась ссылочка сегодня сергей бедзенков скинул в чатик просто шикарная потому что очень часто возникает в профильных чатах вопрос а жив ли ли вообще дот нет мою а что вместо него взять там а что у нас юаем а где кросс платформину и все такое и сергей нашел классную ссылку которая так и называется из мауи дед точка нет все просто читается из ссылки что это такое такой небольшой дашбордик который примерно меряет количество пул реквестов количество контрибютеров за какое-то последнее время количество звездочек смотрит когда был выпущен последний релиз и делает на основании этого вывода мертв дот нет мою или не мертв ну и в данном данном случае прям на текущий момент когда мы записываем подкаст статус ноуп то есть по идее не мертв пока живой но тут тоже он так немножко
5515.44 5528.48 SPEAKER_01 непонятно считать потому что вот дашбордик говорит типа лысый три лист релиз один дей го а если кликаешь на ссылочку там написано лист 3 days ago и поэтому тут возникает вопросики как же он
5528.48 5546.28 SPEAKER_00 считает на самом деле ну написано что он считает каждые сутки 24 часа но наверное это любительская поделка погрешность плюс минус сутки тоже поглядим поглядим в общем такой да фановый сайт если вдруг у вас кто-то лишний раз спросит вот хорошая полезная ссылочка да ну а на этом наверное все
5546.28 5602.00 SPEAKER_01 надо заканчивать сотый выпуск получился на это примерно таким же как у нас получается последнее время часа полтора получится после всех отрезаний оговорок и прочих на монтаже моментов мы успели поговорить про дотонт 9 релиз кандидат 1 про то как вы спайр запускаете в assembly программки в качестве таких контейнеров аналогов докеру поговорили про большую статью performance improvement за 9 дотнете от стивена тауба узнали как нам жить если мы хотим явно трекать что у нас является паблик апи в нашем коде посмотрели на 1 на превью 2 студии 22 и завершили цикл статей богорода про миграцию со старого фреймворка на новый да да кажется все давай
5602.00 5652.96 SPEAKER_00 закругляться я напоминаю что это было радио дотнет у нас можно смотреть слушать заходить на boost и кликать и все такое и кстати как раз при пришел обсуждали что у нас на apple подкастах всего два голоса то есть вот эти 2 2 героя конечно за нас проголосовали пятерочками небольшие молодцы но два голоса это совсем мало мы никакие рекомендации таким образом скорее всего не попадем поэтому если вдруг у вас есть яблочные девайсы пожалуйста зайдите поставьте нам оценочку можно даже комментарий написать какой-нибудь и всячески вообще везде наш лайк и тире постите шарьте рассказывайте друзьям будем будем расширяться а и слушайте слушайте интересные новости если есть ссылочки тоже присылайте мы с радостью все читаем все анализируемся смотрим и добавляем
5652.96 5665.36 SPEAKER_01 некоторые выпуски в отсутствие больших большого количества новостей от майкрософт всякие такие ссылочки от вас могли бы быть очень полезными и это шанс обсудить именно то что хотите вы это
5665.36 5668.12 SPEAKER_00 точно там до новых встреч всем пока всем пока
