0.00 9.04 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Радио.нет, выпуск номер 25.
9.04 11.60 "Анатолий Кулаков" И сегодня в студии Анатолий Кулаков.
11.60 12.60 "Анатолий Кулаков" И Игорь Лабутин.
12.60 13.60 "Анатолий Кулаков" Всем привет.
13.60 18.72 "Анатолий Кулаков" Мы хотели бы поблагодарить всех наших патронов, их с каждым выпуском становится все больше и больше.
18.72 19.72 "Анатолий Кулаков" Спасибо вам большое.
19.72 21.56 "Анатолий Кулаков" И отдельная благодарность Александру.
21.56 23.32 "Анатолий Кулаков" Спасибо всем, кто нас поддерживает.
23.32 29.24 "Анатолий Кулаков" Если вы не знаете, о чем речь, заходите на наш сайт и на Boosty и Patreon, ссылочки будут в шоу-нотах.
29.24 31.68 "Игорь Лабутин" И теперь давайте переходим уже к выпуску.
31.68 34.24 "Игорь Лабутин" Начнем мы как обычно с новостей про .NET мир.
34.24 38.56 "Игорь Лабутин" У нас .NET 6 полным ходом движется к релизу, который состоится в ноябре.
38.56 45.60 "Игорь Лабутин" И вышел .NET 6 Preview 2 со всеми причитающимися дополнениями в виде SP NET Core и Entity Framework.
45.60 49.60 "Игорь Лабутин" И давайте быстренько пробежимся по тому, что же там появилось.
49.60 65.68 "Игорь Лабутин" Во-первых, в статье анонс, как я уже говорил в прошлый раз, теперь рассказывают не только про непосредственно то, что вошло в .NET 6 Preview 2, но и про какие-то более большие топики, или эпики, как хотите, называйте, над которыми работает Microsoft.
65.68 67.92 "Игорь Лабутин" Они это называют Theme, темой.
67.92 71.28 "Игорь Лабутин" И в этой статье обозреваются два момента.
71.28 74.72 "Игорь Лабутин" Момент первый называется Improve .NET Inner Loop Performance.
74.72 81.16 "Игорь Лабутин" И это про то, что вообще говоря, Microsoft очень много делает Performance Improvement для самого рантайма.
81.16 88.76 "Игорь Лабутин" Мы это огромное количество раз обсуждали, как-то все стало у нас быстрее, как мы в Tech Empower Benchmark сильно всех опережаем и так далее.
88.76 98.64 "Игорь Лабутин" Но это все здорово, но мало чтобы код работал быстро, неплохо было бы, чтобы разработчикам было удобно, и весь цикл разработки тоже был очень быстрым.
98.64 104.56 "Игорь Лабутин" И здесь пионером этого дела выступает Стивен Тауп, который всем все это драйвит.
104.56 108.80 "Игорь Лабутин" И здесь как раз-таки появилось очень много улучшений и будет появляться.
108.80 118.32 "Игорь Лабутин" Основной фокус нацелен на Performance непосредственно стартапа приложения, работа MS Build, работа .NET командной строки, всех тулов и так далее.
118.32 119.32 "Игорь Лабутин" Проблема в чем?
119.32 133.28 "Игорь Лабутин" Что все те улучшения, которые были в S/P/A, .NET и просто в .NET в рантайме за последний год или даже больше сделаны, во многом касаются именно стабильного режима работы, когда у нас все устаканилось, прогрелось и нормально работает.
133.28 140.72 "Игорь Лабутин" Тут, конечно же, помогают всякие киши, там всякие многоуровневые компиляции, Second Tier и так далее.
140.72 143.52 "Игорь Лабутин" В стартапе такого не может быть.
143.52 157.56 "Игорь Лабутин" Когда вы что-то подправили в коде, запустили приложение, посмотрели, остановили, подправили в коде, запустили, посмотрели, ни о каком кешировании речи особо не идет, потому что все время все запускается с нуля.
157.56 168.72 "Игорь Лабутин" Поэтому работа в этом направлении ведется и некоторые улучшения, которые уже делаются и некоторые уже завершены, включают в себя следующие штуки.
168.72 174.80 "Игорь Лабутин" Во-первых, постарались убрать как можно больше ненужного джета для тулов, которые запускаются.
174.80 180.00 "Игорь Лабутин" Джит довольно много всего компилировал, как выясняется, и можно было сократить это время.
180.00 187.20 "Игорь Лабутин" Это, конечно, миллисекунды, если не микросекунды, но тем не менее, по чуть-чуть, по чуть-чуть в итоге дает какие-то хорошие проценты.
187.20 200.76 "Игорь Лабутин" Дальше убрали ненужный логин, он был выключен с точки зрения логлевела, но несмотря на то, что при обычном логлевеле все эти сообщения не писались, они все равно отжирали какое-то количество ресурсов, ну, видимо, не очень оптимально было написано.
200.76 203.32 "Игорь Лабутин" Добавили какое-то количество оптимизации в MS Build.
203.32 209.16 "Игорь Лабутин" Мы уже рассказывали про всякие оптимизации работы со строками в MS Build и всякие другие штуки.
209.16 217.08 "Игорь Лабутин" Сейчас улучшили работу с поиском файлов на диске, тоже довольно частая операция для MS Build, так что должно стать чуть-чуть побыстрее.
217.08 227.84 "Игорь Лабутин" И, по-моему, мы это уже затрагивали в SPNet, Razer переписали на использование сурс-генераторов, тоже должно стать побыстрее и более нативно для современного .NET.
227.84 229.68 "Игорь Лабутин" Но это все хорошо.
229.68 236.68 "Игорь Лабутин" Лучшая оптимизация для того, чтобы код выполнялся быстро, это, как известно, не выполнять код и сделать все как-нибудь другим способом.
236.68 241.16 "Игорь Лабутин" Поэтому основной топик, над которым они сейчас работают в этом направлении, это .NET Hot Reload.
241.16 259.28 "Игорь Лабутин" Мы это уже упоминали в контексте Blazor, где это работает, но сейчас это дело потихонечку продвигается на весь остальной .NET, то есть вы сможете, ну, до некоторой степени, конечно, менять код в Visual Studio и без перезапуска программы оно продолжит работать уже с измененным кодом.
259.28 268.84 "Игорь Лабутин" Понятно, что тут уже как раз-таки нету всех накладных расходов на изначальный запуск, полный JIT всей программы, того, что нужно при самом начале запуска сделать и так далее.
268.84 275.44 "Игорь Лабутин" Будет быстрее и гораздо лучше смотреть все какие-то такие мелкие изменения и сокращать девелопменты.
275.44 279.88 "Анатолий Кулаков" Это в этом превью уже можно посмотреть или они только его декларируют?
279.88 293.40 "Игорь Лабутин" Нет, Hot Reload сейчас еще пока в процессе работы, он требует огромного количества изменений, то есть это и JIT нужно поменять, это и рантайм нужно поменять, и фреймворк нужно поменять, поэтому там все пока еще не настолько готово, чтобы работало.
293.40 299.88 "Игорь Лабутин" И, по-моему, даже они говорят, что, может быть, они в шестом .NET все не успеют сделать, но до какой-то степени они должны работать.
299.88 301.44 "Игорь Лабутин" Хотя бы что-то посмотреть.
301.44 303.04 "Игорь Лабутин" Да, ждем следующих превью.
303.04 319.04 "Игорь Лабутин" Второй момент, но мы про него уже тоже много раз говорили, топик для этого .NET 6 релиза, это про то, чтобы в .NET появился, как они называют, great client app experience, то есть мы бы стали лучшей платформой для разработки клиентских приложений.
319.04 323.92 "Игорь Лабутин" Но это все то же самое, про кучу платформы, MAUI, Blazor и так далее.
323.92 345.96 "Игорь Лабутин" И основная девелоперская фишка, которые здесь работают, это упаковка, собственно, этих приложений, то есть понятно, что если вы делаете для Android, вам нужно запаковать в APK, если вы делаете для iOS, вам нужно запаковать в какой-то формат у iOS, если вы делаете при этом для Windows, то одно, для Linux третье, веб четвертое, ну и так далее.
345.96 357.60 "Игорь Лабутин" Вот они работают над тем, чтобы сделать более удобную всю эту работу, чтобы пэкэджинг сводился к каким-то более простым действиям и не требовало огромного количества времени.
357.60 358.60 "Игорь Лабутин" Посмотрим, что получится.
358.60 359.60 "Анатолий Кулаков" Неплохо.
359.60 361.60 "Анатолий Кулаков" Ну а все-таки по существу, что нового?
361.60 362.60 "Игорь Лабутин" Что нового?
362.60 369.24 "Игорь Лабутин" В .NET библиотеке, в основном .NET, так скажем, несколько изменений больших.
369.24 386.40 "Игорь Лабутин" System Text JSON теперь поддерживает игнорирование циклов, то есть если вы попытаетесь десериализовать или сериализовать объект, который в памяти лежит с циклом, то в результирующий JSON попадет null, если передать специальную опцию ignoreCycles.
386.40 394.76 "Игорь Лабутин" То есть он не будет бесконечно вкладывать объект в объект в объект в объект, он просто как только задетексит цикл, сразу напишет в это поле null и все.
394.76 396.88 "Игорь Лабутин" Добавился новый тип Priority Queue.
396.88 406.64 "Игорь Лабутин" Это такая обычная очередь, но ее можно параметризовать не только типом объекта, который в ней лежит, но еще и вторым типом, по которому будет считаться порядок.
406.64 421.44 "Игорь Лабутин" Например, туда передать int, после чего будет возвращаться из очереди объекты в порядке, чем меньше вот этот вот приоритет, тем первее она будет выдана из очереди, как этот очередной элемент.
421.44 434.64 "Анатолий Кулаков" Вот кстати, с очередью у меня какие-то большие вопросы, потому что на самом деле она называется очередь, но если вдруг вы туда положите два элемента с одинаковым индексом, то вернутся они в абсолютно непредсказуемом и не в гарантированном порядке.
434.64 436.84 "Анатолий Кулаков" И вот это уже как-то слабо похоже на очередь.
436.84 437.84 "Анатолий Кулаков" Да, она такая же.
437.84 438.84 "Анатолий Кулаков" Почему у них такое поведение-то?
438.84 443.88 "Игорь Лабутин" Ну вот не знаю, скорее всего это какая-то особенность внутренней реализации, что они решили так сделать.
443.88 450.72 "Игорь Лабутин" Почему назвали при этом queue, ну не знаю, могли бы назвать это не знаю, priority bag или еще как-то, не знаю.
450.72 455.60 "Анатолий Кулаков" Да, мне кажется priority bag сюда подходит на гораздо лучше, чем queue, потому что вводит в заблуждение.
455.60 458.16 "Анатолий Кулаков" Наверняка с этим будет много вопросов на Stack Overflow.
458.16 468.88 "Игорь Лабутин" О, тут небольшой off-topic, не знаю, видел ты или нет, про есть GitHub issue про введение отдельного типа для времени и отдельного типа для даты.
468.88 473.40 "Анатолий Кулаков" Нет, не видел, но мне кажется, John's Kid это чуть ли не с первых версии дотнета уже предлагал.
473.40 477.24 "Игорь Лабутин" Вот, смотри, у нас же есть тип там, date time, да?
477.24 479.24 "Игорь Лабутин" Как бы ты назвал тип для даты?
479.24 480.24 "Игорь Лабутин" Дейт?
480.24 481.24 "Игорь Лабутин" Внезапно, да, дейт.
481.24 485.48 "Игорь Лабутин" Есть большая проблема, дейт - это резервированное ключевое слово в Visual Basic.
485.48 488.36 "Анатолий Кулаков" Почему это мешает назвать точно так же тип?
488.36 490.60 "Анатолий Кулаков" Я так понимаю, что тип можно-то назвать.
490.60 493.96 "Анатолий Кулаков" Например, System String у нас есть тип и есть ключевое слово
493.96 500.20 "Игорь Лабутин" string. Я могу ошибаться, возможно, это не ключевое слово, там звучали какие-то слова про то, что это какой-то стандартный alias или так далее.
500.20 505.56 "Игорь Лабутин" Короче, дотнет команда считает, что если назвать его дейт, то это не будет работать в VB.
505.56 508.84 "Анатолий Кулаков" Ну, мы, наверное, сильно от этого не пострадаем, мне кажется.
508.84 509.84 "Анатолий Кулаков" Ну, пусть да, пусть не работает.
509.84 524.80 "Игорь Лабутин" Я, короче, прочитал GitHub issue, там нет, судя по всему, они довольно настроены серьезно и половина аудитории говорит, блин, да, ломнуть, ломать совместимость нельзя, половина говорит, блин, чуваки, вы че серьезно, давайте назовем его просто дейт и не будем париться.
524.80 528.80 "Игорь Лабутин" В общем, там длиннющее обсуждение, пока ничего ни к чему не пришли.
528.80 538.12 "Игорь Лабутин" Ну, то есть, там это API Proposal, как обычно, то есть, там интерфейс, все описаны, все методы, всякие конвертилки туда-сюда, как из date/time сконвертить, как обратно и так далее.
538.12 543.32 "Игорь Лабутин" Но самая большая дискуссия - это проименование, конечно, это прям шедеврально, можно почитать.
543.32 559.08 "Игорь Лабутин" И с таймом, кстати, проблем меньше, тайм вроде как народ чуть спокойнее относится к тайму, там, по-моему, было предположение, что это будет то ли local time, то ли как-то так типа называться, и вроде ничего, с ним как бы более-менее все согласны, а вот с дейтом все прямо это, да, шикарное обсуждение.
559.08 570.64 "Игорь Лабутин" Так что вот с Priority Queue возможно какие-то тоже такого же рода проблемы были, не знаю, может в исходной реализации действительно была бы очередь, ну, в планировавшемся API, а потом было поздно менять, не знаю, не выяснял.
570.64 573.92 "Игорь Лабутин" Ну, ладно, давай дальше.
573.92 597.20 "Игорь Лабутин" Улучшился немножко распарсивалка параметров форматирования для чиселок, то есть когда вы пишете в стрингформате, там, допустим, какое-нибудь там форматирование, что нам нужно записать вещественное число в формате обязательно сфиксированной точкой и строго с тремя знаками после запятой, там были некоторые баги, как выяснилось, в распарсивании этого формата, точнее, в воспринимании этого формата, не в парсинге, а воспринимании.
597.20 611.04 "Игорь Лабутин" Если ты почему-то захотел написать больше ста точек после запятой, я не знаю, зачем тебе больше ста знаков после запятой, но вот если ты вдруг указывал такой формат, то он не считался форматом, как столько знаков после запятой, а считался каким-то кастомным форматом, писал совсем не то.
611.04 616.40 "Игорь Лабутин" Ну, в общем, почему-то, по их словам, это big deal и много чего там вокруг этого дела пофиксили.
616.40 626.36 "Игорь Лабутин" И развесили nullable annotations по всему сигналару, теперь, соответственно, когда вы работаете с сигналаром из .NET, у вас есть nullable annotations.
626.36 628.40 "Игорь Лабутин" Так, погнали дальше, runtime.
628.40 630.76 "Игорь Лабутин" В runtime не так много всего.
630.76 653.52 "Игорь Лабутин" Очередной виток улучшения профайл guided optimization — это штука, которая позволяет вам прогнать программку на каком-нибудь профиле вашей нагрузки, записать, что там происходило, после чего скормить это каким-нибудь тулу, и он предкомпилирует те пути в программе, так скажем, более оптимально, которые у вас обычно под этим профилем нагрузки используются.
653.52 655.88 "Игорь Лабутин" Ну, позволяет как раз-таки снизить время стартапа и так далее.
655.88 658.16 "Анатолий Кулаков" Это уже можно попробовать или все еще планы?
658.16 661.56 "Игорь Лабутин" Нет, это вот в 0.6 Preview 2 выпущено.
661.56 665.96 "Анатолий Кулаков" Интересно, как это будет работать и какой инструментарий вокруг этого построен?
665.96 666.96 "Анатолий Кулаков" Надо потыкать.
666.96 671.80 "Игорь Лабутин" Надо потыкать, мы можем это попробовать в backlog записать, как-то чуть более подробно посмотреть на это дело.
671.80 672.80 "Игорь Лабутин" Почему нет?
672.80 682.80 "Игорь Лабутин" Кажется, что такие штуки, они больше пригождаются для тулов в формате, как бы запустил в командной строке, что-то она поделала и вышла, и у меня в работе таких, например, мало.
682.80 696.56 "Игорь Лабутин" То есть это именно девелоперские тулы обычно, а обычный продукт, ну это просто S/P/Nad Core сервисы, которые долго-долго-долго висят, поэтому там кажется, что просто обычный GIT рано или поздно его нормально оптимизирует и все.
696.56 710.04 "Игорь Лабутин" Ну то есть возможно здесь, либо еще это важно для всяких платформ, где невозможно динамическое что-то, то есть где ты должен предкомпилировать, типа head of time компиляция, чтобы она была правильной, а не очень такой общего вида и медленной.
710.04 723.88 "Анатолий Кулаков" У меня как раз-таки бывает другая ситуация, когда мне хочется на старте все проджитить, потому что время первого реквеста довольно важно, и это сейчас делается какими-то страшными костылями, которые абсолютно не кроссплатформены и очень плохо переносятся между фреймворками.
723.88 726.04 "Анатолий Кулаков" И мне кажется, вот эта тулза могла бы мне здесь помочь.
726.04 731.96 "Игорь Лабутин" Возможно, возможно, но тут тебе нужно тогда будет еще подобрать правильный профиль, чтобы он понял, что нужно все проджитить.
731.96 741.12 "Игорь Лабутин" Ну ладно, и как раз-таки есть еще в GIT какие-то тоже улучшения, там что-то где-то чуть оптимальнее GIT-ится, какие-то оптимизации очередные завезли, ну и так далее.
741.12 742.92 "Игорь Лабутин" Так что ждем дальше.
742.92 744.44 "Игорь Лабутин" Видимо там Егор Богатов.
744.44 746.48 "Игорь Лабутин" Ну на самом деле не только он.
746.48 751.04 "Анатолий Кулаков" Так, хорошо, ну и как всегда у нас, наверное, подоспел ASP.NET Core с новой версией.
751.04 754.20 "Игорь Лабутин" Да, ASP.NET Core, улучшения в Blazor.
754.20 757.68 "Игорь Лабутин" Тут я не специалист в том смысле, что Blazor я сейчас не пользуюсь.
757.68 771.80 "Игорь Лабутин" Есть кастомный Event Arguments, то есть можно передавать какие-то свои типы, я так понимаю, какие-то улучшения при наследовании компонент и сохранение стейта после пререндера.
771.80 790.04 "Игорь Лабутин" То есть я так понимаю, что есть такая технология, что из-за того, что Blazor может грузиться довольно долго, сначала клиенту может отправляться какой-то пререндеред кусочек, а потом когда Blazor уже полностью загрузится в ваше приложение, оно тогда уже подменяется, грубо говоря, на полностью уже нормальный Blazor и сейчас стало возможно какой-то стейт между этими штуками передавать.
790.04 794.56 "Игорь Лабутин" Ну, это единственное, что я могу знать из новости, на практике не пробовал.
794.56 815.68 "Анатолий Кулаков" Справедливости ради нужно сказать, что дело не в том, что Blazor долго грузится, а вообще пререндеринг - это сейчас такая модная фича у всех фронт-энд фреймворков, то есть там даже всякие реакты, они тоже стараются на сервере первую страничку отпререндерить, отдать ее браузеру для быстрого показа первой информации, а потом уже какие-то куски изменений добавлять к существующему дому.
815.68 819.36 "Анатолий Кулаков" Так что Blazor здесь просто идет в ногу с современными тенденциями.
819.36 820.36 "Игорь Лабутин" Ну, хорошо.
820.36 830.28 "Игорь Лабутин" Ну и мы обсуждали, наверное, 3 или 4 подкаста назад, что в Blazor завезли CSS Isolation, и теперь ее же завезли в MVC и в Razer.
830.28 831.28 "Игорь Лабутин" Можно пользоваться.
831.28 832.28 "Анатолий Кулаков" Прекрасно.
832.28 834.72 "Анатолий Кулаков" С Entity Framework что-нибудь?
834.72 835.72 "Игорь Лабутин" Чуть-чуть.
835.72 852.00 "Игорь Лабутин" Entity Framework Core в прошлом релизе, в пятом Entity Framework почти везде заменил всякие осинки на осинки с конфигуратором WaitFalse, ну то есть без сохранения синхронизации контекста.
852.00 879.16 "Игорь Лабутин" Это, понятно, помогло там много чего разгрузить в том смысле, что больше работы ушло в ThreadPool, но выяснилось, что в одном методе, а именно в SafeChanges, могут вызываться всякие делегаты, хендлеры, какие-то ивенты, которые очень часто хотят, ну, по пользовательским сценариям, чтобы они запускались в UI-ном потоке, поэтому конкретно в SafeChanges Async это было откатено, и теперь там синхронизация контекста сохраняется при вызове.
879.16 886.40 "Игорь Лабутин" Дальше они улучшили трансляцию linq в SQL, и StringConcat теперь поддерживает несколько аргументов.
886.40 896.12 "Игорь Лабутин" Раньше, по-моему, только два поддерживалось, ну, то есть просто сложение двух строк, а сейчас можно короче туда запихнуть сколько угодно, и это все аккуратно сконкатится в SQL-ный конкат.
896.12 906.52 "Игорь Лабутин" И добавили еще более такой гибкий поиск FreeTextSearch, то есть который тоже правильно конфигурится в SQL-ной конструкции.
906.52 913.80 "Игорь Лабутин" Ну, то есть улучшают SQL-генератор, при том, что, если мы помним, обещали, что этот релиз будет почти без фич, а в основном bugfix.
913.80 916.24 "Игорь Лабутин" Ну, может быть, там bugfix-ов еще больше, поэтому...
916.24 917.24 "Игорь Лабутин" Да.
917.24 920.84 "Игорь Лабутин" И это все, чем порадовал нас Microsoft DotNet 6 Preview 2, так что пошли дальше.
920.84 930.08 "Анатолий Кулаков" Ричард Лендер пообещал, что они снова вышли на цикл, где будут делать превью-версии каждый месяц, поэтому мы с тобой без новостей не останемся.
930.08 935.28 "Анатолий Кулаков" А следующая новость заключается в том, что Microsoft помогает сделать ваше приложение High Performance.
935.28 944.64 "Анатолий Кулаков" Для того, чтобы любое ваше приложение стало High Performance, вам необходимо поставить волшебный пакетик, который называется Microsoft Toolkit High Performance, который как раз достиг седьмого релиза.
944.64 946.00 "Анатолий Кулаков" Игорь, это так работает?
946.00 947.00 "Игорь Лабутин" Ну, почти.
947.00 952.52 "Игорь Лабутин" Но только поставив пакетик, нужно из него хотя бы один классик завязать, иначе линкер вам этот пакетик выпилит обратно.
952.52 954.44 "Игорь Лабутин" И из него есть что завязать.
954.44 965.96 "Игорь Лабутин" На самом деле, это немножко удивительно, что он добрался аж до седьмого релиза, и мы не сильно много про него говорили, мы один раз всего упоминали, но штука довольно популярная, похоже, или, по крайней мере, развивающаяся.
965.96 969.64 "Игорь Лабутин" Она является частью того, что называется Windows Community Toolkit.
969.64 990.32 "Игорь Лабутин" Это проект техногитхаби, где собраны, так скажем, достаточно полезные и интересные расширения к стандартному .NET, причем эта штука поддерживает от .NET стандарта 1.4, который довольно старый, до последнего пятого .NET, ну и шестого, соответственно, тоже, но которые не включены в основной фреймворк по каким-то причинам.
990.32 995.04 "Игорь Лабутин" И понятно, что там могут контрабьютизировать те, кто работает в Microsoft, и сторонние.
995.04 1000.52 "Игорь Лабутин" В общем, он такой, набор полезных расширений с точки зрения комьюнити.
1000.52 1007.00 "Игорь Лабутин" Там довольно много всего про UI, как мы говорили, но конкретно сейчас именно про High Performance хочется сказать.
1007.00 1009.80 "Игорь Лабутин" И там есть несколько интересных вещей.
1009.80 1033.16 "Игорь Лабутин" Если вы почувствовали радость от работы с MemoryT и SpanT-тайпами, и вам прям не терпится улучшать скорость работы вашего приложения, то если вы вдруг работали с двумерными массивами, то вы сможете из этого пакета достать типы, которые называются Memory2D и Span2D, которые обеспечивают примерно ту же работу, что Memory и Span в обычном .NET для массивов, только эти для двумерных массивов.
1033.16 1037.40 "Игорь Лабутин" То есть быстрый доступ, слайсы и так далее.
1037.40 1044.68 "Игорь Лабутин" Понятно, что какой-нибудь стеколог двухмерного массива на стеке, наверное, смысла не имеет, если у вас какие-то большие картинки.
1044.68 1052.04 "Игорь Лабутин" Но если вы как раз работаете много с картинками, может быть, это имеет смысл поиспользовать и что-то будет там интересное для вас.
1052.04 1054.40 "Игорь Лабутин" Дальше есть такой тип, называется StringPool.
1054.40 1056.60 "Игорь Лабутин" Это немножко похоже на StringInterning.
1056.60 1061.52 "Игорь Лабутин" Мы помним, наверное, что в .NET на любой строчке можно сказать String.Inter.
1061.52 1074.44 "Игорь Лабутин" И если таковая строчка уже где-то в памяти вашего процесса есть, то вам вернется ссылка на нее, а ваша строка, которую вы передали, она по сути будет собрана сборщиком мусора при случае.
1074.44 1077.28 "Игорь Лабутин" И как только на нее ссылки исчезнут.
1077.28 1082.08 "Игорь Лабутин" Это все хорошо, но, к сожалению, это работает только в одну сторону.
1082.08 1085.12 "Игорь Лабутин" То есть если вы строчку заинтернили, то все.
1085.12 1087.08 "Игорь Лабутин" Вытащить ее из памяти уже невозможно.
1087.08 1097.80 "Игорь Лабутин" Вот StringPool — это конкретный класс, конечно, который позволяет вам сделать конкретный пул конкретных строчек, и он довольно сильно заточен именно на строчке.
1097.80 1105.80 "Игорь Лабутин" То есть там специальные хэши используются внутри, чтобы разделить правильно по бакетам, чтобы все это работало правильно, с многопоточностью, поменьше конфликтов было.
1105.80 1126.52 "Игорь Лабутин" В общем, если вы работаете с большим количеством строк, парсите, например, какие-нибудь XML, JSON или тексты любые, и у вас иногда наступает момент, когда все эти строчки отчитаны от паршина и можно их выкидывать, то посмотрите за StringPool или заиспользуйте его напрямую, или по крайней мере, там могут быть интересные идеи, как вы можете это использовать у себя.
1126.52 1127.52 "Игорь Лабутин" Дальше.
1127.52 1130.68 "Игорь Лабутин" Мелкая штука, но на самом деле интересная.
1130.68 1141.36 "Игорь Лабутин" Возвращаясь к MemoryT, если вы используете MemoryAtT класс, то наверняка вам иногда хотелось взять и, скажем, сказать, что у вас сейчас не Memory от ByteArray, а Memory от IntArray.
1141.36 1143.48 "Игорь Лабутин" В спанах такое можно, в Memory такое нельзя.
1143.48 1148.64 "Игорь Лабутин" В стандартном .NET здесь написано ряд методов расширения, которые это дело позволяют сделать.
1148.64 1170.84 "Игорь Лабутин" И тоже полезный метод расширения еще один, если у вас есть абстракция iBufferWriter, и если я правильно помню, она используется в том числе в районе там чаннелов всяких и так далее, то если у вас есть какой-то код, который ждет стрима, то классический способ, когда мы это делали раньше, ну как, создаете MemoryStream, в него все пишут, потом из MemoryStream достаете ByteArray и делаете с ним что хотите.
1170.84 1179.44 "Игорь Лабутин" Теперь можно использовать метод расширения sStream, который сделает такой специальный якобы стрим, но который будет писать напрямую в правильный .BufferWriter.
1179.44 1186.04 "Игорь Лабутин" В принципе штука, которая пишется самостоятельно не знаю, за полчаса, но тут уже все написали, корректно отладили, оттестировали, почему бы нет.
1186.04 1196.24 "Игорь Лабутин" В общем так, а если у вас есть вдруг с вашей стороны какие-то полезные клевые штуки, которые вы у себя в коде написали, на самом деле можно подумать и законтрибьютить туда, чтобы всем остальным тоже было полезно.
1196.24 1199.08 "Анатолий Кулаков" Отлично полезный пакетик, я считаю.
1199.08 1209.36 "Анатолий Кулаков" Я гуляя по просторам интернета обнаружил интересный плейлистик, который делает компания JetBrains, называется он JetBrains Open Source Power Apps.
1209.36 1212.76 "Анатолий Кулаков" Заключается он в том, что JetBrains помогает продвинуть всякие open source библиотеки.
1212.76 1219.56 "Анатолий Кулаков" И в принципе это не только какими-то рекламными материалами, но и много чем другим.
1219.56 1226.60 "Анатолий Кулаков" Например, она предоставляет деньги, там какая-то регулярная ежемесячная сумма выплачивается хорошим open source проектом.
1226.60 1237.20 "Анатолий Кулаков" Естественно она предоставляет набор инструментов своих IDE-шек каких-нибудь и она обеспечивает уже инфраструктуру готовую, такую как CIDI на своих серверах.
1237.20 1246.52 "Анатолий Кулаков" Она помогает подписать плагины под Rider для ваших библиотек, чтобы Rider более нативно, более интересно как-то мог с ними работать, подсвечивать.
1246.52 1253.60 "Анатолий Кулаков" И она распространяет информацию об этих библиотеках, как-то их рекламирует, продвигает в своих конференциях, продвигает в своих проектах.
1253.60 1265.28 "Анатолий Кулаков" И в частности вот этот проект Power Apps, он как раз и является типичным представителем того, как продвигаются open source проекты с помощью JetBrains.
1265.28 1271.72 "Анатолий Кулаков" Этот проект ведет Matias Kout, мы много уже с ним знакомы, он много интересных инструментов сделал.
1271.72 1277.28 "Анатолий Кулаков" Вообще хороший программист, хороший евангелист, достаточно громадно подходит к обсуждаемым материалам.
1277.28 1280.20 "Анатолий Кулаков" На данный момент вышло всего два выпуска.
1280.20 1283.60 "Анатолий Кулаков" Первый выпуск посвящен Fluent Validation.
1283.60 1290.32 "Анатолий Кулаков" Это такая специальная библиотека, которая позволяет вам строго типизированно задать какие-то validation рулы.
1290.32 1292.52 "Анатолий Кулаков" В основном они используются для вашей бизнес-логики.
1292.52 1300.40 "Анатолий Кулаков" И этот стрим, этот видосик, он был записан вместе с автором Fluent Validation, Джереми Скинером.
1300.40 1306.52 "Анатолий Кулаков" И очень интересно смотреть, как именно авторы рассказывают про свои библиотеки.
1306.52 1323.76 "Анатолий Кулаков" В данном выпуске были рассмотрены вложенные валидации, композиция валидаций, как нужно расширять ваши валидаторы, как тестировать валидаторы, каким образом Fluent Validation может интегрироваться с SPNet, как валидировать синхронный и асинхронный код.
1323.76 1328.48 "Анатолий Кулаков" То есть, все, чтобы вам полностью с нуля начать пользоваться этой библиотекой.
1328.48 1330.88 "Анатолий Кулаков" Видео, конечно, целины прежде всего на начинающих людей.
1330.88 1338.20 "Анатолий Кулаков" Но, в принципе, если вы никогда не сталкивались с этими библиотеками, а это вполне возможно, то обязательно посмотрите.
1338.20 1341.32 "Анатолий Кулаков" И второй видосик это про Fluent Assertion.
1341.32 1343.96 "Анатолий Кулаков" Названия похожи, но это, наверное, все, что их связывает.
1343.96 1346.00 "Анатолий Кулаков" В принципе, все совпадения случайны.
1346.00 1351.48 "Анатолий Кулаков" Fluent Assertion это специальная библиотека, которая помогает вам уже в юнит-тестах.
1351.48 1355.40 "Анатолий Кулаков" Она позволяет делать грамотные ассершины на ваши классы.
1355.40 1359.22 "Анатолий Кулаков" Как раз-таки помогает более красиво делать последнюю часть.
1359.22 1364.04 "Анатолий Кулаков" Точно так же видосик записывался вместе с автором Денис Думин.
1364.04 1369.60 "Анатолий Кулаков" И Fluent Assertion хороша тем, что у нее есть уже очень много встроенных хороших equals.
1369.60 1377.72 "Анатолий Кулаков" То есть, она очень хорошо сравнивает коллекции, массивы и обычные объекты, анонимные объекты, рекурсивные объекты.
1377.72 1379.52 "Анатолий Кулаков" То есть, она полностью проходит все поля.
1379.52 1383.56 "Анатолий Кулаков" Если вы об этом скажете, заходит во все свойства, сравнивает эти свойства.
1383.56 1390.52 "Анатолий Кулаков" Она хорошо работает с датой и временем, учитывая всю специфику .NET и все подводные камни, которые там существуют.
1390.52 1396.16 "Анатолий Кулаков" Также в докладе рассмотрели, как можно сделать целую цепочку ассертов.
1396.16 1401.16 "Анатолий Кулаков" Рассмотрели, каким образом делать ассерты на асинхронный корд, на await, на асинхронный.
1401.16 1408.04 "Анатолий Кулаков" Каким образом вы можете сделать ршение под ассерты, чтобы они были заточены под вашу бизнес логику.
1408.04 1409.44 "Анатолий Кулаков" И так далее.
1409.44 1423.68 "Анатолий Кулаков" Fluent Assertion помогает не только более глубоко, более красиво и более четко проверять ваши объекты, но также выдает намного более читабельные и понятные сообщения о проблемах.
1423.68 1428.04 "Анатолий Кулаков" То есть, о том, что такое случилось, где не совпало, почему не совпало, как мы к этому пришли.
1428.04 1431.88 "Анатолий Кулаков" То есть, там прям как документация, можно читать все ее ошибки.
1431.88 1435.20 "Анатолий Кулаков" Вот такие два видосика есть с авторами этих библиотек.
1435.20 1442.76 "Анатолий Кулаков" И в принципе, для всех начинающих, особенно тех, кто никогда не слышал про такие библиотеки, крайне рекомендую, потому что как минимум о них нужно знать.
1442.76 1449.00 "Анатолий Кулаков" Неизвестно, где они вам могут пригодиться, поэтому нужно понимать, что они умеют и как этим пользоваться.
1449.00 1451.36 "Игорь Лабутин" Любые обучающие материалы всегда полезны.
1451.36 1453.68 "Игорь Лабутин" Так что, тем более от авторов в данном случае.
1453.68 1460.44 "Игорь Лабутин" Так что смотрите, слушайте и офладевайте, так скажем, этими тулами, если вы ими не пользуетесь.
1460.44 1472.72 "Анатолий Кулаков" Несмотря на то, что я про все эти библиотеки знал, то я с удовольствием пересмотрел оба этих видосика, потому что когда рассказывает автор библиотеки, очень интересно думать и схватывать его мысли о том, как он это задумывал, как он это видит.
1472.72 1476.88 "Анатолий Кулаков" И понимать, сопадает ли это с твоей практикой использования или нет.
1476.88 1478.96 "Анатолий Кулаков" Поэтому очень интересно чтить его.
1478.96 1479.96 "Игорь Лабутин" Ну, прекрасно.
1479.96 1480.96 "Игорь Лабутин" Погнали дальше.
1480.96 1486.12 "Игорь Лабутин" Про NuGet мы давно не говорили, а тем временем вышел NuGet 5.9.
1486.12 1490.88 "Игорь Лабутин" Он появился некоторое время назад, он включен в Visual Studio 16.9 и в .0.5.0.
1490.88 1493.80 "Игорь Лабутин" И там есть несколько интересных изменений.
1493.80 1504.60 "Игорь Лабутин" Во-первых, если вы знали, то вы можете ссылаться на NuGet пакеты, используя так называемый Floating Version, когда вы туда указываете, скажем, версия 6.0.*.
1504.60 1510.24 "Игорь Лабутин" И это значит, что подхватится любая 6.0.*, которая там доступна, ну последняя из доступных.
1510.24 1515.08 "Игорь Лабутин" И проблем была в том, что надо было как-то посмотреть, а какая же подхватилась на самом деле.
1515.08 1518.40 "Игорь Лабутин" Теперь это видно в Solution Level Package Manager.
1518.40 1523.20 "Игорь Лабутин" Там появилась отдельная колоночка, где будет написано, что вы поставили вот конкретно такую.
1523.20 1525.96 "Игорь Лабутин" В смысле, у вас сейчас стоит вот конкретно такая.
1525.96 1532.20 "Игорь Лабутин" Вторая штука, которую давно-давно просили, это каким-то образом для пакетов указывать, откуда они вообще пришли.
1532.20 1543.12 "Игорь Лабутин" Потому что если у вас прописано несколько NuGet-сорсов, то было бы неплохо знать, что вот этот пришел из моего локального NuGet или из корпоративного, или вообще из NuGet.org.
1543.12 1550.64 "Игорь Лабутин" Теперь, соответственно, можно посмотреть это дело в файле kinupkg.metadata, который лежит в собственной каталоге, где лежит пакет.
1550.64 1551.64 "Игорь Лабутин" Там будет это написано.
1551.64 1562.88 "Игорь Лабутин" А также это теперь показывается в логах во время инсталляции пакета, то есть там будет написано, что пришел такой-то пакет с таким-то хэшом, там теперь хэшки показываются, с такого-то сервера.
1562.88 1571.20 "Игорь Лабутин" Это прям вообще на самом деле big deal, особенно если у вас, как я говорил, есть внутренний корпоративный сервер, и вы хотите знать, откуда вам приходят пакетики.
1571.20 1584.20 "Игорь Лабутин" Дальше, теперь можно в Solution Explorer откликнуть прямо на пакете и сказать upgrade или update, и вы попадете в Package Manager прямо непосредственно с этим пакетом выбранным, и вы сможете непосредственно выбрать ту версию, на которую апгрейдится и проапгрейдится.
1584.20 1585.84 "Игорь Лабутин" Ну, чуть проще.
1585.84 1592.12 "Игорь Лабутин" И в целом, ребята рассказали интересную историю того, как улучшался Package Manager в Visual Studio.
1592.12 1597.12 "Игорь Лабутин" То есть в 16.7 было минорное улучшение между тапками install и update.
1597.12 1598.12 "Игорь Лабутин" Можно переходить быстро.
1598.12 1601.24 "Игорь Лабутин" Знаю, у меня оно всегда более-менее быстро работало, может у меня пакетиков мало.
1601.24 1610.20 "Игорь Лабутин" В 16.8 они увеличили скорость апгрейда и даунгрейда пакетов, как они говорят, до 14 раз быстрее.
1610.20 1611.84 "Игорь Лабутин" Не знаю, как медли.
1611.84 1613.68 "Игорь Лабутин" Дальше, смотрите, внимательно следите за руками.
1613.68 1616.00 "Игорь Лабутин" В последовательности они делают улучшение.
1616.00 1623.76 "Игорь Лабутин" В 16.9 улучшили скорость деинсталла пакетов до 5 раз, а в 16.10 планируют улучшить скорость инсталла пакетов.
1623.76 1625.60 "Игорь Лабутин" Для меня немножко странная последовательность.
1625.60 1632.60 "Игорь Лабутин" Сначала апгрейд, даунгрейд, ладно, это, наверное, может быть самая частая операция, но uninstall, почему первее инсталла, непонятно.
1632.60 1637.64 "Анатолий Кулаков" Может там технически был какой-то пререквизит, который помогал просто продвинуться к инсталлу.
1637.64 1641.60 "Игорь Лабутин" Ну вот надеюсь на это, потому что иначе выбор какой-то странный.
1641.60 1651.16 "Игорь Лабутин" Ну и немножечко еще обновили иконочки, типа более красивые, более в соответствии со всеми остальными иконками на Nuget, Org и так далее.
1651.16 1656.80 "Игорь Лабутин" Так что в целом вот такие улучшения в Nuget, в Package Manager конкретнее, вижу в студии в целом.
1656.80 1664.44 "Анатолий Кулаков" Также за это время произошел очень большой, очень хайповый и очень долгожданный релиз.
1664.44 1669.16 "Анатолий Кулаков" Вышел релиз OpenTelemetry версии 1.0.
1669.16 1671.72 "Анатолий Кулаков" Давайте подробнее разберемся, что же это такое.
1671.72 1677.88 "Анатолий Кулаков" Прежде всего, мне кажется, мы ни разу в наших подкастах не разбирали, что такое OpenTelemetry, поэтому давайте начнем с самых основ.
1677.88 1679.72 "Анатолий Кулаков" У нас есть современный мир.
1679.72 1683.56 "Анатолий Кулаков" В современном мире очень популярно делать распределенные микросервисы.
1683.56 1693.40 "Анатолий Кулаков" Это значит, у нас разные приложения, которые могут писаться абсолютно на разных языках, которые каким-то образом общаются между собой и все это очень сложно.
1693.40 1696.56 "Анатолий Кулаков" Особенно сложно это каким-то образом отлаживать и отслеживать.
1696.56 1700.92 "Анатолий Кулаков" То есть, что происходит между этими микросервисами, как они общаются, когда, почему.
1700.92 1703.32 "Анатолий Кулаков" Это становится огромной большой болью.
1703.32 1709.56 "Анатолий Кулаков" Новый стандарт OpenTelemetry как раз-таки и направлен на то, чтобы вот эту боль каким-то образом решить.
1709.56 1712.52 "Анатолий Кулаков" В стандарт OpenTelemetry входят несколько вещей.
1712.52 1713.52 "Анатолий Кулаков" Во-первых, это спецификация.
1713.52 1717.76 "Анатолий Кулаков" Во-вторых, это специальные инструменты, которые вам помогают в работе с данными.
1717.76 1727.24 "Анатолий Кулаков" И в-третьих, это большое количество SDK, которые пишутся под конкретные приложения, под конкретные платформы и под конкретные операционные системы.
1727.24 1730.48 "Анатолий Кулаков" Вообще, сама идея не нова.
1730.48 1738.76 "Анатолий Кулаков" В принципе, очень много уже проектов было сделано до этого, но все они были или какие-то коммерческие, или какие-то недоделанные, или какие-то несогласованные.
1738.76 1745.92 "Анатолий Кулаков" В частности, сам OpenTelemetry, он смёржился из двух проектов, которые назывались OpenCensus и OpenTracing.
1745.92 1759.24 "Анатолий Кулаков" После того, как эти два конкурента договорились и смёржились, появился проект OpenTelemetry, который был призван как раз-таки объединить все стандарты, все, которые у нас существуют, и вот какой-то один открытый предоставить.
1759.24 1764.92 "Анатолий Кулаков" Microsoft был активным членом OpenTelemetry community с самых первых его версий, как только он появился.
1764.92 1768.28 "Анатолий Кулаков" И даже раньше они очень сильно вкладывались в OpenCensus еще.
1768.28 1773.48 "Анатолий Кулаков" Сам OpenTelemetry, он никак не привязан ни к какому вендору, ни к какому продукту, ничего.
1773.48 1781.40 "Анатолий Кулаков" Это открытая спецификация, где каждый ее может реализовать, и каждый ее может использовать и интегрироваться с помощью нее.
1781.40 1786.20 "Анатолий Кулаков" То есть, вы можете использовать абсолютно любые инструменты от абсолютно любых вендоров.
1786.20 1790.56 "Анатолий Кулаков" Сам OpenTelemetry проповедует на данный момент три спецификации.
1790.56 1796.08 "Анатолий Кулаков" Он нам рассказывает о том, каким образом работать с метриками, с логами и с трейсами.
1796.08 1798.44 "Анатолий Кулаков" Про логи вы, наверное, все знаете.
1798.44 1800.88 "Анатолий Кулаков" Логи есть практически в каждом приложении.
1800.88 1805.60 "Анатолий Кулаков" Сейчас очень модно использовать для логирования пакет Microsoft Extensions Logins.
1805.60 1814.96 "Анатолий Кулаков" И в принципе, если вы его используете, то в будущем у вас, скорее всего, логи будут работать через OpenTelemetry тоже.
1814.96 1819.76 "Анатолий Кулаков" Метрики - это специальная числовая информация, которая может описать ваш процесс.
1819.76 1822.16 "Анатолий Кулаков" Это какие-нибудь счетчики, гистограммы.
1822.16 1831.12 "Анатолий Кулаков" Типичным примером является потребляемый уровень CPU или сколько памяти использует ваше приложение.
1831.12 1837.12 "Анатолий Кулаков" Или, например, сколько HTTP-реквестов приходило в ваше приложение за определенное количество времени.
1837.12 1838.88 "Анатолий Кулаков" Это все описывается метриками.
1838.88 1843.72 "Анатолий Кулаков" И третий кит, на котором стоит все Observability - это трейсинги.
1843.72 1846.72 "Анатолий Кулаков" Еще и они известны под именем Distributed Tracing.
1846.72 1854.48 "Анатолий Кулаков" То есть, это специальные записи, у которых есть начало, конец и какая-то дополнительная информация.
1854.48 1859.36 "Анатолий Кулаков" И эти записи соединяются в цепочку вызовов.
1859.36 1862.68 "Анатолий Кулаков" Distributed Tracing легче всего представить как распределенный стек.
1862.68 1865.40 "Анатолий Кулаков" Наверняка каждый из вас в атлатчике видел стек.
1865.40 1869.50 "Анатолий Кулаков" Но в распределенных приложениях, к сожалению, этого увидеть невозможно.
1869.50 1880.20 "Анатолий Кулаков" И как раз Distributed Tracing помогает вам составить такой своеобразный стек между различными приложениями, различными машинами и различными инфраструктурами.
1880.20 1882.84 "Анатолий Кулаков" И как не привязано к какой-то конкретной локации.
1882.84 1885.80 "Игорь Лабутин" Мне кажется, даже не совсем стек, а больше даже дерево.
1885.80 1888.88 "Игорь Лабутин" То есть, это по сути дерево того, как у вас исполнялось.
1888.88 1896.88 "Игорь Лабутин" Где ваша входная точка - это вершинка наверху, а дальше, как классически рисует программистское дерево, вниз веточки.
1896.88 1903.08 "Игорь Лабутин" И вот каждые ноды - это какой-то кусочек вашей логики, который дальше бьется на какие-то дальнейшие кусочки.
1903.08 1905.68 "Игорь Лабутин" Возможно, при этом между системами они как-то распределены.
1905.68 1908.48 "Анатолий Кулаков" Да, да, ты прав.
1908.48 1913.28 "Анатолий Кулаков" Но нужно сказать, что сейчас зарелизились только Distributed Tracing.
1913.28 1915.88 "Анатолий Кулаков" Два остальных кита пока еще находятся в разработке.
1915.88 1920.88 "Анатолий Кулаков" Метрики обещали нам показать к сентябрю, а логин вообще еще в экспериментальном режиме.
1920.88 1925.80 "Игорь Лабутин" Так, давай тогда попробуем понять, что же такое Open Telemetry.
1925.80 1929.28 "Игорь Лабутин" Ты упоминал Open Sense, Open Tracing, Open...
1929.28 1930.28 "Игорь Лабутин" Кто там еще был?
1930.28 1935.08 "Игорь Лабутин" И в общем, кто же теперь Open Telemetry и что это нам дает практически?
1935.08 1940.92 "Анатолий Кулаков" Ну, прежде всего, что важно в данном релизе, это то, что это протокол.
1940.92 1950.68 "Анатолий Кулаков" Это межязыковой, межвендерный протокол, который не зависит ни от кого и который описывает как раз-таки, как инструменты должны взаимодействовать друг с другом.
1950.68 1953.64 "Анатолий Кулаков" Инструменты на разных языках и на разных платформах.
1953.64 1957.96 "Анатолий Кулаков" Далее это SDK, которые также выложены в официальном репозитории.
1957.96 1961.76 "Анатолий Кулаков" И в принципе, dotnet-овский SDK сейчас один, наверное, из самых популярных.
1962.08 1966.00 "Анатолий Кулаков" У него там больше всего активитей, контрибьюторов, звездочек и так далее.
1966.00 1969.88 "Анатолий Кулаков" Ну, то есть, dotnet там далеко не на последнем, может даже и на первом месте.
1969.88 1978.16 "Анатолий Кулаков" Также это набор всяких экспортеров, которые помогают ваши данные, которые вы собрали, все-таки куда-то применить, куда-то сохранить и как-то их отобразить.
1978.16 1984.04 "Анатолий Кулаков" Тут нужно еще упомянуть, что Open Telemetry разрабатывается под эгидой Cloud Native Computing Foundation.
1984.04 1991.56 "Анатолий Кулаков" То есть, ему пророчат еще большое будущее, потому что очень много продуктов находится под крылом Cloud Native Computing Foundation.
1991.56 1995.28 "Анатолий Кулаков" Прежде всего это Kubernetes, Consul и многие-многие другие.
1995.28 2008.88 "Анатолий Кулаков" Также Open Telemetry сейчас используется уже очень большим числом компаний, то есть огромное число огромных корпораций подписались под ним, что они будут внедрять эту поддержку в свои инструменты и будут внедрять ее в свои языки программирования.
2008.88 2019.72 "Анатолий Кулаков" Итак, Open Telemetry нацелен прежде всего на распределенные приложения, по крайней мере в данном релизе, которые могут быть написаны на различных платформах и различных языках.
2019.72 2023.00 "Анатолий Кулаков" Как уже упоминалось выше, вы вполне можете отследить цепочку вызовов.
2023.00 2040.96 "Анатолий Кулаков" Допустим, если ваш фронтенд, который написан на WebUI, вызвал какой-нибудь WebProxy, который передал управление какому-нибудь .NET Backend сервису, этот .NET сервис вызвал базу данных и где-то там посередине были какие-то задержки или были какие-то ошибки.
2040.96 2045.48 "Анатолий Кулаков" И вот эту картину полностью вам как раз таки может показать Distributed Tracing.
2045.48 2064.72 "Анатолий Кулаков" Как я уже говорил, вы можете выбрать абсолютно любого провайдера или платформу, это никак не привязано к спецификации и, соответственно, никак ваш код, если он настроен на то, чтобы отдавать стандартный протокол OpenTelemetry, ваш код тоже не пострадает, его не нужно заново перекомпилировать или что-то сделать еще, просто меняйте инструмент и все.
2064.72 2071.24 "Анатолий Кулаков" И сейчас самые популярные аппликейшн-перформанс-мониторы уже поддерживают OpenTelemetry в том или ином виде.
2071.24 2080.52 "Анатолий Кулаков" Конечно, они ждали релиза, но проект разрабатывался довольно-таки давно и поэтому они наверняка сейчас уже начнут выпускать свои совместимости.
2080.52 2087.12 "Анатолий Кулаков" Например, New Relic, Azure Monitor, AWS Distro - все они уже поддерживают OpenTelemetry.
2087.12 2090.92 "Анатолий Кулаков" Также существует большое количество open-source библиотек.
2090.92 2094.60 "Анатолий Кулаков" Для нас, в принципе, самыми интересными на сегодня являются Jagger и Zipkin.
2094.60 2106.68 "Анатолий Кулаков" Это UI-инструменты, которые способны как раз таки превратить все ваши распределенные данные, распределенные стеки, распределенные деревья именно в визуальную картинку, где вы можете покликать, посмотреть и увидеть, что же все-таки происходит.
2106.68 2115.76 "Игорь Лабутин" Окей, то есть получается, что сейчас у нас зарелизился 1.0, где у нас есть Distributed Tracing и мы можем что-то писать, так?
2115.76 2116.76 "Анатолий Кулаков" Все верно.
2116.76 2117.76 "Анатолий Кулаков" 1.0 - спецификация.
2117.76 2122.00 "Анатолий Кулаков" Также у нас зарелизился 1.0 OpenTelemetry SDK для .NET.
2122.00 2130.40 "Анатолий Кулаков" И вы, соответственно, можете уже сейчас начинать инструментировать ваш собственный код или использовать библиотеки, которые уже проинструментировались.
2130.40 2135.84 "Анатолий Кулаков" .NET SDK включает в себя не только какие-то классики, которые вы можете использовать, но и также большое количество всяких примеров.
2135.84 2140.40 "Анатолий Кулаков" Каким образом обрабатывать, каким образом экспортировать, собирать, агрегировать все эти данные.
2140.40 2151.92 "Анатолий Кулаков" И еще важно, что он включает уже в себя релизные пакеты Jagger, Zipkin для визуализации всех этих данных, потому что без визуализации это все малоинтересно.
2151.92 2155.56 "Анатолий Кулаков" И также есть экспортер в OpenTelemetry Protocol.
2155.56 2165.84 "Анатолий Кулаков" Это стандартный протокол, который призван отвязаться от конкретного инструмента и, соответственно, дать возможность любому инструменту читать ваши метрики.
2165.84 2175.68 "Анатолий Кулаков" Также зарелизилось огромное количество документаций, семплов, учебников для начального уровня и всяких пособий для авторов.
2175.68 2178.32 "Анатолий Кулаков" Авторов библиотек, авторов инструментов и прочего.
2178.32 2189.28 "Игорь Лабутин" Ну, хорошо, смотри, до OpenTelemetry у нас было огромное количество средств, как ты говоришь, было OpenCensus, OpenTracing, были, собственно, сами продукты, как Jagger и Zipkin.
2189.28 2196.76 "Игорь Лабутин" Но с OpenTelemetry оно прям вот такой хайп-хайп во всех там соцсеточках и YouTube-каналах я его вижу.
2196.76 2197.76 "Игорь Лабутин" Откуда хайп?
2197.76 2198.76 "Игорь Лабутин" Почему?
2198.76 2205.36 "Анатолий Кулаков" Я думаю, с этим вопросом лучше всего справится человек, который уже много-много времени провел в OpenTelemetry.
2205.36 2206.92 "Анатолий Кулаков" И у нас есть такой человек.
2206.92 2212.64 "Анатолий Кулаков" У нас в студии как раз сейчас находится Филипп Бочаров, руководитель проектов в компании МТС.
2212.64 2216.36 "Анатолий Кулаков" Он занимается обеспечением наблюдаемости экосистемы МТС.
2216.36 2220.60 "Анатолий Кулаков" То есть это самый тот человек, который нам может рассказать все про наблюдаемость и телеметрию.
2220.60 2221.60 "Анатолий Кулаков" Привет, Филипп!
2221.60 2222.60 "Анатолий Кулаков" Привет!
2222.60 2229.40 "Анатолий Кулаков" Мы тут пытаемся разобраться в нашем новом стандарте OpenTelemetry 1.0 и прежде всего хотели бы тебя спросить, а что, собственно, случилось?
2229.40 2230.80 "Анатолий Кулаков" Почему этот релиз важен?
2230.80 2232.72 "Анатолий Кулаков" Чем он поможет нашему текущему рынку?
2232.72 2239.40 "Филипп Бочаров" Ну, я, наверное, расскажу из своего опыта, то есть по опыту обеспечения наблюдаемости МТС.
2239.40 2249.52 "Филипп Бочаров" Сейчас, когда мы какой-то продукт обеспечиваем его наблюдаемость, мы используем несколько стэков для сбора логов, для сбора метрик и для сбора трейсов.
2249.52 2256.24 "Филипп Бочаров" То есть для метрик мы, например, используем Prometheus, для трейсов — Jagger и для логов — различные реализации логеров.
2256.24 2264.04 "Филипп Бочаров" Собственно, это создает некоторые зоопарк-системы, которые довольно сложно поддерживать, тем более что у нас много стэков, не только .NET.
2264.04 2276.24 "Филипп Бочаров" И как раз OpenTelemetry — это стандарт, который призван этот зоопарк немножко уменьшить, свести все к одному стандарту OpenTelemetry, к одному набору инфраструктурных компонентов для сбора.
2276.24 2282.84 "Филипп Бочаров" И мы очень надеемся, что это нам поможет существенно сократить наши затраты на подключение продуктов.
2282.84 2283.84 "Анатолий Кулаков" Ясно, отлично.
2283.84 2287.56 "Анатолий Кулаков" А скажи тогда, пожалуйста, что все-таки зарелизилось?
2287.56 2291.36 "Анатолий Кулаков" Потому что словом OpenTelemetry сейчас обозначает практически все.
2291.36 2296.40 "Анатолий Кулаков" И протоколы, и, по-моему, коллектор, и SDK на всех возможных языках, и все подряд.
2296.40 2298.16 "Анатолий Кулаков" В общем, 1.0 — это все-таки что?
2298.16 2300.20 "Анатолий Кулаков" Что у нас готово, а что еще нет?
2300.20 2303.12 "Филипп Бочаров" Да, тут вопрос интересный, с подводными камнями.
2303.12 2317.24 "Филипп Бочаров" Дело в том, что зарелизилась именно спецификация, то есть набор API, и модель данных, набор API, которым можно пользоваться для того, чтобы использовать трассировку, распределенную трассировку.
2317.24 2323.36 "Филипп Бочаров" В составе этого стандарта есть, грубо говоря, три сигнала, три части — это логи, метрики и распределенная трассировка.
2323.36 2326.96 "Филипп Бочаров" Так вот, зарелизилась в версии 1.0 только распределенная трассировка.
2326.96 2333.96 "Филипп Бочаров" Логи и метрики даже на уровне API, на уровне спецификации остаются еще экспериментальные фичи.
2333.96 2340.08 "Филипп Бочаров" Но кроме API есть еще и его реализация под каждый конкретный язык, в том числе под .NET.
2340.08 2343.92 "Филипп Бочаров" Она сейчас тоже находится в релизе, я видел там версию 1.0.
2343.92 2350.56 "Филипп Бочаров" Но кроме этого есть еще инфраструктура для сбора данных, то есть все эти коллекторы, агенты, которые эти данные собирают.
2350.56 2353.84 "Филипп Бочаров" И там нужно смотреть уже по каждому компоненту, какой у них статус.
2353.84 2357.48 "Филипп Бочаров" Например, сегодня я проверял OpenTelemetry коллектор в статусе бета.
2357.48 2362.48 "Филипп Бочаров" То есть здесь надо быть очень аккуратным, пока речь идет именно про спецификацию.
2362.48 2365.00 "Филипп Бочаров" Но почему это важно?
2365.00 2385.48 "Филипп Бочаров" Фиксация вот этих стандартов, фиксация этого API, причем там на три года обеспечивается Backup Compatibility, гарантирует большому комьюнити, который сейчас будет разрабатывать различные плагины, экспортеры для OpenTelemetry, гарантирует то, что их труд через год не потеряет свою актуальность.
2385.48 2393.32 "Филипп Бочаров" То есть это дает возможность большему числу людей принять участие в адаптации этого фрейворка.
2393.32 2398.08 "Анатолий Кулаков" Ну, то есть такие довольно важные куски инфраструктуры все еще не готовы.
2398.08 2403.28 "Анатолий Кулаков" А стоит ли тогда вообще смотреть в эту сторону, и стоит ли использовать в текущих проектах?
2403.28 2404.68 "Филипп Бочаров" Ну, я бы сказал так.
2404.68 2409.24 "Филипп Бочаров" Безусловно, стоит смотреть в эту сторону, потому что похоже, это действительно будущие наблюдаемости.
2409.24 2419.68 "Филипп Бочаров" Этот стандарт очень широко принят, он и поддерживается напрямую в .NET, в .NET 5, например, там много новых нововведений и дополнительная поддержка OpenTelemetry.
2419.68 2429.16 "Филипп Бочаров" Он принят различными гендерами APM, допустим, New Relic сразу заявила о поддержке OpenTelemetry Elasticsearch APM.
2429.16 2430.88 "Филипп Бочаров" Я бы сказал так.
2430.88 2438.68 "Филипп Бочаров" Если вы делаете что-то новое, какой-то проект с нуля, то безусловно, стоит сразу использовать спецификацию OpenTelemetry.
2438.68 2462.80 "Филипп Бочаров" Если у вас какой-то легаси, или не легаси, вы просто использовали какой-то предыдущий стандарт OpenCensus или OpenTracing, я бы немножко подождал, пристально бы смотрел на то, как, скажем так, зреет новый стандарт, когда зарелизилась бы часть с метриками и с логами, я бы уже думал о переходе.
2462.80 2476.76 "Филипп Бочаров" Ну, вот конкретно мы запланировали переход на OpenTelemetry, мы сейчас делаем некие ренди, изучаем его очень глубоко, с тем, что когда он зарелизится, все его части, мы бы сразу начали миграцию на OpenTelemetry.
2476.76 2481.04 "Анатолий Кулаков" Ну, с вами понятно, вы компания большая, уже опытная.
2481.04 2489.48 "Анатолий Кулаков" Скажи вот среднему проекту, когда пора задумываться о том, что в вашем проекте не хватает телеметрии, на какие вопросы она вообще может дать ответы, и как она может помочь в вашем приложении.
2489.48 2492.76 "Анатолий Кулаков" Как определиться, нужно мне заводить ее или не надо?
2492.76 2494.68 "Филипп Бочаров" Ну, тут вопрос из двух частей.
2494.68 2497.20 "Филипп Бочаров" Значит, как может помочь?
2497.20 2507.84 "Филипп Бочаров" Ну, во-первых, наблюдаемость позволяет производить локализацию диагностику, то есть это то, что называется root cause analysis, поиск корневой причины дефекта.
2507.84 2510.36 "Филипп Бочаров" Это может быть на бою или во время тестирования.
2510.36 2514.44 "Филипп Бочаров" Все это ведет к качеству.
2514.44 2527.88 "Филипп Бочаров" То есть наблюдаемость напрямую связана с качеством вашего приложения, с тем, как быстро вы решаете аварии на бою, с тем, что вы можете их предотвращать за счет качественного мониторинга, и с тем, что вы можете контролировать какие-то метрики качества.
2527.88 2535.92 "Филипп Бочаров" Если посмотреть на стандарты со, там есть всякие разные модели качества продукта, там есть результативность и производительность.
2535.92 2547.60 "Филипп Бочаров" Результативность – это как часто пользователь достигает успеха, пользуясь вашей системой, если 98% запросов обрабатывается, вот у вас результативность 98%.
2547.60 2556.12 "Филипп Бочаров" Так вот, результативность и производительность – это метрики, которые напрямую вычисляются из данных, которые дают наблюдаемость логов, метрик, трейсов.
2556.12 2559.84 "Филипп Бочаров" Так, и по вторую часть вопроса, когда этим следует заниматься.
2559.84 2567.68 "Филипп Бочаров" Ну, такой, сложно четко вот эту грань обозначить, но в целом я бы сказал так, тут есть как бы два критерия.
2567.68 2587.12 "Филипп Бочаров" Это сложность системы, если у вас нет человека, который в голове целиком держит вашу систему, может быстро на бумажке нарисовать схему, как это все работает, какие зависимости между компонентами и связи, то значит, вам нужна помощь какой-то автоматизированной системы, какого-то автоматизированного средства.
2587.12 2589.08 "Филипп Бочаров" Это как раз наблюдаемость и есть.
2589.08 2605.92 "Филипп Бочаров" И второе, это как раз качество, то есть если у вас жесткие требования к качеству, к доступности системы, к SLM, то наблюдаемость вам просто необходима, без нее вы не сможете контролировать эти параметры, понимать, что вы в них не укладываетесь и не сможете довести вашу систему до вот такого уровня качества.
2605.92 2625.44 "Анатолий Кулаков" Я еще слышал, компания Netflix с помощью телеметрии очень сильно экономит на QA разработчиках, то есть они мало тестируют свой продукт, а выкатывают практически из мастера каждую секунду в релиз и по телеметрии смотрят, сколько процентов пользователи получили там ошибки или отвалились, или у них были какие-то проблемы.
2625.44 2629.04 "Анатолий Кулаков" И если вдруг этот процент большой, то они начинают это все дело фиксить.
2629.04 2632.04 "Анатолий Кулаков" Если маленький, то раскатывают на более широкую аудиторию.
2632.04 2635.44 "Анатолий Кулаков" Вот как тебе кажется, это нормально, применение телеметрии?
2635.44 2636.44 "Анатолий Кулаков" Одобряешь такое?
2636.44 2638.44 "Филипп Бочаров" Ну, на самом деле, одобряю.
2638.44 2643.48 "Филипп Бочаров" Кажется, что это довольно классный современный подход.
2643.48 2649.92 "Филипп Бочаров" Мы так еще не делаем, но мне кажется, надо взять на угрожение их подход, попробовать как минимум.
2649.92 2654.48 "Анатолий Кулаков" Хорошо, допустим, мы поняли, что наше приложение нуждается в телеметрии.
2654.48 2657.24 "Анатолий Кулаков" Что бы ты посоветовал наблюдать в первую очередь?
2657.24 2662.92 "Анатолий Кулаков" Потому что когда смотришь, что ты можешь собрать в своем приложении, глаза разбегаются и непонятно, с чего все-таки начать.
2662.92 2665.16 "Анатолий Кулаков" Какие первые шаги, что собирать?
2665.16 2671.04 "Филипп Бочаров" Ну, я исхожу из того, что какой-то уровень логов у приложения уже так или иначе есть.
2671.04 2676.88 "Филипп Бочаров" Я думаю, что в 2021 году все так или иначе собирают логи, вопрос только в их качестве.
2676.88 2680.92 "Филипп Бочаров" Поэтому поговорим о чем-нибудь более интересном, например, о метриках.
2680.92 2684.40 "Филипп Бочаров" Метрики у нас есть разные, если выделять их уровни.
2684.40 2699.88 "Филипп Бочаров" Бизнес-метрики, количество продаж, метрики процессов в приложении, процесса продаж, его длительность, метрики отдельных приложений и метрики инфраструктуры, там, CPU, RAM на ваших хостах.
2699.88 2723.00 "Филипп Бочаров" Ну, наверное, самое, то, что легко собрать и то, что даст наибольший эффект, это метрики OPM, то есть это ваша бизнес-логика и метрики ее производительности, время ответа системы, время работы каждого шага вашего алгоритма, то, что вот обычно мы называем термином OPM.
2723.00 2741.12 "Филипп Бочаров" И метрики инфраструктуры, то есть с каждого узла, с каждого компонента, потребление системных ресурсов, сведенные вместе на какой-то каскад дашбордов, эти метрики дадут вам некий инсайт о том, почему ваша система не работает, из-за инфраструктуры или из-за бизнес-логики.
2741.12 2756.52 "Филипп Бочаров" Если вы будете добавлять к этому еще метрики бизнеса, бизнес-процессов, тогда вы можете еще больше увидеть, как влияет недоступность или аномалии в работе той или иной части вашей системы, как они влияют на ваш бизнес-показатель.
2756.52 2759.92 "Филипп Бочаров" Чем больше собираете, тем лучше видите.
2759.92 2762.16 "Филипп Бочаров" Это то, что касается метрик.
2762.16 2771.44 "Филипп Бочаров" Ну и конечно очень рекомендую вам внедрить в свой проект распределенную тарсировку, особенно если у вас микросервисная или сервис-ориентированная архитектура.
2771.44 2773.84 "Анатолий Кулаков" Отличные рекомендации, спасибо большое.
2773.84 2776.08 "Анатолий Кулаков" И, наверное, последний вопрос.
2776.08 2785.80 "Анатолий Кулаков" В «АллатРе» очень ходит много страшилок относительно телеметрии в том, что она сильно влияет на перформанс, что может убить абсолютно ваше приложение, и нужно быть с этим очень-очень аккуратным.
2785.80 2790.40 "Анатолий Кулаков" Что ты скажешь, как ты прокомментируешь, действительно ли есть проблемы с перформансом?
2790.40 2796.00 "Филипп Бочаров" Ну, надо всегда держать в голове, что действительно наблюдаемость – это не бесплатное удовольствие.
2796.00 2799.64 "Филипп Бочаров" Тут надо разделять вот эти три типа данных.
2799.64 2801.48 "Филипп Бочаров" Это логи, метрики, трейсы.
2801.48 2812.32 "Филипп Бочаров" Если их выстраивать по влиянию, то метрики – это наиболее небольшой объем данных, который собирается, поэтому метрики влияют в меньшей степени.
2812.32 2819.16 "Филипп Бочаров" Я, честно говоря, ни разу не видел, чтобы сбор метрик каким-то образом сильно повлиял на систему или привел к аварии.
2819.16 2821.24 "Филипп Бочаров" На моем опыте такого не было.
2821.24 2822.88 "Филипп Бочаров" Трассировка может влиять.
2822.88 2826.36 "Филипп Бочаров" Трассировка – это гораздо более большой поток данных.
2826.36 2838.68 "Филипп Бочаров" Для того, чтобы это нивелировать, есть специальный подход сэмплирования, это способ ограничения количества собираемых данных трассировки.
2838.68 2845.44 "Филипп Бочаров" Мы, правда, собираем 100% трассировки даже с высоконагруженных систем, и на самом деле у нас это работает хорошо.
2845.44 2860.40 "Филипп Бочаров" Но я слышал мнение коллег, есть отличный от моего опыт даже в рамках НТС, что даже включение трассировки на 100% может влиять на производительность.
2860.40 2861.40 "Филипп Бочаров" И логи.
2861.40 2864.04 "Филипп Бочаров" Логи действительно серьезное влияние.
2864.04 2871.68 "Филипп Бочаров" Если на высоконагруженной системе собирать 100% логов, это, скорее всего, на производительности скажется.
2871.68 2877.24 "Филипп Бочаров" Из-за больших объемов данных это влияет и на сеть, и на ЦПУ.
2877.24 2887.40 "Филипп Бочаров" И в моей практике действительно есть примеры, когда продуктивная система падала после включения расширенного логирования.
2887.40 2888.40 "Анатолий Кулаков" Прекрасно.
2888.40 2890.68 "Анатолий Кулаков" И, правда, тебе спасибо за такой развернутый и интересный комментарий.
2890.68 2896.08 "Анатолий Кулаков" А я напоминаю, что с нами был Филипп Бочаров, руководитель проектов в компании НТС.
2896.08 2902.12 "Игорь Лабутин" Давай теперь посмотрим немножко в сторону OpenTelemetry и непосредственно того, как же с этим жить.
2902.12 2908.44 "Игорь Лабутин" Потому что SDK хорошо, примеры, гайды это хорошо, но вот я там пишу какое-нибудь свое OSP на это приложение,
2908.44 2914.44 "Анатолий Кулаков" что мне делать? Тебе поможет отличная серия статей, которая называется Deep Dive into OpenTelemetry.
2914.44 2916.68 "Анатолий Кулаков" Давай кратко по ней пробежимся.
2916.68 2918.88 "Анатолий Кулаков" Прежде всего, прикладной уровень.
2918.88 2922.44 "Анатолий Кулаков" Никакой прикладной уровень, конечно, нам не нужен без визуализации.
2922.44 2928.20 "Анатолий Кулаков" UI-ка это то, что, в принципе, самое интересное для распределенной трассировки.
2928.20 2929.32 "Анатолий Кулаков" И здесь у нас есть два игрока.
2929.32 2932.08 "Анатолий Кулаков" Прежде всего, это Джаггер и Зипкин.
2932.08 2939.36 "Анатолий Кулаков" Зипкин имеет не настолько прекрасный и новомодный UI, поэтому, в принципе, автор рекомендует остановиться на первом кандидате.
2939.36 2954.16 "Анатолий Кулаков" Самая большая печаль, которая, в принципе, тревожила всех дот-нет разработчиков еще при разработке OpenTelemetry и, в принципе, продолжает тревожить сейчас, это в том, что Microsoft не придерживается стандартных именований, которые отражены в спецификации и в протоколе.
2954.16 2956.92 "Анатолий Кулаков" То есть, Microsoft изобрел свои собственные названия.
2956.92 2967.64 "Анатолий Кулаков" Ну, не то, чтобы изобрел, Microsoft просто делался под существующий уже фреймворк, который уже включал в себя нечто похожее на распределенную трассировку.
2967.64 2970.24 "Анатолий Кулаков" И, может быть, даже некоторые из вас его использовали.
2970.24 2972.00 "Анатолий Кулаков" Это классики на основе Activity.
2972.00 2974.60 "Анатолий Кулаков" Если же нет, сейчас я вам расскажу.
2974.60 2980.44 "Анатолий Кулаков" Для вас сейчас главное запомнить, что если вы будете читать спецификации и будете читать дот-нетовские классы, то они будут расходиться.
2980.44 2988.92 "Анатолий Кулаков" В принципе, Microsoft постарался сделать маппинг один в один, но названия все-таки остались старинными микрософтовскими.
2988.92 2997.72 "Анатолий Кулаков" Также нужно сказать, что, скорее всего, вам не захочется собирать распределенную трассировку на 100% ваших запросов.
2997.72 3001.40 "Анатолий Кулаков" Хотя, вот как мы видели у друзей из МТС, в принципе, это получается.
3001.40 3005.76 "Анатолий Кулаков" Но основные рекомендации - это можете собирать около 10% ваших запросов.
3005.76 3009.92 "Анатолий Кулаков" То есть, в принципе, рандомно или по какому-то специальному флагу, который вы передаете в запросе.
3009.92 3017.20 "Анатолий Кулаков" Но автор рекомендует не начинать сразу со 100% всех сборок, потому что это может сильно просадить ваш перформанс.
3017.20 3022.88 "Анатолий Кулаков" Прежде всего, самым главным классиком в OpenTracing является Activity.
3022.88 3026.72 "Анатолий Кулаков" В спецификации OpenTelemetry она называется Spans.
3026.72 3038.56 "Анатолий Кулаков" Это уникальный идентификатор, который имеет время начала и время окончания, у которого есть ссылка на Parent и который имеет какие-то уникальные данные.
3038.56 3049.88 "Анатолий Кулаков" То есть, если вы представите какое-нибудь дерево загрузки ваших файликов в браузере, то вот это как раз одна полосочка, один файлик - это и будет вот этот Activity.
3049.88 3053.80 "Анатолий Кулаков" То есть, это ровно то, что произвела одна операция от начала и до конца.
3053.80 3058.24 "Анатолий Кулаков" Сколько она длилась, какие ивенты породила и какие новые данные в себя включает.
3058.24 3060.52 "Анатолий Кулаков" Далее есть такое понятие как Events.
3060.52 3066.44 "Анатолий Кулаков" Это некие события, у которых есть время и они привязаны к какой-то Activity.
3066.44 3075.74 "Анатолий Кулаков" То есть, если в процессе вашего длительного процесса что-то происходит, какие-то важные ивенты, то вы можете отражать это на временной прямой с помощью вот этих маленьких Events.
3075.74 3079.24 "Анатолий Кулаков" Далее у каждой Activity есть теги.
3079.24 3087.64 "Анатолий Кулаков" Это обычные KeyValue значения, которые также можно присобачить к Activity и они будут путешествовать вместе с ней везде.
3087.64 3090.68 "Анатолий Кулаков" Теги очень важны для всяких UI.
3090.68 3099.32 "Анатолий Кулаков" Если вы будете соблюдать определенную конвенцию, которую UI обычно декларирует, у вас будет красиво эти теги использовать.
3099.32 3107.88 "Анатолий Кулаков" Например, визуализация поможет подсказать, где у вас идет HTTP протокол, где общение с базой данных, где какие-то очереди, а где у вас записалось исключение.
3107.88 3110.88 "Анатолий Кулаков" Все это делается с помощью конвенции над тегами.
3110.88 3115.76 "Анатолий Кулаков" Но самое интересное, конечно же, начинает происходить, как только мы выходим за границы процесса.
3115.76 3122.68 "Анатолий Кулаков" Распределенная трассировка была бы не так вам интересна, не так важна, если бы мы говорили только о локальных Activity.
3122.68 3128.92 "Анатолий Кулаков" Каким же образом стало возможно передавать нашу Activity, передавать наш трейсинг между различными приложениями?
3128.92 3136.28 "Анатолий Кулаков" Прежде всего немаловажную роль здесь сыграла спецификация W3C Trace Context Standard.
3136.28 3143.44 "Анатолий Кулаков" Это специальный контекст, который описывает, каким образом в ваших HTTP-хедерах вы можете передавать вашу распределенную трассировку.
3143.44 3147.96 "Анатолий Кулаков" И там есть много хедеров, для нас, наверное, интересные три.
3147.96 3157.52 "Анатолий Кулаков" Прежде всего, это Trace Parent, который включает в себя версию, уникальный идентификатор трассировки, уникальный идентификатор парента и какие-то трассировочные флаги.
3157.52 3165.00 "Анатолий Кулаков" Также есть Trace State, это вендор-специфик, ключ значения пары, которые также ходят с этой трассировкой.
3165.00 3168.36 "Анатолий Кулаков" И еще один дружок - это багаж.
3168.36 3176.68 "Анатолий Кулаков" Это похоже чем-то на теги, но теги существуют в рамках одного процесса и в рамках одной активити, багаж же намного хитрее.
3176.68 3186.32 "Анатолий Кулаков" Он умеет пролазить между процессами, как раз таки из-за спецификации HTTP-заголовков, а также он умеет пропагетиться на все челдовые спаны.
3186.32 3200.76 "Анатолий Кулаков" То есть, если вы открыли какой-нибудь KVL-ю багаж над самым рутовым запросом, то все остальные запросы, которые пойдут уже после него в другие процессы, они будут иметь доступ к этому багажу, к этому контексту.
3200.76 3209.28 "Анатолий Кулаков" Если кто-то из вас работал с логами, и в частности с CD-логом, то вы могли сталкиваться с такой концепцией, как лог-контекст.
3209.28 3214.88 "Анатолий Кулаков" Это вот лог-контекст, это как раз таки проекция багажа, но только межпроцессорная.
3214.88 3237.16 "Игорь Лабутин" И на самом деле это все такая теория, но фактически из-за вас много работы уже сделано, HTTP-клайнт автоматически будет вам все это, все эти хедера посылать, если он понимает, что вы сейчас находитесь внутри конкретной активити, а SPNetCore, соответственно, как сервер будет читать все эти заголовки и корректно создавать нужные вам активити.
3237.16 3246.24 "Игорь Лабутин" Также это все работает для jrpc.net, для SQL-клайнта, для Redis, Jimmy Bogart, соответственно, дописал это для NServiceBus и для MongoDB-драйвера.
3246.24 3260.80 "Игорь Лабутин" Ну, в общем, потихонечку это дело начинает распространяться по всем библиотечкам, и многие библиотеки при работе между процессами начинают правильно и корректно передавать этот самый контекст.
3260.80 3269.68 "Анатолий Кулаков" В принципе, все, что вам нужно прямо сейчас, это обновить все ваши библиотеки, и они уже начнут вырабатывать какую-то полезную информацию.
3269.68 3273.16 "Анатолий Кулаков" Далее, если вы захотите ее подключить, просто настраивайте определенные флажки.
3273.16 3281.36 "Анатолий Кулаков" В принципе, если вы хотите плотно все-таки этим заняться и посмотреть, что же происходит в вашем настоящем приложении, то это сделать довольно-таки просто.
3281.36 3288.44 "Анатолий Кулаков" SPNetCore уже поддерживает всю OpenTelemetry и установить его, запустить его это очень-очень просто.
3288.44 3293.44 "Анатолий Кулаков" Вам достаточно установить пакет OpenTelemetry Extensions Hosting в ваше приложение.
3293.44 3310.56 "Анатолий Кулаков" Также после того, как вы добавите пакет OpenTracing Instrumentation SPNetCore, у вас автоматически во всех ваших реквестах и респонсах начнут появляться вот эти магические хедра, которые позволят вашему приложению не нарушать цепочку OpenTracing, а дальше как минимум ее передавать и пропускать.
3310.56 3321.16 "Анатолий Кулаков" То есть, если вы даже не будете использовать сами эти хедра, не будете использовать сами эти метрики, то какой-нибудь DevOps скажет вам большое спасибо, что вы хотя бы их не обрезаете.
3321.16 3329.04 "Анатолий Кулаков" Далее вы можете для быстрого эксперимента добавить к себе такой экспортер, который называется Console.
3329.04 3342.12 "Анатолий Кулаков" Он вам прямо в Console вывалит все, что сейчас собрало ваше приложение и покажет, а что бы он отправил, если бы у вас был настоящий какой-нибудь UI, который бы хранил и визуализировал эти данные.
3342.12 3347.08 "Анатолий Кулаков" Но на самом деле экспортеров полно и все они довольно рабочие и полезные.
3347.08 3356.32 "Анатолий Кулаков" Находятся они все в пакетах OpenTelemetry Exporters и далее точка и название того, куда вы захотите это все заэкспортить.
3356.32 3364.08 "Анатолий Кулаков" Достаточно добавить всего пару строчек кода в ваш ASP.NET ConfigureServices метод и в принципе все заработает.
3364.08 3381.76 "Анатолий Кулаков" В Console после такого нехитрых маневров вы сразу сможете увидеть, например, время старта ваших операций, их продолжительность, посмотреть какие теги проставляет ASP.NET Core, посмотреть статусы, которые возвращаются в респонсах и вот такую базовую информацию, которую вы в принципе наверняка видите в своих логах.
3381.76 3385.16 "Анатолий Кулаков" Теперь сможете ее видеть и в том числе и в Telemetry.
3385.16 3388.80 "Анатолий Кулаков" Но, как я уже говорил, самая важная все-таки часть это визуализация.
3388.80 3394.72 "Анатолий Кулаков" И если вы хотите все-таки увидеть, чем же по-настоящему занимается ваше приложение, то здесь вам на помощь приходит Ягер.
3394.72 3399.76 "Анатолий Кулаков" Я напомню, что в принципе Ягер это не какой-то там один-единственный обязательный проприетарный продукт.
3399.76 3404.52 "Анатолий Кулаков" Это консольное приложение, которое в принципе работает по стандартному протоколу OpenTelemetry Protocol.
3404.52 3409.28 "Анатолий Кулаков" И соответственно вы можете абсолютно любое приложение подсадить на этот протокол или даже написать свое.
3409.28 3415.88 "Анатолий Кулаков" Итак, Ягер это прежде всего веб-дашборда, который показывает вам красивые графики.
3415.88 3424.40 "Анатолий Кулаков" Самый простой способ запустить ее это Docker Image, потому что там у него много зависимостей, много всяких настроек и как всегда Docker приходит на помощь.
3424.40 3437.08 "Анатолий Кулаков" В нашем же ASP.NET пакете вам достаточно подключить экспортер OpenTelemetry Protocol, который будет выдавать это все в стандартном формате и добавить пару конфигураций с нужным портом в конфигурсервисис.
3437.08 3440.88 "Анатолий Кулаков" После этого Ягер-дашборд готов показывать все, что творится в вашем приложении.
3440.88 3450.00 "Анатолий Кулаков" Достаточно сделать вам всего несколько реквест-респонсов и вы увидите развесистое красивое дерево в вашем браузере.
3450.00 3453.16 "Анатолий Кулаков" Ну, соответственно, если у вас там будут какие-то еще сервисы, которые будут с вами работать.
3453.16 3457.72 "Анатолий Кулаков" Если же не будут, то вы увидите просто плоское дерево в вашем браузере.
3457.72 3471.52 "Анатолий Кулаков" Вы сможете посмотреть на Activity, который я описывал выше, вы сможете потыкать в теги, вы сможете посмотреть время, которое занимается той или иной операцией, а также статус коды и прочие интересные вещи, которые ASP.NET Core прописывает в респонсы.
3471.52 3475.40 "Игорь Лабутин" В общем, звучит прям интересно и можно попробовать на практике.
3475.40 3482.16 "Игорь Лабутин" То есть, будь то Ягер, если мы там, например, хостим все в Ажуре, но существует экспортер для AppInsights.
3482.16 3494.60 "Игорь Лабутин" AppInsights в принципе нативно позволяет все это посмотреть, но если ваш код поддерживает OpenTelemetry, то вы можете из этого кода здесь в библиотеку тоже кидать информацию в AppInsights, там будет все прекрасно, красиво, наглядно показываться.
3494.60 3495.60 "Анатолий Кулаков" Да, так точно.
3495.60 3500.12 "Анатолий Кулаков" В принципе, сейчас во всех облаках уже есть какие-то инструменты, которые поддерживают OpenTelemetry.
3500.12 3516.12 "Анатолий Кулаков" Если же вы находитесь с другой стороны забора, то есть вам наоборот нужно как-то проинструментировать свою библиотеку, чтобы она поддерживала OpenTelemetry, Activities и все вот эти новомодные вещи, то для вас есть отличная серия статей Джимми Боггарта, которая называется "Building end-to-end diagnostics".
3516.12 3519.84 "Анатолий Кулаков" Вкратце, не углубляясь, расскажу, что он там делает.
3519.84 3529.72 "Анатолий Кулаков" В принципе, у него очень хорошая есть концепция того, что нужно сделать, чтобы вообще вот эта вся сеть, вся эта OpenTelemetry, она работала.
3529.72 3539.52 "Анатолий Кулаков" Потому что здесь как раз-таки функциональность зависит не только от вашего конкретного приложения, но и от абсолютно всей цепочки тех микросервисов, тех сервисов, с которыми вы взаимодействуете.
3539.52 3551.68 "Анатолий Кулаков" Прежде всего, входящий нетворк Traffic должен забирать всю информацию из OpenTelemetry заголовков и отдавать ее во весь исходящий Traffic.
3551.68 3558.12 "Анатолий Кулаков" То есть весь исходящий Traffic должен точно так же инструментироваться OpenTelemetry информацией.
3558.12 3566.00 "Анатолий Кулаков" Между этим ваше приложение, конечно же, может само добавлять какие-то диагностики, какие-то теги или создавать свои собственные Activities.
3566.00 3583.12 "Анатолий Кулаков" И если все цепочки будут работать именно так, то вы и увидите вот это самое распределенное дерево всех вызовов от самого начала, от самого HTTP-клайента, которое проходит через ASP.NET Core, которое идет в Rebit, оттуда переходит в SQL, в базу данных какую-то.
3583.12 3587.24 "Анатолий Кулаков" И вот именно тогда вы получите всю эту карту.
3587.24 3593.36 "Анатолий Кулаков" В принципе, если задаться целью, то не так уж и сложно сделать инструментацию из вашей собственной библиотеки.
3593.36 3596.04 "Анатолий Кулаков" Для этого достаточно создать специальный класс ActivitySource.
3596.04 3600.32 "Анатолий Кулаков" Это такая своеобразная фабрика всех Activities, которые будут в вашем приложении.
3600.32 3613.52 "Анатолий Кулаков" Далее, если у вас есть какая-то длительная операция, которую вы хотите обозначить отдельной Activity в этом распределенном дереве, вы просто говорите ActivitySource, StartActivity, передаете ей какие-то атрибуты, теги, не суть важно.
3613.52 3628.76 "Анатолий Кулаков" После этого у этой Activity вы можете точно так же задавать багаж, делать какие-то настройки, добавлять, менять какие-то теги, после того как ваша Activity закончилась, вы вызываете StopActivity и все, Trace в этот момент записывается уже в хранилище.
3628.76 3642.28 "Игорь Лабутин" Ну, либо вы вместо StopActivity просто это все оборачиваете в Using, удобная штука, которая просто по мере выхода из блока Using в файл аккуратненько задиспоусит Activity, и это будет означать, что оно остановлено.
3642.28 3647.56 "Анатолий Кулаков" Еще парочку таких полезных, как ты сказал, хаков как раз есть у Джимми, хотелось бы их подчеркнуть.
3647.56 3658.16 "Анатолий Кулаков" Во-первых, он заметил, что Егерь стандартно на первом экране показывает только теги, он не показывает багаж, то есть те данные, которые ходят как раз между спанами, между процессами.
3658.16 3662.12 "Анатолий Кулаков" Для этого нужно вам зайти внутрь спана и там где-то отыскать весь этот багаж.
3662.12 3672.28 "Анатолий Кулаков" Поэтому он написал для себя специальный Activity Listener, который слушает все Activity, которые появляются в этом процессе и копирует все, что есть в багаже, как раз таки в теге.
3672.28 3678.00 "Анатолий Кулаков" Это позволяет ему визуально сделать более привлекательную картинку для своего приложения.
3678.00 3692.92 "Игорь Лабутин" Причем тем более, что багаж это как раз таки, скорее всего, чуть более важные теги, чем просто теги, потому что это, например, какой-нибудь, не знаю, юзернейм, который должен быть проассоциирован со всеми спанами, которые есть в этой логической операции.
3692.92 3696.32 "Игорь Лабутин" И поэтому, конечно, хотелось бы видеть такие теги сразу.
3696.32 3698.28 "Анатолий Кулаков" Да, да, так точно.
3698.28 3700.56 "Анатолий Кулаков" И еще один интересный примерчик.
3700.56 3714.96 "Анатолий Кулаков" Я уже упоминал, что багаж очень сильно похож на лок контексты и Джимми как раз таки сделал еще одну интересную штуку, которая берет ваш багаж и с помощью специального серилога Enricher добавляет весь этот багаж в ваш лок ивент.
3714.96 3720.72 "Анатолий Кулаков" То есть вы сможете эту информацию также видеть и в серилоговском выхлопе, что тоже довольно таки полезная вещь.
3720.72 3723.16 "Анатолий Кулаков" Как я уже сказал, там большая серия статей.
3723.16 3728.60 "Анатолий Кулаков" Джимми писал свои примеры и затронул очень много интересных аспектов.
3728.60 3742.84 "Анатолий Кулаков" Он вам расскажет про трейс-контексты, Activity, корреляции, визуализацию, по-другому, как взаимодействовать с экспортерами, как делать User-Defined контексты и как OpenTelemetry можно интегрировать в существующие библиотеки.
3742.84 3745.24 "Анатолий Кулаков" На примере NServiceBus и MongoDB.
3745.24 3757.12 "Анатолий Кулаков" Он для них сделал хорошую инструментацию, которая уже позволяет на первых шагах, если ваше приложение использует эту шинку и эту базу, уже добавить к нему какой-то дополнительной интересной визуализации.
3757.12 3759.64 "Анатолий Кулаков" Вот такой дивный интересный мир перед нами открывается.
3759.64 3765.32 "Анатолий Кулаков" Я думаю, после релиза как раз спецификаций все это будет только еще больше и цести и пахнуть.
3765.32 3780.32 "Игорь Лабутин" Я привыкаю читать логи не просто в текстовых файликах, а сначала смотреть на большие распределенные деревья того, как реквест или логическая операция путешествует по всем вашим десяткам, сотням микросервисов и понимать, где находятся ошибки.
3780.32 3786.88 "Игорь Лабутин" По-первых, это может быть действительно непривычно, но потом понимаешь все удобства этой конструкции.
3786.88 3798.92 "Игорь Лабутин" А учитывая то, как легко на самом деле под нее писать и легко создавать свои спаны и какие-то свои теги навешивать, это действительно полезная штука для использования практически в любом распределенном приложении.
3798.92 3801.72 "Игорь Лабутин" Я бы даже сказал просто в любом распределенном приложении.
3801.72 3817.80 "Анатолий Кулаков" Да, для обсервабилити, особенно когда у нас выйдет все-таки все три компонента, то есть у тебя будет распределенное дерево, которое будет привязываться к метрикам, соответственно может тебе сразу показывать и загрузку, и CPU, и обжирание памяти, и время исполнения каждой Activity.
3817.80 3820.40 "Анатолий Кулаков" Это автоматически уже можно как-то подсвечивать.
3820.40 3836.92 "Анатолий Кулаков" Далее можно зайти внутрь Activity, посмотреть все подробные логи, которые происходили в рамках этой Activity и перейти уже непосредственно к строчкам кода, где эти логи писались, и может быть посмотреть программу, которая может быть в распределенном репозитории где-то или в какой-то другой команде, абсолютно сделано отправить им отчет.
3836.92 3845.48 "Анатолий Кулаков" То есть когда вся эта картина сольется вместе, появится огромная база инструментированных библиотек, то вот здесь как раз-таки и будет самая большая мощь.
3845.48 3856.24 "Игорь Лабутин" Да, и чувствительно нам нужны будут тулзы по типу ягерей, которые будут уметь делать на самом деле все вместе, потому что ягеря это только про трейсинг, если я правильно понимаю, логи в нем смотреть нельзя.
3856.24 3857.24 "Игорь Лабутин" Именно так.
3857.24 3858.36 "Анатолий Кулаков" Но может быть это только пока.
3858.36 3867.08 "Анатолий Кулаков" Ну и кстати, по субъективным ощущениям, все сейчас визуализационные тулзы для распределенного трейсинга довольно убоги.
3867.08 3883.16 "Анатолий Кулаков" То есть я все-таки надеюсь, что выйдет какой-то инструмент, который заменит существующие ягерей, и который будет более ориентирован как раз-таки на полную обсервабилити и более удобную работу с большим количеством микросервисов.
3883.16 3887.60 "Игорь Лабутин" Ну посмотрим, на Кибана же, или сейчас не Кибана, а Графана.
3887.60 3894.52 "Игорь Лабутин" Графана же в ту же сторону логов пошла, они же делали какой-то тул для логов, соответственно, может туда же и трейсинг допилят.
3894.52 3907.48 "Анатолий Кулаков" Вот Графана, да, это отличный пример, потому что она изначально начиналась с метрик, она сейчас добавила логи, и в принципе им осталось делать только распределенную трассировку, что с их опытом визуализации вообще плевое дело.
3907.48 3917.52 "Анатолий Кулаков" Я был бы очень рад, если бы Графана добавила трассировку, и тогда ничего в принципе от жизни больше не нужно, потому что у нее сейчас метрики и логи уже провязаны единым контекстом, и это прекрасно.
3917.52 3920.88 "Игорь Лабутин" Ну вот логи не пробовал пока в ней, но метрики показывают шикарно.
3920.88 3928.20 "Игорь Лабутин" Ладно, давай затронем самую последнюю тему, она немножко особенечком стоит, но мне хотелось ее упомянуть.
3928.20 3941.40 "Игорь Лабутин" Я довольно редко, надо сказать, ставлю всякие экстенджины в Visual Studio, да и в Raider у меня не так много экстенджинов, но вот этот вот прям оказался суперполезным, называется Source Server Browser Power Tool.
3941.40 3945.48 "Игорь Лабутин" Это экстенджин для Visual Studio, и он позволяет сделать следующую штуку.
3945.48 3962.60 "Игорь Лабутин" Как мы знаем, в NuGet пакеты, ну и не только в NuGet пакеты, на самом деле, а .NET сборки можно собирать с так называемой Source Link информацией, ну или просто с Source информацией, то есть PDB-шка для этого пакета будет знать, где искать сурсы.
3962.60 3969.44 "Игорь Лабутин" То есть Raider, когда мы пытаемся отлаживать процессы, и он встречает какую-то длельку, для которой нет исходников, он ее просто декомпилирует на лету.
3969.44 3987.80 "Игорь Лабутин" Но в принципе, особенно если вы делаете in-house разработку, в том смысле, что такие длельки просто это ваши же NuGet пакеты, собранные в вашей же компании, исходники для них лежат в вашем же Source Control, гораздо удобнее, чем просто смотреть на исходные коды, где есть все комментарии, ну вот все, как вы и так знаете этот код.
3987.80 3998.76 "Игорь Лабутин" Для этого используется Source Link, который при сборке указывает конкретно, где из какого места брать исходник, из какой ревизии, из Source Control, в каком бранче и так далее, это все живет.
3998.76 4004.24 "Игорь Лабутин" И вот этот вот экстенджер, он позволяет это все браузить, смотреть, то есть проблема же, отладки в чем?
4004.24 4014.40 "Игорь Лабутин" В студии, по крайней мере, что пока вы не упали каким-то образом в нужный файлик из сторонней, так скажем, библиотеки, вы не сможете поставить туда breakpoint.
4014.40 4029.72 "Игорь Лабутин" Сейчас это теперь стало можно делать, то есть можно в Source Server вот в этом вот плагинчике, это отдельное окошко в дебак режиме, посмотреть на все длельки, у которых есть такая информация о сурсах и найти нужные вам файлики, это же ваш код, и поставить там breakpoint.
4029.72 4040.80 "Игорь Лабутин" Мне прям супер помогло, у нас довольно много NuGet пакетов, то есть продукт состоит из довольно большого количества NuGet пакетов, которые мы сами же делаем, и это прям очень удобно и хорошо зашло.
4040.80 4053.64 "Игорь Лабутин" Поэтому если вы используете такую штуку, и причем это не только ваши пакеты, на самом деле у меня там показываются и какие-то довольно сторонние пакеты тоже, которые просто правильно проаннотированы эти SourceLink, введут на GitHub, и все прекрасно работает.
4053.64 4065.92 "Анатолий Кулаков" Слушай, у меня работала схема, когда я по Ctrl+T, решарперовскому, находил тот класс, который мне интересен, и если есть SourceLink, он его как раз-таки не декомпилировал, а подтаскивал исходники и прямо там ставил breakpoint.
4065.92 4066.92 "Анатолий Кулаков" В принципе и все.
4066.92 4070.20 "Игорь Лабутин" Вот у меня иногда такое работало, иногда такое не работало.
4070.20 4076.80 "Игорь Лабутин" То есть с SourceLink оно работает как-то гарантированно, вот здесь я просто могу побраузиться, найти конкретный файлик и вот заработало.
4076.80 4086.88 "Игорь Лабутин" Мне в общем-то это сильно помогло, но может быть потому, что я не такой сейчас активный пользователь решарпера под студией, то есть если вы вдруг почему-то решарпер в студии не держите, то может быть эта штука вам тогда поможет чуть лучше.
4086.88 4090.88 "Игорь Лабутин" Ну в общем, вот такая вот вещь.
4090.88 4092.88 "Игорь Лабутин" Ладно, на сегодня нам надо завершаться.
4092.88 4094.28 "Игорь Лабутин" Да, давай подводить итоги.
4094.28 4097.08 "Игорь Лабутин" Ну итогов сегодня не так много.
4097.08 4103.28 "Игорь Лабутин" .NET 6 превью 2 со всеми, ну тем не менее, будут раз в месяц нас радовать.
4103.28 4104.84 "Игорь Лабутин" Интересно, до 10 успеем добраться?
4104.84 4111.24 "Игорь Лабутин" Нет, до 10 наверное не успеем добраться, будет превьюшек наверное 6, 7 наверное успеем сделать, но посмотрим.
4111.24 4131.20 "Игорь Лабутин" Microsoft Toolkit High Performance, системной релиз, там всякие улучшатели, экстенджн методы и новые типы для работы в высокопроизводительных приложениях, новый канал JetBrains, ну или плейлист как правильно называется, JetBrains Open Source Power Apps, где есть обучающие и такие вводные видосики с авторами популярных библиотек.
4131.20 4147.76 "Игорь Лабутин" Посмотрели что произошло с Nougat, давно не затрагивали, подробненько обсудили тему OpenTelemetry распределенной трассировки, как на это смотреть, если вы разработчик приложений, как на это смотреть, если вы разработчик библиотек и хотите поддержать эту самую трассировку.
4147.76 4154.96 "Игорь Лабутин" И в конце быстренько затронули вопрос SourceLink, плагин, как это посмотреть, или может быть нужно просто использовать ReSharper, все будет работать.
4154.96 4155.96 "Игорь Лабутин" Как вам удобнее.
4155.96 4163.88 "Анатолий Кулаков" Отлично, а на сегодня все, хочешь поддержать наш подкаст заходи на Boosty и Patreon, ссылки в описании, посмотри что там есть.
4163.88 4164.88 "Игорь Лабутин" Всем пока.
4164.88 4165.88 "Игорь Лабутин" Всем пока, до новых встреч.
4165.88 4172.40 None [музыка]
