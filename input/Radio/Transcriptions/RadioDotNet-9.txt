0.00 4.36 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
4.36 7.24 "Анатолий Кулаков" В эфире Radio.net, выпуск номер 9.
7.24 9.36 "Анатолий Кулаков" И в студии с вами, как всегда, Анатолий Кулаков.
9.36 10.64 "Анатолий Кулаков" И Игорь Лабутин.
10.64 17.36 "Анатолий Кулаков" Прежде всего хотелось бы сказать спасибо всем тем, кто откликнулся на наш призыв в прошлом выпуске и оставил свои отзывы.
17.36 24.44 "Анатолий Кулаков" Напомню, что мы открыли YouTube-канал, и там отличная площадка для комментариев и фидбэка по нашим выпускам.
24.44 36.04 "Анатолий Кулаков" Поэтому всех милости просим туда, заходите, рассказывайте нам о том, что вы считаете важным обсудить, что нам стоит поправить, куда стоит двигаться и так далее.
36.04 45.48 "Анатолий Кулаков" Мы разыграли три лицензии от JetBrains среди комментаторов и среди тех, кто помогал нам распространять информацию о подкасте.
45.48 47.12 "Анатолий Кулаков" Вот, им тоже отдельное спасибо.
47.12 49.08 "Анатолий Кулаков" И пойдем к темам.
49.08 52.60 "Анатолий Кулаков" А в темах у нас как раз-таки JetBrains.
52.60 58.84 "Анатолий Кулаков" JetBrains делает конференцию, которая называется .NET Days Online.
58.84 62.48 "Анатолий Кулаков" Эта конференция пройдет естественно в онлайне.
62.48 64.72 "Анатолий Кулаков" Она будет 13-14 мая.
64.72 68.68 "Анатолий Кулаков" Начнется с 14.00 по Москве и закончится примерно в 22.30.
68.68 72.76 "Анатолий Кулаков" Ивент полностью виртуальный, свободный для посещения.
72.76 76.96 "Анатолий Кулаков" Можно уже сейчас регистрироваться.
76.96 79.40 "Анатолий Кулаков" Будет идти два дня.
79.40 81.48 "Анатолий Кулаков" Спикеры будут не только из JetBrains.
81.48 84.72 "Анатолий Кулаков" Из JetBrains я бы даже сказал почти нет никого.
84.72 95.84 "Анатолий Кулаков" Спикеров набирали со всего мира, всех, кто желал, всех, кто хотел рассказать не только про технологии, которые продает компания, но и про все, что считали нужными.
95.84 98.80 "Анатолий Кулаков" Например, хотелось бы отметить несколько докладов.
98.80 101.88 "Анатолий Кулаков" Андрей Карпов расскажет про Async Streams.
101.88 104.28 "Анатолий Кулаков" Андрей очень большой профессионал.
104.28 110.80 "Анатолий Кулаков" Он работает в команде, которая пишет как раз инструменты для разработчиков в компании JetBrains.
110.80 114.16 "Анатолий Кулаков" И очень хорошо, интересно рассказывает и тема отличная.
114.16 116.04 "Анатолий Кулаков" Ее должен знать практически каждый.
116.04 117.64 "Анатолий Кулаков" Поэтому обратите внимание.
117.64 120.40 "Анатолий Кулаков" Еще одна забавная тема это Tess Fernandes.
120.40 123.96 "Анатолий Кулаков" У нее тема называется From C# to Python.
123.96 141.40 "Анатолий Кулаков" Не подумайте ничего плохого, просто спикер знала C#, перешла на Python и увидела, попыталась программировать так, как программируют нормальные люди на C# и увидела, что ее код немножко не соответствует тем гайдлайнам и тем ожиданиям, которые предъявляла команда.
141.40 159.20 "Анатолий Кулаков" И вот она расскажет все-таки, как нужно изменить свой майндсет, как можно изменить свое поведение, как нужно писать так, чтобы команда Python посчитала вас за свою, за своего разработчика и не перепутала с каким-нибудь C# пистом.
159.20 161.52 "Анатолий Кулаков" Тоже довольно интересно, наверное, будет послушать.
161.52 162.52 "Анатолий Кулаков" Рикардо Терел.
162.52 168.04 "Анатолий Кулаков" Highly performant computation with gRPC for ISPnet.
168.04 170.44 "Анатолий Кулаков" Вечная тема gRPC, ISPnet.
170.44 174.88 "Анатолий Кулаков" Тоже хороший спикер, наверняка будет, что это очень интересно.
174.88 182.60 "Анатолий Кулаков" Алексей Голубь расскажет нам о том, как выучить F# и не просто выучить, а вот сразу на примере дизайна своего собственного языка.
182.60 190.36 "Анатолий Кулаков" Очень увлекательно, я думаю, каждый из нас мечтал написать свой собственный язык и почему бы при этом не выучить F# по пути.
190.36 192.32 "Анатолий Кулаков" Очень заманчиво.
192.32 204.24 "Анатолий Кулаков" Все сессии будут записаны, конечно же, и опубликованы сразу после окончания ивентов, поэтому даже если вы не попали на сам ивент, можно найти плейлист и посмотреть, что же там все-таки происходило, какое мракобесие.
204.24 206.56 "Анатолий Кулаков" Следующая большая конференция.
206.56 214.32 "Игорь Лабутин" Не менее известная компания Microsoft организует тоже онлайн-конференцию под названием Microsoft Build 2020.
214.32 220.60 "Игорь Лабутин" Обычно это офлайн-мероприятие, но в этот раз это полностью онлайн-событие.
220.60 236.00 "Игорь Лабутин" И там будут выступать, естественно, топовые спикеры от Microsoft, которые откроются от всего выступления у Сати Анателло, и дальше Скотт Хансельман и остальные будут радовать нас различными докладами.
236.00 248.04 "Игорь Лабутин" Все это длится 2 дня, 19 и 20 мая по американскому времени, это начнется где-то в 6 вечера по Москве, 19 мая, и нон-стопом 48 часов.
248.04 253.76 "Игорь Лабутин" Некоторые доклады, я так понимаю, будут повторены в записи, какие-то будут, возможно, вживую.
253.76 259.72 "Игорь Лабутин" И смотрите, все новости Microsoft там, регистрируйтесь, все бесплатно.
259.72 266.48 "Анатолий Кулаков" Кроме Хансельмана там будет, естественно, Сати Анателло, Мэтт Торгессон, Скотт Гатри, Марк Русинович и много-много других именитых спикеров.
266.48 270.12 "Анатолий Кулаков" Кстати, Хансельман будет еще и на .NEXT.
270.12 275.24 "Анатолий Кулаков" И уж если мы завели блог про конференции, нельзя промолчать про .NEXT.
275.24 281.64 "Анатолий Кулаков" Он тоже перешел в онлайн, теперь его можно посмотреть с любой точки мира, не отрываясь от стула.
281.64 284.72 "Анатолий Кулаков" Что же осталось на месте?
284.72 290.28 "Анатолий Кулаков" На месте, безусловно, остался наш промокод, который вы можете пользоваться и получить скидочку на билет.
290.28 295.88 "Анатолий Кулаков" А также наикрутейшие докладчики, практически все, кто был запланирован изначально.
295.88 303.24 "Анатолий Кулаков" Кстати, можете посмотреть или послушать наш выпуск про .NEXT, который мы недавно записывали, про питерский .NEXT.
303.24 309.20 "Анатолий Кулаков" Там мы подробно вместе с Андреем Акиншиным прошлись по всем докладам и обсудили, что от чего ожидать.
309.20 313.84 "Анатолий Кулаков" Вот если вы еще не слышали, вернитесь немножко назад и сделайте это.
313.84 316.00 "Анатолий Кулаков" Нас безусловно ждут новые форматы выступления.
316.00 318.48 "Анатолий Кулаков" Jigroo готовит что-то сверхъестественное.
318.48 321.16 "Анатолий Кулаков" Они пишут свою собственную платформу для вещания.
321.16 325.28 "Анатолий Кулаков" Они обучают команду под новые какие-то форматы.
325.28 326.76 "Анатолий Кулаков" Они закупают оборудование.
326.76 333.48 "Анатолий Кулаков" В общем, они городят там какое-то большое интересное техническое месиво в плане форматов.
333.48 335.64 "Анатолий Кулаков" То есть это тоже будет что-то новое, интересное.
335.64 339.72 "Анатолий Кулаков" Мне очень хочется поучаствовать в этом и посмотреть, что же из всего этого получится.
339.72 354.92 "Игорь Лабутин" В онлайне будет, соответственно, не только .NEXT, в онлайне будут все остальные конференции весеннего, так скажем, сезона от JugRu Group и вы можете посмотреть все 8 конференций по цене обычного одного офлайн билета.
354.92 363.44 "Игорь Лабутин" Так что приходите, смотрите, обучайтесь не только .NET, но .NEXT, конечно, мы постараемся сделать как можно более крутым.
363.44 373.84 "Игорь Лабутин" Продлится все это 4 дня с 15 по 18 июня, блоками по 4-5 часов, чтобы не сильно устать и иметь возможность сделать что-то параллельно в эти дни.
373.84 376.52 "Игорь Лабутин" Самое главное это, конечно, нетворкинг.
376.52 378.52 "Игорь Лабутин" Постараемся сделать, чтобы это было интересно.
378.52 382.08 "Анатолий Кулаков" Сообщество .NET.RU, как всегда, готовит свой собственный трек.
382.08 387.36 "Анатолий Кулаков" Там будет много очень неофициальных, неформальных общений, дискуссий, докладчиков и докладов.
387.36 390.04 "Анатолий Кулаков" Поэтому тоже помните про скрытую возможность.
390.04 391.76 "Анатолий Кулаков" Там будет интересно.
391.76 398.68 "Анатолий Кулаков" Мы попытаемся найти, опять же, вписаться в новый формат и найти какую-то интересную струю.
398.68 399.68 "Анатолий Кулаков" Итак, пойдем дальше.
399.68 401.28 "Анатолий Кулаков" Наконец-то серьезная тема.
401.28 402.28 "Анатолий Кулаков" Source-генераторы.
402.28 407.44 "Анатолий Кулаков" Уж чего-чего мы больше всего ждали с самых первых релизов .NET Framework.
407.44 409.48 "Анатолий Кулаков" Под мы, я не обидую себя.
409.48 411.20 "Анатолий Кулаков" Так это нормальных генераторов кода.
411.20 414.64 "Анатолий Кулаков" И вот какое-то просветление вдали у нас появляется.
414.64 417.24 "Анатолий Кулаков" Микрософт анонсировала превью Source-генераторов.
417.24 418.80 "Анатолий Кулаков" Давайте по порядку.
418.80 420.56 "Анатолий Кулаков" Что такое Source-генераторы?
420.56 432.72 "Анатолий Кулаков" Это специальный инструмент, который позволяет вам динамически добавлять какие-то участки кода, какие-то классы, методы, атрибуты, интерфейсы, что-то еще в ваш процесс в момент компиляции.
432.72 436.80 "Анатолий Кулаков" Мы уже имели какие-то прототипы, когда только родственный стартовал.
436.80 438.44 "Анатолий Кулаков" У Микрософта был интересный вброс.
438.44 444.12 "Анатолий Кулаков" Но тогда Source-генераторы были задизайнены с какими-то новыми ключевыми словами.
444.12 447.88 "Анатолий Кулаков" Если кто-то помнит, типа "replace" и "original", еще что-то.
447.88 451.36 "Анатолий Кулаков" В общем, для этого необходимо было менять сам язык.
451.36 454.80 "Анатолий Кулаков" То есть, вводились какие-то новые термины, новые кейворды.
454.80 458.88 "Анатолий Кулаков" А новая версия Source-генераторов полностью лишена этого недостатка.
458.88 461.84 "Анатолий Кулаков" То есть, язык остается тот же, ничего менять не нужно.
461.84 467.00 "Анатолий Кулаков" Они просто легко и ненавязчиво встраиваются в pipeline самого рослина.
467.00 471.52 "Анатолий Кулаков" Давайте я вкратце расскажу вообще, как это происходит, чтобы понимать, что вообще происходит.
471.52 473.80 "Анатолий Кулаков" То есть, это полностью фича компилятора.
473.80 475.60 "Анатолий Кулаков" Никак не связанная с языком.
475.60 483.60 "Анатолий Кулаков" Когда вы запускаете компилятор, он первым делом начинает, запускает степ, который называется Source-generation.
483.60 492.88 "Анатолий Кулаков" Этот степ находит все Source-генераторы, которые зарегистрированы в вашем проекте, подает им на вход семантическую и синтаксическую модель.
492.88 496.32 "Анатолий Кулаков" Ту же самую, которую используют родственные анализаторы сейчас.
496.32 502.60 "Анатолий Кулаков" Эти генераторы генерируют C# файлы, которые подают на выход свои работы.
502.60 505.56 "Анатолий Кулаков" Также эти генераторы могут сообщить о неких диагностиках.
505.56 509.04 "Анатолий Кулаков" Они могут доступаться к существующим моделям.
509.04 516.16 "Анатолий Кулаков" Они могут доступаться к существующим файлам проекта и на основании этого производить какие-то новые классы, производить какие-то новые методы.
516.16 518.76 "Анатолий Кулаков" Все генераторы запускаются параллельно.
518.76 521.40 "Анатолий Кулаков" На вход им подается одно и то же синтаксическое дерево.
521.40 524.96 "Анатолий Кулаков" Невозможно на выходе принять какой-то output от другого генератора.
524.96 534.72 "Анатолий Кулаков" Это специально сделано для того, чтобы не впасть в какую-то рекурсию, чтобы как генератор не генерил специальные атрибуты, которые нужно загенерить другим генератором или даже самим собой.
534.72 543.68 "Анатолий Кулаков" На вход генераторам могут поступать не только C# файлы, но и какие-то дополнительные файлы моделек, например, XML, JSON.
543.68 549.08 "Анатолий Кулаков" И после того, как генераторы закончили свою работу, весь output они отдают обратно компилятору.
549.08 553.32 "Анатолий Кулаков" Output сейчас может выйти только в виде C# файлов, ничего кроме.
553.32 559.92 "Анатолий Кулаков" И компилятор добавляет файлы, полученные от генераторов, в основной ваш проект и продолжает компиляцию.
559.92 565.16 "Анатолий Кулаков" Это все абсолютно прозрачно для пользователя, то есть никаких дополнительных файлов, естественно, на диске у вас не появится.
565.16 568.76 "Анатолий Кулаков" Это все происходит в памяти и пока там и остается.
568.76 574.56 "Анатолий Кулаков" Важно заметить, что текущий вариант Source Generator в принципе не поддерживает изменения кода.
574.56 576.48 "Анатолий Кулаков" Можно только добавлять.
576.48 580.40 "Анатолий Кулаков" Это сделано специально для того, чтобы выполнение вашей программы было интуитивным.
580.40 586.48 "Анатолий Кулаков" То есть нельзя сделать так, что вы подключаете какой-то генератор и вдруг поведение программы меняется на полностью противоположное.
586.48 590.08 "Анатолий Кулаков" И это невозможно ни отдебажить, ни понять, почему так происходит.
590.08 591.40 "Анатолий Кулаков" Ничего в этом духе.
591.40 595.20 "Анатолий Кулаков" То есть если вы получаете какое-то поведение, оно будет только дополнительным.
595.20 598.60 "Анатолий Кулаков" Итак, какие же области покрывают генераторы?
598.60 599.60 "Анатолий Кулаков" Зачем они вообще нужны?
599.60 601.60 "Анатолий Кулаков" Что с помощью них можно сделать?
601.60 606.72 "Анатолий Кулаков" Вообще мы пользуемся более или менее генераторами, так называемыми, ежедневно.
606.72 613.28 "Анатолий Кулаков" Например, если вы представите Reflection, то это типичные области, где генераторы вам очень сильно помогут.
613.28 621.64 "Анатолий Кулаков" То есть вы на основании какой-то мета-информации порождаете какую-то другую информацию или даже сразу код.
621.64 624.00 "Анатолий Кулаков" И эти генераторы отлично могут заменить вам Reflection.
624.00 631.40 "Анатолий Кулаков" И по моему опыту, просто процентов 90 использования Reflection можно выкинуть сразу, имея нормальные генераторы.
631.40 637.16 "Анатолий Кулаков" Другой способ, как еще современные программисты модифицируют код, это с помощью модификации ILL.
637.16 639.12 "Анатолий Кулаков" Самый знаменитый интерфейс - это FODI.
639.12 641.12 "Анатолий Кулаков" Надеюсь каждый из вас хотя бы раз это слышал.
641.12 643.32 "Анатолий Кулаков" FODI - очень забавный инструментик.
643.32 647.96 "Анатолий Кулаков" Он на основе плагинов позволяет вам делать маленькие, очень интересные фиксы к вашему проекту.
647.96 654.44 "Анатолий Кулаков" Например, проверять все входные параметры на NULL, при этом не написать ни строчки кода, имплементировать INotifyPropertyChange.
654.44 657.76 "Анатолий Кулаков" Это интерфейс и много-много других интересных хаков.
657.76 661.76 "Анатолий Кулаков" Вот FODI тоже является типичным генератором, но он пишет уже ILL.
661.76 664.84 "Анатолий Кулаков" И последний класс - это так называемые MSBuildTasks.
664.84 682.24 "Анатолий Кулаков" То есть MSBuild - это обычный исполняемый, грубо говоря, скрипт, который рассказывает то, в каком порядке какие инструменты нужно запустить и ничего не мешает вам туда подставить любой припроцессор, который сделает с вашим кодом и не только с кодом все что угодно.
682.24 690.68 "Анатолий Кулаков" Вот, в принципе, такие инструменты у нас были на сегодняшний день и в каждой из этой области новые SourceGenerator могут себя как-то проявить.
690.68 698.88 "Анатолий Кулаков" Они не призваны для того, чтобы заменить это все, они призваны к тому, чтобы немножко это упростить и оттянуть какую-то часть на себя.
698.88 728.00 "Анатолий Кулаков" Вообще, если мы представим, то, например, типичная генерация ReflectionEmit, когда мы пишем ILL на лету, она используется много где - в стандартном системтексте JSON, в регулярных выражениях, которые мы обсуждали в прошлом выпуске, они тоже имеют свой собственный ILL-генератор, который позволяет выполнять регулярные выражения намного быстрее, и даже в ISP NetCore для того, чтобы строить роутинги и находить правильные оптимальные пути на ваши контроллеры.
728.00 732.12 "Анатолий Кулаков" В WPF используется ReflectionEmit.
732.12 744.84 "Анатолий Кулаков" И все это делает затруднительным другую очень интересную технологию, которая называется Ahead of Time Compilation, потому что все вот такие ReflectionEmit, они ее практически убивают, и она с ними очень плохо дружит.
744.84 749.28 "Анатолий Кулаков" И SourceGenerator как раз позволяет вот эту область тоже улучшить.
749.28 760.76 "Анатолий Кулаков" То есть они переносят всю эту генерацию ILL на момент компиляции, и уже после этого компилятор сможет применить полноценные оптимизации, уже JIT сможет применить полноценные оптимизации и так далее.
760.76 764.88 "Анатолий Кулаков" Еще примеры, что можно будет сделать с помощью новых SourceGenerators.
764.88 787.76 "Анатолий Кулаков" Например, если вы задумаетесь, то на каждом старте вашего ISP Net приложения Framework сканирует все ваши контроллеры, парсит все ваши роуты, строит какую-то таблицу маршрутизации, находит зависимости в переменных, пытается их как-то отвалидировать в InputModel, пытается как-то проанализировать OutputModel, чтобы составить по ней свагер и выдать это в виде контракта наружу.
787.76 791.96 "Анатолий Кулаков" То есть происходит очень много действий, и все эти действия, естественно, делаются на Reflection.
791.96 801.08 "Анатолий Кулаков" Вот все это можно сделать на SourceGenerators, потому что все контроллеры, которые у вас есть в программе, они вам известны на момент компиляции.
801.08 804.68 "Анатолий Кулаков" Все роутинги у них прописаны, все типы и входные параметры у них есть.
804.68 820.28 "Анатолий Кулаков" Достаточно это всего лишь наоборот проанализировать один раз на момент компиляции, сгенерировать правильный код, который связывает это все вместе, и у вас время поднятия вашего ISP Net Framework в разы сокращается, потому что ему больше не нужно делать вот это сканирование.
820.28 826.88 "Анатолий Кулаков" Безусловно, есть извращенные случаи, когда вы динамически подключаете какие-то контроллеры, но мы их сейчас не рассматриваем, в принципе.
826.88 829.96 "Анатолий Кулаков" В большинстве случаев нам вот этой функциональности должно хватить.
829.96 839.16 "Игорь Лабутин" Подожди, то есть получается, что если мы можем так собрать контроллеры, то мы ведь также можем собрать и полное дерево для DI?
839.16 840.16 "Анатолий Кулаков" Именно так.
840.16 854.60 "Анатолий Кулаков" DI - это тоже процесс, который есть практически в любом современном приложении, и который каждый раз на старте вашей системы начинает строить контейнеры, начинает резолвить зависимости, начинает подставлять туда какие-то непонятные конфигурации, и все это происходит в фронтайме с помощью рефлекшена.
854.60 859.76 "Анатолий Кулаков" И это одна из первых вещей, которая поддается полной замене с помощью Source Generator.
859.76 863.08 "Игорь Лабутин" Полной-то не получится, я могу что-то написать в конфиге?
863.08 901.12 "Анатолий Кулаков" Да, безусловно, полная замена, это я немножко преувеличил, просто я объясню, мы пользуемся вот этой техникой Source Generator для составления контейнеров, для других интересных вещей, мы пользуемся уже давно, и на практике получается так, что если вы себя ограничиваете и бьете по рукам, когда пытаетесь протянуть в DI контейнер какое-то извращение, и придерживаетесь простых правил, которые элементарно покрывают абсолютно все ваши требования, если вы немножко задумаетесь, то тогда, возможно, без всяких проблем, без всяких сюрпризов полностью заменять DI контейнер, то есть полностью делать Composition Root во время компиляции, без единой строчки рефлекшена.
901.12 902.12 "Игорь Лабутин" Ага, прикольно.
902.12 910.40 "Игорь Лабутин" А еще, наверное, тогда можно будет не размечать, ну, ты уже упомянул сериализацию, к большому счету.
910.40 938.44 "Анатолий Кулаков" Да, сериализация тоже всегда везде участвует, ей всегда нужен рефлекшен, и, опять же, очень глупо сделать сериализатор, который будет рефлекшеном обходить все поля, потом как-то через рефлекшен это все считывать, записывать и так далее, если это можно просто-напросто сгенерить оберточку, как это, например, делает старый XML-сериалайзер, он в памяти делает, сгенерит сборочку, где строго типизированные типы считаются с приятно типизированной XML.
938.44 946.84 "Анатолий Кулаков" Вот это можно делать точно так же, только для любого формата под ваши собственные классы, и наверняка это тоже один из генераторов, который появится просто в первые дни.
946.84 961.36 "Игорь Лабутин" Ну, я так понимаю, что любой уважающий себе сериализатор делает все-таки какой-то там рефлекшен и мид, чтобы код был адаптирован к тому, что ты реально сериализуешь, и, честно, рефлекшеном мало кто обходит, кроме каких-то, возможно, эджкейсов, где по-другому никак.
961.36 984.12 "Игорь Лабутин" Ну, вообще, звучит прикольно, что можно погенерить кучу кода, но если ты говоришь, что нельзя менять текущий код, то как вот эти вот, ну, то есть, хорошо, мне SourceGenerator сможет сгенерить, например, какой-то новый класс, а как я тогда в момент написания кода, пока мне еще этот класс не сгенерили, узнаю, что он там есть, что он будет, как мне вообще обращаться к тому классу, который еще не сгенерили?
984.12 985.60 "Игорь Лабутин" Мне же интеллисенс нужен.
985.60 988.92 "Анатолий Кулаков" Смотри, для этого есть очень много интересных методик.
988.92 994.04 "Анатолий Кулаков" Например, каким образом я могу добавлять функциональность, при этом не изменяя код?
994.04 998.44 "Анатолий Кулаков" Ну, например, мне нужно реализовать типичный InotifyPropertyChanger, да?
998.44 1002.52 "Анатолий Кулаков" Очень муторно и нудно писать его руками, и все мечтают, чтобы он генерился.
1002.52 1003.92 "Анатолий Кулаков" Наконец-то он будет генериться.
1003.92 1006.40 "Анатолий Кулаков" Все очень просто.
1006.40 1025.64 "Анатолий Кулаков" Ты декларируешь паршу о класс, говоришь ему, что он должен имплементить интерфейс InotifyPropertyChanger, а генератор в этот момент выплевывает тебе другой файлик, тоже с паршу о классом, который называется точно так же, как твой, но уже с реализацией всех пропертей и всех событий, которые эти пропертии бросают непосредственно для тебя.
1025.64 1030.16 "Анатолий Кулаков" Это все будет происходить в бэкграунде, то есть для этого необязательно запускать компиляцию.
1030.16 1044.72 "Анатолий Кулаков" Соответственно, как только ты навесишь атрибут "я хочу генерировать InotifyPropertyChanger для этого класса", в этот момент студия подхватывает сорс-генераторы, запускает их, получает какой-то выходной паршу о класс и подставляет его в твой проект.
1044.72 1054.08 "Анатолий Кулаков" Поэтому у тебя автоматически появляется интеллисенс, поэтому твой проект может компилиться и поэтому твой проект может просто-напросто дебажиться внутрь с генерированного кода.
1054.08 1059.92 "Анатолий Кулаков" Ты его даже можешь увидеть и посмотреть, в отличие от FOD, где ты только можешь предположить, какой или оно там генерило.
1059.92 1075.08 "Игорь Лабутин" То есть это получается по сути то же самое, что в WPF-ный там Design Time Build, когда у тебя ты добавляешь на WPF-ную формочку какой-нибудь контрол и у тебя тут же образуется переменная поля класса для этого контрола.
1075.08 1077.24 "Анатолий Кулаков" Да, да, именно так.
1077.24 1083.24 "Анатолий Кулаков" Здесь ты просто добавляешь атрибуты и у тебя мгновенно образуются дополнительные какие-то классы, какие-то методы и так далее.
1083.24 1085.48 "Игорь Лабутин" Прикольно, звучит вообще супер.
1085.48 1093.12 "Анатолий Кулаков" Еще из интересных примеров, это мы можем немножко приблизиться к F# TypeProvider, очень знаменитая тема, многие платформы о ней мечтают.
1093.12 1099.04 "Анатолий Кулаков" Безусловно, полностью мы заменить ее не сможем, но много интересных фишек мы оттуда украдем обязательно.
1099.04 1114.44 "Анатолий Кулаков" И, например, в раперы для интеропа с другими языками, там C++, тоже часто приходится писать какие-то очень банальные, но очень нужные в раперы, которые помогают передавать типы из одного языка в другой.
1114.44 1121.20 "Анатолий Кулаков" Обычно их генерят с помощью каких-то сторонних тулзов, а это можно генерить в момент компиляции, то есть у вас не разъедется ничего, никто ничего не забудет.
1121.20 1142.56 "Анатолий Кулаков" Вместе с этой темой уже вышли в качестве примеров такие генераторы, как, например, генерация строго типизированных сеттингов из XML файла, то есть все вы себе наверняка представляете XML-конфиг, там записаны у вас какие-то флаги, у них есть какие-то значения, и считывать вам их приходится обычными строчками.
1142.56 1144.28 "Анатолий Кулаков" Строчками считывать это, естественно, плохо.
1144.28 1147.48 "Анатолий Кулаков" Вы всегда можете опечататься, переименовать, еще что-то.
1147.48 1160.72 "Анатолий Кулаков" Гораздо приятнее было бы, если бы взять этот XML-файл и сгенерить строго типизированный класс с полями, с типами, с проверками, с автоматической конвертацией и просто-напросто привлечь, получать на вход этот уже класс.
1160.72 1171.76 "Анатолий Кулаков" Раньше мы это делали руками, теперь генератор сможет для вас прочитать этот XML-файл, сделать для вас строго типизированный класс с настройками и засунуть его в какой-нибудь IOptions от Microsoft.
1171.76 1173.80 "Анатолий Кулаков" Звучит довольно-таки интересно.
1173.80 1187.16 "Анатолий Кулаков" Дальший пример, который у нас есть, это естественная NotifyPropertyChanged, имплементация этого интерфейса, потому что это был один из самых востребованных заявок у Microsoft в бэклоге, поэтому пример сразу показывает, как это можно сделать.
1187.16 1192.16 "Анатолий Кулаков" Есть примеры, где уже энтузиасты, например, генерят BuilderPattern.
1192.16 1200.04 "Анатолий Кулаков" Это способ, когда ваш конструктор имеет много-много каких-то входных аргументов и передавать их чисто в конструктор очень нечитабельно и очень неудобно.
1200.04 1208.44 "Анатолий Кулаков" И тогда начинают лепить Build-шаблон, который через точку говорит, сделай мне этот класс с таким-то именем, с таким-то возрастом и так далее.
1208.44 1211.84 "Анатолий Кулаков" Теперь эти классы можно не писать вручную, их можно элементарно сгенерить.
1211.84 1217.76 "Анатолий Кулаков" Очень интересная тема - это генерация интерфейса по классу.
1217.76 1227.24 "Анатолий Кулаков" Есть у нас, конечно, такой BadPractice, когда у класса есть всего-навсего один интерфейс и обычно оправдывается тем, что этот интерфейс нужен для моков в тестах.
1227.24 1240.36 "Анатолий Кулаков" Мы сейчас не будем рассуждать, хорошо это или плохо, но, например, если вам это нужно, вы можете на своем классике навеслить атрибуты, сказать, что все публичные свойства и методы этого класса пусть автоматически сгенерятся в интерфейсик.
1240.36 1247.24 "Анатолий Кулаков" И вам уже не нужно в двух местах бегать, поправлять сигнатуры или в двух местах не забывать проставлять атрибуты или еще что-то в этом духе.
1247.24 1253.28 "Анатолий Кулаков" Как только вы поменяете свой класс, генератор автоматически актуализирует вот этот интерфейс, который вы используете в тестах для моков.
1253.28 1256.64 "Игорь Лабутин" Слушай, вообще прям звучит очень вкусно.
1256.64 1261.88 "Игорь Лабутин" А распространяться все это будет как аналайзеры розлиновские, то есть GetPackage?
1261.88 1271.96 "Анатолий Кулаков" Да, действительно, команда хочет сделать это максимально близким, похоже, на аналайзеры, и одним из артефактов такого подхода в том, что это будет обычный NuGet пакет.
1271.96 1281.00 "Анатолий Кулаков" То есть вы можете установить любой артефакт из NuGet репозитория, он подключится в ваш проект, он будет версионироваться, обновляться, запускаться и так далее.
1281.00 1282.00 "Анатолий Кулаков" То есть это очень удобно.
1282.00 1297.72 "Игорь Лабутин" И получается, что в какой-нибудь библиотеке, сейчас же стало популярным, какой-нибудь NUnit или XUnit генерирует помимо основного пакета пакет с аналайзерами для этого проекта, будет также, видимо, пакет с полезными Source-генераторами, например.
1297.72 1301.64 "Анатолий Кулаков" Да, да, наверняка что-то типа того и должно происходить.
1301.64 1307.28 "Анатолий Кулаков" То есть каждая библиотека может с собой таскать какие-то полезные для нее не только анализаторы, но и генераторы.
1307.28 1308.28 "Игорь Лабутин" Хорошо.
1308.28 1310.80 "Игорь Лабутин" Слушай, звучит все это очень вкусно, наверняка есть какие-то недостатки.
1310.80 1321.04 "Игорь Лабутин" Я понимаю, что все это очень ранняя стадия, и все 20 раз может поменяться, но обычно, насколько я знаю, текущие микрософтские дизайны, они обычно очень трепетно относятся к описанию и плюсов, и минусов.
1321.04 1324.08 "Игорь Лабутин" Есть ли у нас какие-то минусы, уже заранее известные?
1324.08 1326.16 "Анатолий Кулаков" Да, безусловно, минусы есть.
1326.16 1331.80 "Анатолий Кулаков" Прежде всего, это отсутствие какого-то подхода к шаблонизации, к плейтингу.
1331.80 1341.40 "Анатолий Кулаков" То есть, если вы хоть раз писали анализаторы или видели, как это происходит, анализ самого синтаксического дерева, он не очень тривиальный.
1341.40 1350.56 "Анатолий Кулаков" Для того, чтобы на выходе сгенерить вам пару строчек C#, вам может вполне понадобиться написать около 100 строчек кода в терминах синтаксического дерева.
1350.56 1358.76 "Анатолий Кулаков" То есть, мы остаемся по-прежнему синтаксическими деревнями, пока никаких улучшений или квазицитирования к нам не пришло.
1358.76 1362.84 "Анатолий Кулаков" Здесь же минус в том, что у нас нет шаблонов никаких.
1362.84 1368.44 "Анатолий Кулаков" На выходе мы должны сгенерить C# файл, настоящий текстовый, то есть, это тип стринг.
1368.44 1371.96 "Анатолий Кулаков" Но никаких шаблонизаторов готовых, которые в этом нам помогут, нет.
1371.96 1380.68 "Анатолий Кулаков" То есть, мы должны или конконтинентить строчку, или вызывать стринг-билдер, или идент-провайдер, ну или подключать какой-нибудь внешний сторонний шаблонизатор.
1380.68 1383.80 "Анатолий Кулаков" Это тоже, в принципе, можно отнести к минусам.
1383.80 1387.52 "Анатолий Кулаков" Дальше, как я уже упоминал, на выходе могут быть только C# файлы.
1387.52 1400.48 "Анатолий Кулаков" Довольно-таки странно, потому что если мы возьмем текущие генераторы, то очень частым юзкейсом является, например, сгенерить TypeScript файл, который отражает ту же самую модель, которая у вас объявлена в C# файле, например.
1400.48 1414.92 "Анатолий Кулаков" Ну или сгенерить Swagger файл, то есть, то описание, которое Swagger тоже достает через Reflection на момент старта вашего приложения, тоже его вполне можно сгенерить генераторами, если бы была возможность возвращать не только C# output, а любой произвольный.
1414.92 1424.12 "Анатолий Кулаков" Безусловно, никто из генераторов не запрещает обратиться непосредственно к диску и на диске поменять все файлы, на диске сходить в базу данных и оттуда там считать какую-то схему.
1424.12 1426.92 "Анатолий Кулаков" Ну, все-таки хотелось более какого-то цивилизованного подхода.
1426.92 1428.64 "Анатолий Кулаков" Также нет модификации.
1428.64 1440.44 "Анатолий Кулаков" И это одно из самых громких воев на GitHub стоит, особенно от любителей AOPA, тех, кто любит размахивать катиной Edge консерном и решать с помощью него все свои проблемы.
1440.44 1456.40 "Анатолий Кулаков" Вот они сейчас очень сильно негодуют и пытаются как-то Microsoft зарулить в эту сторону, но команда стоит на своем и говорит, что это будет очень неинтуитивно, очень страшно и мы сильно-сильно не хотим в эту сторону лезть, поэтому вряд ли.
1456.40 1461.60 "Анатолий Кулаков" Дальше нет поддержки большого .NET фреймворка и пока не планируется.
1461.60 1469.64 "Анатолий Кулаков" То есть, команда сосредоточилась полностью именно на Core, на .NET 5 и большой фреймворк не планируется.
1469.64 1472.28 "Анатолий Кулаков" Ну и это очень-очень раннее превью.
1472.28 1483.20 "Анатолий Кулаков" Сейчас, например, даже не работает подтягивание студии автоматически IntelliSense, то есть после генерации вам придется перезакрыть студию для того, чтобы она подхватила те файлы, которые были сгенерированы.
1483.20 1496.20 "Анатолий Кулаков" Безусловно, это уйдет из новых альф, но все же очень раннее превью, поэтому мало статей, мало документации, мало тулзов, но зато очень большие интересные перспективы у этого инструмента.
1496.20 1502.80 "Анатолий Кулаков" И здесь же нельзя умолчать о способе, который позволяет вам все эти минусы устранить.
1502.80 1504.64 "Анатолий Кулаков" Ну, практически все.
1504.64 1515.68 "Анатолий Кулаков" Люди, которые хотят генерации, люди, которые давно мечтают о генерации, такие как я, они давно уже смотрят и используют такой подход, как T4.
1515.68 1520.28 "Анатолий Кулаков" T4 - это инструмент, который появился, скорее всего, с самых первых версий .NET.
1520.28 1524.96 "Анатолий Кулаков" Он поддерживается во всех студиях, в которых только возможно и во всех языках, в которых только есть.
1524.96 1528.96 "Анатолий Кулаков" Он безумно древний и в этом плане это плюс.
1528.96 1530.64 "Анатолий Кулаков" Какие можно выделить у него характеристики?
1530.64 1533.72 "Анатолий Кулаков" У него есть отличный темплейт движок.
1533.72 1542.04 "Анатолий Кулаков" Наверное, если сравнивать его с современными какими-то веб-движками или если нескушенный пользователь первый раз на него посмотрит, он впадет в ужас.
1542.04 1547.28 "Анатолий Кулаков" Но если разобраться буквально 15 минут, то движок вполне предсказуем.
1547.28 1552.52 "Анатолий Кулаков" T4 поддерживается прекрасно ReSharper, то есть это специальный синтаксис этого темплейт движка.
1552.52 1556.80 "Анатолий Кулаков" Можно на нем творить очень интересные и прекрасные вещи.
1556.80 1560.76 "Анатолий Кулаков" Также у него уже довольно зрелая инфраструктура.
1560.76 1567.36 "Анатолий Кулаков" Мы имеем огромное количество документаций, курсов, каких-то примеров, вспомогательный библиотек и так далее.
1567.36 1573.60 "Анатолий Кулаков" То есть у вас никогда не станет какой-то проблемы загуглить ответ на любой тупик, с которым вы столкнулись.
1573.60 1586.92 "Анатолий Кулаков" Еще интересная фишка, которая пока не прослеживается у будущих генераторов, это в том, что T4 можно настроить, чтобы он запускал свою генерацию по требованию и в момент компиляции.
1586.92 1588.80 "Анатолий Кулаков" Я объясню, что такое по требованию.
1588.80 1596.84 "Анатолий Кулаков" Часто очень T4 используют, например, чтобы сходить в базу данных, считать оттуда какие-то таблички и по этим табличкам сделать модель в виде вашего C# кода.
1596.84 1600.76 "Анатолий Кулаков" На каждую компиляцию ходить в базу данных абсолютно не нужно.
1600.76 1607.32 "Анатолий Кулаков" Это излишне, это долго, это тратятся ресурсы и это никому не нужно, потому что модель в базе данных меняется довольно-таки редко.
1607.32 1614.76 "Анатолий Кулаков" Поэтому вы можете зайти внутрь T4 файла, нажать кнопочку перегенерить, он в этот момент перегенерится и все.
1614.76 1617.04 "Анатолий Кулаков" Или вы можете нажать в студии кнопочку перегенерить все T4 файлы.
1617.04 1623.84 "Анатолий Кулаков" А также на билд сервере, чтобы без всяких сюрпризов T4 файлы можно перегенерять всегда, если он бился в какой-нибудь CI окружении.
1623.84 1628.00 "Анатолий Кулаков" То есть это тоже очень удобно и надеюсь, что эту функциональность добавят в генераторы.
1628.00 1637.12 "Анатолий Кулаков" В общем, если вы вдруг не использовали T4 и очень хотите генераторов уже сейчас, а никогда не будут зарелижены Microsoft, то советую посмотреть.
1637.12 1643.64 "Анатолий Кулаков" Для примера, как я уже сказал, мы используем T4 для того, чтобы собирать Composition Rook в контейнерах.
1643.64 1649.80 "Анатолий Кулаков" Например, я уже давно использую рекорды, которые все шарпи много-много откладывали.
1649.80 1657.20 "Анатолий Кулаков" То есть с помощью одной строчки я могу генерить классы, которые там состоят из 100 строк со всякими equals, интерфейсами и так далее.
1657.20 1661.60 "Анатолий Кулаков" И это все на существующих технологиях, на существующих языках и на существующих версиях.
1661.60 1663.54 "Анатолий Кулаков" В общем, вполне отличная штука.
1663.54 1668.12 "Анатолий Кулаков" Со своими минусами, безусловно, но на данный момент это лучшее, что есть на рынке.
1668.12 1671.00 "Игорь Лабутин" Мне кажется, это звучит так, что надо делать доклад.
1671.00 1673.00 "Анатолий Кулаков" Кстати, да, отличная тема для докладов.
1673.00 1675.96 "Анатолий Кулаков" Если будет возможность, я бы даже им занялся.
1675.96 1677.64 "Анатолий Кулаков" Но не будем заглядывать в будущее.
1677.64 1683.96 "Анатолий Кулаков" Кстати, в будущем Source генераторы позиционируются на то, что они выйдут вместе с C# 9.
1683.96 1689.84 "Анатолий Кулаков" Я напомню, они никак не привязаны к языку, но команда поставила к себе именно такой мейлстоун.
1689.84 1696.28 "Анатолий Кулаков" И весь смысл ранней превью, которую мы сейчас обсуждали, в том, что они хотят фидбэка.
1696.28 1701.28 "Анатолий Кулаков" Они хотят ваших юзкейсов, они хотят ваших каких-то проблем, которые можно решить.
1701.28 1705.80 "Анатолий Кулаков" Они хотят, чтобы вы уже сейчас пробовали и давали свой фидбэк.
1705.80 1711.16 "Анатолий Кулаков" Поэтому милости просим на GitHub, давайте вместе поучаствуем в становлении такого замечательного проекта.
1711.16 1718.24 "Игорь Лабутин" Да, это всегда прикольно, помогать и на ранней стадии влиять, возможно, даже на какие-то решения.
1718.24 1724.40 "Игорь Лабутин" Если вы попробовали и вам что-то не понравилось, вы можете ставить свой фидбэк и команда постарается его учесть.
1724.40 1734.32 "Игорь Лабутин" Но давайте к будущему перейдем к не менее замечательному прошлому и немножко вспомним про Garbage Collector.
1734.32 1745.68 "Игорь Лабутин" Поводом для этого стала серия статей от Маони Стеффенсен в дотнет-блоге Microsoft, где она написала ряд статей про Garbage Collector.
1745.68 1753.48 "Игорь Лабутин" Причем они не сильно связаны друг с другом в том плане, что все статьи рассматривают Garbage Collector, какие-то отдельные его аспекты.
1753.48 1761.12 "Анатолий Кулаков" Подожди, прежде всего давай расскажем вообще, кто такой Маони, потому что это же не просто какой-то рядовой автор, на самом деле это человечище, это ОВО.
1761.12 1772.32 "Игорь Лабутин" Маони Стеффенсен, это действительно можно сказать до недавнего времени, по крайней мере, это единственный автор-мейнтейнер, так скажем, современного Garbage Collector в дотнете.
1772.32 1779.28 "Игорь Лабутин" То есть не она его, конечно, написала в самой первой версии, но она является главным его сейчас архитектором.
1779.28 1791.64 "Игорь Лабутин" А насколько я знаю из рассказов, что сейчас уже несколько человек работают над улучшениями Garbage Collector, но она все еще является его главным архитектором и никто лучше нее не знает, как устроен дотнет Garbage Collection.
1791.64 1805.60 "Игорь Лабутин" И поэтому всегда интересно посмотреть на какие-то уголки или особенности реализации Garbage Collector или вообще любой технологии, когда об этом пишет автор этой технологии или человек, который очень хорошо в ней разбирается.
1805.60 1810.52 "Анатолий Кулаков" Мне кажется, ее можно даже назвать единственным человеком, который вообще понимает, как это работает.
1810.52 1812.72 "Анатолий Кулаков" Ну, естественно, после Конрада Кокоса.
1812.72 1828.52 "Игорь Лабутин" Насколько я понял из общения с командой, собственно, dotnet runtime, куда она в том числе входит, непосредственно с ней я, к сожалению, не общался, а уже, может быть, даже и она совсем целиком абсолютно все-все-все может и не понимает.
1828.52 1839.00 "Игорь Лабутин" Но, естественно, общие архитектурные идеи и все варианты тонких настроек она знает, потому что они с ней обычно обсуждают.
1839.00 1849.40 "Игорь Лабутин" Итак, в серии статей я бы хотел выделить несколько, мы приведем ссылки на все, но несколько штук я хотел бы обсудить отдельно.
1849.40 1861.64 "Игорь Лабутин" Первый класс статей, я бы сказал, это статьи про историю, то есть про то вообще, как все развивалось и как все работало раньше и почему члены решений были приняты.
1861.64 1869.20 "Игорь Лабутин" И здесь отдельная, самая, наверное, пожалуй, интересная статья, это история конфигов garbage collector.
1869.20 1889.48 "Игорь Лабутин" Все мы знаем две опции, которые были в дотнете со времен, ну, не знаю, я начал дотнетом пользоваться в версии 3 с чем-то, 3.0, наверное, и они там уже были, но я так понимаю, что они там были с какими-то, с 2.0-то уж точно, это серверный, либо, соответственно, workstation и concurrent-не-concurrent или background-не-background, как он раньше, как он тоже иногда назывался.
1889.48 1897.08 "Игорь Лабутин" То есть и эти две опции были единственными паблик-опциями для настройки garbage collector, ничего другого вообще никогда в garbage collector настроить было нельзя.
1897.08 1920.64 "Игорь Лабутин" И долгое время команда считала, что этого достаточно, потому что вполне справедливо полагая, что если хоть какую-то опцию выдать наружу, а опций-то на самом деле очень много, просто они все внутренние, то эта опция становится паблик и ее надо после этого поддерживать и обеспечивать совместимость, потому что какие-то кастомеры могут на нее завязаться и все, ее больше нельзя убирать, ее поведение нельзя менять и так далее.
1920.64 1921.64 "Игорь Лабутин" Очень справедливо.
1921.64 1926.80 "Игорь Лабутин" Команда этого не хотела, поэтому всячески старалась с ним показывать эти опции.
1926.80 1941.20 "Игорь Лабутин" Было несколько исключений и буквально добавили чуть-чуть 3 или 4 новых опции в районе дудна это 4-го, и на этом все успокоилось.
1941.20 1956.92 "Игорь Лабутин" Но потом произошло такое интересное событие, как открытие исходного кода всего Core CLR, и вот тут-то собственно вся общественность узнала, сколько на самом деле опций бывает и как их вообще, говорят, задавать, и вообще, говорят, что теперь им можно пользоваться.
1956.92 1959.20 "Игорь Лабутин" В принципе, смартфон в коде взял и попользовался.
1959.20 1960.52 "Игорь Лабутин" Прекрасно стало.
1960.52 1963.28 "Игорь Лабутин" Тем, кому хочется потюнить GC.
1963.28 1968.44 "Игорь Лабутин" Но команда все равно считает, что сильно много добавлять нельзя.
1968.44 1972.12 "Игорь Лабутин" Во-первых, они немножко изменили подход к опциям.
1972.12 1974.96 "Игорь Лабутин" Раньше опцию можно было задавать тремя способами.
1974.96 1992.64 "Игорь Лабутин" Можно было задать ее в конфиг-файле, как мы все привыкли, там называется server true, можно было задавать через переменное окружение, вы их наверняка видели не раз с префиксом com+ или можно было их задать при старте .NET хостинга, если вы хостите его сами.
1992.64 1996.16 "Игорь Лабутин" Но этим, наверное, пользовалось подавляющее меньшинство народа.
1996.16 2005.84 "Игорь Лабутин" В .NET Core механизм изменился, теперь все загружается исключительно через runtime.json в настройке, и никакие переменные окружения на это не влияют.
2005.84 2011.60 "Игорь Лабутин" Если вы хотите что-то задавать через переменные окружения, то этот подход все тоже прописывается через runtime.json.
2011.60 2031.40 "Игорь Лабутин" Это позволяет, так скажем, сузить и упростить работу внутри Core CLR кода и явно отделить паблик, поддерживаемые настройки, которые как раз через runtime.json, от внутренних настройок, которые все еще могут подтягиваться через переменные окружения, но их поведение никто не гарантирует от релиза к релизу.
2031.40 2041.36 "Игорь Лабутин" И в целом команда, так скажем, обрисовала свой подход к переводу настроек в Public Scope.
2041.36 2054.48 "Игорь Лабутин" Их подход сейчас заключается в следующем, что настройка имеет право быть в паблике, если для ее использования не требуется глубокого понимания того, как работает garbage collector.
2054.48 2090.04 "Игорь Лабутин" И Maoni, в частности, приводит несколько примеров, что, допустим, настройка про ограничение количества ядер, которые может использовать garbage collector, она, с одной стороны, вроде как довольно-таки внутренняя, это тонкость серверного garbage collector, что там количество потоков обычно совпадает с количеством ядер, но, с другой стороны, если вы пишете высокопроизводительный код и у вас сильно многоядерная машина, там 32 ядра, 64 ядра или больше, то, в принципе, вам не обязательно знать garbage collector, вам просто хочется сказать, что вот это приложение не должно сильно использовать все ядра, и вы таким образом ограничиваете.
2090.04 2097.04 "Игорь Лабутин" Или, допустим, garbage collector можно сказать, когда он будет считать, что у вас очень сильно занята память.
2097.04 2119.00 "Игорь Лабутин" Это выдается чиселка в процентах, и если ваш процесс потребляет всего-ничего, 2-3 гигабайта памяти, крутится на машинке с 64 гигабайтами, то дефолтная настройка 90% начнет срабатывать, когда в системе останется 6 гигабайт свободной памяти, что для вашего процесса вообще выше крыши, но garbage collector вашего процесса будет считать, что все плохо и у вас очень мало памяти.
2119.00 2122.76 "Игорь Лабутин" Это все тюнится теперь, и такие настройки будут в паблике.
2122.76 2138.12 "Игорь Лабутин" Все остальные пока не будут, и несмотря на то, что часть настройки команда выставила таки наружу для определенных заказчиков, они сейчас будут, возможно, стремиться к тому, чтобы все обратно убрать во внутреннее и особо не выдавать.
2138.12 2139.12 "Игорь Лабутин" Вот.
2139.12 2155.00 "Игорь Лабутин" В общем, интересное чтение про то, как все это развивалось, как принимаются решения, что сделать паблик, что не паблик, и очень интересно читать на предмет того, как вообще себя вести, если вы делаете что-то для других людей, по большому счету, с точки зрения кода.
2155.00 2158.96 "Игорь Лабутин" Второй блок статей - это про будущее.
2158.96 2169.40 "Игорь Лабутин" Мы, например, знаем такой процесс как финализация, где один поток потихонечку разгребает очередь финализации и выполняет код финализаторов и окончательно уничтожает объекты.
2169.40 2181.40 "Игорь Лабутин" Все хорошо, но есть некоторые команды, в том числе внутри Майкрософта, которые очень активно используют финализацию, и объектов этих становится очень много, и, соответственно, хотелось бы, чтобы эта работа делалась быстрее.
2181.40 2197.04 "Игорь Лабутин" У команды Core CLR есть планы сделать финализацию распроливаемой и сделать это более чем одним потоком, это пока планы, но вот есть некоторые рассуждения над тем, когда это может пригодиться, как это может быть реализовано, такие планы читать интересно.
2197.04 2267.96 "Игорь Лабутин" Вторая вещь про будущее, которую хотелось бы подчеркнуть, это область, так скажем, работы с памятью в .NET, которая производится через класс GCHandle, то есть это обычно каким-то образом вручную полученная память, которую нужно либо запинить руками, либо получить какие-нибудь слабые ссылки, либо есть еще вариант слабой ссылки с оживлением или возрождением, weak reference track refraction, и кроме того, на самом деле, помимо четырех типов GCHandles, которые видны в обычном разработчике .NET, внутри есть еще несколько, которые используются исключительно внутри .NET, так вот, в современном мире в сети GCHandles есть нагрузки, под которыми их количество довольно сильно растет, но, к сожалению, нормальных средств для диагностики, конкретно вокруг этого аспекта работы с памятью, почти практически нету, поэтому Maoni, соответственно, написала статью, как это все правильно диагностировать, а кроме того, что они сейчас предполагают сделать, чтобы сделать диагностику легче.
2267.96 2299.44 "Игорь Лабутин" И, наконец, самый для меня, наверное, интересный блок сетей, это Performance Infrastructure или Performance Diagnostics, потому что я так понимаю, что это основная ее работа, одна из основных работ - это диагностировать различные проблемы заказчика, когда приходят заказчики, в том числе внутренние, со словами "у меня тут все тормозит, гармошка-лектор работает неправильно, кушает кучу процессора, мало времени", или, как она пишет, иногда приходят просто со словами "вот, дам пейсперфью, посмотрите, все ли у нас хорошо с гармошкой-лектором".
2299.44 2309.60 "Игорь Лабутин" И тут вступает в дело туглинг, который, надо сказать, с одной стороны весьма развит, с другой стороны не вполне развит.
2309.60 2325.16 "Игорь Лабутин" Понятно, что на Windows у нас есть ETW под системой для сбора диагностической информации, на Linux есть, соответственно, свои средства, которые в итоге тоже породят ETL-файлик, и дальше с этим ETL-файликом нужно что-то сделать.
2325.16 2346.36 "Игорь Лабутин" В Microsoft есть отличная библиотека TraceEvent, которая позволяет на C# ETL-файлике парсить и получать всю информацию, которая в этих файликах заключена, но основная и самая большая проблема в том, что обработка такого ETL-файлика, особенно если он очень большой, занимает довольно долгое время, и поэтому каждый раз это делать это не очень здорово.
2346.36 2361.20 "Игорь Лабутин" В результате команда подумала и заиспользовала такой, как мне показалось, не очень стандартный инструмент для диагностики дотнет-проблем с памятью, это Jupyter Notebooks питончиковые.
2361.20 2363.48 "Игорь Лабутин" Соответственно, у них есть это все за OpenSource.
2363.48 2367.28 "Анатолий Кулаков" Неужели здесь Machine Learning провинились с этими Data Scientists, что ли?
2367.28 2378.76 "Игорь Лабутин" Тут дело не столько в Machine Learning, сколько в удобстве, что Jupyter Notebooks позволяет очень хорошо запоминать промежуточные результаты вычислений и перезапускать шаги вычислений, не перевычисляя начальный.
2378.76 2401.32 "Игорь Лабутин" То есть идея в том, что первые несколько шагов анализируют ETL-файлик и всю нужную информацию сгребают в какое-то промежуточное хранилище, ну автоматом практически, и дальше вы уже можете строить графики, диаграммы и всячески наводить статистику на ваши данные по garbage-collect, каждый раз не вычитывая огромные многогигабайтные иногда файлы.
2401.32 2405.84 "Игорь Лабутин" Особенно если вы собираете, например, статистику garbage-collect за сутки, там ETL-файлик будет огромный.
2405.84 2411.84 "Игорь Лабутин" Это все за OpenSource, это все лежит в CoreCLR-репозитории, правда довольно-таки далеко.
2411.84 2418.40 "Игорь Лабутин" Ох, простите, не в CoreCLR, это лежит в репозитории dotnet-performance, где собрана коллекция бенчмарков.
2418.40 2454.68 "Игорь Лабутин" Там же в бенчмарках есть папочка egc, где, собственно, лежит все, что нужно, есть редмишка, как этим пользоваться, вы можете у себя собрать информацию о вашем garbage-collect в вашем приложении, запустить это все в эти самые ноутбуки и посмотреть какие-то стандартные для начала предлагаемые команды графики и распределения от того, как у вас, допустим, распределяются паузы garbage-collect в зависимости от времени всего остального или насколько быстрая garbage-collect в зависимости от паузы и как это все соотносится, и на основе этого делать какие-то выводы.
2454.68 2471.04 "Игорь Лабутин" В общем, исключительно интересная информация, я не уверен, что она нужна в ежедневном использовании, но посмотреть интересно и, возможно, в сложных случаях, когда у вас действительно непонятно или действительно тормозит garbage-collection, то это может пригодиться.
2471.04 2483.00 "Игорь Лабутин" Но, с другой стороны, мне кажется, что это уже совсем тяжелая артиллерия, есть какие-то гораздо более простые способы, и про них тоже сейчас есть серия статьи Майони, она еще не закончена, мы ее посмотрим, когда она будет закончена.
2483.00 2488.32 "Игорь Лабутин" Тогда мы по ней тоже пробежимся, посмотрим, как же правильно все это смотреть для начала.
2488.32 2492.36 "Анатолий Кулаков" Майони пишет довольно-таки понятно, легко и интересно.
2492.36 2498.88 "Анатолий Кулаков" Она недавно начала писать, я не знаю, по правильнее, мне кажется, где-то с полгода я начинаю видеть ее статьи, не позже.
2498.88 2500.44 "Анатолий Кулаков" И сейчас пишет довольно-таки регулярно.
2500.44 2507.00 "Игорь Лабутин" Да, она пишет где-то, ну, мне кажется, что первая статья была в районе сентября прошлого года, чуть больше, чем полгода.
2507.00 2526.72 "Игорь Лабутин" Но да, она старается хотя бы раз в месяц или пару раз в месяц публиковать статью в блог, и я так понимаю, что у нее нет проблем особо с контентом, она может написать огромное количество статьи, основной вопрос, это, конечно, время, скорее всего, которое в ограниченном количестве, и поэтому мы видим не так часто появляющиеся статьи.
2526.72 2536.40 "Анатолий Кулаков" Да, это один из тех фундаментальных авторов, за которым нужно следить, в принципе, даже если вам эта тема неинтересна, чтобы хотя бы быть в курсе, что там происходит, и как это все решается, и как это все делается.
2536.40 2539.56 "Анатолий Кулаков" Очень увлекательный персонаж, крайне рекомендую.
2539.56 2541.08 "Игорь Лабутин" Да, пойдем дальше.
2541.08 2543.16 "Игорь Лабутин" У нас должно быть еще что-нибудь сегодня обозреть.
2543.16 2549.52 "Анатолий Кулаков" Есть-есть, у нас появился свой собственный Mobius, и это не то, о чем вы подумали, как только услышали.
2549.52 2552.92 "Анатолий Кулаков" На самом деле, это новый фреймворк от Конрада Кокоса.
2552.92 2557.28 "Анатолий Кулаков" Это .NET Runtime, который написан, собственно, на .NET.
2557.28 2561.68 "Анатолий Кулаков" Такая довольно неинтересная связка, необычная и странная.
2561.68 2566.12 "Анатолий Кулаков" Ну, в принципе, и все связки, которыми занимается Конрад Кокоса.
2566.12 2567.44 "Анатолий Кулаков" Для чего это может быть нужно?
2567.44 2583.76 "Анатолий Кулаков" Во-первых, по словам автора, это для ресерча и для всяких экспериментов, потому что если мы будем иметь свой собственный рантайм, который написан на понятном нам языке, каждый человек сможет там разобраться и сможет проэкспериментировать с какими-нибудь алгоритмами Garbage Collector или Jita, например.
2583.76 2585.40 "Анатолий Кулаков" Также для изучения.
2585.40 2588.84 "Анатолий Кулаков" Очень интересно изучать то, как работает рантайм.
2588.84 2603.72 "Анатолий Кулаков" Вы можете выбрать какие-нибудь интересные структуры данных и посмотреть, как они будут работать, попробовать какие-нибудь интересные алгоритмы или понять, каким образом работают низкоуровневые API, например, Span, StakeAllock, EndSafe классы и так далее.
2603.72 2607.44 "Анатолий Кулаков" То есть это становится хорошим такой тестовый исследовательский стенд.
2607.44 2610.36 "Анатолий Кулаков" Ну и, наверное, самое главное, для чего это может пригодиться.
2610.36 2611.76 "Анатолий Кулаков" Да это просто весело.
2611.76 2614.08 "Анатолий Кулаков" Это просто такой фановый проект.
2614.08 2615.24 "Анатолий Кулаков" Почему бы и нет?
2615.24 2618.72 "Анатолий Кулаков" Почему бы не написать все на .NET, если можно писать на .NET?
2618.72 2625.12 "Игорь Лабутин" Ну, я боюсь, что все на .NET написать не получится, потому что это, скорее всего, работа не для одного и не на один год.
2625.12 2633.48 "Игорь Лабутин" А я думаю, что вряд ли мы из этого получим какой-то production-ready код, который можно будет для чего-то использовать в серьезных проектах.
2633.48 2635.28 "Игорь Лабутин" Но для фана почему нет?
2635.28 2636.68 "Анатолий Кулаков" А он не один.
2636.68 2645.52 "Анатолий Кулаков" Он сейчас заканчивает свой прототип и будет все это выкладывать в open-source на GitHub, и поэтому к нему срочно набегут 100 тысяч поклонников и наверняка ему помогут.
2645.52 2647.28 "Игорь Лабутин" Отлично, напишем альтернативный рантайм.
2647.28 2648.72 "Игорь Лабутин" В принципе, мы уже написали.
2648.72 2649.72 "Анатолий Кулаков" Почему нет?
2649.72 2656.44 "Анатолий Кулаков" Если найдем какие-то интересные плюсы или тем более сможем как-то коммерчески это обосновать, то, я думаю, интересующиеся появятся.
2656.44 2661.12 "Анатолий Кулаков" А идея не такая бредовая при глубоком копании, как кажется на первый взгляд.
2661.12 2667.36 "Анатолий Кулаков" Я думаю, мы к ней еще вернемся, если проект будет дальше жить и развиваться, посмотрим, что еще можно на нем сделать.
2667.36 2669.76 "Анатолий Кулаков" Окей, Конрад радует.
2669.76 2677.88 "Анатолий Кулаков" Следующая интересная тема это то, что JetBrains выпустил райдер для разработчиков на Unreal Engine.
2677.88 2685.24 "Анатолий Кулаков" Если кто не в курсе, то Unreal это один из двух самых популярных движков для построения игр.
2685.24 2686.24 "Анатолий Кулаков" Второй - это Unity.
2686.24 2691.52 "Анатолий Кулаков" Поддержка Unity уже давно есть в райдере, она там отлично справляется.
2691.52 2693.92 "Анатолий Кулаков" Я слышал много хвалебных отзывов о ней.
2693.92 2698.44 "Анатолий Кулаков" А теперь JetBrains решили добавить туда еще и поддержку Unreal.
2698.44 2707.36 "Анатолий Кулаков" Они хотят сделать райдер, я даже сейчас процитирую, стейделон, олдванс, кроссплатформ, геймдевелопмент иде.
2707.36 2712.28 "Анатолий Кулаков" То есть такой объемлющий игровая студия, которая позволит вам разрабатывать игры.
2712.28 2720.12 "Анатолий Кулаков" Так как она уже практически захватила рынок Unity, очень логично вторым шагом покуситься и на Unreal.
2720.12 2725.88 "Анатолий Кулаков" И вот теперь превью райдера, который поддерживает движок Unreal представлен к вашим услугам.
2725.88 2729.04 "Анатолий Кулаков" Вы можете его протестировать, посмотреть и так далее.
2729.04 2730.16 "Анатолий Кулаков" Это early preview.
2730.16 2732.08 "Анатолий Кулаков" Сейчас поддерживается только Windows.
2732.08 2737.08 "Анатолий Кулаков" В будущем, безусловно, это будет поддержка всех трех платформ, на которых запускается райдер.
2737.08 2741.44 "Анатолий Кулаков" И, естественно, это все кроссплатформенно.
2741.44 2748.80 "Анатолий Кулаков" Райдер, в отличие от Unity, где основным языком написания является C#, в Unreal пишут в основном на плюсах.
2748.80 2754.40 "Анатолий Кулаков" И райдер уже умел поддерживать C++, благодаря ядру ReSharper C++.
2754.40 2764.08 "Анатолий Кулаков" И там уже было очень много всяких quickfixes, хаков, анализаторов и прочего для C++ языка, который мы привыкли видеть в C#.
2764.08 2769.12 "Анатолий Кулаков" И, естественно, это все переедет в поддержку кодинга самого Unreal.
2769.12 2773.52 "Анатолий Кулаков" Также добавляются дополнительные знания, о которых райдер раньше не имел понятия.
2773.52 2779.24 "Анатолий Кулаков" Например, Blueprints, High-Level Shader Language - это язык для программирования шейдеров.
2779.24 2782.80 "Анатолий Кулаков" Все это тоже теперь встроено, умеется и поддерживает.
2782.80 2786.08 "Анатолий Кулаков" Версия, пока находится в превью, полностью бесплатная.
2786.08 2787.32 "Анатолий Кулаков" Вы можете ее скачать и пользоваться.
2787.32 2792.36 "Анатолий Кулаков" В будущем райдер for Unreal Engine станет официальной частью самого райдера.
2792.36 2795.16 "Анатолий Кулаков" Сейчас это пока отдельная DE.
2795.16 2798.16 "Анатолий Кулаков" И точных сроков команда не обещает.
2798.16 2804.92 "Анатолий Кулаков" И примерные планы - это зарелизить райдер for Unreal Engine до конца 2020 года.
2804.92 2806.36 "Игорь Лабутин" Ну, прекрасно.
2806.36 2807.36 "Игорь Лабутин" Прекрасно.
2807.36 2813.12 "Игорь Лабутин" Никогда разработкой игр не занимался, но, наверное, тем, кто это делает, это будет полезно.
2813.12 2818.76 "Анатолий Кулаков" Скорее всего, да, потому что вспомогательные инструменты нам, например, в Enterprise мире очень сильно от JetBrains помогли.
2818.76 2825.40 "Анатолий Кулаков" Я думаю, что в играх там еще большая проблема, потому что на них практически никто не обращает внимания, как на разработчиков.
2825.40 2831.60 "Анатолий Кулаков" И там довольно все уныло с точки зрения анализаторов, которые могут предоставить ребята из JetBrains.
2831.60 2835.80 "Игорь Лабутин" Окей, у тебя так хорошо получается это рассказывать, давай еще про что-нибудь расскажешь.
2835.80 2838.04 "Анатолий Кулаков" Не очень дотнетная тема.
2838.04 2841.08 "Анатолий Кулаков" Представлен при релиз Grafana 7.
2841.08 2846.36 "Анатолий Кулаков" Grafana - это не самый дотнетный инструмент, но очень хочется про него рассказать.
2846.36 2853.56 "Анатолий Кулаков" Вообще, я считаю, что настоящий разработчик должен интересоваться миром вокруг себя, а не только дотнетом.
2853.56 2868.16 "Анатолий Кулаков" Поэтому, если у вас вдруг случайно предоставится возможность за цену двух оффлайн билетов посетить восемь конференций, самых крупных конференций в России по различным технологиям, то очень рекомендую этим возможностью воспользоваться.
2868.16 2885.28 "Анатолий Кулаков" Например, на конференции DevOps очень часто упоминаются такие темы, как метрики, как графаны, как инфлюкции, как это все собирать вместе, анализировать и так далее, чего очень сильно не хватает на наших специализированных конференциях ввиду немножко не того формата.
2885.28 2893.32 "Анатолий Кулаков" И в частности, одним из инструментов, которым, мне кажется, обязан научиться пользоваться каждый разработчик - это Grafana.
2893.32 2896.32 "Анатолий Кулаков" Grafana - это лидер сейчас по построению красивых графиков.
2896.32 2903.12 "Анатолий Кулаков" Графики могут получаться откуда угодно, но в основном это мы сейчас говорим о метриках, то есть Grafana - это все-таки таргетируется на метрики.
2903.12 2905.88 "Анатолий Кулаков" И это было так до прошлого релиза.
2905.88 2911.84 "Анатолий Кулаков" В прошлом релизе Grafana выпустила отдельный инструмент, который называется Grafana-Locky.
2911.84 2917.04 "Анатолий Кулаков" Это тул, который предназначен для сбора и анализа логов.
2917.04 2919.68 "Анатолий Кулаков" То есть Grafana покусилась еще и на логи.
2919.68 2922.80 "Анатолий Кулаков" И чем знаменателен новый релиз Grafana 7?
2922.80 2932.92 "Анатолий Кулаков" Тем, что она убивает третьего кита, на котором стоит все обсервабилити, то есть она уже покрыла метрики, она уже покрыла логи и последний, кто оставался - это Distributed Tracing.
2932.92 2955.92 "Анатолий Кулаков" В новом релизе Grafana нативно будет поддерживать Distributed Tracing, то есть она сможет отслеживать запросы, которые летают между вашими микросервисами, между вашими программами, сможет их отслеживать, визуально показывать в виде красивого дерева, на котором будет понятно, где присутствуют затыки, какое место сколько времени заняло, что где происходило, всякую дополнительную красивую информацию.
2955.92 2959.08 "Анатолий Кулаков" В общем, в сложных системах станет разбираться намного-намного легче.
2959.08 2968.08 "Анатолий Кулаков" Поддерживаются два стандарта, сейчас это Jagger и Zipkin, это должно хватить большинству тем, кто увлекается Distributed Tracing.
2968.08 2972.48 "Анатолий Кулаков" Второе такое большое нововведение - это Transformation.
2972.48 2982.68 "Анатолий Кулаков" Раньше Grafana рассчитывала на то, что всякие агрегации, каунты, анализы и прочие глупости будут делать те движки, информацию из которых она отображает.
2982.68 2992.20 "Анатолий Кулаков" Она поддерживает огромное количество дата сорсов, естественно, InfluxDB, Postgres, MS SQL, Prometheus и прочее-прочее.
2992.20 2996.72 "Анатолий Кулаков" В принципе, все, что вы можете представить, скорее всего, Grafana поддерживается для сбора данных.
2996.72 3005.52 "Анатолий Кулаков" И она обычно рассчитывала, что эти движки сами знают, сами умеют понимать и оптимально исполнять всякие агрегационные функции трансформации.
3005.52 3013.16 "Анатолий Кулаков" Но сейчас она выросла и начали появляться очень странные движки, такие как, например, "забери мне все данные из Google Spreadsheet таблицы".
3013.16 3019.00 "Анатолий Кулаков" И там, естественно, никакой трансформации и агрегации и Алаб-кубирования не встроено.
3019.00 3034.12 "Анатолий Кулаков" Поэтому ребята решили поддержать независимый движок, который позволяет вам производить любые манипуляции с точками, дофильтровать их, джойнить с другими дата сорсами, сделать из них пивот, переименовать, выполнить какие-то математические операции и так далее.
3034.12 3038.56 "Анатолий Кулаков" В общем, просто из тех точек, которые Grafana уже имеет.
3038.56 3043.00 "Анатолий Кулаков" Для некоторых дата сорсов, для бедных дата сорсов это довольно-таки хорошее и интересное преимущество.
3043.00 3044.52 "Анатолий Кулаков" На остальном я останавливаться не буду.
3044.52 3046.44 "Анатолий Кулаков" Если вам интересно, почитайте по ссылке.
3046.44 3050.60 "Анатолий Кулаков" Там опять переделали редактор UI-ного интерфейса.
3050.60 3053.44 "Анатолий Кулаков" Он стал еще более понятным, более гибким и более красивым.
3053.44 3058.92 "Анатолий Кулаков" Ну, вообще, Grafana довольно интуитивная, поэтому не бойтесь, если вы раньше ни с этим, ни с чем не сталкивались.
3058.92 3064.44 "Анатолий Кулаков" Можно буквально открыть демки, потыкать, посмотреть, отравить на ваши текущие данные и уже получить море
3064.44 3066.44 "Игорь Лабутин" фана. Звучит прям здорово.
3066.44 3067.44 "Игорь Лабутин" Да.
3067.44 3070.80 "Игорь Лабутин" На тот Next же был разговор про Grafana, ты как раз доклад делал.
3070.80 3074.60 "Игорь Лабутин" Но, пожалуй, это, наверное, единственное упоминание было такого рода на тот Next.
3074.60 3078.04 "Анатолий Кулаков" Да, я пытался вставить полезный инструмент хоть как-то в дотнет тематику.
3078.04 3081.84 "Анатолий Кулаков" Надеюсь, что у меня получилось, чтобы кто-то обратил на нее внимание.
3081.84 3085.68 "Анатолий Кулаков" Но мне кажется, надо больше, надо еще больше про это говорить, надо еще больше про это рассказывать.
3085.68 3086.68 "Игорь Лабутин" Окей, посмотрим.
3086.68 3093.08 "Игорь Лабутин" Последняя, наверное, на сегодня тема - это очередная новинка от Microsoft.
3093.08 3102.36 "Игорь Лабутин" Microsoft всячески поддерживает мир open-source и тем интереснее следить за тем, что там происходит.
3102.36 3132.52 "Игорь Лабутин" Они анонсировали разработку нового, я сначала думал, что просто Reverse Proxy, то есть то, что Microsoft решил написать замену Nginx или еще чему-то, но нет, они начали новый проект, который называется YARP, соответственно, YARP - это YARP Reverse Proxy, но это не непосредственно приложение или что-то, это набор библиотек, который позволяет вам написать Reverse Proxy более просто.
3132.52 3157.84 "Игорь Лабутин" То есть это все базируется на S/PANET и позволяет сделать раутинг endpoints, SSL termination, возможно, какие-то трансформации запросов по пути не, так скажем, простыми способами, руками написав все контроллеры, а задав все в конфиге, и оно само все взлетит.
3157.84 3173.60 "Игорь Лабутин" Согласно тому, что написано, это все произросло из внутренних нужд Microsoft, несколько команд внутри Microsoft делают такие вещи самостоятельно, и вот они попросили объединиться и сделать единый solution на всех, ну и Microsoft его успешно из Open Source сделал дополнительно.
3173.60 3196.20 "Игорь Лабутин" Тоже все это еще на очень ранней стадии, там пока есть какие-то очень базовые примеры, как это все работает, но выглядит интересно, и действительно, если вам нужен какой-то load balancing, простой forwarding реквестов, возможно, сбор метрикс по использованию вашей API, можно рассмотреть эту штуку, поконтролировать из нее в том числе, и как-то повлиять на то, как она будет развиваться.
3196.20 3224.68 "Анатолий Кулаков" Да, прежде всего хотелось бы этот проект отметить в том, что он в зачатом существенном состоянии, и там очень интересно идут дискуссии про позылы, про то, как это нужно делать, как это можно реализовать, то есть, например, если вы очень интересовались, каким образом там работает HTTP протокол, работает load balancing, работает port forwarding, encryption и прочие вот эти вещи, но никак с этим не сталкивались, то это отличный проект для того, чтобы последить за ним, для того, чтобы поучаствовать в дискуссиях и посмотреть.
3224.68 3233.28 "Анатолий Кулаков" Посмотреть, потому что очень интересные алгоритмы там открываются, очень интересные оптимизации также точно на performance открываются, очень интересные возможности.
3233.28 3238.84 "Анатолий Кулаков" И это все под кураторством мудрых и бородатых дядьков из Microsoft, поэтому в просак вы с ними не попадете.
3238.84 3242.92 "Анатолий Кулаков" В общем, посмотрите на этот проект еще с точки зрения как вклад в open source.
3242.92 3247.20 "Игорь Лабутин" Да, и на этом я думаю, что на сегодня мы закончили.
3247.20 3248.20 "Игорь Лабутин" Думаю, да.
3248.20 3261.72 "Игорь Лабутин" Мы, соответственно, сегодня поговорили про то, чем можно заняться в ближайшее время на онлайн просторах конференций JetBrains, Microsoft Build, конечно же, .NET и все остальные конференции Jougrou Group.
3261.72 3291.08 "Игорь Лабутин" Посмотрели новинки .NET 5, Source генераторы, вспомнили немножко прошлое про ГЦ от автора и главного архитектора ГЦ Маони и обсудили новинки в, так скажем, прикладных областях вокруг .NET, новые .NET Runtime написанные на самом же .NET, Rider, Grafana и Revios Proxy библиотеки, которые практически все эти еще штуки в зачаточном состоянии, но, скорее всего, разовьются во что-то интересное.
3291.08 3294.60 "Анатолий Кулаков" А на этом все, всем спасибо и до новых встреч, пока!
3295.20 3295.70 "Анатолий Кулаков" Пока!
