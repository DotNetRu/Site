0.00 8.84 "Анатолий Кулаков" Здравствуйте, уважаемые слушатели.
8.84 13.20 "Анатолий Кулаков" В эфире Радио Дотнет и его постоянный ведущий Анатолий Кулаков.
13.20 14.20 "Игорь Лабутин" И Игорь Лабутин.
14.20 15.20 "Анатолий Кулаков" Всем привет.
15.20 17.20 "Анатолий Кулаков" Выпуск у нас 94.
17.20 18.60 "Анатолий Кулаков" Растем, растем.
18.60 24.32 "Анатолий Кулаков" Не мы одни растем, с нами наши постоянные друзья, которые пребывают, что не может не радовать.
24.32 26.60 "Анатолий Кулаков" Только слушайте сегодня эти прекрасные имена.
26.60 42.60 "Анатолий Кулаков" Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков, Андрей Фазлеев и Басим Альджавахири.
42.60 48.64 "Анатолий Кулаков" Друзья, огромное спасибо всем, кто нас поддерживает, помогает, а также не забывайте, шары, репосты, колокольчики.
48.64 52.16 "Анатолий Кулаков" Ну и самое главное, слушаем, слушаем наш подкастик и рассказываем о нем друзьям.
52.16 65.88 "Анатолий Кулаков" Потому что интересные новости у нас происходят, да, мы тут полгода ныли, что у нас ничего не выходит от команды Микрософта, и тут бац, как раз команда Микрософт разродилась, и новостей прям напылила на целый выпуск.
65.88 81.68 "Игорь Лабутин" Прям, да, причем было интересно, что мы, записывая выпуск, особенно в конце там жаловались, что ждем новостей, ждем новостей, и буквально, когда я уже обрабатывал этот самый выпуск, все эти новости и прилетели, так что да.
81.68 82.68 "Игорь Лабутин" Подождали.
82.68 93.56 "Анатолий Кулаков" Ну я думаю, как раз хорошо, там они настоялись, появились комментарии, обзорчики сторонние, видосики сторонние, поэтому мы это все впитали, и сейчас вам расскажем, что же такого представилось нам от Микрософта.
93.56 104.08 "Игорь Лабутин" Да, для начала, внезапно, в середине года, никого не предупредив, DotNet Aspire стал релизным, ну точнее General Availability GA.
104.08 115.36 "Анатолий Кулаков" Слушай, а тебя тоже удивило, да, я думал, что как раз где-то там в ноябре, в сентябре, на обычном осеннем презентации зарелизится, ну и как остальные большие анонсы, вот туда они все уйдут.
115.36 118.80 "Анатолий Кулаков" А тут какая-то посреди года, зачем, перед летом, кому это надо.
118.80 136.12 "Игорь Лабутин" Да, с одной стороны, удивило, это правда, но с другой стороны, подумав немножко, я понял, что может быть в этом был какой-то смысл, потому что все-таки DotNet Conf осенний, он именно ориентирован на DotNet разработку, ну по большому счету, да, то есть там анонсируется именно новый DotNet, и все, что с ним связано вокруг.
136.12 152.06 "Игорь Лабутин" А кажется, что с Aspire они все-таки целятся не только в DotNet, а и в другие стейки вокруг DotNet, и поэтому, может быть, на Microsoft Build, который такое более широкое мероприятие с точки зрения тематики… Ну типа конференция Майкрософта
152.06 154.00 "Анатолий Кулаков" для всех разработчиков, не только дотнетовских.
154.00 159.44 "Игорь Лабутин" Да, да, потому что там они же там и железо анонсировали свои эти серфисы и все такое, ну и вот заодно Aspire.
159.44 169.48 "Анатолий Кулаков" Да, да, в принципе, если мы говорим про позиционирование Aspire, то Build, наверное, к нему даже лучше подходит, но я думаю, ты нам расскажешь про фичи, которые подходят и другим языкам, не только дотнету.
169.48 172.40 "Анатолий Кулаков" То есть зачем кому-то, кроме дотнета, Aspire?
172.40 173.40 "Игорь Лабутин" Да, давайте.
173.40 187.20 "Игорь Лабутин" Собственно, никаких новых нововведений в Aspire в момент релиза не было объявлено, то есть все то, что мы рассказывали, оно все остается в силе, если это не было в каких-то ранних превью и уже выпилено, потому что такие случаи тоже были.
187.20 199.40 "Игорь Лабутин" Но на всякий случай, давайте действительно напомним, пробежимся по статье, в которой, собственно, написан анонс Aspire, где рассказано, что это такое, зачем оно вам, может быть, нужно или как этим всем пользоваться.
199.40 210.64 "Игорь Лабутин" В целом, они, Microsoft называют Aspire, это новый стек разработки, который упрощает разработку, собственно, дотнетных клауднейтив приложений.
210.64 220.40 "Игорь Лабутин" То есть он все-таки упрощает разработки именно дотнетных клауднейтив приложений, но вообще говоря, все-таки не только дотнетных, там есть кусочки, которые можно применить для любых.
220.40 235.88 "Игорь Лабутин" Для того, чтобы его попользовать, вам нужна либо Visual Studio 17.10, либо дотнет CLI последней версии, либо можно Visual Studio Code с последним C#, как его, DevKit, там все будет нормально, натурально работать.
235.88 250.84 "Игорь Лабутин" Все вместе, Aspire вообще как таковой, состоит из пачки тулов, каких-то шаблонов, проектов и NuGet пакетов, которые вы можете к себе поставить, которые все это вместе помогает вам собирать приложение.
250.84 265.64 "Игорь Лабутин" Важно, что Aspire ориентирован именно на distributed клаудные приложения, то есть распределенные приложения для облаков, и если вы пишете Desktop на WPF, возможно, Aspire, вы не целевая аудитория.
265.64 277.56 "Игорь Лабутин" Но кажется, что действительно у нас всяких распределенных клауднейтив приложений сейчас подавляющее большинство, по крайней мере, ими точно много кто занимается, и поэтому потенциально Aspire пригодится всем.
277.56 281.44 "Игорь Лабутин" Для того, чтобы Aspire начать использовать, вам нужно как-то поставить его себе.
281.44 290.40 "Игорь Лабутин" Если вы пользуетесь CLI или Visual Studio кодом, то нужно в CLI поставить через команду .NET Workload сказать .NET Workload install Aspire.
290.40 303.00 "Игорь Лабутин" В Visual Studio это все входит в ASP.NET и в Web Development Workload, и если вы занимаетесь ASP.NET, то Aspire у вас уже поставлен, если вы студию обновили до последней 17.10.
303.00 305.28 "Игорь Лабутин" Зачем вообще Aspire создавался?
305.28 319.44 "Игорь Лабутин" В целом у них есть, у Microsoft есть цель сделать .NET, ну, одной из таких самых, на английском называется Productive Platform, хотел хотеть продуктивную платформу.
319.44 322.00 "Игорь Лабутин" Платформа-то не продуктивная, разработчики продуктивные.
322.00 325.44 "Игорь Лабутин" Короче, платформы удобны для создания клауднейтив приложений.
325.44 329.88 "Игорь Лабутин" И на пути к этому, на самом деле, они делают много чего.
329.88 340.66 "Игорь Лабутин" Мы уже много раз упоминали всякие разные штуки всякие там, начиная от мелочей, типа встроенных удобных health-чеков, заканчивая такими штуками, как там YARP, поддержка gRPC.
340.66 354.60 "Игорь Лабутин" Они вот Native OAuth активно пытаются продвигать и тестировать и улучшать, чтобы был некоторый хороший баланс между перформансом и размером, да, и мы не тащили весь большой рантайм с собой.
354.60 378.04 "Игорь Лабутин" Но при всем при этом, это все, конечно, здорово, все эти фичи помогают нам делать клауд-приложения, но для вашей локальной разработки этого, конечно, не совсем достаточно, в том плане, что если вы разрабатываете для клауда, то обычно у вас есть вокруг достаточно большой зоопарк всего остального, приложения же распределенные, напомню.
378.04 413.00 "Игорь Лабутин" И поэтому разработчики очень хотели, чтобы что-то было еще, чтобы им было попроще жить локально, потому что то количество усилий, которые уходят на то, чтобы помнить про то, как там коннектиться ко всяким там Redis'ам, Postgres'ам, шинам данных, этим, месседбасам и прочим внешним и не очень внешним сервисам, да и между сервисами тоже общаться, оно на самом деле довольно, объем этих знаний, которые нужно держать в голове, довольно велик.
413.00 426.28 "Игорь Лабутин" И тем самым, пока вы пишете такое приложение, у вас большая часть времени, не сказать, что больше, но большая часть времени уходит на как раз вот всю вот эту вот обвязку и инфраструктурную работу, вместо того, чтобы писать собственно саму бизнес-логику.
426.28 458.56 "Игорь Лабутин" И для того, чтобы все это упростить, соответственно придумали .NET Aspire, который позволяет сделать сразу удобно и при этом продуктивно писать приложение, не поступая с никакими проблемами, не поступая с observability, все еще поддерживая нормальные там логирования, нормальный уровень резиллиенса, то есть газоустойчивости и всего такого, и не сильно при этом задумываясь.
458.56 461.88 "Игорь Лабутин" Значит, как это все работает?
461.88 484.32 "Игорь Лабутин" Как я уже сказал, распределенное приложение в среднем это большой набор проектов, которые между собой как-то общаются, плюс еще некоторое количество то, что они называют hosted services, это базы данных, какие-то другие хранилища, возможно, нейролиционные кэши, всякие месседжинг штуки, и все это вместе нужно сконфигурировать и запустить.
484.32 491.00 "Игорь Лабутин" И поэтому для того, чтобы это все сделать попроще, в Aspire появилась новая сущность, которая называется проект app-host.
491.00 508.40 "Игорь Лабутин" Он позволяет вам на C# описать конфигурацию того, как ваше приложение устроено, то есть именно прямо на C# вы пишете, как ваши ресурсы, а все вот эти проекты и внешние сервисы называются ресурсами, взаимодействуют между собой.
508.40 521.40 "Игорь Лабутин" То есть вот этот коннектится к этому, здесь нам нужно поднять Redis, здесь нам нужно подключить вот эти два наших сервиса к этому поднятому Redis с помощью какой-то connection string.
521.40 528.80 "Игорь Лабутин" Вот магия вся заключается в том, что вы не определяете, какой connection string, вы просто говорите, вот этот сервис должен общаться с вот этим Redis.
528.80 529.80 "Игорь Лабутин" Все.
529.80 534.64 "Игорь Лабутин" Где он будет развернут, как он будет запущен, локально, не локально, это не ваше дело.
534.64 544.40 "Игорь Лабутин" Этим всем занимается Aspire, который смотрит на вашу конфигурацию, написанную на C#, строит по ней то, что называется внутреннее представление, это называется application model.
544.40 564.52 "Игорь Лабутин" И когда вы запустите такой app-host, у вас некоторым магическим образом, ну понятно, что магии никакой нет, там все там, docker-контейнеры, либо ваши .NET проекты, либо просто какие-то исполнимые файлы, все это запустится, поднимется и сконфигурится так, что они все будут правильно видеть друг друга.
564.52 578.08 "Игорь Лабутин" То есть там, где нужны connection string, и в допустим контейнер Redis будет передана конфигурация, там слушаный к такому-то порту, и в ваше приложение будет передано правильное переменное окружение со словами "коннексия к такому-то порту".
578.08 591.32 "Анатолий Кулаков" Похоже это на какой-нибудь очень умный docker-compose или kubernetes, для которого не нужно писать отдельную конфигурацию, а он сам по вашему .NET приложению понимает, как это все вместе завязать, обработать, запустить и заставить красиво показывать логи и графики.
591.32 615.18 "Игорь Лабутин" Ну в каком-то смысле да, в docker-compose есть штука под названием "dependence", то есть ты можешь сказать, что вот этот сервис depends от другого сервиса, и там докер будет пытаться как-то следить, что если у вас один контейнер упал, то тот, который от него зависит, наверное, тоже надо бы перезапустить или остановить или еще что-нибудь сделать, но он действительно ничего не делает про конфигурацию, ты все пишешь руками.
615.18 621.08 "Игорь Лабутин" Если нужно сконфигурить все из общей переменной окружения, ну ты ее прокидываешь и туда, и сюда, и в один и в другой контейнер.
621.08 631.92 "Анатолий Кулаков" Ну да, а Espire, видишь, такой умный, что он соображает, что у нас .NET приложение, он понимает его специфику, он понимает connection-string, и может конфигурацию сам более-менее, такую базовую, хотя бы инфраструктурную сам обеспечить.
631.92 643.52 "Игорь Лабутин" Да, но он это делает все-таки не совсем сам, в том смысле, что не то чтобы Espire внутри себя написан так, что он знает все, нет, он это делает путем подключения разных модулей.
643.52 669.48 "Игорь Лабутин" То есть все вот эти сервисы, которые можно действительно подключать, это все по сути набор, точнее, это не сервисы набора, а то, как вы пишете вашу конфигурацию на C#, это набор extension-методов, которые поставляются из компонентов Espire, которые позволяют расширить функциональности Espire и дать ему знания о каких-то новых сервисах или новых типах приложений или еще о чем-то.
669.48 718.92 "Игорь Лабутин" То есть когда вы, например, говорите useRedis, грубо говоря, или addClientRedis, не помню точно, как сейчас называется метод, то на самом деле он просто конфигурит стандартный редисовский клиент, который они там выбрали, и знает, что нужно в момент конфигурации взять из переменной окружения вот такую-то строчку, там будет написано host и port, и правильно там собрать из него url, ну с редисом попроще, а там, не знаю, с каким-нибудь Postgres или Oracle, там же нужно всю вот эту длинную, или с SQL-сервером, где это длинная-длинная connection-стринга, где host и port это только малая часть, там же еще есть куча всяких других параметров, модификации, вот это все, и вот эту вот всю строку он собирает автоматически на базе того, что мы передали из переменных окружений.
718.92 743.60 "Игорь Лабутин" И на серверной стороне то же самое, он знает, что если это редис, то нужно запустить docker-контейнер, он знает, что редисовский docker-контейнер, чтобы запустить, он там запустится на порту, какой там порт стандартный у редиса, 31 что-то там, я уже не помню, путаю, наверное, с кем-то, и его нужно правильно прокинуть наружу с правильным порт-маппингом именно в тот порт, который рандомно был выбран, и который был же передан к клиенту.
743.60 759.60 "Игорь Лабутин" То есть никакой особой магии там нет, но вот удобный набор extension-методов плюс некоторая логика, которая позволяет понять, что вот этот клиент коннектится к этому сервису, позволяет все это, естественно, настроить, по крайней мере для девелоперского окружения, практически бесшовно.
759.60 764.56 "Игорь Лабутин" Ну, потому что в девелоперском окружении вы обычно не паритесь, на каком порту там что у вас слушается, поднялось и хорошо.
764.56 773.88 "Игорь Лабутин" Понятно, что в проде там будут всякие вопросы firewall, безопасности, и там вот так просто на произвольном рандомном порту вряд ли кто-то будет поднимать.
773.88 778.36 "Игорь Лабутин" А для девелоперного это вообще зашибись.
778.36 815.72 "Игорь Лабутин" Компоненты эти, раз уж мы заговорили про компоненты, они не только позволяют настроить вот этот самый там connection string и как-то связать друг с другом ваши сервисы, они еще позволяют автоматически, точнее они написаны так, что они автоматически настраивают подключение к этим самым сервисам в достаточно надежном виде, то есть они автоматически добавляют poly с нужными плюс-минус разумными настройками, какие-то там экспоненциальные back-off ожидания следующих коннектов, circuit breaker и вот это все.
815.72 862.88 "Игорь Лабутин" То есть то, что вы в принципе можете все это написать руками, никаких проблем нет, но проблема в том, что это нужно знать, как писать, то есть вы можете все это сделать, но на каждый кейс вам придется идти в интернет, искать, как же это правильно писать, а какие же, как правильно, не знаю, настраивать back-off для, не знаю, кэша реддиса, наверное они будут немножко разные по сравнению с подключением к базе данных, особенно если это ваш мастер базы данных с записью, там как бы retry надо по-другому немножко настраивать и надо ли вообще их настраивать, а здесь есть некоторая базовая конфигурация, которая в среднем скорее всего подойдет довольно большому числу проектов, потому что она была сделана на базе некоторой практики того, как это в Майкрософте внутри все устроено и настроено.
862.88 868.12 "Анатолий Кулаков" Ну и не только же в Майкрософте, компоненты там могут писать и сторонние разработчики.
868.12 874.60 "Игорь Лабутин" Да, согласен, то есть про Майкрософт я имею в виду те компоненты, которые пишет действительно сама Майкрософт.
874.60 892.76 "Игорь Лабутин" Компоненты живут в том же репозитории, что и Aspire, и если вы считаете, что вам нужен какой-то новый компонент для какого-то сервиса или продукта, для которого еще не написано, можно законтрибить это pull-request туда, и оно войдет просто, оно соберет гетпакет и будет доступным для всех пользователей.
892.76 901.68 "Игорь Лабутин" Ну и естественно никто не мешает вам сделать ваш приватный личный Aspire-компонент, который вы будете использовать например только в рамках организации, ну вообще никаких проблем не делайте.
901.68 913.96 "Игорь Лабутин" Дальше, кроме собственно такой конфигурации для разработки, есть еще возможность все это дело задеплоить.
913.96 955.12 "Игорь Лабутин" Майкрософт конечно же, ну понятно, работает в основном с Ажуром, и для Ажура стандартный CLI-инструмент, он нативно понимает Aspire-овские проекты, и поэтому вы можете натравить его просто на Aspire-овский проект, сказать задеплой пожалуйста в Ажур, и он все аккуратненько разложит по нужным сервисам, там где докер поднимет правильный менедж-докер, там где дотнетный проект поднимет какой-нибудь App-сервис, там где какой-нибудь, не знаю, Redis использует Managed Redis, ну и вот это все, то есть он нативно все это замечательно задеплоит в ваш указанный тенент, и все в целом будет работать.
955.12 983.24 "Игорь Лабутин" Если нужно это деплоить в какие-то другие места, то понятно, что в среднем другие места понятия не имеются о том, что такое Aspire, тем более конфигурация написана на C#, и ждут какого-нибудь YAML-файла, как правило, то здесь есть возможность из этого апхаста получить некоторый конфиг того, что же вы там наконфигурили в текстовом виде, в виде, собственно, ничего-то я не помню, JSON или YAML, JSON по-моему, по-моему он JSON задеплевывает, ну понятно.
983.24 984.24 "Игорь Лабутин" По-моему JSON, да.
984.24 1024.20 "Игорь Лабутин" Да, JSON в YAML перегнать дело несложное, особенно если вам нужен какой-то конкретный YAML, и вот в частности одна из популярных технологий нынче, это депломент в Kubernetes, особенно в Aspire оно не поддерживается, Microsoft сознательно не стали писать депломент в Kubernetes, зато есть параллельный проект Aspire 8, который пишется как Aspire 8, Aspire 8, который как раз берет вот этот JSON-чик и преобразует его в нужные конфиги кубера, плюс Helmchart умеет генерить в последней версии, и это позволит вам ваш Aspire-проект задепловать в ваш Kubernetes-кластер вообще без проблем.
1024.20 1026.84 "Анатолий Кулаков" И, кстати, Docker Compose тоже оно умеет.
1026.84 1045.16 "Игорь Лабутин" Вот, значит, это все было бы здорово и хорошо, если и, наверное, пользовалось бы определенной популярностью, но кажется, по крайней мере, половина такого хайпа, не хайпа, но интереса вокруг Aspire произошло от другой его части, а именно Dashboard.
1045.16 1060.84 "Игорь Лабутин" Значит, после того, как вы все запустили локально для разработки, это все, конечно, здорово и хорошо, но что нужно и чего часто не хватает в локальной разработке, это возможность как-то посмотреть на метрики, посмотреть на логи.
1060.84 1069.00 "Игорь Лабутин" Не то, что вам, наверное, нужны метрики прямо локально, но в целом полезно иметь некоторое единое место, куда сваливаются, например, логи от всех ваших приложений.
1069.00 1075.08 "Игорь Лабутин" Конечно, вы можете настроить какой-нибудь единый сек-сервер либо что-то подобное, но Aspire это…
1075.08 1082.72 "Анатолий Кулаков" Потом рядом единое Grafana, потом рядом единый Prometheus, и так рядом единых контейнеров еще 10 штук поднимите, чтобы это все вам посмотреть.
1082.72 1102.36 "Игорь Лабутин" По поводу на GitHub на самом деле композы, которые это все поднимают вместе, они есть, они вполне юзабельны, но действительно, Aspire предоставляет довольно удобный Dashboard, в который автоматически стекаются все метрики, структурированные логи, трейсы всего того, что происходит в ваших приложениях, сервисах, которые вы заиспользовали в Aspire.
1102.36 1112.56 "Игорь Лабутин" Плюс у него торчит наружу OpenTelemetry Endpoint, в который можно просто слать любые данные из любых в общем-то приложений, и они все там тоже будут копиться и отображаться.
1112.56 1138.36 "Игорь Лабутин" Надо понимать, что это все Development Only штука, то есть только для разработки, все это InMemory, никаких там как бы персистентных хранилищ, не надо это разворачивать себе для прода, хотя там есть сервисы, появились сейчас плагины, которые позволяют персистентно это хранить, но кажется, что это все-таки не совсем то, для чего предназначалось, поэтому вряд ли это будет работать нормально на больших масштабах, но для локальной разработки вообще прекрасно.
1138.36 1144.40 "Игорь Лабутин" Ну или для какого-нибудь там маленького деф-контура может быть вполне сойдет, временно поднимаемого.
1144.40 1151.60 "Анатолий Кулаков" Слушай, а мне кажется через годик или через пару версий дорастет до того, что на маленьком проде уже тоже может быть ничего совсем.
1151.60 1166.92 "Игорь Лабутин" Ну может быть, может быть действительно народ поиспользует, посмотрит где узкие места, на чем оно больше всего падает, просто накопится какой-то опыт использования и будут какие-то рекомендации, что мол там не знаю, трейсов туда не валите много, а там не знаю, метрик оно выдерживает много.
1166.92 1168.40 "Игорь Лабутин" Ну почему нет?
1168.40 1169.40 "Анатолий Кулаков" Действительно.
1169.40 1177.52 "Анатолий Кулаков" Ну да, довольно удобный дашборд, почему бы не заставить его работать более надежно и более отказоустойчиво и все, и вот тебе вполне нормальный продакшн, продакшн решение.
1177.52 1178.52 "Игорь Лабутин" Да.
1178.52 1187.52 "Игорь Лабутин" Ну в общем вот теперь оно general availability, продакшн, так сказать, ready, в смысле development ready, в смысле готово к продакшну на ваших девелоперских машинах.
1187.52 1219.00 "Игорь Лабутин" Пробуйте, пользуйтесь, и почему оно может быть интересно не только дотнетчикам, поскольку OpenTelemetry у нас сейчас плюс-минус стандарт по индустрии, и поэтому даже если вы пишете что-то на какой-нибудь там, не знаю, Go, Java, еще ком-нибудь локально, и ваши сервисы и продукты умеют слать метрики, логи и трейсы, то вы можете поднять Aspire только ради дашборда, там есть такой специальный режим, можно сказать, есть пример на GitHub, как это сделать, просто в докере поднять его и спокойненько использовать его как такой универсальный локальный дашборд для телеметрии.
1219.00 1236.68 "Анатолий Кулаков" Да, опять же такая замена вот этим всем распространенным решением, но только в отличие от тех композов, которые поднимают всякие сики, графаны и прометеусы все вместе, здесь у вас будет хорошее красивое окошко, которое поднимает хороший интерфейс, который все это объединяет, а вот с этим уже у многих инструментов проблемы.
1236.68 1238.60 "Игорь Лабутин" Да, такие дела.
1238.60 1241.64 "Игорь Лабутин" Ну что, давай дальше.
1241.64 1248.96 "Игорь Лабутин" Это не единственные, так сказать, новости, есть более интересные, с моей точки зрения, новости, которых мы очень долго ждали.
1248.96 1255.00 "Анатолий Кулаков" Ну, не знаю, более не более, но новостей сегодня много хороших, интересных и разных, поэтому да, давай не будем останавливаться.
1255.00 1265.28 "Анатолий Кулаков" Есть новости про C# 13, конечно, то, что мы ждали-ждали, просили и нудили, как бы вот, наконец, подвезли, что ж такое будет основная фича C# 13.
1265.28 1277.52 "Анатолий Кулаков" Судя по всему, похоже на все, что это будет фича, которая называется Extension Types, также мы ее раньше упоминали как Extension Everything, т.е. это возможность писать экстеншн методы ко всему, к чему только захочется.
1277.52 1282.84 "Анатолий Кулаков" Вот, это хорошая новость, но есть плохая, но мы пока не дадут.
1282.84 1292.80 "Анатолий Кулаков" На билде показали радостно и красиво, как будет выглядеть Extension Types, но дело в том, что в ближайшем превью, который вот как раз вместе с билдом вышел, эта штука не вошла.
1292.80 1307.72 "Анатолий Кулаков" Не очень понятно, почему там, или не готовы показать, или не готова фича, или еще какие-то проблемы, но смеем надеяться, что в следующем превью она все-таки уже должна быть, ну, как бы уже пора, народу нужно время, чтобы обкатать до релиза, до осени, поэтому с терпением ждем.
1307.72 1310.76 "Анатолий Кулаков" А пока разберемся, что же это такое, что же это за зверь такой.
1310.76 1318.04 "Анатолий Кулаков" Это новая конструкция, новые ключевые слова в C#, которые позволяют нам писать Extension методы практически для всего, чего мы захотим.
1318.04 1343.72 "Анатолий Кулаков" Наверное, многие из вас знают, что там со времен, наверное, линку, там со времен третьего C#, 3.5, у нас появились Extension методы, которые могут симулировать, как бы прицеплять дополнительные методы к уже существующим сторонним классам, к тем классам, у которых у нас нет возможности дописать какой-то код, например, к классам от Микрософта, где поставляется самый замечательный пример, это IEnumerable.
1343.72 1354.88 "Анатолий Кулаков" Он сам по себе содержит не так уж много функциональности, и дописывать эту функциональность мы не имеем морального права, ну и физического тоже никакого, и поэтому с помощью Extension методов этот класс очень хорошо расширяется.
1354.88 1361.08 "Анатолий Кулаков" Всем вам известны методы там Aggregate, Sum, Select, Where, это все написано с помощью тех самых Extension методов.
1361.08 1373.48 "Анатолий Кулаков" Очень мощный механизм, наверное, прям одна из самых киллер фич C#, особенно на тот момент, когда эта штука выходила, ее не было практически нигде, а из таких, из мейнстриновых, конечно, языков.
1373.48 1379.32 "Анатолий Кулаков" В общем, крутая штука, тут особо, как бы, комментариев быть не может.
1379.32 1393.96 "Анатолий Кулаков" Единственный комментарий, что люди просили очень сильно сделать Extension методы не только для методов, они хотели расширять в классе и свойства, и делать статические методы, и делать конструкторы расширять, и много-много чего другого.
1393.96 1404.36 "Анатолий Кулаков" И вот, наконец-то, спустя много-много релизов, там 10 релизов самого C#, создатели подошли к этому вопросу и придумали нам следующую конструкцию.
1404.36 1408.80 "Анатолий Кулаков" Теперь мы можем сделать такую магию с помощью ключевых слов.
1408.80 1411.72 "Анатолий Кулаков" Прям вот, какое-то заклинание можно зачитывать.
1411.72 1422.36 "Анатолий Кулаков" Implicit Extension, имя класса, for, и вы после for указываете, а для чего вы будете делать Extension, ваши методы, для чего вы будете расширять.
1422.36 1424.96 "Анатолий Кулаков" Прям пошли в какой-то Native English программинг.
1424.96 1443.56 "Анатолий Кулаков" Такая вот странный заголовок, который позволяет вам описать тот класс с Extension, который у вас будет, и внутри этого класса вы уже можете писать методы и свойства, как будто они написаны в самом классе, который вы расширяете.
1443.56 1451.24 "Анатолий Кулаков" То есть, допустим, вы можете написать обычный Instance метод, не так, как мы раньше писали Extension с помощью статических ключевых слов.
1451.24 1452.24 "Анатолий Кулаков" Прям без статика.
1452.24 1462.52 "Анатолий Кулаков" Пишите обычный метод, и в этом методе можете обращаться к ключевому слову this, и это ключевое слово будет интерпретироваться в отношении расширяемого экземпляра.
1462.52 1470.68 "Анатолий Кулаков" То есть, вы вполне можете вызывать this методы, вы можете вызывать this property, и это все будет вполне нормально вызываться.
1470.68 1472.12 "Анатолий Кулаков" То есть, полноценный такой доступ получается.
1472.12 1478.32 "Игорь Лабутин" Слушай, а можно сразу вопрос, он прям полноценный-полноценный в том плане, что он даже к private полям сможет доступаться?
1478.32 1483.20 "Анатолий Кулаков" Нет, ни к private, ни даже к protected, ни даже к internal.
1483.20 1494.20 "Анатолий Кулаков" То есть, это все-таки не наследование, это все-таки не какая-то магия рефлексии, это те же самые наши привычные Extension методы в моральном плане, только немножко с другим синтексисом.
1494.20 1496.08 "Анатолий Кулаков" Синтексис более упрощенный и более гибкий.
1496.08 1500.96 "Анатолий Кулаков" Но вся суть осталась вот с теми Extension методами, которые мы были.
1500.96 1502.24 "Анатолий Кулаков" И теперь стало писать более удобно.
1502.24 1514.16 "Анатолий Кулаков" Не знаю, скорее всего, даже появится рефакторинг, чтобы мы наши старые классы, и статические наши старые классы перегоняли вот этот новый синтексис, потому что кажется, что он должен быть немножко проще и понятнее, и читается лучше.
1514.16 1515.16 "Анатолий Кулаков" Ну, посмотрим.
1515.16 1518.56 "Анатолий Кулаков" Посмотрим, до чего дорастут анализаторы.
1518.56 1522.40 "Анатолий Кулаков" Extension методы у нас уже были, поэтому этим народ не удивишь.
1522.40 1523.40 "Анатолий Кулаков" А чем же можно было удивить?
1523.40 1526.28 "Анатолий Кулаков" Ну, это дополнительные вещи, которые можно расширять.
1526.28 1529.96 "Анатолий Кулаков" Из того, что уже сейчас известно, можно будет расширять статические методы.
1529.96 1540.44 "Анатолий Кулаков" То есть, вы можете написать string, точка, и добавить туда какой-то статический метод, например, метод create, создать из какого-нибудь стрима, или создать из какого-нибудь JSON, или еще что-нибудь такое.
1540.44 1543.84 "Анатолий Кулаков" То есть, статические методы тоже можно теперь расширять.
1543.84 1554.68 "Анатолий Кулаков" Это, наверное, одна из самых востребованных фич, которые люди просили, потому что очень удобно таким образом делать какие-нибудь фабрики, которые у вас в факторе методы, которые у вас в доме вдруг нужны оказались.
1554.68 1558.88 "Анатолий Кулаков" И второе, по популярности, это, конечно же, расширение свойствами.
1558.88 1561.60 "Анатолий Кулаков" Не только методы хочется, но и свойства тоже.
1561.60 1563.00 "Анатолий Кулаков" И свойства тоже будут.
1563.00 1575.32 "Анатолий Кулаков" Более того, будут еще индексеры, то есть, будет возможность расширить индексеры класса, что тоже дает очень много таких удобных синтаксических сахаров, удобных конструкций для описания всяких DSL.
1575.32 1577.56 "Анатолий Кулаков" Поэтому индексеры - это тоже хорошо, это тоже есть.
1577.56 1583.52 "Анатолий Кулаков" Теперь вернемся к нашей магической строчке, которая описывает наш класс.
1583.52 1593.16 "Анатолий Кулаков" Внимательный читатель и также внимательный наслуг-слушатель мог услышать там магические слова implicit, extension и for какой-то метод.
1593.16 1597.48 "Анатолий Кулаков" Если есть implicit, то должен быть и explicit.
1597.48 1606.56 "Анатолий Кулаков" И, соответственно, у нас появились explicit extensions, то есть, extension методы, которые явно должны быть приведены к какому-то классу.
1606.56 1608.04 "Анатолий Кулаков" Для чего такая штука нужна?
1608.04 1609.48 "Анатолий Кулаков" И вот это уже новая концепция.
1609.48 1617.88 "Анатолий Кулаков" Если раньше обычные extension методы мы писали к строке, к урлу, к инту, еще к чему-нибудь, мы понимаем, как эта концепция работает.
1617.88 1621.96 "Анатолий Кулаков" И вот то, что мы понимаем, это сейчас называется implicit extensions.
1621.96 1626.60 "Анатолий Кулаков" А вот новая тема - это explicit extensions, такого еще никогда не было.
1626.60 1628.56 "Анатолий Кулаков" Давайте посмотрим на конкретном примере.
1628.56 1631.84 "Анатолий Кулаков" Например, давайте представим, что мы хотим написать расширение к строке.
1631.84 1646.56 "Анатолий Кулаков" И в данном конкретном случае мы знаем, например, что в нашей строке лежит хорошо отформатированный JSON-чик, и этот JSON-чик мы хотим десертилизовать в какой-нибудь JSON-string, чтобы уже потом с этой строкой оперировать на уровне JSON.
1646.56 1656.80 "Анатолий Кулаков" И когда мы пишем, мы можем написать такое расширение, которое будет относиться непосредственно только к классу, который называется JSON-strings.
1656.80 1660.84 "Анатолий Кулаков" На самом деле такого класса нету, поэтому мы его напишем в виде экстеншена.
1660.84 1666.16 "Анатолий Кулаков" То есть мы должны декларировать explicit extension JSON-string for string.
1666.16 1672.28 "Анатолий Кулаков" То есть мы расширяем класс, стандартный класс SystemString с помощью нашего экстеншен-класса, который называется JSON-string.
1672.28 1680.88 "Анатолий Кулаков" И в этом JSON-string мы можем написать кучу методов, которые будут уже оперировать со строкой, зная, что у нее внутри лежит валидный JSON.
1680.88 1686.88 "Анатолий Кулаков" Может быть, парсить, может быть, вычленять по JSON-пафу какие-то ключи, может быть, еще что-то.
1686.88 1700.72 "Анатолий Кулаков" И, естественно, такой класс делать implicit, то есть такие методы расширения, которые находятся в этом классе делать implicit не очень хочется, потому что они будут появляться по интеллисенсу в абсолютно всех строках, даже если там никаким JSON-ом и не пахнет.
1700.72 1707.80 "Анатолий Кулаков" Мы хотим сделать эти методы расширения только в определенный момент, когда мы почему-то по какой-то магии уверены, что мы туда положили JSON.
1707.80 1710.88 "Анатолий Кулаков" И вот в этих случаях нам нужен explicit.
1710.88 1724.84 "Анатолий Кулаков" Explicit означает, что прежде, чем мы получим extension-метод на данном классе string, мы должны каким-то образом компилятору сказать, что это не просто string, а это string, которое у нас интерпретируется как JSON-string.
1724.84 1727.40 "Анатолий Кулаков" Это можно сделать несколькими способами.
1727.40 1735.44 "Анатолий Кулаков" Например, сохранить нашу обычную string в переменную типа JSON-string, так называемая конвертация будет неявной.
1735.44 1739.76 "Анатолий Кулаков" Мы просто пересохраняем одну переменную в переменную другого типа, и все.
1739.76 1749.42 "Анатолий Кулаков" Или можем явно прямо закастить, мы можем прикастить тип string JSON-string и получим, опять же, экземпляр так называемый JSON-string.
1749.42 1750.42 "Анатолий Кулаков" Почему так называемый?
1750.42 1759.04 "Анатолий Кулаков" Потому что, естественно, никакой конвертации, ничего вот этого под капотом происходить не будет, то есть компилятор не будет вам вызывать какие-то боксинги, касты и еще что-то.
1759.04 1766.64 "Анатолий Кулаков" Он просто-напросто начнет интерпретировать ваш system string как некий класс JSON-string, которого не существует.
1766.64 1774.56 "Анатолий Кулаков" И у этого JSON-string мы, соответственно, пишем extension-методы, которые уже компилятор понимает, что он может применить к данному заказченному классу.
1774.56 1777.92 "Анатолий Кулаков" То есть, это такой structure typing у нас получается.
1777.92 1782.92 "Анатолий Кулаков" То есть, мы знаем, что в строке что-то лежит, и мы знаем, как с этим что-то мы можем работать.
1782.92 1795.56 "Анатолий Кулаков" Поэтому мы говорим, что теперь для нас это не строка, для нас это JSON-строка, и у нее появляется набор методов, которые компилятор нам будет подсказывать в интеллисенсе, к которым будет нормально компилировать и к которым будет нормально вызывать.
1795.56 1801.76 "Анатолий Кулаков" Но при этом для обычных всех строк все вот эти грязные методы, которые мы обозначили для JSON-string, будут не видны.
1801.76 1804.36 "Анатолий Кулаков" Такая вот структурная типизация получается.
1804.36 1809.80 "Игорь Лабутин" Слушай, а при этом для JSON-string все стринговые методы будут видны?
1809.80 1815.20 "Игорь Лабутин" То есть, всякие там .length, все стандартные стринговые методы, они все на месте останутся?
1815.20 1816.20 "Анатолий Кулаков" Да, да.
1816.20 1820.92 "Анатолий Кулаков" То есть, мы получаем такое своеобразное наследование от строки, то есть, расширяем ее дополнительными JSON-string
1820.92 1821.92 "Игорь Лабутин" методами.
1821.92 1837.40 "Игорь Лабутин" Я сначала подумал, что это похоже на, знаешь, иногда когда мне нужно такое поведение, я бы там написал, не знаю, структурку JSON-string с единственным полем value, типа string, и структурку, чтобы там не было лишних локаций, грубо говоря, и там, где надо.
1837.40 1847.08 "Игорь Лабутин" Ну вот я ее типа обернул, но дальше возникает действительно вопрос боксингов, там вот этого всего, если я ее куда-то положил, оно все, ну в класс, например, в поле, оно тогда забоксится.
1847.08 1863.80 "Игорь Лабутин" И плюс у меня нету, если я в этом классе, в этой структурке написал какие-то мои нужные вот эти а-ля экстенджн методы, то для того, чтобы добраться, например, до оригинальных методов строки, нужно было бы писать там что-нибудь, там JSON-string.value.length, грубо говоря, или дублировать метод.
1863.80 1871.52 "Игорь Лабутин" А так получается такой типа а-ля обертка над типом с экстра методами, но не скрывающая внутренний тип и не скрывающая внутренние методы.
1871.52 1872.52 "Игорь Лабутин" Ну удобно, да?
1872.52 1874.20 "Анатолий Кулаков" Да, да, это именно так.
1874.20 1892.04 "Анатолий Кулаков" И в принципе, вот мы часто поднимали тему примитива обсессиона, да, т.е. когда мы вводили специальный класс для того, чтобы обернуть вот такую точку value, да, какой-нибудь или int, или gui, или еще чего-нибудь, обернуть только для того, чтобы компилятор понимал, что это что-то разное, что-то другое.
1892.04 1895.68 "Анатолий Кулаков" И кажется, что этот подход тоже может вот здесь быть применим.
1895.68 1903.40 "Анатолий Кулаков" Т.е. вполне вероятно, что value-объекты тоже каким-то образом изменятся благодаря этому синтаксису, может быть, это будет удобнее, а может и нет, кстати.
1903.40 1905.12 "Анатолий Кулаков" Здесь надо посмотреть, здесь надо поэкспериментировать.
1905.12 1911.60 "Игорь Лабутин" Надо еще посмотреть, а один explicit extension к другому explicit extension приводится, если они к одному и тому же типу.
1911.60 1919.52 "Анатолий Кулаков" Интересный вопрос, да, да, я думаю, допилят, потому что технически это как бы все строка, которая имеет, грубо говоря, неявный каст, а росты.
1919.52 1920.52 "Игорь Лабутин" Ну да, да.
1920.52 1924.00 "Анатолий Кулаков" И туда, и туда есть неявный каст, значит, их через строку в любом случае можно преобразовать.
1924.00 1925.60 "Анатолий Кулаков" Поэтому кажется, что должны.
1925.60 1937.08 "Игорь Лабутин" Как раз именно вот здесь вот может быть и будет влиять то, пойдут ли они на замену вот этих всяких value-типов, ну вот примитивных, да, оберток и так далее.
1937.08 1942.48 "Игорь Лабутин" Потому что силы-то как раз примитивных оберток в том, что ты их случайно не скастишь одно в другое.
1942.48 1950.64 "Игорь Лабутин" А здесь, если компилятор будет позволять, ну как бы, ну передал JSON-стринг вместо какого-нибудь HEX-стринга, ну какая разница, обе же стринги.
1950.64 1957.04 "Игорь Лабутин" В общем, надо посмотреть, эту часть я не изучал, ну вообще, ну потому что она нам еще недоступна в том числе.
1957.04 1958.92 "Игорь Лабутин" Да, к сожалению, мы ее не дали.
1958.92 1961.28 "Игорь Лабутин" Но посмотреть будет интересно, как же это сделано.
1961.28 1969.24 "Игорь Лабутин" Скорее всего, конечно, команда про это думала, команда компилятора и языка дизайнера, и, наверное, может быть, даже где-то это описано, я просто не читал.
1969.24 1973.20 "Игорь Лабутин" Подождем, практических кейсов наверняка будут еще статьи.
1973.20 1981.60 "Анатолий Кулаков" Да, и мне кажется, видишь, здесь такая интересная концепция, которая дает что-то новое языку, наконец-то, да, вот какое-то новое дыхание, что-то интересное можно с ним будет делать.
1981.60 1991.30 "Анатолий Кулаков" Поэтому я надеюсь, что эту тему еще раскрутят с многих разных сторон, и мы какие-то конструкции такие интересные, интересные решения мы все-таки еще приобретем благодаря этой штуке.
1991.30 2002.66 "Анатолий Кулаков" Все так же, как и приобрели благодаря экстеншн-методам еще в третьем дот-нете, что он нам дал линку практически, да, вот дал линку, подарил новые идеи, вот эта вещь может что-то тоже такое интересное подарить.
2002.66 2007.78 "Анатолий Кулаков" Ну, и на что это еще похоже, да, кроме вот этих примитив обсессионов, про которые мы говорили.
2007.78 2041.70 "Анатолий Кулаков" Еще мы практически по полтора выпуска назад обсуждали такую вещь, как юзинги, да, мы, я говорил, я ссылался еще на статью, где с помощью обычного слова юзинг внутри одного файла вы можете таки сделать, избавиться от примитива эксцепшен для бедных, т.е. вы объявляете юзинг, даете какое-то название этому типу, который у вас есть, например, какой-нибудь dictionary string, вы вполне можете обозвать какой-нибудь dictionary, т.е. road dictionary там от роута и от мапа, что-нибудь такое, более говорящее, более на ревью такое, подходящее под то, что происходит на самом деле в вашей бизнес-логике.
2041.70 2126.98 "Анатолий Кулаков" Так вот, вот эти методы расширения, которые у нас есть в новом синтаксисе, они вполне могут служить вот такими элиасами, но только глобально, потому что, по сути, если мы сейчас объявим explicit класс, пронаследованный от той же самой строки, explicit класс, который назовем JSON strings, и внутри него даже не будем никаких экстеншен-методов писать, т.е. объявим его так, как он, грубо говоря, не предназначался, мы не будем использовать его экстеншен-методы, мы будем использовать только его ключевое слово explicit, то у нас получится вот своеобразный элиас, т.е. компилятор умеет string приводить к JSON string, он умеет давать ему, т.е. он умеет их различать, он умеет давать им тельсенсы и т.д., и мы вот можем объявить точно такой же элиас, который мы получили бы с помощью юсинга, но только если юсинг его давал нам на один класс, ой, на один файлик, т.е. с помощью explicit extension мы его можем получить для всей программы, потому что explicit extension виден абсолютно везде во всем проекте, вот, поэтому, может быть, опять же, их можно использовать как глобал-элиасы, вот, и уже немножко более, более такие строгие, более мощные, чем обычный юсинг, потому что юсинг, он просто-напросто компилятор один к одному смачивается, а здесь компилятор уже каким-то образом их различает, насколько он их будет различать, это мы посмотрим, когда нам выдадут какое-то превью, но точно это уже будет больше, чем строже, да, чем обычный юсинг.
2126.98 2137.54 "Анатолий Кулаков" Теперь, хочется немножко покомментировать, да, вообще, не, ну, фича прекрасная, да, Игорь, тут спорить не будешь, фича великолепная, она нужна и все такое.
2137.54 2144.54 "Игорь Лабутин" Ну, да, конечно, нормально писать классный экстенджен проперти, экстенджен индексеры, это прям здорово.
2144.54 2148.86 "Анатолий Кулаков" Вот, меня единственное поразило, это вот этот синтексис.
2148.86 2154.82 "Анатолий Кулаков" Непонятно, в каком ростаманском угаре нужно было придумать три ключевых слова вместо нуля.
2154.82 2176.90 "Анатолий Кулаков" Вот вспомни гениальность Андреса Хелсберга, который экстенджен методы придумал в ранних версиях C#, он использовал ноль ключевых слов новых, да, он вот этот if, то есть этот this, который у нас уже был, и статические методы превратил в экстенджены, и это было великолепно, это гениальный ход, красиво, понятно, семантично, все читается, никаких новых ключевых слов, ничего.
2176.90 2195.86 "Анатолий Кулаков" Здесь же парни пришли и сразу три ключевых слова влупили, это extension, это implicit, implicit и for, да, ну то есть вообще, ну как, ну вот зачем, ну вот зачем вот этот вот нагромождать опять-таки новые ключевые слова в C# и делать его еще более сложнее, еще более нечитабельнее.
2195.86 2227.66 "Анатолий Кулаков" Ну вот смотри, если в принципе, допустим, через две версии там или через три версии они додумаются, что explicit можно сделать необязательным, да, чтобы по дефолту explicit всегда был, ну как у нас, например, наследование от интерфейсов происходит, там по интерфейсу наследуется explicit по дефолту, если вам нужно implicit, то вы стараетесь и что-то для этого делаете, наверное, тут точно так же можно экстенджен-методы сделать explicit по дефолту и implicit там что-нибудь вставлять, ну или наоборот, в общем, выбрать какой-то дефолт, да, допустим, от одного из этих страшных слов мы избавимся.
2227.66 2268.66 "Анатолий Кулаков" Ключевое слово extension, ну, наверное, без него они не могли каким-то образом обозначить эти классы, хотя тоже спорно, наверное, что-то мы могли все-таки придумать, но, наверное, самое ужасное, что можно было изобрести, это for, да, потому что в оригинальном пропозоле, вот который это чудо представлял, вместо for было нормальное человеческое двоеточие, потому что очевидно, что когда ты делаешь extension JSON-стрингу, то внутри него ты себя ведешь абсолютно, как будто ты находишься в классе string, то есть, грубо говоря, ты внутри него ведешь себя практически так же, как будто ты от него пронаследовался, и вот двоеточие как признак пронаследования, он здесь гениально подходит.
2268.66 2291.78 "Анатолий Кулаков" Да, это не полное пронаследование, ну, может быть, для этого и нужен ключевое слово extension, может быть, вместо даже слова «класс» можно было его заделать, да, ну, т.е. благодаря ключевому слову extension мы понимаем, что это не просто наследование, а вот такое, магическое extension наследование, но какой смысл было менять двоеточие на вот эти ростаманские for-ы, мне вообще непонятно.
2291.78 2292.78 "Игорь Лабутин" Компилятор проще писать.
2292.78 2302.82 "Анатолий Кулаков" Смотри, они же, когда переписали всё наросли, они же на каждом углу кричали, теперь мы не имеем ограничения в написании компилятора, теперь мы можем расширять так гибко и так красиво, как только хотим, а теперь
2302.82 2304.74 "Игорь Лабутин" мы упираемся в том, что нам всё равно легче писать.
2304.74 2313.10 "Игорь Лабутин" Я не говорю, что есть ограничения, я говорю легче, оно гибкое, можно всё, но трудно, а так легче, одно отдельное ключевое
2313.10 2314.10 "Анатолий Кулаков" слово.
2314.10 2315.10 "Анатолий Кулаков" Парсиво круче.
2315.10 2321.98 "Анатолий Кулаков" Слушай, ну это же неправильно, что когда у тебя в одном месте тебе легче, тебе при этом должно тысяча пользователей страдать.
2321.98 2332.90 "Анатолий Кулаков" Правильнее было бы напрячь команду компиляторов, чтобы они сделали как бы, как им сложнее, но зато как пользователям всем этим было бы легче, было бы понятнее и тому подобное.
2332.90 2338.90 "Игорь Лабутин" Интересно, надо, не знаю, если будет не лень, попробую почитать, почему так было выбрано, наверняка же должно быть какое-то обсуждение.
2338.90 2347.06 "Анатолий Кулаков" Обязанно, ну потому что в оригинальном пропозале было именно двоеточие, да, и они специально поменяли на for, т.е. там что-то такое есть страшное.
2347.06 2356.62 "Анатолий Кулаков" Кстати, если вы знаете из наших слушателей кто-то, почему такое решили, приходите в комментарии и расскажите, потому что очень интересно, что могло людей сподвигнуть на такую глупость.
2356.62 2366.98 "Анатолий Кулаков" Ну что ж, а пока радуемся, что хоть какая-то фича у нас в языке появится все-таки, да, что не просто выпустим performance and improvements, а что-то более вменяемое наконец-то.
2366.98 2367.98 "Анатолий Кулаков" Поживем, посмотрим.
2367.98 2368.98 "Анатолий Кулаков" Да.
2368.98 2370.58 "Анатолий Кулаков" Давайте посмотрим, что еще у нас было, да?
2370.58 2381.34 "Игорь Лабутин" Смотри, а ты правильно сказал, что там instance, statики, properties, а там конструкторы, всякое, можно наследовать, не знаю, что делать, чтобы стринг наследовался от моего стринга.
2381.34 2383.02 "Игорь Лабутин" Нельзя так будет делать?
2383.02 2387.78 "Анатолий Кулаков" Ну, вот это очень сильно и много просили, но авторы вежливо об этом умолчали.
2387.78 2404.78 "Анатолий Кулаков" Т.е. насколько они комментировали, они сказали, что мы сделали все настолько гибко, что в будущее можно было добавить туда и конструкторы, и операторы, и какое-то даже наследование, и еще что-то, но в данном релизе будет ли это или не будет, они не уточнили.
2404.78 2408.22 "Анатолий Кулаков" В общем, скорее всего, такой платздарм для будущих улучшений.
2408.22 2413.34 "Игорь Лабутин" А может, они и двоеточие поэтому не завязали, сохранив его под будущее наследование?
2413.34 2416.14 "Анатолий Кулаков" Может быть, может быть, почему бы и нет.
2416.14 2419.50 "Игорь Лабутин" Хотя я не очень представляю, как это будет, двоеточие for?
2419.50 2428.50 "Анатолий Кулаков" Да-да, ну т.е. это будет двоеточие, ну не так, это будет for, от чего, а потом, наверное, двоеточие, ну т.е. ты как-то наследуешь все.
2428.50 2429.50 "Анатолий Кулаков" А, не знаю вообще.
2429.50 2430.50 "Анатолий Кулаков" Короче, непонятно, да.
2430.50 2431.50 "Игорь Лабутин" Давай посмотрим.
2431.50 2432.50 "Игорь Лабутин" Да-да.
2432.50 2433.50 "Игорь Лабутин" Ладно, будем ждать.
2433.50 2434.50 "Анатолий Кулаков" Давай дальше, что у нас еще есть?
2434.50 2438.30 "Анатолий Кулаков" Методы расширения с помощью наследования – это уже за гранью какой-то.
2438.30 2439.30 "Анатолий Кулаков" Что еще есть?
2439.30 2444.10 "Анатолий Кулаков" В принципе, еще парочку интересных фич добавили, тоже не помешает, не помешает нам.
2444.10 2466.86 "Анатолий Кулаков" Во-первых, опять же, начиная с .NET 2, как только появилось ключевое слово "парам", а мы помним, что ключевое слово "парам" позволяет вам писать в методе не просто передавать туда какую-то коллекцию, да, т.е. когда вы вызываете метод, у которого есть ключевое слово "парам", то ему можно не коллекцию передавать, а теперь учислить через запятую ваши элементы.
2466.86 2472.46 "Анатолий Кулаков" И компилятор их с помощью такой-то магии соберет в аррэй, и этот аррэй уже передастся вашему методу.
2472.46 2479.34 "Анатолий Кулаков" И вот это, чтобы компилятор понял, что ваше перечисление нужно сконвертировать в аррэй, существует ключевое слово "парам".
2479.34 2489.62 "Анатолий Кулаков" В принципе, нельзя сказать, что это киллер фича, да, ну т.е. это удобно, это иногда пригождается, но сказать, что это мега нужно, ну, не знаю.
2489.62 2495.30 "Анатолий Кулаков" Нечасто, нечасто я использовал это, и в тех местах, где я использовал, вполне бы пережил и без него.
2495.30 2512.98 "Анатолий Кулаков" Это немножко удобнее DSL-е писать, конечно, потому что синтакси становится чуть-чуть более приятным, особенно если мы вспоминаем, что недавно добавились вот эти collection expression, где все коллекции, чтобы передать их, достаточно обернуть просто в квадратные скобки, и поэтому "парам" все менее и менее актуален, да, т.е.
2512.98 2516.78 "Анатолий Кулаков" вы экономите на двухквадратных скобках, ну, допустим, почему бы и нет.
2516.78 2525.30 "Анатолий Кулаков" Но, опять же, популярное слово, часто используется, а потом его, как только ввели, люди сразу начали просить, почему у нас "парам" может быть только "рэем".
2525.30 2536.74 "Анатолий Кулаков" "Рэй" - это часто неудобно, это часто некрасиво, потому что он вообще какой-то мьютабельный, а когда ты передаешь параметры, ты не понимаешь, что там можно мьютить, поэтому люди стали просить "енумерабл".
2536.74 2547.62 "Анатолий Кулаков" Но так как это не критикал ни разу, эту песню всю отложили, и отложили вот до этого релиза, т.е., представляете, со второго "Дотнета" вот эта тема тянется.
2547.62 2561.94 "Анатолий Кулаков" И, наконец, разработчики достали, опять же, из долгого кармана, кажется, что у них есть какой-то карман, где они держат такие фичи, которые делать легко, все замучились, что их нет, и вот они вытаскивают, когда у них релиз какой-то слабенький, и они добавляют, догоняют.
2561.94 2564.34 "Анатолий Кулаков" Одна из этих фич, это как раз и вот было "парам".
2564.34 2567.34 "Анатолий Кулаков" Теперь, наконец-то, мы можем туда вставлять не только "рэи".
2567.34 2581.48 "Анатолий Кулаков" Прежде всего, что туда можно вставлять, это "енумераблы", что давно просили, это любые коллекции, любые листы, иммьютабл арреи, в общем, любая коллекция, которая вам может прийти на ум, в принципе, должна встать.
2581.48 2585.10 "Анатолий Кулаков" Но это все баловство, в принципе, можно было бы обойтись и так.
2585.10 2603.54 "Анатолий Кулаков" Самое главное, ну, т.е., практически полезное, если мы не говорим про какое-то эстетическое удовольствие, а про практическую пользу, самая главная практически полезная вещь в этом нововведении - это "систем спан", т.е., теперь вы можете вставить не массив каких-то элементов, а спан или даже "ридонли спан" каких-то элементов.
2603.54 2604.54 "Анатолий Кулаков" Почему это важно?
2604.54 2612.50 "Анатолий Кулаков" Потому что есть люди, которые загоняются перфомансом, и при этом люди, которые загоняются перфомансом, еще и хотят красивости.
2612.50 2614.90 "Анатолий Кулаков" Да, это вообще антонимы, конечно, но допустим.
2614.90 2620.98 "Анатолий Кулаков" Люди, которые загоняются перфомансом, хотят, чтобы у них метод вызывался через парамсы, чтобы красиво передавать им аргументики.
2620.98 2627.62 "Анатолий Кулаков" И вот эти люди вынуждены были эти парамсы игнорировать, потому что парамс аллоцировал раньше массив.
2627.62 2636.18 "Анатолий Кулаков" Когда мы говорим о перфомансе, аллоцирование массива, это просто камень себе на ноги, потому что нельзя такого делать.
2636.18 2641.26 "Анатолий Кулаков" Это очень затратная операция, страшная, и все профайлеры просто взорвутся сразу, как только ее увидят.
2641.26 2643.42 "Анатолий Кулаков" Поэтому какое раньше было хак-решение?
2643.42 2646.02 "Анатолий Кулаков" Вы просто-напросто делаете несколько оверайдов, т.е.
2646.02 2648.82 "Анатолий Кулаков" несколько методов с различным набором параметров.
2648.82 2651.70 "Анатолий Кулаков" Таким образом вы эмулируете парамс вручную.
2651.70 2659.94 "Анатолий Кулаков" Вы генерируете 10 методов, у первого метода один параметр, у второго два параметра, у третьего три параметра, у четырех четыре и т.д., и т.д.
2659.94 2662.42 "Анатолий Кулаков" Т.е. вот такая вот матрешка получалась.
2662.42 2667.54 "Анатолий Кулаков" Во многих перфоманс-библиотеках, например, в логгерах вы можете такой паттерн найти.
2667.54 2688.02 "Анатолий Кулаков" Теперь они могут выдохнуть и спать спокойно, потому что теперь есть спанат, который как минимум в два раза быстрее, чем аллокация массивов, ну, и неизвестно, правда, насколько он конкурирует с вот этим паттерном, когда вы вручную раскладываете это все по параметрам, но по идее автор утверждает, что где-то там на уровне, т.е. вполне можно заменить в каких-то моментах.
2688.02 2692.66 "Анатолий Кулаков" Тут без строгих бичмарков конкретного кейса невозможно сказать.
2692.66 2699.46 "Анатолий Кулаков" В общем, теперь есть у нас такая возможность поставлять по RAMS практически любую коллекцию, которая есть.
2699.46 2707.02 "Анатолий Кулаков" Более того, авторы пошли дальше и сделали возможность поставлять не только эти системные коллекции, которые у нас уже Microsoft сам задекларировал.
2707.02 2711.38 "Анатолий Кулаков" Компилятор умный, он может даже сделать по RAMS из вашего собственного типа.
2711.38 2724.38 "Анатолий Кулаков" Допустим, вы сделали там какой-то тип юзер-лист, и хотите этот юзер-лист получать к себе удобно через запятую, и чтобы это красиво у вас еще в коде выглядело.
2724.38 2725.38 "Анатолий Кулаков" Как это сделать?
2725.38 2726.38 "Анатолий Кулаков" Это очень просто.
2726.38 2729.30 "Анатолий Кулаков" Вам этот юзер-лист нужно выполнить два условия.
2729.30 2736.70 "Анатолий Кулаков" Во-первых, юзер-лист пронаследовать от i, и номер был от t, чтобы компилятор понимал, какое перечисление вы хотите заполучить.
2736.70 2743.58 "Анатолий Кулаков" И нужно, чтобы этот юзер-лист реализовал метод add, чтобы компилятор понимал, каким образом ему туда вам что-то добавить.
2743.58 2750.18 "Анатолий Кулаков" Поэтому, удовлетворив обоим этим условиям, вы можете создать такой класс, который удобно будет передаваться в по RAMS.
2750.18 2755.70 "Анатолий Кулаков" Тоже наверняка кому-нибудь нужно, особенно для красивых DSL-чиков, для красивых билдеров, вполне вероятно может пригодиться.
2755.70 2768.30 "Анатолий Кулаков" Другой интересный момент, который вытекает из этой фичи, в том, что Microsoft внутри себя, ну он тоже использовал по RAMS, не сказать, что слишком часто, но есть места, есть классы, которые тоже используют по RAMS.
2768.30 2771.58 "Анатолий Кулаков" И он внутри себя практически все эти классы переделал на span от t.
2771.58 2788.22 "Анатолий Кулаков" И компилятор, он умный, он понимает, что если, в принципе, есть две перегрузки у по RAMS, которые первая использует массивы, а вторая использует спаны, и вы передаете некие параметры, которые хорошо конвертируются в спаны, то есть их можно представить в виде спана, он будет использовать метод со спаном.
2788.22 2789.22 "Анатолий Кулаков" Что это значит?
2789.22 2806.30 "Анатолий Кулаков" Что как только вы обновитесь на новый фреймворк и просто-напросто перекомпилируете ваш код, то вполне вероятно, что перекомпилируя ваш код, который использует уже новые перегрузки со спаном, ваш новый метод в рантайме уже будет использовать перегрузку со спаном вместо старой перегрузки с array.
2806.30 2812.22 "Анатолий Кулаков" А это значит, что ваш код автоматически увеличится в перформансе, то есть у него улучшится перформанс.
2812.22 2820.90 "Анатолий Кулаков" Таким образом, это один из примеров, каким образом перекомпиляция под новый .NET фреймворк или под новый C# ленгвич может ускорить ваше приложение на пустом месте.
2820.90 2822.82 "Анатолий Кулаков" Вот благодаря вот таким вот оптимизациям, например.
2822.82 2823.82 "Игорь Лабутин" Да.
2823.82 2833.82 "Игорь Лабутин" Я еще про эту фичу хочу добавить, что, как Толя сказал, вы теперь в парамсах можете не только конкретную коллекцию, но туда можно, например, запихать iEnumerable или iList.
2833.82 2845.42 "Игорь Лабутин" И у внимательного слушателя возник вопрос, если у нас парамс iList, то какая реальная коллекция-то будет в методе внутри?
2845.42 2848.42 "Игорь Лабутин" Объект-то нужно какой-то создать, правда ведь?
2848.42 2850.22 "Игорь Лабутин" Да, да, все верно.
2850.22 2851.22 "Игорь Лабутин" Вот.
2851.22 2854.02 "Игорь Лабутин" И здесь как бы компилятор пошел довольно далеко.
2854.02 2867.38 "Игорь Лабутин" У них есть для каждого типа такого плюс-минус популярного интерфейса есть соответствующий тип, который будет создан, но я подозреваю, что для iList будет какой-нибудь iridom, какой-нибудь iridom-lylist или не знаю, просто list-t, наверное.
2867.38 2869.50 "Анатолий Кулаков" Скорее всего, для lista, да, будет просто list.
2869.50 2870.50 "Игорь Лабутин" Вот.
2870.50 2881.10 "Игорь Лабутин" Но там есть забавная заметка, что типа, но в некоторых случаях компилятор может посчитать, что выгоднее сгенерить кастомную коллекцию, реализующую этот интерфейс.
2881.10 2898.10 "Игорь Лабутин" То есть типа они на лету сгенерят какой-нибудь очередной класс с невыговариваемым именем, со служебным, который будет реализовывать интерфейс, который как бы у вас передан, и именно его передавать вам, поэтому типа предупреждение не закладывайтесь на то, какой тип к вам пришел.
2898.10 2903.42 "Игорь Лабутин" Если попросили iList, пользуйтесь только как iList, не надо его кастить в list и что-то с ним делать.
2903.42 2908.10 "Анатолий Кулаков" Да, интересно посмотреть бы на все вот эти их эвристики.
2908.10 2913.14 "Анатолий Кулаков" Понятно, что для каких-то примитивных случаев они очевидны, а вот для непримитивных, вот это интересно уже.
2913.14 2918.82 "Игорь Лабутин" Да-да, ну может кто-то и разберёт наверняка, я думаю, ждём статью от Эндрю Лока, я считаю.
2918.82 2919.82 "Анатолий Кулаков" Я думаю, да.
2919.82 2941.06 "Анатолий Кулаков" Ну и автор упоминает, что вот такая подобная эвристика, где мы передаём интерфейс, и каким-то образом компилятор должен догадываться, какой тип настоящий туда подставить, в общем-то этот механизм нашёл место в нескольких ещё местах, кроме Парамсов, то есть ещё где-то есть, поэтому в принципе, может быть и в других местах вы тоже его встретите.
2941.06 2948.78 "Игорь Лабутин" Но подозреваю, что в коллекшен-экспрессионах, когда ты передаёшь их в функцию, которая принимает интерфейс, надо же какую-то коллекцию создать.
2948.78 2951.54 "Анатолий Кулаков" В частности, да, безусловно.
2951.54 2960.66 "Анатолий Кулаков" Ещё один интересный нововведений, это манипуляции с field-кейвордом, то есть у нас появился ещё один новый ключевое слово, это field.
2960.66 2971.54 "Анатолий Кулаков" Мы уже тоже в каких-то ранних превью упоминали о том, что такая возможность рассматривается, и теперь кажется, что авторы намекают, что мы тоже её получим в нынешнем грядущем релизе C#.
2971.54 2973.66 "Анатолий Кулаков" Что же это такое?
2973.66 2976.22 "Анатолий Кулаков" Опять же, старая тема, автопроперти.
2976.22 2994.98 "Анатолий Кулаков" Автопроперти появились тоже там как с какого-то дотнета, чуть ли не первого, и в автопропертях всегда было всё хорошо до тех пор, пока вы не хотите его немножко изменить, это проперти, например, потримать или проверить на входе, или выдать какой-нибудь модифицированный результат, а не просто чистый value, который к вам приходил.
2994.98 3013.98 "Анатолий Кулаков" И вот как только вы этого хотите, вы попадаете в ловушку, что вам нужно теперь автопроперти превратить в обычный проперти с бэкингфилдом, к этому бэкингфилду как-то обращаться, каким-то образом его хранить, и в общем, код превращался из одной маленькой строчки, превращался легко в пяток больших строчек.
3013.98 3017.90 "Игорь Лабутин" А также ещё возникала проблема, с которой я лично сталкивался.
3017.90 3022.66 "Игорь Лабутин" Как только у тебя есть бэкингфилд и саму проперти, возникает вопрос, а изнутри класса что использовать?
3022.66 3024.74 "Игорь Лабутин" Ну да, в принципе, тоже неочередный ответ.
3024.74 3029.22 "Игорь Лабутин" То ли get, где у вас, возможно, есть какая-то логика специальная, то ли field.
3029.22 3040.58 "Игорь Лабутин" И в общем, когда всякие find usages и прочее, вот это начинается, ищешь usage филда, а потом выясняешь, что он из проперти, ищешь usage проперти, ну в общем, прям неудобненько.
3040.58 3049.38 "Анатолий Кулаков" Ну и к какому-то единому подходу там всегда используем проперти или филд, договориться невозможно, потому что ответ на этот вопрос зависит от того, что там внутри творится этой проперти.
3049.38 3056.36 "Анатолий Кулаков" Может, он там внутри себя каждый раз генерирует огромные массивы и перекладывает данные, в общем, и зачем каждый раз его дёргать через проперти, непонятно.
3056.36 3060.70 "Анатолий Кулаков" Да, вот были такие проблемы.
3060.70 3075.02 "Анатолий Кулаков" Вот эти проблемы, в принципе, люди пытались решить, просив Микрософта сделать вот что-то среднее между автопроперти и проперти с backing field, то есть немножко, чтобы было больше сахара, но при этом не заводите ручками какое-то backing field свойство.
3075.02 3080.46 "Анатолий Кулаков" В общем, Микрософт откладывал эту штуку, потому что он старался наоборот, он старался улучшить автопроперти.
3080.46 3102.42 "Анатолий Кулаков" Например, он сделал возможность делать get-only проперти, которые доступны только на чтение, например, он добавил возможность инициализации свойств, чтобы можно было сразу задать какое-то значение, он сделал возможность указывать свойства сразу там лямбду, чтобы получать какой-то expression, а не просто обычный value, который туда положили.
3102.42 3110.74 "Анатолий Кулаков" В общем, пытался вот какие-то самые частые методы использования как-то обобщить и сделать к ним дополнительный синтаксис, и у него это нормально получалось.
3110.74 3121.46 "Анатолий Кулаков" Но, видимо, всё, обобщения кончились, синтаксисы кончились, и теперь всё-таки вернулись обратно, а что же делать, когда нам чуть-чуть хочется на get и чуть-чуть хочется на set, а при этом backing field заводить не хочется.
3121.46 3125.06 "Анатолий Кулаков" И вот предложили завести такое ключевое слово, которое называется field.
3125.06 3133.38 "Анатолий Кулаков" Это ключевое слово, которое, по сути, ссылается на тот backing field, который будет сгенерирован компилятором.
3133.38 3144.98 "Анатолий Кулаков" Естественно, с таким названием поле у вас по-настоящему сгенерировано не будет, но в тех местах, где вы используете ключевое слово field, туда компилятор подставит тот backing field, который он будет компилировать, который он будет генерировать.
3144.98 3158.82 "Анатолий Кулаков" А нужно помнить, что к любому автопроперти после компиляции у вас всегда будет сгенерированный backing field, т.е. магии никакой нет, это всего лишь синтаксический сахар, свойства могут обращаться только к backing field, поэтому он обязательно будет.
3158.82 3163.54 "Анатолий Кулаков" И именно к этому backing field вы теперь можете обращаться с помощью ключевого слова field.
3163.54 3164.54 "Анатолий Кулаков" Для чего это нужно?
3164.54 3172.30 "Анатолий Кулаков" Ну, например, когда вы сетите, допустим, какое-то значение, т.е. имя, вы его хотите затримить, прежде чем засетить ваше backing field.
3172.30 3188.06 "Анатолий Кулаков" Для этого вам нужно написать сеттер, в который вы будете делать field = value.trim, т.е. мы используем ключевое слово value для того, чтобы входящее значение обозначить и ключевое слово field для того, чтобы обозначить backing field, между ними можно творить любую магию.
3188.06 3197.14 "Анатолий Кулаков" Точно так же на get, мы в get можем передать лямбду, которая, допустим, сделаем field.trim, таким образом мы не просто значение возьмем, которое у нас хранится, а при этом его затримем.
3197.14 3200.86 "Анатолий Кулаков" Вот такой хороший синтаксис.
3200.86 3203.94 "Анатолий Кулаков" Все бы в этом синтаксисе прекрасно, но кроме одного.
3203.94 3204.94 "Анатолий Кулаков" Что это?
3204.94 3205.94 "Анатолий Кулаков" Breaking change на самом деле.
3205.94 3206.94 "Анатолий Кулаков" Изменение.
3206.94 3208.58 "Анатолий Кулаков" Казалось бы, какой тут может быть breaking change.
3208.58 3209.98 "Анатолий Кулаков" А очень простое.
3209.98 3220.46 "Анатолий Кулаков" Существует определенная каста людей, которая вполне могла бы назвать внутри класса поле именем field.
3220.46 3224.46 "Анатолий Кулаков" И если она так сделает, то у компилятора появляется неоднозначность.
3224.46 3225.62 "Анатолий Кулаков" А что польский хотел сказать?
3225.62 3229.78 "Анатолий Кулаков" Он в это поле хотел записать значение или он обратился к ключевому слову field?
3229.78 3231.14 "Анатолий Кулаков" Что нам делать-то?
3231.14 3234.10 "Анатолий Кулаков" И вот в этом и заключается, грубо говоря, breaking change.
3234.10 3242.78 "Анатолий Кулаков" В новых версиях языка мы будем интерпретировать это название как ключевое слово.
3242.78 3249.70 "Анатолий Кулаков" Если ваш код использовал имя, поле, которое называется field, он, в принципе, сломается.
3249.70 3257.58 "Анатолий Кулаков" Вот чтобы он не сломался, Microsoft применили первый раз вот этот хак с упоряждающим компилятором.
3257.58 3260.10 "Анатолий Кулаков" Мы тоже его уже обсуждали в наших выпусках подробнее.
3260.10 3261.10 "Анатолий Кулаков" Кратко напомню.
3261.10 3281.86 "Анатолий Кулаков" Когда вы будете компилировать новым компилятором ваш старый код, который нацелен на старую версию языка C#, компилятор выдаст вам предупреждение, что человек, мой дорогой, смотри, ты сейчас здесь используешь поле, которое называется field, а в новой версии языка, в C# 13, мы это ключевое слово заиспользовали с таким же точным именем.
3281.86 3285.34 "Анатолий Кулаков" И твой код может работать уже не так, как мы рассчитываем.
3285.34 3286.34 "Анатолий Кулаков" Не так, как ты рассчитываешь.
3286.34 3295.10 "Анатолий Кулаков" Поэтому, если ты сейчас бы это поле поправил, как-нибудь его переименовал, то миграция на будущую версию языка у тебя прошла бы более бесшовной.
3295.10 3298.50 "Анатолий Кулаков" Вот такие варнинги компилятор уже будет выдавать.
3298.50 3303.82 "Анатолий Кулаков" Поэтому, если вы компилируете, обязательно обращайте внимание на то, какие варнинги у вас там появляются.
3303.82 3308.78 "Анатолий Кулаков" Если вчера их не было, то сегодня они могут быть, потому что Microsoft вводит новое ключевое слово.
3308.78 3313.02 "Анатолий Кулаков" Здесь интересно в том, что эту технику мы уже обсуждали, как я уже сказал.
3313.02 3316.30 "Анатолий Кулаков" Интересно, что Microsoft его первый раз применяет на основании вот этого примера.
3316.30 3323.30 "Анатолий Кулаков" Я думаю, что он, может быть, даже этот пример специально завел для того, чтобы у него был шанс проверить, как вообще весь этот подход работает.
3323.30 3340.22 "Игорь Лабутин" Да-да-да, на самом деле мы про это говорили, и Мэтт Сторгерсон, автор языка, как раз говорил то ли в статье, то ли в видео, где он объяснял эту технику с тем, как они будут теперь пытаться деприкейтить какие-то старые фичи языка вот таким ингрементным образом.
3340.22 3342.78 "Игорь Лабутин" И он как раз прям явно говорил, что аннуфилдем и проверим.
3342.78 3350.70 "Анатолий Кулаков" Ну да, может, они специально такую мелкую фичу и придерживали для того, чтобы как-нибудь, мало ли, ее проверить.
3350.70 3357.10 "Анатолий Кулаков" Вот, в принципе, такие вещи в C# 13 будут, которых у нас еще нет, но хотя бы хорошо, что они будут.
3357.10 3363.42 "Анатолий Кулаков" То есть здесь уже больше шансов, что если авторы пообещали, то, значит, они хотя бы над этим работают и хотя бы к релизу они это доделают.
3363.42 3364.42 "Игорь Лабутин" Да.
3364.42 3366.42 "Игорь Лабутин" А мы пойдем дальше.
3366.42 3376.74 "Игорь Лабутин" На самом деле довольно много вот этих всех анонсов произошли благодаря конференции Microsoft Build, и она довольно широкопрофильна, как я уже сказал.
3376.74 3388.14 "Игорь Лабутин" Она довольно охватывает большое количество всяких разных Microsoft технологий, начиная от железа, ажура и всего остального, но там есть часть, была часть и про .NET.
3388.14 3400.18 "Игорь Лабутин" Если вам интересно все остальное, посмотрите, просто есть там плейлисты Build, но вот у нас есть две статьи, которые как раз описывают, что же важного произошло в .NET.
3400.18 3416.70 "Игорь Лабутин" Первая статья это про то, что важного было заанонсировано в .NET для, на Build для .NET, и первым пунктом, конечно же, идет .NET для AI, для искусственного интеллекта.
3416.70 3421.94 "Игорь Лабутин" Тут есть штука под названием "новый тип", именно "тензор от Т".
3421.94 3434.22 "Игорь Лабутин" Ну это, понятно, тензоры, да, многомерные массивы, матрицы, в частном случае тензоров, вот это все нужны для всяких разных вычислений в области нейронных сетей и прочего.
3434.22 3444.34 "Игорь Лабутин" .NET пытается, по крайней мере, в эту область как-то залезать хотя бы, может быть не для построения сетей, но хотя бы для эффективного использования нейронных сетей.
3444.34 3450.66 "Игорь Лабутин" Так что, если вы как-то с этим работаете, то вот тензор от Т, возможно, чем-то пригодится.
3450.66 3467.46 "Игорь Лабутин" Также в разделе искусственного интеллекта был указан упомянутый Smart Components для Blazor, про который мы говорили, это когда вы делаете вставку в форму со Smart Компонентами какой-то информации из клеймборда, она сама распределяет там, где адрес, где имя, где там телефон и так далее.
3467.46 3492.58 "Игорь Лабутин" Ну и Semantic Kernel, это такая центральная часть всего этого добра с точки зрения работы с искусственным интеллектом, это некоторое SDK, которое позволяет вам собирать в вашем приложении нечто похожее на то, как Microsoft у себя собирает Copilot, ну в смысле использовать нейронные сетки внутри вашего приложения для того, чтобы использовать универсально любые, ну практически любые это, сетки, вот как раз Semantic Kernel можно поиспользовать.
3492.58 3495.94 "Игорь Лабутин" Это то, что касается .NET и искусственного интеллекта.
3495.94 3516.78 "Игорь Лабутин" Дальше был раздел про Cloud Native, ну тут, понятно, Aspire, тут Chiseled Container, про которые мы говорили, по-моему, пару или тройку выпусков назад, включая тот факт, что Canonical и Red Hat перешли на свои собственные сборки и теперь поставляют .NET, сами собирают для своих дистрибутивов, для своих репозиториев пакетов.
3516.78 3537.58 "Игорь Лабутин" Ну и то, что в девятке, похоже, будет включен по умолчанию вот этот Dynamically Adaptable to Application Sites режим для Garbage Коллектора, который позволяет автоматом подбирать количество куч в серверном режиме сборщика мусора и тем самым уменьшать memory usage, ну посмотрим.
3537.58 3543.26 "Игорь Лабутин" О C# 13 Толя уже сказал, отдельная секция была, но мы ее подробно осветили.
3543.26 3553.62 "Игорь Лабутин" В Web Development мы еще чуть-чуть коснемся чуть дальше при обсуждении .NET 9 Preview 4, который вышел примерно одновременно с конференцией.
3553.62 3559.14 "Игорь Лабутин" Ну и в разделе Multiplatform почти вся информация была про MAUI.
3559.14 3569.26 "Игорь Лабутин" Во-первых, наверное, это был первый случай, когда я увидел в статье Microsoft список приложений, которые написаны на MAUI.
3569.26 3573.06 "Анатолий Кулаков" Ну и как, там есть что-то хотя бы приличное?
3573.06 3582.02 "Игорь Лабутин" Ну давай так, там в основном, наверное, это конечно специфично для американского рынка, но там NBC Sports, Hawaiian Airlines,
3582.02 3583.02 "Анатолий Кулаков" UPS.
3583.02 3595.54 "Анатолий Кулаков" Слушай, мне кажется, вот когда они, знаешь, только запускали там WinForms, только запускали и UVP, только запускали до PF, вот те же самые приложения с теми же самыми спонсорами они тоже выпускали и всем показывали, смотрите, как красиво.
3595.54 3597.54 "Анатолий Кулаков" Скорее всего, там какие-то дежурные контракты у них есть, знаешь?
3597.54 3598.54 "Анатолий Кулаков" Ну возможно, возможно.
3598.54 3600.18 "Анатолий Кулаков" Которые переписываются по договоренности.
3600.18 3601.18 "Игорь Лабутин" Ну хотя бы что-то.
3601.18 3606.54 "Игорь Лабутин" То есть, ну хоть какие-то имена, то есть, хоть какие-то приложения, которые можно пощупать.
3606.54 3620.82 "Игорь Лабутин" Ну, кстати, Microsoft Azure, не знаю, что там за приложение Microsoft Azure, и насколько оно там мобильное, не мобильное, кроссплатформенное, не кроссплатформенное, но тем не менее, ну, веб-версию я знаю, а вот насколько оно там, не знаю, в мобильной версии никогда не смотрел.
3620.82 3623.38 "Анатолий Кулаков" Ну, CLI у них там еще есть нормальное какое-то приложение.
3623.38 3625.58 "Анатолий Кулаков" Не, ну CLI, это без Maui, вот.
3625.58 3628.06 "Анатолий Кулаков" Да, веб по-твоему, что с Maui, что ли?
3628.06 3629.06 "Анатолий Кулаков" Ну, веб может.
3629.06 3633.54 "Анатолий Кулаков" Ну, то есть, да, я не знаю, я не видел действительно у Azure какое-то такое приложение.
3633.54 3634.54 "Игорь Лабутин" Вот.
3634.54 3635.54 "Игорь Лабутин" Ну, в общем, поглядим.
3635.54 3647.34 "Игорь Лабутин" С точки зрения планов, они говорили, ну вот, мы там были, значит, всячески фокусировались на перформансе, стабилизации, вот это все, мы продолжим наш, значит, путь к этим светлым целям.
3647.34 3664.22 "Игорь Лабутин" У них какие-то чуть более конкретные цели с точки зрения Android и iOS, потому что кажется, что сейчас там есть некоторые моменты то ли несовместимости, то ли неполной поддержки, поэтому основной фокус, я так понимаю, продолжение фикса всех багов и латания дыр.
3664.22 3667.94 "Игорь Лабутин" Ну и вот Android и iOS какие-то там изменения, улучшения будут.
3667.94 3673.26 "Игорь Лабутин" Ну, в общем-то, и все про Maui, то есть каких-то прям сурового, большого roadmap опять же нету.
3673.26 3678.54 "Игорь Лабутин" Очень жалко, очень жалко, да, непонятно, что с ним происходит.
3678.54 3683.58 "Игорь Лабутин" Хотя, с другой стороны, Android и iOS, в принципе, это большой и суровый roadmap, так-то, но платформы непростые,
3683.58 3684.58 "Анатолий Кулаков" да.
3684.58 3690.66 "Анатолий Кулаков" Было бы хорошо, если бы они заявили, вот смотрите, у нас здесь вот такие проблемы, мы будем двигаться туда, вот здесь у нас, вот этого ожидайте.
3690.66 3699.02 "Анатолий Кулаков" Потому что сейчас, когда ко мне приходят люди и спрашивают, а на чем писать кросс-платформенный UI, я, к сожалению, ни в каком из случаев не могу посоветовать Maui.
3699.02 3712.54 "Анатолий Кулаков" Прежде всего потому, что непонятно, как бы этот проект не похож на развивающийся, он больше похож на умирающий, но при этом Microsoft со всех столбов кричит, что нет-нет-нет, мы его развиваем, мы активным занимаемся, мы его бросать не будем.
3712.54 3721.70 "Анатолий Кулаков" В общем, с вот такой судьбой непонятно, как людям оперировать там хотя бы на 5 лет вперёд, что с этим проектом дальше будет.
3721.70 3736.10 "Анатолий Кулаков" Поэтому очень плохая, знаешь, вот эта вот его политика, отсутствие нормального, меняемого roadmap-а, меняемых обновлений хороших, каких-то девелопер-адвокатов, они играют с ним в злую шутку, то есть им меньше и меньше начинают пользоваться.
3736.10 3737.22 "Анатолий Кулаков" А от этого он больше и больше умирает.
3737.22 3744.10 "Игорь Лабутин" Это правда, ну, будем посмотреть, может быть, к осени что-то появится.
3744.10 3747.82 "Игорь Лабутин" Не знаю, должны же они осенью что-то будут сказать, отлично от того, что говорят сейчас.
3747.82 3757.86 "Анатолий Кулаков" Ну, не знаю, насколько должны, потому что это не мешает им один и тот же release notes выпускать каждый раз, про improvements рассказывать надо, поэтому, может, и не должны.
3757.86 3767.10 "Анатолий Кулаков" Может быть, знаешь, они готовят вот этот Android и iOS, готовят к такому состоянию, чтобы осенью как бахнуть, а потом пойти быстро везде маркетинг делать по этому поводу.
3767.10 3768.10 "Анатолий Кулаков" Может быть.
3768.10 3769.10 "Анатолий Кулаков" Со всех сторон.
3769.10 3770.10 "Анатолий Кулаков" Может быть.
3770.10 3778.30 "Анатолий Кулаков" Ну, пожелаем удачи, потому что кроссплатформенный UI нам нужен, желательно, конечно, чтобы он был от Microsoft, потому что все любят микрософтовский UI.
3778.30 3781.14 "Анатолий Кулаков" Ну, или просто, чтобы было несколько, чтобы была конкуренция.
3781.14 3801.86 "Анатолий Кулаков" Ну, или чтобы была конкуренция, да, потому что, по-моему, UI – это единственное поле, на которое, знаешь, на которое не бегут люди на Microsoft, потому что обычно, если тебе говоришь, вот, Microsoft выпустил дашборд, всё, бросают все графа, напишут, бегут на Aspire, да, если тебе говоришь, Microsoft выпустил UI, ну, нет, давайте посмотрим, там, может, Avalon'я получше-то как-то будет и тому подобное.
3801.86 3806.06 "Анатолий Кулаков" То есть, пока это единственное поле, где Microsoft вот явно проигрывает всем остальным конкурентам.
3806.06 3808.66 "Игорь Лабутин" Хотя раньше, можно сказать, выигрывал.
3808.66 3821.34 "Игорь Лабутин" Ну, Windows Only, вот это всё, но все как бы переживали, что блин, почему WPF-то Windows Only, было бы прикольно, если бы он был кроссплатформен, ну, вот, появилась Avalon'я, да.
3821.34 3831.06 "Игорь Лабутин" Ну, ладно, давай дальше, дальше у нас более живая часть майкрософтовского девелопмента, так скажем, это DotNet 9 Preview 4.
3831.06 3836.86 "Анатолий Кулаков" Наконец-то вышло новое превью, и, в принципе, здесь тоже есть какие-то мелочи, которые хочется светить.
3836.86 3860.78 "Анатолий Кулаков" Начнём, прежде всего, с ASP.NET Core, в ASP.NET Core, мы уже упоминали, что Microsoft позарился на святое, он хочет в девятом ДотНете вырезать интеграцию с фаггером, со свэш-баклом, то есть, в частности, да, и причины были в предыдущих выпусках, об этом подробнее, если хотите, читайте там, сейчас мы рассмотрим, а что же, собственно, он предлагает замену.
3860.78 3896.30 "Анатолий Кулаков" Да, и предлагает замену он своей классике, свою иерархию, свою инфраструктуру, которая реализует OpenAPI-спецификацию, сваггер и OpenAPI – это одно и то же, то есть свою сваггер, по сути, спецификацию, сваггер классики, для того, чтобы описывать HTTP API, которые мы все с вами любим, мы все с вами пишем каждый день, наверняка, в общем, и их нужно как-то описывать, для этого есть формат, он же OpenAPI, он же сваггер, и Microsoft наделала своих собственных классиков для того, чтобы теперь что-то с этими форматами делать, а делать они с ним могут теперь много чего.
3896.30 3910.26 "Анатолий Кулаков" Прежде всего, эта спецификация OpenAPI, она будет описывать и control-based ваши API-шки, такие, так называемые, старые, и minimal API, так называемые, хипстерские, в общем, и там, и там она применима.
3910.26 3946.42 "Анатолий Кулаков" Все классики схоронились в отдельном пакете, который Microsoft назвал Microsoft ISP NetCore OpenAPI, и для того, чтобы вам заиспользовать эти новые классики, вам нужно будет сделать два простых шага – в программ.cs, как и положено со всеми остальными там интеграциями, вы должны сделать addOpenAPI для того, чтобы зарегистрировать все необходимые сервисы и классики в вашем DI-контейнере, и вызвать класс mapOpenAPI для того, чтобы зарезервировать и замапить все endpoints, с помощью которых ISP Net будет сообщать саму спецификацию OpenAPI.
3946.42 3955.46 "Анатолий Кулаков" И, соответственно, чтобы сообщать, вам нужно будет запустить ваше приложение и пройти на url, который называется openapi/v1.json.
3955.46 3965.14 "Анатолий Кулаков" То есть помнишь, я в прошлый раз упрекал, что все урлы, которые называются Swagger, должны отдавать Swagger документ?
3965.14 3967.30 "Анатолий Кулаков" Вот Microsoft меня теперь тоже обломал.
3967.30 3970.38 "Анатолий Кулаков" Теперь не все урлы на Swagger будут отдавать Swagger документы.
3970.38 3974.02 "Анатолий Кулаков" Теперь мы еще должны учитывать openapi/v1.json.
3974.02 3983.60 "Анатолий Кулаков" Так вот, если вы зайдете по этому адресу, то вы получите, как ни удивительно, json-документ, который в сыром виде описывает вам полную Swagger спецификацию.
3983.60 3999.42 "Анатолий Кулаков" Также мы уже рассказывали, каким образом сгенерить Swagger спецификацию в build-тайме, т.е. как в run-тайме по этому урлу получить Swagger документ – понятно, но мы еще этот Swagger документ можем сгенерить в момент сборки вашего приложения.
3999.42 4019.38 "Анатолий Кулаков" Это тоже часто бывает нужно, например, для всяких статических анализов, для прегенерации HTTP-клайентов, для фиксирования breaking changes в вашем API, в общем, очень много пакетов, очень много инструментов, которые позволяют вам делать прекрасные вещи, которые спасают вас каждый день на основе сгенеренного уже json-документа.
4019.38 4023.26 "Анатолий Кулаков" Он тоже никуда не девается, т.е. все это остается с вами.
4023.26 4037.30 "Анатолий Кулаков" Еще этот новый API, новый OpenAPI классики поддерживает уже авторизацию, поддерживает различные трансформаторы, которые позволяют вам преобразовывать вот это синтаксическое дерево и добавлять в него какие-то дополнительные конструкции.
4037.30 4046.30 "Анатолий Кулаков" Также точно вы можете использовать Swagger UI, т.е. тот интерфейс, который у нас был с flash-баклом обычно по дефолту, он никуда не девается.
4046.30 4052.54 "Анатолий Кулаков" Это отдельная репозитория, отдельная библиотека, которой достаточно всего лишь на все получить файлик с json-спецификацией.
4052.54 4062.10 "Анатолий Кулаков" И как мы с вами срассмотрели, такой файлик у нас есть, он никуда не делся, поэтому главное его в Swagger UI подсунуть и вы увидите прежде тот же прежний UI.
4062.10 4071.30 "Анатолий Кулаков" Кроме Swagger UI, к которому уже все привыкли, Microsoft показала нам еще какие-то интерфейсы для вашего Swagger.
4071.30 4077.30 "Анатолий Кулаков" Прежде всего это Redock и второй интересный интерфейс это Scalar.
4077.30 4082.86 "Анатолий Кулаков" В принципе очевидно, что такие интерфейсы должны были быть, кроме Swagger UI, но я почему-то никогда их не искал.
4082.86 4084.94 "Анатолий Кулаков" Может быть потому, что Swagger UI мне полностью хватало.
4084.94 4091.62 "Анатолий Кулаков" Очень такой функциональный, хороший, удобный, да и к тому же все тестеры и все остальные разработчики к нему уже привыкли.
4091.62 4094.70 "Анатолий Кулаков" Вставлять какой-то новый интерфейс может быть не настолько практично.
4094.70 4099.24 "Анатолий Кулаков" Но взглянуть стоит, поэтому если вы ни разу не видели Redock и Scalar, то посмотрите.
4099.24 4102.94 "Анатолий Кулаков" Функциональности на первый взгляд кажется у них меньше, но зато они берут чем-то другим.
4102.94 4106.74 "Анатолий Кулаков" Они красиво, например, оформляют документацию, хорошо структурируют ссылки.
4106.74 4122.54 "Анатолий Кулаков" То есть если вы хотите делать, например, полноценный сайт с живой API документацией и с генерацией, допустим, клиентов на 200 языков по одной кнопочке, то вполне вероятно, что другие альтернативы вам больше понравятся, чем Swagger UI.
4122.54 4125.70 "Анатолий Кулаков" Поэтому можно пройти в статью по ссылочке и посмотреть на вот эти альтернативы.
4125.70 4127.66 "Анатолий Кулаков" Вполне нормально, вполне нормально.
4127.66 4130.70 "Анатолий Кулаков" Непривычно с первого взгляда, но зато функциональность берет.
4130.70 4135.70 "Анатолий Кулаков" Еще интересный инструмент, который я нашел в статье, это Spectral.
4135.70 4145.54 "Анатолий Кулаков" Spectral - это специальная тулза для того, чтобы проверять стайл-гайд вашего HTTP API, и также линтеры, которые указывают вам на какие-то бестпрактисы.
4145.54 4148.94 "Анатолий Кулаков" Вот это тоже та штука, которой мне, в принципе, давно не хватало.
4148.94 4159.94 "Анатолий Кулаков" Я уже стою на грани написать свою, но, естественно, нужно прежде всего поискать уже существующие, потому что разработчиков много, команд много, проектов много, и все начинают HTTP API писать как-нибудь по-своему.
4159.94 4167.22 "Анатолий Кулаков" Несмотря на то, что в компании обычно фиксируется какой-то гайдлайн, но за его соблюдением следить может быть проблематично.
4167.22 4174.86 "Анатолий Кулаков" Может быть, опять же, глаз размыливается, когда у тебя по тысяче API-ов каждый день проходит, то никто сильно вспоминать не будет на каких-то мелочах.
4174.86 4180.02 "Анатолий Кулаков" Поэтому автоматизация стайл-гайда по HTTP API, это, кажется, наше все.
4180.02 4183.06 "Анатолий Кулаков" И вот в этот инструмент я тоже обязательно закопаюсь и посмотрю.
4183.06 4186.50 "Анатолий Кулаков" Так, это про новинки, что у нас ISP было.
4186.50 4193.30 "Анатолий Кулаков" Давайте теперь еще посмотрим, еще хороший классик у нас появился, новый, интересный, называется он Гибрид Кэш.
4193.30 4198.06 "Анатолий Кулаков" Гибрид Кэш – это своеобразная такая мостик между Distributed Кэшем и In-Memory Кэшем.
4198.06 4201.98 "Анатолий Кулаков" Я напомню, у нас есть два таких классика, да, In-Memory Кэша.
4201.98 4204.82 "Анатолий Кулаков" Очевидно, по названию все данные, которые вы в него засовываете, хранит в памяти.
4204.82 4210.54 "Анатолий Кулаков" Самым примитивным образом можно его представить в виде дикшенери, но он намного умнее, намного сложнее.
4210.54 4216.38 "Анатолий Кулаков" У него есть различные политики, retention policy, которые позволяют чистить этот так называемый дикшенери.
4216.38 4219.66 "Анатолий Кулаков" Вы можете чистить его по какому-то времени, например, через 30 минут.
4219.66 4226.74 "Анатолий Кулаков" Можете чистить по slice time, например, те элементы, к которым чаще обращаются, они будут находиться в кэше.
4226.74 4229.58 "Анатолий Кулаков" Те к элементам, к которым я, допустим, целый день не обращался, их из кэша нужно выбрасывать.
4229.58 4233.74 "Анатолий Кулаков" Он может чиститься в зависимости от, например, занимаемой памяти.
4233.74 4236.38 "Анатолий Кулаков" Если в машине не хватает памяти, то он может очищаться.
4236.38 4247.98 "Анатолий Кулаков" В общем, много всего такого умного он имеет, к сожалению, даже слишком умного иногда он умеет, так что его умные кэши иногда хочется очень выключить, но, к сожалению, рубильника не хватает.
4247.98 4248.98 "Анатолий Кулаков" Но речь не об этом.
4248.98 4250.26 "Анатолий Кулаков" В общем, есть у нас такой in-memory кэш.
4250.26 4251.26 "Анатолий Кулаков" Хороший класс.
4251.26 4255.58 "Анатолий Кулаков" В принципе, если вы хотите делать in-memory кэш в вашем приложении, обязательно первым делом посмотрите на него.
4255.58 4257.18 "Анатолий Кулаков" В принципе, без каких-то особых нареканий.
4257.18 4265.18 "Анатолий Кулаков" И второй есть и distributed кэш, потому что в наше время распределенных приложений как-то наивно полагаться только на in-memory кэш.
4265.18 4272.58 "Анатолий Кулаков" Обычно, если вы хотите что-то такое глобально закэшировать, какой-то или сложный отчет, или токены, которые не должны часто создаваться.
4272.58 4276.98 "Анатолий Кулаков" В общем, какой-то ресурс, который вы не хотите часто создаваться, создавать по той или иной причине.
4276.98 4284.54 "Анатолий Кулаков" Который занимает процессовом времени или обычной памяти, или еще чего-то.
4284.54 4285.54 "Анатолий Кулаков" Часто его хотят закэшировать.
4285.54 4289.58 "Анатолий Кулаков" И чтобы закэшировать что-то не на одном инстансе, т.е.
4289.58 4296.98 "Анатолий Кулаков" по сути, не in-memory, не в одном процессе, а между различными инстансами, между различными процессами, используют distributed кэш.
4296.98 4298.70 "Анатолий Кулаков" Тоже прекрасная абстракция.
4298.70 4304.94 "Анатолий Кулаков" На нее уже есть куча адаптеров и в Redis, и в memcached, и в msql, куда только не кэшируют.
4304.94 4310.34 "Анатолий Кулаков" В общем, вот два таких прекрасных интерфейса есть.
4310.34 4313.74 "Анатолий Кулаков" Но между ними часто хочется иметь что-то среднее.
4313.74 4322.18 "Анатолий Кулаков" Например, хочется, чтобы элементы, которые очень часто затребуются, они хранились в in-memory кэше.
4322.18 4326.38 "Анатолий Кулаков" Прям на горяченький, в этом же приложении, в этом же процессе.
4326.38 4333.58 "Анатолий Кулаков" Элементы, которые редко затребуются, но при этом все еще так же важны, т.е. не хочется их перестраивать, их можно скипнуть в distributed кэш.
4333.58 4339.76 "Анатолий Кулаков" Мы можем потратить какие-то миллисекунды, чтобы на него всходить, но перестраивать снова этот ресурс не очень хочется.
4339.76 4344.50 "Анатолий Кулаков" И хочется, чтобы это само работало, само жонглировалось, само контролировалось.
4344.50 4348.34 "Анатолий Кулаков" И вот именно вот это вам и дают гибрид кэш.
4348.34 4353.94 "Анатолий Кулаков" Гибрид кэш внутри себя сочетает несколько сториджей кэшей.
4353.94 4366.86 "Анатолий Кулаков" Он использует in-process кэш для того, чтобы доступаться к наиболее часто запрашиваемым элементам, и он использует out-of-process, он же distributed кэш, для того, чтобы обращаться к тем элементам, которые запрашиваются реже.
4366.86 4373.86 "Анатолий Кулаков" Кроме того, что он внутри себя скрывает вот эту магию кэширования, он еще немножко упрощает синтексис.
4373.86 4378.86 "Анатолий Кулаков" Ну давайте вспомним, каким образом мы делали свой кэш раньше на основе distributed кэша.
4378.86 4380.06 "Анатолий Кулаков" Что нам нужно было сделать?
4380.06 4394.88 "Анатолий Кулаков" Во-первых, мы должны были сделать get-async, т.е. запросить закэшированный элемент, проверить, что если этот элемент был равен null, это значит, что у нас произошел кэш-мисс, и мы должны запустить операцию создания нашего ресурса.
4394.88 4405.34 "Анатолий Кулаков" Здесь мы запускаем длительное создание ресурсов, потом этот ресурс должны сериализовать во что-то, что умеет передаваться по сети, потому что distributed кэш, он уходит в сеть, обычно хранит именно там.
4405.34 4414.70 "Анатолий Кулаков" Мы должны были сериализовать в байты, и, наконец, вызвать set-async для того, чтобы сохранить это где-то в далеком distributed кэше.
4414.70 4422.38 "Анатолий Кулаков" И, иначе, если у нас все-таки был не кэш-мисс, а мы нашли элемент из кэша, мы можем десериализовать наш элемент и дальше уже с ним как-то работать.
4422.38 4439.02 "Анатолий Кулаков" В общем, алгоритм нехитрый, естественно, довольно очевидный, но строк занимает много, часто повторяется, и многие пишут extension методы, что как-то его сократить, потому что там практически все очевидно, все одинаково практически для любого типа, никакого смысла это повторять в каждом классе нет.
4439.02 4450.94 "Анатолий Кулаков" И вот, чтобы вам не писать больше extension методы, у гибрид кэша уже есть метод, который называется getOrCreate, который в самом простом случае принимает просто-напросто два аргумента, два параметра.
4450.94 4459.90 "Анатолий Кулаков" Во-первых, это ключ, под которым мы должны этот элемент поискать или создать, и, во-вторых, это фабрика, которая создает нам этот элемент.
4459.90 4463.06 "Анатолий Кулаков" То есть, вот это самая долгая операция, которая там должна происходить.
4463.06 4472.86 "Анатолий Кулаков" Все остальное под капотом он делает сам, он достает, смотрит кэш-миссы, сериализует, десериализует, в общем, делает все, что вы хотите.
4472.86 4481.06 "Анатолий Кулаков" Естественно, сериализаторы, с помощью которых он это все делает, они настраиваются через options.
4481.06 4491.94 "Анатолий Кулаков" По дефолту используется system.txt.json, но если вы захотите поменять его там на protobuf, на xml или каким-то образом подконфигурировать, то это все тоже элементарно и прекрасно делается.
4491.94 4498.98 "Анатолий Кулаков" Еще одной классной фишкой гибрид кэша является хорошая обработка concurrency операций.
4498.98 4508.86 "Анатолий Кулаков" То есть, даже если мы сами напишем вот этот алгоритм доставания из distributed кэша, который я сказал, у него есть довольно неприятная особенность.
4508.86 4518.54 "Анатолий Кулаков" В том примитивном случае, как его пишут, а его пишут всегда в этом примитивном случае, ну, потому что загоняться на что-то более сложное – это сложно, и очень редко это делают.
4518.54 4520.70 "Анатолий Кулаков" Какое плохое поведение?
4520.70 4532.06 "Анатолий Кулаков" Вот, когда происходит кэш-мисс, мы пошли создавать какой-то долгий ресурс, и в тот момент, когда мы создаем долгий ресурс, на этот же кэш-мисс могут напороться другие запросы.
4532.06 4538.90 "Анатолий Кулаков" Если у нас высоконагруженное приложение, то это на самом деле довольно частая операция, и очень часто мы в это можем упереться.
4538.90 4548.30 "Анатолий Кулаков" В общем, что будет, если другие, там придут вам еще тысячи запросов, которые наткнутся на точно такой же ключ и обнаружат, что этого же ключа нет в нашем кэше.
4548.30 4559.42 "Анатолий Кулаков" Они точно так же пойдут запускать вот эту дорогую операцию, пойдут сериализовать, пойдут по сети запихивать это в кэш, и вы вместо одного запихивания можете сделать тысячу запихиваний.
4559.42 4563.10 "Анатолий Кулаков" Что правильно делать в таких случаях?
4563.10 4575.26 "Анатолий Кулаков" Просто так, как бы, смотреть, если есть кэш-мисс, и ничего не делать, как бы, просто уходить или что-то выдумать, ну, в общем, невозможно сделать, да, т.е. простого решения здесь нет.
4575.26 4576.26 "Анатолий Кулаков" Здесь есть сложное решение.
4576.26 4583.42 "Анатолий Кулаков" Если вы находите кэш-мисс, вы должны проверить, вдруг этот кэш-мисс уже выполняет, уже заполняет какой-то другой процесс.
4583.42 4585.70 "Анатолий Кулаков" Если он заполняет, что вам нужно?
4585.70 4604.26 "Анатолий Кулаков" Вам нужно не просто там подождать какое-то количество секунд, а вам нужно подписаться на время его окончания, и в тот момент, когда он закончит, вы тогда можете пойти и взять результат работы вот этого первого процессора, который сделал всю основную магию, всю основную работу, всю основную фабрику за вас, и воспользоваться его результатом, и этот результат вернуть.
4604.26 4609.18 "Анатолий Кулаков" Вот в гибрид кэше как раз вот этот алгоритм и встроен.
4609.18 4614.06 "Анатолий Кулаков" Он звучит, может быть, и просто, но реализуется довольно нетривиально.
4614.06 4615.66 "Анатолий Кулаков" Там есть очень много корнер-кейсов.
4615.66 4621.14 "Анатолий Кулаков" Если вы используете гибрид кэш, то вам больше об этом задумываться не нужно.
4621.14 4624.86 "Анатолий Кулаков" За вас это все сделает вот этот прекрасный классик.
4624.86 4642.86 "Анатолий Кулаков" Он скомбинирует все тысячи запросов, которые пришли в один ключ, запустит длительную операцию только один раз, и когда она закончится для одного ключа, он все эти тысячи запросов, которые будут ждать именно, не тратя процессорное время, он их удовлетворит и вернет ответ всем, кому он был нужен.
4642.86 4646.82 "Анатолий Кулаков" То есть, он умеет комбинировать вот эти concurrent операции.
4646.82 4649.26 "Анатолий Кулаков" Тоже такое забавное, интересное свойство.
4649.26 4662.58 "Анатолий Кулаков" Даже если вам не нужен, например, какой-то distributed хранилище, а вам достаточно in-memory спецификации, то только ради комбайна конкурентных запросов его вполне можно использовать.
4662.58 4669.82 "Анатолий Кулаков" То есть, сделать вполне in-memory distributed кэш и юзать вот его ради combined concurrency operations.
4669.82 4674.48 "Анатолий Кулаков" Но если вы захотите distributed кэш, то он под капотом использует тот distributed кэш, который у вас сконфигурирован.
4674.48 4678.00 "Анатолий Кулаков" То есть, не надо там каким-то образом что-то дополнительно настраивать.
4678.00 4686.00 "Анатолий Кулаков" Если у вас раньше был сконфигурирован Redis в качестве distributed кэша, то гибрид кэш автоматически подхватит этот distributed кэш и будет его использовать.
4686.00 4688.84 "Анатолий Кулаков" Поэтому здесь вам, в принципе, ничего менять не нужно.
4688.84 4690.20 "Анатолий Кулаков" Так, погнали дальше.
4690.20 4694.40 "Анатолий Кулаков" Есть такие космические улучшения в developer exception page.
4694.40 4701.76 "Анатолий Кулаков" Это та страничка, которая появляется у вас, если вдруг в вашем приложении что-то случилось страшное, возникло какое-то исключение и вы сидите под дебаг-режимом.
4701.76 4708.36 "Анатолий Кулаков" В этот момент вашему сайту главное не рухнуть, а показать разработчику как можно больше полезной информации.
4708.36 4714.04 "Анатолий Кулаков" Там будут у вас тег-трейсы, переменные окружения, прям куски кода, где это могло случиться и много другой полезной информации.
4714.04 4716.20 "Анатолий Кулаков" В общем, developer page - это хорошо.
4716.20 4718.36 "Анатолий Кулаков" Сейчас все привели в более-менее какой-то порядок.
4718.36 4723.88 "Анатолий Кулаков" Улучшили там скроллбарчики, выровняли текстики, подделали под один стиль таблички.
4723.88 4727.32 "Анатолий Кулаков" В общем, улучшили консистентность, юзабиденность, читабельность.
4727.32 4729.32 "Анатолий Кулаков" Все было красивше.
4729.32 4733.20 "Анатолий Кулаков" Что касается Entity Framework, здесь тоже есть парочку небольших изменений.
4733.20 4737.76 "Анатолий Кулаков" Во-первых, поддержали GroupBy операцию для комплекс-тайпов.
4737.76 4748.88 "Анатолий Кулаков" Я напомню, что в свежем Entity Framework появились комплекс-тайпы, то есть это примитивные типы, которые хранятся в той же самой таблице, в которой основной тип, не имеют своих айдишников и вообще, красавцы и молодцы.
4748.88 4752.08 "Анатолий Кулаков" Как раз это то правильное место, куда надо сохранять value-объекты.
4752.08 4757.28 "Анатолий Кулаков" Так вот, теперь по ним можно группировать, даже не по ним, а по их филдам, которые есть у комплекс-тайпов.
4757.28 4759.40 "Анатолий Кулаков" И Entity Framework это прекрасно поддерживает.
4759.40 4765.20 "Анатолий Кулаков" Еще у нас появилась поддержка Redonly примитивных коллекций.
4765.20 4776.30 "Анатолий Кулаков" То есть в Entity Framework 8 был введен своеобразный тип поля, который вы могли представить в виде массива или в виде листа примитивов.
4776.30 4779.44 "Анатолий Кулаков" Например, лист отентов вы могли завязать в сущности.
4779.44 4784.92 "Анатолий Кулаков" И этот лист отентов прекрасно сериализовался в вашу поле прямо и десериализовался оттуда.
4784.92 4791.40 "Анатолий Кулаков" Удобно, хорошо, красиво, тоже очень часто операция, когда вам нужно просто сохранить массив примитивов без всяких дополнительных таблиц.
4791.40 4796.20 "Анатолий Кулаков" И вот в новом Entity Framework немножко улучшили эту поддержку.
4796.20 4800.20 "Анатолий Кулаков" Они сделали возможность заводить свойства Redonly коллекций.
4800.20 4806.44 "Анатолий Кулаков" То есть теперь вы можете не просто использовать Array или ListIntOf, вы можете использовать RedonlyList или RedonlyCollection.
4806.44 4820.00 "Анатолий Кулаков" То есть тоже очень часто бывает нужно, потому что примитивные, то есть иммьютабельные сущности заводят намного чаще, чем мьютабельные, поэтому Redonly коллекции обычно именно по дефолту используют чаще, чем какие-то мьютабельные коллекции.
4820.00 4823.36 "Анатолий Кулаков" Немножко пробежимся по рантайму.
4823.36 4826.04 "Анатолий Кулаков" В рантайме есть тоже парочка забавных фич.
4826.04 4828.92 "Анатолий Кулаков" Во-первых, мы уже обсуждали Unsave Accessor Attribute.
4828.92 4843.16 "Анатолий Кулаков" В одном из выпусков я кратко напомню, что это специальный атрибут, который позволяет вам очень красиво обращаться к приватным филдам или к приватным методам, которые скрыты от обычного доступа, который нам разрешает компилятор, который называется IntelliSense.
4843.16 4850.36 "Анатолий Кулаков" В общем, с помощью хитрой магии, навешивания специальных атрибутов, мы можем доступиться к таким приватным вещам.
4850.36 4868.36 "Анатолий Кулаков" Естественно, каждый день это делать не стоит, это какая-то должна быть экстремальная ситуация, но редко такая штука бывает очень необходима, и вот для этого был придуман классный атрибут, который очень хорош, особенно когда мы говорим о перформансе.
4868.36 4879.16 "Анатолий Кулаков" То есть, если вам нужно сделать какую-то перформанс, а этот перформанс опирается на скрытые, на private какие-то особенности классов, то вот это ваш первый путь, который вы должны попробовать.
4879.16 4882.48 "Анатолий Кулаков" Так вот, это появилось в .NET 8, что же нас ждет в новом?
4882.48 4896.68 "Анатолий Кулаков" А в новом .NET мы научили вот этот магический классик, который понимает компилятор, вот этот магический классик понимать Generic Attribute, ой, не Generic Attribute, а Generic Parameter.
4896.68 4912.28 "Анатолий Кулаков" То есть, вы можете, например, доступаться к field от t, или, например, вызывать метод от t, которому в параметры передаются какие-нибудь t-value, t-key, ну и другие generic параметры.
4912.28 4914.94 "Анатолий Кулаков" То есть, generic параметры могут участвовать абсолютно везде в этом классе.
4914.94 4920.36 "Анатолий Кулаков" Раньше такой поддержки не было, а теперь она есть, и это еще более удобно.
4920.36 4927.04 "Анатолий Кулаков" Теперь просто практически все можно private-приватное вскрыть, и все тайное у нас теперь становится совсем явным.
4927.04 4928.04 "Анатолий Кулаков" Тоже удобная штука.
4928.04 4938.80 "Анатолий Кулаков" А еще в плане Trimming и NativeOut, интересную штуку сделали, это специальный атрибут, который можно навесить на Feature Switch.
4938.80 4942.60 "Анатолий Кулаков" Ну, например, как у нас обычно используется Feature Management.
4942.60 4948.68 "Анатолий Кулаков" Мы пишем "if Feature is supported" какая-то, то делаем какую-то Feature do.
4948.68 4951.20 "Анатолий Кулаков" То есть, если она поддерживается, то мы эту Feature вызываем.
4951.20 4959.64 "Анатолий Кулаков" Это довольно частый шаблон проектирования, его много кто использует, именно для него был выдуман специальный атрибут, который называется Feature Switch Definition.
4959.64 4978.08 "Анатолий Кулаков" В этом Feature Switch Definition атрибуте вы навешиваете его на ваше IS_SUPPORTED поле, обозначаете, какой флажочек, то есть, под каким ключом это поле будет проверять, и компилятор во время компиляции знает все флажочки, все фичи, которые включены в данном конкретном приложении.
4978.08 4997.12 "Анатолий Кулаков" Таким образом, когда он делает вам NativeOut компиляцию, и он видит, что в вашем коде прямо написано "if Feature is supported", он понимает, что этот метод лезет в Feature Management в AppContext, оттуда достается флажочек булевский, проверяет его.
4997.12 5000.92 "Анатолий Кулаков" Он может, то есть, компилятор может во время out-компиляции сам это сделать.
5000.92 5016.92 "Анатолий Кулаков" Он может полезть в AppContext, достать оттуда switch, проверить его и убедиться, что если этот switch выключен, то поле FeatureDo, он даже, то есть, метод, который делает саму реализацию фичи, он даже не вызовет.
5016.92 5019.96 "Анатолий Кулаков" Более того, он ее не просто не вызовет, он ее затримет.
5019.96 5025.76 "Анатолий Кулаков" То есть, он полностью этот метод выкинет из вашего аутпут-бинаря.
5025.76 5028.12 "Анатолий Кулаков" Таким образом, ваш бинарник станет меньше.
5028.12 5043.60 "Анатолий Кулаков" То есть, если вы какие-то фичи включаете или выключаете, и пользуетесь вот этими атрибутами, то в зависимости от включенной или выключенной фичи, результирующий бинарник вас может вообще включать, содержать в себе или не содержать вообще реализацию этой фичи полностью.
5043.60 5060.88 "Анатолий Кулаков" Это тоже отличная штука, которая очень хорошо может позволить уменьшить бинарник в ваших собственных фич-менеджментах, в ваших собственных вот этих управлениями того, какую функциональность нужно включать, а какую выключать.
5060.88 5066.16 "Анатолий Кулаков" В зависимости от того, под что, под какую целевую платформу или под какие там целевые другие флаги вы компилируете.
5066.16 5071.00 "Анатолий Кулаков" Такое же чудо еще у нас есть в виде фича Гуарда.
5071.00 5084.58 "Анатолий Кулаков" Это специальный тоже классик для выпиливания на уровне, для тримминга на уровне native auto, но только уже там по особым типам, по атрибутам required unreference code, required assembly file и так далее.
5084.58 5092.44 "Анатолий Кулаков" То есть, в зависимости от того, где этот атрибут встречается и что он делает, опять же, куски кода могут выпиливаться, что тоже вполне приятно.
5092.44 5097.16 "Анатолий Кулаков" И нововведение, последняя большая секция у нас это library.
5097.16 5101.20 "Анатолий Кулаков" В library тоже так есть пару мелочей, которые хочется упомянуть.
5101.20 5110.08 "Анатолий Кулаков" Это прежде всего добавили возможность к Activity, которая OpenTelemetry, да, у нас есть OpenTelemetry, у нее есть Activity, и к этой Activity теперь можно удобно добавлять link.
5110.08 5116.92 "Анатолий Кулаков" И в этот link, не просто добавлять link, да, то есть в этот link можно добавить ссылку на какой-то другой tracing контекст.
5116.92 5125.20 "Анатолий Кулаков" То есть, грубо говоря, вы из одной Activity можете добавить ссылку на какую-то другую Activity или другой span, или любой другой tracing контекст.
5125.20 5142.92 "Анатолий Кулаков" Это в визуализационных инструментах позволяет вам из одного спана по какому-то там клику или ссылке или еще чего-то ссылаться на другой span, то есть навигироваться между вот этими сложными вызовами, тоже бывает полезно, особенно в тех инструментах, которые умеют красиво и правильно это юзать.
5142.92 5156.08 "Анатолий Кулаков" Мы в одном из прошлых выпусков упоминали о появлении Persisted Assembly Builder, который теперь, наконец, сможет строить сборки, собирать их из ILL-а, из EMIT-а, собирать их и сохранять.
5156.08 5160.04 "Анатолий Кулаков" Так вот, к этому Persisted Assembly Builder наконец добавили поддержку PDP.
5160.04 5177.88 "Анатолий Кулаков" PDP нужно для того, чтобы вам записывать туда всякую дебаг-информацию, с помощью которой в эту сборку, которую сгенерировали, вы можете теперь еще красиво отладить и сообщить какую-то дополнительную информацию при эксепшенах или при отладке, или при еще чем-нибудь.
5177.88 5189.00 "Анатолий Кулаков" Весь API, который есть у этого PDP-билдера, он практически полностью совпадает с тем, что было в .NET-фреймворке.
5189.00 5192.84 "Анатолий Кулаков" Ну, в .NET-фреймворке этот персидент уже давно есть, давно был.
5192.84 5194.48 "Анатолий Кулаков" Сейчас его переносят в Core.
5194.48 5204.20 "Анатолий Кулаков" В общем, API весь совпадает, поэтому если вы вдруг знакомы с тем, как в .NET-фреймворке он делался, то здесь тоже для вас особо ничего нового не будет.
5204.20 5209.44 "Анатолий Кулаков" Вот такие нововведения ждут нас в превью четвертом.
5209.44 5213.64 "Игорь Лабутин" Ну, уже не то, что ждут, превью четвертый уже доступно.
5213.64 5218.44 "Игорь Лабутин" Можно качать, пользоваться, начинать смотреть, если вам что-то из этого интересно.
5218.44 5223.24 "Игорь Лабутин" А мы пойдем дальше, потому что это еще не все анонсы.
5223.24 5231.20 "Игорь Лабутин" У нас обновилась Visual Studio, ну, точнее как обновилась Visual Studio 17.10, превью которой мы много-много-много раз уже рассматривали.
5231.20 5266.28 "Игорь Лабутин" Наконец-таки стала generally available, то есть она перешла в состояние релиза, и в статье-анонсе никаких особых больших нововведений нет, но там вся статья это про GitHub Copilot, и вообще про Copilot, который, соответственно, интегрирован в Visual Studio, всячески там и код комплетит, в чате с ним можно общаться, есть у него там командочки через слэш, которые можно ему ссылки на код кидать через решеточку, он помогает в дебаггере, то есть можно на странице в дебаггере написать ему в чате, почему это переменная NULL, и он там попытается что-то ответить.
5266.28 5272.04 "Игорь Лабутин" Ну и понятно, что пишет всякие код коммит, ну вот комменты к коммитам, вот это все, ну в общем.
5272.04 5287.96 "Игорь Лабутин" В релизе, в общем, только если вам побаловаться Copilot, если новенького, и одновременно, естественно, зарелизилась 17.11 превью 1, следующая версия превьюшка, которая, видимо, наверное к осени как раз выйдет уже в релиз, ну, хочется верить.
5287.96 5302.20 "Игорь Лабутин" В ней в основном пока супер мелкие фичи, это там где вы ищете в окошке поиска теперь можно чуть более просто и легко переключать сколп, то есть между салюшеном проектом и текущим документом.
5302.20 5336.32 "Игорь Лабутин" Если вы пользуетесь гитхабом, лейзер, девопсом, то комменты к пул реквестам теперь там чуть более аккуратно и красиво отображаются в самой Visual Studio, шорткаты поменяли две штуки, для лайн, короче, для того чтобы закомментировать строчку теперь можно использовать control и слэш, как во многих других IDE, ну а если вам нужна, так сказать, быстрый поиск команд, да, с клавиатурой, то это теперь control+shift+p как в Visual Studio, если вы привыкли к Visual Studio код, ну, соответственно, вот в Visual Studio теперь поменяли.
5336.32 5346.24 "Игорь Лабутин" В точке зрения отладки появилось две интересных фичи, с одной стороны профайлер теперь при профайлинге автоматически декомпилирует библиотеки.
5346.24 5381.58 "Игорь Лабутин" Если надо, то есть он будет понимать, вы будете видеть, что это не просто там где-то в какой-то библиотеке, а прям конкретные методы и так далее, а вот другая фича дебаггинга может быть полезна, теперь как можно настроить Visual Studio так, что если из вашего async метода, который возвращает таск, вылетел эксепшн, а он вылетает, он естественно кетчится где-то там в стейт-машине во фреймворке, то вот в этот момент можно автоматически теперь поставить breakpoint, и он будет, ну дебаггер останавливается в этот момент, бывает полезно для такой отладки async методов, которые вызываются через странные стейт-машины.
5381.58 5420.54 "Игорь Лабутин" Ну и с точки зрения самой IDE, там поменялось в разделе статей про IDE, написано, что только они улучшили поддержку файлов в sconfig, напомню, что это штука, которая позволяет вам, если вы положите рядом с solution файлом и пропишите туда название, ну ссылки на нужные экстенджины и компоненты visual studio, то когда вы такой solution попытаетесь открыть в какой-нибудь другой студии, например, вы там устроили какую-нибудь работу, открываете solution совершенно нового вам проекта, вам автоматически студия скажет, что для того, чтобы нормально работать с этим solution вам нужно поставить вот такие-то экстенджины и такие-то компоненты.
5420.54 5429.06 "Игорь Лабутин" Вот теперь это будет получше работать, потому что раньше, если вам один раз предложили, то больше не предложат никогда, даже если sconfig файл поменялся.
5429.06 5432.54 "Игорь Лабутин" Теперь это все чудак получше работает.
5432.54 5442.54 "Игорь Лабутин" Вот примерно так релиз студии есть, каких-то супербольших новостей вокруг него нету, но подождем, чего в следующей ежу студии будут нам показывать.
5442.54 5451.10 "Анатолий Кулаков" Слушайте, я знаю крутую фичу, которая перебьет вообще абсолютно любые экстенджин тайпы и любые потуги C# хоть что-то красивое показать.
5451.10 5454.86 "Анатолий Кулаков" Когда у нас будут XML solutions, неизвестно ли?
5454.86 5455.86 "Игорь Лабутин" Непонятно.
5455.86 5462.94 "Игорь Лабутин" Ну то есть, как я понимаю, в экспериментальном каком-то режиме они у нас есть, но когда это в полноценном виде завезут, пока не знаю.
5462.94 5466.78 "Игорь Лабутин" По-моему, видишь, я думал, что может они к этому релизу что-то допилят, но нет.
5466.78 5473.62 "Анатолий Кулаков" Да, хочется вроде уже как бы, чтоб официально можно было завязать, всем рассказывать и вообще обязать всех комедий только в них.
5473.62 5484.34 "Анатолий Кулаков" Ладно, будем ждать, мне кажется, это вот мега киллер фича студии, которая просто порвет последние какие-нибудь 10 релизов студии и будут померкнут по сравнению с тем, что они сделают с solutions.
5484.34 5488.66 "Анатолий Кулаков" Будем надеяться, что хотя бы к сентябрю они сделают эту штучку.
5488.66 5495.38 "Анатолий Кулаков" Так, следующий мелкий анонс был, это Nuget 6.10.
5495.38 5498.38 "Анатолий Кулаков" Интересен он тем, что у него добавились забавные команды.
5498.38 5521.74 "Анатолий Кулаков" В общем, теперь мы можем в Nuget управлять его environment с помощью того, как вы, например, если вы в GTE в командной строке чего-нибудь делали, то есть у него есть такие подкомандочки, и вот в этих подкомандочек появилось немножко и у Nuget, то есть вы можете вызвать dotnet nuget config path, например, и он вам покажет список всех Nuget config файлов, которые актуальны для той директории, в которой вы работаете.
5521.74 5541.30 "Анатолий Кулаков" Включая там глобальный Nuget config, студийный, dotnet конфиг, ваш локально переопределенный конфиг, это тоже бывает удобно, потому что, опять же, вы, наверное, легко можете найти ваш solution Nuget config, который у вас есть, но что берется за базу, что там сверху подтягивается, чем оно переписывается, порой добыть довольно-таки непросто.
5541.30 5543.82 "Анатолий Кулаков" Но вот данные команды вам вполне могут помочь.
5543.82 5565.10 "Анатолий Кулаков" Что у нас еще есть из команд интересного, это, например, можно вызвать dotnet nuget config get all, который выдаст вам вообще все конфигурации, которые он найдет, очень сильно похоже на гид, на выдавание конфигурации от гида, да, то есть он тоже вам по всем файликам соберет и суммарный отчетик расскажет, что у вас там все-таки включено, что не включено.
5565.10 5575.20 "Анатолий Кулаков" Можно, соответственно, конфиги включать, если вы вызовете конфиг set, то, соответственно, настройка включится, если конфиг unset, разумеется, соответствующая настройка выключится.
5575.20 5580.20 "Анатолий Кулаков" И включится она или выключится, и это все запишется в вашем Nuget config файле.
5580.20 5629.58 "Анатолий Кулаков" Из еще интересного есть приложения, которые не перешли с package.config, вот был такой в каменном веке у нас файл, который назывался packages.config, в этом packages.config хранились ссылки на пакеты и их версии, так вот, приличные люди с него уже давно ушли на package-референсы, которые хранятся непосредственно в csproje, и у этих приличных людей есть хорошие анализаторы, которые умеют проверять актуальность тех или иных пакетов, допустим, если в вашем пакете, на который вы ссылаетесь, была найдена какая-нибудь критическая security-уязвимость, то об этом вам сразу скажет студия или там другая ваша EDE, которая у вас есть, она сразу вам расскажет, что обновитесь или сделайте еще что-нибудь, или заменитесь, но этой зависимостью пользоваться больше не рекомендуется.
5629.58 5648.90 "Анатолий Кулаков" Вот, те чипенцы, которые не имели возможности перейти на новые csproje с package-референсами, а которые по-прежнему использовали packages-config, они были лишены таких анализаторов, в общем, естественно, это неправильно, несмотря на то, что они бедные и убогие, все равно защищать их нужно, security-дыр никто не отменял.
5648.90 5665.30 "Анатолий Кулаков" Так вот, теперь в этом релизе вот этот security-аудит, он понимает в том числе и packages-config, то есть он будет сканировать и их тоже, поэтому наши старички, которые любят старые технологии, они тоже, может быть, будут немножко безопаснее.
5665.30 5687.22 "Игорь Лабутин" Ну, это прекрасно, и мне кажется, что надо потихонечку двигаться в сторону завершения на сегодня, потому что новостей много, пишемся мы уже час 30 плюс, так что давай перейдем к последнему нашему разделу, именно кратко о разном, сегодня тут тоже не очень много, но есть.
5687.22 5716.98 "Игорь Лабутин" Скотт Хансельман со Стивеном Таубом не перестают радовать нас прикольными видусиками, теперь у них видео под названием highly technical talk, ну, видимо, чтобы сразу все поняли, что это прям супертехничное и все такое, они там обсуждают тему про проблемы performance и фиксят какие-то проблемы перформанса, соответственно, если вы хотите посмотреть, как это делают Хансельман и Тауб, как они отлаживают, как они оптимизируют и так далее, гляньте видосик.
5716.98 5765.70 "Игорь Лабутин" Дальше мы когда-то, ну, относительно недавно обсуждали такую узу, такой продукт как Garnet от Microsoft, это некоторая замена а-ля RADIS, то есть такой быстрый кэш, и поскольку он написан на C#, то, конечно же, конечно же, к ним на их гитхаб пришли Visual Studio и попробовали запустить свой анализатор на Garnet, а я напомню, что там по всем отзывам был какой-то очень странный дотнет-код с кучей unsafe и вот этого всего, ну, и ожидаемо, конечно же, VSTudio нашла в этом коде некоторое количество проблем, если интересно читать статью приложенную, как бы они какие-то исправляются, какие-то весьма забавные, в общем, гляньте, может быть что-то интересное найдете.
5765.70 5809.98 "Игорь Лабутин" Ну и последняя новость, это релиз XUnit, казалось бы XUnit там, ну, относительно почти замороженный, там релизится не часто и все ждем новую классную переделанную нафиг версию с полностью новым, значит, дизайнным парадигмами и все такое, но тем не менее, релиз 2.8.1 довольно важный с практической точки зрения, потому что там добавили интересную фичу, которой мне, например, очень сильно в XUnit не хватало, как вы знаете, наверное, если пользуетесь XUnit, то весь output теста, все что пишется, оно идет в специальный itestoutputhelper, и когда тест заканчивается, он, собственно, это все вблевывает наружу, ну, или куда-нибудь в файлик, не знаю, в отчет какой-нибудь и так далее.
5809.98 5828.38 "Игорь Лабутин" Так вот, теперь есть флажок, который позволяет сказать этому itestoutputhelper "пиши все, что в тебя приходит с разума куда-нибудь в вывод", и это позволяет отлаживать там подвисающий тест и вот это все, потому что если тест подвис, понятно, что он никогда не заканчивается, и значит, output от него вы никогда не получите.
5828.38 5848.22 "Игорь Лабутин" Теперь это можно сделать, то есть ключик называется show live output, он там, можно его и через конфигурацию, и через runsettings, и через консольный раннер, и через msbuildrunner, короче, по-разному можно его включить и видеть, что происходит в ваших тестах вживую.
5848.22 5866.38 "Игорь Лабутин" Они, конечно, пишут много предупреждений про то, что весь output перепутается, у нас же тесты запускаются параллельно, вот это все, но, тем не менее, может быть действительно полезно в тех случаях, когда вам нужно понимать, что же происходит внутри теста, а подключиться там и до ешки возможности нет, примерно с CI.
5866.38 5869.26 "Игорь Лабутин" Так что звучит как полезная вещь.
5869.26 5872.26 "Игорь Лабутин" Ну и на этом, кажется, все на сегодня.
5872.26 5883.06 "Анатолий Кулаков" Да, действительно, тем у нас в принципе полно, но тайминг подгоняет, при том, что наши беглые опросы показали, что вы почему-то любите короткие выпуски, поэтому стараемся, закругляемся.
5883.06 5898.22 "Анатолий Кулаков" Я думаю, на следующей неделе у нас уже есть хороший бэклог, поэтому не переключайтесь, ждите новый выпуск, зовите друзей, шарите репосты, распространяйте этот выпуск, пишите в комментариях, что вам понравилось, что нет, и до новых встреч, всем пока.
5898.22 5898.90 "Анатолий Кулаков" Всем пока.
5898.90 5910.10 "Анатолий Кулаков" [музыка]
