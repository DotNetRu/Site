0.00 9.88 "Анатолий Кулаков" Здравствуйте дорогие друзья, в эфире Radio.net выпуск номер сорок пять.
9.88 13.44 "Анатолий Кулаков" И сегодня с вами будет как всегда Анатолий Кулаков и Игорь Лабутин.
13.44 14.44 "Анатолий Кулаков" Привет.
14.44 17.00 "Анатолий Кулаков" А мы благодарим наших любимых и помогаторов.
17.00 21.64 "Анатолий Кулаков" Это Александр, Сергей, Владислав, Алексей, Шевченко Антон и Илья.
21.64 27.52 "Анатолий Кулаков" Если вы хотите присоединиться к этому доблестному списку, то заходите к нам на Patreon и Boosty и смотрите, что у нас есть интересного.
27.52 35.00 "Анатолий Кулаков" После шоу ссылочки, статейки, все это можно найти в наших платных аккаунтах.
35.00 40.72 "Анатолий Кулаков" Я прежде всего, наверное, во первых строках нашего подкаста должен извиниться перед Микрософтом.
40.72 43.92 "Анатолий Кулаков" Мы в прошлый раз на него как-то так наехали, что ничего не делает, ничего не выпускает.
43.92 46.20 "Анатолий Кулаков" Оказывается, Микрософт занимался делом.
46.20 48.12 "Анатолий Кулаков" Микрософт покупал компанию Blizzard.
48.12 64.40 "Анатолий Кулаков" И вот теперь-то с должным уважением, в принципе, вся моя душа счастлива, потому что две юношеские любви моего детства – это Винда, которая привила мне любовь к компьютерам, и Blizzard, которая привила мне намного больше еще любовь к компьютерам и играм.
64.40 69.60 "Анатолий Кулаков" Две моих самых любимых в юношестве компаний сольются в одно целое.
69.60 71.28 "Анатолий Кулаков" Надеюсь, у них все будет хорошо.
71.28 74.24 "Анатолий Кулаков" Так что Микрософт молодец, правильная дорога идет.
74.24 76.64 "Анатолий Кулаков" В принципе, GitHub тут же подкупил.
76.64 79.56 "Анатолий Кулаков" В общем, корпорация становится.
79.56 87.28 "Анатолий Кулаков" Надеюсь, что на .NET-поприще у нее все будет так же хорошо, как и обычно, и есть ли у нее новости на .NET-поприще?
87.28 90.72 "Игорь Лабутин" Ну, новостей не то чтобы сильно много, но они есть.
90.72 110.52 "Игорь Лабутин" У нас потихонечку движется .NET Maui к релизу, вышел 12 превью, и в анонсе уже проявляется фраза, где написано, что мы приближаемся к нашему первому стабильному релизу, и поэтому фокус будет потихонечку смещаться на стабилизацию, повышение качества, а не на какие-то новые фичи.
110.52 131.28 "Игорь Лабутин" Тем не менее, в этом превьюшке завезли, ну ладно, это не фича, это новая документация для всяких иконочек, лайфхайклов, контролов, работы с одним проектом, то, про что мы рассказывали чуть раньше, что теперь не надо там заводить огромное количество проектов под каждую платформу, достаточно все из одного сразу делать.
131.28 151.64 "Игорь Лабутин" Но при этом они продолжают дописывать и переписывать Maui под новые свои подходы архитектуры, то есть еще часть вьюшек, точнее хендлеров сделаны для андроида, добавили Z-Index, не знаю почему его не было раньше, мне кажется довольно основополагающая штука для UI, но почему-то видимо не было.
151.64 160.00 "Игорь Лабутин" Продолжают в рамках, так скажем, переезда на шестой дотнет унификацию всяких типов, на этот раз все добралось до iOS.
160.00 185.48 "Игорь Лабутин" Ну и в фокусе, так скажем, этого 12 превью это находится такая штука под названием Shell, это некая специальная, ну не вьюха, а концепт в коде, которая позволяет как в XAML, так и в коде описать то, как ваши вьюшки должны выглядеть с точки зрения навигации между ними, и после этого использовать этот самый объект Shell для того, чтобы навигироваться между ними и из кода, и из XAML, и так далее.
185.48 204.80 "Игорь Лабутин" Вот делается это до некоторой степени похоже на то, как сделан раутинг в S-Panet, то есть на основе урлов, там даже можно передавать query options, которые во вьюшке соответственно приходят как параметры, все это естественно поддерживает dependency injection, ну то есть в общем такой очередной взгляд на то, как нужно навигироваться в мобильном приложении, ну не только мобильном.
204.80 214.00 "Игорь Лабутин" Все это, понятно, потихонечку готовится к релизу, как я сказал, но пока конкретных дат, обещаний, сроков ничего нету, ждем, надеемся и верим.
214.00 227.12 "Анатолий Кулаков" Да, кросс-платформенная UI нам нужна, нам важна, поэтому внимательно следим и надеемся, что в этот раз Microsoft наконец-то сделает тот единый стандарт, который объединит уже существующие 10 UI, которые у нас есть.
227.12 236.92 "Игорь Лабутин" Да, и еще одна штука, которая произошла вокруг, внутри Microsoft, связана с так называемым .NET Community Toolkit.
236.92 248.12 "Игорь Лабутин" Мы когда-то давно, мне кажется в районе там какого-нибудь 10-15 выпуска, я могу ошибаться с числами, но кажется, очень давно обсуждали такую штуку как Windows Community Toolkit.
248.12 259.72 "Игорь Лабутин" Это был набор просто каких-то полетняшек, причем вообще разных, от там каких-то помощей для работы с винапи на C++, до как раз таки .NET части.
259.72 269.16 "Игорь Лабутин" И вот по какой-то причине, не знаю от какой, .NET часть выпилилась отдельно, и теперь это называется .NET Community Toolkit, начинающийся сразу с версии 8.
269.16 279.04 "Игорь Лабутин" То есть вышел сейчас .NET Community Toolkit версия 8 Preview 1, это тоже превью, как-то полюбилась им эта система с превью номерными.
279.04 296.60 "Игорь Лабутин" И смысл в том, что это набор всяких разных хелперов, апишек, которые должны помочь .NET разработчикам как бы более эффективно что ли работать с какими-то, ну некоторыми там, в некоторых особенных сценариях работы с платформой.
296.60 297.60 "Игорь Лабутин" Что туда входит?
297.60 315.08 "Игорь Лабутин" Во-первых, там есть MVVM Toolkit, то есть это довольно быстрая MVVM библиотечка, если вам интересны модели MVVM для программирования UI на VPF, то посмотрите в сторону ее, причем туда вот ровно сейчас завозят Source генераторы, то есть там все должно стать быстро, легко и compile time.
315.08 320.76 "Игорь Лабутин" Там есть раздел Diagnostics, в основном это всякие хелперы вокруг эксепшенов, каких-то диагностик.
320.76 327.40 "Игорь Лабутин" Я не уверен может быть даже, что их надо использовать в коде, но так в качестве идеи подсмотреть, что можно сделать, может быть полезно.
327.40 333.00 "Игорь Лабутин" И часть, про которую мы собственно рассказывали когда-то давно, это Namespace High Performance.
333.00 355.52 "Игорь Лабутин" Если вы активно используете спаны, memory и прочие типы вокруг этого, и вам например нужны двумерные версии спанов, то вот вам этот Nuget пакетик, это все распространяется в виде Nuget пакета, там есть и Span 2D, и Memory 2D, и кастомный StringPool, и хелпер для битов, короче для битовых операций, в общем много-много-много всего вокруг перформанса.
355.52 363.08 "Игорь Лабутин" Опять же, можно использовать напрямую, можно подсмотреть как сделано и сделать по-своему, но источник вдохновения вполне может быть полезен.
363.08 369.68 "Анатолий Кулаков" А название Community Toolkit значит, что они там легче принимают пол реквеста от комьюнити или какие-то идеи им толкают
369.68 389.64 "Игорь Лабутин" комьюнити? Да, идея была как раз в том, что туда можно предложить практически все что угодно, я не знаю нужно ли попадать обязательно в эти три категории, либо можно предлагать какие-то свои, тут уж я не знаю как это работает, сейчас не изучал, но вообще активность с точки зрения ищусов там была в бытности его Windows Community Toolkit, а активность в ищусов была довольно высокой.
389.64 401.84 "Игорь Лабутин" Но там, поскольку, как я говорю, был собран и плюсы, и дотнет, и что только не было, то сложно было отделить именно дотнет направление, но скорее всего, если вам кажется, что есть что-то полезное, то можно попробовать
401.84 407.00 None туда законтрибьютить. Отлично, еще одно место, куда можно приложить свои силы.
407.00 422.60 "Анатолий Кулаков" В прошлом выпуске мы начали разговаривать с вами про медиатор, довольно популярная библиотека, довольно интересная, многих зацепила и соответственно в комментариях на ютубе Денис Цветих оставил очень правильное дополнение, и поэтому виновник этого комментария сейчас у нас в студии.
422.60 442.40 "Анатолий Кулаков" Я кратко напомню, что в прошлом выпуске мы обсуждали статью, в которой автор настаивал, что медиатор плохо подходит для реализации SecureOS приложений, и Денис, ты пришел к нам в коммент на ютубе и сказал, что автор несет полную чушь, сравнивать несравнимые вещи, вообще так делать нельзя и говорит он абсолютно не то.
442.40 445.08 "Анатолий Кулаков" Раскрой пожалуйста пошире свой комментарий, что ты имел ввиду.
445.08 447.84 "Денис Цветцих" Да, немного расскажу, что я имел ввиду.
447.84 457.52 "Денис Цветцих" Дело в том, что когда мы говорим о SecureOS, как правило имеют ввиду разделение приложения на два стека, стек чтения и стек записи.
457.52 465.16 "Денис Цветцих" А нужно ли нам для этого еще использовать какой-то дополнительный тул, типа медиатора или какую-нибудь собственную липу?
465.16 487.04 "Денис Цветцих" Ну вообще говоря нет, потому что мы можем создать какой-нибудь UserReadService и UserWriteService, и в этом сервисе будет по одному методу на каждый useCase, там какой-нибудь UserWriteService это будут команды, он будет только писать, а UserReadService это там будут query, этот сервис будет только читать.
487.04 492.68 "Денис Цветцих" То есть для того, чтобы сделать SecureOS, нам медиатор не нужен.
492.68 505.04 "Денис Цветцих" Он будет полезен для другой задачи, когда мы каждый вот этот вот метод сервиса выделяем в отдельный класс и мы унифицируем интерфейс обработки вот этих самых useCases, вынесенных в отдельный класс.
505.04 519.64 "Денис Цветцих" И это дает нам возможность как раз каждый на этот useCase еще добавлять какое-то дополнительное поведение, там в медиаторе это называется behavior, то есть выполнять какой-то код до собственного useCase, а либо после него.
519.64 526.00 "Денис Цветцих" И как раз ради вот этой вот фичи, ради этой возможности и стоит использовать медиатор.
526.00 532.20 "Денис Цветцих" То есть Джимми Богорд, собственно автор медиатора, он называет такой подход Vertical Slice Architecture.
532.20 540.28 "Денис Цветцих" Вот, собственно, я этот подход на практике тоже использую, мне он нравится, поэтому вам его тоже рекомендую.
540.28 549.40 "Анатолий Кулаков" А тебе не кажется, что ты как раз-таки доказал слова автора в том, что в принципе медиатор и SecureOS никак не связаны и друг для друга в принципе бесполезны, можно обойтись вполне и без него?
549.40 552.00 "Анатолий Кулаков" То есть со статьей ты полностью согласен, правильно?
552.00 560.76 "Денис Цветцих" Ну, я считаю медиатор и SecureOS вещами взаимодополняющими, они взаимо какими-то противоречивыми и исключающими.
560.76 564.56 "Денис Цветцих" Можно ли SecureOS реализовать без медиатора?
564.56 568.88 "Денис Цветцих" Да, можно, но с медиатором будет удобно.
568.88 572.84 "Денис Цветцих" Дело в том, что автор он предлагал другой подход.
572.84 577.08 "Денис Цветцих" Он говорит, а давайте мы не будем использовать медиатор, а мы напишем свой собственный велик.
577.08 588.04 "Денис Цветцих" Там не будет никаких пайплайнов, то есть мы выбрасываем возможности, ради которых там медиатор создавался, а у нас там будет просто абстракция для query и абстракция для команды.
588.04 593.72 "Денис Цветцих" Это то, чего автору статьи не хватило.
593.72 595.48 "Денис Цветцих" Но здесь есть подводные камни.
595.48 605.68 "Денис Цветцих" Дело в том, что медиатор это уже такой проект зрелый, он уже дожил до девятой версии и чему-то эти авторы медиатора, вот Jimmy Bogart, он научился, пока предыдущие восемь делал.
605.68 609.36 "Денис Цветцих" Было бы хорошо этот опыт переиспользовать.
609.36 612.28 "Денис Цветцих" А научился он, например, вот чему.
612.28 636.44 "Денис Цветцих" Например, если мы делаем такой SecureOS прям трушный и мы из команды запрещаем возвращать любые значения, то потом, когда мы захотим добавить в наш движок пайплайны, то есть команда ничего не возвращает, можно считать void метод, а query возвращает, то мы один и тот же behavior добавить и на команду, и на запрос уже не сможем.
636.44 639.48 "Денис Цветцих" То есть типичная ситуация, у нас какая-нибудь система документов оборота.
639.48 646.32 "Денис Цветцих" И у нас есть там пользователи, на котором настроен доступ на документ, там прям пофамильно.
646.32 658.68 "Денис Цветцих" И перед тем как ну либо отдать пользователю документ из запроса, либо если перед тем как изменить документ из команды, мы должны проверить, а у пользователя это вообще права на это есть.
658.68 671.40 "Денис Цветцих" Но вот как раз это хорошая задачка для behavior, а вот когда вот эти контракты у команды и у запроса разные, то нам один и тот же behavior добавить и на команду и на запрос не получится.
671.40 697.60 "Денис Цветцих" Более того, насколько я помню, в медиаторе даже сначала вот такое разделение было на команду и запрос, это вот такое разделение, которое автору статьи не хватило, а потом это убрали как раз ради того, чтобы была возможность унифицированно обрабатывать команды и запросы, ну и вот такого вот ограничения, когда мы не можем один и тот же behavior добавить и на команду, и на запрос, чтобы этого ограничения не было.
697.60 710.64 "Анатолий Кулаков" Ну, я тебя немножко поправлю, автор действительно предлагал писать свой велосипед, но у него там были пайплайны, то есть он просто говорил, что эти пайплайны намного удобнее вешать, когда у тебя есть четкое разделение между интерфейсами, кто queried, а кто запускает команды.
710.64 723.24 "Анатолий Кулаков" И соответственно, чтобы тебе один и тот же behavior навесить и туда, и сюда, тебе достаточно соблюсти сигнатуру, то есть в сигнатуре тебе нужно возвращать не void, а какой-нибудь unit, что делают в принципе все функциональные языки, и ты свои проблемы решаешь.
723.24 735.68 "Анатолий Кулаков" Хорошо, смотри, я бы с тобой согласился, что медиатор и CQRS вообще никак не связаны, и в принципе зря их упоминают люди в одном и том же предложении, но автор не зря начал это упоминать.
735.68 765.00 "Анатолий Кулаков" Я сам пошел в Google и набил CQRS и медиатор, и там вывалилась огромная куча статей, начиная от нашего любимого Хаббра, заканчивая тем же самым докладами Макса Аршинова, глубоко мне уважаемого, и вот в принципе очень показательная вещь – это книга Microsoft, которая называется «Архитектура для контролируемых .NET-приложений», которую, кстати, мы сейчас обсуждаем в Бук-клубе, поэтому всем любителям подкаста крайне советую как раз знакомлению, и там мы открываем главу CQRS и сразу же первым абзацем нам там летит.
765.00 766.76 "Анатолий Кулаков" А давайте-ка мы заиспользуем медиатор.
766.76 776.48 "Анатолий Кулаков" И все, и опять же, вот тебе рекомендация best practice от Microsoft, что в принципе в любой книге, в любой статье, в любом ролике про CQRS тебе обязательно появится медиатор.
776.48 777.80 "Денис Цветцих" Да, я согласен.
777.80 793.80 "Денис Цветцих" В свое время я даже пытался найти, откуда вообще ноги растут, почему, когда мы говорим, что нам надо сделать CQRS, то нам прям обязательно надо распилить вот эти вот юзкейсы по отдельным классикам, по командам, по запросам.
793.80 813.20 "Денис Цветцих" Когда-то еще Саша Бунью давно в своем блоге, тогда еще медиатора не было, он не был так популярен, он тоже в своем блоге предлагал что-то похожее делать, там был какой-то свой CQRS велосипед, и да, там точно так же вот эти команды запросы разносились по отдельным классам.
813.20 821.92 "Денис Цветцих" Ну это, наверное, это еще просто там мода, что там каждый разработчик должен написать свой собственный CQRS велосипед.
821.92 833.00 "Денис Цветцих" Вот, но я там на одном своем pet project его сделал, у меня получилось примерно то же, что и у автора медиатора, вот поэтому теперь я с чистой совестью использую медиатор.
833.00 845.04 "Анатолий Кулаков" Я даже помню первые примеры Грега Янга, когда он вообще миру представлял, что такое там event sourcing, что такое CQRS, и он там тоже сразу изобрел себе вот шинку, которая очень-очень напоминает современный медиатор.
845.04 850.04 "Анатолий Кулаков" Поэтому мне кажется, это еще от самых основ пошло, и поэтому до сих пор в головах происходит такая путаница.
850.04 854.44 "Анатолий Кулаков" Может быть, даже это уже не путаница, а бест практисы как бы выработались, потому что вместе действительно удобнее.
854.44 878.92 "Денис Цветцих" Да, я согласен, что это действительно такая хорошая бест практис, когда мы растаскиваем по разным классам команды и запросов, ну вообще юзкейсы, не важно там у нас есть CQRS или нет, то это действительно удобно, там будет много преимуществ, что там каждый юзкейс изолированный, не надо кучу зависимости в конструктор тащить, такого большого сервиса.
878.92 881.28 "Денис Цветцих" В общем, да, это действительно удобно.
881.28 891.32 "Анатолий Кулаков" Ну и еще про vertical slices, как раз таки можно прочитать в микрософтской книге по архитектуре, там как раз нет vertical slices и вполне нормально используют медиатор.
891.32 908.28 "Анатолий Кулаков" Делают они это, основываясь на DDD, то есть они просто не разбили компонентики, не разбили все наши компоненты на слайсы, а берут именно настоящий DDD object и вызывают соответствующие его методы.
908.28 919.24 "Анатолий Кулаков" То есть они используют именно ради pipeline, потому что pipeline для чтения и pipeline для записи, то есть вот этот набор behaviour, они сильно отличаются, и даже если у тебя нет слайсов, это тоже имеет какой-то смысл.
919.24 921.20 "Денис Цветцих" Да, это будет удобно.
921.20 922.48 "Анатолий Кулаков" Большое спасибо, Денис.
922.48 925.40 "Анатолий Кулаков" Я напомню, что в гостях у нас был Денис Цветих.
925.40 926.40 "Анатолий Кулаков" Все, пока.
926.40 927.40 "Анатолий Кулаков" Спасибо, пока.
927.40 938.60 "Анатолий Кулаков" Друзья, видите, как довольно просто попасть к нам в эфир, просто напросто пишите правильные и полезные комментарии, и мы без проблем пригласим вас в выпуск для того, чтобы с вами побеседовать.
938.60 950.28 "Анатолий Кулаков" В принципе, наверное, тему прошлого выпуска мы закрыли, но про медиатор разговаривать не закончим, потому что вышла еще одна интересная статья, которую мне с вами хотелось бы обсудить.
950.28 953.92 "Анатолий Кулаков" И называется она «Вам, возможно, не нужен медиатор».
953.92 959.36 "Анатолий Кулаков" Немножко перекликается с прошлой темой, но автор упирает немножко на другие аспекты.
959.36 967.88 "Анатолий Кулаков" И только на то, что медиатор плохо подходит для SecureS, ну и вообще, какие принципы нарушает медиатор и зачем он нужен в вашем приложении.
967.88 968.88 "Анатолий Кулаков" Давайте разбираться.
968.88 973.16 "Анатолий Кулаков" Кратко напомню, что медиатор – это очень популярная библиотека.
973.16 980.48 "Анатолий Кулаков" Призвана она прежде всего уменьшить зависимости между вашими объектами, между вашими слоями вашего сообщения.
980.48 996.60 "Анатолий Кулаков" Основные принципы, которых она придерживается – это некий message bus, который принимает асинхронные сообщения, может и синхронные, но мы говорим про асинхронные сообщения, которые бросаются по шинке, обрабатываются с помощью пайплайна и, может быть, возвращается ответ.
996.60 1002.56 "Анатолий Кулаков" Прежде всего он делает так, что компоненты вашей системы получаются слабосвязанными.
1002.56 1019.08 "Анатолий Кулаков" То есть тот контроллер, который поймал оригинальное сообщение, в принципе, не знает, кто будет обрабатывать это сообщение и поэтому может пулять просто в шинку любой message и ждать ответа от кого угодно, от того, кто сумеет его отработать.
1019.08 1033.92 "Анатолий Кулаков" Это свойство, маленькая связанность, оно повышает, соответственно, переиспользование ваших объектов и позволяет лучше тестировать вот эти самые хендлеры, которые непосредственно отвечают за бизнес-логику.
1033.92 1037.28 "Анатолий Кулаков" И вам неважно, каким образом в этот хендлер прилетело сообщение.
1037.28 1041.52 "Анатолий Кулаков" А теперь непосредственно попробуем пройтись по минусам, которые отметил для себя автор.
1041.52 1052.12 "Анатолий Кулаков" Наверное, мы не будем придираться к неймингу, потому что один из минусов был то, что медиатор, по сути, не реализует шаблон проектирования, который называется медиатор.
1052.12 1059.56 "Анатолий Кулаков" Медиатор сейчас в данном случае это пакет, который больше похож на in-process memory bus, то есть process message bus.
1059.56 1062.64 "Анатолий Кулаков" Никакого отношения к настоящему медиатору он в принципе не имеет.
1062.64 1066.48 "Анатолий Кулаков" Настоящий медиатор это то, что, может быть, вы иногда могли встречать под именем директора.
1066.48 1074.52 "Анатолий Кулаков" То есть это некий оркестратор, который берет в себя кучу разных компонентов с кучей разных зависимостей и выставляет какой-то удобный фасад наружу, чтобы ими управлять.
1074.52 1076.64 "Анатолий Кулаков" Вот это и должен был быть по-настоящему медиатор.
1076.64 1078.84 "Анатолий Кулаков" Но Джимми Боггарт выбрал это название.
1078.84 1088.88 "Анатолий Кулаков" Он признал, что название не самое идеальное и, может быть, не отражает действительно классическое понимание медиатора, но лучше название он придумать не смог, поэтому вот как-то так с этим и живем.
1088.88 1123.92 "Анатолий Кулаков" Одно из самых интересных наездов это то, что медиатор не соответствует DDD, потому что как только вы начинаете в своих приложениях использовать domain-driven design, у вас сразу же на первое место выходит так называемый универсальный язык, ubiquitous language, который обязывает вас использовать в ваших бизнес-объектах и в ваших бизнес-слоях те бизнес-термины, те слова, которыми вы общаетесь с заказчиком, с бизнесом, с продукт-оундером и, соответственно, все стараетесь описывать в тех словах, которые будут понятны людям вокруг, бизнес-людям вокруг.
1123.92 1130.40 "Анатолий Кулаков" И тут мы приходим к тому, что у нас в домене появляются такие методы, как send и handle.
1130.40 1136.56 "Анатолий Кулаков" Разумеется, ни один нормальный бизнес-человек не будет рассказывать о том, что вот нам что-то прислали и мы это отработали.
1136.56 1140.88 "Анатолий Кулаков" То есть в таких терминах разговаривают только разработчики, нормальные люди так не говорят.
1140.88 1146.72 "Анатолий Кулаков" Поэтому немножко здесь начинает ваш язык течь.
1146.72 1159.52 "Анатолий Кулаков" И другой интересный аспект в том, что ваш доменный слой, теперь ваша бизнес-логика обязана реализовывать специальные интерфейсы, вот этот iHandler и прочие хендлеры вот эти.
1159.52 1178.48 "Анатолий Кулаков" И, соответственно, это приводит вас не только к тому, что вы обязаны реализовать какие-то непонятные интерфейсы, которым нет обоснования в вашем языке, но и то, что вы тащите в бизнес-слой третьеостороннюю библиотеку, которая тоже считается не очень хорошей практикой нагромождать в бизнес-слой какие-то библиотеки, тем более инфраструктурные.
1178.48 1183.08 "Анатолий Кулаков" И, соответственно, ваш бизнес завязывается на третьеостороннюю библиотеку.
1183.08 1185.12 "Анатолий Кулаков" И, в принципе, не только бизнес, но и все ваши приложения.
1185.12 1187.24 "Анатолий Кулаков" Но, может, для всего приложения это не так критично.
1187.24 1192.64 "Анатолий Кулаков" Другой минус, который отвечает автор, это очень сложно теперь становится навигироваться по коду.
1192.64 1195.68 "Анатолий Кулаков" То есть у вас практически теряется интеллисенс.
1195.68 1199.68 "Анатолий Кулаков" Вы тут переходите как будто на динамическое проектирование.
1199.68 1209.32 "Анатолий Кулаков" То есть после того, как вы забросили ваше сообщение в шинку, вы понятия не имеете, кто его отработает, когда отработает, с какими условиями, после какой валидации, с какими параметрами.
1209.32 1211.60 "Анатолий Кулаков" И, соответственно, вам уже не помощник интеллисенс.
1211.60 1216.60 "Анатолий Кулаков" Вы не можете посмотреть, кто этот метод, который вы сейчас пытаетесь вызвать.
1216.60 1219.92 "Анатолий Кулаков" Потому что все происходит, весь диспатчинг происходит фронтами внутри.
1219.92 1220.92 "Анатолий Кулаков" И даже наоборот.
1220.92 1224.64 "Анатолий Кулаков" У вас есть хендлер, и вы понятия не имеете, откуда этот хендлер может вызваться.
1224.64 1227.96 "Анатолий Кулаков" Там из контроллеров, из каких-нибудь шинок, еще откуда-то.
1227.96 1231.16 "Анатолий Кулаков" Это обычно довольно сложно.
1231.16 1234.84 "Анатолий Кулаков" Дальше он отмечает, что из-за этого падает производительность.
1234.84 1239.76 "Анатолий Кулаков" Что прямой вызов обычно на порядке быстрее, чем вызов через шинку.
1239.76 1243.44 "Анатолий Кулаков" Если вы просто дернете тот же самый хендлер, просто этот метод у него вызовете.
1243.44 1253.32 "Анатолий Кулаков" Ну и, соответственно, в процессе того, как эта шинка обрабатывает свой pipeline, у вас выделяется много памяти по сравнению с обычным прямым вызовом.
1253.32 1261.56 "Анатолий Кулаков" Ну и, наверное, самый главный нагест - это то, что медиатор используется в нашем приложении как сервис-локатор.
1261.56 1269.24 "Анатолий Кулаков" Нам с юных лет долбили в голову, что сервис-локатор - это антипаттерн, это очень плохо, и никогда использовать его нельзя.
1269.24 1273.36 "Анатолий Кулаков" Давайте немножко поподробнее рассмотрим, чем же плохо так сервис-локатор.
1273.36 1279.64 "Анатолий Кулаков" Во-первых, у вас появляется такой божественный объект, который, соответственно, может обработать все и вся.
1279.64 1283.56 "Анатолий Кулаков" У вас некая шинка, куда вы просто бросаете сообщение и надеетесь, что оно обработается.
1283.56 1287.08 "Анатолий Кулаков" Такая большая ответственность - это довольно плохо.
1287.08 1291.92 "Анатолий Кулаков" Потому что вы теперь понятия не имеете, действительно ли оно обработается или где-то в рантайме упадет.
1291.92 1296.00 "Анатолий Кулаков" Также это нарушает принцип явных зависимостей.
1296.00 1310.68 "Анатолий Кулаков" То есть, когда вам в ваш Classic приходят какие-то зависимости, там какой-нибудь репозиторий или какой-нибудь mail sender, вы примерно по зависимостям уже понимаете, что этот Classic будет делать, что он будет творить, что интересного с ним будет происходить.
1310.68 1320.68 "Анатолий Кулаков" Но когда к вам приходит iMediator, который единственное, что может делать - это дайте мне какое-то сообщение, я с ним что-то сделаю, то ситуация становится абсолютно непредсказуемой.
1320.68 1323.00 "Анатолий Кулаков" Вы не знаете, что будет происходить с вашим приложением.
1323.00 1328.24 "Анатолий Кулаков" И не можете это даже никак по интеллисенсу, как я уже упоминал, по коду отнавидироваться и посмотреть.
1328.24 1330.64 "Анатолий Кулаков" Может произойти абсолютно все, что угодно.
1330.64 1336.92 "Анатолий Кулаков" И самое обидное, что те хендлеры, которые у вас там зарегистрированы, они проверятся только в рантайме.
1336.92 1341.04 "Анатолий Кулаков" То есть, упадет ваше приложение или не упадет, об этом мы узнаем только в рантайме.
1341.04 1349.72 "Анатолий Кулаков" Ну вот как бы в компилированном языке мы напоролись на те самые глупости, из-за которых много лет ругали динамические языки.
1349.72 1355.40 "Анатолий Кулаков" Что нам не компилятор помогает теперь писать надежные приложения, а мы должны рассчитывать на какой-то рантайм.
1355.40 1363.24 "Анатолий Кулаков" И на то, как наше приложение этих хендлеров соберет, отсканирует и конфигурирует, все ли они там попадут или кого-то отсеет.
1363.24 1366.04 "Анатолий Кулаков" В общем, это гарантия очень-очень плохая.
1366.04 1372.84 "Анатолий Кулаков" Соответственно, мы не знаем, от каких хендлеров мы зависим, мы не знаем, с какими хендлерами мы будем в рантайме выполняться.
1372.84 1377.96 "Анатолий Кулаков" Все это лишь можем как-нибудь более-менее гарантировать на уровне тестов, да и то не всегда.
1377.96 1383.96 "Анатолий Кулаков" И, соответственно, это делает нашу программу намного более подверженной ошибкам.
1383.96 1387.72 "Анатолий Кулаков" Еще больше про проблему сервис-локатора можно прочитать у Марка Симона.
1387.72 1390.24 "Анатолий Кулаков" У него огромное количество статей по этой теме.
1390.24 1393.12 "Анатолий Кулаков" Он явный сторонник того, что это антипаттерн.
1393.12 1403.80 "Анатолий Кулаков" Оттуда вы можете узнать, почему сервис-локатор нарушает солид, почему сервис-локатор нарушает инкапсуляцию и много-много, в принципе, абсолютно все нарушает в этой жизни сервис-локатор.
1403.80 1407.08 "Анатолий Кулаков" Он существовать, как по определению, судя по всему, не должен.
1407.08 1408.92 "Анатолий Кулаков" И что же предлагает автор?
1408.92 1412.24 "Анатолий Кулаков" Автор предлагает рассмотреть прежде всего банальную схему.
1412.24 1415.80 "Анатолий Кулаков" Сейчас pipeline работы обычно следующий.
1415.80 1417.92 "Анатолий Кулаков" У вас есть, допустим, контроллер.
1417.92 1420.48 "Анатолий Кулаков" API-контроллер, к нему приходит веб-реквест.
1420.48 1423.60 "Анатолий Кулаков" У контроллера есть одна-единственная зависимость, это iMediator.
1423.60 1429.12 "Анатолий Кулаков" Он берет этот реквест, перемапливает его внутреннюю терминологию и запуливает это все в медиатор.
1429.12 1433.12 "Анатолий Кулаков" Говорит, медиатор, найди мне хендлера, отработай, send.
1433.12 1436.60 "Анатолий Кулаков" iMediator имплементируется с помощью класса Mediator.
1436.60 1451.56 "Анатолий Кулаков" У медиатора, соответственно, есть пачка реквест-хендлеров, из которых он выбирает того хендлера, который матчится по этому сообщению и вызывает непосредственно реализацию этого хендлера, допустим, ping-хендлер, который у нас будет что-то там пинговать.
1451.56 1458.20 "Анатолий Кулаков" Автор предлагает, зачем нам нужны все эти медиаторы, ведь у нас уже есть абстракция, это хендлер.
1458.20 1462.80 "Анатолий Кулаков" Давайте мы в контроллерах просто вместо iMediator запросим iRequestHandler.
1462.80 1467.44 "Анатолий Кулаков" У этого iRequestHandler будет одна-единственная имплементация, это ping-хендлер.
1467.44 1471.12 "Анатолий Кулаков" Вызовем iRequestHandler, обработает ping-хендлер, все счастливы.
1471.12 1477.76 "Анатолий Кулаков" И потом он замечает, что зачем нам вообще нужен iRequestHandler, если у нас одна-единственная имплементация, это ping-хендлер.
1477.76 1483.04 "Анатолий Кулаков" Давайте мы сделаем контроллер, у него зависимость ping-хендлер, одна-единственная имплементация, ping-хендлер.
1483.04 1485.24 "Анатолий Кулаков" В общем, все вроде счастливы.
1485.24 1492.76 "Анатолий Кулаков" У нас получается классический контроллер с обычной прямой зависимостью, директ вызов, никаких лишних аллокаций, все очевидно, IntelliSense работает.
1492.76 1501.44 "Анатолий Кулаков" Мы все еще имеем слабую связанность, потому что контроллер зависит от iPing-хендлера, от реализации он никак не зависит, поэтому тестирование, мокание, все на месте.
1501.44 1506.64 "Анатолий Кулаков" У нас нет никакой зависимости от третисторонних библиотек, у нас полностью наши классики.
1506.64 1520.32 "Анатолий Кулаков" У нас также исчезают суррогатные классы, которые там должны были быть типа ping-реквеста, ping-респонса, то есть те самые перемапленные объекты, которые необходимы только медиатору и все, в принципе, больше они никому не нужны.
1520.32 1528.12 "Анатолий Кулаков" Как я уже сказал, понимаемость увеличивается просто многократно и, соответственно, IntelliSense возвращается на место.
1528.12 1536.72 "Анатолий Кулаков" И казалось бы, все хорошо, но при этом подходе автор теряет одну единственную вещь, маленькую вещь, которая называется Cross-Cutting Concern.
1536.72 1542.76 "Анатолий Кулаков" То есть он теряет возможность настраивать pipeline вызовов произвольного метода.
1542.76 1558.64 "Анатолий Кулаков" То есть он потерял как раз наши метрики, логирование, измерение производительности, какую-то нотификацию о прошедших ивентах, возможность ретрая, если вдруг на обратной стороне какие-то эксепшены были и попытку повторить.
1558.64 1560.92 "Анатолий Кулаков" В общем, все это он почему-то не учел.
1560.92 1563.92 "Анатолий Кулаков" И из-за этого он сделал вывод, что в принципе медиатор не нужен.
1563.92 1570.00 "Анатолий Кулаков" В принципе, если вам не нужна настройка pipeline, если вы не пользуетесь behavior, то безусловно, медиатор вам и не нужен.
1570.00 1573.12 "Анатолий Кулаков" Вы просто передайте совет автора и сделайте все просто красиво и понятно.
1573.12 1580.68 "Анатолий Кулаков" Но если это вам нужно, то тогда в принципе задумайтесь о том, стоит ли удалять или не стоит.
1580.68 1586.20 "Анатолий Кулаков" Медиатор - это не единственная вещь, не единственный способ, как можно обеспечить вас behavior.
1586.20 1594.48 "Анатолий Кулаков" И есть другие вещи, например Type Interceptors, которые похожи на behavior, но встречаются во многих разных библиотеках.
1594.48 1598.20 "Анатолий Кулаков" Например, стандартный AutoFag уже очень давно поддерживает Type Interceptors.
1598.20 1608.24 "Анатолий Кулаков" То есть там вы можете точно так же на pipeline наложить каких-то врапперов и с помощью аспектно-ориентированных парадигм абсолютно сделать то же самое.
1608.24 1609.60 "Анатолий Кулаков" Никаких проблем с этим нет.
1609.60 1615.40 "Анатолий Кулаков" Есть также Dynamic Proxy и на основании его тоже очень много библиотек строят своих перехватчиков.
1615.40 1621.04 "Анатолий Кулаков" То есть все равно вам придется какую-то магию куда-то вводить, если вы все-таки хотите ничего не делать.
1621.04 1635.44 "Анатолий Кулаков" А если для вас важно делать это явно, то можно рассмотреть шаблон из предыдущей нашей статьи, когда автор описывал, каким образом он построил CQRS-шинку, в которой явно в принципе более-менее описал.
1635.44 1641.56 "Анатолий Кулаков" Она не лишена многих проблем медиатора, но зато дает кое-какие преимущества.
1641.56 1647.24 "Анатолий Кулаков" Вот если вы не слушали наш прошлый выпуск, то соответственно советую вернуться и посмотреть.
1647.24 1658.96 "Анатолий Кулаков" В общем, вот такая статья, она не то чтобы разумная, потому что автор опять же вынес те моменты, которые ему не важны и подвел это под абсолют.
1658.96 1670.88 "Анатолий Кулаков" Но интересна она тем, что она подняла огромную дискуссию в твиттерах, в интернетах и лично Джимми Богарт пришел и ответил на эту статейку.
1670.88 1677.10 "Анатолий Кулаков" Что он ответил, наверное я расскажу попозже, давай небольшой какой-нибудь брейк и попозже мы вернемся к этой теме.
1677.10 1678.10 "Игорь Лабутин" Да, тема интересная.
1678.10 1686.28 "Игорь Лабутин" Мы сейчас на самом деле в одном проекте, в качестве эксперимента вроде как хотим попробовать медиатор, посмотреть что получится.
1686.28 1687.28 "Игорь Лабутин" Ради интереса.
1687.28 1690.44 "Игорь Лабутин" Так мы обычно его не используем, но глянем.
1690.44 1695.92 "Игорь Лабутин" Но на самом деле мы не закончили с новостями Microsoft, потому что Visual Studio.
1695.92 1705.36 "Игорь Лабутин" У обычной 22 студии у нас ничего не выходило уже давненько и мы ждем пока что-то там выйдет новенького, видимо готовят какое-то большое превью.
1705.36 1709.36 "Игорь Лабутин" Но тем временем вышла 22 студия для Mac, превью 5.
1709.36 1717.56 "Игорь Лабутин" И там не то чтобы сильно много изменений, там по сути есть два больших тренда, которые сейчас проявляются.
1717.56 1726.52 "Игорь Лабутин" Во-первых, это все еще они пытаются все переписать на нативный UI, говорят что достигли какого-то достаточно большого покрытия собственно UI.
1726.52 1736.40 "Анатолий Кулаков" Погоди, как это на нативный UI, если у нас тут Маюй как бы всеми шагами шагает по планете, мы его рекламируем как кроссплатформенный уничтожитель всех, а ты говоришь нативный UI.
1736.40 1740.88 "Игорь Лабутин" Нет, но тем не менее студия для Mac должна быть на нативном UI, по их мнению.
1740.88 1748.28 "Игорь Лабутин" Ну не так, нативный, не нативный, оно пишется на Xamarin.Forms, конечно, все равно, но в смысле что она должна выглядеть нативно.
1748.28 1752.08 "Анатолий Кулаков" Не, ну выглядеть-то ладно, нам же главное движок рекламировать, конечно.
1752.08 1753.08 "Игорь Лабутин" Хорошо, тогда все в порядке, продолжаем.
1753.08 1762.24 "Игорь Лабутин" Да, там как бы она и выглядела как-то вообще непонятно, сейчас они потихонечку все вьюшки и все тут tool window и так далее переносят так, чтобы они выглядели нативно.
1762.24 1793.36 "Игорь Лабутин" А второе, что теперь начиная с пятого превью она нативно работает на M1 без эмуляции, то есть на шестом тотнете на M1 и там все прям как-то супер быстро стало, то есть они показывали сравнительное видео, где открытие какого-то достаточно большого вроде салюшена занимало типа 30 секунд, ну в смысле запуск студии плюс открытие салюшена на старой версии, на прошлой превьюшке и что-то около, боюсь наврать, 14 секунд на новой, то есть там в два раза практически легко.
1793.36 1798.20 "Анатолий Кулаков" Было бы классно, если бы они вот то же самое еще с райдером сравнили, ну из Visual Studio Code для компании.
1798.20 1804.28 "Игорь Лабутин" Не, ну с кодом неинтересно сравнивать, код откроется мгновенно, понятное дело, что там, вот.
1804.28 1805.28 "Игорь Лабутин" Ну с райдером-то честно.
1805.28 1807.40 "Игорь Лабутин" Да, плюс индексацию подождать.
1807.40 1816.44 "Анатолий Кулаков" Ну вот это все и сравнить, потому что они друг другу как бы любят разные циферки показывать, а вот сравнить с индексацией, без индексации, с прогретым, не прогретым.
1816.44 1818.96 "Игорь Лабутин" Ну короче да, интересно, но такого сравнения нет.
1818.96 1829.64 "Игорь Лабутин" В общем вот это все, что пока есть про пятый превью, ждем точно так же, когда она таки доберется до нормального полноценного релиза, но пока еще никаких слухов нет.
1829.64 1842.36 "Игорь Лабутин" И вторая штука, про которую хотелось бы рассказать, на немножко нетрадиционно для нашего, так скажем, в основном обычного чисто дотнетного подкаста, но тем не менее, она про Azure.
1842.36 1853.72 "Игорь Лабутин" Как ты думаешь, Толя, сколько у нас способов запустить код в Azure, вот если ты написал какую-нибудь программку на C#, допустим, и решил ее запустить в Azure, сколько у тебя способов это сделать?
1853.72 1862.44 "Анатолий Кулаков" Да подожди, ну мне кажется миллионы, я же могу там виртуалочку создать, в контейнер положить, в Azure Function засунуть, это ж ого-го, мне кажется, еще одно количество
1862.44 1871.56 "Игорь Лабутин" уже должно быть. Да, вот даже если мы забудем про виртуалочки, их сейчас пять штук разных, те, которые ты можешь каким-то образом запустить.
1871.56 1895.36 "Игорь Лабутин" Значит, ты можешь запустить действительно то, что, наверное, наиболее часто слышится, ну мне, по крайней мере, это Azure App Service, это как бы просто в основном нацеленное на веб-приложение, то есть вот мы так запускаем наш код, но мы не пользуемся никаким докером, ничего, то есть мы просто пушим на нативные наши S/Panad Core приложения в App Service, они там запускаются.
1895.36 1905.96 "Игорь Лабутин" Если у тебя докер, можно использовать контейнер instance, но это считай как виртуалка практически, потому что там Hyper-V изоляция, и в общем никакого тебе автоскейлинга, никакого load balancing и так далее.
1905.96 1915.44 "Игорь Лабутин" Если все это хочется, иди, пожалуйста, в Kubernetes, там, пожалуйста, делай свой полный кластер и все такое, но как бы нужно держать свой полный кластер и самому все это менеджить, тоже не очень.
1915.44 1918.96 "Анатолий Кулаков" И нужно держать еще команду DevOps, которые будут менеджировать этот кластер Kubernetes.
1918.96 1921.64 "Игорь Лабутин" Конечно, обязательно, как же без этого.
1921.64 1935.12 "Игорь Лабутин" Вот, можно действительно functions запихнуть, если у тебя что-то серверлесное и таковое, лайтовое, а если вдруг, ну ладно, это уже про Java, есть еще у них отдельный офферинг для Spring Cloud, если ты на Spring Boot пишешь, у них там есть что-то отдельное для Java, я не сильно знаю.
1935.12 1941.56 "Игорь Лабутин" Так вот, анонсированы и в превью-версии вышли сейчас так называемые container apps.
1941.56 1961.20 "Игорь Лабутин" Это, короче, штука, которая написана поверх Azure Kubernetes, разбавлена Dapro и Envoy, и позволяет, собственно, контейнеры запускать в достаточно лайтовой манере, в смысле, что не надо менеджировать свой Kubernetes, но за тебя все будет, всякие health-чеки, рестарты, апдейты будут делаться сами-сами.
1961.20 1979.96 "Анатолий Кулаков" У меня с Azure связана детская травма, что когда я хотел там запустить свой Docker-контейнер, то обнаружил там десяток сервисов, которые могут запустить Docker-контейнер с различными уровнями, гарантиями и так далее, и в них так сложно было разобраться, и так легко было запутаться, что легче было плюнуть, и не ставить перед собой таких целей.
1979.96 1985.48 "Игорь Лабутин" Все так, и самая главная проблема для меня, например, с Azure в том, что там еще фиг разберешься с ценообразованием.
1985.48 2019.00 "Игорь Лабутин" У меня сложилось впечатление, что все эти перечисленные сервисы, ну кроме functions, пожалуй, у них практически, по-моему, даже нет consumption так называемых планов, то есть когда ты платишь только за использованное время там CPU и памяти, ну или там I/O, так вот контейнер apps как раз-то у них есть consumption план, то есть это как раз хороший способ для таких как бы, ну например, как вот у нас там, не знаю, наш метапный бекентик запустить для метапного приложения, который используется только раз в несколько недель, вот это было бы вообще идеально.
2019.00 2023.68 "Анатолий Кулаков" Да, точно, ну и чем же эта штука отличается от существующих кубернетусов и фанкшенов?
2023.68 2072.80 "Игорь Лабутин" Ну вот она как раз-таки, во-первых, то есть это вы туда просто пушаете ваши контейнеры, образы контейнера, контейнеры имиджес, да, и они, соответственно, запускаются, их можно группировать, это получится некоторый аналог кубернетского пода, то есть они вместе будут скалироваться, вот, там как бы ему абсолютно плевать на то, что у вас внутри контейнера, тут нет нет нет, ну как, собственно, и всем остальным, вот, и зато вам не нужно париться о кубернетскластере, то есть это нечто среднее между полноценным кубернетскластером, совсем серверлесным фанкшеном и очень сильно заточенным на вебап сервисами, то есть вот какая-то такая очень золотая середина, и, возможно, это как раз очень правильный способ, такой должен быть, по идее, дефолтный способ запускать контейнеры, теперь вожу ли.
2072.80 2074.60 "Игорь Лабутин" Звучит хорошо, надо попробовать.
2074.60 2090.00 "Игорь Лабутин" Да, я тоже планирую что-нибудь с этим попробовать сделать, я не уверен, что мне это надо в продакшене, в продакшене у нас контейнеры инстанциоз живут, но в таком вот, да, для себя куда-нибудь попушать, тем более если там есть consumption pricing, значит, там, скорее всего, должно быть довольно дешево.
2090.00 2097.32 "Игорь Лабутин" Давай дальше, давай вернемся, наверное, к сервис-локаторам и прочему, добьем уже эту тему.
2097.32 2129.28 "Анатолий Кулаков" Ну давай, я надеюсь, что больше у нас продолжения не будет, хотя, не знаю, мне было очень увлекательно следить за беседой наших гигантов, они там в нескольких местах общались, в нескольких местах переписывались, соединялись другие интересные знаменитости и в конце до концов сейчас мы имеем то, что Джимми Боггарт написал отдельную статью, его, в принципе, за все эти годы порядочно задолбали вот этим навязчивым мнением, что сервис-локатор это антипаттер, так делать нельзя, так никто не делает и вообще уходите срочно из профессии, если вы вдруг используете сервис-локатор.
2129.28 2135.04 "Анатолий Кулаков" И поэтому он разойдется свежей статьей, 2022 год и мы обсуждаем до сих пор сервис-локаторы.
2135.04 2137.16 "Анатолий Кулаков" Но почему бы и нет?
2137.16 2154.40 "Анатолий Кулаков" Прежде всего лет 10 или 12 назад была шикарная статья от Марка Симона, почему сервис-локатор это плохо, там он рассмотрел множество кейсов, расписал и минусы подробно, расписал почему нельзя его использовать, как нужно переделать, как надо использовать.
2154.40 2170.16 "Анатолий Кулаков" В общем, если вам интересно, то обязательно обратитесь к статьям Симона, они актуальны до сих пор, в принципе, это самый гениальный, наверное, человек, который может вам обалденно расписывать архитектуру именно вот на таком уровне, на уровне классиков, интерфейсов, зависимостей.
2170.16 2174.28 "Анатолий Кулаков" Вот этого у него полно, в общем, в его блоге замечательно все это есть.
2174.28 2187.64 "Анатолий Кулаков" И Джимми говорит, что типа все, что расписал Марк, это прекрасно, он полностью со всем согласен и ничем он не спорит, но только единственная проблема в том, что Марк расписал слишком легкие, понятные кейсы.
2187.64 2190.16 "Анатолий Кулаков" А жизнь она не такая, жизнь она такая более суровая.
2190.16 2194.72 "Анатолий Кулаков" И в жизни у каждого шаблона есть как плюсы, так и минусы.
2194.72 2201.98 "Анатолий Кулаков" И иногда абсолютно невозможно избежать сервис локатора, особенно его много, когда мы говорим про инфраструктурный код.
2201.98 2214.40 "Анатолий Кулаков" Когда вы пишете что-то в бизнес логике, то вы еще можете показаться белоручкой и выйти из этого чистым и красивым, но как только вы спускаетесь в инфраструктуру и пытаетесь сделать удобно и универсально, то там уже руки у вас связаны.
2214.40 2222.84 "Анатолий Кулаков" Рассмотрим несколько типичных примеров, которые не обойдутся без сервис локатора, по мнению Джимми Боггарта.
2222.84 2226.44 "Анатолий Кулаков" Прежде всего это несоответствие жизненных циклов компонентов.
2226.44 2228.56 "Анатолий Кулаков" Эта тема относится к контейнерам.
2228.56 2233.68 "Анатолий Кулаков" Все мы знаем, что у нас теперь есть сервис контейнеры, их завезли у нас в ISP.NET Core.
2233.68 2241.36 "Анатолий Кулаков" Теперь это, если раньше это было удел передовых технологий, то сейчас это есть во фреймворках практически у каждого.
2241.36 2244.24 "Анатолий Кулаков" Даже кто-то, если почему-то раньше с контейнерами не сталкивался.
2244.24 2253.24 "Анатолий Кулаков" И контейнеры в принципе и в назаре своей имели очень много разных уровней жизни, но в конце концов сейчас осталось по сути три.
2253.24 2258.16 "Анатолий Кулаков" Самые главные, самые понятные и в принципе их абсолютно достаточно большинству приложений.
2258.16 2264.32 "Анатолий Кулаков" Во-первых, в контейнерах компоненты могут жить с помощью трех различных лайфтаймов.
2264.32 2271.12 "Анатолий Кулаков" Это Transient, это лайфтайм, когда компонент создается каждый раз, когда его кто-то попросит.
2271.12 2279.76 "Анатолий Кулаков" Если он стоит в зависимости у какого-то класса, то как только этот класс запросит эту зависимость, вызовется New и создается этот новый компонент.
2279.76 2283.96 "Анатолий Кулаков" Это практически то, что вы используете каждый день, когда делаете New какой-то object.
2283.96 2285.84 "Анатолий Кулаков" Вот ничем не отличается.
2285.84 2286.84 "Анатолий Кулаков" Дальше идет Scoped.
2286.84 2298.68 "Анатолий Кулаков" Scoped - это специальные компоненты, если они зарегистрированы в лайфтайме Scope, то их instance создается один раз на какой-то определенный заданный Scope.
2298.68 2301.16 "Анатолий Кулаков" Легче всего это представить в виде Request Scope.
2301.16 2313.64 "Анатолий Кулаков" Когда к вам заходит запрос, открывается Scope и внутри этого запроса сколько раз вы бы не запросили компонент, который зарегистрирован как Scoped компонент, вам всегда будет возвращаться только один instance.
2313.64 2319.52 "Анатолий Кулаков" Но если в это время войдет второй запрос, для него откроется совершенно другой Scope.
2319.52 2324.20 "Анатолий Кулаков" И второй instance вашего компонента никак не будет связан с первым.
2324.20 2327.28 "Анатолий Кулаков" То есть они синглтоны только в рамках своего Scope.
2327.28 2333.96 "Анатолий Кулаков" Соответственно, когда HTTP Request закончился, Scope закрывается и все ваши instances Scoped используются.
2333.96 2336.40 "Анатолий Кулаков" Вот такой тоже очень полезный лайфтайм.
2336.40 2341.08 "Анатолий Кулаков" В нем, например, живет контекст базы данных, что тоже довольно полезно.
2341.08 2345.76 "Анатолий Кулаков" И самый последний, наверное, самый простой лайфтайм это Singleton.
2345.76 2347.44 "Анатолий Кулаков" Все мы, скорее всего, писали Singleton.
2347.44 2352.60 "Анатолий Кулаков" Может быть, многих из вас спрашивали на собеседовании, как написать правильный потокобезопасный Singleton.
2352.60 2355.60 "Анатолий Кулаков" Я думаю, что это слово все знают и все помнят.
2355.60 2360.32 "Анатолий Кулаков" То есть это класс, который существует в одном единственном экземпляре.
2360.32 2364.56 "Анатолий Кулаков" Единственное уточнение, что в одном единственном экземпляре пока живет контейнер.
2364.56 2370.32 "Анатолий Кулаков" Контейнер у нас обычно живет все время жизни приложения, поэтому это обычно Singleton на все приложения.
2370.32 2378.44 "Анатолий Кулаков" И очень важно, с тех пор, когда мы перешли на контейнеры, очень важно соблюдать несколько простых правил.
2378.44 2383.60 "Анатолий Кулаков" Несколько простых правил, из-за которых вам нельзя смешивать определенные лайфтаймы.
2383.60 2385.84 "Анатолий Кулаков" Вот самые основные из них.
2385.84 2392.64 "Анатолий Кулаков" Во-первых, вам нельзя ни в коем случае инжектить Transient компонент внутрь Singleton компонента.
2392.64 2395.92 "Анатолий Кулаков" Потому что в этот самый момент он начнет жить вечно.
2395.92 2406.48 "Анатолий Кулаков" Как только Singleton захватывает свою зависимость, он эту зависимость держит и соответственно продлевает время этой зависимости на время жизни всего приложения, как мы выяснили выше.
2406.48 2410.28 "Анатолий Кулаков" Обычно, когда компонент делают Transit, на это не рассчитывают.
2410.28 2412.32 "Анатолий Кулаков" Ну, поэтому его и делают Transit.
2412.32 2417.12 "Анатолий Кулаков" И это может приводить к банальным утечкам памяти или еще к чему-то похуже.
2417.12 2422.40 "Анатолий Кулаков" Далее, если у вас есть Scoped сервис, то он обязан резолвиться только из Scope.
2422.40 2435.52 "Анатолий Кулаков" Если у вас нет Scope, если у вас не пришел никакой HTTP-реквест, и вы пытаетесь из Singleton забрать Scoped сервис, то это типичная ошибка проектирования, и это тоже может привести к утечкам памяти или к чему-то еще хуже.
2435.52 2443.80 "Анатолий Кулаков" И третье основное правило - это Scoped сервисы не должны инжектироваться в Singleton.
2443.80 2450.56 "Анатолий Кулаков" Это, как я уже описал, Singleton противные, они продлевают времена жизни и все такое.
2450.56 2457.12 "Анатолий Кулаков" Вот если вы будете соблюдать эти правила, то в принципе в большинстве случаев, там 99% проблем, вас не коснется.
2457.12 2462.76 "Анатолий Кулаков" Но вся сложность заключается в том, что иногда невозможно эти правила соблюсти.
2462.76 2465.04 "Анатолий Кулаков" Давайте рассмотрим типичные примеры.
2465.04 2467.96 "Анатолий Кулаков" Например, есть ASP Validation Action Filter.
2467.96 2478.14 "Анатолий Кулаков" То есть этот фильтр, который вызывается непосредственно перед тем, как передать контроллеру какой-то запрос, и он может как Interceptor, как Middleware что-то с этим запросом сделать.
2478.14 2479.96 "Анатолий Кулаков" Например, в данном случае отвалидировать.
2479.96 2484.60 "Анатолий Кулаков" В ASP Validation Filter он валидирует модель, которая сейчас к нам пойдет в контроллер.
2484.60 2487.60 "Анатолий Кулаков" Специфика этого фильтра заключается в том, что он Singleton.
2487.60 2492.12 "Анатолий Кулаков" Ну, казалось бы, валидатор Singleton, никаких проблем в этом нет.
2492.12 2499.20 "Анатолий Кулаков" Но обычно реализация его подразумевает то, что Scoped Singleton для него не очень удобен.
2499.20 2500.32 "Анатолий Кулаков" Объясню на примере.
2500.32 2503.28 "Анатолий Кулаков" У него есть метод Validate.
2503.28 2506.68 "Анатолий Кулаков" Внутри этого метода Validate передается HTTP Request Context.
2506.68 2514.24 "Анатолий Кулаков" И для того, чтобы проверить этот Request Context, у него обычно регистрируются так называемые Request Validators.
2514.24 2518.24 "Анатолий Кулаков" Это отдельные классы, которые имплементируют непосредственно какую-то одну проверочку.
2518.24 2521.68 "Анатолий Кулаков" И эти Validators регистрируются как раз в Scoped Space.
2521.68 2528.36 "Анатолий Кулаков" А мы знаем, что из компонента, который зарегистрирован как Singleton, нельзя вызывать Scoped Services.
2528.36 2530.88 "Анатолий Кулаков" Поэтому здесь такая небольшая проблемка возникает.
2530.88 2537.64 "Анатолий Кулаков" Если у нас Action Filter Singleton, нам нужно достать Validators из Scoped, как нам это сделать?
2537.64 2538.64 "Анатолий Кулаков" Есть небольшой хак.
2538.64 2544.24 "Анатолий Кулаков" Внутри контекста, HTTP контекста, есть специальные свойства, которые называются Request Services.
2544.24 2548.32 "Анатолий Кулаков" Это как раз Scoped Services, которыми можно воспользоваться.
2548.32 2558.04 "Анатолий Кулаков" Соответственно, мы лезем внутрь этого свойства, резолвуем оттуда наш iRequest Validator, который зарегистрирован как Scoped, валидируем и в принципе все счастливы.
2558.04 2564.40 "Анатолий Кулаков" Validator отпускаем, Scoped кончается, он там где-то задиспользуется и мы справились со своей задачей.
2564.40 2577.24 "Анатолий Кулаков" Но в тот самый момент, когда мы полезли внутрь контекста, в свойства Request Services для того, чтобы найти наших валидаторов, в этот самый момент мы воспользовались небезызвестным Service Locator.
2577.24 2579.32 "Анатолий Кулаков" Как раз таки это и есть Service Locator.
2579.32 2585.52 "Анатолий Кулаков" И без него здесь никак не справиться, потому что нам нужно нарушить границу вот этих правил lifetime.
2585.52 2586.52 "Анатолий Кулаков" Следующий пример.
2586.52 2587.52 "Анатолий Кулаков" Hosted Services.
2587.52 2598.88 "Анатолий Кулаков" Это отличная фишка, которая появилась в свежих ISP-фреймворках.
2598.88 2608.48 "Анатолий Кулаков" Это background service, который у вас просто запускается на старте вашего приложения и может быть одноразовую работу какую-то делает, а может запустить в таймере бесконечный цикл.
2608.48 2618.68 "Анатолий Кулаков" Допустим, периодическая рассылка спама, рассылка e-mail всем пользователям на свете через каждые 5 минут и в background крутить свой счетчик и рассылать e-mail.
2618.68 2624.84 "Анатолий Кулаков" С ним тоже все не так уж просто, потому что hosted service это обычный singleton.
2624.84 2630.64 "Анатолий Кулаков" И так как он singleton, зависимости он может иметь соответственно только какие-нибудь singleton.
2630.64 2639.52 "Анатолий Кулаков" Но если мы вдруг хотим e-mail рассылать не просто так, а с содержимым из нашей базы данных, то скорее всего мы захотим использовать Entity Framework.
2639.52 2645.96 "Анатолий Кулаков" Entity Framework регистрирует свой контекст, DB-контекст, обычно в lifetime scoped.
2645.96 2652.92 "Анатолий Кулаков" Мы опять получаем, что singleton, наш hosted service, обязан каким-то образом общаться со scoped-сервисами.
2652.92 2671.04 "Анатолий Кулаков" И проблема этой ситуации состоит в том, что здесь уже ISP Core Framework не предоставляет нам никаких удобных пропертей, никаких удобных scoped-сервисов, куда мы можем слазить и достать сервисы для этого реквеста, потому что у нас нет никакого реквеста.
2671.04 2679.72 "Анатолий Кулаков" Этот hosted service поднимается на старте приложения, и пользователь вообще может не ходить ни с какими реквестами, но e-mail нам уже рассылать хочется.
2679.72 2682.40 "Анатолий Кулаков" В этом случае у нас только один вариант.
2682.40 2686.12 "Анатолий Кулаков" Мы вынуждены создать свой собственный scoped, благо это можно сделать.
2686.12 2701.60 "Анатолий Кулаков" То есть вы создаете свой собственный scoped с помощью зависимости, которая называется service provider, и уже у этого scoped-сервиса резолвите db-контекст, который должен резолвиться только в scoped-сервисе, он не может просто с чистого синглтона резолвиться.
2701.60 2709.36 "Анатолий Кулаков" И соответственно у этого db-контекста вызываете уже методы чтения с базы данных, запись в базу данных и так далее.
2709.36 2719.08 "Анатолий Кулаков" В принципе тоже вполне стандартный шаблон, многие так делают, но проблема в том, что как только вы зарезолвили из scoped-сервиса db-контекст, вы снова воспользовались сервис-локатором.
2719.08 2721.64 "Анатолий Кулаков" И здесь тоже сервис-локатор.
2721.64 2724.52 "Анатолий Кулаков" Казалось бы, избежать этого абсолютно никак невозможно.
2724.52 2749.60 "Анатолий Кулаков" Ну и вообще, если мы говорим про ISP Core, вообще ISP Framework, то там сервис-локатор встречается сплошь и рядом на инфраструктурной части, потому что на каждый у вас запрос, который входит в ваши контроллеры, у вас создается обязательно scoped, у вас резолвится каким-то образом все ваши middleware, прогоняется запрос по всему этому pipeline, и когда запрос уходит, scoped закрывается.
2749.60 2755.32 "Анатолий Кулаков" И все это работает с компонентами в различных лайфтаймах.
2755.32 2760.28 "Анатолий Кулаков" То есть какие-то компоненты зарегистрированы как синглтоны, какие-то в scoped, какие-то transient.
2760.28 2765.24 "Анатолий Кулаков" И это все нужно как-то миксовать и держать в голове все вот эти правила.
2765.24 2771.32 "Анатолий Кулаков" Поэтому на уровне инфраструктуры очень сложно как раз-таки избавиться от вот этих проблем.
2771.32 2778.96 "Анатолий Кулаков" И в принципе проблема не только в ISP, это касается любого такого универсального message-диспатчинга.
2778.96 2806.80 "Анатолий Кулаков" Допустим, если вы хотите написать свою шинку и хотите туда забросить какой-то произвольный объект, который нужно отправить, и при этом не знаете настоящий тип этого объекта, а вот отвалидировать или отхендлить или каким-то образом еще обработать этот объект нужно уже по типизированному хендлеру, то тут тоже каким-то образом не справиться без сервис-локатора, который найдет вам необходимый хендлер необходимого типа, который вы узнаете только в рантайме.
2806.80 2813.96 "Анатолий Кулаков" Соответственно, если у вас бибанинг типа происходит в рантайме, результат типа происходит в рантайме, то здесь без сервис-локатора тоже будет очень сложно.
2813.96 2826.00 "Анатолий Кулаков" Так, например, проступает Fluent Validator, тоже очень известный фреймворк, который находит валидаторы во всем вашем приложении и позволяет удобно в Fluent Syntax записывать интересные правила.
2826.00 2835.76 "Анатолий Кулаков" Еще один интересный пример, где используется сервис-локатор, я в принципе о нем, наверное, не знал, потому что он касается мобильных разработчиков в основном.
2835.76 2846.04 "Анатолий Кулаков" Интересный момент для мобильных разработчиков заключается в том, что для них запуск приложения, время старта очень критично.
2846.04 2857.24 "Анатолий Кулаков" Если в наших интерпрайзах приложение запускается 5 минут, ну и ладно, никому этого хуже не будет, зато оно потом работает годами не переставая, то в мобильном приложении все намного по-другому.
2857.24 2859.56 "Анатолий Кулаков" Там приложение обязано быстро запускаться.
2859.56 2877.92 "Анатолий Кулаков" И говорят, что люди как раз таки упираются в резолв зависимости в конструкторе, что конструктор обязан требовать уже конкретной инстанции этих зависимостей, и типа посоздавать все эти зависимости, запихнуть их в конструктор, уже становится в этих условиях довольно тяжеловесной операцией.
2877.92 2881.16 "Анатолий Кулаков" И поэтому люди выкручиваются как-то по-другому.
2881.16 2894.88 "Анатолий Кулаков" Например, они создают lazy dependency, то есть они непосредственно зависимость требуют, а оборачивают ее в lazy generic и требуют отложенную зависимость, и в тот момент, когда она вам нужна, резолвит уже это значение.
2894.88 2900.80 "Анатолий Кулаков" Кажется, что при этом dependency не создается сама и уже на тяжелый конструктор времени не тратится.
2900.80 2911.32 "Анатолий Кулаков" Но здесь прежде всего хотелось бы отметить, что создание объектов с тяжелым конструктором - это отдельный антипаттерн, никогда так делать нельзя.
2911.32 2917.24 "Анатолий Кулаков" Конструкторы должны быть обязательно быстрые, единственное, что они должны делать - это проверять аргументы и сохранять локальные поля.
2917.24 2918.92 "Анатолий Кулаков" Все остальное уже им делать нельзя.
2918.92 2926.12 "Анатолий Кулаков" Если вас интересуют подробности, опять же у Марка есть шикарная статья, которая называется "Почему конструкторы должны быть быстрые и легкие".
2926.12 2936.64 "Анатолий Кулаков" Обязательно прочитайте, потому что мне кажется, что легкие конструкторы - это одно из основополагающих принципов, которых нужно придерживаться для того, чтобы не наступать на вот такие подобные грабли.
2936.64 2938.76 "Анатолий Кулаков" Итак, вернемся к нашим мобильным приложениям.
2938.76 2951.04 "Анатолий Кулаков" Как я уже сказал, у них очень важен стартап тайм, и они часто используют вместо настоящей зависимости lazy обертки, но бывает так, что этих lazy оберток тоже уже становится очень много.
2951.04 2957.88 "Анатолий Кулаков" Поэтому они переходят на следующую ступень эволюции, они запрашивают всего лишь навсего один единственный сервис.
2957.88 2958.88 "Анатолий Кулаков" Я думаю, вы уже догадались.
2958.88 2960.24 "Анатолий Кулаков" Это сервис Service Locator.
2960.24 2965.44 "Анатолий Кулаков" Передать одну зависимость, которая уже создана, ну так как Service Locator - это синглтон, не составляет особого труда.
2965.44 2970.08 "Анатолий Кулаков" Вы передаете ее в конструктор, ваше приложение поднимается, все быстро, хорошо и прекрасно.
2970.08 2982.08 "Анатолий Кулаков" А когда вам нужно, например, зарезоловать настоящую зависимость, там пользователь тапнул по кнопочке, тогда вы берете Service Locator, вызываете уже нужный, резолвите нужный сервис, и у этого сервиса дергаете все, что должно дергаться.
2982.08 2985.92 "Анатолий Кулаков" То есть, такая отложенная, отложенный резолв с отложенным вызовом получается.
2985.92 2995.28 "Анатолий Кулаков" И, соответственно, пожалуйста, здесь тоже вам Service Locator в полный рост используется, всеми считается best practice, потому что вот так он нас выручает.
2995.28 3005.56 "Анатолий Кулаков" И Джимми делает вывод, что в принципе, если вам не нужно Service Locator использовать в вашем приложении, то, пожалуйста, не используйте его.
3005.56 3011.16 "Анатолий Кулаков" Но есть сценарии, в которых использовать его просто необходимо, без этого вы никуда не денетесь.
3011.16 3014.60 "Анатолий Кулаков" И один из таких сценариев, как раз таки, он и нашел для медиатора.
3014.60 3024.52 "Анатолий Кулаков" То есть, то, что медиатор вас заставляет использовать Service Locator, он не видит ничего плохого, потому что при этом медиатор решает очень много понятных проблем, которые не решить иначе.
3024.52 3034.04 "Анатолий Кулаков" Те же самые Behaviour, Cross-Cutting Conserve, упрощение ваших классов, упрощение вообще работы с из контроллеров, с хендлерами.
3034.04 3040.12 "Анатолий Кулаков" То есть, он делает просто, он делает понятно и при этом приходится кое-чем заплатить.
3040.12 3043.32 "Анатолий Кулаков" Вот заплатили именно как раз Service Locator.
3043.32 3049.28 "Анатолий Кулаков" И Джимми призывает вас думать головой, что каждый шаблон это обязательно какой-то трейд-офф.
3049.28 3054.56 "Анатолий Кулаков" У него есть плюсы, у него есть минусы и не надо ко всему относиться как к чему-то черно-белому.
3054.56 3057.64 "Анатолий Кулаков" Вот такой, в принципе, основной вывод статьи.
3057.64 3075.36 "Анатолий Кулаков" Нужно еще отметить, что там шикарные комментарии к этой статье, потому что в комментарии пришел Марк Симон и сказал, что в принципе за все эти годы он не встречал никогда проблемы, где Service Locator нельзя было бы переписать на нормальный человеческий строго типизированный подход.
3075.36 3077.64 "Анатолий Кулаков" Поэтому он не согласен с выводами Джимми.
3077.64 3083.44 "Анатолий Кулаков" Он все-таки продолжает утверждать, что Service Locator это адский антипаттер и использовать его ни в какие стороны нельзя.
3083.44 3096.64 "Анатолий Кулаков" И в комментах он рассказывает, каким образом делать свой Message Dispatcher, каким образом правильно организовать конструкторы, чтобы они не приводили к таким проблемам и все это прочее.
3096.64 3101.68 "Анатолий Кулаков" Я вам советую отправиться по ссылочкам и прочитать, потому что Марк великолепен.
3101.68 3108.84 "Анатолий Кулаков" Он просто на каждое свое слово практически бросает из своей статьи, которые раскиданы примерно по 15 годам его блога.
3108.84 3118.52 "Анатолий Кулаков" И на каждый пример у него буквально по несколько статей, в каждой статье рассматривается плюс и минусы со всех сторон, как переделать и как сделать.
3118.52 3120.44 "Анатолий Кулаков" В общем, Марка я обожаю.
3120.44 3122.16 "Анатолий Кулаков" Как вы, наверное, уже все поняли.
3122.16 3125.96 "Анатолий Кулаков" Поэтому крайне рекомендую его статьи как знакомлению.
3125.96 3132.32 "Анатолий Кулаков" Ну и надеюсь, про Service Locator вам тоже стало немножко ясно и про медиатор что-то в голове у вас уже сформировалось.
3132.32 3154.28 "Игорь Лабутин" Да, мне нравятся как раз такие статьи, что даже, может быть, спорят и спорят, но по мере спора именно ты выясняешь какие-то практически полезные моменты, которые можно подсмотреть, подумать, придумать, как сделать у себя, если не знал, или подумать, чем заменить какие-то свои решения, если вдруг выясняешь по мере чтения статьи, что тебе не нравится, видя какие-то аргументы.
3154.28 3160.00 "Игорь Лабутин" Так что читайте, изучайте и, возможно, это как-то правильно повлияет на структуру вашего кода.
3160.00 3164.44 "Анатолий Кулаков" Да, кстати, у Марка Симона недавно вышло второе переиздание его книги про dependency injection.
3164.44 3167.28 "Анатолий Кулаков" В общем, я читал первую книгу и она была великолепна.
3167.28 3171.36 "Анатолий Кулаков" То есть там тоже не просто так, как зарегистрировать контейнеры и как им резолвить.
3171.36 3177.64 "Анатолий Кулаков" Там он описывает именно все с точки зрения глубокой теории.
3177.64 3184.00 "Анатолий Кулаков" То есть почему надо инжектить, как надо резолвить, кто сколько должен жить, как структурировать и делить объекты.
3184.00 3191.88 "Анатолий Кулаков" То есть вот это глубокая, хорошая, интересная архитектурная теория классиков, интерфейсиков, компонентов, слоев.
3191.88 3193.24 "Анатолий Кулаков" Вот крайне рекомендую.
3193.24 3199.64 "Анатолий Кулаков" Пишет он прекрасно, потому что английский – это не его родной язык, и очень четко, доходчиво, структурированно.
3199.64 3206.52 "Анатолий Кулаков" Я думаю, что второе издание не должно уступать первому, и поэтому книга крайне рекомендуется к ознакомлению.
3206.52 3207.52 "Игорь Лабутин" Да, поддерживаю.
3207.52 3210.44 "Игорь Лабутин" Второе издание не читал, но первое действительно когда-то давно читал.
3210.44 3211.44 "Игорь Лабутин" Все так.
3211.44 3212.44 "Игорь Лабутин" Пойдем дальше.
3212.44 3218.84 "Игорь Лабутин" Дальше у нас, давай вернемся немножко во внутренний институт НЕТа, давно мы по ним не ходили.
3218.84 3233.60 "Игорь Лабутин" И в конце прошлого года вышла серия статей от двух авторов, ну точнее, это две независимых серии, на которых мы очень часто ссылаемся, от Стива Гордона и от Эндрю Лока, про то, как устроен стрингбилдер.
3233.60 3241.00 "Анатолий Кулаков" Да, странное совпадение, в принципе, действительно два именитых автора, очень глубоко оба пишут, и как-то они вместе так синхронизировались.
3241.00 3255.32 "Игорь Лабутин" Да, вот они вроде как по внешним признакам никак не договаривались, немножко рассмотрели, ну и были какие-то общие моменты, были какие-то разные моменты в этом сборнике статей, всего вышло 9 статей, 3 от Стива и 6 от Эндрю Лока.
3255.32 3261.08 "Игорь Лабутин" И, соответственно, мне показалось интересным заглянуть таки в стрингбилдер, посмотреть, как он устроен.
3261.08 3268.96 "Игорь Лабутин" Наверняка многие знают, но может быть не все, может быть для кого-то это будет новостью, кто-то просто вспомнит, как же все это на самом деле устроено.
3268.96 3276.28 "Анатолий Кулаков" Интересно, многие ли разработчики способны предсказать, что под прострингбилдер два автора могут наклепать 9 статей?
3276.28 3283.92 "Анатолий Кулаков" Вот что там внутри такого можно описать, чтобы вот глубокие авторы с большими основательными статьями нашли там какой-то материал?
3283.92 3291.04 "Анатолий Кулаков" Вот те, кто жалуются, что нету тему, чтобы написать статью или нету темы, чтобы сделать доклад.
3291.04 3295.32 "Анатолий Кулаков" Вот отличный пример, просто возьмите стрингбилдер и там уже материалы на несколько часов.
3295.32 3301.08 "Игорь Лабутин" Ну, часов может быть нет, но по крайней мере на какой-то небольшой докладик точно наберется.
3301.08 3307.32 "Игорь Лабутин" Итак, давай сначала вспомним вообще зачем такая сущность как стрингбилдер появилась, зачем она нужна.
3307.32 3310.00 "Анатолий Кулаков" Это кстати один из моих любимых вопросов на собеседовании,
3310.00 3314.56 "Игорь Лабутин" ну-ка давай. Эээ, чтобы склеивать строчки, я прошел собеседование?
3314.56 3318.36 "Анатолий Кулаков" У нас для этого есть конкат, нам не нужен стрингбилдер, чтобы склеивать строчки.
3318.36 3320.12 "Анатолий Кулаков" Не, не говоря уже о плюсике.
3320.12 3324.28 "Игорь Лабутин" Да, плюсик это наше все, а еще можно делать какой-нибудь link you, select.
3324.28 3327.36 "Игорь Лабутин" Не, не, погоди, это уже высший уровень пошел.
3327.36 3330.48 "Игорь Лабутин" Сегрегейтом там прошлого состояния, вот это все.
3330.48 3355.40 "Игорь Лабутин" Но короче, смысл в том, что действительно, если вам нужно склеивать много строчек, вы возможно их напишите, например, склеивание плюсиков в цикле, но это будет не очень здорово, потому что, как известно, операция конкат, ну или плюсик, выдает новую строчку, то есть аллоцирует ее в памяти, а поскольку строки у нас в тотнете неизменяемые, то когда вы к ним подклеиваете третью строчку, то результат предыдущий, собственно, можно уже выкинуть.
3355.40 3363.48 "Игорь Лабутин" Ну и в цикле, если вы их много склеиваете, у вас будет копиться много-много-много промежуточных строчек, которые по сути никуда не нужны, не будут выкидываться.
3363.48 3397.00 "Игорь Лабутин" Это все не очень здорово, если нам нужно собирать сложные строчки, поэтому придумали такой класс как стрингбилдер, он, по-моему, в 1.x даже в фреймворке появился, боюсь наврать, может быть во 2, не знаю, не помню точно, но по-моему он очень древний, и его смысл простой, он внутри использует не строчку, а внутри использует набор массивов из чаров, и потихонечку их заполняет тем, что вы туда пытаетесь аппендить, добавлять, удалять, инсертить, и в конце у него можно получить строчку, которая будет аллоцирована один единственный раз.
3397.00 3400.96 "Анатолий Кулаков" Ну тут нужно отметить, что в процессе эволюции его внутреннее устройство менялось.
3400.96 3419.24 "Игорь Лабутин" Да, конечно, оно менялось, оно было разным, там есть разные тонкости, разные оптимизации, но нам сейчас вот со стороны, когда ты на него смотришь и используешь, кажется, что все просто, ты просто создаешь стрингбилдер, ты туда вызываешь какое-то количество методов аппенд, потом говоришь тут стринг, и получил строчку.
3419.24 3429.20 "Игорь Лабутин" И все вроде нормально, но на самом деле дальше возникает не то чтобы проблема, но некоторая особенность.
3429.20 3457.60 "Игорь Лабутин" С одной стороны, и это то, что я иногда спрашиваю на собеседованиях, что мы избавились от локации строчек промежуточных, но во-первых, мы не избавились от локации, хранить-то все равно где-то надо, поэтому массив это все равно будет аллоцироваться, плюс стрингбилдер это тоже класс, он тоже будет аллоцироваться, это же не структурка, вот, и поэтому если вы, например, склеиваете много, но коротких стройщиков, то тут еще вопрос, что выгоднее, и надо как-то искать баланс.
3457.60 3466.08 "Игорь Лабутин" Ну ладно, это уже совсем детали, смысл в том, что действительно мы аллоцируем стрингбилдер, кидаем туда нужные нам строчки, получаем в конце новую строчку.
3466.08 3469.20 "Игорь Лабутин" Стрингбилдеру все то, что мы в него кидаем, надо как-то хранить.
3469.20 3479.68 "Игорь Лабутин" Хранит он это все в массивах символов, причем по дефолту, если вы создаете стрингбилдер без аргументов, дефолтным конструктором, он выделяет место под 16 символов всего.
3479.68 3502.00 "Игорь Лабутин" То есть если вы знаете, что ваша строчка будет заведомо длиннее, не создавайте стрингбилдер вот таким дефолтным, потому что как только вы превысите 16 символов, там начнется всякая разная катавасия с балансированием новых массивов, удлинением и так далее, и это лишние накладные расходы.
3502.00 3511.80 "Игорь Лабутин" Поэтому если вы заранее знаете хотя бы пример, хотя бы нижнюю границу того, сколько будет символов в строке, лучше передайте в конструктор, будет полезно.
3511.80 3518.40 "Анатолий Кулаков" Я хочу подчеркнуть, что как раз-таки ресайзы листов, аллокации, перемещения - это очень заметные расходы.
3518.40 3523.56 "Анатолий Кулаков" Поэтому если вы посмотрите в профайле, и у вас будут там ресайзы, то они скорее всего будут у вас на первом месте.
3523.56 3527.00 "Анатолий Кулаков" Вы там не увидите никаких ни боксингов, ни инлайнингов, ни прочих глупостей.
3527.00 3529.28 "Анатолий Кулаков" И вот ресайзы - это реально очень-очень дорого.
3529.28 3534.48 "Игорь Лабутин" Да, но фишка-то как раз в том, что стрингбилдер ресайзов не делает никогда.
3534.48 3538.20 "Игорь Лабутин" То есть стрингбилдер никогда не ресайзит внутренние array.
3538.20 3542.08 "Игорь Лабутин" Единственное, что он делает - он их аллоцирует дополнительно.
3542.08 3545.44 "Игорь Лабутин" Причем каждый раз аллоцируя, он увеличивает размер.
3545.44 3547.20 "Игорь Лабутин" Но сейчас мы до этого доберемся.
3547.20 3557.00 "Игорь Лабутин" И поэтому если вы, например, все время генерируете строчки длиной по 30 символов, то у вас каждый стрингбилдер, каждый такой использованный стрингбилдер, будет генерировать два массивчика по 16 символов.
3557.00 3562.08 "Игорь Лабутин" И заметить такое на профайле, ну можно, конечно, но требует некоторого искусства.
3562.08 3563.08 "Игорь Лабутин" Вот.
3563.08 3567.56 "Игорь Лабутин" Поэтому внимательнее и старайтесь capacity передавать заранее.
3567.56 3568.56 "Игорь Лабутин" Ну ладно.
3568.56 3572.28 "Игорь Лабутин" Давайте дальше проговорим, что происходит дальше.
3572.28 3574.64 "Игорь Лабутин" Как мы сказали, хранится в массивах.
3574.64 3577.84 "Игорь Лабутин" Массив хранит, очевидно, кусочек только строки.
3577.84 3584.72 "Игорь Лабутин" И если нужно добавить новый кусочек строки, то мы создаем новый массив и надо каким-то образом их связать.
3584.72 3591.64 "Игорь Лабутин" Так вот, хитрость в том, что стрингбилдер не хранит внутри списка массивов или что-то подобного.
3591.64 3598.08 "Игорь Лабутин" Стрингбилдер хранит копию, точнее, стрингбилдер - это односвязный список стрингбилдеров.
3598.08 3605.16 "Игорь Лабутин" То есть, когда вы создаете экземпляр стрингбилдера, у вас есть референс, который хранится, допустим, в локальной переменной.
3605.16 3621.84 "Игорь Лабутин" Но когда стрингбилдер внезапно понимает, что ему не хватает места, он будет создавать копию вашего объекта стрингбилдер, на него вешать ссылочку, а в вашем текущем стрингбилдере подвинять все внутренние поля, как будто это новый стрингбилдер.
3621.84 3622.84 "Игорь Лабутин" Вот.
3622.84 3628.32 "Игорь Лабутин" И вот здесь появляется связанный список стрингбилдеров, в котором данные строки лежат от конца к началу.
3628.32 3633.76 "Игорь Лабутин" То есть, сначала последний кусочек, потом предпоследний, пред, пред, пред, пред, и так пока не доберется до самого первого.
3633.76 3640.72 "Игорь Лабутин" Плюс каждый из объектов хранит смещение, точнее, сколько символов в строке есть до этого стрингбилдера.
3640.72 3643.80 "Игорь Лабутин" Ну, чтобы понимать вообще, в каком месте строки он находится.
3643.80 3646.00 "Игорь Лабутин" Вот это все потом используют для всяких инсертов и ремовов.
3646.00 3647.72 "Игорь Лабутин" Мы до этого дойдем.
3647.72 3649.44 "Игорь Лабутин" Давай поговорим про аппенды.
3649.44 3652.20 "Игорь Лабутин" Аппенды - штука интересная, там есть несколько оптимизаций.
3652.20 3667.52 "Игорь Лабутин" Во-первых, если вы аппендите один или два символа, я вот всегда, знаешь, думал, когда, особенно поначалу начинал использовать стрингбилдеры, нормально ли писать много раз аппенд и какой-нибудь там одиночный, не знаю, разделитель, сепаратор с одним символом.
3667.52 3674.44 "Игорь Лабутин" Вот, так вот нормально, потому что если вы передаете строку из одного или двух символов, то он просто делает присваивание массивчика.
3674.44 3686.00 "Игорь Лабутин" Никаких там мем-мувов, никаких копирований, ничего не происходит, он просто делает обычный индекс, ну, доступ к внутреннему массиву по индексу и присваивает туда то, что вы передали, но только если строка из одного или двух символов.
3686.00 3697.16 "Игорь Лабутин" Если же строка длиннее, то делается нормальный честный мем-мув, то есть копирование памяти через unmanaged код, видимо, а может быть это уже и менеджмент реализации, я не смотрел настолько детально.
3697.16 3703.28 "Игорь Лабутин" Если же полная строчка не влезает в тот кусочек буфера, который остался внутренний, то там происходит интересное.
3703.28 3711.32 "Игорь Лабутин" Во-первых, как я сказал, мы аллоцируем новый чанг, вот этот самый чаров.
3711.32 3723.44 "Игорь Лабутин" По дефолту размер этот будет удвоенный по отношению к прошлому, но не более 8000 байт, для того чтобы он точно не попал в Lara Chopin's heap, ну и вообще был не очень большой.
3723.44 3737.20 "Игорь Лабутин" Это важно, но при этом, если вы, например, будете аппендить в stringbuilder строку, в которой находится 10 000 символов, то stringbuilder зааллокейтит массив на 10 000.
3737.20 3752.20 "Игорь Лабутин" То есть он аллокейтит не более 8000, но если вы аппендите что-то, что не влезает в 8000, то один аппенд никогда не будет добавлен в несколько чангов, максимум в два, в тот, который мы сейчас заполняем, и в новый.
3752.20 3761.12 "Игорь Лабутин" Поэтому не удивляйтесь, если вдруг у вас в stringbuilder появятся какие-то очень большие врасти, массивы они бывают, несмотря на ограничения в коде вроде как.
3761.12 3779.72 "Игорь Лабутин" Дальше, соответственно, мы салонсировали массив, мы копируем полностью текущий stringbuilder, то есть мы создаем копию текущего stringbuilder, то есть новый класс stringbuilder со всеми полями, со всеми offset'ами, то есть это занимает, если я правильно помню, порядка 50 байт со всеми ссылочками и так далее.
3779.72 3796.56 "Игорь Лабутин" И в текущем stringbuilder обнуляем всякие offset'ы, reference'ы и так далее, и сохраняем именно в текущий stringbuilder, тот, на который у вас есть ссылка в вашем коде, последний заалоцированный чанг символов, и туда мы будем дальше писать.
3796.56 3812.52 "Игорь Лабутин" Это, соответственно, про хранение, поэтому когда вас спрашивают, как же устроен внутри stringbuilder, это не просто, если вы хотите совсем разбираться, это не просто список массивов, это список stringbuilder'ов с кучей мета-информации, вдовесок.
3812.52 3815.08 "Игорь Лабутин" Дальше немножко еще про апенды.
3815.08 3859.88 "Игорь Лабутин" Можно не бояться вызывать апенды на примитивных типах, то есть когда вы вызываете апенд от int'а или апенд от double'а или апенд еще от чего-то, там все сделано очень умно, там все вызывается специальная внутренняя функция, которая называется append_span_formatable, то есть если переданный тип поддерживает ispan_formatable, а такой интерфейс поддерживает все стройные типы, то вызывается не object to string, а специальный try_format метод, которому передается span, который указывает сразу на буфер, то есть чиселка либо какой-нибудь boolean, либо еще кто-то форматируется непосредственно сразу в целевой буфер без аллокейта промежуточной строки.
3859.88 3921.34 "Игорь Лабутин" И в последнем дотнете, или в пятом, по-моему, все-таки, если я правильно помню, а может быть даже в шестом, что-то я сейчас начал сомневаться, завезли новый метод, называется append_join, то есть если вам когда-то приходилось писать append от string_join, то теперь есть метод append_join, куда можно передать тот же набор параметров, то есть separator и innumerable там, или массив строчек, точнее массив там даже не строчек, там массив объектов t можно передать, после чего append_join сделает, соответственно, то что делал бы string_join, то есть он по крайней мере не будет аналтзиловать, сначала джойнить строчку, аналтзировать под нее память, а потом ее копировать в целевой string_builder, он сразу будет все делать в string_builder, но к сожалению там не работает вся эта магия со span_formatable, то есть если вам нужно допустим сджойнить массив, не знаю, int через запятую, то делайте это в честном цикле, так будет эффективнее по памяти, иначе будет вызываться честный to_string у int и это будет аналтзироваться, аналокация памяти.
3921.34 3939.86 "Игорь Лабутин" Это были append, после того как мы поappended обычно нужно получить строчку, вот для этого вызывается метод to_string, она сразу аналтзирует строчку нужной длины, потому что она знает сколько данных запихали в string_builder, ну и дальше аккуратненько пробегается по этому связанному списку, копируя туда все данные.
3939.86 3954.70 "Игорь Лабутин" Причем поскольку связанный список, как мы помним, он идет от конца к началу, в смысле что в head в голове этого списка лежит последний кусочек строки, то и строка заполняется как бы с конца в начало, но благодаря тому что в каждом string_builder есть смещение, он заполняет все правильно.
3954.70 3979.62 "Игорь Лабутин" При этом если вам вдруг почему-то мне в жизни ни разу не пригодилось, нужен только какой-то кусочек готовой строки, то у to_string есть overload, который получает старт и длину, то есть если вы получаете строку из string_builder, а потом внезапно от нее сразу же отрезаете какой-то, делаете под строку, то лучше сразу вызвать to_string, потому что он будет эффективно генерировать только нужный кусочек строки.
3979.62 3995.10 "Игорь Лабутин" Собственно все, дальше есть некоторые тонкости оптимизации того, как работает remove и insert, то есть в string_builder тоже я не то чтобы сильно часто видел, чтобы этим пользовались, но он поддерживает операцию remove и insert, то есть можно убрать произвольный кусочек строки, либо добавить.
3995.10 4013.06 "Игорь Лабутин" Там есть важный момент, только insert сейчас не работает с ispan_formatable, то есть если вы insertите какие-то int и так далее в серединку, он будет вызываться через to_string и опять же аллоцировать, так что если вы про оптимизацию работы с памятью, то лучше remove и insert не делать, делать это как-то в логике чуть раньше.
4013.06 4057.94 "Игорь Лабутин" Дальше интересное, string_builder как вы поняли, он тоже класс, его нужно аллоцировать, это тоже память, плюс смотрите, допустим вы собираете очень много раз строчки, которые ну не знаю, там по 200 символов, то есть вы аллоцируете string_builder, он там внутри зааллоцирует цепочку буферов, предположим, что вы не сможете сразу сказать capacity, и получится, что, а потом мы выкинем string_builder, то есть мы получим строчку, выкинем string_builder, соответственно все эти буферы освободятся, будет собран garbage_collector, потом мы снова это сделаем, для следующего допустим, request или еще как-то, и получается, что вроде есть какое-то не очень эффективное использование, поэтому string_builder очень часто я видел и CLR так делает и вообще рекомендует кэшировать.
4057.94 4062.38 "Игорь Лабутин" Как для этого, как вообще это делать?
4062.38 4080.26 "Игорь Лабутин" Если посмотреть в исходнике .NET, там можно найти класс называемый string_builder_cache, там не сильно хитрая логика, вы можете его просто реплицировать к себе, скопировать, либо сделать что-то подобное, мы у нас иногда даже не делаем там слишком хитрую логику и делается все простым способом.
4080.26 4102.02 "Игорь Лабутин" Во-первых, кэшируется это все в thread static переменных, чтобы не париться с многопоточным доступом, обычно вы очень редко string_builder как-то передаете между потоками, долго-долго в него собираете, то есть в большинстве случаев такое кэширование имеет смысл именно для таких небольших коротких сессий по сборке строки, которые очень часто даже вообще в рамках одной функции происходят.
4102.02 4104.06 "Игорь Лабутин" И тут thread static прям хорош.
4104.06 4111.26 "Игорь Лабутин" Но вот этот string_builder_cache из .NET, он при этом кэширует только string_builder длиной не более чем 360 символов.
4111.26 4124.54 "Игорь Лабутин" Они объясняют это тем, это магическая константа, подобранная экспериментальным путем, объясняют это тем, что поскольку он thread static, то будет копия этого, копия кэша в каждом потоке.
4124.54 4142.58 "Игорь Лабутин" Ну и если потоков у вас много, то будут висеть невозможно не использованные string_builder с кучей буферов, на которые они ссылаются, если вдруг какой-нибудь такой string_builder из него будет сгенерен строка длиной 2 килобайта, 10 килобайт, 300 килобайт, кто знает.
4142.58 4153.70 "Игорь Лабутин" Поэтому у них кэш написан таким образом, что если вы возвращаете string_builder в кэш обратно, и он при этом очень длинный внутри, капасит у него большой, то он будет просто выброшен и не вернется в кэш.
4153.70 4155.82 "Игорь Лабутин" А если маленький, то сохранится обратно в кэш.
4155.82 4157.54 "Игорь Лабутин" Ну и почистится, понятное дело.
4157.54 4169.26 "Игорь Лабутин" У него есть метод clear, который на самом деле просто, он очень эффективный, он просто ставит индекс в нолик, если я правильно помню, но при этом не отрезает все буферы.
4169.26 4176.26 "Игорь Лабутин" И как только вы будете делать аппенды, он начнет делать аппенды в уже существующие буферы, что будет довольно эффективно.
4176.26 4185.14 "Игорь Лабутин" Если же вам нужна совсем хорошая оптимизация, и вы не хотите ничего кэшировать, посмотрите в сторону value string_builder.
4185.14 4194.22 "Игорь Лабутин" Это тоже тип, который есть внутри, он не паблик, потому что он принимает в себя два, у него есть два варианта конструктора.
4194.22 4200.42 "Игорь Лабутин" Один конструктор принимает span, и классическое метод использования это передать туда результат вызова stack_alloc.
4200.42 4223.46 "Игорь Лабутин" То есть если вы знаете, что внутри какой-то функции вы форматируете, не знаю, два int через запятую, это значит будет точно не больше 21-25 символов, то вы делаете просто stack_alloc на 30 символов, передаете в value string_builder, и у вас вообще не будет никаких аллокаций в heap, все будет чисто на stack собрано.
4223.46 4232.78 "Игорь Лабутин" Либо вы туда передаете в capacity, в value string_builder, и тогда он возьмет подходящий массив из array_pool, но и вернет его в конце.
4232.78 4250.34 "Игорь Лабутин" Но поскольку value string_builder это ref-структура, это короче такая прям хардкорная-хардкорная оптимизация, CLR, дотент-разработчики, ну команда решила, что нет, это недостаточно безопасный тип для того, чтобы выставлять его наружу, и если вам такой нужен, ну напишите сами, там несложно.
4250.34 4253.82 "Игорь Лабутин" Но можно посмотреть в исходничке, посмотреть, как это делается.
4253.82 4259.74 "Игорь Лабутин" Поэтому если вы генерируете прям очень много небольших коротких строчек, то это прям то, что нужно.
4259.74 4263.42 "Игорь Лабутин" Вообще не будет никаких аллокаций на string_builder, ну кроме финального to_string, конечно.
4263.42 4264.70 "Игорь Лабутин" Финальный to_string никуда не деть.
4264.70 4273.62 "Игорь Лабутин" Вот, примерно состав 9 статей, рассказанных за примерно 10 минут, или наверное меньше даже.
4273.62 4276.42 "Игорь Лабутин" Но это очень кратко, без деталей.
4276.42 4290.74 "Игорь Лабутин" А если вам интересно, как это все работает со схемами, там диаграммки, детально описаны логаритмы вставки и удаления, как находить новый chunk, там куда копируется, какие оптимизации применяются, то читайте серию статей, они очень хорошо написаны, с картинками, и прям все
4290.74 4297.78 "Анатолий Кулаков" понятно. Отлично, мне кажется, таких продвинутых разработчиков мы уже давно покрыли с помощью твоих string_builder.
4297.78 4301.86 "Анатолий Кулаков" Давай теперь попробуем немножко не потерять аудиторию среди начинающих.
4301.86 4304.06 "Анатолий Кулаков" И вот есть как раз легенькая статейка.
4304.06 4318.10 "Анатолий Кулаков" Это называется прям таким громким названием, что 10 самых наилучших, крутецких и прекрасных C# Nuget пакета для того, чтобы улучшить вашу работоспособность в 2022 году.
4318.10 4323.58 "Анатолий Кулаков" Ну просто собрали все подряд, и цифры, и improvement, и продуктивность, и ведь еще и год добавили.
4323.58 4332.14 "Анатолий Кулаков" Ну давай посмотрим, что нам предлагают знающие люди для того, чтобы улучшить нашу работоспособность, и примерно быстренько заценим, улучшит оно у нас что-нибудь или нет.
4332.14 4344.14 "Анатолий Кулаков" Итак, здесь автор собрал на одной страничке 10 прекрасных библиотечек, пакетиков, как вы уже поняли из названия, и давай кратко пробежимся и посмотрим, что здесь есть интересного.
4344.14 4346.78 "Анатолий Кулаков" На первое место почему-то у нас поставлен REST#.
4346.78 4348.50 "Анатолий Кулаков" Ты пользовался REST#?
4348.50 4362.78 "Игорь Лабутин" Я не пользовался REST# напрямую, но REST# всегда входил в стандартный код ген от Swagger, то есть если вы генерите Swagger код геном C# клиент по API спецификации, то внутри будет REST#.
4362.78 4371.38 "Анатолий Кулаков" Я пользовался REST# очень-очень давно, где-то лет 10 назад, весь его смысл заключается в том, что он вам дает хорошие оберточки над HTTP клиентом.
4371.38 4384.86 "Анатолий Кулаков" То есть вы можете легко посылать запросы, GET, POT, POST, вы можете делать аутентификацию, авторизацию, у вас там сериализация сразу встроена, не нужно было заботиться о каком-то дополнительном библиотеке, которая все это умела делать.
4384.86 4389.26 "Анатолий Кулаков" В общем, такой очень полезный со всех сторон враппер над HTTP клиентами.
4389.26 4399.26 "Анатолий Кулаков" Пользовался я им 10 лет назад, потому что самые первые клиенты, у них была очень маленькая функциональность, очень слабая, и более того, их даже не было.
4399.26 4410.06 "Анатолий Кулаков" То есть изначально все HTTP запросы там бросались, ходили с помощью WebRequests, WebResponse, их там нужно было руками как-то собирать, заполнять, экранировать.
4410.06 4414.82 "Анатолий Кулаков" В общем, все это было довольно муторно, и тогда Redsharp выглядел в принципе как глоток свежего воздуха.
4414.82 4422.54 "Анатолий Кулаков" Потом начал появляться уже HTTP Client, и он с каждым релизом становился все лучше, все интереснее, все мощнее.
4422.54 4428.38 "Анатолий Кулаков" Вот в последних релизах у него уже даже есть встроенная сериализация, десериализация и так далее.
4428.38 4440.26 "Анатолий Кулаков" И в общем, как только начал появляться HTTP Client, то для меня лично Redsharp полностью как бы ушел, необходимость в нем отпала, и с каждым годом она отпадала все больше и больше.
4440.26 4444.78 "Анатолий Кулаков" В общем, поэтому я не могу сказать, что на 2022 год это какая-то мега необходимая библиотека.
4444.78 4465.82 "Игорь Лабутин" Ну, единственное, что надо знать, что поскольку она действительно довольно древняя, то вы, если сейчас начнете гуглить про него, вы найдете огромное количество упоминаний про то, что блин, Redsharp использует WebRequest, как Толя, собственно, и сказал, потому что действительно WebRequest был предпочтительным способом использования, ну точнее вызывая HTTP, до появления нормального HTTP Client.
4465.82 4476.58 "Игорь Лабутин" Но проблема в том, что в современном .NET, то есть пятой там, даже уже .NET Core 3.0, WebRequest построен внутри на HTTP Client, но построен не очень эффективно.
4476.58 4492.30 "Игорь Лабутин" То есть он оставлен ради backward compatibility, то есть он на PIT поддерживает тот же самый, но работает он гораздо менее эффективно, то есть он делает огромное количество локейтов, он очень неэффективный, у него там, он синхронный, и там много всяких разных проблем.
4492.30 4550.30 "Игорь Лабутин" И с Redsharp была именно такая проблема, мы ради, точнее из-за этого даже запланировали переход со сваггер-код гена на NSWAG, который нормально использует HTTP Client современный, но буквально вот в несколько последних недель, сейчас я не вспомню точную дату, Алексей Тимарев анонсировал, что все, новая версия Redsharp, 107-я по-моему, сейчас боюсь наврать с нумерацией, она все переписана точно, выкинут вебриквест и переписана на нормальный HTTP Client, поэтому если вдруг вам зачем-то интересно API Redsharp, ну может действительно нужно, то он теперь, начиная со 107-й версии написан на HTTP Client, и поэтому можно теперь забыть про все старые статьи, которые говорят, что там вебриквест и все неинтересно, там ищутся в огромное количество, если поискать, и Redsharp, ну наверное сейчас будет нормально юзабелен, хотя опять же, да, я согласен, но я не очень знаю почему, зачем он нужен сейчас.
4550.30 4553.50 "Анатолий Кулаков" Следующий небезызвестный пакет – это Newtonsoftjson.net.
4553.50 4558.26 "Анатолий Кулаков" Игорь, удавалось ли тебе в жизни попробовать Newtonsoftjson.net?
4558.26 4570.54 "Игорь Лабутин" Да, ну не то чтобы прям попробовать, мы пользовались, я особо не пробовал, альтернатив-то, ну были альтернативы, ладно, врать не буду, конечно всегда были альтернативы сериализации,
4570.54 4573.70 "Анатолий Кулаков" но… Неужели ты забыл про Data Contract
4573.70 4597.62 "Игорь Лабутин" Serializer? Я пользовался VCF, Data Contract Serializer – это мое все, поэтому как бы, конечно… Не испугаешь. Да, тут добавили JSON и JSON, ну конечно JSON.NET всегда был дефолтом, и он до сих пор остается максимально, наверное, фичастым из всех, хотя конечно, System Text JSON тоже потихонечку набирает силу и популярность, благо, что он встроенный.
4597.62 4622.94 "Анатолий Кулаков" Ну в 2022 году я бы тоже его характеризовал уже как все-таки Legacy библиотека, то есть это действительно было наше все, многие годы, это библиотека для легкого сериализации, децерализации JSON и из него, для отличного доступа с помощью линку JSON объектам, GObject, GArray и так далее, чтобы вам не парсить все дерево или динамически каким-то образом составлять и читать JSON объект, очень тоже полезная библиотека.
4622.94 4666.82 "Анатолий Кулаков" Безусловно, она сейчас самая фичастая, потому что многие годы очень активно развивалась автором, у нее есть куча настроек, враперов, совместимостей и прочего, прочего, прочего, но теперь рекомендуемый все-таки стандарт это System Text JSON, который официально поддерживается уже Microsoft, из коробки есть везде и в многих бичмарках намного производительнее, потому что как раз-таки начал использовать все новомодные внутренние спаны, memory, локаторы и прочие вот эти переюзабельные пулы и в принципе на многих бичмарках рвет, конечно, Newtonsoft, да и более того, сам товарищ Newtonsoft как бы перешел работать в Microsoft и теперь трудится над протоколом gRPC и наверняка еще прикладывает руку к стандартному System Text JSON.
4666.82 4691.78 "Анатолий Кулаков" Вот, поэтому, опять же, на 2022 год рекомендовать ее точно нельзя, если она у вас есть, то может быть даже стоит смотреть в сторону миграции, если вы не слишком сильно используете кастомизацию, настройки и так далее, то это не должно вызвать у вас проблем, у Microsoft есть отдельная статейка, которая рассказывает, как это сделать, ну а если вы там глубоко засели на custom конвертерах и custom акселизаторах, то может ничего страшного не произойдет, если вы продолжите дальше ей пользоваться.
4691.78 4708.62 "Анатолий Кулаков" Интересный момент для тех, кто не знал вдруг, что Newtonsoft JSON.NET, она умеет также работать с XML, более того, она умеет конвертировать XML в JSON и обратно, по-моему, JSON в XML, вот тоже ни разу на практике не пользовался, но она умеет.
4708.62 4716.66 "Анатолий Кулаков" Следующая библиотечка, вот это вот, наверное, самая главная, самая первая библиотека, которая должна быть в топе этого списка, это SiriLog.
4716.66 4737.82 "Анатолий Кулаков" Это родоначальник вообще структурного логирования и замечательная библиотека, которая создана просто-напросто для банального логирования, но правильного, структурного, с множеством провайдеров, с огромным числом поддерживаемых систем, куда он может писать, с классными интерфейсами, продуманной внутренностью, крутыми оптимизациями, которые развиваются до сих пор.
4737.82 4746.86 "Анатолий Кулаков" Я каждый день вижу там какие-то импровменты, какие-то новые фичи, то есть много-много лет, и автор там практически ни на день не останавливал разработку этой библиотеки.
4746.86 4762.34 "Анатолий Кулаков" Опять же, непонятно, что там можно еще делать, но она и так прекрасна, но продолжает нас, в принципе, радовать, даже несмотря на стандартный микрософтовский логер, несмотря на главенствующие позиции Nlog, который у нас был еще до появления SiriLog.
4762.34 4767.34 "Анатолий Кулаков" В общем, он, SiriLog сейчас поборол, мне кажется, всех логеров и сейчас является стандартом де-факто.
4767.34 4778.10 "Анатолий Кулаков" Его абсолютно используют все в микрософте, все разработчики фреймворка и Рослина, и все подряд, в общем, там, где можно, например, в самплах у них всегда фигурирует SiriLog.
4778.10 4780.38 "Игорь Лабутин" Ну, да, библиотека полезная, так что тут, наверное, добавить
4780.38 4782.38 "Анатолий Кулаков" нечего. Тогда пойдем дальше.
4782.38 4786.30 "Анатолий Кулаков" Дальше нам предлагают рассмотреть, наконец-то, тестовый фреймворк.
4786.30 4789.98 "Анатолий Кулаков" Ну куда же мы без тестов, и здесь почему-то NUnit.
4789.98 4792.50 "Анатолий Кулаков" Ну, наверное, из-за уважения к стретчикам.
4792.50 4819.38 "Игорь Лабутин" Ну, я бы сказал, что NUnit мне нравится гораздо больше XUnit, то есть я, у нас сейчас проект полностью мы перевели в итоге с XUnit на NUnit, потому что, не знаю, XUnit я как-то не очень понимаю его методологию, я не понимаю, ну, то есть меня больше всего, конечно, расстраивает, так скажем, вот сложность получения выхлопа тестов, вот так скажем.
4819.38 4834.66 "Игорь Лабутин" То есть любой выхлоп консольный тестов, да, консольный, либо какой-либо другой, получить из XUnit надо вот писать эти injected itext output, как там, что-то там, не помню что, и NUnit в этом смысле как-то концептуально мне проще и понятнее.
4834.66 4854.62 "Анатолий Кулаков" Ну, да, но я только склоняюсь на обратную точку зрения, мне как-то концептуально понятнее XUnit, и я его, в принципе, глубоко и нежно люблю с ранних его версий, и командами Microsoft полностью используют, ну не полностью, наверное, но в большинстве продуктов своих как раз-таки в фреймворке она использует именно XUnit.
4854.62 4874.86 "Анатолий Кулаков" И мы тут когда-то с тобой сравнивали, что у них примерно одинаковые доли, в общем, это два самых популярных тестовых фреймворка на платформе .NET, по крайней мере в C#, это XUnit и NUnit, разницы между ними большой нет, если вы выучите атрибутики и смысл одного, то примерно за 15 минут как бы краткого содержания легко сможете писать тесты на другом.
4874.86 4882.94 "Анатолий Кулаков" Это все как бы вкусовщина, но приятно, что как бы оба фреймворка растут, оба размножаются, и как бы оба выпускают новые версии.
4882.94 4884.58 "Анатолий Кулаков" Конечно, тесты каждому приложению нужны.
4884.58 4922.50 "Игорь Лабутин" Да, но надо сказать, что опять же NUnit, сейчас живет по-моему третья его версия, и он как-то довольно планомерно развивается, в XUnit было большое затишье, то есть XUnit версии 2 был выпущен довольно давно, и как-то там не сильно много чего менялось, мне кажется, но вот сейчас ведется работа над V3, и если вы пойдете в документацию XUnit, там есть отдельная статейка, где написано состояние, так сказать, V3 версии, но последнее ее обновление было в октябре 2021 года, и версия называлась 0.1.0, при альфа что-то там, то есть там все на очень ранней стадии, но тем не менее, возможно, там что-то новенькое, интересное завезут.
4922.50 4935.06 "Анатолий Кулаков" Да, действительно, следующую мажорную версию там все сильно ждут, там и null reference type должны приехать, и все в этом духе, но что-то пока автор не торопится нас радовать какими-то датами, поэтому ждем, ждем, что будет.
4935.06 4939.70 "Анатолий Кулаков" И следующий интересный пакет, Insight Database, знаешь такую?
4939.70 4940.70 "Анатолий Кулаков" Первый раз слышу.
4940.70 4963.90 "Анатолий Кулаков" Это, судя по описанию, microRM, которая помогает, соответственно, мапить дотнетовские объекты в базу данных, и она очень простая, очень быстрая, много всего поддерживает, ну и имеет для самого популярного продукта 2022 года, как ее позиционирует, всего-навсего 600 тысяч скачиваний, это довольно мало.
4963.90 4969.14 "Анатолий Кулаков" Для примера, у наших обсуждаемых серилогов, допустим, 360 миллионов скачиваний.
4969.14 4975.22 "Игорь Лабутин" Ну да, и у этого Insight Database 690 звездочек на гитхабе, то есть как-то совсем мало.
4975.22 4980.54 "Анатолий Кулаков" Я думаю, это какая-то проплаченная позиция, давай не будем на ней останавливаться, какая-то чушь.
4980.54 4987.46 "Анатолий Кулаков" Датабазов есть много для C# прекрасных разных, встроенные, не встроенные, объектные, реляционные, полно всяких.
4987.46 4989.50 "Игорь Лабутин" Это ORM все-таки, но ORM тоже приличные.
4989.50 4990.82 "Анатолий Кулаков" А, это даже не баз данных, это ORM.
4990.82 4998.82 "Анатолий Кулаков" Ну хорошо, а ORM тем более, слушай, достаточно, особенно на microORM достаточно много уже проверенных, это не проблема.
4998.82 4999.82 "Анатолий Кулаков" А Fluent Validation?
4999.82 5007.82 "Анатолий Кулаков" Вот Fluent Validation это довольно популярная библиотека, она создана для того, чтобы писать правила валидации в очень удобном Fluent синтаксисе.
5007.82 5021.22 "Анатолий Кулаков" Вы там можете написать, что поле, нейм у пользователя должно обязательно быть заполненным, должно не быть больше 50 символов, там email должен совпадать с этим паттерн-матчингом, пассворды должны быть одинаковые в двух полях и прочее-прочее.
5021.22 5028.62 "Анатолий Кулаков" Любую валидацию, которую вы, наверное, способны сейчас выдумать, все это, скорее всего, может покрыть Fluent Validation за все свои большие годы.
5028.62 5034.86 "Анатолий Кулаков" Хорошая библиотека, удобный синтаксис, в принципе, мне кажется, у нее есть все, что нужно.
5034.86 5052.78 "Анатолий Кулаков" Опять же, если вы не сильно загоняетесь, если вы какой-то огромный спец в валидации, вам это нужно во многих разных местах, есть минусы у этой библиотеки, есть минусы у этого пакета, но обычно я вижу, что в большинстве компаний это считается стандартным де-факто.
5052.78 5054.14 "Игорь Лабутин" Окей, пойдем дальше.
5054.14 5056.82 "Игорь Лабутин" Нода тайм, JonesKit.
5056.82 5064.42 "Анатолий Кулаков" Да, когда вспоминаешь о временах, о поясах, и это всегда приходит к нам JonesKit, и всегда приходит к нам нода тайм.
5064.42 5077.66 "Анатолий Кулаков" Я надеюсь, что для многих из вас не секрет, что работа с датам и временем - это очень сложная штука, и те реализации даты и времени, которые есть в дот-нете, они, в принципе, хороши до тех пор, пока вы не ставите это своим бизнес-доменом.
5077.66 5086.82 "Анатолий Кулаков" Как только вы начинаете очень плотно работать с различными тайм-зонами, с временами, со смещениями, у вас есть огромное количество подводных камней.
5086.82 5093.94 "Анатолий Кулаков" Легко нагуглите множество докладов, в том числе и самого JonesKit, где он рассказывает о всех проблемах.
5093.94 5096.74 "Анатолий Кулаков" Если вдруг не видели никогда, обязательно посмотрите.
5096.74 5104.78 "Анатолий Кулаков" То даже для общего обзора, то есть это та вещь, которую просто обязан знать каждый разработчик, потому что дата и время - это очень-очень сложный домен.
5104.78 5122.54 "Анатолий Кулаков" Вот и там он рассказывает огромное число интересных примеров из жизни, из мира, из разных стран, из разных часовых поясов, и как раз-таки пакет NodaTime позволяет вам более-менее упростить работу с датой и временем, немножко сгладить какие-то шероховатости.
5122.54 5128.94 "Анатолий Кулаков" И если вы вдруг работаете плотно в этом домене, то наверное обязательно должны использовать эту библиотеку.
5128.94 5132.02 "Анатолий Кулаков" Для повседневных приложений, скорее всего, она будет избыточной.
5132.02 5137.34 "Игорь Лабутин" Я, кстати, никогда не использовал, ни разу, только в каких-то таких своих примерчиках, не более того.
5137.34 5139.78 "Игорь Лабутин" В продакшене как-то обходимся стандартом.
5139.78 5140.78 "Игорь Лабутин" Давай дальше.
5140.78 5144.26 "Игорь Лабутин" Дальше библиотека, которую я тоже ни разу не видел, это Fluent Email.
5144.26 5149.14 "Анатолий Кулаков" Я тоже не могу похвастаться, что когда-то ее встречал.
5149.14 5157.14 "Анатолий Кулаков" Судя по описанию, это библиотека, которая позволяет вам очень легко сформировать сообщение, email, и отправить его с помощью сотни различных сервисов.
5157.14 5168.98 "Анатолий Кулаков" Наверное, кому-то это может быть полезно, хотя я отсылаю имейлы с помощью стандартных устройств, стандартных классиков .NET, и как-то никогда никаких проблем даже не
5168.98 5176.74 "Игорь Лабутин" встречал. Но тут ты можешь быть неправ на самом деле, потому что если ты зайдешь, ну ты, скорее всего, используешь какой-нибудь SMTP-клайд или что-нибудь подобное.
5176.74 5190.02 "Игорь Лабутин" Если ты зайдешь в статью про SMTP-клайд на docs.microsoft.com, там есть после всяких конструктор, экзампл и так далее, есть такая плашка, типа information или как-то так, где написано не используйте SMTP-клайд.
5190.02 5195.14 "Игорь Лабутин" Официальная рекомендация Microsoft, используйте вместо этого какую-нибудь другую библиотеку, например, MailKit.
5195.14 5202.78 "Игорь Лабутин" Это типа она более правильная, лучше поддерживается, поддерживает правильный стандартный, и короче, SMTP-клайд вообще outdated и не надо его использовать.
5202.78 5219.54 "Игорь Лабутин" То есть понятно, что для простых случаев все работает, мы тоже его используем, но если у вас какой-то чуть-чуть что-то более хитрое, то берите MailKit, большая библиотека, 4.6 тысяч звездочек на GitHub, MailKit, да, называется.
5219.54 5230.30 "Игорь Лабутин" И кроссплатформенная, вот это все поддерживает кучу всего, и мапы, и SMTP, и так далее, и все в общем будет работать.
5230.30 5242.14 "Игорь Лабутин" Fluent Email тоже неплохо, но я так понимаю, что Fluent Email заточена на, судя по всему, на именно паблик-сервисы типа SendGrid, MailGun и прочих, вот, она больше на это именно заточена.
5242.14 5253.62 "Игорь Лабутин" Плюс имеет какие-то кусочки из Razer, чтобы сделать прям UI для этого, и встроить это на свой сайт, а MailKit это более низкоуровневая штука, как замена SMTP-клайд.
5253.62 5259.30 "Анатолий Кулаков" Следующий пакет это Handfire, мне кажется, довольно узкоспециализированный такой фреймворк, хотя я часто о нем слышал.
5259.30 5264.22 "Анатолий Кулаков" Это фреймворк, который позволяет вам запускать некие бэкграунд-процессы, которые там что-то делают.
5264.22 5275.90 "Анатолий Кулаков" Ну, то есть, это специальные устройства для управления различными воркерами, джабами, бэкграунд-воркерами, они могут быть долгими, как выполнять какие-то длинные действия, или коротенькими.
5275.90 5283.74 "Анатолий Кулаков" Он вам дает красивый дешборд, умеет отслеживать CPU-Intensive и Input-Output-Intensive приложения, то есть джабы.
5283.74 5303.42 "Анатолий Кулаков" В общем, если у вас в вашем приложении нужно часто что-то запускать, делать какой-нибудь стандартный скедулер или отслеживать, насколько эти процессы выполняются, как часто их надо ретрайт, дать доступ с хорошим дешбордом к этому, ко всему вашему пользователю, то, наверное, вот пакет вам должен подойти.
5303.42 5306.22 "Анатолий Кулаков" В общем, если у вас такая проблема стоит, то пакет отличный.
5306.22 5312.62 "Анатолий Кулаков" В общем, в этом пакете он давно уже развивается, выглядит и есть, скорее всего, все, что вам нужно.
5312.62 5319.62 "Анатолий Кулаков" Но если вы поймете, что он действительно нужен, потому что я очень редко встречал ниши, где его можно применить.
5319.62 5327.66 "Игорь Лабутин" Ну, ты упомянул скедулинг, то есть если вам нужен скедулинг, есть еще одна альтернатива, которая даже чуть-чуть, мне кажется, более популярна, это Quartz.net.
5327.66 5334.58 "Игорь Лабутин" Это порт на .net, соответственно, по-моему, C++, если я правильно помню скедулер, Quartz.
5334.58 5340.26 "Игорь Лабутин" Короче, тоже очень классная штука, мы его использовали в одном из проектов, как скедулер вообще шикарно.
5340.26 5349.98 "Анатолий Кулаков" Да, мне кажется, что они не очень пересекаются, просто действительно, если мы говорим про скедулинг, то здесь есть точки соприкосновения, но Handfire, он больше про управление бэкграунд процессами.
5349.98 5350.98 "Анатолий Кулаков" Да, я согласен.
5350.98 5352.54 "Анатолий Кулаков" А Quartz, он больше про скедулинг, действительно.
5352.54 5358.98 "Игорь Лабутин" Да, но возможно, их даже можно совместить, по Quartz запускать что-то и отдавать в Handfire, почему нет.
5358.98 5359.98 "Игорь Лабутин" Ладно, пойдем дальше.
5359.98 5362.34 "Игорь Лабутин" LazyCash, впервые вижу.
5362.34 5365.98 "Анатолий Кулаков" Тоже первый раз в жизни сталкиваюсь с такой штукой.
5365.98 5378.82 "Анатолий Кулаков" Я обычно использую стандартный, который есть во фреймворке MemoryCache, и для большинства случаев отличная штука, умеет задавать лайфтаймы, умеет экспариться по определенному условию, всегда хватало.
5378.82 5384.58 "Игорь Лабутин" Это правда, и я не очень понимаю, зачем она может быть надо.
5384.58 5389.26 "Игорь Лабутин" Единственное, я не помню, когда добавили MemoryCache, возможно это что-то достаточно новое?
5389.26 5391.66 "Анатолий Кулаков" Ну, в большом фреймворке он точно уже был.
5391.66 5394.94 "Игорь Лабутин" А, ну тогда не знаю зачем.
5394.94 5404.90 "Игорь Лабутин" Если бы MemoryCache был только в Дотнеткоре или в Дотнете последнем, это было бы одно, а так он с 4го Дотнета доступен.
5404.90 5416.94 "Анатолий Кулаков" У него еще стройная удобная поддержка Performance Counter есть, то есть все MemoryCache, которые есть в вашем приложении, создает Performance Counter, удобно наблюдать за кешмиссами, например, тоже через стандартные средства Винды или может быть даже графану.
5416.94 5417.94 "Анатолий Кулаков" То есть отличная вещь.
5417.94 5425.78 "Анатолий Кулаков" Ну, наверное, есть какие-то преимущества у LazyCash, но видишь, мы с тобой уже отстаем от 2022 года и не все библиотеки хорошо знаем.
5425.78 5433.46 "Игорь Лабутин" Да, я вот не могу так вот, я сейчас читаю описание на GitHub и не могу сказать зачем он нужен, чем он лучше, чем MemoryCache.
5433.46 5445.22 "Анатолий Кулаков" Это все библиотеки, в принципе, довольно странный список, очень непонятно как автор выбирал их, как он их сортировал, почему выбрал именно эти, но я думаю многим из вас было интересно узнать.
5445.22 5454.58 "Анатолий Кулаков" И для справедливости ради, давай зайдем на NuGet, зайдем на NuGet и посмотрим какие самые скачиваемые пакеты, мне кажется это самый честный рейтинг, если мы говорим про пакеты.
5454.58 5457.54 "Анатолий Кулаков" И на первом месте у нас, конечно же, будет Newton Soft JSON.
5457.54 5463.22 "Анатолий Кулаков" Это штука, которая обгоняет ближайшего конкурента в 3-4 раза.
5463.22 5466.26 "Анатолий Кулаков" Здесь никаких неожиданностей нет.
5466.26 5467.58 "Анатолий Кулаков" За ней идет Serilog.
5467.58 5472.62 "Анатолий Кулаков" Самое что странное, в принципе, библиотека для логирования и на втором месте популярности.
5472.62 5476.50 "Анатолий Кулаков" Ну, наверное, каждому приложению нужно логирование, здесь безусловным лидером является Serilog.
5476.50 5478.02 "Анатолий Кулаков" Наверное, тоже ничего удивительного.
5478.02 5481.02 "Анатолий Кулаков" Из интересного еще стоит отметить Swashbuckle.
5481.02 5487.86 "Анатолий Кулаков" Это специальная штукенция для генерации Swagger протокола вашего ASP.NET приложения.
5487.86 5497.14 "Анатолий Кулаков" То есть, это универсальный протокол, который с помощью JSON описывает весь ваш API, все ваши контроллеры в универсальном межъязыковом синтаксисе.
5497.14 5503.02 "Анатолий Кулаков" То есть, можно по нему генерить клиентов, можно отдать его клиенту какому-то другому приложению, чтобы тот на него посмотрел.
5503.02 5509.82 "Анатолий Кулаков" Можно сгенерировать удобную UI, с помощью которой тестер или любой желающий пользователь может зайти и покликать.
5509.82 5512.34 "Анатолий Кулаков" То есть, да, действительно, хорошая и полезная библиотечка.
5512.34 5513.86 "Анатолий Кулаков" Что здесь еще?
5513.86 5514.86 "Анатолий Кулаков" Здесь интересный автомаппер.
5514.86 5519.94 "Игорь Лабутин" Да, автомаппер вполне как бы тоже высоко.
5519.94 5529.98 "Игорь Лабутин" Он полезен, когда вам нужно маппить много DTO-шек друг в друга, без необходимости писать кучу кода, проперти X, проперти Y, проперти Z и присвоить таким же.
5529.98 5536.70 "Игорь Лабутин" И если вот большие DTO-шки с миллионом пропертей, то, наверное, автомаппер, конечно, будет полезнее.
5536.70 5540.10 "Игорь Лабутин" Удивительно видеть AWS SDK в десятке.
5540.10 5546.58 "Игорь Лабутин" То есть, видимо, как-то популярность AWS растет, и авсовский SDK прям поднялся в десятку.
5546.58 5557.74 "Анатолий Кулаков" Или я вам рискую предположить, что AWS не умеет настраивать кэши, и поэтому любой билд в CI приложениях у них скачивает их SDK, поэтому они искусственно накручивают счетчик.
5557.74 5558.74 "Анатолий Кулаков" Poly.
5558.74 5559.74 "Игорь Лабутин" Непонятно, не знаю.
5559.74 5562.10 "Игорь Лабутин" Да, Poly, ну, Poly интересно.
5562.10 5569.94 "Игорь Лабутин" Poly – это библиотечка для реализации разных стратегий обработки ошибок, назовем это так.
5569.94 5574.78 "Анатолий Кулаков" Мне показалось еще странным, что библиотека Moku идет следующая.
5574.78 5581.78 "Анатолий Кулаков" То есть библиотека Moku – это способ замочить ваши интерфейсики, ваши классики, ваши зависимости в тестах.
5581.78 5588.46 "Анатолий Кулаков" Интересно здесь то, что Moku идет на 15 месте, а ближайший тестовый фреймворк XUnit идет на 17 месте.
5588.46 5592.10 "Анатолий Кулаков" Каким образом Moku может быть использована чаще, чем XUnit?
5592.10 5610.42 "Игорь Лабутин" Ну, это легко, потому что Moku, как мне кажется, Moku сейчас практически де-факто стандартом создания моков, и поэтому все, кто использует NUnit, XUnit, MSTest, если вдруг такие есть, они все используют Moku, и таким образом, по идее, Moku должен быть суммой всех тестовых фреймворков.
5610.42 5612.38 "Анатолий Кулаков" Ну да, да, наверное ты прав.
5612.38 5616.02 "Анатолий Кулаков" В общем, да, хорошая библиотека, тоже странно, что мы ее не упоминали.
5616.02 5618.14 "Анатолий Кулаков" Вот, обратите внимание, если вам нужно что-то замокать.
5618.14 5625.46 "Анатолий Кулаков" Дальше XUnit упомянутый же, FIU Info Illidation, по которому сегодня говорили, и наверное на этом 20-очка у нас закончилась.
5625.46 5632.30 "Анатолий Кулаков" Да, вот такие в принципе основные фреймворки, самые популярные в дотнете, если вдруг какие-то вы из них не использовали, то как минимум стоит посмотреть.
5632.30 5639.38 "Игорь Лабутин" Да, ну и есть огромное количество, понятно, других, но вот это самые такие, те, которые на слуху практически все время.
5639.38 5642.66 "Игорь Лабутин" Так, давай дальше, что у нас еще есть сегодня?
5642.66 5648.14 "Игорь Лабутин" Давай, давай немножко затронем интересную историю про rate limiting.
5648.14 5659.82 "Игорь Лабутин" Значит, смотрите, идея у нас такая, иногда когда мы делаем сервер, то нам нужно каким-то образом ограничивать количество одновременно обрабатываемых запросов.
5659.82 5674.42 "Игорь Лабутин" С другой стороны, иногда такая же проблема или задача возникает на клиенте, например, если мы ходим к какой-то API, про которую мы точно знаем, что про ее rate limit, то мы хотим ограничить rate limiting на клиенте.
5674.42 5683.54 "Игорь Лабутин" И в июне прошлого года вышла статья на InfoQ со словами, что все, теперь в дотнете будет стандартный rate limiting.
5683.54 5698.58 "Игорь Лабутин" Ну я порадовался, решил, что хорошо, ну как бы тема такая не очень большая, отложил статью в долгий ящик, вот наконец до нее добрались руки, я решил, что ну все, дотнет 6 вышел, надо, так сказать, сделать обзорчик, рассказать, что такая штука появилась.
5698.58 5700.10 "Игорь Лабутин" Но оказалось все не так просто.
5701.10 5716.34 "Игорь Лабутин" Значит, в июне получается примерно, нет, в апреле 21 года был пропозал про то, что давайте сделаем rate limiting API, причем, поскольку во фреймворке оно должно быть расширяемым, кастомизируемым и так далее.
5716.34 5720.98 "Игорь Лабутин" Был написан пропозал, как это обычно делается, сделана какая-то реализация, там был какой-то ревью.
5720.98 5725.66 "Игорь Лабутин" В общем, где-то к августу ребята сказали, не, в 6 дотнет мы не успеваем.
5725.66 5731.54 "Игорь Лабутин" Напоминаю, что дотнет реализовался в ноябре, то есть за, сколько лет, 3 с небольшим месяца.
5731.54 5736.66 "Игорь Лабутин" Они сказали, что нет, в 6 релиз мы не успеваем, ну ладно, значит, будем успевать в 7.
5736.66 5738.86 "Игорь Лабутин" И успели, в 7 успели.
5738.86 5740.70 "Игорь Лабутин" Значит, что же они сделали?
5740.70 5745.58 "Игорь Лабутин" Я не буду вдаваться в подробности, но все это живет в namespace system trading rate limiting.
5745.58 5752.78 "Игорь Лабутин" Теперь у нас есть базовый класс, который называется rate limiter, и от него наследована часть 4, которых встроены.
5752.78 5762.38 "Игорь Лабутин" То есть есть concurrency limiter, это простая штука, которая просто проверяет, что не более чем n одновременных задач, допустим, может проходить через этот limiter.
5762.38 5767.98 "Игорь Лабутин" Есть fixed window, есть sliding window, и есть token bucket, алгоритм поддержка.
5767.98 5769.98 "Игорь Лабутин" Ну и можно написать свой, естественно.
5769.98 5776.74 "Игорь Лабутин" То есть они написали все эти limiter, есть тестики, есть документация, все здорово, все это будет доступно в 7 дотнете.
5776.74 5785.38 "Игорь Лабутин" И вот буквально, ищи была закрыта примерно 2 недели назад относительно вот даты, когда мы пишемся.
5785.38 5790.38 "Игорь Лабутин" То есть с апреля это дело заняло, ну сколько, почти 3/4 года.
5790.38 5802.14 "Игорь Лабутин" Когда я читал новость вообще еще тогда, в июне, в июле, я подумал, ну все, конечно, хорошо, хорошо иметь в стандартном фреймворке стандартный rate limiter, наверняка такая штука есть в поле.
5802.14 5814.86 "Игорь Лабутин" Вот мы как раз поле недавно упоминали в прошлой новости, что это библиотека как раз для обработки ошибок и для написания более такого надежного кода, обычного вокруг сетей.
5814.86 5820.26 "Игорь Лабутин" И казалось бы, было бы очень логично иметь там rate limiter.
5820.26 5832.66 "Игорь Лабутин" Я пошел в репозиторий поле посмотреть, что там, как там, и выяснилось, что внезапно нет, в поле не было rate limiter, точнее он там появился примерно 2 недели назад от времени записи подкаста.
5832.66 5838.22 "Игорь Лабутин" Там буквально ищи были закрыты с разницей в 1 день в 2 разных репозиториях разными людьми.
5838.22 5841.82 "Игорь Лабутин" Теперь у нас есть 2 rate limiter, один в за 7 дотнете, второй в поле.
5841.82 5846.46 "Игорь Лабутин" У них немножко разные, ну очевидно разные, так скажем, интерфейсы.
5846.46 5855.54 "Игорь Лабутин" В поле по дефолту, по-моему, сделан 1 или 2 алгоритмов всего, то есть если вам нужно больше, то берите кастомные, пишите кастомные.
5855.54 5856.54 "Игорь Лабутин" Но забавно.
5856.54 5865.90 "Игорь Лабутин" Причем в поле, в отличие от дотнета, это заняло гораздо больше времени ищу про то, что давайте сделаем rate limiter, там появилось в середине 17 года.
5865.90 5870.14 "Игорь Лабутин" То есть вот они за 4 с небольшим кода таки сделали.
5870.14 5875.66 "Анатолий Кулаков" Ну хорошо, удивительно, что в принципе так совпали по датам и так совпали по направлению.
5875.66 5876.66 "Игорь Лабутин" Бывает.
5876.66 5877.66 "Игорь Лабутин" Ну бывает, да.
5877.66 5888.74 "Игорь Лабутин" В поле там объяснялось тем, что тот, кто драйвил это, потом куда-то отвалился, ну как бы, сколько это open source, он там повисел, сколько-то потом кто-то подхватил pull request, доделал, потестировали, ну в общем занял какое-то время.
5888.74 5898.38 "Игорь Лабутин" Ну в общем, anyway, если вам нужен какой-то rate limiting, особенно client-side, теперь у вас есть 2 варианта, поле либо стандартный в дотнете, но для этого придется подождать седьмого дотнета.
5898.38 5909.22 "Анатолий Кулаков" Ну допустим, rate limiter хорошая штука, я думаю, когда седьмой дотнет будет выходить, мы подробнее рассмотрим лимитеры, как они работают и что из себя представляют, когда их использовать, ну а пока будем смотреть, полезно следить.
5909.22 5914.54 "Анатолий Кулаков" Так, давай, наверное, последнюю статейку, что-то мы затянулись, что-нибудь легенькое.
5914.54 5920.46 "Анатолий Кулаков" Вот, например, интересная штука есть про 6 вещей, которые не стоит делать в ASP.NET контроллерах.
5920.46 5925.02 "Анатолий Кулаков" Не отпускают нас сегодня контроллеры и бестпрактисы, поэтому логично будет ими закончить.
5925.02 5939.26 "Анатолий Кулаков" В принципе, сама статейка очень, я бы сказал, посредственная, заявленные темы вообще никак не раскрываются, но список там более или менее нормальный, поэтому я предлагаю пройтись по списку и более или менее на своими темами, своими мнениями набросать.
5939.26 5942.42 "Анатолий Кулаков" Что же у нас такое здесь происходит?
5942.42 5943.42 "Анатолий Кулаков" Прежде всего, проблема.
5943.42 5954.30 "Анатолий Кулаков" Проблема в том, что когда люди пишут ASP.NET контроллеры, API контроллеры, юзер контроллеры, не важно, они очень любят туда нагонять много всего, много логики, много кода, много маппинга.
5954.30 5958.46 "Анатолий Кулаков" В общем, чем больше кода там получается, тем, им кажется, легче.
5958.46 5960.18 "Анатолий Кулаков" Легче считать, легче поддерживать все в одном месте.
5960.18 5972.10 "Анатолий Кулаков" И, в общем, таким образом работали много языков, там также точно и PHP начинался, и в Python очень много с помощью такого способа программировали.
5972.10 5983.94 "Анатолий Кулаков" Но обычно от этого люди уже уходят, и так как мы все-таки не скриптовый язык, а строго типизированный, объектно-ориентированный прежде всего, то у нас другие принципы и другие ценности в этой жизни.
5983.94 5990.54 "Анатолий Кулаков" И мы обычно любим, и все нам обычно советуют любить именно тонкий контроллер.
5990.54 5994.50 "Анатолий Кулаков" Тонкий – это те контроллеры, в которых меньше всего кода.
5994.50 5995.50 "Анатолий Кулаков" Зачем же они нужны?
5995.50 5997.94 "Анатолий Кулаков" Прежде всего, тонкие контроллеры лучше читаются.
5997.94 6009.06 "Анатолий Кулаков" Когда у вас есть у контроллера даже пяток методов, и все эти методы занимаются огромным числом работы, код разрастается неимоверно много, и читать это абсолютно невозможно.
6009.06 6013.70 "Анатолий Кулаков" Как это поддерживать невозможно, как это понять тоже абсолютно невозможно.
6013.70 6016.02 "Анатолий Кулаков" Поэтому читаемость прежде всего.
6016.02 6018.58 "Анатолий Кулаков" Дальше следующий плюс – это будет у нас тестируемость.
6018.58 6023.26 "Анатолий Кулаков" Тестируются тонкие контроллеры прекрасно тем, что их тестировать не надо.
6023.26 6031.30 "Анатолий Кулаков" Если контроллер тонкий, то у него единственная задача – передать всю логику, все управление вашему бизнес-сервису какому-нибудь или бизнес-объекту.
6031.30 6036.74 "Анатолий Кулаков" И уже те обладают некой логикой, которую легко тестировать.
6036.74 6040.90 "Анатолий Кулаков" Именно поэтому тонкие контроллеры как раз таки дают лучшую тестируемость.
6040.90 6043.70 "Анатолий Кулаков" Но не себя, а лучшую тестируемость вашей бизнес-логики.
6043.70 6052.18 "Анатолий Кулаков" Соответственно, простота поддержки, очень легко разобраться, очень легко внедрить какие-то новые зависимости и очень легко вызвать какие-то новые сервисы.
6052.18 6062.26 "Анатолий Кулаков" Так как он элементарный, это всего лишь перенаправление обычных запросов в вашу бизнес-логику, ничего здесь, никакой сложности в поддержке не вызывает.
6062.26 6072.22 "Анатолий Кулаков" И рефакторинг кода непосредственно вашей бизнес-логики и переиспользование самое главное вашей бизнес-логики становится намного легче.
6072.22 6086.30 "Анатолий Кулаков" Потому что теперь, чтобы ее переиспользовать, у вас есть отдельные сервисы, отдельные классы, а не нужно каким-то образом вызывать методы из контроллера, чтобы оттуда выцепить всю эту бизнес-логику, которую люди могут там у них реализовать.
6086.30 6090.30 "Анатолий Кулаков" В общем, все это реализовать в контроллерах плохо, нужно делать именно тонкий.
6090.30 6095.98 "Анатолий Кулаков" И чтобы понять, что такое тонкий контроллер, прежде всего нужно осознать и ответственность, зачем нужны контроллеры.
6095.98 6099.70 "Анатолий Кулаков" Самая главная их ответственность - это работа с запросами на HTTP уровне.
6099.70 6113.74 "Анатолий Кулаков" Это получить HTTP-запрос, каким-то образом обработать входящий поток, сделать вызов обработчика где-то в бизнес-логике или в сервисной логике, или в сервисном слое и каким-то образом обработать ответ.
6113.74 6124.02 "Анатолий Кулаков" То есть сформировать правильный HTTP-ответ, может быть сформировать правильный HTTP-код, внедрить какие-то заголовки, поставить еще какие-то дополнительные служебные флажочки.
6124.02 6128.66 "Анатолий Кулаков" В общем, все, что касается HTTP-уровня и HTTP-протокола.
6128.66 6134.18 "Анатолий Кулаков" И, соответственно, типичные ошибки, которые допускаются, когда мы пишем контроллеры.
6134.18 6137.54 "Анатолий Кулаков" Прежде всего это формирование маппинга внутри контроллеров.
6137.54 6144.94 "Анатолий Кулаков" То есть маппинг DTO-шек, который пришел к вам, вам нужно смапить это в какие-то бизнес-сущности, бизнес-объекты для того, чтобы передать дальше по пайплайну.
6144.94 6150.50 "Анатолий Кулаков" Вы же не будете разговаривать с вашей бизнес-логикой в терминах HTTP-респонсов и HTTP-реквестов.
6150.50 6152.90 "Анатолий Кулаков" Поэтому обычно встречаются слои некие маппинга.
6152.90 6168.30 "Анатолий Кулаков" И если на первый взгляд это кажется довольно-таки невидным перекладыванием двух полей, то очень быстро, особенно в больших приложениях, это разрастается, раздувается, и это один из тех того мусора, которым зарастают как раз-таки контроллеры.
6168.30 6170.34 "Анатолий Кулаков" И при этом они получают новую ответственность.
6170.34 6181.14 "Анатолий Кулаков" Они уже отвечают не только за HTTP, за передачу запросов, но и за правила маппинга и всякую надстройку над этим.
6181.14 6182.62 "Анатолий Кулаков" Потому что маппинги тоже иногда бывают нетривиальными.
6182.62 6187.58 "Анатолий Кулаков" Нужно несколько объектов, может быть, спапить, как-то их объединить, как-то определить.
6187.58 6191.02 "Анатолий Кулаков" И обычно это выносят куда-нибудь в отдельный класс.
6191.02 6194.46 "Анатолий Кулаков" Этот отдельный класс прекрасен тем, что его можно отдельно тестировать.
6194.46 6197.62 "Анатолий Кулаков" И это может быть отдельно переиспользовать.
6197.62 6203.50 "Анатолий Кулаков" И соответственно из разных транспортов вы можете использовать с этим маппингом из разных точек.
6203.50 6209.22 "Анатолий Кулаков" Следующая штука, которую встречают в контроллерах и которой там не должно быть, это валидация.
6209.22 6214.74 "Анатолий Кулаков" А здесь нужно уточнить, что именно валидация HTTP реквеста.
6214.74 6218.34 "Анатолий Кулаков" HTTP реквест можно провалидировать тысячами разных способов.
6218.34 6222.10 "Анатолий Кулаков" Есть тот же самый Fluent Validator, который мы сегодня уже упоминали.
6222.10 6229.54 "Анатолий Кулаков" Есть стандартные атрибуты из Data Annotation, который понимает сам ISP, Netcore, который тоже умеет это все дело валидировать.
6229.54 6235.82 "Анатолий Кулаков" Есть куча middlewari, которые помогают вам это сделать, отвалидировать запрос еще до того, как он попадет в ваш контроллер.
6235.82 6247.86 "Анатолий Кулаков" И соответственно внутри контроллера вы можете быть на 100% уверены, что все поля заданы, все поля соответствуют и никакой логики по провалидации больше не нужно.
6247.86 6252.78 "Анатолий Кулаков" Но это касается только простой валидации, где ее можно каким-то образом декларативно формализовать.
6252.78 6256.30 "Анатолий Кулаков" Ну и если вы не используете Fluent Validator.
6256.30 6259.30 "Анатолий Кулаков" Соответственно валидацию тоже желательно из контроллера выносить.
6259.30 6274.06 "Анатолий Кулаков" Если мы еще говорим про бизнес-валидацию, а не про HTTP-валидацию, не про валидацию HTTP-реквестов, то бизнес-валидация безусловно будет переюзываться, потому что взаимодействие с бизнес-объектом может идти с тысячи разных сторон, не только из ваших контроллеров.
6274.06 6278.62 "Анатолий Кулаков" И поэтому бизнес-валидация должна уже идти где-то, быть возле бизнес-логики.
6278.62 6281.06 "Анатолий Кулаков" Ну соответственно в контроллерах ей тоже не место.
6281.06 6286.50 "Анатолий Кулаков" И непосредственно сама бизнес-логика - это тоже та вещь, которую люди часто суют в контроллеры.
6286.50 6293.94 "Анатолий Кулаков" Ну что может быть легче, как бы загрузить пользователя из базки прямо в контроллер и поменять ему там одно поле и обратно сохранить в базу.
6293.94 6298.14 "Анатолий Кулаков" Казалось бы, никаких проблем с этим нет, но опять же, это невозможно тестировать.
6298.14 6301.34 "Анатолий Кулаков" Или это тестировать очень дорого, долго, ну и глупо.
6301.34 6319.50 "Анатолий Кулаков" Намного лучше вынести отдельный бизнес-объект без дурацких зависимостей на HTTP, контексты, на HTTP-реквесты, респонсы, с понятными чистыми входами, чистыми выходами, без зависимости от каких-то других фреймворков библиотек, и его уже будет элементарно, быстро, хорошо и качественно тестировать.
6319.50 6325.54 "Анатолий Кулаков" Потому что бизнес-логика - это одна из самых главных частей, которая должна быть протестирована и покрыта абсолютно вся тестами.
6325.54 6329.50 "Анатолий Кулаков" Дальше у нас есть такой слой, как авторизация, аутентификация.
6329.50 6342.30 "Анатолий Кулаков" Это слой, который как раз-таки заставляет вас подумать о том, а иметь ли пользователь, который как-то стучится к вам в систему права на то, чтобы общаться с вашим контроллером, на то, чтобы запрашивать ваши ресурсы.
6342.30 6344.82 "Анатолий Кулаков" Вот, это тоже в контроллере делать глупо.
6344.82 6359.26 "Анатолий Кулаков" Есть, существуют специальные middleware, которые помогают вам полностью абстрагироваться от того, как пользователь залогинил вашу систему, какие протоколы он использовал, может быть, даже вообще не на вашем сервере он залогинился, а к вам приходит просто с access токеном.
6359.26 6384.34 "Анатолий Кулаков" Здесь есть тонкость, что все-таки авторизация, в большинстве случаев ее можно сделать декларативной, но существует ресурс-бейс авторизация, когда условия очень-очень сложные, и применять ее надо точечно, и поэтому даже в рекомендациях Майкрософта есть, что ресурс-бейс авторизацию можно делать в контроллерах, в принципе, не возбраняется, разрешается.
6384.34 6387.54 "Анатолий Кулаков" Но это довольно редкий и специфичный случай.
6387.54 6390.98 "Анатолий Кулаков" Следующий случай очень распространен, это обработка ошибок.
6390.98 6403.06 "Анатолий Кулаков" Нельзя в контроллерах строить try-catch в каждом вызове и при этом ловить исключения и каким-то образом пытаться перемапить это в какой-то bad request или еще что-то невнятное.
6403.06 6404.46 "Анатолий Кулаков" В общем, это путь в никуда.
6404.46 6418.06 "Анатолий Кулаков" Все вот эти try-catch, обработки, они будут встречаться у вас в каждом методе, и в каждом методе этот код будет и дублироваться, и пачкать, и вообще try-catch они не очень хорошо читаются, они не очень хорошо вписываются в код.
6418.06 6431.10 "Анатолий Кулаков" Существует просто стандартный middleware, который перехватывает абсолютно все запросы, абсолютно от всех контроллеров, оборачивает их в try-catch и, соответственно, мапят исключения на какие-то стандартные ошибки.
6431.10 6445.70 "Анатолий Кулаков" Если они видят, что это argument exception, они вам выдадут ошибку bad user input, если это какая-то внутри сервера произошла проблема, они там сразу выдадут internal server error, то есть умеют перемапливать стандартные дотентовские исключения в HTTP.
6445.70 6448.22 "Анатолий Кулаков" Это очень помогает и упрощает жизнь.
6448.22 6457.38 "Анатолий Кулаков" Естественно, вы можете там свои обработчики зарегистрировать и как-то это настраивать, но не занимайтесь вы кетчингом и обработкой ошибок внутри непосредственно контроллеров.
6457.38 6458.74 "Анатолий Кулаков" Это не универсально.
6458.74 6473.26 "Анатолий Кулаков" Вообще, если вы повторяете какой-то cross-cutting код внутри каждого метода, там логирование, будь то измерение производительности метрика, трассировка и обработка ошибок, значит вы что-то делаете не так.
6473.26 6482.90 "Анатолий Кулаков" Всегда задумывайтесь о том, что повторяющийся однообразный код можно вынести в какой-то middleware, который может сделать его один раз для всех контроллеров.
6482.90 6492.70 "Анатолий Кулаков" Ну и соответственно, последним примером автор приводит непосредственно доступ к репозиториям, доступ к сохранению, получению данных из вашей базы данных.
6492.70 6510.62 "Анатолий Кулаков" То есть действительно база данных, ну и репозитория в частности, это то место, которое тоже необходимо будет как-то вам протестировать, обложить какой-то логикой и доступаться к нему непосредственно из тех частей, которые понимают и scope, и бизнес часть, и то, какую операцию они сейчас в данный момент делают.
6510.62 6520.42 "Анатолий Кулаков" Обычно контроллеры таковыми не являются, и надо всегда держать в голове, что контроллеры это только лишь один из возможных входов в ваше приложение.
6520.42 6538.50 "Анатолий Кулаков" Может быть завтра вы поставите Rabbit и будете консюмить сообщения из Rabbit или Kafka, и уже, казалось бы, тот же самый, грубо говоря, Rabbit контроллер, Rabbit консюмер тоже должен будет взаимодействовать с вашими пользователями, бизнес доменами и сохранением данных в репозитории, загрузку данных из репозитория.
6538.50 6542.22 "Анатолий Кулаков" И поэтому эта логика должна быть уже переиспользована и уже должна быть отделена.
6542.22 6545.50 "Анатолий Кулаков" Вот именно поэтому не стоит её оставлять внутри контроллеров.
6545.50 6562.72 "Анатолий Кулаков" Вот такие лёгенькие советы на прощание, я думаю, в принципе, они будут полезны начинающим разработчикам и, соответственно, помогут каким-то образом сделать ваши контроллеры тоньше, соответственно, лучше тестировать и качественнее за ними следить.
6562.72 6568.74 "Игорь Лабутин" Да, контроллеры должны ли они быть тонкими или толстыми, это тема обсуждения внутри команды.
6568.74 6576.18 "Игорь Лабутин" Ну, то есть, все вроде согласны, что они в среднем тонкие, но всегда возникает куча нюансов и каждый раз приходится обсуждать.
6576.18 6585.50 "Игорь Лабутин" Давай действительно будем завершаться, у меня есть одна маленькая темка, не совсем запланированная, вот, но я что-то про неё совсем забыл, но я думаю, что упомянуть стоит.
6585.50 6590.50 "Игорь Лабутин" Началась вся февраль, а это значит, что мы будем отмечать, у нас будет праздник в этом феврале.
6590.50 6592.50 "Игорь Лабутин" Ты знаешь, что за праздник?
6592.50 6594.10 "Игорь Лабутин" Ну, разумеется, 23 февраля.
6594.10 6596.14 "Игорь Лабутин" Не, раньше, 13 февраля.
6596.14 6597.70 "Игорь Лабутин" Что за праздник у нас?
6597.70 6598.70 "Игорь Лабутин" Первый раз слышу.
6598.70 6625.90 "Игорь Лабутин" Первый раз слышишь, так вот, запомни, 13 февраля 2002 года был анонсирован .NET, поэтому мы отмечаем 20 лет .NET, соответственно, в этом году, в 13 февраля 2022 года, и по этому поводу там Microsoft куча, ну, как обычно, статьи про то, что там можно скачать специальные обои, там, понятно, рингтоны на ваши телефоны, вот это всё, я не знаю, что там ещё можно, но смысл в том, что дадут на это 20 лет внезапно.
6625.90 6626.90 "Анатолий Кулаков" Круглая дата.
6626.90 6635.26 "Анатолий Кулаков" Да, 20 лет – это, в принципе, кругло, это мощно, это долго, в принципе, надо праздновать, надо что-нибудь действительно замутить.
6635.26 6656.50 "Анатолий Кулаков" Друзья, я думаю, что эта новость достойна того, чтобы разыграть лицензии от компании JetBrains, которая любезно поддерживает наш подкаст уже многие-многие годы, не 20 лет, конечно, но тоже молодцы, и так, тогда в честь праздника и в честь того, что наконец-то мы дожили до круглой даты, у нас розыгрыш.
6656.50 6673.98 "Анатолий Кулаков" Как всегда, у нас будет разыгрываться три лицензии, одну лицензию получит кто-то, кто оставит комментарий на YouTube-канале под этим выпуском, абсолютно любой комментарий, где вы нас слушаете, откуда нас слушаете, что вам нравится, что не нравится, просто что придёт в голову, нам просто интересно пообщаться с живыми людьми.
6673.98 6697.18 "Анатолий Кулаков" Вторую лицензию получит тот, кто ретвитнет наш твит на официальном аккаунте dotnet.ru в Твиттере, ретвит об этом выпуске, и тот, кто репостнит анонс ВКонтактике этого выпуска, тот тоже получит право участвовать в розыгрыше, соответственно, среди трёх этих групп мы разыграем отдельно три лицензии.
6697.18 6700.94 "Анатолий Кулаков" Розыгрыш состоится через неделю после выхода этого выпуска подкаста.
6700.94 6751.02 "Игорь Лабутин" Ну а мы будем завершаться, вспомним, что сегодня мы обсудили некоторое количество новостей от Microsoft, DotNet Pro и Preview 12, DotNet Community, Toolkit V8.0, Preview 1, Visual Studio 2022, Mac Preview 5 и Azure Container Apps, порассуждали долго про медиатор и сервис локатор, паттерн, антипаттерн и что это вообще такое, узнали как устроен стрингбилдер внутри, поговорили про популярные или полезные NuGet пакеты, которые вам обязательно нужны в 2022 году для вашей продуктивити, ну или просто потому что они хорошие NuGet пакеты, посмотрели на историю рейт-лимитинга в ДотНет мире, узнали про тонкие или толстые SPNет контроллеры и вспомнили, а кто-то узнал про то, что ДотНету внезапно исполняется 20 лет в этом месяце.
6751.02 6756.70 "Анатолий Кулаков" Да, поэтому отмечайте все 13 февраля у себя в календариках, закупаемся кефиром и дружно празднуем.
6756.70 6763.98 "Анатолий Кулаков" Ну на этом, наверное, всё, большое спасибо, что дослушали этот выпуск до конца и увидимся на следующем выпуске.
6763.98 6765.18 "Анатолий Кулаков" До новых встреч, пока!
6765.18 6767.94 "Игорь Лабутин" Да, это был 45-й радио ДотНет, пока!
6767.94 6778.94 None [музыка]
