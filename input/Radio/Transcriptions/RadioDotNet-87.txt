0.00 11.68 SPEAKER_00 Здравствуйте, дорогие друзья, в эфире Radio.net и выпуск 87-й.
11.68 14.94 SPEAKER_00 Сегодня с вами в студии Анатолий Кулаков.
14.94 15.94 SPEAKER_01 И Игорь Лабутин.
15.94 16.94 SPEAKER_01 Всем привет.
16.94 19.90 SPEAKER_00 А также большое спасибо всем нашим помогаторам.
19.90 25.66 SPEAKER_00 Если вы не знаете, о чем мы сейчас говорим, проходите на наш сайт на Boosty и присоединяйтесь к доброму списку.
25.66 35.50 SPEAKER_00 Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин и Ольга Бондаренко.
35.50 39.06 SPEAKER_00 Спасибо, друзья, а также те, кто пожелал остаться неизвестными.
39.06 41.70 SPEAKER_00 Так, что у нас интересного?
41.70 44.26 SPEAKER_01 Ну, у нас сегодня, как обычно, много интересного.
44.26 47.06 SPEAKER_01 Мы, как обычно, проговорим часа два, не меньше.
47.06 49.54 SPEAKER_01 Ну, там посмотрим, сколько останется после сведения.
49.54 53.66 SPEAKER_01 Ну, начнем мы с Эндрю Лока, с статейка Эндрю Лока.
53.66 56.94 SPEAKER_01 Обычно мы их как-то на серединку-конец оставляем, но сегодня прямо начнем с нее.
56.94 57.94 SPEAKER_01 Давай.
57.94 62.94 SPEAKER_00 Ну, потому что обычно вначале у нас Микрософт, да, Микрософт сейчас пока еще спит, что-то он после каникул еще не
62.94 63.94 SPEAKER_01 очухался.
63.94 71.94 SPEAKER_01 Ну, не факт, что спит, может быть, они готовят что-то важное и интересное, как в релиз кандидата, ой, да, это что у нас будет, превью один, не релиз кандидата, конечно.
71.94 72.94 SPEAKER_01 Превью один, что-нибудь выкатит, эдакое.
72.94 73.94 SPEAKER_01 Сейчас как бахнут.
73.94 74.94 SPEAKER_01 Весь подкаст обсуждать будем.
74.94 75.94 SPEAKER_01 Ну, посмотрим.
75.94 76.94 SPEAKER_01 Будем надеяться, будем надеяться.
76.94 80.94 SPEAKER_00 Для нас, чем больше инфоповодов, тем лучше.
80.94 99.74 SPEAKER_00 Кстати, про инфоповоды, .NEXT открыл CFP, поэтому если вы мечтали стать докладчиком на весь мир, прогреметь и побывать на самой большой .NET конференции в России, то милости просим, подавайтесь на доклады, заходите, смотрите, что там есть интересного.
99.74 102.82 SPEAKER_00 И к локу, да, вернемся к локу.
102.82 111.94 SPEAKER_00 И лок у нас, в принципе, он обычно по ISP нас гоняет, но в этот раз он решил рассмотреть дефолт имплеметейшн метод для интерфейсов.
112.50 121.22 SPEAKER_00 Такая спорная тема, мы, по-моему, на весь год, прошлый год про нее что-нибудь выдумывали, обсуждали, насколько это будет плохо, насколько будет хорошо.
121.22 124.62 SPEAKER_00 Как тебе, Игорь, вот зарелизились дефолт интерфейс методы?
124.62 126.94 SPEAKER_00 Оправдались ли все твои страхи или наоборот?
126.94 130.94 SPEAKER_01 Честно говоря, я их прям так напрямую особо и не использую.
130.94 138.18 SPEAKER_01 Вот я что-то не припомню, чтобы я хоть раз писал именно дефолтный интерфейс метод в своем обычном коде, как-то не нужно было.
138.18 140.86 SPEAKER_01 Может быть, в библиотеках это прям сильно нужно, мне не пригождалось пока.
140.86 165.94 SPEAKER_00 Ну вот тоже, я напомню, что самое главное опасение всего сообщества было в том, что абстрактные классы как-то выродятся, все начнут вымазывать интерфейс имплементацией, запихивать туда всякие непотребные методы, а абстрактные классы уйдут в небытие, и вот эта вот наша святая, долго играющая преемственность в наследовании, она вообще вся испортится, испоганится, непонятно, что будет.
165.94 170.66 SPEAKER_00 Ну, как показала практика, хоть и недолгая, в принципе, этого не происходит.
170.66 186.58 SPEAKER_00 Дефолтная имплементация в методах, в дефолтных интерфейсах этих, она используется довольно редко, используется довольно специфично, абстрактные классы по-прежнему на месте, и люди пока не сильно злоупотребляют этими методами, что в принципе и требовалось.
186.58 189.46 SPEAKER_00 То есть их нужно применять там, где они в реальности нужны.
189.46 193.66 SPEAKER_00 А там, где не нужны, их применять, как вы, наверное, догадались, не следует.
193.66 205.02 SPEAKER_00 Так что, в принципе, не такие они получились страшные, как все об этом думали, как бы, если подходить с умом, то даже микроскопом можно забивать гвозди.
205.02 208.42 SPEAKER_00 Итак, что же нам Эндрю про них рассказывает?
208.42 212.58 SPEAKER_00 Ну, прежде всего, как положено, прямо с самого начала, что же такое, за чудо такое.
212.58 223.22 SPEAKER_00 Прежде всего, методы, эти дефолт интерфейс метод, а также, в принципе, правильнее будет назвать дефолт интерфейс имплементейшнс, потому что там не только методы могут быть.
223.22 246.46 SPEAKER_00 Они были введены в C# восьмом, и основная их цель была для того, чтобы эволюционировать и изменять интерфейсы без breaking changes, то есть без калечащих изменений, потому что на самом деле, даже добавление поля, казалось бы, такой безобидная вещь, как добавление, вы уже не удаляете, не ренеймите, а просто добавляете.
246.46 258.02 SPEAKER_00 Даже добавление поля к интерфейсу, это является breaking changes, потому что на этот интерфейс уже могла насоздаваться куча наследников, и все ваши наследники перестанут компилироваться.
258.02 265.86 SPEAKER_00 В случае Microsoft, если они, допустим, в системных интерфейсах что-то добавят, может перестать компилироваться полмира, поэтому они себе этого позволить не могли.
265.86 271.06 SPEAKER_00 И вот эта проблема решалась с помощью дефолтной реализации интерфейсов.
271.06 274.74 SPEAKER_00 И начиная с .NET восьмого, что мы можем делать?
274.74 282.98 SPEAKER_00 Мы теперь можем в интерфейсах задавать не только заголовки, но и реализовывать непосредственно само тело, реализовать метод body.
282.98 295.98 SPEAKER_00 И после того, как мы это смогли сделать, уже добавление каких-то методов не стало breaking changes, т.е. ваш код по-прежнему продолжит компилироваться, несмотря на то, что в интерфейсе могло добавиться еще 10 методов.
295.98 299.42 SPEAKER_00 На первый взгляд это очень сильно походит на абстрактные классы.
299.42 305.94 SPEAKER_00 Т.е. вполне валидный вопрос, а чем абстрактные классы отличаются от интерфейса с дефолтной имплементацией.
305.94 312.82 SPEAKER_00 Но на этот вопрос мы ответим немножко позже, но на первый взгляд это, в принципе, кажется одним и тем же.
312.82 324.12 SPEAKER_00 Так, и после того, как мы научились добавлять дефолтную имплементацию после .NET восьмого, Microsoft стал это обширно использовать.
324.12 330.46 SPEAKER_00 Ну, опять же, не злоупотребляя, в своих библиотеках, и наш код после этого не ломается.
330.46 337.08 SPEAKER_00 В общем, то, что они хотели добиться этим, сейчас видно, что они этого достигли, и, в принципе, все счастливы.
337.08 355.38 SPEAKER_00 Также нужно отметить, что реализовать мы можем не только методы в интерфейсах, в интерфейсах мы можем также заводить свойства, мы можем заводить приватные филды, не только публичные, например, мы можем заводить статические методы, в общем, там творится практически такая же свобода, как и в обычных классах.
355.38 375.66 SPEAKER_00 Теперь давайте же все-таки поговорим, а что же с ними не так, чем они отличаются в абстрактных классах, а самое главное, какие есть подводные камни при использовании этих дефолтных имплементаций, потому что вроде все ввели, про них все забыли, но мало кто догадывает, зачем чревато, если вдруг в своем коде вы захотите вот такую штуку использовать.
375.66 386.54 SPEAKER_00 Итак, первый подводный камень, с которым вы, возможно, столкнетесь, это в том, что в отличие от абстрактных классов, дефолтные методы в интерфейсах, они не наследуются.
386.54 387.70 SPEAKER_00 Что это значит?
387.70 405.50 SPEAKER_00 Это значит, что если у вас есть интерфейс iCustomer и реализация sampleCustomer, и в интерфейсе iCustomer вы объявили некий метод дефолтным, то есть сделали ему body, написали там какое-то возвращаемое значение, дальше вы пытаетесь это в коде вашем использовать.
405.50 431.92 SPEAKER_00 И как только вы создаете вот этого кастомера и пытаетесь обратиться через интерфейс к вот этому defaultImplement методу, то все у вас будет хорошо, потому что этот дефолтный метод есть в интерфейсе, но как только вы пытаетесь обратиться к sampleCustomer, то есть к наследнику от этого интерфейса, пытаетесь у него найти метод, который дефолтно был добавлен в интерфейсе, вы этого метода не найдете.
431.92 436.28 SPEAKER_00 То есть ваш код просто не скомпилируется, потому что этого метода в данном классе нет.
436.28 446.90 SPEAKER_00 Этого отличают от абстрактного класса, если что, потому что если вы наследуетесь от абстрактного класса, естественно, метод будет как в самом абстрактном классе, так и в наследнике.
446.90 455.02 SPEAKER_00 В случае дефолт интерфейс методов, метод будет только в интерфейсе, а в самом наследнике его не будет, если будете обращаться непосредственно к наследнику.
455.02 459.54 SPEAKER_00 То есть вызвать мы его напрямую не сможем.
459.54 461.30 SPEAKER_00 Решается эта проблема очень просто.
461.30 467.70 SPEAKER_00 Мы берем этого sampleCustomer и сохраняем в переменную iCustomer, то есть переменную с интерфейсом, ну или кастим к интерфейсу.
467.70 471.98 SPEAKER_00 И после того, как мы его скастили, то этот метод на него магическим образом появляется.
471.98 473.98 SPEAKER_00 Кажется, что все нормально.
473.98 500.34 SPEAKER_00 Вот такое небольшое неудобство, в принципе оно расходится с тем, как нам бы, наверное, очевидно, хотелось бы это видеть, но оно было добавлено как раз таки для того, что если вдруг в классе уже такой метод был реализован, или какой-нибудь reflection оббегал этот класс в поисках всех методов, наверное, чтобы он не нашел и у вас не получилось бы какого-то bracketChanger, то есть не нашел эту дефолтную имплементацию.
500.34 505.82 SPEAKER_00 В общем, ради обратной совместимости пришлось ввести такое не очень интуитивное поведение.
505.82 506.82 SPEAKER_00 Дальше.
506.82 508.62 SPEAKER_00 На этом подводные камни не кончаются.
508.62 513.70 SPEAKER_00 Прежде всего, иерархия виртуальных вызовов, т.е.
513.70 527.74 SPEAKER_00 как, наверное, вызываются виртуальные методы с абстрактными классами, все мы знаем, т.е. их можно переопределить, с ними можно и пронаследовать, не переопределять, воспользоваться дефолтным поведением из абстрактного класса и так далее.
527.74 539.34 SPEAKER_00 Когда мы пытаемся сделать то же самое и с дефолтными методами, ну, например, есть у нас интерфейс Shape, который возвращает в виде строки свое имя, getName у него возвращает iShape.
539.34 559.78 SPEAKER_00 Если мы от этого интерфейса, да, и getName это метод, который заимплементирован по дефолту в этом интерфейсе, дальше мы делаем от наследника, который называется Rectangle, и Rectangle наследуется от iShape, при этом не переопределяя метод getName, ну, т.е. по сути должен использовать базовый метод.
559.78 569.46 SPEAKER_00 И дальше мы от Rectangle наследуем квадратик, квадратик тоже переопределяет getName и говорит, что мой name это квадратик.
569.46 572.42 SPEAKER_00 Тут как бы тоже все вроде пока прямо и очевидно.
572.42 580.26 SPEAKER_00 А теперь, внимание, вопрос, что будет, если мы создадим квадратик, приведем его к интерфейсу iShape и дернем у него метод getName?
580.26 594.06 SPEAKER_00 Ну, кажется, что если бы мы делали это все с абстрактными классами, то, естественно, даже несмотря на то, что мы у iShape переменной дернули getName, то override ее в квадратике должен был вернуть нам слово квадратик.
594.06 599.82 SPEAKER_00 Но нет, так не произойдет, нам вернется именно iShape.
599.82 606.66 SPEAKER_00 Это поведение неинтуитивное, и оно абсолютно сбивает с толку тех, кто привык к абстрактным классам и привык от них наследоваться.
606.66 633.14 SPEAKER_00 Для того, чтобы пофиксить это поведение, вам необходимо в наследнике квадратика пронаследоваться не только от Rectangle, но и явно пронаследоваться от интерфейса iShape, несмотря на то, что Rectangle и так наследуется от интерфейса iShape, т.е. здесь вам нужно явное наследование сделать, и только после этого квадратик подхватит override из базового интерфейса.
633.14 634.14 SPEAKER_00 Следующая проблема.
634.14 637.98 SPEAKER_00 Насколько вы знаете, в C# не существует множественного наследования.
637.98 641.38 SPEAKER_00 Кстати, в C, там C++, оно есть.
641.38 648.26 SPEAKER_00 И самая главная причина, на которую все ссылались при дизайне языка, почему так не было сделано, это Diamond Inheritance Problem.
648.26 651.38 SPEAKER_00 Игорь, ты знаешь, как на русский переводится эта
651.38 654.30 SPEAKER_01 проблема?
654.30 659.50 SPEAKER_01 Ромбовидное наследование, обычно я что-то из своих древних плюсовых времён помню какой-то такой термин.
659.50 666.14 SPEAKER_00 Ну да-да, мне тоже кажется, что-то с равновидным, не какое-нибудь там бриллиантовое или…
666.14 668.42 SPEAKER_01 Нет-нет, ну ромбовидное, да.
668.42 670.66 SPEAKER_01 Ну что-то там с ромбами было связано.
670.66 673.74 SPEAKER_01 Ну и оно рисуется в виде ромба обычно, поэтому вот.
673.74 674.74 SPEAKER_00 Да.
674.74 686.10 SPEAKER_00 А рисуется в виде ромба неспроста, потому что эта проблема, она очень похожа на ромб, если представить наследование в виде такой своеобразной диаграммы.
686.10 693.02 SPEAKER_00 Допустим, у вас есть класс IShape, у IShape наследуется первый наследник и наследуется второй наследник.
693.02 694.90 SPEAKER_00 А потом мы захотели сделать класс.
694.90 702.46 SPEAKER_00 И этот класс мы хотим, чтобы он имплементировал два интерфейса, интерфейс наследник 1 и интерфейс наследник 2.
702.46 709.90 SPEAKER_00 И у IShape есть метод getName, и у первого наследника есть getName, и у второго наследника есть getName.
709.90 716.42 SPEAKER_00 И все эти getNames, они переопределены во всех этих трёх интерфейсах, так как мы теперь можем это делать.
716.42 717.42 SPEAKER_00 Вот.
717.42 718.42 SPEAKER_00 И теперь, внимание, вопрос.
718.42 733.06 SPEAKER_00 Вот наш класс, последний, четвёртый, который хочет пронаследоваться и от второго, и от третьего наследника, какой у него метод getName вызовется, т.е. что вернёт, от какого наследника.
733.06 736.46 SPEAKER_00 Это, в принципе, в общем случае неразрешимая проблема.
736.46 740.94 SPEAKER_00 И именно поэтому и не стали делать множественное наследование в C#.
740.94 755.02 SPEAKER_00 Ну, как только у нас появляется дефолтная реализация интерфейси на методах, а методов, а интерфейсов, т.е. мы можем пронаследовать сколько угодно в нашем классе, у нас вот эта ромбовинная проблема наследования, она встаёт в полный рост снова.
755.02 760.34 SPEAKER_00 И здесь Микрософт пошёл самым правильным, наверное, путём.
760.34 762.94 SPEAKER_00 Он на уровне компиляции запрещает такое компилировать.
762.94 767.74 SPEAKER_00 Т.е. он говорит, что компилятор не может найти самый лучший метод, который вам подходит, идите и явно его укажите.
767.74 770.82 SPEAKER_00 В общем, и указать явно это, естественно, можно.
770.82 781.26 SPEAKER_00 Таким образом мы избавляемся от всяких проблем и в рантайме не ловим каких-то непонятных исключений или даже непонятного поведения, я бы сказал, которое вполне вас могло преследовать всю плюс-плюсе.
781.26 783.34 SPEAKER_00 Так, погнали дальше.
783.34 793.34 SPEAKER_00 Следующая проблема, с которой, возможно, столкнётесь, если вы захотите пронаследовать структуру от вашего интерфейса, в котором есть дефолт имплементации.
793.34 799.82 SPEAKER_00 Естественно, структуры тоже могут наследовать интерфейсы, но здесь есть парочка небольших проблем.
799.82 808.78 SPEAKER_00 Прежде всего, для того, чтобы использовать дефолтный метод из дефолтного этого интерфейса, вам необходимо будет структуру прикастить к интерфейсу.
808.78 818.50 SPEAKER_00 Как мы уже обсуждали чуть ранее, что только интерфейс может вызывать методы, которые явно задекларированы в интерфейсе, но их нет в самом наследнике.
818.50 822.98 SPEAKER_00 И как только вы кастите структуру к интерфейсу, у вас неизбежно появляется боксинг.
822.98 830.30 SPEAKER_00 А боксинг у вас появляется не просто так, а вместе с избыточным потреблением памяти, то есть вызывается memory location.
830.30 838.54 SPEAKER_00 И обычно, то есть в обычных программах, наверное, вам memory location может не так страшен, но здесь мы используем структуру.
838.54 841.26 SPEAKER_00 И обычно структуру используют как раз там, где памяти выделять не надо.
841.26 844.70 SPEAKER_00 И это высокопроизводительный и обычный оптимальный код.
844.70 846.90 SPEAKER_00 Как раз где не хочется в ХИПе выделять память.
846.90 853.98 SPEAKER_00 И как только вы начинаете кастить вашу структуру к интерфейсу, вы автоматически все плюсы структуры как бы теряете.
853.98 857.30 SPEAKER_00 Поэтому, скорее всего, именно в этом месте вы этого не хотите.
857.30 870.50 SPEAKER_00 И также нужно сказать, что дефолтные методы в интерфейсе, когда пытаются изменить структуру, они получают ее, естественно, через интерфейс.
870.50 874.54 SPEAKER_00 То есть они по случаю получают забокшенную копию самой структуры.
874.54 878.02 SPEAKER_00 Таким образом, чтобы они там не меняли, до оригинала они никак не дотянутся.
878.02 884.50 SPEAKER_00 То есть, по сути, невозможно из дефолт имплементейшн метода обновить каким-то образом структуру.
884.50 888.38 SPEAKER_00 Из этих двух минусов можно сделать только один единственный правильный вывод.
888.38 896.30 SPEAKER_00 Не используйте структуры и дефолт интерфейс методы вместе, потому что вы явно этого не хотите.
896.30 904.98 SPEAKER_00 Еще один неочевидный подводный камень в том, что дефолтные методы требуют изменения в рантайме.
904.98 911.06 SPEAKER_00 Казалось бы, по идее, наверное, это изменение можно засунуть было в компилятор и все, и дело в шляпе.
911.06 912.06 SPEAKER_00 Но нет.
912.06 913.74 SPEAKER_00 Обновления компилятора вам недостаточно.
913.74 915.58 SPEAKER_00 Нужно еще будет обновиться рантайм.
915.58 923.54 SPEAKER_00 Они есть в рантайме после .NET третьего, поэтому можно смело на этот рантайм переходить, если вам они вдруг зачем-то нужны.
923.54 939.14 SPEAKER_00 В качестве хорошего примера для оптимизации Андрю Лок приводит хорошую оптимизацию от Бена Адамса, который умудрился увеличить перформанс iHeaderDictionary в три раза.
939.14 942.42 SPEAKER_00 В общем, сделал он это довольно нехитрым путем.
942.42 950.58 SPEAKER_00 Раньше к iHeaderDictionary, т.е. это специальный словарик, в который мы ходили за заголовками, аж теперь и квесты, аж теперь и спонсоры.
950.58 951.58 SPEAKER_00 Мы оттуда могли доставать заголовки.
951.58 956.02 SPEAKER_00 Как вы понимаете, заголовков бесконечное множество, там может быть абсолютно любой строковой ключ.
956.02 959.38 SPEAKER_00 В общем, мы раньше их доставали просто из дикшнери лукапом.
959.38 963.46 SPEAKER_00 Ну, не просто лукапом, там умным лукапом с мегаоптимизацией и так далее.
963.46 980.42 SPEAKER_00 Но все эти мегаоптимизации оказались довольно слабыми по сравнению с тем, что мы могли бы в этом iHeaderDictionary просто завести свойства для самых популярных хедров таких, там, accept, content-type, encoding и так далее, и просто обращаться к этим свойствам.
980.42 995.82 SPEAKER_00 Вот именно это Эндрю сделал, т.е. Бен Адамс сделал, сделал это с помощью дефолтных методов, т.е. теперь он на этом интерфейсе смог реализовать свойства, которые напрямую ходят к тому полю, который вы захотели, без всякого лукапа в дикшнере.
995.82 997.98 SPEAKER_00 И все это в три раза ускорило дикшнер.
997.98 1010.22 SPEAKER_00 Вот в принципе один из примеров, как Microsoft использует эти методы не только для расширения интерфейсов, а ради каких-то непонятных методов, ну и ради прям увеличения перформанса.
1010.22 1018.10 SPEAKER_00 Несмотря на то, что API там стал красивше и использовать этот дикшнер стал легче, но главная цель Бена, конечно же, была перформанс.
1018.10 1034.46 SPEAKER_00 Вот такие наши старые новые друзья, может, эта статья открыла для вас какие-то новые вещи, о которых вы раньше не знали и, может быть, как раз показала, почему и не следует в последненной жизни использовать дефолт интерфейс имплементейшнсы.
1034.46 1040.34 SPEAKER_01 Да, звучит интересно, потому что, ну кажется, относительно простая фича всего лишь.
1040.34 1045.38 SPEAKER_01 Казалось бы, добавили методы в интерфейсе, а столько проблем.
1045.38 1049.14 SPEAKER_01 Что может быть, кстати, подчеркивает, почему сложно дизайнить все эти языковые фичи.
1049.14 1054.06 SPEAKER_01 Казалось бы, придумали простую штуку, а вот надо со всем совместить.
1054.06 1063.34 SPEAKER_00 Наверное, главное теперь, что нужно придумать в языке или во всех новых языках, которые люди придумывают, самое главное, что нужно придумывать, это как вы будете избавляться от легоси-конструкции.
1063.34 1070.02 SPEAKER_00 Потому что сейчас это бич C#, и он нам мешает такие хорошие фичи вводить полноценно, красиво, ожидаемо.
1070.02 1074.94 SPEAKER_00 Вот всё это из-за обратной дурацкой совместимости, которая, в принципе-то, по большому счёту никому и не нужна.
1074.94 1077.66 SPEAKER_00 Ну в таком виде, в котором мы могли бы ей пренебречь.
1077.66 1086.86 SPEAKER_01 Ну именно, мы вообще рассказывали, кстати, на эту тему немножко, что команда C# придумала, что они с этим будут делать.
1086.86 1105.14 SPEAKER_01 Напоминаю, что в новом SDK, по-моему, начиная с девятки, если вы скомпилите ваш старый код в девятом SDK с таргетом в восьмёрку, он теоретически сможет вас предупредить, что смотрите, вот эти вот фичи, которые в вашем коде, если вы поменяете таргет на девятку, они изменят поведение.
1105.14 1115.38 SPEAKER_01 То есть, и за счёт этого они теперь могут делать breaking changes, то есть они меняют их, но поменяют так, что если вы компилите со старым таргетом, то поведение старое, например.
1115.38 1127.22 SPEAKER_01 Какое-нибудь там новое ключевое слово будет считаться просто обычной переменной, идентификатором, а вот если с таргетом девятка, то всё, это уже новое поведение, новое ключевое слово и вот это всё.
1127.22 1139.10 SPEAKER_01 Это таки позволит, наконец-таки, не знаю, вводить ключевые слова, не боясь того, что кто-то объявил класс с именем рекорд, с маленькой буквы, в таком духе.
1139.10 1141.38 SPEAKER_01 Так что, надеюсь, станет лучше.
1141.38 1144.58 SPEAKER_00 Да-да, это именно то решение, которое я имел в виду.
1144.58 1147.30 SPEAKER_00 Посмотрим, как оно себя покажет, но кажется, это то, что нам надо.
1147.30 1148.30 SPEAKER_01 Да.
1148.30 1149.30 SPEAKER_01 Пойдём дальше.
1149.30 1151.82 SPEAKER_01 Дальше у нас очередной новости про Aspire.
1151.82 1159.26 SPEAKER_01 На их, не то чтобы вышло статья, но на их гитхабе появилось ишьё, которое называется first release scoping.
1159.26 1164.22 SPEAKER_00 То есть понятно, что… Это для тех, кому не хватило до прошлого выпуска, посвящённое полностью Aspire.
1164.22 1178.42 SPEAKER_01 Да, я боюсь, что… ладно, боюсь неправильный термин, но я думаю, что у нас Aspire будет так или иначе в каждом выпуске появляться, потому что, похоже, это одна из самых больших фичей или компонент, не знаю, направлений того, куда сейчас работает команда ASP.
1178.42 1182.30 SPEAKER_01 Ну, наверное, фреймворк, да, то есть это что-то рядом с AspNet.
1182.30 1192.26 SPEAKER_01 Это AspNet, да, главной движухой и промоутом этого всего занимается Дэвид Фаулер, который, собственно, до этого промоутил minimal API, а теперь вот занимается Aspire.
1192.26 1197.86 SPEAKER_01 Вот, итак, что, собственно, должно войти в первый релиз?
1197.86 1204.10 SPEAKER_01 Напоминаю, что сейчас Aspire это всё-таки превью, там раннее первое, второе, ну, короче, пока это всё очень превью.
1204.10 1213.98 SPEAKER_01 Всё может 20 раз меняться, и оно уже меняется, но когда будет релиз, значит, scope, который сейчас себе команда очертила, он следующий.
1213.98 1234.94 SPEAKER_01 Напоминаю, что Aspire это такой способ запихать в ваше приложение стандартные, так скажем, хорошо проверенные временем конфигурации для широко известных компонент и добавить к этому возможность, соответственно, сервис дискавери, правильной телеметрии и вот этого всего.
1234.94 1243.22 SPEAKER_01 И поэтому, когда мы говорим про скопинг, во-первых, в первую очередь, конечно же, речь идёт о компонентах, ну и ресурсах.
1243.22 1260.34 SPEAKER_01 И здесь Microsoft говорит следующее, что из open-source, они будут ну, open-source на это громко сказано, потому что там есть SQL-сервер, но у них это называется OSS раздел, и там написано, что там будет поддержана Postgres, MySQL, SQL-сервер, Oracle, Mongo, Redis, Kafka и RabbitMQ.
1260.34 1274.46 SPEAKER_01 Ну, то есть, наверное, не знаю, 90% наверное не скажу, но очень существенная часть всего стандартного такого базданческого, ну, базданных, эстеков и кэшей, да?
1274.46 1278.94 SPEAKER_01 Точно есть ещё какие-то, вернее, точно есть ещё какие-то, но это, наверное, покроет большой процент.
1278.94 1284.46 SPEAKER_00 Да, да, хороший список, прям нормальный стандартный стек-энтерпрайзер, и не только.
1284.46 1285.46 SPEAKER_01 Да.
1285.46 1295.94 SPEAKER_01 Дальше, естественно, не могли обойти вниманием Ажуру, там будет, ну, мы уже говорили про Cosmos, Storage, всякие разные, сервис-баски, Vault, OpenAI, AI-сёрч, куда же без AI?
1295.94 1299.46 SPEAKER_01 Azure Redis, Azure Postgres, Azure SQL, тут всё нормально.
1299.46 1309.70 SPEAKER_01 И Dapr мы упоминали в последнем выпуске, что они сделали заделочки под Dapr, соответственно, вот стоит Store и Pub/Sub из Dapr тоже нативно будут, ну, нативно, в смысле, в скоупе релиза будут поддержаны.
1309.70 1323.06 SPEAKER_01 Для дэшборда запланирован очень важный и нужный шаг, называется декаплинг, то есть так, чтобы дэшборд можно было запускать абсолютно отдельно от вашего приложения.
1323.06 1345.58 SPEAKER_01 Сейчас напоминаю, что вы должны, для того, чтобы вставить Aspire в ваш продукт, нужно создать отдельный проект, из него зареференсить или каким-то образом заиспользовать там через пути компоненты, еще через что-нибудь ваши основные остальные проекты, приложения, и после этого, именно из этого продукта, этот проект вы делаете стартом и из него запускается дэшборд.
1345.58 1359.62 SPEAKER_01 Так вот, теперь есть уже pull-request, он вмёржен, то есть последняя ветка мастера или мейна, что у них там в этом самом репозитории, уже содержит отрезанный дэшборд, который как-то можно запускать отдельно.
1359.62 1384.26 SPEAKER_01 Пока еще нет толковой документации, я пока не видел, может быть, уже появилось там, с момента, как я смотрел, недельку назад, но теперь дэшборд в каком-то смысле отцеплен от основного приложения, с которым он работает, и может быть это означает, что мы сможем вскоре увидеть абсолютно standalone дэшборд, который не требует каких-то, ну какой-то магии для своей работы.
1384.26 1388.78 SPEAKER_01 Посмотрим, что они подразумевают под декаплингом, пока просто написано.
1388.78 1389.78 SPEAKER_01 Дэшборд декаплинг.
1389.78 1394.74 SPEAKER_00 А ты не знаешь, он будет запускаться как бы в отдельном процессе, или все равно процесс должен быть этот же?
1394.74 1396.18 SPEAKER_00 То есть как он будет слушать, по сути, все эти метрики?
1396.18 1424.30 SPEAKER_01 Нет, процесс он и был отдельный в любом случае, он по-любому отдельный процесс, он слушает, потому что у него LP-сервер, ну оплентелеметрии и кто там еще, вот, он в любом случае слушает, просто другое дело, что если ты помнишь прошлый выпуск, то мы обсуждали, что там есть еще так называемый DCP, Data Control Plane, или нет, странное название, ну короче, Control Plane, какой-то отдельный процесс, который как раз всем управляет.
1424.30 1434.86 SPEAKER_01 Вот, и дэшборд – это просто отдельный процесс, из которого торчит, собственно, бэкэнд для вот этого фронт-энд-приложения, которое в браузере.
1434.86 1438.70 SPEAKER_01 Поэтому это будет отдельный процесс, однозначно.
1438.70 1459.70 SPEAKER_01 Проблема в том, как научить остальные процессы в системе, ну или в вашем продукте репортить в этот процесс, то есть будут ли какие-то там well-known-урлы, будут ли какие-то, ну короче, непонятно, поскольку он, если он отрезан от основного приложения и не используется для запуска основного приложения, то каким-то образом конфигурацию нужно будет прокинуть.
1459.70 1468.90 SPEAKER_00 Ну, наверное, такой же, как и во всех остальных LTP-сервисах, ты должен подключить внешний телеметрий-провайдер и писать туда, или какой-то агент должен собирать от тебя информацию.
1468.90 1485.38 SPEAKER_01 Я очень надеюсь, что это ровно так, потому что тогда это позволяет использовать его вообще для чего угодно, даже для того, чего Майкрософт не предполагал, ну грубо говоря, для каких-то приложений, там, не знаю, на Java, на Python, на Rust, на Go, да, которые ты просто так из студии не запустишь.
1485.38 1490.86 SPEAKER_00 Ну, я думаю, что они не зря на LTP-сервис рассчитывали на этот протокол.
1490.86 1496.14 SPEAKER_00 То есть они, скорее всего, предполагают, что его можно использовать как standalone-приложение с абсолютно любыми другими приложениями.
1496.14 1501.46 SPEAKER_00 То есть мы ждём конкурента Эластику, или чего-то у нас ещё есть?
1501.46 1502.46 SPEAKER_00 Ну, Эластику, Графани, там, не знаю.
1502.46 1503.46 SPEAKER_00 Графани, да-да-да.
1503.46 1504.46 SPEAKER_01 Чему-нибудь такому.
1504.46 1514.62 SPEAKER_01 Слушай, посмотрим, в том плане, что я думаю, что сейчас должны появиться статьи на предмет как бы, как это мы всё сделали, чтобы оно вместе заработало.
1514.62 1526.90 SPEAKER_01 В смысле, что такое standalone и так далее, потому что пока просто всё очень рано, в смысле, что, ну, только-только вот pull-request недавно вмёрзли, и поэтому пока рано говорить, что всё из этого получится.
1526.90 1527.90 SPEAKER_01 Посмотрим.
1527.90 1528.90 UNKNOWN Вот.
1528.90 1541.18 SPEAKER_01 Дальше, deployment раздел, это, соответственно, все вот эти ресурсы, которые я перечислил, да, там, пасгрегий, ажур и так далее, должны быть в состоянии задеплоины куда-либо.
1541.18 1545.02 SPEAKER_01 Ну, понятное дело, что в ажур, это однозначно.
1545.02 1564.58 SPEAKER_01 Дальше у них написано, что должен быть CI/CD scaffolding, ну, короче, command-line tool, который позволит тебе из, ну, как бы, из твоего аспайровского описания, да, которое пишется на C#, я напомню, сгенерить GitHub action, который тебе потом это всё будет собирать уже в CI где-то там.
1564.58 1580.10 SPEAKER_01 Ну и поддержка Kubernetes, есть отдельный комьюнити-проект Aspirate называется, он, соответственно, как раз умеет преобразовывать эти аспайровские манифесты из кода в нормальные, так сказать, скрипты для кубера, чтобы туда задеплоить.
1580.10 1601.42 SPEAKER_01 Tooling, ну, Visual Studio, понятное дело, Visual Studio Code обещают, и обещают тот самый scaffolding не только в виде command-line, но и в виде какой-то Visual Studio приблуды, я уж не знаю, плагин или нативная функциональность, тут уж я не знаю, ну, короче, какой-то tooling вокруг Visual Studio, Visual Studio кода.
1601.42 1613.14 SPEAKER_01 Есть ещё такой интересный раздел, называется top requests at end-to-end scenarios, то есть это, я так понимаю, те сценарии, где либо больше всего народу проголосовало, либо какие-то заказчики к ним пришли и сказали, что вот это точно надо.
1613.14 1633.58 SPEAKER_01 Они все в основном, конечно, крутятся вокруг ажура, то есть там я хочу коннектироваться к ремоутному ажурному ресурсу из своего девелоперского окружения, я хочу брать секреты, которые проставлены в моих ажурных ресурсах и прокидывать их локальным приложением, там через User Secrets или как-то.
1633.58 1649.14 SPEAKER_01 Но есть и те, которые не относятся к ажуру, например, давайте поддержите докер в VSL, чтобы можно было видимо туда там деплойт, не знаю, не деплойт, типа, в, тоже локально, но такой типа, а-ля, локальный кубер.
1649.14 1667.90 SPEAKER_01 Хочется уметь возможность оркестрировать, ну вот это как раз история с декаплингом, несколькими репозиториями, то есть сейчас Spyre предполагает, что у тебя монорепа, грубо говоря, в которой, ну плюс-минус, да, дефолтный сценарий, в который ты референсируешься на другие проекты, то есть не только монорепа, но еще и сингл солюшен, по большому счету.
1667.90 1677.02 SPEAKER_01 Ну, это понятно, что первый превью, и это самое простое, что можно было сделать, но вот end-to-end сценарий, так что можно было вообще с несколькими репозиториями работать, тоже нормально.
1677.02 1686.10 SPEAKER_01 Из того, что явно написано, что out-of-scope, точно не будет поддержан никакой там AWS, Google Cloud, не будет поддержан Azure Kubernetes.
1686.10 1691.18 SPEAKER_00 Слушай, а почему это out-of-scope, если ажура поддерживается, ну то есть кажется одного полиягоди?
1691.18 1702.50 SPEAKER_01 Там чуть-чуть разные, так скажем, видимо какие-то, ну не знаю, в мелочах требования, не знаю, вот, поэтому, ну вот пока не поддержан, out-of-scope, просто видимо ресурсов не хватит.
1702.50 1708.74 SPEAKER_00 Ну хорошо, ну так мы написали, что ресурсов не хватит, типа делайте сами, но мне кажется, что это out-of-scope.
1708.74 1709.74 SPEAKER_01 Нет, стоп.
1709.74 1729.94 SPEAKER_01 Ну так они это и написали, out-of-scope, это в смысле наша команда этим не будет заниматься, то есть это scope команды, которые они планируют, что Microsoft планирует официально зарелизить в первом релизе, но out-of-scope Microsoft не планирует, как бы запрещать, никто не запрещает, пожалуйста, делайте что хотите, но как бы Microsoft это делать не планирует,
1729.94 1735.66 SPEAKER_00 и это не только… Я думал, что это out-of-scope именно самого проекта, то есть проект под это не предназначен.
1735.66 1767.50 SPEAKER_01 Это first-release scope, напоминаю, все, что мы обсуждаем, это scope первого релиза, будет он как бы вместе с девяткой в ноябре, будет он раньше, будет он отдельно, как версионируется этот продукт пока тоже не очень понятно, ну вроде бы логично его привязать, наверное, к релизам дотнета, но с другой стороны, если они планируют это делать как отдельный стендаловый продукт под другие платформы тоже, то зачем привязывать, может быть они там летом его зарелизят, я не знаю, но вот это как раз таки все то, что я перечислял, это то, что должно войти в первый релиз.
1767.50 1808.60 SPEAKER_01 Так вот, то, что ты говоришь, если поддерживать ажуру, в первый релиз out-of-scope не только ажура, ой, в смысле AWS там, Google Cloud, но еще и Azure Kubernetes и Azure Functions, это все тоже не будет поддержано, то есть даже если у тебя есть проект, напоминаю, в студии ты можешь создать проект Azure Functions и довольно легко там в пару кликов его деплоить в ажуру, Aspire такого поддерживать пока не будет, ну, видимо, не успевают, вот, ну либо просто сознательно ограничивать на самом деле, может быть это тоже правильно, сознательно ограничить себе scope первой версии, сделать его, ее, его scope версию и зарелизить, посмотреть на фидбэк и дальше выбирать следующее, наиболее важное.
1808.60 1834.48 SPEAKER_01 Ну, в общем, примерно так, соответственно, в ссылочках будет и ссылка на pull request, где отрезали дэшборд и он теперь standalone, можно посмотреть, может быть там уже что-то появилось где-нибудь или в связанных ишах написана какая-нибудь документация, или, можно сказать, в pull request она прямо есть, я не посмотрел, вот как этим пользоваться, так что если у кого-то руки дойдут, попользуйтесь, расскажите, как он там standalone работает, у меня пока не дошли, честно говоря.
1834.48 1838.72 SPEAKER_00 Угу, ну и мы будем следить за статейчиками, если появятся, обязательно расскажем.
1838.72 1841.64 SPEAKER_01 Ну, конечно, проще прочитать, чем самому сделать, так
1841.64 1842.64 SPEAKER_00 что.
1842.64 1843.64 SPEAKER_00 Это да.
1843.64 1850.76 SPEAKER_00 Кстати, вот проще как раз было дождаться, пока кто-то найдет замещение байна реформатору, чем сделать его самому.
1850.76 1863.84 SPEAKER_00 Давай, следующая статейчика как раз про то, что один дяденька загнался тем, что начал скучать по байна реформатору, ну, у него в проекте он просто использовался, а он захотел перебежать на последний фреймворк и сильно загрустил.
1863.84 1893.38 SPEAKER_00 Давай для, как раз для молодежи вспомним, что в старинных версиях дотнет фреймворка много-много тысяч лет назад была такая прекрасная штука, как байна реформатор, и отличалась она от вот этих ваших новомодных JSON-сериалайзеров тем, что паковала, не поверите, в байнаре, то есть по сути в нечитабельную кашу из битиков и байтиков, которую естественно неудобно было дебажить и смотреть на нее глазками.
1893.38 1897.04 SPEAKER_00 Но у байна реформаторов есть другой прекрасный плюс.
1897.04 1901.00 SPEAKER_00 Они намного быстрее всегда и намного компактнее.
1901.00 1909.48 SPEAKER_00 И обычно, когда мы говорим о сериализации, это два очень весомых плюсика, которые в принципе вполне могут перебить любой текстовый сериализатор.
1909.48 1914.76 SPEAKER_00 Так вот, был у Микрософта байна реформатор рядом с XML-форматором вообще самых первых его версий.
1914.76 1918.48 SPEAKER_00 Потому что JSON-а не было, а байнаре XML был всегда.
1918.48 1928.04 SPEAKER_00 И сериализовали, сериализовали люди с помощью него и постепенно поняли, что в принципе реализация этого байна реформатора была слишком мощная.
1928.04 1935.32 SPEAKER_00 Она могла делать такие страшные вещи, что даже которые выходили за уровень ее декларируемых фич.
1935.32 1962.76 SPEAKER_00 То есть, допустим, с помощью байна реформатора, если у вас вдруг торчит какой-нибудь endpoint, VCF-endpoint или HTTP-endpoint, не суть важно, или сигнал-эр-эндпоинт, который принимает внутрь себя некий пакет, который десяти реализуется с помощью байна реформатора, то очень часто вы можете благодаря такому endpoint выполнить произвольный код на удаленном сервере.
1962.76 1966.80 SPEAKER_00 То есть, с байна реформатором очень много было о секьюрити проблем.
1966.80 1987.24 SPEAKER_00 Кому интересно, можно отдельную статейку почитать, но смысл как раз в том, что от него начали отказываться, наверное, не в основном по этой причине, это была причина главная, но как бы, понимаете, обычно программистам на секьюрити плевать, поэтому программисты начали от него отказываться, потому что он был не очень удобный, у него было много багов, он был очень медленным и прочие такие рюшечки.
1987.24 2004.40 SPEAKER_00 Но на самом деле, самая главная была причина для того, чтобы от него начать отказываться, и чтобы Микрософт его специально больше не развивал, специально не латал никакие-нибудь проблемы, это как раз в том, что сама концепция была очень сильно подвержена различным секьюрити атакам.
2004.40 2018.80 SPEAKER_00 И начиная с DotNet 7, этот байна реформатор был помечен как абсолют, при том на уровне ERROR, т.е. вы не могли скомпилить ваш проект, если вдруг почему-то использовали его до сих пор.
2018.80 2023.12 SPEAKER_00 Вот и автор наткнулся на этот ERROR и решил посмотреть, а что же такого есть на рынке.
2023.12 2028.40 SPEAKER_00 И прошло как бы 10 лет, как он решил отойти от байна реформатора.
2028.40 2036.28 SPEAKER_00 Ну, прежде всего, все микрософтовские статьи советуют переходить почему-то на текстовые форматы в виде JSON, т.е.
2036.28 2056.32 SPEAKER_00 System Text JSON, раньше до этого рекомендовали Newton Soft JSON, но выглядело для всех это довольно странно, потому что никто с драмами твердой памяти после бинарного форматора, если бы, конечно, бинарный форматор был выбран явно, никто не пойдет на JSON, потому что это всегда медленно, много и т.д.
2056.32 2069.64 SPEAKER_00 Дальше пошли смотреть на байна реформатор, также ему приглянулся Protobuf, но Protobuf требует кучу приседаний, кучу настроек, конфигурации, объявления протокола и, в общем, ему это показалось слишком сложно все.
2069.64 2076.92 SPEAKER_00 Поэтому Protobuf он скипнул и дошел до, наверное, самой очевидной вещи, на которую должен был дойти каждый, это MessagePack.
2076.92 2086.64 SPEAKER_00 MessagePack - это прекрасный сериализатор, он байнарий сериализатор, он намного быстрее, чем JSON и он намного компактнее, чем JSON.
2086.64 2101.92 SPEAKER_00 Другая прекрасная новость заключается в том, что этот MessagePack разрабатывается организацией, которая называется SciSharp и человеком, который сложно произносимым ником на GitHub'е не Uytsk, Yoshimi Kawai.
2101.92 2109.64 SPEAKER_00 Короче, чувак довольно со сложным именем, но если вы там увидите его иконку или увидите этого чувака, вы его запомните навсегда.
2109.64 2118.32 SPEAKER_00 По той простой причине, что это очень грамотный человек, который реализовал уже кучу сериализаторов, кучу парсеров.
2118.32 2125.84 SPEAKER_00 У него отличные in-memory embedded базы данных есть, у него есть там какие-то генераторы каких-то оптимизаций.
2125.84 2135.24 SPEAKER_00 В общем, это человек, который очень хорошо соображает в оптимизациях, пишет хороший код, качественный API и поддерживает свой продукт довольно хорошо.
2135.24 2146.68 SPEAKER_00 Поэтому MessagePack является одним таким и сразу дефолтным сериализатором, если вам нужен хороший, надежный, компактный, быстрый binary-series сериализатор.
2146.68 2163.52 SPEAKER_00 Про MessagePack мы уже говорили в нашем подкасте, и эта статья никогда не попала бы к нам в выпуск, если бы автор не пошел немножко дальше и нашел следующий проект вот этого товарища Kawai, который называется MemoryPack.
2163.52 2167.72 SPEAKER_00 И вот про MemoryPack мы еще не разговаривали, поэтому стоит его осветить.
2167.72 2183.52 SPEAKER_01 Но подожди, подожди, на самом деле, когда он только-только появился, про MemoryPack мы говорили, мы про него… была у нас новость, по крайней мере, про то, что вот вышла такая штука, она типа супероптимизированная, все дела, но это было что-то год назад.
2183.52 2187.80 SPEAKER_01 Я не знаю, насколько он с тех пор развивался, поэтому современная статья будет точно полезна.
2187.80 2188.80 SPEAKER_00 Давай, да.
2188.80 2195.60 SPEAKER_00 Да, наверное, когда он появился, может, и говорили, но опять же, в чем его плюсы?
2195.60 2219.12 SPEAKER_00 Плюс его заключается в том, что он использует и сразу писался на .NET 7 и C# 11, это значит, что он заюзал все возможные оптимизации, которые там ввели, а там, напомню, их было очень много, iBuffer Writer, Span, Read-only Sequence, Read-only Span, PipeWriter, PipeReader, короче, вот эти все-все-все, что только можно было.
2219.12 2222.56 SPEAKER_00 Вот он их очень плотненько заюзал, и это там как бы основная его концепция была.
2222.56 2239.56 SPEAKER_00 Это такая библиотека для Zero Encoding Extreme Performance Binary Serializator, т.е. основная его фишка в том, что он не пытается выдумать какой-то формат и в этот формат что-то записать, как делают другие сериализаторы.
2239.56 2253.12 SPEAKER_00 Он просто берет бинарный dump C# элемента, т.е. C# примитива типа, допустим, Int, и берет этот бинарный поток и просто-напросто записывает его в свой output формат.
2253.12 2254.12 SPEAKER_00 Вот как бы и все.
2254.12 2261.70 SPEAKER_00 Сериализация происходит таким же точным образом, просто-напросто массив byte замещается там, где он должен быть, и это позволяет ему как раз-таки достичь высокой скорости.
2261.70 2274.28 SPEAKER_00 Как я уже, наверное, упомянул, что одно из самых больших прелестей этого проекта в том, что он поддерживается товарищем Kawai'em, который написал уже кучу сериализаторов, в частности, кстати.
2274.28 2284.60 SPEAKER_00 ZeroFormator делая его рук, UTF-8 JSON, это был самый быстрый JSON сериализатор на тот момент, и MessagePack тоже поддерживается им.
2284.60 2290.92 SPEAKER_00 И вот весь опыт он собрал, который он делал с сериализаторами, плюс у него там, как я уже говорил, много других крутецких проектов есть.
2290.92 2294.88 SPEAKER_00 Кстати, если вы не видели его репозиторию, обязательно загляните и посмотрите.
2294.88 2298.08 SPEAKER_00 Там много всего интересного можно найти абсолютно на любой вкус.
2298.08 2307.28 SPEAKER_00 И вторая фишка после того, что он юзает самые последние структуры, которые появились для перфоманса, он полностью написан на source-генераторах.
2307.28 2312.76 SPEAKER_00 Это привело к тому, что у него появились дополнительные плюшки, которые дает source-генераторы.
2312.76 2315.80 SPEAKER_00 Мы их много раз обсуждали, но в данном разделе не грех и повториться.
2315.80 2326.28 SPEAKER_00 Это значит, что он очень дружественно настроен к native auto, т.е. к триммингу, к оптимизациям и к прочим вот этими вещам.
2326.28 2343.88 SPEAKER_00 У него отсутствует полностью рефлекшн, т.е. у него имплементация с помощью рефлекшна, т.е. весь API сделан на source-генераторах, и это ему как раз таки позволяет хорошо и триммиться, и хорошо аутиться, и хорошо и быстро запускаться под всякие оптимальные платформы.
2343.88 2373.48 SPEAKER_00 Из фишек еще у него можно диссерилизовать существующий инстанс, полиморфная диссерилизация, у него также есть TypeScript код-генератор, т.е. вы можете диссерилизовать вот этот формат не только в C#, но и в TypeScript, ну не только в дотнете, но и в TypeScript, поддержка Unity, поддерживается очень много, широкий пласт вообще всех типов, т.е. не только какие-то примитивы, но и листы, и dictionary, и mutable коллекции, и много-много всего того, чего не поддерживают обычные нормальные сериализаторы.
2373.48 2398.36 SPEAKER_00 Также есть у него специальный режим терпимости, где он может немножко ослабить свои требования к структуре ваших DTO-шек, он может позволить вам их немножко добавлять поля, переименовывать поля, но при этом диссерилизоваться это будет немножко медленнее, но если вы гарантируете, что ваши DTO-шки не изменились, там скорость вылетает просто в космос.
2398.36 2411.48 SPEAKER_00 Также у него есть поддержка Brotli, это специальный компрессор, т.е. можно вот этот весь бинарный поток, который он наделал, в то же время еще и посжимать, т.е. мало того, что он компактный сам по себе, еще и можно сжать.
2411.48 2415.68 SPEAKER_00 И все эти ухищрения дали, в принципе, немаленькие результаты.
2415.68 2425.28 SPEAKER_00 Прежде всего, если сравнивать с binary-форматором, который я уже упоминал, он мега медленный был, допустим, на бенчмарках он показал 27 попугаев, там 27 нс.
2425.28 2430.84 SPEAKER_00 Newtonsoft у нас было сразу 7 нс и System Tech JSON – 5 нс.
2430.84 2439.20 SPEAKER_00 Немножко возвращает нас к той мысли, которую мы уже упоминали в прошлых подкастах, что в принципе Newtonsoft написан с точки зрения перформанса довольно хорошо.
2439.20 2450.12 SPEAKER_00 Смотрите, у него 7 нс, а System Tech JSON, который Microsoft вкладывает все силы много последних лет, это 5 нс, т.е. не сильно быстрее, если уж на то пошло.
2450.12 2457.40 SPEAKER_00 Ну и наши лидеры – это MessagePack – 2 нс, и MemoryPack добился 1 нс на тех данных, которые там бенчмаркались.
2457.40 2471.20 SPEAKER_00 На каких-то синтезированных обычных примерах с кучей массивов, с какими-то огромными объектами, автор заявляет, что MemoryPack в 200 раз может быть быстрее любого из существующих сервизаторов.
2471.20 2474.52 SPEAKER_00 В общем, такой вот интересный наборчик.
2474.52 2482.68 SPEAKER_00 Из минуса, наверное, MemoryPack'а можно отметить то, что он будет работать между .NET-приложениями и TypeScript-овым приложением.
2482.68 2493.28 SPEAKER_00 Да, если вам нужна все-таки кросс-языковая какая-то сериализация между Python, Perl, JavaScript, Yava и т.д., то ваш выбор тогда MessagePack.
2493.28 2499.00 SPEAKER_00 Это такой же бинарный сериализатор, но поддерживается практически во всех существующих языках программирования.
2499.00 2505.88 SPEAKER_00 В общем, если вам нужна максимальная перформанс и максимальная утилизация памяти, то взгляните на MemoryPack.
2505.88 2523.44 SPEAKER_01 Ну и надо понимать, что вся эта магия перформанса нужна вам, скорее всего, именно с учетом всех тех проблем и ограничений, которые доставит MemoryPack, она нужна, конечно, только если у вас прям совсем-совсем все жестко по ресурсам.
2523.44 2532.80 SPEAKER_01 И именно поэтому, на самом деле, вот этот автор и пишет всякие такие быстрые сериализаторы туда, быстрые сериализаторы сюда, потому что они занимаются, на самом деле, разработкой игр.
2532.80 2548.56 SPEAKER_01 И в играх понятно, что чем меньше вы потратили ресурсов на один там, на отрисовку одного фрейма или на обсчет одного там типа цикла игры, тем лучше, тем плавнее все будет, тем эффективнее и так далее, тем больше можно считать.
2548.56 2551.72 SPEAKER_01 И именно поэтому у него такие довольно ограниченные штуки.
2551.72 2555.48 SPEAKER_01 Ну и почти все его проекты поддерживают Unity, как-то неудивительно.
2555.48 2557.68 SPEAKER_00 Да, что якобы намекает.
2557.68 2558.68 SPEAKER_00 Да, да.
2558.68 2564.92 SPEAKER_01 Не, ну их на самом деле прямо у организатора C# записано, что они типа Unity, game, что-то там.
2564.92 2569.40 SPEAKER_01 Так что это прям, очень прям, прям тем текстом написано.
2569.40 2574.80 SPEAKER_00 Ну то есть, если на ваших формочках вам нужно клик от кнопочки отработать, то это, естественно, подход не для вас.
2574.80 2576.36 SPEAKER_00 Джессона вам хватит за головой.
2576.36 2584.00 SPEAKER_00 А вот если вам нужно там утилизировать сетку очень сильно, у вас огромные блобы там летают, вот это вот тогда бинарь сериализаторов придет к вам очень быстро.
2584.00 2586.52 SPEAKER_01 Да, начните, наверное, с message пака, мне кажется.
2586.52 2589.84 SPEAKER_01 Если уже будет не хватать, тогда можно идти в memory pack.
2589.84 2595.04 SPEAKER_01 Ну, довольно специфический, так скажем, для очень узких ниш.
2595.04 2596.04 SPEAKER_01 Давай дальше.
2596.04 2604.00 SPEAKER_01 Дальше у нас тема, которую мы на самом деле долго-долго откладывали, потому что она довольно-таки большая.
2604.00 2613.12 SPEAKER_01 Там много чего можно смотреть, можно обсуждать, можно, наверное, несколько подкастов записать только на эту тему, но тем не менее, решил, что все-таки хватит откладывать, надо про это поговорить.
2613.12 2616.84 SPEAKER_01 Тем более, мне этот случай удачный выдался, все равно почитать все эти статейки.
2616.84 2628.44 SPEAKER_01 Речь идет о том, как же дизайнить, версионировать и вообще проектировать, дизайнить, проектировать, ну, в общем, одно и то же REST API.
2628.44 2629.88 SPEAKER_01 Масштабно замахнулся, масштабно.
2629.88 2630.88 SPEAKER_01 Масштабно.
2630.88 2706.32 SPEAKER_01 У нас в ссылочках к этому выпуску вы найдете довольно большое количество материалов на эту тему, есть огромный курс от, ну, не курс, а такой плейлист от Джеффри Рихтера, где он подробно объясняет, как Microsoft и Azure командов в частности подходят к этому вопросу, есть плюс-минус текстовая версия этих гайдлайнов, которая, понятно, я не знаю, насколько Рихтер обновляет свои видео, но гайдлайны видимо свои, они обновляют чуть быстрее, есть огромный, прямо такой монструозный, я бы даже сказал, труд от компании Золанда, у них прямо огромные гайдлайны на их open source портале, ну и есть еще ряд статей от всяких разных более или менее известных товарищей на тему, всяких разных их мыслей о том, как дизайнить правильно REST API, я попробовал это все разнести немножко по, во-первых, я попробовал все это прочитать, прочитал, ну не все, наверное, но большую часть из этого, во-вторых, я выделил для себя какие-то интересные моменты и те, которые, ну, я бы сказал так, наиболее часто возникают споры о них, либо может быть действительно какие-то неочевидные рекомендации, там есть несколько неочевидных рекомендаций, которые я, например, о которых я не задумывался.
2706.32 2710.60 SPEAKER_01 Точнее, я про них слышал, но как-то на автомате делаешь по-другому.
2710.60 2711.60 SPEAKER_01 Вот.
2711.60 2719.60 SPEAKER_01 Ну и вот мы пройдемся по ним, сколько успеем, не знаю, довольно много всего, ну и просто обсудим, кто что на эту тему думает.
2719.60 2723.80 SPEAKER_00 Может, нам стоило каждую секцию поделить на отдельную там статью?
2723.80 2730.60 SPEAKER_01 Ой, нет, слушай, обсуждать кучу выпусков подряд одно и то же мне не нравится, вот мы сейчас быстренько пробежимся.
2730.60 2747.24 SPEAKER_01 Если есть какие-то моменты по дизайну REST, которые остались не освещенными, но вам очень интересно узнать наше мнение, приходите в комменты, пишите в комментах на YouTube, и мы, если там будет очень нужен развернутый ответ, мы включим следующий выпуск, никаких проблем.
2747.24 2748.92 SPEAKER_01 Материалы у нас есть.
2748.92 2755.04 SPEAKER_00 Хорошая идея, если даже есть, присылайте ссылочки, статейки, видео, посмотрим, тоже обсудим.
2755.04 2764.12 SPEAKER_01 Ну да, если есть что-то, вот я проектирую API только вот так, согласно этой статье, никак иначе все остальные не правы, засылайте, мы почитаем, скажем, правы вы или нет.
2764.12 2766.68 SPEAKER_01 В нашем веским мнении, ну ладно.
2766.68 2780.28 SPEAKER_01 Смотри, начнем мы с простого, с принципов, то есть когда мы говорим, а давай мы спроектируем REST API, не секрет, что каждый понимает под этим нечто свое, вот.
2780.28 2850.80 SPEAKER_01 Рандомная статья из интернета, вот буквально мне просто попалось что-то типа несколько дней назад статейка из интернета с неплохим набором, с моей точки зрения, рекомендаций, говорит о том, что ну вообще подавляющее большинство народу считает за REST API, считает просто любой HTTP API, где как бы в урлах не глаголы, а существительные, вот если у тебя там плюс-минус HTTP API, плюс-минус используется там get, post, что-нибудь, и в урле у тебя не там create что-нибудь, а все-таки имена существительные, то есть каких-то ваших доменных объектов, сущностей, то все, это уже как бы REST, там 90% пользователей, которого вы спросите, скажут, да это же конечно же REST, вот, это с одной стороны, с другой стороны есть компания Zalando, которая говорит, нет, вот должен быть REST level какой-то там 2, да, самый крутой, 3 должен быть, короче, ссылки во все поля, значит, любой ответ должен подразумевать, вы можете из него куда-то уйти, в общем, вот это все.
2850.80 2862.68 SPEAKER_00 Ну подожди, тут как бы, мне кажется, это непротиворечивая вещь, если Zalando понимает, что есть REST level 3, а другие люди понимают, что есть level другие, то как бы это все покрывает.
2862.68 2867.32 SPEAKER_01 Ну, если подходить к этому вопросу академически, я с тобой соглашусь.
2867.32 2871.96 SPEAKER_01 На практике, если ты говоришь, о, это REST API, то себе не
2871.96 2872.96 SPEAKER_00 так.
2872.96 2873.96 SPEAKER_00 Технически, конечно, это REST API, почему же нет.
2873.96 2879.36 SPEAKER_01 Да, технически это REST API, но если ты спрашиваешь о какой-то level, он на тебя посмотрит и скажет, что?
2879.36 2881.44 SPEAKER_01 Ну, не все, конечно, но многие.
2881.44 2883.60 SPEAKER_00 Ну, тогда, наверное, стоит осветить, что это за левелы
2883.60 2884.60 SPEAKER_01 такие.
2884.60 2890.44 SPEAKER_01 Ну, можно осветить, да, у нас есть нулевой, вот я сейчас, кстати, не помню, определялся ли в диссертации нулевой level.
2890.44 2891.44 SPEAKER_01 Да, есть.
2891.44 2905.16 SPEAKER_00 Ну, прежде всего, это называется, схема, если вы вдруг захотите найти, это Richardson maturity model, т.е. это модель того, насколько у вас REST-овый, так сказать, и он имеет как раз 4 level, от 0 до 3.
2905.16 2909.44 SPEAKER_01 Ну, как настоящий программист писал, не с первого почитай, а от 0 до 3.
2909.44 2919.08 SPEAKER_00 Ну да, оно здесь подходит просто, потому что ибо 0, это называется вообще болото, это самое примитивное, что можно представить на нулевом уровне в виде REST.
2919.08 2921.76 SPEAKER_00 А я даже не помню, по-моему, нулевое же вообще не определяется.
2921.76 2931.80 SPEAKER_00 Не, нулевое определяется, нулевое – это когда у вас есть один endpoint, у вас есть один метод, и вы все возможные реквесты и респонсы постите в один этот метод.
2931.80 2934.32 SPEAKER_00 Ну, т.е. чтобы вы понимали… Ну, т.е. нет.
2934.32 2938.68 SPEAKER_00 Это модный GRPC, GRPC – это отстойное болото, которое считается самым простым.
2938.68 2941.56 SPEAKER_01 Не, погоди-погоди-погоди, ты путаешь, не GRPC, а GravQL.
2941.56 2947.44 SPEAKER_00 А, GravQL, точно, вот, GravQL – это болото, которое в нормальном ресте даже произносить слух страшно.
2947.44 2950.04 SPEAKER_01 Я тебе более того скажу, там еще и пост всегда.
2950.04 2954.12 SPEAKER_00 Ну вот, один единственный метод, один единственный endpoint, это называется болото.
2954.12 2967.16 SPEAKER_01 Да, значит, потом есть REST-1, когда вы начинаете разносить по урлам разным хотя бы, а потом есть REST-2, там добавляются уже глаголы HTTP, т.е. там GET, PUT, PORT, DELETE.
2967.16 2986.44 SPEAKER_00 Ну и ресурсы тоже уже на REST-2 добавляются, ресурсы, т.е. вы не просто обзываете, как вам в голову придет, т.е. не гуидами у вас теперь урлы называются, а как-то вменяемо, типа что у вас шоп, карты, мы положили товар в корзину и так далее, т.е. пытаетесь как-то натянуть это все.
2986.44 3032.24 SPEAKER_01 Да, а есть еще REST-3, и это, соответственно, уже больше про, это называется еще одним модным словом hypermedia, это когда вы в ответах на все ваши запросы, помимо собственно самой сущности, ну, т.е. например, какой-нибудь GET там, не знаю, тот самый шоп, ну, карт, да, по водичнику, т.е. получить корзину, вы помимо этого сразу в ответе не только содержимое корзины отдаете, но еще и набор мета-информации, т.е. ссылочек, что вы можете с этим сделать, т.е. например, вам очистить корзину или еще что-то сделать, и соответственно, вам не нужно, по сути, идти в документацию, вы можете посмотреть на ответ и знать полный перечень того, что можно сделать из этой ситуации с этим объектом, согласно тому состоянию, в котором этот объект находится.
3032.24 3037.44 SPEAKER_00 Как-то так, вот The Lambda как раз за последний.
3037.44 3039.24 SPEAKER_00 Прямо за третий, да?
3039.24 3043.28 SPEAKER_01 Да, ну, т.е. они сказали, он должен быть truly RESTful, вот это все.
3043.28 3047.12 SPEAKER_00 Тут нужно просто упомянуть, что до последнего доходят не все.
3047.12 3059.32 SPEAKER_00 Ну, т.е. обычно нормальные компании, нормальные люди останавливаются на втором левеле и считают, что если они там глаголы определили, ресурсы определили, и там эти ответы тоже, http-коды заиспользовали, то в принципе этого достаточно.
3059.32 3061.40 SPEAKER_00 Ну, и это, наверное, в 80% случаях правда.
3061.40 3065.72 SPEAKER_00 Ну, т.е. если вы идете дальше, все-таки вам нужна гибкая система.
3065.72 3071.68 SPEAKER_00 Ну, если вспомнить, какие у нас команды вообще дошли публичные до третьего левела, их можно посчитать там по пальцам.
3071.68 3078.28 SPEAKER_00 Я вот, на вскидку, знаю, у GitHub есть третий левел, у Vimeo есть в API третий левел, вот это что сразу в голову
3078.28 3079.28 SPEAKER_01 пришло.
3079.28 3080.28 SPEAKER_01 Ну, вот и, похоже, у Zalando.
3080.28 3086.28 SPEAKER_01 Я не пользовался, т.е. я не могу сказать, насколько они действительно соответствуют, но это же, опять же, гайдлайнс, да?
3086.28 3091.52 SPEAKER_01 Не факт, что их API написан полностью согласно гайдлайнам у всех сервисов у них, я не знаю, десятки, сотни сервисов.
3091.52 3102.04 SPEAKER_00 Не, я видел много этих лекций от Zalando, они очень много клевых практик используют, очень любят про них разговаривать, поэтому на разных конференциях это всегда одни из самых интересных спикеров.
3102.04 3104.60 SPEAKER_00 И, вроде, да, у них на практике все это используется.
3104.60 3113.12 SPEAKER_01 Я, когда мы говорим про REST Level 3, вот с этими самыми ссылочками, которые возвращаются в ответе, я не очень понимаю, зачастую, что с ними делать на клиенте.
3113.12 3122.68 SPEAKER_01 Это очень красиво, что сервер так про себя все рассказал, а вот далеко не всегда понятно, насколько умный должен быть клиент, чтобы с этим точно так же работать.
3122.68 3134.08 SPEAKER_01 Потому что в большинстве случаев все-таки, все-таки, у нас редко строится продукт по принципу, что вот тебе вернули сущность, и мы понятия не имеем, что с ней можно делать.
3134.08 3143.38 SPEAKER_01 В среднем у тебя есть какой-то бизнес-воркфлоу, который тебе нужно сделать, и тебе, в принципе, тебе достаточно понять, можно или нельзя, а не то, что все возможные вещи, которые можно.
3143.38 3147.80 SPEAKER_01 Не знаю, я вот как-то, у меня не было опыта именно с клиентской стороны общения с REST Level 3.
3147.80 3155.76 SPEAKER_00 Ну, именно поэтому, как бы, немногие компании такой запрос делают, потому что у них обычно очень узкий API, и ты там понимаешь, что ты хочешь делать.
3155.76 3163.92 SPEAKER_00 Для примера, чтобы вы понимали, что такое Hypermedia Controls, вот этот REST Level 3, вы можете вспомнить обычный HTML.
3163.92 3169.36 SPEAKER_00 Вот в обычном HTML как раз на 100% реализован Level 3.
3169.36 3172.80 SPEAKER_00 Несмотря на то, что это не API, как бы, но смысл в нем точно такой же.
3172.80 3182.88 SPEAKER_00 То есть, когда браузер загружает вам сайт, он понятия не имеет, какие на этом сайте есть экшены, то есть, какие, например, он должен дернуть URL для того, чтобы залогиниться.
3182.88 3193.32 SPEAKER_00 Но он знает, что есть некая кнопочка, и при нажатии на этой кнопочке нужно пойти на какой-то URL, и он понятия не имеет, что этот URL делает.
3193.32 3195.64 SPEAKER_00 Вот это и есть как раз Hypermedia Controls.
3195.64 3207.80 SPEAKER_00 То есть, когда вы не сообщаете вашему UI, что товарищ UI-щик, когда нажмется кнопочка, дерни вот этот метод создания юзера, потом перейди на другую страничку, там отвалидируй результат и покажи его в окошке.
3207.80 3214.28 SPEAKER_00 Вот когда вы ему это не говорите, а вы говорите, что товарищ UI-щик, вот я дал тебе API, в этом API будет специальный URL.
3214.28 3219.24 SPEAKER_00 В этом URL будет специальная ссылка, которая называется Create User.
3219.24 3225.52 SPEAKER_00 Вот ее надо показать на вот этой кнопочке, и к этой кнопочке привязывать вот это поле, куда пользователь введет там свое имя, допустим.
3225.52 3227.32 SPEAKER_00 И когда он ее нажмет, просто вызови URL.
3227.32 3243.24 SPEAKER_00 Что будет происходить дальше, мы тебе сообщим в ответе, и там тебе разложим экшены, которые можно будет сделать с этим новым юзером, отредактировать его, удалить, установить какой-то новый пароль, в общем, все это пришлется в виде списка экшенов, но не за хардкоженную UI.
3243.24 3244.24 SPEAKER_00 Вот.
3244.24 3245.24 SPEAKER_00 А теперь мы возвращаемся.
3245.24 3247.28 SPEAKER_00 В принципе, представьте браузер себе, вот обычно.
3247.28 3252.24 SPEAKER_00 У браузера как раз не за хардкоженые ни кнопки, ни менюшки, ничего, он все забирает из себя с сервера.
3252.24 3259.16 SPEAKER_01 То, что я говорил, то, что это называется словом гипермедиа, вспоминаем, что HTML, да, это гипертекст, ровно оно.
3259.16 3261.68 SPEAKER_01 А ссылки – это гиперссылки, на самом деле.
3261.68 3287.52 SPEAKER_01 То есть просто в мире современного победившего SPA, да, Single Page Applications, тот факт, что ты послал запрос на сервер про логин, означает, что сервер там что-то свое делает и когда-нибудь вернет ответ, а ты уже там это, перемалываешь какую-то логику на клиенте, который там покажет какую-нибудь анимацию логина там, еще что-нибудь, спросит тебя по пути, пока ты логинишься, еще какую-нибудь фигню про куки, ну, я сейчас фантазирую, но тем не менее.
3287.52 3294.04 SPEAKER_01 То есть у клиента своя сложная логика, и ему как бы тот факт, что ты пришлешь какой-то ответ – это просто дополнительный кирпичик.
3294.04 3295.04 SPEAKER_01 Вот.
3295.04 3300.22 SPEAKER_00 Ну да, можно назвать это богатым клиентом, да, т.е.
3300.22 3303.88 SPEAKER_00 рест и гипермедиа, они больше рассчитаны под тупого бедного клиента, под тонкого клиента.
3303.88 3311.00 SPEAKER_00 В общем, они не исключают, конечно, богатых клиентов, но в целом индустрия реста была спроектирована именно для тонких клиентов.
3311.00 3314.00 SPEAKER_00 Ну тогда да, это какой-то… Практика двинулась немножко в другую сторону.
3314.00 3315.00 SPEAKER_01 Двухтысячный год же.
3315.00 3316.00 SPEAKER_00 По-моему, диссертация.
3316.00 3317.00 SPEAKER_01 Не знаю.
3317.00 3318.00 SPEAKER_01 Диссертация Роя Филдинга.
3318.00 3319.00 SPEAKER_01 Не помню.
3319.00 3325.08 SPEAKER_01 Собственно, Роя Филдинга, который придумал эту штуку, да, по-моему, 2000 или 2001 год, сейчас могу ошибиться.
3325.08 3333.04 SPEAKER_01 И тогда, понятное дело, ну, SPA, был ли тогда Якс уже хотя бы?
3333.04 3334.04 SPEAKER_01 Да-да, был.
3334.04 3335.04 SPEAKER_01 Был, да?
3335.04 3336.04 SPEAKER_01 Ну конечно.
3336.04 3338.84 SPEAKER_01 Хорошо, я не помню, я тогда особо не программировал ещё.
3338.84 3362.00 SPEAKER_00 Кстати, можно тут сразу под шумок порекомендовать шикарный доклад от делана Бити, если вы хотите разобраться в ресте вот этих всех уровнях на очень хороших примерах, довольно лёгких, примитивных, понятных, с хорошим юмором от прекрасного автора, то доклад называется "Real World REST and Hands-On Hypermedia", который он делал на dotnext, кстати, был его самый первый доклад в России.
3362.00 3365.52 SPEAKER_00 В общем, посмотрите, доклад до сих пор не потерял свою актуальность, потому что REST никуда не делся.
3365.52 3366.52 SPEAKER_01 Да.
3366.52 3369.96 SPEAKER_01 Ну так вот, ладно, пойдём дальше.
3369.96 3373.04 SPEAKER_01 Мы потратили уже много времени на то, чтобы обсудить, что же такое REST.
3373.04 3377.56 SPEAKER_01 На самом деле, рекомендации дальше, они все очень прям конкретные.
3377.56 3401.44 SPEAKER_01 Я осмотрел, давайте так, брал три основных источника, это майкрософтская статья, это заландовская статья, и это статья неизвестного мне автора, которая мне так немножко отозвалась, что да, похожа на то, что я обычно стараюсь использовать, хотя некоторые были довольно забавные рекомендации, ну забавные, на английском есть хорошее слово "controversial", то есть противоречивые, да, наверное, правильно сказать, рекомендации, которые непонятно следуют или нет.
3401.44 3403.32 SPEAKER_01 Давай пойдём по частям.
3403.32 3404.60 SPEAKER_01 Начнём с первого, это Урлы.
3404.60 3416.52 SPEAKER_01 Это у нас, собственно, главное и первое, что видит пользователь, когда начинает работать с REST, и здесь, в принципе, все сходятся в том, что надо использовать множественное число для сущностей.
3416.52 3428.16 SPEAKER_00 Ну тут смотри, это не то, чтобы для сущностей, потому что для сущностей множественное число звучит странно, это всё-таки коллекция, это ресурсы, которые представляют собой коллекцию сущностей, и тогда понятно, почему множественное.
3428.16 3439.40 SPEAKER_01 Так а у тебя почти всегда будет сущность, это дальше ты, ну давай так, хорошо, сущность, которая имеет идентификатор, потому что почти всегда у тебя это будет потенциально коллекция сущностей.
3439.40 3454.24 SPEAKER_01 Может быть, ты не будешь иметь возможность получить коллекцию, например, если у тебя есть какой-нибудь шоппинг-карт, ну хотя вот с другой стороны, да, вот у тебя есть корзина, да, шоппинг-карт, технически в бэкэнде их много, но у каждого клиента она своя,
3454.24 3455.24 SPEAKER_00 правильно?
3455.24 3458.48 SPEAKER_00 Ну подожди, API-то всё-таки дёргается для конкретного клиента.
3458.48 3461.92 SPEAKER_01 Вот, да, для конкретного клиента она одна всегда, но у неё она… Она всегда одна.
3461.92 3464.88 SPEAKER_01 Ну если у неё… А, может быть, несколько, например.
3464.88 3470.84 SPEAKER_00 Ну обычно в магазинах нескольких не бывает, давай, может быть, конечно, может быть, но 99% у тебя всегда в магазине одна корзина.
3470.84 3475.44 SPEAKER_01 А, ну тогда у тебя не будет айдишника, да, согласен, ну тут тогда это самое, единственное число, окей.
3475.44 3493.60 SPEAKER_00 Кстати, здесь минутка весёлого, да, почему у неё не будет айдишника, потому что на заре времён, когда только начинали делать сайты, программисты именно делали вот так, что у тебя есть множество корзин и есть айдишник, и соответственно ты мог по айдишнику обратиться к своей корзине, и умные люди просто взяли, ну т.е.
3493.60 3498.08 SPEAKER_00 брали и эти айдишники перебирали, и по факту ты мог посмотреть в корзины других пользователей.
3498.08 3511.60 SPEAKER_00 Вот, и чтобы такого, таких глупостей как бы не делали, вот сделали такие вещи, что если урл относится к текущему пользователю, и этот пользователь не должен видеть никакие другие корзины, то айдишник просто не передаётся.
3511.60 3512.60 SPEAKER_00 Ну да, желательно его скрывать.
3512.60 3513.60 SPEAKER_01 Небольшой хак.
3513.60 3522.40 SPEAKER_01 Вот, очень желательно, и находите его какой-то внутренней логикой внутри у вас на сервере, там в сессии храните или просто поднимайте по юзер айди, какая же у него корзина.
3522.40 3523.40 SPEAKER_01 Это уже другое дело.
3523.40 3524.40 SPEAKER_01 Дальше.
3524.40 3553.52 SPEAKER_01 В целом все довольно, ну давай так, не очень однозначно, но в целом говорят, что не надо добавлять ненужные кусочки пути, т.е. если у вас есть ресурс и у него есть подресурс, при этом подресурс довольно уникальным образом определяется своим айдишником, т.е. его айди уникален не только в рамках родительского ресурса, а вообще в системе, то не надо тогда передавать вот этот вот топовый ресурс, айдишник его всегда в урле.
3553.52 3554.52 SPEAKER_01 Ну, грубо говоря.
3554.52 3578.76 SPEAKER_01 Если у вас есть разные сущности, которые принадлежат одному пользователю, не надо везде писать users/userid/books, что-нибудь или там /posts, что-нибудь, /comments, что-нибудь, userid, ну, в общем, во-первых, и так понятен из контекста, ну, userid в этом смысле плохой пример, но даже если он не был бы понятен из контекста, если у тебя блок-пост имеет уникальное id, достаточно сделать /posts/id.
3578.76 3607.80 SPEAKER_00 Ну, здесь, наверное, могут быть исключения, потому что иногда иерархия тебе позволяет эти урлы удобнее читать, т.е. нужно сказать, что rest level 3, он в отличие от болота, подразумевает то, что эти урлы должны быть пользователям хорошо читаемыми, и именно на это направлено большинство практик, ну, т.е. для машины наплевать, у тебя с ресурсами коллекции во множественном числе или в единственном называется, ей все равно, а вот пользователь, когда это будет читать, у него уже будет какое-то или понимание, или недопонимание.
3607.80 3611.20 SPEAKER_00 Поэтому бывают такие ресурсы, которые логичнее представить в виде иерархии.
3611.20 3625.28 SPEAKER_00 Город, страна, дом, если вы просто напишите дом 10, ну, дом с гуйдом, допустим, у вас будет смотреться не так красиво, как если бы вы написали, там, страна Россия, город Санкт-Петербург, улица такая, дом такой-то.
3625.28 3630.16 SPEAKER_01 Ну только теперь мы вспоминаем, что дом – это гуид, и поэтому это будет страна гуид, город гуид.
3630.16 3633.08 SPEAKER_01 Ну, именно так, да-да, это уже другой вопрос.
3633.08 3647.64 SPEAKER_01 Ну про это, кстати, тоже есть отдельная рекомендация, что для таких well-known штук, ну в смысле, допустим, для страны, тупо используйте, у нас есть как бы стандартная классификация этих самых двухбуквенных кодов стран, вот используйте ее, не надо ничего придумывать своего.
3647.64 3660.64 SPEAKER_01 Чем более стандартная штука, тем более стандартная, ну т.е. если на какую-то сущность есть стандартная ее репрезентация, хоть как-то классифицированная, используйте ее, облегчите жизнь потребителю гораздо больше.
3660.64 3668.24 SPEAKER_00 А еще желательно, чтобы эта стандартная стандартизация была url-френдли, потому что не все стандартизации у нас хорошо эскейпятся.
3668.24 3697.00 SPEAKER_01 Это правда, это правда, ну вот, и последнее, предпоследнее, что про урлы, тоже, кстати, мне кажется, что я не так часто это встречаю, и Майкрософт из Оландо говорит, надо предпочтительно использовать кебаб, кейзинг, это который, если у вас в урле в сущности нужно указать несколько слов подряд, ну в смысле, в одном термине, да, в одном сегменте, то нужно использовать дефис, не подчеркивая, не camel-кейзинг, когда с большой буквы пишется, а через дефис, и все, лаверкейзинг.
3697.00 3732.76 SPEAKER_00 Ну, я хочу сказать, что это правило, оно как бы довольно, сейчас скажу, не то, чтобы спорное, оно довольно поздно появилось в индустрии, т.е. уже после того, как RSTPI там хайпанул, приобрел своих последников, выпустилась куча книжек, и, к сожалению, у каждой компании раньше были свои какие-то рекомендации, именно поэтому у кого-то там Pascal, у кого-то Camel, у кого-то Kebabs, у кого-то Snake, в общем, разбродилось, разбродилось вот это все поверье, но именно, да, именно Kebab-кейс в последнее время начали писать у себя многие большие компании.
3732.76 3737.96 SPEAKER_00 Я не знаю, они там специально договорились или не специально, но вот NSC к этому явно в последнее время идет.
3737.96 3748.16 SPEAKER_01 Да, и везде написано не в формате рекомендаций, а в формате просто «не забудьте, что вообще-то та часть, которая не является доменным именем, она case-sensitive», т.е.
3748.16 3762.72 SPEAKER_01 вот весь URL, который вправо от после доменного имени, он вообще говоря case-sensitive, и надо бы его рассматривать именно так, хотя в Microsoft написано «не, но если там правда GUID передается, GUID можно и так, и сяк».
3762.72 3767.32 SPEAKER_01 Короче, там куча всяких разных но, но вообще-то case-sensitive по стандарту.
3767.32 3786.36 SPEAKER_00 Ну, кстати, да, и это довольно-таки мало людей знает почему-то, потому что в RLAC все привыкли видеть какое-то безобразие и об этом не задумываются, и иногда у нас, например, пользователи писали баги, типа я вот по ID-шнику такому запрашиваю ресурс, а он не находит, а он там ID-шник руками вбивал и немножко буковки перепутал, кейсы как раз-таки.
3786.36 3789.64 SPEAKER_00 Поэтому это правда, да, смотри на case-sensitive.
3789.64 3798.80 SPEAKER_00 Про GUID я тебе хотел немножко поправить, что это же все-таки не зависит от кейса, потому что GUID у него есть свой собственный парсер, и вот парсер сам решает, sensitive или не sensitive.
3798.80 3799.80 SPEAKER_00 Ну это да.
3799.80 3800.80 SPEAKER_00 Именно поэтому ты можешь там передать.
3800.80 3807.64 SPEAKER_01 Я понимаю, почему так происходит, но как бы у Microsoft в статье написано, что типа, мол, вообще-то оно case-sensitive.
3807.64 3816.16 SPEAKER_01 Ну там написано, но типа есть определенные сегменты с определенными типами данных, которые, ну и вот в общем дальше, да.
3816.16 3820.32 SPEAKER_01 Ну вообще да, рассчитывайте, что это всегда case-sensitive, это точно не ошибетесь.
3820.32 3860.96 SPEAKER_01 И последний момент интересный, смотри, в Rust-е level 2, ну вообще в Rust-е, да, у нас известная проблема, что у нас нет возможности делать экшены, в смысле, если у тебя через HTTP-глаголы не выражается что-либо, точнее, если тебе нужно выразить что-то, кроме create, read, update, delete, которые выражаются через HTTP-глаголы, то полноценные Rust-гайдлайны говорят, что нужно завести новый ресурс, к нему делать пост, создание операции по чему-нибудь, потом проверять ее статус, ну это типа такой, я не видел особо, чтобы таким пользовались, ну кроме действительно длинных операций.
3860.96 3865.72 SPEAKER_01 У Microsoft в этом смысле сейчас современные Azure-рекомендации довольно простая.
3865.72 3895.32 SPEAKER_01 Если вам нужно что-то сделать с какой-то сущностью, до которой вы, например, дошли по айдишнику, ну я не знаю, опубликовать блокпост, вот давай предположим, что это именно экшен, который нужно сделать, то url для такой операции будет выглядеть как там, пост, слэш, айдишник его, двоеточие, паблиш, т.е. глагол вот этого экшена делается через двоеточие, ну и естественно используется пост в этом случае, вот.
3895.32 3903.04 SPEAKER_00 Ну, ты затронул две темы, т.е. ты затронул тут асинхронные операции и связал их с постом, т.е. пост не всегда может быть асинхронный.
3903.04 3920.08 SPEAKER_01 Нет, смотри, смотри, смотри, да, я говорю, что идея в том, что, т.е. для любых асинхронных операций подход примерно понятие, да, дергаем пост, получаем какой-то айдишник, потом по нему там полим и выясняем статус асинхронной операции.
3920.08 3928.56 SPEAKER_01 Это как бы такой более-менее сложившийся паттерн, с которым примерно все согласны, насколько я вижу по статьям и в среднем по интернету.
3928.56 3943.56 SPEAKER_01 Но вот когда у тебя возникает вопрос, а вот как сделать операцию паблиш-посту, ну предположим, что это не просто обновление, да, одного и проперти, да, это некоторый процесс, который нужно запустить с какими-то дополнительными аргументами, то есть несколько техник.
3943.56 3970.96 SPEAKER_01 Ты можешь сделать что-нибудь типа пост, пост в смысле http-шный пост, там, www, что-нибудь, /blockpost/1/publish, а можешь сделать /1:publish, вот с двоеточием я, честно говоря, подхода не видел, хотя, признаться, ажурным как раз API им пользовался одно время, но что-то мне не попадались, видимо, такие действия, которые требовали прям глагола /action, вот Майкрософт говорит, давай через двоеточие, чтоб вот точно было понятно.
3970.96 3980.08 SPEAKER_00 Действительно, я думаю, это такое их довольно новомодное предложение, потому что как бы устоявшийся в индустрии подход в том, что всё, что угодно можно выразить через REST.
3980.08 3994.92 SPEAKER_00 В данном конкретном твоём случае, когда мы хотим опубликовать блокпост, мы всего лишь навсего находим url, ресурс, который называется публикации, и добавляем в ресурс публикации новый пост, вот таким образом ты публикуешь пост, вот и всё.
3994.92 3999.80 SPEAKER_00 То есть сводишь это всё к пустому чайнику первому случаю.
3999.80 4005.68 SPEAKER_00 У тебя для всего могут быть ресурсы, и для публикаций, и для запусков, и для скедурингов, и для чего угодно.
4005.68 4007.92 SPEAKER_01 Да, но проблема в том, что публикация не имеет айтишника
4007.92 4008.92 SPEAKER_00 своего.
4008.92 4009.92 SPEAKER_00 Ну почему это проблема?
4009.92 4016.84 SPEAKER_00 Ты же можешь в публикацию запульнуть пост, можешь, о том, что тебе не нужно публикации все считывать по айтишнику, ну не нужно, ну не считывай.
4016.84 4018.48 SPEAKER_01 Что здесь проблема?
4018.48 4062.20 SPEAKER_01 Ну проблема в том, что мне, например, такой подход кажется прям контринтуинтивным, в смысле, что мы привыкли, то есть сейчас сформулирую, во многих доменах мы привыкли к действию, прямому действию над объектом, в данном случае это как бы косвенное действие над объектом, ты не, у тебя главный объект, к которому ты обращаешься в урле, это пост, я хочу обратиться в урле к посту и с ним что-то сделать, а не я хочу обратиться в урле к публикации, а передать пост где-то там в аргументах, то есть вот этот вот переход, очень многих, меня в том числе, на самом деле сильно замедляет, когда я пытаюсь понять или осознать какой-то API, это прям вот.
4062.20 4085.04 SPEAKER_00 Смотри, мне кажется, ты сделаешь следующую ошибку, ты зря смешиваешь домен и транспортный уровень, то есть по сути HTTP это у тебя транспортный уровень, ну например, когда ты там по сигналеру передаешь, это все в хабе летает по кусочкам как бы бинарного протокола, ты же не пытаешься все в голове уложить в какой-то бизнес логичный процесс, ты понятия не имеешь там, как листанер это листанет, HTTP сокетит, это сосокетит.
4085.04 4086.04 SPEAKER_00 Все так.
4086.04 4099.40 SPEAKER_00 Так здесь у тебя нужно делить, что действительно в бизнес домене ты обращаешься к терминам поста, но это транспортный протокол, это REST, он тебе не призван идеально описывать бизнес домен, он не про то, он не про описание домена вообще, он про протокол общения.
4099.40 4118.00 SPEAKER_01 С этим я с тобой согласен, но, к сожалению, процентов, пандомное число, 60 API-шек, с которыми я встречаюсь, единственное, что содержит, это свагерспеку без описания того, что если вы хотите сделать вот такой бизнес процесс, вам нужно подергать API-методы в таком-то порядке.
4118.00 4122.64 SPEAKER_01 И ты понимаешь бизнес процесс только глядя на свагерспеку.
4122.64 4124.20 SPEAKER_00 Ну, на OpenAPI-спеку.
4124.20 4127.32 SPEAKER_00 Ну, опять же, может это проблемы документации или проблемы
4127.32 4128.32 SPEAKER_01 еще чего-то.
4128.32 4145.68 SPEAKER_01 Это может быть проблемы документации, то есть понятно, что было бы здорово, если бы REST API был чисто технической штукой, и мне просто было понятно, окей, и мне нужно сначала создать блокпост, отредактировать его, добавить черновики, картинок довесить, и потом опубликовать.
4145.68 4154.56 SPEAKER_01 И рядышком с этим описанием бизнес процесса, у меня было бы, типа, для этого сделай PUT такой-то, для этого сделай POST такой-то, для этого сделай POST такой-то.
4154.56 4159.36 SPEAKER_01 Мне тогда не важно, тогда я просто беру механически, что мне сказали сделать, то и делаю.
4159.36 4165.52 SPEAKER_01 Проблема в том, что API-шек, где написано так, в моей практике, по крайней мере, катастрофически мало.
4165.52 4174.44 SPEAKER_00 Кстати, вот эту самую штуку делает гипермедия, потому что гипермедия тебе возвращает абстрактные экшены, которые тебе нужно просто вызывать, не задумываясь о том, по какому урлу она там находится.
4174.44 4177.48 SPEAKER_01 Не совсем, гипермедия не возвратит тебе контент-боди.
4177.48 4186.64 SPEAKER_00 Ну почему же это не возвратит, конечно, возвратит, но это же такой же обычный урл, ты его можешь дернуть и что-то оттуда получить.
4186.64 4197.52 SPEAKER_01 Нет, нет, нет, в смысле, я не уверен, что ты можешь в гипермедии передать ожидаемый боди-реквеста.
4197.52 4203.36 SPEAKER_00 Ты можешь передать там боди, ты можешь передать там форматор, которым ты хочешь отформатировать, и можешь передать там другие ожидания.
4203.36 4209.36 SPEAKER_00 Это обычная HTTP, грубо говоря, запрос, просто более высокоуровневый, в терминах бизнеса, а не в терминах какой-то транспорта.
4209.36 4215.68 SPEAKER_01 Слушай, может быть, но возвращаемся к вопросу, цена, так сказать, и польза.
4215.68 4229.08 SPEAKER_01 Я такие API-шки, скажем так, не понимаю и не люблю, потому что это сильно, когда у меня домен сильно совпадает с транспортным уровнем, это очень, ну как бы, ценно и легко.
4229.08 4230.08 SPEAKER_00 Потом в отладке.
4230.08 4237.12 SPEAKER_00 Мне кажется, смотри, если мы возьмем какие-нибудь статьи, которые пропагандирует gRPC, вот это как раз один эндпоинт, и делай там с ними что хочешь.
4237.12 4238.12 SPEAKER_00 GraphQL.
4238.12 4239.12 SPEAKER_00 GraphQL.
4239.12 4244.12 SPEAKER_00 То у них как раз-таки вот это, что мы сейчас обсуждаем, вот это проблема.
4244.12 4253.92 SPEAKER_00 Ну то есть нужно признать, что у HTTP-транспорта, у REST давай так, это проблема, что не всё выражается довольно интуитивными бизнес-терминами.
4253.92 4257.94 SPEAKER_00 А вот если мы берём GraphQL, то там ты у любой сущности можешь, по сути, дёрнуть любой метод.
4257.94 4261.72 SPEAKER_00 То есть они это ставят как свой плюс, если мы сравним с REST.
4261.72 4263.84 SPEAKER_00 Ну да, есть у них такой плюс, есть у REST-а такой минус.
4263.84 4272.76 SPEAKER_01 Ну вот тут скорее, да, про то, что вопрос, надо ли стремиться к тому самому REST-левел, 2 или 3, с точки зрения вообще всех операций.
4272.76 4279.52 SPEAKER_01 Кажется, что, с моей точки зрения, нет, не надо, но кажется, что индустрия куда-нибудь пойдёт в другое место.
4279.52 4284.14 SPEAKER_01 Ладно, давай с урлами плюс-минус закончим и пойдём к следующей части.
4284.14 4287.72 SPEAKER_01 Это контракты, там про эти глаголы мы поговорим чуть позднее.
4287.72 4290.56 SPEAKER_01 Давай немножко про контракты, что тут все говорят.
4290.56 4297.92 SPEAKER_01 Ну, в среднем все там плюс-минус сходятся в том, как нужно делать контракты.
4297.92 4306.16 SPEAKER_01 То есть почти все говорят, что не надо возвращать массивы в качестве топ-левел сущности, потому что это не расширяемый контракт вообще.
4306.16 4313.88 SPEAKER_01 Массив всегда должен быть под ключиком каким-нибудь, потому что иначе вы не сможете ничего дополнительно вернуть, помимо массива.
4313.88 4326.52 SPEAKER_00 Ну, то есть, допустим, если массив у вас вырос, и вы хотели сделать пейджинг, и хотите теперь возвращать в этом объекте count, сколько всего элементов в этом общем массиве, а не только то, что вы сейчас вернули, сколько элементов на этой странице.
4326.52 4334.52 SPEAKER_00 Это вполне нормальная эволюция процесса и, скорее всего, в больших коллекциях, когда они у вас вырастут, вы с этим столкнётесь.
4334.52 4343.32 SPEAKER_00 И вот такое изменение вы не сможете сделать, если вы возвращали массив топ-левелом, а если вы это запихивали под ключиком как отдельное какое-то одно поле, то там добавляете вообще всё, что хотите.
4343.32 4344.32 SPEAKER_01 Да.
4344.32 4354.76 SPEAKER_01 Интересная рекомендация как раз из статей, неизвестной статьи из интернета, которая не встречается ни в The London, ни в Microsoft, по крайней мере, я не нашёл, может, пропустил там много их.
4354.76 4365.20 SPEAKER_01 Это про то, что момент номер один, всегда для всех идентификаторов в контракте используйте строки, т.е. даже если у вас в BD число, отдавайте всё равно строку.
4365.20 4376.60 SPEAKER_01 Потому что кто знает, как что изменится, а строки точно всё сожрут внутри себя, т.е. если вы потом решите перейти на Гуиды, то не надо будет менять контракт на Пишки, по сути.
4376.60 4390.20 SPEAKER_00 Да, вот это, кстати, очень полезное правило, которое почему-то очень редко встречается, я тебя поддержу и сам пользуюсь именно таким подходом, потому что, опять же, обычно, когда вы возвращаете айтишники, это идентификаторы из базы данных.
4390.20 4395.16 SPEAKER_00 А то, какую базу данных сейчас использует приложение, это личное дело любого микросервиса.
4395.16 4398.24 SPEAKER_00 Т.е. если он сейчас это в памяти хранил, у него там могут быть инты.
4398.24 4408.08 SPEAKER_00 Завтра он подрос, у него там будет какой-нибудь пастгря, потом он перейдет на какой-нибудь MS SQL, там у него должны быть Гуиды, при том не просто Гуиды, а сортированные Гуиды и так далее, и тому подобное.
4408.08 4412.96 SPEAKER_00 Потом, если нужны шарды, то там желательно ещё добавить номер кластера перед каждым этим айтишником.
4412.96 4423.64 SPEAKER_00 В общем, и внутри самого сервиса, сервис обязан мочь переходить на любую базу данных, на ту, которая полностью удовлетворяет его как бы системам, его системам.
4423.64 4424.64 SPEAKER_00 А требования могут меняться, как вы все понимаете.
4424.64 4430.32 SPEAKER_00 И сервис как раз-таки не должен наружу декларировать, а какого типа у него идентификаторы.
4430.32 4435.12 SPEAKER_00 Поэтому в JSON строка – это как раз не декларирование типа, это там object.
4435.12 4446.12 SPEAKER_00 Вот если вы в коде возвращали бы object, то в JSON вы должны возвращать string, и вот как раз идентификатор – это та внутренняя логика, которую сервис обязан как бы контролировать самостоятельно.
4446.12 4452.40 SPEAKER_00 И никто снаружи не может эти айтишники, по сути, никак их интерпретировать и никак на них рассчитывать.
4452.40 4453.40 SPEAKER_01 Вот.
4453.40 4460.12 SPEAKER_01 А теперь есть второй кусочек этой рекомендации, который на самом деле я встречал несколько раз, не у больших ребят, но во многих статьях.
4460.12 4463.20 SPEAKER_01 Называется «используйте префиксы для ваших идентификаторов».
4463.20 4465.24 SPEAKER_01 То есть, о чем речь?
4465.24 4471.72 SPEAKER_01 Это поможет, то есть это как бы для облегчения жизни клиентским разработчикам и в каком-то смысле саппорту.
4471.72 4485.68 SPEAKER_01 То есть если у вас, например, есть, не знаю, возвращаемся к нашему традиционному примеру про блокпосты и комменты, у каждого из них, предположим, есть уникальный идентификатор, да, сквозной, ну потому что они лежат в каждой своей табличке в BD, допустим, и там сквозная нумерация.
4485.68 4505.48 SPEAKER_01 Так вот, вы возвращаете не просто строчку с содержимым 1, строчку с содержимым 2, строчку с содержимым 3, а для всех постов вы возвращаете строчку с содержимым p1, p2, p3, то есть с префиксом p, типа что это посты, а для комментов вы возвращаете строчку с префиксом c, да, c1, c2, c3.
4505.48 4524.40 SPEAKER_01 Клиенту пофигу, потому что это строка все равно, он не должен ее парсить, он не должен с ней ничего делать, это просто прозрачная для него строка, но во-первых он сам понимает, что ага, тут мне вернулись, там, идентификатор на p, значит окей, типа это наверное про посты, а тут на c, значит это наверное про комменты, в таком духе.
4524.40 4526.00 SPEAKER_01 Чисто просто понятнее становится.
4526.00 4540.28 SPEAKER_01 При этом, при этом автор говорит, что ну вообще-то, вообще-то не нужно обязательно считать, что вот этот вот айдишник, который вы возвращаете пользователю, должен совпадать с primary ключиком вашей базы.
4540.28 4557.96 SPEAKER_01 Вообще говоря, вы можете использовать юиды для хранения в базе, а пользователю возвращать что-то более осмысленное, например, или еще каким-то образом там компаунд ключ собранный, как ты говоришь, из шарда или еще из чего-нибудь, это не обязательно так, не надо всегда возвращать primary key наружу.
4557.96 4571.16 SPEAKER_00 Смотри, наверное более распространенный пример это когда у вас в базе все хранится все-таки синтами, потому что это должно быть красивенько и все такое, но наружу вы не хотите отдавать инты, потому что они легко подбираются, и пользователь может подобрать их просто чисто перебором.
4571.16 4582.88 SPEAKER_00 Поэтому существуют специальные библиотечки, которые превращают ваши инты, то есть хешируют их по словарю в какой-то хеш, которых перебирать в принципе бесполезно, но при этом он у вас остается довольно читабельным, коротким и так далее.
4582.88 4587.36 SPEAKER_01 Надо сказать, не хешируют здесь важно, а именно конвертируют, потому что обратная конвертация тоже возможна.
4587.36 4590.96 SPEAKER_01 Вам же нужно из этого айдишника обратно-то свою чиселку получить, когда к вам придут.
4590.96 4593.96 SPEAKER_00 Да, да, ты прав, именно так.
4593.96 4596.56 SPEAKER_00 Я ещё хотел добавить про префиксы.
4596.56 4610.64 SPEAKER_00 Я тоже эту технику с префиксами очень много использую, и действительно, может быть, многие из вас, кто особенно любит гуйды, встречались с такими, что приходишь в базу данных какой-нибудь, а там есть 10 колонок, и во всех этих колонках написано «айдишники», и всё это гуйдами забито.
4610.64 4624.08 SPEAKER_00 И ты, естественно, без какой-то чёрной магии недели, проведённой над этим дампом, никогда не сможешь понять, а чьи это гуйды, откуда они прилетели, и что они там лежат, потому что название колонок тоже имеет свойство переименовываться, записаться не туда и так далее.
4624.08 4627.00 SPEAKER_00 В общем, по названию иногда бывает не добраться.
4627.00 4630.18 SPEAKER_01 Ну подожди, ты хочешь сказать, что ты префикс даже в базу положишь?
4630.18 4631.18 SPEAKER_01 А как же?
4631.18 4632.18 SPEAKER_01 Смотри.
4632.18 4634.92 SPEAKER_01 Там юидные типы колонок, там вот это всё.
4634.92 4636.92 SPEAKER_00 Не-не-не, немножко не так.
4636.92 4640.20 SPEAKER_00 Или вот смотри, более, наверное, такой правильный пример, это в логах.
4640.20 4648.36 SPEAKER_00 Вот ты в логах видишь сообщение «сущность такая не может быть там вставлена», и айдишник этой сущности, и всё, и больше у тебя никакой информации о ней нет.
4648.36 4649.36 SPEAKER_00 Ну там, наверное, логер.
4649.36 4655.08 SPEAKER_00 Наверное, ты можешь пойти, достать код, достать какой-то проект, найти где там логеры, посмотреть, а что же за сущность была вставлена.
4655.08 4670.20 SPEAKER_00 А вот если у тебя есть префиксы, которые рассказывают, что это, в принципе, айдишник поста был, то есть по правде в айдишник добавляется там, допустим, «п» или можно просто «пост», если это слово небольшое, то ты сразу по айдишнику видишь, что в логах у тебя залогировано.
4670.20 4671.20 SPEAKER_00 То есть айдишник какой сущности.
4671.20 4677.76 SPEAKER_00 И про базы данных пример я тебе привел, это когда у тебя внешняя база данных хранит ссылки на твои сущности.
4677.76 4682.40 SPEAKER_00 То есть внешняя база данных воспринимает твои айдишники как строки.
4682.40 4684.20 SPEAKER_00 Она не может оттуда выделить ни префикс, ничего.
4684.20 4689.92 SPEAKER_00 Она взяла строку, как-то я дал, и положила к себе как бы референс к этому пользователю, я его люблю, завтра я к нему схожу.
4689.92 4692.52 SPEAKER_00 И у нее в базе, да, хранятся это все именно с префиксами.
4692.52 4697.96 SPEAKER_00 И ты, когда на ее базу смотришь, ты видишь сразу все вот эти внешние зависимости, ты понимаешь, откуда они.
4697.96 4702.72 SPEAKER_00 То есть я в свой префикс добавляю не только имя сущности, я добавляю еще имя сервиса.
4702.72 4708.72 SPEAKER_00 Естественно, сокращённое, но я по айдишнику могу определить, во-первых, сервис, а во-вторых, сущность из этого сервиса.
4708.72 4710.40 SPEAKER_00 И только потом его ГУИД.
4710.40 4711.40 SPEAKER_00 Прикольно.
4711.40 4712.40 SPEAKER_00 Прикольно.
4712.40 4713.40 SPEAKER_01 Окей.
4713.40 4714.40 SPEAKER_01 Хорошо.
4714.40 4715.40 SPEAKER_01 Давай еще поговорим.
4715.40 4716.40 SPEAKER_01 А, смотри.
4716.40 4717.40 SPEAKER_00 Еще одна мелочь.
4717.40 4724.92 SPEAKER_00 Многих людей коробит, потому что, когда ты добавишь имя сервиса, потом еще имя сущности, а потом еще ГУИД, у тебя превращается в ГУИД очень большой.
4724.92 4727.54 SPEAKER_00 То есть айдишник превращается в что-то очень большое.
4727.54 4728.68 SPEAKER_00 Здесь есть небольшой лайфхак.
4728.68 4734.64 SPEAKER_00 На самом деле ГУИД шифруется шестнадцатиличным числом.
4734.64 4736.20 SPEAKER_00 Шестнадцатиличная система измерения.
4736.20 4738.36 SPEAKER_00 Это никакого смысла вообще не имеет.
4738.36 4744.44 SPEAKER_00 Берете стандартный какой-нибудь Base64 или еще что-то лучшее и шифруете по полному алфавиту.
4744.44 4750.28 SPEAKER_00 Как я уже сказал, URL он case-sensitive, поэтому никаких проблем у вас не будет, если у вас там даже все буквы будут скакать.
4750.28 4754.04 SPEAKER_00 И у вас ГУИД уменьшается прямо легко в пару раз вообще.
4754.04 4759.20 SPEAKER_00 Не надо шифровать шестнадцатиличную систему, это не имеет никакого смысла.
4759.20 4766.24 SPEAKER_01 Да, либо есть всякие там Snowflake ID, вот эти все, которые аналоги такие же, плюс-минус сортируемые, но которые занимают существенно меньше места.
4766.24 4767.24 SPEAKER_00 Можно на них посмотреть.
4767.24 4775.00 SPEAKER_00 То есть если вы ГУИД по размеру уменьшаете, то то, что вы добавляете префикс, грубо говоря, сохраняет вам примерно ту же самую длину и вас это будет меньше коррубить.
4775.00 4777.16 SPEAKER_01 Так, что еще интересного?
4777.16 4786.96 SPEAKER_01 Ну понятно, используйте структурированные ROR, это все говорят, ISO 8601 для timestamps и для всяких других дат и прочего.
4786.96 4795.32 SPEAKER_01 Причем сказано, что когда вы форматируете это все потом в JSON, в ISO 8601, не доверяйте вашей, короче, платформе про то, что она корректно сделает.
4795.32 4809.16 SPEAKER_01 Лучше напишите явную спецификацию формата, что вы хотите, потому что дефолты меняются, подходы меняются, а вот если вы точно напишете, что там yyyy, mm, dd, вот это все, то точно не поменяется.
4809.16 4810.32 SPEAKER_01 Лучше пишите явно.
4810.32 4825.32 SPEAKER_01 Так, для строк, да, вот это, кстати, у Майкрософта прям очень большой раздел указан, для любых строк, которые встречаются в вашем контракте, напишите четкий контракт.
4825.32 4832.60 SPEAKER_01 То есть для каждого поля, которое строка, напишите, если там, ну типа если это а-ля Unum, то напишите какие значения там могут быть.
4832.60 4837.28 SPEAKER_01 Это не значит, что там не может быть других, но хотя бы вот эти точно могут быть.
4837.28 4843.76 SPEAKER_01 Если это поле ограничено по длине, напишите, если оно там, ну понятно, что всякие обязательности точно нужно указывать и так далее.
4843.76 4848.84 SPEAKER_01 То есть не должно быть в контракте поля, в котором просто написано "строка".
4848.84 4856.52 SPEAKER_00 Ну это немножко напоминает языки со слабой типизацией типа Питона, да, где там всё на свете может храниться во всём, чем угодно.
4856.52 4859.24 SPEAKER_00 Или, допустим, если бы у нас в шарпе все поля были бы object.
4859.24 4867.72 SPEAKER_00 Ну конечно, если бы поля все были бы object, мы бы всё в комментариях писали, что этот object, это на самом деле Unum, этот object – это data, а JSON – это та же самая фигня.
4867.72 4873.92 SPEAKER_00 Там всё это, грубо говоря, строки, там буквально 5 типов, и в основной части это, конечно, строки, да, их надо написать, надо документировать.
4873.92 4875.60 SPEAKER_00 По-моему, там три типа, что там?
4875.60 4877.16 SPEAKER_00 Там bool, int, ну number.
4877.16 4878.92 SPEAKER_01 Bool, number, string, всё.
4878.92 4882.08 SPEAKER_01 Ну не берём листы, всякие вот эти array, это уже понятно.
4882.08 4883.08 SPEAKER_01 Да-да, элемент примитива.
4883.08 4884.08 SPEAKER_01 Коллекция.
4884.08 4886.80 SPEAKER_01 Ну да-да, наверное, в три, если только примитивы брать.
4886.80 4888.72 SPEAKER_01 Так, что ещё у нас по контрактам?
4888.72 4899.68 SPEAKER_01 А, ну у Майкрософта, кстати, явно написано, используйте одинаковые JSON-схемы для put-ов, патчей, ну, респонсов, понятно, get-ов, респонсов, и для пост-ов, request-ов, респонсов.
4899.68 4921.48 SPEAKER_01 Максимально делайте похожую схему, чтобы в идеальном случае то, что вы получили из get-а, нужно было немножко поменять, что вы там хотите поменять, например, отправить в put, вот, или в post, если вы хотите, например, копию создать объекта, вот, вы получили какой-то объект из get-а, отдали в post, его же будет копия, вот, в таком духе.
4921.48 4927.40 SPEAKER_01 То есть, ну, понятно, не плодите там, там где ожидается одинаковый плюс-минус схемы, используйте реально одинаковую плюс-минус схему.
4927.40 4937.92 SPEAKER_01 Так, так, так, так, так, довольно много всяких разных рекомендаций про error-коды, что-то пешные, то есть там 400, 404, вот это все.
4937.92 4956.88 SPEAKER_01 Одна из интересных дискуссий, которую я много где слышал, это вопрос, вот смотри, берем мы url, делаем мы get, поэтому url-у по какому-то конкретному idшнику, ну, допустим, у нас есть там блог-пост, мы хотим получить блог-пост с idшником 999, а его никогда не было, что мы должны вернуть?
4956.88 4961.92 SPEAKER_00 Ну, опять же, здесь в зависимости от договоренности, никакого единого стандарта по рынку нет.
4961.92 4983.08 SPEAKER_01 Вот, и как раз, у Microsoft, кстати, у Zalando каких-то особых нет, по-моему, они там говорят, ну, 404 и все, что-то как бы not found, вот, а вот неизвестный автор из интернета говорит, нет, 404 not found подразумевает, что, короче, это вы прям в url-е ошиблись, вот это все, типа, нельзя возвращать not found в этом случае, используйте что-нибудь другое.
4983.08 5001.36 SPEAKER_01 Я, говорит, использую 410, вот, это, а что-то по код-ган, ну, что, типа, ресурс был, но больше нет, вот, чтобы как бы пользователь понимал, что он 404 в смысле он в url ошибся или в смысле он в url-у написал правильно все, но, ну, там не найдено ничего.
5001.36 5026.24 SPEAKER_00 Смотри, я насчет ошибок я очень часто сталкивался случаями, когда компании нагораживали нам очень большое число ошибок, ну, то есть у них там использовалось 20 или там 25, чуть ли не ячайник они могли когда-нибудь вернуть, ну, потому что сидят там какие-то большолобые бэкэндеры и начинают выдумывать для себя, вот здесь был конфликт, вот здесь я обновил, но конфликта не было, но он мог бы быть, поэтому я вот вернул вот такой вот нашел интересный код.
5026.24 5031.60 SPEAKER_00 В общем, здесь прежде всего нужно задумываться, а кто эти ошибки у вас будут читать, то есть кто ваши клиенты.
5031.60 5067.84 SPEAKER_00 И если у вас клиент действительно способен обрабатывать ваши 25 типов статус кодов, то, конечно, пуляйте, но в большинстве случаев ваши клиенты – это вот тупые какие-нибудь React HTTP клиенты, которые знают буквально там 5 кодов по пальцам, и вот 404 они поймут, я вам 100% гарантирую, а вот 410 нет, ну или каждый будет понимать по-своему, и вам придется ходить из команды в команду и договариваться, что у меня вот 410, поэтому в таком случае я бы здесь больше склонился к 404, потому что это стандартная вещь, ее понимают многие клиенты, ее понимают там кэши, логи, как стандартные мидлвари, которые там метрики отсылают и прочее-прочее-прочее.
5067.84 5073.48 SPEAKER_00 Здесь больше нужно идти к стандартизации и к пониманию клиентами, т.е. кто вас будет интерпретировать.
5073.48 5104.68 SPEAKER_01 Да, и, кстати, Zalando здесь во всем, что касается в этих error-кодах, у них прямо есть огромная большая табличка по каждому из этих error-кодов, ну в смысле табличка с error-кодами, и на каждой есть признак, а надо ли его вообще документировать в API, т.е. они говорят, что очень часто бывает такая ситуация, что вы видите там, не знаю, API-шку, в ней 10 методов, и на каждом методе написано, он может вернуть 200, он может вернуть 500, он может вернуть 400, он может вернуть 404, и везде написано одно и то же.
5104.68 5107.36 SPEAKER_01 Да-да, есть такие API-шки, да-да-да.
5107.36 5121.48 SPEAKER_01 У Zalando в рекомендациях написано, все well-known стандартные коды, которые возвращаются в известных обычных случаях, типа не надо документировать 500, все знают, что 500 может прийти от сервера, не надо вообще этого OpenAPI-спеку даже включать.
5121.48 5141.72 SPEAKER_00 Ну вот видишь, как программисты, они когда видят дублирование у себя в коде, у них почему-то мозг включается, что нужно вот это дублирование вынести метод, куда-нибудь обозначить, а когда они видят дублирование в тексте одного и того же, мозг у них очень медленно включается, что блин, ну нафига вы дублируете одно и то же, ну это же можно или в одном месте записать где-нибудь на общей странице документации, или еще где-то, ну не нужно это дублировать,
5141.72 5142.72 SPEAKER_01 конечно же.
5142.72 5143.72 SPEAKER_01 Ну да, да-да-да.
5143.72 5157.80 SPEAKER_01 Ну и еще один момент касательно контрактов, последний, который я хотел бы отметить, это что, опять же, мне кажется, в индустрии нет какого-то единого стандарта, как в проперти в JSON, вот ты к чему склоняешься, к CamelCase, к SnakeCase?
5157.80 5160.64 SPEAKER_01 Наверное, это два самых популярных, пожалуй, да, наверное?
5160.64 5166.64 SPEAKER_00 CamelCase и SnakeCase, через подчеркивание, либо с… Подожди, мы как нормальные C#-исты, мы должны склоняться к PascalCase, я считаю.
5166.64 5167.64 SPEAKER_00 В пропертях?
5167.64 5168.64 SPEAKER_00 Нет.
5168.64 5169.64 SPEAKER_00 Конечно.
5169.64 5170.64 SPEAKER_00 Да почему Camel?
5170.64 5171.64 SPEAKER_00 Давай Pascal.
5171.64 5174.76 SPEAKER_00 Ну у нас проперти называются в Pascal же, пусть и JSON-чики
5174.76 5175.76 SPEAKER_01 страдают.
5175.76 5192.24 SPEAKER_01 Ну проперти в Pascal, я согласен, ну не знаю, короче, традиционно я, конечно, больше CamelCase встречаю, но вот тут Microsoft говорит, короче, Майкрософт считает, что нужно обязательно CamelCase, ничего другого, Zalando считает, что обязательно SnakeCase, ничего другого, я так понимаю, что тут каждая компания, как договорится, лишь бы весь ваш API выглядел одинаково.
5192.24 5199.16 SPEAKER_00 Ну типа того, мне кажется, у нас CamelCase просто по дефолту включены, поэтому большинство API в C#, они именно CamelCase-овые.
5199.16 5217.96 SPEAKER_00 Тут и другой интересный вопрос есть, потому что на самом деле проперти в JSON не существует, в JSON все это дикшнери, и существует, это дикшнери-ключ на самом деле, а не проперти, и существует отдельная настройка в сериализаторе, типа проперти, окей, у вас будут вот такие, а что будет, если дикшнери вы передадите?
5217.96 5224.44 SPEAKER_00 Ведь, по сути, в JSON и проперти, и дикшнери будут приведены к JSON-дикшнери, потому что это все дикшнери, вот.
5224.44 5244.64 SPEAKER_00 И бывает такая ситуация, когда у вас проперти написаны в одном кейсе, а дикшнери, по сути, настройка стоит в другом кейсе, типа обычно даже ключи дикшнери стараются не менять, то есть они там, допустим, лежат в Pascal кейсе, а все остальное у вас там в Camel кейсе, вот, и сам JSON, соответственно, уже будет не соответствовать этому правилу, потому что на уровне JSON это одно и то же.
5244.64 5259.80 SPEAKER_00 То есть вот здесь довольно большая проблема встречается, вот здесь надо еще договориться, а просто так модифицировать ключи в дикшнере обычно бывает не очень хорошо, потому что некоторые API спроектированы так, что воспринимаются ключи в дикшнере именно case-sensitive, ну потому что это ключи, это не свойства.
5259.80 5265.48 SPEAKER_00 В общем, здесь тоже большой интересный вопрос, на который индустрия до сих пор, к сожалению, не договорилась.
5265.48 5269.12 SPEAKER_01 Ну я думаю, что на самом деле и не договорится, все равно слишком у нас много.
5269.12 5278.92 SPEAKER_00 Так и есть, вы поэтому договоритесь на уровне своей компании, т.е. у каждой компании должен быть по каждому вот такому спорному пункту свой гайдлайн, как так положено делать у вас.
5278.92 5289.72 SPEAKER_01 Пойдем дальше, секция под названием HTTP-глаголы и идемпотентность, они идут вместе, потому что довольно сильно связаны.
5289.72 5299.96 SPEAKER_01 Ну, во-первых, все, в общем-то, сходятся мысли, что в современном мире нужно обязательно предоставлять механизмы обеспечения идемпотентности.
5299.96 5329.64 SPEAKER_01 Напомню, что такое идемпотентность, у вас есть разные HTTP-глаголы, и некоторые вы можете достаточно безболезненно при правильном спроектированном API повторять, т.е. например, вы можете вызвать GET много раз и, в принципе, на состояние системы с той стороны это не повлияет, оттого что вы вызвали, вам могут вернуться, естественно, разные немножко данные, потому что, возможно, как-то объект живет, меняется, у него там меняются статусы, но в целом вы можете без болезненно повторять GET-реквесты, не боясь что-то респортить.
5329.64 5346.72 SPEAKER_01 Вы точно также можете безболезненно повторять DELETE-реквесты, а вот если вы повторите, например, POST, то это может привести к нехорошим последствиям, потому что POST по дефолту не идемпотентен, и сервер как бы аккуратно его выполнит и создаст еще один объект, например, если вы POST создаете
5346.72 5347.72 SPEAKER_00 объект.
5347.72 5351.64 SPEAKER_00 Ну, это стандартный вопрос на собеседовании, чем отличается PUT от POST.
5351.64 5352.64 SPEAKER_00 Да-да-да.
5352.64 5355.68 SPEAKER_00 Единственное отличие в том, что POST не идемпотентен, а PUT идемпотентен.
5355.68 5360.28 SPEAKER_01 Да, ну их всего два, короче, точно не идемпотентных, это PATCH и POST, соответственно.
5360.28 5361.28 SPEAKER_01 Вот.
5361.28 5365.36 SPEAKER_00 Ну, подожди-подожди, PATCH вполне идемпотентен.
5365.36 5366.36 SPEAKER_00 Почему?
5366.36 5370.84 SPEAKER_00 Ну, если ты в PATCH меняешь имя пользователя и ты поменял его 100 раз, то имя там будет одно и то же.
5370.84 5373.80 SPEAKER_00 Да, но если я в PATCH делаю EDD в коллекцию.
5373.80 5374.80 SPEAKER_00 В PATCH EDD?
5374.80 5376.36 SPEAKER_00 Да, там есть такой вариант.
5376.36 5379.36 SPEAKER_00 Ну да-да, потому что PATCH это, по сути, модификация.
5379.36 5383.28 SPEAKER_00 В модификации ты как можешь поле поменять, так и можешь добавить некий элемент, поэтому непредсказуемо.
5383.28 5386.56 SPEAKER_01 В PUT ты обязан коллекцию целиком передать, и поэтому он идемпотентен.
5386.56 5390.36 SPEAKER_01 А в PATCH можно кусочек, там есть EDD и remove, по-моему, даже там есть.
5390.36 5391.36 SPEAKER_01 Что-то мне казалось, что есть.
5391.36 5392.36 SPEAKER_01 Ну ладно.
5392.36 5394.88 SPEAKER_01 Ну ты же точно так же в PUT можешь коллекцию добавлять?
5394.88 5395.88 SPEAKER_01 В PATCH?
5395.88 5398.24 SPEAKER_01 Добавлять не могу в PUT, в PUT она целиком перезапишется.
5398.24 5401.76 SPEAKER_00 Опять же, бывают разные имплементации, кто как
5401.76 5402.76 SPEAKER_01 интерпретирует PUT.
5402.76 5406.88 SPEAKER_01 Ладно, да, хорошо, давай мы это, не будем углубляться в эту область.
5406.88 5414.96 SPEAKER_01 Короче, есть, в принципе, три таких способа, что ли, да, обеспечить эту самую демпотентность.
5414.96 5431.56 SPEAKER_01 Один вариант – это ключи демпотентности, т.е. вы вместе с POST просто посылаете заголовочки, отдельный еще ID-шник, там GUID, грубо говоря, и даже если… и сервер, соответственно, трекает, он будет знать, что операцию с таким GUID он уже выполнял.
5431.56 5433.88 SPEAKER_00 Смотри, здесь, наверное, стоит сказать, а в чем проблема-то?
5433.88 5436.96 SPEAKER_00 Ну допустим, у нас все урлы не демпотентны, и к чему это приводит?
5436.96 5464.56 SPEAKER_01 Ну проблема в том, что, например, если мы берем POST, да, традиционно он используется для создания сущности, вы попробовали вызвать метод, вам вернулся там тайм-аут, вы не знаете, вам вернулся тайм-аут, потому что ответ к вам не пришел, а сервер уже выполнил запрос, или ваш реквест не дошел, а даже если, например, не дошел ответ, сущность-то уже создана на сервере, сервер ее обработал, создал, получил какой-то ID-шник, но вы этот ID-шник не узнали.
5464.56 5469.04 SPEAKER_01 Вы, естественно, делаете retry, как положено в современном облаке.
5469.04 5484.60 SPEAKER_01 Допустим, второй retry проходит, но в итоге у вас созданы две сущности, но первая никуда ни к чему не привязана, потому что ее ID-шник потерян, или наоборот, она в каком-нибудь списке будет видеться, и вы, когда получите список сущностей, увидите, что, оказывается, вы создали две.
5484.60 5503.56 SPEAKER_01 А если бы был способ понять, что вот создание сущности вы повторяете, на самом деле, то тогда сервер мог бы сообразить, ага, он хочет создать сущность снова, но он же уже пробовал, я уже это обработал, можно не обрабатывать второй раз.
5503.56 5527.68 SPEAKER_01 Так вот, способов это сделать, два хороших, это либо вы передаете ключ ID-патентности, то есть некоторые просто искусственный идентификатор, грубо говоря, уникальный идентификатор запроса, который сервер помнит какое-то время у себя и знает, что если к нему повторно придутся таким идентификатором, то просто можно ничего не делать, а вернуть, соответственно, созданную уже там сущность.
5527.68 5556.00 SPEAKER_01 Либо же надо просто отдать, то есть нельзя делать никакой генерации, условно говоря, ID-шников на клиенте, то есть этим самым уникальным идентификатором будет являться нечто сгенеренное на клиенте, то есть в этом случае ID-шники генерятся на клиенте, в пост передаются они, вы точно так же трекайте, но вы знаете, что поскольку не вы генерите ID-шник, вы просто увидите, что объект с таким ID уже создан, ну как бы и просто скажите, ну окей, да, уже создан.
5556.00 5567.08 SPEAKER_00 Ну немножко учтите, что этот подход противоречит тому, что после этого вы уже не выбираете хранилище, если у вас ID-шники будут генерироваться на клиенте, уже клиент выбирает в каком хранилище и как вам хранить эти ID-шники.
5567.08 5568.08 SPEAKER_01 Да.
5568.08 5583.84 SPEAKER_01 И здесь на самом деле, а еще, кстати, есть такой интересный момент, а что делать, допустим, мы используем ключи демпотенности, вы делаете пост и говорите, что сервер понимает, что ага, такой пост я уже обрабатывал.
5583.84 5587.88 SPEAKER_01 На самом деле существует два способа обработать такую штуку.
5587.88 5601.00 SPEAKER_01 Способ один — вернуть специальный что-то по коду 409, это конфликт, и в принципе вы можете вместе с этим error-кодом вернуть прошлый ответ, да, ID-шник прошлого созданного, например, созданной сущности.
5601.00 5610.32 SPEAKER_01 Таким образом клиент поймет, что ну да, он уже созданный, вот конфликт вот с этой сущностью, ага, ну то есть как бы ее мы, этот ID мы и возьмем за создание.
5610.32 5620.32 SPEAKER_01 Либо вы можете сделать вид, что вы обрабатываете этот реквест как будто в первый раз и вернуть тот же самый респонс, который вы бы вернули, если бы первый реквест не затаймаутился.
5620.32 5633.44 SPEAKER_00 Я бы тут как раз предложил обратиться к правилу, а клиенту это надо, т.е. клиенту ваши различные результаты нужны, т.е. ему важно, конфликт это или не конфликт, и в большинстве случаев ему не важно, ему нужно получить обратную сущность.
5633.44 5645.76 SPEAKER_01 Да, но с другой стороны, нагрузка, ну т.е. как бы программировать сложнее второй вариант, когда нужно получить сущность, потому что вам нужно помнить не только тот факт, что вы этот вопрос обрабатывали, а собственно и полный ответ.
5645.76 5652.72 SPEAKER_00 Ну у тебя есть ключи на импотентности, да, ты по этому ключу на импотентность должен знать, какую сущность породила этот ключ на импотентность, ну какой ответ породил.
5652.72 5653.72 SPEAKER_00 Да-да-да, какой ответ.
5653.72 5661.20 SPEAKER_00 Тут еще один интересный вопрос, ни в какой ли спецификации не сказано, сколько нужно хранить ключи на импотентности, потому что… В спеках я этого нигде не видел.
5661.20 5666.02 SPEAKER_00 Ретрай может прийти через секунду, а может через неделю прийти, и что нам делать, не вечно же их хранить?
5666.02 5675.70 SPEAKER_01 В спеках я этого не видел, Золанда, кстати, говорит, что возвращайте заголовки, где будет сказано, сколько он живет у вас.
5675.70 5680.34 SPEAKER_00 Это хорошо, если твои заголовки кто-то прочитал, а если мы говорим, что у нас оборвалась связь, и клиент ретрает.
5680.34 5685.22 SPEAKER_01 Все правда, ну я так понимаю, что какой-то стандарт я не видел.
5685.22 5691.12 SPEAKER_00 То есть тут плохо, конечно, что наши ретрай-библиотеки никак не договорились с кэширующими импотентными серверами.
5691.12 5696.76 SPEAKER_00 Было бы неплохо, какой-нибудь стандартный таймаут, после которого чувак не ретрай, не надо.
5696.76 5698.12 SPEAKER_01 Ну да.
5698.12 5701.36 SPEAKER_01 Так, что у нас ещё интересного?
5701.36 5702.92 SPEAKER_01 А вот, про глаголы.
5702.92 5711.04 SPEAKER_01 У Майкрософта есть интересная рекомендация, я ей, я бы сказал, никогда не пользуюсь, но, в принципе, подход интересный.
5711.04 5713.52 SPEAKER_01 Ажура, я так понимаю, ей пользуется всё время.
5713.52 5720.18 SPEAKER_01 Для того, чтобы вы, для создания ресурсов используете только патч или пут.
5720.18 5721.18 SPEAKER_01 Пост использовать нельзя.
5721.18 5722.80 SPEAKER_01 А почему?
5722.80 5734.66 SPEAKER_01 Ну, потому что он типа, ну у них написано, что типа may use post, если вы сделали, короче, всю импотентность, вот это всё, короче, пост не надо.
5734.66 5735.66 SPEAKER_01 А патч...
5735.66 5737.46 SPEAKER_01 Ну то есть потому, что без импотентности он по-дефритному?
5737.46 5742.78 SPEAKER_01 Да, патч тоже же без импотентности, но у патча есть несколько вариаций.
5742.78 5754.74 SPEAKER_01 Вот там вот body, который вы передаёте, он может быть разных немножко форматов, и там есть специальный тип, называется то ли мерч патч, мерч патч, по-моему, это называется, короче.
5754.74 5761.46 SPEAKER_01 Вот он как раз не будет позволять добавлению коллекции вот этого всего, и за счёт чего он становится и демпатентным.
5761.46 5762.46 SPEAKER_00 Вот.
5762.46 5767.42 SPEAKER_00 Ты говоришь про какой-то стандартный имплементатор и накатыватель патчей, да?
5767.42 5768.42 SPEAKER_01 РФЦ 5789.
5768.42 5777.10 SPEAKER_00 Нет, хорошо, а есть ли у нас в дотнете какой-нибудь классик, который возьмёт тебе патчи, поэтому РФЦ его накатит без добавлений, без ничего вот этого?
5777.10 5781.30 SPEAKER_01 Наверняка есть библиотечка, не искал, честно говоря, я говорю, что я никогда так не пользовался.
5781.30 5788.62 SPEAKER_00 Ну вот сложно, рекомендовать такие вещи, когда у тебя нет простого способа вот это заиспользовать, а у нас в индустрии пока простого способа чуть ли не полно.
5788.62 5795.26 SPEAKER_01 Но с другой стороны, разажур, как бы на этом ажур написан, в частности на шарпе местами, должно быть что-то, наверняка.
5795.26 5800.78 SPEAKER_00 Ну наверное должно, но пока оно не станет как бы стандартом везде, рассчитывать на него довольно странно.
5800.78 5805.66 SPEAKER_01 В среднем, конечно, все создают через пост, ну иногда через пуд, такое встречал.
5805.66 5810.06 SPEAKER_01 Ну в общем-то всё по методам.
5810.06 5815.98 SPEAKER_00 Смотри, я как раз больше встречал, что люди предпочитают не использовать патч, как раз таки потому, что охрень знает, как его реализовать.
5815.98 5819.98 SPEAKER_01 Да он сложный, да, и со стороны фронта в том числе, то есть непонятно как.
5819.98 5829.22 SPEAKER_01 Особенно этот стандартный патч, который там с эдремувами, он там очень хитро собирается, этот джейсончик, мы один раз делали такое, нам не понравилось.
5829.22 5841.82 SPEAKER_01 Мерч патч, он попроще, но тоже непонятно, то есть может быть действительно пока еще не появилось удобных тулов, так скажем, библиотек и всего остального.
5841.82 5854.46 SPEAKER_01 Давай дальше, по заголовкам, ШТТП заголовка имеется в виду, каких-то интересных рекомендаций нет, все говорят ну используйте стандартные, что как бы, они стандартные, не используйте.
5854.46 5868.10 SPEAKER_01 А, ну единственное, рекомендации, сейчас в РФЦ уже написано, в РФЦ специальной, в котором написано не используйте префикс x для кастомных заголовков, в долгое время считалось, что нужно все ваши кастомные заголовки начинать с символа x, то есть x-дефис и что-нибудь.
5868.10 5870.74 SPEAKER_01 Вот, последняя рекомендация говорит не надо.
5870.74 5873.10 SPEAKER_01 А что, вместо него надо?
5873.10 5884.94 SPEAKER_01 Написано в РФЦ, я РФЦ почитал, там написано, просто придумайте имя, которое наверняка, про которое вы с достаточной уверенностью можете сказать, что оно не используется,
5884.94 5885.94 SPEAKER_00 точка.
5885.94 5889.62 SPEAKER_00 Ну обычно в такие вещи вставляют или имя продукта, или имя компании.
5889.62 5890.62 SPEAKER_00 Ну да, да.
5890.62 5896.06 SPEAKER_00 Для того, чтобы можно было сразу сказать, что вот этот заголовок, он наверняка относится к этому продукту, потому что заголовков много и так далее.
5896.06 5897.06 SPEAKER_00 Всё так.
5897.06 5899.06 SPEAKER_00 Ну это примерно уникальность тебе какую-то гарантирует.
5899.06 5907.14 SPEAKER_01 Да, там в РФЦ что-то такое написано, типа company name, там что-то такое, можно, но при этом у Майкрософта все их стандартные заголовки, они xms, что-то там, но видимо
5907.14 5908.14 SPEAKER_00 исторически.
5908.14 5912.58 SPEAKER_00 Да и, насколько я помню, у всех, и у Гуглова, и у Гитхаба, как бы у всех.
5912.58 5913.58 SPEAKER_01 Да.
5913.58 5919.94 SPEAKER_01 Ну и примерно осталось два раздела, это версионирование и тот самый пейджинг.
5919.94 5920.94 SPEAKER_01 Вот.
5920.94 5927.02 SPEAKER_01 Давай про пейджинг сначала немножко, рядом с контрактом пока это самое.
5927.02 5948.50 SPEAKER_01 Значит, про пейджинг сказано следующее, что Майкрософт говорит, бывает client-сайт и server-сайт, ну то есть client-сайт это offset-base, когда вам с клиента приходит, хочу там, не знаю, пятую страницу 20 сущностей, а server-сайт это когда вы запрашиваете список, вам сервер возвращает начало этого списка и ссылочка про то, что, а продолжение вот по этой ссылке.
5948.50 5949.50 SPEAKER_01 Вот.
5949.50 5956.20 SPEAKER_01 Соответственно клиент просто запрашивает, не зная, что там дальше, сколько там будет еще страниц, не страниц и так далее.
5956.20 5971.58 SPEAKER_01 Майкрософт говорит, что ну постарайтесь никогда не отдавать total в списках, независимо от как бы пейджинга, не надо считать total, если вам очень надо, сделайте отдельный query-опцию, что типа.
5971.58 5977.66 SPEAKER_00 Слушай, ну сложно не отдавать total, когда ты первый вид используешь, когда тебе перед клиентом нужно показать количество страниц.
5977.66 5982.26 SPEAKER_01 Это правда, но тем не менее старайтесь не отдавать
5982.26 5983.26 SPEAKER_00 total.
5983.26 5984.26 SPEAKER_01 Тем не менее не отдавать, да.
5984.26 5985.26 SPEAKER_01 Да.
5985.26 5987.50 SPEAKER_01 Ну типа там, напишите, что там 1, 2, 3 и многоточие.
5987.50 5989.66 SPEAKER_01 Так а если он 1?
5989.66 5990.66 SPEAKER_01 Вот.
5990.66 6009.90 SPEAKER_01 Ну правда, я согласен, да, что скорее всего, конечно, в таком случае вы будете, но рекомендация говорит, что старайтесь избежать total, ну отправьте какой-нибудь там has_next_true, знаешь как это в итераторах C#, has_next и move_next, все.
6009.90 6010.90 SPEAKER_00 Это cursor based по сути.
6010.90 6011.90 SPEAKER_00 Да.
6011.90 6023.38 SPEAKER_00 У этих двух способов есть плюсы и минусы, да, и один как раз таки из минусов того, что тебе в принципе всегда в первом случае приходится total отправлять, но зато во втором не нужно, это его плюс.
6023.38 6034.82 SPEAKER_01 Ну и во втором вы можете, да, чуть более стабильные может быть даже результаты возвращать, если вы, например, что-то там, ну хотя в первом тоже теоретически, но…
6034.82 6039.18 SPEAKER_00 Слушай, нам по идее, мне кажется, по версионированию вообще надо отдельную статейку сделать.
6039.18 6040.18 SPEAKER_00 Давай как-нибудь, да.
6040.18 6041.18 SPEAKER_00 Отдельную тему.
6041.18 6042.18 SPEAKER_00 Не по версионированию, это pagination.
6042.18 6054.22 SPEAKER_00 По пейджингу, да, да, потому что оба этих подхода, они прям стоят того, чтобы их обсудить, плюсы, минусы и так далее, потому что там второй у него больше плюсов, но его не всегда можно сделать, там для него есть определённые хаки, в общем, хорошая тема.
6054.22 6055.22 SPEAKER_00 Да.
6055.22 6056.22 SPEAKER_01 Можно как-нибудь отдельно её сделать.
6056.22 6058.94 SPEAKER_01 Давай посмотрим потом отдельно, ну и давай про версионирование.
6058.94 6073.90 SPEAKER_01 В общем, все сходятся из тех статей, которые я читал в основном, вот крупных компаний, все сходятся к тому, что типа не надо использовать версию в Урле, ну хотя Nuget использует, например, да, там API Nuget, там v1, v2, v3.
6073.90 6076.22 SPEAKER_00 Да мне кажется, тоже все большие все используют,
6076.22 6077.22 SPEAKER_01 именно в Урле.
6077.22 6078.82 SPEAKER_01 Ну вот Microsoft не использует.
6078.82 6079.82 SPEAKER_01 Уже молодец.
6079.82 6086.26 SPEAKER_01 Да, Zalando не использует, а у Zalando вообще прикольное это самое, у них просто рекомендация, should avoid
6086.26 6087.26 UNKNOWN versioning.
6087.26 6091.70 SPEAKER_01 Т.е. как бы вот типа не надо использовать вершинк вообще.
6091.70 6094.98 SPEAKER_01 Модифицируйте ваши API так, чтобы версионирование было не нужно.
6094.98 6121.54 SPEAKER_00 И они недалеки от правды, потому что знаешь, когда самого Роя Филдинга спросили, а где нужно версию указывать, в Урле там или в заголовке или ещё где-то, и он твитанул, что типа если вы указываете версию в своём API, то вы по сути посылаете в задницу весь в REST, потому что весь REST как раз создан именно для того, чтобы быть мегагибким и указывая версию, вы по сути ломаете весь его
6121.54 6122.54 SPEAKER_01 принцип.
6122.54 6123.54 SPEAKER_01 Да.
6123.54 6154.58 SPEAKER_01 Значит, надо сказать, что Microsoft, что Zalando, тут Microsoft неплохо сформулировали, у них написано следующее в принципах своих с точки зрения дизайна API, что заказчик никогда не, ну как бы код заказчика никогда не должен сломаться, если вы меняете сервис, а с другой стороны, а заказчик должен уметь переключиться на новую версию сервиса без необходимости менять код.
6154.58 6166.94 SPEAKER_01 Звучит очень абстрактно, но они, я так подозреваю, под этим понимают тот факт, что если вы как бы используете там v1, v2 в URL, то скорее всего им придется все-таки довольно сильно менять.
6166.94 6186.22 SPEAKER_01 Я не очень понимаю, почему их подход, они призывают использовать query параметр, почему он как-то чем-то отличается от версии в URL с точки зрения изменения кода клиента, и там либо это как-то параметризуется, либо это, не знаю, через конфиг задается, не знаю.
6186.22 6187.90 SPEAKER_01 Ну вот их парадигма такая.
6187.90 6200.42 SPEAKER_01 Думал, давайте это сделаем так, чтобы кастомер мог начать использовать новую версию сервиса без необходимости, соответственно, его менять, ну свой код.
6200.42 6211.90 SPEAKER_01 И Microsoft говорит, мы используем query параметр, причем у них для версии используется формат, не как все привыкли, там 1.0.1.1.1.2, у них для версии используется формат вида дата.
6211.90 6238.34 SPEAKER_01 Не знаю, пользуются какими-нибудь ажурскими API, но там действительно так, вы передаёте специальный query параметр, называется API version, причем если его не передать, то это ошибка, это 400, и вам в ответе пролетит, что API version обязательно, и туда нужно передать дату, ну из well-known, так скажем, списка дат, вида там год, месяц, день, они вот так вот идентифицируют свои версии, просто датой, когда она была зарелижена.
6238.34 6241.14 SPEAKER_01 Ну нормальный формат, почему бы и нет.
6241.14 6259.02 SPEAKER_01 Да, The London, наоборот, говорит, что типа в, ну он тоже говорит, что в url-е нельзя, ни в коем случае, если очень надо, то мы версионируем в media type, то есть не отдельным заголовком, а прямо в media type, то есть у вас там будет какой-нибудь там application.json, точка запятой, API version равно 5.
6259.02 6260.02 SPEAKER_01 Вот.
6260.02 6276.78 SPEAKER_00 Это как раз соответствует одному из принципов, что ресурсы, они должны быть стабильными, то есть от версии они не должны меняться, поскольку были юзеры, значит, они и остались юзерами, а то какой они версии, грубо говоря, или в каком формате, это всё определяется другими атрибутами, это не определяется этим адресом ресурса.
6276.78 6285.30 SPEAKER_01 Да, именно так, но я вот не знаю, мне кажется, что подавляющее большинство народу версионируют именно url-ами.
6285.30 6288.70 SPEAKER_01 Я могу ошибаться, но мне кажется, что это подавляющее большинство опишек, которые я встречаю.
6288.70 6298.62 SPEAKER_00 Я бы, по моему опыту, сказал, что в разноброс, где-то по поровну, и url-ами, и query-ами, и header-ами, и вообще не версионируют.
6298.62 6309.22 SPEAKER_00 Кстати, если бы мы пользовались hypermedia, то там бы все url-ы пользовались бы динамически, и таким образом люди делают так, что сервер сам решает, на какой url тебя послать.
6309.22 6313.42 SPEAKER_00 И клиент, как бы не зная url-а, он ходит по тому, куда его пошлют.
6313.42 6315.74 SPEAKER_00 И вот таким образом они делают прозрачное версионирование.
6315.74 6320.98 SPEAKER_00 Более того, они делают его постепенным, потому что для половины клиентов отдаётся один url, а для половины другой.
6320.98 6321.98 SPEAKER_00 В зависимости от чего-то.
6321.98 6322.98 SPEAKER_01 Да.
6322.98 6328.90 SPEAKER_01 Ну и последний момент касательно версионирования, я не знал, кстати, что такое существует.
6328.90 6332.14 SPEAKER_01 Короче, у нас теперь есть 2 rfc на 2 новых заголовка в респонсах.
6332.14 6335.02 SPEAKER_01 Один называется deprecation, второй называется sunset.
6335.02 6337.02 SPEAKER_01 Прям вот так вот они и называются.
6337.02 6338.02 SPEAKER_01 И они должны вызывать.
6338.02 6370.22 SPEAKER_01 То есть, если вы планируете, как владелец API, какие-то методы убирать, там, obsolетить или ещё что-то, этого, конечно, делать не надо, но иногда приходится, то сначала вы должны навесить header deprecation, где будет написана дата, когда он планируется к deprecation, а как только наступила эта дата, вы должны повесить header sunset, насколько я помню, в котором будет написана дата, согласованная, конечно, с потребителями и достаточно далёкая в будущем, после которой этот метод может быть отключен.
6370.22 6375.46 SPEAKER_00 Ну, то есть, одного не хватило, ты будешь, да, предупреждаю второй раз называть.
6375.46 6377.98 SPEAKER_00 Ну, типа warning error, да, типа такого.
6377.98 6378.98 SPEAKER_01 Вот.
6378.98 6379.98 SPEAKER_01 Ну, как-то так.
6379.98 6385.10 SPEAKER_01 То есть, я не видел, что такие хедеры появились и как бы да, rfc-шка даже есть на них новая.
6385.10 6387.06 SPEAKER_01 Ну прикольно, я тоже не встречал ещё.
6387.06 6388.06 SPEAKER_01 Вот.
6388.06 6389.42 SPEAKER_01 Ну и в реальной жизни я их пока не встречал.
6389.42 6392.94 SPEAKER_01 Но вот в Zalando уже прям, уже добавлены.
6392.94 6394.42 SPEAKER_01 Ну вот примерно такие дела.
6394.42 6396.90 SPEAKER_00 То есть, оно не версионирует, но деприкетит, да?
6396.90 6399.90 SPEAKER_01 Ну да, деприкетить можно, ничего, мы версии не меняем.
6399.90 6400.90 SPEAKER_01 А версионировать не надо?
6400.90 6401.90 SPEAKER_01 А версионировать не надо?
6401.90 6406.94 SPEAKER_01 Не, у них, кстати, написано, что один из самых хороших способов – это типа добавьте просто отдельный метод.
6406.94 6407.94 SPEAKER_01 Ну, отдельный.
6407.94 6410.10 SPEAKER_00 Ну, тогда, но просто деприкет этого не подразумевает.
6410.10 6411.10 SPEAKER_00 Ну да.
6411.10 6413.02 SPEAKER_00 То есть, по сути, деприкет – это и есть версионирование.
6413.02 6414.02 SPEAKER_00 Да.
6414.02 6417.86 SPEAKER_00 Как только ты деприкетишь старый метод, это значит, что у тебя там скоро поменяется мажор, грубо говоря.
6417.86 6418.86 SPEAKER_00 Скоро breaking changes будет.
6418.86 6419.86 SPEAKER_00 Это и есть версионирование.
6419.86 6422.00 SPEAKER_01 Ну, такое, незаметное для пользователя.
6422.00 6427.86 SPEAKER_01 Если кто-то не пользуется этим методом, ему не нужно переключаться на V2 или еще на что-нибудь ради новых фич других методов.
6427.86 6428.86 SPEAKER_01 Ладно.
6428.86 6431.86 SPEAKER_01 Ну как, на сегодня покрыли?
6431.86 6434.70 SPEAKER_01 Да, я думаю, что на сегодня это самое.
6434.70 6441.18 SPEAKER_01 Больше длинных статей мы брать, наверное, не будем, давай еще пробежимся кратенько о разном у нас чуть-чуть тут есть.
6441.18 6442.18 SPEAKER_01 Давай.
6442.18 6443.18 SPEAKER_01 Всяких разных.
6443.18 6444.86 SPEAKER_01 Я попробую не очень задерживаться.
6444.86 6471.10 SPEAKER_01 Несмотря на то, что у нас нету новостей от Microsoft в виде прям больших статей, которые было бы прикольно обсудить, там, превью или еще что-нибудь в таком духе, у нас есть, периодически возникают всякие разные штуки про, из GitHub у Microsoft, один из таких кейсов — это заведенный тикет в ISP.NET Core-овском репозитории под названием Eventing Framework в девятом дотнете.
6471.10 6474.62 SPEAKER_01 Вот если бы ты услышал Eventing Framework, что тебе приходит в голову?
6474.62 6484.62 SPEAKER_00 Тем более в девятом дотнете, но я думаю, сейчас прям такую выпустят мега-фреймворк, который будет все подряд консумить, все позит-хендлить, обрабатывать, и комплекс event-процессинг и все такое.
6484.62 6487.82 SPEAKER_01 Вот, и недалеко от истины примерно так же подумал весь интернет.
6487.82 6500.26 SPEAKER_01 В итоге в GitHub issue сейчас, вот на момент, когда я смотрел, не сейчас, это было несколько дней назад, 120 комментов уже, и это не технический комментарий, это очередное обсуждение open source versus Microsoft.
6500.26 6508.50 SPEAKER_01 Короче, типа вот, там половина народу, как обычно, типа вот, вы сейчас делаете свой убер-фреймворк, как ты сказал, да?
6508.50 6516.26 SPEAKER_01 И тем самым, короче, всякие вот наши, значит, open source-ные подели будут больше не нужны, и все начнут пользоваться вами, и вообще, что вы делаете?
6516.26 6527.38 SPEAKER_01 С другой стороны, народ говорит, что типа, наконец-таки Microsoft что-то, ну как с логгингом, короче, да, вот этот DI, как бы, контракт есть, да, дальше логгеры, пожалуйста, сериалок никто не убивал, бери да пользуйся.
6527.38 6536.10 SPEAKER_00 Да так же точно, как и с Aspire, да, все 10 лет пытались что-то нагромоздить на коленке, у них ничего не случилось, а тут Microsoft выкатил кусок, как бы, недоделанного чего-то, и все счастливы.
6536.10 6595.86 SPEAKER_01 Короче, в среднем интернет считал, что будет убер-мега-пупер-штука, но потом пришел Дэвид Фаулер, по-моему, Фаулер, и сказал, ну вообще-то, вообще-то, мы собирались сфокусироваться на очень маленьком подножестве event-хендлинга, а именно, что происходит, то есть, как удобно консумить ивенты из вот этих всяких, там, сервис-басов и прочего в контексте Azure-фанкшенов и Azure-веб-джобов, и сделать вот эту вот модель того, как консумить ивенты, похожую на minimal API, все, вот, то есть, типа, мы просто хотим сделать такой простой контракт поверх, как бы, поверх, скажем так, идей, которые, можете посмотреть, сайтик такой есть cloudevents.io, вот, там есть некоторое описание, попытка стандартизации, да, они говорят, что, ну, мы сделаем это, по сути, очень похоже на minimal API, там тоже будут middlewires для выработки ивентов, ну, такой, типа, не знаю, на медиатор, может, похоже будет, черт знает, фильтры и все.
6595.86 6600.94 SPEAKER_00 А что было не назвать minimal-events какой-нибудь, они не вводили в людей воплосы, нет, фреймворки там.
6600.94 6607.38 SPEAKER_01 Вот, короче, поглядим, что будет, 120 комментов не предел, ну, посмотрим, во что это выльется.
6607.38 6616.98 SPEAKER_01 Дальше, в C#-овом репозитории нашлась штука под названием C# log statement pattern, причем она уже чуть ли не там реализована, и вот-вот скоро будет.
6616.98 6649.54 SPEAKER_01 Штука следующая, вы сейчас можете внутри использовать любой тип, любой instance, точнее, любого типа внутри конструкции log, да, есть ключевое слово log, вы передаете, значит, в круглый скобочек какой-то instance, дальше в фигурных скобочках что-то пишете, тело, и, соответственно, через monitor-enter, monitor-exit, да, происходит блокировка на этом объекте, и пока какой-то кусочек, один поток выполняется внутри этого лога, другие потоки не будут выполняться.
6649.54 6685.02 SPEAKER_01 Скорее всего, в 9-ом дотнете появится специальный тип system.trading.log, который будет, можно использовать внутри лога, ходят слухи, что в каком-нибудь 10-ом дотнете, грубо говоря, в 11-ом, ну, короче, через несколько лет, когда все это аккуратно задеприкейтит, внутри лог можно будет использовать только этот специальный тип, но пока как бы просто добавят новый тип, и если бы его просто добавили, то никакая как бы хитрая логика внутри этого типа, они, видимо, хотят какую-то хитрую логику сделать в блокировок, я даже потом могу как-нибудь отдельно рассказать, зачем эта идея движется.
6685.02 6725.02 SPEAKER_01 Короче, если сделать его просто добавить, даже какую-то хитрую логику внутри не написал, ключевое слово log, внутренней логики типа не работает никак, поэтому теперь у нас будет новый маркерный интерфейс, называется ilogpattern, и если этот интерфейс реализован, в нём нет методов, но в нём должен быть метод под названием enterLogScope, который возвращает специальный ref struct, у которого есть dispose, и тогда, если тип, который вы передали в ключевое слово log, в конструкцию log, резвит этот ilogpattern, то вместо monitorEnter будет вызван вот этот enterLogScope метод.
6725.02 6730.06 SPEAKER_00 Ну, это богатая идея, можно свои monitorLogs иметь, значит, это более другое.
6730.06 6731.06 SPEAKER_01 Да-да-да.
6731.06 6732.06 SPEAKER_00 Можно будет касаться.
6732.06 6737.50 SPEAKER_00 Название только дурацкое, то есть это как disposable для ютинга, у нас теперь будет для лога тоже такой интерфейс.
6737.50 6738.50 SPEAKER_01 Типа того.
6738.50 6740.34 SPEAKER_01 Да-да-да, вот ровно оно, по сути.
6740.34 6746.38 SPEAKER_01 Только в dispose понятно, что там только один выходной метод есть, а здесь будет два, на вход и на выход.
6746.38 6750.82 SPEAKER_01 Посмотрим, к чему приведёт, на самом деле, да, вся эта история делается ровно для одного.
6750.82 6767.70 SPEAKER_01 Если сделать вот такой специальный log-тип, который будет, собственно, реализовать некоторую логику логов, а в каком-то дунете запретить использование внутри конструкции лог любых типов, кроме этого типа, то знаешь, что можно сделать?
6767.70 6772.18 SPEAKER_00 Узнать, прооптимизировать абсолютно все объекты, которые хранят этот дурацкий флажочек у себя в ядерах.
6772.18 6778.58 SPEAKER_01 Именно, мало того, что флажочек они хранят не только флажочек, там получится выкинуть, короче, из заголовка объекта кучу всего.
6778.58 6787.26 SPEAKER_00 Ну вот у меня прям с первых версий C# сразу был такой ступор, нафига они задумали все объекты лочить, почему нельзя было сделать отдельный класс?
6787.26 6790.58 SPEAKER_00 Потому что никто никогда не хочет лочить просто абсолютно всё.
6790.58 6794.94 SPEAKER_00 Все делают свой какой-нибудь классик по бестпрактисам всем, и только этот классик лочат.
6794.94 6797.98 SPEAKER_01 Скорее всего, наследие Java, потому что синхронайст и вот это всё.
6797.98 6800.98 SPEAKER_00 Там тоже можно, но это… Во всём виноваты эти личаисты.
6800.98 6819.14 SPEAKER_01 Ну, короче, смысл в том, что, да, глобальная такая идея – это пока не цель, это пока идея, а можно ли у объекта выкинуть вот этот заголовок, где хранится лог, где хранится ещё хэшкод, кстати, иногда, а иногда лог, а иногда хэшкод, в зависимости от того, использовали вы объект в лог или не использовали.
6819.14 6827.86 SPEAKER_01 Вот, там ещё хранится пачка некоторых битовых флагов, короче, там есть идеи, как его можно порезать, чтобы мы поменьше кушали в памяти.
6827.86 6828.86 SPEAKER_01 Вот.
6828.86 6831.90 SPEAKER_01 Последим, посмотрим, к чему это всё приведёт.
6831.90 6832.90 SPEAKER_01 Сериолог трейсинг.
6832.90 6852.78 SPEAKER_01 Мы в прошлый раз как раз рассказывали про СЕК новый, который позволяет, по-моему, что он там, OTLP, да, open telemetry провайдерам теперь быть, всё это в себя собирать, и мы там упоминали, что вот есть библиотечка сериолог трейсинг, удобный, client-side, все дела, вышла статья, в которой прямо описано, как ей пользоваться, что она даёт, так что посмотрите.
6852.78 6861.58 SPEAKER_00 Ну, не просто статья, а статья Никаса Блумхарта, как раз автора СЕКа и сериолога, и всех вместе взятых, у него классный блог, если ещё не подписаны, то тоже рекомендуем.
6861.58 6862.58 SPEAKER_01 Да.
6862.58 6875.14 SPEAKER_01 В .NET 9 продолжается работа над генерацией, удобной генерацией ИЛИ кода, я напоминаю, что когда мы получили .NET Core, у нас был, отрезана, на самом деле, возможность кода генерации некоторая, сейчас вот потихонечку это всё возвращается.
6875.14 6880.66 SPEAKER_01 Короче, в .NET 9 должен полностью AssemblyBuilder.save уже нормально работать со всеми нужными приседаниями.
6880.66 6901.70 SPEAKER_01 В .NET 9 уже заимплементили три новых link_you метода, мало ли вам не хватало, это count_by и aggregate_by, то есть вы можете просто, ну, count - это просто считал элементы коллекции, можно сказать count_by и передать делегатик, по какому полю считать, собственно, эти самые, или агрегировать сущности.
6901.70 6917.98 SPEAKER_01 И есть ещё теперь новый метод index, раньше, если вы хотели итерировать коллекцию так, чтобы вам возвращался и сущность, и её индекс в этой коллекции, нужно было писать замечательную конструкцию там, select item_index и вернуть tuple, соответственно, из item_index, теперь для этого у нас есть отдельный метод index.
6917.98 6942.58 SPEAKER_01 И последнее, что у нас есть из краткого, это то, что mstest до сих пор жив, и Microsoft выпустил mstestrunner, это, короче, штука, которая позволяет вам теперь собрать ваш проект с тестами, напоминаю, мстестовый проект, раньше, как и на самом деле во многих других тестовых фреймворках, это .dll, и вам нужен какой-то специальный раннер, который её будет запускать.
6942.58 6948.62 SPEAKER_01 В XUnity, по-моему, сейчас в последнем вроде как они собрались сделать .exe, или даже сделали уже, что XUnity
6948.62 6949.62 SPEAKER_00 генерирует .exe.
6949.62 6953.46 SPEAKER_00 Ну, при альфе, который у них есть, да, тоже сделали.
6953.46 6954.46 SPEAKER_01 Вот.
6954.46 6983.54 SPEAKER_01 У mstest теперь есть следующее, что вы можете взять в вашем тест-продже, добавить, ну, get_packet, специально называется mstest.adapter, тест-адаптер, поставить опцию enable mstestrunner, и в output type вместо .dll написать .exe, после чего у вас берётся executable, который, во-первых, не требует никаких там продуктных тестов, visual studio, mstestconsole, вообще никаких других раннеров он не требует, он полностью самодостаточен, то есть его можно отлаживать, его можно делать чего угодно.
6983.54 6994.02 SPEAKER_01 Вы можете таким образом, как ни странно, собрать какой-нибудь там кроссплатформенный тест, в смысле на винде собрать тест, который юнит-тестом запустится на линуксе, ну, например.
6994.02 6995.02 SPEAKER_01 Вот.
6995.02 6998.34 SPEAKER_01 И вы можете его отлаживать, как обычное приложение, всё такое.
6998.34 7013.86 SPEAKER_01 И при этом это всё ещё работает быстрее, то есть они меряли, там, на некоторых тестах, там, скорость увеличивается раза в три, за счёт того, что нет вот этого межпроцессного взаимодействия между хостом, который контролирует раны вашего теста, и тем процессом, который загружает ваши сборки с тестами.
7013.86 7014.86 SPEAKER_00 Примерно так.
7014.86 7019.26 SPEAKER_00 Ну, отлично, в принципе, смотри, сколько нововведений оказывается.
7019.26 7020.26 SPEAKER_00 А мы зря Microsoft ругали.
7020.26 7021.26 SPEAKER_00 Что они делают?
7021.26 7029.26 SPEAKER_01 Да, что-то делают, потихонечку какие-то вмещения выходят, мы просто всё ждём какого-нибудь превью уже нормального, там наверняка будет что-нибудь интересное и масштабное и мега суперкрутое для девятки.
7029.26 7030.26 SPEAKER_01 Но посмотрим.
7030.26 7038.34 SPEAKER_00 Да, хорошо, подождём, и как только будет, мы вам обязательно об этом расскажем, поэтому никуда не уходите, подписывайтесь и всех остальных тоже зовите подписываться.
7038.34 7039.90 SPEAKER_00 Давай, на сегодня, наверное, хватит нам.
7039.90 7047.22 SPEAKER_01 Да, на сегодня нам хватит, мы посмотрели на Andrew Locke и вспомнили, что такое дефолтные методы интерфейсов или реализации.
7047.22 7062.18 SPEAKER_01 Мы узнали Aspire Roadmap, посмотрели на байнари-форматер и чем его теперь заменять, подробнейшим образом обсудили различные аспекты того, как можно дизайнить REST API, ну и много мелочей от Microsoft в основном, но не только от Microsoft, тоже
7062.18 7063.18 SPEAKER_00 было.
7063.18 7068.86 SPEAKER_00 Всем спасибо за прослушивание, заходите ещё и увидимся.
7068.86 7069.86 SPEAKER_00 До новых встреч, пока.
7069.86 7070.46 SPEAKER_00 Пока.
7070.46 7085.50 SPEAKER_00 [Музыка]
