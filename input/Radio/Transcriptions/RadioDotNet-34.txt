0.00 9.04 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет номер 34.
9.04 12.12 "Анатолий Кулаков" И приветствует вас сегодня Анатолий Кулаков.
12.12 13.12 "Игорь Лабутин" И Игорь Лабутин.
13.12 14.12 "Анатолий Кулаков" Всем привет.
14.12 22.48 "Анатолий Кулаков" В самом начале большое спасибо всем патронам, которые нас поддерживают, в частности, Александр, Сергей, Владислав и также всем остальным.
22.48 24.28 "Анатолий Кулаков" Большое спасибо за помощь.
24.28 34.12 "Анатолий Кулаков" Если вы хотите присоединиться к этой группе великих, благодарных людей, заходите на наши сайты на Patreon и Boosty и поддерживайте наш подкаст.
34.12 36.36 "Анатолий Кулаков" Ну что ж, давай начнем.
36.36 42.28 "Анатолий Кулаков" Я так понимаю, что Microsoft снова в деле и перед релизом не собирается расслабляться.
42.28 45.48 "Анатолий Кулаков" Выпустил шикарный большой интересный Preview 7.
45.48 49.64 "Игорь Лабутин" Да, похоже, что это последний Preview 7 перед релиз кандидата.
49.64 55.76 "Игорь Лабутин" По крайней мере, много где они упоминают, что какие-то вещи не вошли в Preview 7, но войдут в Rc1.
55.76 58.00 "Игорь Лабутин" Ну, поглядим, как пойдет.
58.00 60.96 "Игорь Лабутин" А пока посмотрим, что вошло в 7 Preview.
60.96 67.68 "Игорь Лабутин" Начнем, как обычно, с основного дотнета и потом перейдем к фреймворкам на основе него.
67.68 75.92 "Игорь Лабутин" Для начала, вы, наверное, если вы следите за твиттером, вы много видели всяких твитов от майкрософтовцев на предмет minimal APIs.
75.92 82.08 "Игорь Лабутин" И вот теперь это дело довольно сильно завезли в дотнет.
82.08 92.40 "Игорь Лабутин" И если вы теперь будете создавать новый проект на основе C#, то вы получите огромное количество всех тех вещей, которые мы уже обсуждали и не раз.
92.40 105.76 "Игорь Лабутин" Вы получите Top-Level Statements, вы получите Global Using Directives, вы получите File Scope Namespaces, вы получите Target Type New, Nullable Reference Types, включенные по умолчанию.
105.76 122.84 "Игорь Лабутин" И в результате всех этих изменений, если вы создадите стандартную, допустим, новую консольку, консольное нововведение, то вам создастся, конечно же, csproj.file, а также создастся file.program.cs, в котором будет одна-единственная строчка - console.writeline.hello world.
122.84 123.84 "Игорь Лабутин" И все.
123.84 128.24 "Игорь Лабутин" Никаких мейнов, никаких using system, вообще ничего этого не будет, просто console.writeline.
128.24 152.36 "Игорь Лабутин" И это с одной стороны хорошо, с другой стороны, такие штуки, они вызвали, скажем так, неоднозначную реакцию на это нововведение, потому что многие считают, что это все прекрасно в качестве такого нормального нового учебного, возможно, проекта, и для каких-нибудь тестов или быстрых проверок ваших гипотез.
152.36 159.52 "Игорь Лабутин" Но если вы начинаете новый какой-то большой проект, то вообще было бы неплохо видеть и классы, и вот это все, а по дефолту это все будет скрыто.
159.52 164.08 "Игорь Лабутин" В общем, реакции сообщества пока неоднозначны, но посмотрим, к чему все это приведет.
164.08 175.68 "Анатолий Кулаков" Слушай, я знаю хорошее решение, которое может помирить всех, это очередной quick fix у ReSharper, типа развернуть в нормальные полноценные классы и убрать все лишнее максимально и наглядно.
175.68 176.68 "Игорь Лабутин" Да, возможно.
176.68 235.00 "Игорь Лабутин" Консольный темплейтами не ограничилось, также поменялись ASP.NET, Web и MVC темплейты, соответственно, там используется во многом minimal APIs, то есть все то, что мы тоже обсуждали, а в MVC темплейте пошли дальше, нет теперь файлика startup.cs, все запихнуто прямо в единый программ.cs, за счет minimal API получилось все это довольно компактно выглядящей конструкцией, но опять же получилось довольно много вещей, скрытых по умолчанию где-то там внутри, и если раньше было понятный файлик startup.cs, где был метод, понятный configure services, где нужно было настраивать ваш контейнер зависимости и configure, где настраивался pipeline, то сейчас это все сведено вместе в единый программ.cs, при том без мейна, без юзингов, без неймспейсов, без всего, выглядит это конечно прикольно, но вот я пока что-то не знаю, я наверное очень старый, но мне все-таки милее вот старый вариант.
235.00 291.76 "Игорь Лабутин" Дальше, в седьмом превью, если вам не нравятся global usings, это одна из самых таких, ну обсуждаемых и спорных фич, то есть хотим ли мы видеть глобальные юзинги или не хотим, потому что они могут что-то сломать, особенно если вы в ваших неймспейсах используете именно типов, которые одинаковы с системными неймспейсами, то в седьмом превью вы можете задизаблить эту фичу путем указания флага disable implicit namespace imports в вашем cs-project, поставить его в true, а в следующем превью-релизе, будет это превью-8 или будет это рц-1, утверждается, что фича будет поменена на обратную, то есть она будет выключена по умолчанию, нужно будет ее включить, а опции implicit usings, поставить ее в true, то есть по дефолту вы не будете получать global usings, вы их будете получать, если вы создаете абсолютно новый шаблон для старого кода, если вы его таргетите новое SDK, по дефолту эта опция будет выключена, чтобы ничего не сломать.
291.76 330.40 "Игорь Лабутин" Дальше, в библиотеках, в стандартной библиотеке появился новый reflection API, казалось бы, что там нового, но то, что, наверное, не знаю, насколько это будет часто использоваться, но тем не менее, вы теперь можете через reflection вытащить информацию о nullability, в принципе, она там была и так, потому что, по сути, это все размечено просто обычными атрибутами, и можно было получить список атрибутов метода, либо список атрибутов параметров метода, и узнать всю инфу, которую вы хотите, но все вот эти, null, if not null, и вот это сложное атрибутик, она должна была партиться, по сути, вами руками.
330.40 368.32 "Игорь Лабутин" Теперь есть специальный класс, он называется nullability info context, у него есть набор extension и просто мемберов методов, которые позволят вам более просто получить эту информацию в таком адекватном виде, из nullable или is not nullable, то есть просто набор пропертий, которые нормально, красиво сделаны, им передается какие-то объекты, которые вы получаете от reflection, то есть какие-то пропертии, как он называется, property info или field info, и он на основе этого возвращает вам нормальную информацию, так что если вам интересно как-то reflection разбирать nullability, используйте nullability info context.
368.32 380.76 "Анатолий Кулаков" Слушай, как можно красиво разобрать атрибут, типа null, if true и вот эти вот прочие вещи, он же тебе в reflection ничего такого красивого предоставить не сможет.
380.76 403.20 "Игорь Лабутин" Я видел, что там есть всякие свойства, боюсь честно врать, по памяти говорю, по-моему там есть свойства типа depends on что-то или как-то так, я согласен, что учитывая, что даже для понимания оно не всегда легко, то наверное пишка будет выглядеть не очень красиво, но это по крайней мере всяко лучше, чем просто атрибутики парсить.
403.20 407.56 "Анатолий Кулаков" Да, чем вспоминать атрибутики, сохранять их там где-то и вспоминать какие у них поля, лучше это будет.
407.56 410.44 "Анатолий Кулаков" Те же самые атрибутики, но хотя бы в одном контексте уже будет хорошо.
410.44 440.08 "Игорь Лабутин" Ну, как минимум, например, в атрибутиках, если ты помнишь, ты указываешь именно параметров в некотором случае и при этом, или по крайней мере они расставляются на разных параметрах, и возможно в случае с reflection тебе, например, передавая один там property, ну, field info или как он там правильно называется, я уже не помню, тип соответствующий параметру, тебе могут вернуть какой-нибудь другой объект из reflection namespace, описывающий, например, тот параметр, который от этого зависит.
440.08 445.04 "Анатолий Кулаков" Объекты, например, несложно, а вот описать связь правильную, что это, мне кажется, уже будет магия.
445.04 459.40 "Игорь Лабутин" Ну, в общем, они какую-то магию сделали, насколько она будет полезна, удобна и так далее, время покажет, потому что мы там, чуть-чуть дальше я сейчас буду говорить, есть фичи, которые в превью 7 исчезли, потому что они оказались неудобными.
459.40 461.08 "Игорь Лабутин" Но пока пошли дальше, что добавили.
461.08 478.68 "Игорь Лабутин" Если вы используете стандартный класс zipfile, это для, собственно, создания zip-архивов, то теперь же, если вы это делаете на Linux, ну или на любом Unix, то внутри zip будет также сохраняться инфа про permission и файлов, и при запаковке, и при распаковке.
478.68 484.04 "Игорь Лабутин" То есть, если вы запаковали что-нибудь executable, то оно при распаковке останется executable, ну и так далее.
484.04 489.12 "Игорь Лабутин" Так что, ну, только для Unix, для Windows не работает, там нет понять, файл permissions.
489.12 492.24 "Игорь Лабутин" Из интересного добавили native memory IP.
492.24 508.00 "Игорь Лабутин" Казалось бы, куда еще, у нас и так есть там огромное количество всяких спанов, memory, stack-a-logов и так далее, но теперь у вас есть полный практический аналог того, что вы знаете из C и C++, там malloc, free, realloc, calloc, вот это все.
508.00 515.44 "Игорь Лабутин" Все эти методы теперь доступны в классе, который живет в system-runtime-interop-services и называется native memory.
515.44 521.56 "Игорь Лабутин" То есть теперь вы можете написать native-memory.allocate, передать размер в байтах и получить обратный указатель.
521.56 524.00 "Анатолий Кулаков" А это зачем нужно?
524.00 525.00 "Анатолий Кулаков" Видимо для интеропа.
525.00 531.24 "Анатолий Кулаков" Подожди, но мы раньше как-то справлялись с этим или это просто систематизировали под одним именем, зачем это?
531.24 548.08 "Игорь Лабутин" Раньше мы справлялись с этим, ну какой стандартный способ был, ты говорил new byte array, потом его пинил через global handle, как там, gchandle.alloc, по-моему, это называлось тогда или как-то так, и получал в итоге intptr, который мог передавать дальше.
548.08 557.12 "Игорь Лабутин" Но по сути, то есть ты allocировал managed память, которая была запинена и это мешает garbage collector, как мы знаем, ну и так далее.
557.12 573.88 "Игорь Лабутин" Сейчас у тебя, я так понимаю, что там внутри живет либо virtual alloc, либо даже heap alloc, который напрямую просто allocated не managed память, которая никак не влияет на garbage collector, никак не занимает места, никак не пинится, и соответственно она ведет себя просто как обычная heap память, которую ты можешь отдать в unmanaged.
573.88 582.84 "Анатолий Кулаков" То есть это уже управление unmanaged памятью без garbage коллектора, это уже да, это уже интересно, это открывает нам интересные новые возможности.
582.84 592.96 "Игорь Лабутин" Ну это то, как я это пока воспринимаю, я, к сожалению, не нашел каких-то прям супер юзкейсов для этого пока, но посмотрим, может быть начнут появляться.
592.96 598.52 "Игорь Лабутин" Система Text.json немножко поменялся, они все еще допиливают всякие штуки там.
598.52 626.60 "Игорь Лабутин" Если вы когда-либо пользовались xml сериализацией, вы знаете, что можно реализовать хитрый интерфейс и получить в итоге методы, которые будут вызываться после десериализации и перед сериализацией, они позволяли вам, скажем так, вручную контролировать, что там происходит в xml, либо в случае с десериализацией, после того, как все десериализовано, выполнить какой-то кастомный код, например, посчитать значение каких-нибудь филдов на основе десериализованной информации.
626.60 649.80 "Игорь Лабутин" Соответственно появилось сейчас новых 4 интерфейса для JSON сериализации, они все называются iJSON и дальше с суффиксами onDeserialized, onDeserializing, onSerialized и соответственно onSerializing, они вызываются либо перед, либо непосредственно после завершения сериализации и вы можете каким-то образом контролировать, как ваш объект сериализуется в
649.80 666.52 "Анатолий Кулаков" JSON. Не, погоди, погоди, это же совсем не аутентично, интерфейс какой-то с методами, должен быть просто магический класс, там, shootSerialize, onValidate, вот чтобы ты просто назвал по сигнатуре, смачивалось по дактайпингу и он в рантайме вызвался, вот это вот как работал настоящий xml сериалайзер.
666.52 667.52 "Анатолий Кулаков" Где наша магия?
667.52 672.32 "Игорь Лабутин" Ну, нет, магии нет, все явно, вот прям явнее не бывает.
672.32 673.88 "Анатолий Кулаков" Хипстеры атакуют.
673.88 674.88 "Игорь Лабутин" Реализуй интерфейсы.
674.88 699.52 "Игорь Лабутин" Раньше, кстати, такое можно было сделать, вклиниться во всю эту очередность, ну в смысле действий сериализации и десериализации, нужно было писать кастомный конвертер, и плюс кастомный конвертер ты либо байдил на конкретный тип и тогда, например, для всех стрингов он срабатывал, либо его нужно было атрибутом на какое-то поле, по-моему, можно было записать как-то, но в общем было все сложно и не очевидно с интерфейсами.
699.52 713.24 "Игорь Лабутин" С одной стороны проще, с другой стороны это будет загрязнять ваши модельки, например, потому что если это у вас просто plain old, как там называется, plain old C# object, да, то так у вас появятся еще вот методы какие-то.
713.24 718.84 "Игорь Лабутин" Ну, правда, они связаны, типа такие, а-ля конструкторы для десериализации.
718.84 723.56 "Игорь Лабутин" В JSON есть еще одно нововведение, теперь вы можете контролировать порядок.
723.56 749.48 "Игорь Лабутин" То есть теперь можно разметить ваши проперти специальным атрибутом, называется JSON property order, туда передается чиселка, они, соответственно, сортируются в порядке от меньшего к большему, то есть от минус бесконечности к плюс бесконечности, и в результате, соответственно, порядок в получающемся JSON будет ровно тот, который вы задали в этих пропертях.
749.48 768.28 "Игорь Лабутин" По дефолту получается нолик, у всех у кого не задано получается нолик, то есть если вы зададите какое-нибудь отрицательное, то эти свойства будут гарантированно десериализованы первыми, дальше будут десериализованы все свойства без ордера, ну или с нулевым ордером в произвольном порядке, и потом дальше, соответственно, тексту с положительным ордером.
768.28 776.20 "Игорь Лабутин" То есть если вам важен порядок десериализации JSON, непонятно зачем, но вдруг, то берите новые превью, там это и
776.20 791.48 "Анатолий Кулаков" есть. Ну знаешь, JSON можно использовать, например, для написания каких-нибудь математических действий, где, в принципе, порядок исполнения математических действий очень важен, или там для запросов, когда запросы пишут, например, к Монге в виде JSON, там очень важно, что ты сначала сделаешь select или filter.
791.48 798.76 "Игорь Лабутин" Я согласен, но я вот как-то XML воспринимаю как формат, где порядок важен JSON, почему-то вообще не воспринимаю.
798.76 804.24 "Анатолий Кулаков" Это нормальное чувство, лучше вообще JSON не воспринимать как нормальный формат, может он скорее сдохнет
804.24 810.84 "Игорь Лабутин" тогда. Да непонятно, будем в XML, в ямле будем возвращать body и писать реквесты.
810.84 812.72 "Игорь Лабутин" Ну ладно, пошли дальше.
812.72 821.00 "Игорь Лабутин" JSON пока сдыхать не собирается, поэтому в System.json в его UTF-8 JSON Writer появился новый метод, называется writeRowValue.
821.00 835.52 "Игорь Лабутин" Если у вас есть какой-то кусочек текста, который уже является валидным JSON, или возможно не очень валидным, то вы теперь можете его прям вот записать в выходной поток через writeRowValue, и там есть опциональный аргумент вообще проверить валидность или нет.
835.52 841.84 "Игорь Лабутин" Если его передать в false, то он вообще даже ничего проверять не будет, поверит вам на слово и запишет его просто в выходной поток.
841.84 856.68 "Игорь Лабутин" Никто не гарантирует, что получится в итоге валидный JSON, но если у вас есть какой-то код, какая-то сложная логика, где вы генерите какие-то допустим подобъекты, их сериализованное представление руками, то вот используйте теперь writeRowValue и будете писать JSON напрямую.
856.68 879.92 "Игорь Лабутин" Дальше, у JSON Serializer появилась новая пачка методов, теперь можно их вызывать на стримах, причем это методы синхронные, то есть никаких await, просто JSON Serializer.deserialize, тип класса, который вы десериализуете, и передаете memory stream, например.
879.92 882.60 "Игорь Лабутин" Все будет синхронно, без всяких async await.
882.60 886.88 "Анатолий Кулаков" Слушай, стрим же поддерживает асинхронные read и write, почему синхронно?
886.88 899.88 "Игорь Лабутин" Они, я так понимаю, это сделали конкретно для поддержки memory stream, то есть довольно часто у тебя каким-то образом получается либо byte array, либо чего-то другое, лежащее в памяти, вот оно уже точно в памяти, там async вообще никаким образом не нужен.
899.88 909.24 "Игорь Лабутин" И в этом случае странно тратить ресурсы на async, который создаст там стоит машину и так далее, проще это сделать синхронно.
909.24 917.24 "Анатолий Кулаков" Они же наверняка в интерфейс принимают iStream, а не memory stream, то есть они не знают, какой там стрим передадут, может network stream передадут.
917.24 922.00 "Игорь Лабутин" Это, наверное, правда, хотя я не поручусь за это.
922.00 929.60 "Анатолий Кулаков" Ну, мне кажется, нигде в библиотеках не видел, где принимается memory stream вместо абстракции iStream, поэтому вряд ли они пойдут.
929.60 932.40 "Игорь Лабутин" Ну, скорее всего, конечно, да.
932.40 937.32 "Игорь Лабутин" Посмотрим только ли это к memory stream, или это будет работать на любых стримах и...
937.32 943.04 "Игорь Лабутин" Ну, скажем так, кажется, что иногда синхронные кейсы вполне ок.
943.04 956.64 "Игорь Лабутин" Например, если ты делаешь какую-нибудь там консольную тузу, которая что-то децерализует из файлов, ну, не нужен тебе там async по большому счету, она там все из файла децерализовала, из файл стрима, например, и что-нибудь с ним сделала.
956.64 960.20 "Игорь Лабутин" Я бы там писал вполне синхронно, почему нет.
960.20 984.16 "Игорь Лабутин" Дальше, последний момент про System.json, мы некоторое время назад, это было в превью 4, обсуждали, что для System.json появилась, короче, такая штука, как сериализация в, ну, в такие generic объекты, можно сказать, точнее, в универсальные объекты, типа JSON node как аналог XML нода.
984.16 1000.92 "Игорь Лабутин" То есть, некоторый набор JSON нодов, которые друг другу вложены, если у вас нет, например, классов, соответствующих вашему JSON, вы можете его сериализовать как такой, децерализовать, как и сериализовать как универсальный JSON и работать с ними как с коллекцией sharp объектов.
1000.92 1004.00 "Игорь Лабутин" Просто property значение, property значение.
1004.00 1011.96 "Игорь Лабутин" Вот, и было логичным сделать поддержку динамиков вокруг этого, потому что, ну, в общем, как-то в динамик это запихнуть, все прикольно.
1011.96 1013.96 "Игорь Лабутин" Как раз там key value, все такое.
1013.96 1017.96 "Игорь Лабутин" Так вот, это, короче, выпилили полностью, теперь динамик там теперь не поддержан.
1017.96 1025.88 "Анатолий Кулаков" Опять же, можно, наверное, сравнить этот подход с reflection, когда вы точно также имеете property info и можете с помощью этого свойства считывать value.
1025.88 1028.24 "Анатолий Кулаков" Вот такая же штука и для notes.
1028.24 1040.76 "Анатолий Кулаков" И точно также для reflection есть специальные третисторонние библиотеки, которые помогают с помощью динамика вам исследовать объект, считывать вот эти property info, считывать values.
1040.76 1046.04 "Анатолий Кулаков" Но это все-таки левый про пакет, это не стандартная поставка Microsoft, наверное.
1046.04 1054.08 "Анатолий Кулаков" Вот для единообразия здесь они тоже решили сдать строго типизированную оболочку, а если кому-то нужны динамики, то идите напишите сами.
1054.08 1061.72 "Игорь Лабутин" Ну да, они написали в анонсе, что это как-то выглядело не очень логично, не очень стройно и поэтому решили выпилить.
1061.72 1062.72 "Игорь Лабутин" Пошли дальше.
1062.72 1063.72 "Игорь Лабутин" System Diagnostics.
1063.72 1068.04 "Игорь Лабутин" Там есть изменения, теперь у нас появилась новая сущность, называется Propagator.
1068.04 1071.44 "Игорь Лабутин" В английском, скорее всего, в русском так и будут пропагаторы.
1071.44 1075.48 "Игорь Лабутин" Не знаю, не распространители же, как их еще назвать.
1075.48 1084.20 "Игорь Лабутин" Короче, теперь есть абстрактный класс, называется Distributed Context Propagator и задачи, которые решают, по сути, сводятся к следующему.
1084.20 1104.64 "Игорь Лабутин" ISP.NET и вообще вся эта машинерия, которая умеет работать с трейсингом, то есть каким-то образом ассоциируя реквесты и логические действия друг с другом, она вся основана на том, что информацию об этих логических действиях нужно как-то передать соседу в соседний микросервис, в соседний даже Thread, в соседнее что-нибудь.
1104.64 1128.40 "Игорь Лабутин" Вот внутри .NET процесса это все живет в рамках Activity, но если это нужно отдать дальше, допустим, в момент HTTP call, то единственная возможность это было сделать, это либо использовать встроенную штуку, а встроенную штуку просто туда добавить стандартные W3C хедеры, ну либо OpenTracing хедеры, там два варианта есть, либо выпишет что-то совсем кастомное.
1128.40 1170.24 "Игорь Лабутин" Вот, теперь есть стандартная штука, называется Distributed Context Propagator, она как раз-таки умеет работать с key-value парами, с test-string, и встраивается в этот pipeline, его можно подменять, то есть есть defaulting, который продолжит естественно работать с W3C заголовками, ingest-ить их там в HTTP client и так далее, но в принципе теперь вы можете зафигачить в DI свой собственный Context Propagator, и он будет работать в этом случае вместо стандартного, и вы можете, например, каким-то своим собственным способом видеть контексты в нужных вам местах.
1170.24 1210.52 "Игорь Лабутин" Я пока не очень понимаю всю механику работы этой штуки, надо будет посмотреть на реальные примеры, но Microsoft говорит, что это как раз клевый способ в вашем, допустим, какой-нибудь кастомной библиотеке с кастомным транспортом, например, вы пишете какую-нибудь свою хитрую очередь сообщений, вы можете в вашем клиенте заюзать, вы можете сказать framework, что когда идет вызов к вашей библиотеке, то вам нужно каким-то образом вот этот Context Propagator ваш, собственно, использовать, чтобы запихать эти результаты в ваш транспорт, не результаты, а state и контекст.
1210.52 1218.40 "Игорь Лабутин" Пока очень все туманно рассказываю, наверное, потому что ни сам не пробовал и не до конца понимаю, как это все дружит с dependency injection.
1218.40 1220.84 "Игорь Лабутин" Надо будет попробовать, тема мне нравится.
1220.84 1221.84 "Игорь Лабутин" Попробую потыкать.
1221.84 1226.48 "Игорь Лабутин" Так, в дотнете осталось совсем чуть-чуть, немножко упростили криптографию.
1226.48 1254.40 "Игорь Лабутин" Раньше для того, чтобы там, короче, заюзать какое-нибудь там, не знаю, симметрическое шифрование с ключиками, вам нужно было взять, например, byte array, в котором лежат ваши зашифрованные данные, обернуть его в memory stream, его обернуть в crypto stream, его уже вызвать, его передать в методы, соответственно, шифрования, получить в ответ тоже stream, его обернуть в memory stream, из него прочитать, собственно, байтики, расшифрованные.
1254.40 1261.08 "Игорь Лабутин" Теперь есть нормальный метод, который можно просто передать byte array, он вернет byte array и все будет хорошо.
1261.08 1263.96 "Игорь Лабутин" Так что удобно стало теперь.
1263.96 1280.92 "Игорь Лабутин" И последнее изменение это, мы тоже обсуждали, write xor execute поведение, то есть возможность защищать странички в памяти, чтобы они были либо для записи, либо для исполнения.
1280.92 1284.96 "Игорь Лабутин" Так вот, теперь это доступно для всех платформах и для всех архитектур.
1284.96 1300.24 "Игорь Лабутин" По дефолту это включено только, понятно, на Apple M1, но на всех остальных можно взять переменную под названием dotnet_enable_write_xor_execute, поставить ее в единичку и вы получите такое поведение на всех, везде, где вы эту переменную заюзали.
1300.24 1313.68 "Игорь Лабутин" Единственный минус это пока имеет некоторый эффект на том, как стартует ваше приложение, у вас примерно будет на 10% оно медленнее стартовать, но с этим они обещают поработать и в следующем релизе сделать все хорошо.
1313.68 1332.84 "Игорь Лабутин" Так что, если вам зачем-то нужна очень защищенная модель, ну по большому счету это дополнительная защита от всяких атак через переполнение буфера и так далее, потому что если вы что-то пишете в память, вы не сможете эту память исполнить, то наверное это интересный кейс для использования.
1332.84 1336.88 "Анатолий Кулаков" Ну еще это единственное условие запускаться нативно на M1 от Apple.
1336.88 1340.80 "Игорь Лабутин" Да, но на M1 оно включено по умолчанию, выключить его нельзя.
1340.80 1344.92 "Игорь Лабутин" И на M1, кстати, penalty по перформансу нет, потому что там это на уровне железа поддержано целиком.
1344.92 1348.28 "Игорь Лабутин" То есть на M1 оно вот так работает по тефолту.
1348.28 1349.28 "Игорь Лабутин" Вот, пошли дальше.
1349.28 1352.28 "Игорь Лабутин" Собственно, с dotnet все, теперь о spnet.
1352.28 1358.96 "Игорь Лабутин" В spnet я быстренько только пробегусь на самом деле по заголовкам без особых деталей, потому что очень много мелочей.
1358.96 1372.16 "Игорь Лабутин" Minimal APIs мы уже обсудили, мы их много раз обсуждали про то, что теперь можно писать там ваш application.mapget, указать строчку, endpoint, который вы хотите и lambda функцию, которая будет обслуживать этот endpoint.
1372.16 1379.84 "Игорь Лабутин" Не надо там ничего никуда кастить, никаким фанком, можно это все разметить атрибутами авторизации, можно вызвать метод расширения requireAuthorization.
1379.84 1385.20 "Игорь Лабутин" В общем, там довольно много они поработали над тем, чтобы это все выглядело очень минималистично.
1385.20 1387.92 "Игорь Лабутин" Для простых приложений вообще должно быть зашибись.
1387.92 1390.88 "Игорь Лабутин" Дальше есть ряд изменений в Blazor.
1390.88 1395.44 "Игорь Лабутин" Теперь можно для компонент передавать параметры через query строку.
1395.44 1405.84 "Игорь Лабутин" Использую attribute supplyParameterFromQuery, причем его нужно указывать дополнительно к обычному параметру, то есть нужно два атрибута указать на проперти.
1405.84 1427.56 "Игорь Лабутин" Дальше добавились всякие полезняшки типа там можно в истории браузера поменять url, а не добавить его в историю, то есть вы можете сказать navigateTo и указать url с флажком replace true, и тогда он в истории браузера заменит последние entry на новый.
1427.56 1430.04 "Игорь Лабутин" Ну и вы естественно туда перейдете.
1430.04 1438.24 "Игорь Лабутин" В компонентах добавилась штука под названием dynamicComponent.instance, то есть есть теперь instance property, где можно быстрее добраться до собственной инстанца.
1438.24 1460.80 "Игорь Лабутин" В очередной раз улучшили interop между JavaScript и .NET, то есть теперь если вы посылаете стримы из JavaScript в .NET, то теперь в .NET у вас есть интерфейс под названием IGSStreamReference, откуда вы можете собственно читать просто как обычный .NET стрим, данные без всякого Base64 encoding и так далее.
1460.80 1474.68 "Игорь Лабутин" Это позволило сделать во-первых large file upload, а во-вторых сделать более быстрый файл upload, потому что не нужно промежуточного кодирования контента в Base64, чтобы строчку передать в Blazor.
1474.68 1478.92 "Игорь Лабутин" Все передается массивчиком, ну если стримом по сути, прямо в .NET.
1478.92 1486.24 "Игорь Лабутин" Из Blazor можно менять теперь head элементы, то есть всякие тайтлы, мета, теги, вот это все теперь можно менять.
1486.24 1492.28 "Игорь Лабутин" На select элементах теперь можно сделать multiple атрибутик, то бишь multi-select поддержан.
1492.28 1495.04 "Игорь Лабутин" И это все про Blazor.
1495.04 1500.16 "Игорь Лабутин" Потихонечку двигается вперед поддержка HTTP/3, в Kestrel завезли превью вариант.
1500.16 1508.64 "Игорь Лабутин" Вообще HTTP/3 это, мы уже по-моему 2 подкаста назад или 3 подкаста назад чуть более детально обсуждали, что это такое.
1508.64 1526.44 "Игорь Лабутин" Напомню кратенько, что это штука, которая позволяет побыстрее получить респонс, ну скажем так, первый ответ на ваш реквест, потому что всякие SSL, handshake и прочие занимают меньше времени, меньше round trip туда-сюда, и поэтому первый ответ физически приходит быстрее.
1526.44 1564.68 "Игорь Лабутин" Дальше, если у вас начинают теряться пакеты, у вас будет гораздо более качественный, так скажем, experience с точки зрения задержек, потому что в HTTP/2, который все-таки работает поверх TCP, если у вас что-то пропало, в смысле пакет, то весь TCP, понятно, поток будет остановлен, пока этот пакет не перешлется, а это значит, что все, несколько реквестов, которые возможно мультиплексированы в одной TCP-коннекшене, а HTTP/2 это позволяет, будут по сути заблокированы, пока мы не найдем этот пакет, а в HTTP/3 проблемы такой нет, будет заблокирован только тот реквест, от которого пакет потерялся, все остальные будут продолжать работать.
1564.68 1579.20 "Игорь Лабутин" Ну и самая главная фича, которую как бы утверждает, что HTTP/3 нам должен решить, это возможность переключения между сетями, то есть вы жили в Wi-Fi, вышли на улицу, переключились в 4G, все продолжало работать, как будто вы вообще никуда не отключались, никуда не переключались.
1579.20 1586.92 "Игорь Лабутин" Так вот, всю эту радость завезли в кестрил, кроме последнего пункта переключения между сетями, пока вот эта кусочка протокола в кестриле нет.
1586.92 1590.60 "Игорь Лабутин" Но Майкрософт над этим работает, потихонечку движется.
1590.60 1605.84 "Игорь Лабутин" Когда мы говорим про HTTP/3, мы всегда говорим про QUIC, который собственно протокол поверх этого добра, который собственно реализует некоторую абстракцию, скажем так, уже более понятную для браузеров и всего остального.
1605.84 1614.04 "Игорь Лабутин" Так вот, поддержка этого добра теперь переместилась в основной фреймворк, то есть теперь не отдельно но гетпакетом это делается, а прямо в базовом фреймворке.
1614.04 1618.16 "Игорь Лабутин" Так что видимо Майкрософт считает, что это все будут скоро использовать.
1618.16 1624.52 "Игорь Лабутин" Ну, все не все, мы до сих пор HTTP/1 в основном используем, так что посмотрим, какова будет судьба HTTP/3 и QUIC.
1624.52 1636.32 "Игорь Лабутин" Дальше то, что я уже говорил про Distributed Context Propagator, то есть он по сути связывает то, как у вас, у всех, создается тот самый Activity, когда приходит новый реквест.
1636.32 1645.80 "Игорь Лабутин" Теперь если этот Context Propagator запихать в DI, то он будет работать и AspNet будет его использовать для того, чтобы создать Activity.
1645.80 1661.96 "Игорь Лабутин" В хедерах можно теперь отвечать не только ASCII кодировкой, но и вообще чем угодно, но это opt-in штука, ее нужно включить отдельно, потому что считается, что хедера вне ASCII это плохо и несовместимо ни с какими стандартами.
1661.96 1686.12 "Игорь Лабутин" Если вы привыкли к IS-логам, то есть этим W3C-логам ваших реквестов, то теперь у нас есть отдельный W3C-логгер, который будет генерировать их ровно в этом формате, но там нужно не только сам логгер добавить, но еще и middleware, потому что, если помните, там в логгах пишется и какой реквест, и какой размер респонса, и какой ответ, и понятно, что это нужно все в middleware как-то поймать.
1686.12 1697.52 "Игорь Лабутин" И в SignalARIA добавили, чуть-чуть улучшили работу с authentication, соответственно, аутентификацией, да.
1697.52 1700.20 "Игорь Лабутин" Если вы этим пользуетесь, посмотрите, что там новенького.
1700.20 1716.88 "Игорь Лабутин" Это все про SPNetCore, в этот раз нет ничего про Entity Framework, Entity Framework команда молчит и никакого превью 7 от них пока по крайней мере не вышло, может быть будет чуть позднее, может быть они что-то готовят дополнительно, может быть просто фиксят баги и ничего в превью показывать, но пока нечего.
1716.88 1727.12 "Игорь Лабутин" Но вышел превью MAUI, там появились новые layout'ы вместо старых, Grid, Flex и Stack.
1727.12 1739.72 "Игорь Лабутин" Довольно много изменений про accessibility, если вы что-то делаете с всякими tap-stops, tap-orders, вот этим всем, посмотрите, потому что там какие-то вещи исчезли, какие-то добавились.
1739.72 1749.32 "Игорь Лабутин" Добавились масштабирования shift-office, ну и в общем они потихонечку видимо приводят это все в какой-то единый вид, чтобы этим было красиво и удобно пользоваться.
1749.32 1751.84 "Игорь Лабутин" Никаких больше изменений не анонсировано.
1751.84 1770.04 "Игорь Лабутин" На этом то, что вошло в официальный релиз превью 7 мы заканчиваем, но на самом деле есть еще пачка вещей, которые я так рандомно повстречал в твиттере или еще в каких-то местах, в основном это всякие разные интересные API'шки, которые появились, которые я хотел бы тоже немножко затронуть.
1770.04 1794.12 "Игорь Лабутин" Самая, наверное, прикольная тема, если вы когда-либо пытались, ну для меня по крайней мере прикольная, получить размер файла в C#, то там нужно было делать нетривиальный штук, или нужно было звать native API, либо нужно было каким-то, что-то короче там были какие-то всякие разные странные, непрямые пути, скажем так, получения размера файла, насколько я помню.
1794.12 1808.28 "Игорь Лабутин" Вот, теперь появился новый класс, называется System.io.random.access, который по сути копирует тот доступ к файлу, который вы могли иметь, допустим, в каких-нибудь плюсах или опять же сях.
1808.28 1818.92 "Игорь Лабутин" То есть теперь есть у класса File есть метод openHandle, то есть есть файл open, он возвращает обычный объект в файл, в котором вы можете делать ваши стандартные C# операции.
1818.92 1837.52 "Игорь Лабутин" А openHandle вернет вам специальный fileHandle, над которым можно выполнять только ограниченное количество операций, все они собраны в классе random.access, в частности там есть getLength, который просто вернет вам длину, а также там есть read/write, ну и read/write.async, которые позволяют собственно читать контент файла в нужном месте.
1837.52 1849.64 "Игорь Лабутин" Пока там нет всяких файлсиков, то есть перемещения по файлу, но раз называется random.access, скорее всего они там появятся, и вы сможете читать файлики вообще прямо вот нативненько-нативненько.
1849.64 1855.96 "Игорь Лабутин" Я не знаю, зачем это сделано, потому что в принципе ровно тот же эффект можно получать стандартным C#.
1855.96 1863.76 "Анатолий Кулаков" Да, что-то они вообще сбивают изначально новичков, то есть теперь встает вопрос, а что использовать, а какой метод из какого класса.
1863.76 1872.76 "Игорь Лабутин" Ну причем как бы вот random.access намекает, что вроде как вы должны просто рандомно иметь возможность куда-то пойти и что-то прочитать.
1872.76 1877.72 "Анатолий Кулаков" Тебе же никто раньше не мешал просто взять стрим и там ссикаться куда тебе угодно.
1877.72 1883.56 "Игорь Лабутин" Все правильно, так вот я говорю, что меня смущает, что в классе random.access нет пока метода для того, чтобы ссикаться куда угодно.
1883.56 1887.24 "Игорь Лабутин" То есть класс называется random.access, а random.access нам пока нет.
1887.24 1892.12 "Анатолий Кулаков" Хорошо, а тебя не смущает вообще само наличие класса random.access, зачем он вообще нужен?
1892.12 1893.68 "Игорь Лабутин" Смущает, пока не знаю.
1893.68 1894.68 "Игорь Лабутин" Будем посмотреть.
1894.68 1903.64 "Игорь Лабутин" Скорее всего, ну как обычно, он кому-то потребовался внутри .NET фреймворка, поэтому он появился, ну как бы класс удобный, давай выставим его в паблик тоже, вдруг кому пригодится.
1903.64 1905.52 "Игорь Лабутин" Что как бы добро хранить внутри.
1905.52 1911.12 "Анатолий Кулаков" Ну главное в стандартный фреймворк, чтобы он не попал, а так мы могли бы пакетиком распространять, да и все.
1911.12 1919.04 "Игорь Лабутин" Может кстати он и пакетиком, я вот не уверен, тему того входит ли он прям в силу в этот .vbcl, надо посмотреть, не помню.
1919.04 1924.44 "Анатолий Кулаков" Если пакетиком, то в принципе отлично, да, хорошая идея, может кому-нибудь понадобится, главное API даже не ломайте.
1924.44 1935.32 "Игорь Лабутин" Кстати, учитывая, что handle-то открывается через стандартный файл, файл.openhandle, то по крайней мере, handle-овая часть должна быть в .vbcl, потому что файл-то в .vbcl.
1935.32 1940.92 "Игорь Лабутин" Если это только не другой класс файл, который в другом на им спейсе, это будет совсем интересно.
1940.92 1950.36 "Игорь Лабутин" Ладно, давай помимо Random Access'а еще появилось некоторое количество новых хелперов, которые возможно вам будут интересны.
1950.36 1962.24 "Игорь Лабутин" Некоторые из них появились еще в шестом превьюшке, некоторые я так понимаю в седьмой, так что может быть вы уже их части видели, но для тех кто не видел, я например большую часть не видел, можно порассуждать на их тему.
1962.24 1980.48 "Игорь Лабутин" Во-первых, если вы работали с ISP.net core конфигурацией, а вы в принципе работали, то там есть у IConfiguration есть такой замечательный метод getSection, который вы как раз таки используете для того, чтобы забайндить вашу конфигурацию к, например, какому-нибудь объекту, ну или просто получить секцию из конфигурации, чтобы с ней поработать, передать куда-то дальше.
1980.48 1990.36 "Игорь Лабутин" Так вот теперь там есть помимо метода getSection, есть еще метод getRequiredSection, который убедится, что эта секция реально есть в конфиге и кинет exception, если ее нет.
1990.36 2007.44 "Игорь Лабутин" Надеюсь, что на кинет exception разумной, в смысле там будет написано какой секции нет и по какому пути, а не как с null reference, где ничего не сказано про то, или там с file not found, где никогда не говорится какой же file not found, но я надеюсь, что они извлекли уроки из старых exception и пишут нормальный exception.
2007.44 2012.84 "Игорь Лабутин" Но теперь если у вас действительно какая-то секция требуется, используйте getRequiredSection и будет вам счастье.
2012.84 2023.92 "Игорь Лабутин" Дальше завезли parallel for each async, то есть теперь можно в parallel for each, ну только async версию передать, асинк лямбду и все там будет асинхронно-асинхронно и короче прям как надо.
2023.92 2037.96 "Игорь Лабутин" Если вы много работаете с битовыми операциями, то в системномере xbit operations добавились по крайней мере два точные метода, теперь можно проверить, является ли число в степени двойки, а также есть метод, называется округли пожалуйста до следующей степени двойки.
2037.96 2044.00 "Игорь Лабутин" В принципе для всяких allocators, там буферов или еще чего-то наверное будет полезно.
2044.00 2065.92 "Игорь Лабутин" Следующий момент, все мы писали код в начале методов типа if argument is null, вот это все throw argument null exception, теперь есть стандартный хелпер внутри bcl под названием throw if null, то есть можно написать argument null exception .throwifnull, передать аргумент и он сам кинет нужный exception если null.
2065.92 2072.04 "Игорь Лабутин" Я так подозреваю, что в большинстве проектов такие хелперы и так есть, но вот теперь есть стандартный.
2072.04 2129.76 "Игорь Лабутин" Если вы где-нибудь используете, обычно это в логах используется, то есть такую пропертию как thread.managedThreadId, для того чтобы узнать id потока, то знайте, что эта штука теперь деприкейтед, потому что она на самом деле довольно трудоемка, в смысле что несмотря на то, что свойства по-моему даже статик, ну или надо было сказать thread.current.managedThreadId по-моему, и это приводило к каким-то локейтам лишним, довольно тяжелым, теперь стало проще, теперь в классе environment есть просто статическая пропертия, называется thread.managedThreadId, которая для каждого thread будет возвращать его собственное thread.id, и такая же история для processId и processName, по-моему, раньше чтобы узнать processId нужно было создать экземпляр класса процессы и узнать у него id, ну вот его process.current.id, это было очень дорого, теперь можно сказать environment.processId и у вас будет ваш processId, это прям, мне кажется, тоже для всяких логов полезно.
2129.76 2154.08 "Игорь Лабутин" Возвращаясь к unsave и всяким таким штукам, теперь у нас есть не только thread.start, у нас теперь есть thread.unsaveStart, вполне себе паблика пишка, но unsave, unsave она в том смысле, что она не кепчурит никакого экзекюшн контекста, если вы знаете, что такое экзекюшн контекст и вы знаете сценарий, когда вам не нужно его кепчурить, для вас теперь есть специальная пишка, более подробно рассказывать не буду.
2154.08 2176.16 "Игорь Лабутин" Следующий момент, мне просто понравилась штука, не все знают, сколько у нас вообще таймеров есть в дотнете, если я правильно помню, их у нас 4, winform, wpf, system.trading и system.timers.timer или как-то так, ну короче, 4 таймера есть в дотнете, если у меня память не изменяет, теперь 5.
2176.16 2219.00 "Игорь Лабутин" Теперь у нас есть класс под названием periodicTimer, который очень забавный, у него нету никаких callbacks, нет ничего такого, то есть вы просто создаете таймер, указываете в конструкторе, какой период у этого таймера будет и дальше вызываете тупо метод, называется waitForNextTick, ну естественно вы вызываете его с await, то есть вы говорите awaitTimer.waitForNextTick и ваш метод аккуратненько засыпает до следующего тика, делаете вы это естественно в цикле, ну и таким образом у вас получается таймер, где в некотором смысле это очень похоже на awaitTask.delay нужного периода, но вот здесь таймер чуть умнее, он будет учитывать время выполнения вашего кода вне таймера, ну и так далее.
2219.00 2222.16 "Игорь Лабутин" Так что теперь есть такая штука.
2222.16 2248.00 "Игорь Лабутин" И последнее, что я хотел здесь рассказать, это про атрибутик colorArgumentExpression, мы тоже, наверное, с полгода назад, наверное, в каком-то из выпусков обсуждали, что есть такой клевый аргумент, атрибут, который приводит к тому, что если пометить им стринговый параметр вашего метода, то в этот стринговый параметр будет передан прям текст того, как ваш метод был вызван.
2248.00 2254.56 "Игорь Лабутин" То есть, например, в assertах это будет текст того, что написано в ассерте прямо в коде.
2254.56 2259.68 "Игорь Лабутин" Assert x>5, там будет написано x>5.
2259.68 2263.56 "Игорь Лабутин" Хотя в параметры будет передано bool, понятное дело, больше он 5 или не больше 5.
2263.56 2267.32 "Игорь Лабутин" А в такую строчку будет передано выражение, очень удобно для логирования, например.
2267.32 2272.56 "Игорь Лабутин" Так вот проблема была в том, что атрибут этот давно живет в .NET, он в PC или есть, но он не реализован был.
2272.56 2279.72 "Игорь Лабутин" Всё, наконец-таки его реализовали, вмёрзли в этот код, теперь если вы возьмёте последний, последний, последний .NET 6, то он там будет и будет работать.
2279.72 2283.00 "Игорь Лабутин" Мало ли вам зачем-то это было надо, мне показалось интересно.
2283.00 2291.84 "Игорь Лабутин" Всё, на этом с .NET 6 превью 7 можно закончить, больше там ничего интересного и нового не завезли.
2291.84 2298.40 "Анатолий Кулаков" Ну и так, в принципе, отличный большой развернутый списочек получился, нам хватит поизучать и посмотреть.
2298.40 2312.08 "Анатолий Кулаков" Слушай, а я вот слышал, что ещё в интернетах очень гуляет бурление по поводу другой мегафичи, которая называется Static Abstract Interface Members, и мне кажется, у тебя есть что сказать по этому поводу.
2312.08 2326.32 "Игорь Лабутин" Ну, мне кажется, мы записали уже довольно много выпусков, потому что я могу сказать, что и эту тему мы тоже обсуждали в каком-то из выпусков давно, но сейчас она обрела некоторые практические применения, и поэтому давайте расскажем ещё разок.
2326.32 2340.92 "Игорь Лабутин" Во-первых, давайте начнём немножко, в принципе, с другой стороны, и скажем, что то, про что я буду рассказывать, это является Preview Feature, и это не просто слова, потому что это входит в какой-то очередной превью, это прям новая концепция.
2340.92 2344.36 "Игорь Лабутин" В .NET появляется штука под названием Preview Features.
2344.36 2346.12 "Игорь Лабутин" Что это такое?
2346.12 2357.04 "Игорь Лабутин" Вы можете взять ваш код, например, метод или пропертию, или вообще сборку целиком, и пометить его атрибутом Requires Preview Features.
2357.04 2360.36 "Игорь Лабутин" Это атрибут, просто он без параметра, без всего.
2360.36 2365.44 "Игорь Лабутин" Дальше есть соответствующий аналайзер, его поведение я сейчас расскажу.
2365.44 2367.48 "Игорь Лабутин" Что он делает?
2367.48 2379.76 "Игорь Лабутин" Он смотрит, есть ли в той сборке, которую вы используете, то есть вы, например, референсите сборку или из NuGet пакета, или просто в вашем соседнем проекте, или просто длитку какую-то.
2379.76 2396.76 "Игорь Лабутин" То есть в сборке, которую вы референсите, есть хоть что-то, помеченное флагом Requires Preview Features, то, соответственно, в той сборке, которую вы пишете, из которой вы используете, либо должно быть тоже такой флаг, либо вы ее должны компилить с этим флагом.
2396.76 2406.36 "Игорь Лабутин" Ну, в смысле, поскольку его можно задать на уровне Assembly, вы можете просто прямо в CSS Project написать, что Requires Preview Features true, и это будет считаться, что вы такой атрибут задали.
2406.36 2417.96 "Игорь Лабутин" То есть таким образом это все сводится к тому, чтобы вся цепочка, как со Sync/Await, вся цепочка использования была помечена таким атрибутом.
2417.96 2426.88 "Игорь Лабутин" То есть если вы используете такую сборку с Preview Features, то ваш код тоже должен быть помечен, так что он тоже требует Preview Features.
2426.88 2433.44 "Игорь Лабутин" Аналайзеров пока еще нет, в .NET 6 Preview 7 его не завезли, но скоро будет.
2433.44 2452.20 "Игорь Лабутин" Соответственно, вот это позволит команде .NET такие фичи, про которые я сейчас буду говорить, завозить на самом деле в уже релизный .NET 6, он будет прямо в релизе все это в коде, но выключенным по умолчанию, пока вы такой атрибутик не вставите.
2452.20 2453.88 "Игорь Лабутин" Мне кажется, прикольное дело.
2453.88 2455.36 "Игорь Лабутин" Теперь, собственно, про фичу.
2455.36 2458.98 "Игорь Лабутин" Действительно, они завезли статические абстрактные методы интерфейсов.
2458.98 2461.48 "Игорь Лабутин" Что это такое?
2461.48 2472.12 "Игорь Лабутин" Мы объявляем метод статический абстрактный, то есть по сути у него есть его declaration, то есть список параметров, возвращаемое значение, никакого implementation нет.
2472.12 2480.12 "Игорь Лабутин" В типах, которые реализует этот интерфейс, нужно этот метод заимплементировать.
2480.12 2490.36 "Игорь Лабутин" Причем надо понимать, что типов, которые реализуют кучу интерфейса, наоборот, один интерфейс может быть реализован огромным количеством типов, по большому счету.
2490.36 2497.20 "Игорь Лабутин" И каждый из таких типов обязан такой интерфейс, метод такого интерфейса статически абстрактный реализовать.
2497.20 2508.20 "Игорь Лабутин" Дальше, соответственно, вы не можете статик комбинировать с виртуалом, и вы не можете эту функциональность использовать в классах.
2508.20 2513.44 "Игорь Лабутин" То есть статические абстрактные методы в классах недопустимы.
2513.44 2526.12 "Игорь Лабутин" И более того, такие методы, которые статические абстрактные, если вы обращаетесь к объекту через его интерфейс, то есть, например, закастовали его к интерфейсу, то такой метод вызвать будет нельзя.
2526.12 2527.76 "Игорь Лабутин" Вот такая вот магия.
2527.76 2534.64 "Анатолий Кулаков" Слушай, ты очень много всего наговорил, а зачем вот так все сложно, зачем это понадобилось вообще?
2534.64 2535.64 "Игорь Лабутин" Вот.
2535.64 2547.12 "Игорь Лабутин" Эта штука не очень очевидна, но тем не менее позволяет сделать фичу, которую на самом деле, может быть, не все, но многие хотят в C#.
2547.12 2551.52 "Игорь Лабутин" То, которое есть, например, в плюсах, это обобщенную математику.
2551.52 2577.16 "Игорь Лабутин" То есть вы можете, например, написать свой класс, который будет иметь такую возможность, как, например, поддерживать сложение или деление, или битовые операции, которые по умолчанию компиляторы, естественно, не позволят применить к вашему, не знаю, допустим, вы пишете комплексные числа, класс комплексных чисел, вы не сможете их умножать друг на друга звездочкой в C#, в коде просто, потому что ну нельзя.
2577.16 2580.76 "Игорь Лабутин" Или в generic вообще, в generic вообще хуже.
2580.76 2591.60 "Игорь Лабутин" В generic, написать generic метод, который будет, например, использовать операцию плюс или звездочка, да, умножение, вы сейчас в C# никак не можете.
2591.60 2599.04 "Игорь Лабутин" Ну потому что компилятор скажет, а я вот, я фиг знает, будет уметь этот класс умножаться или не будет.
2599.04 2600.04 "Игорь Лабутин" Теперь будет можно.
2600.04 2601.04 "Игорь Лабутин" Как это сделано?
2601.04 2606.76 "Игорь Лабутин" В стандартной библиотеке теперь есть пачка интерфейсов, их реально дофигища.
2606.76 2609.92 "Игорь Лабутин" Они называются следующим образом.
2609.92 2621.92 "Игорь Лабутин" I_addition operators, I_division operators, I_comparison, I_bitwise, I_additive identity, I_minmaxvalue, I_number, I_binarynumber, I_floatingpoint.
2621.92 2642.24 "Игорь Лабутин" Короче, всякие разные комбинации для того, чтобы представить, что окей, я являюсь числом или там я являюсь floatingpoint числом или я являюсь числом, например, допустим, какой-нибудь там double будет реализовывать I_number, будет реализовывать I_floatingpoint и будет реализовать весь комплект там I_addition, I_division, I_comparison.
2642.24 2652.40 "Игорь Лабутин" И статический метод позволяет, соответственно, описать, собственно, там будет один метод, например, add, да, сложение.
2652.40 2681.04 "Игорь Лабутин" Там ты будешь писать, как у тебя складываются инстансы этих типов, после чего компилятор будет знать, окей, если в generic типе ты сможешь написать constraint на I_addition, и в этом случае начать использовать этот самый статический метод для вот этой вот типа абстрактной математики, например, add вызывать, и компилятор будет знать, ага, add, я теперь знаю, что такое add, и как бы, поскольку типы я знаю, что будут улетевать в таком constraint, ну, будет типа можно использовать.
2681.04 2690.48 "Игорь Лабутин" Причем это вот фишка компилятора, что плюсики будет заменять на add, да, деление будет заменять на вызов метода division.
2690.48 2740.24 "Игорь Лабутин" Пока это все очень, я бы сказал, сложно, вот, то есть там есть примеры, почитайте статью, это надо смотреть на код, там такие трехэтажные генерики, это все очень напоминает, начинает напоминать темплейты C++, да, которые там темплейт в темплейте, внутри темплейта, короче, выглядит это нереально сложно, но уже народ в комментах потихонечку начинает генерировать идеи, где это может быть еще пригодится, например, народ пишет, что в принципе можно попробовать таким образом избавляться от фабрик и начать, ну, по сути, писать вот эти статические методы интерфейсов, которые будут знать, где каждый объект будет реализовывать такой метод, там create, например, да, назвать метод create в интерфейсе, и объект, реализующий этот метод, будет уметь создавать сам себя.
2740.24 2746.84 "Игорь Лабутин" Там проблема с передачей параметров небольшая есть, но в принципе как бы все решаемо.
2746.84 2753.68 "Игорь Лабутин" Поэтому описал я это очень кратко, я боюсь, что без кода это все крайне сложно пока воспринять.
2753.68 2776.20 "Игорь Лабутин" Берите статью, она довольно честно подробная, берите dotnet 6, для того, чтобы это все заезжать, нужно взять экспериментальный пакет, называется system runtime experimental, это как раз таки пакет, в котором помечены эти features, requires feature, requires preview feature атрибутом, то есть, когда вы его заезжаете, вам нужно будет свой проект уже этим атрибутом пометить и пробовать экспериментировать.
2776.20 2780.56 "Игорь Лабутин" Либо подождем просто адекватных статей, где будет написано, как это все сделать просто и понятно.
2780.56 2781.56 "Игорь Лабутин" Пока сложно.
2781.56 2800.44 "Анатолий Кулаков" Ну вообще, несмотря на всю кажущуюся сложность, это интересно, когда в языке появляется что-то новое, может быть нестандартное, может быть на первый взгляд пугающее, но кажется, что приносящее новую парадигму, которая в будущем вылезет даже в новые подходы, в новые шаблоны проектирования.
2800.44 2804.40 "Анатолий Кулаков" И в принципе это значит, что язык жив, язык развивается.
2804.40 2805.92 "Анатолий Кулаков" Нет, и не так уж и плохо.
2805.92 2811.16 "Анатолий Кулаков" Вот, а еще интересная статейка вышла, которая нам рассказывает про string interpolation.
2811.16 2824.88 "Анатолий Кулаков" И здесь тоже кажется, что произошла какая-то революция в том подходе, который жил уже с нами многие годы, то есть мы уже все время пользовались самых первых версий string форматом и горе не знали.
2824.88 2840.24 "Анатолий Кулаков" И тут вдруг повалился interpolation, который очень удобненький появился, и вдруг к interpolation еще начали накручивать какие-то страшные небывалые вещи, без которых мы раньше жили и было все хорошо, а теперь они нам почему-то резко понадобились.
2840.24 2844.00 "Анатолий Кулаков" И что там накрутили, расскажи, и зачем это нам понадобилось?
2844.00 2850.08 "Игорь Лабутин" Ну, как обычно, основной драйвер всего этого дела это performance и работа с памятью.
2850.08 2853.48 "Игорь Лабутин" Давай напомним, действительно, мы начинали все всегда со string формата.
2853.48 2865.48 "Игорь Лабутин" Со string форматом все понятно, вы передаете строчку, в ней 10 placeholders, 0, 1, 2 и так далее в фигурных скобочках, и набор параметров в конце опциональный, если у вас были какие-то placeholders.
2865.48 2876.60 "Игорь Лабутин" Дальше метод внутри парсит строчку, находит все placeholders, подставляет аргументы по порядку, возможно, применяет какое-то форматирование, если оно было указано, и результирующую строчку выдает вам в ответ.
2876.60 2880.08 "Игорь Лабутин" С этим было несколько проблем.
2880.08 2905.16 "Игорь Лабутин" Сейчас мы к ним перейдем, но сначала вспомним, что действительно появились interpolation строки, это когда вы пишете перед строчкой $, и тогда вместо 0, 1 и вот этого всего вы можете написать туда прямо имена каких-то параметров, например, или прямо expression даже, которые можно посчитать, и в результате, ну, скажем так, код становится почище, понятнее, но на самом деле overhead еще немножко возрастает.
2905.16 2906.16 "Игорь Лабутин" Смотрите, в чем проблема.
2906.16 2914.24 "Игорь Лабутин" Во-первых, строчка формата вот этого с placeholders, она парсится, по сути, в случае с interpolated строками, два раза.
2914.24 2919.48 "Игорь Лабутин" Два раза это, конечно, в compile time, и это, ну, можно сказать, бесплатно для нас, но тем не менее.
2919.48 2926.96 "Игорь Лабутин" Но по сути, вызов все равно превращается в string формат, и поэтому в run time все равно эту строчку мы еще раз парсим, по большому счету.
2926.96 2943.44 "Игорь Лабутин" То есть мы уже потратили время в момент компиляции, мы распарсили, мы знаем, сколько там placeholders, мы знаем, в каких они местах, мы знаем, какие там типы, потому что там же C# выражение, которым тип известен, в общем-то, практически всегда в момент компиляции, за редкими исключениями, там, object.
2943.44 2945.52 "Игорь Лабутин" Но потом в run time нам заново все это делать.
2945.52 2946.52 "Игорь Лабутин" Это первое.
2946.52 2947.52 "Игорь Лабутин" Второе.
2947.52 2951.16 "Игорь Лабутин" Все аргументы передаются objects всегда.
2951.16 2967.40 "Игорь Лабутин" Была идея в string формате сделать несколько overloadов на самом деле для разных типов, то есть там, допустим, string string string, или string int, ну, понятно, что там количество комбинаций, оно прям гигантское.
2967.40 2982.12 "Игорь Лабутин" И если это сделать, например, generic методом, мультиплированным тремя параметрами, например, то, как мы знаем, для каждой комбинации, например, value типов, то есть там int, double, а их довольно часто передают в string формат, будет сгенерирована своя собственная версия кода, jitom.
2982.12 2986.28 "Игорь Лабутин" И это прям много с точки зрения overhead на генерацию кода.
2986.28 2989.44 "Игорь Лабутин" Поэтому этого сделано не было, и поэтому все передается objects.
2989.44 2996.16 "Игорь Лабутин" Есть несколько overloadов у string формата, где можно вообще не передавать параметров, можно передать один параметр, два параметра и три параметра.
2996.16 3008.52 "Игорь Лабутин" Но если вы передаете уже четыре и больше, то включается версия, которая содержит object array в качестве единственного параметра, и соответственно вы мало того, что передаете все объекты как объекты, вы еще и локируете массив.
3008.52 3013.60 "Игорь Лабутин" А надо сказать, что раз вы передаете все объекты как объекты, даже если это примитивные типы, то у вас есть boxing.
3013.60 3019.48 "Игорь Лабутин" То есть один string формат у вас прям генерирует додуре памяти, эээ, allocators.
3019.48 3032.32 "Игорь Лабутин" Хуже, если вы передаете туда все, что угодно в качестве параметров, кроме стрончек, на них будет вызван toString, потому что у framework нет никакого другого способа получить строковое представление от object, кроме как вызвать на нем toString.
3032.32 3041.12 "Игорь Лабутин" toString слоксирует строчку, которую вы потом склеите и вернете в виде финальной строки, но этот temporary строка тоже локетится.
3041.12 3061.32 "Игорь Лабутин" И последнее, что поскольку все передается как объекты, то есть боксится, вы не можете в качестве аргументов, например передавать какие-нибудь там ref struct или span, у которых может быть написан метод toString хороший, и который можно было бы вызвать, но к сожалению ref struct нельзя класть в кучу и соответственно боксить, и соответственно передавать как объект.
3061.32 3063.36 "Игорь Лабутин" В общем, одни сплошные минусы.
3063.36 3073.72 "Игорь Лабутин" Ну, они такие, конечно, но на самом деле, если вы string формат активно используете, то все эти мелкие локиты, они становятся видны на профилях программы, я с этим сталкивался.
3073.72 3075.60 "Игорь Лабутин" Что получается теперь?
3075.60 3077.00 "Игорь Лабутин" Теперь получается следующим образом.
3077.00 3085.48 "Игорь Лабутин" Как мы сказали, если у вас есть interpolated строка, то компилятор в любом случае должен ее распарсить, понять, где там placeholder и понять, какие expressions есть в каждом placeholder.
3085.48 3089.60 "Игорь Лабутин" И если он это сделал, так как бы чем не пользоваться этой информацией?
3089.60 3093.00 "Игорь Лабутин" Что теперь делается под капотом?
3093.00 3101.72 "Игорь Лабутин" Когда вы пишете там $, кавычка, какие-то строчки и там placeholder, то это преобразуется в набор вызовов к специальной новой структуре.
3101.72 3112.72 "Игорь Лабутин" Появилась новая структура, это ref struct, то есть это значит, что она точно на стеке лежит, ее нельзя никуда забоксить, она ничего не аллоцирует, она только может быть на стеке.
3112.72 3115.68 "Игорь Лабутин" Называется default interpolated string handler.
3115.68 3123.64 "Игорь Лабутин" Туда передается, в конструктор передается количество литеральных символов, которые у вас есть в строке, для preallocating некоторой памяти.
3123.64 3133.48 "Игорь Лабутин" То есть если вы, например, пишете, у вас там какое-то очень длинное предложение и потом один placeholder, то под это длинное предложение сразу будет преаллоцировано местом, ну и наверное с каким-нибудь запасом.
3133.48 3139.00 "Игорь Лабутин" И дальше к этой структуре начинают вызываться методы.
3139.00 3158.84 "Игорь Лабутин" То есть на литеральную строчку будет вызвана append literal, а потом на каждый placeholder будет вызван, ну не вызван, а сгенерирован вызов метода append formatted, который дженериковый, который будет, соответственно, либо передаваться, туда будет передаваться то выражение, которое вы написали в placeholder параметре.
3158.84 3173.68 "Игорь Лабутин" И это означает, что поскольку вы передаете только один аргумент, то будет сгенерирована во время рантайма все нужные реализации этой функции для всех вариантов параметров, которые вы передаете, но они будут сгенерированы по одной штуке на каждый тип, что в принципе норм.
3173.68 3176.32 "Игорь Лабутин" И самое главное, что теперь нет боксинга никакого.
3176.32 3193.52 "Игорь Лабутин" То есть если вы передаете int, то у вас будет вызвана версия append формата для int, который ничего не будет боксить, вы можете теперь передавать refstruct, вы можете передавать что угодно и оно все будет прям офигенно быстро и так далее работать, все это действительно работает там внутри на спанах и вот на этом все.
3193.52 3205.52 "Игорь Лабутин" Естественно есть override для object, ну потому что у вас могут быть object, которые передаете в качестве placeholder значений, ну object и object, на нем вызовется toString, потом понятно впишется куда нужно.
3205.52 3222.24 "Игорь Лабутин" В конце вызовется метод toString and clear, который освободит всю ненужную память, хотя она на стеке, и вернет вам строчку готовую, собранную прям из того, что получилось собрать из всех вот этих вызовов.
3222.24 3226.76 "Игорь Лабутин" То есть по сути allocate у вас будет только один в самом конце и ровно на ту строку, которую вы собрали.
3226.76 3232.60 "Игорь Лабутин" Это прям супер, такой очень оптимальный string builder внутри получается.
3232.60 3244.72 "Игорь Лабутин" Для того, чтобы все это работало еще более эффективно, есть несколько способов вклиниться в эту работу, вот этого всего фреймворка.
3244.72 3263.48 "Игорь Лабутин" Во-первых, вы сейчас уже можете реализовать интерфейс iformattable и тогда вместо вызова toString у вас будет вызываться специальный метод из этого интерфейса при string форматах, который позволяет отформатировать это все добро с учетом всех вот этих параметров форматирования, которые вы в плейсхолдере можете указать.
3263.48 3269.96 "Игорь Лабутин" Так вот теперь появился новый интерфейс, называется ispanformattable, который передает вам span, в который можно писать.
3269.96 3286.28 "Игорь Лабутин" И таким образом вы можете, если у вас какая-то очень high-performance штука, которую нужно быстро очень сериализовывать допустим в строке, вы реализуете ispanformattable, пишете в спаны, не аллоцируете никакой памяти, все будет быстро и хорошо работать.
3286.28 3287.28 "Игорь Лабутин" Дальше следующее.
3287.28 3314.20 "Игорь Лабутин" В методе вы можете, вот это тоже сложная концепция, лучше рекомендую почитать статью, но я просто упомяну, что вы можете в методе пометить, не пометить, добавить параметр с типом default interpolated string handler и тогда, если вы передаете интерполированную строчку в такой метод, то на самом деле все это будет развернуто вот в вызовы этого специального билдера.
3314.20 3322.64 "Игорь Лабутин" В статье есть огромное количество рассмотренных примеров, где это может быть полезно и как вы можете туда передавать дополнительные параметры.
3322.64 3350.96 "Игорь Лабутин" Также эта штука хорошо интегрирована с формат-провайдерами, то есть если вы знаете, наверное, что вы можете, как я говорил, в placeholder написать имя переменной двоеточие и например, если это для даблов, в каком формате его вывести, в scientific или с точечкой или еще как-то, то вы можете через реализацию интерфейса iFormatProvider написать туда вообще все что угодно и ваш формат-провайдер будет интерпретировать этот текст после двоеточия как вы хотите.
3350.96 3355.40 "Игорь Лабутин" Эта вся штука, все это синтегрировано и все будет хорошо.
3355.40 3372.28 "Игорь Лабутин" И самое главное, они все это синтегрировали еще и со stringbuilder, поэтому если вы в stringbuilder пишете типа append format и туда передаете интерполированную строчку, то строчка не будет аллацироваться и она будет все писаться прямо напрямую внутрь stringbuilder.
3372.28 3376.08 "Игорь Лабутин" Короче, они там такую накрутили крутую магию внутри.
3376.08 3379.68 "Игорь Лабутин" Почитайте статью, посмотрите, как это все вообще работает и устроено.
3379.68 3387.80 "Игорь Лабутин" Ну в общем, теперь не надо бояться использовать интерполированные строчки, потому что они будут работать быстро, хорошо и гораздо лучше, чем обычный stringformat.
3387.80 3389.44 "Игорь Лабутин" stringformat, кстати, будет тормозить.
3389.44 3395.04 "Анатолий Кулаков" Ну неплохо, неплохо, слушай, отличные оптимизации.
3395.04 3406.68 "Анатолий Кулаков" Несмотря на то, что это кажется со стороны как какая-то экономия на спичках, которая в принципе никогда никому не нужна, ну мы там передаем JSON гигабайтами, а тут вдруг решили какие-то append форматы оптимизировать.
3406.68 3415.32 "Анатолий Кулаков" Но на самом деле это действительно очень большой пласт и памяти и перформанса занимают подобные маленькие спички.
3415.32 3419.36 "Анатолий Кулаков" Если их соптимизировать, то в куче это выйдет хороший прирост.
3419.36 3424.40 "Игорь Лабутин" Да, потому что такие строчки очень часто являются комбайнт ключами.
3424.40 3433.72 "Игорь Лабутин" Например, вы хотите построить сложный ключ из трех значений, там, не знаю, через подчеркивание объединяете строчку и кидаете в какой-нибудь дикшенере от стринга во что-нибудь.
3433.72 3440.40 "Игорь Лабутин" И вот собирание этих ключиков каждый раз, оно довольно затратное может быть и сильно ударит по вашей памяти, если вы это делаете часто.
3440.40 3444.12 "Игорь Лабутин" Вот для таких случаев вот эти новые interpolated стринги будет прям вообще самое оно.
3444.12 3451.08 "Анатолий Кулаков" Так, я правильно понял, что нам ничего включать не надо, там атрибуты проставлять не надо, это все у нас будет с новой версией C#?
3451.08 3452.72 "Игорь Лабутин" Да, это все с новой версией C#.
3452.72 3461.56 "Игорь Лабутин" Вам нужно только проставить length preview, по-моему, ну типа следующая версия типа поддержана, и дальше вся эта машинерия будет работать сама.
3461.56 3465.28 "Игорь Лабутин" В самом деле просто компилятор будет знать, что да, окей, можно переписать.
3465.28 3468.76 "Анатолий Кулаков" То есть это даже версия дотнета, наверное, не C#?
3468.76 3473.60 "Игорь Лабутин" Наверное, дотнета, вот сейчас не знаю, скорее всего, достаточно затаргивать дотнет 6.
3473.60 3489.40 "Анатолий Кулаков" Хорошо, ты нам огромное количество нововведений и по языку, и по всему фреймворку уже рассказал, большое тебе спасибо, было интересно, теперь да, я что-нибудь повнесу.
3489.40 3510.24 "Анатолий Кулаков" У меня тут интересная статичка есть про самый лучший редактор на свете, вышел новый ReSharper и Rider 2021.2, и у него появилось тоже много-много интересных вещей, кроме стандартных оптимизаций, больше квикфиксов и прочего всего, есть несколько пунктов, на которые хотелось бы остановиться.
3510.24 3511.76 "Анатолий Кулаков" Прежде всего код анализ.
3511.76 3532.40 "Анатолий Кулаков" Код анализ научился понимать нативно такие вещи, как ArrayEmpty, EventArgsEmpty и TypeEmptyTypes, то есть теперь советуют заменить на Empty аналоги все ваши создаваемые, скорее всего, ручками пустые массивы, пустые массивы типов и так далее.
3532.40 3539.56 "Анатолий Кулаков" В общем, это позволит вам без всяких новых аллокаций передавать пустые аргументы, что тоже, в принципе, часто бывает нужно.
3539.56 3547.04 "Анатолий Кулаков" Далее он научился понимать из EditorConfig специальное свойство, которое называется GeneratedCode.
3547.04 3558.36 "Анатолий Кулаков" Благодаря ему он теперь знает в каких файлах вы генерируете обычно код и, соответственно, относится к этим файлам уже с определенными правилами, которые у него есть для сгенерированных файлов.
3558.36 3564.36 "Анатолий Кулаков" В плане nullblur reference types я расскажу отдельно, это большая интересная тема.
3564.36 3573.88 "Анатолий Кулаков" Здесь бы хотелось упомянуть, что вышел новый пакет JetBrains Annotations, и в этом пакете все типы помечены с учетом nullblur reference types.
3573.88 3583.12 "Анатолий Кулаков" То есть теперь вы можете использовать JetBrains атрибуты вместе с рослиновскими nullblur типами.
3583.12 3586.44 "Анатолий Кулаков" Улучшилась поддержка source-генераторов.
3586.44 3589.52 "Анатолий Кулаков" В частности, они были интегрированы абсолютно везде в систему.
3589.52 3594.52 "Анатолий Кулаков" Например, warning и error теперь отображаются непосредственно в коде.
3594.52 3602.48 "Анатолий Кулаков" Если эти error и warning произошли в сгенерированном коде, то они в редакторе видны у вас из того места, который порождает этот код.
3602.48 3606.52 "Анатолий Кулаков" А также в различных подсказках, tooltypes и так далее.
3606.52 3616.32 "Анатолий Кулаков" Например, в solution-wide analysis теперь там тоже включены все warning и error из сгенерированного кода, что очень полезно.
3616.32 3625.00 "Анатолий Кулаков" То есть вы можете искать всякие ошибки, недочеты, опечатки не только в вашем собственном коде, но и в том, который породили генераторы.
3625.00 3632.96 "Анатолий Кулаков" Также у нас теперь этот код полностью участвует в find-usages, в всяких наследованиях, в навигациях.
3632.96 3638.20 "Анатолий Кулаков" В общем, пронизан полностью всей системой типов JetBrains.
3638.20 3641.48 "Анатолий Кулаков" Интересное нововведение коснулось HTTP-клайента.
3641.48 3644.44 "Анатолий Кулаков" Точнее будет сказать его поддержки URL.
3644.44 3652.48 "Анатолий Кулаков" В одном из прошлых выпусков мы уже обсуждали, что ядро решапера научилось хорошо понимать роуты.
3652.48 3662.48 "Анатолий Кулаков" То есть оно знает, в каком контроллере роут объявлен, как он был примаплен на endpoint и как он может вызваться с помощью HTTP-клайента.
3662.48 3685.00 "Анатолий Кулаков" Вот теперь, когда вы пишете у HTTP-клайента метод получения ресурса по какому-то URL, решапер знает все URL, которые есть в ваших контроллерах, которые были объявлены с помощью атрибутов route или с помощью атрибутов HTTP-метод или еще как-то и подсказывает вам в интеллисенсии, что вы можете сюда подставить, что очень удобно.
3685.00 3701.64 "Анатолий Кулаков" То есть если у вас есть контроллер с памятным атрибутом users, то из другого проекта вызывая HTTP-клайент, get, например, решапер скажет, что вы можете по строчке users получить доступ к тому контроллеру, над которым вы это все объявили.
3701.64 3713.56 "Анатолий Кулаков" Также здесь включена навигация, то есть это теперь уже не просто строчки, это просто представление строчек, по правде уже это настоящие навигационные объекты, то есть можно по ним навигироваться.
3713.56 3736.76 "Анатолий Кулаков" Очень интересный эффект получается при переименовании, если у вас вдруг в контроллере это больше не юзеры, а теперь вы это переименуете в какие-нибудь people, то и тот HTTP-клайент, который вызывал этот контроллер по данному url, он тоже теперь больше перестанет вызывать юзеров и станет вызывать people, что смотрится довольно забавно.
3736.76 3760.44 "Анатолий Кулаков" Интересно, конечно, такой эскейс, что многие заводили какие-нибудь шареные константы или шареные редонали-филды и туда выносили все урлы, для того чтобы удобно было пробегаться по ним и рефлекшнам, искать какие-нибудь зависимости и смотреть какой урл где используется.
3760.44 3771.64 "Анатолий Кулаков" К сожалению, пока решапер не может понять, что та константа, которую я объявил в каком-то классе, она по сути является урлом, и вот ее надо поставлять в интеллисенсии и ее нужно везде использовать.
3771.64 3777.92 "Анатолий Кулаков" Но я надеюсь, с помощью каких-нибудь кастомных атрибутов или специального воркфолова анализа мы к этому дойдем.
3777.92 3792.60 "Анатолий Кулаков" Потому что несмотря на всю мощь и удобство такого подхода, дублировать строки в коде, тем более такие ключевые важные строки, как url, то есть дублировать его над контроллером и дублировать его же над клиентом, все-таки такая рискованная вещь.
3792.60 3803.56 "Анатолий Кулаков" Вдруг решапер когда-то не поймает переименование или пользователь плохо сможет не применить quickfix переименование и у вас уже разъезжаются сразу клиенты с контроллерами.
3803.56 3808.48 "Анатолий Кулаков" При использовании какого-то шареного классика с константами этого никогда не произойдет.
3808.48 3811.84 "Анатолий Кулаков" И такой подход, насколько я видел, более распространен.
3811.84 3815.72 "Анатолий Кулаков" Хотелось бы, чтобы этот кейс был тоже поддержан.
3815.72 3821.04 "Анатолий Кулаков" В декомпиляторе мы научились наконец-то декомпилировать синглфайл приложения.
3821.04 3825.80 "Анатолий Кулаков" С ними были проблемы, сейчас проблем никаких нет, они декомпилируются как обычное приложение.
3825.80 3834.20 "Анатолий Кулаков" Более того, каждый модуль показывается как будто там отдельный сборка, отдельный пакетч у этого приложения внутри есть.
3834.20 3836.40 "Анатолий Кулаков" Поэтому можно каждый модуль так подробнейше рассмотреть.
3836.40 3839.76 "Анатолий Кулаков" Стоит обратить внимание на решапер command line tools.
3839.76 3850.96 "Анатолий Кулаков" В частности, был breaking change в утилите inspect code, который позволяет вам из командной строки проверить, проанализировать ваш код, что очень удобно на CI серверах.
3850.96 3861.68 "Анатолий Кулаков" Так вот, она теперь по умолчанию будет восстанавливать NuGet пакеты из репозитория и собирать ваш solution для того, чтобы получить более детальный анализ.
3861.68 3867.16 "Анатолий Кулаков" Вот если вы хотите вернуть старое поведение, для этого есть специальный ключ, который называется no builds.
3867.16 3872.36 "Анатолий Кулаков" И он задизабилит рестор и собирание вашего solution.
3872.36 3876.08 "Анатолий Кулаков" Это что касается решапера у райдера.
3876.08 3881.68 "Анатолий Кулаков" Практически база та же самая, потому что он использует ядро решапера, естественно.
3881.68 3883.56 "Анатолий Кулаков" Но есть несколько своих фишек.
3883.56 3887.20 "Анатолий Кулаков" Например, endpoint tool window, про который мы упоминали в прошлом выпуске.
3887.20 3891.64 "Анатолий Кулаков" Вкратце расскажу, что это относится к тем же самым нашим урлам.
3891.64 3897.20 "Анатолий Кулаков" Урлы умеют детектиться из атрибутов route, http, accept, verb.
3897.20 3900.96 "Анатолий Кулаков" И эти урлы теперь перемещаются в наше отдельное окошко.
3900.96 3907.84 "Анатолий Кулаков" В этом окошке вы можете удобно посмотреть все navigation патхы, все урлы, которые есть в вашем приложении.
3907.84 3911.72 "Анатолий Кулаков" Можете почитать документацию прямо в одном месте по ним по всем.
3911.72 3916.16 "Анатолий Кулаков" Можете прыгнуть на контроллер, который обрабатывает этот route.
3916.16 3919.08 "Анатолий Кулаков" Можете поискать cuse, find usages и прочее.
3919.08 3924.32 "Анатолий Кулаков" То есть вообще общаться с урлами как с полноценными объектами, живущими в вашей системе.
3924.32 3928.02 "Анатолий Кулаков" У райдера теперь появилось отдельное окошко, где можно это удобно делать.
3928.02 3933.52 "Анатолий Кулаков" Я надеюсь, это окошко до решапера они тоже донесут, потому что окошко очень полезное.
3933.52 3936.48 "Анатолий Кулаков" В Blazor WebAssembly завезли дебаггинг.
3936.48 3939.96 "Анатолий Кулаков" Этого тоже очень ждали, очень много просили.
3939.96 3945.76 "Анатолий Кулаков" Теперь client-side WebAssembly можно дебажить прямо из райдера.
3945.76 3954.24 "Анатолий Кулаков" В этот момент, как только вы запускаете дебаггер, он запускает ваше приложение и приоттачивается к Google Chrome или Edge.
3954.24 3961.56 "Анатолий Кулаков" И вместе вы можете смотреть интерфейс в браузере, а дебажить код в райдере.
3961.56 3965.04 "Анатолий Кулаков" Также эта штука поддерживается на Linux.
3965.04 3970.72 "Анатолий Кулаков" Еще одна интересная вещь - это поддержка Apple Silicon M1.
3970.72 3977.24 "Анатолий Кулаков" У райдера теперь появилась с этой версии специальная сборка, которая называется Apple Silicon Edition.
3977.24 3982.56 "Анатолий Кулаков" И в ней он собран с полной поддержкой чипа M1.
3982.56 3986.88 "Анатолий Кулаков" Поэтому тем, кому интересно эта штука, обязательно ставьте, пробуйте.
3986.88 3997.76 "Анатолий Кулаков" Внутри это все сделано на DotNet 6 Preview 4, который уже заявил поддержку M1.
3997.76 4004.80 "Анатолий Кулаков" Будем вместе пользоваться, вместе тестировать, насколько это все хорошо работает под новыми макбуками.
4004.80 4005.80 "Анатолий Кулаков" Прекрасно.
4005.80 4010.32 "Игорь Лабутин" Видно, что и райдеры, и шарперы хорошо развиваются.
4010.32 4014.40 "Игорь Лабутин" Помимо райдера у нас есть и другие IDE для DotNet, например Visual Studio.
4014.40 4016.44 "Игорь Лабутин" Там тоже есть определенное развитие.
4016.44 4021.36 "Игорь Лабутин" Но пока оно такое, достаточно скрытое, я бы сказал.
4021.36 4024.64 "Игорь Лабутин" Речь идет о Visual Studio 2022 Preview 3.
4024.64 4033.04 "Игорь Лабутин" Там в этот раз нету никаких новых иконок, там вот этого всего, но есть несколько тоже нововведений интересных, давайте мы их посмотрим.
4033.04 4045.00 "Игорь Лабутин" Во-первых, это Personal and Team Productivity заголовок, который на самом деле объединяет в себя довольно много всяких мелких фич, но вполне тоже почему бы и нет.
4045.00 4055.76 "Игорь Лабутин" Во-первых, если вы когда-либо оттачились к процессам из Visual Studio, то теперь вы будете рады узнать, что диалог полностью асинхронный, то есть он не будет подвисать пока там список процессов генерится и так далее.
4055.76 4064.44 "Игорь Лабутин" Для всех процессов показываются command-line аргументы, для IS-овых процессов показываются еще дополнительно некоторые IS-информации.
4064.44 4079.80 "Игорь Лабутин" И можно теперь включить режим preview, то есть отображать процессы в виде дерева на самом деле, что может быть вам полезным, когда вы разбираетесь в вашей сложной иерархии процессов, например, вашего приложения, если он состоит из многих процессов дочерних.
4079.80 4092.84 "Игорь Лабутин" Дальше завезли новый, у них это называется New Project Designer, то есть тот набор свойств, которые вы задаете для проекта при создании, но я так понимаю, что это работает и для свойств текущего проекта тоже.
4092.84 4121.76 "Игорь Лабутин" Теперь это такой, как они называют, одноколоночный интерфейс со всеми опциями, с нормальными descriptions, то есть с удобным поиском по опциям, то есть не куча вкладочек типа debugging, тут общие property, тут какой-нибудь там code signing, тут еще что-нибудь, а просто общий сплошной список опций, как-то сгруппированных в определенные категории, где можно легко по ним искать и с нормальным текстом сопроводительным, что это вообще значит.
4121.76 4132.80 "Игорь Лабутин" И они улучшили еще темную тему, если вы пользовались стандартной темной темой Visual Studio, там некоторые цвета были, ну скажем так, излишне яркими, на мой вкус.
4132.80 4146.60 "Игорь Лабутин" Теперь они стали немножко более приглушенными и действительно не сильно бросаются в глаза, и в общем темная тема стала, по крайней мере на скриншотах я только видел, пока я еще себе не ставил 2022, оно выглядит поприятнее.
4146.60 4160.96 "Игорь Лабутин" Для разработки, собственно, есть тоже некоторое количество улучшений, называется это все developing modern apps, и под modern apps в основном подразумевается либо кроссплатформа, либо UI.
4160.96 4187.84 "Игорь Лабутин" Для кроссплатформы завезли remote testing, то есть теперь если у вас есть какие-то тесты, типа юнит тест или еще что-то, вы можете их запускать кроссплатформенно, то есть поддержаны линуксовые контейнеры, поддержаны Windows App System for Linux и в принципе поддержано любое что угодно, к чему можно подключиться по SSH, ну в смысле к remote хосту, если вы можете подключиться по SSH, на нем тоже можно запускать тестики и их отлаживать.
4187.84 4200.08 "Игорь Лабутин" И появились два новых типа проектов, это соответственно JavaScript и TypeScript для всяких Angular, Vue и React, соответственно они тоже будут поддержаны теперь прям в студии нативно.
4200.08 4242.72 "Игорь Лабутин" Из более приближенных, еще более приближенных к разработке, это новый Diagnostic Analyzer, если у вас есть memory dump, то вы можете загнать его в Visual Studio, она над ним подумает и выдаст все проблемы, которые она видит в этом дампе, то есть возможно у вас есть какие-то дедлоки, возможно у вас есть какие-то там, не знаю, слишком большое количество потоков, возможно у вас есть какие-то проблемы с garbage коллектором, по каким-то внутренним структурам данных тут на это можно узнать и вот соответственно все эти диагностики теперь будут выданы вам в нормальном, хорошо читабельном виде, можно будет по этим трейдам попрыгать, посмотреть дедлоки, в общем Microsoft всячески пытается улучшить то, что раньше можно было добиться только сложными усилиями винтабг, например.
4242.72 4249.96 "Анатолий Кулаков" Мне нравится этот подход, просто кнопочка "покажи мне все плохое" и "оставь в покое все хорошее", прекрасно, чтоб все так работало.
4249.96 4254.36 "Игорь Лабутин" Ну да, посмотрим, насколько хорошо это будет работать, но в принципе да, и подход прикольный.
4254.36 4271.12 "Игорь Лабутин" Дальше если у вас почему-то в одном солюшене внезапно собраны проекты, которые почему-то лежат в разных гидрепозиториях, то раньше с этим работать было очень сложно, то есть студия не могла одновременно контактиться к нескольким гидрепозиториям и вам нужно было выбирать, с кем вы работаете.
4271.12 4299.76 "Игорь Лабутин" Если все нормально работает, вы можете включить эту опцию, пока нужно включить в обзах студии, называется это "Enable Multi-Repo Support", если это включено, дальше каждый проект может жить в своем репозитории и студия будет правильно, корректно работать с гидом, чтобы правильно пушить во всякие разные, эти самые, как называется, пушить в репозитории правильно, ну и пулить, и все остальное работает.
4299.76 4302.00 "Игорь Лабутин" Можно работать с разными гидрепозиториями.
4302.00 4307.68 "Игорь Лабутин" Вот примерно и все, что касается 22-ой студии.
4307.68 4346.72 "Игорь Лабутин" Помимо нововведений 2022 студии, куда, я так понимаю, сейчас сосредоточены основные усилия команды, вышла новая версия, новый минорный релиз, так скажем, студии 2019, это версия 16.11, General Availability GA, и там изменений не так много, это всякий hot reload, который мы обсуждали, гид tooling еще немножко улучшился, ну в общем, таких как бы не сильно много важных изменений, и это последний, что важно, это последний, то что они называют "Servicing Baseline", то есть это та версия, которая будет долго-долго-долго поддержана.
4346.72 4372.52 "Игорь Лабутин" Предыдущий "Servicing Baseline" был 16.9, он будет поддержан до октября 2022 года, а вот студия 2019 версия 16.11, по крайней мере пока, Microsoft утверждает, что будет поддерживать ее до апреля 2029 года, то есть еще 8 почти лет, так что не скоро у нас, официально можно еще сидеть на 19-ой студии долго-долго-долго.
4372.52 4382.08 "Игорь Лабутин" Но, конечно, если у вас есть возможность переключаться на 2022, то, наверное, как только она выйдет из превью, по крайней мере, точно можно начинать пользоваться.
4382.08 4384.72 "Игорь Лабутин" А кто-то может и сейчас уже готов.
4384.72 4395.44 "Анатолий Кулаков" Посмотрим, это все-таки такая глобальная переделка, переход на 64 бита, мне кажется, может быть у них там должно что-то отвалиться или не работать, или еще что-то, ну то есть не все так просто должно быть.
4395.44 4403.40 "Игорь Лабутин" Да, несомненно, все отвалится, еще кучу багов им зарепортят, наверняка уже репортят, но будем посмотреть.
4403.40 4410.16 "Анатолий Кулаков" Давай не отходя далеко от наших EDE-шек, от наших любимых студий, я хотел бы еще раз вернуться к ReSharper Ryder 2021.2.
4410.16 4416.64 "Анатолий Кулаков" У меня есть отдельная статья, поэтому вот мы так немножко разнесли их.
4416.64 4436.08 "Анатолий Кулаков" Отдельная статья от Андрея Дятлова, мне кажется, сейчас лучшему спецу по nullable reference type, который есть, потому что это разработчик из команды ReSharper, который вдоль и поперек пролез на nullable reference type и полностью заимплементировал их в ядре как раз этих EDE.
4436.08 4453.04 "Анатолий Кулаков" И он в принципе по праву считает, что nullable reference type - это одна из самых больших и наиболее активно развивавшихся C# фич, то есть ничего сопоставимого по масштабам с нашим языком не происходило.
4453.04 4460.60 "Анатолий Кулаков" Вот и поэтому настолько много времени и мы, и разработчики, и блогеры уделяют этой теме.
4460.60 4476.20 "Анатолий Кулаков" Андрей выпустил статью, в которой рассказал немножко о нововведениях, о последних нововведениях, которые включены в Ryder и ReSharper, и здесь есть ряд интересных наблюдений, вот с которыми я хотел бы вас познакомить.
4476.20 4491.80 "Анатолий Кулаков" Прежде всего нужно помнить, что компания JetBrains давно предоставляет пакет, который называется JetBrains Annotations, в котором мы уже поддерживали с помощью атрибутов вот эту семантику, вот эту концепцию nullable и non-nullable типов.
4491.80 4511.72 "Анатолий Кулаков" И с выходом нового Ryder и нового ReSharper у нас теперь есть QuickFix, который помогает нам трансформировать все вот эти пронатыченные наши классы, трансформировать в новые рослиновские атрибуты, где это возможно естественно, быстро, безболезненно и красиво, с полными гарантиями и так далее.
4511.72 4519.48 "Анатолий Кулаков" Это полезная фича, которая хорошо может спасти Legacy и помочь вам мигрировать на новые nullable референс тайпы.
4519.48 4523.68 "Анатолий Кулаков" Также нужно забывать, что не все всегда можно красиво мигрировать.
4523.68 4527.12 "Анатолий Кулаков" Например, практически ничего невозможно сделать с дженериками.
4527.12 4528.88 "Анатолий Кулаков" С дженериками есть следующая сложность.
4528.88 4543.72 "Анатолий Кулаков" Если вы не проаннотируете свой дженерик тип с помощью вопросика, это значит, что пользователь туда при врантайме, при сконструировании дженерика может передать любой тип, в том числе nullable референс.
4543.72 4549.96 "Анатолий Кулаков" И ваш код, который внутри дженерика, уже будет работать не так, как вы рассчитывали.
4549.96 4551.44 "Анатолий Кулаков" То есть он будет небезопасным.
4551.44 4556.88 "Анатолий Кулаков" Он рассчитывал, что тип неизвестно какой, а передадут туда nullable тип.
4556.88 4562.72 "Анатолий Кулаков" Если же вы проаннотируете дженерик с помощью знака вопросика, то будет все очевидно и понятно.
4562.72 4566.80 "Анатолий Кулаков" Код внутри дженерика будет работать с nullable типом и все будет хорошо.
4566.80 4572.92 "Анатолий Кулаков" Но соответственно у вас нет никакого способа сказать, что дженерик должен быть точно ненулябельным.
4572.92 4575.36 "Анатолий Кулаков" Это никак не поддерживается.
4575.36 4577.72 "Анатолий Кулаков" Поэтому такой случай вы, наверное, смигрировать не сможете.
4577.72 4579.92 "Анатолий Кулаков" То есть никак строго это не указать.
4579.92 4594.24 "Анатолий Кулаков" Но у ReSharper есть ряд анализов, ряд атрибутов, с помощью которых он поможет вам разобраться с этой ситуацией и подскажет, когда что нужно правильно подписывать или трансформировать.
4594.24 4607.60 "Анатолий Кулаков" Другой интересный новый фичей, который касается nullable reference type является поиск всех подавлений предупреждений компилятора.
4607.60 4609.72 "Анатолий Кулаков" Что это значит?
4609.72 4621.04 "Анатолий Кулаков" Очень часто бывает так, что компилятор не способен правильно понять вывод типов, которые есть в вашей программе, особенно если мы говорим про какие-то сложные куски.
4621.04 4628.48 "Анатолий Кулаков" То есть он не способен правильно вывести тип и узнать, нулябельный там у вас получается в итоге тип или ненулябельный.
4628.48 4636.28 "Анатолий Кулаков" В таких случаях очень часто рекомендуют ставить специальный значок, специальный оператор в виде воскресательного знака.
4636.28 4646.00 "Анатолий Кулаков" Этот знак называется nullable warning suppression expression, то есть подавление варнингов, подавление сообщений о нулябельности.
4646.00 4654.40 "Анатолий Кулаков" И этот значок в принципе просто-напросто затыкает компилятор и говорит, чтобы он не рассказывал, не умничал.
4654.40 4658.00 "Анатолий Кулаков" И программист лучше знает, что происходит в данной ситуации.
4658.00 4667.76 "Анатолий Кулаков" Таким образом, когда происходит миграция в вашей программе, вся ваша кодовая база может обрасти вот такими подавлениями, воскресательными знаками.
4667.76 4676.68 "Анатолий Кулаков" И что не очень хорошо, потому что если вы подавляете компилятор, то автоматически вы выключаете все его анализы, автоматически вы запрещаете себе помогать.
4676.68 4682.52 "Анатолий Кулаков" И это как раз-таки тот способ, когда вы легко можете выстрелить себе в ногу.
4682.52 4688.88 "Анатолий Кулаков" Конечно, компилятор должен обязательно на полную катушку вам помогать, в этом и заключается вся мощь строго типизированных языков.
4688.88 4697.28 "Анатолий Кулаков" И в этом заключается вся эволюция вот этих nullable типов и вся эволюция развития рослина и анализаторов и прочего.
4697.28 4701.20 "Анатолий Кулаков" То есть старайтесь максимально в своем коде избегать этих воскресательных знаков.
4701.20 4715.16 "Анатолий Кулаков" К сожалению, когда вы мигрируете, вы вынуждены их расставлять, потому что очень сложные бывают случаи и они не могут в какой-то изолированной среде.
4715.16 4725.16 "Анатолий Кулаков" Невозможно понять, какой здесь будет тип и до тех пор, пока вы не промигрируете до какой-то весь модуль или весь блок, ваш код компилироваться там не будет без warning.
4725.16 4726.92 "Анатолий Кулаков" И поэтому приходится их как-то подавлять.
4726.92 4735.08 "Анатолий Кулаков" Но после этого, когда вы смигрировали какой-то изолированный полноценный блок, обычно эти воскресательные знаки вам больше не нужны.
4735.08 4740.80 "Анатолий Кулаков" Уже начинает работать вот эта вся цепочка строгих типов и там должно быть все хорошо.
4740.80 4747.28 "Анатолий Кулаков" К сожалению, просто так вычленить те воскресательные знаки, которые больше не нужны, было невозможно.
4747.28 4761.60 "Анатолий Кулаков" И вот теперь у нас в ReSharper появилась такая функциональность, которая позволяет найти все ненужные suppression, все ненужные подавления, которые есть в вашем проекте, в вашем скоупе, в вашем файле и удалить их.
4761.60 4768.04 "Анатолий Кулаков" И соответственно позволить компилятору давать вам правильные рекомендации и системе типов работать на полную катушку.
4768.04 4774.20 "Анатолий Кулаков" Ради эксперимента Андрей проверил, а сколько вообще таких воскресательных знаков есть в Rosslyn.
4774.20 4778.80 "Анатолий Кулаков" Не таких, которые не нужны, а вообще, насколько они используются, насколько они распространены.
4778.80 4783.16 "Анатолий Кулаков" И вот в Rosslyn он насчитал 4200 воскресательных знаков.
4783.16 4788.20 "Анатолий Кулаков" С учетом того, что их лучше вообще никогда не использовать, их должно быть в идеальном мире ноль.
4788.20 4794.88 "Анатолий Кулаков" Ну, в не идеальном мире может быть штуки, то здесь 4000 и это в принципе звучит грустно.
4794.88 4798.20 "Анатолий Кулаков" Несмотря на то, что большая их часть в сгенерированном коде.
4798.20 4803.64 "Анатолий Кулаков" Еще интересный был введен новый рефакторинг.
4803.64 4813.04 "Анатолий Кулаков" Опять же, если мы говорим про нулябельные типы, то представьте себе ситуацию, у вас в метод приходит какой-то параметр какого-то определенного типа.
4813.04 4825.04 "Анатолий Кулаков" Этот параметр передается из другого метода, тот метод забирает этот параметр с коллекции, коллекция хранится в свойстве и везде вы вынуждены указывать вот эти типчики, которые там есть.
4825.04 4830.64 "Анатолий Кулаков" А теперь представьте, если бы вы захотели вот этот параметр, который передается в метод, сделать нулябельным.
4830.64 4843.12 "Анатолий Кулаков" Это значит, что вы должны пройти через всю эту цепочку вызовов методов, коллекций, пропертей, классов, в которых это все берется, протягивается и там везде тоже его сделать нулябельным, иначе у вас ничего не скомпилируется.
4843.12 4850.44 "Анатолий Кулаков" Ну или Rosslyn будет выдавать ворнинги, а по-хорошему если у вас включены ворнинги с errors, то компиляции никакой не произойдет.
4850.44 4861.76 "Анатолий Кулаков" Вот, и соответственно для этого, чтобы вот эту всю полную цепочку было чудить не так грустно, был введен новый рефакторинг, который называется просто-напросто change type.
4861.76 4871.18 "Анатолий Кулаков" С помощью change type решарпер может сам изменить вам всю эту цепочку вызовов и поменять где бы этот тип не находился.
4871.18 4882.48 "Анатолий Кулаков" Естественно у вас будет способ это все гибко контролировать, но это миленькое окошечко, в которое вы выберете где надо менять, куда надо пропагидить, где не надо менять, и заменится это все в один клик.
4882.48 4884.96 "Анатолий Кулаков" Безопасно, красиво и удобно.
4884.96 4914.16 "Анатолий Кулаков" Вот, еще одна интересная штука, в последних версиях решарпера и райдера существует такой якобы баг, если вы написали ключевое слово вор, то есть произвольный тип какой-то слева и присваиваете его ненулябельным значением, что вернется допустим из какого-то метода, а потом говорите разверни-ка мне это в настоящий тип, вор все время разворачивался в нулябельный тип.
4914.16 4923.68 "Анатолий Кулаков" Несмотря на то, что допустим метод никогда бы не возвращал вам нулябельный тип, вар все равно развернется именно в нулябельный явный тип.
4923.68 4932.52 "Анатолий Кулаков" Я всегда думал, что это бага, в принципе с нисхождением смотрел на решарпер, на райдер и надеялся, что когда-нибудь в будущем команда это все починит.
4932.52 4947.08 "Анатолий Кулаков" Оказывается из этой статьи это не бага, это на самом деле специальный ленгвич дизайн, так было запланировано, так было задумано разработчиками и если кому-то интересно почему, есть ссылка на пропозл, сходите почитайте.
4947.08 4968.56 "Анатолий Кулаков" Но не это главное, главное в том, что на практике с этим работать было практически нереально, всегда когда происходил какой-нибудь ввод нового поля или декларация какой-то переменной, то есть всегда когда сматериализовался тип, когда нужно было задать его явно, он проставлял там вопросик и приходилось ручкой менять его, в общем это было очень неудобно.
4968.56 4981.68 "Анатолий Кулаков" Теперь же анализатор стал более умный в этом плане и несмотря на рекомендацию всегда использовать nullable типы, когда используется вар, решарпер ходит и пытается найти настоящий тип.
4981.68 4990.92 "Анатолий Кулаков" Если действительно nullable вам никогда не был нужен и никогда не появится, то он все-таки сделает ненулябельную переменную, ненулябельное поле, что очень удобно.
4990.92 4995.48 "Анатолий Кулаков" Вот такие нововведения, которые касаются отдельно nullable reference types.
4995.48 5008.72 "Игорь Лабутин" Прикольно, ну то есть штука действительно полезная, я использую их так в своих личных проектах, мы потихонечку их затаскиваем в основную кодовую базу, но пока не такими большими темпами, как хотелось бы.
5008.72 5021.92 "Анатолий Кулаков" Вот в принципе если вам тема nullable reference types интересная и вы почему-то еще не видели доклады Андрея Дятлова, то обязательно поищите, посмотрите, у него есть шикарные версии и на русском языке, и на английском, какой вам более удобен.
5021.92 5027.12 "Игорь Лабутин" А мы пойдем дальше и поговорим про уже теперь не EDE, а библиотечку.
5027.12 5046.40 "Игорь Лабутин" Мы по-моему в прошлом, кстати, раз упоминали про core WCF или позапрошлый, что вышел релиз, сейчас вышел релиз следующий, это 0.2.0, не то чтобы это прям сильно какой-то супер-супер релиз, но тем не менее, если вы интересуетесь WCF и живете на пятом дотнете или на шестом уже, то вам может быть интересно.
5046.40 5060.24 "Игорь Лабутин" Во-первых, я пробегу и быстренько по изменениям, не буду сильно углубляться, вряд ли сейчас сильно много кто работает с WCF, но тем кому интересно, по крайней мере если услышите знакомые слова, сходите, почитайте.
5060.24 5087.68 "Игорь Лабутин" Во-первых, теперь можно сделать role-based авторизацию на основе нового атрибутика, Authorized Role называется он, и раньше это можно было сделать через principal permission в старом коде, а теперь, соответственно, так нельзя, но зато теперь можно указать Authorized Role, указать туда список ролей из Active Directory и оно будет вполне работать.
5087.68 5092.60 "Игорь Лабутин" На виндах это, собственно, все то, что все будет работать и так, этого достаточно.
5092.60 5109.60 "Игорь Лабутин" На Linux нужно еще дополнительно указать, откуда вообще брать, собственно, все эти доменные данные, то есть указать holdup клиента, настроить через service-credential.windows-authentication.holdup-setting, вкладать туда определенную информацию в holdup-сервер и все будет работать.
5109.60 5129.88 "Игорь Лабутин" Дальше расширили поддержку transport with message-credentials в net-tcp-binding и basic-http-binding, поддержали и 5.net и 3.1, то есть теперь все прям будет хорошо и нормально там.
5129.88 5139.96 "Игорь Лабутин" Добавили чуть-чуть overload в функцию use_net_tcp, там теперь можно указать listening-адрес, то, на чем вы будете слушать.
5139.96 5155.56 "Игорь Лабутин" Раньше, соответственно, вам возвращался всегда только localhost, теперь можно указать конкретный IP-адрес, к которому привязаться, ну и он, соответственно, будет возвращаться вам обратно, чтобы вы знали, на чем вы реально слушаете.
5155.56 5164.16 "Игорь Лабутин" Добавили новый атрибут message-параметра, ну как добавили, сделали его пабликом, по крайней мере, из того, что я вижу из статьи, возможно, он и был раньше.
5164.16 5175.16 "Игорь Лабутин" Если вы используете message-контракт, то вам будет интересно посмотреть, потому что message-параметр позволяет вам переименовывать произвольно то, как это реализуется потом внутри в XML при пересылке.
5175.16 5185.24 "Игорь Лабутин" Это полезно, если вы пытаетесь на WSVF мимикрировать под какой-то SOP-интерфейс, который, возможно, написан не на WSVF и с нужными именами параметров.
5185.24 5191.76 "Игорь Лабутин" То есть просто в коде используете одни property-параметры, а в XML-южисе реализуется совсем другое.
5191.76 5204.64 "Игорь Лабутин" И теперь service-behavior-attribute можно заинжектировать через dependency injection, и это позволяет вам делать singleton-сервисы без приседаний с созданием временных инстансов и прочих таких штук.
5204.64 5220.44 "Игорь Лабутин" Так что потихонечку, потихонечку WSVF обретает какую-то жизнь, пошли релизы, так что не все померло, и, в принципе, можно это использовать вроде как, CoreVCF местами используется даже уже в Prod, из того, что я слышал.
5220.44 5223.04 "Игорь Лабутин" Так что, видимо, там все очень даже неплохо.
5223.04 5229.08 "Игорь Лабутин" Если вас устраивает та часть, которая перенесена на новые технологии, используйте, вполне все работает.
5229.08 5230.08 "Анатолий Кулаков" Отлично.
5230.08 5241.32 "Анатолий Кулаков" А у компании JetBrains вышел ежегодный отчет, который называется "Экосистема разработки" в 2021 году, и я предлагаю напоследок немножко ознакомиться с интересными цифрами.
5241.32 5250.36 "Анатолий Кулаков" Примерно где-то год назад мы обсуждали такой же точно отчет в 11-м выпуске Radio.net, точно такой же отчет за прошлый год.
5250.36 5257.52 "Анатолий Кулаков" Посмотрим, что есть в этом году, что изменилось по сравнению с прошлым годом, и куда двигается наша экосистема.
5257.52 5260.52 "Анатолий Кулаков" Итак, пойдемте по циферкам.
5260.52 5263.48 "Анатолий Кулаков" Какие версии C# вы регулярно используете?
5263.48 5268.72 "Анатолий Кулаков" Такой был вопрос как раз в отчете про C#.
5268.72 5277.36 "Анатолий Кулаков" C# 8 использует 50% опрошенных, C# 7 — 40%, и C# 9 уже адаптировали 30%.
5277.36 5303.28 "Анатолий Кулаков" В общем, экосистема старается держаться довольно-таки новой, большинство продуктов все-таки работает на новых системах, больше половины, даже приближаясь к всяким высоким цифрам, это последние три версии, что очень хорошо, то есть адаптируется к новой фреймворке быстро, проекты мигрируются быстро, и язык развивается довольно грамотно.
5303.28 5312.32 "Игорь Лабутин" Ну, тут ты немножко лукавишь, потому что это мы сейчас говорим о языке, потому что если мы посмотрим на следующий вопрос, то мы увидим, что старый фреймворк еще ого-го.
5312.32 5320.80 "Анатолий Кулаков" Да, к счастью, языки можно менять без изменения фреймворка большинство, поэтому языки должны внедряться в ваши команды намного быстрее.
5320.80 5346.88 "Анатолий Кулаков" Вот с фреймворками, может быть, могут быть проблемы, и они, наверное, есть, в частности, в отчете на .NET Core перешло 66% опрошенных, на большом .NET фреймворке все еще остается 62% всех проектов, пятый .NET фреймворк попробовало 33%, и где-то там внизу, Mono, еще используется в 12% проектов.
5346.88 5355.56 "Игорь Лабутин" Хорошо, а что у нас по технологиям, фреймворкам, там ASP, WinForms умерли, живы, WPF?
5355.56 5382.24 "Анатолий Кулаков" Здесь все живы, все, в принципе, развиваются, места предсказуемы, ASP.NET Core 55% фреймворка используется, 55% случаев, Entity фреймворк в 42%, старенький ASP.MVC еще жив в 38%, WinForms, которые мы потеряли в прошлый раз на месте, никуда не делись, 28% наших любимых десктопных WinForms все еще здесь.
5382.24 5392.80 "Анатолий Кулаков" Razer поднялся до 23%, неплохо, то есть по объему, представляешь, он примерно уже равен WinForms, который существует много-много лет.
5392.80 5395.72 "Анатолий Кулаков" И WPF держится на 22%.
5395.72 5411.84 "Игорь Лабутин" Ну да, на самом деле забавно, что WinForms отряжает WPF, как бы Microsoft никто не пушила WPF, как модно и все такое, все равно WinForms старенький, но все еще модный и вполне практичный, я бы сказал.
5411.84 5417.72 "Анатолий Кулаков" Вот, представляешь, а в следующем году сюда еще вольется MAUI и посмотрим, какая тут уже драка развернется.
5417.72 5419.08 "Анатолий Кулаков" Но Blazer еще должен быть.
5419.08 5426.52 "Анатолий Кулаков" Blazer тот же, да, может тоже подтянется вместе с десктопом, с мобильными своими байнингами и будет еще веселее.
5426.52 5428.52 "Анатолий Кулаков" Ну ладно, давай дальше.
5428.52 5432.04 "Анатолий Кулаков" IDE-шки, тоже интересная ситуация.
5432.04 5442.20 "Анатолий Кулаков" Visual Studio сейчас занимает 62%, то есть больше половины всех опрошенных использует Visual Studio в последневных проектах.
5442.20 5451.28 "Анатолий Кулаков" Здесь интересно учесть, что в прошлом году этот показатель был 65%, то есть минус 3%, какая-то может быть погрешность, но студия потеряла.
5451.28 5460.60 "Анатолий Кулаков" Rider же наоборот, с прошлогодних 20%, а в этом году взлетел до 27%, то есть потихонечку, но стабильненько кажется растет.
5460.60 5464.04 "Анатолий Кулаков" В какой операционной системе программирует наш брат на C#?
5464.04 5477.16 "Анатолий Кулаков" В операционной системе Windows программирует 82% всех разработчиков, в прошлом году было 92%, Windows прям так сильно потеряла, и потеряла она как раз-таки в две следующие системы.
5477.16 5483.60 "Анатолий Кулаков" На Mac OS раньше программировала 14% C# разработчиков, теперь этот показатель 30%.
5483.60 5486.60 "Анатолий Кулаков" На Linux было 7%, теперь 17%.
5486.60 5494.64 "Анатолий Кулаков" То есть кроссплатформенность прям шагает по планете, переманивая не только пользователей, но и даже самих разработчиков, которые там сидят.
5494.64 5500.04 "Игорь Лабутин" Так, ну хорошо, давай теперь про, что у нас такого из общего осталось?
5500.04 5501.04 "Игорь Лабутин" Юнит тесты?
5501.04 5519.44 "Анатолий Кулаков" Да, в юнит тестах тоже у нас сюрприз, раньше у нас с большим отрывом лидировал N-Unit, теперь N-Unit и X-Unit разделят в общем 37% рынка, то есть сейчас они поровну занимают и в принципе чувствуют себя хорошо.
5519.44 5538.84 "Анатолий Кулаков" И один из сюрпризов это MS-Test, MS-Test занимает практически 20% всех тестов, которые используются в проектах, но объяснить это можно тем, что он установлен в студии по умолчанию и в принципе все новые разработчики, которые не подсели еще на какой-то специализированный фреймворк используют MS-Test.
5538.84 5541.80 "Анатолий Кулаков" Вот отсюда такой довольно значительный показатель в процентах.
5541.80 5545.48 "Игорь Лабутин" Прикольно, прикольно, посмотрим, не знаю, как будет жить.
5545.48 5554.88 "Игорь Лабутин" Мне интересно соревнования X-Unit и N-Unit в каком-то смысле, я больше за N-Unit, мне X-Unit как-то не очень нравится, но посмотрим, что скажут массы.
5554.88 5559.80 "Анатолий Кулаков" Вот, я больше приверженец X-Unit, поэтому мы как раз тут с тобой хорошо посоревнуемся.
5559.80 5565.20 "Игорь Лабутин" Ну а что, пусть остальные используют, мы через год посмотрим результаты, мне нравится такое соревнование.
5565.20 5566.20 "Анатолий Кулаков" Именно так.
5566.20 5583.92 "Анатолий Кулаков" Ну что же, C# живет не в каком-то вакууме, разработчики из него приходят, в него уходят, и он общается с другими языками, давайте посмотрим, насколько C# заметен в округе среди других языков.
5583.92 5588.72 "Анатолий Кулаков" Например, на какие языки хотят перейти C# разработчики.
5588.72 5596.36 "Анатолий Кулаков" Многие признались, что хотят перейти на язык Go, это 11%, самый большой показатель перебежчиков.
5596.36 5603.48 "Анатолий Кулаков" На Kotlin посматривают 9%, и 8% C# разработчиков мечтают освоить TypeScript.
5603.48 5611.96 "Анатолий Кулаков" Обратный тренд тоже отслеживается, например, на C# 7% разработчиков хотят перейти из C++.
5611.96 5622.52 "Анатолий Кулаков" В принципе, довольно очевидно, что C++ уже многие годы держит верхнюю строчку, как главный источник перебежчиков на C#.
5622.52 5636.72 "Анатолий Кулаков" Надо признаться, я сам перешел из + на C#, и насколько я знаю, весь дизайн C# и его продвижение задумывалось именно так, чтобы переменить в основном + на этот язык.
5636.72 5643.52 "Анатолий Кулаков" Вот в принципе, это маркетинговая цель, она до сих пор работает, до сих пор действует, 7% все еще собираются переходить.
5643.52 5652.64 "Анатолий Кулаков" С Python на C# придут 5%, и с Java 4%, и с JavaScript тоже планируют перейти 4%.
5652.64 5657.72 "Анатолий Кулаков" Вот такие небольшие какие-то процентики, но посмотрим, что получится на следующем году.
5657.72 5662.00 "Анатолий Кулаков" Вот еще один интересный был вопросик, это популярность языка по регионам.
5662.00 5671.36 "Анатолий Кулаков" Оказывается, самая C# пишущая страна, целых 34% среди всех проектов занимает C# проекты – это Турция.
5671.36 5672.52 "Анатолий Кулаков" Казалось бы, непонятно почему.
5672.52 5684.12 "Игорь Лабутин" Ну, я на такие вопросы обычно отвечаю, почему бы и нет, но действительно, я не сказать, что сильно… Не, ну как, ABP у нас в Турции же, да, живет?
5684.12 5688.92 "Анатолий Кулаков" Ну да, но это, по-моему, единственное, что там есть, что там разрабатывается.
5688.92 5691.96 "Игорь Лабутин" Ну это действительно единственное, о чем слышал я, это правда.
5691.96 5692.96 "Игорь Лабутин" Так что непонятно.
5692.96 5698.12 "Анатолий Кулаков" Мне кажется, уже нужно переводить наш подкаст на турецкий язык и пропагандировать его там.
5698.12 5706.96 "Анатолий Кулаков" Кстати, если кто из Турции и русскоязычный .NET разработчик, напишите, может вам нужно там организовать .NET сообщество или распространить подкаст.
5706.96 5710.68 "Анатолий Кулаков" Мы всегда рады охватить такой большой интересный рынок.
5710.68 5728.56 "Анатолий Кулаков" На голову ниже практически все остальные страны по C# на следующем месте с 18% расположилась Северная Европа и Мексика, в России всего-навсего 15% C# проектов и самый популярный язык в России, в принципе, так же, как и во всем мире, это JavaScript.
5728.56 5730.60 "Игорь Лабутин" Интересно, что в списке нет штатов.
5730.60 5734.08 "Анатолий Кулаков" Штаты есть, он просто не входит в тройку, в ту тройку,
5734.08 5750.28 "Игорь Лабутин" которую я выбрал. Ну я понимаю, да, то есть странно, что место, где собственно живут основные разработчики, да, и казалось, действительно, у нас очень много контента на C# именно приходит из штатов, при этом он там не является такой прям мегапопулярным.
5750.28 5751.28 "Игорь Лабутин" Ну ладно, давай дальше.
5751.28 5761.12 "Анатолий Кулаков" Так, давайте теперь с C# закончим, посмотрим, что вообще творится в этом отчете от JetBrains, как отвечали другие разработчики, что интересного можно вытащить из общего отчета.
5761.12 5765.36 "Анатолий Кулаков" Как я уже сказал, самый популярный язык в мире это сейчас JavaScript.
5765.36 5771.40 "Анатолий Кулаков" Большинство респондентов, а именно 71% занимается разработкой веб-бэкэндов.
5771.40 5783.64 "Анатолий Кулаков" И пять языков, которые разработчики чаще всего планируют изучить или перейти в будущем, в грядущем году это Go, Kotlin, TypeScript, Python и Rust.
5783.64 5794.96 "Анатолий Кулаков" Как мы видим, .NET среди нет, C#, F# здесь нет, более хайповые, какие-то более модные языки здесь лидируют, но посмотрим, посмотрим.
5794.96 5820.72 "Игорь Лабутин" Ну вообще, я понимаю, откуда здесь там Go, Kotlin, TypeScript и Python, они все-таки, ну такие, довольно широкого профиля, но Rust, который довольно-таки узкопрофильный, он все-таки позиционируется как такая хорошая замена C++ для какого-то низкоуровневого программирования, его вон там в ядро Линукса пытаются затащить небезуспешно, выглядит немножко таким, выделяющимся из этого списка.
5820.72 5826.60 "Анатолий Кулаков" Ну здесь нужно подчеркнуть, что это языки, на которые только хотят посмотреть, хотят, планируют перейти.
5826.60 5838.64 "Анатолий Кулаков" А Rust это тот язык уже, который многие-многие годы занимает первые строчки в языках, которые люди хотели бы изучить, но также он занимает первые строчки в языках, которые хотели, но не изучили.
5838.64 5849.96 "Анатолий Кулаков" Поэтому Rust здесь просто стоит как язык такой очень привлекательный, очень интересный, но вряд ли большинство людей как бы на него перейдут, потому что действительно, как ты и сказал, он очень узкоспециализированный.
5849.96 5852.24 "Игорь Лабутин" Но концепции в нем интересные, это правда.
5852.24 5862.80 "Анатолий Кулаков" Да, может быть какие-то языки эти концепции себе затащат, и тогда Rust немножко начнет спускаться на свое место, где ему положено быть, возле плюсов.
5862.80 5863.80 "Игорь Лабутин" Давай дальше.
5863.80 5868.36 "Анатолий Кулаков" Итак, какие языки программирования вы могли бы назвать основными в своей работе?
5868.36 5873.12 "Анатолий Кулаков" Как я уже сказал, первое место JavaScript, это основной язык в принципе везде.
5873.12 5888.16 "Анатолий Кулаков" Второе место занимает Java, дальше идут Python, HTML, PHP, SQL, TypeScript и где-то там в самом почти конце, в самом хвосту прилетелся C# с 12% опрошенных.
5888.16 5895.64 "Анатолий Кулаков" Ответили, что на C# могут назвать основными языки языком для своей ежедневной работы.
5895.64 5898.92 "Анатолий Кулаков" Немного, немного надо признаться.
5898.92 5902.60 "Анатолий Кулаков" Из еще интересных графиков распределение по полу.
5902.60 5907.40 "Анатолий Кулаков" Все-таки мы ждем женщин, где наши женщины, мы хотим больше женщин.
5907.40 5910.80 "Анатолий Кулаков" И лучше всего с этим справляется Южная Корея.
5910.80 5914.88 "Анатолий Кулаков" 13% всех опрошенных женщин как раз у нас из Южной Кореи.
5914.88 5919.52 "Анатолий Кулаков" И следующее, второе место, прочно и уверенно занимает Беларусь.
5919.52 5933.84 "Анатолий Кулаков" У нас 12% женщин, дальше идут Аргентина с 10%, в России у нас 6% женщин и на Украине тоже 6% женщин будем говорить в IT.
5933.84 5935.36 "Анатолий Кулаков" Проучаствовали в этом вопросе.
5935.36 5942.76 "Анатолий Кулаков" В принципе Беларусь молодец, задает тренд вообще всем и вся.
5942.76 5945.96 "Анатолий Кулаков" Скоро даже может быть обогонят Южную Корею.
5945.96 5947.72 "Анатолий Кулаков" Какой язык вы используете в работе?
5947.72 5950.40 "Анатолий Кулаков" Занимается, виду, иностранный язык.
5950.40 5953.72 "Анатолий Кулаков" Лидирует, наверное, это без сюрпризов, английский.
5953.72 5956.96 "Анатолий Кулаков" Английским пользуется 78% на работе.
5956.96 5964.08 "Анатолий Кулаков" Далее идут китайский 20%, японский 9% и русским на работе пользуется всего лишь на всего 5% опрошенных.
5964.08 5967.88 "Анатолий Кулаков" Доля английского языка как рабочего языка по регионам.
5967.88 5972.32 "Анатолий Кулаков" То есть в каком регионе больше всего общаются на английском по работе?
5972.32 5977.00 "Игорь Лабутин" Ну, да, кажется, что я знаю первое место, да?
5977.00 5978.00 "Игорь Лабутин" Это будут Штаты.
5978.00 5980.00 "Анатолий Кулаков" Да, да, с Великобританией вместе.
5980.00 5981.76 "Анатолий Кулаков" В общем, они делят первую строчку.
5981.76 5985.48 "Анатолий Кулаков" Почему-то у них там целых 100% все общаются практически на английском.
5985.48 5986.48 "Анатолий Кулаков" Ну, да ладно.
5986.48 5990.28 "Анатолий Кулаков" Дальше идут Индия, Китай, интересные показатели Украины.
5990.28 5991.76 "Анатолий Кулаков" 90% практически.
5991.76 5997.16 "Анатолий Кулаков" В Беларуси 82% общаются на английском среди всех проектов.
5997.16 6002.44 "Анатолий Кулаков" И в России 71% всех опрошенных проектов общаются на английском языке.
6002.44 6004.96 "Анатолий Кулаков" Мне кажется, как-то слишком высокий процент.
6004.96 6005.96 "Игорь Лабутин" Не думаешь?
6005.96 6019.24 "Игорь Лабутин" Я бы сказал, что, ну, может быть, мы в какой-то другой России, может быть, мы кого-то не того нанимаем, может быть, это действительно все те самые JavaScript, а 12% C#'еров как-то не говорят по-английски.
6019.24 6031.32 "Игорь Лабутин" Я не знаю, но на самом деле есть, ну, по моим ощущениям, есть некоторые проблемы с нами, по крайней мере, англоговорящих.
6031.32 6032.32 "Игорь Лабутин" Хотя может быть, может быть.
6032.32 6034.08 "Игорь Лабутин" Тут есть еще какой-то эффект.
6034.08 6043.68 "Игорь Лабутин" Если я работаю в российской команде, но при этом переписываюсь с английскими заказчиками, ты же будешь считать, что у тебя английский рабочий, хотя при этом говорить ты не сможешь, например.
6043.68 6045.12 "Анатолий Кулаков" Может быть, да.
6045.12 6048.16 "Анатолий Кулаков" То есть может быть вопрос задан не очень корректно.
6048.16 6057.44 "Анатолий Кулаков" То есть если у вас есть в команде англоговорящие сотрудники, то тогда ответ будет, действительно, я общаюсь на английском на работе.
6057.44 6061.80 "Игорь Лабутин" Ну, опять же, мы не всегда говорим, это не всегда нужно.
6061.80 6064.76 "Игорь Лабутин" То есть это у нас, допустим, проект такой, где нужно много именно разговорного английского.
6064.76 6073.00 "Игорь Лабутин" А во многих местах действительно достаточно письменного, и это более чем, это тоже рабочий, хорошая переписка на английском, это тоже умение, тоже надо уметь.
6073.00 6084.52 "Игорь Лабутин" Так что в этом смысле, наверное, все окей, просто если вам нужно, если вы считаете, что у вас 71% кандидатов вокруг умеет английский разговорный, то, наверное, это преувеличение.
6084.52 6089.92 "Анатолий Кулаков" Я бы просто даже не назвал 71%, как английский письменный и в том числе.
6089.92 6098.48 "Анатолий Кулаков" То есть среди моих знакомых доля тех, кто общается на английском ежедневно по работе, письменно, неважно, она намного, намного меньше.
6098.48 6100.48 "Игорь Лабутин" Ну, наверное, да.
6100.48 6104.88 "Игорь Лабутин" То есть, ну, возможно, это специфика опроса.
6104.88 6116.56 "Игорь Лабутин" Опять же, мы видели, что в целом респондентов из России, возможно, не так много, и поэтому, может быть, проценты здесь кажутся довольно большими просто потому, что ответивших было не так много.
6116.56 6118.44 "Анатолий Кулаков" Ну, да, да, ты прав.
6118.44 6124.28 "Анатолий Кулаков" Всего в вопросе проучаствовало около 32 тысяч разработчиков из 183 стран.
6124.28 6131.08 "Анатолий Кулаков" Ну, под разработчиками здесь такое понятие условное, потому что там были и UI-щики, и девопсеры, и тестеры, и все подряд.
6131.08 6134.28 "Анатолий Кулаков" В общем, IT-специалистов будем говорить.
6134.28 6135.28 "Анатолий Кулаков" Пойдем дальше.
6135.28 6137.20 "Анатолий Кулаков" Здесь есть еще парочка интересных цифр.
6137.20 6142.08 "Анатолий Кулаков" Давайте обсудим иммиграцию, то есть куда в основном иммигрируют IT-специалисты.
6142.08 6146.52 "Анатолий Кулаков" На первых местах это Канада, Великобритания и Северная Европа.
6146.52 6148.28 "Анатолий Кулаков" Как ни удивительно, не Штаты.
6148.28 6163.84 "Игорь Лабутин" Ну, может, стало чуть сложнее, может быть, действительно Штаты всё-таки воспринимаются как, не знаю, там именно в Кремниевую долину попасть, и это сложнее, а Канада более такой лояльный в этом плане место.
6163.84 6171.72 "Игорь Лабутин" Ну, а Великобритания, Северная Европа, в общем, понятно, что это всё здесь рядышком, не так далеко от дома, в каком-то смысле, если мы говорим про Россию.
6171.72 6172.72 "Анатолий Кулаков" Да, да, действительно.
6172.72 6182.64 "Анатолий Кулаков" Ну и через Канаду очень удобно попадать в США, поэтому Канада всегда являлась таким хорошим перевалочным пунктом, если вдруг вы там не хотели именно задержаться.
6182.64 6187.96 "Анатолий Кулаков" А следующий пункт – это как раз эмигранты, откуда больше всего уезжают.
6187.96 6197.32 "Анатолий Кулаков" И здесь на первом месте Украина, на втором месте Беларусь и на третьем – Восточная Европа, все остальные дальше.
6197.32 6201.00 "Анатолий Кулаков" Ну, что ж, давай теперь обсудим самое интересное – это зарплаты.
6201.00 6205.60 "Анатолий Кулаков" Вот, прежде всего, самые прибыльные IT-профессии.
6205.60 6213.80 "Анатолий Кулаков" Как оказалось, самые прибыльные – это архитекторы, за ними идут IT-директоры и на третьем месте, вот ни за что не догадаешься – девопсеры.
6213.80 6220.60 "Анатолий Кулаков" Вот эти наши новые администраторы, они, в принципе, очень дорого стоят, оказывается, практически там недалеко от IT-директоров.
6220.60 6222.04 "Игорь Лабутин" Ну, прикольно, да.
6222.04 6224.96 "Игорь Лабутин" Ну, а кубик Кубернета сам себя не настроит.
6224.96 6230.16 "Анатолий Кулаков" Ну, по идее, это средство автоматизации, но он должен сам себя настраивать в идеале, ну что это такое?
6230.16 6231.60 "Анатолий Кулаков" Ну вот, его надо уговорить.
6231.60 6234.76 "Анатолий Кулаков" Теперь давайте пробежимся по циферкам.
6234.76 6240.32 "Анатолий Кулаков" Медианное значение годовой зарплаты в долларах США за вычетом налогов и без учетов бонусов.
6240.32 6249.40 "Анатолий Кулаков" В США по медиане IT-специалисты зарабатывают 102 тысячи долларов в год.
6249.40 6255.56 "Анатолий Кулаков" Я взял на себя смелость, перевел это в рубли месяц и получилось 640 тысяч рублей в месяц.
6255.56 6259.88 "Анатолий Кулаков" Как тебе кажется, Игорь, для штатов это нормальная зарплата?
6259.88 6263.04 "Анатолий Кулаков" Мне кажется, что она показалась очень заниженной, прям сильно заниженной.
6263.04 6267.76 "Игорь Лабутин" Ну, сейчас это получается порядка 8 тысяч долларов примерно в месяц.
6267.76 6271.08 "Игорь Лабутин" Слушай, я так понимаю, что это сильно смотря где жить.
6271.08 6273.72 "Игорь Лабутин" То есть, для Кремниева и Долины, наверное, тут это мало.
6273.72 6278.08 "Игорь Лабутин" Для, возможно, средним по штатам это норм, не знаю.
6278.08 6281.76 "Анатолий Кулаков" Может быть, да, может быть ты прав, что это все-таки медианное.
6281.76 6287.48 "Анатолий Кулаков" Хорошо, ну вот по официальной статистике 100 тысяч баксов в США это типа медианное, это типа хорошо.
6287.48 6288.48 "Анатолий Кулаков" Ну, допустим.
6288.48 6293.84 "Анатолий Кулаков" В принципе, все остальные страны в два раза меньше как минимум получают.
6293.84 6305.32 "Анатолий Кулаков" Например, ближайший конкурент это Канада, 54 тысячи долларов в год, это около 340 тысяч рублей в месяц по курсу где-то 75 рублей за доллар.
6305.32 6310.80 "Анатолий Кулаков" Великобритания на третьем месте, у нее тоже 54 тысячи баксов в год.
6310.80 6321.20 "Анатолий Кулаков" На Украине получается 27 тысяч долларов в год или примерно 170 тысяч рублей на медианного IT специалиста.
6321.20 6328.44 "Анатолий Кулаков" В Белоруссии меньше, 21 тысяча в год или 131 тысяча рублей в месяц.
6328.44 6331.40 "Анатолий Кулаков" И в России также 131 тысяча рублей в месяц.
6331.40 6336.64 "Игорь Лабутин" Ну, блин, сложно, конечно, так, знаешь, это медианное в среднем по IT, ну, как бы.
6336.64 6342.20 "Анатолий Кулаков" Да, к сожалению, сюда всплели всех, но более детальной выборки нет.
6342.20 6356.48 "Игорь Лабутин" Ну, видно, что на самом деле есть некая, возможно, корреляция, что на Украине зарплаты побольше, и английский там побольше, потому что, видимо, больше работают с заграницей, и, соответственно, ставки повыше, чем с внутренними проектами.
6356.48 6358.04 "Игорь Лабутин" За счет этого получается платить больше.
6358.04 6370.40 "Анатолий Кулаков" Ну, в целом нужно признаться, что если вы в IT-индустрии, то прежде всего вам повезло, потому что и цены, и зарплаты, и жизнь здесь, безусловно, намного лучше, чем в окружающем мире вне IT.
6370.40 6371.96 "Анатолий Кулаков" Поэтому все хорошо.
6371.96 6379.88 "Игорь Лабутин" Ну и на этой замечательной ноте, радостной ноте того, что мы в IT, давай потихонечку завершаться.
6379.88 6388.80 "Игорь Лабутин" Сегодня мы поговорили про .NET 6 Preview 7, все, что там завезли в самом .NET, в ASP.NET Core, в MAUI и куча всяких мелочей и ништяков.
6388.80 6395.96 "Игорь Лабутин" Затронули большую новую фичу в 6.0 .NET, это генерик математика и статически абстрактные методы интерфейсов.
6395.96 6430.12 "Игорь Лабутин" Поговорили про новинки String Interpolation в 10.0 C# и 6.0 .NET, обсудили новенькие фичи нового ReSharper и Ryder, затронули на Label Reference Type поддержку в новом ReSharper и Ryder, поговорили что нового в студии 2022 Preview 3, а также 2019 последний релиз 16.11, затронули Core WCF 0.2.0 и обсудили результаты опроса JetBrains на тему вообще экосистемы разработки и что думают разработчики о разных аспектах своей жизни.
6430.12 6439.36 "Анатолий Кулаков" Слушайте нас, рассказывайте своим друзьям, шарьте в социальных сетях, 5 звездочек, колокольчики, подписки, это все вы и так знаете.
6439.36 6449.36 "Анатолий Кулаков" Ждем уже комментариев о работе подкаста, что улучшить, что ухудшить, где подробнее, про что рассказать, какие темы вам бы хотелось интересно услышать.
6449.36 6451.56 "Анатолий Кулаков" В общем мы рады любому фидбэку.
6451.56 6458.72 "Анатолий Кулаков" Заходите в любые наши социальные сети, связывайтесь с нами и рассказывайте любые ваши мысли относительно подкаста.
6458.72 6462.28 "Анатолий Кулаков" Огромное спасибо всем слушателям и пока, до новых встреч.
6462.28 6464.80 "Игорь Лабутин" А это был 34 выпуск, всем пока.
