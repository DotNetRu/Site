0.00 14.40 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет выпуск номер 56 и в студии, как всегда, Анатолий Кулаков.
14.40 16.44 "Игорь Лабутин" И Игорь Лабутин, всем привет.
16.44 23.80 "Анатолий Кулаков" Пора просыпаться после летних каникул, давно мы с вами не виделись, накопились новостей, сейчас обсудим, что у нас здесь интересного происходит.
23.80 31.08 "Анатолий Кулаков" Но для начала хотелось бы поблагодарить наших постоянных помогаторов, которые всегда с нами, всегда поддерживают, и большое им спасибо.
31.08 37.44 "Анатолий Кулаков" В частности, Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья и Гурий Самарин.
37.44 40.80 "Анатолий Кулаков" Спасибо, друзья, спасибо, что с нами, спасибо, что поддерживаете наш подкаст.
40.80 62.52 "Анатолий Кулаков" А если вы не знаете, о чем мы сейчас говорим, то пройдите на сайт Бусти, его ссылочку вы найдете в описании к любому нашему выпуску, в комментариях, и там посмотрите, что у нас интересного есть для наших платных подписчиков, в том числе закулисные выпуски, и интересные чатики, и прочее-прочее всего интересного.
62.52 71.20 "Анатолий Кулаков" Так, наверное, с официальной частью все, все порекламировал, все пообещал, а теперь давай приступим непосредственно к темам.
71.20 77.24 "Анатолий Кулаков" И темы у нас не то, чтобы совсем новые, не то, чтобы совсем старые, а вот что-то такое новенькое, как горбунка.
77.24 82.72 "Анатолий Кулаков" У нас внезапно зарелизился старый, большой, толстый, жирный, любимый нашим и древний .NET Framework.
82.72 84.48 "Анатолий Кулаков" Что случилось, Игорь?
84.48 94.76 "Игорь Лабутин" Действительно, это тот релиз, которого, ну, наверное, вряд ли ждешь после, там, каникул, хотя мы про него немножко говорили и анонсировали, что он будет.
94.76 97.68 "Игорь Лабутин" Действительно, зарелизился .NET Framework 4.8.1.
97.68 106.08 "Игорь Лабутин" Это такой, ну, хотфикс-хотфикс, можно сказать, но он не просто так появился, он появился из-за новых фич.
106.08 126.40 "Игорь Лабутин" Да, надо сказать, что он доступен в Visual Studio 2022.17.3, мы про нее сегодня немножко поговорим, и он доступен, его можно загрузить отдельно для любой Windows 10, начиная с 20.h2+, ну, то есть, второй половинка 2020 года, или Windows Server 2022 и новее.
126.40 128.00 "Игорь Лабутин" Так вот, новые фичи.
128.00 136.12 "Игорь Лабутин" Там есть одна самая главная фича, ради которой, я так понимаю, все затевалось, это нативная поддержка сборки по ARM64 и работы.
136.12 155.20 "Игорь Лабутин" То есть, теперь, если вы берете какой-нибудь современный Windows 11, на нее можно поставить .NET Framework 4.8.1, 11-я версия может запуститься на ARM64, и после этого радостно будет работать там, а .NET Framework позволит вам там все компилить и запускать ваши .NET-приложения.
155.20 157.52 "Игорь Лабутин" Это самое главное, ради чего это делается.
157.52 162.20 "Игорь Лабутин" Но кроме этого, там есть, заодно туда запихнули еще парочку фич.
162.20 173.12 "Игорь Лабутин" Во-первых, это изменения по accessibility, то есть, WinForms и WPF — это, в общем-то, давно проверенные и работающие фреймворки для десктопного UI.
173.12 182.52 "Игорь Лабутин" И Microsoft не то чтобы стремится, но старается быть в тренде с точки зрения современных норм и подходов к accessibility.
182.52 188.32 "Игорь Лабутин" И выкатила два апдейта, одно для WinForms, другое для WPF, в частности, ToolTips.
188.32 195.40 "Игорь Лабутин" То есть, ToolTips вообще себя ведут обычно, ну, всем известно, как на винде, да, вы мышки наводите, там появляется ToolTip.
195.40 198.72 "Игорь Лабутин" Потом, куда бы мышку не дернули, ToolTips сразу исчезает.
198.72 206.64 "Игорь Лабутин" Хотя по нормам современным он тоже не исчезает, на него должно быть можно навести мышь, там, ну, в общем, ради всяких скрин-ридеров и так далее.
206.64 208.00 "Игорь Лабутин" Ну, в общем, вот это сделали.
208.00 220.80 "Игорь Лабутин" Теперь и в WinForms, правда, только на Windows 11, и в WPF, и на десятке, и на одиннадцатой версии будет нормально работать в соответствии с современными нормами accessibility, если вы используете Framework 4.8.1.
220.80 223.40 "Игорь Лабутин" В общем-то, все, ничего другого там нету.
223.40 229.76 "Игорь Лабутин" Ну, возможно, какие-то security fix, конечно, есть, но security fix довольно регулярно выходит и на старой 4.8.
229.76 236.16 "Игорь Лабутин" Так что, если вы используете 4.8, то можно смело обновиться и дальше использовать все прелести последнего фреймворка.
236.16 241.52 "Анатолий Кулаков" Ну, а дальше задумайтесь о том, чтобы все-таки эмигрировать на Core, потому что он семимильными шагами двигается.
241.52 248.24 "Анатолий Кулаков" Мы практически в каждом выпуске обсуждаем новую превьюшку DotNet 7, и этот выпуск, естественно, не станет каким-то исключением.
248.24 252.00 "Анатолий Кулаков" Более того, у нас уже успело выйти две превьюшки.
252.00 256.72 "Анатолий Кулаков" Ну, начнем мы, соответственно, с превью 6, чтобы не сбивать отчетностей.
256.72 263.60 "Анатолий Кулаков" Как показала практика, намного легче обозревать именно фичи, которые внедряются постепенно.
263.60 268.76 "Анатолий Кулаков" У нас и больше времени их обсудить, и больше времени, чтобы их как-то опробовать и обкатать.
268.76 279.92 "Анатолий Кулаков" И, соответственно, чем мы потом во время релиза замахиваемся на все то, что напрограммировали друзья из Дотнета, и там, конечно, объятное-необъятное в любом случае у вас не получится.
279.92 283.96 "Анатолий Кулаков" Поэтому продолжаем обсуждать, что нового происходит, маленькими шагами, постепенно.
283.96 287.56 "Анатолий Кулаков" И у нас на очереди DotNet 7, превью 6.
287.56 292.24 "Анатолий Кулаков" Прежде всего сюда добавили Type-конверторы, которые для новых типов.
292.24 302.52 "Анатолий Кулаков" Я напомню, что там появились новые типы, ну, сравнительно уже новые, Date-only, Time-only, Int-128, Unsigned Int-128 и Half.
302.52 305.56 "Анатолий Кулаков" Для них раньше не было Type-конверторов, а теперь они появились.
305.56 315.36 "Анатолий Кулаков" Я напомню, что Type-конверторы - такая прекрасная штука, которая помогает вам как минимум из строчки и в строчку перегонять практически любой встроенный примитивный тип.
315.36 319.44 "Анатолий Кулаков" Ну, примитивный точно любой, но и большинство еще не только примитивных в Дотнете поддерживают Type-конверторы.
319.44 330.84 "Анатолий Кулаков" Прекрасная штука, особенно если вы хотите их получать в виде аргументов из ISP-нет-контроллеров, или хотите сохранять куда-нибудь в базу данных, или вот прочее где-нибудь сериализовать.
330.84 338.72 "Анатолий Кулаков" В общем, отличная вещь, многие фреймворки, соответственно, с ними пользуются и приятно, что поддерживают полноту Type-конверторов.
338.72 346.44 "Анатолий Кулаков" То есть новые типы у нас тоже станут полноценными членами Identity Framework, и JSON-сериалайзера, и ISP-нета, и прочих вещей.
346.44 358.20 "Анатолий Кулаков" Еще интересно, расширили JSON-контракт Customization, то есть это способ, с помощью которого вы можете описывать какую-то кастомную сериализацию.
358.20 369.28 "Анатолий Кулаков" Допустим, очень часто у вас в коде используются классы, которые поставляются третисторонними библиотеками, и вы, например, не можете их изменить, а очень хочется как-то кастомизировать их сериализубельность.
369.28 375.20 "Анатолий Кулаков" То есть каким образом они там запишут свои свойства, как назовут свои имена, как типы преобразуют, вот это все.
375.20 389.92 "Анатолий Кулаков" И в самых безнадежных ситуациях, конечно, приходится писать фрапперы или отдельные классы и перемапливать туда данные, но если сериализатор гибкий, он позволяет настраивать абсолютно любые классы, даже не модифицируя их, не навешивая никакие атрибуты.
389.92 398.84 "Анатолий Кулаков" И естественно, System.js претендует на всепоглощающую гибкость, поэтому у него тоже появляются больше и больше всяких методов для кастомизации.
398.84 407.32 "Анатолий Кулаков" И одна из самых таких массивных, мощных точек расширения – это JSON Serialization Options TypeInfoResolver.
407.32 427.88 "Анатолий Кулаков" Специальный класс, который предоставляет абсолютно всю метаинформацию о типе, то есть как он будет сериализоваться, какие свойства у него есть, какого они типа, как их получить, как их считать, как значения записать, все это он знает и, соответственно, все это вы можете как разработчик, как программист поменять, модифицировать, сконвертировать, подстроить под себя.
427.88 446.48 "Анатолий Кулаков" Обычно дефолтным поведением является использование как раз-таки класса, который называется DefaultJSONTypeInfoResolver, который дает стандартное дефолтное поведение, и его немножко под свои нужды можно как-нибудь закастомизировать, выставить кастомные сеттеры, переименовать свойства и так далее.
446.48 460.36 "Анатолий Кулаков" Если же вам обычного дефолтного маловато, вы можете реализовать свой интерфейс, JSONTypeInfoResolver, и в этом интерфейсе уже творить полный беспредел, издеваться над бедными объектами, как только сможете, и здесь ограничено только все вашей фантазией.
460.36 471.76 "Анатолий Кулаков" В частности, появилась интересная штука, это JSONPropertyInfo, это специальный класс, который полностью описывает то, каким образом сериализатор будет работать с свойством, с property.
471.76 480.36 "Анатолий Кулаков" В частности, вы можете поменять любое имя, вы можете кастомизировать их в Getter, как это значение из этого property будет считаться, Setter и так далее.
480.36 495.04 "Анатолий Кулаков" Например, вы легко можете взять свойство, которого нет в коде, которого нет в вашем классе, создать ему JSONPropertyInfo, и с помощью сеттеров и Getter кастомных, например, считать значение из какого-то метода и записать его в какой-то метод.
495.04 500.08 "Анатолий Кулаков" А в JSON это будет выглядеть как обычное свойство с обычным варью, никто даже ни о чем не догадается.
500.08 502.16 "Анатолий Кулаков" Вот такие веселые штуки можно творить.
502.16 510.84 "Анатолий Кулаков" Естественно, у нас еще очень сильно не хватало еще одной замечательной штуки, метода ShootSerialize.
510.84 518.72 "Анатолий Кулаков" Это специальный метод, который динамически может определять, нужно ли сериализовать свойство или не нужно.
518.72 539.40 "Анатолий Кулаков" В обычной жизни нам хватает JSONIgnoreAttribute, если мы просто свойства никогда не хотим сериализовать, или же все-таки JSONIgnoreAttribute вместе со специальным менюмчиком, который называется JSONIgnoreCondition, который определяет, когда нужно игнорировать какое-то поле.
539.40 545.20 "Анатолий Кулаков" Например, очень часто во время сериализации, во время записи данных игнорируют дефолтные поля.
545.20 552.88 "Анатолий Кулаков" Допустим, если у вас там в объектах хранится null, то никакого смысла в это писать в JSON нет, зря только засовываете объект.
552.88 557.96 "Анатолий Кулаков" Или если там нолик у вас в int-овых полях, то такое свойство тоже можно не писать.
557.96 564.24 "Анатолий Кулаков" И вот эти два свойства помогают вам настроить вот это поведение.
564.24 568.88 "Анатолий Кулаков" Здесь же бывают намного более сложные ситуации.
568.88 575.48 "Анатолий Кулаков" Например, что если вам не нужно писать коллекцию, записывать коллекцию, если вдруг в ней нет ни одного элемента.
575.48 577.48 "Анатолий Кулаков" В общем, вы не хотите писать там пустые коллекции.
577.48 585.40 "Анатолий Кулаков" Или что если вы хотите записать информацию о пользе, фамилию пользователя, только если ему больше 18 лет, что-нибудь такое.
585.40 593.36 "Анатолий Кулаков" И на этот случай в старых добрых сериализаторах были магические методы, которые назывались ShootSerialize.
593.36 598.76 "Анатолий Кулаков" Магические они потому, что нигде вообще никак не декларировались, никак не учитывались и непонятно было, как они вызывались.
598.76 607.40 "Анатолий Кулаков" Вы просто объявляете ShootSerialize и имя, свойство, которое вы хотите таким образом записать или не записать, и оно магически работало.
607.40 613.80 "Анатолий Кулаков" В общем, практически эту практику поддержал новый систем тех JSON, но насколько я понимаю, у него там никакой магии нет.
613.80 618.60 "Анатолий Кулаков" Здесь вы все явно объявляете, все явно предикаты передаете, за что ему отдельное спасибо.
618.60 622.20 "Анатолий Кулаков" Как бы от магии избавляемся, но мощной функциональности не теряем.
622.20 628.12 "Анатолий Кулаков" Вот, это в принципе все из главного, что касается улучшений в JSON-сериализаторе.
628.12 631.32 "Анатолий Кулаков" Естественно там генераторы, performance, improvements и все такое.
631.32 641.00 "Анатолий Кулаков" Из еще интересного, что мне попалось на глаза, это обновили, улучшили новый тип архиватора.
641.00 649.80 "Анатолий Кулаков" Теперь в стандарте Дотнета поддерживается TAR-архивы, то есть у нас есть API, с помощью которых мы можем писать, читать и вообще манипулировать любым образом с TAR-архивами.
649.80 660.60 "Анатолий Кулаков" Эта функциональность появилась в превью 4, не в этом, но просто в этом нам лишний раз напомнили, что они улучшили, а я сам для себя лишний раз открыл, что интересный факт, в Дотнете теперь поддерживаются TAR-ы.
660.60 667.16 "Анатолий Кулаков" Это очень популярный формат архива в Линуксе, такой не то чтобы совсем архив, но в общем специфичный довольно формат.
667.16 678.04 "Анатолий Кулаков" В Линуксе практически все раньше распространялось, и вообще это единственный был очень общепризнанный стандарт между всеми дистрибутивами по распространению каких-то файлов.
678.04 692.56 "Анатолий Кулаков" Сейчас он в принципе уже более или менее не так распространен, но историчность его очень большая, легаси в него очень большое, поэтому я думаю все еще он захватывает, как бы занимает большую долю рынка среди всех архиваторов.
692.56 697.84 "Анатолий Кулаков" То есть тоже есть такая штука, тоже интересно об этом помнить.
697.84 705.32 "Анатолий Кулаков" Из .NET Tool, у нас .NET Tool тоже продолжает развиваться, добавили в темплейты Constraints.
705.32 712.00 "Анатолий Кулаков" А помню, что .NET Tool это .NET.EXE, специальная консольная утилитка, с помощью которой вы можете творить очень многое.
712.00 715.04 "Анатолий Кулаков" В частности, вы можете создать пустой проект.
715.04 724.52 "Анатолий Кулаков" Вот вы захотели какую-то новую консольку, написали .NET.NEW на консоль, и он вам создал там MVC, Razer, VBSM, или что угодно.
724.52 729.00 "Анатолий Кулаков" Указали, темплейтов очень много, они распространяются через Nuget, постоянно расширяются, добавляются.
729.00 734.92 "Анатолий Кулаков" Очень удобная штука, но очень часто бывает неудобно, особенно когда вы долго пользуетесь этой утилитой.
734.92 754.44 "Анатолий Кулаков" Когда вы пытаетесь найти тот шаблон, который вам нужно, который уже или забыли как пишется, или он немножко не из стандартных, и нужно как-то более правильное имя у него узнать, вы обычно вызываете команду .NET List, которая вываливает вам огромный список всех шаблонов, которые у вас установлены, и там уже становится сложно ориентироваться.
754.44 758.40 "Анатолий Кулаков" Это какие-то уже фильтры, какие-то кондишены, какое-то еще что-то.
758.40 761.48 "Анатолий Кулаков" И вот как раз кондишены у нас и появились.
761.48 773.04 "Анатолий Кулаков" Это такая штука, которая позволяет вашей .NET LZ узнать, в каком окружении она запускается, и соответственно подобрать только те команды, которые вам сейчас нужны.
773.04 794.52 "Анатолий Кулаков" Например, если мы сейчас смотрим, выводим список шаблонов, которые установлены в вашей системе с помощью команды .NET List, .NET NEW List, эта команда может посмотреть, что какая у нас операционная система стоит, где мы вообще запускаем это, из консольки, из студии или из браузера, какие у нас сейчас в студии установлены ворклоуды.
794.52 802.28 "Анатолий Кулаков" Я напомню, что студия пытается себя облегчить, она распространяет там, грубо говоря, только оболочку, а всякую полезную нагрузку доставляет отдельно.
802.28 808.48 "Анатолий Кулаков" Например, если вам не нужна UIK, если вам не нужна SP, если вам не нужен Blazor, то это все можно абсолютно не ставить.
808.48 826.08 "Анатолий Кулаков" И, соответственно, если у вас .NET NEW List видит, что никакой ворклоуд в Asm.Tools у вас в студии не установлен, то есть вы не собираетесь программировать на Blazor и в WebAssembly, то она вам даже не покажет шаблоны, которые включают себя в WebAssembly.
826.08 834.76 "Анатолий Кулаков" То есть вы их просто даже не увидите, и, соответственно, ваш лист будет всегда актуальным, чистым, красивым, и, соответственно, легче будет вам там ориентироваться.
834.76 845.60 "Анатолий Кулаков" Вот, наверное, главное, что интересно было в этом релизе, естественно, множество оптимизаций, новые генераторы, рантайм оптимизации и прочие-прочие вещи.
845.60 851.04 "Анатолий Кулаков" Это вот с каждым новым премью нас ждут, и их обсуждать не очень интересно.
851.04 856.68 "Анатолий Кулаков" Ну, что касается основного .NET, основного рантайма языка, это, наверное, пока все.
856.68 865.04 "Игорь Лабутин" Ну и, конечно же, вместе с основным .NET пришли новинки в SPNET и NST Framework, и про них тоже надо поговорить.
865.04 889.68 "Игорь Лабутин" В SPNET у нас давным-давно была штука под названием Response Compression Middleware, то есть вы могли написать Use Response Compression, и в случае, если в реквесте в Accept header'ах было помечено, что, допустим, клиент понимает какой-то такой Gzip или там Deflate или что-нибудь еще, то Middleware, она компрессировала ваши респонсы.
889.68 908.76 "Игорь Лабутин" Теперь есть, соответственно, симметричная, появилась она, называется Request Decompression, и если к вам приходит реквест, который уже закомпрессирован с помощью Gzip, Proc или Deflate, определяется это с помощью Content Encoding заголовка, то тогда такой реквест будет понят и нормально, так сказать, распакован.
908.76 921.40 "Игорь Лабутин" Так что теперь наш сервер стал еще более совместим с клиентами, хотя я, ну, наверное, не очень много реквестов таким образом приходят, но если вам действительно плодят какие-то большие JSON, например, то такая штука вполне полезна.
921.40 924.40 "Игорь Лабутин" Дальше появилось кэширование.
924.40 930.04 "Игорь Лабутин" У нас довольно много кэширования в Дотанете внутри, всякие рэйплы, там, мемори кэши.
930.04 932.24 "Игорь Лабутин" Теперь появилось кэширование респонсов.
932.24 944.24 "Игорь Лабутин" Вам нужно там, где вы конфигурируете ваши сервисы, ну, Service Collection вызвать метод Add Output Cache, в секции, где вы конфигурируете Middleware, позвать Use Output Cache, как обычно.
944.24 955.60 "Игорь Лабутин" Ну и дальше для каждого endpoint, который вы хотите кэшировать, результат, который вы хотите кэшировать, нужно вызвать экстенджерный метод Cache Output, и вот туда есть возможность передать всякие опции.
955.60 969.88 "Игорь Лабутин" Что нужно, например, кэшировать, держать различные кэши в зависимости от Query Option или в зависимости от каких-нибудь хедеров, или просто вообще в зависимости от какого-то кастомного выражения или значения, которое вы туда передадите.
969.88 1003.32 "Игорь Лабутин" Так что стало возможным это делать, плюс Microsoft утверждает, что там довольно умный алгоритм кэширования, и, например, если у вас что-то в кэше протухло и очень много реквестов, ну, а ваш сервис высоконаруженный, то понятно, что как только протухнет какая-то запись в кэше, а за ней все пришли, то вроде как получается, что пока первый реквест не обработается, в кэше все еще ничего нет, и поэтому все реквесты, пришедшие в этот период, будут, по идее, делать бесполезную работу, потому что дальше закэшируется только один результат и все.
1003.32 1014.24 "Игорь Лабутин" И они там сделали какой-то умный алгоритм, который, значит, поставит остальные реквесты в очередь, они дождутся, когда первый реквест посчитает закэшированные значения, все вернут из кэша, ну, короче, там все говорят умно.
1014.24 1022.08 "Игорь Лабутин" Но что мне не очень понравилось, это то, что все примеры в статье, и на самом деле даже все официальные примеры в реквизиторе, они все только на minimal API.
1022.08 1027.24 "Игорь Лабутин" То есть, например, что делать, если я хочу кэшировать результаты контроллеров, я не понял.
1027.24 1030.28 "Игорь Лабутин" Там вроде как extension метод писать не к чему.
1030.28 1038.84 "Игорь Лабутин" Надо изучать, смотреть, возможно, действительно этого просто нету, а возможно Microsoft теперь всеми силами продвигает свой minimal API и писать надо только так.
1038.84 1041.48 "Игорь Лабутин" Ну, это было бы грустно, мне кажется, да.
1041.48 1063.00 "Игорь Лабутин" Да, ну, надеюсь, что все появится, понятно, что все это, поскольку это extension метод, это значит, что это просто добавление какого-то правильного, не знаю, фильтра, скорее всего, поверх респонсии, это значит, что в контроллерах это тоже можно сделать, какой-нибудь там тоже фильтр на респонс повесить и все будет делаться, но интересно, интересно посмотреть.
1063.00 1073.36 "Анатолий Кулаков" Ну, похоже, это какими-то action result'ами будет, наследник от action result, который тебе делает какую-то обертку, и ты, соответственно, кэширующий middleware, можешь эту обертку посмотреть и распаковать в твой объект.
1073.36 1079.76 "Игорь Лабутин" Да, наверное, то есть без middleware не обойтись, потому что action result не позволит тебе обрабатывать реквест.
1079.76 1087.40 "Игорь Лабутин" Вот, это должно быть действительно где-то на уровне middleware либо фильтра, в контроллере уже тоже свои фильтры есть, которые и на реквест смотрят, и на респонс.
1087.40 1094.76 "Анатолий Кулаков" Я думаю, да, но фильтры это уже термины MVC, а если мы говорим про минимум API, мне кажется, там даже никакой MVC не пахнет, то есть скорее всего, все равно это в тварях
1094.76 1096.76 "Игорь Лабутин" сделано. Ну да, скорее всего, middleware, да.
1096.76 1105.44 "Игорь Лабутин" В общем, вот, в любом случае кэширование есть, если вы задумывались о кэшировании или как-то его реализовывали сами, то теперь вот есть реализация от Microsoft, туда можно подсмотреть.
1105.44 1117.92 "Игорь Лабутин" Дальше добавили апдейты, мы уже рассказывали про то, что у нас есть rate limiting middleware, которое позволяет как-то ограничивать частоту запросов, которые обрабатывает ваше приложение.
1117.92 1130.28 "Игорь Лабутин" Теперь появилась возможность делать индивидуальные настройки по endpoint, то есть можно иметь какой-то глобальный rate limiter и плюс на отдельный endpoint еще свои локальные rate limiter со своими правилами.
1130.28 1132.40 "Игорь Лабутин" Более гибко подходить к этому.
1132.40 1151.16 "Игорь Лабутин" Дальше кестре у нас развивается, понятно, что там есть куча улучшений перформанса на многоядерных машинах, при этом когда мы говорим многоядерные, то они в статье приводят пример, ну берем, например, обычную виртуалку в ажуре с 80 ядрами и вот там были какие-то большие проблемы с concurrent queue, теперь их нет.
1151.16 1157.80 "Игорь Лабутин" Наверное, у нас не каждый использует 80-ядерные машинки, но в принципе, почему нет, в продакшене вполне может быть.
1157.80 1165.28 "Игорь Лабутин" Тем более, что кэстрел теперь у нас, мне кажется, все больше и больше и больше развивается.
1165.28 1188.72 "Игорь Лабутин" Они, короче, теперь поддержали веб-сокеты поверх HTTP/2 и это, как они сказали, позволило им выкинуть, наконец-таки, IS из ажурной инфраструктуры, ну весь не весь, не знаю, но утверждается, что теперь, короче, ажурные App-сервисы не используют IS, а используют как раз-таки кэстрел и ну и все.
1188.72 1201.12 "Игорь Лабутин" Или с Nginx, или с YARP, конечно же, как я мог предложить Nginx, у Microsoft есть YARP, соответственно, теперь, типа, вместо IS, Nginx плюс IS используется YARP плюс прямой кэстрел.
1201.12 1204.72 "Игорь Лабутин" Это прям performance boost, performance boost и все такое.
1204.72 1205.72 "Игорь Лабутин" Наверное, круто.
1205.72 1211.68 "Анатолий Кулаков" Ну интересно было бы на цифрке, конечно, посмотреть, может быть, команда ажуры или хотя бы Bingo поделится статейчики.
1211.68 1234.52 "Игорь Лабутин" Там есть какие-то небольшие цифрки в статье, и может быть, даже есть какие-то ссылки, поэтому почитайте основную статью, скорее всего, они сейчас любят много чего переводить, и все это делается, много чего на GitHub, поэтому ажур, конечно, не на GitHub, но изменение рантайма, которое приводит к изменению скорости ажур, я так понимаю, иногда публикуются, ну, в репе рантайма, ESP NAT.
1234.52 1235.52 "Игорь Лабутин" Дальше.
1235.52 1244.72 "Игорь Лабутин" И в V3C-логере добавилась некоторая возможность логировать хедеры, если надо.
1244.72 1252.16 "Игорь Лабутин" В Blazor появились улучшения, но в основном они такие датаносные косметические, хотя, тем не менее, интересные.
1252.16 1267.04 "Игорь Лабутин" Во-первых, теперь можно сгенерить пустой Blazor проект, причем как сервер-сайт Blazor, так и Blazor в VBSMLE, там не будет никакого bootstrap, вообще ничего, то есть просто голый VBSMLE, условный hello world, дальше используйте, что хотите сами внутри, мы ничего не навязываем.
1267.04 1284.36 "Игорь Лабутин" Для Blazor же потихонечку улучшается криптография, в VBSMLE теперь поддержаны все вариации SHA, то есть SHA-1, SHA-256, SHA-384, SHA-512 и HMAC в соответствующей версии.
1284.36 1306.20 "Игорь Лабутин" И немножко забегая вперед, в превью 7, соответственно в следующем превью будет еще поддержан IES, PBGDF2 и HKEF, это на самом деле специальные хэши и алгоритмы, в том числе для нормальной генерации паролей, насколько я понимаю, вот по-моему PBGDF2 это один из парольных хэшей, хотя я могу ошибаться.
1306.20 1316.20 "Игорь Лабутин" В Blazor добавили новый QuickGrid компонент, причем она прямо experimental-experimental, но говорят, что это супербыстро и удобно, надо смотреть.
1316.20 1335.52 "Игорь Лабутин" Мы, по-моему, в прошлый раз рассказывали про новую фичу под названием gRPC JSON-транскодинг, то есть если у вас есть gRPC endpoint, то их можно выставить автоматически в качестве REST-эндпойнтов, ну и для этого, естественно, требуется некоторое транскодирование из JSON-ов gRPC и обратно, ну в Pertabuf.
1335.52 1350.52 "Игорь Лабутин" И вот эта как раз-таки штука теперь тоже улучшилась, расширилась, углубилась, она работает быстрее, она понимает больше паттернов и, в общем, еще лучше ваши gRPC-шные API-шки будут выставлять наружу как REST, ну или таки REST-like.
1350.52 1376.24 "Игорь Лабутин" Ну и последнее, мы, по-моему, два превью назад, если я правильно помню, рассказывали, что появилась такая фича под названием endpoint groups, то есть когда вы не просто пишете map-get, map-get, map-get, да, если вы пользуетесь minimal API, а вы пишете map-group, и, допустим, вы можете в группы указать общий префикс для пути, а потом уже внутри делать под какие-то маршруты уже в рамках этой группы.
1376.24 1384.32 "Игорь Лабутин" Так вот, теперь на этой map-группе можно создать еще больше разных общих свойств, типа там общая авторизация, типа общая аутентификация и так далее.
1384.32 1390.32 "Игорь Лабутин" Так что если вы вдруг пользуетесь minimal API и вы группируете как-то свои endpoints, посмотрите в эту сторону, будет что-то наверняка полезное.
1390.32 1394.32 "Игорь Лабутин" Ну и, наконец, Entity Framework.
1394.32 1413.80 "Игорь Лабутин" Entity Framework традиционно подходит нестандартно к своим статьям о релизах, то есть у них довольно много улучшений, есть там полный список GitHub issues выявляет довольно внушительно, однако в статье они всегда традиционно используют, ну, так сказать, хайлайтят какую-то одну фичу, которую они улучшили, и в превью-6 это performance.
1413.80 1446.16 "Игорь Лабутин" Ну и если весь прошлый релиз EF Core был посвящен перформансу с точки зрения чтения, то есть если вы помните, они там соревновались с даппером, чтобы его хотя бы догнать, ну, по-моему, в итоге не совсем догнали, но очень близко подобрались, то этот релиз посвящен перформансу сохранения, ну, вообще, сохранения, insert, delete, то есть всех записывающих изменениях базу, и в частности в этом превью они серьезно ускорили save changes, потому что они сосредоточились на том, чтобы на самом деле делать поменьше roundtrips в базу.
1446.16 1456.80 "Игорь Лабутин" То есть, как выяснилось, довольно большой, ну, что очевидно, база не всегда лежит рядом с тем местом, где у вас исполняется код, и довольно много потерь происходит на roundtrips.
1456.80 1510.48 "Игорь Лабутин" И как пример они приводят, что если вы делаете всего лишь одну вставку одного, одной записи, то есть save changes, где вы добавили всего одну сущность, то у вас делается как минимум три roundtrips, это начать транзакцию, это собственно выполнить statement, и закоммитить транзакцию, это уже три roundtrips, это они там все пооптимизировали, используют механизм автоматической создания транзакции, если у вас выполняется один statement, для этого им пришлось немножко insert еще подхачивать, чтобы это был действительно один statement, и в общем в итоге теперь это один roundtrip с автоматическим transaction management, и вообще все хорошо и быстро стало, там что-то типа, ну на локальном хосте что-то раза в полтора всего, не так интересно, а если хост находится, ну с базы данных в той же сети, но на другой машине, там что-то типа раза в два-три быстрее стало, прям все хорошо.
1510.48 1533.16 "Игорь Лабутин" И такие же изменения для вставки нескольких записей, там чуть-чуть посложнее, потому что там все-таки вставка нескольких записей иногда приводила к нескольким statement, и совсем уж там все свести к одному insert не всегда получается, но тем не менее они стараются и точно так же стараются исключить явные по крайней мере roundtrips на начало и commit транзакции.
1533.16 1553.96 "Игорь Лабутин" Ну вот как-то так, то есть кажется, что EF Core движется вперед, потихонечку развивается, и надеюсь, я его довольно неплохо использую для чтения, но как бы каждый раз, когда заходит речь про запись, мне всегда стремно, что он там что-то очень странное изгенерирует, не знаю почему.
1553.96 1562.00 "Анатолий Кулаков" Ну да ладно, у него же есть хороший режим, который называется основной трекинг, в принципе, если ты трекинг отключаешь, то все остальное у него довольно… Ну тогда записывать ничего не надо.
1562.00 1568.52 "Анатолий Кулаков" Не, ну можно записывать и не трекинговые объекты, но он довольно нормально, бодренько работает.
1568.52 1570.00 "Игорь Лабутин" Ну да, да, да, да.
1570.00 1588.36 "Игорь Лабутин" Ну такое в классическом варианте оно, конечно, когда ты прочитал, поменял, записал, ну оно вроде работает на простых задачках, все работает, но вдруг становится что-то очень большое или какое-то очень сложное дерево, всегда, ну я просто всегда включаю логику, или начинаю дотошно проверять, что же он там нагенерил, по-другому никак.
1588.36 1597.72 "Анатолий Кулаков" Ну это правильно, да, потому что никто тебе не может предсказать, что он там нагенерил, как бы там ребята не оптимизировали, все равно запросы у всех индивидуальные, настройки у всех индивидуальные, может стрельнуть.
1597.72 1606.52 "Анатолий Кулаков" Ну и не отходя далеко от кассы, как я уже говорил, у нас успело выйти уже два превью, поэтому мы плавненько, постепенно переходим к превью 7.
1606.52 1621.32 "Анатолий Кулаков" Превью 7 наградила большой .NET не таким уж большим набором фич, поэтому совсем немножко, но зато очень даже крутая модная фича, которую мы ждали со времен 3.5 фреймворка, как только линку появилась, у нас наконец-то добавился в линку долгожданный метод.
1621.32 1625.50 "Анатолий Кулаков" Метод сортировки, правильной сортировки примитивных типов.
1625.50 1645.68 "Анатолий Кулаков" Ну допустим раньше, если вам нужно было отсортировать массив обычных стрингов или массив интов, то вам приходилось писать уродливую конструкцию, которая называлась orderby в скобках какой-нибудь s, стрелочка s, ну потому что линку наш понял, что мы пытаемся отсортировать не какое-то свойство элемента в этом массиве, а непосредственно сами элементы в этом массиве.
1645.68 1652.24 "Анатолий Кулаков" Вот до этого ему ума как бы не хватало понять, что если массив с примитивных типов, то можно отсортировать его и так.
1652.24 1657.84 "Анатолий Кулаков" И вот наконец-то свершилось, в превью 7 выйдет экстеншн метод, который мы все с вами долго ждали.
1657.84 1671.44 "Анатолий Кулаков" Теперь можно просто заказать метод order без всяких параметров, и он попытается вам отсортировать именно элементы в массиве без приема всяких лямб, замыканий, метод групп и прочих усложнений.
1671.44 1675.96 "Анатолий Кулаков" Вот ваш код станет чистым, шелковистым и красивым, что не может не радовать.
1675.96 1679.20 "Анатолий Кулаков" Спасибо, дорогой Microsoft.
1679.20 1696.12 "Анатолий Кулаков" Еще один интересный штук, появилась поддержка Unix файл модов, которые, наверное, всем вам известно, если вы программировали под Linux, то там у немножко другая система подхода к правам, чем у Microsoft, чем в ACL используется.
1696.12 1703.64 "Анатолий Кулаков" Вот, соответственно, у нас теперь появился такой же Enum, который там умеет group execute, group write, group read, читать, писать.
1703.64 1713.08 "Анатолий Кулаков" Соответственно, появились у файлов и у директорий методы getUnixFileMod, setUnixFileMod, с помощью которых вы можете все прочитать и все записать.
1713.08 1725.32 "Анатолий Кулаков" Я только не очень нашел примеров, это работает только под Unix, под Linux, что будет под Windows, оно не скомпилируется, оно будет брутить Node-support exception, оно вернет какую-то эмуляцию виндовых ACL.
1725.32 1732.96 "Анатолий Кулаков" То есть, вот это тоже интересно, каким образом они все-таки соблюли совместимость, кроссплатформенность в таких очень узко специализированных вещах.
1732.96 1747.92 "Анатолий Кулаков" Еще, наверное, третья самая важная фича, которая появилась, это library import source generator с заревизанса, штуковина, которую разрабатывали и дизайнили 18 месяцев, то есть это такая очень большая, мощная штука.
1747.92 1755.84 "Анатолий Кулаков" Это генератор, который позволяет вам организовать pain walk и interopы между нативными дл и ллками и, соответственно, mc# кодом.
1755.84 1768.24 "Анатолий Кулаков" Разрабатывалась она специально с интерфейсом, который позволяет вам просто-напросто заменить существующий атрибут daily import с помощью нового атрибута library import и у вас все, по идее, должно заработать.
1768.24 1796.08 "Анатолий Кулаков" Но на самом деле не все, потому что там аргументы отличаются, синтексис отличается и много чего отличается, но полностью новый атрибут покрывает функциональность старого, что позволило написать очень прекрасный анализатор вместе с codefix, который автоматически может пройтись вам по всем дл и лл импорта и сконвертировать в новомодный library import, который хорошо сделает всю ту же самую работу, вроде с тем же самым результатом, но это покажет только ваши тесты.
1796.08 1801.88 "Анатолий Кулаков" Что касается .NET, наверное, это все, что было в этом превью, а что у нас с ASP?
1801.88 1818.32 "Игорь Лабутин" С ASP у нас, опять же, некоторое количество улучшений и изменений в Blazor, добавили забавную фичу, теперь при, когда вы заходите в VBSable приложение Blazor, оно показывает прогресс бар своей загрузки.
1818.32 1830.76 "Игорь Лабутин" Это я так понимаю встроили чуть ли не в рантайм, но там такой красивенький прогресс барчик, кругленький, который, значит, когда доходит до 100%, тут же появляется отрендеренный ваш, значит, UI, который вы там нарисовали.
1830.76 1844.20 "Игорь Лабутин" В Blazor добавили более удобный способ привязки, соответственно, клей к вьюшкам с помощью так называемых get set и after модификаторов.
1844.20 1858.12 "Игорь Лабутин" То есть get set это, собственно, байдинги, а after это штука, которая позволяет указать код, который нужно выполнить после, собственно, того, как какое-то действие было выполнено, или просто как произошло получение значения из байдингов.
1858.12 1873.84 "Игорь Лабутин" Как я говорил чуть ранее, добавили криптографию в WebAssembly, поддержка ES, pbgdf2, https, jsonrpc, json, точнее, jrpc transcoding, еще улучшился performance.
1873.84 1894.96 "Игорь Лабутин" Если вы помните то, как сделана схема авторизации и модификации в S/Pen and Core, вы наверняка встречались с таким понятием, как схема авторизации, и если вам нужно было как-то ее закастомизировать или явно указать, всегда удалось писать, что вот, прям называть ее default scheme и так указывать.
1894.96 1899.76 "Игорь Лабутин" Теперь, если она одна, то она сама по себе default scheme и вообще не надо никак явно указывать.
1899.76 1917.12 "Игорь Лабутин" В minimal API добавилась поддержка аутентификации при загрузке iForm, точнее при работе с интерфейсами iForm File и iForm File Collection, когда вы upload-ите файлики через формочки, то раньше аутентификацию было нельзя использовать, теперь можно.
1917.12 1953.32 "Игорь Лабутин" Внутри S/Pen добавился новый сервис, это интерфейс, соответственно, iproblem_details_service, который вы сможете использовать у себя, если вы вызовете метод add_problem_details, мне так нравится, когда вы в коде у себя пишете add_problem_details, и после этого вы можете заинжектировать к себе iproblem_details_service, и у него есть метод write_async, который будет писать респонс сообщения об ошибках в формате, который вот такой довольно общеизвестный problem_details, когда там написано что, как, где, почему и в общем в едином для всех JSON формате.
1953.32 1965.28 "Игорь Лабутин" Немножко обновили middleware для диагностики, то есть всякие там unhandled, exception, middleware и вот это вот все, чтобы они как раз пользовались problem_details_service.
1965.28 1981.76 "Игорь Лабутин" Ну и когда-то давно мы обсуждали, что у нас добавились новые result-тайпы, в том числе для minimal API, теперь для них добавились, соответственно, интерфейсы, чтобы можно было более удобно их там, не знаю, мокать, тестировать и так далее.
1981.76 1997.52 "Игорь Лабутин" В общем-то и все в SPNet, то есть потихонечку дело движется к релизу, и в этой статье уже было сказано, что это последний превью, и следующий будет уже релиз кандидата 1, так что ждем следующего с нетерпением.
1997.52 2003.36 "Игорь Лабутин" Ну и Entity Framework Core, здесь главная фича этого релиза — это интерсепторы.
2003.36 2020.80 "Игорь Лабутин" Это штука, которая позволяет встроиться в pipeline обработки запросов в EF Core на довольно многих участках до начала исполнения команды, после формирования дерева, но до начала его исполнения, или после выполнения какой-либо запроса, но до начала вычетки результат-сета и так далее во многих местах.
2020.80 2028.56 "Игорь Лабутин" И теперь, во-первых, улучшили, изменили некоторое количество существовавших интерсепторов и добавили несколько новых.
2028.56 2042.32 "Игорь Лабутин" Регистрируются они, напомню, когда мы конфигурируем db.context, ну либо при создании, либо в методе onConfiguring, то есть либо когда вы add db.context указываете, либо уже в самом db.contextе onConfiguring переопределяете.
2042.32 2056.00 "Игорь Лабутин" Конкретные интерсепторы, я сейчас не буду погружаться в детали, они довольно специфические, и если вы занимаетесь прям такой низкоуровневой работой с EF Core, посмотрите, возможно, там есть нужные для вас.
2056.00 2063.96 "Игорь Лабутин" Кроме этого, есть кучка улучшений, несколько я хотел бы захайлайтить, они были просто приведены в виде GitHub issues, но они мне кажутся интересными.
2063.96 2081.12 "Игорь Лабутин" Если вы в запросах используете функции агрегации, то для SQL Server они теперь будут транслироваться в нативные функции SQL Server, то есть если вы пишете всякие там average, max, то они теперь в linq, то они теперь будут транслироваться в соответствующие функции SQL Server, и есть планы, как это сделать для Postgres и для всех остальных баз.
2081.12 2088.60 "Игорь Лабутин" Возможно, что-то уже даже сделано, я не проверял статус всех issues, там куча linq-ованых issues.
2088.60 2112.24 "Игорь Лабутин" Дальше, если у вас есть navigational properties, которые не являются public, то вам может хотеться их загрузить, EF Core это умеет, но, к сожалению, вы в include не можете сказать, ну, стандартно написать include и написать x, там, стрелочка, x точка именно этой property, потому что они private, и вы не можете их использовать извне этого класса.
2112.24 2118.12 "Игорь Лабутин" Теперь появился механизм, как это можно сделать через EF точка property, указать, что их нужно грузить.
2118.12 2136.64 "Игорь Лабутин" И последнее, завезли еще более расширенный, так сказать, набор работы со строками методов, и если вы используете у себя в linq string_join или string_concat, то они тоже будут, по крайней мере на SQL Server, преобразованы в нативные функции в SQL Server.
2136.64 2176.44 "Игорь Лабутин" И там сейчас ведется дискуссия на предмет, как бы это так сделать с учетом версии SQL Server, потому что нативные функции, которые позволяют делать в SQL Server, появились только в сам, ну, по-моему, с девятнадцатой версии SQL Server, а до этого их нужно было делать через всякие там XML query, там, for xml, in, что-нибудь, и это не так может быть эффективно на новых версиях по сравнению с нативными, и вот там сейчас ведутся дискуссии на предмет, как там правильно указывать на самом деле, не просто, допустим, use_sql_server в момент инстализации EF Core, а там use_sql_server в 2019, чтобы включать уже конкретные наборы фич.
2176.44 2183.20 "Игорь Лабутин" До этого момента в Entity Framework практически все фичи были, ну, независимы от версии, скажем так.
2183.20 2186.12 "Игорь Лабутин" Вот примерно это все для Entity Framework.
2186.12 2197.24 "Анатолий Кулаков" Слушай, а почему он не может при старте, тот же самый Entity Framework, каким-нибудь запросом запросить версию, запросить компобиличес и подстроить свои драйвера и маппинги и генераторы под это?
2197.24 2211.80 "Игорь Лабутин" Хороший вопрос, возможно, так и сделают, не знаю, пока обсуждали, либо сделать, типа, use_sql_server в скобочках там писать options.use2019features, грубо говоря, происходит true или там false, не знаю, что там будет по дефолту.
2211.80 2214.92 "Игорь Лабутин" Или вообще сделать экстенджер методы, типа, use_sql_server2019.
2214.92 2217.20 "Игорь Лабутин" Слушай, ну по-хорошему я не хочу знать, какой у
2217.20 2226.80 "Анатолий Кулаков" меня есть SQL Server, я хочу, чтобы если мои админы поставили новую версию, то у меня код начал выполняться быстрее, и все, зачем мне для этого перекомпьютировать, перевыкладывать, передеплоивать?
2226.80 2230.96 "Игорь Лабутин" Справедливо, не знаю, надо сходить выше и посмотреть.
2230.96 2249.36 "Игорь Лабутин" Я вот только пока читал ищи и пробовал именно конкретно эту фичу, там было обсуждение, по-моему там были линки какие-то отдельные, их было много на самом деле, всяких ищи изов на тему, как там сделать базоданч... ну, сервер-специфик, да, штуку, там ты же понимаешь, что там не только SQL Server-специфик, там же еще базоданных-специфик.
2249.36 2267.32 "Игорь Лабутин" Потому что в подвесе свои функции агрегации, там строк, например, в SQL Server свои, в SQLite третий, в MySQL четвертая, и везде нужны свои функции, то есть они уже должны уметь, в зависимости от того, в какой базе данных мы подключились, как-то по-разному все это транслировать.
2267.32 2270.44 "Игорь Лабутин" Добавить туда еще небольшую инстализацию в начале должно быть несложно.
2270.44 2271.44 "Анатолий Кулаков" Ну, по идее, да.
2271.44 2274.08 "Анатолий Кулаков" Ладно, погнали дальше, не будем терять времени.
2274.08 2280.72 "Анатолий Кулаков" Еще одна толзень, которая в нашей экосистеме плотно и ежедневно используется, это Nuget.
2280.72 2287.52 "Анатолий Кулаков" У Nuget тоже вышла версия 6.3, и несколько интересных нововведений они там продемонстрировали.
2287.52 2293.92 "Анатолий Кулаков" Во-первых, одно из самых прекрасных нововведений это, что теперь Visual Studio умеет показывать транзитивные зависимости.
2293.92 2301.88 "Анатолий Кулаков" То есть зависимости, которые не напрямую используются в вашей программе, а которые подтянулись с помощью тех пакетов, которые используются в вашей программе.
2301.88 2307.08 "Анатолий Кулаков" Или с помощью тех пакетов, которые используются в тех пакетах, которые используются в тех пакетах, которые используются в вашей программе.
2307.08 2308.08 "Анатолий Кулаков" Ну, в общем, вы поняли.
2308.08 2314.28 "Анатолий Кулаков" То есть это не прямые зависимости, которые к вам приехали через откуда-то, только потому, что какая-то третьестроение в библиотеках их использует.
2314.28 2324.44 "Анатолий Кулаков" Не знаю, например, тот же самый EF начинает использовать под VizDriver, и к вам приехал под VizDriver, несмотря на то, что напрямую вы его не используете, но вот в EF вы подключили.
2324.44 2328.72 "Анатолий Кулаков" Вот, это всегда хотелось бы видеть.
2328.72 2340.48 "Анатолий Кулаков" И, наконец, в Visual Studio на специальной макешке Dependencies у вас теперь есть такая возможность посмотреть, какие пакеты вы используете напрямую, какие они тащат.
2340.48 2345.44 "Анатолий Кулаков" И более того, там уже прям расширенный удобный функционал появился.
2345.44 2352.52 "Анатолий Кулаков" Например, вы можете щелкнуть по Transitive Dependency и добавить ее на верхний уровень.
2352.52 2360.72 "Анатолий Кулаков" То есть, по сути, установить пакет, который неявно пришел к вам из другой зависимости, на непосредственно установить уже в вашем приложении.
2360.72 2367.96 "Анатолий Кулаков" Казалось, безумная идея, зачем вам устанавливать этот пакет, который вы напрямую не используете, вашему коду он абсолютно не нужен, зачем вы его устанавливаете в ваше приложение.
2367.96 2371.72 "Анатолий Кулаков" Но у этого есть очень полезное использование.
2371.72 2386.24 "Анатолий Кулаков" Таким образом вы, например, можете обновить пакеты, в которых найдена Security Уязвимости до тех пор, пока непосредственно не обновится ваша настоящая зависимость и не обновится она новый патч.
2386.24 2414.44 "Анатолий Кулаков" То есть, таким образом вы можете, если вдруг у вас случилась такая ситуация, что сам Entity Framework, для примера, использует Postgres драйвер версии 1 и в Postgres драйвере версии 1 есть какая-нибудь уязвимость, которая позволяет скомпрометировать ваш код или завалить ваше приложение, вы, соответственно, идете на GitHub, ищете версию драйвера Postgres 1.1, который уже пропатчен, в которой этой уязвимости нет.
2414.44 2434.64 "Анатолий Кулаков" И несмотря на то, что Entity Framework еще не вышел, не обновился, Microsoft еще, может быть, даже не успел выпустить этот патч, вы уже можете взять версию уже неуязвимую, установить ее в ваше приложение, и, соответственно, в реальности, в рантайме будет использоваться именно она, несмотря на то, что сам Entity Framework будет требовать версию намного ниже.
2434.64 2451.02 "Анатолий Кулаков" В общем, очень приятная, хорошая фишка, очень часто как бы такое нужно, раньше приходилось это делать ручками, искать ручками, а теперь все это в удобном UI, вы можете увидеть, запромотить наверх и удобно поддерживать всю эту штуку.
2451.02 2460.16 "Анатолий Кулаков" Еще одна клевая штука, которая появилась у Transitive Dependents, это возможность посмотреть, откуда они все-таки взялись.
2460.16 2473.04 "Анатолий Кулаков" Тоже у меня часто бывала такая вещь, когда ты заходишь в папочку bin, смотришь, какие дейлильки вместе с твоим приложением распространяются, и диву даешься, и думаешь, откуда вот эта старая или вот эта ненужная, или вот эта глупая зависимость взялась.
2473.04 2477.78 "Анатолий Кулаков" И раньше определить это было довольно нетривиальным квестом.
2477.78 2493.36 "Анатолий Кулаков" Сейчас же вы в удобной UI-ке можете навести мышку на транзитивную зависимость, и она вам прямо в папочке подскажет, что меня тащит вот такая библиотека, потому что я вот нужна ей вон там, вон там, с такой-то версией.
2493.36 2495.68 "Анатолий Кулаков" В общем, тоже удобно, полезно и интересно.
2495.68 2499.88 "Анатолий Кулаков" Очень жалко, что долго мы так этого ждали и не было этого сразу.
2499.88 2503.00 "Анатолий Кулаков" Из Transitive Dependents это, наверное, все.
2503.00 2512.00 "Анатолий Кулаков" Появились новые Warning Messages, теперь анализаторы нугетов могут проверять дублирование пакетча референсов, пакетча версионов, пакетча даунлоудов.
2512.00 2516.04 "Анатолий Кулаков" Если эти атрибуты и элементы дублируются, то вам будет выдан соответствующий warning.
2516.04 2526.20 "Анатолий Кулаков" Также вы можете теперь, появилась возможность прямо из Visual Studio, из UI-ки устанавливать пакеты с плавающей версией, Floating Version, так называемая.
2526.20 2540.84 "Анатолий Кулаков" То есть это, где вы задаете не версию напрямую, там, например, 1.1.10, а можете использовать звездочки, типа мне скачивайте все, где поменялся только патч, или все только с минорной версией, или вообще звездочка, просто скачивайте самую последнюю версию.
2540.84 2546.20 "Анатолий Кулаков" И также можно там обозначить какие-нибудь пререлизные ветки, какие-нибудь бета-ветки.
2546.20 2555.68 "Анатолий Кулаков" Вот тоже для этого все маски есть, если вам вдруг почему-то это нужно, и вы не хотите ручками это редактировать в текстном файле, теперь у вас для этого есть удобный интерфейс Visual Studio.
2555.68 2556.68 "Анатолий Кулаков" Наверное, все.
2556.68 2563.00 "Анатолий Кулаков" Я лишь хочу напомнить, что Nuget 6.3 будет доступен во всех Visual Studio 2022.
2563.00 2573.80 "Анатолий Кулаков" Также из коробки будет распространяться с .NET 6, и он поддерживается на всех операционных системах, и даже можно скачать его из сайта в виде отдельного запускабельного файла.
2573.80 2578.28 "Анатолий Кулаков" В общем, тоже такой дипкий инструмент во всех возможных состояниях аморфных он существует.
2578.28 2584.00 "Игорь Лабутин" Ну, раз ты упомянул Visual Studio, давай тогда немножко поговорим про Visual Studio.
2584.00 2587.84 "Игорь Лабутин" У нас вышел релиз Visual Studio 2022.17.3.
2587.84 2592.76 "Игорь Лабутин" Это вполне стабильный релиз, который можно использовать.
2592.76 2594.52 "Игорь Лабутин" Там добавили следующие вещи.
2594.52 2597.04 "Игорь Лабутин" Во-первых, там теперь официально доступен MAUI.
2597.04 2602.24 "Игорь Лабутин" Оно теперь есть в релизной версии, так что MAUI у нас официально зарелизился.
2602.24 2608.08 "Игорь Лабутин" Там добавилась возможность разрабатывать приложение для Microsoft Teams, если вдруг кому-то это интересно.
2608.08 2610.84 "Игорь Лабутин" Улучшили всякие штуки про Live Unit Testing.
2610.84 2623.80 "Игорь Лабутин" Он там еще более умно перекомпилирует код, чтобы перекомпилировать только нужные кусочки для того, чтобы гонять только нужные тесты в режиме реального времени и так далее.
2623.80 2634.88 "Игорь Лабутин" Мы уже много раз упоминали про улучшение гита типа возможности делать Line Staging, то есть по строчкам добавлять код в комиты.
2634.88 2638.84 "Игорь Лабутин" Ну и куча всяких разных мелочей, которые мы тоже уже обсуждали.
2638.84 2645.72 "Игорь Лабутин" Показывать табы в несколько рядов, Visualizer для enumerables и возможность переоткрыть и закрыть документы.
2645.72 2650.08 "Игорь Лабутин" Прям в общем такие уже минорные фичи, но тем не менее возможно полезные.
2650.08 2651.08 "Игорь Лабутин" Это был 17.3.
2651.08 2657.08 "Игорь Лабутин" И одновременно с 17.3 релизным, конечно же, объявили релиз 17.4 Preview 1.
2657.08 2665.24 "Игорь Лабутин" И это как раз таки версия 17.4 же у студии будет первая, которая будет являться нативной для ARM64.
2665.24 2682.44 "Игорь Лабутин" И Preview 1 это как раз таки развитие этой штуки, потому что в первом превью, самом первом превью, который даже не назывался Preview 1, там были анонсированы три ворклода - консольный, espnet и не помню какой еще.
2682.44 2686.60 "Игорь Лабутин" Вот в Preview 1 добавился UVP.
2686.60 2690.40 "Игорь Лабутин" Не знаю зачем, но видимо для того, чтобы девелопить все под Windows 11.
2690.40 2698.00 "Игорь Лабутин" Если вы вдруг пишете на плюсах, то там появился нативный ARM64 CMake.
2698.00 2703.20 "Игорь Лабутин" В полноценный релиз обещают все это вывести ближе к концу этого года.
2703.20 2708.56 "Игорь Лабутин" Так что ждем новый 17.4 для ARM64 ближе к концу этого года.
2708.56 2713.00 "Игорь Лабутин" Ну и из таких еще мелких фич, там конечно еще планируются очередные гид-энхансменты.
2713.00 2721.24 "Игорь Лабутин" Студия теперь позволяет внутри инсталлера сама понять, что какие-то компоненты теперь не поддерживаются.
2721.24 2734.20 "Игорь Лабутин" То есть, например, если вы заинсталили какой-то очередной апдейт студии, она поймет, что предыдущий, не знаю там, .NET Runtime уже не поддержана, есть более новый патч, то она может удалить старый, поставить новый.
2734.20 2743.84 "Игорь Лабутин" В общем, можно теперь через инсталлер контролировать, так сказать, поддерживаемость всяких компонентов студии, которые не влияют на жизнеспособность студии непосредственно.
2743.84 2754.04 "Игорь Лабутин" Ну и завезли мелкую фичу, если вы когда-нибудь пользовались в Ryder или ReSharper, штукой под названием FileStructure, которая показывает вам такой outline файлика.
2754.04 2757.36 "Игорь Лабутин" Вот теперь такая штука под названием DocumentOutline есть в студии.
2757.36 2758.92 "Игорь Лабутин" 17.4 Preview 1.
2758.92 2771.12 "Игорь Лабутин" Вот примерно все про студию, ждем, во что вылезет 17.4, ждем каких-нибудь первых статей про то, как она работает на армии, хорошо, плохо, быстро, медленно.
2771.12 2777.72 "Анатолий Кулаков" Хорошо, кажется, с тулзами, с фреймворками, с языками разобрались, можно наконец пробежаться по статейчикам.
2777.72 2785.40 "Анатолий Кулаков" Есть у меня парочка интересных статей и хотелось бы начать с такой дерзкой идеи, как построение своего собственного редиса.
2785.40 2788.28 "Анатолий Кулаков" И не просто редиса, а редиса прямо на C#.
2788.28 2797.12 "Анатолий Кулаков" Кто не знает, что редис - это довольно популярная in-memory база данных, которая в основном... даже база данных ее нельзя называть, это in-memory кэш.
2797.12 2806.40 "Анатолий Кулаков" Это просто in-memory хранилище, которое в основном используется в нашей современной жизни для того, чтобы держать кэш поближе к тому месту, куда его надо отдавать.
2806.40 2817.52 "Анатолий Кулаков" Она безумно примитивная, она однопоточная, у нее очень мало команд, но зато она работает быстро, стабильно, надежно, многие годы и все ее любят за это.
2817.52 2820.56 "Анатолий Кулаков" Маленькая, предсказуемая, быстрая штука.
2820.56 2826.72 "Анатолий Кулаков" И если вы делаете где-то кэш, то скорее всего, в большинстве случаев, это будет именно редис.
2826.72 2830.84 "Анатолий Кулаков" И началось все с интересной истории.
2830.84 2838.44 "Анатолий Кулаков" Команда Dragonfly, это такой небольшой израильский стартапчик, решила переписать редис на C и C++.
2838.44 2849.44 "Анатолий Кулаков" Ну, то есть, казалось бы, если продукт настолько популярен, он оптимизирован под перформанс, и почему бы ему не быть написан на настолько низковыровневом языке, как плюсы.
2849.44 2862.76 "Анатолий Кулаков" Она это сделала, и результаты ее довольно порадовали, поэтому это теперь довольно хайповая штука, она недавно прошлась по всем твиттерам, по всем интернетам со сравнительными бичмарками.
2862.76 2864.56 "Анатолий Кулаков" Что же они сделали?
2864.56 2880.52 "Анатолий Кулаков" Во-первых, Dragonfly, это, как я уже сказал, база данных, написанная на C и C++, это in-memory база данных, даже это data storage, давайте так, чтобы не путать, это все-таки data storage, никакого там синтаксиса и прочих сложных вещей, что мы ожидаем от нормальной базы данных, там нет.
2880.52 2894.84 "Анатолий Кулаков" Это data storage, который полностью совместим по API с редисом и memcached, memcached это другой популярный движок для кэширования, в общем, интересно, что последние годы очень популярная такая штука, как совместимость по протоколам.
2894.84 2917.60 "Анатолий Кулаков" Кто-то держит совместимость с mong, кто-то с postgres, кто-то вот, как в нашем случае, например, с редисом, это позволяет нам просто-напросто взять нашу существующую инфраструктуру, подменить там компонент с редисом, контейнер с редисом, допустим, новым контейнером уже с Dragonfly и просто-напросто на голом месте получить величайший буст в производительности.
2917.60 2924.64 "Анатолий Кулаков" При этом никакой код перекомпилировать не надо, документацию читать не надо и вообще новые всякие драйверы, новые протоколы изучать не надо, все полностью совместимо.
2924.64 2929.72 "Анатолий Кулаков" Подход прекрасный и им воспользовалась команда этого продукта, за что им тоже честь и хвала.
2929.72 2944.04 "Анатолий Кулаков" Они не просто переписали один в один, тупо и без всякой головы, они переписали умно, они взяли новые алгоритмы, те, которые уже были изобретены после того, как редис был написан и которые уже в него внедрить было сложно.
2944.04 2953.56 "Анатолий Кулаков" Они взяли новые структуры данных, которые были оптимизированы как раз-таки под вот эту схему и под вот эту нагрузку, с которыми приходилось работать.
2953.56 2964.24 "Анатолий Кулаков" Они сделали мультитрейдинг, напомню, что редис он однопоточный, соответственно здесь тоже величайший простор для скалабилити и оптимизации.
2964.24 2978.48 "Анатолий Кулаков" И они учли, что когда писался редис, у нас еще основными системами были жесткие диски, памяти было обычно мало и все структуры, соответственно, которые были выбраны в редис и они учитывали те времена.
2978.48 3006.20 "Анатолий Кулаков" У нас сейчас в современном мире абсолютно не так, памяти много, терабайты, SSD, диски все с рандомной записью и прочее, то есть вот это все последние веяния в хардваре они тоже учли, также они учли, что у нас теперь есть облака и в результате всего этого они сделали штуку, которая работает в некоторых кейсах в 25% в 25 раз быстрее, чем редис.
3006.20 3012.92 "Анатолий Кулаков" Это довольно внушительная сумма и безусловно стоит того, чтобы на этот продукт посмотреть, как минимум прицениться.
3012.92 3024.52 "Анатолий Кулаков" И также они добились того, что Dragonfly на 30% использует более эффективную память, ну то есть по сути меньше памяти использует, чем редис на тех же самых объемах данных.
3024.52 3029.84 "Анатолий Кулаков" В общем, такой довольно интересный продукт LA, в общем, если вам интересно, посмотрите.
3029.84 3034.48 "Анатолий Кулаков" Ну и естественно, она никак не связана ни с темой нашего подкаста, ни вообще с дотнетом.
3034.48 3037.84 "Анатолий Кулаков" Безусловно, никакого дотнета здесь нет, не было и не пахнет.
3037.84 3039.80 "Анатолий Кулаков" Если бы не продолжение.
3039.80 3058.76 "Анатолий Кулаков" Замечательный человек, в миру известен также, как Айен Дерахин, Орен Йени или автор Raven DB, посмотрел на это все и подумал, неплохо, друзья, переписали просто-напросто ребят на новый язык, переменили там новые структуры и получили такой большой, огромный буст.
3058.76 3061.80 "Анатолий Кулаков" А что будет, если мы перепишем редис на C#?
3061.80 3067.48 "Анатолий Кулаков" И вот этот вопрос его так захватил, что он немножко попробовал это сделать.
3067.48 3075.28 "Анатолий Кулаков" И не то, чтобы здесь у нас будут какие-то огромные цифры, с помощью которых C# порвет как бы все на свете.
3075.28 3082.36 "Анатолий Кулаков" Замечательный факт заключается не в том, что Айен Дерахин хочет изобрести новый редис на C# и как-то его продвигать, абсолютно нет.
3082.36 3092.64 "Анатолий Кулаков" Замечательные эти статьи сделали то, что он очень подробно и интересно описывает о том, каким образом он писал этот код, каким образом его профилировал и какие выводы из этого сделал.
3092.64 3094.44 "Анатолий Кулаков" То есть получился такой небольшой детективчик.
3094.44 3099.76 "Анатолий Кулаков" Вот именно с этим детективчиком я и приглашаю вас подробнее немножко ознакомиться.
3099.76 3105.00 "Анатолий Кулаков" Итак, интересно, как вы думаете, сколько нужно строк, чтобы написать свой собственный редис на C#?
3105.00 3107.00 "Анатолий Кулаков" Игорь, твои предположения?
3107.00 3115.00 "Игорь Лабутин" Ну, я знаю, что редиса, конечно, команд не то, чтобы сильно много, но чтобы все поддержать нужно, ну не знаю, тысячу.
3115.00 3118.44 "Анатолий Кулаков" Тысячу строк, ну блин, это ты прям даже, мне кажется, мало взял.
3118.44 3119.80 "Анатолий Кулаков" Ну, наверное, да.
3119.80 3130.68 "Анатолий Кулаков" С учетом того, что для Айен Дерахина это был как бы не основной продукт, это просто была тема на попробовать, просмотреть, профилировать, он поддержал всего две команды, это get и set.
3130.68 3134.84 "Анатолий Кулаков" Самые примитивные команды, которые записывают какое-то значение и читают какое-то значение.
3134.84 3135.84 "Анатолий Кулаков" Вот и все.
3135.84 3138.20 "Анатолий Кулаков" И на это у него ушло сто строк.
3138.20 3165.24 "Анатолий Кулаков" Полностью поддержку всей этой инфраструктуры, то есть он завел себе TCP-листнер, открыл сокет, потом считал данные из сети, все это сделал с синхрона с помощью таска, распарсил команды, там get или set, и в зависимости от того, что к нам пришло, сложил это все в обычный concurrent dictionary, стандартный системный concurrent dictionary типа string-string, там, соответственно, есть ключи, есть какое-то строковое значение.
3165.24 3168.96 "Анатолий Кулаков" Вот, в принципе, и вся логика, которая у него была сделана.
3168.96 3180.80 "Анатолий Кулаков" Ну, естественно, он добавил еще exception handling, надо признать, что в эти сто строк что пошли хорошая обработка исключений, и вот этот простой подход, наивный, в сто строк дал ему сразу один миллион записей в секунду.
3180.80 3189.56 "Анатолий Кулаков" Неважно, на какой машине он там делал, как мерил, нам, в принципе, главное только относительные цифры, естественно, все будет зависеть от ваших показателей железа.
3189.56 3197.00 "Анатолий Кулаков" В общем, один миллион операций в секунду, но после того, как он запустил это под профайлером, сразу очевидным стали проблемы.
3197.00 3209.84 "Анатолий Кулаков" Во-первых, было много локаций, потому что весь парсинг был сделан с помощью строк, которые там спритились, каким-то образом конконтинуировались, складывались, делились, это всегда дает много локаций, как только вы начинаете работать активно с строками.
3209.84 3224.76 "Анатолий Кулаков" Также ему не понравилось то, что очень большой latency был у этого продукта, то есть в 99-м персентиле где-то 100 миллисекунд уходило на запрос, в то время как, например, DragonFly справился всего-навсего за одну миллисекунду.
3224.76 3229.36 "Анатолий Кулаков" И, соответственно, была ужасная работа с сетью.
3229.36 3239.72 "Анатолий Кулаков" Вот этот примитивный подход, когда мы просто бросаем что-то в сеть, оттуда что-то читаем, даже с учетом банальной синхронности, банальных тасков, все равно сеть легитимизировалась неоптимально.
3239.72 3256.64 "Анатолий Кулаков" Нужно сказать про Redis еще одну штуку, что у него поставляется прям сразу вместе с ним отличная бичмаркалка, который по протоколу Redis позволяет вам производить абсолютно любые замеры, позволяет очень гибко настраивать потоки клиентов и прочее.
3256.64 3274.24 "Анатолий Кулаков" Поэтому для того, чтобы произвести все эти замеры, Анди практически ничего не пришлось делать, он просто взял уже скачал готовый контейнер, подобрал те ключики, которые удовлетворяют его тестам и запустил всего-навсего одну команду, там есть контейнер в докере с определенными ключиками и уже начинает снимать результаты, профилировать и дампить.
3274.24 3279.76 "Анатолий Кулаков" Ну что ж, это все понятные проблемы.
3279.76 3295.56 "Анатолий Кулаков" После того, как он посмотрел в профайлер, он увидел, что самым главным отжирателем всех ресурсов, которые у него есть, прямо на самом топе, у него там держится флаша SYNC, который сбрасывал ответ для нашего сетевого клиента.
3295.56 3309.40 "Анатолий Кулаков" То есть сетевой клиент приносил какую-то команду записать или считать, в это время процессор доставал какое-нибудь значение из Concurrent Dictionary или наоборот записал в Concurrent Dictionary и отсылал ответ, что типа или все хорошо, или вот тебе значение.
3309.40 3319.04 "Анатолий Кулаков" И вот этот ответ с помощью Streamwriter все время флашился в сеть.
3319.04 3320.84 "Анатолий Кулаков" Флашился он на каждую команду.
3320.84 3333.32 "Анатолий Кулаков" А нужно сказать еще про тест, в том, что этот тест был очень интенсивным, то есть он там создавал множество клиентов, и эти множество клиентов генерировали огромное количество команд, ну то есть чтобы максимально именно сделать хороший бичмарк.
3333.32 3351.44 "Анатолий Кулаков" И соответственно флашить на каждую команду, это получилось слишком тронжирно, слишком накладно, потому что команды маленькие, их там много, и так как флаш сразу делал сетевой вызов, мы сразу ходили в сеть, сеть у нас медленная, и это было дорого.
3351.44 3353.12 "Анатолий Кулаков" И какое решение здесь?
3353.12 3356.00 "Анатолий Кулаков" Решение это, конечно же, больше утилизировать буфер.
3356.00 3367.20 "Анатолий Кулаков" То есть мы сначала можем накопить как можно больше в памяти, накопить какой-то большой буфер информации, который мы хотим отослать, а потом за один раз сбросить это в сеть, сеть это все быстренько к себе скопирует тоже за один батч и быстренько отошлет.
3367.20 3375.36 "Анатолий Кулаков" Это в принципе хорошая оптимизация, которая очень часто везде используется, и это было сделано довольно интересно, довольно хитро.
3375.36 3380.20 "Анатолий Кулаков" То есть он не стал там замерять какое-то количество команд или по какому-то количеству времени сбрасывать.
3380.20 3382.16 "Анатолий Кулаков" У него был другой интересный лайфхак.
3382.16 3396.76 "Анатолий Кулаков" Прежде всего он рассчитывает на то, что стрим в райтер, после того как у него переполнится свой внутренний буфер, то есть если не делать флаж, он это все у себя в буфере складывает, складывает и складывает до тех пор, пока у него есть внутренний буфер.
3396.76 3399.44 "Анатолий Кулаков" Когда он переполнится, он сам автоматически сбросит.
3399.44 3403.24 "Анатолий Кулаков" То есть вообще нам ничего делать не надо, все само будет работать.
3403.24 3415.96 "Анатолий Кулаков" Но также точно не хотелось ждать, что он нам будет автоматически это все сбрасывать, а если у нас вдруг не будет случайно команд, то он никогда это не сбросит и наш мечмаркер не получит никогда ответа, что тоже не хотелось.
3415.96 3438.92 "Анатолий Кулаков" Поэтому он применил такой интересный ход, он посмотрел, что если он считывает из буфера какое-то значение, то есть считывает из сети какое-то значение и это значение еще ожидает своего считывания, то есть по сути у сетевого интерфейса сейчас в буфере нет ничего, что он может прямо сейчас быстро отдать, а он пошел там собирать, копить байтики или ждать сокета, в этот момент он тоже делает флаж.
3438.92 3445.90 "Анатолий Кулаков" Хорошее решение, которое ему сразу дало прирост просто в два раза производительности нам.
3445.90 3451.42 "Анатолий Кулаков" Соответственно, эту главную точку, главную боль, которая у нас была, метод флаж, мы убрали.
3451.42 3458.70 "Анатолий Кулаков" Следующим нашим целью профайлер показал concurrent dictionary.
3458.70 3475.90 "Анатолий Кулаков" Concurrent dictionary – очень хорошая структура, но не рассчитанная под большой контенжент, то есть под большую нагрузку и в принципе для этого есть более оптимальные структуры и в профайлере мы четко видим, что мы тормозим на локи в методе try at internal, который есть у concurrent dictionary.
3475.90 3478.90 "Анатолий Кулаков" Мы там проводим где-то 50% всего полезного времени.
3478.90 3479.90 "Анатолий Кулаков" Ну 50% – это много.
3479.90 3483.90 "Анатолий Кулаков" Да, сказать, что это много – это просто ничего не сказать.
3483.90 3503.00 "Анатолий Кулаков" Дело в том, что внутри concurrent dictionary есть локи и это не просто локи, которые просто окружили dictionary и все, то есть не одним локом dictionary окружается, а там есть специальный набор, специальный бакет расшаренных локов, которые в зависимости от каких-то там условий лочат тот или иной бакет.
3503.00 3507.10 "Анатолий Кулаков" То есть монитор может сразу несколько бакетов залочить.
3507.10 3515.54 "Анатолий Кулаков" Естественно, да, прежде всего, что количество этих локов обычно зависит от количества ядер на вашем процессоре.
3515.54 3521.94 "Анатолий Кулаков" Ну это один из самых простых способов для того, чтобы оптимально сделать мультитрейдинг.
3521.94 3527.30 "Анатолий Кулаков" Естественно, что чем больше у вас будет локов, тем меньше у вас будет контеншен.
3527.30 3538.18 "Анатолий Кулаков" И соответственно, чем больше у вас concurrency в вашем проекте, чем больше у вас нагрузка в этот concurrent dictionary, тем больше есть смысла увеличивать количество локов.
3538.18 3547.42 "Анатолий Кулаков" Чем больше локов, тем меньший объем бакетов они лочат и тем больше шанс, что контеншен у вас в приложении будет очень уменьшаться.
3547.42 3551.50 "Анатолий Кулаков" Соответственно, Айенди попробовал сделать 1024 лока.
3551.50 3558.26 "Анатолий Кулаков" Это немножко помогло, но абсолютно не в тех цифрах, которых он ожидал, которые мы ждем от нашего приложения.
3558.26 3567.34 "Анатолий Кулаков" То есть все-таки с той нагрузкой, которую давал вот этот бичмаркер, мы просто так конкурент dictionary потюдить не смогли.
3567.34 3572.86 "Анатолий Кулаков" Из этого Айенди делает вывод, что от concurrent dictionary нужно избавляться.
3572.86 3587.02 "Анатолий Кулаков" И соответственно, мы можем сделать шареные данные напрямую без вот этого конкурент dictionary, потому что он не подозревает о наших нагрузках, он не знает, каким образом у нас распределяются клиенты.
3587.02 3589.06 "Анатолий Кулаков" И самое главное, что мы никак не можем этим управлять.
3589.06 3591.46 "Анатолий Кулаков" Это все абсолютно рандомно, абсолютно случайно.
3591.46 3601.66 "Анатолий Кулаков" Таким образом, вместо того, чтобы использовать один concurrent dictionary, мы можем разбить его на несколько независимых словарей, несколько независимых dictionary, вообще без локов.
3601.66 3607.98 "Анатолий Кулаков" И использовать в каждом отдельном потоке, доступаться к этому одному dictionary.
3607.98 3609.74 "Анатолий Кулаков" Абсолютно без контеншона.
3609.74 3615.66 "Анатолий Кулаков" Если никаких локов не будет, это значит, что мы будем работать с этими словарями максимально эффективно.
3615.66 3625.94 "Анатолий Кулаков" Соответственно, нам для того, чтобы достучаться из одного трейда к одному словарю, нужно сделать небольшую штуку по трейдам.
3625.94 3632.18 "Анатолий Кулаков" То есть складывать задачи в какую-то определенную очередь, чтобы трейды отзабирали и чтобы они не конфликтовали между собой.
3632.18 3636.26 "Анатолий Кулаков" Чтобы они не дрались за ресурсы, за локи, за dictionary, за мониторы.
3636.26 3640.66 "Анатолий Кулаков" У них у каждого будет свой dictionary, они будут каждый к себе складывать, каждый от себя читать.
3640.66 3643.18 "Анатолий Кулаков" И если мы правильно настроим роуты, то все будет хорошо.
3643.18 3644.30 "Анатолий Кулаков" Контеншона никакого не будет.
3644.30 3651.82 "Анатолий Кулаков" И, соответственно, он написал такой dictionary, в общем, не очень большой классик, такой все понятно.
3651.82 3666.42 "Анатолий Кулаков" Распределил он ядер, всего у него на машине было 16, поэтому он распределил 10 ядер на трейды, которые соответственно будут работать непосредственно со сториджем, и 6 ядер отдал на непосредственно input-output на сеть и на прочие взаимодействия.
3666.42 3668.62 "Анатолий Кулаков" Таким образом, утилизировал хорошо 16 ядер.
3668.62 3678.30 "Анатолий Кулаков" И вот этот подход, когда мы избавились от concurrent dictionary, переделали на свой без контеншона, он добавил нам еще 25% перформанса к тому, что у нас уже было.
3678.30 3680.14 "Анатолий Кулаков" Это тоже отличный показатель.
3680.14 3688.74 "Анатолий Кулаков" И, соответственно, он убрал из профайлера, concurrent dictionary и вообще любые упоминания о сторидже, которые там были, что тоже прекрасно.
3688.74 3693.86 "Анатолий Кулаков" Следующим шагом у нас всплыла плохая работа с сетью.
3693.86 3712.46 "Анатолий Кулаков" То есть недостаточно утилизировались ресурсы, недостаточно хорошо мы обрабатывали данные, которые к нам приходят, а самое главное, мы очень много данных копировали, то есть те гигабайты, которые к нам приходили из сети, мы их копировали куда-то там в память с помощью стримрайтера, стримридера, пытались их как-то распарсить.
3712.46 3713.66 "Анатолий Кулаков" В общем, все это не модно.
3713.66 3721.30 "Анатолий Кулаков" Сейчас так не носят, сейчас так не делают, а модно сейчас использовать как раз таки System.io pipelines, о которых мы не раз уже говорили в наших программах.
3721.30 3727.22 "Анатолий Кулаков" И, соответственно, он тоже поддался на это искушение, заюзал модные пайплайны.
3727.22 3735.22 "Анатолий Кулаков" Я напомню, что пайплайны – это специальная API для high performance input/output, что бы это ни значило.
3735.22 3746.70 "Анатолий Кулаков" Он позволяет вам работать уже непосредственно со спанами, то есть позволяет избежать копирования памяти, позволяет низкоуровнево работать со всеми возможными буферами, которые там есть на низком уровне.
3746.70 3756.22 "Анатолий Кулаков" В общем, если вам нужен высокопроизводительная input/output система, то вам смело нужно смотреть на пайплайны, что в принципе в нашем случае идеально просто ложилось.
3756.22 3761.98 "Анатолий Кулаков" Минусы пайплайна заключаются в том, что очень много низкоуровневых вещей у нас теперь всплывают наверх.
3761.98 3773.26 "Анатолий Кулаков" Если раньше мы могли взять какой-нибудь стримридер, вызвать метод readline, он вам сам распарсит строчку, сам найдет у него окончание строки, сам преобразует это в UTF-8 и сам в это все вернет, то теперь нет.
3773.26 3782.14 "Анатолий Кулаков" В принципе у вас есть пайпридер, который работает чисто с байтами и соответственно, чтобы оптимально работать с байтами, вы тоже уже должны спускаться на какой-то вот этот уровень.
3782.14 3784.94 "Анатолий Кулаков" Никаких строк, все по хардкору.
3784.94 3790.42 "Анатолий Кулаков" Ну ладно, в принципе, небольшая проблема, там не такой уж сложный протокол, чтобы заморачиваться такими мелочами.
3790.42 3800.62 "Анатолий Кулаков" Но после того, как проект был переписан, автор столкнулся с неожиданным поведением.
3800.62 3806.94 "Анатолий Кулаков" Дело в том, что приложение стало вместо наших миллионов и миллиардов операций в секунду, всего-навсего выдавать всего-навсего 100.
3806.94 3808.54 "Анатолий Кулаков" 100 операций в секунду.
3808.54 3812.10 "Анатолий Кулаков" 100, не просто 100 тысяч, не 100 миллионов, а просто 100.
3812.10 3819.06 "Анатолий Кулаков" Вот, естественно, это не говорит нам о том, что дотнет медленный, а о том, что мы просто-напросто что-то не так делаем.
3819.06 3822.62 "Анатолий Кулаков" Таких показателей не бывает в жизни, в общем.
3822.62 3826.38 "Анатолий Кулаков" И действительно, это вскрыло другую подноготную пайплайнов.
3826.38 3840.26 "Анатолий Кулаков" Дело в том, что API у них немножко отличается от того, как мы привыкли читать из ридеров и врайтеров, и там введены новые концепции, такие как не просто сколько байт мы получили, но и то, сколько байт наш клиент готов потребить.
3840.26 3858.90 "Анатолий Кулаков" Потому что очень часто бывает, особенно когда мы пишем какой-то пар с протоколов, как в нашем случае, очень часто бывает такая ситуация, когда нам, допустим, половинка команды и половинка слова от протокола дошла, и сетевая карта уже может нам отдать этот буфер, в котором содержится вот эта половинка команды.
3858.90 3873.82 "Анатолий Кулаков" Но тот потребитель, который пытается эту команду распарсить, ему знаний недостаточно, ему нужна полная команда, чтобы распарсить те знания, распарсить те данные, которые, соответственно, помогут ему дальше как-то продолжать свою работу.
3873.82 3882.30 "Анатолий Кулаков" Конечно, раньше мы могли скопировать первую часть команды, подождать, пока придет вторая часть, как-то континейтить, попытаться опять еще раз распарсить.
3882.30 3892.30 "Анатолий Кулаков" Но так как пайплайны рассчитаны на то, что мы копировать должны как можно меньше, а больше использовать уже существующие буферы, которые и так держатся в сетевой карте, то там пошли другим путем.
3892.30 3893.66 "Анатолий Кулаков" Там есть два параметра.
3893.66 3899.34 "Анатолий Кулаков" Первый параметр сообщает, сколько байт мы прочитали непосредственно, или сколько можем прочитать.
3899.34 3906.34 "Анатолий Кулаков" А второй параметр сообщает, а сколько байт мы непосредственно обработали за консюмере, то есть готовы принять как потребитель этого контракта, мы готовы себе принять.
3906.34 3912.50 "Анатолий Кулаков" И вы, честно, можете сказать, что вот ты мне, конечно, можешь 200 байт отдать, но я хочу из них принять только 50.
3912.50 3925.94 "Анатолий Кулаков" Остальные пусть у тебя в буфере лежат, ты вот эти 50 отбрось, которые я у тебя считал, остальные 150 пусть у тебя лежат в буфере и подожди, пока придет еще какие-то данные, потом я у тебя заберу и заново их сначала, и те, которые остались, и попробую еще раз распасить.
3925.94 3934.42 "Анатолий Кулаков" Интерфейс очень удобный, очень понятно, зачем сделан, хорошо оптимизирует память, хорошо оптимизирует данные, но, наверное, не очень интуитивный, если вы первый раз его видите.
3934.42 3942.02 "Анатолий Кулаков" После осознания вот этого факта, плюс 50% скорости к нам еще пришло, у нас еще увеличилось.
3942.02 3949.34 "Анатолий Кулаков" То есть, действительно, pipeline работает, работает очень хорошо и, опять же, очень сильно помогает, если вам это нужно.
3949.34 3953.50 "Анатолий Кулаков" Дальше пошли уже скитания какие-то по всяким мелочам.
3953.50 3979.62 "Анатолий Кулаков" В процессе этих скитаний он возвращался к предыдущим каким-то подходам, возвращался обратно к dictionary, отказывался от pipeline, в общем, много всего делал, чего, в принципе, не так уж интересно читать, то есть, не так интересно рассказывать, а вот если вам интересно именно чтение и хардкорные детали, и большие мелочи, то смело обращайтесь к статьям, там целая серия статей из, по-моему, 5 или 6 небольших таких рассказиков, легко читаются, легко делаются.
3979.62 3985.10 "Анатолий Кулаков" Из того, что еще дало хороший boost в perfomancy, это, конечно, работа со строками.
3985.10 4001.38 "Анатолий Кулаков" Как я уже сказал в начале, parser был сделан очень примитивно, там строки, они сплитились, они континентились, и это сразу вам говорит о том, что в вашей программе будут проблемы, как только придет более или менее вменяемая нагрузка.
4001.38 4013.42 "Анатолий Кулаков" Профайлер это доказал, притом доказал он это не так уж очевидно, как у нас были предыдущие какие-то пункты, где прям сразу там говорят тебе, что вот 50% у тебя занято вот здесь.
4013.42 4020.14 "Анатолий Кулаков" Здесь не так, здесь работа со строками, профайлер показал, что занимает у нас 13% времени, ну, по сравнению со остальными не так уж и много.
4020.14 4030.34 "Анатолий Кулаков" Но здесь еще есть интересный пункт, это gc_wait, то есть работа garbage collector занимает еще 14% времени.
4030.34 4048.06 "Анатолий Кулаков" Напрямую мы не можем сделать вывод, что garbage collector тормозил только из-за строк все это время, но косвенно, если мы посмотрим на код, если мы увидим аллокацию, если мы прикинем, что творится, то косвенно ничего другого там кроме строк такой аллокации, чтобы загрузить garbage collector на 14% там не было.
4048.06 4054.50 "Анатолий Кулаков" А здесь мы уже сплюсовываем непосредственно работу со строками из gc и получаем уже 27%.
4054.50 4061.98 "Анатолий Кулаков" 27% уже на его профайлере непосредственно занимало второе место сразу после систем кода.
4061.98 4067.38 "Анатолий Кулаков" То есть, по сути, из пользовательского кода это уже самое первое, что нужно оптимизировать.
4067.38 4072.26 "Анатолий Кулаков" Я напомню, что оптимизировать нужно не то, что вам хочется, а то, что вам показывает профайлер.
4072.26 4078.70 "Анатолий Кулаков" Поэтому обязательно надо смотреть сначала в профайлер, смотреть, что там занимает первые места и уже только туда лезть.
4078.70 4088.26 "Анатолий Кулаков" Вот, он честно дождался, когда мы дооптимизировали настолько, что можно спуститься к строкам и garbage collector и аллокациям и честно вот приступил к их оптимизации.
4088.26 4091.46 "Анатолий Кулаков" Что же можно сделать со строками?
4091.46 4092.70 "Анатолий Кулаков" Прежде всего 27%.
4092.70 4094.74 "Анатолий Кулаков" Много это или мало?
4094.74 4099.22 "Анатолий Кулаков" Может кому-то показаться, что 27% это ни разу не 80% и в принципе нормуль.
4099.22 4102.22 "Анатолий Кулаков" Но здесь нужно учить несколько ослабляющих факторов.
4102.22 4106.66 "Анатолий Кулаков" В том, что мы сейчас поддержим только get и set команды в протоколе редиса.
4106.66 4108.38 "Анатолий Кулаков" На самом деле их там больше 300.
4108.38 4124.74 "Анатолий Кулаков" И если на двух командах мы уже настолько memory traffic генерим и настолько garbage collector нагружаем, то если мы этот показатель увеличим до 300, а там команду немножко посложнее могут быть, чем просто считать get или set, то этот показатель и возрастет у нас довольно сильно.
4124.74 4131.54 "Анатолий Кулаков" Также нужно учесть, что там нет ни удалений, ни протуханий, ничего в этом.
4131.54 4135.58 "Анатолий Кулаков" В общем, как только мы бы это добавили, проблема у нас вырезала бы еще больше.
4135.58 4138.66 "Анатолий Кулаков" Поэтому 27% на двух командах это довольно много.
4138.66 4142.42 "Анатолий Кулаков" Это стоит место стоящее, которое нужно оптимизировать.
4142.42 4153.10 "Анатолий Кулаков" Тем более, весь наш storage, весь наш базы данных, она все-таки у нас работает с текстовым протоколом и хранит и отсылает именно текстовые данные.
4153.10 4158.14 "Анатолий Кулаков" Поэтому это будет одна из самых нагруженных частей этой программы.
4158.14 4160.50 "Анатолий Кулаков" Что же делать?
4160.50 4161.78 "Анатолий Кулаков" Во-первых, строки это дорого.
4161.78 4165.94 "Анатолий Кулаков" Это всегда было дорого, но решение придумали еще до появления самих строк.
4165.94 4169.22 "Анатолий Кулаков" Это конечно же использовать байт-аррей, массивы байтиков.
4169.22 4175.66 "Анатолий Кулаков" Массивы байтиков были всегда, в плюсах есть и всяк, они до сих пор как один из самых популярных видов представления строк.
4175.66 4183.62 "Анатолий Кулаков" Но в дотнете мы почему-то не привыкли им использоваться, наверное потому, что редко у нас такая интенсивность приходится на наше дотнет-приложение.
4183.62 4191.54 "Анатолий Кулаков" Но о Янди Дипромах он не зря пишет базу RavenDB и он точно знает, что в базах данных работать нужно только с массивами байт.
4191.54 4201.94 "Анатолий Кулаков" Все остальное от лукавого, если вам нужно какой-то ключ преобразовать в строку, если вам нужно какой-то аутпут для пользователя отдать в виде строки, то вот только тогда и вот только там вы и работаете со строками.
4201.94 4207.34 "Анатолий Кулаков" Все остальные процессинги, все остальные обработки и хранения, и приемы будут работать только с байтами.
4207.34 4208.86 "Анатолий Кулаков" Поэтому массив байт это наше все.
4208.86 4212.26 "Анатолий Кулаков" К сожалению, массив байт нам просто так не поможет.
4212.26 4234.30 "Анатолий Кулаков" Он нам позволит справиться со строками, мы уже не будем там сплитики конкатенейтить, мы это можем уже сделать на rope-стрингах, то есть на сырых массивах байтах, но это не поможет нам избавиться от garbage-коллектора, потому что тот же самый массив байт, его нужно локетить, и его нужно после того, как ты его заиспользовал, его соответственно нужно деструктиризировать, его нужно удалить.
4234.30 4237.42 "Анатолий Кулаков" А это все равно нагрузка на ГЦ.
4237.42 4244.94 "Анатолий Кулаков" Когда у нас таким образом возникает нагрузка на ГЦ, первое, что нужно делать, конечно же, использовать кэш.
4244.94 4247.10 "Анатолий Кулаков" То есть в нашем случае использовать pool.
4247.10 4248.26 "Анатолий Кулаков" Мы можем использовать pool массивов.
4248.26 4258.78 "Анатолий Кулаков" Pool это такая прекрасная штука, из которой вы можете забрать некий массив байтов, и после того, как он вам не нужен, обратно в этот pool сложить.
4258.78 4263.02 "Анатолий Кулаков" При этом заметьте, что память не выделяется и не освобождается.
4263.02 4271.14 "Анатолий Кулаков" Вы один раз, когда создавали pool, можете выделять себе сколько угодно памяти, или вдруг по надобности, если вам вдруг не хватит, еще выделять память.
4271.14 4278.42 "Анатолий Кулаков" Но когда вы складываете обратно, помещаете массив байт обратно в pool, у вас уже ГЦ никак не напрягается, и ничего ему чистить и удалять не надо.
4278.42 4286.46 "Анатолий Кулаков" Pool это прекрасная вещь, но как и с любым кэшом, у нас возникает вечный вопрос.
4286.46 4287.86 "Анатолий Кулаков" А когда-то чистить этот кэш?
4287.86 4290.78 "Анатолий Кулаков" То есть, а когда вообще в этот pool можно возвращать эти массивы?
4290.78 4296.30 "Анатолий Кулаков" Потому что очевидной строчки, когда массив больше не нужен, у нас нет, этот массив байт.
4296.30 4301.54 "Анатолий Кулаков" И вообще это довольно тяжелая задача, если мы начнем ее решать в лоб.
4301.54 4307.22 "Анатолий Кулаков" То есть нам придется городить какие-то флажочки, какие-то мьютексы, как-то отслеживать, как-то передавать.
4307.22 4314.38 "Анатолий Кулаков" Это очень много может вызвать сложностей, и соответственно очень легко допустить ошибку в коде, который будет этим всем управлять.
4314.38 4320.38 "Анатолий Кулаков" Есть один небольшой хак, который позволяет нашу жизнь сделать сладкой и безболезненной.
4320.38 4330.66 "Анатолий Кулаков" Хак заключается в том, что мы можем обернуть наш массив байт в некий классик, назовем его ReducibleBuffer, и у этого классика объявить деструктор.
4330.66 4346.30 "Анатолий Кулаков" Соответственно мы вот эту задачу, которая называется проследить о том, когда этот массив байт используется, и после того, как он перестал использоваться, а поместить его обратно в pool, мы ее перекладываем на Garbage Collector.
4346.30 4349.54 "Анатолий Кулаков" Следующим образом, Garbage Collector и так следит за всеми объектами.
4349.54 4359.94 "Анатолий Кулаков" Соответственно мы заставляем его следить за ReducibleBuffer, и после того, как Garbage Collector увидит, что наш ReducibleBuffer больше никем не используется, никому не нужен, он вызовет деструктор.
4359.94 4370.22 "Анатолий Кулаков" Деструктор мы переопределим, и все, что сделает деструктор, он возьмет наш массив байт и отправит обратно в шареный массив, в шареный pool.
4370.22 4374.10 "Анатолий Кулаков" Напомню, что недавно появилась такая структура встроенная, которая называется ArrayPool.
4374.10 4380.78 "Анатолий Кулаков" У нее есть уже шареный дефолтный instance, который можно брать pool и возвращать pool.
4380.78 4384.50 "Анатолий Кулаков" Вот именно им можно честно воспользоваться, и в деструкторе туда все вернуть.
4384.50 4404.82 "Анатолий Кулаков" Буквально с помощью пяти строчек мы решаем такую огромную проблему, как управление массивом байт, и предлагаем Garbage Collector самому это делать, потому что он это делать умеет отлично, он этого делать уже учится много десятилетий, и там прекрасные алгоритмы и прекрасные программисты, которые все это программируют, будем в целом им доверять.
4404.82 4409.50 "Анатолий Кулаков" Вот, в принципе, и вся оптимизация.
4409.50 4411.38 "Анатолий Кулаков" Что в конце он там к чему приводит?
4411.38 4417.14 "Анатолий Кулаков" Что настоящие вообще пацаны используют именно массивы байт и работают только с массивом байт.
4417.14 4427.18 "Анатолий Кулаков" Если им там нужно что-то парсить, интенсивно работать с нетворком, с диском, сториджем, как я уже говорил, если вы все-таки пишете какую-то базу данных, то рассмотреть этот вариант, он очень часто бывает полезен.
4427.18 4430.58 "Анатолий Кулаков" Это все, что касается интересных оптимизаций.
4430.58 4434.74 "Анатолий Кулаков" Насколько, как я и сказал, никаких там взрывных цифр нету.
4434.74 4440.10 "Анатолий Кулаков" В конце концов, самый лучший его результат, это было около двух миллионов операций в секунду.
4440.10 4442.46 "Анатолий Кулаков" Это смесь между get и set.
4442.46 4447.10 "Анатолий Кулаков" Set, естественно, медленнее, get быстрее, их там в том числе различается по количеству.
4447.10 4452.34 "Анатолий Кулаков" Не суть важна, важен как бы не смысл жизни, а наш путь в этой жизни.
4452.34 4462.94 "Анатолий Кулаков" И, соответственно, он, а я не доказал нам это, потому что все его исследования, все его интересные выводы, то, как он напарывался на какие-то проблемы, на какие-то ошибки, это было очень увлекательно читать.
4462.94 4469.78 "Анатолий Кулаков" Этот челлендж у него растянулся, по-моему, на пару месяцев, начиная с июля, и сейчас кажется, что уже закончился.
4469.78 4484.94 "Анатолий Кулаков" Он обещал сделать какие-то конечные бичмарки, сравнить это с настоящим редисом, сравнить это с тем же самым Dragonfly, но похоже, что цикл статей уже иссяк, и никаких еще последних бичмарков нет.
4484.94 4492.46 "Анатолий Кулаков" Если вдруг они появятся, мы к вам, конечно же, сообщим, но кажется, что на данный момент это все, и, может быть, на этом и стоит завершить.
4492.46 4503.62 "Анатолий Кулаков" Потому что никакого конечного продукта не было целью выпустить, а была цель просто поэкспериментировать со структурами и тем, что у нас есть под рукой, для того, чтобы сделать примерно такую же базу данных.
4503.62 4526.06 "Игорь Лабутин" Прикольно, здорово, на самом деле, именно такие статьи - это хороший пример того, где можно поучиться тому, как делать такую работу в реальных живых проектах, когда у вас что-то где-то драматит, что как померить, на что смотреть, как пользоваться профайлером и какие оптимизации пытаться делать на основании именно выводов, которые выдал профайлер.
4526.06 4537.42 "Анатолий Кулаков" Именно так, отдельно приятно, когда эти статьи очень хорошо разжеваны для новичков, то есть если вы ни разу не запускали профайлер, то эти статьи специально для вас, там со скриншотиками, все красиво написано, обосновано.
4537.42 4549.94 "Анатолий Кулаков" И самое прекрасное, что обосновывают, это один, наверное, из лучших экспертов по базе данных в дотнет-среде, потому что кто лучше Айенди у нас разбирается одновременно и в дотнете, и в базе данных одновременно хорошо, я даже не могу вспомнить.
4549.94 4556.38 "Анатолий Кулаков" То есть это человек, который способен объяснить именно настоящие причины, сделать правильные выводы и направить вас именно туда, куда вам нужно идти.
4556.38 4557.38 "Анатолий Кулаков" Прекрасно.
4557.38 4562.94 "Игорь Лабутин" Так, давай немножко отличимся от статей, еще поговорим про одну новость.
4562.94 4616.30 "Игорь Лабутин" Я периодически вспоминаю про такую штуку как dotnet community toolkit, и вот вышла очередная версия, в этот раз это прям релиз-релиз, мажорный релиз 8.0, при этом ну каких-то прям суперизменений там нет, но тем не менее, это действительно большой мажорный релиз, надо напомнить, что в этот community toolkit, который раньше был частью Windows community toolkit, но дотнетная часть была выделена отдельно, основной его кусочек это mvvm toolkit, если вы пишете на ui-чке, на vpf, то mvvm toolkit это одна из вещей, которые рекомендую посмотреть, если вы слышали про такую библиотеку как mvvm lite, то mvvm toolkit фактически его, так сказать, последователь, настолько последователь, что даже автор mvvm lite как-то поучаствовал в mvvm toolkit и сказал, что да, это можно считать официальным наследником.
4616.30 4650.06 "Игорь Лабутин" Так вот, в нем довольно много изменений, они подтянули 6.dotnet и, соответственно, подтянули кучу всяких клевых фич, типа там новые source-генераторы, они, значит, добавили кучу всяких мелких изменений, которые теперь дает 6.dotnet, они теперь, у них есть официальное приложение, так сказать, пример, то есть если раньше mvvm toolkit это просто была документация + либо, теперь есть прям пример приложения, подписан с помощью mvvm toolkit, и если вам интересно, можно посмотреть, как его использовать.
4650.06 4675.78 "Игорь Лабутин" Ну и раз уж подтянули 6.dotnet, то завезли всякие штуки, типа включили trimming по умолчанию, но при всем при этом надо понимать, что весь toolkit таргетит dotnet standard 2.0, поэтому если вы его используете на какой-нибудь там, даже старом фреймворке, ну достаточно новом, типа там 4.8, то все вполне будет работать, несмотря на то, что сам toolkit скомпилен 6.dotnet.
4675.78 4695.10 "Игорь Лабутин" Так что не знаю, насколько широко его применение и использование, но кажется, как пример того, куда можно заглянуть, подсмотреть код, в том числе какой-то относящий к high performance или диагностике, потому что там есть такие разделы, мне кажется, вполне отличный вариант.
4695.10 4705.38 "Анатолий Кулаков" Ну да, как пример вот этого хорошего качественного open source, где можно грамотные вещи найти и очень полезные на практике, потому что все-таки на практике, я думаю, используются все эти toolkit не слабо.
4705.38 4709.74 "Анатолий Кулаков" В общем, это хорошая репозитория, хорошая идея.
4709.74 4713.02 "Игорь Лабутин" Ну и давай пойдем дальше, у нас осталась последняя статейка.
4713.02 4717.78 "Анатолий Кулаков" Да, давай под вечер что-нибудь такое более философское, более архитектурное разберем.
4717.78 4737.10 "Анатолий Кулаков" Нас спасает, как всегда, в последних выпусках Марк Симон, у нас стандартная рубрика, пробегаемся по основам архитектуры и очень хочется, чтобы вы тоже как-то приобщились к этому автору, которого я безуздешно люблю, всегда обожаю перечитывать и всегда нахожу что-то новое и интересное.
4737.10 4758.22 "Анатолий Кулаков" И одно из самых, я бы не сказал, что больших, но значимых откровений в моей жизни, когда-то многие десятилетия назад, это было откровение, которое сегодня я вам хочу тоже рассказать, вот эта статья, несмотря на то, что она очень старая, но я по-прежнему встречаю до сих пор вот эту ошибку, распространенную в коде очень-очень много.
4758.22 4772.22 "Анатолий Кулаков" Вот хотелось бы тоже вам этот вброс сделать, поэтому расслабьтесь, откиньтесь на спинку кресла, расслабьте ваш мозг и попытайтесь воспринять любую информацию, даже если на первый взгляд она вам кажется неимоверной и страшной.
4772.22 4784.22 "Анатолий Кулаков" А поговорим мы сегодня с вами, дорогие друзья, о таком замечательном методе, который называется IsNullOrWhitespace из небезызвестного класса String.
4784.22 4792.22 "Анатолий Кулаков" Этот метод таит в себе ментальную ловушку, давайте немножко ближе разберемся и узнаем какую.
4792.22 4798.66 "Анатолий Кулаков" Нужно сказать, что не только этот метод виноват во всех наших несчастьях, но еще и его собрат, который называется IsNullOrEmpty.
4798.66 4813.58 "Анатолий Кулаков" Вот два вот этих гада, они нам говорят о том, что они навязывают реальность, в которой нам сообщают о том, что null и whitespace это одно и то же.
4813.58 4815.94 "Анатолий Кулаков" Это в принципе эквивалентные вещи.
4815.94 4824.82 "Анатолий Кулаков" Раз мы их проверяем с помощью одного метода и скорее всего поведение у нас будет соответственно одно и то же, значит между ним есть какая-то эквивалентность.
4824.82 4827.18 "Анатолий Кулаков" Но на самом деле это не так.
4827.18 4833.54 "Анатолий Кулаков" Null никогда не может быть эквивалентен любому значению, потому что null это отсутствие значения.
4833.54 4839.30 "Анатолий Кулаков" А если мы говорим про пустую строку или про whitespace, то это как раз такие значения.
4839.30 4841.90 "Анатолий Кулаков" Это нормальное значение типа string.
4841.90 4845.74 "Анатолий Кулаков" Оно есть и оно может иметь какой-то смысл.
4845.74 4855.62 "Анатолий Кулаков" И приравнивать это все к какой-то эквивалентности, заворачивать это все в одну проверку, заворачивать это все в какой-то один код, один метод, это большая-большая ошибка.
4855.62 4860.74 "Анатолий Кулаков" К сожалению, очень много этот метод используется и в очень неправильных местах.
4860.74 4864.14 "Анатолий Кулаков" Давайте разберем несколько примеров.
4864.14 4869.02 "Анатолий Кулаков" Допустим вам нужно написать какой-нибудь сервис для поиска музыки.
4869.02 4873.46 "Анатолий Кулаков" То есть вы пишете какой-то алгоритм, который ищет по пользовательному запросу музыку.
4873.46 4874.90 "Анатолий Кулаков" Допустим база данных музыки у вас есть.
4874.90 4888.54 "Анатолий Кулаков" Но проблема, самая примитивная база проблема заключается в том, что пользователи обычно ищут названия групп, особенно длинных групп, которые создают из нескольких слов, произвольно, как им вздумается.
4888.54 4895.46 "Анатолий Кулаков" Например, если у нас есть группа "тролль гнет ель", там три слова, ее легко могут искать как по слову "тролль", как по слову "ель", так же по слову "гнет".
4895.46 4903.18 "Анатолий Кулаков" Все эти слова довольно уникальны и пользователь вполне правомерно ожидает, что в каком-то топе выданных результатов он свою группу найдет.
4903.18 4912.82 "Анатолий Кулаков" Соответственно, он может написать по одному слову, он может написать их в разных регистрах, он может перебутать их местами, это все нормально, это все мы должны учитывать.
4912.82 4922.14 "Анатолий Кулаков" Для того, чтобы хоть как-то это учитывать, мы должны привести название в какую-нибудь каноничную форму, чтобы на эту каноничную форму наложить какой-нибудь индекс и уже по ней искать.
4922.14 4934.54 "Анатолий Кулаков" Ну, самым примитивным способом, отбросив все сложности, будет каноничная форма, что мы просто-напросто берем все слова в названии группы, приводим в нижний регистр и сортируем все слова по алфавиту.
4934.54 4942.42 "Анатолий Кулаков" Потому что в каком порядке там он не вел, мы все равно его вот преобразовали в канонический вид, в нормальную форму и все равно нашли.
4942.42 4947.74 "Анатолий Кулаков" Например, в нашем случае будет "гнет", "ель", "тролль" по алфавиту и все в ловеркейсе.
4947.74 4952.42 "Анатолий Кулаков" Таким образом, мы всегда по этому индексу, по этой каноничной форме сможем определить эту группу.
4952.42 4981.70 "Анатолий Кулаков" Если мы возвращаемся к языку C#, то самым примитивной реализацией будет следующий код, что мы берем "search_chome", то есть то значение, которое нам передал пользователь, сплитим его по пробельчику, что между словами, там у нас обычно пробелы, делаем "select", делаем трансформацию к ловеркейсу, упорядочиваем с помощью метода "order_by", упорядочиваем это все по алфавиту и, соответственно, с помощью метода "aggregate" агрегируем все слова через пробельчик.
4981.70 4987.06 "Анатолий Кулаков" Вот, казалось бы, примитивная имплементация, приводок к канонической форме, все хорошо, все работает.
4987.06 4988.62 "Анатолий Кулаков" Теперь давайте немножко усложнять.
4988.62 4993.02 "Анатолий Кулаков" Допустим, наш пользователь может ввести дополнительные пробельчики между словами.
4993.02 4999.98 "Анатолий Кулаков" Это тоже нормально, как бы два раза щелкнуть по пробелу, для пользователя это незначимый символ, и он рассчитывает на то, что мы их никак не учтем.
4999.98 5005.82 "Анатолий Кулаков" Наш алгоритм сейчас к этому не готов, он это учитывает, соответственно, сделает неправильную каноническую форму.
5005.82 5006.82 "Анатолий Кулаков" Чтобы это исправить, это довольно легко.
5006.82 5022.22 "Анатолий Кулаков" В методе "split", который сплитит, разбивает на слова пользовательский input, нам достаточно указать такой яномчик, который называется "remove empty entries", который как раз таки удаляет ненужные излишние пробелы, если вдруг они там появились.
5022.22 5025.10 "Анатолий Кулаков" Все, алгоритм запросто работает дальше.
5025.10 5027.94 "Анатолий Кулаков" Дальше возникает еще интересная ситуация.
5027.94 5035.78 "Анатолий Кулаков" Если мы пишем тесты или еще что-то, нам обязательно захочется передать в наш алгоритм "null".
5035.78 5041.50 "Анатолий Кулаков" Казалось бы, если наш термин будет равняться "null", что должно происходить?
5041.50 5047.66 "Анатолий Кулаков" Ну, наверное, каждый разработчик вам скажет, что "null" - это невалидный input для нашего алгоритма.
5047.66 5060.70 "Анатолий Кулаков" Мы не знаем, что с ним делать, и мы не хотим его никаким образом использовать, потому что очевидно, что никто в здравом уме по "null" искать песни, искать авторов, искать группы не будет.
5060.70 5066.62 "Анатолий Кулаков" Значит, "null" для нас - это невалидный input, и мы вполне вправе бросить исключение.
5066.62 5069.54 "Анатолий Кулаков" Отличный вывод, в принципе, никаких претензий к нему нет.
5069.54 5076.40 "Анатолий Кулаков" Обычно такие исключения заворачиваются не в проверку на "null", а заворачивается вот этот наш вышеупомянутый метод.
5076.40 5081.46 "Анатолий Кулаков" If string is null or a whitespace term, тогда бросить аргумент null exception.
5081.46 5083.74 "Анатолий Кулаков" И вот здесь уже начинаются проблемы.
5083.74 5087.94 "Анатолий Кулаков" То есть, когда мы говорим, что "null" - это невалидный input, это нормально.
5087.94 5095.10 "Анатолий Кулаков" Но когда мы начинаем говорить, что пустая строка или whitespace - это невалидный input, здесь уже кроются проблемы.
5095.10 5097.42 "Анатолий Кулаков" Давайте разберем их поближе.
5097.42 5102.02 "Анатолий Кулаков" Во-первых, при таком банальном подходе у нас будет неправильное сообщение в эксепшене.
5102.02 5109.94 "Анатолий Кулаков" В эксепшене нам скажут, что у вас... если мы передадим туда пустую строку, да, в эксепшене нам скажут, что аргумент null exception.
5109.94 5110.94 "Анатолий Кулаков" Но это не так.
5110.94 5114.26 "Анатолий Кулаков" По ради мы туда передали пустую строку, это уже не null exception.
5114.26 5126.54 "Анатолий Кулаков" Здесь можно легко заменить исключение аргумент null exception на аргумент exception, но ситуация-то не очень улучшит, потому что если мы передаем все-таки туда null, то нам хотелось бы иметь аргумент null exception.
5126.54 5129.02 "Анатолий Кулаков" Соответственно, у нас уже появляются здесь какие-то две проверки.
5129.02 5138.10 "Анатолий Кулаков" И если продолжать дальше в том же самом духе, то возникает вот эта вот увеличенная неправильная непонятная сложность, которую мы сами себе ввели.
5138.10 5140.38 "Анатолий Кулаков" Не очень понятно, зачем мы это сделали.
5140.38 5153.10 "Анатолий Кулаков" Потому что на самом деле термин, если он состоит из пробелов или он состоит из каких-то whitespaces, это вполне валидное значение.
5153.10 5155.98 "Анатолий Кулаков" Его вполне может проживать наш алгоритм.
5155.98 5162.74 "Анатолий Кулаков" Он с ним способен справиться и способен выводить адекватный ответ в тех рамках, в которые мы его писали.
5162.74 5168.30 "Анатолий Кулаков" Никакого смысла бросать исключение на валидный входной аргумент, нет.
5168.30 5173.78 "Анатолий Кулаков" Единственное, что у нас считается неправильным input, это все-таки null.
5173.78 5176.78 "Анатолий Кулаков" Таким образом, правильный код будет заключаться в следующем.
5176.78 5182.70 "Анатолий Кулаков" В начале нашего алгоритма мы должны проверить, термин равно null, тогда бросить аргумент null exception.
5182.70 5185.86 "Анатолий Кулаков" Вот это самая правильная проверка, которая и должна быть во всех программах.
5185.86 5187.30 "Анатолий Кулаков" Именно чистая проверка на null.
5187.30 5188.46 "Анатолий Кулаков" Ничего больше, ничего меньше.
5188.46 5195.54 "Анатолий Кулаков" Если у нас же там есть какие-то пробельные символы, просто не обращаем на них внимания, а делаем наш алгоритм таким образом, чтобы он их поддерживал.
5195.54 5200.02 "Анатолий Кулаков" Во-первых, как я уже сказал, это remove_entry, empty_entries, которые мы добавляем в split.
5200.02 5208.54 "Анатолий Кулаков" Во-вторых, мы инициализируем агрегат с помощью пустой строки, что позволяет ему получить начальное значение уже пустую строку, а не null.
5208.54 5219.14 "Анатолий Кулаков" И во-вторых, в конце мы к нашему результату, к нашему каноническому имени, применяем метод trim, который позволяет избавиться от аргумента, от пробелов, соответственно, на его концах.
5219.14 5227.90 "Анатолий Кулаков" Таким образом, мы независимо от того, какое значение к нам пришло в стринге, кроме null, мы его обрабатываем всегда правильно, хорошо и интересно.
5227.90 5248.14 "Анатолий Кулаков" И хочется еще раз вернуться к этому догмату, что проблема заключается в том, что null or whitespace, или он же is_null or empty, заключается в том, что эти методы пытаются наш мозг поймать в ментальную ловушку.
5248.14 5252.26 "Анатолий Кулаков" Они говорят о том, что null каким-то образом может быть эквивалентен whitespace.
5252.26 5253.86 "Анатолий Кулаков" Это не так.
5253.86 5259.30 "Анатолий Кулаков" Такого быть не может и в большинстве случаев таковым оно и не является.
5259.30 5266.86 "Анатолий Кулаков" С whitespace вы можете прекрасно манипулировать, вы можете производить с ними те же самые действия, как и с обычными строками.
5266.86 5271.90 "Анатолий Кулаков" Ничего в созгаритмической, спрактической или стоктической точке зрения не меняется абсолютно.
5271.90 5284.90 "Анатолий Кулаков" Но если вы подойдетесь на эту ловушку, то ментально вы будете понимать, что null, пробелы и пустые строки у вас где-то находятся в категории невалидных данных.
5284.90 5291.98 "Анатолий Кулаков" И вы тогда будете везде воспринимать и проверять эти данные, считать их невалидными.
5291.98 5298.94 "Анатолий Кулаков" Это очень опасно и в большинстве случаев может привести даже к каким-то потенциальным ошибкам.
5298.94 5301.30 "Анатолий Кулаков" Поэтому не поддавайтесь на эту ловушку.
5301.30 5305.94 "Анатолий Кулаков" Пробел, пустая строка и все, что с ними связано это нормальные валидные данные.
5305.94 5309.02 "Анатолий Кулаков" Если это нормальные валидные данные, их надо пытаться обрабатывать.
5309.02 5311.66 "Анатолий Кулаков" Зачем отказываться от тех данных, которых вы можете обработать.
5311.66 5317.14 "Анатолий Кулаков" Естественно, если в вашей логике это имеет место быть, но это точно не должно быть никакого исключения.
5317.14 5330.34 "Анатолий Кулаков" Потому что если пользователь передает null, он программист, в данном случае в нашей библиотеке, он ожидает какое-то исключение, то есть он передает пустую строку и знает, что со строками мы умеем работать, то он все-таки не ожидает никакого исключения.
5330.34 5339.22 "Анатолий Кулаков" Если ваша библиотека начнет на empty и на l, бросать исключения, а на обычной строке возвращать данные, это вызовет как минимум когнитивный диссонанс.
5339.22 5344.30 "Анатолий Кулаков" Поэтому не стройте такой API, не делайте так внутри и старайтесь избегать таких вещей.
5344.30 5357.46 "Анатолий Кулаков" И еще одна связанная статичка, которая нас подводит на основе того, что мы немножко выше обсудили, еще к интересному выводу.
5357.46 5364.94 "Анатолий Кулаков" Также для ее понимания вам нужно будет вспомнить Primitive Obsessions, который мы тоже обсуждали несколько выпусков назад.
5364.94 5367.54 "Анатолий Кулаков" Если вы вдруг забыли, то можно переслушать.
5367.54 5389.14 "Анатолий Кулаков" А я кратко напомню, что Primitive Obsessions, то есть озабоченность с примитивами, это возможность программирования, когда вы вместо каких-то значимых бизнес-объектов, таких как деньги, такие как дата, такие как сумма, зарплата, еще что-то, вы используете примитивные типы, такие как int, string.
5389.14 5392.22 "Анатолий Кулаков" У нас был хороший пример, это телефон, email.
5392.22 5396.78 "Анатолий Кулаков" В качестве телефона, email нужно использовать специальные классы, а не простые строки.
5396.78 5406.54 "Анатолий Кулаков" Если мы соединим вот эти два знания, которые мы слышали сегодня и Primitive Obsessions, у нас возникает еще один интересный примерчик, который я вижу практически абсолютно везде.
5406.54 5414.74 "Анатолий Кулаков" Еще раз, включите воображение и представьте себе кусок кода, который я сейчас попытаюсь описать словами.
5414.74 5418.78 "Анатолий Кулаков" Представьте метод контроллера, который называется getUser.
5418.78 5429.10 "Анатолий Кулаков" В качестве параметра метод getUser принимает юзернейм, то есть мы пытаемся вернуть по имени пользователя нам пользователя, то есть какой-то результат.
5429.10 5431.66 "Анатолий Кулаков" Что очень часто бывает.
5431.66 5438.78 "Анатолий Кулаков" В первой строчке прежде всего проверяется, string isNullOrEmpty или string isNullOrWhitespace на юзернейма.
5438.78 5447.06 "Анатолий Кулаков" Если вдруг юзернейм у нас содержит какие-то whitespaces, то есть состоит только из whitespaces, у нас сбросается инвалид юзернейм, exception, то есть bad request.
5447.06 5449.18 "Анатолий Кулаков" Из контроллера возвращается bad request.
5449.18 5452.18 "Анатолий Кулаков" Если же все хорошо, то мы вызываем репозиторию.
5452.18 5459.38 "Анатолий Кулаков" У этого репозитория есть метод findUserByName, передаем туда имя и того юзера, которого получили, возвращаем обратно.
5459.38 5462.18 "Анатолий Кулаков" В общем, дальше судьба нас этого юзера не интересует.
5462.18 5464.10 "Анатолий Кулаков" Теперь давайте подробнее разберем этот код.
5464.10 5474.06 "Анатолий Кулаков" Если вы спросите разработчика, почему в первой строчке он все-таки проверил юзернейм на null or whitespace, он вам сразу же ответит, что таково требование бизнес-логики.
5474.06 5478.78 "Анатолий Кулаков" То есть бизнес сказал обычно, что имя пользователя не может состоять из пробелов.
5478.78 5482.74 "Анатолий Кулаков" Это как бы логичное заявление бизнеса.
5482.74 5488.02 "Анатолий Кулаков" Если вдруг вы его спросите, он вам точно подтвердит, что имя пользователя никакой без пробелов состоять не может.
5488.02 5496.82 "Анатолий Кулаков" Но в данном случае, да, с бизнесом мы спорить не можем, с бизнес-логикой мы спорить не можем, но в данном случае все здесь является бизнес-логикой.
5496.82 5506.26 "Анатолий Кулаков" Во-первых, если вдруг это проверка, которая проверяет на бизнес-требование, что пользователь не может состоять из пробелов, если это действительно проверка бизнеса, то что она делает в контроллере?
5506.26 5507.26 "Анатолий Кулаков" Вообще абсолютно непонятно.
5507.26 5522.66 "Анатолий Кулаков" А если мы в одном методе контроллера проверили это бизнес-правило, то в другом методе контроллера, который будет по пользе не get пользователя делать, а обновлять имя или выставлять новое имя, мы тоже должны эту проверку повторить?
5522.66 5531.10 "Анатолий Кулаков" То есть получается, что везде, где мы работаем с именем пользователя, нам нужно эту проверку каким-то образом повторять, каким-то образом тестировать, каким-то образом не забывать использовать.
5531.10 5538.82 "Анатолий Кулаков" И вот здесь вовсю возникает как раз-таки вот эти наши два код смела, которых мы обсудили.
5538.82 5551.90 "Анатолий Кулаков" Во-первых, это неправильное использование null or white trace, потому что мы сейчас смешиваем неправомерные данные, которых никогда не может быть, и нормальные данные, которые просто не проходят валидацию по бизнес-требованиям.
5551.90 5568.82 "Анатолий Кулаков" И второе – это primitive obsession, когда мы пытаемся в одном месте проверить строчку и дальше везде в коде надеяться на то, что этот юзернейм, он везде будет проверяться, и его везде уже до нас проверили, если мы будем вдруг этот юзернейм где-то использовать.
5568.82 5570.38 "Анатолий Кулаков" В общем, все это плохо.
5570.38 5575.70 "Анатолий Кулаков" Решается это, как вы, наверное, уже поняли, с помощью обертки все в строго типизированный тип.
5575.70 5585.30 "Анатолий Кулаков" Вместо строки мы должны завести отдельный тип, который называется юзернейм и энкапсулировать туда всю бизнес-логику, которая отвечает за проверки.
5585.30 5592.74 "Анатолий Кулаков" Это будет одно единственное место, которое не надо больше дублировать, которое будет сосредоточено в одном классе.
5592.74 5604.78 "Анатолий Кулаков" Соответственно, там мы уже сможем распарсить пользователя, там мы уже сможем понять, из чего у него состоит имя, может ли имя содержать такие символы или по нашей бизнес-логике оно содержать не может.
5604.78 5610.38 "Анатолий Кулаков" И, соответственно, как только мы это сделаем, наш контроллер преображается в идеальный код.
5610.38 5611.90 "Анатолий Кулаков" Выглядит он будет следующим образом.
5611.90 5622.06 "Анатолий Кулаков" Представьте себе метод getUserByName, к нему приходит строка в виде юзернейма, и первым делом, что вы делаете, у нашего нового класса юзернейм вызывайте метод tryParse.
5622.06 5630.26 "Анатолий Кулаков" Всю бизнес-логику, может ли такое имя существовать, должно определять только как раз-таки класс, отвечающий за бизнес-валидацию.
5630.26 5643.10 "Анатолий Кулаков" Ни в коем случае контроллер не может знать, бывают ли у вас пользователи с пустыми пробелами, бывает ли у вас банковский счет, который может состоять из пробелов, бывает ли у вас пароли, которые состоят там из 10 пробелов.
5643.10 5648.82 "Анатолий Кулаков" Ни в коем случае никакой контроллер эти проверки делать не должен, потому что это не его собачье дело.
5648.82 5650.62 "Анатолий Кулаков" Это дело бизнес-логики.
5650.62 5664.58 "Анатолий Кулаков" И вот если мы отдаем все это в место, которое отвечает полностью, одно единственное актуальное место, которое отвечает полностью за бизнес-логику, у нас получается такой прекрасный код юзернейм tryParse, отдаем туда юзернейм.
5664.58 5672.54 "Анатолий Кулаков" Если мы его прекрасно не смогли распарсить, тогда возвращаем bad result с каким-то сообщением об ошибке, все нормально.
5672.54 5682.02 "Анатолий Кулаков" Если же мы его смогли распарсить, то в результате tryParse у нас уже появляется не строка, а строго типизированный юзернейм, который принимает репозиторий.
5682.02 5692.30 "Анатолий Кулаков" То есть репозиторию уже тоже не нужно заботиться о том, проверили ли вы все это на бизнес ваши правила, есть ли там null в этой строке, есть ли там пробельщики в этой строке.
5692.30 5694.46 "Анатолий Кулаков" Во всех этих глупостях репозиторий больше не заботится.
5694.46 5701.14 "Анатолий Кулаков" Во всех своих 100 методах, которые принимают юзернеймы или каким-то образом обрабатывают юзернеймы, репозиторий больше не заботится.
5701.14 5709.98 "Анатолий Кулаков" Как только вы отдаете ему строго типизированный класс, который называется класс юзернейм, он уже четко знает, что уже все проверено, все хорошо, дальше я работаю только над своей функциональностью.
5709.98 5715.98 "Анатолий Кулаков" Я ищу пользователей, я что-то с ними делаю, никак не загоняясь над проверкой того, что вы мне передали.
5715.98 5729.74 "Анатолий Кулаков" И соответственно результат заключается в том, что вы в одном месте сосредотачиваете свою бизнес логику и прочие плюшки от исключения примитива обсессион из вашей повседневной практики, которую мы обсуждали в прошлых выпусках.
5729.74 5735.86 "Анатолий Кулаков" Здесь, наверное, стоит задать резонный вопрос, а не ли over-engineering это все?
5735.86 5738.42 "Анатолий Кулаков" То есть не слишком ли мы переусложнили?
5738.42 5753.90 "Анатолий Кулаков" Потому что в предыдущем нашем коде мы всего лишь навсего передали одну строчку, а здесь нам пришлось написать около 50 строк кода для того, чтобы сделать хороший красивый юзернейм со всякими equals, stripe arse, с валидацией, с exception, в общем, чтобы он был красивый и хороший.
5753.90 5759.58 "Анатолий Кулаков" То есть плюс 50 строчек, плюс тесты, то есть 15 минут разработки мы точно как-то потеряли.
5759.58 5765.82 "Анатолий Кулаков" И вот, соответственно, автор тоже задается, а не переусложнили ли это все?
5765.82 5780.38 "Анатолий Кулаков" Но здесь стоит напомнить, что, во-первых, если раньше у вас вся ваша бизнес-логика дублировалась во многих местах, вы должны были не забыть вот этот юзернейм во всех этих местах проверить на все ваши бизнес-правила.
5780.38 5783.62 "Анатолий Кулаков" А чем больше бизнес-правил будет становиться в будущем, тем сложнее эти проверки будут.
5783.62 5808.82 "Анатолий Кулаков" Во-вторых, учитывая тот факт, что у вас по коду гулять будет именно строка, соответственно, каждый метод, который принимает эту строку и рассчитывает, что там юзернейм тоже должен все эти проверки по-хорошему повторить или надеяться, опять же, что за него это кто-то сделал, а эта надежда – это самое плохое, что может быть в коде, потому что она очень легко пришедшим джуниорам завтра поменяется, и он об этом ничего знать не будет, и совесть его даже совершенно мучить от этого не будет.
5808.82 5826.14 "Анатолий Кулаков" В общем, учитывая то, сколько проблем нам в будущем может принести поддержка этого кода, сколько проблем нам в будущем могут доставить ошибки в этом коде, потратить лишние 15 минут и обезопасить себя абсолютно навсегда от этих проблем, кажется, что это не такая большая плата.
5826.14 5841.62 "Анатолий Кулаков" Вот такие откровения от Марка Симона, если хотите больше аргументаций, если хотите код все-таки не воспринимать на слух, а посмотреть в листинге, то ссылки, соответственно, ко всем нашим статьям у нас всегда в шоу-нотах, милости просим, проходите, читайте.
5841.62 5853.26 "Игорь Лабутин" Да, монументальный труд, ну в смысле, что Марк действительно давно и плотно пишет про всякие такие штуки, и интересно иногда вернуться к старым статьям, почитать.
5853.26 5858.50 "Игорь Лабутин" Хотя я вот что-то как-то так и не использую этот подход в коде, все стрингами постаренькие.
5858.50 5864.50 "Анатолий Кулаков" Наверное, еще не попадался, когда у тебя будет большая команда и много джунов, ты пожалеешь.
5864.50 5868.62 "Игорь Лабутин" Возможно, возможно, пока еще справляемся как-то.
5868.62 5883.22 "Игорь Лабутин" Ладно, давай заканчивать, сегодня мы после долгого перерыва посмотрели на дотнодфраймворк481, успело за наше отсутствие выйти и дотнодсемпревью6, и дотнодсемпревью7, которые мы кратенько посмотрели и выяснили, что в них новенького.
5883.22 5889.18 "Игорь Лабутин" Напоминаю, что это последние превьюшки, следующие обещаны уже релиз кандидат 1.
5889.18 5896.94 "Игорь Лабутин" Обновился Nougat 6.3 с транситивными зависимостями, плавающими версиями и другими мелкими плюшками.
5896.94 5906.82 "Игорь Лабутин" Обновились Visual Studio 2022 версии 17.3, появился 17.4.1 с поддержкой ARM64.
5906.82 5920.42 "Игорь Лабутин" Последили за перипетиями попытки построить клоун рейдиса на C# и к чему может привести это, и заодно выучили какие-то оптимизации, техники, подходы к тому, как надо профилировать и оптимизировать код.
5920.42 5937.66 "Игорь Лабутин" Узнали, что вышел в дотнодкомьюнити Toolkit 8.0 с обновлением MVVM Toolkit, и порассуждали опять на тему, как нам использовать примитивные типы в коде, и передавать ли все строчками, либо все-таки писать специальные типы.
5937.66 5941.18 "Игорь Лабутин" И на этом на сегодня, думаю, все.
5941.18 5943.18 "Анатолий Кулаков" Да, да, давай заканчивать.
5943.18 5946.54 "Анатолий Кулаков" Друзья, большое спасибо, что слушаете нас, что дослушали до конца.
5946.54 5949.46 "Анатолий Кулаков" Я напоминаю, что мы с радостью принимаем любой ваш фидбэк.
5949.46 5958.26 "Анатолий Кулаков" В основном у нас сейчас комментарии пишут на ютубчике, поэтому заходите, пишите к выпуску на ютубе к этому комментарию, а также во всех любых социальных сетях.
5958.26 5965.18 "Анатолий Кулаков" Находите нас, делитесь фидбэком, расшарьте этот выпуск среди друзей, рекомендуйте, нам будет очень-очень приятно.
5965.18 5970.30 "Игорь Лабутин" Это был 56 выпуск радио.нтент, с вами были Игорь Лабутин
5970.30 5972.42 "Анатолий Кулаков" и Анатолий Кулаков. Всем пока!
5972.42 5972.92 "Игорь Лабутин" Пока!
5972.92 5973.92 "Игорь Лабутин" Счастливо!
