0.00 11.14 "Анатолий Кулаков" Приветствую, дорогие слушатели, в эфире Радио.нет и выпуск номер 116.
11.14 14.68 "Анатолий Кулаков" В студии его постоянные ведущие Анатолий Кулаков
14.68 15.68 "Игорь Лабутин" и Игорь Лабутин.
15.68 16.68 "Игорь Лабутин" Всем привет.
16.68 22.68 "Анатолий Кулаков" А вне студии наши замечательные золотые друзья, хотелось бы вам их представить.
22.68 35.04 "Анатолий Кулаков" Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Шевченко Антон, Ольга-молодец-Бондаренко, она приходит к нам на митапчики, будьте как Ольга, ходите на митапы.
35.04 45.34 "Анатолий Кулаков" Сергей Краснов, Константин Ушаков, Постарнаков Андрей, Дмитрий Сорокин, Дмитрий Павлов, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Лазарев Илья, Тимофей и Виталий.
45.34 48.60 "Анатолий Кулаков" Огромное спасибо всем, кто поддерживает нас на бусти.
48.60 52.16 "Анатолий Кулаков" Если вы не среди этого списка, то присоединяйтесь, у нас
52.16 53.16 "Игорь Лабутин" там весело.
53.16 59.44 "Игорь Лабутин" И нас по-прежнему поддерживает компания Altenar, разработчик масштабируемых надежных решений для индустрии спортивных данных.
59.44 72.28 "Игорь Лабутин" В основе большинства продуктов – дотнет и c-sharp – используются удобные DE, облачные платформы, можно качать английский для общения, а для сотрудников, которые вносят большой вклад, возможно продолжение карьеры в европейском офисе.
72.28 86.60 "Игорь Лабутин" Ребята активно делятся опытом, проводят митапы, вот у нас недавно прошел спб.дотнет.митап, где были доклады про серилок и опробовал тест, если вдруг пропустили можно посмотреть в записи, а в целом за новостями компании можно следить в телеграм-канале.
86.60 95.00 "Анатолий Кулаков" Ну у нас сегодня интересные новости, в принципе от микрософта небольшие, но вполне значимые какие-то события были и кое-что еще разберем.
95.00 97.72 "Анатолий Кулаков" Давай по врядочку, что у нас от микрософта все-таки.
97.72 103.24 "Игорь Лабутин" Да, у нас много чего от всяких разных компаний, интересного и новиночного.
103.24 115.40 "Игорь Лабутин" Начнем мы с Microsoft, dotnet runtime, dotnet вообще в целом пока молчит про поводу очередных превью, никаких вам превью пятых не выходит, зато Aspire продолжает свой релизный цикл.
115.40 130.00 "Игорь Лабутин" Напомню, что мы обсуждали несколько месяцев назад, что у них была цель делать релизы достаточно часто, что типа чуть ли не раз в месяц, вот они этому примерно следуют, вышел dotnetaspire 9.3, где есть некоторое количество изменений.
130.00 313.88 "Игорь Лабутин" В основном они конечно же касаются копайлота, копайлот добрался и сюда, он теперь встроен в дашборд и утверждается, что внутри этого самого дашборда он вам поможет ревьюить автоматически сотни ваших логов, ну записей логов понятное дело, поможет изучать всякие причины того, что у вас ничего не работает, автоматически будет подсвечивать какие-то проблемы перформанса в ваших трейсах, наверное одна из самых может быть полезных вещей будет смотреть на ваши ошибки и роркады, которые какие-то странные, эксепшены и пользуясь гигантской своей базой знаний сразу говорить в чем же проблема и где нужно что исправить, вот единственное, что как я понял, я не пробовал эту часть сам, что будет он доступен только если вы запускаете ваше Aspire приложение из Visual Studio и Visual Studio Code, но вероятно это как-то связано там, не знаю, с лицензиями, ключами, еще чем-нибудь, то есть если вы просто через там dotnet run запустите ваш Aspire проект, видимо работать эта штука не будет, но если из Studio и Visual Studio Code, то будет нормально, вот, но понятно одним AI-м дело не обходится, есть и другие нововведения, во-первых в Dashboard напомню, что там появился ресурс граф в одном из недавних релизов и теперь в этом ресурс графе на нодах можно поддерживать контекстные менюшки, в которых есть пункты для того чтобы посмотреть телеметрию соответствующей ноды, выполнить команды которые соответствуют этому объекту вашей модели приложений или посмотреть логи конкретной ноды, в принципе удобно если вы работаете с этим, граф view, а также довольно тоже полезные изменения, напомню что в Aspire есть понятие трейсов, ну в смысле он умеет отображать трейсы, то есть это некоторое дривовидное представление того как ваша операция выполнялась с указанием всех нод на которые она выполнялась, то есть если был вызов в какую-то там базу данных например, то будет определенный кусочек времени, ну на графике будет соответственно отображено, что количество времени с такого-то по такое-то время выполнялась операция на базе данных или еще где-нибудь, так вот сейчас .NET Aspire стал достаточно умным, чтобы понимать и отображать внешние вызовы исходящие даже если компонент, в который этот вызов происходит не поддерживает никакой трейсинг, то есть даже если ваша база данных не умеет писать никакие трейсы, ничего никуда не пишет или какой-то сторонний сервис, который вы вызываете, понятно, что можно понять, что вы вызвали этот сервис, например, если это какой-то HTTP сервис, то со стороны HTTP клиента трейсинг есть, то есть есть понимание, что вы какой-то URL вызвали, там что-то подделалось в какое-то время, мы не знаем сколько из этого времени заняла сетевая часть, мы не знаем сколько из этого времени заняла собственно обработка запроса, сколько заняло время возврата ответа опять же через сеть, но мы в целом знаем, что с момента, как мы зашли в HTTP клиент, до момента, когда мы получили ответ, прошло какое-то время.
313.88 325.96 "Игорь Лабутин" И вот теперь Aspire умеет эти все кусочки отображать на графике трейсов, что в принципе может быть полезно, особенно если вы интегрируетесь с чем-то, что действительно не имитит трейсы или имитит их не к вам, такое тоже может быть.
325.96 433.68 "Игорь Лабутин" Так, с интегрейшенами есть тоже небольшое обновление, напомню, интегрейшены это модули, да, pluggable кусочки, которые вы можете подключить к вашему приложению для того, чтобы, ну не к приложению, а к Aspire, ну хотя и к приложению тоже, потом в виде пакетов, чтобы получить некоторую стандартную конфигурацию, или как-то ее настроить, так вот теперь появился этот самый интегрейшен для YARP, то есть вы можете встроить YARP теперь легко и просто в ваше приложение через Aspire Hosting YARP Package, и таким образом как-то его даже там настроить удобным Fluent API, в модели приложения, это как раз набор вот этих C# объектов, через которые вы все это настраиваете, изменилось, ну опять какие-то минорные изменения API, то есть если у вас все работало, может быть что-то придется там немножко поменять, ну и в паблишерах тоже напомнит довольно недавняя штука, это возможность все это задеплоить не только в Azure, не только генерить JSON, из которого потом можно как-то пытаться генерить какие-то другие деплойменты, а сразу запаблишить прямо из Aspire куда-нибудь, теперь есть превью-саппорт для Docker Compose, Kubernetes, ажурных контейнерных приложений и ажурных App-сервисов, вот соответственно 4 места куда вы это можете сделать альтернативно, пока это все превью, это все развивается, к этому пытаются подобраться с точки зрения, как сделать API поудобнее, как сделать код поудобнее, но работа идет, и я думаю, что в районе релиза .NET, хотя кажется, что Aspire, релизы Aspire не сильно уже привязаны к релизам .NET, они живут более-менее
433.68 434.68 "Анатолий Кулаков" отдельной жизнью.
434.68 435.68 "Анатолий Кулаков" Ну да, это не пересекается вообще.
435.68 455.76 "Игорь Лабутин" Ну примерно как в студии, я так понимаю, там вроде как поддержка языка нужна, но какая-то поддержка языка в студии выходит существенно заранее, нежели чем официальный релиз .NET, и к моменту релиза основного .NET вроде как уже не нужно релизить студию, потому что она уже зарелизлена почти там, либо чуть раньше, либо чуть позже, ну и с Aspire так же.
455.76 465.00 "Игорь Лабутин" Так что вот, больше пока с Aspire никаких новостей нету, ждем, что еще новенького нам предложат.
465.00 498.00 "Анатолий Кулаков" Ну отлично, все, этот слот по Aspire мы на сегодня закрыли, значит можно переходить к другим темам, а другие темы тоже, есть интересная новость, в принципе довольно звонко звучала в интернетах в это время, это то, что Microsoft анонсировал новую фишку, мы теперь можем запускать .CS файлы как отдельные приложения, и конечно невозможно стороной обойти эту новость, поэтому давайте обсудим поподробнее, хотя казалось бы очевидная вещь, в принципе всем понятная, но почему-то народ безумно счастлив, что она появилась.
498.00 502.76 "Анатолий Кулаков" Будем разбираться, есть у него на это причины или все-таки нет.
502.76 529.60 "Анатолий Кулаков" Итак, как я уже сказал появилась новая фича, она анонсирована в .NET 10 Preview 4, и звучит она так, что теперь вы можете запускать C# файл напрямую, просто-напросто указав его в команде .NET run app.cs, ну то есть обычный .CS файлик, можно любой .CS файлик передать, и он будет запущен, и это сейчас очень большое дело, почему это большое дело-то?
529.60 666.96 "Анатолий Кулаков" А все очень просто, потому что раньше для того, чтобы вам запустить C# код, вам необходимо было построить настоящую проектную структуру, то есть вам всегда нужен был проект файл, без проект файла вы ничего не сделаете, но если есть проект файл, через тот же самый .NET, в принципе, командный утилит от .NET, в принципе можно было запустить все что угодно, он там под капотом компилировал, собирал, линковал и запускал, но казалось, что это слишком сложно, слишком много файлов, какая-то структура нужна, какие-то связи между ними нужны, и все это постепенно упрощалось и упрощалось, если вы вспомните тот же самый верхнеуровневый statement, когда мы избавились от мейна, начали там писать юзинги и использования там программа напрямую сразу в файликах, то это все шло именно вот этой вот теме, то есть мы немножко отрезали, отрезали, отрезали, и вот она кульминация, наконец-то мы отрезали все и смогли просто-напросто оставить один .cs файл, очень простой, без всяких лишних скобочек, без всяких мейнов, как раз такой скриптоподобный, и вот теперь мы находимся в той точке, когда у нас есть один единственный файл, кстати, они назвали этот подход file-based apps, то есть приложение, основанное на файлах, в котором вы теперь можете запустить один единственный, независимый, красивый .cs файл, и это очень сильно похоже на скриптовые языки, если вы вдруг знакомы каким-то из них, там например на PowerShell и так далее, то это очень сильно похоже на них, то есть у вас есть какой-то файлик, внутри написан код, он вполне самодостаточный и его можно запускать, и это по мнению большинства очень-очень важно, потому что снижает порог входа в C#, таким образом Microsoft надеется привлечь новых людей, которые будут писать на C#, потому что становится намного легче изучать C#, намного легче вообще прототипировать какие-то мелкие быстрые программки, писать какие-то утилитки или автоматизировать подручные сценарии, вот как раз все то, для чего используются скрипты и почему так любят люди скрипты, вот такая простота входа и можно еще поавтоматизировать, поутилизировать какие-то небольшие какие-то задачки, которые вам нужны прямо сейчас.
666.96 671.76 "Анатолий Кулаков" Итак, давайте же поподробнее разберемся с синтексисом.
671.76 681.76 "Анатолий Кулаков" Естественно, как бы дать простой .cs файл, выдрать его просто из нашей любимой какой-нибудь программы и подсунуть, и запустить, этого было недостаточно.
681.76 690.24 "Анатолий Кулаков" .cs файл теперь должен уметь содержать некие директивы внутри себя, которые помогают компилятору понять, что же с этим файлом делать.
690.24 713.60 "Анатолий Кулаков" Ну и по сути, если мыслить логически, то если раньше вам для запуска необходим был .csproj файл плюс файлы с исходниками, а остались у нас только файлы с исходниками, то всю ту информацию, которая нужна компилятору из .csproj файла, ему необходимо откуда-то брать, и по факту ее взяли и просто-напросто перенесли в .src файл, то есть в обычный .cs файл.
713.60 714.60 "Анатолий Кулаков" Как это выглядит?
714.60 723.96 "Анатолий Кулаков" Появились некие директивы, директивы компилятора, ну очень сильно похожи на те Define, допустим, которые у нас были в C# коде, похожи на те, что начинаются с решеточки.
723.96 728.32 "Анатолий Кулаков" Появились вот такие некие вспомогательные директивы.
728.32 736.68 "Анатолий Кулаков" В частности, например, есть директивы подключения NuGet пакета, если раньше мы пакеты подключали через .csproj файл, что сделать здесь?
736.68 737.68 "Анатолий Кулаков" Очень просто.
737.68 749.32 "Анатолий Кулаков" Мы точно также можем подключить какой-нибудь NuGet пакет в .cs файле, всего лишь навсего объявив директиву решетка .package и указав там имя пакета и через собаку его версию.
749.32 752.52 "Анатолий Кулаков" Почему через собаку?
752.52 766.00 "Анатолий Кулаков" Ну, опять же, наверное, какие-то оголделые дживоскриптовщики влезли и зачем-то указали, потому что обычно в .net версия от имени отделялась минусом.
766.00 767.88 "Анатолий Кулаков" Почему здесь внедрили собаку, непонятно.
767.88 771.76 "Анатолий Кулаков" Кажется, что это, наверное, первый прецедент, где я это вижу.
771.76 774.88 "Анатолий Кулаков" Может быть, это не так, поправьте в комментариях.
774.88 781.80 "Анатолий Кулаков" В общем, указываете имя пакета, тоже можно указать версию пакета и все это прозрачно и естественно скачается и заиспользуется.
781.80 785.16 "Анатолий Кулаков" Также можно указать SDK с помощью директивы компилятора.
785.16 800.84 "Анатолий Кулаков" По дефолту используется Microsoft.NET SDK, то есть это обычная .NET SDK, которая используется в нашем стандартном шаблоне Visual Studio, допустим, если вы создаете, и естественно тоже указывается в .csproj файле и по дефолту она подразумевается.
800.84 807.84 "Анатолий Кулаков" Если же вы хотите какую-то другую SDK, допустим, самое первое, что приходит на ум, это .web SDK, то все тоже очень просто.
807.84 812.32 "Анатолий Кулаков" Делаете решеточку, двоеточие, пишите SDK директиву и указываете, что вы хотите.
812.32 822.72 "Анатолий Кулаков" И у вас автоматически тут же в одном .cs файлике появляется поддержка всего полного S/P/Net Core с минимал API, с MWC, с Razer и прочим-прочим.
822.72 831.96 "Анатолий Кулаков" Например, в одном единственном файлике вы можете с помощью пяти строчек поднять свой собственный веб-сервер и запустить его без всяких проблем.
831.96 848.56 "Анатолий Кулаков" Первая строчка — это подключение SDK, вторая — мы сделаем стандартный веб-аппликейшн Crate Builder, у этого Crate Builder вызываем Build, получаем апп, у этого мапа делаем через минимал API, map-get, hello world, бандим какой-нибудь endpoint и следующая строчка — app.run, вот все.
848.56 852.36 "Анатолий Кулаков" Вы сервер построили, замапили ему роуты и запустили.
852.36 873.16 "Анатолий Кулаков" И у вас после выполнения команды .netrun app.cs, то есть вот этого файлика cs, поднимется кистрл, открывается сокет и вы можете подключиться, допустим, с помощью какого-нибудь курла к вашему вновь созданному серверу и чего-нибудь там подтыкать, поэкспериментировать.
873.16 890.00 "Анатолий Кулаков" Пример довольно наглядный, в 5 строчек в обычный cs-файл без всяких там инсталляций, прелюдий, cs-proj, еще чего-то подняли полноценный интересный сервер, можно что-то попробовать, например, посмотреть, как работает новый OpenAPI протокол, допустим, всего-навсего.
890.00 905.80 "Анатолий Кулаков" Еще интересных из директив мы можем указать какие-нибудь msbuild-проперти, те же самые, что мы, например, могли указать в cs-proj файл и, допустим, указать lang-version, то есть какая версия языка у нас будет использоваться в cs-файле.
905.80 914.72 "Анатолий Кулаков" Например, точно так же решетка, двоеточие, проперти и указываем ключи значения без каких-либо проектных файлов.
914.72 933.72 "Анатолий Кулаков" Ну и, наверное, самая интересная директива, которую как бы все ждали, к чему это все шло, это shibang-директива, так называемый shibang-лайн, это специальная штука, тоже директива, которая начинается с волшебных решетка восклицательный знак.
933.72 947.28 "Анатолий Кулаков" Это очень популярная директива в Unix среде, она позволяет писать такие кроссплатформенные C# скрипты, ну для нас C# скрипты, а в принципе в Unix она помогает писать скрипты вообще на любом языке.
947.28 973.12 "Анатолий Кулаков" Дело в том, что если интерпретатор видит в первой строчке любого скрипта эту директиву, решетка восклицательный знак, после которой идет обязательный запускаемый бинарник, который можно запустить, то интерпретатор Unix забирает эту строчку, запускает тот бинарник, который указан в этом пути и передает ему данный файл.
973.12 985.52 "Анатолий Кулаков" То есть по сути, если мы напишем решетка восклицательный знак userbin.net run, то в этот run передастся наш скриптик и он сможет запускаться.
985.52 988.04 "Анатолий Кулаков" А дальше идет непосредственно тело самого скрипта.
988.04 1006.36 "Анатолий Кулаков" Для того, чтобы эта магия сработала, кроме того, что нужно указать шибанку строчку эту первую, вам необходимо сделать файл запускаемый, что в Unix редакте делается с помощью команды chmod +x и имя файла, и после этого можете прям смело запускать, как будто это настоящий экзешник.
1006.36 1016.24 "Анатолий Кулаков" То есть просто вызывать app.cs и он запустится и будет работать, как обычный .exe файл в терминах Windows, как обычный executable файл.
1016.24 1026.36 "Анатолий Кулаков" Тоже очень полезная директива и в принципе это ключевой момент для того, чтобы использовать в общем системе некий скриптовой язык и его скрипты.
1026.36 1028.16 "Анатолий Кулаков" Он здесь тоже поддерживается.
1028.16 1040.28 "Анатолий Кулаков" Что позволяет сделать C# довольно удобным кроссплатформенным инструментом для написания всяких команд-лайновых тулзов, автоматизационных скриптов, да и просто каких-то полезных утилит, которые нужны вам по работе.
1040.28 1048.92 "Анатолий Кулаков" При этом не нужно инсталировать никаких дополнительных проектов, то есть не инсталировать, а писать дополнительных проектов, конфиг файлов и прочего-прочего.
1048.92 1060.28 "Анатолий Кулаков" Так, что случится, если вдруг вы начинаете скриптовать и ваши скрипты начинают расти-расти и сложность их увеличивается-увеличивается.
1060.28 1066.72 "Анатолий Кулаков" К сожалению или к счастью, со скриптовыми языками это очень частая проблема.
1066.72 1084.04 "Анатолий Кулаков" Когда вы начинаете писать какую-то маленькую утилитку, она хорошенькая, маленькая, потом вы дописываете чуть-чуть по пару строчек, добавляете какую-то новую функциональность и через месяц приходите к выводу, что у вас там уже несколько тысяч строк, они уже плохо систематизируются, плохо помещаются и что-то с этим нужно делать.
1084.04 1086.32 "Анатолий Кулаков" Майкрософт предлагает довольно интересное решение.
1086.32 1091.88 "Анатолий Кулаков" Оно предлагает сконвертировать ваш файлик один-единственный в нормальный человеческий проект.
1091.88 1103.86 "Анатолий Кулаков" Для этого даже сделали специальную команду, которая называется .NET Project Convert и вы указываете имя файла и она это конвертирует в стандартный проект, который C#.
1103.86 1104.86 "Анатолий Кулаков" Что же происходит?
1104.86 1136.54 "Анатолий Кулаков" Она создает новую директорию с именем вашего файла, создает csproj файл, перемещает весь код из вашего файла в файл, который называется Program.cs, то есть настоящую запускабельную entry point и транслирует все директивы, начинающиеся с ознака решетка в ваш csproj файл, то есть все msbuild-овские проперти, все референции на какие-то пакеты из нугета, все это раскладывается красиво, как вы и ожидали по proj файлу.
1136.54 1160.18 "Анатолий Кулаков" И после того, как у вас появился проект, как у вас появился программ.cs файл, вы можете открыть это в EDE, запустить рефакторинг, разбить все на классики, вынести в отдельные файлики, сделать нормальный рефакторинг и довольно быстро перейти из вашего сложного громоздкого скрипта в одном файле, перейти к нормальному проекту с папочками, файликами, методами и так далее, что довольно таки удобно.
1160.18 1169.84 "Анатолий Кулаков" Конечно же, Microsoft был не первым, кто там за сколько там, 10-20 лет изобрел скрипты на C# и до этого было миллион проектов, наверное еще 2 миллиона умерло по дороге.
1169.84 1174.86 "Анатолий Кулаков" Можно вспомнить cs-скрипт, .net-скрипт, Cake и много-много других.
1174.86 1196.94 "Анатолий Кулаков" И в принципе все они продолжают работать, никуда не делись и так как их опыт довольно большой, появились они довольно давно, то наверное для каких-то сложных сценариев вполне может быть, что на первое время они будут даже удобнее и мощнее и точно по ним будет написано больше документации, задано больше вопросов, у нас такой же флоу, то есть легче будет, наверное, осваиваться.
1196.94 1201.06 "Анатолий Кулаков" Но у нового способа есть одно неоспоримое преимущество.
1201.06 1208.54 "Анатолий Кулаков" Для того, чтобы его использовать, вам не нужно ставить никакие дополнительные тулзы, каких-то Cake, cs-скриптов, .net-скриптов, ничего этого не надо.
1208.54 1209.54 "Анатолий Кулаков" Все идет просто из коробки.
1209.54 1212.62 "Анатолий Кулаков" Если у вас стоит .net-сдк, то все, у вас все готово.
1212.62 1220.94 "Анатолий Кулаков" Не нужно ничего конфигурировать, не нужно ничего там исследовать, читать документацию, искать какие-то сайты разработчиков, надеяться, что они не потеряются, в общем все это идет из коробки.
1220.94 1225.22 "Анатолий Кулаков" Что всегда было сильной стороной Microsoft, когда он задавливал конкурентов.
1225.22 1243.10 "Анатолий Кулаков" Важно здесь отметить, что в отличие от предыдущих как бы инструментов внешних, здесь мы пишем не на каком-то отдельном диалекте или не на каком-то режиме специальном C#, созданном специально для скриптования, нет.
1243.10 1248.02 "Анатолий Кулаков" Мы пишем на настоящем C#, который ничем не отличается от стандартного C#.
1248.02 1254.74 "Анатолий Кулаков" Мы компилируем это все стандартным Roslyn-компилятором, который тоже ничем не отличается, то есть стандартный C# стандартным Roslyn-компилятором.
1254.74 1266.26 "Анатолий Кулаков" Да, какие-то директивы там совместимые с file-based applications, какие-то нет, но компилятор один, у них кодовая база одна, оно никогда не разъедется, не отстанет, не умрет, в общем.
1266.26 1270.26 "Анатолий Кулаков" Поэтому это очень хорошая, большая, интересная гарантия.
1270.26 1271.26 "Анатолий Кулаков" Хорошо, что она есть.
1271.26 1274.62 "Анатолий Кулаков" Итак, что же предполагается в будущем, куда это все дело будет развиваться.
1274.62 1282.14 "Анатолий Кулаков" Есть много идей, также Microsoft велит вам набрасывать идей побольше, что куда двигаться, что делать с этим.
1282.14 1289.26 "Анатолий Кулаков" В частности, будет естественно появляться больше файловых директив, с помощью которых можно настраивать.
1289.26 1296.60 "Анатолий Кулаков" Скорее всего, все, что вы сможете сделать через cs-project файл, более или менее, наверное, будет кочевать в cs-файл.
1296.60 1302.12 "Анатолий Кулаков" Не то, чтобы это хорошо, ну как бы замусоривание синтаксиса и все такое, но, наверное, от этого никуда не деться.
1302.12 1306.70 "Анатолий Кулаков" Дальше будет проведена работа над перформансом.
1306.70 1315.14 "Анатолий Кулаков" Вот эти файлики, естественно, если мы претендуем на какие-то системные утилиты или запуск скриптов стандартный, то они должны запускаться очень быстро.
1315.14 1323.62 "Анатолий Кулаков" Вот здесь планируется гигантская работа, что будет запускаться быстро, будет компилироваться быстро, будет все к нам кэшироваться, правильно оптимизироваться, перекомпилироваться.
1323.62 1326.38 "Анатолий Кулаков" В общем, все это будет проходить неявно под капотом.
1326.38 1331.46 "Анатолий Кулаков" В общем, эти скрипты должны быть мега-быстрыми, но посмотрим, что удастся сделать до релиза.
1331.46 1337.94 "Анатолий Кулаков" Также должна быть поддержка дебаггинга, действительно, какие скрипты без настоящего дебаггера.
1337.94 1340.90 "Анатолий Кулаков" Мы же не в какие-то бирюльки играем, мы же настоящие программисты.
1340.90 1349.90 "Анатолий Кулаков" И будет поддержано множество файлов, то есть мы уходили от сложной структуры, когда у нас там есть проекты, файлы и так далее.
1349.90 1353.50 "Анатолий Кулаков" Мы хотели что-нибудь простенькое, вот вам один файлик и в нем все есть, он самодостаточный.
1353.50 1370.50 "Анатолий Кулаков" В общем, мы пошли по спирали, теперь у нас есть один файлик, но мы хотим теперь много файликов, потому что, естественно, классики в одном файле не помещаются или помещаются некрасиво, и хочется каким-то образом референсить другие CS-файлы, допустим, доставать оттуда какие-то классики, какие-то методы.
1370.50 1381.74 "Анатолий Кулаков" А также, может, на референсе будет не только CS-файлы, например, ресурсы, resx-файлы, допустим, какие-нибудь переводы строк для вашего скрипта, еще что-нибудь там.
1381.74 1382.74 "Анатолий Кулаков" В общем, можно придумать.
1382.74 1395.46 "Анатолий Кулаков" Из подхода, когда у нас есть несколько файлов, и они лежат, допустим, в одной директории, можно придумать точно так же какое-то упрощение синтаксиса для того, чтобы их соединить вместе, то есть для импорта файлов.
1395.46 1408.10 "Анатолий Кулаков" То есть можно сделать неявный импорт, например, все CS-файлы, которые лежат в одной директории, допустим, импортятся неявно, то есть вы можете обращаться к тем классам, не указывая явный импорт этого файла.
1408.10 1421.90 "Анатолий Кулаков" Также планируется сделать явный импорт, допустим, если файл лежит где-то в другом месте, то можно сделать директива решетка импорт и сослаться на этот файлик, как обычные, например, скрипты ссылаются, и заинтегрить к себе его тело.
1421.90 1428.22 "Анатолий Кулаков" Чего же не будет пока сделано, или на данный момент, по крайней мере, не планируется.
1428.22 1438.34 "Анатолий Кулаков" Также в деталях сообщили, что пока не планируется поддержка Visual Basic скриптов, ну, то есть такой же точно файлов, но в виде Visual Basic, да и вряд ли когда-то будет.
1438.34 1458.22 "Анатолий Кулаков" Что самое интересное, ну, мне поразило, это то, что они пока не планируют поддерживать вот эти файл-бейст аппликейшены в Visual Studio в большой, но в Visual Studio Code они это уже поддержали, поэтому, если вы хотите попробовать эту технологию с интеллисенсом, естественно, с подсветкой, как положено, то вам нужна последняя версия Visual Studio Code.
1458.22 1463.54 "Анатолий Кулаков" А вот появится оно в Visual Studio, пока говорят, что нет, пока таких планов нет.
1463.54 1475.14 "Анатолий Кулаков" Я думаю, что команда Visual Studio, наверное, не будет спать и, скорее всего, все-таки поддержит эту штуку, и иначе Visual Studio Code ее обойдет, это будет что-то странное.
1475.14 1479.66 "Анатолий Кулаков" Также нет никаких планов по поддержке дабл клика среди Windows.
1479.66 1488.62 "Анатолий Кулаков" Как вы помните, наверное, например, Visual Basic скрипты, VBS скрипты, работают именно так.
1488.62 1492.78 "Анатолий Кулаков" Если файл имеет окончание VBS, то два раза по нему щелкнуть, он запустится.
1492.78 1494.66 "Анатолий Кулаков" Ну или, допустим, те же самые PowerShell скрипты.
1494.66 1496.46 "Анатолий Кулаков" Если по ним два раза щелкнуть, они запустятся.
1496.46 1502.90 "Анатолий Кулаков" Ну, у PowerShell там есть защита, что они по дефолту из коробки так запускаться не будут, но, в общем, идея, я думаю, вы поняли.
1502.90 1515.62 "Анатолий Кулаков" То есть, что бы можно было сделать, а-ля экзешники с помощью этих скриптов, нет, команда сказала, что пока такое не планируется, потому что это может сделать огромный брешь в системе Windows, а там их и так хватает.
1515.62 1517.94 "Анатолий Кулаков" В общем, этого тоже пока не ждите.
1517.94 1530.94 "Анатолий Кулаков" Ну, а что там получится у них в дальнейшем, будем следить, обязательно посмотрим, как они подойдут к релизу, с какими цифрами, с какими битчмарками, с какими временем запуска, прежде всего, это будет интересно настоящим скриптописальщикам.
1530.94 1534.90 "Анатолий Кулаков" Ну и насколько удобно это все будет поддерживать и развивать.
1534.90 1535.90 "Игорь Лабутин" Да, интересно.
1535.90 1546.98 "Игорь Лабутин" Хотя, кстати, в винде же по идее никто не мешает тебе по дабл клику сказать, что вот запусти эту программу с каким-то аргументом, указываешь dotnet run и с этим аргументом и все.
1546.98 1550.26 "Анатолий Кулаков" Да, если хотите настроить, то, конечно, никто не мешает.
1550.26 1554.10 "Анатолий Кулаков" Вот видишь, принципиальный вопрос, а будет ли они запускаться по умолчанию.
1554.10 1555.10 "Анатолий Кулаков" Ну да, понятно.
1555.10 1560.62 "Анатолий Кулаков" Потому что тебе могут прислать в письме, допустим, cs-файл, ты по нему два раза щелкнешь, у тебя уже будет вирус в системе.
1560.62 1569.34 "Игорь Лабутин" Нужно придумать какое-то другое расширение, так чтобы было не cs, ну, по аналогии с VBS предлагают css.
1569.34 1571.78 "Анатолий Кулаков" Css, запускабельные файлы, да.
1571.78 1573.94 "Игорь Лабутин" Да, будет прекрасно, мне кажется.
1573.94 1574.94 "Игорь Лабутин" Как минимум весело.
1574.94 1583.06 "Игорь Лабутин" Точно, ты никогда не знаешь, ты запустил, собственно, какую-нибудь таблицу стилей или c-шарповый скриптик.
1583.06 1584.06 "Игорь Лабутин" Нормально.
1584.06 1589.54 "Анатолий Кулаков" Раскрасил тулбар или сделал новые круглые кнопочки или сломал себе всю систему одну из двух.
1589.54 1590.54 "Игорь Лабутин" Типа того.
1590.54 1608.34 "Игорь Лабутин" Но вообще идея интересная, посмотрим, то есть у меня есть ряд действительно каких-то таких вспомогательных тулзов, которые написаны условно в формате, как это сейчас называют, топ-левел программы, да, в виде одного файлика на 10 строчек, почему нет, может и нормально будет.
1608.34 1609.34 "Анатолий Кулаков" Поглядим.
1609.34 1614.90 "Анатолий Кулаков" Опять же, взять, если тот линкопад, то есть я с линкопадом пользуюсь довольно часто.
1614.90 1618.30 "Анатолий Кулаков" И вот кажется, что в принципе вот это довольно хорошая замена.
1618.30 1626.86 "Анатолий Кулаков" Опять же, скорее всего вокруг этого накрутится нормальная окошко, там должен быть какой-нибудь визуалайзер хороший, чтобы там таблицы визуализировал, но постепенно
1626.86 1627.86 "Игорь Лабутин" мне кажется, обрастет.
1627.86 1632.02 "Игорь Лабутин" Какой визуалайзер, если у тебя command-line тулза, ну?
1632.02 1639.02 "Анатолий Кулаков" В Visual Studio Code открываешь, там наверняка уже все плагины это будут поддерживать, они тебе будут рисовать там графики, какие захочешь.
1639.02 1644.14 "Анатолий Кулаков" То есть у нас Visual Studio Code вместе с вот этой фишкой, она вполне может заменить линкопад.
1644.14 1654.42 "Игорь Лабутин" Не, наверное, на линкопад не соглашусь, но в целом как бы такие вот одно, ну не однострочники, но небольшие программки, которые чисто из одного файлика действительно может и получиться.
1654.42 1659.70 "Игорь Лабутин" Когда какой-нибудь там лениво писать скриптик на чем-нибудь другом, быстрее закидать на фичу.
1659.70 1662.98 "Анатолий Кулаков" Да-да, там у нас тебя из-за угла косо смотрит PowerShell.
1662.98 1669.50 "Игорь Лабутин" Да, но, блин, я так и не смог к его синтаксису нормально привыкнуть.
1669.50 1670.50 "Игорь Лабутин" Вот.
1670.50 1684.30 "Игорь Лабутин" Я каждый раз либо пишу, то есть у меня в общем есть набор PowerShell скриптов, но он исключительно мал, и я либо действительно пишу просто какую-нибудь маленькую консольную утилитку на интернете, либо иду уже в чисто скриптовые языки.
1684.30 1685.30 "Игорь Лабутин" Вот.
1685.30 1692.42 "Анатолий Кулаков" А у меня уже как раз я попался вот в эту ловушку, что пишешь на 100 маленькие скриптики, они теперь превращаются в большие.
1692.42 1693.42 "Анатолий Кулаков" Вот с PowerShell такая же проблема.
1693.42 1697.90 "Анатолий Кулаков" У меня там сотня PowerShell скриптов, многие из них уже тянут на полноценные большие такие проекты.
1697.90 1705.62 "Анатолий Кулаков" В общем, если интересно, приходите на Boosty, мы там собираемся лекцию по PowerShell устроить, так что посмотрим.
1705.62 1708.26 "Игорь Лабутин" И что, пойдем посмотрим, что у нас еще есть?
1708.26 1728.22 "Игорь Лабутин" А, потому что не только Microsoft нас порадовал чем-то новеньким, а также вышел анонс от компании JetBrains, и компания JetBrains сказала по меньшей мере странное то, чего за прошедшие 20 лет, наверное, вряд ли от них...
1728.22 1749.42 "Игорь Лабутин" Ну, наверное, кто-нибудь этого от них ожидал, но 20 лет у нас ReSharper был экстенджером Visual Studio, кто-то на него ругался, что он тормозит, кто-то без него жить не может, кто-то пользуется от судьи к случаю, но так вот теперь ReSharper это экстенджер, в том числе для Visual Studio кода.
1749.42 1753.06 "Анатолий Кулаков" Теперь Visual Studio код будет тормозить?
1753.06 1754.06 "Игорь Лабутин" Да.
1754.06 1774.98 "Игорь Лабутин" Вероятно, он не будет такой же прям суперполнофункциональный, то есть сейчас уже доступен некоторые анализы кода, доступен CodeCompletion, доступен SolutionExplorer, а почему-то прям отдельно подчеркивают RenameRefactoring, видимо, как самый часто используемый рефакторинг форматирования
1774.98 1775.98 "Анатолий Кулаков" кода.
1775.98 1780.02 "Анатолий Кулаков" Не, ну это показатель того, что там вообще есть ReSharper, потому что иначе что там, синтакс хайлай... хайлайтинг?
1780.02 1787.06 "Игорь Лабутин" Ну, подожди, у ReSharper он тоже развесистый прикольный, более прикольный, чем у других хайлайтеров, но тем не менее.
1787.06 1791.50 "Игорь Лабутин" Ну и навигация, конечно же, давно знакомая.
1791.50 1810.74 "Игорь Лабутин" Все это пока в паблик превью и, соответственно, бесплатное использование, ну как обычно в формате яблок, да, типа билд, сколько там, 30 дней живет, вот, потом выходит следующий, его снова можно использовать, пока не будет нормальной релизной версии, релизная версия будет частью обычной подписки Dota Ultimate, так же, как там Rider и все остальное.
1810.74 1811.74 "Игорь Лабутин" Вот.
1811.74 1831.14 "Игорь Лабутин" Для того, чтобы начать работать, вы ставите экстенджер, после чего вы открываете в Visual Studio код ваш Workspace, там, где у вас Solution файл находится, дальше ReSharper сам попытается найти этот самый Solution либо SLNX файл, да, который XML новый, если найдет один, он его просто откроет, если найдет несколько, предложит на выбор, какой хотите.
1831.14 1859.26 "Игорь Лабутин" Единственное, что поскольку единственный способ, как я понимаю, нормальным взаимодействовать нативно с Visual Studio кодом с точки зрения работы с языком, это реализовать LSP, да, Language Server Protocol, и ReSharper это, видимо, как раз таки и сделал, поэтому он несовместим с другими LSP серверами для C#, то есть если у вас работает C# DevKit, его нужно дизейблить, чтобы нормально работал ReSharper, ну и другие C# расширения, соответственно.
1859.26 1864.98 "Игорь Лабутин" Либо ReSharper, либо другие C# расширения, тогда у вас будет нормально все работать в Visual Studio кодом.
1864.98 1865.98 "Анатолий Кулаков" Вот.
1865.98 1869.62 "Анатолий Кулаков" Слушай, а там точно-то написано, что он сделал это через SLP?
1869.62 1871.98 "Анатолий Кулаков" Потому что там протокол SLP, он довольно убог.
1871.98 1898.30 "Игорь Лабутин" Да, это сделано через LSP, то есть в самой статье в анонсе этого нет, но если пойти в детали и посмотреть, там детально написано, что да, это сделано через LSP, именно поэтому полнофункционального 100% ReSharper в VS коде вы не увидите, если вы хотите такой же, как в Visual Studio, то берите Rider, благо у вас все равно уже будет Dota Ultimate подписка для нормального использования ReSharper.
1898.30 1903.26 "Анатолий Кулаков" Я подумал, как раз наоборот, докрутят туда Rider внутрь Visual Studio кода.
1903.26 1906.62 "Игорь Лабутин" А им не нужно это, скорее всего, зачем?
1906.62 1909.18 "Игорь Лабутин" А зачем им это?
1909.18 1918.98 "Игорь Лабутин" Иметь удобный единый experience, известно, что ты не будешь запускать Rider, там для правки твоих, например, тех самых двух-трех строчников.
1918.98 1924.14 "Анатолий Кулаков" А там же fleet на борту где-то должен был быть, нет?
1924.14 1925.14 "Игорь Лабутин" Ну, видимо, нет.
1925.14 1926.14 "Игорь Лабутин" Все, кончился?
1926.14 1927.14 "Игорь Лабутин" Видимо, нет.
1927.14 1933.10 "Игорь Лабутин" Поэтому вот оно в виде LSP сервера теперь может жить.
1933.10 1945.98 "Игорь Лабутин" Я просто не знаю деталей особой LSP, что он там позволяет, что не позволяет, поэтому наверняка там вообще все полностью, конечно же, не получится сделать, но что-то получится.
1945.98 1951.58 "Игорь Лабутин" Будет удобная, нормальная альтернатива, например, C# девкиту.
1951.58 1952.58 "Игорь Лабутин" Почему нет?
1952.58 1958.42 "Игорь Лабутин" Если ты уже платишь JetBrains за Rider, не надо платить Microsoft за еще одну лицензию.
1958.42 1967.70 "Игорь Лабутин" Напомню, что девкиту он же тоже платный, требует лицензии как студия, поэтому будет у тебя и в VS Code C#.
1967.70 1979.26 "Игорь Лабутин" Ну и заодно вместе с анонсом ReSharper для VS Code вышел и Extension JetBrains AI Assistant, если вы пользуетесь, теперь можете его также поставить в VS Code и там тоже попользоваться.
1979.26 1989.34 "Игорь Лабутин" Вот такие вот новости, поглядим, куда это все вылезет, поглядим, насколько ReSharper под VS Code будет нормально работать.
1989.34 2005.66 "Игорь Лабутин" Пока я каких-то больших отзывов не видел, я видел только видосик Ника Чапса со словами "ReSharper для VS Code вышел, но он работает отвратно", но понятно, что это как бы публик превью, поэтому нормально, что он работает не идеально.
2005.66 2008.54 "Игорь Лабутин" Вот, такие дела.
2008.54 2020.22 "Анатолий Кулаков" Ну вообще, конечно, больше EDE-шек хороших, а разных, как мы обсуждали несколько выпусков назад, EDE-шек нам не хватает, но не хватает, конечно, бесплатных, поэтому посмотрим.
2020.22 2021.94 "Игорь Лабутин" Ну, пусть хотя бы такая конкуренция будет уже хорошо.
2021.94 2025.78 "Анатолий Кулаков" Да, да, наверное, ты прав.
2025.78 2063.42 "Анатолий Кулаков" Так, ну что, новости обсудили, пойдемте учиться программировать, и у нас на полочке очередная стадия про best practices, если кто-то внимательно нас слушал, то в прошлом выпуске мы обсуждали, как сделать отказоустойчивые приложения на C#, и там обсуждали несколько техник от Poly, и хотелось бы сегодня остановиться на одной из этих техник, наверное, самая, мне кажется, редко используемая и недооцененная, это Circuit Breaker, и есть, попалась там интересная статья, которая называется "Лучшие практики тонкой настройки и политики автоматического выключателя".
2063.42 2097.34 "Анатолий Кулаков" Наверное, правильнее все-таки Circuit Breaker переводить как предохранитель, а не выключатель, потому что, в принципе, наверное, это одно и то же, да, но, наверное, в нашем русском языке больше встречается именно это, то есть это некий механизм, который срабатывает, когда в цепи происходят какие-то недоразумения, например, у вас случилось короткое замыкание, у вас выбивают пробки, вот выбивание пробок - это и есть некий Circuit Breaker, который спасает всю остальную систему от неправильного поведения, потому что он задетектировал какие-то аномалии в сети.
2097.34 2103.22 "Анатолий Кулаков" Давайте уже рассмотрим, что с точки зрения как раз Resilient Strategy от Poly подразумевается под этим.
2103.22 2135.86 "Анатолий Кулаков" Итак, Resilient Strategy разрешает сервису быстро осознать в том, что он работает неправильно, и сделать fail fast, то есть быстро осознать свои проблемы, что необходимо, когда в сети случились какие-то ошибки для того, чтобы предотвратить стагнацию своей собственной функциональности или тех сервисов, которые лежат вниз по вызывающему дереву.
2135.86 2144.42 "Анатолий Кулаков" Например, если он вызывает кого-то и понимает, что этот кто-то начинает заболевать, то лучше его очень часто не дергать.
2144.42 2152.18 "Анатолий Кулаков" Лучше дать ему время выздороветь, подняться, освободить ресурсы и только после этого начинать этот сервис, который лежит внизу, начинать снова дергать.
2152.18 2172.18 "Анатолий Кулаков" Такое временное предотвращение выполнения, то есть мы немножко приостанавливаем поток выполнения, позволяет нижележащему серверу как раз восстановиться и не быть забитым какими-то ретраями.
2172.18 2181.38 "Анатолий Кулаков" Если мы просто начнем ретраить каждую миллисекунду свои запросы, то скорее всего мы тому серверу, который сейчас болеет, сделаем еще больше.
2181.38 2187.58 "Анатолий Кулаков" Если раньше не хватало ресурсов, то с нашими плюс тысячи реквестами тем более ничего не хватит.
2187.58 2200.22 "Анатолий Кулаков" Ресурсов станет еще меньше, поэтому вот такая несложная логика позволяет как-то более-менее надеяться на то, что при уменьшении наших запросов его выздоровление пойдет быстрее.
2200.22 2209.06 "Анатолий Кулаков" Поэтому данный шаблон, он как раз был и спроектирован с несколькими целями.
2209.06 2224.58 "Анатолий Кулаков" Во-первых, обрабатывать те ошибки, которые у него есть для того, чтобы прекратить нагружать нижележащие сервисы и уменьшить давление, которое мы оказываем на них.
2224.58 2229.18 "Анатолий Кулаков" Для того, чтобы управлять этим алгоритмом, есть несколько ключевых параметров.
2229.18 2238.82 "Анатолий Кулаков" Что нам нужно для того, чтобы включать предохранитель и что нам нужно для того, чтобы он выключался и в какой момент это делать и на основании каких параметров.
2238.82 2241.66 "Анатолий Кулаков" Вот давайте немножко ключевых параметров и обсудим.
2241.66 2245.34 "Анатолий Кулаков" Во-первых, один из самых главных параметров — это fail ratio.
2245.34 2259.38 "Анатолий Кулаков" Это значение от нуля до одного, которое как раз таки показывает в скольких случаях, в скольких ошибках будет этот предохранитель включен, открыт.
2259.38 2268.14 "Анатолий Кулаков" Например, если эта настройка равняется 0,1, это значит, что в 10% случаев, когда произошла ошибка, он включается.
2268.14 2273.14 "Анатолий Кулаков" Допустим, нижележащий сервер выдает 10% ошибок из всех запросов.
2273.14 2280.22 "Анатолий Кулаков" Тогда мы включаем наш предохранитель и абсолютно все запросы, которые мы собирались отправить к этому серверу, сразу фейлятся.
2280.22 2285.28 "Анатолий Кулаков" То есть происходит такой fail fast и нижележащий сервер имеет шанс на какие-то восстановления.
2285.28 2287.38 "Анатолий Кулаков" Мы больше запросами напрягать не будем.
2287.38 2292.38 "Анатолий Кулаков" Вот этот коэффициент как раз и настраивает, когда нам нужно реагировать, когда нам нужно открывать наш предохранитель.
2292.38 2305.54 "Анатолий Кулаков" Дальше, minimal throughput - это минимальное число вызовов, которые необходимо сделать для того, чтобы задетектировать вообще наличие ошибки.
2305.54 2316.26 "Анатолий Кулаков" Sampling duration, по умолчанию стоящее в 30 секунд - это временное окно, которое необходимо для того, чтобы вычислить вообще фейл рейки.
2316.26 2322.46 "Анатолий Кулаков" И breaking duration - это то, насколько наш предохранитель откроется.
2322.46 2324.74 "Анатолий Кулаков" То есть какое время он будет открыт.
2324.74 2330.70 "Анатолий Кулаков" По умолчанию стоит 5 секунд, то есть в течение 5 секунд он не будет посылать запросы на нижележащие серверы.
2330.70 2346.16 "Анатолий Кулаков" А после прошедшей 5 секунд он снова попробует начать посылать запросы и снова измерит наши minimum throughput, sample duration и так далее для того, чтобы определить нужно ему опять открываться или не нужно.
2346.16 2354.28 "Анатолий Кулаков" И shoot handle - тоже такая настроечка, которая по сути является предикатом, определяющим, что же такое у нас ошибка.
2354.28 2361.42 "Анатолий Кулаков" То есть какие, например, типы исключений мы считаем ошибками, какие результаты, которые нам вернул сервер мы будем считать ошибками.
2361.42 2367.02 "Анатолий Кулаков" То есть те ошибки, которые будут влиять на переключение нашего Circuit Breaker.
2367.02 2372.22 "Анатолий Кулаков" Итак, теперь по тонкой работе настроек.
2372.22 2374.18 "Анатолий Кулаков" Давайте проберемся по настроечкам.
2374.18 2381.58 "Анатолий Кулаков" Прежде всего советуется включать наш предохранитель только в тех случаях, когда у нас действительно произошел какой-то инцидент.
2381.58 2399.94 "Анатолий Кулаков" Для этого нужно держать настройку fail ratio высокой, потому что если вы скажете, что необходимо включать предохранитель, допустим если у нас там случилась одна или две ошибочки, то он будет включаться слишком часто и это будет неправильное срабатывание.
2399.94 2405.34 "Анатолий Кулаков" То есть у вас ошибки будут сыпаться, просто обычные какие-нибудь случайные маленькие ошибочки.
2405.34 2409.82 "Анатолий Кулаков" То есть они не будут сыпаться из-за того, что нижележащему серверу не хватает каких-то ресурсов.
2409.82 2413.46 "Анатолий Кулаков" То есть по сути предохранитель включать никакого смысла нет.
2413.46 2414.46 "Анатолий Кулаков" Это ему не поможет.
2414.46 2416.86 "Анатолий Кулаков" Может там идут какие-то обычные бизнес ошибки.
2416.86 2423.26 "Анатолий Кулаков" Допустим или сеть моргает или еще что-нибудь такое, что никак не решается нашим предохранителем.
2423.26 2426.66 "Анатолий Кулаков" Поэтому необходимо этот параметр держать довольно высокий.
2426.66 2444.62 "Анатолий Кулаков" Также необходимо учитывать количество трафика, который идет через наш переключатель, потому что если трафика будет не хватать, то у него будет недостаточно статистики для анализа того, является ли эта ошибка частой или нечастой.
2444.62 2458.38 "Анатолий Кулаков" Допустим если у вас какой-нибудь один запрос в час идет и этот запрос вернулся с ошибкой или вернулся успешно, то вот этой статистики совсем не хватает для того, чтобы осознать действительно ли сервер на том стороне страдает, действительно ли ему плохо.
2458.38 2460.78 "Анатолий Кулаков" Поэтому вам необходим нормальный трафик.
2460.78 2464.22 "Анатолий Кулаков" Если трафика не будет, то этот шаблон тоже вам в принципе не подходит.
2464.22 2471.18 "Анатолий Кулаков" Значит вам необходимо делать какие-то другие ухищрения или может не стоит делать совсем ничего.
2471.18 2478.66 "Анатолий Кулаков" Также вам необходимо избавиться от агрессивных настроек minimal throughput и sample duration.
2478.66 2483.98 "Анатолий Кулаков" Они не должны быть слишком маленькими, иначе это может привести к false позитивам.
2483.98 2493.34 "Анатолий Кулаков" Необходимо также подумать о параметре breaking duration, потому что с одной стороны мы должны уметь восстанавливаться очень быстро.
2493.34 2507.54 "Анатолий Кулаков" Когда например предохранитель открылся и нижележащему серверу ру похорошело, нам необходимо уже начать к нему посылать настоящие запросы, потому что мы тоже не можем там на целый час пользователя оставить без нашего любимого сервиса.
2507.54 2520.82 "Анатолий Кулаков" Поэтому breaking duration должен быть как можно короче, чтобы мы как можно чаще могли опрашивать тот сервер, а жил ли ты, можно ли тебе еще запросы посылать или не можно.
2520.82 2532.50 "Анатолий Кулаков" Но с другой стороны, если вы сделаете его слишком коротким, то от нашего переключателя не будет никакого толка, потому что он как раз не будет предохранять бедный и больной сервис от наших запросов.
2532.50 2542.82 "Анатолий Кулаков" Поэтому здесь необходимо сделать его максимально коротким, но не настолько коротким, чтобы задавливать нижележащий сервис.
2542.82 2545.22 "Анатолий Кулаков" Тут нож нужно подбирать.
2545.22 2548.18 "Анатолий Кулаков" Итак, еще по лучшим практикам.
2548.18 2572.70 "Анатолий Кулаков" Прежде всего советуется дискриминировать ваш переключатель на уровне не только хоста, но и пути или какого-то более гранулярного измерения, для того чтобы, если вы и отключаете какой-то endpoint, то вы отключали только этот конкретный endpoint, то есть не пытались каскадно убить очень много функциональности.
2572.70 2588.14 "Анатолий Кулаков" То есть советуется использовать более гранулярные переключатели, чтобы они как раз-таки позволяли отключать точечно проблемные места, но не отрубали практически весь ваш кластер, все ваши приложения.
2588.14 2610.66 "Анатолий Кулаков" Также советуют выставлять параметр fail ratio повыше, для того чтобы он игнорировал всякие временные ошибки, то есть возникают опять вот эти шморгания, про которые я говорил, чтобы он их более-менее пропускал, и сосредотачивался на как раз тех больших ошибках, которые возникают непосредственно из-за большого набора трафика.
2610.66 2630.34 "Анатолий Кулаков" И вообще в идеальности для того, чтобы этот параметр отконфигурить, нам его должен сообщить нижележащий сервис, потому что только он на самом деле знает, какие гарантии он готов дать к своему API, то есть на что он рассчитан, с какими параметрами ему производилось перформанс тестирования, то есть что он может выдержать.
2630.34 2653.50 "Анатолий Кулаков" И в идеальной картине мира, конечно, это он должен сообщить то, с каким Circuit Breaker и с какими настройками к нему необходимо обращаться, но в реальности это получается сделать довольно редко, поэтому авторы рекомендуют ставить значение 0.5 или больше, и вот от этого уже плясать, от этого уже собирать статистику.
2653.50 2661.70 "Анатолий Кулаков" Про Breakdown Duration я уже упомянул, что необходимо ее ставить как можно более маленькой, а потом постепенно увеличивать, если вдруг вам не хватает.
2661.70 2681.66 "Анатолий Кулаков" И увеличивать нужно не просто так, а обязательно все это контролировать на уровне Observability, то есть должны быть какие-то графики, какие-то параметры, какие-то метрики и смотреть, насколько быстро подлежащий сервер восстанавливается, как быстро он угасает, на сколько вам нужно еще подождать для того, чтобы он стал стабильным.
2681.66 2693.94 "Анатолий Кулаков" Рекомендуется начать настройки с 5 секунд, которая как раз стоит по умолчанию, и это дает хороший баланс между тем, чтобы защитить подлежащий сервер и при этом не оставить пользователя надолго без запросов.
2693.94 2696.62 "Анатолий Кулаков" В общем, от этой настройки уже можно плясать.
2696.62 2718.50 "Анатолий Кулаков" Одна из самых неочевидных и сложно настраиваемых параметров это как раз Minimum Throughput и Sample Duration, потому что они полностью зависят от вашего трафика, то есть на то, как у вас идут запросы, насколько часто, насколько быстро, насколько большие, поэтому чтобы вот их правильно подобрать для вашей системы, тут без анализа совсем никак.
2718.50 2750.78 "Анатолий Кулаков" Вам необходимо будет собрать какой-то тестовый стенд, запустить какой-то трафик, можно даже не тестовый стенд, а взять трафик прямо с продакшена лучше всего, посмотреть на экстремумы вашего трафика, каким-то образом визуализировать зависимость между ошибками и пропускной способностью, ну то есть нагрузить ваш сервер так, чтобы он перестал выдерживать, чтобы у него пропускная способность кончилась и начал выдавать ошибки, и примерно замерить на какой скорости, на каком количестве запросов это происходит.
2750.78 2758.50 "Анатолий Кулаков" И вот из этих цифр тогда вы можете довольно точно и хорошо настроить данные параметры.
2758.50 2769.30 "Анатолий Кулаков" Есть в статье прямо хорошие картинки, которые вам рекомендуется посмотреть, если вдруг вы действительно будете это все настраивать.
2769.30 2785.26 "Анатолий Кулаков" Потенциальные проблемы, которые здесь еще могут возникнуть, это, например, выставление слишком большого sample duration, sample duration все-таки рекомендуется держать не более пяти минут, это вот как раз ситуация, которую я рассказывал, когда у вас слишком мало трафика.
2785.26 2797.82 "Анатолий Кулаков" Когда вы выставляете уже sample duration больше пяти минут, то есть вам не хватает данных, не хватает статистики, и вы заходите за рамки пяти минут, это означает, что все-таки трафика у вас мало.
2797.82 2802.26 "Анатолий Кулаков" Или второй случай, что подлежащий сервис слишком нестабильный.
2802.26 2810.94 "Анатолий Кулаков" То есть вы не можете предсказать его стабильную работу, у вас не получится никаким образом, сколько бы вы не ждали, он никогда не станет стабильным, вот смысл такой.
2810.94 2813.10 "Анатолий Кулаков" То есть он сам по себе как-то написан нестабильно.
2813.10 2826.82 "Анатолий Кулаков" И тогда тоже использовать переключатель, использовать предохранитель здесь у вас не получится, вам необходимо придумать или другую стратегию, или все-таки каким-то образом стабилизировать ваш сервис для того, чтобы с ним можно было работать с других приложений.
2826.82 2830.38 "Анатолий Кулаков" Вот такой интересный алгоритм, такой интересный сервис.
2830.38 2855.10 "Анатолий Кулаков" Я думаю, что в принципе, если вы сталкиваетесь с частым таким большим трафиком, который иногда приходит на ваши сервисы, и вам необходима такая ситуация, когда нужно подождать немножко, чтобы подлежащие серверы переварили все запросы, которые у них есть, обстановились и уже с новыми силами пошли в бой, то без вот этого подхода, без этой стратегии в принципе не обойтись.
2855.10 2874.90 "Игорь Лабутин" Да, действительно полезная и действительно хорошая статья на предмет того, как это делать, потому что многим кажется, что да, ладно, по пятисотим и потом обратно пойдем, когда отлягут наши даунстрим-сервисы, но может случиться так, что рост нагрузки будет приводить к тому, что ляжет вообще все.
2874.90 2877.94 "Игорь Лабутин" Встречалось такое на практике, сервер-брейкер - важная штука.
2877.94 2889.14 "Игорь Лабутин" Ликбез мы на сегодня, наверное, закончили, хотя посмотрим и пойдем в наш класс статей, которых мы давно, кстати, не видели.
2889.14 2892.22 "Игорь Лабутин" Это про всякую внутряночку, перфомансы, вот это все.
2892.22 2900.78 "Игорь Лабутин" Мало с чего у нас происходит с перфомансом, мне кажется, вы тут знаете, но не дремлет автор самых крутых перфомансных библиотек.
2900.78 2907.74 "Игорь Лабутин" Если вы знаете, что такое MessagePack C#, что такое MemoryPack, что такое UTF-8 Serializer, то вы наверняка поняли о ком я.
2907.74 2910.26 "Анатолий Кулаков" У нас новый сериализатор появился, что ли?
2910.26 2913.86 "Игорь Лабутин" Нет, у нас не появился новый сериализатор, у нас появилось нечто более крутое.
2913.86 2929.66 "Игорь Лабутин" Действительно, автор известен своими всякими протоколами взаимодействия с сериализаторами и так далее, но также у него теперь есть библиотечка, которая называется Z-LinkU, и это Zero-Allocation-Link-Library-for.net.
2929.66 2951.10 "Анатолий Кулаков" В принципе, слушай, действительно интересная идея, потому что когда у тебя появляется перфоманс-код или вдруг твое приложение становится мегаперфомансным, и тебе нужно улучшить его производительность, давай так, то первым делом советую практически во всех статьях выкидывать линку к чертовой матери, потому что тормозить линку очень сильно.
2951.10 2962.58 "Игорь Лабутин" Да, и можно будет его не выкинуть, а небольшими изменениями, я там расскажу, какими, довести его до некоторого достаточно перфомансного состояния.
2962.58 2972.38 "Игорь Лабутин" Значит, смотрите, в чем идет речь, ну понятно, что раз это Zero-Allocation, то понятно, что там нет аллокации памяти.
2972.38 3000.14 "Игорь Лабутин" Действительно, большинство бенчмарков, которые приведены в статье, они показывают, что память практически не аллоцируется, ясное дело, что для этого мы либо все раскладываем на стэки, либо если нам нужны операции, где без аллокации вообще говоря не обойтись, ну а такие бывают, да, это всякие агрегирующие операции, как ни крути, но агрегирующая операция должна что-то зааллоцировать, чтобы по крайней мере сохранить какой-нибудь результат чего-либо, там используются всякие буферизации, пулы и прочее такое.
3000.14 3008.58 "Игорь Лабутин" Что все это означает и как вообще к этому пришел автор?
3008.58 3034.14 "Игорь Лабутин" Он говорит, что вообще много было разных попыток сделать оптимальную или более оптимизированную реализацию LinkU, но они были не очень практичные в общем-то все, потому что либо не хватало языковых средств, либо это была какая-то адская кодогенерация на миллиарды методов и раздувался размер сборки, ну когда там пытаются изгенерить все возможные перегрузки, чтобы не было боксинга, что-нибудь в таком духе.
3034.14 3064.66 "Игорь Лабутин" Но у них была цель попытаться создать что-то практичное, что будет работать прямо вместо оригинального LinkU, естественно они целятся в основном в Link to Objects, надо понимать, то есть это не про какой-то там EF и Expression Trees, там дело не про то, дело про Link to Objects, и самое главное они хотят, чтобы было реализовано стопроцентное покрытие всего того, что предлагает LinkU сейчас в вот уже готовящемся десятом дотнете.
3064.66 3081.46 "Игорь Лабутин" И при этом хочется, чтобы это все было быстро, то есть надо было не то, чтобы это только мало памяти пользовало, использовало, но еще и там, где можно была всякая векторизация, SIMD, вот это все, чтобы и там еще performance как-то получили.
3081.46 3126.34 "Игорь Лабутин" Оказалось, что автор, вообще говоря, не первый раз сталкивается с LinkU, у него был ряд библиотек, посвященных LinkU, ну или переделывающих LinkU в каких-то узких областях, то есть для Unity, а он в основном, я так понимаю, игродельством занимается, потому что у него в основном много чего крутится вокруг Unity, у него написана библиотечка LinkJS для JavaScript, Link реализованный, и есть кейсы, как он говорит, что в целом бывают места, где чисто теоретически не получится сделать быстрее, чем как бы делает основной Link, но в 99% случаев мы все-таки быстрее.
3126.34 3130.14 "Игорь Лабутин" С pooling совсем добро, понятное дело, все работает отлично.
3130.14 3183.90 "Игорь Лабутин" Для того, чтобы это все использовать, достаточно после вашего какого-нибудь inNumerable написать вызов метода asValueInNumerable, ну как мы обычно делаем там, sQueryable, чтобы преобразовать в iQueryable, здесь нужно написать asValueInNumerable, это преобразуется в специальный интерфейс, я там чуть дальше расскажу, как это сделано, и после этого дальше вы используете все обычные ваши LinkU методы, как у вас были, код написан таким образом, что никаких других изменений вам не потребуется, вот, там есть исключение, если вы пользуетесь старыми фреймворками, то есть несмотря на то, что написано, что это все поддерживает стопроцентный coverage всего того, что есть в .NET 10, техническая библиотека Targeted .NET Standard 2.0, то есть она поддерживает всякие и старые .NET и все остальное прочее, понятно, что она будет там не так быстро, потому что всякие спаны, рефстракты там не такие быстрые, оптимизированные, но тем не менее оно будет работать.
3183.90 3209.34 "Игорь Лабутин" Вот, для того, чтобы убедиться, то есть автор не просто говорит, что у него, значит, на 100% все соответствует основному LinkU, они сделали крутую штуку, они взяли System Link Tests из репозитория .NET Runtime, это набор тестов для, собственно, основного LinkU, и запускают этот комплект тестов на реализации своего Z-LinkU.
3209.34 3215.38 "Анатолий Кулаков" Слушай, ну это вообще круто, вот это вот хороший пойнт в обеспеченности прямо.
3215.38 3216.38 "Игорь Лабутин" Да.
3216.38 3222.66 "Игорь Лабутин" Там, соответственно, у них порядка 9 тысяч тест-кейсов, у Майкрософта написано, и вот на них на всех это все проходит.
3222.66 3238.34 "Игорь Лабутин" Там есть некоторые, которые игнорятся просто потому, что они невыразимы в value-типах, ну тебе там какой-нибудь боксинг, рефстракт недопустим, поэтому каких-то тест-кейсов нету, но в целом их осталось порядка 9 тысяч, которые работают.
3238.34 3259.30 "Игорь Лабутин" Более того, на самом деле, на самом деле, у Z-LinkU, они еще есть в поставке source-генератор, который, видимо, вместе с интерсепторами позволяет не писать вот этот svlue_innumerable, а любое использование LinkU автоматически подменять на Z-LinkU.
3259.30 3304.78 "Игорь Лабутин" Ну примерно как у нас вот в minimal API, да, source-генераторы с интерсепторами используются, чтобы подменять там мэпгеты на какие-то более правильные штуки, да, в зависимости от того, что вы там понастраивали, также и здесь, то есть вы можете настроить и сказать, что там Z-LinkU автоматически замени на Z-LinkU, и все будет работать прозрачно, причем именно такой подход они сделали для System-LinkU-тестов, поэтому я не проверял, но они утверждают, что вот папочка Z-LinkU-System-LinkU-Tests, она на 100% соответствует тому, что лежит в Майкрософте, то есть они тупо копируют файлики, применяют магию source-генератора, и все те же самые тесты, которые в репозитории тут NetRuntime работают для обычного LinkU, у них в репозитории работают для Z-LinkU, без изменения тестов.
3304.78 3306.46 "Анатолий Кулаков" Которые будут появляться новые, круто.
3306.46 3310.10 "Игорь Лабутин" Ну да, перенося новые тесты, ты будешь, понятное дело, добавлять.
3310.10 3312.18 "Игорь Лабутин" Как же это все работает?
3312.18 3340.70 "Игорь Лабутин" Работает это все, как я уже сказал, конечно же на всех новомодных внедряемых фичах C#, а именно итератор, это основная сущность, которая внутри работает, она сделана через ReadOnlyRefStruct, то есть каждый раз, когда у нас обычные методы LinkU-шные, у нас всегда возвращают InNumerable, либо же возвращают какой-то итератор, типа там структуру, либо еще что-то.
3340.70 3358.38 "Игорь Лабутин" Зачастую бывает, что возвращают структуру для оптимизации, но в целом как бы все это может каститься, бокситься в интерфейсе и так далее, здесь это все ReadOnlyRefStruct, это гарантированно не закастится, в смысле не закастится, не забоксится никуда в heap, вот это итератор, это один момент.
3358.38 3379.14 "Игорь Лабутин" Второй момент, в классическом итераторе, в InNumerable, у нас есть два метода, точнее методы свойства, одно называется move_next, второе свойство называется current, то есть move_next у нас двигает текущий, переходит на следующий элемент, да и возвращает false, если его нет, current берет текущий элемент.
3379.14 3392.86 "Игорь Лабутин" И для того, чтобы минимизировать все внутреннее содержимое этой самой структуры, все это заменено на один метод try_get_next, который сразу возвращает boolean значение и элемент, если он есть.
3392.86 3425.74 "Игорь Лабутин" Как только вы делаете цепочку вызова link_you, по сути это происходит вложенное создание структурок итераторов, то есть у вас какой-нибудь link_you метод, который говорит точка where, where вам вернет структурку, на ней вы вызываете точку select, по сути, это все обернет ту структуру, на которой вызвали select, в еще одну структуру итератора, и таким образом у вас на стэке, это все напомнивает restruct и все живут на стэке, у вас копятся потихонечку вложенные друг в друга структуры.
3425.74 3448.58 "Игорь Лабутин" Это именно тот кейс, один из кейсов, про который я говорил, что в некоторых случаях link_you обычный будет быстрее, потому что если вы сделаете слишком длинную цепочку, то объем вот этой вложенной, вложенных друг в друга итераторов, раскруток всего этого на стэке и перемещения может быть чуть дольше, чем на самом деле положить все в heap и быстро с ним работать.
3448.58 3475.52 "Игорь Лабутин" Понятно, что в этом самом интерфейсе это все называется ivalue, ivalue итератора, если я правильно помню, есть еще всякие вспомогательные методы, которые на самом деле используются и в обычном link_you, ну что-то похожее, то есть там есть методы try_get, null_enumerated_count, если внутри итератор знает, что он создавался на массиве, на спане или на списке, то он сразу может вернуть значение, количество штук.
3475.52 3502.22 "Игорь Лабутин" Можно вызвать try_get_span, опять же, если мы, итератор позволяет он сразу вернет вам нужный спан, это, например, может быть полезно, если вы делаете в link_you чисто какой-нибудь там skip и take, то есть вы никак не модифицируете внутреннее содержимое исходной коллекции, исходного перечислимого, тогда try_get_span вполне вам может пропустить нужное количество элементов, вернуть нужный кусочек спана, спаном сразу.
3502.22 3511.54 "Игорь Лабутин" Ну и есть еще метод try_copy_to для оптимизации, если что-то куда-то, в случае с агрегациями, когда работаем с буферизованными массивами.
3511.54 3535.86 "Игорь Лабутин" В девятом дотнете и позднее, zlink еще крут тем, что он, это уже свойство из-за языка и поддержки runtime, позволяет делать link_you прямо на спанах, то есть обычный link_you на спанах сделать нельзя, потому что boxing вот это все, а zlink_you можно, можно на спане вызвать какой-нибудь там select, where, все, first, take, и будет все прекрасно работать.
3535.86 3548.58 "Игорь Лабутин" При этом, когда дело доходит до агрегации, то есть когда мы понимаем, что нам нужно там посчитать сумму и так далее, то вовсю включаются попытки оптимизировать все через simd и все такое прочее.
3548.58 3561.26 "Игорь Лабутин" Вот такая вот клевая штука, не пробовал, не знаю, надо смотреть, но это еще не все, в том плане, что link_to_objects дело не ограничивается, помнишь ли ты такую штуку как link_to_xml?
3561.26 3566.94 "Анатолий Кулаков" Да, конечно, я даже часто много ее использовал, какие-то былые времена.
3566.94 3583.82 "Игорь Лабутин" Да, она была довольно удобной для навигации, то есть там были всякие удобные проперти, типа там предки, наследники, дети, можно было походить по соседям своего уровня иерархии, то есть довольно удобный способ навигации по какой-то деревянной структуре.
3583.82 3603.90 "Игорь Лабутин" Они назвали это дело в этой библиотеке link_to_tree и сделали интерфейсик под названием itraverser, который как раз имеет вот эти самые 5 или 6 свойств, ancestors, children, descendants, before_self, after_self и некоторое количество методов, и реализовали эту штуку для некоторых, ну видимо нужных им кейсов.
3603.90 3637.98 "Игорь Лабутин" Очевидно была полезная реализация для файловой системы, то есть у них есть класс под названием directory_tree, который позволяет с помощью link_u обходить дерево файлов, есть такая же реализация под названием json_node для систем текст json, который позволяет использовать по сути link_u to json в каком-то смысле, ну и еще видимо им нужно было для каких-то юнитийных игровых штук, они там сделали для юнити, для годота, уже видимо какие-то уже специфические штуки, я там особо не разбираюсь, не знаю.
3637.98 3669.98 "Игорь Лабутин" Вот, соответственно, если, может быть, даже вам и не нужна какая-то супер-пупер продвинутая и очень оптимизированная библиотека link_u для замены обычного link_u, но если вам нужно с помощью link_to что-нибудь, как вы ходили с link_to.xml вокруг json, например, или вокруг файловой системы, то вот можно, или какую-то вашу кастомную структуру написать деревянную, можно реализовать itraverser, там всего ничего, методов и свойств, 5 или 6 штук, как я сказал, и все, и у вас будет link_u на вашей кастомной структуре.
3669.98 3687.86 "Анатолий Кулаков" Ну и действительно многие используют link_u как для плоских списков и не задумываются, на самом деле я очень много использовал link_u для иерархии, для xml, для файловой системы, и это очень удобная штука, например, там обходить любые деревья, реализовать какие-нибудь алгоритмы на графах и так далее, в общем, link_u для этого подходит идеально.
3687.86 3691.22 "Анатолий Кулаков" И очень полезно на уведении, вообще молодцы, супер.
3691.22 3692.22 "Игорь Лабутин" Вот.
3692.22 3740.46 "Игорь Лабутин" Ну и в конце статьи автор прям посвятил отдельный блог тому факту, что вообще библиотечка опенсурсная, и конечно же он знает и слышит про все то, что происходит в опенсурсной экосистеме дотнета, то, что мы много раз обсуждали, да, библиотеки становящиеся платными и так далее, он себя считает одним из самых крупнейших провайд-поставщиков опенсурса в дотнете, ну, с его количеством всяких разных месседж-паков, мэмори-паков и прочих библиотек, может быть, они не столь там прям популярны, как ньютон софт, условно говоря, да, то есть, как он говорит, там все вместе они, по-моему, типа 50 тысяч звездочек на гитхабе набирают или как-то так, но тем не менее он действительно довольно популярный автор, так скажем, в узких кругах любителей перфоманса, назовем так.
3740.46 3743.86 "Анатолий Кулаков" Потому что он не самый крупнейший, но один из самых значительных,
3743.86 3744.86 "Игорь Лабутин" точно.
3744.86 3803.62 "Игорь Лабутин" Да, и поэтому он говорит, что пока, я понимаю ваши опасения, что я там начну собирать со всего этого деньги, у меня, говорит, таких планов нет, но вы понимаете, что у меня как бы этих библиотек стало много, я на вас на всех один, поэтому у меня, говорит, есть цикл, так сказать, поддержки, то есть я, грубо говоря, вот сейчас напишу этот линк, отлажу его, он там будет нормально работать, в следующий раз я к нему вернусь там, типа хорошо, если через полгода, поэтому вы, типа, если проблемы найдете, вы пишите, но тот факт, что я там полгода не буду заходить и не отвечать ни на какие вещи, это нормально, я работаю с библиотеками по принципу, типа, пару-тройку месяцев на одной, пару-тройку месяцев на другую и так далее по кругу, поэтому, типа, мол, не ожидайте быстрых, частых и каких-то прям огромных апдейтов вот сразу после выхода, скорее всего, будет некоторая пауза, а потом я вернусь и все, оптом, быстренько все сделаю по фикшу, дореализую и так далее, такой интересный
3803.62 3804.62 "Анатолий Кулаков" подход.
3804.62 3867.34 "Игорь Лабутин" Вот такие дела, в принципе, я не стал пересказывать вам все бенчмарки, которые там есть в статье, ну потому что там надо вглядываться в микросекунды и байты, не сказать, что там прям эта библиотека как-то рвет LinkU с точки зрения, типа, в сотни раз быстрее, нет, то есть там где-то в два раза, где-то в полтора, где-то в три-четыре, где-то в шесть, понятно, что все это зависит от размеров исходных объектов, ну в смысле коллекций, да, от количества методов в цепочке, от сложности операций, потому что никто не выкидывает из рассмотрения вызовы делегатов, то есть напоминаю, что в каждый LinkU метод вы передаете делегат, который нужно вызвать, и в статье указано, что это был сознательный выбор, мы ничего не делали, никак не пытались оптимизировать вот эту часть вызова делегата, то есть наша задача была оптимизировать именно саму механику LinkU, да, локации и какие-то внутренние штуки на локации итераторов, вот этого всего.
3867.34 3890.94 "Игорь Лабутин" Вот, но даже при этих условиях может быть все еще дельным совет прям в супер перформант коде выкинуть линк и переписать нормально там на цикл или еще на что-нибудь, но если вам нужно просто посмотреть на интересную библиотеку, LinkTo3 мне кажется вообще шикарная штука, мне кажется отличный кандидат на посмотреть и применить у себя в коде.
3890.94 3906.70 "Анатолий Кулаков" Ну и вообще с этим автором очень приятно работать, то есть если ты берешь его библиотеки, точно понимаешь, что они прекрасно отлажены, отлично написаны, хорошо протестированы, задокументированы самое, что главное, и использовались как минимум уже на полмира, поэтому отличный библиотек.
3906.70 3910.42 "Игорь Лабутин" Ну, идем, давай дальше.
3910.42 3926.54 "Анатолий Кулаков" Так, немножко хочется поговорить про свагер, мы уже упоминали, что в новом дотунете, начиная с девятого, у нас не будет нашего привычного свагера и уже немножко упоминали о том, какие альтернативы для него есть.
3926.54 3934.98 "Анатолий Кулаков" В общем, теперь хочется остановиться не немножко, теперь хочется остановиться основательно и поговорить о том, а что же вместо свагера у нас будет.
3934.98 3959.94 "Анатолий Кулаков" В общем, вещь довольно новая для дотунета разработчиков, которые уже многие годы привыкли к свагер-юайю, поэтому говорить об этом нужно, чтобы никто не боялся, чтобы все понимали, что происходит, что есть, и поможет нам в этом Андрей Порожняков, он написал серийную статью на Хабар, которая называется "Скаляр вместо свагер-юайя, надо ли оно нам?" Ну, будем вместе с Андреем разбираться, надо оно нам или вообще не надо.
3959.94 3963.82 "Анатолий Кулаков" Итак, начнем сначала, что же такое у нас свагер.
3963.82 3974.70 "Анатолий Кулаков" Свагер в принципе под этим названием подразумевал несколько элементов системы, даже не он подразумевал, а разработчики обычно под этим понимают несколько элементов.
3974.70 3978.58 "Анатолий Кулаков" Ну, и для того, чтобы понять, что с этим дальше делать, нам все-таки их необходимо разделить и осознать.
3978.58 3982.26 "Анатолий Кулаков" Во-первых, это два основных элемента.
3982.26 3995.26 "Анатолий Кулаков" Во-первых, это OpenBI-протокол, то есть все ваши контроллеры собирали некую информацию о себе, такую мета-информацию, то есть какие у них параметры есть, какие они ответы возвращают, как их вызывать и прочее-прочее.
3995.26 3998.34 "Анатолий Кулаков" И вся эта мета-информация собиралась в неком OpenAPI-документе.
3998.34 4008.62 "Анатолий Кулаков" То есть такой документик, его можно представить в JSON-виде, у него есть стандарт в YAML-виде, ну, не суть, важно, в общем случае это JSON-документ, который описывает полностью все ваши endpoints.
4008.62 4018.14 "Анатолий Кулаков" Неважно, как вы их задавали, вы могли это написать в MinimalAPI, могли написать обычными контроллерами, в общем, там это все отображается.
4018.14 4025.02 "Анатолий Кулаков" Правильно называть это как раз OpenAPI-документом или OpenAPI-спецификацией, но этот документ часто называли Swagger-документом.
4025.02 4029.22 "Анатолий Кулаков" И вторая часть, которую называли Swagger, это непосредственно Swagger-UI.
4029.22 4062.14 "Анатолий Кулаков" Это такая зеленая жабообразная интерфейса, которую многие из вас, наверное, знают, которая запускается там по умолчанию, открывается, допустим, в браузере, если вы делаете какой-нибудь WebAPI, то есть больше у вас открыть нечего, никакого фронтенда у вас специально написанного нет, а вот эта зеленая запускалка всех ваших endpoints, она довольно, ну, мы можем, наверное, сказать, что удобная, как минимум, тестировщики могут ей пользоваться, допустим, запускать, дергать некие ваши API и что-то там, допустим, тестировать.
4062.14 4076.66 "Анатолий Кулаков" В общем, этот Swagger-UI, он довольно плотно вошел в нашу жизнь, настолько плотно, что Microsoft затащил его даже в стандартный шаблон, то есть, опять же, библиотеки, которые используют Microsoft в своих дефолтах, в своих шаблонах можно пересчитать просто по пальцам.
4076.66 4088.48 "Анатолий Кулаков" И вот Swagger был одной из них, поэтому все разработчики к нему уже привыкли, все тестировщики привыкли и вот вдруг беда пришла, откуда не ждали, от Дотнета 9.
4088.48 4101.06 "Анатолий Кулаков" В Дотнете 9 там Microsoft рассказал, что, в принципе, Swagger UI больше не будет, Swagger'а больше не будет, все это мы выпиливаем и будем писать свое.
4101.06 4102.30 "Анатолий Кулаков" Почему же так получилось?
4102.30 4113.18 "Анатолий Кулаков" Ну, прежде всего, были проблемы с разработчиками Swashbuckler, это название как раз-таки пакета, который к нам приносил всю эту радость в наши Дотнет-проекты.
4113.18 4146.46 "Анатолий Кулаков" Так вот, разработчики Swashbuckler покинули по какой-то там причине проект, сейчас не суть важно, и разработка этого пакета уже, проекта, начала длиться очень тяжко и вялко, начал копиться тех долг, начали запаздывать поддержки новых версий Дотнета, начал запаздывать интеграции, какие-то там ошибки очень долго не решались, а так как, по сути, Microsoft поставляет Swashbuckler вместе со своим продуктом, с SDK, то, грубо говоря, все эти косяки летели прямо на Microsoft.
4146.46 4168.90 "Анатолий Кулаков" То есть, вот вы нам поставили шаблон, там какая-то дурацкая несовместимая версия, у нее какие-то баги и, в конце концов, Microsoft это надоело, они написали интересный анонс, в котором рассказали, почему им это надоело и где им это надоело, и они решили сделать свою собственную реализацию OpenAPI и избавиться от Swashbuckler со своим SDK.
4168.90 4188.14 "Анатолий Кулаков" И вот, в принципе, они реализовали свою мечту, теперь вместо Swashbuckler нас приветствует пакет, который называется Microsoft ASP.NET Core OpenAPI, не путается OpenAEI, и давайте же обсудим, а как же разработчикам дальше с этим жить.
4188.14 4196.00 "Анатолий Кулаков" Теперь, когда вы создаете новый веб-проект, у вас автоматически подключается ASP.NET Core OpenAPI.
4196.00 4211.98 "Анатолий Кулаков" Прежде всего, наверное, если вы просто-напросто мигрируете свои старые проекты на новый фреймворк и не находите там, допустим, вообще всех этих референсов, наверное, одним из самых разумных ответов, который может прийти к вам в голову, это восстановить все как было.
4211.98 4223.26 "Анатолий Кулаков" Потому что как бы сам Swashbuckler никуда не делся, он доступен в репозиториях, он доступен в нугетах, его можно установить, и он вполне работоспособный со всеми современными версиями дотнета.
4223.26 4242.90 "Анатолий Кулаков" Даже поговаривают, что оригинальные его разработчики вернулись и начали делать все как было, но естественно, это не спасло от того, что Microsoft уже все переписал, поэтому здесь фарш назад не прокрутить, но все же пакет рабочий, пакет проверенный, документация есть и многие разработчики с ними уже знакомы.
4242.90 4248.30 "Анатолий Кулаков" Поэтому вполне неплохая идея просто-напросто вернуть все как было.
4248.30 4249.70 "Анатолий Кулаков" Что для этого нужно сделать?
4249.70 4261.78 "Анатолий Кулаков" Ну, во-первых, вам нужно удалить пакет ASP.NET Core OpenAPI, ничего страшного в этом нет, и поставить Swashbuckler ASP.NET Core, то есть вернуть то, что Microsoft раньше делал по умолчанию.
4261.78 4271.38 "Анатолий Кулаков" Дальше вам необходимо сделать стандартную регистрацию UseSwagger.UseSwagger.UI и все, и у вас все вернется на свои места, все заработает, как будто ничего и не было.
4271.38 4282.82 "Анатолий Кулаков" Второй способ, можно в принципе не возвращать Swashbuckler, можно оставить пакет ASP.NET Core OpenAPI, но при этом вернуть Swashbuckler.UI.
4282.82 4291.42 "Анатолий Кулаков" То есть это самый зеленый интерфейс, к которому привыкли все ваши тестировщики, возможно, какие-то ваши внутренние клиенты.
4291.42 4296.22 "Анатолий Кулаков" Вот его можно вернуть, опять же, потому что внешние потребители привыкли, зачем их обламывать.
4296.22 4302.22 "Анатолий Кулаков" При этом Swashbuckler.UI прекрасно дружится вместе с ASP.NET OpenAPI пакетом.
4302.22 4319.46 "Анатолий Кулаков" В общем, никаких проблем с этим нет, их тоже очень легко вместе подключить, настроить, и внутри у вас все будет генерироваться на микрософтском новом пакете, который они обещают поддерживать и расширять, а снаружи у вас вернется старый интерфейс, который в принципе все знают, все любят, все умеют.
4319.46 4324.14 "Анатолий Кулаков" В принципе, тоже хорошее решение, смотрите, какое подойдет лучше вам.
4324.14 4327.30 "Анатолий Кулаков" Давайте поговорим про настройку нашей новой библиотеки OpenAPI.
4327.30 4329.38 "Анатолий Кулаков" Чем же он там хороший и все такое?
4329.38 4332.90 "Анатолий Кулаков" Хорошим тем, что у него довольно хорошие гибкие настройки.
4332.90 4337.74 "Анатолий Кулаков" С помощью AppDocumentTransformer можно сделать с документом все что угодно.
4337.74 4351.30 "Анатолий Кулаков" Например, настроить, как и ожидается, наверное, версию, название, описание, можно настроить параметры подключения к серверу, на котором будут выполняться все вот эти вот запросы.
4351.30 4358.26 "Анатолий Кулаков" И, естественно, поддерживается Minimal API, который Microsoft всячески везде рекомендует.
4358.26 4363.54 "Анатолий Кулаков" В общем, по настройкам он довольно хорош, все, что ожидается, там есть.
4363.54 4366.70 "Анатолий Кулаков" И также он продолжает, с каждой новой версией становится все лучше и лучше.
4366.70 4370.90 "Анатолий Кулаков" Может быть, даже что-то новое придумают относительно даже свэш-бакла.
4370.90 4374.50 "Анатолий Кулаков" Теперь хочется поговорить про вторую часть.
4374.50 4388.90 "Анатолий Кулаков" Ну, раз мы заменили на новый пакет свэш-бакл, у нас теперь генерация этого OpenAPI документа на каком-то новом пакете, то, может быть, стоит нам еще раз взглянуть на Swagger UI, к которому, опять же, все привыкли за многие годы и все такое.
4388.90 4394.30 "Анатолий Кулаков" Может быть, он немножко устарел, может быть, есть какие-то альтернативы на ринке.
4394.30 4397.26 "Анатолий Кулаков" И, как показывает практика, на ринке действительно альтернативы есть.
4397.26 4399.78 "Анатолий Кулаков" Самая популярная среди них называется Scalar.
4399.78 4406.34 "Анатолий Кулаков" Это проект с открытым исходным кодом, как раз направленный на то же самое, на что и Swagger UI.
4406.34 4415.66 "Анатолий Кулаков" Это документирование и взаимодействие с REST API, и его чаще всего выбирают именно как замену Swagger UI.
4415.66 4418.70 "Анатолий Кулаков" Он отличается более современным и более удобным дизайном.
4418.70 4422.34 "Анатолий Кулаков" У него проще настройка, у него гибче и намного больше настроек.
4422.34 4430.66 "Анатолий Кулаков" Также у него встроен генератор клиентского кода, там огромное число всяких языков, на которые можно сгенерировать клиентов.
4430.66 4432.78 "Анатолий Кулаков" Разумеется, C# там тоже есть.
4432.78 4438.78 "Анатолий Кулаков" Он позволяет при запросах легко редактировать куки, заголовки и различные другие параметры запроса.
4438.78 4442.06 "Анатолий Кулаков" То есть, более гибкие такие запросы можно строить непосредственно из интерфейса.
4442.06 4456.06 "Анатолий Кулаков" У него очень удобный поиск, у него хорошая навигация поинт-поинта, по моделям, то есть, прямо по функциональности это хороший современный фреймворк, который покрывает те особенности, которые вы ожидаете.
4456.06 4461.18 "Анатолий Кулаков" Потому что Swagger UI действительно застыл где-то там в 90-х.
4461.18 4466.42 "Анатолий Кулаков" Работать с ним довольно сложно и тяжело, и если вы это не осознаете, значит вы просто-напросто привыкли.
4466.42 4469.26 "Анатолий Кулаков" Вы давно с ним работаете и вам это нравится.
4469.26 4478.98 "Анатолий Кулаков" Но если действительно открыть какой-нибудь новый интерфейс и попробовать там немножко поработать, вы поймете, что никаких интересных и полезных фишек вам не хватает.
4478.98 4489.24 "Анатолий Кулаков" Ну и немаловажным еще аргументом в пользу Scalar является то, что он полностью Ahead of Time совместим, что тоже довольно хорошо.
4489.24 4499.14 "Анатолий Кулаков" Итак, чтобы начать работать со Scalar, вам необходимо восстановить пакет Scalar SPnet Core, добавить Map-Scalar-API-Reference и все.
4499.14 4504.86 "Анатолий Кулаков" И в принципе с одной строчкой вы добавляете поддержку этого чудесного пакета.
4504.86 4519.94 "Анатолий Кулаков" Открывается он по URL Scalar-v1, допустим, этот же URL можно добавить в launch.url, чтобы Visual Studio или ваше IDE открывало его по умолчанию, когда вы запускаете ваш проект.
4519.94 4526.50 "Анатолий Кулаков" И как только вы это сделаете, перед вами откроется какая-то страничка, которая довольно сильно напоминает постмена.
4526.50 4547.62 "Анатолий Кулаков" Но у Scalar есть очень много настроек, есть различные темы, светлые, темные, а также очень хороший фреймворк для кастомизации, то есть не заставит труда абсолютно его превратить во все, что вы захотите, в любой интерфейс, который вам нравится, который вам известен.
4547.62 4555.66 "Анатолий Кулаков" Еще из настроек, как я уже сказал, настройка намного больше, чем у Swagger UI и меняется намного лучше и интереснее.
4555.66 4565.54 "Анатолий Кулаков" Нужно обязательно упомянуть, что у него хорошо и из коробки поддерживается схема аутентификации, APK, OAuth2, BASIC, HTTP BASIC и т.д.
4565.54 4578.90 "Анатолий Кулаков" В общем, если у вас с аутентификацией в Swagger UI были проблемы, а у многих они были, то возможно в Scalar у вас таких проблем больше не будет, потому что там все это продумано и настроено гораздо лучше.
4578.90 4595.86 "Анатолий Кулаков" Итак, подводя итог, Scalar автору прежде всего понравился, он ответил, что простое подключение, простое начало работы, очень гибкую настройку, большое количество настроек, отличную документацию и активную разработку этого проекта.
4595.86 4604.10 "Анатолий Кулаков" И лишний раз упомянул, что Scalar сильно выигрывает у Swagger UI и по настройкам, и по юзабилити, и по внешнему виду.
4604.10 4618.18 "Анатолий Кулаков" Из минусов, из минусов стоит ответить, что интерфейс довольно непривычный после Swagger UI, действительно все эти годы нас привычали к вот этим убогим кнопочкам и очень сложно вначале переключиться на что-то другое.
4618.18 4632.02 "Анатолий Кулаков" Поля находятся не там, описание не то, опять же, метод дата не с той стороны, в общем, все это будет сначала довольно раздражать, поэтому это смело можно занести в минус.
4632.02 4661.30 "Анатолий Кулаков" И отвечая на главный вопрос, а надо оно нам или не надо, вывод примерно такой, что в принципе никакого смысла бежать и переводить текущие проекты Swagger UI в Scalar нет, то есть вряд ли вы получите что-то такое, неоспоримые какие-то преимущества, но если вы создаете новый проект и хотите там попробовать что-то новое, и может быть думаете, что вам это вполне могло бы понравиться, то Scalar это отличный кандидат на рассмотрение того, чтобы попробовать.
4661.30 4667.54 "Анатолий Кулаков" Поэтому переписывать не стоит, а вот попробовать и может быть после этого все остальное переписать, вот это уже стоит.
4667.54 4684.58 "Анатолий Кулаков" Вот такая интересная библиотечка, надеюсь те, кто ее не знал, обязательно потыкают, попробуют и может быть отпишутся насколько им понравилось, насколько Swagger UI все-таки должен умереть, или все-таки привычка возьмет свое и то, что нам уже давно известно с детства, продолжит жить.
4684.58 4693.10 "Игорь Лабутин" Ну вообще да, я слышал только пока о такой библиотеке, не пробовал еще, но думаю, что в каком-нибудь ближайшем продукте по проектике попробую.
4693.10 4705.70 "Игорь Лабутин" Интересно, что Swagger мне немножко, ну как-то, не знаю, я не люблю Swagger почему-то, эту зеленую штуку, как-то не знаю почему пока, не могу это внетно сформулировать, но не люблю.
4705.70 4709.90 "Анатолий Кулаков" Предпочитаю… Вот он действительно не очень удобный, может как раз вот этого удобства тебе не хватало.
4709.90 4726.50 "Игорь Лабутин" Может быть, то есть я предпочитаю какие-то сторонние клиенты, но постман я тоже не люблю, он тяжелый и большой, поэтому как-то пользуемся всяким разным, .http, вот это все, ну конечно, это как бы не для всех, и UI может быть вполне удобен в некоторых случаях.
4726.50 4735.46 "Игорь Лабутин" Ну что ж, давай пойдем до самой конец, кратко о разном, у нас есть немножечко еще чего рассказать в кратких новостях.
4735.46 4776.86 "Игорь Лабутин" Во-первых, помимо того, что JetBrains выпустил ReSharper для VS Code, вероятно, этому поспособствовал тот факт, что ReSharper наконец-таки достиг некоторого прогресса в движении в сторону out of process исполнения, и в 2025.2 EAP2 у нас теперь есть возможность поставить настройку, настройка галочку, чтобы ReSharper стал out of process Visual Studio, то есть первая public preview появилась этой фичи, и вы просто перейдете в настройки, ставите галочку, запускаете ReSharper out of process, без перезапуска студии он сам переинициализируется как надо, и все работает.
4776.86 4796.32 "Игорь Лабутин" Не все работает, как я говорил в прошлый раз, когда мы обозревали статью про ReSharper out of process, пока есть недостатки, не работают часть фичей в AI, или вообще все фичи AI одни, не работает часть фичей в дебаггере, возможно из-за ограничений того самых протоколов и так далее.
4796.32 4815.34 "Игорь Лабутин" Понятно, не работает интеграция со всякими dot memory, dot trace и прочим, ну и там, помелочи, еще кусочки, но я так понимаю, что уж по крайней мере внутри ReSharper это уж точно допилит до нормального состояния, ну в смысле ReSharper со студией, там тут нет ограничений LSP никаких, в отличии от Visual Studio Code.
4815.34 4829.26 "Игорь Лабутин" Вот, так что если вы интересуетесь, если вам хочется использовать ReSharper в студии, но он тормозит, и всю студию тормозит, попробуйте поставить EAP2, включите эту опцию и посмотрите, что получится.
4829.26 4838.82 "Игорь Лабутин" Переключать можно между out of process и in process чуть ли потом не с тулбара, то есть это как бы сделано вообще офигенно прозрачно, все супер прозрачно работает.
4838.82 4893.46 "Игорь Лабутин" Второй новость, не новость, наверняка, если вы как-то в dot-мире следите за новостями, она не прошла мимо вас, это попытки поиспользовать copilot, не только предлагая его клиентам, но и прямо на, так сказать, репах Microsoft, на dot-net runtime реп попробовали поиспользовать copilot, и как-то пока опыт, ну, такой себе, copilot находит какие-то странные или может быть даже не странные проблемы, пытается их фиксить, фиксить с ошибками, и дальше вся толпа, значит, этих вот инженеров, профессионалов, которые пипишут dot-net runtime, пытается наставить на пусть истинный copilot, заставить его выполнять нужные тесты, указывать на ошибки в тестах и вот это все, потом видимо плюют и идут писать все руками, но пока опыт в общем такой, не очень успешный, но интересно, посмотрим, во что это вылиться.
4893.46 4929.54 "Анатолий Кулаков" Так, а я бы хотел рассказать про такого старичка как Mono, у нас какой-то юбилей случился, вышел Mono 6.14.0, не то чтобы он вам нужен, не то чтобы этот релиз чем-то примечательным, но очень интересно отметить, что этот релиз был выпущен компанией Vine, напомню, что 5 лет назад вышел предыдущий релиз Mono, то есть это первый релиз, который включает в себя изменения за последние 5 лет и это первый релиз Mono, который случился после того, как Microsoft передала всю разработку компании Vine.
4929.54 4954.14 "Анатолий Кулаков" В общем, вот чем он примечательный, ну то есть можно хотя бы констатировать, что Vine просто не забил о него, что он развивает его, собирает все изменения и все-таки вышел на релизный путь, может быть в будущем релизы появятся чаще, но опять не очень понятно, зачем и кому он нужен, кроме там Legacy проектов, которые раньше были на Mono и почему-то вот сейчас переписывать их никакого смысла нет.
4954.14 4966.94 "Анатолий Кулаков" Зачем что-то новое начинать, не знаю, у меня нет таких сведений, если вы знаете, зачем что-то новое пишется на Mono, то обязательно придите и расскажите, может быть что-то из геймдева с этим может быть связано.
4966.94 5000.34 "Анатолий Кулаков" Еще у нас интересная новость, что мы в принципе с Игорем подкасты пишем по вечерам, а на самом деле мы организуем митапы, и мы организуем митапы не только в Санкт-Петербурге, но и пытаемся сделать митапы в других городах, в которых дотнетчики могут собираться вместе, общаться и так далее, поэтому если у вас есть какие-то наметки на то, чтобы вы хотели собирать вместе дотнетчиков, но не знаете, как это сделать, не знаете, как делать митапы, мы в этом помогаем, поэтому приходите к нам, обязательно с вами обсудим этот вопрос.
5000.34 5008.06 "Анатолий Кулаков" Но рассказать я хотел не об этом, рассказать я хотел о новом городе, который мы запустили, это город-герой Севастополь.
5008.06 5039.90 "Анатолий Кулаков" У нас в Севастополе прошел первый дотнет-митап, который прошел довольно с большим аншлагом, там прозвучало два доклада, скоро записи появятся уже на нашем канале, или может быть, когда вы слушаете этот подкаст, уже появились, поэтому заходите, смотрите, а самое главное, если будете отдыхать в этом замечательном месте или вдруг там живете или в округе живете, обязательно заходите на митапы, обязательно поддерживайте сообщество и вообще активно участвуйте, будем развиваться, будем учиться все вместе.
5039.90 5040.90 "Игорь Лабутин" И это прекрасно.
5040.90 5084.26 "Игорь Лабутин" А сегодня, наверное, мы уже будем завершать, поговорили мы сегодня про дотнет эспайр 9.3, поговорили про возможность писать приложеньки теперь просто в CSS файликах и запускать через дотнетран, узнали, что ReSharper появился в Visual Studio Code, пока в ранней версии превью, но будет все развиваться, обсудили теорию и практические приемы того, как правильно реализовать Circuit Breaker, как его настраивать точнее и скорее, узнали про новую библиотечку zLinQ, Zero Allocation LinQ Library, посмотрели на замену SwaggerUI, Scalar, ну и обсудили немножечко разнообразных новостей.
5084.26 5088.90 "Игорь Лабутин" Это был 116 выпуск, на этом мы заканчиваем.
5088.90 5098.30 "Анатолий Кулаков" А вы не забывайте, что у нас есть комментарии, туда можно приходить, писать, рассказывать, жаловаться, поправлять, где мы неправы и всячески взаимодействовать.
5098.30 5107.14 "Анатолий Кулаков" Поэтому всем большое спасибо, кто пишет и обязательно те, кто слушает и рассказывает о нас своим друзьям и всячески распространяет информацию о подкасте.
5107.14 5109.86 "Анатолий Кулаков" Большое вам спасибо, друзья, и до новых встреч, всем пока.
5109.86 5110.66 "Игорь Лабутин" Всем пока.
