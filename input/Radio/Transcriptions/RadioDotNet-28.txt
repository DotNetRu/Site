0.00 9.48 "Анатолий Кулаков" Здравствуйте дорогие друзья, в эфире Radio.net выпуск номер 28.
9.48 12.08 "Анатолий Кулаков" И в студии как всегда Анатолий Кулаков.
12.08 13.88 "Анатолий Кулаков" И Игорь Лабутин, привет.
13.88 20.64 "Анатолий Кулаков" Мы бы хотели поблагодарить наших больших патронов, их выросло, у нас их теперь в два раза больше.
20.64 22.16 "Анатолий Кулаков" Александр, большое спасибо.
22.16 25.60 "Анатолий Кулаков" И Сергей, огромное тебе спасибо, что присоединился к нам.
25.60 31.72 "Анатолий Кулаков" Если вы не знаете о чем речь, заходите на наши сайты на патреоны Boosty и смотрите что там есть интересненького.
31.72 34.40 "Анатолий Кулаков" А что же у нас интересненького в мире дотнета?
34.40 35.40 "Игорь Лабутин" Ну как?
35.40 37.88 "Игорь Лабутин" Последняя новость недавняя, новая Visual Studio.
37.88 42.60 "Игорь Лабутин" И это не какой-то очередной там 16.10 превью X, это прям
42.60 48.56 "Анатолий Кулаков" 20.22. Наконец-то, действительно анонсирована студия 2022.
48.56 51.20 "Анатолий Кулаков" И давайте пробежимся по ее фичам.
51.20 54.76 "Анатолий Кулаков" Самая главная фича естественно это новые иконочки.
54.76 57.64 "Анатолий Кулаков" Игорь, ты не поверишь, они просто великолепны.
57.64 73.96 "Анатолий Кулаков" Иконочки все перерисовали, они теперь стали лучше видны, они теперь стали контрастнее, они теперь стали больше, они сделаны под разные цвета, под разные темы студии и прекрасно вписываются в любой ваш дизайн, какой бы темой вы не пользовались.
73.96 76.36 "Игорь Лабутин" Надеюсь они теперь не анимированные?
76.36 79.00 "Анатолий Кулаков" Пока еще слава богу нет, но уже смотрятся очень
79.00 83.68 "Игорь Лабутин" хорошо. Это было бы прикольно, такие прыгающие смайлики по всему тулбару, это здорово.
83.68 87.68 "Игорь Лабутин" Нет, подожди, ладно, иконки иконками, мне кажется это не так.
87.68 88.68 "Игорь Лабутин" Давай про 64 бита.
88.68 94.80 "Анатолий Кулаков" Ну конечно же, самая главная новость это в том, что наша Visual Studio наконец-то станет 64-битной.
94.80 101.20 "Анатолий Кулаков" Это означает, что ей не нужно больше будет ужиматься в 4 гигабайта оперативной памяти.
101.20 105.88 "Анатолий Кулаков" А в чем, да, давай разберем, в чем вообще все это было плохо.
105.88 109.32 "Анатолий Кулаков" Плохо это было потому, что даже самой студии не хватало 4 гигабайта памяти.
109.32 118.60 "Анатолий Кулаков" Если она начинала загружать свои компоненты, если она начала загружать свою визуализацию, а после того, как появился Rosslyn, то это вообще стал ад.
118.60 125.36 "Анатолий Кулаков" Именно поэтому Rosslyn начали выносить в отдельный процесс, запускать его в стороне от основного процесса Visual Studio.
125.36 134.32 "Анатолий Кулаков" То есть проблемы явно были налицо, все это понимали, но многие годы официальные ответы были в том, что это практически невозможно сделать.
134.32 145.12 "Анатолий Кулаков" Вся студия пронизана ком-объектами какими-то старыми легосами, API-ами и никаких 64-битов здесь быть не может и мечтать вам об этом не нужно.
145.12 155.12 "Анатолий Кулаков" Перенос студии на 64-разрядную систему - это был один из самых популярных реквестов на UserVoice еще с 2008 года.
155.12 167.16 "Анатолий Кулаков" То есть в тот момент, когда все обсуждали новинки 2010 студии, самое популярное требование было - дайте нам, наконец, нормальный 64-разрядный процесс.
167.16 170.76 "Анатолий Кулаков" То есть, смотри, уже больше 12 лет.
170.76 173.84 "Анатолий Кулаков" Больше 12 лет, и мы, кажется, дождались.
173.84 180.56 "Игорь Лабутин" Может, все это время Microsoft говорила "не-не-не-не, не будет", но у них это заняло как раз таки 12 лет аккуратненько, хочешь что-то переделать.
180.56 187.44 "Анатолий Кулаков" Я, в принципе, не удивлюсь, потому что если ты заметишь, вот последние годы как раз таки Visual Studio начала двигаться, начала развиваться.
187.44 204.96 "Анатолий Кулаков" Ну, вот те же самые фиксы появились, поиски всякие, много разных рефакторингов, ну то есть вот эта вся динамика, когда она действительно жила, когда начали задумываться о перформансе, о рефакторингах, о переносимости - вот это буквально произошло недавно на наших глазах.
204.96 213.48 "Игорь Лабутин" Так что… Ну, может, действительно, Microsoft-команда как-то очень втихаря много чего готовила для того, чтобы иметь возможность потом всё-таки что-то перенести на 64 бита.
213.48 230.24 "Игорь Лабутин" Ладно, ты упомянул, что одна из причин, почему Microsoft долгое время отказывалась это делать, была там куча COM-интерфейсов и вот этого всего, и когда мы говорим про COM-интерфейсы, для студии все, конечно же, вспоминают любые плагины, которые через эти самые COM-интерфейсы общаются.
230.24 232.76 "Игорь Лабутин" А мне кажется, что переезд на 64 бита должен всё сломать.
232.76 233.76 "Игорь Лабутин" Или нет?
233.76 234.76 "Анатолий Кулаков" Как?
234.76 243.16 "Анатолий Кулаков" В принципе, официальных гайдов пока ещё нет, но судя по каким-то комментариям, действительно, API поменяется и будем следить.
243.16 245.52 "Анатолий Кулаков" Пока ещё ничего официально не выложено.
245.52 249.80 "Игорь Лабутин" Ну, будем надеяться, что Microsoft даст достаточно времени плагинным писателям, чтобы всё переписать.
249.80 252.00 "Игорь Лабутин" Хорошо, давай с другой стороны посмотрим.
252.00 262.48 "Игорь Лабутин" Ты сам опять же сказал, что Microsoft многие компоненты сначала переносит извне процесса студии и этим же занимался, как мы знаем, например, ReSharper, тоже как достаточно прожорливый плагин.
262.48 270.80 "Игорь Лабутин" Значит ли это, что теперь, когда мы переходим обратно в 64-битный мир, мы можем забить на все эти дела и просто жить спокойно в одном большом процессе?
270.80 273.28 "Игорь Лабутин" Или out of process всё ещё нужен?
273.28 279.16 "Анатолий Кулаков" Это интересный вопрос и давай-ка мы его зададим непосредственно людям, которые в этом разбираются.
279.16 286.12 "Анатолий Кулаков" И как раз у нас сейчас в студии руководитель всех .NET продуктов в JetBrains Сергей Кукс.
286.12 287.12 "Анатолий Кулаков" Привет, Сергей!
287.12 288.12 "Анатолий Кулаков" Привет, Анатолий!
288.12 300.20 "Анатолий Кулаков" Но сегодня Сергей нам интересен не как руководитель всего .NET, а как разработчик, который занимается непосредственно тем, что выносит ReSharper в отдельный 64-битный процесс.
300.20 304.52 "Анатолий Кулаков" Сергей, расскажи для начала, как продвигается вынос ReSharper в отдельный процесс?
304.52 306.36 "Анатолий Кулаков" Когда вы планируете его закончить?
306.36 309.40 "Анатолий Кулаков" Мы довольно давно об этом уже слышим, давно ждём.
309.40 311.92 "Анатолий Кулаков" В каком статусе вообще сейчас находится эта задача?
311.92 314.68 "Сергей Кукс" Это статус work in progress.
314.68 330.84 "Сергей Кукс" На самом деле мы довольно хорошо продвинулись, у нас остался, как бы это сказать, это довольно сложная история в том смысле, что у нас есть абстракция, которая цепляется за студийную абстракцию текстового редактора.
330.84 342.96 "Сергей Кукс" И эта же абстракция цепляется за нашу абстракцию текстов, документов, которые уходят в проектную модель и в код модель дальше, и в всё то, что должно жить на backend.
342.96 354.36 "Сергей Кукс" А с другой стороны, это всё упирается уже в то, что связано со студийным API, которое интегрируется непосредственно в редактор.
354.36 360.12 "Сергей Кукс" Это там аддорменты, скроллинг текст-файла и вот это всё.
360.12 375.64 "Сергей Кукс" И у нас остался ровно один юзыч, который нам нужно извести в интеграции в студийный API, чтобы после этого мы наконец могли расщепить абстракцию текстового редактора на фронт-эндную и бэк-эндную часть, и дальше оно уже поехало.
375.64 378.56 "Сергей Кукс" В общем и целом, это ровно то, чем мы сейчас занимаемся.
378.56 390.72 "Сергей Кукс" Мой коллега изводит этот последний юзыч, а я параллельно вот прямо сейчас пилю эту абстракцию пополам и надеюсь, что мы сольёмся где-то на этой неделе.
390.72 402.04 "Сергей Кукс" После этого мы, собственно, распилим эту абстракцию и попробуем завести out-of-process, ну такой, типа, чтобы в редакторе что-нибудь нарисовалось, и посмотрим, как это будет.
402.04 406.16 "Сергей Кукс" Но в общем и целом, план у нас такой, показать что-нибудь на публике в этом году.
406.16 420.72 "Сергей Кукс" Ничего более конкретного обещать я не хочу, потому что непонятно, как оно в реальности случится раз, и непонятно, сколько усилий от нас займёт, в частности, интеграция в 64-битные студии, которую нам вот-вот обещают.
420.72 422.72 "Анатолий Кулаков" Ну, уже звучит неплохо.
422.72 433.88 "Анатолий Кулаков" Смотри, а если мы всё-таки говорим про отдельную студию, а нужен ли вообще продолжать этот процесс расщепления решаперой студии, если у нас выходит 64-битная студия?
433.88 438.32 "Анатолий Кулаков" Или может вообще эту задачу лучше заканчевать и, в принципе, и так всё будет хорошо?
438.32 439.32 "Сергей Кукс" Нет, нужно.
439.32 442.44 "Сергей Кукс" Продолжать нужно по куче причин.
442.44 447.20 "Сергей Кукс" Причина первая, студию, конечно, обещали в этом году, ну, показать.
447.20 454.72 "Сергей Кукс" В реальности она называется 2022, и я честно не верю в релиз студии раньше следующего года.
454.72 455.72 "Сергей Кукс" Это раз.
455.72 463.56 "Сергей Кукс" Два, далеко не все наши кастомеры и, думаю, что студийные тоже сразу же обновляются на новую студию.
463.56 472.52 "Сергей Кукс" Это означает, что существенная часть этих людей будет сидеть на старых версиях студии, а значит, они никаких 64-битных не получат.
472.52 473.52 "Сергей Кукс" Это два.
473.52 480.64 "Сергей Кукс" Ну и третье, 64-битная студия, это, конечно, здорово, и она нам, скорее всего, решит проблемы с памятью.
480.64 487.36 "Сергей Кукс" Если только, например, студия не решит ограничивать память, потребляемую каждым конкретным экстеншеном.
487.36 489.36 "Сергей Кукс" Что там будет в реальности, мы не знаем.
489.36 504.36 "Сергей Кукс" Но даже при этом выносить все вот этот процесс, ну, совсем не вредно, потому что, во-первых, все-таки проблемы с памятью уходят, а во-вторых, вынос в другой процесс, он сопровождается естественным переписыванием API-шек.
504.36 508.48 "Сергей Кукс" Все то, что раньше было синхронное, мы, естественно, делаем асинхронным.
508.48 514.00 "Сергей Кукс" И делаем это с пониманием того, что этот асинхронный вызов может быть долгим.
514.00 518.84 "Сергей Кукс" И вот это как раз позволяет заметно улучшить experience.
518.84 525.60 "Сергей Кукс" В редакторе, например, когда ты печатаешь, сейчас бывает так, что ReSharper хочет синхронно что-нибудь поделать.
525.60 526.60 "Сергей Кукс" Ну, например, typing assist.
526.60 530.84 "Сергей Кукс" Так вот, ты там напечатал скобочку, и нам нужно понять, в какое место вставить парную.
530.84 534.16 "Сергей Кукс" А для этого нам нужно сделать репарс файла.
534.16 541.28 "Сергей Кукс" А если ты печатаешь файлики на 200 тысяч строк, ты, конечно, сам себе злобный, Буратино, но так тоже бывает.
541.28 545.24 "Сергей Кукс" И вот этот асинхронный репарс 200 тысяч строк — это долго.
545.24 548.80 "Сергей Кукс" А так мы его сделаем асинхронно в бэкграунд-процессе и, может быть, выкинем.
548.80 550.80 "Сергей Кукс" Ну, правда, скобку тебе, может, не напечатать.
550.80 553.32 "Сергей Кукс" Но, по крайней мере, у тебя typing.
553.32 554.32 "Анатолий Кулаков" Хорошо.
554.32 568.24 "Анатолий Кулаков" А если все-таки учесть, что вот асинхронный API вы сделаете, в отдельные процессы вынесите, а принесет ли вообще ReSharper или другим, может быть, студийным плагинам какую-то пользу, то, что студия теперь станет 64-битной?
568.24 571.04 "Анатолий Кулаков" Ну, другим плагинам ладно, они в одном процессе.
571.04 577.52 "Анатолий Кулаков" А вам, если вы все-таки уйдете в другой процесс, вам от этого холодно или жарко, что она теперь 64-разрядная, или все равно уже?
577.52 582.48 "Сергей Кукс" Ну, до тех пор, пока мы не ушли в другой процесс, нам от этого очень даже жарко.
582.48 585.08 "Сергей Кукс" От нас уйдет куча проблем с памятью.
585.08 589.68 "Сергей Кукс" Ну и, соответственно, будет меньше ГЦ, и все будет работать быстрее.
589.68 593.36 "Сергей Кукс" Ну, в некотором смысле райдер — это такое маленькое приближение.
593.36 599.00 "Сергей Кукс" Да, то есть там далеко не все API-шки асинхронны, хотя тоже есть уже какое-то количество.
599.00 605.36 "Сергей Кукс" Но главное, что памяти намного больше, ГЦ случается намного реже еще и в другом процессе.
605.36 609.04 "Сергей Кукс" И это нам действительно всем поможет, и нам, и другим
609.04 613.96 "Анатолий Кулаков" экстеншенам. А на что вы сейчас делаете больше упор, на райдер или на решарпер?
613.96 620.48 "Анатолий Кулаков" Или они уже, ну, получается, как-то они конкурируют, тем более, если у нас будет решарпер полноценно в отдельном процессе.
620.48 625.72 "Анатолий Кулаков" Есть ли вообще публичная статистика использования, что чаще используют райдер, решарпер?
625.72 626.72 "Сергей Кукс" Статистика есть.
626.72 630.56 "Сергей Кукс" И вот я специально смотрел ее сегодня.
630.56 638.68 "Сергей Кукс" Решарпер где-то 350 тысяч активных ежемесячных пользователей, райдер чуть больше 200 тысяч.
638.68 643.64 "Сергей Кукс" Но они не конкурируют, и более того, для нас это вообще один продукт.
643.64 649.00 "Сергей Кукс" Мы продаем не решарпер, и не райдер, и не профилятор, а мы продаем dotAltium.
649.00 660.44 "Сергей Кукс" Это единый пользовательский экспириенс, если он программирует для дотнета, то вне зависимости от платформы, вне зависимости от желаемых продуктов, у нас всегда есть tool.
660.44 674.08 "Сергей Кукс" Если наш пользователь почему-то живет в студийной эписистеме, ну, например, это довольно типично для корпоративного пользователя, корпорация сидит на маркосовском стеке и никуда не девается, тогда у нас есть решарпер.
674.08 679.96 "Сергей Кукс" Если пользователь занимается, не знаю, на маке или на линуксе разработкой, вот у нас есть райдер.
679.96 682.80 "Сергей Кукс" И плюс к этому всегда у нас есть профиляторы.
682.80 685.44 "Сергей Кукс" У нас есть dotTrace, у нас есть dotMemory.
685.44 689.32 "Сергей Кукс" Если пользователь хочет читать код, у нас есть декомпилятор dotPick.
689.32 695.52 "Сергей Кукс" Если пользователю нужен код-кавер, еще у нас есть dotCover, который бывает и стенд-аунд, встроенный в решарпер и в райдер.
695.52 699.96 "Сергей Кукс" И по смыслу для нас это, вообще говоря, отдельный продукт.
699.96 706.48 "Сергей Кукс" У нас есть общая платформа, которая раньше была решарпером, а теперь это бэкэнд, что к решарперу, что к райдеру.
706.48 710.80 "Сергей Кукс" И для нас это все один большой продукт, который мы пользуемся и предлагаем.
710.80 717.36 "Анатолий Кулаков" Да, здесь, наверное, большая проблема с точки зрения разработчиков, что им приходится выбирать, что они все-таки хотят.
717.36 719.76 "Анатолий Кулаков" И студийный интерфейс, или интерфейс райдера.
719.76 724.44 "Анатолий Кулаков" Вот здесь их разрывает, и некоторые для себя не могут однозначного ответа найти.
724.44 727.28 "Сергей Кукс" Мы тоже не можем найти для себя однозначного ответа.
727.28 734.52 "Сергей Кукс" Мне, например, лично мне, визуально студия приятнее, но райдер для меня намного более функциональный.
734.52 737.92 "Сергей Кукс" Поэтому я программирую в том и в другом, в зависимости от задач.
737.92 743.12 "Сергей Кукс" Ну, да, и в некотором смысле это соответствует нашему предложению.
743.12 748.56 "Сергей Кукс" Мы не можем использовать у нас Dota Ultimate, но можем использовать то, что в данный момент больше подходит для задач.
748.56 751.44 "Сергей Кукс" И не нужно конкурировать, не нужно выбирать.
751.44 754.00 "Анатолий Кулаков" Хорошо, давай вернемся под новую студию.
754.00 764.48 "Анатолий Кулаков" Я надеюсь, вы уже начали решарпер портировать под 64-разрядную студию, и можешь поделиться впечатлениями, насколько это вообще сложно или легко просто перекомпилировать и все?
764.48 767.12 "Сергей Кукс" Не могу, потому что мы еще не начали, потому что студии
767.12 769.84 "Анатолий Кулаков" нет. То есть ее не предоставили даже для разработчиков
769.84 771.84 "Сергей Кукс" плагинов, да? Ее не предоставили.
771.84 776.16 "Сергей Кукс" У нас есть SDK, но по нему пока сказать что-то сложно.
776.16 783.96 "Сергей Кукс" Мы кое-что пощупали, бинарные форматы, например, описания экшена в студии не поменялись, но это вершина айсберга.
783.96 787.92 "Сергей Кукс" Пока у нас не будет студии, что-то внятное сказать сложно.
787.92 789.92 "Сергей Кукс" Решарпер по 64 бита мы собирать умеем.
789.92 791.92 "Сергей Кукс" Это называется райдер.
791.92 794.24 "Сергей Кукс" 85% общего кода.
794.24 799.68 "Анатолий Кулаков" И то есть ты не знаешь, насколько вообще API для плагинов изменился?
799.68 801.32 "Анатолий Кулаков" То есть что ждет вообще старые плагины?
801.32 802.92 "Анатолий Кулаков" Их надо переписывать или не надо?
802.92 804.20 "Анатолий Кулаков" Или что Microsoft обещает?
804.20 805.20 "Анатолий Кулаков" Ничего не зря.
805.20 807.64 "Сергей Кукс" Их точно надо переписывать.
807.64 810.08 "Сергей Кукс" Там точно есть мигрэйшн гайд.
810.08 811.08 "Сергей Кукс" Но он так...
811.08 816.76 "Сергей Кукс" Ну я бегал по нему глазами очень приблизительно и он такой без больших деталей.
816.76 819.80 "Сергей Кукс" Пока реально не начну делать, очень сложно что-то сказать.
819.80 820.80 "Анатолий Кулаков" Отлично.
820.80 823.20 "Анатолий Кулаков" Ты прояснил многие вопросы, которые у нас возникли.
823.20 824.44 "Анатолий Кулаков" Большое тебе спасибо.
824.44 830.12 "Анатолий Кулаков" Я напоминаю, что у нас в гостях был Сергей Кукс, руководитель .NET продуктов компании JetBrains.
830.12 831.12 "Анатолий Кулаков" Пока, Сергей.
831.12 832.12 "Игорь Лабутин" Пока, всегда пожалуйста.
832.12 834.12 "Игорь Лабутин" Ну хорошо. 64 бита.
834.12 835.12 "Игорь Лабутин" Это здорово.
835.12 838.92 "Игорь Лабутин" Мы много чего узнали и посмотрим, как это все будет развиваться.
838.92 840.88 "Игорь Лабутин" Но это же не все изменения.
840.88 843.52 "Игорь Лабутин" Иконочки, конечно, важнее, несомненно.
843.52 845.16 "Игорь Лабутин" Но есть еще что-нибудь наверняка.
845.16 847.92 "Анатолий Кулаков" Ну и с глобальным это по сути все, чем нас порадовали.
847.92 850.44 "Анатолий Кулаков" Можно даже сказать так.
850.44 853.48 "Анатолий Кулаков" На фоне этого меркнет все остальное.
853.48 857.56 "Анатолий Кулаков" Естественно, как и в любой студии, нас ждет самый последний .NET.
857.56 860.44 "Анатолий Кулаков" Это .NET 6.
860.44 863.28 "Анатолий Кулаков" Будет поставляться вместо всей этой студии.
863.28 866.40 "Анатолий Кулаков" Blazer будет улучшен и заперфомен.
866.40 870.24 "Анатолий Кулаков" MAUI будет как официальный UI фреймворк.
870.24 877.96 "Анатолий Кулаков" Заимпровится Live Sharing и прочие-прочие такие мелочи, которые в принципе, наверное, мы уже привыкли, ждем и никого ты этим не удивишь.
877.96 884.00 "Анатолий Кулаков" Еще одна из интересных новинок заключается в том, что Microsoft активно будет продвигать Cascadia Code.
884.00 886.08 "Анатолий Кулаков" Это новый фонд.
886.08 888.84 "Анатолий Кулаков" Это новый шрифт от Microsoft, который поддерживает лигатуры.
888.84 896.84 "Анатолий Кулаков" В принципе, непонятно, придет ли он на смену дефолтному консоли, который сейчас существует или будет существовать как альтернатива.
896.84 899.40 "Анатолий Кулаков" Но в принципе, шрифт довольно популярный.
899.40 904.24 "Анатолий Кулаков" Его можно скачать с GitHub уже довольно-таки давно.
904.24 906.88 "Анатолий Кулаков" Поэтому, если кому-то интересно, скачивайте, смотрите.
906.88 910.28 "Анатолий Кулаков" Я помню, когда я первые превьюшки смотрел, у него не было поддержки русского языка.
910.28 914.52 "Анатолий Кулаков" Но я уверен, что уже на данном этапе все с этим хорошо.
914.52 918.68 "Анатолий Кулаков" Наверное, примечательен тот факт, что раньше Microsoft не очень обращала внимание на лигатуры.
918.68 923.76 "Анатолий Кулаков" И вот Cascadia Code как раз-таки будет вместе с лигатурами.
923.76 928.64 "Анатолий Кулаков" Наверное, это первый дефолтный шрифт от Microsoft, который поддерживает эту интересную штуку.
928.64 932.28 "Игорь Лабутин" Ну, посмотрим, как будет происходить его адаптация разработчиками.
932.28 937.24 "Игорь Лабутин" Ему придется посоревноваться с FearCode и с JetBrains Mono.
937.24 940.72 "Игорь Лабутин" Так что, может, у Microsoft получится тоже неплохо в этом смысле.
940.72 945.80 "Игорь Лабутин" Кому-то понравится он больше, чем другие шрифты с лигатурами для разработчиков.
945.80 948.60 "Игорь Лабутин" И надо сказать, что студия пока это еще только анонс.
948.60 950.96 "Игорь Лабутин" Первые превью обещают к лету.
950.96 954.80 "Игорь Лабутин" Так что, или летом, если быть более точным.
954.80 959.64 "Игорь Лабутин" Так что посмотрим, никаких пока официальных, я так понимаю, абсолютных планов по релизу пока нет.
959.64 966.80 "Анатолий Кулаков" С C# 10 тоже пока не густо, но кое-какие интересные фичи уже обсуждаются на GitHub.
966.80 975.48 "Игорь Лабутин" Да, уже обсуждаются, ты сказал, неплохо, потому что на самом деле некоторые из них обсуждаются уже с 2017 или около того годов.
975.48 988.32 "Игорь Лабутин" Я просмотрел кучу всяких дизайнов, которые сейчас в работе, так скажем, в разной степени готовности к тому, что они попадут в некоторые 10 C# условный.
988.32 999.52 "Игорь Лабутин" Но мы можем про ним пробежаться, посмотреть, что из этого мы давно знаем и давно ждем, что из этого совсем новенькое, и составить некоторое свое мнение о том, что происходит сейчас в C#.
999.52 1008.56 "Игорь Лабутин" Сразу дисклеймер, все то, что сейчас я и Анатолий будем рассказывать, оно еще не вообще в каком confirmed статусе.
1008.56 1015.40 "Игорь Лабутин" Надо сказать, что даже то, что уже готово, сделано и вмерзжено в код, это не означает, что оно попадет в финальный C#.
1015.40 1034.60 "Игорь Лабутин" Мы много раз видели, как фичи из языка убирались перед релизом, поэтому сказать что-то более точное на тему того, что вот это точно будет в C# 50 и в DotNet 6 соответственно, можно будет только ближе, наверное, к концу лета, к осени, когда будет уже формироваться непосредственно релиз и начинаться фича freeze.
1034.60 1040.16 "Игорь Лабутин" Но, тем не менее, интересно посмотреть, куда действительно думают, в какую сторону разработчики языка.
1040.16 1049.04 "Игорь Лабутин" И есть четыре вещи, которые уже реализованы, которые уже закоммичены в мейн-ветку и которые можно попробовать, если вы используете ранние превьюшки.
1049.04 1055.00 "Игорь Лабутин" Во-первых, можно теперь делать deconstruction от дефолта.
1055.00 1058.84 "Игорь Лабутин" Достаточно такая интересная фича, я долго пытался осознать, зачем она может быть нужна.
1058.84 1067.32 "Игорь Лабутин" То есть вы можете теперь написать там, открыть скобочку круглую, написать int i, стринг s, закрыть круглую скобочку, присвоить дефолт точку с запятой.
1067.32 1072.52 "Игорь Лабутин" То есть такому deconstruction присвоить просто значение дефолт.
1072.52 1075.28 "Игорь Лабутин" Это означает то же самое, что написать там, дефолт, запятая дефолт.
1075.28 1077.92 "Игорь Лабутин" То есть присвоить по дефолту в каждый из компонент.
1077.92 1079.88 "Анатолий Кулаков" Ты все-таки осознал, зачем она нужна?
1079.88 1086.48 "Анатолий Кулаков" Потому что это ничем не отличается, если ты просто объявишь переменные в этом скопе и все, они по умолчанию получат значение дефолт.
1086.48 1092.20 "Игорь Лабутин" И все так, и действительно в высших языках было некоторое количество обсуждений, типа зачем бы это может быть надо?
1092.20 1095.24 "Игорь Лабутин" Ммм, так удобно в конструкторе инициализировать все поля в дефолт.
1095.24 1096.24 "Игорь Лабутин" Ммм, да конечно так, в дефолт.
1096.24 1101.56 "Игорь Лабутин" Вот в таком духе были обсуждения, потом на самом деле нашли один полезный use case.
1101.56 1112.72 "Игорь Лабутин" Это типа, если у тебя есть метод сгороя out параметров, и тебе после проверки каких-то входных данных выяснилось, что тебе надо сделать early exit, но out параметры ты же обязан заполнить.
1112.72 1118.64 "Игорь Лабутин" И вот таким образом ты out параметры, значение этих out параметров быстро заполнишь дефолтными значениями.
1118.64 1119.64 "Игорь Лабутин" Вот.
1119.64 1125.68 "Игорь Лабутин" Каких-то сильно других use cases в высших языках не было замечено, но вот такая штука есть.
1125.68 1137.28 "Анатолий Кулаков" Ну, наверное да, это какая-нибудь штука, которую можно отдать студенту и он это быстренько на коленочки состряпает, не без вреда для остального языка.
1137.28 1139.40 "Анатолий Кулаков" В принципе смотрится довольно гармонично, но почему бы
1139.40 1144.64 "Игорь Лабутин" и нет? Ну да, оно вот именно такое, чисто минорное дополнение, очень-очень минорное, я бы сказал.
1144.64 1161.08 "Игорь Лабутин" Следующая штука это constant interpolated strings, то есть если у вас есть интерполированный строчек, там доллар, кавычка, бла-бла, дальше что-то в фигурных скобочках и там кавычка где-нибудь закрылась, то раньше, ну и сейчас в смысле в современном дотнете, это всегда конструируется в рантайме.
1161.08 1166.40 "Игорь Лабутин" То есть даже если то, что вы указали в фигурных скобочках, это тоже константная строка, все равно все конструируется в рантайме.
1166.40 1175.96 "Игорь Лабутин" Сейчас, соответственно, это изменено так, что если и сама строчка, которая с долларом, и то, что в нее подставляется, это константные строки, то это все за вас подставит компилятор.
1175.96 1191.20 "Игорь Лабутин" Тоже особо use-case'ов народ не нашел, потому что по большому счету ты либо конкретинация, ты можешь написать и компилятор все развернет, тоже уровня, что чуть приятнее выглядит визуально, если вы пишете через интерполированные строки.
1191.20 1214.76 "Игорь Лабутин" Так, и следующее тоже про deconstruction, это такая штука, теперь можно совмещать объявления переменных и автоматическую и deconstruction, то есть можно теперь прямо написать, типа "вар r,int_error" присвоить, await какой-нибудь функции.
1214.76 1228.92 "Игорь Лабутин" В высших сетях это называют в стиле языка Go, везде, где вы обязаны явно взорвать ошибку, но теперь можно это как бы сразу совместить объявление переменной и ее deconstruction, результата.
1228.92 1236.72 "Игорь Лабутин" Мне считается, что это похоже на out, как теперь можно стало декларировать переменную везде, где out, при вызове функции, ну вот такая же теперь в deconstruction штука поддержана.
1236.72 1237.72 "Игорь Лабутин" Ну, допустим.
1237.72 1246.56 "Игорь Лабутин" И четвертая фича, которую сделали, тоже у меня заняло наверное минут 10 понять, нафига она нужна, вернее нафига она нужна, было понятно, не было понятно, что они сделали.
1246.56 1269.20 "Игорь Лабутин" В общем, смотрите, если у нас есть record, если мы у рекорда за override'ем to_string пометим его как sealed, ну что типа вот, он типа защищенный для наследования, то и после этого объявим несколько наследников этого рекорда, то очевидно с to_string за override'ить нельзя, она sealed, правильно?
1269.20 1272.12 "Анатолий Кулаков" Да, судя по спецификации языка именно так.
1272.12 1279.16 "Игорь Лабутин" Вот, но поскольку это record, то record по умолчанию включает в себя автогенерированный to_string, логично?
1279.16 1280.16 "Игорь Лабутин" Да.
1280.16 1282.24 "Игорь Лабутин" Ну который там красиво расписывает все поля.
1282.24 1301.24 "Игорь Лабутин" Так вот это означает, что если у тебя есть класс рекорда, рекорд класс с sealed to_string'ом, то ты не можешь на самом деле создать дочерних рекордов вообще, потому что у тебя to_string sealed и тебе компилятор физически ругается, что вот тот to_string, который сгенерился в дочернем рекорде, он не может быть там сгенерен, потому что у тебя базовый класс sealed.
1301.24 1310.08 "Анатолий Кулаков" Ну нельзя было просто пропустить to_string и все остальное сгенерить, это как бы не критика функциональности для рекордов.
1310.08 1324.36 "Игорь Лабутин" Это первое, а вторая штука, что ты можешь хотеть такую вещь, если у тебя, например, есть такой через рекорды симулированный discriminated union, где тебе нужно, у тебя только базовый to_string'ер должен работать.
1324.36 1333.76 "Игорь Лабутин" Ну у тебя есть какое-то базовое поле, которое только его ты хочешь выводить, например, в to_string'е, и тебе достаточно базовой реализации to_string'а в базовом классе, тебе не нужно ее оверрайдить.
1333.76 1341.88 "Игорь Лабутин" В текущей варианте тебе нужно, чтобы так это работало, тебе нужно заоверрайдить to_string'и у всех дочерних и там везде написать тупо base.to_string.
1341.88 1345.84 "Игорь Лабутин" Короче, что сделали?
1345.84 1363.12 "Игорь Лабутин" Теперь можно в рекорде to_string'а обозвать sealed, в этом случае при генерации дочерних он будет понимать, что для вызова to_string'а у дочерних нужно как раз сделать то, что примерно ты и сказал, не генерить to_string' для дочерних, и чтобы вызывался тупо базовый.
1363.12 1364.12 "Игорь Лабутин" Автоматически.
1364.12 1369.72 "Игорь Лабутин" Ну он автоматически будет вызываться, очевидно, поскольку он наследован.
1369.72 1376.24 "Игорь Лабутин" И это позволяет делать более красивый discriminated unions, на самом деле, который сейчас как раз через рекорд народ делает.
1376.24 1377.24 "Игорь Лабутин" Вот.
1377.24 1380.36 "Игорь Лабутин" То есть тут такой очень edge case в каком-то смысле, но вот сделали.
1380.36 1384.32 "Анатолий Кулаков" Ну получается более умный, наверное, более грамотный генератор.
1384.32 1392.24 "Игорь Лабутин" Да, более грамотный генератор и более красивый код, потому что рекорды, они же про однострочники почти все, да, ну там очень часто рекорд это просто однострочная штука.
1392.24 1401.00 "Игорь Лабутин" И так там действительно вышли, есть хороший пример того, как красиво на нем пишется такой псевдо-дискриминитед юнион на вот таких рекордах.
1401.00 1407.64 "Игорь Лабутин" Остальные все фичи помечены как in progress, то есть это значит, что над ними ведется работа, как я уже говорил над некоторыми с 2017 года.
1407.64 1418.00 "Игорь Лабутин" Но в общем они в разной степени готовности, продвинутости и так скажем, для них существенно разные шансы быть включенными в финальный вариант спики.
1418.00 1419.00 "Игорь Лабутин" Ну посмотрим.
1419.00 1420.00 "Игорь Лабутин" Поехали по порядку.
1420.00 1421.00 "Игорь Лабутин" Рекорд стракты.
1421.00 1424.72 "Игорь Лабутин" Ну тут как бы очевидно, рекорд класса у нас есть, теперь нужны рекорд стракты.
1424.72 1429.60 "Анатолий Кулаков" Неужели это не просто заменить слово класс на слово стракт и все, и готово, готово фичи?
1429.60 1430.92 "Анатолий Кулаков" Что там можно делать?
1430.92 1452.40 "Игорь Лабутин" Вроде как там более-менее примерно так и есть, но там есть какие-то тонкости работы, как бы вот семантики этих value типов и того, как там все это делается с учетом override-нутых методов и того, как тебе нужно там конструкторы генерить и вот это все там будет еще немножко про конструкторы дальше в структурах, поэтому ну там не все так просто, было бы просто давно бы сделали.
1452.40 1456.72 "Анатолий Кулаков" Расскажи, Игорь, уже известно, каким образом мы будем отличать рекорды класса от рекордов страктов?
1456.72 1460.80 "Игорь Лабутин" Ну мы так и будем писать там public record struct, дальше
1460.80 1464.84 "Анатолий Кулаков" имя. А можно будет написать public record class и дальше имя?
1464.84 1465.84 "Игорь Лабутин" Да, обязательно.
1465.84 1472.56 "Игорь Лабутин" Там это отмечено отдельно, что типа если мы будем делать рекорд стракт, то нужно обязательно позволить рекорд класс тоже, да.
1472.56 1482.76 "Анатолий Кулаков" Ну хотя бы, но тогда непонятно, почему они сразу допустили слово рекорд без указания типа, почему бы сразу не выдали бы нам рекорд класс и не мучились бы вот этой глупостью?
1482.76 1483.76 "Анатолий Кулаков" Не знаю, не знаю.
1483.76 1487.84 "Игорь Лабутин" Видимо по дефолту все-таки считается, что должны быть классы, потому что с ними проблем меньше, видимо.
1487.84 1489.80 "Игорь Лабутин" А структура только если очень хочешь.
1489.80 1493.28 "Анатолий Кулаков" Наверное, чтобы сократить опять же вот этот синтез этого однострочника, да?
1493.28 1496.28 "Игорь Лабутин" Ну да, что у тебя там длинное будет?
1496.28 1499.28 "Игорь Лабутин" Public final, final это java, sorry.
1499.28 1505.80 "Игорь Лабутин" Public field, что там, класс, рекорд и вот где-то там в конце 80-й колонки уже имя, нормально.
1505.80 1513.56 "Анатолий Кулаков" Ну зато видишь, оставили еще один вопрос на собеседование, во что возвращаются по дефолту рекорды в классу или в стракты, наверное, опять такой глупости будем замучиваться.
1513.56 1514.56 "Игорь Лабутин" Ну да, хорошо.
1514.56 1515.56 "Игорь Лабутин" Ладно, давай дальше.
1515.56 1526.80 "Игорь Лабутин" Следующее, мы довольно много, ну мы может быть и не очень много в этом подкасте, но вообще интернет очень много обсуждал дефолтные методы интерфейсов.
1526.80 1528.44 "Игорь Лабутин" Я бы даже сказал бурлил.
1528.44 1532.64 "Игорь Лабутин" Готовься к следующей части, статические абстрактные методы в интерфейсах.
1532.64 1539.84 "Анатолий Кулаков" Подожди, подожди, то есть в интерфейсах статические, а теперь еще эти статические абстрактные?
1539.84 1543.96 "Игорь Лабутин" Ну то есть, скажем, абстрактные методы в интерфейсах меня не пугают.
1543.96 1547.36 "Игорь Лабутин" Собственно, у нас интерфейс по сути и состоит из абстрактных методов.
1547.36 1553.76 "Анатолий Кулаков" Ну теперь, после того, как там есть дефолтные, то абстрактный метод в интерфейсе наверняка подразумевает нечто другое совсем.
1553.76 1559.12 "Анатолий Кулаков" А теперь расскажи мне, кто может перекрыть статические абстрактные методы в интерфейсе?
1559.12 1562.32 "Игорь Лабутин" Тот, кто его реализует, очевидно, этот самый интерфейс.
1562.32 1565.36 "Игорь Лабутин" Че, нормально, статик методы можно будет оверайдить до черных классов.
1565.36 1567.36 "Игорь Лабутин" Не об этом ли вы мечтали?
1567.36 1575.44 "Анатолий Кулаков" Я давно хотел себе, если честно, абстрактные статические методы, но как-то не мог себе представить, каким образом они будут работать и как будут реализованы.
1575.44 1581.68 "Игорь Лабутин" Короче, пример там на самом деле хороший и он позволит сделать довольно много клевых штук на дженериках.
1581.68 1586.76 "Игорь Лабутин" Смотри, делается это вот для чего и примерчик там весьма неплохой.
1586.76 1603.84 "Игорь Лабутин" То есть, это нужно, чтобы у тебя можно было объявлять интерфейсы, которые как бы поведенческие в каком-то смысле, то, что там иногда называют миксинами или в некотором смысле шейпом, можно сказать, в некоторых языках.
1603.84 1605.44 "Игорь Лабутин" Короче, у них пример примерно такой.
1605.44 1615.04 "Игорь Лабутин" Мы объявляем интерфейс Iadable от T, то есть, типа, что-то, что умеет складывать чего-то с чем-то или складываться друг с другом.
1615.04 1618.96 "Игорь Лабутин" И ты объявляешь два статических мембера абстрактных.
1618.96 1628.44 "Игорь Лабутин" Во-первых, static abstract от типа T с именем 0, это get property, это типа для типа T, что такое 0.
1628.44 1634.32 "Игорь Лабутин" А второй это типа static abstract T оператор плюс от двух T аргументов.
1634.32 1647.16 "Игорь Лабутин" То есть, это тебе позволит, по сути, дальше, чтобы сделать так, чтобы у тебя, допустим, какой-нибудь структурка int32, ну, встроенные типа, они, скорее всего, будут как-то не явно его реализовывать.
1647.16 1661.12 "Игорь Лабутин" Ну, допустим, что у тебя есть структурка int32, она сможет переопределить оператор плюс, который будет тупо возвращать x+y, ну, два аргумента, складывать именно математически, а property of 0 будет возвращать честный 0.
1661.12 1666.44 "Игорь Лабутин" И вот как раз-таки это позволит тебе дальше в дженериковом виде наконец-таки описывать всякую математику.
1666.44 1685.00 "Игорь Лабутин" То есть, ты сможешь написать generic метод какой-нибудь там, from all, да, или sum, нормально, который будет честно писать там, t result присвоить t.0, да, и потом там типа result плюс равно какой-нибудь элементик t из коллекции.
1685.00 1686.88 "Игорь Лабутин" То есть, то, что мы не могли делать раньше.
1686.88 1699.84 "Анатолий Кулаков" То есть, если мой класс реализует вот этот интерфейсик, который умеет, в принципе, складываться и возвращать 0 значение, то этот класс может участвовать во всех математических плюсиках, которые у меня будут там в системе, да?
1699.84 1720.00 "Игорь Лабутин" Ну, да, если он, то есть, если ты его используешь методом, у которого generic constraint указан, этот addable, то компилятор будет знать, что у этого типа t существует понятие плюс, то есть, если он видит плюс оператор, примененный к типу t, он знает, что вызвать надо, вот тот самый абстрактный статический оператор, который можно переопределить у себя в классе.
1720.00 1732.40 "Игорь Лабутин" Возникает естественный вопрос, что будет, если дальше иерархия наследования развивается еще дальше, и там, допустим, наследники переопределяют эти 0 и вот эти операторы дальше, или это будет запрещено.
1732.40 1735.32 "Игорь Лабутин" Ну, в общем, посмотрим, во что это превратится.
1735.32 1737.64 "Игорь Лабутин" Идея понятна, зачем она понятна.
1737.64 1745.52 "Анатолий Кулаков" Ну, и вообще-то, довольно-таки мощный базис, на основании которого можно потом будет выращивать довольно интересную функциональность.
1745.52 1755.08 "Игорь Лабутин" Да, и надо сказать, что вот эта фича одна из тех, которая очень свежая, она появилась в феврале этого года, и завел ее сам Мэтт Торгерсон.
1755.08 1758.72 "Игорь Лабутин" Что-то мне подсказывает, что… Что Мэтт Торгерсон
1758.72 1760.40 "Анатолий Кулаков" будет не против ее заапруить.
1760.40 1769.08 "Игорь Лабутин" Да, но там не так, что один Мэтт Торгерсон все апрует, поэтому там все-таки есть некоторый комитет, который это все делает, так что там единолично все-таки все не решишь.
1769.08 1771.36 "Игорь Лабутин" Но, тем не менее, работа какая-то идет.
1771.36 1772.36 "Игорь Лабутин" Пошли дальше.
1772.36 1774.36 "Игорь Лабутин" По паттернам есть изменения.
1774.36 1782.16 "Игорь Лабутин" Вот те самые pattern matching, которые у нас сейчас умеют там по типам мачать, по пропертям мачать, почему-то он еще только не умеет мачать.
1782.16 1784.32 "Игорь Лабутин" Здесь предлагается две вещи.
1784.32 1793.56 "Игорь Лабутин" Вещь первая, немножко расширить паттерны на коллекции, то есть можно будет написать "из" фигурно-скобочка открылась, "1,2,3" фигурно-скобочка закрылась.
1793.56 1804.00 "Игорь Лабутин" Это значит, что в левой части, и если такое будет true, то это значит, что в левой части находится что-то, это является коллекцией, и там есть 2, 3 элемента со значениями 1, 2 и 3.
1804.00 1810.52 "Анатолий Кулаков" Ну то есть это сразу мачет коллекции по их значениям, по содержимому и по количеству элементов и по значениям.
1810.52 1811.52 "Игорь Лабутин" Да.
1811.52 1817.84 "Игорь Лабутин" А если хочется только по количеству, то можно написать "из" и дальше в квадратных скобках ожидаемая длина.
1817.84 1820.60 "Игорь Лабутин" Тогда это значит, что слева коллекции нужной длины.
1820.60 1824.20 "Анатолий Кулаков" А если мне хочется по значениям, но не в этом порядке?
1824.20 1829.84 "Игорь Лабутин" Ну ты прям, не знаю, сконверти сначала в какой-нибудь там, не знаю, bag.
1829.84 1832.12 "Игорь Лабутин" Сначала отсортирую, а потом сравниваю.
1832.12 1838.16 "Игорь Лабутин" Да, отсортируй, не знаю, не знаю, допиши в proposal, что тебе не нравится, ты не согласен.
1838.16 1839.52 "Игорь Лабутин" Вот это одна штука.
1839.52 1854.88 "Игорь Лабутин" И вторая штука — это чуть-чуть расширить property patterns, то есть сейчас можно написать такую штуку, что допустим какое-то выражение "e" является там, не знаю, типом какой-нибудь ваш класс А, у которого там poly length = 5.
1854.88 1857.88 "Игорь Лабутин" То есть можно это прямо писать в едином выражении.
1857.88 1874.60 "Игорь Лабутин" Но если вам нужно описать что-то, что в вашем классе А внутри есть класс B, внутри есть класс C, у которого property length должно быть равно 5, вот как вложенную такую структуру описать, то сейчас вам нужно все это вкладывать в кучу фигурных скобочек внутрь, и паттерн становится довольно-таки, ну, большим.
1874.60 1878.76 "Игорь Лабутин" Предлагается просто возможность заченить эти property через точечку.
1878.76 1890.44 "Игорь Лабутин" То есть, как я сказал, есть класс А, в нем есть класс B, в нем есть класс C, property length, соответственно, назван так же, то вы будете писать там if e is class A, дальше фигурные скобочки, дальше b.c, точка там d is, не знаю, 5.
1890.44 1891.96 "Игорь Лабутин" Ну, 2 точки, а 5 точнее.
1891.96 1905.92 "Игорь Лабутин" То есть чисто такой синтексис немножко упростить, чтобы было все покороче, потому что кажется, что все эти pattern matching становятся какие-то длинными, особенно если вы начинаете туда еще добавлять всякие and, or и вот это вот штуки.
1905.92 1907.68 "Игорь Лабутин" Вот, pattern matching.
1907.68 1910.84 "Игорь Лабутин" Ну, это действительно такие совсем косметики, совсем мелкое.
1910.84 1914.32 "Игорь Лабутин" Что более важно и более интересно, это лямбда-импрувменты.
1914.32 1926.84 "Игорь Лабутин" Работа совсем-прям совсем-совсем in progress, прям вот буквально на этой неделе какие-то свежие коммиты прилетели в main, то есть она прям очень рядышком, и там есть 3 вещи, которые они хотят уйдут, импрувить на лямбдах.
1926.84 1935.00 "Игорь Лабутин" Во-первых, позволить лямбдам иметь атрибуты, то есть можно будет перед лямбдой написать в квадратных скобочках атрибутик, и он, собственно, будет работать.
1935.00 1945.52 "Игорь Лабутин" Второе, у лямбд можно будет указать явный return type, то есть сейчас у нас у лямбд return type всегда выводится из типа того выражения, которое встретилось в последнем лямбде, ну или ретурну, соответственно.
1945.52 1947.40 "Игорь Лабутин" Можно будет указать его явно.
1947.40 1973.32 "Игорь Лабутин" И третье, это то, что лямбды теперь смогут, скажем так, сами по себе, средством компилятора, автоматически приводиться к нужному типу делегатов, то есть если у вас есть какая-то лямбда, а метод ожидает, не знаю, от NTA, то сейчас иногда вам нужно было явно прописать, что привести лямбдочку к типу action от NTA, или там, не знаю, к func от пяти аргументов.
1973.32 1987.40 "Игорь Лабутин" Сейчас это всё будет происходить более-менее само, причём с учётом того, что если у вас написано в нужном месте async, то оно будет само ждать, что это action от task, или task от action, или что-нибудь в таком духе.
1987.40 1997.16 "Анатолий Кулаков" Ну, наконец-то, это, по-моему, самый большой позор уже много-много лет был, что нам приходится вручную кастить к экшенам лямбды, или там локальные методы, или вот эти прочие глупости.
1997.16 2017.44 "Игорь Лабутин" Да, они это всё делают ради того, чтобы, ну, не совсем ради того, но это одна из фич, которая драйвится ASP.NET Core, чтобы можно было делать более такие простые, однострочные типа а-ля action методы для всяких разных экшенов внутри ASP.NET Core приложений, если вы не хотите делать контроллеры.
2017.44 2030.72 "Игорь Лабутин" То есть там же есть возможность просто навесить там, ну, либо map action вызвать метод, либо ещё что-то в подобном духе, чтобы прям вот ваша лямбдочка вызвалась вместо контроллера по определенному пути, по определенному урлу.
2030.72 2042.52 "Игорь Лабутин" Ну вот, соответственно, чтобы там не приходилось писать огромное количество хода для приведения типов, а также чтобы можно было навесить атрибут типа там, что вот эта лямбдочка - это на самом деле HTTP-пост с нужным урлом.
2042.52 2044.76 "Игорь Лабутин" Вот как раз-таки эти фичи похожие и делаются.
2044.76 2054.04 "Игорь Лабутин" При этом фича будет не совсем прям идеально до конца сделана в каком-то смысле, потому что вам нельзя будет всё ещё использовать var для лямбд.
2054.04 2059.32 "Игорь Лабутин" То есть если вы пишете лямбдочку, всё равно нужно будет писать явный тип.
2059.32 2063.36 "Анатолий Кулаков" Ну я так понимаю, чисто физически для этого нет никаких проблем.
2063.36 2066.44 "Анатолий Кулаков" То есть это, скорее всего, просто не успели доделать, да?
2066.44 2069.48 "Игорь Лабутин" Ну, и да, и нет.
2069.48 2074.36 "Игорь Лабутин" Потому что я так понимаю, там есть тонкости на тему того, куда могут сконвертиться.
2074.36 2076.20 "Игорь Лабутин" Там не всегда однозначно.
2076.20 2083.32 "Игорь Лабутин" В основном, это в деле, когда у тебя есть готовая лямбда и известный target type, и между ними ты либо можешь построить соответствующее, либо не можешь.
2083.32 2089.12 "Игорь Лабутин" Но я так понял из обсуждения, что там есть какие-то кейсы, когда у тебя может быть больше, чем один target type.
2089.12 2091.68 "Игорь Лабутин" То есть там не везде будет очевидно, кто такой var.
2091.68 2095.60 "Анатолий Кулаков" Ну то есть как-то вывод типа не справляется.
2095.60 2097.28 "Игорь Лабутин" Ну вот пока да.
2097.28 2102.76 "Игорь Лабутин" Возможно, это действительно какие-то недоработки и всё можно сделать, но вот пока решили этим ограничиться.
2102.76 2109.80 "Игорь Лабутин" На самом деле, пожалуй, такие более-менее все большие штуки, прям совсем большие.
2109.80 2112.44 "Игорь Лабутин" Из мелких пошли быстренько пробежимся.
2112.44 2113.44 "Игорь Лабутин" Во-первых, Global Using Directive.
2113.44 2114.84 "Игорь Лабутин" Как ты думаешь, название...
2114.84 2116.60 "Игорь Лабутин" Вот что-нибудь тебе говорит название?
2116.60 2119.88 "Анатолий Кулаков" Так, у нас using сейчас используется в двух местах.
2119.88 2123.56 "Анатолий Кулаков" Во-первых, это вызов dispose, который стандартно с нами уже давно.
2123.56 2126.84 "Анатолий Кулаков" И во-вторых, это вот даже не в двух, в больших.
2126.84 2136.04 "Анатолий Кулаков" А во-вторых, это using какого-то класса, которому ты можешь задать alias произвольный и объявить его.
2136.04 2137.04 "Анатолий Кулаков" Вот.
2137.04 2148.04 "Анатолий Кулаков" Ещё также using можно использовать для того, чтобы заинлайнить, открыть скобу для статических всяких пропертей, чтобы писать не mav.py, а просто p.
2148.04 2155.28 "Игорь Лабутин" Ну да, и не только пропертей, это просто namespace, импортишь целиком и там чушь есть, классы, статические экстенджер-методы там есть и так далее.
2155.28 2158.00 "Игорь Лабутин" Так вот, предложение сделать следующее.
2158.00 2160.64 "Игорь Лабутин" Всем надоело писать using system.
2160.64 2168.88 "Игорь Лабутин" Вовсех файлах внутри проекта, поэтому можно будет взять один файлик, в нём написать global using system.
2168.88 2178.16 "Игорь Лабутин" И это обеспечит внутри этого проекта, то есть всех cs-ов, включенных в тот же самый cs-proj, что везде будет, как будто написано using system.
2178.16 2188.00 "Анатолий Кулаков" Что-то это какие-то глобальные статические перемены мне напоминает, знаешь, когда объявляешь в одном месте, оно выстреливает в 10 других, и ты не знаешь, откуда это всё выросло, почему оно вдруг заинлайнилось.
2188.00 2194.80 "Игорь Лабутин" Да, откуда у тебя в интеллисенсе 100-500 экстенджер-методов, хотя у тебя в юзингах ничего нет в этом файлике.
2194.80 2196.72 "Анатолий Кулаков" Да, дерзкая штука.
2196.72 2199.68 "Анатолий Кулаков" Мне напоминает функциональность из Blazor.
2199.68 2212.56 "Анатолий Кулаков" Вот там сейчас тоже такая есть вещь, там есть отдельный файлик, в этом файлике ты объявляешь все юзинги, которые нужны всем твоим Blazor, и он их подтягивает во всех местах, и в редакторах, и в UI-ке, и везде.
2212.56 2219.20 "Игорь Лабутин" Так может это оттуда и пришло, типа народ потом на C# в обычной жизни стал писать и сказал, что "ой, нам этого не хватает".
2219.20 2227.24 "Анатолий Кулаков" Да, удобно, удобно, конечно, когда у тебя, ну по сути у тебя блок юзинг становится или пустым, или там буквально парочку специфичных namespaces остаются.
2227.24 2228.24 "Анатолий Кулаков" Да.
2228.24 2229.24 "Игорь Лабутин" К namespaces.
2229.24 2232.44 "Игорь Лабутин" Следующая фича называется filescoped namespaces.
2232.44 2233.84 "Игорь Лабутин" Ну тут вроде более-менее понятно.
2233.84 2246.40 "Игорь Лабутин" У нас сейчас namespace, ну как объявляется, вы пишете там namespace, имя какое-то, фигурная скобочка открылась, и дальше весь ваш код, он долго-долго идёт внутри файла, да, дальше фигурная скобочка namespace закрылась, всё.
2246.40 2262.44 "Игорь Лабутин" То есть в принципе, учитывая, что, ну скажем так, наверное, в подавляющем большинстве случаев всё-таки в одном файле у нас один класс, есть исключения, конечно, и это там не догма писать всегда один файл на один класс, но в целом, ну как бы паттерн везде одинаковый.
2262.44 2265.72 "Игорь Лабутин" Объявили namespace, в нём один класс, ну внутри файлика, и всё.
2265.72 2272.48 "Игорь Лабутин" Поэтому есть предложение вместо этого писать просто в начале файлика namespace там, такой-то там mycompany, точка с запятой.
2272.48 2277.04 "Игорь Лабутин" Это значит, что до конца файла всё, что объявлено в этом файле, будет лежать в этом namespace.
2277.04 2285.56 "Игорь Лабутин" То есть тупо как бы скипнуть фигурные скобочки открывающие и закрывающие, и перестать выравнивать код на один отступ вправо.
2285.56 2289.32 "Анатолий Кулаков" Слушай, а вот это мне нравится, в принципе, да, странно, почему давно так не сделали.
2289.32 2301.00 "Анатолий Кулаков" Потому что действительно, обычно namespace на файлике один, и зря тратить целый indent, тратить целый отступ на вот эту глупость, это уже какой-то мовитон, это уже пережиток старости.
2301.00 2302.00 "Анатолий Кулаков" Хорошая штука.
2302.00 2303.00 "Анатолий Кулаков" Да.
2303.00 2304.00 "Анатолий Кулаков" Вот.
2304.00 2311.36 "Анатолий Кулаков" А ещё, может они всё-таки додумаются, что очень часто и класс на файлик всё время один, может там тоже вот эти скобочки, они уже давно лишние?
2311.36 2314.44 "Игорь Лабутин" Ну, я боюсь, что это может зайти слишком далеко.
2314.44 2321.16 "Игорь Лабутин" Хотя, это будет в следующей версии, погоди, давай вот эту завезём в 10, а потом в 11 классы будем так оптимизировать.
2321.16 2340.40 "Игорь Лабутин" Так, следующую фичу мы на самом деле обсуждали, по-моему, в прошлый раз, про improved interpolated strings, то что вместо string формата там теперь будут работать билдеры, и на самом деле рекомендую почитать тишью, там прикольную штуку показали в одном из примеров, где это может быть полезно.
2340.40 2369.96 "Игорь Лабутин" Вот стандартный паттерн, многие же знают, что мы там можем написать какому-нибудь логеру, там log.info, не знаю, там $, кавычкой, туда какие-нибудь строчки, аргументы попередавать внутри этого interpolated string, и проблема была в том, что сейчас такой вызов однозначно строчку сначала изгенерит, потому что он её проинтерполирует, подставит все значения, там забоксит, не забоксит, соберёт всю строку, зайдёт в log.info и выяснит, что лог.level у нас сейчас warning, и что вообще говоря вся строчка собиралась зря.
2369.96 2412.60 "Игорь Лабутин" Вот, с новым вот этим подходом билдеров можно будет на самом деле сделать, там написано прямо даже как это можно будет сделать, кастомные билдеры, то есть какая-нибудь библиотека может написать свой собственный кастомный билдер для конкретного места, и тогда у этого билдера, он может знать, поскольку он контролируется самой библиотекой, какой сейчас лог.level, и понять, что окей, билдер-то мы создали, мы туда передали собственно саму строчку, и допустим перемен, или даже переменные мы не передавали, они просто дальше компилятором развернулись в вызовы builder.append, но их не нужно вызывать, потому что билдер знает, что там лог.level сейчас не нужный нам, и он тупо проскипает тогда, там в эфир обернёт.
2412.60 2420.00 "Игорь Лабутин" Короче, там прям какая-то бездна оптимизации открывается, если использовать эти билдеры, и похоже, что это только начало, посмотрим, куда выльется.
2420.00 2422.60 "Анатолий Кулаков" Да, это хорошая штука для логеров, очень актуальная
2422.60 2431.84 "Игорь Лабутин" вещь. Так, следующее, вот в структурке, allow no-arg constructor, то есть конструктор без аргументов, и field initializer в структурах.
2431.84 2440.20 "Анатолий Кулаков" Наконец-то запретят этот страшный конструктор без аргументов, и мы сможем делать нормальные гарантированные value-обжекты с инвариантами.
2440.20 2447.48 "Игорь Лабутин" Ну типа того, запретят, это громко сказано, это скорее разрешат его не писать, и сделать нормальный field initializer.
2447.48 2456.04 "Игорь Лабутин" Эта фича, я сейчас не смогу про неё сильно много рассказывать, там нужно очень внимательно вчитываться, там огромное количество обсуждений всяких edge-кейсов, того, что может пойти не так.
2456.04 2461.72 "Анатолий Кулаков" Мне кажется, с темой структуры это всегда так, маленькая фича и огромное обсуждение edge-кейсов.
2461.72 2469.64 "Игорь Лабутин" Да, поэтому вот про неё у меня есть какое-то чёткое ощущение, что она не попадёт в 10-ый шарп, но посмотрим.
2469.64 2474.96 "Игорь Лабутин" Дальше следующая мелкая фича, support for method parameters names в операторе nameof.
2474.96 2482.12 "Игорь Лабутин" То есть сейчас вы можете внутри тела метода использовать nameof и аккуратненько там, например, писать имена параметров.
2482.12 2485.44 "Игорь Лабутин" Ну все это используют, кидая какие-нибудь argument null exception.
2485.44 2489.00 "Игорь Лабутин" Я, прочитав название этой фичи, подумал, что так, а всё же поддержано.
2489.00 2490.36 "Игорь Лабутин" Оказалось, нет, не всё.
2490.36 2498.96 "Игорь Лабутин" Если вы на метод навешиваете атрибут какой-нибудь, то в этом атрибуте нельзя использовать nameof от параметров этого метода.
2498.96 2500.96 "Игорь Лабутин" Да, это действительно беспредел.
2500.96 2507.60 "Игорь Лабутин" И это не было бы большой проблемой, и это долгое время не было никакой проблемой до тех пор, пока у нас не появились что?
2507.60 2515.52 "Игорь Лабутин" Правильно, non-nullable атрибуты, где как раз-таки есть всякие атрибуты типа null if not null, где нужны ссылки на параметры.
2515.52 2517.32 "Игорь Лабутин" И блин, там nameof не работает.
2517.32 2520.48 "Игорь Лабутин" Да-да, полезная штука будет вообще, вообще класс.
2520.48 2528.64 "Игорь Лабутин" Вот, соответственно, там было тоже какое-то количество обсуждений, где разрешать какой scope, но вроде всё там разрешилось, так что вот эта фича имеет хороший шанс попасть.
2528.64 2531.52 "Анатолий Кулаков" У меня ещё, знаешь, к nameof какие претензии есть.
2531.52 2539.56 "Анатолий Кулаков" Я наталкиваюсь на то, что я хочу сделать nameof от каких-то приватных имён полей или от приватных пропертей метода в другом классе.
2539.56 2549.32 "Анатолий Кулаков" Ну, то есть, понятное дело, что вызывать я их не буду, но для каких-то свойств мониторинга, логирования, диагностики мне нужно получить строку от них.
2549.32 2556.08 "Анатолий Кулаков" И вот я не могу сделать nameof, несмотря на то, что у меня такой класс есть, такое поле у него есть, но это поле приватное.
2556.08 2562.72 "Анатолий Кулаков" Компилятору, в принципе, на момент компиляции наплевать приватное или нет, мне нужна строковая константа, но почему-то этого сделать нельзя.
2562.72 2569.20 "Игорь Лабутин" Я, на самом деле, видел где-то в обсуждениях какую-то похожую проблему и, возможно, где-то есть отдельные ищи на эту тему.
2569.20 2572.64 "Игорь Лабутин" Вот такие слова мне точно встречались, когда я это всё изучал.
2572.64 2574.40 "Игорь Лабутин" Так что, может и сделают.
2574.40 2579.16 "Игорь Лабутин" Дальше маленький кусочек тоже про nullable, это называется громким словом improve definite assignment analysis.
2579.16 2590.76 "Игорь Лабутин" То есть, на самом деле это просто научить компилятор ещё определять лучше в каких же случаях, в каких ифах какие переменные присваиваются, какие не присваиваются, чтобы ещё лучше понимать, где null, а где не null.
2590.76 2595.04 "Анатолий Кулаков" Вообще с nullable там ещё, блин, огромное непаханное поле, они зарелизили их довольно такими сырыми.
2595.04 2600.68 "Анатолий Кулаков" И вот каких-то громких анонсов, громких импрументов вот как-то нету, нету, хотелось бы, хотелось бы.
2600.68 2601.92 "Анатолий Кулаков" Ну да, пока нету.
2601.92 2609.40 "Игорь Лабутин" Ну вот они потихонечку, видимо, пилят именно компиляторную часть, чтобы лучше понимать, где у нас проваливается таки в null, а где не проваливается.
2609.40 2612.88 "Игорь Лабутин" Чтобы более точно выдавать предупреждение.
2612.88 2616.36 "Игорь Лабутин" Смешная фича, я не очень понял, мотивация, но тем не менее.
2616.36 2618.88 "Игорь Лабутин" Она есть, над ней серьёзно работают и обсуждают.
2618.88 2627.32 "Игорь Лабутин" У нас сейчас в C# оказывается, я как-то не знал, есть строгий порядок модификаторов ref и partial.
2627.32 2632.04 "Игорь Лабутин" Вот просят его, так сказать, ослабить и разрешить писать их в любом порядке.
2632.04 2633.52 "Игорь Лабутин" Да, это critical.
2633.52 2638.76 "Игорь Лабутин" Я вот не очень понимаю, чем народу мешает, учитывая, что это пишется, в общем-то, на классе.
2638.76 2642.32 "Игорь Лабутин" Ну хорошо, на методах это тоже можно писать, да, у нас же partial методы ещё бывают.
2642.32 2644.88 "Игорь Лабутин" Но блин, ну как бы да.
2644.88 2645.88 "Игорь Лабутин" В общем вот.
2645.88 2648.36 "Игорь Лабутин" Но фича есть, она in progress.
2648.36 2650.80 "Игорь Лабутин" А вот следующее интересно.
2650.80 2659.00 "Игорь Лабутин" Как много мы пишем кода вида, там, if параметр метода is null, throw new argument null exception.
2659.00 2663.40 "Анатолий Кулаков" Ну каждый метод, который публичный, обязан проверять свои входные аргументы.
2663.40 2664.40 "Игорь Лабутин" Вот.
2664.40 2668.04 "Игорь Лабутин" Вот вместо этого автор этой идеи предлагает писать следующее.
2668.04 2672.40 "Игорь Лабутин" Допустим, у вас есть метод insert, у него есть параметр s, типа string.
2672.40 2685.24 "Игорь Лабутин" Раньше вы бы писали void, допустим, insert от string s, там скобочка закрылась, дальше внутри if s is null или равно-равно null или string is null or empty, throw new argument null exception от name of s.
2685.24 2689.48 "Игорь Лабутин" Предлагается вот эту вот всю шелуху заменить на такую штуку.
2689.48 2694.96 "Игорь Лабутин" Функцию вы будете писать как void insert, круглая скобка открылась, string s восклицательный знак, круглая скобка закрылась.
2694.96 2695.96 "Анатолий Кулаков" Всё.
2695.96 2701.32 "Анатолий Кулаков" И, соответственно, компилятор это развернёт в такую же точную проверку и бросание null reference exception, да?
2701.32 2720.04 "Игорь Лабутин" Да, он просто в момент компиляции вставит туда, то есть если у вас есть параметры функции, у которых восклицательный знак стоит после имени параметра, не после типа параметра, а после имени параметра, то это означает, что этот параметр стопудово должен быть не null и туда нужно вставить стандартную проверку на null и кинуть аргумент null exception.
2720.04 2725.76 "Анатолий Кулаков" Вот здесь надо не запутаться, потому что если вы поставите после типа, это уже будет обозначать ненулябельный тип.
2725.76 2729.08 "Анатолий Кулаков" Если поставите после имени, это значит, это сгенерим ко мне проверку наив.
2729.08 2730.64 "Анатолий Кулаков" Че это как-то слишком много магии.
2730.64 2737.60 "Анатолий Кулаков" Я надеялся, что с появлением nullable reference types вот эта проблема станет не настолько актуальной, чтобы градить такие хаки.
2737.60 2741.28 "Игорь Лабутин" Ну, вот эту фичу я видел довольно давно, именно предложение.
2741.28 2742.28 "Игорь Лабутин" Я не знаю, в каком она сейчас состоянии.
2742.28 2747.64 "Игорь Лабутин" Я брал только те фичи, которые не так давно менялись на самом деле.
2747.64 2753.88 "Игорь Лабутин" То есть, значит, какая-то работа там ведётся, но работа, это может означать, что там просто кто-то что-то комментирует и всё, не более того.
2753.88 2756.08 "Игорь Лабутин" Поэтому не знаю пока, как это будет.
2756.08 2757.08 "Игорь Лабутин" Ну, глянем, посмотрим.
2757.08 2760.64 "Игорь Лабутин" Штука тоже забавная.
2760.64 2766.04 "Игорь Лабутин" Знаешь ли ты что-то про атрибют color argument expression?
2766.04 2776.00 "Анатолий Кулаков" Ну, это скорее, color argument это у нас есть такой стандартный атрибут, который позволяет нам вставить имя того метода, который сейчас нас вызвал.
2776.00 2778.88 "Анатолий Кулаков" Это очень полезная штука во многих случаях.
2778.88 2787.16 "Анатолий Кулаков" По suffix expression намекает, наверное, на то, что мы хотим получить expression от этого имени.
2787.16 2788.16 "Анатолий Кулаков" Что?
2788.16 2789.16 "Игорь Лабутин" Зачем это?
2789.16 2790.52 "Игорь Лабутин" Нет, на самом деле всё немножко проще.
2790.52 2793.40 "Игорь Лабутин" Представь себе какой-нибудь, не знаю, assert метод, да?
2793.40 2795.88 "Игорь Лабутин" Ну, там какой-нибудь assert из true.
2795.88 2796.88 "Игорь Лабутин" Так, представил.
2796.88 2803.92 "Игорь Лабутин" И ты туда передаёшь, например, какой-нибудь там не просто переменную, да, проверить, что она true или нетrue, а какое-нибудь там хитро вывернутое выражение.
2803.92 2810.48 "Игорь Лабутин" Переменная плюс другая переменная поделить на другую переменную, там тернатный оператор какой-нибудь ещё вставишь.
2810.48 2813.48 "Игорь Лабутин" Ну, короче, какое-нибудь такое навороченное выражение и проверяешь, что это всё выражение true или false.
2813.48 2818.56 "Игорь Лабутин" То есть у тебя assert метод при этом, ты его объявляешь с двумя аргументами.
2818.56 2822.44 "Игорь Лабутин" То есть передаёшь ты один аргумент, а объявляешь с двумя.
2822.44 2826.60 "Игорь Лабутин" Первый аргумент, собственно, bool, ну, который ты будешь ассёртить true или false, да.
2826.60 2831.24 "Игорь Лабутин" А второй аргумент - это string вот с этим атрибутиком перед аргументом.
2831.24 2838.80 "Игорь Лабутин" И компилятор автоматически во второй аргумент передаст просто вот то, что у тебя в коде прямо написано, вот литерально, типа как строка.
2838.80 2850.92 "Анатолий Кулаков" Это, например, если мы пишем тестовый framework, который вот эти ассершины пачками поглощают, чтобы он выдал нам красивый месседж о том, какой кондишен у нас не соответствует реальности.
2850.92 2851.92 "Игорь Лабутин" Да-да-да-да.
2851.92 2858.00 "Игорь Лабутин" Что конкретно вот у тебя, если ты красиво написал в аргументе длинное выражение, у тебя это выражение будет доступно в виде строки внутри функции?
2858.00 2863.36 "Анатолий Кулаков" Ну, миленько-миленько, но мне кажется, что это вот реально один use case из всех, которые можно представить.
2863.36 2881.36 "Игорь Лабутин" Так вот, фишка заключается в том, что если мы загуглим эту штуку, то мы выясним, вот я сейчас смотрю, что этот атрибут, он есть, на него есть документация, он в дотнете начинается с 5.0 и в дотнет коре начинается с 3.0, казалось бы, причем здесь новая фича, и почему мы его обсуждаем в контексте C# 10.
2881.36 2884.16 "Анатолий Кулаков" Его потеряли, оставили в документации, а код забыли?
2884.16 2886.96 "Игорь Лабутин" Ну да, его добавили в документацию, но он ничего не делает.
2886.96 2894.16 "Игорь Лабутин" То есть, его можно использовать, ты его можешь использовать в коде, но реальной передачи вот этого, как бы, строки не произойдет.
2894.16 2895.88 "Игорь Лабутин" Эту фичу пока не сделали.
2895.88 2897.72 "Игорь Лабутин" А зачем ее в документацию добавили?
2897.72 2908.68 "Игорь Лабутин" Я не знаю, зачем так сделано, но типа вот сейчас они обсуждают, что нужно это дело добавлять, собственно, в следующей версии языка, наверное, все-таки реализацию может напишем или пока подождем.
2908.68 2911.12 "Игорь Лабутин" Короче, в общем, такая вот забавная фича.
2911.12 2918.20 "Анатолий Кулаков" Слушай, но мне гораздо более приятно было бы, если бы мне передавалось не стринг аргументом, а именно экспрессион.
2918.20 2920.48 "Анатолий Кулаков" Мне кажется, это открывает более богатый простор.
2920.48 2924.72 "Игорь Лабутин" Это открывает более богатый простор, но экспрессион все-таки и сложнее изгенерить, и сложнее парсить.
2924.72 2934.52 "Игорь Лабутин" Ну и это, как бы, уже совсем не явный накладной расход, то есть строчка-то у тебя будет константная строка, ты уже генерил компилятор, положил в ресурс, и у тебя нет точно никакого локейта памяти, ничего такого.
2934.52 2938.92 "Игорь Лабутин" А экспрессион все-таки придется в рантайме генерить объекты, создавать вот это все.
2938.92 2945.36 "Игорь Лабутин" Это уже не нулевой оверхед, и я боюсь, что, ну, не боюсь, я думаю, что рантайм-команда на это не пойдет.
2945.36 2947.00 "Игорь Лабутин" Ну да, да, ты прав, наверное.
2947.00 2953.32 "Анатолий Кулаков" Но с учетом того, что это будет применяться наверняка только в тестовых фреймворках, данная проблема не должна стать очень остро.
2953.32 2954.32 "Игорь Лабутин" Да, да.
2954.32 2957.44 "Игорь Лабутин" И последняя фича из списка - это generic attributes.
2957.44 2961.84 "Игорь Лабутин" То есть сейчас мы в атрибутах не можем использовать generic типы, будет можно.
2961.84 2966.00 "Анатолий Кулаков" Давно пора, действительно одна из тех штук, которая должна была появиться еще с самого начала.
2966.00 2968.40 "Игорь Лабутин" Ну вот, в общем, примерно такие дела.
2968.40 2972.28 "Игорь Лабутин" Фичи потихонечку пилятся, фичи обсуждаются.
2972.28 2983.40 "Игорь Лабутин" Если вам интересно посмотреть, как это происходит регулярно в твиттере, соответственно, можно поискать анонсы ревью, все ревью вот этих вот фич, они паблик, ну, языковых особенностей.
2983.40 2993.92 "Игорь Лабутин" Ну и вот все то, что мы перечисляли, почти на всех из них есть эти линки на уже какие-то обсужденные штуки с митинг минусами.
2993.92 2995.72 "Игорь Лабутин" И можно посмотреть вообще, как это происходит.
2995.72 3001.12 "Игорь Лабутин" Что обсуждают, на что смотрят, как вообще все это двигается вперед.
3001.12 3006.56 "Анатолий Кулаков" Ну вообще, гитхаб - это не самый полезный ресурс для того, чтобы вот так вот пойти и просто-напросто посмотреть.
3006.56 3010.24 "Анатолий Кулаков" Есть же специализированные, более пригодные, более наглядные ресурсы.
3010.24 3015.84 "Игорь Лабутин" Есть, но давай прежде, чем мы пойдем к этим ресурсам, мы все-таки посмотрим на еще некоторые импровменты.
3015.84 3017.48 "Игорь Лабутин" Там что-то про симки завезли.
3017.48 3018.48 "Игорь Лабутин" Точно?
3018.48 3019.92 "Игорь Лабутин" Точно, я темку пропустил.
3019.92 3021.52 "Анатолий Кулаков" Давай, про симки сначала.
3021.52 3031.88 "Анатолий Кулаков" Да, наткнулся на статейку, где вот в тему, может быть, тем C# фичам, которые мы обсуждали, есть еще немножко импровментов в .NET 6.
3031.88 3037.88 "Анатолий Кулаков" Вообще, сам .NET 6 нам принес около сотни всяких изменений в API.
3037.88 3045.00 "Анатолий Кулаков" Некоторые из них связаны вот как раз таки со синхронностью для того, чтобы код, ваш асинхронный код стал более удобным.
3045.00 3046.72 "Анатолий Кулаков" Вот я парочку интересных выписал.
3046.72 3059.28 "Анатолий Кулаков" Смотри, вот каким образом ты раньше делал следующую задачу, если у тебя вдруг есть пачка каких-то тасков, и тебе нужно их подождать, но не более какого-то таймаута, например, не больше 3 секунд.
3059.28 3061.80 "Анатолий Кулаков" Вот какой бы ты написал код?
3061.80 3075.28 "Игорь Лабутин" Я бы через when any подождал бы, ну вот там, мою таску, которую я хочу, и этот самый таск delay какой-нибудь, ну таск, которая заделает на нужное мне время.
3075.28 3079.04 "Анатолий Кулаков" Да, действительно, вот обычно все так и делались, то есть подождать первое, что произойдет.
3079.04 3083.36 "Анатолий Кулаков" Или все таски завершатся, которые нужны, или произойдет таймаут в течение 3 секунд.
3083.36 3088.00 "Анатолий Кулаков" Выглядит это не очень привлекательно, ну то есть обычно даже очень ужасно.
3088.00 3094.88 "Анатолий Кулаков" И теперь у нас завезли в новый .NET 6, у нас завезли методы к самому таску.
3094.88 3097.28 "Анатолий Кулаков" На таске появились методы wait, wait-async.
3097.28 3112.32 "Анатолий Кулаков" То есть теперь вы можете сделать task when all, передать ему все таски, которые вы хотите ждать завершения, и при этом вызвать .wait-async, и передать ему некий таймаут, таймспан, который вы хотите ожидаться.
3112.32 3120.24 "Анатолий Кулаков" Вот это довольно удобно и читается более натурально, чем вот эта всякая городня с any, с when all, с delay, с прочими глупостями.
3120.24 3121.24 "Игорь Лабутин" Вот, еще.
3121.24 3129.28 "Игорь Лабутин" Хорошо, подожди, а если вот в таск delay было хорошо, что я тогда мог передать токен, cancellation токен, и заканцелить раньше, если мне нужно.
3129.28 3130.28 "Игорь Лабутин" А здесь как?
3130.28 3139.72 "Анатолий Кулаков" Да, здесь в принципе все точно так же, поддержали сигнатуру с просто таймспаном, с cancellation токеном, вместе с таймпаном и с cancellation токеном, то есть все возможные варианты допустимы.
3139.72 3143.20 "Анатолий Кулаков" И эти методы есть не только на таске, но естественно на таске от резолта.
3143.20 3157.16 "Анатолий Кулаков" Еще одна интересная штука, когда я разбирал эту новую фичу, там Microsoft сейчас во всю придерживается позиции, что любой промежуток времени, любой duration должен обязательно передаваться таймспаном.
3157.16 3169.08 "Анатолий Кулаков" Если ты помнишь, что во всяких task wait, task delay и прочих вот этих ожиданиях всегда можно было передать время в миллисекундах, которое по сути являлось int.
3169.08 3174.12 "Анатолий Кулаков" И вот этот int, не очень было понятно из сигнатуры, что именно он обозначает.
3174.12 3176.36 "Анатолий Кулаков" То есть value obsession происходил.
3176.36 3180.16 "Анатолий Кулаков" Теперь же Microsoft говорит, передавайте таймспаны и не выпендривайтесь.
3180.16 3182.48 "Анатолий Кулаков" Все будет читабельно, красиво и понятно.
3182.48 3183.48 "Анатолий Кулаков" Логично.
3183.48 3187.60 "Анатолий Кулаков" Еще одна интересная штука, это reusable cancellation token source.
3187.60 3189.60 "Анатолий Кулаков" Где бы это могло вам пригодиться?
3189.60 3200.88 "Анатолий Кулаков" Например, у нас есть web-реквесты, которыми наш любимый кестрил обменивается с дикой скоростью, занимает первые места и жмет все возможные бенчмарки.
3200.88 3207.24 "Анатолий Кулаков" И этот кестрил на каждый реквест по сути создает cancellation token source.
3207.24 3212.84 "Анатолий Кулаков" Для того, чтобы уметь отменять этот запрос, если что-то произошло с коннекцией.
3212.84 3218.48 "Анатолий Кулаков" Может быть, коннекция дропнулась, закрылась с другой стороны или оборвалась сеть или еще что-то.
3218.48 3220.52 "Анатолий Кулаков" Ваш реквест должен быть заканцелен.
3220.52 3226.20 "Анатолий Кулаков" Именно для этого он порождает дикое количество cancellation token source.
3226.20 3232.44 "Анатолий Кулаков" Но на практике, если мы возьмем Success Path, то по сути реквесты обычно не канцелятся.
3232.44 3238.60 "Анатолий Кулаков" Это очень редкая операция и на продакшене практически не встречается, если у вас все хорошо.
3238.60 3242.96 "Анатолий Кулаков" То есть он порождает все эти сорцы абсолютно зря.
3242.96 3243.96 "Анатолий Кулаков" Бесполезно.
3243.96 3247.44 "Анатолий Кулаков" Он не участвует никак в Success Path и не участвует никак в работе.
3247.44 3253.40 "Анатолий Кулаков" Вот эту проблему и попытались решить ребята из как раз таки .NET 6.
3253.40 3257.04 "Анатолий Кулаков" Они придумали такую штуку как reusable cancellation token source.
3257.04 3261.76 "Анатолий Кулаков" Это не какой-то новый класс, а новый метод на существующем токен сорсе.
3261.76 3263.28 "Анатолий Кулаков" Метод называется try_reset.
3263.28 3268.08 "Анатолий Кулаков" Метод не зря называется try_reset, потому что он вполне может не удастся.
3268.08 3271.80 "Анатолий Кулаков" Вернет он вам труд только в единственном случае.
3271.80 3276.96 "Анатолий Кулаков" Если у вас не произошло cancellation токена.
3276.96 3279.00 "Анатолий Кулаков" То есть если он не зафарился.
3279.00 3281.36 "Анатолий Кулаков" Если у вас никакой канцеляции не произошло.
3281.36 3287.96 "Анатолий Кулаков" Если же канцеляция произошла, то вы не можете переузывать существующий токен сорс.
3287.96 3295.48 "Анатолий Кулаков" Если же вам удалось его переузать, то это не ведет никаким проблемам для существующих cancellation токенов.
3295.48 3305.32 "Анатолий Кулаков" Потому что как только вы вызовете try_reset на cancellation токен сорсе, он отвяжется от всех своих старых cancellation токенов и создаст себе новенькие.
3305.32 3313.00 "Анатолий Кулаков" Соответственно весь тот пользовательский код, который подписался на cancellation события по старому cancellation токену продолжит работать.
3313.00 3317.40 "Анатолий Кулаков" Cancellation токен будет нормальный, хороший, рабочий, не дисползнутый.
3317.40 3320.00 "Анатолий Кулаков" Но при этом он никогда не зафарится.
3320.00 3324.16 "Анатолий Кулаков" Потому что единственный сорс, который мог это сделать, от него уже отвязался.
3324.16 3326.04 "Анатолий Кулаков" Вот в принципе и вся оптимизация.
3326.04 3336.68 "Игорь Лабутин" Но я так понимаю, что в нормальной жизни, как ты говоришь, когда у нас ничего не канцелится, в обычной хэппи сценарии, таких объектов, которые ссылаются на старые cancellation токены, по идее быть уже и не должно.
3336.68 3344.96 "Игорь Лабутин" Потому что у тебя предыдущий реквест закончился, все токены, ну не то чтобы померли, но cancellation токен - это же структура, если я правильно помню.
3344.96 3349.56 "Игорь Лабутин" И она есть, ну и есть, и есть, и ладно.
3349.56 3351.48 "Игорь Лабутин" Реквест закончен, все равно канцелировать нечего.
3351.48 3352.48 "Анатолий Кулаков" Да, именно так.
3352.48 3363.44 "Анатолий Кулаков" Если мы говорим именно про реквесты, то там в конце реквеста весь реквест-скоп диспозится, и если вы почему-то специально куда-то не сохранили этот токен сорс зачем-то, то в принципе никаких проблем не будет.
3363.44 3364.44 "Игорь Лабутин" Ну, хорошо.
3364.44 3371.24 "Игорь Лабутин" В общем, мне кажется, что команда все больше и больше оптимизирует, реюзает, пулит, вот это все.
3371.24 3379.48 "Игорь Лабутин" Немножко вернуться, наверное, к тому, что происходит с C# 50, в том числе и про эти async-импрувменты в DotNet 6.
3379.48 3381.72 "Игорь Лабутин" Вам может быть интересно следить за всем этим.
3381.72 3395.32 "Игорь Лабутин" И надо сказать, что когда я попытался найти какой-нибудь такой единый список, что же у нас происходит вообще в DotNet с точки зрения C# 10, например, нет, я, конечно, нашел, но это стоило некоторых усилий.
3395.32 3405.44 "Игорь Лабутин" Поэтому хочется на самом деле напомнить вам о существовании трех уже теперь сайтов, которые весьма полезны, если вы пытаетесь разобраться, что происходит в DotNet.
3405.44 3421.88 "Игорь Лабутин" Первый сайт, он довольно древний, называется APIs of .net, APIs of .net, и это такой хороший браузер API, где для каждой API, для каждого класса, для каждого мембера и всего такого написано, в каких фреймворках он поддержан, на каких версиях и линк на его документацию.
3421.88 3433.88 "Игорь Лабутин" То есть если вам нужно быстро проверить, где что находится, в каком поддержано, в каком Nuget оно живет, это не там используется, так сказать, индексируется довольно много Nuget в Microsoft, то это все вам туда.
3433.88 3450.24 "Игорь Лабутин" Дальше мы несколько подкастов назад разбирали сайт Themes of .net, это то, где можно посмотреть, как происходит работа над, так скажем, high-level фичами .net 6, ну и 5 немножко там тоже есть, естественно, из старенького, но в основном это конечно для .net 6.
3450.24 3468.80 "Игорь Лабутин" Это overview issues of GitHub, но сгруппированный соответственно с лейблами и собранный в дерево, то есть эпики там под ними, какие-то фичи, high-level штуки, какие-то user stories, tasks, в общем, если вам интересно смотреть какие-то детальные работы над фичами, в каком они состоянии, вам на Themes of .net.
3468.80 3509.60 "Игорь Лабутин" И есть еще штука под названием Designs of .net, это обзор, так скажем, всех дизайнов, которые так или иначе рассматриваются для платформы .net, то есть в частности там есть всякие такие штуки, какие у нас новые будут target framework monikers, вот я сейчас смотрю на этот сайт, какие у нас улучшения ждут в utf-8 support, что мы думаем про secure string, о statics and interfaces, которые мы обсуждали, и там даже открыт pull request, видно добавление некоторого предварительного драфта, так что в общем тут можно посмотреть вообще в каком состоянии, что ведется.
3509.60 3526.52 "Игорь Лабутин" И кстати, я хотел попутно обсудить, значит тут есть такая фича, у которой стоит зеленая галочка, то есть я так понимаю она вмержена, или по крайней мере дизайн запроблен, я не знаю, что означает, фича называется preview features, в общем смысл в чем?
3526.52 3549.12 "Игорь Лабутин" Если вы знаете, мы много раз на самом деле обсуждали, что какие-то те или иные фичи .net, они доступны только в превью версии фреймворка, то есть вам нужно взять, пойти, скачать .net 6.0 превью, что-то там, ну так очень раннее, и может быть внутри, а то и собрать самому свой собственный фреймворк, и тогда у вас будет какая-нибудь очень сильно ранняя превью фича.
3549.12 3572.96 "Игорь Лабутин" Они хотят сделать по-другому, они хотят, чтобы обычные сборки тоже включали в себя потенциальные превью фичами, но вы внутри CSS Project специальным флажком могли их включать у себя в конкретном проекте, потому что так команда считает, что будет больше распространения превью фич, больше народу смогут их попробовать, потому что сейчас это все-таки надо пойти в какой-то отдельный превью канал, поставить совсем раннюю версию, чтобы что-то потрогать.
3572.96 3574.80 "Игорь Лабутин" А так будет попроще.
3574.80 3585.48 "Игорь Лабутин" Так что уже может быть скоро вы сможете какие-то превью фичи пользовать там прям в вашей стабильной студии со стабильным SDK, но вот завезенные туда какими-нибудь добавочными нугетами, либо еще чем-то.
3585.48 3586.48 "Игорь Лабутин" Ждем.
3586.48 3603.92 "Игорь Лабутин" Вот, короче, дизайн софт .net, API софт .net и theme софт .net - 3 сайты, которые позволят вам и нам ориентироваться вообще в том, что происходит в мире .net с точки зрения каких-то таких работ, потому что просто ищусь на GitHub, это какая-то огромная куча всего, и так разобраться сложно, даже отфильтровав по лейблу.
3603.92 3609.80 "Анатолий Кулаков" Интересно, что Microsoft понимает вот эту проблему GitHub, когда у тебя нет нормального иерархического ищу-трекера.
3609.80 3617.16 "Анатолий Кулаков" И GitHub принадлежит Microsoft, может они наконец-то нам выкатят какой-нибудь хороший инструмент для управления ищесами.
3617.16 3620.48 "Игорь Лабутин" Может быть, как со студией лет через 10, увидим.
3620.48 3621.48 "Игорь Лабутин" 6-4 битный.
3621.48 3627.24 "Анатолий Кулаков" А что еще вышло лет через 10, так это новая версия Iron Python.
3627.24 3632.56 "Анатолий Кулаков" Вот скажи, ты слышал когда-нибудь про Iron Python и лелеял надеждой, что он еще жив?
3632.56 3641.32 "Игорь Лабутин" Я слышал про Iron Python на одном из наших SPB.net meetup, но текущее его состояние я не понимал никак.
3641.32 3646.04 "Анатолий Кулаков" В принципе надолго Iron Python и Iron Ruby надолго умерли.
3646.04 3656.52 "Анатолий Кулаков" Iron Ruby по-прежнему все еще там, а Iron Python как ни странно в принципе оживился, разрабатывается, поддерживается и сейчас более-менее активен.
3656.52 3659.04 "Анатолий Кулаков" Конечно, медленнее, чем хотелось бы, но он существует.
3659.04 3668.08 "Анатолий Кулаков" Я вкратце напомню, что Iron Python это open source имплементация питона, то есть это язык программирования под платформу .NET.
3668.08 3674.48 "Анатолий Кулаков" То есть вы можете писать на питоне, но по факту это все будет исполняться на рентале .NET, что в принципе прекрасно со многих сторон.
3674.48 3685.64 "Анатолий Кулаков" Вы можете использовать язык, который многие считают идеальным для обучения, для вхождения вообще в программирование и при этом зрелую, полноценную, очень производительную среду .NET.
3685.64 3690.76 "Анатолий Кулаков" Язык этот не просто так висит в воздухе, у него есть Python Tools for Visual Studio.
3690.76 3698.12 "Анатолий Кулаков" Это специальный плагин, который позволяет вам удобно использовать наш любимый инструмент Visual Studio вместе с Iron Python.
3698.12 3702.00 "Анатолий Кулаков" И поэтому вы можете разрабатывать на нем довольно-таки безболезненно.
3702.00 3709.04 "Анатолий Кулаков" Новость заключается в том, что анонсирован Iron Python версии 3.4.0 альфа 1.
3709.04 3714.80 "Анатолий Кулаков" То есть это питон, полностью совместимый с настоящим Python 3.3.4.
3714.80 3726.60 "Анатолий Кулаков" Но он может бежать по .NET рантаймам и в частности поддерживается рантайм 4.6 большого фреймворка, Core 2.1, Core 3.1 и .NET 5.
3726.60 3738.12 "Анатолий Кулаков" Сам Iron Python сделан на базе DLR, то есть это Dynamic Language Runtime, который в принципе использовался для многих динамических языков и используется до сих пор.
3738.12 3742.54 "Анатолий Кулаков" И довольно интересная среда, у нас тоже по ней было много докладов.
3742.54 3748.36 "Анатолий Кулаков" И это настоящая штука, зря в принципе сейчас не так популярна, зря заброшена.
3748.36 3752.88 "Анатолий Кулаков" Одно из фишек Iron Python является то, что он полностью совместим с CPython.
3752.88 3755.76 "Анатолий Кулаков" Ну, по крайней мере старается быть в основных своих частях.
3755.76 3767.20 "Анатолий Кулаков" И поэтому Iron Python можно использовать как некий оптимизатор, который дает вам очень большой буст на ваших стандартных питоновских программах.
3767.20 3776.84 "Анатолий Кулаков" Допустим, если у вас есть программа, написанная на чистом Python и при этом вам ее хочется очень сильно-сильно ускорить, попробуйте запустить ее под Iron Python, просто-напросто.
3776.84 3782.84 "Анатолий Кулаков" Обычно это дает очень хорошую производительность и в принципе больше ничего оптимизировать не нужно.
3782.84 3785.04 "Анатолий Кулаков" Просто-напросто поменять рантайм.
3785.04 3788.28 "Анатолий Кулаков" У Python существует две ветки.
3788.28 3792.32 "Анатолий Кулаков" Это ветка второй версии Python и ветка третьей версии.
3792.32 3800.80 "Анатолий Кулаков" От второй версии уже пытаются отказаться более 10 лет, но версия была настолько популярна, что в принципе до сих пор не везде это удалось.
3800.80 3806.60 "Анатолий Кулаков" Но основные дистрибутивы, основные библиотеки, основные программы уже на данный момент все-таки мигрировали.
3806.60 3810.48 "Анатолий Кулаков" Iron Python поддерживает точно так же две ветки.
3810.48 3818.04 "Анатолий Кулаков" Последняя из второй - это 2711 и соответственно третья ветка это 340, сейчас она в альфе.
3818.04 3823.92 "Анатолий Кулаков" Если кому-то интересен Python, то посмотрите на реализацию по .NET, которая называется Iron Python.
3823.92 3824.92 "Игорь Лабутин" Прекрасно.
3824.92 3829.24 "Игорь Лабутин" Я на самом деле думал, что DLR уже как-то сильно подзаброшен.
3829.24 3831.72 "Игорь Лабутин" Я, честно говоря, даже не был уверен, входит ли он в .NET 5.
3831.72 3834.08 "Игорь Лабутин" Но похоже входит и живет и здравствует.
3834.08 3840.00 "Анатолий Кулаков" Ну, по сути, ведь для поддержки DLR ничего не нужно от тебя, от рантайма самого.
3840.00 3844.84 "Анатолий Кулаков" Тебе единственное, что нужно, это вот ключевое слово Dynamic в C#.
3844.84 3848.40 "Анатолий Кулаков" Все остальное сделано абсолютно рядом стоящей библиотечкой.
3848.40 3854.08 "Анатолий Кулаков" То есть это library, который не требует ни изменения или изменения рантайма, вообще ничего.
3854.08 3861.60 "Анатолий Кулаков" То есть можно сделать динамический язык на .NET просто-напросто вот рядом стоящей библиотечкой, тебе этого ничего не надо.
3861.60 3865.76 "Игорь Лабутин" Ну да, тогда, конечно, почему бы не работать на .NET 5.
3865.76 3872.88 "Игорь Лабутин" Хорошо, давай, раз уж мы пошли в такие языковые и прочие тулы, как обычно, пойдем дальше по тулингу.
3872.88 3884.04 "Игорь Лабутин" И новость недавняя относительно, что .NET Monitor есть такой тул, который вы, может быть, знаете, и мы его довольно много обсуждали, какие там в него заводят разные изменения и улучшения.
3884.04 3886.84 "Игорь Лабутин" Он теперь стал официальным supported тулом.
3886.84 3893.20 "Игорь Лабутин" То есть теперь он получил статус нормального тула, а не какой-то экспериментальной или превьюшной поделки.
3893.20 3896.80 "Анатолий Кулаков" Может быть, имеет смысл напомнить про что это, что он умеет делать?
3896.80 3907.00 "Игорь Лабутин" Да, соответственно, это штука, которая позволяет кроссплатформенно получать инфу о запущенных .NET Core и .NET 5 процессах.
3907.00 3916.60 "Игорь Лабутин" В некотором смысле похожей на ETV, то, что можно было сделать или Performance Counter, но кроссплатформенным видом.
3916.60 3923.04 "Игорь Лабутин" И она сейчас доступна в виде .NET Global Tool, либо, соответственно, Docker Container Image, если вам это интересно.
3923.04 3928.28 "Игорь Лабутин" И помимо того, что он стал supported тулом, там есть еще некоторое количество улучшений.
3928.28 3931.72 "Игорь Лабутин" Во-первых, добавились то, что они называют egress providers.
3931.72 3933.96 "Игорь Лабутин" Есть ingress, а это egress, типа наружу.
3933.96 3945.76 "Игорь Лабутин" Потому что раньше нельзя было от этого, он очень классно все писал на экран, но при этом получить из него данные каким-то образом, кроме как через HTTP, было не очень можно.
3945.76 3955.00 "Игорь Лабутин" Теперь в его четвертой превьюшке, которая сейчас вот недавно вышла, можно теперь настроить, либо писать все это в Azure Blob Storage, либо вообще в файловую систему.
3955.00 3959.32 "Игорь Лабутин" То есть можно просто все, что он там мониторит, дампить в файловую систему и дальше с этим как-то разбираться.
3959.32 3960.72 "Игорь Лабутин" Дальше, второй момент.
3960.72 3975.20 "Игорь Лабутин" Он раньше собирал только вполне себе стандартные метрики, то есть либо от систем рантайма, либо Microsoft S/P/NET Core Hosting, потому что основная его цель была, конечно, самой команды Microsoft, поатюнить, помониторить то, как работают их собственный код.
3975.20 3981.84 "Игорь Лабутин" Но теперь можно делать custom метрики, то есть через event counter имитировать дополнительные метрики.
3981.84 3988.64 "Игорь Лабутин" И все это дело в итоге тащится наружу в формате Prometheus, который я так понимаю, что более-менее стандарт.
3988.64 3992.16 "Игорь Лабутин" И соответственно, вы можете это дальше подцепить куда угодно.
3992.16 3995.32 "Игорь Лабутин" И последняя штука, которую они завезли, это security.
3995.32 4008.36 "Игорь Лабутин" То есть теперь, чтобы постучаться к HTTP endpoint, который есть у дотент-монитора, можно включить авторизацию по ключику, можно потребовать RTTPS и указать путь к сертификату.
4008.36 4011.32 "Игорь Лабутин" И соответственно, есть пять endpoints.
4011.32 4018.00 "Игорь Лабутин" Это процессы /dump, /gcdump, /tracing, /logs, которые требуют авторизацию.
4018.00 4021.00 "Игорь Лабутин" При этом есть еще endpoint, который /metrics.
4021.00 4031.88 "Игорь Лабутин" Он не требует авторизации, потому что, как правило, Prometheus или прочие другие штуки, типа Grafana, не очень хотят авторизацию, то есть проще забирать данные без авторизации.
4031.88 4035.04 "Игорь Лабутин" Так работало раньше, они не хотели ничего ломать в этом месте.
4035.04 4043.12 "Игорь Лабутин" В общем, простой конфигурации через обычный AppSettings.json вы можете добавить, как я сказал, некоторые ключики.
4043.12 4047.88 "Игорь Лабутин" Ключики для авторизации генерятся точно так же через .NET пробел Monitor, пробел GenerateKey.
4047.88 4062.28 "Игорь Лабутин" То есть такая сабкоманда сделана специально для генерации ключиков, которые вы потом указываете туда и указываете со своей стороны, со стороны клиента в заголовке авторизацию, в HTTP заголовке, и после этого все будет работать.
4062.28 4063.28 "Игорь Лабутин" То есть, в общем, если вам...
4063.28 4077.48 "Игорь Лабутин" Теперь вы можете ваш .NET Monitor, просто работающий в контейнере, выставить вообще практически наружу, ну можно сказать, практически в интернет и все еще не быть очень сильно беспокоящимся о том, что вы там какие-то данные, дампы ваших процессов отдадите наружу.
4077.48 4079.72 "Игорь Лабутин" Все-таки авторизация хоть как-то это защищает.
4079.72 4082.96 "Игорь Лабутин" Хотя, наверное, все равно плохая идея выставлять это совсем наружу в интернет.
4082.96 4093.68 "Игорь Лабутин" Но, тем не менее, тул развивается, теперь это support от tool, так что если вам нужно мониторить ваши .NET Core и .NET процессы, можно на него смотреть и использовать в продакшене, практически.
4093.68 4095.28 "Игорь Лабутин" Особенно когда он до релиза доберется в 2006.
4095.28 4101.52 "Анатолий Кулаков" У нас еще один есть новый, старый тул, который называется CrossGen.
4101.52 4103.12 "Анатолий Кулаков" CrossGen второй версии вышел.
4103.12 4120.96 "Игорь Лабутин" Да, пока он называется CrossGen 2, и действительно в статье, там даже есть отдельная секция про название, его сначала хотели назвать CrossGen R2R, ну типа Ready to Run, потом еще как-то, еще как-то, в общем в итоге все звучало как-то не так, поэтому просто назвали CrossGen 2.
4120.96 4125.36 "Игорь Лабутин" И план такой, что когда CrossGen 1 умрет, то CrossGen 2 переменят просто обратно в CrossGen.
4125.36 4126.92 "Игорь Лабутин" И мы его будем так и знать дальше.
4126.92 4128.64 "Игорь Лабутин" Что это такое за тул?
4128.64 4138.56 "Игорь Лабутин" Это тул, который позволяет вам сделать ahead-of-time компиляцию, так что когда вы исполняете код в рантайме, JIT уже либо совсем не нужен, либо почти не нужен.
4138.56 4148.88 "Игорь Лабутин" Там совсем в некоторых сценариях вы не сможете предкомпилировать все, но довольно большой кусок вы сможете предкомпилировать, этот бинарный код кладется просто в отдельную секцию в вашем файлике в дл.
4148.88 4153.48 "Игорь Лабутин" И используется во время рантайма, если все, так сказать, складывается.
4153.48 4165.84 "Игорь Лабутин" То есть если вы там не поменяли никакой код, если архитектура совпадает, вот это все, то тогда будет использоваться этот предкомпилированный код, что хорошо, потому что это ускоряет сильный запуск.
4165.84 4170.40 "Анатолий Кулаков" Погоди, ну вот для ускорения сильного запуска у нас был Ready to Run, зачем нам еще нужен CrossGen?
4170.40 4182.76 "Игорь Лабутин" Ну, Ready to Run, CrossGen - это на самом деле довольно-таки заменяемые понятия, то есть они сильно связаны, и CrossGen - это tool, Ready to Run - это подход, концепция, не знаю, как это назвать.
4182.76 4185.60 "Игорь Лабутин" Но у нас был CrossGen 1, который все это позволял делать.
4185.60 4202.76 "Игорь Лабутин" Но CrossGen 1 - это по сути своей, по архитектуре, был тот самый обычный дотиметричный JIT, который мы просто вытащили наружу из рантайма и добавили некоторые обертки, которые позволяют это все писать в правильный формат файла, а не в память напрямую, как JIT это обычно делает, и все.
4202.76 4205.92 "Игорь Лабутин" А вот CrossGen 2 - это новая клевая штука.
4205.92 4210.84 "Игорь Лабутин" Во-первых, это абсолютно новая кодовая база, и они его переписывают на C# внезапно.
4210.84 4216.08 "Игорь Лабутин" JIT естественно на плюсах написан, и CrossGen 1 был плюсовым тулом, CrossGen 2 - это C# тул.
4216.08 4227.84 "Игорь Лабутин" И второе - это оно теперь позволяет делать гораздо больше оптимизаций, потому что они научили CrossGen 2 трогать сразу несколько сборок.
4227.84 4229.68 "Игорь Лабутин" То есть в чем проблема?
4229.68 4245.96 "Игорь Лабутин" Смотрите, раньше CrossGen 1 работал на одной сборке, то есть он брал сборку, он ее как-то JIT'ил, но допустим у вас есть такой популярный паттерн, такой бывает, когда у вас есть какая-нибудь лелька, где сложены, свалены всякие хелперы, там какой-нибудь utils.
4245.96 4256.00 "Игорь Лабутин" Обычно все эти хелперы - это какие-нибудь простые однострочники, они очень удобные и полезны в коде, но если они у вас лежат в отдельной сборке, то CrossGen 1 не мог заинлайнить такие вызовы, потому что они же лежат в другой сборке.
4256.00 4260.32 "Игорь Лабутин" Черт знает, где она там будет, какая версия этой сборки будет в реальном рантайме и так далее.
4260.32 4262.32 "Игорь Лабутин" Это не работало.
4262.32 4270.92 "Игорь Лабутин" CrossGen 2 теперь поддерживает эту штуку, они называют это version bubble, если интересно почитать, вещи типа version bubble - пузырь версии в дословном переводе.
4270.92 4284.16 "Игорь Лабутин" И вы можете CrossGen 2 подсунуть несколько сборок, он их проджитит вместе, сделает инлайны между ними и запомнит, каких версий кто был и кого откуда он заинлайнил.
4284.16 4299.12 "Игорь Лабутин" Соответственно в рантайме, если вы хотя бы одну из таких сборок подмените, он поймет, кто от этой сборки зависел, куда он что заинлайнил и поймет тогда, что то, куда он заинлайнил нельзя использовать в джитованном виде, потому что ну мало ли поменялся код, который инлайнился.
4299.12 4303.84 "Игорь Лабутин" И тогда будет работать нормальный джит во время рантайма и нормально все заджитит заново.
4303.84 4334.00 "Игорь Лабутин" То есть, учитывая, что обычно все-таки в релизе, например, мы не сильно часто подменяем сборки, то в целом кажется, что это неплохая техника оптимизации, которая позволит предкомпилировать достаточно быстрый, достаточно хороший, так сказать, код, достаточно хорошо оптимизированный, почти такой же, как джит нормальный в рантайме, по которому видна вся программа и при этом иметь, так сказать, safety net, то что называется на предмет, если мы вдруг что-то подменили или почему-то не совпало архитектура или еще что-то произошло.
4334.00 4352.44 "Игорь Лабутин" В общем вот, все это будет в шестом дотнете, это опять же, мы обсуждали сколько-то выпусков назад, что скорее всего это будет, ну так, полировка, причесывание для LTS релиза, но вот мы уже сколько всего обсуждаем и какие-то новые фичи, новые тулы, новые что-то.
4352.44 4359.40 "Игорь Лабутин" Так что будет интересно еще дальше, нам еще полгода до релиза, так что наверняка еще что-нибудь завезут.
4359.40 4363.20 "Анатолий Кулаков" Так, ну что ж, продолжим по хардкору, я тут вижу, ты еще статейку от майони принес?
4363.20 4377.48 "Игорь Лабутин" Да, старая статейка, февраля примерно, что ли, если я правильно помню, но мы что-то особо сильно не обсуждали, давайте тоже быстро пробежимся, напомним, что есть такая штука, мало ли для кого-то это будет актуально и для каких-то сценариев вы узнаете что-то новенькое.
4377.48 4383.60 "Игорь Лабутин" Я веду речь о Pinnet Object heap, который на русском называется прикольной аббревиатурой POH.
4383.60 4394.40 "Игорь Лабутин" Это действительно новый тип кучи, который появился в дотнете 5, она в принципе уже есть в нормальном релизном рантайме и вообще это все вокруг pinnet objects.
4394.40 4397.32 "Игорь Лабутин" Что такое pinnet object?
4397.32 4406.08 "Игорь Лабутин" Это же объект, который запинен, то есть он не имеет права передвигаться по памяти, то есть garbage collector усказан, этот объект двигать нельзя.
4406.08 4419.88 "Игорь Лабутин" Обычно это используется для сценариев, когда какой-либо массив передается для обработки, передачи данных в unmanaged код, который естественно работает с нормальными обычными указателями в память и будет очень удивлен, если garbage collector внезапно переместит объект куда-нибудь.
4419.88 4428.16 "Игорь Лабутин" Ну точнее, unmanaged код удивлен не будет, он просто продолжит писать по старому адресу, а вот garbage collector будет сильно удивлен того, что ему куда-то что-то записали.
4428.16 4441.44 "Игорь Лабутин" В идеальном случае, пиннить надо конечно на очень короткое время и пиннить очень желательно какие-то статические вещи, потому что статические вещи обычно никуда не двигаются, они живут все время программы и поэтому запините вы их или нет более-менее не важно.
4441.44 4442.80 "Игорь Лабутин" А почему на короткое время?
4442.80 4462.28 "Игорь Лабутин" Потому что если вы запините на длинное время и пока объект запинен, у вас сработает garbage collector, то garbage collector будет немножко страдать, потому что этот объект ему не подвинуть и если внезапно этот объект например в нулевом или в первом поколении, где компактинг это вполне нормальная вещь и которая периодически происходит, это будет сильно мешать компактингу.
4462.28 4474.60 "Игорь Лабутин" И из-за этого на самом деле, чтобы хоть как-то с этим бороться, у garbage collector есть даже специальный режим, что такие объекты запиненные иногда не промоутятся в следующее поколение.
4474.60 4485.84 "Игорь Лабутин" То есть мы все знаем из теории, из интервью и от Рихтера, что если объект был в нулевом поколении, то после сборки мусора он гарантированно окажется в первом поколении, а потом соответственно при следующей сборке мусора во втором.
4485.84 4494.00 "Игорь Лабутин" Так вот на самом деле для пиннинг, для запиненных объектов это неправда, если он был в нулевом поколении, после сборки мусора он может остаться в нулевом поколении.
4494.00 4500.20 "Игорь Лабутин" Если интересно почитать про это подробнее, ищите материалы с ключевым словом demotion.
4500.20 4503.12 "Игорь Лабутин" Обычно есть promotion, а это demotion.
4503.12 4505.32 "Игорь Лабутин" Дальше, следующая штука.
4505.32 4518.44 "Игорь Лабутин" Мы обычно пинем массивы и понятно, что как только мы говорим про массивы, мы редко, если мы пиним, это значит, что скорее всего у нас какой-нибудь high performance сценарий и скорее всего вы используете array pool.
4518.44 4533.96 "Игорь Лабутин" Это немножко спасает, потому что array pool, там обычно массивы могут быть более-менее одинакового размера, они как-то могут быть разложены рядом случайно или не случайно, и поэтому чуть проще, это просто большой объем данных, которые запинены и при этом не могут двигаться.
4533.96 4547.92 "Игорь Лабутин" Но если это так, то есть если у нас есть массивы, которые запинены, которые например достаточно долго запинены, мы знаем, что нам много придется работать с Unmanned Spamming, то почему бы эти массивы вообще не вытащить из обычного heap'а и не положить в отдельный heap?
4547.92 4552.40 "Игорь Лабутин" Подумала команда runtime, а точнее коробочек коллектора, а точнее maoni, и сделала отдельный heap.
4552.40 4563.32 "Игорь Лабутин" То есть он называется pinnet object heap, там можно делать только, там можно хранить только массивы, больше пока ничего, и allocate'ить оттуда можно только массивы.
4563.32 4576.12 "Игорь Лабутин" И появилось две новых API в классе GC, это allocate array, туда передается длина и флажок pinned true, или allocate uninitialized array, туда тоже передается длина и флажок pinned true.
4576.12 4590.04 "Игорь Лабутин" Это означает, что массив не нужно zero initialize'ить в начале, причем это не гарантирует на самом деле, что он не будет проинитialized, там есть сценарий, когда он все равно проинитialize'ится, но в целом это говорит о том, что мне как вызывающему пофигу, что там лежит.
4590.04 4607.32 "Игорь Лабутин" По своей сути pinnet object heap это то же самое, что large object heap, то есть он тоже принадлежит второму поколению, оттуда тоже будет происходить сборка мусора, если вы потеряли ссылку на массив, он конечно же тоже соберется, но это отдельная структура, поэтому она не так сильно фрагментирует large object heap.
4607.32 4630.64 "Игорь Лабутин" И для того, чтобы иметь возможность обозначать, что теперь находится в gen2, теперь у нас есть, ну не совсем в gen2, неправильно сказал, раньше у нас был как бы gen0, gen1, gen2 и large object heap, а теперь у нас есть нулевое первое и второе поколение, large object heap и pinned object heap, поэтому вместе large object heap и pinned object heap теперь называются user old heap, внезапно.
4630.64 4631.64 "Игорь Лабутин" Почему old?
4631.64 4636.28 "Игорь Лабутин" Не знаю, почему old, но вот так написано, видимо потому, что там отживут старые объекты.
4636.28 4637.28 "Игорь Лабутин" Это не толерантно.
4637.28 4653.64 "Игорь Лабутин" Я не знаю почему, но вот это называется, да, такая премиатура, но справедливости ради, статья Маони, где этот термин вводится, это единственное место, где я это встречал, хотя она говорит, что в коде поменялось, то есть это важно, если вы полезете в код garbage collector, то ищите там теперь не loch, а uoch.
4653.64 4659.08 "Игорь Лабутин" Еще одна очень неудобная для русскоязычного слушателя аббревиатура.
4659.08 4677.28 "Игорь Лабутин" И как и раньше, ну то есть не как и раньше, пинить можно у нас только blittable объекты, то есть те, которые не содержат managed references внутри себя, то есть массивы, которые не содержат managed references, и ровно такие массивы можно loch-хейтить в этом pinned-том же heapе.
4677.28 4679.64 "Игорь Лабутин" Другие нельзя, это будет runtime exception.
4679.64 4680.64 "Игорь Лабутин" Как-то так.
4680.64 4684.08 "Анатолий Кулаков" Так, у меня еще есть одна новость с февраля.
4684.08 4687.68 "Анатолий Кулаков" .NET Foundation открыл speaker directory.
4687.68 4695.36 "Анатолий Кулаков" Это специальное место, где собираются различные докладчики, которые могут прочитать доклады.
4695.36 4702.48 "Анатолий Кулаков" И в принципе это место интересно нам тем, что там могут собираться спикеры просто со всего мира, которые могут поговорить про .NET.
4702.48 4714.32 "Анатолий Кулаков" Это могут быть как докладчики, так и менторы, которые обучают новых спикеров, и .NET Foundation всячески призывает в этом месте искать спикеров.
4714.32 4721.32 "Анатолий Кулаков" Там можно искать по нейму, по имени, фильтровать по какой-то теме, которую спикеры сами себе объявляют.
4721.32 4731.64 "Анатолий Кулаков" Там можно фильтровать по языку, на которых спикер разговаривает, и соответственно искать тех, кто идеально подходит вам по различным географическим признакам.
4731.64 4740.08 "Анатолий Кулаков" Сейчас в данном каталоге около 250 спикеров, и мы в принципе всячески призываем вас туда присоединиться.
4740.08 4749.56 "Анатолий Кулаков" Если вы вдруг хотите поговорить на тему .NET, и хотите быть доступны для приглашения во всем мире, то это в принципе кажется отличной точкой.
4749.56 4767.72 "Игорь Лабутин" Я бы хотел присоединиться к, так сказать, Анатолию и попросить вас, если вы являетесь спикером или хотите им стать, добавиться туда, потому что сейчас вот я смотрю на карту, а из русскоязычной, ну по крайней мере скажем так, на русскоязычной карте есть всего одна точка, и это я.
4767.72 4774.44 "Анатолий Кулаков" Ну ты имеешь ввиду все-таки из России, потому что русскоязычных там около пяти человек, но многие из них в Америке,
4774.44 4777.44 "Игорь Лабутин" некоторые из Украины. Да, окей, согласен, действительно.
4777.44 4778.44 "Игорь Лабутин" А, да.
4778.44 4781.76 "Анатолий Кулаков" А в России разговариваешь только ты действительно про .NET?
4781.76 4787.48 "Игорь Лабутин" В России разговариваю только я, хорошо, я вижу еще трех человек на Украине, или в Украине.
4787.48 4799.78 "Игорь Лабутин" И в общем, да, очень мало, так что добавляйтесь, давайте покажем, что в России мы тоже умеем рассказывать про .NET, и все вокруг технологий, это не только про .NET, это вообще про любые вещи.
4799.78 4811.66 "Игорь Лабутин" Тут есть, вот я смотрю сейчас список тем, тут есть такие штуки, как там, не знаю, Microsoft 365, ML.NET, Project Management, Game Development, Human Skills, TVOS, ну в общем.
4811.66 4814.30 "Анатолий Кулаков" Нет, слушай, это вообще позор какой-то.
4814.30 4820.44 "Анатолий Кулаков" Я сейчас смотрю на наш .NET рушный каталог спикеров, сколько их там, 250.
4820.44 4830.28 "Анатолий Кулаков" Вот у нас сейчас в .NET рушном каталоге спикеров находится больше 220 спикеров, которые говорят четко по-русски и строго на хардкорную тему .NET.
4830.28 4839.94 "Анатолий Кулаков" И более того, эти спикеры собраны не просто так, пожалуйста, зарегистрируйтесь, все эти спикеры туда попали только после того, как они сделали как минимум один доклад.
4839.94 4843.56 "Анатолий Кулаков" То есть, это каталог более прорженный, более проверенный.
4843.56 4851.68 "Анатолий Кулаков" Так что, мне кажется, нам нужно самим открывать свой пойнт и рисовать на карте русских спикеров более правдиво, а не так, как они.
4851.68 4853.64 "Игорь Лабутин" Да, будет, наверное, правильнее.
4853.64 4856.44 "Игорь Лабутин" Давай напишем скрипт, который всех туда зарегистрирует.
4856.44 4859.20 "Анатолий Кулаков" Я думаю, они нам этого не простят.
4859.20 4864.44 "Анатолий Кулаков" Представляешь, если им будут приходить предложения выступить людям, которые на это не подписывались.
4864.44 4865.44 "Игорь Лабутин" Да, это неправильно.
4865.44 4875.68 "Игорь Лабутин" Ладно, но на самом деле, если вы действительно хотите, чтобы вас узнали и каким-то образом знали, что вы тоже на околомайкрософтовские темы, зарегистрируйтесь
4875.68 4881.24 "Анатолий Кулаков" там. Ну, я так понимаю, что это в основном работает для тех, кто хочет, чтобы о нем узнали за пределами России.
4881.24 4882.24 "Анатолий Кулаков" Да.
4882.24 4883.88 "Анатолий Кулаков" Там в Европах, Америках и прочих глупостях.
4883.88 4892.52 "Анатолий Кулаков" Если же вы все-таки хотите распространить свою религию в пределах России, то вам, наверное, лучше обратиться к dotnet.ru организации.
4892.52 4895.64 "Игорь Лабутин" Да, мы поможем, обязательно.
4895.64 4900.04 "Игорь Лабутин" Давай дальше, последняя тема, она такая, тоже странная.
4900.04 4904.52 "Игорь Лабутин" Она буквально вчера залетела в мой список, и я решил ее быстренько добавить.
4904.52 4909.00 "Игорь Лабутин" Это тема про dotnet framework 452, 46 и 461.
4909.00 4910.00 "Игорь Лабутин" А?
4910.00 4911.00 "Игорь Лабутин" Мы обычно...
4911.00 4912.00 "Игорь Лабутин" Что с ними не так?
4912.00 4919.72 "Игорь Лабутин" Ну, мы обычно обсуждаем dotnet 5, dotnet 6, должны же мы поговорить о чем-то, что было зарегистрировано уже сколько лет, 5, наверное, назад, да?
4919.72 4929.44 "Игорь Лабутин" Короче, смысл в том, что мы много обсуждали, что у нас там LTS-версии dotnet core и dotnet не LTS-версии.
4929.44 4949.12 "Игорь Лабутин" В общем, все такое, мы немножко, не то что подзабыли про всякие старые фреймворки, но вот тут Microsoft опубликовала интересную новость, и мы решили немножко осветить это дело, а именно через год, 26 апреля 2022 года, заканчивается саппорт версии 452, 46 и 461 обычного десктопного фреймворка.
4949.12 4951.00 "Игорь Лабутин" Ну, это должно было когда-нибудь случиться.
4951.00 4972.14 "Игорь Лабутин" Основная мотивация Microsoft, это потому что там и сборки подписаны с помощью SHA-1, и внутри там много SHA-1, уже не актуален, протуг считается небезопасным и так далее, поэтому короче использовать его нельзя, не надо и в от stealом забудьте про эти версии, пользуйтесь хотя бы 462 и новее.
4972.14 4978.28 "Игорь Лабутин" Но это не всё, если внимательно почитать новость, то выясняется следующее.
4978.28 4987.32 "Игорь Лабутин" Как вы знаете, и вас наверное не сильно удивляет, что Family Datos framework 1.0, 1.1, 2.0, 3.0, 3.5, 4.0, 4.5 и 4.5.1 уже не поддерживаются.
4987.32 5013.24 "Игорь Лабутин" Ну как бы это нормально, но если вам вдруг зачем-то нужны инсталлеры или какие-то пакеджи или ещё что-то короче вокруг этих фреймворков, то поторопитесь, потому что с 26 июля 2021 года, это этот год, то есть это буквально через 3 месяца, все по мнению Microsoft инсталлеры, бандлы, пакеджи и апдейты для всех этих версий фреймворков, которые я назвал, исчезнут с сайтов Microsoft, их нельзя будет больше скачать никак.
5013.24 5021.96 "Анатолий Кулаков" То значит зачем-то, у нас живут 10 годовалые интерпрайзы, никуда не собираются мигрироваться, они деплоятся на новых кастомеров и всё такое.
5021.96 5024.68 "Анатолий Кулаков" Конечно им нужны дистрибутивы, конечно им нужны рантаймы.
5024.68 5033.56 "Игорь Лабутин" Ну Microsoft говорит перейдите хотя бы на 4.6.2, там почти всё совместимо, там ну немножко возможно breaking changes, но в целом оно совместимо короче, 4.6.2 должно работать.
5033.56 5035.04 "Игорь Лабутин" Но это не всегда возможно.
5035.04 5036.04 "Игорь Лабутин" Это правда.
5036.04 5042.32 "Игорь Лабутин" Что меня очень удивило, что особняком вообще стоит тут над фреймворком 3.5.1.
5042.32 5048.28 "Анатолий Кулаков" Это по-моему первый фреймворк, который был в XP, или чем он ещё особняком, чем он так выдающийся от других?
5048.28 5050.84 "Игорь Лабутин" Он выдающийся от других тем, что он до сих пор саппортит.
5050.84 5056.56 "Игорь Лабутин" И более того, он, у него end of support сейчас заявленный Microsoft в сентябре 29 года.
5056.56 5058.32 "Игорь Лабутин" Вот это неплохо.
5058.32 5062.34 "Игорь Лабутин" Если вы почему-то живёте на 3.5.1, на самом деле причина проста.
5062.34 5072.96 "Игорь Лабутин" Он был частью операционной системы и соответственно на него распространялась стандартная политика Microsoft, что срок саппорта совпадает со сроком саппорта операционки.
5072.96 5079.80 "Игорь Лабутин" И он был частью операционки до Windows 10 version 1809, а точнее до версии передней.
5079.80 5086.80 "Анатолий Кулаков" Ну то есть, если ваш продукт на .NET фреймворке 4.5, срочно даунгрейдитесь на .NET фреймворк 3.5.
5086.80 5089.32 "Анатолий Кулаков" Он будет поддерживаться ещё 10 лет.
5089.32 5090.72 "Игорь Лабутин" 3.5 SP1, прошу заметить.
5090.72 5092.72 "Игорь Лабутин" 3.5 не поддержан, только SP1.
5092.72 5100.36 "Игорь Лабутин" И вот начиная с Windows 10 version 1809, либо с сервера 2019, я так понимаю, что он перестал быть частью операционки.
5100.36 5111.60 "Игорь Лабутин" Это теперь standalone продукт, но опять же согласно политике Microsoft, с этого момента он получает 5 лет поддержки и потом ещё порядка 5 лет Extended Support.
5111.60 5115.20 "Игорь Лабутин" Короче, сейчас пока написано Extended Support 2029.
5115.20 5117.76 "Игорь Лабутин" Так что радуемся, пишем на 3.5 на .NET.
5117.76 5118.76 "Игорь Лабутин" Вообще, зашибись.
5118.76 5123.92 "Анатолий Кулаков" И ищем торренты с официальными дистрибутивами .NET фреймворка 4.5, 4.5.11.
5123.92 5124.92 "Анатолий Кулаков" Да.
5124.92 5142.56 "Игорь Лабутин" Если же вы пользуетесь правильным .NET фреймворком, если ещё не на .NET Core, а соответственно 4.6.2, либо 4.8, ну всё, что между ними, 4.7, все версии, то с ними всё хорошо, у них есть саппорт, но если вам интересно, когда у них заканчивается саппорт, то там всё просто.
5142.56 5149.12 "Игорь Лабутин" До тех пор, пока соответствующий фреймворк входит в поставку какой-то операционной системы, он будет поддержан в течение жизни этой операционной системы.
5149.12 5155.84 "Игорь Лабутин" То есть до тех пор, пока Microsoft поставляет 4.8 вместе с Windows, а она это делает, то он будет поддерживаться.
5155.84 5156.84 "Анатолий Кулаков" Ну хотя бы.
5156.84 5163.76 "Анатолий Кулаков" В общем, полностью с большого фреймворка очень много приложений не слезет, ну то есть хотя бы надо поддерживать последнюю версию.
5163.76 5168.80 "Анатолий Кулаков" Есть большой шанс, что многие программы до неё всё-таки домигрируют и заморозятся на ней.
5168.80 5169.80 "Игорь Лабутин" Ну да, да.
5169.80 5170.80 "Игорь Лабутин" Так что так.
5170.80 5172.84 "Игорь Лабутин" На этом всё, я думаю.
5172.84 5174.16 "Игорь Лабутин" Пробежимся, что мы обсудили.
5174.16 5176.80 "Анатолий Кулаков" Да, давай посмотрим, что мы за сегодня успели.
5176.80 5183.20 "Игорь Лабутин" Ой, мы сегодня пробежались вообще от новейших историй до совсем каких-то древностей 2010 года.
5183.20 5184.20 "Игорь Лабутин" Ну давайте по порядку.
5184.20 5192.04 "Игорь Лабутин" 2022 студия, анонс, пока мало деталей, основная фича это иконочки конечно же и x64.
5192.04 5193.36 "Игорь Лабутин" Посмотрим, что будет дальше.
5193.36 5199.12 "Игорь Лабутин" И обсудили, как там живёт ReSharper и чем грозит ему 22 студия.
5199.12 5209.84 "Игорь Лабутин" Посмотрели на список, ну скажем так, не то чтобы C# 10 импровментов, но того, что может войти в эту версию C# 10, а может и не войти, посмотрим ближе к делу.
5209.84 5217.36 "Игорь Лабутин" Также посмотрели немножко на импровменты вокруг асинхронных тасков, .NET 6, как их можно теперь ждать с правильными тайм-аутами.
5217.36 5225.28 "Игорь Лабутин" Вспомнили, что существует такая клёвая троица сайтов APIs of .NET, Themes of .NET и Designs of .NET, чтобы вы лучше ориентировались в .NET.
5225.28 5233.12 "Игорь Лабутин" Оживили Iron Python, точнее он сам ожил, и мы про это вспомнили и узнали, что он до сих пор живой и на .NET вполне работает.
5233.12 5238.08 "Игорь Лабутин" .NET Monitor стал официальным тулом и в него завезли некоторое количество полезных улучшений.
5238.08 5245.16 "Игорь Лабутин" CrossGen 2 потихонечку развивается и к релизу у нас будет клёвое AOT, Ahead of Time Compilation решение.
5245.16 5252.08 "Игорь Лабутин" В .NET 5 нам уже была доступна пиннинг TopJet heap, мы немножко подробнее посмотрели, что это такое и зачем это может быть надо.
5252.08 5259.28 "Игорь Лабутин" Если вы спикер, занесите себя в .NET Foundation Speaker Directory, если вам интересно быть как-то международно видимым.
5259.28 5271.32 "Игорь Лабутин" Ну и если вы вдруг все еще сидите на старом фреймворке, то помните, что 4.5.2, 4.6 и 4.6.1 через год закончат свое существование с точки зрения поддерживаемых фреймворков.
5271.32 5272.32 "Игорь Лабутин" Переходите на более новый.
5272.32 5276.48 "Анатолий Кулаков" Отлично, в принципе хороший списочек, я думаю, давай его подкрепим очередным конкурсом.
5276.48 5278.00 "Анатолий Кулаков" Давно-ка мы не раздавали лицензии.
5278.00 5285.52 "Анатолий Кулаков" Итак, друзья, у нас есть три лицензии от компании JetBrains на любой их продукт и получить их довольно-таки просто.
5285.52 5290.40 "Анатолий Кулаков" С помощью рандома великого и справедливого будут выбраны три победителя.
5290.40 5300.32 "Анатолий Кулаков" Итак, первый победитель будет составлен из списка тех участников, которые на канале YouTube под этим выпуском оставят свой комментарий.
5300.32 5309.64 "Анатолий Кулаков" Напишите нам о том, как вы слушаете подкаст, где вы слушаете, что вам нравится, что не нравится или просто о том, где вы сейчас находитесь, где вы сейчас живете, все что угодно.
5309.64 5315.20 "Анатолий Кулаков" Не принципиально, нам главное понять, что нас слушают настоящие люди и мы не просто так стенку разговариваем.
5315.20 5326.16 "Анатолий Кулаков" Вторая лицензия получит тот, кто один из тех, кто расшарит эту запись из группы ВКонтакте .NET.RU, запись с этим выпуском подкаста.
5326.16 5334.16 "Анатолий Кулаков" И третья лицензия уйдет тому, кто ретвитнет анонс этого подкаста в Твиттере официального аккаунта .NET.RU.
5334.16 5336.04 "Анатолий Кулаков" Вот такие вот три лицензии.
5336.04 5345.60 "Анатолий Кулаков" Розыгрыш состоится через семь дней после публикации этого анонса и также будет опубликован под этим выпуском, поэтому следите за нашими комментариями.
5345.60 5355.64 "Анатолий Кулаков" Еще мы в прошлых выпусках объявляли о более глобальной поддержке нашего подкаста, о том, кто нам может помочь какими-то более серьезными вещами.
5355.64 5357.40 "Анатолий Кулаков" За это мы обещали книгу Рихтера.
5357.40 5361.32 "Анатолий Кулаков" К сожалению, добровольца набралось не так уж и много.
5361.32 5367.96 "Анатолий Кулаков" Есть отдельные личности, мы о них поговорим в следующий раз, но книги Рихтера у меня все еще остались.
5367.96 5369.88 "Анатолий Кулаков" Они у меня, они прекрасны.
5369.88 5374.32 "Анатолий Кулаков" Автограф исцеляет и мироточит.
5374.32 5377.28 "Анатолий Кулаков" В общем, личный автограф Джефри Рихтера ждет вас.
5377.28 5380.08 "Анатолий Кулаков" Я так думаю, что мы эти книги оставим пермоментно.
5380.08 5386.52 "Анатолий Кулаков" То есть, нам нужна ваша помощь, нам нужно, чтобы вы как-то помогли нам продвинуть подкаст.
5386.52 5394.48 "Анатолий Кулаков" И для тех, кто лучше всех это сделает, мы, соответственно, когда-нибудь подарим книгу с личным автографом Джефри Рихтера.
5394.48 5396.64 "Анатолий Кулаков" Вот сейчас эти книги лежат и ждут своих героев.
5396.64 5402.64 "Анатолий Кулаков" Пожалуйста, присоединяйтесь, помогайте и, как всячески, делитесь нашими выпусками.
5402.64 5404.08 "Анатолий Кулаков" Нам это очень приятно.
5404.08 5406.80 "Анатолий Кулаков" И сильно вдохновляет нас на новые эпизоды.
5406.80 5409.40 "Игорь Лабутин" А на этом мы завершаем 28 выпуск подкаста.
5409.40 5411.20 "Игорь Лабутин" С вами были Игорь Лабутин.
5411.20 5412.20 "Игорь Лабутин" И Анатолий Кулаков.
5412.20 5413.20 "Игорь Лабутин" Всем пока.
5413.20 5413.70 "Игорь Лабутин" Пока.
