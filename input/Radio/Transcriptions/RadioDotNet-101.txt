0.00 41.50 "Анатолий Кулаков" В частности, Александр, Сергей, Владислав, Шевченко Антон, Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Андрей Маслов, Дмитрий Павлов, Постарнаков Андрей.
41.50 47.06 "Анатолий Кулаков" Друзья, всем спасибо, а также тем, кто пожелал остаться неназванными.
47.06 59.34 "Анатолий Кулаков" Спасибо за большую помощь, если кто-то еще хочет поддержать наш подкаст, то, милости просим, заходите на бусти и посмотрите, как там с миру по нитке можно собрать нам на чай, кефир, на еще какой-нибудь микрофон.
59.34 66.14 "Анатолий Кулаков" В общем, все идет в дело, все идет для вас, только лучший звук, только лучшие новости, только самые прекрасные ведущие.
66.14 68.02 "Анатолий Кулаков" Ну как, я подвел?
68.02 70.30 "Игорь Лабутин" Вообще шикарно, особенно, как обычно.
70.30 76.74 "Игорь Лабутин" Давай теперь заведем нашу стандартную шарманку, никаких новостей нет, рассказывать не о чем, разбежались, все, всем до свидания, всем спасибо.
76.74 77.74 "Игорь Лабутин" Ну как-то так.
77.74 78.74 "Игорь Лабутин" Я думаю, да.
78.74 88.18 "Игорь Лабутин" Скоро, мне кажется, будут заглядеть наши выпуски, потому что, действительно, мы все очень ждем следующего, кто у нас там релиз-кандидат, да, вы же, был же релиз-кандидат 1.
88.18 89.18 "Игорь Лабутин" Ну да, да.
89.18 90.18 "Игорь Лабутин" Соответственно, второй должен быть.
90.18 91.18 "Игорь Лабутин" Второй должен быть.
91.18 93.02 "Игорь Лабутин" Трех, по-моему, еще не было ни разу, мне кажется.
93.02 108.94 "Игорь Лабутин" Но учитывая, что дата релиза у нас 14-е, да, по-моему, ноября или что-то около того, то есть это еще полтора, почти месяца, ну то есть, видимо, где-нибудь к середине-концу октября будет релиз-кандидат 2, так что долго нам еще ждать.
108.94 109.94 "Анатолий Кулаков" А пока...
109.94 110.94 "Анатолий Кулаков" Ну мы просто так ждать не будем.
110.94 111.94 "Анатолий Кулаков" Да, будем смотреть статьи.
111.94 112.94 "Анатолий Кулаков" У нас есть кучка статейчиков.
112.94 118.82 "Анатолий Кулаков" Интересно, вообще это нормальный формат, когда мы код статьи описываем звуком?
118.82 121.38 "Анатолий Кулаков" Это как идет, прокатывает?
121.38 134.86 "Игорь Лабутин" Ну иногда некоторые статьи, как Тауба, очень сложно описывать голосом на самом деле, а некоторые статьи, вот сегодня будет одна из таких статей, где лучше было бы, конечно, с картинками, но мы постараемся голосом.
134.86 148.26 "Игорь Лабутин" Но вообще интересно, да, напишите нам в комментариях, как вы смотрите и как вам кажется, чем может быть лучше и чего бы такого обозревать в таких выпусках, когда вообще никаких новостей нет.
148.26 155.94 "Анатолий Кулаков" Слушай, ну вообще, статьи, слайды, видосики, это любой дурак покажет, а ты попробуй голосом опиши, так чтобы было интересно.
155.94 158.74 "Игорь Лабутин" Ну или хотя бы понятно, фиг с ним, это интересно.
158.74 160.90 "Анатолий Кулаков" Да-да, понятно, это уже хорошо.
160.90 168.94 "Анатолий Кулаков" Ладно, пойдем, не будем затянуть времени, несмотря на то, что новостей нет, статьи у нас много, ну если что-то не влезет, то перенесем, но давай попробуем вместить.
168.94 175.78 "Анатолий Кулаков" Начнем с Espyro, у нас уже давняя традиция, несмотря на отсутствие новостей, без Espyro мы выпуски уже не проводим.
175.78 182.06 "Анатолий Кулаков" И в этот раз я наткнулся на статейку, как мы можем с помощью Espyro тестировать.
182.06 196.78 "Анатолий Кулаков" Наши постоянные слушатели помнят, что как только Espyro появился, как бы у нас сразу возникла дискуссия, как с этой штукой обстоят дела в плане тестирования, и вот вышла как раз статейка у Микрософта, которая нам рассказывает, что с тестированием там все в порядке, в частности, давайте же все-таки посмотрим.
196.78 199.94 "Анатолий Кулаков" Ну, во-первых, в чем, собственно, проблема?
199.94 205.82 "Анатолий Кулаков" А проблема заключается в том, что когда мы начинаем тестировать распределенное приложение, это довольно сложная задача.
205.82 234.98 "Анатолий Кулаков" Потому что вам нужно не просто создать какой-нибудь классик, замокать ему входные аргументы и при этом радостно сделать вид, как будто вы пишете по TDD, нет, когда мы говорим о распределенном приложении, вам нужно поднять базу данных, поднять какой-то кэш, поднять очередь, все это обычно в разных контейнерах находится, поднять сервис 2, 3, 10, сколько вы их там насобирали, и все это каким-то образом от начала и до конца необходимо протестировать, убедиться, что оно все работает.
234.98 244.06 "Анатолий Кулаков" И именно на Aspire возлагалась та надежда, которая говорит, что это возможно сделать легко, хорошо и просто.
244.06 248.14 "Анатолий Кулаков" Поэтому хотелось бы, хотелось бы, чтобы Aspire такую штуку поддерживал.
248.14 263.90 "Анатолий Кулаков" И он поддерживает, поэтому в Aspire очень легко сделать тестирование приложения, и не просто вашего одного приложения, а именно тестирование в той связке, которую он может описать.
263.90 279.66 "Анатолий Кулаков" То есть мы сейчас говорим как раз про Aspire, как про средства композиции, про средства, в котором вы описали уже, какие у вас есть сервисы, как они с друг другом зависят, как они с друг другом взаимодействуют, какие у них там есть сервис Discovery, все вы это уже настроили, это уже все в хосте есть.
279.66 300.94 "Анатолий Кулаков" Если раньше вам необходимо было сделать какой-нибудь может быть Docker Compose для тестирования, или поднять какой-нибудь список из тест-контейнеров для того, чтобы их тоже настроить и провести end-to-end тесты, то сейчас все это описание у вас уже есть в Aspire, и по идее никаких лишних шагов вам делать не должно быть нужно.
300.94 304.18 "Анатолий Кулаков" Ну посмотрим, как это обстоит на практике.
304.18 328.38 "Анатолий Кулаков" Действительно, Aspire можно использовать для тестирования, в частности мы сейчас говорим не о юнит-тестировании каком-то, мы говорим об end-to-end тестировании или интеграционном тестировании, именно когда вам нужно подымать практически то приложение, которое будет у вас крутиться на продакшен, с максимально близкой к продакшену функциональности, то есть минимум моков у вас там должно быть, и запустить ваши тесты, которые у вас там должны ходить.
328.38 333.82 "Анатолий Кулаков" Сделать все это можем мы с помощью пакета, который называется Aspire Hosting Testing.
333.82 335.74 "Анатолий Кулаков" А как же это делается?
335.74 364.94 "Анатолий Кулаков" Ну для примера мы можем рассмотреть пустое наше приложение, которое создается с помощью .NET New Aspire Starter, это специальный такой темплейт, и для того чтобы создать тесты, вот такие интеграционные тесты, у нас тоже есть специальный темплейт, а мы его можем вызвать с помощью функции .NET New Aspire и указать через DEFIS, с каким фреймворком мы хотим сделать наш тестовый проект, например -MS_TEST, -X_UNIT, -N_UNIT.
364.94 370.84 "Анатолий Кулаков" Как вы поняли, уже поддерживается три основных фреймворка, поэтому вы можете выбрать тот, который подходит больше всего вам.
370.84 385.48 "Анатолий Кулаков" И уже когда мы создаем вот этот тестовый проект из нашего темплейта, уже этот тестовый проект содержит референс на Nuget пакет Aspire Hosting Testing, поэтому больше явно вам его задавать не нужно, все остальное уже находится в нем.
385.48 387.34 "Анатолий Кулаков" Как же пишется сам тест?
387.34 427.50 "Анатолий Кулаков" Ну если вы когда-нибудь писали тесты на основе TestFactory, то для вас никаких новшеств не будет, в принципе так как пишутся интеграционные тесты для обычного ASP.NET приложения, также в принципе пишутся тесты по своей форме для Distributed Application, то есть вы создаете Distributed Application Testing Builder, вызываете у него метод Create, в качестве параметра вы должны передать Aspire Application Host, это тот хост в котором настроены как раз все ресурсы для Aspire, там где у вас провязаны взаимосвязи, там где провязаны референсы, данные именно вашим сервисам, вот этот самый классик, вы его просто указываете параметром.
427.50 432.14 "Анатолий Кулаков" Дальше Distributed Application Test Builder сам знает чего с ним делать.
432.14 628.62 "Анатолий Кулаков" Также вы можете этот хост, наш тестовый хост, немножко деконфигурить, допустим вам нужно пробросить какие-то переменные, как-нибудь поднастроить http клиентов специфично для ваших юнит тестов и прочее, все это можно будет сделать до того момента пока вы вызвали Application Host Build, как только вы этот хост забилдили, вызывается стандартный метод Start и все, и ваше приложение поднимается, стартует, поднимает абсолютно все контейнеры, все зависимости, в общем все происходит точно так же как ведет себя нормальный Aspire при запуске, то есть поднимает все контейнеры, пробрасывает между ними какой-то сетевой тоннельчик, запускает все конфигурации, в общем полностью поднимает ваше приложение, но метод Start не ждет пока все контейнеры поднимутся, потому что он не может рассчитывать на то, что какой-то контейнер в каком-то состоянии, который считается поднятым, для этого уже нужна какая-то более высокоуровневая магия, и такая магия есть, Application Test Service предоставляет вам прекрасный сервис, который называется Resource Notification Service, и с помощью этого Resource Notification Service вы можете дождаться того компонента, который вам нужен, допустим если мы хотим дождаться фронт-энда, который у нас объявлен с именем фронт-энд в нашем Aspire настройке, мы можем у Resource Notification вызвать метод WaitForResourceAsync, передать ему в качестве названия, название компонента, то есть фронт-энд, и передать, чего мы ждем, мы ждем статуса Running, также можно указать Timeout, через которое наш тест отвалится, если вдруг мы не дождались пока наш фронт-энд поднимется, но надо понимать, что там Node.js обычно какой-нибудь, еще там Angular, еще там немножко разбами, это все React, это может продыматься больше чем 30 секунд вообще без проблем, в общем задаем Timeout, и если мы уложились, Timeout прошел, компонент поднялся, мы его дождались, то как раз этот Resource Notification освободит нам UTX, и мы пройдем дальше, то есть после того, как Resource Notification вернул управление, мы уже можем обращаться ко всем компонентам так, как привыкли, ну например, мы можем взять у нашего тест хоста, и попросить у него создать HTTP Client, и в качестве имени этого HTTP Client мы можем передать имя компонента, допустим фронт-энда, чем это хорошо, да, почему не создавать HTTP Client и стандартный HTTP Client Factory, потому что как только мы просим у тестового хоста, HTTP Client, он нам использует сервис Discovery, то есть нам не нужно знать, на каком порту запустился этот контейнер, или по какому адресу, нам нужно знать всего лишь на все имя компонента, то за что мы так все любим Aspire, то есть мы отдадим ему имя компонента, там отработает сервис Discovery, и вернется нам уже полностью настроенный HTTP Client, с помощью которого мы можем обратиться, допустим, к главной страничке и проверить, что результат нашего обращения был успешным, или если вам даже нужно, можно там распарсить боди, проверить, что там в этом боди содержится, таким образом мы завершаем последнюю секцию assert, мы завершаем наш интеграционный тест, то есть мы прекрасно знаем, как обратиться к ресурсу, который уже работает и что дальше с его результатом сделать.
628.62 672.14 "Анатолий Кулаков" Естественно, я описал вот это создание все в одном методе, естественно, его не нужно запускать в каждом методе, потому что Aspire подымает кучу различных компонентов, докер-контейнеров и так далее, вам это нужно всего лишь на все, за всю тестовую сессию поднять один раз и дальше уже использовать те HTTP Client, которые будут ходить к единственно поднятому тестовому контейнеру, к выполненному даже Aspire кластеру вот этому, вот, и таким образом писать интеграционные тесты, я думаю, те, кто из вас, кто раньше писал интеграционные тесты полностью понимают, какая инфраструктура здесь нужна, единственное, что нам помогает, это вот этот волшебный пакетик, который теперь подымает не просто одно Aspire-приложение, как мы тестировали раньше, а способен поднять целую пачку настроенных, взаимосвязанных Aspire-компонентов.
672.14 700.26 "Анатолий Кулаков" Теперь еще один интересный вопрос здесь у нас встает, а как же тест-контейнеры, потому что, по сути, тест-контейнеры выполняли вот эту функцию, то есть выполняли наши end-to-end тесты, то есть они были источником, они были фреймворком, с помощью которых мы писали вот эти end-to-end тесты для наших приложений, и нужно признать, что это довольно хороший, проверенный и стабильно работающий фреймворк, то есть он много где использовался.
700.26 704.02 "Анатолий Кулаков" Насколько Aspire залез на грядку тест-контейнеров?
704.02 807.46 "Анатолий Кулаков" Мне кажется, что залез вам достаточно хорошо, то есть если у вас действительно есть инструмент, с помощью которого вы можете описать композицию всех ваших проектов, то есть вы выкидываете Docker Compose, по сути, отсюда, дальше у вас есть инструмент, который способен вам тем же самым описанием сделать тесты, то вы вполне можете выкинуть из вашего портфеля разработчика и тест-контейнеры тоже, и плюс, Aspire дает еще третий плюс, с помощью него вы можете локально отлаживаться, то есть вы с помощью него можете локально поднять все эти зависимости и запустить уже под студией все ваши компоненты, которые есть в системе, то есть Aspire вот эти три ключевых точки с собой закрывает, локальная отладка, локальный запуск нескольких контейнеров и тестирование всего этого кластера, и плюс разворачивание, то есть на основании Aspire вы можете построить себе некий выхлоп, который поможет развернуть ваш кластер в кубернетисе, в ашури еще там где-то, ну в общем на основании вот этого единого описания вы можете еще и построить описание для продакшена развертывания, вот эти три точки, в принципе, Aspire себой хорошо и прекрасно закрывает, и соответственно выдавливает отсюда те инструменты, которые мы раньше могли может быть в них использовать, вот так вот Aspire залазит на чужую нишу и прекрасно там себя чувствует, поэтому если вы вдруг интересовались, а как же с помощью Aspire можно тестировать все эти компоненты, писать интеграционные end-to-end тесты, то вот вам отличная статейка, можете попробовать на своих приложениях, посмотреть что получится.
807.46 841.50 "Игорь Лабутин" Действительно выглядит удобно, особенно то, что не надо порты разгребать, все само за тебя, можно будет и попробовать. Пойдем дальше. Дальше у меня довольно редкая для нашего подкаста, ну то есть давно у нас не было таких статей, а именно внутрянка Frozen Dictionary, значит очень хорошая статья, которая рассказывает про то, а как же устроен Frozen Dictionary внутри и почему он такой особенный, интересный, и вообще зачем его придумали. Сначала
841.50 853.86 "Анатолий Кулаков" давайте... Слушай, я тебя даже немножко для начала поправлю, потому что это не просто статья про Frozen Dictionary, это, наверное, первый за несколько лет статья из Хаббра, то есть может Хаббр уже становится тортом?
853.86 857.02 "Игорь Лабутин" Кстати, да, я действительно давно не помню статьи, чтобы
857.02 865.58 "Анатолий Кулаков" мы обозревали из Хаббра. Да, не думайте, мы Хаббр читаем, мы его проверяем, но там реально мало что стоит нашего внимания, но вот это в принципе золотой
865.58 929.30 "Игорь Лабутин" самородок. Да, все так, спасибо автору. Значит, давайте напомним вообще что такое Frozen Dictionary. Это read-only словарь, то есть словарь только для чтения. И опытный дотнетчик конечно же задастся вопросом, а зачем нам еще один словарь, у нас же есть read-only dictionary, такой класс, который давным-давно с нами, он только для чтения и все замечательно. Проблема в том, что read-only dictionary, во-первых, это просто обертка для чтения над обычным словарем, то есть он буквально внутри содержит ссылочку на другой словарь, на какой-нибудь iDictionary и просто преопределяет все методы словаря и во всех методах, которые хоть как-то модифицируют словарь, он будет кидать исключения. То есть он не позволяет через себя менять, но во-первых, он не запрещает менять внутренний словарь, если у вас осталась ссылка на него, а во-вторых, все-таки это просто обертка. Frozen Dictionary был придуман для того, чтобы более эффективно читать из словаря, перекладывая сложность на момент создания.
929.30 942.74 "Игорь Лабутин" То есть если мы знаем фиксированный набор содержимого словаря, то можно таким образом оптимизировать создание, чтобы чтение стало супер-быстрым. И вот про это мы и поговорим.
942.74 983.58 "Игорь Лабутин" Сам по себе Frozen Dictionary - это абстрактный класс и у него есть, ну, грубо говоря, 18 реализаций разных на данный момент. И технически их может быть еще больше, потому что идея заключается в том, что вы создаете ваш словарь через статический метод FrozenDictionary.createFromDictionary, передаете туда некоторый обычный словарь, и вот этот вот метод, он смотрит на значения и ключи этого словаря, и на основании типа и набора значений, и количества значений этого ключа, выбирает разные алгоритмы того, как он будет формировать внутренний Frozen словарь.
983.58 1088.18 "Игорь Лабутин" И именно поэтому сейчас вот есть 18 этих алгоритмов, которые позволяют как-то по-разному составлять внутренний словарь. Но можно придумать еще больше, если будет зачем-то нужно. Все эти 18 реализаций делятся на самом деле на 11 групп, ой, на 11, чё я говорю, на 5 групп. Всего на 5 групп. Если у вас, скажем так, просто обычный дефолтный словарь, то есть у него нет каких-то спецособенностей, про то, что такое спецособенности мы поговорим чуть дальше, то используется штука, внутри используется реализация под названием FrozenHashTable, ну что логично, да, во FrozenDictionary внутри лежит FrozenHashTable. Это довольно такая специфичная HashTable, с которой мы чуть дальше познакомимся. Если у вас ключик это int32, то используется тот же самый FrozenHashTable, но с звездочкой, у вас никогда не считается хэш, то есть если у вас ключ int32, то сам ключ является своим же хэшом, и поэтому FrozenHashTable работает прямо с ним напрямую. Еще одна группа это про строки. Если у вас строки ключи разной длины, то можно попытаться разложить их на разные бакеты подобно блочной сортировке. Если у вас просто строки, которые не влезают в эти самые бакеты, то там используется как раз один из 11 вариантов работы с OrdinalString. И наконец-таки, если у вас очень маленькие словарики, то там используется просто линейный поиск.
1088.18 1125.74 "Игорь Лабутин" Напомню как работает обычный словарь, самый обыкновенный наш Dictionary. Примерно как этого, наверное, ожидают на собеседованиях. Во-первых, мы берем ключ, вычисляем каким-то образом от него хэш-код. Желательно, конечно, чтобы хэш-код был уникальным, но могут быть коллизии, когда у вас несколько разных ключей, тем или иным способом посчитанный хэш получается одинаковый. По этому хэшу мы вычисляем индекс сущности под названием Bucket, то есть некоторая область, некоторая виртуальная область, куда складываются все ключи из одинакового хэш-кода.
1125.74 1319.46 "Игорь Лабутин" Дальше мы в этом Bucket смотрим, то куда показал индекс, потому что в обычной словарике это просто массив, то есть индекс массива. В Bucket сравниваем ключик, если ключ совпадает, то все хорошо, если ключ не совпадает, это та самая коллизия, либо, возможно, ключ отсутствует в словаре, и тогда есть специальный алгоритм, как мы найдем следующий элемент в этом Bucket. Идем туда, проверяем ключ и так далее, пока у нас не закончатся элементы в Bucket. Как только закончились, значит ключ не найден, либо мы встретим нужный ключ. В FrozenHashTable работает немножко по-другому. Во-первых, за счет того, что мы создаем словарь сразу из готового словаря, у нас фиксированное количество пар ключ-значений, то у нас никогда не будет происходить добавление или удаление, мы можем сразу подобрать нужное количество Bucket, причем эта константа сейчас в коде, подбирается количество Bucket так, чтобы коллизий между ключами было меньше, чем 5% от общего объема ключей. Пока это так написано в коде, прямо если посмотреть на GitHub. Дальше. Ключи и значения можно размещать последовательно, без каких-то хитрых алгоритмов поиска следующего пустого элемента для Bucket в случае коллизий, то есть если есть коллизии, ну не вопрос, ключики будут лежать просто друг за другом. И тогда логика работы с такой уже HashTable будет немножко другой. Вычисляем хэш-код, ну тут как бы никуда не деться, другое дело что хэш-код может быть очень хитрым, мы про это поговорим чуть дальше в разных случаях, какой он будет. Считаем индекс Bucket, ну по хэш-коду тут вопросов нету. Дальше мы получаем для этого Bucket, поскольку все ключи в одном Bucket лежат последовательно друг за другом, то мы можем сразу получить начал и конечный индексы, ну и собственно линейно итерируемся от начала до конца Bucket, находим ключик. Если нашли возвращаем, если не нашли, ну значит все, такого ключа нет. То есть гораздо более оптимальный в том плане, что в случае коллизий особенно, потому что все ключи лежат рядышком и скорее всего будут где-то рядом в памяти. А вот теперь к этим самым 5 группам. Если у вас просто самый обыкновенный FrozenDiction, который не попал ни в какую категорию, тут все будет как обычно, хэши считаются как обычно, обычной хэш-функцией, хэш-код на объектах, как все у нас положено и складываются, как я сказал, в массив. Единственное различие от обычного словаря, что складываются линейно все коллизии и очень интересный получился результат бенчмарка. Если у нас размер словаря меньше чем 1000 примерно элементов, ну конкретно в бенчмарке, на конкретном железе, где я автор проверял, то внезапно такой FrozenDictionary на value-тайпах обязательно, то есть это проявляется только на value-тайпах почему-то, он медленнее, чем обычный dictionary. Не намного, но медленнее.
1319.46 1334.90 "Игорь Лабутин" Автор предполагает, что скорее всего это связано с какими-нибудь там оптимизациями джета, который распознает тонкости доступа к обычному dictionary и что-то там умудряется сооптимизировать, но вот такой вот интересный результат.
1334.90 1338.10 "Игорь Лабутин" А в других случаях… Ну то есть есть надежда, что
1338.10 1340.98 "Анатолий Кулаков" в будущем прооптимизируют для Frozen тоже?
1340.98 1358.94 "Игорь Лабутин" Да, да. Но может быть мы не знаем на самом деле статистики, насколько часто мы попадаем вот в этот value-тайп FrozenDictionary вариант. То есть насколько часто у тебя кастомный value-тайп является ключом. Возможно это не такая частая ситуация. Да-да, скорее всего, да, какая-то редкая.
1358.94 1416.46 "Игорь Лабутин" Вот. А во всех остальных случаях, если мы попали в обычный дефолтный FrozenDictionary с объектами в виде ключей, на которых стандартно считается хэш-код, то примерно плюс минус на 30% быстрее получается в FrozenDictionary чтение, чем в обычном dictionary за счет как раз оптимизации коллизий и оптимизации поиска линейного. Если у нас ключик просто int32, тут все ускоряется еще больше, потому что хэш можно уже не считать. Мы сразу по int2 можем вычислить индекс бакета, ну просто взяв там остаток отделения либо еще что-нибудь, и чтение получается быстрее где-то от 34 до 42%, в зависимости от размеров там массивов и типа ключей. Ну, как бы ожидаемо. Не очень интересный кейс. Следующий кейс интересный. Если у нас ключ - это строка.
1416.46 1468.06 "Игорь Лабутин" И вот тут начинается самое интересное. Сначала алгоритм делает следующее. Алгоритм берет и все ключи и строчки пытается поделить на бакеты по длине строк. Ну, то есть грубо говоря, все строчки одинаковой длины попадаются в бакет. В один. Но есть одно условие. В бакете может быть не больше пяти строк. То есть, грубо говоря, если у тебя есть словарик, в котором есть три ключа длиной 3, три ключа длиной 2 и пять ключей длиной 5, все хорошо, они попадут в три бакета. С длиной 2, с длиной 3 и с длиной 5. А вот если у тебя есть словарик, где у тебя 6 строк длиной 5 и 6 строк длиной 6, то вот этот алгоритм уже отвалится и работать не будет. Наверное,
1468.06 1470.18 "Анатолий Кулаков" константа 5 тоже выведена с помощью искусственного
1470.18 1507.38 "Игорь Лабутин" интеллекта? Наверняка. Это действительно константа в коде. Сказано, что получается иначе очень неэффективно по памяти. Сейчас я к этому дойду. Почему? Потому что там немножко интересно раскладывается. Как все это работает? Поскольку у нас известна длина всех ключей известна, то мы не создаем три отдельных бакета. То есть у нас нет бакета номер один для коротких ключей, потом бакет номер два для длинных ключей.
1507.38 1521.82 "Игорь Лабутин" Тут делается все проще. Мы храним все бакеты, все ключи в одном массиве длиной, максимальная длина ключа попавшегося умножить на количество этих бакетов.
1521.82 1550.74 "Игорь Лабутин" Грубо говоря, если у нас есть строчка длиной 6 и строчка длиной 4, и таковых у нас каждый по одной штуке, то есть у нас такой словарик, нет, не по одной. Давайте у нас строчки длиной 2, у нас одна строчка, строчка длиной 6, у нас две строчки, то такой словарик будет содержать всего 4 элемента в бакетах, насколько я понимаю.
1550.74 1621.66 "Игорь Лабутин" Несмотря на то, что с короткой строчки у нас одна, в бакете нам будет 2 элемента, сделано это для того, чтобы как можно быстрее считать индекс. То есть просто длина ключа, вычитаем минимальную длину ключа, умножаем на размер это количество строчек на каждую длину и из этого можно легко посчитать индекс. А дальше опять же тупо линейный поиск по ключам. То есть опять никаких хэш-кодов, ничего считать не надо, просто по длине исходной строчки считаем номер бакета и в нем линейным поиском и возвращаем значение. Для того, чтобы все это очень эффективно работало, нужно чтобы мы не сожрали всю память для этого. Это конечно очень эффективная система хранения, когда максимальное число ключиков в бакете умножаем на количество бакетов, но если таких бакетов будет пусто, то есть в моем примере на самом деле внимательный слушатель мог бы сказать, что я не прав. Если у тебя строчка длиной 2 и строчка длиной 6, а ты хочешь считать индекс как просто длина строки минус минимальная длина строки умножить на количество строк, то тебе нужно иметь бакеты для 2, для 3, для 4, для 5 и для 6.
1621.66 1643.70 "Игорь Лабутин" Они будут все пустые, кроме первого и последнего. А иначе вот эта магия с индексами работать не будет. И вот если таких бакетов пустых становится больше чем 20%, то этот алгоритм опять же не работает и переключаемся на следующий Ordinal String, про который я чуть позднее расскажу.
1643.70 1739.94 "Игорь Лабутин" В целом по перформансу получается, поскольку вообще единственная операция, которая здесь делается сложная, это взятие длины строки, ну сложная в кавычках, а это быстрая операция в дотнете, то по бенчмаркам там как бы чтение условно говоря на 99% быстрее, потому что по сути там взять длину строки, пару математических операций и небольшой линейный поиск в массиве не более 5 элементов. Ну как бы это прям супер быстро. Но если у вас количество вот этих вот ключей с одинаковой длиной уже ближе к пятерке, и в каждой длине их много, то в среднем понятно, что будет немножко хуже становиться, но все равно это все гораздо быстрее. То есть если у вас какие-то маленькие словарики с относительно разными длинами ключей, то может быть при этом все довольно равномерно распределено по длинам, то может быть это хороший вариант и явно алгоритм на это заточен, потому что видимо такие варианты есть. Если этот алгоритм не прокатил, то переходим к алгоритму OrdinalString. Тут все просто, есть специальный класс, называется KeyAnalyzer, который пытается выбрать один из 11 алгоритмов. Как он это делает? Делает он довольно сложно, на результат влияет довольно много характеристик. Во-первых, влияет длина ключей, влияет наличие не скишных символов, влияют правила сравнения строк, типа case-insensitive, case-sensitive, ordinal, не ordinal и так далее, и влияет наличие в ключах уникальных подстрок.
1739.94 1761.26 "Игорь Лабутин" В целом, чем длиннее строка, тем хэш-код будет считаться медленнее. Поэтому первым делом, что пытается сделать KeyAnalyzer, это пытается в переданном наборе ключей найти подстроки наименьшей длины, которые позволят однозначно идентифицировать ключ. То есть, что он делает?
1761.26 1791.50 "Игорь Лабутин" Он берет все ключи, грубо говоря, выравнивает их налево, ну то есть, берет первый символ всех и смотрит, а получился ли уникальный. То есть, если у нас такой уникальный набор ключей, где у них у всех первая буква разная, то это означает, что когда к вам придет потом следующее чтение словарик по ключу, можно будет просто взять первую букву этого ключа, это будет ее хэшун, по нему по этой букве быстро найти бакет, сравнить с ключом, который там лежит, если совпало, хорошо, если не совпало, значит ключ не найден. Все.
1791.50 1802.50 "Игорь Лабутин" Быстро, просто, легко. Проблема в том, что довольно много, ну, редкое количество словарей пишутся с такими ключами, так чтобы у вас была абсолютно разлетяющаяся первая буква.
1802.50 1825.90 "Игорь Лабутин" Поэтому если с первой буквы не прокатило, берем вторую букву, потом третью, ну и так далее, потихонечку двигаемся вправо по строчке, пока не найдем. И если не нашли, то делаем то же самое с правым выравниванием, то есть берем последние буквы, и идем обратно по строчке, тоже пока не, ну, очевидно идем до самого короткого ключа, до длины самого короткого ключа.
1825.90 1908.42 "Игорь Лабутин" Если это не прокатило, то берем по два символа, и тоже начинаем с первой колонки, ходить по строчкам по всем ключам, смотреть уникально они или не уникально вот эти подстроки по два символа. То же самое с правой, ну и так далее, потом три символа, четыре символа и вплоть до восьми, то есть максимальная длина подстроки по которой смотрится это восемь. Если что-то нашлось, то есть если нашлась комбинация некоторого смещения в строке, либо справа в строке, либо с конца строки, и длины вот этой подстроки, в которой у вас ключи уникальны, то фактически словарик этот frozen hash запомнит эти два параметра, после чего будет его применять ко всем входящим ключам при поиске. То есть если же таких уникальных не найдено под строк, то есть у вас все строки абсолютно одинаковы, ну не абсолютно одинаковы, они такие, что у вас не нашлось уникальной подстроки на все ваши ключи длиной не более восьми символов, то тогда, ну, фолбетчимся насчитать хэша полной строки. С поиском, да, ну и варианты всех этих алгоритмов, это как раз таки зависит от всякого comparison, то есть понятно, что уникальность можно считать с учетом, регистры без учета, регистры, ну и вот этого всего. Соответственно, из-за этого там несколько алгоритмов получается. При поиске делается следующее.
1908.42 2011.46 "Игорь Лабутин" Первое. Проверяем, находится ли длина ключа в нужном диапазоне. То есть мы знаем все ключи, и поэтому если к нам пришел ключ заведомо слишком короткий или слишком длинный, так сразу откинуть. Если подходящей длины кажется, что мы помним, где мы находили уникальную подстрочку, находим ее в ключе, считаем от нее хэш, идем в нужный бакет, находим, ну и так далее. Вот, все просто и легко. Значит, что касается бенчмарков, если у вас, вот в конкретных бенчмарках автора получилось следующее. Если у вас меньше семидесяти пяти тысяч элементов, то такой словарь будет быстрее, чем обычный dictionary. Но при дальнейшем увеличении скорость поиска начинает снижаться. Ну, скорость, понятно, почему, потому что хэш-код считается существенно быстрее. То есть самая дорогая операция при поиске по строкам — это подсчет хэш-кода. И понятно, что если вы считаете по подстроке длиной не более восьми символов, то это, конечно, супербыстро и хорошо. Но если такого не происходит, либо если у вас строчек становится настолько много, что, ну, больше семидесяти пяти тысяч, то просто становится сложно найти суперуникальную строку длиной восемь символов. И начинают появляться коллизии, а мы помним, что frozen dictionary пытается собраться так, чтобы коллизий было меньше пяти процентов. То есть у вас и количество бакетов будет увеличиваться и так далее. И, в общем, если у вас ключи попадаются такие, что у вас не получается на этих коротких подстроках сделать количество коллизий меньше пяти процентов, то будут полные хэш-коды считаться тогда. А тут тогда уже особой перформанса-то и не будет.
2011.46 2015.50 "Анатолий Кулаков" Значит, он должен быть немедленнее? Он должен как минимум фолбетчиться
2015.50 2038.58 "Игорь Лабутин" на скорость обычного dictionary? Да-да-да-да. То есть написано, что алгоритм в целом, даже если он фолбетчится, получается где-то на семьдесят пять тиры девяносто процентов быстрее обычного. За счет линейности. Не забываем, что там еще ключики раскладываются линейно, и если есть коллизии, тебе не нужно бегать по разным кускам памяти. Потому что в обычном dictionary ты не гарантируешь, что ты пойдешь в соседнюю ячейку массива, если у тебя коллизия.
2038.58 2054.98 "Игорь Лабутин" Вот. А здесь… Да-да-да, вот тут уже похоже на правду, это уже хорошо. Да, то есть он чуть-чуть быстрее будет в любом случае, сильно тормозить не будет, но прям буста такого, что там на пятьдесят процентов быстрее, вы на больших массивах не получите. На больших словарях. Но семьдесят пять тысяч элементов в словаре
2054.98 2057.94 "Анатолий Кулаков" — это прям уже немало, на самом деле. Для frozen.
2057.94 2073.30 "Анатолий Кулаков" Не, ну просится. Такое поведение дает понятный алгоритм действия. Просто по умолчанию, если вы можете, если ваша стратегия подразумевает… Просто по умолчанию можно всегда использовать frozen dictionary, и никогда вы с ним минусов не найдете по сравнению с обычным dictionary.
2073.30 2080.10 "Игорь Лабутин" Нет, есть проблемы, то есть зависит от того, как часто вы его перестраиваете. То есть надо понимать, что эта штука довольно дорогая в построении. Построение
2080.10 2089.78 "Анатолий Кулаков" не бесплатное. Да, да. Это я и сказал, что если ваша стратегия подразумевает, то есть если вы один раз его делаете. Да. Еще одно количество раз. Если вы
2089.78 2103.34 "Игорь Лабутин" не перестраиваете часто. Да, если вы его действительно перестраиваете, там какие-нибудь справочники какие-то или что-то редко меняющееся, может быть, имеет смысл запихнуть это во frozen dictionary и посмотреть, побенчить, что получится. Скорее всего, получится лучше.
2103.34 2118.70 "Игорь Лабутин" И последний кейс — это небольшие словари. То есть в разных кейсах по разному для разных типов где-то считается меньше 10 элементов, где-то меньше 4 элементов. Это считается небольшим словарем, ну либо равно, 4 или меньше.
2118.70 2137.74 "Игорь Лабутин" Дальше там есть некоторые микрооптимизации. Если ключ — это встроенный примитивный тип, int, long, еще кто-нибудь, и значения внезапно мало, то самое быстрое — это на самом деле сортировать ключ в ключе и сделать простой линейный поиск по отсортированному массиву.
2137.74 2191.98 "Игорь Лабутин" Благо он коротенький, будет быстрее. Причем для сортированных бонус в том, что если вы добежали до элемента, который, например, больше искомого, то это значит, что его уже точно нет и все, можно прекращать. Но при этом для таких маленьких классов, уже маленьких словарей, выигрыш там буквально какие-то доли процента, вернее в процентах это может быть и много, но это доли на секунд, и поэтому особо выигрыша тут нет. Тут можно только успокаивать себя тем, что если вы строите frozen dictionary и, например, вы не знаете, сколько там будет элементов, то в случае, если там окажется внезапно мало элементов, ничего страшного не будет. Я так понимаю, что скорее всего для этого это и было сделано. Чтобы если случайно оказалось мало элементов, то вся эта сложная машинерия с хэшкодами, бакетами и прочим ничего не усугубляла, вы просто линейным поиском быстренько нашлись и все.
2191.98 2206.70 "Игорь Лабутин" Вот такие дела с frozen dictionary, так что, ну, Толя уже сказал основную мысль. Действительно, рассмотрите эту структуру, этот класс, если вы редко перестраиваете какие-то словарики, она может оказаться действительно очень полезной
2206.70 2229.34 "Анатолий Кулаков" для ускорения чтения. Ну да, мне кажется, таких случаев довольно много. Скорее всего, если каждый задумается, то все в приложении найдет несколько таких мест. Пойдем посмотрим, что у нас еще есть. Тут у нас статейчика, на которую мы решили хайпануть. Ну, то есть у нас тут все рассказывают про искусственный интеллект, и мы тоже с вами сейчас обсудим искусственный интеллект.
2229.34 2315.86 "Анатолий Кулаков" Ну, если быть точным, то, конечно же, большие языковые модели и, конечно же, на примере C#, потому что иначе зачем нам другие. Другие нам неинтересны. Разберемся мы со статьей, которая называется "Как запустить большую языковую модель на подобие ChubJPT локально, с помощью C# и вашего локального компьютера". Ну, потому что ChubJPT в облаке уже никого не удивишь, а хочется все-таки локально что-то позапускать. И хочется, чтобы люди все-таки осознавали и понимали, как это делается. И не просто позапускать с помощью какого-то стороннего приложения из-за родного C# кода. И, может быть, даже встроить его в свою программу, чтобы для того, чтобы у вас там появился какой-то интеллектуальный ассистент, который может что-то подсказывать в реальном времени или что-то еще делать, и при этом не зависеть от таких облаков. Вот подобные заданицы мы сейчас с вами и рассмотрим. Итак, как же мы вообще пришли к этому шагу? Ну, пришли мы прежде всего потому, что искусственный интеллект - это уже становится не только удел каких-то лабораторий, замкнутых в себе, не только каких-то клаудных серверов, но и наука нашла настолько, что мы можем даже уже запускать большие языковые модели на локальных компьютерах. Естественно, с различной степенью успешности, с различной степенью производительности, но все же сам факт, что мы сюда пришли, на это место уже говорит о многом и довольно многообещающе.
2315.86 2332.18 "Анатолий Кулаков" То есть, в будущем это будет становиться все легче и легче. Сейчас многие модели даже можно запустить на телефончиках, в общем, не говоря уже о каких-то нормальных десктопах или нормальных лаптопах. И делать мы это будем с помощью библиотечки, которая называется LLamaSharp.
2332.18 2430.98 "Анатолий Кулаков" Это штука, которая как раз и позволяет запускать Large Language модель, большие языковые модели, LLM, простонародье, в принципе, если большие языковые модели, это получается BAM, да. Которая может запускать BAM-ы ваши, на которые наподобие CHUBJPT локально и на C#. Что же такое LLamaSharp? Это open source проект, который кроссплатформенный и который запускает модели формата LLama и LLava, ну также много других разных. Запускает это на вашем локальном девайсе, как уже было сказано, поддерживает CPU и GPU, в зависимости от того, что там у вас есть, он выберет максимально, вы для него должны указать и выбрать ему максимально производительное железо, которое он должен использовать. И на самом деле это все является C#-оберткой над C++ библиотекой, которая называется LLama.cpp. Это очень популярная библиотека, там заплюсованная, расхапованная, у нее огромное число поддерживаемых форматов, у нее огромное число контрибьюторов, она растет, куча оберток для нее есть, в частности мы рассмотрим все шарповые сегодня. В общем, крутая хорошая либа, крутая хорошая обертка, не грех и посмотреть и может быть даже и поиспользовать. Это библиотека, у нее есть очень много API, в частности она поддерживает такие концепции, как историю чатов, такие как запросы промты, такие как блокирующие листы, такие как антипромт.
2430.98 2442.22 "Анатолий Кулаков" Она поддерживает сессии в чатах и т.д. Оперирует довольно высокоуровневыми концепциями, которые в каждом уважающем себя чат-боте должны присутствовать.
2442.22 2459.86 "Анатолий Кулаков" Как же запустить эту штуку? Давайте разберемся с технической частью. Во-первых, нам нужно поставить LLamaSharp в библиотеку, для этого можно создать стандартное консольное приложение, добавляем пакет, который называется LLamaSharp и дальше у нас есть первая необычность, первая сложность.
2459.86 2468.50 "Анатолий Кулаков" Мы не просто поставили пакет, а что-то теперь еще надо сделать. Дальше нам нужно выбрать бэкэнд, с которым мы будем работать, так называемый бэкэнд.
2468.50 2543.62 "Анатолий Кулаков" Это как раз таки та C++ библиотека, которая будет являться основным источником всей инженерии. Что мы здесь можем выбрать? А выбрать мы можем то, на каком железе она будет работать. У нас есть варианты на CPU, это подойдет каждому, но будет работать медленнее, а если у вас есть хорошая видеокарточка, то скорее всего для вас будут интересны другие варианты. Это CUDA11, CUDA12 или Vulkan. После того, как мы определились с тем, какой бэкэнд мы будем ставить, то точно так же делаем .NET Add Package и вызываем LLamaSharp CPU, допустим. И таким образом мы ставим вот эти две зависимости. После этого все, что нам нужно для работы с большими языковыми моделями на нашем локальном компьютере, оно установлено и готово к работе. Теперь перед нами стоит задача, а где же взять собственно эту модель, которая большая, которая совсем языковая. И перед тем, как мы ее хотим где-то взять, нам нужно определиться, какую модель мы хотим. Потому что на самом деле в мире сейчас развелось тысячи сотни и миллион этих моделей. Практически каждый, кому не лень, сейчас генерирует свою. Поэтому если вы зададитесь целью выбрать какую-то хорошую модельку, вы должны очень много всего учитывать. Ну, во-первых, производительность.
2543.62 2560.58 "Анатолий Кулаков" Не забывайте, мы все-таки на локальном компьютере запускаемся. Не у всех есть самые последние инвидиевские карты в количестве не менее 100 штук. Поэтому перформанс - это первое, о чем вам нужно определиться. У всех моделей разная производительность. Второе, что влияет - это память. Все модели жрут разное количество памяти.
2560.58 2566.38 "Анатолий Кулаков" Есть большие, есть поменьше и так далее. Немаловажным фактом также является так называемая стабильность.
2566.38 2616.18 "Анатолий Кулаков" Это то, с каким уровнем модель начинает галлюцинировать или отклоняться от темы. Отклоняется от того промта, о котором вы спросили. Ну и также важно, на каких данных была натренирована модель. Что используется в качестве основ для ее обучения. Определившись со всеми этими факторами, вы можете из огромного списка моделей выбрать та, которая вам больше всего подходит. Если вы как-то еще метаетесь среди непонятного чего выбрать, то на официальном сайте этой библиотечки есть рекомендованные модели, которые в принципе ведут себя хорошо, там жрут мало и там какой-то понятный список есть. Допустим, автор статьи выбрал модель, которая называется Fi2. Такая, хорошая, средненькая модель, приличная и все такое. Почему бы ее не использовать для наших тестов, для наших экспериментов. После того, как вы модель выбрали, вам нужно решить, где ее взять.
2616.18 2736.62 "Анатолий Кулаков" В общем, и откуда вам ее скачать. Есть такой прекрасный сайт, который называется Hugging Face. Это сайт, на котором можно поискать различные модели. Там можно найти уже натренированные готовые модели. Это такой своеобразный онлайн репозиторий. Не только для моделей, а вообще для разных проектов, которые каким-то образом связаны с машинным обучением. Там много всего есть интересного, ну и в частности можно уже взять обученные модели оттуда скачать. Он предоставляет множество сервисов. В сервисах в частности можно потренировать модель, можно и поизменять уже натренированную модель. И, например, там есть полезные какие-то утилиты. Может быть вам понадобится утилита, которая умеет конвертировать гигуф-модели. То есть это такой формат специальной модели, который довольно распространен, довольно современен. Она может конвертировать другие модели из каких-то разных других или старых форматов в этот формат гигуфа, который как раз нам и подходит. То есть мы определились с форматом модели нам нужен гигуф, мы определились с самой, с названием модели нам нужен фи-2. Все. Дальше после этого у нас есть достаточно информации для того, чтобы на Hugging Face найти эту модельку и скачать ее. Но как только мы ее находим, у нас появляется еще один критерий выбора, который называется метод квантования. И как раз метод квантования это технический способ в машинном обучении, который позволяет вам уменьшить или увеличить размер модели и уменьшить и увеличить ее подремляемые ресурсы и в зависимости от ее точности. То есть вы варьируете вот этими факторами. Вы можете, например, уменьшить размер, вы можете увеличить скорость, но при этом пострадает точность модели. Или же наоборот. Дать больше размера, уменьшить скорость ответа, сделать так, чтобы модель отвечала вам дольше, короче. И тогда точность модели будет лучше.
2736.62 2812.34 "Анатолий Кулаков" Вот этими параметрами можно играться. Так, после того, как вы выяснили для себя метод квантования, то все, в принципе вы готовы к тому, чтобы скачать файлик на свой локальный компьютер, который и будет являться той самой моделью. Итак, что же у нас есть? У нас есть консольное приложение. В этом консольном приложении установлен пакет SelamaSharp. Мы определились с моделью, которую мы хотим и мы эту модель скачали на локальный компьютер. Дальше уже пошла C# код. Все просто. Мы оперируем довольно высокоуровневыми понятиями, никакими байтиками читать не надо. У нас есть SelamaWeights, мы можем загрузить из файла ту модель, которую скачали, просто передав путь к файлу. Мы можем создать контекст, в котором будет оперироваться наша модель. Также у нас, например, есть классик удобный, который называется ChatHistory. Это всего лишь навсего история сообщений, которая будет обмениваться с моделью. У каждого элемента этой истории есть не только сам месседж, не только сам текст сообщения, но и то, от чьего лица это сообщение было сказано. Это может быть там система, пользователь, ассистент или еще кто-то.
2812.34 2823.54 "Анатолий Кулаков" И указав, кто говорил то или иное сообщение, мы можем заполнить такой классик как ChatHistory, то есть заполнить историю, с помощью которой мы будем дальше работать.
2823.54 2834.54 "Анатолий Кулаков" Дальше у нас есть такая концепция как ChatSession, и уже зная ChatSession, мы можем уже общаться с нашей моделью.
2834.54 2856.18 "Анатолий Кулаков" Как это происходит? Просто создайте бесконечный цикл, например, мы будем на основе консольного приложения, который представляет собой обычный чатик, то есть запускаем бесконечный цикл, считываем от пользователя фразу, на основании этой фразы создаем сообщение, запускаем это сообщение в сессию, и сессия нам возвращает некий текст.
2856.18 2858.34 "Анатолий Кулаков" Этот текст мы просто-напросто показываем пользователю.
2858.34 2876.30 "Анатолий Кулаков" То есть, допустим, мы в истории подготовили какую-то прелюдию, то есть мы рассказали, что дорогая модель, ты являешься ассистентом, который обязан помогать пользователю, максимально вежливо, максимально точно отвечая на все вопросы и так далее и тому подобное, как обычно мы все это любим.
2876.30 2887.76 "Анатолий Кулаков" Сохранили это в истории, дальше запускаем в цикле пользовательский, считывание пользовательского ввода, что бы пользователь ни вел, какой бы просьбы он ни попросил, отдаем модели и просто-напросто возвращаем пользователю результат.
2887.76 2891.44 "Анатолий Кулаков" А что тут еще хочется сказать?
2891.44 2901.28 "Анатолий Кулаков" Ну, во-первых, нужно осознавать, что вот этот промпт, и в частности история, которую мы передали, это является очень важной частью вообще всей работы.
2901.28 2918.04 "Анатолий Кулаков" То есть здесь мы уже должны следить не за тем, какой красивый C#-код мы написали, какие best practices и шаблоны проектирования использовали, вот в данных программах нам очень важно следить о том, насколько мы хорошо настроили наш промпт, наш запрос.
2918.04 2920.36 "Анатолий Кулаков" Что значит хорошо?
2920.36 2941.36 "Анатолий Кулаков" Нет какого-то единого понятия, как хорошо настраивать запросы, но вы должны стараться выражать свои мысли как можно более четко, как можно более чисто, и если вы что-то хотите, то вам нужно конкретные желания свои высказывать, более специфичные инструкции давать.
2941.36 2956.00 "Анатолий Кулаков" И этот промпт может повлиять не только на качество выдаваемых вам ответов, которые вы получаете, но также точно и на перформанс, и на то, как пользователь будет себя чувствовать, то есть насколько пользователь будет с этой моделью понятно, удобно и приятно общаться.
2956.00 2961.60 "Анатолий Кулаков" То есть конфигурация пред-истории, вот эта прелюдия довольно важна.
2961.60 2969.76 "Анатолий Кулаков" В частности в этой модели приводится, то есть в этой статье приводится несколько запросов, с которыми можно поиграться на ФИ-2 и получить вполне адекватные ответы.
2969.76 2978.76 "Анатолий Кулаков" Ну например, пользователь попросил выдать топ-15 необходимых элементов, которые нужно приготовить во время урагана.
2978.76 2994.92 "Анатолий Кулаков" То есть что нам нужно во время урагана, и в принципе моделька довольно нормально ответила, то есть она сказала да, вот вам топ-15, водичка, аптечка первой помощи, фонарик, но иногда у нее попадаются вещи, которые не должны были бы, например, ходить в топ-15, например подгузники и детская присыпка.
2994.92 3003.60 "Анатолий Кулаков" Может быть, конечно, кто-то очень сильно боится урагана, поэтому ему нужны эти элементы, но все-таки это не общепринятый топ-15, допустим.
3003.60 3015.44 "Анатолий Кулаков" И вот это в простонародье галлюцинирование, вот эти фантазии, которые она выдает, это как раз и та вещь, которую нужно тюнить с помощью промта.
3015.44 3027.32 "Анатолий Кулаков" Ну или с помощью переобучения, если вы до этого уровня дошли, но пока мы находимся на том уровне, что пока у нас есть только промт, и именно с помощью строки и запроса мы можем это как-то подтюнивать, что-то здесь делать.
3027.32 3039.68 "Анатолий Кулаков" Также был пример, попросили этого ботика написать письмо боссу, который объясняет, что я сегодня заболел и не смогу прийти на работу, как можно более вежливое, красивое, объяснить, какая у меня температура.
3039.68 3046.10 "Анатолий Кулаков" То есть это был запрос на то, чтобы моделька как можно четче учитывала все те требования, которые ей отдали.
3046.10 3054.86 "Анатолий Кулаков" И судя по результату, требования действительно были все учтены, все, что просили, она сделала, создала хорошее и адекватное письмо, хоть бери и сразу пересылай.
3054.86 3062.12 "Анатолий Кулаков" В общем, в зависимости от ваших потребностей и от ваших нужд, вполне можно такую штуку настроить.
3062.12 3083.76 "Анатолий Кулаков" И самое интересное, это будет оффлайн модель, которая будет работать на вашем локальном компьютере, никак не зависит от интернета, с ней вы будете общаться с помощью C#, и все довольно хорошо, удобно, красиво и с помощью высокоуровневых примитивов, которые как раз таки помогут вам разобраться с этим довольно быстро и легко.
3083.76 3111.36 "Анатолий Кулаков" В конце, у нас как раз на днях я выложил запись с митапов SPB.net Дмитрия Нестерюка, у него был очень хороший доклад в эту тему, он назывался "Разработка с использованием искусственного интеллекта", поэтому если кому-то интересно вообще эта тема, и в частности программирование на C#, то этот доклад Дмитрия крайне рекомендуется ко просмотру.
3111.36 3122.48 "Анатолий Кулаков" Вот такое интересное будущее, вот такие вот интересные либо мы будем подключать, Игорь с тобой скоро вместо там всяких Blazer'ов, может быть Mayuy'ев, вот просто консольное приложение и говори, что ты хочешь.
3122.48 3145.72 "Игорь Лабутин" Не-не-не, надо, смотри, то есть мы сейчас там спорим про то, что там медиатор, не медиатор, да, вот у тебя есть там контроллеры, ты отправляешь, значит, в медиатор команду, там неизвестно, какой хендлер, а тут у тебя есть в каждом контроллере какой-нибудь там iservice.response и туда передай просто этот входящий JSON, она тебе сама что-нибудь придумает в ответ, круче медиатора.
3145.72 3151.80 "Анатолий Кулаков" Ну, в принципе, да, главное, зарплату не считать в таких сервисах, а все остальное, в принципе, горение огнем.
3151.80 3162.60 "Игорь Лабутин" Ну вот, типа того, давай продолжим, у нас еще немало статей, наверное, все мы сегодня не успеем, но какие-то мы, по крайней мере, еще сможем пробежаться.
3162.60 3183.84 "Игорь Лабутин" И, интересно, ну, не то, что это суперинтересная статья, хотя других у нас нет, конечно же, попалась мне, а именно разница между луковой и чистой архитектурой, которые, вообще говоря, многие путают и считают одними теми же, хотя у них два разных автора, у этих двух архитектур.
3183.84 3187.40 "Игорь Лабутин" Видимо, примерно одно и то же пришло в голову, и поэтому так получилось.
3187.40 3190.04 "Анатолий Кулаков" Да, это не мешает им быть одним и тем же.
3190.04 3206.88 "Игорь Лабутин" Ну, да, значит, но статья все-таки попыталась навести хоть какой-то порядок и расставить точки над "и", поэтому я расскажу, а вы, если что, приходите в комментах и говорите, что я не прав, и все понимаю не так, и вообще-то надо было рассказывать по-другому, и все это значит совсем другое.
3206.88 3207.88 "Игорь Лабутин" Но, тем не менее.
3207.88 3211.24 "Игорь Лабутин" Ну и вообще лучше приходить к автору статьи, а не к себе.
3211.24 3215.72 "Игорь Лабутин" Ну, ко мне тоже, придите ко мне, расскажите, в чем я не прав, я чего-нибудь научусь.
3215.72 3218.32 "Игорь Лабутин" Всегда полезно, когда тебе рассказывают, в чем ты не прав.
3218.32 3219.68 "Игорь Лабутин" Особенно, если из этого можно чего-нибудь научиться.
3219.68 3224.84 "Игорь Лабутин" Приносите ссылки на правильные статьи, где описана разница между ними, и мы их тоже рассмотрим.
3224.84 3227.88 "Игорь Лабутин" Ну, вообще, да, приносите больше ссылок.
3227.88 3229.64 "Игорь Лабутин" Да, да, да, это, кстати, всегда полезно.
3229.64 3237.36 "Игорь Лабутин" Луковая архитектура — это некоторая слоеная, можно сказать, архитектура, но слои в виде концентрических кругов.
3237.36 3253.80 "Игорь Лабутин" Придумана она была Джеффой Полермо, обычно рассматривается четыре слоя, самый внутренний — это доменный уровень, потом сервисный, и снаружи — инфраструктурный, и представления, они как бы сливаются воедино, то есть там и то, и другое вместе.
3253.80 3258.72 "Игорь Лабутин" В качестве представления это не обязательно UI, это могут быть всякие REST-контроллеры, и вот это все — это тоже представление.
3258.72 3261.96 "Игорь Лабутин" В смысле, любое, так скажем, взаимодействие с внешним миром вашей системы.
3261.96 3267.04 "Игорь Лабутин" Ну, а инфраструктурные — это какие-то базы данных, очереди, вот это все.
3267.04 3271.44 "Игорь Лабутин" Концептуально они на одном уровне, но технически все-таки обычно разные штуки.
3271.44 3287.12 "Игорь Лабутин" Внешние слои должны зависеть от внутренних, и вот в статье написано, что иногда, в общем, к луковой архитектуре также можно сказать, что относятся всякие порты адаптера и хексагональные, это, кажется, просто другие названия примерно похожие, концептуально похожие штуки.
3287.12 3291.76 "Игорь Лабутин" А вот чистая архитектура — это другое, вот, это не то же самое.
3291.76 3302.80 "Игорь Лабутин" Она тоже слоеная, у нее тоже есть доменный слой внутри, потом есть слои приложений, они же юзкейсы, потом инфраструктурные, представления, да, вот чувствуешь разницу, да?
3302.80 3303.80 "Игорь Лабутин" Совсем все по-другому.
3303.80 3304.80 "Игорь Лабутин" Нет?
3304.80 3455.62 "Игорь Лабутин" Да, зависимости все также направлены внутрь, в общем, написано в статье абсолютно то же самое, значит, но разница все-таки есть, значит, разница на самом деле в, кажется, по вот статье, я не буду сейчас детально рассказывать, но смысл такой, что разница вот в этом самом среднем слое в сервисах или он же слой приложения юзкейсов, как он в чистой архитектуре называется, то есть чистая архитектура, она больше про юзкейсы и про то, как как бы ваш домен используется, грубо говоря, то есть она больше сфокусирована не на самом домене, а на именно юзкейсах и довольно строго, ну как бы она более строгая с точки зрения того, что должно быть в среднем слое и более того, иногда там выделяют даже несколько подслоев, так скажем, вот, в то время как полуковая архитектура, она больше про, собственно, центральный доменный слой, про то, что ну где-то есть какие-то эти вот сервисы посередине, ну просто потому, что надо как-то это связываться с внешним слоем, ну в смысле не связываться, зависимости у нас нету из внутреннего слоя наружу, но тем не менее, какую-то логику писать надо, поэтому приходится этот сервисный слой делать, но как бы главная суть это все-таки доменный слой, доменная логика, все внутри, значит, этого доменного центрального круга, поэтому, значит, чистая архитектура, как написано в статье, она больше про всякие независимость бизнес-правил, правильное распределение юзкейсов, очень часто из-за этого она начинает потихонечку смещаться в сторону вертикал слайсов, когда у вас юзкейсы вообще принципиально разделены, да, весь код угруппирован по фичам, условно говоря, и вот это вот все, а логовая она вот, главное, про слои, главное, чтобы вы выделили домен, ну, сервисы, ну, как бы хорошо, ну и наружный слой, инфраструктурный, понятно, как бы не надо репозиторий тащить в домен, ну, типа, и нормальненько, вот, и дальше интересный пойнт в статье, значит, типа,
3455.62 3462.74 "Анатолий Кулаков" что выбрать, что выбрать… Погоди, а давай насчет разницы еще пообсудим, ну, то есть они же все равно не противоречат друг другу.
3462.74 3463.74 "Анатолий Кулаков" Они не противоречат, да, они не противоречат.
3463.74 3469.90 "Анатолий Кулаков" Там сервисы есть, здесь юзкейсы есть, но в юзкейсах больше напор, в сервисах меньше напор, ну, опять же, никакой противоречия нет.
3469.90 3484.22 "Игорь Лабутин" Противоречия нету, действительно, то есть здесь больше к тому, что, как бы, можно сказать, что чисто является под множеством луковой в том плане, что она более, ну, если следовать всем канонам того, что было написано в исходной статье.
3484.22 3499.78 "Анатолий Кулаков" Ну, и в обоих этих статьях, насколько я помню, в обоих изобретениях, в этих доменных архитектурах, насколько я помню, есть рекомендация, типа, максимально, что вы сможете, запихивайте в доменную, а остальное вы пихивайте наружу.
3499.78 3504.42 "Анатолий Кулаков" То есть нет такого, что в сервисной модели оставляйте больше логики, а доменную такую анимичную делайте.
3504.42 3505.42 "Анатолий Кулаков" То есть там нигде такого нету.
3505.42 3507.02 "Анатолий Кулаков" То есть максимально все равно пытаешься в доменную
3507.02 3508.02 "Игорь Лабутин" засунуть.
3508.02 3509.02 "Игорь Лабутин" Нет, такого нету.
3509.02 3514.14 "Игорь Лабутин" Максимально пытаешься, но в луковой, если я правильно помню, там нету почти ничего про то, как ваши сервисы строить.
3514.14 3519.34 "Игорь Лабутин" Ну, типа, вы как бы запихиваете все максимально в доменную, а сервисы, ну, нужны они, без них никак.
3519.34 3523.86 "Анатолий Кулаков" Ну, просто не рассматривали, потому что, наверное, слишком разрослась статья.
3523.86 3529.14 "Игорь Лабутин" Да, а вот в чистой там фокус прям такой на сервисном слое.
3529.14 3536.78 "Анатолий Кулаков" Ну, а по чистой там Бу-Бу-Бу-Бу-Бушка Мартин наш, он несколько книг написал, несколько курсов выпустил, ему по-любому надо было разжевывать.
3536.78 3559.26 "Игорь Лабутин" Вот поэтому теперь, почему я эту статью и затронул, интересно, да, послушать, что знают и о чём думают наши зрители, наши, блин, зрители, ну, хотя на ютубе зрители, слушатели, на ютубе, короче, пишите, что вы об этом всём думаете, чистая, луковая, порты адаптера гексигональная, никак вообще между ними выбирать.
3559.26 3560.26 "Игорь Лабутин" Роктальная.
3560.26 3567.74 "Игорь Лабутин" Ну, погоди, это уже сложно, одно внутри другого, не знаю.
3567.74 3571.18 "Игорь Лабутин" Вот, это же надо думать, кто является инфраструктурой на каждом уровне.
3571.18 3572.18 "Игорь Лабутин" Нет?
3572.18 3573.18 "Игорь Лабутин" Сложновато.
3573.18 3576.90 "Анатолий Кулаков" Ну, для этого нам голова и дана, пока не заменили нас.
3576.90 3577.90 "Игорь Лабутин" Да?
3577.90 3580.46 "Игорь Лабутин" Ладно, да, вот подключи ЛЛМку и будет нормально.
3580.46 3597.58 "Игорь Лабутин" Вот, в статье забавные выводы на тему, что выбрать, там сказано, если у вас сложная бизнес-логика, берите чистую архитектуру, а если вам нужна чёткая структура кода, берите луковую, а если у меня сложная бизнес-логика и мне нужна чёткая структура, то как бы, что брать непонятно.
3597.58 3614.86 "Игорь Лабутин" Ну, как бы, кажется так, что луковая можно считать довольно большой класс систем, а чистая можно считать, ну, как бы, некоторое подмножество, которое следует заветам товарища Мартина, чуть более строго.
3614.86 3617.10 "Игорь Лабутин" Вот, наверное, я бы так это определил.
3617.10 3624.98 "Анатолий Кулаков" Ну, в принципе, вам ничего не мешает следовать и то, и то, и не называть это каким-то задним словом, чтобы никому не обидно было, да?
3624.98 3625.98 "Игорь Лабутин" Абсолютно.
3625.98 3640.90 "Игорь Лабутин" Ну, трудный словарь всегда это хорошо, когда ты можешь сказать аж какой-нибудь термин и остальные поймут его и не надо долгих каких-то объяснений, проблема в том, что для этого должен существовать самый единый понятный термин.
3640.90 3664.46 "Игорь Лабутин" И кажется, что вот во всяких чистых луковых гексагональных и прочих архитектурах, с одной стороны, если ты говоришь и перед тобой кто-то, кто в принципе их всех воспринимает примерно как одно и то же, вы друг друга поймете, а если вы попадёте на человека, который как бы знает тонкую разницу между луковой и чистой архитектурой и будет начинать с вами спорить, то может быть тут уже не так и хорошо, что у вас есть такой словарь.
3664.46 3670.78 "Игорь Лабутин" Так что словарь бы иметь хорошо, но кажется, что здесь у нас нет пока такого словаря, который все…
3670.78 3674.50 "Анатолий Кулаков" Ну, и мы, кажется, сошлись, что они друг другу не противоречатся.
3674.50 3675.70 "Анатолий Кулаков" Они действительно не противоречатся.
3675.70 3680.74 "Анатолий Кулаков" Если ты назовёшь свою луковую гексагональ, ну, луковую чистой или чистой луковой, то скорее всего никто сильно на тебя не наедет.
3680.74 3681.74 "Игорь Лабутин" Ну, кроме…
3681.74 3683.74 "Анатолий Кулаков" Главное, кроме… Кроме авторов.
3683.74 3686.24 "Анатолий Кулаков" Кроме Мартина, да, который придёт и всех поставит на место.
3686.24 3687.24 "Анатолий Кулаков" Главное, чтобы она была.
3687.24 3694.78 "Анатолий Кулаков" Да, просто её… Сейчас, мне кажется, у большинства проектов основная проблема в том, что там нет никакой архитектуры.
3694.78 3702.46 "Анатолий Кулаков" Они слышали про какие-нибудь трёхзвенные слои, насоздавали там по 200-300 проектов и думают, что всё, у них есть слои, у них есть архитектура.
3702.46 3710.58 "Анатолий Кулаков" То есть там нет ни той, ни секой, то есть абсолютно неважно, какую вы выберете, выберите хоть какую-нибудь, и чтобы… Главное исследовать, да.
3710.58 3711.58 "Анатолий Кулаков" И придерживайте себя.
3711.58 3721.10 "Игорь Лабутин" Даже если вы выберете простую трёхслойную, то есть типа контроллеры, сервисы, репозитории, нормально, много проектов, большому количеству проектов это может быть даже достаточно.
3721.10 3725.34 "Игорь Лабутин" Обычная трёхслойная архитектура, но как бы просто аккуратно её придерживайтесь.
3725.34 3728.74 "Анатолий Кулаков" Просто придерживайтесь, и всё.
3728.74 3732.82 "Анатолий Кулаков" Так, давай ещё, у меня есть интересный набросик небольшой такой.
3732.82 3738.74 "Анатолий Кулаков" Тут автор вылез и рассказал, что янамы нам пользовать вообще не надо.
3738.74 3741.78 "Анатолий Кулаков" Янамы – это зло, и они нам вообще не нужны.
3741.78 3746.98 "Анатолий Кулаков" И особенно не надо это делать как раз-таки в нашем доменном слое.
3746.98 3753.86 "Анатолий Кулаков" Поэтому, не пересекаясь с предыдущей темой, хочется поговорить немножко о янамочках, что же, собственно, не угодило.
3753.86 3765.70 "Анатолий Кулаков" Итак, часто в наших приложениях, несмотря на то, что автор тут рассказывает про доменный слой, на самом деле все претензии, которые у него есть, они применимы к абсолютно любым янамам.
3765.70 3769.62 "Анатолий Кулаков" Поэтому можно рассматривать их абсолютно ко всему приложению.
3769.62 3774.34 "Анатолий Кулаков" Итак, в наших приложениях очень часто необходимо сгруппировать какие-то константы.
3774.34 3779.02 "Анатолий Кулаков" И часто разработчики, особенно в C#, предпочитают янамы.
3779.02 3787.86 "Анатолий Кулаков" Очень удобная штучка, в принципе, что там один концепт на одну строчку, прекрасно пишется, прекрасно используется, поддерживается языком, компилятором, в общем, всё прекрасно.
3787.86 3791.38 "Анатолий Кулаков" Но автор говорит, избегайте, избегайте этого ужаса.
3791.38 3795.26 "Анатолий Кулаков" Какие же причины он приводит в качестве аргументов?
3795.26 3809.90 "Анатолий Кулаков" Итак, для примера, для примера объявим янамчик, который называется ROLI, и у этого янамчика, ROLI, у нее будет следующее перечисление User, Administrator, Reviewer и SuperAdmin.
3809.90 3814.44 "Анатолий Кулаков" Теперь поехали рассуждать о минусах.
3814.44 3826.44 "Анатолий Кулаков" Первая проблема, которую видит автор, это в том, что если вы вдруг захотите узнать, какой же из этих элементов является админом, то вам необходимо будет произвести следующую манипуляцию.
3826.44 3833.26 "Анатолий Кулаков" Напомню, у нас есть 4 перечисления, и 2 из этих перечисления являются админами, это администратор и суперадмин.
3833.26 3837.28 "Анатолий Кулаков" Нам нужно, ну, часто бывает такая ситуация, когда нужно учесть или того, или другого.
3837.28 3838.70 "Анатолий Кулаков" Что в этом случае делается?
3838.70 3851.46 "Анатолий Кулаков" Ну, обычно создается экстеншн-метод к этому янамчику, и в этом экстеншн-методе пишут, что если переданная роль является администратором или суперадмином, тогда true, тогда это администратор.
3851.46 3855.46 "Анатолий Кулаков" Вот такой экстеншн-метод решает нам, в принципе, вот эту проблему.
3855.46 3861.06 "Анатолий Кулаков" Как определить из нескольких значений, кто из них задан, а кто нет.
3861.06 3870.82 "Анатолий Кулаков" Но автор говорит, что это вообще плохой подход, потому что данный код, данный экстеншн-метод нарушает эту инкапсуляцию.
3870.82 3878.22 "Анатолий Кулаков" Мы берем логику запроса, то есть логику определения того, кто является админом, отделяем его непосредственно от модели.
3878.22 3888.30 "Анатолий Кулаков" То есть у нас есть модель, которая называется роли, этот янамчик, и логика оторвана от него, то есть методы оторвана от него, которые начинают с этими ролями выдумывать какие-то бизнес-правила.
3888.30 3892.90 "Анатолий Кулаков" Это общепризнанный антипаттерн, который называется анимичная модель.
3892.90 3904.34 "Анатолий Кулаков" В общем, оставим за скобками, насколько анимичная модель является антипаттерном, но здесь действительно налицо применение анимичной модели, и это проблема.
3904.34 3905.34 "Анатолий Кулаков" Проблема номер два.
3905.34 3907.26 "Анатолий Кулаков" Называется спагетти-код.
3907.26 3909.58 "Анатолий Кулаков" Как она выглядит?
3909.58 3918.94 "Анатолий Кулаков" Она больше не про спагетти-код в привычном смысле, то есть мы тут не делаем каких-то больших цепочек вызовов там или завихрений, или еще чего-то, она больше про замусоривание кода.
3918.94 3921.30 "Анатолий Кулаков" Когда у нас случается замусоривание кода?
3921.30 3927.94 "Анатолий Кулаков" Допустим, если у этих ролей есть какие-то определенные коды, интовые коды.
3927.94 3938.10 "Анатолий Кулаков" Допустим, есть какой-нибудь юзер, и у этого юзера есть айдишник, юзер айди, то есть в нашем случае получается у роли.
3938.10 3939.10 "Анатолий Кулаков" У роли есть какой-нибудь айдишник.
3939.10 3944.78 "Анатолий Кулаков" Например, у юзера 1, у администратора 2, у ревьюера 3, у суперадмина 4.
3944.78 3952.80 "Анатолий Кулаков" Если мы используем енумы, то мы явно должны задать эти айдишники в енамчиках, и для этого есть синтаксис, способы и все такое.
3952.80 3955.74 "Анатолий Кулаков" Через равно мы прекрасно эти айдишники им зададим.
3955.74 3960.90 "Анатолий Кулаков" Можно не по порядку, там можно суперадмину дать 100 или 99 и так далее.
3960.90 3963.02 "Анатолий Кулаков" Что же у нас получается в коде?
3963.02 3967.62 "Анатолий Кулаков" Если вдруг в коде нам нужно вычислить код этой роли, в коде код.
3967.62 3974.14 "Анатолий Кулаков" Если нам в коде необходимо будет вычислить числовое значение этой роли, то мы обычно кастим.
3974.14 3978.30 "Анатолий Кулаков" То есть мы берем наш енамчик юзера и кастим его к энту.
3978.30 3982.50 "Анатолий Кулаков" Таким образом получаем целочисленный признак этой роли.
3982.50 3990.14 "Анатолий Кулаков" На самом деле вот этот каст с ролями, он не очень хороший примерчик, но если вы задумаетесь, у нас есть хороший пример.
3990.14 3991.54 "Анатолий Кулаков" Это как раз HTTP коды.
3991.54 4000.66 "Анатолий Кулаков" Когда возвращаете HTTP код в кей, на самом деле он имеет явное значение энтовое, которое называется 200, ну и так далее.
4000.66 4004.18 "Анатолий Кулаков" Там 404, 401 и прочие известные нормальные HTTP коды.
4004.18 4011.34 "Анатолий Кулаков" В общем мы их часто используем и очень много, например, iSpanet Framework и может быть даже ваша бизнес-логика, их кастят к энту.
4011.34 4016.94 "Анатолий Кулаков" То есть есть такая практика, действительно енамчики часто кастятся к энту.
4016.94 4020.90 "Анатолий Кулаков" И каст это тоже не очень хороший подход.
4020.90 4023.58 "Анатолий Кулаков" Это тоже какой-то такой запах.
4023.58 4028.02 "Анатолий Кулаков" Потому что он делает код менее явным.
4028.02 4031.38 "Анатолий Кулаков" Этот код начинает сложнее читать и сложнее поддерживать.
4031.38 4040.42 "Анатолий Кулаков" Особенно когда мы сделаем explicit cast, ну как ни крути, интуитивно все равно кажется, что там может быть какая-нибудь рантайм ошибка.
4040.42 4044.38 "Анатолий Кулаков" А вдруг почему-то к энту эта штука не приведется, по какому-то там признаку, не знаю.
4044.38 4048.06 "Анатолий Кулаков" Поменяли у енума, поменяли им у него базовый тип.
4048.06 4051.66 "Анатолий Кулаков" Теперь там под ним хранится не инт, допустим, а какой-нибудь флот.
4051.66 4057.54 "Анатолий Кулаков" В общем, есть такая штука, что когда ты кастишь, все-таки нужно кастов избегать.
4057.54 4062.62 "Анатолий Кулаков" И чем меньше в вашем коде явных кастов, тем лучше.
4062.62 4064.82 "Анатолий Кулаков" Чем меньше этих явных приведений типа.
4064.82 4069.50 "Анатолий Кулаков" В общем, вторая проблема, действительно, нарицион.
4069.50 4077.42 "Анатолий Кулаков" Третья проблема, которую автор откопал, это то, что невозможно дать нормальные имена енамчикам, когда мы хотим.
4077.42 4080.46 "Анатолий Кулаков" Ну в частности, у нас енамы не поддерживают пробельщики.
4080.46 4092.22 "Анатолий Кулаков" Поэтому если мы свой енам хотим назвать супер админ через пробел, а не как мы пишем обычно в Pascal кейсе, то у нас обычно на сцене появляется дисплей атрибут.
4092.22 4101.94 "Анатолий Кулаков" И в этом дисплей атрибуте мы можем написать любое имя, то есть любой нейм задать, хоть с пробелами, хоть со смайликами, хоть псевдографикой, какой угодно.
4101.94 4103.70 "Анатолий Кулаков" Это обычная юникодная строка.
4103.70 4110.22 "Анатолий Кулаков" Но опять же, у нас появляется атрибут, это какое-то усложнение, это какая-то неявность.
4110.22 4114.82 "Анатолий Кулаков" Надо не забыть, а в конце-то концов, а что если у нас будут разные локали?
4114.82 4126.86 "Анатолий Кулаков" И если нам нужно будет под язык автора этот атрибут локализировать, то что мы навесим, какой атрибут, на каком языке, как мы загрузим новый ресурс для того, чтобы отобразить новый язык.
4126.86 4137.74 "Анатолий Кулаков" Ну и вообще, это касается любых динамически определяемых ресурсов, которые в атрибутах мы уже не закачаем, а как-то нужно определять зависимость от пользователя или от его environment.
4137.74 4140.02 "Анатолий Кулаков" Поэтому дисплей атрибут тут не спасает.
4140.02 4142.22 "Анатолий Кулаков" Ну действительно, третья явная проблема.
4142.22 4157.54 "Анатолий Кулаков" И что же предлагается, куда же нам деться без наших любимых enumчиков, ну не будем же мы все какими-нибудь int'ами использовать или еще какими-нибудь глупостями, которые используют в недоязыках, в которых не завезли enum.
4157.54 4163.94 "Анатолий Кулаков" А нет, на самом деле у нас завезли более интересную концепцию, которая называется рекорды.
4163.94 4168.42 "Анатолий Кулаков" И вот рекордами мы вполне можем заменить все наши enumчики.
4168.42 4173.30 "Анатолий Кулаков" И это гораздо лучше, потому что у них есть очень много преимуществ.
4173.30 4183.46 "Анатолий Кулаков" Ну, во-первых, у них нет минусов, потому что они такие же компактные, то есть вы можете объявить рекорд в одну строчку, точно так же, как один элемент enumчика тут объявить.
4183.46 4190.18 "Анатолий Кулаков" Рекорды иммьютабельные, то есть нет никаких проблем с concurrent кодом или с поздней инициализацией или еще с какой-то глупостью.
4190.18 4191.94 "Анатолий Кулаков" Создали один раз и все работает.
4191.94 4206.70 "Анатолий Кулаков" И они сравнябельные, то есть каждый рекорд имплементируется в стандартные интерфейсы, с помощью которых вы можете их сравнивать, выводить удобно на консоль и прочие такие утилитивные методы, которые позволяют с рекордами работать интереснее и легко.
4206.70 4208.78 "Анатолий Кулаков" Так как же мы можем переделать наш enumчик?
4208.78 4209.78 "Анатолий Кулаков" Очень просто.
4209.78 4217.78 "Анатолий Кулаков" Мы можем объявить паблик рекорд роль, тоже самое, который в качестве единственного поля в конструкторе принимает ID.
4217.78 4224.18 "Анатолий Кулаков" А дальше мы объявляем паблик статик свойства у этого рекорда.
4224.18 4225.90 "Анатолий Кулаков" И эти паблик статик свойства инициализируем.
4225.90 4232.70 "Анатолий Кулаков" У нас будет паблик статик свойства, который называется User, которому мы дадим инициализацию NewRole от единички.
4232.70 4238.94 "Анатолий Кулаков" Точно так же паблик статик свойства Administrator, Reviewer, SuperAdmin.
4238.94 4244.62 "Анатолий Кулаков" И те же самые четыре строчки в рекордах мы займем те же самые, которые мы бы заняли в enumах.
4244.62 4249.18 "Анатолий Кулаков" В общем, все довольно компактно, все довольно миленько, красивенько выглядит.
4249.18 4252.82 "Анатолий Кулаков" Но при этом у рекордов есть куча преимуществ.
4252.82 4255.30 "Анатолий Кулаков" Например, они могут соблюдать энкапсуляцию.
4255.30 4264.66 "Анатолий Кулаков" То есть те методы, которые должны работать с полями рекорда, должны располагаться прямо внутри этого рекорда, без всяких экстеншн методов.
4264.66 4269.22 "Анатолий Кулаков" Таким образом, мы теперь можем определять админа по нашим локальным полям.
4269.22 4278.58 "Анатолий Кулаков" То есть бизнес логика, которая оперирует с моделью ролей, она будет находиться в том же самом классике, в котором и находится сама модель этих ролей.
4278.58 4281.90 "Анатолий Кулаков" Не будет никакого разрыва, не будет никакой анимичной модели.
4281.90 4283.90 "Анатолий Кулаков" Все будет богато и красиво.
4283.90 4289.30 "Анатолий Кулаков" А следующее преимущество это в том, что теперь мы можем легко этот рекорд расширять.
4289.30 4311.94 "Анатолий Кулаков" Допустим, если нам нужно задать теперь элементу этого рекорда какое-то имя, даже если у этого имени будут пробельчики, мы всего лишь навсего к полю id в конструктор добавляем стринговое поле name, и все, и все рекорды у нас теперь обладают прекрасным полем name, который мы можем выносить, выносить куда-нибудь, показать пользователю.
4311.94 4316.54 "Анатолий Кулаков" Если нам нужно, мы можем опять же подгрузить из какого-нибудь справочника, из какого-нибудь локали и так далее.
4316.54 4321.82 "Анатолий Кулаков" То есть оперировать с ними как с локальными данными, которые можно динамически в рантайме откуда-то подгружать и как-то менять.
4321.82 4332.30 "Анатолий Кулаков" И так же точно, в принципе, как и декларация практически ничем не отличается от Enuma, кроме своей гибкостью, у нас не отличаются и использования.
4332.30 4357.54 "Анатолий Кулаков" Если мы раньше объявляли переменную роль и давали ей значение роли с точки администратор, то сейчас получается все то же самое, так как у нас статические свойства в рекорде, который называется ролис, синтаксис вообще не изменяется, мы объявляем рекорд, который называется роль, присылаем ему ролис с точки администратор и абсолютно все то же самое, все можно использовать и иметь.
4357.54 4375.10 "Анатолий Кулаков" В общем, вот так вот в принципе можно заменить Enum на рекорды, которые будут более гибкие, более используемые и более концептуальные, то есть они не будут превращать ваш код в анимичную модель, они будут все свое таскать с собой.
4375.10 4391.82 "Анатолий Кулаков" Если у вас какие-то мега-сложные юзкейсы, то есть допустим нужно не только два поля вывести, но и кучу методов надавать, еще что-то, то всегда рекорды можно заменить на полноценные классы и полноценными классами тоже оперировать и расширять их как угодно.
4391.82 4404.42 "Анатолий Кулаков" В принципе, когда вы на практике сталкиваетесь обычно, что ваш Enum начинает обрастать какие-то кучи бизнес-логики, куча методов и так далее, то очень часто на практике так и делают, просто заводят отдельные классы.
4404.42 4443.82 "Анатолий Кулаков" Но просто если раньше классы, вот тот барьер, когда вы начинали Enum превращать в классы, он был достаточно далек, то есть вас нужно было очень сильно напрячь, очень много логики напихать, очень много каких-то кастомных интерфейсов нужно заимплементировать, чтобы вы все-таки перешли к классам, чтобы вас на это подтолкнули, то сейчас этот барьер сильно уменьшился, для того чтобы прийти к рекордам, вам в принципе-то и не обязательно ждать, пока у ваших Enum появится куча логики, буквально пару шажков, буквально у вас там появляется какое-то текстовое представление, и сразу можно уже юзать рекорды, они уже себя на этом этапе оправдывают.
4443.82 4450.78 "Анатолий Кулаков" Вот такой вот наброс, если на практике не использовали, то задумайтесь, может быть в некоторых ваших местах в вашем коде это будет полезно.
4450.78 4462.46 "Игорь Лабутин" Да, действительно, идея интересная и может заслуживать рассмотрение, мне кажется, я такое делал в нескольких местах, но как-то не отдавая себе отчет, сразу класс написал и все.
4462.46 4468.58 "Анатолий Кулаков" Ну вот, а с рекордами удобнее, там в принципе если класс несколько ставчиков требует, то рекорд всего одну.
4468.58 4473.14 "Игорь Лабутин" Да, рекордов тогда, конечно, не было еще, это очень давно писалось, все.
4473.14 4478.34 "Игорь Лабутин" Хорошо, ну чего, будем потихонечку в сторону закругления думать?
4478.34 4485.58 "Анатолий Кулаков" Да, давай, давай, я эту статью, наверное, вкратко раз нам упомяну, да и все, и хватит, потому что она там действительно такая довольно поверхностная маленькая.
4485.58 4488.66 "Анатолий Кулаков" Давай, хорошо, ладно, сейчас я… Пойдем подслушно.
4488.66 4502.66 "Анатолий Кулаков" И у нас подслушно всего-навсего один пункт, который достоин вашего внимания, но зато какой, в подлодке 374 на тему High Performance пришел никто иной, как Сергей Тепляков.
4502.66 4517.10 "Анатолий Кулаков" Это автор отличного блога, автор хорошей книжки, автор хороших докладиков, в общем, Сергей проявил себя в множестве аспектов и, в частности, он очень хороший специалист по перформансу.
4517.10 4529.14 "Анатолий Кулаков" Сейчас он занимается перформансом в Микрософте и именно поэтому может много чего рассказать и в этом выпуске он делает много ссылок к Дотнету, к C#, в общем, все довольно близко нам и понятно.
4529.14 4556.98 "Анатолий Кулаков" Там он рассказывает про Observability, про профайлинг, про бенчмаркинг, все это с привкусом High Performance, и также рассказывает, когда вообще нужно начинать оптимизировать, когда не нужно оптимизировать, когда легче вашу проблему с медленным кодом залить просто покупкой новых мощностей и все так далее, в общем, перформанс рассматривается с абсолютно разных сторон, и вширь, и вглубь, и в общем, все как мы любим, поэтому выпуск Подлодки 374 с Сергеем Тепляковым крайне рекомендую.
4556.98 4557.98 "Игорь Лабутин" Отлично.
4557.98 4564.30 "Игорь Лабутин" Тогда перейдем к последней нашей части, это кратко о разном.
4564.30 4568.98 "Игорь Лабутин" Здесь несколько статейчик новостей, тира таких небольших заметочек.
4568.98 4588.90 "Игорь Лабутин" Во-первых, продолжим немножко про Aspire, у Джимми Богарда вышла статья, как он пытался в Aspire запустить довольно сложный продукт на базе, значит, Particle Software Service Platform, если пользуетесь либо одним, либо другим, ну, посмотрите, может, что интересно найдет для себя с точки зрения того, как работает с Aspire.
4588.90 4600.62 "Игорь Лабутин" Дальше вышла статья про SoftDelete, про то, как его реализовывать в NCT Framework и про то, что, ну, вообще-то это не очень здорово.
4600.62 4634.38 "Игорь Лабутин" Напомню, что SoftDelete — это когда вы не удаляете записи в табличке, помечаете их булевским флажком, а потом надо везде, где вы делаете селекты писать where, там, не deleted или еще что-то в таком духе, можно это через GlobalQuery фильтры делать, но тогда логика размазывается, в общем, не очень большая статья, но рассуждение на тему, зачем это может быть надо, как это сделать и какие есть альтернативы, там, какая-нибудь архивная табличка, архивная база данных, если совсем, старые данные, которые не нужны, ну, в общем, если вдруг пользуетесь SoftDelete или думаете об этом, гляньте, может, какие-то полезные мысли найдете.
4634.38 4635.38 "Игорь Лабутин" Ну и последнее...
4635.38 4639.98 "Анатолий Кулаков" Так, а что, подожди-подожди, а что не здорово-то, пользоваться SoftDelete или имплементацией?
4639.98 4662.58 "Игорь Лабутин" Не здорово, ну, как бы, SoftDelete, если пользоваться, то, конечно, можно, но если данных много, то, во-первых, надо тщательно следить за индексами, потому что, как бы, если у вас в таблице 90% это уже удаленные записи, а 10% не удаленные, то сложнее будет выбирать нужные индексы правильные.
4662.58 4679.98 "Игорь Лабутин" Вот, во-вторых, много где, может, надо есть писать руками, значит, из Delete, да, и тогда вы подумаете про GlobalQuery фильтры, но тогда, если вам где-то нужно написать таки, чтобы было с учетом Delete, то нужно будет немножко поприседать, в общем, логика запросов размазывается.
4679.98 4688.34 "Игорь Лабутин" Вы, вроде, смотрите на запрос, а то, что есть еще где-то where, значит, не Delete, а отдельно дописываемый, как бы, где-то там в определении модели, далеко.
4688.34 4692.10 "Анатолий Кулаков" Ну да, и отключается, он довольно некрасивый будет.
4692.10 4712.26 "Игорь Лабутин" Да, поэтому, в общем, автор предлагает, как бы, вообще, либо складывать в архивную табличку, мувать прям записи, да, и дропать их, честно, делитить в основной, либо вообще в архивную BD и говорить, что если живете в облако, это может вам еще и денег сэкономить, потому что там в некоторых облаках есть прям спецстариф на, типа, архивные BD.
4712.26 4726.22 "Анатолий Кулаков" Это же сложнее, типа, тебе же, чтобы поставить один флажок в записи, это один уровень сложности, а для того, чтобы транзакционно правильно ее передвинуть, именно не потеряя в пути куда-то в другую табличку, это же совсем другой уровень сложности.
4726.22 4733.06 "Игорь Лабутин" Ну, зато, зато денег сэкономишь потом, может быть, или потратишь их на разработку и поддержку этого механизма.
4733.06 4752.02 "Игорь Лабутин" Короче, ну, слушай, разные ситуации бывают, бывают действительно сугубо, как сказать, сезонные нагрузки, да, то есть вот когда что-то активное приехало, в данных много в базу прогрузилось, но это что-то закончилось и больше эти данные точно не нужны, только если кто-то не полезет смотреть архивы раз в год, и то, если полезет.
4752.02 4759.90 "Игорь Лабутин" Такие, как бы, держать в основной горячей базе данных, может быть, действительно смысла не имеет, и куда-нибудь их выгружать, как вариант.
4759.90 4762.30 "Игорь Лабутин" Ну, это да, это да.
4762.30 4780.18 "Игорь Лабутин" Ну, и последняя новость от Microsoft, все-таки у нас есть новости в этом выпуске, а именно единственная фича C# 13, на которой планировалось поэкспериментировать с тем, как бы мы будем обсолетить всякие языковые фичи в C#.
4780.18 4799.10 "Игорь Лабутин" И напомню, мы рассказывали, что там будет вариант, что если вы берете новое SDK, компилируете им старый проект, у которого target framework еще старенький, то он проанализирует использование каких-то новых, проанализирует ваш код на предмет того, не сломаются ли они, если вы переключитесь на новый C#.
4799.10 4803.10 "Игорь Лабутин" Потому что, например, новые ключевые слова появились или какая-то семантика появилась.
4803.10 4807.58 "Игорь Лабутин" Так вот, это собирались обкатать в 13 C# на примере ключевого слова field.
4807.58 4822.78 "Игорь Лабутин" Это в сеттерах, напомню, что в смысле в сеттерах у нас уже есть спецключевое слово value, планировалось ввести ключевое слово field, так чтобы вы в сеттере могли написать field, присвоить value, сделав какую-то валидацию, например, дополнительную.
4822.78 4826.98 "Игорь Лабутин" Ну а в геттере тоже возвращать field, без необходимости явно объявлять бэкинг поле.
4826.98 4836.62 "Игорь Лабутин" Но что-то пошло не так, фича будет в превью только включаться и не будет в основной версии C#, резолюционном 13-го.
4836.62 4843.86 "Анатолий Кулаков" — То есть, единственная фича, которая могла быть в новом C#, и то ее убрали, что же там будет-то в языке вообще?
4843.86 4848.46 "Игорь Лабутин" — Тензоры, тензоры, тензоры… — Главная интрига — тензоры, тензоры.
4848.46 4851.80 "Игорь Лабутин" — И этот парамспан, он точно будет, вроде его не выпилили.
4851.80 4856.54 "Анатолий Кулаков" — Ну ладно, ладно, подождем релиза, может еще выпилят, еще не вечер.
4856.54 4859.34 "Игорь Лабутин" — Ну да, еще месяц у них есть, да.
4859.34 4860.86 "Анатолий Кулаков" — Я думаю, успеют.
4860.86 4883.62 "Анатолий Кулаков" Так, давай, у меня тут есть парочка заметок, у товарища Ардалеса вышла статья, и как всегда, виденка своим статьям делает, или наоборот, видео статьи делает, короче, называется она, что интерфейс должен описывать, что вы будете делать, а имплементация должна описывать, как вы будете это делать.
4883.62 4895.10 "Анатолий Кулаков" В принципе, мысль довольно простая и примитивная, но товарищ очень подробно расписывает все аргументации, почему так происходит, почему так должно быть, и как это реализовать.
4895.10 4901.46 "Анатолий Кулаков" Не знаю, может быть, каким-нибудь джунам полезно будет послушать, почитать, для того, чтобы в память это вложить.
4901.46 4911.10 "Анатолий Кулаков" То есть, основная концепция в том, что интерфейс вам всего лишь навсего объявляет, что он будет делать, но при этом ни в каком случае не должен намекать, а как он это делает.
4911.10 4912.10 "Анатолий Кулаков" А имплементация наоборот.
4912.10 4915.82 "Анатолий Кулаков" Имплементация рассказывает вам, как это делать, и таких имплементаций может быть много.
4915.82 4924.94 "Анатолий Кулаков" И прелесть этого подхода в том, что вы можете имплементацию менять, интерфейс составляя одним и тем же, то есть не изменяя код, который уже использует этот интерфейс, при этом подменяя имплементацию.
4924.94 4939.86 "Анатолий Кулаков" Все это, конечно, на таком примитивном уровне довольно хорошо, но как только появляются, например, асинхронные методы, которые обязаны возвращать таску, то мы очень сильно начинаем убивать интерфейсы.
4939.86 4948.22 "Анатолий Кулаков" Например, у нас уже четко отличаются интерфейсы, которые, например, и обаунт, и не обаунт, в зависимости от того, есть у них таска или нет у них таски.
4948.22 4953.14 "Анатолий Кулаков" Или, допустим, она начинает бросать от имплементации какие-то эксепшены, которые оригинальный интерфейс не предусматривал.
4953.14 4956.46 "Анатолий Кулаков" И тоже тут начинает наша абстракция течь.
4956.46 4968.98 "Анатолий Кулаков" Короче, минусов у этого подхода много, у этого утверждения, но все-таки там, наверное, какие-нибудь 80% случаев должны ему соответствовать, и поэтому знать данное правило и понимать, почему мы его используем, довольно важно.
4968.98 4987.18 "Анатолий Кулаков" Еще одна новость от Эндрю Лока, он обновил свою библиотечку, которая называется NetEscapes ISPNetCoreSecurityHeaders, в общем, самое главное, это Security Headers здесь.
4987.18 4993.78 "Анатолий Кулаков" Это библиотечка, которую Лок поддерживает, и она в себе содержит, как вы, наверное, догадались, хедеры для security.
4993.78 4997.10 "Анатолий Кулаков" Что же это за такие магические хедеры?
4997.10 5008.22 "Анатолий Кулаков" Это специальные защитные заголовки, которые описывает Avasp, которые рекомендует Avasp для того, чтобы ваше веб-приложение возвращало.
5008.22 5027.66 "Анатолий Кулаков" Ну, в качестве примера такие заголовки, как Content Type Options, Cross-Origin Opener, XSS Protection, в общем, специальные заголовки, которые помогают вашему браузеру избавиться от какого-то числа атак, которые можно произвести на ваше приложение.
5027.66 5035.42 "Анатолий Кулаков" Какие-нибудь подмена кук, подмена оригинального сайта, подмена, там, понижение протокола с HTTP, и вот такие прочие-прочие вещи.
5035.42 5039.66 "Анатолий Кулаков" На самом деле их очень много, все не кривые, именно поэтому их очень много.
5039.66 5051.46 "Анатолий Кулаков" То есть там тысячу миллионов стандартов, кто-то поддерживает что-то, кто-то поддерживает никого-то, они постоянно меняются, постоянно изменяются, поэтому нормальному человеку в голове это держать все очень плохо, очень неблагодарно это дело.
5051.46 5066.22 "Анатолий Кулаков" Поэтому у Andrew есть всего-лина всего библиотечка, которая с помощью одного метода @DefaultSecurityHeaders позволяет вам добавить там какой-то уровень дефолтных рекомендуемых заголовков ко всем вашим ответам и ко всем вашим запросам.
5066.22 5072.42 "Анатолий Кулаков" Кроме дефолтов, естественно, можно добавить какие-то недефолтные, но это только в том случае, естественно, если вы знаете, что вы делаете.
5072.42 5078.62 "Анатолий Кулаков" В общем, библиотечка полезна, если вы загоняете секьюрити или для вас это критически важно, то как минимум стоит ее происследовать.
5078.62 5107.94 "Игорь Лабутин" Ну и на этом будем заканчивать, сегодня у нас, мы в очередной раз посмотрели на .NET Aspire и тестирование в нем, разобрались детально, как работает Frozen Dictionary внутри, попробовали позапускать LLM кейс C#, поговорили про луковую и чистую архитектуру, про янумчики в доменном слое и замены их на рекорды, ну и нашли стандартные подслушанные кратко о разном, пробирались по разным подкастам и статьям.
5107.94 5110.22 "Игорь Лабутин" На этом, кажется, все на сегодня.
5110.22 5121.30 "Анатолий Кулаков" Да, до новых встреч, шаре, репосты, слушайте, рассказывайте друзьям, заходите, оставляйте комментарии на ютубчике и ставьте лайков во всех наших социальных сетях, где там только можно.
5121.30 5129.18 "Анатолий Кулаков" Кстати, у нас там у Apple очень мало лайков, поэтому если не сложно, зайдите туда, напишите парочку отзывов и поставьте нам того, чего мы заслуживаем.
5129.18 5133.26 "Анатолий Кулаков" Всем до новых встреч, счастливо, пока!
