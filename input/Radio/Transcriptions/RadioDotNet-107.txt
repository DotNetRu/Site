0.00 14.48 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Радио.нет выпуск номер 107, и в эфире его постоянный ведущий Анатолий Кулаков.
14.48 15.48 "Игорь Лабутин" И Игорь Лабутин.
15.48 16.48 "Игорь Лабутин" Всем привет.
16.48 33.68 "Анатолий Кулаков" Так, у нас новогодние праздники вроде закончились, поэтому пора, пора возвращаться в рабочее русло, и помогут в этом нам с вами не только новости, но и замечательные друзья, наши помогаторы, которые пополнялись за эти новогодние праздники, что не может не радовать.
33.68 36.72 "Анатолий Кулаков" Так, запомните эти благозвучные имена.
36.72 58.60 "Анатолий Кулаков" Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Лазарев Илья, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей, Дмитрий Сорокин, Александр Ерыгин, Егор Сычев и Гольдебаев Александр.
58.60 63.00 "Анатолий Кулаков" Ну что ж, всех приветствуем, а также всех тех, кто пожелал остаться неизвестными.
63.00 77.08 "Анатолий Кулаков" Если вдруг вы почему-то ищете еще новогодний выпуск, который у нас был с наших времен, вот мы решили его не выкладывать, в общем то, потому что не очень вам вписывался наш формат и не очень много просмотров собирал.
77.08 93.56 "Анатолий Кулаков" Но если вам нравится вот такая новогодняя болтовня, подведение наших каких-то личных итогов, сравнение технологий, какие-то планы на будущее и обсуждение дотнета, в общем, такие сплетни на скамейке, то этот выпуск записан и на самом деле ждет вас на Boosty.
93.56 96.64 "Анатолий Кулаков" Поэтому если вдруг сильно хочется, то там его можно послушать.
96.64 99.84 "Анатолий Кулаков" Так, что у нас с новостями вообще?
99.84 100.84 "Анатолий Кулаков" Майкрософт проснулся?
100.84 113.84 "Игорь Лабутин" Майкрософт, конечно, проснулся, в Твиттере там какая-то активность появилась, GitHub не спит, но из новостей и каких-то емких больших статей про то, что нового нас ждет в дотнете 10 пока особо многого не видно.
113.84 128.40 "Игорь Лабутин" Какие-то мелочи пока мелькают там всем, наметки того, что уже начали делать в 10-ом дотнете, или что может быть сделают в 10-ом дотнете, вот мы тут в чатике обсуждали как раз про background service недавно, вчера-позавчера.
128.40 134.60 "Анатолий Кулаков" Да, кстати, хорошая тема, я думаю, должны бы как раз всех порадовать в новом релизе.
134.60 136.60 "Анатолий Кулаков" Не то, чтобы она большая, но довольно удобная.
136.60 150.48 "Игорь Лабутин" Ну, Дэвид Фаудлер обещал, что, да, наверное, может быть, на это они таки посмотрят, по крайней мере, у нас есть точно несколько месяцев, пока не выйдет релиз, даже не сколько, несколько, 10 месяцев, получается, пока не выйдет релиз, можно успеть сделать.
150.48 151.48 "Игорь Лабутин" Не, ну там же плебьюшки еще.
151.48 155.72 "Игорь Лабутин" Ну, понятно, да, ну мы знаем, что last-minute-fixes у них тоже бывают.
155.72 182.24 "Игорь Лабутин" В любом случае, какая-то работа ведется, пока никаких существенных новостей нет, поэтому мы пока продолжим по статьям смотреть, и у нас сегодня не так много статей, мы отобрали какое-то количество, которое на самом деле не то, чтобы прям напрямую некоторые из них относятся к дотнету, но, тем не менее, дотнет-разработчики с ними точно встречаются, и они, как нам кажется, могут быть полезными, поэтому давайте обсудим.
182.24 195.36 "Игорь Лабутин" И начнем мы со статьи, даже серии статей, которые выпустил Andrew Log в прошлом году еще, которая посвящена security-заголовкам.
195.36 218.92 "Игорь Лабутин" В каком-то смысле эта тема больше, ну не то, что больше, она во многом касается именно фронтендовой части, и, конечно, вы с этим, возможно, больше столкнетесь, если вы занимаетесь программированием фронтенда, но бэкэнд-разработкой, когда вы пишете на дотнеты, тоже нужно знать про то, какие заголовки бывают, что с ними нужно делать и вообще зачем они предназначены.
218.92 227.48 "Игорь Лабутин" И говорим мы все это про корс и все, что вокруг него, есть там некоторые другие заголовки, которые тоже про всякий cross-origin, всякие разные штуки.
227.48 230.96 "Игорь Лабутин" Поэтому давайте… Ну, я имею в виду HTTP-заголовки все-таки, да?
230.96 239.20 "Игорь Лабутин" Да, да, да, HTTP-заголовки, которые используются для того, чтобы так или иначе как-то обеспечить безопасность ваших серверов, ваших бэкэнд, в том числе приложений.
239.20 242.28 "Игорь Лабутин" Не только бэкэндах, понятное дело, но ваших приложений в целом.
242.28 275.36 "Анатолий Кулаков" Мне кажется, да, эта история как бы обоюдная, она интересна не только фронтендерам должна быть, но и бэкэндерам, потому что заголовки-то общаются, обкидываются между фронтендом и бэкэндом, ну, иногда, конечно, между фронтом и фронтом, но в общем случае, в принципе, это больше такая тема секьюрити, а секьюрити, как известно, должно заботить всех, даже там, если вы пишете на дотнете и при этом лазите в SQL, то в SQL тоже есть секьюрити, если вы общаетесь с фронтендом, у фронтенда есть секьюрити, если по HTTP там или какому-нибудь gRPC ходите, к другим сервисам, там тоже бывает секьюрити.
275.36 277.68 "Анатолий Кулаков" И чем больше про секьюрити вы знаете, тем лучше.
277.68 280.16 "Анатолий Кулаков" Поэтому, мне кажется, тема нормальная.
280.16 281.16 "Игорь Лабутин" Ну, да.
281.16 290.44 "Игорь Лабутин" И именно к бэкэндам приходят фронты со словами «включите нам нормальный курс, вот давайте, делайте так, чтобы у нас курс заработал нормально, так вот, давайте разбираться,
290.44 291.44 "Анатолий Кулаков" что такое курс».
291.44 292.44 "Анатолий Кулаков" «Нормальный» — это звездочку всем поставьте, да?
292.44 298.92 "Игорь Лабутин" А там не так просто, в некоторых случаях звездочку ставить нельзя, как выясняется, даже если ему очень хочется, стандарт не даст.
298.92 303.80 "Игорь Лабутин" Смотрите, давайте начнем с первого, с терминологии.
303.80 310.04 "Игорь Лабутин" Везде это звучит, слова, мы уже в несколько раз их тоже произнесли, cross-origin, cross-origin, что же такое ориджин?
310.04 313.48 "Игорь Лабутин" Ориджин — это не совсем то же самое, что домен.
313.48 324.88 "Игорь Лабутин" То есть многие считают, что ориджин — это вот доменное имя, если у вас есть какой-нибудь там, не знаю, google.com, то вот у вас там, или там github.com, давайте вот возьмем, то это ориджин.
324.88 325.88 "Игорь Лабутин" На самом деле нет.
325.88 331.56 "Игорь Лабутин" Ориджин — это доменное имя вместе с протоколом доступа и с портом.
331.56 337.76 "Игорь Лабутин" При этом, включая любые поддомены, и порт при этом может быть неявным.
337.76 343.20 "Игорь Лабутин" То есть, например, у вас может быть там https://github.com, это ориджин.
343.20 353.48 "Игорь Лабутин" Может быть там https://github.com/443, это тоже ориджин, и он такой же, как предыдущий.
353.48 361.72 "Игорь Лабутин" Вы можете придумать какой-нибудь поддомен github, и это тоже будет ориджин, и он уже не будет совпадать с двумя первыми названными.
361.72 366.44 "Игорь Лабутин" То есть, вы берете полностью домен, вы берете порт, явный или неявный, и вы берете протокол.
366.44 373.88 "Игорь Лабутин" Это очень важно, потому что именно cross-origin штуки как раз сравнивают с вот эти самые ориджины.
373.88 413.24 "Игорь Лабутин" В целом, вообще говоря, по дефолту браузер должен бы себя вести, и в идеальном мире хотелось бы, чтобы браузер себя вел так, чтобы ресурсы, которые вы загружаете, на какой-то сайт с какому-то доменом, то есть с каким-то ориджином, хотелось бы, чтобы все данные, которые загружаются в рамках загрузки этого сайта, то есть там скрипты, которые потом хотят подгрузить другие скрипты, какие-то HTML, которые хотят подгрузить какие-то другие там картинки, все остальное, загружали всегда любые другие ресурсы тоже с этого же самого ориджина.
413.24 415.72 "Игорь Лабутин" Это называется same-origin policy.
415.72 444.20 "Игорь Лабутин" И, в принципе, так было бы здорово, это контролируется браузером, все здорово, и было бы гораздо более безопасно на интернете, но оно было бы гораздо более, назовем это, скучным и неинтересным, потому что как раз тот факт, что вы можете с одного сайта ссылаться на другой, и туда как-то переходить, или подгружать, ну переходить, ладно, вам никто не мешает, но подгружать контент с соседних сайтов, баннеры, вот это все, и все такое прочее.
444.20 478.40 "Игорь Лабутин" Но даже если не говорить о баннерах, даже если говорить о нормальных сайтах, очень часто сейчас делается так, что у вас есть основной сайт, а, например, какие-то картинки и ресурсы подгружаются в CDN, да, контент-деливери, не только, у которых обычно другой адрес, с совершенно другим доменом, или как минимум с другим ориджином, то есть даже если вы живете с таким же доменом, но с другим поддоменом, например, cdn.github.com, то это уже другой ориджин, и сайт github.com, по мнению браузера, не должен иметь доступа к cdn.github.com, но он каким-то образом имеет.
478.40 500.00 "Игорь Лабутин" Вот для того, чтобы рассказать браузеру про то, что, а вот этот сайт на самом деле имеет право обращаться вот туда тоже, точнее, что сайт github.com имеет право ходить на cdn.github.com, тот самый cdn.github.com сообщает об этом браузеру посредством заголовков, http-заголовков в ответе.
500.00 507.18 "Игорь Лабутин" Естественно, для того, чтобы получить эти заголовки, браузеру нужно сделать какой-то запрос, и запросы делятся на два вида.
507.18 524.08 "Игорь Лабутин" Запросы бывают, я сейчас не помню, как они точно называются, типа простые, грубо говоря, то есть обычный get без параметров и так далее, такой запрос просто делается, но понятно, что, например, пост-запрос таким образом вы не сделаете, потому что он не является и демпотентом, то есть он потенциально может поменять состояние сервера.
524.08 528.00 "Игорь Лабутин" Если же вам было нельзя делать такой запрос, ну это как-то странно.
528.00 544.20 "Игорь Лабутин" Поэтому для таких запросов, пост, например, которые могут поменять состояние, сначала браузер делает специальный запрос с методом http, методом options, который как раз и предназначен для того, чтобы получить данные от сервера и вот эти самые course-заголовки.
544.20 554.76 "Игорь Лабутин" Дополнительно, для того, чтобы, поскольку вы отправляете запрос options, сервер понятия не имеет, с каким запросом вы к нему собираетесь прийти.
554.76 595.92 "Игорь Лабутин" Курл-то вы ему выдадите, но будет там get или post или delete, сервер не знает, поэтому метод, которым вы потом пойдете, передается в специальном заголовке, access-control-request-method, а также вы можете заодно передать еще те заголовки, которые вы можете заслать, нестандартные заголовки, в специальные http-заголовки, access-control-request-headers, просто имена этих заголовков через запятую, и дальше сервер решает, а имеет ли право вот этот самый клиент с таким origin, который тоже придет естественно в запросе, давать доступ, в смысле, получать доступ к этому самому серверу вот по запрошенным, так сказать, данным.
595.92 602.96 "Игорь Лабутин" В ответ сервер возвращает набор заголовков, те самые course-заголовки, которые все просят настроить.
602.96 619.20 "Игорь Лабутин" Три стандартных заголовка, это access-control-allow-origin, не стандартные, они все стандартные, три самых популярных, access-control-allow-origin, куда вы указываете либо ту самую звездочку, про которую я говорил, то ли, либо прям конкретный один origin, туда нельзя указать список ориджинов, только один.
619.20 626.44 "Игорь Лабутин" Потом access-control-allow-methods, это те методы, с которыми вы можете приходить, к вам можно прийти к этому ориджину.
626.44 629.76 "Игорь Лабутин" Ну и access-control-allow-headers, это какие заголовки разрешены.
629.76 631.96 "Игорь Лабутин" Остальные будут игнорироваться.
631.96 648.88 "Игорь Лабутин" И если есть учетные данные, то есть если к вам браузер хочет прийти и передать какие-то credentials, то нужно, чтобы сервер возвращал заголовок access-control-allow-credentials-true.
648.88 690.88 "Игорь Лабутин" Если такого заголовка не будет, а браузер таки пошлет запрос с cred'ами, то будет интересно, сервер получит запрос, сервер его выполнит, сервер вернет ответ, браузер ответ получит, но не даст коду страницы прочитать этот ответ, а вернет типа, сорян, там не помню, 500 сколько там, то есть или 300 сколько-то, не помню, что вернет сейчас, но смысл в том, что запрос-то выполнится, у нас нет никакого механизма запретить выполнение запроса, но фактически, поскольку все это контролирует браузер, именно браузер откинет ответ и скажет, что ничего не было, ничего не знаю.
690.88 710.76 "Игорь Лабутин" Вот, и для того, чтобы как раз в этом случае можно было нормально прочитать ответ, коду в браузере, сервер должен отвечать access-control-allow-credentials-true, и обязательно нужно указать access-control-allow-origin именно не звездочку, а тот origin, с которого пришли.
710.76 738.76 "Игорь Лабутин" Поэтому большинство фреймворков на сервере, с которыми вы работаете, обычно в коде позволяет вам указывать allowed origins в виде какого-нибудь массива, списка, чего угодно, тех оригинов, которые вы разрешаете, но в результате код работает, ну там тот же SPNet, работает таким образом, что он проверяет пришедший origin, и если он содержится в списке разрешенных, он его же отправляет в access-control-allow-origin обратно.
738.76 750.36 "Игорь Лабутин" Если же не содержится, ну, соответственно, эти заголовки не отправляются, браузер в результате их не видит и отрезает такой запрос.
750.36 763.44 "Игорь Лабутин" Помимо тех заголовков, которые я перечислил, бывают еще несколько, наверное, даже не буду устанавливаться, там можно еще всякие expose headers сказать и так далее, но смотрите, что нам это все дает.
763.44 785.24 "Игорь Лабутин" Вот этот cross-origin-resource-sharing, то есть по шарени ресурсов, все эти механизмы, все эти проверки заголовков, все эти методы options и прочее, все то, что я перечислил, срабатывает только если браузер делает явный запрос на back-end.
785.24 800.80 "Игорь Лабутин" Ну, например, вы в вашем JavaScript-коде делаете какой-нибудь метод fetch чего-нибудь, тогда все это работает, но в принципе могут быть другие cross-origin-запросы, которые не требуют fetch, а которые выполняются в каком-то смысле неявно.
800.80 814.90 "Игорь Лабутин" Один из примеров это, например, работа с объектом window, то есть вы можете в JavaScript создать объект window, в него закинуть ссылочку и открыть pop-up или что-нибудь в таком духе.
814.90 817.00 "Игорь Лабутин" То есть это не fetch, это как бы работа с окошками.
817.00 846.16 "Игорь Лабутин" И если у вас window открыт с того же origin, ну в смысле что код, который выполняет там window.что-нибудь, был загружен с того же origin, который передан внутрь этого window, в ссылке, который был передан внутрь этого window, то тогда вы можете из вызывающего кода с этим window делать много чего, доступаться к внутренним методам, пропертям, много чего там можно делать.
846.16 856.78 "Игорь Лабутин" А вот если cross-origin, то есть довольно ограниченный метод, там по-моему 6 или 7 штук, в статье они все описаны, которые выглядят на первый взгляд безопасными.
856.78 869.88 "Игорь Лабутин" Ну что там можно сделать, там типа можно проверить, что открыто, закрыть и странная такая пропертя, посчитать количество iframes внутри.
869.88 877.88 "Игорь Лабутин" Вот я не знаю зачем это было сделано, наверное как-то разработчики браузеров подумали и зачем-то им это было надо.
877.88 883.68 "Игорь Лабутин" Может быть на основе этого, например, можно принять решение, что ага, пора закрывать window.
883.68 896.80 "Игорь Лабутин" Но, как выяснилось, именно вот это вот свойство, количество iframes, это внезапно большая security дырка, от которой аж фейсбук пострадал в каком-то смысле.
896.80 914.40 "Игорь Лабутин" И поэтому разработчики браузеров придумали новый заголовок, точнее не заголовок, а новый подход работы со всем этим добром, но по факту это заголовок cross-origin opener policy, который конкретно нацелен на то, чтобы устранять вот эту самую уязвимость.
914.40 917.88 "Анатолий Кулаков" А как фейсбук пострадал, чем он повредил?
917.88 938.88 "Игорь Лабутин" Вот, значит, смотри, я почитал статью, где была ссылочка, смысл примерно такой, значит, если ты берешь фейсбук и ищешь в фейсбуке, например, какую-нибудь, ну что-нибудь да, просто в сёрче, то у тебя на каждый результат поиска по внутренним фейсбуковым техническим причинам рендерится небольшой iframe.
938.88 950.08 "Игорь Лабутин" То есть, грубо говоря, посчитав количество iframes в окне поиска, можно узнать, сколько результатов у тебя было выдано на конкретный запрос, понятное дело.
950.08 953.44 "Игорь Лабутин" А результаты там очень персонализированные, да, получается?
953.44 954.44 "Игорь Лабутин" Да.
954.44 970.52 "Игорь Лабутин" Дальше твоя задача как злоумышленника сделать так, чтобы у тебя пользователь в каком-то поп-апе на каком-то вредоносном сайте смог поискать в своем фейсбуке что-то, ну или типа отправить запрос на фейсбук на поиск от твоего имени.
970.52 982.60 "Игорь Лабутин" Ты не сможешь получить доступ к данным поиска, ты не сможешь получить доступ к джаваскрипту, который там загружается, к результатам поиска, но ты сможешь получить доступ к количеству результатов.
982.60 999.16 "Игорь Лабутин" А дальше там прямо написаны запросы, что-то типа, а найди мне, сколько пользователей залайкали вот эту вот штуку и при этом являются моими друзьями.
999.16 1005.80 "Игорь Лабутин" Там, короче, можно составить довольно сложные запросы, на основе которых можно на самом деле довольно хитро таргетить, ну, понимать, что за пользователь.
1005.80 1014.08 "Игорь Лабутин" Ты, понятно, не выяснишь никаких персданных, но ты очень хорошо сможешь его затаргетить с точки зрения, например, рекламы или еще чего-нибудь.
1014.08 1020.92 "Анатолий Кулаков" То есть это не то, что… И эти выводы можно сделать, только зная количество результатов, и все, да?
1020.92 1024.92 "Анатолий Кулаков" Количество результатов на твои хитро подготовленные запросы.
1024.92 1027.92 "Анатолий Кулаков" Ну, все равно круто, да?
1027.92 1030.68 "Анатолий Кулаков" Чисто по количеству догадываешься, не по содержимому, не по
1030.68 1031.68 "Игорь Лабутин" размеру.
1031.68 1032.68 "Игорь Лабутин" Ну да, да.
1032.68 1041.76 "Игорь Лабутин" Знаешь, это вот как эти игры, не знаю, школьного времени, угадаешь что-нибудь, да, можно задавать вопросы, типа, а это животное, а это бегает, а это это самое.
1041.76 1048.36 "Игорь Лабутин" Вот ты таким же образом угадывал когда-то что-нибудь, что загадал твой, так сказать, соперник, вот здесь то же самое.
1048.36 1049.36 "Игорь Лабутин" А это там…
1049.36 1057.94 "Анатолий Кулаков" Наверное, запрос, казалось, здесь какая-то более широкое пространство для поиска, то есть идентифицировать человека во всем мире по непонятным запросам, опираясь
1057.94 1058.94 "Игорь Лабутин" только на количество.
1058.94 1065.70 "Игорь Лабутин" А тебе не нужно идентифицировать человека, тебе нужно, ну, как бы цель злоумышленника же не всегда получить персданные, да?
1065.70 1071.18 "Игорь Лабутин" Цель злоумышленника – сделать что-то, ну, получить какие-то данные, которые можно, например, продать кому-то.
1071.18 1074.38 "Игорь Лабутин" Хороший рекламный профиль продать кому-то, ну почему нет?
1074.38 1090.62 "Игорь Лабутин" Потому что вот я знаю людей, айдишники Фейсбук, Фейсбук-пользователей, которые там, не знаю, находятся, не знаю, в штатах, в таком-то штате, в таком-то городе, любят при этом такую-то лайк или такую-то контору и так далее, ну, как бы, почему нет?
1090.62 1091.62 "Игорь Лабутин" Им можно что-то…
1091.62 1093.02 "Анатолий Кулаков" Да-да, хорошее описание появилось.
1093.02 1100.06 "Анатолий Кулаков" И ты говоришь, что, в общем, это починили с помощью не того, что Фейсбук переделали на нормальные какие-то димчики, да?
1100.06 1101.06 "Анатолий Кулаков" Да, это похихли браузера.
1101.06 1102.06 "Игорь Лабутин" Стандарт изменили.
1102.06 1138.82 "Игорь Лабутин" Да-да-да, добавили новый хеддер, cross-origin open-repolicy, у которого есть несколько значений, значений 3, и мне понравилось, что у новых, короче, хеддеров, мне казалось, у каких-то были похожие хеддера раньше, и там было значение что-то типа там none или там disabled, same-origin какой-нибудь, ну, в таком духе, а здесь как бы первое значение, которое типа безопасно, наоборот, все опасно, все выключено, называется unsafe none, то есть ты когда будешь писать такое, типа unsafe none, ты сразу поймешь, не надо писать unsafe none, надо что-то другое выбрать.
1138.82 1139.82 "Игорь Лабутин" Ну, в общем, понятно.
1139.82 1140.82 "Анатолий Кулаков" Пугает хорошо, да.
1140.82 1181.50 "Игорь Лабутин" Да, unsafe none, ладно, как бы то же самое, что его нету, same-origin, и есть еще same-origin allow popups, значит, самое безопасное, понятно, same-origin, то есть это означает, что к этому самому открытому window, объекту, хоть что-то из него можно будет узнать, только если он открыт из same-origin, да, то есть от самой атака, посмотреть количество i-frames уже не получится, у вас в том месте, где вы откроете window, если вы находитесь на другом ориджене, а очевидно, что вы будете на другом ориджене, потому что на фейсбуке вас никто не захостит, то вы сможете просто понять, что у вас есть window, и с ним, по-моему, кроме закрытия сделать ничего нельзя, если я правильно помню.
1181.50 1199.30 "Игорь Лабутин" Но бывает иногда, все-таки требуется открыть popup так, чтобы можно было из этого popup обращаться к сайту, который вас открыл.
1199.30 1215.78 "Игорь Лабутин" Это иногда надо, потому что на самом деле same-origin, если вы откроете с другого ориджена, он и в обратную сторону не даст работать, то есть из окошка можно узнать, кто тебя открыл, и там тоже был ограниченный набор, если он из разных оридженов, но все-таки что-то можно было сделать.
1215.78 1248.18 "Игорь Лабутин" С новым заголовком сделать ничего нельзя, если ориджен разный, но same-origin allow popups такое даст сделать, потому что, например, это нужно для всяких оплата на сторонних сайтах может требовать открытия попапа, ну то есть у нас есть некоторый флоу, я с этим регулярно сталкиваюсь, у меня в браузере уже установлено расширение, которое по дефолту старается резать все попапы, и у меня кое-где, видимо, на каких-то чуть кривовато настроенных сайтах у меня где-то что-то иногда не проходит, приходится в исключении добавлять, вот, и в основном это оплаты почему-то.
1248.18 1261.42 "Игорь Лабутин" Поэтому добавили аж третий вариант, это same-origin allow popups, вот, соответственно, ну, вроде бы стало получше.
1261.42 1299.98 "Игорь Лабутин" Со всеми этими заголовками, надо сказать, и все, конечно, все становится безопасно, но если у вас маломальский большой сайт, в котором вы там сложно как-то взаимодействуете, особенно если это какой-то большой продукт, который там потом собирает из кучки каких-нибудь микрофронтендов, расположенных на разных хостах, на разных адресах, на разных доменах большой единый финальный продукт, то если вы так бодро закинете все безопасные значения для этого, ну и там последующих заголовков, про которые я буду рассказывать, то с вероятностью 99% ваш сайт где-нибудь да перестанет работать.
1299.98 1307.02 "Игорь Лабутин" Ну, просто потому, что где-то там нужно все-таки поменять домен загрузки, где-то там прокинуть через единый домен, ну вот это все.
1307.02 1341.82 "Игорь Лабутин" Для того, чтобы это все потестировать, и я могу сказать, что мы это так и делали, мы тут недавно как раз все эти заголовки, ну как недавно, летом, летом или где-то в сентябре, в районе сентября, проставляли, очень помогает специальный режим, если вы зададите заголовок не Cross-Origin Opener Policy, а Cross-Origin Opener Policy Report Only, то браузер его будет игнорить, ну то есть все будет работать как раньше, но браузер в свою консоль начнет писать всякие логи типа, а вот если бы он был не Report Only, то я бы тут заблокировал вот это, вот это, вот это и вот это.
1341.82 1364.06 "Игорь Лабутин" Вот, в итоге как бы вы все докидываете Report Only заголовки вот эти, открываете ваш сайт, гоняете его какими-нибудь тестами, не тестами, вручную, как вы умеете, смотрите на консоль браузера и смотрите, нет ли там ужасных логов на тему того, я бы тут сейчас все заблокирую, если нет, то ну скорее всего можно Report Only убирать и ставить нормальный заголовок, если же есть, значит надо идти разбираться и исправлять.
1364.06 1454.26 "Игорь Лабутин" Дальше, смотрим дальше, как мы выяснили, для фича работают корсы, для кошек работает Cross-Origin Opener Policy, но это не все, у нас есть всякая загрузка, не знаю, скриптов, медиа, цсски в конце концов, для них это все не работает, и для того, чтобы это все работало для них нужен новый заголовок, называется Cross-Origin Resource Policy, вот, там соответственно Same Origin, Same Site или Cross-Origin можно использовать, Same Site это без учета под домены и порта, то есть здесь все просто, например, если вы грузите какие-нибудь там ваши цсски или медиа под домена вашего сайта, вы делаете Same Site и тогда не будет учитываться порт и под домен, то есть будет учитываться только протокол, что это TPS или TTPS и основное имя домена второго уровня, соответственно, ну Cross-Origin понятное дело разрешает все, тут, кстати, unsafe почему-то не стали делать, тут всего лишь три варианта, Same Origin, Same Site и Cross-Origin, идея абсолютно вся та же самая, соответственно, проставляете нужные заголовки на стороне тех серверов, которые раздают ваши медиа, скрипты, CSS и все остальное, и убеждаетесь, что браузер, ну сначала ставите report only, убеждаетесь, что браузер не ругается и все у вас будет хорошо.
1454.26 1552.02 "Игорь Лабутин" Итак, и мы на данный момент получили такой расклад, что у нас есть корс, который запрещает дополнительные запросы к сайту с каких-то левых ориджинов, у нас есть ресурс полиси, который запрещает дополнительные запросы к сайту с каких-то левых ориджинов и разрешает загрузку, то есть чтобы ваши CSS не грузили кто-то левый, грубо говоря, а есть еще Cross-Origin Embedder Policy, он запрещает загрузку на вашем сайте левых ресурсов, если что они, если они явно не отметили, что они готовы загружаться Cross-Origin, то есть там тоже unsave none, require corp, corp это Cross-Origin Resource Policy или credentialless, то есть если, лучше это все почитать в статье на схемы, там есть нормальная схема с нормальными описаниями, к сожалению голосом очень сложно объяснять, но кратко смысл такой, если ваш сайт возвращает header Cross-Origin Embedder Policy со значением require corp, а это самое строгое значение, то все внедряемые ресурсы должны возвращать этот самый Cross-Origin Resource Policy обязательно с same origin или same site, ну или соответственно Cross-Origin, то есть короче заголовок Cross-Origin Resource Policy обязан быть, то есть вы ставите Embedder Policy и тогда требуете от всего того, что вы грузите, обязательная перестановка ресурс полиси с правильными значениями.
1552.02 1558.90 "Игорь Лабутин" Вот Embedder я никогда ни разу не пользовался и мы до него так и не дошли, может быть и зря.
1558.90 1566.22 "Анатолий Кулаков" Ну по идее да, как хотелось бы, чтобы какая-нибудь такая штука по умолчанию стояла, чтобы по умолчанию нельзя было ничего, и ты разрешаешь что-нибудь точечно там.
1566.22 1582.78 "Игорь Лабутин" Ну вот да, но неудобненько иногда бывает, особенно удобно начинать разработку, когда разрешено все, а потом потихонечку закручиваешь гайки, но если ты пришел к этому слишком поздно, то как-то чуть подкрутишь гайку, а оно уже перестает работать, потому что где-то на что-то завязались.
1582.78 1588.78 "Игорь Лабутин" Ну да ладно, давай вернемся в .NET тему, и как раз сообразим…
1588.78 1596.26 "Анатолий Кулаков" Ты расскажи, да, каким образом все это в голове уложить, связать, вспомнить и знать, кому чего отдавать, это вообще нереально.
1596.26 1612.96 "Игорь Лабутин" Ну в голове уложить, это все-таки надо почитать и разобраться, особенно если вы это, то есть как связаны разные кусочки ваших серверов, какие сервера должны что возвращать, это надо прямо, ну вот вдуматься, почитать вот эти статьи, там довольно неплохо Андре все описано, и осознать.
1612.96 1616.74 "Игорь Лабутин" А вот дальше, как это все написать в .NET коде, тут все попроще.
1616.74 1635.74 "Игорь Лабутин" Ну как, можно писать вручную, в принципе ISP.NET Core, там поддержка Cores встроенная, поддержка вот этих Corp, короче, Embedder Policy, Resource Policy, Opener Policy, по-моему, встроенной нет, может быть, кстати, в последних версиях добавили, но по-моему не было такого.
1635.74 1668.30 "Игорь Лабутин" Можно вручную добавить эти заголовки, а можно воспользоваться библиотечкой от, конечно же, Andrew Locke, то есть на самом деле серия статей, конечно, писалась под апдейт библиотечки, которая, кстати, зарелизилась, по-моему, где-то ближе ко второй половине прошлого года, в версию 1.0, так что ее можно вполне пользоваться, она довольно простая, поэтому там не то, что там как-то 1.0 сильно повлияло, и в практичном варианте пользоваться ей очень просто, вы просто пишете app.useSecurityHeaders, то есть добавляете медлеварьку в Security Headers, и оно само добавляет разумные дефолты.
1668.30 1671.94 "Игорь Лабутин" Что значит разумные дефолты?
1671.94 1697.06 "Игорь Лабутин" Есть такая организация, AWASP, может быть, слышали, если как-то вам нравится тема security, очень часто всякие там AWASP Top 10 упоминают и так далее, то есть это организация, которая составляет некоторые, в том числе, рекомендации, как наиболее безопасно программировать ваши сайты, апишки, ну в общем, все, там на самом деле есть рекомендации почти на все, что можно запрограммировать.
1697.06 1707.58 "Игорь Лабутин" И есть некоторые рекомендации, как должна быть засекьюрена бэкэнд по дефолту, и вот как раз библиотека добавляет по дефолту нужный набор заголовков.
1707.58 1727.46 "Игорь Лабутин" Если вы хотите это дело кастомизировать, вы можете создать header policy collection, такой классик, его каким-то образом наполнить как надо нужными заголовками, там такой fluent интерфейс для всех этих заголовков, то есть там не нужно ничего делать, практически со строчками, все с fluent методами работаете, и передать в этот самый useSecurityHeaders, мне дал Варьку, все будет хорошо.
1727.46 1738.62 "Игорь Лабутин" Более того, надо понимать, что вот это все, я там рассказываю, CSS, вот это все, а очень часто мы же пишем чисто опишку.
1738.62 1829.58 "Игорь Лабутин" То есть мы, вот та часть, которая работает с опишкой, точнее которая предоставляет опишку, она не будет предоставлять ни CSS, ничего другого, если это не какой-то конечно сервер сайт рендеринг, если у вас Razor приложение тут же рядышком лежит, то нет, у вас будет чистая опишка и для нее на самом деле можно немножко больше закрутить гаек, там уже никаких там имбейдеров ресурс полисе не нужен, там можно ставить их максимально секьюрный вариант, и для этого у Эндрю как раз добавился новый метод, можно у headerPolicyCollection вызвать метод называется addDefaultEPISecurityHeaders, и он тогда поставит более агрессивные дефолты, так что ваше API будет защищено прям супер совсем, но если ваше API раздает CSS или что-нибудь в таком духе, то присмотритесь, тогда может быть лучше использовать просто addDefaultSecurityHeaders без слова API, ну а если вам вдруг зачем-то нужно разные полисы на разные методы, на разные endpoints, то это тоже можно сделать, вы можете создать разные именованные полисы, вот тут вот появляются строчки, вы просто их называете как-то, каждой полисе задаете свой собственный набор заголовков и дальше, либо если вы используете minimal API, вы пишите withSecurityHeadersPolicy и указываете имя, либо если вы используете контроллер, вы используете SecurityHeadersPolicyAttribute, тоже указываете название, и нужные заголовки автоматически будут в металловарьке подставляться, когда к вам будут приходить запросы.
1829.58 1837.78 "Игорь Лабутин" Причем, как я понимаю, options-запросы поддержаны автоматически и будут возвращать корректные заголовки.
1837.78 1850.54 "Игорь Лабутин" Такие дела, security — тема сложная, даже рассказывать про нее сложновато, но я попробовал, по крайней мере, заранить какую-то, надеюсь, интерес, что ли, не знаю, к этой теме.
1850.54 1862.98 "Игорь Лабутин" Ну, какой-то интерес, неинтерес — это делать надо, на самом деле, потому что иначе вас могут, как Facebook, хакнуть и узнать какие-нибудь, может быть, очень важные или не очень важные данные о ваших пользователях.
1862.98 1880.54 "Анатолий Кулаков" Да, вообще, когда смотришь на все эти разнообразия заголовок, особенно их именование, значение, историческое обновление, понимаешь, что весь вот этот HTTP — это такой огромный, большой, дырявый решетер, который пытается затыкать и параллельно прорывает где-то еще 10 дырок.
1880.54 1889.38 "Игорь Лабутин" Ну, когда придумывали, не было Facebook, просто хотели ссылочки на соседний компьютер, грубо говоря, на соседний нетрокнод по имени.
1889.38 1900.54 "Анатолий Кулаков" Ну, даже если не было Facebook, у тебя же основополагающий протокол не должен ориентироваться на то, что в каком-то сайте завязал фреймочки, поэтому надо все браузеры срочно менять.
1900.54 1904.94 "Анатолий Кулаков" Основополагающий должен быть глобальный и фундаментальный, он должен подстраиваться под сайт.
1904.94 1912.18 "Анатолий Кулаков" И потом, даже если не было Facebook, то прежде всего надо было подумать, зачем вообще такую штуку делать.
1912.18 1939.18 "Анатолий Кулаков" Ну ладно, понятно, что все исторически сложилось, там вообще, если посмотреть на весь HTML, JS, CSS, это одно большое исторически сложилось, поэтому здесь какое-то разумное объяснение искать не нужно, просто обидно, что индустрия все еще идет по пути затыкания дырок пальцами, а не по какому-то концептуальному пути, который раз объявил тебе какой-нибудь HTTP3, который мегабезопасный и по дефолту весь секьюрный.
1939.18 1940.74 "Анатолий Кулаков" Вот такого не происходит.
1940.74 1946.14 "Анатолий Кулаков" Ну понятно, потому что это сломает как бы сразу весь интернет, и такого никогда не будет.
1946.14 1949.86 "Анатолий Кулаков" Хорошо, давай, от грустного к чему-то более веселому.
1949.86 1954.74 "Анатолий Кулаков" Про более веселого, давайте поговорим про Дотнет.
1954.74 1955.74 "Анатолий Кулаков" Про Дотнет?
1955.74 1963.62 "Анатолий Кулаков" Ну это тоже почти Дотнет, там Дотнет библиотечка и антрилока была, но сейчас ближе к Дотнету.
1963.62 1974.02 "Анатолий Кулаков" И более того, приятная новость, Святослав Бычков, наш служитель, прислал нам интересную статью, свое собственное изготовление, которое описывает его собственную библиотеку.
1974.02 1990.90 "Анатолий Кулаков" Для того, чтобы мы о ней рассказали, и так совпало, что реализация этой библиотеки давно у меня, не то, что летала в голове, я ее давно хотел сделать, то есть это был такой мой маленький подпроджект, который я хотел бы сделать, потому что я очень сильно люблю логирование и все, что с этим связано.
1990.90 1999.86 "Анатолий Кулаков" И вот эта библиотечка идеально попала во все, что мне мечталось приобрести, поэтому хочется о ней рассказать, об этой и идее, и библиотечке.
1999.86 2007.42 "Анатолий Кулаков" Давайте поговорим о том, каким образом ваши повседневные логи увеличить их скорость, их эффективность в десять раз.
2007.42 2016.90 "Анатолий Кулаков" Это безусловно штука, которая нужна не всем, то есть если вы уперлись в производительность логов, то значит с вашим приложением все хорошо.
2016.90 2025.66 "Анатолий Кулаков" Значит все остальное вы вычистили, запросы у вас летают, а локаций нет, ничего нигде не боксится и прочие вот эти глупости вы все вылезали.
2025.66 2028.58 "Игорь Лабутин" Или вы пишете слишком много логов.
2028.58 2037.34 "Анатолий Кулаков" Наверное, да, это может быть причиной, вы пишете слишком много логов и профайлер вам показал, что вот где-то здесь у вас проблемы.
2037.34 2055.06 "Анатолий Кулаков" Но я участвовал в проектах, в которых действительно были такие шизофренические требования к перформансу, и это было нужно, и это не единышные проекты, поэтому действительно тема важная, тема интересная о том, как сделать перформанс логи.
2055.06 2058.74 "Анатолий Кулаков" Давайте начнем для начала, что же такого не так с обычными нашими логами.
2058.74 2067.34 "Анатолий Кулаков" Мы будем рассматривать микрософтовский iLogger стандартный, который есть у нас в приложениях, и наверное каждый из вас обязательно писал в своей жизни логи.
2067.34 2080.94 "Анатолий Кулаков" Вы берете логгер, вы пишете там какую-нибудь строчку типа log trace, передаете туда message template, то есть это какая-то строка, в которой вы в качестве шаблона указываете параметры, и дальше передаете параметры, которые вы хотите залогировать.
2080.94 2096.98 "Анатолий Кулаков" Как бы банальная строчка, наверняка все из вас представляют, как она устроена и что она делается, и она не предвещает каких-то больших проблем, но на самом деле это не так, потому что под капотом у логов делается очень много важной какой-то машинерии.
2096.98 2101.82 "Анатолий Кулаков" Ну и прежде всего, давайте рассмотрим, какие проблемы в этой строчке есть.
2101.82 2104.18 "Анатолий Кулаков" Уже сейчас, уже в вашем коде эти проблемы есть.
2104.18 2110.30 "Анатолий Кулаков" Вы их не замечаете, потому что они довольно мелкие и .NET с ними успешно справляется, но они уже есть.
2110.30 2123.82 "Анатолий Кулаков" А прежде всего, это может, возможно, избыточная аллокация message template, и вообще все памяти, связанные с вызовом метода.
2123.82 2145.98 "Анатолий Кулаков" Ну допустим, если мы логируем log trace, и в это время у нас логирование трейсов выключено, то есть minimal level для логера проставлен в какой-нибудь info, то есть трейсы мы вообще логировать не будем, то мы все еще потратим время на то, чтобы этот метод вызвать, чтобы эту строчку сформировать, чтобы параметры передать и прочие-прочие вещи.
2145.98 2149.42 "Анатолий Кулаков" В приложениях, которые заботятся о своем performance, это важно.
2149.42 2157.94 "Анатолий Кулаков" То есть вы тратите время на лишний вызов метода, на лишнюю аллокацию параметров, на форматирование message template и прочие такие мелкие вещи.
2157.94 2167.78 "Анатолий Кулаков" Иногда вы логируете не просто какое-то число или какую-то строку, а какой-то отчет, который требует для своего формирования, может быть, даже каких-то дополнительных вызовов.
2167.78 2175.18 "Анатолий Кулаков" Вот, и если вдруг трейс у вас выключен, то все эти вызовы, которые необходимы были для того, чтобы сформировать такой маленький отчетик, они были сделаны зря.
2175.18 2182.22 "Анатолий Кулаков" Поэтому здесь, когда вы просто так пишете log, вы немножко можете потерять.
2182.22 2188.50 "Анатолий Кулаков" Следующая проблема, которая есть у нашей строчки с логом, это возможность избыточного боксинга параметров.
2188.50 2198.62 "Анатолий Кулаков" Потому что все параметры, которые вы передаете после message template, они на самом деле передаются в массиве объектов paramObjectArray.
2198.62 2204.94 "Анатолий Кулаков" И paramObjectArray славен тем, что он аллоцирует этот массив.
2204.94 2211.10 "Анатолий Кулаков" И на аллокацию, опять же, тратится время, тратится память, и это не очень хорошо.
2211.10 2222.22 "Анатолий Кулаков" Эта аллокация действительно в маленьких размерах никому ничего плохого не делает, но если таких логов у вас очень много, то на профилере эту штуку тоже легко увидите.
2222.22 2229.10 "Анатолий Кулаков" Также есть еще проблема с подобным message template и параметром, которые передаются.
2229.10 2236.78 "Анатолий Кулаков" Заключается она в том, что этот message template представляет из себя обычную строчку, и в этой строчке довольно легко ошибиться.
2236.78 2244.18 "Анатолий Кулаков" Например, не передать туда каких-то параметров или передать лишние, именно написать в строчке лишние параметры, а забыть их передать в качестве значения.
2244.18 2251.94 "Анатолий Кулаков" И в таком случае вас ждет runtime error, если вдруг какой-то параметр в runtime будет отсутствовать, то есть message template его не найдет для реализации.
2251.94 2260.78 "Анатолий Кулаков" Это тоже довольно плохая ошибка, вы могли случайно что-то отрефакторить, и при этом у вас в runtime что-то свалится.
2260.78 2261.78 "Анатолий Кулаков" Ошибка плохая.
2261.78 2267.86 "Анатолий Кулаков" И существуют специальные анализаторы, которые помогают ее находить, но, опять же, это все костыли.
2267.86 2278.90 "Анатолий Кулаков" Также можно поговорить про сам message template, когда вы просто логируете какую-то запись, в это время не формируется какая-то обычная строка, которая записывается куда-то там в файлик или уходит куда-то в сеть.
2278.90 2282.38 "Анатолий Кулаков" Начиная с .NET Core, по его умолчанию, у нас используют структурное логирование.
2282.38 2292.10 "Анатолий Кулаков" Структурное логирование прекрасно тем, что оно формирует некий объект, который описывает вот эту строчку в логах, и так как там формируется объект, то у этого объекта есть куча свойств.
2292.10 2300.26 "Анатолий Кулаков" И каждой проперти, каждый параметр, который вы передаете в эту логовую запись, это одно из свойств этого структурного логирования.
2300.26 2301.26 "Анатолий Кулаков" Это все записи в журнал.
2301.26 2316.94 "Анатолий Кулаков" И вот форматирование каждого параметра, учет каких-то там настроек, допустим, текущей культуры или настроек форматирования чисел или еще чего-то, оно все учитывается во время логов.
2316.94 2330.22 "Анатолий Кулаков" И на самом деле там происходит куча какой-то сложной логики, которая заставляет из всего этого структурного логирования получить вам в итоге понятный картеж с сообщением о логах.
2330.22 2338.82 "Анатолий Кулаков" И когда вы пишете лог просто одной строчкой, очень мало существует способов для оптимизации всего этого процесса.
2338.82 2351.26 "Анатолий Кулаков" Потому что каждый лог, он довольно такой индивидуальный, непредсказуемый, динамический, в общем, все, что можно было бы там прооптимизировать, закешировать какие-нибудь форматоры, закешировать какие-нибудь культуры, в общем, всего этого мы лишаемся.
2351.26 2354.74 "Анатолий Кулаков" Благодаря вот этому вот краткому, понятному и красивому синтаксису.
2354.74 2361.78 "Анатолий Кулаков" И опять же, на мелких размерах вы этого не заметите, но когда у вас будут какие-то нагрузки, то это вполне может выстрелить.
2361.78 2364.46 "Анатолий Кулаков" Итак, что же мы можем с этим сделать?
2364.46 2370.58 "Анатолий Кулаков" Ну, как я уже выше сказал, это проблема довольно известная, и люди натыкаются на нее довольно часто.
2370.58 2374.74 "Анатолий Кулаков" Как бы вам не казалось, что такие мелочи кого не могут волновать.
2374.74 2375.74 "Анатолий Кулаков" Нет, волнуют.
2375.74 2385.78 "Анатолий Кулаков" Особенно если вы, например, Microsoft, и если вы пишете, например, какой-нибудь ASP.NET Framework или Entity Framework, то вы наткнётесь на это практически сразу.
2385.78 2394.44 "Анатолий Кулаков" И Microsoft выпустила какие-то расширения, какие-то библиотеки, рекомендации о том, каким же образом работать с таким подобным кодом.
2394.44 2402.54 "Анатолий Кулаков" И даже есть специальная статейка, которая называется High-Performance Logging, то есть как вам сделать логирование прям для хай-перформанса.
2402.54 2404.62 "Анатолий Кулаков" Ссылочка на эту статейку тоже будет в шоу-ноутах.
2404.62 2414.82 "Анатолий Кулаков" Если кто не читал, посмотрите, потому что очень интересное чтиво, и там вы как раз столкнетесь с теми вещами, о которых могли бы раньше даже не задумываться.
2414.82 2424.54 "Анатолий Кулаков" Ну, в общем, Microsoft довольно быстро выпустила такую библиотечку, это даже не библиотечка, так набор экстеншенов, который делает следующую вещь.
2424.54 2442.78 "Анатолий Кулаков" Он объявляет LoggerMessage класс, и у класса LoggerMessage метод Define, который позволяет нам прикомпилировать, приготовить некую запись, даже не запись, а некий делегат, который позволяет нам приготовить некий делегат, с помощью которого мы будем в дальнейшем логировать.
2442.78 2443.78 "Анатолий Кулаков" Что это значит?
2443.78 2447.90 "Анатолий Кулаков" Это значит, что мы разбиваем вот эту нашу логовую запись на две части.
2447.90 2451.62 "Анатолий Кулаков" На часть статическую, которая никак не меняется, и на часть динамическую.
2451.62 2459.34 "Анатолий Кулаков" Если мы задумываемся, то практически все в нашем логе, вот в обычном лог-трейсе, практически все это статическая часть.
2459.34 2460.34 "Анатолий Кулаков" То есть это константы.
2460.34 2461.78 "Анатолий Кулаков" Мы знаем, под каким уровнем мы логируем.
2461.78 2464.86 "Анатолий Кулаков" Мы знаем Message Template, под которым мы логируем.
2464.86 2468.42 "Анатолий Кулаков" Мы можем знать количество параметров, мы типы этих параметров тоже знаем.
2468.42 2471.42 "Анатолий Кулаков" Единственная динамическая часть, которая у нас есть, это значение параметров.
2471.42 2476.62 "Анатолий Кулаков" Вот только значение параметров нам нужно получить динамически в рантайме.
2476.62 2486.46 "Анатолий Кулаков" Все остальное мы можем объявить еще в Design Timing, то есть сделать метод Define, который предкомпилирует вот этот делегат, которому мы должны будем отдать параметры.
2486.46 2494.50 "Анатолий Кулаков" И параметры уже в рантайме там подставятся в делегат, который уже распарсил весь Message Template, который уже закэшировал все форматоры, который уже сделает вам хорошо.
2494.50 2495.50 "Анатолий Кулаков" Вот.
2495.50 2497.86 "Анатолий Кулаков" Каким образом это работает?
2497.86 2505.86 "Анатолий Кулаков" Вы должны объявить где-нибудь там у себя в локальных функциях или где-то в отдельном классике вот эти делегатики, с помощью которых вы будете логировать.
2505.86 2510.10 "Анатолий Кулаков" Для каждой, для каждой строчки логов вам необходим будет отдельный делегат.
2510.10 2522.58 "Анатолий Кулаков" И для создания этого делегата воспользуйтесь статической фабрикой Logger Message Define, где опишите абсолютно каждую строчку логов, что вы от ней хотите, под каким типом, с какими айтемами, с каким Message Template и так далее.
2522.58 2527.50 "Анатолий Кулаков" И все это рантайм вам подготовит один раз и будет оптимально использовать быстро и хорошо.
2527.90 2533.50 "Анатолий Кулаков" И на самом деле вот этот вот простой подход, он избавляет от всех тех проблем, о которых мы говорили вверху.
2533.50 2552.18 "Анатолий Кулаков" У нас больше не будет там ни аллокации массива, у нас больше не будет каких-то проблем с кэшированием, у нас не будет ошибок в количестве аргументов, потому что в Compile Time мы сделаем строго типизированный делегат, который принимает ровно то количество параметров, которые нужно, ровно с таким типом, которое нужно.
2552.18 2554.70 "Анатолий Кулаков" В общем, все, казалось бы, проблема решена.
2554.70 2559.46 "Анатолий Кулаков" Микрософт написал статью, Микрософт выпустил библиотечку и как бы свое дело сделал.
2559.46 2566.22 "Анатолий Кулаков" И именно этим подходом, если вы залезете там внутрь ISP.NET, Entity Framework, именно этим подходом как бы сам Микрософт и пользуется.
2566.22 2569.70 "Анатолий Кулаков" Всем рекомендует и этот подход себя прекрасно показывает.
2569.70 2580.94 "Анатолий Кулаков" Если вы оптимизировали логи, то, скорее всего, здесь вы остановились, потому что все проблемы решены, все перфомансы счастливы и больше делать ничего не надо.
2580.94 2593.14 "Анатолий Кулаков" Но если вдруг мы начнем придираться и посмотрим немножко на то, а как теперь наши логи выглядят, мы поймем, что здесь есть все еще есть другие проблемы.
2593.14 2598.58 "Анатолий Кулаков" Мы предыдущие проблемы с перфомансом закрыли, но перед нами стали проблемы с удобством использования.
2598.58 2606.78 "Анатолий Кулаков" Потому что, если мы раньше просто писали логер трейс и все, и жили счастливо, теперь нам нужно сделать довольно большую работу.
2606.78 2618.06 "Анатолий Кулаков" Нам нужно пойти, где-то найти место, написать там вот этот Define, описать там сразу все темплейты, описать их параметры, потом этот Define каким-то образом вызвать.
2618.06 2626.46 "Анатолий Кулаков" В общем, все это сопровождается очень большим куском дополнительного кода, который, в принципе, писать не очень хочется.
2626.46 2630.66 "Анатолий Кулаков" И сопровождать его не очень хочется, и рефакторить его неудобно, и выглядит он вообще ужасно.
2630.66 2638.82 "Анатолий Кулаков" Вместо там одной строчки мы начинаем создавать какие-то дополнительные классы, делегаты, лямбды, где-то их юзаем в каком-то месте, в общем, выглядит это ужасно.
2638.82 2642.58 "Анатолий Кулаков" И здесь мы можем подойти к следующему этапу.
2642.58 2652.14 "Анатолий Кулаков" Недавно, ну как недавно, когда появились Source-генераторы, Microsoft, опять же, осознавая проблему вот этой уродливости, выпустил Source-генератор.
2652.14 2659.98 "Анатолий Кулаков" Мы его обсуждали в нашем подкасте, Source-генератор, который позволяет вам как раз-таки нивелировать вот эти проблемы.
2659.98 2663.62 "Анатолий Кулаков" То есть он помогает каким образом?
2663.62 2679.46 "Анатолий Кулаков" Теперь, для того, чтобы сгенерировать вот этот performance-critical метод для логирования, вы просто пишете partial-метод, даете ему какое-то понятное имя, обозначаете, какие аргументы он должен принять, и сверху на этом partial-методе навешиваете атрибутик.
2679.46 2700.26 "Анатолий Кулаков" Этот атрибутик рассказывает практически все то же самое, какой лог-левел, какой message-темплейт к этому методу должен прийти, и благодаря вот этому атрибуту Source-генератор сканирует вашу сборку, находит все вот эти лог-методы, они уже не делегаты, вот эти partial-методы, и делает под них реализацию.
2700.26 2707.34 "Анатолий Кулаков" Реализация, как несложно догадаться, как бы точно такая же, там define, передается туда template, и все вот возвращаясь к предыдущему шагу.
2707.34 2720.34 "Анатолий Кулаков" Код становится чище, в результате Source-генератора генерится вот этот же код с define, как я сказал, код становится довольно чище, чем предыдущий метод, но все еще есть проблемы.
2720.34 2729.58 "Анатолий Кулаков" Вот проблемы, которые называются слишком много, слишком много ненужного кода, который приходится писать, она все еще присутствует.
2729.58 2744.66 "Анатолий Кулаков" Его намного меньше, чем было в предыдущем шаге, но все еще его очень много, потому что вам нужно создать какой-то делегат, куда-то его поместить, разметить его атрибутами, указать в этих атрибутах какие-то непонятные значения в довольно некоротком синтаксисе.
2744.66 2747.70 "Анатолий Кулаков" Насчет, опять же, размещения.
2747.70 2765.86 "Анатолий Кулаков" Существует несколько способов размещения, вы можете выделить отдельный класс, в этом отдельном классе задефайнить все вот эти ваши методы, которые будут логировать, но мы приходим к тому, что этот отдельный класс как-то не очень связан с тем куском кода, из которого этот логер вызывается, что очень часто неудобно.
2765.86 2791.62 "Анатолий Кулаков" Другой способ - это сделать partial класс, там где вам нужно использовать лог, и в качестве второго partial класса вот там реализовать все эти функции для логирования, но тогда мы получаем, что у нас рядом с бизнес-логикой находятся куча, опять же, каких-то инфраструктурных логов с какими-то страшными атрибутами и немножко бизнес-логика замусоривается.
2791.62 2796.30 "Анатолий Кулаков" В общем, куда это все положить и как организовать - это тоже встает довольно нетривиальный вопрос.
2796.30 2813.96 "Анатолий Кулаков" Ну и все, еще слишком много избыточного мусора, вот эти вот все атрибуты, которые довольно-таки не короткие, не маленькие, нетривиальные, они могут сильно увеличить тот код, который вы писали бы, используя обычное простое логирование в одну строчку, не performance, не оптимизированное.
2813.96 2835.18 "Анатолий Кулаков" И еще один минус здесь можно выделить, когда вы начинаете использовать вот эти define или атрибуты с source-генератором, вы сталкиваетесь с тем, что у вас может появиться в команде различные подходы к логированию, то есть кто-то пишет в одну строчку, кто-то пишет через define, кто-то использует атрибуты и source-генератор, и вот получается такая вот каша.
2835.18 2844.18 "Анатолий Кулаков" В общем, это тоже не очень хорошо и отслеживается или на код-ревью, или анализаторами, в общем, опять же, какая-то сложность, от которой бы хотелось избавиться.
2844.18 2859.22 "Анатолий Кулаков" И вот пройдя вот эти вот эволюцию, то есть сначала у нас была одна строчка, потом у нас появились какие-то define, потом эти define попытались упростить с помощью source-генератора, уже вроде получилось, но не совсем, здесь можно перейти еще к следующему шагу.
2859.22 2861.26 "Анатолий Кулаков" Что же мы еще можем сделать?
2861.26 2874.68 "Анатолий Кулаков" Мы, наверное, можем прежде всего остановиться и подумать, может, мы не туда идем, может, мы вот пытаемся сначала нагромоздили себе какую-то сложность, потом пытаемся ее упростить и все еще упростить мы не можем, а в идеале нам хотелось бы получить… А что бы в идеале хотелось получить?
2874.68 2914.50 "Анатолий Кулаков" А хотелось бы получить нам вот эту вот простую строчку, которую мы писали в самом начале, логер, trace, передали туда просто строку, передали туда просто параметры, она довольно красивая, она довольно выразительная, понятная, у нее нет избыточности кода, в общем, вот хотелось бы прийти к этому варианту, и на самом деле, уже имея текущие средства работы фреймворка, мы можем к этому прийти, именно это и делает вот эта новая библиотечка, про которую я пытаюсь вам рассказать вот в последние несколько десятков минут, библиотечка гениальная, она называется автологер-месседж, что она, собственно, делает?
2914.50 2953.70 "Анатолий Кулаков" Она позволяет вам писать вот эти логи в виде вот этой простой строчки, которую вы и сейчас пишете, то есть никаких новых привычек, никакого изменения текущего кода не нужно, то, что вы сейчас делаете, она позволяет их писать точно так же, но при этом она все вот эти логи делает таким образом, чтобы в реализации они были high-performance, то есть в реализации они используют все те рекомендации, которые нам завещал Microsoft, что позволяет на обычных логах, обычных строчках, которые в вашем коде есть, добавить 90% производительности в логах, это как раз то, что дает вот этот метод Define, и как же она это делает?
2953.70 3021.86 "Анатолий Кулаков" Давайте разберемся поконкретнее, ну, прежде всего она опирается на микрософтовский авлогер, поэтому если вы используете какой-то другой, то здесь она работать не будет, наверное, скорее всего это не проблема, прежде всего она, эта библиотечка объявляет несколько экстеншн-методов, как я уже говорил в начале, одна из больших проблем стандартных экстеншн-методов для текущего логера микрософтовского заключается в том, что передавая все параметры, он лоцирует обязательно ObjectArray, ну, как я уже говорил, прежде всего это бьет по performance, эта библиотечка объявляет кастомные generic экстеншн-ы, то есть тот же самый LogTrace, но не с ObjectArray в качестве параметров, а с одним параметром строго типизированным, с двумя параметрами и тремя параметрами, это стандартный подход, его используют абсолютно все лог-библиотеки, кроме микрософтовского экстеншн-методов, ну и не только лог-библиотеки, такая ситуация, когда вам нужно передать переменное число значений, вы не хотите аллоцировать какие-то массивы, это довольно частая ситуация, поэтому это стандартный подход и библиотека как раз объявляет вот эти методы, которые этот подход использует.
3021.86 3065.98 "Анатолий Кулаков" Подобное объявление кастомных методов с различным количеством параметров дает нам два преимущества, ну, самое очевидное преимущество в том, что у нас теперь нет боксинга, потому что мы не создаем массив объектов, мы каждый параметр засовываем в свой собственный generic параметр, generic аргумент, и второе, менее очевидный вывод из этого, заключается в том, что даже если у вас есть одинаковое имя, то есть имя, которое называется там log_trace, одинаковое имя метода, но при этом вы разложили параметры не в массив, а разложили их на четкое количество тех аргументов, которые вы передаете, компилятор выберет ваш метод, потому что он больше соответствует спецификации вызываемого метода.
3065.98 3079.10 "Анатолий Кулаков" То есть, еще раз, если вы не меняли свой код, в вашем коде написан метод log_trace, и у вас была всего-навсего одна единственная реализация, это param_object_array, то компилятор всегда вызвал ее.
3079.10 3102.52 "Анатолий Кулаков" Но если вдруг в вашем коде, случайно, откуда-то появится метод, который точно также называется log_trace, но при этом он не принимает массив объектов в качестве параметров, а принимает строгое число параметров, там один параметр, два параметра, три параметра, четыре параметра, то компилятор при следующей перекомпиляции уже будет использовать вот этот новый метод, а про старый просто забудет.
3102.52 3107.78 "Анатолий Кулаков" При этом код, который у вас уже существует, вам переделывать никак не придется.
3107.78 3119.62 "Анатолий Кулаков" Благодаря такому хаку, мы получаем, что мы легко можем как бы избавиться от боксинга и легко можем заиспользовать наши generic extension для вот этого логирования.
3119.62 3122.18 "Анатолий Кулаков" Переходим к следующему шагу, который делает библиотека.
3122.18 3126.98 "Анатолий Кулаков" Библиотека, она прежде всего эти методы нам предоставляет, но это не все, естественно.
3126.98 3129.74 "Анатолий Кулаков" Приходим к следующему методу, здесь подключается source_generator.
3129.74 3131.14 "Анатолий Кулаков" Что делает source_generator?
3131.14 3147.86 "Анатолий Кулаков" Он ищет все использования вот этих новых generic extension методов в вашем проекте, то есть сканирует просто сборку, собирает о них информацию, то есть он знает, что метод log_trace, это значит, что вы захотите записать вашу логовую запись с уровнем trace.
3147.86 3153.34 "Анатолий Кулаков" Он может определить message_template из той строки, которую передали в метод trace.
3153.34 3168.74 "Анатолий Кулаков" Он может понять, какого типа аргументы, он может эти аргументы все проанализировать, достать, в общем, у него информации полностью достаточно для того, чтобы сгенерировать вот эту define оболочку, про которую мы обсуждали выше.
3168.74 3195.86 "Анатолий Кулаков" То есть он берет log_message, log_message объявляет define со всеми теми, со всеми теми атрибутами, со всеми теми параметрами, которые вы, по идее, должны были бы проставлять вручную, но теперь вам вручную этого делать не нужно, потому что генератор всю эту информацию собрал и передал это стандартному микрософтовскому source_generator, который призван для того, чтобы оптимизировать ваши логи и сгенерить вот эти define методы.
3195.86 3205.66 "Анатолий Кулаков" И, казалось бы, уже счастье, да, вам уже не нужно руками писать все эти атрибуты, вам не нужно руками писать все эти define, уже все, source_generator автоматически для вас написал.
3205.66 3210.38 "Анатолий Кулаков" Но это еще не все, потому что теперь у нас еще есть такая прекрасная тема, как интерсепторы.
3210.38 3212.34 "Анатолий Кулаков" Что это нам позволяет сделать?
3212.34 3232.66 "Анатолий Кулаков" А это позволяет нам подменить вот эти новые наши generic extension методы, подменить с помощью реализации, которая уже опирается на те define, которые сделал микрософтовский генератор для того, чтобы ваши логи быстрее выполнялись.
3232.66 3250.54 "Анатолий Кулаков" И таким образом уже будут вызываться не наши конкретные generic extension методы, а вызов этого метода будет перенаправлен на сгенерированный код, который был сгенерирован для использования log_message_define с помощью source_generator от микрософта.
3250.54 3257.18 "Анатолий Кулаков" То есть интерсепторы перенаправляют на генератор, который сгенерировал код для того, чтобы логи ваши выполнялись быстрее.
3257.18 3260.98 "Анатолий Кулаков" И это прекрасно, и это дает нам идеальную картинку.
3260.98 3274.08 "Анатолий Кулаков" То есть вы пишете якобы те же методы, которые писали 10 лет до этого, все наши гиды их писали, вы ничего вообще не меняете, но при этом ваш код начинает выполняться с учетом всех performance рекомендаций микрософта, потому что выполняется новый метод.
3274.08 3287.74 "Анатолий Кулаков" Этот новый метод использует performance-optimized делегат, этот performance-optimized делегат с помощью интерсепторов подставляется в этот новый метод, и вуаля, получается вообще просто шикардос и красота.
3287.74 3294.00 "Анатолий Кулаков" Минусов у этого подхода не знаю, я не смог придумать.
3294.00 3304.18 "Анатолий Кулаков" По-моему, прекрасный подход, прекрасное решение, и более того, автор подумал, что было бы замечательно, если бы в стандартный комплект микрософта вся эта функциональность входила.
3304.18 3312.34 "Анатолий Кулаков" Ну, то есть нам не нужно загоняться с вот этими всякими генераторами, интерсепторами, подключать стороны библиотеки, если бы у микрософта из коробки все это было.
3312.34 3319.90 "Анатолий Кулаков" Действительно, что ему мешает, как бы просто-напросто сделать методы логирования, которые будут подставляться с уже оптимизированным кодом.
3319.90 3330.98 "Анатолий Кулаков" И он создал дискуссию в .NET Runtime, пока дискуссия не продвинулась дальше дискуссии, но я думаю, что если вы зайдете в комментарии и поддержите автора, то от этого только все выиграют.
3330.98 3350.26 "Анатолий Кулаков" Еще одно довольно неочевидное преимущество у этой липы, даже если вы не собираетесь оптимизировать логовую запись, как бы вам это не упиралось, вообще сам факт интересен, потому что, например, у вас могут быть проекты, которые переводятся со старых логовых фреймворков.
3350.26 3361.26 "Анатолий Кулаков" Ну, например, вы использовали там NLOG или LOG4NET, или еще там какие-то фреймворки, которые, наверное, давно должны были умереть, но так как у нас существует куча legacy хода, они до сих пор не умирают.
3361.26 3393.74 "Анатолий Кулаков" Ну, так вот, с помощью этого подхода, то есть сочетание анализаторов, интерсепторов и прочего, вы вполне можете вот этот переход сделать довольно прозрачным, то есть весь код, который используют синтаксис, библиотеки, методы, там, LOG4NET, вы его можете не менять, он может у вас якобы остаться работать тот же самый, то есть код останется тот же самый, но с помощью генератора и интерсептора вы можете подменить абсолютно любую реализацию и вставить в ваши старые проекты новую реализацию, например, от Microsoft, или может быть сразу с High Performance Defined методами, или что-то еще.
3393.74 3406.38 "Анатолий Кулаков" В общем, репозиторий интересен даже с точки зрения там просто образовательного исследования, то есть каким образом написать такой генератор, такой интерсептор, чтобы вот это все вместе связать, как старым методом прицепить новую реализацию.
3406.38 3410.70 "Анатолий Кулаков" Казалось бы, задача довольно распространенная, бывает часто нужна.
3410.70 3425.34 "Анатолий Кулаков" Ну и вообще, я думаю, что идея гениальная, она обязательно требует вашей поддержки, поэтому все, кто залогинен, зарегистрирован на GitHub, пройдите, поставьте автору звездочку в репозитории GitHub, давайте поддержим хорошие проекты.
3425.34 3438.30 "Анатолий Кулаков" Ну и вообще, если вы знаете какие-нибудь хорошие проекты open-source, а самое главное, если вы являетесь автором какого-нибудь из подобных проектов, обязательно напишите нам, мы озвучим самые интересные из них в наших выпусках.
3438.30 3440.62 "Анатолий Кулаков" Вот такая классная библиотечка.
3440.62 3444.14 "Игорь Лабутин" Да вообще прекрасная, я посмотрел, даже Фаулеру понравилось.
3444.14 3452.82 "Игорь Лабутин" И на том самом обсуждении на GitHub отметился сам Дэвид Фаулер с отзывами, вау, cool use of interceptors, так что…
3452.82 3471.74 "Анатолий Кулаков" Да, они там сейчас застопорились на Event ID, который там пробрасывается, и действительно вот эта концепция вся Event ID, которую вы не видите в ваших обычных логах, но она существует в High Performance Defined вот этих логах, она такая, она правильная, она хорошая, но реализация у нее довольно сомнительная.
3471.74 3484.68 "Анатолий Кулаков" И вот сейчас уперлись в эту сомнительную реализацию, не знаю, надо как-нибудь влезть и поподробнее там зарыться и рассказать, и описать, и больше примеров привести.
3484.68 3486.74 "Анатолий Кулаков" В общем, как-то с мертвой строчки сюда сдвинуть.
3486.74 3499.54 "Игорь Лабутин" Ну поглядим, пока там действительно, там сейчас пока есть коммент от автора, соответственно, ждем реакции от Дэвида Фаулера, посмотрим, что скажет, может быть и будет нормально.
3499.54 3515.78 "Игорь Лабутин" Я так подозреваю, что сейчас они сильно заняты планированием скоупа на десятый юнет, и может быть именно поэтому пока не такая большая активность, но вообще действительно классная такая тема, что вроде как ты подключаешь какой-то Nuget пакетик, и у тебя весь старый код работает быстро, шустро и так далее.
3515.78 3517.94 "Игорь Лабутин" Это прекрасно.
3517.94 3537.70 "Анатолий Кулаков" Вообще вот сам подход, представляешь, ты же можешь под сути так стеночку и в любом магазинчике убрать, то есть у тебя любой код берешь, который делает запросы к базе данных, и говоришь, что теперь мне этот запрос к базе данных по правде не будет никакой использовать, а вот вам уже сгенерированный сиквел, и просто этот сиквел выполним и все.
3537.70 3541.26 "Анатолий Кулаков" И даже маппер туда же можно писать, и даже сформировать дтшку.
3541.26 3547.78 "Игорь Лабутин" Так, так, так, погоди, погоди, и сразу вернуть данные, да, чтобы не это, и вообще в базу не ходить.
3547.78 3551.94 "Анатолий Кулаков" Да, да, данные все можно в памяти уже сразу держать.
3551.94 3552.94 "Анатолий Кулаков" Вот.
3552.94 3556.50 "Анатолий Кулаков" Нет, просто идея богата, и да, я думаю, что можно ее куда-нибудь еще тоже прилепить.
3556.50 3558.90 "Анатолий Кулаков" Главное — держать себя в руках.
3558.90 3559.90 "Игорь Лабутин" Да.
3559.90 3560.90 "Игорь Лабутин" Дальше.
3560.90 3563.86 "Игорь Лабутин" Дальше у нас еще одна такая относительно абстрактная статья.
3563.86 3576.06 "Игорь Лабутин" Вернее как, статья очень конкретная, она относится к донетпанку по стольку-поскольку, но важная тема, интересная, и много кто наверняка с ней сталкивался, а именно про то, как хранить деньги.
3576.06 3586.54 "Игорь Лабутин" Не в смысле, где и в какой банке их хранить, а в смысле, как хранить значения каких-нибудь сумм, там, цен и так далее, когда вы что-то программируете, связанное с деньгами.
3586.54 3594.74 "Анатолий Кулаков" Ну, все дутьнечики хранят деньги, поэтому да, надо не только зарабатывать, но и хранить.
3594.74 3595.74 "Игорь Лабутин" Да.
3595.74 3602.80 "Игорь Лабутин" Какие у нас есть факты про то, что мы знаем про валюты и про деньги.
3602.80 3629.94 "Игорь Лабутин" Во-первых, у нас есть стандарт, у нас есть стандарт ISO 4217, это стандарт про валюты, он описывает те самые коды валюты, именно оттуда пошли всякие USD и вот это все, плюс описывает то, какие грубо говоря, в английском это называется minor units, в русском мы это часто называем копейками, то есть, на что делится ваша основная валюта и делится ли.
3629.94 3634.14 "Игорь Лабутин" Валюта имеет трехбуквенный код, она имеет числовой код и она имеет название.
3634.14 3645.66 "Игорь Лабутин" Большинство валют имеет два знака после запятой, но некоторые валюты не имеют вообще никаких знаков после запятой, бывают только целыми, а некоторые имеют три знака после запятой.
3645.66 3650.54 "Анатолий Кулаков" А бывает трехкратное деление, то есть, копейки и еще микрокопейки?
3650.54 3674.34 "Игорь Лабутин" Нет, такого нигде вроде нет, по крайней мере, стандарт такого не предусматривает, но зато есть две страны, Мавритания и Мадагаскар, которые не используют десятичное разделение валюты, ну, практически везде мы все-таки делим на, по десятичной системе, то есть, в одном рубле сто копеек, в одном долларе сто центов, несмотря на то, что Америка в целом живет не на метрической системе, но в деньгах все-таки система метрическая.
3674.34 3676.78 "Анатолий Кулаков" А эти шестнадцатиличные, наверное, используют?
3676.78 3687.34 "Игорь Лабутин" Нет, они получаются пятеричные, что ли, там одна их, я не буду пытаться прочитать название, равна, ну, грубо говоря, как если бы у нас один рубль был равен пяти копейкам.
3687.34 3692.70 "Игорь Лабутин" То есть, она такая, как бы, не на десять делим, а на пять.
3692.70 3698.54 "Игорь Лабутин" И это может доставлять интересный спецэффект, если вы вдруг внезапно поддерживаете такие валюты.
3698.54 3712.42 "Игорь Лабутин" О, продолжаем дальше, как я сказал, большинство валют имеет два знака после запятой, некоторые не имеют вообще, некоторые имеют три знака после запятой, но если вдруг вы работаете с криптовалютами, то там может быть до восемнадцати знаков после запятой, и все они значимы.
3712.42 3725.58 "Игорь Лабутин" Дальше, количество знаков после запятой, и в этот момент, когда я читал статью, я понял, что валюта это ничуть не проще, чем таймзоны со своими изменениями часовых поясов, дейлайтс, тайминг и так далее.
3725.58 3733.46 "Игорь Лабутин" Количество знаков после запятой в валюте может меняться со временем, из-за всяких динаминаций, реноминаций и прочего.
3733.46 3752.82 "Игорь Лабутин" То есть можно взять, в какой-то момент может так случиться, допустим взять и сказать, что теперь в России в одном рубле, не знаю, десять копеек, ну вот не надо нам ничего делить на сто уже, давайте будем делить на десять, и будет у нас десять копеек самое минимальное, в смысле всего на десять копеек.
3752.82 3787.34 "Игорь Лабутин" Дальше, не всегда, даже если ваша валюта делится например на десять майнор юнитов, или на сто майнор юнитов, как в России допустим, или как в Штатах, когда мы делим на центы, не всегда минимальная сумма представима в физическом мире, то есть есть валюты, в которых грубо говоря сто копеек, но физическая монетка минимальная, это например десять копеек, то есть одну копейку вы никак не сможете заплатить одну копейку физическими деньгами, минимум десять, а в валюте тем не менее сто как бы этих самых делений.
3787.34 3812.70 "Игорь Лабутин" Дальше, и как ни странно, не смотря на то, что, не как ни странно, в принципе это понятно, но тем не менее, не смотря на то, что стандарт говорит, сколько у вас знаков после запятой есть в той или иной валюте, но для хранения цены того или иного товара вам может потребоваться больше знаков после запятой, чем то, сколько есть в валюте.
3812.70 3829.30 "Игорь Лабутин" Например, если вы считаете цену какого-нибудь одного айтема из группы и стоимость группы, которая выражена наверняка в нормальной валюте, стоимость какого-то бандла, надо поделить на количество айтемов, и тогда у вас естественно могут возникнуть дополнительные знаки после запятой.
3829.30 3840.94 "Игорь Лабутин" Дальше, что статья рекомендует с точки зрения, точнее не то, что рекомендует, а какие у нас есть требования к хранению.
3840.94 3852.62 "Игорь Лабутин" То есть какой у нас есть минимальный необходимый набор свойств нашего хранилища, которые позволят работать нормально с валютами и не терять особо данные.
3852.62 3857.14 "Игорь Лабутин" Во-первых, мы обязаны хранить сумму вместе со ссылкой на валюту.
3857.14 3864.44 "Игорь Лабутин" Ну, это вроде как очевидно, понятно, что если мы будем хранить без ссылки на валюту, мы не будем знать, что это такое 120 в базе данных.
3864.44 3865.44 "Игорь Лабутин" Конечно, если ваша…
3865.44 3872.94 "Анатолий Кулаков" Но ты же можешь не ссылку хранить, ты можешь прямо колонку назвать рублей, доллары и все, грубо говоря, никакая ссылка…
3872.94 3914.46 "Игорь Лабутин" Ну да, если вы работаете с одной или с двумя валютами, может быть такое допустимо, но вспоминаем, что валюта может меняться со временем, понятно, что закладываться на это может быть, это будет оверкилом с самого начала, но и depends, что называется, и если вы работаете, например, на тех рынках, где, например, ну, относительно велика вероятность, я не знаю, правда, как ее считать, того, что что-то могут сделать с валютой, то может быть имеет смысл где-то отдельно схоронить в базе спецификацию валюты, да, то есть сколько в тот или иной период у вас было знаков после запятой, например.
3914.46 3937.18 "Игорь Лабутин" Дальше, нужно хранить минимальную учитываемую единицу, ну то есть либо в дополнение, либо вместо точности, то есть, грубо говоря, либо мы храним все в копейках, да, либо мы помним, ну, где-то храним, что у нас в одном рубле 100 копеек, то есть что точность два знака после запятой, иначе вы не сможете ничего преобразовать туда-сюда.
3937.18 3956.10 "Игорь Лабутин" Дальше нужно обязательно, ну не то что обязательно, но рекомендуется хранить минимально представимую физическую единицу валюты, чтобы не получилось так, что на кассе в магазине вы скажете, что вам нужно покупателю, если мы, например, в России выдать полкопейки, ну вот не получится.
3956.10 3969.78 "Игорь Лабутин" Дальше, точность хранения сумм должна быть, ну это очевидное требование, достаточной для всех поддерживаемых валют, если вы работаете с криптой, добро пожаловать в 18 знаков после запятой, вот, и для…
3969.78 3975.38 "Анатолий Кулаков" Это не предел, подожди, биткоин только растёт, я думаю, там скоро будет и 64 знака после запятой.
3975.38 3982.30 "Игорь Лабутин" Ну нет, там, по-моему, архитектурно заложено ограничение, что там всегда именно 18 знаков после запятой, мне кажется.
3982.30 3992.30 "Игорь Лабутин" Я не спец по крипте, я сразу говорю, наверное, я сейчас говорю чушь, но, по-моему, там именно смысл был в том, что там всегда строго 18 знаков после запятой.
3992.30 4011.10 "Игорь Лабутин" Дальше, и может потребоваться, как я сказал, несколько большее точность, потому что если вы делите цены или если вы считаете, например, проценты за какие-то комиссии, то понятно, что могут получаться суммы меньше, чем минимально предоставимая сумма, и надо тогда держать большую точность.
4011.10 4023.38 "Игорь Лабутин" Ну, всё вроде как очевидно, хорошо и понятно, и дальше возникает вопрос, а в каком типе данных это всё хранить, в смысле, представлять в коде, и в каком типе данных это всё хранить в BD.
4023.38 4031.74 "Игорь Лабутин" Обычно этот вопрос очень любят на собеседованиях, ну, может быть, не очень, но довольно часто его задают на собеседованиях и так далее.
4031.74 4042.06 "Игорь Лабутин" Можно хранить в виде целых чисел, целые числа в копейках, значит, довольно популярный формат, то есть мы храним не 5 рублей, а мы храним 500 копеек.
4042.06 4062.02 "Игорь Лабутин" Возможно, если вам нужна дополнительная точность, те самые проценты или какие-то дроби, в смысле, части, кусочки и так далее, то тут как раз могут возникнуть необходимости хранить в тех самых микрокопейках, про которые ты спрашиваешь, то есть хранить не 5 рублей, а, например, 5 миллионов микрокопеек.
4062.02 4079.86 "Игорь Лабутин" Понятно, что никогда микрокопейки не будут в реальном мире, но и вам поэтому и нужно помнить, что на самом деле это для получения реальной суммы в рублях нужно умножить на 6, ну, в смысле, на 10/6, но может быть, полезно для каких-то операционных расходов или описания.
4079.86 4084.44 "Анатолий Кулаков" В идеале тебе нужно, по идее, хранить 18 знаков после пятерки, да?
4084.44 4089.40 "Игорь Лабутин" Ну, типа того, да-да-да-да-да-да-да, это если ты знаешь, что ты работаешь с криптовалютами.
4089.40 4116.68 "Игорь Лабутин" И возникают, естественно, вот те самые проблемы, про что как раз я сейчас только что сказал, если нужно, то есть тебе нужно заранее знать точность, поскольку если ты уже начнешь все писать, например, в честных копейках, ну, предположим, что тебе не нужны дробные копейки, ты начнешь писать в копейках, хотя придут просты, теперь мы поддерживаем крипту и такой, опа, ну, как бы здорово, но лучше все-таки попытаться знать заранее.
4116.68 4134.28 "Игорь Лабутин" Дальше это все немножко усложняет логику, понятное дело, то есть все это нужно преобразовывать в нормальный вид, и в базе это все хранится, ну, не так очевидно, иногда если заглядываешь в базу, ты будешь видеть суммы в копейках, ну, чуть менее удобно работать, не критично, но просто чуть менее удобно.
4134.28 4150.16 "Игорь Лабутин" Если вдруг изменяется характеристика валюты, то есть, например, добавляются разряды после запятой, то это как бы очень сложная миграция BD, вам нужно будет пересчитать все в новые копейки, это просто может быть очень много данных, и долго, и нудно, и зачем.
4150.16 4173.64 "Игорь Лабутин" Для сторонней систем, понятно, что тоже нужно все это конвертировать, ну, можно частично решить эту проблему, сохраняя не только саму сумму, но и рядом сохраняя точность, то есть, грубо говоря, хранить не только 500 копеек, а рядом еще колоночка, где будет написано "Precision = 2", грубо говоря, ну, или там 100, на что нужно, грубо говоря, поделить, чтобы получить номинальную обычную валюту.
4173.64 4174.82 "Игорь Лабутин" Тогда может быть чуть проще.
4174.82 4179.32 "Игорь Лабутин" Это один вариант.
4179.32 4194.72 "Игорь Лабутин" Дальше в статье рассматривается тип BigInt, и отдельно подчеркнется, это не тот BigInt, который вы знаете по базам данных, вот это именно честный BigInt из каких-нибудь древних занятий по программированию, из школьных уроков, тип с произвольной точностью.
4194.72 4201.60 "Игорь Лабутин" Все же, наверное, реализовывали когда-нибудь математику произвольной точности, для задачек или еще для чего-то.
4201.60 4221.60 "Игорь Лабутин" Если вы храните микроюниты, то есть, если у вас действительно там много-много знаков после запятой и много-много знаков до запятой, то, скорее всего, существующие числовые типы вам просто в них не влезут, и вам придется использовать какой-нибудь такой BigInt для хранения произвольной точности.
4221.60 4228.24 "Анатолий Кулаков" Можно заметить, что произвольная точность в нашем случае правильнее бы назвать бесконечная большая точность.
4228.24 4236.48 "Игорь Лабутин" Ну да, ограниченная только вашей памятью и разумностью, грубо говоря.
4236.48 4258.24 "Игорь Лабутин" И вот здесь как раз говорится, что для того, чтобы возникнула проблема, BigInt это все здорово, в памяти мы можем делать все что угодно, как хранить в базе, в базу можно сохранять двумя способами, либо как decimal, который тоже во многих базах может быть довольно-таки произвольным, там есть ограничение, но довольно произвольной точностью, либо даже вообще прям просто как строку, то есть реализовывать каждый раз строчку и сохранять строчку.
4258.24 4265.84 "Игорь Лабутин" Желательно, конечно, в invariant culture, чтобы не мучиться потом со всякими точками, запятыми и так далее.
4265.84 4305.36 "Игорь Лабутин" И если вам не нужна суперточность, в смысле супер, большое количество знаков после запятой, а все-таки большинство валют, как я сказал, имеет 2,3 знака после запятой, то может быть будет достаточно int64, но если крипта, то вам будет, может быть, недостаточно, а второе, что int64 в некоторых языках, например в Go, для операций требует, для некоторых операций будет требовать конверсии во float64, а это значит деньги и float несовместимы, то есть нужно очень аккуратно подходить к хранению, как int64.
4305.36 4322.16 "Игорь Лабутин" Дальше, если мы отказываемся от сохранения целых чисел и хотим хранить таки дробные, можно рассмотреть тип decimal, который, соответственно, есть во многих BD, он же поддерживается довольно много, многими языками, так или иначе, нативно, либо с помощью сторонних библиотек.
4322.16 4330.72 "Игорь Лабутин" Есть, соответственно, разные, некоторые разные реализации децималов с точки зрения и баз, и языков.
4330.72 4346.76 "Игорь Лабутин" В статье указано, что, например, есть decimal 128, так называемый, который поддерживает некоторое ограниченное количество знаков все-таки, то есть у него есть некоторый верхний предел того, сколько вы туда можете запихнуть значащих разрядов, и такое поддерживается в Monga и в C#.
4346.76 4359.00 "Игорь Лабутин" Я, кстати, не помню, какое у нас ограничение decimal в C# с точки зрения количества знаков, как-то не надо было больше, по-моему, 20, что ли, или 30 никогда хранить, но, наверное, какое-то есть.
4359.00 4372.48 "Игорь Лабутин" Ну и бывает big decimal, это как раз таки в SQL он такой, в смысле в, да, в SQL-сервере, в SQL-сервере как минимум точно, и, например, Java, да, big decimal, там типа как раз по абсолютно произвольной точности.
4372.48 4391.64 "Игорь Лабутин" Но тут у вас будут проблемы с производительностью, потому что понятно, что математика произвольной точности, она не так быстра, как нативные типы, но зато есть преимущество, вы храните это все-таки в том же виде, как вы с этим обращаетесь в реальном мире, то есть не нужно все это в уме переводить вечно из копеек в нормальные деньги.
4391.64 4436.68 "Игорь Лабутин" Дальше, если во-вторых, у вас меняется количество этих самых знаков после запятой, то в большом счете вам нужно просто, если, например, вы храните это все в колонке, поменять у колонки precision, и существующие значения менять не надо, то есть к ним просто автоматически дорисуется нолик при десериализации, при чтении из базы, или что-то и будет все нормально, ну, можно… А, и когда сериализуете строчку, опять же, вам точно известно, где у вас находится десятичный разделитель, да, вам не нужно таскать за собой точность этого значения и так далее, но опять же, помните, что decimal, это, конечно, хорошо, точность менять можно относительно легко, но лучше все-таки заранее зарезервировать нужную.
4436.68 4447.56 "Анатолий Кулаков" Ну, и про decimal хочется отметить, что обычно все-таки decimal – это дефолтная реализация денег, если вы не хотите ни о чем задумываться, то обычно это легче всего и нужнее всего.
4447.56 4478.96 "Игорь Лабутин" Да, обычно там не нужны прям такие performance-performance вычисления, то есть от того, что оно будет чуть-чуть медленнее, ничего страшного, зато точнее, потому что если мы пойдем во float double, то там будет все плохо, ну, просто потому что деньги считаются у нас по основанию 10, а float double работает по основанию 2, и, соответственно, в силу того, что не все значения целочисленные представимы в float double, то могут быть потери точности, в том числе просто в математических операциях даже, поскольку разные основания системы счисления.
4478.96 4479.96 "Игорь Лабутин" А еще…
4479.96 4495.64 "Анатолий Кулаков" Мне кажется, что на собеседованиях, когда спрашивают вот эту тему про как раз в чем бы вы хранили деньги, то может быть и можно там порассуждать, кто будет в decimal или кто в int хранить, но если кто-то скажет во float или double, то это сразу вот вон из профессии и все, и дальше можно не разговаривать.
4495.64 4523.60 "Игорь Лабутин" А если вы работаете с SQL-сервером, то вы, может быть, знаете, что в SQL-сервере есть такой специальный тип, называется money, и глядя на тип, который называется money, ну, первое желание использовать его для хранения денег, но на самом деле этого делать не надо, потому что внутри это int64, и как я сказал, не все языки, не все платформы int64 нормально переваривают, поэтому лучше все-таки посмотреть в сторону decimal.
4523.60 4557.80 "Игорь Лабутин" А дальше возникает вопрос, что на самом деле далеко не всегда при работе с деньгами вам будет достаточно хранить одно число, проблема в том, что вам может быть необходимо хранить дроби, типа там 1/3 от чего-то, при этом, как вы понимаете, просто посчитать 1/3 в decimal вы сможете только с округлением, и если вы потом такое число умножите, скажем, на 30, то вы должны бы в реальном мире получить 10, а в компьютере вы получите не 10, а поменьше немножко из-за округления, что-то примерное.
4557.80 4571.44 "Игорь Лабутин" Decimal такой не может делать, и тогда, если вам вдруг критически важно хранить вот такие вот дроби, так чтобы математические выражения с ними были нормальными, вам придется хранить числитель и знаменатель отдельно в базе данных.
4571.44 4638.32 "Игорь Лабутин" Такой подход нужен действительно только если вам критически это важно, либо если вы по какой-то причине пишете софт, который работает с какими-то очень старыми валютами, когда действительно, например, не делилось на 10, а делилось на какое-нибудь странное число, типа на 12 или еще что-то такое, вот там может быть действительно такой операции будут полезны, но тогда, понятное дело, всякие там суммы и прочее придется реализовывать как нормальную, нормальные алгебраические операции, это прямо надо постараться, хотя есть библиотеки, которые такое поддерживают, и даже, по крайней мере, автору статьи известно только по сгря, которые имеют прям расширение PGRational, в котором есть специальный тип, который позволяет хранить вот эти дроби, грубо говоря, прям в BD, в одной колонке, ну а в других BD придется хранить две разные колонки, числитель и знаменатель, аккуратненько правильно десериализовывать в код, и дальше в коде, если у вас есть доступная библиотека с какой-нибудь алгебраическим математикой, как раз используя для вычислений, если вам зачем-то это надо.
4638.32 4647.40 "Анатолий Кулаков" Мне кажется, хранение это не так страшно, действительно, завел два поля или две колонки, да и хранить себя на здоровье, а вот математику на ней реализовать, вот это уже будет повеселее.
4647.40 4659.36 "Игорь Лабутин" Ну, именно поэтому в это надо идти, только если вы точно понимаете, что вам это зачем-то надо, вам вот действительно нужно уметь там поделить на 3, а потом умножить на 30 и получить в результате исходное число, умноженное на 10, а не приблизительно.
4659.36 4674.04 "Игорь Лабутин" Такие дела, довольно краткая, но очень по делу емкая статья, из которой можно почерпнуть, по крайней мере, основные моменты того, как хранить именно деньги.
4674.04 4723.28 "Игорь Лабутин" Понятно, что этим тема не исчерпывается, в деньгах есть много еще очень всего интересного, например, если для того же самого деления на 3 вам не нужно, например, хранить здоровье, вам просто нужно аккуратно поделить на 3, вы же не можете сказать, что вы всем дадите по 3 в периоде копейки, да, вам нужно кому-то дать 3 копейки, а кому-то 4 копейки, и как вот это все учитывать, как это все считать, это уже по большому счету бизнес-логика, это все нужно обговаривать с теми, кто ответственен за бизнес-логику вашего продукта и понимать, как это все делится, потому что даже такая копейка, которую вы как-то случайно перераспределяете между всеми при делении, может на что-то сильно повлиять с точки зрения каких-то там, не знаю, расчетов, налогов, еще чего-нибудь, сходимости суммы и прочего, так что очень аккуратно обращайтесь с деньгами в коде, ну и не в коде тоже.
4723.28 4727.96 "Анатолий Кулаков" Храните деньги в заберегательной кассе.
4727.96 4728.96 "Анатолий Кулаков" Типа того.
4728.96 4746.26 "Анатолий Кулаков" Вообще, мне кажется, это вот отдать из тех фундаментальных тем, которые, наверное, можно называть их сложными, но которые обязаны Джуны просто знать с самого рождения, это вот работа с датовременем и работа с деньгами, может быть, даже еще какой-нибудь такой фундаментальный можно подтянуть, можно подвести.
4746.26 4761.14 "Анатолий Кулаков" Не обязательно вот знать все тонкости, не обязательно понимать вглубь, что там случится, если вы вдруг там сконвертируете какие-нибудь персональные числа, но основные постулаты типа, что можно использовать, что нельзя использовать, вот это вот надо знать просто со школьной скамейки.
4761.14 4766.06 "Игорь Лабутин" Ну, мы стараемся по мере сил рассказывать про какие-то такие моменты.
4766.06 4774.50 "Игорь Лабутин" Скажите, кстати, нам, расскажите в комментах, полезны ли такие отвлечения прям на вообще не дотнетные темы, вот.
4774.50 4784.02 "Игорь Лабутин" И может быть, есть еще какие-то темы, про которые нам стоит прям целенаправленно поискать статьи и какой-нибудь такой ликбез кразенький устроить, с удовольствием поищем.
4784.02 4787.40 "Анатолий Кулаков" Я бы не сказал, что вообще не дотнетные, это же программистская тема.
4787.40 4788.40 "Анатолий Кулаков" Фундаментальные.
4788.40 4799.02 "Игорь Лабутин" Фундаментальные, да, фундаментальные, но все-таки есть какие-то границы, мы все-таки радио Дотнет, про новости вокруг Дотнета, так мы изначально собирались быть.
4799.02 4802.74 "Игорь Лабутин" Но, кажется, новостей становится так мало, что мы это, да.
4802.74 4810.86 "Анатолий Кулаков" Да, мне кажется, наоборот, мы просто фундаментальный подкаст для программистов на Дотнете, а программисты на Дотнете, они не только Дотнет, они еще и программисты.
4810.86 4815.54 "Анатолий Кулаков" А каждый программист должен уметь работать с деньгами и датой времени, поэтому надо, надо.
4815.54 4840.10 "Анатолий Кулаков" Кстати, насчет нарушения границ и все такое, я там, когда доедал прошлогодний салат, прошлогоднее оливье, наткнулся на интересную статейку, которую вот под конец выпуска, кажется, надо обсудить, особенно такого расслабленного предновогоднего, постновогоднего, наткнулся я на авторов замечательной библиотеки OpenSilver, которые на хабре написали удивительный анонс, что вышла какая-то версия 3.
4840.10 4844.14 "Анатолий Кулаков" И я полез посмотреть, что же это такое за версия 3, из чего он выпадет, OpenSilver и зачем он нужен.
4844.14 4849.38 "Анатолий Кулаков" И оказывается, что это open-source наследник платформы Silverlight.
4849.38 4853.18 "Анатолий Кулаков" Ты знаешь такую, ну, застал, писал?
4853.18 4860.06 "Игорь Лабутин" Ну, застал, но практически никогда не писал, по-моему, я один раз что-то под нее кому-то где-то что-то подправил, но особо не писал, нет.
4860.06 4868.46 "Анатолий Кулаков" Ну, вот для тех, кто мало с ней сталкивался, я в принципе пописал немножко, поуспел, но тоже не очень много.
4868.46 4881.74 "Анатолий Кулаков" Напомню, напомню, Microsoft изначально создала Silverlight как конкурент замена новой эволюции в аду флеша, блин, наверняка наши слушатели не знают, что когда флеш.
4881.74 4903.42 "Анатолий Кулаков" Был браузер, и этот блаузер был очень медленным, потому что стандарт HTML в то время практически стагнировал, он вообще никак не развивался, а люди наоборот, у них появились какие-то видосики, анимации, гифки и прочие вот эти радости, они хотели больше какой-то интерактивщины, какой-то анимации, каких-то красюлик, и им нужен был инструмент, чтобы это все выразить.
4903.42 4919.70 "Анатолий Кулаков" И Microsoft создал такую платформу, которую назвал Silverlight, это как раз-таки возможность была запускать в браузере трехмерные фигурки крутить, делать игры, делать какие-то мультимедийные системы, в общем, очень много всего было такого красивого, именно мощного, на ней можно было делать.
4919.70 4926.54 "Анатолий Кулаков" А у нее была критическая проблема, чтобы это все у вас в браузере работало, вам нужно было поставить плагин.
4926.54 4939.10 "Анатолий Кулаков" Многие люди не любят ставить плагины, особенно в то время еще зарождалось как раз бум мобильных смартфонов, и в смартфонах опять же были браузеры, которые тоже не очень дружили с плагинами.
4939.10 4941.38 "Анатолий Кулаков" Вот на плагинах они довольно сильно погорели.
4941.38 4952.78 "Анатолий Кулаков" Но сама идея была интересная, идея была в следующем, давайте засунем XAML, а XAML уже к тому времени себя отлично показал на десктоп-приложениях, то есть когда .dpf как бы цвел, летел и пахнул.
4952.78 4960.86 "Анатолий Кулаков" В общем, давайте возьмем этот .dpf, но .dpf вам было слишком сложно, давайте возьмем ее небольшое подмножество, такое, которое можно легко и быстро отендрить в браузере.
4960.86 4975.44 "Анатолий Кулаков" То есть некое подмножество .dpf, а он все еще XAML, давайте напишем логику на .NET, в частности на C#, засунем это в браузер, браузер это все заинтерпретирует и выдаст нам .NET на десктоп-приложение практически, но только в браузере.
4975.44 4985.38 "Анатолий Кулаков" Это будет у нас кроссплатформенно, это будет у нас переноситься между разными браузерами, то есть у нас не нужно тратить время на обновление какого-то сервера, еще чего-то.
4985.38 4992.42 "Анатолий Кулаков" В общем, то, к чему мы сейчас приходим с Blazor, по сути было задано Silverlight, вся эта идея.
4992.42 5001.02 "Анатолий Кулаков" Silverlight задал никак, основоположник этого всего, до него были и Flash, и другие какие-то плагины, которые эту же концепцию пропагандировали.
5001.02 5011.94 "Анатолий Кулаков" Это лишь подход, вариация от Microsoft, но подход и вариация довольно интересные, опять же, потому что C#-разработчик мог применить свои знания в веб-браузере без всяких как бы проблем.
5011.94 5020.10 "Анатолий Кулаков" Именно тот лозунг, тот постулат, который сейчас пропагандируется в Blazor и это, опять же, довольно летит, то есть история по спирали, история идет по спирали.
5020.10 5050.22 "Анатолий Кулаков" Ну и более того, Silverlight до конца не умер, потому что огромный кусок Silverlight был использован для того, чтобы сделать кроссплатформенный .NET, потому что мы говорим, Silverlight это не только визуальная часть, которая там под браузер как-то рендерилась, это плюс еще кроссплатформенный C#, и когда мы пользуемся каждым кором, то там большая часть это как раз наследие исследования команды Silverlight, поэтому, дружок, мы тебя помним, ты с нами.
5050.22 5060.06 "Анатолий Кулаков" Но, как вы, наверное, поняли, Microsoft Silverlight закрыл по тем или иным причинам, плагины, тяжеловесность, поддерживаемость, все это неважно, хотите, почитайте в энциклопедии.
5060.06 5087.06 "Анатолий Кулаков" Но, опять же, Microsoft умеет толкать технологии и умеет продавать большим компаниям свои технологии, и к тому моменту, когда Silverlight он закрыл, уже было очень много всего написано, компонентов, там, программочек старых уже было написано на Silverlight, и людям это все, естественно, переписывать не очень хотелось, и после этого как бы независимая команда решила создать open-source реализацию Silverlight, и назвали они ее как раз таки OpenSilver.
5087.06 5124.26 "Анатолий Кулаков" Она 100% совместима должна была быть Silverlight, ну, по идее, есть Silverlight, полностью бесплатная, концепции используют те же самые, то есть вы пишете интерфейс на XAML, вы пишете логику на C#, F#, Visual Basic, если вдруг захотите, и вы получаете на выходе веб-приложение, без использования HTML, вот этих вот дурацких заголовков, про которые мы разговаривали, без вот этого кривого CSS, который они могут допилить уже несколько десятков лет, без богом проклятого JavaScript, который языком программирования только с трудом можно назвать, в общем, без вот этих всех старых, унылых, ущербных, убогих технологий.
5124.26 5237.10 "Анатолий Кулаков" Вы получаете на чистом XAML, на чистом C#, веб-приложение, которое работает во всех браузерах, на всех платформах, ну, и опять же, если вы хотите добавить туда HTML, CSS и JavaScript, никто вам не мешает, там, interoperability просто шикарная, и все это вот вам предлагает OpenSilver, еще раз, можно запускать на Windows, Android, Mac'ах, Google Chrome'ах, Firefox'ах, Safari, то есть любых браузерах, на любых платформах, в этот раз без плагина, безусловно, благодаря тому, что эта штука теперь работает не с помощью какого-то специального плагина, который устанавливается в ваш браузер, как это делал Microsoft, нет, OpenSilver пошел по современным технологиям, он берет C#, XAML или вообще любой .NET и компилирует их в WebAssembly, HTML и CSS, то есть сейчас HTML и CSS, они стали такой, довольно мощными по сравнению с тем временем, когда необходим был плагин для того, чтобы более-менее вменяемо отобразить и одинаково во всех браузерах, самое главное, сейчас нет, сейчас вот этот стандарт HTML и CSS, он довольно хорошо поддерживается всеми современными браузерами, поэтому плагин не нужен, и сейчас у нас есть стандарт WebAssembly, опять же, для которых не нужен плагин для интерпретации или кода для интерпретации C#, у нас WebAssembly прекрасно интерпретируется, а C# прекрасно компилируется в WebAssembly, и вот мы получаем такую прикольную связь, все это у нас бесплатное, open-source, mid-лицензия, то есть вообще красота, со всех сторон красота, и более того, если вы хотите, например, чтобы ваш C# и XAML компилировался не в WebAssembly, а, например, в JavaScript, ну, потому что у вас там есть команда с JavaScript, может быть, вы хотите как-то больше дебажить там или лучше это видеть, то есть смежный проект, который называется cshtml5, он как раз компилирует XAML, C#, .NET, JavaScript, HTML, CSS, в общем, тут они рядом ходят в этих проектах.
5237.10 5295.14 "Анатолий Кулаков" Ну, вот, почему меня это заинтересовало, да, кому нужен server-light, кому нужен open-light, ведь, знаешь, я вот сел и задумался, вот какой бы идеальный фреймворк для UI я бы хотел, я человек как раз, который застал расцвет .dpf, и я очень много использовал UI-ных фреймворков, я на GTK, на Qt писал, и самое ужасное, что я очень много верстал страничек и на HTML, и на CSS, и с использованием JavaScript этих хаков, и, безусловно, самое крутое, что придумало человечество на данный момент, это XAML, и там .dpf, его расширение, которые пошли потом, это, безусловно, самое лучшее, что сейчас и вообще человечество выдумало для UI, по моему мнению, и если вот выбирать, как бы я хотел видеть UI, я бы хотел видеть прежде всего на XAML, да, и тут как раз вот этот проект замечательно подходит.
5295.14 5357.58 "Анатолий Кулаков" Затем мы говорим, а на чем бы ты хотел писать бизнес-логику, ну, тут, безусловно, как бы выбор очевиден, на C#, то есть хотелось бы на XAML, на C# писать какие-то визуальные формочки, визуальные приложения, ну, и, безусловно, не под десктоп все это делать, потому что, как бы, как ни крути, а браузер захватил умы, и хотелось бы, чтобы у нас C# и XAML были в вебе, и вот сочетание вот этих трех пожеланий, C#, XAML и веб, оно, наверное, сейчас мало кем реализуется из современных библиотек, а здесь смотри, вот тебе, пожалуйста, вот тебе прекрасный проект OpenSilver, который все эти пожелания реализует, почему-то они на своем сайте все время кричат, что мы чисто для совместимости с Legacy кодом, мы только про старый код, мы поддерживаем все хорошо на старом коде, то есть на старом сервере Silverlight, но при этом они развиваются, при этом они работают, и вот позиционирование почему-то для новых проектов, в отличие там от Avalon, от MyUIA, от Uno Framework, вот для новых проектов он почему-то себя не позиционирует.
5357.58 5368.42 "Анатолий Кулаков" Интересно, в принципе, почему, потому что все современные там WebAssembly, HTML5, вот все это у них есть, все это они делают, не очень ясно. Ну и прошло, собственно, статья.
5368.42 5427.02 "Анатолий Кулаков" На статье про то, что вышел UI-дизайнер у этого OpenSilver, он поддерживается в Visual Studio в качестве плагина, в Visual Studio коде, здесь у нас есть более 100 компонентов, в UI-дизайнере они поддерживаются с помощью DarkenDrop, визуальное дерево с учетом шаблонов, синхронизация между XAML-редактором и редактированием XAML вручную, в обе стороны они прекрасно синхронизируются и все такое. А, и как подтверждение моих слов, что как бы это очень мощный и интересный инструмент, после того, как, друзья, сделали UI-дизайнер, они перенесли его в Web, ну так как сам дизайнер был написан на OpenSilver, по идее никакого труда его не должно было составлять, перенести в Web, и они это сделали довольно легко и просто. XAML.io сайтик предоставляет вам как раз таки доступ к визуальному редактору, который написан на C#, который использует WebAssembly, и который работает довольно приятно и визуально выглядит довольно хорошо.
5427.02 5471.58 "Анатолий Кулаков" Вот, такой замечательный проектик, не знаю, не знаю, насчет того, как он будет конкурировать со современными фреймворками, потому что, к сожалению, почему-то никто его не берет в сравнение, когда вот ищет какой-то идеальный веб-фреймворк. Наверное, этому есть причины, если вы знаете какие-нибудь причины, почему вот нельзя брать новым фреймворком именно OpenSilver, а стоит посмотреть в сторону других каких-то еще, напишите нам обязательно в комментариях. А я, скорее всего, на следующий выпуск притащу какую-нибудь статейку по сравнению UI-фреймворков, и мы, наконец, посмотрим, а что у нас есть в дот-нете, наконец, для того, чтобы формочки клепать, и желательно в браузере, ну и кросс-платформе, наверное, желательно теперь уже и на мобилках, и везде-везде-везде. Посмотрим на состояние, что там в будущем, ну а пока, вот, отличный новогодний
5471.58 5491.98 "Игорь Лабутин" салатик. Да, я, кстати, сейчас пока это рассказывал, потыкался в XAML.io. Первая загрузка, она довольно долгая, потому что она там прямо видно, если открыть консольку браузера, как она грузит там, systems.txt.generic, system.generic.collections там, или как там, system.collections.generic.wasm, system.txt.что-то.там.wasm, ну то есть, короче, все стандартные.
5491.98 5494.62 "Анатолий Кулаков" Родные просто имена для православного рулка.
5494.62 5515.74 "Игорь Лабутин" Да-да-да, все, короче, собранные, серфовые дейлильки, которые просто собраны WASM, это все грузится, оно грузится один раз, дальше работает действительно хорошо и шустро. Так что, да, можно пробовать. Ну, чего, давай мы пойдем уже на последнюю финальную тему, наш кратенький выпуск все равно часа в полтора будет точно, как обычно.
5515.74 5573.70 "Игорь Лабутин" И здесь у нас как раз из, немножко из новостей дутнета, а именно обнаружилась некая проблема с Entity Framework Core, что если мы включаем LangVersion Preview, а именно, то есть в вашем CS Project вы включаете прямо раз в последнюю версию, то это ломает EF Core. Почему? Потому что в целях оптимизации, в целях борьбы за скорость, у нас, если вы где-то используете метод что-то там .contains, то раньше, как правило, подставлялся метод, который энумеровал .contains. И все было бы здорово, если бы на коллекции это делали. Но теперь для скорости, если у вас коллекция будет подходящая, у вас подставится с точки зрения компилятора вызов метода memory_extension.contains.
5573.70 5718.46 "Игорь Лабутин" И он там быстрее, спан, и вот это все, он это все сделает шустро, быстро, без каких-либо дополнительных локаций, без всего-всего-всего-всего. Проблема в том, что в EF Core мы же это expression запихиваем в дерево, и потом это дерево компилируется, причем поскольку фишка в том, что дерево по сути надо скомпилировать только один раз, оно же не меняется для запроса каждого, то компилируется это не через частную компиляцию в bytecode, вот это все, а оно интерпретируется. И выяснилось, что ни expression.compile, ни интерпретатор понятия не имеют, что делать со спанами, которые попали в такое дерево. То есть если вы в expression начинаете использовать методы, которые принимают спаны, или что-то вокруг них, рефстракты любые, на самом деле, то все плохо, ничего не работает. То есть фактически на самом деле сломался не только EF Core, просто в EF Core это наиболее было заметно, сломается любой код, который использует linkexpressions, и при этом каким-то образом попадается метод с рефстрактами. Казалось бы, почему, ну как бы проблемы и проблемы, что-нибудь сделают, что-нибудь пофиксят. Почему вот новость меня привлекла, потому что в там огромнейшее обсуждение на GitHub, и там было такое, ну так давайте пофиксим link, system.link.expressions, что, давайте туда добавим byrefs, и там кто-то из, а чуть ли не Дэвид Фаулер сам, я сейчас не вспомню, но кто-то из таких топов разработки написал, так это, мы же в system.link.expressions ничего не добавляем, они же у нас, называется они effectively archived, то есть system.link.expressions сейчас находится в состоянии, что в него, ну как бы ничего не добавляют, если это не критическая уязвимость. И поэтому, как бы если кто-то вдруг на данный момент надеется, что expressions продолжат дальше развиваться, в них будут добавляться новые-новые фичи, там не знаю, языка и так далее, то нет, пока не планируют, и для того, чтобы туда что-то начали добавлять, их нужно вернуть из архивного состояния, пока там только суровый мейнтенанс, только ради security проблем. Вот. Также, на самом деле, проблема еще с рефстрактами в том, что они и в reflection не поддержаны.
5718.46 5746.62 "Игорь Лабутин" Нормально. С ними, короче, нельзя нормально через reflection поработать, по разным причинам. И, ну вот это может быть будет по-фикшену, как я понял, из github.ish, но пока непонятно. EFCore команда сказала, да, фигня вопрос, мы сейчас у себя просто сделаем еще один обход дерева, прежде чем отдавать дерево в компиляцию, мы просто все мемории extension.contains принудительно заменим на innumerable_contains прямо в дереве. Ну, визитер такой, сделаем на дереве, который первым проходом будет это и делать, и дальше все будет работать как раньше.
5746.62 5759.78 "Игорь Лабутин" Типа, нам не проблема, мы сейчас сделаем. Но, знаете, вот такая вот есть штука, и я для себя действительно узнал, что, оказывается, expression, и они, типа, в архивном статусе и не собираются развиваться никак. Я что-то
5759.78 5768.94 "Анатолий Кулаков" считал, что они живут. Интересно, технология такая, на которой там весь entity framework работает и все такое, и она вот в архиве уже много-много лет и не развивается.
5768.94 5775.14 "Анатолий Кулаков" Да-да. Действительно, оно не противоречит друг другу, но ситуация довольно забавная.
5775.14 5782.98 "Анатолий Кулаков" Интересно. Слушай, а почему вот эти entity framework коровцы, они в тестах это не узнали? Ну, казалось бы, очевидно, у тебя же в тестах все это должно было поменяться, и все тесты должны были
5782.98 5788.10 "Игорь Лабутин" упасться. Так, видимо, они в тестах линк превью не ставят. Это же именно превью фича, видимо.
5788.10 5791.38 "Игорь Лабутин" То есть они ставят latest, возможно, но не превью.
5791.38 5796.86 "Анатолий Кулаков" Ага, ну, то есть, если бы они поставили превью, это бы все у них, по идее, рухнуло. Ну, может быть, они так это
5796.86 5803.06 "Игорь Лабутин" и выяснили. То есть не то, что это где-то кто-то сломал это самое, это уже в скоупе тут над десятого обсуждается.
5803.06 5840.02 "Игорь Лабутин" То есть они, видимо, начали потихонечку обновлять SDK на новый превью, ну, и так далее. И вот, типа, превью фичи включили, потому что в десятом-то все превью фичи, скорее всего, хочется верить, станут уже не превью, а часть из них уже доступны. Ну, там вот field же, да, у нас ключевое слово field было закрыто под превью, и вот, видимо, еще какие-то уже успели наклепать, судя по тому, что memory extension теперь предпочитается вместо enumerable contains. Потому что мы такую фичу не обсуждали, видимо, это какие-то тонкости уже там разрешения перегрузок компилятора, которые уже успели впилить.
5840.02 5857.46 "Анатолий Кулаков" Слушай, ну, и смотри, сам факт интересный, что директива lang version, я вообще думал, что она относится только к компилируемому моему проекту, что она никак не влияет на то, как там, например, entity framework себя ведет. То есть я думал, что это версия языка, который я пишу.
5857.46 5874.34 "Игорь Лабутин" Ну, подожди, это версия языка, который ты пишешь, но ведь когда ты пишешь expression, ты пишешь там list.contains, это должен сказать, какой там будет тип, чтобы когда из этого он построит expression, там был ссылка уже на нормальный метод полностью.
5874.34 5884.74 "Анатолий Кулаков" И почему это версия языка, а не версия той библиотеки, то есть того BCL? Я же могу писать не на превью языке, а при этом BCL у меня будет подставлен там старый.
5884.74 5887.50 "Анатолий Кулаков" Это интересно, но подожди, target для тебя.
5887.50 5890.98 "Анатолий Кулаков" BCL 5, и language я могу хоть 10 использовать.
5890.98 5892.94 "Игорь Лабутин" Да, но expression…
5892.94 5897.26 "Анатолий Кулаков" И по идее это должен BCL отвечать, какой метод у меня подставится, а не language.
5897.26 5902.14 "Игорь Лабутин" А на тот момент уже поздно отвечать, какой метод подставится.
5902.14 5916.42 "Игорь Лабутин" Если у тебя написано лямбда, в которой что-то вызывается, то тебя по-любому уже компилятор должен решить вообще, имеешь ты право здесь вызвать такой contains или нет, если он вообще в принципе существует или не существует.
5916.42 5919.58 "Игорь Лабутин" Если не существует, то у тебя будет ошибка компиляции.
5919.58 5932.42 "Анатолий Кулаков" Понятно, что компилятор, мне кажется, просто казалось, что компилятор это будет решать на основании версии BCL, а не на основании версии языка, потому что существует вот этот memory твой contains или не существует, это решает BCL, это не решает язык.
5932.42 5950.78 "Игорь Лабутин" Это ты прав, тут не знаю, да, не могу сказать почему так, это надо вот погружаться, что же они там сделали с этим lang preview и почему теперь где-то что-то, перегрузка какая-то выбирается, это интересный вопрос, но возможно мы до этого доберемся, когда нам про эту фичу расскажут в каком-нибудь блоге.
5950.78 5952.46 "Анатолий Кулаков" Ну да, когда прививки может пойдут.
5952.46 5960.54 "Игорь Лабутин" Да, и вторая новость, она скорее всего особо вас не коснется, но на самом деле может.
5960.54 6000.34 "Игорь Лабутин" Тут такая ситуация произошла, значит если вы когда-либо качали какие-либо скрипты, там билды, SDK и так далее, особенно во всяких линуксах, маках и прочем, то вероятно вы встречались с тем, что ну невероятно вы точно встречались с тем, что естественно все эти билды хранятся на CDN, и у CDN Node есть куча всяких разных доменных имен, в частности есть те, которые заканчиваются на AzureEdge.dotnet, это были на самом деле стандартные ноды для того, чтобы там Azure DevOps, CI собирался и .dotnet install скрипты под линукс, в частности, они как раз именно с этих нод качали SDK.
6000.34 6091.54 "Игорь Лабутин" Внезапно выяснилось, что эти сервера хостятся не в Майкрософте, а их партнерами, Edge.io, и эти партнеры внезапно банкротятся, ну так получилось, вот, и поэтому все домены, которые AzureEdge.dotnet заканчиваются, они вообще говоря относятся к серверам, которые будут полностью закрыты, потушены и выключены, вот, поэтому новость заключается в том, что Майкрософт решила, что все домены AzureEdge.dotnet будут полностью выключены, в смысле прям, их не надо будет больше использовать, все билды надо забирать с builds.dotnet.microsoft.com, то есть с нормального адреса в домене Microsoft.com, где он там хостится дальше, это уже не важно, но по крайней мере ссылки не надо будет менять потом, CI билды лежат на ci.dot.net, .net install скрипты, которые там .netinstall.sh, уже проаптечены, нужно их скачать, а вот в течение января как раз будут меняться всякие GitHub, CI-ные скрипты, AzureDevOps CI-ные скрипты, а может быть даже на февраль залезет, то есть в общем проверьте, куда, если вдруг вы например какие-то свои скрипты писали, которые как-то внутри себя и используют AzureEdge.net, Майкрософт прям рекомендует поищите эту строчку у себя в скриптах, там еще где-то, если она есть, меняйте на нормальные builds.dotnet.microsoft.com, чтобы забирать прям с официального места.
6091.54 6097.22 "Анатолий Кулаков" Они не могли просто эти домены себе купить, да и все, и настроить?
6097.22 6115.22 "Игорь Лабутин" Они при этом, я не знаю почему не могли, они при этом сказали, что если вы вдруг использовали что-то там, AzureEdge.net, вы просто поменяйте домены именно builds.dotnet.microsoft.com и полностью обеспечили совместимость по всем путям дальше, все пути дальше они как бы сделали, что полностью совместимы.
6115.22 6117.90 "Игорь Лабутин" Что было и домены себе не забрать, я не знаю.
6117.90 6119.86 "Анатолий Кулаков" Ну да, сделали потом редиректы и все.
6119.86 6127.74 "Игорь Лабутин" Ну в общем, при том, что в домене, домен называется AzureEdge, я подозреваю, что все-таки оунеры они, но в общем почему-то VM решили так не делать, не знаю.
6127.74 6132.14 "Анатолий Кулаков" Да, что с такими он нафиг никому не нужен, кроме там каким-нибудь киберсквоттером.
6132.14 6136.34 "Игорь Лабутин" Ну в общем вот, такие дела, меняйте на официальный Microsoft.com.
6136.34 6137.34 "Анатолий Кулаков" Вот.
6137.34 6160.50 "Анатолий Кулаков" Слушай, я хотел еще выпуск нам сегодня поставить и прекрасный отчет, который мы обсуждаем каждый год, который называется JetBrains State of Developer Ecosystem Report, где мы там рассматриваем, сколько там программисты наши, как они работают, на чем работают, сколько занимают, различные версии фреймворков, но обнаружил вдруг почему-то JetBrains перестал публиковать детализацию этого отчета.
6160.50 6176.22 "Анатолий Кулаков" Ну то есть этот отчет, он был для всех языков, для всех программистов, для всех стран, и у него всегда была такая общая часть, где мы рассматриваем всю экосистему вместе, а потом под каждый конкретный язык рассматривалась такая детализация, и мы, естественно, рассматривали все, что касается .NET.
6176.22 6186.26 "Анатолий Кулаков" И сейчас, в этом году, ну в 24-м, да, это для 24-х, в прошедшем году был выпущен отчет, но в нем есть почему-то только общая часть, а вот конкретно по языкам нет.
6186.26 6210.78 "Анатолий Кулаков" Поэтому, если вам интересна общая часть, которая не очень интересна, можете зайти посмотреть, в частности можно сказать, что там C# находится на тех же самых позициях, на которых находится уже последние 7 лет, то есть там 22% всех опрошенных его использует, он где-то примерно там на 8-м месте, перед ним там JS, Python, Java, C++, ну в общем стандартная комплектовка, но детализации, выводов по крайней мере из детализации нет.
6210.78 6215.90 "Анатолий Кулаков" Там есть сырой файлик, который вы можете скачать и сами проанализировать, но это что-то совсем не то.
6215.90 6221.94 "Анатолий Кулаков" В общем, непонятно, зачем один из самых лучших отчетов в индустрии, так надо было зарезать.
6221.94 6227.58 "Анатолий Кулаков" Если у вас есть вдруг инсайдерские сведения, а почему, а где, то обязательно напишите.
6227.58 6230.86 "Анатолий Кулаков" Ну в общем на этом все, весь отчет закончен.
6230.86 6236.58 "Игорь Лабутин" Но выглядит очень красиво, потыкайтесь по сайту, там ну как бы оформлено прекрасно, да.
6236.58 6238.66 "Анатолий Кулаков" Тормознуто, но красиво.
6238.66 6247.10 "Игорь Лабутин" Ну ничего, хороший интернет у нас у всех есть, и нормально скачает все это, ну ставьте скачать, потом потыкайтесь.
6247.10 6274.74 "Игорь Лабутин" Все, что на этом надо сегодня завершать, мы сегодня успели обсудить всего 4 статейки и немножко поговорить кратко о разном, про всякие security хедера поговорили, про ускорение логирования волшебным образом, про то, как хранить валюты и суммы, деньги вообще в целом, и про то, что такое OpenSilver, какой там у него новый прекрасный UI-дизайнер, который на васме работает в браутере везде, ну и само OpenSilver, что еще тоже работает много где везде, где работает в васм.
6274.74 6277.04 "Игорь Лабутин" На этом у нас все на сегодня.
6277.04 6284.22 "Анатолий Кулаков" Да, до новых встреч, всем хороших превьюшек в новом году, классных новостей, а мы обо всем об этом обязательно будем рассказывать.
6284.22 6285.22 "Анатолий Кулаков" Всем пока.
6285.22 6286.22 "Игорь Лабутин" Обязательно.
6286.22 6286.72 "Игорь Лабутин" Всем пока.
