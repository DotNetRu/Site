17.64 20.04 SPEAKER_01 За нашими спинами наши прекрасные помогаторы.
20.04 36.12 SPEAKER_01 Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Постарнаков Андрей, Дмитрий Сорокин, Дмитрий Павлов, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Лазарев Илья, Тимофей.
36.12 37.92 SPEAKER_01 Спасибо, друзья, всем, кто нас поддерживает.
37.92 41.52 SPEAKER_01 Также в этом выпуске нас поддерживает компания Altenar.
41.52 46.40 SPEAKER_01 В компании разрабатывают масштабируемые надежные решения для индустрии спортивных данных.
46.40 48.48 SPEAKER_01 Эти решения используются по всему миру.
48.48 64.60 SPEAKER_01 В продуктах используется, конечно же, DotNet и C#, при этом продукты являются высоко нагруженными реалтаймовыми сервисами и приложениями, над которыми работают лучшие инженеры.
64.60 71.40 SPEAKER_01 Идеи этих инженеров не теряются в десятках согласований, а довольно быстро могут быть доведены до продакшена.
71.40 89.92 SPEAKER_01 Разработка компании международная, так что можно качать английский, если вам нужно для общения, если вы хотите общаться, можно использовать принятые удобно во всем мире IDE, облачные платформы, а для сотрудников, которые вносят большой вклад, возможно продолжение карьеры в европейском офисе.
89.92 96.16 SPEAKER_01 Также ребята активно делятся опытом, проводят митапы, выступают с докладами и не только.
96.16 99.84 SPEAKER_01 Следить за их новостями можно в их телеграм-канале по ссылке в описании.
99.84 108.20 SPEAKER_01 Отлично, надеюсь, ребята не только будут митапы проводить, но и статейки будут писать, и тогда мы их можем даже у нас обсудить.
108.20 114.12 SPEAKER_01 Ну а пока у нас статейки есть от самого Микрософта, он наконец разродился, у нас второй выпуск подряд, и второй превью выпускает.
114.12 117.16 SPEAKER_01 Что там интересного в дотнет 10 превью 2?
117.16 130.00 SPEAKER_01 Да, вышел дотнет 2, дотнет 10 превью 2, в котором на самом деле кажется, что в превью 1 мы довольно много всего обсуждали, а в превью 2 у меня все новинки помещаются на один экран в моих заметках, что и очень немного.
130.00 131.28 SPEAKER_01 Но давайте все равно посмотрим.
131.28 132.28 SPEAKER_01 Библиотеки.
132.28 162.00 SPEAKER_01 В библиотеках всего лишь единственное изменение, на самом деле, конечно, не единственное, коммитов там было много разных, но из того, что попало в выпуск, в релиз ноутса и, соответственно, в наш выпуск, Майкрософт же, конечно, делает все, чтобы попасть в наш выпуск, так вот, попало только то, что можно теперь при экспорте сертификатов через специальный класс, можно указать конкретно каким инкрипшенным алгоритмом вы хотите его заинкриптить.
162.00 165.16 SPEAKER_01 Это единственное, что поменялось в библиотеках, было достойного анонса.
165.16 237.64 SPEAKER_01 В рантайме побольше, и в рантайме на самом деле интересные изменения, в прошлый раз мы рассказывали про то, что происходит такая штука, так называемый de-abstraction, я рассказывал про то, что если у нас есть, там, энумераторы, которые там реализуют интерфейс, а точнее они возвращаются через интерфейс, то раньше джит не понимал, что там возвращается структура, а теперь понимает, вот теперь это все продолжилось дальше, глубже и лучше, и теперь на самом деле с учетом всего того, что сделано, плюс еще одна допфиджа, которую сделали в этом превью, она называется inlining of late de-virtualized methods, то есть смысл в чем, если у вас есть вызов метода интерфейса, например, то джит в принципе понимает, с учетом какой-никакой статистики, что в общем-то вызывается всегда один тот же метод, например, и по сути там не нужен виртуальный вызов, а нужен обычный вызов, или даже он это может сделать, расходясь понимания общего кода, что там действительно вызывается какой-нибудь метод, который всегда возвращает объект фиксированного типа, и интерфейс там, ну просто потому что так сложилось, а на самом деле там будет всегда один и тот же тип, и тогда можно не делать виртуальный вызов, а можно сделать обычный вызов.
237.64 271.12 SPEAKER_01 Так вот теперь со всем крутым знанием джита, вся эта информация о типе становится доступной после де-виртуализации, смысл в том, что если мы де-виртуализировали вызов, у нас появляется информация о том, что ага, в этой точке у нас всегда будет один и тот же тип, так вот в некоторых случаях это может привести к тому, что мы можем понять, ага, а тогда можно заинлайнить еще что-нибудь, вот раньше этого еще что-нибудь, следующего шага инлайнинга не было, теперь есть.
271.12 279.64 SPEAKER_01 А кроме того, когда у вас что-то заинлайнилось, ну что бывает нужно?
279.64 296.00 SPEAKER_01 Бывает нужно завести какую-то временную переменную, то есть джит, когда он инлайнит вызовы функций, он может завести какую-то временную переменную, грубо говоря, ну регистра, понятно, на уровне джита, но по сути это временная переменная, куда сложится результат вызова, например, вашего метода, и дальше с ним будет продолжаться работа.
296.00 303.44 SPEAKER_01 Вызова метода, конечно же, не будет, то есть просто результат блока заинлайнинга будет положен в какую-то переменную и дальше с ней будет продолжаться работа.
303.44 326.20 SPEAKER_01 Так вот, смысл заключается в том, что если в результате такого инлайнинга у этой переменной становится понимание, что у нее есть какой-то плюс-минус фиксированный тип и он не меняется во время исполнения программы, то это повод задевиртуализировать еще больше вызовов, которые производятся потом на этой переменной.
326.20 341.76 SPEAKER_01 То есть, грубо говоря, если у вас есть метод, который возвращает интерфейс, и он заинлайнился, то, возможно, метод, который вызовется на результате вызова этого метода, можно тоже задевиртуализировать и сделать не виртуальным, а обыкновенным.
341.76 360.60 SPEAKER_01 С учетом всех этих, в общем, улучшений, джит теперь, по сути, умеет в некоторых случаях, в основном это, конечно, касается и нумераторов, он сможет девиртуализировать эти вызовы, заинлайнить их, застеколокать, а потом еще и сделать так называемый стракт промоушн.
360.60 375.40 SPEAKER_01 То есть это когда, если у вас, а нумераторы довольно часто делаются для перформанса страктами, что вам не нужно будет прямо аллоцировать эту структуру на стеке, она сразу разберется на кусочки и может быть даже просто по регистрам покатается и не будет даже на стеке ничего аллоцироваться.
375.40 384.40 SPEAKER_01 В общем, все оптимизируется в максимально идеальный код, хотя вы пишете с интерфейсами, абстракциями, нумераторами, вот этим всем.
384.40 385.76 SPEAKER_01 Ну, это круто-круто.
385.76 394.60 SPEAKER_01 А может он дойти до такого состояния, когда нумератор у нас будет все-таки классом, а он его будет настолько разворачивать, что прям класс тебе по регистрам разложит.
394.60 398.72 SPEAKER_01 Он будет понимать, что он практически как структура.
398.72 416.72 SPEAKER_01 Для такого нужно нам все-таки сделать полноценный большой escape analysis, то, что называется, то есть понимание, что этот класс никогда не покинет scope вызова, и тогда его можно положить на стек, а если его можно положить на стек, ну смотри, выше, может быть его можно тогда и промоутить до раскидать по регистрам.
416.72 418.76 SPEAKER_01 Я думаю, что мы до этого доживем.
418.76 422.16 SPEAKER_01 Вопрос, насколько быстро?
422.16 423.16 SPEAKER_01 Но думаю, что это будет.
423.16 424.16 SPEAKER_01 Может быть, даже в десятки.
424.16 425.16 SPEAKER_01 Ну классно.
425.16 426.16 SPEAKER_01 Я не знаю.
426.16 427.16 SPEAKER_01 По крайней мере, все в эту сторону двигается.
427.16 428.16 SPEAKER_01 Должна быть интересная штучка.
428.16 429.16 SPEAKER_01 Да.
429.16 435.12 SPEAKER_01 В SDK изменения, по сути, опять же, то, что оказалось достойной статьи, только одно.
435.12 449.96 SPEAKER_01 Если вы пользовались dotnet.com онлайном, толзой, то могли заметить, что там иногда есть некоторая неконсистентность, так скажем, с точки зрения, где, в каком порядке указывать команды.
449.96 462.72 SPEAKER_01 То есть где-то вы можете указать dotnet add package, где-то нужно сначала dotnet workload install, то есть где-то вы говорите, что сделать, а потом говорите с чем, а где-то вы говорите сначала с чем сделать, а потом что.
462.72 469.76 SPEAKER_01 Вот они там добавили некоторое количество алиасов, то есть теперь можно сказать dotnet package add либо dotnet add package, как хотите.
469.76 470.76 SPEAKER_01 Вот.
470.76 471.76 SPEAKER_01 Они оба будут работать.
471.76 480.68 SPEAKER_01 В общем, если интересны детали, посмотрите по ссылкам, там всё чётенько описано, какие алиасы, в каких чаще всего ошибаются и какие они, соответственно, добавили.
480.68 485.40 SPEAKER_01 Ты имеешь в виду, что они не смогли сесть договориться, какой правильный, да, и поддержали оба формата.
485.40 489.12 SPEAKER_01 Я так понимаю, что исторические блоги немножко разные.
489.12 493.16 SPEAKER_01 Не то, что сесть договориться, они не могут выкинуть один, потому что...
493.16 494.16 SPEAKER_01 Можете прикидить там и выдасть, ворнить.
494.16 495.16 SPEAKER_01 Да-да-да.
495.16 496.16 SPEAKER_01 Я думаю, что...
496.16 497.16 SPEAKER_01 Пользуйтесь, мы это отключим, как положено.
497.16 505.52 SPEAKER_01 Я думаю, что пока они добавили оба варианта, возможно, они посмотрят на какую-то статистику и потом, может быть, через пару ревизов что-нибудь задеприкейтят.
505.52 509.60 SPEAKER_01 Ну, алиасы в Комманд Лайне бесплатно практически чё.
509.60 510.60 SPEAKER_01 Можно и не деприкейтить.
510.60 511.60 SPEAKER_01 Дальше.
511.60 512.60 SPEAKER_01 C#.
512.60 519.00 SPEAKER_01 В C# появилась только одна, по сути, фича в этом превью, и она называется Partial Events и Constructors.
519.00 528.48 SPEAKER_01 То есть теперь вы, помимо Partial методов, Partial Properties, которые уже были, можете делать Partial Events и Partial Constructors.
528.48 529.48 SPEAKER_01 Вот.
529.48 533.56 SPEAKER_01 С Constructors мне было наиболее интересно, что такое Partial Constructor.
533.56 545.20 SPEAKER_01 То есть это, напомню, Partial метод, когда вы можете, грубо говоря, объявить метод в одной части, а результовать его в другой части, обычно с генерированным кодом это делается.
545.20 550.72 SPEAKER_01 В Partial Constructors, соответственно, есть точно так же две части.
550.72 555.24 SPEAKER_01 Одна называется Defining Declaration, вторая называется Implementing Declaration.
555.24 561.56 SPEAKER_01 И вот тут есть некоторые, ну скажем так, ограничения, которые накладываются на то, где что можно делать с точки зрения конструкторов.
561.56 567.08 SPEAKER_01 А я напомню, что при определении конструктора вы не просто пишете сигнатуру, как, например, это было бы в методе.
567.08 574.68 SPEAKER_01 В методе вы просто пишете сигнатуру, ничего больше с ней особо сделать не можете, поэтому там никаких спецограничений, насколько я помню, нету.
574.68 579.48 SPEAKER_01 Вы просто одну и ту же сигнатуру используете и там, и там, и в одной части класса, и в другой.
579.48 580.48 SPEAKER_01 И все работает.
580.48 582.24 SPEAKER_01 Ну, плюс ключевое слово Partial.
582.24 586.28 SPEAKER_01 А здесь нужно будет сделать обязательно вот что.
586.28 602.24 SPEAKER_01 В том, где вы объявляете то, что называется Defining Declaration, то есть это то место, где вы просто объявляете, что должен быть конструктор с такой-то сигнатурой, вы не имеете права использовать всякие спецификаторы типа Base, This и так далее, которые обычно через двоеточие пишутся после обычной сигнатуры.
602.24 613.28 SPEAKER_01 То есть эти штуки допустимы только в Implementing Declaration, то есть только там вы можете специфицировать, что нужно вызвать базовый конструктор или какой-то другой конструктор в рамках того же класса.
613.28 631.36 SPEAKER_01 Ну, наверное, это довольно разумное ограничение, потому что именно в части имплементации вы знаете, какой базовый или какой другой конструктор нужно вызвать, но вот тем не менее это явно подчеркнуто в описании фичи, что вот помните, нельзя просто скопировать всю строчку, нужно выкинуть из нее всякие Base, This и все какое-то такое.
631.36 633.36 SPEAKER_01 Ну это реально, это часть имплементации.
633.36 634.36 SPEAKER_01 Да, да.
634.36 637.80 SPEAKER_01 Даже если вот в методе пишешь, вызываешь базовый метод, то это же все-таки считается имплементацией.
637.80 638.80 SPEAKER_01 Да.
638.80 639.80 SPEAKER_01 Но там.
639.80 640.80 SPEAKER_01 Удивительно, что конструктор – это тоже имплементация.
640.80 641.80 SPEAKER_01 Да, да, да.
641.80 648.68 SPEAKER_01 Но эти ассигнатуры обычно видятся в каком-то смысле, и поэтому они явно про это написали.
648.68 649.68 SPEAKER_01 Дальше.
649.68 653.52 SPEAKER_01 Мне больше интересно, что такое partial декларация ивента и имплементация ивента.
653.52 656.56 SPEAKER_01 Вот это мне кажется веселее, что такое имплементация ивента.
656.56 662.32 SPEAKER_01 Это, ну как, у него же может быть этот get_set, ой, не get_set, как его там.
662.32 663.32 SPEAKER_01 А, custom_add_remove.
663.32 664.32 SPEAKER_01 Add_remove же там же, да.
664.32 665.32 SPEAKER_01 Да, custom_add_remove.
665.32 666.32 SPEAKER_01 Да, да.
666.32 670.74 SPEAKER_01 Ну ладно, просто кому это могло понадобиться?
670.74 673.56 SPEAKER_01 Это действительно практические примеры, кому нужен partial ивент.
673.56 675.92 SPEAKER_01 Ну кода генерации какая-нибудь только, если, я не знаю.
675.92 678.20 SPEAKER_01 Не, ну понятно, что кода генерации, но как бы что?
678.20 679.20 SPEAKER_01 Не знаю.
679.20 680.20 SPEAKER_01 В WPF-е.
680.20 682.20 SPEAKER_01 Я даже… В WPF-е генерить.
682.20 683.52 SPEAKER_01 …это информам не пользовался, и в WPF-е не пользовался.
683.52 686.06 SPEAKER_01 Там мне никогда не, ну редко приходилось перекрывать.
686.06 693.56 SPEAKER_01 Ну погоди, тебе редко приходилось, но зато, не знаю, там, ты не парился на тему того, что у тебя там что-то рефлекшнам работает.
693.56 700.38 SPEAKER_01 А сейчас, если мы хотим в какой-нибудь там WinForms-приложении запустить на ATF-аот, то вот тебе будет нужно там генерить какие-нибудь ивенты.
700.38 701.38 SPEAKER_01 Ну я не знаю.
701.38 703.22 SPEAKER_01 Сейчас гадаю немножко, наверное.
703.22 704.22 SPEAKER_01 Вот.
704.22 705.22 SPEAKER_01 Ну ладно, возможно.
705.22 707.90 SPEAKER_01 Не ходил в исходник, не читал описания нафига.
707.90 713.94 SPEAKER_01 Я думаю, что они делают это для, что называется, для полноты фичи, так скажем.
713.94 717.30 SPEAKER_01 Чтобы все было, и методы, и свойства, и вот теперь ивенты, и конструкторы.
717.30 718.74 SPEAKER_01 Что у нас еще осталось в классах?
718.74 721.90 SPEAKER_01 Что еще можно объявить такого в классе, что можно сделать partial?
721.90 722.90 SPEAKER_01 Не знаю.
722.90 723.90 SPEAKER_01 Да, кажется, все.
723.90 724.90 SPEAKER_01 Пропертии и методы у нас же были, да?
724.90 725.90 SPEAKER_01 Да.
725.90 726.90 SPEAKER_01 Да.
726.90 727.90 SPEAKER_01 Ну все.
727.90 730.38 SPEAKER_01 Хотя, может, там еще что-нибудь выдумают.
730.38 731.38 SPEAKER_01 Partial Extension методы.
731.38 736.02 SPEAKER_01 Вот Extension Everything давно не хватает, как бы.
736.02 737.02 SPEAKER_01 Да-да-да.
737.02 740.26 SPEAKER_01 Я ни на что не намекаю, товарищ Microsoft, но как бы уже бы пора бы давно бы.
740.26 741.26 SPEAKER_01 Ну ладно.
741.26 744.26 SPEAKER_01 Посмотрим, может, что еще сделают.
744.26 745.26 SPEAKER_01 Дальше.
745.26 746.26 SPEAKER_01 Evcore.
746.26 747.26 SPEAKER_01 Тоже особо новостей нету.
747.26 750.86 SPEAKER_01 В прошлый раз сказали, мы поддержали leftJoin, значит, метод из LinkU.
750.86 754.70 SPEAKER_01 В этом превью поддержали, угадай, rightJoin из LinkU.
754.70 756.66 SPEAKER_01 В следующем InnerJoin, наверное, поддержат.
756.66 757.66 SPEAKER_01 InnerJoin.
757.66 762.50 SPEAKER_01 А, кстати, в LinkU уже нет метода InnerJoin, или я что-то путаю?
762.50 764.50 SPEAKER_01 Ну погоди, ну right-а тоже не было, теперь есть.
764.50 765.50 SPEAKER_01 Ну да, теперь есть.
765.50 767.10 SPEAKER_01 Ладно, можно и сделать.
767.10 771.06 SPEAKER_01 Ну дальше по UI-ным частям, там в основном всякие мелкие импрувменты.
771.06 792.90 SPEAKER_01 В MAUI улучшение контролов, это я так сейчас просто говорю улучшение контролов, там на самом деле прям четко указано, что в каком контроле поменяли, поэтому если вы пользуетесь MAUI, сходите, посмотрите, улучшения какие-то, значит, баги фиксятся, качество улучшается, вот это все, там iOS, Android, что-то куда-то становится лучше, становится быстрее и все такое прочее.
792.90 804.34 SPEAKER_01 В WinForms сделали интересную штуку, они, значит, продолжают работать над тем, чтобы BinaryFormatter полностью излежить, и BinaryFormatter, одно из мест, где использовался, это Clipboard.
804.34 805.34 SPEAKER_01 Работа с Clipboard.
805.34 814.46 SPEAKER_01 Так вот теперь они написали в новостях, что, значит, у них теперь Clipboard код, он пошарен с WPF, то есть он, короче, одинаковый теперь, что в WPF, что в WinForms.
814.46 821.02 SPEAKER_01 Не знаю, скопировали они или в библиотеку какую завязали, но теперь типа он общий и не использует BinaryFormatter.
821.02 824.62 SPEAKER_01 И можно контроллы скопировать в WinForms, а вставлять в WPF.
824.62 825.62 SPEAKER_01 Типа того.
825.62 827.62 SPEAKER_01 Да, возможно, не знаю.
827.62 850.58 SPEAKER_01 В WPF только performance и bugfixes, ну и в контейнерах, в контейнер images, базовые образы, которые поставляет Microsoft, появилось или обновились, точнее, некоторое количество SDK images, которые поддерживают nativeout, то есть там они позволяют внутри докера все нормально, полноценно компилировать под nativeout.
850.58 858.06 SPEAKER_01 Интересно, native images вот эти, у них же там .NET поедине ставится, да?
858.06 859.06 SPEAKER_01 .NET Runtime?
859.06 860.06 SPEAKER_01 Нет.
860.06 864.18 SPEAKER_01 Нет, они именно, это именно SDK images, то есть для сборки.
864.18 865.18 SPEAKER_01 А, SDK.
865.18 866.18 SPEAKER_01 Да.
866.18 873.46 SPEAKER_01 Я на то намекаю, насколько там должны быть большие толстые уже runtime images, ведь там .NET не нужен, там какие-нибудь питоны, там все такое не нужно.
873.46 876.18 SPEAKER_01 Так там базовый альпайн какой-нибудь берешь и все.
876.18 882.02 SPEAKER_01 Ну, наверное, да, но они же не на альпайне основные images делают, они же в основном на Debian выпускают.
882.02 890.62 SPEAKER_01 А, нет, подожди, у них же были разные, у них были и на Debian, и на Ubuntu, и мне казалось, что на чем-то типа альпайна какой-то маленькие они были.
890.62 913.18 SPEAKER_01 Ну, альпайн был, да-да, тут я, наверное, неправильно выразился насчет официально, то есть действительно официальные images альпайна были, но меня больше интересует вот именно дебенанская какая-нибудь версия, будет ли она по размеру отличаться от runtime .NET, ну, наверное, будет, но мне интересно, насколько, только ли на дистрибутив .NET или… Нет, я думаю, что это зависит от приложения, от приложения должно зависеть.
913.18 915.60 SPEAKER_01 Ну, мне базовый интересен, базовый, конечно.
915.60 919.22 SPEAKER_01 Ну, базовый должен быть существенно меньше, конечно, на дистрибутив.
919.22 926.30 SPEAKER_01 Просто потом ты в приложение влинкуешь пол-SDK, если у тебя большое сложное приложение, и все обратно вырастет.
926.30 934.22 SPEAKER_01 Смотри, я про то, что, смотри, тебе, чтобы на Debian установить .NET Runtime, тебе нужны были еще какие-то зависимости.
934.22 937.58 SPEAKER_01 Ну, для того, чтобы Runtime сам начал работать, у Runtime тоже зависимости были.
937.58 938.58 SPEAKER_01 А, я понял тебя.
938.58 944.38 SPEAKER_01 Вот, и теперь тебе не только на дистрибутив Runtime, но и плюс еще на размер вот этих зависимостей он должен быть меньше.
944.38 946.58 SPEAKER_01 Слушай, ну… Насколько вот эту матрешку можно развернуть?
946.58 949.26 SPEAKER_01 Я думаю… На голом железе сможем запуститься.
949.26 978.66 SPEAKER_01 Не очень много, потому что мы, кажется, обсуждали под выход восьмого .NET, наверное, это было еще давно, короче, больше года назад, мы обсуждали, если ты помнишь, сколько дополнительных пакетов нужно поставить на базовый голый, условный Debian или Ubuntu, для того, чтобы получился образ, который Microsoft поставляет в виде своего базового, и там минимум было типа шесть пакетов каких-то микронужных, чтобы, значит, заработало минимальный .NET.
978.66 981.18 SPEAKER_01 Поэтому я думаю, что там не такая большая разница на самом деле.
981.18 987.06 SPEAKER_01 Но интересно, возможно, для полного .NET действительно будет большая разница.
987.06 990.06 SPEAKER_01 Ну, хорошо, посмотрим.
990.06 1002.06 SPEAKER_01 В общем, вот такие новости про десятку Preview 2, никаких супер прорывных вещей особо нету, каких-то супер готовящихся и сильно анонсированных вещей нету.
1002.06 1018.38 SPEAKER_01 Я бы сказал, что наиболее интересная часть сейчас — это работа вокруг Jita, и все, что у них там получится или не получится с точки зрения всяких оптимизаций, вот эти вот работы на стейке, Escape Analysis и прочее, прочее, прочее.
1018.38 1019.38 SPEAKER_01 Мне кажется, пока самый интерес вот там.
1019.38 1024.14 SPEAKER_01 Ну, и у тебя уже есть статейки, да, мы от тебя ждем?
1024.14 1025.14 SPEAKER_01 Да, да, да, да.
1025.14 1034.90 SPEAKER_01 Мне нужно найти немножко времени, аккуратненько все прочитать, понять, что я этого не смогу рассказать, и что-нибудь с этим сделать.
1034.90 1035.90 SPEAKER_01 Поглядим.
1035.90 1036.90 SPEAKER_01 Хорошо, хорошо.
1036.90 1037.90 SPEAKER_01 Мы ждем.
1037.90 1041.14 SPEAKER_01 А ваши лайки, шарики и репосты помогут Игорю собраться и найти время.
1041.14 1045.02 SPEAKER_01 Знаешь, как в этом, в комиксе.
1045.02 1046.02 SPEAKER_01 Помогите Игорю найти время.
1046.02 1050.86 SPEAKER_01 Так, тоже не сильно большой анонс, но все же анонс.
1050.86 1055.62 SPEAKER_01 Системлинку Async теперь является непосредственно частью Дотнета 10.
1055.62 1061.02 SPEAKER_01 Давайте подробнее разберем, что это такое, да и вспомним вообще, кому это нужно.
1061.02 1066.82 SPEAKER_01 Если говорить подробнее, то начать следует от печки, а в нашем случае вот Async Enumerable.
1066.82 1076.74 SPEAKER_01 Как ни странно, Async Enumerable был введен еще много-много лет назад в DotNet Core 3.1, ну, то есть это совсем на заре цивилизации это было, и там появился некий интерфейс iAsyncEnumerable.
1076.74 1092.42 SPEAKER_01 Может быть, вы в своих приложениях и мало его использовали, и может быть, вы видели мало, почему-то его используют, потому что практически, кроме интерфейса и пару инструментов вокруг него, ничего больше не было, никаких особых библиотек и всего такого.
1092.42 1094.62 SPEAKER_01 Вот этот релиз, он пытается это исправить.
1094.62 1096.62 SPEAKER_01 Давайте же начнем сначала.
1096.62 1102.14 SPEAKER_01 Для тех, кто не в курсе, так как вы мало видели Async Enumerable, что это такое же, разберемся.
1102.14 1110.10 SPEAKER_01 Представьте себе обычную коллекцию, в обычной коллекции вы элементы возвращали бы по интерфейсу iEnumerable, ну и, наверное, были бы правы.
1110.10 1116.34 SPEAKER_01 А теперь представьте себе коллекцию, в которой у вас элементы должны возвращаться не синхронно, а асинхронно.
1116.34 1123.54 SPEAKER_01 Ну, допустим, чтобы каждый элемент получить, вам нужно сходить куда-нибудь далеко в сеть, оттуда его извлечь и отдать наружу.
1123.54 1126.86 SPEAKER_01 Что в этом случае вам нужно было бы сделать?
1126.86 1129.06 SPEAKER_01 Какой бы интерфейс вы бы заимплементили?
1129.06 1137.18 SPEAKER_01 Ну, наверное, сигнатура такого метода могла бы возвращать таск от iEnumerable от t, где t - это, естественно, тип элемента.
1137.18 1152.38 SPEAKER_01 Но, на самом деле, немножко это не то, что мы хотим, потому что таск iEnumerable от t вернул бы вам в управление только, когда мы все элементы достали бы из сети, сложили бы в какую-то коллекцию и в это время закомплитили бы таск.
1152.38 1157.34 SPEAKER_01 И только тогда потребительская сторона могла бы получить нашу коллекцию и пошла бы с ней что-то сделать.
1157.34 1164.18 SPEAKER_01 А нам хочется, не дожидаясь всей коллекции, нам хочется отдавать элементы по мере того, как они приходят.
1164.18 1170.38 SPEAKER_01 Допустим, мы пошли в 100 ресурсов, начали это сделать параллельно, и вот какой у нас ответ первый пришел, тот мы отдали.
1170.38 1173.46 SPEAKER_01 Потом какой первый пришел, тот и отдали, не дожидаясь окончания всех.
1173.46 1180.38 SPEAKER_01 Тогда, возможно, сигнатура этого метода должна возвращать iEnumerable таск от t, то есть наоборот.
1180.38 1186.38 SPEAKER_01 Мы сначала возвращаем какой-то enumerator, а потом enumerator по одному дергаем и получаем по одному элементу.
1186.38 1190.30 SPEAKER_01 И вот это уже немножко похоже на то, о чем мы говорим, на то, что мы хотим.
1190.30 1204.74 SPEAKER_01 То есть мы реально возвращаем enumerator, возвращаем какую-то коллекцию, сообщаем вызывающей стороне, что у нас есть коллекция, и при этом мы можем прокрутить эту коллекцию и каждый элемент должны ожидать, когда он к нам придет.
1204.74 1215.06 SPEAKER_01 Проблема этого подхода заключается в том, что вот эта правильная прокрутка этого enumerator и ожидания каждого элемента, это все-таки какое-то ручное управление.
1215.06 1223.74 SPEAKER_01 Закат солнца вручную, то есть вы все-таки должны правильно написать код, он будет немножко такой некрасивый, избыточный, но в целом, наверное, это то, что мы хотим.
1223.74 1245.02 SPEAKER_01 И вот iAsyncEnumerable интерфейс, он и решает вот эту проблему, то есть он сильно похож на enumerable таск от t, но при этом упаковывает это в гораздо более красивый синтексис и дает некие универсальные методы и инструменты для работы с вот этой задачей, типа возвращения асинхронно элементов по одному для целой коллекции.
1245.02 1253.06 SPEAKER_01 Для того, чтобы вот создать такой асинхронный источник данных, который вам будет возвращать элементы, вам необходимо сделать не так уж много вещей.
1253.06 1255.62 SPEAKER_01 Всего лишь навсего сделать ELTReturn.
1255.62 1266.30 SPEAKER_01 В общем, если вы делаете ELTReturn и при этом возвращаете iAsyncEnumerable, все остальное у нас автоматически, магически провяжется, компилятор вас поймет и он сделает именно то, что вы хотите.
1266.30 1272.02 SPEAKER_01 Соответственно, этот метод будет возвращать последовательные элементы из асинхронного потока.
1272.02 1283.06 SPEAKER_01 С другой стороны, чтобы теперь эту коллекцию потребить, вам необходимо будет новое, ну как, относительно новое конструкция, которую вы, может быть, тоже редко встречали, это AwaitForEach.
1283.06 1302.06 SPEAKER_01 Все мы пользовались forEach, а с недавних пор, например, с .NET 3.1, как я уже сказал, у нас есть еще AwaitForEach, который как раз таки принимает iAsyncEnumerable в качестве параметра и умеет красиво и правильно его разматывать так, что вы код практически не отличите от вашего обычного кода, которым вы пользуетесь, от вашего обычного forEach.
1302.06 1308.66 SPEAKER_01 Вот эти вот красивые инструменты и методы, интерфейсы нам и дают iAsyncEnumerable.
1308.66 1311.70 SPEAKER_01 И напомню, что это все у нас уже давно же было.
1311.70 1313.22 SPEAKER_01 А что же у нас не было?
1313.22 1324.46 SPEAKER_01 А не было у нас таки как раз более удобных методов работы с iAsyncEnumerable, к которым мы привыкли уже в нашем обычном enumerable.
1324.46 1344.70 SPEAKER_01 То есть теперь у нас добавились extension методы, которые вам всем давно известны, такие как select, where, их асинхронные товарищи там firstOrDefault, count.async, aggregate.async, toList.async, в общем, все вот эти названия, которые мы с вами привыкли видеть на enumerable, теперь у нас есть и на iAsyncEnumerable.
1344.70 1362.66 SPEAKER_01 Все эти extension методы в принципе давно существовали, они не новые для мира .NET разработки, они новые для стандартной библиотеки, но в мире .NET разработки они уже давно были известны и лежали они в пакете, который назывался System.link.async и этот пакет являлся частью ReactiveExtensions.
1362.66 1374.90 SPEAKER_01 Я думаю, многие из вас знакомы с ReactiveExtensions и там парни как бы недолго задумывались, увидев настоящие реактивные стримы в нативной библиотеке, быстро накрепали кучу полезных extension методов.
1374.90 1390.46 SPEAKER_01 Поэтому если у вас какой-то .NET меньше десятого, вы можете скачать соответствующий пакет, подключить соответствующий namespace и наслаждаться вот этими extension методами точно так же как и сейчас все разработчики могут наслаждаться уже на десятом и более .NET.
1390.46 1399.10 SPEAKER_01 В общем, если у вас десятые и более, то никакого смысла подключить вам пакет нет, теперь это все входит в стандартную библиотеку и можно использовать без каких-либо проблем.
1399.10 1418.18 SPEAKER_01 Но, если вдруг у вас есть пакет вот этот старый System Link Async или если он у вас тащится какой-нибудь транзитиной зависимостью, то есть не напрямую, а какой-то другой пакет от него зависит и вы хотите все-таки перейти на нативный, на системный, то тоже есть прекрасный способ.
1418.18 1437.74 SPEAKER_01 Вы у себя можете в пакетче референсах указать специальную директиву, которая называется ExcludeAsync и указать, что вы хотите заэксклудить все упоминания System Link Async и она заэксклудит в том числе транзитивные зависимости, то есть она просто уберет этот пакет полностью из вашего приложения, кем бы он ни приносился и кто бы его не хотел.
1437.74 1446.02 SPEAKER_01 И, соответственно, заменит на стандартный системный .NET десятый линк расширения для асинхронных стримов.
1446.02 1460.14 SPEAKER_01 Вот такое прекрасное дополнение, если вдруг кто-то не пользовался этим асинхронным forage и он вам, кстати, возможно сейчас как раз хорошее время заиспользовать, проверить и посмотреть, будет ли он подходить к вашему приложению или нет.
1460.14 1467.54 SPEAKER_01 Да, потихонечку всякие разные интересные улучшения заносят, посмотрите, попробуйте.
1467.54 1477.22 SPEAKER_01 Мне, вроде, кстати, ни разу не потребовался асинхронный forage, хотя нет, по-моему, один или два раза писал, но это большая редкость как-то для меня, по крайней мере, пока.
1477.22 1478.22 SPEAKER_01 Да, редкость.
1478.22 1479.22 SPEAKER_01 С ним знаешь, что прикольно?
1479.22 1480.22 SPEAKER_01 Его очень хорошо поддерживает, например, ISP.NET.
1480.22 1491.14 SPEAKER_01 То есть если ты вдруг выставляешь из контроллера, а асинхий номер был наружу, а потом еще в HTTP клиенте его запрашиваешь, то вот эта вся связка идеально работает.
1491.14 1503.86 SPEAKER_01 То есть ты реально в контроллере можешь вернуть первый элемент, поставить там sleep 10, при этом клиент этот первый элемент получит, допустим, пользователь его выведет, пойдет за вторым элементом и реально будет ждать, пока сервер тебе не вернет следующий элемент.
1503.86 1506.22 SPEAKER_01 То есть вот эта связка работает, такая хорошая магия.
1506.22 1514.78 SPEAKER_01 То есть ты вообще легко можешь, например, long polling сделать, то есть крутить там бесконечный цикл и возвращать просто те пакеты, которые там пользователю приходят.
1514.78 1523.42 SPEAKER_01 Вот если раньше для этого нужно как-то было выпендриваться, то сейчас это вообще делается обычным forage, в общем может быть тоже кому-то пригодится.
1523.42 1524.42 SPEAKER_01 Да, прекрасно.
1524.42 1533.06 SPEAKER_01 Раз мы заговорили про forage, link queue и прочее, давайте еще одну новость быстренько обсудим, это Visual Studio 2022 Preview 2.
1533.06 1578.06 SPEAKER_01 Там появились, ну, понятное дело, всякие IE улучшения для copilot появилась, возможно, в public preview gpt 4.0, если вам она доступна, то вы можете ее опробовать, он теперь умеет генерить эти xml-документарии с помощью IE, а вот в дебаггинге как раз появилась новая штука, называется data tips for link queue expressions, то есть если вы в дебаге и вы наведете мышку на разные кусочки link queue выражения, то он постарается вычислить, ну, грубо говоря, как выглядит ваша там коллекция либо что-то, стрим, чего угодно, в том месте выражения, куда вы навелись, то есть отлаживать link queue выражения будет попроще, вы будете видеть какие-то промежуточные результаты.
1578.06 1615.90 SPEAKER_01 Вот, также добавили новый дебаггер для maui, так прямо называется, new mono debug engine, то есть затащили туда, а также студия будет показывать, что вы аллоцируете много zero length arrays, то есть если у вас в итоге получается так, что вы аллоцируете массив, как-то динамически считаете, какой массив нужно аллоцировать, у вас получается ноль, и вы аккуратно аллоцируете массив длины ноль, то студия такие штуки будет подсвечивать и говорить, хе-хе, надо использовать array empty вместо этого, ну, что в принципе хорошая тема, потому что зачем плодить лишние пустые массивы.
1615.90 1632.90 SPEAKER_01 Ну и, в общем-то, все, ну, там под эстоп разработки еще, там live preview в дизайн тайме появилась на основе там hot reload и вот этих технологий, но в целом, по большому счету, тоже в студии особо ничего супербольшого нового нету.
1632.90 1633.90 SPEAKER_01 Пока.
1633.90 1638.06 SPEAKER_01 По крайней мере, и она все еще 2022, в 2025 году.
1638.06 1644.34 SPEAKER_01 Следим за ее версионированием, да, ну, Microsoft начал выпускать превью чаще, но они какие-то стали меньше.
1644.34 1655.14 SPEAKER_01 Да вот не сказать, что чаще, ну, студия превью 1, напомню, вышла, собственно, в момент, когда залилители .NET, то бишь, в когда, в ноябре?
1655.14 1656.14 SPEAKER_01 Ну.
1656.14 1657.14 SPEAKER_01 Сейчас март.
1657.14 1663.90 SPEAKER_01 То есть вот прошел сколько времени, у нас вышла превью 2, и там как-то не очень много всего, поэтому непонятно.
1663.90 1669.18 SPEAKER_01 Ну, хорошо, хорошо, пожелаем ребятам удачи, пусть работают дальше.
1669.18 1675.46 SPEAKER_01 Ну, а мне хотелось бы вернуться вот с наших инструментов, новинок и так далее, немножко поговорить на архитектурные и философские темы.
1675.46 1684.26 SPEAKER_01 Мы это давно не затрагивали, а тут как раз весна, меланхолия, а витаминоз, поэтому надо бы нам поговорить что-нибудь там про философию архитектуры.
1684.26 1696.90 SPEAKER_01 И как раз не то, чтобы свежая идея, но довольно фундаментальная статья, которая часто, я замечаю, что часто разработчики про нее не помнят, не знают или не хотят осознавать.
1696.90 1699.94 SPEAKER_01 Подход, который называется Parse Don't Validate.
1699.94 1709.50 SPEAKER_01 По мне, так один из самых гениальных и фундаментальных и очень полезных подходов, которые существуют, я стараюсь его использовать просто на всех проектах, где только-только возможно.
1709.50 1715.10 SPEAKER_01 Но, как же, опять, как я уже сказал, на моей практике кажется, что большинство разработчиков о нем совсем не знает.
1715.10 1716.10 SPEAKER_01 Поэтому давайте об этом поговорим.
1716.10 1718.82 SPEAKER_01 Что же это такое?
1718.82 1724.26 SPEAKER_01 Это штука, с помощью которой вы можете немножко по-другому относиться к валидации.
1724.26 1728.86 SPEAKER_01 Во многих программных продуктах, естественно, есть валидация.
1728.86 1738.10 SPEAKER_01 Вот у вас есть какие-то контроллеры, в эти контроллеры обязательно приходят какие-нибудь реквесты и прежде чем реквесты пропихнуть дальше в бизнес-логику, обычно их валидируют.
1738.10 1745.06 SPEAKER_01 Проверяют какие-то поля, обязательность заполненных значений, насколько то или иное значение попадает в нужный диапазон и так далее.
1745.06 1748.50 SPEAKER_01 Поэтому я думаю, что с валидацией обязательно сталкивались все.
1748.50 1749.50 SPEAKER_01 Вот без этого никуда.
1749.50 1755.98 SPEAKER_01 Существуют даже специальные библиотеки, которые позволяют вам как-то красиво писать валидацию, типа Fluent Validation или ему подобных.
1755.98 1758.74 SPEAKER_01 Ну, то есть прямо целая индустрия для валидации.
1758.74 1762.58 SPEAKER_01 Но кажется, что многие неправильно делают валидацию.
1762.58 1764.74 SPEAKER_01 Что же такое валидация-то?
1764.74 1779.66 SPEAKER_01 Валидация – это такой специальный способ, который помогает вам как-то ограничить те структуры данных, которые к вам приходят и убедиться, что они соответствуют тем или иным ожиданиям, которые в этом приложении или в этом методе наложены.
1779.66 1782.74 SPEAKER_01 И вот обычный подход к валидации как он заключается?
1782.74 1788.70 SPEAKER_01 Он обычно представляет собой какой-то метод, который возвращает тебе true или false.
1788.70 1796.78 SPEAKER_01 Обычно если true, то это все хорошо, а если false, то это значит ваш реквест, который, допустим, пришел в ваша структура данных, не удовлетворяет каким-то критериям.
1796.78 1808.90 SPEAKER_01 И по-хорошему, если этот метод валидации возвращает false, то желательно бы еще вернуть из списка причин, по которым ваша программа считает эту структуру невалидной.
1808.90 1823.78 SPEAKER_01 Ну, для того, чтобы эти причины показать пользователю на UI, допустим, если это было какое-то поле для ввода пользовательских данных или вернуть HTTP-респонсом, если к вам пришел какой-то HTTP-клиент по Web API и объяснить ему, в каких именно полях он не прав.
1823.78 1825.94 SPEAKER_01 Ну, в общем, такое описание какое-нибудь вернуть.
1825.94 1828.22 SPEAKER_01 И это, в принципе, хорошо.
1828.22 1831.10 SPEAKER_01 Но здесь есть некие проблемы.
1831.10 1838.02 SPEAKER_01 Такой примитивный метод валидации, который принимает слабо типизированную структуру данных и пытается ее каким-то провалидировать.
1838.02 1847.42 SPEAKER_01 В общем, обычно валидаторы пишутся так, чтобы они не имели side-эффектов, то есть валидаторы не имеют права изменять эту DTO, изменять структуру, которая к ним пришла на валидацию.
1847.42 1855.18 SPEAKER_01 Ну, действительно, если вас попросили просто-напросто проверить, будет как-то грубо, если вы кроме проверки начнете делать с ней что-то еще с этой структурой.
1855.18 1868.26 SPEAKER_01 А делать бы хотелось, ну, например, допустим, пользователь к вам прислал какой-нибудь реквест на получение коллекции и забыл указать лимит, или специально не указал лимит, сколько элементов из этой коллекции мы хотим получить.
1868.26 1870.46 SPEAKER_01 А мы работаем только по пенджингу.
1870.46 1873.54 SPEAKER_01 У нас вполне может быть какие-то дефолтные значения.
1873.54 1878.82 SPEAKER_01 Допустим, по умолчанию мы отдаем первую страницу и берем лимит 100, 100 первых элементов отдаем.
1878.82 1881.02 SPEAKER_01 Нормальный дефолт, нормальный.
1881.02 1885.02 SPEAKER_01 Могла бы валидация его проставлять в том случае, если она понимает, что значение не заполнено.
1885.02 1886.58 SPEAKER_01 Да, вполне могла бы.
1886.58 1893.14 SPEAKER_01 Если она этого не проставляет, значит, у нее будет стоять условие, что эти поля с пенджингом необязательны.
1893.14 1901.94 SPEAKER_01 А раз они необязательны, то где-то должна быть находиться логика, которая называется, что если пенджинг не заполнен, то подставляем туда какие-то дефолтные значения.
1901.94 1912.50 SPEAKER_01 И так как эти дефолтные значения могут играть роль не в одном месте, а в нескольких местах, то становится вопрос, а где должны определяться эти дефолтные значения, а в какой момент их проверять.
1912.50 1920.62 SPEAKER_01 А вдруг эти дефолтные значения выходят за те лимиты, которые у нас есть у стандартного валидатора.
1920.62 1932.74 SPEAKER_01 Допустим, пользователю мы разрешаем максимум 50 элементов загрузить, а если он не укажет цифру, то по дефолту подставляется лимит 100, и 100 уже превышает тот лимит 50, который почему-то мы выставили там.
1932.74 1934.98 SPEAKER_01 Получается такая рассинхронизация программы.
1934.98 1944.46 SPEAKER_01 Как только у нас появляется несколько мест, в которых нам нужно принимать решение о том, что такое дефолтный лимит, то у нас сразу имеется возможность к рассинхронизации.
1944.46 1953.78 SPEAKER_01 Еще одна проблема у этих валидаторов, это в том, что, например, они не могут вносить какие-то маленькие изменения, которые вполне могли бы автоматически сделать.
1953.78 1957.78 SPEAKER_01 Такой автокомплит, который у вас в студии, допустим, есть.
1957.78 1961.60 SPEAKER_01 И вам приходит номер телефона, и номер телефона начинается с семерки.
1961.60 1966.74 SPEAKER_01 И ваша программа-то настолько умная, что она понимает, что семерки быть не может, может быть только +7.
1966.74 1979.06 SPEAKER_01 И вот она могла бы догадаться, что если она работает только с российскими телефонными номерами, и вам приходит какая-то строка, в которой первое число семерка, а не плюс, она могла бы этот плюсик тогда подставить и отформатировать это в нормальный международный телефонный номер.
1979.06 1987.62 SPEAKER_01 В общем, такой тоже маленький интуитивный фикс вполне мог бы какой-нибудь валидатор делать, но он этого делать не может, потому что я напомню, что валидаторы обычно пишутся без сайт-эффектов.
1987.62 1990.50 SPEAKER_01 Итак, что же мы имеем?
1990.50 1995.30 SPEAKER_01 Имеем мы вот такие вот валидаторы и кучу еще проблем с ними.
1995.30 1996.30 SPEAKER_01 Давайте еще проблемы рассмотрим.
1996.30 2003.10 SPEAKER_01 Допустим, к вам пришла вот такая структура данных, такой реквест, вы его отвалидировали и передали дальше.
2003.10 2006.74 SPEAKER_01 То есть валидатор сказал, что все, структура хорошая, пойдем дальше.
2006.74 2010.60 SPEAKER_01 И дальше у вас эта структура начинает гулять по разным контекстам.
2010.60 2016.14 SPEAKER_01 Ну там в бизнес-логику она забежала, куда-нибудь в репозиторий забежала, в один сервис, во второй сервис, в третий сервис.
2016.14 2021.98 SPEAKER_01 И вот каждый из этих сервисов, он должен предполагать какие-то очень странные допущения.
2021.98 2025.94 SPEAKER_01 Ну например, он должен предполагать, что эту структуру уже кто-то провалидировал.
2025.94 2031.54 SPEAKER_01 Да, вы конечно можете надеяться, что кто-то перед тем, как забросить ее в сервис, там контроллер как-то ее провалидировал.
2031.54 2045.64 SPEAKER_01 Но так как обычная DTOшка, она все-таки самая по себе мутабельная, у вас нет никаких гарантий, что после того, как эта DTOшка пройдет в первый сервис и вернется в сервис второй, никто ее по пути не изменит.
2045.64 2053.88 SPEAKER_01 То есть, может быть, она была валидной перед тем, как ее передали в первый сервис, а первый сервис ее поменял, и она перестала уже быть валидной, а второй сервис на что должен рассчитывать?
2053.88 2064.24 SPEAKER_01 На то, что валидатор проверил, и там те значения, которые нам гарантирует валидатор, или на то, что первый сервис ее мог поменять, и там уже вообще не понятно, какие значения, и эта структура уже больше не валидная.
2064.24 2067.48 SPEAKER_01 Скорее всего, он не может рассчитывать на то, что эта структура уже валидная.
2067.48 2074.48 SPEAKER_01 И по-хорошему, он должен был бы еще раз вызвать этот валидатор и убедиться, что там находятся валидные значения все-таки, что он все еще может ее использовать.
2074.48 2082.88 SPEAKER_01 Но в общем случае, у системы нет никаких гарантий, что эта структура по-прежнему продолжает быть валидной между разными вызовами.
2082.88 2099.76 SPEAKER_01 И валидацию обычно делают в нескольких местах, как только у вас появляется 10 вызовов сервиса, то сервисы, по-хорошему, каждый из них еще раз вызывает этот валидатор для того, чтобы убедиться, что там есть нужные поля, что они правильного значения, что они правильного рейнджа.
2099.76 2102.88 SPEAKER_01 И вы одну и ту же структуру начинаете валидировать 500 миллионов раз.
2102.88 2113.92 SPEAKER_01 И это всем известный Код Смэл, который называется Шотган Валидэйшн, т.е. когда вы валидируете его просто на каждый чьих, даже если вам это не нужно.
2113.92 2118.88 SPEAKER_01 В российской версии я встречал более показательное название, называется это «железные трусы».
2118.88 2127.16 SPEAKER_01 Т.е. когда вы примерно понимаете, что все будет хорошо, но на всякий случай давайте перестрахуемся, давайте против своих трусов наденем еще десяток железных.
2127.16 2130.40 SPEAKER_01 В общем, вот это и есть Шотган Валидэйшн.
2130.40 2140.84 SPEAKER_01 Т.е. если подводить итоги, то что у нас получается, что метод валидации на вход принимает слабо типизированную структуру, т.е. структуру, которая практически ничего вам не гарантирует.
2140.84 2147.12 SPEAKER_01 И на выходе она тоже дает слабо типизированную структуру, по факту структуру, которая ничего вам не валидирует.
2147.12 2150.28 SPEAKER_01 И это очень сильно напоминает языки нетипизированные.
2150.28 2157.56 SPEAKER_01 Т.е. представьте, что если бы у вас передавались везде обжекты, и вы бы во всех методах принимали бы обжекты.
2157.56 2160.36 SPEAKER_01 Т.е. слабо типизированная структура, ничем не отличается.
2160.36 2170.32 SPEAKER_01 Когда вы строки гоняете какие-то, которые у вас из джессона пришли, и объекты были бы в этих самых полях, черт знает, что там в объекте лежит, может стринг, может инт, может хороший стринг, может плохой инт.
2170.32 2171.32 SPEAKER_01 Неизвестно.
2171.32 2173.16 SPEAKER_01 Вот это и называется слабо типизированная структура.
2173.16 2179.36 SPEAKER_01 Довольно плохой подход, если мы говорим о языке со строгой типизацией, коим мы и являемся.
2179.36 2181.24 SPEAKER_01 Есть подход лучше.
2181.24 2183.44 SPEAKER_01 Этот подход называется парсинг.
2183.44 2184.72 SPEAKER_01 Что такое парсинг?
2184.72 2193.64 SPEAKER_01 Это когда мы берем слабо типизированную структуру, и на выходе отдаем более структурную и более типизированную структуру.
2193.64 2195.76 SPEAKER_01 Т.е. уже строго типизированную структуру.
2195.76 2199.64 SPEAKER_01 Отдаем, естественно, если она валидна, если к нам пришел на вход валидные значения.
2199.64 2207.00 SPEAKER_01 Если значения не валидные, то мы можем выкинуть какой-нибудь эксепшн и рассказать, в чем причина того, что мы не смогли ее распарсить.
2207.00 2210.12 SPEAKER_01 И вот этот процесс называется парсингом.
2210.12 2213.64 SPEAKER_01 Давайте же посмотрим основные отличия от тех проблем, которые мы нашли в валидации.
2213.64 2220.84 SPEAKER_01 Ну, прежде всего, парсинг на входе принимает одну структуру, а возвращает совсем другую, со всем другими свойствами.
2220.84 2225.00 SPEAKER_01 И вот благодаря этим свойствам мы можем добавить туда кучу гарантий.
2225.00 2231.60 SPEAKER_01 Ну, например, мы можем добавить какой-то constraint, который гарантирует нам какие-то условия, которые мы ожидаем.
2231.60 2241.40 SPEAKER_01 Ну, например, если мы хотим распарсить int из строки, то мы можем вполне при парсинге распарсить int и положить ее уже в поле именно int.
2241.40 2254.28 SPEAKER_01 Если мы хотим проверить, что значение строки обязательно должно быть занято, то есть обязательно должно быть задано, то мы можем проверить, что оно задано, и если оно задано, то положить его уже не в нулябельный стринг, то есть в поле с ненулябельным стрингом.
2254.28 2261.80 SPEAKER_01 В этот же момент мы можем гарантировать, что там значение не пустое, допустим, или не whitespace, и положить его в соответствующее поле.
2261.80 2267.52 SPEAKER_01 Или мы можем там взять из строки и распарсить гуид, и положить его в поле уже с гуидом, а не со строкой.
2267.52 2275.74 SPEAKER_01 То есть вот такие примитивные, казалось бы, операции мы можем делать, но при этом мы можем создавать, конструировать на выходе структуру, которая уже нам это все гарантирует.
2275.74 2277.82 SPEAKER_01 Что это значит?
2277.82 2286.94 SPEAKER_01 Это значит, что теперь мы уменьшаем необходимость повторной валидации.
2286.94 2301.94 SPEAKER_01 То есть если раньше вызывающий метод ждал от нас какую-нибудь хорошо отформатированную строку, он вполне может понимать, что к нам пришел объект, в котором уже гарантируется на уровне инвариантов, в том, что это правильно отформатированная строка.
2301.94 2302.94 SPEAKER_01 Он на это может 100% рассчитывать.
2302.94 2310.22 SPEAKER_01 И обычно такие элементы, обычно такие DTOшки, которые переходят между слоями, их делают иммутабельными.
2310.22 2311.70 SPEAKER_01 То есть их невозможно изменить.
2311.70 2318.42 SPEAKER_01 И поэтому он 100% знает, что откуда бы она ему ни пришла, из первого, из десятого сервиса, из пятисотого никто ее не поменял по пути.
2318.42 2322.90 SPEAKER_01 Если этот объект был создан, то он полностью должен сохранять свои инварианты.
2322.90 2332.02 SPEAKER_01 И, соответственно, этот объект, он получается более строго типизированным.
2332.02 2334.82 SPEAKER_01 У него больше гарантий и больше строгой типизации.
2334.82 2339.18 SPEAKER_01 И он соответствует подходу, который называется Illegal State Unrepresentable.
2339.18 2343.94 SPEAKER_01 То есть сделайте невозможные значения недопустимыми в вашем коде.
2343.94 2355.66 SPEAKER_01 То есть если у вас в коде нельзя, чтобы какое-то поле name была нулябельной строкой, то есть имя должно быть обязательным, значит вы можете это выразить на уровне типов и в момент парса гарантировать.
2355.66 2366.90 SPEAKER_01 Это как раз способ сделать нелегальное, как плохое состояние несуществующим с помощью типов, с помощью системы типов.
2366.90 2367.90 SPEAKER_01 И это прекрасно.
2367.90 2371.28 SPEAKER_01 Мы, наконец, начинаем использовать нашу систему типов в полную мощь.
2371.28 2373.34 SPEAKER_01 Ну, по крайней мере, в ту мощь, на которую она нам позволяет.
2373.34 2379.86 SPEAKER_01 Мы уже не передаем какие-то обжекты или какие-то строки между различными слоями, мы уже передаем более или менее гарантию.
2379.86 2389.82 SPEAKER_01 Мы можем передать примитивный тип, а можем даже не примитивный, мы можем распарсить там как его-нибудь URL положить или время с датой положить в это поле, то есть уже какие-нибудь сложные типы делать.
2389.82 2394.74 SPEAKER_01 Или там свой кастомный тип, тип какой-то сделать object value, его распарсить, положить в это поле.
2394.74 2398.42 SPEAKER_01 И с помощью типов гарантировать, например, нулябельность и ненулябельность.
2398.42 2399.42 SPEAKER_01 Что тоже уже неплохо.
2399.42 2402.42 SPEAKER_01 И у нас уже получаются такие хорошенькие типчики.
2402.42 2413.82 SPEAKER_01 Ну, например, если нам нужен какое-нибудь int значение, допустим, возраст человека, мы можем сделать int parse и положить это в значение как раз возраста.
2413.82 2426.94 SPEAKER_01 Если бы мы не воспользовались этим значением, не воспользовались этой возможностью, а попродолжали бы использовать до сих пор наш validate, и нам бы пришла какая-нибудь строка, то мы бы столкнулись с огромным множеством значений.
2426.94 2429.18 SPEAKER_01 Потому что в строке может лежать все, что угодно, не только int.
2429.18 2439.22 SPEAKER_01 А если мы уже сделали какой-то шаг, распарсили, проверили, что там int, мы точно знаем, что вот это ограничение по int у нас лежит в этом объекте, и больше нам его проверять не нужно.
2439.22 2445.82 SPEAKER_01 Больше нам не нужно проверять, что в этой строке лежит, мог бы лежать int, а вдруг там не int, а вдруг что-то еще.
2445.82 2446.82 SPEAKER_01 Вот.
2446.82 2455.46 SPEAKER_01 И после этого мы можем этот int передавать уже дальше вокруг, и все начинают его использовать без дополнительного парса, без дополнительной валидации, и мы убираем как раз вот этот shotgun validation.
2455.46 2458.22 SPEAKER_01 Больше его в нашем приложении не будет.
2458.22 2463.82 SPEAKER_01 Вот этот подход парса, он очень тесно переплетается с уже упомянутой мной value-объектами.
2463.82 2467.28 SPEAKER_01 Мы уже много раз в подкасте обсуждали, насколько value-объекты это хорошо.
2467.28 2470.10 SPEAKER_01 И я напомню, что value-объекты это хорошо.
2470.10 2490.70 SPEAKER_01 Обычно value-объекты сделаются иммутабельными, и как раз, когда вы эти примитивные типы представляете в виде value-объектов, то это очень сильно позволяет вам улучшить читабельность, а самое главное, надежность вашей программы, потому что вам меньше нужно проверять различные параметры на ошибки, вам нужно меньше беспокоиться о том, что там могут передаться какие-то неправильные данные и так далее.
2490.70 2493.78 SPEAKER_01 Ну, например, взять тот же самый возраст человека.
2493.78 2502.62 SPEAKER_01 Когда мы из строки, которая к нам пришла, распарсили интовое значение в возраст, ее можно оставить, положить в int и дальше гонять как int.
2502.62 2515.46 SPEAKER_01 Но на самом деле мы понимаем, что возраст как бы не может быть меньше нуля, ну и не может быть, не может быть больше двухсот, допустим, ну, если вы не получаете пенсию в Соединенных Штатах, то у вас не может быть возраст больше двухсот.
2515.46 2520.10 SPEAKER_01 В общем, и это вы можете все оформить в виде value-объекта, который вам вот эти гарантии даст.
2520.10 2526.02 SPEAKER_01 Он даст, что внутреннее значение не отрицательно и не превышает какой-то порог, которому вашему приложению нужен.
2526.02 2527.02 SPEAKER_01 Вот.
2527.02 2532.66 SPEAKER_01 И этот value-объект точно так же можно распарсить, точно так же можно положить структурку и пойти гонять дальше по приложению.
2532.66 2535.06 SPEAKER_01 Возьмем, к примеру, дата и время.
2535.06 2537.54 SPEAKER_01 Представим, что в нашей системе нет даты и времени.
2537.54 2540.18 SPEAKER_01 В .NET дату и времени не завезли.
2540.18 2541.18 SPEAKER_01 Что в этом случае?
2541.18 2544.58 SPEAKER_01 Ну, в этом случае к нам, скорее всего, будет приходить какая-нибудь строка.
2544.58 2546.58 SPEAKER_01 И что же мы будем делать с этой строкой?
2546.58 2548.26 SPEAKER_01 У нас есть несколько вариантов.
2548.26 2552.98 SPEAKER_01 Ну, прежде всего, эту строку мы можем, опять же, раздать 10500 различных сервисов.
2552.98 2562.54 SPEAKER_01 И каждая из этих сервисов будет пытаться ее распарсить, вычленить оттуда в каком-то виде дату и время, начнет их валидировать в том, что они соответствуют определенным диапазонам.
2562.54 2566.50 SPEAKER_01 И мы получим, опять же, нашу Shotgun Validation.
2566.50 2578.62 SPEAKER_01 Как другой способ, мы можем, например, в одном месте распарсить это все, сформировать из этого какую-то структуру и отдавать ее дальше.
2578.62 2582.02 SPEAKER_01 Таким образом, мы переходим от этапа валидации к этапу парсинга.
2582.02 2584.02 SPEAKER_01 Но каким образом мы можем распарсить?
2584.02 2585.78 SPEAKER_01 Мы можем распарсить это в 6 значений.
2585.78 2590.50 SPEAKER_01 Например, год, месяц, день, час, минута, секунда.
2590.50 2597.46 SPEAKER_01 И вот эти 6 значений упаковать в кортежи, в таплы, и вот тапл из шести значений передавать дальше по всем методам.
2597.46 2598.46 SPEAKER_01 Удобно?
2598.46 2599.46 SPEAKER_01 Ну, не особо.
2599.46 2600.46 SPEAKER_01 Слишком вот длинно.
2600.46 2604.02 SPEAKER_01 Ну, и плюс мы по-прежнему оставляем проблему с валидацией.
2604.02 2607.50 SPEAKER_01 Никто там нам не сказал, что часов максимум может быть 24.
2607.50 2614.80 SPEAKER_01 У нас часы передаются как int, значит, это уже может какой-то отрицательный час быть или больше 24 часов может быть.
2614.80 2620.10 SPEAKER_01 То есть, эта структура в виде таплов, она не очень, ну, лучше, чем предыдущая, но не очень удобная.
2620.10 2621.62 SPEAKER_01 Поэтому есть следующий шаг.
2621.62 2633.54 SPEAKER_01 После того, как мы распарсили, мы можем воспользоваться шаблоном value object и упаковать это в некую структуру, которая нам будет строго гарантировать, что у нее там вся дата и времени хранится валидно и красиво.
2633.54 2636.70 SPEAKER_01 И вот как раз этой структурой и является, по сути, наш data time.
2636.70 2654.50 SPEAKER_01 То есть, если Microsoft додумался до того, чтобы научиться парсить строки вместо валидации, чтобы научиться эти распаршенные уже int значения сложить в одну структуру и сделать из нее value object, то вот почему-то программисты никак не могут привыкнуть к тому, что это нормально.
2654.50 2665.46 SPEAKER_01 Если вам нужен какой-то примитивный класс, если вам нужен какой-то value object, то это нормально уметь его парсить, уметь его форматировать и как можно чаще использовать его в своих приложениях.
2665.46 2672.98 SPEAKER_01 У вас же не возникает никогда идею, а где же мне хранить data time, а в какую структуру мне это засунуть, а как бы мне разложить там минуты и секунды.
2672.98 2673.98 SPEAKER_01 Нет.
2673.98 2680.30 SPEAKER_01 Вы просто берете date time, может быть date time offset, может быть time span в зависимости от того, что вам нужно и просто это храните.
2680.30 2686.46 SPEAKER_01 У разработчиков необходимо выработать такой же рефлекс и на свои собственные какие-то хотелки.
2686.46 2691.26 SPEAKER_01 Вот когда вам нужно хранить возраст, вы не должны пытаться сохранить его в int.
2691.26 2696.46 SPEAKER_01 Вы должны примерно понять, возраст не может быть отрицательным, какие-то ограничения, что я хочу от него.
2696.46 2707.06 SPEAKER_01 Сейчас я быстренько забасаю value object и буду там его парсить и буду в него туда складывать и буду этим гарантировать нормальный возраст на протяжении всех вызовов в моей программе.
2707.06 2708.06 SPEAKER_01 Вот.
2708.06 2718.74 SPEAKER_01 И это вам поможет как раз избавиться от вот этих валидаций, от вот этих шотган валидейшенов и поможет убрать вот этот запах.
2718.74 2740.42 SPEAKER_01 Вот как только вы видите, что вы одно и то же значение проверяете в нескольких местах своей программы и вы понимаете, что в принципе это значение никак не меняется и проверять его по-хорошему бы не надо, но никто вам не гарантирует, что оно не меняется, что оно по-прежнему валидное, то вот это вот хороший code smell именно шотган валидации.
2740.42 2747.26 SPEAKER_01 Значит вы пропустили где-то в той точке, где это значение должно было преобразоваться в нужный тип, вы пропустили вот этот момент.
2747.26 2752.54 SPEAKER_01 Вы пропустили момент парсинга, вы пропустили момент преобразования в настоящий валидный проверенный тип со строгими констрейнтами.
2752.54 2757.66 SPEAKER_01 Вот, вот этот code smell можно легко визуально находить и устранять.
2757.66 2761.18 SPEAKER_01 Итак, подведем небольшие итоги, чем же прекрасен парсинг.
2761.18 2772.42 SPEAKER_01 Парсинг создает вам высокоуровневый какой-то объект, который более строгий, более консистентный и более прекрасный, чем те слабо типизированные объекты, которые в него проходили.
2772.42 2781.66 SPEAKER_01 И одно из самых главных его преимуществ это в том, что этот объект больше не требует валидации, потому что он не может быть, он не может стать невалидным.
2781.66 2786.10 SPEAKER_01 Вся его суть, как нормального бизнес объекта, это в сохранении своих инвариантов.
2786.10 2793.26 SPEAKER_01 И поэтому больше его проверять не нужно, а все, что от него необходимо, он уже проверил на момент своего конструирования.
2793.26 2796.94 SPEAKER_01 И этим становится очень легко и прекрасно пользоваться.
2796.94 2811.74 SPEAKER_01 Поэтому, если вы хотите избавиться от примитив обсессионов, если вы хотите избавиться от code smell validation, шотган валидейшенов и устранить другие вот такие примитивные code smell, то есть запахи в вашем коде, то советую попробовать вот такой подход.
2811.74 2815.46 SPEAKER_01 То есть поменьше использовать валидейта, побольше использовать парса.
2815.46 2816.46 SPEAKER_01 Желательно валидейту вообще отказаться.
2816.46 2820.10 SPEAKER_01 В общем, парс должен заменить вам все в идеальной картине мира.
2820.10 2830.22 SPEAKER_01 И тогда ваш код становится легче читать, легче писать и более поддерживаемый, и меньше в нем ошибок внезапно становится прямо на порядке.
2830.22 2832.46 SPEAKER_01 Поэтому всем рекомендую, подход прекрасный.
2832.46 2835.26 SPEAKER_01 И статья отличная, если кому-то нужно тоже заходите.
2835.26 2839.70 SPEAKER_01 У меня даже добавить, честно говоря, нечего, прекрасно рассказал.
2839.70 2862.18 SPEAKER_01 Действительно, валидировать желательно один раз и больше, чтобы не возвращаться к этому вопросу, потому что, ну, опять же, ловили такое, ну, впроди не впроди, в общем, ловили кейсы, когда ты понимаешь, что у тебя почему-то сломалось что-то на второй валидации, и тут ты начинаешь уже гадать, а почему прошла первая, но сломалась вторая.
2862.18 2876.02 SPEAKER_01 То есть это значит, что в нашем коде какие-то ошибки и не ошибки, которые что-то модифицировали, ну, в общем, возникает много довольно головной боли вокруг этого, действительно, проще это делать в одном месте, чтобы точно быть уверенным, что дальше это значение уже валидно.
2876.02 2884.70 SPEAKER_01 Да, как только получается две валидации, они всегда могут разъехаться, как бы одна добавила условие одно, другое другое, и непонятно, кто из них правильный.
2884.70 2893.98 SPEAKER_01 Кстати, когда у нас появились нулябельные типы, вот эта проблема по parse.validate, она вообще должна была всех затронуть, всех стать.
2893.98 2911.22 SPEAKER_01 Типичная ситуация, когда тебе в контроллер приходит DTO-шка с значениями какими-то, и мы уже обсуждали это, что все поля в DTO-шке должны быть нулябельные, то есть вы должны рассчитывать на то, что к вам придут всегда значения, которые могут не заполнить какое-то из этих полей.
2911.22 2917.66 SPEAKER_01 И чтобы теперь эти нулябельные поля вам передать дальше в бизнес-логику, вам необходимо как-то гарантировать их обязательность.
2917.66 2926.34 SPEAKER_01 То есть бизнес-логика говорит, я не могу принимать, создавать пользователя без обязательного имени, но к нам приходит реквест, и в этом реквесте имени в принципе может не быть.
2926.34 2931.90 SPEAKER_01 И нам нужно каким-то образом, прежде чем отдать управление дальше, каким-то образом проверить, а у этого реквеста есть имя или нет.
2931.90 2948.74 SPEAKER_01 И вот очень часто люди совершают первую ошибку, они заводят метод validate, который загоняет эту DTO-шку, внутри метод validate проверяет, что да, в нулябельном свойстве name действительно хранится что-то, не empty.
2948.74 2962.26 SPEAKER_01 Потом из метода validate они возвращаются и отдают этот name сервису, который создает пользователя, но как его отдать, ведь в name хранится нулябельное значение, там нулябельный тип, компилятор ничего не знает о том, что валидатор вам его только что проверил.
2962.26 2965.90 SPEAKER_01 И они начинают глушить компилятор с помощью восклицательных знаков.
2965.90 2968.94 SPEAKER_01 Так вот, товарищи, никогда в жизни так не делайте, это очень-очень плохо.
2968.94 2973.34 SPEAKER_01 А проблема заключается в том, что вы как раз использовали неправильный подход.
2973.34 2998.02 SPEAKER_01 Нельзя разделять логику валидации и логику преобразования пользователя, то есть преобразование имени пользователя из необязательного в обязательный - это преобразование, это constraint, это типизированная, строго типизированная гарантия, то есть это отдельный процесс, несмотря на то, что в нашем языке он как-то не выделен мега сильно, вам достаточно там какой-то if-чик написать или восклицательный знак поставить, но на самом деле это действительно целый процесс.
2998.02 2999.18 SPEAKER_01 Что же нужно сделать?
2999.18 3072.98 SPEAKER_01 А нужно вместо двух раздельных шагов валидация и преобразования сделать один шаг, который называется parse, то есть метод который у вас, можно так и назвать парс, метод парс, он должен принимать как раз реквест с нулябельным именем и проверять внутри, что это поле не является null и возвращать новый объект, в который вы уже складываете имя уже не нулябельное, уже просто string, без nullable, и в этот момент, как только у вас в одном методе встречается и проверка, и конструирование, и трансформация, компилятор начинает неожиданно вас понимать, потому что в принципе компилятор нулябельных типов, он довольно умный, не идеальный, но для этого уровня его полностью хватает, как только он поймет, что вы в ифи проверили name на не null или на нот string or empty, он вам вполне позволит создать новый класс, в котором значение поля name уже не нулябельное, вы его возвращаете наружу и все, в этот момент у вас есть прекрасный строкотипизированный объект, провалидированный, иммьютабельный, со всеми красивыми рюшечками и проверочками, и даже компилятор вам это теперь гарантирует без всяких дурацких подавлений компилятора, и дальше все по вашему workflow, по бизнес-коду уходит в красивый прекрасный объект.
3072.98 3080.46 SPEAKER_01 Ну прям дополнил статью еще одним примером, очень релевантным и подходящим под наши обычные реалии.
3080.46 3106.06 SPEAKER_01 Давай дальше, дальше у нас еще одна штука, которая долгое время меня занимала, а именно я долгое время видел статьи, и мы уже рассказывали на самом деле про то, что Microsoft внедрила или внедряет новый формат solution файлов под названием slnx, и как вы могли догадаться, он по x в конце, он основан на xml.
3106.06 3112.82 SPEAKER_01 Да, это было в какой-то превью Visual Studio, какая-то превью фича, его нужно было флажочком даже отдельно включать.
3112.82 3120.98 SPEAKER_01 Да, все так и есть, но тут что-то в последнее время как-то его пушили-пушили, статья вышла на devblogs, я решил посмотреть, что это, и выяснилось вот что.
3120.98 3146.02 SPEAKER_01 Значит смотрите, solution файлы, если вы когда-нибудь их открывали в обычном редакторе, просто в текстовом, это текстовый файл, где там с помощью некоторой такой, ну достаточно структурированной, но все-таки не совсем строго структурированной, как в xml, формате, не знаю, структуре еще чем-то, записывается то, как лежат ваши проектики.
3146.02 3154.10 SPEAKER_01 Плюс там есть довольно много всякой разной методаты вокруг ваших проектов, типа там конфигурации, сборки, как раз туда записываются всякие, дебаг релиз, вот это все.
3154.10 3179.66 SPEAKER_01 Но формат файла, он очень неудобен, а главное, он отстановлен частично на отступах, частично он основан на странных гуидах, которые иногда перегенеряются как-то очень странно, и поэтому если вы туда, например вы с solution файлами активно работаете, и там один коллега добавил проекты в solution, другой добавил проекты в solution, то мержить эту конструкцию было очень неудобно, это очень хрупкая штука, и в общем работала так себе.
3179.66 3210.74 SPEAKER_01 И долгое время мы Microsoft просили сделать нормальный формат, вот SLNX в принципе нормальный формат, основан на xml, действительно был поддержан давным-давно в Visual Studio, ну не очень давным, но достаточно давно в Visual Studio в качестве preview фичи, и вот в .NET SDK, начиная с версии 9.0.200, это не совсем релиз, как я помню, это недавно относительно вышел апдейт к девятому SDK, это все поддержано в наконец-таки .NET Command Line туле, которое позволяет все это очень легко делать.
3210.74 3228.46 SPEAKER_01 Значит, что позволяло Visual Studio, Visual Studio позволяло, если включена эта preview фича, сказать save as SLNX формат, и сохранить ваш solution открытый в Visual Studio в новом SLNX формате, для этого вам нужна Visual Studio, то есть вы должны быть на винде.
3228.46 3264.46 SPEAKER_01 А вот теперь это все поддержано в .NET Command Line, вам достаточно сказать .NET SLN Migrate, и соответственно ваш solution превратит, рядышком создастся SLNX файлик, который прекрасно будет работать, на нем можно вызвать .NET Build, на нем можно вызывать всякие addproject, deleteproject, listproject, на нем не работает пара всего команд сейчас, а именно .NET Nuget Y и .NET List Package, то есть то, что связано с Nuget, но вероятно не допилили, как они написали в следующем апдейте, должно все допилиться.
3264.46 3271.14 SPEAKER_01 Еще раз, .NET SLN Migrate в Command Line, и вы смигрируетесь на новый формат.
3271.14 3296.16 SPEAKER_01 Он существенно проще, существенно короче, то есть в примере в статье, типичный solution файл с тремя проектами занимал что-то типа строчек 50 или около того, XML вариант занимает 6 строчек, грубо говоря, 3 тега для трех проектов, один тег, по-моему, какой-то общий, ну и закрывающий открывающий, грубо говоря, все, больше там нет ничего.
3296.16 3311.22 SPEAKER_01 Более того, все это стало возможным, потому что команда Visual Studio создала библиотечку, она называется Microsoft Visual Studio Solution Persistence, которая позволяет работать программно с solution файлами, как в старом, так и в новом формате.
3311.22 3332.82 SPEAKER_01 Вот, поэтому если вам вдруг, даже если вам не очень интересен SLNX формат как таковой, но вам зачем-то нужно, у вас там, не знаю, какие-нибудь кастомные генераторы солюшенов или еще что-нибудь, или парсеры, то вот теперь есть официальная библиотека от Microsoft, которая позволяет solution файлы читать, ну и писать, вероятно, тоже абсолютно нормально, бесплатно, открыто лежит на GitHub.
3332.82 3348.14 SPEAKER_01 В .NET-командной строке, как я сказал, поддержано почти все, в Visual Studio, ну, собственно, поддержана загрузка и сохранение файликов SLNX, после загрузки и сохранения естественно дальше работает полноценная функциональность Visual Studio.
3348.14 3353.66 SPEAKER_01 Скажи, а Visual Studio, это ушло из preview-фичи, это уже нормально поддерживается или по-прежнему нужно галочками?
3353.66 3364.10 SPEAKER_01 Пока вроде в статье нужно все еще галочками делать, и более того, вся статья заканчивается словами про то, что нам нужен ваш фидбэк on our way to general availability, т.е.
3364.10 3369.82 SPEAKER_01 я так понимаю, что это пока еще не general availability, это все еще preview-фича, которая раскатилась на практически весь tooling.
3369.82 3370.82 SPEAKER_01 Вот.
3370.82 3393.94 SPEAKER_01 В C#, где в ките это экстендер для Visual Studio кода, который позволяет пользоваться, ну типа, аналог Visual Studio, да, в некотором смысле, на там Mac и Linux, это тоже включается специальной фичой, JetBrains Rider тоже это поддерживает в некотором предварительном варианте, то, что у них называется preliminary support, но нужно явно это все включать.
3393.94 3407.50 SPEAKER_01 Есть еще такой tool, называется SLNGen, он позволяет вам генерить solutions на основе комплекта каких-нибудь C-Sprite G-Files, вот там это пока не поддержано, там будет генерироваться старый файл, но потом с помощью .NET migrate вы сможете его мигрировать.
3407.50 3439.10 SPEAKER_01 Так что, если вам это интересно, направление, попользуйтесь, посмотрите, пишите фидбэк в GitHub, вероятно, эта фича, я надеюсь, видимо, в течение вот этого года она таки станет нормальной, релизной, мы сможем пользоваться нормальными XML-ными маленькими файликами, не то чтобы XML проще мерзнуть в диффере, но кажется, что будет существенно проще, потому что добавление одного проекта — это новая одна строчка, а не куча строчек с какими-то странными рандомными гуидами в разных местах, как было раньше.
3439.10 3447.58 SPEAKER_01 Да-да, ну точно проще, даже вопрос не в XML, а в количестве этих строчек, которые разбросаны не в одном месте, а по всем SLNG-файлу.
3447.58 3459.70 SPEAKER_01 Вообще, я как бы очень быстро забыл тот ад, который у нас был в C-Sprite G-Files, помнишь, до появления вот этого, как он называется, project base, project file, какая-то такая глупость?
3459.70 3463.18 SPEAKER_01 СДК-бэйс, по-моему, называлась, СДК-бэйс сейчас называется.
3463.18 3487.54 SPEAKER_01 Вот, а когда у нас в проектном файле, я напомню для молодежи, когда у нас в проектном файле там перечислялись абсолютно все CS-файлы, которые у вас были в этом проекте, и это был лютый ад, потому что по той же самой причине, у тебя разработчик добавил 10 файлов здесь, другой разработчик добавил 10 файлов там, и в проекте они добавились все в разные места, и как только ты начинаешь это мерзнуть, это всегда конфликты, всегда боль, всегда ужас как бы.
3487.54 3499.26 SPEAKER_01 Но я думаю, что как у нас стали современные проектные файлы, в которые можно практически ни одной строчки не написать, и при этом у вас будут все CS-файлы компилироваться и выполняться, это стало очень-очень радостно и очень прекрасно.
3499.26 3508.62 SPEAKER_01 Вот я думаю, что так как SLN-файл тоже редактируется довольно редко, а даже если и редактируется, то будет меняться он построчно, то мерзнуть его тоже станет одно удовольствие.
3508.62 3524.02 SPEAKER_01 Ну и самое главное читать, потому что тоже как-то странно вот этот вот дурацкий формат, когда ты заходишь и глазками не можешь понять, а что там интересного творится, как он работает, на куда он отсылается, тоже чувствуешь себя как из прошлого века, а этот вполне легко и приятно читается.
3524.02 3528.22 SPEAKER_01 Ну да, посмотрим, насколько это все заадоптится и будет использоваться.
3528.22 3529.22 SPEAKER_01 Надеюсь, что будет сильно.
3529.22 3531.62 SPEAKER_01 Ну что, давай заканчивать.
3531.62 3532.62 SPEAKER_01 Ждём релиза.
3532.62 3533.62 SPEAKER_01 Да.
3533.62 3534.62 SPEAKER_01 Ждём релиза, чтобы везде это прокинуть наконец.
3534.62 3537.26 SPEAKER_01 Кратко о разном у нас ещё есть немножко сегодня поговорить.
3537.26 3540.70 SPEAKER_01 Во-первых, зарелизился Mono 6.14.
3540.70 3547.10 SPEAKER_01 Я напомню, что Mono был у Майкрософта, потом Майкрософт, видимо, забрав оттуда всё, что нужно.
3547.10 3551.06 SPEAKER_01 Примерно год назад отдала это всё компании Вайночке.
3551.06 3552.06 SPEAKER_01 Вайн.
3552.06 3553.06 SPEAKER_01 Или Вайночке.
3553.06 3556.14 SPEAKER_01 Ты имеешь в виду всех нормальных разработчиков, да?
3556.14 3579.46 SPEAKER_01 Я не знаю, что она там отдала, в итоге исходники оказались у Вайна, с полным владением, как я понимаю, и вот наконец-таки, не то чтобы я сильно этого ждал, но вышел релиз, первый релиз Mono за последние 5 лет, и там не то чтобы это прям какой-то мы просто собрали ради релиза, там есть какие-то изменения, улучшения, он поддерживает нативно.
3579.46 3593.78 SPEAKER_01 ARM64 процессоры, Макосину, CTM, новые процессоры, там есть всякие улучшения, изменения, секьюрити что-то исправлялись и так далее, есть какой-то роадмап на развитие, так что совсем не померло, что-то там пытается жить.
3593.78 3604.38 SPEAKER_01 Ну, я так понимаю, есть какие-то open-source инструменты, которые до сих пор работают на Mono, я не знаю, например, Unity тот же самый, он переехал на Core или до сих пор на Mono или сидит, может быть кто-то еще.
3604.38 3619.34 SPEAKER_01 Кстати, если вы знаете, зачем кому-то нужен Mono, зачем его так активно поддерживают и до сих пор релизят, напишите в комментариях, действительно интересно, остались ли еще какие-то значимые большие проекты, которые по какой-то причине не хотят ехать на Core и при этом хотят на Mono запускаться.
3619.34 3622.94 SPEAKER_01 Да, было бы интересно, потому что я с Mono почти не сталкиваюсь.
3622.94 3639.74 SPEAKER_01 Вот, вторая новость это, а мне кажется, мы уже упоминали, может быть в подкасте даже, может быть я не прав, книжку про .NET Memory Management, наверняка мы точно упоминали первую часть, которую сообщество .NET.RU помогало переводить/вычитывать от Конрада Кокоса.
3639.74 3651.94 SPEAKER_01 Относительно недавно вышла вторая часть, где уже не только Конрад, а в соавторстве с Кевином Госсо и Кристофом Назаро попытались обновить книжку до современного состояния .NET.
3651.94 3679.50 SPEAKER_01 В ходе этого процесса, значит, книжка претерпела некоторое количество изменений и как раз Кевин Госсо написал статейку, где он делится впечатлениями, во-первых, как это все происходило, немножко там инсайдов, и плюс обозревает, удивляется, точнее, единственному, по крайней мере на момент написания статьи, отзыву на Амазоне, который там разгромный, со словами, что книжка вообще получилась полное фуфло, первое издание было гораздо лучше, а второе ни о чем.
3679.50 3685.22 SPEAKER_01 Если почитать статью Кевина, то не очень понятно, почему такой отзыв, потому что идея была в чем?
3685.22 3714.82 SPEAKER_01 Идея была в том, что, во-первых, второе издание должно было быть, ну, таким типа, исправленным и подогнанным под реалии, соответственно, современного дотнета, во-вторых, из него должны были быть выкинуты все, что уже не актуально, то есть там всякие Linux tooling для дотнет корр третьего, но он сейчас уже абсолютно не актуален, сейчас все по-другому, а вот плюс оттуда выкинули, кстати, глава про, если помнишь книжку, первая глава про всякую историю компьютер-сайенса, такого типа там устройства памяти.
3714.82 3716.82 SPEAKER_01 Ну да, ну слушай, многим нравилась хорошая книжка.
3716.82 3723.60 SPEAKER_01 Так вот, все главы, которые выкинуты, они опубликованы бесплатно на сайте книжки, их можно оттуда скачать и посмотреть.
3723.60 3726.34 SPEAKER_01 То есть они… Они пытались так объём уменьшить или что?
3726.34 3731.18 SPEAKER_01 Да, ну типа объём уменьшить, плюс, ну, структура, видимо, так лучше получалась.
3731.18 3745.86 SPEAKER_01 Блин, ну я не хочу бесплатно, я хочу книжечку сесть как бы под камином, за кефиром и… Короче, ну выяснилось, Кевин написал, что, говорит, книжка у меня была, но я, говорит, её никогда не читал от начала до конца.
3745.86 3750.46 SPEAKER_01 Я в неё смотрел, когда мне нужны были какие-то маленькие кусочки, но я её никогда не читал.
3750.46 3754.54 SPEAKER_01 А тут, как бы, ну Конрад позвал, я согласился, пришлось прочитать.
3754.54 3755.54 SPEAKER_01 И я понял, что, короче, всё плохо.
3755.54 3766.86 SPEAKER_01 Значит, Кевин, короче, в статье прямо написано, что кажется, что о пресс как-то очень ужасно вычитывали, огромное количество грамматических ошибок там, сложно читаемых предложений, в общем, как-то с вычиткой у них было так себе.
3766.86 3769.58 SPEAKER_01 Надеюсь, в дотнутру хоть немножко получше, хотя не уверен.
3769.58 3770.58 SPEAKER_01 Получше, получше.
3770.58 3776.46 SPEAKER_01 Ну это была наша первая книжка, так что может быть и не идеально, но мы старались в любом случае.
3776.46 3785.90 SPEAKER_01 Так вот, и в итоге он сказал, что из всей идеи, как бы, а давайте мы, значит, существенно переработаем книжку, типа 80% времени ушло именно на вычитывание старой версии и правку багов в ней.
3785.90 3786.90 SPEAKER_01 Вот.
3786.90 3799.22 SPEAKER_01 Но новые фичи, естественно, добавили, всякие регионы, вот это всё, это всё добавилось, ненужное выкинулось, уменьшился шрифт, за счёт чего книжка похудела и стала не тысячей страниц, а всего 750, при примерно том же объёме материала.
3799.22 3818.02 SPEAKER_01 Значит, и там есть в статье забавный, значит, флоу-чарт, или как это правильно называется, алгоритм, короче, выбора, нужно ли мне покупать второе издание, и там, типа, это, если как бы у вас есть, ну типа, если у вас нет первого, то, конечно, и вы там заинтересованы в memory management, то, конечно, нужно.
3818.02 3834.50 SPEAKER_01 А вот если у вас есть первое издание, типа, вы его прочитали от начала и до конца, ну тогда, скорее всего, вам второе не нужно, вот, потому что, типа, по статьям быстрее добрать, вот, но если у вас его нету, то, в принципе, можно купить, книжка действительно хорошая, на самом деле.
3834.50 3864.50 SPEAKER_01 И, что забавно, Кевин говорит, что, ну, мало того, что надо было вычитывать английский, мы же вычитывали и проясняли моменты с точки зрения, ну, правдивости информации, которая в книжке приведена, и говорит, проблема-то тут в том, что для того, чтобы валидировать такой источник, это надо не просто сходить в Google и почитать, а нужно прям сходить в исходники ГНГЦ, может быть, собрать какой-нибудь тестовый примерчик, убедиться, что Конрад описал именно так, как оно сейчас работает, и оно не перестало работать именно так, как описывал Конрад, или поменялось.
3864.50 3875.42 SPEAKER_01 Он говорит, ну, в общем, короче, пока мы работали над книжкой, я зарепортил как минимум 6 багов ГЦ, которые не нашли, пока что-то делали, вот, пытались воспроизводить эти маленькие примерчики.
3875.42 3878.06 SPEAKER_01 Прикольно, ваш ГЦ не соответствует нашей книге.
3878.06 3879.06 SPEAKER_01 Да, типа того.
3879.06 3889.98 SPEAKER_01 Ну, там какие-то такие, можно сказать, немножко edge case баги, но все-таки баги, ГЦ баги, они такие всегда странные немножко, когда их прочитаешь, кому в голову такое придет, а выясняется, что нет, в реальных программах такое бывает.
3889.98 3918.38 SPEAKER_01 Так что вот, поэтому, если вы раздумывали о том, купить книжку или нет, и отзыв на Амазоне вас чем-то смущает, ну, на самом деле, он действительно странный, потому что, по сути, из книжки выкинуты наиболее, так скажем, литературные, можно сказать, главы, вот те самые, да, история компьютер сайенс, вот это все, в начале которой были, и добавлены куча технической информации про новые фичи, поэтому странно видеть, что книжка стала существенно более лайтовой, чем первая версия.
3918.38 3929.10 SPEAKER_01 Возможно, автор отзыва хотел видеть еще более глубокое погружение, но там глубже уже было, видимо, тяжело с точки зрения сроков времени и всего остального.
3929.10 3975.74 SPEAKER_01 Такие дела по поводу книжки, и третья от меня новость тут буквально вот на глазах, там вчера-сегодня попалась экстеншн для Visual Studio, если вы пользуетесь Visual Studio, гляньте, называется EyeLogger Visualizer, по скриншотикам мне понравилось, я потом попробую, когда до студии доберусь, который позволяет вам смотреть конфигурацию вашего EyeLogger в живую в окошечках, не по конфигу, пытаться понять, где какие ловлевелы, там вот это все, особенно если это все сложно, как-то собирается из разных мест, а прям в живую посмотреть, о, оно, значит, вот выглядит так, причем для некоторых логгеров, если у вас там какой-нибудь ивент логгер есть, там прям кнопочки появляются, посмотреть в Event Viewer, вот это все, ну такое, возможно, чуть более удобно как-то, кому-то будет интересно.
3975.74 3981.30 SPEAKER_01 Мне, по крайней мере, по скринам понравилось, я попробую, не факт, что буду пользоваться, но попробовать поставить, потом выкинуть, почему нет.
3981.30 3982.30 SPEAKER_01 Такие дела.
3982.30 3996.94 SPEAKER_01 Не, ну выглядит действительно классно, да, может, если на практике, то окажется полезным, просто я не знаю, насколько я часто этим бы занимался, ну потому что у меня не было такого плагина, а если есть, посмотрим, да, ну попробовать, но поставить точно стоит.
3996.94 4046.14 SPEAKER_01 Я хочу рассказать, что конференция .NEXT открыла свой незакрывающийся CFP, то есть она ждет докладчиков, и сейчас самое время, если вы вдруг хотели подать доклад, то самое оно, потому что только начало, людей мало, поэтому у вас есть хороший шанс проскочить с хорошей темой и нарваться на незанятого ПК-шника, который поможет вам дотащить ваш доклад до идеального состояния, поэтому все, кто хотел выступить, приглашаем на поддаваться доклад, если вдруг вы чувствуете, что сил у вас маловато и хочется больше практики, но при этом тем мало, приходите на spb.net, я напоминаю, что мы с Игорем и еще другими волонтерами организуем бесплатные митапы, там можно потренировать выступления, там можно научиться выступать перед зрителями, делать слайды и прочие такие технические вопросы мы тоже с вами пройдем.
4046.14 4080.62 SPEAKER_01 Вот, а чтобы вы вдохновились, а также гостям Санкт-Петербурга и живущим здесь, мы приглашаем на наши митапы, у нас регулярно проходят митапы и мне хотелось бы рассказать, какие за одно видосики там сейчас уже выложены, то есть мы все наши выступления записываем и сейчас на ютубе выложены видео с нашего прошлого митапа, мы как раз сделали митап в честь запуска дотнета, дотнет девятого и друзья наши спикеры поделились, а что ж такого интересного в дотнет девятого они для себя отметили, только слушайтесь.
4080.62 4159.66 SPEAKER_01 Дмитрий Нестрюк рассказал нам, что такого нового в C# 13 появилось, Юрий Малич погрузил нас в рев структуры в C# 13, Ринат Тазиев рассказал про перфоманс и какие там улучшения нас ждали, а Виктор Дзицкий приехал издалека для того, чтобы просветить нас, что нового в EF Core 9, а также работа с NoSQL и в частности с MongoDB Provider, что тоже довольно интересная новинка, что в EF Core теперь нормально с MongoProvider работает, Георгий Гуцол рассказал, что нового в SPNet в EF Core 9, Дмитрий Егоров поведал нам об улучшениях в Signal Area в EF Core 9, Андрей Порожняков рассказал, что нового в WebAPI и Валерий Никитин углубился в авторизацию и аутентификацию, в те импрувменты, которые были сделаны в EF Core 9. Вот все эти доклады мы прослушали на митапе, а у вас есть возможность посмотреть YouTube-записи, которые уже выложены, уже вас ждут. Поэтому если вы будете в гостях в нашей северной столице, то обязательно заходите, но свертись с нашим расписанием и если будет возможность, обязательно заходите, у нас еще много прекрасных тем намечено, много интересных мест, и я думаю, не пожалеете увидеть воочию такие доклады.
4159.66 4177.18 SPEAKER_01 Ну и заодно можно с нами тоже пообщаться, если вдруг мы вам еще не надоели. Ну вживую с нами не так часто общаются, поэтому надеюсь, вживую мы не очень надоели, а вживую мы не только про статьи рассказываем, можем поговорить на любые темы. Так, давай на сегодня заканчивать.
4177.18 4226.94 SPEAKER_01 DotNet 10 Preview 2, System Link Async тоже в DotNet 10, Visual Studio 2022 Preview 2. Всего по чуть-чуть, немножко добавили того, немножко всего. Обсудили, что нужно парсить, а не валидировать ваши входные данные, и не надо валидировать их тем более два раза. Посмотрели на все еще пока превью вариант, но все же уже более распространенный формат XML Solution Files с SLNX, ну и кратенько пробежались по небольшим новостям, которые не очень заслуживают прям большой отдельного раздела в подкасте в виде статьи. На этом на сегодня, я думаю, все. Да, всем спасибо, кто нас послушал, шары, репост, рассказы друзьям, лайки там, сердечки, все, что вы имеете, все, что мы любим. И до скорых встреч, всем пока. Всем пока.
