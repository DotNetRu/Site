0.00 14.64 "Анатолий Кулаков" Всем привет, в эфире Radio.net, и это 117 выпуск, в студии у нас, как всегда, Анатолий Кулаков и Игорь Лабутин,
14.64 15.64 "Игорь Лабутин" всем привет.
15.64 36.24 "Анатолий Кулаков" И нам помогают замечательные люди – Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Шевченко Антон, Ольга, красивая, Бондаренко, Сергей Краснов, Константин Ушаков, Постарнаков Андрей, Дмитрий Сорокин, Дмитрий Павлов, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Лазарев Илья, Тимофей, Виталий.
36.24 38.40 "Анатолий Кулаков" Большое спасибо, друзья, всем, кто нас поддерживает.
38.40 42.16 "Анатолий Кулаков" Если вы еще не там, то заходите на Boosty и посмотрите, что у нас есть интересного.
42.16 51.82 "Игорь Лабутин" И как обычно с нами компания Altnar, которая разрабатывает масштабируемые надежные решения для индустрии спортивных данных, которыми пользуются по всему миру.
51.82 59.08 "Игорь Лабутин" Разработкой компания международная, можно качать английский, можно использовать всякие облачные платформы, и вот это все.
59.08 62.84 "Игорь Лабутин" Можно попробовать продолжить карьеру в европейском офисе.
62.84 71.20 "Игорь Лабутин" А также ребята из компании активно делятся опытом, проводят митапы, выступали и выступают с докладами у нас на митапчике, на исповедательном выступали.
71.20 72.20 "Игорь Лабутин" И не только.
72.20 74.72 "Игорь Лабутин" Следить за их новостями можно в телеграм-канале.
74.72 80.40 "Анатолий Кулаков" Ну отлично, нас там Microsoft клепает превьюшки как пирожки горячие.
80.40 82.04 "Анатолий Кулаков" Ни один выпуск практически не обходится.
82.04 85.24 "Анатолий Кулаков" Я так понимаю, что новый превью 5 уже с нами?
85.24 89.64 "Игорь Лабутин" Новый превью 5 уже с нами, но пирожки такие маленькие, пирожочки.
89.64 92.12 "Игорь Лабутин" Потому что в превью 5 прям как-то ну очень мало всего.
92.12 104.60 "Игорь Лабутин" Там есть интересные штуки, сейчас мы их обсудим, но в целом я ожидал какого-то, ну прям, когда открывал там, ну хотелось много всего увидеть, а там по 1-2, 1-2 новости грубо говоря на каждый из разделов.
104.60 105.60 "Игорь Лабутин" Давайте по порядку.
105.60 106.60 "Игорь Лабутин" Библиотеки.
106.60 115.32 "Игорь Лабутин" В библиотеках буквально ровно одна новость, очень полезная в повседневной жизни, вы все ее будете обязательно использовать, добавились алгоритмы для постквантовой криптографии.
115.32 124.76 "Игорь Лабутин" Если вы знаете, что такое алгоритмы MLChem, MLDSA или SLHDSA, то теперь вы их можете использовать в дотнете.
124.76 131.64 "Игорь Лабутин" Это сделано все вокруг, ну в дополнение к другим алгоритмам, которые конечно уже есть.
131.64 136.28 "Игорь Лабутин" Они были отмечены как экспериментал, то есть это пока не финальный вариант.
136.28 159.40 "Игорь Лабутин" Дело в том, что Microsoft немножко отошла от привычного интерфейса про asymmetric encryption, вот этих всех классов, которые нужно отнаследовать, ну в смысле алгоритмы все наследовали эти классы, вы должны были создать объект, потом заимпортировать туда ключ, теперь это статик методы на новых классах, но скорее всего там тоже что-то изменится, потому что они будут экспериментировать с формой того, как выглядит этот API.
159.40 180.72 "Игорь Лабутин" То есть эксперименты с API, может быть это интересно и правильно, и может быть это означает, что даже наши привычные, обычные всякие там DSA и прочие алгоритмы начнут использовать новую форму API, но постквантовые, ну если вам это интересно, поглядите, что там сделали, но я не знаю, насколько это практически полезно пока.
180.72 191.28 "Игорь Лабутин" Рантайм содержит более практические изменения, продолжается эпопея с escape анализом, и теперь добрался этот самый escape анализ для до делегатов.
191.28 215.60 "Игорь Лабутин" Значит напомню, что такой escape анализ это попытка понять статически в момент компиляции, в момент GTA по сути, то есть компиляции по большому счету, что объект не покинет текущую функцию, а это означает, что даже если этот объект нужно бы аллоцировать в кучу, его технически можно аллоцировать на стеке и не тратить время на garbage collector, а потом на то, чтобы его собрать.
215.60 225.28 "Игорь Лабутин" Это было сделано уже для массивов из определенного количества элементов и определенных типов, теперь эта штука добралась до делегатов.
225.28 260.96 "Игорь Лабутин" Напомню, что в момент, когда вы каким-то образом используете внутри функции делегат, лямбдочку, то у вас на самом деле аллоцируется в теории два объекта, там могут быть понятные исключения, но в целом в среднем будет аллоцироваться два объекта, один объект это собственно сам объект делегата, который нужно будет вызвать, на котором вызывается потом метод invoke под капотом, а второй объект это если вы захватывали какие-то переменные в этой лямбде, то объект замыкания его тоже нужно аллоцировать и он тоже будет в куче.
260.96 278.44 "Игорь Лабутин" Сейчас в пятом превью мы добрались до того, что если можно доказать, что эта лямбда или этот делегат никуда не исчезают из этой функции, никуда не передаются после того, как функция завершится, то объект самого делегата теперь аллоцируется на стеке.
278.44 282.40 "Игорь Лабутин" Про объект замыкания пока речи не идет, но в планах он есть.
282.40 293.16 "Игорь Лабутин" То есть может быть к релизу мы увидим, что и объекты замыкания тоже будут аллоцироваться на стеке, и это интересно.
293.16 315.76 "Игорь Лабутин" Еще, кстати, я тут вот сейчас что-то подумал, что как раз таки объект замыкания, который по какой-то причине можно будет доказать, что он выходит из области видимости функции, это не всегда плохо, это нормально, но в целом это же один из источников каких-нибудь мемориликов интересных, когда вы замыкаете какой-нибудь большой жирный объект на себя, и потом этот делегат куда-то сохраняете.
315.76 333.28 "Игорь Лабутин" В принципе, как только будет этот escape-анализ, можно будет на этом, может быть, еще и какие-то такого рода анализаторы построить, что вот, мол, у вас тут объект что-то себя замыкает и выходит из области видимости функции, и проверьте, что может быть у вас там что-то не то, как вариант.
333.28 338.56 "Анатолий Кулаков" Это, наверное, возможно будет такой анализ запустить только во время работы JIT, да, то есть только в рантайме.
338.56 360.72 "Игорь Лабутин" Ну, технически код JIT доступен и до, то есть у нас же есть аот, который по сути делает то, что делает JIT, только предварительно, то есть, ну, скорее всего, это да, некоторые все равно в связь рантайма и компайл тайма, потому что, ну, и как я говорю, в принципе, факт того, что мы что-то замыкаем и отдаем наружу, это полезная штука, и, знаете, иногда этим пользуются, и это нормально.
360.72 362.84 "Игорь Лабутин" Но важно понять, что мы замыкаем что-то не то.
362.84 368.84 "Игорь Лабутин" То есть пока это скорее теория, что такое можно будет запилить, такой анализ, но, в принципе, почему нет.
368.84 399.64 "Игорь Лабутин" Дальше в инлайнингах произошли очередные изменения, но они все связаны как раз вот этими всеми штуками, что мы инлайним, мы теперь аллоцируем что-то в стэки, из-за этого может меняться размер методов туда-сюда, и, соответственно, инлайнер и в целом JIT работают гораздо лучше друг… ну, инлайнинг — это часть JIT, но в смысле что они начинают гораздо больше знать о разных частях друг друга, то есть инлайнинг теперь гораздо более активно пользуется результатами профайлинга методов.
399.64 408.96 "Игорь Лабутин" Напомню, что JIT у нас выполняется в несколько теперь фаз, да, фаз, подходов, как угодно назовите, по-английски tiers.
408.96 420.00 "Игорь Лабутин" И, соответственно, если профайлинг информации говорит, что этот метод надо заинлайнить, и это будет полезно, даже несмотря на то, что этот метод очень большой, инлайнер говорит, ладно, давай заинлайним.
420.00 422.44 "Игорь Лабутин" Хотя раньше как бы размер метода был довольно строгим.
422.44 431.16 "Игорь Лабутин" Большие методы старались не инлайнить, потому что это сильно раздувает код, а это сильно бьет потом по кэшам процессора и всему остальному.
431.16 462.00 "Игорь Лабутин" Ну и продолжается улучшение для ARM64, туда подтянули улучшение по write barrier, это так называемые… ну, в смысле write barrier — это штука, которая используется в частности для понимания, чтобы дать понимание garbage-коллектору, когда тот или иной регион памяти был тронут, и из этого garbage-коллектор решает, не пора ли собирать какие-то более высокие поколения памяти, соответственно.
462.00 472.36 "Игорь Лабутин" Ну то есть то, что у нас, например, ссылка на новый объект, мы ее положили в ссылку в более старый объект или наоборот.
472.36 479.24 "Игорь Лабутин" В общем, garbage-коллектор получает более точную информацию о том, что и как у нас можно трекать.
479.24 499.04 "Игорь Лабутин" В результате, из-за вот этих изменений, garbage-коллектор теперь с регионами работает более точно, то есть он более точно знает, какие регионы были изменены и когда, и из-за этого произошло улучшение работы с паузами garbage-коллектора, в смысле он паузится гораздо меньше, примерно на 8-20%, это прям неплохо.
499.04 505.96 "Игорь Лабутин" Естественно, за счет того, что немножко мы проседаем там, где нужно эти write-барьеры писать.
505.96 509.28 "Игорь Лабутин" Но в целом, overall, говорят, что помогает.
509.28 511.44 "Игорь Лабутин" И это все, что произошло в рантайме.
511.44 527.12 "Игорь Лабутин" В C# добавили тоже, ну такую оптимизационную штуку, я крайне не верю, что этим будут пользоваться прям большие широкие массы народа, это очень узкая внутренняя оптимизация, а именно, что типа, ну давай начнем с начала.
527.12 536.60 "Игорь Лабутин" В C# можно переопределять операторы, если у вас есть класс, вы можете переопределить оператор +, вы можете переопределить оператор -, умножить, разделить, ну многие всякие, сдвига и так далее.
536.60 563.64 "Игорь Лабутин" А также в C# есть так называемый compound оператор, то есть когда вы пишете там a+=b, это компилятор по сути разворачивает в a присвоить a+b, и все было бы хорошо, все замечательно, кроме того, что у вас получается следующее, если вы реализовали оператор + на таком классе, то у вас выполнится сначала a+b, обычный оператор + в таком случае создает новый объект, который является, ну, суммой, и результат этого объекта присвоится в переменную a.
563.64 573.40 "Игорь Лабутин" Таким образом на самом деле создается, по сути, лишний объект, потому что можно было бы изменить переменную a прямо на месте, если бы мы имели возможность переопределить оператор +=.
573.40 586.24 "Игорь Лабутин" Так вот теперь такая возможность есть, теперь можно переопределять все вот эти compound операторы, +=, -=, делить=, сдвиги= и так далее, и они будут, по сути, исполняться на объекте на самом.
586.24 592.92 "Игорь Лабутин" То есть это такой, по сути, ну, неунарный оператор, то есть это оператор с одним аргументом, который нужно применить самому к себе.
592.92 603.08 "Игорь Лабутин" Полезно это все становится тогда, когда типы, над которыми происходят эти действия, они достаточно большие, чтобы было заметено вверх этот их копирование.
603.08 620.88 "Игорь Лабутин" Туда как раз попадают всякие тензоры, матрицы, и вот всякие такие большие числовые штуки, над которыми эти операторы довольно чисты, но при этом копировать их довольно дорого, поэтому вот думаю, что примерно этим это все и ограничится, всякими суровой большой математикой.
620.88 636.16 "Игорь Лабутин" На этом все в C#, больше пока ничего новенького и каких-то слухов пока больше не слышно, но зато много изменений в ASP.NET Core, которые тоже, правда, такие все очень нишевые, кроме, пожалуй, одного.
636.16 679.92 "Игорь Лабутин" Первое — это, я даже не знаю, как про это рассказывать, я впервые про эту фичу узнал, если дословно, она называется Configure Custom Security Descriptor for HTTPS Request Queues, т.е. где-то, если ваше приложение пользуется HTTPS с драйвером для того, чтобы принимать входящие коннекты, т.е. это вы работаете на винде, соответственно, дальше вы очень хотите внедриться в то, как это HTTPS работает внутри, то теперь вы можете на вот эти вот очереди запросов, которые там, где-то в HTTPS сидят, навесить кастомные Security Descriptor, чтобы никто другой, кроме вашего приложения, не смог в эти очереди смотреть.
679.92 690.12 "Игорь Лабутин" Короче, это какая-то очень тонкая штука, я не знаю, кому это надо, вероятно, может быть, это нужно как-то для того, чтобы работать в контейнерах, и это именно для этого фича.
690.12 704.84 "Игорь Лабутин" Почему она так как бы, ну, не, вот с New она, наверное, не зря попала, но это что-то очень днишевое, если вы знаете, зачем это, напишите в комментах, я никогда не то, что не видел использования, даже не знал, что так можно.
704.84 730.88 "Игорь Лабутин" Дальше, в Minimal API у нас есть API, которые вызываются через метод addValidation, с addValidation все хорошо, все, как надо там, ничего не меняется, но внутри есть так называемый Resolver, Validation Resolver APIs, которые как раз таки позволяют, я так понимаю, ну, тонко встроиться вот в этот ход валидации.
730.88 748.36 "Игорь Лабутин" Вот эти все API-шки пометили Experimental, видимо, с ними будет что-то происходить, поэтому их пока отметили Experimental, так что если вы вдруг завязываетесь, не просто делайте addValidation на Minimal API, а что-то внутрь пытаетесь строить, смотрите внимательно, что там будет происходить в .NET, в следующих превьюшках, может быть, горят какие-то изменения.
748.36 781.76 "Игорь Лабутин" В OpenAPI произошли некоторые изменения, обновили генерилку на версию 2.0.0 превью 18, чтобы это не было, и почему 18, не знаю, но, видимо, столько превьюшек уже вышло, и также научили генерить метаданные OpenAPI-шные из XML-доков, конкретно про ретурны и респонсы сейчас идет речь, если вы используете над функциями XML-теги returns или response над контроллерами, то они попадут в OpenAPI-спеку.
781.76 832.64 "Игорь Лабутин" Еще пару изменений в Blazor, в Blazor теперь появился способ правильно указывать not-found-page, можно просто передать тип нужной странички в раутер-компонент с помощью специального синтакса not-found-page, и все будет работать, как раньше, через not-found-fragment, а также в Blazor дозавезли метрики и трассировки, т.е. если вы теперь добавите метры для Microsoft ASP.NET Core Components, а также Components Lifecycle, а также Components Server Circuits, то вы увидите всякие разные метрики про, там, как живут ваши компоненты, как там происходит навигация, обработка ивентов, вот это все, а также даже трейсы тоже.
832.64 841.00 "Игорь Лабутин" В Trace Provider нужно добавить Microsoft ASP.NET Core Components, и после этого Blazor-овские компоненты начнут участвовать в трейсингах со своей стороны.
841.00 848.00 "Игорь Лабутин" Это, в принципе, наверное такая самая практически полезная штука в ASP.NET Core.
848.00 875.78 "Игорь Лабутин" В EVE-Core единственная фича, которая оказалась достойной для включения в Bots.new, помимо многочисленных баг-фиксов, это кастомное именование для Constraints, то есть если вы специфицируете какое-то дефолтное значение для Property, то EVE-Core обычно генерирует некоторый датабейзный Constraint, причем с абсолютно рандомным именем.
875.78 899.24 "Игорь Лабутин" Теперь можно явно указать это самое имя, а можно даже указать вообще useNamed Default Constraints, тогда оно будет более предсказуемо генерировать имена, но надо сказать, что как только вы это добавите, первые же следующие миграции она переименует все ваши прошлые Constraints в новую схему, поэтому будьте внимательны и смотрите, что там в миграциях за вас EVE-Core придумает.
899.24 911.28 "Игорь Лабутин" В MAUI, кажется, задумались над тем, как бы попроще писать XML, точнее код, XML-разметку, и появилось два новых нововведения в XAML.
911.28 926.76 "Игорь Лабутин" Одно называется XAML Global Namespaces, это позволяет взять несколько XML-неймспейсов и запихнуть их всех в .NET MAUI Global Namespaces, и тогда можно использовать без префикса.
926.76 936.60 "Игорь Лабутин" При этом xNamespaces специальный такой, он нужен все еще для парсинга, поэтому от всяких x2.tag и прочего не отказаться.
936.60 941.12 "Игорь Лабутин" А с другой стороны появилась штука под названием Implicit Namespaces.
941.12 976.40 "Игорь Лабутин" Если вы у себя в проекте определите константу, это в Property группе надо завести Property под названием Define Constants, и с названием maui.allow.implicit.xmlns.declaration, то после этого можно вообще убрать все xmlns и xmlnsx из XAML, но будет предполагаться, что они там есть, и соответственно код вы должны писать также через x2.там, где нужно, ну и не использовать Namespace, там где Namespace совпадает с xmlns основным, ну тот же Global, который я выше говорил.
976.40 987.80 "Игорь Лабутин" Но все это конечно пока вообще не поддерживается, практически не поддерживается различным XAML-тулингом, который ожидает валидные xmlns с Namespaces и всем добром.
987.80 996.16 "Игорь Лабутин" И встретив x2. несмотря на то, что xmlns, ну Namespaces с именем x не было введено, будет конечно очень удивленный и скорее всего будет писать ошибки.
996.16 1007.00 "Игорь Лабутин" То есть пока к этому не готовы, но это выглядит как будто попытка максимально упростить XAML и избавиться от этого вот xmlного немножко наследия в виде Namespaces.
1007.00 1029.92 "Игорь Лабутин" В maui также добавили в компонент HybridWebView возможность перехватывать реквесты, то есть если например вам нужно добавить какой-нибудь кастомный заголовок в запросы, которые исходят из вашего HybridWebView, вы можете теперь этого добиться, переопределить нужный метод и тогда делать с запросом все, что вам угодно, добавить заголовки и так далее.
1029.92 1080.66 "Игорь Лабутин" Над XAML-ом также задумались в WPF-е, и в WPF-е упростили способ создания гридов, если вы когда-нибудь делали там grid_definition, row_definition, column_definition вот это все, теперь все попроще, можно там сделать чуть более просто, примерчики есть в новости, я сейчас не буду засчитывать весь XAML, который там получается, но он на вид по крайней мере чуть более простой, ну и как обычно performance, код, quality, improvements и вот это все, больше никаких у нас новостей в превью пятом нет, то есть он такой, наверное я бы назвал больше всего это Escape Analysis самое интересное, то есть в runtime ребята что-то важное и нужное делают, остальные все как-то пока затаились, я бы сказал, затаились.
1080.66 1082.86 "Анатолий Кулаков" Готовят нам фичи к следующему превью, наверное.
1082.86 1088.82 "Игорь Лабутин" Ну либо пытаются придумать, как встроить AI в их часть работы, это же наверняка тоже надо.
1088.82 1091.10 "Анатолий Кулаков" Ну главное, чтобы не в runtime, да-да.
1091.10 1102.26 "Игорь Лабутин" Ну в runtime мы видели это в прошлый раз, когда обсуждали как, что там, гитхабовские код-ревью были с помощью AI, так что вот они, встроили, нормально, у них уже выполнены все KPI.
1102.26 1106.74 "Анатолий Кулаков" Да, надеюсь им хватит и больше никакими глупостями заниматься не будут.
1106.74 1116.14 "Анатолий Кулаков" Хорошо, пойдем на следующую темку поговорим, хотелось бы сегодня затронуть логи и несколько интересных оптимизаций, которые Microsoft предлагает нам использовать в своих проектах.
1116.14 1121.38 "Анатолий Кулаков" Ну, прежде всего поговорим о самплинге, давайте начнем издалека.
1121.38 1127.06 "Анатолий Кулаков" Когда мы пишем логи, перед нами возникает обычно парочку дилемм.
1127.06 1159.06 "Анатолий Кулаков" Во-первых, если у нас есть, если мы будем писать слишком мало логов, то автоматически во время диагностики в нашем приложении, когда у нас случаются проблемы, мы становимся немножко слепыми, то есть мы не знаем, что происходило в нашем приложении, а если мы будем писать много логов, то у нас может возникнуть постепенно такой момент, когда мы начинаем просто тонуть в наших логах, то есть у нас там появляются куча каких-то сообщений, которые валятся и которые не очень нам полезны для исследования, допустим, нашей конкретной проблемы.
1159.06 1172.42 "Анатолий Кулаков" Ну, и второй минус такого подхода заключается в том, что мы начинаем все эти логи хранить и, соответственно, тратим очень много времени, денег и сил на то, чтобы их просто сохранять.
1172.42 1182.14 "Анатолий Кулаков" Они просто начинают сжирать место, они начинают сжирать CPU для анализа и прочие минусы получаем мы от большого размера наших логовых записей.
1182.14 1186.62 "Анатолий Кулаков" В общем, и в идеальном мире, что бы нам хотелось видеть?
1186.62 1207.58 "Анатолий Кулаков" Нам бы хотелось, что бы когда у нас есть какой-нибудь сукцесс сценарий, то есть все идет хорошо, то в принципе нам логи в этом мире обычно не очень нужны, а вот если у нас случилась какая-то ошибка, то вот в этот момент нам хочется видеть вообще абсолютно все логи, которые когда-либо происходили по этой цепочке вызовов.
1207.58 1211.50 "Анатолий Кулаков" И постепенно мы к этому сценарию попробуем с вами прийти.
1211.50 1215.26 "Анатолий Кулаков" Наверное, не за одну темку, а за две, но точно в этом выпуске.
1215.26 1218.06 "Анатолий Кулаков" Поэтому не переключайтесь.
1218.06 1222.74 "Анатолий Кулаков" Первая штука, которая позволит нам немножко более удобно работать с логами, это самплинг.
1222.74 1232.58 "Анатолий Кулаков" В 9.NET будет выпущен специальный пакет, который вам позволит уменьшать количество логов, чем-то похоже на фильтринг.
1232.58 1242.22 "Анатолий Кулаков" То есть вы в фильтре всегда могли уменьшить количество логов, если укажете, допустим, что фильтровать только логи, допустим, с уровнем information и выше, все остальные можем отбрасывать.
1242.22 1246.10 "Анатолий Кулаков" В общем, это был типичный фильтринг, он был сначала времен.
1246.10 1251.34 "Анатолий Кулаков" И у него всего как бы два состояния, два переключателя.
1251.34 1253.38 "Анатолий Кулаков" Мы или пишем, или не пишем.
1253.38 1257.58 "Анатолий Кулаков" Самплинг позволяет немножко более точно настроить то, что вы хотите.
1257.58 1262.82 "Анатолий Кулаков" В частности, он помогает вам сделать, обозначить какой-то процент логов, которые будут писаться.
1262.82 1268.50 "Анатолий Кулаков" И плюс позволяет этот процент привязать к различным условиям, допустим, к тому же самому уровню.
1268.50 1280.70 "Анатолий Кулаков" Допустим, мы можем сказать, что, например, логи с уровнем information нужно записать ровно 10%, и тогда 10% именно запишутся.
1280.70 1281.70 "Анатолий Кулаков" Все остальные будут проигнорированы.
1281.70 1289.66 "Анатолий Кулаков" Это нововведение у нас поставляется в пакете Microsoft Extension Telemetry, в общем, и будет доступно всем в новой версии.
1289.66 1304.82 "Анатолий Кулаков" Когда мы в продакшене начинаем все больше и больше писать логов, у нас, естественно, растет и трафик, и плюс сложность самого процесса, и самого приложения, и самого процесса записи логов.
1304.82 1313.62 "Анатолий Кулаков" И типичным сценарием, когда мы сталкиваемся с огромным количеством логов, является как раз понижение уровня логирования.
1313.62 1323.10 "Анатолий Кулаков" Если раньше мы, допустим, писали почему-то все в диагностике, в дебаге и так далее, то включают в продакшене уровень information.
1323.10 1331.82 "Анатолий Кулаков" Но бывает так, что и information у нас там валится, уже тысячи и миллионы записей в секунду, с этим тоже начинаются проблемы.
1331.82 1347.42 "Анатолий Кулаков" И начинают уменьшать даже information, например, оставляют только ворнинги, оставляют только эроры, и постепенно вот такой подход скатывается к тому, что мы начинаем не видеть те инциденты, которые у нас происходят.
1347.42 1350.90 "Анатолий Кулаков" То есть, когда уже все дошло до эроров, это уже как-то слишком поздно.
1350.90 1368.70 "Анатолий Кулаков" Хотелось бы все-таки и оставить какие-то полезные логи, вроде information, или может быть даже иногда какие-то дебажные записи, но, к сожалению, чем больше растет наша пользовательская база, чем больше растет наше приложение, логи сильнее и сильнее нагружают нашу систему.
1368.70 1375.74 "Анатолий Кулаков" И постепенно мы можем утонуть в тех логах, которые просто сыпятся к нам со всех сторон.
1375.74 1381.26 "Анатолий Кулаков" Плюс, приложение начинает жрать больше ресурсов, не только Storage, но и само приложение.
1381.26 1385.46 "Анатолий Кулаков" Если начинает писать больше логов, на это тоже уходят какие-то CPU-юниты.
1385.46 1390.50 "Анатолий Кулаков" Так что выключать, в принципе, не вариант.
1390.50 1391.50 "Анатолий Кулаков" Что же можно сделать?
1391.50 1403.50 "Анатолий Кулаков" Можно, в принципе, оставить тот же уровень логирования, но при этом применить вот этот самплинг, то есть снизить количество тех логов, которые будут писаться на этом уровне, допустим, у этого логера или по каким-то другим критериям.
1403.50 1417.82 "Анатолий Кулаков" Лог-самплинг позволяет как раз оставить какой-то процент этих логов и есть из коробки несколько стратегий, которые позволяют вам определить, какие именно логи оставлять.
1417.82 1419.74 "Анатолий Кулаков" Разберем в основных три из них.
1419.74 1422.10 "Анатолий Кулаков" Это Random, Trace-based и Custom.
1422.10 1423.94 "Анатолий Кулаков" Прежде всего, Random-самплинг.
1423.94 1425.74 "Анатолий Кулаков" Это самая простая штука.
1425.74 1442.58 "Анатолий Кулаков" Подключается к логу с помощью метода addRandomPropabilityStickSampler, выставляется различные критерии, например, если мы выставим 5% от лог-левела Information, то, соответственно, у нас будет оставаться Information только 5%.
1442.58 1458.26 "Анатолий Кулаков" Кроме лог-левела можно еще в критериях выбора сделать, чтобы участвовала категория и Event ID, то есть на основании вот этих полей можно, в принципе, настраивать, какой процент от данных логов мы хотим у себя видеть, мы хотим у себя фильтровать.
1458.26 1473.58 "Анатолий Кулаков" И также этот уровень можно варьировать в рантайме, то есть поддерживается динамическая конфигурация с помощью Option Monitor и без перезапуска приложения вы вполне можете менять эту цифру и вообще эти правила все.
1473.58 1480.58 "Анатолий Кулаков" Trace-based sampling - это самплинг, который завязан на Distributed Tracing.
1480.58 1488.78 "Анатолий Кулаков" Смысл в том, что когда вы пишете логи и когда у вас есть распределенная трассировка, вы хотите держать их консистентными.
1488.78 1498.78 "Анатолий Кулаков" Ну, то есть если вы записали Distributed трассировку в ваше хранилище распределенных трассировок, то и логи вы конечно же тоже хотите записать.
1498.78 1506.90 "Анатолий Кулаков" Это значит, что ваш трейсинг будет полностью покрыт вызовами и всеми логами, которые были в рамках этого вызова.
1506.90 1513.58 "Анатолий Кулаков" Если вы запишите что-то одно, вы уже автоматически теряете вторую часть информации, что естественно плохо.
1513.58 1519.10 "Анатолий Кулаков" При расследовании инцидентов вы очень много можете из-за этого потерять.
1519.10 1523.28 "Анатолий Кулаков" Поэтому данная стратегия позволяет держать логи и трейсинги синхронно.
1523.28 1534.02 "Анатолий Кулаков" Это в частности полезно для микросервисов, которые как раз общаются между собой с помощью распределенных трассировок и помогает держать трейсы и логи синхронными.
1534.02 1537.86 "Анатолий Кулаков" Ну и третья стратегия, которую можно выбрать - это реализовать что-то свое.
1537.86 1548.94 "Анатолий Кулаков" В примере в статье приводится хороший Read Limiter, который позволяет писать только одно сообщение в секунду, если вдруг таких сообщений пришло много.
1548.94 1558.06 "Анатолий Кулаков" Я думаю часто бывает у вас, вы видели такие логи, которые пишутся например в цикле, и у вас запускается цикл на 100 элементов, и на каждом шаге пишется какой-то лог.
1558.06 1561.44 "Анатолий Кулаков" Обрабатываю элемент, обрабатываю элемент и так далее, и так далее.
1561.44 1563.70 "Анатолий Кулаков" Очень хочется их все одновременно причесать.
1563.70 1574.10 "Анатолий Кулаков" Вот такой Read Limiter вполне будет здесь как бы быстрый фикс таких плохих логов вполне приемлем, тем более если у вас их в приложении довольно много.
1574.10 1579.26 "Анатолий Кулаков" Он проверит, что если один и тот же лог пишется чаще чем раз в секунду, он их просто игнорирует.
1579.26 1583.02 "Анатолий Кулаков" Ну и вообще, как самому написать Read Limiter Sampler?
1583.02 1590.94 "Анатолий Кулаков" Очень просто, вам нужно пронаследоваться от специального класса, который называется Login Sampler и перекрыть всего-лишь на все один единственный метод, который называется ShootSample.
1590.94 1595.66 "Анатолий Кулаков" Он в качестве параметра принимает LogEntry и должен вернуть bool.
1595.66 1599.18 "Анатолий Кулаков" Типа нужно ее самплировать или не нужно.
1599.18 1622.94 "Анатолий Кулаков" Если подводить итог и посмотреть на производительность данного подхода, на самом деле кажется, что мы добавляем какой-то CPU Overhead, теперь нам нужно не просто логи писать, а пропускать их через какой-то специальный самплер или даже набор самплеров, которые внутри себя могут содержать какую-то логику по полям и при этом безусловно будет нагружаться CPU.
1622.94 1721.06 "Анатолий Кулаков" Но на самом деле, если мы задумаемся, то самплеры помогают очень хорошо урезать лог-трафик, т.е. трафик записи ваших логов, а это соответственно уменьшает расходы на CPU, т.е. нам не нужно больше обрабатывать какие-то мусорные ненужные рекорды, при этом вы снижаете косты на транспортации логов, вам не нужно их больше куда-то в сети передавать, что-то с ними делать, каким-то образом преобразовывать, а также вы снижаете наценку на хранение, вам не нужно эти логи хранить, поэтому если в общем собрать все плюсы данного подхода, то кажется, что то небольшое увеличение CPU на фильтрацию вполне окупается всеми остальными кб-пунктами и в результате мы получаем что-то среднее между тем, чтобы захватывать абсолютно все логи бездумно и тем, чтобы фильтровать их по какому-то бинарному признаку, т.е. мы уже можем здесь что-то варьировать, поэтому мы можем остаться как с нужными уровнями, но при этом отбрасывать какие-то данные, какой-то информации, которые может быть там не сильно нужны или мы можем им пожертвовать, в принципе такой подход уже доказал свою эффективность, в частности в distributed tracing, в каких-нибудь APM-системах, когда мы захватываем не всю информацию, которая была в запросе, потому что это слишком много на каждый запрос, так напрягать программу, а какой-то процент от этих запросов, вот авторы логов и авторы этого пакета предлагают нам в логах заняться тем же самым.
1721.06 1725.98 "Анатолий Кулаков" То есть захватывать какой-то процент от логов, но при этом оставаться еще с какой-то полезной информацией.
1725.98 1742.78 "Игорь Лабутин" Ну, я бы сказал, что подход интересный, но кажется, что вот random sampling – это прямо какая-то странная штука, типа там оставлять просто 5%, т.е. trace-based я еще понимаю, типа если trace на месте, то и логи к нему на месте.
1742.78 1756.02 "Игорь Лабутин" Если trace нет, то и логов нет, а когда у тебя будет половина логов от операции есть, половины нет, и ну как-то я не знаю, логи же, они… Наверное, такой подход нормальный, если у вас нет связанных логов, т.е.
1756.02 1773.78 "Игорь Лабутин" вы не пытаетесь анализировать как-то, не знаю, какую-то последовательность действий по логу, потому что тот факт, что какого-то действия а сделано, действия b лога нету, не было оно сделано, или лог просто не попал в выборку, ну как-то странно, не знаю, не знаю.
1773.78 1793.74 "Анатолий Кулаков" Ну да, я с тобой согласен, что random в обычных приложениях применить довольно сложно, т.е. сложно придумать какие-то логи, которые не связаны с предыдущими, когда ты не прослеживаешь по логам workflow-процесс, не знаю, например, собираешь какой-нибудь датчик периодически, да, тебе нужно там показания твоего датчика, допустим,
1793.74 1794.74 "Игорь Лабутин" просто залогировать.
1794.74 1820.66 "Игорь Лабутин" Ну вот может быть, да-да-да, т.е. что-то такое, где ты точно знаешь, что у тебя есть строго одна операция, т.е. на самом деле вот может быть тот самый event_id и в этом смысле полезен, т.е. типа там я хочу увидеть 5% логов с каким-то event_id, и это в принципе нормально, т.е. я буду видеть только 5% логов, а не постоянный flow тех же показаний, например, в принципе я понимаю, да, т.е. наверное, наверное в таком виде это имеет свою ценность.
1820.66 1831.02 "Игорь Лабутин" Ну посмотрим, посмотрим, но про логи мы еще доберемся, мы сегодня еще поговорим, давай сначала вернемся к нашей любимой теме, к Aspire.
1831.02 1917.58 "Игорь Лабутин" С Aspire происходит пока ничего, т.е. с самим Aspire каких-то новых превью вроде бы не выходило, если я ничего не пропустил, зато потихонечку именитые авторы, те, которых мы часто обозреваем, в этот самый Aspire начинают погружаться, и в частности до Aspire добрался Andrew Locke, который попробовал сделать следующее, он попробовал сказать, ну окей, Aspire так рекламируется как замена Docker Compose, и вот это все, и все будет круто, легко и прозрачно, а давайте мы возьмем, попробуем перевести приложение на соответственно Aspire какое-нибудь, и занялся, взял он для этого приложение под названием ListMonk, это такой mail list manager, т.е. штука, которая позволяет вам как-то описывать, кому послать письма, какую-то аналитику, ну т.е. такой настройка рассылок, грубо говоря, он не является рассылщиком сам по себе, он только настраивает все, дальше понятно, что какой-то внешний рассылщик это все дело уже, ну через внешние СМТП там и так далее, это все рассылает, вот, я подозреваю, что Andrew Locke этим пользуется, для каких-либо своих рассылок, ну этим программам, поэтому решил взять его и ради фана сделать его Aspire, что добавляет фана, то что сам ListMonk написан на Go, при том для фронта используется Vue, ну как он Vue, наверное, так читается, я каждый раз забываю, как правильно читать.
1917.58 1918.58 "Игорь Лабутин" В превью Vue, да.
1918.58 1955.20 "Игорь Лабутин" В Vue, да, т.е. его можно, собственно, запустить, как единый бинарник, но можно и заиспользовать тот Docker Compose, который они сами рекомендуют у себя на сайте, соответственно, будет лучше использовать Docker Compose, внутри там ничего такого особенного, там всего 2 сервиса, один это Application, а второй это Postgre, который тоже работает как контейнер, но только подмапливает, понятно, свою директорию к себе, там куча shared конфигураций, вольюми, там всякие, понятно, порты наружу торчат, зависимости в смысле, что приложение ждет, пока Postgre запустится, кастомные команды для Docker файлов, вот это все.
1955.20 2006.50 "Игорь Лабутин" Ну, соответственно, Эндрю говорит, ладно, поехали, для начала нам нужен SDK, .NET, ну девятый либо восьмый, ставим его, понятно, что вам нужен Docker, дальше мы ставим пакетч под названием Aspire Project Templates, то есть .NET New Install Aspire Project Templates, и выбираем шаблон под названием Aspire Uphost, это минимальный шаблон Aspire, который поднимет только сам Uphost, напомню, что там есть еще всякие разные там, как он там, Services, по-моему, назывался, или еще как-то второй проект, потом еще Dashboard, в общем, короче, это поднимает минимальный Uphost, который не будет содержать ничего, просто Uphost, и все, там будет всего две строчки кода, Distributed Application Create Builder и Builder Build Run, все, больше ничего.
2006.50 2027.78 "Игорь Лабутин" Дальше пошли по частям, берем базу данных, для того, чтобы заюзать базу данных, для того, чтобы из Docker Compose его превратить в нормальный Aspire кусочек, нужно взять те самые Integrations, которые раньше назывались Components, теперь они Integrations, добавляем package, .NET Add package Aspire Hosting PostgreSQL, и дальше пишем некоторое количество кода.
2027.78 2079.10 "Игорь Лабутин" Эндрю отмечаю, что, конечно, по сравнению с Docker Compose ямлем, переиспользованием всяких разных переменных, ну, в C# это прям, ну, нормальный язык программирования, оно там нормально работает, то есть мы создаем Builder, но он уже создан был за нас, дальше мы говорим add параметр, для секретных параметров, то есть для юзернейма, для пасворда, указываем, что они secret true, дальше добавляем название базы данных, ну, тут уже не секрет, поэтому просто add параметр, указываем порт и контейнер name, ну, потому что мы так хотим, хотя технически этого не обязательно, Aspire как раз, сила Aspire в том, что он сам умеет это делать, вот, но в данном случае Эндрю хотел прям максимально повторить то, что написано в Docker Compose, поэтому и сделал.
2079.10 2106.58 "Игорь Лабутин" Ну и дальше пишем волшебную ленточку из fluent методов, Builder and Progress, это все простая штука, дальше нужно указать какой image, то есть with image, потом под каким именем контейнер должен работать, with container name, потом with lifetime для этого контейнера, with datavolume, чтобы указать какой datavolume использовать, ну и with environment, это какое явное явное переменное окружение внутри контейнера прокинуть.
2106.58 2319.86 "Игорь Лабутин" Все, на этом, собственно, с базы данных все закончено, то есть там буквально десяток строк и все, и дальше нужно перейти к приложению, с приложением все хуже, потому что приложение на Go, поэтому никаких, как бы в виде докер-контейнера, причем, поэтому никаких, ну так скажем, полезностей и прочего вокруг нет, нужно опять же добавить пару параметров, это admin_user и его пароль тоже секретные, естественно, а дальше приседать с ручной магией, то есть можно сказать, есть метод add_container, который позволяет добавить, собственно, конкретный докер-контейнер, который вы хотите использовать, можно указать, что надо подождать базы данных, для этого есть специальный метод wait_for, тут все удобно, можно добавить astata_point_point, тут все прекрасно, with astata_point_point, можно добавить external_astata_point_point, это понятно, то что нужно выставить наружу, то что вы делаете в expose, когда пишете докер-композ, можно добавить любые аргументы, тут тоже, это кастомная стартовая, ну, кастомный entry_point, bind_mount тоже все нормально, забайдить это самое, дальше вы перечисляете with_environment, with_environment, with_environment, то есть все переменные окружения, которые нужно задать, а здесь их примерно на глаз 15 штук, вы аккуратно напишите через with_environment, выглядит, честно говоря, так себе, я бы, наверное, ожидал какого-то более красивого синтаксиса, но что есть, то есть, но entry_prof сам предупреждает, что, может быть, он что-то не понимает, и есть ли какие-то более красивые способы это сделать, мол, если есть, напишите в комментариях, в комментариях какого-то, ну, прям, что-то более красивого я не видел, дальше, testing говорит, ну, что, для тестирования нам нужны те переменные, мы, параметры, точнее, которые мы обозвали секретами, нужно их добавить, добавляется это все через стандартную дотнетовую секрет-охранилку, то есть dotnet_user_secrets_set, ну и дальше параметры с дветочиями, параметры и значения, ну и делаем dotnet_run, и все работает, все прекрасно запускается, все замечательно работает, можно пощупать, потрогать, убедиться, что все как надо, и, видимо, андроид действительно, ну, как-то использует эту штуку сам, поэтому он проверил, что все нормально работает, все хорошо, но дальше, соответственно, возникает вопрос, ну, с Aspire-ом-то вы же не будете запускать в Prodee, да, хотелось бы паблишинга, паблишинг — это недавнее добавление в Aspire, мы недавно про это рассказывали, и одна из совсем недавних штук в паблишерах — это Docker Compose, для этого нужно пойти в мир превьюшек, и вот тут начинаются прям совсем некрасивости, во-первых, нужно добавить пакетч под названием Aspire Hosting Docker версии 9.3.0 preview 1.25.265.20, ну, вероятно, последний превью на тот момент, дальше нужно заимейблить, тут все просто, в коде пишем — это Docker Compose Environment, и все, и в общем-то это все, что нужно сделать, единственное, что все, что специфично для Docker Compose, а именно всякие restart policy и вот такие штуки, которые не являются конфигурацией конкретного контейнера, а именно Compose, то нужно добавить явные вызовы fluent-методов, там publishes docker-compose-service и в лямбдочку передать там всякие настройки типа service.restart, присвоить unless-stopped и вот это все.
2319.86 2380.38 "Игорь Лабутин" Дальше нужно поставить Aspire.com.online, для этого мы ставим dotnet tool install global Aspire.kli, минус-минус, пререлиз, оно еще пререлизное, поэтому ставится только так, ну и наконец-таки мы можем сказать Aspire.publish и получить два файлика на выходе, это .env, куда нужно задать все наши переменные, которые мы задали как параметры, ну и файлик docker-compose, который является собственно докер-композом, и надо сказать, что результат довольно сильно похож на исходный докер-композ, из которого собирался этот самый Aspire-ный хост, так что выглядит все вполне надежно, в том плане, что можно доверять так скажем тому, что если вы возьмете Aspire и на нем напишете примерно то, что написано в докер-композе, в результате у вас получится очень схожий по поведению докер-композ файл, который будет работать примерно так же.
2380.70 2481.02 "Игорь Лабутин" И надо сказать, что вот это вот, собственно, на этом статья заканчивается, надо сказать, что идея про то, что давайте возьмем Aspire и перепишем реальные проекты может быть довольно привлекательной, как ну такая реклама что-ли, да, того, что Aspire действительно работает и его можно использовать, и Microsoft про это тоже подумал, и они запустили очередной YouTube, ну не каналчик, очередной YouTube-плейлист под названием "Aspire Fridays", это короче такое лайв-шоу, в котором трое товарищей, а именно Дэвид Фаулер, его давний кореш Дамьен Эдвардс, они же вместе как раз всегда выступали, мне кажется, вот, и Мэдди Монтакилло, это я так понимаю то ли PM Aspire, то ли, ну в общем, кто-то из, около такого технического менеджмента Aspire, они все втроем, иногда с гостями, сидят и пытаются в прямом эфире взять какое-нибудь приложение на Дотнете и перефигачить ее, ну может быть не только на Дотнете, кстати, они будут это делать, не знаю, но пока все было на Дотнете, и перефигачить в Aspire, вот, там уже вышло два полноценных больших выпуска, первый выпуск был посвящен такому продукту как Bitwarden, если кто не знает, есть Bitwarden, это такая хранилка паролей, да, там как onepassword и прочее, и вообще оригинальный Bitwarden написан на Дотнете, серверная часть по крайней мере.
2481.02 2493.54 "Игорь Лабутин" Раньше была, по-моему, и клиентская тоже, но по-моему, клиенты они в итоге сейчас выкинули Дотнетную версию, вроде как собирались переписать на что-то более нативное, типа React Native или что-то такого, но не помню, не знаю, в чем это получилось.
2493.54 2517.66 "Игорь Лабутин" А серверная написана на Дотнете, правда все в основном пользуются Bitwarden RS, потому что протокол стандартен и переписанный на более компактных языках, так скажем, Дотнеты, потому что очень какая-то развесистая, там что-то типа поднимается в 8 или 10 контейнеров, чтобы работал сервер и так далее, ну, короче, там очень развесистая версия, в отличие от Bitwarden RS, где все это в один контейнер запихнуто.
2517.66 2527.66 "Игорь Лабутин" Но смысл не в этом, смысл в том, что сам Bitwarden на Дотнете они взяли и за 3 часа плюс-минус смогли его поднять в формате Espire приложения.
2527.66 2531.94 "Игорь Лабутин" Ну, в принципе, наверное, неплохой результат.
2531.94 2545.38 "Игорь Лабутин" Во втором видосике они, соответственно, собрались еще и с Джо Гуаданьо, это такой спикер, ну, я его знаю как спикера, вот, наверняка он еще чем-то известен, не помню еще с чем.
2545.38 2553.54 "Игорь Лабутин" У него есть его личный сайт, на котором он там бродкастит все и так далее, но тоже на Дотнете, и они, соответственно, его там тоже 2 часа переводили на Espire.
2553.54 2566.38 "Игорь Лабутин" Вот, я их видео целиком не смотрел, смотрел только кусочки там местами, там нарезка есть в плейлисте, в общем, я ссылочку приложу, поглядите, интересно, как на это самое, в прямом эфире народ все это переписывает.
2566.38 2569.74 "Игорь Лабутин" Не уверен, что нужно смотреть все 3 часа, но с другой стороны почему нет.
2569.74 2578.38 "Игорь Лабутин" Так что вот, может быть, это будет такой интересной рекламой, ну, или антирекламой, кто знает, насколько много они найдут в Дотнете проектов, чтобы их так переписать.
2578.38 2589.74 "Анатолий Кулаков" Слушай, странно, почему они до сих пор какую-то конвертилку не сделали, если настолько все ровно и прямо переписывается, и все просто, все хорошо, могли бы автоматизировать уже.
2589.74 2598.42 "Игорь Лабутин" Слушай, ну 3 часа, это не ровно и хорошо, это прям как-то немало на самом деле для Дотнетного же продукта, мне кажется.
2598.42 2600.58 "Анатолий Кулаков" Ну ладно, тогда надо узнать, какие проблемы.
2600.58 2602.86 "Анатолий Кулаков" Ну вот для этого надо посмотреть видео.
2602.86 2608.10 "Анатолий Кулаков" Да, у Лока чуть ли не посрочно там все получилось, и вроде казалось, что просто можно было делать.
2608.10 2626.50 "Игорь Лабутин" Да, у Лока все просто, но я так, знаешь, это избранные моменты очень смотрел, и я там в какой-то момент как бы, скажешь видео, там написано типа там в ком-онлайне написано Дотнетран, по-моему, и все сидят смотрят в экран, и типа задают друг другу вопрос, что он делает, да кому билдит.
2626.50 2644.98 "Игорь Лабутин" И они так типа 5 минут сидят и смотрят типа, а что делает, наверное, все еще билдит, интересно, типа, вот, там короче, я так понимаю, что не все так просто, может быть, это еще от продукта, конечно, сильно зависит, может там продукт так написан, что он билдится по полчаса, даже и без Aspire, фиг знает, не знаю, я там его 6 раз собрал, вот уже 3 часа прошло.
2644.98 2656.70 "Игорь Лабутин" Поэтому, ну в общем, поглядим, говорят, что они это стараются делать, ну если не каждую, то раз в 2, в пятницу, посмотрим, куда подвинется.
2656.70 2665.62 "Игорь Лабутин" Я думаю, что к релизу, ну там или хотя бы через несколько месяцев у нас будет какая-то статистика на предмет того, насколько это все популярно, интересно и так далее.
2665.62 2669.42 "Игорь Лабутин" Просмотров там не так, что сильно много пока, но как есть.
2669.42 2670.42 "Игорь Лабутин" Вот.
2670.42 2680.86 "Анатолий Кулаков" Ну вот если вы хотите, чтобы ваши лайв-демо смотрели, то предзаписывайте их, а потом на монтаже вырезайте все эти 5-минутные компиляции, да?
2680.86 2687.70 "Игорь Лабутин" Ну тогда будет непоказательно, здесь-то они все-таки стараются, чтобы было живо… Ну ладно, пусть видят, как они мучаются.
2687.70 2696.74 "Игорь Лабутин" Да-да-да, то есть они там типа реально сидят, пытаются понять, что как, что не так пошло, а почему вот так, а почему вот это как-то вообще работает.
2696.74 2698.58 "Игорь Лабутин" В общем, нет, нормально, нормально такой.
2698.58 2699.58 "Игорь Лабутин" Интересный экспириенс.
2699.58 2702.74 "Анатолий Кулаков" Да, наверное, тоже формат, да, почему бы и нет.
2702.74 2709.30 "Анатолий Кулаков" Давай вернемся к логам, я обещал решить все проблемы с логами, и наконец пришел этот момент, когда мы все-таки должны их все решить.
2709.30 2720.94 "Анатолий Кулаков" Вторая статья, которая вышла в блоге про телеметрию, это запись логов по требованию и использование буфера для логов.
2720.94 2725.62 "Анатолий Кулаков" Как же буфер и запись по требованию могут решить какие-то наши проблемы?
2725.62 2746.94 "Анатолий Кулаков" Ну, напомню, что наша главная цель, когда мы логируем все-таки, состоит в том, чтобы мы детально записывали ту информацию, те логи, которые произошли в момент какой-то ошибки, ну, естественно, все, что привело к этой ошибке, и те логи, которые, в принципе, выполнялись по какому-нибудь успешному пути, нам обычно не нужны, не интересны.
2746.94 2752.98 "Анатолий Кулаков" Может быть какая-то базовая информация о них, может быть какая-то сэмплированная информация, но полностью они нам уже не так сильно интересны.
2752.98 2762.46 "Анатолий Кулаков" И вот эту проблему уже собирается решить как раз лог-буферинг, который появился в DotNet 9.
2762.46 2775.18 "Анатолий Кулаков" Он представляет собой временное хранилище в памяти, которое позволяет вам принять решение о том, хотите вы записывать некую пачку логов или не хотите, позже, не тогда, когда они произошли, а в какой-то другой момент.
2775.18 2785.54 "Анатолий Кулаков" Концепция логов, концепция того, как пишутся логи и сохраняются немножко в этот момент меняется.
2785.54 2787.62 "Анатолий Кулаков" Что происходит?
2787.62 2807.14 "Анатолий Кулаков" Прежде всего, этот фреймворк, он мачет те логи, которые должны быть записаны в память, а не напрямую, сразу куда-нибудь заброшенные в сеть, то есть в Storage, например, и принимает решение о том, что с логами делать.
2807.14 2809.62 "Анатолий Кулаков" Решение может быть в двух состояниях.
2809.62 2815.82 "Анатолий Кулаков" Или записать все логи, или просто-напросто выбросить, забыть про эти логи, то есть отменить их.
2815.82 2832.86 "Анатолий Кулаков" И как раз вот этот подход нам и позволяет реализовать один из сценариев, который позволяет реализовать — это запись как раз ошибочных веток развития вашей программы и отбрасывания, допустим, успешных веток.
2832.86 2853.50 "Анатолий Кулаков" Например, в нашей программе есть какая-то валидная транзакция, которая там выполняется, и может быть даже к базе данных, и вы хотите полностью проследить путь этой транзакции, как вы подготавливаете на нее данные, как вы запускали ее исполнение на базе данных, что в этот случай произошло и так далее.
2853.50 2868.02 "Анатолий Кулаков" И вы можете настроить ваше приложение, ваш логин таким образом, чтобы данные сохранялись в Storage, ваши логи сохранялись в Storage только тогда, когда транзакция завершилась фейлом.
2868.02 2878.42 "Анатолий Кулаков" Если вдруг транзакция завершилась успешно, вы можете сказать, что теперь все логи, которые относятся к этой транзакции, в принципе, просто выбросили, просто забудь про них.
2878.42 2888.38 "Анатолий Кулаков" Из коробки .NET 9 поставляет две стратегии — это глобальный буферинг и буферинг на уровне реквеста.
2888.38 2897.26 "Анатолий Кулаков" Глобальный буферинг работает на уровне всего приложения, а на уровне реквеста — на уровне одновости типа реквеста, соответственно.
2897.26 2898.26 "Анатолий Кулаков" Давайте разберемся подробнее.
2898.26 2909.26 "Анатолий Кулаков" Глобальный буферинг использует циклический буфер для того, чтобы записать временно все ваши логи, которые происходят внутри приложения.
2909.26 2916.54 "Анатолий Кулаков" Обычно этот буфер используется для каких-нибудь долгоиграющих процессов или, например, бэкграунд тасок.
2916.54 2923.62 "Анатолий Кулаков" Подключается он очень просто, у билдера логинга вызываете метод addGlobalBuffer и все.
2923.62 2927.22 "Анатолий Кулаков" В этом глобальном буфере вы можете настроить несколько параметров.
2927.22 2937.58 "Анатолий Кулаков" Например, maxBufferSize, который вам показывает, при каком достижении размера старые логи будут отбрасываться.
2937.58 2942.46 "Анатолий Кулаков" То есть понятно, что если мы храним в памяти, то в памяти этот буфер не бесконечен.
2942.46 2951.14 "Анатолий Кулаков" Поэтому программа должна понимать, что делать, если этот буфер у нас кончился, а при этом вы логи еще не записали в Storage.
2951.14 2956.50 "Анатолий Кулаков" Нужно определить, в какой лимите они будут удаляться, они будут стираться.
2956.50 2966.34 "Анатолий Кулаков" magLogRecordSize - это размер одной индивидуальной записи логовой, то есть сколько она будет занимать в байтах.
2966.34 2974.22 "Анатолий Кулаков" Это как раз тоже, чтобы мы не смогли в один лог запихнуть весь томик Войны и Мира, чтобы тоже программа каким-то образом это контролировала.
2974.22 2985.86 "Анатолий Кулаков" Дальше, каким образом мы теперь все-таки можем сбросить этот глобальный буфер, который во время жизни всего нашего приложения там где-то копится, копится и постепенно собирает много-много данных.
2985.86 2995.74 "Анатолий Кулаков" Все очень просто, вам нужно заинжекшить куда-нибудь к себе класс, который называется GlobalLogBuffer, и у этого класса вызвать метод flush.
2996.30 3001.06 "Анатолий Кулаков" Соответственно, все логи уйдут в этот момент в сторидж.
3001.06 3010.26 "Анатолий Кулаков" Теперь гораздо более интересный кандидат - это стратегия, которая позволяет вам буферизировать записи на уровне реквеста.
3010.26 3013.42 "Анатолий Кулаков" Естественно, это полезная штука для веб-приложений.
3013.42 3017.90 "Анатолий Кулаков" Она более гранулярная, чем писать вообще все логи вашего приложения.
3017.90 3024.54 "Анатолий Кулаков" Она работает на уровне каждого отдельного CTP-реквеста, то есть у каждого CTP-реквеста будет свой собственный буфер.
3024.54 3035.50 "Анатолий Кулаков" Добавляется она в BuilderService.adp.incomingRequestBuffer, и основные отличия ее от глобального буфера следующие.
3035.50 3045.14 "Анатолий Кулаков" Когда HTTP-реквест заканчивается, то все записи, которые есть под буфером, по умолчанию отбрасываются, то есть отменяются.
3045.14 3052.06 "Анатолий Кулаков" То есть, по сути, если вы просто подключите этот буфер, то у вас все логи будут отбрасываться.
3052.06 3059.86 "Анатолий Кулаков" Вам нужно явно сделать запись в каком-то месте, где вы решите.
3059.86 3071.42 "Анатолий Кулаков" Для того, чтобы сделать запись, то есть зафиксировать все ваши логи из буфера, вам нужно заинжектировать в какой-нибудь класс PureRequestLogBuffer класс и вызвать у него метод флаж.
3071.42 3073.70 "Анатолий Кулаков" После этого все записи уйдут в хранилище.
3073.70 3087.66 "Анатолий Кулаков" Здесь следует отметить, что как только вы зафлажите PureRequestBuffer, у вас автоматически будет зафлажен и GlobalBuffer, потому что эти записи могут быть каким-то образом скоррелированы.
3087.66 3090.82 "Анатолий Кулаков" То есть, какая-то наведенка или какая-то взаимосвязь между ними будет.
3090.82 3092.50 "Анатолий Кулаков" И для диагностики вам это будет полезно.
3092.50 3098.14 "Анатолий Кулаков" Итак, Best Practices, рассмотрим с этим подходом.
3098.14 3118.38 "Анатолий Кулаков" Прежде всего, нужно буферизировать грамотно, то есть вам нужно буферизировать детальную информацию на Information Control и при этом какие-то на уровне Error и Critical, если вы будете записывать данные на уровне Error и Critical, важно флажить их сразу.
3118.38 3133.70 "Анатолий Кулаков" Как только у вас появилась какая-то ошибка, сразу желательно все зафлажить, для того, чтобы диагност, то есть человек, который отлаживает сейчас вашу программу, мог вот эту ошибку вашу увидеть мгновенно, чтобы не ждал, что она появится через каких-то 5 минут, пока буфер опустошится и так далее.
3133.70 3141.82 "Анатолий Кулаков" Все-таки ему ошибки хочется видеть сразу, поэтому важный момент, ошибки надо записывать, как только они произошли.
3141.82 3148.70 "Анатолий Кулаков" Еще один Best Practices, это делайте явные флажи.
3148.70 3157.46 "Анатолий Кулаков" Вам нужно найти те места, которые подходят под ваши условия, в которых вы хотите сделать явные флажи.
3157.46 3179.88 "Анатолий Кулаков" Ну, например, что это может быть, как я уже выше сказал, это места, в которых произошли исключения или какие-то важные ошибки, вот там нужно флажить буфер, это места, в которых, например, ваш запрос исполнялся дольше, чем нужно, дольше, чем вы ожидали, или где вы обнаружили какие-нибудь странные места, странные шаблоны поведения вашей программы, в которые вы не ожидали зайти.
3179.88 3183.34 "Анатолий Кулаков" Если вы их обнаружили, то тоже это хороший способ зафлажиться.
3183.34 3188.70 "Анатолий Кулаков" И еще один Best Practices, это полезно сочетать буферинг и самплинг.
3188.70 3193.18 "Анатолий Кулаков" То есть необходимо использовать оба подхода, буферинг и самплинг вместе.
3193.18 3211.74 "Анатолий Кулаков" Самплинг, как мы уже обсуждали выше, это способ уменьшить какое-то количество однотипных логов, которые к вам записываются в Storage, а буферинг как раз позволит вам определить о том, какие логи вам нужны в данный момент, а какие вообще не нужны, их можно отбросить.
3211.74 3219.22 "Анатолий Кулаков" Казалось, волшебная технология, в принципе, то, чего мы ждали всю нашу жизнь, записывать только то, что нужно, а не записывать только то, что не нужно.
3219.22 3230.86 "Анатолий Кулаков" К сожалению, у этого подхода есть какие-то огромные ограничения, которые, по моему мнению, делают его просто недееспособным.
3230.86 3234.30 "Анатолий Кулаков" Давайте посмотрим, что это за ограничения такие.
3234.30 3259.10 "Анатолий Кулаков" Ну, по мелочи, во-первых, он доступен только с девятого .NET, это в принципе не проблема, дальше он не гарантирует тот порядок, в котором логи он получил, то есть порядок логов в буфере не гарантируется, но при этом остается таймстэмп, поэтому хранилище, в которое вы отправите эти логи, в любом случае по таймстэмпу их переупорядочат, в принципе, тоже небольшая проблема.
3259.10 3275.74 "Анатолий Кулаков" Дальше пошли большие проблемы, это в том, что сейчас не поддерживается лог в Scopes, а в лог в Scopes записывается очень много полезной информации, то есть это вся embed-информация, которая сейчас происходит с данным потоком логирования.
3275.74 3300.90 "Анатолий Кулаков" Также у нас не поддерживаются очень важные пропертии, которые, например, используются в Distributed Tracing и в телеметрии, ну, например, Activity Span ID, Activity Trace ID, и еще важные свойства — это Message Template, допустим, и Thread ID, ну, Thread ID, ладно, это какие-то мелочи, вот Message Template, почему нельзя было записать, это какой-то большой вопрос у меня возник.
3300.90 3311.98 "Анатолий Кулаков" В общем, некоторые ограничения довольно странные, не очень понятно, чем они вызваны, то есть технических особых проблем я не представляю, возможно, они находятся где-то глубже.
3311.98 3330.54 "Анатолий Кулаков" В общем, может быть, это еще будет доделано, может быть, там какие-то технические проблемы с этим есть, в общем, будем разбираться, смотреть, потому что технология интересная, подход классный, и ломаться на таких банальных вещах, которые всем нужны по-любому, было бы довольно странно.
3330.54 3367.62 "Анатолий Кулаков" Итак, если мы рассуждаем про Performance, то, конечно, потребление памяти у нашего приложения возрастает, ну, до тех самых пор, пока все сообщения собираются в буфере, до тех пор, пока мы не решим, что с ними делать, или зафлашить, или отменить, в общем, они будут копиться в памяти, но при этом нужно понимать, что это еще один способ очень сильно уменьшить использование Storage, потому что только те записи, которые будут заимичены, которые относятся к нашему конкретному сценарию, только они будут занимать место, а все остальное будет просто отброшено.
3367.62 3380.78 "Анатолий Кулаков" Если мы врубаем такой банальный сценарий, как записывать только ошибки, а успешные пути вообще не логировать, то при нормальном работе нашего приложения Storage у нас вообще будет пустой, как бы сказка.
3380.78 3389.26 "Анатолий Кулаков" Естественно, до такого доводить, наверное, не стоит, все-таки хочется какую-то информационную политику тоже получать, но в общем случае идеальная картина мира выглядит прекрасно.
3389.26 3393.46 "Анатолий Кулаков" Итак, что же мы получаем?
3393.46 3401.82 "Анатолий Кулаков" Логбуферинг может очень сильно уменьшить ваши накладные расходы на хранение информации, но может быть даже нет, самое главное.
3401.82 3420.66 "Анатолий Кулаков" Самое главное, что он может очень сильно увеличить уровень диагностики, который вы получаете, как только начинаете исследовать какую-то проблему, потому что больше у вас не мелькает перед глазами гигабайт и ненужной информации, вы ровно и четко по ним получаете только те логики, которые относятся к всей ветке выполнения вашей проблемы.
3420.66 3431.94 "Анатолий Кулаков" Если эти чудики починят еще нам Distributed Tracing поля, то мы будем получать абсолютно весь трейс между всеми микросервисами, которые относятся к данной проблеме.
3431.94 3439.82 "Анатолий Кулаков" В общем, и это прекрасно, в общем, будем смотреть за развитием проекта и надеемся, что парни вырулят в нужную сторону.
3439.82 3450.86 "Игорь Лабутин" Это действительно так, будем очень надеяться, но хотя меня вот все-таки необходимость какого-то ручного флэша как-то пока триггерит.
3450.86 3457.74 "Игорь Лабутин" Я же правильно понимаю, что там нет возможности сказать, что типа, а если ты увидел эррор, то флэш не все, что ты сейчас, допустим, в рамках текущего реквеста
3457.74 3458.74 "Анатолий Кулаков" собрал?
3458.74 3470.58 "Анатолий Кулаков" У них там есть отдельный пакет для ASP.NET Core, который там перехватывает начало реквеста и конец реквеста, я думаю, что если они сейчас еще и не встроили, то обязательно встроят какую-нибудь хорошую дефолтную политику для
3470.58 3471.58 "Игорь Лабутин" этого.
3471.58 3478.92 "Игорь Лабутин" То есть просто в какой-нибудь middleware вписывать и в нем проверять, что если мы там пришли с эррором, то тогда флэш не.
3478.92 3490.18 "Игорь Лабутин" Ну как-то странно, а с другой стороны эрроры же могут возникнуть уже и после цепочки middleware, пока мы пишем в стрим, например, уже потом, это же делается уже после цепочки middleware, и если там возникнет эррор,
3490.18 3497.02 "Анатолий Кулаков" я бы тоже хотел, но… Основные все-таки скорее всего у нас в пределах реквеста работают, ошибки появляются.
3497.02 3503.90 "Игорь Лабутин" Да, конечно, но бывает все-таки такое, знаешь, что хочется видеть к любому эррору все логи.
3503.90 3513.46 "Игорь Лабутин" Хотя вообще, ну как идея, да, интересная, всегда хотелось такое, что пока все хорошо, не надо собирать логи, а как все плохо, желательно, чтобы они уже точно были записаны.
3513.46 3516.82 "Игорь Лабутин" Ну вот, может быть, может быть, будет когда-нибудь.
3516.82 3528.50 "Анатолий Кулаков" Видишь, мне кажется, тут как раз нет какой-то правильной дефолтной стратегии, ну то есть действительно кажется, что если ошибок не было, ничего не писать, если ошибки были, то все писать, это нормальное поведение по умолчанию.
3528.50 3539.66 "Анатолий Кулаков" Но скорее всего в 100% наших приложений мы все-таки хотим какие-то саксесные пути все-таки иногда записывать, и тогда тебе все равно придется городить вот такую свою мидлварию.
3539.66 3540.66 "Анатолий Кулаков" То есть тебе все равно придется писать.
3540.66 3541.66 "Анатолий Кулаков" Да, все равно придется.
3541.66 3548.02 "Анатолий Кулаков" Может быть, они на это и рассчитывают, что раз тебе все равно придется писать, то напиши там уже флаж во время эрроров сам.
3548.02 3549.02 "Игорь Лабутин" Ну, возможно, возможно.
3549.02 3562.62 "Игорь Лабутин" Все равно придется, потому что все равно нужно разбирать кейсы и успешные, когда к тебе пришли и сказали, а вот мы тут вызывали, а вот у вас тут вернулся 200к, а на самом деле почему, и ты идешь и смотришь, почему, ну в общем.
3562.62 3567.58 "Игорь Лабутин" Даже инфа и успешные запросы все равно иногда приходится разбирать в рамках каких-то кейсов.
3567.58 3579.98 "Игорь Лабутин" Ну, поглядим, поглядим, может быть, какие-то правила евристики выведут, потому что я что-то не встречал таких систем в других экосистемах.
3579.98 3582.14 "Игорь Лабутин" Ты где-нибудь что-нибудь подобное слышал?
3582.14 3586.42 "Анатолий Кулаков" Наверное нет, только самописное все, но я сам писал такую штуку.
3586.42 3590.26 "Анатолий Кулаков" Встроенных из коробки красивых на ум не приходит.
3590.26 3596.50 "Игорь Лабутин" Ну вот мне тоже что-то не приходит, ну поглядим, может разовьется какая-то практика применения, посмотрим.
3596.50 3597.50 "Игорь Лабутин" Давай пойдем дальше.
3597.50 3614.14 "Игорь Лабутин" Мы какое-то время назад, кажется, затрагивали разные попытки Microsoft построить новый, лучший и единственный интерфейс к командной строке, причем, мне кажется, это год назад или около того было, если не два.
3614.14 3650.38 "Игорь Лабутин" Там, напомню, была эпопея, что у нас было некоторое количество всяких разных сторонних пакетов, которые все плюс-минус использовали, потом Microsoft сказал, мы тоже напишем свой, system.com.online, начали писать, родили какого-то адского монстра, там, по-моему, как раз James Newton King, по-моему, привлекали его, он там пришел, чуть ли не всех разогнал, все раскритиковал, они пошли заново все переписывать, в общем, что-то в итоге какое-то выкатили system.com.online, который очень гибкий, но очень неудобный, то есть на нем можно сделать почти все, что угодно, но очень многословно.
3650.38 3662.86 "Игорь Лабутин" И поэтому родился пакетик, который я недавно наткнулся, и я, честно говоря, мне прям понравилось, как он выглядит, я хочу попробовать его поиспользовать, вот, рассказываю вам.
3662.86 3680.74 "Игорь Лабутин" Это штука, которая позволяет упростить настройку вот этого монструозного system.com.online до простейшего Fluent интерфейса, плюс еще и с интеграцией с DI, которого нет в нативном систем.com.online, потому что далеко не в каждом com.online приложении есть этот самый DI, далеко не все его настраивают.
3680.74 3706.50 "Игорь Лабутин" А здесь есть, автор, соответственно, имеет за плечами опыт разработки пакета под названием Console Application Builder, тоже NuGet пакет, который, ну, в каком-то смысле мимикрирует под Web Application Builder, только позволяет это делать для консольных приложений, туда вписать всякий DI и так далее, вот, и, соответственно, он написал еще пакет под названием com.online-extensions, который, собственно, упрощает настройку.
3706.50 3741.42 "Игорь Лабутин" Всего лишь, что нужно сделать, вы имея на руках вот этот самый Console Application Builder, вы говорите builders.services.AddCommand, указываете там withDescription, говорите withOption, передаете туда тип того, чего должно быть у вас в качестве опции, дальше указываете withHandler и передаете сюда лямбдочку, которая, собственно, будет обрабатывать это все, после чего говорите builder.build.invoke, передаете сюда args, это, собственно, переменные, которые пришли в ваш main, и все.
3741.42 3749.62 "Игорь Лабутин" Все остальное будет сделано автоматически, то есть у вас будет вызвана нужная лямбда с нужными аргументами, все, естественно, распарсится, правильно провалидируется и так далее.
3749.62 3755.94 "Игорь Лабутин" При этом, возвращаясь к dependency injection, там есть поддержка его в следующем виде.
3755.94 3766.70 "Игорь Лабутин" Можно в качестве хендлера указать лямбду, которая будет принимать в качестве параметра тот самый value, который вам передали библиотечка распарсила из командной строки.
3766.70 3792.42 "Игорь Лабутин" Либо же можно указать withHandler и указать просто тип обработчика, тогда этот тип должен быть класс, который просто реализует интерфейс ICommandHandler, и в конструкторе этого класса, в аргументе, ну в primary constructor нужно указать, если вы пользуетесь primary constructor, все нужные вам зависимости, он через di их подтянет.
3792.42 3814.22 "Игорь Лабутин" И в статье довольно неплохо приводится то, что на вот этой библиотечке требует, не знаю, примерно десятка строчек кода, на нативном system.com.online это выглядит как 20-30 строчек кода, причем довольно такого запутанного кода, объяви переменную, создай instance, тут ее передай, тут запомни, тут вызови, тут и так далее.
3814.22 3823.30 "Игорь Лабутин" А с di так там еще более приседать надо, потому что di напрямую в system.com.online не поддерживается, там нужно чуть ли не с reflection развлекаться.
3823.30 3851.74 "Игорь Лабутин" Библиотечка пока на ранней стадии, у нее пока в параметры могут быть только максимум 2 параметра на 1 команду, но это такое техническое ограничение, скоро его пофиксит, как обещал автор, и если вы хотите использовать дефолтные значения, то вы не можете использовать factories, это то, что поддержано в system.com.online, а можете использовать просто фиксированные значения, то есть вы не можете передать лямбду в качестве дефолта, и она будет вычисляться каждый раз.
3851.74 3855.34 "Игорь Лабутин" А вы можете просто вычислить значение 1 раз и его именно передавать.
3855.34 3860.34 "Игорь Лабутин" Ну, может кому-то это важно, но кажется, что это не такая большая разница, так что в принципе оно юзабельно.
3860.34 3889.66 "Игорь Лабутин" Библиотечка в общем такая, интересная библиотечка и если вы пользуетесь com.online и думаете над тем, что поделка от Microsoft в целом может быть имеет какой-то смысл, но хотелось бы что-то более удобного, то вот system.com.online вот это вот он, com.online extension, простите, он вполне неплохой, неплохой на вид.
3889.66 3907.86 "Игорь Лабутин" Я хочу попробовать посмотреть, я смотрю, что там в, так скажем, в контрибьюторах довольно известные люди, не только сам автор, но еще там некоторые вполне известные ребята, по крайней мере мне, как человек, который новости собирает периодически.
3907.86 3912.06 "Игорь Лабутин" Нормальная документация, в общем, вполне себе есть.
3912.06 3935.78 "Игорь Лабутин" И парная его библиотечка, соответственно, консоль Application Builder, она прям там и Project Teamplay рядышком и все такое прочее, так что, в общем, вполне себе, не могу сказать, что это прям люто рекомендую, но очень рекомендую присмотреться, кажется, что это неплохой вполне себе интерфейс для com.online, если вы пишете com.online приложение и пару-шести параметров.
3935.78 3936.78 "Анатолий Кулаков" Вот.
3936.78 3952.14 "Анатолий Кулаков" Слушай, надо признать, что, действительно, у микрософта с com.online какое-то проклятие там, он долго не появлялся, были отличные какие-то конкуренты, которые там на рынке сильно его захватили, в частности, от Mono был прекрасный арибе.
3952.14 3958.02 "Анатолий Кулаков" Потом, после того, как они его сделали, я ни разу не видел, чтоб кто-то его использовал, потому что действительно сделали они его сложно.
3958.02 3968.22 "Анатолий Кулаков" То есть это одна из тех библиотек, которая как-то не очень удачно была спроектирована и не очень удачно продвигается, потому что её, по-моему, даже никто внутри микрософта сам не использует для своих проектов.
3968.22 3972.82 "Игорь Лабутин" Ну вот, мне, кстати, даже интересно было посмотреть, а на чём сделан какой-нибудь espire?
3972.82 3990.10 "Игорь Лабутин" У espire же есть же какой-нибудь com.online, правильно, должен быть, да, espire, com.online, интересно, там же они должны использовать хоть что-то-то для себя, парсить, там же миллион всяких параметров у них, правда ведь?
3990.10 4013.38 "Анатолий Кулаков" Ну да, конечно, вообще много у микрософта консольных приложений, которые должны что-то парсить и использовать, например, та же самая утилита .net, она же тоже очень сильно работает с командной строкой, поэтому должны, вот, насколько я знаю, что даже внутренние продукты микрософта, может, если только показательно, может, они и будут его использовать, но такие по собственному желанию не используют
4013.38 4014.38 "Игорь Лабутин" её.
4014.38 4032.74 "Игорь Лабутин" Ну, в общем, да, непонятно, непонятно, ну, не, вот, да, system.com.online используют, я вот сейчас смотрю исходники, они прям аккуратненько, ну, тут такое, прям, да, наворочено-наворочено.
4032.74 4041.10 "Анатолий Кулаков" Может, действительно их заставили, знаешь, не, так как мы делаем показательный проект, значит, надо использовать как положено, всё по-другому.
4041.10 4054.18 "Игорь Лабутин" Функция в t начинается, ну, handle, короче, одной из команд, начинается на 53 строчке, заканчивается на 335 строчке, 280 строк, одна функция, нормально.
4054.18 4057.02 "Анатолий Кулаков" Ну, да, видно, что, ребята, было непросто.
4057.02 4062.74 "Игорь Лабутин" Вот, это только одна из команд, из десятка, вот, интересно-интересно.
4062.74 4083.30 "Игорь Лабутин" Мне даже интересно, как они это всё, ну, короче, тут прям наворочено сделано, наворочено, ладно, не буду сейчас пытаться это самое, периодически встречается это самое, комментарий типа this parsing logic is hopefully temporary, заметочки в коде.
4083.30 4088.54 "Анатолий Кулаков" Да-да-да, что может быть более постоянным, чем временной логики.
4088.54 4111.26 "Игорь Лабутин" In the future we will have proper fix, нормально, нормально, всё хорошо с испаром, всё прекрасно, ладно, на этом новость всё, то есть, в общем, command-line, если у вас есть уже любимая библиотека, пользуйтесь, если нет, вдруг посмотрите на command-line extensions, небольшая, автор пока там не собрал какого-то огромного количества звёзд, но, в принципе, почему нет?
4111.26 4112.26 "Игорь Лабутин" Почему нет?
4112.26 4114.58 "Игорь Лабутин" Есть у нас что-нибудь ещё поделиться?
4114.58 4129.54 "Анатолий Кулаков" Да, слушай, наткнулся тут на анонсик, который как бы с первого взгляда не имеет никакого отношения к C#, называется он SourceCraft и Code Assistant от Яндекса, запустились.
4129.54 4145.90 "Анатолий Кулаков" Прежде всего меня привлёк автор, некий Дмитрий Иванов, автор данной статьи, который является сейчас руководителем платформы SourceCraft, вот я решил, что Дмитрий Иванов такого хорошего мог сделать для .NET и C# по старой памяти, пошёл рыть.
4145.90 4147.46 "Анатолий Кулаков" Давайте разберёмся по порядку.
4147.46 4178.26 "Анатолий Кулаков" Итак, SourceCraft – это конкурент GitHub, который разрабатывается компанией Яндекс, то есть это такая целая платформа, и вот новость застоит в том, что она вышла в свободный доступ, до этого она была в приватных бета-тестированиях, в корпоративных интерпрейс подписках и прочих всяких ограничениях, сейчас она доступна для всех разработчиков, поэтому кто угодно, кто хочет слезть с GitHub или попробовать какие-то альтернативы, бешено приглашаются, попробуйте, посмотрите.
4178.26 4202.90 "Анатолий Кулаков" Платформа довольно зрелая, несмотря на то, что только запустилась, она включает в себя богатые инструментарии по безопасности, зеркалирование репозиторий с GitHub, интеграция с другими приложениями через публичный API, навигация по коду для некоторых языков, но C#, к сожалению, среди этих языков нет, богатая автоматизация CI/CD процессов, в том числе публикация мобильных приложений во все возможные магазины, которые только существуют.
4202.90 4219.92 "Анатолий Кулаков" В этой версии отмечается обновление инструментов безопасности, появился сканер секретов в коде, анализ уязвимостей в кодовой базе и отдельная сводная таблица со статистикой по рискам информационной безопасности.
4219.92 4227.50 "Анатолий Кулаков" Тоже как бы для первого релиза, в принципе, довольно хорошее нововведение, которые у обычного GitHub появились на какой-то десяток лет, по-моему, в его существовании.
4227.50 4231.70 "Анатолий Кулаков" Здесь ребята сразу со старта запускаются уже довольно так мощно.
4231.70 4262.98 "Анатолий Кулаков" Интересно, есть миграция проектов с GitHub, в общем, обычно у нормального разработчика на GitHub уже полно проектов, и если вдруг им все понравится, они захотят с GitHub мигрировать на платформу от Яндекса, и красиво здесь то, что переносится абсолютно все, бесшовно переносятся все issues, PR, лейблы, milestone, комментарии, просто все, что там можно только связать или вытащить, точнее сказать, через публичный API.
4262.98 4280.74 "Анатолий Кулаков" В общем, можно выбрать ветки для зеркалирования, то есть непрерывной синхронизации кода, допустим, в GitHub у вас появились новые коммиты в этой ветке, и автоматически здесь все в SourceCraft подтянулось, и можете дальше продолжать работать, что тоже интересно.
4280.74 4302.38 "Анатолий Кулаков" Но на самом деле, как бы платформы входят и выходят, и здесь нет какой-то большой новости, а больше всего меня зацепило, это же, конечно, SourceCraft Code Assistant, это и помощник для разработчиков от Яндекса, наконец-то какой-то помощник, который можно всем попробовать без каких-либо ограничений.
4302.38 4311.94 "Анатолий Кулаков" Он помогает писать код уже сейчас десяткам тысяч разработчиков, то есть больше 50% разработчиков Яндекса по заверению его используют.
4311.94 4317.38 "Анатолий Кулаков" Кажется, что достаточно отлаженная и работоспособная штука.
4317.38 4343.34 "Анатолий Кулаков" На данный момент сервис находится в стадии превью, именно вот этот, Code Assistant который, и для того чтобы пощупать его функциональность, вам нужно будет установить один из двух плагинов, у них есть плагин для WS-кода и плагин для IDE от JetBrains, притом в WS-коде гораздо больше настроек, ну например можно с помощью IE генерить сообщение к коммитам, пока у IDE от JetBrains такой штуки не поддерживается.
4343.34 4425.74 "Анатолий Кулаков" Официально поддерживаются C++, Java, Python и еще несколько вот таких языков первого уровня, но тут Code Assistant нужно рассказать, что он делится как бы, у него языки делятся на два уровня, типа нативно, хорошо поддержанный, отлаженный и специально обученный и все остальное, в общем вообще он знает более 30 языков программирования, и C# он поддерживает в том числе, несмотря на то, что на главном сайте C# никак не упоминается, он входит в раздел все остальное, вот из инструментов, стандартный чат клиент у вас появляется, быстрые подсказки на основе контекста, то есть и понимает в каком контексте он находится и как только вы начинаете печатать, он вам подсказывает а что в этот момент вы хотели бы допечатать, что бы нажать, вся работа не тормозится у вас на локальном компьютере, потому что выполняется на удаленных серверах, это можно считать как за плюс, так и за минус, как бы если у вас слабенькая машинка, то удаленные сервера для обработки больших искусственных интеллектов вам конечно же помогут, если вы боитесь за свои данные, то наверное это не ваш вариант, но с другой стороны здесь есть хорошая интерпрайс подписка, многие компании уже используют Яндекс и многие продали свой код анализатором Яндекса и вот наверное с интерпрайс подписками проблем быть не должно.
4425.74 4434.74 "Анатолий Кулаков" Пока все это чудо бесплатно, не знаю, пока превью будет бесплатно или дальше будет бесплатно, посмотрим, пока подробная информация не сообщается о монетизации.
4434.74 4453.14 "Анатолий Кулаков" Я попробовал поставить плагин к райдеру, так как это EDH brains, то он туда стал без всяких проблем, тут нужно отметить, что если у вас вдруг настроены какие-то http-прокси, то с ними плагин работать не будет, вам необходимо отключить http-прокси и тогда он только подключится, поставится, зарегистрируется и все что нужно сделает.
4453.14 4507.78 "Анатолий Кулаков" Из личного опыта работы, к сожалению, он не может изменять файлы, то есть у вас есть, например, в качестве работы красивый чатик, я имею ввиду чатик не может изменять, поговорим о подсказках чуть дальше, в общем если брать чатик и в чатик забивать какие-нибудь стандартные там фразы, сгенери мне приложение, которое красивое и все такое, и он прекрасно вам все распишет, все по действиям, что надо сделать, прям шаги обозначит, куда положить, как назвать, что должно внутри содержаться, но к сожалению, сам этот сволочь не делает, то есть мне хотелось бы наоборот вообще, в идеальном мире, я бы хотел ему говорить, что делать, а он бы за меня создавал файлы, провязывал какие-то регистрации и связывал какие-то линки, но здесь получается, что наоборот, он командует мне, что мне надо делать, и мне приходится из чатика копировать все это, создавать файлики и вставлять их туда.
4507.78 4516.66 "Анатолий Кулаков" Ну, надеюсь, рано или поздно мы, плагин, который интегрируется с EDE, все-таки сможет EDE использовать на полную катушку и хотя бы файлы научится создавать.
4516.66 4533.46 "Анатолий Кулаков" Я попробовал на стандартных там каких-то C# маленьких демках, в принципе, нормально генерирует код C#, нормально пишет документацию, пишет тесты с использованием XUnit и Mocku, в общем, как положено, то есть фреймворк он понимает достаточно хорошо.
4533.46 4549.30 "Анатолий Кулаков" Когда генерирует код, он, к сожалению, не соблюдает стиле всего остального проекта, допустим, не подтягивает до EditorConfig, не смотрит, в каком стиле названы методы, не смотрит, в каком стиле классы, переменки называются и так далее.
4549.30 4557.54 "Анатолий Кулаков" Вот в этом тоже какой-то отдельный минус, то есть он сидит и генерирует себе все, что ему на уме, не подтягивает этот контекст, в котором он сейчас находится.
4557.54 4568.98 "Анатолий Кулаков" Хотелось бы, конечно, дать ему доступ к Solution, чтобы он оттуда все прочитал, все проанализировал и уже с этим полным контекстом уже как-то начинал работать.
4568.98 4581.62 "Анатолий Кулаков" Из плюсов он умеет подтягивать открытые вкладки, то есть если у вас какие-то вкладки уже открыты, то вам не нужно явно говорить файлы, которые у вас там открыты или код, который там открыт.
4581.62 4589.30 "Анатолий Кулаков" Вот те открытые вкладки, которые есть, он прекрасно из них все считывает и может этот код как-то описывать или использовать его для генерации кода.
4589.30 4599.82 "Анатолий Кулаков" Насчет генерации кода, этот ассистент умеет генерировать код по комментарию, допустим, вы в комментарии пишите «хочу такой-то метод» и он вам может этот метод сгенерировать.
4599.82 4606.46 "Анатолий Кулаков" Может подсказывать как отдельные блоки кода, так и отдельные методы, которые вы хотите вызвать.
4606.46 4622.62 "Анатолий Кулаков" Довольно интересны это непосредственно подсказки во время написания кода, то есть вы пишете какой-то код и он догадывается по предыдущему написанному коду, какой далее или строку, или какой-то далее блок вы хотите написать.
4622.62 4632.62 "Анатолий Кулаков" В общем, это, например, очень сильно помогает, когда вы хотите какие-то переменные или аргументы, которые уже есть в контексте вашего метода, передать другому методу.
4632.62 4643.86 "Анатолий Кулаков" Довольно часто операция, когда вы подготавливаете какие-то аргументы и берете половину оттуда, половину отсюда, половину от конструктора, половину от инжекшена, и вам нужно заполнить какой-то большой длинный метод.
4643.86 4653.26 "Анатолий Кулаков" Эта штука быстренько, мгновенно соображает, какие параметры вы хотите подставить и вызывает метод просто за одну секунду.
4653.26 4656.62 "Анатолий Кулаков" Подставляю все параметры правильные и беря их из правильных адресов.
4656.62 4669.70 "Анатолий Кулаков" Как один из примеров того, как вы в момент написания кода можете просто использовать те вещи, которые вокруг вас, даже не обращаясь непосредственно в чатик каким-то искусственным интеллектом или высшим силам.
4669.70 4684.34 "Анатолий Кулаков" В общем, инструмент интересный, инструмент хороший, будем надеяться, что все-таки поддержка C# когда-то появится нативно, что появилась навигация по коду, что появилась какая-то поддержка синтаксиса в окружающем проекте и прочее.
4684.34 4692.66 "Анатолий Кулаков" В общем, будем следить за развитием отечественных и технологий, посмотрим, как Яндекс покажет себя дальше в этом плане.
4692.66 4700.50 "Игорь Лабутин" Да, интересно, последим, конечно же, посравниваем может быть даже с остальными, так или иначе.
4700.50 4706.38 "Игорь Лабутин" Хотя, конечно, рабочие проекты запихивать во всякие нейросетки, да, надо подумать несколько раз позже, чем такое делать.
4706.38 4709.82 "Игорь Лабутин" Но на личных ПЭД-проектах вполне, почему нет.
4709.82 4720.14 "Анатолий Кулаков" Ну вот смотри, как раз таки уговорить начальство взять интерпрайс-поддержку Яндекса и как бы уговорить начальство взять какую-нибудь интерпрайс-поддержку чат-GPT, в общем, две огромные
4720.14 4721.14 "Игорь Лабутин" разницы.
4721.14 4722.14 "Анатолий Кулаков" Это я согласен, да.
4722.14 4724.92 "Анатолий Кулаков" Потому что Яндексу, Сберу мы все-таки как-то больше доверяем.
4724.92 4731.20 "Игорь Лабутин" Ну, тоже зависит от бизнес-области и того, что, так сказать, вы разрабатываете.
4731.20 4732.64 "Игорь Лабутин" Ну, конечно, конечно.
4732.64 4733.64 "Игорь Лабутин" Поглядим.
4733.64 4739.36 "Игорь Лабутин" Ладно, на этом на сегодня у нас все, никаких кратких новостей для вас сегодня нет, одни длинные.
4739.36 4767.26 "Игорь Лабутин" Мы за сегодня посмотрели на дотант 10 превью 5, узнали про логи, как их фильтровать и буферизировать, посмотрели на то, как Андрю Локус конвертировал Docker Compose приложение к Westpire и обратно, посмотрели на расширение Command Line Extensions вокруг системы Command Line и порассуждали немножко о Яндекс.Сourcecraft, Code Assistant и о том, как это все может нам потенциально помочь в разработке.
4767.26 4769.36 "Игорь Лабутин" На этом на сегодня у нас все.
4769.36 4774.92 "Анатолий Кулаков" Да, всем до новых встреч, не забывайте нас слушать, шарить, рассказывать друзьям и оставлять комментарии.
4774.92 4775.92 "Анатолий Кулаков" Всем пока.
4775.92 4776.56 "Игорь Лабутин" Всем пока.
