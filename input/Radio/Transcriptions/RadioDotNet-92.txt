0.00 11.68 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Radio.net и выпуск номер 92.
11.68 16.32 "Анатолий Кулаков" В студии его постоянный ведущий Анатолий Кулаков.
16.32 18.84 "Анатолий Кулаков" И Игорь Лабутин, всем привет.
18.84 38.88 "Анатолий Кулаков" Также за нами стоит боровая компания наших помогаторов, а именно Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков и Андрей Фазлеев.
38.88 41.58 "Анатолий Кулаков" Друзья, всем огромное спасибо, что нас поддерживаете.
41.58 50.32 "Анатолий Кулаков" Если вы захотите присоединиться к этому бравому списку и поддержать свой любимый подкаст, то заходите на Boosty и посмотрите, что интересного мы можем вам предложить.
50.32 54.76 "Анатолий Кулаков" Так, что у нас из официальных новостей от Microsoft, что-нибудь есть?
54.76 55.76 ÷ Есть.
55.76 59.56 "Игорь Лабутин" Вы решили, вы будете смеяться, но, конечно же, это expired.
59.56 60.56 "Игорь Лабутин" Опять?
60.56 84.08 "Игорь Лабутин" Опять expired, dotnet preview пока готовят, там уже есть какие-то проблески того, что, может быть, там будет что-то интересное, по крайней мере, в твиттере, то Фаулер, то какой-нибудь Джеймс Ньютон Кинг что-нибудь дозапостит, типа, а вот в следующем превью мы там пытаемся сделать вот такую штуку, но пока не сделали, пока, по крайней мере, превью
84.08 85.08 "Анатолий Кулаков" не вышло.
85.08 93.52 "Анатолий Кулаков" Не хватает в других направлениях вот такого же шоумена типа как Ньютон Кинга или Хантельман или кто-то такого, который будет фичи раздавать направо и налево.
93.52 103.96 "Игорь Лабутин" Не, ну они есть, то есть там есть тот же Тауп, который про ронтайм иногда говорит, вот про EF Core иногда, как его Шай Раянский говорит, но действительно их мало.
103.96 111.68 "Анатолий Кулаков" Ну да, они редко попадаются как-то, в отличие от Кинга, он там сверкает везде, и в твиттере, и в анонсах, и абсолютно везде.
111.68 117.44 "Игорь Лабутин" Ну и Фаулер, вот эти двое заправляют за этот самый привью, за ASP в основном, и все, что с ним связано.
117.44 122.00 "Анатолий Кулаков" Да, а Фаулера, скорее всего, за ASP выгнали, наверное, да, что у нас как бы про ASP ничего нет, про один Aspire
122.00 123.00 "Игорь Лабутин" только.
123.00 126.68 "Игорь Лабутин" Ну может быть, может быть, да, он сейчас пока занят Aspire, это правда, по крайней мере на вид.
126.68 130.60 "Игорь Лабутин" Больше пока он ничего, ну такого он ничего не твиттит особо.
130.60 137.52 "Игорь Лабутин" Ну ладно, давайте про Aspire ближе к делу, вышел превью 6, в нем не обошлось, конечно же, без breaking changes.
137.52 151.32 "Игорь Лабутин" Во-первых, сменили некоторое количество API вокруг сервиса Discovery, я не буду углубляться в детали, в статье есть ссылка на GitHub.ish, где подробно все описано, что там поменяли, там довольно много мелких, но тем не менее, изменений.
151.32 158.84 "Игорь Лабутин" А второе, важное, и breaking change изменения, все API, которые были помечены как obsolete в прошлых превьюшках, просто удалили.
158.84 159.84 "Игорь Лабутин" Ну вот.
159.84 166.48 "Игорь Лабутин" Поэтому если вы вдруг пользовались чем-то, что было обсолетом, в этом превью этого API больше совсем не будет, и надо переходить на новый.
166.48 178.02 "Игорь Лабутин" К счастью, там плюс-минус прямолинейный переход, без каких-то особых, сложных и совсем несовместимых API, поэтому все должно пройти легко.
178.02 179.02 "Игорь Лабутин" Дальше.
179.02 190.68 "Игорь Лабутин" Из основных и, наверное, самых важных изменений это security improvements, то есть у нас улучшилась безопасность, и самое главное, что там появилось, это аутентификация в дэшборде.
190.68 198.72 "Игорь Лабутин" То есть, когда вы запускаете дэшборд, теперь нужно ввести логин-пароль, даже если вы работаете на вашей локальной девелоперской машинке.
198.72 213.64 "Игорь Лабутин" При этом, если вы запускаете этот дэшборд, потому что вы запустили Aspire-приложение из Visual Studio, либо из Visual Studio Code с C# девкитом расширением, то тогда логин-пейдж вы не увидите, оно все, магия произойдет сама.
213.64 228.92 "Игорь Лабутин" Но вот если вы запускаете из консольки, через там .NET RUN, то при открытии дэшборда вам нужно будет все-таки залогиниться, а чтобы залогиниться, вам нужно знать некоторый секретный токен, который печатается в эту самую консольку, когда вы делаете .NET RUN.
228.92 251.80 "Игорь Лабутин" То есть, вы делаете .NET RUN, подсматриваете там токен, идете в дэшборд, этот токен туда вставляете, все, вы молодцы, вы залогинены, и при этом у вас будет сохранена кука, которая позволит вам этот логин будет более-менее долго сохраняться, там есть конечно какое-то время протухания этой куки, но она довольно большая.
251.80 263.36 "Игорь Лабутин" Было некоторое количество вопросов в Твиттере в том числе, и в GitHub еще, по-моему, тоже, на предмет, а вообще нафига дэшборда аутентификация в случае, если мы все это делаем на нашей локальной машинке.
263.36 305.56 "Игорь Лабутин" И ответ тут простой, в дэшборде видны логи, видны какие-то там метрики, ну метрики вряд ли, что-то секьюрное там есть, а вот в логах может попадаться какая-нибудь приватная информация, все дела, а поскольку дэшборд слушает на просто TCP порту, то если вы, например, работаете с какой-нибудь, не знаю, там в вашей организации вы работаете с каким-нибудь кодом или с данными, к которым вы имеете доступ, и делаете на каком-нибудь, не знаю, там, Remote Desktop Server, то кто угодно другой, зайдя на этот же Remote Desktop Server, может подключиться к этому порту и посмотреть, если без аутентификации какие-то секретные или, по крайней мере, данные, к которым он, возможно, не должен иметь доступ.
305.56 318.80 "Игорь Лабутин" Поэтому даже локальная аутентификация важна, считает Microsoft, и они это дело запилили, но действительно, справедливости ради, запилили довольно неплохо, так что, в общем-то, если вы пользуетесь студией или ВС-кодом, вы вообще этого не заметите.
318.80 333.04 "Игорь Лабутин" Так, дальше, в хосте, то есть, собственно, в той части Aspire, которая ответственна за оркестрацию всего этого дела, тоже произошло некоторое количество апдейтов.
333.04 346.96 "Игорь Лабутин" Во-первых, обновили, добавили, точнее, новые API для того, чтобы вы могли при запуске контейнеров в докере или подвоне передавать вообще какие-нибудь кастомные аргументы для рантайма, ну, в смысле, для того, чтобы запустить контейнер.
346.96 361.08 "Игорь Лабутин" Прям любые аргументы можно передать, там нет никакой валидации, там нету никаких проверок, вот, как бы, угадали, ну, в смысле, знаете правильные аргументы, передавайте, не знаете, ну, передавайте какие угодно, если что, пойдет в рантайме.
361.08 385.96 "Игорь Лабутин" И дальше можно еще передавать аргументы теперь проектам при запуске, то есть можно сказать, что вот этот проект запускай всегда с такими-то аргументами, это можно было делать раньше, но это нужно было делать через так называемые launch profiles, теперь это можно делать прямо в API, там написать, по-моему, with the command arguments или with arguments, просто не помню точно, и передать любые аргументы, которые будут переданы, соответственно, в запускаемое приложение.
385.96 414.64 "Игорь Лабутин" Дальше, для connection string'ов теперь можно задавать кастомные переменные окружения, раньше там был некоторый шаблон, по которому всегда эти переменные окружения собирались, а если у вас уже есть эти переменные окружения в вашем каком-то нужном формате или заданной извне, то можно этим теперь имя переменной окружения прямо явно указать, и тогда SPAR будет использовать именно его для хранения и для передачи connection string'а в нужные компоненты.
414.64 454.92 "Игорь Лабутин" И последнее, что добавилось в оркестрации и в запуске, это то, что можно теперь указывать то, что называется fully qualified container images, то есть вам нужно не только указывать, ну можно раньше было указывать, я хочу, не знаю, Postgres, условно говоря, или какой-нибудь, не знаю, Redis, нужной версии, и все, а теперь можно прямо вместе с package registry именем, то есть там hub docker.io/что-нибудь, понятно, что для докер-хаба это делать, в общем-то, не нужно, но если у вас есть какие-то свои собственные хабы или registry для имиджей, то это как раз то, что нужно, можно использовать.
454.92 485.88 "Игорь Лабутин" Для тестирования добавили штуку, я сначала не понял зачем, но вроде как есть для этого применение, в обычных ISPnet приложениях у нас есть штука под названием Web Application Factory, она позволяет написать unit test, который по сути вам в unit test поднимет целиком ваше ISPnet приложение, и вы из теста, а и предоставит вам некоторый такой http клиент, который, обращаясь к которому, вы будете фактически производить вызовы к вашему поднятому тестируемому приложению.
485.88 509.16 "Игорь Лабутин" Так вот теперь в Aspire есть класс, который называется Distributed Application Testing Builder, который позволяет создать тест-хост, который фактически поднимает ваше целиком распределенное приложение и выдает вам некоторого клиента, с помощью которого вы можете делать запросы, а этот клиент будет знать, в какую часть вашего поднятого Distributed, вашего распределенного приложения на основе Aspire роутить запросы.
509.16 513.68 "Игорь Лабутин" То есть он и все зависимые докер-контейнеры поднимет и все, что там указано.
513.68 515.04 "Игорь Лабутин" Насколько я понимаю, да.
515.04 524.52 "Игорь Лабутин" То есть это некоторая, видимо, смесь тест-контейнеров не знаю с чем, но позволяет, по крайней мере, написать видимо такие плюс-минус интеграционные тесты прямо на все ваше приложение целиком.
524.52 530.72 "Анатолий Кулаков" Ну да, если это заработает, это будет реально замена тест-контейнеров, которые как бы рулят и бибикают.
530.72 533.36 "Анатолий Кулаков" А тут как бы какой-то обычный эффект от дэшборда.
533.36 536.92 "Игорь Лабутин" Надо посмотреть, можно ли там мокать, например, какие-нибудь зависимости.
536.92 541.40 "Игорь Лабутин" Смотреть там, типа вот тут рейтинг не поднимай, а просто всегда отвечай, что там, не знаю, записей нет.
541.40 542.40 "Игорь Лабутин" Вот это надо посмотреть.
542.40 543.40 "Игорь Лабутин" Я не знаю, не изучал.
543.40 553.12 "Игорь Лабутин" Но если вы задумывались о том, чтобы пописать такие интегрейшн-стайл тесты для вашего приложения, то посмотрите, может быть, будет интересно.
553.12 564.76 "Анатолий Кулаков" Я думаю, стоит даже порыть как бы в область того, чтобы просто использовать Aspire для того, как замена тест-контейнеров, да, то есть чтобы просто поднимать твои зависимости в зависимости от того, где они там нужны.
564.76 568.12 "Анатолий Кулаков" Какие-то части из проектов, какие-то из экзешников, какие-то из контейнеров.
568.12 571.52 "Анатолий Кулаков" Так, мало кто умеет, я бы даже сказал, никто не умеет.
571.52 573.68 "Игорь Лабутин" Даже без дэшборда это было бы прекрасно.
573.68 584.24 "Игорь Лабутин" Для этого всё-таки нужно тебе уметь описывать всё твоё приложение полностью в Aspire-варианте, даже если ты не используешь это потом для дипломента или там для локальной разработки, например.
584.24 588.20 "Анатолий Кулаков" Окей, в принципе там описание не настолько сложное, чтобы это было какой-то проблемой.
588.20 589.20 "Анатолий Кулаков" Это правда.
589.20 595.84 "Игорь Лабутин" В общем, посмотрим, подождём, наверняка будут какие-нибудь статьи на тему, как это сделать.
595.84 598.16 "Игорь Лабутин" Попадётся статейка, посмотрим.
598.16 601.36 "Игорь Лабутин" Не уверен, что у меня доберутся руки самому посмотреть, но глядим.
601.36 602.36 "Игорь Лабутин" Дальше.
602.36 603.36 "Игорь Лабутин" В шаблонах.
603.36 612.16 "Игорь Лабутин" В шаблонах некоторое время использовались, так скажем, как они называют, пререлизные версии всяких разных Open Telemetry компонентов.
612.16 619.72 "Игорь Лабутин" Теперь все кусочки шаблонов, все зависимости обновлены на Open Telemetry SDK версии 1.8.1 стабильной.
619.72 631.12 "Игорь Лабутин" И, кроме того, добавили некоторые API, которые позволяют достаточно легко в 3-4 строчки конфигурить стандартный Open Telemetry экспортер, и у вас просто всё будет работать.
631.12 635.00 "Игорь Лабутин" Там, в общем, в статье есть короткий примерчик, как это сделать.
635.00 636.00 "Игорь Лабутин" Так, что у нас ещё.
636.00 641.96 "Игорь Лабутин" По компонентам особо новостей нету, добавили некоторый компонент под названием Quadrant Vector Database.
641.96 647.56 "Игорь Лабутин" Не знаю, что такое, впервые вижу название, но я как-то не пользовался векторами базовыми данных, ничего не скажу.
647.56 648.56 "Игорь Лабутин" А квадрантами?
648.56 649.56 "Игорь Лабутин" Квадрантами...
649.56 655.04 "Игорь Лабутин" Это что-то из далёкого, не помню, из географии или ещё откуда-то.
655.04 658.04 "Игорь Лабутин" Квадранты, квадранты, какой-то, или математический термин.
658.04 661.96 "Игорь Лабутин" А, это квадранты координатной плоскости же, по-моему, были.
661.96 666.60 "Игорь Лабутин" Что-то такое, я помню, из какой-то древних математических времён.
666.60 668.60 "Игорь Лабутин" Короче, нет, не пользовался, для программирования не пользовался.
668.60 677.48 "Игорь Лабутин" И второе, для ажурных пэкэджей они там ещё что-то распилили-поделили, на разные пэкэдж пер сервис, как они теперь называют.
677.48 691.56 "Игорь Лабутин" Поэтому, в общем, если вы пользуетесь ажуром, и с помощью эспайра создаёте ресурсы в ажуре, скорее всего, вам нужно будет начать зависеть от некоторого большего количества пакетов, но ровно от тех, которые вам нужны.
691.56 701.52 "Игорь Лабутин" Так, это, в принципе, всё для эспайр превью-6, тут же связанная новость попалась, которую тоже расскажу здесь.
701.52 720.96 "Игорь Лабутин" Если вы помните, мы уже много раз упоминали, есть такой проект Aspire 8, пишется как Аспир 8, это экстенджен по сути для эспайра, который позволяет из вот этого манифеста, который умеет генерить эспайр, сгенерить куберовский ям-альфайлик, который позволяет напрямую это всё дело в кубер прямо, реплайть.
720.96 732.36 "Игорь Лабутин" Так вот, эту штуку допилили, там, по-моему, релиз 0.6, что ли, как-то так, ну, короче, тоже там 0-что-то там, она, в общем, теперь умеет помимо куберовского ям-альфайлика генерить прям хелм-чарты.
732.36 745.64 "Игорь Лабутин" Ну, мне кажется, хелм-чарты, я не знаю, насколько это прям мейнстрим в кубере, у нас, по-моему, во всех проектах через хелм всё это делается, поэтому вот теперь эту штуку умеет ещё и хелм-чарты генерить по вашему эспайр-проекту.
745.64 750.60 "Анатолий Кулаков" Ну да, да, это сейчас, как бы, самый общепринятый, общепопулярный способ диплайв-кубер.
750.60 751.60 "Игорь Лабутин" Ну вот.
751.60 752.60 "Игорь Лабутин" У всех.
752.60 764.96 "Игорь Лабутин" Теперь из эспайра с помощью Аспир 8 можно сгенерить хелм-чарты и в вашем там CI какой-нибудь, CD точнее, все это здесь не про то, соответственно, диплойт – это всё прям на лету.
764.96 783.00 "Анатолий Кулаков" Ну вот, это уже приближается к каким-то продакшн-требованиям, вот у нас как бы есть описание целого кластера наших сервисов, вот теперь мы их можем в хелм определять, диплойт, обновлять, роллинг апдейтить, уже какой-то прям вид продакшн радиосистемы получает.
783.80 801.28 "Игорь Лабутин" Ну да, да, мне всё вот интересно узнать, это как бы они к релизу, грубо говоря, просто заполируют эспайр вот в том виде, как он есть или там к очередному релизу в ноябре выкатят какую-нибудь супер-пупер вау-штуку, в каком-нибудь превью 12 или сколько их там ещё будет.
801.28 816.56 "Анатолий Кулаков" Ну мне кажется, на той хайп-полне, на которой они сейчас катятся, они вполне могли бы доехать до релиза, но оставлять это просто так нельзя, нужна ещё какая-нибудь твоя вау-штука в конце, чтобы просто вот добить, чтобы первый релиз вышел такой, чтобы все о нём кричали направо и налево.
816.56 819.28 "Игорь Лабутин" Ну да, интересно, интересно, посмотрим.
819.28 854.40 "Анатолий Кулаков" А вообще интересно посмотреть, как вообще проекты развиваются в большой компании, да, то есть вспомни, когда первый релиз эспайра появился, там и дэшборд встроенный, и ажур гвоздями прибит, ну в нормальной же проекте так не делает, ну сразу же очевидно было, что ажур надо отлеплять, как бы дэшборд должен быть отдельно, и такие очевидные вещи все, но они были слеплены вот этот единый пок, комок, да, то есть мне кажется это наоборот как раз таки не какая-то ошибка была разработчиков, а наоборот, это был пок, который был сделан быстро, напрямую, грубо, для того, чтобы показать, продемонстрировать идею.
854.40 870.36 "Анатолий Кулаков" А уже после этого можно разделять, разбивать, перфоманс улучшать, аутентификацию прилеплять и прочие такие вещи, о которых иногда разработчики думают на первом этапе, не заботясь о том, чтобы продукт поставить там, даже не продукт, а вот показательную демку какую-то предоставить быстро и функционально.
870.36 899.00 "Игорь Лабутин" Ну все по заветам стартапов, сначала покажи, что он работает, а потом уже это, если будут пользователи, и у тебя будет, условно говоря, мотивация, деньги, ну в данном случае с деньгами нет проблем, вероятно, на них вряд ли зависит от каких-то инвестиций, но если у тебя будут пользователи, у тебя начнут появляться какие-то фич реквесты, ты вообще поймешь, что пользователи из этого всего используют, того, что ты быстренько на коленке сделал, и поймешь, какие места нужно оптимизировать, вот они это собственно и сделали, нормально сделали, молодцы.
899.00 901.36 "Анатолий Кулаков" И продемонстрировали как бы да всему миру, как надо.
901.36 905.56 "Игорь Лабутин" Да, и не боятся, кстати, делать дофигища брейкчейнджей в привычках.
905.56 914.88 "Анатолий Кулаков" Ну и отдельно прекрасно, что такая монструозная огромная компания, она все-таки вот этот дух стартапчика, хотя бы в отдельном взятом проекте, не боится поддерживать.
914.88 923.36 "Игорь Лабутин" Да, прикольно, прикольно, ну давай пойдем дальше, по-моему, на этом все у нас с новостями Майкрософта за прошедшие две недели.
923.36 935.48 "Анатолий Кулаков" Да, больше не выдает, как ни крути, но зато выдает другие люди, и в частности, у нас во внутреннем чатике поднялась интересная тема про Search Values, кстати, у нас есть внутренний чатик, как туда попасть?
935.48 936.48 "Анатолий Кулаков" Через бусти, конечно.
936.48 954.72 "Анатолий Кулаков" Про Search Values и по диалогам там мы поняли, что эта тема как бы зря обошла нас стороной, потому что никаких больших анонсов по ней не было, и нигде мы их почему-то, именно поэтому, да, мы нигде о ней почему-то не рассказывали, но штучка прекрасная.
954.72 956.68 "Анатолий Кулаков" Поэтому давайте рассмотрим ее поподробнее.
956.68 976.20 "Анатолий Кулаков" Итак, System Buffers Search Values – это специальный тип, который был добавлен еще в далекий .NET 8, в рантайм, и это тип, который используется, с одной стороны, не так уж и часто, а с другой стороны, если вам нужно работать с постоянным поиском, то вы должны о нем знать.
976.20 986.00 "Анатолий Кулаков" Изначально этот тип появился благодаря простому подходу в оптимизации, да, то есть очень часто существуют оптимизации, когда вы можете разделить вашу стратегию, ваш алгоритм на две части.
986.00 999.52 "Анатолий Кулаков" Первая часть – это подготовить какие-то данные для того, чтобы запустить вторую часть, выполняющую непосредственные действия с данными, а подготовленные данные ей уже как-то помогали, то есть сама операция была бы быстрее.
999.52 1032.24 "Анатолий Кулаков" Ну, типичный представитель – это когда мы запускаем наше .NET приложение, и оно при первом старте компилится, да, его JIT компилирует для того, чтобы потратить какое-то временное компиляцию, поэтому старт у этого приложения может быть долгим, но зато потом выполнение самого приложения будет очень-очень быстрым, потому что в памяти уже нет никаких лькодов, в памяти уже идут прямо машинные коды, которые оптимизированы под конкретную архитектуру, и поэтому мы можем себе позволить, мы даже хотим этого, чтобы наше приложение стартовало помедленнее, но зато потом работало быстрее.
1032.24 1036.16 "Анатолий Кулаков" Вот типичная оптимизация, вот когда такая стратегия срабатывает.
1036.16 1043.82 "Анатолий Кулаков" И, в принципе, такую стратегию можно делать на разных вещах, то есть вот эту подготовочку, ее можно делать на разных этапах.
1043.82 1077.70 "Анатолий Кулаков" Ну, вы ее, например, можете сделать в рантайме, как делает JIT, например, или вы можете ее сделать в компайл-тайме, как, например, есть вариант систем-текст-джессона приготовить, да, у нас есть систем-текст-джессон-сериалайзер, этот сериалайзер может взять тип и засериализировать вам его в рантайме и также считать его тоже в рантайме, но есть другой способ вызвать систем-текст-джессон-генератор, и генератор, опираясь на те типы, которые есть у вас в компайл-тайм, уже сгенерирует строго типизированные ридеры и врайтеры, которые будут работать намного быстрее, намного интереснее и так далее.
1077.70 1089.98 "Анатолий Кулаков" Это вот тоже тот пример, когда мы готовы в компайл-тайме потратить больше времени, зная о том, что в будущем, когда мы запустим наше приложение, сериализатор будет работать намного, намного быстрее.
1089.98 1094.14 "Анатолий Кулаков" Кроме того, генератор в компайл-тайме дает другие плюсы.
1094.14 1102.96 "Анатолий Кулаков" Ну, во-первых, у нас больше нет прогрева на рантайме, то есть мы в рантайме не бегаем рефлекшеном по нашим типам, это все намного быстрее получается.
1102.96 1130.64 "Анатолий Кулаков" И, во-вторых, что в последнее время стало очень модным и мейнстримовым, это nativeout, то есть генераторы совместимы с nativeout, генерация кода в рантайме не совместима с nativeout, поэтому так мы очень любим генераторы в компайл-тайме, что они нам дают nativeout-friendly, а это автоматический и быстрый запуск, и компактность приложения, и много-множество оптимизаций, и так далее, и так далее.
1130.64 1132.04 "Анатолий Кулаков" И тримминга, конечно же, да.
1132.04 1133.04 "Анатолий Кулаков" Вот.
1133.04 1145.48 "Анатолий Кулаков" И именно по этой схеме оптимизаций и пошли люди, которые придумали, что на самом деле очень часто в мире нам необходимо искать какую-то подстрочку в какой-то другой строке.
1145.48 1147.72 "Анатолий Кулаков" Да, очень часто операция.
1147.72 1158.60 "Анатолий Кулаков" Особенно если вы пишете какую-нибудь специализированную вещь, какой-нибудь парсер или токенайзер, или какой-нибудь еще текстовый процессор, который оперирует очень много с текстом.
1158.60 1165.62 "Анатолий Кулаков" Кстати, не обязательно с текстом, а с чем угодно, где вы можете какой-то массив чего-то найти в другом массиве под чего-то.
1165.62 1169.92 "Анатолий Кулаков" Такая довольно широкая задача, которая встречается на практике довольно-таки часто.
1169.92 1175.64 "Анатолий Кулаков" И вот именно под этот кейс и был создан специальный тип.
1175.64 1183.36 "Анатолий Кулаков" Также нужно понимать, что поиск подстроки в какой-то строке довольно хорошо ложится на векторные операции.
1183.36 1199.76 "Анатолий Кулаков" То есть, когда у вас процессор поддерживает векторные операции, это значит, что вы можете выполнить одну инструкцию, которая способна обработать очень много значений параллельно, если эти значения обрабатываются одинаково.
1199.76 1210.60 "Анатолий Кулаков" То есть, вы даете какую-то тысячу буквок, и в параллельной вселенной, в векторной вселенной, это то же самое, что сделать ту же самую операцию над одной буковкой.
1210.60 1213.12 "Анатолий Кулаков" То есть, он практически ничего на этом не теряет.
1213.12 1216.32 "Анатолий Кулаков" Он может параллельно запустить несколько обработчиков одинаковых.
1216.32 1223.56 "Анатолий Кулаков" И как раз поиск подстроки в строке хорошо ложится на эти векторные операции.
1223.56 1228.28 "Анатолий Кулаков" Например, у нас в линку всегда был метод, который назывался "indexOfAny".
1228.28 1236.00 "Анатолий Кулаков" Этот метод, например, применяемый к строке, мог найти вам определенный чар, то есть, определенную буковку в этой строке.
1236.00 1240.56 "Анатолий Кулаков" И он также мог в себя принимать не только одну буковку, но и массив буковок.
1240.56 1247.44 "Анатолий Кулаков" Это значит, что он вам вернет индекс первого вхождения любой буковки из переданного параметра.
1247.44 1254.80 "Анатолий Кулаков" Если у вас там, допустим, все цифры и весь английский алфавит, то он вам, соответственно, вернет, когда хоть что-то из этого встретится в какой-то строке.
1254.80 1263.24 "Анатолий Кулаков" И здесь интересно заметить, что, когда вы вызываете этот метод "indexOfAny", он на самом деле не прямолинейный.
1263.24 1271.04 "Анатолий Кулаков" То есть, если вы вызовете его с одним чаром и, допустим, с 36 чарами, стратегия его работы будет разная.
1271.04 1281.28 "Анатолий Кулаков" Он потратит некоторое время на то, чтобы проанализировать переданные аргументы, и в зависимости от переданных аргументов он выберет, а что нам дальше с этим делать.
1281.28 1291.92 "Анатолий Кулаков" Мы пойдем по быстрому какому-то перебору, тупому или каким-то образом попытаемся соптимизировать переданный аргумент так, чтобы искался он намного быстрее, зная, из чего он состоит.
1291.92 1305.96 "Анатолий Кулаков" И вот как раз таки вот этот этап "выбор стратегии и оптимизация переданного аргумента под выбранную стратегию", он становится довольно существенным, когда мы ищем по тексту довольно часто.
1305.96 1312.68 "Анатолий Кулаков" И в этот момент к нам приходит такое желание, что мы, в принципе, понимаем, что мы будем искать часто.
1312.68 1320.96 "Анатолий Кулаков" Мы, в принципе, понимаем, что вот у нас есть аргумент строго определенный, он не зависит от того текста, в котором мы будем искать.
1320.96 1327.64 "Анатолий Кулаков" Но вот что мы будем искать, мы точно знаем, и мы бы хотели прооптимизировать наш алгоритм, учитывая два вот этих параметра.
1327.64 1331.04 "Анатолий Кулаков" И таким образом на свет родились Search Values.
1331.04 1336.88 "Анатолий Кулаков" Search Values как раз позволяет вам разделить вот эту стратегию поиска на две независимые фазы.
1336.88 1345.28 "Анатолий Кулаков" Первая фаза подготавливает ваш шаблон для поиска, и вторая фаза уже непосредственно ищет ваш этот шаблон в других значениях.
1345.28 1375.50 "Анатолий Кулаков" Таким образом, вы можете создать тип, который называется SearchValues.create с помощью метода такого, передать ему все циферки, все буковки, весь алфавит, который вы хотите, и в этот самый момент код метода проанализирует, что ему было передано, он выберет правильную стратегию на основании тех аргументов, которые были переданы, он прооптимизирует какие-то свои внутренние буферы, векторы и прочую глупость, и сохранит вот эту стратегию в классе Search Values.
1375.50 1384.50 "Анатолий Кулаков" Таким образом, подобрав вот эту самую наилучшую технику, он может вам гарантировать, что для данного конкретного шаблона сгенерится специальная стратегия.
1384.50 1404.66 "Анатолий Кулаков" Она может быть на целевой машине векторизирована, если CPU это позволяет, там для нее может быть оптимизирован какой-то алгоритм, допустим, если вы передали только циферки, хотите искать в подстроке, но при этом не хотите буковки, алгоритм это все тоже умеет делать, он умеет это оптимизировать и будет искать вам каким-то образом быстро только сами циферки и все.
1404.66 1407.80 "Анатолий Кулаков" Вот такой, в принципе, интересный классик.
1407.80 1422.12 "Анатолий Кулаков" Интересен он также тем, что, как я уже говорил, он может искать не только среди строчек и среди буковок, он может, в принципе, искать среди любого Redundant Span, Redundant Span от T.
1422.12 1430.04 "Анатолий Кулаков" Это, значит, строки, это, значит, любые memory буферы, это, значит, рейнджи меморей, массивы и так далее.
1430.04 1437.36 "Анатолий Кулаков" Ну, практически как бы все, что вы можете за Redundant Span использовать, а в современном дотенте это любые области памяти практически.
1437.36 1445.80 "Анатолий Кулаков" Вот, и дальше, после того, как вы приготовили этот search value, вы можете его непосредственно долобить в строке, и он-то будет искать максимально быстро.
1445.80 1455.68 "Анатолий Кулаков" Более того, он может учитывать, например, такие вещи, как искать с учетом регистра или искать без учета регистра.
1455.68 1459.74 "Анатолий Кулаков" В общем, это все у него тоже есть в прикомпилированной стратегии.
1459.74 1464.98 "Анатолий Кулаков" Здесь, на этом этапе он тоже оптимизирует, то есть не в runtime это делает.
1464.98 1466.98 "Анатолий Кулаков" Насколько же быстро эта штука работает?
1466.98 1473.46 "Анатолий Кулаков" Ну, на малых размерах, до 4 элементов, никакой разницы как бы с полным перебором вы, естественно, не увидите.
1473.46 1479.26 "Анатолий Кулаков" А уже, когда размеры повышаются, тем уже повышается и скорость работы этого search values.
1479.26 1492.14 "Анатолий Кулаков" Где-то примерно на 2000 элементов, например, на 2000 букв, если вы ищете какой-то текст, да, у вас там 2000 буквок, то там уже performance достигает двоекратного ускорения.
1492.14 1497.66 "Анатолий Кулаков" То есть в 2 раза быстрее мы будем искать с помощью search values на таком тексте, чем без него.
1497.66 1503.50 "Анатолий Кулаков" В принципе, для тех операций, где мы часто работаем с текстом, это довольно существенный performance.
1503.50 1511.18 "Анатолий Кулаков" И опять же, чем извращеннее шаблон, чем он у вас больше, чем у вас больше текст, тем больше вы выиграете на вот этих search values.
1511.18 1531.58 "Анатолий Кулаков" Поэтому, если вы часто работаете с каким-нибудь поиском под строки, или даже под какого-то массива байт, какой-то другой выделенной области байт, или банально под строки в строке, то, вероятно, вам имеет смысл посмотреть на этот новенький интересный класс, который, опять же, внутри себя использует очень много стратегий.
1531.58 1547.78 "Анатолий Кулаков" Как обещают разработчики, если будут добавляться поддержки каких-нибудь новых процессоров, или новых runtime оптимизаций, или новых векторных инструкций, автоматически этот метод будет их имплементировать, и ваш код, ваши подстроки будут искаться быстрее и быстрее с каждой новой версией дотнета и рантайма.
1547.78 1558.14 "Игорь Лабутин" Да, причем надо понимать, что поиск под строки, иногда довольно неожиданные задачки сводятся к поиску под строки.
1558.14 1583.38 "Игорь Лабутин" То есть, например, через ровно этот search values, это, по-моему, было первое, где он был заменен и применен в самом рантайме, это всякие штуки типа там разбиения на строке, в смысле enumerate lines какой-нибудь по тексту, то есть ты даешь какой-нибудь длинный большой текст и хочешь получить построчно оттуда, да, это же по сути поиск под строки в строке, где ты ищешь любой из символов переноса строки.
1583.38 1585.06 "Игорь Лабутин" Ну да, окончания строки.
1585.06 1596.62 "Игорь Лабутин" Да, да, да, коих может быть много, и казалось бы, в общем, это не совсем про поиск под строки в строке, но это вот ровно оно, и search values, это было одно из первых применений как раз-таки для ускорения.
1596.62 1607.86 "Игорь Лабутин" Вот там этих самых символов переноса строк не так много, поэтому там даже старый вариант нормально справлялся, но если вы ищете что-то более сложное, то будет
1607.86 1608.86 "Анатолий Кулаков" действительно быстрее.
1608.86 1617.34 "Анатолий Кулаков" Ну или, например, если мы рассматриваем токенайзер какой-нибудь, да, тот же самый Рослинн, которому нужно искать пробельчики, точечки для того, чтобы токены друг от друга отделить, вот типичный пример.
1617.34 1627.62 "Игорь Лабутин" Фигурные скобочки, точки с запятой, табы, переносы строк, и в общем вот уже набирается больше пяти, и векторизация отключается в старом варианте, а теперь не будет.
1627.62 1665.58 "Игорь Лабутин" Окей, хорошо, давай пойдем дальше, у нас сегодня такой выпуск про всякие разные тулы, мне кажется, будет еще, можно его так охарактеризовать, потому что я нашел, ну как нашел, не то чтобы я искал, случайно у меня попалась статья в DevBlog, вроде бы не про .NET, но как оказалось немножко про .NET, про тул под названием DevProxy, он относится к .NET, поскольку написан на C#, и предназначен для следующего, не то чтобы забавного, но для следующего применения.
1665.58 1689.46 "Игорь Лабутин" Смотрите, мы когда используем всякие разные апишки из наших приложений, а в общем-то сейчас большинство приложений я так поднимаю, если это не какие-нибудь консольные тулы или десктопные, да даже десктопные приложения частенько куда-нибудь с какими-нибудь апишками ходят, что-нибудь надо в интернете спросить, поискать, не знаю, в AI сходить куда-нибудь, дернуть, ну и так далее.
1689.46 1699.38 "Игорь Лабутин" И разработчики, ну естественным образом думают в основном о то, что называется Happy Path, что будет, точнее как приложение себя ведет, если все работает.
1699.38 1738.82 "Игорь Лабутин" Более опытные разработчики знают, что рассчитывать, что API всегда доступна, обычно не стоит, и поэтому обкладывается всякими разными поли, да, вот эти все retry policy, все такое, это все здорово, поли хорошая библиотека, ей можно верить, она работает неплохо, но как ваше приложение-то будет работать, если вдруг сервис таки отвалится, поли не, что-то магическое, если сервис вдруг совсем недоступен, апишкой которого вы пользуетесь, ну как бы она ничего не сможет сделать, но все равно прилетит таки какой-нибудь там 500, не 500, не знаю, 503 сервер недоступен, ну или просто что-то сломалось, вот.
1738.82 1740.02 "Игорь Лабутин" Надо эти штуки тоже тестировать.
1740.02 1747.54 "Игорь Лабутин" И в целом это довольно сложно, особенно если вы зависите от какого-то внешнего API, который вы не контролируете.
1747.54 1768.78 "Игорь Лабутин" Одно дело тестировать свои же приложения, да, как один бэкэнд к другому бэкэнду, например, или frontend к бэкэнду обращается, и что будет, если бэкэнд начнет отвечать какую-нибудь неожиданную, значит, комбинацию там, не знаю, проперти или еще что-нибудь в таком духе, или времен ответов, то медленно, то быстро, а вот со сторонними сервисами такой афиг сделаешь.
1768.78 1776.54 "Игорь Лабутин" Так вот, DevProxy как раз таки позволяет с этим немножко поиграться и сделать так, чтобы это было удобно тестировать.
1776.54 1796.34 "Игорь Лабутин" Значит, это в принципе некоторый симулятор API, который позволяет либо просто симулировать разные поведения API, и при этом под симуляцией подразумевается, что можно симулировать ошибки, задержки, какой-нибудь rate limiting и много чего другого, немножко чуть позже расскажу.
1796.34 1824.30 "Игорь Лабутин" В принципе, для этих целей можно было, ну в общем, это не первый раз, когда такие тулы появляются, таких тулов, естественно, наверняка было много, они все работают в целом через прокси в системе, то есть этот тул не исключение, то есть он просто регистрируется как веб-прокси на вашем компе и, соответственно, если правильно сказать приложению любому причем, что вот наш DevProxy живет здесь, то все вызовы будут идти через этот прокси и он сможет на них как-то влиять.
1824.30 1845.22 "Игорь Лабутин" Для того, чтобы это все влияло только на нужные вам кусочки приложения, можно настроить, ну для простоты здесь в примере показано, что настраивается для того, чтобы слушать какой-то конкретный урл, но там есть более развесистые конфигурации, чуть позже расскажу.
1845.22 1872.34 "Игорь Лабутин" Дальше для реквестов нужно задать, что мы делаем, можно вернуть какой-то предопределенный ответ, он тогда вообще не пойдет в, так скажем, нормальный API, можно кинуть ошибку, можно задержать ответ, можно попробовать посимулировать ограничение пропускной способности, то есть как-то порейдлимитить запросы, можно, как ни странно, просто позаписывать сессию и посмотреть вообще, что происходит.
1872.34 1885.10 "Игорь Лабутин" Есть штука под названием Crude API Mocking, когда вы отдаете в конфигурацию JSON-чик с готовыми entity, а эта штука умеет над ними делать create, read, update, delete, симулировать его.
1885.10 1903.30 "Игорь Лабутин" Ну и интересный кейс, можно после того, как он позаписывает все, что творится, он умеет сгенерить OpenAPI-спеку, то есть вы такие, вам дали какой-нибудь там сторонний API, у которого нет OpenAPI-спеки, вы что-то пописали, погоняли в ваше приложение и вот у вас уже есть OpenAPI-спека внешнего API, по крайней мере той части, которую вы используете.
1903.30 1910.90 "Игорь Лабутин" Понятно, что ее надо допиливать напильником, понятно, что там не будут написаны все типы, возможно, или они будут написаны неправильно, но хоть что-то, уже приятно.
1910.90 1948.18 "Игорь Лабутин" Написано это все, еще раз я говорю, на C#, значит, там есть разбор примерчика, что вы просто запускаете в консольке, где в проксе, указываете параметром urls_to_watch, какие urls смотреть, эта штука будет использовать дефолтную конфигурацию, по умолчанию, если не передать никакие конфигурационные файлы, ну и стартуете ваше приложение, передав примерно окружение http, подчеркиваю, не прокси, оно тогда будет ходить через прокси, и после чего в консольке этого самого, где в проксе, будет видны все, что происходит, все вызовы к API, что с ними было сделано.
1948.18 1956.10 "Игорь Лабутин" Типа, тут мы попытались зейролизлимитить, тут мы ответили ошибкой, тут мы сделали, там красиво так все рисуется, прям зашибись, выглядит здорово, но в консольке.
1956.10 1965.94 "Игорь Лабутин" Вот, для того, чтобы эта вся радость заработала, нужно, во-первых, поставить где в проксе, либо берете просто из github-релиза, либо из Vingetta, если вы на винде.
1965.94 2026.54 "Игорь Лабутин" Дальше нужно сконфигурить, конфигурится все очень, так сказать, по, без изысков, то есть файлик defproxyrc.json и defproxyrc.json, берете два файлика из папочки инсталляции, копируете к себе, модифицируете как хотите, передаете через аргумент - -config файл и работаете, в каком-то смысле похоже на то, что мы с тобой обсуждали про Aspire, как бы написано на коленке, так сказать, минимально работающий вариант, берете, пользуетесь, но, правда, есть два расширения для, соответственно, Visual Studio, нет, одно расширение для VSCode, называется devproxy toolkit, которое позволяет чуть правильнее, удобнее редактировать конфиг файл, а второе расширение, которое позволяет открыть результат работы, потому что в консольке может быть неудобно читать в браузерных DevTools и видеть, как будто бы это все было в браузере, ошибочки смотреть, фильтровать, все вот это все, запросы, ответы и все такое прочее.
2026.54 2054.34 "Игорь Лабутин" Вот такая штука, то есть, во-первых, ну, звучит действительно интересно для того, чтобы просто попробовать, если вам нужно как-то попробовать поломать ваши API, выглядит довольно то, что называется по-английски seamless, бесшовно, поставили, накидали в JSON-чик конфигурацию и поработали, а во-вторых, интересно посмотреть на самом деле, как оно реализовано, я что-то думал, что он через YARP, но вроде как не через YARP, вроде там все какое-то самописное на вид.
2054.34 2055.90 "Анатолий Кулаков" Странно, но зачем, да.
2055.90 2061.90 "Игорь Лабутин" Я бы ожидал YARP, может быть, я его просто там не нашел, честно скажу, вот, такое может быть.
2061.90 2075.74 "Игорь Лабутин" Живет это все в гитхабе Майкрософта, родилось это все на хакатончике, короче, у них там был 2-3-дневный хакатон, что ли, где пару чуваков, а вот с 5 по 9 сентября 22 года, трое чуваков написали этот проектик быстренько.
2075.74 2080.86 "Игорь Лабутин" Ну и дальше вот он с тех пор живет, поддерживается, развивается.
2080.86 2106.70 "Игорь Лабутин" Релиз у него, правда, версии 0.17.1, то есть, короче, пока очень такой ранний, назовем это так, вот, но, нет, кстати, действительно, они почему-то не на YARP, помнишь такую штуку, мне почему-то что-то такое отдает в память, Titanium Viproxy, у них package reference, вот, видимо, эта штука как раз у них используется для проксии.
2106.70 2108.78 "Анатолий Кулаков" Ну это, кажется, левый пакет, микрософтовский.
2108.78 2116.70 "Игорь Лабутин" Это не микрософтовский, мне просто кажется, что мы тоже его для чего-то когда-то использовали, вот именно, проксии, не проксии, какое-то знакомое название, Titanium Viproxy.
2116.70 2121.34 "Игорь Лабутин" Слушай, с другой стороны, в 22 году YARP-то уже был, да, не был, был, 2 года назад.
2121.34 2122.34 "Игорь Лабутин" Да был, был, конечно.
2122.34 2124.90 "Игорь Лабутин" Вот, ну в общем, почему-то не на YARP, ну так сложилось.
2124.90 2135.50 "Анатолий Кулаков" Ну, Хакатон, опять же, заслали каких-нибудь специальных чуваков из компании Titan, чтобы внедрить зависимость в сам Microsoft, чтобы потом, как бы, Microsoft их тащил за уши.
2135.50 2157.18 "Игорь Лабутин" Ну, в общем, короче, штука, мне кажется, по крайней мере, достойна того, чтобы попробовать, вдруг, работать, там можно написать плагинчики свои, если надо, тут уже есть куча всяких плагинов, вот, там, по сути, на самом деле, вся функциональность, которая у них есть, она реализована, в принципе, плагинами, даже встроенная функциональность, это всё плагины.
2157.18 2163.42 "Анатолий Кулаков" Ну, идея интересная, как бы, во многих языках действительно она уже есть, и хорошо, что тут тоже появилась.
2163.42 2172.82 "Анатолий Кулаков" В принципе, будет замечательно, если это вырастет в какой-нибудь всё-таки релизный полноценный тул, потому что с поддержкой там, знаешь, совсем таким, чтобы плагины там начали больше крепаться.
2172.82 2173.82 "Анатолий Кулаков" Ну, это замечательно.
2173.82 2174.82 "Игорь Лабутин" Да, да.
2174.82 2183.10 "Игорь Лабутин" То есть оно всё, MIT, вот это всё, лицензия, всё такое прочее, так что вполне себе неплохо выглядит.
2183.10 2196.18 "Игорь Лабутин" Тут URL есть, нет, у них есть довольно неплохой сайт по, или я уже с кем-то путаю, нет, не помню, сайта у них наверно нету всё-таки, надо всё пока в JSON смотреть, а нет, документация какая-то есть, короче.
2196.18 2199.42 "Игорь Лабутин" Так что… Товарные ценники есть, заберёмся.
2199.42 2213.70 "Игорь Лабутин" Я тебе более того скажу, не то, что у них есть какой-то сайт документации, он лежит, прости меня, на LearnMicrosoft.com, так что прямо официальная документация… Значит, они взялись прямо за продукт, будем смотреть.
2213.70 2214.70 "Игорь Лабутин" Да, да, да.
2214.70 2220.82 "Игорь Лабутин" Tutorials, how-to, concepts, reference, короче, да, подробнейшая документация в разделе Microsoft Cloud, это всё лежит.
2220.82 2221.82 "Игорь Лабутин" Вот.
2221.82 2226.58 "Игорь Лабутин" Такая вот песня, ещё один такой микро, мини, не знаю, тул Microsoft.
2226.58 2236.66 "Анатолий Кулаков" Может, они его потом в конце заинтегрируют в Aspire, чтобы автоматически делали всё в Aspire, а у вас тут раз, бацек, веб-прокси, хаус-манки, всё здесь сразу тестируется,
2236.66 2237.66 "Игорь Лабутин" проксируется.
2237.66 2243.82 "Игорь Лабутин" Там же, прям, сам бог велел, там же как раз компоненты друг к другу общаются, понимаешь, прям туда и конфигурить на C#.
2243.82 2248.02 "Анатолий Кулаков" Ну вот, может, поэтому и открыли ближе к релизу Aspire, знаешь, больше интересных плагинов.
2248.02 2249.02 "Анатолий Кулаков" Может, может.
2249.02 2250.02 "Анатолий Кулаков" Хорошо, пойдём дальше.
2250.02 2251.02 "Анатолий Кулаков" Давай.
2251.02 2268.02 "Анатолий Кулаков" Так, я тут взобрёл на статью Николаса Блумхарта, небезызвестного автора Серилога и Сика, и он выпускает довольно периодично такие статьи, которые называются «Как, собственно, заинтегрить Серилог в текущую версию фреймворка».
2268.02 2282.22 "Анатолий Кулаков" И статья, казалось бы, довольно примитивная, довольно простая, но на самом деле, на практике очень многие люди неправильно настраивают логеры и встраивают их в свои приложения не совсем корректно.
2282.22 2290.90 "Анатолий Кулаков" Несмотря на то, что там есть буквально три простых шага, которых нужно придерживаться, многие не знают, как это делать.
2290.90 2293.90 "Анатолий Кулаков" И поэтому я решил эту статью подтянуть, тем более она тут свеженькая, красивая.
2293.90 2313.10 "Анатолий Кулаков" В своей статье он рассказывает о том, как строить Серилог в .NET 8 Minimal API, но на самом деле она подходит не только для .NET 8, а абсолютно для любого .NET, то есть основные ее концепции, и не только для Minimal API, как ни странно, потому что Maximum API тоже прекрасно ей покрывается.
2313.10 2320.98 "Анатолий Кулаков" Поэтому все, что будет сказано в статье, оно справедливо для любой версии Серилога, для любой версии .NET, и тем более для любой версии API.
2320.98 2328.14 "Анатолий Кулаков" И поэтому давайте конкретно на этом примере, потому что свеженький, красивый, разберем, а как же все-таки правильно подключать Логгер к вашему приложению.
2328.14 2346.98 "Анатолий Кулаков" Ну, прежде всего, Николас напоминает, что в принципе все ваши ISP.NET Core приложения, какими бы они там крутыми и не казались, какими бы там кестерылы не поднимали, на самом деле это всего лишь навсего с точки зрения Логгера, это обычное консольное приложение, ни больше, ни меньше.
2346.98 2347.98 "Анатолий Кулаков" Консольное приложение.
2347.98 2361.98 "Анатолий Кулаков" Таким образом вы, в принципе, можете подключить Серилог, как к любому консольному приложению, то есть создать просто-напросто серилог конфигурашн, настроить все синки и все инричери, которые вам нужны и просто-напросто юзать Логгер, который пишет в консоль.
2361.98 2366.78 "Анатолий Кулаков" Для этого нужно сделать несколько небольших действий.
2366.78 2369.22 "Анатолий Кулаков" Естественно, установить пакет, который называется серилог.
2369.22 2374.90 "Анатолий Кулаков" Также установить пакет, который называется synx-консоль, что поможет вашему Логгеру писать в консоль.
2374.90 2388.78 "Анатолий Кулаков" И прямо в программ.cs, первой же строчкой, как только начинается ваш код, еще до того, как вы создали какой-нибудь там аппликейшн билдер или что-то сделали еще, первой же строчкой, должен идти создание Логгера.
2388.78 2397.06 "Анатолий Кулаков" Там прямо можно сделать нью логгер конфигурашн, врайт ту консоль и крейт логгер, и вы создаете уже Логгер.
2397.06 2399.26 "Анатолий Кулаков" Почему это все должно идти первой строчкой?
2399.26 2401.58 "Анатолий Кулаков" Потому что дальше пойдет какой-то ваш код.
2401.58 2408.38 "Анатолий Кулаков" Вы там будете регистрировать сервисы, билдить свои приложения, настраивать им какие-то конфигурации.
2408.38 2412.34 "Анатолий Кулаков" В любом из этих шагов может случиться какая-то проблема.
2412.34 2419.50 "Анатолий Кулаков" Может случиться какое-то исключение или какое-то важное бизнес-ветвление, которое вы хотите залогировать.
2419.50 2424.66 "Анатолий Кулаков" В общем, могут случиться те важные шаги, которые вам нужно будет видеть в логах.
2424.66 2439.78 "Анатолий Кулаков" Чтобы приложение, когда оно упало, оно падало не просто так с пустым черным экраном или с пустым черным лог-файлом или еще каким-нибудь пустым черным дном, а оно рассказало, почему оно не смогло запуститься даже хотя бы в самом начале.
2439.78 2451.62 "Анатолий Кулаков" Даже когда оно начинает строить у вас веб-аппликейшн-билдер какой-нибудь и он не смог найти какой-нибудь референс, который у него случайно подтащился, вы об этом должны уже в логах знать.
2451.62 2456.82 "Анатолий Кулаков" Поэтому первой строчкой у вас должен появиться настроенный, красивый, хороший логгер.
2456.82 2459.22 "Анатолий Кулаков" И именно здесь его нужно делать.
2459.22 2468.06 "Анатолий Кулаков" Не оставлять это все на тот момент, когда появится конфигурация, когда появится сервис-коллекция, когда появится сам веб-аппликейшн-билдер, нет, это уже поздно.
2468.06 2471.18 "Анатолий Кулаков" Пока оно появится, у вас уже может случиться миллион всяких проблем и ошибок.
2471.18 2478.78 "Анатолий Кулаков" И, как я уже сказал, после того, как вы сделали конфигурацию, логгером можно пользоваться, его можно логировать.
2478.78 2484.50 "Анатолий Кулаков" Но, опять же, вспоминаем, что на момент инициализации у вас могут быть ошибки.
2484.50 2489.50 "Анатолий Кулаков" Поэтому следующей строчкой после того, как вы создали себе полноценный логгер, должна быть строчка "try".
2489.50 2499.66 "Анатолий Кулаков" И все остальное у вас должно идти в блоке "try-catch", то есть создание билдера, построение билдера, запуск вашего приложения – это должно все в блоке "try-it".
2499.66 2509.78 "Анатолий Кулаков" В блоке "catch" вы обязательно обрабатываете исключения, а что случится, если вдруг ваше приложение там рухнет в момент настройки или вдруг там рухнет в момент запуска самого приложения.
2509.78 2521.34 "Анатолий Кулаков" То есть здесь у вас уже есть исключения, у вас уже есть логгер, и в блоке "catch" вы это исключение в логгер записываете и радостно возвращаете код ошибки.
2521.34 2533.74 "Анатолий Кулаков" И также у вас здесь должен быть блок "finally", который помогает логгеру сбросить все те события, которые у него накопились во внутреннем буфере, сбросить в синки.
2533.74 2547.82 "Анатолий Кулаков" То есть сейчас современные логгеры, они в основном пишут куда-нибудь далеко, там на какой-нибудь лог-сервер или там в Elasticsearch, или в SICK, или еще куда-нибудь, и пишут они туда несинхронно, пишут они туда обычно асинхронно.
2547.82 2568.38 "Анатолий Кулаков" То есть есть какой-то буфер, в этот буфер быстренько накапливается сообщение, а потом какой-то воркер из этого буфера разбирает все и отсылает в сеть, потому что опять же сеть может быть медленная, сеть может тормозить, сеть может отваливаться, и мы при этом не хотим, что наша программа каким-то образом фризилась или тормозила или еще что-то с ней делалось, поэтому эти процессы разведены.
2568.38 2581.82 "Анатолий Кулаков" И это правильно, но когда ваше приложение падает по какой-то исключительной ошибке, и в этих буферах остаются сообщения, которые еще не успели дойти до удаленного сервера, эти сообщения потеряются.
2581.82 2598.18 "Анатолий Кулаков" Мы себе не можем позволить, чтобы они потерялись, потому что в этих сообщениях как раз-таки может скрываться причина того, почему оно, собственно, упало, поэтому в блоке файнали вам обязательно нужно закрыть логер и зафлушить все эти буферы, то есть дождаться, пока эти буферы уйдут на удаленный сервер.
2598.18 2602.66 "Анатолий Кулаков" В общем, и как раз это делает метод, который называется close and flush async.
2602.66 2620.26 "Анатолий Кулаков" В принципе, все, и после этого ваше приложение может уже спокойно заканчиваться, в общем, при любом стечении обстоятельств чувствует себя уверенно, что если оно будет работать, у него будет хороший понятный логер, или даже если оно упадет, у вас все равно будут хорошие понятные логи.
2620.26 2631.46 "Анатолий Кулаков" Теперь, если мы на этом моменте подключили какой-нибудь консоль SYNC, то у нас в нашем консольном приложении до данный момент работают оба логера.
2631.46 2639.82 "Анатолий Кулаков" Перелог логер, который пишет вам в консоль после того, как мы его настроили с этим, чего мы пытались добиться.
2639.82 2657.94 "Анатолий Кулаков" А также еще у нас в Default Web Application Builder, ну и в любом Application Builder у нас регистрируется такая полезная, прекрасная штука, как Microsoft iLogger, то есть это тот самый логер, который используется самим фреймворком ASP.NET Core и всеми остальными в принципе тоже.
2657.94 2669.94 "Анатолий Кулаков" То есть, когда вы запустите ваше приложение, вы увидите два аутпута, первый аутпут от того логера, который вы настроили, и второй аутпут от самого Microsoft, и эти аутпуты, они даже по форматам будут отличаться, вы их невооруженным взглядом увидите.
2669.94 2680.70 "Анатолий Кулаков" Естественно, нам такого счастья не нужно, у нас логер должен быть один, чтобы контролировать, в какие SYNC он пишет, с какими Enricher он пишет, в общем, чтобы всю конфигурацию контролировать в одном единственном месте.
2680.70 2682.54 "Анатолий Кулаков" Что для этого нужно?
2682.54 2683.54 "Анатолий Кулаков" Все очень просто.
2683.54 2691.78 "Анатолий Кулаков" Ставите пакет, который называется Serial Log Extension Hosting, и у вас появляется у вашей коллекции сервисов метод, который называется AddSerialLog.
2691.78 2696.14 "Анатолий Кулаков" Метод AddSerialLog делает за вас абсолютно все, что вам нужно.
2696.14 2716.38 "Анатолий Кулаков" Он убирает старый микрософтовский логер с его микрософтовскими форматорами и замещает вместо стандартного LogFactory свою SerialLogFactory, которая теперь создает SerialLogLogger, у которых вы уже все настроили, у которых есть конфигурация, и SerialLogLogger, соответственно, пишет везде, куда вы ей скажете.
2716.38 2724.58 "Анатолий Кулаков" И после этого шага у вас уже будет в консоли виден консистентный, красивый лог, как он и должен быть.
2724.58 2727.74 "Анатолий Кулаков" Красивый сериалоговский выхлоп.
2727.74 2728.74 "Анатолий Кулаков" Поехали дальше.
2728.74 2734.70 "Анатолий Кулаков" Если вам достаточно писания в консоль, то, в принципе, на этом можно остановиться, но обычно в настоящем приложении этого недостаточно.
2734.70 2738.14 "Анатолий Кулаков" СТДА – вот это не единственное место, куда можно писать.
2738.14 2749.70 "Анатолий Кулаков" Можно писать, например, файлы для того, чтобы в каких-то чрезвычайных ситуациях вы могли примонтировать вольюм, допустим, и сохранить хотя бы файлы, те логи, которые почему-то не смогли дойти куда-то на удаленный сервис.
2749.70 2758.02 "Анатолий Кулаков" Можно прямо задать URL удаленного сервиса, какой-нибудь Remote Network Logging, какой-нибудь Elastic или тот же самый SICK, допустим.
2758.02 2771.14 "Анатолий Кулаков" SICK, в принципе, прекрасен тем, что на нем его можно очень легко поднять локально, его не нужно настраивать, у него очень хорошие дефолтные настройки, дефолтное всякое поведение.
2771.14 2775.14 "Анатолий Кулаков" Для локального разбора, локальной настройки – великолепная вещь.
2775.14 2778.10 "Анатолий Кулаков" Теперь, как настраивать логи?
2778.10 2782.82 "Анатолий Кулаков" Для настройки серилога существуют два основных подхода.
2782.82 2783.82 "Анатолий Кулаков" Разберем их по порядку.
2783.82 2788.38 "Анатолий Кулаков" Первый подход – это настройка через код, и второй подход – это настройка через файл.
2788.38 2790.58 "Анатолий Кулаков" Через код – это более рекомендуемая штука.
2790.58 2791.58 "Анатолий Кулаков" Почему?
2791.58 2796.54 "Анатолий Кулаков" Ну, во-первых, у вас есть доступ к абсолютно всему, что есть в приложении.
2796.54 2804.66 "Анатолий Кулаков" То есть вы можете доступиться к переменным средеокружениям, подстроить ваши синки, допустим, вытащить URL того же самого сика, куда писать логи.
2804.66 2810.78 "Анатолий Кулаков" Вы можете взять какие-то настройки и просканировать там ваши классы, какие-то настройки оттуда взять.
2810.78 2826.02 "Анатолий Кулаков" У вас есть строго типизированный компилятор, потому что вы пишете все настройки на C#, и у вас есть, прежде всего, строго типизированный C#, который вам помогает с помощью интеллисенса, с помощью различных анализаторов написать правильную настройку логера.
2826.02 2838.14 "Анатолий Кулаков" В настройке вы уже можете указать, какие синки использовать, какие буферы там использовать, буферы с какими размерами использовать, куда писать, как форматировать, какими цветами.
2838.14 2839.14 "Анатолий Кулаков" Вот это все можете писать легко кодом.
2839.14 2843.22 "Анатолий Кулаков" У SICK очень приятный Fluent Syntaxes, где все это настраивается.
2843.22 2853.42 "Анатолий Кулаков" Допустим, если мы хотим подключить тот же самый SICK, то для этого вам достаточно установить пакет, который называется Serialog Sync SICK и вызвать всего лишь на все.
2853.42 2856.02 "Анатолий Кулаков" У Logger Configuration один-единственный метод, который называется WriteToSick.
2856.02 2861.78 "Анатолий Кулаков" Все, и после этого вы начнете писать в SICK все ваши логи, которые происходят в приложении.
2861.78 2866.10 "Анатолий Кулаков" Естественно, у вас на компьютере вполне может и не быть SICK.
2866.10 2870.18 "Анатолий Кулаков" Но, как я уже сказал, он прекрасно настраивается и имеет великолепные дефолты.
2870.18 2891.78 "Анатолий Кулаков" Поэтому, если вы сделаете Docker run SICK, то у вас запустится локальный контейнер с SICK, после этого вы можете открыть браузер на Localhost 5341, и у вас откроется приятный, удобный интерфейс, где вы уже можете в ту же секунду начать смотреть, а что ваше приложение там делает, какие логи посылает, с какими таймингами, с какими трейсингами.
2891.78 2895.90 "Анатолий Кулаков" В общем, SICK очень мощная такая штука, там дашборды можно смотреть и так далее, и так далее.
2895.90 2900.66 "Анатолий Кулаков" Если вы ни разу не видели, посмотрите хотя бы скриншоты, я уверен, вы в него влюбитесь.
2900.66 2901.66 "Анатолий Кулаков" Теперь опция 2.
2901.66 2907.78 "Анатолий Кулаков" Как я уже сказал, есть вторая опция настройки Serialog, это с помощью конфигурации, это с помощью AppSettings.json.
2907.78 2918.46 "Анатолий Кулаков" Для этого вам необходимо поставить пакет, который называется Serialog Settings Configuration и вызвать метод у настройщика, который называется Read From Configuration.
2918.46 2931.42 "Анатолий Кулаков" В общем, после этого все, что будет написано в вашем файле AppSettings.json в секции Serialog, также точно преобразуется в конфигурацию, подтягивается и внедряется в настройки самого SICK.
2931.42 2933.38 "Анатолий Кулаков" Какие минусы у этого метода?
2933.38 2940.10 "Анатолий Кулаков" Ну, вам нужно описывать конфигурацию в JSON, мне кажется, этим минусом можно ограничиться, потому что он critical-fatal.
2940.10 2946.38 "Анатолий Кулаков" Потому что, блин, описывать конфигурацию в JSON, описывать все, что угодно в JSON, это дороговато.
2946.38 2964.58 "Анатолий Кулаков" Легко опечататься, нет никаких проверок, нет никакого интеллисенса, нет вообще ничего, кроме что, даже гибкость не такая большая, как в Environment, потому что нет никаких переменок, нет никаких темплейтов, нет строго типизированного компилятора, в общем, не делайте так.
2964.58 2984.82 "Игорь Лабутин" Ну, слушай, погоди, тут у меня есть вопрос-разражение, мы неоднократно пользовались возможностью через JSON временно переопределить, например, лог-левел для какого-то конкретного класса, ну если не в рантайме, то, по крайней мере, просто у контейнера, либо у кого-то меняешь переменное окружение.
2984.82 3005.86 "Игорь Лабутин" Оно, конечно, имя выглядит ужасно, за счет того, что каждая точка заменяется одним или двумя подчеркиваниями, я уже не помню, какой-то полный синтез, но в итоге это позволяло, как бы без перекомпиляции, тебе временно поменять лог-левел у какого-то конкретного логгера на нужный тебе там, ну если не дебаг, то, по крайней мере, там ворны на инфу, например, поменять от какого-нибудь внутреннего.
3005.86 3020.78 "Игорь Лабутин" Внутрянка EF Core, либо еще кого-нибудь, поэтому иногда это бывает полезно, т.е. всё равно, т.е. как с этим жить, бороться, перекомпилировать всё-таки, как ты считаешь?
3020.78 3027.86 "Анатолий Кулаков" Смотри, дилемма очень простая, мы сейчас рассуждаем о том, как настроить основную конфигурацию серилога, т.е. то, что у него будет запускаться при старте.
3027.86 3039.78 "Анатолий Кулаков" А при старте у него там может быть, опять же, 20 синков, 30 буферов, 50 форматоров, в общем, всё это в JSON-файле будет выглядеть мега безобразно, а в коде это буквально там 10 строчек кода, которые красивые, интеллисенсные и всё такое.
3039.78 3049.86 "Анатолий Кулаков" А теперь мы говорим про то, что нам иногда нужно в рантайме поменять там лог-левел или подключить какой-то экстремальный форматор, который начнёт там вверх боузе всё выдавать и дампить бинарии на диск.
3049.86 3057.90 "Анатолий Кулаков" Да, это всё можно сделать, но это уже будет у тебя там одна или две строчки, и это уже как-то можно пережить, и в JSON-е.
3057.90 3071.54 "Игорь Лабутин" Т.е. ты, короче, правильно ли я тебя понял, что мы же начали весь этот разговор с того, что ты первым делом пишешь там new logger configuration, write to console, create logger и потом try весь основной код.
3071.54 3098.38 "Игорь Лабутин" Т.е. вот вся вот эта вот настройка синков и всего, чего хочется в коде делается до того, как ты начал собирать свои веб-аппликейшены и всё остальное, полностью собираешь всё из кода, всё как надо, всё как тебе нужно в стандартном варианте, и дальше, когда уже у тебя подстроена вся конфигурация, прочитаны все апсеттинги с JSON и вот это всё, ты говоришь ему ещё дополнительно read from configuration, и он туда дочитает, если ты что-то переопределил через окружение, ну через конфиг.
3098.38 3110.58 "Анатолий Кулаков" Да, да, именно так, т.е. в идеальной картине мира у тебя в апсеттинге нет ничего, всё настроено строго в коде, но если тебе нужно что-то пропатить и что-то сделать, то да, это можно потащить там пару строчек из апсеттингов.
3110.58 3113.58 "Игорь Лабутин" Всё, я понял, окей.
3113.58 3129.74 "Анатолий Кулаков" Так, пойдём дальше, я напомню, что мы собираем не просто консольное приложение, да, всё-таки какой-то ISP.NET, если ISP.NET, то значит у нас там приходят какие-то запросы и уходят какие-то ответы, т.е. банальный логер, который хочется иметь, это логер, который нам логирует, а что за запрос пришёл и что за ответ ушёл.
3129.74 3144.08 "Анатолий Кулаков" Более того, он настолько банален, что в стандартном комплекте ISP.NET Core такой логер есть, но опять же, насколько я пытался к нему привыкнуть, он мне не нравится, нехороший он, мало информации, не в таком формате информация, не так полезен, не так красив.
3144.08 3153.46 "Анатолий Кулаков" У серилога есть свой специальный реквест-логин Middleware, который намного более информативен, намного более интересен и намного более гибок.
3153.46 3160.26 "Анатолий Кулаков" В общем, её автор тоже говорит, что как бы используйте его, а стандартный микрософтовский отключите.
3160.26 3170.30 "Анатолий Кулаков" К сожалению, стандартный микрософтовский отключить не так уж и просто, потому что он там как бы гвоздями забиты, как бы поставить конфигурацию или поставить галочку у вас не получится.
3170.30 3175.22 "Анатолий Кулаков" Поэтому идём по хардкорному пути.
3175.22 3185.86 "Анатолий Кулаков" Любой логер, который вам не нравится, который очень много спамит, а таких логеров сразу предупреждаю, микрософт запилил огромную кучу, которые просто засирают вам лог без всякой, видимо, на то причины.
3185.86 3189.90 "Анатолий Кулаков" Такие логеры отключаются с помощью override минимум левела.
3189.90 3198.06 "Анатолий Кулаков" У вас у конфигурации есть минимум левел, и вы можете завирайдить для какого namespace, то есть какой минимальный уровень должен быть.
3198.06 3205.58 "Анатолий Кулаков" Например, namespace, который называется Microsoft ASP.NET Core Hosting, он как раз отвечает за тот логер, который будет спамить вас запросами.
3205.58 3213.58 "Анатолий Кулаков" Если мы выставить минимум левел warning, то те входящие и выходящие запросы, которые в него придут, они логироваться не будут.
3213.58 3217.58 "Анатолий Кулаков" Ибо логируются они под уровнем information.
3217.58 3222.74 "Анатолий Кулаков" Таким образом, мы избавимся от этого спама, который выдаёт стандартный Microsoft Middleware.
3222.74 3232.98 "Анатолий Кулаков" И подключаем в это время с помощью метода useSiriLogRequestLogging серилоговский Middleware, который функционально делает то же самое, но намного приятнее и красивше.
3232.98 3240.78 "Анатолий Кулаков" Таким образом, у нас получаются входящие и выходящие логи, но с помощью другой Middleware.
3240.78 3250.50 "Анатолий Кулаков" Опять же, можно посмотреть, как он сделан, и написать, например, штуку, которая в вашей компании ведёт себя более предсказуемо, более адекватно для вашего приложения.
3250.50 3260.98 "Анатолий Кулаков" Подстроить её под себя, как бы там код абсолютно небольшой, он очень читабельный, красивый, гибкий, можно легко подстроить под себя и сделать, как вам, например, нравится.
3260.98 3261.98 "Анатолий Кулаков" Дальше.
3261.98 3267.62 "Анатолий Кулаков" Ещё есть такая великолепная штука, как Distributed Tracing, в котором, опять же, в нашем новом современном мире без неё уже никуда.
3267.62 3276.58 "Анатолий Кулаков" Поддержка серилогов, поддержка в серилоге включается с помощью отдельного пакета, который называется Serilog Tracing.
3276.58 3283.06 "Анатолий Кулаков" Для того, чтобы настроить трейсинг, это всё не то, чтобы сложно.
3283.06 3284.30 "Анатолий Кулаков" Это же делается не одним пакетом.
3284.30 3290.82 "Анатолий Кулаков" Там есть Serilog Tracing, Expressions и Instrumentations ISPNetCore, чтобы нам всё это вместе связать.
3290.82 3298.82 "Анатолий Кулаков" Все эти библиотеки независимы друг от друга и так далее, чтобы никакого каплинга не было.
3298.82 3308.62 "Анатолий Кулаков" И далее выполнить незамысловатую строчку, которая называется ActivityListenerConfiguration, инструмент ISPNetCoreRequests и TraceToSharedLogger.
3308.62 3324.30 "Анатолий Кулаков" То есть он инструментирует ISPNetCoreRequests, то есть все реквесты, которые будут порождаться внутри ISPNetCore, он будет записывать в расшаренный логгер, а в нашем случае расшаренный логгер представляет из себя серилог.
3324.30 3332.86 "Анатолий Кулаков" И таким образом мы можем поймать все те OpenTelemetry трассировки, которые у нас будут приходить и уходить.
3332.86 3337.02 "Анатолий Кулаков" И эти трассировки умеет понимать серилог.
3337.02 3343.14 "Анатолий Кулаков" Даже консольный синк серилога умеет понимать иерархические вызовы.
3343.14 3344.14 "Анатолий Кулаков" Что это значит?
3344.14 3355.14 "Анатолий Кулаков" Что у вас в консольке появится дерево из псевдографики, такое ASCII-3 дерево, как в старых фарах, если застали и пользуетесь.
3355.14 3373.26 "Анатолий Кулаков" В общем, появится дерево вызовов, в котором вы четко увидите, что здесь у вас был один спан, здесь он разделился на несколько вызовов, пошел в базу данных, тут будет другой спан, и эти спаны уже будут помечены специальным elapsed лейблом, т.е. вы можете видеть, сколько по времени каждая из этих веточек заняла.
3373.26 3387.70 "Анатолий Кулаков" Ну, в общем, это можно смотреть даже в консоли, но если вы откроете SICK, который мы настроили на предыдущем шаге, то там все будет намного красивше, там уже практически настоящий егерь рисуется с всякими веточками, с таймами, с таймаутами.
3387.70 3392.10 "Анатолий Кулаков" В общем, там поддержка трассировки у SICK на довольно хорошем уровне есть.
3392.10 3394.38 "Анатолий Кулаков" Ну, вот, в принципе, и все.
3394.38 3398.22 "Анатолий Кулаков" Как я уже говорил, ничего сложного, но есть вот такие моменты, о которых нужно знать.
3398.22 3415.02 "Анатолий Кулаков" Например, то, что логер должен создаваться с самой первой строчкой, то, что у вас все остальное должно быть в методе кетч, то, что вам обязательно нужно обработать у этого трая, и все остальное должно быть в блоке трай, конечно, что у этого трая нужно обязательно обработать кетч и нужно обязательно обработать файнали.
3415.02 3416.38 "Анатолий Кулаков" Вот это вот такие ключевые моменты.
3416.38 3427.54 "Анатолий Кулаков" Ну, и как, соответственно, переопределить микрософтовский спам, как переопределить микрософтовский логер и какие синки еще можно подключить для того, чтобы удобно было работать в вашем приложении.
3427.54 3431.50 "Игорь Лабутин" Мне кажется, получился прямо исчерпывающий гайд берешь да пользуешься.
3431.50 3439.18 "Игорь Лабутин" Дальше это допиливаете по вкусу, пишите статью, становитесь популярными, вот это все, делаете доклады на эту тему.
3439.18 3440.18 "Игорь Лабутин" Почему нет?
3440.18 3453.02 "Игорь Лабутин" Ну, на самом деле, это здорово, когда есть такой хороший гайд про то, видо "бери да пользуйся", который покроет, наверное, не знаю, 99% того, что вам нужно в обычном среднестатистическом приложении.
3453.02 3462.46 "Анатолий Кулаков" Ну да, тем более, когда такая частая тема, знаешь, как логи, трейсы, куда этот коллегин запрягать столько много терминов, всяких синков, пинков и прочего непонятного.
3462.46 3463.46 "Анатолий Кулаков" Полезная штука.
3463.46 3464.46 "Анатолий Кулаков" Ну да.
3464.46 3469.62 "Анатолий Кулаков" Поэтому за подробностями можно смело в статью Николаса там все описано более детально.
3469.62 3496.62 "Игорь Лабутин" Да, причем если раньше еще был момент, ты думаешь, ну ладно, логи-то ладно, ну как бы добавил и добавил, с логами все понятно, вот они в консольку пишутся, то с метриками и с трейсами, ну метрики, ладно, они не совсем как при сериалу, а трейсы точно про него, как Толя сказал, всегда думалось, ну окей, подключить-то я подключу, а смотреть-то и где, ну локально, это же надо поднимать все эти там егерь и егерь, ну теперь есть Aspire, куда все это можно загрузить, там все это красиво тоже будет отображаться.
3496.62 3500.02 "Игорь Лабутин" Поэтому, кстати, может и не нужен тересек сразу в Aspire?
3500.02 3505.46 "Анатолий Кулаков" Ну, опять же, у Aspire довольно сомнительная и узкая ниша, я думаю, мы об этом во время релиза поговорим.
3505.46 3516.74 "Анатолий Кулаков" То есть Aspire просто так везде не всегда засунешь, и не всем он и всегда везде нужен, нишевость у этого инструмента требует очень много дискуссий, которые, я думаю, мы и поднимем еще.
3516.74 3525.94 "Игорь Лабутин" Окей, ладно, посмотрим, опять же, как будет Microsoft его позиционировать к моменту релиза, потому что мне кажется, что сейчас они тоже пытаются осознать, что же они сделали, и для
3525.94 3526.94 "Анатолий Кулаков" чего это уже полезно.
3526.94 3536.26 "Анатолий Кулаков" Да-да, потому что он не задумался для локальной разработки, потом там всякие ажуры хелмы пошли, потом аутентификация уже пошла, как бы это при релизе не превратилось в очередной кубернетис?
3536.26 3537.26 "Анатолий Кулаков" Ну, посмотрим-посмотрим.
3537.26 3558.70 "Игорь Лабутин" Давай пойдем дальше, по тулам, еще один тул, который вообще очень мало отношений имеет к, мне кажется, дотнету и нашему подкасту, но тем не менее, все мы пишем опишки, все мы пишем опенаписпеки, по крайней мере те, кто работает, или хотя бы генерим их из кода, и поэтому, возможно, этот тул будет тоже чем-то полезен.
3558.70 3568.70 "Игорь Лабутин" Он тоже пока еще на довольно ранней стадии, его вот только-только открыли, так скажем, публике, это 25 апреля статья, но звучит интересно.
3568.70 3572.98 "Игорь Лабутин" Тул называется TypeSpec, и это не то чтобы тул, это прям новый язык.
3572.98 3578.42 "Игорь Лабутин" Мало нам языков, у нас теперь есть еще один язык для описания опишек.
3578.42 3583.78 "Анатолий Кулаков" Ну, и тут надо добавить, что это язык от самой Microsoft, это не просто так там какой-то левый пьяный чувак собрался.
3583.78 3595.86 "Игорь Лабутин" Да, значит, и называется это все, ну не то чтобы называется, посинционируется как, что это новый язык для API-centric development, то есть для разработки вокруг API.
3595.86 3602.74 "Игорь Лабутин" Давайте сначала немножко отойдем, сделаем шаг назад и поговорим вообще про то, как мы пишем API.
3602.74 3610.22 "Игорь Лабутин" Да, есть два, мне кажется, таких принципиально различных подхода к тому, как писать API.
3610.22 3651.66 "Игорь Лабутин" Подход один — это собственно Code First, да, который вы берете, пишите ваш API, возможно, как-то дополнительно размечаете ваш код, кучей дополнительных атрибутов, да, про то, что вот здесь вот там описание такое-то, а вот здесь вот возможные эррор-коды такие-то, и вот это все, после чего специальным тулом, там, Slashbuckle раньше, сейчас может еще какие-то альтернативы появились, не помню, генерите соответственно на OpenAPI-спеку, которую потом можно отдать кому угодно, вашим потребителям, фронтендерам, кто там будет использовать ваш API, они могут радостно работать с вашим API, ну, точнее, со спекой на ваш API, генерить соответственно у себя уже клиентский код, еще что-то делать.
3651.66 3663.42 "Игорь Лабутин" Если вы меняете каким-то образом код, то вы можете перегенерить соответственно API, ну, спеку имеется в виду, и отдать клиентам, они, соответственно, будут работать с вашим измененным API.
3663.42 3675.98 "Игорь Лабутин" Это подход Code First, он удобен, хорош, и много кто им пользуется, но есть альтернатива, альтернатива называется API First, и это обратный процесс.
3675.98 3680.14 "Игорь Лабутин" До того, как садиться писать код, вы садитесь и пишите спеку.
3680.14 3689.62 "Игорь Лабутин" На ямлике вот этот самый, ну, можно в JSON, OpenAPI поддерживает JSON, но руками, мне кажется, все-таки, ну, ямль писать чуть поприятнее, чем в JSON фигурные скобочки расставлять.
3689.62 3692.54 "Анатолий Кулаков" Ну, да-да, точно, ямль поприятнее будет.
3692.54 3700.74 "Игорь Лабутин" Соответственно, берете, либо спецредакторами, есть всякие онлайн там редакторы, есть экстендер для Visual Studio Code, для Visual Studio, по-моему, тоже есть, если я правильно помню.
3700.74 3705.62 "Игорь Лабутин" Короче, любыми способами пишите спеку, не написав ни строчки кода.
3705.62 3714.90 "Игорь Лабутин" Дальше из этой спеки вы можете ее сразу отдать вашим потребителям, они на основе нее могут начать писать код даже до того, как вы написали сервер, например, замоков.
3714.90 3722.14 "Игорь Лабутин" Его есть специальные отдельные тулы, которым можно скормить OpenAPI спеку, и они вам сделают такой mock-сервер на основе спеки.
3722.14 3731.08 "Игорь Лабутин" Вы же можете из этой спеки изгенерить ваши там шаблончики контроллеров, например, и наполнить их чем-нибудь, либо просто руками написать аккуратненько.
3731.08 3744.34 "Игорь Лабутин" Правда, встанет вопрос, насколько то, что вы написали соответствует спеке, которую вы до этого написали, но это отдельный вопрос, можно обсуждать, как с ним бороться, и как это можно автотестами, например, пытаться понять, насколько соответствует.
3744.34 3756.10 "Игорь Лабутин" Соответственно API First, он требует несколько большей, с моей точки зрения, дисциплины, и, наверное, побольше ресурсов в плане того, что спеку нужно написать руками.
3756.10 3779.38 "Игорь Лабутин" А спека пишется, ну, объективно не очень быстро, в том смысле, что OpenAPI вот эта яма, или даже с учетом вспомогательных всех этих тулов вокруг, но он довольно вербозный, так скажем, формат, и писать его долго, нудно, особенно если вы хотите написать хорошие API с аккуратным прописыванием всех возможных ROR-кодов, там, всех правильных типов, да, а не просто, что-то object возвращается, а иначе зачем вам спека?
3779.38 3781.62 "Игорь Лабутин" Вот это все просто время занимает.
3781.62 3794.82 "Анатолий Кулаков" Тут очень хорошо видно, что в этом OpenAPI, и даже в YAML, и даже в этом JSON формате, они шли как раз-таки от машины специфичного кода, то есть там видно, что он идеально описывает для машины.
3794.82 3801.78 "Анатолий Кулаков" Он очень многословный, он очень чёткий, там очень такая большая вложенность, большая иерархия, т.е. для машины вообще идеально.
3801.78 3805.74 "Анатолий Кулаков" Наверное, мало кто рассчитывал, что люди начнут его писать руками.
3805.74 3818.58 "Игорь Лабутин" Ну да, видимо, предполагалось, что вы будете это всё делать, не знаю, в каких-нибудь онлайн-редакторах или ещё в чём-то, но как-то вот, не знаю, я очень часто действительно пишу руками прямо YAML, не знаю почему, но копипастом в основном, конечно.
3818.58 3819.58 "Игорь Лабутин" Не прямо аккуратно.
3819.58 3820.58 "Игорь Лабутин" Не прямо аккуратно.
3820.58 3821.58 "Игорь Лабутин" Ну вот, да-да-да.
3821.58 3826.22 "Игорь Лабутин" Ну там начинаются вот такие всякие улучшения и оптимизации.
3826.22 3845.70 "Игорь Лабутин" Но в целом, я в принципе сторонник в основном API First, т.е. пожалуй, Code First я использую только в каких-нибудь таких стартап на, так скажем, ранних фазах, давайте так скажем, когда нужно просто быстро попробовать накидать какой-нибудь прототип, посмотреть, вообще оно работает, не работает.
3845.70 3878.74 "Игорь Лабутин" Но как только возникает уже, ну как только мы находимся в режиме какого-то рабочего проекта, где уже есть какие-то потребители вашего API, то здесь я сторонник подхода API First, потому что, имея спеку, вы можете её заранее согласовать, выяснить, что вы вообще не так друг друга понимали, что им нужно одно, а вы думаете другое или наоборот, вам нужно одно, а они ждут от вас совсем другого, утрясти все недопонимания, и после этого каждый пойдёт с одинаково понимаемой спекой писать свой кусочек кода, сервер-клиент, не знаю, и так далее.
3878.74 3879.74 "Анатолий Кулаков" Кого ты имеешь в виду?
3879.74 3883.58 "Анатолий Кулаков" Ты утрясаешь между двумя командами или двумя различными языками, или между кем?
3883.58 3999.54 "Игорь Лабутин" У нас в основном это команды, то есть если к нам приходит бизнес со словами "сделайте нам такую фичу, и я понимаю, что нужно там, не знаю, нам выставить API, а соседнему продукту его поиспользовать", то ну как бы я лучше сначала напишу спеку, покажу соседнему продукту, скажу "смотрите, вот для этой фичи", а к ним она тоже естественно приходит, ну это большая бизнес-штука, это несколько разных команд независимых, или даже продуктов иногда, мы делаем вот такую спеку, вы, соответственно, вот такой API по этой спеке, вы её со своей стороны будете использовать, типа "окей, окей", или наоборот, вам нужно будет дёргать наши там коллбеки, вот API спека на них, типа вас устраивает, таки "да, окей, всё поняли, всё согласовано, нам информации хватает в полях этого всего", после чего они идут писать, мы идём писать, и в принципе про языки ты тоже прав в том плане, что мне абсолютно всё равно, на чём они пишут, хотят на Java, хотят на .NET, хотят на Python, хотят на JavaScript, спека есть, ну просто реализуйте, вот, то есть у нас это сильно помогает, так скажем, ну чисто как бы согласовать API, то есть до того, как разработчики начали что-то писать, и в принципе, я-то на самом деле окей с тем, что мы что-то написали, показали, оно не такое, пошли переписывать, но некоторым разработчикам не нравится, они предпочитают "давайте мы сначала согласуем", чтобы все понимали, что мы потом, никто друг на друга пальцем не показывал, типа мы ж хотели не то, мы ж тут хотели, не знаю там, не timestamp, а какой-нибудь duration, да, в формате этого, ну ISO, кто он там, который там P, D, T, вот это всё, P0, что-то там, период который, вот, а вы нас не так поняли, короче, лучше согласуем сначала, и потом каждый пойдёт свою часть писать.
3999.54 4012.22 "Анатолий Кулаков" Тебе не кажется, что этот подход, он больше такой, более ватерфольный, более бюрократический, потому что ты сначала должен всё согласовать, а потом если вдруг идея будет более лучшей, тебе захочется поменять, то тебе надо пересогласовывать.
4012.22 4022.78 "Игорь Лабутин" Да, он более ватерфольный, но в тех масштабах продуктов, где я сейчас работаю, это неизбежное зло, вот, так скажем, т.е. по-другому просто не заработает.
4022.78 4030.58 "Анатолий Кулаков" Т.е. если у тебя одна маленькая команда, язык один, в принципе никакого API-first тебе не надо?
4030.58 4042.54 "Игорь Лабутин" Если маленькая команда, язык один, слушай, даже я на самом деле почти всегда, как только использовал Swagger, ну OpenAPI, у нас почти всегда был API-first по какой-то причине.
4042.54 4047.62 "Игорь Лабутин" То ли мы решили попробовать, то ли ещё что-то.
4047.62 4061.70 "Игорь Лабутин" Насколько будет полезен API-first в маленькой независимой команде, да, у которой там, не знаю, один человек, два человека пилит фронт-энд, два человека пилит бэк-энд, тут не знаю, у меня просто нет такого опыта, в таких маленьких не работал давно уже, поэтому не знаю, может,
4061.70 4063.46 "Анатолий Кулаков" у тебя есть опыт.
4063.46 4083.78 "Анатолий Кулаков" Да в целом мы, в принципе, и обходились без API-first, опять же, если у вас в обоих командах .NET-чики, то, как показала практика, .NET-чикам легче показать ссылку на контроллеры или на минимал API, и им глазками это гораздо легче читать, чем вот эту крёбаную портянку из OpenAPI JSON или, не дай бог, ещё и YAML.
4083.78 4090.42 "Анатолий Кулаков" А если уже у вас команды, которые пишут на разных языках, то тут вам деваться некуда, и тут вам нужен какой-то API-first.
4090.42 4096.74 "Анатолий Кулаков" И в принципе, это довольно частая ситуация, как сказал Игорь, иногда она бывает просто всегда и везде.
4096.74 4100.10 "Анатолий Кулаков" И вот здесь как раз выстреливает хорошо TypeSpec.
4100.10 4126.34 "Игорь Лабутин" Да, TypeSpec — это новый язык, причём в описании написано это new language, и следующая строчка — это more than just a new language, это прям платформа, тут блин такая фраза, майкрософтские все эти пресс-релизы, так скажем, прямо любо-дорого читать с точки зрения английского, it's a platform that enables abstraction, encourages code reuse, and leverages modern tooling for rapid development.
4126.34 4128.78 "Игорь Лабутин" Короче, быстрее, выше, сильнее.
4128.78 4131.30 "Игорь Лабутин" Чем меньше, работать будет всё быстрее.
4131.30 4133.30 "Игорь Лабутин" Значит, в чём смысл?
4133.30 4167.42 "Игорь Лабутин" TypeSpec — это штука для описания API, причём это не только про OpenAPI и не только про REST API, это просто про описание API для нескольких протоколов, так скажем, то есть эта штука совместима с OpenAPI, она совместима с JSON-схемой, она совместима с протобафом, и она, в принципе, расширяема плагинами, которые позволяют вам вообще генерировать что угодно, если у вас есть какой-то свой собственный формат API и вы хотите попробовать, можно написать свой собственный модуль расширения и компилить в этот ваш формат.
4167.42 4171.74 "Игорь Лабутин" Значит, в чём основные ключевые фичи?
4171.74 4199.62 "Игорь Лабутин" Первое — это высокоуровневый язык описания, как мы сказали, OpenAPI довольно многословен, мягко говоря, то есть такой простенький API, не знаю, на 3-4 endpoints, в принципе, легко выразиться в каких-нибудь 200 строк, потому что вы аккуратно будете описывать все объекты со всеми типами, со всеми уточнениями типов, потому что тип уже там только string, да, а дальше ты уточнишь string, но формат у него date/time, вот это всё.
4199.62 4213.66 "Игорь Лабутин" Дальше язык, который, он создан на базе TypeScript и C#, такая вот странная смесь, но тем не менее действительно похож местами на одно, местами на другое.
4213.66 4216.66 "Анатолий Кулаков" Я бы сказал, больше TypeScript, чем C#.
4216.66 4217.66 "Игорь Лабутин" Да, но…
4217.66 4225.94 "Анатолий Кулаков" Такой синтаксист, нормальный бы C#-ист вот такую глупость бы никогда в жизни не написал, атрибуты через собаку, ну где это видно?
4225.94 4236.54 "Игорь Лабутин" Не, ну да, он, и сам tool написан на TypeScript, поэтому там чувствуется, похоже, что это всё-таки пошло со стороны фронтендеров, но тем не менее, может, действительно получилось что-то интересное.
4236.54 4247.74 "Игорь Лабутин" Ну и он там супер расширяемый, туда можно допихивать, как у них написано, custom vocabularies, то есть это, конечно, чуть ли не новые ключевые слова в язык, можно с помощью плагинов расширения дописывать.
4247.74 4259.54 "Игорь Лабутин" Вот, используется сейчас пока только в Майкрософте, внутри в ажурке, ну то есть он, понятно, был внутренним тулом, в ажуре они его попользовали, видимо, получилось что-то неплохое.
4259.54 4260.54 "Игорь Лабутин" Всё это выкатили наружу.
4260.54 4291.98 "Игорь Лабутин" Для того, чтобы его попробовать, ну вам нужен Node.js, потому что это TypeScript-овый тул, по крайней мере пока, заинсталите модуль, tfpeg-компайлер и дальше там tsp_init, эта штука вам спросит несколько вопросов, типа, какой API вы пишете, там REST API, не REST API, сгенерит какой-то базовый такой шаблон, потом вы говорите tsp_install, это почти как .NET Restore, он там затянет всякие зависимости, потому что это скомпилятор, у него там есть куча всяких модулей расширений и так далее.
4291.98 4296.74 "Игорь Лабутин" Ну и дальше tsp_compile, который скомпилит ваш вот этот вот код в что-нибудь.
4296.74 4303.30 "Игорь Лабутин" Значит, рассказывать это всё как-то голосом не очень здорово, в том плане, что на это надо, конечно, смотреть.
4303.30 4310.90 "Игорь Лабутин" У них есть хороший playground, всё это живёт на сайте typespec.io, и там есть playground, где есть прям готовые примерчики уже заполненные.
4310.90 4320.14 "Игорь Лабутин" Ну и вот я так поигрался немножко, и прикольно, что такой вот 200 примерно строчный open API спека, развесистый и так далее.
4320.14 4334.66 "Игорь Лабутин" Дело даже не только в количестве строк, дело в том, что за счёт вот этого очень веробозности очень сложно иногда охватить одним взглядом, ну то есть любой маломальски сложный объект из, там, не знаю, 10-15 полей он уже не влезает в экран, если каждое поле аккуратно описано со всеми типами и всем добром.
4334.66 4338.78 "Игорь Лабутин" А если ещё какие-нибудь атрибуты навешаны, так вообще.
4338.78 4340.98 "Игорь Лабутин" Здесь это всё умещается в 26 строчек.
4340.98 4349.14 "Игорь Лабутин" Ну как бы в 8 раз экономия, понятно, что это не универсальная константа, где-то будет может быть в 3 раза, где-то может быть в 20, я не знаю.
4349.14 4364.02 "Игорь Лабутин" Но выглядит интересно, и я думаю, что может быть в каком-нибудь проекте, может быть даже попробую, где что-нибудь не очень критичное будет, попробую набросать API, где я писал бы её в ямлике, попробую написать на этой штуке и скомпилить в ямли, посмотрим,
4364.02 4365.02 UNKNOWN что получится.
4365.02 4371.66 "Анатолий Кулаков" Не знаю, я вот глядя на этот синтаксис, даже про табов кажется не таким ужасным после такого, что они изобрели.
4371.66 4375.78 "Игорь Лабутин" Ну интересно, интересно, тэп-скриптёры, видимо, изобретали.
4375.78 4376.78 "Анатолий Кулаков" Я не знаю.
4376.78 4381.54 "Анатолий Кулаков" Ну то есть идея хорошая, блин, но реализация, ну кто ж в 21 веке такие глупости пишет.
4381.54 4386.98 "Игорь Лабутин" Ну как, custom vocabulary, пишем, называется c-sharp way и вот это всё.
4386.98 4387.98 "Игорь Лабутин" И нормально.
4387.98 4393.42 "Анатолий Кулаков" Надо попробовать, да, действительно, затестить, значит, насколько он гибок и насколько он расширяем.
4393.42 4394.42 "Игорь Лабутин" Да, да.
4394.42 4398.66 "Игорь Лабутин" Ну так интересно, да, если пишите много API-шек, посмотрите, может быть действительно найдёт.
4398.66 4410.58 "Анатолий Кулаков" Ну опять же, да, если мы говорим про подход API-фиос, то мне кажется, это вообще лучший выход, который есть на рынке, потому что иначе люди в ямли писали, и по сравнению с ямлом, это манна небесная.
4410.58 4411.58 "Игорь Лабутин" Да.
4411.58 4417.34 "Игорь Лабутин" Ну вопрос ещё качества OpenAPI-спеки, который он генерирует, насколько она полная, да, если вы там прямо подробно расписываете.
4417.34 4425.14 "Игорь Лабутин" То есть может быть, и чтобы получить хорошую такой же степень подробности OpenAPI-спеки, которую написали бы вы руками, и код будет уже не 26 строчек, а 50-70.
4425.14 4427.98 "Игорь Лабутин" Ну с другой стороны, всё равно приятнее.
4427.98 4432.22 "Анатолий Кулаков" Ну хочется верить, что Microsoft в Ажуре как бы протестил всё это за нас.
4432.22 4433.22 "Анатолий Кулаков" Да, наверное.
4433.22 4434.62 "Анатолий Кулаков" И основные грабли он уже должен был съесть.
4434.62 4435.62 "Игорь Лабутин" Да.
4435.62 4436.78 "Игорь Лабутин" Давай дальше, следующий тул.
4436.78 4452.86 "Анатолий Кулаков" Почему бы и нет, выпуск тулов, и сегодня мне хотелось бы с вами познакомить, опять же, тоже с тулом, которых существует на рынке много, наверное, как и с предыдущим, но на дотнете мы переписали свой, почему бы и нет.
4452.86 4466.38 "Игорь Лабутин" Ну вот как раз, мне кажется, по отношению к предыдущих, я не знаю сильно много тулов, которые позволяют на чём-то таком, хотя бы тейпскриптоподобном, писать спеку, кроме как ямль напрямую, я чё-то как-то не встречал, может быть,
4466.38 4470.74 "Анатолий Кулаков" я по крайней мере на Маркдауне видел, и там оно смотрится довольно нормально.
4470.74 4472.50 "Игорь Лабутин" Не видел, не видел.
4472.50 4484.26 "Анатолий Кулаков" Но я уверен, что должно быть намного больше, потому что идея на поверхности, опять же, кривой какой-то язык видеть Джессона, и надо туда во что-то в него сконвертить нормальный человек, отчитабельное
4484.26 4485.26 "Игорь Лабутин" что-то.
4485.26 4491.26 "Игорь Лабутин" Ну ладно, посмотрим про OpenAPI, вернёмся к Маркдауну, потому что здесь Маркдаун как раз будет в тему, мне
4491.26 4492.26 "Анатолий Кулаков" кажется.
4492.26 4514.82 "Анатолий Кулаков" Здесь есть статейка, которая называется ADR, и давно хотелось вам рассказать про ADR, но как-то не подворачивалось оно под наш формат, а здесь внезапно вышла тулза, которая умеет управлять ADR, и эта тулза написана на дотнете, но этого достаточно для того, чтобы попасть к нам в подкаст, и для того, чтобы обсудить вообще, что такое ADR.
4514.82 4515.82 "Анатолий Кулаков" Давайте с этого и начнём.
4515.82 4516.82 "Анатолий Кулаков" А что же такое ADR?
4516.82 4527.12 "Анатолий Кулаков" ADR – это Architectural Decision Records, то есть это специальные записи, которые вам позволяют рассказать о том, каким же образом было принято то или иное решение.
4527.12 4541.50 "Анатолий Кулаков" Обычно эти рекорды представляют собой примитивные файлики, обычно их складывают в репозиторий с вашим кодом, чтобы они не расходились с кодом, а также версионировались, ревьювились и так далее, всё, что нужно с кодом.
4541.50 4551.24 "Анатолий Кулаков" И обычно в современном мире эти файлики представляют собой Markdown файлы, потому что он хорошо зарекомендовал себя именно для такой легковесной, быстрой и красивой документации.
4551.24 4565.34 "Анатолий Кулаков" В этих файликах часто записывают контекст того, как было принято то или иное решение, какие варианты были рассмотрены и какие последствия этого решения у нас будут в программе.
4565.34 4575.18 "Анатолий Кулаков" И статья начинается с того, что, в принципе, ребята изобрели новый инструмент, Global Tool, который называется .NET ADR.
4575.18 4580.54 "Анатолий Кулаков" Таких инструментов на рынке миллион, но .NET, кажется, ещё не было.
4580.54 4595.94 "Анатолий Кулаков" В общем, этот инструмент не сильно сложный, он всего лишь навсего позволяет вам создавать эти файлики из каких-то шаблонов, а также манипулировать ими, можно создать, как-нибудь обновить, удалить, чтобы у них номера не поехали и такие банальные действия с файликами делать.
4595.94 4603.74 "Анатолий Кулаков" Вот, в принципе, и вся функциональность, которую только можно такие инструменты предоставлять, но некоторым удобно, почему бы и нет.
4603.74 4612.06 "Анатолий Кулаков" Если вам нужен такой инструмент, вы просто можете пользоваться обычными текстовыми редакторами, которые умеют открывать папочки и создавать там файлики, ну, то есть просто любыми.
4612.06 4619.18 "Анатолий Кулаков" Давайте тогда подробнее разберёмся, зачем же всё-таки вообще нужны эти АДРы.
4619.18 4633.46 "Анатолий Кулаков" Существует такое мнение, что когда у нас есть код, то есть когда код, который мы написали, он выражает именно то, что разработчик хотел запрограммировать, то есть какой алгоритм он хотел запрограммировать, в каком виде он это хотел сделать.
4633.46 4643.54 "Анатолий Кулаков" Но мы теряем контекст, а почему он это хотел сделать, почему он выбрал именно такое решение, какие другие решения он рассматривал, чем они ему не подошли.
4643.54 4657.62 "Анатолий Кулаков" В принципе, в одном моменте, если мы на наш код смотрим, то это не такая уж и большая проблема, но если мы возвращаемся вдруг через год к этому куску кода и думаем его отрефакторить, то перед нами сразу встают вопросы.
4657.62 4673.78 "Анатолий Кулаков" Если мы отрефакторим, что упадёт, какие алгоритмы на этот код рассчитывали, какие сервисы сюда приходили, почему была выбрана именно такая стратегия, а не другая, может быть, гораздо более очевидная, гораздо более прямая, может быть, какие-то конфликты с другими версиями, другие библиотеки у него были.
4673.78 4680.70 "Анатолий Кулаков" Обо всем этом мы не знаем абсолютно, мы видим, что код написан, и допустим, он даже работает правильно, это окей.
4680.70 4687.98 "Анатолий Кулаков" Но как мы можем его переписать, какие причины были для того, чтобы именно так это реализовать, ничего это нам не известно.
4688.58 4695.50 "Анатолий Кулаков" И до появления АДР у нас не существовало такого артефакта, который нам способен был бы объяснить эту информацию.
4695.50 4702.30 "Анатолий Кулаков" То есть где грань между тем, чтобы нам поставили какое-то техническое задание, и в конце мы получили реализацию этого задания.
4702.30 4709.06 "Анатолий Кулаков" А между ними, вот как мы пришли к этой реализации, вот это была большая чёрная дыра.
4709.06 4711.98 "Анатолий Кулаков" И вот АДР попытались эту дыру как раз-таки заполнить.
4711.98 4722.62 "Анатолий Кулаков" Опять же, как я уже сказал, это обычно простые файлики в виде маркдауна, которые лежат в папочке с какой-нибудь документацией.
4722.62 4729.14 "Анатолий Кулаков" И современные разработчики пришли к тому, что удобно это класть именно в репозиторий.
4729.14 4732.06 "Анатолий Кулаков" Там создаете папочку "docs", в ней папочку "ADR" и туда всё складываете.
4732.06 4745.24 "Анатолий Кулаков" Нумерируете в зависимости от ваших предпочтений датой или порядковым номером, и там подробно описываете, как вы пришли к такой жизни, что в АДРе конкретно рекомендуется описывать.
4745.24 4756.34 "Анатолий Кулаков" В принципе, это полностью зависит от шаблона, шаблонов миллион разных, разные умные дядьки бородатые рекомендуют что-то своё, но в общем концепция делится на несколько частей.
4756.34 4763.62 "Анатолий Кулаков" Во-первых, вы там не должны вскатываться в какую-то мегаформальную, мегабольшую, мегаобязательную документацию.
4763.62 4767.94 "Анатолий Кулаков" У вас там не должны расписываться какие-то огромные проспекты.
4767.94 4775.14 "Анатолий Кулаков" Иначе это никто не будет читать, это будет в конце концов лень кому-то писать, и вы в конце концов забьёте.
4775.14 4791.90 "Анатолий Кулаков" Поэтому основной подход в том, что вы пишите простыми словами хотя бы одно-два предложения, но написать краткость намного лучше, чем не сделать ничего, но при этом захотеть это расписать очень большими и замысловатыми словами.
4791.90 4797.46 "Анатолий Кулаков" Поэтому одно-два предложения в каждом пункте, и это будет уже более-менее нормальный АДР.
4797.46 4801.34 "Анатолий Кулаков" Если вы хотите больше, конечно, никто вам не мешает, пишите больше.
4801.34 4802.34 "Анатолий Кулаков" Итак, что же там должно быть?
4802.34 4804.46 "Анатолий Кулаков" Ну, прежде всего, какое-нибудь название.
4804.46 4807.58 "Анатолий Кулаков" К чему вы этот АДР относите?
4807.58 4812.42 "Анатолий Кулаков" Например, почему мы выбрали System Text JSON Serializer, а не какой-то другой сериалайзер?
4812.42 4814.78 "Анатолий Кулаков" И дальше пошли расписывать.
4814.78 4816.42 "Анатолий Кулаков" Также очень часто добавляют статус.
4816.42 4822.70 "Анатолий Кулаков" У АДРов бывают статусы в написании, в ревью, в рассмотрении применён.
4822.70 4826.54 "Анатолий Кулаков" Когда вы уже применили это в вашем коде, вот вон зафиксирован АДР.
4826.54 4841.42 "Анатолий Кулаков" А также у вас там есть какой-то контекст, в котором вы должны описать какие-то предположения, типа «Я предполагаю, что ко мне будут приходить JSON-документы, не больше такого-то размера, не больше такой-то вложенности».
4841.42 4847.94 "Анатолий Кулаков" И, в общем, какие-то предположения о том, зачем вы вообще реализовываете, допустим, такой сериализатор, почему вы используете именно него.
4847.94 4851.06 "Анатолий Кулаков" Дальше желательно рассмотреть опции, какие у вас были.
4851.06 4864.46 "Анатолий Кулаков" Выбрать System Text JSON Serializer, выбрать Newton Soft JSON Serializer, выбрать свой собственный сериализатор, рассмотреть может быть вообще не JSON-протокол, если это позволяет другая сторона, с которой вы обмениваетесь этими данными.
4864.46 4866.26 "Анатолий Кулаков" В общем, расписать опции.
4866.26 4869.54 "Анатолий Кулаков" И у каждой из этих опций желательно выделить плюсы и минусы.
4869.54 4872.86 "Анатолий Кулаков" То есть, почему вам то это подходит, а то не подходит.
4872.86 4875.74 "Анатолий Кулаков" Это вы рассмотрели, а вот это не рассмотрели.
4875.74 4891.74 "Анатолий Кулаков" Таким образом, прочитав этот документ, вы примерно понимаете, какой контекст был, почему мы вообще столкнулись с этой проблемой, какие опции перед нами стояли, какие условия перед нами у нас были, и как мы пришли ввеси все плюсы и минусы, пришли к тому или иному решению.
4891.74 4896.22 "Анатолий Кулаков" Но опять же, нужно зафиксировать решение, которое вы приняли, и почему вы его приняли.
4896.22 4900.14 "Анатолий Кулаков" Также желательно рассказать о том, а какие последствия у этого решения будут.
4900.14 4910.22 "Анатолий Кулаков" То есть, нам нужно переписать всю кодовую базу, или мы можем сделать какую-нибудь проксик, или мы сделаем какую-нибудь оберточку, которая позволит это внедрить амбишовно, и так далее, и так далее.
4910.22 4915.90 "Анатолий Кулаков" То есть, какие последствия для вашей кодовой базы вы примерно подразумеваете будут после принятия вами этого решения.
4915.90 4919.94 "Анатолий Кулаков" Вот примерно в таких пунктах это все описывается.
4919.94 4931.30 "Анатолий Кулаков" Опять же, каждая команда обычно под себя все эти пункты переделывает, какие-то дополнения под себя делает, но за основу можно взять вот какие-то стандартные шаблоны, которые уже на рынке существуют.
4931.30 4936.30 "Анатолий Кулаков" Даже бывает так, что это зависит не от команды, а от проектов.
4936.30 4938.30 "Анатолий Кулаков" Потому что на самом деле и проекты у всех разные.
4938.30 4948.34 "Анатолий Кулаков" В каких-то проектах больше ресерча, в каких-то проектах больше общения с кастомеров, у каких-то проектов чисто технический, там нужен просто какой-нибудь архитектор, который и так все знает, как делать.
4948.34 4956.54 "Анатолий Кулаков" В общем, и в зависимости от того, в каком проекте вы пишете ADR, там тоже формат может вполне меняться, почему бы и нет.
4956.54 4958.66 "Анатолий Кулаков" Зачем же понадобился все-таки отдельный тул?
4958.66 4961.86 "Анатолий Кулаков" Не просто, чтобы переписать на дотнет и пусть будет.
4961.86 4965.34 "Анатолий Кулаков" В общем, это довольно такая цель примитивная.
4965.34 4969.30 "Анатолий Кулаков" Здесь у ребят было более глобальное видение.
4969.30 4981.58 "Анатолий Кулаков" Все существующие ADR-тулы, как я уже сказал, это какая-нибудь обычная консольная инструмента, которая умеет создавать документы из темплейта и каким-то образом минимально работать с файлами.
4981.58 4986.06 "Анатолий Кулаков" В общем, все эти тулы были плотно завязаны на какой-то конкретный шаблон.
4986.06 4990.26 "Анатолий Кулаков" То есть у них этот шаблон был выбит просто гвоздями обычно.
4990.26 4993.82 "Анатолий Кулаков" А если они не поддерживали какие-то вариации, то это довольно примитивная такая поддержка была.
4993.82 5005.18 "Анатолий Кулаков" Автор сказал, что в принципе даже в одном проекте в одной команде они сменили десяток темплейтов, пока нашли тот, который идеально подходит конкретно к их ситуации.
5005.18 5009.82 "Анатолий Кулаков" И кажется, что это действительно такой правильный кейс.
5009.82 5017.18 "Анатолий Кулаков" То есть не стараться заложиться на что-то конкретное, выбитое в камни, а взять какой-то стандарт и попытаться переделать его под себя.
5017.18 5022.62 "Анатолий Кулаков" Даже не просто один раз переделать, а все время, пока живет проект, переделывать, пока вы не поймаете тот самый дзен.
5022.62 5033.14 "Анатолий Кулаков" И вот авторы вот этого нового .NET Tool, .NET ADR, они четко разделили сам инструмент от тех шаблонов, которые он может генерить.
5033.14 5040.06 "Анатолий Кулаков" Потому что в принципе самая технически сложная часть данной тулы – это именно работа с шаблонами.
5040.06 5043.46 "Анатолий Кулаков" Все остальное, перемещение файликов и так далее, делает вам любой фарм-менеджер.
5043.46 5048.10 "Анатолий Кулаков" А вот шаблоны, да, здесь уже может быть какая-то логика.
5048.10 5054.06 "Анатолий Кулаков" Поэтому здесь они четко разделили сам инструмент и отдельно они приняли за факт, что шаблонов может быть много.
5054.06 5056.72 "Анатолий Кулаков" Они могут быть разные, и у всех команд свои, и у всех проектов свои.
5056.72 5060.62 "Анатолий Кулаков" И поэтому они даже выделили схему дистрибьюции с помощью Nuget.
5060.62 5066.14 "Анатолий Кулаков" То есть, вы можете в Nuget опубликовать какой-то пакет и сказать, вот сегодня, сейчас это наш шаблон, мы юзаем его.
5066.14 5070.66 "Анатолий Кулаков" И это отразилось на, в принципе, синтаксисе самой команды, то есть как вы с ней работаете.
5070.66 5079.58 "Анатолий Кулаков" Прежде всего, раз это глобальный .NET Tool, мы должны установить командой .NET Tool install -global ADR.
5079.58 5091.18 "Анатолий Кулаков" Дальше просто вызываете команду ADR пробел templates set и устанавливаете имя темплейта, то есть имя, по сути, пакета, который будет считаться у вас сейчас текущим темплейтом на данный момент.
5091.18 5098.90 "Анатолий Кулаков" Дальше все просто, ADR new title, и это создаст вам из текущего темплейта новый ADRчик.
5098.90 5107.34 "Анатолий Кулаков" Положит его в нужную папочку, правильно назовет, сформирует нужные секции, в эти секции, может быть, там напишет какие-то заглушки, какие-то шаблоны, которые помогут вам развить мысль.
5107.34 5109.46 "Анатолий Кулаков" И на этом его задача закончена.
5109.46 5118.30 "Анатолий Кулаков" В качестве настройки, опять же, вы можете настроить, создать файл adr.config.json, например, настроить путь, а где ваши эти файлики лежат.
5118.30 5120.78 "Анатолий Кулаков" Как я уже говорил, лучше их складывать прямо в том же самом репозитории.
5120.78 5126.06 "Анатолий Кулаков" В общем, и путь до папочки в этом же самом репозитории легко настраивается.
5126.06 5129.22 "Анатолий Кулаков" Какие шаблоны можно взять за основу?
5129.22 5138.46 "Анатолий Кулаков" Как я уже говорил, существует в мире очень много шаблонов, существуют очень авторитетные авторы, очень авторитетные проекты, где есть АДРки.
5138.46 5145.94 "Анатолий Кулаков" Их сложно описать словами, как-нибудь четко, но очень просто посмотреть.
5145.94 5155.54 "Анатолий Кулаков" Когда вы их увидите, вы сразу поймете, что люди пишут, в каких случаях они что-то описывают, в каких случаях не описывают, что скипают, что стараются уточнить и так далее.
5155.54 5161.10 "Анатолий Кулаков" Легче всего выбрать какой-нибудь проект, который ближе подходит к вам, и прямо на конкретном этом проекте посмотреть.
5161.10 5169.58 "Анатолий Кулаков" Поэтому в статье даются ссылки на известные open source проекты, которые используют АДРки, и они лежат прямо в репозитории, соответственно, можно посмотреть.
5169.58 5181.54 "Анатолий Кулаков" Есть темплейты, выданные из книг бородатых архитекторов 70-х годов, они тоже пользовались такими штуками, они тоже советуют какие-то шаблоны, можно к ним пойти.
5181.54 5193.26 "Анатолий Кулаков" Есть прямо по кейсам, есть, например, бизнес-кейс-паттерн, когда вы работаете очень много с какими-нибудь бизнес-отделом, и как-то вам с ними надо коммуницировать, и это все каким-то образом фиксировать.
5193.26 5201.02 "Анатолий Кулаков" Есть очень стандартный шаблон, который называется Markdown, Decision Record, Mother сокращенно, это, наверное, один из самых популярных шаблонов.
5201.02 5211.58 "Анатолий Кулаков" Вот, есть еще один замечательный шаблон, который называется Merson pattern, я его выделил только потому, что можно было спутать с великолепным Мерсоном, но это не он написал.
5211.58 5227.36 "Анатолий Кулаков" И, естественно, вы можете взять их и на их основе создать свой собственный шаблон, опубликовать это в GetPacket, и дальше использовать с помощью этого инструмента в вашей повседневной работе.
5227.36 5247.58 "Анатолий Кулаков" Ну, и как утверждают авторы, что если вы вдруг хотите в вашу команду, в ваш бизнес-процесс, в процесс разработки внести какое-то маленькое изменение, которое даст вам самый огромный профит, который только возможен из этого маленького изменения, то ADR-ка – это, скорее всего, первое, что вы должны попробовать.
5247.58 5259.56 "Анатолий Кулаков" Вполне вероятно, что это будет просто геймчетч для вашего проекта, и уж точно будущие вы скажете огромное-огромное спасибо вашему прошлому, если вы будете начнете писать такие ADR-ки.
5259.56 5272.74 "Анатолий Кулаков" Действительно, они помогают, может быть, не так часто, может быть, редко, когда вы возвращаетесь к какому-то куску и хотите понять, какого черта творилось в голове у автора, когда он это все выдумывал, писал и реализовал, но зато очень метко.
5272.74 5277.78 "Анатолий Кулаков" То есть, когда у вас такой документ есть, то любой рефактор превращается просто в конфетку.
5277.78 5299.70 "Анатолий Кулаков" Вы понимаете, зачем это было сделано, что рассмотрели, что забыли рассмотреть, какие плюсы-минусы учитывали, и можете предложить новые решения, которые уже в текущем контексте гораздо более выгодно или более производительно, или более гибко, или обладают какими-то другими плюсами, которые в текущем контексте перевешивают все другие опции, которые у вас были до того.
5299.70 5302.46 "Анатолий Кулаков" Вот такие полезные документики.
5302.46 5307.46 "Игорь Лабутин" Да, я еще хочу предупредить, предостеречь, не знаю.
5307.46 5331.06 "Игорь Лабутин" Короче сказать, следующую штуку, что если вы будете смотреть примеры в интернете, того, как пишут АДР, или в каких-нибудь модельных примерах, или даже может быть в реальных проектах, вы можете наткнуться на АДР, где будет два экрана текста, описание, почему мы делали, что мы делали, какие альтернативы мы рассматривали, и может показаться, что ровно так же нужно писать у вас.
5331.06 5332.90 "Игорь Лабутин" Это не совсем так.
5332.90 5345.74 "Игорь Лабутин" Если у вас есть что написать такого объема, конечно, пишите, если вы действительно сделали какую-то большую работу, провели какой-то ресерч и выбрали по результатам, ну например, библиотеку, тул, подход, ну все что угодно, конечно, опишите.
5345.74 5354.66 "Игорь Лабутин" Но даже если вы просто, не знаю, собрались в переговорки, подумали и сказали, будем пользоваться систем.текст.json, потому что всем нравится, да, то так и запишите.
5354.66 5391.74 "Игорь Лабутин" Ну то есть одно предложение, но хотя бы вы там через два года, когда будете вспоминать, почему мы так сделали, вы не будете пытаться понять, интересно, был ли какой-то ресерч, или может быть даже не вы, а какая-то другая команда, которая будет за вами, или даже если пол команды сменится, уже информация поменяется, в смысле забудется, то даже такая запись про то, что ну мы выбрали потому, что нам казалось, что прикольно, это в принципе тоже аргумент, просто сейчас возможно нужно сменить приоритеты и уже выбирать не потому, что прикольно, а там, что держит нагрузку или там не знаю, что обладает нужной гибкостью, кастомизируемостью и так далее.
5391.74 5400.74 "Игорь Лабутин" Поэтому любую информацию, пусть даже в каждом вот этом разделе, там 5-6 в простейших АДРах, будет по одной-двум строчкам, уже прикольно, уже хорошо.
5400.74 5410.22 "Анатолий Кулаков" Может именно поэтому нет какого-то единого формализованного стандарта, потому что всё-таки каждая команда в том числе выбирает уровень детализации под себя.
5410.22 5411.22 "Игорь Лабутин" Да-да-да.
5411.22 5422.54 "Игорь Лабутин" Ну я скорее про то, что даже не столько вот уровень детализации, там же обязательно стополей 2, по-моему, насколько я помню, это тайтл и статус, типа о чём и как бы принято или не принято.
5422.54 5429.42 "Игорь Лабутин" То есть даже заполнив эти парочку про то, что выбрали системный текст JSON, потому что сказал так Вася, всё отлично.
5429.42 5435.42 "Игорь Лабутин" Нормальная в принципе аргументация, если на тот момент вам было достаточно этого аргумента, чтобы это выбрать, ну окей, так и запишите.
5435.42 5436.42 "Анатолий Кулаков" Такое решение.
5436.42 5437.90 "Анатолий Кулаков" Да, хотя бы знаем, кого теперь бить.
5437.90 5443.26 "Игорь Лабутин" Да, не надо выдумывать длинные двухстраничные тексты про то, что мы долго анализировали, а потом пришёл Вася и сказал.
5443.26 5446.82 "Игорь Лабутин" В принципе.
5446.82 5450.30 "Игорь Лабутин" Пишите просто краткую суть того, что произошло и почему.
5450.30 5451.30 "Игорь Лабутин" Вот, отлично.
5451.30 5458.82 "Игорь Лабутин" Давай пойдём дальше, у нас собственно осталось кратко о разном, там есть тоже несколько интересных моментов.
5458.82 5463.90 "Игорь Лабутин" Давай сначала расскажу те, которые я отрыл, а потом ты добавишь своих.
5463.90 5544.78 "Игорь Лабутин" Во-первых, вышло, хотел сказать интервью, но нет, это не интервью, это ролик, где основной автор, основной докладчик, это Стивен Тауб, это уже, так сказать, добавляет плюсов к тому, чтобы его посмотреть, второй партнер его это Скотт Хансельман, и они вдвоём обсуждают, как устроен линк Ю изнутри, ну как обсуждают Стивен Тауб, постоянно на протяжении всего ролика, он час длится, если я правильно помню, шарит свою Visual Studio и аккуратненько, не спеша, под разговоры, потихонечку реализует свой собственный линк, ну примерно так же, как реализован в реальной жизни, показывая по пути, что за оптимизацией там используется, как это всё построено, причём довольно, ну всякие нетривиальные штуки показывает, так что если вам интересно, как устроен линк Ю, как в принципе думают внутри, так скажем, разработчики дотнета, да, на какие моменты они смотрят, как это всё оптимизируется, возможно, какие-то идеи вы почерпнёте для своего кода, посмотрите, в принципе, смотрится довольно неплохо, ну хорошо, я с интересом послушал какие-то моменты, где-то приматовые, конечно, но в целом звучит интересно.
5544.78 5559.50 "Игорь Лабутин" Называется это всё DeeperDive, у них была первая часть, которая называлась, по-моему, DeepDive, если я правильно помню, теперь вторая часть называется DeeperDive, вот, так что вторая часть, на мой взгляд, поинтереснее, чем первая, хотя первая тоже была интересной мыслью.
5559.50 5600.22 "Игорь Лабутин" Вторая часть, вторая статья, точнее, которая мне попалась, тоже интересная, я планирую попробовать, если вы пишете на SPNetCore, используете Razer и всё такое, и вам иногда хочется запихнуть какую-нибудь JavaScript-овую штуку, то в статье как раз показано, как это всё совместить ещё и со Shtmx, вот, и такое, я как-то не приходил в голову Razer совмещать со Shtmx, вот, если вам вдруг зачем-то это потребовалось, или вы хотите посмотреть, зачем это может потребоваться, загляните в статью, там довольно неплохо хорошим примером показано, как они Chart.js запихнули в Razer Prages, по-моему, с Shtmx.
5600.22 5605.58 "Анатолий Кулаков" Слушай, но прежде всего мы ни разу ещё не упоминали о Shtmx, можно рассказать, что это такое?
5605.58 5610.02 "Игорь Лабутин" Да, это такой, ну как сказать, не шаблонизатор.
5610.02 5620.66 "Анатолий Кулаков" Я бы сказал, что это, смотри, расширение Shtml, который позволяет вам в очень частых кейсах не использовать JavaScript, когда в обычной жизни вам пришлось бы это делать.
5620.66 5632.46 "Анатолий Кулаков" То есть это, скорее всего, выдуманная штука бэкендерами, которые хотят немножко выкинуть JavaScript из Shtml и больше как раз делать на бэкенде, чем на фронт-энде.
5632.46 5637.26 "Игорь Лабутин" Ну слушай, Razer же тоже этим занимается, Razer такой типичный шаблонизатор, не так ли?
5637.26 5648.50 "Анатолий Кулаков" Razer, да, но как-то Razer это делает грубее, тебе пришлось там кучу технологий ввести, куча там Shadow DOM-ов, куча Signal Air-ов, ну в общем, это как бы из пушки по воробьям, да.
5648.50 5654.50 "Анатолий Кулаков" Но в общем, он намного тоньше, то есть там есть небольшая прослойочка на JavaScript и она делает там примитивные вещи.
5654.50 5670.42 "Анатолий Кулаков" Ну, например, если вы хотите послать на сервер какой-то запрос, то с помощью обычного Shtml вы это можете там сделать с помощью или там банального где-то, если по ссылке кликнете, или по форме кликните button, это вам обязательно будет какой-нибудь пост.
5670.42 5676.62 "Анатолий Кулаков" В общем, все это как-то слишком сильно забито костылями и ограничено, ну, например, вы не можете никак сделать put.
5676.62 5683.06 "Анатолий Кулаков" А с помощью Shtmx он вам позволяет любой верб присобачить к абсолютно любому элементу.
5683.06 5693.30 "Анатолий Кулаков" Вы можете там кликнуть на кнопки и удёрнуть у сервера get, при том этот сервер на get вам может отдать какие-то данные, которые вы тут же можете у себя в страничку вставить, допустим.
5693.30 5698.70 "Анатолий Кулаков" И всё это делается с помощью там 1 или 2 буквально атрибутов у каждого Shtml-тяга.
5698.70 5699.70 "Анатолий Кулаков" Ну да.
5699.70 5703.58 "Анатолий Кулаков" И такими вот банальными атрибутиками вы можете нагенерить довольно сложные приложения.
5703.58 5721.62 "Игорь Лабутин" Ну да, то есть я действительно, шаблонизатор неправильное слово, но там действительно по сути вы к Shtml-тягам добавляете гору, ну не гору на самом деле, да, небольшое количество вот этих атрибутиков от Shtmx, и оно магическим образом заводится, становится таким, слегка динамичным.
5721.62 5739.22 "Анатолий Кулаков" То есть по идее, если бы человечество двинулось не в сторону развития ржавого скрипта, а в сторону развития Shtml, как более такого функционального, более мощного языка, как в сторону развития гипермедиаленгвидия, как он и должен был бы быть, то вот примерно из него должно было бы что-то получиться, что нам дает Shtmx.
5739.22 5750.02 "Анатолий Кулаков" В общем, даже если вы его не видели, то есть не хотите пользоваться, просто посмотрите, во что мог бы превратиться Shtml без JavaScript, что у вас есть бекендеры, у вас есть верстальчики.
5750.02 5759.86 "Анатолий Кулаков" Всё, вот эта ненужная прослойка в виде макак с JavaScript, они не нужны по сути для, опять же, какого-то подмножества приложений, которых не так уж и мало, как кажется.
5759.86 5764.38 "Игорь Лабутин" Да, не для всего нужен полноценный React, там Angular, Vue или кто-нибудь такой SPA.
5764.38 5787.94 "Игорь Лабутин" Так, давай дальше, дальше у нас опять новость про .NET и Ubuntu, мы уже упоминали, по-моему, в выпуск назад или даже два выпуска назад про то, что Canonical теперь собирается собирать целиком всё сам, вот это всё сам .NET, самостоятельно, без помощи Microsoft из исходников.
5787.94 5833.30 "Игорь Лабутин" Вот в конце апреля произошло значимое событие, во-первых, эта передача таки полностью состоялась, т.е. теперь все дистрибутивы .NET, которые входят в каноне в Ubuntu и в RedHat, соответственно, собираются самими, Canonical и RedHat, соответственно, и, видимо, под эту тему 25 апреля, когда релизилась, собственно, Ubuntu 24.04, вышла статья в блоге Microsoft про то, что .NET теперь полностью доступен в Ubuntu, абсолютно независимо в каком-то смысле от Microsoft, т.е. вам теперь не нужно в AppGate или где вы там это делаете добавлять новый фид в виде packages.microsoft.com, это всё теперь официально доступно в самом Ubuntu-вском основном фиде.
5833.30 5862.22 "Игорь Лабутин" Это с одной стороны, а с другой стороны они настолько здорово синтегрировались с Microsoft, ну, синтегрировались или отделились, тут уж как посмотреть, что Microsoft всякие security и feature-патчи отдаёт теперь им тоже чуть-чуть заранее, ну, через какие-то приватные каналы, грубо говоря, чтобы они могли тоже у себя всё пересобрать, протестировать, так чтобы все security и прочие патчи выходили одновременно и в официальных майкрософтских каналах и в Ubuntu и RedHat вместе.
5862.22 5884.14 "Игорь Лабутин" Так что теперь, ну, дело движется к тому, чтобы .NET был прям таким полноценным, правильным open-source, я не знаю, пакетом, который правильно собирается из исходников и, глядишь, в какой-то момент даже в Debian включат, где несколько, насколько я помню, более строгие правила вхождения в основной фид.
5884.14 5894.22 "Игорь Лабутин" Такие дела, поэтому если вы пользуетесь дотой на этом на Ubuntu, можете теперь бодренько ставить из основного репозитория, ну, если вы, понятно, на последнюю Ubuntu.
5894.22 5903.30 "Игорь Лабутин" Вот, и последняя тоже новость, которую я буквально что-то нарыл, пока я вам пишу подкаст, это про Xamarin.
5903.30 5915.18 "Игорь Лабутин" Мы много раз обсуждали Xamarin, потом мы стали обсуждать MAUI, и Xamarin как-то подзабили, потому что понятно, что все должны быть на MAUI, вот это всё, ну, Microsoft по крайней мере так считает, не факт, что мы с этим согласны.
5915.18 5943.14 "Игорь Лабутин" Так вот, 1 мая закончился support Xamarin Microsoft, и, ну, грубо говоря, у нас есть много разных технологий, у которых support закончился, но здесь в момент окончания support Microsoft аккуратно заархивировал GitHub-репозиторий Xamarin, и поэтому теперь Xamarin совсем всё, GitHub-репозиторий заархивированы, ishu писать теперь некуда, вот это всё такое, пользуйтесь теперь только MAUI.
5943.14 5945.58 "Игорь Лабутин" Ну, пишите ishu в MAUI.
5945.58 5971.50 "Игорь Лабутин" Да, ну, точнее, там немножко всё более сложно, потому что Xamarin Android, Xamarin iOS, Xamarin Mac, они теперь, как пишет Microsoft, встроены непосредственно в .NET под названиями .NET for Android, .NET for iOS и .NET for Mac, а вот Xamarin Forms, это как раз теперь MAUI, и поэтому, если вы пользуетесь Xamarin Forms, срочно мигрируйте на MAUI и надейтесь, что Microsoft не заархивирует репозиторий MAUI в каком-нибудь обозреваемом будущем.
5971.50 5979.38 "Игорь Лабутин" Мемы, кстати, в интернете уже появились про то, что да, типа, а в 25-м году то же самое будет написано про MAUI, про то, что всё, закрываем.
5979.38 5982.78 "Анатолий Кулаков" Да-да, с какой-нибудь новой альтернативой ещё.
5982.78 5985.62 "Анатолий Кулаков" Да, несомненно, ну как, Avalon'ю купить.
5985.62 5987.66 "Анатолий Кулаков" Avalon'ю, Microsoft купит Avalon'ю.
5987.66 5988.66 "Анатолий Кулаков" Чтобы закрыть.
5988.66 5993.70 "Анатолий Кулаков" Да, ладно, поживём, увидим, почему бы и нет.
5993.70 6023.70 "Анатолий Кулаков" Я хотел вам сказать, что Андрю Лок, который вы знаете наверняка по нашим статьям, по его статьям, которые мы регулярно обозреваем, он решил портировать библиотеку, которая называется ASCII Math, это специальный парсер, который переводит вам такой человека, даже не человека, а машину написанный, обычный текст в MathML, то есть в красивые формулы со всякими суммами, интегралами, дробными частями и вот этим всем.
6023.70 6034.42 "Анатолий Кулаков" То есть вы можете написать в обычной нашей жизни такой код, такие примеры, как вы пишете, например, на C#, и он вам переведёт это всё в какое-то красивое математическое представление.
6034.42 6053.54 "Анатолий Кулаков" Ну то есть он вам вот этот парсер распарсит, переведёт это в MathML, MathML – это такой XML-подобный, ну это не XML по сути, это XML, который описывает всю эту структуру, а уже современные браузеры умеют отображать MathML в виде вот таких вот формул, сложных, красивых и так далее.
6053.54 6060.90 "Анатолий Кулаков" Поэтому если вы вдруг с этим сталкивались, и вам нужна была библиотека по .NET, опять же, Андрю обнаружил, что почему-то по .NET нет такой библиотеки, поэтому он решил портировать.
6060.90 6076.46 "Анатолий Кулаков" Если вы тоже столкнулись с такой проблемой, то может иметь смысл посмотреть на его библиотеку или может быть даже помочь ему с переводом, потому что он как раз занимается портированием Ruby библиотеки, Schemaf, которая очень распространена, очень популярна, но всё же как бы не на .NET.
6076.46 6085.62 "Анатолий Кулаков" Также у него там есть интересный эксперимент, с помощью которого он встроил вот этот свой конвертер, вот этот свой парсер в MarkDig.
6085.62 6093.30 "Анатолий Кулаков" MarkDig – это библиотека Александра Мютула, которая является парсером Маркдауна.
6093.30 6098.18 "Анатолий Кулаков" Хороший .NET парсер Маркдауна, опять же, если вдруг вам пригодится, то обратите на неё внимание.
6098.18 6124.18 "Анатолий Кулаков" Он как раз таки довольно легко расширяемый и что позволило Андрю заставить MarkDig, т.е. по сути в Маркдауне писать код, который после парсинга, после конвертации в HTML будет транслироваться в MathML, и соответственно вы в своём блоге, у Андрю была это как раз цель, в своём собственном блоге, который у него построен на MarkDig, использовать хорошие, красивые математические формулы.
6124.18 6127.62 "Анатолий Кулаков" С помощью как раз будет он это делать в библиотеке MathML.
6127.62 6131.42 "Анатолий Кулаков" В библиотеке ASCII Math через формат MathML.
6131.42 6132.42 "Анатолий Кулаков" Вот.
6132.42 6142.06 "Анатолий Кулаков" И вторая интересная статья, которая называется «Представление типов с помощью дженериков», алисов с помощью дженериков.
6142.06 6155.06 "Анатолий Кулаков" Не то, чтобы здесь что-то новое, интересное, просто я довольно часто в сложных алгоритмах использовал такой подход и, наконец-то, нашёл статью, где кто-то его описывал, поэтому захотелось поделиться с окружающими.
6155.06 6157.02 "Анатолий Кулаков" Смысл очень простой.
6157.02 6165.30 "Анатолий Кулаков" Когда вы объявляете алис у какого-то типа, например, с помощью оператора using, вы можете сделать using_user_id = string.
6165.30 6175.34 "Анатолий Кулаков" Это значит, что везде в коде этого файла, где встретится user_id токен, он туда будет просто-напросто компилятором подставляться string.
6175.34 6180.22 "Анатолий Кулаков" Банально, примитивно, но это помогает писать намного более понятные алгоритмы.
6180.22 6191.34 "Анатолий Кулаков" Например, если у вас есть какой-то лукап, который связывает пользователя и проект, то, скорее всего, вы этот лукап у себя оформите в коде с помощью обычного dictionary string-string.
6191.34 6198.98 "Анатолий Кулаков" И что такое dictionary string-string, вам придётся или писать в комментариях, или забить, и поэтому вы будете нехороший программист.
6198.98 6205.90 "Анатолий Кулаков" Потому что другой человек, который придёт, он будет очень долго понимать, что вы хотели сказать с помощью типа dictionary string-string.
6205.90 6207.90 "Анатолий Кулаков" Это нечитабельно абсолютно.
6207.90 6211.26 "Анатолий Кулаков" Естественно, вы можете обернуть dictionary в какую-то свою коллекцию.
6211.26 6218.86 "Анатолий Кулаков" Естественно, вы можете избавиться от примитива obsession и завести какие-то свои типы user_id и project_id.
6218.86 6222.30 "Анатолий Кулаков" Но иногда вам это всё не нужно.
6222.30 6228.42 "Анатолий Кулаков" Вам нужно просто более выразительно описать конкретно один алгоритм или конкретно один класс.
6228.42 6232.66 "Анатолий Кулаков" И вот в этот момент к вам на помощь приходят как раз алиасы типов.
6232.66 6245.14 "Анатолий Кулаков" Когда вы просто говорите using user_id=string и using project_id=string, и этого достаточно просто, чтобы выразительно написать класс, или выразительно написать алгоритм, чтобы он был читабельным и понятным.
6245.14 6255.66 "Анатолий Кулаков" Если вдруг вы дорастёте к тому, чтобы избавиться от примитива obsession, то эти using легко превращаются в рекорды или в классы, и в принципе код менять не нужно.
6255.66 6266.18 "Анатолий Кулаков" Но если вы до этого не дорастаете, и вам этого достаточно, то вот как самое банальное избавление от примитива obsession с помощью одной строчки, вот такой подход довольно часто в принципе спасает жизнь.
6266.18 6269.46 "Анатолий Кулаков" То есть увеличивает читабельность, и при этом ничего не надо делать.
6269.46 6274.74 "Игорь Лабутин" Ну отлично, мне кажется, на этом мы на сегодня можем закругляться.
6274.74 6291.30 "Игорь Лабутин" Статьи закончились, новости закончились, ждём, когда-нибудь Майкрософт наконец-таки выпустит майские праздники и скоро закончатся, можно перестать отдыхать и наконец-таки выпустить очередную превью .NET, и я надеюсь, будет много полезных клёвых фич, которые мы будем долго обсуждать.
6291.30 6297.62 "Анатолий Кулаков" Или наоборот, все уйдут в летний отпуск и всё, и мы совсем ничего не дождёмся к сентябрю.
6297.62 6305.62 "Игорь Лабутин" И только в ноябре они такие, ну ладно, короче, последняя превью будет в девятом .NET и сойдёт.
6305.62 6313.06 "Игорь Лабутин" Да я сомневаюсь, я надеюсь, что они всё-таки что-то готовят большое, что в C# и что в .NET, ну очень подозрительно выглядит такая тишина, не знаю.
6313.06 6319.62 "Анатолий Кулаков" И очень долго готовят, по-моему никогда в жизни они до этого так долго и так тщательно ничего не скрывали и не готовили.
6319.62 6327.62 "Игорь Лабутин" Да, мне кажется, что у нас давно такого не было, что мы уже который выпуск говорим, ну вот, нет новости от Майкрософта, нету.
6327.62 6328.62 "Игорь Лабутин" Что-то как-то странно.
6328.62 6347.06 "Игорь Лабутин" Ладно, сегодня мы посмотрели на .NET Expire Preview 6, узнали про детали того, как мы правильно искать подстронки с помощью Search Values, посмотрели как тестировать ваши API, точнее не ваши API, а то, как ваше приложение обращается к внешним API с помощью DevProxy и возможно что-то попробовать поломать.
6347.06 6368.46 "Игорь Лабутин" Узнали, как правильно подключать C-Log и вообще настраивать логин к вашему .NET-приложению, посмотрели на новый язык, новый туллинг от Майкрософта, как писать спеки для ваших API, узнали про новый тул для того, чтобы писать Adder в ваших проектах, ну и красненько тут поговорили обо всяком разном, по мелочи.
6368.46 6374.66 "Игорь Лабутин" На этом все, 92-й выпуск, мне кажется, пора заканчивать.
6374.66 6389.42 "Анатолий Кулаков" Да, действительно пора, ну а вам в шаре репосты, заходите, мы ждем ваших комментариев на YouTube, мы ждем ваших лайков, мы ждем привода друзей к нам в подкасты и все такое.
6389.42 6391.66 "Анатолий Кулаков" Всем до новых встреч, всем пока.
6391.66 6392.26 "Игорь Лабутин" Всем пока.
6392.26 6404.26 "Игорь Лабутин" [Музыка]
