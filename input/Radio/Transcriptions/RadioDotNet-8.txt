0.00 3.80 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
3.80 10.12 "Анатолий Кулаков" В эфире снова Radio.net и с вами его постоянный ведущий Анатолий Кулаков и Игорь Лабутин.
10.12 11.12 "Анатолий Кулаков" Привет!
11.12 14.94 "Анатолий Кулаков" У нас уже восьмой выпуск и накопилось немножко интересных тем.
14.94 15.94 "Анатолий Кулаков" Предлагаю их обсудить.
15.94 18.42 "Анатолий Кулаков" Самая первая тема, самая важная.
18.42 21.84 "Анатолий Кулаков" Наконец-то наш подкаст доступен на Ютубе.
21.84 38.16 "Анатолий Кулаков" Нас об этом много просили и вот наконец мы в видео формате, поэтому если вам интереснее и приятнее слушать Насть на телевизорах или желательно иметь какую-то картинку перед глазами, то милости просим на наш Ютуб канал dotnet.ru в отдельном плейлисте.
38.16 42.76 "Анатолий Кулаков" Там будут собраны все выпуски нашего подкаста, начиная с самого нулевого.
42.76 45.72 "Анатолий Кулаков" Те, кто хочет поностальгировать, тоже заходите.
45.72 49.12 "Анатолий Кулаков" Также можете там попутно полазить по каналчику.
49.12 50.44 "Анатолий Кулаков" Канальчик очень интересный.
50.44 64.40 "Анатолий Кулаков" Там собрано очень много видосиков за все годы существования наших сообществ из всех городов, поэтому можно встретить практически любую тему, на которой вам захочется поискать материалы или по которой вы захотите просветиться.
64.40 76.56 "Анатолий Кулаков" И для меня Ютуб канал еще с момента первых метапов и становления сообщества оказался интересным местом еще и потому, что это одно единственное место, где в основном люди оставляют свои комментарии.
76.56 88.92 "Анатолий Кулаков" То есть мы публикуем анонсы в Твиттерах, в Фейсбуках, в Контактах, много где еще, в Телеграмах, но в основном люди там не комментируют доклады, не комментируют выступления.
88.92 95.96 "Анатолий Кулаков" А вот в Ютубе, вот там обычно разгоряются очень интересные баталии, очень интересные комментарии.
95.96 107.24 "Анатолий Кулаков" И поэтому я надеюсь также, что это будет хорошее место для нашего подкаста, где вы будете оставлять свои комментарии, которым мы будем прислушиваться, отвечать вам и так далее.
107.24 117.08 "Анатолий Кулаков" Поэтому все заходите на Ютуб, даже если вы не хотите посмотреть, а просто заходите нас полайкать, пошарить или оставить какие-то комментарии или пожелания, тоже мы вас там всех ждем.
117.08 119.52 "Анатолий Кулаков" А теперь давайте непосредственно перейдем к нашим темам.
119.52 121.68 "Анатолий Кулаков" Итак, что у нас там сегодня интересного?
121.68 124.16 "Анатолий Кулаков" Как всегда, новости начинаются с Дотнет 5.
124.16 126.44 "Анатолий Кулаков" Почему так много всего про Дотнет 5?
126.44 129.20 "Игорь Лабутин" Майкрософт активно работает над Дотнет 5.
129.20 140.08 "Игорь Лабутин" Не сказать, чтобы за две с небольшим недели, с тех пор, как мы в прошлый раз записывались, появилось какое-то большое количество новостей, но тем не менее, немножечко есть.
140.08 145.96 "Игорь Лабутин" И первая новость - это пропозал, но который уже довольно близок к финальному завершению.
145.96 156.76 "Игорь Лабутин" И он про TFM, Target Framework Monitors, или по сути, описание того, на что вы хотите таргетить ваши DLL или приложения.
156.76 166.72 "Игорь Лабутин" Все мы знаем, что в CES Proj можно писать Target Framework нет стендарт 2.0 или нет 4.8 или нет Core App что-нибудь.
166.72 174.48 "Игорь Лабутин" И по этому атрибуту рантайм будет понимать, под какой фреймворк ваше приложение должно быть запущено.
174.48 176.24 "Игорь Лабутин" И совместимо оно или нет.
176.24 182.12 "Игорь Лабутин" С появлением Дотнет 5 появляется необходимость добавить новые Target Framework.
182.12 188.76 "Игорь Лабутин" И пропозал заключается в том, что теперь не будет возможности сказать нет стандарт.
188.76 196.84 "Игорь Лабутин" То есть, мы много раз упоминали, что наверное с появлением Дотнет 5 нет стандарт как-нибудь будет умирать или не будет умирать.
196.84 198.12 "Игорь Лабутин" Так вот, похоже, что будет.
198.12 203.12 "Игорь Лабутин" Теперь не будет нового TF Target Framework, нет стандарт что-нибудь.
203.12 205.96 "Игорь Лабутин" Вместо этого нужно будет использовать нет 5.0.
205.96 211.28 "Игорь Лабутин" Но нет 5.0 это достаточно общее название.
211.28 213.20 "Игорь Лабутин" Оно будет относиться к всему Дотнет 5.0.
213.20 218.56 "Игорь Лабутин" А поскольку Дотнет 5.0 по определению cross-platform, то по большому счету это и есть замена нет стандарту.
218.56 226.48 "Игорь Лабутин" То есть в будущем, если вы хотите писать библиотеку, которую бы вы сейчас затаргетили на нет стандарта, вам нужно будет таргетить нет 5.0.
226.48 227.80 "Игорь Лабутин" Причем обязательно через точку.
227.80 240.16 "Игорь Лабутин" Это новая договоренность, чтобы не путаться со старыми обозначениями target framework, потому что когда доберемся до 10 версии Дотнета, то будет нет 1.0 и непонятно это Дотнет 1.0 или Дотнет 10.
240.16 243.44 "Игорь Лабутин" Поэтому договорились, что оно всегда будет через точку и всегда с ноликом в конце.
243.44 245.80 "Игорь Лабутин" То есть это будет Дотнет 10.0.
245.80 247.40 "Игорь Лабутин" Дальше есть проблема.
247.40 253.40 "Игорь Лабутин" Бывает, что нужно затаргетить приложение для Windows или Linux или macOS или еще чего-нибудь.
253.40 256.20 "Игорь Лабутин" Этот момент тоже теперь стандартизирован.
256.20 257.76 "Игорь Лабутин" Все будет писаться через DEFIS.
257.76 267.48 "Игорь Лабутин" То есть будет писаться net 5.0 DEFIS WIN или DEFIS macOS или DEFIS Xamarin или DEFIS iOS что-нибудь.
267.48 277.12 "Игорь Лабутин" Хуже того или лучше того, у этой самой операционной системы можно будет указать версию минимальную необходимую, для которой это все таргетится.
277.12 281.04 "Игорь Лабутин" То есть можно будет написать нет 5.0 DEFIS iOS 13.0.
281.04 287.68 "Игорь Лабутин" И это будет означать, что вы таргетите ваше приложение на рантайм Дотнет 5 запущенный на iOS версии не ниже 13.
287.68 299.84 "Игорь Лабутин" В общем, пока это пропоузл, но похоже на то, что он довольно стройный, он покрывает все необходимые нужды и, скорее всего, в таком видео он и будет принят и реализован везде где нужно.
299.84 307.44 "Игорь Лабутин" Так что вот прощание стандарт и здравствуй Дотнет 5.0, который везде и всюду и в каждом телевизоре.
307.44 308.44 "Анатолий Кулаков" Отлично.
308.44 319.52 "Анатолий Кулаков" И чтобы не пропускать от Дотнет 5.0, Microsoft продолжает нас бомбить новыми превьюшками Visual Studio и тут недавно вышел Visual Studio 2019-16.6 Preview 2.
319.52 323.76 "Анатолий Кулаков" Вот там улучшали каких-то новых нам оптимизаций.
323.76 324.76 "Анатолий Кулаков" Что именно?
324.76 327.88 "Игорь Лабутин" Ну, оптимизаций, как таковых, как я понимаю, там не сильно много.
327.88 332.60 "Игорь Лабутин" Самое главное, пожалуй, они переделали гид.
332.60 340.24 "Игорь Лабутин" Ну не сам гид, конечно же, а то, что теперь чуть-чуть по-другому Visual Studio предоставляет методы работы с гидом.
340.24 342.36 "Игорь Лабутин" То есть UI-чик по сути немножко улучшили.
342.36 360.76 "Игорь Лабутин" Но не только улучшили, они сделали так, что теперь можно работать и с GitHub, и с Azure, и запушить новые проекты напрямую на GitHub, соответственно, даже не создавая проекты на GitHub, то есть Visual Studio сама все сделает за вас под вашим аккаунтом.
360.76 363.44 "Игорь Лабутин" И в общем, новый экспириенс.
363.44 369.28 "Игорь Лабутин" Я, честно скажу, превьюшку не ставил и не пробовал, поэтому надо посмотреть, как это все будет развиваться.
369.28 380.56 "Игорь Лабутин" И они сами говорят, что это пока только начало того, как они хотят чуть больше и чуть лучше GitHub экспириенс затащить в Visual Studio, поэтому я думаю, что это не последний GitHub изменение, и гид изменения.
380.56 387.08 "Игорь Лабутин" Дальше еще интересная штука, но надо посмотреть, как она будет работать.
387.08 389.44 "Игорь Лабутин" Это New .NET Async Tool.
389.44 398.72 "Игорь Лабутин" В коллекцию Performance Tools в студии добавили новый .NET Async Tool, который помогает смотреть, как вообще работает Async/Evade и оптимизировать его.
398.72 400.68 "Анатолий Кулаков" А примеры каких-нибудь оптимизаций можешь привести?
400.68 401.96 "Анатолий Кулаков" Что именно помогает делать?
401.96 414.52 "Игорь Лабутин" Примеры оптимизаций пока не могу, но то, что у них написано, что он может позволять делать, он позволяет посмотреть, сколько таски висели в ожидании того, как они начнут исполняться, были ли таски выполнены последовательно друг за другом.
414.52 422.88 "Игорь Лабутин" Ну, как мы знаем, там, континуейшн могут быть выполнены непосредственно сразу на том же трекде и никуда не переходя, если рантайм посчитает это необходимым.
422.88 431.72 "Игорь Лабутин" Так вот, это теперь можно будет все видеть в диагностике и возможно на основе этого как-то понимать, как нам, так скажем, оптимизировать наш код.
431.72 436.24 "Игорь Лабутин" Но пока превью надо смотреть, ставить и развлекаться.
436.24 444.36 "Игорь Лабутин" Я, к сожалению, просто не успел поставить превьюшку и посмотреть, хотя очень хочу уже перейти на превьюшечные версии, чтобы так поиграться, посмотреть, что новенького.
444.36 446.84 "Игорь Лабутин" Каждая превью-версия тащит довольно много нового.
446.84 456.04 "Игорь Лабутин" Ну, как обычно, добавили кучу всяких разных, или не очень много, но все-таки всякие разные квик-экшены, потихонечку видимо утаскивая их из ReSharper или откуда-то рядом райдера.
456.04 461.36 "Игорь Лабутин" Так что, что-то про ML, что-то про VEP, ну и даже про C++.
461.36 477.28 "Игорь Лабутин" Так что, по чуть-чуть везде, но сейчас, вижу, студия как бы развивается так, что даже минорная версия может принести какие-то большие фичи, так что приходится внимательно следить за каждой, даже превьюшками, вдруг что интереснее.
477.28 482.92 "Анатолий Кулаков" Да, и сам .NET 5 не отстает от Visual Studio.
482.92 488.24 "Анатолий Кулаков" Тоже с момента нашего последнего обсуждения вышел превью-2, и в нем уж оптимизаций куча.
488.24 493.88 "Анатолий Кулаков" И одной из самых главных, значимых, больших оптимизаций были прооптимизированы Regexp.
493.88 505.32 "Анатолий Кулаков" Вообще, Regexp - это одна из самых юзаемых фич, и это очень интересно, потому что они были разработаны и внедрены во фреймворке еще во времена версии 1.1.
505.32 507.28 "Анатолий Кулаков" Это где-то 15 лет назад.
507.28 513.60 "Анатолий Кулаков" И с тех пор практически не изменялись, то есть в них практически не инстигировали никакого времени.
513.60 534.44 "Анатолий Кулаков" Когда переходили на корку, там были небольшие изменения, в частности касающиеся тех, что под .NET Core 1, веткой 1, была проигнорирована полностью фича Regexp Options Compiled, то есть, несмотря на то, указали вы флаг Compiled или нет, Regexp всегда выполнялись в нескомпилированном режиме.
534.44 537.64 "Анатолий Кулаков" Об этом никто не знал, никто не заметил, поэтому всем тихо.
537.64 554.52 "Анатолий Кулаков" Во второй ветке они все это восстановили, конечно же, и уже сейчас в .NET 5 они добавили кучу интересных оптимизаций, пересмотрели многие архитектуры и добились того, что в среднем регулярные выражения начали работать в 3-6 раз быстрее.
554.52 558.44 "Анатолий Кулаков" Это средние показатели.
558.44 566.92 "Анатолий Кулаков" Естественно, в максимальных случаях и в извращенных кейсах цифры были до нескольких тысяч, сот тысяч раз быстрее.
566.92 571.76 "Анатолий Кулаков" Итак, сначала хотелось бы затронуть вопрос, из чего состоят регулярные выражения.
571.76 583.00 "Анатолий Кулаков" Ведь для нас это обычно статический классик с несколькими методами, которые принимают простую маску, строку, возвращают обычный какой-то предсказуемый результат.
583.00 586.44 "Анатолий Кулаков" На самом деле внутри там написана огромная-огромная библиотека.
586.44 599.60 "Анатолий Кулаков" У нее на входе вас встречает Regexp Parser, это инструмент, который парсит шаблоны регулярного выражения, преобразует их в некое симпатическое дерево, затем отдает это Regexp в райтеру.
599.60 605.04 "Анатолий Кулаков" В райтер ему называется потому, что пишет обкоды, оптимизированные под этот темплейт.
605.04 614.16 "Анатолий Кулаков" И если вдруг вы указали флажочек Regexp Options Compiled, то в дело вступает Regexp Compiler.
614.16 626.56 "Анатолий Кулаков" Компайлер с помощью Reflection Emit генерирует msrc коды и подстраивает уже непосредственный шаблон под оптимальные алгоритмы, которые в этом шаблоне были заданы.
626.56 641.32 "Анатолий Кулаков" Если же вы флажок Compiled не указали, то вся интерпретация выполняется с помощью Regexp Interpreter, специального класса, который не производит никакой компиляции, но зато не тратит время на всякие оптимизации и преобразования, и делает код интерпретируемым.
641.32 659.48 "Анатолий Кулаков" Основные оптимизации, которые были сделаны командой, заключаются в том, что они переписали, переосмыслили всякие медленные куски, внедрили спаны, внедрили векторизацию, заиспользовали куски стандартного BCL, где уже была векторизация и так далее.
659.48 669.48 "Анатолий Кулаков" То есть, если вы захотите покопаться в этом поглубже, или вы сильно интересуетесь, как устроена оптимизация Regexwap, то статейка очень занимательная, очень подробная, большая.
669.48 678.36 "Анатолий Кулаков" Основные выводы, которые из нее можно сделать, это старайтесь обязательно юзать Regexp Options Compiled и Regexp Options Invariant Culture.
678.36 694.68 "Анатолий Кулаков" Обычно это можно сделать в 99% всех Regexwaps, и поэтому, если вдруг у вас есть в вашем продукте какие-то Regexwaps, убедитесь, что эти два флага там обязательно присутствуют, и ваш перформанс у них как минимум не ухудшится, а в некоторых случаях в разы вырастет.
694.68 720.96 "Игорь Лабутин" Да, еще интересный момент, который я вынесу из этой статьи, это то, что в .NET Framework используется так называемый non-deterministic finite automata, то есть недетерминированный неконечный автомат, который позволяет на самом деле очень крутые фичи в Regexwaps поддерживать, типа back-references так называемых, то есть когда вы можете сматчить кусочки так, чтобы паттерн в одном месте соответствовал паттерну в другом месте.
720.96 765.08 "Игорь Лабутин" Но при этом есть еще класс, скажем так, интерпретаторов регулярных выражений, который зовется deterministic finite automata, и на самом деле команда .NET всерьез рассматривает возможность написания такого для .NET тоже, есть еще и на GitHub, в который можно прийти, посмотреть, поучаствовать, и они подумывают о том, что если с этим что-то получится хорошее, то возможно этот метод тоже будет жить в .NET, и потому что в большинстве случаев, если регулярные выражения действительно простые и не требуют каких-то супер фич матчинга под выражение или еще чего-то, а просто проверить соответствие строке или нет, то deterministic finite automata будет гораздо быстрее, и на нем можно сделать гораздо больше оптимизаций.
765.08 805.16 "Игорь Лабутин" То есть плюс, помимо оптимизации, собственно, в райтерах и компайлерах, то, о чем мы говорили, спаны, вот это все, они сделали довольно прикольную штуку, они оптимизируют само регулярное выражение, то есть вот ту строчку, которую вы пишете, она преобразуется внутри в дерево, и вот на этом дереве возможны очень разные оптимизации, которые на самом деле сильно упрощают выражение, но которые возможно не очевидны с первого взгляда, и Microsoft над этим тоже очень много работает, и есть некоторое количество GitHub issues про то, как это тоже можно улучшить, если хочется поконтрибьютить и что-то сложное, то вот это можно туда зайти посмотреть, потому что RegExp - это непросто.
805.16 809.08 "Анатолий Кулаков" Мне кажется вполне валидно сравнивать RegExp с полноценным языком программирования.
809.08 819.08 "Анатолий Кулаков" Смотри, у него есть парсер, у него есть оптимизатор, у него есть компилятор, у него есть интерпретатор, то есть такая большая инфраструктура, и целая полноценная язык программирования там живет.
819.08 826.76 "Игорь Лабутин" Осталось еще рантайм и операционную систему, и будет полноценное, вообще можно будет что-нибудь написать на нем.
826.76 827.76 "Игорь Лабутин" Ладно, погнали дальше.
827.76 829.76 "Игорь Лабутин" Что у нас еще есть про DotNet 5?
829.76 836.24 "Анатолий Кулаков" Смотри, не отходя далеко от DotNet 5 и оптимизации, у меня есть отличные две статейки от Егора Богатого.
836.24 854.80 "Анатолий Кулаков" Егор - это разработчик в компании Microsoft, он перешел из команды Mono, прошел много всего, знает еще больше всего, сейчас работает на DotNet 5, и в Mono Runtime, контрибьютит в Core CLR, CoreFX, в общем, человек непосредственно близкий к коду, непосредственно близкий к оптимизациям.
854.80 865.36 "Анатолий Кулаков" У него есть куча отличных видосиков, если вы почему-то как-то раньше с ним не встречались, обязательно погуглите в видео Егора Богатов и найдете много всего интересного.
865.36 877.92 "Анатолий Кулаков" Он рассказывает про оптимизации, про перформансы, про внутреннее строение рантаймов, джетов, и соответственно, две его статьи, которых сегодня хочется обсудить, тоже касаются про оптимизации.
877.92 881.96 "Анатолий Кулаков" Эта статья называется "Оптимизация в JIT-компиляторе для DotNet 5".
881.96 890.16 "Анатолий Кулаков" Егор рассказывает, каким образом он пришел в оптимизацию JIT-компилятора и какие простейшие элементарные вещи он туда добавил, казалось бы.
890.16 893.08 "Анатолий Кулаков" Просто хочется осветить какой-нибудь примерный список.
893.08 898.24 "Анатолий Кулаков" Например, он убрал отбоксинги из некоторых юзкейсов паттерн-матчинга.
898.24 915.36 "Анатолий Кулаков" Команда, имплементирующая паттерн-матчинг, при реализации не учла, что некоторые типы можно было бы вполне заоптимизировать, и зная те типы данных, которые участвуют в паттерн-матчинге, можно было бы избежать отбоксинга и отбоксинга, что очень вредно для перформанса.
915.36 922.68 "Анатолий Кулаков" Дальше, например, он научил JIT заменять свойства из value type у system type, если оно уже известно на момент компиляции.
922.68 928.12 "Анатолий Кулаков" То же самое касается из assignable from type, например, если оно тоже известно во время компиляции.
928.12 937.52 "Анатолий Кулаков" И вообще, таким образом, можно заменить, заинлайнить, заоптимизировать любое свойство system type, если его тип уже известен во время компиляции.
937.52 940.40 "Анатолий Кулаков" Например, в случае дженериков это всегда так.
940.40 952.52 "Анатолий Кулаков" Дальше простейшая оптимизация он сделал, как вычисление длины строки, если эта длина ищется от константы, то есть если она, опять же, уже известна нам, и мы можем за нее заинлайнить.
952.52 964.12 "Анатолий Кулаков" Прооптимизировал bound checking, то есть проверку на границы массивов, если вдруг индекс ищется по наложению с маской, и размер маски точно известен, и он не превышает размер массива.
964.12 971.64 "Анатолий Кулаков" Также такие простейшие оптимизации, как заменил деление на 2 умножением на 0.5, что в некоторых случаях очень сильно увеличивает производительность.
971.64 981.08 "Анатолий Кулаков" И возведение во вторую степень можно заменить на перевнажение числа на самого себя, или умножение числа на 2 можно заменить как складывание числа самого себя.
981.08 991.56 "Анатолий Кулаков" То есть такие простецкие, казалось бы, реализации, которые в принципе должны быть в любом компиляторе, в любом оптимизаторе, в любом gcs, в gcs с самого начала, их почему-то вообще не было в rigid.
991.56 994.76 "Анатолий Кулаков" Игорь, тебя вот это не смутило?
994.76 1002.76 "Игорь Лабутин" Ну, немножко, да, потому что, казалось бы, rigid должен вобрать в себя все то, что было в старом, плюс много чего нового.
1002.76 1013.20 "Анатолий Кулаков" Да, то есть значит ли это, что в большом дотнет фреймворке и в старом gt и все эти 15 лет, которые мы там работали, всех этих оптимизаций не было, и мы как-то жили?
1013.20 1026.24 "Игорь Лабутин" Ну, как-то жили, возможно, сейчас при общей нацеленности идут на это, на перформанс и оптимизации, стала проявляться даже важность таких мелких оптимизаций.
1026.24 1036.92 "Игорь Лабутин" То есть мне кажется, что просто раньше мы за memory traffic и накладными расходами на соответствующий garbage collector и всем остальным просто не видели необходимых в таких тонких подстройках.
1036.92 1045.16 "Игорь Лабутин" А сейчас, когда garbage collector почти не влияет, все работает на спанах и не нужно локетить память, даже такие мелкие оптимизации становятся важными.
1045.16 1047.32 "Анатолий Кулаков" Да, да, вполне может быть.
1047.32 1075.68 "Анатолий Кулаков" Вторая статья Егора называется «Как gt инлайнит наш C# код?» Тоже очень интересная тема, меня давно она интересует, особенно давно хотелось бы иметь такой инструмент, который подсказывает, заинлайнился ваш метод или не заинлайнился, что нужно делать, как его прооптимизировать, чтобы он все-таки заинлайнился, потому что я часто упираюсь в такую проблему, в такую ситуацию, и до сих пор какого-то предсказуемого инструмента, какого-то предсказуемого подхода и поддержки такого кода его почему-то нет.
1075.68 1081.80 "Анатолий Кулаков" И вот статья Егора как раз раскрывает немножко глаза на то, что там происходит внутри, как это все делается.
1081.80 1098.60 "Анатолий Кулаков" А инлайнинг вообще-то это очень важная штука, она не только помогает ваш метод внедрить внутрь вызывающей стороны или что-то типа того, она еще и позволяет сделать много других оптимизаций, которые невозможно были бы без инлайнинга.
1098.60 1106.48 "Анатолий Кулаков" Например, constant folding или dead code elimination, и поэтому эта тема довольно важна.
1106.48 1115.00 "Анатолий Кулаков" До этого в моей голове была картина, что JIT определяет, то, нужно метод заинлайнить или нет, по каким-то простым правилам.
1115.00 1119.12 "Анатолий Кулаков" Например, если вызывается exception внутри метода, значит, он не будет заинлайниться.
1119.12 1123.96 "Анатолий Кулаков" Если метод больше, чем какого-то определенного набора bytes, значит, он не будет заинлайнит.
1123.96 1130.64 "Анатолий Кулаков" И вот такие правила у него есть, который он быстренько-простенько перебирает и определяет, будет ли метод заинлайниться или нет.
1130.64 1135.04 "Анатолий Кулаков" И Егор рассказывает, что все работает на самом деле абсолютно не так.
1135.04 1140.72 "Анатолий Кулаков" У Рюджита есть некий определенный бюджет, в который он старается уложиться.
1140.72 1142.80 "Анатолий Кулаков" И он начинает анализировать ваши методы.
1142.80 1146.40 "Анатолий Кулаков" Он анализирует методы и учитывает некие правила.
1146.40 1148.72 "Анатолий Кулаков" Эти правила дают определенный коэффициент.
1148.72 1154.60 "Анатолий Кулаков" Если все эти коэффициенты уложились в определенный лимит, значит, метод будет заинлайнен.
1154.60 1156.88 "Анатолий Кулаков" Если не уложились, то он заинлайнен не будет.
1156.88 1164.92 "Анатолий Кулаков" Интересно, что в своих исследованиях Егор использует инструмент, который я тоже раньше никогда не слышал, Dizasmotool.
1164.92 1172.24 "Анатолий Кулаков" То есть этот инструмент показывает вам, во что превратится ваш код после того, как по нему пройдется JIT.
1172.24 1178.32 "Анатолий Кулаков" То есть он вам показывает ассемблер, уже непосредственно машинный код, во что превращаются ваши методы, во что превращаются ваши классы.
1178.32 1186.12 "Анатолий Кулаков" Очень интересно иногда бывает действительно на него посмотреть и понять, то есть все работает так, как вы рассчитываете или немножко по-другому.
1186.12 1198.04 "Игорь Лабутин" Ну, насколько я понял, его можно поставить, это экстенджинг 2019 студии, но из сайта Tool, если я правильно понял, нужно собрать себе свою CLR.
1198.04 1203.80 "Игорь Лабутин" Это делается несложно, но, тем не менее, это нужно сделать, потому что нужна отладочная версия CLR, чтобы можно было эту информацию вытащить.
1203.80 1221.04 "Анатолий Кулаков" И в частности, этот tool как раз таки и покажет вам вот эти все правила, вот эти все эвристики, которые пытаются применить Regit, и этот tool покажет вам коэффициент, который посчитал этот Regit, и из него как раз таки и можно будет понять, заинлайнился ваш код или нет, или почему не заинлайнился.
1221.04 1231.56 "Анатолий Кулаков" Все эти коэффициенты, они не такие примитивные, в том числе они учитывают то, насколько вырастет перформанс вашего приложения или насколько увеличится размер вашего приложения.
1231.56 1237.28 "Анатолий Кулаков" Все эти показатели, естественно, не могут вычислиться каким-нибудь эмпирическим путем, они вычислились с помощью ML.
1237.28 1253.24 "Анатолий Кулаков" Вот таким образом, машин.лень принес непосредственную пользу именно нам, то есть языкам программирования и компиляторам, которым мы пользуемся, с помощью ML были подобраны специальные коэффициенты, учтен специальный перформанс импакт и так далее.
1253.24 1268.84 "Анатолий Кулаков" В общем, если вас интересует, каким образом рассчитывать там эти коэффициенты или каким образом искусственный интеллект помог нам рассчитать правильные методы для инлайнинга, правильные лимиты для инлайнинга, в общем, это тоже есть отдельная статья, мы ее приложим в шоу-ноты.
1268.84 1276.52 "Игорь Лабутин" Да, ну и несмотря на все эти ML коэффициенты и все остальное, тем не менее, если функция достаточно большая, инлайниться она не будет.
1276.52 1287.84 "Игорь Лабутин" Есть так называемые basic blocks или базовые блоки, если их больше чем 5, то несмотря на то, какой бы хороший коэффициент у вас не был, метод все равно не заинлайнится.
1287.84 1293.84 "Анатолий Кулаков" Да, ну и существуют также другие правила, например, если метод бросает исключение, то он все-таки действительно не будет заинлайниться.
1293.84 1306.48 "Анатолий Кулаков" Если у вас используется виртуальный метод, то в принципе есть возможность, что он заинлайнится, если вы используете метод или сам класс sealed, то тоже есть теоретики, которые могут помочь ему заинлайниться.
1306.48 1328.72 "Игорь Лабутин" Насколько я понимаю, thrown_you тоже не всегда гарантируется, что не будет инлайнинга, потому что как раз один из примеров, который рассказывает Егор, такой, что метод, в котором есть thrown_you в одной из веток исполнения, он все-таки инлайнится, но там достаточно много звезд должно сойтись и константу передать, и константы внутри сравниваются, и количество этих базовых блоков не больше 5, это все-таки очень редкий случай.
1328.72 1339.28 "Анатолий Кулаков" И он хорошо демонстрирует как раз-таки то, о чем я говорил в самом начале, потому что с помощью всех этих инлайнингов JIT понимает, что блок, который бросает исключение, он на самом деле никогда не сработает.
1339.28 1345.20 "Анатолий Кулаков" То есть с учетом тех констант, про которые JIT знает, ему хватает сведений о том, чтобы просто этот блок выкинуть.
1345.20 1354.40 "Анатолий Кулаков" А как только мы выкидываем блок, который никогда не сработает, блок генерации исключения, соответственно, у нас уже срабатывают непосредственно другие правила, и мы можем заинлайнить этот метод.
1354.40 1357.16 "Игорь Лабутин" И надо предупредить еще об одной штуке.
1357.16 1368.48 "Игорь Лабутин" Если вы будете читать эти игры, то может сначала показаться, что тот код, который он приводит в качестве примера, что вот мы можем заинлайнить вот такое, вот такое, никогда вам не встретится в реальной жизни.
1368.48 1372.16 "Игорь Лабутин" Ну по принципу, кто же так пишет, никто так, ифы не пишет, никто так, код не пишет.
1372.16 1382.58 "Игорь Лабутин" Надо не забывать, что JIT работает уже на этапе после всех оптимизаций, во-первых, самого Розлина, который делает там constant folding и какие-то минимальные оптимизации может сделать сам.
1382.58 1390.16 "Игорь Лабутин" И кроме того, JIT по результатам там инлайнинга одного метода может потом в результате что-то заинлайнить еще дальше.
1390.16 1401.92 "Игорь Лабутин" И может так оказаться, что на момент работы JIT метод уже выглядит совершенно неузнаваемо для вас, но в реальной жизни так встречается довольно часто, такая, допустим, последовательность команд.
1401.92 1407.52 "Игорь Лабутин" И поэтому имеет смысл работать и думать, как сделать такую JIT оптимизацию.
1407.52 1417.36 "Игорь Лабутин" И вроде как есть даже специальный режим или специальный тест, можно сказать, а что будет, если в JIT сделать определенную оптимизацию.
1417.36 1427.64 "Игорь Лабутин" Можно запустить этот тестик на кодовой базе CoreFX, на дотнета всего, и он выдаст, соответственно, отчет про то, насколько изменился размер каждого метода в плюс или в минус.
1427.64 1438.08 "Игорь Лабутин" Соответственно, если вы предложите свою JIT оптимизацию и все методы дотнета в результате станут меньше размером, ну мне кажется, у вас хорошие шансы получить эту оптимизацию внутри дотнета.
1438.08 1456.00 "Анатолий Кулаков" Да, и очень приятно, Егор рассказывает, у него отличный язык, он отлично это все доносит, то есть понятным, интересным языком, и он реанимировал свой англоязычный блог, поэтому если у вас есть иностранные коллеги, с кем бы вы хотели поделиться статьей, то ссылочка на блог тоже будет в шоу-нотах.
1456.00 1466.12 "Игорь Лабутин" Супер, мне кажется, что про DotNet 5 во многом мы закончили, каких-то еще особых новостей конкретно про DotNet 5 у нас сейчас пока нету, поэтому пошли дальше.
1466.12 1472.76 "Анатолий Кулаков" В прошлом выпуске мы с вами обсуждали магическую фичу, которая мелькнула в анонсах, и называется она "динамик программ-анализис в райдере".
1472.76 1483.24 "Анатолий Кулаков" Наконец-то пришли подробности, наконец-то пришла статейка, которая же все-таки нам объясняет, что это за новомодная штука, каким образом этот перформанс-анализ будет осуществляться и что вообще происходит.
1483.24 1486.00 "Анатолий Кулаков" Давайте немножко пробежимся по этой статеечке.
1486.00 1492.88 "Анатолий Кулаков" Статья в блоге JetBrains вводит нам новую фичу "динамик программ-анализис".
1492.88 1500.84 "Анатолий Кулаков" Она пока работает только в райдере, планы на решарпер есть, но еще без конкретных дат, а в райдере вы уже можете ее наблюдать в версии 2020.1.
1500.84 1503.92 "Анатолий Кулаков" Итак, мысли ребят из JetBrains в принципе довольно логические.
1503.92 1518.20 "Анатолий Кулаков" Они говорят, что если вы запускаете перформанс-профайлер довольно-таки редко, а обычно люди его запускают раз в полгода или может быть даже еще реже, то никаких best-practice, никаких умений, никаких освоений глубокого этого инструмента у вас не будет.
1518.20 1524.12 "Анатолий Кулаков" И соответственно вы не сможете проанализировать ваш код глубоко и вам нужна какая-то помощь.
1524.12 1532.32 "Анатолий Кулаков" Вам нужны какие-то автоматические подсказывающие, которые могут вам рассказать, где у вас какие-то перформанс-проблемы и показать может быть даже как их решить.
1532.32 1546.56 "Анатолий Кулаков" И команда райдера она строго уверена, что профайлить нужно всегда, профайлить нужно часто и всегда рассматривайте свою программу под профайлером и это очень сильно отражается на качестве вашего продукта.
1546.56 1569.04 "Игорь Лабутин" Мне кажется, что мысль про то, что запускается профайлер раз в полгода, ладно бы он запускался раз в полгода регулярно и это давало какие-то результаты, очень часто профайлер запускается, когда уже все совсем плохо, когда уже видны явные проблемы, до релиза неделя вот это все и в спешке мы что-то пофиксили, где-то убрали локейты памяти и снова забыли про профайлинг до следующей такой проблемы.
1569.04 1573.48 "Игорь Лабутин" Поэтому как раз таки да, регулярный профайлинг он невероятно полезен.
1573.48 1582.44 "Анатолий Кулаков" А еще бывают, знаешь, ситуации, когда зовут одного единственного человека в команде, который умеет профайлить, выдают ему этот кусок, говорят ну-ка сделай нам здесь магию, прооптимизируй, чтобы было быстрее.
1582.44 1589.80 "Анатолий Кулаков" Вот этот один как бы все запускает, оптимизирует, выдает и вся остальная команда радостно наслаждается тем, что кот стал быстрее.
1589.80 1594.32 "Игорь Лабутин" Да, или перед релизом, когда такая проблема, вот этот сам единственный он в отпуске.
1594.32 1596.12 "Игорь Лабутин" Тогда что, релиз откладываем?
1596.12 1597.48 "Игорь Лабутин" Ну получается, что так.
1597.48 1598.64 "Игорь Лабутин" Ну, почему нет?
1598.64 1601.76 "Анатолий Кулаков" Чтобы таких ситуаций не было, хотелось бы как-то эту проблему решить.
1601.76 1604.20 "Анатолий Кулаков" И JetBrains нам предоставил свое решение.
1604.20 1607.24 "Анатолий Кулаков" Это специальный инструмент, который называется Dynamic Program Analysis.
1607.24 1611.20 "Анатолий Кулаков" Физически он себе представляет отдельный процесс, который называется TV Collector.
1611.20 1614.44 "Анатолий Кулаков" Он работает в бэгранде и собирает всякую полезную для вас информацию.
1614.44 1622.24 "Анатолий Кулаков" Запускается Dynamic Program Analysis в момент дебага и показывает вам некую информацию о перформанс картине вашего приложения.
1622.24 1633.76 "Анатолий Кулаков" В частности, в первой версии он может быть настроен на треш-холд memory allocation и показывать места в вашей программе, которые allocated память.
1633.76 1635.44 "Анатолий Кулаков" Почему именно с memory allocation?
1635.44 1644.88 "Анатолий Кулаков" Потому что команда JetBrains уверена, что memory allocation это одна из самых частых проблем, то есть не нужные создания участков памяти.
1644.88 1653.68 "Анатолий Кулаков" Они приводят к очень хорошей просадке по гардеробному коллектору и они легко фиксируются в большинстве своем.
1653.68 1655.88 "Анатолий Кулаков" Поэтому это очень хороший такой старт.
1655.88 1658.24 "Анатолий Кулаков" Итак, что же может отслеживать DPA?
1658.24 1668.84 "Анатолий Кулаков" В первых версиях он может отслеживать аллокации, которые связаны с замыканиями, с small object heap и large object heap.
1668.84 1669.84 "Анатолий Кулаков" Как это выглядит?
1669.84 1676.00 "Анатолий Кулаков" Вы запускаете просто свое приложение под отладчиком, общаетесь с ним, отлаживаете, делаете свои дела.
1676.00 1695.68 "Анатолий Кулаков" В этот момент незаметно для вас бэкграундный процесс DPA собирает нужную информацию и делает выводы, что если какой-то участок кода аллоцирует много памяти, а много - это какой-нибудь треш-холд который задается в настройках, он вам подсвечивает этот кусок.
1695.68 1707.44 "Анатолий Кулаков" То есть для того, чтобы найти все подобные места, вам достаточно обратить внимание на маленькую иконочку внизу у райдера и посмотреть все те участки, которые он вам обозначил.
1707.44 1711.60 "Анатолий Кулаков" Он вам напишет сколько в этом участке было залацировано памяти, сколько раз он вызывался.
1711.60 1719.12 "Анатолий Кулаков" И если вы поставите прекрасное наширение, которое называется heap allocation view viewer, то вы сразу же увидите и почему эта аллокация произошла.
1719.12 1721.20 "Анатолий Кулаков" То есть что именно там случилось.
1721.20 1728.80 "Анатолий Кулаков" Потому что банальный new - это понятно, но часто, очень часто разработчики не видят тех аллокаций, которые происходят.
1728.80 1729.80 "Анатолий Кулаков" Например, тот же самый боксинг.
1729.80 1737.48 "Анатолий Кулаков" Если вы вдруг структуру кастите к какому-нибудь объекту, явно или не явно у вас происходит боксинг, и вот этого вы практически никогда не увидите.
1737.48 1740.64 "Анатолий Кулаков" Плагин heap allocation viewer вам эту информацию покажет.
1740.64 1745.12 "Анатолий Кулаков" Если у вас еще не стоит, попробуйте, много нового интересного узнаете о вашем коде.
1745.12 1753.72 "Игорь Лабутин" Да, сам плагин покажет, что тут она есть, а вот эта новая фича, она покажет, а сколько тут у вас есть в ваших конкретных флоу исполнения.
1753.72 1756.40 "Игорь Лабутин" Смотри, у меня такой вопрос.
1756.40 1765.04 "Игорь Лабутин" Не кажется ли тебе, что память, вот эти все аллокейты, это чуть ли не единственное, что можно на самом деле таким образом анализировать?
1765.04 1777.40 "Игорь Лабутин" Потому что мне, как человеку, который умеет и знает, как профайлить, всегда говорили, что профайлимы только релиз, конфигурацию, и только не под дебагом, потому что это отключает всякие JIT оптимизации, вот это все.
1777.40 1782.12 "Игорь Лабутин" То есть профайлить любой другой перформанс, кроме аллокейтов памяти, мне кажется абсолютно бессмысленным.
1782.12 1791.64 "Анатолий Кулаков" Мне пока нечего тебе возразить, но зная команду JIT Brains, я думаю, они бы не стали загоняться таким инструментом ради вот этого одного шага.
1791.64 1800.12 "Анатолий Кулаков" И они в статье упоминают, что у них уже готовятся какие-то новые оптимизации, уже готовятся какие-то новые идеи, они есть, они будут, давай посмотрим, что покажет
1800.12 1814.52 "Игорь Лабутин" время. Да, интересно, потому что я пока, кроме как память, не могу придумать, что еще можно так вот мониторить в дебаге под отладчиком и выдавать это как-то полезную информацию, которая точно будет применима, в том числе для релиза и без отладчика.
1814.52 1815.52 "Игорь Лабутин" Но посмотрим.
1815.52 1828.08 "Игорь Лабутин" Окей, следующая тема, она же новость, она на самом деле даже немножко к Dota 5 относится, но так, к RAISH-кам это Message Pack.
1828.08 1849.56 "Игорь Лабутин" То есть все мы знаем REST, все мы знаем JSON, все пользуются JSON, естественно, везде во всей API он пробрался, в частности потому, что его очень удобно парсить и на фронт-энди, и на бэк-энди, и где угодно, есть огромная куча всяких разных сериалайзеров, которые с ним работают, но тем не менее иногда хочется что-нибудь компактное и бинарное.
1849.56 1871.64 "Игорь Лабутин" Естественно, в эпоху процветания или пока еще роста популярности JRPC можно вспомнить про Taboo, но про Taboo он все-таки требует и схемы, и некой, скажем так, аккуратности в подходе, как-то надо пошарить схему между клиентом и сервером, это не всегда удобно.
1871.64 1912.08 "Игорь Лабутин" И есть аналогия, есть протокол под названием Message Pack, который умеет в том числе сериализовывать схему сам в себя, если я правильно помню и не вру, и он существовал в нескольких библиотеках, я знаю две, которые таких основных и достаточно популярных существовали, и одна из них это Message Pack C#, довольно долгое время была в версии 1, она была долго-долго-долго без развития, то есть она была зарелизлена около двух, если не ошибаюсь, лет назад, и с тех пор как-то GitHub довольно был тих и пустынен, никаких апдейтов не было в том числе от автора, было ощущение, что автор полностью его забросил.
1912.08 1928.56 "Игорь Лабутин" Но внезапно, внезапно для меня, на самом деле Message Pack обновился до версии v2, причем обновился он на самом деле в конце 2019 года, но как-то мы эту новость пропустили, и стало понятно, как версия 2 родилась.
1928.56 1943.92 "Игорь Лабутин" Оказывается, один из инженеров команды Microsoft, то есть команды Visual Studio, написал большую часть обновления этого самого Message Pack, и совместно с автором Message Pack добили ее до состояния, что теперь можно зарелизить.
1943.92 1945.80 "Игорь Лабутин" И там много чего интересного.
1945.80 1956.64 "Игорь Лабутин" Мы на самом деле Message Pack C# библиотечку использовали, и она очень прекрасно работает, у нее получается примерно такой же пейлоуд по объему, как у Protobuf, чуть-чуть больше.
1956.64 1967.44 "Игорь Лабутин" И она чуть-чуть более прожорлива к CPU, чем Protobuf, но все это меркнет по сравнению с тем, сколько нужно пейлоуда для JSON и сколько нужно было CPU, если пользоваться Newtonsoft JSON.
1967.44 1976.44 "Игорь Лабутин" Поэтому мы использовали Message Pack C#, но к сожалению, у нее есть одна особенность, которая делает ее с одной стороны очень крутой, с другой стороны очень некрутой.
1976.44 1985.40 "Игорь Лабутин" Она полностью построена на массивах байтов, то есть она в себя для десерилизации принимает byte array, и наружу она тоже выдает byte array.
1985.40 2007.36 "Игорь Лабутин" Естественно, если мы десерилизуем или десерилизуем что-то довольно маленькое, это все прекрасно, но в нашем случае мы десерилизовывали объекты, итоговый объект серилизован в виде занимал порядка 5 мегабайт, и это было как-то очень грустно, потому что внутри она ведет себя примерно как Memory Stream, то есть удваивала byte array, вот это все, и тратила кучу памяти на это.
2007.36 2019.92 "Игорь Лабутин" Поскольку сам Message Pack, как я сказал, v1 был довольно заброшен, мы сделали свою кастомную версию, переписали ее немножко, чтобы она хотя бы использовала array pool, но как-то дальше не пошло.
2019.92 2021.88 "Игорь Лабутин" Так она у нас сейчас пока и используется.
2021.88 2026.00 "Игорь Лабутин" Но вот есть версия 2, и в ней довольно много изменений.
2026.00 2041.04 "Игорь Лабутин" Самое главное, что они теперь используют все наши модные новые апи, то есть используют и BufferWriter класс, который из ченнелов, как я понимаю, пришел, и ReadOnlySequence, и спаны внутри, и array pool, и все такое прочее.
2041.04 2047.72 "Игорь Лабутин" Ну в общем, все теперь должно быть быстро, легко, элементарно, и в стрим-варианте.
2047.72 2058.16 "Игорь Лабутин" Несомненно, есть все еще старые апишки с byte array, но все должно вообще работать теперь прям быстро и зашибись как.
2058.16 2073.60 "Игорь Лабутин" Кроме того, теперь они официально стали использовать внутри array pool, и говорят, что теперь ни один внутренний массив не должен быть больше чем 85 тысяч байт, то есть они никогда не должны залезать в large object heap, что очень, конечно, приятно.
2073.60 2090.44 "Игорь Лабутин" В общем, звучит это все очень промиссинг, и мы прошли, может быть, мимо этой новости стороной, потому что, ну, мало ли сколько у нас разных библиотек релизится Message Pack, возможно, не самый популярный протокол сейчас, но как выяснилось, Message Pack версии v2 используется самим Microsoft.
2090.44 2098.80 "Игорь Лабутин" И не в команде Visual Studio, несмотря на то, что инженер, который его дописывал, был из команды Visual Studio, а из команды ASP.NET Core.
2098.80 2110.56 "Игорь Лабутин" А если посмотреть внимательно, то GitHub репозиторий Message Pack подключен в виде сабмодуля в GitHub репозиторий ASP.NET Core, и часть исходников оттуда используется при компиляции ASP.NET Core рантайма.
2110.56 2120.32 "Игорь Лабутин" Я, ради интереса, посмотрел зачем, и выяснилось, что Message Pack используется как сериализатор для Blazor.
2120.32 2129.68 "Игорь Лабутин" То есть, когда Blazor общается между клиентом и сервером через SignalR, то все то, что гоняется в бинарном виде между ними, оно сериализуется Message Pack тем самым.
2129.68 2131.32 "Игорь Лабутин" И вот конкретно этой библиотекой.
2131.32 2137.24 "Игорь Лабутин" Что дает основания полагать, что возможно, когда-нибудь мы увидим нативную реализацию Message Pack от Microsoft.
2137.24 2147.20 "Игорь Лабутин" Не знаю, будет ли она лучше или хуже, но мне нравится тот факт, что Microsoft думает не только о поддержке ProtoBuf, как единственном бинарном формате, но и каких-то альтернатив.
2147.20 2149.40 "Игорь Лабутин" У тебя вообще есть какой-то опыт Message Pack?
2149.40 2151.64 "Анатолий Кулаков" Нет, как-то не приходилось сталкиваться.
2151.64 2154.32 "Анатолий Кулаков" В принципе, идея интересная.
2154.32 2156.08 "Анатолий Кулаков" Как альтернатива JSON тоже интересно.
2156.08 2164.80 "Анатолий Кулаков" И правильно я понимаю, что его нельзя использовать со стороны JavaScript, как протокол общения front-end и back-end?
2164.80 2174.56 "Игорь Лабутин" Напрямую нет, в том смысле, что нативно на JavaScript это не напишешь, все равно нужен какой-то код на C или на чем-то.
2174.56 2185.40 "Игорь Лабутин" Но возможно, в WebAssembly поможет, потому что в Blazor он используется, но Blazor это как бы в WebAssembly, то есть там есть некоторый кусочек парсера Message Pack, который написан, как я понимаю, на...
2185.40 2188.20 "Игорь Лабутин" Я даже не знаю, на чем, но в общем скомпилирован он в WebAssembly.
2188.20 2197.04 "Игорь Лабутин" И из TypeScript, если посмотреть исходники ESP-NodeCore, там видно, что из TypeScript дергаются просто эти парсеры, и все работает.
2197.04 2201.96 "Анатолий Кулаков" Благодаря Microsoft мы все-таки получили поддержку на стороне JavaScript этого замечательного протокола?
2201.96 2203.44 "Игорь Лабутин" Ну, в каком-то смысле да.
2203.44 2208.60 "Игорь Лабутин" Возможно, она была, и возможно, Microsoft на client-сайте тоже кого-то заиспользовала до этого.
2208.60 2209.60 "Игорь Лабутин" Это я не знаю.
2209.60 2219.04 "Игорь Лабутин" Но, тем не менее, сейчас мы знаем, что вот, по край мере, в Blazor связка frontend с backend работает через SignalR и через Message Pack.
2219.04 2224.80 "Игорь Лабутин" И второй момент, который довольно-таки интересен, это следующий.
2224.80 2231.60 "Игорь Лабутин" Почти все сериализаторы, которые у нас есть, ну или скажем так, часть сериализаторов, которые есть, работают, естественно, через Reflection.
2231.60 2237.52 "Игорь Лабутин" Особенно те, которые не требуют заранее описывать схемы и так далее.
2237.52 2239.80 "Игорь Лабутин" Это, на самом деле, Reflection.
2239.80 2247.08 "Игорь Лабутин" Так вот, проблема с такими сериализаторами в том, что они не могут использоваться на всяких платформах, где Reflection нет.
2247.08 2248.08 "Игорь Лабутин" Например, iOS.
2248.08 2249.08 "Игорь Лабутин" iOS.
2249.08 2256.60 "Игорь Лабутин" Ну и, на самом деле, как я понимаю, в Android, наверное, тоже, но, в общем, Unity, вот это все.
2256.60 2258.60 "Игорь Лабутин" Unity же есть под iOS, да?
2258.60 2259.60 "Игорь Лабутин" Или нет?
2259.60 2260.60 "Игорь Лабутин" Сам движок есть, да.
2260.60 2261.60 "Игорь Лабутин" Вот.
2261.60 2273.12 "Игорь Лабутин" Соответственно, короче говоря, вот этот товарищ, который пишет, который автор Message Pack, он, на самом деле, сейчас занимается тем, что дизайнит игрушки и пишет их.
2273.12 2275.84 "Игорь Лабутин" И Unity ему там прямо очень важен и нужен.
2275.84 2286.32 "Игорь Лабутин" И, соответственно, большая его боль была в том, что, я так понимаю, что Reflection там есть не везде, не всюду, и, возможно, не такой полноценный, как он был бы на полноценном фреймворке.
2286.32 2295.40 "Игорь Лабутин" Поэтому у этого сериалайзера есть отличная поддержка всяких платформ, где нужно делать AOT, то есть, Head of Time Compilation.
2295.40 2301.92 "Игорь Лабутин" Они сделали хороший тулинг, который позволяет взять вашу кодовую базу, взять, соответственно, Message Pack, этот NuGet пакетик.
2301.92 2312.20 "Игорь Лабутин" Он пройдется по всем нужным размеченными атрибутиками коду вашим C# файлом и сгенерит все, весь нужный сериализатор, так сказать, до компиляции.
2312.20 2314.20 "Игорь Лабутин" После чего оно все скомпилируется и будет работать.
2314.20 2323.76 "Игорь Лабутин" Так что, если вы работаете в каких-то областях, где вам нужно, нету Reflection, то попробуйте Message Pack, вот этот конкретный Message Pack C# v2.
2323.76 2326.60 "Игорь Лабутин" Возможно, это будет то, что вам нужно, если вам нужна бинарная сериализация.
2326.60 2333.52 "Анатолий Кулаков" Да, я подобный подход использовал, даже когда у меня был Reflection, именно для ускорения процесса сериализации и децерализации.
2333.52 2334.52 "Анатолий Кулаков" Хороший подход.
2334.52 2342.80 "Игорь Лабутин" Я так понимаю, любой сериализатор в итоге, естественно, генерирует код сериализации, но для того, чтобы понять, в каких полях читать, он все-таки первый раз делает проход Reflection.
2342.80 2353.88 "Игорь Лабутин" Так делает, по крайней мере, стандартный XML сериалайзер, на самом деле, который генерирует в рантайме сборочку темповую, в которую кладет уже нормальный оптимизированный код.
2353.88 2355.64 "Игорь Лабутин" Но все-таки один раз Reflection ему нужен.
2355.64 2357.72 "Игорь Лабутин" А тут сборочка прям готовая, заранее сделана.
2357.72 2358.72 "Анатолий Кулаков" Да, отлично.
2358.72 2365.64 "Анатолий Кулаков" Еще один инструмент, если мы уж говорим про инструменты, на которые я наткнулся, интересный, это Wasmir.
2365.64 2377.88 "Анатолий Кулаков" Wasmir - это специальный рантайм, специальный инструмент, специальная экосистема, которая помогает вам запускать библиотеку, написанную на WebAssembly под любой другой язык.
2377.88 2379.24 "Анатолий Кулаков" Казалось бы, зачем это может быть нужно?
2379.24 2385.04 "Игорь Лабутин" А давай прежде, чем думать, зачем это нужно, давай немножко поговорим о том, что такое WebAssembly.
2385.04 2388.64 "Игорь Лабутин" Потому что ты так сказал, библиотека, написанная на WebAssembly.
2388.64 2392.52 "Игорь Лабутин" WebAssembly - это все-таки, мне кажется, не тот язык, на котором пишут.
2392.52 2398.72 "Игорь Лабутин" Давай, чтобы все наши слушатели знали, если вдруг кто-то не знает, что такое WebAssembly, немножко поясним, что это такое.
2398.72 2399.72 "Игорь Лабутин" Да, отличное замечание.
2399.72 2400.72 "Игорь Лабутин" Поясняли.
2400.72 2411.88 "Игорь Лабутин" WebAssembly - это, как я это тоже понимаю, я не фронт-энд-девелопер, куда это все пришло, поэтому если вдруг мы вам все рассказываем неправильно, пишите нам комменты и говорите, что мы неправы.
2411.88 2415.60 "Игорь Лабутин" Мы будем этого очень ждать, наконец-таки нам хоть что-нибудь кто-нибудь скажет, что мы в чем-то неправы.
2415.60 2424.72 "Игорь Лабутин" И WebAssembly - это штука, которая, это по сути стандарт некоторого языка.
2424.72 2437.60 "Игорь Лабутин" То есть во многом его можно рассматривать так, как Common Intermediate Language для .NET, то есть некоторый универсальный стандарт языка, который позволяет платформа независимо писать, ну по сути, да, писать программы.
2437.60 2446.40 "Игорь Лабутин" То есть и складывать их в виде абстрактного синтактического дерева, бинарно записанного и компактно очень записанного.
2446.40 2450.20 "Игорь Лабутин" И дальше это бинарное дерево, почему бинарное?
2450.20 2458.96 "Игорь Лабутин" Абстрактное синтактическое дерево можно интерпретировать либо компилировать на лету в то, где вы будете исполняться и получать таким образом исполняемый код.
2458.96 2468.84 "Игорь Лабутин" Кроссплатформенность прям вообще суперская должна быть, но такая кроссплатформенность достигается, конечно, за счет того, что набор средств в этом языке достаточно ограничен.
2468.84 2470.28 "Игорь Лабутин" Тем не менее.
2470.28 2475.60 "Анатолий Кулаков" Изначально этот язык пришел как подмножество JavaScript, он пришел из браузерного окружения.
2475.60 2496.04 "Анатолий Кулаков" То есть разработчики браузера посчитали, что есть специальное подмножество, которое можно ограничить и благодаря этим ограничениям, как правильно Игорь сказал, можно выдать намного больше перформанса, можно все вот эти командочки очень сильно прооптимизировать и запустить на каком-нибудь очень-очень низком уровне.
2496.04 2505.68 "Анатолий Кулаков" Изначально он целился как оптимизированный язык для игр, для 3D-реальности, для прочих высоконагруженных графических приложений, может быть машин-ленинг приложений.
2505.68 2508.40 "Анатолий Кулаков" В общем, все то, где очень важен перформанс.
2508.40 2531.92 "Анатолий Кулаков" И с какой-то извращенной стороны, как всегда человечество на это посмотрело и сказало, что если браузеры - это наша новая кроссплатформенная операционная система, и эти браузеры теперь имеют свой ассемблер в виде WebAssembly, значит мы должны теперь под этот ассемблер смочь компилироваться и тем самым получить кроссплатформенные приложения, которые могут запускаться на любой операционной системе.
2531.92 2537.64 "Анатолий Кулаков" Потому что браузеры, поддерживаемые WebAssembly, уже запускаются практически везде, и он поддерживается во всех современных браузерах.
2537.64 2550.56 "Игорь Лабутин" Так, то есть получается, что мы теперь можем взять что-нибудь, что скомпилируется в WebAssembly, мы еще поговорим, что можно скомпилировать в WebAssembly, и запустить это вообще где угодно.
2550.56 2553.84 "Игорь Лабутин" То есть это круче, чем Java и .NET?
2553.84 2555.28 "Анатолий Кулаков" По сути, да.
2555.28 2560.80 "Анатолий Кулаков" Единственная проблема с этим, такая же, как и с обычным ассемблером - писать на нем крайне неудобно.
2560.80 2574.36 "Анатолий Кулаков" Поэтому сейчас существует подход такой, что мы берем языки высокого уровня, пишем на них понятные программы с помощью понятных нам инструментов, отлаживаем их, профайлим их, оптимизируем их, и после этого перегоняем в WebAssembly.
2574.36 2582.72 "Анатолий Кулаков" И уже в этот WebAssembly, это еще один такой формат выходного артефакта для наших продуктов, уже с этим WebAssembly делаем что-либо дальше.
2582.72 2586.92 "Анатолий Кулаков" А вот что с этим пакетом выходным можно сделать дальше - это уже следующий вопрос.
2586.92 2595.16 "Анатолий Кулаков" И в частности, один из путей, что же с ним можно сделать, предлагает такой проект как Wasmer.
2595.16 2602.64 "Анатолий Кулаков" А Wasmer говорит, а давайте мы сделаем просто-напросто универсальный контракт для наших приложений.
2602.64 2608.16 "Анатолий Кулаков" То есть мы наконец-то получим тот ассембль, который удовлетворяет идеальным требованиям всех программистов.
2608.16 2609.16 "Анатолий Кулаков" Что это за требования?
2609.16 2616.08 "Анатолий Кулаков" Прежде всего, вы, конечно же, должны использовать свой любимый язык, свои любимые IDE и свои любимые инструменты вокруг этого всего.
2616.08 2617.08 "Анатолий Кулаков" Удовлетворяет.
2617.08 2625.96 "Анатолий Кулаков" Во-вторых, все это должно компилироваться в какой-то один единственный промежуточный формат, который поддерживается всеми операционными системами.
2625.96 2627.40 "Анатолий Кулаков" Опять же, это он.
2627.40 2636.52 "Анатолий Кулаков" И, в-третьих, этот промежуточный формат должно быть можно заиспользовать в любом другом языке, в любой другой IDE, которая нравится кому угодно другому.
2636.52 2651.36 "Анатолий Кулаков" Таким образом, мы получим отличную инфраструктуру, отличную экосистему, в которых наконец-то перестанут происходить холивары о том, какой IDE лучше, какой язык программирования лучше, какая операционная система лучше, потому что абсолютно это все не важно.
2651.36 2653.00 "Анатолий Кулаков" Они все могут с друг другом работать.
2653.00 2660.16 "Анатолий Кулаков" Они все могут использовать плюсы одного, они все могут нивелировать минусы другого и таким образом выстраивать идеальный продукт.
2660.16 2665.84 "Анатолий Кулаков" Вот этой экосистемой и пытается стать проект, который называется ВАСМИР.
2665.84 2668.60 "Игорь Лабутин" Че-то пока планы выглядят очень наполеоновски.
2668.60 2671.28 "Игорь Лабутин" Не будет ли это как обычно?
2671.28 2677.12 "Игорь Лабутин" У нас было N фреймворков, мы сделаем новый, который будет вместо них всех, теперь у нас будет N+1 фреймворк.
2677.12 2678.12 "Анатолий Кулаков" Может быть, вполне.
2678.12 2682.88 "Анатолий Кулаков" Но проект новый, проект интересный, идея тоже заманчивая, поэтому почему бы не начать.
2682.88 2686.84 "Анатолий Кулаков" И начал не кто иной подхватил эту идею Мигель Дальказа.
2686.84 2694.44 "Анатолий Кулаков" Мигель Дальказа сделал баннинги для C#, таким образом в экосистему ВАСМИРа попал в том числе и C#.
2694.44 2700.80 "Анатолий Кулаков" То есть C# теперь может обмениваться кодом и использовать модули от всех других языков, которые поддерживает проект ВАСМИР.
2700.80 2708.12 "Анатолий Кулаков" А это на данный момент Rust, Python, Ruby, PHP, C, C++ и Go.
2708.12 2715.24 "Анатолий Кулаков" Проект развивается, новые баннинги добавляются и поэтому в будущем мы наверняка увидим какие-то новые поддержки для других языков.
2715.24 2729.60 "Анатолий Кулаков" У ВАСМИРа уже есть свой собственный package manager, который называется Wamp.io, там уже люди выкладывают какие-то свои модули, какие-то свои наработки, компоненты, которые они написали, пишут их на любых языках и использовать вы тоже это можете в любом другом языке.
2729.60 2734.44 "Игорь Лабутин" Да, то есть давайте еще раз повторим, чтобы все поняли.
2734.44 2752.56 "Игорь Лабутин" ВАСМИР - это штука, которая позволит вам писать код на дотнете и если вам какой-то в WebAssembly модуль понравился, то заиспользовать его из дотнета напрямую, практически без всяких пейнвоков и прочих странностей, независимо от того, на чем этот модуль был написан.
2752.56 2754.36 "Игорь Лабутин" Он может быть написан на чем угодно.
2754.36 2758.68 "Анатолий Кулаков" В том же самом процессе, в котором высполняется ваш дотнет-код, да.
2758.68 2759.68 "Игорь Лабутин" Да.
2759.68 2774.96 "Игорь Лабутин" Но с другой стороны, как я сказал, что WebAssembly - это в принципе некоторый достаточно абстрактный язык, ну ассемблер, можно сказать, который до некоторой степени похож на наш родной дотнет-интермидиат-ленгвич.
2774.96 2779.60 "Игорь Лабутин" И возникает вопрос, а почему бы не сделать компилятор из одного в другое?
2779.60 2787.28 "Игорь Лабутин" Возникает он, конечно же, не только у нас одних, и поэтому есть человек, который этим уже заботился, и его зовут Эрик Синг.
2787.28 2805.28 "Игорь Лабутин" Человек, который довольно-таки известен всякими разными околокомпиляторными и другими штуками, и он попробовал сделать некоторый, скажем так, это даже не компилятор, это, если правильно говорить, транспайлер, который переводят из одного интермидиат-ленгвича в другой интермидиат-ленгвич.
2805.28 2808.12 "Игорь Лабутин" Проект называется Wasm2SIM.
2808.12 2809.12 "Игорь Лабутин" Да.
2809.12 2823.60 "Игорь Лабутин" Сейчас он находится в таком довольно-таки зачаточном состоянии, он уже в состоянии перегонять какие-то WebAssembly-модули в дотнет, но там поддержано еще далеко не все, и работа над ним довольно активно ведется.
2823.60 2837.20 "Игорь Лабутин" Хотя я смотрю, что последние коммиты там пару месяцев назад, но Эрик Синг пишет в блоге, что это его pet project, и часть работы делается на самом деле в private репозиториях, наружу выкладывают только то, что уже там хоть как-то готово.
2837.20 2846.44 "Игорь Лабутин" Для того, чтобы понимать, как вот вся эта цепочка работает, он это делает на примере SQLite клиента, который написан на C.
2846.44 2864.52 "Игорь Лабутин" У C есть компилятор, который умеет генерировать WebAssembly, он основан на LLVM, и соответственно он умеет генерировать WebAssembly-модуль, который потом пытается вот этим вот Wasm2SIM переводиться в дотнетовскую сборку.
2864.52 2869.76 "Игорь Лабутин" И надо сказать, что результат вполне впечатляющий, более или менее базовая функциональность уже работает.
2869.76 2879.56 "Игорь Лабутин" То есть мы получаем из C приложения на чистом C, мы получаем приложение на в общем-то чистом дотнете, без там paintwalk'ов и всего остального.
2879.56 2883.60 "Игорь Лабутин" Выглядит вообще говоря, ну так, если не космически, то где-то близко.
2883.60 2888.64 "Игорь Лабутин" Расскажи мне такое пару лет назад кто-нибудь, это было бы очень странно, иметь такой компилятор, но тем не менее.
2888.64 2895.40 "Анатолий Кулаков" Да, будем надеяться, что Эрик доведет свой проект до какого-то продакшена, и мы сможем воспользоваться всей этой мощностью.
2895.40 2898.16 "Игорь Лабутин" Да, так, что у нас еще?
2898.16 2900.88 "Игорь Лабутин" Я думаю, что у нас есть еще что-нибудь сегодня поговорить.
2900.88 2908.16 "Анатолий Кулаков" По-моему осталась последняя тема, очень интересная, называется Best Practice for REST API Design.
2908.16 2916.40 "Анатолий Кулаков" Интересная она тем, что этому вопросу уже многие-многие тысячелетия, и обсасывался он на всевозможных местах, которые только возможно.
2916.40 2918.52 "Анатолий Кулаков" Ты зачем вообще эту новость перетащил?
2918.52 2920.52 "Игорь Лабутин" Да поговорить.
2920.52 2922.84 "Игорь Лабутин" Давно мы что-то не обсуждали REST API.
2922.84 2923.84 "Игорь Лабутин" Да никогда.
2923.84 2932.32 "Игорь Лабутин" Да даже никогда, ну и как-то с одной стороны вроде как разговоры поутихли, потому что мне кажется, такой прям хайп более-менее прошел, и все более-менее договорились.
2932.32 2939.92 "Игорь Лабутин" Хайп именно обсуждений, то есть хайп REST API прошел, но обсуждений, они мне очень редко попадались в последнее время, а тут вот попалось.
2939.92 2947.36 "Игорь Лабутин" Причем попалось не оба где, а на сайте под названием Stack Overflow Blog, который я, честно говоря, до этого не то чтобы сильно часто видел.
2947.36 2948.96 "Игорь Лабутин" Я вообще никогда не видел.
2948.96 2964.24 "Игорь Лабутин" Ну вот я так поискал по истории, и оказывается там были какие-то статьи в 2017 году и в 2018, то есть это некоторый блог, как я думал, от компании Stack Overflow, в смысле от, про то, как они живут внутри, как устроена их система, но похоже, что нет.
2964.24 2996.32 "Игорь Лабутин" Там есть и приглашенные авторы, и в частности вот эта статья, она от, как я понимаю, приглашенного автора Джон Ау Йонг, или Йонг, не очень понимаю, как это произносится, но смысл в том, что статья такая, достаточно для поговорить, я бы сказал, я не со всеми тезисами согласен, но на самом деле я предлагаю просто пройтись по, скажем так, заголовкам и основным тезисам и поговорить, кто что из нас думает на те тему каждого из разделов.
2996.32 3022.08 "Игорь Лабутин" В целом про блог хочется сказать, что с одной стороны вроде как Stack Overflow блог, обычно мы верим в Stack Overflow и там всячески считаем, что они крутые и так далее, но вот кажется, что с блогом пока у меня какое-то ощущение, что там надо достаточно внимательно относиться к статьям, качество статей с одной стороны должно быть высокое, но с другой стороны вот я вижу по этой статье, что далеко не со всем я согласен и судя по комментариям я не одинок.
3022.08 3029.24 "Игорь Лабутин" Но давай пойдем по заголовкам, так скажем, и поговорим, кто что думает согласный, не согласный.
3029.24 3035.32 "Игорь Лабутин" Заголовок первый это Accept and Respond with JSON, то есть принимать нужно только JSON, отдавать нужно только JSON.
3035.32 3038.40 "Игорь Лабутин" Ты как к этому относишься в Рестапе?
3038.40 3042.20 "Анатолий Кулаков" Не поддерживать никакие другие протоколы ты имеешь в виду?
3042.20 3069.56 "Игорь Лабутин" Да, тут как бы его point состоит в том, что нужно всегда отдавать JSON, всегда принимать JSON, единственное исключение это когда мы отдаем именно файлы, ну то есть если есть какой-то endpoint, типа дать файл, то там конечно нужно тогда или зааплодить файл с формочки на сайте, ну тогда как бы там форм дата, старая добрая, там мультипарт разделителями вот этим всем, а в остальном всегда типа application JSON и UTF-8 без вариантов.
3069.56 3079.88 "Анатолий Кулаков" Нужно признать, что действительно JSON стал форматом де-факто, потому что у нас появился frontend и для них это самый удобный формат и нам пришлось под них подстраиваться.
3079.88 3095.64 "Анатолий Кулаков" Безусловно, JSON должен быть всегда и скорее всего везде, но о том, что это единственный правильный протокол, вот это я категорически не согласен, потому что существует огромное количество прекрасных протоколов, да любой протокол, который ты не возьмешь, он в 100 тысяч раз прекраснее, чем JSON, но мы сейчас не об этом.
3095.64 3110.24 "Анатолий Кулаков" Существует огромное количество многих разных протоколов, которые подходят под, может быть, какие-то узкие юзкисы, может быть какие-то внутрикорпоративные, может быть какие-то игры те же самые и так далее.
3110.24 3121.36 "Анатолий Кулаков" Ну то есть JSON это самый отвратительный вариант из всех, но он самый общепринятый, самый кроссплатформенный, самый кросспризнанный, поэтому если вы не умеете ничего, естественно JSON.
3121.36 3128.24 "Анатолий Кулаков" Если вы хотя бы немножко задумываетесь о ресурсах, о перформансе, о производительности, не JSON.
3128.24 3132.20 "Игорь Лабутин" Я бы сказал чуть-чуть, может быть, по-другому.
3132.20 3149.28 "Игорь Лабутин" Я бы сказал, что любой API, который у вас выставляется наружу, если он, конечно, да, если вы пишете REST API, который будет использоваться всеми известными и только контролируемыми вами клиентами, там, конечно, творите, что хотите, можете даже не называть это REST.
3149.28 3162.24 "Игорь Лабутин" Но если вы выставляете внешний API наружу, то, несомненно, выставить его через JSON обязательно, потому что кто знает, кто там будет снаружи, да и как минимум в браузере иногда удобно дернуть где-то и посмотреть на вернувшийся JSON.
3162.24 3176.04 "Игорь Лабутин" Но если вы, да, понимаете, что у вас какие-то есть требования по производительности еще где-то, то дополнительно к этому правильно используйте заголовки про тип контента и, возможно, поддержите еще что-то.
3176.04 3199.96 "Игорь Лабутин" То есть мы, например, у себя все public API у нас выставлено наружу через JSON, конечно же, но некоторые endpoints, не все, принимают тот самый application msgpack и внутренние сервисы, когда они обращаются друг к другу между собой, они это делают все равно через public API, ну, потому что он уже есть и делает то, что нужно, но они делают это через msgpack, чтобы сэкономить время и на сериализацию, и на вообще объем передаваемых данных.
3199.96 3210.00 "Игорь Лабутин" Это нам резко все ускорило и при этом мы никак не затронули внешних наших пользователей, они все так же шлют, что они хотят JSON и получают свой JSON в ответ.
3210.00 3212.12 "Игорь Лабутин" Хотя он, конечно, нам раз в 10 больше по объему.
3212.12 3229.48 "Анатолий Кулаков" Ну и вообще, мне кажется, такой подход, он полностью нивелирует сам REST как таковой, потому что REST - это строгий набор правил, в котором написано, что мы должны использовать полный content negotiation, то есть не зависеть от какого-то нашего одного предпочтения.
3229.48 3234.84 "Анатолий Кулаков" У нас есть разные клиенты, и клиенты нам указывают свой content type, и мы должны с этим как-то работать.
3234.84 3235.84 "Анатолий Кулаков" Да.
3235.84 3246.24 "Анатолий Кулаков" Поэтому тут бы, знаешь, очень много в последнее время встречается людей, которые пишут, назовем это так, http API и кричат во все стороны, что у меня REST.
3246.24 3257.00 "Анатолий Кулаков" Что такое настоящий REST API, я думаю, это отдельная большая тема, и они тоже нам когда-нибудь, наверное, придется заговорить, не сейчас, иначе этот подкаст продлится еще на пару часов.
3257.00 3268.52 "Анатолий Кулаков" Но то, что автор настолько небрежно оперирует с терминами, настолько небрежно ссылается на какие-то непонятные предрассудки, это уже не располагает прямо с первых строк.
3268.52 3269.96 "Игорь Лабутин" Окей, пошли дальше.
3269.96 3273.76 "Игорь Лабутин" Use nouns instead of verbs in endpoint paths.
3273.76 3277.08 "Игорь Лабутин" Ну, то есть не используем глаголы в урлах.
3277.08 3297.20 "Игорь Лабутин" Тут мне кажется, что я в целом пытаюсь быть согласным, то есть когда мы дизайним наши API, в основном, конечно, мы стараемся использовать только существительные, но, к сожалению, все-таки у нас есть какое-то количество, ну скажем так, операций, которые не укладываются вообще в REST парадигму как таковую, ну и там мы начинаем использовать глаголы.
3297.20 3298.56 "Игорь Лабутин" Нам без этого не обойтись.
3298.56 3300.40 "Анатолий Кулаков" Да, мы все-таки стараемся держаться.
3300.40 3318.48 "Анатолий Кулаков" То есть действительно правило такое есть, действительно прошло из изначального REST, и в принципе мне кажется, что абсолютно любое предложение, любую операцию, любой метод можно представить в рамках тех глаголов, которых предоставляет сам HTTP, то есть get, post, put, и так далее.
3318.48 3346.24 "Игорь Лабутин" Но у нас это в основном касается очень долго идущих операций, у нас есть операции, которые могут идти минуты, и хочется иметь как бы, кругово говоря, мы используем глаголы для старта операции, получения статуса, это уже в REST формате, потому что статус это вполне себе стоит, и для cancel операции, то есть можно ее заканчилить снаружи, и это как бы не совсем стейт, можно сказать, там для этого используются отдельные пост-запросы с глаголами
3346.24 3356.92 "Анатолий Кулаков" в конце. Мы для cancel используем delete, хорошее тоже HTTP verb, а для поставки в очередь это обычный post, то есть добавление элементов в список задач.
3356.92 3369.08 "Игорь Лабутин" Ну, может быть, да, может быть мы такие еще немножко больше в RPC стайле мыслим, и у нас, ну мы не говорим, что у нас там полный REST, мы не RESTful ни разу, но тем не менее да.
3369.08 3372.80 "Игорь Лабутин" Если вы пытаетесь сделать хоть как-то похоже на REST, попробуйте использовать без глаголов.
3372.80 3384.00 "Игорь Лабутин" Дальше, name collections with plural nouns, то есть все там в урлах, вот у него есть пример там со статьями и с комментами к ним, то есть он говорит, что в урле должно быть /articles.
3384.00 3394.12 "Анатолий Кулаков" Тоже мне нравится этот подход, в принципе он пересекается с C#, у C# тоже коллекции принято называть как бы во множественном числе, а единичные свойства, единичные проперти в единственном числе.
3394.12 3402.96 "Анатолий Кулаков" И для REST, для url это тоже довольно-таки удобно, ты сразу понимаешь, есть там вложенность какая-нибудь, стоит тебе куда-то глубже копать или это какой-то конечный узел.
3402.96 3405.40 "Анатолий Кулаков" То есть мне нравится это правило, мы его используем.
3405.40 3418.20 "Игорь Лабутин" А вот смотри, такой вопрос, вот мы можем сказать get /articles, а если мы хотим взять 1, то мы говорим get /articles /1 или get /article /1?
3418.20 3424.24 "Анатолий Кулаков" Нет, articles /1, то есть в коллекции всех статей мы находим статью номер 1.
3424.24 3440.48 "Игорь Лабутин" Ну да, окей, с этим я согласен, потому что там в комментариях был представитель иного лагеря, который говорит, что урл должен намекать, так скажем, сколько там объектов может вернуться, если вы просите по IDшнику, то почему articles, он же там всегда 1.
3440.48 3441.48 "Игорь Лабутин" Ну в общем.
3441.48 3445.84 "Анатолий Кулаков" Интересная точка зрения, я в принципе с такой не сталкивался, но мне кажется, это уже извращение.
3445.84 3449.04 "Игорь Лабутин" Ну вот да, я тоже не сталкивался, мне стало интересно.
3449.04 3460.40 "Игорь Лабутин" Единственное, опять же, если вы будете читать эту статью, хочется предупредить, заголовок-то хороший, name collections, plural nouns, все правильно, но вот объяснение и аргументация у автора, она немножко странная.
3460.40 3472.84 "Игорь Лабутин" Он аргументирует это тем, что нужно так делать, потому что мы хотим быть consistent с тем, как мы таблички в базе называем.
3472.84 3475.80 "Игорь Лабутин" Вот таблички в базе называешь с плюралом или без плюрала?
3475.80 3477.64 "Игорь Лабутин" Кстати, тоже с плюралом, да.
3477.64 3501.48 "Игорь Лабутин" А вот у нас наоборот, у нас нет ни одной таблички с плюралом, у нас все таблички в единственном числе, несмотря на то, что понятно, что они хранят много данных, но вот в любом случае аргументация про то, что коллекции называйте так же, как у вас таблички в базе данных, мне кажется, какая-то не очень правильно, потому что API, ну это не про только CRUD в базе данных, это может быть всё, что угодно, и привязываться к базе данных вроде как не очень правильно.
3501.48 3515.96 "Анатолий Кулаков" Я согласен, и более того, я себя не считаю большим экспертом базы данных, то есть, может быть, мой стайл тоже противоречит основным тенденциям, но 100% никак не нужно завязывать ни вашу базу данных, ни тем более ваш язык программирования на то, каким образом будет выглядеть ваш API.
3515.96 3520.40 "Анатолий Кулаков" Ваш API - это что-то другое, это такое кроссплатформенное, кросс-языковое.
3520.40 3526.80 "Игорь Лабутин" Да, мне кажется, что база данных - это по-моему так и там, NCT Framework по дефолту делает, и как бы, и ладно.
3526.80 3531.40 "Игорь Лабутин" Нас просто мы, база создавалась еще до времен NCT Framework, поэтому таблички назывались руками.
3531.40 3544.52 "Игорь Лабутин" Следующий пункт - это вложенные ресурсы для объектов, которые иерархичны, то есть, если у нас есть статьи и у них есть комментарии, то, соответственно, будет article/1/comments.
3544.52 3546.56 "Игорь Лабутин" Делаем так, согласен?
3546.56 3547.76 "Игорь Лабутин" Да, здравый подход.
3547.76 3548.76 "Игорь Лабутин" А какие альтернативы?
3548.76 3560.64 "Игорь Лабутин" Альтернативы, к сожалению, ну, альтернативы можно говорить /articles/1, а если ты хочешь получить комменты, ты пишешь там /comments/article/1.
3560.64 3562.00 "Игорь Лабутин" Наверное, можно так придумать.
3562.00 3577.52 "Анатолий Кулаков" Ну, наверное, можно и так, и так, но, скорее всего, основной посыл этого пункта в том, что поддержим ли мы глубину больше, чем 1 или не поддержим, да, то есть, заканчивается у нас на /articles/1, или можно чем-то дальше углубиться и что-то еще запросить.
3577.52 3588.44 "Анатолий Кулаков" Мне нравится подход, когда действительно можно углубиться на произвольную глубину, насколько это поддерживает домен данного приложения, и пройти куда вам угодно, куда вам нравится.
3588.44 3606.68 "Игорь Лабутин" Да, но надо понимать, что вот так вот в глубину и идти можно, но это сильно зависит от домена, в том смысле, что в примере с статьями и с комментариями тут все более-менее очевидно, что комментарии - это явно ребенок от статьи, то есть, комментарий не может существовать сам по себе.
3606.68 3638.88 "Игорь Лабутин" Но очень часто у вас бывают 2 равноценные сущности, которые просто друг с другом как-то связаны, и тут, мне кажется, может быть и в одну сторону, и в другую, то есть, если бы, допустим, статьи и авторы статей, если у статьи может быть несколько авторов, то чтобы получить статьи, все статьи одного автора вы пишите там /authors/1/articles, а чтобы получить всех авторов одной статьи, вы пишите /articles/1/authors, и тогда у вас можно и так, и так, и это определяется вашей доменной областью.
3638.88 3652.68 "Анатолий Кулаков" И никто не сказал, что мы должны выбрать какой-то один путь, скорее всего, поддержка и того, и другого урла, они будут правильные и удобные, потому что каким-то клиентам удобно ходить к авторам через статьи, а каким-то наоборот, смотреть какие статьи у автора.
3652.68 3655.12 "Анатолий Кулаков" И мне кажется, поддержать нужно и то, и то.
3655.12 3665.12 "Игорь Лабутин" Да, интересный вопрос, нужно ли поддержать /articles/1/authors/2/articles, но вот это, кажется, дальше рекурсивно можно заходить очень далеко, но мне кажется, это уже перебор.
3665.12 3677.20 "Анатолий Кулаков" Да, и самое главное, что мы не имеем у нас на дотнете какого-то хорошего инструмента, какой-то хорошей тулзы, которая нам эту рекурсию иерархичную запилит, которая нам ее легко реализует.
3677.20 3681.20 "Анатолий Кулаков" Это все мы сейчас делаем как-то ручками, и это похоже на какой-то каменный век.
3681.20 3685.36 "Игорь Лабутин" Может быть, какой-нибудь там GraphQL ответом тебе будет?
3685.36 3689.12 "Анатолий Кулаков" Да, GraphQL, OData, они есть, но это, мне кажется, уже совсем про другое как-то.
3689.12 3696.28 "Анатолий Кулаков" Не про то, хотелось бы более низкоуровневые инструменты, которые вам позволят работать на уровне урлов, хендлеров и все.
3696.28 3698.52 "Игорь Лабутин" Посмотрим, что S/P/N команды придумают.
3698.52 3702.32 "Игорь Лабутин" Что-нибудь они должны придумать, не только про перформанс только думать, надо и про удобство подумать иногда.
3702.32 3703.32 "Игорь Лабутин" Поехали дальше.
3703.32 3708.92 "Игорь Лабутин" Handle errors gracefully and return standard error codes.
3708.92 3715.32 "Игорь Лабутин" Ну, вроде бы логичная рекомендация, как бы обрабатывайте ошибки и возвращайте стандартные error-коды, HTTP, естественно.
3715.32 3717.64 "Игорь Лабутин" Тут вроде бы вариантов особых нет.
3717.64 3721.40 "Игорь Лабутин" Хотя у меня вот есть интересный такой вопрос.
3721.40 3723.68 "Игорь Лабутин" Как ты к этому относишься?
3723.68 3731.16 "Игорь Лабутин" Вот смотри, предположим, ты пытаешься получить данные какого-то пользователя и у тебя к нему нет доступа.
3731.16 3736.12 "Игорь Лабутин" Ты вернешь 403 забрит, forbidden или 404 not found?
3736.12 3744.48 "Анатолий Кулаков" Если у этого пользователя есть права на чтение данных другого пользователя, то это not found и этого пользователя нет.
3744.48 3749.64 "Анатолий Кулаков" Если у этого пользователя нет прав на чтение этого пользователя, то это forbidden.
3749.64 3757.92 "Анатолий Кулаков" Обычно проверяется сначала права, сначала проверяется то, куда может доступиться, не превышен ли лимит у этого пользователя, валидный ли у него токен и так далее.
3757.92 3762.92 "Анатолий Кулаков" Обычно сначала проходят всякие security проверки и там forbidden вылетает первым.
3762.92 3770.28 "Анатолий Кулаков" Но уж если ему разрешили и он идет к ресурсу, и этого ресурса уже по этому адресу нет, то это уже not found.
3770.28 3773.28 "Игорь Лабутин" Смотри, теперь вопрос, не является ли это security дыркой?
3773.28 3786.84 "Игорь Лабутин" То есть, таким образом, грубо говоря, если, допустим, у тебя есть возможность получить, не знаю, детали пользователя по e-mail, ты можешь, посылая разные e-mail, получать, ага, вот на этого говорят forbidden, а на этого not found.
3786.84 3789.84 "Игорь Лабутин" То есть, тот, на которого сказали forbidden, такой e-mail в системе есть.
3789.84 3790.84 "Игорь Лабутин" Как с таким быть?
3790.84 3803.08 "Анатолий Кулаков" Вот мне кажется, как раз-таки в той системе, которую я описал, сначала проверяем на права, а потом уже сообщаем, раскрываем какую-то информацию о том, есть он или нет, вот этой security дырки должно не быть.
3803.08 3807.96 "Анатолий Кулаков" Потому что ты никогда не узнаешь, существует пользователь или не существует, если у тебя на это нет привилегий.
3807.96 3810.72 "Анатолий Кулаков" А если привилегии есть, то тогда в чем дырка-то?
3810.72 3811.72 "Анатолий Кулаков" Ты можешь легально это читать.
3811.72 3821.92 "Игорь Лабутин" Ну, то есть, мы говорим, что мы, допустим, если пользователь не какой-нибудь там супер админ, то… А, окей, все, я понял, хорошо.
3821.92 3827.68 "Анатолий Кулаков" Здесь можно привести аналогию с админом домена в операционной системе, в домене Windows.
3827.68 3837.64 "Анатолий Кулаков" Если у тебя есть права администратора, есть имя пользователя и пароль, ты заходишь в свой домен, то ты, естественно, можешь посмотреть всех юзеров в этом домене, можешь посмотреть список этих юзеров.
3837.64 3846.08 "Анатолий Кулаков" Если у тебя прав администратора нет, то ты даже не можешь узнать, существует в этом домене такой пользователь, которого зовут Вася, или не существует, для тебя эта информация закрыта.
3846.08 3856.08 "Анатолий Кулаков" Здесь точно так же, если ты смог пробиться через авторизацию и аутентификацию, то там уже может быть, у тебя есть права на просмотр всех пользователей, и здесь нет никакого секрета.
3856.08 3864.36 "Анатолий Кулаков" Если ты не смог через нее пробиться, то действительно, ты не должен иметь права узнать, существует такой пользователь или не существует, потому что это реально может быть security drawing.
3864.36 3866.20 "Анатолий Кулаков" У тебя не должно на это быть привилегий.
3866.20 3867.80 "Игорь Лабутин" Вот, кстати, да, смотри, такой вопрос.
3867.80 3878.64 "Игорь Лабутин" Ты администрируешь, допустим, подгруппу пользователей, да, ты там не суперадмин, а вот только группу пользователей, и ты спрашиваешь, ну, предположим, такая API, которая по e-mail пытается сказать, дать какие-то детали.
3878.64 3885.16 "Игорь Лабутин" А вот мне, ну, там пришел токен, где сказано, имею право администрировать такую-то группу.
3885.16 3891.20 "Игорь Лабутин" Понять, какую группу, ты как бы не сможешь, пока ты не поймешь, вообще этот пользователь в этой группе состоит или не состоит.
3891.20 3892.20 "Игорь Лабутин" Правильно?
3892.20 3894.36 "Игорь Лабутин" То есть вроде как 403 выдавать вроде как незачем.
3894.36 3903.96 "Анатолий Кулаков" Погоди, ты же должен сначала этого пользователя авторизовать, да, и вот интифицировать, попросить у него привилегии, попросить у него, то есть пароль, попросить у него имя.
3903.96 3912.40 "Игорь Лабутин" Да, ну, смотри, токен валидный, в токене там лежит claim, что он имеет право смотреть, там, не знаю, группу тех, кому разрешен Remote Desktop.
3912.40 3915.36 "Игорь Лабутин" Предположим, вот возвращаясь к доменной админке.
3915.36 3921.56 "Игорь Лабутин" Вот, и теперь ты спрашиваешь, входит ли пользователь Вася в группу, в которой можно админить Remote Desktop.
3921.56 3924.56 "Игорь Лабутин" Такой вот просто, там, user/group/remotedesktop/vasya.
3924.56 3932.40 "Анатолий Кулаков" Смотри, если ты админ группы Remote Desktop, то ты можешь посмотреть список всех пользователей, которые входят в группу Remote Desktop.
3932.40 3934.88 "Игорь Лабутин" Так, в чем вопрос тогда?
3934.88 3951.40 "Игорь Лабутин" Если я при этом спрашиваю, а, окей, хорошо, мы подразумеваем, что группу, все, я понял, то есть мы говорим, что группа Remote Desktop, она будет где-то в урле, получается, и тогда, естественно, очевидно, мы можем спокойно проверить, типа, да, все, я понял мысль.
3951.40 3952.40 "Игорь Лабутин" Да.
3952.40 3964.84 "Игорь Лабутин" Хорошо, то есть, по сути, для того, чтобы обеспечить нормальную security, нам нужно максимально подробную информацию, которая позволит как раз таки проверить всю эту самую security, обеспечивать, ну, либо в урле, либо в клеймах токена, либо еще где-то.
3964.84 3974.12 "Анатолий Кулаков" Да, то есть обычно в клеймах токена сообщается, что вот этот пользователь имеет право полностью отменить группу Remote Desktop, и на все другие группы у него нет прав.
3974.12 3979.56 "Анатолий Кулаков" Поэтому, что происходит в других группах, как существуют они или нет, какие у них пользователи, этого он не знает.
3979.56 3980.84 "Анатолий Кулаков" Но в своей группе список пользователей посмотреть,
3980.84 3984.36 "Игорь Лабутин" он может. Поэтому будет возвращаться, естественно, форбидно на все другие группы.
3984.36 3985.36 "Игорь Лабутин" Окей, хорошо.
3985.36 3987.96 "Игорь Лабутин" Ладно, еще есть у нас что-нибудь обсудить про ретурн-коды?
3987.96 3993.44 "Игорь Лабутин" Есть у тебя какие-нибудь там, скажем так, больные места именно по ретурн-коду?
3993.44 3994.44 "Анатолий Кулаков" В основном нет.
3994.44 4007.56 "Анатолий Кулаков" То есть идея действительно правильная, http-кодов их очень много, они есть практически под любую ситуацию, даже если вы внезапно оказались чайником, вы вполне можете это сообщить через отдельный http-код, который называется "Я чайник".
4007.56 4012.64 "Анатолий Кулаков" Поэтому, я думаю, каждый может найти любой код, который ему по душе.
4012.64 4013.64 "Игорь Лабутин" Супер.
4013.64 4014.64 "Игорь Лабутин" Следующий раздел.
4014.64 4020.12 "Игорь Лабутин" Разрешайте фильтринг, сортинг и постраничный вывод.
4020.12 4030.32 "Игорь Лабутин" То есть в вашем запросе в query options всегда должно быть там, как пофильтровать ваши результаты, как их посортировать обязательно и обязательно возможность выдачи постраничной.
4030.32 4047.36 "Анатолий Кулаков" Отличная рекомендация, да, я тоже с ней полностью согласен, если у вас есть хоть какой-то API, который возвращает коллекцию, и вы не можете заранее предсказать ее точно, что она будет очень маленького размера, а обычно вы никогда этого не можете предсказать, если вы там, не знаю, генум просто какой-нибудь выводите и все.
4047.36 4051.60 "Анатолий Кулаков" Тем более, если эта коллекция наполняется пользователем, значит она потенциально может быть бесконечного размера.
4051.60 4052.60 "Анатолий Кулаков" Вот.
4052.60 4065.40 "Анатолий Кулаков" Для этих целей обязательно должен быть постраничный вывод и желательно, конечно, фильтры, сортиринг, потому что это очень часто нужно для реализации какой-нибудь UI или каких-нибудь клиентских оптимизаций, чтобы не тащить все данные, а вытащить по какому-то фильтру.
4065.40 4079.52 "Анатолий Кулаков" Ну, опять же, смотри выше, в дотнете у нас нет какого-то удобного инструмента, чтобы это все сделать, исключая OData и GraphQL, чтобы такое менее тяжелое, более удобное, более очевидное, более понятное.
4079.52 4096.76 "Анатолий Кулаков" То есть я был бы счастлив, если бы это делалось все намного легче, вот так, как мы сейчас навешиваем роуты у наших контроллеров, так, как мы сейчас регистрируем всякие middleware, что-нибудь подобное сделать бы еще и для постраничных выводов, сортировок и так далее.
4096.76 4100.56 "Игорь Лабутин" Да, было бы прекрасно, к сожалению, пока такого нет.
4100.56 4107.92 "Игорь Лабутин" Ну, наверное, можно, кстати, что-нибудь попробовать с middleware и какие-нибудь хитрым equarable навернуть, если мы уверены, что внутри там equarable, но я боюсь, что это не так просто.
4107.92 4128.04 "Игорь Лабутин" И вот из-за всех этих неудобств у меня в проекте, мы сейчас используем немножко противоположный, можно сказать, подход, мы не делаем nepogenation, ну, фильтринг мы обычно знаем, какой может потребоваться, поэтому фильтринг мы стараемся делать, а вот nepogenation мы делаем только тогда, когда мы видим на практике реально, сколько там реально данных.
4128.04 4139.32 "Игорь Лабутин" Но нам позволяет это доменная область, то есть мы примерно знаем объемы данных в разных коллекциях и даже если пользователь может что-нибудь напихать, то мы примерно представляем, какого это объема может быть.
4139.32 4154.42 "Игорь Лабутин" Поэтому мы больше как бы в реактивном режиме работаем, если мы видим, что какое-то API начинает возвращать достаточно большую коллекцию и это занимает уже достаточно много времени, в том числе на передачу всего этого по сети, в браузер или куда-нибудь, то мы тогда, да, делаем пейджинг и все остальное.
4154.42 4172.30 "Анатолий Кулаков" Я думаю, как раз таки потому, что у нас существует такая проблема с инструментом, мы все так работаем, ну, то есть мы по дефолту делаем какой-то пустой контроллер, который не умеет там ничего кроме принимать параметры и отвечать, и если уж тогда припечет когда-нибудь, что нам нужна пейджинация, то уже тогда ее доворачиваем.
4172.30 4175.18 "Анатолий Кулаков" Вот хотелось бы, чтобы она была как-то по дефолту незаметно и удобно.
4175.18 4182.14 "Игорь Лабутин" Ну, опять же, все надежды на сплэнт команду, что они слушают наш подкаст, все услышат и сделают в ближайшем релизе буквально.
4182.14 4201.26 "Анатолий Кулаков" Ну, вообще-то у нас там все open source, комьюнити, все такое, какая сплэнт команда, пусть она занимается своими делами, пусть она оптимизирует битики с байтиками, а для того, чтобы делать удобный UI, для того, чтобы его как-то интересно внедрять, нужны инициативы, нужны интересные люди, нужны интересные идеи, поэтому все дружно садимся и покоим в удобный middleware.
4201.26 4207.22 "Игорь Лабутин" Ну, или не middleware, а какие-нибудь правильные атрибутчики на контроллер, и все это пытаемся убедить сплэнт команду, что это нам очень надо.
4207.22 4210.86 "Игорь Лабутин" Так, следующий заголовок - maintain good security practices.
4210.86 4223.66 "Игорь Лабутин" Тут все довольно-таки прозрачно, то есть тут про то, что всегда используется SSL, то, о чем мы с тобой уже поговорили, про permissions, проверяйте permissions, выделяйте как можно меньше ролей пользователя, ну и так далее.
4223.66 4224.66 "Игорь Лабутин" Тут вообще ничего, мне кажется, интересного.
4224.66 4238.46 "Анатолий Кулаков" Слушай, интересный вопрос, вот если у тебя есть два микросервиса, которые общаются внутри твоего корпоративного контура, то есть который спрятан за всевозможными firewall'ами, бренмаурами, антивирусами и прочим шелухой, зачем тебе SSL?
4238.46 4239.46 "Анатолий Кулаков" Зачем тебе HTTPS?
4239.46 4241.14 "Анатолий Кулаков" Зачем тебе security?
4241.14 4243.06 "Игорь Лабутин" Кажется, тут два варианта.
4243.06 4270.26 "Игорь Лабутин" Контуры бывают разные, то есть если ваше приложение там работает во внутри корпоративной сетки, например, но при этом как бы в эту же сетку имеет доступ, допустим, все сотрудники внутри, ну просто внутри локалки там стоит какой-то сервер и туда все что-то ходят, возможно, SSL имеет все-таки ценность, потому что произвольный сотрудник, ему будет чуть тяжелее перехватить трафик и посмотреть, что там происходит.
4270.26 4275.86 "Анатолий Кулаков" Если у тебя у сотрудников разрешен доступ в эту внутреннюю сеть, то значит они легально могут в нее проникать.
4275.86 4276.86 "Анатолий Кулаков" Да.
4276.86 4282.62 "Анатолий Кулаков" Значит, по идее, это их легальная работа, смотреть, что там происходит, смотреть, что происходит между серверами и как они общаются.
4282.62 4290.46 "Игорь Лабутин" Не, ну подожди, тот факт, что у меня сотрудники имеют право проникать в локальную сеть, не означает, что они право имеют читать мою почту, где я там, не знаю, пересылаю данные с контрактами.
4290.46 4291.46 "Игорь Лабутин" Согласен?
4291.46 4304.94 "Анатолий Кулаков" Вообще-то нет, потому что если у тебя сотрудник имеет доступ к твоему продакшн серверу, он может вполне подменить там сертификат тот же самый SSL, сделать man in the middle и прослушать твой трафик в любом случае.
4304.94 4305.94 "Анатолий Кулаков" Вот.
4305.94 4309.46 "Анатолий Кулаков" Или подменить бинари приложения на свои бинари приложения, которые ничего не будут шифровать.
4309.46 4310.46 "Анатолий Кулаков" Вот.
4310.46 4317.78 "Анатолий Кулаков" Если у тебя пользователь имеет доступ к твоему продакшн серверу, то там от него защищаться не нужно, я считаю, потому что он и так может сделать все, что захочет.
4317.78 4329.38 "Игорь Лабутин" А это правда, и я не говорю поэтому, что тебя SSL защитит, но это сделает все-таки чуть более сложным, просто как бы запустив в AirShark на сетке, посмотрите.
4329.38 4332.06 "Игорь Лабутин" Опять же, смотри, это то, с чего я начал.
4332.06 4334.26 "Игорь Лабутин" Зависит от того, что такое контур.
4334.26 4355.18 "Игорь Лабутин" То есть у нас сейчас мы приложение переносим в Azure, там будет выделенная сетка, ну там сейчас есть точнее выделенная сетка настроенная, куда имеет доступ очень мало народу, если вообще, хоть кто-то кроме самих App-сервисов, и там все это закрыто, естественно, Application Gateway, на котором делается SSL Termination, и внутри общения все идет только по HTTP.
4355.18 4360.30 "Игорь Лабутин" Но туда физически никто не сможет прийти, кроме там 3-4 доверенных лиц, грубо говоря.
4360.30 4364.46 "Игорь Лабутин" В таком случае HTTPS, конечно, там нафиг не сдался, и будет все только тормозить.
4364.46 4367.86 "Игорь Лабутин" Плюс надо сертификаты обновлять, ну короче, лишняя заморочка на ровном месте.
4367.86 4368.86 "Игорь Лабутин" Вот.
4368.86 4396.02 "Игорь Лабутин" Если же у меня есть какой-нибудь там, не знаю, сервер, который внутри корпоративной, во внутренней сетке, ну грубо говоря, как раньше было, да, там типа почтовый сервер у меня в сетке стоит, почтовый сервер все равно будет хорошо, чтобы использовалось HTTPS, потому что все на него ходят, на него самого зайти никто не может, но трафик-то к ним уходит от каждого клиентского компа, и чтобы я не мог посмотреть трафик соседа до какого-то важного сервера, неплохо бы, чтобы в этот сервер все-таки тоже было HTTPS.
4396.02 4401.18 "Анатолий Кулаков" Ну да, но здесь пример, знаешь, он ближе, его можно сравнить с mail-сервером в интернете.
4401.18 4413.90 "Анатолий Кулаков" Мы ходим в интернет к нашему mail-серверу, естественно, между мной и этим mail-сервером должно быть шифрование, чтобы, допустим, какой-нибудь провайдер тоже со мной не прослушал, или локальные пользователи в моей сети его не прослушали, вот.
4413.90 4424.06 "Анатолий Кулаков" Но если у тебя внутри корпоративный контур, где все пользователи, они контролируются, у всех есть привилегии, и эти привилегии уже выданы, то зачем обязательно их использовать?
4424.06 4431.10 "Игорь Лабутин" Нет, там обязательно не нужно, тут надо как бы определить это понятие внутри корпоративный контур.
4431.10 4461.70 "Игорь Лабутин" Мы вроде как с тобой понимаем, что это именно выделенный какой-то контур, куда есть доступ ограниченном количестве лиц, но если кто-то сделает упор на слово внутри корпоративный и скажет, что локальная сетка внутри предприятия это тоже, в конце концов, внутри корпоративный контур, ну куда имеет доступ все там 100, 150, 200, 300, сколько там человек народу в компании, тысяча, 10 тысяч, то как бы, если точно не определить, что такое внутри корпоративный контур, то в таком контуре, равном все локальные сетки я бы рекомендовал все-таки HTTPS использовать.
4461.70 4476.18 "Игорь Лабутин" Естественно, если он ограниченный с ограниченным списком допуска, то да, там HTTPS не нужен, но снаружи все равно нужен, поэтому SSL Termination на каком-нибудь там проксе либо гейтвее, что вы там используете, и дальше уже внутри можно HTTP, смело.
4476.18 4483.94 "Анатолий Кулаков" Смотри, я еще встречал такую интересную практику, которая немножко противоречит твоему утверждению, она, например, применяется в гугле.
4483.94 4503.62 "Анатолий Кулаков" В гугле люди рассчитывают, что по умолчанию вас взломали, то есть они стараются писать программы так, что как будто хакер проник в ваш внутрикорпоративный контур, он все взломал, он уже имеет там доступ хоть к чему-то, и надо пытаться защищаться изо всех сил, насколько нам можно.
4503.62 4516.54 "Анатолий Кулаков" Ну то есть именно поэтому внутри своих микросервисов, внутри своих дата-центров, они тоже весь трафик шифруют как раз из-за такой потенциальной угрозы, из-за такого потенциального вектора атаки, тоже хороший вариант для параноика, знаешь.
4516.54 4538.66 "Игорь Лабутин" Ну я думаю, что это сильно зависит от вашего бизнеса, если вы банк, то, наверное, имеет смысл это делать действительно везде и всюду, если вы как бы онлайн-магазин, ну надо смотреть, насколько вам это важно, возможно, крупным магазинам это очень важно, если вы личный веб-сайтик на трех микросервисах, ну, наверное, вам это не нужно.
4538.66 4547.18 "Игорь Лабутин" Все зависит от, скажем так, соотношения затрат на поддержку этого и потенциальных рисков, и бенефитов, которые вы получаете, как всегда.
4547.18 4548.18 "Игорь Лабутин" Да, пойдем дальше.
4548.18 4554.18 "Игорь Лабутин" Дальше тут остался последний, нет, еще не последний, кстати, пункт.
4554.18 4555.18 "Игорь Лабутин" Кэш.
4555.18 4556.18 "Игорь Лабутин" Кэш дата to improve performance.
4556.18 4561.62 "Игорь Лабутин" Кэшируйте все, что вы отдаете наружу, чтобы все это быстро отдавалось, если вас попросили еще раз.
4561.62 4565.58 "Анатолий Кулаков" Кэш - это хорошо, кэш - это нужно, самая главная проблема с кэшем...
4565.58 4566.58 "Анатолий Кулаков" Инвалидация.
4566.58 4567.58 "Анатолий Кулаков" Да, инвалидация.
4567.58 4574.86 "Анатолий Кулаков" Если вы четко понимаете, когда его нужно инвалидировать, когда это произойдет, и у вас не будет никаких с этим проблем, вы можете кэшировать, ну, конечно,
4574.86 4605.38 "Игорь Лабутин" кэшируйте, почему нет. Ну, да, такая же примерно идея, плюс кэширование, либо вам нужно точно знать, когда что инвалидировать, либо, если вы это делаете, допустим, примерно или там строго по каким-то тайм-аутам, это тоже в каком-то смысле точное знание, то надо быть готовым к тому, что система у вас все-таки, то, что называется, eventually consistent, то есть внутри у вас что-то уже могло поменяться, а пишка отдает все еще старое состояние, через 5 минут оно сменится, но нужно быть готовым, допустимо ли у вас в вашей системе такое.
4605.38 4617.22 "Анатолий Кулаков" Есть у меня к кэшу тоже одно негодование, это то ли баг, то ли фича протокола HTTP, заключается она в том, что кэшировать мы можем, грубо говоря, только GET.
4617.22 4641.06 "Анатолий Кулаков" И GET плох тем, что в его body нельзя передать какие-то значения, ну, то есть, по сути, вы не можете сделать GET с body, и поэтому, если у вас есть какой-то огромный, большой запрос, ну, представим, какой-нибудь SQL, SQL запрос вы запускаете на сервер, он на сервере там выполняется 10 часов и выдает вам какой-то ответ, вот, соответственно, вы не можете этот запрос закэшировать.
4641.06 4644.14 "Игорь Лабутин" Потому что ты его будешь запускать постом, конечно же, правильно?
4644.14 4655.06 "Анатолий Кулаков" Потому что GET действительно его запустить невозможно, потому что GET не может иметь body, он не может вот этот большой запрос принять, поэтому ты будешь запускать постом, пост не кэшируется и прочее, прочее, прочее.
4655.06 4668.90 "Анатолий Кулаков" Вот эта бага очень меня сильно раздражает, очень часто я на нём напарываюсь, и хотелось бы, конечно, чтобы её профиксили в протоколе, но так как уже приняли протокол HTTP/2, то, наверное, в HTTP/1 мы уже развития никакого не получим.
4668.90 4682.98 "Игорь Лабутин" Вряд ли, так как workaround баги, я так понимаю, является тогда уже просто своя собственная логика кэширования, то есть используем какой-нибудь RAIDs или вообще просто хоть in-memory кэш и внутри как-то локально аккуратно кэшируем на уровне контроллера.
4682.98 4700.58 "Анатолий Кулаков" Именно так, in-process это можно сделать, но хотелось бы воспользоваться, знаешь, глобальной распределённой сетью, CDN-ами и так далее по всему миру, чтобы некоторые вещи можно было закэшировать прямо непосредственно возле клиента, а не на своём приложении за 10 микросервисами, 50 фаерволами и какими-то лямбдами.
4700.58 4706.26 "Анатолий Кулаков" То есть это всё равно уже какие-то ресурсы были потрачены до того момента, пока ты дошёл до этого кэша.
4706.26 4708.38 "Игорь Лабутин" Да, пожалуй, соглашусь.
4708.38 4720.74 "Игорь Лабутин" У нас не так много кэширования, у нас всё строго, так сказать, должно быть никаких eventually, мы пока не готовы кэшировать, почти нигде не используем, но да, пожелания, конечно, прикольные.
4720.74 4721.74 "Игорь Лабутин" У нас вообще весь подкаст такой сегодня.
4721.74 4725.54 "Игорь Лабутин" Хотим то, хотим это, хотим вот ещё другого.
4725.54 4727.22 "Игорь Лабутин" Пошли, последний, обсудим.
4727.22 4729.14 "Игорь Лабутин" Это версионирование.
4729.14 4731.66 "Игорь Лабутин" Куда же мы без версионирования.
4731.66 4746.14 "Игорь Лабутин" Тут всё просто, автор рекомендует версионируйте, версионируйте, ну обычно версионируйте через v1, v2 в Url, хотя можно и header'ами, можно query option'ами, но как бы в Url он самый простой.
4746.14 4750.34 "Игорь Лабутин" И всё, вот вся рекомендация, версионируйте.
4750.34 4761.26 "Анатолий Кулаков" Возвращаясь к оригинальной посылке, что такое REST, у него это не просто какой-то набор правил, это вот реальный документ, реально существующий, реально описанный документ.
4761.26 4762.66 "Анатолий Кулаков" И у этого документа есть автор.
4762.66 4763.94 "Анатолий Кулаков" Автор зовут Роул Филдинг.
4763.94 4772.94 "Анатолий Кулаков" И у Роула Филдинга есть прекрасный твит, в котором он говорит, если вы засовываете версию в ваш Url, значит вы просто склали большой жирный болт на весь REST.
4772.94 4778.02 "Анатолий Кулаков" То есть вся суть REST как раз таки в том, что нельзя в Url указывать версию.
4778.02 4779.58 "Анатолий Кулаков" А где тогда, в header'е?
4779.58 4814.34 "Анатолий Кулаков" Это нужно указывать в header'е и более глубоко, то есть есть специальные header'ы для разных ситуаций, то есть в зависимости от того, поломали мы совместимость, не поломали мы совместимость, есть у нас тот же самый формат или мы перешли на новый формат, ну то есть в зависимости от того, что именно обозначает вот эта версия, то есть что именно вы хотите увеличить, почему вы что-то сломали, или если вы не сломали, то что вы перенесли или что вы оставили совместимым, в зависимости от этих ситуаций нужно делать, изменять те или иные эти header'а.
4814.34 4816.58 "Анатолий Кулаков" Вот это, наверное, лучше поговорить про тему уже
4816.58 4856.38 "Игорь Лабутин" REST. Ну окей, да, хорошо, давай мы сейчас не будем укрепляться, плюс версионирование темы такая, как мы обсуждали, по-моему, в каком-то из выпусков подкаста про вообще проблемы версионирования от Jonas Keita, и там было, конечно, про версионирование словом зависимости, но версионирование AP-шек тоже, я так понимаю, не самая простая область, так что да, версионируйте, простой способ через Urlay это не совсем REST или совсем не REST, если хотите более правильно RESTful, делайте через header'а, но опять же поддержка в S-Panel не очень хорошая, к сожалению, и одного и у другого, и поэтому так или иначе приходится приседать вручную.
4856.38 4874.42 "Анатолий Кулаков" Для версионирования есть отличная библиотека, которая может вам помочь сделать поддержку где угодно, там и в Urlay она умеет, и в header'ах, и ещё что-то, но самое печальное, что я забыл её название, наверняка наши слушатели помнят, знают, приходите в комменты и оставляйте, оставляйте название библиотечки, оставляйте комментарии.
4874.42 4903.66 "Игорь Лабутин" Да, ну на этом статья заканчивается, так что в целом заголовки все правильные, практически, аргументация каждого из этих заголовков местами достаточно спорная, будете читать статью, почитайте обязательно комментарии, там есть довольно много полезных мыслей, в том числе противоречащих основному посылу статьи, но лучше иметь несколько вариантов, так скажем, мнений и выбирать уже из них, как-то смотря на аргументы тех сторонников, того или другого.
4903.66 4906.38 "Игорь Лабутин" Что-то мы с тобой засиделись, Игорь, пора закругляться.
4906.38 4915.82 "Игорь Лабутин" Давай будем закругляться, давай тогда вспомним, о чём мы сегодня поговорили, мы говорили мы сегодня долго, так что лучше, наверное, напомнить всё то, что мы прошли.
4915.82 4928.74 "Игорь Лабутин" Начали мы с нашего YouTube канала, ну точнее он не совсем прям наш радиодотнетный, но дотнетрушный, так что заходите, оставляйте комментарии, лайк, шер, репост, как там это правильно сейчас говорить модно.
4928.74 4943.50 "Игорь Лабутин" Посмотрели на новинки дотнет 5, новые target framework, то, как мы будем таргетить наши сборки и куда исчезнет стандарт и чем нам это всё грозит.
4943.50 4949.42 "Игорь Лабутин" Посмотрели на новые Visual Studio 2019, новинок не так много, но они есть.
4949.42 4957.10 "Игорь Лабутин" Обсудили производительность Regex'ов и опять же, что за импровизируем дотнет 5, и посмотрели на оптимизацию Рюджита.
4957.10 4959.62 "Игорь Лабутин" После этого переключились на TULI.
4959.62 4982.54 "Анатолий Кулаков" Прошлись по новой фиче райдера динамика программ-анализис, посмотрели на Message Pack версии 2, какие оптимизации он принёс, какие улучшения он сделал по предыдущей версии, обсудили WASM-мер и WebAssembly, и то, какие инструменты существуют вокруг этого, кроме Blazor, и пробежались быстренько по best practices REST API, и обсудили, что каждый использует.
4982.54 4994.78 "Анатолий Кулаков" И будем с терпением ждать ваших замечаний, может быть, у вас какие-то другие подходы, другие best practices, и они имеют под собой какие-то практические полезности, какие-то бенефиты, тоже расскажите.
4994.78 4999.42 "Игорь Лабутин" И на этом мы закругляемся, оставляйте все ваши фидбэки, мы будем очень рады.
4999.42 5009.74 "Анатолий Кулаков" А чтобы удобнее было вам оставлять фидбэки, чтобы у вас было больше стимула, а также в честь открытия нашего YouTube-версии, нашей видеопрезентации, я предлагаю вам небольшой конкурс.
5009.74 5015.70 "Анатолий Кулаков" Мы разыграем 2 лицензии от JetBrains, да нет, давайте 3, 3 лицензии от JetBrains.
5015.70 5030.70 "Анатолий Кулаков" Первая лицензия будет разыграна среди тех участников, кто отставит под этим видео в YouTube полезный комментарий о нашем подкасте, какую-нибудь критику или похвалу, или что угодно, что вам придет в голову.
5030.70 5037.86 "Анатолий Кулаков" Вторую лицензию от JetBrains получит тот, кто нажмет "Share" в нашем посте ВКонтактике с этой новостью.
5037.86 5044.90 "Анатолий Кулаков" И третью лицензию от JetBrains получит тот, кто нажмет "Like" в нашем посте с этим анонсом ВКонтактике.
5044.90 5047.94 "Анатолий Кулаков" Победители будут выбраны с помощью рандома.
5047.94 5054.26 "Анатолий Кулаков" Участников мы будем регистрировать в течение 1 недели, в течение 7 дней после выпуска этих анонсов.
5054.26 5063.54 "Анатолий Кулаков" Итак, еще раз, анонс ВКонтакте, там можно получить лицензию рандомно, если вы нажмете "Like" или "Share", или комментарий в YouTube.
5063.54 5067.58 "Анатолий Кулаков" Там лицензию вы тоже получите рандомно среди тех, кто прокомментировал.
5067.58 5069.54 "Анатолий Кулаков" Конкурс действует 7 дней.
5069.54 5072.26 "Анатолий Кулаков" А за 7 - все.
5072.26 5073.34 "Анатолий Кулаков" Всем спасибо, всем пока.
5073.34 5082.38 "Анатолий Кулаков" Писать нам можно по-прежнему на старые адреса - radiosobaka.net.ru и найти все выпуски по url - radio.dotnet.ru.
5082.38 5083.38 "Анатолий Кулаков" До новых встреч.
5083.38 5083.58 "Анатолий Кулаков" Всем пока.
5083.58 5111.58 "Анатолий Кулаков" ПОДПИШИСЬ НА КАНАЛ!
