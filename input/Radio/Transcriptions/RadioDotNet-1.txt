0.00 11.24 "Анатолий Кулаков" Здравствуйте, дорогие друзья! Мы все-таки решили записать первый выпуск Radio.net, и сегодня в студии для вас будут работать Анатолий Кулаков и Игорь Лабутин. Всем привет!
11.24 43.60 "Анатолий Кулаков" Мы решили собраться вместе и пообсуждать новости, которые у нас накопились за это время, и заодно поэкспериментировать с форматами. От вас, соответственно, хочется какого-нибудь фидбэка и пожеланий, в какую сторону и как мы должны развиваться или двигаться. И одной из самых больших новостей, наверное, за все это время, пока мы с Игорем не виделись, это был анонс .NET 5. Как раз на днях мне попался твит Карла Зигмута, который наконец-таки сказал, что .NET 5 все-таки бранчнулся.
43.60 47.20 "Анатолий Кулаков" На GitHub он теперь стал мастером, насколько я понял, да, Игорь? Я прав?
47.20 87.28 "Игорь Лабутин" Да, отбранчились мы, я тебя немножко поправлю, все-таки версию 3 пока еще, .NET 5, к сожалению, пока не готов, но я надеюсь над этим работает, команда в Майкрософте, но да, мастер теперь стал версии .NET 5, пока, к сожалению, там нет практически никакой активности, кроме собственно, имения версии, и то, если я правильно помню, не во всех репозиториях это сделано, потому что все силы сейчас, конечно же, направлены на версию 3.0, которая обещается заревизиться в сентябре этого года. Мы очень надеемся, что после этого, наконец-таки, будет проводиться работа над версией 5, которую мы все ждем. А пока мы далеко не ушли в обсуждение
87.28 104.44 "Анатолий Кулаков" версии 5, вот насчет бранча, то есть действительно отбранчивался версия 3, и в мастере сейчас осталась версия 5. Вот, я посмотрел как раз Коммит, который эти изменения внес, вот, как ты думаешь, сколько изменений требуется внести в репозиторий .NET, чтобы перейти на новую версию?
104.44 121.48 "Игорь Лабутин" Во все репозитории, если я правильно помню, у нас сейчас .NET собирается там из, не помню, десятка репозиторий разных, но я думаю, что Коммит-то, наверное, один на каждой репозитории, а вот сколько файлов с ним надо поменять, ну, предположим, штуки три.
121.48 137.88 "Анатолий Кулаков" Да, я сейчас говорю про CoreFX, конечно, репозиторий, вот, но самое печальное, что поменять пришлось 18 файлов, вот этот человек в 18 файлах пошел и проставил метки, что это теперь .NET 5, .NET 5, .NET 5, .NET 5, вот, как тебе уровень автоматизации, нормально вообще?
137.88 148.48 "Игорь Лабутин" Ну, мне кажется, прекрасно, особенно если это все были какие-нибудь билдскрипты или еще что-нибудь такое, это, или же они до сих пор держат отдельный версию NCS в каждом NCS-продже?
148.48 152.00 "Анатолий Кулаков" Нет, нет, это все, естественно, в билдскриптах, но их все равно огромное количество,
152.00 218.72 "Игорь Лабутин" почему это не одно место, репозиторий-то один? Ну, потому что, во-первых, работы много, но все, рук не хватает, работать не трогай, а версия .NET поднимается, к сожалению или к счастью, видимо, очень редко, и поэтому потратить сколько-то времени, раз в N месяцев, а то и лет, ну, в принципе, можно, хотя, конечно, это может быть еще эффектом от той работы, которую Microsoft сделала в течение этого года, особенно это было видно по ASP-репозиториям, они довольно большую работу провели по объединению репозиториев, то есть, если мы посмотрим на open-source-ные все репозитории Microsoft где-нибудь год назад, ASP, я, по-моему, пытался его собрать у себя на машинке, мне требовалось чекаутить что-то около то ли десятка, то ли 15 репозиторий, потому что базовый ASP в одном, билдскрипты для него в другом, там какой-нибудь MVC в третьем, раутинг в четвертом, и вот это вот все. Они провели большую работу по объединению этого всего в чуть-чуть репозиториев, и может быть это просто следствие.
218.72 227.76 "Игорь Лабутин" Все скрипты потаскали из всех прошлых репозиториев, и вот теперь они все пока еще живут в общей кучке и не унифицированы. А может, действительно, это никому не надо,
227.76 243.40 "Анатолий Кулаков" но можно закинуть pull-request. Да, наверняка, хорошее место для оптимизации. Ладно, давай далеко не отвлекаться, все-таки обсудим, что такое .NET 5. Он вроде не такая большая новость, про него уже были анонсы довольно-таки давно, но можно вкратце пробежать для тех, кто почему-то
243.40 308.44 "Игорь Лабутин" пропустил. Ты можешь нам рассказать вообще, что это? .NET 5 - это на самом деле такой немножко, для меня это такой немножко забавный момент, мы опять пытаемся вернуться к ситуации, когда у нас есть один .NET фреймворк. То есть если смотреть в далекую историю, когда-то был один единственный .NET фреймворк, потом он где-то форкнулся в ротор shared source, который нельзя было ни для чего использовать, кроме как почитать. Потом стали писать альтернативные моно, потом появился форк основного .NET фреймворка в виде .NET Core, весь этот зоопарк стал развиваться каждый своим путем в каком-то смысле, но в какой-то момент стало понятно, что зоопарк зоопарком, но допустим, в библиотеке между всеми разработчиками шарить-то хочется. То есть если есть какая-то общая, общеполезная библиотека, то писать ее в 5-6 фреймворках, рентаймах, таргетах, смысла нет.
308.44 322.36 "Анатолий Кулаков" Вот, мне все время это что-то напоминает, как будто мы это уже видели, там какие-то shared library, .NET стандарт, и теперь еще .NET 5, что-то мы каждый год объединяемся, объединяемся, объединяемся, объединяемся, сколько можно. Сколько еще осталось? Осталось немного, потому что
322.36 335.60 "Игорь Лабутин" как раз-таки когда поняли, что хочется писать что-то общее, придумали тот самый .NET стандарт, который ты упомянул. Это по сути просто сборник интерфейсов со словами, если платформа поддерживает .NET стандарт в какой-то версии, значит она поддерживает реализацию всех этих интерфейсов.
335.60 386.28 "Игорь Лабутин" Другое дело, что часть этих реализаций будут кидать платформу .NET Supported, но интерфейс поддержан. Так получилось. И в какой-то момент поняли, и так точнее так сложилось, что .NET Core, как один из самых прогрессивных и быстроразвивающих фреймворков, получил такое количество новых фич, это там спаны и другие штуки, которые потребовали в том числе поддержки рентайма, что стало понятно, что очень тяжело вне стандарта включать все эти новые штуки и опять получается, что вроде все расходится. Поэтому, а портировать их обратно в .NET Framework это сложно, нужно менять рентайм и все такое прочее. Поэтому в какой-то момент Microsoft приняла решение, что не будет у нас больше .NET Framework, не будет .NET Core, не будет Mono, не будет ничего другого, будет один универсальный
386.28 397.36 "Анатолий Кулаков" фреймворк .NET 5. Но все-таки нужно заметить, что .NET 5 это именно фреймворк .NET Core. Несмотря на название, по которому, наверное, было бы логичнее предположить, что это форк .NET большого,
397.36 420.44 "Игорь Лабутин" это все-таки .NET Core. Это естественное продолжение .NET Core, а число 5 было выбрано для того, чтобы оно было заведомо больше всех версий фреймворка, которые оно будет заменять. Ну вот с Mono немножко не получилось, у Mono сейчас уже пятая, если я правильно помню, версия, но Mono все-таки немножко сотняком стоит и называется по-другому, поэтому тут, надеюсь, никаких коллизий не будет.
420.44 447.76 "Игорь Лабутин" Но действительно это развитие .NET Core, в который перетасили, скажем так, часть функциональности .NET Framework в версии .NET Core 3, как то WPF, WinForms, и за счет этого можно сказать, что покрыли, сложно сказать какой процент, но довольно, наверное, большой процент всех тех, кто жил на втором фреймворке и теперь может переходить на .NET Core 3, когда он зареализится. Вот по планам .NET 5 он
447.76 460.24 "Анатолий Кулаков" должен покрыть Desktop, Web, Cloud, Mobile, Gaming, IOT, Artificial Intelligence и много-много чего еще. Ну то есть действительно такая глобальная какая-то реструктуризация происходит всех фреймворков.
460.24 512.04 "Игорь Лабутин" Надо сказать, что в каком-то смысле это будет несколько, надеемся, что это будет упрощением, потому что сейчас, как мне кажется, довольно многие путают, кто где какой фреймворк что поддерживает, а главное, при чем здесь нет стандарт и вообще как оно все это с чем связано и какую версию нет стандарта кто поддерживает. Это на самом деле непросто. И на что таргетить ваши ноги от пакета и вот это все. Есть надежда, ну не надежда, но подозрение, что .NET стандарт как стандарт будет абсолютно не нужен, когда будет .NET 5, потому что .NET 5 будет один и, собственно, больше к нему ничего не нужно. Но возможно это все-таки далекое будущее, когда перестанут, так скажем, поддерживать обычный фреймворк, а про поддержку .NET 4.8, последнего фреймворка полного, Microsoft говорит, что оно будет поддерживаться, ну если не вечно, то очень долго. Да, теперь все ваши приложения,
512.04 567.48 "Анатолий Кулаков" которые работают на последнем 4.7 фреймворке, станут легкостью. Ну не теперь, а когда он выйдет. Поэтому задумывайтесь о том, чтобы переезжать уже на Core. И результатом того, что это смежилось с Mono, в принципе, у него есть некоторые интересные фишки. Например, .NET 5 получит прозрачную интерабельность с Java и с Objective-C. Вот казалось бы, чего нам реально в жизни не хватало в повседневной разработке, это вот эти глупости. Это пришло к нам из-за того, что Mono прекрасно умеет поддерживать эти технологии из-за своего мобильного направления, и, соответственно, это перетечет в большой .NET. Также нам подоспеют WebAssembly, Blazor и прочие-прочие вещи. Кстати говоря о Blazor. Переедет в .NET 5 не все. Стоит особенно упомянуть три больших технологии, из-за которых бомбануло большинство интернета. Во-первых, это ASP.NET WebForms.
567.48 587.92 "Игорь Лабутин" Игорь, ты писал когда-нибудь вообще на WebForms? К счастью, нет. Я как-то мир в веб-разработке, меня обошел стороной в начале, в начале, так скажем, моей карьеры, и моя область всегда была десктопа и немножко сервер API, но оно было на WCF, про которое мы еще поговорим. Вебформы меня
587.92 631.88 "Анатолий Кулаков" не коснулись никак вообще. Вот я тоже так на уровне ознакомления. Помню, что это была, может быть, даже хорошая идея. То есть, если вы имеете опыт с обычными вебформсами, вы можете точно так же набросать контроллы на веб-страничку, и у вас практически точно так же по онклику образуются события, в которых вы можете писать код. То есть, чтобы десктоп-разработчикам легко можно было переманить веб. И у этого были очень большие минусы, которые, в принципе, поначалу казались не такими большими, но в конце концов они убили эту технологию. Ну, не будем о грустном. Microsoft советует менять эту технологию на SPNet Blazor. Blazor - это фреймворк, который основан на WebAssembly, которое тоже еще недалеко от релиза. Blazor далек от релиза, и не очень понятно, как бедным
631.88 643.36 "Игорь Лабутин" интерпретерам сейчас на это все переходить. Пока никак сидеть на 4C или где там еще поддержаны веб-форумы и ждать, ждать, ждать, во что превратится Blazor. Да, да, ты прав. Вот,
643.36 647.64 "Анатолий Кулаков" следующая технология, которая с нами не переедет - это Microsoft Workflow. Ну, с Workflow ты хоть
647.64 693.12 "Игорь Лабутин" работал? Ты удивишься, но нет. Единственное мое перечтение с Windows Workflow Foundation произошло на самом деле на конференции году, так, в 2013, где я слушал доклад про то, как делать persistence на Windows Workflow, ну, то есть, как сохранять все эти состояния, там, кастомный persistence и вот это все. И у меня есть принцип, не принцип, на каждой конференции я стараюсь сходить на какой-нибудь один, как минимум один доклад, который мне кажется совершенно не по моему профилю. Вдруг узнаю что-нибудь новое. Или вдруг это окажется полезным, точнее. Так я узнал про Windows Workflow на той конференции, это, пожалуй, был не самый полезный для меня доклад, так он мне не пригодился никогда. Хорошо, я с Workflow, наверное, сталкивался
693.12 713.40 "Анатолий Кулаков" один-единственный раз, когда писал кастомный Workflow для TFS. Многие не знают, но Workflow очень много используется в микрософтических продуктах, таких как, там, SharePoint, тоже самый TFS-сервер и многие-многие других вот под капотом для людей, которые ничего не соображают в программировании, для них накидать квадратики это вообще сущеедилие.
713.40 729.56 "Игорь Лабутин" О, так подожди, тогда я два раза сталкивался, нет, в TFS я настраивал билды вот этими квадратиками, да, Build Definition, это был 2012, наверное, TFS или какой-то такой, ну, короче, какой-то очень древний, да, наверное, тогда был Workflow Foundation, окей, я что-то сделал, но мышкой.
729.56 762.00 "Анатолий Кулаков" Вот видишь, оказывается полезная технология, ты ее использовал, даже не знал, что она так сложно называется. Супер. Рекомендации по ней, это сейчас есть open-source fork, называется он CoreWF, его можно использовать, его можно поддерживать, его можно чекинить, поэтому если кому-то нужно, можно на это смотреть. И самое обидное, самое бомбящее весь интернет, самое бурлящее и прожигательное - это, конечно, WCF. WCF, сервисы тоже никуда не переедут, на них решили жестоко забить.
762.00 804.40 "Игорь Лабутин" Игорь, WCF ты хоть касался? О, WCF - это примерно 5-6 лет моей работы, я как бы не могу сказать, что я профессионал и знаю все про WCF, но я знаю очень много, и я очень много чего писал кастомного под него, и у нас до сих пор полпродукции на этом работает, поэтому WCF - это важная штука, и тот факт, что в .NET Core хотя бы завезли клиентскую часть, очень сильно нам помогает в переезде на .NET Core, потому что те части, которые уже переведены на .NET Core, оттуда по крайней мере можно подергать WCF на и существующие сервисы, и это более-менее хорошо работает. А вот серверной части там нет, к сожалению.
804.40 808.28 "Анатолий Кулаков" Мне тоже кажется, что это одна из полезных технологий, которые почему-то выбросили.
808.28 815.44 "Анатолий Кулаков" Ну, почему понятно, об этом мы, может, поговорим в следующий раз, были естественные весьма вертикальные причины, но больше всего мне поразила рекомендация о переходе.
815.44 830.12 "Анатолий Кулаков" Они говорят, пользуйтесь gRPC. Вот мне кажется, что когда люди, у которых 5 лет на WCF и разработок, смотрят это gRPC, и у них в голове возникает немой вопрос, что, как это заменяет, как на это можно переехать, что с этим делать и с какой стороны к этому подходить.
830.12 832.96 "Анатолий Кулаков" То есть рекомендация какая-то издевательская, как мне кажется.
832.96 856.12 "Игорь Лабутин" Я допускаю, что на самом деле какие-нибудь не очень сложные WCF-контракты и вообще endpoints перевести на gRPC, наверное, получится. Но если мы говорим про всякие сессии, транзакции и вот это всё, то это, конечно, да, это всё мимо, и это всё нужно реализовать самому.
856.12 860.32 "Анатолий Кулаков" Я думаю, несложные вещи и на простой WPPI уже давно люди перевели.
860.32 865.64 "Анатолий Кулаков" Фишка WCF и в том, что там очень сложные вещи на ней написаны.
865.64 918.48 "Игорь Лабутин" Ну, это с одной стороны, с другой стороны, фишка WCF - это всё-таки скорость, это бинарная сериализация, никакого тебе HTTP, то есть он там может быть, но там могут быть и TCP-шные протоколы быстрые, и gRPC в этом смысле, в этой части, мною видится как замена, то есть внутри продуктовая, так скажем, коммуникация, то есть между микросервисами, скажем, или ещё как-то. Наверное, там это как-то может взлететь, но опять же, зависит от сложности взаимодействия. Если это просто Request-Reply, ну, то есть RPC тот самый, наверное, да, если что-то более сложное, проблема даже не в том, что как-то сложно переходить, проблема в том, что такой переход требует переделки архитектуры, во многом, как мне кажется. Если раньше у меня были транзакции из коробки в WCF, я знаю, что распределённые транзакции - это сложно, плохо, но они есть, архитектура на этом построена, а теперь их нет, надо всё перестраивать, поэтому дорого.
918.48 939.52 "Анатолий Кулаков" Да, как альтернатива Microsoft OpenSource WCF, репозиторий называется Core WCF, поэтому можно, в принципе, развивать, не слезать и продолжать им пользоваться, большая группа энтузиастов уже приступила над работой по его поддержке, портированию и улучшению.
939.52 953.92 "Игорь Лабутин" Будем надеяться, что всё-таки это во что-то влезет. Хотя, вполне допускаю, что если они не сделают это очень быстро, ну, быстро - это не в горизонте года, скажем, то, может быть, все уже успеют перейти на что-то другое.
953.92 960.36 "Игорь Лабутин" И тогда это будет, ну, действительно, незаслуженно, а может и заслуженно, не знаю, можем поговорить потом.
960.36 966.96 "Игорь Лабутин" Забытая технология, которую в очередной раз оставили где-то на обочине прогресса, скажем так.
966.96 974.08 "Анатолий Кулаков" Да, давай сильно не задерживаться. По датам хотелось сказать, что .NET Core 3, как многие, наверное, знают, у нас выходит в сентябре.
974.08 981.88 "Анатолий Кулаков" Если всё хорошо, то 3.1 LTS будет в ноябре, а .NET 5 как раз-таки планируют на 2020 год.
981.88 991.28 "Игорь Лабутин" Да, причём LTS - это Long Term Support, и дальнейшие планы, Microsoft говорит, что каждые 2 года будет входить Long Term Support.
991.28 999.60 "Игорь Лабутин" Соответственно, есть шансы, что существенные большие апгрейды между LTS можно будет делать раз в 2-3 года.
999.60 1004.28 "Игорь Лабутин" По крайней мере пока. Но это планы. Как будет на самом деле, посмотрим через годик.
1004.28 1018.52 "Анатолий Кулаков" Ну ладно, давай чуть поближе к реальности, скоро выходит, релизится .NET Core 3, и недавно была заносена интересная штука, которая называется Self-Contained Single Executable.
1018.52 1020.72 "Анатолий Кулаков" Можешь рассказать примерно, про что это?
1020.72 1043.32 "Игорь Лабутин" Да. Во-первых, вся идея .NET Core была в том, что оно всё кроссплатформенно, оно всё независимо от принстального фреймворка, и поэтому уже в первых версиях .NET Core была возможность либо требовать установки .NET Core рантайма, либо же поставлять с собой весь рантайм вместе с вашим приложением.
1043.32 1055.52 "Игорь Лабутин" Это было круто и здорово, но была проблема. Вместе с вашим приложением объёмом 5 мегабайт или 20 мегабайт, вы тащили с собой ещё 200 мегабайт фреймворка.
1055.52 1060.72 "Игорь Лабутин" При том, что по факту использовали вы из него хорошо, если 3, а то и меньше.
1060.72 1068.64 "Анатолий Кулаков" Ну и чисто эстетически перед вами была папочка, в которой находятся 2 миллиона файликов, и таскать её с собой не очень красиво, тем более век.
1068.64 1074.68 "Анатолий Кулаков" Всяких гошных программ, которые приносят один экзешничек, с помощью которого все радуются жизни.
1074.68 1081.48 "Анатолий Кулаков" А здесь у вас целая папка непонятных файлов. В принципе, это олдскульно, деды наши тоже так делали, но всё же это уже не очень красиво выглядит.
1081.48 1091.52 "Игорь Лабутин" Да, поэтому теперь можно в новой версии говорить, что мы теперь будем паблишить это всё в одну экзешку.
1091.52 1099.40 "Игорь Лабутин" Есть специальный ключик у команды DotNet Publish, и вам в результате на выходе будет одна единственная экзешка.
1099.40 1106.44 "Игорь Лабутин" Она будет большая, потому что в ней будет лежать весь фреймворк, но зато она одна, и станет легче, не правда ли?
1106.44 1124.28 "Анатолий Кулаков" Да, то есть вы можете таскать с собой фреймворк, и у этого ещё есть один замечательный плюс, в том, что вы не будете конфликтовать или не будете зависеть от установок, те, которые есть уже на целевой машине, то есть у вас всегда будет свой собственный известный фреймворк, с известными патчами, с известной версией, и вы точно на нём умеете запускаться и умеете ранить.
1124.28 1125.40 "Игорь Лабутин" Это почти докер.
1125.40 1127.76 "Анатолий Кулаков" Да, действительно, докер больше не нужен после этого.
1127.76 1135.16 "Игорь Лабутин" Ага, вот. Докер нужен ещё что-то, к сожалению, например тот же SQL Server, что-то в одну экзешку пока не пакуют. Я бы с радостью...
1135.16 1139.08 "Анатолий Кулаков" Это потому что просто не было такой возможности. Сейчас появилось, я думаю, упакуют.
1139.08 1145.80 "Игорь Лабутин" Это было круто, запускать SQL Server просто вот одним, без всей этой кучи тулов и всё такого.
1145.80 1152.12 "Игорь Лабутин" Но на этом жизнь не останавливается. Одна экзешка хорошо, но, как мы сказали выше, она большая.
1152.12 1164.24 "Игорь Лабутин" Поэтому, кроме того, мы знаем, что DotNet Core Framework в своём текущем виде - это огромное количество нудет-пакетиков, в которых лежит довольно-таки много, но очень иногда небольших файликов.
1164.24 1170.84 "Игорь Лабутин" И великие шансы, что на самом деле вы в вашем продукте, в вашей программе не используете все.
1170.84 1176.56 "Игорь Лабутин" Поэтому возникает разумное желание выкинуть на самом деле все лишние файлы.
1176.56 1178.76 "Игорь Лабутин" Вы можете это делать уже сейчас руками.
1178.76 1190.56 "Игорь Лабутин" В принципе, никто не мешает. Если вы точно знаете, что вы какой-нибудь там System.Dot что-нибудь не используете, то его можно просто удалить. Никто вам ничего не скажет из того самого аутпута, который вы поставляете пользователю.
1190.56 1195.92 "Игорь Лабутин" Но это уже сделает сложнее, когда вы поставляете одну экзешку, надо ещё найти, что там удалить внутри.
1195.92 1199.64 "Игорь Лабутин" А во-вторых, надо понимать, что удалять. А это не всегда очевидно.
1199.64 1220.00 "Игорь Лабутин" И теперь в новой версии вот в превьюшке, если я правильно помню, в превью 6 или 7, вышло обновление собственного утилита .NET, в которой появилась новая опция - Publish Trimped Output, которая сама анализирует в код вашей программы, начиная от мейна, и удаляет все дейлики, на которые вы не ссылаетесь.
1220.00 1229.08 "Анатолий Кулаков" Если говорить про цифры, то один экзешник у нас раньше был 70 МБ, с полным включением в себя всех фреймворков под одну хардварную платформу.
1229.08 1232.64 "Анатолий Кулаков" Теперь после обработки этого инструмента он становится 30 МБ.
1232.64 1236.12 "Игорь Лабутин" Это Hello World, да? Да, это Hello World.
1236.12 1240.84 "Игорь Лабутин" То есть вот у вас получается, вместо 70 МБ рантайма, вы сейчас тащите с собой 30. Уже неплохо.
1240.84 1244.04 "Игорь Лабутин" Но можно, в принципе, сделать ещё лучше.
1244.04 1248.76 "Игорь Лабутин" И эта штука, она на самом деле, я так понимаю, есть в мире JavaScript.
1248.76 1253.68 "Игорь Лабутин" Я не очень знаю, есть ли она в других платформах типа Java.
1253.68 1261.44 "Игорь Лабутин" А именно, по большому счёту, в каких-то дейликах, например, в Amscore Lib, главная дейлика наша в дотнете, есть куча кода, которые вы тоже не используете.
1261.44 1263.44 "Игорь Лабутин" И его бы тоже было неплохо удалить.
1263.44 1265.44 "Игорь Лабутин" Но это уже изменение самих дейлик.
1265.44 1270.44 "Анатолий Кулаков" То есть в рамках одной дейлики мы половину кода используем, половину не используем.
1270.44 1273.68 "Анатолий Кулаков" Это тоже большое расточительство, когда мы говорим о таких мелких цифрах.
1273.68 1277.44 "Игорь Лабутин" Ну да, я не верю, что нам нужен 30 МБ для того, чтобы вывести строчку в консоль.
1277.44 1283.04 "Игорь Лабутин" Пусть хорошо, там нужен garbage collector, хорошо, там нужен JIT-компилятор, но всё-таки как-то что-то много.
1283.04 1288.64 "Игорь Лабутин" Вот. И у нас есть шансы получить такую функциональность, на самом деле, даже в dotnet core.
1288.64 1292.64 "Игорь Лабутин" Я не уверен, что это будет в третьей версии, скорее всего это уже дождётся версии 5.
1292.64 1294.64 "Игорь Лабутин" Потому что у нас есть Mono.
1294.64 1303.04 "Игорь Лабутин" В Mono эта проблема стоит ещё больше, потому что там итоговая EXE, или не EXE, а что там у нас получается в результате, улетает на мобильники.
1303.04 1307.64 "Игорь Лабутин" А на мобилках места не так много, и там за каждый МБ, в принципе, было бы неплохо поэкономить.
1307.64 1314.44 "Игорь Лабутин" Поэтому в Mono есть клёвая штука, напоминающая мне мир Cypress Plus, потому что она называется волшебным словом "линкер".
1314.44 1326.64 "Игорь Лабутин" Она умеет при сборке вот той самой единой EXE-шки удалять как раз-таки уже il-код из ваших длелек, который не используется. И таким образом ещё уменьшать размер файла.
1326.64 1332.04 "Игорь Лабутин" И, наверное, можно даже 30 МБ ещё срезать. Но пока я не экспериментировал, не знаю, насколько.
1332.04 1334.04 "Анатолий Кулаков" Да, звучит отлично.
1334.04 1341.04 "Анатолий Кулаков" Слушай, ещё у Core 3 будет такая прекрасная штука, которая называется Async Enumerable.
1341.04 1344.04 "Анатолий Кулаков" Async Enumerable — это поддержка асинхронных стримов.
1344.04 1346.04 "Анатолий Кулаков" Зачем это может понадобиться?
1346.04 1352.04 "Анатолий Кулаков" Например, представьте, что вы захотели считать какой-нибудь файлик, считать его с жёсткого диска.
1352.04 1358.04 "Анатолий Кулаков" Естественно, вы как продвинутый человек не будете это делать с помощью синхронных операций, а вызовете асинхронную вещь.
1358.04 1369.04 "Анатолий Кулаков" А теперь представьте, что вы, как настоящий любитель линку и .NET-чик, любите читать файлики, фильтровать контент и делать какие-то маппинги в выборке с помощью линку.
1369.04 1376.04 "Анатолий Кулаков" Раньше вы такое не могли сделать, потому что линку работал с обычными статическими Enumerable коллекциями.
1376.04 1382.04 "Анатолий Кулаков" А в асинхронные стримы, то есть асинхронные файлики, асинхронные операции, у нас требовали таску и вейтов, и всё, что с этим связано.
1382.04 1389.04 "Анатолий Кулаков" У Microsoft Channel 9 вышел видосик, в котором Бард Эсмет рассказывает, что Microsoft делает по этому поводу.
1389.04 1392.04 "Анатолий Кулаков" Они работают над таким проектом, который называется Async Streams.
1392.04 1410.04 "Анатолий Кулаков" Async Streams - это новый интерфейс iAsyncEnumerable, который также за собой тащит небезызвестный iAsyncDisposable, который помогает вам использовать линку запроса, линку агрегатора, линку фильтра, и всё это с асинхронными операциями, то есть операциями, которые работают с тасками.
1410.04 1430.04 "Игорь Лабутин" Да, то есть всё, что вы раньше писали в linq-стайле, либо с использованием языка запросов linq, либо экстенджер-методами, fluent-синтексисом, вы можете теперь вместо исходной inNumerable прямо подставить asyncEnumerable, и оно волшебным образом заработает, если вы просто зарефилинируете новые Nuget-пакеты к систему linq-async.
1430.04 1435.04 "Игорь Лабутин" Он всё ещё в превью, потому что работа не закончена, но вы уже можете сделать это сейчас.
1435.04 1443.04 "Игорь Лабутин" И темплятор всё это волшебным образом переварит, и всё будет работать асинхронно, без задержек, и вообще не занимая ваш процессор.
1443.04 1471.04 "Анатолий Кулаков" Мне ещё понравилось, что ребята из Reactive Extension уже подхватили эту штуку, то есть они уже заменяют свои внутренние реализации, которые они делали для того, чтобы поддержать асинхронные стримы, потому что в Reactive Extension эта концепция была довольно-таки давно, но она была сделана на своих интерфейсах, она была сделана на своих понятиях, на своих концепциях, вот, они подхватили эту штуку, и теперь в Reactive Extension с версии 4 уже будет поддержка асинхстримов.
1471.04 1493.04 "Игорь Лабутин" Да, а ещё, что мне понравилось в этой библиотеке новой, что они стали довольно активно использовать такую тему как value-tasks, потому что, скажем, если мы возьмём такую, ну, обычную операцию linq-q, как var, которую фильтрует, она, по идее, берёт элементы из коллекции по одной штуке.
1493.04 1501.04 "Игорь Лабутин" И если за каждой штукой мы будем создавать новую таску, ну, мне кажется, с памятью у нас будут проблемы, в смысле с объёмом доступной памяти.
1501.04 1523.04 "Игорь Лабутин" Поэтому там вовсю используются новые value-tasks, и всё там очень оптимизировано, здорово работает, и я надеюсь, что я не буду видеть уже такое огромное количество создаваемых у меня в продукте при работе энумераторов, которые боксятся, ещё что-нибудь делают, и, в общем, всё это будет, да, работать не очень употребляя память, быстро и не занимая процессор. Прям отличное будущее.
1523.04 1531.04 "Анатолий Кулаков" Ещё, бегая по репозиторию .NET, я обнаружил классную штуку, которую, в принципе, мы давно мечтали, давно обсуждали.
1531.04 1537.04 "Анатолий Кулаков" Это event-каунтеры. Это как раз-таки класс, который помогает нам сделать кроссплатформенные performance-каунтеры.
1537.04 1538.04 "Анатолий Кулаков" Я правильно понимаю?
1538.04 1552.04 "Игорь Лабутин" Да. На Windows-платформе, если вам нужно было каким-то образом выставить информацию о том, насколько живо ваше приложение, традиционным способом, в старых времён считается, ну, наверное, даже единственным практическим способом является performance-каунтер.
1552.04 1567.04 "Игорь Лабутин" То есть, по сути, это некоторое именованное число, которое по некоторому стандарту можно сабвить в Windows, а потом любой другой клиент может, тоже используя стандартный достаточно интерфейс, получить это значение по имени.
1567.04 1571.04 "Анатолий Кулаков" Самое главное преимущество этого подхода в том, что оно безумно быстрое.
1571.04 1577.04 "Анатолий Кулаков" При нескольких тысячах метрик оно даже не влияет на производительность той программы, которая пишет или читает эти метрики.
1577.04 1597.04 "Игорь Лабутин" Да, с одной стороны, да, с другой стороны, performance-каунтеры обладают огромным количеством очень тонких моментов, и в частности, оно, конечно, с одной стороны безумно быстро, но с другой стороны, созданный свежий каунтер, нельзя дергать сразу, потому что его значение обновится только через какой-то определенный интервал, там, в пределах секунды, но тем не менее.
1597.04 1612.04 "Игорь Лабутин" Поэтому оно, да, но оно не очень было здорово, и на самом деле, вся эта поддержка основана на реестре, поэтому для меня, на самом деле, в каком-то смысле удивительно, что оно работает настолько быстро, но тем не менее работал.
1612.04 1624.04 "Анатолий Кулаков" Ну, на реестре оно основано только внешне, по правде, там, в этом API стоят злобные гвозди, которые говорят, что если это реестр и это performance-каунтер, то они идут совсем по другому пути, потому что действительно работа с самим реестром, она очень медленная.
1624.04 1637.04 "Игорь Лабутин" Ну тогда, значит, это тем более прибиты жестко гвоздями не только к реестру, но еще и к Windows, и поэтому, когда у нас появился bootnet-корд, у нас, естественно, исчезла возможность использовать performance-каунтеры, но появилась потребность в какой-то замене.
1637.04 1642.04 "Игорь Лабутин" Какая-то замена достаточно долго ждала своего часа, и вот, наконец-таки, у нас теперь она появилась.
1642.04 1654.04 "Игорь Лабутин" Появилась она не просто так, то есть, если просто сделать event-каунтеры, это, конечно, хорошо, но нам нужен какой-то протокол, транспорт, чтобы сообщать эти самые метрики, каунтеры, к клиентам.
1654.04 1674.04 "Игорь Лабутин" И тут на Windows есть вполне естественный выбор, event-tracing for Windows, это очень быстрый kernel-based framework, который быстро умеет доставлять ивенты клиентам, если они есть, и если их нет, то практически не оказывает никакого воздействия на вашу программу.
1674.04 1678.04 "Анатолий Кулаков" На Linux тоже есть такой транспорт, который называется LTNG.
1678.04 1689.04 "Игорь Лабутин" Или LTTNG. Я каждый раз путаю, кто он там. Мне кажется, NG - это что-то про new generation, наверное, но я не уверен. Linux-tracing - что-то там, new generation. Но я не Linux-специалист, возможно, я не прав.
1689.04 1706.04 "Игорь Лабутин" И да, в DotNet Core в итоге сделали так, чтобы не завязываться на ETV, они поменяли идеологию trace-sources, это класс, который вам позволяет генерить ETV-евенты, так что он работает кросс-проформенно, скажем так.
1706.04 1713.04 "Игорь Лабутин" А поверх этого механизма event-sources, trace-sources, они как раз сделали event-counter.
1713.04 1717.04 "Игорь Лабутин" То есть, по сути, event-counter - это просто небольшой класс, который умеет принимать в себе метрики.
1717.04 1722.04 "Игорь Лабутин" Метрики в данный момент - это исключительно числа типа double, и больше ничего с именем.
1722.04 1728.04 "Игорь Лабутин" И он умеет делать некоторую агрегацию внутри себя, то есть считать минимум, максимум, средний, отклонение.
1728.04 1737.04 "Игорь Лабутин" И заданной частотой, частота ждается слушателям, эти усредненные агрегированные числа посылать, собственно, этим самым слушателям.
1737.04 1739.04 "Игорь Лабутин" Таким образом это все и работает.
1739.04 1750.04 "Игорь Лабутин" Я пока еще не пробовал эту штуку, но есть подозрение, что в скором времени придется, потому что мы как раз сейчас основаны на performance-counters, и нам не очень нравится то, как они работают.
1750.04 1754.04 "Игорь Лабутин" Возможно, это повод как раз попробовать новую штуку. Тем более, что у нас есть .NET Core.
1754.04 1759.04 "Анатолий Кулаков" Да, вот .NET Core. Существует global tools, который называется .NET counters.
1759.04 1766.04 "Анатолий Кулаков" Это консольная утилита, которую вы можете поставить у себя и запустить с помощью нее чтение любых event-counters.
1766.04 1770.04 "Анатолий Кулаков" Она имеет очень приятный консольный интерфейс.
1770.04 1776.04 "Анатолий Кулаков" Здесь вы можете задать небольшие фильтры. Она несложная, понятная, красивая.
1776.04 1787.04 "Анатолий Кулаков" Конечно, не сравнится с графическими интерфейсами performance-counters, но зато cross-платформенная и дает все шансы для того, чтобы вырасти в какие-то другие библиотеки, обрасти какими-то гуевыми tools.
1787.04 1792.04 "Анатолий Кулаков" Тут хочется еще отметить, что это именно замена performance-counters на Windows.
1792.04 1808.04 "Анатолий Кулаков" Это метрики, которые требуют очень высокой производительности и нужны именно для того, чтобы ваше приложение на каких-нибудь низкоуровневых вещах, таких как обращение к dictionary, количество закэшированных элементов, или количество сборок мусора, или такие вещи мерить.
1808.04 1811.04 "Анатолий Кулаков" Настоящие бизнес-метрики никуда не деваются.
1811.04 1818.04 "Анатолий Кулаков" Они у нас, как раньше, писались в какие-то высокоуровневые среды мониторинга, типа Influx, Datadog, Prometheus и так далее.
1818.04 1821.04 "Анатолий Кулаков" Так и продолжают писаться. У них с cross-платформенной сетью обычно не бывает проблем.
1821.04 1835.04 "Игорь Лабутин" Да, все так. Так что, если вам интересно покопаться в том, как теперь современный .NET репортит всю свою информацию о себе и попробовать из вашего приложения тоже что-то такое зарепортить, то посмотрите на event-counters.
1835.04 1838.04 "Игорь Лабутин" За ними, видимо, будущее платформы .NET Core.
1838.04 1846.04 "Игорь Лабутин" Толя, ты сказал, когда описывал .NET Tools, очень классную фразу, что у него приятный консольный интерфейс.
1846.04 1861.04 "Игорь Лабутин" И вот тут мне хотелось бы немножко про это поговорить, потому что я на самом деле несколько поражаюсь, сколько, интересно, усилий уходит у команды .NET на то, чтобы по сути единственного приложения, .NET.EXE,
1861.04 1866.04 None это же по сути одно единственное приложение, написать такой развесистый command-line интерфейс.
1866.04 1868.04 "Игорь Лабутин" Как вам вообще такое удается?
1868.04 1874.04 "Анатолий Кулаков" Вся концепция Global Tools подразумевает то, что у тебя не все команды, они включаются в .NET.EXE.
1874.04 1881.04 "Анатолий Кулаков" У тебя ставятся какие-то дополнительные утилиты, которые через команду .NET.EXE, по правде, запускаются внешние сторонние .EXE-файлы.
1881.04 1886.04 "Анатолий Кулаков" То есть это получается какая-то такая система плагинов для бедных, система плагинов для консольных команд.
1886.04 1888.04 "Анатолий Кулаков" Сам .NET.EXE, он по правде не очень умеет.
1888.04 1890.04 "Анатолий Кулаков" Он очень много делегирует.
1890.04 1894.04 "Игорь Лабутин" Понял, понял. Потому что как-то тема Global Tools, она немножко...
1894.04 1902.04 "Игорь Лабутин" То ли я пока не очень много в .NET Core именно работаю, то ли еще почему-то она как-то пока не очень сильно мимо меня.
1902.04 1911.04 "Игорь Лабутин" Точнее, она как-то наоборот очень сильно мимо меня проходит, и я все по стариночке вижу в студии, обычно без онлайна делаю.
1911.04 1920.04 "Анатолий Кулаков" Я думаю, мы про это еще как-нибудь поговорим, потому что вообще консольные приложения, консольные утилиты, они сейчас набирают вторую популярность, после того, как даже виндузятников заставили изучить Linux.
1920.04 1923.04 "Анатолий Кулаков" Это такая еще одна хайповая тема.
1923.04 1926.04 "Анатолий Кулаков" И почему-то они очень близки к сердцам разработчиков.
1926.04 1934.04 "Анатолий Кулаков" Я не знаю, может, это, конечно, только те разработчики, которые застали там Cubasic, Pascal, DOS и прочие консольные игры.
1934.04 1936.04 "Анатолий Кулаков" Посмотрим, что скажет будущее поколение.
1936.04 1940.04 "Анатолий Кулаков" Но пока консольным интерфейсам выделяется довольно-таки много времени.
1940.04 1946.04 "Анатолий Кулаков" И вот недавно Скотт Хансельман у себя в блоге опубликовал интересную библиотечку.
1946.04 1952.04 "Анатолий Кулаков" Это проект тоже команды .NET, которые экспериментируют с команд-лайновым интерфейсом.
1952.04 1954.04 "Анатолий Кулаков" Проект называется DragonFruit.
1954.04 1960.04 "Анатолий Кулаков" Это способ парсить ваши входные аргументы в консольных программах.
1960.04 1962.04 "Игорь Лабутин" О, еще один из тысячи, да?
1962.04 1965.04 "Анатолий Кулаков" Именно так, потому что очень много в интернете есть библиотечек.
1965.04 1971.04 "Анатолий Кулаков" Я думаю, это одна из тех тем, которые каждый уважающий себя разработчик должен сам написать.
1971.04 1979.04 "Анатолий Кулаков" То есть создать самую универсальную, самую удобную и самую reusable-бальную среду для парсинга аргументов командной строки.
1979.04 1983.04 "Анатолий Кулаков" И действительно, мне казалось, что мы уже приблизились к такому какому-то идеалу.
1983.04 1989.04 "Анатолий Кулаков" Вот действительно есть у нас библиотечка, от которой уже много-много форков, которая уже в принципе не имеет смысла как называется.
1989.04 1994.04 "Анатолий Кулаков" Но если вы вспомните, как вы последний раз парсили аргументы командной строки, наверняка вы ее вспомните.
1994.04 1998.04 "Анатолий Кулаков" Обычно вы описываете какой-то классик, который вам должна эта утилита заполнить.
1998.04 2006.04 "Анатолий Кулаков" Помечаете его специальными атрибутами, которые должны показывать этой утилите, какие поля, какими значениями нужно заполнять.
2006.04 2008.04 "Анатолий Кулаков" Вот, и она все за вас делает.
2008.04 2011.04 "Игорь Лабутин" Да, все так делают. А можно что-то новое придумать.
2011.04 2013.04 "Анатолий Кулаков" Теперь я понял, что да.
2013.04 2021.04 "Анатолий Кулаков" Если вы посмотрите на этот проект, то в принципе он берет многие концепции из этой утилиты, но доводит их до более естественного состояния.
2021.04 2027.04 "Анатолий Кулаков" То есть теперь вы, например, можете прямо в методе main у себя описать все параметры, которые вам нужны.
2027.04 2030.04 "Анатолий Кулаков" Ну, допустим, это легче всего сравнить с каким-нибудь конструктором.
2030.04 2036.04 "Анатолий Кулаков" Когда у вас есть контейнер, вы у себя в конструкторе просто-напросто описываете те зависимости, которые вы хотите получить.
2036.04 2039.04 "Анатолий Кулаков" И все. Вы не заморачиваетесь тем, откуда и как они к вам придут.
2039.04 2041.04 "Анатолий Кулаков" Здесь концепция точно такая же.
2041.04 2044.04 "Анатолий Кулаков" Вы в методе main прямо пишете то, что вы хотите получить.
2044.04 2053.04 "Анатолий Кулаков" Вы хотите получить булевый флажок, какую-нибудь строку с путем, какой-нибудь еще оператор, который нужно вызвать по мере того, как программа закончится и так далее.
2053.04 2062.04 "Анатолий Кулаков" То есть для вас специально сгенерировали скрытый метод main, который все это распарсит, проанализирует ваши input-аргументы и передаст вам в ваш метод main уже распаршенные проверенные аргументы.
2062.04 2069.04 "Анатолий Кулаков" А если они вдруг почему-то не все будут заполнены, или пользователь введет их неправильно, то для пользователя выведется help.
2069.04 2084.04 "Анатолий Кулаков" А help возьмется из XML-документации, которую вы напишите как раз к вашему main-методу, в котором вы опишите все параметры, которые вы принимаете, которые удобно для вас отформатируются и покажутся в зависимости от того хоста, на котором происходит этот вывод.
2084.04 2086.04 "Игорь Лабутин" Вообще звучит волшебно.
2086.04 2093.04 "Игорь Лабутин" На первый взгляд, как обычно, кажется, что это, наверное, очень клево будет работать для каких-то простых случаев.
2093.04 2102.04 "Игорь Лабутин" В сложном случае, наверняка, это все равно будет нужно размечать много-много атрибутов, что этот требуется, этот не обязательно, или этот, или эти два обязательно вместе.
2102.04 2105.04 "Игорь Лабутин" Но если присутствует третий, то можно обязательно четвертый.
2105.04 2110.04 "Игорь Лабутин" То есть вот такие случаи, наверное, все-таки придется старым добрым методом порасить.
2110.04 2117.04 "Анатолий Кулаков" Да, безусловно, от этого ты никуда не едешься, потому что у тебя действительно бывают случаи, которые просто так атрибутами или обычным код-конвенционом не покроются.
2117.04 2124.04 "Анатолий Кулаков" И этот инструмент интересен тем, что простые вещи он делает просто, а сложные вещи тебе придется делать не сложнее, чем везде.
2124.04 2131.04 "Анатолий Кулаков" То есть тебе не должен отгородить кучу атрибутов, кучу каких-то непонятных классов, если ты просто захочешь запросить два параметра в командной строке.
2131.04 2135.04 "Анатолий Кулаков" Что, скорее всего, покрывает 90% всех утилит командной строки.
2135.04 2140.04 "Игорь Лабутин" Да, вообще в целом видно ориентацию Microsoft на Common Line.
2140.04 2145.04 "Игорь Лабутин" Действительно, вот эта вот штука, терминал новый, который они там делают, пилят.
2145.04 2147.04 "Игорь Лабутин" Видимо, да, Linux как-то на это все влияет.
2147.04 2151.04 "Игорь Лабутин" Но Linux с Linux, баш, я надеюсь, нам изучать не придется.
2151.04 2154.04 "Игорь Лабутин" Можно ограничиться PowerShell.
2154.04 2156.04 "Игорь Лабутин" PowerShell старый добрый, там особо изменений никаких нет.
2156.04 2165.04 "Игорь Лабутин" Я вот, признаться для себя, у него выходят какие-то новые версии, но я сходу не назову отличие, там, 4-й от 5-й, какая сейчас у нас последняя.
2165.04 2166.04 "Игорь Лабутин" 6-я.
2166.04 2168.04 "Анатолий Кулаков" Давайте я как раз краткий introduction дам.
2168.04 2170.04 "Анатолий Кулаков" В общем, на виндах сейчас последняя версия, это 5-я.
2170.04 2172.04 "Анатолий Кулаков" Она, в принципе, всем прекрасна.
2172.04 2176.04 "Анатолий Кулаков" Если у вас есть возможность, то обновляйте ваши системы на нее и используйте ее.
2176.04 2179.04 "Анатолий Кулаков" В ней уже есть много чего интересного.
2179.04 2185.04 "Анатолий Кулаков" Ну, самое главное, там есть поддержка классов, то есть C# разработчики там себя чувствуют довольно-таки уютно.
2185.04 2187.04 "Анатолий Кулаков" Практически с полным ООП.
2187.04 2191.04 "Анатолий Кулаков" Но самая замечательная, самая интересная версия, это 6-я.
2191.04 2197.04 "Анатолий Кулаков" 6-я версия PowerShell, она появилась благодаря тому, что появился .NET Core как кроссплатформенная среда разработки.
2197.04 2207.04 "Анатолий Кулаков" Так как PowerShell полностью написан на .NET, его портировали, и теперь PowerShell тоже стал кроссплатформенным, он запускается на Linux, Mac, Vindah и так далее.
2207.04 2213.04 "Анатолий Кулаков" И недавно был анонсирован PowerShell Global Tools, который мы уже сегодня не один раз упоминали.
2213.04 2219.04 "Анатолий Кулаков" Это что означает? Это значит, вы с помощью команды .NET стал, можете поставить в себя на компьютере PowerShell.
2219.04 2223.04 "Анатолий Кулаков" Этот PowerShell будет той именно версией, которой вы захотите.
2223.04 2226.04 "Анатолий Кулаков" Он будет в том окружении, где вы захотите.
2226.04 2234.04 "Анатолий Кулаков" И, соответственно, вы можете таскать PowerShell с собой, без всяких сложных инсталляционных пакетов, без всяких сложных заморочек с реестрами, установками и так далее.
2234.04 2238.04 "Анатолий Кулаков" Это теперь появляется отдельная портабельная клевая оболочка.
2238.04 2240.04 "Игорь Лабутин" Небось еще и одним файликом.
2240.04 2241.04 "Игорь Лабутин" Скорее всего.
2241.04 2244.04 "Игорь Лабутин" Это вообще будет шикарно. Супер, здорово, приятно.
2244.04 2249.04 "Анатолий Кулаков" По крайней мере, после того, как третий .NET Core Z лезется, я думаю, не обязательно такое сделают.
2249.04 2257.04 "Анатолий Кулаков" А еще отличная новость заключается в том, что теперь в стандартный Docker образ .NET SDK включен PowerShell по умолчанию.
2257.04 2267.04 "Анатолий Кулаков" Это значит, что когда вы будете готовить свои Docker файлы, там вам не нужно больше мучиться с ваш синтаксисом, с помощью которого вы наполняете свой Docker файл и конфигурируете его.
2267.04 2272.04 "Анатолий Кулаков" Вы можете указать команду pwsh и вся мощь PowerShell в вашем распоряжении.
2272.04 2280.04 "Анатолий Кулаков" Можете свои Docker файлы стряпать из PowerShell, находясь в полной уверенности, что он там есть, у него актуальная версия, и вы полностью можете его использовать.
2280.04 2282.04 "Анатолий Кулаков" Эта штука сейчас в превью.
2282.04 2287.04 "Анатолий Кулаков" По-моему, ее включили в превью 4, но скоро она будет доступна во всех Docker образах.
2287.04 2289.04 "Игорь Лабутин" Ну, вообще, прекрасно.
2289.04 2303.04 "Игорь Лабутин" Общий тренд, видимо, зависит от влиятельного специфика, а может и нет, на тренд на то, что теперь не надо ничего именно ставить старыми добрыми инсталлерами, а так просто берешь иглешечку и все работает.
2303.04 2305.04 None Звучит вообще приятно.
2305.04 2315.04 "Игорь Лабутин" Не думал я, что года 4 назад так оно будет, настраивая какой-нибудь свой ноутбук и ставя на него 30-40 программ, которые тебе нужны для работы.
2315.04 2318.04 "Игорь Лабутин" Окей, это было все у нас.
2318.04 2319.04 "Игорь Лабутин" Это мы все еще обсуждаем.
2319.04 2324.04 "Игорь Лабутин" Обсуждаем DotNet 5 и все, что вокруг него, или DotNet Core 3, скорее, все, что вокруг него.
2324.04 2326.04 "Игорь Лабутин" Да, новинки от Микрософта.
2326.04 2331.04 "Игорь Лабутин" Много их у нас оказывается, хотя казалось бы, еще даже релиза не было.
2331.04 2332.04 "Игорь Лабутин" Что же будет, когда релиз будет?
2332.04 2337.04 "Игорь Лабутин" Там, наверное, еще что-нибудь нам успеют за оставшиеся пару месяцев показать интересненького.
2337.04 2340.04 "Игорь Лабутин" Но, наверное, надо двигаться дальше.
2340.04 2343.04 "Игорь Лабутин" Что у нас есть еще пообсуждать?
2343.04 2346.04 "Анатолий Кулаков" Слушай, есть статья к Джона Скита.
2346.04 2348.04 "Анатолий Кулаков" В принципе, немаленький такой документ.
2348.04 2350.04 "Игорь Лабутин" Джон Скит обычно пишет хорошие статьи.
2350.04 2352.04 "Анатолий Кулаков" Да, подробные.
2352.04 2354.04 "Анатолий Кулаков" "Version Limitation in DotNet".
2354.04 2357.04 "Анатолий Кулаков" Он вернулся к проблеме "Вечный как мир".
2357.04 2361.04 "Анатолий Кулаков" Какие у нас есть проблемы с версионированием, и как мы будем с ними дальше жить.
2361.04 2362.04 "Анатолий Кулаков" Именно так.
2362.04 2369.04 "Игорь Лабутин" DLLHell, я как будущий C++ разработчик, DLLHell, 20+ с рантаймом, и все вот это вот.
2369.04 2374.04 "Анатолий Кулаков" Согласись, что в принципе в DotNet DLLHell немножко поменьше, чем в C++.
2374.04 2383.04 "Игорь Лабутин" Для меня в DotNet DLLHell начался, когда команда DotNet попробовала System.NET.http выпустить в виде отдельного Nuget.
2383.04 2389.04 "Игорь Лабутин" Комбинация нужных тебе Binding Redirect это была некая такая магия.
2389.04 2397.04 "Игорь Лабутин" Потому что сборка выкидывала в Output то версию 4.2, то версию 4.0, а от чего у тебя что-то зависело было вообще непонятно.
2397.04 2400.04 "Игорь Лабутин" То есть, к счастью, они потом сами признали, что была фигня.
2400.04 2403.04 "Игорь Лабутин" Но я понял, что в DotNet тоже не все хорошо.
2403.04 2406.04 "Анатолий Кулаков" Согласен с тобой. Это было эпично, конечно.
2406.04 2408.04 "Анатолий Кулаков" Ладно, давай поближе к скиту.
2408.04 2410.04 "Анатолий Кулаков" О чем статья, собственно?
2410.04 2411.04 "Анатолий Кулаков" Как мы живем сейчас?
2411.04 2416.04 "Анатолий Кулаков" Сейчас, в принципе, мы все стараемся придерживаться Semantic Version, где у нас есть в основном три цифры.
2416.04 2418.04 "Анатолий Кулаков" Major, Minor и Patch.
2418.04 2420.04 "Анатолий Кулаков" То есть, Major цифру — это первая.
2420.04 2424.04 "Анатолий Кулаков" Мы меняем только, если у нас произошел какой-то страшный breaking change.
2424.04 2427.04 "Анатолий Кулаков" Minor мы меняем только, если мы добавили какую-то фичу.
2427.04 2429.04 "Анатолий Кулаков" А Patch мы меняем на каждый чих.
2429.04 2437.04 "Анатолий Кулаков" И, казалось бы, все хорошо, все с этим живут и все счастливы до тех пор, пока мы не встречаемся с проблемой Diamond Dependency.
2437.04 2445.04 "Анатолий Кулаков" Эта проблема заключается в том, что когда у нас есть две зависимости на одну и ту же библиотеку, не очень очевидно, какую из них мы должны использовать.
2445.04 2448.04 "Анатолий Кулаков" Допустим, твой пример со HTTP Client, он здесь как раз очень хорош.
2448.04 2464.04 "Анатолий Кулаков" Когда у нас половина библиотек нашего фреймворка, которые мы используем, зависят от одной версии DotNet Client, а вторая половина наших библиотек, которые мы потянули, допустим, даже третий сторонних, она зависит от уже нового Nuget пакета, в котором ходится новый HTTP Client.
2464.04 2467.04 "Анатолий Кулаков" И как разрезолвить эту проблему не очень очевидно.
2467.04 2471.04 "Анатолий Кулаков" В DotNet с давних времен есть Binding и Direct.
2471.04 2473.04 "Анатолий Кулаков" Они худо-бедно эту ситуацию решали.
2473.04 2479.04 "Анатолий Кулаков" Они генерятся автоматически и таргятся в основном на самую последнюю сборку, которую мы знаем, которую мы используем.
2479.04 2481.04 "Анатолий Кулаков" И в раунд тайме, соответственно, используются последние.
2481.04 2491.04 "Игорь Лабутин" Да, но если у тебя так случится, что две твои библиотеки, третий сторонних, которые ты используешь, используют разные мажорные версии, то не факт, что они будут совместимы по интерфейсам.
2491.04 2493.04 "Игорь Лабутин" Пусть даже Binding и Direct тебе дают все на последнюю.
2493.04 2495.04 "Игорь Лабутин" Я боюсь, что тут все сломается.
2495.04 2498.04 "Анатолий Кулаков" Все именно так. Никаких гарантий уже здесь тебе нет.
2498.04 2502.04 "Игорь Лабутин" Угу. И нам Джон Скитт что-то предлагает?
2502.04 2504.04 "Анатолий Кулаков" Да. У него есть несколько предложений.
2504.04 2509.04 "Анатолий Кулаков" Самое лучшее, самое разумное из них - никогда не делать breaking changes. Как тебе?
2509.04 2512.04 "Игорь Лабутин" Вообще прекрасно. Я такой автор библиотеки.
2512.04 2514.04 "Игорь Лабутин" Я выложил ее на GitHub, что-то пишу.
2514.04 2517.04 "Игорь Лабутин" Потом я понял, что где-то у меня что-то не так.
2517.04 2519.04 "Игорь Лабутин" И я хочу что-то поменять.
2519.04 2524.04 "Игорь Лабутин" Я делаю fork сам и говорю, что теперь у меня эта библиотека называется...
2524.04 2526.04 "Игорь Лабутин" Короче, придумал какое-нибудь новое клевое имя.
2526.04 2528.04 "Игорь Лабутин" И, в общем, вот именно так мы и делаем.
2528.04 2530.04 "Игорь Лабутин" А так, как бы, такая...
2530.04 2535.04 "Игорь Лабутин" У нас есть эти immutable коллекции, вот теперь будут сниматься immutable библиотеки.
2535.04 2537.04 "Игорь Лабутин" Там, ну, какие-нибудь minor патчи, ладно.
2537.04 2539.04 "Игорь Лабутин" А так, ну, вообще идея не четок. Мне нравится.
2539.04 2541.04 "Анатолий Кулаков" Ну, может, да?
2541.04 2544.04 "Игорь Лабутин" Хотя, боюсь, что в продуктовой разработке будет плохо.
2544.04 2546.04 "Игорь Лабутин" Заказчики не поймут.
2546.04 2552.04 "Анатолий Кулаков" Вот и он потом осмысл, осознал свои ошибки, подумал и решил попробовать поэкспериментировать с чем-нибудь другим.
2552.04 2562.04 "Анатолий Кулаков" Например, у него есть предложение в том, что мы должны научиться в дотнете поддерживать несколько версий одновременно, загруженных одновременно в домен, в один и тот же.
2562.04 2564.04 "Анатолий Кулаков" Ну, тем более, что в core у нас вообще доменов нет.
2564.04 2567.04 "Анатолий Кулаков" Одновременно разные версии библиотеки.
2567.04 2573.04 "Анатолий Кулаков" И каждый код, который скомпилирован с определенной версией, должен использовать именно свою версию библиотеки.
2573.04 2579.04 "Игорь Лабутин" Ну, то есть загружать-то мы умеем и сейчас, а AssemblyLot, насколько я понимаю, позволит тебе загрузить несколько версий одной и той же библиотеки.
2579.04 2583.04 "Игорь Лабутин" Если у них разные AssemblyVersion.
2583.04 2585.04 "Игорь Лабутин" Ну, за что мы, собственно, и боремся.
2585.04 2587.04 "Игорь Лабутин" Но, да, это все-таки reflection.
2587.04 2605.04 "Игорь Лабутин" То есть предлагается, что вот если эта функция из этой библиотеки была когда-то скомпилирована с NugetPacket версии 5, а у нас загружены версии и 5 и 6, вот эта функция при исполнении будет дергать пакет 5, а соседние в соседней библиотеке будут дергать пакет 6.
2605.04 2607.04 "Анатолий Кулаков" Именно так.
2607.04 2612.04 "Анатолий Кулаков" А еще как расширение, он предлагает загружать эти библиотеки с модификатором доступа.
2612.04 2615.04 "Анатолий Кулаков" Обычно у тебя происходит следующая ситуация.
2615.04 2617.04 "Анатолий Кулаков" Допустим, тот же самый WebAPI.
2617.04 2624.04 "Анатолий Кулаков" WebAPI использует под своим капотом или использовал уже Newton's Soft JSON Serializer.
2624.04 2634.04 "Анатолий Кулаков" Соответственно, как только ты пытаешься к своему пакету, к своему проекту добавить свой Newton's Soft JSON Serializer, уже совершенно другой версии, у тебя, кстати, могут начаться небольшие проблемы.
2634.04 2640.04 "Анатолий Кулаков" Именно поэтому команды WebAPI начали переезжать на свой собственный самописный OTF-8 Serializer.
2640.04 2642.04 "Анатолий Кулаков" Но, допустим, у тебя вот такие проблемы.
2642.04 2656.04 "Анатолий Кулаков" На самом деле-то здесь, при том условии, что мы умеем в памяти держать обе версии библиотеки, никаких конфликтов быть не может, потому что Newton's Soft JSON Serializer из фреймворка WebAPI никак наружу не торчит.
2656.04 2675.04 "Анатолий Кулаков" Если бы мы просто-напросто могли сказать, что WebAPI использует модификатор доступа private, то есть загрузил эту DLL-ку и юзает ее только в своих приватных имплементациях, никуда наружу не выставляет никакие интерфейсы, не дает ее ни расширять, ничего с ней делать не дает, то, в принципе, это бы решило, мне кажется, 80% всех проблем.
2675.04 2687.04 "Анатолий Кулаков" Обычно, когда ты тащишь какую-то третьеостороннюю библиотеку, и ты рассчитываешь на то, что тебя могут выюзать, все-таки ты ее обычно закрываешь какими-нибудь своими интерфейсами, какими-нибудь своими абстракциями и так далее, и наружу она у тебя обычно не торчит.
2687.04 2690.04 "Анатолий Кулаков" То есть это такой best practice, который вот здесь бы мог бы хорошо нам сыграть.
2690.04 2693.04 "Игорь Лабутин" Да, такие очень лайтовые обдомены.
2693.04 2704.04 "Игорь Лабутин" Получается, что у тебя как бы можно загрузить каждое из условно сборок, можно загрузить себе другие сборки, так что никто другое из них не видит.
2704.04 2706.04 "Игорь Лабутин" Ну да, прикольно.
2706.04 2708.04 "Игорь Лабутин" Помогло бы, наверное, согласен.
2708.04 2709.04 "Анатолий Кулаков" Да, вот.
2709.04 2716.04 "Анатолий Кулаков" А потом у нас остается все-таки проблема, что делать, если у нас какие-то внешние контракты отдаются наружу, какие-то внешние контракты торчат наружу.
2716.04 2726.04 "Анатолий Кулаков" И если у тебя одна библиотека отдает, G-Object версии номер 2, а вторая библиотека хочет принять G-Object версии номер 3, вот как здесь быть?
2726.04 2733.04 "Анатолий Кулаков" Соответственно, Джон предлагает делать какие-то прослойочные библиотеки, которые умеют конвертировать из одной версии в другую версию.
2733.04 2747.04 "Анатолий Кулаков" Вот, здесь тоже встречаются некие подводные камни, здесь тоже встречаются какие-то проблемы, и все еще остаются открытыми многие интересные вопросы, на которые он ответов не дает и предлагает просто подискутировать и подумать о том, как бы это могло быть на самом деле.
2747.04 2758.04 "Игорь Лабутин" Ну, да, скорее всего, действительно, общее какое-то состояние, которое надо передавать, это тогда будет главная боль автора библиотеки написать все эти прослойки между версией A, B, C во всех возможных комбинациях.
2758.04 2766.04 "Игорь Лабутин" Но, да, в основном здесь, конечно, будет главная боль команды дезенета придумать, что с этим делать, если это будет большой проблемой.
2766.04 2770.04 "Анатолий Кулаков" А еще интересный вопрос здесь затрагивается, а что же сделать с синглтонами?
2770.04 2780.04 "Анатолий Кулаков" То есть, например, тебе нужно в рамках твоей библиотеки иметь статическое какое-то поле, какой-то статический метод, который должен быть один уникальный на все твое приложение.
2780.04 2789.04 "Анатолий Кулаков" Если мы говорим о мультиассембле, то здесь получается, он уникален в рамках твоей эссембле, то есть в рамках твоей версии определенной, не в рамках всего приложения.
2789.04 2792.04 "Анатолий Кулаков" Вот, здесь тоже интересно, есть моменты, как это можно решать.
2792.04 2794.04 "Игорь Лабутин" Ну, посмотрим, посмотрим.
2794.04 2804.04 "Игорь Лабутин" То есть, пока я так понимаю, что это все на уровне идей, никаких подвижек со стороны дотнет, я дотнет команды я не видел на тему версионирования.
2804.04 2806.04 "Игорь Лабутин" Так что посмотрим, может это вылечится.
2806.04 2807.04 "Анатолий Кулаков" Зато...
2807.04 2811.04 "Анатолий Кулаков" Погоди, со стороны дотнет команды есть клевый подход, клевый инструмент.
2811.04 2831.04 "Анатолий Кулаков" То есть, в своей статье, Джон Скид, еще очень хорошо проходится потом, а когда нужно увеличивать какую версию в твоей semantic version, что такое breaking changes, что такое обратное совместимое изменение, что такое вперед совместимое изменение, и как от них зависят сторонние библиотеки, которые используют твой фреймворк.
2831.04 2839.04 "Анатолий Кулаков" Вот, и через эти рассуждения я вышел на интересный документик, который называется breaking changes rules в команде дотнета, в команде CoreFX.
2839.04 2844.04 "Анатолий Кулаков" То есть, как они определяют, что такое breaking changes, и какие у них есть правила для этого.
2844.04 2850.04 "Анатолий Кулаков" Вот, очень интересный документ, я не буду перечислять, потому что технически не очень интересно.
2850.04 2863.04 "Анатолий Кулаков" Но, для примера, если вы добавляете какой-нибудь абстрактный метод в класс, который не sealed, или, допустим, в интерфейс, то это breaking changes, потому что от этого класса могли наследоваться, и, соответственно, все наследники дружно сломаются.
2863.04 2873.04 "Анатолий Кулаков" Вот, если же вы добавляете какой-нибудь метод в internal interface, или, может быть, виртуальный метод, в sealed класс, и после этого открываете sealed class, то это не считается breaking changes.
2873.04 2877.04 "Анатолий Кулаков" Вот, и таких куча-куча интересных правил, многие из которых совершенно неочевидными.
2877.04 2898.04 "Анатолий Кулаков" Самое интересное, что эти правила все формализованы, и у команды CoreFX есть специальный инструмент, который помогает посмотреть коммиты, которые были зачекинены, который позволяет по каждому коммиту решить, это breaking change или нет, forward или backward on compatibility, советует какую цифру в semantic версии увеличить, первую, вторую или третью.
2898.04 2903.04 "Анатолий Кулаков" Тоже довольно инструментный тулзень, который более-менее помогает бороться с вот этим адом версионирования.
2903.04 2904.04 "Анатолий Кулаков" Ну да, мне кажется,
2904.04 2912.04 "Игорь Лабутин" что команда CoreFX в .NET мире это, наверное, в принципе, не самая главная команда, которая должна заботиться о backward compatibility.
2912.04 2922.04 "Игорь Лабутин" Может быть, это не так очевидно на ранних этапах .NET Core было, но сейчас, когда это все уже в продакшене, это, конечно, сильно важно, и действительно формализованный список правил, это очень важно.
2922.04 2924.04 "Игорь Лабутин" Прикольно, я не знал.
2924.04 2928.04 "Игорь Лабутин" Ну, то есть я догадывался, что он есть, но вот я его как-то не видел до этого.
2928.04 2929.04 "Игорь Лабутин" Надо будет почитать.
2929.04 2939.04 "Анатолий Кулаков" Вообще, semantic version очень хорошо прижился в .NET мире, в принципе, я думаю, не только в .NET, потому что он дает очень много плюшек и бенефитов, его используют сейчас практически все.
2939.04 2942.04 "Игорь Лабутин" Да, semantic version - тема прикольная.
2942.04 2945.04 "Игорь Лабутин" И недавно тоже наткнулся на такую штуку.
2945.04 2949.04 "Игорь Лабутин" Semantic version, как известно, написан на сайте semver.org.
2949.04 2952.04 "Игорь Лабутин" Есть еще сайт fibver.org.
2952.04 2962.04 "Игорь Лабутин" Это такой фановый вариант semantic version, который полностью соответствует semantic version, то есть все правила ровно те же самые, про major, minor и все такое прочее, за одним исключением.
2962.04 2967.04 "Игорь Лабутин" Обычно, когда вы делаете новую версию, вы увеличиваете версию на единичку.
2967.04 2969.04 "Игорь Лабутин" Здесь предлагается брать следующее число Fibonacci.
2969.04 2971.04 "Игорь Лабутин" Так, типа, почему бы нет?
2971.04 2974.04 "Игорь Лабутин" Придумал это дело Конрад Кокоса, небезызвестный.
2974.04 2982.04 "Игорь Лабутин" Он, похоже, большой любитель всяких разных фановых штук, писать книжки ясного по килограмму и вот всякие такие прикольные вещи делать.
2982.04 2985.04 "Игорь Лабутин" Кстати, кто не знает, он сейчас делает настольную игрушку.
2985.04 2987.04 None Такую физическую настольную игрушку про .NET.
2987.04 2989.04 "Игорь Лабутин" Надеемся скоро увидеть ее в реальной жизни.
2989.04 2992.04 "Игорь Лабутин" Ну и вот как раз таки сделан этот Fibonacci versioning.
2992.04 2998.04 "Игорь Лабутин" Просто берете и используете, как обычный semver, только каждый раз увеличиваете на следующее число Fibonacci.
2998.04 3001.04 "Анатолий Кулаков" Мне кажется, или она очень быстро у тебя закончится?
3001.04 3004.04 "Игорь Лабутин" Да, нет, закончится...
3004.04 3006.04 "Игорь Лабутин" Ну хотя да, у нас же версии ограничены.
3006.04 3010.04 "Игорь Лабутин" Если я правильно помню, в .NET версии ограничены 6x536.
3010.04 3015.04 "Игорь Лабутин" Вот, и соответственно, действительно, число Fibonacci быстро закончится.
3015.04 3018.04 "Игорь Лабутин" И это на самом деле преподносится как плюс.
3018.04 3022.04 "Игорь Лабутин" Там на самом деле даже два плюса есть у этой системы, как утверждает Конрад.
3022.04 3031.04 "Игорь Лабутин" Во-первых, очень сложно получить похожие версии, то есть когда у вас там есть версии 2.1.3 и 2.3.1, их частенько сложно отличить, так скажем, быстрым взглядом.
3031.04 3038.04 "Игорь Лабутин" А тут у вас будет что-нибудь там типа 3585.4000, что-то там, произносить дико неудобно, зато отличимое.
3038.04 3041.04 "Игорь Лабутин" А второе, что он говорит, что такой быстрый рост версий - это очень правильно.
3041.04 3046.04 "Игорь Лабутин" И в каком-то смысле это перекликается с рекомендациями Джона Скита про то, что не надо апгрейдить менеджер-версию.
3046.04 3056.04 "Игорь Лабутин" А Конрад говорит, что если ваша менеджер-версия добралась до каких-то очень больших чисел и уже не влезает, ну, значит, все, пора переставать писать код и надо начинать новый проект.
3056.04 3060.04 "Игорь Лабутин" Так что это вот тот самый, да, естественно, ограничение роста моей же версии.
3060.04 3063.04 "Игорь Лабутин" Прикольно, чисто посмеяться.
3063.04 3065.04 "Анатолий Кулаков" Звучит как отличная рекомендация, да.
3065.04 3066.04 "Игорь Лабутин" Окей.
3066.04 3075.04 "Анатолий Кулаков" А многие команды не загоняют с них FBNach-вершин, не Steam-вершин, а есть у них такая маркетинговая политика, как ER-вершин.
3075.04 3077.04 "Анатолий Кулаков" Например, наш любимый решапер.
3077.04 3082.04 "Анатолий Кулаков" Он отошел от всяких дурацких цифрок непонятных и выпускает просто 2019.2.
3082.04 3086.04 "Игорь Лабутин" Нет, это не значит же, что это севераль. Это просто вторая версия в 2019 году.
3086.04 3087.04 "Игорь Лабутин" Я правильно понимаю?
3087.04 3088.04 "Игорь Лабутин" Да.
3088.04 3091.04 "Игорь Лабутин" Это удобно. Ты ничем не ограничен в этом случае, действительно.
3091.04 3093.04 "Игорь Лабутин" Чисел в году точно хватит.
3093.04 3098.04 "Анатолий Кулаков" И в блоге JetBrains вышел большой лонгрид, который называется очень заманчиво.
3098.04 3101.04 "Анатолий Кулаков" Где же этот чертов решапер в отдельном процессе?
3101.04 3104.04 "Игорь Лабутин" Чтобы не вылезать в 32-битную студию, наконец-таки?
3104.04 3106.04 "Анатолий Кулаков" Да, да, да, именно так.
3106.04 3112.04 "Анатолий Кулаков" Всем известно, что решапер ютится в 32-битной Visual Studio и им там вдвоем довольно-таки тесно.
3112.04 3115.04 "Анатолий Кулаков" Особенно там, когда пришел Roslyn, когда появился новый формат Solutions.
3115.04 3118.04 "Анатолий Кулаков" Это стало еще больнее, еще хуже, чем было раньше.
3118.04 3124.04 "Анатолий Кулаков" Несмотря на все те оптимизации, которые команда JetBrains делает регулярно, лучше не становится.
3124.04 3126.04 "Игорь Лабутин" Понятное дело.
3126.04 3128.04 "Игорь Лабутин" Студия тоже не стоит на месте.
3128.04 3130.04 "Игорь Лабутин" Все это надо поддерживать, новые штуки.
3130.04 3134.04 "Игорь Лабутин" Ну, в смысле, что команда Microsoft в студии много чего-то в нее добавляет.
3134.04 3138.04 "Игорь Лабутин" И тоже, насколько я понимаю, довольно большую работу проводят по оптимизации.
3138.04 3143.04 "Игорь Лабутин" Возможно, по оптимизации скорости работы, но, возможно, с ценой небольшого роста количества памяти, которую они потребляют.
3143.04 3145.04 "Игорь Лабутин" Но вот тут возникает вопрос.
3145.04 3149.04 "Игорь Лабутин" Есть же райдер, у которого, по сути, решапер уже out of process.
3149.04 3157.04 "Игорь Лабутин" Берем, меняем идею на Visual Studio, фронт-энд поменяли, бэк-энд оставили, профит.
3157.04 3158.04 "Анатолий Кулаков" Все именно так.
3158.04 3172.04 "Анатолий Кулаков" И когда, я помню, еще в давние времена говорили, почему решапер не выходит в свой собственный процесс, команда Digital Brain рассказывала, что это все сложно, это все надо делать, это все долго, это множество проблем и так далее.
3172.04 3179.04 "Анатолий Кулаков" Просто как вышел райдер, и все увидели, что это possible, это не так уж и бесполезно, теперь встал другой вопрос.
3179.04 3180.04 "Анатолий Кулаков" Ну, вы же это уже сделали.
3180.04 3181.04 "Анатолий Кулаков" Ну, какого черта?
3181.04 3188.04 "Анатолий Кулаков" Ну, переключите просто интерфейс с идеи на Visual Studio, и у вас все там, само собой, практически заработает.
3188.04 3190.04 "Анатолий Кулаков" Об этом как раз-таки статья рассказывает.
3190.04 3192.04 "Анатолий Кулаков" То есть, что было сделано.
3192.04 3195.04 "Игорь Лабутин" И судя по тому, как ты рассказываешь, краткий итог не заработает.
3195.04 3197.04 "Анатолий Кулаков" Краткий итог совсем не заработает.
3197.04 3203.04 "Анатолий Кулаков" То есть, там очень-очень много граблей, которые решапер писал долгие-многие годы.
3203.04 3208.04 "Анатолий Кулаков" Все эти грабли плотно сплетены с ComAPI, которыми кишит студия.
3208.04 3219.04 "Анатолий Кулаков" Все эти грабли сплетены с несколькими версиями студии, с разными версиями плагин API, которые приходится поддерживать JetBrains, и прочее, прочее, прочее.
3219.04 3225.04 "Игорь Лабутин" Ну, звучит как-то не очень оптимистично, но подвижки-то в этом деле, я надеюсь, все-таки есть.
3225.04 3228.04 "Игорь Лабутин" Я не думаю, что это работа уровня.
3228.04 3230.04 "Игорь Лабутин" Сложно, дорого делать не будем.
3230.04 3232.04 "Анатолий Кулаков" Подвижки, безусловно, идут.
3232.04 3258.04 "Анатолий Кулаков" Основные проблемы, с которыми они сталкивались, если мы отбросим всякие отмазы, типа нам нужно многое переписать API, это, конечно же, в том, что по сравнению с идеей, допустим, которая уже предоставляла множество UI элементов, таких как Solution Explorer, такие-то как интеграция с системой контроля версий и прочие удобные для программистов штуки, в голом ReSharper всего этого нет.
3258.04 3260.04 "Анатолий Кулаков" Solution Explorer предоставляла студия.
3260.04 3269.04 "Анатолий Кулаков" И интеграцию со всякими системами контроля версий и с TFS, о чем Ник ночью будет упомянутым, это все предоставляла студия.
3269.04 3273.04 "Анатолий Кулаков" То есть голый ReSharper — это лишь ядро, это лишь мозг, это лишь логика.
3273.04 3279.04 "Анатолий Кулаков" И все это нужно по-хорошему тоже заново переписать, заново синтегрировать и сделать.
3279.04 3286.04 "Анатолий Кулаков" Когда мы пытаемся выйти на уровень взаимодействия с контроллами, опять же, встает вопрос, а где эти контроллы размещать?
3286.04 3300.04 "Анатолий Кулаков" То есть должен ли контролл быть один для идеи и для Visual Studio, или он должен имплементироваться в рамках нативного интерфейса, а ReSharper должен каким-то образом учиться взаимодействовать с обоими визуальными элементами.
3300.04 3306.04 "Анатолий Кулаков" И здесь интересная концепция родилась в нетрах JetBrains, которая называется B-Controls.
3306.04 3312.04 "Анатолий Кулаков" То есть ребята научились описывать с помощью C#-кода, научиться логически описывать контроллы.
3312.04 3317.04 "Анатолий Кулаков" То есть у них там есть добавить чекбокс, добавить комбо-бокс, добавить какие-то логические элементы.
3317.04 3326.04 "Анатолий Кулаков" И это мета-описание, этот своеобразный DSL-чик, он трансформируется в идеи в ее нативные окошки, а Visual Studio — в свои нативные окошки.
3326.04 3332.04 "Анатолий Кулаков" Это как пример того, что ReSharper все-таки двигается к тому, чтобы уйти в отдельный процесс.
3332.04 3337.04 "Анатолий Кулаков" В частности, проблему примитивных окошек, примитивных настроек решает именно так.
3337.04 3346.04 "Игорь Лабутин" Ну, хочется сказать, пожелаем удачи, будем надеяться, но каких-то родмапов, я так понимаю, нет.
3346.04 3348.04 "Анатолий Кулаков" Родмапов нет, обещаний тоже нет.
3348.04 3350.04 "Анатолий Кулаков" Ну, потому что здесь сложно обещать.
3350.04 3358.04 "Анатолий Кулаков" Если, например, с идеей у них могли быть какие-то планы, потому что они могут менять контракт с двух сторон, допустим, если идея чего-то не умеет.
3358.04 3366.04 "Анатолий Кулаков" JetBrains команда ReSharper может пойти JetBrains команде идеи, и там что-нибудь им пропатчить или предложить, или форкнуть и самой сделать.
3366.04 3373.04 "Анатолий Кулаков" То есть любые необходимые изменения, любые необходимые какие-то дополнения, всего, что идея не умеет, они могли ее научить.
3373.04 3375.04 "Анатолий Кулаков" С Visual Studio система совершенно другая.
3375.04 3386.04 "Анатолий Кулаков" Visual Studio закрыта, Microsoft никакие патчи туда не принимает, на уговоры идет очень неохотно, и поэтому ReSharper приходится подстраиваться под то, что уже есть.
3386.04 3409.04 "Игорь Лабутин" И причем это то, что уже есть, как я понял, довольно, особенно сейчас, в 17-й студии, в 19-й, очень активно меняется, туда постоянно что-то допиливается, я не знаю, насколько меняется при этом именно интерфейс плагинов, но я так понимаю, что там движуха активная, и видимо какое-то количество ресурсов уходит на все время подстраиваться под современную студию, не ломая при этом совместимость со старой.
3409.04 3417.04 "Анатолий Кулаков" Да, насколько я знаю, плагины писателей под Visual Studio все они как один, плачут, что это очень больно, грустно, неудобно и так далее.
3417.04 3418.04 "Анатолий Кулаков" Но выхода особого нет.
3418.04 3431.04 "Игорь Лабутин" Ну, хорошо, будем тогда ждать, я так понимаю, что следить за новостями, и посмотрим, возможно в какой-то момент Visual Studio 2021 или какой-нибудь, ReSharper будет уже жить отдельно.
3431.04 3444.04 "Анатолий Кулаков" По крайней мере мы теперь точно знаем, что команда над этим работает, что работы идут, что у них подвижки есть, и они эту идею не забросили, поэтому мы все дружно ждем, что все-таки у них все получится.
3444.04 3455.04 "Анатолий Кулаков" Еще я пока читал эту статью, действительно обнаружил, что в блоге компании JetBrains в тему ReSharper очень-очень много статей по тому, как они улучшали перформанс.
3455.04 3470.04 "Анатолий Кулаков" То есть они описывают очень классно свои улучшения, они показывают на примерах с помощью своих инструментов DotMemory и DotTrace, как они искали проблемы, что они нашли, как они их улучшили, в каких релизах они-то выпустили, очень увлекательное чтиво.
3470.04 3473.04 "Анатолий Кулаков" Поэтому Performance Series тоже сильно рекомендую.
3473.04 3478.04 "Игорь Лабутин" Да, вот Performance Series я как раз-таки видел, и там действительно все очень здорово.
3478.04 3490.04 "Игорь Лабутин" Ну а вообще, кстати, с трендом на тему, как жить в транслювительной студии, мне кажется, что я видел какие-то упоминания про то, что Microsoft сама, мне кажется, начинает выносить кусочки студии в отдельные процессы.
3490.04 3500.04 "Игорь Лабутин" По крайней мере я сейчас вижу, что у меня на компьютере 17-я студия, она там держит помимо себя еще энное количество процессов, типа там тест-раннеры, еще что-то.
3500.04 3510.04 "Игорь Лабутин" Они живут все отдельно, и возможно со временем студия сама начнет худеть, и будет, да, по сути, просто небольшим шалом для запуска всего остального.
3510.04 3517.04 "Анатолий Кулаков" Да, ее иммунитабельные росли, но он не влез в ее процессы, поэтому они его тоже вынесли out of process.
3517.04 3521.04 "Игорь Лабутин" Ну, хорошо. Так, есть ли у нас что-нибудь еще на сегодня обсудить?
3521.04 3531.04 "Анатолий Кулаков" Не отходя далеко от JetBrains вышла статейка на Hubri, которая рассказывает про Open Days, JetBrains Open Days в Питере.
3531.04 3541.04 "Анатолий Кулаков" Я попал на это мероприятие, очень шикарный день выдался, мы много общались, много общались с командой Ryder, Resharper и с другими командами.
3541.04 3546.04 "Анатолий Кулаков" Вот, смотрели на новый офис JetBrains, это тема для отдельного разговора.
3546.04 3551.04 "Анатолий Кулаков" Все-таки, если оставаться на технической волне, я бы хотел порекомендовать несколько докладиков.
3551.04 3555.04 "Анатолий Кулаков" Вот, докладики все выложены, их можно посмотреть на YouTube.
3555.04 3561.04 "Анатолий Кулаков" Прежде всего, Дмитрий Иванов, наш любимый Дмитрий Иванов сравнивает Kotlin и C#.
3561.04 3571.04 "Анатолий Кулаков" Сравнение это интересно тем, что в самом начале Дима говорит, что с Java сравнивать это абсолютно бесполезно, потому что Java на 10 лет уже отстала и вряд ли уже когда-то догонит C#.
3571.04 3578.04 "Анатолий Кулаков" И действительно, достойным конкурентом, с которым можно хоть как-то состязаться по фичам C#, это как раз таки является Kotlin.
3578.04 3593.04 "Анатолий Кулаков" И там мы узнаем много всего интересного, там мы узнаем, что Kotlin украл у C#, что C# украл у Kotlin, что сделано там лучше, что сделано с Java лучше, какие перспективы нас могли бы ждать в C#, если бы разработчики не тормозили и так далее.
3593.04 3595.04 "Анатолий Кулаков" В общем, весьма познавательный доклад.
3595.04 3610.04 "Анатолий Кулаков" Всем рекомендую посмотреть, я думаю, ни для кого не секрет, что Брислав, когда писал Kotlin, он вдохновлялся в частности и C#, это один из его самых вдохновенных языков был, поэтому, в принципе, шарписты довольно-таки легко смотрят на Kotlin.
3610.04 3614.04 "Анатолий Кулаков" И видят там много знакомых, интересных конструкций.
3614.04 3626.04 "Игорь Лабутин" Да, я слышал, что одна из, ну, может быть не главных, но такая большая фишка Kotlin про всякие coroutines и прочее, это, естественно, продолжение развития Async/await и C#.
3626.04 3634.04 "Игорь Лабутин" Это вот как бы было очень приятно узнать, что Async/await он весь и пошел из C# в другие языки.
3634.04 3637.04 "Анатолий Кулаков" Да, именно так. Ну, в Kotlin немножко передумали Async/await, да?
3637.04 3638.04 "Анатолий Кулаков" Это мы с тобой, Игорь, на Гидре были.
3638.04 3643.04 "Анатолий Кулаков" И там как раз мы смотрели доклад про Async/await в Kotlin.
3643.04 3646.04 "Анатолий Кулаков" Ну, опять давай не будем углубляться, может, тоже еще обсудим.
3646.04 3651.04 "Анатолий Кулаков" Еще один доклад просто обалденный, это доклад Кирилла Скрыгана.
3651.04 3653.04 "Анатолий Кулаков" Кирилл — это тимлид команды Rider.
3653.04 3663.04 "Анатолий Кулаков" Он рассказывал про IDE войны, то есть кто сейчас по факту является другом Rider, кто является его врагом, как, почему, зачем.
3663.04 3682.04 "Анатолий Кулаков" То есть Кирилл отлично разложил карту мирового просто господства всех компаний, всех IDE-шек, описал связи между ними и вывел шикарные просто планы на будущее, планы развития IDE, планы развития Fitch, что будет происходить в будущем, кто за что будет драться.
3682.04 3686.04 "Анатолий Кулаков" В общем, доклад просто эпический, всем рекомендую посмотреть.
3686.04 3690.04 "Анатолий Кулаков" И еще один классный доклад от Хади Харири.
3690.04 3697.04 "Анатолий Кулаков" Хади у нас знаменитый докладчик, все его доклады, кейноуты, они расходятся на ура.
3697.04 3704.04 "Анатолий Кулаков" И в этот раз он рассказывает про культуру, которую JetBrains построил в своей компании.
3704.04 3706.04 "Анатолий Кулаков" Доклад называется «Removing Barriers».
3706.04 3712.04 "Анатолий Кулаков" Это сложно описать в нескольких словах, но если вкратце, то культура построена на принципе доверия.
3712.04 3730.04 "Анатолий Кулаков" Когда менеджеры, программисты, разработчики, они все понимают, что все мы здесь взрослые люди, все мы здесь делаем качественный продукт, и никто не старается вас законтролировать, вогнать в какие-то временные рамки, навязать какие-то непонятные задачи, заставить ходить на какие-то скучные собрания.
3730.04 3734.04 "Анатолий Кулаков" Они просто дают команде нормально по-человечески работать.
3734.04 3738.04 "Анатолий Кулаков" То, что команда любит, то, что команда хочет, и чем команде хочется заниматься.
3738.04 3744.04 "Анатолий Кулаков" То есть они дают команде возможность сделать продукт таким, чтобы они его сами любили и сами хотели его развивать.
3744.04 3757.04 "Анатолий Кулаков" Хади как раз-таки рассказывает, каким образом это, казалось бы, фантастическая вещь, каким образом она на практике работает, и каким образом в компании она еще умудряется приносить прибыль, а не приводит ее к разорению ровно через месяц после запуска.
3757.04 3758.04 "Анатолий Кулаков" Отличный доклад.
3758.04 3769.04 "Анатолий Кулаков" То есть тоже обязательно посмотрите, хотя бы для того, чтобы понимать, что существуют какие-то альтернативные реальности, а не просто где вы навесельного дядю день и ночь просто гребете, гребете и гребете.
3769.04 3773.04 "Анатолий Кулаков" Также, если у вас будет возможность, обязательно посетите новый офис JetBrains.
3773.04 3776.04 "Игорь Лабутин" Да, в общем, видео...
3776.04 3780.04 "Игорь Лабутин" Согласен, я пока еще не видел, но по описанию прям хочется посмотреть.
3780.04 3785.04 "Игорь Лабутин" Я думаю, что там помимо этих трех докладов есть наверняка еще что-то интересное.
3785.04 3788.04 "Игорь Лабутин" И может быть даже не только из мира дотнета.
3788.04 3796.04 "Анатолий Кулаков" Да, да, там в принципе весь день было представление всего JetBrains, то есть все продукты, которые вы знаете, у них был...
3796.04 3802.04 "Анатолий Кулаков" были у каждого там свой этаж, можно было прийти, пообщаться с командой разработчиков, позадавать им вопросы.
3802.04 3805.04 "Анатолий Кулаков" Был отдельный этаж прямо для секретного продукта некоего.
3805.04 3811.04 "Анатолий Кулаков" Вот тоже очень было интересно выведать у JetBrains, чем он таким секретным и интересным работает.
3811.04 3814.04 "Анатолий Кулаков" Можно было легко пообщаться, погулять, посмотреть.
3814.04 3816.04 "Анатолий Кулаков" В общем, день был просто замечательным.
3816.04 3825.04 "Анатолий Кулаков" И также вы найдете кучу записей, кучу докладиков, пройти не только в статье на хабре, ссылочка, которую мы приложим.
3825.04 3829.04 "Игорь Лабутин" Ну, я думаю, что тогда на этой ноте можно начинать заканчивать.
3829.04 3832.04 "Игорь Лабутин" Мы уже больше часа обсуждаем новости.
3832.04 3840.04 "Игорь Лабутин" Новостей как бы сегодня действительно огромное количество, что здорово, значит, Дотонат в общем-то развивается, не стоит на месте.
3840.04 3846.04 "Игорь Лабутин" Надеемся, что развивается в правильном направлении и в части самого Дотоната фреймворка, и в части тулинга.
3846.04 3849.04 "Игорь Лабутин" Смотри, Шарпер, и студии, и райдеры, и все остальное.
3849.04 3852.04 "Игорь Лабутин" Так что будем завершаться на сегодня.
3852.04 3866.04 "Игорь Лабутин" Как Анатолий говорил в самом начале, любые пожелания, комменты, фидбэк, возможно, идеи каких-то тем, которые вы хотели бы обсудить, присылайте нам.
3866.04 3869.04 "Игорь Лабутин" Нам - это, я так понимаю, во Вконтакте?
3869.04 3873.04 "Анатолий Кулаков" Да, я выложу этот выпуск в Дотнетру группу Вконтактики.
3873.04 3878.04 "Анатолий Кулаков" В комментарии к этой записи вы можете оставлять свои отзывы, мнения и так далее.
3878.04 3882.04 "Анатолий Кулаков" А также те, кто резвует Вконтакта, могут писать нам напрямую на почту.
3882.04 3886.04 "Анатолий Кулаков" Почта довольно-таки простая - radiosobaka.net.ru
3886.04 3891.04 "Игорь Лабутин" Отлично, ждем тогда от вас фидбэка. И на сегодня прощаемся.
3891.04 3892.04 "Анатолий Кулаков" С вами был Игорь.
3892.04 3894.04 "Анатолий Кулаков" И Анатолий. Всем пока.
3894.04 3895.04 "Игорь Лабутин" Пока.
