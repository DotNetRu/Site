0.00 11.48 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Радио.нет и в студии сегодня Анатолий Кулаков и Игорь Лабутин.
11.48 14.00 "Анатолий Кулаков" Сороковой выпуск у нас уже.
14.00 27.88 "Анатолий Кулаков" Всех, кто не посещал наш Patreon или Boosty, приглашаю посмотреть на наши странички, если вы, конечно, хотите поддержать этот подкаст и присоединиться к таким замечательным людям, как Александр, Сергей, Владислав и множество других замечательных человечков.
27.88 30.64 "Анатолий Кулаков" Огромное вам большое спасибо, всех, кто нас поддерживает.
30.64 39.88 "Анатолий Кулаков" А сегодняшний выпуск у нас такой, обычно необычный, потому что, как многие из вас знают, наконец-то зарелизилось, да, в принципе, все зарелизилось.
39.88 43.36 "Анатолий Кулаков" И .NET, и C#, и студия, и миллион тулзов вокруг этого.
43.36 47.08 "Анатолий Кулаков" И как раз о сегодня мы об этом и поговорим.
47.08 60.48 "Анатолий Кулаков" Мы собрали, конечно, не все, иначе бы этот выпуск растянулся на пару дней, но собрали основные моменты, а остальные релизы, остальные инструменты будем рассматривать уже в следующих выпусках по мере поступления.
60.48 63.84 "Анатолий Кулаков" Ну и, соответственно, главный анонс, анонс .NET 6.
63.84 70.44 "Игорь Лабутин" Да, .NET 6, можно сказать, мы про него уже все рассказали, что-то рассказывать пошли дальше.
70.44 84.12 "Игорь Лабутин" Но на самом деле давайте все-таки пройдемся по тому, что Microsoft представил, в каком виде он это представил и на что сделал основной упор, чтобы понимать, какие фичи они считают, например, довольно важными.
84.12 95.36 "Игорь Лабутин" Самое главное про .NET 6 это то, что уже к моменту выпуска, это довольно забавно говорить, но тем не менее, он уже, можно сказать, прошел стресс-тест продакшена.
95.36 119.40 "Игорь Лабутин" Ну, все довольно осведомленные про внутреннюю кухню Microsoft знают, что как только появляются превьюшки довольно более поздние и более стабильные, внутренние сервисы Microsoft довольно часто начинают переводить на эти самые превьюшки типа Bing, Azure или еще кого-то, какие-то, возможно, менее важные сервисы, чтобы посмотреть, как это все естественно работает в нормальном продакшене на нормальных хороших нагрузках.
119.40 126.48 "Игорь Лабутин" Поэтому к релизу, на самом деле, если не половина Microsoft, то довольно много сервисов на 6 .NET работало.
126.48 129.92 "Игорь Лабутин" Поэтому можно его без опаски использовать в вашем продакшене.
129.92 138.00 "Игорь Лабутин" Наверняка там еще что-нибудь найдется и будут баги, но Microsoft старается обычно очень оперативно их фиксить, так что будем надеяться на лучшее.
138.00 143.88 "Игорь Лабутин" Из забавной статистики в этот релиз вошло примерно 10 тысяч коммитов в GIT.
143.88 156.72 "Игорь Лабутин" Не знаю, по каким репозиториям они считали, только ли это .NET Runtime или это еще S/Panet Core, или это еще EF, или это еще куча других репозиториев, но тем не менее, вот в статье говорится, что это примерно 10 тысяч GIT коммитов, что вообще говоря, немало.
156.72 162.84 "Игорь Лабутин" Главная штука, которую мы хотим узнать, когда что-то зарелизилось, это сколько оно будет жить.
162.84 181.40 "Игорь Лабутин" В данном случае жить оно будет 3 года, это LTS-релиз, он с нами надолго, до тех пор, пока не выйдет .NET 8 через пару лет, поэтому если вы еще не над .NET 6, постарайтесь на него переехать и можете тогда уже на стабильном .NET 6, который будет получать Security Patch в ближайшие 3 года, можно жить.
181.40 189.48 "Игорь Лабутин" Также он поддержан на Linux, и это не просто мы можем запускать приложенки на Linux, это можно было и раньше делать.
189.48 195.56 "Игорь Лабутин" 6 .NET официально поддержан и входит в поставку Red Hat Enterprise Linux, что как бы уже круто и прикольно.
195.56 200.96 "Игорь Лабутин" Там есть отдельная история, как он собирается, для того чтобы быть честно опенсурсным, но мы про это как-нибудь в другом месте затронем.
200.96 219.84 "Игорь Лабутин" Поддержан .NET 6 в 22 студии, то есть она вам нужна, чтобы использовать 6 .NET, но либо вы можете использовать конечно SDK, но если вы хотите именно в студии, то используйте 22, можно использовать VS Code, экстенджеры все обновлены, и любые другие редакторы, понятное дело, и Command Line.
219.84 231.40 "Игорь Лабутин" С .NET 6 Microsoft все дальше двигается в сторону такой универсальной платформы про все сразу, то есть это и браузер, и плака всякий, и десктоп разработка, и мобильнички, и IoT, и все такое.
231.40 245.36 "Игорь Лабутин" Из недавних добавлений это добавление тренда в сторону машин лернинга, и естественно WebAssembly со всяких разных сторон используется, поэтому без этих слов тоже никуда сегодня не обойдемся.
245.36 267.76 "Игорь Лабутин" Для того чтобы ваш код собирался для 6 .NET и таргетил его, нужно использовать TFM под названием net6.0, плюс вы можете добавить опциональный сосек, там dfis-android, dfis-ios, или dfis-windows, или dfis-tvios, и так далее, чтобы включить какие-то фичи, которые специфичны, или API, которые специфичны для определенных операционных систем.
267.76 275.64 "Игорь Лабутин" Если же вы соберете бинарничек с таргетом net6.0, то он будет спокойно работать на всех платформах, где поддержан .NET 6.
275.64 298.68 "Игорь Лабутин" Наверное одна из основных фич, которые промоутят в момент релиза .NET это конечно перформанс, и перформанс в 6 .NET прям стал хорош, не то чтобы он был плохой, но стало еще лучше, мы еще лучше соптимизировали какие-то бенчмарки, еще меньше кушаем памяти, еще меньше занимаем CPU, еще быстрее запускаем все приложения еще меньше размера, а делают вроде столько же.
298.68 313.52 "Игорь Лабутин" Так что все хорошо у нас, есть несколько вещей, которые хотелось бы упомянуть, мы про них практически все уже рассказывали, про File Guided Optimization, может быть мы потом поговорим поподробнее, потому что там довольно много новых изменений грядет и сейчас делается.
313.52 335.72 "Игорь Лабутин" File.io, полностью переписали файл стрим, больше не используется блокинг API на Windows особенно, и если вы используете async вызовы, то они смогли сделать так за счет всяких value tasks и pooling, что async вызовы аллоцируют память только на первом вызове, на первом использовании, а дальше они все становятся практически allocation free, ну на так скажем основных путях, и это здорово.
335.72 350.56 "Игорь Лабутин" Ну и плюс, если говорить про перформанс, там огромное количество всяких мелких улучшений, начиная от JIT заканчивая код генерации и так далее, так что перформанс сейчас это практически основная фишка команды, и они над этим очень плотно работают.
350.56 372.80 "Игорь Лабутин" Вторая фича, которую промоутят просто опять же из каждого утюга, это ход релоуд, мы его упоминали в прошлый раз, мы его наверное упоминали в позапрошлый раз, и сколько раз мы его только уже не упоминали, но фича действительно прикольная, полезная, позволяет менять ваш код на лету, не перезапуская, точнее, ваше приложение, ну и само понимает когда, что, как поменено и так далее.
372.80 381.00 "Игорь Лабутин" Есть конечно ограничения, детально читайте документацию, потому что список обновляется постоянно и постоянно добавляются новые варианты, когда это все работает.
381.00 401.04 "Игорь Лабутин" Большая работа проведена над security, добавили поддержку OpenSSL 3, добавили фичу, которая была нужна для MacOS, это write XOR execution, то есть мы в страничке памяти либо пишем, либо их исполняем, на MacOS она обязательно, для остального пока это opt-in, но в общем, штука полезная.
401.04 411.24 "Игорь Лабутин" А, нет, кстати я вру, она не opt-in, она вроде как как раз-таки нормальная, типа она была сделана opt-in в каких-то превьюшках, а сейчас она вроде включена уже.
411.24 438.84 "Игорь Лабутин" И добавили, вот точно уже opt-in фичу, это InterControl Flow Enforcement Technology, это какая-то такая магическая штука, единственное что я про нее знаю, это то, что она там как-то с помощью какого-то shadow stack проверяет, куда там должна была пойти программа на бранч-переходах и куда она пошла на самом деле, тем самым пытаясь, так скажем, задетектить действие вредоносного кода, когда он там подменяет какие-нибудь бранчи или джампы, чтобы пойти не туда, куда она должна была.
438.84 443.48 "Игорь Лабутин" Вот, пока это opt-in, оно недостаточно оттестировано, но тоже интересно.
443.48 460.48 "Игорь Лабутин" ARM64 поддержка существенно улучшилась, то есть на дотнет 6 у нас есть ARM64 SDK, есть еще x64 конечно SDK, вы можете, если вы допустим на там m1, то вы можете компилироваться в x64 и там будет, понятно, виртуализация тогда работать.
460.48 472.56 "Игорь Лабутин" Для старых дотнетов, типа дотнет Core 3.1 и дотнет 5, в принципе они работать будут, но скорее всего там будет чуть меньше возможностей и там не будут использовать все возможности процессора.
472.56 483.60 "Игорь Лабутин" Не работает пока дотнет тест на ARM64 с эмуляцией x64, но скорее всего это точно пофиксит в каком-то ближайшем хотфиксе.
483.60 496.12 "Игорь Лабутин" Ну и если у вас есть допустим линуксовый ARM64 дотнет контейнер, то его можно использовать только на ARM64 операционной системе, никакой такой кросс эмуляции сейчас нет.
496.12 508.40 "Игорь Лабутин" И про контейнеры тоже в этот раз было не так, чтобы сильно много, так скажем, хайпа или пуша в течение релиза, но тем не менее в контейнерах тоже появилось довольно несколько интересных вещей.
508.40 518.72 "Игорь Лабутин" Во-первых, добавились так называемые processes isolated контейнеры для винды, то есть изоляция на уровне процессов, а не на уровне там Hyper-V, например.
518.72 527.96 "Игорь Лабутин" И если вы, например, используете Azure Kubernetes Service, то вы как раз этот самый process isolated используете, если вы виндовый контейнер там запускаете.
527.96 549.76 "Игорь Лабутин" Для контейнеров было несколько фиксов сделано, то есть на самом деле environment.processorcount стал возвращать реальное число процессоров, которые выданы вам условным докером, но выяснилось, что из-за этого скейлинг не всегда хорошо работает, и поэтому появилась возможность переопределить то, что возвращает environment.processorcount через специальное переменное окружение .NET.processorcount.
549.76 563.04 "Игорь Лабутин" Так что если вы как-то используете или ориентируетесь на то количество процессоров, которые вам возвращаются и вы при этом работаете в контейнерах, посмотрите в эту сторону, возможно там что-то поменялось к лучшему или к худшему, и вам нужно использовать это переменное окружение.
563.04 581.40 "Игорь Лабутин" Интересная история с Debian, мы на самом деле затрагивали весной, что Microsoft говорил, что базовыми имиджами для нового, собственно, SDK, для новых контейнеров, для шестого .NET будет Debian 11, но к моменту, когда все это анонсировалось, не было понятно, когда Debian зарелизится.
581.40 601.16 "Игорь Лабутин" Ну, наверное, в этом году, но как бы успеют до, не успеют до, и по словам Microsoft, они ждали практически до последнего момента, чё как, то есть не меняли этого решения, но в итоге, да, Debian 11 зарелизился в августе, так что в ноябре, в начале ноября они прекрасно смогли зарелизиться на уже релизном Debian, не пришлось ничего менять.
601.16 607.76 "Игорь Лабутин" Ну и последняя штука, которую они сделали для контейнеров, это логи.
607.76 630.40 "Анатолий Кулаков" Формат логов немножко изменился, и сейчас мы говорим только об имидже докера, ispnet.net 6, а раньше, еще в .NET 5, на выход в output, в консоль output выдавался в этом случае обычный Simple Console Formatter, то есть обычный тот текст, который вы, наверное, всегда видите, когда запускаете свое ispnet приложение.
630.40 636.60 "Анатолий Кулаков" Вот, теперь этот дефолт изменен, может быть это также затронет ваши текущие настройки, поэтому будьте внимательны.
636.60 652.08 "Анатолий Кулаков" Теперь, по умолчанию, внутри контейнера ispnet 6 выдает JSON-форматер по дефолту, то есть все сообщения логовые пишутся у вас в так называемом New Line Delimiter JSON, ND-JSON.
652.08 663.16 "Анатолий Кулаков" Это тот же самый JSON, просто у него каждая строка — это полноценный отдельный JSON-документик, и они между собой разделяются только переводом строки, вот и все.
663.16 677.88 "Анатолий Кулаков" То есть на консоли вы будете видеть JSON-овские данные, это сделано прежде всего для tools of automatization, которые как раз-таки любят считывать output докера и каким-то образом эти логи парсить и находить там полезную информацию.
677.88 685.36 "Анатолий Кулаков" Безусловно, это можно все отключить, перенастроить через переменные окружения, через код, как угодно, но об этом нужно знать, поэтому повнимательнее.
685.36 692.12 "Анатолий Кулаков" Еще одно интересное нововведение заключается в поддержке OpenTelemetry.
692.12 702.52 "Анатолий Кулаков" Наверное, те, кто следит за нашими выпусками, знают, что .NET уже давно начал свою интенсивную интеграцию с OpenTelemetry, поддерживает ее с ранних версий.
702.52 708.84 "Анатолий Кулаков" Уже последние несколько лет активно разрабатываются всякие протоколы, взаимодействия и новые классы.
708.84 714.96 "Анатолий Кулаков" И вот .NET 6 добавил новую область, появились OpenTelemetry Metrics API.
714.96 723.52 "Анатолий Кулаков" Напомню, что Distributed Tracing уже поддержан, и вот такой второй большой кит приходит к нам — это Metrics.
723.52 729.44 "Анатолий Кулаков" Это пространство имен, имплементированное в системе диагностик Metrics.
729.44 738.80 "Анатолий Кулаков" Поддерживаются различные метрики, такие как Counter, Histogram, Observable Counter и Observable Gauge.
738.80 743.68 "Анатолий Кулаков" Все эти классики, все эти счетчики нужны для разных целей.
743.68 752.48 "Анатолий Кулаков" Кому-то нужно мерить производительность реквестов, кто-то смотрит за, например, за такими показателями, как нагрузка на CPU.
752.48 756.12 "Анатолий Кулаков" В общем, все это разные штуки, которые нужны для разных вещей.
756.12 759.84 "Анатолий Кулаков" Я надеюсь, мы поговорим про них в рамках какой-нибудь отдельной статьи.
759.84 775.80 "Анатолий Кулаков" Здесь же стоит лишь упомянуть, что теперь OpenTelemetry Metrics поддерживается в .NET 6, и очень многие системы мониторинга ваших приложений будут эффективно и красиво работать с вашими новыми приложениями.
775.80 778.60 "Анатолий Кулаков" Также появился классик, который называется MetricListener.
778.60 786.64 "Анатолий Кулаков" Нужен он для того, чтобы внутри вашего кода слушать все эти метрики и делать какие-нибудь агрегации, копировки, выводы, анализы и так далее.
786.64 803.64 "Игорь Лабутин" Да, в общем, если вы на самом деле делаете что-то для клауда, да и не только для клауда, даже если вы это запускаете у себя где-то на своих серверах, то чего как бы не поиспользовать крутую интеграцию с правильными метриками, которые потом можно засылать куда вообще угодно.
803.64 805.56 "Игорь Лабутин" Так что используем.
805.56 806.56 "Игорь Лабутин" Пойдем дальше.
806.56 814.96 "Игорь Лабутин" В Inform'ы, как ни странно, получили некоторое количество обновлений, то есть в Inform'ах улучшилась accessibility.
814.96 825.40 "Игорь Лабутин" В Inform'ах появился, они заменили фонд по умолчанию, то есть раньше был, если я правильно помню, я не помню какой там фонд был раньше, но в общем теперь у нас дефолтный фонд другой.
825.40 835.76 "Игорь Лабутин" Применили туда minimal applications, то есть и обновили, кстати, шаблончики, то есть всякие global usings, file scope, namespace, analabel, reference type, в общем, все это теперь включено.
835.76 846.20 "Игорь Лабутин" И в общем, в Inform'овое приложение тоже стало не таким минималистичным, как SPNet, но, или консольные, но тоже довольно-таки маленьким.
846.20 858.16 "Игорь Лабутин" И они улучшили поддержку дизайнеров, то есть дописали нужные фичи в дизайнере, так что теперь можно писать кастомные дизайнеры, старые какие-то кастомные дизайнеры будут работать, так что в Inform'ы живут и процветают.
858.16 860.76 "Игорь Лабутин" Ни странно, про VPF, кстати, нет вообще ни малейших упоминаний.
860.76 861.76 "Игорь Лабутин" Что там новенького?
861.76 864.96 "Игорь Лабутин" А вот в Inform'ах прям все хорошо, что-то изменяется.
864.96 867.96 "Анатолий Кулаков" Я думаю, что они копят все на релиз Mavi.
867.96 876.48 "Игорь Лабутин" Да, кстати, не исключено, может быть, потому что в Inform'а это все-таки что-то такое старенькое-старенькое, а VPF вполне может быть заменен Mavi.
876.48 883.20 "Игорь Лабутин" Single file API тоже довольно-таки хорошая тема, чтобы все запаковывать в одну единственную .exe.
883.20 896.16 "Игорь Лабутин" Теперь оно, соответственно, работает практически идеально, то есть оно пакует все в один файлик, этот файлик теперь не распаковывается в какую-то темповую директорию при запуске, а все читается прямо из него в память.
896.16 908.28 "Игорь Лабутин" По дефолту нативные зависимости не включаются в этот файлик, но можно их туда запихнуть с помощью специальной MSBuild property, называется include native libraries for self-extract.
908.28 918.40 "Игорь Лабутин" Тогда они туда запишутся, но они как раз будут экстрактиться, потому что, ну, они, скорее всего, нативные, и, соответственно, load library, к сожалению, .NET Runtime не может подменить на лету.
918.40 935.24 "Игорь Лабутин" Добавили некоторые статические анализаторы того, как ваш single file app и кто там от чего зависит, где может что-то сломаться, например, если вы грузите что-то по имени пути с диска, то, конечно, в случае, если эта сборка будет загружена откуда-то из памяти, может что-то не так быть.
935.24 946.32 "Игорь Лабутин" Добавили compression, то есть теперь можно закомпрессить все то, что складывается в единый файл, для этого нужно использовать property enable compression in single file.
946.32 948.12 "Игорь Лабутин" И есть пока одно "но".
948.12 955.56 "Игорь Лабутин" Как они пишут, что вот такие single file аппы могут пока отлаживаться только дебаггерами платформенными, то есть виндбг.
955.56 965.80 "Игорь Лабутин" То есть если вы запаблишите такое приложение как single file app, еще и с компрессионом, еще и так далее, то вы его не сможете нормально отлазить в Visual Studio, и вам придется использовать виндбг для этого.
965.80 970.08 "Игорь Лабутин" Они над этим работают, Visual Studio поддержка, конечно, будет, но она пока нет.
970.08 981.48 "Анатолий Кулаков" Странно, когда, знаешь, в фреймворке обновляются новые версии, там, новые форматы, новые компрессии, это все нужно поддерживать в разных там студиях, тулзах, в дкх, а виндбг тупо работает.
981.48 986.28 "Анатолий Кулаков" Вот тот виндбг, который существует много лет, который ничего не знает про новый формат, он просто работает.
986.28 1002.44 "Игорь Лабутин" Да, ну, там как бы поддержка, ну, скажем так, он работает очень хитро, и он работает, я так понимаю, благодаря тому, что всякие интерфейсы профайлеров не сильно менялись, профайлов, отладчиков, именно в разрезе рантайма, где-то там вот глубоко.
1002.44 1004.16 "Игорь Лабутин" Поэтому все, да, все работает.
1004.16 1010.32 "Игорь Лабутин" Но, кстати, экстенджены, скорее всего, к нему тоже надо как-то обновлять, чтобы они все правильно понимали, все эти дотентные имеются в виду.
1010.32 1011.88 "Игорь Лабутин" Ну ладно, пошли дальше.
1011.88 1022.60 "Игорь Лабутин" В деле уменьшения всего этого дела, кода вашего, еще есть такая штука, называется ill trimming, то есть уменьшение на уровне, собственно, промежуточного кода.
1022.60 1028.04 "Игорь Лабутин" Это не первая попытка Microsoft это сделать, они улучшают эту технологию.
1028.04 1050.44 "Игорь Лабутин" Раньше можно было сказать trim mode, задать такую опцию, и можно было сказать trim mode link, но это была типа opt-in фича, которую нужно было включать с опаской, потому что, или с осторожностью, потому что она могла выбросить кусочки уже не просто целой сборки, если они не используются, а уже прям кусочки кода изнутри ваших сборок, изнутри ваших классов и так далее.
1050.44 1057.48 "Игорь Лабутин" Это могло быть опасно, если, например, есть какой-то рефлекшн или еще что-нибудь хитрое, странное используется.
1057.48 1064.76 "Игорь Лабутин" Теперь это, Microsoft довольно-таки в этом уверен, и поэтому теперь trim mode link это теперь настройка по дефолту.
1064.76 1082.20 "Игорь Лабутин" И кроме этого, компилятор теперь довольно умный, и он знает, ну или анализаторы соответствующие, они знают, когда могут быть проблемы, то есть где ваш код может привести к проблемам, если включен trim mode link, и как это нужно там исправить и так далее.
1082.20 1096.52 "Игорь Лабутин" Соответственно, с точки зрения размера, если мы берем файлик, который без всяких оптимизаций занимает 80 мегабайт, в пятом дотнете с его дефолтным режимом получалось 55 мегабайт, в шестом дотнете с его дефолтным режимом получается 36 мегабайт.
1096.52 1100.56 "Игорь Лабутин" То есть, ну в целом, в полтора раза каждый раз сжимаем.
1100.56 1101.56 "Игорь Лабутин" В принципе, неплохо.
1101.56 1107.68 "Анатолий Кулаков" Направление хорошее, интересно, это уже все, что они планировали, или они могут в будущем выдать размер поменьше?
1107.68 1113.60 "Игорь Лабутин" Наверное, могут поменьше, потому что я так понимаю, что сильно зависит от того, что можно выкинуть из рантайма.
1113.60 1124.52 "Игорь Лабутин" То есть, и потому что где-то я видел статью или какое-то упоминание, что вообще вот самый базовый рантайм, который в BASEMBLE работает, он там что-то типа в какие-то сотни килобайт влезает.
1124.52 1129.40 "Игорь Лабутин" То есть там и JIT, и GC, и все, и оно какое-то очень маленькое.
1129.40 1134.60 "Игорь Лабутин" Ой, не JIT, JIT, кстати, там и нету, там же AOT, по идее.
1134.60 1142.04 "Анатолий Кулаков" Да, интересно почитать, вот куда все это стремится и собирается ли уже на TrimModeling останавливаться, или все-таки будут дальше как-то эту тему пилить.
1142.04 1145.40 "Игорь Лабутин" Но было бы интересно, конечно, пилить, потому что, ну маленькие приложения, это прикольно.
1145.40 1154.16 "Анатолий Кулаков" Ну и при этом Blazer, он только сейчас, грубо говоря, только развивается, только начинается, и там, я думаю, TrimMod тоже хорошо помогает.
1154.16 1155.16 "Игорь Лабутин" Да.
1155.16 1156.16 "Игорь Лабутин" Дальше математика.
1156.16 1183.08 "Игорь Лабутин" Мы, кстати, математики довольно мало касались в наших выпусках, но тем не менее, если вы используете какие-то API-шки из математики, то есть Math, Class, Namespace, то посмотрите, потому что сами API-шки улучшились и плюс добавилось некоторое количество таких performance улучшений, в смысле API-шек, которые прямо ориентированы на performance, ну типа функции, которые одновременно считают и синус, и косинус, потому что частенько это, видимо, бывает надо в математике.
1183.08 1192.00 "Игорь Лабутин" Причем они все, ну все не все, но большая из них часть имеет хардварное ускорение, если оно поддержано на том железе, на котором вы исполняетесь.
1192.00 1202.28 "Игорь Лабутин" Так что если у вас есть какие-то алгоритмы, написанные на вот этих всех математических функциях, возможно, имеет смысл их как-то подумать, посмотреть и при переходе на шестой .NET переписать на что-то более быстрое.
1202.28 1207.72 "Анатолий Кулаков" Ни один большой релиз не обходится без улучшений в JSON-стерилизаторе.
1207.72 1215.64 "Анатолий Кулаков" Microsoft продолжает идти по пути того, что заменяет всю функциональность Newton's Source JSON с помощью своего нового System Text JSON.
1215.64 1221.80 "Анатолий Кулаков" И здесь у них тоже пачка улучшений, естественно, performance, баги и все такое.
1221.80 1223.96 "Анатолий Кулаков" Из интересного появились Source Generators.
1223.96 1226.12 "Анатолий Кулаков" Мы о них тоже упоминали в последнем выпуске.
1226.12 1239.60 "Анатолий Кулаков" Source Generators позволяют вам избавиться от Reflection и код генерации в рантайме и заменить ее на оптимальный сериализованный код во время билд тайма.
1239.60 1246.80 "Анатолий Кулаков" То есть вы практически не будете терять ничего важного и никаких накладных расходов у вас не будет в рантайме.
1246.80 1255.20 "Анатолий Кулаков" Из-за этого у вас уменьшится стартап время вашего сериализатора, время на прогрев всех кэшей, уменьшится потребление памяти обязательно.
1255.20 1267.48 "Анатолий Кулаков" И еще одно не самое маловажное свойство - это теперь ваши сериализаторы станут совместимыми с Eltrimming, который мы упоминали выше.
1267.48 1279.80 "Анатолий Кулаков" То есть теперь Eltrimming может обрубить ненужные вещи, которые не используются без опаски того, что в рантайме вы с помощью Reflection начнете туда лазить и все от этого упадет.
1279.80 1286.64 "Анатолий Кулаков" Поэтому это тоже такой интересный побочный эффект, можно сказать, Source Generators, которые помогут также сократить размер ваших файлов.
1286.64 1296.68 "Анатолий Кулаков" Это все, все эти потуги дают примерно ускорение в полтора раза на самых примитивных, самых обычных объектах.
1296.68 1302.32 "Анатолий Кулаков" На каких-то структурах посложнее, цифры разнятся, но обычно не меньше.
1302.32 1306.56 "Анатолий Кулаков" То есть перформанс очень сильно улучшается с помощью Source Generators.
1306.56 1315.04 "Анатолий Кулаков" Также в сериализаторах, конкретно в этом System Text Generation сериализаторе поддержали новый интерфейс iOSyncE Numerable.
1315.04 1336.48 "Анатолий Кулаков" Теперь сериализатор понимает, что это такое, знает и методу serializeAsync было специально сделано в новоучение, с помощью которого он знает, как этот класс правильно сериализовать, то есть не бюферизируя, а абсолютно синхронно записывать это все в поток.
1336.48 1343.24 "Анатолий Кулаков" И интересно, что теперь еще класс есть, в классе сериализатор появился метод deserializeAsyncE Numerable.
1343.24 1349.84 "Анатолий Кулаков" Он, правда, поддерживает только рутовые массивы, но зато может десериализовать их асинхронно.
1349.84 1354.12 "Анатолий Кулаков" И это отличный юзкис для какого-то большого массива данных.
1354.12 1362.96 "Анатолий Кулаков" Какой-то огромный стрим с данными приходит, и вот его вы можете десериализовать абсолютно по одному значению и сразу же отдавать в другие протоколы.
1362.96 1373.32 "Анатолий Кулаков" Например, можете сразу его в Network Stream отдавать и на другой стороне его асинхронно точно так же будут получать клиенты, если опять же все это поддерживает цепочку asyncE Numerable.
1373.32 1389.56 "Анатолий Кулаков" И из другого интересного в JSON теперь поддержан writeable DOM, то есть вы теперь можете представить весь ваш JSON-документ в виде специальных удобных классиков, в которые удобно писать и удобно модифицировать.
1389.56 1414.16 "Анатолий Кулаков" Это может быть нужно, например, если вам заранее неизвестна схема того документа, который вы собираетесь писать, и соответственно вы не можете использовать стандартные DTO или POCO классы, и поэтому в таких случаях writeable DOM очень сильно вас выручит, вам не придется все-таки к низкоуровневому врайтеру обращаться напрямую, а вот такой высокоуровневый API у вас появится.
1414.16 1423.52 "Анатолий Кулаков" Также удобно, когда у вас есть какое-то большое дерево все-таки с JSON-документом, и вы хотите модифицировать его маленькую часть, какой-то маленький подкомпонентик, веточку.
1423.52 1428.44 "Анатолий Кулаков" Тоже удобно с помощью такой штуки добраться и заменить все, что нужно, или даже считать все, что нужно.
1428.44 1435.32 "Игорь Лабутин" Следующий кусочек посвящен таким, на самом деле не очень понятным вещам, это Source and Reproducible Builds.
1435.32 1445.20 "Игорь Лабутин" В статье говорится, что Source билды - это вообще большой шаг в сторону Reproducible Builds, в которые Microsoft довольно сильно верит и, видимо, к ним стремится.
1445.20 1450.32 "Анатолий Кулаков" Может, она к ним и стремится, но не очень понятно, что такое Reproducible Builds.
1450.32 1462.60 "Анатолий Кулаков" Давай немножко разберемся в этой теме поглубже, и специально для этих целей у нас в студии сейчас Михаил Филиппов, разработчик из компании JetBrains, и как раз его мы и спросим, что же это такое.
1462.60 1463.60 "Анатолий Кулаков" Привет, Миша!
1463.60 1464.60 "Анатолий Кулаков" Привет, Анатолий!
1464.60 1468.44 "Анатолий Кулаков" Расскажи, что же все-таки такое Reproducible Builds и зачем они вообще нужны?
1468.44 1471.64 "Михаил Филиппов" Это очень большая тема, на самом деле.
1471.64 1482.60 "Михаил Филиппов" Можно начать с того, что у нас в начале этого года, по-моему, был прекрасный инцидент с компанией Solar Winds, когда ребята поставили трояна многим своим кастомерам.
1482.60 1493.88 "Михаил Филиппов" Это было крайне неприятно, и не хотелось бы такое никому повторить, наверное, и поэтому Reproducible Builds помогают митигировать.
1493.88 1504.16 "Михаил Филиппов" На самом деле сейчас много проблем с зависимостями, недавно с NPM было несколько проблем, когда через зависимость внедрялась всякая вредоносная фигня.
1504.16 1509.84 "Михаил Филиппов" Суть Reproducible Builds в том, что то, что вы собираете, можно взять и бинарно повторить.
1509.84 1528.52 "Михаил Филиппов" То есть, грубо говоря, взяв ваш набор исходников, ваш набор зафиксированных зависимостей, можно взять все ваши зависимости, проверить их, что это то, что надо, что это те самые зависимости, которые имел в виду разработчик, когда их добавлял, и что из тех же самых исходников получается тот же самый результат.
1528.52 1540.00 "Михаил Филиппов" Если у вас получается бинарно эквивалентный результат, все, бинго, у вас Reproducible Builds, значит, вы можете прийти в третьеостороннюю компанию и попросить их проверить, что вы все сделаете правильно.
1540.00 1546.92 "Михаил Филиппов" Они в своей инфраструктуре возьмут ваши исходники, ваши зависимости, проведут сборку и бинарно сверят, например, дистрибутив.
1546.92 1552.36 "Михаил Филиппов" Также это полезно, например, людям, которые как-то хотят ваше ПО забандлить.
1552.36 1557.52 "Михаил Филиппов" Например, мы бандлим с собой .NET Runtime, и нам очень хочется уметь в него делать патчи.
1557.52 1570.84 "Михаил Филиппов" Но когда мы делаем патчи в Runtime, важно понимать, что вы собрали то же самое, что шипует вендор, то есть Microsoft, чтобы не получилось так, что мы где-то ошиблись с лагами сборки или еще с чем-то, и там тоже важно.
1570.84 1580.72 "Михаил Филиппов" Поэтому для .NET это важно, иметь Reproducible Builds, чтобы клиенты типа нас могли взять и собрать у себя и проверить, что там нет никаких закладок со стороны вендора.
1580.72 1584.44 "Анатолий Кулаков" Ну, по крайней мере, тех закладок, которых нет в открытых сердцах, да?
1584.44 1587.24 "Михаил Филиппов" Да, да, потому что там всякая фигня может быть.
1587.24 1597.40 "Михаил Филиппов" Во время билда наложат какой-то патч, который что угодно поменяет, а потом это выйдет боком, потому что когда выбрали, не рассчитывали на этот патч и всякое такое.
1597.40 1601.92 "Михаил Филиппов" Дальше там есть всякое интересное, что в .NET происходит с Reproducible Builds.
1601.92 1607.56 "Михаил Филиппов" Это то, что в NUGET пакетах современных там появилось...
1607.56 1609.48 "Михаил Филиппов" когда вы собираете пакет, ну, если...
1609.48 1612.08 "Михаил Филиппов" это, например, касается сильно open-source ребят.
1612.08 1625.72 "Михаил Филиппов" То есть если у вас есть open-source проект, и вы хотите своим клиентам, кто вас потребляет, просто дать способ проверить, что то, что выложено на NUGET.org, это то, что у вас лежит на GitHub, потому что где гарантия?
1625.72 1633.60 "Михаил Филиппов" То есть у вас есть source link какой-нибудь, который прописывает, что вот мой репозиторий лежит вот там, исходники от него там, была такая-то ревизия.
1633.60 1636.76 "Михаил Филиппов" Но где гарантия, что эту информацию просто по пути не подменили?
1636.76 1647.80 "Михаил Филиппов" Что не взяли, скачали, окей, ваш, склонили Rep, потом накатили на это какой-нибудь, на вашем CI специальный патчик, и этот патчик залили... пакет, собранный с этим патчиком, залили на NUGET.org.
1647.80 1654.20 "Михаил Филиппов" А дальше все ваши клиенты получили майнер, например, в виде зависимости к своей программе.
1654.20 1676.96 "Михаил Филиппов" И там у нас, например, некоторое время назад Мартин, по-моему, писал статейку прикольную про то, как, собственно, сделать такие интересные всякие штуки в Дотнете, когда ты можешь, используя специальные атрибуты в сборке, сделать так, чтобы очень скрытно и хитро твой код запустился так, чтобы при этом разработчики не увидели это.
1676.96 1683.60 "Михаил Филиппов" В Дотнете есть там некоторые ручечки, которые позволяют очень филигранно внедриться так, что будет незаметно.
1683.60 1690.32 "Михаил Филиппов" И поэтому хотелось бы, чтобы, по крайней мере, то, что лежало на GitHub соответствовало тому, что ставит ваш пользователь.
1690.32 1694.56 "Михаил Филиппов" Ну и, собственно, Microsoft, а там еще всякие интересные штуки есть.
1694.56 1696.80 "Михаил Филиппов" Например, флаги компиляции Roslin.
1696.80 1704.52 "Михаил Филиппов" То есть в Roslin, вообще в Дотнет-проектах, чтобы начать как бы пытаться сделать reproducible билды, что вам нужно сделать?
1704.52 1711.76 "Михаил Филиппов" Первое, вам нужно желательно, чтобы все ваши зависимости были reproducible, иначе вопросы возникнуть могут.
1711.76 1715.84 "Михаил Филиппов" А второе, вам нужно включить в проекте флаг, по-моему, детерминистик build.true.
1715.84 1725.16 "Михаил Филиппов" После этого Roslin, когда будет вас компилировать, ваши исходники, он сделает несколько хитрых штук, которые позволят получать бинарно-генетичный результат.
1725.16 1730.92 "Михаил Филиппов" Из хитрых штук, про которые надо думать, это, например, когда вы шьете...
1730.92 1738.72 "Михаил Филиппов" У вас есть PDB-шки, отладочная информация, например, встроенная, и в них шьются пути на системе на вашей.
1738.72 1741.24 "Михаил Филиппов" Там в экзешнике шьются пути, где исходники искать.
1741.24 1743.68 "Михаил Филиппов" И, соответственно, если туда...
1743.68 1752.04 "Михаил Филиппов" Ну, видели, наверное, на GASTAC Trace, который выпадает или информацию, и там оригинальный путь к исходнику на какой-нибудь машине сборки лежит.
1752.04 1753.04 "Михаил Филиппов" Вот.
1753.04 1754.04 "Михаил Филиппов" Когда...
1754.04 1757.92 "Михаил Филиппов" Чтобы такого не было, мы там, например, делаем специальный маппинг, чтобы этих путей не было.
1757.92 1762.32 "Михаил Филиппов" Потом у сборки там есть вид, который рандомный, есть таймстемпы.
1762.32 1769.08 "Михаил Филиппов" Вот когда вы этот ключ включаете в Roslin, Roslin начинает быть аккуратен и производить бинарно-генетичные результаты.
1769.08 1770.72 "Михаил Филиппов" У него не всегда это получается.
1770.72 1780.16 "Михаил Филиппов" А когда мы делали, мы нашли баг в Roslin, который при определенном хитром сложении структур генерирует в рандомном порядке их.
1780.16 1785.48 "Михаил Филиппов" Это удивительно, но если вы тестируете свою билдовую воспроизводимость, вы такие штуки будете находить.
1785.48 1787.44 "Анатолий Кулаков" Слушай, а расскажи ты это на примитивных примерах.
1787.44 1794.40 "Анатолий Кулаков" Вот действительно тебе нужно прописать путь к исходникам, и, естественно, исходники на каждой билдовой машине по разным путям лежат.
1794.40 1796.16 "Анатолий Кулаков" Как это можно решить с помощью?
1796.16 1797.16 "Анатолий Кулаков" Как это решается?
1797.16 1802.92 "Михаил Филиппов" Есть специальные параметры в Cessproject, которые говорят сделать маппинг.
1802.92 1808.52 "Михаил Филиппов" То есть, грубо говоря, будет рут проекта ваш заменен на некоторую константу.
1808.52 1810.96 "Михаил Филиппов" Например, мы Project Root, по-моему, вставляем туда.
1810.96 1828.64 "Михаил Филиппов" То есть, относительный путь исходника, относительный путь проекта будет правильный, а вот корень проекта на билд-машине будет заменен на подкладку, и, соответственно, когда вы будете дебажить с такой PDB, студия спросит вас, где исходники лежат, мы иногда в райдере сможем это сами найти.
1828.64 1829.64 "Михаил Филиппов" Ну, иногда спросим тоже.
1829.64 1830.64 "Михаил Филиппов" Ну, хорошо.
1830.64 1833.36 "Анатолий Кулаков" В принципе, проблема понятна.
1833.36 1834.36 "Анатолий Кулаков" Зачем она нужна?
1834.36 1835.36 "Анатолий Кулаков" Понятно.
1835.36 1836.36 "Анатолий Кулаков" Расскажи все-таки, как ее решили.
1836.36 1845.48 "Анатолий Кулаков" Ну, то есть, допустим, я действительно на GitHub выложил одни исходники у себя, на билд-сервере собрал другие и выложил пакет вообще, не соответствующий с исходниками.
1845.48 1847.68 "Анатолий Кулаков" Каким образом я могу это сматчить или проверить?
1847.68 1849.40 "Анатолий Кулаков" Какие инструменты для этого есть?
1849.40 1851.64 "Михаил Филиппов" Во-первых, все это...
1851.64 1901.88 "Михаил Филиппов" Если ты использовал правильные ключики при сборке пакета и при сборке DLL для пакета, про то, про что я говорил, что там терминистик поставить, вошьешь правильно конфигурацию сорслинка, который ссылки на GitHub даст, после этого, по-моему, команда .NET Validate есть, которая возьмет, собственно, все данные, которые прописаны в Nuget, скачает твои зависимости, положит их, скомпилирует и сверит результат, что, собственно, Microsoft активно в этом плане работает, например, в последнем Nuget Explorer появились галочки, что Build Reproducible в виде таких зелененьких тиков, то есть если открыть Nuget пакет какой-нибудь современный, собранный тем, кто заботится о воспроизводимости, вы увидите там зеленую галочку, что этот проект можно взять и пересобрать, и получить точно тот же самый результат, который получил автор пакета.
1901.88 1905.64 "Анатолий Кулаков" Ну, я правильно понимаю, что эта галочка, она просто чисто на доверии?
1905.64 1931.16 "Михаил Филиппов" Эта галочка пока... да-да, конечно, эта галочка показывает только то, что пакет был собран с правильными флагами, и после этого там как-то происходит, после этого на него накладывается подпись Nuget, Nuget.org, то есть он становится подписан, и после этого ты можешь взять этот пакет, собственно, проверить подпись, что подпись целая, то есть его по пути никто не модифицировал, и проверить, взяв его параметры сборки, собрать такой же и излечить бинарно, что это одно и то же.
1931.16 1942.08 "Михаил Филиппов" То есть верификация пакета все равно остается на совести конечного пользователя, но, ну, как бы понятно, потому что это какие-то ресурсы довольно ощутимые могут затратить.
1942.08 1959.84 "Михаил Филиппов" Но в этом случае хорошо, что ты можешь это сделать один раз, зафиксировать хэш этого пакета, и дальше все, дальше у тебя уже будет... ну, если у тебя какие-то специфические билд-системы, которые верифицируют результаты сборки продукта, и этот пакет к нему встраивается, они уже будут иметь один и тот же хэш, результирующий.
1959.84 1967.60 "Анатолий Кулаков" Ну, то есть неплохо было бы, если бы на себя какой-нибудь сторонний сервис или, допустим, тот же самый Nuget.org взял на себя эту работу, то есть все пакеты там верифицировал
1967.60 1969.60 "Михаил Филиппов" бы. Нет, плохо.
1969.60 1970.60 "Михаил Филиппов" А почему?
1970.60 1973.28 "Михаил Филиппов" Ну, потому что как ему можно доверять?
1973.28 1975.60 "Михаил Филиппов" Ну, в смысле, где гарантия, что его не хакнут?
1975.60 1978.44 "Михаил Филиппов" Ты же как бы... ну, вот представь себе ситуацию, да?
1978.44 1984.44 "Михаил Филиппов" Ну, там, Nuget.org, окей, большой крупный сервис, я имею в виду там какой-нибудь MyGet, не знаю, что-нибудь поменьше, кто хостит пакеты.
1984.44 1985.92 "Михаил Филиппов" Их скомпрометировали.
1985.92 1986.92 "Михаил Филиппов" И дальше что?
1986.92 1996.48 "Михаил Филиппов" Дальше что, получается, к тебе придет пользователь с вопросом "Парень, а откуда у меня майнер?", а ты скажешь "Ну, там Nuget.org взломали, ну нет, так не будет работать".
1996.48 2001.24 "Михаил Филиппов" Поэтому то, что ты поставляешь, за это отвечаешь только ты.
2001.24 2012.16 "Михаил Филиппов" Да, ты можешь использовать третью сторону как authority, которая, ну, нотаризация, грубо говоря, проведет твоего результата, возьмет его, проверит и скажет, что да, похоже, это то, что хотели собрать.
2012.16 2013.16 "Михаил Филиппов" Но не больше.
2013.16 2025.76 "Михаил Филиппов" Это не гарантирует, что у тебя, опять же, нету извимости, не гарантирует, что у тебя нет проблем, но репродуктивовые билды позволяют третьей стороне валидировать результат билда, что именно из этих исходников получили именно такие бинарии.
2025.76 2042.56 "Игорь Лабутин" Так, итак, да, спасибо, Миша, мы теперь имеем неплохое представление о том, что такое reproducible билды, и давай теперь вернемся, может быть, немножко к моей исходной фразе про то, что source builds — это большой шаг в сторону reproducible билдов.
2042.56 2053.44 "Игорь Лабутин" Майкрософт поясняет это тем, что вы теперь можете просто собрать .NET SDK на вашей собственной машине из исходников с помощью всего лишь нескольких команд.
2053.44 2058.68 "Игорь Лабутин" Интересно, почему так не было раньше, или, может быть, раньше так тоже было, но почему-то теперь так очень сильно называется.
2058.68 2076.80 "Игорь Лабутин" Плюс эти самые source builds, по мнению Майкрософта, ну и, видимо, не только по мнению Майкрософта, являются таким стандартом для всяких Linux-дистрибутивов, потому что там open source, вот это все вы должны уметь собирать с помощью компиляторов и тулчейнов, которые входят в дистрибутив, и поэтому вот это такой big deal.
2076.80 2080.96 "Анатолий Кулаков" Ну, тоже какая-то мутная тема, давай воспользуемся шансом, что мы Мишу еще не отпустили.
2080.96 2086.84 "Анатолий Кулаков" Миша, расскажи, пожалуйста, с твоей точки зрения, а что такое вот эти source builds?
2086.84 2091.80 "Михаил Филиппов" О, это почти из этой же оперы, но немножко в другом разрезе.
2091.80 2093.36 "Михаил Филиппов" Что такое source build?
2093.36 2109.56 "Михаил Филиппов" Есть, короче, представленная система Linux, и у них принято, чтобы когда ты собираешь какой-то пакет, ты собирал его из исходников, и при этом все, что нужно тебе, было в этот момент с тобой.
2109.56 2117.64 "Михаил Филиппов" Ну, то есть, грубо говоря, ты вот такой берешь zip-архив, грубо говоря, source-архив, взяв который, и build-система, и тебе интернет не нужен.
2117.64 2143.68 "Михаил Филиппов" Чтобы не было зависимостей, которые лежат у кого-то подконтрольны, потому что если предположить, например, что там есть зависимости, которые лежат, ну, например, не знаю, тебе нужно, например, поставить Visual Studio для того, чтобы собрать продукт, это уже зависимость, которую нельзя использовать в open-source, ну, или очень сложно, потому что как ты на безсистемы доставишь, как люди-пользователи будут проверять это, если у них нет Visual Studio.
2143.68 2152.44 "Михаил Филиппов" Поэтому, как бы, source build — это такой самодостаточный архив, взяв который, и только его можно собрать готовый продукт.
2152.44 2158.80 "Михаил Филиппов" Собственно, требование попадания в крупные репозитории типа Debian, по-моему, наличие такого билда.
2158.80 2168.08 "Михаил Филиппов" Ну, или это, может быть, не 100%, обязательно, я точно не помню, но то, что это хорошо, это правда.
2168.08 2171.44 "Михаил Филиппов" Ну, то есть вообще правильно иметь такую возможность.
2171.44 2187.96 "Михаил Филиппов" Опять же, например, если вы хотите провалидировать, что ваш билд репродюсибл, хорошо бы третьей стороне не нужно было иметь доступ к вашим внутренним сетям, там, пакетным репозиториям и прочему всему, отдать им один какой-нибудь RGZ-ничек, который они возьмут, распакуют, запустят скриптик, и он соберет результат.
2187.96 2190.52 "Михаил Филиппов" Вот это примерно то, что SourceBuild делает.
2190.52 2199.32 "Анатолий Кулаков" Где-то же все равно должно быть дно, ну, то есть, ну, get-пакеты, я еще понимаю, может быть, можно таскать с собой, но CLR, runtime, C#, ты же не будешь в Zip-чик?
2199.32 2200.32 "Михаил Филиппов" .NET, runtime, почему?
2200.32 2202.84 "Михаил Филиппов" Будешь, конечно, ну, в смысле, берешь .NET.
2202.84 2213.24 "Михаил Филиппов" Слушай, у нас на билд-системе примерно так и происходит, то есть мы скачиваем себе наш .NET, скачиваем себе исходники, берем .NET, берем исходники, результат.
2213.24 2226.16 "Михаил Филиппов" Если ты кладешь это в один архив, и .NET, которым собирали, и исходники, вот тебе, собственно, на руках компилятор, лицензия позволяет, на руках, собственно, исходники, берешь, совмещаешь вместе, получаешь результат.
2226.16 2227.88 "Михаил Филиппов" В Reproducible, в SourceBuild.
2227.88 2234.40 "Анатолий Кулаков" Тот же самый компилятор, чтобы собрать, тебе нужен C#, ростлинг написан на C#, где курица, где яйцо, как это сделать?
2234.40 2238.80 "Михаил Филиппов" Ну, а, там еще интересная хитрость сделана.
2238.80 2244.44 "Михаил Филиппов" Если я правильно помню, в Linux'ах у тебя несколько стадий, билд состоит из нескольких стадий.
2244.44 2248.76 "Михаил Филиппов" У тебя есть первый Bootstrap, грубо говоря, как это, GCC, когда собираешь, да?
2248.76 2259.72 "Михаил Филиппов" У тебя есть первое нечто, что собирает из исходников, да, да, вот точно, я вспомнил, почему это SourceBuild называется, потому что есть исходники, и есть некоторый Bootstrap Tooling.
2259.72 2278.76 "Михаил Филиппов" Ты из этих исходников собираешь себе полностью Runtime, компилятор, все такое, а затем, с помощью того, что ты собрал, фактически, из исходников, уже собираешь в второй раз сборку делаешь, и получаешь уже результат, который собран тобой, из твоих исходников, как бы, понимаешь, да?
2278.76 2286.36 "Михаил Филиппов" То есть, изначально есть Bootstrap, который собирает бинари, которыми ты компилируешь потом, и они уже производят конечный результат.
2286.36 2293.12 "Михаил Филиппов" Это, опять, сделано для того, чтобы у тебя нельзя было от первой стадии сделать закладку такую во вторую стадию, наверное.
2293.12 2310.12 "Михаил Филиппов" Ну, и показать, что у тебя достаточно, ты самодостаточен, грубо говоря, знаешь, бывает история, когда сначала компилятор пишет на каком-нибудь C++, а потом проходит там пару лет, и big achievement, типа, мы научились собирать, не знаю, Go с помощью Go или Rasta с помощью Rasta.
2310.12 2314.00 "Михаил Филиппов" Вот это, собственно, когда они достигают фазы того, что Source Build можно сделать.
2314.00 2318.56 "Анатолий Кулаков" Слушай, ну, кажется, люди там сильно загоняются в этих Open Source, в Linux, по поводу безопасности.
2318.56 2322.52 "Михаил Филиппов" А иначе у тебя может быть очень интересные последствия.
2322.52 2332.52 "Михаил Филиппов" Представь себе, что ты какой-нибудь, не знаю, молодой язык, ну, совсем молодой, да, и внезапно у тебя утрачены все возможности скомпилировать.
2332.52 2335.48 "Михаил Филиппов" Вот ты не думал никогда, как C, например, собирали первый компилятор?
2335.48 2337.68 "Михаил Филиппов" Я уже боюсь представить даже.
2337.68 2339.68 "Михаил Филиппов" По-моему, его писали на машинных кодах.
2339.68 2340.68 "Михаил Филиппов" Ну, то есть, чтобы...
2340.68 2349.16 "Михаил Филиппов" Я не помню точно, то ли на Assembler, ну, короче, идея в том, что пока у тебя нет компилятора для своего языка, ты не можешь ничего скомпилировать.
2349.16 2356.20 "Михаил Филиппов" И пока у тебя есть вот этот вот Source Build, есть гарантия, что какую-то версию языка ты все еще можешь собрать.
2356.20 2362.80 "Михаил Филиппов" Может быть, она не суперсвежая, но где-то есть точка начала, где, взяв исходники, ты можешь получить результат.
2362.80 2373.32 "Михаил Филиппов" Ну, а в Open Source, как бы, вся идея в том, что, как бы, любой человек может взять исходники и получить результат, который, ну, который поставляют тебе, чтобы, например, его пропатчить.
2373.32 2394.56 "Михаил Филиппов" Потому что иногда, в нашем случае, например, мы с собой носим рантайм не от хорошей жизни, а потому что мы хотим какую-то стабильность, ну, мы хотим конкретный рантайм, и мы хотим иногда его патчить, потому что бывают уязвимости, ждать которых, ну, уязвимости в смысле некоторые хитрые сценарии багов, которые нас аффектят, но не аффектят сильно других.
2394.56 2395.92 "Михаил Филиппов" Ну, корнер-кейсы какие-то.
2395.92 2405.12 "Михаил Филиппов" И поэтому мы вынуждены взять, вот, собственно, рантайм, пофиксить этот баг, там, отправив его в AppStream, но пока выйдет новый релиз, пройдет полгода.
2405.12 2407.40 "Михаил Филиппов" А у нас у кастомеров там крашится продукт.
2407.40 2408.40 "Михаил Филиппов" Как быть?
2408.40 2412.96 "Михаил Филиппов" Ну, только взять, собрать свой рантайм, вложить его с собой и носить с собой.
2412.96 2420.60 "Анатолий Кулаков" Классно, что вся эта история про open-source, знаешь, это не оканчивается тем, что ты на GitHub исходники выложил, а вот развивается в очень интересных направлениях.
2420.60 2421.60 "Анатолий Кулаков" Вот это мне нравится.
2421.60 2429.00 "Михаил Филиппов" Слушай, в любом open-source выложить исходники на GitHub, это прям совсем даже не полработа.
2429.00 2439.04 "Михаил Филиппов" То есть потом к тебе придут люди и скажут, окей, а как к тебе отправить contribution, как проверить, как тесты прогнать, как собрать, как вообще, что это вообще такое, где взять документацию.
2439.04 2445.88 "Михаил Филиппов" Мы ведем несколько гитхабных проектов open-source, где принимаем contribution и там вот, короче, сложно все.
2445.88 2451.16 "Михаил Филиппов" Потому что это такая инвестиция, которая поначалу совсем непонятно зачем.
2451.16 2455.04 "Михаил Филиппов" То есть у тебя есть девелоперы, да, ты открыл кусочек кода, ну, типа мир, держи.
2455.04 2461.36 "Михаил Филиппов" Но если ты хочешь получать обратно contribution, тебе придется очень много времени потратить на всякие-всякие мелочи.
2461.36 2471.04 "Михаил Филиппов" Дотнет тот же, например, там, не знаю, MS Build, куда я контрибью, там бывает иногда прикол, у тебя, не знаю, билд ломается, если у тебя в пути есть пробел.
2471.04 2479.24 "Михаил Филиппов" Вот ты взял себе, его склонировал в папочку с юзернеймом, с пробелом и все, у тебя не забирается продукт.
2479.24 2486.20 "Михаил Филиппов" И это всякие, ну, много всяких приколов, о которых стоит подумать, о том, чтобы не было зависимости.
2486.20 2501.72 "Михаил Филиппов" Там, не знаю, если у тебя есть зависимость на какой-то тулчейн на машине стоящей, а еще через реестр, например, то очень веселые приключения ждут своих пользователей, у которых появляются разные версии, а ты не можешь собрать на конкретный какой-то.
2501.72 2505.12 "Михаил Филиппов" Как объяснить пользователю, что нужно поставить, что нужно засетапить.
2505.12 2516.80 "Михаил Филиппов" Я думаю, каждый разработчик в компании, ты тоже сталкивался с тем, что ты приходишь в компанию, и что мне сделать, чтобы сделать первый комитт свой осмысленный, что мне нужно сделать, чтобы собрать проект.
2516.80 2526.40 "Михаил Филиппов" Иногда это инструкции многостраничные, и задача инфротимов — это как раз свести их к тому, что, не знаю, склонировал репку, запустил байтник и работаешь.
2526.40 2527.80 "Михаил Филиппов" Вот это идеальный вариант.
2527.80 2541.40 "Анатолий Кулаков" Да, именно поэтому и важно двигаться в этом направлении, чтобы каждый разработчик осознавал весь тот environment, весь тот мир, который происходит вокруг, а не просто думал, что Visual Studio — это все, что у нас есть, и вот все, что нужно для нормального разработчика.
2541.40 2549.60 "Анатолий Кулаков" Нет, вам нужно очень много знаний, вам нужно очень много всего пониманий для того, чтобы это работало правильно, безопасно, стабильно и качественно.
2549.60 2559.60 "Михаил Филиппов" Да, у тебя, если это open source проект, если контрибьютеру будет сложно собрать тебя или протестить, то он через 5 минут отвалится, и все, ты не получишь contribution.
2559.60 2567.60 "Михаил Филиппов" Поэтому разработчики прямо заинтересованы в том, чтобы писать качественные инструкции, делать нормальные настройки и чтобы это было доступно для всех.
2567.60 2570.84 "Анатолий Кулаков" Отлично, Михаил, большое спасибо за такие качественные объяснения.
2570.84 2573.76 "Анатолий Кулаков" Я думаю, многим стало понятнее, мне уж точно.
2573.76 2577.24 "Анатолий Кулаков" Я напомню, что с нами был Михаил Филиппов, разработчик из компании JetBrains.
2577.24 2586.84 "Игорь Лабутин" А мы поедем дальше, у нас еще огромное количество материал на сегодня, и продолжаем мы следующим списком улучшений в API-шках всяких разных библиотек.
2586.84 2594.76 "Игорь Лабутин" Я не буду углубляться во все изменения, их там прям, наверное, в буквальном смысле сотни, если не тысячи, но кратенько пробегусь по заголовкам.
2594.76 2602.48 "Игорь Лабутин" Это поддержка компрессии сжатия веб-сокетов, поддержка SOCKS-прокси, если вам это зачем-то надо.
2602.48 2608.44 "Игорь Лабутин" В S/P Network можно настраивать host options теперь с помощью метода configure host options еще более гибко.
2608.44 2616.92 "Игорь Лабутин" Если вы в стандартах Microsoft, в Dependency Injection использовали BeginScope, то теперь есть еще Async-версия.
2616.92 2622.48 "Игорь Лабутин" В Logging появились тоже Source-генераторы, которые позволяют более оптимально писать логи.
2622.48 2626.56 "Игорь Лабутин" В LinkU огромное количество улучшений, изменений, дополнений.
2626.56 2632.16 "Игорь Лабутин" Смотрите, если вы пользуетесь LinkU, а кто им опять же не пользуется, наверное, многие.
2632.16 2639.60 "Игорь Лабутин" Priority Queue добавили, улучшили поддержку TimeZones и Windows, и правильных, которые и она.
2639.60 2652.40 "Игорь Лабутин" Сделали Public Class Dependent Handle, он позволяет делать всякие очень странные штуки типа Conditional Week Table, то есть это такой типа почти как Week Reference, но с хитрым трекингом в сторону garbage-коллектора.
2652.40 2658.48 "Игорь Лабутин" И переписали ThreadPool на полностью менеджерную версию, и он теперь одинаковый везде на всех операционках.
2658.48 2677.28 "Игорь Лабутин" Кроме этого, конечно, изменения довольно много коснулись JITA и всяких технологий типа Ready to Run, то есть мы подробно описывали, как они меняли CROSSGEN, то есть это стул, который позволяет вам генерить нативные образы под разные операционки, находясь на какой-то другой операционке.
2677.28 2688.88 "Игорь Лабутин" Теперь CROSSGEN2 официально в релизе, и CROSSGEN1 полностью выпилен, потому что, как они сказали, они смогли с помощью CROSSGEN2 скомпилировать SDK самого .NET для разных операционок, ну, генотивный код.
2688.88 2693.20 "Игорь Лабутин" Тем самым его, так сказать, задокфудили и решили, что CROSSGEN1 пора на пенсию.
2693.20 2696.96 "Игорь Лабутин" А .NET Diagnostics есть некоторое количество изменений.
2696.96 2708.60 "Игорь Лабутин" EventPipe — это технология, которая используется для того, чтобы, собственно, из Coursera, из .NET, экспозить разные новые ивенты, это замена там performance counter и так далее, подобные штуки.
2708.60 2721.08 "Игорь Лабутин" Она была переписана из C++ на C, и после этого внезапно оказалось, что теперь ее можно использовать в Mono, и поэтому Mono Runtime теперь ее тоже использует, и по идее, как я понимаю, это значит, что он должен подхватываться .NET Monitor, например.
2721.08 2732.72 "Игорь Лабутин" Кроме этого, в целом в .NET Diagnostics вот в этом EventPipe и вокруг него произвели некоторое количество улучшений, в итоге пропускная способность улучшилась примерно в два раза.
2732.72 2735.80 "Анатолий Кулаков" СДК также коснулись большие изменения.
2735.80 2738.28 "Анатолий Кулаков" Во-первых, это добавление workload.
2738.28 2747.88 "Анатолий Кулаков" Теперь весь SDK разбит на такие своеобразные зоны влияния, которые называются workloads, что позволило сильно сократить его изначальный размер.
2747.88 2759.04 "Анатолий Кулаков" То есть изначально в SDK там очень мало полезных инструментов и очень мало функциональности, но зато эти workloads вы можете настраивать и доставлять себе только те, которые вам нужны.
2759.04 2765.84 "Анатолий Кулаков" Вот в .NET Just Home как раз-таки вот эта концепция была отработана в превью и сейчас пошла в продакшн.
2765.84 2772.12 "Анатолий Кулаков" Из новых workloads добавились к релизу это .NET MAUI и Blazor WebAssembly Out.
2772.12 2779.08 "Анатолий Кулаков" Visual Studio управляет этими workloads за вас, поэтому вы, наверное, даже не должны об этом никак задумываться и скорее всего для вас это будет прозрачным.
2779.08 2788.24 "Анатолий Кулаков" Естественно, можно ими управлять с помощью командной строки, то есть обновлять, искать, устанавливать, удалять и все как положено.
2788.24 2794.76 "Анатолий Кулаков" Также у нас есть новые команды для .NET.
2794.76 2806.20 "Анатолий Кулаков" Во-первых, это команда, которая позволяет вам легко проверять версию вашего текущего SDK и всех рентаймов, которые у вас созданы, установлены.
2806.20 2808.88 "Анатолий Кулаков" Это команда .NET SDK Check.
2808.88 2816.32 "Анатолий Кулаков" Также у нас появилась команда, которая помогает вам искать в Nuget новые темплейты для шаблона new.
2816.32 2831.04 "Анатолий Кулаков" Часто бывает такое, что мы создаем пустые начальные проекты с помощью .NET new и существует очень много вокруг вещей, программ, каких-то блоков, библиотек, которые было бы неплохо, под которые было бы неплохо иметь вот эти шаблоны.
2831.04 2837.24 "Анатолий Кулаков" Теперь можно их поискать прямо в Nuget, а независимые поставщики в этот самый Nuget могут их складывать.
2837.24 2838.72 "Анатолий Кулаков" Тоже удобная штука.
2838.72 2850.12 "Анатолий Кулаков" Еще одно нововведение - это Nuget Packet Validation, которое добавляет кучу анализаторов для ваших Nuget пакетов, которые проверяют и исправляют, и подсказывают вам много интересных и полезных вещей.
2850.12 2851.96 "Игорь Лабутин" Ну и классненько.
2851.96 2852.96 "Игорь Лабутин" Мы пойдем дальше.
2852.96 2858.32 "Игорь Лабутин" Теперь настал черед поговорить про ASP.NET Core 6.
2858.32 2864.96 "Игорь Лабутин" Тут я совсем не буду подробно останавливаться, потому что по-моему про ASP.NET Core мы говорили чуть ли не больше про весь, чем весь остальной дебют на этом месте взятый.
2864.96 2867.96 "Игорь Лабутин" И тут просто пробегусь по заголовкам.
2867.96 2872.32 "Игорь Лабутин" Это, конечно же, Hot Reload, куда же без него, он там тоже поддержан.
2872.32 2878.60 "Игорь Лабутин" Это Minimal API, с которыми прожужжали все, Twitter, по крайней мере, мне прожужжал все уши последний, там, не знаю, месяц, наверное.
2878.60 2895.76 "Игорь Лабутин" Async Streaming - это, мне кажется, какая-то относительно недавняя фича и недавняя демка, которая позволяет вам вернуть, скажем так, асинк номер был из, допустим, тюнтпоинта или из API какого-нибудь тюнтпоинта, и браузер будет все это рендерить по мере того, как приходят результаты.
2895.76 2901.20 "Игорь Лабутин" Вы, соответственно, будете потихонечку отправлять, а, соответственно, браузер будет это потихонечку получать.
2901.20 2904.00 "Игорь Лабутин" Очень прикольно, если вам нужно передать что-то такое большое.
2904.00 2907.24 "Игорь Лабутин" В ASP.NET Core 6 входит Bootstrap 5.1.
2907.24 2914.92 "Игорь Лабутин" Теперь куча изменений вокруг, там, CSS изоляции для страничек и вьюшек для Razer.
2914.92 2920.80 "Игорь Лабутин" Есть возможность сделать JavaScript модули специфичные для каких-то страничек и вьюшек там правильных, соответственно, в правильные файлики.
2920.80 2925.40 "Игорь Лабутин" Куча изменений в Blazor, в WebAssembly и AOT.
2925.40 2938.72 "Игорь Лабутин" Для Single Page Application используется Angular 12 и React 17 в шаблончиках, но плюс шаблончики написаны таким образом и используют такие паттерны, что там можно использовать не только Angular и React, а все, что захотите на фронтенде.
2938.72 2947.92 "Игорь Лабутин" Из более низкоуровневых штук вы можете контролировать теперь, как работают и с какими опциями используются сокеты для ваших соединений на сервере.
2947.92 2964.92 "Игорь Лабутин" Для HTTP Client вы можете использовать теперь строго типизированный доступ к определенным хендлером, то есть к популярным и общеупотребиваемым хендлерам теперь там правильный строго типизированный доступ, то есть просто через property, а не надо искать там header в коллекции.
2964.92 2970.92 "Игорь Лабутин" Добавили возможность логировать в формате W3C, но это, я так понимаю, примерно как и Ease делал.
2970.92 2982.20 "Игорь Лабутин" Ну и завезли превью поддержку HTTP/3, то есть у нас было HTTP/1, точнее, если быть праведливым, с gRPC появился HTTP/2, а теперь вот есть HTTP/3 Preview.
2982.20 2985.28 "Игорь Лабутин" Ну и как во всем этом бардаке теперь разбираться?
2985.28 2987.20 "Анатолий Кулаков" Брать HTTP Client и его использовать.
2987.20 2989.28 "Анатолий Кулаков" Давай-ка поглубже закопаемся.
2989.28 3001.00 "Анатолий Кулаков" У нас в гостях есть Евгений Пешков, он также известен как большой эксперт по HTTP, делал про это много докладов на больших и малых конференциях, ну и у него есть небольшое хобби, он еще разработчик-райдер в компании JetBrains.
3001.00 3002.00 "Анатолий Кулаков" Привет, Женя.
3002.00 3003.00 "Анатолий Кулаков" Привет.
3003.00 3006.76 "Анатолий Кулаков" Я надеюсь, ты нам поможешь разобраться с новыми HTTP.
3006.76 3012.64 "Анатолий Кулаков" Итак, у нас довольно комфортно себя давно уже чувствует HTTP/1.1, много лет.
3012.64 3014.60 "Анатолий Кулаков" Все под него настроено, все его знают.
3014.60 3019.12 "Анатолий Кулаков" Тут появляется два новых протокола прямо сразу, HTTP/2 и HTTP/3.
3019.12 3021.64 "Анатолий Кулаков" Скажи, как нам теперь разобраться в этом зоопарке?
3021.64 3023.64 "Анатолий Кулаков" В чем у них основные отличия?
3023.64 3034.32 "Евгений Пешков" HTTP/1.1 - это всем привычный Request Response протокол, работающий прямо поверх TCP соединения.
3034.32 3049.52 "Евгений Пешков" То есть на каждый запрос и ответ на этот запрос внутри используется HTTP соединение, и, например, пока сервер думает над тем, что ответить клиенту, это соединение простаивает.
3049.52 3054.84 "Евгений Пешков" HTTP/2 как раз адресовано решать эту проблему.
3054.84 3057.36 "Евгений Пешков" В чем там суть?
3057.36 3067.16 "Евгений Пешков" Суть там в том, что поверх TCP стримов HTTP/2 оперирует так называемыми виртуальными стримами.
3067.16 3078.60 "Евгений Пешков" То есть если мы отправили запрос, мы не можем точно сказать, по каким физическим TCP стримам этот запрос будет отправлен.
3078.60 3103.24 "Евгений Пешков" Он отправляется через некоторые виртуальные стримы, и в итоге, если серверу нужно над респонсом подумать чуть дольше, чем обычно, например, у вас какой-то сценарий с long polling, то тогда TCP соединение, которое под этот запрос было использовано, оно не будет простаивать, просто его займет другой виртуальный стрим.
3103.24 3118.32 "Евгений Пешков" А HTTP/3, так называемый QUIC, у него отличие в том, что он вообще не использует TCP соединения, а использует внутри для отправки запросов и ответов UDP датограммы.
3118.32 3119.88 "Евгений Пешков" Что это дает?
3119.88 3127.84 "Евгений Пешков" Это дает то, что на протокол QUIC не аффектят различные особенности TCP.
3127.84 3134.88 "Евгений Пешков" TCP, как известно, внутри умеет подстраиваться под качество соединения.
3134.88 3145.48 "Евгений Пешков" Если он теряет пакеты, то внутри TCP есть некоторый механизм их переотправки, и этот механизм был создан довольно давно в современных сетях.
3145.48 3153.80 "Евгений Пешков" Как раз вот этот механизм гарантированной доставки пакетов в TCP может тормозить обмен данными.
3153.80 3162.12 "Евгений Пешков" И в HTTP/3 как раз адресует эту проблему тем, что TCP не используют вообще, вместо TCP используют UDP.
3162.12 3165.48 "Анатолий Кулаков" Отлично, основные особенности понятны.
3165.48 3171.56 "Анатолий Кулаков" Скажи, стоит ли переходить на новые протоколы и кого из них выбрать, в каких ситуациях, кого предпочесть?
3171.56 3179.20 "Евгений Пешков" Тут довольно сложный вопрос, но я бы сказал так, что все зависит от конкретной ситуации.
3179.20 3185.56 "Евгений Пешков" Нужна ли действительно та производительность, которую будут давать HTTP/2 и HTTP/3.
3185.56 3193.96 "Евгений Пешков" То есть основной профит, который мы хотим получить от использования новых протоколов, это производительность.
3193.96 3207.92 "Евгений Пешков" И здесь надо понимать, что есть некоторый трейд-офф, что HTTP/1.1 это довольно простой протокол, который, тем не менее, реализовать все равно очень сложно.
3207.92 3218.28 "Евгений Пешков" То есть оно простое в том плане, что если вы возьмете обычный сокет, вы скорее всего по нему сможете отправить HTTP запрос вручную.
3218.28 3244.72 "Евгений Пешков" Но при этом, чтобы написать production HTTP клиент, понадобится очень большое количество усилий, понадобится учесть очень много ограниченных случаев, рассмотреть сценарий, когда запросов отправляется много, когда запросы идут на один endpoint, когда запросы идут на разные endpoints, как будет устроен внутри трейдинг, как будут переиспользоваться HTTP соединения.
3244.72 3252.88 "Евгений Пешков" Все это надо учесть и написать код так, чтобы он оказался достаточно производительным и корректным при этом.
3252.88 3257.16 "Евгений Пешков" И с HTTP/1.1 накоплен уже большой опыт.
3257.16 3267.76 "Евгений Пешков" HTTP/1.1 используют повсеместно, и в его реализациях уже учтено довольно много ограниченных случаев, в них найдены баги.
3267.76 3283.88 "Евгений Пешков" HTTP/2, HTTP/3 используются куда меньше, и, например, HTTP/2 имеет очень много разных реализаций, и там еще непонятно, как состыкуется конкретно ваш клиент и сервер.
3283.88 3292.68 "Евгений Пешков" К тому же могут быть какие-то баги в реализации, которые просто пока не были замечены, но с которыми потенциально столкнетесь вы.
3292.68 3301.28 "Евгений Пешков" HTTP/3 сейчас вообще существует только в отдельных реализациях со своими особенностями.
3301.28 3312.20 "Евгений Пешков" То есть, если вы хотите взять HTTP/2 и HTTP/3, вы должны четко понимать, какой именно прирост производительности вам это даст.
3312.20 3328.88 "Евгений Пешков" И стоит ли этот прирост производительности того, чтобы лезть в эти сетевые протоколы и огребать проблемы, с которыми никто больше еще не сталкивался, они у вас могут запросто возникнуть.
3328.88 3338.32 "Евгений Пешков" Поэтому, если вам просто хочется использовать новые сетевые протоколы, там HTTP/2, HTTP/3, то, скорее всего, вам это делать не надо.
3338.32 3352.72 "Евгений Пешков" Если у вас действительно есть какая-то перфоманс-задача, то лучше сравнить производительность на HTTP/1 и на более новых версиях протокола.
3352.72 3359.48 "Евгений Пешков" Точнее, это сложно даже назвать более новыми версиями протокола, по факту это полностью разные протоколы.
3359.48 3365.68 "Евгений Пешков" То есть, сделайте ваше MVP-сервис на HTTP/1.
3365.68 3375.28 "Евгений Пешков" Затем попробуйте сравнить с версией на HTTP/2, на квике, на HTTP/3.
3375.28 3381.32 "Евгений Пешков" Тогда вы будете уже четко понимать, что конкретно вам переход на новый протокол дал.
3381.32 3389.40 "Евгений Пешков" И вы сможете, что еще сделать здесь, надо заметить, вы можете здесь проявить, так сказать, инженерный подход.
3389.40 3403.80 "Евгений Пешков" То есть, сравните сервис на HTTP/1/1, на HTTP/2, потом понять, что на HTTP/2 у вас сервис работает на столько-то процентов быстрее.
3403.80 3411.52 "Евгений Пешков" Соответственно, у вас затраты на сервера или на облако в Амазоне уменьшились на столько-то долларов.
3411.52 3417.60 "Евгений Пешков" Это уже будет явно видимый профит от конкретного внедрения новых протоколов.
3417.60 3431.04 "Евгений Пешков" То есть, получается, что если вы только стартуете свой сервис и еще не уверены, что вам действительно нужна производительность, которую будет давать HTTP/2 и HTTP/3, возьмите HTTP/1/1.
3431.04 3444.20 "Евгений Пешков" Перейти на новой версии всегда сможете, но при этом, если вы начнете на HTTP/1/1, то при переходе вы явно увидите, что именно вам дал переход на более новую версию.
3444.20 3451.32 "Евгений Пешков" Ну и вы сможете показать, что вы ускорили сервис путем перехода на HTTP/2, HTTP/3.
3451.32 3457.88 "Анатолий Кулаков" — Ну, то есть, так просто перепрыгнуть опять не получится, придется все равно что-то мерить, что-то доказывать и что-то считать.
3457.88 3458.96 "Анатолий Кулаков" Ну, может быть, это к лучшему.
3458.96 3490.32 "Евгений Пешков" — Да, но тут скорее пойнт в том, что попытки сразу начать сервис на HTTP/2 и HTTP/3, они могут вас увести от бизнес-задачи в сторону сетевых протоколов, то что вы запутаетесь окончательно в том, какой у вас клиент с каким сервером стыкуется, какие там есть особенности взаимодействия между ними, и будете заниматься именно попыткой внедрить новый протокол вместо того, чтобы решать бизнес-задачи.
3490.32 3498.24 "Евгений Пешков" Все-таки в первую очередь, я считаю, нужно сделать бизнес-задачи, а уже затем заниматься оптимизациями.
3498.24 3500.92 "Анатолий Кулаков" — Отлично, большое спасибо за развернутый ответ.
3500.92 3506.44 "Анатолий Кулаков" Я напомню, что у нас в студии был Евгений Пешков, разработчик райдера из компании JetBrains.
3506.44 3508.04 "Игорь Лабутин" — А мы пойдем дальше.
3508.04 3514.32 "Игорь Лабутин" Про шестой дотнет вроде поговорили, но не затронули важную тему, а именно десятый C#.
3514.32 3517.96 "Анатолий Кулаков" — Безусловно, какой же релиз дотнета без нового релиза языка?
3517.96 3519.72 "Анатолий Кулаков" И вот десятый C#.
3519.72 3527.40 "Анатолий Кулаков" Тут сразу, наверное, стоит отметить, что никаких глобальных, больших, страшных или наоборот прекрасных улучшений здесь нет.
3527.40 3537.48 "Анатолий Кулаков" Мы немножко подтянули все, что должны были подтянуть, немножко улучшили все, что должны были улучшить и добавили пару новых фич для того, чтобы как-то оправдать релиз-лог.
3537.48 3540.40 "Анатолий Кулаков" Но пробежимся по том, что есть.
3540.40 3541.68 "Анатолий Кулаков" Прежде всего, это Global Usings.
3541.68 3553.48 "Анатолий Кулаков" У нас появилась такая замечательная возможность, как описать в каком-то одном файле частые юсинги, которые есть в вашем проекте, и дальше забыть про них во всех остальных C# файлах.
3553.72 3560.04 "Анатолий Кулаков" То есть в рамках проекта они будут включаться в ваши C# файлы автоматически.
3560.04 3564.76 "Анатолий Кулаков" Ну, наверное, в каждом файле есть использование пространства системы.
3564.76 3574.20 "Анатолий Кулаков" Может быть, будет хорошая идея просто-напросто добавить его в неявные юсинги, в глобальные юсинги, и все станет почище, немножко покрасивее.
3574.20 3575.20 "Анатолий Кулаков" Посмотрим.
3575.20 3580.80 "Анатолий Кулаков" Также у нас появилась возможность с помощью Global Usings также импортировать к себе статические классы.
3580.80 3591.84 "Анатолий Кулаков" Например, если у вас в приложении очень много используется консоль, консоль в Write, Line, или еще что-то вы делаете много с консолей, вы вполне можете сделать Global Usings систем консоли.
3591.84 3599.40 "Анатолий Кулаков" И тогда во всех файлах в рамках этого проекта этот намп-спейс будет статически заимпортирован.
3599.40 3603.80 "Анатолий Кулаков" Соответственно, вы можете использовать статические методы без указания корневого класса.
3603.80 3606.12 "Игорь Лабутин" Я только тебя немножко поправлю.
3606.12 3608.48 "Игорь Лабутин" Нужно сказать Global Usings Static System Console.
3608.48 3619.16 "Игорь Лабутин" И мне интересно, когда у нас наступит какой-то предел количества ключевых слов, потому что Global Usings Static, это мне уже начинает напоминать всякие Public Static Void Main, вот это все.
3619.16 3628.48 "Анатолий Кулаков" Тут же, смотри, еще нет аксессора, можно еще добавить там Protected Global Usings Static, чтобы импортировалось только в эту папочку, не во весь проект, не во весь Solution.
3628.48 3631.84 "Игорь Лабутин" Точно, а Private это только… Нет, Private не знаю что.
3631.84 3632.84 "Игорь Лабутин" Ладно, давай дальше.
3632.84 3640.64 "Анатолий Кулаков" Вот, не знаю, вот следующая фича, мне кажется, будет полезна, по крайней мере, я ее ждал очень много, вот еще со времен C++.
3640.64 3648.60 "Анатолий Кулаков" Это как раз-таки можно сравнить с тем Define, который, наверное, был у C++, такой недоделанный.
3648.60 3670.44 "Анатолий Кулаков" Например, с помощью магического предложения GlobalUsingEnv=SystemEnvironment, мы, соответственно, можем теперь везде в нашем коде, глобально в рамках этого проекта, ссылаться на статический класс SystemEnvironment с помощью названия env, то есть мы можем такой alias дать какому-то классу.
3670.44 3686.40 "Анатолий Кулаков" Я часто использовал вот такие alias в рамках одного файла, если мне было лень, например, заводить отдельную структуру или отдельный классик для какого-нибудь, допустим, IDшника, но в коде хочется выразительно писать, что это как бы UserID, а на самом деле это у меня int.
3686.40 3697.12 "Анатолий Кулаков" Вот такой маленький факт, я его просто объявлял с помощью using, UserID=int и все, и дальше в коде используется только чистый красивый UserID, чисто ради читабельности.
3697.12 3710.80 "Анатолий Кулаков" Вот теперь моя лень может распространиться на весь проект, если я не хочу все еще в одну строчку сделать себе рекорд, вот я теперь могу вот такие глобальные юсинги тоже переименования делать.
3710.80 3735.92 "Анатолий Кулаков" Другая интересная секция, немножко отойдя от юсингов и оставаясь в пределах их же, называется implicit using, это такое магическое, опять же, словосочетание, которое помогает в рамках вашего проекта включить какие-то определенные namespaces в ваш проект, но при этом не имея файла, в котором были описаны глобальные юсинги.
3735.92 3748.56 "Анатолий Кулаков" И интересно это тем, что в зависимости от того, какого типа ваш проект, то есть какой, например, SDK он использует, у вас будут включаться по дефолту разные неявные namespaces.
3748.56 3768.72 "Анатолий Кулаков" Например, если вы используете в вашей библиотеке тип, который называется Microsoft.NET SDK, то неявно во всем этом проекте будут автоматически уже заимпортированы такие namespaces, как System, System.IO, Task, System.Collection.Generic и вот такие базовые вещи, которые мы с вами каждый день используем.
3768.72 3773.64 "Анатолий Кулаков" Вам нигде не нужно будет писать юсинг, парник, это все сделает для вас MS Build.
3773.64 3785.24 "Анатолий Кулаков" Если вы работаете с вебом, то вы автоматически в нагрузку получите заимпортированные namespaces, логин, хостинг, конфигурация, dependency injection и прочее.
3785.24 3794.60 "Анатолий Кулаков" Для того, чтобы эта магия заработала, в вашем проекте нужно указать implicit using, enable или disable, как вам больше нравится.
3794.60 3806.60 "Анатолий Кулаков" Такие же есть разограничения по проектам для WinForm, для PDF, и в их случае будут подтаскиваться, соответственно, их контролы при неявном использовании.
3806.60 3811.96 "Анатолий Кулаков" Здесь интересная фишка есть в том, что вы можете это контролировать из своего cproj файла.
3811.96 3824.24 "Анатолий Кулаков" То есть вы можете в cproj файл сделать директиву using, где указать, какой namespace будет неявно заимпортирован в глобальное пространство имен этого проекта.
3824.24 3829.36 "Анатолий Кулаков" То есть using include и пишите прямо в cproj, какой namespace вам нужен.
3829.36 3839.04 "Анатолий Кулаков" И можно сделать remove, если вдруг стандартный комплект implicit using вам подходит, ну кроме одного или двух каких-то namespaces, вы их можете точно так же через файл проекта удалить.
3839.04 3858.20 "Игорь Лабутин" Интересно, а если я использую при этом, знаешь, этот directory props, который общий автоматически инклюдится в cproj на основании иерархии папочек на диске, то если я в такой directory props напишу using, какой-нибудь там include system collections generic, он у меня вообще во всех проектах теперь будет автоматически.
3858.20 3864.60 "Анатолий Кулаков" Да, по идее да, можно включить global using implicit для всех твоих
3864.60 3868.80 "Игорь Лабутин" проектов. Прикольно, прикольно, надо будет попробовать, может быть действительно.
3868.80 3877.16 "Игорь Лабутин" Пока мы не ушли далеко от using и связанных с ними namespaces, обсудим следующую фичу, это filescope namespaces.
3877.16 3909.64 "Игорь Лабутин" Тут все просто, раньше вы писали namespace, там имя компании, точка, имя проекта, namespaces и так далее, открывали фигурную скобочку, ну или конечно же на новой строчке открывали фигурную скобочку и писали дальше все ваши эти самые файлики, в смысле классики, структурки и так далее и закрывали фигурную скобочку последней строчкой в файле, тем самым вы зря потратили, значит, ваше количество пробелов умножить на количество строчек, потому что все это нужно было сдвинуть вправо на соответствующее количество пробелчиков, ну или на целый тап.
3909.64 3916.00 "Игорь Лабутин" Теперь можно вначале просто указать на namespace имя там компании, точка, как вы раньше указывали, и поставить сразу точку с запятой.
3916.00 3924.68 "Игорь Лабутин" Это означает, что этот namespace будет длиться до конца файла, то есть фактически все, что будет описано после него будет включено в этот namespace.
3924.68 3956.04 "Анатолий Кулаков" Это как раз тот случай, если вы хотите перед Новым годом повысить ваш рейтинг в глазах начальника, то соответственно вы можете сделать файл скоп на namespaces, то есть убрать вот этот отступ во всех ваших файлах, во всех ваших проектах и сделать там коммит на 10 тысяч файлов и следующий же анализатор у вашего босса выдаст вам самый лучший рейтинг, так как лучшему коммитеру, который затронул все файлы, который поменял табики на каждой строчечке и знает о всем вашем проекте абсолютно все.
3956.04 3960.08 "Игорь Лабутин" Причем более того, это такое изменение, которое скорее всего вряд ли сломает ваши тесты.
3960.08 3964.80 "Анатолий Кулаков" Да, гарантированно стабильное изменение, которое покроет все файлы и даст вам плюс тысячу коммитов.
3964.80 3970.48 "Игорь Лабутин" Это если у вас шестое SDK стоит на билд серверах.
3970.48 3971.48 "Игорь Лабутин" Поехали дальше.
3971.48 3973.68 "Анатолий Кулаков" Вот следующее изменение действительно нужно.
3973.68 3981.16 "Анатолий Кулаков" Здесь вот нечего сказать, часто мне не хватало, с тех пор как появились лямбды, мне всегда поражало, зачем мне с двух сторон писать их тип.
3981.16 4001.60 "Анатолий Кулаков" Ну естественно к VARу очень быстро привыкаешь и раньше может быть вы замечали, если вам нужно вдруг объявить локальную лямбдочку, то есть вы пишете func от string равно и снова вынуждены там писать сигнатуру, которая по сути соответствует func от string, то есть компилятор вполне мог бы ее вывести и вот сейчас он наконец научился ее выводить.
4001.60 4016.84 "Анатолий Кулаков" Вы можете просто написать VAR равно, опять же лямбдочку там в скобочках тип входных аргументов, какой-то метод, который выведется, тоже тип у него return тип автоматический и в этот VAR вам будет подставлено то, что вы ожидаете, то, что вам нужно.
4016.84 4023.68 "Анатолий Кулаков" Соответственно вместо VAR вы можете написать expression и ваша лямбдочка вдруг внезапно превратится в expression, что тоже очень удобно.
4023.68 4031.32 "Анатолий Кулаков" В общем все это компилятор понимает и теперь локальное декларирование лямбд станет намного лучше и интереснее.
4031.32 4046.44 "Анатолий Кулаков" Также лямбды поддержали атрибуты, это наверное довольно бесполезная штука с точки зрения логики какой-то, но очень полезная штука для анализаторов и вот для анализаторов атрибуты должны быть абсолютно везде, и на локальных функциях, и на лямбдах и просто где только можно.
4046.44 4058.16 "Анатолий Кулаков" И соответственно вот эти улучшения позволили продвинуть minimal APIs для ASP.NET Core, вот благодаря им он стал действительно еще минимальнее, еще короче и еще красивее.
4058.16 4068.44 "Анатолий Кулаков" Интересная штука произошла со структурами, в общем много изменений, нельзя сказать, что все они очевидны и не противоречивы, но давайте посмотрим как же поменялись структуры.
4068.44 4071.74 "Анатолий Кулаков" Прежде всего у них появилась возможность задавать конструктор без параметров.
4071.74 4082.88 "Анатолий Кулаков" Напомню, что раньше у структур всегда существовал неявный конструктор без параметров и как только вы пытались определить его явно, то есть сделать его конструктор без параметров в своем коде, то получали ошибку.
4082.88 4087.72 "Анатолий Кулаков" В DC Atom C# у вас появилась такая возможность, вы теперь можете это сделать.
4087.72 4098.88 "Анатолий Кулаков" И вы можете в этом конструкторе проинциализировать поля, свойства, запустить property initializers, в общем то же самое все, что вы делаете и в обычных ваших классах.
4098.88 4107.76 "Анатолий Кулаков" К сожалению все не так просто, потому что существует очень интересный способ, который оставили именно в дефолтном поведении.
4107.76 4124.20 "Анатолий Кулаков" Если вы создаете ваши структуры с помощью ключевого слова default или же вы создаете массив этих структур, то .NET игнорирует ваш конструктор по умолчанию, который вы только что написали и проинциализировали в нем красиво все ваши поля.
4124.20 4129.36 "Анатолий Кулаков" Игнорирует, что здесь еще можно сказать, просто-напросто забивает и поведение остается такое же, как и раньше.
4129.36 4134.20 "Анатолий Кулаков" То есть все члены класса помечаются дефолтными значениями.
4134.20 4136.28 "Анатолий Кулаков" То есть то же самое, что и было раньше.
4136.28 4141.88 "Анатолий Кулаков" И вот непонятно, в некоторых ситуациях у вас конструктор по умолчанию вызывается, в некоторых он не вызывается.
4141.88 4144.16 "Анатолий Кулаков" Игорь, есть соображения, зачем они так вот сделали?
4144.16 4149.24 "Игорь Лабутин" Я думаю, что изменить это поведение, во-первых, это будет какой-то breaking change, возможно.
4149.24 4154.00 "Игорь Лабутин" Хотя правда, с другой стороны, нельзя же было раньше конструкторы, они всегда были гарантированно пустые.
4154.00 4155.00 "Игорь Лабутин" Да.
4155.00 4156.00 "Игорь Лабутин" Непонятно.
4156.00 4159.92 "Игорь Лабутин" Во-вторых, ну, наверное, это все-таки какое-то довольно серьезное изменение рантайма.
4159.92 4165.96 "Игорь Лабутин" То есть нужно, по сути, вставить вызов конструктора, когда ты просто аллоцируешь массив.
4165.96 4173.20 "Игорь Лабутин" Хотя сейчас аллокация массива, допустим, структуры, это же просто, по сути, выделить память и ничего больше не делать, потому что конструктора не было.
4173.20 4178.28 "Анатолий Кулаков" Может быть и так, но со старым кодом проблем никаких не будет, а в новом коде вы сами написали конструктор.
4178.28 4184.00 "Анатолий Кулаков" Ну, как и в стандартных классах, если ты в конструкторе написал thread sleep, ну да, ты сам себе виноват.
4184.00 4185.48 "Анатолий Кулаков" Как бы в чем проблема?
4185.48 4186.48 "Игорь Лабутин" Ну, не знаю.
4186.48 4198.28 "Игорь Лабутин" Скорее всего, как-то либо какие-то есть очень тонкие моменты, про которые я либо не знаю, либо не помню, либо просто не стали делать слишком много изменений в рантайме.
4198.28 4209.04 "Анатолий Кулаков" Ну, ладно, друзья, если кто-то из вас понимает о таком расхождении немножко поглубже и поумнее, то заходите к нам в комментарии, можно на YouTube, можно еще в любую социальную сеть.
4209.04 4211.56 "Анатолий Кулаков" Расскажите, зачем поступили именно так.
4211.56 4215.28 "Анатолий Кулаков" Еще у нас появились рекорд стракты.
4215.28 4223.56 "Анатолий Кулаков" Я напомню, что у нас рекорд классы уже были давно, уже к ним многие привыкли, многие используют, но нельзя было сделать рекорды из структур.
4223.56 4238.84 "Анатолий Кулаков" И вот теперь в 10 C# вы можете, наконец, объявить паблик рекорд стракт и получить структуру, которая соответствует опять же почти тем рекордам, которые вы видели в классе.
4238.84 4248.16 "Анатолий Кулаков" Как и рекорд в классе, она имплементирует iQuotable, переопределяет операции сравнения, переопределяет toString.
4248.16 4253.28 "Анатолий Кулаков" И вот такие базовые вещи, которые вы ожидаете, они будут сделаны.
4253.28 4257.56 "Анатолий Кулаков" Также там будет primary конструктор, который можно заиспользовать.
4257.56 4272.84 "Анатолий Кулаков" Но в отличие от классов, свойства по умолчанию будут не init_only, как делаются рекорды в классах, а будут доступны на чтение и на запись.
4272.84 4285.28 "Анатолий Кулаков" Вот тоже такое отличие, которое абсолютно вгоняет в супер, если вы вдруг уже знаете рекорды на классах, и, наверное, будет хорошим вопросом на собеседовании для того, чтобы к чему-то придраться.
4285.28 4290.12 "Игорь Лабутин" Причем интересный момент, что я бы ожидал, что будет наоборот.
4290.12 4300.60 "Игорь Лабутин" На классах сделать read_write, а на структурах, которые скорее безопаснее сделать immutable, сделать read_only, read_init.
4300.60 4301.60 "Анатолий Кулаков" Именно так.
4301.60 4304.84 "Анатолий Кулаков" Это поведение можно немножко исправить.
4304.84 4311.68 "Анатолий Кулаков" Можно превратить структуру в immutable, если добавить ключевое слово read_only, когда вы объявляете свой рекорд.
4311.68 4313.04 "Анатолий Кулаков" Это вам поможет.
4313.04 4316.72 "Анатолий Кулаков" Но по умолчанию свойства будут открыты на чтение и на запись.
4316.72 4330.00 "Анатолий Кулаков" Также, чтобы немножко в консистентности привести декларацию рекордов, теперь стало возможно объявлять ваши рекорд-классы с помощью ключевых слов record_class.
4330.00 4333.44 "Анатолий Кулаков" Раньше нужно было писать просто record, нельзя было указывать record_class.
4333.44 4336.92 "Анатолий Кулаков" Сейчас можно писать record_class или record_struct, в зависимости от того, что вам нужно.
4336.92 4341.76 "Анатолий Кулаков" Вот такая явность, она мне кажется довольно-таки правильной.
4341.76 4346.00 "Анатолий Кулаков" Еще интересное изменение касается ключевого слова viv.
4346.00 4357.96 "Анатолий Кулаков" Это ключевое слово, которое помогает вам копировать какие-то поля из структуры или из класса, но при этом заменяя указанный список полей на свои.
4357.96 4362.28 "Анатолий Кулаков" То есть раньше вы могли это сделать у рекорд-классов.
4362.28 4369.48 "Анатолий Кулаков" Вы могли скопировать 10 полей и заменить из них 2 каких-то определенных с помощью этого ключевого слова, что довольно-таки удобно.
4369.48 4380.80 "Анатолий Кулаков" Теперь viv можно применять к структурам, также их можно применять к рекордам, рекорд-структурам, и его можно применять к анонимным типам.
4380.80 4385.40 "Анатолий Кулаков" Вот тоже так расширили функциональность довольно полезного оператора, что не может не радовать.
4385.40 4389.48 "Игорь Лабутин" Большое изменение в поддержке interpolated strings.
4389.48 4391.60 "Игорь Лабутин" Мы его подробно разбирали.
4391.60 4411.56 "Игорь Лабутин" По дефолту, если вы используете interpolated strings, которые с долларом в начале, то там происходит довольно много всяких разных изменений, в смысле работы в рантайме, то есть нужно распарсить строчку, нужно понять, где там эти placeholders, нужно забоксить, возможно, аргументы, чтобы их передать в объекты.
4411.56 4415.84 "Игорь Лабутин" Если аргументов слишком много, то там еще лоцируется массив для передачи этих аргументов.
4415.84 4419.04 "Игорь Лабутин" В общем, все как-то очень много, долго, дорого.
4419.04 4432.32 "Игорь Лабутин" А если в результате выяснится, например, что функция с этой строчкой делать ничего не должна, а так, например, работает логгинг, то окажется как-то обидно, что мы столько времени потратили и сделали что-то странное.
4432.32 4436.24 "Игорь Лабутин" Поэтому теперь interpolated strings работают чуть-чуть по-другому.
4436.24 4447.16 "Игорь Лабутин" Там генерится некоторый специальный билдер, который используется, который stack-only, и который собирает строчку по сути в stringbuilder без дополнительных аллокаций.
4447.16 4449.24 "Игорь Лабутин" То есть аллокируется только один раз финальная строка
4449.24 4451.92 "Анатолий Кулаков" после сборки. И то, если она нужна, соответственно.
4451.92 4459.00 "Анатолий Кулаков" Если у вас логгер не проходит по какому-то уровню логирования, то никаких аллокаций вообще не будет, что тоже очень удобно.
4459.00 4487.44 "Анатолий Кулаков" И еще полезная штука, то, что вы сами можете создать такой билдер, то есть не только для каких-то системных встроенных вещей, это вполне легальная штука, с помощью атрибута interpolated string handler attribute вы можете создать билдер, научить ваши классы логирования, ваши метрики, еще где-то, где вы принимаете строчки, работать более оптимально, то есть не расходовать зря память, не форматировать зря строчки, не использовать культуру, дать вам момент, пока вам это действительно не будет нужно.
4487.44 4493.92 "Анатолий Кулаков" Еще один интересный атрибутик у нас появился, это color expression attribute, то есть он начал работать.
4493.92 4505.72 "Анатолий Кулаков" С помощью этого атрибута, это атрибут из семейства атрибутов для компилятора, который вам вставлял номер строки, имя файла, имя метода, которого вызывали.
4505.72 4516.72 "Анатолий Кулаков" Вот в это семейство прибавился еще один атрибут для компилятора, который вам в строку вставляет expression, с которым был вызван этот метод.
4516.72 4530.08 "Анатолий Кулаков" Это очень полезно, например, в тестировании, наверняка многие из вас писали какие-нибудь assert методы, которые, например, assert a>5, то какое-нибудь сообщение об ошибке.
4530.08 4541.96 "Анатолий Кулаков" И вот интересно, что вот это a>5, теперь компилятор вам может в виде строки автоматически подставить в аргумент, который будет передан вот этому вызывающему методу.
4541.96 4548.60 "Анатолий Кулаков" И этот вызывающий метод уже сможет отформатировать сообщение об ошибке более привычно, более красиво и более внятно.
4548.60 4560.64 "Игорь Лабутин" Ну, в общем, как ты и сказал, в 10-ом C# довольно много на самом деле изменений, но они все как бы такие причесывающие, хотя, конечно, рекорд строк, например, это не такое уж и сильно маленькое изменение.
4560.64 4566.12 "Игорь Лабутин" Ну, посмотрим, поглядим, чего будет дальше, что нам принесет 11-й C#.
4566.12 4567.12 "Игорь Лабутин" Пойдем дальше.
4567.12 4569.28 "Игорь Лабутин" Дальше у нас .NET MAUI.
4569.28 4584.80 "Игорь Лабутин" К сожалению, как мы говорили, к 6-му .NET они не успели выпустить полноценный релиз и не то чтобы тут чуть-чуть не успели, потому что сейчас у нас вышло preview 10, она точно также требует Visual Studio 2022.
4584.80 4610.44 "Игорь Лабутин" Изменений там из таких визначимых не так и много, то есть если вы помните, наверное, выпуском 8 назад мы рассказывали про то, что основная идея переписывания, так скажем, или точнее редизайна MAUI по сравнению с GlamorInforms это изменение вообще того, как работают контроллы, они переписываются на хендлеры так называемые, и вот в 10-ом preview переписали два контролла, collection view и indicator view.
4610.44 4614.64 "Игорь Лабутин" Collection view это, собственно, любые списки, которые вы видите на экране, довольно важный контролл.
4614.64 4645.72 "Игорь Лабутин" И в статье про анонс 10-го preview больше ничего особо и нет, но есть такая небольшая ссылочка на вот с нее, и вот там уже конкретно прям лежащие в GitHub и там где-то порядка 50 или 60 items, то есть на самом деле работа там довольно большая, что-то фиксится, улучшается, просто они, ну, довольно такие мелкие, видимо, улучшения и исправления, фикса багов, какие-то мелкие, может быть, фичи, поэтому работа идет и работа будет идти еще полгода, видимо, потому что пока релиз стоит на второй квартал 22-го года.
4645.72 4656.36 "Анатолий Кулаков" Еще одна интересная циферка – это Nougat 6, The Real The Instrument, которым мы управляем зависимостями, и что про него интересно можно рассказать?
4656.36 4661.96 "Анатолий Кулаков" Прежде всего Nougat 6 поставляется в коробке вместе с Visual Studio 22 и .NET M6.
4661.96 4666.64 "Анатолий Кулаков" Естественно, вы его можете скачать без проблем под любые оси, как и положено.
4666.64 4671.80 "Анатолий Кулаков" Одно из самых значительных нововведений – это Source Mapping.
4671.80 4678.16 "Анатолий Кулаков" И Source Mapping нужен для того, чтобы защитить ваши зависимости от какого-то злонамеренного внедрения.
4678.16 4697.76 "Анатолий Кулаков" То есть, возможно, проведение такой атаки, когда какой-то злоумышленник узнает, каким образом у вас называются пакеты вашей внутренней сети, поднимет свой какой-нибудь сервер пакетов или, может быть, заиспользует стандартный Nougat и создаст там такие пакеты с вашим, такие же пакеты, как и ваши.
4697.76 4714.68 "Анатолий Кулаков" И, возможно, когда-то какой-то билд-сервер вдруг не найдет вашего стандартного артефактория, или он будет в этот момент выключен, или еще по какой-то причине, инструмент сборки может пойти на публичный Nougat сервер и попытаться поискать локальные ваши пакеты именно там.
4714.68 4723.24 "Анатолий Кулаков" И здесь очень легко злоумышленник может попасть в вашу внутреннюю сеть и сделать абсолютно все с вашим кодом и с вашим продуктом, все, что захочет.
4723.24 4730.80 "Анатолий Кулаков" А вот от такой, казалось бы, на первый взгляд странной, непривычной атаки и попытались защититься в шестом Nougat.
4730.80 4742.40 "Анатолий Кулаков" Но на самом деле атака не странная, она довольно серьезная и доказала свою работоспособность уже на многих языках и на многих репозиториях в интернете.
4742.40 4750.60 "Анатолий Кулаков" Я приложил в шоу ноты прекрасную статейку человека, который рассказывает о том, как он хакнул Apple, Microsoft и многих других с помощью такой техники.
4750.60 4758.00 "Анатолий Кулаков" Вот, почитайте для того, чтобы стать большим параноиком и, наконец, научиться правильно работать с вашими зависимостями.
4758.00 4762.28 "Анатолий Кулаков" Итак, что же предлагает нам Nougat 6 для того, чтобы защититься от злобных хацкеров?
4762.28 4773.68 "Анатолий Кулаков" Прежде всего, мы получили новую секцию, в которой вы можете замапить, связать вашу зависимость с источником, откуда она, по вашему мнению, должна приходить.
4773.68 4789.12 "Анатолий Кулаков" Вы можете указать package source, указать там какой-то ваш локальный Nougat сервер или, может быть, даже публичный Nougat сервер и задать некий шаблон пакетов, например, начинающихся с имени вашей компании, которые должны браться только из этого сорса.
4789.12 4792.48 "Анатолий Кулаков" Другой сорс за ними, Nougat, не пойдет.
4792.48 4811.68 "Анатолий Кулаков" Из еще интересных нововведений про интеграцию Nougat и Visual Studio, теперь в окне package manager вы можете увидеть количество пакетов, которые подвержены security уязвимостям.
4811.68 4815.28 "Анатолий Кулаков" Вот это все показывается в виде интересной красивой иконки.
4815.28 4824.80 "Анатолий Кулаков" Вы можете увидеть, в чем проблема, посмотреть, какие пакеты у вас попадают под уязвимости и тут же их обновить.
4824.80 4832.68 "Анатолий Кулаков" Также интересная штука, что теперь этот package manager может вам показать задеприкейченные пакеты.
4832.68 4840.32 "Анатолий Кулаков" То есть бывает так, что автор пакет забросил или перешел на новую версию или еще по какому-то соображению пакеты деприкейтятся.
4840.32 4847.28 "Анатолий Кулаков" Естественно, вас это не устраивает, ваше приложение не работает, ему нужна эта функциональность и что делать дальше.
4847.28 4850.52 "Анатолий Кулаков" И здесь вам package manager может посоветовать альтернативу.
4850.52 4855.32 "Анатолий Кулаков" Альтернатива, которая активно разрабатывается и в принципе переняла флаг от предыдущего пакета.
4855.32 4863.08 "Анатолий Кулаков" Здесь же прямо будет линк, где вы можете установить новый пакет, заменить все зависимости и в принципе радоваться дальше жизни, продолжать.
4863.08 4876.92 "Анатолий Кулаков" Еще мелкая штука, теперь можно добавить в ваш csproj файл readme, собрать его Nougat, то есть упаковать его в пакет и этот readme будет показываться в Visual Studio.
4876.92 4886.80 "Анатолий Кулаков" Это тоже бывает очень удобно, когда вы в readme файле описываете то, для чего нужен этот пакет, какие классики он собирает, какую функциональность делает.
4886.80 4890.40 "Анатолий Кулаков" В общем, такая легенькая информация, чтобы посмотреть, для чего вообще пакет нужен.
4890.40 4912.96 "Анатолий Кулаков" Напомню, что к такой же схеме перешел Nougat.org недавно, то есть он тоже поддерживает вот эти readme файлы, включенные в ваш пакет и будет на первой же вкладке, как только кто-то перейдет на страничку вашего пакета на Nougat.org, будет на первой же вкладке показывать вот этот readme, красиво отформатированный, может быть даже с некоторыми картинками.
4912.96 4914.76 "Игорь Лабутин" Ну да, звучит все это полезно.
4914.76 4923.88 "Игорь Лабутин" А ты несколько раз упомянул Visual Studio 2022 и кажется, что мы про нее тоже должны поговорить, потому что помимо самого дотнота зарелизилась и сама студия.
4923.88 4944.72 "Игорь Лабутин" И в 2022 есть довольно много всяких разных улучшений и одна из целей, которую ставила команда, это, так скажем, то, что называется Development Loop, то есть достаточно быстрая и отзывчивая студия, когда вы делаете свою обычную работу, собственно говоря, для чего нужна IDE.
4944.72 4953.16 "Игорь Лабутин" И здесь довольно много всяких разных улучшений, завезли, улучшили, добавили, дополнили IntelliSense, который превратился в IntelliCode.
4953.16 4967.92 "Игорь Лабутин" Это штука, которая, ну вот если вы видели GitHub Copilot, вы, наверное, или слышали про него, наверное, что-то похожее, это не совсем он, но это тоже Machine Learning Based штука, которая смотрит на ваши исходники, обучается на них и пытается предугадать, что же вы хотели.
4967.92 4976.76 "Игорь Лабутин" То есть если вы вместо консоль WriteLine пишете консоль.ReadLine очень часто, то, наверное, она рано или поздно начнет вам подсказывать именно ReadLine.
4976.76 4984.40 "Игорь Лабутин" Плюс она умеет, зная ваш код, примерно понимать паттерн, как вы пишете и выдавать соответствующие подсказки.
4984.40 5000.16 "Игорь Лабутин" Мы уже много раз упоминали фичу Hot Reload во многих контекстах, и Microsoft не раз ее упоминал, но так вот Hot Reload действительно в студии хорошо поддержан для разных проектов, для разных рантаймов, для разных таргетов, в разных режимах.
5000.16 5018.72 "Игорь Лабутин" На сайте Microsoft в документации есть хорошая сводная табличка, какие типы проектов, на каких рантаймах, с подключенным и отключенным откладчиком, на каких операционных системах работают, с какими фичами Hot Reload, так что посмотрите, если почему-то у вас что-то не работает, загляните в эту табличку, может быть оно просто еще пока не поддержано.
5018.72 5030.36 "Игорь Лабутин" Но Microsoft довольно активно работает над тем, чтобы поддержать все и везде, и постоянно расширяет список фич, которые поддержаны, изменения в которых поддержаны без перезапуска приложения.
5030.36 5037.68 "Игорь Лабутин" И в частности вокруг Hot Reload есть еще такая похожая фича под названием Example Live Preview.
5037.68 5040.76 "Игорь Лабутин" Это штука, которая позволяет вам сделать следующую штуку.
5040.76 5051.44 "Игорь Лабутин" Вы берете работающее приложение, его как бы, грубо говоря, то есть либо на нем, когда вы его запустите из-под откладчика студии, у него в Title Bar появляются такие служебные кнопочки, несколько штук.
5051.44 5066.84 "Игорь Лабутин" Вот нажав одну из них, ну либо, соответственно, из студии, позвав нужный шорткад, вы получите WPF-ный дизайнер, изменяя код которого, ну в смысле layout и прочий Example, вы будете видеть, как это меняется в реальном живом приложении рядышком.
5066.84 5069.96 "Игорь Лабутин" То есть такой Hot Reload, но прям вот такой live.
5069.96 5073.60 "Игорь Лабутин" Hot Reload, так скажем, прям в экзамле.
5073.60 5080.16 "Игорь Лабутин" Вот если вы как-то что-то дизайните или, допустим, экспериментируете с layout, мне кажется, что это вообще незаменимая штука.
5080.16 5085.04 "Игорь Лабутин" Поменял какое-нибудь значение пропертии, у вас там как-нибудь перерендерилось красиво или некрасиво.
5085.04 5087.04 "Игорь Лабутин" Сразу понимаете, как оно работает.
5087.04 5089.84 "Игорь Лабутин" И это не студийный дизайнер, а это именно ваше приложение.
5089.84 5093.00 "Игорь Лабутин" Боевое на ваших боевых данных.
5093.00 5096.40 "Игорь Лабутин" Студия, конечно же, стала 64-битной, но мы уже про это много раз говорили.
5096.40 5106.16 "Игорь Лабутин" Внезапно Microsoft выпустила статью, что Visual Studio 2022 выдала для разработчиков на Visual Basic, их не забыли.
5106.16 5112.72 "Игорь Лабутин" Там как-то не очень много, но туда тоже завезли всякие Hot Reload, Source Generator, так что, в принципе, почему нет.
5112.72 5117.44 "Игорь Лабутин" В разделе про Visual Studio еще был, соответственно, анонс про Xamarin.
5117.44 5125.40 "Игорь Лабутин" Я думал уже, что Xamarin как-то так подзабыт и MAUI наше новое будущее светлое и все должны писать на нем, но нет.
5125.40 5136.68 "Игорь Лабутин" Поскольку MAUI еще не вышел и не выйдет до 2 квартала 2022 года, а приложение писать уже надо, то официальная рекомендация Microsoft говорит, что используйте Xamarin.
5136.68 5143.56 "Игорь Лабутин" Xamarin будет поддерживаться еще 2 года, начиная с ноября этого года, то есть до ноября 2023 года есть официальная поддержка от Microsoft.
5143.56 5152.60 "Игорь Лабутин" И именно это рекомендованный способ сейчас писать пока .NET CrossFormed приложения UI, а не MAUI.
5152.60 5158.80 "Игорь Лабутин" При этом, если посмотреть агенту .NET Conf, который прошел, то там не было ни одной сессии про Xamarin, конечно все про MAUI.
5158.80 5164.56 "Игорь Лабутин" То есть это явно новый тренд, ну в смысле новое будущее, и Xamarin пока только если вам просто очень надо.
5164.56 5208.60 "Игорь Лабутин" Visual Studio 2022 имеет, соответственно, своего Mac-компаньона, там сейчас пока Mac Preview 3, и там основная работа идет в сторону нативного UI, туда потихонечку завозят фичи из основной Visual Studio, то есть, например, завезли новый гид UI-ные окошечки всякие, чтобы ваш, так сказать, Visual Experience был одинаковый и на Windows-студии, и на маковской, и при этом она поддерживает 6.NET, она поддерживает 10.C#, и основная цель Mac Preview это продолжить использовать нативный UI как можно больше, и второе - перенести всю студию на работу на 6.NET, чтобы это позволило потом работать в студии на M1 процессорах на Mac.
5208.60 5216.24 "Игорь Лабутин" Это будет, как бы, самый простой способ, вместо того, чтобы в текущий рантайм пытаться как-то смочь завести на M1.
5216.24 5239.60 "Игорь Лабутин" По планам, полноценный релиз Visual Studio for Mac запланирован на первую половину 2022 года, очень расплывчато, при этом, несмотря на такие расплывчатые планы, Microsoft говорит, что даже они не сильно точные, в том плане, что они будут внимательно слушать фидбэк аудитории, пользователей, и вероятно, если поймут, что нужно еще каких-то много доработок, может быть, даже подвинут релиз еще на попозже.
5239.60 5240.60 "Игорь Лабутин" Будем смотреть.
5240.60 5247.92 "Анатолий Кулаков" Среди этих больших и уже давно знаменитых имен затесалась еще одна интересная утилитка, но она довольно-таки новая.
5247.92 5257.36 "Анатолий Кулаков" Ну, новая для тех, кто не слушал наш подкаст, для людей, которые уже в курсе, они знают, что такое .NET Monitor, который выходит в релиз вместе с .NET 6.
5257.36 5266.32 "Анатолий Кулаков" Это был экспериментальный тул, и, наконец, к этому моменту он уже подтвердил свою пригодность к продакшену, поэтому команда решила его зарелизить.
5266.32 5268.52 "Анатолий Кулаков" В чем суть проблемы?
5268.52 5274.00 "Анатолий Кулаков" Дело в том, что вместе с нашими приложениями мы вынуждены собирать кучу диагностических артефактов.
5274.00 5291.12 "Анатолий Кулаков" Ну, такие как логи, трейсы, может быть, снимать дампы ваших процессов, и нужен для этого необходим какой-то инструмент, который будет работать одинаково на всех энвайрментах, что довольно-таки сложно, потому что энвайрментов у .NET теперь огромная и большая куча.
5291.12 5299.68 "Анатолий Кулаков" Вы можете запускать свои процессы как на десктоп-машинах, как на кубернет-кластерах, как на телефончиках, так на серверах и на всем, чем угодно.
5299.68 5310.32 "Анатолий Кулаков" Поэтому нужен был менеджер, такой поддерживаемый, краткоплатформенный нормальный инструмент, который бы объединил все эти платформы и дал какую-то базовую диагностику, где только это возможно.
5310.32 5313.24 "Анатолий Кулаков" И вот таким инструментом и стал .NET Monitor.
5313.24 5316.60 "Анатолий Кулаков" У него есть два основных режима работы.
5316.60 5319.64 "Анатолий Кулаков" Во-первых, это через HTTP API.
5319.64 5330.16 "Анатолий Кулаков" Если вдруг вы уже обнаружили какие-то проблемы в вашем приложении и вы хотите просто залезть к вашему приложению и подробнее посмотреть, что же там происходит, то вы должны воспользоваться именно этим путем.
5330.16 5333.40 "Анатолий Кулаков" То есть пойти и посмотреть, найти больше информации какой-то.
5333.40 5335.20 "Анатолий Кулаков" И с помощью триеров.
5335.20 5338.92 "Анатолий Кулаков" Это такой специальный механизм, который основан на правилах.
5338.92 5352.28 "Анатолий Кулаков" Он всегда собирает данные, отслеживает заданные вами параметры и может вам запустить какие-то определенные процессы, какие-то определенные действия, как только наступило ожидаемое вами событие.
5352.28 5358.48 "Анатолий Кулаков" Прежде всего .NET Monitor распространяется двумя официальными способами.
5358.48 5361.88 "Анатолий Кулаков" Во-первых, это через командную строку.
5361.88 5366.44 "Анатолий Кулаков" Вы можете набрать .NET Tool, Install и поставить себе .NET Monitor.
5366.44 5375.84 "Анатолий Кулаков" И во-вторых, это через контейнер .NET Pool из официального репозитория контейнеров для Microsoft.
5375.84 5378.84 "Анатолий Кулаков" И можете установить себе .NET Monitor в виде контейнера.
5378.84 5384.48 "Анатолий Кулаков" Соответственно, запустить в любой обстановке и натравить на какой-то определенный процесс.
5384.48 5391.92 "Анатолий Кулаков" Что же мы получаем, если вдруг заставим наш .NET Monitor следить за определенным процессом?
5391.92 5396.52 "Анатолий Кулаков" Прежде всего, через HTTP API у нас есть куча полезных ресурсов.
5396.52 5401.16 "Анатолий Кулаков" Во-первых, мы можем посмотреть ресурс процесс.
5401.16 5404.28 "Анатолий Кулаков" Здесь он нам вернет детальную информацию о данном процессе.
5404.28 5414.68 "Анатолий Кулаков" Мы можем вызвать ресурс Dump и сможем снять Dump без дебаггера прямо в продакшене с вашего приложения.
5414.68 5418.68 "Анатолий Кулаков" Мы можем вызвать ресурс GCDump и, соответственно, снять GCDump.
5418.68 5424.40 "Анатолий Кулаков" Можно посмотреть трейсы абсолютно без профайлера, только на основании вот этого .NET Monitor.
5424.40 5427.72 "Анатолий Кулаков" Мы можем посмотреть на Metrix.
5427.72 5437.84 "Анатолий Кулаков" Этот ресурс нам предоставляет описание в виде Prometheus формата, описание всех метрик, которые сейчас есть в приложении.
5437.84 5448.92 "Анатолий Кулаков" Можно недовольствоваться просто снапшотом этих метрик с предыдущего ресурса, запустить ресурс LiveMetrix и мы получим метрики в реальном времени, сможем за ними наблюдать.
5448.92 5455.00 "Анатолий Кулаков" Ресурс Log, как очевидно из названия, дает нам возможность прочитать какие-то логи.
5455.00 5466.04 "Анатолий Кулаков" Вот с помощью такого довольно простенького API вы уже можете получить какую-то базовую диагностическую информацию о вашем приложении и уже сделать какие-то дополнительные выводы.
5466.04 5468.00 "Анатолий Кулаков" Остановимся поподробнее на триггерах.
5468.00 5478.36 "Анатолий Кулаков" Как я уже говорил, это такой механизм, который позволяет на основании различных правил добиваться автоматического срабатывания ваших экшенов.
5478.36 5480.84 "Анатолий Кулаков" Например, вы можете задать такое условие.
5480.84 5491.04 "Анатолий Кулаков" Для определенного процесса снимать не больше одного дампа в час, если зарегистрированное устойчивое потребление процессора больше 80% в течение одной минуты.
5491.04 5496.28 "Анатолий Кулаков" Вот, например, такие какие-то извращенные вещи можете творить благодаря всего-навсего четырем концепциям.
5496.28 5501.64 "Анатолий Кулаков" Во-первых, это фильтр, который отфильтровывает только те процессы, которые вам нужны по имени или по пиду.
5501.64 5509.76 "Анатолий Кулаков" Триггеры – это специальные ивенты, которые привязываются к какому-то событию.
5509.76 5519.64 "Анатолий Кулаков" Например, вы можете посчитать количество реквестов или можете почитать статус от респонза, подписаться на эти триггеры, сделать какой-нибудь экшен.
5519.64 5524.36 "Анатолий Кулаков" Например, вышеупомянутый «собрать дамп» или «собрать логи».
5524.36 5528.80 "Анатолий Кулаков" И, естественно, нужно установить какие-то лимиты, чтобы вы где-то там не завалились чересчур.
5528.80 5535.80 "Анатолий Кулаков" То есть вы можете посчитать количество уже выполненных экшенов или какой-нибудь промежуток времени, чтобы собирать, например, логи не больше одной минуты.
5535.80 5537.80 "Анатолий Кулаков" Вот это все ограничивает лимиты.
5537.80 5555.00 "Анатолий Кулаков" С помощью таких простых концепций создаются довольно сложные правила, и эти правила автоматически могут ловить ошибки на продакшене, даже когда вы спите, и собирать действительно нужную информацию, с помощью которой позже уже вы сможете локально понять, что же такое странное творится с вашим приложением на продакшене.
5555.00 5562.44 "Игорь Лабутин" Прямо звучит круто, полезно, и мне бы такое хотелось бы, конечно, иметь еще во всяких облаках, когда там всякие App-сервисы работают.
5562.44 5575.76 "Игорь Лабутин" Пока такого прям функционала нет, но если вы все это запускаете в Докере, то, кстати, DotNet Monitor доступен в виде сайдкар-контейнера, и вы можете это тоже использовать от Microsoft, официальная сборка.
5575.76 5579.92 "Игорь Лабутин" Так что рассмотрите такой вариант, если вы пользуетесь контейнерами.
5579.92 5581.96 "Игорь Лабутин" Пойдем дальше.
5581.96 5612.56 "Игорь Лабутин" Мы обычно не сильно много рассказываем про облака, ажур и прочее, но на DotNet Conf было довольно много сессий посвященных этому, поэтому мы кратненько затронем, что DotNet 6 практически сразу после релиза доступен везде, где нужно в ажуре, то есть это и Azure Web Apps, и всякие статики веб-аппс, и также Azure Functions 4.0 версия, где вы можете использовать DotNet 6, ну и также всякие питончики, Java, PowerShell, Node.js, всяких разных версий.
5612.56 5616.16 "Игорь Лабутин" Поддержан и Isolated, и In-Process режимы.
5616.16 5627.08 "Игорь Лабутин" Там есть тонкости и отличия, когда какой вам нужно использовать, то есть, допустим, если вам нужны Durable функции, то, по-моему, вы должны использовать обязательно In-Process.
5627.08 5629.56 "Игорь Лабутин" Ну, в общем, там много всяких разных тонкостей.
5629.56 5642.64 "Игорь Лабутин" Смотрите статью Announce, смотрите документацию, когда что нужно использовать, но поддержаны оба, и все это уже должно быть раскатано на все регионы, так что вы должны это просто видеть и можно начинать использовать.
5642.64 5650.24 "Анатолий Кулаков" Также зарелизился один из самых распространенных языков, написанных на DotNet, это PowerShell.
5650.24 5666.44 "Анатолий Кулаков" PowerShell достиг версии 7.2, что является по его релиз-циклу LTS, и для нас интересно то, что этот релиз был откомпилирован на базе DotNet 6, поэтому это официальная первая версия PowerShell на 6-ом DotNet.
5666.44 5670.44 "Анатолий Кулаков" Разумеется, огромное количество Performance Improvements.
5670.44 5680.80 "Анатолий Кулаков" Напомню, что PowerShell уже давно поддерживается всеми платформами, он запускается на Windows, Linux, Mac, и где угодно еще, там где запускается DotNet.
5680.80 5697.12 "Анатолий Кулаков" Из новенького появилась поддержка ANSI Escape Sequences, это специальный индустриальный уже стандарт, который позволяет из вашей консоли задавать каким-то образом и декорировать текст.
5697.12 5703.64 "Анатолий Кулаков" То есть вы можете поменять цвет текста, поменять цвет бэкграунда, сделать текст жирненьким, наклоненьким и так далее.
5703.64 5722.96 "Анатолий Кулаков" Все это в консоли, в консоли нет каких-то определенных контролов для форматирования, поэтому эволюция пришла к тому, что с помощью этих Escape последовательностей мы можем в консоли рисовать интересную даже графику, делать игры и чего-то как-то с помощью них не делают.
5722.96 5744.96 "Анатолий Кулаков" Для того, чтобы с этим было как-то легче управляться, был добавлен специальный класс, который называется PSStyle и он позволяет из ваших скриптов более удобно управлять этими Escape последовательностями, потому что те, кто их использовал, знают, что это какие-то абсолютно нечитабельные коды, специально зашифрованные скобочки, какие-то топчики с запятой, логические циферки.
5744.96 5749.04 "Анатолий Кулаков" В общем, вменяемому человеку на это смотреть сначала очень-очень тяжело.
5749.04 5763.76 "Анатолий Кулаков" Вот чтобы как-то этот порог сгладить, команда PowerShell сделала для нас специальные утилитки, которые довольно таки удобно, хорошо и красиво могут дать вам поддержку, полную поддержку всех этих способов форматирования, но в более человечной форме.
5763.76 5770.08 "Анатолий Кулаков" Также у нас появился новый интелисенс с помощью PSRedline.
5770.08 5782.20 "Анатолий Кулаков" Интересность здесь заключается в том, что заиспользован PSRedline 2.1, а в нем появилась возможность преддикшена, то есть предсказывать команды.
5782.20 5801.40 "Анатолий Кулаков" Это значит, что ваша консоль становится более интерактивной, и вы, соответственно, более продуктивно можете за ней работать, потому что теперь, учитывая вашу историю, я не побоюсь этого слова "учась" на вашей истории, она сможет вам подсказывать те команды, которые вы вероятнее всего сейчас будете набирать.
5801.40 5814.12 "Анатолий Кулаков" Вот, мы эту тенденцию наблюдаем в наших уже полноценных HDD-шках, и вот, наконец, умный интелисенс с анализом вашей персональной истории добрался и до консольных утилит и до консольных шеллов.
5814.12 5819.40 "Игорь Лабутин" Теперь нужно, чтобы JetBrains выпустил свой шелл, чтобы там были рефакторинги, еще что-нибудь.
5819.40 5826.44 "Игорь Лабутин" Вот так теперь не можно писать, будет подсказывать тебе, вылезает ToolTip в командной строке, а так теперь не пишет, перепиши на новую версию.
5826.44 5832.00 "Анатолий Кулаков" Да, я думаю, если открыть PowerShell в райдере, то он там сможет что-то тебе найти, что тебе можно переписать.
5832.00 5836.56 "Анатолий Кулаков" Райдер или решапер всегда найдут, что тебе улучшить в своем проекте или переписать.
5836.56 5837.56 "Анатолий Кулаков" Да.
5837.56 5840.92 "Игорь Лабутин" Ну, давай пойдем на последнюю тему.
5840.92 5867.40 "Игорь Лабутин" Это не совсем относится прямо к шестому .NET, но тема на самом деле важная и интересная в плане, что если вы изучаете, что происходит в мире .NET и в мире Microsoft, то, наверное, замечали, что Microsoft на самом деле генерирует довольно большое количество онлайн-контента, обучающего такого полуразвлекательного, просто интервьюшки разные, и они все что-то на YouTube, что-то еще где-то.
5867.40 5873.36 "Игорь Лабутин" Microsoft сейчас старается все это объединить под единым, так скажем, брендом, что ли.
5873.36 5885.72 "Игорь Лабутин" То есть у них есть довольно большое количество шоу, там Ask Experts, Learn Live, After Party, Table Talk, Training Days, и все это пытается объединиться под общим брендом под названием Microsoft Learn TV.
5885.72 5890.12 "Игорь Лабутин" И вот они объявили, что теперь туда же переезжает Channel 9.
5890.12 5902.08 "Игорь Лабутин" То есть мы долгое время знали, что вот Channel 9 - это такой обособлен настоящий кусочек, не YouTube, но большое количество видеоматериалов от Microsoft.
5902.08 5913.56 "Игорь Лабутин" Вот теперь Channel 9 будет теперь доступен в рамках Learn TV, и все архивы туда переедут, как они обещали, так что теперь все, что вы хотите знать, будет их жить именно там.
5913.56 5916.44 "Игорь Лабутин" И изучайте, смотрите, что там Microsoft генерирует.
5916.44 5919.04 "Игорь Лабутин" Microsoft на самом деле делает довольно много хорошего контента.
5919.04 5933.32 "Анатолий Кулаков" Слушай, а лично мне обидно, что они теряют торговую марку Channel 9, потому что вот те качественные, хорошие видосики с реальными разработчиками, с хорошими темами, как раз у меня ассоциируются почему-то с Channel 9.
5933.32 5949.96 "Анатолий Кулаков" А все вот эти Learning, Ask Experts, Getting Started и прочее, обычно там давали очень вводный уровень, и он был реально для новичков, поэтому можно было весь контент чисто отсеивать сразу и пытаться что-то выбрать из Channel 9.
5949.96 5954.64 "Анатолий Кулаков" А теперь это все сольется вместе, и не очень понятно, как ориентироваться.
5954.64 5962.52 "Анатолий Кулаков" Ну и плюс Channel 9, мне кажется, за эти годы уже знают абсолютно все, то есть это реально торговая марка, ее реально уже можно продавать, ее реально уже можно рекламировать.
5962.52 5966.68 "Анатолий Кулаков" Они просто берут, выбрасывают и изобретают какое-то очередное новое название.
5966.68 5972.96 "Игорь Лабутин" Ну может совсем и не выбросят, какой-нибудь там плейлистик внутри назовут как Channel 9, не знаю, посмотрим.
5972.96 5977.96 "Игорь Лабутин" Но да, именно как Channel 9, как отдельная сущность, существовать вроде как перестает.
5977.96 5981.92 "Игорь Лабутин" Ну и что, на этом я думаю все, хватит на сегодня.
5981.92 5984.12 "Игорь Лабутин" Да, достаточно, давай подводить итоги.
5984.12 5989.84 "Игорь Лабутин" Ну как, DotNet 6, DotNet 6, DotNet 6 и DotNet 6, практически так.
5989.84 6016.12 "Игорь Лабутин" Ну в рамках DotNet 6 мы посмотрели на все то, что было сделано там и на спинете, посмотрели на C# 10, вспомнили про MAUI, что он все еще, пока планы не поменялись и мы ждем 2022 года, 22 студия, 6 Nougat, DotNet Monitor, Azure изменения, касающиеся DotNet 6, PowerShell 7.2 и Microsoft Learn TV, он уже бывший Channel 9.
6016.12 6037.92 "Анатолий Кулаков" Вот после таких выпусков, знаешь, у меня создается вот впечатление, что не зря мы все это делаем, потому что абсолютно любая эта тема, абсолютно любой хайп на вышедшем DotNet 6, у меня были ассоциации с тем, что мы это все уже говорили, все это уже разбирали, все это уже видели и вот никакого перенасыщения вот этим релизом не было.
6037.92 6054.08 "Анатолий Кулаков" На самом деле в него вошло очень много всего, с разных сторон, с разными фичами и никакого перенасыщения нет, потому что со всем этим мы уже знакомились, обо всем этом мы нашим слушателям уже рассказывали и прошел он довольно гладко, привычно и нормально, никакого удивления.
6054.08 6055.84 "Анатолий Кулаков" Есть ли у тебя такое ощущение?
6055.84 6104.08 "Игорь Лабутин" Оно действительно есть и мне кажется это во многом, ну во-первых, потому что мы это рассказывали, но рассказывали мы про это, потому что это большой плюс того, что все это делается в общем-то open-source, ну хорошо, почти все, то есть тот же Hot Reload, например, он был довольно закрытый, но вот внезапно его, значит, внесли в SDK и он стал open-source, окей, хорошо, но большинство фич, там C# и весь основной дотнет и аспнет, они разрабатываются в целом в open-source, и поэтому мы все видим все эти ранние превью и Microsoft не боится их релизить, не боится их пиарить, посмотрите, что у нас есть, посмотрите, что мы сделали, посмотрите, возможно оно что-то вам ломает, особенно в ранних превью, но тем не менее, это все живет, работает и прекрасно позволяет, собственно, ознакомиться с направлением и даже повлияет на него в каком-то смысле.
6104.08 6106.60 "Анатолий Кулаков" Да, да, ты прав.
6106.60 6125.72 "Анатолий Кулаков" Друзья, пойдите, пожалуйста, в комментарии и расскажите о том, помогает ли наш подкаст вот как-то лучше ориентироваться в дотнете, в наших новостях, то, что происходит вокруг, то есть те вещи, которые мы обсуждали там по полгода, по году, помогают ли они вам не так удивляться и лучше ориентироваться в современных анонсах.
6125.72 6144.96 "Анатолий Кулаков" А если вдруг вы к нам присоединились недавно и хотите подробнее узнать про какую-то из тех тем, которые мы сегодня вскользь упомянули, то обязательно просто поищите, мы практически про все говорили более глубоко, звали экспертов, обсуждали это с разных сторон и все эти темы в принципе за весь этот год мы уже как-то проходили.
6144.96 6157.48 "Анатолий Кулаков" А для нашего подкаста, который вот конкретно целится на дотнет и рассказывает новости вокруг дотнета, мне кажется, вот можно считать завершением какого-то сезона вот такой релиз.
6157.48 6169.32 "Анатолий Кулаков" И со следующего сезона мы уже начнем наблюдать за эффектом от как раз дотнет шестого, может быть, за какими-то новыми зачатками новых идей, продуктов и все, что будет касаться уже следующей релизной
6169.32 6177.44 "Игорь Лабутин" ветки. Да, действительно, мы посмотрим, что такое будет C# 11, хотя понятно, что еще очень рано говорить, что там будет.
6177.44 6195.96 "Игорь Лабутин" Дотнет 7, который будет во многом, как мне кажется, гораздо более экспериментальным, потому что это не LTS, и можно себе там позволить какие-то, ну скажем так, может быть они все будут под ключиками и фича-флагами, но возможно какие-то более экспериментальные опции по сравнению с LTS релизом.
6195.96 6205.48 "Игорь Лабутин" Я думаю, что следующий год будет веселее в плане новинок, и может быть и нам, как подкасту, тоже может быть надо что-нибудь интересное менять.
6205.48 6217.88 "Игорь Лабутин" Если у вас есть, например, какие-то идеи, что бы вы хотели услышать в каком-нибудь, может быть, новом формате, в новом, какие-то новые рубрики, не знаю, что-нибудь еще, то тоже пишите нам, мы подумаем, посмотрим.
6217.88 6228.08 "Игорь Лабутин" Особенно сейчас у нас будет наверняка какое-то затишье перед первыми анонсами 7-го дотнета, и поэтому можем с чем-нибудь поэкспериментировать и что-нибудь там подготовить
6228.08 6235.36 "Анатолий Кулаков" новенькое. Да, да, вообще не стесняйтесь нам всегда писать, нам очень приятно любые комментарии, любой фидбэк, любое ваше мнение.
6235.36 6251.88 "Анатолий Кулаков" Ну что ж, давай закругляться, был отличный релиз, был отличный год, прекрасные, мне кажется, нововведения, у нас теперь есть LTS, можно смело тратить следующий год на перевод старых проектов, старых продуктов на новую версию, которая как минимум даст вам бешеный перформанс.
6251.88 6253.44 "Анатолий Кулаков" И что не может не радовать?
6253.44 6254.44 "Анатолий Кулаков" И ход релоуд.
6254.44 6255.44 "Анатолий Кулаков" А их от релоуд.
6255.44 6256.44 "Анатолий Кулаков" Всем пока!
6256.44 6256.44 None Всем пока!
6256.44 6257.44 "Игорь Лабутин" Всем пока!
6257.44 6257.44 None Всем пока!
6257.44 6257.94 "Игорь Лабутин" Всем пока!
6257.94 6258.94 None Всем пока!
6258.94 6259.94 None Всем пока!
6259.94 6260.94 None Всем пока!
6260.94 6261.94 "Евгений Пешков" Всем пока!
6261.94 6262.94 "Евгений Пешков" Всем пока!
6262.94 6263.94 "Евгений Пешков" Всем пока!
