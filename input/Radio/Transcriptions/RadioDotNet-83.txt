0.00 10.16 SPEAKER_01 Здравствуйте, дорогие друзья, в эфире Radio.net выпуск номер
10.16 11.16 SPEAKER_01 83.
11.16 14.96 SPEAKER_01 И в студии, как всегда, Анатолий Кулаков и Игорь Лабутин.
14.96 15.96 SPEAKER_01 Всем привет.
15.96 18.78 SPEAKER_01 Большое спасибо нашим обстоятельным помогаторам, среди них
18.78 21.28 SPEAKER_01 Александр, Сергей, Владислав, Шевченко Антон, Лазарев
21.28 24.64 SPEAKER_01 Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр
24.64 28.08 SPEAKER_01 Ерыгин, Сергей Бензенко и Александр Лапердин.
28.08 30.82 SPEAKER_01 Всем большое спасибо вам, а также всем тем, кто пошел
30.82 31.82 SPEAKER_01 остаться неназванными.
31.82 34.62 SPEAKER_01 Если вы хотите присоединиться к этому бравому списку
34.62 37.52 SPEAKER_01 или просто поддержать наш подкаст «Маленькая монетка»,
37.52 41.06 SPEAKER_01 заходите на наш сайт на Boosty и посмотрите, что интересного
41.06 42.14 SPEAKER_01 он вам может предложить.
42.14 46.78 SPEAKER_01 Так, из еще интересного, мы в прошлом выпуске разыгрывали
46.78 49.42 SPEAKER_01 две книги про Blazer, печатные, свеженькие, только что
49.42 53.04 SPEAKER_01 из-под типографии, с нашими автографами заодно, мы
53.04 54.80 SPEAKER_01 не упустили шанс на них порисовать.
54.80 59.32 SPEAKER_01 Книги разыграны, авторы уже уведомлены, со всеми
59.32 63.12 SPEAKER_01 я связался и думаю, что к моменту выхода этого выпуска
63.12 66.24 SPEAKER_01 книги уже будут в пути к своим непосредственным
66.24 67.24 SPEAKER_01 новым владельцам.
67.24 70.00 SPEAKER_01 С чем их и поздравляем, и спасибо всем тем, кто
70.00 72.92 SPEAKER_01 участвовал в нашем конкурсе и помогал распространять
72.92 73.92 SPEAKER_01 подкаст.
73.92 76.80 SPEAKER_01 Ну что ж, если по темам, Игорь, у нас что-нибудь
76.80 78.32 SPEAKER_01 от Микрософта сегодня есть?
78.32 83.16 SPEAKER_01 Да вообще ничего, с трудом искали, так что будет всякая
83.16 85.60 SPEAKER_01 фигня в этом выпуске, можно уже отключаться.
85.60 89.44 SPEAKER_01 Но если вы все-таки останетесь с нами, то вы узнаете, что
89.44 91.40 SPEAKER_01 сегодня весь выпуск будет про Майкрософт, потому
91.40 94.48 SPEAKER_01 что, конечно же, прошел dotnet.conf, конечно же, зарелизился
94.48 98.28 SPEAKER_01 восьмой dotnet, и, как мы и обещали, мы будем рассказывать
98.28 101.80 SPEAKER_01 про все новинки, ну ладно, не все, про все не сможем,
101.80 102.80 SPEAKER_01 их было много.
102.80 106.36 SPEAKER_01 Ну действительно, если мы будем каждую тему разбирать,
106.36 110.28 SPEAKER_01 это будет очень-очень долгий выпуск, мы пройдемся кратко,
110.28 112.00 SPEAKER_01 пробежимся, что было, что показали, естественно,
112.00 114.84 SPEAKER_01 нововведения еще раз кратенько повторим, если какое-то
114.84 118.08 SPEAKER_01 нововведение вас затронет, как-то ближе захочется про
118.08 121.52 SPEAKER_01 него узнать, то, скорее всего, у нас в течение этого года
121.52 124.40 SPEAKER_01 был отдельный выпуск с большим-большим обсуждением,
124.40 126.56 SPEAKER_01 потому что в течение года мы все это обсуждали в больших
126.56 128.60 SPEAKER_01 подробностях, с примерами и так далее.
128.60 130.84 SPEAKER_01 Сейчас просто-напросто подводим итоги, что из
130.84 133.40 SPEAKER_01 этого вошло, что вышло, и о чем Микрософт решил
133.40 134.68 SPEAKER_01 как бы в первую очередь рассказать.
134.68 139.68 SPEAKER_01 Ну и начнем мы с основной новости, грубо говоря,
139.68 143.96 SPEAKER_01 то, что .NET 8, напоминаю, что это LTS-версия, то есть
143.96 148.40 SPEAKER_01 она будет поддерживаться 3 года, короче, это проект
148.40 150.88 SPEAKER_01 к 3-х лет, что-то я уже начинаю путаться, до следующего
150.88 155.48 SPEAKER_01 LTS точно доживет до 10-го, и как написано в открывающем
155.48 159.64 SPEAKER_01 посте, она позволяет собирать, то есть я не могу это перевести
159.64 164.40 SPEAKER_01 на русский, build intelligent cloud native apps, high traffic services
164.40 167.80 SPEAKER_01 и тем, которыми нужно scale on demand.
167.80 170.80 SPEAKER_01 Ну вообще вот эта тема у них с клаудом, последнее
170.80 174.20 SPEAKER_01 время, ну последние несколько релизов прямо давилось
174.20 176.48 SPEAKER_01 как бы во все предложения, а в этом релизе просто
176.48 180.36 SPEAKER_01 они все на клауд перевели, и язык у них под клауд заточен,
180.36 182.40 SPEAKER_01 и фреймворк под клауд, и все новые фреймворки под
182.40 185.12 SPEAKER_01 клауд, мы сейчас с вами не раз упомянем это слово,
185.12 187.12 SPEAKER_01 и так бы до сих пор никто не объяснил, да, что такое
187.12 188.12 SPEAKER_01 cloud ready application.
188.12 190.64 SPEAKER_01 Ну, кстати, нет, мы сегодня немножко это затронем
190.64 194.92 SPEAKER_01 ближе к концу, что же это такое и что Микрософт считает
194.92 197.84 SPEAKER_01 правильным делать для cloud native приложений, но пока
197.84 201.12 SPEAKER_01 мы пойдем по основному анонсу, и конечно же первое
201.12 204.84 SPEAKER_01 с чего они начинают, это performance, если вы помните
204.84 207.80 SPEAKER_01 картинку с презентации прошлогодней, где были
207.80 210.80 SPEAKER_01 там такие кружочки, где мы говорили, что мы там,
210.80 215.20 SPEAKER_01 не знаю, сколько там, 100 типа импрувментов в пятом
215.20 218.28 SPEAKER_01 дотнете, 500 импрувментов в шестом дотнете, тысячи
218.28 220.92 SPEAKER_01 импрувментов в седьмом дотнете, это в смысле количество
220.92 225.00 SPEAKER_01 pull-requests в гитхабе за релиз, который относится хоть
225.00 226.00 SPEAKER_01 как-то к перформансу.
226.00 230.00 SPEAKER_01 Вот в этом релизе их 1250, ну, с плюсиком, типа чуть
230.00 231.00 SPEAKER_01 больше.
231.00 235.48 SPEAKER_01 Короче, одни сплошные performance-импрувменты, может быть, перформанс уже
235.48 238.56 SPEAKER_01 настолько приходится выгребать по мелким частям, что pull-requests
238.56 241.84 SPEAKER_01 становятся меньше, их больше, может быть поэтому, но числа
241.84 242.84 SPEAKER_01 рекламные хорошие.
242.84 245.64 SPEAKER_01 Ну, другой вопрос, как они могли столько медленного
245.64 247.64 SPEAKER_01 кода выпустить в продакшн, чтобы его потом несколько
247.64 249.84 SPEAKER_01 релизов по тысячу pull-requests импрувить?
249.84 252.98 SPEAKER_01 Да он был немедленный, просто он был нормальный,
252.98 254.44 SPEAKER_01 а мы теперь еще его будем импровить, всегда есть
254.44 255.44 SPEAKER_01 чего поимпровить.
255.44 260.92 SPEAKER_01 И одним из основных импрувментов, это, конечно, включение
260.92 265.20 SPEAKER_01 dynamic pgo, profile-guided optimization, то есть эта штука, мы про
265.20 269.00 SPEAKER_01 нее довольно подробно рассказывали, как она там компилирует
269.00 273.76 SPEAKER_01 через тиры, тир 0, тир 0 инструмента, тир 1, и вот это все, а если
273.76 277.00 SPEAKER_01 у вас есть ready-to-run, то там другой тир 1, тир 0, в общем
277.00 278.84 SPEAKER_01 там я про это все подробно довольно рассказывал в
278.84 281.68 SPEAKER_01 одном из прошлых выпусков, но смысл в том, что эта штука
281.68 284.72 SPEAKER_01 теперь включена по умолчанию, по умолчанию ваше приложение
284.72 288.80 SPEAKER_01 будет теперь оптимизироваться в рантайме, и в среднем
288.80 292.12 SPEAKER_01 для обычных приложений перфоманс может вырасти
292.12 296.60 SPEAKER_01 просто на халяву до 20%, просто потому что вы переключились
296.60 297.60 SPEAKER_01 на восьмой дотнет.
297.60 300.44 SPEAKER_01 При этом надо понимать, что если вы, например,
300.44 304.76 SPEAKER_01 очень печетесь о перфомансе, во-первых, надо тщательно
304.76 308.10 SPEAKER_01 посмотреть и заново померить те старые места, где у вас
308.10 311.60 SPEAKER_01 были какие-то, возможно, перфоманс-оптимизации написаны
311.60 315.76 SPEAKER_01 вручную, попробовать примитивный код на них, то есть отменить
315.76 317.84 SPEAKER_01 вашу оптимизацию, написать обычный код и посмотреть,
317.84 320.88 SPEAKER_01 не станет ли лучше, потому что джит становится умнее,
320.88 324.40 SPEAKER_01 джит становится лучше, profile-guided optimization может ваш код
324.40 327.40 SPEAKER_01 преобразить вообще до неузнаваемости, потому что он в том числе
327.40 332.24 SPEAKER_01 реордерит иногда, допустим, условия бранчей, чтобы
332.24 335.56 SPEAKER_01 моя частая ветка получалась максимально то, что называется
335.56 336.56 SPEAKER_01 branchless, без переходов.
336.56 342.04 SPEAKER_01 И в этом случае, возможно, ваш оптимальный для шестого
342.04 344.28 SPEAKER_01 дотнета код уже не такой оптимальный для восьмого,
344.28 346.72 SPEAKER_01 и обычный простой код будет лучше и быстрее.
346.72 352.12 SPEAKER_01 А во-вторых, если вы бенчмаркаете, если вы постоянно делаете
352.12 355.00 SPEAKER_01 какие-то бенчмарки, даже если вы правильно используете
355.00 358.52 SPEAKER_01 бенчмарк дотнет, надо теперь внимательно смотреть и
358.52 363.56 SPEAKER_01 понимать, как dynamic pgo на это влияет, потому что если
363.56 368.88 SPEAKER_01 у вас, например, бенчмарк, который, не знаю, сортирует
368.88 370.60 SPEAKER_01 может быть неправильно, ну не знаю, вызывает какую-то
370.60 373.96 SPEAKER_01 функцию и периодически ей передает то a, то b, то
373.96 377.12 SPEAKER_01 надо понимать, что если частота одного из аргументов
377.12 381.20 SPEAKER_01 будет чуть выше другой, то dynamic pgo под это дело оптимизирует,
381.20 385.96 SPEAKER_01 и код будет мерить не абсолютную разницу между подходом
385.96 389.18 SPEAKER_01 a и подходом b, а разницу между оптимизированным
389.18 391.32 SPEAKER_01 более частым подходом и менее оптимизированным
391.32 392.32 SPEAKER_01 более редким подходом.
392.32 395.88 SPEAKER_01 Слушай, а интересно вот как-то бенчмарк дотнет
395.88 398.72 SPEAKER_01 к этой теме подстроится, к dynamic pgo, я просто не знаю,
398.72 400.72 SPEAKER_01 как можно к этому подстроить, ну хотя бы отключать его,
400.72 401.72 SPEAKER_01 наверное, как-то.
401.72 403.16 SPEAKER_01 Ну отключать это можно переменное окружение, да,
403.16 406.32 SPEAKER_01 вы можете отключить полностью, и это рекомендация Microsoft,
406.32 409.00 SPEAKER_01 что теперь он включен по умолчанию, но если вы вдруг
409.00 412.56 SPEAKER_01 видите, не знаю, баги, падение рантайма, странное поведение,
412.56 415.88 SPEAKER_01 тормоза, то отключите и зарепортите в Microsoft, потому
415.88 417.96 SPEAKER_01 что не должно быть такого, не должно быть тормозов
417.96 419.56 SPEAKER_01 с включенным dynamic pgo.
419.56 422.76 SPEAKER_01 Ну если мы говорим о бенчмарках, то, наверное, выключать
422.76 424.92 SPEAKER_01 это тут не очень правильно, да, потому что из-за бенчмарка
424.92 426.52 SPEAKER_01 ишь в вакууме, а работать оно у тебя будет в совсем
426.52 427.52 SPEAKER_01 других условиях.
427.52 428.52 SPEAKER_01 Все так.
428.52 432.00 SPEAKER_01 Надо научиться как-то тестить вместе с ним, а как?
432.00 433.00 SPEAKER_01 Все так.
433.00 436.96 SPEAKER_01 Есть на самом деле в, вот я сейчас не вспомню, где
436.96 439.68 SPEAKER_01 я сейчас, я когда готовился, по-моему, в гитхабе и шлюзах
439.68 442.72 SPEAKER_01 где-то, а может быть даже, кстати, в оригинальной
442.72 447.52 SPEAKER_01 статье, собственно, про performance, есть врезка про
447.52 450.46 SPEAKER_01 то, что, типа, ребята, если вы пишите бенчмарки, смотрите
450.46 451.46 SPEAKER_01 внимательнее.
451.46 454.96 SPEAKER_01 Типа, бенчмарк дотнет, конечно, постарается там все прогреть
454.96 458.48 SPEAKER_01 и за счет вармапа у вас, скорее всего, по крайней
458.48 461.28 SPEAKER_01 мере на момент нормального бенчмарка не будет уже
461.28 466.72 SPEAKER_01 перекомпиляции джитовых, но ставится вопрос оптимизированного
466.72 468.72 SPEAKER_01 кода, то есть проверяй, может быть надо на самом
468.72 471.54 SPEAKER_01 деле правильно тогда будет уже смотреть дизассемблер
471.54 475.04 SPEAKER_01 в бенчмарк дотнете, есть соответствующий диагнозер,
475.04 477.68 SPEAKER_01 который позволяет задампить дизассемблер и проверять
477.68 480.32 SPEAKER_01 уже на уровне дизассемблера, что же вы там в бенчмаркете
480.32 483.64 SPEAKER_01 и правильно ли эта штука, и если нет, то как-то думать.
483.64 486.68 SPEAKER_01 Пока я не видел каких-то прям рекомендаций, как
486.68 490.58 SPEAKER_01 это делать, вот, но вероятно они появятся рано или поздно.
490.58 496.84 SPEAKER_01 Так, по перформансу, что еще, ну, AVX 512, если вы счастливый
496.84 499.20 SPEAKER_01 обладатель процессора, у которого есть AVX 512, у вас
499.20 501.40 SPEAKER_01 еще будет кое-что побыстрее.
501.40 505.60 SPEAKER_01 Для примитивных типов завезли отличное форматирование
505.60 508.32 SPEAKER_01 прямо в UTF-8 строчке, то есть там не нужно аллоцировать
508.32 510.36 SPEAKER_01 теперь строку, он умеет из какого-нибудь там read-only
510.36 517.64 SPEAKER_01 спана байтов с UTF-8, в которой лежит UTF-8 чиселка, например,
517.64 519.56 SPEAKER_01 десериализовывать сразу в число без дополнительных
519.56 522.04 SPEAKER_01 аллокаций, ну и обратно, соответственно, писать.
522.04 525.60 SPEAKER_01 Ну и техампауэр бенчмарки, они, конечно, выросли, значит,
525.60 528.80 SPEAKER_01 в JSON-бенчмарке было 800 тысяч реквестов, мы добрались
528.80 533.52 SPEAKER_01 почти до миллиона, а в Fortune, который, как утверждается,
533.52 536.00 SPEAKER_01 практически идеально соответствует обычным веб-приложениям
536.00 538.58 SPEAKER_01 с 260 тысяч почти до 320 добрались.
538.58 542.60 SPEAKER_01 Слушай, это же первый раз, да, они с Fortune как-то компарятся?
542.60 545.28 SPEAKER_01 Потому что раньше обычно только техампауэр был.
545.28 547.96 SPEAKER_01 Нет, так, подожди, ты не путай, в техампауэре это
547.96 549.60 SPEAKER_01 один из тестов внутри техампауэра.
549.60 551.48 SPEAKER_01 А, это просто часть техампауэра?
551.48 552.48 SPEAKER_01 Это часть, да.
552.48 554.84 SPEAKER_01 В техампауэре есть разные, так скажем, уровни, там
554.84 557.76 SPEAKER_01 есть то, что называется Platform Only, когда там, грубо
557.76 560.80 SPEAKER_01 говоря, ты на кестриле шлешь байтики в ответ в сокет,
560.80 563.56 SPEAKER_01 то есть он проверяет, по сути, только сетевую часть,
563.56 567.12 SPEAKER_01 есть там Minimal, где там из Minimal API стандартный, прям
567.12 570.88 SPEAKER_01 это HTTP-ответ с тростиками фигачим, есть JSON, где мы
570.88 573.92 SPEAKER_01 все-таки децерализуем какой-то JSON туда-сюда, и есть Fortunes,
573.92 577.00 SPEAKER_01 который, вот я не помню, ходит ли он в BD, может быть,
577.00 578.00 SPEAKER_01 нет.
578.00 580.28 SPEAKER_01 То есть, короче, они там есть разной степени, так
580.28 581.28 SPEAKER_01 сказать, навороченности.
581.28 584.32 SPEAKER_01 Вот в Fortunes они приводят, ну и видно по количеству,
584.32 587.72 SPEAKER_01 да, JSON это 800 тысяч, а в Fortunes 260к было, ну и стало, соответственно,
587.72 590.64 SPEAKER_01 миллион, почти миллион, там 900 с чем-то, и 320к, то
590.64 593.72 SPEAKER_01 есть там в три раза разница, по количеству реквестов
593.72 594.96 SPEAKER_01 явно больше работы делается.
594.96 598.52 SPEAKER_01 Вот, но я не проверял какой там самый-самый-самый правильный
598.52 601.00 SPEAKER_01 фулл-тест, может быть, и не Fortunes, может быть, есть
601.00 603.36 SPEAKER_01 еще какой-то, но мы там делаем меньше 100 тысяч реквестов
603.36 605.68 SPEAKER_01 и в материалах маркетинга это смотрится не очень
605.68 606.68 SPEAKER_01 здорово.
606.68 610.60 SPEAKER_01 Ну да ладно, короче, перформанс в среднем, в любом случае,
610.60 611.60 SPEAKER_01 вырос.
611.60 613.76 SPEAKER_01 Я действительно видел много всяких разных и твитов,
613.76 616.16 SPEAKER_01 и статей на тему того, что вот, мы обновились на восьмерку,
616.16 617.16 SPEAKER_01 стало быстрее.
617.16 618.80 SPEAKER_01 Скорее всего, в основном это, конечно, за счет Dynamic
618.80 623.04 SPEAKER_01 PGO, ну и всяких разных оптимизаций внутри стандартной библиотеки
623.04 626.68 SPEAKER_01 тоже, конечно же, много, среди этих 1250+ импровментов
626.68 628.96 SPEAKER_01 там есть всякие разные.
628.96 634.16 SPEAKER_01 Дальше, поскольку мы Cloud Native, вот это все, то, конечно
634.16 635.88 SPEAKER_01 же, есть улучшения в контейнерах.
635.88 637.40 SPEAKER_01 Про контейнеры мы, по-моему, рассказывали каждый второй
637.40 639.52 SPEAKER_01 выпуск, мне кажется, там что-то менялось, дополнялось
639.52 640.52 SPEAKER_01 и добавлялось.
640.52 643.12 SPEAKER_01 Кратко напомню, в чем там смысл.
643.12 647.16 SPEAKER_01 Во-первых, у нас теперь контейнеры по дефолту паблишится,
647.16 649.00 SPEAKER_01 точнее, создаются без рута.
649.00 652.32 SPEAKER_01 Во-вторых, их можно паблишить без написания докер файла
652.32 653.56 SPEAKER_01 прямо дотнет тулинга.
653.56 657.92 SPEAKER_01 В-третьих, базовые имиджи стали гораздо меньше.
657.92 661.04 SPEAKER_01 Причем меньше стали все имиджи, на самом деле, включая
661.04 663.92 SPEAKER_01 там всякие альпайны, дебилины и прочее, но в том числе
663.92 669.48 SPEAKER_01 на Ubuntu делается так называемый chiseled, то есть урезанные,
669.48 673.36 SPEAKER_01 порезанные имиджи, которые делаются для увеличения,
673.36 675.00 SPEAKER_01 на самом деле, для двух вещей.
675.00 677.48 SPEAKER_01 Во-первых, для security, потому что чем меньше компонентов
677.48 680.44 SPEAKER_01 внутри, тем больше, тем меньше, точнее, поверхность
680.44 682.76 SPEAKER_01 атаки и меньше шансов, что вас как-то смогут сломать.
682.76 686.04 SPEAKER_01 Ну и во-вторых, просто маленький образ, это просто приятно.
686.04 688.52 SPEAKER_01 Все эти уменьшенные образы могут быть использованы
688.52 691.68 SPEAKER_01 для дотнет шестерки, семерки и восьмерки, ну, соответственно,
691.68 697.52 SPEAKER_01 используем там 8.0-djammy, это кодовое имя убунтовского
697.52 700.84 SPEAKER_01 дистрибутива базового, и потом chiseled, это так такой,
700.84 701.84 SPEAKER_01 через D-физики.
701.84 706.24 SPEAKER_01 Все это основано на Ubuntu 22.04, удалено как максимально
706.24 709.36 SPEAKER_01 возможное количество компонентов, вот, и причем Майкрософт
709.36 712.96 SPEAKER_01 делал какую-то автоматизацию и тулинг, что как только
712.96 717.68 SPEAKER_01 они теперь фиксируют всякие CVE в уязвимости, в основном
717.68 720.20 SPEAKER_01 репозитории, у них, типа, все образы пересобираются
720.20 722.40 SPEAKER_01 там в течение нескольких часов и паблишатся на Docker
722.40 724.84 SPEAKER_01 Hub, то есть на Docker Hub всегда свежие пофикшенные образы
724.84 726.08 SPEAKER_01 базовые лежат.
726.08 730.14 SPEAKER_01 Ну, для сравнения, они говорят, что вот эти вот неурезанные
730.14 733.20 SPEAKER_01 образы, если посчитать количество компонентов,
733.20 735.60 SPEAKER_01 под количеством компонентов линуксовых они считают
735.60 738.28 SPEAKER_01 количество пакетов установленных, то есть они просто считают
738.28 742.28 SPEAKER_01 там сколько какой-нибудь, там, dbkg-info или что там есть,
742.28 744.68 SPEAKER_01 я уже не помню, сейчас наизусть всю эту комодлайны, выдает
744.68 747.04 SPEAKER_01 с точки зрения количества штук пакетов, соответственно,
747.04 752.04 SPEAKER_01 на Alpine они получают 17, на Debian 92, на Ubuntu 105, а если они
752.04 755.08 SPEAKER_01 берут урезанную Ubuntu, то там всего 7.
755.08 761.60 SPEAKER_01 Вот, там типа libc, ssl и еще каких-то, ну, такого же плана
761.60 764.16 SPEAKER_01 библиотек, и все, больше там нет ничего.
764.16 766.96 SPEAKER_01 Вот, ну и в результате все эти базовые образы получаются
766.96 770.64 SPEAKER_01 существенно меньше, то есть, типа, там 100 мегабайт
770.64 775.12 SPEAKER_01 по сравнению с 220 мегабайтами, это прям, ну, довольно хорошее
775.12 776.12 SPEAKER_01 улучшение.
776.12 778.32 SPEAKER_01 Вот, это про контейнеры.
778.32 780.80 SPEAKER_01 Короче, просто используем стандартные базовые контейнеры
780.80 781.80 SPEAKER_01 и все у вас будет хорошо.
781.80 786.36 SPEAKER_01 Native Out, я думаю, что мы про Native Out еще поговорим, дальше
786.36 791.24 SPEAKER_01 там про spend наверняка будет много чего в Native Out, но из-за
791.24 794.44 SPEAKER_01 важного они просто захайлайтили результаты в чиселках,
794.44 797.16 SPEAKER_01 что я на линуксовые приведу, потому что, наверное, это
797.16 798.16 SPEAKER_01 самое интересное.
798.16 801.76 SPEAKER_01 В линуксовых, соответственно, если мы паблишим приложение,
801.76 805.96 SPEAKER_01 раньше было 95, стало 10 мегабайт, working set в памяти, это мы все
805.96 809.68 SPEAKER_01 про hello world, конечно, говорим, грубо говоря, в working set был
809.68 816.16 SPEAKER_01 87, стал 40, startup time был 42 миллисекунды, стал 34, но и rps уменьшились,
816.16 821.68 SPEAKER_01 было 809 тысяч, стало 724, то есть процентов на 10 уменьшилось.
821.68 825.16 SPEAKER_01 Мы про это обсуждали, объясняли, почему так произошло, и
825.16 826.84 SPEAKER_01 что можно с этим сделать, потому что там есть ключик
826.84 831.44 SPEAKER_01 optimize for speed и optimize for size, можно сказать optimize for speed,
831.44 833.44 SPEAKER_01 тогда реквесты почти не упадут, но сайз немножко
833.44 834.44 SPEAKER_01 подрастет.
834.44 839.88 SPEAKER_01 Довольно немало было всяких разных нововведений вокруг
839.88 845.12 SPEAKER_01 AI, это и тензорная математика, новые примитивы и всякие
845.12 849.28 SPEAKER_01 разные SDK, я так понимаю, штуки, как там к JPT доступаться
849.28 851.48 SPEAKER_01 и так далее, особо останавливаться не будем, там чисто к дотнету
851.48 854.00 SPEAKER_01 имеет мало чего отношения, просто наборы библиотек.
854.00 860.96 SPEAKER_01 Blazor, это тоже довольно важный вех в восьмерке, потому
860.96 865.64 SPEAKER_01 что Blazor получил, во-первых, важный режим работы, который
865.64 868.08 SPEAKER_01 называет, я даже не знаю, если у него какое-то специальное
868.08 871.56 SPEAKER_01 название, я сходу найти не смог, но смысл заключается
871.56 874.08 SPEAKER_01 в том, что у вас приложение начинает работать как сервер
874.08 876.48 SPEAKER_01 сайт рендеринг, то есть вам быстро отдается сендеренная
876.48 880.04 SPEAKER_01 страничка к серверу, и первые какие-то интеракшены вы
880.04 883.60 SPEAKER_01 делаете как бы с сервер сайт приложением отрендеренным,
883.60 886.44 SPEAKER_01 а пока в бэкграунде там инициализируется всякая
886.44 888.60 SPEAKER_01 веб-ассембльная штука, и потом все это переключается
888.60 890.64 SPEAKER_01 на client-сайт рендеринг.
890.64 893.72 SPEAKER_01 Я слышал, что эта штука называется как автовыбор
893.72 894.72 SPEAKER_01 рендер-мода.
894.72 898.00 SPEAKER_01 Наверное, более лучше ничего не придумать.
898.00 900.44 SPEAKER_01 Я так понимаю, что там остается возможность миксовать
900.44 902.32 SPEAKER_01 это чуть ли не по компонентам, то есть у тебя может быть
902.32 905.76 SPEAKER_01 там основной Blazor работать как веб-ассембле, но какие-то
905.76 908.80 SPEAKER_01 сервер-сайт рендериться, что-то в таком духе я помню,
908.80 913.40 SPEAKER_01 но в общем тут надо изучать отдельно, сильно не смотрел.
913.40 916.44 SPEAKER_01 Плюс напоминаю, что в ассембле у нас дотнет исполняется
916.44 919.80 SPEAKER_01 в двух вариантах, он может исполняться либо интерпретироваться
919.80 922.64 SPEAKER_01 и тогда там используется по сути Mono Runtime, либо он
922.64 925.20 SPEAKER_01 может сразу компилироваться в нативный WASM-код.
925.20 929.40 SPEAKER_01 Так вот, в восьмерке появился, так скажем, такая, в дополнение
929.40 932.48 SPEAKER_01 к интерпретатору появилась штука под названием Jitterpreter,
932.48 934.88 SPEAKER_01 мы про нее тоже рассказывали, он такой типа, частично
934.88 937.04 SPEAKER_01 JIT, частично интерпретатор, для ускорения.
937.04 942.80 SPEAKER_01 Ну, еще у нас, конечно же, в garbage-коллекторе большие
942.80 943.80 SPEAKER_01 изменения.
943.80 949.32 SPEAKER_01 Это тот самый Dynamically, который DATAS, мы тоже про него рассказывали,
949.32 953.88 SPEAKER_01 или Dynamically Adapt, чего-то там Application Size.
953.88 954.88 SPEAKER_01 Вот.
954.88 958.00 SPEAKER_01 Смысл в том, что мы теперь в дотнет-процессе можем
958.00 960.32 SPEAKER_01 не задавать количество куч, точнее оно не будет задаваться
960.32 963.36 SPEAKER_01 автоматически, а будет считаться в динамике в
963.36 966.24 SPEAKER_01 зависимости от нагрузки на приложение там, то ли
966.24 968.40 SPEAKER_01 по количеству ядер, то ли можно меньшим количеством
968.40 970.88 SPEAKER_01 обойтись, более агрессивно их отдавать обратно в память
970.88 974.64 SPEAKER_01 системе, так что тоже надо смотреть, как это будет
974.64 977.56 SPEAKER_01 все себя вести, отключать, включать и репортить в Майкрософт,
977.56 980.28 SPEAKER_01 если все работает не так, как они предполагают.
980.28 984.12 SPEAKER_01 Скажи, теперь можно на собеседованиях на вопрос, сколько кучи
984.12 987.24 SPEAKER_01 в дотнете, отвечать, как бы неизвестно?
987.24 988.24 SPEAKER_01 Надо отвечать, зависит.
988.24 989.84 SPEAKER_01 Ты же знаешь правильный ответ.
989.84 990.84 SPEAKER_01 Да-да, зависит.
990.84 993.80 SPEAKER_01 Но я вам точно сказать не могу, это решается в рантайме.
993.80 996.76 SPEAKER_01 Это можно настроить, чтобы это было фиксировано через
996.76 999.20 SPEAKER_01 конфиг, то есть если вы про это все расскажете,
999.20 1002.40 SPEAKER_01 то я думаю, что… Короче, переслушайте наш выпуск
1002.40 1006.44 SPEAKER_01 про Dynamically Adaptation вот этот вот, и вы сможете пройти
1006.44 1009.00 SPEAKER_01 собеседование по современным garbage коллекторам, наверное,
1009.00 1011.12 SPEAKER_01 но это не точно, мы не пробовали.
1011.12 1016.72 SPEAKER_01 Значит, так, на самом деле было довольно много вот
1016.72 1019.20 SPEAKER_01 в этом вот главной статье про .NET 8 анонсов, но они
1019.20 1021.92 SPEAKER_01 у нас есть дальше в списке, поэтому я про них сейчас
1021.92 1024.24 SPEAKER_01 ничего рассказывать не буду.
1024.24 1027.36 SPEAKER_01 Скажу только вот что, что весь .NET Conf доступен на
1027.36 1030.28 SPEAKER_01 ютубе в виде плейлиста, он есть в шоуноутах, там
1030.28 1034.92 SPEAKER_01 сто два, по-моему, или около сотни видосиков, и там есть
1034.92 1038.00 SPEAKER_01 видосики как от ребят из Microsoft, где прямо вот такие
1038.00 1041.68 SPEAKER_01 анонсы, вот мы сделали такую штуку, смотрите какие нововведения
1041.68 1046.80 SPEAKER_01 там, не знаю, в Евкоре, а есть статьи, видео от, так
1046.80 1050.76 SPEAKER_01 скажем, внешних контрибьюторов, назовем это так, внешних
1050.76 1057.42 SPEAKER_01 ребят, которые просто показывают, что еще можно делать с
1057.42 1060.76 SPEAKER_01 какими-то разными штуками вокруг .NET 8, вот я на часть
1060.76 1063.96 SPEAKER_01 видео еще буду ссылаться дальше, и в частности, например,
1063.96 1067.56 SPEAKER_01 одно из видео, которое там было видно, в которое
1067.56 1070.40 SPEAKER_01 упоминается библиотечка или тул, который вообще
1070.40 1072.56 SPEAKER_01 нигде не светился до этого, или по крайней мере мы его
1072.56 1077.46 SPEAKER_01 пропустили, штука под названием Project Kyoto, это очередной новый
1077.46 1081.76 SPEAKER_01 OpenAPI client генератор, то есть по OpenAPI спеке умеет генерировать
1081.76 1082.76 SPEAKER_01 вам клиенты.
1082.76 1085.36 SPEAKER_01 Штука интересная, надо на нее посмотреть поближе,
1085.36 1088.68 SPEAKER_01 мы ее отложили на будущее обсуждение, так что в каком-нибудь
1088.68 1091.72 SPEAKER_01 из выпусков мы на нее посмотрим повнимательнее, попробуем
1091.72 1095.18 SPEAKER_01 и более подробно расскажем, вот, я к тому, что посмотрите
1095.18 1098.04 SPEAKER_01 на плейлист, хотя бы даже по заголовкам, увидите,
1098.04 1102.80 SPEAKER_01 что там есть не только то, что мы много раз уже обсуждали
1102.80 1106.08 SPEAKER_01 в течение этого года, да, с момента выхода семерки,
1106.08 1109.12 SPEAKER_01 но и какие-то совсем новинки, которых может быть вы не
1109.12 1113.64 SPEAKER_01 слышали, не знали, и может быть будет вам интересно,
1113.64 1119.36 SPEAKER_01 вот такой вот обзор, я бы сказал, а да, еще такой интересный
1119.36 1121.72 SPEAKER_01 момент, если вы вдруг хотите посмотреть, что поменялось
1121.72 1123.92 SPEAKER_01 между семеркой и восьмеркой, то у Майкрософта есть теперь,
1123.92 1126.16 SPEAKER_01 я не знаю, как давно она появилась, честно говоря,
1126.16 1131.68 SPEAKER_01 не смотрел, но в шоуноутах можно найти линк на github.net,
1131.68 1136.64 SPEAKER_01 .net core, репозиторий, где есть pull request, где есть div в
1136.64 1142.24 SPEAKER_01 виде markdown файликов всех изменений public API в .net, между
1142.24 1146.04 SPEAKER_01 семеркой и восьмеркой, то есть вот буквально markdown
1146.04 1148.42 SPEAKER_01 файлики, где как бы по каждой библиотечке, по каждой
1148.42 1153.40 SPEAKER_01 длельке, ну там нукет-пакету, я уже не помню, там написано,
1153.40 1156.48 SPEAKER_01 что вот здесь мы убрали класс, тут добавили класс,
1156.48 1158.68 SPEAKER_01 тут добавили конструктор, тут убрали, то есть такой
1158.68 1161.96 SPEAKER_01 прям полный API-див у них есть, можно посмотреть,
1161.96 1162.96 SPEAKER_01 если интересно.
1162.96 1168.16 SPEAKER_01 Ну, такие дела по общему .net, давай, наверное, дальше
1168.16 1169.16 SPEAKER_01 пойдем уже по деталям.
1169.16 1173.28 SPEAKER_01 Ну, давай, естественно, главная деталь на первом месте,
1173.28 1176.76 SPEAKER_01 в котором она есть, это новый C#, C# 12, посмотрим, что
1176.76 1177.76 SPEAKER_01 же в нем есть.
1177.76 1179.96 SPEAKER_01 Ну, наверное, в самом начале нужно сказать, что вы сильно
1179.96 1184.40 SPEAKER_01 не обольщались, релиз по фичам языка довольно слабенький,
1184.40 1186.44 SPEAKER_01 но что есть, то и обсудим.
1186.44 1189.80 SPEAKER_01 Во-первых, во-первых, что я тут упомянуть, это collection
1189.80 1194.12 SPEAKER_01 expression, они же выражение коллекций, что это было?
1194.12 1196.68 SPEAKER_01 До того, как у нас появился новый наш прекрасный релиз,
1196.68 1200.64 SPEAKER_01 мы с вами все всегда создавали некие наборы, некие коллекции,
1200.64 1203.00 SPEAKER_01 да, мы их могли создавать через дисты, через коллекшн,
1203.00 1206.12 SPEAKER_01 через инты, через спаны дженериковые, и всегда
1206.12 1209.44 SPEAKER_01 это было что-то со своим синтексисом, ну, как со
1209.44 1210.44 SPEAKER_01 своим.
1210.44 1211.64 SPEAKER_01 Например, чтобы создать лист, вам нужно было написать
1211.64 1214.90 SPEAKER_01 new list, и в фигурных скобочках можно было указать его
1214.90 1215.90 SPEAKER_01 элементы.
1215.90 1218.32 SPEAKER_01 Для арея практически то же самое, только вам нужно
1218.32 1221.60 SPEAKER_01 было написать new, там, интовый массив и в квадратных скобочках
1221.60 1224.00 SPEAKER_01 указать, что это массив, и в так же фигурных скобочках
1224.00 1225.42 SPEAKER_01 передать его компоненты.
1225.42 1227.20 SPEAKER_01 Стеколока практически точно так же, у него было
1227.20 1231.78 SPEAKER_01 ключевое столовое стеколок, две скобочки квадратненьких,
1231.78 1234.28 SPEAKER_01 и в фигурных скобках точно так же вы передавали все
1234.28 1235.28 SPEAKER_01 его элементы.
1235.28 1238.56 SPEAKER_01 И вот, товарищи смутило в том, что мы каждый раз
1238.56 1242.36 SPEAKER_01 вот этот new писали по-разному, там, у массива так, у листа
1242.36 1245.40 SPEAKER_01 так, у стеколока так, и поэтому, знаете, что они
1245.40 1246.40 SPEAKER_01 сделали?
1246.40 1247.40 SPEAKER_01 Правильно.
1247.40 1250.32 SPEAKER_01 Они поменяли синтексис, как мы передаем элементы
1250.32 1251.32 SPEAKER_01 в массив.
1251.32 1254.64 SPEAKER_01 То есть, там он раз раньше был весь в фигурных скобочках,
1254.64 1257.80 SPEAKER_01 а теперь все элементы передаются в квадратных скобочках.
1257.80 1261.28 SPEAKER_01 И благодаря этому новому синтексису в виде квадратных
1261.28 1265.04 SPEAKER_01 скобочков, они смогли избавиться от различного написания
1265.04 1268.44 SPEAKER_01 новых, от различного написания конструкторов.
1268.44 1270.88 SPEAKER_01 То есть, теперь вам достаточно просто открыть-закрыть
1270.88 1273.16 SPEAKER_01 квадратную скобочку и внутри перечислить элементы для
1273.16 1275.68 SPEAKER_01 того, чтобы компилятор сам вывел тот тип, который
1275.68 1277.68 SPEAKER_01 вы хотите присвоить переменной.
1277.68 1282.20 SPEAKER_01 То есть, если это массив, он преобразует вот эти квадратные
1282.20 1285.56 SPEAKER_01 скобочки к массиву, если к листу, то он их заимплементит
1285.56 1288.28 SPEAKER_01 как лист, и добавит все листы, и со стеколоком
1288.28 1290.42 SPEAKER_01 такая же точная ситуация.
1290.42 1294.08 SPEAKER_01 Интересно в этой парадигме то, что мы, во-первых, не
1294.08 1297.00 SPEAKER_01 только указываем тип, он компилятором выводится,
1297.00 1300.36 SPEAKER_01 во-вторых, компилятор также выводит отсюда размер, то
1300.36 1302.16 SPEAKER_01 есть больше вам не нужно там указывать специально
1302.16 1305.88 SPEAKER_01 размер, и компилятор избавляет вас от копирования данных.
1305.88 1307.84 SPEAKER_01 То есть, если раньше вам нужно было сначала создать
1307.84 1310.00 SPEAKER_01 какой-то временный буфер, а потом скопировать в настоящий
1310.00 1313.90 SPEAKER_01 массив, то теперь компилятор полностью подделает все
1313.90 1318.52 SPEAKER_01 операции с вот этим классом за вас в момент компиляции,
1318.52 1321.60 SPEAKER_01 и никакого копирования уже происходить не будет.
1321.60 1324.04 SPEAKER_01 Другим нововведением этого данного синтаксиса есть
1324.04 1328.10 SPEAKER_01 то, что мы можем теперь вот эти коллекции объединять.
1328.10 1331.16 SPEAKER_01 Если у вас есть, например, два массивчика, и вы хотите
1331.16 1333.28 SPEAKER_01 создать третий массив, который состоит из первых
1333.28 1335.94 SPEAKER_01 двух, для этого появился специальный синтаксис.
1335.94 1339.28 SPEAKER_01 Точно так же в квадратных скобочках вы указываете
1339.28 1342.40 SPEAKER_01 имена переменных, в которых хранятся вот эти два массива,
1342.40 1345.28 SPEAKER_01 и перед каждым именем переменного вы ставите две точечки.
1345.28 1349.68 SPEAKER_01 Вот эти две точечки обозначают, что надо эти массивы не
1349.68 1354.00 SPEAKER_01 засовывать как переменные сюда, а развернуть их, и
1354.00 1357.60 SPEAKER_01 итоговый массив уже будет состоять из двух контентов,
1357.60 1359.04 SPEAKER_01 вот первых двух этих переменных.
1359.04 1364.40 SPEAKER_01 На самом деле безумно неинтуитивный синтаксис, т.е. раскладывать
1364.40 1368.12 SPEAKER_01 массив двумя точечками перед ним, надо еще постараться
1368.12 1370.72 SPEAKER_01 поискать языки, где такая штука есть, по-моему, в Visual
1370.72 1373.36 SPEAKER_01 Basics мы там объединяли строки через точечку, вот это вот
1373.36 1374.76 SPEAKER_01 что-то сильно напоминает это.
1374.76 1378.56 SPEAKER_01 Но при этом я не могу сказать, что я могу хоть как-то придумать
1378.56 1381.16 SPEAKER_01 в принципе нормальный синтаксис, как бы вставить
1381.16 1383.12 SPEAKER_01 контент одного массива в другой.
1383.12 1386.52 SPEAKER_01 Ну, может быть, через плюсик, ты же контенируешь их все-таки?
1386.52 1389.32 SPEAKER_01 Ну не знаю, можно через плюсик, можно этими угловыми
1389.32 1392.56 SPEAKER_01 скобочками, так сказать, ну обратными, ну т.е. перед
1392.56 1396.00 SPEAKER_01 именем написать знак "больше", а после имени знак "меньше",
1396.00 1398.44 SPEAKER_01 ну типа как бы внутрь, я не знаю.
1398.44 1400.60 SPEAKER_01 Ну да, да может быть, но я боюсь, там придется весь
1400.60 1402.64 SPEAKER_01 дженерик этот компилятор переписывать после этого.
1402.64 1405.00 SPEAKER_01 Да, там я боюсь, что просто с этими двумя точечками
1405.00 1406.88 SPEAKER_01 понятно, скорее всего, почему они выбрали, потому что
1406.88 1409.28 SPEAKER_01 такая штука уже нужна для всяких паттерн-матчингов.
1409.28 1411.96 SPEAKER_01 Она же там используется вроде бы, да?
1411.96 1412.96 SPEAKER_01 Да, да.
1412.96 1413.96 SPEAKER_01 Там.
1413.96 1415.38 SPEAKER_01 Да, но она там никогда, по-моему, не используется
1415.38 1417.88 SPEAKER_01 для того, чтобы объединить какие-то коллекции.
1417.88 1420.36 SPEAKER_01 Не объединить, она там использовалась, если я правильно помню, как
1420.36 1422.48 SPEAKER_01 раз для того, чтобы показать, что вот в эту переменную
1422.48 1423.48 SPEAKER_01 заверни хвост.
1423.48 1424.48 SPEAKER_01 Т.е. для обратного.
1424.48 1429.96 SPEAKER_01 Т.е. типа хвост списка, например, т.е. ты указываешь там первый
1429.96 1433.00 SPEAKER_01 элемент, запятая две точечки и имя переменной, и после
1433.00 1434.52 SPEAKER_01 паттерн-матчинга у тебя в этой переменной останется
1434.52 1435.52 SPEAKER_01 хвост списка.
1435.52 1437.88 SPEAKER_01 Слушай, а в рейнджах разве не тоже самое используются?
1437.88 1439.56 SPEAKER_01 И в рейнджах тоже две точечки.
1439.56 1440.56 SPEAKER_01 Ну вот.
1440.56 1442.24 SPEAKER_01 Опять же, там не для того, чтобы их объединить.
1442.24 1443.24 SPEAKER_01 Ну да.
1443.24 1444.24 SPEAKER_01 Там немножко для другого.
1444.24 1447.28 SPEAKER_01 Зато парсер уже есть, чё, Reduce, там вот это всё.
1447.28 1448.28 SPEAKER_01 Не знаю.
1448.28 1450.40 SPEAKER_01 В общем… Нет, не отсюда, ладно.
1450.40 1452.92 SPEAKER_01 Для меня выглядит всё ещё безумно загадочно.
1452.92 1455.08 SPEAKER_01 Ну опять же, если показать это новому человеку, который
1455.08 1458.16 SPEAKER_01 приходит изучать .NET и сказать, что вот это значит штука,
1458.16 1461.32 SPEAKER_01 ну я практически гарантирую, что никто вам не ответит.
1461.32 1463.80 SPEAKER_01 Потому что безумно неинтуитивная вещь получилась.
1463.80 1469.00 SPEAKER_01 Также точно и большой вопрос к предыдущему пункту.
1469.00 1472.08 SPEAKER_01 Почему когда все .NETчики привыкли через фигурные
1472.08 1478.00 SPEAKER_01 скобочки записывать элементы, команда C# взяла и переделала
1478.00 1480.60 SPEAKER_01 фигурные скобочки на квадратные и сказала, теперь все будем
1480.60 1481.60 SPEAKER_01 писать так?
1481.60 1483.84 SPEAKER_01 Вот почему эту привычку-то менять?
1483.84 1486.60 SPEAKER_01 Ну там были какие-то аргументы про то, что если оставить
1486.60 1490.48 SPEAKER_01 фигурные, я читал про это, там были большие проблемы
1490.48 1492.56 SPEAKER_01 с однозначностью в некоторых сценариях.
1492.56 1496.36 SPEAKER_01 Их можно, вот эти самые коллекшн-экспрессионы можно было использовать в таких
1496.36 1499.96 SPEAKER_01 местах, где получалось неоднозначно, что это инициализатор или
1499.96 1502.24 SPEAKER_01 какая-нибудь там лямбда или еще что-нибудь.
1502.24 1504.60 SPEAKER_01 Поэтому пришлось использовать квадратные.
1504.60 1505.76 SPEAKER_01 Так было однозначно.
1505.76 1509.72 SPEAKER_01 Это они, их технические проблемы сваливают на кастомеров.
1509.72 1512.16 SPEAKER_01 Обычно это считается плохим подходом.
1512.16 1515.60 SPEAKER_01 Ну тут как посмотреть, если и компилятор не может разобраться
1515.60 1517.92 SPEAKER_01 что это, то возможно и читающий человек не сможет.
1517.92 1520.32 SPEAKER_01 Это понятно, что когда у тебя скобочка открылась
1520.32 1525.44 SPEAKER_01 1,2,3, тут тебе как бы и ясно видно, что это список.
1525.44 1528.04 SPEAKER_01 И компилятор тоже должен это, ну что-то не видишь,
1528.04 1529.32 SPEAKER_01 что ли, список, что ли.
1529.32 1531.52 SPEAKER_01 Вот, а вот если там что-то более сложное, особенно
1531.52 1533.44 SPEAKER_01 если ты туда какие-нибудь, не знаю, экспрессионы еще
1533.44 1537.16 SPEAKER_01 попихаешь, а не просто константы, то я боюсь, что
1537.16 1539.64 SPEAKER_01 там может даже уже и читать-то будет не очень удобно.
1539.64 1542.36 SPEAKER_01 Ну вставил там собаку или доллар перед фигурной
1542.36 1545.12 SPEAKER_01 скобкой, как это у нас положено, и все, явно обозначил, что
1545.12 1546.88 SPEAKER_01 это твой набор какой-то, какой-то сет.
1546.88 1550.56 SPEAKER_01 Не, ну это уже вот тоже будет, да, а давайте через это,
1550.56 1554.20 SPEAKER_01 в шарпе же, по-моему, да, коллекция через это квадратная
1554.20 1556.00 SPEAKER_01 скобка, вертикальная черта таким.
1556.00 1559.64 SPEAKER_01 Ну это уже квазицитирование-то, по-моему, а нет, это ареи,
1559.64 1561.96 SPEAKER_01 да, там листы отличаются от ареев, действительно.
1561.96 1564.76 SPEAKER_01 Вот, вот там начнется, знаешь, типа там на угловой скобочке
1564.76 1567.44 SPEAKER_01 вертикальная черта, а потом это двойная вертикальная
1567.44 1571.12 SPEAKER_01 черта, а потом присядь, а потом тройная, ну и т.д.
1571.12 1573.68 SPEAKER_01 Ну вот я не уверен, что как бы хуже вертикальная черта
1573.68 1576.00 SPEAKER_01 или двоеточие перед именем переменной.
1576.00 1579.36 SPEAKER_01 Ну фиг знает, ладно, давай, посмотрим, как это будет
1579.36 1582.84 SPEAKER_01 использоваться, давай так, и посмотрим на фидбэк потом.
1582.84 1584.60 SPEAKER_01 Ну посмотрим, да, ну опять же, менять уже ничего не
1584.60 1587.04 SPEAKER_01 будут, поэтому чего толку смотреть-то, будем использовать.
1587.04 1589.86 SPEAKER_01 В будущем команда планирует ещё расширять и добавлять
1589.86 1592.68 SPEAKER_01 к этому синтаксису, к этим экспрессионам что-то ещё,
1592.68 1595.44 SPEAKER_01 дополнительные возможности, естественно, раз ввели новый
1595.44 1597.48 SPEAKER_01 синтаксис, надо его пополнить и перезавязать.
1597.48 1600.56 SPEAKER_01 В частности, хотят так научиться инициализировать не только
1600.56 1604.28 SPEAKER_01 коллекции, но и дикшнери, где уже есть ключ значения,
1604.28 1607.00 SPEAKER_01 надо что-то похитрее выдумывать, и каким-то образом поддержать
1607.00 1608.00 SPEAKER_01 вар.
1608.00 1612.16 SPEAKER_01 Тоже идут как бы дискуссии, а как, потому что если вы
1612.16 1614.32 SPEAKER_01 просто указали фигурные скобки, то компилятор может
1614.32 1616.84 SPEAKER_01 вам вывести тип, только если вы явно слева указали
1616.84 1617.84 SPEAKER_01 этот тип.
1617.84 1620.68 SPEAKER_01 Если у вас вместо типа будет вар, то во что он транслирует
1620.68 1622.24 SPEAKER_01 эти фигурные скобки пока не очень ясно.
1622.24 1625.88 SPEAKER_01 А это же тебе там не система типа в ф-шарпе, он понятия
1625.88 1626.88 SPEAKER_01 не имеет.
1626.88 1630.24 SPEAKER_01 Ладно, пойдём дальше, следующее нововведение – это праймари
1630.24 1631.24 SPEAKER_01 конструктор.
1631.24 1636.96 SPEAKER_01 И кратко, что это такое, это теперь мы можем не только
1636.96 1639.52 SPEAKER_01 к рекордам делать основные конструкторы, но и к классам
1639.52 1640.52 SPEAKER_01 и структурам.
1640.52 1644.96 SPEAKER_01 Я напомню, что праймари конструктор – это когда
1644.96 1650.36 SPEAKER_01 вы при декларации самого типа можете указать переменные,
1650.36 1654.20 SPEAKER_01 то есть можете указать некие параметры у этого
1654.20 1660.00 SPEAKER_01 класса, и эти классы, и эти параметры, они как будто
1660.00 1661.32 SPEAKER_01 перейдут в конструктор.
1661.32 1664.64 SPEAKER_01 То есть, тут очень сложно объяснить абстрактно, потому
1664.64 1669.20 SPEAKER_01 что это поведение отличается у классов и у рекордов.
1669.20 1671.20 SPEAKER_01 Давайте вспомним, как это уже давно есть в рекордах.
1671.20 1673.48 SPEAKER_01 Вот в рекордах, когда вы задаете праймари конструктор,
1673.48 1677.64 SPEAKER_01 вы прямо возле типа перечисляете параметры, которые вы туда
1677.64 1678.64 SPEAKER_01 передаёте.
1678.64 1681.56 SPEAKER_01 И это можно сравнить с тем, что как будто вы эти параметры
1681.56 1684.48 SPEAKER_01 передали в конструктор настоящий, конструктор
1684.48 1687.32 SPEAKER_01 их присвоил публичным свойствам, и теперь рекорды через
1687.32 1689.08 SPEAKER_01 эти публичные свойства могут эти конструкторы
1689.08 1692.52 SPEAKER_01 каким-то образом с этими параметрами взаимодействовать.
1692.52 1699.24 SPEAKER_01 К сожалению, в классах и структурах поведение отличается,
1699.24 1700.96 SPEAKER_01 несмотря на то, что синтаксис тот же самый.
1700.96 1704.20 SPEAKER_01 То есть, вы объявляете какой-то класс, пишите класс, пробел
1704.20 1708.76 SPEAKER_01 имя класса, открываете кругленькие скобочки, и
1708.76 1711.28 SPEAKER_01 здесь перечисляете параметры, которые вы хотите передать
1711.28 1713.44 SPEAKER_01 в этот праймари конструктор.
1713.44 1716.80 SPEAKER_01 Под капотом компилятор вам создаёт конструктор,
1716.80 1720.08 SPEAKER_01 вот эти параметры принимает их в конструктор и создаёт
1720.08 1723.64 SPEAKER_01 приватные филды, то есть, приватные поля.
1723.64 1730.48 SPEAKER_01 И эти поля вы можете использовать в различных методах, свойствах,
1730.48 1732.84 SPEAKER_01 где-то ещё внутри этого класса.
1732.84 1735.80 SPEAKER_01 Вот самое главное отличие, то есть, синтаксис одинаковый,
1735.80 1737.80 SPEAKER_01 как я уже сказал, самое главное отличие в имплементации,
1737.80 1741.60 SPEAKER_01 что у нас в рекордах создаются публичные свойства, а в
1741.60 1744.76 SPEAKER_01 классах и структурах создаются приватные филды.
1744.76 1748.12 SPEAKER_01 То есть, теперь, когда вы создаете приватный конструктор
1748.12 1750.44 SPEAKER_01 или когда используете приватный конструктор, вам нужно
1750.44 1752.96 SPEAKER_01 чётко понимать, к чему вы его пишите, к рекорду или
1752.96 1753.96 SPEAKER_01 к классу.
1753.96 1756.24 SPEAKER_01 На самом деле, это очень сильно вводит в заблуждение,
1756.24 1758.36 SPEAKER_01 потому что, опять же, рекорды есть классовые, рекорды
1758.36 1764.04 SPEAKER_01 есть для структур, а тут ещё вот такое вот разное
1764.04 1765.04 SPEAKER_01 поведение.
1765.04 1768.60 SPEAKER_01 И тут ещё нужно отметить, что, когда вы создаёте
1768.60 1771.48 SPEAKER_01 праймари конструктор для классов, на самом деле это
1771.48 1775.48 SPEAKER_01 не настоящие филды, то есть это специальные филды,
1775.48 1778.32 SPEAKER_01 сгенерированные компилятором, помеченные мега-атрибутом,
1778.32 1782.10 SPEAKER_01 который делает так, что эти филды не являются членами
1782.10 1783.10 SPEAKER_01 этого класса.
1783.10 1784.56 SPEAKER_01 То есть, на самом деле, вы к этим филдам не можете
1784.56 1788.52 SPEAKER_01 обратиться через this, например, а вот просто заюзать их
1788.52 1791.04 SPEAKER_01 по имени, например, можно, то есть поведение немножко
1791.04 1792.04 SPEAKER_01 отличается.
1792.04 1794.68 SPEAKER_01 Во всех стандартных случаях, где вы ожидаете доступ
1794.68 1797.44 SPEAKER_01 к филдам, оно у вас будет работать, но какие-то извращённые
1797.44 1801.20 SPEAKER_01 случаи, которые, не знаю, включат в себя reflection, или
1801.20 1804.04 SPEAKER_01 обращение через this, или ещё что-то, вот там вы этих
1804.04 1805.04 SPEAKER_01 филдов не найдёте.
1805.04 1807.16 SPEAKER_01 Теперь же, почему было сделано такое поведение?
1807.16 1809.72 SPEAKER_01 Игорь, у тебя есть ответ на этот вопрос?
1809.72 1812.44 SPEAKER_01 Нет, ну причём не странно, через reflection это, наверное,
1812.44 1813.84 SPEAKER_01 найдётся, всё-таки я думаю, что они просто обычные
1813.84 1814.84 SPEAKER_01 филды.
1814.84 1816.12 SPEAKER_01 Как их ещё-то сделать?
1816.12 1820.20 SPEAKER_01 У них имена автосгенерированные, поэтому имени-то их не
1820.20 1821.20 SPEAKER_01 найдёшь через reflection.
1821.20 1823.64 SPEAKER_01 Ну то есть типа у них есть какие-то имена, которые
1823.64 1825.80 SPEAKER_01 компилятор, когда ты их просто используешь, будет
1825.80 1828.48 SPEAKER_01 транслировать вот в эти вот неудобоваримые внутренние
1828.48 1829.48 SPEAKER_01 имена в момент компиляции.
1829.48 1830.48 SPEAKER_01 Да-да.
1830.48 1832.88 SPEAKER_01 То есть это действительно реализовано на уровне или
1832.88 1836.36 SPEAKER_01 с помощью филдов, но там автосгенерированные пропертии,
1836.36 1838.80 SPEAKER_01 ой, автосгенерированные филды, поэтому вы их там,
1838.80 1840.56 SPEAKER_01 грубо говоря, к ним нельзя доступиться.
1840.56 1842.00 SPEAKER_01 Не знаю, честно.
1842.00 1843.64 SPEAKER_01 А они read-only же?
1843.64 1847.32 SPEAKER_01 Да, они read-only, они правят read-only филд, да.
1847.32 1848.32 SPEAKER_01 Интересно.
1848.32 1850.40 SPEAKER_01 Скорее всего, да, ради опять какой-то совместимости
1850.40 1853.00 SPEAKER_01 очевидной, что если вдруг у тебя в классе такие филды
1853.00 1855.20 SPEAKER_01 с такими полями уже есть, чтобы они не пересекались
1855.20 1856.20 SPEAKER_01 или какая-нибудь такая.
1856.20 1857.20 SPEAKER_01 Ну, может быть, может быть, да.
1857.20 1859.32 SPEAKER_01 Типа компиляторная магия всегда генерирует что-нибудь
1859.32 1860.32 SPEAKER_01 странное.
1860.32 1861.32 SPEAKER_01 Ну, возможно.
1861.32 1867.20 SPEAKER_01 Ну, опять что-то или не доделали, или не додумали, или перемудрили,
1867.20 1868.20 SPEAKER_01 мне кажется.
1868.20 1872.44 SPEAKER_01 Также в будущем, опять же, команда ждет фидбэка, и
1872.44 1874.72 SPEAKER_01 в будущем они планируют как-нибудь расширять эту
1874.72 1875.72 SPEAKER_01 штуку.
1875.72 1878.60 SPEAKER_01 Например, в частности, они хотят к вот этим параметрам,
1878.60 1883.76 SPEAKER_01 которые вы передаете в право-реконструктор, дать
1883.76 1886.32 SPEAKER_01 возможность пользователю добавить ключевое слово
1886.32 1887.32 SPEAKER_01 "read-only".
1887.32 1889.96 SPEAKER_01 Вот, Игорь, как ты думаешь, если мы добавим "read-only"
1889.96 1892.84 SPEAKER_01 к параметру, который передаем в право-реконструктор, что
1892.84 1893.84 SPEAKER_01 бы это могло значить?
1893.84 1896.08 SPEAKER_01 Он же уже и так "read-only".
1896.08 1897.08 SPEAKER_01 Да.
1897.08 1898.08 SPEAKER_01 Ну, два раза "read-only".
1898.08 1899.72 SPEAKER_01 А если добавить ключевое слово?
1899.72 1901.56 SPEAKER_01 Если два раза "read-only" применить, то что получится?
1901.56 1906.24 SPEAKER_01 Ну, как, нет, ну, минус на минус, плюс, будет "read-writeable".
1906.24 1907.24 SPEAKER_01 "Mutable".
1907.24 1908.24 SPEAKER_01 А вот и нет.
1908.24 1910.84 SPEAKER_01 Помнишь, я тебе говорил, что это "private read-only" филды?
1910.84 1915.44 SPEAKER_01 Вот если ты добавишь "read-only", то он станет "public property",
1915.44 1916.44 SPEAKER_01 не поверишь?
1916.44 1919.08 SPEAKER_01 Но "read-only" все равно, то есть типа с "init" видимо,
1919.08 1920.08 SPEAKER_01 "get init".
1920.08 1921.96 SPEAKER_01 А вот это пока еще никто не знает, пока пообещали
1921.96 1924.84 SPEAKER_01 только "property" добавлять, а "read-only" это "property" будет
1924.84 1926.40 SPEAKER_01 то ли с сеттером, то ли с публичным, вот это пока
1926.40 1927.40 SPEAKER_01 неизвестно.
1927.40 1930.36 SPEAKER_01 Было бы странно, если добавляя "read-only", ты бы добавил поле
1930.36 1932.52 SPEAKER_01 с "property" с публичным сеттером.
1932.52 1935.76 SPEAKER_01 Погоди, а то, что ты добавляешь "read-only" и у тебя филд превращается
1935.76 1937.56 SPEAKER_01 в "property" тебя не смущает?
1937.56 1942.24 SPEAKER_01 Нет, вполне нормальное поведение, почему бы нет?
1942.24 1945.92 SPEAKER_01 Ну мне кажется, что все-таки команда Микрософта где-то
1945.92 1946.92 SPEAKER_01 бредит.
1946.92 1949.88 SPEAKER_01 Ну подожди, я так понимаю, что все-таки это пока только
1949.88 1950.88 SPEAKER_01 планы?
1950.88 1951.88 SPEAKER_01 Так и есть, это планы.
1951.88 1954.04 SPEAKER_01 А, ну еще 20 раз поменяют.
1954.04 1957.48 SPEAKER_01 Да-да, я бы надеялся, если бы мы говорили с тобой года
1957.48 1960.72 SPEAKER_01 три назад, но вот глядя на этот релиз, что вошло
1960.72 1963.12 SPEAKER_01 как бы сюда, с какими костылями оно залезло, я думаю, что
1963.12 1964.12 SPEAKER_01 ничего не меняют.
1964.12 1966.60 SPEAKER_01 Они как в первом этапе как бы предложили полную чушь,
1966.60 1968.20 SPEAKER_01 но вот так они ее до релиза и протаскивают.
1968.20 1972.74 SPEAKER_01 Ну ладно, будем ждать девятку с нетерпением, 9.net в смысле
1972.74 1973.74 SPEAKER_01 и 13.c#.
1973.74 1977.36 SPEAKER_01 Ну будем следить еще в течение года, давай еще есть нововведение
1977.36 1980.06 SPEAKER_01 прекрасное, называется "alias any type", т.е. псевдонимы
1980.06 1983.30 SPEAKER_01 для любого типа, ну это, мне кажется, наверное, самое
1983.30 1987.36 SPEAKER_01 полезное из всего нашего c#, это мы теперь, раньше
1987.36 1991.24 SPEAKER_01 мы могли использовать ключевое слово "using" для того, чтобы
1991.24 1996.56 SPEAKER_01 подключить namespaces или заиспользовать какое-нибудь большое написание,
1996.56 1998.48 SPEAKER_01 какого-то типа внутри одного файлика.
1998.48 2000.88 SPEAKER_01 Тоже часто бывает полезно, особенно если у вас конфликты
2000.88 2004.44 SPEAKER_01 идут по названиям, то вы можете явно уточнить, какой
2004.44 2008.76 SPEAKER_01 именно тип вы используете, с какого именно namespace.
2008.76 2011.00 SPEAKER_01 Довольно полезная штука была.
2011.00 2013.76 SPEAKER_01 Вот теперь ее усилили и расширили, теперь в этот
2013.76 2017.88 SPEAKER_01 "using" можно написать абсолютно любой тип, который вы хотите
2017.88 2019.96 SPEAKER_01 просто заиспользовать в вашем приложении.
2019.96 2024.44 SPEAKER_01 Например, можно сделать "using int array =" и присвоить
2024.44 2028.40 SPEAKER_01 ему объявить int array, и везде, где вы в вашем коде будете
2028.40 2032.72 SPEAKER_01 использовать имя int array, туда будет поставляться
2032.72 2033.72 SPEAKER_01 настоящий массив.
2033.72 2035.88 SPEAKER_01 То есть, насколько я понимаю, это прямо делается в инлайне,
2035.88 2038.44 SPEAKER_01 никакой магии runtime здесь нет, здесь прямо компилятор
2038.44 2039.72 SPEAKER_01 инлайнит вам эту структуру.
2039.72 2042.32 SPEAKER_01 Это очень полезно, например, для tuples, когда у вас там
2042.32 2045.44 SPEAKER_01 есть tuple, который возвращает два значения, в общем вы
2045.44 2049.68 SPEAKER_01 можете обозвать его "point", например, и этот "point" уже
2049.68 2052.08 SPEAKER_01 использовать везде в своем коде.
2052.08 2054.34 SPEAKER_01 Весьма удобно, опять же, у вас есть именованный
2054.34 2056.72 SPEAKER_01 tuple, он везде используется, при этом не надо создавать
2056.72 2058.88 SPEAKER_01 никаких рекордов, опять же, рекорды в наше время
2058.88 2061.24 SPEAKER_01 создать довольно легко одной строчкой, поэтому
2061.24 2065.96 SPEAKER_01 может быть выгода не такая большая, как была до их
2065.96 2066.96 SPEAKER_01 использования.
2066.96 2071.48 SPEAKER_01 Также можно использовать unsave pointers, ну это опять
2071.48 2073.56 SPEAKER_01 же для каких-то узких извращенцев.
2073.56 2079.88 SPEAKER_01 И хотелось бы отметить, что кажется ни одна фича
2079.88 2083.88 SPEAKER_01 в этом релизе не обойдется без маленького "но", она
2083.88 2087.24 SPEAKER_01 конечно называется alias "any type", но кажется, что там
2087.24 2088.72 SPEAKER_01 есть все-таки "но".
2088.72 2092.04 SPEAKER_01 Ну, да-да, она "any", но не для всех, некоторые тайпы
2092.04 2095.80 SPEAKER_01 более "any", чем другие, например, есть небольшой нюанс с
2095.80 2100.00 SPEAKER_01 nullable reference types, вот смотрите, вы можете в принципе объявить
2100.00 2103.96 SPEAKER_01 нормальный nullable value type, но при этом у вас будут
2103.96 2107.20 SPEAKER_01 проблемы при объявлении nullable reference type, то есть
2107.20 2111.80 SPEAKER_01 допустим вы можете объявить, что x = int nullable, это нормально,
2111.80 2114.52 SPEAKER_01 везде, где будете подставлять x, там будет nullable int подставляться.
2114.52 2119.80 SPEAKER_01 Вы можете легко объявить и x = list от string nullable, то есть
2119.80 2123.40 SPEAKER_01 от нулябельных строк, тоже нормально, тоже будет работать,
2123.40 2128.16 SPEAKER_01 но вот вы не можете сделать using x = string nullable, т.е. стринг
2128.16 2130.52 SPEAKER_01 за знаком вопроса, вот это уже сделать нельзя.
2130.52 2135.32 SPEAKER_01 Я так понимаю, потому что nullable reference types, как таковые
2135.32 2138.88 SPEAKER_01 в runtime, они не существуют, это обычные типы с некими
2138.88 2141.40 SPEAKER_01 атрибутами, и тут они не смогли какие-то атрибуты
2141.40 2142.40 SPEAKER_01 на это на всё навесить.
2142.40 2143.40 SPEAKER_01 Интересно.
2143.40 2144.92 SPEAKER_01 И компилятор почему-то не смог разобраться во время
2144.92 2146.32 SPEAKER_01 компиляции, что это такое.
2146.32 2150.64 SPEAKER_01 Интересно, а можно вот если я сказал using x =, не знаю,
2150.64 2155.56 SPEAKER_01 list от string, потом где-нибудь использовать x знак вопросика?
2155.56 2158.44 SPEAKER_01 Да, так, скорее всего, можно.
2158.44 2159.44 SPEAKER_01 Интересно.
2159.44 2160.44 SPEAKER_01 Окей.
2160.44 2162.68 SPEAKER_01 Ну в принципе это помогает тогда, наверное, действительно
2162.68 2166.08 SPEAKER_01 как-то nullability для nullable reference types чуть более явнее
2166.08 2167.44 SPEAKER_01 это в коде видеть.
2167.44 2170.76 SPEAKER_01 Я бы тоже так подумал с первого раза, если бы у нас не было
2170.76 2172.96 SPEAKER_01 бы возможности присвоить сюда int nullable.
2172.96 2173.96 SPEAKER_01 Согласен.
2173.96 2176.24 SPEAKER_01 По идее, мы nullability хотим видеть независимо от того
2176.24 2178.60 SPEAKER_01 структуры это или класс, поэтому если бы они и для
2178.60 2182.72 SPEAKER_01 int, ну для value nullable не поддержали, это было бы логично, я с
2182.72 2183.72 SPEAKER_01 тобой согласен.
2183.72 2184.72 SPEAKER_01 Слушай, ну…
2184.72 2185.72 SPEAKER_01 Явно его задавали.
2185.72 2187.80 SPEAKER_01 Nullable value types давным-давно поддержаны, и у них там
2187.80 2190.40 SPEAKER_01 специальная магия runtime, и для них есть и компилятор,
2190.40 2192.36 SPEAKER_01 поэтому ладно уж, давай дальше.
2192.36 2195.44 SPEAKER_01 И вот видишь, мне как раз кажется, что nullable value types,
2195.44 2198.56 SPEAKER_01 они же разворачиваются в nullable класс настоящий,
2198.56 2200.72 SPEAKER_01 именно поэтому они смогли их в вьюзингах поддержать.
2200.72 2202.08 SPEAKER_01 А не структуру ли?
2202.08 2204.52 SPEAKER_01 Ну структуру, да-да, структуру, я имею в виду, что настоящий
2204.52 2207.92 SPEAKER_01 тип такой есть, а у nullable string вопросика нет никакой
2207.92 2210.52 SPEAKER_01 структуры или класса, который представляет nullable string.
2210.52 2211.52 SPEAKER_01 Ну да, это все ваши атрибуты.
2211.52 2212.52 SPEAKER_01 Там атрибутами все сделано, да-да-да.
2212.52 2214.84 SPEAKER_01 И вот поэтому у них, наверное, была какая-то проблема
2214.84 2215.84 SPEAKER_01 с этим.
2215.84 2216.84 SPEAKER_01 Ладно.
2216.84 2217.84 SPEAKER_01 Окей.
2217.84 2220.32 SPEAKER_01 Ну а главная фишка-то, что стало благодаря этому
2220.32 2221.60 SPEAKER_01 возможно делать?
2221.60 2224.18 SPEAKER_01 Теперь эти типы, ну как бы раньше alias к типу мы могли
2224.18 2225.18 SPEAKER_01 сделать всегда.
2225.18 2229.60 SPEAKER_01 Мы могли объявить его вверху класса и удачно этим пользоваться.
2229.60 2231.56 SPEAKER_01 С этим проблем там больших не было.
2231.56 2233.04 SPEAKER_01 Теперь главная фишка, что появилось?
2233.04 2235.56 SPEAKER_01 Теперь мы можем использовать этот юзинг внутри global
2235.56 2236.56 SPEAKER_01 юзинга.
2236.56 2238.62 SPEAKER_01 То есть я напомню, что у нас есть недавно фича, появилась
2238.62 2241.28 SPEAKER_01 это global юзинг, когда вы объявляете с ключевым
2241.28 2244.84 SPEAKER_01 словом global юзинг, как ни странно, какой-то namespace,
2244.84 2247.12 SPEAKER_01 и он начинает импортироваться автоматически во всех
2247.12 2249.80 SPEAKER_01 файлах, которые есть в этом проекте.
2249.80 2252.64 SPEAKER_01 Очень полезно бывает для каких-то системных namespaces,
2252.64 2256.04 SPEAKER_01 там system, system collection, system generic и так далее.
2256.04 2258.44 SPEAKER_01 В общем один раз их объявил и больше не мусоришь свой
2258.44 2259.44 SPEAKER_01 класс.
2259.44 2263.32 SPEAKER_01 Теперь мы можем юзинг новый тип сделать таким образом,
2263.32 2265.68 SPEAKER_01 чтобы он был глобалом, то есть чтобы он инклудился
2265.68 2267.64 SPEAKER_01 во все файлы данного проекта.
2267.64 2270.00 SPEAKER_01 То есть мы теперь можем объявить point там в одном
2270.00 2273.84 SPEAKER_01 месте через какой-нибудь tuple, и они будут автоматически
2273.84 2274.84 SPEAKER_01 везде доступны.
2274.84 2277.46 SPEAKER_01 Не знаю, хорошо это или плохо, потому что здесь
2277.46 2279.92 SPEAKER_01 очень легко переступить ту грань, когда мы перестанем
2279.92 2282.36 SPEAKER_01 создавать классы и везде будем объявлять вот эти
2282.36 2283.36 SPEAKER_01 юзинг алиасы.
2283.36 2287.40 SPEAKER_01 Но нужно за собой следить, чтобы все-таки код оставался
2287.40 2291.68 SPEAKER_01 восподержимым, читабельным, и при этом для каких-то полезных
2291.68 2294.00 SPEAKER_01 вещей такую штуку можно сделать, такую штуку можно
2294.00 2295.00 SPEAKER_01 объявить.
2295.00 2297.68 SPEAKER_01 Главное, что вы пока не можете сделать define true/false.
2297.68 2300.44 SPEAKER_01 Я думаю, да, это пока.
2300.44 2303.60 SPEAKER_01 Default lambda параметр, то есть раньше мы с вами умели
2303.60 2306.76 SPEAKER_01 все всегда создавать лямбды и умели все создавать методы
2306.76 2309.96 SPEAKER_01 с дефолтными аргументами, когда у нас внутри метода
2309.96 2312.84 SPEAKER_01 вы можете указать дефолтное значение, но вот создавать
2312.84 2315.58 SPEAKER_01 лямбды с дефолтными аргументами, с дефолтными значениями
2315.58 2316.58 SPEAKER_01 мы не могли.
2316.58 2319.48 SPEAKER_01 В общем, теперь с этого релиза мы можем это сделать,
2319.48 2321.60 SPEAKER_01 то есть объявлять лямбду точно так же, как и в методах
2321.60 2324.72 SPEAKER_01 через равно, пишем ей какую-то там константу, и если мы
2324.72 2328.16 SPEAKER_01 при вызове лямбды константу не задали, то она подставляется.
2328.16 2330.24 SPEAKER_01 Все примитивно и ожидаемо.
2330.24 2334.12 SPEAKER_01 У них все равно щича какая-то очень нишевая, и я пока
2334.12 2335.96 SPEAKER_01 не могу придумать, зачем она нужна, но она, наверное,
2335.96 2336.96 SPEAKER_01 где-то пригодится.
2336.96 2339.44 SPEAKER_01 Слушай, ну зачем тебе дефолтные методы в методах, дефолтные
2339.44 2342.68 SPEAKER_01 вэлли нужны в методах, наверное, для того же самого, чтобы
2342.68 2345.20 SPEAKER_01 не повторять какие-то по дефолту разумные какие-то
2345.20 2346.20 SPEAKER_01 вещи.
2346.20 2347.20 SPEAKER_01 Ну, может быть, может быть.
2347.20 2348.20 SPEAKER_01 Типа передать лямбду.
2348.20 2350.20 SPEAKER_01 Если у тебя есть лямбда, которая делает инкремент,
2350.20 2353.84 SPEAKER_01 то обычно ты в 99% случаях хочешь инкремент на 1.
2353.84 2357.00 SPEAKER_01 Вот этот 1 можно сделать как дефолт вэлли, но иногда
2357.00 2358.00 SPEAKER_01 хочешь перекрыть.
2358.00 2360.24 SPEAKER_01 Я не знаю, мне казалось, что лямбду я практически
2360.24 2363.36 SPEAKER_01 всегда задаю в среднем, когда мне нужно что-то куда-то
2363.36 2366.28 SPEAKER_01 передать, и в большинстве случаев я делаю ее под
2366.28 2368.44 SPEAKER_01 ту сигнатуру, куда мне это нужно передать.
2368.44 2371.36 SPEAKER_01 Не, я с тобой согласен, что на практике это безумно
2371.36 2372.36 SPEAKER_01 редкий случай.
2372.36 2374.36 SPEAKER_01 Я тоже на практике почти никогда этого не хотел.
2374.36 2375.36 SPEAKER_01 Вот.
2375.36 2377.24 SPEAKER_01 Ну, наверное, где-то кто-то захотел, и в общем было
2377.24 2380.68 SPEAKER_01 дешево сделать, плюс полнота языка, вот это все, ну окей,
2380.68 2381.68 SPEAKER_01 не мешает.
2381.68 2383.36 SPEAKER_01 Да, и у тебя там нету несколько тысяч открытых как бы
2383.36 2385.92 SPEAKER_01 ишисов, когда люди просят годами добавить какой-нибудь
2385.92 2387.48 SPEAKER_01 синтаксис нормальный.
2387.48 2388.48 SPEAKER_01 Это всякая фигня.
2388.48 2390.84 SPEAKER_01 Несколько тысяч минус один, импровмент, импровмент,
2390.84 2391.84 SPEAKER_01 что ты.
2391.84 2394.36 SPEAKER_01 Бесполезный вообще, абсолютно бесполезный.
2394.36 2396.80 SPEAKER_01 Ладно, давай, следующая полезная фича.
2396.80 2399.80 SPEAKER_01 О, следующие две фичи мега полезные, сейчас я вам о
2399.80 2401.56 SPEAKER_01 них расскажу, по крайней мере их название.
2401.56 2405.64 SPEAKER_01 Это refreadonly параметр, это специальный способ передачи
2405.64 2408.48 SPEAKER_01 аргумента в метод, когда вы не хотите модифицировать
2408.48 2416.48 SPEAKER_01 аргумент, но при этом вы еще и хотите получить локейшн
2416.48 2418.92 SPEAKER_01 точки в памяти, где этот аргумент находится, да,
2418.92 2420.76 SPEAKER_01 т.е. вам нужно ссылку по сути получить, ссылку, и
2420.76 2423.76 SPEAKER_01 при этом вам ее не надо модифицировать.
2423.76 2427.28 SPEAKER_01 Это очень похоже на in параметр, ты часто пользовался in параметрами
2427.28 2428.28 SPEAKER_01 вообще?
2428.28 2429.28 SPEAKER_01 Никогда.
2429.28 2431.72 SPEAKER_01 Хорошо, тогда я тебе расскажу про другую мега крутую
2431.72 2435.92 SPEAKER_01 штуку, это называется inline arrays, встроенные массивы,
2435.92 2441.96 SPEAKER_01 которая позволяет безопасным образом сделать memory buffer,
2441.96 2447.40 SPEAKER_01 и это memory buffer в виде inline массива, который является
2447.40 2450.84 SPEAKER_01 структурой с фиксированным размером, и это помогает
2450.84 2454.40 SPEAKER_01 вызывающему коду манипулировать блоками памяти, используя
2454.40 2455.40 SPEAKER_01 staccalog.
2455.40 2458.20 SPEAKER_01 Если бы я не знал, что это за фича, ничего бы не понял
2458.20 2460.52 SPEAKER_01 из объяснения, честно тебе скажу.
2460.52 2463.84 SPEAKER_01 Вот и я объясняю, а практически ничего не понял, и поэтому
2463.84 2465.88 SPEAKER_01 у нас есть специальный выделенный человек для
2465.88 2468.84 SPEAKER_01 таких вещей, который, надеюсь, слушателю объяснит более
2468.84 2471.36 SPEAKER_01 понятно, он специализируется на производительности,
2471.36 2472.36 SPEAKER_01 может быть это легче.
2472.36 2474.20 SPEAKER_01 И это Евгений Пешков, привет Женя.
2474.20 2475.20 UNKNOWN Привет.
2475.20 2479.48 SPEAKER_01 Слушай, объясни вот эту вот штуку, которая ref readonly,
2479.48 2482.96 SPEAKER_01 это она для чего вообще нужна и полезна ли на практике?
2482.96 2488.64 SPEAKER_01 Ну, вообще эта фича довольно спорная, на мой взгляд,
2488.64 2494.20 SPEAKER_01 и появилась она в дотнете из-за того, что когда добавляли
2494.20 2499.28 SPEAKER_01 in параметры и readonly структуры, немного прогадали, как
2499.28 2501.40 SPEAKER_01 это будет использоваться.
2501.40 2508.40 SPEAKER_01 В C#, если я правильно помню, в версии 7.2 появились in параметры,
2508.40 2514.44 SPEAKER_01 их суть такая, туда можно передать структуру по ссылке,
2514.44 2519.88 SPEAKER_01 но доступную только на чтение, в отличие от ref параметров,
2519.88 2520.88 SPEAKER_01 которые всегда были.
2520.88 2523.96 SPEAKER_01 Какая проблема решается, то, что если у нас структура
2523.96 2528.84 SPEAKER_01 большая, то при передаче ее в метод надо копировать,
2528.84 2532.76 SPEAKER_01 и на вот это копирование на стэке тратится лишнее
2532.76 2538.24 SPEAKER_01 время, будет чуть хуже перформанс, поэтому придумали фичу
2538.24 2542.52 SPEAKER_01 — передавать структуры по ссылке, но доступной
2542.52 2546.16 SPEAKER_01 только на чтение, чтобы семантика оставалась точно
2546.16 2550.52 SPEAKER_01 такой же, как при передаче структуры без каких-либо
2550.52 2555.36 SPEAKER_01 модификаторов по значению, но при этом без этого дополнительного
2555.36 2556.36 SPEAKER_01 копирования.
2556.36 2560.56 SPEAKER_01 Люди, которые пришли из C, наверное, смахнули слезу,
2560.56 2562.44 SPEAKER_01 вспомнив, что там очень много таких операций как
2562.44 2565.52 SPEAKER_01 раз, поэтому там референсы — это такие первоклассные
2565.52 2567.40 SPEAKER_01 элементы, которые живут в языке уже давно.
2567.40 2573.32 SPEAKER_01 Ну да, там можно любой тип передавать как по ссылке,
2573.32 2575.68 SPEAKER_01 так и по значению, как захочется.
2575.68 2579.64 SPEAKER_01 C# тоже постепенно приближается к вот этому миру, к хайперформансу.
2579.64 2581.68 SPEAKER_00 Кажется, что да.
2581.68 2585.00 SPEAKER_01 Отлично, так, и в общем, IN — INWELLY, ну и кажется по
2585.00 2587.92 SPEAKER_01 описанию, что REFREDONLY — это то же самое, что и IN.
2587.92 2589.76 SPEAKER_01 Чем они отличаются?
2589.76 2597.04 SPEAKER_01 Отличие IN от REFREDONLY в том, что IN принимает как так
2597.04 2600.12 SPEAKER_01 называемое L-вэлью, так и R-вэлью.
2600.12 2606.44 SPEAKER_01 Эта терминология тоже пришла из мира C, и она используется
2606.44 2609.68 SPEAKER_01 в пропозеле про REFREDONLY параметры.
2609.68 2615.30 SPEAKER_01 И кратко так, L-вэлью — это какое-то значение, которое
2615.30 2620.48 SPEAKER_01 еще обладает местом в памяти, т.е. в терминах C# это переменная
2620.48 2625.00 SPEAKER_01 или поле, или ссылка на переменную, там поле, какой-то участок
2625.00 2626.00 SPEAKER_01 в памяти.
2626.00 2631.08 SPEAKER_01 А R-вэлью — это все остальные значения, но в этом контексте
2631.08 2634.52 SPEAKER_01 это те значения, которые можно куда-то присвоить.
2634.52 2640.96 SPEAKER_01 И в IN параметр можно передать как ссылку на переменную
2640.96 2644.04 SPEAKER_01 или поле, так и просто какое-то значение.
2644.04 2648.44 SPEAKER_01 И в некоторых случаях вот такая передача по значению
2648.44 2650.44 SPEAKER_01 кажется не очень осмысленной.
2650.44 2656.56 SPEAKER_01 Допустим, для методов класса Unsave, которые именно хотят
2656.56 2661.28 SPEAKER_01 обрабатывать значения, у которых есть какое-то конкретное
2661.28 2662.28 SPEAKER_01 место в памяти.
2662.28 2670.96 SPEAKER_01 Допустим, они могут ссылку на переменную одного типа
2670.96 2674.04 SPEAKER_01 представить как ссылку на переменную другого типа.
2674.04 2678.96 SPEAKER_01 Допустим, у нас есть ссылка на int, и мы хотим взять ее
2678.96 2683.76 SPEAKER_01 побитого и рассмотреть как переменную типа float.
2683.76 2688.12 SPEAKER_01 Или у нас есть long, мы хотим на него посмотреть как на
2688.12 2689.12 SPEAKER_01 double.
2689.12 2693.84 SPEAKER_01 И вот таким методом им хочется работать именно с значениями,
2693.84 2696.56 SPEAKER_01 у которых есть конкретное место в памяти, и для этого
2696.56 2699.48 SPEAKER_01 были придуманы как раз refreadonly параметры.
2699.48 2702.84 SPEAKER_01 Refreadonly параметры, в отличие от IN параметров, требуют,
2702.84 2706.64 SPEAKER_01 чтобы значение, которое в них передается, обязательно
2706.64 2710.28 SPEAKER_01 имело какое-то конкретное место в памяти.
2710.28 2715.32 SPEAKER_01 Туда нельзя передать просто какое-то значение.
2715.32 2719.92 SPEAKER_01 А вот дальше начинается интересно, потому что в
2719.92 2724.16 SPEAKER_01 нынешней версии C# решили сделать обратную совместимость
2724.16 2729.16 SPEAKER_01 для IN и refreadonly параметров, потому что в некоторых местах,
2729.16 2733.56 SPEAKER_01 где IN параметры не очень подходили, их все равно
2733.56 2738.04 SPEAKER_01 стали использовать, туда можно было передать просто
2738.04 2740.92 SPEAKER_01 значение, поэтому сейчас в refreadonly параметр тоже
2740.92 2744.36 SPEAKER_01 можно передать значение, а не ссылку.
2744.36 2747.84 SPEAKER_01 Хотя идея refreadonly как раз в том, чтобы туда значение
2747.84 2749.48 SPEAKER_01 передавать было нельзя.
2749.48 2753.88 SPEAKER_01 В нынешней версии, если так сделать, то будет warning,
2753.88 2758.40 SPEAKER_01 а в следующих версиях C#, насколько я понимаю, предполагается,
2758.40 2762.24 SPEAKER_01 что уже будет ошибка и refreadonly параметры будут работать
2762.24 2763.24 SPEAKER_01 полноценно.
2763.24 2766.74 SPEAKER_01 Тебе не кажется, что при такой небольшой как бы
2766.74 2769.72 SPEAKER_01 семантической составляющей, то есть IN и refreadonly действительно
2769.72 2772.76 SPEAKER_01 очень похожи, там очень в тонких моментах отличаются,
2772.76 2775.20 SPEAKER_01 у них синтаксический разрыв очень большой, то есть
2775.20 2778.52 SPEAKER_01 почему там к IN не добавили какой-нибудь readonly кейворд,
2778.52 2782.80 SPEAKER_01 а завели вот специально refreadonly, прям далеко-далеко.
2782.80 2786.12 SPEAKER_01 Здесь довольно забавно, кстати, то, что если мы хотим
2786.12 2792.36 SPEAKER_01 передать ссылку в refreadonly параметр, и у нас уже есть
2792.36 2798.12 SPEAKER_01 refreadonly ссылка, то мы её должны передавать при вызове метода,
2798.12 2802.32 SPEAKER_01 указывая ключевое слово IN, и здесь ещё больше возникает
2802.32 2805.92 SPEAKER_01 путаница между IN и refreadonly.
2805.92 2810.08 SPEAKER_01 Почему не добавили какой-то новый кейворд?
2810.08 2816.08 SPEAKER_01 Мне кажется, то, что сейчас разработчики языка C# всё
2816.08 2821.00 SPEAKER_01 ещё очень боятся сломать обратную совместимость
2821.00 2827.16 SPEAKER_01 с тем, что они добавят новое ключевое слово, и у пользователей
2827.16 2830.00 SPEAKER_01 где-то есть переменные, которые называются так
2830.00 2833.80 SPEAKER_01 же, как это ключевое слово, хотя недавно, насколько
2833.80 2838.92 SPEAKER_01 я помню, начали выдавать warning при использовании
2838.92 2842.62 SPEAKER_01 имён с маленькой буквы в тех местах, где они могут
2842.62 2846.80 SPEAKER_01 быть перепутаны с ключевыми словами.
2846.80 2850.12 SPEAKER_01 Ну да, что-нибудь такое надо сразу доработать.
2850.12 2855.52 SPEAKER_01 Ну и да, ещё, на самом деле, refreadonly — это не очень новая
2855.52 2862.44 SPEAKER_01 фича для C#, потому что раньше были refreadonly-переменные.
2862.44 2867.72 SPEAKER_01 Можно было объявить переменную как refreadonly, и в таком случае
2867.72 2873.08 SPEAKER_01 это будет ссылка, по которой значение нельзя изменять.
2873.08 2878.40 SPEAKER_01 Если, допустим, у нас вызывается какой-то метод на структуре,
2878.40 2881.64 SPEAKER_01 на которую ссылается refreadonly поле, если эта структура
2881.64 2885.90 SPEAKER_01 сама не readonly, то будет создаваться защитная копия, чтобы этот
2885.90 2888.72 SPEAKER_01 метод точно структуру не испортил.
2888.72 2894.96 SPEAKER_01 И получается то, что refreadonly на самом деле не добавили
2894.96 2899.04 SPEAKER_01 целиком в язык заново, а просто позволили делать
2899.04 2906.48 SPEAKER_01 не только refreadonly-переменные, refreadonly поля, но ещё и refreadonly
2906.48 2907.48 SPEAKER_01 параметры.
2907.48 2909.32 SPEAKER_01 Ну хорошо, это хоть как-то оправдывает.
2909.32 2912.16 SPEAKER_01 Ладно, давай перейдём ко второму чудному зверю,
2912.16 2913.64 SPEAKER_01 который у нас появился, это inline_arrays.
2913.64 2917.36 SPEAKER_01 Может ты знаешь, для каких ситуаций его можно использовать,
2917.36 2920.92 SPEAKER_01 и отсюда мы пойдём и попытаемся как-то оправдать синтаксис,
2920.92 2922.92 SPEAKER_01 с помощью которого вы его внедрили.
2922.92 2924.36 SPEAKER_01 Зачем эта структура нужна?
2924.36 2927.96 SPEAKER_01 Да, там такой необычный синтаксис, что надо объявить
2927.96 2935.00 SPEAKER_01 структуру с одним полем и навесить атрибут inline_array,
2935.00 2939.24 SPEAKER_01 сколько в этой структуре будет на самом деле элементов.
2939.24 2942.84 SPEAKER_01 То есть эта структура будет вести себя как массив.
2942.84 2949.52 SPEAKER_01 А идея здесь такая, что это нужно для двух вещей.
2949.52 2954.56 SPEAKER_01 Первое, для интеропа, второе, если мы хотим сэкономить
2954.56 2960.96 SPEAKER_01 на объектах, и эта фича позволяет нам объявить по сути обычный
2960.96 2966.84 SPEAKER_01 C-массив прямо внутри другой структуры, или на стэке.
2966.84 2972.36 SPEAKER_01 А это что, что где-то надо, где это применяется вообще?
2972.36 2976.20 SPEAKER_01 Сложно на самом деле представить, когда такая фича понадобится
2976.20 2981.80 SPEAKER_01 простому пользователю, языка C# разработчику, но
2981.80 2985.16 SPEAKER_01 вполне может понадобиться, если нам надо сделать интероп
2985.16 2991.52 SPEAKER_01 с C-кодом и передать туда структуру, содержащую внутри
2991.52 2997.12 SPEAKER_01 какой-то массив, или допустим, мне приходилось делать
2997.12 3000.84 SPEAKER_01 некоторое подобие inline_array у себя в библиотеке, когда
3000.84 3005.28 SPEAKER_01 я хотел, чтобы у меня были такие сегменты связанного
3005.28 3010.84 SPEAKER_01 списка, в каждом из сегментов хранится по 16 или 256 элементов.
3010.84 3013.64 SPEAKER_01 То есть мне не хотелось делать так, что вот у меня
3013.64 3017.64 SPEAKER_01 есть объект сегмент, и этот объект сегмент ссылается
3017.64 3021.64 SPEAKER_01 на массив в куче, я хотел, чтобы вот этот сегмент
3021.64 3025.76 SPEAKER_01 был одним объектом, прямо внутри которого находятся
3025.76 3029.68 SPEAKER_01 нужные мне поля в должном количестве.
3029.68 3036.16 SPEAKER_01 Хотя раньше это можно было написать, но мне приходилось
3036.16 3042.00 SPEAKER_01 для этого просто, условно, сорт-генератором делать
3042.00 3048.16 SPEAKER_01 набор полей, поле 0, поле 1, поле 2 и так далее до нужного
3048.16 3049.16 SPEAKER_01 мне количества.
3049.16 3057.28 SPEAKER_01 Inline_array вот эту логику упрощает и позволяет сделать это
3057.28 3059.08 SPEAKER_01 автоматически средствами языка.
3059.08 3062.04 SPEAKER_01 Я правильно понимаю, что оба этих нововведения, они
3062.04 3064.24 SPEAKER_01 не для простых людей, то есть простые люди никогда
3064.24 3065.24 SPEAKER_01 пользоваться не будут?
3065.24 3070.28 SPEAKER_01 Да, это исключительно нововведения, которые больше полезны
3070.28 3077.24 SPEAKER_01 самим разработчикам C# и .NET Runtime, ну и обычным пользователям
3077.24 3079.00 SPEAKER_01 в очень редких кейсах.
3079.00 3082.68 SPEAKER_01 Как ты считаешь, не превращается ли у нас уже тенденция к
3082.68 3085.64 SPEAKER_01 тому, что нам язык нужно делить на две части, одна
3085.64 3087.56 SPEAKER_01 часть для обычных смертных, которые будут использовать
3087.56 3090.24 SPEAKER_01 все, а другая специальная performance часть, может быть,
3090.24 3093.16 SPEAKER_01 которую мы делим какими-нибудь анализаторами для авторов
3093.16 3096.04 SPEAKER_01 фреймворков, библиотек и вообще из полных извращенцев.
3096.04 3101.92 SPEAKER_01 На самом деле мне так не кажется, потому что все
3101.92 3105.84 SPEAKER_01 фичи так или иначе полезны, единственное, что мне бы
3105.84 3111.96 SPEAKER_01 хотелось, чтобы язык развивался как-то более последовательно
3111.96 3116.32 SPEAKER_01 и продуманно, потому что refreadonly параметр - это как
3116.32 3120.44 SPEAKER_01 раз пример того, что когда добавляли in параметры,
3120.44 3122.40 SPEAKER_01 немного просчитались.
3122.40 3129.16 SPEAKER_01 Про inline-array был другой пропозал, как можно добавить поддержку
3129.16 3133.12 SPEAKER_01 inline-array, не делая вот этот костыль со структурой из
3133.12 3140.84 SPEAKER_01 одного поля, а как сделать такую поддержку inline-array
3140.84 3145.24 SPEAKER_01 с помощью расширения функциональности дженериков, чтобы можно
3145.24 3148.56 SPEAKER_01 было в качестве дженерик параметра использовать
3148.56 3154.08 SPEAKER_01 не только тип, но еще и константное значение.
3154.08 3157.76 SPEAKER_01 Но этот пропозал требовал довольно больших изменений
3157.76 3164.76 SPEAKER_01 в рантайме и появился очень поздно, когда inline-array уже
3164.76 3165.76 SPEAKER_01 были готовы.
3165.76 3169.32 SPEAKER_01 В итоге inline-array попали в язык, но возможно их когда-то
3169.32 3174.56 SPEAKER_01 удалят или заабслетят в пользу подхода с дженериками,
3174.56 3176.56 SPEAKER_01 если он окажется удачным.
3176.56 3181.16 SPEAKER_01 Ну и что меня еще удивило по поводу inline-array, когда
3181.16 3185.92 SPEAKER_01 я эту фичу прочитал в пропозале, я подумал, что это чисто
3185.92 3192.28 SPEAKER_01 компиляторная фича, то что я поставлю себе новый
3192.28 3198.28 SPEAKER_01 компилятор C#, уберу из своей библиотеки вот это нагромождение
3198.28 3202.60 SPEAKER_01 полей и красиво заменю это на один inline-array.
3202.60 3206.12 SPEAKER_01 Но оказалось то, что inline-array сделаны так, что для них
3206.12 3211.60 SPEAKER_01 нужна поддержка в рантайме и я могу пользоваться inline-array
3211.60 3214.76 SPEAKER_01 только в том случае, если у меня одновременно и C#
3214.76 3221.08 SPEAKER_01 12, последняя версия, и одновременно с этим runtime.net 8.
3221.08 3227.88 SPEAKER_01 На dotnet 7 таргете я уже даже использую C# 12, inline-array пользоваться
3227.88 3228.88 SPEAKER_01 не могу.
3228.88 3232.32 SPEAKER_01 Потому что это не какой-то сорс-генератор, не фича
3232.32 3236.08 SPEAKER_01 компилятора, а это фича еще и со стороны рантайма.
3236.08 3239.12 SPEAKER_01 Я не очень понял, почему они так сделали и для меня
3239.12 3243.76 SPEAKER_01 это снизило ценность фичи inline-array, потому что я все-таки
3243.76 3247.56 SPEAKER_01 хочу писать код, который будет работать на всех
3247.56 3250.96 SPEAKER_01 LTS-версиях, которые есть сейчас актуально.
3250.96 3254.20 SPEAKER_01 Да-да, действительно интересно почему.
3254.20 3257.12 SPEAKER_01 Хорошо, Жень, большое спасибо, что зашел, я напомню, что
3257.12 3259.60 SPEAKER_01 с нами был Евгений Пешко, если хотите больше интересной
3259.60 3261.76 SPEAKER_01 информации про performance, уже есть отличный блог
3261.76 3265.12 SPEAKER_01 в телеграме, поэтому подписывайтесь, не стесняйтесь, все, пока,
3265.12 3266.12 SPEAKER_01 пока.
3266.12 3267.12 SPEAKER_01 Спасибо.
3267.12 3268.12 SPEAKER_01 Пока.
3268.12 3269.12 SPEAKER_01 Пока.
3269.12 3272.48 SPEAKER_01 Ну, я надеюсь, что тем, кому это нужно, наверное, поняли,
3272.48 3276.16 SPEAKER_01 что это удобно, необходимо, а тем, кому это не нужно,
3276.16 3277.88 SPEAKER_01 поняли, что никогда вы этого не увидите, никогда
3277.88 3280.04 SPEAKER_01 вы этого использовать не будете, и поэтому забейте.
3280.04 3283.24 SPEAKER_01 Что еще появилось полезного?
3283.24 3287.16 SPEAKER_01 Полезного, мега полезного появился experimental attribute,
3287.16 3291.16 SPEAKER_01 это специальный атрибут, тут надо прежде всего отметить,
3291.16 3294.88 SPEAKER_01 что это еще не окончательная версия, потому что experimental
3294.88 3300.16 SPEAKER_01 атрибут, он экспериментальный, т.е. его добавили как превью
3300.16 3301.16 SPEAKER_01 некий.
3301.16 3303.08 SPEAKER_01 А он помечен сам собой.
3303.08 3307.44 SPEAKER_01 Я не знаю, я, если честно, не проверял, но не удивлюсь,
3307.44 3310.84 SPEAKER_01 т.е. это некое превью, которое может поменять имплементацию,
3310.84 3312.72 SPEAKER_01 может поменять название, все, что угодно может поменять.
3312.72 3314.68 SPEAKER_01 Так, что это за мега атрибут?
3314.68 3318.16 SPEAKER_01 Атрибут можно наложить на типы, мемберы, ассембли,
3318.16 3322.52 SPEAKER_01 вообще на все, что угодно, и это будет означать, что
3322.52 3328.36 SPEAKER_01 если код помечен как экспериментальным, то компиляторам будет выдаваться
3328.36 3329.36 SPEAKER_01 ошибка.
3329.36 3333.92 SPEAKER_01 Ошибка будет выдаваться до тех пор, пока тот код,
3333.92 3336.72 SPEAKER_01 который использует этот экспериментальный код,
3336.72 3340.24 SPEAKER_01 также не будет помечен атрибутом experimental, т.е. это сделано
3340.24 3343.60 SPEAKER_01 для того, чтобы некие экспериментальные фичи, которые вы юзаете
3343.60 3347.60 SPEAKER_01 в своем коде, были или явно подавлена эта ошибка, т.е.
3347.60 3350.28 SPEAKER_01 были или явно помечены, что я осознаю, что делаю,
3350.28 3354.00 SPEAKER_01 или код, который ее использует, тоже был бы помечен этим
3354.00 3358.28 SPEAKER_01 атрибутом, таким образом, чтобы все вызывающие методы,
3358.28 3360.56 SPEAKER_01 чтобы все вызывающие классы знали, что мы сейчас используем
3360.56 3363.24 SPEAKER_01 какую-то экспериментальную фигню, которая в любой момент
3363.24 3365.08 SPEAKER_01 может поменяться или может быть даже рухнуть.
3365.08 3369.24 SPEAKER_01 Т.е. чтобы более явно показать, это, знаешь, похоже на вот
3369.24 3373.10 SPEAKER_01 эти проталкивающие эксепшены, когда ты должен маркать
3373.10 3375.76 SPEAKER_01 свой классик специальным типом эксепшена, который
3375.76 3378.24 SPEAKER_01 тебе показывает, что он будет на самом верху лезть.
3378.24 3380.48 SPEAKER_01 Чект эксепшены, да, в джаве.
3380.48 3383.76 SPEAKER_01 Да-да, это чект эксепшены какие-то, и также не сильно
3383.76 3387.08 SPEAKER_01 понятно, чем он принципиально, практически, я имею в виду,
3387.08 3389.56 SPEAKER_01 будет отличаться от абсолета, который делал практически
3389.56 3390.56 SPEAKER_01 то же самое.
3390.56 3393.56 SPEAKER_01 Ну, может, тем, что тебе не надо будет удалять использование,
3393.56 3395.80 SPEAKER_01 а просто видеть явно, что это экспериментал, т.е.
3395.80 3397.68 SPEAKER_01 такая более широкая у него очередь спалена.
3397.68 3399.84 SPEAKER_01 Ну и то, что он эррор все-таки по дефолту выдает, абсолет
3399.84 3402.32 SPEAKER_01 же, по-моему, там можно в нем указать, выдавать
3402.32 3405.00 SPEAKER_01 это как вординг или как эррор, а этот сразу эррор.
3405.00 3407.40 SPEAKER_01 Ну да, но опять же, сделай абсолет с эррором, если
3407.40 3408.80 SPEAKER_01 тебе надо выдать, и будет эррор.
3408.80 3412.84 SPEAKER_01 Ну, опять же, он не проверит, он же тебе будет тогда всегда
3412.84 3416.60 SPEAKER_01 выдавать эррор, а тебе нужно не выдавать, если ты вызываешь,
3416.60 3418.92 SPEAKER_01 зная, что это такое, т.е. либо надо сопрессить.
3418.92 3422.28 SPEAKER_01 Насколько я помню, что абсолеты такая же точная семантика,
3422.28 3426.70 SPEAKER_01 если ты свой метод пометишь как абсолет, то ты можешь
3426.70 3428.56 SPEAKER_01 вызывать абсолетный код, и при этом у тебя не будет
3428.56 3429.56 SPEAKER_01 никаких эрроров.
3429.56 3431.68 SPEAKER_01 А могу я сборку пометить абсолетом?
3431.68 3432.68 SPEAKER_01 Вот это не знаю.
3432.68 3435.52 SPEAKER_01 Ну ладно, хорошо, за сопрессить-то можно экспериментал каким-нибудь
3435.52 3436.52 SPEAKER_01 там, сопресс-вординг?
3436.52 3437.52 SPEAKER_01 Или сопресс-эррор?
3437.52 3439.92 SPEAKER_01 Да, за сопрессить можно, более того, у каждого этого
3439.92 3441.64 SPEAKER_01 экспериментала есть свой уникальный айдишник, т.е.
3441.64 3444.68 SPEAKER_01 тебе не надо сопрессить абсолютно все эксперименталы,
3444.68 3446.04 SPEAKER_01 как было бы в случае абсолета.
3446.04 3448.52 SPEAKER_01 У тебя есть специальный айдишник, и ты можешь запрессить
3448.52 3449.92 SPEAKER_01 только вот этот эксперимент.
3449.92 3450.92 SPEAKER_01 Удобно.
3450.92 3451.92 SPEAKER_01 Ну ладно, нормально.
3451.92 3453.92 SPEAKER_01 Ну в принципе, почему нет на самом деле?
3453.92 3457.40 SPEAKER_01 Ну может быть, это позволит им чуть более активно выкатывать
3457.40 3461.12 SPEAKER_01 какие-нибудь экспериментальные опишки, не знаю, что-нибудь.
3461.12 3463.76 SPEAKER_01 И чтоб как бы все видели, что это код, который может
3463.76 3464.76 SPEAKER_01 поменяться.
3464.76 3465.76 SPEAKER_01 Ну да, может быть.
3465.76 3468.76 SPEAKER_01 Итак, самая глобальная, наверное, важная фича, но
3468.76 3471.68 SPEAKER_01 она в превью, поэтому мы не вынесли её в самые глобальные,
3471.68 3473.72 SPEAKER_01 это интерсепторы, конечно же.
3473.72 3476.52 SPEAKER_01 Интерсепторы мы не раз уже обсуждали в наших выпусках.
3476.52 3481.04 SPEAKER_01 Кратко напомню, что это возможность перехватить
3481.04 3485.04 SPEAKER_01 вызов метода и заоптимизировать его под конкретный вызов,
3485.04 3488.08 SPEAKER_01 т.е. учесть специфические аргументы, специфическое
3488.08 3490.68 SPEAKER_01 окружение, которое есть в том месте, где этот метод
3490.68 3491.68 SPEAKER_01 вызывается.
3491.68 3495.64 SPEAKER_01 И сгенерить на его основании что-то вот узкоспециализированное
3495.64 3498.48 SPEAKER_01 вместо какого-то абстрактного непонятного метода, который
3498.48 3500.64 SPEAKER_01 там может очень сильно тормозить.
3500.64 3503.00 SPEAKER_01 У вас есть возможность сгенерить что-то конкретное.
3503.00 3505.20 SPEAKER_01 Ну в общем случае, это просто перехват абсолютно любого
3505.20 3506.20 SPEAKER_01 метода.
3506.20 3508.84 SPEAKER_01 Я думаю, что эта фича вот как бы на том уровне, на
3508.84 3510.52 SPEAKER_01 котором она появилась, мы её уже обсуждали, но тут
3510.52 3512.96 SPEAKER_01 интересно, конечно, проследить за её развитием, поэтому
3512.96 3514.76 SPEAKER_01 мы о ней, скорее всего, увидим ещё не раз в следующем
3514.76 3515.76 SPEAKER_01 году.
3515.76 3518.40 SPEAKER_01 Ну и надо напомнить, надо напомнить, несмотря на
3518.40 3520.60 SPEAKER_01 то, что она экспериментал, она уже используется в
3520.60 3522.64 SPEAKER_01 продакшене, в Майкрософте, в нутнет-восьмом, внутри
3522.64 3523.64 SPEAKER_01 ASP.NET Core.
3523.64 3526.64 SPEAKER_01 Да, да, это ещё одна фишка Майкрософта, теперь она
3526.64 3530.08 SPEAKER_01 внутри себя использует фичи, которые не советуют
3530.08 3531.08 SPEAKER_01 другим.
3531.08 3533.28 SPEAKER_01 Ну, с другой стороны, это объяснимо, они-то внутри
3533.28 3535.50 SPEAKER_01 могут в следующий раз ASP.NET переписать, это внутренняя
3535.50 3539.56 SPEAKER_01 кухня ASP.NET, поэтому возьмут да перепишут, чего такого.
3539.56 3540.56 SPEAKER_01 Ну именно так.
3540.56 3543.84 SPEAKER_01 Опять же, вот это, в принципе, всё, что у нас завезли в
3543.84 3546.88 SPEAKER_01 язык, как я уже говорил, не густо, опять же, очень
3546.88 3549.36 SPEAKER_01 мало вещей, наверное, мы будем использовать на практике
3549.36 3553.04 SPEAKER_01 из этого всего, но что есть, то есть.
3553.04 3555.88 SPEAKER_01 Ну, справедливости ради, я тебе могу сказать, что
3555.88 3559.72 SPEAKER_01 я уже с трудом могу понять, какие фичи из, не знаю, 11
3559.72 3561.96 SPEAKER_01 C# вот так вот ты каждый день используешь, потому
3561.96 3565.68 SPEAKER_01 что их уже настолько, не знаю, не то что много, но
3565.68 3568.44 SPEAKER_01 вот как-то стирается эта грань, когда какую фичу
3568.44 3570.72 SPEAKER_01 внедрили, может быть, ещё за счёт того, что многие
3570.72 3573.24 SPEAKER_01 фичи внедряются постепенно, тот же pattern matching внедрялся
3573.24 3576.32 SPEAKER_01 на протяжении чего-то 5 релизов языка или как-то
3576.32 3577.32 SPEAKER_01 так.
3577.32 3579.36 SPEAKER_01 И поэтому, если раньше… Ну и продолжают ещё.
3579.36 3582.04 SPEAKER_01 Да, если ты раньше мог сказать, что link_u добавили в какой-то
3582.04 3584.92 SPEAKER_01 версии, какой-то, 3, не помню.
3584.92 3585.92 SPEAKER_01 3.5, наверное.
3585.92 3586.92 SPEAKER_01 3.5, по-моему, да.
3586.92 3591.08 SPEAKER_01 Вот, то анекдот на 3.5 язык, по-моему, всё-таки он, или
3591.08 3592.56 SPEAKER_01 он тоже тогда версионировался.
3592.56 3596.40 SPEAKER_01 Короче, я уже слишком старый, я не помню, вот, но смысл
3596.40 3599.32 SPEAKER_01 в том, что можно было сказать, вот версия, а сейчас как
3599.32 3602.08 SPEAKER_01 бы ну pattern matching, всё, вот тут чуть-чуть и здесь чуть-чуть,
3602.08 3605.00 SPEAKER_01 вот я использую pattern matching, который был залежен в 7-м
3605.00 3608.32 SPEAKER_01 и в 9-м C#, а вот в 8-м не использую, ну потому что мне не нужно
3608.32 3611.20 SPEAKER_01 было там, ну вот как-то странно сейчас.
3611.20 3615.56 SPEAKER_01 Вот, если вы так же, как и я, забываете, что когда
3615.56 3618.28 SPEAKER_01 было внедрено, в шоуноутах вот к этой новости как раз
3618.28 3623.52 SPEAKER_01 про C# есть ссылочка на очень удобную, по-моему, там png,
3623.52 3628.40 SPEAKER_01 где очень кратенько, буквально на одном экране впикнуто,
3628.40 3632.64 SPEAKER_01 как сказать, хронология внедрения фичей, как в язык,
3632.64 3635.80 SPEAKER_01 так и в рантайм в целом, вот, можно как раз посмотреть
3635.80 3639.40 SPEAKER_01 на всю историю C# идут на это, всё как когда добавлялось,
3639.40 3640.40 SPEAKER_01 в каких версиях.
3640.40 3642.08 SPEAKER_01 Мне кажется, причина в другом, мне кажется, потому что
3642.08 3646.52 SPEAKER_01 раньше добавлялись нормальные фичи, типа линку, дженерики,
3646.52 3650.04 SPEAKER_01 какие-нибудь вары, ну понятная вещь, как бы сразу переписываешь
3650.04 3653.68 SPEAKER_01 весь проект, сразу всё становится красивше и лучше, а сейчас
3653.68 3656.32 SPEAKER_01 внедряется какая-то непонятная муть, как бы какая-то непонятная
3656.32 3657.32 SPEAKER_01 мелочь.
3657.32 3659.00 SPEAKER_01 При том, что сказать, что у них нет проблем, они всё
3659.00 3662.28 SPEAKER_01 сделали, у них всё хорошо – нет, проблемы есть, запросы
3662.28 3663.28 SPEAKER_01 есть.
3663.28 3665.04 SPEAKER_01 Да нет, язык идеален, всё, что можно было, внедрили,
3665.04 3666.72 SPEAKER_01 теперь только такие мелочи всякие.
3666.72 3669.84 SPEAKER_01 Ну вот судя по тому, что они делают, это действительно
3669.84 3673.96 SPEAKER_01 так, это затронет там вряд ли даже 1% пользователя,
3673.96 3676.20 SPEAKER_01 а то, сколько там пользователей, например, discrimination union
3676.20 3678.36 SPEAKER_01 требует уже много десятилетий, вот это вообще никого не
3678.36 3679.36 SPEAKER_01 волнует.
3679.36 3682.00 SPEAKER_01 Ну или там другие примеры, таких можно кучу перевести,
3682.00 3684.84 SPEAKER_01 которые вот фишки, которые реально позволят вам быстренько
3684.84 3687.20 SPEAKER_01 и красивенько переписать весь проект и дальше наслаждаться
3687.20 3688.20 SPEAKER_01 жизнью.
3688.20 3691.08 SPEAKER_01 Ну вот нет, почему-то уже который релиз, мы страдаем
3691.08 3692.44 SPEAKER_01 без нужных вещей.
3692.44 3694.72 SPEAKER_01 Они берегут тебя от переписывания проекта.
3694.72 3697.62 SPEAKER_01 Я уж как-нибудь сам себя поперегу, пусть лучше фичи
3697.62 3698.62 SPEAKER_01 поставляют.
3698.62 3699.92 SPEAKER_01 А Microsoft заботится о тебе, заботится.
3699.92 3703.80 SPEAKER_01 Давай пойдём дальше и пойдём к следующей новости, это
3703.80 3704.80 SPEAKER_01 Entity Framework.
3704.80 3707.96 SPEAKER_01 Ну вот там команда работает, да, я знаю.
3707.96 3710.08 SPEAKER_01 Да, там команда работает, они отчитываются.
3710.08 3713.72 SPEAKER_01 Если вы помните, кстати, я вот не проверил в итоге,
3713.72 3716.12 SPEAKER_01 по-моему, этот же релиз они обещали, что в этом релизе
3716.12 3717.48 SPEAKER_01 мы пофиксим все баги.
3717.48 3720.24 SPEAKER_01 Да-да-да, было-было такое.
3720.24 3723.64 SPEAKER_01 Короче, по результатам они сказали, что они сделали
3723.64 3727.48 SPEAKER_01 117 инхансментов и 128 баг-фиксов.
3727.48 3730.60 SPEAKER_01 Слушай, нам цифры не интересны, нам интересны проценты,
3730.60 3731.60 SPEAKER_01 все или не все?
3731.60 3732.60 SPEAKER_01 Я не знаю, не проверял.
3732.60 3734.64 SPEAKER_01 Ну кажется, что в GitHub уже накидали новых, поэтому
3734.64 3735.64 SPEAKER_01 видимо не все.
3735.64 3738.84 SPEAKER_01 Ну я говорю, какое-то странное заявление было, Entity, и зачем
3738.84 3740.96 SPEAKER_01 непонятно, и к чему такие цифры.
3740.96 3742.92 SPEAKER_01 Не, ну слушай, можно проверить, может быть все, которые
3742.92 3745.60 SPEAKER_01 накиданы, они новее, чем релиз дот 0.7, и тогда это
3745.60 3748.24 SPEAKER_01 правда, все, которые были на момент релиза дот 0.7,
3748.24 3749.24 SPEAKER_01 все пофикшено.
3749.24 3752.16 SPEAKER_01 Да не, ну просто само утверждение странное, то есть наверняка
3752.16 3754.12 SPEAKER_01 же есть намного лучшие фичи, куда ты можешь потратить
3754.12 3756.48 SPEAKER_01 свое время, чем принципиально фиксить самую последнюю
3756.48 3757.48 SPEAKER_01 никому не нужную багу.
3757.48 3762.92 SPEAKER_01 Да, хотя интересно, по GitHub сложно проверить, пофикшены
3762.92 3765.80 SPEAKER_01 или просто закрыты, может быть, можно просто было
3765.80 3769.00 SPEAKER_01 закрыть, он фикс, что, настраиваешь бот, который закрывает
3769.00 3771.92 SPEAKER_01 все, что старше недели, там, неактивности, и все?
3771.92 3774.68 SPEAKER_01 Может, по pull-request привязанному хотя бы, хоть что-то там
3774.68 3777.16 SPEAKER_01 было, я не говорю, что это фикс, но хоть что-то.
3777.16 3780.40 SPEAKER_01 Не, ну можно, конечно, это кажется, что сложновато
3780.40 3781.40 SPEAKER_01 так сходу сделать.
3781.40 3782.40 SPEAKER_01 Ну ладно, не важно.
3782.40 3786.12 SPEAKER_01 На самом деле, конечно, вот эти 117 enhancements завезли
3786.12 3790.04 SPEAKER_01 довольно важные и интересные фичи, мы про них тоже говорили,
3790.04 3791.80 SPEAKER_01 не так часто, может быть, ни в каждом выпуске, ни
3791.80 3794.84 SPEAKER_01 в каждом превью, потому что команда Entity Framework не
3794.84 3799.68 SPEAKER_01 радует нас прям большими статьями о том, что же там,
3799.68 3800.68 SPEAKER_01 где зарелизили.
3800.68 3804.32 SPEAKER_01 Но практически про все штуки, которые здесь я сейчас
3804.32 3807.88 SPEAKER_01 перечислю, мы так или иначе говорили, либо они, ну,
3807.88 3810.96 SPEAKER_01 слишком уж детальны и технически, поэтому лучше почитайте
3810.96 3815.24 SPEAKER_01 это все в статье, чем я вам буду тут рассказывать
3815.24 3818.88 SPEAKER_01 в тихах SQL и linq выражения, и как они преобразуются
3818.88 3819.88 SPEAKER_01 в Expression Tree.
3819.88 3821.76 SPEAKER_01 Это и читать-то тяжело, а уж на слух воспринимать
3821.76 3822.76 SPEAKER_01 совсем сложно.
3822.76 3828.20 SPEAKER_01 Итак, из добавленного, это value-обжекты с использованием
3828.20 3831.88 SPEAKER_01 сложных типов Complex Types, речь идет про то, что раньше
3831.88 3835.80 SPEAKER_01 была такая концепция как Owned Object, то есть вы могли
3835.80 3839.92 SPEAKER_01 часть толп софт таблицы мапить в объект другой,
3839.92 3842.76 SPEAKER_01 который был вложен в объект, соответствующий основной
3842.76 3847.18 SPEAKER_01 таблице, но там были всякие, под капотом это все равно
3847.18 3850.14 SPEAKER_01 оставалось объектом с ключом, который просто совпадал
3850.14 3852.80 SPEAKER_01 с ключом основной таблицы, а сейчас можно делать честные
3852.80 3856.72 SPEAKER_01 value-обжекты, причем как структуры, так и классы.
3856.72 3860.24 SPEAKER_01 Примитивные коллекции, то есть если вы храните
3860.24 3864.12 SPEAKER_01 в базе или наоборот просто заводите в модельке к, например,
3864.12 3869.24 SPEAKER_01 поле property с типом лист от int, то теперь, если база
3869.24 3872.60 SPEAKER_01 поддерживает такое, то есть, например, в PostGru они
3872.60 3875.28 SPEAKER_01 вроде как готовы складывать это прямо в виде натурального
3875.28 3878.12 SPEAKER_01 PostGru массива, потому что PostGru поддерживает массивы,
3878.12 3881.60 SPEAKER_01 а в SQL Server это будет сложено в виде JSON, через запятую
3881.60 3885.20 SPEAKER_01 там перечисленные данные, хотя, кстати, про PostGru массивы
3885.20 3886.88 SPEAKER_01 не уверен, может быть, там надо для этого стандартный
3886.88 3888.84 SPEAKER_01 конвертер заиспользовать какой-то.
3888.84 3892.20 SPEAKER_01 Да, может, они сразу в PostGru JSON засунут в колонку, да
3892.20 3893.20 SPEAKER_01 и все.
3893.20 3895.36 SPEAKER_01 Ну да, в принципе, там тоже JSON хорошо поддержан, поэтому
3895.36 3902.40 SPEAKER_01 можно и в JSON, улучшили поддержку contains в запросах, улучшили
3902.40 3905.32 SPEAKER_01 как раз JSON column mapping, то есть там теперь с JSON-тиками
3905.32 3908.54 SPEAKER_01 работать гораздо удобнее, и они используют больше
3908.54 3912.08 SPEAKER_01 JSON-функций, если они недоступны в драйвере базы данных,
3912.08 3916.44 SPEAKER_01 добавились SQL Server hierarchy ID тип, добавили возможность
3916.44 3919.96 SPEAKER_01 работать примерно как даппер, то есть можно теперь выполнять
3919.96 3922.00 SPEAKER_01 то, что они называются raw SQL queries, то есть когда вы
3922.00 3926.54 SPEAKER_01 пишете там exec SQL, и для типов, которые вы не задали вообще
3926.54 3927.54 SPEAKER_01 как модель.
3927.54 3931.00 SPEAKER_01 Он сам там разберется, рефлексии, понятное дело, как, че, куда,
3931.00 3933.60 SPEAKER_01 какие колонки мапить, и смапит ваши типы, даже
3933.60 3935.44 SPEAKER_01 если вы их не добавляли в модель.
3935.44 3938.60 SPEAKER_01 Lazy loading улучшился, в том числе для случаев, когда
3938.60 3940.68 SPEAKER_01 вы используете запросы без трекинга, то есть если
3940.68 3943.84 SPEAKER_01 вы теперь сделаете какой-нибудь там ваш db-контекст точка
3943.84 3947.68 SPEAKER_01 что-нибудь as no-tracking, точка, там, where, что-нибудь, и внутри
3947.68 3949.96 SPEAKER_01 полученных сущностей есть коллекции, которые должны
3949.96 3952.38 SPEAKER_01 загрузиться через lazy loading, они загрузятся нормально.
3952.38 3958.44 SPEAKER_01 Можно теперь нормально получать доступ к сущностям
3958.44 3961.08 SPEAKER_01 вашим, которые траппиваются, если у вас включен трекинг,
3961.08 3965.24 SPEAKER_01 не только через primary ключик, но и через foreign ключ и всякие
3965.24 3966.24 SPEAKER_01 другие.
3966.24 3970.00 SPEAKER_01 У них есть еще так называемый alternate, альтернативный
3970.00 3971.00 SPEAKER_01 ключ.
3971.00 3973.32 SPEAKER_01 В общем, внутри это все работало, раньше это внутренняя кухня
3973.32 3975.40 SPEAKER_01 Entity Framework, они ее просто открыли наружу.
3975.40 3982.24 SPEAKER_01 Дальше есть некоторое количество улучшений разных всяких
3982.24 3986.80 SPEAKER_01 функций типа математики лучше поддерживается,
3986.80 3991.64 SPEAKER_01 можно задавать теперь sentinel values, это то, что называется,
3991.64 3994.56 SPEAKER_01 это не совсем дефолтные значения, это аналогии
3994.56 3997.44 SPEAKER_01 в каком-то смысле дефолтных значений, то есть какое
3997.44 4001.88 SPEAKER_01 значение внутри .NET новой пропертии считать аналогичным
4001.88 4006.46 SPEAKER_01 отсутствию значения, то есть ходите на вот по дефолту
4006.46 4010.28 SPEAKER_01 для reference типов, например, а для структур, например,
4010.28 4013.24 SPEAKER_01 не знаю, для int, в смысле для value типов, можно сказать,
4013.24 4016.12 SPEAKER_01 что sentinel value это -1, поэтому если вы туда присвоите
4016.12 4019.84 SPEAKER_01 -1 в это поле, оно не будет сохраняться вообще, а все
4019.84 4022.68 SPEAKER_01 остальное будет, ну и так далее.
4022.68 4025.72 SPEAKER_01 Много улучшений в execute update и execute delete, там с транзакциями
4025.72 4030.12 SPEAKER_01 всем добро, мы про это подробно рассказывали, инк, запросы,
4030.12 4032.80 SPEAKER_01 которые where что-нибудь, int что-нибудь тоже улучшили
4032.80 4036.06 SPEAKER_01 местами, они теперь заменяются на join, которые более оптимальны,
4036.06 4040.00 SPEAKER_01 можно доступаться до row versions в нормальном виде,
4040.00 4043.52 SPEAKER_01 ну и огромное количество всякого разного, как они
4043.52 4048.48 SPEAKER_01 называют minor stuff, или точнее не minor, а типа очень специфичного,
4048.48 4051.04 SPEAKER_01 то есть там много улучшений конкретно для mysql, конкретно
4051.04 4055.24 SPEAKER_01 для sql server, конкретно для postgres, в общем, посмотрите,
4055.24 4058.46 SPEAKER_01 там у них довольно неплохие заголовки всех тикетов,
4058.46 4061.76 SPEAKER_01 что по ним обычно можно понять, что делалось, поэтому их,
4061.76 4063.64 SPEAKER_01 кстати, относительно немного получается, то есть такое
4063.64 4067.44 SPEAKER_01 ощущение, что там команда не очень большая, ну и если
4067.44 4070.08 SPEAKER_01 посмотреть на основной рантайм, где там 1250+ только
4070.08 4073.72 SPEAKER_01 performance лучше, а не здесь 117 всего, грубо говоря, ну
4073.72 4078.72 SPEAKER_01 и 128 bugfixes, то есть всего там 250 в принципе коммитов.
4078.72 4080.68 SPEAKER_01 Ну у них и команда маленькая.
4080.68 4084.08 SPEAKER_01 Да, ну и они, кажется, что под одним как бы тикетом
4084.08 4087.64 SPEAKER_01 делают довольно много сразу, то есть если в рантайме
4087.64 4089.56 SPEAKER_01 принята штука, что если мы пилим большую фичу,
4089.56 4092.32 SPEAKER_01 мы заводим тикет внутри, заводим еще тикеты, ну как
4092.32 4095.64 SPEAKER_01 бы такой мета тикет со ссылками на другие тикеты, то здесь
4095.64 4098.72 SPEAKER_01 как бы вот у нас есть enhancement, мы под ним все пилим.
4098.72 4101.08 SPEAKER_01 У меня вот складывается такое ощущение.
4101.08 4105.36 SPEAKER_01 Короче вот, entity framework, ну как, развивается, продолжается,
4105.36 4108.12 SPEAKER_01 работает, становится быстрее, становится там auto-friendly
4108.12 4111.80 SPEAKER_01 потихонечку, вот это все, так что пользуемся, если
4111.80 4114.52 SPEAKER_01 вы пользуетесь entity framework, если вы пользуетесь dapper,
4114.52 4117.56 SPEAKER_01 посмотрите на новую фичу entity framework 8, возможно, вот
4117.56 4120.04 SPEAKER_01 это вот выполнение raw query будет вполне себе быстрым
4120.04 4123.76 SPEAKER_01 и хорошим, и тогда, может быть, например, можно отказаться
4123.76 4124.76 SPEAKER_01 от dapper.
4124.76 4129.08 SPEAKER_01 Ну да, я слышал по бенчмаркам, что entity framework прям полнотно
4129.08 4131.48 SPEAKER_01 и приблизился к dapper в этом плане, то есть если вы будете
4131.48 4133.40 SPEAKER_01 его использовать так же как и dapper, то скорость скорее
4133.40 4135.48 SPEAKER_01 всего у вас будет такая же точно, может быть даже
4135.48 4136.84 SPEAKER_01 в некоторых местах и получше.
4136.84 4139.80 SPEAKER_01 Ну просто я видел кейсы, когда использовался типа
4139.80 4143.48 SPEAKER_01 для там, ну в части логики используется entity framework,
4143.48 4145.12 SPEAKER_01 загрузки, сохранения, ну каких-то таких сложных
4145.12 4146.12 SPEAKER_01 сценариев.
4146.12 4148.88 SPEAKER_01 Когда нужно что-то загрузить, относительно просто или
4148.88 4151.08 SPEAKER_01 быстро из базы использовался dapper, вот теперь, может быть,
4151.08 4153.20 SPEAKER_01 можно на восьмерку просто перейти и все, целиком на
4153.20 4154.20 SPEAKER_01 entity framework.
4154.20 4157.64 SPEAKER_01 Ну и тут нужно еще упомянуть, что если для вас перформанс
4157.64 4160.44 SPEAKER_01 важен, то конечно же dapper это не ваш первый выбор,
4160.44 4162.68 SPEAKER_01 потому что из микрофреймворков сейчас dapper считается самым
4162.68 4164.72 SPEAKER_01 медленным, есть намного более быстрые фреймворки.
4164.72 4167.52 SPEAKER_01 Тоже посмотрите по бенчмаркете.
4167.52 4170.76 SPEAKER_01 Ну что, пойдем к следующей теме, мы конечно же не могли
4170.76 4174.16 SPEAKER_01 после entity framework пропустить ISP.NET Core, посмотрим, что у
4174.16 4176.52 SPEAKER_01 нас интересного в ISP.NET Core.
4176.52 4179.36 SPEAKER_01 Прежде всего, как сказал Игорь, это перформанс, перформанс,
4179.36 4180.36 SPEAKER_01 перформанс.
4180.36 4184.64 SPEAKER_01 Что же у нас там, 18% фасте на TakeEmpower.json бенчмарк и 24%
4184.64 4192.36 SPEAKER_01 на Fotion получается, а в ISP.NET добавилось еще очень
4192.36 4197.36 SPEAKER_01 много улучшений в плане поддержки native auto.
4197.36 4200.88 SPEAKER_01 Раньше native auto успешно поддерживался в консоли, а теперь он добрался
4200.88 4202.20 SPEAKER_01 для ISP.NET.
4202.20 4206.68 SPEAKER_01 Это довольно такая большая фича, потому что по причине,
4206.68 4210.32 SPEAKER_01 что в ISP.NET Core очень много рефлекшена изначально
4210.32 4211.32 SPEAKER_01 было.
4211.32 4213.16 SPEAKER_01 Ну то есть это вообще весь фреймворк, он по сути состоит
4213.16 4214.16 SPEAKER_01 из рефлекшена.
4214.16 4216.54 SPEAKER_01 Он сканирует ваши контроллеры, у контроллеров каким-то
4216.54 4219.16 SPEAKER_01 образом находит методы, из этих методов вычленяет
4219.16 4222.20 SPEAKER_01 роуты и по этим роутам как-то динамически запускает ваш
4222.20 4223.20 SPEAKER_01 код.
4223.20 4225.48 SPEAKER_01 То есть этот фреймворк вообще строился без оглядки на
4225.48 4227.86 SPEAKER_01 какой-то native auto.
4227.86 4232.28 SPEAKER_01 Поэтому то, что его перевели, в том, что было проделано
4232.28 4235.74 SPEAKER_01 огромное количество работы, этих маленьких тасочек,
4235.74 4237.34 SPEAKER_01 которые нужны были для того, чтобы реализовать
4237.34 4238.34 SPEAKER_01 их.
4238.34 4239.34 SPEAKER_01 Там было просто миллиарды.
4239.34 4243.36 SPEAKER_01 Итак, что же в результате мы получили?
4243.36 4245.84 SPEAKER_01 А в результате мы получили, что мы теперь можем ISP.NET
4245.84 4248.68 SPEAKER_01 Core приложение запускать в native auto.
4248.68 4253.56 SPEAKER_01 Это значит, что мы можем сделать self-contained application,
4253.56 4256.88 SPEAKER_01 то есть один-единственный экзешник полностью с native
4256.88 4260.60 SPEAKER_01 кодом, который абсолютно никак не зависит от того,
4260.60 4263.20 SPEAKER_01 какая версия .NET фреймворка проинсталлена в операционной
4263.20 4265.44 SPEAKER_01 системе и вообще, проинсталлена ли она вообще.
4265.44 4267.76 SPEAKER_01 То есть в этом может не быть.
4267.76 4272.36 SPEAKER_01 То есть это один native экзешник и мы получаем полный, не,
4272.36 4276.16 SPEAKER_01 не полный, ну ладно, мы получаем ISP.NET Core приложение.
4276.16 4279.44 SPEAKER_01 Благодаря тому, что это native auto, у нас уменьшился
4279.44 4282.20 SPEAKER_01 размер, это контейнеры уменьшили, уменьшился размер
4282.20 4285.80 SPEAKER_01 самого приложения на 78%, что повлияло и на размер
4285.80 4287.40 SPEAKER_01 контейнера, в том числе, о чем мы говорили чуть
4287.40 4288.40 SPEAKER_01 выше.
4288.40 4292.84 SPEAKER_01 Время старта, благодаря тому, что мы убрали JIT-компиляцию,
4292.84 4295.20 SPEAKER_01 которая происходит на старте, время старта увеличилось
4295.20 4296.20 SPEAKER_01 на 76%.
4296.20 4301.52 SPEAKER_01 Скорость старта, давай так, скорость старта увеличилась,
4301.52 4302.52 SPEAKER_01 стала лучше.
4302.52 4309.28 SPEAKER_01 Также точно уменьшилось потребление памяти на 37%,
4309.28 4312.96 SPEAKER_01 то есть native auto показывает очень хорошие результаты,
4312.96 4313.96 SPEAKER_01 очень хорошие цифры.
4313.96 4315.76 SPEAKER_01 Ну и самое главное, что вы теперь можете работать
4315.76 4318.56 SPEAKER_01 без заинсталлированного .NET абсолютно везде где
4318.56 4321.68 SPEAKER_01 угодно, потому что это полный бинарный чек нативный,
4321.68 4322.76 SPEAKER_01 без всяких компромиссов.
4322.76 4326.96 SPEAKER_01 Вот, и так, а теперь давайте же все-таки вернемся к этой
4326.96 4333.12 SPEAKER_01 сноске, но не все фичи ISP.NET Core, не все фичи поддержаны
4333.12 4335.68 SPEAKER_01 в native auto, потому что, как я уже сказал, это огромная
4335.68 4341.12 SPEAKER_01 просто работа, и поэтому она ведется очень выборочно.
4341.12 4344.44 SPEAKER_01 Мы берем компонент и переводим его с рефлекшена полностью
4344.44 4346.96 SPEAKER_01 на какие-то другие альтернативные средства.
4346.96 4349.72 SPEAKER_01 И вот так вот они сделали с каждым компонентиком.
4349.72 4352.64 SPEAKER_01 И именно в этом релизе товарищи сосредоточились
4352.64 4356.88 SPEAKER_01 на minimal API и gRPC, в общем они взяли полностью аспект
4356.88 4361.24 SPEAKER_01 minimal API и gRPC и перевели, перетестили, поддержали
4361.24 4363.12 SPEAKER_01 максимум возможностей, которые там есть.
4363.12 4366.88 SPEAKER_01 И вот эти две фичи там поддержаны абсолютно полностью.
4366.88 4370.44 SPEAKER_01 На самом деле переводить на native auto, как я уже сказал,
4370.44 4371.44 SPEAKER_01 очень сложно.
4371.44 4373.76 SPEAKER_01 В качестве примера можно привести, что вам нельзя,
4373.76 4376.64 SPEAKER_01 например, динамически загружать сборки, и вот если вы сами
4376.64 4380.80 SPEAKER_01 делаете код, который должен по вашим собственным желаниям
4380.80 4383.16 SPEAKER_01 использоваться в native auto приложении, в частности
4383.16 4386.26 SPEAKER_01 в новом подходе ISP.NET Core, вот вы должны тоже все эти
4386.26 4387.26 SPEAKER_01 требования соблюдать.
4387.26 4392.92 SPEAKER_01 Самые ключевые из них – это никаких assembly loading в динамике,
4392.92 4397.00 SPEAKER_01 вы не можете делать никакого генерации кода в рантайме,
4397.00 4399.98 SPEAKER_01 т.е. с помощью, например, reflection emitter, нельзя использовать
4399.98 4405.32 SPEAKER_01 C++ или CLI, вы должны поддерживать стриминг приложения, а для
4405.32 4407.50 SPEAKER_01 того, чтобы поддержать стриминг, у вас там еще есть куча
4407.50 4410.16 SPEAKER_01 реквайерментов, что нужно, чтобы это сделать.
4410.16 4412.84 SPEAKER_01 В частности, там нужно будет разметить свой код, нужно
4412.84 4415.80 SPEAKER_01 там какие-то убрать, опять же, рефлекшены, нужно очень
4415.80 4418.32 SPEAKER_01 много всего подготовить, чтобы ваше приложение поддерживало
4418.32 4419.32 SPEAKER_01 стриминг.
4419.32 4422.72 SPEAKER_01 И ваше приложение должно уметь компилироваться
4422.72 4425.96 SPEAKER_01 в один единственный файл – single file mod.
4425.96 4429.40 SPEAKER_01 Это тоже звучит довольно просто, но с некоторыми
4429.40 4432.28 SPEAKER_01 библиотеками есть все еще до сих пор проблемы, т.е.
4432.28 4434.40 SPEAKER_01 там тоже есть отдельный список реквайерментов,
4434.40 4436.24 SPEAKER_01 как сделать так, чтобы ваше приложение поддерживало
4436.24 4437.60 SPEAKER_01 single file mod.
4437.60 4443.20 SPEAKER_01 В общем, и это все успешно ISPNETовцы прошли, чего и вам
4443.20 4447.56 SPEAKER_01 желают, и в результате у нас появился прекрасный
4447.56 4450.88 SPEAKER_01 тулинг, который умеет анализировать проекты, поэтому если вы
4450.88 4454.32 SPEAKER_01 хотите ваш проект нацелить на InnoTVout, вам нужно будет
4454.32 4456.96 SPEAKER_01 указать там буквально в файлике проектов несколько
4456.96 4459.84 SPEAKER_01 галочек, и у вас заработает специальный тулинг, который
4459.84 4463.00 SPEAKER_01 будет анализировать весь ваш код и выдавать варнинги
4463.00 4466.24 SPEAKER_01 на те куски, которые не готовы к InnoTVout.
4466.24 4468.84 SPEAKER_01 И как утверждает Microsoft, что если вы избавились от
4468.84 4473.00 SPEAKER_01 всех варнингов, то огромный процент вероятности, что
4473.00 4475.56 SPEAKER_01 это все заработает прекрасно, т.е. они говорят, что тулинг
4475.56 4477.60 SPEAKER_01 они полировали очень хорошо.
4477.60 4485.76 SPEAKER_01 Для того, чтобы поддержать всю эту красоту в ISPNET Core,
4485.76 4489.80 SPEAKER_01 прежде всего они сосредоточились на minimal API, как на более
4489.80 4494.40 SPEAKER_01 новом прогрессивном способе задания вот этих ротов
4494.40 4497.76 SPEAKER_01 и делегатов, так и на том способе, который они сейчас,
4497.76 4500.64 SPEAKER_01 уже держа в памяти InnoTVout, могут каким-то образом
4500.64 4503.92 SPEAKER_01 эволюционировать и развивать, т.е. контроллеры у нас забиты
4503.92 4507.40 SPEAKER_01 там гвоздями и к ним довольно сложно там чего-то добавить,
4507.40 4508.40 SPEAKER_01 хотя тоже есть способы.
4508.40 4513.12 SPEAKER_01 А вот в minimal API его можно подгонять под те знания,
4513.12 4514.76 SPEAKER_01 под те инструменты, которые у нас уже есть.
4514.76 4517.88 SPEAKER_01 В частности, они использовали очень много source-генераторов,
4517.88 4521.32 SPEAKER_01 например, те методы, которые вы в minimal API мапите с помощью
4521.32 4528.40 SPEAKER_01 методов map_get, map_post, под них генерятся в compile-time специальные
4528.40 4532.36 SPEAKER_01 обертки, которые помогают сделать статическую таблицу
4532.36 4535.68 SPEAKER_01 маршрутизации, т.е. уже искать маршрут, по которому
4535.68 4538.36 SPEAKER_01 будут ваши map_get вызываться не динамически с помощью
4538.36 4542.24 SPEAKER_01 reflection, а по готовой таблице, которая подготавливается
4542.24 4545.60 SPEAKER_01 вся в compile-time, и также точно вызывать не с помощью каких-то
4545.60 4549.04 SPEAKER_01 там динамически созданного request-делегата, который
4549.04 4552.08 SPEAKER_01 раньше илим собирался, а просто компилятор в момент
4552.08 4556.16 SPEAKER_01 компиляции сделает правильные вызовы, и интерцепторы
4556.16 4558.64 SPEAKER_01 заменяют правильные методы для того, чтобы это все
4558.64 4559.64 SPEAKER_01 работало.
4559.64 4562.72 SPEAKER_01 Также точно был добавлен source-генератор для систем-текст
4562.72 4566.12 SPEAKER_01 JSON, мы его разбирали очень много в предыдущих выпусках,
4566.12 4568.88 SPEAKER_01 и там рассказывали, как он стал и быстрее, и красивше,
4568.88 4571.52 SPEAKER_01 а самое главное, что он научился поддерживать
4571.52 4576.88 SPEAKER_01 native OAuth, который является частью всего ASP.NET Core, и для
4576.88 4580.00 SPEAKER_01 того, чтобы вам было удобнее, например, свои библиотеки
4580.00 4583.60 SPEAKER_01 оптимизировать под концепцию OAuth, у Microsoft есть хорошие
4583.60 4586.60 SPEAKER_01 статьи, как я уже сказал, есть tooling, и также есть
4586.60 4589.52 SPEAKER_01 куча анализаторов, которые вам помогут это сделать.
4589.52 4593.52 SPEAKER_01 В общем, на самом деле подготовились ребята замечательно, мне
4593.52 4597.32 SPEAKER_01 единственное, что обидно, что уже этот native OAuth существует
4597.32 4598.32 SPEAKER_01 довольно долго.
4598.32 4600.72 SPEAKER_01 Я имею в виду, Microsoft идёт к нему довольно долго и
4600.72 4604.04 SPEAKER_01 постепенно улучшает инструменты, выпускает какие-то новые
4604.04 4608.76 SPEAKER_01 поддержки, и у нас нет какой-то большой статьи или хорошей
4608.76 4611.92 SPEAKER_01 лекции, или отличного доклада, который бы рассказал, как
4611.92 4615.12 SPEAKER_01 свой код переводить к тому, чтобы он был готов к нативной
4615.12 4616.12 SPEAKER_01 компиляции.
4616.12 4618.76 SPEAKER_01 Что нужно сделать, как учесть, те же самые атрибуты, чтобы
4618.76 4621.72 SPEAKER_01 с ними разобраться, там надо вечерок прям хорошо
4621.72 4622.72 SPEAKER_01 с чаем посидеть.
4622.72 4626.38 SPEAKER_01 А вот нашёлся бы добрый человек, и всё бы это понятным
4626.38 4628.72 SPEAKER_01 языком рассказал, вот почему-то таких людей не появляется.
4628.72 4634.84 SPEAKER_01 Ну, возможно, потому что не так много кто стремится
4634.84 4638.64 SPEAKER_01 это сделать сейчас, т.е. ещё не настолько массово
4638.64 4642.28 SPEAKER_01 с одной стороны, а с другой стороны нету такого прям
4642.28 4644.56 SPEAKER_01 бизнес-драйвера, не знаю, почему, честно говоря.
4644.56 4647.28 SPEAKER_01 Ну смотри, сколько там перформанса, сайза, мемори, всё такое,
4647.28 4649.40 SPEAKER_01 по идее, это чистое бабло, особенно если вы работаете
4649.40 4650.40 SPEAKER_01 в облаках.
4650.40 4651.40 SPEAKER_01 По идее, да.
4651.40 4654.32 SPEAKER_01 Ну, сайз, наверное, не столь важен, какая разница, сколько
4654.32 4657.32 SPEAKER_01 занимает твоё приложение в каком-то смысле, а вот
4657.32 4659.84 SPEAKER_01 время старта, всё, особенно если какой-нибудь сервер
4659.84 4661.72 SPEAKER_01 less functions, это, конечно, будет важно.
4661.72 4664.96 SPEAKER_01 Ну, да, наверное, нужно будет как-нибудь сделать
4664.96 4665.96 SPEAKER_01 такое.
4665.96 4668.64 SPEAKER_01 И опять же, разбираясь в наших cloud-ready-аппликейшенах,
4668.64 4670.88 SPEAKER_01 так называемых, вот там один из ключевых моментов
4670.88 4672.80 SPEAKER_01 в том, что приложение должно уметь быстро стартовать.
4672.80 4677.80 SPEAKER_01 Вот для тех же самых функций, функций лямбд и прочих
4677.80 4678.80 SPEAKER_01 вещей.
4678.80 4682.16 SPEAKER_01 Поэтому nativeout здесь вот как раз выливается в струю
4682.16 4684.00 SPEAKER_01 вот этих cloud-аппликейшенов.
4684.00 4689.16 SPEAKER_01 Чтобы вам удобнее было разрабатывать тоже out-проекты,
4689.16 4692.24 SPEAKER_01 Microsoft приготовил для вас несколько темплейтов, это
4692.24 4695.96 SPEAKER_01 web-api, nativeout-темплейт и gRPC-сервис-темплейт.
4695.96 4701.36 SPEAKER_01 И темплейта для mvc нет, потому что mvc ещё не поддерживает
4701.36 4703.96 SPEAKER_01 nativeout, я думаю, что в будущем они будут над этим работать,
4703.96 4705.40 SPEAKER_01 но пока ещё нет.
4705.40 4709.64 SPEAKER_01 Ещё из интересной секции ISP – это Blazor.
4709.64 4713.68 SPEAKER_01 Blazor в каждой релизе, в принципе, славится огромными нововведениями,
4713.68 4717.48 SPEAKER_01 там в нём делают, клипают просто много-много всего,
4717.48 4720.32 SPEAKER_01 и этот релиз не стал исключением, и в этом релизе Blazor уже
4720.32 4724.36 SPEAKER_01 стали называть full-stack web-UI-framework, т.е. если раньше там говорили
4724.36 4728.24 SPEAKER_01 это компоненты, какие-то взаимодействия клиента-сервера,
4728.24 4730.20 SPEAKER_01 то нет, сейчас это нормальный full-stack.
4730.20 4732.64 SPEAKER_01 Поэтому если вы программируете на Blazor, вы, честно, в резюме
4732.64 4735.04 SPEAKER_01 мышки можете писать full-stack разработчик, и для этого
4735.04 4737.44 SPEAKER_01 уже не надо знать какие-то богомерзкие джаваскрипты.
4737.44 4742.24 SPEAKER_01 Что же у нас такого поддержали?
4742.24 4747.48 SPEAKER_01 Во-первых, улучшили взаимодействие между web-assembly Blazor и Blazor-сервером.
4747.48 4749.60 SPEAKER_01 Теперь, как уже говорил Игорь, они могут там динамически
4749.60 4752.00 SPEAKER_01 подключаться вплоть до компонента, до метода,
4752.00 4753.00 SPEAKER_01 до чего угодно.
4753.00 4754.80 SPEAKER_01 Причём умеют друг друга переключаться.
4754.80 4758.40 SPEAKER_01 Также это согласуется с пунктом автоматического
4758.40 4762.40 SPEAKER_01 выбора рендеринга в рантайме.
4762.40 4767.20 SPEAKER_01 То есть, когда вы открываете Blazor-приложение, судя по
4767.20 4770.52 SPEAKER_01 вашему коннекшену и потому, что у вас в браузере сейчас
4770.52 4774.60 SPEAKER_01 закэшировано, сервер выбирает режим, с помощью которого
4774.60 4776.08 SPEAKER_01 будет открывать вам этот сайтик.
4776.08 4778.48 SPEAKER_01 Если вы ни разу не открывали Blazor-приложение, то прежде
4778.48 4784.24 SPEAKER_01 всего вам отдаётся уже статически сгенерённая
4784.24 4788.80 SPEAKER_01 сервер-сарт-рендеринг-страница в чистом HTML, где уже внедрены
4788.80 4791.28 SPEAKER_01 абсолютно все зависимости, которые вам нужны, и вы
4791.28 4794.04 SPEAKER_01 уже страницу видите мега-быстро и мега-удобно.
4794.04 4798.32 SPEAKER_01 В этот момент в бэкграунде к вам загружается web-assembly-версия,
4798.32 4800.60 SPEAKER_01 которая позволяет вам увеличить время отклика.
4800.60 4803.48 SPEAKER_01 То есть, теперь все ваши операции будут выполняться
4803.48 4807.48 SPEAKER_01 именно в браузере на клиентской стороне, а с сервером синхронизироваться
4807.48 4810.08 SPEAKER_01 только какие-то изменения, которые нужны серверу.
4810.08 4814.32 SPEAKER_01 В общем, вот этот автоматический выбор того, как загружать,
4814.32 4817.32 SPEAKER_01 что рендерить на сервере, что рендерить на клиенте,
4817.32 4821.24 SPEAKER_01 в какой момент подгружать какие-то компоненты у дом-дерево,
4821.24 4825.52 SPEAKER_01 которые изменились, это здесь выведено всё на новый
4825.52 4828.32 SPEAKER_01 уровень и позволяет вам добиться довольно сильной
4828.32 4829.32 SPEAKER_01 гибкости.
4829.32 4832.52 SPEAKER_01 Также были улучшения в навигейшн и в обработке
4832.52 4833.52 SPEAKER_01 форм.
4833.52 4837.24 SPEAKER_01 Об этом, в принципе, да, можно почитать подробнее в статье
4837.24 4839.48 SPEAKER_01 про Blazor.
4839.48 4843.22 SPEAKER_01 Из ещё интересных вещей появился компонент QuickGrid,
4843.22 4845.96 SPEAKER_01 это типичный DataGrid, всё, что вы от него ожидаете.
4845.96 4850.92 SPEAKER_01 Форма Grid данных, в которой можно сортировать, фильтровать,
4850.92 4854.36 SPEAKER_01 делать странички, самое главное, это, конечно же,
4854.36 4855.36 SPEAKER_01 делать виртуализацию.
4855.36 4858.12 SPEAKER_01 Вроде она там даже более-менее работает.
4858.12 4861.36 SPEAKER_01 Я покликал, в принципе, работает быстро, довольно
4861.36 4864.32 SPEAKER_01 удобно, все те фишки, которые вы ожидаете от DataGrid там
4864.32 4865.32 SPEAKER_01 поддержаны.
4865.32 4867.16 SPEAKER_01 Естественно, это первый релиз, это всё довольно
4867.16 4870.24 SPEAKER_01 быстро, но уже довольно функционально и, самое главное,
4870.24 4871.24 SPEAKER_01 работоспособно.
4871.24 4876.04 SPEAKER_01 Появились секции, также был сильно переписан и
4876.04 4879.44 SPEAKER_01 обновлён роутинг в Blazor для того, чтобы более гибко
4879.44 4881.92 SPEAKER_01 подставлять там атрибуты и более быстрее разбирать,
4881.92 4882.92 SPEAKER_01 но это уже мелочи.
4882.92 4888.24 SPEAKER_01 Дальше, из интересного, это улучшения в .NET Assembly,
4888.24 4893.72 SPEAKER_01 .NET WebAssembly, конечно же, .NET Assembly был тоже мега прооптимизирован,
4893.72 4898.30 SPEAKER_01 опять же, рантайм, на 20% быстрее рендерится, в
4898.30 4900.84 SPEAKER_01 два раза быстрее работает, в общем, люди здесь тоже
4900.84 4901.84 SPEAKER_01 не спят.
4901.84 4906.72 SPEAKER_01 Интересно, в этой области ввели новый веб-френдли
4906.72 4911.00 SPEAKER_01 формат пакетов, мы обсуждали, что раньше это всё отдавалось
4911.00 4915.28 SPEAKER_01 довольно в Windows-специфик или в .NET-специфик с заголовками
4915.28 4920.96 SPEAKER_01 .dll и .exe, на что многие корпоративные антивирусы ругались, поэтому
4920.96 4924.20 SPEAKER_01 сделали специальный WebAssembly формат, который называется
4924.20 4925.20 SPEAKER_01 WebCL.
4925.20 4930.16 SPEAKER_01 И вот в виде этого WebCL отдаётся чистый Blazor, чистый WebAssembly
4930.16 4934.48 SPEAKER_01 даже, чистый WebAssembly-код, который генерится из Blazor-компонентов
4934.48 4937.62 SPEAKER_01 и его уже, вроде как бы, антивирусы не так сильно
4937.62 4938.62 SPEAKER_01 боятся.
4938.62 4941.56 SPEAKER_01 И, конечно же, добавился новый Blazor-темплейт в студию,
4941.56 4942.56 SPEAKER_01 куда же без этого.
4942.56 4950.48 SPEAKER_01 Из Blazor-а прекрасная штука в бете вышла, это Scaffolder.
4950.48 4954.24 SPEAKER_01 Scaffolder позволяет вам генерить различный код, который
4954.24 4955.24 SPEAKER_01 вам нужен.
4955.24 4959.64 SPEAKER_01 Для этого вам понужно поставить Visual Studio Preview, где это доступно.
4959.64 4961.76 SPEAKER_01 Ну, например, вы можете сгенерить стандартные
4961.76 4966.08 SPEAKER_01 формы с Create, Read, Update и Delete, например, то есть не только
4966.08 4969.72 SPEAKER_01 формы, но и модельки, формы и, более того, связи этих
4969.72 4973.02 SPEAKER_01 моделек с Entity Framework, то есть, вообще, абсолютно полное
4973.02 4976.68 SPEAKER_01 приложение можно сгенерить просто благодаря Wizard.
4976.68 4981.16 SPEAKER_01 Мы такие штуки проходили и в WinFormах, и в WPF-ах, и вот
4981.16 4983.68 SPEAKER_01 мы дошли, наконец, до того, что можно Blazor сгенерить
4983.68 4986.52 SPEAKER_01 с помощью прокликивания мастера и базовые какие-то
4986.52 4987.52 SPEAKER_01 операции ему сделать.
4987.52 4989.24 SPEAKER_01 Безусловно, после того, как вы сделаете базовые
4989.24 4993.36 SPEAKER_01 операции, вам нужно каким-то, ну, дописать код специфичный,
4993.36 4996.04 SPEAKER_01 но в общем случае, если это довольно простое приложение,
4996.04 4997.04 SPEAKER_01 Scaffolder очень часто помогает.
4997.04 5004.28 SPEAKER_01 Из мелочи появился Generic-атрибут для всех MVC-типов, которые
5004.28 5008.20 SPEAKER_01 раньше требовали type-параметр, то есть, например, если
5008.20 5015.96 SPEAKER_01 у вас раньше был тип producesResponseType, которым вы должны были передать
5015.96 5018.96 SPEAKER_01 type of той модели, которая возвращается из контроллера,
5018.96 5022.48 SPEAKER_01 теперь есть его коллега, такой же producesResponseType,
5022.48 5024.72 SPEAKER_01 но теперь Generic, где вы этот тип можете не параметром
5024.72 5028.00 SPEAKER_01 передавать, а просто обычным Generic-аргументом передать,
5028.00 5031.84 SPEAKER_01 что делает синтаксис, конечно, более чистым и более красивым,
5031.84 5034.32 SPEAKER_01 и более воспринимается лучше.
5034.32 5039.72 SPEAKER_01 Еще интересная секция – это метрики, то есть, появилась
5039.72 5046.72 SPEAKER_01 стандартная сборка, стандартный пакет для метрик, тоже довольно
5046.72 5049.74 SPEAKER_01 долго эту штуку ждали, и вот, наконец, она появилась
5049.74 5052.92 SPEAKER_01 в том виде, в котором ее более-менее можно юзать.
5052.92 5057.50 SPEAKER_01 Метрики – это обычно какие-то счетчики, которые зависят
5057.50 5060.48 SPEAKER_01 от времени, то есть, репортят вам какие-то значения во
5060.48 5061.48 SPEAKER_01 времени.
5061.48 5064.00 SPEAKER_01 Ну, например, если вы хотите узнать, сколько запросов
5064.00 5068.00 SPEAKER_01 в секунду к вашему приложению приходило, то это типичное
5068.00 5071.48 SPEAKER_01 обращение к метрикам, типичная запись в метрике.
5071.48 5074.52 SPEAKER_01 Или, например, какое количество ошибок у вас в приложении
5074.52 5076.96 SPEAKER_01 возникло – это тоже типичные метрики, которые можно
5076.96 5080.00 SPEAKER_01 собирать в вашем приложении и куда-нибудь репортить,
5080.00 5083.36 SPEAKER_01 например, на какое-нибудь хранилище метрик.
5083.36 5086.04 SPEAKER_01 Все это чудо подключается с помощью специального
5086.04 5092.00 SPEAKER_01 Namespace System Diagnostic Metrics – это кроссплатформный API, который
5092.00 5096.32 SPEAKER_01 сделан с тесным взаимодействием с OpenTelemetry Community.
5096.32 5099.24 SPEAKER_01 Вот почему эти метрики в этом релизе очень важны,
5099.24 5103.72 SPEAKER_01 потому что данная штука поддерживает OpenTelemetry протокол,
5103.72 5108.52 SPEAKER_01 а это значит, что OpenTelemetry протокол – это стандарт,
5108.52 5111.48 SPEAKER_01 и поэтому данная поддержка обозначает, что ваши метрики
5111.48 5114.96 SPEAKER_01 будут видны практически во всех, например, каких-нибудь
5114.96 5120.00 SPEAKER_01 APM-системах или в каких-нибудь Cloud-системах, или во всех
5120.00 5123.40 SPEAKER_01 практически системах мониторинга, которые наблюдают обычно
5123.40 5129.40 SPEAKER_01 за приложениями, потому что это стандарт, поэтому
5129.40 5132.76 SPEAKER_01 метрики теперь смогут использоваться в таком более широком смысле
5132.76 5133.76 SPEAKER_01 для дот-нета.
5133.76 5138.76 SPEAKER_01 В новой метрике включены и каунтеры, гейджи и гистограммы.
5138.76 5146.04 SPEAKER_01 Также поддерживаются многомерные значения и более четкое
5146.04 5151.48 SPEAKER_01 соблюдение OpenTelemetry стандарта, то есть более четкая градация.
5151.48 5154.84 SPEAKER_01 Одним из таких систем визуализации, не в облаках, а часто у
5154.84 5157.88 SPEAKER_01 себя дома, используется графан.
5157.88 5160.40 SPEAKER_01 Графан – замечательный инструмент, рисует красивые
5160.40 5163.82 SPEAKER_01 графики быстро, красиво, и вот Microsoft предоставил
5163.82 5170.20 SPEAKER_01 дашборды, которые построены поверх этих метрик, которые
5170.20 5174.00 SPEAKER_01 теперь не только введены в namespace, но и которые используют
5174.00 5177.28 SPEAKER_01 и ISP.NET Core, и фреймворк, и в общем все о них используют.
5177.28 5181.04 SPEAKER_01 У нас теперь есть графановские дашборды, которые построены
5181.04 5184.48 SPEAKER_01 поверх этих метрик системных, которые уже есть у Microsoft,
5184.48 5187.56 SPEAKER_01 и которые помогают вам посмотреть в real-time статус
5187.56 5191.32 SPEAKER_01 вашего приложения, то есть сколько реквестов, сколько
5191.32 5193.48 SPEAKER_01 ошибок, какая нагрузка на кейндпоинт, и все это
5193.48 5196.28 SPEAKER_01 красиво видно в разноцветных интересных графиках.
5196.28 5199.32 SPEAKER_01 В общем, тоже если пользуетесь графаной, посмотрите, может
5199.32 5200.32 SPEAKER_01 быть, вам понравится.
5200.32 5203.40 SPEAKER_01 Вот такие у нас новости по ISP.NET Core.
5203.40 5205.52 SPEAKER_01 Ну как, Игорь, ISP тебя порадовал?
5205.52 5209.12 SPEAKER_01 Ну в ISP, мне кажется, как раз я вижу такое полномерное
5209.12 5210.12 SPEAKER_01 улучшение.
5210.12 5212.92 SPEAKER_01 Я не особо пользуюсь Blazor, на который сейчас основной
5212.92 5213.92 SPEAKER_01 упор, мне кажется.
5213.92 5218.32 SPEAKER_01 Блэйзер и нейтив аут, поэтому для меня сейчас это больше
5218.32 5222.68 SPEAKER_01 такие эволюционные улучшения без каких-то революций,
5222.68 5225.72 SPEAKER_01 но с другой стороны, я по сравнению, например, с C-Sharp
5225.72 5228.28 SPEAKER_01 не вижу здесь каких-то, знаешь, таких типа… Не
5228.28 5229.92 SPEAKER_01 могу сказать, что это неважный релиз.
5229.92 5234.18 SPEAKER_01 Фичи важные, нужные, и, скорее всего, своего аудиторию
5234.18 5235.18 SPEAKER_01 найдут.
5235.18 5237.16 SPEAKER_01 Я не исключаю, что я там через полгода буду все
5237.16 5239.60 SPEAKER_01 компилить в нейтив аут и начну использовать Blazor,
5239.60 5240.60 SPEAKER_01 кто знает.
5240.60 5241.60 SPEAKER_01 Ну да, да.
5241.60 5244.86 SPEAKER_01 Ну в любом случае ты какое-нибудь улучшение перфоманса получаешь
5244.86 5245.86 SPEAKER_01 просто так.
5245.86 5246.86 SPEAKER_01 Это да.
5246.86 5247.86 SPEAKER_01 Вот.
5247.86 5252.16 SPEAKER_01 Ну давай пойдем дальше, мы посмотрели на .NET в целом,
5252.16 5254.48 SPEAKER_01 мы посмотрели на язык, мы посмотрели на работу
5254.48 5257.32 SPEAKER_01 с базами, мы посмотрели на S/PANET, теперь настало время
5257.32 5258.52 SPEAKER_01 посмотреть на UI.
5258.52 5261.60 SPEAKER_01 Ну Blazor мы уже затронули, но у нас есть еще один UI
5261.60 5263.92 SPEAKER_01 от Майкрософта, и это Maui.
5263.92 5270.64 SPEAKER_01 С Maui история темная в каком-то смысле, непонятно.
5270.64 5273.20 SPEAKER_01 Что, завезли темную тему, что ли?
5273.20 5274.20 SPEAKER_01 Если бы.
5274.20 5276.36 SPEAKER_01 Ну нет, кстати, было, по-моему, даже в седьмом уже доступно.
5276.36 5277.36 SPEAKER_01 Смысл в чем?
5277.36 5280.60 SPEAKER_01 Во-первых, они так же, как и EF Core, гордятся количеством
5280.60 5282.72 SPEAKER_01 пул реквестов и багов.
5282.72 5287.04 SPEAKER_01 Они замерзли 1681 пул реквест, это аж в три раза больше,
5287.04 5290.72 SPEAKER_01 чем в прошлом, так сказать, отчетном периоде, и пофиксили
5290.72 5293.92 SPEAKER_01 689 багов, это почти в четыре раза больше, чем в отчетном
5293.92 5297.92 SPEAKER_01 прошлом периоде, видимо, к семерке, когда они готовились.
5297.92 5302.36 SPEAKER_01 Но при этом, надо сказать, что статья про релиз говорит,
5302.36 5306.88 SPEAKER_01 а еще мы вообще выяснили, что, я про это уже как-то
5306.88 5310.00 SPEAKER_01 говорил, что вообще Maui рождался больше как наследник заморенной
5310.00 5314.12 SPEAKER_01 и такого мобильного фреймворка, вспомнили, что вообще бывают
5314.12 5318.88 SPEAKER_01 десктопы, там нужны всякие клавиатуры, бывает у компьютеров,
5318.88 5321.84 SPEAKER_01 поэтому основная фича, которой посвящена половина
5321.84 5324.80 SPEAKER_01 статьи, это Keyboard Accelerator, то есть это горячие клавиши
5324.80 5325.80 SPEAKER_01 на клавиатуре.
5325.80 5331.56 SPEAKER_01 Ну и еще немножко драгондропа там, вот это все, и, конечно
5331.56 5334.20 SPEAKER_01 же, раздел, без которого не обходится любой анонс
5334.20 5337.96 SPEAKER_01 Maui, это Performance and Memory Improvements, это вот к вопросу, как же
5337.96 5339.16 SPEAKER_01 можно было написать так медленно, что они до сих
5339.16 5340.88 SPEAKER_01 пор улучшают перформанс и память.
5340.88 5344.20 SPEAKER_01 Ну, просто смотри, когда мы говорим о фреймворке
5344.20 5347.48 SPEAKER_01 или о SPNet, это можно померить, да, у тебя есть реквесты,
5347.48 5350.04 SPEAKER_01 они должны выполняться быстро, а вот когда мы говорим
5350.04 5354.04 SPEAKER_01 о Maui целый год, и что у них каждый релиз Performance
5354.04 5356.36 SPEAKER_01 и Memory Improvements, там даже померить-то нечего, что у них, быстрее
5356.36 5358.36 SPEAKER_01 кнопочки нажимаются, быстрее рендер происходит.
5358.36 5360.76 SPEAKER_01 Да, возможно быстрее рендер происходит, а с памятью
5360.76 5363.60 SPEAKER_01 все просто, все меньше памяти утекает, возможно.
5363.60 5366.76 SPEAKER_01 Действительно, да, и раньше никто не говорил, что диспользовать
5366.76 5367.76 SPEAKER_01 надо.
5367.76 5371.40 SPEAKER_01 Ну, типа того, вот, и, ну, если интересно, посмотрите
5371.40 5376.20 SPEAKER_01 на ролики в плейлисте Edut.net.conf по слову Maui, поищите, там
5376.20 5379.16 SPEAKER_01 их, по-моему, даже не один, их несколько, разных всяких
5379.16 5382.88 SPEAKER_01 примеров того, как можно использовать Maui, я не особо
5382.88 5387.60 SPEAKER_01 смотрел, но если вам интересует, и вас интересует UI на .NET,
5387.60 5392.20 SPEAKER_01 там же есть выступление про Avalon, про то, как надо
5392.20 5396.48 SPEAKER_01 писать на Avalon для .NET, это кроссплатформенный фреймворк,
5396.48 5398.24 SPEAKER_01 включая, кстати, они там немножко рассказывают
5398.24 5401.44 SPEAKER_01 про то, что такое XPF, это их замена, это кроссплатформенный
5401.44 5408.60 SPEAKER_01 VPF, вот, а также зарелизился Uno, платформа, по-моему, пятерка,
5408.60 5411.52 SPEAKER_01 примерно вместе с .NET 8, и это тоже альтернативный
5411.52 5413.88 SPEAKER_01 кроссплатформенный фреймворк, который можно использовать
5413.88 5416.16 SPEAKER_01 для UI на .NET.
5416.16 5418.88 SPEAKER_01 Поэтому я бы, честно говоря, если бы сейчас выбирал
5418.88 5422.56 SPEAKER_01 что-нибудь для UI на .NET и не хотел бы VPF, как обычно
5422.56 5425.52 SPEAKER_01 все делают, я бы, скорее, брал либо Avalon, либо Uno, потому
5425.52 5428.44 SPEAKER_01 что, мне кажется, они два наиболее плюс-минус живых
5428.44 5430.12 SPEAKER_01 фреймворка кроссплатформенных.
5430.12 5433.96 SPEAKER_01 Опять же, видишь, не хватает какого-то хорошего обзорчика,
5433.96 5437.24 SPEAKER_01 потому что все это какой-то UI, и мне кажется, что у каждого
5437.24 5440.48 SPEAKER_01 из них есть какая-то ниша, да, где каждый из них хороший,
5440.48 5442.04 SPEAKER_01 но каждый из них почему-то надо выбирать.
5442.04 5445.00 SPEAKER_01 Но вот такого роудмапа, типа кого когда выбрать,
5445.00 5447.72 SPEAKER_01 и кто из них что делает, пока не хватает.
5447.72 5450.24 SPEAKER_01 Надо бы поискать, кто это сможет делать.
5450.24 5453.36 SPEAKER_01 Все, кто нас слушают, если вы про это что-то знаете,
5453.36 5454.36 SPEAKER_01 приходите, расскажите.
5454.36 5457.48 SPEAKER_01 Не, ну и вообще мы тут очень много не понимаем, как вы
5457.48 5459.56 SPEAKER_01 видите, да, у нас практически вопросы огромные есть к
5459.56 5462.00 SPEAKER_01 каждому пункту, поэтому если у вас есть ответы или
5462.00 5464.00 SPEAKER_01 практически кейсы, когда это нужно, тоже обязательно
5464.00 5466.48 SPEAKER_01 приходите, рассказывайте, чтобы мы не сидели тут
5466.48 5469.28 SPEAKER_01 в неведении, а все-таки понимали, что такие люди
5469.28 5470.28 SPEAKER_01 и что это востребовано.
5470.28 5473.28 SPEAKER_01 И вообще пробежали писать UI снова на десктопах, как
5473.28 5474.28 SPEAKER_01 мы это делали когда-то раньше.
5474.28 5478.56 SPEAKER_01 Да, скоро все эти вебы ваши и клауды вымрут, и наконец-то
5478.56 5479.84 SPEAKER_01 мы вернемся к нашим десктопам.
5479.84 5481.12 SPEAKER_01 Я скучаю по WPF.
5481.12 5483.64 SPEAKER_01 Ну, что-то в этом есть, там было по крайней мере понятно,
5483.64 5487.08 SPEAKER_01 вот у тебя приложение, оно работает, и все, и не надо
5487.08 5491.32 SPEAKER_01 там вот этого докер такой, докер секой, докер этакий,
5491.32 5493.72 SPEAKER_01 удаленный вожу ли какой-нибудь сервис баз, подними то,
5493.72 5496.64 SPEAKER_01 подними, вот допустил приложение, оно работает, просто и понятно.
5496.64 5498.52 SPEAKER_01 Самая большая проблема – это просто пользователя
5498.52 5500.76 SPEAKER_01 ее потом обновить каким-то образом, делать это более-менее
5500.76 5503.36 SPEAKER_01 регулярно, и чтобы он еще не заметил, а все остальное
5503.36 5504.36 SPEAKER_01 мелочь.
5504.36 5505.64 SPEAKER_01 Ну, можно сказать, что это проблема пользователя.
5505.64 5510.60 SPEAKER_01 Хорошо, что там у нас еще по UI есть?
5510.60 5515.64 SPEAKER_01 По UI у нас нет больше пока ничего, зато у нас есть
5515.64 5516.64 SPEAKER_01 про F#.
5516.64 5520.20 SPEAKER_01 О, про F#, сейчас я вам расскажу, что такое Monado и все такое.
5520.20 5524.20 SPEAKER_01 Я бы, наверное, хотел бы вам это все рассказать,
5524.20 5526.56 SPEAKER_01 но так как мы с Игорем абсолютно ничего не понимаем в F#,
5526.56 5529.40 SPEAKER_01 мы пригласили к нам в гости специального человека,
5529.40 5532.20 SPEAKER_01 который отлично разбирается в этом языке и вообще рассказывает
5532.20 5535.00 SPEAKER_01 о нем на конференциях, на митапах и вообще при любом
5535.00 5537.28 SPEAKER_01 удобном случае, как и в этот раз.
5537.28 5538.64 SPEAKER_01 Это Марк Шевченко.
5538.64 5539.64 SPEAKER_01 Приветствую, Марк.
5539.64 5540.64 SPEAKER_01 Привет, Анатолий.
5540.64 5541.64 SPEAKER_01 Как дела?
5541.64 5542.64 SPEAKER_01 Отлично.
5542.64 5545.72 SPEAKER_01 Вот пытаемся сейчас посидеть, прозабраться, что же такое
5545.72 5548.64 SPEAKER_01 в F# произошло, и кроме непонятных закорючек мы ничего понять
5548.64 5549.64 SPEAKER_01 не можем.
5549.64 5551.88 SPEAKER_01 Надеюсь, ты нам расскажешь, что же там такого, собственно,
5551.88 5555.32 SPEAKER_01 интересного, чем сообщество F# гордится, и что может быть
5555.32 5557.08 SPEAKER_01 C# у него каким-то образом перенять.
5557.08 5561.48 SPEAKER_01 Да, хорошо, давай, у нас как раз речь пойдет про
5561.48 5565.68 SPEAKER_00 новую версию языка, восьмую версию F#, которая вышла вместе
5565.68 5566.92 SPEAKER_00 с .NET-ом восьмеркой.
5566.92 5571.40 SPEAKER_00 Что тут можно сказать, наверное, таких больших
5571.40 5573.96 SPEAKER_00 изменений в языке нет, ну вот прямо, чтобы что-то
5573.96 5577.12 SPEAKER_01 новое появилось, такое киллер фича, но команда
5577.12 5580.36 SPEAKER_01 очень хорошо поработала над компилятором и завезла
5580.36 5583.40 SPEAKER_01 немного такого хорошего нового синтаксиса, и это,
5583.40 5584.40 SPEAKER_01 в общем, приятно.
5584.40 5588.24 SPEAKER_01 Как мы будем рассказывать про синтаксис, не показывая
5588.24 5590.24 SPEAKER_01 скриншоты, что скажут наши зрители?
5590.24 5592.80 SPEAKER_01 В этом есть профессионализм, видишь, со скриншотами
5592.80 5593.80 SPEAKER_01 любой сможет.
5593.80 5595.32 SPEAKER_01 А ты теперь попробуй голосом рассказать, тем более на
5595.32 5597.64 SPEAKER_01 функциональном языке, это вдвойне сложнее.
5597.64 5598.96 SPEAKER_01 Что же там такого интересного?
5598.96 5602.40 SPEAKER_01 Да, хорошо, первое известное довольно и очень приятное
5602.40 5608.04 SPEAKER_01 это новшество, это сокращённый синтаксис для лямбд, если
5608.04 5610.88 SPEAKER_01 раньше нужно было писать полностью лямбду, это ключевое
5610.88 5613.56 SPEAKER_01 слово fun, потом параметры, потом стрелочка, то сейчас
5613.56 5616.96 SPEAKER_01 можно просто использовать подчёркивание, точку и
5616.96 5620.52 SPEAKER_01 какое-то свойство или какой-то метод, и это всё разворачивается
5620.52 5621.76 SPEAKER_01 в большое выражение.
5621.76 5626.92 SPEAKER_01 И очень удобно работать, там есть такой синтаксис,
5626.92 5632.40 SPEAKER_00 похожий на текущий синтаксис в C#, когда очень много лямбд
5632.40 5636.04 SPEAKER_01 используется, и вместо них у нас очень короткий
5636.04 5639.84 SPEAKER_01 компактный синтаксис получается, очень хорошее такое добавление
5639.84 5640.84 SPEAKER_01 в языке.
5640.84 5645.96 SPEAKER_00 Я думаю, его всем понравилось в Sharp, хотя не все кейсы
5645.96 5648.76 SPEAKER_00 он пока обрабатывает, но я думаю, что с течением
5648.76 5654.64 SPEAKER_01 времени команда компилятора всё это покроет постепенно.
5654.64 5657.84 SPEAKER_01 Слушай, ну вот такую штуку мне тоже давно в C# хотелось,
5657.84 5659.84 SPEAKER_01 и мне было интересно, почему не завезли.
5659.84 5663.56 SPEAKER_01 Я ещё, может быть, дополню, чтобы вы больше представляли,
5663.56 5664.56 SPEAKER_01 что это.
5664.56 5667.68 SPEAKER_01 Например, если вам нужно в линку указать, например,
5667.68 5671.56 SPEAKER_01 groupby по юзернейму, то обычно вы должны написать groupby,
5671.56 5674.68 SPEAKER_01 открыть скобочки, написать юзер, у этого юзера стрелочка
5674.68 5675.68 SPEAKER_01 юзернейм.
5675.68 5678.44 SPEAKER_01 И очень часто в лямбдах нам приходится обращаться
5678.44 5680.72 SPEAKER_01 к одному-единственному свойству, который там,
5680.72 5684.00 SPEAKER_01 может, селект один свойств хотите сделать, может, загрупбайть,
5684.00 5688.40 SPEAKER_01 может, ещё что-то с ним сделать, но вот обычно в таких больших
5688.40 5690.92 SPEAKER_01 цепочках очень лень писать полный синтаксис вот этой
5690.92 5691.92 SPEAKER_01 лямбды.
5691.92 5694.64 SPEAKER_01 И то, что сделали ребята в F#, это они сделали сокращенный
5694.64 5697.48 SPEAKER_01 синтаксис, вы можете написать подчёркивание, точка, и
5697.48 5700.72 SPEAKER_01 обратиться к тому имени, который вы хотите выбрать,
5700.72 5704.48 SPEAKER_01 т.е. к нейму или к age, или ещё к чему-то.
5704.48 5707.72 SPEAKER_01 Интересно здесь то, что вот, почему раньше эти фичи,
5707.72 5711.24 SPEAKER_01 мне кажется, не то, что никто не делал, почему её откладывали?
5711.24 5714.00 SPEAKER_01 Потому что нельзя выбрать хороший, красивый синтаксис
5714.00 5718.40 SPEAKER_01 для текущего значения, т.е. вот это F# выбрал подчёркивание,
5718.40 5719.40 SPEAKER_01 точка.
5719.40 5720.64 SPEAKER_01 Ну согласись, подчёркивание – не самое лучшее имя, правда
5720.64 5721.64 SPEAKER_01 же?
5721.64 5726.20 SPEAKER_00 Да, тем более, у него есть какие-то и другие коннотации,
5726.20 5730.00 SPEAKER_00 в общем, такое опускаемое значение переменной, вот
5730.00 5732.44 SPEAKER_00 часто в таком контексте применяется.
5732.44 5737.24 SPEAKER_00 Ну вот мы знаем в Котлине ключевое слово «ид», такая
5737.24 5741.32 SPEAKER_00 переменная «ид» появляется как раз в похожем контексте,
5741.32 5743.88 SPEAKER_00 тоже для сокращения лямбд, если кто из наших слушателей
5743.88 5747.52 SPEAKER_00 писал на Котлине, то, наверное, вам это будет знакомо.
5747.52 5750.16 SPEAKER_01 Ну «ид», кажется, звучит более читабельнее, да?
5750.16 5752.28 SPEAKER_01 Скорее всего, не захотели новое ключевое слово вводить,
5752.28 5753.84 SPEAKER_01 но, мне кажется, «ид» было бы лучше.
5753.84 5757.68 SPEAKER_00 Да, и ключевое слово, там, возможно, есть какие-то,
5757.68 5762.80 SPEAKER_00 как мне сказали ребят из чата F#, возможно, есть пересечения
5762.80 5768.44 SPEAKER_01 с F# Interactive, там такой инструмент есть для написания скриптов,
5768.44 5772.44 SPEAKER_01 там «ид» – это тоже такая переменная, которая последнее
5772.44 5774.62 SPEAKER_01 вычисленное выражение хранит, может быть, с этим
5774.62 5776.00 SPEAKER_01 пересечения какие-то были.
5776.00 5779.72 SPEAKER_01 В общем, мы не знаем, но такой синтаксис какой-то
5779.72 5781.94 SPEAKER_01 завезли, и он, в принципе, уже работающий, т.е. у нас
5781.94 5784.04 SPEAKER_01 все ребята попробовали, всем нравится.
5784.04 5787.28 SPEAKER_01 Ну, отлично, может быть, что-нибудь еще можешь подсветить?
5787.28 5789.28 SPEAKER_01 На твой взгляд, прям такое значение.
5789.28 5793.44 SPEAKER_00 Да, значит, опять-таки упрощенный синтаксис для копирования
5793.44 5794.92 SPEAKER_00 и обновления записей.
5794.92 5796.92 SPEAKER_00 История о чем?
5796.92 5800.84 SPEAKER_00 Данные мутабельные в F#, конечно, большей частью, и когда
5800.84 5804.12 SPEAKER_00 мы хотим что-то поменять, то мы не меняем непосредственно
5804.12 5806.68 SPEAKER_00 самой записи, мы создаем новую, копируем, и меняем
5806.68 5808.76 SPEAKER_00 только несколько полей, и есть специальный синтаксис
5808.76 5809.76 SPEAKER_01 для этого.
5809.76 5814.44 SPEAKER_01 Но для, как бы, вложенных записей, вложенных классов,
5814.44 5817.08 SPEAKER_01 вложенных структур, наверное, C# прям более так понятно.
5817.08 5820.20 SPEAKER_01 Синтаксис, получается, довольно громоздкий, а сейчас придумали,
5820.20 5821.20 SPEAKER_01 как его сделать очень коротким.
5821.20 5824.60 SPEAKER_01 Он, в общем-то, очень удобнее сейчас стал, поэтому тоже
5824.60 5828.48 SPEAKER_01 удобно для иммутабельных программистов, очень хороший
5828.48 5831.08 SPEAKER_01 такой синтаксический сахар, но приятный.
5831.08 5836.56 SPEAKER_01 Что-то еще у нас, ключевое слово "while bang" появилось,
5836.56 5840.68 SPEAKER_01 это для вычислимых выражений.
5840.68 5843.44 SPEAKER_01 Довольно сложно объяснить людям, которые не погружены
5843.44 5848.48 SPEAKER_01 в тему, но это позволяет писать в код для ввода и
5848.48 5853.44 SPEAKER_00 вывода в сокращенном виде, когда мы хотим блоками читать
5853.44 5854.44 SPEAKER_00 что-то.
5854.44 5859.16 SPEAKER_00 Раньше, если мы писали подобное на F#, это было такое, ну там,
5859.16 5863.40 SPEAKER_00 на 4, на 5 строк, на 7, а сейчас это 2-3 строчки, вот так вот.
5863.40 5867.36 SPEAKER_01 В самом языке это ничего не потребовало изменять,
5867.36 5870.12 SPEAKER_01 только компилятор стал более умным, он это ключевое
5870.12 5872.36 SPEAKER_01 слово распознает и использует существующие средства
5872.36 5875.68 SPEAKER_01 для того, чтобы его с код это скомпилировать.
5875.68 5880.36 SPEAKER_01 Это всегда, конечно, классная штука F#, что он может прям
5880.36 5882.40 SPEAKER_01 реальной концепции новый в язык вводить, при этом
5882.40 5885.08 SPEAKER_01 не изменяя компилятор, благодаря вот таким вот структурчикам
5885.08 5886.08 SPEAKER_01 всяким.
5886.08 5893.80 SPEAKER_00 Да, там ребята реально головастые сидят в команде, да, это
5893.80 5897.12 SPEAKER_01 не может не радовать, приятно, вот такие изменения, конечно,
5897.12 5898.12 SPEAKER_01 приятные.
5898.12 5899.12 SPEAKER_01 Что-то еще у нас?
5899.12 5900.48 SPEAKER_01 Расширенные синтексы с интерполяцией, но это такая
5900.48 5904.28 SPEAKER_01 вещь, мне она показалась немного странной, это,
5904.28 5908.28 SPEAKER_00 наверное, для тех, кто пишет очень много такого веп-кода,
5908.28 5913.72 SPEAKER_00 там, css-ки какие-то, потому что мы знаем, что в интерполяционных
5913.72 5916.04 SPEAKER_01 строках у нас фигурные скобки используются для
5916.04 5920.16 SPEAKER_01 того, чтобы что-то там обозначить, а если мы хотим саму фигурную
5920.16 5923.16 SPEAKER_01 скобку записать, то нам нужно написать два раза,
5923.16 5926.36 SPEAKER_01 и это, конечно, усложняет жизнь, если мы хотим какой-то
5926.36 5927.36 SPEAKER_01 css написать.
5927.36 5932.40 SPEAKER_01 Так вот синтекс такой придумали, что можно вместо, там, где
5932.40 5935.20 SPEAKER_01 мы хотим ставить переменную, там мы пишем две скобки,
5935.20 5938.64 SPEAKER_01 а там, где просто скобку хотим, мы пишем одну скобку,
5938.64 5941.76 SPEAKER_01 то есть ровно все наоборот получается, такой вот странный
5941.76 5944.76 SPEAKER_01 синтексис, но, наверное, он нужен, я просто с этим
5944.76 5946.52 SPEAKER_01 никогда не сталкивался в HRD.
5946.52 5949.52 SPEAKER_01 Ну, действительно, если вам нужно css каким-то образом
5949.52 5952.20 SPEAKER_01 затемплейтить, то вам это будет очень полезно, а еще
5952.20 5956.64 SPEAKER_01 можно учесть, что вообще темплейтинги в веб-мире
5956.64 5959.28 SPEAKER_01 часто делаются с помощью скобок, то же самое mustache
5959.28 5963.32 SPEAKER_01 синтексис, где как раз две скобки обозначают имя переменной,
5963.32 5966.80 SPEAKER_01 которую надо подставить, и вот как сделать одну скобку,
5966.80 5969.20 SPEAKER_01 ее заэкранировать, а еще сложнее, как сделать две
5969.20 5971.84 SPEAKER_01 скобки, их заэкранировать, т.е. до этого изменения
5971.84 5975.40 SPEAKER_01 это было довольно громоздко и некрасиво выглядело.
5975.40 5978.16 SPEAKER_01 После этого изменения, когда мы начали считать, что одна
5978.16 5982.04 SPEAKER_01 скобка – это все-таки синтеподстановка самого F#, а все остальное
5982.04 5985.52 SPEAKER_01 – это вот чистая строка, и туда мы не лезем, и стало
5985.52 5986.52 SPEAKER_01 довольно читабельнее.
5986.52 5990.16 SPEAKER_01 Наверное, как-будто актуальнее, шаблоны css напишут, да.
5990.16 5994.76 SPEAKER_00 Код читаемый, да, стал, да, значит, немного улучшилась
5994.76 5999.08 SPEAKER_01 у нас работа с константами, раньше, по крайней мере,
5999.08 6001.24 SPEAKER_01 это обычно везде делается, константные вычисления
6001.24 6006.44 SPEAKER_01 вычисляются, и остаются константами, но в F# этого
6006.44 6010.40 SPEAKER_00 не было, сейчас это добавили, и там константные выражения
6010.40 6013.22 SPEAKER_00 у нас теперь работают, если мы хотим какую-то константу
6013.22 6016.16 SPEAKER_00 почитать, ну, например, количество секунд в сутках
6016.16 6021.40 SPEAKER_00 – 24*60*60, раньше нужно было вручную подставить.
6021.40 6024.46 SPEAKER_01 Ну, точно так же строковое выражение в функциях, которые
6024.46 6028.34 SPEAKER_01 семейство printf, дело в том, что компилятор на этапе
6028.34 6034.24 SPEAKER_01 компиляции уже умеет строку формата разбирать, чтобы
6034.24 6037.68 SPEAKER_01 проверять, но раньше мы не могли ее, например, состыковать
6037.68 6040.88 SPEAKER_00 из двух-трех строковых констант, сейчас можно, какое-то уже
6040.88 6042.96 SPEAKER_00 приятное нововведение.
6042.96 6048.28 SPEAKER_00 Что-то еще, ну, давай, может быть, немного про сам компилятор
6048.28 6051.36 SPEAKER_01 поговорим, там просто есть еще несколько небольших
6051.36 6053.80 SPEAKER_01 изменений, но вот про сам компилятор интересно, потому
6053.80 6056.60 SPEAKER_01 что сама команда гордится как раз больше вот этими
6056.60 6057.60 SPEAKER_01 вот изменениями.
6057.60 6059.84 SPEAKER_01 Ну, интересно, интересно, да, давай, что там такое.
6059.84 6062.24 SPEAKER_01 Да, дело в том, что нам это обычно не очень видно, ну,
6062.24 6065.40 SPEAKER_01 то есть мы-то хотим нового синтаксиса, новых фишек,
6065.40 6070.24 SPEAKER_01 а то, что старый компилятор начинает работать лучше
6070.24 6072.84 SPEAKER_01 с нашим кодом, то мы этого, может быть, не всегда замечаем.
6072.84 6076.72 SPEAKER_01 Ну, оптимизации, знаешь, всегда, когда новым компилятором
6076.72 6079.56 SPEAKER_01 откомпилируешь или на новый рантайм запустишь, у тебя
6079.56 6081.96 SPEAKER_01 код становится быстрее работать, это тоже, в принципе,
6081.96 6082.96 SPEAKER_01 приятно.
6082.96 6085.32 SPEAKER_01 Оптимизации – хорошо, да, оптимизации тоже есть,
6085.32 6090.28 SPEAKER_01 но есть большая… большая внимание команда уделила
6090.28 6092.88 SPEAKER_01 там диагностике ошибок, в частности, диагностируется
6092.88 6095.00 SPEAKER_01 как, ну, предупреждение гораздо больше ситуации,
6095.00 6101.68 SPEAKER_01 чем раньше, и сейчас поддерживается больше тримминг для, ну,
6101.68 6103.76 SPEAKER_01 объектов, который раньше не поддерживался, для размеченных
6103.76 6107.44 SPEAKER_01 объединений, для анонимной записи, и если мы вызываем
6107.44 6112.84 SPEAKER_01 код в функцию printf для таких триммингованных записей,
6112.84 6116.60 SPEAKER_01 он тоже становится триммингованным, в общем, там в эту сторону
6116.60 6120.20 SPEAKER_01 тоже команда поработала, и она сделала очень устойчивый,
6120.20 6122.40 SPEAKER_01 ну, гораздо более устойчивый парсер сейчас, то есть,
6122.40 6126.16 SPEAKER_01 если у нас… ну, проблема в чём, когда мы пишем код,
6126.16 6128.84 SPEAKER_01 у нас программа постоянно неправильная, то есть, мы
6128.84 6131.58 SPEAKER_01 что-то начинаем писать, у нас всё ломается, и в это
6131.58 6133.64 SPEAKER_01 время компилятор-то должен нормально показывать вот
6133.64 6136.92 SPEAKER_01 все ключевые слова, он не должен ломаться, и это
6136.92 6138.92 SPEAKER_01 довольно сложно обеспечить, ну, команда вот сделала
6138.92 6144.20 SPEAKER_01 ещё более мощным в этом смысле, то есть, сейчас
6144.20 6147.48 SPEAKER_01 ломается гораздо реже и всё время подсвечивает,
6147.48 6150.48 SPEAKER_01 это очень удобно для программистов, автодополнение стало
6150.48 6152.52 SPEAKER_01 более чётко работать, но это, наверное, уже не только
6152.52 6154.56 SPEAKER_01 компилятор, это вообще сам инструментарий.
6154.56 6157.40 SPEAKER_01 Слушай, а как это вообще у вас автодополнение выстроено?
6157.40 6160.00 SPEAKER_01 То есть, это точно так же каждая EDE-шка решает сама,
6160.00 6161.62 SPEAKER_01 как это дополнять, или, может быть, есть прям специальный
6161.62 6163.80 SPEAKER_01 какой-нибудь language-сервис, или ещё что-то?
6163.80 6164.80 SPEAKER_01 Как это работает?
6165.32 6171.44 SPEAKER_01 Ну, тут я точно не знаю, дело в том, что сейчас нет,
6171.44 6175.66 SPEAKER_01 language-процессора нет, сейчас более тесно связаны F# и,
6175.66 6176.66 SPEAKER_01 скажем, Visual Studio.
6176.66 6180.52 SPEAKER_01 То есть, все эти изменения, они в Visual Studio сделаны,
6180.52 6183.12 SPEAKER_01 да, соответственно, в каком-нибудь там райдере они будут работать
6183.12 6185.56 SPEAKER_01 не так, или их надо специально доделывать?
6185.56 6188.20 SPEAKER_00 В райдере, наверное, не так, хотя тут надо больше
6188.20 6190.40 SPEAKER_01 бы с ребятами пообщаться, которые этим занимаются,
6190.40 6193.16 SPEAKER_01 тут уже начинаются тонкости, в которых я уже не сильно
6193.16 6194.16 SPEAKER_01 разбираюсь.
6194.16 6195.16 SPEAKER_01 Ну, хорошо.
6195.16 6199.28 SPEAKER_01 Но я просто слышал от ребят, кто сидит в команде с F#,
6199.28 6204.64 SPEAKER_01 они пишут в наших чатиках, что собираются отделиться
6204.64 6208.20 SPEAKER_01 от Visual Studio, то есть будет language-сервис-процессор
6208.20 6211.52 SPEAKER_01 такой полноценный, F#-овский даже, Visual Studio, потому что
6211.52 6215.12 SPEAKER_01 они говорят, что это даст больше надёжности для
6215.12 6216.12 SPEAKER_01 их кода.
6216.12 6219.16 SPEAKER_01 Ну, то есть, казалось бы, путь F# такого, знаешь, открытого
6219.16 6221.80 SPEAKER_01 языка, где там сообщество может всё дополнять и так
6221.80 6223.36 SPEAKER_01 далее, то есть, кажется, что этот путь действительно
6223.36 6225.28 SPEAKER_01 говорит о том, что нужен какой-то инструмент, который
6225.28 6227.92 SPEAKER_01 будет в общем и Visual Studio юзаться, там и райдером юзаться,
6227.92 6230.44 SPEAKER_01 Visual Studio кодом юзаться, может, ещё кем-то юзаться,
6230.44 6235.72 SPEAKER_01 и чтобы он одну и ту же IntelliSense выдавал, вот эти же оптимизации
6235.72 6238.64 SPEAKER_01 и ворнинги, которые ты про сейчас рассказываешь.
6238.64 6240.20 SPEAKER_01 То есть, хочется, чтобы они у всех появились во
6240.20 6242.96 SPEAKER_01 всех студиях, независимо от того, кто какой пользуется.
6242.96 6245.96 SPEAKER_01 Ну, команда из райдера тоже очень плотно общается
6245.96 6249.44 SPEAKER_01 с разработчиками языка, там просто настолько, ну,
6249.44 6251.72 SPEAKER_01 даже вот если мы сейчас просто посмотрим, что у
6251.72 6256.28 SPEAKER_01 нас восьмой F# вышел, и написан раздел благодарности, кто
6256.28 6259.96 SPEAKER_01 больше всего внёс хороших интересных правок, то у
6259.96 6263.16 SPEAKER_01 нас, например, Евгений Аудачинок из команды райдера, по-моему,
6263.16 6264.16 SPEAKER_01 на втором месте.
6264.16 6268.00 SPEAKER_01 Да, я скажу, что Евгений – это как раз тот, кто пишет
6268.00 6270.64 SPEAKER_01 для райдера поддержку F#.
6270.64 6274.52 SPEAKER_01 Да-да, и в общем, это очень плотное общение, поэтому
6274.52 6278.36 SPEAKER_01 я думаю, что в райдер это тоже половина точно сразу
6278.36 6280.20 SPEAKER_01 должна работать, а вторую половину допишет.
6280.20 6284.12 SPEAKER_01 Так, отлично, ещё мы что-нибудь упустили, хочешь ещё что-нибудь
6284.12 6285.12 SPEAKER_01 отметить?
6285.12 6288.60 SPEAKER_01 Ну, ты знаешь, там, в принципе, много изменений классных,
6288.60 6290.96 SPEAKER_01 но если мы в них погрузимся, то, наверное, это займёт
6290.96 6293.88 SPEAKER_01 гораздо больше времени, поэтому, ну, так, в целом
6293.88 6297.44 SPEAKER_01 очень хорошо улучшили компилятор и несколько классных синтаксических
6297.44 6301.00 SPEAKER_01 таких фишек внесли люди довольны.
6301.00 6303.72 SPEAKER_01 Ну, отлично, я думаю, что если вы пишете на F#, вы в
6303.72 6306.64 SPEAKER_01 любом случае эту статью сами без нас прочитали,
6306.64 6310.08 SPEAKER_01 и все тонкости, все моменты, которые мы опустили, наверное,
6310.08 6311.08 SPEAKER_01 вы сами знаете.
6311.08 6314.20 SPEAKER_01 Тогда, Марк, последний вопрос идти к тебе, как ты считаешь,
6314.20 6316.86 SPEAKER_01 за последний год стало людей или проектов больше
6316.86 6317.86 SPEAKER_01 на F#?
6317.86 6321.48 SPEAKER_01 Видишь ли ты больше движухи, каких-нибудь новостей, лекций,
6321.48 6322.48 SPEAKER_01 курсов, чего-нибудь ещё?
6322.48 6326.32 SPEAKER_01 Поднимается F# в твоих глазах, в твоём окружении, или всё
6326.32 6328.60 SPEAKER_01 так, какая же у него довольно узкая ниша?
6328.60 6332.96 SPEAKER_01 Довольно узкая, к сожалению, что, конечно, нас всех, F#-еров,
6332.96 6335.88 SPEAKER_01 расстраивает, но, видимо, такая планета, что же тут
6335.88 6336.88 SPEAKER_01 делать?
6336.88 6342.72 SPEAKER_01 Ну, в частности, будем популяризировать с помощью подкастов, докладов,
6342.72 6343.72 SPEAKER_01 что мы ещё можем.
6343.72 6347.60 SPEAKER_01 Да, и с помощью конференций, но, может быть, компания
6347.60 6350.96 SPEAKER_01 Microsoft немного больше начнёт вкладываться в язык, и он
6350.96 6352.72 SPEAKER_01 станет тогда ещё более популярным.
6352.72 6357.32 SPEAKER_01 Отлично, ну, за этим тебе огромное спасибо, просветил,
6357.32 6358.32 SPEAKER_01 рассказал.
6358.32 6361.16 SPEAKER_01 Я думаю, часть F# отлично у нас покрыта.
6361.16 6365.00 SPEAKER_01 Спасибо, Анатолий, что пригласил, всем слушателям больших
6365.00 6369.32 SPEAKER_01 успехов в работе, и скорого приятного Нового года.
6369.32 6371.44 SPEAKER_01 Да, пока, счастливо.
6371.44 6372.44 SPEAKER_01 Пока.
6372.44 6376.60 SPEAKER_01 Ну, вот там ещё по мелочи есть какие-то вещи, которые
6376.60 6379.68 SPEAKER_01 тоже, наверное, знающие люди по F# и без нас сами
6379.68 6382.24 SPEAKER_01 прочитают, но в целом вот так, в принципе, видим, что
6382.24 6386.48 SPEAKER_01 тоже язык развивается, язык растёт, и много интересных
6386.48 6388.12 SPEAKER_01 возможностей в нём есть.
6388.12 6391.72 SPEAKER_01 Ну что ж, стандартные все вещи мы обсудили, пора перейти
6391.72 6394.08 SPEAKER_01 к чему-то нестандартному, необычному в наших анонсах.
6394.08 6399.30 SPEAKER_01 Да, давайте обсудим, я бы сказал, наверное, самый
6399.30 6402.56 SPEAKER_01 действительно нестандартный и, пожалуй, выбивающийся
6402.56 6406.44 SPEAKER_01 из нашего обычного ряда для таких выпусков анонс,
6406.44 6408.64 SPEAKER_01 потому что это штука, про которую мы не говорили
6408.64 6409.64 SPEAKER_01 раньше.
6409.64 6411.84 SPEAKER_01 Это единственная штука, про которую мы весь год
6411.84 6414.80 SPEAKER_01 не говорили, весь год не знали, и когда мы готовили
6414.80 6417.40 SPEAKER_01 выпуск, мы думали, что действительно там уже всё будет по накатанной
6417.40 6420.16 SPEAKER_01 идти, но нет, Microsoft сделал нам большой сюрприз.
6420.16 6423.84 SPEAKER_01 Ну, если внимательно посмотреть и всё прочитать, сюрприз
6423.84 6427.72 SPEAKER_01 на самом деле не такой, чтобы прям супербольшой,
6427.72 6430.28 SPEAKER_01 потому что там проглядывают знакомые корни, про которые
6430.28 6433.16 SPEAKER_01 они сами, в общем-то, и говорят, но, тем не менее, давайте
6433.16 6434.16 SPEAKER_01 по порядочку.
6434.16 6438.92 SPEAKER_01 Мы, конечно же, говорим про .NET Aspire, который вышел под
6438.92 6443.60 SPEAKER_01 лозунгом "упрощаем клауд-нейтиф разработку для .NET восьмого".
6443.60 6446.04 SPEAKER_01 Во-первых, большое спасибо, что назвали так нормально,
6446.04 6448.28 SPEAKER_01 без чего больше не было всяких многочтений, как
6448.28 6449.28 SPEAKER_01 "смаюём", например.
6449.28 6451.32 SPEAKER_01 А вот Aspire – нормальное русское слово.
6451.32 6452.64 SPEAKER_01 Действительно, сойдёт.
6452.64 6459.22 SPEAKER_01 Итак, с чего началась вся эта история, и зачем появился
6459.22 6460.22 SPEAKER_01 вообще Aspire?
6460.22 6463.86 SPEAKER_01 Значит, Microsoft довольно много, по их словам, и так написано
6463.86 6467.48 SPEAKER_01 в анонсе, инвестировала во всякую околооблачную
6467.48 6471.36 SPEAKER_01 разработку, то есть они сделали YARP, это "Yet Another
6471.36 6475.52 SPEAKER_01 Reverse Proxy", релиза, по-моему, 2 назад уже .NET, он, в принципе,
6475.52 6477.96 SPEAKER_01 до сих пор плюс-минус живёт, библиотека для создания
6477.96 6480.80 SPEAKER_01 реверс-прокси, ну и, вероятно, много использующихся внутри
6480.80 6485.44 SPEAKER_01 Microsoft, хотя я слышал и вне Microsoft примеры, когда на
6485.44 6486.96 SPEAKER_01 нём что-то делали вполне такое.
6486.96 6489.88 SPEAKER_01 Да, да, я тоже видел, в принципе, вне Microsoft строят хороший
6489.88 6492.16 SPEAKER_01 реверс-прокси и, в принципе, все счастливы.
6492.16 6493.16 SPEAKER_01 Да.
6493.16 6495.12 SPEAKER_01 Ну, во-вторых, вот мы сегодня уже упоминали про контейнеры
6495.12 6497.16 SPEAKER_01 и много раз говорили, то есть тоже оптимизация размера
6497.16 6500.60 SPEAKER_01 контейнеров, ну и много-много-много всяких разных других вещей,
6500.60 6503.02 SPEAKER_01 которые вроде как приближают нас к счастливому миру
6503.02 6507.60 SPEAKER_01 клаудных разработки, но разработчики, они же всегда
6507.60 6509.80 SPEAKER_01 всем недовольны, ну не всем, может быть, но разработчики
6509.80 6513.40 SPEAKER_01 всегда хотят большего, и поэтому по мнению Microsoft,
6513.40 6516.96 SPEAKER_01 опять же, по их отзывам, разработчики говорили,
6516.96 6519.40 SPEAKER_01 блин, всё равно сложно делать эти клаудные приложения,
6519.40 6522.52 SPEAKER_01 потому что ты сильно отвлекаешься на всякие вот эти вот облачные
6522.52 6525.68 SPEAKER_01 штуки, потому что все же помнят все эти, да, fallacies
6525.68 6531.44 SPEAKER_01 of the distributed computing, да, про то, что там сеть надёжна,
6531.44 6534.88 SPEAKER_01 точнее наоборот, да, сеть ненадёжна, там нужно всё
6534.88 6539.74 SPEAKER_01 перетраить, вот это всё, и на нормальную работу с
6539.74 6542.52 SPEAKER_01 сетью и с прочими проблемами, которые могут возникнуть
6542.52 6545.32 SPEAKER_01 в распределённых приложениях, уходит некоторое количество
6545.32 6550.64 SPEAKER_01 сил, времени, и мы на этой инфраструктуре, ну работая
6550.64 6552.48 SPEAKER_01 над этой инфраструктурой, отвлекаемся от основных
6552.48 6556.32 SPEAKER_01 бизнес-целей, и хочется как-то всё это ещё больше
6556.32 6557.32 SPEAKER_01 упростить.
6557.32 6561.28 SPEAKER_01 И вот тут появляется тот нет Aspire, который создан
6561.28 6566.76 SPEAKER_01 для, как сейчас, тут по-английски надо прочитать, это cloud
6566.76 6572.76 SPEAKER_01 ready stack for building observable production-ready distributed applications, короче, пользуйтесь
6572.76 6575.54 SPEAKER_01 Aspire, вы будете production-ready, мне сильно нравится слово
6575.54 6578.68 SPEAKER_01 production-ready, а так мы типа пишем не production-ready приложение,
6578.68 6580.44 SPEAKER_01 их нужно ещё как-то готовить к продакшену.
6580.44 6584.68 SPEAKER_01 Ну да-да, какие-то десктопные в столбе проекты, они не
6584.68 6585.68 SPEAKER_01 для продакшена.
6585.68 6588.32 SPEAKER_01 Если вы возьмёте Aspire, больше не будет никаких pet-проектов
6588.32 6592.44 SPEAKER_01 в столб, сразу всё будет production-ready и cloud-native.
6592.44 6596.20 SPEAKER_01 С самого начала, это важно, и это здорово, что они это
6596.20 6599.52 SPEAKER_01 говорят, они говорят, что это opinionated stack, то есть это
6599.52 6601.98 SPEAKER_01 не что-то универсальное, что они считают, что все
6601.98 6605.00 SPEAKER_01 должны теперь заадоптить, это их видение того, как
6605.00 6606.00 SPEAKER_01 это должно быть.
6606.00 6609.40 SPEAKER_01 То есть подходит использовать и не подходит, ну, сорян,
6609.40 6611.44 SPEAKER_01 как бы, но это наше мнение.
6611.44 6616.24 SPEAKER_01 И состоит этот Aspire из некоторого набора тщательно отобранных,
6616.24 6619.60 SPEAKER_01 ну или на самом деле созданных компонент, которые включают
6619.60 6623.72 SPEAKER_01 в себя всякие service discovery, телеметрии, обеспечения
6623.72 6626.32 SPEAKER_01 надёжности, health-checks и так далее.
6626.32 6629.16 SPEAKER_01 И дальше они используют очень интересную формулировку,
6629.16 6633.24 SPEAKER_01 в английском она звучит как sophisticated but simple, local
6633.24 6636.44 SPEAKER_01 development experience, то есть он сложный, но простой.
6636.44 6639.28 SPEAKER_01 Как-то по-русски перевести вроде странно, но слово
6639.28 6644.04 SPEAKER_01 sophisticated, оно как бы подразумевает, что всё-таки он такой сложно
6644.04 6646.72 SPEAKER_01 навороченный, но он при этом просто в использовании.
6646.72 6649.08 SPEAKER_01 Я слышал прекрасный перевод – извращенный.
6649.08 6653.24 SPEAKER_01 Настолько сложный, что извращение какое-то получается.
6653.24 6655.48 SPEAKER_01 Ну, на самом деле, глядя на примеры, не такое, чтобы,
6655.48 6658.96 SPEAKER_01 вот в том-то и дело, что он simple, сейчас формально
6658.96 6661.48 SPEAKER_01 вышел в первый превью, то есть сейчас это пока всё-таки
6661.48 6666.12 SPEAKER_01 превью, а general availability планируется в следующем
6666.12 6667.12 SPEAKER_01 году весной.
6667.12 6672.20 SPEAKER_01 При этом эта штука, этот toolkit, я не знаю, как это
6672.20 6676.00 SPEAKER_01 назвать, пакет, хотя это не пакет, это технология,
6676.00 6679.20 SPEAKER_01 не совсем технология, в общем, эта штука, она является
6679.20 6682.52 SPEAKER_01 официальной частью дотнет 8, и дальше будет версионироваться
6682.52 6685.44 SPEAKER_01 вместе с дотнетом, ну как бы в будущем, то есть будет
6685.44 6688.92 SPEAKER_01 там эспайр 9, эспайр 10 и всё такое прочее.
6688.92 6693.60 SPEAKER_01 Для своей работы она требует в Visual Studio превью, ну и восьмёрки,
6693.60 6694.60 SPEAKER_01 естественно.
6694.60 6697.04 SPEAKER_01 Теоретический тулинг пока не полностью готов для
6697.04 6698.96 SPEAKER_01 кросс-платформенности, поскольку это первое превью,
6698.96 6701.76 SPEAKER_01 оно сейчас довольно сильно завязано на Visual Studio, но это
6701.76 6704.28 SPEAKER_01 дело будет меняться, и будет нормально работать под
6704.28 6707.96 SPEAKER_01 Linux и Mac в том числе, я про это чуть-чуть дальше скажу,
6707.96 6712.16 SPEAKER_01 где там, я так понимаю, есть пока трудности.
6712.16 6716.16 SPEAKER_01 Начнём мы с того, что, первое, что, во-первых, в Visual Studio
6716.16 6719.48 SPEAKER_01 вы теперь можете поставить, это прям, как там это называется,
6719.48 6722.00 SPEAKER_01 это не workload, это individual component, по-моему, это называется,
6722.00 6723.88 SPEAKER_01 там можно workloads ставить, а можно индивидуальные
6723.88 6724.88 SPEAKER_01 компоненты.
6724.88 6726.76 SPEAKER_01 Короче, это теперь компонент, можно сказать dotnet, эспайр,
6726.76 6727.76 SPEAKER_01 что-то там.
6727.76 6730.72 SPEAKER_01 И у вас, во-первых, появится теперь новый темплейт, шаблончик
6730.72 6734.28 SPEAKER_01 dotnet, эспайр, стартер.
6734.28 6736.64 SPEAKER_01 Если вы создадите проект с помощью этого шаблончика,
6736.64 6740.44 SPEAKER_01 у вас создастся обычный solution, который будет состоять
6740.44 6742.96 SPEAKER_01 из backend приложения, ну этого стандартного, который
6742.96 6746.96 SPEAKER_01 про погоду, мне кажется, он во многих шаблончиках
6746.96 6747.96 SPEAKER_01 используется.
6747.96 6753.00 SPEAKER_01 У вас создастся проект с фронтендом, с Blazor, причём
6753.00 6755.96 SPEAKER_01 эти два приложения будут друг с другом связаны,
6755.96 6759.56 SPEAKER_01 они будут дополнительно использовать raisescash, а также,
6759.56 6761.80 SPEAKER_01 поскольку это не просто там шаблончик какого-то
6761.80 6765.80 SPEAKER_01 там такого, backend с фронтендом, а dotnet, эспайр, шаблончик,
6765.80 6768.70 SPEAKER_01 у вас создастся два новых проекта.
6768.70 6773.88 SPEAKER_01 Один проект будет называться имя вашего приложения .apphost,
6773.88 6776.92 SPEAKER_01 а второй будет называться имя вашего приложения .servicedefaults.
6776.92 6781.12 SPEAKER_01 Apphost является выполнимым, а servicedefaults - это библиотечка
6781.12 6783.04 SPEAKER_01 для лейка.
6783.04 6784.04 SPEAKER_01 Зачем нужен Apphost?
6784.04 6787.36 SPEAKER_01 Apphost нужен, собственно, для того, чтобы запускать
6787.36 6789.96 SPEAKER_01 всё, что нужно для того, чтобы запустить ваше приложение,
6789.96 6792.80 SPEAKER_01 включая ваше само приложение.
6792.80 6795.24 SPEAKER_01 Мы сейчас более подробно всё разберём внутри, но
6795.24 6799.34 SPEAKER_01 смысл такой, что именно его вы выбираете как стартап
6799.34 6804.20 SPEAKER_01 проекта в Visual Studio, и оно запускается, оно запускает
6804.20 6808.08 SPEAKER_01 всё, что надо, а Visual Studio, некоторой магией, оттачится
6808.08 6811.00 SPEAKER_01 ко всем запущенным приложениям, которые там будут.
6811.00 6814.28 SPEAKER_01 То есть, по сути, вы можете запустить сразу много кусочков
6814.28 6817.04 SPEAKER_01 вашего приложения и отложить в студии сразу всё.
6817.04 6821.96 SPEAKER_01 А servicedefaults - это длелька, который, ну, проект, по сути,
6821.96 6824.84 SPEAKER_01 csproj, на который ссылаются все остальные проекты в
6824.84 6827.96 SPEAKER_01 вашем солюшене, в котором заданы на самом деле просто
6827.96 6833.92 SPEAKER_01 некоторые общие настройки для тех самых cloud-native cross-cutting
6833.92 6837.92 SPEAKER_01 concerns, то есть service discovery, telemetry, health-checks и всё такое
6837.92 6838.92 SPEAKER_01 прочее.
6838.92 6842.96 SPEAKER_01 Кроме того, значит, это то, что будет темплейтом, если
6842.96 6848.52 SPEAKER_01 вы всё это запустите в студии, то у вас, помимо
6848.52 6850.56 SPEAKER_01 того, что запустится само приложение, запустится
6850.56 6854.42 SPEAKER_01 фронт-энд, бэк-энд, у вас ещё в браузере откроется
6854.42 6856.56 SPEAKER_01 дашборд автоматически.
6856.56 6860.08 SPEAKER_01 Это некоторое веб-приложение, которое сервится из вот
6860.08 6865.92 SPEAKER_01 этого самого app-host, который является таким, как они
6865.92 6870.04 SPEAKER_01 называют, центральным хабом для наблюдения и инспекции
6870.04 6871.64 SPEAKER_01 ваших приложений.
6871.64 6873.56 SPEAKER_01 Оно предназначено только для девелопмента, то есть
6873.56 6875.72 SPEAKER_01 это не что-то, что вы будете ставить в продакшен, конечно
6875.72 6879.28 SPEAKER_01 же, но там вы можете смотреть всё, что вы хотите про ваше
6879.28 6880.28 SPEAKER_01 приложение.
6880.28 6881.28 SPEAKER_01 Подробно всё расскажу чуть дальше.
6881.28 6884.56 SPEAKER_01 И на самом деле, если вы вот это всё прослушали,
6884.56 6888.56 SPEAKER_01 то это всё довольно сильно, включая дашборд, напоминает
6888.56 6891.48 SPEAKER_01 одну штуку, про которую мы рассказывали, слушай,
6891.48 6895.00 SPEAKER_01 наверное, уже года два назад.
6895.00 6896.00 SPEAKER_01 Давно, короче.
6896.00 6898.92 SPEAKER_01 Первый раз, да, появилась она года два назад.
6898.92 6899.92 SPEAKER_01 Это project.ai.
6899.92 6903.12 SPEAKER_01 Project.ai, да, очень сильно похож, потому что именно
6903.12 6905.92 SPEAKER_01 он как бы собирал, например, все проекты в кучу, именно
6905.92 6909.84 SPEAKER_01 он давал визуальную UI для того, чтобы посмотреть
6909.84 6910.84 SPEAKER_01 на эти проекты.
6910.84 6914.80 SPEAKER_01 Именно он извлекал метрики, логии и всё такое из этих
6914.80 6915.80 SPEAKER_01 проектов.
6915.80 6918.00 SPEAKER_01 Я думаю, что там от project.ai прямо много взято.
6918.00 6922.24 SPEAKER_01 Да, project.ai был анонсирован, что это эксперимент, про
6922.24 6924.88 SPEAKER_01 него не было сказано, что это там production-ready что-то
6924.88 6927.28 SPEAKER_01 там, то есть это просто эксперимент для того, чтобы
6927.28 6928.28 SPEAKER_01 что-то попробовать.
6928.28 6932.32 SPEAKER_01 И он был признан, я так понимаю, ну плюс-минус успешным,
6932.32 6939.40 SPEAKER_01 на основе него, собственно, был рождён Aspire, и что забавно
6939.40 6943.64 SPEAKER_01 получилось, в репозитории project.ai на GitHub было заведено
6943.64 6946.12 SPEAKER_01 issue, где было сказано, вот всё, короче, эксперимент
6946.12 6951.40 SPEAKER_01 окончен, все дела, мы эксперимент завершаем, пользуйтесь
6951.40 6954.96 SPEAKER_01 dotnet Aspire и дальше, значит, я типа ещё сколько-нибудь
6954.96 6958.64 SPEAKER_01 оставлю комменты к этой issue открыты, если вы хотите
6958.64 6961.64 SPEAKER_01 что-то ещё сказать, и после чего репозиторию заархивировали,
6961.64 6965.68 SPEAKER_01 а в архивированной репозитории, как известно, нельзя писать
6965.68 6966.68 SPEAKER_01 комменты.
6966.68 6969.92 SPEAKER_01 Короче, ну вот так вот project.ai закрыт, репозиторий заархивирован,
6969.92 6971.68 SPEAKER_01 ну в смысле он редонально, по-моему, доступен на GitHub,
6971.68 6974.44 SPEAKER_01 но он типа архивит, и поэтому, если вы вдруг пользовались
6974.44 6977.36 SPEAKER_01 project.ai, скорее всего, вам нужно переезжать на Aspire,
6977.36 6978.36 SPEAKER_01 так или иначе.
6978.36 6981.28 SPEAKER_01 Ну, конечно, тай останется работать, но никаких обновлений
6981.28 6982.28 SPEAKER_01 больше к нему не войдет.
6982.28 6985.84 SPEAKER_01 Ну вот у тай там были, он больше как отдельный инструмент
6985.84 6987.72 SPEAKER_01 существовал, т.е. у него там был какой-то формат
6987.72 6990.64 SPEAKER_01 конфигов, например, который, скорее всего, у Aspire не будет,
6990.64 6992.36 SPEAKER_01 потому что весь Aspire настраивается через код.
6992.36 6994.36 SPEAKER_01 Да, про это я тоже расскажу.
6994.36 6995.36 SPEAKER_01 А, давай.
6995.36 6996.36 SPEAKER_01 Давай-давай.
6996.36 7001.00 SPEAKER_01 Там статья большая, я когда пытался прикинуть, как это
7001.00 7003.36 SPEAKER_01 рассказывать, получалось, что как ни зайди, всё равно
7003.36 7005.32 SPEAKER_01 то одно не расскажешь, то другое не расскажешь.
7005.32 7008.48 SPEAKER_01 Поэтому рассказываю примерно, как идёт статья, чтобы потихонечку
7008.48 7009.48 SPEAKER_01 углубляться.
7009.48 7012.16 SPEAKER_01 Значит, итак, мы поняли, что Aspire — это некоторый
7012.16 7016.16 SPEAKER_01 набор компонент, который как-то магически позволяет
7016.16 7018.60 SPEAKER_01 удобно работать девелоперам с клауд-нейти в приложении.
7018.60 7020.40 SPEAKER_01 Что же такое эти самые компоненты?
7020.40 7023.12 SPEAKER_01 Значит, компоненты — это, на самом деле, нугет-пакеты,
7023.12 7027.36 SPEAKER_01 у которых единственный признак того, что это дотнет-аспайр-компонент
7027.36 7029.96 SPEAKER_01 — то, что у него в имени есть секция с названием
7029.96 7030.96 SPEAKER_01 Aspire.
7030.96 7034.40 SPEAKER_01 Называется там Aspire.что-нибудь.
7034.40 7037.12 SPEAKER_01 Каждый компонент, для того чтобы быть вот этим самым
7037.12 7039.20 SPEAKER_01 компонентом, этот нугет-пакет, обязан иметь следующие
7039.20 7040.20 SPEAKER_01 штуки.
7040.20 7044.16 SPEAKER_01 Во-первых, в нём должна быть JSON-схема для сеттингов
7044.16 7048.36 SPEAKER_01 в AppSettings.json, ну, в смысле, схема, которую редактор
7048.36 7050.60 SPEAKER_01 может использовать для того, чтобы обеспечить
7050.60 7053.44 SPEAKER_01 вам IntelliSense при заполнении ваших AppSettings потом для
7053.44 7054.44 SPEAKER_01 этого компонента.
7054.44 7060.20 SPEAKER_01 Второе, внутри этого компонента, что бы этот компонент ни
7060.20 7064.08 SPEAKER_01 делал, он обязательно должен использовать всякие паттерны
7064.08 7068.36 SPEAKER_01 для обеспечения надёжности, т.е. timeout, retry, circuit breakers,
7068.36 7071.24 SPEAKER_01 т.е. их можно как-то настраивать через те самые сеттинги,
7071.24 7074.00 SPEAKER_01 но они должны быть уже там, т.е. не должно быть нужно
7074.00 7076.96 SPEAKER_01 сверху на компонент наворачивать условный поле, он должен
7076.96 7077.96 SPEAKER_01 быть внутри.
7077.96 7081.24 SPEAKER_01 Компонент обязательно должен использовать health-чеки,
7081.24 7085.60 SPEAKER_01 и обязательно должен нативно интегрироваться в, так
7085.60 7089.00 SPEAKER_01 скажем, всё, что касается логов, метрик и трейсов,
7089.00 7092.76 SPEAKER_01 т.е. через ilogger, через класс метр, через класс activity.
7092.76 7095.64 SPEAKER_01 И последнее, нужно обязательно иметь extension method, который
7095.64 7099.56 SPEAKER_01 позволяет, собственно, сделать так, чтобы всю внутреннюю
7099.56 7102.92 SPEAKER_01 эту кухню компонента можно было добавить одним простым
7102.92 7105.92 SPEAKER_01 вызовом extension метода, ну, возможно, понятное дело,
7105.92 7106.92 SPEAKER_01 с какими-то настройками.
7106.92 7111.24 SPEAKER_01 В принципе, схема вполне знакомая, мы много как делали,
7111.24 7114.08 SPEAKER_01 вы добавляете какой-нибудь EntityFrameworkCore, да, и вы говорите
7114.08 7118.16 SPEAKER_01 ефта-кор, или там в чём-нибудь в таком духе, а он сам уже
7118.16 7121.60 SPEAKER_01 внутри, иллюстрирует db-контексты, как надо, и так далее, или
7121.60 7123.40 SPEAKER_01 там add-ready, в чём-нибудь в таком духе, вот.
7123.40 7127.20 SPEAKER_01 Но здесь всё то же самое, только с health-чеками, resilience,
7127.20 7131.44 SPEAKER_01 там, retry и всем добром, и интеллисенсом для сеттингов
7131.44 7132.44 SPEAKER_01 через, в конфиге.
7132.44 7133.44 SPEAKER_01 Вот.
7133.44 7139.36 SPEAKER_01 И по сути, эта компонента, она является обёрткой
7139.36 7146.24 SPEAKER_01 для какой-нибудь из библиотек, нужных для работы с другими
7146.24 7151.64 SPEAKER_01 продуктами или с другими приложениями, готовая для
7151.64 7153.56 SPEAKER_01 использования в Cloud Native среде.
7153.56 7157.20 SPEAKER_01 То есть, если говорить простым языком, вот есть у вас какой-нибудь,
7157.20 7162.04 SPEAKER_01 не знаю, Redis клиент, есть .NET-ный пакет Redis клиент,
7162.04 7165.04 SPEAKER_01 единственное, что он предоставляет, он предоставляет некоторый
7165.04 7166.68 SPEAKER_01 набор классов, которые позволяют вам указать
7166.68 7170.48 SPEAKER_01 connection string и начать пользоваться Redis.
7170.48 7174.68 SPEAKER_01 Но там не будет никаких timeout, там не будет, их можно
7174.68 7177.40 SPEAKER_01 задать, но это нужно делать вручную, там не будет никаких
7177.40 7181.56 SPEAKER_01 retry, их можно задать, притащив поле, но это будет вручную,
7181.56 7184.40 SPEAKER_01 там, возможно, будет какой-то логинг, возможно, будут
7184.40 7187.12 SPEAKER_01 какие-то метрики, но не факт, что эти метрики автоматически
7187.12 7190.52 SPEAKER_01 экспортятся в нужный OpenTelemetry коллектор, скорее всего,
7190.52 7192.24 SPEAKER_01 вам нужно будет написать небольшой код, который
7192.24 7195.80 SPEAKER_01 заберет эти метрики из нужных мест библиотеки и отдаст
7195.80 7198.28 SPEAKER_01 их в OpenTelemetry коллектор, и вот это вот все.
7198.28 7200.24 SPEAKER_01 Так вот, чтобы вот это все не писать руками, это все
7200.24 7203.60 SPEAKER_01 обертывается в стандартный .NET-пакет и поставляется
7203.60 7204.60 SPEAKER_01 вам.
7204.60 7209.40 SPEAKER_01 И вы в клиентском коде говорите не add Redis, а вот есть новый
7209.40 7213.56 SPEAKER_01 этот extension метод addRedis что-нибудь, который внутри вызовет
7213.56 7217.84 SPEAKER_01 addRedis, но правильно настроенный, со всеми нужными настроечками.
7217.84 7221.72 SPEAKER_01 И вы не паритесь про все вот эти клаудные эти штуки.
7221.72 7224.40 SPEAKER_01 Помимо компонент, компоненты — это штука, которую вы
7224.40 7228.52 SPEAKER_01 будете использовать в проектах, которые пишете
7228.52 7229.52 SPEAKER_01 вы.
7229.52 7233.16 SPEAKER_01 То есть вот в примере с шаблончиком, этот самый
7233.16 7236.44 SPEAKER_01 компонент, например, Redis'а, вы на него будете ссылаться
7236.44 7240.30 SPEAKER_01 из ваших проектов, там, бэкэнда или фронтэнда.
7240.30 7245.48 SPEAKER_01 Но также есть тот самый хост, и если посмотреть
7245.48 7248.52 SPEAKER_01 на код, там будет видно, что там или, например, если
7248.52 7251.60 SPEAKER_01 вы посмотрите на фронтэнд, вот давайте с этой стороны
7251.60 7254.36 SPEAKER_01 зайдем, если вы посмотрите на код фронтэнда в Blazor'е,
7254.36 7257.60 SPEAKER_01 там будет написано addHttpClient, и там внутри написан такой
7257.60 7264.30 SPEAKER_01 странный url Http://api.service, это какое-то такое странное
7264.30 7266.00 SPEAKER_01 доменное имя, не то, не сё.
7266.00 7267.00 SPEAKER_01 Что это такое?
7267.00 7269.52 SPEAKER_01 Вот здесь как раз становится важным, что у нас есть тот
7269.52 7271.72 SPEAKER_01 самый app-хост, который всех запускает.
7271.72 7277.88 SPEAKER_01 У нас появился новый билдер, у нас теперь есть, в app-хосте
7277.88 7280.80 SPEAKER_01 используется штука под названием DistributedApplication,
7280.80 7284.40 SPEAKER_01 это такой класс, у которого есть метод createBuilder, в который
7284.40 7287.28 SPEAKER_01 вы начинаете кодом, как правильно сказал Толя,
7287.28 7289.84 SPEAKER_01 накидывать, а из чего у вас состоит приложение.
7289.84 7293.64 SPEAKER_01 Вы туда можете сказать addTheProject и указать путь к вашему
7293.64 7297.52 SPEAKER_01 там css-проекту, вы можете сказать addTheContainer и добавить
7297.52 7300.80 SPEAKER_01 любой docker-контейнер, вы можете сказать даже addExecutable
7300.80 7303.44 SPEAKER_01 и добавить просто любой исполнимый файл, причем
7303.44 7306.44 SPEAKER_01 дальше вы можете добавить ссылки, что, например, ваш
7306.44 7314.72 SPEAKER_01 addProject там frontend ссылается на project-backend, и project-backend
7314.72 7317.04 SPEAKER_01 для frontend называется api-service.
7317.04 7323.92 SPEAKER_01 И тогда, когда у вас будет во frontend коде ссылка на http://api-service,
7323.92 7327.40 SPEAKER_01 вот этот хост будет знать, что api-service — это на самом
7327.40 7331.04 SPEAKER_01 деле то, где он поднял backend, с тем портом, потому что
7331.04 7334.12 SPEAKER_01 порты вы нигде не указываете, портов нету.
7334.12 7339.12 SPEAKER_01 Это одна из целей, которой преследовали авторы, максимально
7339.12 7342.48 SPEAKER_01 изолировать девелопера, когда вы делаете все на
7342.48 7346.08 SPEAKER_01 локальной машине, от необходимости какой-то манипуляции,
7346.08 7347.80 SPEAKER_01 connection-стрингами, портами, еще чем-то.
7347.80 7349.68 SPEAKER_01 Вы просто говорите, вот этот frontend должен найти
7349.68 7353.96 SPEAKER_01 backend по адресу api-service, или там вот этот backend должен
7353.96 7358.24 SPEAKER_01 найти redis по адресу redis, или там redis для этого проекта,
7358.24 7359.24 SPEAKER_01 все, точка.
7359.24 7361.60 SPEAKER_01 На каком порту redis, откуда он возьмется, из какого
7361.60 7364.44 SPEAKER_01 контейнера он поднимется, неважно, главное, что он
7364.44 7365.44 SPEAKER_01 есть.
7365.44 7366.44 SPEAKER_01 Вот.
7366.44 7368.08 SPEAKER_01 Это, в общем-то, цель.
7368.08 7375.08 SPEAKER_01 И теперь статья зацикливается и снова говорит, а теперь
7375.08 7376.44 SPEAKER_01 снова посмотрят на компоненты.
7376.44 7379.72 SPEAKER_01 Ну, я, собственно, про это уже немножко рассказал,
7379.72 7382.40 SPEAKER_01 то есть раньше вам нужно было добавить там клиентскую
7382.40 7386.88 SPEAKER_01 либу, посмотреть, откуда взять для нее health-чеки,
7386.88 7390.28 SPEAKER_01 добавить все это в di правильно, поманипулировать connection-стрингами,
7390.28 7394.52 SPEAKER_01 откуда-то их взять в настройках, правильно настроить логи,
7394.52 7396.52 SPEAKER_01 телеметрию и вот это вот все.
7396.52 7400.24 SPEAKER_01 Сейчас достаточно просто добавить package от dotnet-aspire
7400.24 7403.00 SPEAKER_01 для того же redis, позвать add-redis, ну и дополнительно,
7403.00 7407.04 SPEAKER_01 если надо, что-то заверрайтить из того, что можно сейчас
7407.04 7411.28 SPEAKER_01 добавить, то есть какие компоненты, какие внешние
7411.28 7413.40 SPEAKER_01 продукты, можно сказать, поддержаны вот такими
7413.40 7415.52 SPEAKER_01 пакетджами, которые уже разработаны.
7415.52 7419.04 SPEAKER_01 Вы можете заюзать pass-grew, причем просто pass-grew, либо
7419.04 7420.88 SPEAKER_01 pass-grew с оберткой e в core.
7420.88 7424.92 SPEAKER_01 Можно заюзать rabbit-mq, можно заюзать redis, в нескольких
7424.92 7427.72 SPEAKER_01 вариантах можно просто redis, тогда он будет для вас
7427.72 7431.92 SPEAKER_01 как бы, ну такой, нативный redis, используя, как хочется.
7431.92 7435.28 SPEAKER_01 Можно заюзать его для distributed caching, можно заюзать его для
7435.28 7438.64 SPEAKER_01 output caching, это уже фичи spnet, да, помните, там есть
7438.64 7444.24 SPEAKER_01 типа spnet-core-output-caching, либо аналог memory-cache, который
7444.24 7449.32 SPEAKER_01 distributed, можно использовать сервер тоже, простой, с
7449.32 7452.32 SPEAKER_01 добавкой nct-framework-core, ну и набор там ажер-специфик
7452.32 7454.24 SPEAKER_01 штук, понятно, майкрософт не могли обойти вниманием
7454.24 7458.08 SPEAKER_01 ажур, и там для blob-storage, космос-dbg, и волта, сервис-бас
7458.08 7462.48 SPEAKER_01 и storage-q тоже есть вот такие пакеты для dotnet-aspire, и здесь
7462.48 7465.48 SPEAKER_01 они явно пишут, что мы как бы ожидаем, что комьюнити
7465.48 7469.88 SPEAKER_01 докидает нам сюда пакетов для каких-то популярных
7469.88 7472.20 SPEAKER_01 штук, типа для кавки мы пока не написали, ну давайте
7472.20 7476.72 SPEAKER_01 вот, в принципе это довольно straightforward, да, и просто
7476.72 7478.76 SPEAKER_01 и понятно, как писать такие компоненты.
7478.76 7482.76 SPEAKER_01 Ну да, это по сути такая плагинная система получается,
7482.76 7485.40 SPEAKER_01 где как раз плагинами являются вот эти пакеты, и поставлять
7485.40 7488.44 SPEAKER_01 их может абсолютно кто угодно, и будет прекрасно,
7488.44 7492.40 SPEAKER_01 если комьюнити действительно законтребитит те компоненты,
7492.40 7493.40 SPEAKER_01 которыми они пользуются.
7493.40 7494.40 SPEAKER_01 Ну да, комьюнити или производители.
7494.40 7498.44 SPEAKER_01 Ну производители тоже да, ну просто производителям
7498.44 7500.84 SPEAKER_01 например кавки, скорее всего, надо на это наплевать,
7500.84 7503.92 SPEAKER_01 а вот те, кто пользуется кавкой, вполне могут нарисовать
7503.92 7506.28 SPEAKER_01 сюда и какое-нибудь, не просто подключение к кавке,
7506.28 7509.48 SPEAKER_01 а действительно и с ретраями, и с полей, и с кэшированием,
7509.48 7510.92 SPEAKER_01 и с коннекшенами, и с чем-то еще.
7510.92 7513.00 SPEAKER_01 И самое интересное, что теперь это можно как бы
7513.00 7516.92 SPEAKER_01 всем сообществам смотреть, предлагать какие-то pull-requests
7516.92 7519.40 SPEAKER_01 и улучшать, то есть вы теперь этот компонент делаете
7519.40 7522.32 SPEAKER_01 не у себя где-то там под столом, все эти ретро-полисы
7522.32 7525.04 SPEAKER_01 навешиваете, а какие-то best-practices собираете вообще
7525.04 7526.04 SPEAKER_01 со всего мира.
7526.04 7531.96 SPEAKER_01 Все так, теперь про то, что они называют application
7531.96 7532.96 SPEAKER_01 model.
7532.96 7537.20 SPEAKER_01 Это как раз то, что идет у вас в проект под названием
7537.20 7538.20 SPEAKER_01 app-host.
7538.20 7542.64 SPEAKER_01 По сути, это способ выразить то, что вам нужно для вашего
7542.64 7545.40 SPEAKER_01 приложения в терминах языка C#.
7545.40 7549.12 SPEAKER_01 Причем они указывают, что типа, ну типа, for now, то есть
7549.12 7553.08 SPEAKER_01 вероятно они готовы рассмотреть возможность выражать
7553.08 7556.32 SPEAKER_01 это на каких-то других языках, ну как минимум на F# возможно
7556.32 7557.32 SPEAKER_01 это можно будет делать.
7557.32 7560.72 SPEAKER_01 Не знаю на тему совсем других, на каком-нибудь
7560.72 7563.80 SPEAKER_01 Go или Java или Rust, может быть этого нельзя будет делать,
7563.80 7564.80 SPEAKER_01 ну фиг знает, посмотрим.
7564.80 7569.56 SPEAKER_01 И вот этот вот app-host, он ответственен за оркестрацию
7569.56 7574.12 SPEAKER_01 и за запуск всего вот этого зоопарка ваших зависимостей
7574.12 7576.12 SPEAKER_01 на вашей машинке-разработчике.
7576.12 7579.12 SPEAKER_01 Я думаю, в первую очередь мы должны поддержать язык
7579.12 7582.16 SPEAKER_01 YAML для выражения структуры нашего приложения.
7582.16 7586.12 SPEAKER_01 Вот про это будет отдельно, они очень не хотят, YAML ни
7586.12 7587.12 SPEAKER_01 в коем случае.
7587.12 7589.72 SPEAKER_01 Не, ну может если комьюнити напишет, пожалуйста, но
7589.72 7593.96 SPEAKER_01 видимо они не хотят, значит, мы дойдем до YAML и всего
7593.96 7594.96 SPEAKER_01 остального.
7594.96 7600.84 SPEAKER_01 Что они умеют, значит, точнее не так, не что оно умеет,
7600.84 7604.12 SPEAKER_01 а в каких терминах оно мыслит, вот этот Application Model, с чем
7604.12 7605.48 SPEAKER_01 оно умеет работать.
7605.48 7608.92 SPEAKER_01 Оно умеет работать с так называемыми, они это называют
7608.92 7613.26 SPEAKER_01 Building Resources, хотя из Building там есть всего лишь Project,
7613.26 7617.16 SPEAKER_01 ну .NET, CSSProj, видимо FProj можно будет использовать когда-нибудь,
7617.16 7619.38 SPEAKER_01 может уже и можно, не знаю, они вероятно на нем просто
7619.38 7621.24 SPEAKER_01 вызывают .NET Build, грубо говоря.
7621.24 7623.68 SPEAKER_01 Можно использовать контейнер, можно использовать исполнимые
7623.68 7624.68 SPEAKER_01 файлы.
7624.68 7627.72 SPEAKER_01 Кроме того, у них есть штука под названием Cloud Agnostic
7627.72 7630.76 SPEAKER_01 Extensions, ну это понятно, по-згаря, Rabbit, Redis и SQL Server, то есть вы
7630.76 7633.58 SPEAKER_01 можете указать, что смотрите, для моего приложения нужно
7633.58 7637.04 SPEAKER_01 поднять там Redis, и он будет знать, как поднять Redis.
7637.04 7640.48 SPEAKER_01 Вот, ну и ажур, понятно, тоже есть, это Storage, Cosmos,
7640.48 7645.10 SPEAKER_01 Key Vault, Redis и Service Bus, они поднимутся в ажуре, соответственно,
7645.10 7649.10 SPEAKER_01 получат к нему Connection String и вашим локальным приложением
7649.10 7653.56 SPEAKER_01 смогут сказать, окей, вот твой там Service Bus там-то,
7653.56 7658.16 SPEAKER_01 и для тебя прозрачно, автоматически поднялся типа Service Bus в
7658.16 7662.12 SPEAKER_01 ажуре, в твоей подписке, вот, то есть в принципе
7662.12 7665.12 SPEAKER_01 штука позволяет вам сказать, из чего ваше приложение
7665.12 7668.76 SPEAKER_01 состоит, как его запустить, ну и какие связи между,
7668.76 7672.28 SPEAKER_01 и дальше самое интересное, это, конечно, Developer Dashboard,
7672.28 7674.76 SPEAKER_01 Developer Dashboard это штука, которая позволяет вам смотреть,
7674.76 7677.68 SPEAKER_01 что вообще происходит в вашем приложении, она работает
7677.68 7680.38 SPEAKER_01 только когда работает App Host, то есть она является
7680.38 7683.36 SPEAKER_01 его неотъемлемой частью, по крайней мере, сейчас,
7683.36 7686.84 SPEAKER_01 и там есть несколько разделов, если вы там слева увидите
7686.84 7689.40 SPEAKER_01 менюшку, там есть несколько разделов, Projects, она позволяет
7689.40 7692.76 SPEAKER_01 вам посмотреть на состояние всех ваших вот этих проектов,
7692.76 7696.48 SPEAKER_01 контейнеров, экзекютаблов, в том виде, как они поднялись
7696.48 7699.68 SPEAKER_01 с их урлами, для контейнеров, экзекютаблов есть там отдельные
7699.68 7702.92 SPEAKER_01 разделы слева, ну и самый интересный раздел, это,
7702.92 7705.44 SPEAKER_01 конечно же, Logs, где вы можете посмотреть логи, трейсы
7705.44 7710.20 SPEAKER_01 и метрики, причем для логов вы видите просто, он парсит
7710.20 7715.88 SPEAKER_01 IOutput и контейнеров stdoutными, и ваши логи из S/Panet Core, и
7715.88 7718.72 SPEAKER_01 логи из просто экзекютаблов приложений, я так понимаю,
7718.72 7721.36 SPEAKER_01 тоже из stdout умеют парсить и показывать их.
7721.36 7725.84 SPEAKER_01 Ну вот, смотри, я не знаю, насколько это самый интересный
7725.84 7728.60 SPEAKER_01 раздел, потому что в принципе логи можно там достать
7728.60 7733.96 SPEAKER_01 легко с помощью обычных стандартных, там, из любого
7733.96 7736.16 SPEAKER_01 приложения, а на меня вот вау-эффект больше всего
7736.16 7738.48 SPEAKER_01 произвел это именно раздел от Affirmability.
7738.48 7741.28 SPEAKER_01 Да, метрики и трейсы, то есть там такое, там, конечно,
7741.28 7745.24 SPEAKER_01 не графана, ну то есть до графана там далеко, но базовые
7745.24 7747.84 SPEAKER_01 возможности там все есть, в метрике вы можете посмотреть
7747.84 7751.24 SPEAKER_01 графики, все там, как-то фильтр настроить и все
7751.24 7752.24 SPEAKER_01 такое прочее.
7752.24 7754.56 SPEAKER_01 А в трейсах вы прям можете видеть, ну вот как в каком-нибудь
7754.56 7758.40 SPEAKER_01 Ягере привыкли смотреть, например, или там в Вейжер
7758.40 7762.58 SPEAKER_01 Open Sites, вот здесь вы будете точно так же видеть график,
7762.58 7766.12 SPEAKER_01 как бы как ваш запрос гулял между процессами, где сколько
7766.12 7768.92 SPEAKER_01 времени потратил, какие спаны есть и все такое прочее.
7768.92 7774.32 SPEAKER_01 Вот, и отдельно про логи, у них есть отдельный раздел,
7774.32 7779.00 SPEAKER_01 это Structured Logs, где, соответственно, они пытаются все, что они
7779.00 7782.32 SPEAKER_01 смогли распарсить как структурные логи, все это дело показать,
7782.32 7784.76 SPEAKER_01 и там можно все это фильтровать, понятно, смотреть уже с
7784.76 7786.80 SPEAKER_01 точки зрения структурных логов, то есть по полям
7786.80 7789.92 SPEAKER_01 фильтры какие-нибудь настраивать и так далее.
7789.92 7790.92 SPEAKER_01 Интересно, где они все это хранят?
7790.92 7791.92 SPEAKER_01 В памяти.
7791.92 7792.92 SPEAKER_01 В памяти.
7792.92 7793.92 SPEAKER_01 Скорее всего, это просто в памяти.
7793.92 7796.44 SPEAKER_01 Сколько памяти надо, чтобы все это держать-то?
7796.44 7800.56 SPEAKER_01 Представляешь, там и логи, и трейсы, и метрики, и все
7800.56 7801.56 SPEAKER_01 подряд.
7801.56 7802.56 SPEAKER_01 Не знаю.
7802.56 7803.56 SPEAKER_01 Графики.
7803.56 7806.16 SPEAKER_01 Я видел лишь на гитхабе у них, в репозитории, про
7806.16 7809.68 SPEAKER_01 то, что давайте мы добавим опцию ограничить, сколько
7809.68 7811.00 SPEAKER_01 можно памяти пользовать.
7811.00 7813.52 SPEAKER_01 То есть, вероятно, есть те, кто упирался в какие-то
7813.52 7815.40 SPEAKER_01 большие ограничения, но не знаю.
7815.40 7817.68 SPEAKER_01 Пока хранят в памяти, и у них, по-моему, это даже
7817.68 7820.44 SPEAKER_01 где-то явно в каких-то ищущих я читал, написано, что у
7820.44 7827.24 SPEAKER_01 нас нет цели делать какой-то persistent storage, то есть мы сознательно
7827.24 7830.32 SPEAKER_01 храним в памяти, потому что это такая простая штука.
7830.32 7833.48 SPEAKER_01 Ну, штука-то простая, просто место много жрет, и там
7833.48 7835.64 SPEAKER_01 как бы пару часов в памяти оно проработает, и уже
7835.64 7836.64 SPEAKER_01 мало никому не покажется.
7836.64 7839.76 SPEAKER_01 Ну, а тебе для девелопер экспириенса иногда так
7839.76 7840.76 SPEAKER_01 много и не надо.
7840.76 7841.76 SPEAKER_01 Ну, зачастую, не знаю.
7841.76 7842.76 SPEAKER_01 Да-да-да.
7842.76 7843.76 SPEAKER_01 Но оно тропать, наверное, начнется, да, старенькое,
7843.76 7844.76 SPEAKER_01 и все.
7844.76 7846.88 SPEAKER_01 Только на этой надежде, да, что тебе, в принципе, запустил,
7846.88 7848.84 SPEAKER_01 отладил, попробовал, как бы и погасил.
7848.84 7851.88 SPEAKER_01 Ну, может быть, даже запустил и дал поработать, там, сутки,
7851.88 7853.44 SPEAKER_01 допустим, что-то поймает, но потом тебе нужно только
7853.44 7857.04 SPEAKER_01 последний, там, час работы, чтобы что-то оттрейсить.
7857.04 7859.18 SPEAKER_01 А вот если где-то в 3 часа ночи у меня там специальный
7859.18 7861.34 SPEAKER_01 трейс проскакивал, который мне надо было поймать, а
7861.34 7863.18 SPEAKER_01 эта сволочь только за последний час все держит.
7863.18 7866.06 SPEAKER_01 Не знаю, не знаю, погоди, это превью первое, ты много
7866.06 7867.06 SPEAKER_01 от него требуешь.
7867.06 7868.06 SPEAKER_01 Вот.
7868.06 7870.90 SPEAKER_01 Но действительно, обзервабилити, это, конечно, прям киллер
7870.90 7874.18 SPEAKER_01 фича, потому что все это скидывается в единое место,
7874.18 7877.50 SPEAKER_01 причем в гитхабе даже есть всякие, типа, это про то,
7877.50 7880.42 SPEAKER_01 что, мол, вау, вообще круто, типа, так, если я поднимал
7880.42 7883.10 SPEAKER_01 отдельно графану, отдельно там егер, отдельно то, а
7883.10 7885.74 SPEAKER_01 теперь, типа, вот одна штука, и все видно сразу.
7885.74 7888.78 SPEAKER_01 Да-да, так и есть, тебе же надо, блин, просто 10 контейнеров
7888.78 7890.98 SPEAKER_01 поднять, чтобы такую же красоту получить, а здесь
7890.98 7893.22 SPEAKER_01 просто все в инпроцесс, и когда тебе показывает
7893.22 7895.42 SPEAKER_01 егерь, это вообще в отвал башки.
7895.42 7897.30 SPEAKER_01 Ну, то есть, действительно, вся эта презентация, она
7897.30 7899.78 SPEAKER_01 была бы там, ну, ладно, ну, настроили там какие-нибудь
7899.78 7901.70 SPEAKER_01 контейнеры, ну, что-то подняли, но когда они начинают дешборт
7901.70 7905.14 SPEAKER_01 открывать и там везде тыкать, ты понимаешь, что да, вот
7905.14 7907.38 SPEAKER_01 этого эффект, вот этого добились, вот это молодцы.
7907.38 7911.62 SPEAKER_01 Да, как же это работает с точки зрения подкапотом?
7911.62 7915.42 SPEAKER_01 Значит, смотрите, для обзервабилити тут все просто, ну, мы уже
7915.42 7918.02 SPEAKER_01 много раз сегодня упоминали слово open telemetry, конечно,
7918.02 7921.90 SPEAKER_01 все работает на open telemetry, весь код дефолтной настройки
7921.90 7924.98 SPEAKER_01 находится в проекте service defaults, и тут надо сказать
7924.98 7926.90 SPEAKER_01 им большое спасибо в том плане, что они сделали
7926.90 7929.98 SPEAKER_01 следующую штуку, они все дефолтные настройки вытащили
7929.98 7932.66 SPEAKER_01 вот в этот проект, и это позволяет вам в одном месте
7932.66 7935.10 SPEAKER_01 для всего вашего приложения все эти дефолтные настройки
7935.10 7936.10 SPEAKER_01 поправить.
7936.10 7938.14 SPEAKER_01 То есть там все это написано просто кодом, там нет ничего
7938.14 7940.38 SPEAKER_01 скрытого, вы можете все это настроить, как вам
7940.38 7942.90 SPEAKER_01 нужно, если надо, в одном месте, и потом все это автоматически
7942.90 7943.90 SPEAKER_01 инклудится во все места.
7943.90 7944.90 SPEAKER_01 Это первое.
7944.90 7948.98 SPEAKER_01 Второе, если вам нужен open telemetry, как вы понимаете,
7948.98 7952.62 SPEAKER_01 нужен где-то endpoint, куда мы будем слать все эти
7952.62 7954.90 SPEAKER_01 данные, да, open telemetry нужен, так сказать, коллектор
7954.90 7955.90 SPEAKER_01 endpoint.
7955.90 7959.38 SPEAKER_01 Так вот он внутри этого Aspire хоста есть, и туда все
7959.38 7960.38 SPEAKER_01 шлют.
7960.38 7963.46 SPEAKER_01 И он, соответственно, все, как я сказал, хранит в памяти.
7963.46 7966.38 SPEAKER_01 Мне стало интересно, я не нашел ответа на этот вопрос,
7966.38 7969.06 SPEAKER_01 а поэкспериментировать не успел, что будет, если
7969.06 7973.18 SPEAKER_01 на этот open telemetry коллектор начнут слать данные приложения,
7973.18 7975.42 SPEAKER_01 которые не запущены, ну и вот изнутри вот этого
7975.42 7980.82 SPEAKER_01 Aspire комплекта приложений, я просто какой-нибудь сторонний
7980.82 7984.76 SPEAKER_01 свой контейнер натравлю на этот же open telemetry, покажет
7984.76 7988.10 SPEAKER_01 ли он мне все, что мне нужно, это интересно.
7988.10 7990.38 SPEAKER_01 Так, ты уверен, что этот endpoint доступен снаружи?
7990.38 7991.38 SPEAKER_01 Да, конечно.
7991.38 7992.38 SPEAKER_01 Или только в n-процессу?
7992.38 7996.22 SPEAKER_01 Ну да как, если я запускаю, грубо говоря, не знаю, пять
7996.22 7999.38 SPEAKER_01 контейнеров, напоминаю, ты можешь запустить контейнеры,
7999.38 8002.42 SPEAKER_01 они все будут репортить в этот коллектор.
8002.42 8005.42 SPEAKER_01 Ну тогда что будет, точно то же самое, что эти контейнеры
8005.42 8007.70 SPEAKER_01 тебе репортят, покажут на твоих дашбордах и все.
8007.70 8009.74 SPEAKER_01 Да, но только так-то он знает, что он их запускает.
8009.74 8011.86 SPEAKER_01 Значит, как это все работает под капотом?
8011.86 8015.42 SPEAKER_01 На самом деле, для того, чтобы это работало, вот
8015.42 8018.86 SPEAKER_01 эти все либы, которые настраивают open telemetry, они ждут настройку
8018.86 8022.74 SPEAKER_01 open telemetry коллектора endpoint в специальное переменное
8022.74 8026.06 SPEAKER_01 окружение, а Aspire host на самом деле это переменное окружение
8026.06 8028.94 SPEAKER_01 всем задает, понятное дело, перед тем, как запустить
8028.94 8031.86 SPEAKER_01 соответствующий контейнер, executable, либо проект.
8031.86 8035.70 SPEAKER_01 Так вот, понятно, что он знает, что окей, я сейчас
8035.70 8039.66 SPEAKER_01 запускаю фронтендный проект, я ему задаю этот open telemetry
8039.66 8042.42 SPEAKER_01 коллектор, и я знаю, что раз я запустил этот фронтенд
8042.42 8044.74 SPEAKER_01 проект, то он мне будет, например, слайти метрики
8044.74 8048.42 SPEAKER_01 там с тегом frontend, а тут ему кто-то начнет слайти метрики
8048.42 8052.30 SPEAKER_01 с тегом "я хрен знает какой проект", вот что он сделает,
8052.30 8053.30 SPEAKER_01 если он получит такое?
8053.30 8055.58 SPEAKER_01 Не знаю, не пробовал, надо бы попробовать.
8055.58 8057.46 SPEAKER_01 Очень как-то заманчиво выглядит использовать
8057.46 8061.14 SPEAKER_01 его не только для таких стартованных проектов
8061.14 8064.78 SPEAKER_01 изнутри Aspire, а просто как такой единый коллектор
8064.78 8069.46 SPEAKER_01 такой, единый удобный девелоперский коллектор для open telemetry,
8069.46 8073.58 SPEAKER_01 не привязанный именно к запуску через Aspire, но посмотрим.
8073.58 8078.14 SPEAKER_01 Дальше, service discovery, для того чтобы обрабатывать
8078.14 8080.34 SPEAKER_01 service discovery, про которое я говорил, что вы, допустим,
8080.34 8082.70 SPEAKER_01 во фронтенде просто пишете, что ваш backend живет по адресу
8082.70 8087.46 SPEAKER_01 ваш ТТП, там, API, а кто такой API знает, собственно, Aspire,
8087.46 8090.58 SPEAKER_01 и он точно так же через как раз конфигурации все нужные
8090.58 8093.78 SPEAKER_01 порты передаст куда нужно, то для этого используется
8093.78 8096.18 SPEAKER_01 новая библиотечка, это, в принципе, отдельный Nuget
8096.18 8099.86 SPEAKER_01 пакет, называется Microsoft Extensions Service Discovery, не обязательно
8099.86 8101.82 SPEAKER_01 его использовать вместе с Aspire, вы, в принципе, его
8101.82 8105.10 SPEAKER_01 можете использовать и у себя сами, он работает
8105.10 8108.06 SPEAKER_01 довольно простым способом, то есть вы через определенную
8108.06 8111.38 SPEAKER_01 конфигурацию задаете набор endpoints, где можно искать
8111.38 8114.34 SPEAKER_01 тот или иной сервис по имени, и дальше в нужных местах
8114.34 8117.70 SPEAKER_01 вы можете сказать, что вот тут используй service discovery,
8117.70 8120.42 SPEAKER_01 там прямо есть extension метод, use service discovery, который можно,
8120.42 8122.98 SPEAKER_01 например, на ТТП клиенте, на регистрацию ТТП клиента
8122.98 8126.34 SPEAKER_01 добавить, и эта магия автоматически будет из вашей конфигурации
8126.34 8129.86 SPEAKER_01 подтягивать потенциальные адреса того, куда вы хотите
8129.86 8130.86 SPEAKER_01 подключиться.
8130.86 8133.34 SPEAKER_01 Вот, так что, может быть, пакет будет полезен вам
8133.34 8135.22 SPEAKER_01 даже так, без Aspire.
8135.22 8138.18 SPEAKER_01 Я писал аналогичную штуку, как бы, много лет назад,
8138.18 8140.94 SPEAKER_01 и это действительно очень хорошо работает, и действительно
8140.94 8144.38 SPEAKER_01 очень удобно, поэтому, да, хороший пакетик.
8144.38 8149.14 SPEAKER_01 И, естественно, разработка не обходится без диплоймента,
8149.14 8153.22 SPEAKER_01 тут пока все очень на зачаточном уровне, хотя сделано тоже
8153.22 8154.22 SPEAKER_01 довольно гибко.
8154.22 8155.94 SPEAKER_01 Что умеют эти штуки?
8155.94 8160.78 SPEAKER_01 Вот эти компоненты, которые мы сказали, да, про Aspire,
8160.78 8164.58 SPEAKER_01 они еще должны уметь, точнее даже не они, компоненты
8164.58 8167.54 SPEAKER_01 как раз это про подключение к ресурсам, а вот описание
8167.54 8170.30 SPEAKER_01 ресурсов, которые вы можете указать в Апхасте, то есть
8170.30 8172.34 SPEAKER_01 когда вы говорите, что я хочу, чтобы мое приложение
8172.34 8177.62 SPEAKER_01 состояло из SQL сервера, вот этого CSProJet и Redis, нужно,
8177.62 8180.62 SPEAKER_01 чтобы эти ресурсы умели делать одну простую штуку.
8180.62 8184.30 SPEAKER_01 У них, это тоже же по сути, ну, GetPackets в каком-то смысле,
8184.30 8188.70 SPEAKER_01 и у них должна быть опция, точнее не опция, а метод
8188.70 8194.64 SPEAKER_01 написать про себя что-нибудь в JSON-манифест, вот буквально
8194.64 8198.46 SPEAKER_01 звучит это так, если посмотреть на C# интерфейс, который
8198.46 8200.74 SPEAKER_01 используется для этого, там буквально C# интерфейс
8200.74 8205.70 SPEAKER_01 типа writeJSONManifest и туда передается UTF-8 JSON Writer, все, без каких-либо
8205.70 8207.82 SPEAKER_01 требований, что вы туда пишите, и вы туда пишите
8207.82 8208.82 SPEAKER_01 все, что нужно.
8208.82 8214.18 SPEAKER_01 По дефолту получается нечто, то есть вот сейчас они написаны
8214.18 8217.46 SPEAKER_01 таким образом, получается нечто, что я так понимаю
8217.46 8221.98 SPEAKER_01 нативным ажурным Command-Line клиентам практически без
8221.98 8224.98 SPEAKER_01 изменений понимается, как ажурный манифест, ну или
8224.98 8227.30 SPEAKER_01 что-то близкое, или что-то, что легко может быть сконвертировано
8227.30 8229.94 SPEAKER_01 в ажурный манифест, ну, что объяснимо, понятное
8229.94 8231.70 SPEAKER_01 дело, Майкрософт, естественно, будет писать в основном
8231.70 8235.42 SPEAKER_01 для себя, но технически там никак не привязаны
8235.42 8239.22 SPEAKER_01 к ажурному JSON, который вы можете, не знаю, в какой-нибудь
8239.22 8243.38 SPEAKER_01 Terraform скрипт поменять, я не знаю, лиансибл скрипт,
8243.38 8246.38 SPEAKER_01 это я так фантазирую сейчас, наверное, можете.
8246.38 8248.94 SPEAKER_01 То есть этот манифест нужен для того, чтобы из него сгенерить
8248.94 8251.74 SPEAKER_01 уже какой-то deployment дальше формат, да?
8251.74 8252.74 SPEAKER_01 Да, да, да.
8252.74 8258.46 SPEAKER_01 То есть чтобы мы не зашивали в Aspire знания, как деплоить
8258.46 8260.94 SPEAKER_01 в кубер, как деплоить в ажур, как деплоить в AWS,
8260.94 8263.70 SPEAKER_01 как деплоить в Google Cloud, Яндекс Клауд, какие еще клауды
8263.70 8266.30 SPEAKER_01 у нас есть, и вообще в ваше приватное облако, в которое
8266.30 8268.86 SPEAKER_01 только вы можете деплоить через ваши странные endpoint,
8268.86 8269.86 SPEAKER_01 например.
8269.86 8270.86 SPEAKER_01 В Helm.
8270.86 8275.02 SPEAKER_01 Ну, Helm это все-таки не всегда в любое место.
8275.02 8276.22 SPEAKER_01 Да ладно, всегда уже.
8276.22 8279.58 SPEAKER_01 Ну, тоже не всегда, не всегда, не везде я Helm вижу сейчас.
8279.58 8283.58 SPEAKER_01 В кубер Helm, да, конечно, наверное, но тоже не факт.
8283.58 8286.06 SPEAKER_01 Вот, поэтому они, короче, решили, что будем просто
8286.06 8289.14 SPEAKER_01 генерировать какой-нибудь JSON, а дальше, если вам надо,
8289.14 8292.38 SPEAKER_01 ну вы его преобразуете в ваш нужный, в нем типа
8292.38 8295.14 SPEAKER_01 все данные от каждого вот этого провайдера есть.
8295.14 8300.18 SPEAKER_01 Ну, там надо, правда, чтобы достаточно информации было,
8300.18 8302.90 SPEAKER_01 для того чтобы все-таки сервисы, которые мы инклудим,
8302.90 8304.42 SPEAKER_01 достаточно информации про себя написали.
8304.42 8305.42 SPEAKER_01 Ну, конечно, конечно.
8305.42 8308.50 SPEAKER_01 Ну, как минимум, нужны всякие переменные окружения какие
8308.50 8312.34 SPEAKER_01 они ожидают, да, это самое, connection string, и вот это все.
8312.34 8314.50 SPEAKER_01 То есть, опять же, это пока превью, то есть пока это
8314.50 8317.10 SPEAKER_01 сделали просто, чтобы была какая-нибудь темка, видимо,
8317.10 8319.58 SPEAKER_01 то это можно задеплоить в ажур, а дальше, ну, будет
8319.58 8321.58 SPEAKER_01 развиваться, посмотрим, куда будет развиваться.
8321.58 8326.26 SPEAKER_01 Если вы, да, я все это говорил, естественно, из предположения,
8326.26 8329.38 SPEAKER_01 что окей, вы создали новый проект из шаблончика, но
8329.38 8331.78 SPEAKER_01 если у вас есть уже существующий проект, и у вас есть превью
8331.78 8334.18 SPEAKER_01 студия, вы можете просто right-click на проекте, сказать
8334.18 8339.18 SPEAKER_01 add Aspirus Orchestration Support, и у вас вот эти два новых проектика
8339.18 8343.70 SPEAKER_01 app-host и service-default добавятся, и студия начнет работать,
8343.70 8345.50 SPEAKER_01 как будто она, ну, в смысле, как будто ваш проект был
8345.50 8347.70 SPEAKER_01 создан из шаблончика.
8347.70 8350.74 SPEAKER_01 Теперь давай подумаем, точнее, не подумаем, а поговорим,
8350.74 8352.90 SPEAKER_01 а почему, собственно, код.
8352.90 8355.38 SPEAKER_01 В основной статье про это у них ничего нет.
8355.38 8359.06 SPEAKER_01 Ты имеешь все-таки в виду для конфигурации, да?
8359.06 8360.06 SPEAKER_01 Да, да, да.
8360.06 8361.06 SPEAKER_01 Почему они выбрали код?
8361.06 8366.06 SPEAKER_01 Как ты помнишь, в TAI был YAML, и казалось бы, ну, YAML сейчас
8366.06 8369.26 SPEAKER_01 такой стандарт почти для всего, они сказали, что
8369.26 8370.82 SPEAKER_01 это прямо было выбрано сознательно.
8370.82 8377.66 SPEAKER_01 Ссылаются они при этом на статью 2012 года, 11 лет прошло,
8377.66 8381.34 SPEAKER_01 которая называется Configuration Complexity Clock.
8381.34 8386.22 SPEAKER_01 Статья довольно интересная и не без как бы, то, что
8386.22 8390.30 SPEAKER_01 по-английски называется it has the point, да, не без как
8390.30 8391.90 SPEAKER_01 бы здравого смысла.
8391.90 8392.90 SPEAKER_01 Смысл в чем?
8392.90 8394.74 SPEAKER_01 Самое простое, что вы можете сделать, когда вы пишете
8394.74 8397.22 SPEAKER_01 приложение, это все захардкодить.
8397.22 8399.46 SPEAKER_01 Со временем вам становится хардкода мало, вы начинаете
8399.46 8402.58 SPEAKER_01 выносить эти кусочки в какие-то конфиги.
8402.58 8404.82 SPEAKER_01 Потом вы понимаете, что логика конфигов стала
8404.82 8407.74 SPEAKER_01 настолько сложной, что нужно уже писать какие-то
8407.74 8410.58 SPEAKER_01 там типа, а-ля правила.
8410.58 8414.22 SPEAKER_01 Потом это тоже становится слишком сложным, вы понимаете,
8414.22 8418.06 SPEAKER_01 окей, правил нам не хватает, давайте напишем свой DSL,
8418.06 8421.50 SPEAKER_01 и в итоге потом получается, что раньше у вас было все
8421.50 8425.02 SPEAKER_01 захардкожено в вашем родном языке программирования,
8425.02 8427.62 SPEAKER_01 а в DSL у вас все тоже, это тоже программа, только
8427.62 8430.82 SPEAKER_01 как правило в DSL у вас отсутствует нормальный тулинг, отсутствует
8430.82 8433.90 SPEAKER_01 нормальный дебаггинг, со временем там тоже придется
8433.90 8436.66 SPEAKER_01 что-нибудь хардкодить, но это уже язык, на который
8436.66 8440.26 SPEAKER_01 как бы фиг отладишь, и при этом тоже язык программирования
8440.26 8442.42 SPEAKER_01 до некоторой степени, а бизнес все равно на нем
8442.42 8444.90 SPEAKER_01 не пишет, все равно пишут программисты, поэтому зачем
8444.90 8447.66 SPEAKER_01 делать это, давайте снова хардкодить в обычном языке
8447.66 8448.66 SPEAKER_01 программирования.
8448.66 8451.30 SPEAKER_01 Именно поэтому это называется configuration complexity clock, что
8451.30 8453.78 SPEAKER_01 мы наращиваем, наращиваем, наращиваем сложность и
8453.78 8456.10 SPEAKER_01 все равно так или иначе переходим к коду, поэтому
8456.10 8458.06 SPEAKER_01 Microsoft подумали и сказали, ладно, будем сразу писать
8458.06 8459.06 SPEAKER_01 кодом.
8459.06 8465.02 SPEAKER_01 Плюс с этого есть еще некоторый бонус, на самом деле, его
8465.02 8467.30 SPEAKER_01 можно было бы, наверное, добиться и в Ямле тоже,
8467.30 8471.30 SPEAKER_01 но с кодом это проще, надо понимать, что вот когда
8471.30 8473.54 SPEAKER_01 вы будете поднимать вот эту инфраструктуру у себя,
8473.54 8477.22 SPEAKER_01 да, обхост задавать, то скорее всего у вас там, не знаю,
8477.22 8481.58 SPEAKER_01 вы всегда используете Redis+, Postgres+, там не знаю, что еще,
8481.58 8485.30 SPEAKER_01 ну что-нибудь еще, кликхаус какой-нибудь, вы в принципе
8485.30 8488.26 SPEAKER_01 можете этот кусочек выделить в отдельный Nuget пакет, запушить
8488.26 8492.06 SPEAKER_01 его в ваш локальный репозиторий и подтягивать к себе во
8492.06 8495.02 SPEAKER_01 все продукты, не копируя один и тот же код.
8495.02 8497.78 SPEAKER_01 То есть стандартные кусочки инфраструктуры можно оформить
8497.78 8500.42 SPEAKER_01 в виде кусочков кода в Nuget и использовать их через
8500.42 8501.42 SPEAKER_01 экстенджер методы.
8501.42 8505.98 SPEAKER_01 Такое расширение получается удобное, ну удобное, неудобное,
8505.98 8510.34 SPEAKER_01 посмотрим, по крайней мере, есть поинты на эту тему
8510.34 8512.34 SPEAKER_01 и точка расширения.
8512.34 8517.82 SPEAKER_01 Еще, почему клевый код, потому что, во-первых, вы
8517.82 8522.74 SPEAKER_01 можете задавать кастомные типы ресурсов, потому что
8522.74 8527.34 SPEAKER_01 по сути, ну что нужно обхосту знать про ваш кастомный
8527.34 8528.34 SPEAKER_01 ресурс?
8528.34 8531.02 SPEAKER_01 Ему нужно знать, как его запустить, его нужно знать,
8531.02 8534.10 SPEAKER_01 как его сконфигурить, его нужно знать, как его написать
8534.10 8535.10 SPEAKER_01 в манифест.
8535.10 8538.10 SPEAKER_01 Ну по сути это реализация одного там или нескольких
8538.10 8540.46 SPEAKER_01 классов, сейчас не вспомню точно, точнее одного или
8540.46 8542.62 SPEAKER_01 нескольких интерфейсов, вы пишете это в виде одного
8542.62 8544.90 SPEAKER_01 или нескольких классов, реализуете это все и вот
8544.90 8547.34 SPEAKER_01 у вас там типа ваш кастомный, не знаю, ваша кастомная
8547.34 8550.14 SPEAKER_01 база данных, про которую никто никогда не узнает,
8550.14 8553.98 SPEAKER_01 и никто не напишет для нее этот Aspired пакетик, вы можете
8553.98 8554.98 SPEAKER_01 написать свой.
8554.98 8555.98 SPEAKER_01 Вот.
8555.98 8558.74 SPEAKER_01 Наверное в конфигах это можно было бы сделать, потому
8558.74 8561.18 SPEAKER_01 что наверняка конфиги бы обрабатывались, что там
8561.18 8564.18 SPEAKER_01 типа провайдер какой-нибудь, но это примерно как вот,
8564.18 8568.34 SPEAKER_01 что-то я такое помню, было в WCF такое решение, ты сначала
8568.34 8572.62 SPEAKER_01 как бы где-то наверху указываешь, что вот этот элемент в XML
8572.62 8575.38 SPEAKER_01 будет описан вот таким-то классом в такой-то сборке,
8575.38 8578.54 SPEAKER_01 указываешь полный путь к сборке, ну этот full name,
8578.54 8581.30 SPEAKER_01 да, с этим, с подписью и всем добром, и потом ты
8581.30 8583.22 SPEAKER_01 можешь его использовать в XML, и для обработки будет
8583.22 8584.22 SPEAKER_01 грузиться твой runtime.
8584.22 8588.10 SPEAKER_01 Типа в runtime, короче, вот это все, ну можно, но сложно,
8588.10 8589.10 SPEAKER_01 проще кодом.
8589.10 8593.18 SPEAKER_01 Ну опять же смотри, ты в YAML вполне можешь, и там весь
8593.18 8595.70 SPEAKER_01 кубер описывается YAML, ты в YAML вполне можешь объявить
8595.70 8598.10 SPEAKER_01 ресурсы и рассказать, на каком порту они запускаются
8598.10 8600.54 SPEAKER_01 и способ запуска, откуда контейнер скачивать, все
8600.54 8602.62 SPEAKER_01 это тоже сделается, все это тоже есть.
8602.62 8607.66 SPEAKER_01 А прикинь, как в YAML описать, в каком формате написать
8607.66 8608.94 SPEAKER_01 выходной JSON.
8608.94 8612.38 SPEAKER_01 Да, строчки форматирования, output формата тоже есть, тот
8612.38 8617.06 SPEAKER_01 же самый string template для логинга элементарно задается строкой,
8617.06 8618.06 SPEAKER_01 почему нет?
8618.06 8621.46 SPEAKER_01 Ну string template для логинга, да, а вот в YAML написать
8621.46 8624.74 SPEAKER_01 многострочный JSON, ну можно, но я как…
8624.74 8628.02 SPEAKER_01 YAML это вообще подмножство JSON, опиши в виде YAML его
8628.02 8629.98 SPEAKER_01 и легко сконвертить в любой JSON, хоть многострочный,
8629.98 8630.98 SPEAKER_01 хоть и многострочный.
8630.98 8635.66 SPEAKER_01 Я понимаю, но выглядит это, короче, тот самый configuration
8635.66 8639.18 SPEAKER_01 complexity clock, они опасались, что наверняка будут те,
8639.18 8642.02 SPEAKER_01 кому будут малы YAML, они захотят расширение через
8642.02 8645.02 SPEAKER_01 код, и тогда придется поддерживать два места, а так поддерживаем
8645.02 8646.02 SPEAKER_01 только одно место.
8646.02 8649.30 SPEAKER_01 Ну смотри, я в принципе здесь согласен, что в данном
8649.30 8652.42 SPEAKER_01 случае с кодом настраивать лучше, и я сам стремлюсь
8652.42 8654.90 SPEAKER_01 вообще настраивать все с кодом, но здесь нужно
8654.90 8657.58 SPEAKER_01 оговориться, что это больше не замещение, они здесь
8657.58 8660.46 SPEAKER_01 немножко лукавят, потому что главное преимущество
8660.46 8664.34 SPEAKER_01 того же самого YAML, ну или любого другого там XML, JSON,
8664.34 8666.42 SPEAKER_01 любого другого формата, который лежит возле вашего
8666.42 8669.02 SPEAKER_01 приложения, его главное преимущество в том, что
8669.02 8672.10 SPEAKER_01 от того же самого TIE этот конфиг можно было взять
8672.10 8674.94 SPEAKER_01 и запаблишить его, например, в кубер, сконвертить и запаблишить
8674.94 8675.94 SPEAKER_01 в кубер.
8675.94 8677.62 SPEAKER_01 То есть главное преимущество в том, что у тебя появляется
8677.62 8679.70 SPEAKER_01 точка интеграции с любым инструментом, который
8679.70 8680.70 SPEAKER_01 есть.
8680.70 8682.94 SPEAKER_01 И вот когда ты настраиваешь в коде, безусловно, у тебя
8682.94 8685.34 SPEAKER_01 настройка все прекрасная и все такое, но тебе в любом
8685.34 8687.86 SPEAKER_01 случае рано или поздно понадобится точка интеграции
8687.86 8690.06 SPEAKER_01 с другими инструментами, и здесь они ее просто-напросто
8690.06 8692.22 SPEAKER_01 перенесли в тот манифест, про который ты рассказывал
8692.22 8693.22 SPEAKER_01 недавно.
8693.22 8695.10 SPEAKER_01 То есть у нас появляется между одной точкой конфигурации
8695.10 8696.74 SPEAKER_01 две точки конфигурации.
8696.74 8699.38 SPEAKER_01 Одна из них, безусловно, удобная и тестируемая FC
8699.38 8701.66 SPEAKER_01 шарпи, но другая все равно необходимая, и ты без нее
8701.66 8703.82 SPEAKER_01 никуда не денешься в этом чертовом манифесте.
8703.82 8705.06 SPEAKER_01 Да, она заодно автогенерится.
8705.06 8708.18 SPEAKER_01 Он-то автогенерится, но формат его не декларирован.
8708.18 8710.78 SPEAKER_01 Ты понимаешь, что сейчас туда могут писать все кто
8710.78 8713.98 SPEAKER_01 угодно, что угодно в любом формате, нет какого-то контракта,
8713.98 8715.74 SPEAKER_01 нет какого-то протокола, который мне расскажет,
8715.74 8718.38 SPEAKER_01 на каком порту мне там поднимать тот же самый Redis.
8718.38 8721.74 SPEAKER_01 Вот здесь сейчас это никак не декларируется, не описано,
8721.74 8723.14 SPEAKER_01 и это большая проблема.
8723.14 8725.38 SPEAKER_01 Если бы они сразу делали это на Ямле, то там бы точно
8725.38 8726.38 SPEAKER_01 это уже было.
8726.38 8727.38 SPEAKER_01 Не факт.
8727.38 8732.10 SPEAKER_01 Они как бы что для манифеста, что для Ямля, им все равно
8732.10 8737.22 SPEAKER_01 нужно было бы… Не, не факт, не факт, не факт, потому
8737.22 8739.78 SPEAKER_01 что если у тебя есть какие-нибудь экзекьютаблы, которые, не
8739.78 8741.74 SPEAKER_01 забывай, у нас есть в том числе, это девелопер штука
8741.74 8745.00 SPEAKER_01 в первую очередь, и у тебя там, у меня, например, когда
8745.00 8747.54 SPEAKER_01 я себе тай конфиги писал, у меня примерно половина
8747.54 8750.10 SPEAKER_01 зависимости, это была экзе, и их я как бы в кубер никогда
8750.10 8751.10 SPEAKER_01 не запихнул.
8751.10 8752.10 UNKNOWN Зачем?
8752.10 8755.78 SPEAKER_01 Ну, какое-то странное тебе тогда приложение, как у
8755.78 8757.78 SPEAKER_01 тебя половина приложения в кубере работает, а половина
8757.78 8760.46 SPEAKER_01 на локальной машине запускается, или что ты с ними делаешь?
8760.46 8765.06 SPEAKER_01 Нет, я просто, когда я работаю со своей частью кусочка
8765.06 8767.66 SPEAKER_01 приложения, все остальные кусочки приложения я запускаю
8767.66 8768.66 SPEAKER_01 экзешкой просто.
8768.66 8771.06 SPEAKER_01 Ну хорошо, это же ничему не противоречит, ты можешь
8771.06 8774.30 SPEAKER_01 делать и так, и так, но в большинстве случаев, если
8774.30 8776.34 SPEAKER_01 ты хочешь поднять полностью свое приложение, которое
8776.34 8779.62 SPEAKER_01 должно там общаться с 10-ю какими-нибудь сервисами,
8779.62 8782.02 SPEAKER_01 и ты там все эти 10 сервисов хочешь поднять, то рано
8782.02 8784.30 SPEAKER_01 или поздно тебе захочется их задеплоить, и у тебя
8784.30 8786.86 SPEAKER_01 должен быть понятный, хороший инструмент, который тебе
8786.86 8787.86 SPEAKER_01 это даст сделать.
8787.86 8789.92 SPEAKER_01 И именно тай это и умел делать, он напрямую все
8789.92 8792.66 SPEAKER_01 мог деплоить, в этом-то его прелесть и была.
8792.66 8795.94 SPEAKER_01 Да, но опять же, да, но нет, потому что, например, если
8795.94 8800.06 SPEAKER_01 я локально поднимаю, я локально подниму, не знаю там, пасгрио,
8800.06 8804.98 SPEAKER_01 редис, кликхаус и свое приложение, а когда я деплою, я не хочу
8804.98 8806.62 SPEAKER_01 деплоить пасгрио, редис и кликхаус, они у меня
8806.62 8808.94 SPEAKER_01 отдельно деплоются, с отдельными манифестами, которые вообще
8808.94 8810.78 SPEAKER_01 к приложению не имеют отношения.
8810.78 8813.62 SPEAKER_01 Тогда ты разрываешь свое приложение и, например,
8813.62 8815.90 SPEAKER_01 локально ты будешь отлаживать под редисом, в то время
8815.90 8818.58 SPEAKER_01 как другой на продакшене твой сервис уехал под
8818.58 8821.62 SPEAKER_01 memcached, и ты, например, об этом даже никогда не узнаешь.
8821.62 8822.62 SPEAKER_01 Узнаю.
8822.62 8823.62 SPEAKER_01 Ты разрываешь конфигурацию общую.
8823.62 8827.12 SPEAKER_01 Ну, как бы, я не могу в своем приложении деплоить единый
8827.12 8830.66 SPEAKER_01 сиквел или пасгрио, который одна на несколько продуктов.
8830.66 8833.66 SPEAKER_01 Ну, тебе не обязательно деплоить, ты можешь подключиться
8833.66 8836.42 SPEAKER_01 к удаленному сервису, это же как настроишь.
8836.42 8841.58 SPEAKER_01 Я просто говорю про то, что очень часто и полезно
8841.58 8844.74 SPEAKER_01 иметь конфигурацию, ту конфигурацию, как у тебя
8844.74 8847.46 SPEAKER_01 разворачивается весь твой кластер на сервере, очень
8847.46 8849.70 SPEAKER_01 часто и полезно иметь ее и локально.
8849.70 8851.86 SPEAKER_01 Конечно, ты не все компоненты из этой конфигурации будешь
8851.86 8854.78 SPEAKER_01 ставить, конечно, ты некоторые из них и заменишь общими,
8854.78 8856.40 SPEAKER_01 но все-таки некоторые из них ты сможешь локально
8856.40 8859.02 SPEAKER_01 запустить и отладить, а если ты эту конфигурацию
8859.02 8861.62 SPEAKER_01 разрываешь, у тебя на сервере одна, а локально ты отлаживаешь
8861.62 8865.38 SPEAKER_01 совершенно другую, ты получаешь возможность приобрести
8865.38 8867.94 SPEAKER_01 новый класс проблем, которых у тебя не было бы при единой
8867.94 8868.94 SPEAKER_01 конфигурации.
8868.94 8870.86 SPEAKER_01 Вот вопрос, есть ли у тебя единая конфигурация всего
8870.86 8871.86 SPEAKER_01 прода.
8871.86 8875.02 SPEAKER_01 То есть, вот у меня в большинстве случаев нет базы отдельной
8875.02 8877.18 SPEAKER_01 конфигурации с отдельными манифестами, которые вообще
8877.18 8880.02 SPEAKER_01 никак не связаны с приложениями, они обдавлятся отдельным
8880.02 8883.30 SPEAKER_01 релизным циклом, а приложения отдельные релизные циклы,
8883.30 8886.14 SPEAKER_01 они в разных конфигурациях, в разных хилмах, и они никогда
8886.14 8887.50 SPEAKER_01 не сливаются в единый.
8887.50 8890.62 SPEAKER_01 Так а в чем проблема взять их конфигурацию и поднять
8890.62 8891.62 SPEAKER_01 у тебя локально?
8891.62 8897.06 SPEAKER_01 Еще раз, в этом направлении нет проблемы, вот, т.е. независимо
8897.06 8902.46 SPEAKER_01 от того, хотят ли они ямль в Aspire или код, если даже
8902.46 8905.04 SPEAKER_01 они хотят ямль, у меня все равно в исходнике будет
8905.04 8909.22 SPEAKER_01 два ямля, как я два ямля солью в один, причем…
8909.22 8911.50 SPEAKER_01 Да, тебе не обязательно их в один сливать, ладно,
8911.50 8915.90 SPEAKER_01 это уже какой-то спор уже о тонкостях, давай все-таки
8915.90 8916.90 SPEAKER_01 по этому.
8916.90 8921.42 SPEAKER_01 Ну, короче, код, мне кажется, что код более правильно,
8921.42 8926.58 SPEAKER_01 т.е. с ямлем есть там тонкости, которые действительно
8926.58 8930.50 SPEAKER_01 где-то можно хотеть кастомизации, кто-то наверняка захочет,
8930.50 8935.10 SPEAKER_01 ну, в общем, пока будет код, значит, и тут как раз-таки
8935.10 8938.10 SPEAKER_01 именно в этом репозитории в том числе лежат графановские
8938.10 8942.50 SPEAKER_01 дэшборды, которые ты упоминал в Aspire.net Core, там два дэшборда,
8942.50 8946.74 SPEAKER_01 один Aspire.net Core общий, а другой Aspire.net Core для Endpoint, более
8946.74 8949.50 SPEAKER_01 детальная статистика по конкретному Endpoint, из одного,
8949.50 8952.30 SPEAKER_01 насколько я понимаю, можно проваливаться в другой.
8952.30 8956.30 SPEAKER_01 Это, собственно, все, что было в официальном анонсе,
8956.30 8958.02 SPEAKER_01 ну и на самом деле, то, что я рассказал, это не только
8958.02 8961.14 SPEAKER_01 в официальном анонсе, это еще из твиттера Фаулера,
8961.14 8964.18 SPEAKER_01 где он там чуть более детально рассказал, это есть у них
8964.18 8970.90 SPEAKER_01 на GitHub, значит, да, Aspire живет в github.com/.net/aspire в репозитории,
8970.90 8974.42 SPEAKER_01 там есть некоторая документация, как это работает внутри
8974.42 8977.98 SPEAKER_01 немножко, и какие-то там tips, tricks, и что может пойти
8977.98 8981.22 SPEAKER_01 не так, поскольку это пока все-таки превью-версия,
8981.22 8982.22 SPEAKER_01 там могут быть проблемы.
8982.22 8988.50 SPEAKER_01 И я еще погулял по issues в GitHub, и там есть несколько
8988.50 8989.50 SPEAKER_01 интересных вещей.
8989.50 8995.06 SPEAKER_01 Во-первых, надо понимать, ну то есть, смотрите, как
8995.06 8999.22 SPEAKER_01 я сказал, некая магия, вот вы говорите в F5 на стартовом
8999.22 9003.10 SPEAKER_01 проекте на Абхасте, то есть вы в качестве стартап-проекта
9003.10 9007.74 SPEAKER_01 в студии выбираете один-единственный проект и говорите F5, в результате
9007.74 9011.78 SPEAKER_01 студия оттачится ко всем запущенным проектам, то
9011.78 9015.00 SPEAKER_01 есть вот в нашем, так сказать, модельном примере, когда
9015.00 9018.58 SPEAKER_01 у нас есть темплейтик, в котором два, ну один фронтенд,
9018.58 9021.42 SPEAKER_01 один бэкэнд и Абхост, вы запускаете Абхост, а студия
9021.42 9025.30 SPEAKER_01 оттачивается и к фронтенду, и к бэкэнду, и к Абхосту.
9025.30 9027.86 SPEAKER_01 Вообще говоря, дефолтная студия так не умеет, она
9027.86 9030.90 SPEAKER_01 оттачивается всегда только к тому, к тем проектам, которые
9030.90 9033.90 SPEAKER_01 были отмечены как стартап-проекты, вот.
9033.90 9037.98 SPEAKER_01 Для того, чтобы эта магия работала, есть специальная
9037.98 9042.66 SPEAKER_01 штука, которая используется в .net Aspire, вы наверняка будете
9042.66 9045.62 SPEAKER_01 видеть эту аббревиатуру, она называется DCP, Developer
9045.62 9052.34 SPEAKER_01 Control Plane или Developer Control что-то там, это специальный процесс,
9052.34 9056.26 SPEAKER_01 который, с которым работает примерно следующим образом.
9056.26 9062.26 SPEAKER_01 Значит, когда Aspire запускается, он этому, то есть когда
9062.26 9068.74 SPEAKER_01 студия, точнее, запускает Aspire, она говорит Aspire, где
9068.74 9073.50 SPEAKER_01 находится ее endpoint, через который можно ее подергать
9073.50 9076.30 SPEAKER_01 и сказать приоттачиваться еще к чему-нибудь, то есть
9076.30 9078.50 SPEAKER_01 такой callback внутрь дебаггера студии.
9078.50 9082.78 SPEAKER_01 А там только приоттачиваться или можно прям управлять
9082.78 9085.22 SPEAKER_01 поширше, там поставить грядку или что-нибудь?
9085.22 9087.62 SPEAKER_01 Не-не-не, там типа запусти, останови, приоттачивайся
9087.62 9090.62 SPEAKER_01 и типа, по-моему, еще что-то, ну, то есть, короче, какая-то
9090.62 9091.62 SPEAKER_01 не очень большая.
9091.62 9096.26 SPEAKER_01 Слушай, ну нам нужен полный web API доступ к студии, я реквестирую
9096.26 9097.26 SPEAKER_01 просто.
9097.26 9100.86 SPEAKER_01 Ну, послушай до конца, там будет интереснее, значит.
9100.86 9103.42 SPEAKER_01 Дальше есть вот этот developer control plane процесс, через
9103.42 9105.42 SPEAKER_01 который, собственно, вся эта магия происходит, то
9105.42 9107.78 SPEAKER_01 есть Aspire как бы понимает, разобрав ваш код, что нужно
9107.78 9111.46 SPEAKER_01 позапускать, и вот этому developer control plane говорит
9111.46 9112.46 SPEAKER_01 тебе, давай запускай.
9112.46 9114.94 SPEAKER_01 И этот plane, он умеет как раз запускать там контейнеры
9114.94 9118.78 SPEAKER_01 и вот это все, и дергать студию со словами, я тут
9118.78 9121.30 SPEAKER_01 запустил такую штуку, вы оттачься к ней, вот.
9121.30 9126.06 SPEAKER_01 Фишка в том, что этот developer control plane, это closed source штука
9126.06 9130.62 SPEAKER_01 с некой такой странноватой лицензией, как народ написал
9130.62 9135.50 SPEAKER_01 в гитхабе, лицензия там звучит так, вы можете использовать
9135.50 9138.14 SPEAKER_01 эту штуку бесплатно и без ограничений до тех пор,
9138.14 9140.74 SPEAKER_01 пока Microsoft не поменяет на ней лицензию, вот.
9140.74 9143.86 SPEAKER_01 Из чего народ делает вывод, что кажется, что может быть
9143.86 9147.58 SPEAKER_01 на этом Microsoft захочет денег зарабатывать, ну, либо она
9147.58 9149.94 SPEAKER_01 там действительно какой-то ноу-хау, поэтому closed source,
9149.94 9152.66 SPEAKER_01 но она все равно останется типа, не знаю там, подписка
9152.66 9154.38 SPEAKER_01 студии нужна, чтобы ее можно было использовать, как
9154.38 9156.66 SPEAKER_01 девбокс, например, вот.
9156.66 9160.74 SPEAKER_01 И как раз, видимо, то, что я говорил, ограничение
9160.74 9163.08 SPEAKER_01 тулинга для линукс и мака связано с тем, что пока
9163.08 9165.86 SPEAKER_01 этот developer control plane умеет работать только со студией
9165.86 9170.34 SPEAKER_01 и не умеет, например, с Visual Studio Code работать, а как научится,
9170.34 9172.94 SPEAKER_01 сразу у нас будет и на маке такой же экспириенс, вот,
9172.94 9173.94 SPEAKER_01 посмотрим, не знаю.
9173.94 9176.70 SPEAKER_01 Ну, вот эта вот тонкость с лицензией и то, что часть
9176.70 9178.62 SPEAKER_01 вот всей этого, всего этого тулинга, она получается
9178.62 9185.14 SPEAKER_01 closed source, ну, она такое, как бы, намекает на мысль,
9185.14 9187.66 SPEAKER_01 что черт ее знает, что там будет к моменту general availability
9187.66 9189.74 SPEAKER_01 и сколько денег за это захочет Microsoft.
9189.74 9194.98 SPEAKER_01 Это с одной стороны, с другой стороны, народ пишет в этих
9194.98 9198.42 SPEAKER_01 самых вышиях, что, мол, еще две таких довольно популярных
9198.42 9202.22 SPEAKER_01 запроса, с одной стороны, а можно ли как-то сделать,
9202.22 9204.96 SPEAKER_01 чтобы я мог вот этот вот крохлевый дашборд с вашим
9204.96 9208.84 SPEAKER_01 OpenTelemetry коллектором и всем добром не запускать из
9208.84 9209.84 SPEAKER_01 обхоста.
9209.84 9212.68 SPEAKER_01 Вот мне не нужно, у меня нет такого, как бы, кейса,
9212.68 9214.92 SPEAKER_01 что мне нужно мое приложение поднимать там с миллионом
9214.92 9216.28 SPEAKER_01 других зависимостей.
9216.28 9218.90 SPEAKER_01 У меня есть Standalone.net core приложение, которому ничего
9218.90 9221.60 SPEAKER_01 не надо, ну, типа, у меня там база стоит локально,
9221.60 9224.92 SPEAKER_01 больше ей ничего не надо, а дашборд хочу, можно я
9224.92 9228.20 SPEAKER_01 как-нибудь его вот Nuget пакетиком к себе притащу, напишу extension
9228.20 9231.96 SPEAKER_01 метод и у меня там по какому-нибудь /dashboard будет ваш дашборд,
9231.96 9235.12 SPEAKER_01 который будет показываться для моего же приложения.
9235.12 9236.12 SPEAKER_01 Вот.
9236.12 9237.12 SPEAKER_01 С одной стороны.
9237.12 9239.92 SPEAKER_01 А с другой стороны была просьба, типа, мол, а можно
9239.92 9242.44 SPEAKER_01 как-нибудь дашборд сделать, отвязать его от обхоста
9242.44 9244.20 SPEAKER_01 и сделать вообще отдельным приложением.
9244.20 9245.92 SPEAKER_01 Ну, типа, запускать его там, не знаю, отдельным
9245.92 9248.96 SPEAKER_01 контейнером или отдельной экзешкой, чтобы его как-бы
9248.96 9251.24 SPEAKER_01 не привязывать к обхосту.
9251.24 9253.92 SPEAKER_01 И это как раз, видимо, покроет вот тот самый мой сценарий,
9253.92 9255.64 SPEAKER_01 а можно ли в него слать кем-нибудь снаружи.
9255.64 9259.76 SPEAKER_01 Ну, наверное, можно, но непонятно, как это, что.
9259.76 9263.88 SPEAKER_01 На все эти штуки ребята, собственно, там два человека
9263.88 9266.56 SPEAKER_01 в основном отвечают в ишуях, кто бы ты мог подумать
9266.56 9267.56 SPEAKER_01 это?
9267.56 9271.20 SPEAKER_01 Ну, это наши стандартные, наверное, друзья, Fowler и
9271.20 9272.20 SPEAKER_01 Эдвардс.
9272.20 9273.20 SPEAKER_01 Точно.
9273.20 9274.20 SPEAKER_01 Дэмин Эдвардс.
9274.20 9277.30 SPEAKER_01 Ты абсолютно прав, да, эти двое парней аккуратненько
9277.30 9280.64 SPEAKER_01 отвечают во многих ишуях про то, что да, это в планах.
9280.64 9282.96 SPEAKER_01 То есть у них есть в планах возможность.
9282.96 9285.24 SPEAKER_01 Они не уверены, что нужно делать как extension метод,
9285.24 9288.24 SPEAKER_01 потому что они говорят, что по сути, ну, сам, короче,
9288.24 9292.00 SPEAKER_01 этот самый дашборд, ну, и его механика шлет свои
9292.00 9294.64 SPEAKER_01 ивенты тоже, то есть он будет там сам себя мерить.
9294.64 9296.20 SPEAKER_01 Из-за этого там могут быть какие-нибудь интересные
9296.20 9297.20 SPEAKER_01 сайд-эффекты.
9297.20 9298.20 SPEAKER_01 Вот.
9298.20 9301.84 SPEAKER_01 Которые они не факт, что хотят, вот, но мысль про
9301.84 9303.88 SPEAKER_01 то, что его нужно отвязать от апхаста и, может быть,
9303.88 9306.08 SPEAKER_01 сделать каким-то внешним приложением отдельным,
9306.08 9309.16 SPEAKER_01 это как бы ходит, у них есть мысль, и, может быть, они
9309.16 9310.16 SPEAKER_01 это сделают.
9310.16 9315.28 SPEAKER_01 Так что ждем развития, в общем-то, смотрим, что из
9315.28 9316.28 SPEAKER_01 этого всего получится.
9316.28 9317.88 SPEAKER_01 Если вы хотите посмотреть, как сейчас выглядит его,
9317.88 9320.56 SPEAKER_01 можно уже прям взять потрогать, можно посмотреть видосик,
9320.56 9324.84 SPEAKER_01 ссылочка есть в шоу-ноутах, и, в общем, посмотрим, разовьется
9324.84 9328.44 SPEAKER_01 ли из-за этого что-нибудь, что будет юзабельно, может
9328.44 9331.40 SPEAKER_01 быть, даже не только внутри dotnet stack.
9331.40 9334.56 SPEAKER_01 Слушай, я вообще надеялся, что тайп пойдет в другую
9334.56 9337.32 SPEAKER_01 сторону, что он как раз пойдет на то, чтобы заменить
9337.32 9340.16 SPEAKER_01 этот ужасно монструозный кубернетис, то есть как
9340.16 9342.92 SPEAKER_01 раз перенесет локальный экспириенс на продакшн,
9342.92 9346.24 SPEAKER_01 а здесь как бы явно полностью отказались от конкуренции
9346.24 9349.04 SPEAKER_01 с продакшном, и решили как раз локальный экспириенс
9349.04 9350.04 SPEAKER_01 улучшить.
9350.04 9352.44 SPEAKER_01 Ну, тоже почему бы нет, отличная тема.
9352.44 9357.92 SPEAKER_01 И мне кажется, что это шикарная область для тех людей, которые
9357.92 9360.24 SPEAKER_01 разрабатывают или, может быть, используют на больших
9360.24 9363.76 SPEAKER_01 какой-нибудь big enterprise framework, то есть я думаю, у каждой
9363.76 9366.56 SPEAKER_01 крупной компании есть какие-то enterprise framework, которые помогают
9366.56 9368.60 SPEAKER_01 как раз таки сделать то, что делает Espire.
9368.60 9372.64 SPEAKER_01 То есть вот такие инфраструктурные вещи, которые service discovery,
9372.64 9376.84 SPEAKER_01 и trying policy, и быстрое подключение через конфиги и прочие вот
9376.84 9381.40 SPEAKER_01 эти вещи, которые делаются абсолютно везде.
9381.40 9384.90 SPEAKER_01 И вот, может быть, здесь Microsoft нас пнет в нужную
9384.90 9387.20 SPEAKER_01 сторону, где мы наконец-то подойдем к какому-нибудь
9387.20 9390.88 SPEAKER_01 более или менее стандарту, когда каждая компания перестанет
9390.88 9394.60 SPEAKER_01 изобретать хотя бы уже формат пакетов, формат манифестов
9394.60 9397.80 SPEAKER_01 и формат конфигов, то есть хоть где-то они начнут уже
9397.80 9400.40 SPEAKER_01 общие вещи пилить, чтобы это можно было, например,
9400.40 9403.00 SPEAKER_01 использовать или поделиться каким-то опытом, или, как
9403.00 9405.52 SPEAKER_01 я уже сказал, собрать какие-то best practices по подключению
9405.52 9408.84 SPEAKER_01 хотя бы той же самой Kafka или Redis или еще чего-то.
9408.84 9411.32 SPEAKER_01 То есть мне кажется, начинание довольно-таки полезно,
9411.32 9414.44 SPEAKER_01 не говоря уже о той практической пользе, которую уже мы
9414.44 9417.32 SPEAKER_01 имеем и уже каждый из вас может подключить к любому
9417.32 9420.48 SPEAKER_01 своему проекту и попробовать потыкать.
9420.48 9426.44 SPEAKER_01 Ну а если они смогут отделить вот этот вот убер, так сказать,
9426.44 9429.24 SPEAKER_01 метрика визуализатор, коллектор и все такое, то что может
9429.24 9432.68 SPEAKER_01 для локал девелопмента заменить графану Егерь,
9432.68 9435.22 SPEAKER_01 Прометеус и все вместе взятое, то может быть это
9435.22 9440.00 SPEAKER_01 даже получится каким-то образом распространить,
9440.00 9442.00 SPEAKER_01 как я говорю, на другие стеки.
9442.00 9444.64 SPEAKER_01 Слушай, мы же обсуждали с тобой, что есть какой-то
9444.64 9447.08 SPEAKER_01 контейнер, который можно поднять рядом, и он через
9447.08 9452.84 SPEAKER_01 event sourcing, слушая все вот эти, ну все эти event sourcing
9452.84 9454.52 SPEAKER_01 рисует практически такую же штуку.
9454.52 9456.84 SPEAKER_01 Ну не контейнер, а скорее всего там компоус, который
9456.84 9460.04 SPEAKER_01 тебе поднимет пяток контейнеров, Прометеус отдельно, там
9460.04 9461.04 SPEAKER_01 графану отдельно.
9461.04 9462.04 SPEAKER_01 Ну да-да-да.
9462.04 9465.24 SPEAKER_01 Ну и плюс будет слушать как бы все это слайд.
9465.24 9467.44 SPEAKER_01 Ну то есть по идее такая штука была, ну и второй
9467.44 9470.96 SPEAKER_01 аргумент, что это же лежит в open-source на гитхабе.
9470.96 9473.04 SPEAKER_01 Заходите, выдирайте как бы и юзайте.
9473.04 9474.04 SPEAKER_01 Ну да.
9474.04 9477.04 SPEAKER_01 Просто народ хочет, чтобы это все не они сами поддерживали,
9477.04 9479.24 SPEAKER_01 а Microsoft это поддерживал, поэтому пишут ищи, но если
9479.24 9482.56 SPEAKER_01 сильно хочется, зайди в гитхаб, да, выдели нужный
9482.56 9483.56 SPEAKER_01 компонент себе.
9483.56 9485.68 SPEAKER_01 Все так, все так.
9485.68 9489.44 SPEAKER_01 Хорошая большая штука, посмотрим во что выльется,
9489.44 9493.28 SPEAKER_01 тайм был интересен, тайм я по крайней мере пользовался,
9493.28 9496.60 SPEAKER_01 посмотрим будет ли спайр также популярен или может
9496.60 9500.12 SPEAKER_01 быть даже еще более популярен, пока отзывы в среднем такие
9500.12 9501.12 SPEAKER_01 плюс-минус хорошие.
9501.12 9505.00 SPEAKER_01 Хорошая большая штука, такая же большая и хорошая
9505.00 9508.04 SPEAKER_01 как наш эпизод, потому что он вылез уже за все разумные
9508.04 9509.04 SPEAKER_01 рамки.
9509.04 9512.24 SPEAKER_01 Абсолютно, ну ничего страшного, давай, у нас осталось не
9512.24 9513.24 SPEAKER_01 так много.
9513.24 9516.16 SPEAKER_01 И тем более мелочь всякая, давай, сейчас в принципе
9516.16 9519.22 SPEAKER_01 на такой большой жирной ноте казалось бы все, бросайте
9519.22 9522.20 SPEAKER_01 все и бегите к экспайру, но хочется так немножко
9522.20 9524.28 SPEAKER_01 растянуть наслаждение, поэтому покайфуйте пока
9524.28 9526.08 SPEAKER_01 под парочку мелких тем.
9526.08 9529.44 SPEAKER_01 Одна из них это анонс нового нугета, который достиг
9529.44 9532.44 SPEAKER_01 версии 6.8, что бы это ни значило.
9532.44 9535.80 SPEAKER_01 И самой главной его фишкой является в том, что товарищи
9535.80 9538.60 SPEAKER_01 из нугета продолжают перейти в сторону секьюрити и здесь
9538.60 9540.36 SPEAKER_01 они добавили нугет аудит.
9540.36 9544.80 SPEAKER_01 Теперь аудит способен анализировать пакетч референсы ваших
9544.80 9546.96 SPEAKER_01 пакетов, а также, самое главное, тех пакетов, которые вы
9546.96 9550.02 SPEAKER_01 инсталируете откуда там, и он способен аудировать
9550.02 9553.48 SPEAKER_01 не только прямые пакетч референсы, на которые вы
9553.48 9555.92 SPEAKER_01 ссылаетесь, но и все транзитивные зависимости.
9555.92 9559.36 SPEAKER_01 То есть если вдруг какой-то там негодяй подцепит какую-то
9559.36 9562.48 SPEAKER_01 библиотеку, которая требует от вас донаты через десятый
9562.48 9566.00 SPEAKER_01 референс, то он тоже ее найдет, и он тоже вас предупредит.
9566.00 9569.00 SPEAKER_01 Но прежде всего он вас будет предупреждать о известных
9569.00 9571.60 SPEAKER_01 секьюрити уязвимостях, база данных гитхаба, база
9571.60 9572.60 SPEAKER_01 данных.
9572.60 9574.12 SPEAKER_01 В общем много баз данных секьюрити у него подцеплена
9574.12 9575.12 SPEAKER_01 для анализа.
9575.12 9578.44 SPEAKER_01 И он вам расскажет, что в такой-то библиотеке какие-то
9578.44 9580.76 SPEAKER_01 проблемы были найдены, сходите, посмотрите, почитайте
9580.76 9581.76 SPEAKER_01 детали.
9581.76 9586.18 SPEAKER_01 Естественно, у каждой уязвимости есть некий уровень ее критичности,
9586.18 9588.24 SPEAKER_01 и этот уровень вы можете у себя менять.
9588.24 9590.84 SPEAKER_01 То есть что вы хотите, только критические уязвимости
9590.84 9593.40 SPEAKER_01 видеть или там какие-то более мелкие, более лайтовые
9593.40 9594.40 SPEAKER_01 тоже.
9594.40 9598.98 SPEAKER_01 Вот эти сообщения о проблемах, прежде всего вы увидите
9598.98 9601.80 SPEAKER_01 когда сделаете dotnet restore, прямо вам, если вы к консольке
9601.80 9603.66 SPEAKER_01 пользуетесь, вам в консольке это напишется.
9603.66 9606.48 SPEAKER_01 Если же вы пользуетесь студией, то там тоже постарались,
9606.48 9610.32 SPEAKER_01 как бы эти сообщения будут у вас светиться в error-листе.
9610.32 9615.36 SPEAKER_01 Если вы зайдете в solution explorer и откроете там зависимости,
9615.36 9618.56 SPEAKER_01 то в этом dependency-3 тоже посветится, потом в solution
9618.56 9622.12 SPEAKER_01 explorer всплывет большая плашка, если вы прям уязвимую версию
9622.12 9623.12 SPEAKER_01 используете.
9623.12 9627.00 SPEAKER_01 И если вы откроете package-manager-ui, то есть там, где вы ставите
9627.00 9630.58 SPEAKER_01 все ваши пакетики, там тоже эти пакеты подсветятся,
9630.58 9632.18 SPEAKER_01 что они там небезопасны или там обнаружена какая-то
9632.18 9633.18 SPEAKER_01 уязвимость.
9633.18 9636.42 SPEAKER_01 В общем, со всех сторон вас будут сыпаться эти проблемы
9636.42 9640.18 SPEAKER_01 вдруг какие-то, и это очень хорошо, потому что с security-уязвимостями
9640.18 9641.18 SPEAKER_01 шутить не надо.
9641.18 9644.42 SPEAKER_01 Нужно вовремя патчиться, вовремя обновляться и обязательно
9644.42 9648.54 SPEAKER_01 держать свой код чистым и обязательно безопасным.
9648.54 9653.82 SPEAKER_01 И по мелочи сделали специальный флажочек, который позволяет
9653.82 9662.30 SPEAKER_01 вам использовать не HTTPS-сорсы Nuget пакетов и написали большой
9662.30 9665.76 SPEAKER_01 документ, который рассказывает о том, какие версии Nuget.exe
9665.76 9670.30 SPEAKER_01 и Nuget.sdk будут поддерживаться командой Nuget, потому что
9670.30 9674.18 SPEAKER_01 по их аналитике слишком много старых Nuget.exe пакетов,
9674.18 9678.74 SPEAKER_01 Nuget.exe-шников используется, в которых уже тоже и уязвимости,
9678.74 9680.98 SPEAKER_01 и совместимости, и прочие проблемы.
9680.98 9683.74 SPEAKER_01 Поэтому они сейчас задекларировали, что вот есть у нас несколько
9683.74 9688.02 SPEAKER_01 уровней сопорта, и от самых старых мы будем отказываться,
9688.02 9690.54 SPEAKER_01 поэтому внимательнее переходите, обновляйтесь и не держите
9690.54 9692.82 SPEAKER_01 свой код в таком старом протухшем виде.
9692.82 9697.54 SPEAKER_01 Ну хорошо, и давай теперь к последней новости, это
9697.54 9698.54 SPEAKER_01 Visual Studio.
9698.54 9702.02 SPEAKER_01 Конечно, какой же релиз дот-нета без релиза студии?
9702.02 9708.38 SPEAKER_01 У нас теперь релизная версия Visual Studio 17.8, мне все интересно,
9708.38 9711.72 SPEAKER_01 почему они так цепляются за эти 17.что-нибудь, когда
9711.72 9714.32 SPEAKER_01 же она станет 18.что-нибудь, наверное, это должно быть
9714.32 9717.32 SPEAKER_01 что-то супербольшое и важное, может быть, они, кстати,
9717.32 9720.02 SPEAKER_01 где-нибудь и готовятся в недрах.
9720.02 9721.50 SPEAKER_01 Портируют на Линукс ее, наконец-то.
9721.50 9724.62 SPEAKER_01 Конечно, наверняка, на Волонью.
9724.62 9725.62 SPEAKER_01 На мою еще.
9725.62 9728.46 SPEAKER_01 Ну все не могут, поэтому, ну ладно, чиселок после
9728.46 9731.62 SPEAKER_01 17.много, можно долго портировать, посмотрим.
9731.62 9734.74 SPEAKER_01 Итак, 17.8, мы, в общем-то, про все рассказывали, кратенько
9734.74 9740.10 SPEAKER_01 напомню, что там есть GitHub Copilot, поиск и замена с учетом
9740.10 9742.54 SPEAKER_01 регистра, который будет заменять правильно, да,
9742.54 9745.50 SPEAKER_01 независимо от того, в каком регистре вы ищете.
9745.50 9748.50 SPEAKER_01 Улучшение с GIT-ом, про всякие дифы, там, построчные дифы
9748.50 9749.50 SPEAKER_01 и вот это все.
9749.50 9753.94 SPEAKER_01 Улучшение скорости, особенно, если вы работаете с Razer и
9753.94 9756.58 SPEAKER_01 Blazer, они как-то вам память сильно порезали со словами
9756.58 9758.98 SPEAKER_01 "мы теперь анонсируем на 1.5 гига меньше", что же они
9758.98 9761.10 SPEAKER_01 там использовали такое ужасное.
9761.10 9763.50 SPEAKER_01 Улучшилась скорость отладки, потому что они более умно
9763.50 9764.50 SPEAKER_01 PDB-шки грузят.
9764.50 9768.74 SPEAKER_01 Для не SDK-проектов, то есть это очень старые ваши проекты,
9768.74 9773.46 SPEAKER_01 4.8 фреймворка какого-нибудь, ускорилась скорость сборки,
9773.46 9776.86 SPEAKER_01 если вы поставите специальную пропертию в MSBuild-проекте
9776.86 9780.86 SPEAKER_01 под названием Accelerate Builds in Visual Studio, ну, то есть это
9780.86 9783.94 SPEAKER_01 прям, такой типа "хочу быстрее", надо поставить эту опцию
9783.94 9784.94 SPEAKER_01 в True.
9784.94 9786.90 SPEAKER_01 Почему не сделать по дефолту, не знаю, возможно, что-то
9786.90 9787.90 SPEAKER_01 ломает.
9787.90 9791.46 SPEAKER_01 Типа, если ты ее не в студию запускаешь, то у тебя взрывается
9791.46 9793.50 SPEAKER_01 компьютер, поэтому они предохранились, а вдруг
9793.50 9794.78 SPEAKER_01 у тебя не студия.
9794.78 9795.78 SPEAKER_01 Ну, может быть, да.
9795.78 9799.58 SPEAKER_01 В F# тоже некоторое количество улучшений, автокомплит,
9799.58 9803.50 SPEAKER_01 уменьшили, скажем, визуальный шум от всяких параметров
9803.50 9806.46 SPEAKER_01 на импхентов, добавили немножко диагностик, ну,
9806.46 9808.98 SPEAKER_01 в общем, полезные и нужные улучшения.
9808.98 9812.78 SPEAKER_01 В C#, соответственно, и вообще, кстати, странно, то есть
9812.78 9816.94 SPEAKER_01 у них теперь вот в студийных релизах, да, .NET C# пишется
9816.94 9817.94 SPEAKER_01 через слэшек.
9817.94 9821.34 SPEAKER_01 Вот F# отдельно, а .NET/C# через слэшек.
9821.34 9824.90 SPEAKER_01 Причем в данном случае, в разделе .NET и C#, у них есть
9824.90 9828.90 SPEAKER_01 .NET Counters в отладчике, мне кажется, что если ты .NET
9828.90 9831.66 SPEAKER_01 Counter из F# будешь показывать, будет ровно то же самое,
9831.66 9834.82 SPEAKER_01 и в бенчмарк .NET завезли, точнее, не в бенчмарк .NET,
9834.82 9838.14 SPEAKER_01 а в Visual Studio завезли поддержку специальных ID-агнозиров,
9838.14 9840.26 SPEAKER_01 которые можно реализовать, и, соответственно, тогда
9840.26 9842.34 SPEAKER_01 результаты будут видны в Visual Studio.
9842.34 9845.82 SPEAKER_01 Как это относится к C#, я не понимаю, но вот почему-то
9845.82 9850.62 SPEAKER_01 у них теперь в .NET слэш C#, видимо, F# это уже не .NET по
9850.62 9851.62 SPEAKER_01 какой-то причине.
9851.62 9854.30 SPEAKER_01 Ну, тем не менее, ладно, отладка, кроссплатформа
9854.30 9856.86 SPEAKER_01 Edit and Continue и Hot Reload, то есть теперь если вы отлаживаете
9856.86 9862.50 SPEAKER_01 что-то в Docker или в VSL, у вас будет Hot Reload, тест профайлинг,
9862.50 9866.70 SPEAKER_01 Razor Tooling улучшили, IntelliTest в превьюшке, мы про это
9866.70 9869.90 SPEAKER_01 рассказывали, ну и Enterprise Management, куда без него, вот
9869.90 9874.30 SPEAKER_01 эти все инсталляции и инсталляции с разными опциями и настройками,
9874.30 9876.98 SPEAKER_01 и кому что можно разрешать, когда там доустанавливать
9876.98 9878.98 SPEAKER_01 пакеты, когда не доустанавливать.
9878.98 9882.50 SPEAKER_01 В общем, про 17.8 релизный мы много о чем говорили,
9882.50 9885.86 SPEAKER_01 берите, ставьте, пользуйтесь, там все стабильно, надежно
9885.86 9886.86 SPEAKER_01 и так далее.
9886.86 9890.06 SPEAKER_01 Ну и естественно, вместе с релизом 17.8 появился 17.9
9890.06 9891.06 SPEAKER_01 Preview 1.
9891.06 9894.02 SPEAKER_01 И надо сказать, обычно в Preview 1 было всякое разное,
9894.02 9896.90 SPEAKER_01 ну такое типа, по мелочи, а здесь прям довольно много
9896.90 9898.22 SPEAKER_01 всяких разных изменений.
9898.22 9902.02 SPEAKER_01 Во-первых, теперь, если у вас есть Copilot, у вас теперь
9902.02 9905.38 SPEAKER_01 будут автоматически генерироваться Git Commit Messages, вам достаточно
9905.38 9908.46 SPEAKER_01 сказать, ну открыть окошко Коммит и вам туда напишут
9908.46 9914.46 SPEAKER_01 сразу AI Summary того, что вы сделали, глядя на ваш код.
9914.46 9917.50 SPEAKER_01 Надо наоборот, надо, чтобы человек писал Summary, а я
9917.50 9919.06 SPEAKER_01 полностью имплементацию по нему делал.
9919.06 9920.06 SPEAKER_01 Действительно.
9920.06 9923.18 SPEAKER_01 Но пока, но это Copilot обычно делает, по сути.
9923.18 9926.90 SPEAKER_01 А потом из этого собирает Summary для Git, ну нормально,
9926.90 9927.90 SPEAKER_01 кстати.
9927.90 9928.90 SPEAKER_01 Вот.
9928.90 9932.46 SPEAKER_01 Дальше в отчетах, ну не в отчетах, а в профайлере,
9932.46 9935.58 SPEAKER_01 в мемори профайлер появилась отдельная диагностика
9935.58 9939.74 SPEAKER_01 про Event Handler утечки, то есть, ну это стандартно, когда
9939.74 9942.38 SPEAKER_01 вы подписываетесь и там не вовремя отписываетесь,
9942.38 9944.86 SPEAKER_01 если все это утекает, теперь вам там прямо явно в профайлере
9944.86 9946.94 SPEAKER_01 скажут, вот тут вот и подписался и не отписался.
9946.94 9950.74 SPEAKER_01 И полезная, наверное, фича, вы знаете, что есть такая
9950.74 9954.78 SPEAKER_01 штука Debug Visualizers, это когда можно там на переменные
9954.78 9957.30 SPEAKER_01 определенных типов, то есть это на стройках работает,
9957.30 9958.30 SPEAKER_01 на...
9958.30 9961.70 SPEAKER_01 Что-то я забыл, на чем еще, но недавно буквально добавляли
9961.70 9964.82 SPEAKER_01 еще какие-то визуалайзеры, давно не пользовался, забыл.
9964.82 9966.94 SPEAKER_01 Короче, вот эти окошки, они теперь не модальны, можно
9966.94 9970.30 SPEAKER_01 их оставить и там будет, соответственно, значение
9970.30 9971.30 SPEAKER_01 обновляться, я так понимаю.
9971.30 9977.34 SPEAKER_01 В C# появилась очень интересная штука, я не знаю, как это
9977.34 9982.02 SPEAKER_01 будет работать, называется Automatic Deoptimization, вот как ты
9982.02 9985.82 SPEAKER_01 думаешь по названию, зачем такое, может быть, надо?
9985.82 9988.94 SPEAKER_01 Если ты отлаживаешь и твой код часто там инлайнится
9988.94 9991.88 SPEAKER_01 или оптимизируется, или может быть, даже нет, аутится
9991.88 9994.94 SPEAKER_01 сразу, то избавиться от этой всей глупости и позволить
9994.94 9999.38 SPEAKER_01 под дебаггером наконец-то пройтись по тому коду, который
9999.38 10000.38 SPEAKER_01 писал не ты.
10000.38 10001.38 SPEAKER_01 Да, именно так.
10001.38 10003.82 SPEAKER_01 Даже если писал ты, но скомпилировал в релиз моде, например, из-за
10003.82 10006.98 SPEAKER_01 вашего NuGet пакета подтянулся что-то в релиз моде, это
10006.98 10010.82 SPEAKER_01 действительно штука, которая автоматически деоптимизирует
10010.82 10013.70 SPEAKER_01 релизный код и экстернал код, то, что называется,
10013.70 10015.26 SPEAKER_01 да, то есть который не ваш.
10015.26 10018.50 SPEAKER_01 Ну, наконец-то, потому что, блин, уже столько веков
10018.50 10021.38 SPEAKER_01 мы мучаемся с этой штукой, и наконец-то появилось.
10021.38 10022.38 SPEAKER_01 Я рад.
10022.38 10025.06 SPEAKER_01 Причем штука умная, она это делает только для тех
10025.06 10027.70 SPEAKER_01 узков кода, где вы поставили breakpoint или через которые
10027.70 10028.70 SPEAKER_01 вы идёте дебаггером.
10028.70 10031.26 SPEAKER_01 То есть всё остальное будет выполняться в релизе, быстро
10031.26 10032.26 SPEAKER_01 оптимизировано и всё как надо.
10032.26 10034.46 SPEAKER_01 Да я бы с удовольствием согласился, чтобы он всё
10034.46 10037.06 SPEAKER_01 деоптимизировал, лишь бы не это самое, не было проблем
10037.06 10038.06 SPEAKER_01 с этим.
10038.06 10039.50 SPEAKER_01 Мне не очень понятно, как это работает, ну потому
10039.50 10043.02 SPEAKER_01 что деоптимизация, это почти сродни восстановить
10043.02 10045.98 SPEAKER_01 значение по хэшу, ну до некоторой степени.
10045.98 10050.86 SPEAKER_01 Но, видимо, он как-то пытается угадать, чтобы хотя бы какие-то
10050.86 10052.70 SPEAKER_01 локальные переменные обратно появились, потому что вы,
10052.70 10054.82 SPEAKER_01 наверное, много раз сталкивались, что в релизном коде вы пытаетесь
10054.82 10056.82 SPEAKER_01 посмотреть локал-переменную или какого-нибудь кусочка
10056.82 10058.74 SPEAKER_01 стека, да, когда вы наверх по стеку поднялись, там
10058.74 10059.74 SPEAKER_01 говорится, ну нет такого.
10059.74 10062.54 SPEAKER_01 Хотя вы знаете, что она там есть, но нету, потому
10062.54 10065.62 SPEAKER_01 что всё оптимизировано, лежит, видимо, где-то в регистре
10065.62 10067.14 SPEAKER_01 и вам не доступно.
10067.14 10068.14 SPEAKER_01 Теперь будет доступно.
10068.14 10069.14 SPEAKER_01 Посмотрим.
10069.14 10071.74 SPEAKER_01 Ну, смотри, те же самые или декомпилеры вполне сносный
10071.74 10072.74 SPEAKER_01 код выдают.
10072.74 10077.50 SPEAKER_01 Он даже хорошо написанный, со свёрнутыми обратно циклами,
10077.50 10078.94 SPEAKER_01 с введёнными локальными переменными, даже имена
10078.94 10079.94 SPEAKER_01 у них иногда нормальные.
10079.94 10082.78 SPEAKER_01 Поэтому, если уж или декомпилер справился, то студия-то тем
10082.78 10083.78 SPEAKER_01 более справится.
10083.78 10088.02 SPEAKER_01 Ну, она, по сути, тоже декомпайлер, поэтому, ну да, да, посмотрим.
10088.02 10089.02 SPEAKER_01 Посмотрим, как будет работать.
10089.02 10091.70 SPEAKER_01 Я на это очень много натыкался, мне довольно много приходилось
10091.70 10095.38 SPEAKER_01 отложить именно релизного кода, поэтому типа в продакшене
10095.38 10096.38 SPEAKER_01 отлаживаешься.
10096.38 10098.26 SPEAKER_01 Ну, самое главное, теперь будет деоптимизированный
10098.26 10099.26 SPEAKER_01 продакшен.
10099.26 10101.90 SPEAKER_01 Ну да, да, вот я тоже очень часто с этим сталкивался,
10101.90 10103.86 SPEAKER_01 поэтому странно, что до сих пор не сделали.
10103.86 10104.86 SPEAKER_01 Вот.
10104.86 10105.86 SPEAKER_01 Дальше.
10105.86 10108.54 SPEAKER_01 Ну, про Blazor scaffolding ты написал новый шаблончик.
10108.54 10112.32 SPEAKER_01 Значит, расширение, Extensibility, тут тоже появилось одно
10112.32 10113.32 SPEAKER_01 улучшение.
10113.32 10116.18 SPEAKER_01 Теперь есть такой файлик .wsconfig, куда можно прописать
10116.18 10119.32 SPEAKER_01 все нужные экстенджины, отдать его соседу, сосед
10119.32 10122.58 SPEAKER_01 скормит его Visual Studio, и Visual Studio доставит все нужные
10122.58 10123.58 SPEAKER_01 экстенджины сама.
10123.58 10126.74 SPEAKER_01 Ну, не сама, в смысле, он скажет, вот тут вам не хватает
10126.74 10128.42 SPEAKER_01 этих экстенджин, давайте поставим.
10128.42 10130.82 SPEAKER_01 То есть, это способ пошарить экстенджины с соседом.
10130.82 10135.22 SPEAKER_01 Ну, это тоже неплохо, но блин, сделайте мне файлик,
10135.22 10137.02 SPEAKER_01 который я могу хоткейсовой положить, это мне больше
10137.02 10138.02 SPEAKER_01 надо.
10138.02 10139.94 SPEAKER_01 Ну вот, я пока не понял, даже с этим файликом, можно
10139.94 10142.30 SPEAKER_01 ли его прям закоммитить в гид, и она это сделает
10142.30 10144.66 SPEAKER_01 в момент открытия Solution, или все-таки это требует,
10144.66 10147.46 SPEAKER_01 там, не знаю, условного, ну, не инсталлера, но хотя
10147.46 10149.86 SPEAKER_01 бы просто хождения в опшнс, посмотрим.
10149.86 10153.14 SPEAKER_01 Не, может, может, это фишка Visual Studio, в принципе, работает
10153.14 10155.66 SPEAKER_01 давно, Visual Studio Code, то есть, работает давно, потому
10155.66 10157.66 SPEAKER_01 что там без экстенджина вообще ничего не делается,
10157.66 10159.90 SPEAKER_01 да, это обычный блокнотик, а вот если ты поставишь
10159.90 10161.86 SPEAKER_01 там какой-нибудь экстендж на целую кучу, вот тогда
10161.86 10163.98 SPEAKER_01 оно у тебя превращается в редактор, и поэтому там
10163.98 10167.70 SPEAKER_01 есть такая секция специальная, которая тебе помогает,
10167.70 10169.14 SPEAKER_01 рассказывает, какие надо экстенджины поставить,
10169.14 10170.46 SPEAKER_01 чтобы с этим репозиторием поработать.
10170.46 10174.26 SPEAKER_01 Но это Visual Studio Code, а это Visual Studio, это разные продукты,
10174.26 10176.58 SPEAKER_01 поэтому хрен его знает, как они сделали, как в
10176.58 10177.58 SPEAKER_01 Visual Studio.
10177.58 10179.54 SPEAKER_01 Там перетекает идея уже туда и сюда, во все.
10179.54 10181.70 SPEAKER_01 Ну, идея, да, а вот реализация не очень.
10181.70 10185.98 SPEAKER_01 Ну, ладно, и последнее, что они сделали, это довольно,
10185.98 10190.74 SPEAKER_01 ну, они это объявляют как вообще massive UI refresh, превью,
10190.74 10193.86 SPEAKER_01 вот это все, новые, короче, темы, новые…
10193.86 10195.66 SPEAKER_01 Наконец, на мою и под Linux.
10195.66 10199.58 SPEAKER_01 Нет, пока на WPF и под Window, но тем не менее, короче,
10199.58 10203.18 SPEAKER_01 они там аж говорят, что типа, вот, смотрите, в старых
10203.18 10206.18 SPEAKER_01 темах, в дефолтном каком-то условном варианте вам было
10206.18 10212.42 SPEAKER_01 доступно 34 и 3/4 строчки кода, мы сделали какие-то изменения
10212.42 10215.66 SPEAKER_01 тем, короче, вам стало доступно 33, вы сказали, что это никуда
10215.66 10217.94 SPEAKER_01 не годится, мы, короче, все переделали, теперь вам
10217.94 10221.86 SPEAKER_01 доступно 34,5 строчки кода, типа, сорян, мы как бы четверть
10221.86 10224.54 SPEAKER_01 строчки кода у вас забрали, но Accessibility и все такое.
10224.54 10231.70 SPEAKER_01 Ну, это все, в общем, мелочи на тему того, что, что там,
10231.70 10235.02 SPEAKER_01 куда поменялось, и визуально, мне кажется, там есть изменения,
10235.02 10237.30 SPEAKER_01 но они все-таки не такие сильные, там важно то,
10237.30 10238.86 SPEAKER_01 что они внутри поменяли.
10238.86 10242.62 SPEAKER_01 Если взять, если ты бы хотел, например, создать Visual
10242.62 10246.50 SPEAKER_01 Studio тему в прошлом, для старой студии, как ты думаешь,
10246.50 10249.82 SPEAKER_01 сколько тебе нужно задать разных цветов для разных
10249.82 10250.82 SPEAKER_01 элементов?
10250.82 10254.42 SPEAKER_01 Типа вот кнопочки, цвет кейворда, бэкграунда.
10254.42 10258.82 SPEAKER_01 Цвет фона, цвет кейворда, цвет там, не знаю, редактора,
10258.82 10259.82 SPEAKER_01 цвет топ-мара.
10259.82 10261.46 SPEAKER_01 Блин, я думаю, сотни.
10261.46 10262.46 SPEAKER_01 Четыре тысячи.
10262.46 10263.46 SPEAKER_01 Четыре тысячи?
10263.46 10264.46 SPEAKER_01 Ну, чуть больше.
10264.46 10265.46 SPEAKER_01 Нормаль, нормаль.
10265.46 10267.78 SPEAKER_01 То есть ты понимаешь, да, вот сколько нужно было
10267.78 10271.74 SPEAKER_01 поменять цветов, чтобы сделать, ну, как бы типа единую нормальную
10271.74 10272.74 SPEAKER_01 красивую тему.
10272.74 10275.30 SPEAKER_01 Ну, просто вряд ли этим загонялись пока бы полностью.
10275.30 10276.90 SPEAKER_01 Брали какую-нибудь или светлую, или тёмную, меняли
10276.90 10279.02 SPEAKER_01 в ней десяток, и вот тебе уже новая тема.
10279.02 10281.50 SPEAKER_01 Там я пытался так делать, я когда-то пытался сделать
10281.50 10284.38 SPEAKER_01 так, чтобы у меня окошко редактора было светло-сереньким.
10284.38 10288.02 SPEAKER_01 Один момент, я так жил со светло-серым бэкграундом.
10288.02 10289.02 SPEAKER_01 Вендея…
10289.02 10291.06 SPEAKER_01 Не, ну если ты один элемент, он же через настройки настраивается.
10291.06 10292.94 SPEAKER_01 Там тебе не надо темы делать.
10292.94 10295.14 SPEAKER_01 Это ты так думаешь.
10295.14 10297.90 SPEAKER_01 Ты меняешь элемент через настройки, а Solution Explorer
10297.90 10298.90 SPEAKER_01 белый.
10298.90 10301.02 SPEAKER_01 Ну, ты же не хотел Solution Explorer, ты хотел только окошко.
10301.02 10304.62 SPEAKER_01 Нет, я хотел все белые бэкграунды в студии сделать серыми.
10304.62 10306.78 SPEAKER_01 Не, ну это ты много хочешь, я согласен.
10306.78 10310.90 SPEAKER_01 Это меня заняло примерно, ну, к счастью, их всего 15,
10310.90 10311.90 SPEAKER_01 по-моему.
10311.90 10316.26 SPEAKER_01 Мне было достаточно поменять, по-моему, 6 или 7, потому
10316.26 10318.78 SPEAKER_01 что остальных окошек я просто не пользуюсь.
10318.78 10321.58 SPEAKER_01 И половину из них только через реестр можно сделать.
10321.58 10322.58 SPEAKER_01 Вот.
10322.58 10325.10 SPEAKER_01 Ну, это ладно, это тонкости, детали.
10325.10 10326.10 SPEAKER_01 Вот.
10326.10 10330.14 SPEAKER_01 В новых стилях у нас теперь всего лишь сотня, ну, примерно
10330.14 10331.74 SPEAKER_01 сотня токенов и цветов.
10331.74 10334.34 SPEAKER_01 Ну, вот кажется, что на практике оно столько и должно быть.
10334.34 10339.58 SPEAKER_01 И более того, Мэдс Кристенсен, это наш любимый экстенджер-настроитель,
10339.58 10343.34 SPEAKER_01 который их клепает, ну, не сотнями, но десятками,
10343.34 10344.34 SPEAKER_01 возможно, в месяц.
10344.34 10345.54 SPEAKER_01 Мы просто про всенесы не рассказываем.
10345.54 10348.22 SPEAKER_01 Говорит, что вообще говоря, у него даже есть пример
10348.22 10352.42 SPEAKER_01 на гитхабе, посмотрите в его гитхаб, что, в принципе,
10352.42 10354.54 SPEAKER_01 говорит, базовую тему, которая нормально выглядит и которая
10354.54 10357.98 SPEAKER_01 не как бы сильно загоняется, можно теперь сделать с
10357.98 10360.66 SPEAKER_01 новой студией, используя только 7 цветов.
10360.66 10363.74 SPEAKER_01 Ну, это, наверное, исключая подсветку кода, потому
10363.74 10366.26 SPEAKER_01 что у одной подсветки будет… Да-да-да, подсветки будет
10366.26 10368.22 SPEAKER_01 много, но, по крайней мере, вот именно базовую тему
10368.22 10372.18 SPEAKER_01 именно UI достаточно задать 7 цветов, чтобы, ну, как бы
10372.18 10375.26 SPEAKER_01 основные, видимо, там, фореграунды, бэкграунды, ну, грубо говоря,
10375.26 10376.26 SPEAKER_01 они теперь бэкграунд везде один сделали.
10376.26 10379.34 SPEAKER_01 Ну, нафига тебе разный бэкграунд в Solution Explorer и
10379.34 10381.14 SPEAKER_01 в тексте кода, скорее всего.
10381.14 10384.50 SPEAKER_01 Не, ну, тогда, конечно, если без кода, там, тебе, что-то
10384.50 10385.90 SPEAKER_01 цифры выбирал уже до менюшки.
10385.90 10389.10 SPEAKER_01 Ну, это, на самом деле, прикольно, то есть, ну, типа, на 7 цветах
10389.10 10392.86 SPEAKER_01 это прям уже хорошо, это можно хоть как-то что-то
10392.86 10393.86 SPEAKER_01 кастомизировать.
10393.86 10395.70 SPEAKER_01 Ну, примерно вот, то есть, я подразумеваю, что, может
10395.70 10397.74 SPEAKER_01 быть, это как-то повлияет на количество, не знаю,
10397.74 10399.70 SPEAKER_01 тем, потому что, кстати, для студии я не видел сильно
10399.70 10403.34 SPEAKER_01 большого количества тем, но, правда, сильно не интересовался,
10403.34 10404.34 SPEAKER_01 я в среднем живу на стандартных.
10404.34 10407.86 SPEAKER_01 Обсуждали, по-моему, есть экстеншн, который темы от
10407.86 10410.06 SPEAKER_01 Visual Studio Code забирает, а там их уже полно.
10410.06 10411.06 SPEAKER_01 Да.
10411.06 10413.50 SPEAKER_01 Ну, вот, видимо, кто-то когда-то один раз написал и все.
10413.50 10416.62 SPEAKER_01 Ну, примерно так, на этом, наконец-таки, мне кажется
10416.62 10417.62 SPEAKER_01 все.
10417.62 10421.98 SPEAKER_01 Ну, как я говорил, в dotnet.conf плейлисте 102 видео, как
10421.98 10430.30 SPEAKER_01 вы понимаете, мы обозрели, отсмотрели не все, мы рассказали
10430.30 10433.90 SPEAKER_01 не про все, мы упустили много всяких разных интересных
10433.90 10436.82 SPEAKER_01 докладов, там есть такие более рекламные и более
10436.82 10441.30 SPEAKER_01 технические, и как пользоваться всеми теми самыми технологиями,
10441.30 10443.66 SPEAKER_01 мы поговорили не про то, как они выглядят, а про
10443.66 10446.82 SPEAKER_01 то, что они такое, так что смотрите по заголовкам,
10446.82 10451.10 SPEAKER_01 они там разной длины, разного наполнения, но заголовки
10451.10 10453.26 SPEAKER_01 везде более-менее понятны, в том плане, что практически
10453.26 10455.90 SPEAKER_01 по всем по ним можно понять, что происходит внутри.
10455.90 10458.90 SPEAKER_01 Ну, если найдете там какой-нибудь интересный видосик, или
10458.90 10461.58 SPEAKER_01 вдруг мы не упомянули ту тему, которую вы ожидаете,
10461.58 10464.10 SPEAKER_01 или вообще у вас есть комментарии к тому, что мы рассказывали,
10464.10 10467.42 SPEAKER_01 поэтому заходите в комментарии к нам на ютубчике, например,
10467.42 10469.78 SPEAKER_01 и пишите, пишите все, что вы об этом думаете.
10469.78 10472.32 SPEAKER_01 Главное, если вы дослушали до этого места, потому
10472.32 10477.06 SPEAKER_01 что кажется, это будет где-то в районе 2.30, как мне думается,
10477.06 10480.22 SPEAKER_01 вот интересно, угадаю я или нет после всей обработки.
10480.22 10483.82 SPEAKER_01 Ну ладно, итак, сегодня мы, да не буду я перечислять,
10483.82 10484.82 SPEAKER_01 что мы сегодня посмотрели, мы сегодня посмотрели
10484.82 10487.90 SPEAKER_01 на релиз Докната 8, во всех его проявлениях.
10487.90 10490.98 SPEAKER_01 Ну вот и схалтурничал, вообще схалтурничал, конечно.
10490.98 10493.54 SPEAKER_01 Ну лайки вы все равно ставьте, вот это все.
10493.54 10496.26 SPEAKER_01 Да, лайки, шарики, репосты, звездочки, поддерживайте
10496.26 10499.42 SPEAKER_01 нас, рассказывайте друзьям, а мы вроде про все рассказали,
10499.42 10501.54 SPEAKER_01 про что хотели, пойдем отдыхать.
10501.54 10502.54 SPEAKER_01 Пойдем.
10502.54 10503.54 SPEAKER_01 Всем пока.

