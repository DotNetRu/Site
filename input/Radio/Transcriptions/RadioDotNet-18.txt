0.00 3.20 "Анатолий Кулаков" Всем привет!
3.20 7.00 "Анатолий Кулаков" В эфире радио .NET, выпуск номер 18.
7.00 8.88 "Анатолий Кулаков" И с вами Анатолий Кулаков.
8.88 9.88 "Анатолий Кулаков" И Игорь Лабутин.
9.88 13.68 "Анатолий Кулаков" Сегодня мы поговорим о такой замечательной теме, как .NET 5.
13.68 23.20 "Анатолий Кулаков" Зарелизилась большая, большая толстая ветка, прошла большая веха и в нас в будущем ждет много интересных и привлекательных фич.
23.20 26.08 "Анатолий Кулаков" Вот этому и хотелось бы посвятить сегодня весь выпуск.
26.08 38.40 "Анатолий Кулаков" Мы, конечно же, про .NET 5 говорили все это время, уже практически целый год рассматривали фичи, рассматривали релиз кандидаты более подробно, более предметно.
38.40 42.20 "Анатолий Кулаков" Какие-то фичи уже отвалились, их не взяли релиз, какие-то наоборот добавились.
42.20 48.92 "Анатолий Кулаков" В общем, я думаю, не мешает нам повториться и собрать весь тот опыт, который мы накопили за год.
48.92 51.72 "Анатолий Кулаков" И начать, прежде всего, хотелось бы с истории.
51.72 60.32 "Анатолий Кулаков" Давайте все-таки рассмотрим, как мы пришли к этому релизу, как мы пришли к этой дате, тем более, что .NET исполняется в этом году ровно 20 лет.
60.32 66.80 "Анатолий Кулаков" Да-да, именно в 2000 году была представлена первая превью .NET и C#.
66.80 79.28 "Анатолий Кулаков" Если кто не помнит, то вся эта история началась с того, что Microsoft пытался как-то нажиться на популярности Java, сделал свой собственный нестандартный язык J++ и пытался его продвигать.
79.28 83.72 "Анатолий Кулаков" На что Sun подала иск в суд на какие-то бешеные миллионы и в принципе иск выиграла.
83.72 87.20 "Анатолий Кулаков" И Microsoft понял, что связываться с Java не очень интересно.
87.20 95.48 "Анатолий Кулаков" И решил создать свой полностью новый язык, забрав из Java самые лучшие концепты, которые ему казалось, и добавив какие-то свои введения.
95.48 102.84 "Анатолий Кулаков" На то время у Microsoft уже был очень богатый опыт поддержки и создания своих, таких как, например, C++ и так далее.
102.84 111.72 "Анатолий Кулаков" Но в принципе такой полный с нуля написанный язык у Microsoft, наверное, это первая попытка, если не считать, конечно, BASIC.
111.72 114.84 "Анатолий Кулаков" И эта попытка довольно-таки хорошо взлетела.
114.84 118.88 "Анатолий Кулаков" Итак, первая версия была зарелижена в 2002 году.
118.88 122.36 "Анатолий Кулаков" В нее сразу же вошли property, event.
122.36 130.88 "Анатолий Кулаков" По сравнению с Java Microsoft изменила naming convention, который больше соответствовал Дельфевскому, Паскалевскому и много из плюсов все-таки взяло.
130.88 136.28 "Анатолий Кулаков" Также уже с первой версии было понятно, что у C# есть отличная система метатипов.
136.28 147.80 "Анатолий Кулаков" Например, там есть атрибуты и эта система позволила практически безгранично расширять ваш код и расширять те возможности, которые ваша программа имеет.
147.80 154.64 "Анатолий Кулаков" Java украла эту идею где-то в SE 5.0 и у нее тоже появилась подобная система расширений.
154.64 159.68 "Анатолий Кулаков" В 2003 году был выпущен C# 1.2 и .NET 1.1.
159.68 171.72 "Анатолий Кулаков" Насколько я помню, что .NET 1.1 это такой самый популярный фреймворк, на который пришло очень много разработчиков, на котором как раз-таки у многих состоялось знакомство с .NET.
171.72 177.20 "Анатолий Кулаков" Самая главная фича этого релиза, C# 1.2 была просто стабильность.
177.20 185.16 "Анатолий Кулаков" Они вылизали все, что было до этого, сделали кучу работы над ошибками, исправили баги, ничего в принципе такого интересного нововведения никаких не было.
185.16 188.44 "Анатолий Кулаков" В 2006 был C# 2.0.
188.44 193.32 "Анатолий Кулаков" Туда добавились partial classes, анонимные методы и самое главное - дженерики.
193.32 211.80 "Анатолий Кулаков" То есть 2006 год уже дженерики настоящие, красивые, прекрасные у нас уже были и это была довольно-таки мощная, крутая штука, которая позволила заменить очень много такого boilerplate кода, где приходилось на каждый тип создавать свой вариант виста, свой вариант репозитория и прочих глупостей.
211.80 215.04 "Анатолий Кулаков" Слава богу, что мы об этом забыли довольно-таки быстро, как о страшном сне.
215.04 225.96 "Игорь Лабутин" Да, но делегаты эти самые жили довольно-таки долго и ключевое слово делегат я помню до сих пор и как-то периодически иногда даже встречаю в каком-то своем коде, до сих пор живет.
225.96 231.84 "Анатолий Кулаков" Но если мы говорим про новый какой-то код, то я вообще не помню, когда я последний раз писал ключевое слово
231.84 241.40 "Игорь Лабутин" делегат. Ну вот я тоже не помню, но да, анонимные методы через лямбды стали конечно прям совсем здорово, но это появилось попозже.
241.40 242.96 "Игорь Лабутин" Это появилось в C# 3.0.
242.96 246.72 "Анатолий Кулаков" Да, который уже в 2007 году был с нами, то есть ровно через год.
246.72 260.84 "Анатолий Кулаков" И там появились не просто анонимные лямбды, здесь появился линк, который дал толчок всему этому движению, query expressions, лямбда expressions и такие более функциональные вещи.
260.84 263.52 "Анатолий Кулаков" То есть уже с 2007 года C# начал двигаться в сторону функциональщины.
263.52 276.00 "Анатолий Кулаков" Появились замыкания, лямбды, линку и все-все-все, что определило, в принципе, предрекло его судьбу как главного воровальщика функциональных вещей среди всех языков.
276.00 281.08 "Игорь Лабутин" А потом был опять перерыв в три года и три года Microsoft что-то там разрабатывала.
281.08 285.60 "Игорь Лабутин" В те времена мы не знали что, все было закрыто и неизвестно до тех пор, пока не зарелизится.
285.60 296.08 "Игорь Лабутин" И в 2010 году появился C# 4, где появилась, наверное, главная большая штука, это DLR, Dynamic Language Runtime.
296.08 306.52 "Игорь Лабутин" И из мелких фич, таких, которые помню я, это опциональные аргументы в функциях, так что теперь можно было не писать полную сигнатуру при вызовах, а использовать аргументы по умолчанию.
306.52 308.52 "Анатолий Кулаков" А что ты можешь сказать про DLR?
308.52 309.52 "Анатолий Кулаков" Как тебе эта фича?
309.52 312.80 "Анатолий Кулаков" И используется ли она тобой, или как ты считаешь, нужна ли она была?
312.80 314.40 "Анатолий Кулаков" Или какая-то ошибочная была ветка?
314.40 316.44 "Игорь Лабутин" Я ее не использовал.
316.44 323.16 "Игорь Лабутин" Я думаю, что она была нужна для того, чтобы попытаться сделать нормальный интероп с другими языками.
323.16 327.88 "Игорь Лабутин" И я так понимаю, что в интеропе с другими языками она может быть даже до сих пор сейчас где-то используется.
327.88 334.40 "Игорь Лабутин" Какой-нибудь там интероп с питоном, почему бы и не использовать через динамик или еще что-нибудь такое.
334.40 339.36 "Игорь Лабутин" Но я так понимаю, что сейчас кроме как для этих целей, она ни для чего больше не пригодилась.
339.36 344.56 "Анатолий Кулаков" Ну, я тебе напомню, был большой хайп, вместе с DLR вышел Iron Python и Iron Ruby.
344.56 356.16 "Анатолий Кулаков" Это вот как раз была такая идея, что типа мы сейчас на DLR перепишем вообще все скриптовые языки, они смогут запускаться по Дотнетам, и мы получим такую мультикросс-платформину языковую среду.
356.16 358.40 "Анатолий Кулаков" То есть, согласись, идея была интересная.
358.40 359.80 "Анатолий Кулаков" Было бы классно, если бы она взлетела.
359.80 363.80 "Анатолий Кулаков" В принципе, у Джавы такая штука летит.
363.80 369.04 "Анатолий Кулаков" Есть очень много языков, которые запускаются по JVM и чувствуют там себя довольно-таки хорошо.
369.04 374.20 "Анатолий Кулаков" У C#, к сожалению, это все умерло, заглохло.
374.20 382.48 "Анатолий Кулаков" Хотя я на протяжении последних лет слышу, что собирается возрождать Iron Python, уже на новой третьей версии совместимости с Python и так далее.
382.48 384.72 "Анатолий Кулаков" Но что-то как-то все до сих пор там тихо.
384.72 397.60 "Анатолий Кулаков" Также DLR очень много использовался и используется при взаимодействии с COM, потому что это то средство, которое позволяет вам не указывать 200 тысяч аргументов, которые требует COM, а сделать это все довольно-таки прозрачно и красиво.
397.60 405.60 "Игорь Лабутин" К счастью, я, когда перешел на .NET, практически на 100% перестал пользоваться COM, поэтому мне не нужно было их как-то дружить вместе.
405.60 411.92 "Анатолий Кулаков" Но один язык, который хотелось бы упомянуть, это все-таки есть, он выжил.
411.92 418.60 "Анатолий Кулаков" Ты догадываешься, какой самый популярный, самый крутецкий и самый интересный язык на свете выжил на DLR?
418.60 419.60 "Анатолий Кулаков" JavaScript?
419.60 420.60 "Анатолий Кулаков" Не-не-не.
420.60 424.92 "Анатолий Кулаков" Ну, кстати, на DLR, если вы зайдете в Википедию, то на DLR там до хрена языков написано.
424.92 429.16 "Анатолий Кулаков" Там было 50 языков на .NET платформе, которые поддерживались через DLR.
429.16 439.36 "Анатолий Кулаков" Они, естественно, сейчас все заглохли более или менее, умерли, но нет, есть один очень живой язык, и я бы сказал, это один из самых распространенных языков в мире.
439.36 443.16 "Анатолий Кулаков" По крайней мере, его интерпретатор есть практически на каждом виндовом компе.
443.16 444.16 "Анатолий Кулаков" Basic?
444.16 445.16 "Анатолий Кулаков" Нет.
445.16 448.44 "Анатолий Кулаков" Не уверен, что Basic там где-то есть уже на последних виндах.
448.44 449.44 "Анатолий Кулаков" Это PowerShell.
449.44 457.72 "Анатолий Кулаков" В общем, это малоизвестный факт, но на самом деле PowerShell - это язык на .NET, который активно использует DLR.
457.72 458.72 "Анатолий Кулаков" Прикольно.
458.72 463.80 "Анатолий Кулаков" Так что PowerShell живее всех живых, цветет, здравствует, выпускает новые релизы.
463.80 465.48 "Игорь Лабутин" И теперь еще и кроссплатформенный.
465.48 467.16 "Анатолий Кулаков" А теперь еще и кроссплатформенный, да.
467.16 473.16 "Анатолий Кулаков" Правда, я не знаю, откуда они в коре нашли DLR, может, они все-таки дошли к тому, чтобы его переписать.
473.16 474.52 "Анатолий Кулаков" Надо эту тему как-то покопать.
474.52 477.08 "Анатолий Кулаков" Ладно, что-то мы задержались, пойдем дальше.
477.08 482.00 "Анатолий Кулаков" C# 5 в 2012 году принес нам Async и Await.
482.00 491.76 "Анатолий Кулаков" Это, мне кажется, очень крутая фича, которую я пользуюсь каждый день, которая сильно изменила то, как наши разработчики программируют.
491.76 501.36 "Анатолий Кулаков" Ну, то есть Async раньше тоже был, но с помощью вот этой лапши с коллбеками и прочих глупостей, которыми остальной мир пользуется практически по сей день.
501.36 507.28 "Анатолий Кулаков" Это та самая фича, которую украл JavaScript в ES 7.
507.28 509.64 "Анатолий Кулаков" Ну, и также дофига много других языков.
509.64 519.00 "Анатолий Кулаков" Титон она появилась, всякие Кортлиновские Async/Await были очень сильно воодушевлены C# реализацией, там они что-то изменили.
519.00 521.80 "Анатолий Кулаков" Ну, и, в общем, мне кажется, там очень много современных языков.
521.80 523.92 "Анатолий Кулаков" Так или иначе, Async/Await у нас украли.
523.92 529.20 "Игорь Лабутин" Это та фича, которая, кажется, появилась, казалось бы, очень недавно, но, блин, 8 лет уже.
529.20 530.20 "Анатолий Кулаков" 8 лет, да.
530.20 534.68 "Анатолий Кулаков" Ну, и справедливости ради, нужно сказать, что, конечно же, не C# был изобретателем этой фичи.
534.68 547.24 "Анатолий Кулаков" Как минимум, в F# она уже точно была, но точно C# стал ее самым главным популяризатором, главным проталкивателем в мир, что люди увидели, что в обычных процедурных OOP языках это может шикарно работать.
547.24 549.16 "Анатолий Кулаков" В общем, за это, конечно, честь и хвала.
549.16 551.28 "Анатолий Кулаков" C# 6, 2015 год.
551.28 554.84 "Анатолий Кулаков" В этом релизе самая громкая фича была, конечно же, Roslyn.
554.84 558.40 "Анатолий Кулаков" Roslyn - это компилятор C#, который написан на самом C#.
558.40 564.60 "Анатолий Кулаков" Уже в те времена у нас в C# очень мало было синтаксического сахара все-таки.
564.60 578.76 "Анатолий Кулаков" То есть, очень хотелось двигать как-нибудь всякие рюшечки вперед, больше синтаксического сахара, больше удобства, больше выразительности кода, но старый компилятор не сильно этого позволял, потому что уже назрела пора, он превращался в какой-то легоси.
578.76 591.32 "Анатолий Кулаков" И поэтому команда решила переписать все на C#, который позволил бы очень легко расширять синтаксис, очень легко внедрять новые фичи именно в сам язык, что, в принципе, в будущем и произошло.
591.32 597.28 "Анатолий Кулаков" То есть в будущем мы довольно-таки много получили сокращений кода, много выразительности, много читабельности и всего-всего-всего.
597.28 600.32 "Анатолий Кулаков" Как раз-таки основы этого были заложены в 2015.
600.32 611.92 "Игорь Лабутин" Да, и как раз-таки в сторону сокращения количества кода появились такие функции как string interpolation, теперь не нужно было писать string format, можно было написать доллар-кавычка и погнали сразу как есть.
611.92 622.56 "Игорь Лабутин" Появился оператор или функция nameof, позволяющая не писать имена аргументов в кавычках и уменьшающая риск того, что вы забудете все переименовать, когда меняете имена ваших параметров.
622.56 630.40 "Игорь Лабутин" Ну и с этого года действительно начался тренд на уменьшение, точнее на более компактный C# код.
630.40 634.16 "Игорь Лабутин" Стали появляться фичи, которые позволяют писать все более компактно и компактно.
634.16 639.72 "Игорь Лабутин" Возможно под воздействием F#, возможно под воздействием каких-то других языков и вообще общих трендов.
639.72 647.48 "Игорь Лабутин" То есть C# из довольно многословного языка, который, я помню, я начинал с C# 2.0, свою карьеру, так скажем, в дотнете.
647.48 651.72 "Игорь Лабутин" И 2.0, конечно, был очень многословен, с делегатами и всем добром.
651.72 661.16 "Игорь Лабутин" Но начиная с 6-го, все начало потихонечку сокращаться, стало все более компактно и компактно, пока мы не пришли в дотнет 5 и 9 C#, о котором мы еще поговорим.
661.16 664.76 "Анатолий Кулаков" До 9-го подожди, в 2017-м вышел еще 7.0.
664.76 669.84 "Анатолий Кулаков" Именно в 2017-м началось разделение дотнет фреймворка и дотнет кора.
669.84 675.52 "Анатолий Кулаков" Дотнет кора - это была такая open-source альтернатива, легковесная и самое главное - кроссплатформенная.
675.52 688.00 "Анатолий Кулаков" Кроме этого у нас завезли паттерн-матчинг, который в течение потом нескольких релизов допиливали, усовершенствовали, рядом с паттерн-матчингом валялись туплы, эксепшн-фильтры и прочие несущественные мелочи.
688.00 695.24 "Игорь Лабутин" А потом, опять же, на 2 года Microsoft ушла дизайнить следующую версию, но на этот раз это все было уже открыто, можно было посмотреть, куда все движется.
695.24 702.84 "Игорь Лабутин" И в 2019-м году мы получили C# 8.0, где появились несколько больших достаточно фич.
702.84 721.76 "Игорь Лабутин" Это nullable reference types, это асинхронные стримы, еще больше тренда на упрощение кода, это switch statement, using declarations и довольно-таки спорные фичи, как дефолтные методы интерфейсов, но видимо она была очень нужна для разработчиков самого framework, поэтому она появилась в
721.76 727.64 "Анатолий Кулаков" языке. И наконец 2020-й год, C# 9, .NET 5, рекорды.
727.64 731.44 "Анатолий Кулаков" Ну, об этом мы, наверное, давай поговорим немножко подробнее.
731.44 733.20 "Анатолий Кулаков" Итак, 20 лет позади.
733.20 734.20 "Анатолий Кулаков" Да фига.
734.20 741.64 "Анатолий Кулаков" Кстати, та история, которую мы сегодня с тобой рассмотрели, на многих наводит некоторое недоумение, потому что действительно неясно.
741.64 748.96 "Анатолий Кулаков" Микрософт сначала был закрытым, потом у него вышла какая-то кора, которая начала с первой версии развиваться, потом появился .NET 5.
748.96 756.80 "Анатолий Кулаков" То есть вот этот весь комок с версиями нам, в принципе, как людям из индустрии, кто сидит внутри и понимает, что к чему, нам он довольно-таки очевиден.
756.80 762.96 "Анатолий Кулаков" Вот людям, которые смотрят вокруг и на C# заглядывают из других языков, может быть не очевидно, что такое вообще творилось.
762.96 764.28 "Анатолий Кулаков" Давай я кратко резюмирую.
764.28 765.96 "Анатолий Кулаков" То есть сначала был .NET framework.
765.96 774.08 "Анатолий Кулаков" Он большой был, закрытый, его Microsoft пилила в одиночку, практически никак не взаимодействовала с комьюнити и выпускала фичи.
774.08 787.32 "Анатолий Кулаков" Дальше Microsoft взяла движение на open source, стала белая, пушистая, открытая и решила под всю эту шумиху переписать .NET Core, чтобы он теперь был не только open source, не только работал вместе с комьюнити, но еще был кроссплатформенный.
787.32 795.92 "Анатолий Кулаков" Чтобы его можно было запускать на Linux, на Mac, на BSD, естественно на винде, на всяких embedded devices, на ARM и где угодно вообще-вообще-вообще.
795.92 803.40 "Анатолий Кулаков" Может быть, своими силами она не могла это сделать и именно поэтому открыла исходники, чтобы все комьюнити ей помогало.
803.40 805.76 "Анатолий Кулаков" Может быть, она действительно просто была добрая и красивая.
805.76 807.80 "Анатолий Кулаков" Для нас в принципе это не особо существенно.
807.80 809.44 "Анатолий Кулаков" Главное, что у нас появился .NET Core.
809.44 816.12 "Анатолий Кулаков" У него сразу была цель на performance, у него сразу была цель на открытость, на легкость и на кроссплатформенность.
816.12 820.00 "Анатолий Кулаков" .NET Core просуществовал три с небольшим версией.
820.00 829.12 "Анатолий Кулаков" После этого Microsoft решила, что в принципе поддерживать Core и поддерживать большой .NET довольно труднозатратно и в принципе невыгодно ни с каких сторон.
829.12 833.60 "Анатолий Кулаков" Поэтому она всячески пыталась пересаживать людей на Core, очень сильно его рекламировала.
833.60 839.96 "Анатолий Кулаков" И последнее, чего не хватало всем людям, которые сидели на большом .NET фреймворке, это наверное все-таки UI.
839.96 849.88 "Анатолий Кулаков" То есть Windows Forms, .DF, это те большие интерпрайс-приложения, которые были написаны для десктопа много лет назад и реализации UI для которых не было в .NET Core.
849.88 854.32 "Анатолий Кулаков" .NET Core был чисто такой серверной фичей без всяких UI.
854.32 862.48 "Анатолий Кулаков" Microsoft пообещала перенести совместимость с Windows Forms и .DF на .NET Core, но при этом естественно только под Windows.
862.48 879.64 "Анатолий Кулаков" В общем, вот эту штуку она сделала и под весь этот шумок, а еще с учетом того, что она купила Xamarin, это тоже такой довольно большой игрок на мире кроссплатформенности, компания, которая долгие годы очень пилит качественные тулзы для мобильных устройств.
879.64 884.64 "Анатолий Кулаков" Она решила опять это все соединить, перебрендировать и таким образом получили .NET 5.
884.64 896.68 "Анатолий Кулаков" .NET 5 это как раз-таки продолжение линейки .NET Core, вместе с WinForms и .DF, .DF под Windows и всеми остальными фичами, в том числе Xamarin под мобилкой.
896.68 901.28 "Анатолий Кулаков" То есть .NET 5 это новый тренд на объединение всего и всех.
901.28 910.48 "Анатолий Кулаков" Этот релиз, который был, он довольно хорошо продвинулся в этом направлении, довольно много всех объединил, но все-таки не до конца.
910.48 915.48 "Анатолий Кулаков" Самое главное объединение произойдет окончательно в следующей версии большой, в .NET 6.
915.48 916.48 "Анатолий Кулаков" Но давайте по порядку.
916.48 918.92 "Анатолий Кулаков" Что же мы имеем сегодня, на сегодняшний день?
918.92 923.12 "Игорь Лабутин" Давай прежде чем мы пойдем по порядку, мы посмотрим вот на что.
923.12 927.84 "Игорь Лабутин" У меня всегда было впечатление, что .NET мир, он какой-то такой очень замкнутый.
927.84 935.88 "Игорь Лабутин" И те, кто в нем варится, все прекрасно знают, а те, кто, как ты говорил, заглядывает снаружи, особо не понимают, что тут внутри происходит.
935.88 944.36 "Игорь Лабутин" Как ты думаешь, с новым .NET 5 и будущим .NET 6, должно ли увеличиться вообще количество народу, которое будет приходить в .NET?
944.36 948.52 "Игорь Лабутин" И вообще, насколько много вот этого народа, который на .NET сейчас пишет?
948.52 958.84 "Игорь Лабутин" Потому что складывается ощущение, что его должно стать неимоверно больше, поскольку мы теперь поддерживаем и Linux, и Mac OS, и мы теперь и быстрые, и самые лучшие, и все такое прочее.
958.84 968.08 "Анатолий Кулаков" Я думаю, что больше народу привалить обязано, потому что сейчас становится довольно-таки понятен путь, которым идет .NET.
968.08 976.64 "Анатолий Кулаков" Сейчас устранились все эти неразберихи с версиями, сейчас устранились все неразберихи с open source, с открытостью, с тем, кто владеет C#.
976.64 984.88 "Анатолий Кулаков" То есть, по сути, действительно владеет только Microsoft, но все-таки это не совсем закрытая вещь, это довольно-таки прозрачный процесс.
984.88 996.64 "Анатолий Кулаков" И в принципе, все, что раньше боялись, все, что раньше люди боялись, как раньше воспринимали Microsoft как закрытую систему какую-то, как эпицентр, как империю зла.
996.64 1009.48 "Анатолий Кулаков" Мне кажется, за последние годы Microsoft исправила весь этот имидж себе, оно затюнило .NET, оно сделало C#, мне кажется, одним из самых комфортнейших и современных языков, которые существуют на данный момент.
1009.48 1012.84 "Анатолий Кулаков" У нас очень хорошо работают над перформансом.
1012.84 1021.92 "Анатолий Кулаков" То есть, созданы абсолютно все условия для того, чтобы новые разработчики появлялись, новые разработчики были, и популярность .NET только росла и росла.
1021.92 1024.48 "Игорь Лабутин" У нас будут миллионы таких девелоперов.
1024.48 1027.32 "Анатолий Кулаков" На самом деле, миллионы уже есть.
1027.32 1037.16 "Анатолий Кулаков" На данный момент у .NET где-то 5 миллионов тех, кто сидят на большом фреймворке, и 2 миллиона это активных разработчиков на .NET Core.
1037.16 1039.44 "Анатолий Кулаков" Это только по статистике Visual Studio.
1039.44 1043.72 "Анатолий Кулаков" Не забываем, что есть еще Rider и Visual Studio Code, которые сюда не входят.
1043.72 1048.20 "Анатолий Кулаков" Еще немного интересных моментов, что мы имеем сейчас.
1048.20 1049.76 "Анатолий Кулаков" Какое состояние платформы?
1049.76 1060.16 "Анатолий Кулаков" Прежде всего, по опросу Stack Overflow, ISP .NET Core занял первое место как самый любимый веб-фреймворк, а .NET Core занял первое место как самый любимый фреймворк.
1060.16 1067.56 "Анатолий Кулаков" Это тоже такая довольно показательная вещь, потому что это не какие-то статистика или собранные данные, а вот честные ответы на вопросы.
1067.56 1070.36 "Анатолий Кулаков" Что вам нравится, чего вы ждете, что вы любите.
1070.36 1072.12 "Анатолий Кулаков" Согласились довольно интересные позиции.
1072.12 1085.60 "Игорь Лабутин" Да, я бы сказал, что варясь внутри котла .NET и смотря как происходит развитие других платформ вокруг и насколько они интересуются .NET, я бы не сказал, что .NET станет таким прям номер один.
1085.60 1087.60 "Анатолий Кулаков" Дальше оба активности Microsoft.
1087.60 1092.48 "Анатолий Кулаков" .NET 5 и ISP .NET Core - это одни из самых активных проектов, которые разрабатываются на GitHub.
1092.48 1094.60 "Анатолий Кулаков" Они постоянно там держатся в каком-то топе.
1094.60 1099.76 "Анатолий Кулаков" То есть, разработка над ними кипит просто бешеными темпами.
1099.76 1104.76 "Анатолий Кулаков" C# - это язык номер 5, который используется на GitHub по популярности.
1104.76 1108.92 "Анатолий Кулаков" Еще одна интересная цифра про новых участников.
1108.92 1113.12 "Анатолий Кулаков" То есть, 45% из всех новых .NET разработчиков - это студенты.
1113.12 1123.56 "Анатолий Кулаков" Мне кажется, это очень хорошая цифра и очень важная метрика, потому что студенты - это как раз-таки та новая сила, новые идеи, новые мысли, которые очень хорошо могут продвинуть платформу.
1123.56 1126.88 "Анатолий Кулаков" Поэтому 40% студентов - это вообще отлично.
1126.88 1138.40 "Игорь Лабутин" А еще после всех тех усилий, которые команда Microsoft предприняла для оптимизации производительности, скорости и всего остального, .NET Core 3.1 занял первое место на Tech Empower Benchmark.
1138.40 1146.00 "Игорь Лабутин" И при этом в .NET 5 обещают еще больше производительности, еще лучше, еще выше, еще быстрее.
1146.00 1150.64 "Игорь Лабутин" И в общем, такое ощущение, что .NET становится самым-самым крутым фреймворком в мире.
1150.64 1161.40 "Анатолий Кулаков" То есть, я правильно понимаю, что вот эти всякие плюсовые, растовые фреймворки остались позади, и .NET - это самый быстрый и самый сейчас, наверное, мощный веб-сервер в мире?
1161.40 1163.12 "Игорь Лабутин" Ну, согласно бенчмаркам - да.
1163.12 1164.12 "Игорь Лабутин" Но не совсем.
1164.12 1165.80 "Анатолий Кулаков" Это кто к нам зашел?
1165.80 1168.44 "Анатолий Кулаков" О, это человек с уникальной профессией.
1168.44 1170.96 "Анатолий Кулаков" Его должность называется Senior Technical Architect.
1170.96 1173.88 "Анатолий Кулаков" Друзья, я хотел бы вам представить Анатолий Жмур.
1173.88 1174.88 "Анатолий Кулаков" Анатолий, привет.
1174.88 1178.24 "Анатолий Кулаков" Анатолий, а что же не так все-таки с тестом Tech Empower?
1178.24 1181.04 "Анатолий Жмур" Ну, если кратко, в них есть две проблемы.
1181.04 1183.48 "Анатолий Жмур" Первая - это то, что они используют пайплайнинг.
1183.48 1184.48 "Анатолий Жмур" То есть, вместо...
1184.48 1186.80 "Анатолий Жмур" Ну, там они используют для тестирования ВРК.
1186.80 1187.80 "Анатолий Жмур" ВРК это умеет.
1187.80 1194.40 "Анатолий Жмур" И он отправляет не один запрос, а 16 запросов за раз одним сетевым вызовом.
1194.40 1197.04 "Анатолий Жмур" Эта фича давно там есть в HTTP.
1197.04 1198.56 "Анатолий Жмур" Проблема в том, что ей никто не пользуется.
1198.56 1202.08 "Анатолий Жмур" Никто не пользуется, потому что может быть head-of-line-blocking.
1202.08 1209.08 "Анатолий Жмур" То есть, если вы набрали каких-то запросов в своем слое агрегации и отправили их вместе, то сервер их будет выполнять подряд.
1209.08 1215.00 "Анатолий Жмур" Если первый запрос у вас длинный, то все короткие запросы, состоящие за ним, будут его ждать.
1215.00 1219.60 "Анатолий Жмур" И вот это привело к тому, что пайплайнинг в реальной жизни никто особо не использует.
1219.60 1223.60 "Анатолий Жмур" Я вообще не видел и не слышал ни от кого, чтобы его не использовался.
1223.60 1226.16 "Анатолий Жмур" Но он поддержан и позволяет разгонять RPS.
1226.16 1228.88 "Анатолий Жмур" Потому что считают вот эти маленькие подзапросы.
1228.88 1233.00 "Анатолий Жмур" Вторая проблема Teach'em Power в том, что они уперлись в канал.
1233.00 1235.80 "Анатолий Жмур" То есть, у них есть сервер, на котором тестируют.
1235.80 1237.68 "Анатолий Жмур" Они на аппаратном железном сервере все это делают.
1237.68 1243.04 "Анатолий Жмур" В него воткнуто, по-моему, то ли 10, то ли 20 гигабит.
1243.04 1244.92 "Анатолий Жмур" Они меняли там в какой-то момент.
1244.92 1254.56 "Анатолий Жмур" Но все равно вот эта плотная группа лидеров от 95 до 100 процентов, которые на Plaintext бенчмарке, это все те, кто уперлись в канал.
1254.56 1256.40 "Анатолий Жмур" Они упираются немножко по-разному.
1256.40 1257.40 "Анатолий Жмур" У них нарезка пакетов разная.
1257.40 1262.76 "Анатолий Жмур" Но в целом все эти тесты имеют на самом деле разную производительность.
1262.76 1267.64 "Анатолий Жмур" Но из-за того, что они признают, что у них CPU недозагружен.
1267.64 1272.00 "Анатолий Жмур" То есть, у них CPU сервера 60 или 70 процентов на вот этих тестах.
1272.00 1274.40 "Анатолий Жмур" Потому что все уперлось в канал.
1274.40 1276.64 "Анатолий Жмур" Ну, и опять же, тут это...
1276.64 1279.64 "Анатолий Жмур" Также по пайплану можно пойти и отключить.
1279.64 1281.20 "Анатолий Жмур" Ну, и вот эту вещь, наверное, тоже можно пофиксить.
1281.20 1283.68 "Анатолий Жмур" Можно воткнуть туда 40 гигабит.
1283.68 1284.68 "Анатолий Жмур" Какой-нибудь InfiniBand.
1284.68 1285.68 "Анатолий Жмур" Еще что-нибудь.
1285.68 1288.68 "Анатолий Жмур" Но, я не знаю.
1288.68 1293.68 "Анатолий Жмур" Мне кажется, что ради сравнения с предыдущими результатами они не хотят это менять.
1293.68 1296.48 "Анатолий Жмур" Потому что, если поменять сильные условия, добавить...
1296.48 1302.12 "Анатолий Жмур" Сейчас там 17 фрейворков в верхних 5 процентах.
1302.12 1304.28 "Анатолий Жмур" И ты берешь, меняешь условия.
1304.28 1305.28 "Анатолий Жмур" Теперь от пайплайнинга...
1305.28 1308.40 "Анатолий Жмур" Как только не будет пайплайнинга, то в канал они будут упираться.
1308.40 1310.40 "Анатолий Жмур" И получаешь распределение сразу.
1310.40 1313.68 "Анатолий Жмур" Что там они на самом деле от 100 до 30 процентов.
1313.68 1316.28 "Анатолий Жмур" Ну, и сравнивать с предыдущими результатами уже нельзя.
1316.28 1317.28 "Анатолий Жмур" Непонятно, кто что улучшал.
1317.28 1320.68 "Анатолий Жмур" Кто улучшил, а кто не улучшил к этой версии.
1320.68 1323.96 "Анатолий Жмур" Отдельная категория теста они, видимо, тоже не хотят заводить.
1323.96 1329.32 "Анатолий Жмур" Ну, в общем, поэтому вот этот результат, который они получают, он не совсем представительный.
1329.32 1330.32 "Анатолий Жмур" У них есть то же самое.
1330.32 1331.32 "Анатолий Жмур" Тестируется на клауде.
1331.32 1332.32 "Анатолий Жмур" Но там очень скачут результаты.
1332.32 1339.18 "Анатолий Жмур" Видно, что клаудные машинки, они не очень надежны в плане гарантированного перформанса.
1339.18 1343.86 "Анатолий Жмур" То тебе гипервизор дает много ресурсов, то мало.
1343.86 1348.50 "Анатолий Жмур" И поэтому от теста к тесту картина совершенно меняется.
1348.50 1349.50 "Анатолий Жмур" То есть она тоже...
1349.50 1355.18 "Анатолий Жмур" Нельзя проследить эволюцию, потому что случайные флюктуации перформанса этой клаудной машины.
1355.18 1362.58 "Анатолий Жмур" Но в целом я рекомендую, конечно, если вы хотите узнать реальный перформанс, посмотреть несколько последних запусков по клауду.
1362.58 1365.06 "Анатолий Жмур" Ну, для экспонента видно, как он ходит туда-сюда.
1365.06 1368.50 "Анатолий Жмур" Но видно, что он как бы не в 100% стабильно.
1368.50 1370.26 "Анатолий Жмур" Он туда-сюда ходит.
1370.26 1371.74 "Анатолий Жмур" И остальные фреймворки тоже.
1371.74 1372.74 "Анатолий Жмур" И там видны лидеры.
1372.74 1374.94 "Анатолий Жмур" И эти лидеры, они объяснимы.
1374.94 1385.74 "Анатолий Жмур" Что все эти Rust, MT, еще кто-то, который клаудный лидер, это наверное более репрезентативно, чем их основной ранг, который первый в канал.
1385.74 1395.30 "Анатолий Кулаков" То есть, я правильно понимаю, что другого какого-то более правильного альтернативного теста, кроме клаудного варианта, его нет.
1395.30 1398.46 "Анатолий Кулаков" Все равно нам нужно смотреть на этих же людей, но только в клаудном варианте.
1398.46 1399.46 "Анатолий Жмур" Ну, наверное, да.
1399.46 1400.46 "Анатолий Жмур" Я просто не знаю.
1400.46 1402.50 "Анатолий Жмур" Это же большая работа.
1402.50 1403.82 "Анатолий Жмур" Это не то, что...
1403.82 1404.82 "Анатолий Жмур" Причем неоплачиваемая.
1404.82 1406.58 "Анатолий Жмур" Никто им не платит за это.
1406.58 1407.58 "Анатолий Жмур" Они вот просто...
1407.58 1409.50 "Анатолий Жмур" У них есть основной бизнес сайте консалтинга.
1409.50 1412.82 "Анатолий Жмур" И для своей самой рекламы они вот это делают.
1412.82 1415.74 "Анатолий Жмур" Понятно, что сейчас их контрибьюшен не очень большой.
1415.74 1418.86 "Анатолий Жмур" Еще все это сотни людей из комьюнити сделали.
1418.86 1423.14 "Анатолий Жмур" Но все равно сделать второй такой тест, это практически невозможно.
1423.14 1427.90 "Анатолий Жмур" Потому, что люди все-таки фокусируются в онлайн пространстве на небольшом количестве проектов.
1427.90 1431.10 "Анатолий Жмур" И вкладываться много своих сил в это не будет.
1431.10 1435.82 "Анатолий Жмур" Я что-то пока думал на эту тему, понял, что никто не мешает это самому запустить.
1435.82 1437.70 "Анатолий Жмур" То есть, у них же есть версия, которая...
1437.70 1448.46 "Анатолий Жмур" Можно на каком-то плохом железе, на антабуке, на десктопе, запустить, отключить пайплайнинг, просто в РК запустить это на своей машине и посмотреть, какие будут результаты.
1448.46 1452.18 "Анатолий Жмур" И после этого долго, много времени займет прогон всех тестов.
1452.18 1459.18 "Анатолий Жмур" Но теоретически на десктопе результаты будут явно более стабильны, чем на жирнокваудной машинке.
1459.18 1462.06 "Анатолий Кулаков" Ну, вот удивительно, что до сих пор этого никто не сделал.
1462.06 1463.62 "Анатолий Кулаков" Там из энтузиастов или даже из компаний.
1463.62 1467.02 "Анатолий Кулаков" Смогли бы все починить, взять их в контейнеры и перезапустить.
1467.02 1468.02 "Анатолий Жмур" Ну, да.
1468.02 1469.02 "Анатолий Жмур" Может и сделал.
1469.02 1472.30 "Анатолий Жмур" Просто попробовать на гуглете надо более внимательно.
1472.30 1474.34 "Анатолий Кулаков" Спасибо, Толя, что внес ясность.
1474.34 1477.50 "Анатолий Кулаков" Я напоминаю, что с нами был сеньор техникал-архитект.
1477.50 1487.74 "Анатолий Кулаков" Ну что, как мы видим, все не так уж и радостно, но в принципе увеличение производительности есть, над производительностью работают, над стабильностью работают, что не может не радовать.
1487.74 1493.86 "Игорь Лабутин" Помимо производительности есть и другие фичи, которые вышли в Дотнад 5, и давай по ним быстренько пробежимся.
1493.86 1507.02 "Игорь Лабутин" Мы их много раз уже рассказывали, мы, конечно, их всех подробно рассматривали, но кажется, что Дотнад Конф - это хороший повод еще раз их всех вспомнить и обозначить к релизу, что вот они наконец-таки все вышли и мы теперь все можем нормально ими пользоваться в релизной версии.
1507.02 1513.70 "Анатолий Кулаков" Прежде всего нужно уточнить, что Дотнад 5 уже давно работает на продакшене, например, Bing.com.
1513.70 1531.98 "Анатолий Кулаков" На нем крутятся с ранних релизов, и хотя в нашей стране он не так заметен, но в мире в принципе достаточно трафика обрабатывает, и команда Bingo плотно работала с командой Дотнада с рантаймом для того, чтобы выявить все узкие места по перформансу.
1531.98 1542.38 "Анатолий Кулаков" Если мы говорим уже про перформанс, то можно рассказать такие цифры, что в Дотнад 5 очень сильно продвинулись в этом направлении.
1542.38 1564.82 "Анатолий Кулаков" Где-то на 30% была улучшена работа с сокетами по производительности, на 19% сериал лазер стал лучше работать, в 3 раза выросла сериализация на больших коллекциях, в 3 раза улучшилась вся перформанс у Блейзера, и много-много таких вот улучшений, которые в общем показали платформу как довольно-таки очень быструю.
1564.82 1582.18 "Анатолий Кулаков" И те графики, которые люди выкладывают в твиттерах, когда они перешли на новый Дотнад 5, как у них уменьшились ГЦ-паузы, как у них сократилось время отклика, как у них процессор стал меньше жрать, памяти меньше использоваться, это все в принципе визуально демонстрирует о том, что мы двигаемся в правильном направлении.
1582.18 1584.82 "Анатолий Кулаков" Но не перформансом единым.
1584.82 1594.38 "Анатолий Кулаков" К Самарин Формс 5 вышли, где поддержан ход релоуд 2.0, а также сделана возможность разрабатывать iOS-приложения под Windows.
1594.38 1597.66 "Игорь Лабутин" Ну, в смысле разрабатываем на Windows, а деплоем потом
1597.66 1605.74 "Анатолий Кулаков" на iOS. Да, я здесь небольшой специалист, но насколько я помню, очень было напряжно разрабатывать iOS-овские приложения, если у тебя нет самой iOS.
1605.74 1606.74 "Игорь Лабутин" Да.
1606.74 1610.46 "Игорь Лабутин" Кроме этого, для Дотнад 5 вам конечно же нужна новая Visual Studio.
1610.46 1615.14 "Игорь Лабутин" Visual Studio 16.8, в нее включен уже Дотнад 5.
1615.14 1619.26 "Игорь Лабутин" Microsoft довольно много поработали над интеграцией с Git.
1619.26 1624.38 "Игорь Лабутин" Там появились все новые вьюшки работы с Git, мержилки, коммитов и так далее.
1624.38 1627.10 "Игорь Лабутин" И все стало довольно-таки неплохо по отзывам.
1627.10 1629.14 "Игорь Лабутин" Добавилась интеграция с GitHub.
1629.14 1639.50 "Игорь Лабутин" То есть теперь вы можете часть действий делать, не открывая даже браузер и не заходя на GitHub, прямо из Visual Studio, создавать pull-requests, насколько я понимаю, ревьюить их, комплитить.
1639.50 1648.78 "Игорь Лабутин" Кроме того, конечно же, поскольку Microsoft очень сильно ориентируется на кроссплатформенную разработку, добавились фичи и в этом направлении тоже.
1648.78 1651.86 "Игорь Лабутин" Появилась возможность сделать отладку на Linux.
1651.86 1658.50 "Игорь Лабутин" И можно запускать теперь юнит-тесты в том контейнере, в котором они должны идти.
1658.50 1660.42 "Игорь Лабутин" Например, прямо в линуксовом контейнере.
1660.42 1664.98 "Игорь Лабутин" То есть вам не нужно теперь это дело гонять где-то там, не знаю, в специальной линукс-машинке.
1664.98 1669.06 "Анатолий Кулаков" Да, мне очень понравилась эта фишка на демке, когда у тебя просто обычный тест-раннер.
1669.06 1673.42 "Анатолий Кулаков" И в этом тест-раннере ты можешь выбрать, а в каком контейнере запустить твои тесты.
1673.42 1679.10 "Анатолий Кулаков" И тест-раннер сам скачивает контейнер указанный, сам деплоит туда тесты и сам их там запускает.
1679.10 1684.58 "Анатолий Кулаков" То есть вы можете прямо на нескольких контейнерах прогнать ваши юнит-тесты или даже интеграционные тесты.
1684.58 1686.34 "Анатолий Кулаков" Довольно интересная, интересная штука.
1686.34 1688.98 "Анатолий Кулаков" Дальше большие импровизации есть у Blazor, конечно же.
1688.98 1694.14 "Анатолий Кулаков" В принципе, все это полугодие на Blazor все кипело и взрывалось.
1694.14 1696.78 "Анатолий Кулаков" И много фич, много перформанса.
1696.78 1698.70 "Анатолий Кулаков" Что же у нас все-таки есть?
1698.70 1701.94 "Анатолий Кулаков" На данный момент у нас есть Blazor Server и Blazor WebAssembly.
1701.94 1704.18 "Анатолий Кулаков" Напомню, что WebAssembly вышла как раз-таки в этом году.
1704.18 1714.14 "Анатолий Кулаков" И WebAssembly позволяет вам разрабатывать ваше приложение полностью, полностью весь front-end без какого-то взаимодействия, например, с сервером.
1714.14 1719.62 "Анатолий Кулаков" То есть вы можете делать статические сайты полностью на .NET с полной логикой, с полной функциональностью.
1719.62 1725.82 "Анатолий Кулаков" Blazor Server все-таки позволяет вам оставить сервер и делать часть логики на сервере и часть логики на клиенте.
1725.82 1729.86 "Анатолий Кулаков" Мы уже подробнее останавливались и рассматривали разницу между ними и когда что нужно применять.
1729.86 1732.78 "Анатолий Кулаков" У Blazor также появился сервер-сайт pre-rendering.
1732.78 1750.54 "Анатолий Кулаков" Это когда у вас пользователь не ждет выполнения WebAssembly кода после его долгой загрузки с сервера, а напрямую сначала сервер рендерит начальную страничку, отдает пользователю и в это время уже пользователь что-то видит и в это время в игре уже начинает подгружаться остальная часть и выполняться.
1750.54 1752.18 "Анатолий Кулаков" Появились компоненты виртуализации.
1752.18 1756.98 "Анатолий Кулаков" Теперь довольно-таки очень легко и сделать виртуализированный грид.
1756.98 1761.42 "Анатолий Кулаков" Это, наверное, одна из самых запрашиваемых фич, потому что виртуализация наша все.
1761.42 1767.70 "Анатолий Кулаков" Чтобы отобразить в браузере 100 тысяч миллионов записей в гриде невозможно сделать практически без виртуализации.
1767.70 1771.38 "Анатолий Кулаков" Теперь мы это можем делать обычным компонентиком всего с одной строчечкой кода.
1771.38 1774.98 "Анатолий Кулаков" Появилась CSS и JS изоляция для компонентов.
1774.98 1783.70 "Анатолий Кулаков" То есть теперь все JavaScript и все CSS стили, которые вы напишите для вашего определенного компонента, никак не будут влиять на другие компоненты.
1783.70 1788.58 "Анатолий Кулаков" Что в принципе для нормального Desktop разработчика очевидно, но для Web абсолютно работает не так.
1788.58 1795.66 "Анатолий Кулаков" Для Web любое CSS правило, любой JavaScript полностью аффектит все деревья, все правила, все что видит только в браузере.
1795.66 1802.70 "Анатолий Кулаков" Вот, теперь это более-менее похоже на изолированную среду компонентов для нормальной Desktop разработки, что очень удобно.
1802.70 1810.22 "Анатолий Кулаков" Также растет количество контролов нативных, которые поставляет Blazor, и количество контролов, которые поставляют за отдельные деньги партнеры.
1810.22 1813.46 "Анатолий Кулаков" Качество контролов довольно-таки хорошее.
1813.46 1815.82 "Анатолий Кулаков" Я несколько из них уже потестировал, попробовал.
1815.82 1816.82 "Анатолий Кулаков" Мне очень понравилось.
1816.82 1818.50 "Анатолий Кулаков" Просто экспириенс отличный.
1818.50 1837.30 "Игорь Лабутин" А если мы говорим про Blazor, Web и прочие интернет-ориентированные штуки, то, конечно же, Microsoft не мог не обойти вниманием начинание про Cloud Native и не сделать шаги в сторону более правильной поддержки облаков и всего, что связано с выкладкой API и прочего в облака.
1837.30 1843.94 "Игорь Лабутин" Поэтому при генерации Web API проектов у вас теперь автоматически появляется Open API спецификация на основе Swagger.
1843.94 1851.70 "Игорь Лабутин" Появился Global Tool от Microsoft, который позволяет вам поэксплорить API в виде такого дерева каталогов, по сути.
1851.70 1859.22 "Игорь Лабутин" Вы можете с помощью команды ls посмотреть, какие действия возможны с каждым из файлов, которыми являются ваши контроллеры.
1859.22 1860.22 "Игорь Лабутин" В общем, забавная штука.
1860.22 1861.22 "Игорь Лабутин" Я чуть-чуть поигрался, выглядит прикольно.
1861.22 1866.22 "Анатолий Кулаков" Да, типа пост сделать команда и сформировать ответ, сформировать реквест.
1866.22 1868.74 "Анатолий Кулаков" Ну, то есть, выглядит довольно интересно.
1868.74 1873.46 "Игорь Лабутин" Вот часть формирования и как ее использовать на практике я пока не очень понял.
1873.46 1880.82 "Игорь Лабутин" У нас довольно многословные бывают ответы и на сложные реквесты в консольке немножко трудновато парсить результаты.
1880.82 1885.62 "Игорь Лабутин" Но вот идея походить по API как по каталогу, это прям прикольно.
1885.62 1890.98 "Игорь Лабутин" Дальше, естественно, можно погенерить клиентов из этой Open API спецификации.
1890.98 1895.74 "Игорь Лабутин" В GRPC тоже улучшили генерацию клиента и сервера из Proto файлов.
1895.74 1898.46 "Игорь Лабутин" Конечно, не обошли вниманием Docker контейнеры.
1898.46 1899.94 "Игорь Лабутин" Они теперь меньшего размера.
1899.94 1904.54 "Игорь Лабутин" В Linux, в принципе, и так было все неплохо по определению Linux поменьше, чем Windows.
1904.54 1906.78 "Игорь Лабутин" Но и Windows контейнеры стали поменьше.
1906.78 1915.90 "Игорь Лабутин" Microsoft активно пытается уменьшить размер, чтобы не тащить за собой пол винды и тащить только нужные кусочки фреймворка, которые вам реально нужны для исполнения.
1915.90 1922.74 "Игорь Лабутин" Для неконтейнерной разработки и для диплоймента, например, в виде тулов, будет очень полезна опция Single File Apps.
1922.74 1927.14 "Игорь Лабутин" А также есть два относительно экспериментальных проекта.
1927.14 1936.06 "Игорь Лабутин" Это Project TIE для сборки и отладки локального диплоя запуска вашего набора микросервисов, а также диплоя всего этого в Kubernetes, если вам очень это интересно.
1936.06 1945.50 "Игорь Лабутин" Диплоить вы, в принципе, можете и без Project TIE, но с ним это сделается в одну строчку, в одну команду с более простой конфигурацией, нежели чем полноценно настраивать полный Kubernetes.
1945.50 1948.98 "Игорь Лабутин" И есть еще тулса под названием YARP и это Another Reverse Proxy.
1948.98 1955.78 "Игорь Лабутин" Это в каком-то смысле некий аналог Nginx, который написан на .NET и пытается стать его заменителем.
1955.78 1963.94 "Игорь Лабутин" Оба проекта сейчас, насколько я понимаю, в такой экспериментальной фазе развития и их можно использовать в своих целях.
1963.94 1968.70 "Игорь Лабутин" Не сказать в продакшене, но для своих работ и экспериментов.
1968.70 1981.94 "Игорь Лабутин" Но судьба их пока непонятна, в том плане, что Microsoft следит за развитием, следит за комментариями от пользователей очень активно, выясняет, что хочет комьюнити и именно комьюнити, видимо, будет влиять на то, куда эти проекты будут развиваться.
1981.94 1983.30 "Анатолий Кулаков" Итак, а что же дальше?
1983.30 1985.38 "Анатолий Кулаков" А дальше мы ждем .NET 6.
1985.38 2006.74 "Анатолий Кулаков" В нем планируют все-таки закончить то объединение, о котором я упоминал в начале, то есть делать один-единственный SDK, один-единственный BCL и сделать один-единственный Toolchain, чтобы все фреймворки, независимо от того, под какую платформу, под какой язык, под какой рантайм, чтобы все они имели одну инфраструктуру.
2006.74 2015.98 "Анатолий Кулаков" Дальше будет работа над кросс-платформенным нативным UI, то есть Microsoft уже подписался, что будет кросс-платформенный нативный UI для .NET.
2015.98 2017.98 "Анатолий Кулаков" Посмотрим, как это у него получится.
2017.98 2023.50 "Анатолий Кулаков" Также параллельно с кросс-платформенным нативным UI будет разрабатываться кросс-платформный WebUI.
2023.50 2030.14 "Анатолий Кулаков" Не знаю, на моей практике это, наверное, первый такой случай, когда Microsoft начинает в открытую параллельно конкурировать сам с собой.
2030.14 2032.54 "Анатолий Кулаков" Очевидно же, что кто-то из них должен будет умереть.
2032.54 2034.74 "Анатолий Кулаков" Не знаю, посмотрим.
2034.74 2038.26 "Анатолий Кулаков" Вот WebUI, если вдруг непонятно, имеется в виду Blazor.
2038.26 2042.26 "Анатолий Кулаков" Blazor сейчас себя очень нативно чувствует, естественно, в веб-среде.
2042.26 2047.58 "Анатолий Кулаков" Также он умеет запускаться в режиме Progressive Web Application.
2047.58 2059.42 "Анатолий Кулаков" Когда вы ставите одну веб-страничку на свой рабочий стол, и она получается у вас такое приложение, которое имеет свое отдельное окно, но по сути работает, естественно, внутри браузера и показывает вам только какой-то один адрес.
2059.42 2064.54 "Анатолий Кулаков" Есть уже экспериментальные наработки для мобильных систем.
2064.54 2068.06 "Анатолий Кулаков" То есть Blazor стремится к тому, чтобы на нем можно было бы писать под мобилки.
2068.06 2070.78 "Анатолий Кулаков" Уже есть баннинги, их уже можно пощупать, попробовать.
2070.78 2074.86 "Анатолий Кулаков" И, соответственно, дальше он будет стремиться к тому, чтобы стать десктоп-системой.
2074.86 2078.06 "Анатолий Кулаков" Тоже, скорее всего, после того, как реализуют мобильные баннинги.
2078.06 2079.26 "Анатолий Кулаков" Посмотрим, что из этого получится.
2079.26 2081.78 "Анатолий Кулаков" Довольно-таки интересная битва получается у нас.
2081.78 2086.14 "Анатолий Кулаков" В DotNet 6 продолжат работать над Cloud Native, что бы это ни значило.
2086.14 2092.86 "Анатолий Кулаков" И продолжат уменьшать размер, увеличивать скорость, добавлять больше диагностик и все-все-все, что мы любим.
2092.86 2096.46 "Анатолий Кулаков" Напомним, что планы у DotNet выпускаются каждый год.
2096.46 2099.94 "Анатолий Кулаков" Каждый год будет выпускаться в ноябре мажорный релиз.
2099.94 2103.30 "Анатолий Кулаков" DotNet 5 - это не LTS, это проходной релиз.
2103.30 2108.30 "Анатолий Кулаков" LTS нас ждет в следующем году, в 2021-м, и это будет DotNet 6.
2108.30 2117.02 "Анатолий Кулаков" Так что, в принципе, пока вы ожидаете DotNet 6 LTS, вы можете переводить свои проекты на DotNet 5 и смотреть, как он впишется в ваш будущий LTS.
2117.02 2119.74 "Анатолий Кулаков" Хотя зачем переводить на 5, если он не LTS?
2119.74 2121.10 "Игорь Лабутин" Действительно хороший вопрос.
2121.10 2130.34 "Игорь Лабутин" И я, когда над ним думал, для себя решал, что с одной стороны все очень вкусно и побежали на 5, конечно, там новый C# 9, там всякие оптимизации и все такое.
2130.34 2132.38 "Игорь Лабутин" А с другой стороны он действительно не LTS.
2132.38 2135.82 "Игорь Лабутин" На этот счет есть, на самом деле, официальная рекомендация Microsoft.
2135.82 2152.22 "Игорь Лабутин" Если у вас живой проект, который планируется к активной разработке дальше, то вы смело можете идти в DotNet 5, потому что, скорее всего, апгрейд на DotNet 6 не потребует сильно больших затрат, и вы его сделаете быстро, просто и легко, когда он выйдет.
2152.22 2158.18 "Игорь Лабутин" У вас там будет некоторое количество времени, потому что DotNet 5 будет поддерживать еще несколько месяцев после выхода DotNet 6.
2158.18 2175.82 "Игорь Лабутин" Если же у вас проект больше к нам мейнтонит, и вы его поддерживаете не очень активно, и на нем, например, нет постоянной команды, то такой проект смысл апгрейдить на DotNet 5 и нет, потому что у вас может не быть шанса уложиться в тот короткий промежуток, пока DotNet 5 еще поддержан, а DotNet 6 уже вышел.
2175.82 2183.22 "Игорь Лабутин" И для таких проектов Microsoft рекомендует оставаться на DotNet Core 3.1, если вы уже на DotNet Core, и ждать, когда появится DotNet 6.
2183.22 2185.22 "Анатолий Кулаков" Ну, действительно, хорошая рекомендация.
2185.22 2193.50 "Анатолий Кулаков" Как минимум, если вам вдруг все равно, то учтите, что вы получите бешеный буст в производительности, тупо просто портируйтесь, и все.
2193.50 2199.82 "Анатолий Кулаков" Так что, может быть, это тоже для вас будет такой хорошей причиной такой халявной производительности.
2199.82 2205.70 "Игорь Лабутин" Ну и мы уже перечислили основные фичи, такие high-level фичи DotNet 5.
2205.70 2214.94 "Игорь Лабутин" На самом деле, мы много раз говорили о каких-то более местечковых и маленьких фичах, которые относятся непосредственно к DotNet Runtime, либо еще к чему-то рядышком с ним.
2214.94 2221.90 "Игорь Лабутин" И давайте еще раз быстро пробежимся по ним, чтобы точно в одном выпуске был полный обзор всего того, что вышло в DotNet 5.
2221.90 2225.78 "Анатолий Кулаков" Я думаю, точно полного обзора не будет, потому что слишком там много всего.
2225.78 2228.30 "Анатолий Кулаков" Но, наверное, по самым главным фичам и пройдемся.
2228.30 2229.30 "Игорь Лабутин" Да.
2229.30 2235.22 "Игорь Лабутин" Во-первых, как мы уже говорили, DotNet 5 - это unified platform, то что называется у Microsoft.
2235.22 2241.90 "Игорь Лабутин" Это действительно общая, единая платформа везде, где был поддержан DotNet Core 3.1, теперь поддержан DotNet 5.
2241.90 2246.62 "Игорь Лабутин" Причем в DotNet 5 добавился еще Windows ARM 64, потому что это нужно Microsoft для своих ноутбуков.
2246.62 2248.62 "Игорь Лабутин" Ждем, когда они добавят Apple M1.
2248.62 2250.62 "Анатолий Кулаков" Не, не, добавят, обязательно добавят.
2250.62 2256.42 "Анатолий Кулаков" Потому что процесс обновления довольно производительный, очень популярный, сейчас будет хайп опять маководов, обязательно добавят.
2256.42 2259.78 "Игорь Лабутин" Ну да, иначе не быть нам кроссплатформенным.
2259.78 2269.06 "Игорь Лабутин" Большое изменение в DotNet 5 и вообще вокруг DotNet, оно начиналось еще в третьем версии DotNet Core - это глобальное стремление к унификации репозиториев на GitHub.
2269.06 2292.86 "Игорь Лабутин" То есть раньше, когда начинался DotNet Core, Microsoft решила, что у нас будет огромная куча маленьких репозиториев под каждую из компонентов, но поняла, что все очень сложно, сложно отлижать зависимости, сложно собирать, и в итоге сейчас это все потихонечку мигрирует в огромные и большие репозитории, там, репозитории рантайма, репозитории основной библиотеки, и несмотря на то, что были опасения, как вообще с этим всем жить, ну, более-менее живут нормально.
2292.86 2304.26 "Игорь Лабутин" Языки, конечно же, C# 9 и F# 5 - два основных языка платформы, которые вышли в DotNet 5, включены в DotNet 5 SDK, вам нужна Visual Studio 16.8, чтобы с ними работать.
2304.26 2309.30 "Игорь Лабутин" И одной из больших фич C# 9, о которой мы еще не упоминали сегодня, это Source генераторы.
2309.30 2331.38 "Игорь Лабутин" Очень важная фича, которую, возможно, в перспективе заменят T4, но пока не очень понятны планы, насколько далеко мы пойдем в их использовании, но Microsoft уже имеет какое-то количество планов по разработке своих собственных Source генераторов и, возможно, переводу каких-то частей своих внутренних шаблонов, темплейтов, продуктов, которые будут нам тоже доступны на использование этих самых Source генераторов.
2331.38 2338.58 "Анатолий Кулаков" Да, это еще одна интересная сфера, за которой нам теперь придется следить, будем держать вас в курсе, какие генераторы появляются, что интересного можно сделать.
2338.58 2344.62 "Анатолий Кулаков" Мне кажется, да, это отдельное такое крыло, теперь отдельные направления будут в DotNet разработке.
2344.62 2359.94 "Игорь Лабутин" Да, C# стремится быть скриптовым языком, как бы это странно ни звучало, у нас появились top-level programs, можно не писать program main, у нас появились те самые single file applications, которые позволяют все это запаковать в единый файл.
2359.94 2382.94 "Игорь Лабутин" К сожалению, обошлось не без проблем, не получается у Microsoft сделать абсолютно self-contained приложение, и если в определенных случаях есть специальные зависимости, то все равно приходится эти специальные зависимости класть пока рядышком в файлик, и в этом смысле очень забавно получилось, что на Linux и на MacOS как раз таки получилось сделать полностью self-contained приложение, а на Windows пока не получается из-за особенностей операционной системы.
2382.94 2388.10 "Игорь Лабутин" И даже в DotNet 6 Microsoft не обещает, что идеально получится, потому что не факт, что Windows позволит.
2388.10 2389.50 "Игорь Лабутин" Надеюсь, они договорятся.
2389.50 2395.18 "Игорь Лабутин" Да, хочется верить, что нам выкатят какой-нибудь легкий апгрейд Windows, который все пофиксит.
2395.18 2407.26 "Игорь Лабутин" Паттерн-матчинг мы уже обсудили, появилось огромное количество новых ключевых слов, теперь можно писать, не знаю, мне это очень напомнило Pascal с and, or и прочими такими штуками.
2407.26 2412.30 "Игорь Лабутин" Вспоминаем про то, что C# немножко родился из Delphi когда-то давно.
2412.30 2418.26 "Игорь Лабутин" Что неудивительно, Андерс Хейлсберг вряд ли бы придумал что-то существенно отличное от Delphi.
2418.26 2420.10 "Игорь Лабутин" Ну подожди, TypeScript же он придумал.
2420.10 2421.10 "Игорь Лабутин" Согласен, придумал.
2421.10 2428.74 "Игорь Лабутин" Но все-таки TypeScript, он немножко другой по парадигме, мне кажется, а C# как-то довольно близок к Delphi, та же объектная ориентированность.
2428.74 2434.74 "Игорь Лабутин" Ну по крайней мере, наверное, было логично придумать что-то похожее, а дальше уже модернизировать под нужды сообщества.
2434.74 2438.62 "Анатолий Кулаков" Мне кажется, эти новые ключевые слова дадут нам более лучшую читабельность.
2438.62 2439.62 "Игорь Лабутин" Да, хочется верить.
2439.62 2440.98 "Игорь Лабутин" Пока не пробовал, буду смотреть.
2440.98 2447.46 "Игорь Лабутин" Рекорды мы подробно рассматривали в одном из предыдущих выпусков и сильно на них останавливаться, наверное, не будем.
2447.46 2450.70 "Игорь Лабутин" Ну, лабилити все лучше и лучше, все больше кода
2450.70 2455.94 "Анатолий Кулаков" аннотируется. Поскольку я понимаю, что они проаннотировали сейчас весь фреймворк, в этом и заключается оно.
2455.94 2470.14 "Игорь Лабутин" Они проаннотировали все паблик API, внутри фреймворка проаннотировано не совсем все, то есть там есть еще места, где не получается нормально проаннотировать, они либо просто не успели, либо по объективным причинам не захотели этого делать.
2470.14 2483.06 "Игорь Лабутин" Но все, что касается вас, паблик API, то, чего будете касаться вы как разработчики, оно точно все проаннотировано и на выходе вам будет все правильно и корректно размечено, это null, это не null и где что ожидается и принимается будет понятно.
2483.06 2484.06 "Игорь Лабутин" Так, тулинг.
2484.06 2499.54 "Игорь Лабутин" Тулинг, как я сказал, Visual Studio сама по себе улучшилась, похорошела и умеет теперь больше, но раз мы в DotNet 5 завезли обратно и WPF и WinForms, то нужно все соответствующие дизайнеры завозить.
2499.54 2516.02 "Игорь Лабутин" И если с WPF дизайнером особых проблем не было, то с Windows Forms какое-то время было, он долгое время был в превью с непонятным статусом, но наконец-таки он полноценно зарелизился и теперь вы можете использовать WinForms дизайнер, как вы это умели делать под обычным DotNet фреймворком, но только теперь это будет компилироваться в DotNet 5.
2516.02 2531.74 "Игорь Лабутин" И если говорить про компиляцию куда-нибудь, то естественно с выходом DotNet 5 появился новый Target Framework, теперь можно указать в вашем CS Profile нет 5.0 и использовать его в качестве нового Target Framework.
2531.74 2563.78 "Игорь Лабутин" И начиная с DotNet 5 появляется новая система обозначения Target Framework, так называемый Target Framework Monitors, которые позволяют указать версию DotNet, это DotNet 5.0 или Net 6.0, опционально указать операционную систему, под которой это должно быть Net 5.0, Defice Windows или Defice Mac OS и даже указать специфическую версию операционной системы, например, конкретную версию Windows 10, если фича, например, зависит или ваше приложение зависит от конкретной версии операционной системы.
2563.78 2585.22 "Игорь Лабутин" Так что теперь станет гораздо более просто таргетировать ваше приложение или ваше библиотеки на конкретные операционные системы, что становится критически важным, потому что мы стали кроссплатформенными и нужно поддерживать все варианты и аккуратно все это упаковать в соответствующие приложения, либо пакеты, либо как это правильно пакуется для той платформы, на которую вы таргетите.
2585.22 2603.10 "Игорь Лабутин" Есть много изменений вокруг интеропа с Windows Runtime, WinRT, мы не будем подробно на этом останавливаться сейчас, но просто знайте, что есть breaking changes в этой области, в том числе из-за того, что были изменения со стороны WinRT и нужно их правильно совместить, чтобы все это работало правильно.
2603.10 2604.58 "Анатолий Кулаков" К нам завезли Event Pipes.
2604.58 2613.86 "Анатолий Кулаков" Event Pipes - это новая система по типу ETV, которая позволяет вам уже кроссплатформенно описать диагностики, потреблять диагностики для ваших приложений.
2613.86 2630.10 "Игорь Лабутин" Ну, справедливости ради, завезли их еще в .NET Core 2.2, но в .NET 5 они существенно улучшились и расширились, теперь в них пишется гораздо больше диагностик, туда можно писать самим и, в общем, они все ближе и ближе к тому, что умело делать ETV, только это делало действительно кроссплатформенно.
2630.10 2634.74 "Игорь Лабутин" Если говорить про диагностику, то нельзя не упомянуть, конечно, логирование.
2634.74 2647.62 "Игорь Лабутин" И в Microsoft Extensions Logging, стандартной нашей лог-библиотеке, особо больших изменений нет, но есть приятные изменения в виде нового консоль-форматора, который позволяет теперь, наконец-таки, задать как же на самом деле писать
2647.62 2651.02 "Игорь Лабутин" ваши логи в консоль, не в виде двух строчек, а, например, в виде одной строчки.
2651.02 2665.74 "Игорь Лабутин" И есть также JSON-вариант, то есть писать в консоль структурированные JSON-логи, которые можно потом скормить какого-нибудь тулзу, который их заберет из консольки, например, от вашего Docker-контейнера и отдаст в какую-то централизованную систему хранения логов.
2665.74 2675.26 "Игорь Лабутин" В принципе, это можно было делать и раньше, SeriLog это, например, поддерживал довольно давно, но если вы не хотите тащить к себе стороннюю зависимость чисто ради этого, то теперь можно пользоваться стандартными средствами.
2675.26 2681.34 "Игорь Лабутин" Также про диагностику можно сказать, что у нас есть теперь чуть более правильный и хороший dump-дебаггинг.
2681.34 2686.86 "Игорь Лабутин" Можно сдампить процесс на Linux и поанализировать его в вин.дбг на вин.де.
2686.86 2694.86 "Игорь Лабутин" И теперь, поскольку .NET стал кроссплатформенным, то стало жизненно важным выводить информацию о том, вообще где мы запускались.
2694.86 2700.78 "Игорь Лабутин" То есть, когда мы, например, собираем информацию о том, что что-то где-то не работает, было бы полезно узнать, а вообще на чем оно не работает.
2700.78 2712.34 "Игорь Лабутин" Если раньше было достаточно версий Windows, потому что было понятно, что это точно Windows, то сейчас становится очень много систем, на которых мы можем работать, а в Linux-мире зоопарк вообще огромный, со всеми возможными вариациями.
2712.34 2724.22 "Игорь Лабутин" И поэтому теперь есть Global Tool, который называется .NET Runtime Info, который выведет полную информацию про то, что за фреймворк, какая версия, какая операционка, какая версия архитектуры, количество процессоров и так далее.
2724.22 2735.26 "Анатолий Кулаков" И он умеет также показывать настройки cgroups, то есть если вы запускаетесь под докером, то этот тулс подскажет, какой у вас лимит, где вы ограничены, куда вы могли упереться, что тоже очень полезно для плотки.
2735.26 2736.26 "Игорь Лабутин" Да.
2736.26 2738.74 "Игорь Лабутин" Несомненно, в рантайме, конечно же, тоже куча улучшений.
2738.74 2739.74 "Игорь Лабутин" Улучшился JIT.
2739.74 2751.62 "Игорь Лабутин" Мы про него практически не говорили, но там вокруг JIT тоже идет большая работа по улучшению, ускорению, введению Tile в JIT и вообще минимизации накладных расходов на JIT во время исполнения.
2751.62 2769.50 "Игорь Лабутин" Нельзя, конечно же, обойти вниманием Garbage Collector, который с одной стороны уже дотюнин до нельзи, а с другой стороны запуск в докерах и других окружениях, где очень сильно могут быть ограничены ресурсы по сравнению с тем, что в среднем сейчас на обычном компьютере есть, налагает некоторые новые челленджи на разработку Garbage Collector.
2769.50 2780.42 "Игорь Лабутин" Или если Garbage Collector долгое время развивался в сторону мы запускаемся на сервера, где у нас гигабайты памяти, то сейчас наоборот мы можем запускаться в докере, которому выделен 1 гигабайт, а из того меньше.
2780.42 2783.18 "Игорь Лабутин" И как-то в нем все равно надо уживаться Garbage Collector.
2783.18 2785.74 "Игорь Лабутин" Вокруг этого довольно много улучшений и изменений.
2785.74 2792.14 "Игорь Лабутин" Ну, в целом, вот это примерный такой обзор того, что мы получили в DotNet 5.
2792.14 2795.66 "Игорь Лабутин" Конечно же, есть куча других улучшений, о которых мы уже упоминали.
2795.66 2805.50 "Игорь Лабутин" JSON сериалайзеры, новые HTTP Client методы, которые полезны и скорее всего не являются какой-то очень крупной фичей, но это то, что вы, скорее всего, будете использовать довольно часто в каждодневной работе.
2805.50 2809.70 "Игорь Лабутин" И последнее, про что я хотел сказать, это опции диплоймента.
2809.70 2823.42 "Игорь Лабутин" Как я уже говорил, есть вариант паковать ваше приложение в один файл, в self-contained приложение, либо же, как раньше, поставлять его вместе с фреймворком рядышком или в framework-dependent.
2823.42 2829.86 "Игорь Лабутин" Но в версии DotNet 5 Microsoft возродила такую технологию, как ClickOnce.
2829.86 2838.14 "Игорь Лабутин" Теперь вы можете опять доставлять ваше приложение на компьютеры конечных клиентов через интернет путем просто скачивания их со специального урла.
2838.14 2842.78 "Игорь Лабутин" И эта штука была бэкпортирована на DotNet Core 3.1 тоже, поэтому там это тоже работает.
2842.78 2850.78 "Игорь Лабутин" Вот примерно то, что произошло в DotNet 5, если подвести итог всем последним нашим, я не знаю, 10, наверное, выпускам подкаста.
2850.78 2852.46 "Игорь Лабутин" Сколько мы уже обозреваем DotNet 5?
2852.46 2854.62 "Анатолий Кулаков" Наверное, да, больше полугода.
2854.62 2855.62 "Анатолий Кулаков" Вот.
2855.62 2857.86 "Анатолий Кулаков" За статью большое спасибо Ричарду Лендеру.
2857.86 2860.62 "Анатолий Кулаков" Если вы хотите каких-то подробностей, переходите по ссылочкам.
2860.62 2861.62 "Анатолий Кулаков" Все ссылочки в бутшоу-нотах.
2861.62 2868.66 "Анатолий Кулаков" И, как всегда, рядом с языком, рядом с DotNet, с C# у нас идет релиз ASP.NET Core.
2868.66 2870.02 "Анатолий Кулаков" Что же там интересного?
2870.02 2873.10 "Игорь Лабутин" Про ASP.NET Core я ничего подробно рассказывать не буду.
2873.10 2877.82 "Игорь Лабутин" Про него мы уже много раз либо упоминали вскользь сегодня, либо очень подробно рассматривали ранее.
2877.82 2883.94 "Игорь Лабутин" Единственная фича, которой достойны упоминания, она связана не непосредственно с ASP.NET Core, а с Azure.
2883.94 2890.38 "Игорь Лабутин" Если вы хоститесь в Azure, то вы могли заметить, что последние версии фреймворков далеко не всегда появляются там быстро.
2890.38 2900.38 "Игорь Лабутин" Например, DotNet Framework 4.8 в Azure появился только недавно, если я не ошибаюсь, буквально несколько месяцев назад, хотя релизнут он был несколько лет назад, получается.
2900.38 2912.82 "Игорь Лабутин" И было немножко странно видеть от Microsoft такое, скажем так, ленивое обновление этих фреймворков у себя же в своем же облаке, но теперь этого можно будет избежать, теперь появилась такая штука, называется Early Access Runtime.
2912.82 2924.70 "Игорь Лабутин" То есть буквально в течение недели-двух после релиза какого-либо рантайма он будет появляться в Azure, его можно будет выбрать, для этого нужно будет выбрать его в специальном дропдауне.
2924.70 2939.90 "Игорь Лабутин" Единственное дно в таком Early Access Runtime он не настолько оптимизирован под Azure и видимо на него выделяются какие-то отдельные виртуалки, потому что у него есть ограничения в виде более низких показателей с точки зрения cold start.
2939.90 2958.98 "Игорь Лабутин" То есть Microsoft говорит, что cold start performance impact, то есть то, насколько у вас может задержаться исполнение ваших запросов, потому что ваше приложение было не запущено, может доходить до 30 секунд 95% а среднее будет при этом чуть меньше 10 секунд.
2958.98 2969.54 "Игорь Лабутин" То есть это довольно существенная задержка, чтобы использовать это в продакшене, но если вам нужно поэкспериментировать, если ваше приложение на .NET 5 например будет жить в Azure, то эту штуку можно уже использовать.
2969.54 2977.06 "Игорь Лабутин" Либо используются всяческие ухищрения, чтобы держать ваши инстансы прогретыми и тогда скорее всего там проблем особых не будет.
2977.06 2980.14 "Игорь Лабутин" С точки зрения работоспособности оно все support и работает.
2980.14 2991.10 "Игорь Лабутин" Вопрос только в том, что видимо виртуалки не настолько их много, либо не настолько они выделены и правильно заведены в нужные места, чтобы были хорошие cold старты.
2991.10 2993.22 "Игорь Лабутин" Так что это все, что можно сказать сейчас про SPNet Core.
2993.22 2997.18 "Анатолий Кулаков" Отлично, а про Entity Framework есть что добавить?
2997.18 3005.82 "Игорь Лабутин" Про Entity Framework в принципе фич много, их действительно добавляли достаточно равномерно за этот год.
3005.82 3021.46 "Игорь Лабутин" И когда писали статью про то, а что ж нового появилось в Entity Framework Core 5.0 в официальном релизе, было непонятно вообще что включать, потому что таких только больших мажорных фич, их около 20 штук, которые важные, интересные и про них про всех писать так это будет чтиво там на час не меньше.
3021.46 3027.90 "Игорь Лабутин" Поэтому сделали следующее, спросили у комьюнити, а что вы считаете самой важной фичей в Entity Framework 5.0.
3027.90 3034.30 "Игорь Лабутин" И получилось в ответ топ 4 фич, которые они и включили в статью про обозрение Entity Framework.
3034.30 3038.38 "Игорь Лабутин" И что мне больше всего нравится, что первой фичей это стало логирование.
3038.38 3049.06 "Игорь Лабутин" То есть в Entity Framework всегда можно было его заставить залогировать то, что там происходит внутри, но это не всегда было тривиально, получались логи довольно таки иногда замусоренные.
3049.06 3053.50 "Игорь Лабутин" И сконфигурировать это абсолютно правильно было не очень-то тривиально.
3053.50 3064.58 "Игорь Лабутин" Сейчас появилась простая опция, теперь вы когда конфигурите либо DB-контекст, либо что-то рядом с ним, вы просто говорите .log2 и передаете туда, куда логировать.
3064.58 3073.14 "Игорь Лабутин" И все что нужно, все что вы хотите логироваться, будет логироваться теперь вот прямо в это конкретное одно место, куда вы указали.
3073.14 3090.02 "Игорь Лабутин" Дальше это конечно можно настраивать, есть документация про то, как настраивать логфильтеринг, как менять формат, как-то может быть адаптировать контент-месседжи, допустим удалять какие-то важные данные из них, пароли там, если вы храните их в базе, не надо так делать и так далее.
3090.02 3092.70 "Игорь Лабутин" Вторая важная фича это many-to-many relationships.
3092.70 3097.90 "Игорь Лабутин" Раньше для того, чтобы это поддержать, нужно было делать явный маппинг на joint-табличку.
3097.90 3110.46 "Игорь Лабутин" Понятно, что в базе у вас many-to-many будет через промежуточную табличку и в прошлой версии Entity Framework требовал отдельного специального маппинга и сущности в вашем коде, который бы соответствовал этой табличке для связи.
3110.46 3137.62 "Игорь Лабутин" Сейчас стало достаточным объявить два класса, которые соответствуют той и другой табличке, в каждом из них объявить коллекцию классов другого типа, то есть допустим в классе post, блок-пост объявить коллекцию тегов, а в классе тег объявить коллекцию блок-постов, где он встречается, после чего Entity Framework сам сообразит, что должна быть табличка, которая связывает many-to-many, настроит все нужные маппинги, сам будет генерировать правильные кверки через эту табличку.
3137.62 3139.78 "Игорь Лабутин" Все будет, соответственно, работать прекрасно.
3139.78 3145.62 "Игорь Лабутин" Третья фича из больших - это возможность очистки change tracker.
3145.62 3152.78 "Игорь Лабутин" Change tracker - это штука, которая следит за тем, что вы поменяли в Entity, чтобы когда вы скажете "save changes", она знала вообще, что сохранять, что не сохранять.
3152.78 3160.82 "Игорь Лабутин" И теперь можно сказать у change tracker вызвать метод clear и таким образом он забудет все, что он там трекал на данный момент.
3160.82 3162.10 "Анатолий Кулаков" Зачем это может быть нужно?
3162.10 3165.74 "Анатолий Кулаков" И почему это такая важная фича, что она перегнала все остальное?
3165.74 3169.86 "Игорь Лабутин" Нет, честно говоря, это немножко странно, я бы сказал.
3169.86 3171.50 "Игорь Лабутин" То есть я никогда не...
3171.50 3180.58 "Игорь Лабутин" Ну, может быть, никогда неправильно, но обычно ты создаешь контекст, что-то в нем делаешь, если что-то поменял, говоришь "save changes", используешь контекст, на этом все закончилось.
3180.58 3192.34 "Игорь Лабутин" Зачем это может быть надо, я, честно говоря, пока не знаю, но те, кто указывал эту фичу в списке самых клевых, говорили, что эта штука очень полезна в юнит-тестах.
3192.34 3204.70 "Игорь Лабутин" То есть когда мы в юнит-тест что-то напихали, мы проверили, что на самом деле наш, например, бизнес-логика в контекст сложила все, что нужно, entity все правильно помечены как tracked entity и они поменены, но в базу сохранять юнит-тесты нам, естественно, ничего не надо.
3204.70 3210.14 "Игорь Лабутин" После этого мы контексту говорим clear и заново начинаем тестик или как бы следующий тестик.
3210.14 3212.66 "Игорь Лабутин" Возможно, это как-то помогает в юнит-тестах.
3212.66 3219.26 "Игорь Лабутин" Я, признаться, не сильно юнит-тестировал код с entity framework, поэтому не знаю, насколько это прям нужно.
3219.26 3222.06 "Игорь Лабутин" Но раз комьюнити выбрал, наверное, это кому-то нужно.
3222.06 3227.10 "Игорь Лабутин" И последняя фича - это улучшенный scaffolding, то есть создание ваших классов из базы данных.
3227.10 3229.38 "Игорь Лабутин" Это про подход database-first.
3229.38 3240.50 "Игорь Лабутин" Во-первых, можно теперь scaffoldить в кастомные namespaces, то есть вы можете при, когда вы говорите dotnet, eef, dbcontext, scaffold, бла-бла-бла, указать namespaces, куда это все сгенерить.
3240.50 3262.82 "Игорь Лабутин" А второе - можно теперь более точно настроить так называемый pluralization, то есть теперь, когда вы из табличек базы данных будете создавать классы, точнее, когда entity framework будет создавать, он будет очень по-умному и хитро создавать множественное число от единственного с учетом английской морфологии.
3262.82 3268.82 "Игорь Лабутин" Наверное, это очень правильно для тех, кто ведет чистоту английского языка и добивается этого в коде.
3268.82 3272.90 "Игорь Лабутин" Возможно, это чуть менее актуально нашим российским программистам, но тем не менее фича прикольная.
3272.90 3273.90 "Игорь Лабутин" И, в общем-то, все.
3273.90 3278.34 "Игорь Лабутин" В entity framework core больше ничего такого особо нет по мнению комьюнити.
3278.34 3285.06 "Игорь Лабутин" Ну, конечно, как я сказал, фич 20, и многие, возможно, вам окажутся полезны, так что смотрите статью и выбирайте то, что вам понравилось.
3285.06 3286.06 "Игорь Лабутин" Отлично.
3286.06 3292.06 "Анатолий Кулаков" Вместе с всей этой бригадой также вышел новый релиз F#.
3292.06 3293.06 "Анатолий Кулаков" F# 5.
3293.06 3299.54 "Анатолий Кулаков" У нас не очень большие специалисты здесь собрались по F#, но хочется все-таки пробежаться и упомянуть этот замечательный язык.
3299.54 3307.42 "Анатолий Кулаков" Итак, главный путь, который проделал F# с четвертой версии по пятой, это в основном поддержка .NET Core и .NET 5.
3307.42 3315.06 "Анатолий Кулаков" В F# 5 уже практически это приключение закончилось и стабильная, хорошая, правильная поддержка уже вылита в main.
3315.06 3321.02 "Анатолий Кулаков" И с F# версии 5 разработчики начинают, так сказать, новую эру.
3321.02 3336.10 "Анатолий Кулаков" Они будут двигаться в сторону интерактивного программирования, они будут двигаться в сторону дата-ориентированного анализа и, наконец-то, они создадут отличную основу для того, чтобы принести перформанс-функциональное программирование.
3336.10 3342.94 "Анатолий Кулаков" Но, как я уже сказал, мы не слишком большие специалисты по F#, а освещать его надо.
3342.94 3345.94 "Анатолий Кулаков" Язык хороший, язык правильный, поэтому мы позвали помощника.
3345.94 3351.50 "Анатолий Кулаков" И сегодня нам поможет Роман Лиман, разработчик на F#, который пишет на нем в продакшене.
3351.50 3354.06 "Анатолий Кулаков" Да-да, такой человек существует и мы его отыскали.
3354.06 3355.06 "Анатолий Кулаков" Вот он.
3355.06 3356.06 "Анатолий Кулаков" Роман, привет.
3356.06 3360.42 "Анатолий Кулаков" Вообще, мне пятый релиз F# показался каким-то довольно-таки бедным на фичи.
3360.42 3365.70 "Анатолий Кулаков" Ну, то есть ничего такого по типу наших nullable типов, рекордах, паттерн-матчинг нет.
3365.70 3372.62 "Анатолий Кулаков" Я понимаю, что в F# они уже давно есть, но вот если по размеру так рассуждать, я верю, что я ошибаюсь.
3372.62 3381.18 "Анатолий Кулаков" Расскажи, пожалуйста, какие фичи ты считаешь важными, что больше всего ждало комьюнити и вообще, доволен ли ты текущим пятым релизом?
3381.18 3386.46 "Роман Лиман" На самом деле список фич для меня достаточно внушительный.
3386.46 3394.66 "Роман Лиман" Он не такой объемный, но качество этих фич, на мой взгляд, довольно значительное.
3394.66 3401.50 "Роман Лиман" То есть я расскажу обо всех, но в том порядке, в котором мне значимыми они.
3401.50 3403.74 "Роман Лиман" Это, естественно, субъективно.
3403.74 3408.98 "Роман Лиман" Первое — это улучшили опыт работы с интерактивом.
3408.98 3422.30 "Роман Лиман" И главная киллер-фича этого релиза — это то, что теперь можно одной строчкой зареференсить NuGet-пакет в сессии интерактива, и он за тебя все скачает и пропишет.
3422.30 3423.94 "Роман Лиман" Короче, это теперь стало очень просто.
3423.94 3427.38 "Роман Лиман" Это значительно облегчает эксперименты.
3427.38 3435.18 "Роман Лиман" То есть ты буквально несколько строчек вбил, и все, ты можешь попробовать, как одна библиотека работает с другой, с третьей.
3435.18 3448.70 "Роман Лиман" Буквально недавно я экспериментировал, как у нас будет работать сериализация нода тайма с нашими какими-то типами, с нашими настройками и так далее.
3448.70 3460.14 "Роман Лиман" И если раньше нужно было руками скачать какую-то DLL-ку, потом прописать до нее абсолютный путь, теперь это гораздо проще, и, соответственно, интерактивом теперь будут пользоваться чаще.
3460.14 3466.06 "Анатолий Кулаков" Слушай, насколько я знаю, интерактивность у F# была там с первых версий, и он ей так много гордился.
3466.06 3471.30 "Анатолий Кулаков" Я правильно понимаю, что это не какие-то изменения в движке, а именно инфраструктуру вокруг этой интерактивности наворачивают.
3471.30 3473.18 "Роман Лиман" Да, да, это просто...
3473.18 3488.50 "Роман Лиман" Ну, действительно, интерактивность была очень давно, это просто делает ее все более и более удобной, и вот этот шаг лично для меня, он как бы очень значительный, потому что я теперь с интерактером, благодаря этой фиче, работаю гораздо чаще и плотнее.
3488.50 3490.66 "Роман Лиман" Отлично, что-нибудь еще?
3490.66 3496.26 "Роман Лиман" Да, аппликативные computation expressions подвезли.
3496.26 3499.98 "Анатолий Кулаков" Ну понеслась, теперь нам будешь про монады рассказывать?
3499.98 3501.86 "Роман Лиман" Ну, куда же без этого?
3501.86 3502.86 "Роман Лиман" Ну давай.
3502.86 3509.14 "Роман Лиман" На самом деле, это уже существующий механизм сделали лучше.
3509.14 3513.46 "Роман Лиман" Как это объяснить для, например, C# пользователей?
3513.46 3518.94 "Роман Лиман" Это все равно, что async/await только для произвольных типов.
3518.94 3524.46 "Роман Лиман" Вы сами можете набросать немножко кода, чтобы он работал с конструкциями, которые похожи на async/await.
3524.46 3536.02 "Роман Лиман" То есть они разворачивают какой-то контейнер, в случае если C# это таски вокруг значений, например, таск от boolean, и вы пишете await и получаете уже boolean, а не обертку вокруг него.
3536.02 3548.10 "Роман Лиман" В C# можно навернуть такие expressions вокруг любого контейнера, и туда добавили возможность параллельного разворачивания этих значений.
3548.10 3549.10 "Роман Лиман" Наверное, так как-то.
3549.10 3557.22 "Анатолий Кулаков" То есть теперь неявно можно сделать какие-то параллельные вычисления, если даже в синтаксисе это явно не обозначать, явно не прописывать?
3557.22 3566.22 "Роман Лиман" Если мы говорим об асинхронных каких-то операциях, да, можно очень удобно делать параллельные вычисления, которые возвращают значения разного типа.
3566.22 3575.06 "Роман Лиман" То есть понятно, что есть таск параллел или асинк параллел, и это раньше можно было, но это если операции возвращали одно и то же значение.
3575.06 3580.90 "Роман Лиман" Теперь можно делать абсолютно независимые операции, вызывать параллельно.
3580.90 3590.22 "Роман Лиман" В случае, например, с квалитацией можно проверить, вызвать несколько методов, которые возвращают окей или ошибку.
3590.22 3607.66 "Роман Лиман" И если раньше они выполнялись последовательно, и весь воркфлоу обрабался на первой проверке, то теперь можно построить его так, чтобы он выполнил 5-10 сколько угодно проверок, и всех их сгруппировал, и только в конце оборвал воркфлоу.
3607.66 3613.30 "Роман Лиман" Теперь подвезли достаточно синтаксического сахара, чтобы это было очень удобно в использовании.
3613.30 3614.30 "Анатолий Кулаков" Ну, отлично.
3614.30 3615.94 "Анатолий Кулаков" Давай еще какую-нибудь одну.
3615.94 3616.94 "Роман Лиман" Интерполяцию, строк.
3616.94 3620.62 "Анатолий Кулаков" Не, погоди, это у нас было уже в C#, этим ты нас не удивишь.
3620.62 3621.62 "Анатолий Кулаков" Ну да.
3621.62 3624.62 "Роман Лиман" Давай что-нибудь специфическое, интересненькое.
3624.62 3629.10 "Роман Лиман" Ладно, неймов тоже не удивишь, он тоже есть в F#.
3629.10 3632.78 "Роман Лиман" На самом деле из больших фичей, в общем-то, все.
3632.78 3637.90 "Роман Лиман" Дальше есть какие-то улучшения в метапрограммировании, интероп, перформанс.
3637.90 3643.78 "Анатолий Кулаков" А можешь в двух словах сказать, что такое F#, quotations, improvements?
3643.78 3648.06 "Роман Лиман" Quotations - это альтернатива expression.
3648.06 3652.14 "Роман Лиман" На самом деле наоборот, quotations появились чуть раньше, и они чуть-чуть более удобные.
3652.14 3664.46 "Роман Лиман" В том смысле, что ты пишешь, обрамляешь кусок кода в специальные символы, и пишешь, по сути, обычный код, а компилятор сам это разворачивает в дерево выражения.
3664.46 3675.02 "Роман Лиман" И там какие-то небольшие улучшения сделали, которые раньше сыпались исключениями определенной конструкции, а не отрабатывают так, как ожидается.
3675.02 3676.02 "Анатолий Кулаков" Ну, отлично.
3676.02 3682.42 "Анатолий Кулаков" Я, в принципе, сталкивался с quotations и в других языках, и очень сильно бы ждал, что в C# они тоже появились.
3682.42 3685.02 "Анатолий Кулаков" Но, насколько я знаю, никаких планов на этот счет нет.
3685.02 3686.66 "Анатолий Кулаков" Поэтому пока радуемся за F#.
3686.66 3689.90 "Анатолий Кулаков" Слушай, а скажи, знаешь ли ты что-нибудь про новые фичи языка?
3689.90 3691.38 "Анатолий Кулаков" То есть, пятый релиз позади.
3691.38 3694.78 "Анатолий Кулаков" Что дальше, к чему будем стремиться, и что ждать от F# в будущем?
3694.78 3697.86 "Роман Лиман" Есть еще большая фича, которая ожидается.
3697.86 3704.26 "Роман Лиман" Это resumable task или state machines.
3704.26 3706.30 "Роман Лиман" Но это тоже, это больше про performance.
3706.30 3717.30 "Роман Лиман" То есть, вот эти computation expressions, которые есть сейчас, они генерируют цепочку вызовов и где-то там элацируют больше, понятное дело, и так далее.
3717.30 3725.06 "Роман Лиман" В скором времени релизнется фича, которая будет очень круто оптимизировать этот код.
3725.06 3731.70 "Роман Лиман" Будет похоже на то, что C# компилятор делает со sync'ами и await'ами, насколько я понимаю.
3731.70 3736.54 "Роман Лиман" Касательно каких-то именно фичей языка я не знаю.
3736.54 3741.02 "Роман Лиман" Насколько я понимаю, теперь больше фокус на tooling уходит.
3741.02 3751.14 "Роман Лиман" И мне кажется, это правильно, потому что в принципе уже язык и так достаточно богатый на разные фичи, чтобы...
3751.14 3754.38 "Роман Лиман" Ну, в интерфразе этого пока с головой хватает.
3754.38 3763.42 "Роман Лиман" А вот чего не хватает, это где-то там удобство дебага, какой-то подсветки, где-то автодополнение хромает.
3763.42 3770.82 "Роман Лиман" И если вот это поправят, то для многих разработчиков порог вхождения в F# существенно снизится.
3770.82 3771.82 "Анатолий Кулаков" Это точно.
3771.82 3772.82 "Анатолий Кулаков" Слушай, насчет разработчиков.
3772.82 3779.46 "Анатолий Кулаков" У нас, к сожалению, мало в гостях бывает разработчиков на F#, поэтому я тебе уже помучаю по другим тоже вопросам.
3779.46 3784.58 "Анатолий Кулаков" Мне кажется, что вот F# комьюнити, оно как-то не развивается совсем.
3784.58 3787.18 "Анатолий Кулаков" То есть оно стоит на какой-то минимальной точке для того, чтобы не сдохнуть.
3787.18 3791.70 "Анатолий Кулаков" И никаких каких-то громких имен, громких событий, громких людей.
3791.70 3795.42 "Анатолий Кулаков" Ну вот Vlash и Don't Sign - это единственные люди, которые мне приходят на ум.
3795.42 3803.98 "Анатолий Кулаков" Никаких громких проектов, по крайней мере, до нас не доходит, до тех людей, которые не следят именно за самим языком, а просто смотрят на эту инфраструктуру сбоку.
3803.98 3805.98 "Анатолий Кулаков" Скажи, как твое ощущение?
3805.98 3807.42 "Анатолий Кулаков" Как идет взросление сообщества?
3807.42 3809.10 "Анатолий Кулаков" Будут ли новые люди?
3809.10 3825.78 "Роман Лиман" Ну, новые люди, на мой взгляд, будут, потому что я как минимум наблюдаю то, что F# чаще упоминается уже от самого Microsoft, и какие-то люди из ISP.NET Core, из Sensitive Framework Core начинают проявлять интерес.
3825.78 3836.86 "Роман Лиман" Если раньше они вообще как будто даже не знали о существовании F# и не парились в том, чтобы их фреймворки хорошо им поддерживались, вот сейчас эти вопросы начинают подниматься.
3836.86 3856.10 "Роман Лиман" Обычно какие-то активных участников, не знаю, ну вот помимо тех, которых ты озвучил, есть еще Айзек Абрахам, он книжку хорошую написал, и в целом хороший эксперт, к которому можно просто в Твиттере обратиться за советом или даже созвониться.
3856.10 3861.54 "Анатолий Кулаков" Слушай, а вот ты говоришь, что Microsoft стал лучше относиться к F#, на каких примерах ты это заметил?
3861.54 3877.02 "Роман Лиман" В F# в репозитории завели issue по поводу неудобности использования ОРМ существующих, в частности Entity Framework Core, который сейчас, наверное, самый популярный дотнетовский ОРМ.
3877.02 3898.10 "Роман Лиман" И один из разработчиков этой команды, EF Core, он пришел и подробненько расписал, что они готовы улучшить со своей стороны какие-то моменты, но им требуется помощь сообщество, потому что они не знают, что именно и как лучше улучшать.
3898.10 3903.82 "Роман Лиман" И в общем, они изъявили желание и открытость к тому, чтобы пойти навстречу.
3903.82 3906.02 "Роман Лиман" Вот, это один пример.
3906.02 3916.10 "Роман Лиман" Второй пример – это Дэвид Паулер, который активно там участвует в разработке ISPNet Core, насколько я знаю.
3916.10 3923.14 "Роман Лиман" Он тоже стал проводить какие-то эксперименты с F#, в Твиттере об этом постит, как-то так.
3923.14 3928.98 "Роман Лиман" Ну и в целом, в релизе дотнет 5 тоже F# много внимания уделили.
3928.98 3931.10 "Анатолий Кулаков" Ну да, да.
3931.10 3932.10 "Анатолий Кулаков" Звучит отлично.
3932.10 3940.26 "Анатолий Кулаков" Да, Паулер – это действительно большой популярный чувак в C#, в ISPNet, ну вообще в принципе все, где связано с сетью, он в принципе везде лезет.
3940.26 3942.78 "Анатолий Кулаков" Отлично, звучит хорошо.
3942.78 3945.18 "Анатолий Кулаков" Подскажи тогда еще один больной вопрос.
3945.18 3956.02 "Анатолий Кулаков" Когда все-таки появится работа для F#-истов, потому что я знаю, что многие как хобби его пытаются использовать, но когда стараются монетизировать свои знания, с этим очень все плохо.
3956.02 3958.02 "Анатолий Кулаков" Есть ли подвижки в этой струне?
3958.02 3967.62 "Роман Лиман" Да, подвижки определенно есть, ну, несмотря на то, что F# все еще существенно менее популярен, чем C# и Java.
3967.62 3973.06 "Роман Лиман" У меня уже сейчас вторая работа на F#.
3973.06 3980.42 "Роман Лиман" Я знаю, что в Норвегии, в Швеции есть крупные компании, которые им пользуются.
3980.42 3984.14 "Роман Лиман" Просто рынок вакансий сейчас работает немножко
3984.14 4004.14 None по-другому. Не публикуются вот таким потоком вакансии от какого-нибудь EPUB или другого крупного аутсорфера, но в последнее время мне все чаще уже даже начинают какие-то рекрутеры писать, что им нужны специалисты на F#, что они заметили какую-то мою активность на GitHub или в сообществе или еще где-то.
4004.14 4012.18 "Роман Лиман" И сейчас, я думаю, если вы действительно хотите найти работу на F#, просто будьте чуть-чуть активнее в комьюнити.
4012.18 4020.14 "Роман Лиман" Пишите какие-нибудь статьи или активно что-то изучаете, и не стесняйтесь искать удаленную работу и работу
4020.14 4023.82 None на зарубежной компании. Отлично, Роман, большое спасибо.
4023.82 4026.54 "Анатолий Кулаков" Спасибо, что рассказал нам подробнее про F#.
4026.54 4030.86 "Анатолий Кулаков" Я надеюсь, что у языка будет все хорошо, и он будет расти и процветать.
4030.86 4045.90 "Анатолий Кулаков" Из тех вещей, которые Роман не упомянул, это улучшена поддержка в Jupiter Notebooks, в Interact, Visual Studio Code Notebooks, добавлен String Interpolation и добавлен NameOf.
4045.90 4050.86 "Анатолий Кулаков" Я сказал просто так, чтобы поржать, потому что наконец-то хоть что-то в #3 и #2.
4050.86 4053.54 "Анатолий Кулаков" У них теперь есть NameOf и String Interpolation.
4053.54 4054.54 "Анатолий Кулаков" Ха-ха-ха.
4054.54 4058.58 "Анатолий Кулаков" Ну, NameOf, надо сказать, что у них поумнее, конечно, все они сделали более в совесть.
4058.58 4062.54 "Анатолий Кулаков" Например, можно сделать NameOf от плюсика, как вам, он вам выдаст плюсик.
4062.54 4069.62 "Анатолий Кулаков" Можно делать NameOf от generic параметров и такие прочие интересные вещи, которые наш NameOf пока делать не умеет.
4069.62 4073.66 "Анатолий Кулаков" Но я думаю, надеюсь, мы до этого практически скоро дорастем.
4073.66 4078.74 "Игорь Лабутин" Да, ну раз мы поговорили про F#, давай снова что ли поговорим про C#?
4078.74 4080.90 "Игорь Лабутин" Давно мы что-то не упоминали C# 9.
4080.90 4082.50 "Игорь Лабутин" Давно, да буквально минуту назад.
4082.50 4084.02 "Игорь Лабутин" О чем ты хотел поговорить?
4084.02 4089.14 "Игорь Лабутин" Есть статья о релизе C# 9.0 от главного архитектора языка Майса Торгерсена.
4089.14 4095.14 "Игорь Лабутин" Интересно, что он считает самыми важными и ключевыми фичами, вышедшими в C# 9.
4095.14 4098.94 "Игорь Лабутин" Вот мы говорили про сорт генераторов, еще какие-то штуки.
4098.94 4100.94 "Игорь Лабутин" А вот что он считает?
4100.94 4104.18 "Игорь Лабутин" Как ты думаешь, с чего у него начинается статья?
4104.18 4108.30 "Анатолий Кулаков" Я думаю, скорее всего, так же, как и у всех, это все-таки рекорды.
4108.30 4113.18 "Анатолий Кулаков" Рекорды, они задали тон всему релизу и, наверное, считаются самой главной фичей.
4113.18 4118.78 "Игорь Лабутин" Да, это действительно так, но он к ним заходит немножко издалека, он начинает сначала с init.only.properties.
4118.78 4128.18 "Игорь Лабутин" И если вы думали, что init.only.properties это нужно исключительно для поддержки рекордов, вы, возможно, были правы, но вы можете их использовать и в ваших классах тоже, потому что это совершенно нормальная штука.
4128.18 4133.46 "Игорь Лабутин" Если вам нужна проферция, которая инициализируется только один раз, смело пишите теперь get.init.
4133.46 4141.46 "Игорь Лабутин" И компилятор вас предупредит, если вы ее инициализируете, пытаетесь еще где-то дальше, кроме как в конструкторе или в Object Initializer.
4141.46 4143.82 "Игорь Лабутин" Дальше, соответственно, есть рекорды.
4143.82 4148.90 "Игорь Лабутин" И с рекордами, несомненно, идет не только сами они, но и withExpressions.
4148.90 4159.94 "Игорь Лабутин" Тот факт, что рекорды являются по сути value объектами в том смысле, что у них не сравниваются референсы, а они всегда сравниваются по значению полей друг с другом.
4159.94 4160.94 "Игорь Лабутин" Так называемые value-based equality.
4160.94 4165.94 "Анатолий Кулаков" Ну и еще нужно упомянуть, что рекорды это прежде всего иммьютабельные типы считаются.
4165.94 4171.06 "Анатолий Кулаков" И именно поэтому по умолчанию у них сделан этот structure equality.
4171.06 4175.02 "Игорь Лабутин" Но вот считаются иммьютабл - это интересная штука.
4175.02 4187.30 "Игорь Лабутин" Если вы сейчас пророетесь по интернету, вы найдете, что некоторое количество статей, которые озаглавлены так, что типа "А че, рекорды бывают не иммьютабл в C#?" Я типа считал, что они 100% гарантированы иммьютабл.
4187.30 4192.58 "Игорь Лабутин" На самом деле они не 100%, их можно сделать ммьютабл, и некоторые на это накалываются.
4192.58 4202.62 "Игорь Лабутин" Но в целом, если их использовать аккуратно и не пытаться что-то хитрое сотворить, добавляя свои кучи методов и так далее, они будут конечно же иммьютабл.
4202.62 4213.70 "Игорь Лабутин" При этом рекорды это нормальные классы, их можно наследовать, они могут реализовывать интерфейсы, их можно деконстрактить там, ну и в общем делать с ними все, что вы наверное хотите делать с рекордами.
4213.70 4217.94 "Игорь Лабутин" А если что-то нельзя делать, то ждите C# 10, там наверняка это добавят.
4217.94 4239.34 "Игорь Лабутин" Дальше у него идут top-level programs, мы их уже обуминали, improved pattern matching, matching теперь по типам, relation patterns, то есть не только ключевые слова and и or, можно еще знаки неравенства и равенства использовать, то есть можно написать всякие pattern matching типа меньше 3000, следовательно верни что-то или больше, и меньше другого увеличенной, то верни что-то другое, ну и так далее.
4239.34 4244.02 "Анатолий Кулаков" О, новый new expression, вот мы его как-то сегодня вообще пропустили, а фича-то довольно интересная, скажи.
4244.02 4246.10 "Анатолий Кулаков" Это практически можно сравнить с появлением вара.
4246.10 4269.46 "Игорь Лабутин" Да, это можно сравнить с варом, буквально сегодня попался твит, что теперь target type new вместе с варом позволяет написать код вида, точнее он позволяет написать функцию, нетривиальную, из нескольких строчек, которая делает что-то полезное и при этом в теле функции не упомянуты ни одного типа, то есть единственный тип это тип аргумента и после этого все, что с ним делается дальше компилятор сам выводит.
4269.46 4287.22 "Игорь Лабутин" То есть там код вида в арте присвоить param, соответственно там param.что-то присвоить new круглые скобки, return что-то там, ну то есть по типам всего и вся компилятор теперь может выводить и вы в принципе можете встретить в вашем коде теперь функцию, где не будет вообще ни одного типа и одни сплошные вары и new.
4287.22 4296.70 "Анатолий Кулаков" Слушай, для ретро-города мне кажется это просто самоубийство, то есть те люди, которые хотят топить за читабельность, хотят видеть всегда типы, хотят видеть всегда аннотации, в общем им кажется сейчас начнется больно.
4296.70 4325.82 "Игорь Лабутин" Да, особенно, как я понимаю, существует вполне возможность передать new с какими-нибудь например круглыми скобочками в аргумент функции, если у тебя допустим присвоение какой-нибудь переменной, там вот как у него в примере point p присвоить new от 3,5, ну понятно, мы создаем point с координатами 3,5, то вот если ты вызываешь какой-нибудь функцион, draw что-нибудь и передаешь внутренний new с круглыми скобочками, то догадаться по этому коду, что ты передал, какого оно вообще типа, не представляется вообще возможным никак.
4325.82 4339.30 "Анатолий Кулаков" Мне кажется здесь отлично будут спасать вот линзы и решаперовские, и визжл студийные аннотации, знаешь, когда они подписывают сбоку, какой тип передается в какой-то метод, как бы где передается в цепочку
4339.30 4353.50 "Игорь Лабутин" вызова. Да, штука полезная, но с другой стороны я у себя ее отключил, потому что вот в текущей версии, по крайней мере в той версии, которую я пробовал, решарпи райрайдера, она уж больно вербозная, то есть она показывает их много где и честно говоря начинает немножко мешать.
4353.50 4369.90 "Игорь Лабутин" Вот и была бы у них опция примерно как с варом, то есть у вара есть опция типа использовать вар только если тип не очевиден, ну как-то так, то есть он оставляет по крайней мере одно упоминание типа в строке, грубо говоря, или наоборот, использовать вар если тип очевиден, как-то так она формулируется.
4369.90 4375.06 "Анатолий Кулаков" Ну когда мы говорим о переменных, о их типах, то там это условие гораздо сложнее.
4375.06 4381.26 "Анатолий Кулаков" Если с варом все ясно, что есть тип указан или не указан, то с этими аннотациями все намного сложнее.
4381.26 4389.90 "Анатолий Кулаков" Но я хочу сказать, что они в последних релизах очень сильно это переписали, очень сильно улучшили, как раз таки чтобы избавиться от вот этой многословности,
4389.90 4391.90 "Игорь Лабутин" попробуй еще раз. Да, надо бы попробовать.
4391.90 4396.58 "Игорь Лабутин" Ну в общем вот примерно то, про что хотел, хочет подчеркнуть Мэтт Сторгенсен.
4396.58 4398.98 "Игорь Лабутин" А, ну еще есть последний фичик, авариент ретурнс.
4398.98 4407.86 "Игорь Лабутин" У вас теперь, если есть наследник некоего класса, то когда вы оверрайдите методы базового класса, вы теперь можете возвращать более специфических наследников ретурн-классов.
4407.86 4412.54 "Игорь Лабутин" То есть того, что вы возвращаетесь в абстрактном методе базового класса.
4412.54 4418.98 "Игорь Лабутин" Это позволяет писать более правильный код, чем там кучу кастов делать внутри, когда вы знаете, что вы точно работаете с объектом наследника.
4418.98 4431.74 "Игорь Лабутин" Итак, это было мнение архитектора языка, но на самом деле мы в целом-то так довольно прикольно все рассказываем, положительно, все такое клевое, замечательное, но есть же те, кто этим языком пользуются и чуть-чуть по-другому.
4431.74 4435.38 "Игорь Лабутин" Они его парсят, они с ним пытаются что-то делать.
4435.38 4438.98 "Игорь Лабутин" Ребята из JetBrains наверняка тоже имеют какое-то мнение о C# 9.
4438.98 4443.74 "Анатолий Кулаков" Да, и у нас есть возможность как-то раз-таки взглянуть их глазами на этот релиз.
4443.74 4453.94 "Анатолий Кулаков" У нас в студии разработчик, который отвечает за то, чтобы поддержать самые новые и самые лучшие фичи языка C# в райдере или шарпере, Андрей Дятлов.
4453.94 4454.94 "Анатолий Кулаков" Привет, Андрей.
4454.94 4455.94 "Анатолий Кулаков" Привет.
4455.94 4462.82 "Анатолий Кулаков" Андрей, скажи, а нравится ли тебе вообще этот релиз, нравится ли тебе синтаксис и вообще то, что происходит с языком в последние нескольких релизов?
4462.82 4464.38 "Анатолий Кулаков" Как ты к этому относишься?
4464.38 4468.38 "Андрей Дятлов" Слушай, ну направление фич, которые появляются в языке, мне скорее нравится.
4468.38 4476.98 "Андрей Дятлов" То есть в C# 9 у нас появились source-генераторы, рекорды, pattern-matching, и я подозреваю, что все это будет очень активно использоваться и сильно облегчить жизнь.
4476.98 4480.38 "Андрей Дятлов" Я бы сказал, что есть еще два направления.
4480.38 4485.82 "Андрей Дятлов" Это performance-фичи, разная работа с поинтерами, нативные моменты.
4485.82 4500.46 "Андрей Дятлов" Я не очень активно этим пользуюсь, поэтому не могу сказать, насколько это актуально, но из того, что я вижу, оно решает узконаправленные performance-задачи, и, соответственно, каким-то людям без них жить не получается, поэтому это тоже замечательные фичи.
4500.46 4520.26 "Андрей Дятлов" И есть еще группа фичей, которые я бы назвал такими quality-of-life фичами, скажем, target-typed object creation, target-typed conditional, статические лямбды, статические локальные функции, и это тоже, пожалуй, важное направление, потому что оно просто облегчает жизнь, делает меньше странных нюансов языка.
4520.26 4531.70 "Анатолий Кулаков" А можешь назвать какую-нибудь фичу, которая, по твоему мнению, языку вообще не нужна была не только в последнем релизе, но, может, там, три последних релиза, и зря ее вообще добавили, ты бы никогда такого не сделал?
4531.70 4539.26 "Андрей Дятлов" Слушай, мне казалось, что такой функции будут локальные функции, но в результате я их использую каждый день, так что не подходит.
4539.26 4546.54 "Андрей Дятлов" И с последней версией языка, мне кажется, что top-level statement, они, пожалуй, нужны только когда ты язык учишь.
4546.54 4555.18 "Андрей Дятлов" То есть я не пишу метод main чаще, чем несколько раз в месяц, и даже тогда все равно в дефолтном шаблоне проекта он уже есть.
4555.18 4565.66 "Анатолий Кулаков" Да, ты прав, мне кажется, это такая более показушная фича, или может быть для каких-нибудь скриптовых применений, для какой-нибудь юпитер-бук применений, знаешь, когда тебе нужно что-нибудь быстренько заскриптовать.
4565.66 4568.10 "Андрей Дятлов" Ну, для этого C# интерактив уже есть.
4568.10 4569.54 "Анатолий Кулаков" Да, тоже верно.
4569.54 4571.94 "Анатолий Кулаков" Слушай, а может быть если не так жестоко, что...
4571.94 4577.54 "Анатолий Кулаков" Может быть какой-то ты фичу сделал бы по-другому или реализовал по-другому, есть ли у тебя такие какие-нибудь кандидаты?
4577.54 4582.66 "Андрей Дятлов" Ну, скорее я в некоторых фичах сделал бы компилятор менее умным.
4582.66 4584.78 "Андрей Дятлов" Ну, скажем, те же локальные функции.
4584.78 4591.50 "Андрей Дятлов" Можно объявить переменную, не инициализировать ее, вызвать локальную функцию, которая сделает в нее запись, и потом ей пользоваться.
4591.50 4598.30 "Андрей Дятлов" И компилятор это поймет, узнает, что переменная была инициализирована в вызове локальной функции, разрешит ей пользоваться.
4598.30 4599.30 "Андрей Дятлов" Ну, зачем?
4599.30 4603.34 "Андрей Дятлов" Я не видел, чтобы кто-то этим пользовался, и это просто добавляет неоправданную сложность.
4603.34 4605.58 "Андрей Дятлов" Есть еще несколько примеров.
4605.58 4617.06 "Андрей Дятлов" Мне, например, не понравилось, когда разрешили перекрывать значение внешних замыканий в лямбдах локальных функциях, но не во всей функции, а, скажем, только в одном ифе.
4617.06 4624.54 "Андрей Дятлов" То есть ты пишешь лямбду, в ней есть иф, в z-не ты объявил переменную и скрыл замыкание, а в l-се ты пользуешься этим же именем для замыкания.
4624.54 4629.14 "Андрей Дятлов" Мне кажется, это может быть немножко странно и сбивать с толку людей.
4629.14 4631.58 "Андрей Дятлов" Да, одно и то же имя, то замыкание, то нет.
4631.58 4633.30 "Анатолий Кулаков" Да, точно, звучит очень страшно.
4633.30 4639.70 "Анатолий Кулаков" Надеюсь, вы какой-нибудь анализатор сделаете, который будет кричать, что переменуйте имя, иначе это будет сбивать людей с толку.
4639.70 4641.90 "Андрей Дятлов" Пока не сделаю, но идея хорошая.
4641.90 4659.90 "Андрей Дятлов" Еще из того, что я бы сделал по-другому, это конверсии с Valid to Plama, потому что когда я написал их поддержку, внезапно оказалось, что можно конвертировать какой-нибудь тип или тапл из redefined конверсии, то есть оператором, который где-то в коде написан, к человеку.
4659.90 4667.02 "Андрей Дятлов" А затем компилятор обычно разрешает только одну из redefined конверсию, но конкретно с таплами он разрешает их несколько подряд.
4667.02 4674.90 "Андрей Дятлов" И получилась ситуация, что можно написать тип, которого поиск конверсии просто съест всю память, потому что он будет экспоненциальным.
4674.90 4684.54 "Андрей Дятлов" К сожалению, я не успел завести об этом баг в компилятор, поэтому когда я это сделал, мне сказали, что, к сожалению, в нашей backward compatibility мы менять ничего не можем.
4684.54 4685.54 "Андрей Дятлов" Неплохо.
4685.54 4700.82 "Анатолий Кулаков" Слушай, а скажи тогда, насколько вообще возможно повлиять на те реализации, которые делает Microsoft, на те фичи, которые они только задумывались, и делаете ли вы, как-то вы вмешиваетесь в процесс, помогаете им, общаетесь с ними.
4700.82 4705.58 "Анатолий Кулаков" Насколько это вообще стало, когда Microsoft пришел в open source, насколько это вообще стало открыто и возможно?
4705.58 4712.34 "Андрей Дятлов" Это возможно через их GitHub, там можно просто завести какой-нибудь issue, пообсуждать какую-нибудь фичу.
4712.34 4724.26 "Андрей Дятлов" Проблема с этим в том, что, во-первых, не все люди осознают, как именно будет выглядеть фича до того, как она зарелизится, а после того, как она зарелизилась, уже backward compatibility, и менять ничего нельзя.
4724.26 4736.38 "Андрей Дятлов" И проблема еще и в том, что на самом деле команда компилятора достаточно ответственно подходит к фичам, поэтому если они что-то обдумали, приняли решение, как оно должно выглядеть, часто менять там особо и нечего.
4736.38 4762.90 "Андрей Дятлов" Тем не менее, всегда случаются баги, например, в том же Nullable анализе у меня около двухсот багов на компилятор заведено, и какие-то из них фиксятся, какие-то закрываются как by design, какие-то приводят к обсуждениям на language design митингах, так что если убедительно показать, почему какой-то дизайн плох или почему он не соответствует тому, что ожидается, то команда компилятора какие-то действия по этому поводу предпринимает.
4762.90 4775.34 "Анатолий Кулаков" А возможно ли вмешаться на более ранний стадий, то есть до того, как они эту фичу запланировали, только когда они выкатили какой-то пропозыв, начинают обсуждать и вот сейчас вмешаться, то есть пока ещё много сил не потрачено на раннем этапе дизайна.
4775.34 4790.54 "Андрей Дятлов" Ну, например, сейчас я отслеживаю thread, посвященный параметрам nullchecking, который был перенесён c# 9 на c# 10, да, можно поставить, скажем, восклицательный знак после имени параметра и компилятор сгенерирует nullcheck в него.
4790.54 4805.74 "Андрей Дятлов" Там достаточно длинное обсуждение, единственная проблема в этом случае — понять, действительно ли ты повлиял как-то на дизайн фичи, потому что команда компилятора это читает, отвечает, но там достаточно разные мнения, и какое решение в итоге принято и почему — не всегда понятно.
4805.74 4811.86 "Анатолий Кулаков" Ну, то есть всё-таки этот процесс ещё не совсем прозрачен, то есть не совсем можно повлиять как-то на фичу.
4811.86 4817.46 "Андрей Дятлов" Да, кроме того, пока фича находится в разработке, не всегда понятно, как именно она будет выглядеть.
4817.46 4822.38 "Андрей Дятлов" То есть, скажем, финальный дизайн рекордов, если не ошибаюсь, чуть ли не в сентябре появился.
4822.38 4828.54 "Андрей Дятлов" До этого там предлагались различные кейворды, да и это кейворд, например, после класса.
4828.54 4837.50 "Андрей Дятлов" И для меня, например, стало немного удивительно, что они отказались от кейворда класс и оставили просто рекорд и его имя.
4837.50 4843.98 "Андрей Дятлов" Потому что это, во-первых, смущает человека, который читает код, он не понимает, это класс или структура или что-то третье.
4843.98 4849.66 "Андрей Дятлов" А во-вторых, это breaking change, если у тебя был метод рекорд в интерфейсе.
4849.66 4860.02 "Андрей Дятлов" И кроме того, в C# 10 они хотят добавить рекорд структуры, их придется как-то обозначать, придется добавить кейворд struct туда и возникнет опять вопрос, почему мы struct пишем, а класс нет.
4860.02 4861.02 "Анатолий Кулаков" Спасибо, Андрей.
4861.02 4868.98 "Анатолий Кулаков" Я напоминаю, что с нами был Андрей Дятлов, разработчик поддержки языка C# в райдере и решарпере из компании JetBrains.
4868.98 4874.66 "Анатолий Кулаков" Ну что ж, а мы сегодня довольно-таки много упоминали такие слова, как performance, improvements, что-то там улучшили, что-то там ускорили.
4874.66 4888.06 "Анатолий Кулаков" И, наверное, одна из самых громких статей, самых громких новостей, которая потрясла довольно-таки много устоев, это статья Джеймса Ньютона Кинга о том, как он увеличил перформанс JRPC сервера.
4888.06 4912.92 "Игорь Лабутин" Ну, справедливости разе, наверное, не только он один, наверняка там работала команда, но сейчас по бенчмаркам, реквестам в секундах, он занимает одни из первых мест, он там уступает только расту и в целом утверждается, что дотнет 5 сервер по перформансу, он примерно на 60% быстрее дотнет кор 3.1, а мы знаем, что дотнет кор 3.1 уже довольно быстрый сервер.
4912.92 4932.84 "Анатолий Кулаков" Здесь надо упомянуть, что дотнет кор обогнал реализацию на плюсах, естественно, обогнал реализацию на Java и обогнал реализацию на Go, что мне кажется очень значимо, потому что Go реализацию пилит Google, он туда вкладывает какие-то миллиарды человеко-часов, чуть ли не сам язык под это JRPC затачивает, ну и уступив только лишь расту.
4932.84 4934.64 "Анатолий Кулаков" Показатели просто феноменальные.
4934.64 4939.88 "Игорь Лабутин" Да, и по большому счету они этого добились активной работой с памятью, как ни странно.
4939.88 4956.24 "Игорь Лабутин" То есть, гробоцент довольно много требует памяти и в исходной версии, когда они только начинали с дотнет кор 3.1, на каждый приходящий реквест ему требовалось чуть-чуть меньше 4 килобайт оперативки, чтобы этот самый реквест обработать внутри сервера.
4956.24 4973.60 "Игорь Лабутин" И естественно, при большом количестве реквестов, там 10 тысяч реквестов, 100 тысяч реквестов, становится заметная нагрузка на garbage collector и график потребления памяти, он становится такой характерной пилой, когда периодически срабатывает garbage collector и начинает все чистить.
4973.60 4978.96 "Игорь Лабутин" Поэтому для того, чтобы увеличить скорость, они стали придумывать довольно много разных улучшений.
4978.96 4983.08 "Игорь Лабутин" Первым делом, конечно же, если вас беспокоит garbage collection, займитесь пулингом.
4983.08 4989.16 "Игорь Лабутин" Они некоторые внутренние объекты стали складывать в object pool и пулить их правильно.
4989.16 5002.40 "Игорь Лабутин" Много где поэкономили кусочки на риюзе каких-то маленьких объектиков и так далее, но при этом, как только мы начинаем что-то пулить, надо не забывать, что из пула надо объекты убирать, потому что иначе они будут копиться там вечно.
5002.40 5020.72 "Игорь Лабутин" И там есть тоже отдельная логика, можно почитать, если интересно, если вам интересуют всякие, то что называется cache eviction strategies, почитайте соответствующую ссылку в статье, там есть объяснение, откуда взялось 5 секунд, почему ровно через 5 секунд эти стримы убираются из пула и так далее.
5020.72 5025.60 "Игорь Лабутин" Дальше вторая часть и довольно-таки важная - это работа с хедерами.
5025.60 5037.84 "Игорь Лабутин" HTTP2, который используется внутри gRPC, он на самом деле поддерживает мультиплексинг, то есть одновременно несколько коннекшенов, но при этом хедера все обрабатываются вместе в одном коннекшене всегда.
5037.84 5043.20 "Игорь Лабутин" То есть, насколько я понимаю, невозможно послать хедера из разных коннекшенов в череду и друг с другом.
5043.20 5054.48 "Игорь Лабутин" По крайней мере, даже если послать-то их можно, то обработать их нужно вместе, потому что их энкодинг зависит друг от друга немножко в так называемом HPAC header compression алгоритме.
5054.48 5063.00 "Игорь Лабутин" И вот как раз-таки вокруг этого декодера алгоритма из HPAC у них было максимальное количество улучшений.
5063.00 5089.20 "Игорь Лабутин" То есть много поработали над циклами, естественно завезли всяческие спаны, memory, вот это вот все, то есть как можно меньше локейтов, как можно больше стеколоков, все дела, какие-то предчтения, там, литералов, то есть если мы видим, что префикс нам незнакомый, мы сразу пропускаем вперед на несколько символов, потому что мы знаем, что точно там ближайшие 10 символов будет продолжение этого литерала и нам он не интересен, ну и так далее.
5089.20 5105.28 "Игорь Лабутин" Плюс они захардкодили какое-то количество стандартных хедеров, то есть, как выясняется, в стандарте есть 61 common header name, то есть 61 стандартный хедер, который может встретиться и их можно посылать числами вместо полных имен для оптимизации.
5105.28 5107.04 "Игорь Лабутин" И это тоже было использовано.
5107.04 5111.76 "Игорь Лабутин" В общем, это все привело к достаточно качественным результатам, как мы видим.
5111.76 5124.80 "Игорь Лабутин" И кроме того, до .NET 5, Kestrel, это веб-сервер наш в .NET, позволял читать вот эти compressed headers, но response headers всегда посылались не сжатыми.
5124.80 5130.68 "Игорь Лабутин" Теперь эта возможность включена и ее можно использовать и еще больше сэкономить на трафике.
5130.68 5133.48 "Игорь Лабутин" Конечно, ценой немножко расхода CPU.
5133.48 5140.72 "Игорь Лабутин" И для обработки реквестов после того, как обработали хедеры, конечно же, важно обработать сам, собственно, message.
5140.72 5142.36 "Игорь Лабутин" В GRPC это, конечно же, Protobuf.
5142.36 5163.80 "Игорь Лабутин" И Protobuf сериалайзер был довольно сильно перепилен для того, чтобы тоже использовать все новинки, спаны, redo only sequences, stack allocs и даже всякие разные примитивы работы над бинарными типами, типа чтения всяких little endian и прочих штук, 64-битных, целых и все такое прочее.
5163.80 5167.16 "Игорь Лабутин" Чисто чтобы выжать самые последние капли перформанса.
5167.16 5168.48 "Игорь Лабутин" И это, в общем, получилось.
5168.48 5174.84 "Игорь Лабутин" В результате получается, что GRPC в .NET 5 близок к топу рейтинга, если не сказать является номером один в
5174.84 5188.44 "Анатолий Кулаков" нем. Вот еще очень важно упомянуть, что это не просто какой-то тест, который Microsoft написал сам для себя, это тест, которым уже много-много лет все самые большие фреймворки состязаются в перформансе.
5188.44 5195.36 "Анатолий Кулаков" То есть это довольно-таки показательный тест, который невозможно просто обвинить в какой-то предвзятости.
5195.36 5196.36 "Анатолий Жмур" Ну не совсем.
5196.36 5200.64 "Анатолий Кулаков" Анатолий, ну а в этом-то тесте что тебе не нравится?
5200.64 5204.32 "Анатолий Жмур" Ну главная его проблема в том, что клиент на рубль.
5204.32 5212.16 "Анатолий Жмур" То есть, ну в принципе это как бы выглядел идеальный тест с моей точки зрения.
5212.16 5217.36 "Анатолий Жмур" Мы берем одну машину, пусть у нас там localhost, чтобы с сеточкой не упираться в нее никогда.
5217.36 5222.56 "Анатолий Жмур" На ней мы запускаем клиент из ядер, написанный на одном языке, на одной технологии.
5222.56 5230.00 "Анатолий Жмур" И там выставляем, понятно, для клиента какую-то сверхконкуренцию больше, чем ядер, чтобы он там четко конкурировал.
5230.00 5232.72 "Анатолий Жмур" И ну видим 100% CPU лоаду.
5232.72 5234.56 "Анатолий Жмур" Ну условно, ну мы же там 90.
5234.56 5236.72 "Анатолий Жмур" И вот в этот момент мы снимаем RPC.
5236.72 5243.72 "Анатолий Жмур" И говорим, что вот мы заняли машину с таким-то количеством ядер, у нас запущен был клиент из ядер, вот такой-то получили RPC.
5243.72 5244.72 "Анатолий Жмур" Что происходит в этом тесте?
5244.72 5248.68 "Анатолий Жмур" В этом тесте у нас есть два докер-контрейнера, в которых есть свой лимитный CPU.
5248.68 5254.96 "Анатолий Жмур" Сервер меняется, то есть вот сервер там действительно 20 реализаций сервера на разных языках, а клиент всегда на Ruby.
5254.96 5258.60 "Анатолий Жмур" И Ruby это, конечно, совсем не про performance.
5258.60 5263.72 "Анатолий Жмур" Поэтому если попробовать это позапускать, вот мы ставим один CPU лимит серверу, один CPU клиенту.
5263.72 5264.84 "Анатолий Жмур" Видим один результат.
5264.84 5267.92 "Анатолий Жмур" Теперь один CPU серверу, два CPU клиенту.
5267.92 5269.92 "Анатолий Жмур" Раз, результат вырос почти в два раза.
5269.92 5271.96 "Анатолий Жмур" То есть сервер был недозагружен.
5271.96 5279.44 "Анатолий Жмур" И фактически вот до 4 CPU на клиенте для многих серверных решений идет линейная эскалируемость.
5279.44 5280.44 "Анатолий Жмур" А для некоторых не идет.
5280.44 5297.12 "Анатолий Жмур" И что бы это значило, то тоже достаточно сложно сказать, потому что они, ну, грубо говоря, клиент настолько плохой, что если отключить все ограничения на CPU и запустить на одной машине, то производительность будет определяться Ruby клиентом.
5297.12 5309.96 "Анатолий Жмур" Если иметь много ресурсов и менять серверные параметры, а клиентские сделать с достаточно большим запасом, то мы не видим линейной эскалируемости на сервере.
5309.96 5316.56 "Анатолий Жмур" То есть по идее вот у нас есть один CPU сервера, мы дали два CPU сервера, должно в два раза вырасти RPC.
5316.56 5323.88 "Анатолий Жмур" Ну, это все-таки высококонкурентный движок, то есть он должен хорошо скалироваться.
5323.88 5325.80 "Анатолий Жмур" Мы не видим этого для многих.
5325.80 5327.40 "Анатолий Жмур" Для каких-то видим, для каких-то нет.
5327.40 5334.20 "Анатолий Жмур" Это вот в официальной вики этого теста, там выложены результаты с августа, и вот там это видно просто, что линейно не растет.
5334.20 5336.20 "Анатолий Жмур" Даем больше ядер серверу, линейно не растет.
5336.20 5337.20 "Анатолий Жмур" Это конечно косяк.
5337.20 5346.20 "Анатолий Жмур" То есть по-хорошему надо было бы написать для каждого и серверного решения еще собственное клиентское решение.
5346.20 5347.20 "Анатолий Жмур" Но это сложно.
5347.20 5352.20 "Анатолий Жмур" То есть понятно, что сервер проще писать, потому что он там ничего не меряет, он просто предоставляет.
5352.20 5356.52 "Анатолий Жмур" А клиент же должен что-то мерить, какие-то там создавать для дот нета.
5356.52 5357.52 "Анатолий Жмур" Причем есть это.
5357.52 5366.64 "Анатолий Жмур" Вот это Джеймс Ньюзанкин, он писал, когда вот GFPC там в репозитории есть это для дот нета.
5366.64 5368.12 "Анатолий Жмур" Для Go оно тоже есть.
5368.12 5374.72 "Анатолий Жмур" Но оно там в гугловом репозитории, его там надо запускать, оно по-другому совершенно работает.
5374.72 5382.00 "Анатолий Жмур" То есть объективно сравнить их, вот они не лежат ни в одном репозитории, у них нет одного раннера, который там можно запустить легко и проверить.
5382.00 5389.56 "Анатолий Жмур" Поэтому объективно сравнить нужно предложить усилия к этому, чтобы запускать это, сравнивать яблоки с яблоками, считать.
5389.56 5390.56 "Анатолий Жмур" К сожалению.
5390.56 5397.16 "Анатолий Жмур" То есть вот ту работу большую, которую они сделали для такого сравнения с коробки, это очень большая работа на самом деле.
5397.16 5398.16 "Анатолий Жмур" Это нелегко.
5398.16 5405.56 "Анатолий Жмур" Но вот из-за того, что клиент плохой, это влияет, как мне кажется, и на серверные результаты.
5405.56 5412.80 "Анатолий Жмур" Потому что с моей точки зрения, там какой-то сверхперформанс в GFPC можно получить только агрегируя сетевые вызовы.
5412.80 5424.92 "Анатолий Жмур" То есть так, чтобы на клиентский вызов, не обязательно на клиентский, отправку клиентского реквеста не был один в один соответствующий сетевой вызов в движке GFPC.
5424.92 5427.08 "Анатолий Жмур" И для Дутнета сейчас именно так.
5427.08 5437.44 "Анатолий Жмур" То есть в Дутнете GFPC клиентский делает один в один флеш и фактически, флеш для стрима и фактически это превращается в сетевой вызов.
5437.44 5444.36 "Анатолий Жмур" Для Гоу в GFPC, для GFPC, реализованного на Гоу, это не так.
5444.36 5456.56 "Анатолий Жмур" Потому что там у них более сложный Event Loop и они заточены на блокирующие сокеты сразу же, поэтому они где-то ждут и отправляют несколько реквестов за раз.
5456.56 5461.24 "Анатолий Жмур" Ну принимают все движки несколько за раз, потому что там Event Loop обычно у всех встроены.
5461.24 5463.76 "Анатолий Жмур" Но вот отправляет несколько штук за раз.
5463.76 5466.16 "Анатолий Жмур" Гоу отправляет, а Дутнета не отправляет.
5466.16 5474.32 "Анатолий Жмур" И это возможно ограничивает его производительность, когда мы достигаем где-то десятков тысяч на ядро.
5474.32 5481.80 "Анатолий Жмур" Потому что в этой ситуации сетевые сисковы, они уже начинают съедать значительную долю ресурсов.
5481.80 5482.80 "Анатолий Кулаков" Спасибо, Толя.
5482.80 5487.08 "Анатолий Кулаков" Я напомню, что с нами был сеньор-техникал-архитект Анатолий Жмур.
5487.08 5488.08 "Анатолий Жмур" Спасибо.
5488.08 5489.08 "Анатолий Жмур" До свидания.
5489.08 5496.68 "Анатолий Кулаков" Ну что ж, несмотря на все это, в принципе, изменения были сделаны довольно-таки качественные, хорошие, отличные.
5496.68 5500.48 "Анатолий Кулаков" Наверняка это поможет на наших практических каких-то юзкейсах.
5500.48 5510.92 "Анатолий Кулаков" Может даже не настолько хорошо, как нам об этом заявляют авторы, но то громадную работу, которую они проделали, те замечательные технологии, которые они использовали, они точно не прошли просто так.
5510.92 5515.72 "Анатолий Кулаков" И наверняка дадут буст тем приложениям, которые используют JRPC.
5515.72 5522.68 "Игорь Лабутин" Да, и последний на сегодня момент, который мы хотели осветить, это немножко еще рассказать про диагностику.
5522.68 5546.20 "Игорь Лабутин" Как мы сказали, в DotNet 5 улучшилось все то, что поддержано в плане диагностики, кроссплатформенной трейсинг, диагностики, и в частности, в DotNet 5 добавилось очень много диагностик вокруг Веба, то есть вокруг HTTP, сокетов, DNS, TLS и всех остальных сущностей, которые вы можете придумать, если вы общаетесь по HTTP протоколам или каким-то другим образом через интернет.
5546.20 5576.80 "Игорь Лабутин" То есть теперь вы можете, так же, как вы могли и раньше собственно послушать ивенты через Event Listener или генерировать сами ивенты через Event Source, но теперь вам будут приходить куча новых ивентов, то есть всякие DNS lookup и про то, как у вас устанавливается TLS соединение, все, что делает HTTP Client и когда у вас там что куда шлется, какие респонсы куда шлются, в общем, прям можно очень детально рассматривать то, как происходит обмен данными по HTTP.
5576.80 5584.36 "Игорь Лабутин" Статья Стива Гордона, он, в общем, как обычно очень детально и подробно все рассмотрел, если вам интересны такие роды диагностики, посмотрите статью.
5584.36 5586.60 "Анатолий Кулаков" Ну, действительно, да, давайте, наверное, закругляться.
5586.60 5592.68 "Анатолий Кулаков" Это был выпуск полностью посвящен по DotNet 5, давай немножко пробежимся и кратко осветим те темы, которые мы сегодня затронули.
5592.68 5614.72 "Игорь Лабутин" Да, мы сегодня посмотрели самое главное, это историю выпусков C# 1 по 9, окунулись в 20-летнюю историю всего того, что было, кратенько посмотрели все, что происходило на DotNet Conf, какие нововведения были анонсированы, вы можете очень подробно все это посмотреть на сайтах Microsoft, есть и YouTube-трансляции, и статьи, которые это все поясняют.
5614.72 5619.48 "Анатолий Кулаков" И полный плейлист с DotNet Conf уже выложен, вы можете найти его в наших шоу-нотах.
5619.48 5644.12 "Игорь Лабутин" Да, посмотрели чуть более внимательно, что было в DotNet 5, ASP.NET Core 5 и F Core 5, с разной степенью подробностей, затронули два языка, это F# 5 и C# 9.0, обсудили, почему уже так стало быстро в gRPC, который все пытается стать самым лучшим, самым правильным протоколом для работы и взаимодействия микросервисов, но REST, мне кажется, пока все-таки немножко побеждает.
5644.12 5655.56 "Игорь Лабутин" И посмотрели, какие новые диагностики и информации телеметрии доступны в DotNet 5 вокруг HTTP, сокетов, DNS и прочего веб-взаимодействия.
5655.56 5667.64 "Анатолий Кулаков" Я напоминаю, что мы хотим в этом году последний выпуск записать более-менее новогодний, то есть не будем обсуждать новости, будем обсуждать нашу внутреннюю кухню, как мы работаем, как мы пишем подкасты, может быть что-то еще.
5667.64 5676.56 "Анатолий Кулаков" И напишите нам, пожалуйста, что бы вам было интересно послушать, что вам было бы интересно узнать о подкасте, может быть о том, как мы его готовим.
5676.56 5686.24 "Анатолий Кулаков" Присылайте ваши вопросы в виде комментариев на YouTube, можно воспользоваться нашей почтой radiosobaka@dotnet.ru или любыми другими способами, которые только сочтете удобными.
5686.24 5687.24 "Анатолий Кулаков" А на этом, наверное, все.
5687.24 5689.84 "Анатолий Кулаков" Да, с вами были Игорь Лабутин.
5689.84 5691.24 "Анатолий Кулаков" И Анатолий Кулаков.
5691.24 5692.24 "Анатолий Кулаков" Пока.
5692.24 5693.24 "Анатолий Кулаков" Пока.
5693.24 5695.48 "Анатолий Кулаков" Пользуйтесь самым лучшим и быстрым фреймворком на свете.
5695.48 5697.48 "Анатолий Жмур" Ну, не совсем.
5697.48 5703.48 None [музыка]
