0.00 14.72 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Радио.нет выпуск номер 93, и в эфире его постоянный ведущий Анатолий Кулаков
14.72 16.88 "Игорь Лабутин" и Игорь Лабутин, всем привет.
16.88 39.56 "Анатолий Кулаков" Большое спасибо за активную помощь товарищей Александр, Сергей, Владислав, Шевченко Антон, Гурий Самарин, Лазарев Илья, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков, Андрей Фазлеев и Басим Альджавахири.
39.56 50.44 "Анатолий Кулаков" Спасибо, друзья, что поддерживаете нас, нам всегда очень приятно, а также всем, кто нас шарит, рассказывает друзьям, репостит, комментирует и всячески другим способом поддерживает наш подкаст.
50.44 70.32 "Анатолий Кулаков" Так, пойдём разберёмся, у нас неделька прошла довольно скучновато, я бы сказал, потому что тем мало, анонсов вообще нет, поэтому сегодня поговорим на более-менее сравнительно абстрактные темы, структурные, архитектурные, да и вообще, что там у нас докопилось из такого глобального за все эти недельки.
70.32 103.12 "Игорь Лабутин" Ну неделька – это ты здорово сказал, мы писали прошлый выпуск более чем две недели назад уже, и всё равно, да, новостей практически нету, именно прям в формате новостей, есть только всякие помелочи вкратко о разном, поэтому мы начнём с довольно старой статьи, ну как старой, конец 23-го, начало 24-го года, приблизительно тех времён, хотел сказать лет, про то, что нам нужно как-то выбирать кроссплатформенные UI-фреймворки.
103.12 119.72 "Игорь Лабутин" В современном мире много кто хочет писать UI, ну или не то, что может быть хочет, но приходится, и если вы хотите это писать на дутнете, то вам нужно выбрать UI-фреймворк, если вы хотите это всё писать кроссплатформенно, то вам нужно выбрать кроссплатформенный UI-фреймворк на дутнете.
119.72 143.36 "Игорь Лабутин" И ещё недавно, ну как недавно, ладно, довольно давно у нас такие есть, но вопросы на тему того, какой выбрать, по-моему, не утихают особо до сих пор, и всё ещё актуальны, потому что их несколько, они все с одной стороны похожи, с другой стороны сильно различаются, и нужно понимать, в какой ситуации какой выбрать, если вообще какой-то один и универсальный.
143.36 144.96 "Игорь Лабутин" Вот давайте пытаться разобраться.
144.96 149.80 "Анатолий Кулаков" Ну, судя по тому, что вопросов меньше не становится, одного универсального до сих пор не нашли.
149.80 158.44 "Игорь Лабутин" Ну, во-первых, многие верят в разное, ну с точки зрения именно, не знаю, там, будущего, какие-то поддержки, я сейчас про это тоже немножко скажу.
158.44 162.00 "Игорь Лабутин" Вот, но, действительно, давайте начнём с простого.
162.00 172.40 "Игорь Лабутин" Во-первых, и все фреймворки, которые мы сегодня будем трогать, рассматривать, они XAML-based, то есть у нас были фреймворки типа WinForms, не знаю, какой ещё был пример.
172.40 173.40 "Игорь Лабутин" МФЦА?
173.40 190.64 "Игорь Лабутин" Ну, ты загнул там Qt, ну это ж как бы не .NET, погоди, я про .NET, которые не XAML-based, то есть там, где вы накидываете контролл на формочку, и оно как-то магически работает с кодом, с код-бихайндом или ещё как-то.
190.64 194.52 "Анатолий Кулаков" Да, наверное, кроме WinForms никаких распространённых больше и не было.
194.52 198.60 "Игорь Лабутин" Ну, пожалуй, нет, я, по крайней мере, на скидку, не вспомню.
198.60 210.16 "Игорь Лабутин" Но XAML, как только появился WPF, он стал прям такой, ну, если не революцией, то довольно свежим подходом, когда разметка отдельно, там, поведение отдельно, стили отдельно.
210.16 224.64 "Игорь Лабутин" То есть вы могли накидать свой какой-то UI дальше, стилями его как-то раскрасить, расцветить или поменять поведение на весь, какие-то там динамические штуки и так далее.
224.64 231.60 "Игорь Лабутин" И он был, ну, довольно продвинутым, ну, почему был, он остаётся довольно продвинутым методом писать UI.
231.60 237.64 "Игорь Лабутин" И XAML, он не единственный, не существует какого-то одного варианта XAML.
237.64 269.48 "Игорь Лабутин" Родился он в WPF, но дальше он немножко трансформировался в разные, так сказать, кусочки, в разные фреймворки, то есть в ветке, которая поддерживается самим Microsoft, то есть из WPF, там в Silverlight был свой вариант XAML, потом в UWP, и как-то это всё в WinUI, вот эту ветку, я не очень знаю, как там чё-куда трансформировалось, но это в некотором роде там одна ветка эволюции XAML.
269.48 273.28 "Игорь Лабутин" Дальше у нас есть фреймворк под названием Avalonia, о котором мы сегодня будем много упоминать.
273.28 283.36 "Игорь Лабутин" Он взял тоже XAML, но он не использует идеально тот же XAML, что и WPF, там свои приседания есть.
283.36 295.28 "Игорь Лабутин" И есть ещё отдельная ветка такого XAML-like интерфейса, это Xamarin.Forms и MAUI, там тоже XAML, но тоже немножко свой.
295.28 314.04 "Игорь Лабутин" Собственно, Avalonia, MAUI — это, наверное, пожалуй, сейчас основные фреймворки, которые на слуху, когда говорят о кроссплатформенном .NET UI, есть ещё UnoPlatform, который тоже довольно-таки старый, я бы сказал, он довольно давно существует, и тоже кроссплатформенный.
314.04 317.80 "Игорь Лабутин" Вот в основном статья оперирует этими тремя.
317.80 326.76 "Игорь Лабутин" Они все используют немножко разные диалекты XAML, то есть если вы напишите какой-то UI-чик на одно, вы не сможете его прям легко и просто без изменений перенести на другой.
326.76 329.56 "Игорь Лабутин" Но, тем не менее, это всё XAML.
329.56 348.28 "Игорь Лабутин" В статье написано, что если бы Microsoft сделала какой-то хороший типа Avalonia Style или что-то подобное, Flutter Style UI много лет назад, то, может быть, у нас бы не было такого большого разнообразия популярных UI-фреймворков, но, тем не менее, мы имеем, что имеем, и теперь их несколько и надо сравнивать.
348.28 367.08 "Игорь Лабутин" Давайте, ну, статья дальше говорит, давайте пробуем подумать, а что нам от фреймворка надо, точнее, чем они вообще отличаются на, так скажем, высоком уровне, то есть не вдаваясь вообще в какие-либо детали.
367.08 377.52 "Игорь Лабутин" Во-первых, у них есть нечто общее, ну, кроме того факта, что они используют хоть какой-никакой XAML, хоть и разный, они все плюс-минус работают на шестёрке или даже новее.
377.52 386.08 "Игорь Лабутин" Статья, в принципе, была после выхода восьмёрки, но что-то они только про шестёрку в основном упоминают.
386.08 393.56 "Игорь Лабутин" Используют одинаковый рантайм, плюс-минус и так далее, но дальше начинаются различия, и они довольно ключевые.
393.56 405.20 "Игорь Лабутин" Avalonia рисует всё сама, то есть Avalonia не использует никакие нативные контроллы, она всё, что нужно, всё, что вызвали в XAML-разметке, отрисовывает сама с нуля.
405.20 409.72 "Игорь Лабутин" .NET MAUI использует абсолютно противоположный подход.
409.72 423.40 "Игорь Лабутин" В .NET MAUI есть некоторый стандартизированный набор у каждого контролла или типа контролла, какие у него могут быть свойства, какие они должны иметь имена, какие у этого контролла могут быть ивенты.
423.40 433.40 "Игорь Лабутин" И на каждой из платформ, на которые поддерживается .NET MAUI, этот стандартный типа такой псевдоконтролл мапится на соответствующий нативный контролл.
433.40 447.04 "Игорь Лабутин" Естественно, это приводит к тому же ограничению, что вот этот стандартный набор пропертей, там, ивентов и чего-то ещё, он должен быть, ну как это, пересечением всех возможностей из всех платформ.
447.04 468.20 "Игорь Лабутин" И поэтому, если в этом наборе не будет какой-то кастомной функциональности, которая относится только к 1-2 платформам, или точнее, которая отсутствует хотя бы на одной платформе, за счёт этого он более ограниченный в каком-то смысле, но с другой стороны даёт возможность использовать все нативные контроллы.
468.20 482.80 "Игорь Лабутин" Есть одна платформа, которая использует такой некоторый гибридный подход, он использует несколько, так скажем, платформ специфичных примитивов для того, чтобы рисовать и собирать все контроллы остальные.
482.80 491.28 "Игорь Лабутин" Условно говоря, как я понимаю, там есть несколько базовых нативных контроллов, которые берутся из каждой платформы, а всё остальное строится на их основе.
491.28 496.92 "Игорь Лабутин" При этом можно заимбедить полностью любой платформ-специфик нативный контролл, тоже будет нормально.
496.92 510.56 "Игорь Лабутин" Ну и в принципе, в принципе, технически к WPF можно добавить, ой, к WPF, к набору рассматриваемых UI-фреймворков можно добавить WPF.
510.56 564.40 "Игорь Лабутин" Он, конечно, исторически никогда не был кроссплатформенным, но сейчас, когда появился продукт типа Avalon и XPF, которые позволяют взять и ваше WPF-приложение плюс-минус без изменений запустить на там Linux или Mac, ну по крайней мере пока говорим только про Desktop, не помню, насколько сейчас у XPF хорошо дела с мобильными, но это было в планах, не знаю, насколько они продвинулись, то технически WPF тоже может сделать кроссплатформенным, хотя это, конечно, ну такой, может быть, не самый легкий экспириенс с точки зрения того, что WPF-приложения обычно писались, ну довольно, ну поскольку они были Windows-only, там может быть довольно много всякого разного в Enapi, который не только относится к WPF и с ним уже будет гораздо более сложнее что-то сделать при переносе в кроссплатформенность.
564.40 599.12 "Игорь Лабутин" Надо сказать, что это не все фреймворки, тут есть еще в статье перечисления некоторых, которых я увидел впервые, со странными названиями, например, это.forms или eto.forms, я не знаю, но Asus GUI, впервые слышу, ну OpenSilver, как такой open-source-ный порт Silverlight-а, а также отдельно рассматривается .NET MAUI с Blazor-ом, hybrid-вариант, то есть когда вы берете MAUI-приложение, единственное, что оно делает, оно хостит специальный контролл, который внутри себя отображает Blazor-веб-приложение.
599.12 611.84 "Игорь Лабутин" И точно такой же есть .NET MAUI с Avalon-юй-хайбрид, когда соответственно MAUI хостит внутри Avalon-юй-вьюшку, то есть Avalon-юй-вьюшку, которая умеет отображать Avalon-юй.
611.84 618.24 "Игорь Лабутин" И таким образом вы можете в кроссплатформенном MAUI-приложении хостить кроссплатформенную Avalon-юй.
618.24 626.24 "Игорь Лабутин" Не очень знаю, зачем это вам, может быть, надо, но на самом деле, например, сейчас так подумал, для того, чтобы ваше .NET MAUI-приложение выглядело везде одинаково.
626.24 633.92 "Игорь Лабутин" Потому что Avalon-юй выглядит везде одинаково, непонятно, почему не взять Avalon-юй родную, но кому-то, может быть, надо.
633.92 640.40 "Игорь Лабутин" Дальше в статье идет довольно большой раздел про детальное сравнение этих самых фреймворков.
640.40 647.52 "Игорь Лабутин" Я не буду вдаваться во все-все-все-все-все варианты, все аспекты сравнения, пробегусь только по нескольким.
647.52 665.84 "Игорь Лабутин" Значит, если вам нужна то, что называется Pixel Perfect отображение, то есть вот как вам, не знаю, дизайнер нарисовал, вот ровно так же вы хотите выглядеть, причем на всех платформах и одинаково, то ваш единственный выбор – это Avalon-я, потому что остальные фреймворки используют нативный контролл, и это значит, что вы не получите одинакового UI на разных платформах.
665.84 685.24 "Игорь Лабутин" Дальше в XAML, как я говорил, XAML был хорош, и был и есть хорош тем, что они это называют, что он lookless, то есть вы отдельно можете задать, грубо говоря, структуру вашего UI, и потом отдельно стилями накрутить, как это будет выглядеть.
685.24 693.68 "Игорь Лабутин" И UNA, и Avalon-е это поддерживают нормально, Maui не поддерживает, поскольку он использует нативные контроллы, там вы особо их не покастомизируете.
693.68 713.72 "Игорь Лабутин" XAML Syntax, тут интересно, значит, UNA, он полностью совместим с текущим вариантом UWP и WinUI, по той простой причине, что когда вы компилите UNA фреймворк-приложение под винду, то он на самом деле использует внутри себя UWP и WinUI, и поэтому ему надо быть совместимым с ними.
713.72 716.24 "Игорь Лабутин" Ну это удобно, по крайней мере.
716.24 720.16 "Игорь Лабутин" Все остальные фреймворки немножко от этого отличаются.
720.16 735.80 "Игорь Лабутин" Avalon-я, по крайней мере, пытается быть совместимой с точки зрения Object Models, хотя, кстати, в статье отмечается, что ребята из Avalon-и пошли дальше, и они в XAML добавили некоторое количество отличий от WPF-а сознательно, чтобы его упростить.
735.80 745.48 "Игорь Лабутин" То есть там чуть более простая модель объектов, чуть более, ну такая, типа, дружественная, я бы сказал, с ней более удобно работать.
745.48 754.18 "Игорь Лабутин" Поэтому XAML от Avalon-и должен быть, по идее, более приятным для того, чтобы писать, ну, читать и понимать, что там происходит.
754.18 764.30 "Игорь Лабутин" Так, отдельный раздел — это Non-UI Features, то есть здесь как раз Avalon-и не очень впереди, потому что Avalon-и — это чистый UI-фреймворк.
764.30 779.30 "Игорь Лабутин" У всех остальных там есть всякие настройки, работа с файлами, аутентификация, permissions, если это касается там мобилок и этих самых, на магазине, например, я так понимаю, сейчас тоже есть вопросы там с выдачей permissions.
779.30 782.22 "Игорь Лабутин" В общем, они такие более универсальные фреймворки.
782.22 785.74 "Игорь Лабутин" Хотя, опять же, я думаю, что, может, Avalon-и тоже что-то добавится.
785.74 788.22 "Игорь Лабутин" Performance, понятное дело, важный момент.
788.22 801.78 "Игорь Лабутин" XAML сам по себе довольно, ну, требовательен к ресурсам, по крайней мере, во времена, когда он был в WPF-е, и каждый фреймворк подходит по-разному к проблеме того, что XAML, вообще говоря, довольно прожорливая штука, и с ней действительно надо что-то сделать.
801.78 826.38 "Игорь Лабутин" В UNO добавили возможность там lazy-лодингов и скомпилированных байдингов заранее, в MAUI просто используют нативные контроллы, там все просто, а в Avalon-е предкомпилируют XAML и компилируют, соответственно, байдинки тоже, то есть можно больше работать сделать в момент сборки приложения, чтобы потом во время рантайма не заниматься в рантайме там построением объектной модели XAML-а, и вот этим всем желательно все это иметь заранее.
826.38 854.46 "Игорь Лабутин" С саппортом, здесь вот интересно, несмотря на то, что MAUI, казалось бы, за MAUI стоит большое имя Microsoft, вот это все, считается, что саппорт гораздо лучше у UNO и у Avalon-и, но, опять же, по понятным причинам, компании гораздо меньше им, они заинтересованы в том, чтобы быстро отвечать, быстро реагировать, они этим занимаются, поэтому отлично быстро любые, ну не любые, но, по крайней мере, многие пожелания так или иначе будут быстро отвечены, обработаны и так далее.
854.46 866.02 "Игорь Лабутин" Avalon-е, кстати, тоже отличается, что у нее очень классный код с точки зрения читабельности, если вам нужно почитать, что там в UI-фреймворке происходит, то Avalon-е в этом смысле лучше всего.
866.02 897.26 "Игорь Лабутин" С экспириенсом разработчиков тоже такое, как бы, где как, где что, ну, MAUI, понятно, хорошо, поскольку уж в микрософтские тулзы оно интегрировано, но у MAUI есть большая проблема в том, что даже если вы там отлично интегрированы в тул, и вы на вашей платформе разработчиков все проверили и так далее, вам нужно, спасибо Native Control, запускать MAUI-приложение обязательно на всех остальных платформах и проверять, как будет выглядеть.
897.26 910.98 "Игорь Лабутин" Очень много отзывов в интернете про то, что написал приложение там для Android, условно говоря, перенес на iOS, а там все по-другому выглядит, это ладно, это ожидаемо, оно и работает по-другому, в смысле, что верстка вообще едет куда-то не туда и так далее.
910.98 921.38 "Игорь Лабутин" Avalon-е в этом смысле получше, ну, просто потому что она сама все рисует и там есть все плагины для всех основных IDE-ш, все хорошо работает.
921.38 947.70 "Игорь Лабутин" В итоге, статья сходится примерно к следующей мысли, если вам нужен десктоп, ну, если вам нужен только Windows, хотя исходная позиция была про кросс-платформность, то, конечно, берите WPF, ну, как бы, что бы не взять, но в целом, если вам нужен десктоп, берите Avalon-е, для macOS, Linux, Windows можно легко брать Avalon-е.
947.70 958.54 "Игорь Лабутин" Если вам нужен в основном мобилки или какой-нибудь там VBS-ом или еще что-то, то, может быть, лучшим решением будет Uno.
958.54 980.82 "Игорь Лабутин" И, наконец, Maui, как сказано в статье, может быть полезен для маленьких приложений без какого-либо сложенного UI, но граница того, когда приложение становится из маленького уже средним, наступает довольно быстро, и непонятно, есть ли смысл вообще брать Maui и для каких целей.
980.82 988.78 "Игорь Лабутин" Может быть, вот для кейса типа мы в нем будем хостить Blazor-е Avalon-е, но тоже, не знаю, для меня этот use-кейс пока не очень понятен.
988.78 997.26 "Игорь Лабутин" В общем, если почитать статью, получается, что на момент начала 2024 года Avalon-е лучший выбор для кросс-платформы.
997.26 1013.50 "Игорь Лабутин" Да, у нее будет недостаток в виде того, что это не native look and feel, в том плане, что она сама все рисует, не использует нативные контроллы, но зато вы плюс-минус получаете гарантию, что оно будет работать и выглядеть одинаково на всех платформах.
1013.50 1014.50 "Игорь Лабутин" Такие дела.
1014.50 1019.02 "Игорь Лабутин" Maui пока с непонятными перспективами, назовем так.
1019.02 1031.46 "Анатолий Кулаков" Ну да, если Microsoft раньше кричал про Maui просто на каждом ходу, то сейчас он просто как-то мучит под нее и непонятные ее перспективы, ее текущий статус, совсем ничего.
1031.46 1050.98 "Игорь Лабутин" Ну вот я там в линке к подкасту добавил еще один линк на репозиторий Maui, где есть дискашен, ох, по-моему, от сентября что ли 23 года, ноября 23 года, в разделе дискашенов про то, что как бы, блин, все плохо, вот.
1050.98 1098.50 "Игорь Лабутин" И надо сказать, я смотрел на него давно, ну и посмотрел вот сейчас, когда готовился, там очень мало, или я вообще не нашел ответов от ребят из Microsoft, ну то есть там посыл Vida, блин, ничего не работает, то есть наверно там конечно палку перегнули немножко с вами, ничего не работает, что-то там работает и действительно какие-то баги фиксятся, но в целом там действительно обозначено некоторое количество проблем, которые реально есть, ну по крайней мере, про которые я много где читал, сам не пользовался, но читал, и что-то как-то реакции какой-то, знаешь, там типа Samari Vida, там да, мы, значит, прочитали, вот смотрите, на это мы можем ответить, вот так, на это так, а тут согласно косяк будем исправлять.
1098.50 1100.86 "Игорь Лабутин" Ну нет, ничего такого нет нигде, не нашел.
1100.86 1118.22 "Анатолий Кулаков" Ну и вообще какая-то странная ситуация, потому что был хоть до беды какой-нибудь Cosamarin.Forms, который работал, почему бы его просто было не выкинуть какой-нибудь, он и так был open-source, в общем, непонятно, потому что у Microsoft обычно был какой-то UI-фреймворк, на который все ориентировались, которые все юзали, и обычно эти UI-фреймворки были прекрасны.
1118.22 1122.40 "Анатолий Кулаков" Возьми хоть тот же самый WinForms, хоть .dpf, ну они великолепны.
1122.40 1131.58 "Анатолий Кулаков" И у Microsoft это получалось хорошо, и сейчас просто так забрасывать на полпути Mavi тоже выглядит как какой-то странной стратегией.
1131.58 1134.54 "Анатолий Кулаков" В общем, что-то там неладное в нашем государстве.
1134.54 1149.38 "Игорь Лабутин" А причем непонятно, является ли текущее состояние, ну сейчас, можно ли описать текущее состояние, как забрасывают, может быть с их точки зрения там ведется какая-то активная работа, просто мы этого не знаем, не видим, или считаем, что они ничего не делают.
1149.38 1154.98 "Анатолий Кулаков" Ну смотри, там последний год у нас не было нормальных новостей про этот фреймворк, какая активная работа там может есть.
1154.98 1155.98 "Анатолий Кулаков" Как перфоманс.
1155.98 1166.58 "Анатолий Кулаков" Перфоманс, да, импрувманс, особенно на фоне того, сколько жалоб поступает на этот фреймворк, они там должны просто из всех пушек стрелять и кричать, да нет, мы все правим в ту же секунду, да нет, все молчат.
1166.58 1178.38 "Игорь Лабутин" Ну в общем, странная ситуация, посмотрим, куда это, ну я не знаю, хочется верить, что к девятому дотнету там наступит какая-то определенность, хотя непонятно, какая определенность может наступить.
1178.38 1182.70 "Игорь Лабутин" Будем наблюдать, мониторить и рассказывать вам, что происходит.
1182.70 1183.70 "Игорь Лабутин" А пока пойдем тогда дальше.
1183.70 1184.70 "Анатолий Кулаков" Да, пойдем.
1184.70 1213.82 "Анатолий Кулаков" В принципе, не все места у Майкрософта такие заскорудлые, есть в принципе эти вещи, которые развиваются, двигаются, и в частности Майкрософт очень активно вытачивает свои докер-контейнеры со всех сторон, договаривается с Ubuntu, оптимизирует по размерам, проверяет перфоманс и вот добрались до лишнего отчета по тому, что же они там делают с секьюрити, опять же, немаловажный аспект, поэтому давай же теперь разберемся, что у нас там в DotNet 8 с безопасностью в контейнерах.
1213.82 1226.18 "Анатолий Кулаков" Как утверждают сами Майкрософтовцы, они прям в DotNet 8 там прям взаимпровели секьюрити, как-никак, но на самом деле все не так страшно, может быть не так жестко, будем по порядку разбираться.
1226.18 1240.38 "Анатолий Кулаков" Прежде всего Майкрософт заявляет, что они в DotNet 8 нацелились прямо на поддержку самого жесткого уровня у Kubernetes, который запускает эти контейнеры, на уровень Restricted.
1240.38 1252.82 "Анатолий Кулаков" Так, для тех, кто не знает, у Kubernetes есть секьюрити-стандарты, их три уровня, это привилегированный, это совсем без всяких ограничений, можете делать все, что угодно, запускать как угодно, выходить куда хотите.
1252.82 1263.74 "Анатолий Кулаков" Есть базовый, это с такими минимальными ограничениями, он подходит для тех приложений, для тех контейнеров, которые хотят перенести под Kubernetes, но не готовы там ограничить их по рукам и ногам.
1263.74 1268.86 "Анатолий Кулаков" И самый страшный, самый сильно ограниченный – это Restricted.
1268.86 1278.34 "Анатолий Кулаков" Этот уровень как раз пропагандируется для недоверенных контейнеров, для самых жестких ограничений, из которого просто практически ничего нельзя сделать.
1278.34 1288.54 "Анатолий Кулаков" Вот, и Майкрософт говорит, что в некоторых сценариях они прямо нацелены на самый Restricted уровень, чтобы сделать вам Full Security и все такое.
1288.54 1290.96 "Анатолий Кулаков" Прежде всего, отчего мы спасаемся?
1290.96 1294.54 "Анатолий Кулаков" У контейнера есть два основных вектора атаки.
1294.54 1317.10 "Анатолий Кулаков" Это контейнер break, он же контейнер skip, то есть это когда код, который исполняется внутри контейнера, может из контейнера сбежать, потому что несмотря на все стороны докера, контейнеры не являются настоящей системой виртуализации или глубокого изолирования или чего-то еще.
1317.10 1330.86 "Анатолий Кулаков" Поэтому он по дефолту, по дефолту настроен докер, так что, конечно, все контейнеры ведут себя как некая изолированная среда, но все-таки иногда приложения из него сбегают.
1330.86 1333.22 "Анатолий Кулаков" В частности, из-за каких-то багов.
1333.22 1342.30 "Анатолий Кулаков" И второй вектор атаки, который страшен внутри контейнеров, это Remote Code Execution, или в нашем же случае On Arbitrary Code Execution.
1342.30 1347.62 "Анатолий Кулаков" Это не то, чтобы специфическая атака для контейнера, это в любом приложении можно такую же штуку сделать.
1347.62 1360.10 "Анатолий Кулаков" Это какой-нибудь Stack Overflow или Buffer Overflow, в общем, когда вы можете выполнить произвольный код в каком-то приложении, и это приложение в результате выполнения вашего кода делает те операции, на которые оно не было рассчитано.
1360.10 1371.06 "Анатолий Кулаков" То есть вы можете заставить, например, какой-нибудь процесс показать вам список файлов, несмотря на то, что отдельного endpoint для показа списка файлов у него нет.
1371.06 1376.98 "Анатолий Кулаков" С помощью того, что вы запишите правильные инструкции в правильный буфер памяти, переполните его, допустим.
1376.98 1384.06 "Анатолий Кулаков" Это тоже довольно распространенная уязвимость, как я уже сказал, она встречается не только в контейнерах, и не сколько в контейнерах, сколько в обычных приложениях.
1384.06 1395.14 "Анатолий Кулаков" Ну и чтобы вы не думали, что это какая-то фиктивная, несуществимые какие-то векторы, есть много примеров, когда докер контейнеры взламывали.
1395.14 1399.90 "Анатолий Кулаков" То есть код, который выполнялся внутри контейнера, выходил наружу, в частности, в 2019 году.
1399.90 1409.78 "Анатолий Кулаков" Есть хорошая CSV, которую можно почитать, как раз описывающая то, как сквозь, из контейнера сбежал пользователь.
1409.78 1425.22 "Анатолий Кулаков" И основной вывод из этой CSV, который можно сделать, это в том, что разработчики и администраторы слишком сильно доверяют дефолтным настройкам, под которыми запускаются там всякие докеры, кубернетесы и прочее.
1425.22 1426.22 "Анатолий Кулаков" В общем, так делать не нужно.
1426.22 1437.22 "Анатолий Кулаков" И самое главное, что вы можете сделать, это прежде всего не использовать привилегированного пользователя, то есть не использовать рута внутри контейнера, надеясь на то, что рута оттуда никогда не сбежит.
1437.22 1450.46 "Анатолий Кулаков" На самом деле, если вы используете рута внутри контейнера, и есть какие-то баги в операционной системе или где-нибудь в слое изоляции, то рута оттуда сбегает и получает, соответственно, рута на хостовой машине, на главной.
1450.46 1455.62 "Анатолий Кулаков" А рута на хостовой машине может сделать абсолютно все, что угодно.
1455.62 1464.38 "Анатолий Кулаков" Поэтому базовые рекомендации, с помощью которых вы можете в общем обезопасить свои контейнеры, это прежде всего держать ваши зависимости обновленными всегда.
1464.38 1470.66 "Анатолий Кулаков" Это касается как хостовой системы, где запускается сам контейнер, так и гостевой системы, под которым лежит ваше приложение.
1470.66 1477.74 "Анатолий Кулаков" В общем, всегда старайтесь обновляться, всегда старайтесь держать последних версий, особенно если мы говорим о security fix-ах каких-нибудь.
1477.74 1486.46 "Анатолий Кулаков" Ну и второе базовое утверждение, на котором стоит абсолютно все, это постарайтесь не использовать рутового пользователя даже внутри контейнера.
1486.46 1494.02 "Анатолий Кулаков" От неизвестных атак, например, как сбегание из контейнера или, может быть, даже remote code execution тоже это может помочь.
1494.02 1495.02 "Анатолий Кулаков" Почему?
1495.02 1496.66 "Анатолий Кулаков" От неизвестных атак, на которых еще нет патча.
1496.66 1498.38 "Анатолий Кулаков" Это самая лучшая защита.
1498.38 1507.06 "Анатолий Кулаков" Даже если какой-то ограниченный пользователь избежит в хостовую систему, то он там практически ничего не сможет сделать, потому что прав, скорее всего, у него там быть не должно.
1507.06 1520.78 "Анатолий Кулаков" Теперь, после того, как мы узнали, почему важно все-таки не держать рута внутри контейнера, давайте посмотрим, а как же обстоят дела среди базовых имиджей.
1520.78 1543.14 "Анатолий Кулаков" Если вы, допустим, возьмете докер имидж любой популярной операционной системы, там докер Alpine, Debian, Ubuntu и скажете ему там "docker run" и вызовете команду "whoamic", которая как раз и рассказывает, под каким пользователем запущен сейчас образ, то и Alpine, и Debian, и Ubuntu вам по дефолту выдадут рут.
1543.14 1560.58 "Анатолий Кулаков" Более того, даже если вы возьмете последний хваленый Microsoft 8 Runtime, который рассказывает, как он там много security, всяких импрувментов сделал для докер-контейнеров и у него вы вызовете "whoamic", то он тоже вам скажет, что он запускается по дефолту под рутом.
1560.58 1575.32 "Анатолий Кулаков" И кажется странным, что все рекомендуют, специалисты, что под рутом никогда не запускайтесь, это плохо, а вот все базовые имиджи и операционных систем, и дотунеты в частности, и практически всех языков программирований запускаются по дефолту под рутом.
1575.32 1576.32 "Анатолий Кулаков" Почему?
1576.32 1601.80 "Анатолий Кулаков" Дело в том, что в таких образах общего пользования, которых невозможно предсказать никакое приложение там будет выполняться, никакой код запускаться, вообще для чего он будет использоваться, то есть такие общие употребительные имиджи, такие как операционная система, просто-напросто, в общем, там удобство использования намного выше, чем безопасность.
1601.80 1622.22 "Анатолий Кулаков" То есть, если вы будете дефолтный образ делать под рутом, то на нем, соответственно, пользователь сможет настроить абсолютно все, что захочет, и не будет задумываться о тех глупостях, какие там нужно группы установить, какие security permissions поправить, прежде чем ему хотя бы банальный пакет запустить или какое-нибудь приложение там заинсталлировать.
1622.22 1625.12 "Анатолий Кулаков" Поэтому по дефолту там стоит всегда рут.
1625.12 1628.84 "Анатолий Кулаков" Это не самый безопасный путь, но зато самый удобный.
1628.84 1638.28 "Анатолий Кулаков" И для высокоуровневых, то есть таких низкоуровневых имиджей, как операционные системы или языковые рантаймы, это считается нормальным подходом.
1638.28 1648.12 "Анатолий Кулаков" Но на плечах конкретного пользователя, в частности разработчика, лежит обязанность обеспечить секьюрность уже в наследниках.
1648.12 1660.96 "Анатолий Кулаков" То есть в высокоуровневых имиджах, в которых вы будете засовывать свое приложение, вот там вы обязаны позаботиться о том, чтобы рутового пользователя в конце концов в итоге вашем докер имидже его не было.
1660.96 1674.04 "Анатолий Кулаков" Ну или взять, например, числд имидж, то есть числд имиджи используют абсолютно другой подход, они по умолчанию как раз используют нерутовых пользователей, поэтому к ним это утверждение неприменимо.
1674.04 1677.68 "Анатолий Кулаков" Про числды мы уже говорили в наших выпусках, тут повторяться не буду.
1677.68 1688.80 "Анатолий Кулаков" Теперь давайте посмотрим, а как же в .NET 8 все-таки улучшили вот эту секьюрность, и они на каждом углу кричат, что мы сделали нон-рута и все такое, где же они сделали его-то?
1688.80 1693.56 "Анатолий Кулаков" Сделали они его не в базовом образе, а в дефолте для .NET паблиша.
1693.56 1711.92 "Анатолий Кулаков" То есть теперь, когда вы вызываете команду .NET паблиш и говорите ей, сделай-ка мне паблиш контейнера, то после того, как вы вот такой контейнер сгенерируете свое приложение, вот в этом контейнере уже по дефолту никакого рута запускаться не будет, весь ваш контейнер будет работать от специального пользователя, который называется ап.
1711.92 1721.76 "Анатолий Кулаков" И если вы даже посмотрите на, например, айдишник этого пользователя, то айдишник у него будет 1654.
1721.76 1725.76 "Анатолий Кулаков" Это новое магическое число, которое есть во всех контейнерах от Микрософта.
1725.76 1732.24 "Анатолий Кулаков" Взялось оно, мы уже рассказывали, я кратко напомню, потому что очень забавная история.
1732.24 1743.56 "Анатолий Кулаков" Прежде всего айдишники всех пользователей должны быть больше тысячи, потому что все, что до тысячи зарезервировано операционной системой для всяких системных пользователей, они нужны для выполнения ее служб.
1743.56 1747.88 "Анатолий Кулаков" Вот, теперь какой же номер больше тысячи нужно выбрать?
1747.88 1758.44 "Анатолий Кулаков" Ну, конечно же, 1654, потому что это тысяча и плюс сумма всех ASCII кодов, из которых состоит слово .NET.
1758.44 1762.24 "Анатолий Кулаков" В общем, так и получается у нас 654.
1762.24 1778.28 "Анатолий Кулаков" Также для того, чтобы вот этот айдишник пользователя использовать в различных командах для настройки там текущего пользователя, это часто нужно для выставления там привилегий, для выдачи правовладения и так далее, часто используют айдишник именно пользователя.
1778.28 1787.56 "Анатолий Кулаков" В общем, чтобы этот дурацкий номер не запоминать, у всех контейнеров Микрософта есть переменная среды окружения, которая называется App, подчеркиваю, UID.
1787.56 1792.52 "Анатолий Кулаков" Вот, благодаря этой переменной окружении вы можете прям не знать номер айдишника, а просто везде ее вязать.
1792.52 1804.16 "Анатолий Кулаков" Так, если мы говорим, что мы не пользуемся командой .NET Publish, которая нам делает безопасные контейнеры теперь по дефолту, раньше это было не так, а используем докерфайлы.
1804.16 1818.52 "Анатолий Кулаков" Это самый, наверное, старый и самый проверенный способ, потому что .NET Publish, который строит контейнеры, появился довольно-таки недавно, а .NET контейнеры из докерфайла собирались со времен наших дедов.
1818.52 1824.16 "Анатолий Кулаков" Поэтому в большинстве случаев вы столкнетесь с докерфайлом, из которого собирается все остальное.
1824.16 1836.48 "Анатолий Кулаков" И, в принципе, там тоже не то чтобы сильно сложнее, смысл весь тот же самый, но просто нужно вам добавить в ваш докерфайл еще одну команду, команда называется User.
1836.48 1844.60 "Анатолий Кулаков" Вы указываете User $appuid, то есть используйте того пользователя, которого нужно взять из переменки, которую мы обсуждали выше.
1844.60 1856.28 "Анатолий Кулаков" И это переключает автоматически пользователя по умолчанию для вашего контейнера в специального пользователя, который называется App, который абсолютно никак не связан с рутом и имеет минимум привилегий.
1856.28 1866.28 "Анатолий Кулаков" И часто разработчики создают своих собственных пользователей, не опираясь на пользователя App, который для них создает Microsoft.
1866.28 1886.20 "Анатолий Кулаков" И, в принципе, здесь нет вообще никакой разницы, абсолютно вы можете заюзать своего пользователя, назвать его каким-то именем, допустим, программы, под которой запускается, или каким-то другим способом, или заиспользовать микрософтовского, обе опции равноценны и между ними нет чего-то более предпочтительного.
1886.20 1887.80 "Анатолий Кулаков" Поэтому как вам больше нравится, так и вязайте.
1887.80 1892.68 "Анатолий Кулаков" Итак, немножко подробнее, как я уже говорил про числт имиджи.
1892.68 1904.72 "Анатолий Кулаков" Это такие специальные образы, из которых урезано очень много всего из операционной системы для того, чтобы у них был как можно более меньший вектор атаки.
1904.72 1912.36 "Анатолий Кулаков" То есть у них очень урезаны какие-то базовые системные пакеты, которые могли содержать много багов, допустим.
1912.36 1919.64 "Анатолий Кулаков" Ну, также у них довольно компактный размер, поэтому если вы гонитесь за размером, то тоже можете посмотреть на числт.
1919.64 1928.00 "Анатолий Кулаков" Но нас сейчас в нашей конкретной теме интересует то, что они по умолчанию законфигурированы как нон-рут образы.
1928.00 1939.68 "Анатолий Кулаков" Поэтому вам не нужно их никак конфигурировать, если вы в своих проектах используете базовую операционную систему как числт, то там уже все установлено, там не нужно вызывать, ничего не нужно ставить, там уже все будет в виде апп-ьюзера.
1939.68 1944.76 "Анатолий Кулаков" Теперь рассмотрим сам кубернетес.
1944.76 1967.56 "Анатолий Кулаков" У кубернетеса есть специальный механизм, который называется run as non-root, это такая настройка, которая проверяет, если она установлена true, то она обязательно проверяет, убеждается, что контейнер, который она пытается запустить, собран не под рутовым пользователем, то есть что у него не выставлен рутовый пользователь как пользователь по умолчанию.
1967.56 1974.76 "Анатолий Кулаков" Если это не так, то, соответственно, кубернетес не сможет загрузить ваш образ и не сможет его запустить.
1974.76 1985.04 "Анатолий Кулаков" Проверяет она очень просто, если юзер-айдишник больше нуля, значит это не рут, если ноль, то это как раз рутовый айдишник, которого допускать нельзя.
1985.04 1990.76 "Анатолий Кулаков" Иногда бывают ситуации, когда вам нужно совершенно противоположное, то есть вы хотите, чтобы ваш контейнер был под рутом.
1990.76 1999.40 "Анатолий Кулаков" Как я уже говорил, в частности юзабилити такое часто встречается, но в ваших приложениях вы не должны такого хотеть.
1999.40 2003.36 "Анатолий Кулаков" Но если вам вдруг все-таки нужно, то есть несколько способов это добиться.
2003.36 2013.36 "Анатолий Кулаков" Во-первых, у докера экзека есть специальный параметр -u, которым можете указать пользователя, в частности если укажете -u root, то он выполнится, контейнер сам запустится от рута.
2013.36 2019.96 "Анатолий Кулаков" К счастью, у kubectl.exe нет аргумента -u.
2019.96 2036.42 "Анатолий Кулаков" Container run также точно имеет -u, юзер, аргументом, и если вы вдруг билдите имиджи с помощью команды .net publish -publish container, то вы можете указать специальный параметр, который называется container user.
2036.42 2040.96 "Анатолий Кулаков" Если вы передадите туда root, соответственно контейнер будет запускаться тоже у вас под рутом.
2040.96 2048.16 "Анатолий Кулаков" Оба пользователя, и root, и app, должны присутствовать в системе, чтобы вы их заюзали, естественно.
2048.16 2056.60 "Анатолий Кулаков" И оба пользователя также точно встроены во все базовые образы .net, Microsoft уже об этом позаботился, как бы есть и тот, и тот.
2056.60 2061.56 "Анатолий Кулаков" Вот такие нововведения у нас в восьмых контейнерах.
2061.56 2075.60 "Анатолий Кулаков" Здесь можно сделать самый главный вывод, что нерутовые пользователи - это, наверное, самое важное изменение, которое вы можете сделать для того, чтобы повысить безопасность ваших контейнеров.
2075.60 2090.08 "Анатолий Кулаков" Поэтому если ваши контейнеры все еще запускаются под рутами, то благодаря минимальным телодвижениям вы можете сделать их мегабезопасными и тем более к тем ясимостям, которых мы еще даже не знаем, на которых даже еще нет патчей.
2090.08 2095.72 "Анатолий Кулаков" Поэтому не ленитесь, следите за обновлениями ваших контейнеров и делайте нерутовых пользователей.
2095.72 2105.24 "Игорь Лабутин" А еще я заметил, что по-моему Ричард Лендер сейчас практически единственные статьи, которые он пишет, это как раз про контейнеры.
2105.24 2114.12 "Игорь Лабутин" Он получил их случайно или он действительно как-то так озаботился темой контейнеров, но прямо от него, именно от него почему-то все время эти статьи.
2114.12 2128.92 "Игорь Лабутин" Но действительно тема важная, Майкрософт много чего делает в этом направлении, чтобы получить маленькие удобные безопасные контейнеры, так что следим, смотрим и докладываем по мере новостей, по мере появления новостей.
2128.92 2129.92 "Игорь Лабутин" Хотя бы тут какие-то новости.
2129.92 2134.76 "Анатолий Кулаков" Да-да, хоть где-то что-то шевелится и двигается, это приятно.
2134.76 2137.80 "Игорь Лабутин" Смотри, оно шевелится, двигается, даже в восьмерке уже было сделано.
2137.80 2138.80 "Игорь Лабутин" Это так пока.
2138.80 2149.04 "Игорь Лабутин" Такое ощущение, что это, кстати, тоже, когда я видел эту статью, подумал, что ну как бы настолько нечего писать в девятке, что приходится еще раз описывать что-нибудь в восьмерке.
2149.04 2151.64 "Игорь Лабутин" Прям как-то грустненько.
2151.64 2152.64 "Игорь Лабутин" Грустненько.
2152.64 2156.52 "Игорь Лабутин" Где динамизм жизни, вот это все.
2156.52 2157.52 "Игорь Лабутин" Вот.
2157.52 2163.52 "Игорь Лабутин" Но надеемся и верим, что все вернется и у нас будет много новых клевых превью с кучей прикольных фич.
2163.52 2168.68 "Игорь Лабутин" А пока пойдем вспомним еще одну относительно старенькую штуку.
2168.68 2170.36 "Игорь Лабутин" Это ченнелы.
2170.36 2176.88 "Игорь Лабутин" Попалась мне статья про то, как сделать легковесный in-memory message bus на ченнелах.
2176.88 2181.80 "Анатолий Кулаков" Слушай, ну старенькую не старенькую, но про нее мало кто знает, потому что она мало юзается.
2181.80 2184.52 "Анатолий Кулаков" Можно в конце рассказать вообще про что это.
2184.52 2201.24 "Игорь Лабутин" Ченнелы действительно юзаются не так много, я их пользовал один или два раза и в каких-то таких условно pet-like проектах, в продюсерах у нас чуть нигде нет, но нет под них задачи никакой в обычном бэкэнде, где прилетают запросы и ты отвечаешь на них.
2201.24 2203.84 "Игорь Лабутин" Но тем не менее, да, что ж такое ченнелы.
2203.84 2216.56 "Игорь Лабутин" Ченнелы это некоторая абстракция, которая соответственно предназначена для того, чтобы быстро и эффективно обеспечить работу для паттерна продюсер-консюмер.
2216.56 2240.52 "Игорь Лабутин" То есть если у вас есть некоторое количество продюсеров, один или много, и есть некоторое количество консюмеров опять же, один или много, то вы можете, и вам нужно как-то передавать сообщения между ними, вы можете конечно взять стандартный, не знаю, класс Q, да, что там, System Collection Generic Q, есть же у нас такой, тысячу лет не использовал, наверное есть.
2240.52 2241.52 "Игорь Лабутин" Должно быть.
2241.52 2242.52 "Игорь Лабутин" Да, должно быть.
2242.52 2253.92 "Игорь Лабутин" Или по крайней мере DQ, типа Double Ended Q, какой-то из них, по-моему, какого-то одного не было, какой-то был, что-то я уже не помню, двадцать лет прошло, я все не знаю, есть ли Q в датнете, но неважно.
2253.92 2271.92 "Игорь Лабутин" Короче, взять обычную очередь и говорить In Q, да, а потом говорить DQ, все здорово, все хорошо, но, во-первых, вы это можете делать так только по одному элементу, а во-вторых, это будет не очень эффективно, там блокировки, вот это все, короче, будет не очень здорово.
2271.92 2310.40 "Игорь Лабутин" И когда для датнета, на самом деле, внутри, для спиноткора, я подозреваю, понадобился какой-то очень быстрый механизм вот этого, продюсер-консюмера, общаться, то родились ченнелы, не вспомню даже уж в каком датнете это, шестерки-то уж точно, может даже раньше, боюсь наврать, не буду, и смысл в том, что у вас есть довольно простой интерфейс, соответственно, у вас есть, во-первых, вы должны создать явно ченнел, указать ему емкость, то есть то, сколько максимум элементов в него может впихнуться, после которых паблишинг в него заблокируется, ну или будет ждать, по крайней мере.
2310.40 2321.96 "Игорь Лабутин" Либо вы можете создать так называемый Unbounded channel, это значит, что, ну по большому счету, количество элементов не ограничено, понятно, что оно ограничено памятью, но тем не менее.
2321.96 2343.16 "Игорь Лабутин" И дальше у вас после этого есть по сути два, вы из этого ченнела можете экспозить две абстракции, так это Writer и Reader, Writer, это, соответственно, пишущая часть, его должны использовать продюсеры, а Reader, это, соответственно, читающая часть, его должен использовать консумер.
2343.16 2370.48 "Игорь Лабутин" У Writer есть, соответственно, метод writeAsync, у Reader есть метод, ну там есть разные вариации, обычно используют какой-нибудь readAllAsync, дополненный современной конструкции waitForEach, то есть это штука, которая будет вам асинхронно потихонечку доставать оттуда все, что туда положили с учетом await, без блокировок, ну короче, все как мы любим, с async/await правильно.
2370.48 2387.52 "Игорь Лабутин" И делать это все очень быстро, если продюсер и консумер не пересекаются внутри, то есть если они не конфликтуют за какую-то одну ячейку внутренней структуры хранения, то там блокировка вообще минимальна, если они в принципе есть.
2387.52 2406.96 "Игорь Лабутин" Ну понятно, что если элементов нет, и вы один ждете, то Reader, конечно же, заблокируется, будет ждать, и тогда при записи будет некоторая синхронизация, но она минимальна, и если у вас Reader уже заблокирован, то ничего страшного в этом нет.
2406.96 2428.68 "Игорь Лабутин" Так, вообще, очень высокопроизводительная штука, работает там очень оптимизированно внутри, спаны там, вот это все можно попытаться с этим все еще больше ускорить, и в общем такая удобная абстракция для однонаправленной передачи данных из одного места в другое, внутри одного процесса строго.
2428.68 2434.28 "Игорь Лабутин" И вот на основе этой штуки предлагается сделать MessageBus.
2434.28 2464.00 "Игорь Лабутин" Не то чтобы тут создали большой MessageBus, вся статья заключается в том, что мы создаем класс, из которого вытарчиваем наружу Writer и Reader, те самые из ченнела, и говорим, что ну окей, паблиш теперь будет делать Writer.WriteAsync, а там, где мы хотим кончимить, мы будем делать WaitForEach из Reader.ReadAllAsync, и вот вам, по сути, MessageBus внутри.
2464.00 2513.76 "Игорь Лабутин" Никакой маршрутизации, никакой там чего-либо сложного нету, но тем не менее, для каких-нибудь простых случаев типа какого-нибудь там модульного монолита, в котором вам хочется развязать кусочки монолита между собой каким-нибудь асинхронным общением, но при этом не хочется тащить какой-нибудь внешний большой тяжелый MessageBus, то это в принципе такой стартап-вариант, на котором вы можете быстренько написать, протестировать, как там вы что хотите делать, и даже оно может жить какое-то время впроде, и только когда вы начнете распиливать ваш монолит в микросервис и выделяете, вам потребуется уже полноценный большой MessageBus или что-нибудь, тогда замените уже на что-нибудь нормальное, внепроцессное, отдельным продуктом стоящее.
2513.76 2553.96 "Игорь Лабутин" И что хорошо в статье, это прямо честно написано, что это все, конечно, хорошо, но вы не забывайте, что полноценное решение должно обязательно еще помнить про Resilience, т.е. поскольку это все in-memory, то если ваше приложение закроется, то и все то, что там лежало в очереди, но не было обработано, оно потеряется, т.е. никакого персистентного хранилища там нету в таком варианте, может быть это там окей для каких-то use-case, но обычно мы все-таки хотим, чтобы сообщения сохранялись, и поэтому это еще больше затрудняет применимость этого решения в целом, но тем не менее.
2553.96 2644.88 "Игорь Лабутин" В общем, три штуки, про которые нужно помнить, если вы хотите это использовать в реальном коде, это Resilience, т.е. если вы попытались туда записать, ну окей, здесь вряд ли что-то пойдет не так с точки зрения сетевых вещей и т.д., но в целом retry было бы неплохо сделать, и демпатентность, это как раз-таки интересный момент, потому что одно и то же сообщение, чтобы не обработать два раза, надо бы это, может быть, отдельно об этом озаботиться, если вы пытаетесь разгребать несколько потоков или еще что-нибудь потом в таком духе делать, ну и для тех сообщений, которые вы почему-то не смогли таки обработать, например, из-за какого-то исключения, ну вы, наверное, конечно, это злокируете и т.д., но может быть интересно ввести концепцию dead letter queue, т.е. некоторую отдельную очередь, куда складываются необработанные сообщения или сообщения, которые почему-то не получилось обработать, чтобы потом их в ручном режиме разобрать, но опять же, поскольку это все in-memory, то вам придется, если вы хотите, захотите это сделать, то вам придется городить какой-нибудь интерфейс, чтобы это все можно было прочитать или куда-то сохранить, короче, берите такой нормальный внешний уже message bus и не заморачивайте, но в качестве такого упражнения, плюс для идеи познакомиться вообще с ченнелами, кажется, действительно неплохое применение для ченнелов, потому что иначе я не очень вижу, зачем-то в обычном таком back-end приложении могут пригодиться ченнелы, у тебя есть какой-нибудь кейс для прода в таком обычном back-end, где ченнелы нужны были бы?
2644.88 2658.00 "Анатолий Кулаков" Да нет, в принципе, опять же, ченнелы, такая довольно низкоуровневая инфраструктурная штука, то есть действительно, если тебе нужно какой-нибудь message bus там оформить или быстренько считать из одного пайпа данные, сконвертить и переложить в другой пайп.
2658.00 2665.40 "Игорь Лабутин" Ну, то есть ты какой-нибудь pipeline действительно пишешь, обработки там высокоскоростного чего-нибудь, да, может быть, может быть.
2665.40 2678.04 "Игорь Лабутин" Ну в общем вот, если вдруг не знали, с какой стороны подступиться к ченнелам, чтобы их потрогать, ну вот, как идея, напишите себе маленький message bus, может быть, зачем-то пригодится даже.
2678.04 2682.28 "Анатолий Кулаков" Ну, как минимум попрактиковаться и узнать, а что же такое ченнелы и как они работают.
2682.28 2686.24 "Игорь Лабутин" Да, а потом написать какую-нибудь клёвую низкоуровневую штуку на них.
2686.24 2688.48 "Анатолий Кулаков" Не понятно зачем, но клёво же.
2688.48 2692.12 "Анатолий Кулаков" Ладно, давай у нас… Можно всем рассказывать, что я написал.
2692.12 2694.00 "Анатолий Кулаков" Ладно, я знаю, что такое ченнелы, я их использовал
2694.00 2695.00 "Игорь Лабутин" в продакшене.
2695.00 2696.00 "Игорь Лабутин" Окей.
2696.00 2701.32 "Игорь Лабутин" Давай, у нас осталась на самом деле последняя из основных статей, но она очень большая, давай попробуем.
2701.32 2703.12 "Анатолий Кулаков" Да, не зарекайся, да, слушай.
2703.12 2708.04 "Игорь Лабутин" К ней как-нибудь подойти с какого-нибудь боку и попробовать её нормально рассказать.
2708.04 2711.12 "Анатолий Кулаков" Да, давай попробуем, если что, задавай вопросы.
2711.12 2725.44 "Анатолий Кулаков" И действительно, статья такая большая, и не просто так, потому что поднимает глобальную тему, а называется она «Каким образом структурировать ваш .NET-решение?
2725.44 2728.12 "Анатолий Кулаков" Архитектуры и ступки».
2728.12 2741.22 "Анатолий Кулаков" То есть, автор пытается поднять большую тему, что такое архитектура приложения, как её выбрать, и как сделать универсальный солюшен, который подходит к вам ко всем.
2741.22 2751.88 "Анатолий Кулаков" Он грамотно прошёлся и по всяким клин-архитектурам, и по вертикал-слайсам, и по многим другим базвордам, который помогает более-менее в голове структурировать.
2751.88 2755.32 "Анатолий Кулаков" А что же нам делать, кого выбрать и куда бежать?
2755.32 2763.88 "Анатолий Кулаков" Давайте вместе с ним попробуем пробежаться и тоже посмотрим, что вашему приложению нужно выбрать, и для чего вам это делать.
2763.88 2766.36 "Анатолий Кулаков" Чтобы выбирать, это всё-таки осознанно.
2766.36 2769.20 "Анатолий Кулаков" Когда у вас маленькое приложение, то там даже думать нечего.
2769.20 2777.48 "Анатолий Кулаков" Вы пишете код в информах, доступаете к базе данных сразу из веб-контроллера, и в принципе всё работает, и так всё хорошо.
2777.48 2781.28 "Анатолий Кулаков" Но чем больше становится ваша система, тем больше у вас становится вопросов.
2781.28 2785.88 "Анатолий Кулаков" И однозначного ответа, в принципе, на них не будет.
2785.88 2791.04 "Анатолий Кулаков" Как бы вы ни рассчитывали, всё равно тут будет "it depends".
2791.04 2799.84 "Анатолий Кулаков" Прежде всего нужно понимать, что у нас существует очень много способов, в какую сторону рыть.
2799.84 2802.12 "Анатолий Кулаков" Ну, допустим, как разделяются у нас модули.
2802.12 2824.32 "Анатолий Кулаков" Мы можем разделить наш солюшен на проекты, мы можем разделить отдельные солюшены на отдельные репозитории, можем расшаривать какую-то логику с помощью Nuget пакетов, почитать про многоуровневую архитектуру, про N-layer, слои, вспомнить про Clean Architecture, узнать, что такое модульные монолиты, воспользоваться какими-нибудь Feature Folder или Vertical Slices.
2824.32 2832.60 "Анатолий Кулаков" В общем, всё это довольно высокоуровневые абстрактные базворды, которые многие даже не знают, как на практике применять.
2832.60 2838.08 "Анатолий Кулаков" Если вы поставите вопрос выбрать между ними что-то, то тут многие станут в тупик.
2838.08 2857.80 "Анатолий Кулаков" И это, в принципе, не единственное, что вам нужно осознать, если вы вдруг захотите действительно разработать какую-то большую универсальную архитектуру или структуру вашего проекта, то перед вами неизбежно встанет вопрос, каким образом ваше приложение будет деплоиться.
2857.80 2879.52 "Анатолий Кулаков" То есть это может быть какой-то модульный монолит, который деплоится на единственный сервер, или вы можете даже модульный монолит запустить не на один сервер, а на несколько серверов, перед ними поставить Load Balancer и прекрасно балансировать нагрузку между различными инстансами этого монолита, несмотря на то, что он монолит, казалось бы.
2879.52 2899.76 "Анатолий Кулаков" Также точно вы можете и взять микросервисы и запустить их на одном сервисе, тоже вам ничего не мешает, несмотря на то, что они микросервисы и как-то все привыкли их запускать на разных нодах, но нет, микросервисы вполне нормально могут жить и на одном сервере, или естественно можете запустить их на разных серверах с помощью каких-нибудь кибернетисов или других средств оркестрации.
2899.76 2909.76 "Анатолий Кулаков" Поэтому о том, как приложение будет деплоиться, как оно будет масштабироваться, в принципе тоже вам необходимо будет задуматься, от этого может быть зависит ваша архитектура и структура вашего солюшена.
2909.76 2918.68 "Анатолий Кулаков" Дальше вам нужно подумать, а как приложения, то есть даже не приложения, а конкретные проекты, модули или сервисы будут между друг с другом взаимодействовать.
2918.68 2934.88 "Анатолий Кулаков" Даже если взять самые распространенные способы, например, роутинг через HTTP API, или через Message Bus какой-нибудь, или может быть они In-Memory Messaging будут использовать, если мы говорим про модульный монолит, то об этом тоже вам нужно задумываться.
2934.88 2938.80 "Анатолий Кулаков" И самое последнее место занимает хранилище.
2938.80 2940.60 "Анатолий Кулаков" Как вы будете использовать базу данных?
2940.60 2962.48 "Анатолий Кулаков" Это может быть каждая база данных на один микросервис, может быть у каждого микросервиса своя собственная база данных, то есть всего много базы данных, может быть расшаренная база данных среди микросервисов, или расшаренная база данных с помощью Sharing схемы, или одна база вообще для всех микросервисов, монолитов, всех приложений вашей компании.
2962.48 2964.68 "Анатолий Кулаков" То есть здесь тоже нужно отвечать на эти вопросы.
2964.68 2986.44 "Анатолий Кулаков" И, как я уже говорил, здесь нет какого-то магического решения, по какому пути из всех этих направлений вы двинетесь, потому что в принципе любая архитектура это некий спектр, вам нужно четко понимать что вы получаете и что из этого вы теряете, то есть какие у вас будут минусы и какие у вас будут плюсы, по-другому у вас не получится.
2986.44 2996.48 "Анатолий Кулаков" Потому что нет золотой пули, иначе бы ее давно изобрели и мы бы все с ней работали, вот почему очень важно об этом во всем знать и об этом обо всем говорить.
2996.48 3034.48 "Анатолий Кулаков" Опять же у вас может быть какой-нибудь монолит, который вы разделили на какие-то логические блоки и у вас получился модульный монолит, который использует там различную технику хранения данных, или же у вас могут быть микросервисы, которые тоже могут использовать много баз данных или даже одну базу данных, и все это имеет место на жизнь, например, давайте разберем самый наверное спорный кейс, это когда у вас, например, есть микросервисы, и они используют одну базу данных, почему это может вообще существовать в нашем мире.
3034.48 3088.68 "Анатолий Кулаков" Есть у этого подхода, бесспорно, свои плюсы, например, это явный контекст, на который разделены эти сервисы, это скорость разработки, потому что если у вас есть одна база данных, то разрабатывать и поддерживать, мигрировать допустим данные будет намного легче, чем если у вас для каждого микросервиса отдельные базы данных, также вы можете захотеть минимизировать ваши расходы на базы данных, потому что существуют, например, сервисы, которые чарджат вас в зависимости от количества баз данных, или опять же, может быть база данных деплоится на столько сложностей, для этого вам придется заводить там какой-нибудь специальный отдел администраторов баз данных, а если у вас будет одна база, то довольно легко она поддерживается, бэкапится и сопровождается.
3088.68 3113.44 "Анатолий Кулаков" И вот всегда вы можете вот такие вот спектры выделить, то есть нельзя сказать, что лучше монолит или микросервисы, вы должны понимать, что если у вас монолит, то у вас там обычно будут меньше накладные расходы, допустим, но при этом у вас могут слиться баунт-контексты ваши в одно единое месиво, и будет больше конфликтов между командами.
3113.44 3124.00 "Анатолий Кулаков" Если же у вас микросервисы, то, конечно, у вас теперь будут баунт-контексты очень красивые, разделенные и так далее, но при этом у вас получается оверхед на поддержку.
3124.00 3136.24 "Анатолий Кулаков" Вам необходимо как-то заботиться о деплойменте, как-то заботиться о развертывании, может быть, специально формировать какую-то команду системных администраторов, даже которые будут это все сопровождать и мониторить.
3136.24 3157.64 "Анатолий Кулаков" И такая же ситуация с базами данных, то есть вы можете произвести одну расшаренную базу данных, и при этом у вас будет намного меньше расходы на ее сопровождение, но зато она будет менее стабильной, так как на нее будут влиять абсолютно все запущенные процессы или модули в вашем приложении, у вас будут какие-то конфликты миграции, которые делают разные другие команды.
3157.64 3168.72 "Анатолий Кулаков" И при этом вы можете выделить отдельную базу данных, но при этом у вас опять же будет оверхед на настройки, на миграцию, на поддерживание, но зато скалируемость улучшится, и зато меньше конфликтов будет.
3168.72 3178.52 "Анатолий Кулаков" То есть вот такой спектр, такой бегунок, который вы можете направо и налево каким-то образом перемещать и в зависимости от этого выбирать, что вам больше всего необходимо.
3178.52 3187.08 "Анатолий Кулаков" Теперь давайте подойдем к решению тому, что может в каких ситуациях нам помочь.
3187.08 3191.92 "Анатолий Кулаков" Прежде всего можно рассмотреть самый популярный подход – это Clean Architecture.
3191.92 3202.92 "Анатолий Кулаков" Перед тем, как критиковать или плюсовать Clean Architecture, хочется еще обозначить здесь такой архитектурный шаблон, который называется 4+1.
3202.92 3210.12 "Анатолий Кулаков" 4+1 – это способ посмотреть на архитектуру с помощью пяти разных точек зрения.
3210.12 3228.20 "Анатолий Кулаков" И эти точки зрения – это логическое представление, то есть каким образом функционирует ваше приложение, и, в общем, это процесс view, то есть с помощью чего различные сервисы в вашем и процессы в вашем общем солюшене коммуницируют друг с другом в рантайме.
3228.20 3233.52 "Анатолий Кулаков" Это physical view, то есть каким образом деплоится ваше приложение.
3233.52 3239.00 "Анатолий Кулаков" Это development view, то есть определяет структуру файлов и папочек в вашей кодовой базе.
3239.00 3252.76 "Анатолий Кулаков" И последний +1 – это обзор сценарий, то есть это те сценарии пользователя, которые как раз-таки и реализовывают всякие бизнес-фичи и то, для чего пользователь использует ваше приложение.
3252.76 3267.76 "Анатолий Кулаков" Вот, если мы посмотрим на любую архитектуру, будем смотреть с таких пяти точек зрения, то у нас немножко обзор на Clean Architecture тоже немножко может сместиться.
3267.76 3268.76 "Анатолий Кулаков" В каком плане?
3268.76 3269.76 "Анатолий Кулаков" Автор говорит, что…
3269.76 3276.36 "Игорь Лабутин" Подожди, вот давай до Clean Architecture сейчас сделаем такую небольшую паузу, попробуем понять.
3276.36 3289.68 "Игорь Лабутин" Вот мы много уже поговорили про монолиты, базы, микросервисы, как мы делим так, как мы делим сяк, но правильно я понимаю, что мы пока еще даже не приблизились к тому, как Solution-то делить, пока мы так готовимся.
3289.68 3298.64 "Анатолий Кулаков" Да-да, все верно, потому что, знаешь, когда ты начинаешь делить Solution, тебе сразу стоит вопрос там, какая папочка там вверху, какая папочка внизу, как их назвать и что там должно быть.
3298.64 3304.24 "Анатолий Кулаков" И вот на вопросы с названиями, один из самых главных вопрос среди разработчиков – это как назвать.
3304.24 3313.00 "Анатолий Кулаков" На этот вопрос невозможно ответить до тех пор, пока ты не определишься с общей архитектурой, потому что общая архитектура тебе может влиять на твой Solution.
3313.00 3319.88 "Анатолий Кулаков" Если ты выберешь там микросервисы, ты четко будешь понимать, что я называю Solution именем моего bound-контекста и сразу пуляю в прот.
3319.88 3330.16 "Анатолий Кулаков" Если ты выбираешь модульный монолит, значит, ты должен понимать, что примерно у тебя там где-то должны быть модули, по имени этих модулей должны быть названы там проекты или папки, и что-то с этим дальше делать.
3330.16 3334.20 "Анатолий Кулаков" Ну т.е. ты не сможешь даже создать верхневыровневую папку, если ты не понимаешь, какая у тебя архитектура
3334.20 3335.64 "Игорь Лабутин" будет у приложения.
3335.64 3339.36 "Игорь Лабутин" Да, окей, давай тогда пойдем в сторону Clean Architecture.
3339.36 3345.72 "Анатолий Кулаков" Ну и вот как самая распространенная вещь, про которую все как минимум слышали, это Clean Architecture.
3345.72 3361.92 "Анатолий Кулаков" Автор говорит, что в принципе Clean Architecture – это хорошо, но у него есть ряд претензий к этому подходу, и основные претензии, они заключаются как раз таки не в том, что Clean Architecture плохая, а в том, что разработчики глупые и смотрят на нее неправильно и понимают ее неправильно и делают все не так.
3361.92 3364.32 "Анатолий Кулаков" Вот хочется как раз и понять.
3364.32 3371.64 "Анатолий Кулаков" Благодаря вот этому фреймворку 4+1, который мы с вами рассмотрели, можно понять боль автора, что собственно ему не нравится.
3371.64 3390.00 "Анатолий Кулаков" Не нравится ему то, что разработчики часто путают логическое представление Clean Architecture и структуру в коде, в котором они это все переносят, потому что они напрямую видят на слайдах красивые квадратики и пытаются это смапить в файлики и папочки.
3390.00 3394.72 "Анатолий Кулаков" В общем, а на самом деле так делать не нужно.
3394.72 3403.44 "Анатолий Кулаков" Ну, допустим, давайте представим, что у вас есть какой-то проект, да, и у вас есть там проект, который называется Shop.
3403.44 3412.56 "Анатолий Кулаков" Внутри этого проекта обычно складываются такие вещи как аппликейшн сервисы, дата аксесс, домен лоджики и так далее.
3412.56 3427.76 "Анатолий Кулаков" И в частности, если мы уже говорим про конкретный .NET фреймворк и SPNET приложение, там же должны лежать и веб-контроллеры, которые взаимодействуют через аппликейшн сервисы с какими-нибудь там, дальше, вашими другими сервисами.
3427.76 3440.00 "Анатолий Кулаков" При этом, в принципе, вы можете аппликейшн сервис отделить, задекаплить от базы данных с помощью подхода шаблона проектирования репозиторий.
3440.00 3461.68 "Анатолий Кулаков" В общем, и это не значит абсолютно, что вы должны все эти слои, все эти классики, папочки выделять в отдельный проект, как обычно делают, то есть, выделяют проект аппликейшн сервисов, проект веб-контроллеров, проект дата аксесса и прочее.
3461.68 3465.12 "Анатолий Кулаков" В общем, абсолютно нет, абсолютно не значит.
3465.12 3479.56 "Анатолий Кулаков" Несмотря на то, что на слайдах обычно рисуют как раз вот эти, именно вот настолько выделенные квадратики, это совсем не значит, что физическая структура вашего солюшена должна ему полностью соответствовать.
3479.56 3482.56 "Анатолий Кулаков" Давайте примерно представим, а чему же она все-таки должна соответствовать.
3482.56 3506.16 "Анатолий Кулаков" Ну, представим, что нам нужно сделать какой-то новый солюшен, и у нас нет каких-то определенных требований по каким-то функциональным требованиям или логическим требованиям, и просто сказали сделать как можно больше, нам нужно там ПОК сделать, и никаких там особых каких-то претензий к этому нет, поэтому вы выберите, что хотите.
3506.16 3535.00 "Анатолий Кулаков" Ну, прежде всего, если мы хотим сделать это как можно быстрее, а для ПОКов это важно, то правильнее всего начать именно с Monolith, потому что вы сразу лишаете себя всяких оверхедов на деплоймент, на мониторинг, на общение между вашими сервисами, поэтому как бы сразу наклепать какие-то микросервисы никого смысла нет, тем более в самом начале мы даже, скорее всего, и не понимаем, какие у нас будут bound контексты и во что мы эти микросервисы выделим.
3535.00 3541.84 "Анатолий Кулаков" Поэтому Monolith – это наш выбор для того, чтобы начать быстренько MVP какое-нибудь приложение на коленочке наклепать.
3541.84 3550.16 "Анатолий Кулаков" Баз данных, естественно, тысяча баз данных нам сейчас тоже не нужна, одна база данных нам вполне подойдёт.
3550.16 3577.28 "Анатолий Кулаков" Следуя более-менее CleanArchitecture, мы туда в этот проект с Monolith набрасываем папочки ControllerViewModel, но это ISPnet нам набросит, это можно и без нас, мы можем добросить туда папочек инфраструктура, домены, интерфейс, и в принципе для пока нам вот этих базовых знаний нам хватит, дальше от архитектуры мы пока ничего требовать и не собираемся.
3577.28 3585.12 "Анатолий Кулаков" Если наш проект идёт и развивается, мы нанимаем ещё несколько разработчиков, то перед разработчиками встаёт вопрос.
3585.12 3604.52 "Анатолий Кулаков" Много недопонимания обычно идёт о том, как найти какую-нибудь фичу, вот у нас есть там какая-то фича поисков товаров, фича заказов или чек-аутов из корзины, и где её найти в этом вашем большом приложении, потому что не очень понятно.
3604.52 3612.48 "Анатолий Кулаков" Другая проблема, которая у разработчика возникает, это то, что наш фреймворк MVC он диктует нам структуру приложения.
3612.48 3613.48 "Анатолий Кулаков" Чему это плохо?
3613.48 3631.04 "Анатолий Кулаков" Потому что, допустим, если у нас для какого-то модуля нам выгодно выбрать не MVC, а, например, запилить какие-нибудь Razer Pages или вставить какой-нибудь новомодный WebAssembly, то это не очень вписывается в ту структуру контроллеров и вьюшек, которые у нас уже фреймворк заставил нас сделать.
3631.04 3642.56 "Анатолий Кулаков" И непонятно, что сделать, как нам дальше идти, следуя образу и подобию, сделать верхнеуровневую папочку Razer Pages или верхнеуровневую папочку API Controllers – тоже неясно.
3642.56 3646.64 "Анатолий Кулаков" И постепенно, если мы пойдём этим путём, у нас наверху будет слишком много мусора.
3646.64 3663.08 "Анатолий Кулаков" И даже если мы так сделаем, каким образом мы сможем ответить на вопросы, допустим, что у нас одни модули доступны, допустим, по MVC-контракту, другие по Razer Pages рендерятся, а третьи через API Controllers отдаются.
3663.08 3683.44 "Анатолий Кулаков" В общем, на такие вот сложные вопросы, когда мы пытаемся обозреть фичу со всех сторон, т.е. где она лежит, найти её, посмотреть, какие у неё есть endpoints, как они взаимодействуют, на фичу со всех сторон посмотреть становится более сложно, потому что мы сфокусированы в нашем солюшене больше на технологический аспект, чем на бизнес-аспект.
3683.44 3692.32 "Анатолий Кулаков" И эту проблему нам помогает решить следующее небольшое нововведение – это фичи-фолдеры.
3692.32 3700.32 "Анатолий Кулаков" Фичи-фолдеры как раз помогают разбить структуру ваших папочек на более бизнес-ориентированные или домен-ориентированные области.
3700.32 3706.00 "Анатолий Кулаков" Это похоже на то, что мы обсуждали выше, с одним небольшим изменением.
3706.00 3715.48 "Анатолий Кулаков" На самом верхнем уровне у вас должны быть не технические аспекты, т.е. не что там у вас, модели или домены, или ещё что-то лежит, а должны быть бизнес-фичи.
3715.48 3727.48 "Анатолий Кулаков" Т.е. допустим, у нас есть бизнес-фича магазин, бизнес-фича отчёт, бизнес-фича планирование, и вот они в виде вот таких вот папочек или проектов должны находиться на самом верху.
3727.48 3735.84 "Анатолий Кулаков" А уже внутри проекта магазин у нас есть папочка, может быть, там папочка с контроллерами, с моделями, с вьюшками, с доменами и т.д.
3735.84 3737.52 "Анатолий Кулаков" К чему это приводит?
3737.52 3742.60 "Анатолий Кулаков" Во-первых, мы легко находим фичу, все наши фичи находятся на верхнем уровне.
3742.60 3749.80 "Анатолий Кулаков" Дальше мы начинаем думать не в терминах технических, кто у нас контроллер, а кто у нас интерфейс, а в терминах бизнес-модулей.
3749.80 3752.68 "Анатолий Кулаков" Т.е. вот у нас есть модуль магазин, и он там за что-то наверняка отвечает.
3752.68 3761.44 "Анатолий Кулаков" И мы более детально видим все отношения, с кем этот модуль, от кого этот модуль зависит и кто зависит от него.
3761.44 3770.00 "Анатолий Кулаков" Т.е. в отличие от всяких технических аспектов мы уже ориентируемся бизнес-модулями и ими отношения их между друг другом.
3770.00 3772.76 "Анатолий Кулаков" У этого подхода по-прежнему остаются некоторые минусы.
3772.76 3790.32 "Анатолий Кулаков" В частности, это то, что WebFramework по-прежнему нам диктует структуру папочек, несмотря на то, что мы эти папочки выбрали в топ-левел фичи, внутри топ-левел фичи мы все равно имеем те же самые контроллеры, папочку с контроллерами, папочку с моделями и прочими глупостями.
3790.32 3800.52 "Анатолий Кулаков" И вторая проблема – это в том, что мы пытаемся загнать все наши модули в одну и ту же структуру.
3800.52 3812.88 "Анатолий Кулаков" В большинстве случаев это неправда, потому что эти модули могут отличаться не только бизнес-наполнением, но они могут отличаться еще инфраструктурным или принципиально другой архитектурой.
3812.88 3827.84 "Анатолий Кулаков" Есть модули маленькие, которым достаточно каких-то базовых крут операций, есть модули разрезистые, которых надо там DDD и CQRS вкапывать, а есть модули, которые должны общаться между собой с помощью месседжинга, и тоже там структура будет немножко другая.
3827.84 3836.04 "Анатолий Кулаков" И чтобы нам перейти к следующему уровню совершенства, вводится такое понятие, как Vertical Slices.
3836.04 3843.08 "Анатолий Кулаков" Vertical Slices – это подход, очень похожий на Feature Folders, но делающих их более гибкими.
3843.08 3857.36 "Анатолий Кулаков" Таким образом, одна фича, которая есть в нашем проекте, в нашем подходе, она может использовать, допустим, свою собственную архитектуру.
3857.36 3865.68 "Анатолий Кулаков" Как я уже говорил, одна использует DDD, другая использует CRUD с транзакцией, с криптом, и третья может на месседж-басы перейти.
3865.68 3869.56 "Анатолий Кулаков" Как это будет выглядеть в структуре нашего солюшена?
3869.56 3870.56 "Анатолий Кулаков" Очень просто.
3870.56 3891.88 "Анатолий Кулаков" У нас будет папочка, такие же точно папочка Scheduling, Shop и Report, т.е. отчет, магазин, планировщик, но при этом внутри, например, магазина у нас не будет никаких там папочек, которые относятся к чему-то, к каким-то другим модулям или содержащим другим папочки.
3891.88 3901.44 "Анатолий Кулаков" Рекомендуется прямо делать файлик Controller.cs и в этом файлике располагать тот контроллер, который будет отвечать полностью за магазин.
3901.44 3919.16 "Анатолий Кулаков" Т.е. у нас будет Model.cs, View.cs, HTML, репозиторий.cs и даже имплементация того же самого репозитория, ее можно положить прямо в эту папочку, т.е. для этого не обязательно лепить кучу проектов, это все можно сложить в одну единственную папочку.
3919.16 3932.36 "Анатолий Кулаков" Т.е. по логической структуре у нас все еще это clean architecture, по физической структуре они все свалены без каких-либо проектов, все свалены там, все фичи свалены в одну папочку.
3932.36 3948.48 "Анатолий Кулаков" Дальше у нас возникают вопросы, как нам шарить функциональность, как нам определить, какую там архитектуру в каждой из этих фич мы должны использовать, ну и один из самых главных вопросов, а как мы будем использовать базу данных.
3948.48 3954.96 "Анатолий Кулаков" Т.е. у нас есть несколько фич, а что с базой данных, они все должны как хранить свои данные, в одной базе или в разных.
3954.96 3980.48 "Анатолий Кулаков" Здесь, на данном конкретном этапе мы в принципе, если мы по-прежнему запускаемся как модульный монолит, мы можем использовать шареную базу данных, но шареную базу данных на уровне схемы, т.е. у нас каждый модуль, каждая папочка, она будет иметь свою собственную схему.
3980.48 3987.52 "Анатолий Кулаков" Таким образом, у нас не будут пересекаться данные, у нас не будут пересекаться таблицы, но база данных физически будет одна.
3987.52 3998.68 "Анатолий Кулаков" И зачем использовать одну базу данных, ну как я уже говорил, что меньше косты на сопровождение, меньше сложность вашего проекта будет и т.д. и т.д.
3998.68 4004.76 "Анатолий Кулаков" Поэтому одна база данных, но при этом обязательно с разной схемой, это вполне хороший подход, особенно если мы говорим про модульный монолит.
4004.76 4028.96 "Анатолий Кулаков" Если же вдруг у вас в модульном монолите захочется сделать фичу, т.е. не фичу, а действие, которое логически выражается джойном между разными схемами, т.е. по сути вы хотите заджойнить к себе или заселектить, запросить данные из одной фичи, захотите запросить данные от другой фичи, используя базу данных, то это уже антипатерн.
4028.96 4033.32 "Анатолий Кулаков" Вы уже становитесь на скользкую дорожку как бы расшаренных таблиц.
4033.32 4041.80 "Анатолий Кулаков" Это очень плохо и в этот самый момент вы должны задумываться о том, а каким образом коммуницируют ваши модули внутри вашего модульного монолита.
4041.80 4066.68 "Анатолий Кулаков" И может быть в этот момент вы придете к тому, что вам нужно некоторые модули объединить, некоторые модули разделить, может быть даже вынести в отдельный процесс, но никогда не оставляйте эту ситуацию на самотек, потому что связанность на уровне базы данных это очень важная вещь, если вы ее упустите, то потом развязывать будет очень-очень больно, поэтому обратите на это особое внимание.
4066.68 4086.16 "Анатолий Кулаков" И в принципе вот с этой стороны, когда вы пытаетесь уменьшить каплинг и увеличить кохижн, вот с этой стороны нужно смотреть на эволюцию всей вашей структуры и именно из-за этого вы должны делить, умножать или каким-то образом объединять различные ваши модули.
4086.16 4106.96 "Анатолий Кулаков" Это нужно как раз для того, чтобы когда вы изменяете одну фичу, не сломать при этом другую фичу, для этого вам нужно держать такую маленькую связанность, иначе ваши команды просто погибнут в каких-то конфликтах и баталиях, пытаясь доказать, чья фича была первее и как ее нужно мерзнуть.
4106.96 4126.32 "Анатолий Кулаков" Поэтому старайтесь использовать все файлы, которые нужны в каком-то определенном вертикал слайсе, старайтесь складывать их в этот вертикал слайс, т.е. как эта команда работает над магазином, она не должна никаким образом повредить функциональность команды, которая работает над отчетами, и наоборот.
4126.32 4131.76 "Анатолий Кулаков" Ну и соответственно база данных тоже должна у них быть изолирована хотя бы на уровне схемы.
4131.76 4142.96 "Анатолий Кулаков" Давайте представим ситуацию, что вот команда, которая работает над отчетами, решила затащить себе 10-летний годовалый отчет и просчитать у него все возможные формулы, которые там только есть.
4142.96 4158.56 "Анатолий Кулаков" Т.е. какой-то годовалый отчет она хочет сделать, и при этом, естественно, этот отчет будет тяжелым, долгим, страшным, и получается так, что он будет потреблять абсолютно все ресурсы, которые только этому модульному монолиту доступны.
4158.56 4161.64 "Анатолий Кулаков" От этого, безусловно, будет страдать остальная функциональность.
4161.64 4166.32 "Анатолий Кулаков" Магазин не сможет работать, пока отчет там где-то в бэкграунде какой-то страшный строится.
4166.32 4169.68 "Анатолий Кулаков" И здесь нужно что-то делать.
4169.68 4179.88 "Анатолий Кулаков" И самым частым подходом, очевидным, который здесь можно сделать, это выделить как раз фичу, которая называется отчет, выделить ее в свой собственный процесс.
4179.88 4184.08 "Анатолий Кулаков" Она может перерасти в отдельный диплоймент-айтем.
4184.08 4195.44 "Анатолий Кулаков" В принципе, на данном этапе можно даже ее оставить на той же самой базе, которая у нас была, а масштабировать только процесс, если мы, допустим, упираемся только в CPU или только в память.
4195.44 4205.16 "Анатолий Кулаков" Но очень часто базу данных тоже выносят, и предпосылки для того, чтобы вынести базу данных вместе с кодом, могут быть разные.
4205.16 4208.64 "Анатолий Кулаков" Например, вам нужен больший перформанс в базе данных.
4208.64 4219.44 "Анатолий Кулаков" Если отчет нагружает не только память, не только CPU, но при этом еще нагружает базу данных, нагружает диск, то, возможно, вам тоже эта база данных будет полезна вынести.
4219.44 4235.20 "Анатолий Кулаков" Если вам вдруг нужна большая изоляция данных, например, команда, которая работает над отчетом, ей нужна больше свободы в миграциях, больше гибкости в структурах, то они могут использовать… В общем, это тоже одна из причин вынести базу данных.
4235.20 4247.16 "Анатолий Кулаков" Ну и если вам нужна больше автономность команды, если она не хочет зависеть никаким образом от каких-то костылей, которые делают другие команды, это тоже причина для того, чтобы вынести базу данных.
4247.16 4250.24 "Анатолий Кулаков" В этот самый момент вы можете подумать о микросервисах.
4250.24 4260.52 "Анатолий Кулаков" То есть, когда мы уже выделили из модульного монолита какой-то модуль и в отдельный процесс выделили ему, может быть, отдельную базу данных, является ли это микросервисом.
4260.52 4265.96 "Анатолий Кулаков" Да, возможно, когда у вас отдельный процесс и у него своя собственная база данных, это можно назвать микросервисом.
4265.96 4266.96 "Анатолий Кулаков" Почему возможно?
4266.96 4274.04 "Анатолий Кулаков" Ну, потому что нет строгого определения микросервисов, и даже многие не понимают, что такое микро.
4274.04 4287.64 "Анатолий Кулаков" Ну, например, вот этот модуль отчета, который мы выделили, сколько там кода, достаточно ли это там кода, чтобы это быть микросервисом, или это слишком много, чтобы быть микросервисом, как бы никто не знает, никаких формальных определений нет.
4287.64 4296.52 "Анатолий Кулаков" Поэтому можете считать, что если модуль выделен в отдельный процесс и у него есть своя собственная база данных, то это уже микросервис, как бы вы его не называли.
4296.52 4306.28 "Анатолий Кулаков" Если мы говорим о фронт-энде, то у вас есть тоже несколько подходов, как автор советует выделять фронт-энд.
4306.28 4313.24 "Анатолий Кулаков" Ну, если у нас Razor, или WebAssembly, или MVC, то тут все просто, да, у нас все путешествует вместе с нашим дотент-приложением и мы счастливы.
4313.24 4325.76 "Анатолий Кулаков" Но что делать, если у нас сингл-пэйдж-аппликейшн, и мы хотим Angular или React, для этого тоже есть подходы, они называются микро-фронт-энд или UI-композишн, в общем, про них тоже можно почитать и каким-то образом заюзать.
4325.76 4361.36 "Анатолий Кулаков" Но из моей практики гораздо самый лучший подход, который себя лучше всего оправдал, это выделяете сразу UI-чиков в отдельные репозитории, отдавайте им их собственные тулзы для сборки, для обновления, для слежения, для сканирования и так далее, и не смешивайте этот код с дотнетом, потому что самые больные моменты, самые страшные рефакторинги и самое большое количество багов, которые приходилось мне испытывать, это как раз-таки, когда мы пытались какой-нибудь устаревший UI-фреймворк вырезать или, не дай бог, обновить, или еще что-то с ним делать внутри дотнетовского репозитория.
4361.36 4386.52 "Анатолий Кулаков" В общем, это сущий ад и кошмар, то есть тот инструментарий, который используется фронтендерами, он абсолютно не приспособлен для какого-то разумного понимания дотнетчиками, поэтому самый лучший способ, который вы можете сделать, это держите фронтенд в отдельном репозитории и используйте там те инструменты, которые специально нужны для фронтенда, а дотнетовские приложения собирайте дотнетными инструментами и будет вам счастье.
4386.52 4392.88 "Анатолий Кулаков" Так, и в конце концов, какие выводы можно сделать?
4392.88 4413.00 "Анатолий Кулаков" Ну, первый, держите файлы, которые вместе меняются вместе, т.е. в одной папочке, в одной фиче-фолдере или в одном слайсе, они должны быть рядышком, чтобы их можно было легко найти, легко понять, что они делают и легко там починить, расширить или пофиксить какую-то фичу.
4413.00 4431.48 "Анатолий Кулаков" Использование в вашем приложении Clean Architecture совсем не значит, что вы должны городить минимум 6 проектов, а многие города родят и больше, там и solutions есть из 200-300 проектов, и когда задаешься банальным вопросом, а почему, а зачем, ну как бы разумного ответа найти сложно.
4431.48 4456.64 "Анатолий Кулаков" Фичи не должны пересекаться между собой, несмотря на то, где эти фичи, если это фичи в папочках, или это фичи в таблицах, или в базах данных, или еще где-нибудь, они никаким образом не должны взаимодействовать, кроме официальных путей взаимодействия, т.е. никаких прямых джойнов или прямых использований сервисов или прямых использований классов, у вас должен быть какой-то задекларированный путь, с помощью которого слайс или фича общается с другими.
4456.64 4469.90 "Анатолий Кулаков" Если вы используете вертикал слайсы, то в принципе довольно легко выделить из этих вертикал слайсов отдельный какой-то сервис или отдельный процесс, с помощью которого вы можете дальше продолжить каким-то образом масштабировать ваше приложение.
4469.90 4502.78 "Анатолий Кулаков" И если вы действительно хотите микросервисы или если вам нужны микросервисы, то не старайтесь их делать сразу, начните с модульного монолита и подождите пока вы не дойдете до того уровня понимания, что вам действительно вот этому слайсу в данном конкретном монолите уже тесно и желательно бы его выделить, и вы четко понимаете, какие вам даст это плюсы и готовы пойти на те минусы, которые к вам свалятся с тем самым, как придут микросервисы.
4502.78 4520.74 "Анатолий Кулаков" Вот такая полезная статья, немножко пробежалась по всему, естественно, никуда глубоко не углубляясь, но это тоже заняло в принципе немало времени, поэтому если вдруг вам понравилось, что там написано, обратитесь к автору, у него там еще много есть интересных каких-то материалов, может быть в будущем мы их тоже рассмотрим.
4520.74 4536.04 "Игорь Лабутин" Ну и я бы сказал, что если вы вдруг на слух что-то не поняли, недопоняли или недоразобрали, посмотрите саму статью, потому что мне кажется, что такие штуки надо иногда вчитываться, и там картинки иногда прикольные встречаются.
4536.04 4542.14 "Анатолий Кулаков" Да, картинки, диаграмма, также подробные ссылки на какие-то слова, которые вам не знакомы были, наверняка их тоже найдете.
4542.14 4543.14 "Игорь Лабутин" Да.
4543.14 4563.58 "Игорь Лабутин" На этом на самом деле у нас все новости, которые были из таких крупных статей, но есть еще ряд мелких новостей, которые, ну как-то не оформились в какой-то большой рассказ, но которые мне кажется стоит осветить, которые мне показались по какой-то причине интересными.
4563.58 4569.26 "Игорь Лабутин" Во-первых, набрел на пакетик под названием EF Core 2nd Level Cache Interceptor.
4569.26 4586.42 "Игорь Лабутин" Если вы вдруг зачем-то задумывались о том, они закешируют ли вам результат выполнения запроса, так чтобы потом, когда вы заново выполните этот запрос, у вас бы не было обращения в BD, а забирал свой результат, который вы закешировали, то этот пакет вам нужен.
4586.42 4615.06 "Игорь Лабутин" То есть он работает так, что если вы заново выполняете запрос, то результат берется из кэша, который можно там настроить, такой кэш, такой кэш, распределенный, нераспределенный, при этом все довольно тонко настраивается, какие запросы кэшировать, какие не кэшировать, в общем, если вы, не знаю, пришли из джава мира и вам хочется чего-то подобного 2nd level кэшу Hibernate, то это вот нечто подобное, похожее, можно попробовать.
4615.06 4633.86 "Игорь Лабутин" Дальше, если вы занимаетесь юнит-тестированием, если вы пишете юнит-тесты и используете XUnit, то может быть вас заинтересует пакет под названием, название это я даже себе почему-то не записал, а он называется .NET XUnitOtl, ну, в репозитории, по крайней мере.
4633.86 4661.46 "Игорь Лабутин" Короче, смысл в том, что если вы возьмете этот пакет и там правильным образом начнете писать ваши тесты, то автоматически все ваши тесты получат трейсы OpenTelemetry, из OpenTelemetry, т.е. вы будете видеть от ваших тестов все те же самые метрики, которые вы видите, например, в Prod'е от вашего кода, иногда может быть полезно, не факт, что нужно прям все тесты всегда занять OpenTelemetry метриками и трейсами, но в целом может быть полезно для каких-то сложных случаев.
4661.46 4715.22 "Анатолий Кулаков" И там, смотри, там не надо каким-то образом сильно использовать, там достаточно на Assembly навесить специальный атрибут и все, и этой магии достаточно для того, чтобы вот этот плагин, он перехватывал все запуски Unit тестов и оборачивал их в OpenTelemetry Scope, это значит, что вы можете, ну, если ваши интеграционные тесты, допустим, пишут логи, почему бы и нет, вы можете эти логи, например, отсортировать по TraceID и посмотреть, и этот TraceID будет даваться каждому тесту индивидуально, и вы можете посмотреть, как этот тест проходил, построить его Distributed Tracing, посмотреть все его логи, допустим, посмотреть его метрики конкретные вот этого теста, ну, то есть делать все то же самое, что вы делаете с нормальным OpenTelemetry трассировками, метриками, но только вы будете наблюдать не полностью за всем вашим приложением или реквестом, а вот в рамках определенного теста.
4715.22 4716.22 "Анатолий Кулаков" Довольно полезно, интересно.
4716.22 4717.22 "Анатолий Кулаков" Да-да-да, удобно-удобно.
4717.22 4724.38 "Игорь Лабутин" Наверняка, кстати, что-нибудь такое для InUnit можно придумать, если вы вдруг используете InUnit, просто мне не попадалось.
4724.38 4778.78 "Игорь Лабутин" Дальше, библиотечка TurboMQTT, я думаю, что если вы занимаетесь всяким IoT, да, Internet of Things, то вы знаете протокол MQTT, это довольно популярный и, ну, можно даже сказать, де-факто стандарт, да, в мире IoT для передачи всяких разных данных с девайсов, так вот, у нас теперь есть на C# библиотечка под названием TurboMQTT от компании PetaBridge, которая делает ACO, так вот, библиотечка — это высокоскоростной клиент для, как бы, масштабных всяких IoT-ворклоудов, который позволяет посылать, ну, или обрабатывать до 100 тысяч сообщений в секунду, и она построена на ACO.NET и ACO Streams, что это, пожалуй, один из первых продуктов, которые мне вот так вот, даже не продукт, а библиотек, который мне встретился, который построен на ACO.
4778.78 4791.62 "Анатолий Кулаков" Чё-то я ожидал как-то наоборот, потому что MQTT — это протокол как раз сетевой обмена данными, я думаю, что как-то ACO будет использовать этот протокол для того, чтобы получать, допустим, свои месседжи, и не как-то реагировать.
4791.62 4794.26 "Анатолий Кулаков" А вот что с самым MQTT построен на ACO?
4794.26 4806.90 "Игорь Лабутин" Ну, MQTT-то не построен, но я думаю, что вот эта вся логика типа как обработать дофигищные сообщения или как их послать, да, она как раз на все эти ACO и ACO Stream сложится.
4806.90 4807.90 "Игорь Лабутин" В общем, интересно-интересно.
4807.90 4809.62 "Игорь Лабутин" Ну, допустим, да, почему бы и нет.
4809.62 4810.62 "Игорь Лабутин" Вот, дальше.
4810.62 4825.58 "Игорь Лабутин" В новостях мне попалась ссылочка на сайт под названием Tracelens.io, естественно, в связке с .NET Aspire, потому что Tracelens намекает, что это что-то про трейсы.
4825.58 4835.18 "Игорь Лабутин" И это действительно некоторый продукт, который пока еще находится, я так понимаю, в какой-то типа альфа-бете или чем-то таком, поэтому он сейчас бесплатный, все такое, пользуйтесь.
4835.18 4838.10 "Игорь Лабутин" Продукт для визуализации как раз-таки метрик трейсов и так далее.
4838.10 4851.62 "Игорь Лабутин" Причем он, ну, там скриншотики красивые, визуализирует он не только стандартный, да, вот как-то выглядит ваш трейс и так далее, но еще какие-то дополнительные данные пытаются к этому делу, какой-то дополнительный анализ провести.
4851.62 4852.62 "Игорь Лабутин" Вот.
4852.62 4871.66 "Игорь Лабутин" Плюс у них есть пакет интеграции с Aspire, то есть я так понимаю, что можно модулю Aspire закинуть, и он автоматически будет посылать в нужный endpoint этого продукта, пока бесплатный, потом он будет, видимо, ну, лицензироваться, видимо, примерно так же, как лицензируется SEC, когда он для девелоперов и персонал-ьюз бесплатный, а для продакшна будет платный.
4871.66 4879.22 "Игорь Лабутин" Но, по крайней мере, интересно, может быть вполне себе еще одним таким all-in-one продуктом визуализации.
4879.22 4880.22 "Игорь Лабутин" Метрик трейсов.
4880.22 4881.22 "Игорь Лабутин" Конкурент Aspire Dashboard'у.
4881.22 4892.22 "Игорь Лабутин" Да, да-да-да, конкурент Aspire Dashboard'у или может быть даже, ну, графанин не сказал бы, непонятно, сколько они будут кастомизируемы, но посмотрим, посмотрим.
4892.22 4894.98 "Анатолий Кулаков" А на чем эти красивые картинки нарисованы?
4894.98 4895.98 "Анатолий Кулаков" Слушай, я не знаю.
4895.98 4896.98 "Анатолий Кулаков" На каком UI?
4896.98 4897.98 "Анатолий Кулаков" А я, кстати, не смотрел.
4897.98 4898.98 "Игорь Лабутин" Не смотрел?
4898.98 4900.62 "Игорь Лабутин" Давай прямо сейчас посмотрим, это несложно.
4900.62 4926.54 "Игорь Лабутин" Трейсленс, бла-бла-бла, так, ну тут у них на сайте только usingtracelens.aspire и потом builder.addtracelens, а вот если пойти на их сайт, в смысле на github, где написано, что они используют C# 100% language, но правда, блин, это всего лишь плагин для трейсленса Aspire, поэтому неинтересно.
4926.54 4937.66 "Игорь Лабутин" То есть они просто шлют в какой-то OpenTelemetry коллектор, а исходников этого самого, как называется, самого трейсленса я не вижу.
4937.66 4939.16 "Игорь Лабутин" Ну ладно, пойдем дальше.
4939.16 4944.56 "Игорь Лабутин" Так что да, надо будет, посмотрим, я думаю, что если они доберутся до какой-то популярности, мы про них еще услышим и обсудим.
4944.56 4966.08 "Игорь Лабутин" В прошлый раз я рассказывал про видосик от Стивена Таубой и Скотта Хансельмана, они продолжили серию видосиков ютубных на тему deepdive куда-нибудь в дотнет, и вышло два видео, одно про спан и все, что вокруг с ним связано, и второе про регексы.
4966.08 4971.14 "Игорь Лабутин" Там как раз про всякие, там бэктрейкинг, не бэктрейкинг, сурс генерацию, вот это все.
4971.14 4981.64 "Игорь Лабутин" В общем, очередной такой deepdive, когда Тауб в основном кодит и при этом они с Хансельманом что-нибудь как-нибудь обсуждают, иногда привязанные коды, иногда не привязанные коды.
4981.64 4984.32 "Игорь Лабутин" Послушайте, интересно, рекомендую.
4984.32 5013.04 "Игорь Лабутин" Дальше до нас в C# доходит машинлернинг, по чуть-чуть, потому что нашлась статейка про то, как из C# заюзать новую модельку, которая FI3, или FI3, как ее правильно произносить, с помощью C# Semantic Kernel, короче, можно на C# через дотнет-консольку создать приложение, которое будет работать примерно как чат, с вот этой моделькой в качестве бэкэнда.
5013.04 5026.36 "Игорь Лабутин" Если хотите посмотреть как используется C# Semantic Kernel, как писать такой прикладной машинлернинг, в смысле неготовых моделей на дотнете, можно глянуть, там небольшая статья типа там, с 4 командой можно все сделать.
5026.36 5030.56 "Анатолий Кулаков" Ну это там можно к любой ламе подключиться, не только на FI3.
5030.56 5043.92 "Игорь Лабутин" Да-да-да, там используется лама, поэтому туда можно что угодно запихать, просто что FI3 достаточно маленькая, и она, скорее всего, поднимется на чем угодно, независимо от мощи вашего компа, и наличия там всяких видеокарточек и прочего.
5043.92 5049.00 "Анатолий Кулаков" А вот следующее… Ну и Semantic Kernel, я тоже первый раз вижу на практике, чтобы его кто-то юзал.
5049.00 5056.40 "Игорь Лабутин" Ну да, да, я поэтому и заинтересовался, что не столько FI3, а сколько именно Semantic Kernel.
5056.40 5060.24 "Игорь Лабутин" А вот следующую штуку я хочу сам попробовать, может быть будет даже полезно.
5060.24 5067.24 "Игорь Лабутин" Есть dotnet global tool под названием http-генератор, и он делает одну единственную задачку.
5067.24 5084.06 "Игорь Лабутин" Вы ему отдаете JSON от OpenAPI, и он вам в ответ генерирует .http файл, это формат файлов для http-запросов, который вам и IDEA понимает, и VS Code понимает, и для Visual Studio есть плагин для того, чтобы делать вам потом тестовые запросы.
5084.06 5095.16 "Игорь Лабутин" То есть он для всех запросов генерирует некоторые шаблонные собственно запросы, там где пост, там будет ботик даже сгенерирован, какой-никакой, ну насколько он сможет из описания OpenAPI.
5095.16 5106.92 "Игорь Лабутин" Может быть полезно, особенно для работы с какими-то не очень известными вами в Амапе, если вы хотите не UI-ный сваггер, а такой .http формат, то почему нет?
5106.92 5110.80 "Анатолий Кулаков" Да, слушай, идея довольно на поверхности, но очень полезная штука.
5110.80 5111.80 "Анатолий Кулаков" Я вот не вижу.
5111.80 5126.32 "Анатолий Кулаков" Замечательно было, знаешь, если бы какой-нибудь Visual Studio или Visual Studio Code, кто поддерживает этот API, сама могла бы понимать, что ты URL только вбил, она тебе примерно по этому URL вытащила бы какой-нибудь сваггер JSON этот, и сама бы сгенерировала тебе ботик.
5126.32 5131.76 "Игорь Лабутин" Ну у нас пока не настолько метаданные для URL-ов развиты в интернете.
5131.76 5133.88 "Игорь Лабутин" Мало ли какой ты туда URL забьёшь.
5133.88 5143.68 "Анатолий Кулаков" Ну хотя бы если ты localhost вбиваешь, то примерно ты же знаешь, что ты будешь, скорее всего, свой сервис редактировать, и ты понимаешь, что на /swagger обычно висит сваггер.
5143.68 5144.68 "Анатолий Кулаков" Ну это да.
5144.68 5145.68 "Игорь Лабутин" Пингануть можно было бы.
5145.68 5146.68 "Игорь Лабутин" Да.
5146.68 5147.68 "Игорь Лабутин" Ну у кого как, у нас он висит на /контракты.
5147.68 5148.68 "Игорь Лабутин" Поэтому.
5148.68 5153.96 "Анатолий Кулаков" Ну вот для вас извращенцев никакой генерации не будет, а те, кто использует дефолты, тем будет плюшечки.
5153.96 5156.76 "Игорь Лабутин" Да, да, будем руками писать дальше.
5156.76 5162.64 "Игорь Лабутин" И последняя штука – это очередное обсуждение вокруг дотнета, почему же его так мало используют.
5162.64 5172.62 "Игорь Лабутин" Началось всё с нескольких твитов, ну твитер трудов даже, про то, что почему же дотнет настолько не популярен в стартапах, дотнет и C# в частности.
5172.62 5173.62 "Игорь Лабутин" Вот.
5173.62 5194.92 "Игорь Лабутин" Ну и там рассматривается ряд, так скажем, я забыл русское слово в соответствующем английском, perceptions, то есть таких как бы, ну не впечатлений, а в общем каких-то таких старых знаний, которые уже больше не актуальны, но всё ещё кажутся актуальными по какой-то причине.
5194.92 5210.24 "Игорь Лабутин" И товарищ пишет, что ну я там с многими говорил, и типа многие говорят, да ну как бы для дотнет нужно будет покупать лицензию Visual Studio, короче, дорого, она там если не дорогая, это всё, тысячи долларов в год на разработчика, всё такое.
5210.24 5232.40 "Игорь Лабутин" А некоторые говорят, да не, ну как бы да, мы знаем, дотнет открытый, всё такое, но всё равно это Майкрософт и вот это всё, хотя понятно, что можно в принципе достаточно заплатить за какую-нибудь билет, там райдер например, даже не Майкрософт, и у вас будет полноценный нормальный экспириенс, но тем не менее.
5232.40 5254.88 "Игорь Лабутин" Дальше есть ещё один тренд, тоже в этих трейдах отмечался про то, что C# это в общем-то не такой простой язык, как питончик или го, типа в нём дофигища фич, сложные значит именования, в смысле, что у нас есть дотнет был, дотнет фреймворк, дотнет корр, дотнет стендарт, сейчас дотнет, ну в общем много раз обсуждаемый вопрос брендинга и позиционирования.
5254.88 5277.88 "Игорь Лабутин" Дальше есть опять же историческая некоторая память того, что дотнет и прочие штуки от Майкрософт всегда были хороши с тулингом на винде, но абсолютно фиговы с тулингом на макбуке, когда ты получаешь новенький макбук в стартапе, у тебя как-то даже в голову не приходит начать туда ставить тулы от Майкрософт для Майкрософт стека, ну хотя как бы Visual Studio Code ты ставишь, но в общем как-то оно вот.
5277.88 5279.48 "Анатолий Кулаков" Ну Office обычно ты тоже ставишь.
5279.48 5288.56 "Игорь Лабутин" Ну Office, ладно, Office не является таким девелопертулом, он как бы, с Office, кстати, всё нормально, на маке в этом смысле.
5288.56 5291.16 "Анатолий Кулаков" Ну ладно, Visual Studio Code, пожалуйста.
5291.16 5300.48 "Игорь Лабутин" Ну дотнет с ней не настолько как бы хорош, как с райдером или с обычной Visual Studio, т.е. всё-таки там есть пока ещё.
5300.48 5325.72 "Игорь Лабутин" И на всё это как бы, ну мало ли что народ поговорил, но на всё это Фаулер, Дэвид Фаулер, наш товарищ, который активно двигает Espire и вообще всячески публично рассказывает про дотнет, на самом деле довольно много, он написал тоже такой большой-большой длинный тред с некоторыми мыслями, которые я так красненько-быстренько расскажу.
5325.72 5343.52 "Игорь Лабутин" То есть, во-первых, что, типа он говорит, да, становится очевидным, что есть ещё дофига работы на стороне Microsoft про то, что, какой вообще дотнет и тулинг, да, что фри, что не фри, где он вообще работает, потому что кажется, что многие до сих пор не понимают, что он крош-платформенный.
5343.52 5344.52 "Игорь Лабутин" Вот.
5344.52 5358.48 "Игорь Лабутин" А дальше как бы он говорит, что абсолютно не важно, ну не то, что не абсолютно не важно, но не важно, насколько у вас там типа свободный, открытый, бесплатный раунд-тайм, если у вас всё плохо с тулами, вот.
5358.48 5374.24 "Игорь Лабутин" И он говорит, что, как это, что народ, разработчики хотят, так скажем, он называет most native tooling experience, и поэтому все хотят крош-платформенную Visual Studio.
5374.24 5382.44 "Игорь Лабутин" Ну, то есть, типа, те, кто когда-либо занимался дотнетом, знают, что Visual Studio полноценная, она, конечно, крута, всё такое, но она не крош-платформенная.
5382.44 5395.56 "Игорь Лабутин" Райдер и EOS Code, они, типа, прекрасные IDE, но не настолько полнофункциональны по фичам, как Visual Studio, ну, буквально это звучало not as feature-rich as Visual Studio.
5395.56 5403.20 "Игорь Лабутин" И тут прям, как бы, в ответ к нему пришли ребята из Райдера со словами, а Райдер-то чё, как это?
5403.20 5404.20 "Анатолий Кулаков" Поясни за фичи.
5404.20 5405.20 "Игорь Лабутин" Поясни за фичи.
5405.20 5413.08 "Игорь Лабутин" А, причём у него ещё было, типа, написано, что типа likely by design, ну, то есть, типа, by design в Райдере фич меньше чем в Visual Studio.
5413.08 5418.88 "Игорь Лабутин" Ну, и, типа, Дэвид Фаулер ответил, да не-не-не, я не про то, что у вас там какие-то фичи не те и так далее.
5418.88 5459.40 "Игорь Лабутин" Он говорит про то, что, типа, это… В Visual Studio есть много фич what you refer to as bloatware, ну, то есть, типа, всякие нахрен никому не нужные фичи, да, bloatware, вот, которые Райдере никогда не будут в принципе, ну, просто по мейнсету и по дизайну Райдера, но при этом кастомеры почему-то юзают в Visual Studio, ну, то есть, типа, многие фичи такие интерпрайзные, знаешь, вот это вот, помнишь, мы обсуждали там, типа, возможность обновления как-то там интерпрайзно-неинтерпрайзно, чё-то в каких-то последних Visual Studio выкатывали, вот, нафиг никому не надо, наверное, но есть, наверное, те, кто
5459.40 5460.40 "Анатолий Кулаков" пользуются.
5460.40 5463.68 "Анатолий Кулаков" Ну, в общем… Да, я бы здесь перевёл фичи речь, как никому не нужные тормознутые охреньки.
5463.68 5464.68 "Анатолий Кулаков" Да.
5464.68 5465.68 "Анатолий Кулаков" Действительно, в Visual Studio их больше.
5465.68 5467.52 "Анатолий Кулаков" Да, вот таких вот много.
5467.52 5505.96 "Игорь Лабутин" Так, ну и, типа, да, мы проводим огромное количество времени для того, чтобы убедиться, что .NET работает отлично в команд-лайне, но кажется, этого недостаточно, вот, и, соответственно, мы, типа, заботимся о том, чтобы у нас была большая база разработчиков, типа, growing developer base, и не только про тех, которые сейчас уже в курсе про нас, вот, это всё юзают исторически, и мы хотим, типа, новых, вот, которые не будут расценивать Microsoft, как, значит, это компания, которая просто хочет денег за дорогие лицензии.
5505.96 5514.64 "Игорь Лабутин" В общем, посылы вроде бы ничё так, но как-то звучало не очень убедительно, там ему тоже накидали в комментах немножко.
5514.64 5516.84 "Игорь Лабутин" Короче, если вам вдруг интересно, почитайтесь.
5516.84 5527.36 "Игорь Лабутин" Очередные рассуждения вокруг, кто-то думает про .NET, в том числе ребята изнутри Microsoft, ну, вот, сходите туда в твиттер к Дэвиду Фаулеру, там все линки я в описании сложу.
5527.36 5535.32 "Анатолий Кулаков" Ну, мне как кажется, с технической точки зрения .NET впереди планеты всей, а вот маркетологи халтурят как раз-таки.
5535.32 5540.52 "Анатолий Кулаков" Такие вот, смотри, уже 10 лет прошло, а в мозгах у людей до сих пор сидят какие-то странные вещи.
5540.52 5542.04 "Анатолий Кулаков" Кто-то не дорабатывает.
5542.04 5543.04 "Игорь Лабутин" Да.
5543.04 5544.04 "Игорь Лабутин" Типа того.
5544.04 5550.20 "Анатолий Кулаков" Слушай, ты там и передай Фаулеру, чтобы он, наконец, блог себе завёл, как бы невозможно по твитам собирать какую-то информацию.
5550.20 5551.20 "Анатолий Кулаков" Скажи там.
5551.20 5554.56 "Игорь Лабутин" Да, ну, Витяй, он в теннис играет, да, в твиттер пишет.
5554.56 5558.52 "Анатолий Кулаков" Не, ну, у него гисты нормальные есть, там твиттеры нормальные есть.
5558.52 5559.52 "Игорь Лабутин" Можешь всё уже оформить.
5559.52 5560.52 "Игорь Лабутин" Он давно не писал, собственно, гистов.
5560.52 5561.52 "Игорь Лабутин" Вот.
5561.52 5563.56 "Игорь Лабутин" Не, ну, и спайр он, вон, видишь, как продвигает.
5563.56 5570.12 "Игорь Лабутин" Не, не сказать, что он не работает, понятно, что он делает, наверное, дофига, но на блог у него, похоже, времени совсем нет.
5570.12 5576.12 "Анатолий Кулаков" Да ладно, если на гитхаб документацию есть и на твиттер базворда есть, значит, можно это всё и в блог оформить.
5576.12 5577.12 "Игорь Лабутин" Вот-вот.
5577.12 5581.92 "Игорь Лабутин" Но он ориентируется на новое современное поколение, которое читает твиттер.
5581.92 5584.92 "Игорь Лабутин" Хотя, наверное, уже новое современное твиттер не читает, видимо.
5584.92 5588.08 "Анатолий Кулаков" Да, да, он тикток теперь смотрит, всё, тикток смирает
5588.08 5589.08 "Игорь Лабутин" уже.
5589.08 5590.08 "Игорь Лабутин" Тикток и прочие такие штуки, да.
5590.08 5591.08 "Игорь Лабутин" Фаулер там, по-моему, нет.
5591.08 5592.68 "Игорь Лабутин" Ладно, давай на сегодня заканчивать.
5592.68 5617.96 "Игорь Лабутин" UI-фреймворки мы сегодня сравнили, контейнеры мы сегодня обсудили, секьюрный для дотнет 8-го, про ченнелы и такой псевдо-месседж баз на основе них поговорили, долгая-длинная тема про то, как ваш solution раскладывать по файликам-папочкам обсудили, ну и кратко о разном действительно в этот раз получилось, довольно-таки о разном поговорить о многих мелких вещах.
5617.96 5622.12 "Игорь Лабутин" Ну, примерно так, 93-й выпуск, вот такой вот он, ждём-ждём
5622.12 5623.12 "Анатолий Кулаков" новых превью.
5623.12 5624.12 "Анатолий Кулаков" Отлично.
5624.12 5625.12 "Анатолий Кулаков" В принципе, да.
5625.12 5628.40 "Анатолий Кулаков" Всего желания, хорошенькие темы есть, надеюсь, вам понравилось.
5628.40 5636.88 "Анатолий Кулаков" О том, понравилось или не понравилось, обязательно пишите в комментариях, также давайте ссылочки вашим друзьям, чтобы им тоже было, что высказать, и что рассказать.
5636.88 5647.64 "Анатолий Кулаков" Шары или посты, колокольчики, мы всех ждём, все комментарии читаем, поэтому обязательно приходите, распространяйте, и всем до новых встреч, всем пока!
5647.64 5648.20 "Игорь Лабутин" Всем пока.
5648.20 5671.20 UNKNOWN [музыка]
