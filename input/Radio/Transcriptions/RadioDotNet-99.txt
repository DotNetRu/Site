0.00 11.36 "Анатолий Кулаков" - Здравствуйте, дорогие друзья, в эфире Радио.нет и выпуск номер 99.
11.36 14.20 "Анатолий Кулаков" В студии, как всегда, Анатолий Кулаков.
14.20 15.20 "Игорь Лабутин" - И Игорь Лабутин.
15.20 16.20 "Игорь Лабутин" Всем привет.
16.20 21.48 "Анатолий Кулаков" - А также за нашими спинами наши веселые помогаторы среди них.
21.48 39.52 "Анатолий Кулаков" Александр, Сергей, Владислав, Шевченко, Антон, Лазарев Илья, Гурий Самалин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Бальсим Альдживахири, Андрей Маслов, Дмитрий Павлов, Постарнаков Андрей.
39.52 41.92 "Анатолий Кулаков" Всем, друзья, огромное спасибо, что нас поддерживаете.
41.92 48.36 "Анатолий Кулаков" А для тех, кто не знает, о чем мы говорим, заходите на сайт Boosty и посмотрите, что у нас там есть для вас интересного.
48.36 53.20 "Анатолий Кулаков" Потому что кроме новостей мы тут барыжим еще чатиками и прочим интересным, да?
53.20 62.24 "Анатолий Кулаков" Но новости - это наша основная спецификация, поэтому не будем далеко уходить, посмотрим, что же случилось с миром дот-нета за время нашего отсутствия.
62.24 67.60 "Игорь Лабутин" Ну, не так, чтобы много случилось, мне кажется, но все-таки хоть какие-то новости есть.
67.60 69.40 "Игорь Лабутин" И начнем мы с Майкрософта.
69.40 73.96 "Анатолий Кулаков" Ну, с Майкрософта, может быть, не с самой веселой новостью, но, наверное, уже ожидаемой.
73.96 81.88 "Анатолий Кулаков" Наверное, многие из вас знают, Майкрософт передал Mono сообществу Vine, ну, то есть, по сути, закрыл, похоронил.
81.88 84.20 "Анатолий Кулаков" Можно это читать, наверное, так.
84.20 86.56 "Анатолий Кулаков" Давай разберемся, что же там, собственно, произошло.
86.56 90.60 "Анатолий Кулаков" Итак, Mono - это альтернативная реализация платформы дот-нет.
90.60 98.04 "Анатолий Кулаков" Она существовала, когда еще дот-нет не был кроссплатформенный, когда он позиционировался только под Windows, и нужна была какая-то альтернатива.
98.04 100.48 "Анатолий Кулаков" И вот такой альтернативной была Моно.
100.48 106.16 "Анатолий Кулаков" И компания Майкрософт объявила о передаче проекта под крыло организации Vine HQ.
106.16 112.04 "Анатолий Кулаков" Vine - это организация, которая пилит одна именную виртуальную, это же можно назвать виртуальной машиной, да?
112.04 123.08 "Анатолий Кулаков" Или там какая-то виртуализация, которая, по сути, позволяет под Linux или под совместимыми операционными системами запускать виндовые программы.
123.08 148.88 "Анатолий Кулаков" Там изначально проект задумался как запускальщик игр, потому что игры, ясное дело, движение всего прогресса, но потом как бы начали запускать одновременно и оконные приложения, все, что поддерживает Win API 32, и поняли, что это хорошая платформа, с помощью которой можно делать много великих вещей, с тех пор Vine цветет и пахнет, и до сих пор жив и здравствует.
148.88 158.52 "Анатолий Кулаков" Поэтому не то, чтобы такая организация типа Apache Foundation, куда все уходят умирать, но как там вообще оказался Моно?
158.52 159.52 "Анатолий Кулаков" Давайте подумаем.
159.52 165.76 "Анатолий Кулаков" Моно вообще, после того, как Майкрософт его приобрел, ну где-то с 2019 года, не выпускал какие-то значимые релизы.
165.76 173.32 "Анатолий Кулаков" Его основная цель была передать все кроссплатформенные наработки в .NET Core и в мобильные всякие изыски Майкрософта.
173.32 176.04 "Анатолий Кулаков" Как же тут дочутился Vine?
176.04 178.00 "Анатолий Кулаков" Все очень просто.
178.00 195.72 "Анатолий Кулаков" Моно использовался в Vine для запуска .NET приложений, которые там, естественно, писались под Windows, а так как Vine пытался запускать все приложения, которые написаны под Windows, вот он брал эти приложения, запускал их под Моно, и вот, пожалуйста, уже виндовая оплекуха у вас работает под Линуксом, и все счастливы.
195.72 214.28 "Анатолий Кулаков" Но не так все просто было, потому что были там какие-то проблемы с официальным Моно, поэтому Vine держал свой форк, который назывался Vine Mono, и регулярно его синкал, и также поэтому в форку выходили регулярные обновления, он каким-то образом развивался там и поддерживался.
214.28 227.96 "Анатолий Кулаков" Вот именно поэтому, то есть, получился, что Vine, вот этот эмулятор виндовых приложений, оказался самым большим потребителем Моно, или может быть самым весомым, или самым интересным, и самым активным, и саморазвивающимся.
227.96 232.44 "Анатолий Кулаков" Вот поэтому Микрософт решил отдать Моно сообществу Vine.
232.44 245.56 "Анатолий Кулаков" Репозиторию Vine Mono будет теперь считаться основным репозиторием для Моно, а репозиторий Моно будет переведен в архивный режим, останется только для чтения, и постепенно как бы все про него забудут.
245.56 261.00 "Анатолий Кулаков" Между тем, несмотря на то, что сам Моно уехал, Микрософт оставил за собой Моно Рантайм, и обязуется его сопровождать, он включен в официальный состав большого Дотнета, поэтому Рантайм остается с нами.
261.00 278.08 "Анатолий Кулаков" Для тех приложений, которые работали на Моно почему-то все это время, до сих пор все еще, Микрософт разумно рекомендует перейти на использование платформы Дотнет, потому что теперь она кроудплатформенная, и ни в каком альтернативном Дотнете никакого смысла нет.
278.08 287.80 "Анатолий Кулаков" В общем, ну, можно наверное считать, что это закат большого великого фреймворка, поэтому давайте кратко посмотрим его историю, а что же это все-таки было.
287.80 305.00 "Анатолий Кулаков" Итак, Моно был основан в 2001 году, довольно далеко, и когда еще Дотнет и не мечтала о кроудплатформенности, когда он всеми силами и всеми словами позиционировался только под Винду, а в Микрософте все верили, что Линукс и опенсорс это большое зло.
305.00 317.36 "Анатолий Кулаков" Мигель Дельказа и Нед Фридман организовали компанию, которая называлась Ксимиан, и в этой компании начали разрабатывать будущее Мона.
317.36 326.28 "Анатолий Кулаков" В 2003 году компания Ксимиан купила Новл, и первый релиз Мона вышел уже под крылом Новла в 2004 году.
326.28 338.80 "Анатолий Кулаков" В принципе, в Новле фреймворк довольно хорошо развивался, я помню эти релизы, они выходили часто, были интересными, какие-то новые идеи привносились, даже тех, которых в большом Дотнете не было.
338.80 342.16 "Анатолий Кулаков" В принципе, все было хорошо, вплоть до 2011 года.
342.16 351.84 "Анатолий Кулаков" В этот момент компания Новл покупает компанию Атачмэйт, и начинает оптимизировать процесс, и под сокращение попадают все разработчики проекта Мона.
351.84 361.56 "Анатолий Кулаков" Мигель Дельказа и Нед Фридман им это не понравилось, и они организовали свою собственную отдельную компанию, которую назвали Ксамарин.
361.56 377.00 "Анатолий Кулаков" И где-то через пару месяцев Атачмэйт передала Ксамарину все права на торговую марку Мона, все лицензии, и отказалась от всяческих прав и претензий, и поэтому Ксамарин единовластно стал Мона развивать, под эгидой оригинальных авторов.
377.00 384.24 "Анатолий Кулаков" И в 2016 году Мигель и Нед продали свой бизнес компании Майкрософт.
384.24 391.84 "Анатолий Кулаков" В принципе, продажа Майкрософту была сопряжена с хорошими тенденциями.
391.84 400.52 "Анатолий Кулаков" Ну, в частности, Мона сменила лицензию с LGPL на MID, что гораздо более свободная, более открытая лицензия.
400.52 413.32 "Анатолий Кулаков" Также много некоммерческих все, по-моему, некоммерческие компоненты, которые, все наоборот, проприетарные компоненты, которые были в Мона, то есть она состояла как из открытых частей, так и из каких-то закрытых, на которых зарабатывались деньги.
413.32 421.24 "Анатолий Кулаков" В общем, все вот эти закрытые компоненты Майкрософт открыла, в Open Source отдала их, и в принципе, начали всем пользоваться ими бесплатно.
421.24 427.16 "Анатолий Кулаков" Потом Мона перешел под эгиду некоммерческой организации .NET Foundation, под которой успешно развивался до сего момента.
427.16 449.32 "Анатолий Кулаков" А Майкрософт взяла полностью Мона под свою крышу, то есть гарантировала не применение никаких лицензий и патентов против тех лиц, которые Мона используют, разрабатывают, потому что там Enterprise'е юзают, в общем, полностью гарантировала юридическую неприкосновенность всем тем, кто любит Мона.
449.32 459.48 "Анатолий Кулаков" И вот, в сегодняшний день кажется, что Майкрософт из Мона вытянул абсолютно все, что только можно, все, что ему было нужно, по крайней мере, и остатки Мона отдал вайну.
459.48 463.76 "Анатолий Кулаков" Игорь, ты как, успел Мону попользоваться, или не приходилось?
463.76 477.72 "Игорь Лабутин" Нет, что-то было, мне нужно было что-то запускать на линуксах, и Мона я помню, что я ставил, и что-то как-то запускал, было такое, но это было уже много, не знаю, лет восемь-девять назад.
477.72 481.28 "Анатолий Кулаков" Ну, наверное, да, когда ещё как раз Доднар Кора не было.
481.28 488.52 "Игорь Лабутин" Ну, может, он даже тогда уже начинал, нет, подожди, Кора тогда девять лет назад, он, так он уже должен был начинать появляться.
488.52 489.52 "Игорь Лабутин" Может быть.
489.52 490.52 "Игорь Лабутин" Ну, может, да.
490.52 512.32 "Игорь Лабутин" Ну, может, я уже путаю, блин, тут старое, я уже много лет назад, короче, это было, я помню, что я запускал через Мону что-то, и через вайн я что-то запускал на линуксах, ну, да, пригождалось, но уже очень давно не пригождалось, что-то мне давно не хотелось запустить ничего на линуксе того, что нужно на винде, поэтому.
512.32 517.32 "Анатолий Кулаков" Ну, наверное, это хороший признак, да, того, что дотнет стал всё-таки кроссплатформенным, наконец-то.
517.32 526.80 "Игорь Лабутин" Ну, и дотнет стал кроссплатформенным, и, может быть, там, набор тулов, которыми, тулов стало достаточно много, чтобы найти те, которые работают в том числе под линукс, без необходимости.
526.80 528.16 "Анатолий Кулаков" Ты не настолько притязательный, да?
528.16 531.56 "Игорь Лабутин" Ну, да, привык, нашёл что-то, так что так, да.
531.56 541.96 "Анатолий Кулаков" Но всё равно, смотри, кажется, это не похожая ситуация, когда Microsoft купил какой-то продукт, подержал его и выкинул просто так, да, потому что все мы знаем, что Mono просто так не погиб.
541.96 557.16 "Анатолий Кулаков" Все его крутейшие специалисты, там, в том числе и Мигель Дель Каза, и другие участники рантайма, разработчики-программисты, они успешно перешли в команду дотнет, и там продолжают пилить прекрасные фичи, прекрасные оптимизации, прекрасные рантаймы.
557.16 564.60 "Игорь Лабутин" Ну, Мигель, я так понимаю, уже не пилит, вот, он всё-таки не в дотнете, но в целом, да.
564.60 569.64 "Анатолий Кулаков" Ну, да, да, трудится, на благо как бы человечества всё ещё в Микрософте, насколько я помню.
569.64 573.12 "Анатолий Кулаков" По карамели никуда не уходил, то есть там всё ему нравится, всё ему хорошо.
573.12 575.00 "Игорь Лабутин" Ну, где-то рядом, да, где-то вон там.
575.00 586.08 "Анатолий Кулаков" Ну, опять же, дотнеткор взял из Mono очень многое для того, чтобы стать крупплатформенным, не знаю, что они там с мобилками будут делать, то есть, по сути, Mono, мне кажется, оставался актуальным только для мобилок.
586.08 592.12 "Анатолий Кулаков" Теперь, наверное, с помощью dotnet.my.ua они будут как-то и мобильную историю закрывать, но посмотрим, опять же.
592.12 604.96 "Анатолий Кулаков" Моно, мне кажется, всё, своё отжил и отдал всё самое лучшее, что у него было в основной дотнет, и дальше его дело будет жить и процветать, мне кажется, всем нам во благо.
604.96 605.96 "Анатолий Кулаков" Ну, да.
605.96 612.32 "Анатолий Кулаков" Так что, да, спасибо большое, старичок Mono, покойся у Вани, а там, кто его знает, может, Вань сейчас что-нибудь ещё интересное с ним придумает.
612.32 613.32 "Анатолий Кулаков" Будем следить за новостями.
613.32 616.36 "Игорь Лабутин" Ну, мало им не взлетит, они что-нибудь ещё такое сделают.
616.36 619.00 "Анатолий Кулаков" Да, и Вань продаст его за много-много денег в Микрософт
619.00 620.00 "Игорь Лабутин" опять.
620.00 621.76 "Игорь Лабутин" Ну, чтобы забрать все остатки.
621.76 622.76 "Игорь Лабутин" Ну, ладно.
622.76 638.68 "Игорь Лабутин" Давай дальше пойдём, действительно, возвращаясь, ну, не возвращаясь, говоря про кроссплатформенный дотнет, у нас на носу, ну, или не на носу, но довольно скоро будет выход полноценной девятой версии нашего кроссплатформенного дотнета, а пока мы смотрим на превьюшки.
638.68 647.24 "Игорь Лабутин" И последнее превью, которое нам сейчас доступно, это dotnet preview 7, оно вышло уже довольно давно, но мы не успели ещё её обозреть, поэтому посмотрим.
647.24 659.48 "Игорь Лабутин" И внезапно в анонсе dotnet preview 7 нету ничего про это, но если посмотреть внимательно релиз ноута, то там даже закралась одна фича C#.
659.48 662.40 "Игорь Лабутин" Заметил ты это или нет?
662.40 663.40 "Анатолий Кулаков" Нет.
663.40 666.12 "Игорь Лабутин" Я даже не видел вообще ни обсуждения этой фичи.
666.12 688.48 "Игорь Лабутин" Короче, ребята из C#, ну, это нужно только как бы в супер нишевых случаях, как обычно в современном C#, но у нас появился новый атрибут, атрибут называется overload resolution priority, и он влияет на то, как рослин в момент компиляции будет выбирать, какой метод вашего класса вызвать.
688.48 704.92 "Игорь Лабутин" Ну то есть у рослина же есть некоторое количество правил применения, правил того, как резолвиться вызовы, если у вас есть несколько вариантов, понятно, да, там типа точное совпадение типов, возможность неявного приведения типа, возможность явного, возможность боксинга, все, сложная система.
704.92 722.00 "Игорь Лабутин" Вот, теперь вы, если у вас есть несколько кандидатов, то раньше было некоторое, ну вот зашитое в компилятор правило про то, какой вариант лучше, но теперь вы можете использовать атрибут overload resolution priority в вашем коде, чтобы компилятор выбирал другие варианты.
722.00 730.00 "Анатолий Кулаков" Ну, что-то мне кажется, это больше непредсказуемости добавит, там хотя бы был большой алгоритм, но он был понятный и выверенный и точный, а здесь как бы...
730.00 756.88 "Игорь Лабутин" Ну, я так понимаю, что здесь, короче, эта штука, ну, по крайней мере, они у себя это в примерах приводят, они начали это использовать в BCL, она в основном для deprecated методов, то есть, грубо говоря, ну, по крайней мере, пока, да, то есть, если у тебя был метод, который хорошо подходил, да, в большинстве случаев, но его пометили deprecated, то с помощью этого атрибута, я так понимаю, его можно подвинуть в конец очереди предлагаемых вариантов, чтобы компилятор его старался не выбирать.
756.88 761.04 "Анатолий Кулаков" Так, а код, который этот метод раньше использовал, теперь что будет использовать?
761.04 762.04 "Анатолий Кулаков" Непредсказуемый новый метод?
762.04 763.04 "Анатолий Кулаков" Ну, да, какой-то другой, более подходящий.
763.04 764.04 "Анатолий Кулаков" Ну, я не хочу, это мегабарикенчастище.
764.04 768.40 "Анатолий Кулаков" Ну, тот же deprecated, короче, ну, в общем, да, короче, такая
768.40 792.92 "Игорь Лабутин" штука прошла вообще незамеченной, я нигде не видел её обсуждения, вот только копаясь по релиз-ноутам, я его нашёл, вот, и это единственное, что про C# сказано вот в этом превью, побольше про другие части, значит, в libraries мы уже обсуждали binary-форматор, всё, его нету в седьмом превью, значит, потому что безопасность, вот это всё.
792.92 823.12 "Игорь Лабутин" Появился способ, если у вас есть read-only-span, вдруг из строчки, например, созданный или откуда-то, то раньше не было функции split на нём, то есть вам, если вы хотели делать split, а это довольно частое операция, если вы что-нибудь парсите, то нужно было зааллоцировать строчку, нужно было на ней написать split, это снова аллокация, вот это всё, хотя, ну либо писать уже руками свой такой, как это, домашний split на каких-нибудь индексах и так далее.
823.12 833.40 "Игорь Лабутин" Вот, теперь есть метод read-only-span.split, который, понятно, возвращает range и ничего не аллоцирует, в общем, ещё больше оптимизаций, богу оптимизаций.
833.40 859.16 "Игорь Лабутин" Debug assert, если вдруг кто-то пользуется этим методом, он в assertion пишет не просто, что assertion failed, а прям что failed, то есть всё выражение, которое вы передали в дебаг assert, там boolean аргумент требуется, он теперь будет записан полностью в виде выражения, но это делается с помощью атрибута caller member, как там он, caller member?
859.16 860.16 "Анатолий Кулаков" expression, по-моему.
860.16 864.08 "Игорь Лабутин" То ли caller member name, или как-то так, что-то я уже не помню.
864.08 865.08 "Анатолий Кулаков" Caller member expression.
865.08 870.88 "Игорь Лабутин" Или expression, в общем, я им ни разу не пользовался, скажу в своём коде, или как-то один раз его...
870.88 874.68 "Анатолий Кулаков" Не прошло и 3 релиза, как решили стандартную библиотеку строить.
874.68 882.20 "Игорь Лабутин" Не, он где-то ещё был, он точно был в этих самых, понятно, во всяких юнитестовых фреймворках использовался, там сам бог велел, да.
882.20 888.84 "Анатолий Кулаков" Ну потому что они не микрософтом поддерживаются, поэтому там бы быстрее сообразили, а здесь тянули, тянули.
888.84 898.16 "Игорь Лабутин" Ну может, кстати, и в mstest-е такое было, я уже не помню, а в bcl-е вот добавили в дебагасёрты.
898.16 899.16 "Игорь Лабутин" Дальше.
899.16 923.32 "Игорь Лабутин" Всякие API-ки про компрессию, то есть всякие zlib, gzip и прочее используют теперь кроссплатформенную библиотечку zlib-ng, видим это new generation, которая вся такая оптимизированная, кроссплатформенная в том плане, что у неё есть сборки для всех платформ, она на C, но теперь универсальное поведение на всех одинаковое и быстрое, хорошее и современное.
923.32 924.32 "Игорь Лабутин" Дальше.
924.32 944.36 "Игорь Лабутин" Добавили поддержку создания uuid-ов версии 7, надо, кстати, может нам будет как-нибудь поговорить про разные uuid-ы, сколько их бывает, какие они версии, но смысл в том, что у нас есть тип system.guid, там генерируется guid, это не то же самое, что uuid, это uuid, но в вариации майкрософта.
944.36 978.16 "Игорь Лабутин" Он исторически был создан таким, потому что таким он был полезен для com, если кто-то еще помнит, да, Component Object Model, но при использовании его во всяких базах данных и местах, где нужно что-то чуть более предсказуемое и, возможно, поддерживающее некоторую монотонность, да, назовем это так, лучше подходит uuid-версии 7, который для этого и создавался, вот теперь есть метод, который называется guid.createversion7, который, собственно, создает guid-ы, они же uuid-ы версии 7.
978.16 987.64 "Анатолий Кулаков" Слушай, а почему нормальные guid-ы, те, к которым мы привыкли, старенькие, они создаются guid.newguid, а вот это createversion7?
987.64 988.64 "Анатолий Кулаков" Не знаю.
988.64 992.40 "Анатолий Кулаков" Где ваша договоренность, где ваши правила, где ваша семантика?
992.40 993.40 "Игорь Лабутин" Нужно было new7, да?
993.40 998.60 "Анатолий Кулаков" Да, какой бы newguid7 там или newguidversion7, уже будет даже
998.60 999.60 "Игорь Лабутин" так.
999.60 1001.16 "Игорь Лабутин" Не знаю, может это новый паттерн такой.
1001.16 1003.64 "Анатолий Кулаков" Хорошо, вот запусти старый задеприкейтинг, что это
1003.64 1004.64 "Игорь Лабутин" за безобразие?
1004.64 1006.96 "Игорь Лабутин" Деприкейтить, полкоду сломаешь, нельзя деприкейтить гуиды,
1006.96 1007.96 "Анатолий Кулаков" ты что?
1007.96 1012.20 "Анатолий Кулаков" Ну хотя бы сделали бы еще один алиэс для старого метода, чтобы можно было в новом коде было использовать.
1012.20 1032.80 "Игорь Лабутин" Да, в общем, история такая интересная, там если почитать все issues вокруг этой штуки, там прям огромные халевары были на тему того, как это нужно сделать, нужно ли это сделать отдельным типом, нужно ли это сделать в том же типе, нужно ли как-то что и как запрещать, там интересно, почитайте.
1032.80 1056.44 "Игорь Лабутин" Проблема в том, почему все это возникло и почему потребовался наш отдельный метод, потому что гуид внутри хранит в себе порядок байт не в том порядке, как он должен бы представляться в байтовом представлении, потому что он хранит не просто массивом из 16 байт, а с помощью полей типа long, int, byte и вот это все, и поэтому влияет тот самый endian, little endian, big endian.
1056.44 1060.00 "Анатолий Кулаков" Ну что значит должен, микрософт так видит, микрософт должен
1060.00 1061.00 "Игорь Лабутин" в другом порядке.
1061.00 1064.44 "Игорь Лабутин" Нет, это самое телькое, сейчас я тебе больше скажу.
1064.44 1090.96 "Игорь Лабутин" Это даже по RFC, потому что в RFC написано, есть штука, RFC на uuid так и говорит, смотрите, есть uuid, есть uuid версии 1, uuid версии 2, uuid версии 3, uuid версии 4, ну теперь добавили вот 5, 6, 7, а если стоит вот этот битик, там он какой-то не помню по счету, 18-ый битик, то это Microsoft версия uuid, которую все называют uuid, там прямо в RFC написано, если стоит бит, это Microsoft версия, и короче, это другая
1090.96 1091.96 "Анатолий Кулаков" вещь.
1091.96 1093.64 "Анатолий Кулаков" Ну, значит, микрософт прекрасно поддержал версию uuid.
1093.64 1096.48 "Игорь Лабутин" Ну, там есть, да, тонкости, вот.
1096.48 1104.92 "Анатолий Кулаков" Тут если начать копаться, неизвестно, кто первый появился, RFC или ком, поэтому, может, не в пользу RFC вообще все это будет, должны были RFC под ком писать, а не наоборот.
1104.92 1124.80 "Игорь Лабутин" Не-не-не, uuid все-таки появились раньше, мне кажется, но в общем, есть там понятные практически проблемы с использованием uuid, как они сейчас реализованы были в Microsoft, именно поэтому отдельный метод и потребовался, который создает их в нужном порядке, чтобы у них бинарное текстовое представление было одинаковым, и sort order был хороший.
1124.80 1130.88 "Анатолий Кулаков" Ну, мне кажется, все-таки главная причина это не для того, чтобы RFC угодить, а для того, чтобы сделать все-таки sort of uuid.
1130.88 1135.24 "Игорь Лабутин" Ну, да, да, sort of uuid, который полезен для работы с современными BD.
1135.24 1136.24 "Игорь Лабутин" Это так.
1136.24 1143.40 "Игорь Лабутин" Ну, и не только с BD, на самом деле, но primary ключ BD — это один из первых кандидатов, понятное дело, на это.
1143.40 1163.40 "Игорь Лабутин" Дальше, interlock compare-exchange, расширилась поддержка еще нескольких типов, теперь их можно делать для байтов, short-ов и так далее, плюс в generic версии убрали всячески разные constraints, то есть раньше там был constraint varp, id и class, то есть можно было только reference-типы использовать, теперь туда можно вообще чего угодно запихивать.
1163.40 1175.72 "Игорь Лабутин" Я не знаю, поставили ли туда allow-refstruct, можно ли там interlock compare-exchange на спанах делать, ну, может и можно, черт знает, не смотрел.
1175.72 1191.84 "Игорь Лабутин" Для сертификатов, если вы работали с сертификатами, вы, наверное, знаете, что это большая мороха иногда их загрузить нормально, в коде есть замечательный класс X.509.certificate2, который, в принципе, это умеет делать, но там есть тонкости.
1191.84 1214.16 "Игорь Лабутин" В общем, проблема с ним в том, что он, во-первых, работает на содержимое сертификатов, чтобы пытаться понять, а содержит ли он что-то, что похоже на сертификат и может ли X.509.certificate2 с этим поработать, плюс поведение этого класса немножко различается на разных операционных для разных типов сертификатов.
1214.16 1228.28 "Игорь Лабутин" Поэтому в 2.9 появился новый класс, он называется X.509.certificateloader, который, соответственно, работает одинаково на всех платформах, правда пока поддерживает всего два формата из пяти, но тем не менее, видимо, это будет расширяться.
1228.28 1253.16 "Игорь Лабутин" Причем, если вы не хотите больше пользоваться X.509.certificate2 загрузкой, которая по некоторым причинам может быть небезопасна из-за того, что она смотрит на эти содержимые сертификаты перед тем, как их реализовать, то этот класс доступен вам в отдельном пакете Microsoft BCL Cryptography, в том числе в дотунет фреймворке и в старых версиях дотунета, поэтому можно его тоже использовать.
1253.16 1273.76 "Игорь Лабутин" На поприще Security довольно много всяких разных изменений, в OpenSSL появилась поддержка провайдеров, в 8.NET появились API, которые специфичны для OpenSSL, они называются save-evpkhandle.openprivatekeyfromengine и openpublickeyfromengine, соответственно.
1273.76 1277.24 "Игорь Лабутин" Они позволяют работать с так называемыми OpenSSL-энджинами.
1277.24 1287.64 "Игорь Лабутин" Это нужно для того, чтобы работать, например, с хардварными модулями, ну то есть там вот эти подключаемые ключики или еще что-нибудь в таком духе, юсбишные всякие.
1287.64 1294.62 "Игорь Лабутин" А в 9.NET появился теперь метод, называется openkeyfromprovider, который позволяет теперь включить разных провайдеров для OpenSSL.
1294.62 1301.84 "Игорь Лабутин" Это позволяет еще больше расширить то, с чем вы можете из кода работать с точки зрения хардварных модулей.
1301.84 1307.38 "Игорь Лабутин" Поэтому если вы вдруг работаете с хардварными модулями в плане Security, может быть это будет вам полезно.
1307.38 1334.38 "Игорь Лабутин" И довольно большое изменение, мы много говорили про то, что вот там тензор и тензор примитив, там же была огромная работа, много API, вот они в статье пишут, что примерно там шестьсот новых public API было завезено вот за счет этого тензора T, generic_tip и все такое, но поскольку их очень много, и кажется, что Microsoft начинает сомневаться, а было ли это все полезно и в том виде, в как оно было сделано.
1334.38 1353.14 "Игорь Лабутин" Короче, весь тензор T теперь помечен как experimental для девятки, и они надеются, что они получат достаточный фидбэк за время, пока там будет зарелизжена и будет в эксплуатации девятка, ну первые, видимо, там полгодика, чтобы к десятке это все финализировать и уже убрать experimental и сделать API в том виде, в котором она пойдет в релиз.
1353.14 1355.70 "Игорь Лабутин" То есть она в релизе будет, но помечена experimental.
1355.70 1366.74 "Игорь Лабутин" А если она помечена experimental, напоминаю, что для того, чтобы эта хитча работала, вам нужно в csproj тоже ставить флажок, как он там, allow_experimental или enable_experimental, как-то так.
1366.74 1370.42 "Игорь Лабутин" И транзитивно его дальше расставлять по всем остальным.
1370.42 1373.26 "Игорь Лабутин" Так что вот, это у нас по библиотекам.
1373.26 1378.46 "Игорь Лабутин" Не мало, но, в принципе, такие нормальные изменения для библиотек, мне кажется.
1378.46 1381.98 "Игорь Лабутин" В ASP.NET Core тоже есть некоторое количество изменений.
1381.98 1412.86 "Игорь Лабутин" SignalR допилили до поддержки Dreaming и Native, а вот она все еще не совсем полная, она поддержана для клиента и для серверных сценариев, она только поддерживает JSON-протокол, и дальше есть некоторое количество ограничений, не поддерживаются строго типизированные хабы, нельзя использовать всякие там async_numerable или channel_reader_t, если t - это value_type, ну то есть такие довольно нишевые, может быть, штуки, но в базовом сценарии вероятно работают.
1412.86 1422.78 "Игорь Лабутин" Также Dreaming и Native, а вот поддерживается в новом Microsoft ASP.NET Core OpenAPI кусочки, которые поддерживают, собственно, OpenAPI-спецификации по вашему коду.
1422.78 1453.66 "Игорь Лабутин" Для того, чтобы вся эта OpenAPI-машинерия работала, вам же нужно правильно размечать все ваши endpoints, для Minimal API для этого служат методы, в том числе produces_problem или produces_validation_problem, которые позволяют указать, какие, собственно, ошибки могут быть на выходе, теперь вы можете эти методы использовать на группах, то есть route-группы, когда вы пишете map_group в Minimal API, вы теперь можете прямо на всю группу сказать вся группа может там какие-то ошибки выдавать, если у вас вся группа выдает примерно одинаковые.
1453.66 1461.70 "Игорь Лабутин" Так, поддержано Pushed Authorization Requests для OpenID Connect Handler.
1461.70 1541.90 "Игорь Лабутин" Это какая-то новая надстройка над OAuth или дополнение или развитие OAuth, поэтому если вы, смотрите, занимаетесь авторизацией и знаете, что такое Pushed Authorization Requests, я особо не вчитывался, то вот такая штука теперь поддержана в OpenID Connect Handler в .NET, можно теперь кастомизировать name pipe и endpoints в Kestrel, у Kestrel улучшили метрики connections, в смысле, когда Kestrel сообщает наружу, сколько длилась той или иной connection, в метриках он заодно пишет причину, почему она оборвалась, и для некоторых, а что-то по endpoints, можно сделать так, что Kestrel не будет собирать, ну Kestrel и Aspirant Core в целом не будет собирать и репортить наружу метрики, ну например, если вам не интересно метрики на health-чеках, вы теперь можете либо туда вановесить атрибут прямо на контроллер, disable http metrics, либо, если вы используете minimal API, вызвать метод disable http metrics, либо вообще через ihttp-metrics.txt feature сделать так, что можно прямо написать middleware, которая будет в рантайме выбирать нужно ли на этом endpoint, конкретно на этом даже запросе, посылать метрики о том, что этот запрос выполнен или нет.
1541.90 1546.90 "Игорь Лабутин" То есть можно посмотреть там на контент запроса и по нему не посылать метрики, зачем-то, если вам вдруг такое нужно.
1546.90 1561.74 "Игорь Лабутин" Так, ну и для exception-handler-middleware появился теперь там специальная полечка, называется status-code-selector, в настройках которой позволяет по exception, исходя из exception, выбрать какой же статус вернуть.
1561.74 1565.54 "Игорь Лабутин" Вдруг вы хотите разные статусы возвращать по разным поводам.
1565.54 1606.86 "Игорь Лабутин" Это все про expended-core и последний кусочек это maui, в этот раз в maui прям ну не только performance и bug-fixing, значит здесь они добавили hybrid webview-control, эта штука позволяет просто хостить произвольный html, gs, css, что угодно внутри webview и при этом взаимодействовать этим кодом с тем, который у вас, значит, который хостит это самое webview, да, т.е. c-sharp.net, для десктопа, про который все, значит, потихонечку, не то что вспоминают, но мы помним историю, что maui внезапно выяснили, что ой, а для десктопа оказывается нужно много чего, вот они это много чего потихонечку доделывают.
1606.86 1661.86 "Игорь Лабутин" Добавили title-bar, добавили возможность работы с окошками в плане, что там activate-window для того, чтобы окошко вытаскивать в foreground, т.е. на передний план на десктопе, немножко поменяли там внутренности, не буду сейчас вдаваться в подробности про всякие там, main-page теперь нельзя использовать, надо использовать просто page, ну и если вы разрабатываете на маке, то появился тун под названием xcode-sync, который позволяет работать в visual studio код, например, на маке с вашим .net-ным солюшеном с maui, но если вы пишете для macos, ну или для ios, соответственно, у вас есть некоторое количество артефактов, которые специфичны конкретно для macos и с ними лучше работать через xcode, ну вот соответственно этот тул позволяет правильно синхронизировать какие-то проектные моменты, что то, что вы поменяете в xcode будет нормально воспринято, тут на этом и наоборот.
1661.86 1672.14 "Игорь Лабутин" Ну вот какой-то такой у нас вышел превью 7, подозреваю, не уверен, но подозреваю, что это, наверное, последний превью, дальше будут релиз-кандидаты.
1672.14 1685.18 "Игорь Лабутин" Потому что уже вроде как сентябрь начался, тут осталось 2 месяца до релиза, так что я думаю, что парочку релиз-кандидатов и все, в которых, скорее всего, ничего нового и интересного не будет.
1685.18 1686.18 "Анатолий Кулаков" Но посмотрим.
1686.18 1693.30 "Анатолий Кулаков" Да, если не считать C#, то в принципе нововведений довольно хорошо набрасывается, но с C# конечно беда, беда.
1693.30 1710.02 "Анатолий Кулаков" Ладно, давай посмотрим что-нибудь еще из нововведений от микрософта, в частности от Nuget, хотелось бы подробнее остановиться на такой фишке Nuget'а, как аудит, security audit, потому что security audit в package-менеджерах это довольно важная часть, важная часть любого процесса.
1710.02 1729.46 "Анатолий Кулаков" К чему это, это когда у нас в пакетах находятся уязвимости, а уязвимости находятся практически во многих пакетах, не только напрямую, например, если вы используете как пакет, но и в какой-то зависимости, которая может притащиться через 20 каких-то там рукопожатий, но она в ваш проект залетит.
1729.46 1742.98 "Анатолий Кулаков" И было бы неплохо, как только в этих пакетах, в этих зависимостях находятся какие-то уязвимости, об этом или сообщать разработчику как минимум, или там блокировать этот пакет или еще что-то с ним делать, каким-то образом реагировать.
1742.98 1780.38 "Анатолий Кулаков" И вот Nuget может проводить security audit, более того он это делает в момент команды .NET restore, то есть в тот момент, когда вы ресторите пакеты, все ваши зависимости проверяются и проверяются они через список известных уязвимостей в базе, которая называется GitHub Advisory Database, это хорошая база по уязвимостям, которая поддерживает GitHub и там есть естественно не только Nuget, там довольно много собрано пакетов, не только .NET, и для различных package-менеджеров, очень многим package-менеджерам, в том числе сам GitHub пользуется этой базой данных, что в принципе прекрасно.
1780.38 1804.22 "Анатолий Кулаков" И если вдруг .NET или Nuget найдет уязвимость в вашем проекте, у вас есть несколько вариантов, ну во-первых вы можете обновить пакет на ту версию, где эта security уязвимость уже пофикшена, или если она вдруг еще почему-то не пофикшена, то добрый Nuget подскажет вам альтернативные пакеты, которые в принципе могут заменить данный нерадивый, который не следит за своими security уязвимостями.
1804.22 1965.46 "Анатолий Кулаков" Чтобы Nuget audit заработал, вам нужен .NET SDK 8 как минимум и немножко поднастроить свой проект, в частности вы должны в проекте разрешить Nuget audit, вы должны выбрать мод, то есть режим, режимы есть проверять только прямые зависимости или транзитивные тоже, также вам необходимо вызвать, то есть указать уровень тех проблем, тех issues, которые вы будете искать, можно выбрать low moderate, high critical, если вы не хотите допустим на какие-то мелкие security уязвимости обращать проблемы, потому что low уязвимости они в большинстве случаев никакой опасности не предоставляют, вот можете для себя этот уровень тоже подогнать как вам угодно, ну и если вы допустим хотите, чтобы security уязвимости вам рушили билд, допустим или, то их можно внести в список warning as errors, тогда эти warning будут выдавать ошибки, или если вы хотите, чтобы билд рушился только допустим при релизном билде или только на CI-системах, это тоже можно настроить через MS Build Condition, если вы просто хотите проверить ваш проект, если там сейчас уже текущие уязвимости или что там происходит, для этого есть тоже отдельная команда .netlist package --vulnerable, и если вдруг вы не хотите по какой-то причине фиксить security уязвимости, допустим, вавтор еще не зарелизил для них какую-то новую библиотеку и при этом ваш код падает, потому что вы как порядочный гражданин указали warning as error глобально для всех ваших проектов, и поэтому данные предупреждения Nuget они тоже будут превращаться в ошибки, в общем это тоже можно решить, можно несколькими способами, во-первых есть директива no-warn, который указывается прямо к package reference, к элементу package reference, то есть вы для каждого пакета можете указать о каких проблемах, не нужно вам сообщать, вы их знаете, вы их успешно игнорируете, или вы можете указать общий директив, который называется warning not as errors, где перечисляются как раз таки все, все, все warning, которые вы не хотите считать эррорами для всех ваших проектов, в общем стандартный тоже функционалист, который тоже может вам помочь, в общем такой полезный инструментик, если у вас андроид почему-то не настроен или вы не обращаете на него внимания, то посмотрите, потому что за security уязвимостями и за вашими пакетами нужно обязательно следить.
1965.46 1983.78 "Игорь Лабутин" Это точно, а то мало ли что там подложат, каким-нибудь вредоносным кодом, и никто не посмотрит, это вам не github, который там может предупредить об уязвимости, поэтому лучше, лучше смотрите сами, ну точнее через тулы конечно же.
1983.78 2043.66 "Игорь Лабутин" Давай дальше, дальше у нас Visual Studio, Visual Studio финализировалась версия 17.11 General Availability, мы уже много раз упоминали, что там вышло, какие изменения были, Microsoft тоже разродился горой статей про разные всякие аспекты новой Visual Studio, ну как новой, которая выходила, много разных превью, кратко перечислю, что можно теперь чуть лучше искать код, можно сужать скоуп, поиск там текущего документа, текущего проекта или еще как-то, немножко поменяли шорткаты для клавиатуры, из всяких замудренных для частых операций, типа комментировать, раскомментировать строчку, использовали более популярные из других EDEs, типа там Control Slash или похожих, VSConfig файлы еще лучше поддерживаются, чтобы всякие расширения ставить, отладка улучшилась, всякие там visualizers, профайлить экстернл код, ну и так далее, ну и для дотнета ресурс эксплодер новый подвезли, который более интересный и полезный.
2043.66 2082.74 "Игорь Лабутин" При этом вышло, как обычно, 17.12 превью 1, первая версия очередной итерации Visual Studio, и там есть некоторые такие интересные штуки, в разделе Productivity там соответственно фича под названием Copy from Error List, когда у вас что-то собралось в студии, у вас появилось окошечко Error, это табличка с ошибками, раньше копировалась полная строчка, теперь там есть в менюшке, и может быть есть кибер на это, просто пунктик на тему скопировать только описание ошибки, чтобы сразу можно было загуглить именно описание ошибки, всяких там номеров строк, имен файлов и так далее.
2082.74 2083.74 "Игорь Лабутин" Просто киллер фичи.
2083.74 2094.62 "Игорь Лабутин" Вообще киллер фичи, ну я так понимаю, что там Мэдс Кристенсен быстренько это, все что он хотел делать в экстенджерах, теперь пилит в основной, такое ощущение, что его взяли на работу Visual Studio, он теперь это может не экстенджерами пилить, а прям Visual Studio фичи добавлять.
2094.62 2098.38 "Анатолий Кулаков" И это не самая плохая идея, я тебе хочу сказать, давно
2098.38 2099.38 "Игорь Лабутин" пора.
2099.38 2110.50 "Игорь Лабутин" Потому что у него же гора всяких мелких экстенджеров, которые делают какие-то простейшие штучки, и он их сейчас, он не он, не знаю, впиливает в основную студию.
2110.50 2124.54 "Игорь Лабутин" Дальше CodeSearch немножко тоже улучшился, теперь там можно переходить по номерам строк, в любом файле, в смысле можно прямо там набрать имя класса, имя файла, нужная строка, и он туда перейдет.
2124.54 2130.42 "Игорь Лабутин" Само CodeSearch окошко можно теперь докать в нужное место, а не только по папкам держать.
2130.42 2139.38 "Игорь Лабутин" Автоматически, если вы переименовываете файл иконы в Git, он постарается там правильно все застейджить, чтобы Git тоже про это узнал, и вы не забыли это закоммитить.
2139.38 2160.90 "Игорь Лабутин" Шаблончики pull-requests, но это неинтересно, в IDE разделе можно теперь настраивать разные профили, запуска многопроектного запуска, да, это когда вы там идете в настройки solution, да, solution или всяких там конфигураций, где вы настраиваете, что будет run, что debug, вот это все.
2160.90 2163.70 "Игорь Лабутин" Там теперь можно несколько профайлов прямо из студии создавать, записывать.
2163.70 2168.10 "Игорь Лабутин" Это все в launch settings, я так понимаю, пишется Jason.
2168.10 2179.38 "Игорь Лабутин" Visual Studio теперь будет предупреждать, если вы открываете проект из небезопасного места, то есть скачали что-нибудь там, склонировались в GitHub, открыли в студии, студия скажет, ай-яй, код из интернета, то есть ты ему доверяешь.
2179.38 2183.02 "Игорь Лабутин" Или нет, не знаю, как определяет, но видимо как-то пытается.
2183.02 2189.66 "Игорь Лабутин" Какие-то улучшения для десктопа небольшие, для веба, в http файлах, вот это, кстати, важная, наверное, штука изменения.
2189.66 2200.94 "Игорь Лабутин" Есть такой формат файлов, да, http файлов, которые позволяют в плей интексте в таком, ну не маркдауне, но что-то близкое, писать http запросы и прямо оттуда их исполнять.
2200.94 2205.90 "Игорь Лабутин" Это все пошло из довольно популярного экстенджена на Visual Studio Code, который называется REST Client.
2205.90 2218.26 "Игорь Лабутин" В Visual Studio и прошлой версии появилась некоторая базовая поддержка по ссылке реквестов, но там не было очень важной фичи, а именно нельзя было использовать ответ одного реквеста для инпута из другого, ну в другом реквесте.
2218.26 2229.82 "Игорь Лабутин" А это очень типичный сценарий, первый запрос, авторизация, да, в ответе ты получаешь токен, а вот модификация, точнее обычный, получаешь токен, который нужно использовать во всех остальных запросах дальше в этом файле, вот теперь это поддержано.
2229.82 2234.18 "Игорь Лабутин" Поэтому если вы пользовались http файлами в студии, вот теперь это прямо можно использовать нормально.
2234.18 2257.58 "Игорь Лабутин" И те самые, как это по-русски называется, inlay hints, короче это конечно все всплывающие такие с сереньким или каким они там цветом, в зависимости от вашей схемы, подсказки там около варов, какие там типы, вот это все, они теперь добавлены для всяких JavaScript, TypeScript, Python и внезапно Razor.
2257.58 2262.10 "Игорь Лабутин" Ну в общем, всякие хинты для этих четырех языков появятся.
2262.10 2272.34 "Игорь Лабутин" Ну а для .NET единственный раздел это тот самый аудирование пакетов, про которые Толя рассказал, соответственно вот это все там есть в UI-чике.
2272.34 2284.70 "Игорь Лабутин" Ну вот примерно такая студия, то есть пока какие-то мелочи, ничего прорывного, ничего супер такого важного и нужного и срочного, но это превью 1, дальше поглядим, куда все будет.
2284.70 2287.42 "Анатолий Кулаков" Да, да, вроде потихонечку развивается, тоже хорошо.
2287.42 2304.02 "Игорь Лабутин" Ну именно что потихонечку, у меня нет ощущения, что они к релизу девятому прям что-то хотят зарелизить, такое ощущение, что студия сейчас живет, ну немножко не в ритме, так скажем, потому что странно было бы релизить, ну сейчас за 2 месяца быстренько сделать следующую версию, что-то как-то не верится в это.
2304.02 2306.06 "Анатолий Кулаков" Скорее всего, да.
2306.06 2360.70 "Анатолий Кулаков" Хорошо, давай еще, за это время прозвучал огромный интересный пропозал, который наконец называется TypeUnions for C#, давай его обсудим, пропозал был опубликован на гитхабе и описывает дискриминацион юнионы для C#, автором пропозала казан Мэтт Уоррен, который работает в микрософте, мы так немножко поштудировали, это не очень похоже на Мэтт Уоррена, который мы все знаем, но вроде какой-то товарищ Мэтт Уоррен, для нас это не важно, для нас более важно, что это наконец-то сотрудник микрософта, потому что до этого дискриминацион юнион в C# предлагали уже, не знаю, больше 10 лет точно, и предлагали их всякие энтузиасты, в основном оголтелые F#исты и прочие функциональщики, потому что там это first-class citizen с самых начала времен, ну хотя нет, их там не с самого начала, но все же.
2360.70 2389.50 "Анатолий Кулаков" Вот, и наконец-то какой-то сотрудник микрософта решился написать пропозал на дискриминацион юнион, что якобы намекает, что микрософт это уже все одобрил и внутри они наконец-то сами с собой договорились, и может быть мы все-таки в каком-то приближении когда-нибудь через несколько релизов это получим, это наверное одно из самых ожидаемых изменений в языке C# за много-много-много-много релизов, потому что я не вспомню, что такого выходило у нас.
2389.50 2399.58 "Анатолий Кулаков" Наверное null reference type, это такое большое мегаизменение, и вот после null reference type по type уже ничего не было, вот это наверное самое крутое, что только могло бы быть.
2399.58 2426.66 "Игорь Лабутин" Ну, наверное, сейчас я тебя перебью, наверное, с этим могло бы посоревноваться вот эта вот фича про extension everything, когда ты можешь писать extension type к чему угодно, как угодно, с наследованием, не с заменой полей, но короче, с добавлением полей и вот этого всего, но это тоже фича, она была частично объявлена, если вы помните, мы про нее рассказывали, на билде в середине года, но не попадает даже в какие-то превью-версии пока.
2426.66 2438.02 "Анатолий Кулаков" Ну да, я думаю, если собрать по популярности, по флажочкам, голосочкам и звездочкам, то кажется, дискриминационный юнион уделает абсолютно все, что только попадется на их пути.
2438.02 2454.46 "Анатолий Кулаков" Может быть, потому что очень много громких фанатиков, а может быть и правда действительно хорошая фича, ну давай разберемся, что же это все-таки такое, по крайней мере попробуем, потому что в мире объектно-ориентированных языков эта штука довольно чуждая, и тем более в таких идиоматичных и красивых как C#.
2454.46 2465.86 "Анатолий Кулаков" Именно поэтому команда Microsoft очень сильно сопротивлялась дискриминационным юнионам, потому что она говорила, что у нас есть объектно-ориентированное программирование, у него есть наследование, интерфейсы, абстрактные классы и все такое.
2465.86 2470.18 "Анатолий Кулаков" Оно позволяет нам делать то же самое, но немножко с другой стороны.
2470.18 2475.18 "Анатолий Кулаков" Так вот, что же такое, зачем вообще эта штука понадобилась?
2475.18 2507.86 "Анатолий Кулаков" Дискриминационный юнион - это способ сохранить какое-то значение в какое-то значение несколько разных типов, то есть у вас может быть в одной переменной, вам хочется сохранить почему-то значение разных типов, например строка и число, и это все засунуть в одну переменную или может быть в один аргумент, в зависимости от контекста, то есть от того, в какой данный момент находятся у вас данные, и от этого вы можете решить, что в этой переменной будет храниться.
2507.86 2526.70 "Анатолий Кулаков" Звучит дико, может быть кому-то напомнит это какое-то динамическое программирование или нетипизированное программирование, что мы в одну переменную можем складывать и строку, и цифры, и числа вместе, но на самом деле нет, никакого динамического программирования здесь нет, все довольно строго, все довольно типизировано, никуда мы от этой концепции не уходим.
2526.70 2540.92 "Анатолий Кулаков" Это больше похоже на некоторый класс, который внутри себя может содержать два поля, например поле string и поле int, в зависимости от ситуации мы заполняем одно из этих полей, но все сделано естественно намного четче и намного красивее.
2540.92 2559.38 "Анатолий Кулаков" Например, если у вас есть какой-нибудь кастомер и какой-нибудь сапплайер, то есть у вас есть вот эти два класса, и вы хотите выполнить над ними одну и ту же операцию, допустим что-то там у них посчитать или что-то проверить, или просто распечатать какие-нибудь поля, которые более-менее пересекаются или похожи по смыслу хотя бы.
2559.38 2575.46 "Анатолий Кулаков" Обычно что в этот момент мы делаем, мы в этот момент ищем какого-то общего наследника, да это может быть или какой-то абстрактный базовый класс или какой-нибудь интерфейс, который позволит нам вот эту абстракцию передавать уже в другие методы, которые начнут этого кастомера и сапплайера каким-то образом обрабатывать.
2575.46 2588.18 "Анатолий Кулаков" Но что если это общего наследника нет, и кодом, который декларирует кастомер и сапплайер, мы не владеем, то есть мы не можем его поменять, мы не можем добавить какой-то интерфейс, который нам нужен.
2588.18 2604.26 "Анатолий Кулаков" Или вдруг таких пар, таких совпадений очень много, то есть на каждую операцию, на каждую функцию создавать свой собственный интерфейс для абсолютно различных объектов, которые может быть даже между собой никак и не связаны, это довольно странно звучит.
2604.26 2627.70 "Анатолий Кулаков" И мы не хотим, чтобы вот эта абстракция, которая говорит о том, что операции нужно что-то, то есть операция хочет над какими-то объектами произвести какие-то действия, это проблемы самой операции, если эти объекты по какому-то принципу, причине не подходят, мы не хотим вот эту абстракцию протекать на декларирование самого класса, на декларирование объекта.
2627.70 2640.38 "Анатолий Кулаков" Потому что сегодня одной операции нужно два этих класса получить, завтра другой операции нужно три этих класса получить, и у нас получается слишком большое множество, то есть не очень удобно решать такую проблему с помощью наследования.
2640.38 2656.14 "Анатолий Кулаков" Как альтернативный способ это сделать так, чтобы ваша функция, ваш метод принимал оба этих типа, и если он будет принимать оба этих типа, то у вас не будет никаких проблем передать или тот, или другой класс.
2656.14 2678.82 "Анатолий Кулаков" Это действительно будет выглядеть немножко уродливо, если мы будем делать это на текущих средствах C#, но вот если мы возьмем discrimination union, то есть как я упоминал выше, то есть позволяем переменной или параметру метода принимать одно или один из строго задекларированных известных заранее типов, то эта проблема легко и красиво решается.
2678.82 2689.86 "Анатолий Кулаков" То есть мы можем в какой-то метод, метод может декларировать, что я хочу принять или строку, или int, и мы туда можем их передать с помощью вот этой новой концепции discrimination union.
2689.86 2694.14 "Анатолий Кулаков" На самом деле во многих языках она уже есть и называется по-разному.
2694.14 2707.98 "Анатолий Кулаков" Начинаем discrimination union, также tagged unions, sum type, то есть типы сум или сумма типов, короче sum types, type unions, все это вот как раз таки оно.
2707.98 2720.58 "Анатолий Кулаков" И все они решают одну единственную проблему, ну в базе стоит одна единственная проблема, это позволить единственной переменной держать у себя значения одного или нескольких разных типов.
2720.58 2730.74 "Анатолий Кулаков" И обычно эти типы заранее известны, то есть мы понимаем, что в эту переменную мы можем засунуть, то есть это не какой-то object, в который можно засовываться все подряд.
2730.74 2731.74 "Анатолий Кулаков" Как же предлагается это решать?
2731.74 2735.98 "Анатолий Кулаков" Ну, как я уже говорил, обычные C# разработчики привыкли к иерархии.
2735.98 2746.10 "Анатолий Кулаков" У нас есть уже иерархия, мы можем наследоваться и все такое, и подходы с иерархией есть проблемы, кроме тех, что я упомянул, немножко еще их подчеркнем.
2746.10 2758.14 "Анатолий Кулаков" Во-первых, это неизвестность всех наследников, то есть обычно у нас иерархия, обычный наш класс, он по умолчанию может быть открыт для наследования.
2758.14 2772.02 "Анатолий Кулаков" И где эти наследники будут, в каком модуле, в какой программе, в каком, не знаю, динамически загружаемом или динамически компилируемом может быть сборке, в общем, мы всех наследников данного класса учесть не можем.
2772.02 2778.50 "Анатолий Кулаков" А это довольно-таки важное ограничение и важная проблема, и желательно, чтобы компилятор мог это делать.
2778.50 2797.70 "Анатолий Кулаков" И если вдруг мы захотим, например, в тот метод, который хочет отпроцессить наши значения нескольких типов, передать что-то, что не является наследником, нам необходимо будет сделать какого-то наследника обертку, в эту обертку передать неподдержимый тип и засунуть в этот процесс.
2797.70 2800.10 "Анатолий Кулаков" Тоже какая-то муторная чепуха выходит.
2800.10 2807.62 "Анатолий Кулаков" Также у нас есть ситуации, когда вот эти обертки, вот эти наследники и так далее, они требуют аллокации.
2807.62 2816.34 "Анатолий Кулаков" То есть в основном это классы, если мы говорим про интерфейсы или про абстрактные классы, если мы вообще в наследование впадаем, то там мы обычно используем классы.
2816.34 2822.14 "Анатолий Кулаков" А классы у нас требуют аллокацию памяти, что не всегда хорошая идея.
2822.14 2828.10 "Анатолий Кулаков" И также они не могут содержать специальные значения, например, ref-тайпы.
2828.10 2831.86 "Анатолий Кулаков" А многим иногда это необходимо.
2831.86 2841.10 "Анатолий Кулаков" Таким образом, если мы говорим об имплементации discrimination union c#, возникает мысль, что нам нужно несколько разных реализаций discrimination union.
2841.10 2844.06 "Анатолий Кулаков" Давайте же посмотрим, какие они могут быть.
2844.06 2847.38 "Анатолий Кулаков" Итак, первая реализация - это обычный union классы.
2847.38 2853.86 "Анатолий Кулаков" То есть это объединение нескольких членов, которые могут быть объявлены вместе.
2853.86 2855.54 "Анатолий Кулаков" Как это может выглядеть в коде?
2855.54 2857.94 "Анатолий Кулаков" Вы пишете ключевое слово new union, новое слово.
2857.94 2862.98 "Анатолий Кулаков" Можно его немножко сравнить с классом или с рекордом.
2862.98 2865.14 "Анатолий Кулаков" Этому юниону необходимо задать тип.
2865.14 2872.62 "Анатолий Кулаков" И внутри этого юниона вы должны рассказать, а какие типы можно в этот тип записывать.
2872.62 2878.22 "Анатолий Кулаков" По сути, можно это представить как абстрактный класс верхнего уровня union.
2878.22 2886.18 "Анатолий Кулаков" И от этого абстрактного класса у нас есть строгий перечень наследников, которые у нас существуют, и мы этих наследников объявляем внутри.
2886.18 2896.50 "Анатолий Кулаков" Например, мы можем внутри объявить наследника A, который принимает тип int, наследника B, который принимает тип string, и наследника C, который вообще ничего не принимает, он пустой.
2896.50 2897.90 "Анатолий Кулаков" То есть не хранит никаких в себе полей.
2897.90 2913.86 "Анатолий Кулаков" И вот таким образом, объявив вот этот union, и внутри юниона объявив три строчки, мы на самом деле на уровне или кода это можем развернуть как раз таки в такую схему наследования.
2913.86 2920.26 "Анатолий Кулаков" Мы можем юнион верхнего уровня развернуть в абстрактный рекорд, и внутри этого рекорда будут еще три рекорда.
2920.26 2922.26 "Анатолий Кулаков" Это A, B и C.
2922.26 2927.78 "Анатолий Кулаков" И они будут пронаследованы от основного верхнего уровня юниона.
2927.78 2928.78 "Анатолий Кулаков" Что это нам дает?
2928.78 2933.58 "Анатолий Кулаков" Что мы как раз можем к юниону присвоить любого из наследников.
2933.58 2936.46 "Анатолий Кулаков" То есть технически получается то, что мы хотели.
2936.46 2943.14 "Анатолий Кулаков" У нас есть какой-то базовый класс, к которому мы можем присвоить любое из перечисленных значений.
2943.14 2947.22 "Анатолий Кулаков" И эти наследники, они внутри себя могут содержать значения разных типов.
2947.22 2957.06 "Анатолий Кулаков" Первый наследник может содержать в себе переменные int, string, второй наследник может какие-то листы от url-ов содержать, третий - гуиды, четвертый вообще пустой.
2957.06 2958.34 "Анатолий Кулаков" В общем, все это можно содержать.
2958.34 2963.70 "Анатолий Кулаков" Вот, в принципе, такая и вся концепция.
2963.70 2966.22 "Анатолий Кулаков" Какие нам еще могут быть необходимы юнионы?
2966.22 2973.34 "Анатолий Кулаков" Ну, как я уже говорил, многие любят отсутствие локаций, поэтому нам еще нужны юнионы в виде страктов.
2973.34 2978.86 "Анатолий Кулаков" В общем, просто опишем struct.union и синтаксис тот же самый оставляем и получаем юнионы страктов.
2978.86 2980.10 "Анатолий Кулаков" Что они нам дают?
2980.10 2994.42 "Анатолий Кулаков" Ну, во-первых, мы избавляемся от локаций, и во-вторых, мы можем использовать специфичные типы, например, ref.union стракты, которые могут содержать в себе поля ref или ref.struct, что раньше было практически невозможно.
2994.42 3029.90 "Анатолий Кулаков" Также нам необходим еще ad-hoc юнион, так называемые анонимные юнионы, то есть это те соединения, которые мы можем собирать динамически, и для этого предлагается использовать синтаксис кортежей и ключевое слово or, то есть мы можем сказать, что наш юнион состоит из типа a, or b, or c, и для того, чтобы этот юнион хоть как-то с ним управляться, ему необходимо дать имя, и имя предлагается давать с помощью файловых или глобальных алиасов, мы с вами их уже обсуждали.
3029.90 3042.18 "Анатолий Кулаков" Это новая фишка, с помощью которой вы можете сделать global using, выдать имя юниону, равно, и там уже указать в виде кортежа a, or b, or c.
3042.18 3044.42 "Анатолий Кулаков" Такие тоже ad-hoc юнионы у нас получаются.
3044.42 3048.34 "Анатолий Кулаков" Еще хочется делать custom юнион, что это такое?
3048.34 3068.86 "Анатолий Кулаков" Это когда вы своему собственному типу можете дать поведение юниона, это может быть класс или структура, и C# компилятор будет распознавать в вашем типе custom юнион, ну в частности он вам позволит сделать закрытую иерархию, то есть иерархию, в которой известно, какие наследники у данного класса есть.
3068.86 3073.18 "Анатолий Кулаков" Это тоже довольно хорошая фишка.
3073.18 3076.18 "Анатолий Кулаков" Наверное попозже обсудим с вами почему.
3076.18 3081.06 "Анатолий Кулаков" Зачем они нужны, что мы хотим с этой штукой делать?
3081.06 3093.14 "Анатолий Кулаков" Самое первое, что приходит на ум, и чего нам давно не хватает, это конечно же options, то есть options это специальный тип, который представляет или существующее значение, или его отсутствие.
3093.14 3095.50 "Анатолий Кулаков" Как бы мы его могли сделать?
3095.50 3101.50 "Анатолий Кулаков" Объявить public union struct options от t, и у этого t будет два значения.
3101.50 3115.66 "Анатолий Кулаков" Значение sum, которое может принимать t value, то есть любое значение, которое удовлетворяет типу t, и значение non, в которое ничего не может принимать, оно просто существует, и все.
3115.66 3126.90 "Анатолий Кулаков" Также точно очень давно нам хочется тип result, который кажется что уже у всех есть, кроме C#, безусловно сторонними библиотеками все это 10 тысяч раз реализовано, но из коробки его все еще нет.
3126.90 3133.06 "Анатолий Кулаков" Result это специальное значение, которое может принимать или успешный результат, или результат ошибки.
3133.06 3148.94 "Анатолий Кулаков" У успешного результата также точно есть какой-то t value, чтобы мы могли его вернуть куда-то наружу, и у ошибки тоже может быть какой-то t error, то есть или строка сообщения об ошибке, или t exception какой-нибудь, чтобы мы там могли прямо exception засунуть, или еще что-то, не важно.
3148.94 3154.98 "Анатолий Кулаков" Как мы будем описывать error в наших терминах, например problem details то же самое.
3154.98 3167.58 "Анатолий Кулаков" Вот такой пропозл был выставлен, в этом пропозле еще есть какие-то базовые пропозлы, на которых он ссылается, то есть без которых невозможно реализовать сами discrimination union.
3167.58 3188.82 "Анатолий Кулаков" В частности самый главный это closed hierarchy, пропозл, который как раз таки позволяет некоторому набору наследников делать декларацию, что это конечный набор наследников, что иерархия закрыта, что больше наследников не будет, и никто наследоваться от нашего базового типа больше не имеет права никакого.
3188.82 3200.78 "Анатолий Кулаков" Это нужно для компилятора в основном для того, чтобы уметь на этапе компиляции проверять разбор всех discrimination unions.
3200.78 3216.34 "Анатолий Кулаков" Ну допустим, вот мы объявили наш результат, у которого есть поле success, у которого есть поле failure, и мы в конце концов запихнули туда какое-то значение, это значение может быть или success, или error, теперь что же мы будем делать с ним дальше?
3216.34 3225.02 "Анатолий Кулаков" Каким образом из этого результата сможем понять, а что там внутри лежит, success, которому можем каким-то образом доступиться, или error, который мы должны выдать пользователю.
3225.02 3240.62 "Анатолий Кулаков" Обычно в таких случаях нам на помощь приходит pattern matching, то есть мы объявляем обычный свитч, у этого свитча спрашиваем, результат это success, тогда мы обращаемся к его полям и выводим value, допустим, для пользователя.
3240.62 3249.74 "Анатолий Кулаков" В альтернативной ветке pattern matching, в альтернативной ветке свитча мы можем спросить, а может быть результат это ошибка, и тогда для пользователя мы выводим ошибку.
3249.74 3272.94 "Анатолий Кулаков" Минус данного подхода раньше был в том, что мы не могли в этом pattern matching определить все возможные типы, то есть это была ошибка, это был success, и в принципе разработчик мог туда завтра добавить еще какое-нибудь третье свойство, допустим, warning, и все наши свитчи, все наши кейсы, все наши pattern matching, они никак не знали, что этот warning был добавлен.
3272.94 3281.98 "Анатолий Кулаков" И в конце концов, скорее всего, наше приложение упало бы с ошибкой, что проверяемый аргумент, проверяемый тип выходит за рамки поддерживаемых значений.
3281.98 3297.94 "Анатолий Кулаков" И это как раз и был бич абсолютно всех библиотек, которые пытались реализовать discrimination union какими-то сторонними костылями и генераторами, и наследованием, и много-много чем еще.
3297.94 3301.22 "Анатолий Кулаков" Таких библиотек в округе полно, наверняка вы с ними сталкивались.
3301.22 3308.58 "Анатолий Кулаков" Так вот, закрыть иерархии это как раз таки то, чего все очень долго и много хотели.
3308.58 3316.42 "Анатолий Кулаков" Это способ объявить, что вот у нас есть какие-то наследники, и больше вне этого модуля наследников не бывает.
3316.42 3329.10 "Анатолий Кулаков" Мы не использовали данное описание "модуль", а модуль это в общем случае сборка, то есть обычно модулей может быть сборки несколько, но по умолчанию в дотнете мы компилируем обычно в одну сборку, в один модуль.
3329.10 3335.58 "Анатолий Кулаков" Поэтому мы можем сказать так, что у нас есть какой-то базовый тип, абстрактный тип, базовый тип, не суть важна.
3335.58 3346.34 "Анатолий Кулаков" И если мы навесим над этим типом какой-нибудь клоуст атрибут, мы сообщаем компилятору, что все наследники, которые есть у этого типа, они внутри этой сборки, нигде их наружу быть не может.
3346.34 3347.66 "Анатолий Кулаков" Что это нам дает?
3347.66 3359.14 "Анатолий Кулаков" В вышеуказанном паттерн матчинге, когда мы проверяем все значения на success, на fail и так далее, компилятор может нам гарантировать, что мы в этом свиче обработали все возможные значения.
3359.14 3370.54 "Анатолий Кулаков" Как только разработчик пойдет и добавит третье значение warning, компилятор проверит абсолютно все свичи и выдаст нам ошибку, что "товарищ, в этом свиче ты не обработал новые значения warning".
3370.54 3372.82 "Анатолий Кулаков" Он не позволит такому коду даже скомпилироваться.
3372.82 3381.30 "Анатолий Кулаков" То есть по сути он убирает вот этот runtime exception, что у нас появился внезапно какой-то новый неподдерживаемый наследник, неподдерживаемый тип.
3381.30 3387.42 "Анатолий Кулаков" Мы этот exception будем получать в этапе компиляции, мы эту ошибку будем видеть, как только разработчик ее пишет.
3387.42 3397.02 "Анатолий Кулаков" И это мега круто, это прелесть, она позволяет обрабатывать всю иерархию типов в одном выражении паттерн матчинга, это прекрасно.
3397.02 3403.10 "Анатолий Кулаков" И два других пропозла, которые позволяют более красиво уже управляться с этим паттерн матчингами.
3403.10 3426.78 "Анатолий Кулаков" Во-первых, это неявный доступ к синглтонам, то есть если мы вдруг объявили static singleton property и мы хотим к этому проперти обратиться, то в рамках discrimination union мы можем написать всего лишь навсего тип, в котором хранится это единственный static singleton property и компилятор сам его подставит.
3426.78 3432.50 "Анатолий Кулаков" Звучит довольно жутко и страшно, но посмотрим как это будет еще обсуждаться и будет реализовываться.
3432.50 3443.90 "Анатолий Кулаков" И второй более интересный пропозл, это nested member shorthand, это возможность более мощного вывода типов.
3443.90 3460.22 "Анатолий Кулаков" То есть вместо того, чтобы допустим объявить enum, переменную с enum color, как равно color red, хочется чтобы компилятор научился сам понимать, если у нас есть переменная color, то ей можно было бы присвоить просто red и все.
3460.22 3468.26 "Анатолий Кулаков" А в том, что это значение enum, color.red, он мог бы вывести сам, потому что он знает какой переменной мы присваиваем это значение.
3468.26 3486.58 "Анатолий Кулаков" В общем, это для pattern-матчингов и для discrimination union очень сильно упростило бы вообще использование их, потому что с ними как раз таки и принято обращаться так, что мы присваиваем наследника типа, своему базовому типу, при этом не указывая его вложенность.
3486.58 3496.26 "Анатолий Кулаков" А данный пропозл нам говорит, что как только мы объявляем discrimination union, то все его наследники будут именно компилироваться в виде вложенных, то есть в виде nested типов.
3496.26 3506.70 "Анатолий Кулаков" Поэтому для того, чтобы читабельность все-таки поддержать на уровне приличном, чтобы было не стыдно перед пацанами, такой пропозл, как nested member shorthand, он тоже был бы весьма в тему.
3506.70 3518.34 "Анатолий Кулаков" Еще раз хочу напомнить, что это только пропозл, никакого официального одобрения у него еще нет, у него даже нет какого-то proof of concept, то есть пока обсуждается только в рамках пропозла.
3518.34 3529.46 "Анатолий Кулаков" Поэтому не факт, что это будет, не факт, что это будет в таком виде, и даже если это будет, то глядя на текущую скорость развития C#, неизвестно через сколько релизов такое счастье нам случится.
3529.46 3549.02 "Игорь Лабутин" Ну да, давай так, это действительно уже не первый заход на discrimination unions, есть много разных предложений от разных групп и сторон, как это все сделать, он действительно выглядит вроде как жизнеспособным, но кажется, что это настолько много работы, что видимо, ждать нам действительно релиза 2 минимум.
3549.02 3550.02 "Анатолий Кулаков" Хорошо.
3550.02 3559.18 "Анатолий Кулаков" Ну, слушай, после того, как эти чудики нам сделали Roslin, они обещали, что любые фичи языка они будут делать просто в 3 секунды, поэтому может там не должно быть много работы?
3559.18 3566.58 "Игорь Лабутин" Ну вот там 3 секунды, здесь 3 секунды, в итоге сейчас в Roslin не столько фич, что следующие уже не 3, а 33 секунды.
3566.58 3569.10 "Анатолий Кулаков" Да, за что боролись, как бы и на то и напоролись.
3569.10 3582.34 "Игорь Лабутин" Ну слушай, любой проект разрастается, поэтому может быть действительно слишком сложно, может быть действительно они хотят это сделать так, чтобы не получилось нечто то, что будет неудобно поддерживать, не знаю, ну то есть там конечно не глупые люди сидят, поглядим.
3582.34 3585.58 "Анатолий Кулаков" Да, посмотрим обсуждения, будет интересно, в принципе,
3585.58 3586.58 "Игорь Лабутин" на чем они становятся.
3586.58 3593.38 "Игорь Лабутин" Пока там вообще никаких обсуждений, то есть что удивительно, у этого проползла вообще сейчас пока никакого движухи нет, сколько я понимаю.
3593.38 3623.78 "Игорь Лабутин" Я не следил за LTM-митингами, но по-моему пока ничего не обсуждалось, надо посмотреть будет, последим, хотя возможно наверное команда сейчас занята, я видел уже где-то какие-то отголоски в твиттере про то, что все, короче, зафрилисили код девятки, можно начинать работать на дотнет 10, типа, а, кто-то, этот самый Джеймс Ньютон Кинг, по-моему, написал, что типа сделал первый коммит в дотнет 10, что-то в таком духе, типа, первую фичу, какой-то мелкий бабак какой-то мелкий пофиксил.
3623.78 3624.78 "Игорь Лабутин" Ну наконец-то, да.
3624.78 3630.70 "Анатолий Кулаков" Интересно, а что он там планирует-то делать, блин, со всякими введениями C# 9?
3630.70 3638.14 "Игорь Лабутин" Ну это уже другой вопрос, ну короче, в общем, дотнет 10 потихонечку начинает тоже двигаться вперёд.
3638.14 3642.02 "Игорь Лабутин" Ну ладно, давай на этом потихонечку будем завершать, у нас ещё есть раздел...
3642.02 3657.78 "Анатолий Кулаков" Ну подожди, насчёт комментариев, да, тут не всё так просто, потому что обычно пропозалы, они паблишатся в ишусы, а вот этот пропозал, он находится в md-файле, который лежит в C# ленгвиче, поэтому у него и комментария в ноль.
3657.78 3660.58 "Игорь Лабутин" Ну не должен же быть иши какой-то?
3660.58 3669.10 "Анатолий Кулаков" Ну опять же, может это просто документ, в котором сейчас собираются мысли в кучу, там готовится что-то делать, а потом на основании его создастся иши и уже пойдёт какое-то обсуждение.
3669.10 3670.10 "Игорь Лабутин" Ну может быть, может быть.
3670.10 3672.34 "Игорь Лабутин" Ну ладно, поглядим, поглядим.
3672.34 3678.82 "Игорь Лабутин" Давай пойдём в сторону кратко-разном, у нас тем более что его вроде как кратко, но чего-то разного много сегодня накопилось.
3678.82 3687.50 "Игорь Лабутин" Во-первых, вышло новое видео Стивена Тауба и Скода Хансельмана, где они часик кодируют, ну точнее Стивен, конечно, кодируют.
3687.50 3703.42 "Игорь Лабутин" В этот раз они пишут array pool свой собственный, таким образом объясняя в каком-то смысле, как устроен обычный array pool внутри, ну и заодно показывая какие-то техники, как можно писать высокопроизводительный или оптимизированный код на дотнете.
3703.42 3705.90 "Игорь Лабутин" Если вы этим интересуетесь, посмотрите.
3705.90 3718.06 "Игорь Лабутин" И вторая ссылочка, это все мы знаем на такой модельный пример от Майкрософта под названием eShop on Containers, это пример такого нормального большого микросервисного приложения.
3718.06 3728.78 "Игорь Лабутин" Ну нормальность его, она там как бы обсуждаема с разных сторон, но, по крайней мере, это некоторый пример микросервисной архитектуры на дотнете, на нем построено много чего с точки зрения учебных материалов.
3728.78 3739.34 "Игорь Лабутин" Теперь у нас есть продукт, проект такой же под названием eShop support, по названию можно догадаться, что это нечто похожее, но только для support центра, видимо, того самого eShop.
3739.34 3760.38 "Игорь Лабутин" И это пример приложения, где есть много AI, то есть там всякие классификации текстов, анализ текстов, в смысле содержимого текстов, суммаризация, в смысле обобщение текстов, генерация данных, генерация какого-то тестового контента, чат-боты и вот это все.
3760.38 3769.90 "Игорь Лабутин" В общем, если вам интересно, как встроить AI в дотнет-приложение, вот можно теперь посмотреть на eShop support и посмотреть, как это сделано.
3769.90 3783.18 "Игорь Лабутин" Конечно, там не обошлось без Aspire, причем надо сказать, что там используется и показаны не только работы, с ажурными какими-то или с OpenAI endpoint, но и с локальной моделькой тоже.
3783.18 3791.10 "Игорь Лабутин" То есть если у вас мощная сервера и вы хотите крутить свою модельку, да, пожалуйста, там тоже есть такие примеры в этом продукте, в этом проекте на GitHub.
3791.10 3797.90 "Анатолий Кулаков" Ну интересно, потому что там типа эти UI уже перевалили все разумные пределы, все эти статьи, надо их в какой-то уже сэмпл объединять.
3797.90 3800.82 "Игорь Лабутин" Ну вот сделали, молодцы.
3800.82 3801.82 "Анатолий Кулаков" Хорошо.
3801.82 3814.66 "Анатолий Кулаков" Так, стали известны даты dotnet.conf/2024, это ноябрь с 12 по 14, а это значит, что именно в эти даты и состоится релиз дотнет-9.
3814.66 3820.10 "Анатолий Кулаков" И под этот же шумок напоминаю, что дотнет-6 заканчивается.
3820.10 3830.86 "Анатолий Кулаков" Поддержка у него как раз в ноябре 2024 года, поэтому если вы там переползали на дотнет-6 или собирались, то поторопитесь и перепрыгивайте уже куда-нибудь дальше.
3830.86 3844.36 "Анатолий Кулаков" Дальше у нас есть статичка еще про MS-тест анализаторы, так как MS-тестов пользуются люди мало, поэтому если кому-то интересно, посмотрите отдельно.
3844.36 3849.46 "Анатолий Кулаков" Ну для меня был интересен сам факт, что в MS-тесте есть анализаторы, в принципе, и это хорошо.
3849.46 3869.50 "Анатолий Кулаков" Они опять же позволяют вам убедиться, что вы передаете в ассерты аргументы в правильном порядке, что вы пометили тестовые методы правильными атрибутами, что у вас есть там правильная сигнатура у ассембляния шала из метода и много-много других разных рулов полезных, поэтому если вдруг используете MS-тест, то посмотрите на анализаторы.
3869.50 3870.50 "Анатолий Кулаков" Они вам должны понравиться.
3870.50 3876.18 "Анатолий Кулаков" Еще одна очередная статейка про BIN-реформатор, про то, что он будет удален из дотнет-9.
3876.18 3890.46 "Анатолий Кулаков" В этот раз официально от Microsoft вышла статья, которая рассказывает, какие там риски были с BIN-реформатором, почему решил Microsoft его удалить, какие есть способы для того, чтобы его заменить, как читать, как совместимость поддержать.
3890.46 3898.82 "Анатолий Кулаков" Мы это недавно обсуждали довольно подробно, там была просто другая статья, но вот здесь, если вы больше доверяете Microsoft, то можете почитать.
3898.82 3905.66 "Анатолий Кулаков" Был анонсирован Aspire 8.2 и самое значимое его изменение в том, что теперь компоненты переименовали в интеграции.
3905.66 3908.30 "Анатолий Кулаков" И это все.
3908.30 3918.42 "Анатолий Кулаков" Дописали кучу тестов и все такое, но теперь очень важно просто потому, что всю текущую документацию или доклады, которые вы будете читать, вам нужно понимать, что такое компоненты и что такое интеграции.
3918.42 3921.58 "Анатолий Кулаков" Это на самом деле теперь одно и то же.
3921.58 3929.38 "Анатолий Кулаков" У Эндрю Лока вышла огромная статья про то, как в Дотнет 8 можно работать с TAR файлами.
3929.38 3968.34 "Анатолий Кулаков" Я напомню, что еще начиная с Дотнет 7, была внедрена нативная поддержка TAR файлов в Дотнет и Эндрю как раз таки сравнивает, насколько эта поддержка хороша, он ее сравнивает с командной утилитой TAR, которой все пользуются на всех платформах и также из его статьи вы узнаете, что такое вообще TAR файлы, почему они появились, как из них извлекать информацию, как их создавать, как посмотреть, что внутри этого TAR файла хранится, а также вы узнаете, какие фичи отсутствуют в реализации Дотнета, какие есть баги и прочее, прочее.
3968.34 3977.86 "Анатолий Кулаков" TAR файл обычно у нас не очень распространен, это больше линуксовая забава и то до тех пор, пока у них появился нормальный ZIP.
3977.86 3984.78 "Анатолий Кулаков" Но если вдруг вы сталкиваетесь, или вам почему-то нужно, то посмотрите на статью Эндрю, там все довольно подробно и тщательно описано.
3984.78 3993.86 "Игорь Лабутин" Да, действительно, статья интересная, не стал я включать в основном выпуск, надо смотреть на код, но она такая практическая и полезная.
3993.86 4010.50 "Игорь Лабутин" Так, и у нас еще вернулась некоторая, тоже довольно давно не упоминаем рубрика, не рубрика, раздел, не раздел, где мы делимся с подкастами, которые мы тоже послушали, мы их иногда слушаем, иногда не слушаем.
4010.50 4012.94 "Анатолий Кулаков" Наконец-то, летом было время, да, и мы что-то послушали.
4012.94 4015.18 "Игорь Лабутин" Да, было немножко времени, что-то послушали.
4015.18 4021.38 "Игорь Лабутин" Послушали, на самом деле, я, по крайней мере, послушал много, так что прям супер поделиться какими-то ВАУ-выпусками у меня не так много.
4021.38 4033.86 "Игорь Лабутин" У меня есть один выпуск, который я тоже где-то услышал, я обычно этот подкаст не слушаю, называется "Corey Joseph Podcast" и выпуск про то, как же строили PowerShell.
4033.86 4039.66 "Игорь Лабутин" Причем это не про технику, это не про то, как там PowerShell построили внутри, с точки зрения архитектуры, там какие-то технические детали.
4039.66 4042.14 "Игорь Лабутин" Все там немножко про это есть, но совсем чуть-чуть.
4042.14 4066.30 "Игорь Лабутин" В основном это про то, как выглядел Майкрософт в тех времен, начала 2000-х, конец 90-х, начало 2000-х, и чуть позднее это всякая политика, борьба внутри, и вот это все, и что стоило Джеффри Сноуэру, с которым интервьюю и который рассказывает эту историю, дотолкать PowerShell до того вида, в котором мы его сейчас знаем.
4066.30 4077.06 "Игорь Лабутин" Да, это тогда еще был, конечно, не кроссплатформин и тогда это был, примерно его рассказ касается до, примерно, четвертой версии, но все равно это то самое становление PowerShell таким, каким мы его знаем.
4077.06 4083.30 "Игорь Лабутин" Если интересуетесь такой историей немножко, да, очень интересно послушать.
4083.30 4085.34 "Игорь Лабутин" Часик на английском.
4085.34 4091.70 "Анатолий Кулаков" Меня зацепило пару выпусков «Подлодки», это выпуск 3.5.7 про партнерство, во-первых.
4091.70 4102.02 "Анатолий Кулаков" Довольно интересный подход, как по мне, это был как раз таки гость, который рассказывает, как проводить партнерские сессии.
4102.02 4118.94 "Анатолий Кулаков" Партнерские сессии это такая интересная штука, которая выстраивает контракт общения между партнерами, обсуждает их договоренности, разделение ресурсов, компетенции, ответственность и так далее, и все она это делает на этапе, когда, например, только собирается какой-нибудь стартап или только собирается какая-то компания.
4118.94 4132.42 "Анатолий Кулаков" Основной смысл в том, что пока партнеры находятся в хороших отношениях, потому что рано или поздно стартапы рушатся или продаются, или делятся, и в этот момент между партнерами уже могут возникнуть какие-то конфликты.
4132.42 4143.18 "Анатолий Кулаков" Вот как этих конфликтов избежать в конце, а предусмотреть в начале, как бы договориться обо всем и обсудить все возможные варианты, которые там могут быть, вот об этом и есть выпуск.
4143.18 4152.62 "Анатолий Кулаков" То есть меня всегда поражало, что у нас очень много нацелено в индустрии каких-то техник, каких-то курсов на решение уже проблем.
4152.62 4163.98 "Анатолий Кулаков" То есть, когда что-то произошло, давайте решать, как нам теперь не унывать, как нам теперь развеселиться, как нам теперь более дружественно относиться к окружающим вместо того, чтобы делать профилактику.
4163.98 4170.02 "Анатолий Кулаков" Как доказала практика, профилактика вместо реабилитации гораздо более лучшая тема.
4170.02 4186.46 "Анатолий Кулаков" И именно поэтому хочется, чтобы партнеры не расставались на какой-то грустной ноте, да, то есть хочется, чтобы они понимали, что их ждет в будущем и договаривались в тот момент, когда они еще находятся в нормальных отношениях.
4186.46 4198.66 "Анатолий Кулаков" В выпуске есть очень много интересных примеров, очень много, может быть, я слишком расплывчато объяснил, очень много конкретных примеров, на которым можно понять, зачем это нужно, кому это нужно и когда это нужно.
4198.66 4207.70 "Анатолий Кулаков" Но вот, например, Игорь, мы с тобой собрались, и мы с тобой ни разу не обсуждали, да, что будет, например, с торговой маркой «Радио.нет», если мы вдруг с тобой распадемся.
4207.70 4210.10 "Анатолий Кулаков" Кому она достанется, а на чьи права логотипы и так
4210.10 4211.10 "Игорь Лабутин" далее.
4211.10 4212.10 "Игорь Лабутин" Тебе радио, мне дотнет.
4212.10 4213.10 "Анатолий Кулаков" Ну или наоборот.
4213.10 4217.26 "Анатолий Кулаков" Не, погоди, дотнет, по идее, больше, может, я себе хочу дотнет.
4217.26 4221.14 "Игорь Лабутин" Ну или там, тебе радио и нет, а мне дот.
4221.14 4227.06 "Анатолий Кулаков" Ну и интересно, что все те примеры, которые здесь приводятся, они на самом деле не про бизнес-партнерство, они в общем про партнерство.
4227.06 4242.70 "Анатолий Кулаков" То есть их очень легко можно натянуть, например, на супружеские взаимоотношения, да, то есть каким образом не доводить до того, чтобы там ходить на разводе к психологам, вместо того, чтобы сесть и просто нормально пообщаться в тот момент, когда вы, допустим, еще в нормальных отношениях.
4242.70 4245.54 "Анатолий Кулаков" В общем, это все тоже там есть.
4245.54 4251.54 "Анатолий Кулаков" Интересный выпуск, поэтому, если вам тоже такие рассуждения приходили в голову, посмотрите.
4251.54 4256.94 "Анатолий Кулаков" Вторая подлодка - это выпуск 323 про языки конфигураций.
4256.94 4261.82 "Анатолий Кулаков" Вообще, я люблю различные языки, в том числе, языки конфигураций, поэтому не мог пройти мимо этого выпуска.
4261.82 4270.10 "Анатолий Кулаков" Автор хорошо рассказывает о том, какие языки были, как они эволюционировали, какие для чего используют, какой из них хороший, какой плохой.
4270.10 4289.10 "Анатолий Кулаков" В частности, очень хочется, чтобы люди, которые обожают YAML, строят на этом YAML гребанные кубернетесы и прочие композы и докеры, наконец-то послушали этот выпуск и узнали, почему же YAML, наконец-то, плох, потому что очень много проблем связано с YAML, неоднозначная спецификация, странное поведение.
4289.10 4295.14 "Анатолий Кулаков" Допустим, стандартная шутка, почему у вас в кубернетесе 7 под поднимается нормально, а 8 падает.
4295.14 4300.34 "Анатолий Кулаков" Потому что у YAML есть такая штука, если вы записали циферку 07, то он воспринимает это как int.
4300.34 4303.82 "Анатолий Кулаков" Если вы записали циферку 08, то для него это уже будет строка.
4303.82 4308.94 "Анатолий Кулаков" Вот подобные прекрасные штуки, опять же, ищите в этом выпуске.
4308.94 4317.58 "Анатолий Кулаков" Там вы можете узнать о каких-то других языках конфигураций, которые более стабильны, более интересны и, может быть, которые вы захотите использовать в своих приложениях.
4317.58 4326.54 "Анатолий Кулаков" То есть, не ведясь на вот этом хайпе, что все любят, что все используют, а именно думая головой и понимать, а что в конкретном месте вам лучше всего подходит и где меньше всего будет ошибок.
4326.54 4330.50 "Игорь Лабутин" Ну и отлично, действительно, послушайте.
4330.50 4332.86 "Игорь Лабутин" Всегда интересно еще что-нибудь новенькое узнать.
4332.86 4361.54 "Игорь Лабутин" А за сегодня мы узнали про то, что Mono Microsoft отдала обратную айну, выпустила при этом Dotnet 9 Preview 7, посмотрели на аудитинг Nuget пакетов, посмотрели на новые фичи Visual Studio 2022, на Preview 1 новой версии, поразмышляли над тему того, во что могут превратиться Discriminated Unions в последнем Proposal, ну и пробежались по всяким мелким новостям и подкастикам.
4361.54 4364.38 "Игорь Лабутин" Примерно так получился 99 выпуск.
4364.38 4372.22 "Анатолий Кулаков" Ну и не забывайте комментировать, шарить, репостить, рассказать о нас своим друзьям и слушать наши выпуски.
4372.22 4374.50 "Анатолий Кулаков" Всем счастливо, всем до новых встреч, пока.
4374.50 4375.46 "Игорь Лабутин" Всем пока.
