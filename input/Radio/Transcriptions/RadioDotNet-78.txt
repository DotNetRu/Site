0.00 11.28 "Анатолий Кулаков" Приветствую, дорогие друзья, в эфире Radio.net выпуск номер 78.
11.28 14.68 "Анатолий Кулаков" В эфире ее постоянный ведущий Анатолий Кулаков.
14.68 15.68 "Анатолий Кулаков" И Игорь Лабутин.
15.68 16.68 "Анатолий Кулаков" Всем привет.
16.68 20.96 "Анатолий Кулаков" Большое спасибо всем, кто нас слушает, помогает, шарит, репостит.
20.96 32.24 "Анатолий Кулаков" И в частности большое спасибо товарищам Александр, Сергей, Владислав, Алексей, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ярыгин, Белоцкий Евгений.
32.24 33.24 "Анатолий Кулаков" Большое спасибо.
33.24 46.00 "Анатолий Кулаков" Если вы хотите нас поддержать не только репостами, шарами, комментариями, но и монетой, то приходите на наш сайт на Boosty и посмотрите, чем можно помочь любимому подкасту.
46.00 49.12 "Анатолий Кулаков" Ну что ж, давай начнем.
49.12 52.44 "Анатолий Кулаков" В принципе недельки выдались какие-то довольно скудные на статьи.
52.44 57.16 "Анатолий Кулаков" Я не знаю, народ может ловит последние дни лета, отдыхает, играет.
57.16 66.92 "Анатолий Кулаков" Микрософт с анонсами тоже не сильно балует, поэтому можно было пробежаться по закромам и достать там статики, которые там от независимых авторов где-то у нас по интернету гуляли.
66.92 69.00 "Анатолий Кулаков" Наверное, чем мы собственно и займемся.
69.00 70.88 "Анатолий Кулаков" И такую небольшую подборочку вам сегодня предоставим.
70.88 85.32 "Игорь Лабутин" Да, ну начнем мы с того, что напомним, что у нас в ближайшее время наступит конференция dotnext, которая будет 15-16 сентября, к шоуноуту будет промокодик на скидку для персональных билетов.
85.32 90.08 "Игорь Лабутин" Так что заходите, мы там будем рады увидеться, если вы там тоже внезапно будете.
90.08 93.44 "Игорь Лабутин" Ну или если не получится быть физически, всегда можно посмотреть онлайн.
93.44 102.32 "Игорь Лабутин" И да, действительно, у нас с анонсами в этот раз туго, но как сказать, у нас есть анонс про Visual Studio.
102.32 111.80 "Игорь Лабутин" Тут как бы прям даже хотелось бы сказать, что это все как обычно, но на самом деле не совсем как обычно, и анонс будет про то, что у нас Visual Studio for Mac закрывается.
111.80 126.52 "Игорь Лабутин" Мы много раз говорили, что вот у нас новые версии, и на самом деле за последний год Microsoft очень активно вложилась в VS for Mac, если вы помните, она его активно, ее точнее, переписывала на нативный UI для Mac оси.
126.52 131.92 "Игорь Лабутин" Много было анонсов, много было промежуточных релизов, превью релизов, финальный релиз.
131.92 139.60 "Игорь Лабутин" Но тем не менее, все, Microsoft от нее отказывается, продолжать поддерживать ее не будет, и последняя версия это 17.6.
139.60 146.92 "Анатолий Кулаков" И все это для того, вот эти релизы, переделки, анонсы, чтобы торжественно, красиво и прекрасно ее закрыть.
146.92 147.92 "Анатолий Кулаков" Да, все так.
147.92 156.76 "Анатолий Кулаков" Вообще, я думаю, смотри, ты неправильно начал, мне кажется, заголовок должен был быть желтее, типа Visual Studio закрывается, Visual Studio все.
156.76 160.56 "Анатолий Кулаков" И потом можно в конце уточнить, что это вот эта недоверсия под Mac.
160.56 183.52 "Игорь Лабутин" Ну, может быть, надо было так, но тем не менее, последняя версия это 17.6, она будет поддерживаться официально Microsoft еще 12 месяцев, то есть если там какие-то security патчи или Apple что-нибудь выпустит такое, что надо будет поменять Visual Studio, чтобы она там запускалась или как-то корректно работала с новыми макосями, то Microsoft это будет делать только в течение года, до конца августа 24-го, дальше все.
183.52 188.44 "Анатолий Кулаков" У вас какие-нибудь причины или статистика, или почему они так поступили, у них нет?
188.44 194.20 "Игорь Лабутин" Вообще ничего никто не публиковал, абсолютно, то есть никаких вообще следов этого не видно.
194.20 213.64 "Игорь Лабутин" Говорят, ну, говорят, что, ну, вероятно, слишком дорого, то есть не очень понятно, что там с командой, потому что где-то я читал в каких-то то ли статьях, то ли в чатиках про то, что там слишком много менеджеров, но слишком мало программистов, давай так скажу.
213.64 219.68 "Анатолий Кулаков" Ну, это же не решается закрытием продукта, правда, можно реструктуризировать компанию как-нибудь как продукт,
219.68 235.04 "Игорь Лабутин" то есть сам. Ну, возможно, но с другой стороны, насколько я понимаю, в маковской версии можно было писать только под Mac, и, возможно, это тоже не очень круто, потому что дотунет же кроссплатформенный, поэтому теперь мы будем на Windows-овальной версии писать кроссплатформенно.
235.04 259.84 "Игорь Лабутин" Ну, в общем, сейчас про альтернативу поговорим чуть-чуть дальше, но еще момент надо пояснить и сказать, что, как вы можете заметить, ее заретайрили до выхода дотунет восьмого, то есть казалось бы, что дотунет восемь в ней больше не будет, ну, не успел в ней поддержаться, да, и дотунет восьмой, несмотря на то, что год студии еще технически жить будет, работать будет невозможно.
259.84 270.52 "Игорь Лабутин" На самом деле, в статье есть слова про то, что rudimentary support там все-таки есть, не знаю, что это означает, но типа скомпилировать, типа отлаживать программу на дотунет восемь вы все-таки там сможете.
270.52 274.00 "Анатолий Кулаков" Ну, скомпилировать я могу из командной строки, тут не сильно удивили как бы.
274.00 278.56 "Игорь Лабутин" Не, ну это странно, работать в EDE и переключаться в командную строку, чтобы компилить, это все-таки как-то, ну…
278.56 280.44 "Анатолий Кулаков" Так это ж Mac, слушай, и что там.
280.44 284.76 "Игорь Лабутин" Ну, ладно, вот. Что же предлагается в качестве альтернатив?
284.76 288.56 "Игорь Лабутин" Альтернатив предлагается три штуки, Microsoft там в статье.
288.56 294.04 "Игорь Лабутин" Во-первых, конечно же предлагается их новое поделие под названием C# DevKit.
294.04 305.92 "Игорь Лабутин" Это, напомню, набор расширений для VS-кода, которые позволяют, ну, собственно, нормально работать с C#, нормальный language server, отладчик там, вот это все.
305.92 315.96 "Игорь Лабутин" Можно работать с Visual Studio обычной виндовой на виртуалке, запущенной в Mac, ну, как вы там запускаете виртуалки, в Apparels или еще как-нибудь.
315.96 322.12 "Игорь Лабутин" Ну, или вы можете купить у Microsoft виртуалку в клауде, это называется Microsoft DevBox.
322.12 326.96 "Игорь Лабутин" Там какие-то цены в зависимости от конфигурации, мы, кстати, тоже обсуждали, когда анонс был.
326.96 328.28 "Игорь Лабутин" Вот эти три альтернативы.
328.28 342.00 "Игорь Лабутин" И в Microsoft написано, что они сфокусируются на развитии Visual Studio, чтобы она была доступна через MS DevBox, то есть максимальные типа фичи были именно в Visual Studio и доступны через MS DevBox.
342.00 354.44 "Игорь Лабутин" Ну, и, конечно же, будут C# DevKit тоже развивать, потому что для того, чтобы использовать C# DevKit полноценно и нормально в промышленном окружении, в бизнес-окружении, вам нужна лицензия на нормальную Visual Studio.
354.44 371.60 "Игорь Лабутин" То есть если вы, там такая же схема, как с Visual Studio, там есть community типа версии, то есть если вы используете C# DevKit в персонал-варианте, вам лицензия не нужна, а вот если вы коммерческой компанией, ну, там есть ограничения на эти вот community версии Visual Studio, короче, C# DevKit.
371.60 376.60 "Игорь Лабутин" А Visual Studio FOMAC, она была бесплатная, насколько я помню, да?
376.60 378.60 "Игорь Лабутин" А вот я что-то не уверен.
378.60 381.04 "Игорь Лабутин" Ну, она же Ksamarin Studio, Ksamarin всегда бесплатная.
381.04 382.72 "Игорь Лабутин" Ну, она девелоп электронно там была.
382.72 384.60 "Игорь Лабутин" Слушай, может быть и бесплатная, да, я что-то не помню.
384.60 385.92 "Игорь Лабутин" А так можно денег собрать.
385.92 389.76 "Анатолий Кулаков" Не, ну, просто смотри, да, они теперь не предлагают бесплатные альтернативы, здесь у них нет.
389.76 393.36 "Игорь Лабутин" Я думал, хотя бы Visual Studio… Не, C# DevKit только, ну, только для personal use.
393.36 399.08 "Анатолий Кулаков" Ну, personal use, хорошо, но все равно лицензия для Visual Studio, наверное, не нужна, если Enterprise будешь писать.
399.08 401.08 "Анатолий Кулаков" Интересный ход.
401.08 419.00 "Игорь Лабутин" Да, особенно с учетом того, что MS-DevBox, как бы, если минимальной конфигурацию машины вы будете использовать в месяц, ну, то есть просто ее… Там, короче, написано, что максимальная цена за минимальную машинку вам обойдется в 150 долларов в месяц.
419.00 424.32 "Игорь Лабутин" Понятно, что если ее там выключать на ночь и как-то это экономно использовать, может быть, и меньше, но
424.32 428.52 "Анатолий Кулаков" в общем… Ну, все равно это как бы разрабатывать в виртуалке и такое еще извращение.
428.52 437.44 "Анатолий Кулаков" Хотелось бы, конечно, что-нибудь нативное, и Visual Studio Code вполне бы сюда вписался, если бы они поддержали, опять же, все бесплатно, мне кажется, сильно бы никто и не возмущался.
437.44 438.44 "Игорь Лабутин" Ну, да.
438.44 440.84 "Игорь Лабутин" Ну, в общем, вот такие дела.
440.84 451.60 "Игорь Лабутин" Понятно, что Microsoft у себя в статье никак не упомянули Rider, который после этого анонса сказал, что ближайшие 65 часов, скидка 65 процентов, переходите на нас.
451.60 456.32 "Игорь Лабутин" И тоже, наверное, с этого дела сколько-то заработали на своих подписках.
456.32 460.00 "Игорь Лабутин" Примерно такие дела, так что…
460.00 471.68 "Анатолий Кулаков" Да, интересно еще сравнить, а что там в этой Mac Visual Studio было такого, чего нельзя, например, сделать в том же самом Windows Studio или может в Xcode?
471.68 477.20 "Игорь Лабутин" Не, ну там были, я так понимаю, специфические маковые штуки, вероятно, для разработки под Mac.
477.20 492.32 "Игорь Лабутин" Не знаю, какая-нибудь интеграция с Xcode, помнишь, у нас же было даже в новостях, что они планировали там какую-то правильную интеграцию с Xcode, с последней версией, с этого чего-то, то есть там наверняка есть какая-то специфичная вещь при разработке под Mac, под iPhone разрабатываешь, под iOS.
492.32 498.16 "Анатолий Кулаков" Ну, по идее, да, и в этих альтернативах, которые они предложили, они же эту специфичность не поддерживают.
498.16 500.52 "Анатолий Кулаков" То есть, такие альтернативы довольно обрезанные.
500.52 503.44 "Игорь Лабутин" Ну, возможно, все же архитектики это поддержат, рано или поздно.
503.44 506.72 "Анатолий Кулаков" Да, рано или поздно, а переходить нужно уже в течение 12 месяцев.
506.72 518.08 "Анатолий Кулаков" Ну, хорошо, попрощались с Visual Studio for Mac, опять же, никто не понимал, кто ей пользуется, наверное, те, кто пользовались сейчас начнут возмущаться, и мы хотя бы увидим, что они были.
518.08 521.36 "Игорь Лабутин" Да, посмотрим.
521.36 522.36 "Игорь Лабутин" Давай дальше.
522.36 533.72 "Игорь Лабутин" Дальше у нас, опять же, из таких, наверное, новостей, которые, может быть, не столь важны, но интересны, это новые штаты по серверу в Дотнете.
533.72 542.56 "Игорь Лабутин" Надо понимать, что в Дотнете, ну, как, не знаю, 99% народу используют Kestrel и ASP.NET Core, если нужно что-то хостить в Вебе.
542.56 546.72 "Анатолий Кулаков" А, ну, это 100, 100, какие 99, у нас нет альтернатив, ну, не выяснишь, ты это все хостишь.
546.72 550.16 "Игорь Лабутин" Не, ну, раньше же были эти всякие, как же их там, сейчас.
550.16 551.44 "Игорь Лабутин" Раньше на NC было.
551.44 552.80 "Игорь Лабутин" На NC вот эти все, да.
552.80 555.92 "Игорь Лабутин" Ну, вот, наверное, кто-то еще остался на этих долях процента.
555.92 557.92 "Анатолий Кулаков" Да, вряд ли, вряд ли, сейчас на NC вообще нет.
557.92 563.48 "Анатолий Кулаков" Ну, на F# есть еще такие достойные альтернативы, но, опять же, сколько это уж F# у нас.
563.48 569.20 "Игорь Лабутин" Ну, в общем, вот нашелся новый сервер для Дотнета под названием Sysk.
569.20 572.48 "Анатолий Кулаков" Название нормуль, да, будем программировать на Sysk.
572.48 576.76 "Анатолий Кулаков" А почему нашелся, где он был, кто изобрел?
576.76 591.52 "Игорь Лабутин" Изобрел какой-то чувак просто в репозитории на GitHub, где в основном коммиты от одного-единственного чувака, я так посмотрел, каких-то других сильно известных от него не нашел, ну, может, просто плохо искал, и кто-то мне подскажет, что он какой-то очень известный, наверное, товарищ, я не знаю.
591.52 593.40 "Игорь Лабутин" А есть мотивация, зачем изобрел?
593.40 612.96 "Игорь Лабутин" Ну, он типа полностью альтернативный, и он максимально упрощенный, то есть он как бы, а S/P/NET, он такой очень сложный, всякая замороченная конфигурация, нужно все регистрировать через регистрировать, перерегистрировать и дорегистрировать, и знать все эти extension points, а здесь такая простая штука.
612.96 616.96 "Анатолий Кулаков" Погоди, ты же говорил, что это все-таки альтернатива Kestrel, все-таки S/P/NET или Kestrel?
616.96 617.96 "Игорь Лабутин" Кестрел и S/P/NET.
617.96 623.92 "Анатолий Кулаков" Просто мы, ну, помню, мы как-то с статьей обсуждали, как Kestrel напрямую использовать, и там как раз нет никакой
623.92 639.84 "Игорь Лабутин" усложненности. Да, если здесь эта штука, которая, ну вот прям вот, если документацию читать, она начинается с того, что эта штука предоставляет раутинг, request handling, middle var, логирование, работу с FAP-сокетами, еще куча всяких штук, которые относятся к S/P/NET.
639.84 642.72 "Игорь Лабутин" Но в том числе она работает, ну, она заменяет и Kestrel.
642.72 646.68 "Игорь Лабутин" Внутри это все работает, кстати, на что-то по-листенере обычном, системе это что-то по-листенер.
646.68 649.40 "Игорь Лабутин" Вот.
649.40 654.36 "Игорь Лабутин" Она сразу native out compatible, чего пока нету полностью, я так понимаю, в S/P/NET.
654.36 677.56 "Игорь Лабутин" И действительно, код выглядит, ну, довольно просто, то есть вы создаете объект вот этого сервера, накидываете в него обработчиков через +=, ну, типа делегатов, грубо говоря, которые там регистрируются в стиле на get и вот такой путь, то есть понятно, что, сделай, выполни такую-то лямбу, понятно, что там нет всей такой гибкости, которая есть в S/P/NET, развесистой системы, там, авторизации и все такое, все писать руками.
677.56 687.16 "Игорь Лабутин" Но если вам нужно что-то очень простое и очень незамысловатое, то может быть, это и небольшая штука, потому что она тянет один-единственный пакет, ну, сама себя.
687.16 689.60 "Игорь Лабутин" И больше ей ничего не надо, кроме стандартной библиотеки.
689.60 695.52 "Игорь Лабутин" В отличие от S/P/NET, который там легко затянет 10-20 пакетов, если вы начнете его использовать.
695.52 699.00 "Анатолий Кулаков" Ну, мы его соберем в один бинарник и все, сейчас же это можно.
699.00 705.64 "Игорь Лабутин" Ну, да, ну, в общем, товарищу, видимо, был нужен какой-то простой сервер или просто pet-проект, не знаю.
705.64 707.84 "Игорь Лабутин" Ему нужен был pet-проект, да.
707.84 709.48 "Игорь Лабутин" Вот, ну, в общем, да.
709.48 715.24 "Игорь Лабутин" Один из плюсов, который, как он говорит, типа у меня еще у меня нет UI-фреймворка, ну, типа, Razer у него нету, никак.
715.24 718.88 "Анатолий Кулаков" Да, вроде у S/P/NET он тоже отключаемый.
718.88 724.48 "Игорь Лабутин" Ну, вот в том-то и дело, что отключаемый, да, это самое, если… Ну, то есть, неподключаемый.
724.48 735.44 "Игорь Лабутин" Понятно, что с minimal API вроде стало попроще, то есть, не нужно вот эту всю магию MVC тащить, кучу рефлексий, да, того, как эти контроллеры находятся, обходятся и так далее.
735.44 741.84 "Игорь Лабутин" И, наверное, это в каком-то смысле очень похоже на minimal API, который появился в S/P/NET.
741.84 753.32 "Игорь Лабутин" Но почему-то этот проект появился после уже minimal API, то есть, minimal API был, но зачем-то автору он показался нужным.
753.32 754.32 "Игорь Лабутин" Посмотрим, последим.
754.32 761.52 "Игорь Лабутин" Я видел про этот сервер в нескольких местах, на самом деле, такие статьи-упоминания, что, о, такая штука, прикольно.
761.52 763.40 "Игорь Лабутин" Так что, может быть, это будет не забыто.
763.40 764.40 "Игорь Лабутин" Посмотрим.
764.40 767.32 "Анатолий Кулаков" Ну, да, нам теперь только понять, зачем это.
767.32 769.72 "Анатолий Кулаков" Ну, то есть, хоть бы там какие-нибудь performance-тесты
769.72 785.84 "Игорь Лабутин" есть, он сейчас по перформансу, ну, примерно на уровне S/P/NET. То есть, прям вот, типа там в S/P/NET, ну, типа бенчмарк, условно говоря, показывает 105 попугаев в S/P/NET, если я правильно помню, и 106 попугаев в этом.
785.84 787.52 "Игорь Лабутин" Причём, чем меньше попугаев, тем лучше.
787.52 793.04 "Анатолий Кулаков" Блин, ну это странно, потому что этот кестер лаптимизировали там последние 10 лет лучшую мысль человечества.
793.04 813.64 "Игорь Лабутин" Вот, а здесь как бы тут тупой поверх, что-то пылесын, наверное, да, который не кестер, нифига, а просто обычный, ну, что там, сокеты, да, это за акцептор сокет, и пишешь, и работаешь с ним, тем не менее, выжимает столько же этих наносекунд, по-моему, не попугаи, по-моему, там, наносекунды, типа, среднее время обработки реквеста или что-то в таком духе было, замеряли, ну, бенчмарк-то там.
813.64 816.48 "Игорь Лабутин" Вот, и, в общем, он на уровне.
816.48 819.84 "Анатолий Кулаков" Да, да, подозрительно, странненько.
819.84 820.84 "Игорь Лабутин" Ну, ладно, что будем следить.
820.84 828.64 "Игорь Лабутин" То есть, это значит, что есть ещё потенциал, если он тупо написан, как бы там сейчас версия типа 0.15, да, и всего 62 звёздочки.
828.64 840.32 "Игорь Лабутин" Но, что меня поразило, кстати, проект приколен тем, что это не просто какой-то там pet project, в смысле, что, ну, вот я захотел написать, а что-то посервное, нафигачил, там, по-моему, документации больше, чем кода уже.
840.32 847.48 "Игорь Лабутин" То есть, там хороший, развитый состав документации, с горой примеров, как это всё делать, короче, прям заморочился чувак.
847.48 852.56 "Анатолий Кулаков" Ну, то есть, видно, что на будущее работал, и, наверное, какие-то планы, да, есть на развитие.
852.56 861.68 "Игорь Лабутин" Да, да, да, то есть, либо, ну, как бы, либо нужно было для себя что-то действительно сделать, ну, не знаю, не знаю, пока тайна покрытая мраком, может, автор когда-нибудь появится где-нибудь, какую-нибудь статью выпустит, зачем он это делает.
861.68 872.52 "Игорь Лабутин" Пока все сводятся к словам, что это типа более простой и более прямолинейное, что ли, как у него написано straightforward programming model, то есть попроще, чем с S-Panet.
872.52 890.24 "Анатолий Кулаков" Ну, ладно, альтернатива, это, в принципе, всегда хорошо, есть возможность там посмотреть какие-нибудь другие подходы, есть возможность посоревноваться в том же самом перфомансе, если он действительно один смог выдать качество, которое там Microsoft делал целых 10 лет, то есть это всегда хорошо, почему нет, будем следить, посмотрим, что получится.
890.24 893.80 "Игорь Лабутин" Да, давай дальше.
893.80 917.80 "Анатолий Кулаков" Дальше хотелось продолжить тему про валидацию бизнес-рулы, раз у нас уже выдалась как бы свободная неделька от выпусков, мы где-то примерно один выпуск назад уже начинали беседовать о Марке Симоне, когда он предлагал нам разделять такие понятия, как валидация и верификация, то есть прежде всего валидация тех входных данных, которые у нас есть в программе и верификация непосредственно бизнес-правил, которые есть в программе.
917.80 932.12 "Анатолий Кулаков" В общем, мы на прошлой неделе, то есть на позапрошлом выпуске мы подробно обсудили, что их нужно делить, что это разные вещи, что у них разные свойства, разное время жизни, разные правила и прочее, в общем, что это два вообще отдельных процесса.
932.12 939.64 "Анатолий Кулаков" И вот в этой статье Марк нам предлагает рассмотреть на конкретном примере, а что же, собственно, должно происходить в вашем приложении.
939.64 948.80 "Анатолий Кулаков" И пример довольно-таки популярный и очевидный – это проверка уникальности e-mail в вашей базе данных, например, при регистрации пользователя.
948.80 958.24 "Анатолий Кулаков" В общем, пользователь регистрируется в вашу систему по e-mail, и естественно, чтобы вам создать нового пользователя, вам нужно проверить, а e-mail такой же в базе данных существует или не существует.
958.24 962.16 "Анатолий Кулаков" И если не существует, его создать, если существует, то создавать не надо.
962.16 969.44 "Анатолий Кулаков" И вот такая проверка на уникальность, она в принципе довольно хорошая, практическая задача на вшивость.
969.44 979.32 "Анатолий Кулаков" Очень много всяких теоретических бизнес-правил, архитектуры и прочих глупостей разбивается в проверку e-mail на валидность.
979.32 981.16 "Анатолий Кулаков" Давайте посмотрим, как же она применяется здесь.
981.16 988.56 "Анатолий Кулаков" То есть, прежде всего нам нужно определиться, валидация это входных параметров или же все-таки это верификация бизнес-правил.
988.56 992.32 "Анатолий Кулаков" Что же такое проверка e-mail на уникальность?
992.32 993.32 "Анатолий Кулаков" Валидация довольно проста.
993.32 999.04 "Анатолий Кулаков" Из нашей прошлой статьи мы выяснили, что валидация это всегда чистая функция.
999.04 1004.36 "Анатолий Кулаков" Может ли проверка уникального констрейта в базе быть чистой функцией?
1004.36 1010.32 "Анатолий Кулаков" Очевидно, что нет, потому что у нас есть обращение к базе данных.
1010.32 1013.08 "Анатолий Кулаков" Обращение к базе данных по определению недетерминированное.
1013.08 1016.48 "Анатолий Кулаков" То есть, что это значит?
1016.48 1029.04 "Анатолий Кулаков" Когда мы сделали запрос в базу данных, получили ответ, что такого e-mail не существует, в это время параллельный процесс может данный e-mail в базу добавить.
1029.04 1037.08 "Анатолий Кулаков" И уже через секунду, сделав повторный запрос с теми межзамятными параметрами на проверку этого e-mail, нам ответ придет абсолютно другой.
1037.08 1040.36 "Анатолий Кулаков" Нам база данных ответит, что теперь e-mail существует.
1040.36 1041.36 "Анатолий Кулаков" Представляете, все поменялось.
1041.36 1045.00 "Анатолий Кулаков" То есть, состояние абсолютно недетерминированное.
1045.00 1048.80 "Анатолий Кулаков" То есть, зависит не только от тех параметров, не только от тех аргументов, которые ей передают.
1048.80 1052.16 "Анатолий Кулаков" Соответственно, никакой пьюр фанкшен он не является.
1052.16 1058.56 "Анатолий Кулаков" База данных, а точнее вот ответ от базы данных, это снапшот во времени тех данных, которые в ней находятся.
1058.56 1070.76 "Анатолий Кулаков" И это нужно помнить всегда, когда вы работаете, особенно с конкурентными запросами, с параллельными сервисами, что те данные, которые вы оперируете, которые вы забрали из базы данных, это не истина последней инстанции.
1070.76 1075.64 "Анатолий Кулаков" Это снапшот всего лишь навсего на какой-то промежуток времени.
1075.64 1086.56 "Анатолий Кулаков" И в данный момент, когда вы их проверяете, любой параллельный сервис, параллельный процесс может идти и уже модифицировать те данные, которые непосредственно лежат в самой базе данных.
1086.56 1092.08 "Анатолий Кулаков" Итак, мы выяснили, что обращение к базе данных – это ни разу не пьюр фанкшен.
1092.08 1101.96 "Анатолий Кулаков" То есть, она не может считаться валидацией, и поэтому проверка уникального констрейта в базе данных – это типичный пример бизнес-правила.
1101.96 1108.60 "Анатолий Кулаков" Соответственно, нужно использовать подходящие инструменты, подходящее время жизни и прочие вещи.
1108.60 1115.96 "Анатолий Кулаков" Теперь интересный вопрос про другое.
1115.96 1124.16 "Анатолий Кулаков" Все-таки давайте мы рассмотрим, что происходит в результате этой валидации, валидации e-mail.
1124.16 1136.00 "Анатолий Кулаков" То есть, на самом деле, когда вы проверяете какие-то входные аргументы, когда вы делаете валидацию входных аргументов, то, опять же, повторяя прошлую статью, необходимо, прежде всего, опираться на инкапсуляцию.
1136.00 1145.92 "Анатолий Кулаков" Это одно из важнейших свойств объектно-ориентированного программирования, которое, в частности, включает в себя проверку предусловий, инвариантов и постусловий.
1145.92 1155.12 "Анатолий Кулаков" И как раз валидация – это ответ на вопрос, а вообще имеют ли смысл вот эти данные, которые к нам сейчас приходят.
1155.12 1158.32 "Анатолий Кулаков" И ответ на этот вопрос, он довольно-таки контекстозависимый.
1158.32 1173.40 "Анатолий Кулаков" То есть, если в одной программе у вас валидация может быть бизнес-правилом, то вполне вероятно, что в другом домене, в другой программе валидация вполне может быть, то есть проверка e-mail может быть еще и валидацией.
1173.40 1181.52 "Анатолий Кулаков" Ну, например, когда к нам приходит e-mail адрес, что мы с ним можем сделать в виде валидации?
1181.52 1188.96 "Анатолий Кулаков" Самым типичным случаем, наверное, с которым сталкивались все разработчики, это то, что мы этот e-mail можем проверить на какое-то регулярное выражение.
1188.96 1192.20 "Анатолий Кулаков" Ну, или банально хотя бы, что в нем есть собака.
1192.20 1197.24 "Анатолий Кулаков" Если есть собака, считаем, что на 50% это уже e-mail адрес.
1197.24 1203.96 "Анатолий Кулаков" Обычно люди заходят дальше, проверяют как дополнительные там условия, что там есть обязательно домен.
1203.96 1206.32 "Анатолий Кулаков" Некоторые спускаются до регулярных выражений.
1206.32 1212.44 "Анатолий Кулаков" В интернете очень ходит множество регулярных выражений, которые примерно проверяют, что этот e-mail адрес допустим.
1212.44 1219.02 "Анатолий Кулаков" И проблема с e-mail адресом в том, что все эти регулярные выражения практически не полные.
1219.02 1230.70 "Анатолий Кулаков" То есть, чтобы построить полное выражение, которое 100% соответствует спецификации, которые написаны на возможные e-mail адреса, вам нужно очень-очень сильно попотеть.
1230.70 1236.82 "Анатолий Кулаков" На самом деле, e-mail обладают огромным простором для форматов.
1236.82 1241.10 "Анатолий Кулаков" То есть, это не просто там какие-то латинские буквы с собакой и латинские буквы справа от нее.
1241.10 1242.10 "Анатолий Кулаков" Нет.
1242.10 1243.10 "Анатолий Кулаков" Это намного сложнее.
1243.10 1258.10 "Анатолий Кулаков" И 100% в реализации проверки правильности на вальволинный e-mail адрес, ее нет практически нигде в прикладных программах, за исключением, если вы пишете какой-нибудь SMTP-сервер.
1258.10 1260.22 "Анатолий Кулаков" Может, вот только там.
1260.22 1264.54 "Анатолий Кулаков" Но это в принципе не является большой проблемой.
1264.54 1276.66 "Анатолий Кулаков" Не является это большой проблемой, потому что на самом деле никакого смысла вот этих больших регулярных выражениях при проверке e-mail, который вам ввел пользователь, его нет.
1276.66 1285.66 "Анатолий Кулаков" Какое бы вы регулярное выражение туда не засунули, пользователь всегда может составить такую строчку, которая пройдет это регулярное выражение и при этом не будет являться настоящим e-mail адресом.
1285.66 1292.98 "Анатолий Кулаков" Ну, то есть, настоящим, который активен, которым он пользуется и с помощью которого он отсылает письма.
1292.98 1303.50 "Анатолий Кулаков" Поэтому единственный нормальный способ, как проверить e-mail адрес на самом деле, это отправить пользователю письмо и заставить его каким-то образом доказать, что это письмо к нему пришло.
1303.50 1311.82 "Анатолий Кулаков" Например, кликнуть там по специальной ссылке, которая вернет его на ваш сервер и докажет, что эта ссылка пришла из того адреса, на который вы послали.
1311.82 1317.78 "Анатолий Кулаков" На самом деле это единственный способ, как нормально можно провалидировать e-mail.
1317.78 1327.42 "Анатолий Кулаков" И на самом деле вам не нужно ничего проверять, если вот грубо говорить, не нужно ничего проверять, кроме того, что пользователь вам ввел ненулевую строку.
1327.42 1331.54 "Анатолий Кулаков" Если он ввел ненулевую строку, то все остальное можно с чистой совестью забить.
1331.54 1338.54 "Анатолий Кулаков" Потому что единственное, что вам нужно сделать, это сохранить эту строку в базу данных и отправить e-mail.
1338.54 1342.50 "Анатолий Кулаков" Если e-mail отправился и результат к вам пришел, значит эта строка валидная.
1342.50 1346.46 "Анатолий Кулаков" Если не отправился, то вам все равно, что в этой строке было написано.
1346.46 1350.14 "Анатолий Кулаков" То есть, если ссылка была не подтверждена, значит e-mail был не валидный.
1350.14 1352.86 "Анатолий Кулаков" Вот на самом деле и все.
1352.86 1358.30 "Анатолий Кулаков" И вот рассматривая предусловия вот с этой стороны.
1358.30 1375.94 "Анатолий Кулаков" Как я уже сказал, вы можете конечно загнаться и реализовать настоящий SMTP сервер, полностью SMTP спецификацию в вашем приложении, но это абсолютно бессмысленно, потому что пользователь всегда вобьет адрес, который будет валидный, но не будет иметь никакой бизнес-ценности.
1375.94 1385.90 "Анатолий Кулаков" Он может не пользоваться, он может быть неактивным, его может вообще не существовать и так далее.
1385.90 1390.06 "Анатолий Кулаков" Всегда ли не нужно проверять e-mail адрес ни на что кроме нуля?
1390.06 1392.62 "Анатолий Кулаков" Всегда ли нужно просто отсылать e-mail и все?
1392.62 1397.06 "Анатолий Кулаков" И на этом всю проверку, всю начальную валидацию заканчивать?
1397.06 1398.06 "Анатолий Кулаков" Нет, не всегда.
1398.06 1401.70 "Анатолий Кулаков" Потому что эта валидация, она контекстно зависимая.
1401.70 1407.50 "Анатолий Кулаков" И у вас вполне может быть в программе такой контекст, где вам важен формат e-mail.
1407.50 1418.26 "Анатолий Кулаков" Например, если ваша программа еще до подтверждения e-mail оперирует с такими понятиями, как хост или юзер, который был задан до собаки.
1418.26 1422.50 "Анатолий Кулаков" Например, она может по ним сортировать, фильтровать, еще что-то делать.
1422.50 1428.02 "Анатолий Кулаков" В общем, для нее состав этого e-mail уже важен, он уже имеет какую-то семантику.
1428.02 1431.62 "Анатолий Кулаков" То есть она должна понимать, что у нее есть какой-то хост, у нее есть какой-то юзер.
1431.62 1438.98 "Анатолий Кулаков" И вот тогда, в принципе, действительно эти условия можно включить в часть валидации.
1438.98 1453.18 "Анатолий Кулаков" Но в часть валидации она включается не в том виде, в котором обычно делают, допустим, смачили с каким-то регулярным выражением или сделали контент на собаку и все, и счастливы.
1453.18 1457.22 "Анатолий Кулаков" Обычно в валидацию такие штуки включаются как попытка парсинга.
1457.22 1466.90 "Анатолий Кулаков" То есть парсинга в теме перевода менее структурированных данных в более структурированные.
1466.90 1474.70 "Анатолий Кулаков" Вот когда вы делаете вот этот перевод, когда к вам приходит менее структурированный, вам абсолютно любая строчка может зайти, там JSON, YAML, что угодно.
1474.70 1476.30 "Анатолий Кулаков" Для вас это непонятная строка.
1476.30 1481.30 "Анатолий Кулаков" И вам нужно ее преобразовать уже в те объекты, с которыми работает ваш язык, непосредственно C#.
1481.30 1484.38 "Анатолий Кулаков" То есть вы уже ее действие реализуете в какую-нибудь DTOшку.
1484.38 1492.50 "Анатолий Кулаков" И вот это преобразование, оно возможно, на его этапе возможно делать, естественно, валидацию.
1492.50 1496.70 "Анатолий Кулаков" И вот эта валидация, она обычно делается с помощью метода распаршивания.
1496.70 1505.86 "Анатолий Кулаков" То есть если в нам в частности приходит email-адрес, то его не нужно пытаться проверить на какие-то собаки или на какие-то регулярные выражения.
1505.86 1510.82 "Анатолий Кулаков" Гораздо проще воспользоваться стандартным классом, который лежит в системе netmail.
1510.82 1512.30 "Анатолий Кулаков" Этот класс называется mail-address.
1512.30 1518.50 "Анатолий Кулаков" У него есть метод try_create, который пытается создать и строки, и email-адрес.
1518.50 1526.42 "Анатолий Кулаков" И у него там, естественно, внутри есть куча проверок, которые Microsoft посчитал нужным добавить на то, что этот адрес валидный.
1526.42 1530.38 "Анатолий Кулаков" В принципе, его одной строчкой можно и использовать, то есть попытаться его распаршить.
1530.38 1538.18 "Анатолий Кулаков" И как только вы его распаршите, у вас получается, что вы соблюдаете некое предусловие.
1538.18 1542.14 "Анатолий Кулаков" То есть вашему домену важно, чтобы данные пришли именно в этом формате.
1542.14 1544.66 "Анатолий Кулаков" То есть вы реализовываете, по сути, предусловие.
1544.66 1553.50 "Анатолий Кулаков" И тогда этот процесс является типичным процессом валидации, который, в принципе, и может быть в любом приложении.
1553.50 1563.10 "Анатолий Кулаков" Вот таким образом мы посмотрели на примере Gmail, как он может относиться и к валидации, и к верификации, то есть к проверке бизнес-требований, и к проверке входных аргументов.
1563.10 1571.06 "Анатолий Кулаков" И к валидации он относится тогда, когда мы преобразуем менее структурированные данные к более структурированным данным.
1571.06 1577.06 "Анатолий Кулаков" И валидация, она, в принципе, движется двумя концепциями.
1577.06 1583.66 "Анатолий Кулаков" Это, во-первых, то, как выглядят входные данные, и то, какие данные необходимы для нашей ДТОшки.
1583.66 1585.74 "Анатолий Кулаков" То есть какие у ДТОшки есть требования.
1585.74 1593.70 "Анатолий Кулаков" Тут уже даже не про ДТОшку речь, тут уже даже больше про объект речь, то есть про бизнес-энтити речь.
1593.70 1603.06 "Анатолий Кулаков" В общем, если у этой бизнес-энтити есть какие-то предусловия, которые говорят, что мне срочно нужен правильно оформленный email-адрес, вот я только правильно оформленный люблю, других не люблю.
1603.06 1607.94 "Анатолий Кулаков" И тогда этот процесс уже обеспечивается с помощью валидации.
1607.94 1618.22 "Анатолий Кулаков" Вот такой практический пример, в принципе, на котором довольно очевидно, как можно использовать одну и ту же концепцию и в рулах, и в валидациях.
1618.22 1630.42 "Игорь Лабутин" Ну, звучит, с одной стороны, вроде как логично и очевидно, с другой стороны, когда начинаешь этим заниматься, действительно возникает вопрос регулярно бахнуть или вообще забить, проверять.
1630.42 1635.98 "Игорь Лабутин" Надеемся, что пользователь введет все нормально сразу или действительно просто попробовать что-нибудь с этим.
1635.98 1640.18 "Игорь Лабутин" IP-адрес.pars, да, или вот этот самый email-адрес create.
1640.18 1644.38 "Анатолий Кулаков" Вообще, да, самая правильная проверка – это всегда парс.
1644.38 1652.26 "Анатолий Кулаков" Если вы можете регулярно проверить, что у вас там int хранится или сделать int try-pars, то, конечно же, воспользуйтесь вторым способом.
1652.26 1657.14 "Игорь Лабутин" Только не забудьте указать правильные аргументы с учетом культуры.
1657.14 1663.78 "Игорь Лабутин" С int-ом-то ладно, а вот со всякими там double, например, где точки, где питы, вот это всё.
1663.78 1673.34 "Анатолий Кулаков" Да, безусловно, и это как раз тебя заставит задуматься о том, в каком формате оно приходит, потому что на регулярном выражении ты бы там даже и не задумывался, да, ты бы там бахнул точку и всё, и даже не думал бы об этом.
1673.34 1674.34 "Анатолий Кулаков" Прошло, но там не прошло.
1674.34 1681.82 "Анатолий Кулаков" А здесь тебе придётся задуматься, да, в каком формате оно пришлёт, а что будет в другой культуре, а там кто у нас справа налево там читает и всё такое.
1681.82 1682.82 "Анатолий Кулаков" Да, да.
1682.82 1689.86 "Анатолий Кулаков" Поэтому try-pars, он обычно более гибок в этом плане к любому типу, чем просто регулярное выражение или какой-нибудь contains.
1689.86 1696.58 "Игорь Лабутин" Ну, по крайней мере, в нём, наверное, разработчики этого самой framework или библиотеки подумали о том, что бывают разные культуры.
1696.58 1707.70 "Анатолий Кулаков" Да, просто может быть такая ситуация, когда регулярка прошла, а потом число из этой строки вы создать не смогли, ну потому что там действительно какой-то формат локализации не тот.
1707.70 1711.14 "Анатолий Кулаков" Но не может быть такой ситуации, когда у тебя try-pars не прошёл.
1711.14 1714.62 "Анатолий Кулаков" В общем, если try-pars не прошёл, значит, всё, строка не подходит однозначно.
1714.62 1715.62 "Игорь Лабутин" Да.
1715.62 1723.42 "Игорь Лабутин" Ну, что ж, удачи вам в парсинге и валидации, а мы пойдём дальше и у нас редкий гость, это Маони.
1723.42 1724.82 "Игорь Лабутин" Редкий гость в плане статей.
1724.82 1737.18 "Игорь Лабутин" Маони написала очередную статью и она прям не маленькая, при том, что она явно говорит, что ну я не стал выглядеть в детали, будут отдельные статьи более, так сказать, детальные, про все детали.
1737.18 1738.18 "Игорь Лабутин" Здесь такое overview.
1738.18 1743.38 "Игорь Лабутин" Ну, тем не менее, там статья, ну не тауб, конечно, но в стиле.
1743.38 1745.58 "Игорь Лабутин" Давайте вообще поговорим, о чём это.
1745.58 1757.26 "Игорь Лабутин" Называется она dynamically adjusting to application sizes, то есть это всё, конечно, про garbage collector, про то, как он будет адаптироваться к размеру приложений.
1757.26 1760.34 "Игорь Лабутин" Тут пока много вопросов, поэтому давайте разбираться с самого начала.
1760.34 1774.70 "Игорь Лабутин" Вообще, вообще, .NET в прошлых релизах довольно сильно фокусировался на том, чтобы сделать garbage collector более эффективным и при этом поменьше пауз, что есть, чтобы throughput был у нас побольше, вот это всё.
1774.70 1792.70 "Игорь Лабутин" Одна из больших таких фич, которая повлияла на это, это был переход на регионы вместо сегментов, что позволило поменьше сделать фрагментацию, переиспользовать эти самые небольшие регионы по сравнению с большими сегментами между разными поколениями, ну и так далее.
1792.70 1806.66 "Игорь Лабутин" Мы много про это говорили, это всё прошлые релизы, но все вот эти улучшения, которые происходили, они в основном были в предположении, что у нас так называемые ну довольно большие серверные приложения.
1806.66 1827.06 "Игорь Лабутин" То есть, во-первых, которые обычно требуют много памяти, во-вторых, у них должен быть маленький latency, ну то есть они должны быстро отвечать, и в-третьих, что они не то что требуют много памяти, но в принципе работают в таких условиях, когда довольно много памяти используется, это нормально.
1827.06 1843.82 "Игорь Лабутин" То есть если у нас есть пик нагрузки, мы сколько-то памяти заалацировали дополнительной, потому что там много запросов обрабатывали, а потоков много родилось в ThreadPool, и вот это всё, дальше с пика нагрузки вроде бы спал, но Garbage Collector не торопится очищать память, потому что ну памяти много, зачем очищать.
1843.82 1850.18 "Игорь Лабутин" И всё это, конечно же, делалось при условии, что мы используем серверный Garbage Collector.
1850.18 1861.06 "Игорь Лабутин" Напомню, что у Garbage Collector есть два принципиально разных режима работы, Workstation и сервер, при котором даже куча немножко по-разному раскладывается, сейчас мы про это чуть дальше поговорим.
1861.06 1872.30 "Игорь Лабутин" И тот самый серверный сборщик мусора был нацелен на то, чтобы максимизировать тот самый throughput, то есть как можно быстрее обрабатывать, как можно больше запросов.
1872.30 1878.70 "Игорь Лабутин" Точнее как можно больше запросов, быстрее, да, наша задача обрабатывать больше вопросов, больше запросов.
1878.70 1884.26 "Игорь Лабутин" При этом у него была такая неофициальная депутация про то, что он сжрёт дофига памяти при этом.
1884.26 1888.90 "Игорь Лабутин" Что такое дофига и что такое сжрёт, вопрос отдельный, но тем не менее.
1888.90 1903.50 "Игорь Лабутин" Но фактически он не то чтобы сжрёт память, а как написано в ООНе, у него есть потенциал использовать больше памяти, когда много памяти в системе доступно.
1903.50 1909.42 "Игорь Лабутин" То есть он будет её не очень экономно расходовать, потому что ну а зачем экономить, если её много.
1909.42 1917.86 "Игорь Лабутин" Поэтому согласно количеству логических процессоров в вашей системе у вас будет создана столько же кучи виртуальных внутри вашего процесса.
1917.86 1933.02 "Игорь Лабутин" В большинстве случаев будет запускаться бэкграунд сборка мусора, который не является компактинг, то есть сборка мусора в старшем поколении будет запускаться во втором поколении, всё там собирать, но куча будет фрагментироваться.
1933.02 1941.58 "Игорь Лабутин" И если вам нужны там какие-нибудь объекты, которые не будут влезать в эти освобожденные фрагменты, ну окей, как бы, залогить им ещё ничего страшного.
1941.58 1951.38 "Игорь Лабутин" Конечно, рано или поздно полный компактинг GC случится, когда совсем будет не хватать памяти, но на больших системах это случается всё-таки довольно редко.
1951.38 1955.22 "Игорь Лабутин" И более того, его может не случиться вообще.
1955.22 1973.22 "Игорь Лабутин" То есть вы зааллоцировали много памяти, она там как-то фрагментирована, если вы посмотрите на memory usage в каком-нибудь там, не знаю, таск менеджере условном, вам скажут, что "у-у, используют дофига памяти", если вы посмотрите на реальный размер используемой памяти, он окажется уже не таким большим.
1973.22 1974.54 "Игорь Лабутин" И в принципе это было ок.
1974.54 1983.18 "Игорь Лабутин" До 8-го дотента при этом вы могли немножко влиять на то, как ведёт себя garbage collector.
1983.18 1993.30 "Игорь Лабутин" Во-первых, можно было изменять allocation budget, насколько я понимаю это какая-то одна из скрытых опций, поэтому сильно особо не поменять.
1993.30 2009.02 "Игорь Лабутин" Ну соответственно, если там совсем memory pressure, то компактинг GC конечно включался, ну и была опция, настройка, она называется GC heap count, где вы могли явно задать, что мне нужно 2 кучи или 5 куч, или 1 куча, несмотря на количество ядер.
2009.02 2028.66 "Игорь Лабутин" Проблема с этим heap count в том, что с одной стороны он позволял, например, это всё запихнуть в какой-то маленький объём, а с другой стороны эта штука фиксирована, то есть если вы задали при начале работы приложение, что это 2 хипа, то какую бы нагрузку на ваше приложение не набрасывать, всё равно будет 2 хипа.
2028.66 2058.54 "Игорь Лабутин" В результате всего этого состояния дел получалось такое, что для действительно больших приложений с сервером GC вот это всё, а в принципе понятно, что для какого-нибудь там ISP net core приложения вы как бы логично выбрать сервер GC, это же серверное приложение, не Workstation, получалось так, что даже маленькое приложение фактически использует кучу памяти, если оно запущено на каком-нибудь большом жирном компьютере с кучей ядер, хотя оно действительно может быть маленькое и ему столько памяти и не нужно.
2058.54 2085.38 "Игорь Лабутин" Глядя на всё это, а также глядя на то, что у нас есть некоторые окружения, где у нас на самом деле мы хотим использовать поменьше памяти, в основном, конечно же, контейнеры, появилась новая фича, она экспериментальная на тот Net8, то есть её нужно включать, и называется тот самый dynamically adjusting to application size, то есть динамическая подгонка, динамическая адаптация под размер приложения.
2085.38 2089.70 "Анатолий Кулаков" Да, интересно, что критерий выбран именно в размер приложения.
2089.70 2093.58 "Игорь Лабутин" Да, вопрос, что такое этот самый размер приложения.
2093.58 2120.46 "Игорь Лабутин" Они определяют аббревиатурой LDS, это live или live data size, то есть это сколько памяти будет использовало бы ваше приложение, если вот мы прямо сейчас запустим наиболее агрессивный из доступных garbage коллекторов, в смысле что он будет компактинг, полный фул, короче, всё, что можно, соберёт, вообще всё, что можно, вот сколько приложения останется, это называется live data size.
2120.46 2124.30 "Анатолий Кулаков" Ну а как ты этого узнаешь, не попробовав?
2124.30 2131.74 "Игорь Лабутин" Вот, это интересный вопрос, эвристики, эвристики, ещё раз эвристики, сейчас поговорим, погоди, там много всего интересного.
2131.74 2132.74 "Игорь Лабутин" Ну давай.
2132.74 2138.62 "Игорь Лабутин" Смотри, цель всего этого дела, ну то есть dynamically это dynamically, а вопрос, цель-то какой мы хотим добиться.
2138.62 2150.98 "Игорь Лабутин" Цель мы хотим добиться, значит, цель простая и первая от Малони, это про то, чтобы не надо было ничего конфигурить, ну это, по-моему, стандартная мантра дотонентного garbage коллектора.
2150.98 2151.98 "Игорь Лабутин" Отличная цель, да, никогда ничего не конфигурить.
2151.98 2154.98 "Игорь Лабутин" Чем меньше мы конфигурим, тем лучше.
2154.98 2171.86 "Игорь Лабутин" Вот, и второе, это мы настраиваемся на два основных кейса, то есть наша цель не просто, как бы, сделать, чтобы это работало всегда, да, на наши два основных кейса, куда мы целимся.
2171.86 2185.86 "Игорь Лабутин" Во-первых, это ворклоды, то есть ваши приложения, которые работают в, они это называют memory constraint environments, то есть это, например, контейнеры, на которых поставлены memory лимиты или просто какая-то не очень мощная машинка.
2185.86 2190.46 "Игорь Лабутин" При этом эти приложения иногда вырабатывают какие-то пиковые нагрузки.
2190.46 2199.26 "Игорь Лабутин" То есть, грубо говоря, к ним пришли, там утром, например, что-нибудь там где-нибудь открылось, начало продаж, или что-нибудь у вас быстренько закидали запросами, а потом вы ничего не делаете.
2199.26 2206.74 "Игорь Лабутин" Вот в обычном сервере GC после закидывания запросами у вас, как бы, потребление памяти останется высоким, а вот этого не хотелось бы.
2206.74 2212.70 "Игорь Лабутин" И второй главный кейс, это небольшие приложения, но тем не менее использующие сервер garbage collector.
2212.70 2234.46 "Игорь Лабутин" В частности, именно такие, как правило, попадаются во всяких бенчмарках, когда там создаются бенчмарки, смотрится типа, вау, там, не знаю, дотнетное приложение работает по скорости, так же, как, не знаю, там, Go или Rust какой-нибудь, или еще кто-нибудь, но зато же живет в три раза больше памяти, нет, в 10 раз больше памяти, ну просто потому что garbage collector видит до фига память и спокойно ничего не собирает, хотя мог бы.
2234.46 2246.18 "Игорь Лабутин" Вот, это два, две таких, как бы, поинта, цели, не знаю, пункта, на которые они, про которые они думают, когда все это дизайнят.
2246.18 2248.94 "Игорь Лабутин" Как это все работает на очень высоком уровне?
2248.94 2250.98 "Игорь Лабутин" То есть, что такое dynamically adjusting?
2250.98 2253.74 "Игорь Лабутин" То есть, что можно adjust-ить-то?
2253.74 2257.78 "Игорь Лабутин" Adjust-ить можно две вещи, точнее, даже три вещи.
2257.78 2260.10 "Игорь Лабутин" Вещь первая, можно adjust-ить количество куч.
2260.10 2266.50 "Игорь Лабутин" То есть, как я говорил, сервер GC по дефолту создает столько куч, сколько у вас логических ядер на компе.
2266.50 2272.22 "Игорь Лабутин" Но, в принципе, ничего не мешает создавать кучи на лету, или удалять кучи на лету.
2272.22 2275.82 "Игорь Лабутин" Звучит не очень просто, но, тем не менее, делать можно.
2275.82 2280.50 "Игорь Лабутин" А второе, что можно делать, и третье, это модифицировать те самые allocation budgets.
2280.50 2285.42 "Игорь Лабутин" Напомню, что allocation budget — это такая штука, в каждом поколении он существует.
2285.42 2291.34 "Игорь Лабутин" Это то, сколько памяти может запросить приложение, не триггеря garbage collector.
2291.34 2301.58 "Игорь Лабутин" То есть, это, по сути, некоторый гарантированный объем памяти, который garbage collector, вся подсистема памяти, может выделить приложение, не триггеря никакую сборку мусора.
2301.58 2310.34 "Игорь Лабутин" И понятно, что если этот самый allocation budget, он большой, а он будет расти, он у нас динамически изменяется в зависимости от паттернов, allocates.
2310.34 2319.42 "Игорь Лабутин" Что если он большой, то у вас будет просто много вот этого свободного места жить в ожидании того, что вы сейчас опять будете много allocate-ить после, например, пиковой нагрузки.
2319.42 2324.26 "Игорь Лабутин" А фактически, пик закончился, и вам бы allocation budget уменьшить.
2324.26 2329.30 "Игорь Лабутин" Но метрики, в смысле, юристики пока такого не позволяли.
2329.30 2330.30 "Игорь Лабутин" Теперь будут.
2330.30 2336.66 "Игорь Лабутин" Ну и еще можно иногда почаще запускать полный compacting gc, чтобы убрать фрагментацию кучи.
2336.66 2339.86 "Игорь Лабутин" Но там тоже надо думать, как и когда это делать.
2339.86 2348.90 "Игорь Лабутин" Итак, получается, что мы можем adjust-ить количество хипов, мы можем менять allocation budget и что-то делать с частотой garbage-коллекторов.
2348.90 2349.90 "Игорь Лабутин" Начнем с хипов.
2349.90 2354.54 "Игорь Лабутин" Эта штука сделана уже в dotnet 8, ее можно включить, она будет работать.
2354.54 2366.82 "Игорь Лабутин" Но работа там все еще идет, там есть, я сейчас буду рассказывать, там есть куча моментов, которые пока сделаны, ну скажем так, в качестве первой прикидки, как это можно сделать, явно будут улучшаться после разных тестов.
2366.82 2370.54 "Игорь Лабутин" Она не требует никакого конфига со стороны пользователя.
2370.54 2380.94 "Игорь Лабутин" И если вот эта фича по динамическому количеству куч включена, приложение всегда стартует с одной кучей и может его количество увеличивать или уменьшать, в зависимости от необходимости.
2380.94 2385.50 "Игорь Лабутин" А необходимость определяется парой параметров.
2385.50 2390.98 "Игорь Лабутин" Для тех, кто очень любит знать все внутренние устройства garbage-коллектора, учим два новых термина.
2390.98 2403.38 "Игорь Лабутин" Один называется throughput cost, другой называется space cost, то есть некоторая плата за throughput, как мы его переводим-то… Пропускная способность.
2403.38 2405.22 "Игорь Лабутин" Да, молодец, пропускная способность.
2405.22 2410.26 "Игорь Лабутин" И space cost, это, соответственно, некоторая цена места, да, занимаемого.
2410.26 2428.74 "Игорь Лабутин" Вот эти две величины, они измеряются постоянно, и примерно каждый три garbage-коллектора, как сейчас сказано, берется медианное значение, не среднее, а именно медианное, и используется для дальнейших вычислений, надо ли что-то сделать с кучками нашей памяти.
2428.74 2437.26 "Игорь Лабутин" Что такое throughput cost, то есть про пропускную способность, цена, стоимость пропускной способности.
2437.26 2442.34 "Игорь Лабутин" По факту это штука, которая кратко описывается со следующей фразой.
2442.34 2445.66 "Игорь Лабутин" Это как долго вам нужно ждать, чтобы сделать allocation.
2445.66 2450.86 "Игорь Лабутин" Ну, есть мнение, да, довольно популярное, про то, что allocate, они очень дешевые.
2450.86 2458.10 "Игорь Лабутин" И это действительно правда, но это правда для small object heap, то есть в нулевом поколении.
2458.10 2470.30 "Игорь Лабутин" То есть если вы выделяете объект в нулевом поколении, и вы не вышли за allocation budget, все еще не израсходовали его целиком, то это действительно по сути там, поинтер подвинуть, грубо говоря, и в общем-то все.
2470.30 2479.54 "Игорь Лабутин" Но для large object heap, напоминаю, туда сразу попадут все эти большие массивы, а еще есть pinned object heap, туда попадут всякие запиненные объекты.
2479.54 2486.86 "Игорь Лабутин" Нужно сходить в garbage collector, возможно он там что-то где-то куда-то соберет, не соберет.
2486.86 2494.14 "Игорь Лабутин" И плюс там в некоторых сценариях нужно брать некоторый лог внутренний для обновления определенных структур данных.
2494.14 2508.50 "Игорь Лабутин" И он один этот лог на кучу, и соответственно, если очень много разных threads пытаются залокитить кучу всякого разного в large object heap, то на локе будет, понятно, собираться куча потоков, ждать, вот это все.
2508.50 2512.50 "Игорь Лабутин" И вот это время ожидания как раз запоминается.
2512.50 2517.22 "Игорь Лабутин" Как только кучи становится много, локи распределяются по разным кучам, и это время снижается.
2517.22 2528.26 "Игорь Лабутин" И если же мы во время локейта затребовали еще и GC собраться, ну там по старым вот эвристикам, которые там и были, то еще и запоминается время сборки garbage collector.
2528.26 2548.66 "Игорь Лабутин" И в результате вот этот вот cost, throughput cost, вычисляется как просто время ожидания локейта в small object heap, там оно обычно маленькое, плюс время ожидания в large object heap, поделенное на, эта сумма поделена на количество куч, и к этому добавляется еще длительность garbage collector.
2548.66 2552.26 "Игорь Лабутин" Напоминаю, что берется медиана.
2552.26 2554.82 "Игорь Лабутин" Дальше считается процент.
2554.82 2559.94 "Игорь Лабутин" То есть мы не оперируем абсолютными числами throughput коста, мы оперируем процентами.
2559.94 2566.70 "Игорь Лабутин" Процент просто делится вот этот вот cost, посчитанный до времени ожидания, на время прошедшее в последний garbage collector.
2566.70 2569.82 "Игорь Лабутин" И получаются некоторые проценты.
2569.82 2573.10 "Игорь Лабутин" Алгоритмы абсолютно не идеальны, над ними еще будут работать, почему?
2573.10 2586.62 "Игорь Лабутин" Потому что вот эти вот ephemeral garbage collectors, то есть это сборка нулевого и первого поколения, они как правило очень маленькие, а если мы запустили full compact garbage collector во втором поколении, то будет очень долго.
2586.62 2595.42 "Игорь Лабутин" А поскольку мы берем медиану, а не среднее, то вот эти вот экстремальные значения, да, очень долгие, очень маленькие, они никогда не будут выбраны, мы же будем брать какое-то из средненьких.
2595.42 2598.74 "Игорь Лабутин" Напоминаю, что мы это делаем раз в три garbage collector.
2598.74 2600.90 "Игорь Лабутин" И поэтому надо что-то с этим думать.
2600.90 2609.82 "Игорь Лабутин" То есть если у вас есть какие-то такие outliers, выдающиеся, что вы периодически делаете full compacting GC очень долгий, то надо как-то учитывать, пока не понятно как.
2609.82 2616.70 "Игорь Лабутин" Так что будут как-то видимо разделять, может быть будут считать отдельно короткие garbage collectors, отдельно длинные, между ними еще как-то что-то усреднять.
2616.70 2628.26 "Игорь Лабутин" Это был про throughput cost, то есть если вот этот процент подрастает, значит надо скорее всего увеличивать количество куч.
2628.26 2629.26 "Игорь Лабутин" Как?
2629.26 2630.26 "Игорь Лабутин" Сейчас дальше расскажу.
2630.26 2635.74 "Игорь Лабутин" Дальше у нас есть spaced cost, то есть стоимость, некоторая цена, стоимость места занимаемого.
2635.74 2643.98 "Игорь Лабутин" Здесь, соответственно, trade-off между тем, как много мы запускаем garbage collector и как много памяти мы используем.
2643.98 2647.54 "Игорь Лабутин" Понятно, что чем чаще мы запускаем, тем скорее всего меньше памяти мы будем использовать.
2647.54 2659.70 "Игорь Лабутин" Но с другой стороны, чем больше памяти мы можем использовать в системе, тем менее часто нужно запускать, и поэтому в результате они посчитали, что окей.
2659.70 2670.86 "Игорь Лабутин" Вот этот spaced cost тоже считается в процентах, поэтому spaced cost percentage считается как размер, как у них написано extra HIPAA, поделенный на общий размер HIPAA.
2670.86 2673.58 "Игорь Лабутин" Возникает вопрос, что такое размер extra HIPAA.
2673.58 2681.66 "Игорь Лабутин" И один из вариантов был то, сколько юзерский код allocated на HIPAA.
2681.66 2700.26 "Игорь Лабутин" То есть понятно, что в HIPAA лежат же всякие служебные структуры, куча всего того, чего сама, ну в общем, framework там для себя allocated, это все, там объекты типов, все-все-все, что нужно, чтобы ваша программа работала, плюс то, что юзер сам allocated, ну код программы.
2700.26 2703.50 "Игорь Лабутин" Так вот давайте возьмем то, что allocated код программы.
2703.50 2710.74 "Игорь Лабутин" Но потом подумали и решили, что все-таки сейчас это будет allocation budget для нулевого поколения.
2710.74 2717.94 "Игорь Лабутин" Почему так сделано, не объясняется, но вот выбрали такое значение сейчас и написано, что это точно изменится.
2717.94 2724.14 "Игорь Лабутин" Поэтому это пока так, для исторической справки скорее всего уже будет нужно, возможно к релизу все изменится.
2724.14 2730.58 "Игорь Лабутин" Окей, у нас есть 2 значения в процентах, spaced cost и throughput cost.
2730.58 2733.94 "Игорь Лабутин" Нам на основании них нужно решить, что мы вообще делаем.
2733.94 2739.94 "Игорь Лабутин" Нужно ли нам увеличивать количество куч, уменьшать количество куч или ничего не делать.
2739.94 2748.94 "Игорь Лабутин" Значит, увеличивать нам нужно, если мы уменьшим throughput cost больше, чем мы потеряем в spaced cost.
2748.94 2756.86 "Игорь Лабутин" Потому что понятно, что увеличивая количество куч, мы увеличиваем spaced cost на самом деле, потому что служебной информации будет больше, там вот это все.
2756.86 2768.46 "Игорь Лабутин" Adjust down, то есть уменьшаем количество куч, если мы сэкономим на spaced cost больше, чем потеряем на throughput cost.
2768.46 2773.06 "Игорь Лабутин" Причем больше у них градация сейчас проведена ровно на 1%.
2773.06 2780.30 "Игорь Лабутин" То есть если мы, вот эта вот разница в экономиях достигнет больше, чем 1%, да, можно делать.
2780.30 2785.30 "Игорь Лабутин" Но тоже будет возможно как-то меняться, адаптироваться, не знаю.
2785.30 2793.98 "Игорь Лабутин" И вот возникает вопрос, насколько много adjust, мы поняли, окей, нам нужно увеличить количество куч, на сколько, на 1, на 2, на 5, на 10, ну как бы непонятно.
2793.98 2803.90 "Игорь Лабутин" И здесь простая логика, соответственно, если throughput cost уже высокий, то есть больше 10%, то мы увеличиваем настолько, чтобы он снизился до 5%.
2803.90 2812.62 "Игорь Лабутин" Ну а если где-то между 5 и 10, то мы там по одной кучке добавляем, если меньше 5, то и вообще ничего не делаем.
2812.62 2819.18 "Игорь Лабутин" С этим всем алгоритмом есть пока несколько проблем, про которые Маони вполне открыто говорит.
2819.18 2836.06 "Игорь Лабутин" Про то, что, во-первых, это все настолько основано на куче статистики, что даже если вы запустите одно и то же приложение на одном и том же компе, примерно в одинаковых условиях, поведение может быть принципиально разным, где-то он начнет увеличивать кучу, где-то начнет уменьшать кучу, то есть алгоритм пока еще не очень стабилен.
2836.06 2841.14 "Игорь Лабутин" Так что будут изменения.
2841.14 2852.26 "Игорь Лабутин" Уменьшают количество куч, они слишком агрессивны, как мне кажется, и поэтому тоже будут над этим работать.
2852.26 2863.14 "Игорь Лабутин" Ну и написано, что с одной стороны, цель была, как ты помнишь, как можно меньше конфигурить, с другой стороны, написано в списке проблем, expect to make this more configurable.
2863.14 2868.06 "Игорь Лабутин" Так что меньше конфигурить, но если надо будет, то мы будем конфигурить.
2868.06 2873.30 "Анатолий Кулаков" Ну, можно пользователями меньше конфигурить, а там сами микрософтовцы могут тюнить.
2873.30 2874.30 "Игорь Лабутин" Да.
2874.30 2878.78 "Игорь Лабутин" Это все мы проговорили пока только про изменение количества куч.
2878.78 2882.94 "Игорь Лабутин" У нас еще есть allocation budget, как вы помните, который тоже можно куда-то двигать.
2882.94 2901.90 "Игорь Лабутин" Оказывается, есть настройка garbage collector, который был заимплеменчен в шестом дотнете и в дотнет фреймворк 4.8, который абсолютно нормально документирован на портале документации Microsoft и называется conserve memory.
2901.90 2906.42 "Игорь Лабутин" Что-то мы ее где-то пропустили, я не помню, что мы про нее рассказывали.
2906.42 2907.62 "Игорь Лабутин" Да, я тоже не припомню.
2907.62 2911.66 "Игорь Лабутин" Короче, это абсолютно официальная документация, абсолютно официальная настройка.
2911.66 2915.58 "Игорь Лабутин" Это число, значение от 0 до 9, включительно.
2915.58 2919.46 "Игорь Лабутин" Если вы используете число 0, это дефолтное значение, означает дефолтное поведение.
2919.46 2922.86 "Игорь Лабутин" То есть не надо ничего консервировать, все работает, как работает.
2922.86 2935.78 "Игорь Лабутин" А вот если вы ставите от 1 до 9, то чем выше значение, тем больше garbage collector старается сохранить память и держать кучку маленькой, ну или кучи, если это сервер garbage collector.
2935.78 2944.38 "Игорь Лабутин" Больше запусков, large object heap, соответственно, будет более агрессивно компактится, если надо.
2944.38 2949.98 "Игорь Лабутин" И вот это число от 1 до 9, оно интерпретируется следующим образом.
2949.98 2955.10 "Игорь Лабутин" Если вы указали, например, 7, то это интерпретируется как 70%.
2955.10 2966.14 "Игорь Лабутин" Это вычитается из сотни, остается 30%, и это означает, что только 30% хипа могут содержать неживые данные.
2966.14 2970.22 "Игорь Лабутин" Ну то есть живые данные не могут занимать меньше 70%, получается.
2970.22 2979.46 "Игорь Лабутин" То есть если вы поставите 9, это будет означать, что только 10% вашего хипа garbage collector будет пытаться поддерживать, ну хоть как-то незаполненным.
2979.46 2986.22 "Игорь Лабутин" То есть если количество свободной памяти превышает, которую освободилось после garbage collector, он будет компактить все тогда.
2986.22 3005.42 "Игорь Лабутин" Но на самом деле это как бы совсем прямолинейно, там на самом деле есть некоторая тоже эвристикология, где-то они чиселки делят на 2, чтобы быть чуть более консервативными и не так агрессивно все там компактить, потому что компактинг все-таки во втором поколении сложно и дорого.
3005.42 3011.14 "Игорь Лабутин" Так вот, вот это вот новая фича про dynamically adjusting.
3011.14 3017.22 "Игорь Лабутин" Если вы явно не указали conserve memory, то она ее проставляет просто в пятерку.
3017.22 3029.26 "Игорь Лабутин" То есть это будет означать, что у вас в garbage collector будет пытаться работать так, чтобы ваши реальные живые объекты занимали не меньше половины общего объема памяти вашего приложения.
3029.26 3032.70 "Игорь Лабутин" То есть меньше они не смогут заниматься.
3032.70 3044.90 "Игорь Лабутин" Ну и баджет, он собственно считается как обычно, но поставлен минимум все-таки в 2,5 мегабайта, потому что меньше там будет совсем неэффективно.
3044.90 3046.98 "Игорь Лабутин" Итого, результаты.
3046.98 3060.46 "Игорь Лабутин" В статье есть очень мало бенчмарков, там есть как бы просто графики из каких-то их официальных бенчмарков, но для примера они взяли сервер с 28 ядрами логическими и 32 гига памяти.
3060.46 3072.82 "Игорь Лабутин" То есть по дефолту, если вы запустите на таком сервере .NET на приложение, у вас будет создано 28 хипов внутри и как-то он там будет работать, ну с серверным ЖЦ, конечно.
3072.82 3078.66 "Игорь Лабутин" И они прогнали какие-то свои стандартные бенчмарки с этой опцией и без этой опции.
3078.66 3090.78 "Игорь Лабутин" Так вот, в среднем, в среднем, working set, то есть то, что вы видите в Task Manager и так далее, уменьшился на 73% по памяти.
3090.78 3095.70 "Игорь Лабутин" При этом пропускная способность тоже немножко уменьшилась на 2.3%.
3095.70 3104.34 "Игорь Лабутин" То есть мы память сэкономили где-то в 3 раза, а throughput ну типа там на 2% уменьшился.
3104.34 3108.14 "Игорь Лабутин" Вроде как выглядит неплохо.
3108.14 3114.06 "Игорь Лабутин" При этом было пара или тройка тестов, где throughput уменьшился аж на 10%.
3114.06 3116.58 "Игорь Лабутин" Это прям недопустимые изменения.
3116.58 3121.18 "Игорь Лабутин" Если такое будет дальше, то фичу надо сильно допиливать.
3121.18 3127.94 "Игорь Лабутин" Но даже в этих случаях время в garbage collector выросло типа там с 0.4% до 2.4%.
3127.94 3134.38 "Игорь Лабутин" То есть скорее всего дело не в garbage collector, а в чем-то другом, но будут разбираться, смотреть.
3134.38 3135.38 "Игорь Лабутин" Такие дела.
3135.38 3145.34 "Игорь Лабутин" То есть кажется, что фича будет прям суперкруто экономить память, но в контейнерах это может быть действительно важно, освобождать ее относительно агрессивно, при этом не сильно влияя на throughput.
3145.34 3150.94 "Игорь Лабутин" И остается последний момент, как же это все поиспользовать и попробовать, если вы уже на восьмом дотнете.
3150.94 3154.82 "Игорь Лабутин" Во-первых, вам нужно использовать сервер GSC, это обязательно.
3154.82 3160.90 "Игорь Лабутин" Во-вторых, не указывать явно количество куч, если вы укажете, фича тут же отключается.
3160.90 3168.26 "Игорь Лабутин" Ну и дальше три стандартных опции, либо через runtime.config.json, либо через msbuild.property, либо через переменное окружение.
3168.26 3170.26 "Игорь Лабутин" Называется это все gc_dynamic_adaptation_mode.
3170.26 3178.70 "Игорь Лабутин" Ну хотя в msbuild почему-то они назвали garbage collector adaptation mode, почему-то слова динамика там нет, я не знаю, ну в общем как-то так.
3178.70 3188.02 "Игорь Лабутин" И в восьмерке ее нужно будет включать явно, надеются, что со следующего релиза будет уже прям всегда включена по умолчанию.
3188.02 3193.06 "Анатолий Кулаков" Ну да, то есть она все-таки в восьмерку не попадет по дефолту, она еще сильно недопиленная штука.
3193.06 3196.26 "Игорь Лабутин" Ну пока кажется, что там все-таки с эвристиками все не очень.
3196.26 3200.86 "Игорь Лабутин" Ну то есть понятно, что Маони, она мастер эвристик, ну и ее команда.
3200.86 3219.58 "Игорь Лабутин" И скорее всего они все это будут в рамках там релиз кандидатов, когда это все выкатится на всяких first party кастомеров, и тех, у кого всякие прикольные и разнообразные нагрузки, посмотрят, как все это работает, посмотрят, как эвристики работают, и поймут, что adjust.
3219.58 3226.62 "Игорь Лабутин" Я не думаю, что они успеют сделать прям и будут готовы это все, скажем так, включать по дефолту.
3226.62 3235.58 "Игорь Лабутин" Может быть, максимум на что я надеюсь, это то, что они выведут ее из разряда экспериментал, скажут, ну да, типа вот фича, можете включать, если хотите, но по дефолту выключена.
3235.58 3249.74 "Анатолий Кулаков" Интересно, они как-то собирают статистику, насколько она хорошо работает, ну чтобы ее в будущем как-то тюнить или какие-то еще выводы делать, они же не могут на первых кастомерах собрать эту статистику, а на весь остальной мир распустить и все, и понадеяться, что все будет хорошо.
3249.74 3255.18 "Игорь Лабутин" Я так понимаю, что они, ну а как они, например, про файл guided optimization так на всех раскатывали, ровно так же?
3255.18 3256.18 "Анатолий Кулаков" На своих?
3256.18 3259.50 "Анатолий Кулаков" Да, то есть нам маленькие выборки попробовали, а на остальных надеяться, что она работает.
3259.50 3261.46 "Игорь Лабутин" Типа того, ну а дальше получают весь из полей.
3261.46 3271.34 "Анатолий Кулаков" Ну, как-то странно, да, для современных технологий и в связи с дисущего интернета могли бы поставить флажок, чтобы вывести статистику работы какой-нибудь.
3271.34 3273.34 "Игорь Лабутин" Да-да-да, вспоминая MockU.
3273.34 3280.82 "Анатолий Кулаков" Да-да, я вот тоже пытаюсь вывести, что типа, насколько это было бы нормальное поведение или ненормальное.
3280.82 3293.54 "Игорь Лабутин" Не, ну видишь, всякие IDE и прочие штуки телеметрию собирают, а здесь у тебя будет, по сути, они собираться из ну как бы продакшена, надо понимать, что, возможно, у кого-то продакшен крутится вообще там, где ты, ну как бы не пошлешь ничего наружу.
3293.54 3302.78 "Анатолий Кулаков" Не, ну от тех и не надо, нам надо хотя бы там хоть чуть-чуть, я думаю, процентов 50 пользователей бы точно пришло, если бы они решились.
3302.78 3304.78 "Анатолий Кулаков" Может быть, может быть, не знаю.
3304.78 3313.86 "Анатолий Кулаков" Не, ну на самом деле, действительно, это слишком грязно было бы, когда у вас с продакшена как бы что-то утекает на сервера Микрософта, иди, поди докажи, что там статистика.
3313.86 3319.90 "Игорь Лабутин" Ну только если там, не знаю, где-нибудь файлик, в котором всё написано, да, и периодически его отсылают, но это очень многоручная работа.
3319.90 3325.46 "Анатолий Кулаков" Да, тем более, опять же, мы же говорим про ГЦ, ну какой файлик, кто там будет из ГЦ файлики писать?
3325.46 3331.02 "Игорь Лабутин" Ну, ивент-каунтер, и специальная Тулза, которая из ивент-каунтеров соберёт что-нибудь.
3331.02 3346.70 "Игорь Лабутин" Да не, я думаю, что опять же, надо понимать, что у них же, может быть, действительно они какие-нибудь ивент-каунтеры сделают, и, например, например, я не знаю, насколько это как бы, они могут это с точки зрения лицензии позволять, они же, например, могут посмотреть, как живёт всё, что в Ажуре хостится.
3346.70 3354.82 "Анатолий Кулаков" Ну в Ажуре, да, вполне, почему нет, у них там в стилеметрии полно натыкано и так, лишний каунтер никто не заменит, не заметит.
3354.82 3364.58 "Игорь Лабутин" Ну я не с точки зрения, заметят, не заметят, я с точки зрения, как бы могут ли они вот так прям смотреть в каунтеры всех клиентов, да, и какую-то статистику на основе них собирать, фиг знает.
3364.58 3377.58 "Анатолий Кулаков" Да, мне кажется, Ажура – это очень хорошая тема, что ну в качестве площадки для именно наблюдений, понять, как их инструменты ведут себя в живой природе, то есть как ими пользуются.
3377.58 3380.14 "Анатолий Кулаков" Поэтому да, да, Ажура – хорошая тема.
3380.14 3382.70 "Игорь Лабутин" Ну вот, видимо, там и будут обкатывать.
3382.70 3384.18 "Игорь Лабутин" Ладно, ждём, посмотрим.
3384.18 3407.86 "Игорь Лабутин" Ну вообще, мне кажется, что по сравнению, в смысле, не по сравнению, а помимо, наверное, Native Out, который сейчас такой фокус, да, фокус прям восьмёрки, это, наверное, одна из таких важных low-level, в каком-то смысле, фич, но которая будет довольно сильно импактить много кого, потому что я опять ожидаю после выхода восьмёрки кучу статей про то, что вау, там .NET ещё ускорился.
3407.86 3414.06 "Игорь Лабутин" Вот, то есть Тауп, я так понимаю, готовит новую статью наверняка про то, что… Про перформанс.
3414.06 3419.46 "Игорь Лабутин" Про перформанс, да, я с ужасом жду, и нам нужен будет, наверное, целый выпуск подкаста опять же про неё.
3419.46 3423.66 "Игорь Лабутин" Вот, не уверен, что мы будем обозревать её целиком пока.
3423.66 3439.42 "Игорь Лабутин" Тут сейчас кто-то же, кто-то же… А, этот самый Джеймс Ньютон Кинг тут какую-то статью тоже в блог писал, в твиттере написал, что типа «мм, я написал новую статью, короче, и перед публикацией решил сравнить с размером статьи, которую Тауп готовит про перформанс».
3439.42 3446.54 "Игорь Лабутин" Ну, короче, размер моей статьи большой, я долго её писал, был полтора процента от статьи Таупа.
3446.54 3452.34 "Игорь Лабутин" Так что я это с ужасом жду, там, не знаю, трёхчасовой выпуск радио .NET, разбор перформанс, значит, оптимизация.
3452.34 3453.34 "Игорь Лабутин" С засчитыванием ИЛИ.
3453.34 3456.78 "Игорь Лабутин" Да, да, да, асемблера, чё ты, какой ИЛИ?
3456.78 3467.30 "Игорь Лабутин" Я думаю, что мы там до асемблера спустимся, будем изучать тонкости различия между там AMD64 и ARM64, не знаю, викторизации, вот это всё.
3467.30 3478.82 "Игорь Лабутин" Фича, мне кажется, важная, понятно, что на самом деле я, наверное, не прав, сказав, что в восьмёрке все там будут вах-вах, потому что в восьмёрке-то её надо будет включать явно, и понятно, что все, кто будут просто бенчмаркать.
3478.82 3481.42 "Игорь Лабутин" Восьмой .NET, скорее всего, её включать не будут.
3481.42 3485.34 "Анатолий Кулаков" Ну да, это будет ближе к девятке, там будем смотреть, скорее всего, про неё.
3485.34 3486.34 "Игорь Лабутин" Да, да.
3486.34 3487.34 "Игорь Лабутин" Ну, в общем, вот.
3487.34 3498.98 "Анатолий Кулаков" Ну, хорошая тема, давай после такого мозгодробительного материала немножко расслабимся и поговорим как раз-таки на лайтовые базорные темы.
3498.98 3503.14 "Анатолий Кулаков" Например, нашёл хорошую статейку про бест-практисы в юнит-тестингах.
3503.14 3516.46 "Анатолий Кулаков" Казалось бы, да, юнит-тестинги – заезженная тема, все вроде всё знают, но нет, нет, есть всё-таки практики, которые очень простые, которых очень элементарно придерживаться, но почему-то люди упорно не хотят ими следовать.
3516.46 3523.34 "Анатолий Кулаков" И автор говорит, что надо, ребята, надо, соберитесь уже наконец и сделайте нормальные тесты, вот хотя бы вот на таком минимальном уровне.
3523.34 3527.26 "Анатолий Кулаков" Давайте посмотрим, что нам советует товарищ автор.
3527.26 3555.62 "Анатолий Кулаков" Прежде всего он напоминает, что юнит-тесты – это прям критическая часть современного софтварного обеспечения, что действительно любая программа должна иметь у себя юнит-тесты, потому что они позволяют вам быть уверенным в будущем вашей программы, в том, что она работает так, как вы предполагали, в том, что когда вы будете рефакторить ваш код, он не развалится просто так у вас на глазах, и в том, что когда вы добавите новую фичу, она будет не настолько деструктивна, что старые фичи перестанут работать.
3555.62 3560.78 "Анатолий Кулаков" Ну, в общем, польза юнит-тестов, она в принципе довольно очевидна и довольно понятна.
3560.78 3566.70 "Анатолий Кулаков" Прежде всего они дают вам гарантию того, что вы можете безбоязненно, безболезненно менять существующий код.
3566.70 3567.98 "Анатолий Кулаков" И это самое главное.
3567.98 3579.66 "Анатолий Кулаков" Когда вы боитесь тронуть какой-то код, который там писали год назад, аргументируя это тем, что я не знаю, что случится, я не знаю, как оно упадет, я не знаю, как оно работает.
3579.66 3596.58 "Анатолий Кулаков" Вот это вот типичная ситуация, когда у вас не хватает тестов, когда вы не можете сопровождать ваш код, когда вы не можете обновлять, тогда вы скорее всего не сможете перейти и на новые фреймворки, и заиспользовать новые фичи языка, и заиспользовать какие-то новые подходы, которые появляются в индустрии, и ваше приложение очень быстро станет легоси.
3596.58 3608.18 "Анатолий Кулаков" Поэтому самая главная прелесть юнит-тестов в том, что они помогают вашему коду всегда гарантировать, что он выдает именно ту работоспособность, на которую был рассчитан.
3608.18 3617.86 "Анатолий Кулаков" То есть по сути вы можете ваш код как угодно рефакторить, как угодно менять, обновлять, переводить на новые фреймворки, и по-хорошему, если тесты прошли, значит все хорошо.
3617.86 3623.30 "Анатолий Кулаков" Если вы потом убеждаетесь, что оказывается было все плохо, это всего лишь на все обозначает, что тестов у вас мало.
3623.30 3624.30 "Анатолий Кулаков" Дописывайте еще тесты.
3624.30 3631.14 "Анатолий Кулаков" В общем, тесты важны, и чем более они будут понятными, предсказуемыми, выразительными и чистыми, тем лучше.
3631.14 3637.50 "Анатолий Кулаков" Теперь давайте посмотрим, как же можно добиться, какими практиками можно добиться качества тестов.
3637.50 3643.06 "Анатолий Кулаков" Прежде всего нужно следить за чистотой и читабельностью тестов.
3643.06 3648.54 "Анатолий Кулаков" То есть давать им понятные имена, которые отражают ту суть, то есть что именно они тестируют.
3648.54 3655.94 "Анатолий Кулаков" Это тоже довольно важно, особенно когда вы пытаетесь быстро понять, что у вас свалилось, быстро сориентироваться в упавшей баге.
3655.94 3658.46 "Анатолий Кулаков" Имена - это первое, на что вы будете смотреть.
3658.46 3674.38 "Анатолий Кулаков" Если они вам расскажут про контекст, расскажут про задачи этого теста, то есть на чем именно он свалился, то в большинстве случаев разработчики, особенно те разработчики, которые в контексте данного приложения, могут даже по названию понять, в чем проблема.
3674.38 3675.38 "Анатолий Кулаков" Что у такого?
3675.38 3678.78 "Анатолий Кулаков" Я затронулся, что могла вот эта именно часть упасть.
3678.78 3688.22 "Анатолий Кулаков" Вторая рекомендация - следуйте шаблону Range, Act and Assert, так называемый ААА.
3688.22 3697.90 "Анатолий Кулаков" Это очень тоже полезный шаблон, он вам советует делить весь ваш тестовый метод на три явные части.
3697.90 3700.74 "Анатолий Кулаков" Первая часть, когда вы данные подготавливаете.
3700.74 3708.10 "Анатолий Кулаков" Вторая часть, когда вы вызываете метод, который хотите протестировать, то есть делаете непосредственно само действие.
3708.10 3713.42 "Анатолий Кулаков" И последняя часть - это Assert, когда вы проверяете то, что вам вернул этот метод.
3713.42 3720.50 "Анатолий Кулаков" У меня даже уже довольно давно сложилось такой сниппет, то есть я тестовые методы пишу с помощью сниппета.
3720.50 3726.22 "Анатолий Кулаков" Вот, набираю слово "факт" и он меня генерирует, XUnit-овский факт метод.
3726.22 3734.26 "Анатолий Кулаков" И в этом сниппете, прямо внутри метода уже вставлены комментарии, которые отделяют явно вот эти три блока.
3734.26 3743.18 "Анатолий Кулаков" Казалось бы, что в обычных маленьких тестах все эти три блока видно глазами, их не обязательно как-то выделять, достаточно подставить отступ строки.
3743.18 3756.62 "Анатолий Кулаков" Но на самом деле, если это будет выделиться комментариями, комментарии пишутся прекрасным зеленым цветом, то есть они хорошо в глаза бросаются, очень помогает на самом деле, даже на мелких тестах, в которых всего три строчки.
3756.62 3765.70 "Анатолий Кулаков" Вот подобный шаблон, плюс с явным выделением насчет комментариев очень помогает ориентироваться и в старых, и в новых тестах.
3765.70 3769.86 "Анатолий Кулаков" Третья рекомендация - используйте тестовые фреймворки, такие как XUnit и NUnit.
3769.86 3785.06 "Анатолий Кулаков" Я тут не очень понимаю, на что автор намекает, но наверное у него были прецеденты, когда люди сами писали свой грубо говоря тестовый фреймворк, то есть сами выдумывали, каким образом им запускать их методы и каким образом проверять, что эти методы отработали корректно, наверное так.
3785.06 3793.46 "Анатолий Кулаков" Ну в общем да, огородить и огород не стоит, есть прекрасные фреймворки, которые отлично поддерживаются всеми инструментами, куча бестпрактисов и все такое.
3793.46 3797.26 "Анатолий Кулаков" Тут наверное комментировать сложно, просто их используйте, без исключений.
3797.26 3802.18 "Анатолий Кулаков" Следующая рекомендация - это упрощенность.
3802.18 3818.30 "Анатолий Кулаков" Как я уже сказал, автор рекомендует паттерн AAA использовать, который помогает как раз таки сфокусироваться на каждой из этих частей отдельно и представить код в более простом виде, не смешивая вот эти части.
3818.30 3824.34 "Анатолий Кулаков" В принципе, когда они не смешиваются, идут друг за другом, то и осознавать легко, и тестировать легко.
3824.34 3834.14 "Анатолий Кулаков" И следующую рекомендацию к этим частям советую делать, это маленькая ренч секция, то есть подготовка данных должна быть довольно минималистичной.
3834.14 3842.58 "Анатолий Кулаков" Один единственный вызов акта всегда должен быть одной строчкой, то есть вы вызываете какой-то метод, и все, больше в акте у вас ничего не должно быть.
3842.58 3860.06 "Анатолий Кулаков" И довольно интересная штука - это у вас всегда должен быть один ассерт, для того чтобы если вы на чем-то упали, то по названию теста было бы сразу понятно, на чем вы упали, на каком свойстве, который проверяет этот ассерт.
3860.06 3869.86 "Анатолий Кулаков" Допустим, если вы вернули какой-то сложный объект, допустим, юзера, у которого 5 полей, и вы хотите проверить правильное форматирование всех этих 5 полей.
3869.86 3878.62 "Анатолий Кулаков" По-хорошему вы должны написать 5 тестов, и каждый назвать таким образом, чтобы вы поняли, что если первое поле свалилось, вы по названию теста увидели, что именно в первом поле проблема.
3878.62 3882.90 "Анатолий Кулаков" Второе поле - это уже другой тест будет, который будет вторым ассертом делать.
3882.90 3890.18 "Анатолий Кулаков" Очень часто этим требованием пренебрегают, особенно если логика не такая уж страшная, не такая уж большая, не такая сложная.
3890.18 3892.90 "Анатолий Кулаков" Можно зафигачить все эти 5 полей 5 ассертами.
3892.90 3897.70 "Анатолий Кулаков" Тут, мне кажется, особой проблемы быть не должно.
3897.70 3901.46 "Анатолий Кулаков" Следующая рекомендация - это всегда держите код простым.
3901.46 3905.22 "Анатолий Кулаков" Простым в плане цикломатической сложности.
3905.22 3909.42 "Анатолий Кулаков" В тестах цикломатическая сложность всегда должна равняться единице.
3909.42 3913.10 "Анатолий Кулаков" Это значит, что в ваших тестах никогда не должно быть вветвления.
3913.10 3919.30 "Анатолий Кулаков" Там всякие if, else, операторы туда-сюда.
3919.30 3921.86 "Анатолий Кулаков" В общем, про них забудьте.
3921.86 3924.54 "Анатолий Кулаков" Любой if, else добавляют сразу к комплексности +1.
3924.54 3927.54 "Анатолий Кулаков" Их в тестах быть не должно.
3927.54 3933.70 "Анатолий Кулаков" По той простой причине, что на самом деле тесты как раз тестируют вот эту цикломатическую сложность.
3933.70 3945.98 "Анатолий Кулаков" Если ваш метод полностью линейный, полностью плоский, в нем нет ни одного if, else, нет фурычьих условий, еще чего-то, то скорее всего и тестировать его особо и не нужно.
3945.98 3948.10 "Анатолий Кулаков" В нем вы ничего такого не протестируете.
3948.10 3950.42 "Анатолий Кулаков" Этот код можно считать практически декларативным.
3950.42 3952.66 "Анатолий Кулаков" А декларацию тестировать бесполезно.
3952.66 3954.18 "Анатолий Кулаков" Она или есть, или нет.
3954.18 3955.18 "Анатолий Кулаков" Другого не дано.
3955.18 3956.18 "Анатолий Кулаков" Она не может работать неправильно.
3956.18 3962.42 "Анатолий Кулаков" А вот когда у вас появляются if, else, вот эти методы, их обязательно нужно тестировать уже внимательно и тщательно.
3962.42 3970.06 "Анатолий Кулаков" И когда у вас появляются if, else, соответственно, в самих тестах, фактически это означает, что вашим тестам теперь нужны тесты.
3970.06 3978.70 "Анатолий Кулаков" А те тесты, которые будут тестировать ваши тесты, они если тоже себе позволят написать какой-нибудь if, else, то и на них тоже, естественно, нужны тесты.
3978.70 3985.66 "Анатолий Кулаков" И таким образом эта кроличья нора может стать абсолютно бесконечной, когда вам нужно будет писать тесты на unit-тесты, на unit-тесты, на unit-тесты.
3985.66 3993.50 "Анатолий Кулаков" Поэтому чтобы не сломать себе мозг, просто-напросто не пишите никаких if в unit-тестах.
3993.50 3995.82 "Анатолий Кулаков" Цикломатическая сложность всегда должна быть равна единице.
3995.82 4000.02 "Анатолий Кулаков" Следующее полезное свойство, к которому стоит придерживаться, это изолированность.
4000.02 4004.14 "Анатолий Кулаков" Изолированность это означает, что тесты не должны ни от чего зависеть.
4004.14 4005.14 "Анатолий Кулаков" Unit-тесты, естественно.
4005.14 4006.50 "Анатолий Кулаков" Мы сейчас все говорим про unit-тесты.
4006.50 4015.02 "Анатолий Кулаков" Они не должны зависеть прежде всего от других тестов, которые выполняются в этот момент, тем более от порядка тестов, которые тоже иногда очень хочется воткнуть.
4015.02 4019.42 "Анатолий Кулаков" И также они не должны зависеть ни от каких внешних зависимостей.
4019.42 4025.22 "Анатолий Кулаков" Для того, чтобы это обеспечить, есть разные подходы, разные методы, но в основном используют какие-нибудь моки.
4025.22 4028.30 "Анатолий Кулаков" Особенно если вы там хотите замокать доступ к какой-нибудь базе данных.
4028.30 4030.18 "Анатолий Кулаков" Естественно, в unit-тестах она вам не нужна.
4030.18 4033.42 "Анатолий Кулаков" И там вполне рабочий вариант.
4033.42 4039.86 "Анатолий Кулаков" Если тест начинает зависеть от какой-то внешней зависимости, это на самом деле очень-очень плохо.
4039.86 4043.86 "Анатолий Кулаков" Прежде всего, это отличный повод для того, чтобы падать.
4043.86 4046.34 "Анатолий Кулаков" Недетерминированно падать, непонятно в какой ситуации.
4046.34 4053.18 "Анатолий Кулаков" Потому что вы теперь должны контролировать не только сам тест, как он выполняется, но и ту зависимость, на которую он рассчитывает.
4053.18 4060.02 "Анатолий Кулаков" Также эти тесты обычно более медленные, что для unit-тестов тоже очень критично.
4060.02 4062.18 "Анатолий Кулаков" Их всегда нужно держать как можно быстрее.
4062.18 4064.34 "Анатолий Кулаков" Чтобы они запускались как можно быстрее.
4064.34 4071.62 "Анатолий Кулаков" И также, если у вас есть какая-то внешняя зависимость у ваших тестов, то обычно такие тесты сложнее параллелить.
4071.62 4073.54 "Анатолий Кулаков" А параллельность это тоже хорошо.
4073.54 4076.06 "Анатолий Кулаков" Особенно когда у вас миллиарды и миллионы тестов.
4076.06 4078.66 "Анатолий Кулаков" Параллельность там реально спасает.
4078.66 4083.22 "Анатолий Кулаков" Следующая важная характеристика, которая у unit-тестов должна быть, это повторяемость.
4083.22 4094.14 "Анатолий Кулаков" То есть у вас должен быть один и тот же результат на любых средах, на любых условиях, независимо от того, где и как вас запускают.
4094.14 4097.22 "Анатолий Кулаков" Если результат у вас разный, значит вы сделаете что-то не так.
4097.22 4100.10 "Анатолий Кулаков" Значит эти тесты плохие, их нужно передумывать.
4100.10 4110.22 "Анатолий Кулаков" Соответственно ваши тесты не должны зависеть от дня времени, или фазы луны, или компьютера, на котором он запускается, или окружения, на котором он запускается.
4110.22 4116.22 "Анатолий Кулаков" В общем, такие все вещи, они должны изолироваться с помощью моков или других средств.
4116.22 4123.50 "Анатолий Кулаков" Поэтому тесты всегда на всех машинах, в любых условиях, в любом дне времени должны выполняться одинаково.
4123.50 4126.58 "Анатолий Кулаков" С одними и тем же входными и выходными аргументами.
4126.58 4129.22 "Анатолий Кулаков" Следующее свойство это быстрота.
4129.22 4131.94 "Анатолий Кулаков" Unit-тесты должны всегда быть очень быстрыми.
4131.94 4133.78 "Анатолий Кулаков" Максимально быстрыми, сколько это можно.
4133.78 4143.58 "Анатолий Кулаков" И в принципе, если вы соблюдаете там предыдущие правила, то есть не делаете каких-то внешних депенденций, то это так и будет, в принципе, и с этим проблем никаких нет.
4143.58 4147.34 "Анатолий Кулаков" Также минимизируйте input-output операции.
4147.34 4151.42 "Анатолий Кулаков" Старайтесь не обращаться с каким-нибудь файлом к сети и так далее.
4151.42 4154.10 "Анатолий Кулаков" То есть в unit-тестах обычно этого не нужно, это все нужно мокать.
4154.10 4156.74 "Анатолий Кулаков" Только все действие происходит в памяти.
4156.74 4163.06 "Анатолий Кулаков" У вас есть интеграционные тесты, функциональные тесты, end-to-end тесты и прочие типы других тестов.
4163.06 4171.26 "Анатолий Кулаков" Вот там можно длинно, там можно интегрироваться с различными внешними системами, вот там в базе данных и все остальное.
4171.26 4174.50 "Анатолий Кулаков" Вот там они могут быть долгими, тут проблем нет никаких.
4174.50 4181.30 "Анатолий Кулаков" В unit-тестах же нет, они быстрые, самостоятельные, изолированные и в них никаких внешних зависимостей быть не может.
4181.30 4185.34 "Анатолий Кулаков" Поэтому unit-тесты должны быть максимально быстрые, как только это возможно.
4185.34 4190.02 "Анатолий Кулаков" Если это не так, значит вы делаете что-то не так, значит вы пишете unit-тесты неправильно.
4190.02 4195.70 "Анатолий Кулаков" Так, следующий пункт это maintainability, ремонтопригодность в общем.
4195.70 4198.18 "Анатолий Кулаков" Сопровождаемость ваших тестов тоже должна быть на высоте.
4198.18 4205.66 "Анатолий Кулаков" Тут важное правило, что хаос в тестах это прямой путь к тому, что у вас будет хаос в коде.
4205.66 4210.22 "Анатолий Кулаков" В принципе, довольно полезно относиться к тестам как к коду.
4210.22 4218.26 "Анатолий Кулаков" Если вы обычно свой код рефакторите, документируете, следите за ним, обновляете, то те же самые практики нужно использовать и с тестами тоже.
4218.26 4220.74 "Анатолий Кулаков" Потому что тесты это как минимум код.
4220.74 4228.98 "Анатолий Кулаков" Есть у них конечно исключения, вот типа код комплексе равно один, в обычном коде вы себе такого позволять редко сможете, а вот в тестах вы обязаны это делать.
4228.98 4239.70 "Анатолий Кулаков" Такие редкие исключения есть, но в общем случае не забывайте, что тесты это тоже код и за ним нужно точно так же следить, там точно такие же есть best practice и паттерны рефакторинга и прочее.
4239.70 4254.10 "Анатолий Кулаков" Не забывайте о правильных именах, которые мы чуть выше упоминали, о том, что тесты должны быть консистентными, то есть они должны понятно рассказывать, что они тестируют, как они тестируют, покрывать то, что нужно и не покрывать то, что не нужно.
4254.10 4263.18 "Анатолий Кулаков" Если там класс, который они тестируют, например, удалился, упростился, замокался или еще что-то с ним случилось, соответственно нужно поправить тесты, не забывайте об этом.
4263.18 4271.30 "Анатолий Кулаков" И опять же не забывайте рефакторы теста, если они стали вдруг какими-нибудь большими, неудобными, нечитабельными, рефакторы эти.
4271.30 4285.62 "Анатолий Кулаков" Очень часто там вынос метода, вынос фабричного метода, например, для создания какого-нибудь объекта, который принимает себе там тысячу аргументов, чтобы в нескольких местах не менять при добавлении еще одного аргумента к конструктору.
4285.62 4289.42 "Анатолий Кулаков" В общем, тоже очень часто работает, то есть вынесение какого-нибудь фактори метода.
4289.42 4293.02 "Анатолий Кулаков" Те же самые рефакторинги, которые и ко всему коду.
4293.02 4298.42 "Анатолий Кулаков" Следующей хорошей практикой является отслеживанием покрытия.
4298.42 4303.38 "Анатолий Кулаков" Довольно спорная тема, потому что очень многие ее неправильно воспринимают.
4303.38 4306.18 "Анатолий Кулаков" Покрытие тестов.
4306.18 4316.62 "Анатолий Кулаков" На самом деле, если ваш тест, если у вас есть тесты, но эти тесты не покрывают никакого полезного кода, то это полностью бесполезные тесты.
4316.62 4319.46 "Анатолий Кулаков" Такое тоже бывает.
4319.46 4324.70 "Анатолий Кулаков" В принципе, легко написать тест, который на самом деле что-то выполняется, что-то делает, но никакой пользы не приносит.
4324.70 4333.42 "Анатолий Кулаков" То есть он никак не отражает то, что будет происходить в настоящем вашем коде и что вообще будет происходить с этим методом, с этим классом, который он тестирует.
4333.42 4335.62 "Анатолий Кулаков" То есть тесты могут тестировать ничего.
4335.62 4340.22 "Анатолий Кулаков" Особенно такие часто какие-то совстречаются, когда люди злоупотребляют моками.
4340.22 4350.66 "Анатолий Кулаков" Они замокивают просто все подряд и начинают тестировать тот метод, который сами только что замокали, который обещает им тот же результат, который они хотят получить на выходе.
4350.66 4352.78 "Анатолий Кулаков" Ну то есть абсолютно бесполезные вещи делают.
4352.78 4356.26 "Анатолий Кулаков" Они лишь убеждаются в том, что мок-фреймворк работает правильно.
4356.26 4358.66 "Анатолий Кулаков" Поэтому такая штука тоже бывает.
4358.66 4362.82 "Анатолий Кулаков" Что здесь, какие можно дать советы?
4362.82 4368.34 "Анатолий Кулаков" Во-первых, старайтесь все-таки следить за покрытием.
4368.34 4373.54 "Анатолий Кулаков" Покрытие это хорошо, но никогда не гонитесь за 100% покрытием.
4373.54 4387.38 "Анатолий Кулаков" Такие вещи, как автосвойства или какие-нибудь декларативные методы, как я уже упоминал, или какие-нибудь однострочники, в которых нет никаких условий, которых комплексности ноль, то есть один, они не дадут вам никакой пользы.
4387.38 4396.14 "Анатолий Кулаков" То есть их тестировать практически бесполезно, потому что вероятность их слома, она практически нулевая.
4396.14 4398.82 "Анатолий Кулаков" Поэтому просто-напросто потратите время.
4398.82 4405.36 "Анатолий Кулаков" Сфокусироваться нужно именно на каких-нибудь критическом пути выполнения вашей программы и особенно на бизнес-логике.
4405.36 4416.10 "Анатолий Кулаков" Потому что бизнес-логика часто сложная, особенно важная, критичная, и вот ее нужно покрывать тестами просто максимально, как только можно.
4416.10 4426.66 "Анатолий Кулаков" Про код-каверидж еще хочется сказать, что на самом деле код-каверидж может показать, насколько плоха ваша программа, но он никогда не покажет, насколько она хороша.
4426.66 4430.34 "Анатолий Кулаков" То есть даже не программа, а тесты, это характеристика тестов.
4430.34 4431.34 "Анатолий Кулаков" Что это значит?
4431.34 4443.62 "Анатолий Кулаков" Это значит, что если код-каверидж показывает, что у вас каверидж в программе ноль, то вы точно можете гарантировать, что покрытие у вас очень плохое и тесты у вас написаны очень плохо.
4443.62 4444.62 "Анатолий Кулаков" Ну или их вообще нет.
4444.62 4449.06 "Анатолий Кулаков" Если же у вас код-каверидж 100%, это не гарантирует абсолютно ничего.
4449.06 4468.54 "Анатолий Кулаков" У вас тесты могут быть и хорошие, и в это же время могут быть и плохие, потому что можно сделать код-каверидж 100%, но при этом не протестировать важных частей, потому что код-каверидж все-таки смотрит на прохождение логики, но не то, как вы проверяете постусловия, как вы тестируете, как вы проверяете precondition и прочие вещи.
4468.54 4472.78 "Анатолий Кулаков" То есть вполне реально добиться 100% код-кавериджа с очень плохими тестами.
4472.78 4481.26 "Анатолий Кулаков" Поэтому 100% не показывает ничего, но если у вас 0%, это точный признак того, что у вас очень плохо с тестами.
4481.26 4483.46 "Анатолий Кулаков" Нейминг конвеншен.
4483.46 4487.14 "Анатолий Кулаков" Довольно интересный автор придерживается нейминг конвеншена.
4487.14 4493.30 "Анатолий Кулаков" В принципе у каждого, к сожалению, в C# используется практически свой нейминг конвеншен.
4493.30 4510.22 "Анатолий Кулаков" Очень редко можно встретить двух человек, которые используют одинаковый нейминг конвеншен, даже если они изначально отталкивались от одного и того же шаблона, то в конце концов каждый прибавляет какие-то свои специфики и все равно это все врождается в какую-то муть.
4510.22 4517.14 "Анатолий Кулаков" Поэтому мне кажется в нашей индустрии это пока больная тема, потому что все-таки хотелось бы иметь какой-нибудь нейминг конвеншен для тестов.
4517.14 4521.94 "Анатолий Кулаков" Понятный, предсказуемый и очевидный, но, к сожалению, нет.
4521.94 4525.94 "Анатолий Кулаков" Ну и как пример я вам хочу показать нейминг конвеншен автора, которого он придерживается.
4525.94 4538.90 "Анатолий Кулаков" У него есть рекомендация, что необходимо на один тестовый метод выделять отдельный тестовый класс.
4538.90 4550.10 "Анатолий Кулаков" То есть, допустим, если у нас есть калькулятор, и у этого калькулятора есть два метода суммировать и разделить, он предлагает нам сделать два файлика, то есть по сути два класса.
4550.10 4555.38 "Анатолий Кулаков" Один класс будет называться калькулятор add, и там будут все тесты про суммирование.
4555.38 4559.98 "Анатолий Кулаков" И второй класс это калькулятор divide, там будут все методы про разделение.
4559.98 4563.06 "Анатолий Кулаков" Вот, довольно дерзко.
4563.06 4570.62 "Анатолий Кулаков" Также он говорит, что если вам не нравится, можете сделать папочку калькулятор, и в этот папочку калькулятор уже добавить два класса add и divide.
4570.62 4581.38 "Анатолий Кулаков" В общем, да, если у вас, соответственно, классов много, у вас будет много папочек, если методов много, много файликов внутри этих папочек.
4581.38 4600.70 "Анатолий Кулаков" И классы внутри файликов относятся к методу, и в этих классиках есть тестовые методы, которые тестируют один единственный метод у целевого класса, и эти методы он предлагает называть через given.
4600.70 4606.02 "Анатолий Кулаков" Например, return positive sum given to positive numbers.
4606.02 4610.98 "Анатолий Кулаков" Или другой метод, return negative sum given to negative numbers.
4610.98 4614.66 "Анатолий Кулаков" Или return zero given to zeros.
4614.66 4618.06 "Анатолий Кулаков" То есть вот такие через given он предлагает давать названия.
4618.06 4624.38 "Анатолий Кулаков" Опять же, это тоже оригинальный ноу-хау, я еще такого не видел, как качестве примера того, что каждый изобретает все, что только может.
4624.38 4631.22 "Анатолий Кулаков" Более частый вариант – это именование в стиле behavior-driven development.
4631.22 4633.22 "Анатолий Кулаков" Это через given, then, then.
4633.22 4638.02 "Анатолий Кулаков" Например, given precondition, then action, then expected result.
4638.02 4647.14 "Анатолий Кулаков" Это способ именования довольно хорошо мапится на вышеупомянутый шаблон range_act_assert.
4647.14 4651.42 "Анатолий Кулаков" То есть как раз секция сначала что-то подготавливаем, потом что-то делаем, и третье что-то проверяем.
4651.42 4654.22 "Анатолий Кулаков" И вот они там, в принципе, на название тоже хорошо мапятся.
4654.22 4656.62 "Анатолий Кулаков" Вот это, по мнению автора, два самых популярных подхода.
4656.62 4663.50 "Анатолий Кулаков" С ним можно согласиться или не согласиться, но для нас, мне кажется, это более как посмотреть на дичь, другого ты не сделаешь.
4663.50 4673.78 "Анатолий Кулаков" В общем, имена юнитестов оставим в покое, это пока каждый рисует сам для себя, но автор советует сделать следующую вещь.
4673.78 4675.38 "Анатолий Кулаков" Два пункта по именам.
4675.38 4678.02 "Анатолий Кулаков" Это, во-первых, выберите консистентные имена.
4678.02 4680.22 "Анатолий Кулаков" С этим сложно спорить.
4680.22 4687.54 "Анатолий Кулаков" Выдумывайте себе правила какие угодно, но главное, что во всем приложении у вас тесты назывались по одному и тому же правилу.
4687.54 4693.34 "Анатолий Кулаков" Пусть оно какое-то извращенное, как у товарища, который написал эту статью, но зато оно одинаковое везде.
4693.34 4705.54 "Анатолий Кулаков" Здесь как раз-таки работает тот случай, когда единообразие намного важнее, чем какое-то разнообразное уродство.
4705.54 4710.30 "Анатолий Кулаков" Даже если это уродство будет правильным, то единообразие здесь намного выигрывает, намного важнее.
4710.30 4716.82 "Анатолий Кулаков" Поэтому советую собраться с командой и выдумать какой-нибудь один единственный стиль и придерживаться его во всем приложении.
4716.82 4723.78 "Анатолий Кулаков" В качестве имен можно еще сказать, что тестовые фреймворки поддерживают специальные атрибуты.
4723.78 4736.14 "Анатолий Кулаков" Например, в XUnit можно написать атрибут FACT с параметром DISPLAYNAME и указать ему строчкой, как этот тест необходимо показывать в вашем запускальщике тестов.
4736.14 4746.46 "Анатолий Кулаков" У NUnit точно также есть атрибут TEST_CASE с названием TEST_NAME, у которого тоже можно словами написать, как этот тест должен отображаться в запускальщике.
4746.46 4752.46 "Анатолий Кулаков" То есть очень удобная штука, особенно если у вас тесты уже не UNIT, а какие-нибудь более сложные.
4752.46 4763.38 "Анатолий Кулаков" Когда вы покрываете какой-то сценарий, этот сценарий плохо описывается просто названием теста, вы можете прям по-русски написать "Вот этот тест делает то, то, сё, то и это".
4763.38 4771.26 "Анатолий Кулаков" И когда он упадет, уже будет понятно без всяких магических догадок, а что же там случилось.
4771.26 4776.26 "Анатолий Кулаков" Тем более, пока у нас нет нормального именования общепринятого теста, это довольно полезно бывает.
4776.26 4804.38 "Анатолий Кулаков" Вот такие вот практики, довольно очевидные, довольно может быть для кого-то банальные, но в принципе, если вы будете их придерживаться, то этого уже достаточно на 80% для того, чтобы ваши тесты работали и UNIT-тесты работали и были прекрасны, и каждый член команды мог хорошо их поддерживать, и гордиться тем, что ваше приложение хорошо покрыто тестами, быть уверенным в завтрашнем дне.
4804.38 4815.62 "Игорь Лабутин" Ну, как ты правильно сказал, хорошо покрыто тестами это такая слабоизмеримая штука, пусть оно хоть как-нибудь будет покрыто хорошими тестами, основная бизнес-логика.
4815.62 4822.06 "Анатолий Кулаков" Есть же отдельная тема, как тестировать тесты, да, мы по-моему уже пару раз обсуждали, это мутационные тесты как раз.
4822.06 4823.06 "Анатолий Кулаков" Да.
4823.06 4826.94 "Анатолий Кулаков" В общем, но это другой вопрос, не будем его сейчас поднимать.
4826.94 4831.62 "Игорь Лабутин" Да, тем более, не знаю, я их особо никогда не пробовал, не знаю.
4831.62 4843.26 "Игорь Лабутин" Ладно, давай дальше, дальше у нас тоже тема, которую я не, честно говоря, не думал, что когда я буду рассказывать в радио.нете, это JavaScript и .NET Interop.
4843.26 4846.46 "Игорь Лабутин" Ты уверен, что стоит начинать вообще?
4846.46 4847.46 "Игорь Лабутин" Да.
4847.46 4848.46 "Игорь Лабутин" Скользкий путь, смотри.
4848.46 4865.10 "Игорь Лабутин" Да, это, короче, GitHub-репозиторий от команды Microsoft, в смысле он GitHub.com/Microsoft/node-api, и эта штука, она не совсем только про JavaScript, она называется, это Interop между .NET и Node.js.
4865.10 4867.90 "Игорь Лабутин" Значит, что позволяет эта штука делать?
4867.90 4880.10 "Игорь Лабутин" Она позволяет добиться возможности использовать .NET-ные сборки и вызывать .NET-ные API прям из JavaScript-ового аппликейшена в том же процессе.
4880.10 4887.90 "Игорь Лабутин" И наоборот, JavaScript-овые пакетжи дергать их API прямо из .NET на приложение тоже в одном и том же процессе.
4887.90 4890.62 "Анатолий Кулаков" Это никак на Blazor не завязано, да?
4890.62 4897.78 "Игорь Лабутин" Вообще никак, ни одного слова Blazor не было сказано, то есть, это же Node.js, Blazor-то здесь при чем, это же сервер-сайт.
4897.78 4907.74 "Анатолий Кулаков" Ну как сервер-сайт, ты же можешь вполне запускать Blazor-овский ILL, ну по сути, ASM, он может вполне интерпретироваться JavaScript-ом.
4907.74 4908.74 "Игорь Лабутин" В ноду, ну да.
4908.74 4910.82 "Игорь Лабутин" В ноду подгрузить, да.
4910.82 4915.50 "Игорь Лабутин" Но ты уже подгружаешь Blazor, ты уже подгружаешь Wasm, по сути, а не .NET все-таки.
4915.50 4916.50 "Игорь Лабутин" Да, да, конечно.
4916.50 4921.66 "Анатолий Кулаков" Но так как там .NET-машина вертится, может, ей легче
4921.66 4931.58 "Игорь Лабутин" дергать .NET-ные процессы. Ну да, я понимаю, что здесь уже очень много всего, с чем можно совместить, но короче, нет, слово Blazor и слово Wasm тут вообще ни разу не употребляется, по-моему, в описании этого репозитория.
4931.58 4934.14 "Игорь Лабутин" То есть, это реально нативные вызовы, да?
4934.14 4938.14 "Игорь Лабутин" Это, ну да, но хитрее, не совсем нативные, но короче, давай смотреть.
4938.14 4942.42 "Игорь Лабутин" Во-первых, что оно поддерживает?
4942.42 4945.26 "Игорь Лабутин" Оно поддерживает, на самом деле, это фиг еще всего.
4945.26 4956.62 "Игорь Лабутин" Для того, чтобы вызвать .NET из JS, вы используете пакетч специальный в npm, который называется node-api.net.
4956.62 4968.70 "Игорь Лабутин" Он хостит внутри себя рантайм, если надо, и, соответственно, в JavaScript-овом приложении будет предоставлять доступ ко всему, что вы в этот рантайм загрузите.
4968.70 4978.14 "Игорь Лабутин" Почему говорю, если надо, потому что вся эта штука нормально поддерживает AOT, то есть вы можете из JavaScript одерживать AOT-шные сборки, тогда никакой .NET Runtime не нужен.
4978.14 4999.26 "Игорь Лабутин" При этом все базовые типы, то есть из стандартной библиотеки, грубо говоря, доступны просто так, то есть никакие дополнительные сборки грузить не надо, но если вам нужны какие-то кастомные дополнительные сборки, вы можете загружать их просто с диска по полному пути внутрь Node.js процесса и через этот node-api.net пакетч их использовать.
4999.26 5003.14 "Анатолий Кулаков" То есть это, по сути, хостинг .NET внутри ноды.
5003.14 5019.70 "Игорь Лабутин" Да, хостинг .NET внутри ноды плюс прозрачная прослойка, потому что для JavaScript-ового кода у вас будет топ-левелный объект под названием .NET, и все namespaces, и дальше, ну понятно, классы и все остальное мапятся как, ну под объекты, то есть вы пишете .NET.system.console.writeline.
5019.70 5024.46 "Игорь Лабутин" Ну как бы вы вызовете райтлайн.
5024.46 5037.34 "Анатолий Кулаков" То есть я правильно понимаю, что раньше мы JavaScript использовали как скриптовый язык в наших приложениях для того, чтобы ну заскриптовать какую-то автоматизацию, а теперь, наоборот, JavaScript-овщики могут .NET использовать как скриптовый язык в их приложениях?
5037.34 5042.54 "Игорь Лабутин" Типа того, у тебя, ты можешь на JavaScript-е делать то же самое, что ты делаешь в PowerShell.
5042.54 5044.58 "Анатолий Кулаков" Интересный дискейс, зачем им это надо?
5044.58 5048.90 "Игорь Лабутин" Не знаю, вот никакой мотивации нафига этот пакет появился, я не нашел.
5048.90 5049.90 "Игорь Лабутин" Интересно.
5049.90 5050.90 "Игорь Лабутин" Ну он есть.
5050.90 5051.90 "Игорь Лабутин" Ладно, давай дальше.
5051.90 5055.54 "Игорь Лабутин" Можно обратно сделать, позвать JavaScript из .NET.
5055.54 5062.02 "Игорь Лабутин" Вот, там соответственно нужно хостить уже JavaScript-овый runtime, например, ноду в .NET.
5062.02 5083.62 "Игорь Лабутин" Соответственно, дальше эти самые, для этого вам нужен соответственно NuGet пакет, который из этого репозитория собирается, который вы затаскиваете к себе в .NET-приложение, говорите ему вот, значит, создать объект, и единственное, что здесь уже не получится прям так централизованно легко вызывать, там есть тонкости с тем, с каких потоков, нода же, она ж там, что, однопоточная или что-то в таком духе.
5083.62 5102.10 "Игорь Лабутин" Я не знаток ноды, но были там какие-то темы с потоком, поэтому здесь вы делаете на вот этом объекте вызов либо run, либо runAsync, либо post, здравствуй, синхронизейшн контексты, для того, чтобы вызвать любой JavaScript-овый код на загруженном Node.js-энвайрменте.
5102.10 5107.58 "Игорь Лабутин" Синхронизейшн контексты упомянул не зря, они там активно используются для того, чтобы правильно возвращать вызовы в нужные места.
5107.58 5138.66 "Игорь Лабутин" Для того, чтобы из JavaScript-а, точнее из TypeScript-а было проще вызывать .NET-ные API, вы в принципе можете сгенерить по .NET-ному API, по DLL-ке, описание в виде .d.ts файлика, как это принято в TypeScript-е, и у вас будут прям TypeScript-овые definition для типов, которые загружены из .NET-ной сборки, точнее, которые описаны в .NET-ной сборке, и вы сможете их вызывать с учетом типизации.
5138.66 5149.98 "Игорь Лабутин" И более того, этот тул генерит маленький JavaScript-овый файлик, вы импортите только его, а он автоматически загрузит все, что нужно, и TypeDefinition, и сборку, и .NET, и все остальное.
5149.98 5156.06 "Игорь Лабутин" Ну, то есть вот в тот самый .NET TopLevelObject все это будет загружено и можно будет использовать.
5156.06 5167.86 "Игорь Лабутин" При этом, как я сказал, что это прослойка некая, то вы вызываете код плюс-минус явно, с небольшой прозрачной прослойкой, но прослойка довольно мощная.
5167.86 5178.78 "Игорь Лабутин" Во-первых, полностью поддерживается синк, то есть если у вас есть .NET-ный метод, который возвращает task, вы можете эвейтить его в JavaScript-овом коде, как будто это JavaScript-овый промис.
5178.78 5193.34 "Игорь Лабутин" И наоборот, JavaScript-овый промис, если вы вызовете метод JavaScript-а, который возвращает промис, то он становится объектом JSPromise в .NET, на который можно сказать evade, и он будет эвейтить его так же, как и task.
5193.34 5195.78 "Игорь Лабутин" Короче, async работает в обе стороны.
5195.78 5206.22 "Игорь Лабутин" Причем он работает корректно, с точки зрения вот тех самых особенностей работы с потоками в ноде, он правильно за счет синхронизации контекстов будет возвращать в нужное место ноды, в нужный поток после эвейтов.
5206.22 5224.42 "Игорь Лабутин" Если у вас случится exception в JavaScript-е, либо в .NET, ну или в JavaScript-е exception, там же, по-моему, скорее, так скажем, ошибки, ну, в статье это все называется exceptions, то у вас будет stack trace, который замиксован из JavaScript-а и .NET-а.
5224.42 5232.26 "Игорь Лабутин" То есть они прямо в stack trace, вот это вот выполняется в JavaScript-е, вот такие функции вызывались в таких-то строчках, а вот тут начался .NET, и тут такие-то классы в таких-то строчках.
5232.26 5237.38 "Анатолий Кулаков" Интересно, так stack trace из двух языков, то даже не то, что языково, а прямо runtime.
5237.38 5239.38 "Игорь Лабутин" Runtime в разных принципиально, да.
5239.38 5243.14 "Игорь Лабутин" Он пропагетится через кассеты на границу, все как надо.
5243.14 5244.74 "Игорь Лабутин" Ну и с маршаллингом.
5244.74 5256.86 "Игорь Лабутин" Значит, с маршаллингом вот эта прословочка сделана следующим образом, значит, ну для value типов, примитивов, там, весь структур, понятно, что они передаются просто как по значению, как положено.
5256.86 5270.62 "Игорь Лабутин" Для reference типов генерится проксия на другой стороне прозрачно, так что вызовы методов, по сути, внутри проксируются в объект на другой стороне, причем garbage collector в курсе и правильно все это.
5270.62 5278.86 "Игорь Лабутин" То есть можно создать объект .NET, отдать ссылку в JavaScript и объект будет жить, несмотря на то, что ссылки в .NET вроде как закончились.
5278.86 5284.46 "Игорь Лабутин" Ну видимо они где-то сохраняют там замаршалленный объект в какой-нибудь статический массивчик, чтобы они не собрали.
5284.46 5295.90 "Игорь Лабутин" И более того, я так понимаю, я вот не знаком с нодой, в ноде есть типы, немного похожие на стримы, ну .NET на и да, то есть это поток байт.
5295.90 5308.70 "Игорь Лабутин" Так вот, они маршалятся друг в друга, в смысле в стриме .NET, то есть если вы можете открыть файлик в .NET, получить стрим, отдать стрим в JavaScript, JavaScript это будет воспринимать как свой нативный, что у них там вместо стрима байтов.
5308.70 5313.82 "Анатолий Кулаков" Довольно такой мощный engine получается, интересно для чего они его делают.
5313.82 5316.02 "Игорь Лабутин" Да, они явно его делают для чего-то полезного.
5316.02 5317.02 "Игорь Лабутин" Да-да-да.
5317.02 5326.14 "Игорь Лабутин" То есть потому что реально усилий вложено видимо дофигище и как-то ну прям, ну очень прям все бесшовно и прекрасно.
5326.14 5355.54 "Игорь Лабутин" Понятно, что если посмотреть выше, там много всяких разных пока проблем еще есть, ну потому что сложная эта вся штука, особенно .NET много чего можно делать и там не все еще маршалится корректно иногда и так далее, то есть это все на очень ранней стадии, это все пока early preview, там пока все работает, как бы основные сценарии работают как написано, но ожидайте еще большого количества доработок, но тем не менее, Майкрософт как-то хочет дружить ноду и .NET, посмотрим за чем будем следить.
5355.54 5375.62 "Анатолий Кулаков" Смотри, может они поняли, что с UI у них ничего не получается, поэтому они сейчас UI сделают с помощью Blazer, Blazer скомбинирует WASM, WASM будет запускаться на GS, на ноде и по сути они ноду встроят в .NET приложение и таким образом сделают в .NET приложение хороший UI.
5375.62 5378.70 "Игорь Лабутин" Утка в зайце или наоборот зайца в утке.
5378.70 5386.34 "Анатолий Кулаков" Ну не важно, у тебя короче кроссплатформенный красивый UI будет через Blazer, ноду и через пин колоду, но зато UI.
5386.34 5392.98 "Игорь Лабутин" Ну это неожиданный ход, да, вообще такая мысль мне в голову не приходило засушить, давай последим, посмотрим.
5392.98 5394.98 "Анатолий Кулаков" Ну а зачем нода еще может быть нужна?
5394.98 5395.98 "Игорь Лабутин" Не знаю.
5395.98 5396.98 "Анатолий Кулаков" Не понятно вообще.
5396.98 5397.98 "Анатолий Кулаков" Не знаю.
5397.98 5401.66 "Анатолий Кулаков" Или может продукт там какой-то у них новый пилится, ну зачем бы они тогда открывали этот движок.
5401.66 5406.02 "Игорь Лабутин" Ну блин, ну нода-то опять же, зачем, нода же это сервер сайт, ну а SP.NET у тебя есть.
5406.02 5412.74 "Анатолий Кулаков" Для того, чтобы, нет, что-то полезное они хотят из GS достать, ну разумеется, естественно, у тебя есть SP.NET.
5412.74 5413.74 "Анатолий Кулаков" А, ну типа.
5413.74 5416.78 "Анатолий Кулаков" Ну и там есть будущие библиотеки, которые есть только на GS.
5416.78 5418.98 "Анатолий Кулаков" Ну грубо говоря, чтобы не переписывать их.
5418.98 5425.58 "Игорь Лабутин" И чтобы не тащить какой-нибудь условный, не, но все равно для UI тебе все равно нужен какой-то браузерный движок, как ни крути.
5425.58 5426.58 "Игорь Лабутин" В ноде его нет.
5426.58 5427.58 "Анатолий Кулаков" Нужен, нужен, да.
5427.58 5436.10 "Анатолий Кулаков" Нет, там, наверное, ну может какой-нибудь библиотеку по визуализации, там может быть какой-нибудь D3 или еще что-то.
5436.10 5448.94 "Анатолий Кулаков" Они же, смотри, они кстати, знаешь, что недавно сделали, они же в студию встащили очень мощную поддержку JavaScript, то есть они хотят всех в студию перетащить всех JavaScript-овщиков, чтобы те писали свои проекты внутри студии.
5448.94 5453.82 "Анатолий Кулаков" И вот кажется, что это хороший движок для того, чтобы строить его в студию.
5453.82 5460.98 "Анатолий Кулаков" Там запустить ноду, нода умеет там пакеты собирать, IntelliSense предоставлять, раскраски раскрашивать и прочие вот эти вещи делать.
5460.98 5461.98 "Анатолий Кулаков" Как тебе вариант?
5461.98 5462.98 "Игорь Лабутин" Ну да, интересно, может быть.
5462.98 5468.46 "Анатолий Кулаков" То есть как и Provement для Visual Studio, для того, чтобы она стала полноценным JavaScript-редактором.
5468.46 5475.82 "Анатолий Кулаков" Естественно, без ноды сейчас JavaScript-редактора невозможно представить, потому что там уже написано куча библиотек, которые надо просто интегрировать.
5475.82 5476.90 "Анатолий Кулаков" Переписывать их никакого смысла нет.
5476.90 5479.14 "Игорь Лабутин" Интересно, может быть, да.
5479.14 5487.90 "Игорь Лабутин" Может быть, действительно отказавшись от VS4Mac, они теперь будут еще больше вкладывать в Visual Studio, в том числе, да, JavaScript и все остальное.
5487.90 5489.42 "Игорь Лабутин" Ну посмотрим, ладно.
5489.42 5490.42 "Игорь Лабутин" Давай будем следить.
5490.42 5491.42 "Игорь Лабутин" Глянем.
5491.42 5501.18 "Игорь Лабутин" И есть еще одна тоже из примерно, ну не такого же рода статей, ну в смысле новостей, но тоже близкая к JavaScript-овому миру.
5501.18 5503.18 "Игорь Лабутин" Мы уже много раз говорили про Blazor.
5503.18 5507.58 "Игорь Лабутин" Ну ладно, далеко от JavaScript-ового мира, но близко к Blazor.
5507.58 5517.74 "Игорь Лабутин" Telerik, как мы знаем, компания, которая выпускает огромное количество разных контролов подо все, WinForm, WPF и, короче, любой, возьми, UI-фреймворк, Telerik под него наверняка что-нибудь выпускает.
5517.74 5520.10 "Игорь Лабутин" Также они это делают под Blazor.
5520.10 5523.98 "Игорь Лабутин" И вот они недавно запустили штуку, которая называется Blazor REPL.
5523.98 5529.38 "Игорь Лабутин" То есть это некоторая интерактивная штука, которая позволяет экспериментировать с Blazor-контролами.
5529.38 5540.42 "Игорь Лабутин" И это полностью браузерное приложение, в котором вы получаете условно говоря три области, ну не вкладки, короче, три области.
5540.42 5554.98 "Игорь Лабутин" В левой у вас сниппеты, в серединке код на Razer, Razer шаблончики, а справа готовый Blazor, так сказать, срендеренный вот это вот Blazor WASM, то, что вы написали в Razer.
5554.98 5561.02 "Игорь Лабутин" Поскольку это все JavaScript и WASM, то это все можно сделать исключительно в браузере, вам ничего не надо кроме браузера.
5561.02 5564.06 "Игорь Лабутин" WASM умеет работать в браузере, он умеет компилироваться в браузере.
5564.06 5568.14 "Игорь Лабутин" В общем, все прямо в браузере.
5568.14 5583.22 "Игорь Лабутин" Но он настолько, уж не знаю, настолько ли он крут или настолько хорошо работает Telerik, линк на этот REPL редактор есть аж в официальной документации Microsoft по Blazor, типа, хотите попробовать все то, что мы вам описываем, вот вам туда, в Telerik.
5583.22 5596.66 "Игорь Лабутин" Ну партнеры, может они какие, я уже не знаю, как они там правильно называются, Telerik'овские контролы обычно платные, но эта штука абсолютно бесплатная, в том числе внутри вы можете пользоваться любыми Telerik'овскими контролами тоже бесплатно.
5596.66 5608.06 "Игорь Лабутин" Понятно, что если вы дальше этот сниппет утащите к себе в код, то уже нужно покупать лицензию, но и посмотреть, что там за контролы, прям можно теперь в интерактивные штуки, у них там есть сразу сниппеты с готовыми контролами, можно все это запихать.
5608.06 5630.50 "Игорь Лабутин" Можно сохранять, понятно, свою галерею у них на сайте, можно шарить через урлы, есть экстенджер для Visual Studio, который позволяет быстренько, например, если вы пишете какую-нибудь там Blazor вьюшку в Visual Studio, одной кнопкой закинуть ее на сайт, там покрутить различными в репли и пошарить с кем-нибудь, что-нибудь в таком духе.
5630.50 5638.90 "Игорь Лабутин" Можно инсталлировать NuGet пакеты, вот тут я не очень понял, как, что прям любые, любые, и как они это все обрабатывают.
5638.90 5640.86 "Анатолий Кулаков" Ну, наверное, только Blazor'ные NuGet пакеты.
5640.86 5643.86 "Игорь Лабутин" Ну, там сказано, типа, install arbitrary NuGet packages.
5643.86 5646.78 "Игорь Лабутин" Как они определяют, что в этом NuGet пакете есть.
5646.78 5649.26 "Анатолий Кулаков" Ну, попробуют загрузить, если там в ASM, то загрузят,
5649.26 5652.94 "Игорь Лабутин" если нет, то дадут ошибку. Ну, может быть, да, наверное, наверное, может быть так, не знаю.
5652.94 5669.94 "Игорь Лабутин" Вот, стать статику можно, соответственно, использовать, и даже немножко на C# писать, то есть там какой-нибудь startup.cs, который требует, если вам требуется для ваших контролов и кода какие-нибудь странные там регистрации в DIY-контейнере, ну, вперед, startup.cs у вас есть, можно туда все это написать.
5669.94 5680.94 "Игорь Лабутин" Ну, и базовая диагностика с точки зрения компиляции, то есть там понятно, что нет отладчика, но есть там всякие ошибки, понятно, warning'и, сборки, минимально все показывает.
5680.94 5691.18 "Игорь Лабутин" В общем, если вы вдруг занимаетесь Blazor'ом, кажется, что это репл полезная штука будет для того, чтобы покрутить и посмотреть, что за UI в браузере у вас получается.
5691.18 5698.94 "Анатолий Кулаков" Да, весьма полезный этот лазейн, кажется, очень в быту, как инструмент, будет удобно.
5698.94 5719.58 "Игорь Лабутин" Ну я ее так покрутил чуть-чуть, я не специалист в Blazor'е, в программировании, ну, какой-то простейший разерфайлик написал с какими-то этими переливчалками, ну, как с этим, знаешь, типа on/off, а-ля, современные чекбоксы, вот это все, ну да, работает прекрасно, там какое-то значение меняется, все нормально, байдинги работают, все хорошо.
5719.58 5728.82 "Анатолий Кулаков" Ну классно, да, если там еще прикрутить интерактивность с JavaScript'ом, там же у Blazor она как-то грамотно есть, можно там какие-нибудь плагины уже бомбить или что-то в этом духе.
5728.82 5730.74 "Игорь Лабутин" Ну да, да, да.
5730.74 5739.54 "Игорь Лабутин" Ну вот на этом у нас наш, так сказать, набор стандартных статей, которые мы отобрали в этот выпуск, завершился.
5739.54 5746.66 "Игорь Лабутин" Давай пробежимся по кратким темам, которые не требуют большого количества времени.
5746.66 5749.22 "Анатолий Кулаков" Не заслужили большого слота, но упоминать их стоит.
5749.22 5753.50 "Игорь Лабутин" Да-да-да, потому что долго про них рассказывать смысла нет, но тема полезная и интересная.
5753.50 5765.94 "Игорь Лабутин" Так, JetBrains организует очередной .NET Online Day, будет это 26 сентября, это абсолютно халявное мероприятие онлайн, там на YouTube, на Twitch, наверное, ну где, короче, они стримят.
5765.94 5776.18 "Игорь Лабутин" Десять спикеров, 11 часов видеоматериала, видимо, как обычно будет из разных таймзон, поэтому когда бы вы не подключились, скорее всего, вы попадете посмотреть хоть что-нибудь, либо потом смотреть в записи.
5776.18 5792.66 "Игорь Лабутин" Темы, как обычно, будут довольно технические, как мне кажется, ну и в тренде текущих популярных тем вокруг восьмого .NET.
5792.66 5804.30 "Игорь Лабутин" Дальше, как мы уже много раз говорили, Visual Studio сильно развивается, но прежде чем заносить какие-то фичи в основной Visual Studio, они теперь всегда выходят в виде экстенджеров.
5804.30 5806.94 "Игорь Лабутин" Кажется, всегда, наверное, неправильное слово, но довольно часто.
5806.94 5817.62 "Игорь Лабутин" И вот у нас есть теперь очередной экстенджер для Visual Studio, от Мэтца Кристонса, автора, не знаю, мне кажется, такими темпами он вообще там будет, первым с большим отрывом по количеству экстенджеров написанных.
5817.62 5820.78 "Игорь Лабутин" И эта штука позволяет теперь смотреть картинки в студии.
5820.78 5838.34 "Игорь Лабутин" Но не просто картинки, а если у вас есть ссылка на картинку из любого практически места в вашем коде, будь то CSS, HTML, XAML, там, комментарии даже в коде, то теперь наведя на такую ссылку мышку, вы в Tooltip просто увидите превьюшку этой картинки.
5838.34 5854.50 "Игорь Лабутин" Он, соответственно, этот экстенджер, он может понимать просто какие-то ссылки, прямые ссылки, типа в Http, что-нибудь в комментах, просто в любых строчках на самом деле, даже в литералах C#, где угодно.
5854.50 5870.42 "Игорь Лабутин" Можно использовать абсолютные URL, можно использовать абсолютные пути на диске, можно использовать сабфолдеры, можно использовать то, что называется pack_uri_format, когда он из ресурсов достает, можно использовать data_uri, когда он там в Base64 кодирует в ресурс-файлах, такое иногда встречается.
5870.42 5875.74 "Игорь Лабутин" Всё это экстенджер понимает и будет показывать.
5875.74 5880.02 "Игорь Лабутин" Поддерживает GIFы, PNG, JPG, иконки, SVG.
5880.02 5891.86 "Игорь Лабутин" И более того, достаточно умный, что если у вас есть относительный путь, он его, во-первых, попробует применить относительно корня проекта, если не получится, то ещё и относительно папочки www.root, куда вы, в принципе, всю его статику сложили.
5891.86 5896.26 "Анатолий Кулаков" Полезная штучка, в принципе, если она попадёт в официальную Visual Studio, будет неплохо.
5896.26 5898.94 "Игорь Лабутин" Да, просто будет удобно.
5898.94 5926.02 "Игорь Лабутин" Дальше из твитов Дэвида Фаулера мы продолжаем узнавать, что появляются какие-то новые методы, может быть, мы в следующем анонсе про него узнаем что-то больше интересного, но пока это чисто в твите Дэвида Фаулера, то если вы используете HTTP Client, который вам создаётся через HTTP Client Factory, то теперь есть новый метод, называется Configure HTTP Client Defaults, который как раз позволяет настроить этот самый HTTP Client, который создаётся из Factory.
5926.02 5931.42 "Игорь Лабутин" Ждём следующего анонса S/P/Net, а скорее всего там будет написано, хотя фиг знает, может и не будет.
5931.42 5937.18 "Анатолий Кулаков" Да-да, тот самый момент, когда из твиттера разработчика узнаешь больше полезной информации, чем из анонсов.
5937.18 5940.34 "Игорь Лабутин" Не, ну погоди, анонс ещё не пришёл, может быть, когда придёт, мы всё это увидим.
5940.34 5944.34 "Анатолий Кулаков" Ну я имею в виду, хотя бы из тех анонсов, которые мы уже прочитали, которые уже были.
5944.34 5945.34 "Игорь Лабутин" Ну это да.
5945.34 5955.94 "Игорь Лабутин" Ну и последняя статья, которую мы хотели бы сегодня осветить, это прибавление всемейства языков для платформы .NET.
5955.94 5956.94 "Игорь Лабутин" Да, не поверишь.
5956.94 5960.34 "Игорь Лабутин" Теперь для .NET можно писать на Rust.
5960.34 5971.98 "Игорь Лабутин" Ну пока только в очень зачаточном состоянии, то есть это версия 0.0.1 компилятора из Rust в CLR.
5971.98 5981.62 "Игорь Лабутин" То есть, причём это эксперимент, там довольно интересная статья на предмет того, с какими трудностями столкнулся автор при попытке генерить Илькод.
5981.62 5992.26 "Игорь Лабутин" Да, надо сказать, что он выбрал такой простой способ, он генерит Илькод в буквальном смысле файликами, а потом на нём вызывает Илясом, чтобы из этого сделать уже собственно сборку.
5992.26 6002.70 "Игорь Лабутин" Вот, и там возникло некоторое количество трудностей и интересностей того, как это всё работает, как раз внутри себя воспринимают код, как из этого генериться.
6002.70 6010.66 "Игорь Лабутин" То есть там появлялись всякие штуки типа локальные переменные типа void, прости, это нормально, вот, ну и так далее.
6010.66 6020.50 "Игорь Лабутин" Из-за этого Ильк получался местами совсем неверный, и ни Илясом, ни кто-либо ещё про это ничего не ругался, только в рантайме всё разваливалось с непонятными ошибками.
6020.50 6028.94 "Игорь Лабутин" В общем, путь там только начат, путь видимо будет тернистый, до полной поддержки Rust в .NET ещё далеко, но начинание интересное.
6028.94 6037.82 "Анатолий Кулаков" Ну да, и нужно упомянуть, что это как бы независимый автор, никакого отношения к Микрософту он не имеет, и не факт, что этот путь будет пройден до конца.
6037.82 6041.42 "Анатолий Кулаков" Это вполне может быть какой-нибудь так пэт-проект на то, чтобы попробовать и забыть.
6041.42 6050.02 "Анатолий Кулаков" Но если у вас есть поклонники Rust рядом, или вы сами являетесь таковым, то в принципе почему бы и нет, очень удобная штука.
6050.02 6051.98 "Анатолий Кулаков" И новый язык выучил, и в старой экосистеме остался.
6051.98 6058.22 "Анатолий Кулаков" Так, а я хочу ещё про одну даже не статейщику, ссылочку упомянуть.
6058.22 6062.62 "Анатолий Кулаков" Недавно команда .NEXT выложила видео с прошлой конференции.
6062.62 6068.22 "Анатолий Кулаков" Это видео с конференции .NEXT 2022 Autumn.
6068.22 6075.38 "Анатолий Кулаков" Там больше 30 видосиков, то есть опять же больше 30 часов хорошего, качественного, отрепетированного, отличного контента.
6075.38 6078.22 "Анатолий Кулаков" Всё это бесплатно на YouTube-канале .NEXT.
6078.22 6098.34 "Анатолий Кулаков" И вообще, если вы думаете, что билеты на .NEXT безумно дорогие, и сейчас вы не можете себе их позволить, или ехать не хочется, ну или по каким-то другим причинам не хотите посещать основную конференцию, то опять же, пожалуйста, зайдите на канал .NEXT в YouTube, и там вы найдёте все записи за все .NEXT, которые были за эти годы.
6098.34 6104.38 "Анатолий Кулаков" Команда не скупится, она всегда выкладывает через полгодика обычно те записи, которые случились.
6104.38 6112.66 "Анатолий Кулаков" И там весь тот качественный, хороший контент, который есть на конференциях, выкладывается в открытый доступ.
6112.66 6114.10 "Анатолий Кулаков" Всегда найдёте, что посмотреть.
6114.10 6116.06 "Анатолий Кулаков" Всегда там хорошие качественные доклады.
6116.06 6129.82 "Анатолий Кулаков" Я в принципе по ним изначально и собирал весь свой багаж, весь свой опыт по .NET вот в таких канальчиках, в таких докладах, которые выкладывают добрые конференции.
6129.82 6130.82 "Анатолий Кулаков" Прекрасно.
6130.82 6134.50 "Игорь Лабутин" На этом будем на сегодня заканчивать.
6134.50 6153.70 "Игорь Лабутин" Поговорили мы сегодня про то, что нет у нас больше Visual Studio for Mac, ну она есть, но скоро закончится, что у нас появился новый альтернативный HTTP сервер, и не только HTTP сервер, но вообще штука для работы с реквестами в .NET, называется Sysq.
6153.70 6159.74 "Игорь Лабутин" Поговорили про то, как правильно валидировать и верифицировать e-mail и чем это всё отличается.
6159.74 6170.38 "Игорь Лабутин" Узнали про новую экспериментальную фичу для garbage-коллектора в .NET, про динамическую адаптацию к размерам приложений.
6170.38 6178.14 "Игорь Лабутин" Поговорили о том, как правильно писать юнит-тесты, как их называть, как их структурировать и вообще как подходить к тому, что они были у вас хорошие.
6178.14 6183.94 "Игорь Лабутин" Узнали, что Microsoft зачем-то пилит интеграцию ноды и .NET, посмотрим, что из этого получится.
6183.94 6190.78 "Игорь Лабутин" Ну а телелик выпустил хороший Blazor REPL, если вы занимаетесь Blazor, я думаю, что вам пригодится.
6190.78 6192.82 "Анатолий Кулаков" На этом всё, давайте завершаться.
6192.82 6202.06 "Анатолий Кулаков" Всем спасибо, кто слушал, репостает, шарит нас, любит, комментирует, лайкает, ставьте звёзды, пальчики, что там у вас есть, сердечки.
6202.06 6206.86 "Анатолий Кулаков" В вашем любимом подкосплеере тоже не забудьте нам написать какую-нибудь хорошую оценку.
6206.86 6218.34 "Анатолий Кулаков" Заходите на Boosty, присоединяйтесь к нашему приватному чатику, всех ждём, всех любим, всем хорошего, хорошего начала осени и до встречи в будущих выпусках.
6218.34 6220.18 "Игорь Лабутин" Да, всем пока.
6220.18 6220.66 "Анатолий Кулаков" Счастливо.
