0.00 32.72 "Анатолий Кулаков" Здравствуйте, дорогие друзья! В эфире Radio.net выпуск номер 44. И всем привет в новом году! Прежде всего, хотелось бы поблагодарить наших больших и хороших спонсоров. Это Александр, Сергей, Владислав, Алексей и Шевченко Антон. Спасибо, друзья, что к нам прибавились. У нас после новогоднего выпуска очень много новых лиц, за что вам отдельный респект. Что у нас еще есть интересного?
32.72 38.00 "Анатолий Кулаков" Микрософт, по-моему, спит. В январе она решила отоспаться и никаких практически новостей от
38.00 47.36 "Игорь Лабутин" нее не было. Или что-то они выпускали? Они, конечно, что-то выпускали, но давай сначала для тех, кто, может быть, присоединился к нам, напомним, кто мы такие. Думаешь? Действительно, друзья,
47.36 59.32 "Анатолий Кулаков" если вдруг вы только что к нам присоединились, я уже думал, что нас все знают. Ну, допустим, сегодня в студии с вами будут Анатолий Кулаков и, как обычно, Игорь Лабутин. Всем привет. Ну что,
59.32 116.76 "Игорь Лабутин" теперь к Микрософту, наконец. Да, давай к Микрософту. Микрософт выпустил Visual Studio 17.1 Preview 2, ну, то есть это Visual Studio 2022, она же 17.1 Preview версии 2. И там некоторое количество улучшений, изменений. Я, в принципе, сижу на 22 студии, но не превьюшной версии, и меня более-менее все устраивает. Я подумал, на самом деле, перейти на превьюшную, чтобы всякие такие клевые штучки иногда пробовать. И среди этих клевых штук, во-первых, они в очередной раз улучшили работу с гидом, то есть в гид-клиент внутри студии Микрософт как-то довольно сильно вкладывается. И здесь они завезли некоторое количество, ну, с моей точки зрения, достаточно интересных изменений. Возможно, они будут вам полезны. Во-первых, вы можете теперь просто посравнивать два бронча, то есть вы можете взять два произвольных бронча и сказать, сравни, что между ними получится. Без создания там pull-request, без всего. То есть что будет, если вы создадите pull-request между ними. Да, это
116.76 126.56 "Анатолий Кулаков" очень неудобная штука. Я часто даже фиктивные pull-request создаю, чтобы такое проделать и в удобном интерфейсе посмотреть, а чем же все-таки брончи отличаются. Да, мне такое помогает иногда,
126.56 168.96 "Игорь Лабутин" например, когда находишь какой-нибудь очень старый бронч в каком-нибудь проекте, где ты там давно не был, и пытаешься понять, это просто забыл удалить или это какая-то работа, которую нужно куда-то не забыть мержить. И вот тут сравнение брончей с текущим мастером довольно полезно, чтобы понять вообще, а что отличается. Вторая штука, она есть, по-моему, практически во всех нормальных гид-клиентах, это возможность зачекаутить в ее произвольный commit, либо, соответственно, голову любого ремоутного бронча. Так что у вас получается то, что называется detached head, вариант, когда вы не чекаутите конкретный бронч, а просто вот произвольный commit, чтобы посмотреть, например, что там было, или с этого места начать новый бронч. Так теперь можно.
168.96 207.20 "Игорь Лабутин" Дальше загадочная фраза про продолжающиеся улучшение поддержки много... многорепозиторенности, назовем это так. Я так понимаю, что если у вас есть большой solution, который раскидан по нескольким репозиториям, видимо, и в Майкрософтах такое бывает, в моей практике такого не было, то студия на самом деле очень хорошо теперь это помогает делать, и в том числе она позволяет создавать один бронч, ну, в смысле, не один бронч, а бронч, называемый одинаково, сразу в нескольких репозиториях. Это актуально, если у вас solution действительно раскидан на несколько репозиториев, но я, признаться, не знаю, какой должен быть solution размера, чтобы это было необходимым.
207.20 219.76 "Анатолий Кулаков" Действительно, я слышал про монорепозитории, которые как бы наоборот поступают, у них все solutions в одном репозитории, но чтобы раскидывать по нескольким репозиториям solution, может, это сабмодули имеются в виду, когда у тебя какая-то библиотечка выносится в сабмодули,
219.76 235.68 "Игорь Лабутин" ее референсит через вложенную директорию. Ну, можно так, возможно, опять же, в Майкрософте специфика там больших именно проектов типа полная SDK, знаешь, запихни в один solution, наверняка его нужно подтащить из многих разных репозиториев. Ну, ты solution-ову можешь сделать несколько,
235.68 238.84 "Анатолий Кулаков" для этого же не обязательно много репозиторий делать, сделай в одном репозитории много
238.84 265.84 "Игорь Лабутин" solution-ов. Это если у тебя не части проекта как-то не разложены по разным репозиториям, потому что они там, не знаю, в отдельные нугеты выходят. Ну, сложно сказать, мне действительно сложно представить сценарий, зачем такое может быть надо, но идея создания бранча одновременно в нескольких репозиториях, она на самом деле интересная. У нас бывает что-то такое необходимое, когда в разных репозиториях там в паре нугетов плюс допустим в API, которые ими пользуются,
265.84 273.88 "Анатолий Кулаков" нужно пофиксить общую багу, например. Я думаю, подождем релиз ноутсов, там нам опишут какие-нибудь практические сценарии для такого прекрасного кейса, может, действительно
273.88 295.36 "Игорь Лабутин" нам тоже это нужно, а мы не осознаем. Это да, кажется, что так. И они завезли еще ту же штуку, которую есть, ну, довольно в большом количестве клиентов, если не во всех, это возможность staging change-a по строчным, ну или по плокам. То есть вы можете, допустим, половину файлов застейджить, а половину оставить в, так сказать, в орг-директоре и не комитить. Ну, я, кстати, пользуюсь такой
295.36 321.20 "Анатолий Кулаков" штукой даже не построчно, иногда даже по полстрочно, то есть в зависимости от того, насколько я был ленивый и до этого не комитил, у меня в моих рабочих файликах вполне могло слиться несколько раздельных issues, которые хочется как бы разделить во время комита, то есть все-таки хочется сделать историю красивой и разделенной по ответственности. Вот, и я такую штуку применяю часто, к сожалению, действительно, в студии я этого не делаю, я запускаю другие сторонние как бы мержилки,
321.20 341.72 "Игорь Лабутин" и часто бывает нужно. Ну вот, теперь такая штука есть. Дальше второе, большой блок улучшений, это про код cleanup, то есть теперь вы можете сконфигурить специальный код cleanup про файлы, которые будут автоматически запускаться, как только вы сохраняете файл. Вот, это тоже прекрасная
341.72 355.20 "Анатолий Кулаков" штука, я очень часто настраивал там всякие гитхуки и прочие вещи, которые тебе форматирует твой код так, чтобы он был в общем стиле как бы со всем проектом. А здесь вот прямо при сохранении, прямо из студии, она которая знает, что поменялось, к чему применять, а к чему не надо,
355.20 395.96 "Игорь Лабутин" это вообще красота. Да, и связанная с этим фича, но такая, связанная просто потому, что это тоже про сохранение, это про то, что вы теперь можете настроить автоматическое сохранение ваших файлов в момент, когда Visual Studio, окно Visual Studio теряет свой фокус. Сейчас это единственная опция, когда это можно сделать, но в зависимости от фидбэка, который поступит от комьюнити на предмет, как вообще эта фича работает, Microsoft скорее всего добавит, конечно, каких-то еще триггеров, так скажем, этого поведения. Так что теперь, когда вы альт табитесь в браузер, ну можно не нажимать Ctrl+S, она сама нажмет за вас. Вот это одна из самых ожидаемых мной фич
395.96 416.96 "Анатолий Кулаков" уже десятилетия просто от Visual Studio, это просто нормальное автоматическое сохранение постоянно. И вот немножко не доделали, мне бы вот просто сохраняться всегда без всяких перемен фокуса, поэтому друзья, все вместе собираемся, идем голосуем за фичу, чтобы сделали срочно нормальное сохранение без всяких фокусов, а просто сохранение по idle. Да, плюс еще надо сказать, что такое
416.96 439.20 "Игорь Лабутин" сохранение не будет триггерить код cleanup, это не то же самое, что ручное сохранение, то есть там есть некоторая разница, если хотите код cleanup, то нажмите ручками Ctrl+S. Мне, кстати, интересно, как эта фича автосохранения будет дружить с .NET Watch и Hot Reload. То есть если ты запустишь с командной строчки .NET Watch на свой проект, то ведь любое сохранение файла триггерит Hot Reload.
439.20 444.44 "Анатолий Кулаков" Ну .NET Watch действительно сидит на файл системы Watch, ему плевать, кто сохранил и когда сохранил.
444.44 447.40 "Анатолий Кулаков" Если файловая система сказала поменялось, значит поменялось.
447.40 460.88 "Игорь Лабутин" Вот, и вот у тебя типа ты окошко студии переключил, потому что ты там не знаю, начал писать кусочек кода, сказал альт таб в браузер, потому что что-то не уверен, а у тебя опа, он перегрузил уже твое приложение и новая версия исполняется.
460.88 479.28 "Анатолий Кулаков" Ну так и надо, в чем проблема? Я думаю даже наоборот, вот если она будет каждую секунду сама сохранять в Widely и .NET Watch будет перезагружать, естественно, если она скомпилилась и отработала, то это будет прекрасно. Это как раз то, что нужно. Ты получишь как раз рантайм, грубо говоря, дизайнер у себя на .NET Watch. Ну, может быть, может быть, не знаю.
479.28 487.64 "Игорь Лабутин" Я пока, мне кажется, не готов, все готовы и всячески приветствую автосохранение, но я пока не готов, чтобы .NET Watch на него так агрессивно реагировал каждую секунду.
487.64 513.80 "Игорь Лабутин" Ну, посмотрим. Пойдем дальше. Очередной блок под разделом be more productive with .NET это про то, что теперь всякий go to definition, то, что вызывается по всяким f12 или control-click мышкой, теперь наконец-таки поддерживает либо те сурсы, которые были заимбедрены внутри, значит, PDB-шек, либо source link, информацию, которая почему-то раньше не поддерживалась.
513.80 524.68 "Игорь Лабутин" Мне казалось, что когда source link внедрили, уж тулы типа Visual Studio точно должны были ее поддерживать, но почему-то вот не поддерживали. Теперь go to definition поддерживает, и если есть информация про source link, пойдет туда, куда он указывает.
524.68 537.84 "Анатолий Кулаков" Мне тоже было, по-моему, такое четкое впечатление, что Visual Studio всегда это поддерживало с момента внедрения, но так как я всегда пользовался ReSharper, и он точно это всегда поддерживал, я не могу сказать, кто действительно для меня все это подгружал.
537.84 559.76 "Игорь Лабутин" А ты знаешь, может быть, я знаю, в чем была разница, дебаггер поддерживал source link, то есть, когда ты в отладке отлаживаешься, там дебаггер тебе подтягивал правильные сурсы, а вот когда ты жмешь просто f12 во время редактирования текста, чтобы посмотреть, что это за, не знаю, условно, какой-нибудь там log.information, тыкаешь f12, то вот там, по-моему, source link не работал действительно.
559.76 568.00 "Анатолий Кулаков" Ну, может быть, но у меня через ReSharper действительно работал, я нажимал f12, составил бряку и в этот момент запускал дебаггер уже на настоящих сходниках.
568.00 573.56 "Игорь Лабутин" Да. Дальше появилась фича, которая тоже давно есть в ReSharper, и называется stacktrace explorer.
573.56 584.24 "Игорь Лабутин" Это вы можете взять откуда-нибудь ваш stacktrace, скопировать в это окошечко, и он позволит по нему понавигироваться, покликать мышкой и попытаться угадать, в какие же методы реально были вызваны.
584.24 598.32 "Игорь Лабутин" То есть он парсит просто текст и пытается подобрать в среде вашего кода подходящий метод, который был вызван. И последняя штука – это очередные улучшения Editor Config UI, туда добавили стиле именования, можно там теперь редактировать.
598.32 610.04 "Игорь Лабутин" Это все про быть очень продуктивным с дотнетом, и последний раздел в этой статье – это про персонализацию, и в данном случае это про цветные тапки.
610.04 614.28 "Игорь Лабутин" То есть ты когда-нибудь пользовался этим расцвечиванием тапов в студии?
614.28 617.72 "Анатолий Кулаков" Действительно, какой же продуктивизм без цветных тапочек.
617.72 622.44 "Анатолий Кулаков" Нет, не пользовался, но я слышал, что давно уже есть такой плагин, и вроде он довольно-таки популярный.
622.44 648.60 "Игорь Лабутин" Да, плагин Fitme есть, я даже когда-то его давно ставил и пытался пользоваться, не очень понял, ну то есть возможно я не открываю такого количества файлов, может быть расцветка это как бы используется с теми же, кто использует 150 тапочек в браузере, у меня по-моему больше 20 никогда не бывает, и после каждого завершенного логического куска работы они все закрываются, то есть вот ровно сейчас у меня одна единственная тапка в браузере открыта, а нет, две, одной не получится.
648.60 657.16 "Анатолий Кулаков" Слушай, ты счастливчик, надо как-нибудь с тобой записать отдельный выпуск, как ты это делаешь, потому что у меня там 3 или 4 браузера, и во всех у них не меньше 200 вкладок.
657.16 667.00 "Игорь Лабутин" Ну вот нет, сейчас у меня два конкретно браузера, потому что Zencaster, которым мы пишемся, в том числе требует хрома, а Firefox у меня открыт собственно трелл, в котором у нас карточки.
667.00 670.28 "Игорь Лабутин" Ну вот и всё, больше у меня ничего не открыто.
670.28 689.08 "Игорь Лабутин" Ну ладно, короче, возвращаясь к тапкам, теперь в Visual Studio можно расцвечивать тапки, я так понимаю, что в прошлой превьюшке, вообще в 22 студии завезли способ делать это по проекту и расширению файла, а теперь можно прям руками кликнуть, можно прям кликнуть на табочке и сказать "хочу зелёный", и она будет зелёной.
689.08 692.36 "Игорь Лабутин" То есть возможно вы так будете помечать какие-то очень важные для вас табы?
692.36 715.00 "Анатолий Кулаков" Ну, наверное, есть какой-то даже удобный API для плагинов, то есть я представляю себе какой-нибудь такой полезный юзкейс, когда ты можешь написать плагин и сказать, что вот в Assembly, который у меня с бизнес-логикой, я открываю все табики там зелёненькие, с инфраструктурой все табики там чёрненькие, и тебе может быть это каким-то образом подскажет, где ты сейчас есть и какой код там можно писать, а какой нежелательно писать, что-нибудь такое.
715.00 741.32 "Игорь Лабутин" Ну да, либо, например, в зависимости от того, редактировал ты этот файлик или нет, по сравнению с GT, ну грубо говоря, является ли он сейчас changed или не является, потому что ты пока навигируешься по коду, у тебя открывается там 100-500 табок, которые просто потому что ты туда сходил по F12, а те, которые именно ты редактировал, ну вот они и есть. Хотя, не знаю, Control+Shift, что там, запятая, да, и все последние места редактирования на месте перед тобой.
741.32 761.72 "Анатолий Кулаков" Да, да. Кстати, если вдруг кто не знает, действительно у ReSharper есть список последних отредактированных файлов, это Control+Zапятая или Control+Shift+Запятая, это в зависимости от того, редактируемые или отсмотренные файлы. Еще есть один шикарный hotkey, это Control+Shift+Backspace, он вас возвращает к тому месту, где вы последний раз что-то редактировали, что-то писали.
761.72 774.72 "Анатолий Кулаков" Это вот самый, наверное, часто используемый после Alt+Enter у меня hotkey, когда ты что-то пописал, потом пошел, поновидировался и не хочешь искать, где ты это писал, ты просто хочешь продолжить писать. В общем, Control+Shift+Backspace и вы на месте.
774.72 780.76 "Игорь Лабутин" Ну вот, на этом все в Visual Studio 17.1 Preview 2, больше пока про нее новостей нет.
780.76 915.08 "Анатолий Кулаков" Ах, хорошо, я тут и нашел интересную статейку, сталкивался в последнее время часто с людьми, особенно когда вышел .NET 6, которые снова начали путать, зачем нужен .NET 6, зачем .NET 5, где там среди этого всего .NET Standard и BCL и прочие вот эти глупости, поэтому хотелось бы вот с точки зрения текущих фреймворков посмотреть, а действительно ли нам нужен сейчас до сих пор .NET Standard, и когда его нужно использовать, когда не нужно использовать. И, кстати, подвернулась под руку статеечка. Поэтому давайте немножко вернемся к нашему .NET Standard и вспомним, а жив ли он или нет. На самом деле, действительно он жив. Итак, для тех, кто пропустил или только что зашел в технологии, напомню, что .NET Standard - это некая спецификация или общий набор контрактов для API между всеми фреймворками, между всеми реализациями .NET. На самом деле, .NET существует очень много имплементаций и на разных платформах. Самый известный большой .NET Framework, он на самом деле был не кроссплатформенный, да по сути и есть. Он создавался изначально только под Windows и у него было очень много завязок на Windows, именно поэтому решили его не патчить для того, чтобы перенести под Linux, а просто написать .NET Core новый. Другие имплементации можно вспомнить - это Mono, Unity, UVP, Silverlight и, конечно же, наш .NET Core. Здесь очень важный момент, который тоже может немножко запутать новичков - это в том, что нынешняя ветка .NET Core, которая кроссплатформенная, работает везде, под всеми операционными системами, под всеми платформами, рантаймами. Ее после .NET третьей ветки переименовали в .NET 5 и поэтому теперь у нас есть .NET 5, который по правде кроссплатформенный, который по правде новенький, переписанный, быстрый, красивый. Вот, несмотря на то, что обычно .NET называли старый, большой, под Windows и не кроссплатформенный. Тут тоже важно очень не путаться. И, соответственно, Microsoft теперь будет поддерживать линейку, которая .NET 5, .NET 6 и так далее. Большой .NET фреймворк, так называемый, уже не будет дальше развиваться, не будет дальше поддерживаться, и поэтому всем рекомендуется с него срочно мигрироваться. Итак, вернемся к нашим стандартам.
915.08 1178.12 "Анатолий Кулаков" Как я уже сказал, .NET стандарт поддерживает много имплементаций и, в частности, вместе с ними есть поддержка Unity, Xamarin.ios, Xamarin.Mac, Xamarin.Android, то есть всеми любимыми, любимых наших мобилочек. И .NET 5 все еще не поддерживает эти платформы. И вот почему .NET стандарт все еще актуален. Потому что .NET стандарт покрывает как раз таки, успел покрыть за время жизни своего существования, когда он еще развивался, успел покрыть большинство платформ, до которых еще большому .NET, то есть новому нашему .NET далеко. И именно поэтому рекомендация того, о чем начинать новый проект или о чем продолжать старый проект, она зависит от того, кто ваши потребители. Прежде всего. Если вы можете, то обязательно выбирайте .NET 6 или .NET 5, ну, наверное, сейчас 6, какой смысл на 5 остановиться. То есть .NET 6 или самый последний .NET, который есть у вас, если вы не связаны ничем другим, никакими другими соседними библиотеками, фреймворками, то для вас все просто. Последний .NET берете и радуйтесь жизни. Начинаются всякие сложности, как только вы предоставляете какие-нибудь библиотеки. Если вы автор библиотек, вы просто так .NET 6 завязать не можете. Потому что вас должны референсить другие приложения. И эти приложения могут быть построены на чем угодно абсолютно. И могут запускаться где угодно. Поэтому здесь уже вам стоит задуматься. Итак, начинаем думать. Если ваши библиотеки могут быть использованы в большом .NET фреймворке, если вы предоставляете какие-то контракты, клиенты или еще что-то, что должно вязаться в большом фреймворке, то ваш выбор это .NET стандарт 2.0. Стандарт 2.0 - это последний стандарт, который поддерживается большим фреймворком. То есть это единственный таргет, с помощью которого можно подружить и самый последний фреймворк, и вот этот самый старый, на котором написано еще огромное число устаревших приложений. И это очень частый кейс, когда например компания эмигрирует. Компания эмигрирует, какие-то сервисы она уже перевела на .NET 6 или начала писать на .NET 6. И при этом ей нужно предоставить контракты, предоставить клиенты для старых приложений, которые все еще работают в их системе, которым все еще нужны контракты, все еще нужны клиенты. И вот эти контракты спокойно потребляются через .NET стандарт 2.0. Это отличный юзкейс и понятная ниша. Само приложение написано на .NET 6, контрактные сборки таргетятся на .NET стандарт 2.0. Дальше у нас есть еще .NET стандарт 2.1. Как вы уже поняли, большой фреймворк 2.1 не поддерживает, но зато его поддерживает Mono, Xamarin и может быть .NET Core третьей версии, если вдруг он вам все еще нужен. Соответственно, если у вас нет большого фреймворка, но вы должны таргетиться на Mono и Xamarin, то .NET стандарт 2.1 - это ваш выбор. Если вы всего всех этих глупостей лишены, то есть ничего такого вам больше поддерживать не надо, то опять же .NET 6 и все. Ну да, еще я не упомянул по .NET стандарт ветку 1.1.x. Ее не рекомендуется использовать, то есть, в принципе, довольно мало эскисов, когда она вам нужна или практически их совсем уже не осталось. Поэтому смотрите 2.0, если вам нужен большой фреймворк, 2.1, если вам нужен Xamarin или не смотрите больше никуда, если вам нужен .NET 6. Этот выбор, он делится, в принципе, вы должны осознавать, на что вы идете, потому что .NET стандарт дает вам больше поддержки всяких рантаймов, больше инфраструктуры, больше библиотек, которые могут вас юзать, а последняя ветка .NET, .NET 6 дает вам больше фич. В общем, вы должны балансировать между двумя этими крайностями. Есть еще один интересный подход, который выбирает, в принципе, сейчас все авторы популярных библиотек. Это мультитаргет. Мультитаргет - это такая прекрасная вещь, которая дает вам возможность одновременно и воспользоваться всеми фичами, всеми преимуществами последнего .NET и немножко попытаться покрыть какие-то ущербные ветки, которые вы все-таки обязаны как-то поддерживать. Как это работает? Прежде всего, довольно просто. В .Sproche файл вы добавляете несколько таргетов, например, .NET 6 и .NET стандарт 2.0. То есть, это самая популярная комбинация. .NET 6 для того, чтобы получить максимальную фичу, а .NET стандарт 2.0 для того, чтобы покрыть очень много устаревших фреймворков, в том числе .NET фреймворк большой.
1178.12 1327.28 "Анатолий Кулаков" Здесь, соответственно, у нас возникает сразу дилемма. А что же нам делать, если вот вдруг нам нужна какая-то фича из последнего фреймворка, которой нет в стандарте? Как она будет в этом проекте работать? Есть два решения. Во-первых, у нас все еще остаются pre-conditional атрибуты. То есть, вы можете написать if и какой-то target framework обозначить и написать два куска кода, который один будет работать в фичастой версии со всеми наворотами и второй кусок кода, который будет работать с какими-то fallback и как-нибудь ущербно. В общем, проект будет один компилироваться, он будет у вас один раз и вы поддержите все миры. Это самый плохой, неудачный вариант. Есть возможность пойти более удачным путем, потому что с тех пор, как Microsoft начал доработать фреймворк на безумно маленькие сборочки, это дало преимущество в том, что вот эти безумно маленькие сборочки, их можно очень легко портировать. И сообщество, и сам Microsoft очень много таких сборочек уже портировала. Например, в .NET стандарте вы без проблем можете использовать nullable reference type, async and numerable, spans, system.txt.json.serializer и много-много других таких крутых фич, которыми сейчас гремит новый фреймворк и новые библиотеки. Вот все это вы можете поставить в виде отдельных пакетов и пользоваться вообще без проблем. Они давно портированы на .NET стандарт 2.0 и никаких изменений в коде вам при этом не понадобится. Достаточно только, если вы используете второй .NET стандарт, подтащить пару лишних библиотечек. С этим обычно проблем никаких не бывает. Соответственно, Multitargets позволяет вам получить лучшее из обоих миров. Вы можете одновременно покрыть и старые версии, которые вынуждены поддерживать, и одновременно воспользоваться фичами нового фреймворка. Так, например, если вы сделаете Multitarget на .NET 6 и стандарт 2.0, вы вполне можете эту библиотеку заиспользовать и запустить в .NET 4.6.1 и в консольном приложении, допустим. И ничего страшного в этом нет, потому что все совместимо, все поддерживается и все будет работать. Вот примерно такие рекомендации. Я думаю, вам сейчас более-менее стало понятно, как начинать новые проекты, как поддерживать старые, куда мигрироваться и какие версии все еще актуальны, а про какие уже можно забыть, как про Legacy. Соответственно, .NET стандарт больше развиваться не будет. .NET стандарт 2.1 - это последняя версия, которая вышла. Дальше Microsoft рекомендует максимально использовать
1327.28 1383.20 "Игорь Лабутин" именно линейку .NET 5, .NET 6 и так далее. При этом я хотел бы добавить, что если ваша цель состоит в том, чтобы поддержать самый, так сказать, последний и наиболее нагруженный фичами релиз - это .NET 6, и при этом остаться совместимым с полным фреймворком, то я бы, может быть, рекомендовал не использовать .NET стандарт 2, а использовать прям конкретно .NET 4.6.1, например. То есть, если вам не нужны все эти странные рантаймы типа Xamarin, Mono и других штук, а просто фулл фреймворк и последний текущий .NET, то лучше, наверное, использовать обычный мультитаргет на обычный фреймворк, ну просто потому что там будет все работать чуть получше, потому что реализация .NET стандарта 2.0, который был поддержан в 4.6.1 первый раз, она там все-таки хромает, и можно наткнуться на некоторые неприятные ошибки. Но тут, конечно, зависит от того, какие рантаймы вам нужны и сколько вы готовы тратить времени на поддержку того или иного варианта.
1383.20 1393.84 "Анатолий Кулаков" Да, да. Ну, надеюсь, скоро мы все про это забудем как про старшинный FSON и уйдем все на одну ветку, которая будет поддерживать абсолютно все платформы. Кстати, в том числе новый UI.
1393.84 1399.60 "Игорь Лабутин" Да, новый UI. Про MAUI мы говорим почти в каждом выпуске, тихонечку выходят новые превьюшки.
1399.60 1414.28 "Игорь Лабутин" Вышла очередная превью уже номер 11, и она доступна вместе с уже вышеупомянутой Visual Studio 2022.17.1 Preview 2. Скороговорка почти получается. Там завезли некоторое количество новых вещей.
1414.28 1495.40 "Игорь Лабутин" Это новые стилизации под Fluent Design, то есть они потихонечку начинают стайлить контроллы под правильный виндовый Fluent Design стиле. Дальше сделали такую фичу, которая называется Multi Window Apps, то есть вы теперь можете в одном приложении создать сколько угодно окошек. Они все будут доступны в специальном статическом property под названием application.current.windows, и вы там можете взять любое окошко, закрыть его или активировать, или что с ним еще сделать, подвинуть куда-нибудь. Поскольку у нас появился C# 10, в котором появились новые всякие фичи типа Global Usings и вот этого всего, то теперь новые шаблончики для MAUI-приложений позволяют сказать, что я хочу Implicit Using, и у вас тогда начнут использоваться Global Usings, и количество Usings в каждом файлике резко уменьшится. Немножко причесали типы вокруг iOS, macOS, tvOS, в общем, чтобы оно все было более-менее, выглядело единообразно, и добавили новую, скажем так, документацию, то есть переделали, и теперь, я так понимаю, там полноценный новый портал, который содержит всю правильную latest документацию конкретно под MAUI. Ждем релиза все так же в втором квартале этого года, надеюсь, что будет все вовремя, будем следить. Отлично,
1495.40 1635.92 "Анатолий Кулаков" ну что ж, вроде с .NET, с Microsoft и официальными тулами разобрались, пойдем немножко посмотрим вокруг сообщества. В сообществе интересная тема была, кто-то очень сильно набросил на медиатор, и в принципе, я сегодня расскажу вам про первую статейку, но чтобы вас не напрягать, надеюсь, в следующий раз мы дойдем все-таки до второй, где наброса отразился еще больше. Но во всем по порядку. Медиатор - это очень популярная библиотека, я думаю, одна из самых популярных библиотек, про нее практически все знают, практически все используют. Это такая своеобразная прослойка, которая помогает вам бросать некие сообщения, забрасывать в домен, там их каким-то образом с помощью хендлеров обрабатывать и возвращать результат. Казалось бы, идея примитивная, реализация тоже не очень сложная, но так как это довольно удобная штука, на ней повесилось еще очень много таких практически полезных реализаций, она быстро завоевала свою нишу, тем более автор Джимми Боггарт довольно известный человек в узких кругах, очень хорошо ее пропиарил, и теперь эта библиотека используется в очень многих проектах. Но иногда выходят некие статички, которые пытаются как-то унизить медиатор, рассказать его слабые стороны, их немного, но они есть и они достаточно интересные. И вот я предлагаю вам сегодня обсудить как раз таки одну из этих статейчик, также она прекрасна тем, что она показывает нужность и необходимость медиатора на примере CQRS приложений. CQRS - это тоже такой интересный шаблон, который часто очень используется в различных приложениях, но не в чистом виде, а вот некие идеи оттуда как-то выдираются, как-то модифицируются и примерно в каких-то местах, где это нужно, они вставляются, что в принципе прекрасно. И поэтому может быть для каждого из нас и из вас узнает какой-то небольшой кусочек, который есть в вашем приложении. Хорошо, а теперь ближай к статейчике. Как я уже говорил, CQRS - это стандартный, уже довольно известный шаблон, главную его идею всегда описывают очень легко. Вы должны разделить все операции, которые происходят с приложением на read и write, то есть операции, которые читают и операции, которые пишут. Из этого следует очень много преимуществ, из этого следует очень много там всяких выводов, оптимизации и так далее. Мы сейчас касаться не будем, если кому интересно, отдельно почитайте или послушайте наши предыдущие выпуски.
1635.92 1757.44 "Анатолий Кулаков" Соответственно продолжим развивать тему read и write. Если у вас вдруг есть какое-то приложение, вы вполне можете начать рефакторинг вашего приложения с помощью того, что вы делите вот такие части читающие и пишущие, например, из вашего юзер сервиса. То есть разделить его на два интерфейса юзер read service, куда перенесете все методы, которые читают информацию о пользователе, и юзер write service, которые пишут информацию о пользователе. Но обычно, когда вы начинаете это делать, постепенно, особенно когда сервис у вас большие, когда операций много, вы приходите немножко к другому подходу. Вы каждую операцию заворачиваете в отдельный классик, то есть классик или команда, или классик query. И, соответственно, у вас получается query и command классики. И в них вы запихиваете всю необходимую информацию для того, чтобы обработать, исполнить ту или иную операцию. И вообще, чтобы построить security framework, так называемый, вам всего-навсего достаточно четыре интерфейса, в каждом из которых будет по одному методу. Вот просто зацените, вам нужен query handler, у которого есть единственный метод handle, который в качестве параметра принимает query и исполняет запрос, и возвращает какой-то результат. И вам, соответственно, нужен query dispatcher. Это та фабрика, тот репозиторий, который вам будет находить необходимый handler и просто-напросто его запускать. И точно такая же ситуация у вас будет с command handler и command dispatcher, которые точно так же обрабатывают команды. В общем, здесь буквально по одному методу на четыре интерфейсика. Вот вам, в принципе, весь security framework. Все остальное это уже как бы на вороты. Это уже какие-то дополнительные фишки и так далее. Кому-то они нужны, кому-то не нужны, не суть важно. Вместе с тем, когда у нас появились di-контейнеры, написать такой замплимирователь dispatcher оказалось довольно-таки просто. Вы просто идете к сервис-провайдеру, запрашиваете у него command handler с определенным типом, и он вам их возвращает. То есть di-контейнеры прекрасно резолвят такую ситуацию. Единственное, что вам нужно сделать, это зарегистрировать все command handlers, которые есть в вашей системе.
1757.44 1880.76 "Анатолий Кулаков" Это тоже несложно делается. Например, есть такая библиотека, которая называется "scrouter". Она поддерживает регистрацию по договоренностям. Это значит, что вы можете выписать выражение типа "возьми мою assembly, достань оттуда все классики, которые имплементируют i-command-handler и зарегистрируй их с их generic-атрибутом в контейнере". А потом этот open generic attribute можно закрывать в момент резолва. Все. Это практически все, что вам нужно для того, чтобы декларировать CQRS framework и, по сути, заимплементировать его. На это у вас не уйдет много времени. Итак, почему же многие люди кричат, что без медиатора никто сейчас CQRS не делает и без этого абсолютно невозможно жить, если мы только что с вами разобрали и все прекрасно делается буквально четырьмя интерфейсами? Зачем же нужен нам все-таки медиатор и почему он нам в данном случае, автор пытается доказать, что он нам не подходит? Прежде всего, давайте рассмотрим. Как я уже говорил, медиатор больше похож на некую шинку, шинку, которая находится в одном процессе и разбрасывает так называемые requests по вашему приложению. Самое интересное, что несмотря на то, что медиатор как бы считается практически обязательным атрибутом для любой реализации CQRS, у него нет самых базовых и основополагающих концепций. У него нет ни команд, ни query. Вот, казалось бы, единственное, что требует CQRS, это разделение на read/write, на command и query. Но нет, у медиатора этого нет. У него есть более обобщенный классик, который называется iRequest. Там же у него есть iNotification и прочие ненужные нам для исследования вещи. Ну, в общем, разделения read и write нет. И это довольно сильно ограничивает возможности вашего приложения. Потому что обычно, если у вас есть разделение на read и write, на command и query, вы можете сделать какие-то вещи, зависящие от того, к чтению или к записи относится ваша операция.
1880.76 1926.00 "Анатолий Кулаков" Ну, например, вы можете запретить модифицировать данные, если вдруг вы выполняете query. Ну, то есть, тот же самый принцип, что нам просит CQRS. Или вы читаете, или вы пишете. Вот это можно сделать на уровне контракта, прямо на уровне кода, если у вас есть разделение и четкое понятие, что вот пришла query. Например, вы можете запретить сохранять данные, то есть запретить коммитить вообще транзакцию, если к вам пришла query. Ну, потому что по принципам CQRS, query не может ничего менять и никакого смысла коммитить не должно быть. Если вы что-то поменяли, то это уже бага. Например, вы можете запретить возвращать модифицированные данные, если к вам пришла команда. Ну, потому что команда не может ничего возвращать, она должна только писать. Или, например, вы можете обработать commit транзакции, если команда выполнилась успешно и все данные, которые нужны, она промодифицировала.
1926.00 2009.92 "Анатолий Кулаков" И в конце концов, обычно после выполнения всех команд, уже когда все прошло успешно, вы об этом знаете, после успешного коммита вы хотите разослать всякие оповещения в том, что в вашем домене что-то поменялось и отсылать так называемые нотификации. Опять же, все это нужно делать, только если у вас отработала команда. Вот много таких очень полезных для жизни мелочей можно построить на том принципе, что команд и квери у вас разделяются. Соответственно, с медиатором это не так. Они там не разделяются и поэтому есть с этим какие-то тонкости. Также это дает преимущество на ревью. Вы довольно легко взглядом цепляетесь за вот эти команды, квери и так далее. И на ревью вам понятно, где принципи секретс нарушаются, где они не нарушаются. И довольно легко отследить логику всей программы и логику автора, который пытался писать какой-то дополнительный код. Мы можем конечно ввести вот эти четыре интерфейса на основе медиатора. То есть пронаследовать от реквеста какие-то команды, пронаследовать от реквеста квери, но все равно это может ввести в заблуждение некоторых пользователей. А с другой стороны, зачем? Если мы понимаем, что вся реализация это буквально четыре строчки, непонятно зачем это делать. Еще одним интересным аспектом того, почему используют медиатор, это то, что у него очень богатые возможности по расширению behavior.
2009.92 2089.28 "Анатолий Кулаков" То есть вы можете очень много набросать в него аспектов, которые помогают обработать ваше приложение с точки зрения Cross-Cutting Concern. Давайте к напримерам. Например, вам нужно сделать логирование и вы не хотите писать именно в лог в каждом обработчике вашей команды, а вы хотите написать общий хендлер, который в начале каждого обработчика там допустим замеряет время и в конце каждого обработчика это время логирует. И вот таким образом вы узнаете сколько по времени длилось каждая из ваших команд. Бизнес-логика чистая, время исполнения команды известно, залогировано, все довольны в принципе. Но если мы приближаемся к медиатору, то опять же мы видим, что медиатор не делит пайплайны, обработки так называемые, на пайплайны обработки команды и пайплайны обработки query, что опять же, как и в предыдущем пункте, лишает нас кучи очень полезных вещей. Например, если у нас разделенные пайплайны для чтения и для записи, то для них можно навешать отдельные аспекты. Кэширование для тех операций, которые только читают, вполне типичный вариант, когда мы просто хотим кэшировать какие-то определенные вещи. Естественно, в райты мы кэшировать не хотим. Дальше мы можем для query настроить unit of work только на read-only поведение.
2089.28 2103.52 "Анатолий Кулаков" Вот, соответственно, для в райта мы можем, для команд мы можем настроить unit of work на в райт, например, чтобы он там поддерживал какие-то в райтовой оптимизации. Например, логировать аудит мы можем только для операции на запись, потому что для операции на чтение никакого смысла не имеют.
2103.52 2183.28 "Анатолий Кулаков" И вот таким образом, если мы разделим пайплайны обработки query, пайплайны обработки команд, у нас тоже появляется очень большой мощный механизм, который помогает избежать ошибок, как на этапе самого программирования, на этапе интеллисенс, на этапе доступных интерфейсовых команд, так и в том числе в момент код-ревью. В общем, тоже очень полезно. И все эти проблемы как раз таки возникают в том, что у медиатора нет разделения на командный query и на read и в write классы. Но это абсолютно не проблема, если мы делаем вот эти наших четыре вышеупомянутых интерфейсика, то есть у нас есть command dispatcher и query dispatcher, которые полностью умеют построить pipeline, который лишен всех этих проблем и может подстраиваться под тип той операции, которую вы запускаете. Соответственно, вот автор как раз-таки и не думевает, а зачем же вообще нужен тогда медиатор и зачем вообще люди его так сильно используют, и вводят всю вот эту сложность в свой фреймворк, потому что чем больше вы используете каких-то внешних зависимостей, чем больше магии диспатчинга, обработки, аспектов, бихеверов у вас есть, тем сложнее вам продебажить, разобраться, найти какие-нибудь ошибки, которые есть в этом фреймворке, и ввести новых членов в вашу команду, которые никогда с этой штукой не сталкивались.
2183.28 2188.60 "Анатолий Кулаков" Вот такое интересное наблюдение. Да, здорово. Мне их пользовалось на самом деле
2188.60 2195.52 "Игорь Лабутин" медиатором, как-то так случилось. Либо писали все ручками, либо наша архитектура не совсем
2195.52 2245.88 "Анатолий Кулаков" была заточена на SQL. Я просто тоже очень часто писал подобные системы и действительно никогда не пользовался медиатором, глядя на него и поснимая какую-то всю его сложность, я не понимал, зачем это делается. И вот я на своей шкуре полностью ощутил действительно вот эту гениальность всего этого разделения на четкие read pipeline и write pipeline, то есть на сколько там пробрасывается кэширование, на сколько там unit of work могут коммитить свои транзакции, когда нужно правильно поливать доменный объект нотификациями и прочее. Там настолько это красиво и грамотно выстраивается, что просто даже желание попробовать медиатор для чего-то не возникало, потому что сценарий он покрывает гораздо меньше и по сути вводит слишком такую абстракцию, которая абсолютно слабая. Она очень-очень слабая, она вас за домен лишает огромного числа
2245.88 2370.36 "Игорь Лабутин" преимуществ. Ну и ладненько, пойдем в другую часть, пойдем в наш любимый garbage collector и все такое прочее. Наскнулся на интересную статейку, где сравнивается поведение приложения под full framework 4.8 и шестым дотнетом. То есть в большинстве случаев, как правило, то, что я видел, народ переходил с 4.8, те кто был готов переходить, не спеша переползали на дотнет кор 3, потом на 5 дотнет, потом на 6 и видимо за таким переходом производительность где-то чуть-чуть лучше, чуть лучше, чуть лучше и так далее. А здесь ребята переписали с 4.8 на дотнет 6 сразу и вот поделились довольно интересными наблюдениями. Для начала о том, что за приложение. Приложение это такой специальный, ну демон не демон, короче приложение, которое контролирует камеры, точнее собирает информацию с камер, порядка десятка камер и соответственно обрабатывает порядка гигабайт в секунду этих самых картинок с попыткой собственно классифицировать, что там происходит на каждой картинке. Общая идея в том, что в зависимости от того, что происходит на картинке, нужно допустим коробку с конвейера столкнуть или не столкнуть, что как вы понимаете добавляет некоторой интересности, потому что нужно это сделать вовремя, очевидно. Если мы немножко задержимся с некоторым пониманием того, нужно ли столкнуть коробку, то коробка уедет дальше, механизмы, которые ее умеют столкнуть и все наши дальнейшие вычисления будут в общем-то бесполезны. И понятно, что здесь garbage collector в дотнете и вообще дотнет как таковая система может быть не очень идеально, потому что garbage collector может в любой момент сказать "у нас в общем пауза, я тут собираю мусор". И понятно, что код в итоге написан так, что память используется минимально, то есть после выхода на какое-то стабильное состояние практически не должно лоцироваться новая память, чтобы garbage collector не паузил приложение и ничего не делал, в общем-то. Но иногда все-таки делать приходится, потому что какой-то алгоритм работает над этими картинками и есть, и совсем без garbage collector никак.
2370.36 2455.16 "Игорь Лабутин" Что было, что они выяснили после того, как смигрировали с 4.8 на дотнет 6? Во-первых, выяснилось, что такая характеристика, максимальное время паузы в дотнете 4.8 на их приложении они смогли добиться 13,5 миллисекунду. Я как бы со стороны своих бизнес-приложений смотрю на это и прям удивляюсь, потому что 13,5 - это прям миллисекунд, это прям очень маленькая пауза, у нас как бы они не бывают и больше, но в 6 дотнете оно упало аж до 4.9 миллисекунд, то есть практически в 2, даже в 3 раза почти. И это прям здорово. И более того, если посмотреть там внимательно на графики, в статье есть всякие разные графички и распределение того, как эти самые паузы происходили по приложению, выяснилось, что не только исчезли вот эти длинные паузы на 13,5 миллисекунд, но более того, время между вот этими паузами, которые остались по 5 миллисекунд примерно, оно увеличилось раза в 2, то есть они стали, вот эти самые garbage collector стали происходить раза в 2 меньше, хотя казалось бы, всего-то переписали приложение на новый фреймворк и логика приложения не поменялась, то есть не стало где-то меньше лоцировать память или еще как-то локации, памяти столько же, но garbage collector работает в 2 раза меньше, срабатывает в 2 раза реже и при этом все работает так же с точки зрения перформанса.
2455.16 2462.16 "Анатолий Кулаков" Да, впечатляет. Слушай, отличные цифры. А у них там и были какие-то алгоритмы, которыми они специально оптимизировали эгоцель или что-нибудь в этом духе,
2462.16 2518.60 "Игорь Лабутин" делали ли они какую-то магию с этим? Ну, они делали магию, но это ровно та же магия, которая на 4 оси и мы на 6. Нет, это все чисто из-за рантайма, то есть в тутнет 6 настолько смогли заоптимизировать рантайм, что и garbage collector конкретно, что он теперь вот работает быстрее. На самом деле, на самом деле там есть некоторая попытка анализа, почему так стало происходить и там с некоторой помощью Маони они вроде как вывели конкретный практически pull request, в котором это все было сделано, то есть там есть такая тема, что garbage collector, как известно, когда он делает свое дело, ему иногда, иногда для некоторых фаз нужно сделать stop the world полный. И понятно, что если у вас сейчас код выполняется в каком-то потоке, то вот просто так взять и в произвольном месте потока остановить его невозможно. Его можно останавливать только в определенных местах, это называется save point, если я правильно помню.
2518.60 2628.80 "Игорь Лабутин" За подробностями обращайтесь либо на github microsoft, где все это разложено, либо в книжку Conrad Karkos, и там подробнейшим образом расписано про то, какие кусочки кода являются safe, какие не safe, на каких конструкциях что может быть сделано. И в частности, одним из этих save point является возврат из функции. И stop the world в том числе делается забавным способом, то есть если я правильно помню, то если поток сейчас выполняется, и garbage collector понимает, что он не может сделать stop the world в данный момент, он подменяет инструкцию возврата так, что вместо собственно инструкции возврата происходит возврат в ту функцию, которая потом собственно застопает этот самый world и потоку не даст дальше выполняться. И когда все потоки таким образом остановились, дальше garbage collector может все собирать. Так вот, в garbage collector есть некоторый внутренний, так скажем, timeout или ping, то есть если он поток не может остановить, он к нему возвращается через какое-то время. По дефолту это было время 10 миллисекунд. И время вот пока он ждет и не может все еще остановить потоки тоже входит в паузу garbage collector по статистике, которая видна там в perfu и других местах. Так вот, что сделали в .NET в garbage collector, теперь это timeout 1 миллисекунда. То есть garbage collector более агрессивно опрашивает потоки и говорит, ну что, давай будем остановиться, не будем, не будем, не будем, не будем, не будем. И именно за счет этого паузу на самом деле резко удалось сократить. Я не знаю, конкретно не вкидывался, почему прям вот было изменение с 10 до 1, надо почитать pull request более внимательно. Но кажется, что Moony знает свое дело и делает этот самый garbage collector настолько прям умным и хорошим, что он вот получается достаточным. Просто проапгрейдить фреймворк и ваш garbage коллектор становится работать прям супер быстро. Да, не зря нам рассказывали, каждый практически
2628.80 2650.04 "Анатолий Кулаков" при лилис, при байке, что вот GCS становится лучше, перформанс улучшается и все, все, все. Вот благодаря таким переходам, благодаря таким статьям и замерам мы действительно видим насколько, насколько сильно он улучшается и насколько быстрее все становится работать только потому, что вы обновились на новую версию. Наверное, это можно использовать как какой-то аргумент для менеджеров перейти на новый фреймворк и все-таки потратить какое-то время для того,
2650.04 2670.32 "Игорь Лабутин" чтобы мигрировать на новые технологии. Это однозначно, да. Другое дело, что чтобы использовать это как аргумент, нужно на своем приложении это тоже померить. То есть может быть, в качестве каких-то тестов варианте быстренько попробовать маленький кусочек приложения или логики перевести на последний фреймворк, сделать измерение и после этого с киселками уже приходить.
2670.32 2684.88 "Анатолий Кулаков" Я не уверен, что все эти киселки, которые ты переведешь в какой-то маленьком кусочке, они будут показательны для всего твоего приложения, потому что ГЦ это такая штука, которой очень важно настоящие данные, настоящие железо, которое работает, настоящие нагрузки, иначе он может тебе показать абсолютно другую картину.
2684.88 2764.36 "Игорь Лабутин" Это тоже правда, да, согласен. Но в любом случае, да, ГЦ нужно точно мерить, ГЦ нужно мерить и на маленьких кусочках на самом деле и на больших, потому что если вы можете выделить свою логику отдельно и тяжелую, то даже она отдельно будет показательна, хотя, конечно, если у вас приложение это в среднем, там обработка запросов, ну там сложно, наверное, будет выделить что-то одно конкретное. Но следите за тем, что происходит в .NET. В 7 .NET нам обещают еще одно большое изменение, точнее, как обещают, оно уже вмерзжено в мастер, ну или в мейн, в ветку. Там, соответственно, если вы помните, что такое сегменты, Гарбич коллекторы, да, это большие непрерывные области памяти, где, собственно, Гарбич коллектор ведет всю свою деятельность внутри себя, выделяя эти самые кусочки, поколения и так далее, то в 7 .NET это все поменяется, эти самые сегменты будут теперь маленькие, их можно будет переиспользовать, освобождать, возвращать оперативную память операционки, в общем, там все будет частично по-другому, не то чтобы совсем по-другому, но частично по-другому, и не то, что никто пока не знает, как это повлияет на продакшн, но они не зря завезли это, они ждали эту поддержку, чтобы завести в .NET именно 7, в смысле, что они не стали в последний момент включать ее в 6, хотя она достаточно давно уже готова, вот, видимо, очень сильно хотят это все потестить на ранних версиях, и чтобы у них был почти год, чтобы все это хорошо подтюнить. Ну и вообще, в принципе,
2764.36 2785.04 "Анатолий Кулаков" .NET развивается в плане перформанса не только в ГЦ, но и просто во всех остальных и инструментах, и библиотеках, и рантаймах, и в компиляторах, и в анализаторах, в общем, во все-во все-во все стороны, поэтому тут недостаточно мерить только ГЦ, здесь можно мерить абсолютно все подряд, а лучше все просто переводить, и у вас точно будет быстрее.
2785.04 2788.08 "Анатолий Кулаков" Мне кажется, это правило будет работать практически для всех проектов.
2788.08 2789.52 "Анатолий Кулаков" Это точно, давай дальше.
2789.52 2818.60 "Анатолий Кулаков" Я наткнулся на то, что почему-то не все в мире разработчики знают о том, что диаграммы, красивые диаграммы можно составлять с помощью кода, и поэтому решил подробнее вам рассказать про один из замечательных инструментов, который называют Memo8, это как бы русалочка по-английски, и смысл этого инструмента заключается в том, что вы можете описывать различные графики, различные диаграммки, различные блок-схемы, графы в виде простого кода.
2818.60 2822.92 "Анатолий Кулаков" Ну, не совсем кода, а в виде синтексиса, который приближен немножко к коду.
2822.92 2833.28 "Анатолий Кулаков" Например, если вы знаете Markdown, или когда напряжетесь и выучите синтексис Markdown, то можете считать, что вы уже вполне способны программировать диаграммы с помощью текста.
2833.28 2845.68 "Анатолий Кулаков" Как я уже сказал, Memo8 - это специальный язык разметки, который позволяет вам визуализировать различные диаграммки, чатики и так далее.
2845.68 2857.48 "Анатолий Кулаков" Его приличие заключается в том, что он может не только писать диаграммы в виде отдельного как бы файлика, но и встраиваться в абсолютно очень много, в какие системы форматирования.
2857.48 2858.60 "Анатолий Кулаков" Например, в тот же самый Markdown.
2858.60 2862.32 "Анатолий Кулаков" Можете писать текстом Markdown, потом вставить красивый график и пойти писать дальше.
2862.32 2870.44 "Анатолий Кулаков" И у вас уже появляется не просто какой-то голый некрасивый набор текста, а красивые диаграммки, объясняющие, что вы умный чувак, еще умеете диаграммки рисовать.
2870.44 2872.44 "Анатолий Кулаков" Удобная штука.
2872.44 2880.76 "Анатолий Кулаков" И самый главный принцип, почему стоит на это смотреть, почему это удобно, потому что вы можете уже сделать какую-то графику в виде кода.
2880.76 2883.64 "Анатолий Кулаков" В чем прелесть делания всего в виде кода?
2883.64 2894.20 "Анатолий Кулаков" В том числе графиков, CI/DI контейнеров и прочее, почему люди, разработчики как-то в последнее время все хотят сделать с помощью кода.
2894.20 2901.60 "Анатолий Кулаков" Вывод очень прост, потому что это дает вам все те преимущества, которые вы уже привыкли видеть в своем коде.
2901.60 2919.40 "Анатолий Кулаков" Например, тот же самый гид версионирования, с помощью которого вы можете посмотреть, кто этот файлик редактировал, когда редактировал, почему, если к нему привязаны какие-то ищесы, и откатиться на нужную версию, сделать бранч, поэкспериментировать, откатить бранч, удалить и так далее, залить, например, свой...
2919.40 2922.76 "Анатолий Кулаков" залить этот бранч на какую-то систему автоматизации.
2922.76 2940.44 "Анатолий Кулаков" Если мы говорим о документообороте, то вы вполне можете залить это на свой CI-сервер, отрендерить эти документы в какой-то уже понятный формат, в PDF или в HTML, и развернуть документацию, допустим, для вычитки каким-нибудь специальным QA, который вычитывает документацию.
2940.44 2944.32 "Анатолий Кулаков" То есть вы просто можете работать с этим, как с обычным кодом, с документами.
2944.32 2949.64 "Анатолий Кулаков" С документами, с графиками, с какими-то спецификациями, с описаниями контрактов и так далее.
2949.64 2953.32 "Анатолий Кулаков" В общем, все это вам позволяет делать вот этот прекрасный движок.
2953.32 2956.00 "Анатолий Кулаков" Немножко о поддерживаемых типах диаграмм.
2956.00 2959.40 "Анатолий Кулаков" Их на самом деле много, я назову вот самые, наверное, популярные.
2959.40 2961.04 "Анатолий Кулаков" Прежде всего, это Flowchart.
2961.04 2972.00 "Анатолий Кулаков" Это способ, с помощью которого вы можете описывать какие-то графы, направленные, ненаправленные, блок-схемы, какие-то любые фигурки, какие-то стрелочки, линиями, как-то их соединять.
2972.00 2978.32 "Анатолий Кулаков" В общем, все вот эти блок-схемы, графы, которые вы можете видеть, вы можете их описать в виде простого, понятного текстового синтаксиса.
2978.32 2982.76 "Анатолий Кулаков" И уже сам движок отрендерит этого в красивые-красивые картинки.
2982.76 2985.00 "Анатолий Кулаков" Картинки можно рендерить абсолютно любого формата.
2985.00 2988.84 "Анатолий Кулаков" Там PNG, SVG, в общем, во все, что вам удобно.
2988.84 2991.32 "Анатолий Кулаков" В любом размере, в любом качестве расширения.
2991.32 2994.40 "Анатолий Кулаков" Настраиваемо, красиво, с темами и так далее.
2994.40 2996.76 "Анатолий Кулаков" Соответственно, еще популярная штука - это Sequence Diagram.
2996.76 2999.44 "Анатолий Кулаков" Это, наверное, самые популярные диаграммы, которые я использую.
2999.44 3008.48 "Анатолий Кулаков" Они очень удобны, когда вам нужно показать какое-то взаимодействие между различными элементами вашей системы.
3008.48 3015.08 "Анатолий Кулаков" Например, когда запрос пошел к одному сервису, вернулся от другого, принял данные от третьего, скомбанил это все в четвертом и отостал пятым.
3015.08 3018.04 "Анатолий Кулаков" Вот это шикарно рисуется в Sequence Diagram.
3018.04 3025.80 "Анатолий Кулаков" Круговые диаграммы, вот эти пироговые, pipe chart, можно их назвать пироговым диаграммом, правильно?
3025.80 3027.80 "Анатолий Кулаков" Ну, когда вы пирог захотите сделать.
3027.80 3030.60 "Анатолий Кулаков" Соответственно, очень тоже нужная в природе вещь.
3030.60 3034.72 "Анатолий Кулаков" Очень часто бывает полезно показать какие-то относительные цифры на основании ее.
3034.72 3036.92 "Анатолий Кулаков" Диаграммы Ганта тоже поддерживаются.
3036.92 3042.60 "Анатолий Кулаков" Класс диаграммы - это штука, которая больше близка людям из UML.
3042.60 3049.24 "Анатолий Кулаков" Там можно расписать классики, какие у них есть атрибуты, какие взаимосвязи между этими классиками и прочие вот эти вещи.
3049.24 3054.44 "Анатолий Кулаков" Интересная новинка, которая недавно появилась, сейчас является в экспериментальной версии - это гид граф.
3054.44 3063.00 "Анатолий Кулаков" То есть вы можете нарисовать вот эти красивые точечки с бранчами, с коммитами, с мержами, с pull-request'ами и показать вот их так наглядно и красивенько.
3063.00 3065.32 "Анатолий Кулаков" Вот это то, что первое бросается в глаза.
3065.32 3067.48 "Анатолий Кулаков" На самом деле там диаграмм немножко больше.
3067.48 3075.60 "Анатолий Кулаков" И, в принципе, одна из самых главных фишек именно вот этого движка в том, что все диаграммки более-менее нормальные, красивые.
3075.60 3078.48 "Анатолий Кулаков" То есть на них можно смотреть и при этом не плеваться.
3078.48 3086.88 "Анатолий Кулаков" Поэтому, выучив довольно несложный синтаксис, вы получаете довольно прилично сделанные красивые диаграммки, которые можете интегрировать абсолютно куда угодно.
3086.88 3092.44 "Анатолий Кулаков" Кстати, интеграция - это еще одна из самых крутейших фишек, которые есть у Меймода.
3092.44 3097.36 "Анатолий Кулаков" Потому что интегрироваться он может просто в огромное число всего.
3097.36 3099.40 "Анатолий Кулаков" Прежде всего, это Live Editor.
3099.40 3104.76 "Анатолий Кулаков" То есть вы прямо в браузере можете открыть специальный редактор, внутри которого начать писать этим синтаксисом.
3104.76 3107.68 "Анатолий Кулаков" И он у вас в реальном времени будет рендерить какой-то там превью.
3107.68 3112.52 "Анатолий Кулаков" Опять же, вы из него сможете там заэкспортить, вставить, сохранить, копировать, расшарить - все это есть.
3112.52 3118.76 "Анатолий Кулаков" Но интересна именно интеграция этого движка с остальными системами, где есть вообще текст, документация, графика.
3118.76 3127.48 "Анатолий Кулаков" Например, прежде всего, нативная поддержка есть у GitLab, который прямо в своей документации позволяет вам наряду с Markdown вставлять вот эти графики.
3127.48 3132.56 "Анатолий Кулаков" У Azure DevOps он тоже поддерживает в своей Wiki эти графики.
3132.56 3135.04 "Анатолий Кулаков" Для этого ничего вам ставить не надо, никаких сторонних плугинов.
3135.04 3137.52 "Анатолий Кулаков" Интересен еще Rider, он тоже не прошел мимо.
3137.52 3139.16 "Анатолий Кулаков" Прямо нативная поддержка в Rider.
3139.16 3141.36 "Анатолий Кулаков" Ставите одну галочку просто в настройках и все.
3141.36 3145.12 "Анатолий Кулаков" И у вас все RedMesh-ки рендерятся с поддержкой красивых графиков.
3145.12 3160.96 "Анатолий Кулаков" Огромное число блогов, CMS-ок, Wiki, из IDE-шек еще важно упомянуть WaysCode, Sublime, Vim, Emacs - все, что вам может прийти в голову, абсолютно все интегрируется и показывает там красивые графики.
3160.96 3180.32 "Анатолий Кулаков" Для самых больших извращенцев, которые хотят поддерживать эти красивые графики даже в тех местах, где их не поддерживает основной сайт или основной движок, есть расширение для браузера, который перехватывает страничку, ищет специальную разметку и заменяет эту разметку с помощью уже отрендеренных красивых диаграммочек.
3180.32 3192.00 "Анатолий Кулаков" Такой замечательный движок, опять же его прелесть в том, что есть большинство необходимых диаграмм, они красивенькие, они довольно быстренькие и у него шикарная интеграция просто со всем подряд.
3192.00 3200.48 "Анатолий Кулаков" Минусы, наверное, можно назвать у него то, что не все диаграммы, которые существуют в мире, им поддерживаются.
3200.48 3210.40 "Анатолий Кулаков" Это довольно свежий движок, довольно хипстерский, поэтому всякие страшные вещи типа UML и всего его множества многообразия он не поддерживает.
3210.40 3215.04 "Анатолий Кулаков" В таких случаях, может быть, вам придется свалиться в такую штуку, которая называется PlantUML.
3215.04 3225.68 "Анатолий Кулаков" PlantUML - это такой самый большой, наверное, самый навороченный, самый раскачанный, самый крутой в плане поддерживаемости различных диаграммок движок.
3225.68 3227.64 "Анатолий Кулаков" Сейчас он поддерживает весь набор UML.
3227.64 3232.28 "Анатолий Кулаков" В общем, много-много всего я не буду перечислять.
3232.28 3237.84 "Анатолий Кулаков" Из тех, что мне необходимо было и я пользовался, это MindMaps, к сожалению, их до сих пор в Мермель не завезли.
3237.84 3242.72 "Анатолий Кулаков" И можно рисовать простенькие формочки прямо в виде Markdown.
3242.72 3251.12 "Анатолий Кулаков" Вы пишете, описываете формочку, там буквально три кнопочки, один чекбоксик и пять выпадающих списочков, тоже более или менее прилично работает.
3251.12 3262.72 "Анатолий Кулаков" Из критических проблем - это в том, что он отвратительно ужасен, то есть те диаграммы, которые он генерирует, у них интерфейс просто убогий, очень убогий, просто мега убогий.
3262.72 3269.08 "Анатолий Кулаков" Ну и он написан на Java, поэтому никаких легковесных и красивых и быстрых интеграций вы мечтать уже больше не можете.
3269.08 3273.88 "Анатолий Кулаков" Но если вам вдруг нужно, то вот такой fallback план есть.
3273.88 3277.04 "Анатолий Кулаков" Кажется, это все, что у нас есть по диаграммкам.
3277.04 3287.16 "Игорь Лабутин" Да, кроме одной штуки, как ты указывал, в том, что с кем кто умеет интегрироваться, про PlantQML особо не знаю, почти не пользовался.
3287.16 3306.48 "Игорь Лабутин" Про MermelJS действительно в Azure DevOps пользовался чуток, в Writer пользуюсь, и сейчас появилась issue, сейчас это вот за четыре дня до того, как мы пишем этот подкаст, появилась issue в roadmap GitHub'a про то, что они собираются это поддержать в самом GitHub'е в течение Q1 этого года.
3306.48 3313.36 "Игорь Лабутин" Так что, может быть, через пару-тройку месяцев мы увидим нативную поддержку MermelJS прямо в GitHub'е.
3313.36 3321.36 "Анатолий Кулаков" Вот это прекрасная штука, потому что сейчас в GitHub'е, к сожалению, никаких векторных вот таких понятных красивых диаграмм их нет.
3321.36 3333.20 "Анатолий Кулаков" Поэтому люди извращаются, они это рендерят как-то в SVG, потом каким-то образом вставляют, но это опять же лишние шаги, лишние экшены, и это все не очень нативно, не очень прекрасно.
3333.20 3344.44 "Анатолий Кулаков" А вот если вы прямо в своем Redmi научитесь рендерить разметку именно текстовых диаграмм, то и редмишки станут красивыми, и более понятными, и более наглядными, это прекрасно.
3344.44 3361.24 "Анатолий Кулаков" Я, в принципе, один из тех человек, которые где-то пару лет назад сам на GitHub писал и голосовал за issue, чтобы они добавили вот движок Mermaid в их экосистему, и вот, наконец-то, наконец-то GitHub разродился, надеюсь, что мы увидим такую замечательную и давно уже необходимую
3361.24 3369.00 "Игорь Лабутин" штуку. Она лежит в roadmap, roadmap, как известно, не гарантия того, что это будет сделано, но будем надеяться.
3369.00 3376.48 "Игорь Лабутин" Пойдем дальше, раз мы затронули уже такие не совсем прямо темы, относящиеся к коду, есть у нас еще одна, последняя.
3376.48 3387.36 "Игорь Лабутин" Это про Identity Server или Duende Server, который, как мы знаем, переименовали какое-то время назад, когда он отделился и стал коммерческим.
3387.36 3393.32 "Игорь Лабутин" Мы помним эту историю, я надеюсь, про то, что у нас был халявный Identity Server, который можно был использовать всем, кому не попадя.
3393.32 3416.36 "Игорь Лабутин" Четвертая версия, но в какой-то момент авторы сказали, что что-то как-то, тратим мы на него много времени, хотим сделать это дело основным источником дохода, организовали компанию, и, соответственно, начиная с пятой версии, Identity Server — это платная штука, если вы компания, у которой достаточно большой доход, назовем это так, или оборот, не помню уж там.
3416.36 3419.92 "Игорь Лабутин" Но, в общем, на сайте читайте, там все точно написано.
3419.92 3430.76 "Игорь Лабутин" И это самоизменение лицензии, оно происходило, нам казалось, что оно просто произошло и произошло, но оно, по факту, это было запланировано сделать это в три шага.
3430.76 3434.60 "Игорь Лабутин" Ну, или по крайней мере, авторы утверждают, что так и было запланировано.
3434.60 3446.16 "Игорь Лабутин" Для начала они, как я сказал, постановили, что все, теперь Identity Server не является бесплатным для продакшена, и нужно за него платить.
3446.16 3472.76 "Игорь Лабутин" Соответственно, как только они поняли, что, ну, в принципе, кажется, это работает, и есть те, кто готов платить, то, соответственно, если вы являетесь компанией, которая зарабатывает меньше миллиона долларов в год, то, соответственно, вам доступен так называемый Community Edition, который является несколько урезанной версией, и при этом позволяет, ну, как бы воспользоваться практически всеми фичами.
3472.76 3488.28 "Игорь Лабутин" Но практически всеми фичами, потому что набор фич был практически идентичен тому, что предоставлял Identity Server 4, там с небольшими фиксами и изменениями, но все те новые штуки, которые завезли в Identity Server 5, точнее в дуэнде, 5, они были недоступны.
3488.28 3494.84 "Анатолий Кулаков" А у тебя примерно есть список, что там в 5 такого нужного для всех необходимых, чего нет в 4?
3494.84 3512.24 "Игорь Лабутин" Ну, насколько я смотрю, там появился автоматический менеджмент ключиков, то есть, если мы помним, в 4 нужно было указать ключики, ну, сертификаты, да, или ключи, которыми подписываются токены и так далее, и там не было функции какого-то автоматического роллинга этих ключей и так далее.
3512.24 3514.60 "Игорь Лабутин" Вот они это все появились, это все появилось.
3514.60 3516.96 "Игорь Лабутин" Да, это полезная штука, да.
3516.96 3533.92 "Игорь Лабутин" Потом у них еще было какие-то изменения про мультитенантность, то есть изоляцию, так скажем, каких-то ресурсов, я вот сейчас не вспомню, что они там точно дописывали, смотрю просто сейчас табличку сравнения на самом деле всяких edition.
3533.92 3568.96 "Анатолий Кулаков" Ну, для тех, кто если не пользовался DTT сервисом, то можно честно сказать, что это мега крутой комбайн, он умеет и поддерживает кучу всего, это очень много сложных протоколов, это очень много крутых интеграций, в том числе с S/P/NET, это там нарисованная прекрасная там всякая UI, каст защиты, очень много проработанной темы с помощью Security и очень много проработано бесшовной, красивой, очень гладкой интеграции, то есть буквально нужно написать там две строчки и получить там безумно мощную систему, мощный комбайн, который позволяет накрыть огромное число запросов.
3568.96 3580.00 "Анатолий Кулаков" Ну, то есть, когда эта штука потребовала каких-то денег, когда она перешла в платный сервис, это наверное первый раз, когда я не осудил приложение, которое вдруг было бесплатным, а потом стало платным.
3580.00 3585.72 "Анатолий Кулаков" В общем, это действительно такая работа огромная проделана, то огромное спасибо ребятам, что они вообще это делали.
3585.72 3604.44 "Игорь Лабутин" Да, так вот ты прав, что оно действительно прям бесшовно и довольно круто поддерживал очень много всяких фич, но на самом деле не все, то есть, например, если у тебя был какой-нибудь там, не знаю, фронтенд, и тебе хотелось написать какую-то авторизацию в нем через там authorization code, по-моему, да, flow, то тебе нужен какой-то бэкэнд.
3604.44 3624.24 "Игорь Лабутин" Возможно, у тебя даже есть какой-то бэкэнд, но тебе нужно было там выставлять некоторое количество специальных endpoints, они, конечно, выставляются там в пару строчек, но все же, все-таки, они, соответственно, вот еще одна штука, которую они сделали, они сделали специальную bff-хостинг-лайбер, то есть библиотечку, которая автоматически предоставляет бэкэнд на фронтенд именно для сингл-пэйдж-аппликационов.
3624.24 3637.76 "Игорь Лабутин" Ну и вот такие штуки, которые более удобно позволяют им пользоваться, то есть динамическая загрузка внешних всяких провайдеров, которые вы, возможно, используете, ну и так далее.
3637.76 3643.20 "Игорь Лабутин" То есть много-много-много разных таких мелочей, которые улучшают юзабельность этой штуки.
3643.20 3644.20 "Игорь Лабутин" Вот.
3644.20 3648.20 "Игорь Лабутин" Они были недоступны в комьюнити-эдишн, и доступны, соответственно, в платной версии.
3648.20 3660.48 "Игорь Лабутин" Так вот, новость состоит в том, что это дело прожило год, и у них появилась статистика, сколько, собственно, у них получилось платных лицензий, и сколько получилось бесплатных лицензий, которые они раздали.
3660.48 3664.24 "Анатолий Кулаков" Только не говори, что платных они не собирали и решили вообще закрыться.
3664.24 3666.56 "Игорь Лабутин" Нет, они насобирали их одинаковое количество.
3666.56 3672.64 "Игорь Лабутин" То есть половина лицензий, которые у них сейчас выданы за вот этот последний год, это платные лицензии, половина это бесплатные.
3672.64 3677.56 "Анатолий Кулаков" Я не пойму, или бесплатных так мало, или платных так много, что-то у меня в голове не сходится.
3677.56 3680.28 "Анатолий Кулаков" Каким это образом может и бесплатных, и платных быть одинаково?
3680.28 3683.24 "Анатолий Кулаков" Тем более, что цены у них не такие уж и гуманные на платной версии.
3683.24 3700.84 "Игорь Лабутин" Ну вот, значит, достаточное количество больших компаний решило правильно, решило заплатить им, но при этом есть и маленькие компании, которые продолжают пользоваться и получают тем самым, смогли получить ту самую Community Edition, подтвердив, что у них доход не очень большой за год.
3700.84 3726.36 "Игорь Лабутин" В результате они сказали следующее, что мы поняли, что собственно год, ну, собственно прошел год, все живет как хотелось, мы вполне получаем достаточно много денег за платные лицензии, и поэтому сейчас вот они готовят к выпуску шестую версию Identity Server, который вот-вот-вот скоро выйдет, и в нем будет одно важное изменение.
3726.36 3738.28 "Игорь Лабутин" В Community Edition, который соответственно будет все так же бесплатен для компаний, у которых оборот за год составляет меньше миллиона долларов, будут абсолютно все те фичи, которые сейчас есть в Enterprise Edition.
3738.28 3740.96 "Игорь Лабутин" Шикарная новость, прекрасно, вот то, что надо, ура!
3740.96 3763.28 "Игорь Лабутин" То есть, если вы небольшая компания, которая хочет продолжать использовать Identity Server, то вы сможете вообще заюзать все то, что вы сейчас видите на вкладочках, Enterprise, либо как у них там называется, по-моему, Standard, а нет, Business Edition и Enterprise Edition, все эти фичи будут вам доступны в шестой версии, которые будут соответственно видимо на DotA 6 там ориентироваться еще больше, использовать всякие фичи, ну и так далее.
3763.28 3779.32 "Анатолий Кулаков" Ну что, спасибо большим богатым компаниям за то, что они как бы поддержали таких крыловатых ребят, такой прекрасный проект, и за то, что дали нам, обычным нищебродам, поработать за качественным продуктом и не городить, опять же, свои костыли, которые привели бы к большим проблемам, чем вот использование Community Edition.
3779.32 3809.56 "Игорь Лабутин" Да, и они это называют Fair Trade Software License, и на самом деле был некоторый такой, ну не тренд, а такая движуха в Твиттере на предмет того, что вообще говоря, кажется, что это один из самых, может быть, разумных способов к тому, как вообще поддерживать Open Source и вообще монетизировать это все вокруг, то есть собирать деньги с очень больших компаний, которым это будет стоить не так много, но за счет этого давать возможность пользоваться всем остальным маленьким.
3809.56 3823.00 "Анатолий Кулаков" Ну да, но чтобы на такой рынок выйти, тебе действительно нужно было до этого 10 лет пахать, забесплатно практически раздавать свой сервис всем подряд и делать его лучшим решением в мире, и при этом все это делать на халяву.
3823.00 3825.00 "Анатолий Кулаков" Вот тогда действительно это может выстроиться.
3825.00 3837.72 "Игорь Лабутин" Ну, в общем, посмотрим, как это будет жить дальше, посмотрим, что они скажут еще через годик, посмотрим, может быть, будет еще некоторое количество проектов, которые последуют такому же принципу, но будем следить.
3837.72 3844.56 "Анатолий Кулаков" Хорошая практика, как всегда, пожелаем авторам удачи, отличный сервис и успехов им на этом непростом поприще.
3844.56 3847.64 "Игорь Лабутин" Ну что, надо завершаться на сегодня или у нас есть
3847.64 3863.84 "Анатолий Кулаков" еще что-нибудь? Давай немножко пробежимся по подкастам, мы за эти новогодние праздники что-то там послушали, если честно, то не было прям таких шикарных, больших, много интересных выпусков, но несколько самородков нашлось, и вот мы спешим вам их порекомендовать.
3863.84 3866.68 "Анатолий Кулаков" Прежде всего, подлодка 243, айти в кино.
3866.68 3870.96 "Анатолий Кулаков" Это подкаст с Романом Беловым.
3870.96 3881.44 "Анатолий Кулаков" Роман известен очень многим людям, которые с ранних лет увлекаются дотнетом, он работает в JetBrains и раньше работал над именно дотнет направлением.
3881.44 3887.04 "Анатолий Кулаков" Сейчас он работает в других направлениях, но не суть важно, а меня поразило больше всего это его хобби.
3887.04 3897.56 "Анатолий Кулаков" Оказывается, Роман очень плотно связан с голливудскими компаниями, да вообще с компаниями российскими в том числе, и очень сильно погружен в фильмы производства.
3897.56 3907.64 "Анатолий Кулаков" Он очень круто разбирается в спецэффектах и пишет инструмент, который используется во многих фильмах, во многих мировых фильмах.
3907.64 3936.40 "Анатолий Кулаков" В общем, этот инструмент как раз для трекинга всяких объектов, и поэтому он знает, как эффекты работают, какие студии их применяют, как делаются различные интересные хаки для фильмов, очень много баек, историй про актеров, про различные интересные решения в киноиндустрии, в общем, все то, что Роман поведал за этот там огромный действительно выпуск по меркам этого подкаста.
3936.40 3962.44 "Анатолий Кулаков" В общем, я прослушал на одном дыхании, просто не прерываясь и на секунду, такие очень много интересных историй, очень много интересных вещей открылось вообще о том, как это все снимается, как это все делается, как производятся фильмы, каким образом визуальные эффекты влияют на них и вообще где разрабатывается, как применяются визуальные эффекты, что для этого нужно сделать, чтобы построить качественный конкурентный продукт на этом поприще.
3962.44 3980.92 "Анатолий Кулаков" В общем, казалось бы, что такая индустрия довольно отсталая, потому что мы практически ничего о ней не слышим, практически ничего о ней не знаем, по крайней мере, в нашем кругозоре, на наших конференциях, но там творятся абсолютно безумные и прекрасные вещи.
3980.92 3990.12 "Игорь Лабутин" Да, и продолжая тему подлодки, хочу сказать, что «Айти в кино» действительно шикарный выпуск, я его прослушал практически всей семьей вместе с детьми, мне тоже было интересно.
3990.12 3998.32 "Игорь Лабутин" Следующий выпуск, который я тоже хотел бы сказать, это 245-й, чуть-чуть позднее у них вышел, про ADE-шки.
3998.32 4013.08 "Игорь Лабутин" Все наверняка слышали про JetBrains Fleet, ну или не слышали, а может быть как-то знаете теперь, что вот есть такая JetBrains Fleet, она находится в каком-то довольно раннем превью, насколько я понимаю, но это взгляд JetBrains на то, как должна выглядеть современная ADE.
4013.08 4058.32 "Игорь Лабутин" И вот в 245-й выпуск пришел как раз Максим Шафиров, который много что знает про JetBrains, и это был не рассказ про Fleet, это был рассказ про то, что такое вообще ADE в современном мире, как на это можно смотреть, как вообще туда вписывается все то, что делает JetBrains, включая весь Remote Development, то есть JetBrains, как известно, JetBrains 3, ну не назвать продукта, но что-то похожее на продукт, это Projector, Gateway и Fleet, и вот как это все связывается вместе, как это все влияет на разработку и вообще какой взгляд у, по крайней мере личного Максима, на состояние дел в современном разработке ADE-шек, очень тоже рекомендую послушать, прям довольно такой цельный взгляд на то, что там происходит.
4058.32 4069.44 "Анатолий Кулаков" Ну и Максим всегда прекрасно рассказывает, его удобно слушать и классно слушать абсолютно на любую тему, на любых лекциях, на любых выступлениях, поэтому тоже обратите внимание.
4069.44 4089.00 "Анатолий Кулаков" А про Fleet тут хочется сказать, что мы про нее в нашем подкасте не говорили по одной простой причине, что там .NET как всегда обделен, .NET пока нет, но по инсайдерской информации мы не скажем от кого, мы знаем, что .NET туда добавляется, .NET там скоро будет, и как только он будет, мы обязательно подробнее вам расскажем, что это такое, зачем она нужна и с чем ее ведет.
4089.00 4091.96 "Игорь Лабутин" А пока не трогайте его, там нет .NET.
4091.96 4154.88 "Игорь Лабутин" Последний подкаст, который я, выпуск точнее, который я хотел бы порекомендовать, называется подкаст "Новый подкаст 2" после правок FinalDoc, если вы хотите его найти, ссылка будет конечно в описании, и подкаст, ну он такого стиля, больше разбора полетов, если вы знаете о чем я, но конкретно один выпуск называется "Стартапы инвестиций", где приглашенным гостем был Леонид Игольник, и если вам интересно знать вообще что такое стартапы, вам интересно знать всю эту терминологию про то, что такое раунд инвестиций, как там, если вы вдруг стали инвестором стартапа, когда вам положены акции, и когда вы вернете свои деньги, или что будет если вы их не вернете, то вот берете этот выпуск, слушайте от начала и до конца, там нон-стоп история, то есть без практически каких-то отвлеченных разговоров, от начала до конца, как живет стартап, когда к нему приходят деньги, когда от него деньги уходят, и что делать основателям, что делать когда появляется совет директоров, ну и так далее, и так далее, и так далее.
4154.88 4158.04 "Анатолий Кулаков" Ты выяснил как из нашего подкаста сделать стартап, чтобы к нам пришли деньги?
4158.04 4163.20 "Игорь Лабутин" Ну там нужно family, friends and fools, как обычно для первых денег.
4163.20 4165.04 "Игорь Лабутин" Это у нас уже есть.
4165.04 4172.00 "Игорь Лабутин" Ну не знаю, возможно нам чего-то недостаточно, вот идея, идея нужна, как же мы будем эти деньги возвращать
4172.00 4175.24 "Анатолий Кулаков" обратно? А их еще возвращать надо, не-не, тогда отказать.
4175.24 4176.24 "Анатолий Кулаков" Да вообще.
4176.24 4178.44 "Анатолий Кулаков" Ну что ж, на этой посидевной ноте, друзья, давайте закругляться.
4178.44 4201.52 "Игорь Лабутин" Да, мы сегодня посмотрели на Visual Studio 2022-17.1 Preview 2, что там появилось новенького, вспомнили про .NET Standard, который еще не совсем помер окончательно, узнали, что вышла 11 превьюшка .NET MAUI, и она потихонечку движется к релизу, но пока очень потихонечку, и пока не видно, чтобы там что-то финализировалось-финализировалось.
4201.52 4208.00 "Игорь Лабутин" Посмотрели на медиатор и как он соотносится с паттерном CQRS, надо ли или не надо его использовать.
4208.00 4215.28 "Игорь Лабутин" Узнали, что в .NET 6 сильно заоптимизировали Garbage Collector, или по крайней мере он стал работать эффективнее для определенного вида приложений.
4215.28 4225.44 "Игорь Лабутин" Толи нам рассказал, как прекрасно можно рисовать диаграммки прямо в коде или в документах с помощью Mermaid или PlantUML.
4225.44 4240.36 "Игорь Лабутин" Ну и узнали, что Duende или Identity Server прекрасно себя чувствует в формате новой коммерческой кампании, и то, что начиная с 6 версии, комьюнити лицензия, которая бесплатная, будет задержать полноценный набор фич, такой же как Enterprise версия.
4240.36 4245.80 "Анатолий Кулаков" Ну а также поделились с вами выпусками, которые мы подслушали за эти дни.
4245.80 4246.80 "Игорь Лабутин" Это точно.
4246.80 4252.52 "Игорь Лабутин" И это был 44-й выпуск Radio.NET, с вами были Игорь Лабутин и Анатолий Кулаков, всем счастливо.
4252.52 4252.92 "Анатолий Кулаков" Пока.
4252.92 4266.28 "Анатолий Кулаков" *музыка*
