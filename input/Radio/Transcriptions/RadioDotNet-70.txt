0.00 11.20 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет выпуск номер 70.
11.20 13.96 "Анатолий Кулаков" И сегодня в эфире Анатолий Кулаков.
13.96 15.16 "Игорь Лабутин" И Игорь Лабутин.
15.16 16.16 "Игорь Лабутин" Всем привет.
16.16 26.36 "Анатолий Кулаков" И большое спасибо всем нашим помогаторам, и в частности Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Илья, Гурий Самарин, Виктор, Руслан Артамонов.
26.36 37.40 "Анатолий Кулаков" Спасибо, друзья, а также всем, кто шарит, репостит и всячески поддерживает наш подкаст и помогает распространиться в этом мире как можно больше, дальше и сильнее.
37.40 44.20 "Анатолий Кулаков" Так, наконец-то и в нашем северном Санкт-Петербурге наступила весна, прям долгожданная.
44.20 49.28 "Анатолий Кулаков" Тут у нас сугробы лежали до последнего момента, льды лежали, и наконец-то все начало таять.
49.28 55.48 "Анатолий Кулаков" Не поверите, небо поголубело, птички прилетели, почек еще правда нет, но лед уже начал таять.
55.48 59.08 "Анатолий Кулаков" Поэтому настроение прекрасное, новости тоже отличные.
59.08 65.36 "Анатолий Кулаков" Пора пробежаться, посмотреть, что же нам приготовили Microsoft, компания и другие интересные разработчики.
65.36 82.20 "Игорь Лабутин" Да, начнем мы традиционно с DotNet 8, вышел превью номер 3, и в нем на самом деле с одной стороны вроде как не очень много изменений, с другой стороны они довольно-таки важные, и которые могут вас затронуть.
82.20 83.64 "Игорь Лабутин" Поэтому давайте пробежимся.
83.64 99.60 "Игорь Лабутин" Во-первых, поддерживаем эту штуку в Visual Studio 17.6 превью 3, и в статье с выходом нового превью DotNet, Microsoft прям явно написала, что Visual Studio 4 Mac пока никак 8-ку не поддерживает, поэтому мол, на маке только если коммандлайном использовать.
99.60 103.60 "Игорь Лабутин" А на винде можно использовать на превьюшку третью.
103.60 105.76 "Анатолий Кулаков" Слушай, интересно, а как там студия должна поддержать?
105.76 108.40 "Анатолий Кулаков" Ну там по идее компилятор же и все.
108.40 112.88 "Анатолий Кулаков" Ростлин поддерживает, компилятор поддерживает, подсветку синтезиса наверняка можно из компилятора вытащить.
112.88 117.64 "Анатолий Кулаков" Почему не все время такое разъезжание, как будто надо полстудии переписать?
117.64 132.96 "Игорь Лабутин" Потому что, во-первых, там есть некоторые, ну, наверное, во-первых, там есть какая-то своя, не знаю, копия Ростлина условно, которая там как-то работает по-своему, не знаю точно, как там студия, она же не все из SDK берет, она же с собой ставит свою собственную SDK.
132.96 147.04 "Игорь Лабутин" А во-вторых, я так понимаю, что есть некоторые изменения в DotNet, которые могут, например, потребовать каких-нибудь доп. опций, потому что бывают всякие штуки, ну вот мы обсуждали там в прошлый раз, какие-нибудь там контейнеры или еще что-то в таком духе.
147.04 152.44 "Игорь Лабутин" И я периодически рассказываю, и ты тоже, что вот так надо пойти в настройки и включить экспериментальную опцию.
152.44 155.12 "Игорь Лабутин" Ну вот поэтому и они и те самые.
155.12 162.08 "Анатолий Кулаков" Ну, наверное, просто мне кажется таких ситуаций не так уж часто, не так уж много, а маковская отстает почти всегда.
162.08 168.24 "Игорь Лабутин" Ну, возможно, маковская не так легко может на самом деле выдернуть всякие диагностики из компилятора, командлайн его.
168.24 169.80 "Анатолий Кулаков" Может быть, может быть.
169.80 171.76 "Анатолий Кулаков" Ну ладно, давай расскажи, что там интересненького
171.76 178.36 "Игорь Лабутин" нас ждет. Интересненького нас ждет следующее, прям, так сказать, попирание устоев и вот этого всего.
178.36 182.88 "Игорь Лабутин" Называется feature simplified output path.
182.88 189.64 "Игорь Лабутин" Мы все, которые разрабатывают DotNet, конечно же знаем три волшебных папочки, bin, obs, ну и publish, да, в последнее время.
189.64 196.80 "Анатолий Кулаков" Ну, publish это вообще прям для хипстеров, ты чего, bin, obs, она по-моему там чуть ли не со времен C++, Delphi и так далее.
196.80 210.00 "Игорь Лабутин" Ну вот про C++ не уверен, там, ну да, наверное, наверное, я прав, obs, obs по крайней мере там точно был, да, куда же складывались всякие объектники, а потом все собираемся в финальный .exe либо lib, но тем не менее.
210.00 215.96 "Игорь Лабутин" Короче, есть bin, obs и иногда publish, по дефолту они, естественно, живут в каждом проекте свои.
215.96 228.56 "Игорь Лабутин" Некоторые проекты настраивают иногда то, что называется single output, то есть на уровень солюшена выносят настройки общего аутпута, по крайней мере, bin, да, чтобы итоговый проект полностью собирался в единую директорию.
228.56 235.88 "Анатолий Кулаков" Ну, итоговый, но не все либо писали бы в одну папку, тогда они будут перетирать библиотеки друг друга, это может быть ад.
235.88 251.08 "Игорь Лабутин" Ну, тем не менее, то есть у нас был на самом деле проект, где мы obs файлы не трогали, obs папочки, а вот bin папочки в каждом CSS Project настраивался так, что они все пишут единый bin там, релиз или bin debug на уровне солюшена.
251.08 270.80 "Анатолий Кулаков" Да, да, у меня тоже такие проекты были, но мне кажется, что-то мы в последнее время их не используем, то есть я не сталкивался, по крайней мере, именно из-за того, что непонятно, что, смотря какую ты первую сборку билдишь, какой первый проект билдишь, как бы тот и проиграет, то есть последний всегда перепишет, твои длельки, если они вдруг так же назывались, но просто другой версией.
270.80 273.28 "Анатолий Кулаков" В общем, это такая опасная игра, удобно, условно.
273.28 285.20 "Игорь Лабутин" Да, это нужно было использовать вместе с вот этим подходом про центральное версионирование всех пакетов, чтобы действительно не получалось в разных проектах ссылки на разные версии там какого-нибудь ньютон софта или еще чего-нибудь.
285.20 291.20 "Игорь Лабутин" Да, там были свои проблемы, были свои, значит, трудности и тонкости, но и удобство было, но…
291.20 294.64 "Анатолий Кулаков" И параллельный билд, как ты запустишь параллельный билд на нескольких проектах?
294.64 296.68 "Игорь Лабутин" Ну он параллельно будет писать.
296.68 297.68 "Игорь Лабутин" Ну хорошо, допустим.
297.68 298.68 "Игорь Лабутин" Перетирать.
298.68 314.68 "Игорь Лабутин" Так вот, Microsoft утверждает, что был у них довольно много фидбэка от пользователей про то, что такая структура, вот как мы описали, да, bin/obsh в каждом проектном, в каждой папочке, да, ну там везде где CS Project лежат.
314.68 315.96 "Игорь Лабутин" Это не очень удобно.
315.96 318.72 "Игорь Лабутин" Эээ, так наши деды писали, вы чего?
318.72 320.72 "Игорь Лабутин" Так вот, почему?
320.72 338.28 "Игорь Лабутин" Значит, один аргумент звучит в статье так, что даже какие-то очень небольшие изменения в MS Build скриптах, ну то есть типа ты там меняешь какую-нибудь пропертии где-нибудь, я не знаю, что они подразумевают, в статье буквально это называется simple changes in MS Build, не знаю, что это такое, но тем не менее.
338.28 339.28 "Игорь Лабутин" В MS Build файлах?
339.28 344.88 "Игорь Лабутин" Может, типа, сильно изменить структуру вот этого layout выходного.
344.88 348.88 "Игорь Лабутин" Ты же не забывай, bin/obsh, это все хорошо, это две рутовые папочки, а что внутри творится?
348.88 351.28 "Игорь Лабутин" Ну да, внутри там полная магия.
351.28 370.80 "Игорь Лабутин" То есть внутри там создаются директории под каждую платформу, под каждой, если вы собираете какое-нибудь, например, на ETIFA от приложения, ну или просто старкетите конкретную платформу, там же будут еще так называемые runtime identifiers использоваться, то есть у вас в итоге будет какой-нибудь там bin/linux/x64 что-нибудь там релиз, да?
370.80 371.80 "Игорь Лабутин" Как-то так.
371.80 387.16 "Игорь Лабутин" Вот это все очень неудобно, а второе, что поскольку это все на каждый проект делается, плюс вот эта вот вся огромная иерархия папочек внутри, это гораздо сложнее для стороннего тулинга.
387.16 397.16 "Игорь Лабутин" То есть если вы хотите написать какой-нибудь тулинг, который обрабатывает там аутпуты вашего чего-нибудь, то в нем должно быть довольно много логики на тему того, где искать вообще говоря то, что собралось.
397.16 402.72 "Анатолий Кулаков" Не так уж много логики, там одна строчка на PowerShell и тебе рекурсивно обойдет все нужные.
402.72 424.52 "Игорь Лабутин" Ну рекурсивно обойдет, а если тебе нужно найти все, обработать только те аутпуты, которые для Linux, ну то есть там можно, понятно, все можно написать, может быть даже отдельной строчкой, одной строчкой с крутым регулярным выражением для поиска нужных под директорий, но опять же, я не говорю, что это неудобно, я говорю, что это фидбэк, от Microsoft, вы утверждаете, что им такой фидбэк принес.
424.52 430.56 "Игорь Лабутин" Поэтому теперь есть новая опция, которая делает следующее.
430.56 434.88 "Игорь Лабутин" Все build аутпуты будут сосредоточены в общем месте.
434.88 448.80 "Игорь Лабутин" В этом общем месте они будут разделены все еще по проектно, то есть это не единый бинт, там, да, свалка всех аутпутов, но тем не менее оно общее, но по проектно.
448.80 453.80 "Игорь Лабутин" И максимум в каждом проекте будет гарантированно не больше трех уровней вложенности папочек дальше.
453.80 456.56 "Анатолий Кулаков" О, это прям важно, да, мы экономим директории.
456.56 457.56 "Игорь Лабутин" Конечно.
457.56 458.56 "Игорь Лабутин" Значит, что сделано?
458.56 479.96 "Игорь Лабутин" Если вы в Cessproje, ой, не в Cessproje, сорян, это делается естественно на весь ваш, так сказать, продукт, да, solution, грубо говоря, поэтому в корне вашего проекта вы создаете файлик директора build.props, если вы еще его вдруг не создали, и в нем ставите опцию под названием use artifacts output в true.
479.96 489.84 "Игорь Лабутин" Кстати, я тут выяснил, только из этой статьи, я как-то раньше не знал, что можно, оказывается, выдать команду .NET new build.props, и она создаст этот файлик директора build.props.
489.84 491.28 "Игорь Лабутин" Интересно, что у него внутри будет?
491.28 496.24 "Игорь Лабутин" Пусто, скорее всего, ну просто базовая структура MSBuild, там, project и какой-нибудь там properties, тег будет стоять
496.24 500.04 "Анатолий Кулаков" дальше на кирповой проперти. То есть для того, чтобы имя было красивое, понятно,
500.04 510.52 "Игорь Лабутин" не вспоминать. Ну имя и вот это там же, там, xml namespace, нужно указать какую-нибудь такую фигню, вот это вот все, короче, я просто не знал, что можно, я обычно копировал откуда-нибудь с этого проекта, вот оказывается, можно.
510.52 518.28 "Игорь Лабутин" Ну ладно, если вы это указали, то у вас теперь, когда вы будете собирать ваш проект, будет создаваться папочка .artifacts.
518.28 519.28 "Игорь Лабутин" Да почему .то?
519.28 524.88 "Анатолий Кулаков" Ну .что ж это не по .NET, не по виндовому, это Linux,
524.88 531.12 "Игорь Лабутин" потому что Linux снял уже. Ну подожди, Visual Studio вечно хранит все свои темповые файлики в .vs.
531.12 539.32 "Анатолий Кулаков" Ну вот они как бы как настройки, вот в качестве настроек в Linux они используются, да, но как бы Visual Studio, .NET,
539.32 556.76 "Игорь Лабутин" и это все-таки настройки, это все-таки артефакты. Это будет действительно очень удобно, потому что на каком-нибудь действительно, не знаю, Macbook'е либо чем-нибудь, MacOS-е либо Linux-е, ты взял, собрал вот это все, пошел в свой там файндер, если ты на MacOS-е, я .artifacts не увидел, что это hidden папочка получается, она же с точки начинается.
556.76 559.44 "Анатолий Кулаков" Ну отлично, все артефакты, которые сбил, не увидишь.
559.44 565.20 "Игорь Лабутин" Ну да, тебе их видеть не надо, ты же их уже в облако залил, у нас же Cloud Native.
565.20 574.52 "Игорь Лабутин" Ладно, короче, на самом деле это конфигурируется, то есть можно в этом же props файле настроить опцию Artifacts Path и туда передать что угодно.
574.52 583.12 "Игорь Лабутин" И будет как хотите, хотите там build output, хотите common output, ну в общем, что хотите, то и назовите, это будет вот это имя корневой папочки.
583.12 589.52 "Игорь Лабутин" Внутри, соответственно, будет три уровня вложенности максимум.
589.52 607.16 "Игорь Лабутин" На первом уровне штука под названием type of output, и там их может быть не так много, то есть там будут как раз те, которые мы уже знаем, bin, obj, еще там может быть publish, это когда ты паблишишь приложенку, и еще там может быть package, это когда ты собираешь NuGet пакет, .net pack делаешь.
607.16 613.84 "Игорь Лабутин" То есть вот они будут раскладываться по трем разным, по четырем, точнее разным вот этим вот папочкам.
613.84 623.92 "Игорь Лабутин" Внутри этих штук может быть, соответственно, project name дальше, то есть если у вас много проектов, то дальше будет папочка под названием проекта.
623.92 633.12 "Игорь Лабутин" И последний третий компонент, это они это назвали pivot, но я вечно не люблю это слово на русском произносить, pivot, пивот.
633.12 638.88 "Анатолий Кулаков" А самое главное, что оно никак по-нормальному не переводится вместе со смыслом, который в него вкладывается.
638.88 652.76 "Игорь Лабутин" В общем, смысл здесь такой, что эта директория будет включать в себя название конфигурации вашего билда, там релиз, дебаг или как вы ее назовете, плюс платформа, target platform, плюс runtime identifier, если он есть.
652.76 654.64 "Анатолий Кулаков" То есть все засунули в название одной папочки.
654.64 671.72 "Игорь Лабутин" Ну вот у них есть примеры, то есть если у вас есть один одинокий csproj, который вы соберете просто через .net build, у вас там результат положится в .artifacts/bin/debug, а объектники, все intermediate файлики будут в .artifacts/obj/debug.
671.72 677.28 "Игорь Лабутин" Ну то есть отличаться от обычного .net build будет только тем, что это просто не в bin/debug, а в .artifacts/bin/debug.
677.28 679.56 "Игорь Лабутин" Тут вроде все как бы по-простому.
679.56 698.04 "Игорь Лабутин" Если у вас будет большой сложный проект, уже там есть несколько, например, приложений, либов и так далее, то если вы собираете, вот у вас там есть myapp, csproj такой, то его дебажная версия, которая таргетит .net 8, соберется в папочку .artifacts/bin/myapp/debug_.net8.0.
698.04 703.08 "Игорь Лабутин" Ну еще и подчеркивание, знак кейса залез.
703.08 704.76 "Игорь Лабутин" Через подчеркивание, да, знак кейса.
704.76 711.84 "Игорь Лабутин" А если ты паблишь приложение для линукса под x64, то это будет .artifacts/publish/myapp/release_linux_defice_x64.
711.84 723.56 "Игорь Лабутин" Ну потому что linux_defice_x64 это официальный runtime identifier этой платформы, соответственно, они его просто подтягивают туда.
723.56 737.04 "Анатолий Кулаков" Инфаркт миокарда можно получить вот этими naming convention, которые они справа и налево, и да, чтобы вы знали, вот дебаг, который произносил Игорь, вот она пишется не так, как сейчас, потому что сейчас дебаг и релиз папочка в ваших приложениях пишется с большой буквы, а тут ловеркейси все.
737.04 738.40 "Игорь Лабутин" А тут все будет ловеркейси, да.
738.40 741.12 "Анатолий Кулаков" Ну это же ужасно, надо менять язык.
741.12 752.92 "Игорь Лабутин" Или все переопределять, я думаю, что все можно переопределить наверняка, но ладно, посмотришь, все на msbuild сделано, скорее всего, переопределить десяток пропертей странного вида и все будет как ты хочешь.
752.92 755.08 "Анатолий Кулаков" Действительно, чем нам еще заняться по вечерам?
755.08 756.08 "Игорь Лабутин" Да.
756.08 767.48 "Игорь Лабутин" Короче, вот, это то, что с output path'ом, это пока все еще такое полуэкспериментальное, у них даже прям в статье ссылочка на сервер манки со словами типа "вам как?" Это идея.
767.48 778.00 "Игорь Лабутин" Нравится ли вам тот факт, что мы назвали дефолтную папочку .artifacts, может вы что-то еще хотите, ну в общем, явно будут ждать какого-то фидбэка от народа, посмотрим.
778.00 784.16 "Анатолий Кулаков" Мне кажется, точку они использовали для того, чтобы она всегда наверху была, это единственная причина, зачем на винде можно называть папочки с точки.
784.16 787.08 "Анатолий Кулаков" Ну а про остальных, про систему, они наверняка же не думают.
787.08 794.96 "Игорь Лабутин" Слушай, я думаю, что вторая причина, чтобы она точно не пересеклась с любой папкой, которая у тебя может быть в проекте.
794.96 802.68 "Анатолий Кулаков" Ну вот, к сожалению, я все свои папки в проекте называю точкой artifacts, куда я складываю всякие результаты паков, билдов и так далее.
802.68 805.64 "Игорь Лабутин" Вот теперь за тебя будут, так вот за тебя все будет.
805.64 810.44 "Анатолий Кулаков" Да, да, но структура-то там другая, у меня-то все поумнее, по конвенциям, по красоте.
810.44 811.68 "Анатолий Кулаков" Тут тоже конвенции, но другие.
811.68 818.12 "Игорь Лабутин" Ну и опять же, ну будет там твои папочки, еще четыре других, ну че, тебе жалко что ли?
818.12 821.64 "Анатолий Кулаков" Которые случайно могут пересечься, конечно жалко, потом богом не найдешь.
821.64 825.52 "Игорь Лабутин" Ну, переменовый, значит, у себя в artifacts 2.
825.52 838.32 "Игорь Лабутин" My artifacts, ну короче, а понятно, что они скорее всего целились, чтобы точно не совпасть с каким-нибудь нормальным названием, потому что artifacts, например, без точки практически наверняка есть в каких-нибудь проектах, ну нормальное.
838.32 845.60 "Игорь Лабутин" Угадать слово на английском в программировании, именем которого не назовут папку в исходниках, я думаю, что сложно.
845.60 846.60 "Игорь Лабутин" Это точно.
846.60 848.60 "Игорь Лабутин" Вот, поэтому буду думать.
848.60 852.76 "Игорь Лабутин" Ну и спасибо, что дали возможность переопределить сразу, в принципе, удобно.
852.76 853.76 "Игорь Лабутин" Пойдем дальше.
853.76 856.60 "Игорь Лабутин" С SDK есть еще одно изменение.
856.60 885.24 "Игорь Лабутин" Вы знаете, что мы много раз рассказывали про то, что часть SDK теперь ставится через команду dotnetworkload, то есть можно сказать dotnetworkload, он стал что-нибудь добавить, а дальше возникает, как выяснилось, я что-то не пробовал много чего ставить, но говорят, судя по статье, что у вас может возникнуть куча каких-то там, как они называют это, stale или orphaned workflows, то есть вы там что-то добавляли, какие-то апгрейды делали из SDK на минорные там security и прочие моменты.
885.24 893.44 "Игорь Лабутин" В итоге, возможно, вам может оказаться, что есть какие-то ошметки старых workload, которые больше не нужны.
893.44 912.16 "Игорь Лабутин" И теперь есть отдельная команда dotnetworkloadclean, которая, соответственно, может уметь все это почистить, она при этом умная, она не будет трогать те workload, которые вы поставили через инсталлятор студии, она про них только warning напишет и скажет, вот, тут как бы такое дело, их удаляйте сами через инсталлятор студии.
912.16 922.48 "Игорь Лабутин" У нее есть волшебный ключик all, который я не очень понял, что делает, то есть по его описанию я так понял, что он тупо снесет вообще все workload, которые у вас есть, включая все, которые сейчас вот в текущей версии стоят.
922.48 925.68 "Игорь Лабутин" То есть типа это такой uninstall все, что можно заинсталить.
925.68 928.68 "Игорь Лабутин" Ну кроме студийных.
928.68 932.72 "Игорь Лабутин" Я не очень понял, что он делает, может быть, надо документацию будет почитать повнимательнее.
932.72 939.52 "Анатолий Кулаков" Ну и вообще плохо как-то использовать для uninstall слова clean, потому что все-таки разные вещи.
939.52 948.28 "Игорь Лабутин" Ну вот я не понял, то есть там как-то очень туманно про это написано, но сильно много разбираться не стал, я надеюсь, не потребуется.
948.28 952.00 "Игорь Лабутин" Давай дальше пойдем в рантайме.
952.00 960.44 "Игорь Лабутин" Ну блин, опять же, они так говорят, секция рантайм, ну да, секция рантайм, и при этом рассказывают про то, как настроить эти конфигурацион байнтеры.
960.44 963.96 "Игорь Лабутин" То есть тот, кто читает upsetting с Джейсоном и остальные провалеры.
963.96 967.20 "Анатолий Кулаков" А, подожди, подожди, он читает его в рантайме, да?
967.20 971.04 "Игорь Лабутин" Ну типа да, может быть, поэтому это секция рантайм.
971.04 984.16 "Игорь Лабутин" Короче, смысл в чем, у нас есть класс под названием конфигурацион байндер, это штука, которая самая центральная часть механизма доступа, ну точнее, не доступа, а чтения как раз всех этих свойств, которые вы используете.
984.16 1003.64 "Игорь Лабутин" То есть она умеет читать из application, точнее, не она умеет читать из application properties, а она как раз-таки является тем связующим звеном между провайдерами, которые умеют откуда-то получать вот эти все ключики и значения, и теми потом там iOptions, iConfiguration и всем остальным, через которые вы в коде получаете.
1003.64 1012.24 "Игорь Лабутин" И вот эта штука, она использовала reflection в разных местах, который не очень совместим с nativeout.
1012.24 1019.44 "Игорь Лабутин" .NET сейчас очень стремится все сделать, так сказать, nativeoutready, ну все не все, но все, что получится, мы про это еще поговорим сегодня.
1019.44 1034.84 "Игорь Лабутин" И поэтому на этом поприще очень много работы, в итоге вот этот конфигурацион байндер переписали на sourcegen, которые все вот эти штуки, которые ему нужны, генерируют в рантайме в sourcegenerator, и соответственно, дальше reflection не нужно.
1034.84 1039.28 "Игорь Лабутин" Для того, чтобы это включить, нужно там завязать preview package nouget, и это нормально.
1039.28 1043.00 "Игорь Лабутин" А дальше поставить опцию в csproj под названием enable microsoft-extension-configuration-binder-sourcegenerator.
1043.00 1050.28 "Игорь Лабутин" Вот, и если ее поставить в true, то тогда все будет заработать.
1050.28 1055.08 "Игорь Лабутин" В четвертом превью обещают упростить, и там nouget не нужно будет референсить, они это видимо все впилят уже в основной msbuild.
1055.08 1057.36 "Игорь Лабутин" И опции, наверное, сократят.
1057.36 1061.00 "Игорь Лабутин" Ну, может быть сократят, может быть оставят пока для включения опции.
1061.00 1086.48 "Анатолий Кулаков" Ну, у меня основная претензия к этому рефлектору была в том, что он безумно тупорылый, то есть он делает те действия, которые делать не должен, например, если свойства нет сеттера, то он пытается его зачем-то гетить, и прочие такие вещи, которые очень сильно мешают, на самом деле, если вы пытаетесь делать хорошие красивые там настроечки со всякой защитой от ненужной записи и прочее.
1086.48 1087.48 "Анатолий Кулаков" Он мега кривой.
1087.48 1094.16 "Анатолий Кулаков" И я надеялся, конечно, что его перепишут и делают прямым, вот видишь, взяли генератор и написали.
1094.16 1096.72 "Анатолий Кулаков" Но я думаю, генераторы все-таки должны уже исправить.
1096.72 1103.80 "Игорь Лабутин" Ну, во-первых, можно будет посмотреть, что он там нагенерировал, вероятно, и подправить, если надо.
1103.80 1107.56 "Игорь Лабутин" Ну и да, наверное, все-таки, может быть, это был повод что-нибудь поменять.
1107.56 1115.08 "Игорь Лабутин" Дальше, как обычно, много улучшений в GT, всяких разных.
1115.08 1118.88 "Игорь Лабутин" Отдельная секция посвящена контейнерам, но про контейнеры мы говорили в прошлый раз.
1118.88 1124.24 "Игорь Лабутин" Про мультипланформ, про то, что теперь можно rootless контейнеры использовать, так что это все мы пропустим.
1124.24 1125.24 "Игорь Лабутин" А SPNet.
1125.24 1129.24 "Игорь Лабутин" В SPNet большое-большое-большое изменение.
1129.24 1137.84 "Игорь Лабутин" Я говорил в одном из прошлых выпусков, может быть, даже в самом последнем, про то, что SPNet не очень готов к nativeout, потому что там дофигища рефлекшена.
1137.84 1143.08 "Игорь Лабутин" И внезапно, в третьем превью, SPNet начал работать с nativeout.
1143.08 1147.60 "Игорь Лабутин" И куда делся наш рефлекшен?
1147.60 1148.60 "Игорь Лабутин" Куда-то.
1148.60 1153.36 "Игорь Лабутин" Значит, смотри, давай по порядку сейчас пройдемся по статье, что они там рассказывают.
1153.36 1159.92 "Игорь Лабутин" Во-первых, пока это касается, как они говорят, мы фокусируемся на cloud native API applications.
1159.92 1166.76 "Игорь Лабутин" Ну, то есть, это означает, что там далеко не все поддержано, и в основном, конечно, поддержаны те части, где рефлекшен особо не нужен.
1166.76 1168.40 "Игорь Лабутин" Зачем это надо?
1168.40 1173.72 "Игорь Лабутин" Понятно, что там меньше размер, меньше startup time, меньше нужна памяти, но в общем, все здорово.
1173.72 1194.92 "Игорь Лабутин" По меньшмаркам у них получается, что какой-то простой их приложенец, типа hello world на SPNet в вебапе, который в обычном виде занимает 88 мегабайт, ну, в смысле, итоговый файлик, в варианте с nativeout стал занимать 11 мегабайт с небольшим, а startup time с 169 миллисекунд снизился до 34 миллисекунд.
1194.92 1197.20 "Игорь Лабутин" То есть, типа, в 5 раз.
1197.20 1199.20 "Игорь Лабутин" Ну, то есть, прям офигеть-офигеть.
1199.20 1205.68 "Игорь Лабутин" Понятно, что это простая маленькая приложенец, и в большом приложении там будет больше кода, но тем не менее.
1205.68 1208.60 "Игорь Лабутин" Что сейчас поддержано?
1208.60 1227.88 "Игорь Лабутин" Поддержано сейчас gRPC, работа с корсами, health-чеки, логирование, локализация, всякие middleware, типа, output caching, rate-limiting, request decompression, compression, response compression, кеширование, rewrite url-ов, раздача статических файлов и веб-сокеты.
1227.88 1240.44 "Игорь Лабутин" Частично поддержано, там не все еще доделано, минималы API, ну, куда же без них, потому что все, что было причислено выше, не включало ни одного, так сказать, кроме статических файлов, реальных endpoints.
1240.44 1244.28 "Анатолий Кулаков" Да, как бы они вообще поддержали, даже cloud native и все такое.
1244.28 1245.28 "Игорь Лабутин" А где контроллер?
1245.28 1246.28 "Игорь Лабутин" Контроллер-то нашел где?
1246.28 1252.68 "Игорь Лабутин" Вот, не поддержано MVC, Blazor, SignalR, любая авторизация, аутентификация, сессии и SPA-приложения.
1252.68 1258.96 "Игорь Лабутин" Вот, но не поддержано, это не значит, что не будет поддержано, над этим ведется работа.
1258.96 1262.92 "Игорь Лабутин" Значит, на примере minimal API можно рассказать, что было сделано.
1262.92 1269.60 "Игорь Лабутин" Сильно в детали углубляться не буду, потому что там прям все очень продвинуто.
1269.60 1272.48 "Игорь Лабутин" Смотрите, где нужен reflection в minimal API?
1272.48 1289.12 "Игорь Лабутин" В minimal API получается следующее, вы когда говорите какой-нибудь там app.map.get, вы туда передаете лямбдочку, которая принимает на вход параметры, например, из вашего запроса, то есть там объекты уже готовые, и на выходе выдает какой-то типизированный результат.
1289.12 1312.76 "Игорь Лабутин" А реально, что нужно вызвать, то есть внутри где-то нужно сгенерить код, который из HTTP контекста построит вам, выполнит код, который конвертнет все входящие объекты из запроса в реальные объекты .NET рантайма, создаст их, смапит, проверит, запустит валидацию и только после этого вызовет вашу лямбду.
1312.76 1319.08 "Игорь Лабутин" А еще там могут вызывать фильтры, фильтры могли навесить, тоже лямбдочки с соответствующими параметрами, которые тоже нужно создать.
1319.08 1323.40 "Игорь Лабутин" Короче, это все делалось в рантайме, в reflection.
1323.40 1343.60 "Игорь Лабутин" Теперь написали внезапно source-генератор, который называется request-delegate-generator, который как раз-таки и создает, точнее это source-gen, который будет прямо в compile-time написанный код, который выполняет все то, что нужно выполнить для того, чтобы ваши лямбды выполнялись, которые в файл-кодах, в файл-кодах и так далее.
1343.60 1359.04 "Игорь Лабутин" И второе ограничение, которое сейчас нужно сделать, что все параметры и респонс-тайпы, которые вы допустим через JSON-сериалайзер прогоняете, вы должны специально зарегистрировать в специальном JSON-сериалайзер контексте, иначе видимо их там триммер выпиливает и так далее.
1359.04 1360.64 "Игорь Лабутин" И они становятся недоступными.
1360.64 1364.88 "Игорь Лабутин" Я не знаю, почему я не вчитывался настолько детально.
1364.88 1374.80 "Игорь Лабутин" Настолько это все важно и нужно, что они аж сделали новый project-темплейт, называется spn-adcore-api, и у этого project-темплейта есть галочка enable native-out-publish опция.
1374.80 1378.00 "Игорь Лабутин" Вероятно после этого отключается часть функций, не знаю.
1378.00 1382.48 "Игорь Лабутин" Можно из командлайна создать этот темплейт через .NET new API.
1382.48 1385.48 "Игорь Лабутин" Теперь можно такую штуку сделать, и у него есть ключик -out.
1385.48 1404.40 "Игорь Лабутин" Так что пока поддержано немного, работа только начата, но там весь твиттер в лице Microsoft, в смысле тех, кто там обычно от Microsoft пишет, Fowler, понятно, NewtonKing и все остальные, все такие прям блин, круто, вообще, спнет в native-out, вообще супер быстро работает, все круто, но там работает мало, но быстро.
1404.40 1410.72 "Анатолий Кулаков" Не, ну звучит классно вообще, если переделать ASP на source generator, это прямо красота.
1410.72 1427.36 "Анатолий Кулаков" Не говоря вот там о том, что уже дебажить легче будет, потому что всегда задаешься вопросом, почему например твой запрос не дошел до твоего хендлера, у него путь может не совпасть, у него вертификация не прошла, у него какой-то фильтр застрял, в общем там причин почему это может случиться миллиард просто.
1427.36 1430.76 "Анатолий Кулаков" А здесь в source generator можно будет всегда зайти и посмотреть.
1430.76 1448.40 "Анатолий Кулаков" Ну и вообще интересно, вот как этот pipeline все-таки работает, потому что раньше он был от разработчика спрятан, теперь можно зайти глазками посмотреть и более так низкоуровнево вникнуть во всю эту систему, что всегда тоже полезно для общего развития и вообще для интереса просто узнать.
1448.40 1449.40 "Игорь Лабутин" Да.
1449.40 1469.96 "Игорь Лабутин" Вторая большая часть, это конечно Blazor, с Blazor много работают, мы, кажется, мы упоминали про такую инициативу как Blazor, как он, United, Unified, не помню как называется, но смысл в том, чтобы вы Blazor компоненты могли использовать вообще где угодно, неважно это там веб, васм, сервер сайт и так далее.
1469.96 1473.88 "Игорь Лабутин" Вот они сделали сейчас штуку под названием сервер сайт рендеринг для Blazor компонентов.
1473.88 1497.76 "Игорь Лабутин" Это пока только самое начало, early preview, но смысл в том, что вы можете теперь нарисовать Razor страничку компонента, к ней не нужен никакой .cshtml файлик, ему нужно только на этой страничке указать собственно, ну, route к этой страничке, откуда эту компоненту доставать и реализовать интерфейсик iRazorComponentApplication в .razor файле и все.
1497.76 1504.92 "Игорь Лабутин" А, ну в самом приложении написать addRazorComponents и mapRazorComponents, чтобы раутинг знал откуда их брать.
1504.92 1525.96 "Игорь Лабутин" Пока это все очень статично, там никакой интерактивности ничего быть не может, но это только начало, причем как интересный side-эффект говорится, что теперь, поскольку вот этот сервер-сайт рендеринг для Razor компонентов сделали, ну, в каком-то начальном виде и будут дальше расширять, то получается, что теперь можно рендерить Razor компоненты вообще не в контексте запросов и вообще не в ASP.
1525.96 1532.60 "Игорь Лабутин" То есть, если вам нужно отрендерить Razor компоненты в письмо в .html, пожалуйста, и потом послать по почте.
1532.60 1536.00 "Игорь Лабутин" Такое теперь тоже можно сделать, может быть, шаблончики на Blazor писать.
1536.00 1544.12 "Анатолий Кулаков" Ну, я всегда, в принципе, для писем Razor, Razor странички использовал, Razor генератор, прекрасная штука.
1544.12 1548.12 "Игорь Лабутин" Вот, ну вот теперь можно там будет еще круче все это делать.
1548.12 1549.60 "Анатолий Кулаков" Ну да, более официально, более прямо.
1549.60 1559.36 "Игорь Лабутин" Да, CMD завезли по дефолту, в смысле, включили по дефолту в Blazor в ASP и добавили пару штук для работы с запросами.
1559.36 1563.00 "Игорь Лабутин" Во-первых, теперь можно добавить штуку под названием Request Timeout.
1563.00 1573.84 "Игорь Лабутин" То есть вы в вашем, при конфигурации сервисов говорите Add Request Timeout, а в Middleware Pipeline говорите Use Request Timeout.
1573.84 1581.76 "Игорь Лабутин" После чего в на нужном Minimal API, либо на контроллере, вешаете атрибутиком Request Timeout и передаете туда Timeout.
1581.76 1588.64 "Игорь Лабутин" Не знаю, можно ли это как-то передать динамически, или только, ну, наверное, как-то должно быть можно передавать динамически, иначе странно было бы.
1588.64 1594.40 "Игорь Лабутин" В атрибут уж не знаю, а в Minimal API точно можно динамически, просто это аргумент таймспена.
1594.40 1599.56 "Игорь Лабутин" После чего эта штука кооперативно умеет абортиться.
1599.56 1600.56 "Игорь Лабутин" Что это значит?
1600.56 1609.12 "Игорь Лабутин" Это значит, что у вас в HTTP контексте появилось новое поле под названием Request Abort, это cancellation token, который будет заканцелен, как только истечен заданный Timeout.
1609.12 1619.68 "Игорь Лабутин" И вы внутри вашего реквеста можете понимать, что если к вам пришел реквест и вы его уже 30 секунд обрабатываете, ну, как бы можно уже и забить на обработку, он уже никому не нужен.
1619.68 1622.52 "Игорь Лабутин" И раньше времени выйти.
1622.52 1626.00 "Анатолий Кулаков" Ну, только это не новое поле, оно там всегда было.
1626.00 1632.96 "Анатолий Кулаков" Если ты, например, реквест у тебя канцелится, например, клиент закрывает TCP соединение или абортит, у тебя оно тоже срабатывает.
1632.96 1633.96 "Игорь Лабутин" А, ну, может быть.
1633.96 1637.40 "Игорь Лабутин" Я никогда не пользовался, честно говоря.
1637.40 1639.80 "Игорь Лабутин" Никогда не предпочитал, ни разу за всю мою карьеру.
1639.80 1651.36 "Анатолий Кулаков" Ну, типа, если ты из контроллера лезешь в базу, естественно, не напрямую, а через какие-то другие интерфейсы, то тебе нужно обычно передать cancellation token, и вот это cancellation token обычно и передается.
1651.36 1659.72 "Игорь Лабутин" Мне кажется, мы обычно когда-то такое делали, либо мы это делали в те времена, когда мы еще не передавали cancellation token вообще.
1659.72 1661.40 "Игорь Лабутин" Тогда это еще не было модным, да?
1661.40 1669.64 "Игорь Лабутин" Либо мы на самом деле свою middlewark писали, которая за таймаутами следила, и тогда мы от нее как раз использовали cancellation token, не используя что-то по контексту.
1669.64 1672.00 "Игорь Лабутин" Как-то это, не знаю, мимо меня прошло.
1672.00 1676.00 "Игорь Лабутин" Я не настоящий в этом смысле программист, видимо, не использовал, короче.
1676.00 1680.48 "Игорь Лабутин" Ну, в общем, вот, реквест аборт будет, можно теперь ему через специальную микрософтскую middlewark задать таймаут.
1680.48 1682.92 "Игорь Лабутин" Он будет абортиться через таймаут какой-то.
1682.92 1685.72 "Игорь Лабутин" А вторая штука называется short circuit routes.
1685.72 1687.20 "Игорь Лабутин" Это про что?
1687.20 1703.08 "Игорь Лабутин" У вас могут быть определенные endpoints, которые, например, отдают, ну, не знаю, файлик robots.txt или какой-нибудь там favicon для сайтов, которые гарантированно не требуют никакой авторизации, никакой аутентификации, ни проверки каких-нибудь корсов.
1703.08 1707.40 "Игорь Лабутин" Ну, то есть, короче, просто тупо сходить отдать там для static файлов, например.
1707.40 1726.12 "Игорь Лабутин" И вы теперь можете на методе написать метод расширения short circuit, и это будет означать, что на самом деле, фичи на самом деле немножко странные, но тем не менее, в статье написано следующее, что в этом случае ASP.NET не будет запускать весь pipeline middlewari перед этим.
1726.12 1734.40 "Игорь Лабутин" То есть, если он routing поймет, что нужно идти именно в тот endpoint, который помечен как short circuit, то забить на запуск всех pipelines и просто его выполнить.
1734.40 1736.32 "Игорь Лабутин" Да, это самый endpoint.
1736.32 1740.28 "Игорь Лабутин" Типа без авторизации, без аутентификации, без всего.
1740.28 1741.68 "Анатолий Кулаков" Тоже полезная штука для отладки.
1741.68 1745.56 "Анатолий Кулаков" Если вдруг у вас не работает какой-то endpoint, поставил быстренько, попробовал.
1745.56 1746.56 "Анатолий Кулаков" И в прот.
1746.56 1747.56 "Анатолий Кулаков" И в прот.
1747.56 1748.56 "Анатолий Кулаков" Только не в прот.
1748.56 1751.56 "Анатолий Кулаков" Хотя бы понимая, что проблема где-то посередине уже хорошо.
1751.56 1754.56 "Игорь Лабутин" Ну да, для отладки, кстати, согласен.
1754.56 1757.56 "Игорь Лабутин" Я ничего не думал про это.
1757.56 1759.24 "Игорь Лабутин" Идея закинуть после этого в прот.
1759.24 1761.76 "Игорь Лабутин" Нужен аналайзер, который проверяет, что в релиз конфигурации
1761.76 1765.92 "Анатолий Кулаков" там… Кроме робота и файл-икона, там больше ничего нет.
1765.92 1766.92 "Игорь Лабутин" Ну в общем, непонятно.
1766.92 1767.92 "Игорь Лабутин" Короче, вот.
1767.92 1768.92 "Игорь Лабутин" На этом все.
1768.92 1782.52 "Игорь Лабутин" Еще в пачке статей про релиз Dotnet 8 Preview 3 была статья про Maui, где написано, что мы заимпровили quality, мы заимпровили memory management, а больше мы ничего не сделали, и поэтому пользуйтесь нашим крутым UI.
1782.52 1783.52 "Игорь Лабутин" Дармоеды.
1783.52 1784.52 "Игорь Лабутин" Типа того.
1784.52 1793.68 "Игорь Лабутин" Ну там были какие-то тонкости, типа там мы еще в контроллы что-то завезли, ну там, слушай, я что-то как-то… Мне уже… Я устал перечислить новые контроллы, которые добавили в Maui.
1793.68 1798.04 "Игорь Лабутин" Такое ощущение, что они все добавляют и добавляют и добавляют, где же они были раньше.
1798.04 1801.08 "Игорь Лабутин" Давай лучше поговорим про что-нибудь более интересное.
1801.08 1802.08 "Игорь Лабутин" Это C#.
1802.08 1808.24 "Анатолий Кулаков" Ну да, вместе с непосредственно своим фреймворком и за релизились новые фичи языка.
1808.24 1809.92 "Анатолий Кулаков" Не, за релизились еще рано.
1809.92 1813.04 "Анатолий Кулаков" Вышли в бета-превью на попробу.
1813.04 1814.04 "Анатолий Кулаков" Еще успеют откатить.
1814.04 1815.56 "Анатолий Кулаков" Еще успеют 10 раз откатить.
1815.56 1820.16 "Анатолий Кулаков" Но все же, что нам тут обещают, над чем сейчас работают, и главное, под чем собираются сейчас фидбэк.
1820.16 1822.68 "Анатолий Кулаков" Поэтому у вас есть шанс возразить.
1822.68 1825.52 "Анатолий Кулаков" Здесь три небольших фичи нам показали.
1825.52 1829.76 "Анатолий Кулаков" Во-первых, это primary конструкторы для не рекорд-классов.
1829.76 1837.64 "Анатолий Кулаков" То есть, как мы, наверное, уже все давно знаем с прошлого релиза, у рекордов появилась такая вещь, как primary конструктор.
1837.64 1849.20 "Анатолий Кулаков" То есть, мы можем в круглых скобочках во время объявления рекорда прямо задать типы и название пропертей, и эти пропертии прокинутся в сам сгенерированный классик.
1849.20 1852.56 "Анатолий Кулаков" Поэтому рекорды можно объявлять в одну строчку, что очень удобно и красиво.
1852.56 1858.04 "Анатолий Кулаков" И пользователи этим понаслаждались и попросили Microsoftа, давайте-ка мы везде так добавим.
1858.04 1861.16 "Анатолий Кулаков" Не только рекордам, но и обычным классам, чтобы можно было так делать.
1861.16 1874.64 "Анатолий Кулаков" И, соответственно, теперь предлагается обычным классам точно так же во время декларации класса в круглых скобочках а-ля конструктор объявить те филды, те поля, которые должны там быть.
1874.64 1884.88 "Анатолий Кулаков" Но, к сожалению, несмотря на то, что синтексис похож, реализация кардинально отличается.
1884.88 1900.16 "Анатолий Кулаков" То есть, если в синтексисе, как я уже сказал, в круглых скобочках задается во время декларации класса, то в отличие от рекордов, где мы привыкли, что те параметры, которые мы передаем в этих круглых скобочках в прайме реконструктора, в рекордах они разворачиваются в публичные свойства.
1900.16 1907.08 "Анатолий Кулаков" Если же мы говорим про не рекорды, а обычные классы и структуры, то они будут разворачиваться в приватные филды.
1907.08 1908.08 "Анатолий Кулаков" Не перепутайте.
1908.08 1912.84 "Анатолий Кулаков" И, соответственно, к этим приватным филдам вы можете обращаться.
1912.84 1924.40 "Анатолий Кулаков" Вообще, во-первых, прежде всего вы можете обращаться из свойств, соответственно, к приватным филдам, и также для вас генериться еще конструктор с этими же самыми параметрами.
1924.40 1929.84 "Анатолий Кулаков" То есть вы можете создавать классы с этим конструктором и можете из других конструкторов вызывать этот конструктор.
1929.84 1937.24 "Анатолий Кулаков" И первое, что приходит в голову, зачем вот такая мешанина.
1937.24 1943.12 "Анатолий Кулаков" То есть у тебя, если это рекорды, у тебя будут свойства генериться, если это классы и структуры, будут генериться приватные филды.
1943.12 1944.68 "Анатолий Кулаков" В общем, зачем так запутывать людей?
1944.68 1952.60 "Анатолий Кулаков" И основной отмаз в том, что это подчеркивает то, что рекорды – это простые классы, и там никому кроме свойств примитивных ничего не надо.
1952.60 1967.00 "Анатолий Кулаков" А вот если мы создаем нормальный класс или нормальную структуру, то это какая-то сложная сущность, где вам все равно придется делать какие-то свойства, у этих свойств будут какие-то дополнительные обработчики или какие-то дополнительные проверки.
1967.00 1973.00 "Анатолий Кулаков" Поэтому в любом случае вам нужно будет делать свойства, и поэтому мы решили остановиться на филдах, к которым вы можете доступиться.
1973.00 1974.92 "Анатолий Кулаков" Ну, в общем, вот так вот.
1974.92 1983.04 "Анатолий Кулаков" Но, конечно, вводят в заблуждение, особенно когда человек этот первый раз видит, ему нужно помнить эту магию, которая срабатывает от фазы Луны.
1983.04 1987.84 "Анатолий Кулаков" В пользу нужно сказать, что генериться все довольно приятно.
1987.84 2009.76 "Анатолий Кулаков" Например, если вы добавите туда свойства, у которого будет getter-setter, и этому свойству там поставите равно, обратившись к одному из аргументов этого конструктора и каким-то образом его обработав, то есть по сути проинициализируете свойства, не будете каждый раз вычислять, а именно проинициализируете, то вот эта инициализация провалится в конструктор, в автосгенеренный, и там выполнится, соответственно, только один раз.
2009.76 2019.04 "Анатолий Кулаков" В общем, ну, такие вот мелочи, тонкости, которые, конечно, ждешь от команды профессионалов, но всегда было приятно увидеть в декомпиляции, что именно так и было сделано.
2019.04 2026.60 "Анатолий Кулаков" Следующая фича, которую нам объявили, это использование юзинга для декларации, для объявления абсолютно любых типов.
2026.60 2034.36 "Анатолий Кулаков" То есть это то, что, в принципе, я уже давно ждал, прямо с самых плюсов ждал, как только перешел на C#, мне этого сильно не хватало.
2034.36 2043.20 "Анатолий Кулаков" Вы можете написать, как всегда, юзинг, там какое-то имя, которое вы только что придумали, равно, и обычно мы там могли сокращать какой-нибудь длинный большой тип.
2043.20 2046.52 "Анатолий Кулаков" Теперь вы это можете сделать абсолютно для любого типа.
2046.52 2057.08 "Анатолий Кулаков" Например, вы можете написать юзинг, юзинг какой-нибудь вольюм и равно int, или массив int, или даже нулябельный int.
2057.08 2061.56 "Анатолий Кулаков" В общем, объявить какой-то алиас для примитивных типов.
2061.56 2068.76 "Анатолий Кулаков" Это очень удобно, это такой, как получается, object value для бедных.
2068.76 2076.76 "Анатолий Кулаков" Если вам не хочется оборачивать свой тип, чтобы избежать примитива обсессиона, то можно, по крайней мере, такой штукой сделаться.
2076.76 2084.08 "Анатолий Кулаков" Конечно, компилятор вам здесь не поможет, в отличие от нормального object value, но хотя бы читать будет легче.
2084.08 2094.64 "Анатолий Кулаков" Вместо double можете передавать тип, который называется процент, и вместо какого-нибудь int можете передавать тип, который называется вольюм или что-нибудь такое.
2094.64 2096.60 "Анатолий Кулаков" Что больше отражает вашу сущность.
2096.60 2117.12 "Игорь Лабутин" Я же правильно понимаю, что эта штука чисто синтактически визуальна, то есть если ты, допустим, сделаешь два таких юзинга, и оба из них будут обращаться к int, то фактически, даже если ты объявишь функцию, напишешь юзинг a = int и юзинг b = int, и напишешь функцию которая принимает a, никто не запрещает тебе туда передать b.
2117.12 2124.64 "Анатолий Кулаков" Да, конечно, это полностью не избавляет от этого примитива обсессиона, это больше похоже на эти типы, которые мы пишем.
2124.64 2135.44 "Анатолий Кулаков" Если ты напишешь юзинг i32 = system.int.32, то ты можешь использовать как alias i32, и также int32, и это все будет одно и то же для компилятора подставляться абсолютно.
2135.44 2137.60 "Игорь Лабутин" И все это в рамках одного файла?
2137.60 2139.76 "Анатолий Кулаков" Да, это работает только в рамках одного файла.
2139.76 2144.00 "Анатолий Кулаков" Ну так как у нас теперь есть юзинг статики, то может быть… Глобал юзинги скорее.
2144.00 2145.44 "Анатолий Кулаков" Да, глобал юзинги, то есть, да-да-да.
2145.44 2148.80 "Анатолий Кулаков" То есть может быть они это вынесут еще в глобал юзинги, но пока так.
2148.80 2152.96 "Анатолий Кулаков" Это очень часто, например, используется в плюсах, когда ты define какой-нибудь тип.
2152.96 2155.76 "Анатолий Кулаков" Делаешь define какой-нибудь alias, и туда тип засовываешь.
2155.76 2159.32 "Анатолий Кулаков" Большой, generic, страшный, и все такое.
2159.32 2162.80 "Анатолий Кулаков" Вот, теперь мы тоже это можем делать, но с небольшими ограничениями.
2162.80 2168.16 "Анатолий Кулаков" Как я уже сказал, нулябельные value-тайпы поддерживаются, но не поддерживаются нулябельные reference-тайпы.
2168.16 2171.36 "Анатолий Кулаков" Я, насколько копал, так и не понял, а почему?
2171.36 2174.88 "Анатолий Кулаков" Какая разница, в чем они провинились, но пока так.
2174.88 2176.68 "Анатолий Кулаков" Надеюсь, что к релизу починят.
2176.68 2183.48 "Анатолий Кулаков" Также можно сделать туда tuples засунуть, что приятно вместе и с типом, и с наименованием.
2183.48 2189.40 "Анатолий Кулаков" То есть это вот такой небольшой аналог рекордов, или даже f-sharp-ных tuples получается.
2189.40 2191.00 "Анатолий Кулаков" Ну, как красивенько, красивенько выглядит.
2191.00 2197.20 "Анатолий Кулаков" И, соответственно, как я уже сказал, можно подставлять эти типы везде, где вы ожидаете типы.
2197.20 2218.00 "Анатолий Кулаков" Это преподносится как абстракция от какого-то более конкретного типа к какому-то более специфичному типу, какой-нибудь более специфичный для вашей бизнес-логики, для преобразования более дружелюбных имен, особенно какие-нибудь большие, дженериковых, страшных типов, и также для удобного чтения.
2218.00 2219.40 "Анатолий Кулаков" Тоже может быть вам полезно.
2219.40 2227.76 "Анатолий Кулаков" И третье последнее нововведение, которым нас познакомили, это Default values для lambda expressions.
2227.76 2230.80 "Анатолий Кулаков" Не очень большое нововведение, но, наверное, довольно полезное.
2230.80 2241.08 "Анатолий Кулаков" Как все мы знаем, лямбду можно записать в виде переменной, в виде круглых схобочков, засунуть ей параметры и через равно стрелочку нарисовать ей body.
2241.08 2253.08 "Анатолий Кулаков" Вот теперь в эти параметры вы можете не только объявить тип и имя параметра, но и с помощью привычного хотя бы здесь, спасибо, синтаксиса, указать ей там равно 2 или равно 3, то есть указать какое-то дефолтное значение.
2253.08 2260.92 "Анатолий Кулаков" И эту лямбду уже можно вызывать или без параметров, тогда поставится ваше дефолтное значение, или с параметрами, тогда дефолтное значение учитываться не будет.
2260.92 2265.68 "Анатолий Кулаков" Но тут довольно-то все предсказуемо, синтаксис понятен и, в принципе, все хорошо.
2265.68 2274.88 "Анатолий Кулаков" Стоит отметить, что это дефолтное значение записывается в метадату, то есть с помощью Reflection, можно его зачем-то, если вам нужно, прочитать и каким-то образом в своей логике заиспользовать.
2274.88 2276.36 "Анатолий Кулаков" Такие небольшие нововведения.
2276.36 2285.92 "Анатолий Кулаков" Кажется, что нам как-то до сих пор не сообщают, а что же будет главной прорывной фичей во всем будущем C#, за что стоит бороться, стараться и всячески прославлять.
2285.92 2287.60 "Анатолий Кулаков" Что-то пока не просматривается.
2287.60 2290.24 "Анатолий Кулаков" Люди ждут, а нас кормят какой-то мелочью.
2290.24 2298.60 "Игорь Лабутин" Да, в комментариях к статье было много всяких разных мнений на тему того, что да, пилим все бесполезные мелочи, где же, где же, где же.
2298.60 2299.60 "Игорь Лабутин" Супер крутое.
2299.60 2310.76 "Игорь Лабутин" И про какие-то вещи довольно адекватно отвечали представители Microsoft про то, что вы хотите одного, сосед хочет другого, кто-то третий хочет третьего.
2310.76 2317.60 "Игорь Лабутин" Причем даже если вы называете все одним и тем же именем, вы хотите разного, а нам надо как-то это все свести воедино.
2317.60 2324.08 "Игорь Лабутин" В общем, мы работаем, мы стараемся, но вот приходите в гитхаб C# и давайте обсуждать там.
2324.08 2329.16 "Анатолий Кулаков" Да, мне в частности понравилось, как ответили опять же на очередной наезд, где наши дискриминацион юнионы.
2329.16 2340.32 "Анатолий Кулаков" Типа давайте несите, уже давно обещали все такое, и там такой огромный абзац, типа вот вы смотрите, там попросили, вот вам ссылки, вот тут есть дискуссия, вот туда и там 20 ссылок навалили с подробным описанием.
2340.32 2344.16 "Анатолий Кулаков" Действительно, ответить нечего, остается только заткнуться и пойти лесом.
2344.16 2346.16 "Игорь Лабутин" Мол, все хорошо, умеет работать.
2346.16 2352.80 "Игорь Лабутин" Или пойти в обсуждение и помочь, не знаю, высказать свое мнение, поставить там палец вверх, палец сниз.
2352.80 2353.80 "Анатолий Кулаков" Да, да, именно так.
2353.80 2362.40 "Анатолий Кулаков" Еще, кстати, очень много комментариев, которые кричат про то, что прекратите извращать язык, прекратите писать какие-то новые непонятные слова.
2362.40 2367.88 "Анатолий Кулаков" И вот, как смотря, видишь, на вот этот Primary Constructor, у меня такие же точно ощущения возникают.
2367.88 2378.60 "Анатолий Кулаков" Они придумали какие-то костыли с вот этими requirement, Primary Constructor и init, и redundant fields, вот столько наградили, всякая чушь.
2378.60 2385.84 "Анатолий Кулаков" Кажется, что они подставляют 11 костылей, у них течет в другом месте, как бы залатывают там, у них пробивает четвертое место.
2385.84 2392.36 "Анатолий Кулаков" И вот они каждый релиз пытаются вот такими костылями все нам подоткнуть, вместо того, чтобы выработать какую-нибудь хорошую устроенную концепцию, чтобы хорошо
2392.36 2395.28 "Игорь Лабутин" бы лошилась на язык. Это называется итеративная разработка.
2395.28 2397.48 "Игорь Лабутин" Это называется костыли.
2397.48 2400.60 "Игорь Лабутин" Ну вот раньше у них было три года спокойно, вот они и делали.
2400.60 2403.08 "Игорь Лабутин" А сейчас у них за год нужно что-нибудь зарелизить, вот они что-нибудь релизят.
2403.08 2410.56 "Анатолий Кулаков" Ну видишь, это не такая уж большая фича, это безумные мелочи, без которых вполне можно было бы и жить, если честно.
2410.56 2411.56 "Игорь Лабутин" Тем более с появлением генерации.
2411.56 2429.20 "Игорь Лабутин" Да, да, но у меня сейчас мнение такое, ну в смысле впечатление, так скажем, такое, что читать, кажется, я пока могу любую версию, а вот писать я уже что-то как-то, пишешь на том, на чем привычно, все вот эти нововведения, на самом деле, не сказать, что я помню.
2429.20 2436.56 "Игорь Лабутин" Вот я сейчас в подкасте, конечно, все рассказываю, я типа все помню, а по факту, когда открываешь студию и начинаешь писать, ну как руки помнят, так и пишешь.
2436.56 2440.28 "Игорь Лабутин" И все эти новые фичи, только если студия или райдер что-нибудь подскажет.
2440.28 2449.60 "Анатолий Кулаков" Да, там, мне кажется, интеллисенс подскажет, сначала студия, райдер, потом GPT придет, тебе все сам за тебя напишет, как захочет, как ты его настроишь.
2449.60 2450.60 "Игорь Лабутин" Ладно, хорошо.
2450.60 2461.80 "Игорь Лабутин" Давай дальше, у нас еще это все не конец, на самом деле, того, что там изменяется, я видел статью про изменение в аутентификации, идентики и прочее в WSP.
2461.80 2467.32 "Игорь Лабутин" Что у нас там, уже что-то сделали, что-то обещают или что-то еще пока не сделали, но будет?
2467.32 2471.12 "Анатолий Кулаков" Да, много пообещали, уже половину сделали, давай подробнее.
2471.12 2483.40 "Анатолий Кулаков" Как многие, наверное, из вас знают, в WSP.NET Core существует идентифейфреймворк, ну то есть идентифейфреймворк такое, который отвечает за юзеров, роли, аутентификации, авторизации, в общем, все туда запихано.
2483.40 2484.68 "Анатолий Кулаков" Все, насколько можно было.
2484.68 2490.20 "Анатолий Кулаков" И, в принципе, у вас есть довольно широкий выбор, что использовать для идентити.
2490.20 2493.64 "Анатолий Кулаков" Во-первых, это по-ранее упомянутая WSP.NET Core Identity.
2493.64 2501.88 "Анатолий Кулаков" Во-вторых, есть Azure Active Directory, ну кроме Azure, там есть, подставьте абсолютно любое облачное решение, но просто Microsoft естественно все пишет на примере Azure.
2501.88 2509.72 "Анатолий Кулаков" И также существует огромное количество сторонних тулзов, там, наверное, самое популярное из этого списка это Duandy Identity Server.
2509.72 2512.44 "Анатолий Кулаков" Тоже можно это все дело использовать.
2512.44 2522.76 "Анатолий Кулаков" Но мы как раз остановимся подробнее на микрософтовском решении, потому что оно идет прямо из коробки, оно включает в себя довольно много базовых концепций, и большинству проектов его, в принципе, вполне хватает.
2522.76 2528.32 "Анатолий Кулаков" WSP.NET Core Identity состоит из нескольких основных частей.
2528.32 2540.16 "Анатолий Кулаков" Во-первых, это Identity Manager, который помогает вам работать с юзерами и ролями, а также он может обрабатывать клеймы, логины, в общем, управлять всеми вот этими низкоуровневыми объектами.
2540.16 2549.32 "Анатолий Кулаков" Дальше идет Identity Store, который как раз-таки отвечает за то, а где все ваши юзеры, роли и клеймы будут храниться, и соответственно откуда они будут считываться.
2549.32 2559.20 "Анатолий Кулаков" И в качестве дефолтной имплементации вот этого стора также существует Identity Store для релационной базы данных, который работает на основе Entity Framework.
2559.20 2562.70 "Анатолий Кулаков" То есть все, что поддерживает Entity Framework, может быть релационной базой данных.
2562.70 2569.52 "Анатолий Кулаков" Вы также, естественно, можете реализовать свой стор, храните где вашей душой угодно все эти сущности.
2569.52 2574.24 "Анатолий Кулаков" Еще одним таким большим, навороченным, важным куском является SIGN Manager.
2574.24 2583.08 "Анатолий Кулаков" Он отвечает как раз за систему аутентификации, за пайплайны, за проверку всяких паролей, за генерацию каких-то новых свойств.
2583.08 2587.92 "Анатолий Кулаков" В общем, очень важный тот чувак, в котором очень много разных правил.
2587.92 2589.60 "Анатолий Кулаков" И Identity UI.
2589.60 2592.40 "Анатолий Кулаков" Это UI для управления пользователями.
2592.40 2597.40 "Анатолий Кулаков" Такие базовые там странички логина, странички forbidden и прочие такие вещи.
2597.40 2603.76 "Анатолий Кулаков" И вся эта система, в принципе, работает хорошо, работает давно, неплохо документирована.
2603.76 2610.76 "Анатолий Кулаков" Но у нее на данный момент есть ряд ограничений, очень важных, которые в современную инфраструктуру немножко не вписываются.
2610.76 2619.60 "Анатолий Кулаков" Во-первых, не очень хорошо эта вся штука работает с Single Server Page Application.
2619.60 2627.40 "Анатолий Кулаков" Потому что традиционно все эти фреймворки, они очень кастомизибельные.
2627.40 2637.36 "Анатолий Кулаков" И для того, чтобы правильно обрабатывать систему аутентификации и авторизации, тоже вот этот Identity Framework, его нужно немножко подделать.
2637.36 2642.04 "Анатолий Кулаков" Потому что в нем вся UI сделана на Server Render Pages.
2642.04 2643.84 "Анатолий Кулаков" По дефолту на Razor Pages.
2643.84 2646.00 "Анатолий Кулаков" Можно, конечно, Razor поменять на что-то другое.
2646.00 2649.16 "Анатолий Кулаков" Но смысл в том, что оно должно рендериться на сервере.
2649.16 2651.36 "Анатолий Кулаков" И уже на клиента даваться готовые странички.
2651.36 2654.28 "Анатолий Кулаков" Можно с помощью Castellet как-то переделать.
2654.28 2657.52 "Анатолий Кулаков" Но прямо красивого способа из коробки нет.
2657.52 2664.88 "Анатолий Кулаков" Другая проблема, которую видят микрософтцы, это в том, что у них нет встроенного решения для Token Based аутентификации.
2664.88 2667.76 "Анатолий Кулаков" То есть у них это все работает сейчас только на куках.
2667.76 2675.96 "Анатолий Кулаков" А многие фреймворки и многие подходы пропагандируют, что Token Based это в данном случае более правильный подход.
2675.96 2679.24 "Анатолий Кулаков" И вот этот как раз таки Identity Core не поддерживает.
2679.24 2688.36 "Анатолий Кулаков" И поэтому обычно подключаются какие-то сторонние либо, которые помогают работать с токенами.
2688.36 2692.08 "Анатолий Кулаков" Давайте теперь подробнее рассмотрим эти и другие пункты.
2692.08 2694.48 "Анатолий Кулаков" Во-первых, для SPA-темплейтов.
2694.48 2710.64 "Анатолий Кулаков" То есть для SPA-темплейтов и для Token Based аутентификации этот фреймворк обычно тащил какой-нибудь Identity Server, который раньше был Duendo.
2710.64 2716.76 "Анатолий Кулаков" И теперь они хотят удалить зависимость от Duendo сервера.
2716.76 2720.16 "Анатолий Кулаков" И обязательно обещают это сделать.
2720.16 2722.96 "Анатолий Кулаков" То есть основная зависимость она конечно в темплейтах была.
2722.96 2725.92 "Анатолий Кулаков" То есть по умолчанию темплейты генерились вместе с Duendo.
2725.92 2729.32 "Анатолий Кулаков" И обещают это сделать наконец в 8-ом дотнете.
2729.32 2733.80 "Анатолий Кулаков" Вообще на самом деле они давно обещали это сделать, но вот сейчас похоже уже доросли.
2733.80 2743.00 "Анатолий Кулаков" И как раз-таки Duendo им обеспечивал поддержку JWT токенов, которые генерились вместе с темплейтами.
2743.00 2747.88 "Анатолий Кулаков" И здесь же они обещают удовлетворить Single Page Application.
2747.88 2750.76 "Анатолий Кулаков" Такие там построенные на Angular, React, Blazor.
2750.76 2751.76 "Анатолий Кулаков" Не суть важно.
2751.76 2753.88 "Анатолий Кулаков" В принципе у всех у них есть такая проблема.
2753.88 2756.16 "Анатолий Кулаков" Про Duendo.
2756.16 2760.00 "Анатолий Кулаков" Они тут рассказывают, что как только они его добавили, это было open-source решение.
2760.00 2763.92 "Анатолий Кулаков" Хоть и стороннее, но все-таки open-source, поэтому они не поджидали ничего плохого.
2763.92 2768.60 "Анатолий Кулаков" Но в 2020 году этот сервер сменил лицензию на коммерческую.
2768.60 2770.32 "Анатолий Кулаков" Мы это обсуждали в нашем подкасте.
2770.32 2773.36 "Анатолий Кулаков" Причины, последствия и так далее.
2773.36 2780.28 "Анатолий Кулаков" И с тех самых пор Microsoft обещает отказаться постепенно для того, чтобы оставить обратную совместимость.
2780.28 2783.04 "Анатолий Кулаков" Для того, чтобы не обломать пользователей, которые уже привыкли этим пользоваться.
2783.04 2784.36 "Анатолий Кулаков" Но постепенно отказывается.
2784.36 2788.28 "Анатолий Кулаков" И вот в будущей версии обещают полностью удалить любую связь.
2788.28 2795.72 "Анатолий Кулаков" И если вам нужно, то в принципе вы всегда можете подключить стандартные Duendo-вские темплейты, которые тоже есть.
2795.72 2799.68 "Анатолий Кулаков" Duendo Identity Server прекрасно интегрируется с SSP.NET Core Identity.
2799.68 2803.00 "Анатолий Кулаков" И вместе они абсолютно не конфликтуют, а очень даже друг друга дополняют.
2803.00 2807.24 "Анатолий Кулаков" Итак, для self-hosting solution.
2807.24 2816.00 "Анатолий Кулаков" То есть главная цель у Microsoft – это все-таки не покрыть абсолютно все кейсы для security, для аутентификации, авторизации.
2816.00 2820.44 "Анатолий Кулаков" Главный кейс у них все-таки обеспечить какой-то минимальный базовый набор, который хочет пользователь.
2820.44 2832.48 "Анатолий Кулаков" И обычно пользователь не хочет каких-то сложных OAuth, OpenID Connect и вот этих всех сложных протоколов по интеграции с другими сервисами, по логину через Active Directory.
2832.48 2845.88 "Анатолий Кулаков" Им нужны довольно-таки примитивные базовые вещи, когда они смогут простое приложение, в нем настроить проверку пользователей, в нем настроить какие-то роли, естественно проверку этих ролей, логин пользователя, логаут пользователя и так далее.
2845.88 2849.68 "Анатолий Кулаков" То есть какие-то базовые вещи, которые всегда всем хочется.
2849.68 2859.32 "Анатолий Кулаков" И вот Identity, I Spent Score Identity поддерживал все эти штуки из коробки довольно давно, прям сразу.
2859.32 2863.96 "Анатолий Кулаков" И как я уже сказал, аутентификация была только через KUKA.
2863.96 2871.16 "Анатолий Кулаков" И в этом релизе они наконец обещают нам заимпровить поддержку UI.
2871.16 2879.84 "Анатолий Кулаков" То есть они обещают сделать UI, который может рендериться как на сервере, так и отдаваться на Single Page Application.
2879.84 2891.00 "Анатолий Кулаков" Также они обещают добавить правильных Endpoints, с помощью которых разработчики UI смогут обеспечить свой процесс именно визуальной аутентификации и авторизации.
2891.00 2902.84 "Анатолий Кулаков" И обещают сделать хороший, понятный механизм, который позволит вам сделать свой custom UI красивым и полноценным, чтобы можно было с ним взаимодействовать.
2902.84 2919.04 "Анатолий Кулаков" Также они обещают поддержать токены без всяких третисторонних лип, что позволит сделать процесс аутентификации более гибкой, что позволит как раз аутентифицировать SPA приложение.
2919.04 2926.52 "Анатолий Кулаков" И на самом деле в токене будет просто напросто отрежена та же самая информация, которая сейчас есть в KUKA.
2926.52 2931.84 "Анатолий Кулаков" И все эти данные, все роли, все что сейчас есть в KUKA засунут в токены.
2931.84 2934.52 "Анатолий Кулаков" И эти токены дойдут на UI.
2934.52 2939.52 "Анатолий Кулаков" И на самом деле это огромная дыра в безопасности, новая будет.
2939.52 2948.48 "Анатолий Кулаков" Потому что на самом деле никакие токены, особенно с информацией, которая помогает вам аутентифицироваться и авторизоваться, нельзя давать на UI.
2948.48 2951.20 "Анатолий Кулаков" Об этом в принципе тоже написано много статей.
2951.20 2960.40 "Анатолий Кулаков" Я чувствую, что в момент релиза данной фишки нам придется эти статьи все-таки поднять, обсудить и рассказать, как все-таки делать не надо.
2960.40 2963.76 "Анатолий Кулаков" Но пока ставим это на совести микрософтовских разработчиков.
2963.76 2964.76 "Игорь Лабутин" Посмотрим, как они это сделают.
2964.76 2967.96 "Игорь Лабутин" Теперь же не обязательно отдавать полный JWT токен наружу.
2967.96 2975.32 "Игорь Лабутин" Ты можешь прозрачный токен, а как он там, опа, короче рандомную строчку просто отдавать и все.
2975.32 2980.64 "Игорь Лабутин" А потом уже на сервере мапить обратно из этой строчки в реальный токен, который у тебя локально лежит.
2980.64 2986.84 "Анатолий Кулаков" Ну вот судя по тому описанию, что они хотят просто-напросто KUKA, данные из KUKA взять и законвертить в токены и отдать и все.
2986.84 2991.48 "Анатолий Кулаков" Так что да, будет зависеть конечно от реализации, но пока описание не вызывает оптимизма.
2991.48 2992.92 "Анатолий Кулаков" Ну хорошо, посмотрим.
2992.92 3003.16 "Анатолий Кулаков" И вместе под этим всем они обратятся обязательно к документации, потому что у них уже есть хорошая в принципе, нормальная документация по идентике, но она основана больше такая технологическая.
3003.16 3008.16 "Анатолий Кулаков" Они там описывают фичи, что мы умеем, какие технологии используются, как это в продукт заинтегрировать.
3008.16 3009.44 "Анатолий Кулаков" Говорят, что непонятно.
3009.44 3013.48 "Анатолий Кулаков" Пользователи хотят больше мануалов для начинающих и конкретных сценариев.
3013.48 3018.88 "Анатолий Кулаков" Например, у меня есть такая ситуация, мне нужно добиться следующего какого-то поведения, как это сделать.
3018.88 3051.32 "Анатолий Кулаков" И в общем они решили создать какую-то такую единую точку, в которой будет описана аутентификация для ISP.NET Core Identity и там собрать абсолютно все ссылки на абсолютно все там туториалы, самплы, всякие мануалы для начинающих и описать подробно много-много сценариев, где и как это использовать, как что подключать, потому что тема действительно обширная и очень гибкая для того, чтобы заставить разных провайдеров на разных протоколах и с разных девайсов в правильном месте работать, нужно подкрутить много-много всяких настройчиков.
3051.32 3057.56 "Анатолий Кулаков" Вот, они это все обещают описать, подсветить и показать.
3057.56 3073.36 "Анатолий Кулаков" Они плотно взаимодействуют с различными своими большими кастерами, у которых как раз запрашивают сценарий, который им необходимо написать в документации и обещают все это в документации обязательно осветить и сделать ISP.NET Core Identity.
3073.36 3075.68 "Анатолий Кулаков" Самая лучшедокументированная библиотека на свете.
3075.68 3077.48 "Анатолий Кулаков" Посмотрим, что из этого всего получится.
3077.48 3083.60 "Игорь Лабутин" Ну, я думаю, что в ближайших превью, которые будут выходить, точно будут какие-то апдейты на эту тему.
3083.60 3093.40 "Игорь Лабутин" Мы потихонечку будем видеть какие-нибудь кусочки этого самого аутентификации переписанной, дописанной, замененной и по мере выхода будем тогда обсуждать.
3093.40 3094.40 "Игорь Лабутин" Давай дальше.
3094.40 3105.60 "Игорь Лабутин" Дальше у нас сегодня практически все про ISP.NET Core, потому что есть еще одна отдельная статья про ISP.NET Core, она очень небольшая, это про раутинг и штуки вокруг него в ISP.NET Core.
3105.60 3118.56 "Игорь Лабутин" ISP.NET Core в принципе построен вокруг раутинга, все что вы, ну почти любое приложение, это будет так или иначе включать его, это и Minimal API, Web API, Razer, Blazer, все что угодно, контроллеры, MVC, все основано на раутинге.
3118.56 3125.68 "Игорь Лабутин" И поэтому Microsoft что-то вложилась тут, подумала, и вложилась в набор аналайзеров вокруг раутинга.
3125.68 3144.92 "Игорь Лабутин" Во-первых, в IDE теперь можно хайлайтить синтексис внутри, то есть у нас в маршрутах можно использовать всякие разные штуки, параметры, constraint на них, дефолтовые значения, параметры могут быть optional, можно replace токены, когда вы пишете в квадратных скобочках, какой-нибудь контроллер, слово, название контроллера подставляется.
3144.92 3146.84 "Игорь Лабутин" Вот теперь там работает синтекс хайлайтинг, они
3146.84 3155.76 None все это понимают, ну те IDE, которые захотят. Также в раутах будет работать автокомплит, над видеом больше работает про студию.
3155.76 3181.88 "Игорь Лабутин" А, и еще там интересная штука, то есть теперь в рауте можно, то есть когда вы пишете какой-нибудь минимал API, вам не обязательно указывать в параметрах раута прям те же названия, параметры, которые вы указали внутри лямбды, он сам будет понимать, что вот если у вас есть лямбда и там есть параметр ID, то, наверное, в запросе в квери, ну по дефолту в квери, как я понимаю, должен быть параметр ID, и если он есть, он будет мапиться.
3181.88 3187.08 "Анатолий Кулаков" Просто непонятно в каком месте, он может быть там после ?, может быть после вопросительного знака.
3187.08 3196.40 "Игорь Лабутин" Да, ну какая-то там логика внутри есть, но какая, кстати, к сожалению, не описана, надо будет почитать опять же документацию.
3196.40 3199.88 "Игорь Лабутин" Не знаю, я обычно предпочитаю все явно указывать, но посмотрим.
3199.88 3207.44 "Игорь Лабутин" Constraint, соответственно, в студии, в смысле в IDE можно автокомплитить теперь после, если вы пишете имя, параметры, двоеточие, она теперь будет знать, что сделать.
3207.44 3212.84 "Игорь Лабутин" И самое главное, всякие разные аналайзеры и фиксеры на тему того, что там все правильно в раутах написано.
3212.84 3215.52 "Игорь Лабутин" Это же просто строчки, ошибиться там очень можно легко.
3215.52 3222.52 "Игорь Лабутин" То есть там можно забыть закрыть скобочки, можно указать несколько параметров с одним и тем же именем, пока вы копипастите маршрут.
3222.52 3230.72 "Игорь Лабутин" Можно указать catch all параметра, который со звездочкой, но после этого продолжить какой-то маршрут писать, который на самом деле уже ни на что влиять не будет.
3230.72 3251.12 "Игорь Лабутин" В общем, завезли некоторое количество аналайзеров, фиксеров, и все это, что хорошо, не просто фичи, там вижу, в студии, а это упаковано в стандартные розлиновские аналайзеры, поэтому все IDE, которые умеют с ними работать, ну и райдеры, и студии это понятное дело умеют, они все это в общем-то получат и смогут использовать.
3251.12 3257.52 "Игорь Лабутин" Поэтому кажется, что все эти аналайзеры надо обязательно использовать, чтобы в раутах не ошибаться.
3257.52 3274.52 "Анатолий Кулаков" Билли лучше бы простили эти раутеры уже давно, потому что мы сейчас движемся в сторону source-генераторов, и там кажется, что вот эти всякие регулярные выражения в раутах, это какие-то тоже непонятные страшные костыли, по которым абсолютно невозможно предсказать, кто из них вызовется, когда вызовется.
3274.52 3277.24 "Анатолий Кулаков" В общем, это большое поле для ошибок.
3277.24 3290.12 "Игорь Лабутин" Все правильно, и даже более того, скажу опять, я, наверное, какой-то не настоящий программист, но мне очень редко требовалось что-то очень сложное, какие-то там хитрые вот эти вот параметры с масочками, ну типа ладно, типа я указывал, что это конкретно int в маршруте.
3290.12 3296.16 "Анатолий Кулаков" А зачем, у тебя же все равно в параметрах будет стоять int, если там будет не int, тебе сп это не пропустить.
3296.16 3308.48 "Игорь Лабутин" Я не помню, зачем это было, но что-то мне как-то надо было, вот типа я помню, что указывал, ничего другого по-моему я не использовал в параметрах, ну кроме стандартного контроллера в квадратных скобочках, это наверное все использовали, это дефолтная штука.
3308.48 3338.72 "Анатолий Кулаков" Ну вот я тоже не использую, даже контроллеры не использую, а по той простой причине, что когда ты запускаешь какой-нибудь URL, особенно в приложении, в котором сам понятия не имеешь, и хочешь найти этот URL, какой контроллер вызывает, ну чтобы там хотя бы бряку поставить на action методе, то его невозможно найти, если ты пользуешься вот этими магическими названиями класса, контроллерами, action методами, поэтому я предпочитаю всегда просто над action методом полностью указывать URL, по которому этот action метод доступен.
3338.72 3352.16 "Анатолий Кулаков" И я тогда могу просто скопировать строчку из браузера, поиском по студии ее тупо по тексту поискать, найти этот атрибут, который мапится в конкретный метод, поставить в метод бряку и наслаждаться жизнью.
3352.16 3355.36 "Анатолий Кулаков" Без всяких там регексов, звездочек, без ничего вообще.
3355.36 3359.20 "Игорь Лабутин" Ну да, ты прав, так и надо делать.
3359.20 3362.28 "Игорь Лабутин" Чем прямее и явнее, тем в общем-то лучше.
3362.28 3365.68 "Игорь Лабутин" Но зачем-то Майкрософт придумал 18 видов constraints.
3365.68 3369.40 "Анатолий Кулаков" Ну потому что SP копировался с Ruby и там так принято.
3369.40 3370.40 None Хорошо.
3370.40 3378.08 "Анатолий Кулаков" Просто мне непонятно, зачем они это развивают, мне казалось, наоборот, надо прикидить к чертовой матери и пытаться от этого убежать подальше.
3378.08 3379.72 "Игорь Лабутин" Переписать тут заново еще раз.
3379.72 3381.96 "Анатолий Кулаков" Это надо было тогда в Core делать.
3381.96 3385.44 "Анатолий Кулаков" А Minimal API же переписывают.
3385.44 3387.44 "Игорь Лабутин" Ну в Minimal API согласен, да.
3387.44 3391.40 "Игорь Лабутин" Но при этом почти все примеры как раз на Minimal API.
3391.40 3392.40 "Анатолий Кулаков" Да?
3392.40 3393.40 "Анатолий Кулаков" Там по-моему уже попроще.
3393.40 3398.76 "Анатолий Кулаков" Они не такие навороченные, я надеюсь, что их не будут все-таки делать такими навороченными, звездочки всякие туда запихивать.
3398.76 3399.76 "Анатолий Кулаков" Можно, можно.
3399.76 3402.56 "Игорь Лабутин" Вот в статье как раз примеры на Minimal API с звездочками.
3402.56 3407.84 "Анатолий Кулаков" С звездочками, ну тогда, к сожалению, не восприняли меня всерьез и игнорируют.
3407.84 3411.72 "Игорь Лабутин" Хотя не очень понимаю, действительно, зачем там всякие звездочки, кочелы и вот это все.
3411.72 3412.72 "Игорь Лабутин" Странная штука.
3412.72 3413.72 "Игорь Лабутин" Ладно, давай дальше.
3413.72 3419.20 "Игорь Лабутин" Дальше у нас закончим, наверное, с Microsoft на сегодня.
3419.20 3420.88 "Анатолий Кулаков" Попытаемся уйти от АСП.NET.
3420.88 3422.56 "Анатолий Кулаков" Ну давай попробуем.
3422.56 3423.76 "Анатолий Кулаков" Давай попробуем.
3423.76 3429.60 "Анатолий Кулаков" И в этом нам поможет неперезаденный технический писатель новоявленный Евгений Пешков.
3429.60 3442.16 "Анатолий Кулаков" Женя выпустил еще одну прекрасную статью, и мы не могли просто пройти мимо, потому что, как всегда, написано великолепно, техническая глубина хорошая, ну и полезность просто неоспоримая, поэтому все должны об этом знать.
3442.16 3447.88 "Анатолий Кулаков" Давайте мы с вами обсудим, что такое RAPULE, какие они бывают и зачем они нужны.
3447.88 3459.64 "Анатолий Кулаков" Итак, как вы знаете, у нас .NET язык с автоматическим Garbage Collection, поэтому обычно мы не думаем о том, откуда появляются типы и куда они исчезают.
3459.64 3467.60 "Анатолий Кулаков" Для нас это все прозрачно, красиво, и это сильно выделяет нас по сравнению с другими языками, у которых Garbage Collection нет.
3467.60 3469.92 "Анатолий Кулаков" И в плане, конечно же, удобства.
3469.92 3479.52 "Анатолий Кулаков" Но иногда мы все-таки вынуждены задумываться о том, что у нас бывают аллокации, что у нас бывают деструкторы, какие-то освобождения памяти.
3479.52 3486.96 "Анатолий Кулаков" И к этому мы обычно приходим, когда ощущаем большую нагрузку на сборщик мусора.
3486.96 3496.64 "Анатолий Кулаков" То есть это уже после какого-нибудь профайлинга, скорее всего, вы заметите, и увидите, что сборщик мусора старается, создает много объектов, удаляет много объектов.
3496.64 3500.84 "Анатолий Кулаков" Кстати, создание в Дотнете мега-быстрое, вы даже не заметили.
3500.84 3503.84 "Анатолий Кулаков" А вот удаление, да, с удалением проблемы.
3503.84 3509.76 "Анатолий Кулаков" Когда вы такую ситуацию себе найдете, первое, что вам должно прийти на ум, это не поможет ли вам случайно пулинг.
3509.76 3518.44 "Анатолий Кулаков" Пулинг – это как раз-таки переиспользование каких-то объектов для того, чтобы не создавать новый, не удалять старый.
3518.44 3520.80 "Анатолий Кулаков" То есть по сути не напрягать Garbage Collector вообще.
3520.80 3529.56 "Анатолий Кулаков" И вот когда мы говорим про оптимизацию Дотнета, в последнее время очень часто используется пулинг как такая очень хорошая система для оптимизации.
3529.56 3535.80 "Анатолий Кулаков" Ну, например, есть у вас, допустим, какой-нибудь стринг-билдер, который билдит огромные-огромные запросы.
3535.80 3544.00 "Анатолий Кулаков" Вот возвращаете вы из того же ASP.NET огромные HTML-странички и билдите их с помощью стринг-билдера какого-нибудь.
3544.00 3552.04 "Анатолий Кулаков" Забилдили, потом на каждый запрос создавать новый стринг-билдер, а самое главное потом его выбрасывать, это очень расточительно.
3552.04 3557.76 "Анатолий Кулаков" Но и держать их все в памяти тоже очень расточительно, потому что опять же странички могут быть очень большими.
3557.76 3561.80 "Анатолий Кулаков" Поэтому у стринг-билдера появился такой метод, как Clear по-моему называется.
3561.80 3568.44 "Анатолий Кулаков" Но суть его в том, что он полностью чистит все то, что стринг-билдер там насобирал, освобождает все его буферы и готовит.
3568.44 3570.48 "Анатолий Кулаков" Даже буфер не освобождает, буфер чистит.
3570.48 3576.44 "Анатолий Кулаков" В общем, оно, у него уже приаллокичены все его параметры внутренние, у него уже приаллокичена вся память.
3576.44 3580.00 "Анатолий Кулаков" И в следующий раз, когда в него пойдут писать строки, он не будет аллокитить никакой памяти.
3580.00 3584.88 "Анатолий Кулаков" Он уже готов, он уже прогрет, просто в нем нет никаких данных и он готов воспринимать что-то новое.
3584.88 3594.00 "Анатолий Кулаков" И вот такой метод Clear, метод Reset, метод Repeat, он появился во многих классах после того, как начали оптимизировать как раз ISP.NET.
3594.00 3601.96 "Анатолий Кулаков" У стримов, по-моему, таких очень много есть, у буферных стримов, конечно, очень много таких есть методов.
3601.96 3610.12 "Анатолий Кулаков" Короче, метод, функция переиспользования каких-то классов без того, чтобы их создавать много-много раз, она вот очень полезна на практике.
3610.12 3612.96 "Анатолий Кулаков" И вот эту функцию как раз эксплуатирует Pulling.
3612.96 3623.12 "Анатолий Кулаков" Pulling – это такое некое хранилище объектов, которое можно достать из этой сумки, из этого пула, поиспользовать и вернуть обратно в этот пул.
3623.12 3627.76 "Анатолий Кулаков" То есть задекларировать то, что больше вам не нужен, его можно обратно кому-нибудь другому отдать.
3627.76 3640.92 "Анатолий Кулаков" И в .NET есть встроенный, даже не класс, встроенный такой абстрактный класс, интерфейс, некий ArrayPool от T. И у него есть несколько имплементаций, несколько реализаций.
3640.92 3644.16 "Анатолий Кулаков" Вообще, Pulling можно сравнить с аллокацией объектов.
3644.16 3653.20 "Анатолий Кулаков" То есть если вы представите память компьютера, и когда вы хотите создать какой-то класс, то в этой памяти компьютера выделяется небольшой блок под данные вашего класса.
3653.20 3661.64 "Анатолий Кулаков" После того, как вы класс заиспользовали, Garbage Collector собирает ваш класс, то есть по сути он отпускает вот этот блок в памяти, и память становится свободной.
3661.64 3670.36 "Анатолий Кулаков" Соответственно, чем больше ваше приложение юзает, тем больше оно памяти жрет, чем больше Garbage Collector собирает и освобождает ресурсов, тем меньше ваше приложение жрет.
3670.36 3676.68 "Анатолий Кулаков" То есть оперативная память, или диская память, не суть важно, любая память, она является своего рода таким вот Pulling.
3676.68 3681.44 "Анатолий Кулаков" И самая главная вещь над этим Pulling, это вот как раз алгоритм, как он работает.
3681.44 3687.28 "Анатолий Кулаков" И нормальные современные фреймворки, когда вы отпускаете память, на самом деле операционной системе ее не возвращают.
3687.28 3688.28 "Анатолий Кулаков" Они ее держат.
3688.28 3694.84 "Анатолий Кулаков" Потому что в большинстве случаев, приложение ваше пойдет работать дальше, и ему понадобится эта память для каких-нибудь других объектов.
3694.84 3696.64 "Анатолий Кулаков" Вот они его точно так и Pulling.
3696.64 3697.64 "Анатолий Кулаков" Они его сразу не отпускают.
3697.64 3700.00 "Анатолий Кулаков" Но мы немножко отдалились.
3700.00 3704.12 "Анатолий Кулаков" Pulling очень похож на аллокаторы объектов.
3704.12 3710.28 "Анатолий Кулаков" Также Pulling очень похож на такой дизайн-паттерн, как фабрика.
3710.28 3715.28 "Анатолий Кулаков" В фабрике обычно есть два метода – Create и Release, который вам создает объект и релизит объект.
3715.28 3716.28 "Анатолий Кулаков" Опять же, наш Pulling.
3716.28 3721.64 "Анатолий Кулаков" Дай мне какой-нибудь стаб и верни обратно этот стаб в Pulling.
3721.64 3735.92 "Анатолий Кулаков" И если вы в принципе юзаете однопоточный код, и у вас какой-то банальный алгоритм, которому хватает всего навсего одной заглушки, то очень часто делают просто приватное поле, допустим, с тем же самым StringBuilder.
3735.92 3741.72 "Анатолий Кулаков" И так как у нас поток один, никаких проблем нет, мы зашли в этот класс, в этом приватном поле.
3741.72 3746.16 "Анатолий Кулаков" StringBuilder уже разогрет, у него все буферы есть, мы его используем и возвращаемся из него.
3746.16 3748.88 "Анатолий Кулаков" Следующий поток зашел.
3748.88 3753.88 "Анатолий Кулаков" В общем, для кэшап, самым примитивным кэшом может служить всего-навсего одно приватное поле.
3753.88 3756.80 "Анатолий Кулаков" Если вы можете себе это позволить, это прям сразу ваш вариант.
3756.80 3765.68 "Анатолий Кулаков" Если же вам нужно хранить несколько объектов, то есть это не одно поле, то вполне подойдут такие структуры, как Queue или Stag.
3765.68 3771.44 "Анатолий Кулаков" Если же у вас многопоточный все-таки код, то здесь вам может понадобиться ConcurrentQueue.
3771.44 3779.88 "Анатолий Кулаков" И ConcurrentQueue – это в принципе довольно хорошая реализация, в частности используют Default Object Pool из пакета Microsoft Extension Object Pool.
3779.88 3783.64 "Анатолий Кулаков" В общем, по дефолту это вполне нормальная реализация.
3783.64 3795.12 "Анатолий Кулаков" Но есть более сложные ситуации, где вам нужна и параллельность, и следить за размером полов, и еще доступаться из множества потоков эффективно.
3795.12 3799.00 "Анатолий Кулаков" И тут уже идет вход в класс ArrayPool.
3799.00 3807.32 "Анатолий Кулаков" В .NET есть две абстрактных наследника сейчас на данный момент от ArrayPool.
3807.32 3814.96 "Анатолий Кулаков" Во-первых, первая получается с помощью метода ArrayPool.create, а вторая расшаренная с помощью статического свойства ArrayPool.shared.
3814.96 3830.16 "Анатолий Кулаков" И после того, как вы получили этот пул, вы, соответственно, можете у него запросить, так как это ArrayPool, вы можете у него запросить массив определенного размера.
3830.16 3841.12 "Анатолий Кулаков" И тут интересный момент, что когда вы вызываете метод rent, который дает вам массив, указываете им какой-то размер, то вам возвращается массив такого размера, как вы запросили, или больше.
3841.12 3848.64 "Анатолий Кулаков" Это нужно для того, чтобы их оптимально хранить, потому что хранить массивы различных размеров – это довольно большая фрагментация у вас будет.
3848.64 3859.12 "Анатолий Кулаков" Поэтому Framework обычно выравнивает все массивы по степени двойки и вернет вам ближайший массив, в который влезет тот размер, который вы запросили.
3859.12 3860.56 "Анатолий Кулаков" Вот это небольшая тонкость.
3860.56 3868.32 "Анатолий Кулаков" Итак, прежде чем, если у нас есть три, даже два, пока два ArrayPool, нам нужно бы понять, а какой из них использовать.
3868.32 3881.20 "Анатолий Кулаков" Женя сделал многопоточный бичмарк, в котором в первом ArrayPool он побичмаркал первый ArrayPool, который достается с помощью метода create, который shared.
3881.20 3894.60 "Анатолий Кулаков" И третий бичмарк такой был референсный, это с помощью new, то есть полностью без pool, с помощью ключевого слова new, он создавал объекты и просто-напросто про них забывал.
3894.60 3897.08 "Анатолий Кулаков" То есть возложил полностью все на Garbage Collection.
3897.08 3906.96 "Анатолий Кулаков" И у него получились цифры, которые в принципе, само значение не нужно, тут главное, чтобы вы понимали саму суть, то есть само относительное значение.
3906.96 3911.88 "Анатолий Кулаков" New, обычный, без pooling, занимает примерно 70 миллисекунд.
3911.88 3919.00 "Анатолий Кулаков" Опять же, в его каких-то алгоритмах, естественно, расшаренный массив занимает 14 миллисекунд.
3919.00 3920.88 "Анатолий Кулаков" Там 70, тут 14.
3920.88 3929.56 "Анатолий Кулаков" И pool, который получается с помощью create, занимает 170 миллисекунд, то есть почти в 10 раз больше, чем shared.
3929.56 3932.48 "Анатолий Кулаков" Казалось, зачем такой медленный и ужасный pool нужен?
3932.48 3933.48 "Анатолий Кулаков" Оказывается, нужен.
3933.48 3935.44 "Анатолий Кулаков" Давайте теперь разбираться подробнее.
3935.44 3947.16 "Анатолий Кулаков" Итак, с помощью метода create, вот этот самый, самый медленный pool, который получается, у него поправили имплементацию, которая называется Configurable ArrayPool.
3947.16 3950.56 "Анатолий Кулаков" Реализуется она довольно просто.
3950.56 3957.32 "Анатолий Кулаков" Там массивы в пуле сгруппированы по размерам, как я уже сказал, чтобы по разной размере не давали дефоргументацию.
3957.32 3961.24 "Анатолий Кулаков" Размеры, у них всегда степень двойки, таким образом они выравниваются.
3961.24 3964.44 "Анатолий Кулаков" Массивы одного размера хранятся, соответственно, в одном списке.
3964.44 3973.72 "Анатолий Кулаков" И каждый список защищен от многопоточного доступа, для того, чтобы несколько потоков сразу не пытались промодифицировать, грубо говоря.
3973.72 3975.76 "Анатолий Кулаков" Защищается он с помощью спинлока.
3975.76 3983.48 "Анатолий Кулаков" И вот из-за этой самой блокировки в нашем многопоточном тесте как раз и была вот эта огромная просадка в производительности.
3983.48 3989.68 "Анатолий Кулаков" И поэтому на множестве потоков этот pool себя ведет не очень хорошо.
3989.68 3996.60 "Анатолий Кулаков" В отличие от него Shared ArrayPool, это тот второй, который получается из статического свойства Shared.
3996.60 4004.60 "Анатолий Кулаков" Во-первых, это статическое свойство, то есть он разделяется во всем вашем приложении, используется один и тот же pool.
4004.60 4010.16 "Анатолий Кулаков" А с помощью метода кредита вы можете создать свой pool.
4010.16 4017.32 "Анатолий Кулаков" Он реализуется с помощью класса, который называется TLS OverPureCoreLockedStackArrayPool.
4017.32 4022.20 "Анатолий Кулаков" Что нам здесь интересно?
4022.20 4025.48 "Анатолий Кулаков" Во-первых, TLS в названии, это означает Thread Local Storage.
4025.48 4034.00 "Анатолий Кулаков" То есть это понятно, что он будет использовать какой-то Thread Local переменные для того, чтобы хранить свой кэш.
4034.00 4037.40 "Анатолий Кулаков" И это отчасти правда, потому что у него есть два уровня.
4037.40 4042.60 "Анатолий Кулаков" И первый уровень это как раз-таки вот этот локальный набор массивов для каждого потока.
4042.60 4050.92 "Анатолий Кулаков" То есть каждый поток уже не берет блокировку, как было в предыдущем случае, для того чтобы достать себе массив из нашего pool.
4050.92 4062.08 "Анатолий Кулаков" А он просто обращается к Thread Local переменной, достает оттуда тот массив, если он свободен, естественно, тот массив, который есть у этой Thread Local переменной и полностью без блокировок вам его возвращает.
4062.08 4065.16 "Анатолий Кулаков" Это конечно хорошо, потому что не требует синхронизации с другими потоками.
4065.16 4070.88 "Анатолий Кулаков" Локально хранится максимум один массив, каждого размера, естественно.
4070.88 4072.68 "Анатолий Кулаков" Вот какой размер есть, вот такой локальный хранится.
4072.68 4078.40 "Анатолий Кулаков" Если мы на первом уровне не нашли одного массива или он уже там, например, занят, мы провалимся на второй уровень.
4078.40 4089.04 "Анатолий Кулаков" Второй уровень уже тут приходится разделяться между несколькими потоками, то есть это уже общая какая-то сумка, в которую все потоки приходят, обращаются и каким-то образом достают свои массивы.
4089.04 4095.04 "Анатолий Кулаков" Но для каждого размера хранится не один список массивов, а несколько списков.
4095.04 4100.92 "Анатолий Кулаков" Таким образом, и количество этого списка зависит от логических ядер.
4100.92 4114.60 "Анатолий Кулаков" Таким образом, у нас, когда мы пытаемся достать какой-то массив, уже не один лог берется на всю эту группу массивов, а берется какой-то уже логический лог на какую-то часть.
4114.60 4117.20 "Анатолий Кулаков" И контент немножко от этого уменьшается.
4117.20 4122.12 "Анатолий Кулаков" И каждый такой список защищается блокировкой.
4122.12 4128.16 "Анатолий Кулаков" И, соответственно, достигается с помощью вот такой вот хороший результат, который мы видели на бичмарках.
4128.16 4133.48 "Анатолий Кулаков" Из-за того, что разные блокировки, они не дерутся за один список, а более-менее эта вся нагрузка размазывается.
4133.48 4145.56 "Анатолий Кулаков" Итак, теперь давайте рассмотрим проблемы, которые бывают с нашим вот этим быстрым, красивым и якобы самым оптимальным вариантом, двухуровневым пулом.
4145.56 4152.04 "Анатолий Кулаков" Прежде всего, локальный набор массивов для каждого потока, он имеет свою цену.
4152.04 4160.28 "Анатолий Кулаков" Цена эта заключается в том, что раз он локален для каждого потока, значит между потоками не происходит переиспользование этих массивов.
4160.28 4162.96 "Анатолий Кулаков" Соответственно, у нас немножко размывается понятие пулинга.
4162.96 4174.20 "Анатолий Кулаков" Если мы думаем, что мы в пул взяли объект, вернули объект, а потом из второго потока обратились снова к пулу и нам вернется этот уже пустой объект, никому не нужный, то нет, это не так.
4174.20 4186.92 "Анатолий Кулаков" Потому что этот следующий пул может попасть на другой тред и в этом треде, в локал сторидже у него, в тред сторидже, у него не будет никакого значения, никакого стаба и он создаст новый.
4186.92 4201.96 "Анатолий Кулаков" От этого может произойти, как раз таки может создаваться очень большое количество крупных массивов, которые на самом деле можно было бы переиспользовать, но так как они лежат в тред сториджах разных потоков, они не переиспользуются, а только раздувается память.
4201.96 4208.52 "Анатолий Кулаков" Соответственно, чтобы избежать этой раздутии памяти существует так называемая очистка памяти.
4208.52 4211.32 "Анатолий Кулаков" Очистка памяти делается при сборке мусора.
4211.32 4214.60 "Анатолий Кулаков" И там есть интересный хак с финализаторами.
4214.60 4224.08 "Анатолий Кулаков" То есть авторы ловят финализатор, который вызывается при сборке мусора и в этом финализаторе пытаются очистить те массивы, которые по их мнению якобы не нужны.
4224.08 4227.08 "Анатолий Кулаков" Это не всегда то, что хочется в вашем приложении.
4227.08 4231.56 "Анатолий Кулаков" Потому что вы все-таки рассчитываете, что у вас там есть огромные массивы и они не будут зря пересоздаваться.
4231.56 4232.88 "Анатолий Кулаков" Вы хотите их переиспользовать.
4232.88 4234.96 "Анатолий Кулаков" Но именно для этого вы пулы используете.
4234.96 4243.24 "Анатолий Кулаков" Если вдруг garbage collector когда-нибудь придет и вот эти массивы посчитает вам ненужными и перетрет, то это приведет к преждевременному удалению больших массивов.
4243.24 4248.04 "Анатолий Кулаков" Что отразится на large object heap.
4248.04 4249.36 "Анатолий Кулаков" Соответственно будет фрагментация кучи.
4249.36 4254.48 "Анатолий Кулаков" Фрагментация кучи это тоже довольно плохая штука, которая может привести к большим замедлениям.
4254.48 4262.88 "Анатолий Кулаков" И вот зная вот эти тонкости вы можете отлавливать такие моменты и примерно предсказывать, что может случиться, какие будут проблемы с вашим пулом.
4262.88 4276.88 "Анатолий Кулаков" Также нужно не забывать, что существует большая проблема, как только мы переходим на пулы, у нас существует большая проблема в том, что мы должны не только брать оттуда какие-то объекты, но и отдавать их туда.
4276.88 4285.68 "Анатолий Кулаков" Так как мы привыкли, что за нас всю проблему по очистке делает garbage collector, может быть это неинтуитивно понятно каждому разработчику, но отдавать их туда обязательно надо.
4285.68 4306.24 "Анатолий Кулаков" Потому что если мы их туда не будем отдавать, то когда мы будем проваливаться на второй уровень кэширования, то есть каждый поток будет использовать больше чем один ядер, больше чем одно ядро, мы будем по кругу искать свободный пул, то есть свободный массив.
4306.24 4316.18 "Анатолий Кулаков" И когда мы ищем свободный массив, для этого мы на каждой списке, этих списков у нас несколько, но мы будем на каждом из этих списков по очереди брать лог.
4316.18 4320.02 "Анатолий Кулаков" То есть мы взяли лог, поискали массивчик, не нашли.
4320.02 4327.38 "Анатолий Кулаков" Если мы не отпускаем, не возвращаем их в пул, мы возьмем лог на другом массиве, поискали, не нашли и так далее.
4327.38 4333.34 "Анатолий Кулаков" То есть мы будем перебирать абсолютно все массивы, если вдруг нам не будут эти массивы возвращать обратно в пул.
4333.34 4344.50 "Анатолий Кулаков" И соответственно каждый вариант, то есть каждый запрос на массив, он будет захватывать все блокировки до того, когда создаст нам новый массив и вернет.
4344.50 4347.66 "Анатолий Кулаков" То есть до этого он будет захватить все блокировки и пройдется по всем спискам.
4347.66 4350.18 "Анатолий Кулаков" И это тоже приводит к большому контеншену.
4350.18 4360.94 "Анатолий Кулаков" Если ваш пул будет опустошаться и не возвращаться туда все ваши стабы, то это тоже придет к большому контеншену и может быть еще хуже, чем без него.
4360.94 4363.34 "Анатолий Кулаков" Как же такие проблемы можно выяснять?
4363.34 4371.04 "Анатолий Кулаков" К счастью, есть несколько полезных событий, встроенных, которые можно промониторить с помощью стандартных событий.
4371.04 4374.84 "Анатолий Кулаков" Например, System Buffer Array Pool Event Source.
4374.84 4382.36 "Анатолий Кулаков" Вот такое полезное событие, которое как раз-таки помогает вам следить о выделении памяти.
4382.36 4388.12 "Анатолий Кулаков" Например, событие Buffer Allocated вызывается, когда аллоцируется много новых массивов.
4388.12 4394.64 "Анатолий Кулаков" То есть если аллоцируется много новых массивов, это значит, что ваш пул работает неэффективно.
4394.64 4398.72 "Анатолий Кулаков" То есть в нем не переиспользуются объекты, которые должны переиспользоваться.
4398.72 4400.24 "Анатолий Кулаков" Почему они могут не переиспользоваться?
4400.24 4401.24 "Анатолий Кулаков" Смотрите выше.
4401.24 4410.68 "Анатолий Кулаков" Далее, вторая проблема – это с лококонтеншеном, за которым тоже нам нужно обязательно следить, не только в Array Pool, но и во многих других ситуациях.
4410.68 4416.76 "Анатолий Кулаков" И там есть событие Microsoft Windows.NET Runtime – Contention Start.
4416.76 4420.44 "Анатолий Кулаков" За ним тоже можно мониторить и каким-то образом на него реагировать.
4420.44 4425.72 "Анатолий Кулаков" Это очень важно, если вы отсортируете их именно по вашим Array Pools.
4425.72 4435.72 "Анатолий Кулаков" И так, в критичных для производительности местах, например, в .NET Runtime, Женя подмечает, что Microsoft очень часто использует свои собственные пулы.
4435.72 4452.16 "Анатолий Кулаков" То есть он не те, которые нам предлагают для общего пользования, а какие-то собственные структуры, какие-то оптимизированные именно для тех ситуаций, которые встречаются только здесь, не отвлекаясь на всякие посторонние моменты, не пытаясь учесть все женериковые случаи.
4452.16 4454.80 "Анатолий Кулаков" И кажется, что это самый оптимальный и самый лучший вариант.
4454.80 4466.36 "Анатолий Кулаков" Если вы четко разбираетесь, как эти пулы работают, четко понимаете, зачем были сделаны те или иные хаки, вы вполне можете написать свой пул для той ситуации, которая подходит именно вашему приложению.
4466.36 4472.84 "Анатолий Кулаков" Поэтому чем лучше вы понимаете профиль нагрузки вашего приложения, тем эффективнее стратегию вы сможете выдумать и ее реализовать.
4472.84 4480.40 "Анатолий Кулаков" Также вам нужно не забывать, что одна из главных проблем вселенной – это инвалидация кэша.
4480.40 4486.92 "Анатолий Кулаков" То есть вам нужно четко задуматься о том, какого размера у вас может быть кэш, кто его будет чистить, когда его будет чистить.
4486.92 4508.16 "Анатолий Кулаков" И это довольно важная проблема, поэтому обязательно, когда вы будете использовать пулы, обязательно задумайтесь о том, какая вместимость этих пулов, то есть сколько там этих массива может быть залокетиться и как часто вам нужно все-таки ваш пул уменьшать в размерах.
4508.16 4525.76 "Анатолий Кулаков" Если у вас вдруг подходит вам пул с неограниченной вместимостью, то есть вы знаете, что у вас там никакого большого размера не будет, все примерно где-то там разбирается, все успевается, то можно прям рассмотреть самый примитивный подход – это concurrent queue, без всяких там дополнительных оберток сверху над этим.
4525.76 4528.80 "Анатолий Кулаков" Это вполне хорошая структура, как я уже говорил выше, для этих задач.
4528.80 4543.56 "Анатолий Кулаков" Если же вам все-таки нужно каким-то образом следить за размерами, то тут уже нужно думать, подбирать и смотреть какие-то варианты, которые там или реализованы, или самому попридумывать в зависимости от вашей ситуации.
4543.56 4549.44 "Анатолий Кулаков" Может быть, все настолько сложно в реализации вашей, что гораздо проще положиться на сборщик мусора.
4549.44 4567.36 "Анатолий Кулаков" Опять же, не нужно забывать, что сборщик мусора пишут гениальные люди, делают они это уже не первый год, у них там опыт очень большого числа, имплементации там в других языках, большое количество пейперов и так далее, и это очень эффективная штука.
4567.36 4573.12 "Анатолий Кулаков" Она справляется с огромными нагрузками, поэтому может быть вам пулы не нужны и гарбеж коллектор справится на ура.
4573.12 4578.84 "Анатолий Кулаков" Или можно попытаться снизить нагрузку на гарбеж коллектор другими свойствами, не пулингом.
4578.84 4591.68 "Анатолий Кулаков" Например, структурами, стеколоком, спанами, мемориями и прочими другими интересными штуками, которые опять же в последних релизах появляются довольно много в нашем фриворке и довольно много интересных статей про них выходит.
4591.68 4603.00 "Анатолий Кулаков" Вот такая статейка, которая знакомит нас с работой стандартных репуллов, с их проблемами, с их алгоритмами и соответственно рассказывает, что можно от них ожидать, чего бояться, чего не нужно.
4603.00 4607.68 "Анатолий Кулаков" Мне кажется, довольно полезная, техническая и интересная чтива.
4607.68 4615.28 "Анатолий Кулаков" Если хотите подробностей, битчмарков, цифр конкретного кода, то ссылка будет в описании, обязательно пройдите к оригиналу и ознакомьтесь.
4615.28 4618.36 "Игорь Лабутин" Да, тема с пулами действительно очень интересная.
4618.36 4624.00 "Игорь Лабутин" У меня было пару эпизодов, когда я как раз таки следил за всеми этими событиями, там buffer allocated.
4624.00 4630.84 "Игорь Лабутин" И там я, кстати, хочу подметить еще одну штуку, которая тоже важна при работе с этими пулами.
4630.84 4634.80 "Игорь Лабутин" У них у всех есть максимальный размер массива, который в них есть.
4634.80 4657.48 "Игорь Лабутин" И если вы, например, аллоцируете, ну то есть вам приходит, например, какой-то запрос, вы там что-нибудь считаете, что для его обработки нужно какого-то размера массив byte, и вы идете в пул и просите такой массив byte, то вот если вы в вашем подсчете получите размер, который больше, чем максимальный размер массива, который лежит в пуле, пул просто за вас сделает new.
4657.48 4666.04 "Игорь Лабутин" И я вот как раз с помощью этих самых ивентов ловил buffer allocated события, там есть на самом деле несколько причин почему.
4666.04 4670.52 "Игорь Лабутин" То есть прямо в этом ивенте есть флажок типа "почему он allocated".
4670.52 4679.68 "Игорь Лабутин" Там есть причина типа нету, то есть размер-то подходящий, но у нас нет свободных массивов, а есть причина, что что-то очень большой размер запросили.
4679.68 4691.92 "Игорь Лабутин" И это тоже важно, потому что в моем первой реализации у нас так получилось, что мы решили, что мы точно влезем в megabyte, и пул был настроен так, что максимальный размер массива был megabyte.
4691.92 4695.44 "Игорь Лабутин" Так получалось, что нам всегда нужно было аллоцировать почти всегда полтора megabyte.
4695.44 4698.76 "Игорь Лабутин" Поэтому пул конечно был, но это был по сути просто new всегда.
4698.76 4709.72 "Игорь Лабутин" А самое главное, когда он делает возврат этого массива обратно, если он понимает, что вы возвращаете в пул массив, который больше, чем его максимальный размер, он его просто выкидывает.
4709.72 4714.32 "Игорь Лабутин" То есть фактически пул работал просто как прослойка для garbage-коллектора и ничего больше.
4714.32 4717.56 "Анатолий Кулаков" Да, хороший кейс вообще.
4717.56 4725.04 "Анатолий Кулаков" Такие ситуации кажется можно ставить на какой-нибудь автоматический алертинг по этим событиям, то есть такого в нормальном приложении быть не должно.
4725.04 4726.64 "Игорь Лабутин" Да, да, да, да, да.
4726.64 4734.08 "Игорь Лабутин" Я просто, ну то есть идея была, там-то был прям конкретный кейс, окей, у нас большое потребление памяти без пула, давайте добавим пул.
4734.08 4737.72 "Игорь Лабутин" Добавили пул, потребление памяти не изменилось вообще.
4737.72 4740.80 "Игорь Лабутин" Пошел смотреть на ивент и понял, что ну ошиблись с размером.
4740.80 4746.92 "Игорь Лабутин" Кто-то сказали, что типа окей, у нас максимальный размер объектов пуля 2 megabyte, сразу да, стало все использоваться.
4746.92 4756.44 "Игорь Лабутин" Ну дальше там уже тюнили размер с точки зрения, чтобы вот этот буфер located уже не летело с событием, с флажком, потому что типа объекты кончились.
4756.44 4764.04 "Игорь Лабутин" Так что это самый, ивенты там дельные, хорошие, можно все понимать, смотреть по ним, все прекрасно работает.
4764.04 4765.04 None Так.
4765.04 4766.04 "Игорь Лабутин" Красота.
4766.04 4772.72 "Анатолий Кулаков" Я вижу, нам не удалось отвязаться от SPNet API, да?
4772.72 4773.72 "Анатолий Кулаков" Да.
4773.72 4774.72 "Анатолий Кулаков" SPNet Core.
4774.72 4792.68 "Игорь Лабутин" Ну и на самом деле немножко затронули уже сегодня, я сегодня когда рассказывал про source-гены для реквест-делегатов, что сделали в SPNet Core для того, чтобы приблизиться к поддержке native auto для minimal API, то мы уже рассказали, что вот этот реквест-делегат generator поменяли на source-gen.
4792.68 4810.28 "Игорь Лабутин" А у нас есть серия статей от Andrew Locke, нашего значит горячо любимого, это аж 8, если не ошибаюсь, статей, где он детальнейшим образом рассказывает жизненный цикл того, как собственно происходит вызов этих ваших лямбдочек в minimal API в момент, когда к вам пришел реквест.
4810.28 4819.16 "Анатолий Кулаков" Представляешь, Microsoft заперел генератор, теперь ему придется все эти статьи переписывать, больше это не так.
4819.16 4823.00 "Игорь Лабутин" Да, кстати, на самом деле я об этом не думал, действительно.
4823.00 4825.00 "Игорь Лабутин" Трудно быть Андрю Локком, да.
4825.00 4828.80 "Игорь Лабутин" Да, ну вот книжку написал, блин, новый дотонетт вышел, надо переписывать.
4828.80 4829.80 "Игорь Лабутин" Надо переписывать.
4829.80 4830.80 "Игорь Лабутин" Статьи написал, надо переписывать.
4830.80 4831.80 "Игорь Лабутин" В общем, интересно.
4831.80 4834.80 "Игорь Лабутин" Но смысл статей в чем?
4834.80 4848.56 "Игорь Лабутин" Мы сейчас не будем пересказывать все 8, это очень детальные, очень технические статьи, но смысл в том, что он говорит, ну, minimal API, типа, работают быстро, давайте поймем, как это делать, потому что там reflection немало, там немало вот этой вот логики про binding и всего остального.
4848.56 4862.32 "Игорь Лабутин" Соответственно, самая главная работа — это как сконвертировать лямбду в специальный инстанс делегата под названием request_delegate, построить, по сути, такой делегат, код которого будет вызывать лямбду.
4862.32 4878.56 "Игорь Лабутин" И там дальше рассказывается про то, что происходит, когда вы вызываете app.run, как строится граф всех endpoints, то есть вот по раутингу тому самому, да, строится граф, чтобы быстро понимать, в какой endpoint надо бежать, когда к вам пришел реальный запрос.
4878.56 4889.56 "Игорь Лабутин" Дальше из вашей лямбды нужно reflection — это отто, для чего, в частности, используется reflection — достать данные параметров, то есть все типы параметров и их имена.
4889.56 4919.68 "Игорь Лабутин" На них могут быть навешаны дополнительные атрибуты, какие-нибудь там from_services или еще что-нибудь, после чего там собираются expression trees для того, чтобы собирать аргументы из http-контекста, то есть у вас будет expression tree, который будет скомпилен в делегат, который будет принимать http-контекст и уметь собирать значения аргументов, то есть как раз именно внутри этого expression tree будет происходить вся магия байдинга, валидации и всего остального.
4919.68 4942.12 "Игорь Лабутин" Такой же expression tree делается для респонсов, потому что в респонсе вы можете просто вернуть строчку, можете вернуть какой-нибудь там ityped_result, можете вернуть еще какой-нибудь странный объект, ну там, page, например, если вдруг вы внезапно решили вернуть blazor-страничку или компоненту какую-нибудь, ее тоже надо корректно преобразовать в респонс с правильными там всякими content-тайпами и прочим.
4942.12 4956.76 "Игорь Лабутин" И дальше все написано, собственно, логику, после того, как все это собрали, как же все это вызвать в реальности, там тоже не так просто, не просто, типа создали делегат и вызвали, иначе это было бы довольно медленно, там есть приседания, чтобы это было все-таки быстро.
4956.76 4975.48 "Игорь Лабутин" Ну и последняя статья рассказывает про то, как к этому всему еще довешиваются фильтры, потому что надо не забывать, что вы не просто можете задать делегатик свой, точнее лямбда, который нужно выполнить, но еще и навесить произвольное количество фильтров, которые нужно выполнить перед и после, которые, конечно, добавляют радости в этот самый код генерацию.
4975.48 4978.20 "Игорь Лабутин" А теперь все это должно работать на source-генах.
4978.20 4986.88 "Игорь Лабутин" Я прям с интересом, что надо будет потом как-нибудь взять, посмотреть, что же там source-генерится-то такое, потому что это прям код должен быть очень интересным.
4986.88 4990.88 "Анатолий Кулаков" Ну да, по идее, все, что Энри описал словами, там должно теперь быть в коде.
4990.88 5021.36 "Игорь Лабутин" Ну он это описал прям, да, словами, кусочками кода, ссылками на GitHub, то есть вы в принципе должны быть в состоянии теперь полностью понять, как работает минимал-LGPI внутри, по крайней мере в части вызова конкретно делегатов, там понятно, что есть еще много разной магии, но вот часть вызова делегатов, она прям очень хорошо описана, поэтому если вам это интересно, если вам почему-то хочется разобраться, как это работает внутри или у вас тут не работает, вам интересно понять, куда, в какие места фреймворка ставить breakpoint, то вот вам туда, в эту статью читайте и изучайте.
5021.36 5039.12 "Анатолий Кулаков" Вот действительно я себя поймал на мысли, зачем я этого хочу, зачем я хочу этого знать, и вот действительно, правда, я часто дебажу вот эти pipeline все, ну то есть люди очень переусложняют их и засовывают, даже не обязательно люди, может кто-то middleware подключил, может кто-то какой-то внешний пакет подключил, который ставят фильтр middleware.
5039.12 5054.36 "Анатолий Кулаков" В общем, часто они все-таки нарушаются по непонятным причинам и бывает, бывают случаи, когда нужно залезть и поймать место, где оно прерывается, понять, почему это делается, и это бывает не так уж редко почему-то в моей практике.
5054.36 5065.40 "Игорь Лабутин" Ну, в общем, вот теперь ты можешь почитать всего-то 8 статей, они коротенькие, ну не очень на самом деле, с кучей кода, и быстренько-быстренько разобраться, если ты все это сможешь запомнить.
5065.40 5070.52 "Анатолий Кулаков" Ну вообще, Andrew Log пишет приятно, мне всегда его нравится читать, поэтому, да, я думаю, проблем не будет.
5070.52 5080.04 "Игорь Лабутин" Там все очень понятно, это точно, я не читал детально вообще все статьи, но те избранные, которые мне были интересны, они прям действительно хорошо читаются.
5080.04 5090.80 "Игорь Лабутин" Давай пойдем дальше, мы не можем пройти вимой темы, которая сейчас там, давай назовем это на хайпе везде, это OpenAI.
5090.80 5097.20 "Анатолий Кулаков" Да, мы долго сопротивлялись, сильно себя сдерживали, не произносили эти слова, но пора уже, пора.
5097.20 5106.24 "Игорь Лабутин" Вот, я так понимаю, что аж в стандартном .NET блоге вышла статья, там же, где публикуются всякие анонсы, так что, наверное, там что-то важное.
5106.24 5116.76 "Анатолий Кулаков" Ну, то есть мы не подавались на всякие маркетинговые уловки, но когда там рядом поставили OpenAI.in.net, но мы как профильный подкаст про .NET не могли промолчать.
5116.76 5122.88 "Анатолий Кулаков" Ну, давай разберемся, что же этот OpenAI делает с нашей современностью, с нашей жизнью и как он на нас влияет.
5122.88 5150.48 "Анатолий Кулаков" Итак, как вы, наверное, уже знаете, все последние месяцы или может быть уже годы нам прозужжали все уши про всякие машин ленинги, artificial intelligence и, в частности, компания OpenAI стреляла на этом рынке, так как не стрелял еще ни один стартап в мире, они собрали миллиарды пользователей за считанное количество месяцев и так далее.
5150.48 5152.56 "Анатолий Кулаков" Но нас это не очень волнует, нас больше интересует их прекрасный продукт.
5152.56 5163.00 "Анатолий Кулаков" И их прекрасный продукт интересует нас потому, что Microsoft очень плотно с ним работает, с этой компанией.
5163.00 5165.32 "Анатолий Кулаков" Я бы даже сказал, что она ее чуть ли не купила.
5165.32 5176.12 "Анатолий Кулаков" Ну, она там купила 49% акций, грубо говоря, и огромные условия на то, что там все будет работать на Azure, что они там будут очень много всего контролировать.
5176.12 5184.52 "Анатолий Кулаков" В общем, с такими условиями, что практически Microsoft является чуть ли не монополистом использования этой технологии.
5184.52 5193.28 "Анатолий Кулаков" И она будет в первую очередь внедрять ее в свои продукты, что, собственно, и произошло на недавнем анонсе от Microsoft.
5193.28 5199.04 "Анатолий Кулаков" OpenAI предоставил свои инструменты абсолютно для всего офисного пакета, например.
5199.04 5201.12 "Анатолий Кулаков" Начнем издалека.
5201.12 5203.76 "Анатолий Кулаков" Прежде всего заработала штука в Bing.
5203.76 5205.88 "Анатолий Кулаков" Насколько я помню, там сейчас все еще по приглашениям.
5205.88 5211.48 "Анатолий Кулаков" Ну, то есть, Bing теперь не просто поиск, Bing теперь поиск на основе чат GPT.
5211.48 5221.08 "Анатолий Кулаков" То есть, вы ему можете в диалоговом режиме давать какие-то дополнительные наводки, давать какие-то дополнительные требования, улучшать каким-то образом ваш поиск.
5221.08 5225.68 "Анатолий Кулаков" Можете его даже попросить сгенерить по текстовому описанию картиночки.
5225.68 5228.40 "Анатолий Кулаков" То есть, это сейчас тоже встроено довольно хорошо.
5228.40 5234.60 "Анатолий Кулаков" Также Microsoft анонсировал, что OpenAI и Toozie будут встроены во все продукты офиса.
5234.60 5238.20 "Анатолий Кулаков" Это так называемый Microsoft 365 Copilot.
5238.20 5246.76 "Анатолий Кулаков" Это помощник, ваш офисный помощник, который интегрирован абсолютно во все инструменты, в Word, Excel, PowerPoint, Outlook, Teams, вообще везде.
5246.76 5268.44 "Анатолий Кулаков" Он участвует, помогает вам ввести календарь, помогает вам писать и принимать почту, ввести диалоги в чате, работать с документами, собираться и напоминаться о митингах, управлять контактами, добавлять какое-то содержимое к вашим документам, к вашим чатам.
5268.44 5277.48 "Анатолий Кулаков" Может сделать какую-то выжимку из текста, которая вам нужна, или переписать ваши e-mail в более политкорректном или наоборот стиле.
5277.48 5295.24 "Анатолий Кулаков" Я всегда мечтал, что когда я пишу в код-ревью, пишу в WTF, чтобы пришел бот и вместо меня это разложил по со ссылочками, с источниками, с best practices, с красивыми интонациями, предложениями, в общем, что я все-таки имел в виду.
5295.24 5297.68 "Анатолий Кулаков" Надеюсь, что когда-нибудь он сможет это сделать.
5297.68 5304.44 "Анатолий Кулаков" Но это сможет сделать, естественно, не офисный бот, а бот, скорее всего, который называется GitHub Copilot.
5304.44 5314.56 "Анатолий Кулаков" Тоже был новый анонс GitHub Copilot X на основе движка ChachaGPT4, который позволяет программистам писать код и пишет он это довольно прекрасно.
5314.56 5321.24 "Анатолий Кулаков" Я думаю, что абсолютно все из вас уже видели видосики там на YouTube, читали восторженные статьи и так далее.
5321.24 5333.36 "Анатолий Кулаков" И в данной статье нам Microsoft намекает, что может быть, друзья, вы тоже хотите сделать свое прекрасное приложение, которое будет такое же крутое, как Microsoft Office, такое же крутое, как GitHub, такое же крутое, как Bing.
5333.36 5336.80 "Анатолий Кулаков" Вашему бизнесу точно тоже непосредственно нужны эти тулзы.
5336.80 5338.96 "Анатолий Кулаков" И вы должны их захотеть.
5338.96 5343.76 "Анатолий Кулаков" И в принципе теперь вы можете захотеть.
5343.76 5348.36 "Анатолий Кулаков" Как я уже сказал, эти тулзы предоставляются компании, даже не тулзы, тулзы предоставляются Microsoft.
5348.36 5352.36 "Анатолий Кулаков" А компания OpenAI – это как раз-таки разработчик самого этого движка.
5352.36 5360.40 "Анатолий Кулаков" То есть она занимается ресерчем и девелопментом различных движков и моделей.
5360.40 5362.32 "Анатолий Кулаков" Этих движков у нее несколько.
5362.32 5364.88 "Анатолий Кулаков" Самый известный, наверное, это GPT.
5364.88 5369.92 "Анатолий Кулаков" Это модель для того, чтобы понимать и генерировать текст или код.
5369.92 5376.12 "Анатолий Кулаков" В принципе никакой разницы нет, потому что код – это по сути тоже сам язык, только нами выдуманный и для компьютера.
5376.12 5382.68 "Анатолий Кулаков" То есть он даже скорее всего намного-намного легче, потому что он довольно четко специфицирован.
5382.68 5387.52 "Анатолий Кулаков" Еще одной замечательной, известной тулзой является движок DALI.
5387.52 5394.24 "Анатолий Кулаков" Это штука, которая умеет генерировать и редактировать картинки по текстовому описанию.
5394.24 5400.40 "Анатолий Кулаков" Картинки тоже появляются довольно качественные и можно загенерить абсолютно все, что приходит вам в голову.
5400.40 5406.96 "Анатолий Кулаков" Очень полезная штука, например, для презентации, когда вы не знаете, как изобразить ту эмоцию, которую вы сейчас чувствуете и хотите показать на слайде.
5406.96 5412.00 "Анатолий Кулаков" То подобные генераторы, которых появилась уйма вокруг нас, они очень сильно помогают.
5412.00 5417.00 "Анатолий Кулаков" И третья тулза, которую обязательно нужно упомянуть, это Whisper.
5417.00 5420.48 "Анатолий Кулаков" Штука, которая умеет превращать аудио в текст.
5420.48 5432.80 "Анатолий Кулаков" Если с первыми двумя мы касались вот чуть-чуть совсем сбоку, то как ни странно, Whisper - это первая штука, которая изменила нашу жизнь.
5432.80 5433.80 "Анатолий Кулаков" Слишком пафосно звучит, да?
5433.80 5435.92 "Анатолий Кулаков" Нашу какое-то увлечение.
5435.92 5444.56 "Анатолий Кулаков" Потому что это первый аудио движок, который смог превратить наш подкаст в текст и при этом сделать это довольно качественно.
5444.56 5456.20 "Анатолий Кулаков" Мы уже довольно много, блин, я последние лет пять точно, или наверное даже десять, перебираю абсолютно все движки, которые распознают аудио и превращают их в текст.
5456.20 5466.96 "Анатолий Кулаков" Так вот, ни один из них не может на программистской речи, то есть речи, которая сочетает в себя русский язык, английский язык и какие-то термины, не могла выдать членораздельного результата.
5466.96 5472.80 "Анатолий Кулаков" То есть хотя бы такого результата, с помощью которого можно было бы через пень-колоду как-нибудь догадаться, а что собственно происходит.
5472.80 5473.80 "Анатолий Кулаков" О чем речь?
5473.80 5474.80 "Анатолий Кулаков" Хотя бы издалека?
5474.80 5475.88 "Анатолий Кулаков" Нет, бесполезно.
5475.88 5479.00 "Анатолий Кулаков" Никто с этим справиться вообще не мог и близко.
5479.00 5487.92 "Анатолий Кулаков" И вот Whisper, он сделал просто гигантский прыжок, то есть как будто, знаешь, такая куча мусора, а потом раз и золотой кубок сразу стоит.
5487.92 5490.24 "Анатолий Кулаков" Вот Whisper нам предоставил именно такую картину.
5490.24 5494.12 "Анатолий Кулаков" То есть мы смогли полностью наш подкаст разложить в текст.
5494.12 5504.00 "Анатолий Кулаков" Если кому-то интересно, то подробнее можно послушать на нашем выпуске «За кулисьей», который доступен на Boosty.
5504.00 5505.24 "Анатолий Кулаков" Давай пойдем дальше.
5505.24 5508.00 "Анатолий Кулаков" Так, что же собственно я обещал?
5508.00 5512.28 "Анатолий Кулаков" Майкрософт обещает нам в наше приложение встроить такую же точно магию.
5512.28 5515.24 "Анатолий Кулаков" Что можно сделать?
5515.24 5520.32 "Анатолий Кулаков" Во-первых, она говорит, что можно сделать абсолютно все, что угодно, что они там делают с офисными приложениями.
5520.32 5528.04 "Анатолий Кулаков" То есть можно посмотреть, как Excel, допустим, с помощью обычной человеческой речи, типа сгруппируем мне годовой отчет, сведите гибель с кредитом, все это сам может делать.
5528.04 5534.40 "Анатолий Кулаков" PowerPoint готовит слайды, просто, когда вы говорите, просто нарисуй мне пять красивых бизнес-слайдов, он это все сам автоматически делает.
5534.40 5537.24 "Игорь Лабутин" А доклады можно будет так делать, да?
5537.24 5541.36 "Игорь Лабутин" Хочу доклад про Garbage Collection тут на эти 20 слайдов, пожалуйста.
5541.36 5545.80 "Анатолий Кулаков" Да-да-да, половину возьми от Пешкова, половину от Сидристова, а третью добавь кокосы.
5545.80 5553.16 "Анатолий Кулаков" И вот он тебе сам сделает выводы, сгенерит, и еще красивые картинки покажет, и голосом, скорее всего, потом озвучит, и видео снимет, да.
5553.16 5556.60 "Анатолий Кулаков" Сейчас мы работаем над тем, чтобы видео могло тоже автогенериться.
5556.60 5560.68 "Игорь Лабутин" Я буду сидеть на диване и даже не поеду на конференцию, блин.
5560.68 5565.88 "Анатолий Кулаков" Нет, как раз на конференцию ты можешь съездить, ты же заслужил, ты же сделал доклад.
5565.88 5566.88 "Анатолий Кулаков" Я поработал.
5566.88 5567.88 "Анатолий Кулаков" Хорошо, да.
5567.88 5569.00 "Анатолий Кулаков" Да, ты якобы поработал.
5569.00 5577.52 "Анатолий Кулаков" Например, можно делать там чат ботов, которые отвечают банально на вопросы о вашем бизнесе, но они такие, как раньше были тупые, а теперь они будут умные.
5577.52 5592.12 "Анатолий Кулаков" Можно сделать категоризатор, который раскидывает ваши продукты или пишет о них ревью, или читает про них ревью и определяет какую-то семантическую наклонность тех ревью, которые вам пользуются, пытаются донести ваши потребители.
5592.12 5598.32 "Анатолий Кулаков" Можно извлекать основные какие-то смыслы из текста и писать краткую выжимку из документов.
5598.32 5605.84 "Анатолий Кулаков" Можно наоборот, разворачивать документы из краткой выжимки и наливать больше воды, смотря в зависимости от того, что вам нужно.
5605.84 5612.52 "Анатолий Кулаков" Перевод текстов становится более лучше, естественно, все за счет GPT станет лучше, даже те же самые переводы.
5612.52 5621.56 "Анатолий Кулаков" И опять же, генерация картинок – это просто великолепная демонстрация, очень мощная, очень интересная и много где применяемая, в частности, для слайдов.
5621.56 5622.56 "Анатолий Кулаков" Милое дело.
5622.56 5624.20 "Анатолий Кулаков" Как это можно сделать?
5624.20 5632.88 "Анатолий Кулаков" OpenAI предоставляет REST API для своих запросов, очень простенький, очень элементарный, и к нему очень легко подключиться.
5632.88 5638.20 "Анатолий Кулаков" Главное, чтобы у вас был ключик, по которому там настроены определенные лимиты, но в основном все остальное бесплатно.
5638.20 5639.84 "Анатолий Кулаков" Опять же, бесплатно в пределах лимита.
5639.84 5642.52 "Анатолий Кулаков" Если вы бизнес, то уже, конечно же, нет.
5642.52 5647.04 "Анатолий Кулаков" И второй интересный способ – это AzureOpenAI.net SDK.
5647.04 5650.12 "Анатолий Кулаков" Сейчас находится в превью, но очень интересная SDK.
5650.12 5674.44 "Анатолий Кулаков" Интересно оно тем, что несмотря на слово «Ажур», оно также поддерживает не только Azure OpenAI Service, который, естественно, в ажуре секьюрный, интерпризный, за большие деньги и все такое, но также он и поддерживает стандартный OpenAI REST API Service, то есть это строго типизированная оберточка, которая позволяет обращаться к OpenAI бесплатно, напрямую, красиво, все тоже через тот же самый ажур SDK.
5674.44 5685.60 "Анатолий Кулаков" И в эстетике также есть GitHub-репозиторий, в котором очень много примеров, которые показывают, каким образом можно взаимодействовать с OpenAI на дот-нете.
5685.60 5698.40 "Анатолий Кулаков" Все примерчики красивые, рабочие, там же куча много интересных идей, что можно сделать, что получить, как сформировать запросы, если вы вдруг не знаете, что теперь у программистов самая большая задача – это правильно сформировать запрос.
5698.40 5700.64 "Анатолий Кулаков" Все остальное он напишет сам.
5700.64 5708.80 "Анатолий Кулаков" Поэтому в SDK, в этих примерчиках, очень хорошие, интересные есть самплы, как можно это все сгенерить, посмотреть.
5708.80 5713.02 "Анатолий Кулаков" Вот такое будущее нас ждет, вот такие у нас возможности предоставляет Microsoft.
5713.02 5716.96 "Анатолий Кулаков" Ну, наверное, огромное им спасибо, действительно, действительно мир меняется, и это хорошо.
5716.96 5719.72 "Игорь Лабутин" Ну да, становится интересно.
5719.72 5726.32 "Игорь Лабутин" Было действительно прикольно получить текстовую расшифровку выпуска, поражать над некоторыми вариантами какого-то всего.
5726.32 5733.32 "Игорь Лабутин" Все-таки программистские тексты – это сложно, когда мы разговариваем голосом, но успехи хорошие.
5733.32 5738.00 "Анатолий Кулаков" Надо признать, что разбор у него прямо можно сравнить с человеческим, и может даже в каких-то моментах
5738.00 5745.52 "Игорь Лабутин" лучше. Но его можно сравнить, мне кажется, с человеком, который бы разобрал наш текст, не являясь программистом.
5745.52 5755.24 "Игорь Лабутин" То есть не будучи знакомым со всей вот этой спецтерминологией и широкоупотребляемыми аббревиатурами и сокращениями и суперспециальными терминами.
5755.24 5761.32 "Анатолий Кулаков" Ну вот я тебя поправлю, как раз, кстати, там всякие там UI, веб-формы, API, Blazor, и он прекрасно понимает.
5761.32 5762.32 "Анатолий Кулаков" Ну да, хорошо.
5762.32 5768.48 "Анатолий Кулаков" Поэтому все-таки вот ключевые слова из программирования он должен знать, то есть программист даже не Джун, между прочим.
5768.48 5770.16 "Анатолий Кулаков" Судя по терминам, он там уже мидл.
5770.16 5771.80 "Игорь Лабутин" Ну он такой очень.
5771.80 5774.84 "Игорь Лабутин" Мидл, однобокий, в смысле каких-то технологий он не знает.
5774.84 5775.84 "Игорь Лабутин" Граф Койль он не знает.
5775.84 5776.84 "Игорь Лабутин" Ну ладно.
5776.84 5777.84 "Игорь Лабутин" Да.
5777.84 5779.96 "Игорь Лабутин" Вот ещё один подкаст, где будет странное слово Граф Койль распознаваться.
5779.96 5780.96 "Игорь Лабутин" Ладно.
5780.96 5785.24 "Анатолий Кулаков" Так, ладно, об этом в другом выпуске, давай по темам всё-таки ближе к делу.
5785.24 5786.24 "Игорь Лабутин" Давай по темам.
5786.24 5789.84 "Игорь Лабутин" Да, у нас есть ещё одна тема, снова не от Майкрософта, но зато снова про рантайм.
5789.84 5792.84 "Игорь Лабутин" Ну как про рантайм, про дунет.
5792.84 5793.84 "Игорь Лабутин" Таймеры.
5793.84 5809.08 "Игорь Лабутин" Я когда мне нужно что-то сделать с таймерами, я обычно, ну как, не то чтобы сильно задумываюсь, но иногда бывает вопрос, что если ты напишешь просто таймер, там, new timer в коде, то тебе дальше студия либо райтер говорит какой.
5809.08 5812.88 "Игорь Лабутин" Да, да, начинаем наш выбор как бы.
5812.88 5816.20 "Игорь Лабутин" Вот, и тут я иногда задумываюсь, какой же нам использовать.
5816.20 5824.56 "Игорь Лабутин" И у нас есть статья, где прям рассказывается история возникновения и когда же какой нужно использовать.
5824.56 5835.72 "Игорь Лабутин" Вот, давай мы этой статьей поделимся и немножко тоже расскажем всем, возможно, о тех фактах, которые они не знают про те таймеры, которые у нас есть в дунете.
5835.72 5838.52 "Анатолий Кулаков" Да, таких таймеров у нас в дунете как минимум шесть.
5838.52 5842.52 "Анатолий Кулаков" Но это те, что автор нашёл, я не удивлюсь, если где-то под капотом ещё парочку завалялось.
5842.52 5846.28 "Анатолий Кулаков" В общем, вопрос не праздный, какой таймер мне использовать.
5846.28 5848.16 "Анатолий Кулаков" Давайте попытаемся разобраться.
5848.16 5851.04 "Анатолий Кулаков" Прежде всего у нас есть два UI таймера.
5851.04 5863.48 "Анатолий Кулаков" Во-первых, это System Windows Form Timer, который используется для того, чтобы вызывать по таймеру периодически некие события, которые запускаются сразу в UI потоке.
5863.48 5867.16 "Анатолий Кулаков" В частном случае, в этом случае это поток виндформов.
5867.16 5873.88 "Анатолий Кулаков" Как вы, наверное, знаете, что все UI контроллы должны меняться и обращаться к ним, и считываться тоже только в определённом UI потоке.
5873.88 5875.44 "Анатолий Кулаков" Вот этот таймер это обеспечивает.
5875.44 5881.64 "Анатолий Кулаков" Очень удобно, вы бросили таймер на формочку, подписались на новые события и делаете с формой всё, что хотите.
5881.64 5885.60 "Анатолий Кулаков" Второй тип таймера это System Windows Trading Dispatcher Timer.
5885.60 5888.20 "Анатолий Кулаков" Он, соответственно, использует так называемый диспатчер.
5888.20 5892.84 "Анатолий Кулаков" То есть, по сути, это тот же самый прокачиватель эквиментов на каком-то определённом потоке.
5892.84 5895.72 "Анатолий Кулаков" И по факту его используют именно только для UI потока.
5895.72 5899.44 "Анатолий Кулаков" Но в данном случае он чаще встречается в WPF приложениях.
5899.44 5900.84 "Анатолий Кулаков" То же самое, только сбоку.
5900.84 5906.80 "Анатолий Кулаков" И какая здесь у них есть интересная особенность?
5906.80 5911.80 "Анатолий Кулаков" Во-первых, он запускается только один раз на callback.
5911.80 5919.20 "Анатолий Кулаков" То есть, один раз таймер сработал, ваш делегат вызвался, и в следующий раз вы должны снова зарядить таймер, чтобы он снова сработал.
5919.20 5922.08 "Анатолий Кулаков" То есть, это не периодический таймер, а одноразовый.
5922.08 5929.28 "Анатолий Кулаков" Это хорошо на самом деле, потому что оно вам позволяет не беспокоиться о нескольких вызовах таймера параллельно.
5929.28 5931.60 "Анатолий Кулаков" То есть, никакого трэдсейфа вам не нужно.
5931.60 5934.56 "Анатолий Кулаков" У вас никакого конкарнси в коде не получится.
5934.56 5942.68 "Анатолий Кулаков" И когда мы говорим о таймерах, на самом деле это самая первая ситуация, проблема, ошибка, стратегия, которую вы должны обязательно обдумать.
5942.68 5948.64 "Анатолий Кулаков" Что будет, если хендлер таймера вызовется параллельно несколько раз?
5948.64 5957.20 "Анатолий Кулаков" Такое легко может быть, если обработчик в вашем таймере выполняется намного дольше, чем период у этого таймера.
5957.20 5959.56 "Анатолий Кулаков" Поэтому опасны периодические таймеры.
5959.56 5963.64 "Анатолий Кулаков" Еще один интересный таймер – это System Web UI таймер.
5963.64 5968.44 "Анатолий Кулаков" Это такая штука, которая нужна была для вебформсов, если кто-то еще помнит такие штуки.
5968.44 5975.48 "Анатолий Кулаков" И она делает постбэк на сервер в тот момент, когда происходит тик.
5975.48 5981.56 "Анатолий Кулаков" Вебформы, в принципе, надеюсь, уже давно умерли, поэтому не будем о них вспоминать.
5981.56 5982.56 "Анатолий Кулаков" И у нас остается…
5982.56 5985.56 "Игорь Лабутин" А таймер до сих пор живой и тикает.
5985.56 5997.36 "Анатолий Кулаков" Таймер постбэки на сервер дает. И из шести таймеров у нас остается три, которые никакого отношения к UI не имеют, к формам не имеют и, в общем, более-менее живучие, более-менее понятные.
5997.36 6002.76 "Анатолий Кулаков" Это System Trading Timer, System Timers Timer и System Trading Periodic Timer.
6002.76 6004.16 "Анатолий Кулаков" Давайте разбираться по порядку.
6004.16 6010.40 "Анатолий Кулаков" System Trading Timer – это самый базовый таймер, который вот обычно используют на основании его строят всех остальных.
6010.40 6014.68 "Анатолий Кулаков" Он скедурит свои коллбеки на тредпуле.
6014.68 6021.36 "Анатолий Кулаков" То есть, когда произойдет тик, он уже вызовется не на каком-то UI-потоке, а просто возьмет обычный поток из тредпула и заразит на нем свой ивент.
6021.36 6027.44 "Анатолий Кулаков" Да, я только что подумал, как нам расшифруют, наш расшифровальщик заразит свой ивент.
6027.44 6028.44 "Анатолий Кулаков" Посмотрим.
6028.44 6033.16 "Игорь Лабутин" Как каждый раз теперь говоришь и задумываешься, блин, интересно
6033.16 6035.16 "Анатолий Кулаков" очень. Да-да-да, думаешь о других, о наших слушателях.
6035.16 6039.68 "Анатолий Кулаков" И вот здесь как раз-таки возникает та ситуация, о которой я вам говорил.
6039.68 6055.44 "Анатолий Кулаков" Если у вас период будет слишком маленький, допустим, давай каждую секунду мне бомби, а обработчик будет слишком длинный, там обращение к файлосистеме, поход в сеть, вычисление там алгоритмического факториала, то у вас может возникнуть такая ситуация, когда таймер запустится несколько раз.
6055.44 6058.36 "Анатолий Кулаков" И вот этот таймер как раз трейдинг таймер.
6058.36 6064.08 "Анатолий Кулаков" Он будет запускать на каждый тик стабильно, как вы ему сказали, ваш хендлер, ваш обработчик.
6064.08 6070.72 "Анатолий Кулаков" И то есть, одновременно может быть запущено благодаря этому множество хендлеров, которые будут выполняться параллельно.
6070.72 6075.08 "Анатолий Кулаков" И поэтому вам нужно следить за теми ресурсами, которые они могут захватить параллельно.
6075.08 6077.88 "Анатолий Кулаков" Вам нужно или как-то синхронизировать, или что-то другое делать.
6077.88 6081.76 "Анатолий Кулаков" В общем, на практике старайтесь таких ситуаций избегать.
6081.76 6087.40 "Анатолий Кулаков" Самый лучший таймер – это тот, который вызывает вас один раз, потом вы делаете всю работу и скедулируете таймер обратно.
6087.40 6097.44 "Анатолий Кулаков" Лучше вы посчитаете, сколько вы работали, отнимите вот это время работы от общего периода и заскедулируете его только на оставшееся время.
6097.44 6110.16 "Анатолий Кулаков" Это намного лучше, легче и проще в плане отладки, дебага, ошибок и так далее, чем полагаться на то, что вы успеете все-таки почему-то сделать свою задачу за этот период.
6110.16 6112.96 "Анатолий Кулаков" Как показывает практика, рано или поздно все не успевают.
6112.96 6115.36 "Анатолий Кулаков" Поэтому не рассчитывайте на это.
6115.36 6119.08 "Анатолий Кулаков" Следующий таймер в нашем разборе – это System Timers Timer.
6119.08 6126.24 "Анатолий Кулаков" Он на самом деле под капотом использует трейдинг таймер, который мы смотрели чуть выше, но наворачивает на него множество полезных фич.
6126.24 6141.20 "Анатолий Кулаков" Например, свойства After Set, которые как раз таки позволяют осуществить то, что я вам говорил, который позволяет настроить, таймер будет одноразово вызывать event или будет по циклу вызывать каждый раз, каждый тик.
6141.20 6150.60 "Анатолий Кулаков" Свойства Enabled, которые позволяют просто включить или выключить его, а также Synchronization Object, который как раз таки позволяет его запустить где угодно, где вам удобно.
6150.60 6163.56 "Анатолий Кулаков" У него есть событие, которое называется Tick, на которое можно подписаться и в отличие от предыдущих таймеров, там можно зарегистрировать multi-делегат, то есть несколько раз подписаться, то есть несколько хендлеров зарегистрировать.
6163.56 6166.44 "Анатолий Кулаков" На один тик у вас будет разиться сразу несколько хендлеров.
6166.44 6169.72 "Анатолий Кулаков" Если они независимые, то в принципе это хорошо, это полезно, это бывает нужно.
6169.72 6175.76 "Анатолий Кулаков" И еще одно интересное свойство у него есть – вы можете поменять хендлеры после его старта.
6175.76 6179.00 "Анатолий Кулаков" Обычно его более примитивные коллеги такого не позволяют.
6179.00 6184.96 "Анатолий Кулаков" А здесь, пожалуйста, один хендлер отработал, заменил себя на другой хендлер и при следующем тике уже будет что-то другое вызываться.
6184.96 6191.24 "Анатолий Кулаков" Конечно, стоит машина и получается сложная, и опять же, как это все дело отлаживать, непонятно, но если вам нужно, то почему бы и нет.
6191.24 6196.60 "Анатолий Кулаков" Итак, последний у нас остался таймер – это System Trading Periodic таймер.
6196.60 6200.32 "Анатолий Кулаков" И в принципе вот ради него стоило как бы всю эту статью слушать, открывать и читать.
6200.32 6207.64 "Анатолий Кулаков" Это самый новый таймер, который появился в дот-нет-библиотеке, то есть самый модный, самый современный, самый юный.
6207.64 6214.60 "Анатолий Кулаков" И в него попытались впихнуть решение всех тех проблем, которые накопились у предыдущих его родственников.
6214.60 6217.92 "Анатолий Кулаков" А именно, он поддерживает асинк-хендлеры.
6217.92 6226.20 "Анатолий Кулаков" Наконец-то, таски у нас появились давно, а вот таймеров, которые могли бы работать с этими тасками у нас не было очень-очень долго.
6226.20 6227.20 "Анатолий Кулаков" И вот он.
6227.20 6230.88 "Анатолий Кулаков" Он умеет как раз-таки делать асинхронные хендлеры.
6230.88 6232.24 "Анатолий Кулаков" На основании его можно это сделать.
6232.24 6242.12 "Анатолий Кулаков" У него нет события тик, на которые можно подписаться и сидеть в своем делегатике и ждать чего-то, что произойдет.
6242.12 6247.00 "Анатолий Кулаков" А у него более интересен, в отличие от остальных таймеров, если там было все очевидно, как они реализованы.
6247.00 6255.04 "Анатолий Кулаков" У вас какой-то объект, у него события, вы на это событие подписываетесь, задаете интервал и сидите в своем делегате, ждете, пока вас вызовут.
6255.04 6257.72 "Анатолий Кулаков" Все легко, интуитивно, прямо, понятно.
6257.72 6260.88 "Анатолий Кулаков" И такой подход есть практически во всех языках.
6260.88 6264.84 "Анатолий Кулаков" Вот этот же товарищ, периодик таймер, он построен немножко иначе.
6264.84 6269.32 "Анатолий Кулаков" Он построен хитрее, и благодаря этому мы смогли решить очень множество проблем.
6269.32 6271.64 "Анатолий Кулаков" В частности, как бы асинхронный таймер.
6271.64 6275.56 "Анатолий Кулаков" Как сделать асинхронный таймер, подписавшись на события?
6275.56 6276.56 "Анатолий Кулаков" Оказывается, никак.
6276.56 6277.84 "Анатолий Кулаков" Поэтому не надо вам вообще такого события.
6277.84 6281.32 "Анатолий Кулаков" Он пошел интересным путем.
6281.32 6285.28 "Анатолий Кулаков" Он сделал метод, который называется waitForNextTickAsync.
6285.28 6288.36 "Анатолий Кулаков" Этот метод возвращает valueTask от bool.
6288.36 6289.68 "Анатолий Кулаков" valueTask от bool.
6289.68 6291.68 "Анатолий Кулаков" У нас здесь есть две точки информации.
6291.68 6293.68 "Анатолий Кулаков" Во-первых, valueTask.
6293.68 6296.32 "Анатолий Кулаков" valueTask можно авейтить.
6296.32 6301.48 "Анатолий Кулаков" Авейтить вы будете до тех пор, пока не придет этот период.
6301.48 6305.64 "Анатолий Кулаков" То есть, valueTask закомплитится, как только сработает таймер.
6305.64 6309.44 "Анатолий Кулаков" То есть, это позволяет вам использовать конструкцию waitForNextTickAsync.
6309.44 6317.48 "Анатолий Кулаков" То есть, вы можете в while ждать закончание этого valueTask.
6317.48 6323.24 "Анатолий Кулаков" И вторая интересная информация, которая нам приходит в ретурне, это bool.
6323.24 6326.32 "Анатолий Кулаков" Это булевый флажок, то есть, чего вы все-таки дождались.
6326.32 6330.52 "Анатолий Кулаков" А дождались вы того, что этот bool обозначает, закончился таймер или не закончился.
6330.52 6334.24 "Анатолий Кулаков" То есть, стоит вам продолжать в следующий раз ждать или не стоило.
6334.24 6338.56 "Анатолий Кулаков" И вот благодаря такой конструкции, шикарной, вы его легко засовываете в цикл while.
6338.56 6347.32 "Анатолий Кулаков" То есть, во-первых, while реагирует на вот этот bool, который говорит, продолжит проваливаться в body или не нужно.
6347.32 6353.24 "Анатолий Кулаков" И во-вторых, благодаря await, while никуда не пойдет в body дальше, пока не случится await.
6353.24 6359.36 "Анатолий Кулаков" И также, благодаря await, вы можете внутри while запустить асинхронный код.
6359.36 6362.80 "Анатолий Кулаков" То есть, вот что вам позволяет запустить асинхронный код.
6362.80 6365.88 "Анатолий Кулаков" Ни какой-то там асинхронный ивент, на который вы можете подписаться, нет.
6365.88 6371.48 "Анатолий Кулаков" Вы просто-напросто получаете управление от этого await только тогда, когда кончился период.
6371.48 6376.12 "Анатолий Кулаков" И запускаете любой код, хоть асинхронный, хоть асинхронный, который вам нравится.
6376.12 6384.08 "Анатолий Кулаков" И плюс, еще один замечательный подход вот этой стратегии в том, что мы избегаем как раз-таки наложения вот этих callbacks.
6384.08 6392.60 "Анатолий Кулаков" У нас здесь полностью исключается система гонок, когда у нас делегат вызовется в то время, когда предыдущий делегат не заработал.
6392.60 6395.12 "Анатолий Кулаков" Потому что это все обычный прекрасный while.
6395.12 6416.48 "Анатолий Кулаков" Таким образом, благодаря одной строчке из while и произвольному body с каким-то полезной нагрузкой, мы смогли избежать и callbacks оверлапа, и смогли поддержать асинхронные вызовы, и смогли понять, когда у нас происходит таймер, и когда его нужно выключить, и когда его нужно включить, то есть когда выйти из этого while.
6416.48 6418.76 "Анатолий Кулаков" В общем, такой замечательный таймер.
6418.76 6430.60 "Анатолий Кулаков" Надеюсь, статичка поможет вам не путаться в том, какие таймеры есть, выбрать тот полезный, который вам нужен, и заиспользовать самое главное новый таймер, который поддерживает асинхронные вот эти callbacks.
6430.60 6433.92 "Игорь Лабутин" Да, идея с циклом на самом деле была действительно прикольная.
6433.92 6435.80 "Игорь Лабутин" Прямо выглядит очень аккуратненько.
6435.80 6437.96 "Игорь Лабутин" Ну, давай потихонечку сворачиваться.
6437.96 6441.16 "Игорь Лабутин" У нас есть еще очень коротенький раздел, кратко о разном.
6441.16 6446.36 "Игорь Лабутин" Здесь мне попалось две статейки, точнее даже одна статейка и вторая, это ишли на гитхабе.
6446.36 6450.60 "Игорь Лабутин" Одна это про те самые ETW-ивенты.
6450.60 6454.64 "Игорь Лабутин" Мы про них сказали, когда говорили про буферизацию, да, RayPoly.
6454.64 6461.88 "Игорь Лабутин" Там генерится ивенты, ну там, на виндах это ETV-ивенты будут, вот это все.
6461.88 6472.36 "Игорь Лабутин" И проблема с ними заключается в том, что, ну вот для некоторых для многих из них есть документация про то, что, как, когда они генерятся, не генерятся.
6472.36 6481.88 "Игорь Лабутин" Но на самом деле, взяв ваше приложение и начав смотреть, если, допустим, там есть какие-то проблемы, было бы полезно знать, аж какие же ивенты вам доступны.
6481.88 6486.88 "Игорь Лабутин" То есть, может быть, посмотреть на список ивентов, уже будет понятно, в какую сторону копать, например, с диагностикой.
6486.88 6491.80 "Игорь Лабутин" Ну и сама платформа тоже эмитит дофига разных ивентов, хорошо бы знать, какие.
6491.80 6503.36 "Игорь Лабутин" Вот, и статейка как раз-таки рассказывает про то, какие статейки можно получить в вашем приложении, там небольшим кусочком кода, все возможные ивенты, которые не то чтобы возможные ивенты, а те, которые на самом деле генерятся в вашем приложении.
6503.36 6506.64 "Игорь Лабутин" Ну и дальше на основе них делать какую-то диагностику.
6506.64 6513.20 "Игорь Лабутин" Так что, если вы смотрите на ваше приложение и не понимаете, какие ивенты оно может сгенерить, вот посмотрите статейку.
6513.20 6523.76 "Игорь Лабутин" А вторая, это GitHub.Issue, это breaking change к докеру, точнее к мультиплатформ-имеджам на докере для .NET.
6523.76 6538.20 "Игорь Лабутин" Эта штука генерируется, ну в смысле эти мультиплатформ-имеджи создаются, по-моему, если я правильно помню, с 6-й версии .NET, и эти мультиплатформ-имеджи, ну это базовые имиджи для .NET, они создавались и для Windows, и для Linux.
6538.20 6558.32 "Игорь Лабутин" Так вот, начиная с восьмерки и превью 3, только линуксовые имиджи будут мультиплатформ, для винды, чтобы если вы используете виндовый базовый имидж .NET, зачем-то это вам нужно на базе наносервера или еще чего-то, вам нужно явно указывать номер версии, номер версии докер-имиджа, который вы берете.
6558.32 6574.76 "Игорь Лабутин" Майкрософт решила, что там что-то как-то автоматический алгоритм поиска подходящей платформы работает не очень, и поэтому, если вы используете базовые виндовые имиджи, используйте, посмотрите, во-первых, конкретно Issue там написано, почему так сделано, зачем сделано, и что делать вместо этого.
6574.76 6581.64 "Игорь Лабутин" Вам, возможно, надо будет что-то поменять, если вы переедете на восьмерку, чтобы правильно продолжать использовать докеры базовые.
6581.64 6588.28 "Анатолий Кулаков" Ну, а я вообще не сталкивался, чтобы кто-то на практике использовал Windows докеры, контейнеры.
6588.28 6594.32 "Анатолий Кулаков" Ну, наверное, это естественно, есть такие ситуации, безусловно, понятно, почему их нужно делать, ну просто на практике
6594.32 6604.88 "Игорь Лабутин" мне не принято. У меня был один раз, мы в итоге не стали использовать докер, мы использовали абсервис, ну ажурный абсервис натуральный, но там был действительно, там нужен был донат фреймворк, винда, вот это все.
6604.88 6608.08 "Игорь Лабутин" То есть там компоненты, которые только под ней и существовали.
6608.08 6611.24 "Игорь Лабутин" И если бы это нужно было завернуть в докер, то да, пришлось бы докер-контейнер винда выбрать.
6611.24 6612.24 "Игорь Лабутин" Так.
6612.24 6613.24 "Игорь Лабутин" Отлично, все?
6613.24 6614.24 "Игорь Лабутин" Да, все.
6614.24 6617.24 "Игорь Лабутин" Давай итоги и пойдем.
6617.24 6673.16 "Игорь Лабутин" Сегодня мы посмотрели на DotNet 8 Preview 3, вместе с ними, с ним, с ними, со всеми ними, новости C# 12, которые мы периодически касаемся, в S/P/Nad Core мы сегодня погрузились, мне кажется, со всех разных возможных сторон, поговорили про авторизацию и то, какие изменения нас ждут в идентитии, посмотрели, что у нас Raute Tooling новый появился, который DE-шки могут использовать, узнали, точнее, знаем теперь, где посмотреть, как раутится минимал API, если интересно, посмотрели, почему может быть не подходящий стандартный RAIP, как его хорошо использовать и как смотреть, что мы его используем правильно, посмотрели на таймеры в DotNet различные и GPT, и все новинки OpenAI, к ним теперь можно доступаться через REST API, есть хорошая SDK на DotNet и для DotNet.
6673.16 6674.16 "Игорь Лабутин" Примерно так.
6674.16 6687.60 "Анатолий Кулаков" Ну, отлично, хорошо посидели, друзья, если вам тоже понравилось, рекомендуйте нас своим знакомым, коллегам, шары, репосты, лайки, комменты, ждем от вас на YouTube, да и в любой социальной сети.
6687.60 6705.72 "Анатолий Кулаков" В общем, всячески приветствуем, пишите нам, если вдруг вам интересна какая-то статья попалась или инструмент попался, обязательно пишите, делитесь своими интересными мнениями, мы самые лучшие выберем и включим наш выпуск в нашу программу.
6705.72 6715.68 "Анатолий Кулаков" На этом все, всем большое спасибо, увидимся вскоре в следующем выпуске, поэтому собираем статейки и отдыхаем, наслаждаемся весной.
6715.68 6717.36 "Анатолий Кулаков" Всем счастливо, всем пока.
6717.36 6717.88 "Игорь Лабутин" Всем пока.
