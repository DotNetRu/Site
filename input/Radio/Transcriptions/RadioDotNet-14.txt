0.00 5.00 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
5.00 8.44 "Анатолий Кулаков" В эфире Radio.net выпуск номер 14.
8.44 10.40 "Анатолий Кулаков" И с вами Анатолий Кулаков.
10.40 11.40 "Анатолий Кулаков" И Игорь Лабутин.
11.40 12.40 "Анатолий Кулаков" Привет!
12.40 18.20 "Анатолий Кулаков" Самая важная новость за весь сегодняшний выпуск это, конечно же, что мы добавились на Яндекс.Музыку.
18.20 21.32 "Анатолий Кулаков" Точнее, можно сказать, на Яндекс.Подкасты.
21.32 24.52 "Анатолий Кулаков" Теперь наш подкаст можно послушать еще и там.
24.52 32.12 "Анатолий Кулаков" Поэтому все любители Яндекс.Музыки, Яндекс.Подкастов ищите нас там и слушайте.
32.12 39.12 "Анатолий Кулаков" Напомню, что нас также можно слушать в Google.Подкастах, в Apple.Подкастах и для любителей YouTube у нас еще все выпуски есть на YouTube.
39.12 47.84 "Анатолий Кулаков" А на этом официальная часть закончена, но сворачиваться мы не собираемся, потому что у Microsoft прошла большая конференция - Microsoft Ignite.
47.84 63.52 "Игорь Лабутин" Да, конференция большая, на ней было много всяких анонсов, но для разработчиков там особо ничего не было, если вы не разрабатываете под Azure, потому что в Azure различных улучшений и изменений было анонсировано довольно много.
63.52 70.08 "Игорь Лабутин" Мы приложим ссылки, можете сходить посмотреть на все анонсы и возможно вы найдете что-то, что вам понравится.
70.08 80.60 "Игорь Лабутин" Кроме того, было, конечно же, сказано, что скоро нас ждет DotNet 5 релиз и для DotNet 5 еще была анонсирована такая штука, как возможность писать под Windows Runtime.
80.60 96.56 "Игорь Лабутин" Вообще Microsoft, судя по всему, пытается как-то заинлайнить, точнее заэлайнить все возможные Windows Runtime и дать вам возможность писать одинаково под все возможные Windows, которые только могут быть для десктопов, для мобильных, для куда угодно.
96.56 110.00 "Игорь Лабутин" И поэтому движение в эту сторону происходит в разных местах, в частности, на DotNet 5 теперь можно будет писать под Windows Runtime, как я сказал, с помощью прозрачных прослоек, так скажем, которые будут скрывать Windows Runtime.
110.00 122.00 "Игорь Лабутин" Кроме того, есть движение в сторону UI, мы про это поговорим, надеюсь, в следующем выпуске, не надо немножко покопаться в этом деле, потому что пока там только очень кратенький анонс, мы сейчас про него не будем рассказывать.
122.00 140.28 "Игорь Лабутин" И последнее, что мне понравилось из анонсов, это стремление Microsoft упростить жизнь тем, кто делает CI/CD в своих проектах, и, по крайней мере, анонсировано, что теперь можно будет не ставить SDK различные для сборки, а получать их в виде NuGet пакетов.
140.28 157.56 "Игорь Лабутин" Откуда вы возьмете NuGet до того, как вы поставили SDK, вопрос пока открытый, но движение интересное, то есть Microsoft пытается сделать так, чтобы вам не нужно было ставить кучу софта до того, как вы сможете сделать CI на конкретном сервере, а чтобы прям CI pipeline, например, все это качал прямо во время сборки.
157.56 162.72 "Игорь Лабутин" Таким образом, получится на одном и том же агенте собирать, например, разные версии или что-то в таком духе.
162.72 172.68 "Игорь Лабутин" Так что для разработчиков и того, каких-то сильных изменений, которые затрагивают нашу жизнь здесь и сейчас, особо нет, но будем следить и смотреть, что из этого получится.
172.68 179.68 "Анатолий Кулаков" Ну, у нас есть другой анонс, который для разработчиков очень даже подходит, и там для них очень много всего интересного.
179.68 185.32 "Анатолий Кулаков" Это, наконец-то, .NET 5 выпустился в релиз кандидат первой версии.
185.32 188.80 "Анатолий Кулаков" Никаких там больших взрывных новинок, естественно, здесь не будет.
188.80 196.92 "Анатолий Кулаков" В нем укрепляется, оптимизируется и улучшается все то, о чем мы с вами уже разговариваем много-много выпусков.
196.92 201.76 "Анатолий Кулаков" Но я думаю, все-таки какие-то основные фичи, основные моменты не грех и повторить.
201.76 208.52 "Анатолий Кулаков" Тем более, что многие для них являются концептуально новыми для нашей платформы, например, рекорды.
208.52 213.24 "Анатолий Кулаков" Рекорды сами авторы называют самой важной фичей в C# 9.
213.24 215.36 "Анатолий Кулаков" Давайте вспомним, что же это такое.
215.36 220.76 "Анатолий Кулаков" Рекорды представляют себя, грубо говоря, мьютабельные классы, которые легко и просто описываются.
220.76 227.92 "Анатолий Кулаков" Буквально одной строчкой вы можете описать, что это такое, и какие неизменимые поля есть у этого класса.
227.92 231.84 "Анатолий Кулаков" Чтобы описать рекорд, все-таки конечный синтексис получился следующим.
231.84 237.40 "Анатолий Кулаков" Вы должны описать аксессор, например, public, потом ключевое слово record, и после этого пишите имя класса.
237.40 240.44 "Анатолий Кулаков" То есть, вместо класса просто-напросто пишите слово record.
240.44 248.08 "Анатолий Кулаков" Далее в скобках перечисляете имена полей, которыми будет оперировать этот рекорд, и точка запятой.
248.08 259.00 "Анатолий Кулаков" То есть, таким образом вы можете в одной строчке объявить себе датакласс, который уже по своей сути будет вполне мьютабельным, юзабельным и с множеством полезных фишек.
259.00 263.16 "Анатолий Кулаков" Под капотом это все-таки раскладывается в настоящий класс.
263.16 270.96 "Анатолий Кулаков" Все филды, которые вы объявили при инициализации, то есть в Primary Constructor, объявляются как init only.
270.96 274.04 "Анатолий Кулаков" Init - это еще одно нововведение C# 9.
274.04 282.76 "Анатолий Кулаков" То есть, теперь вы могли у каждого свойства написать get или set, а теперь можно вместо set поставить ключевое слово init.
282.76 291.56 "Анатолий Кулаков" Это означает, что значение в вашем классе может быть присвоено не только конструкторе, но еще в блоке инициализации при создании класса.
291.56 294.36 "Анатолий Кулаков" Но после этого изменять его уже больше нельзя.
294.36 299.08 "Анатолий Кулаков" То есть, это такой костыль на уровне изобретения read-only пропертей.
299.08 303.48 "Анатолий Кулаков" Вот с этими init-свойствами инициализируются рекорды.
303.48 310.08 "Анатолий Кулаков" Также у рекорда, в отличие от класса, определяется сравнение не по ссылке, не по референсу, а по контенту.
310.08 318.16 "Анатолий Кулаков" То есть, если вы попытаетесь сравнить два рекорда, они будут эквивалентными, если каждое поле будет равно полю в другом рекорде.
318.16 322.56 "Анатолий Кулаков" Также рекорды имплементируют интерфейс IEquatable.
322.56 329.44 "Анатолий Кулаков" Они переопределяют оператор равно, переопределяют string, в результате которого вы сможете увидеть значение всех полей.
329.44 338.68 "Анатолий Кулаков" У них переопределен деконструктор, который позволяет вам раздеконструировать рекорд и вернуть значение всех его полей с прайма реконструктора.
338.68 341.72 "Анатолий Кулаков" Но нужно не обманываться.
341.72 345.56 "Анатолий Кулаков" Рекорды - это все-таки не создание каких-то immutable классов и все такое.
345.56 353.40 "Анатолий Кулаков" То есть, immutable получаются только те поля, которые вы задаете в прайме реконструктора, в том конструкторе, который объявлен рядом с именем класса.
353.40 359.64 "Анатолий Кулаков" Ничто же вам не мешает открыть скобочку и пользоваться рекордами, как обычными классами.
359.64 369.92 "Анатолий Кулаков" Внутри вы можете написать вполне изменяемые свойства, например, сеттеры или даже сделать методы и навернуть там любую изменяемую логику.
369.92 373.00 "Анатолий Кулаков" То есть, поведение будет практически такое же, как у класса.
373.00 380.36 "Анатолий Кулаков" Но, скорее всего, на практике делать этого не стоит, потому что если вам нужны какие-то большие immutable классы с методами, извольте для этого простые классы.
380.36 390.12 "Анатолий Кулаков" Еще одной интересной фишкой на пути к immutable классам является ключевое слово "with", которое используется очень широко с рекордами.
390.12 395.00 "Анатолий Кулаков" Нужно оно для того, чтобы изменять классы или изменять рекорды.
395.00 400.08 "Анатолий Кулаков" Допустим, у вас есть рекорд "пользователь", у которого есть 10 полей, одно из которых это фамилия.
400.08 403.20 "Анатолий Кулаков" И вот пользователь сменил фамилию и вам нужно его переименовать.
403.20 405.48 "Анатолий Кулаков" Что делать, если класс immutable?
405.48 411.84 "Анатолий Кулаков" Ну, создавать новый класс, создавать новый класс, у которого все эти 10 полей будут одинаковыми, кроме одного единственного свойства.
411.84 413.56 "Анатолий Кулаков" Свойство "фамилия".
413.56 417.68 "Анатолий Кулаков" Вот для таких специальных случаев и придуман ключевое слово "with".
417.68 419.72 "Анатолий Кулаков" То есть, записывается это просто.
419.72 424.04 "Анатолий Кулаков" Вы говорите "user", "with" и пишете, какое поле нужно изменить.
424.04 426.24 "Анатолий Кулаков" Например, фамилия равна что-то другое.
426.24 433.24 "Анатолий Кулаков" И все, все остальные поля будут скопированы, кроме одного этого поля, которое заменится на то значение, которое вы указали.
433.24 437.00 "Анатолий Кулаков" Нужно понимать, что никакой связи между этими двумя рекордами нет.
437.00 439.92 "Анатолий Кулаков" То есть, между старым пользователем и тем новым, который получится.
439.92 444.96 "Анатолий Кулаков" Референс тайпы, если они есть у этого рекорда, копируются, как и положено по ссылке.
444.96 447.28 "Анатолий Кулаков" Валю тайпы копируются по значению.
447.28 449.96 "Анатолий Кулаков" То есть, никакой магии, чистая, понятная копия.
449.96 453.24 "Анатолий Кулаков" Рекорды можно наследовать, но можно их наследовать только от рекордов.
453.24 455.40 "Анатолий Кулаков" А классы можно наследовать только от классов.
455.40 458.96 "Анатолий Кулаков" То есть, вы не можете пронаследовать класс от рекорда или рекорд от класса.
458.96 459.96 "Анатолий Кулаков" То есть, их мешать никак нельзя.
459.96 462.92 "Анатолий Кулаков" То есть, рекорды не силт, они вполне наследуются.
462.92 470.72 "Анатолий Кулаков" Еще в DotNet 5 улучшили System Text JSON, который совершенствуется с каждым релизом.
470.72 475.96 "Анатолий Кулаков" Прежде всего, конечно же, он научился децерализовать и серилизовать рекорды.
475.96 481.76 "Анатолий Кулаков" Это не так просто, потому что у рекордов один-единственный конструктор, который требует обязательных параметров.
481.76 485.24 "Анатолий Кулаков" И просто так старым серилизаторам их было не взять.
485.24 487.56 "Анатолий Кулаков" Но новый серилизатор умеет это делать.
487.56 493.56 "Анатолий Кулаков" Естественно, большие импрувменты у серилизатора в перфомансе, в редабилити и прочем-прочем.
493.56 503.16 "Анатолий Кулаков" Появилось множество различных хаков, хуков, флажков и так далее, которые позволяют ваш проект перевести с Newton Soft JSON на новый System Text JSON.
503.16 514.00 "Анатолий Кулаков" Microsoft создал отличный migration guide, в котором описано, что нужно делать для того, чтобы мигрировать вашу серилизацию на новый класс.
514.00 523.00 "Анатолий Кулаков" Там собраны советы, которые говорят, каким образом сделан какой-то функционал в Newton Soft JSON и как он реализуется в Microsoft.
523.00 536.88 "Анатолий Кулаков" Мне очень нравится, что Microsoft не пошли именно под гонкой своего API под Newton Soft, а все-таки сделали свой чистый красивый API и создали подробнейший гайд, каким образом перейти, каким образом что эмулировать.
536.88 543.92 "Анатолий Кулаков" Это все-таки создает консистентность API у нового серилизатора, не пытаясь его подогнать под старые какие-то тулзы.
543.92 556.92 "Анатолий Кулаков" Из мелочей, что серилизатор теперь умеет работать с дикшенерами, у которых ключ не только строка, серилизатор теперь поддерживает филды, а также добавлена поддержка циклических ссылок.
556.92 572.96 "Анатолий Кулаков" Еще появились удобные extension методы, которые позволяют JSON-серилизатору интегрироваться вместе с HTTP-клиентом для прозрачной обработки контента и вализации медиа-типов.
572.96 592.64 "Анатолий Кулаков" То есть, теперь вы можете, например, HTTP-клиента вызвать метод, который называется getFromJSONAsync, передать ему тип, который вы ожидаете на выходе от вашего API, и клиент не только запросит данные с веб-точки, но и децерализует их, если медиатайп будет соответствующим.
592.64 597.00 "Анатолий Кулаков" И также можно сделать POSTAsJSON и так далее.
597.00 608.16 "Анатолий Кулаков" То есть, много таких маленьких, хороших методов-помощников, которые позволяют вам просто одной строчкой работать с внешним API и получать уже на выходе строго типизированные типы.
608.16 611.24 "Анатолий Кулаков" Также у серилизатора улучшена поддержка мьютабельных типов.
611.24 619.72 "Анатолий Кулаков" Он показал рекорды, типичный тому пример, и еще он научился децерализовать и серилизовать структуры.
619.72 633.56 "Анатолий Кулаков" Проблема у структур в том, что они могут иметь несколько конструкторов, и для того, чтобы серилизатор все-таки определил правильный конструктор, который нужно использовать, для этого нужно проставить специальный атрибут, JSON конструктор атрибут.
633.56 638.48 "Анатолий Кулаков" Вот такие основные ключевые моменты у нас в .NET 5, RC1.
638.48 651.04 "Игорь Лабутин" Да, и при этом надо понимать, что это RC1, то есть по сравнению с превью 8, как сам говорит Microsoft, особых фич новых нету, мы только допиливаем, финализируем и полируем все, что есть.
651.04 661.76 "Игорь Лабутин" Если при этом посмотреть на SP NetCore или Entity Framework Core, там видно, что прям новых фич просто завались, и это немножко идет в разрез с тем, как выглядит RC1.
661.76 675.84 "Игорь Лабутин" Если мы посмотрим на SP NetCore, во-первых, там прям допиливают в огромном количестве Blazor, там штук 10 или 15 разных импровментов вокруг Blazor, не буду вдаваться в подробности, почитайте линки.
675.84 687.76 "Игорь Лабутин" Из полезного, из того, что меня зацепило, и того, что я сам буду счастлив использовать, во-первых, Model Binding теперь умеет нормально биндить дейтаймы с признаком UTC.
687.76 699.92 "Игорь Лабутин" Раньше была проблема, что если вам приходит время в UTC, прям вот обозначенная там строчка, заканчивающаяся на Z или что-то в таком духе, полученный дейтайм, который в C#, он все равно не будет иметь kind UTC.
699.92 707.68 "Игорь Лабутин" И нам приходилось писать специальные Model Binders, это по-моему называется, которые специально проставляют нам UTC kind.
707.68 710.64 "Игорь Лабутин" Теперь это SP NetCore делает сам за вас.
710.64 711.64 "Игорь Лабутин" Второй момент.
711.64 721.72 "Игорь Лабутин" Вы все знаете, что в классическом SP NetCore нужно написать эту волшебную конструкцию useStartup и указать имя стартап-класса, которым будет искаться метод configureServices и configure.
721.72 730.80 "Игорь Лабутин" Теперь можно указать не только имя класса, но и указать на самом деле лямбду, это позволит ваш стартап-класс использовать с какими-то конструктор-параметрами.
730.80 737.68 "Игорь Лабутин" Если, например, вы этот же класс используете из каких-то других мест еще для чего-нибудь, можно теперь хитрые параметры передавать прямо из мейна.
737.68 740.96 "Игорь Лабутин" Например, command-line параметры каким-нибудь таким образом передать.
740.96 749.70 "Анатолий Кулаков" Я использую для логгера, потому что Best Practice рекомендует, что логгер нужно инициализировать еще до того, как поднимется ваш стартап-класс.
749.70 755.68 "Анатолий Кулаков" Это нужно для того, чтобы залоггировать ошибки, которые возникают при конфигурировании, при подъеме, при поиске стартап-класса.
755.68 762.12 "Анатолий Кулаков" Поэтому прямо самой первой строчкой в мейне я делаю конфигурацию логгера, и после этого логгер у меня уже готов.
762.12 767.96 "Анатолий Кулаков" И хотелось бы его передать в мой стартап, чтобы там зарегистрировать его в контейнерах, там он начал использоваться и так далее.
767.96 773.92 "Анатолий Кулаков" Вот в принципе для вот такого маленького хака я вот такую штуку буду использовать.
773.92 784.00 "Игорь Лабутин" Ну да, то есть логгер тоже, либо еще что-то, что вы берете в мейне, там читаете какие-то специальные файлы или еще что-то, и вам нужно это все передать каким-то образом в стартап.
784.00 785.00 "Игорь Лабутин" Дальше.
785.00 794.00 "Игорь Лабутин" Неведомое, невиданное дело, Microsoft запартнерился, а точнее зареференсил сторонний NuGet пакет у себя.
794.00 807.20 "Игорь Лабутин" Если вы в .NET 5 будете генерировать Web API Project, то вам автоматически сгенерятся референсы на Swashbuckle, и автоматически включится автогенерация Swagger для ваших контроллеров.
807.20 818.16 "Игорь Лабутин" То есть это работает только в DevEnv, то есть только когда вы из-под студии запускаете отладку, ну либо ставите переменное окружение, что у вас Development Environment, но это на самом деле прикольно.
818.16 838.20 "Игорь Лабутин" То есть у вас сразу к вашей API автоматически будет подготавливаться Swagger спек, и вы сможете подергать эти ваши контроллеры прямо из браузера, потому что когда вы жмете теперь F5 на таком проекте, автоматически открывается не стандартный там root, ну, рутовый URL, а сразу именно открывается API спека.
838.20 840.60 "Игорь Лабутин" Это прямо вот здорово.
840.60 845.00 "Игорь Лабутин" Кроме того, добавили очередной кусочек конфигурации Kestrel.
845.00 850.00 "Игорь Лабутин" Он не факт, что вам сильно нужен прямо так в каждом проекте, но может быть интересен.
850.00 867.16 "Игорь Лабутин" Теперь можно в зависимости от того endpoint, на который приходит клиент, конфигурировать разные версии, поддерживаемые HTTP протоколы, то есть HTTP1, HTTP2, можно сконфигурировать, что на таких-то endpoints такой-то TLS использовать версию или какие-то разные сертификаты.
867.16 875.20 "Игорь Лабутин" В зависимости, например, от того, по какому domain name к вам пришли, вы можете использовать разные сертификаты, соответствующие этим domain именам.
875.20 882.36 "Игорь Лабутин" Позволяет хостить несколько сайтов как будто бы на одном сервере и раздавать при этом разные сертификаты.
882.36 883.36 "Игорь Лабутин" Раньше такого было нельзя.
883.36 885.36 "Игорь Лабутин" В принципе, штука полезная.
885.36 886.36 "Игорь Лабутин" Мы иногда таким пользуемся.
886.36 899.84 "Игорь Лабутин" У нас есть то, что в VCF называлось портшарингом, мы этим пользовались, в том числе между разными продуктами даже, ну, в смысле версиями продуктов, установленными на одной машине, и средствами VCF просто разносили их по domain name.
899.84 902.36 "Игорь Лабутин" Вот, теперь такое можно сделать в Kestrel тоже.
902.36 903.36 "Игорь Лабутин" Все, супер.
903.36 906.36 "Игорь Лабутин" Так, по SPnetcore все.
906.36 912.44 "Игорь Лабутин" Entity Framework Core тоже, несмотря на то, что это RC1, тоже прилетело довольно много разных обновлений.
912.44 918.52 "Игорь Лабутин" Например, в каких-то из них теперь не нужно руками прописывать many-to-many соглашения.
918.52 933.12 "Игорь Лабутин" Он сам по именованию ключей, понимание, если у вас есть два объекта, в каждом из которых есть коллекция, соответственно, противоположного объекта, то он автоматически создаст табличку many-to-many, все сам заполнит, все ключики правильно пропишет и все будет здорово.
933.12 937.12 "Игорь Лабутин" Вам не нужно в конфигурации датабейт-контекст это все прописывать.
937.12 944.76 "Игорь Лабутин" Так, есть фича, которая, она довольно старая, то есть сейчас ее улучшили, называется MapEntityTypeToQuery.
944.76 948.80 "Игорь Лабутин" Позволяет это сделать в некотором роде вьюшку новыми средствами C#.
948.80 963.52 "Игорь Лабутин" То есть вы объявляете некоторый класс, в нем объявляете некоторое количество полей и говорите Entity Framework, что если кто-либо когда-либо попросит такой класс, коллекцию таких классов, то надо исполнить вот такой-то SQL-запрос и прям пишите plain текстом SQL-запрос.
963.52 966.72 "Игорь Лабутин" Казалось бы, фича простая, ну как бы, что такого?
966.72 971.40 "Игорь Лабутин" Можно было всегда написать там from SQL и замапить результат на нужный класс.
971.40 973.08 "Игорь Лабутин" Но в дабере мы всегда так и делали.
973.08 990.96 "Игорь Лабутин" Да, вот, но здесь фишка теперь, вот клевая фишка заключается в том, что Entity Framework позволяет такой класс использовать в более сложных кверках, то есть на него можно навернуть там дальнейший join, на него можно навернуть include, и он корректно вот этот вот фрагмент SQL-я воткнет в нужное место.
990.96 999.80 "Игорь Лабутин" Ну на самом деле, конечно же, это будет просто вложенный select, но если там не что-то шибко сложное, то SQL-сервер это все поймет и корректно развернет в нормальный исполнимый запрос.
999.80 1011.88 "Игорь Лабутин" То есть, в принципе, если у вас есть такое стремление использовать вьюшки, или у вас сейчас система, например, построена на вьюхах, то можно попробовать такое дело поменять, попробовать и посмотреть, насколько это будет хорошо или плохо работать.
1011.88 1017.76 "Игорь Лабутин" Так, сейчас мы смотрим сквозь огромный лист того, что сделали в EF Core.
1017.76 1020.84 "Игорь Лабутин" Во, мой любимый тип изменений - это улучшение диагностики.
1020.84 1029.36 "Игорь Лабутин" EF Core добавил своих каунтеров, теперь можно смотреть, сколько было сейвов там в секунду исполнено, сколько было там компиляций запросов и всего такого прочего.
1029.36 1038.52 "Игорь Лабутин" Это теперь видно в .NET Monitor через новый Event Pipe, и вы можете теперь следить, как ваш EF Core работает.
1038.52 1044.44 "Игорь Лабутин" Также добавили, улучшили, на самом деле, существенно работу с миграциями, добавили поддержку транзакций.
1044.44 1052.12 "Игорь Лабутин" По дефолту, я так понимаю, теперь миграции выполняются в транзакциях, а может и раньше так было, но, в общем, что-то там они улучшили существенно вокруг транзакций.
1052.12 1059.80 "Игорь Лабутин" У нас как-то, у меня не было необходимости в сложных миграциях и не было необходимости разбираться, насколько нужны транзакции в данном случае.
1059.80 1080.04 "Игорь Лабутин" И полезная фича, кстати, законтрибьюченная сторонними ребятами, это можно теперь наконец-таки посмотреть список Pending Migrations, то есть на заданной базе написать, а вот что бы, если я сейчас попрошу тебя накатить миграции, какие миграции ты накатишь, и он выдаст список тех миграций, которые он считает нужным накатить вот сейчас, но не накатывая их.
1080.04 1085.04 "Игорь Лабутин" Это прямо теперь можно хоть посмотреть, в каком состоянии база и понять вообще, где как.
1085.04 1089.80 "Игорь Лабутин" Возможно, пригодится в каких-нибудь автоматических скриптах или еще в чем-то.
1089.80 1100.24 "Игорь Лабутин" И весьма забавный последний пункт, на который хочется обратить внимание, ребята поменяли дефолтный сайз для батчей, когда кверки отправляются в SQL-сервер.
1100.24 1107.40 "Игорь Лабутин" И после долгих измерений, после долгих экспериментов, они обнаружили, что идеальный вариант это, как ни странно, 42.
1107.40 1120.04 "Игорь Лабутин" Поэтому, если там есть даже объяснение, наверняка можно найти какой-нибудь GitHub, где это все описано, и почему 42, ну вот да, SQL-сервер 42 это…
1120.04 1127.60 "Анатолий Кулаков" Да, спросили бы не меня, я бы вам сразу сказал, без всяких поисков и траты много денег, я бы даже целую книгу дал, где обосновывается, почему так.
1127.60 1140.24 "Игорь Лабутин" Вот они в анонсе RCE, в корот, RCE 1 делают отсылки к этой книге и говорят, что да, видимо вся книга ради SQL-сервера, или SQL-сервер ради книги, или вообще SQL-сервер связан с тем, как устроен наш мир.
1140.24 1144.64 "Игорь Лабутин" Ну, в общем, примерно так у нас устроен DotNet 5 в текущем его виде.
1144.64 1151.52 "Анатолий Кулаков" Вышла отдельная статья про тип half, мы о нем уже упоминали, это что-то половинчатое.
1151.52 1153.64 "Анатолий Кулаков" Интересно, половина чего это?
1153.64 1156.04 "Игорь Лабутин" Половина, ну половина чего-то целого.
1156.04 1165.60 "Игорь Лабутин" Half, как ни странно, я сначала думал, что half это будет половина дабла, но потом понял, что половина дабла это единичка, и как-то это не то.
1165.60 1171.60 "Анатолий Кулаков" Все-таки half это половина флоата, а флоат это у нас 32 бита, если мне не изменит память, верно?
1171.60 1173.92 "Игорь Лабутин" Флоат, да, 32 бита, все так.
1173.92 1181.16 "Анатолий Кулаков" Соответственно, дабл у нас 64, и нам срочно-срочно не хватало половинку от 32 битов, то есть 16 бит.
1181.16 1182.96 "Анатолий Кулаков" Именно столько будет занимать half.
1182.96 1183.96 "Анатолий Кулаков" 16 бит.
1183.96 1187.80 "Анатолий Кулаков" Зачем нам вообще могло понадобиться такое странное среднее число?
1187.80 1207.40 "Анатолий Кулаков" Ну, прежде всего, это не какое-то абстрактное изобретение микрософта, это существующий стандарт 754, который описывает все флоат-типы, то есть сколько там должна занимать мантиса, сколько отводится бит под хранение каждого типа и так далее.
1207.40 1218.52 "Анатолий Кулаков" В этой спецификации уже давно был этот тип, он был там описан под именем Binary 16, и он очень сильно и очень много используется сейчас в машин-ленинге.
1218.52 1236.56 "Анатолий Кулаков" Он используется для экономии места, прежде всего, потому что он маленький, его быстро загружать, и какие-нибудь маленькие типики очень хорошо ложатся на интринсики, то есть инструкторы процессора, которые могут оптимально работать с маленькими флоатами.
1236.56 1247.60 "Анатолий Кулаков" Поэтому основная надежда микрософта в том, что очень много библиотек для машин-ленинга будут оптимизированы под этот тип, и они смогут добиться здесь какого-то импровмента.
1247.60 1256.12 "Анатолий Кулаков" Также в этот тип можно сохранять небольшие значения, и они будут меньше занимать сторижа на диске, допустим, в базах данных.
1256.12 1262.12 "Анатолий Кулаков" И уже многие процессоры, как я и сказал, поддерживают SIM-инструкции, оптимизированные под 16-битный флоат.
1262.12 1264.08 "Анатолий Кулаков" Что ещё интересно можно сказать про Half?
1264.08 1265.08 "Игорь Лабутин" Про Half?
1265.08 1279.20 "Игорь Лабутин" Ну, он действительно маленький, он действительно всё для хранения, с ним удобно работать, он нативно конвертится во флоат и дабл и обратно, но с ним нельзя делать никакие операции, вы не сможете их складывать, вычитать, умножать и всё остальное.
1279.20 1284.24 "Игорь Лабутин" Только для хранения, если нужна математика, то добро пожаловать во флоат и дабл обратно.
1284.24 1290.68 "Анатолий Кулаков" Ну и ещё к нему не завезли стандартный кей-ворд, маленькими буквами, как для наших любимых флоатов, даблов, винтов.
1290.68 1294.88 "Анатолий Кулаков" То есть, вам придётся писать с большой буквы настоящую ссылку на тип.
1294.88 1296.24 "Игорь Лабутин" Ну, будем пока писать.
1296.24 1300.12 "Игорь Лабутин" Если мне надо сэкономить место, я, пожалуй, напишу чуть-чуть больше кода.
1300.12 1301.12 "Игорь Лабутин" Это не страшно.
1301.12 1302.12 "Анатолий Кулаков" Потерпишь, да?
1302.12 1307.36 "Анатолий Кулаков" А это обещали исправить в будущих версиях, то есть, может быть, мы всё-таки получим отдельное ключевое слово.
1307.36 1308.36 "Анатолий Кулаков" Хорошо.
1308.36 1312.88 "Анатолий Кулаков" И ещё нас уже мучили вопросы в наших предыдущих выпусках.
1312.88 1338.32 "Анатолий Кулаков" После того, как .NET 5 объявил то, что он пытается объединить все фреймворки, все рантаймы, мир во всём мире, операционные системы, всё вместе, вот, мы задавались вопросом, а что ж теперь будет с .NET стандартом, который, по сути, и был создан для того, чтобы сделать какое-то подмножество, общее подмножество API, которые поддерживаются между всеми платформами, всеми фреймворками и всеми операционными системами.
1338.32 1347.44 "Анатолий Кулаков" Он тогда объединял Xamarin, Mon, .NET фреймворки большие, .NET фреймворки маленькие, на мобилках и так далее.
1347.44 1355.80 "Анатолий Кулаков" Вот, сейчас это всё было скуплено Microsoft, гордо объединено, названо .NET 5 и скоро уже собирается релизиться.
1355.80 1358.40 "Анатолий Кулаков" Так что же нам делать с .NET стандартом?
1358.40 1367.84 "Анатолий Кулаков" И, отвечая на этот вопрос, программный менеджер команды .NET Има Ландверт выпустил хорошую, большую, интересную статью.
1367.84 1371.80 "Игорь Лабутин" И в ней, по сути, всё сводится к довольно простым мыслям.
1371.80 1372.80 "Игорь Лабутин" Мысль первая.
1372.80 1376.04 "Игорь Лабутин" Если вы пишете на .NET 5, вы можете забыть про .NET стандарт.
1376.04 1377.28 "Игорь Лабутин" Он вам уже не нужен.
1377.28 1384.04 "Игорь Лабутин" .NET 5 это, можно сказать, .NET стандарт следующего поколения с той только разницей, что он единственный его имплементит.
1384.04 1388.28 "Игорь Лабутин" Поэтому, как бы, всё просто и легко.
1388.28 1402.84 "Игорь Лабутин" Но, если бы мы все могли перейти на .NET 5 прямо сегодня, было бы, конечно, здорово, но этого не случится в ближайшее время, тем более, что .NET 5 не является LTS релизом, поэтому кто-то будет дожидаться .NET 6 и будет по-прежнему жить на .NET Core 3 и так далее.
1402.84 1405.72 "Игорь Лабутин" Поэтому рекомендации такие.
1405.72 1417.32 "Игорь Лабутин" Если вам всё ещё зачем-то нужно шарить код за .NET Framework или какими-то другими совсем старенькими платформами, то используйте .NET стандарт 2.0.
1417.32 1426.28 "Игорь Лабутин" Есть явная рекомендация стараться уже не таргетить на стандарт 1.x в любых видах, потому что это уже совсем старьё и почти никто его не должен использовать.
1426.28 1434.64 "Игорь Лабутин" Если вам нужно шарить код между чуть более современными штуками вида MonoXAMarin и .NET Core 3.x, то это .NET Standard 2.1.
1434.64 1444.52 "Игорь Лабутин" Во всех других случаях используйте .NET 5.0, новый target framework монитор, то что мы про это уже рассказывали, и он тогда будет работать на всех .NET 5 платформах.
1444.52 1462.88 "Игорь Лабутин" Но, несмотря на то, что у нас теперь .NET 5 будет един, у нас, можно сказать, не будет уже необходимости в .NET стандарте, у нас всё равно есть зоопарк платформ, на которых какие-то API-шки могут работать, какие-то API-шки могут не работать, где-то они не представлены совсем, где-то они работают по-разному, и как-то это нужно в своём коде тоже учитывать.
1462.88 1465.72 "Игорь Лабутин" И для этого в этой статье есть тоже несколько ответов.
1465.72 1472.48 "Игорь Лабутин" Во-первых, если вам встречается, если вам необходимо написать платформ-специфик код, то у вас есть несколько вариантов.
1472.48 1477.68 "Игорь Лабутин" Во-первых, вы можете просто прямо в коде проверить, на какой операционной системе вы работаете.
1477.68 1488.28 "Игорь Лабутин" Существует теперь новый класс System.OperatingSystem, у которого можно узнать вообще, на чём нас запустили, и сообразно этому выполнить ту или иную ветку кода.
1488.28 1489.28 "Игорь Лабутин" Это рантайм-вариант.
1489.28 1500.04 "Игорь Лабутин" Второй вариант - можно попробовать чуть-чуть положиться на, так сказать, сам runtime .NET и отметить атрибутом прямо метод.
1500.04 1508.64 "Игорь Лабутин" Это атрибут supported.platform, туда передаётся, допустим, там, Linux или Windows, или что-нибудь другое, или браузер, если мы говорим о Blazor.
1508.64 1519.92 "Игорь Лабутин" И после этого runtime сам поймёт, что если этот метод отмечен, например, атрибутиком со значением Windows, а мы выполняемся на Linux, то он этот метод просто, я так понимаю, не будет вызывать вообще.
1519.92 1521.36 "Игорь Лабутин" Вроде как.
1521.36 1528.20 "Игорь Лабутин" Или будет ругаться при анализе в вышестоящем вызывающем коде про то, что вот, мол, тут есть такой код.
1528.20 1529.20 "Анатолий Кулаков" Да.
1529.20 1538.00 "Анатолий Кулаков" Мне кажется, он будет использоваться как атрибут condition, который просто в рантайме выпиливается к чёртой матери, если condition не совпал.
1538.00 1539.60 "Анатолий Кулаков" То есть это, скорее всего, наследник от condition.
1539.60 1562.00 "Игорь Лабутин" С одной стороны, да, с другой стороны, там есть прямо явные слова про то, что этот атрибут переносит, вот у них появился новый анализатор, который пытается, который знает, на самом деле, какие API на каких платформах реализованы и работают, и он будет вам просто в момент компиляции выдавать warning про то, что вы там таргетите ваше приложение на NET 5, а используйте там Windows specific API.
1562.00 1566.28 "Игорь Лабутин" И у вас будет просто warning в момент компиляции, что вот тут анализатор сработал.
1566.28 1574.64 "Игорь Лабутин" И я так понимаю, что вот этот вот supported_os_platform просто помечает метод, что вот для анализатора, что этот метод требует там Windows.
1574.64 1581.64 "Игорь Лабутин" Если вы этот метод дёрнете из какого-нибудь кода на Linux или ещё что-то, он будет и там тоже срабатывать.
1581.64 1582.64 "Игорь Лабутин" То есть это такой типа.
1582.64 1591.04 "Игорь Лабутин" Я бы сказал, что это ближе к всяким там nullable аннотациям, которые просто распространяют этот nullability дальше и дальше по коду.
1591.04 1600.20 "Игорь Лабутин" Кроме того, помимо supported_os_platform есть атрибут unsupported_os_platform, который как соответственно позволяет отметить методы, которые где-то не поддержаны.
1600.20 1603.52 "Игорь Лабутин" Видимо, бывают такие, которые не поддержаны на одной-двух платформах.
1603.52 1606.16 "Игорь Лабутин" По словам автора, это как раз таки в основном Blazor.
1606.16 1611.60 "Игорь Лабутин" То есть допустим есть штуки типа, не знаю, файловых систем, которые например поддержаны почти везде, кроме Blazor.
1611.60 1615.24 "Игорь Лабутин" И на таких методах будет стоять unsupported_os_platform.
1615.24 1618.84 "Игорь Лабутин" Браузер и соответственно анализатор тоже будет как-то ругаться.
1618.84 1625.32 "Игорь Лабутин" Этот атрибут можно вешать соответственно на member, то есть на методы, там property, на целый тип или вообще на уровень всей сборки.
1625.32 1646.32 "Игорь Лабутин" Но если вы хотите его повесить на уровень всей сборки, то проще тогда на самом деле затаргетить сборку на конкретную операционку и использовать в таком случае, как мы тоже уже обсуждали в прошлых подкастах, не net5.0, а net5.0.defice.windows или net5.0.defice.linux или любой другой соответствующий суффикс для net5.0, который позволяет затаргетить на конкретную операционку.
1646.32 1649.96 "Игорь Лабутин" Вот, что нас ждет как соответственно над стандартом.
1649.96 1654.60 "Анатолий Кулаков" Вообще очень прекрасно, как анализаторы хорошо вливаются в будущее нашей разработки.
1654.60 1663.88 "Анатолий Кулаков" То есть они помогают уже не только рефакторить код, но и анализировать ваш код с точки зрения кроссплатформенности, учитывать какие-то там особые атрибуты и так далее.
1663.88 1669.48 "Анатолий Кулаков" Очень хорошо, что Microsoft пытается на полную использовать этот довольно мощный инструмент.
1669.48 1672.80 "Анатолий Кулаков" А я на днях наткнулся на интересную статейку "Как создавать .NET Core Tools".
1672.80 1682.12 "Анатолий Кулаков" В принципе, ничего нового и откровенного, но написано довольно хорошо, поэтому я решил лишний раз опять же вспомнить, что это такое, как это работает и зачем это может быть нужно.
1682.12 1694.96 "Анатолий Кулаков" Статью написал Рик Страхл и он на примере своих инструментов рассказывает, каким образом каждый из вас, каждый из нас может сделать .NET Tool.
1694.96 1696.40 "Анатолий Кулаков" Прежде всего, что это такое?
1696.40 1702.40 "Анатолий Кулаков" .NET Tool - это обычный Core Application, который можно очень легко распространять среди ваших клиентов.
1702.40 1708.12 "Анатолий Кулаков" Делается это с помощью Nuget, самого универсального и самого прекрасного репозитория для .NET разработчиков.
1708.12 1718.72 "Анатолий Кулаков" В .NET Tool может выступать обычное консольное приложение или же вы туда можете запаковать целый ASP.NET сервер, или это могут быть маленькие утилитки, какие-то сервисы.
1718.72 1726.04 "Анатолий Кулаков" Или, если даже задуматься, то обычное Desktop приложение тоже можно таким образом расшаривать.
1726.04 1727.56 "Анатолий Кулаков" Что же хорошего в .NET Tool?
1727.56 1730.72 "Анатолий Кулаков" Это прежде всего то, что его очень легко забилдить.
1730.72 1742.88 "Анатолий Кулаков" То есть, это обычное Core приложение, которое можно с помощью шаблонизатора одной командой создать, откомпилить, запаблишить артефакты, сделать Nuget-пакет и дальше его элементарно распространять.
1742.88 1751.00 "Анатолий Кулаков" Как я уже сказал, это делается через Nuget, который кроссплатформенный, который быстрый и который поддерживается практически везде.
1751.00 1755.68 "Игорь Лабутин" Да, а как мы говорили, на нем теперь можно прямо искать эти самые тулы в отдельном фильтре.
1755.68 1765.12 "Анатолий Кулаков" В прошлом выпуске мы обсуждали это нововведение Nuget.org, если вы пропустили, перемотайте, пересмотрите и убедитесь.
1765.12 1769.90 "Анатолий Кулаков" И что еще прекрасно с тулзами в том, что их очень легко использовать.
1769.90 1781.96 "Анатолий Кулаков" На целевой системе вам достаточно просто сделать .NET Tool Install, указать имя тулзы, после этого она установится в вашу систему и будет доступна из любого места.
1781.96 1785.72 "Анатолий Кулаков" То есть, прекрасно, одной командой, как будто из пакетного менеджера мы все можем поставить.
1785.72 1788.92 "Анатолий Кулаков" Но есть один существенный минус, нужно о нем не забывать.
1788.92 1796.08 "Анатолий Кулаков" Пререквизитом для того, чтобы установить тулзы и для того, чтобы они там работали, является .NET Core SDK.
1796.08 1806.76 "Анатолий Кулаков" А это довольно-таки большая, массивная бинарина, которая скорее всего не стоит на компьютере, если вы не разработчик или не какой-то специальный компьютер.
1806.76 1809.40 "Анатолий Кулаков" Поэтому это довольно существенное ограничение.
1809.40 1816.20 "Анатолий Кулаков" Но мы все же думаем, что все мы разработчики, всех у нас .NET установлен и для нас это не проблема.
1816.20 1828.28 "Анатолий Кулаков" Тем более, что если у вас на компьютере установлен .NET SDK, это значит, что ваши утилитки, все ваши пакетики, все ваши тулзы могут уже приезжать собранными с уверенностью, что весь SDK стоит на компьютере.
1828.28 1833.40 "Анатолий Кулаков" Поэтому они будут маленькими, быстренькими и занимать мало места, что является как бы плюсом.
1833.40 1837.64 "Анатолий Кулаков" Говоря о .NET тулзах, нужно обязательно упомянуть о вопрос безопасности.
1837.64 1842.32 "Анатолий Кулаков" Это все-таки обычные .EXE файлы, которые вы скачиваете с интернета.
1842.32 1844.68 "Анатолий Кулаков" Закачать их в интернет мог кто угодно.
1844.68 1850.44 "Анатолий Кулаков" Естественно, NuGet.org проверяет на какие-то банальные вирусы и все в этом духе, но все это чушь.
1850.44 1859.16 "Анатолий Кулаков" Если вредитель захочет навредить вам, вашему компьютеру, вашим данным или так далее, то он это элементарно сможет сделать.
1859.16 1861.00 "Анатолий Кулаков" Здесь никаких рекомендаций нет.
1861.00 1865.48 "Анатолий Кулаков" Устанавливайте все на свой страх и риск, только от проверенных паблишев и от проверенных источников.
1865.48 1877.52 "Анатолий Кулаков" Справедливости и ради нужно сказать, что .NET тулз тут не вносит какую-то большую security дыру, так как мы с вами уже много-много лет используем NuGet пакеты таким же точным образом.
1877.52 1887.04 "Анатолий Кулаков" Если вы никогда не задумывались, то NuGet пакет - это по правде тоже исполняемый бинарник, пусть исполняемый не напрямую, но через ваш код, который вызывает в нем методы.
1887.04 1891.00 "Анатолий Кулаков" Но это такой же точно бинарник, который может сделать с вашей системой все что угодно.
1891.00 1893.24 "Анатолий Кулаков" Как-то живем, как-то не боимся.
1893.24 1894.80 "Анатолий Кулаков" Но нужно иметь это в виду.
1894.80 1898.80 "Анатолий Кулаков" Что же уже есть в .NET тулзах у нас?
1898.80 1900.56 "Анатолий Кулаков" На самом деле очень-очень всего много.
1900.56 1904.04 "Анатолий Кулаков" В качестве примера можно привести, например, инструменты миграции.
1904.04 1906.24 "Анатолий Кулаков" EF Core активно их использует.
1906.24 1909.12 "Анатолий Кулаков" Вы можете мигрировать базу данных из командной строки.
1909.12 1911.40 "Анатолий Кулаков" Далее Source File Watcher.
1911.40 1918.04 "Анатолий Кулаков" Это специальные веб-сервера, которые следят, какие файлы у вас поменялись и делают определенные действия.
1918.04 1925.80 "Анатолий Кулаков" Например, перезагружают вашу страничку или отправляют ваши файлики в систему контроля версий или кэшируют и так далее.
1925.80 1927.48 "Анатолий Кулаков" Это огромное количество генераторов.
1927.48 1931.08 "Анатолий Кулаков" Как код генераторов, так и ресурс генераторов, картинка генераторов.
1931.08 1933.24 "Анатолий Кулаков" Это инструменты построения кода.
1933.24 1936.20 "Анатолий Кулаков" Например, Nuke и его подобные.
1936.20 1939.44 "Анатолий Кулаков" Минимизаторы CSS, JavaScript, Linter.
1939.44 1946.36 "Анатолий Кулаков" Типичным примером является JetBrains Tools, который тоже теперь распространяется в виде .NET тула.
1946.36 1954.72 "Анатолий Кулаков" Локальные веб-приложения, благодаря которым вы получаете self-contained веб-сервер на своей локальной машине быстро и удобно.
1954.72 1969.28 "Анатолий Кулаков" И хотя Microsoft рекомендует в основном делать консольные приложения для .NET тулов, ничего вам абсолютно не мешает делать таким способом распространение Desktop-приложения на WinForm, на .DPF или на других каких-то UI.
1969.28 1976.92 "Анатолий Кулаков" Просто нужно учитывать, что .NET тул - это все-таки кроссплатформенная технология, а WinForm и .DPF только для Windows.
1976.92 1984.20 "Игорь Лабутин" Да, и вся эта прелесть и огромное количество тулов на самом деле довольно легко производить самим.
1984.20 2011.80 "Игорь Лабутин" Как было сказано, вам нужен просто обычный консольный тул, .NET New Console, дальше вы добавляете атрибутики, которые вы бы добавляли, если бы делали Nuget-пакет, типа PackageID, который будет потом использоваться как ваш ID для установки из Nuget, и добавляете главный атрибутик PackageTool, вставите его в .TOOL, после чего собираете проект в .NET BuildDom, получаете Nuget-пакет, пушите его на Nuget.org и все готово.
2011.80 2015.04 "Игорь Лабутин" Можно делать .NET Toon Install и все будет работать.
2015.04 2022.60 "Анатолий Кулаков" Тулы устанавливаются в специальную директорию, которая находится в папке пользователя, в директории .NET, Tools, Store, и там распаковывается ваш пакет.
2022.60 2032.08 "Анатолий Кулаков" Интересным моментом является то, что в тулах нет экзешника, но вы можете запустить их из любого места в вашей операционной системе из командной строки.
2032.08 2040.28 "Анатолий Кулаков" Магия заключается в том, что при инсталляции тула генерируется специальный нативный экзешник, который называется таким же точным образом, как ваш пакет.
2040.28 2048.20 "Анатолий Кулаков" Задачей этого экзешника является запуститься и вызвать метод main в вашей главной DLL.
2048.20 2054.24 "Анатолий Кулаков" То есть, по сути, он является такой проксой, такой прослойчик, который запускает ваш тул.
2054.24 2057.76 "Анатолий Кулаков" Экзешник находится в директории .NET, там же недалеко от пакетов.
2057.76 2066.88 "Анатолий Кулаков" Более детальное описание того, как создавать .NET тулзы вместе с картинками, с подробным мнением автора и так далее, вы можете найти по ссылке.
2066.88 2072.04 "Анатолий Кулаков" Автор довольно популярный, пишет довольно-таки много и хорошие, интересные статьи.
2072.04 2087.40 "Анатолий Кулаков" В качестве примеров, которыми он пытается вдохновить своих читателей делать больше .NET тулзов, он приводит свои инструменты, которые очень сильно помогают его в каждодневной работе, и также находит отклик в виде каких-то скачиваний.
2087.40 2090.52 "Анатолий Кулаков" Ну, например, это Visual Studio Snippet Converter.
2090.52 2098.56 "Анатолий Кулаков" Это специальный конвертер, который помогает вам перегонять сниппеты из формата Visual Studio, Visual Studio Code и в райдер.
2098.56 2109.08 "Анатолий Кулаков" Он путешествует между этими тремя IDE-шками в зависимости от языка и в зависимости от environment, и хочет поддерживать библиотеку сниппетов одинаково.
2109.08 2117.16 "Анатолий Кулаков" Вот этот инструмент ему помогает, элементарно устанавливается, быстро запускается, и в принципе .NET Tools - идеальная платформа для него.
2117.16 2119.48 "Анатолий Кулаков" Еще один тул - HTML Packager.
2119.48 2122.04 "Анатолий Кулаков" Он делает сел в контейнер HTML.
2122.04 2132.08 "Анатолий Кулаков" То есть представьте себе обычный стандартный HTML, он включает в себя кучу всяких ресурсов - CSS, JS, и картинки, фонты, все-все-все, все что угодно.
2132.08 2135.72 "Анатолий Кулаков" По веянию последних тенденций, self-contained рулит.
2135.72 2146.72 "Анатолий Кулаков" Хочется получить один единственный HTML, который внутри себя уже содержит все эти ресурсы, и его можно безопасно копировать в виде одного файлика, перемещать, запускать, и все будет работать.
2146.72 2149.44 "Анатолий Кулаков" Вот этот инструмент делает подобную штучку.
2149.44 2154.44 "Анатолий Кулаков" Еще один интересный проект - это Live Reload Server.
2154.44 2165.60 "Анатолий Кулаков" Это стандартный веб-сервер, который можно запустить локально на своем компьютере, указать ему директорию с вашими файликами, и он их будет раздавать, как сервер.
2165.60 2182.84 "Анатолий Кулаков" Этот сервер может раздавать статические файлы, может раздавать razor pages, markdown pages, и еще одна интересная фишка у него - он умеет перезагружать страничку в вашем браузере, как только любая зависимость, которую он сейчас наблюдает, поменялась.
2182.84 2188.12 "Анатолий Кулаков" Если вы хотите изменить CSS-файл, вы можете поменять razor pages, и автоматически браузер его перегрузит.
2188.12 2198.60 "Анатолий Кулаков" Это очень удобно, если вы, например, что-то разрабатываете, и вам нужно быстрое live preview, и на локальном компьютере без всяких IS-ов и прочей глупости вам нужен сервер.
2198.60 2200.56 "Анатолий Кулаков" Вот тоже такой полезный инструмент.
2200.56 2206.16 "Анатолий Кулаков" Как вы видите, огромное количество разнообразного инструмента можно сделать с помощью .NET Tools.
2206.16 2222.52 "Анатолий Кулаков" У нас также в ссылочках будет большой архив на GitHub .NET Tools, который поддерживается доброжелателем, и там вы наверняка сможете найти для себя какие-нибудь интересные тулзы, которые легко устанавливаются, легко шарятся и легко запускаются.
2222.52 2224.60 "Анатолий Кулаков" Также пробуйте писать свои штучки.
2224.60 2225.60 "Игорь Лабутин" Да.
2225.60 2233.88 "Игорь Лабутин" А от маленьких тулзов давай перейдем к более крупным тулзам, а именно объявлен roadmap на ReSharper и Rider 2020.3.
2233.88 2242.48 "Игорь Лабутин" И на самом деле в этот раз, сколько мы не обсуждали ReSharper и Rider, в этот раз меня прям радует набор фич, которые анонсированы.
2242.48 2253.36 "Игорь Лабутин" Не факт, что все они, конечно, войдут в 2020.3, но шансы хорошие, и будем с интересом следить и освещать, какие изменения и какие фичи таки будут сделаны.
2253.36 2254.36 "Игорь Лабутин" Пробежимся по ним.
2254.36 2259.28 "Игорь Лабутин" В ReSharper, ну, понятное дело, расширенная поддержка .NET и C#.
2259.28 2269.48 "Игорь Лабутин" Нужно поддерживать новые .NET 5, нужно поддерживать всякие фичи типа top-level statements, target-typed new expressions, new lability расширять дальше.
2269.48 2279.52 "Игорь Лабутин" В том числе заявлена конверсия между атрибутами JetBrains и Microsoft, соответственно, JetBrains Annotations, и Microsoft можно туда-сюда гонять их будет.
2279.52 2283.84 "Игорь Лабутин" Улучшена, и я так понимаю, существенно доработана Command Line версия.
2283.84 2290.80 "Игорь Лабутин" Будет, точнее, улучшена и доработана, потому что пока это всего лишь планы.
2290.80 2294.48 "Игорь Лабутин" Важная часть про ReSharper, это, конечно же, out of process.
2294.48 2297.00 "Игорь Лабутин" Основные архитектурные рефакторинги закончены.
2297.00 2303.76 "Игорь Лабутин" И теперь нужно потихонечку переводить всю существующую функциональность на использование этого самого внешнего ReSharper H100.
2303.76 2314.52 "Игорь Лабутин" Поэтому этот процесс начнется, скорее всего, уже, конечно, начался, и будем следить, как это будет влиять на быстродействие студии с открытым большим количеством проектов и солюшенов.
2314.52 2319.28 "Игорь Лабутин" Конечно же, JetBrains не мог пройти мимо своего любимого поиска.
2319.28 2325.80 "Игорь Лабутин" То есть, пожалуй, поиск - это, наверное, первая, по крайней мере, наверное, одна из самых клевых фич, которую использовал я, когда использовал ReSharper.
2325.80 2327.72 "Игорь Лабутин" Сейчас я его поменьше использую.
2327.72 2328.72 "Игорь Лабутин" Это, конечно же, поиск.
2328.72 2331.40 "Игорь Лабутин" Поиск чего угодно, где угодно, когда угодно.
2331.40 2346.16 "Игорь Лабутин" И он хорошо ищет, он хорошо ищет по кусочкам слов, но JetBrains закономерно подумали, а что если мы допускаем опечатки, а что если мы как-то в очень длинном идентификаторе где-то ошиблись, забыли кусочек слова.
2346.16 2348.64 "Игорь Лабутин" И поэтому они решили, что они будут делать то, что называется fuzzy search.
2348.64 2351.16 "Игорь Лабутин" То есть, такой нечеткий поиск.
2351.16 2355.52 "Игорь Лабутин" Он будет искать примерно то, что вам надо, но, наверное, с хорошей степенью вероятности угадывая.
2355.52 2362.88 "Анатолий Кулаков" Меня очень часто выручает, например, то, когда я начинаю набивать почему-то по-русски имена классов, имена полей, и он это, сволочь, все находит.
2362.88 2364.56 "Анатолий Кулаков" Я просто в этот момент дико радуюсь.
2364.56 2370.52 "Игорь Лабутин" Да, русский, английский, ну, как бы, объяснимо, потому что компания все-таки наша.
2370.52 2376.16 "Игорь Лабутин" Вряд ли, если ты начнешь набивать на каком-нибудь чешском или немецком, он поймет.
2376.16 2378.00 "Игорь Лабутин" Хотя не исключаю, я просто не пробовал ни разу.
2378.00 2386.40 "Игорь Лабутин" Но fuzzy search, когда там постоянно путаешь каких-нибудь пар символов местами или еще что-то, наверное, поможет в этом случае.
2386.40 2387.40 "Игорь Лабутин" Дальше.
2387.40 2391.24 "Игорь Лабутин" Есть в ReSharper такая фича, вы ее наверняка видели, называется inlay hints.
2391.24 2396.64 "Игорь Лабутин" Это те самые имена типов, которые пишутся перед всякими параметрами, переменными и так далее.
2396.64 2398.88 "Игорь Лабутин" Мне они, честно говоря, мешают.
2398.88 2406.76 "Игорь Лабутин" То есть я когда читаю код, то ли у нас стандарт кодирования такое, то ли еще что-то, в большинстве случаев я и так примерно знаю, что здесь за тип.
2406.76 2411.24 "Игорь Лабутин" Мне вот эти серенькие еле видные имена типов как-то мешают.
2411.24 2423.40 "Игорь Лабутин" Обещается, что эта штука будет серьезно пересмотрена и действительно убрана в тех местах, где она визуально вроде как кому-то мешает, но возможно добавлены какие-то новые идеи, так что ждем, что же там придумает команда.
2423.40 2426.48 "Игорь Лабутин" Так, отладчик.
2426.48 2433.44 "Игорь Лабутин" Отладчик это прям будет супер, потому что он теперь станет предсказательным в каком-то смысле.
2433.44 2441.16 "Игорь Лабутин" То есть он будет, вы стоите на какой-то строчке, но он будет пытаться предсказать, куда пойдет исполнение программы.
2441.16 2448.68 "Игорь Лабутин" Ну в принципе, он знает все значения переменных, которые будут исполняться, чтобы не предсказать, куда пойдет этот иф через 2-3 строчки.
2448.68 2465.48 "Игорь Лабутин" Вести это прям возможно действительно сэкономит, потому что я не раз себя ловил на ситуации, что ты что-нибудь отлаживаешь, отлаживаешь, отлаживаешь, выясняешь, ага, в этом месте в иф мы ушли налево, окей, перезапускаемся заново, доходим до этого места, но уже перед ифом и пытаемся понять, а почему мы ушли налево.
2465.48 2475.24 "Игорь Лабутин" То есть это требует двух прогонов, здесь как бы наверное нам теперь будут подсказывать, что вот тут мы сейчас пойдем налево, и можно сразу остановиться и понять, а зачем или почему.
2475.24 2482.24 "Игорь Лабутин" Улучшение декомпайлера, ну понятно, опять же поддержка новых фич, тут надо C#, чтобы все это красиво выглядело.
2482.24 2501.72 "Игорь Лабутин" Улучшение и новая на самом деле штука под названием Endpoint Viewer, как мы говорили, Microsoft у себя добавила поддержку Swagger, C# не отстает и они добавят прямо Endpoint Viewer, то есть некоторый аналог Swagger, который путем анализа ваших атрибутиков, например, на контроллерах, сможет сразу выдать, как выглядит ваша опишка.
2501.72 2505.12 "Игорь Лабутин" И скорее всего, видимо, удастся еще ее и подергать из своих окошечек.
2505.12 2509.44 "Анатолий Кулаков" Ну то есть у Microsoft это все-таки собирается с Swagger, это в рантайме, вот.
2509.44 2516.72 "Анатолий Кулаков" А ReSharper будет это делать с помощью именно анализа исходного кода, то есть я смогу даже без запуска получить картину моих Endpoints, правильно?
2516.72 2532.84 "Игорь Лабутин" Да, я не очень знаю, насколько она полезна без запуска, то есть я скорее надеюсь, что это будет некоторый да, аналог Swagger и аналог там красивого, не знаю, юнит тестового окошка, например, где можно будет там выбрать какой конкретный нужный мне Endpoint и что-нибудь его дернуть как-нибудь.
2532.84 2535.96 "Игорь Лабутин" Ну, посмотрим, не знаю, ждем с интересом.
2535.96 2544.04 "Игорь Лабутин" Ну и, как обычно, наверняка отсыплют много новых Code Inspections, то есть в частности обещанные новые инспекции вокруг Antity Framework и вокруг юнитестов.
2544.04 2545.04 "Игорь Лабутин" Посмотрим, подождем.
2545.04 2546.56 "Игорь Лабутин" Да, забыл одну штуку.
2546.56 2550.72 "Игорь Лабутин" ReSharper, конечно, ReSharper обещает что-то про Avalon'ю.
2550.72 2558.84 "Игорь Лабутин" И они, как я понимаю, они обещают начать поддерживать различные кусочки синтексис в UI на разметке Avalon'и.
2558.84 2563.48 "Игорь Лабутин" Avalon'и, если кто не знает, это UI-фреймворк кроссплатформенный.
2563.48 2571.40 "Игорь Лабутин" Наверное, пожалуй, один из самых популярных, если не брать Xamarin какой-нибудь, который прям майкрософтовский айс таких сторонних открытых фреймворков.
2571.40 2575.16 "Игорь Лабутин" И вот его как раз-таки теперь ReSharper будет потихонечку начинать поддерживать.
2575.16 2582.72 "Анатолий Кулаков" Да, если не брать микрософтовские фреймворки, то, наверное, это самый популярный не микрософтовский UI-фреймворк кроссплатформенный и все такое.
2582.72 2596.76 "Анатолий Кулаков" А у Avalon'и действительно будет поддерживать синтексис ее биндингов и также CSS-like синтексис, который тоже есть только в Avalon'е и который является одним из ее интереснейших преимуществ.
2596.76 2599.96 "Игорь Лабутин" Окей, теперь давайте пробежимся по планам райдера.
2599.96 2603.20 "Игорь Лабутин" Ну, конечно же, DotNet 5, ну куда же без него.
2603.20 2605.20 "Игорь Лабутин" Конечно же, перформанс.
2605.20 2613.16 "Игорь Лабутин" Есть забавный раздел, называется Enterprise Features, то есть поддержка, так сказать, всяких энтерпрайзных разработчиков.
2613.16 2620.64 "Игорь Лабутин" Она заключается в том, что будет чуть улучшена и реализована поддержка Ease, то есть можно будет легче оттачиться ко всяким Ease процессам.
2620.64 2632.88 "Игорь Лабутин" Как обычно, их десятки могут рождаться на системе, если у вас более-менее какое-то активное приложение и нужно правильно уметь выбирать, к какому V3WP приоттачиться, вот видимо райдер нам будет в этом как-то помогать.
2632.88 2640.40 "Игорь Лабутин" Переработают Immediate Window, переработают Toolbars, добавят возможность смотреть на структуру проекта.
2640.40 2643.92 "Игорь Лабутин" Ну это уже есть в ReSharper, то есть просто по сути портирование существующих фич.
2643.92 2657.76 "Игорь Лабутин" И добавят из интересного еще возможность миграции сеттингов из разных других IDE, то есть можно будет видимо райдеру сказать, вот моя Visual Studio, сделай так, чтобы ты выглядел и работал как Visual Studio.
2657.76 2665.92 "Игорь Лабутин" И у тебя будут такие же шорткаты, такие же лейауты окошек, те же плагины, ну не те же плагины, а конечно же аналоги, но он постарается подобрать.
2665.92 2692.52 "Анатолий Кулаков" Да, было бы просто замечательно, потому что несмотря на всю дружелюбность и попытку команды JetBrains изначально сделать райдер похожим на Visual Studio для разработчиков, то есть была такая концепция, чтобы они чувствовали себя там более или менее уютно, все равно он дико отличается, просто мега отличается, особенно если вы используете фичи Visual Studio и ReSharper на полную, то безусловно вы разницу чувствуете просто огромную и это очень неудобно вам от этого становится работать.
2692.52 2700.12 "Анатолий Кулаков" Вот и чем больше будет вот это похоже, чем больше разработчики будут чувствовать себя в своей тарелке, мне кажется, тем лучше для них будет, для райдера.
2700.12 2711.56 "Игорь Лабутин" Да, ну посмотрим, поглядим, это roadmap, то есть никаких пока обещаний, что из этого будет сделано, что не сделано, так что мы будем следить и вы от нас, конечно же, услышите о любых новостях, которые там будут происходить.
2711.56 2715.68 "Игорь Лабутин" Ну давайте перевернемся к Visual Studio, в Visual Studio тоже есть о чем поговорить.
2715.68 2720.08 "Анатолий Кулаков" Да, Visual Studio Codespaces, он сдох, ну как сдох, не сдох, а слился.
2720.08 2749.40 "Анатолий Кулаков" Мы уже рассказывали про Codespaces, это такое cloud-powered окружение для разработчиков, где каждый разработчик может разрабатывать какой-то определенный проект, при том независимо от того, на каком компьютере этот разработчик сейчас находится, под какой операционной системой он находится, все его настройки шарятся в облаке, все его любимые плагины уже установлены в его любимом environment и ему не обязательно даже знать, где находится репозитория с его кодом.
2749.40 2763.00 "Анатолий Кулаков" То есть он получает такой своеобразный cloud-компьютер, к которому он может подключиться, загрузить туда нужные ему код и это все будет работать уже настроенным под него и будет работать с нужными ему характеристиками.
2763.00 2766.12 "Анатолий Кулаков" Это все называлось Visual Studio Codespaces.
2766.12 2770.56 "Анатолий Кулаков" Таким же точно образом существовал параллельный проект, который назывался GitHub Codespaces.
2770.56 2776.36 "Анатолий Кулаков" Наверное, совпадение имен не случайно и Microsoft тоже думал как-то об объединении этих проектов.
2776.36 2782.40 "Анатолий Кулаков" GitHub Codespaces имел под собой ту же самую идею, все было то же самое, но просто параллельно существовало два проекта.
2782.40 2785.44 "Анатолий Кулаков" И вот новость заключается в том, что эти два проекта слились вместе.
2785.44 2792.80 "Анатолий Кулаков" И интересно в том, что убили именно ажуровскую версию Codespaces, а оставили GitHub Codespaces.
2792.80 2806.68 "Анатолий Кулаков" Microsoft это связало с тем, что у GitHub уже есть большое количество разработчиков, которые любят GitHub, которые уже к нему привыкли и интегрироваться намного удобнее будет именно через него, через GitHub.
2806.68 2813.36 "Анатолий Кулаков" То есть на GitHub сделать одну единственную кнопочку и открыть мне этот репозиторий в моем любимом environment в облаке.
2813.36 2821.80 "Анатолий Кулаков" Чем тащить людей на ажур, заставить их там регистрироваться, выбирать какие-то непонятные настройки, клонировать откуда-то репозиторий и так далее.
2821.80 2824.36 "Анатолий Кулаков" В принципе, довольно логичное решение.
2824.36 2832.08 "Анатолий Кулаков" Сейчас GitHub Codespaces находится в лимитированной публичной бете, то есть вы можете попросить туда доступ и может быть вам его дадут.
2832.08 2835.72 "Анатолий Кулаков" И вы можете посмотреть, как это работает на живую.
2835.72 2846.92 "Анатолий Кулаков" Что касается ажуровского Codespaces, то он присуществует до 17 февраля 2021 года, после этого прекратит свою работу и все аккаунты будут удалены.
2846.92 2852.72 "Анатолий Кулаков" Ну я не думаю, что он успел заработать уже очень много клиентов, поэтому это небольшая потеря.
2852.72 2861.48 "Игорь Лабутин" Он вроде тоже был в какой-то бете или не бете, так что там да, скорее всего все более-менее предполагали, что это пока еще не продакшн прям совсем.
2861.48 2865.16 "Анатолий Кулаков" Ну идея интересная, посмотрим, как она будет развиваться дальше.
2865.16 2891.16 "Игорь Лабутин" Мне кажется, эта идея прям вот хорошо матчится на еще там серверлесс, ты очень классно говорил про то, что открыть проект, который непонятно где находится, неизвестно где, открываем тоже в облаке и мне кажется, вот надо написать кусочек кода в виде функции и запифигачить в какой-нибудь серверлесс, чтобы там функции запускались и в общем никаких тебе ASP.NET, ничего такого, пишем функции в облаке, кидаем туда же в облако, они там исполняются и все.
2891.16 2895.40 "Анатолий Кулаков" То есть еще непонятно, где деплоются, непонятно, где исполняются, непонятно, как масштабируются, но
2895.40 2899.36 "Игорь Лабутин" это все работает. Да, но самое главное непонятно, где смотреть диагностику.
2899.36 2901.56 "Игорь Лабутин" Диагностика вся будет в ажур-дашбарде, ну.
2901.56 2906.80 "Игорь Лабутин" А, ну хорошо, ладно, туда еще надо найти, в каком из них, мы же неизвестно куда задеплоили.
2906.80 2908.56 "Игорь Лабутин" Ладно, поехали дальше.
2908.56 2913.88 "Игорь Лабутин" Наткнулся я тут в новостях на штуку под названием High Performance Package.
2913.88 2915.92 "Игорь Лабутин" Название такое прям, ух.
2915.92 2917.20 "Игорь Лабутин" Вызывающее, вызывающее.
2917.20 2919.84 "Игорь Лабутин" High Performance я люблю, пошел смотреть, что это такое.
2919.84 2926.32 "Игорь Лабутин" Оказалось, что на самом деле довольно давно существует уже такая штука под названием как Windows Community Toolkit.
2926.32 2931.40 "Игорь Лабутин" И мы как-то ее не затрагивали никогда, я ее тоже никогда не видел.
2931.40 2933.40 "Игорь Лабутин" И я понял почему.
2933.40 2938.88 "Игорь Лабутин" Потому что этот Toolkit, это штука, которая в идеале драйвится как бы комьюнити.
2938.88 2952.68 "Игорь Лабутин" И это просто открытый проект на GitHub, куда контрибьют все, кому хочется в каком-то смысле, включая самих майкрософтовцев, который предназначен для того, чтобы упростить написание Universal приложений для Windows 10.
2952.68 2956.92 "Игорь Лабутин" Я как-то никогда эти Universal приложения не писал, не написал ни на C#, ни на чем.
2956.92 2958.72 "Игорь Лабутин" Поэтому мне это было не очень интересно.
2958.72 2963.04 "Игорь Лабутин" И действительно большая часть этого Community Toolkit - это всякие разные контроллы.
2963.04 2970.08 "Игорь Лабутин" Просто прям огромное количество контролов, всех видов, сортов, цветов, форм и размеров, которые умеют делать все, что угодно.
2970.08 2972.92 "Игорь Лабутин" Там строить графики, отображать карты, что хотите делать.
2972.92 2977.40 "Игорь Лабутин" Если вы вдруг пишете UVP-приложение, загляните туда, там прям дофига.
2977.40 2980.04 "Игорь Лабутин" Ну, наверное, может вы и так про него знаете, если вы их пишете.
2980.04 2993.92 "Игорь Лабутин" Но, как оказалось, большая часть этих проектов, оно используется на C#, оно таргетится вполне себе на адекватные версии, то есть это нетстандарт 2.0, местами даже 1.4 встречался.
2993.92 2997.96 "Игорь Лабутин" И там есть некоторое количество полезных хелперов, которые могут вам пригодиться.
2997.96 3003.36 "Игорь Лабутин" Пусть не в виде, ну, get-пакетов, но, по крайней мере, как идею посмотреть в коде, может быть, будет полезно.
3003.36 3012.12 "Игорь Лабутин" То есть там есть какие-то простые хелперы, типа там проверить, что в строчке email, или там в строчке номер телефона, или там какие-то красивые хелперы вокруг массивов.
3012.12 3014.64 "Игорь Лабутин" Это простые штуки.
3014.64 3023.12 "Игорь Лабутин" Есть более сложные штуки, например, там есть достаточно развесистые клиенты для работы с C#, с Facebook, с OneDrive, с Twitter.
3023.12 3029.72 "Игорь Лабутин" Если вам вдруг это надо, поглядите, по крайней мере, какие-то идеи, возможно, вы оттуда вытащите, а может прямо наугад сможете заиспользовать.
3029.72 3040.32 "Игорь Лабутин" Там есть пара парсеров, там есть парсер Markdown, который вам дает объектную модель из Markdown файла, ну или из Markdown стрима, что тоже может быть интересно.
3040.32 3046.60 "Игорь Лабутин" И вроде как даже есть рендерер для него, но это опять же, если вам нужно, это в UVP.
3046.60 3050.24 "Игорь Лабутин" Но то, что меня привлекло, это тот самый High Performance Package внутри.
3050.24 3057.24 "Игорь Лабутин" То есть вообще весь этот Community Toolkit, это там набор, по-моему, из десятка или двадцати, ну, get-пакетов, они совершенно независимы друг от друга.
3057.24 3062.20 "Игорь Лабутин" И вот High Performance Package, там буквально десяток классов, но они весьма интересные.
3062.20 3067.08 "Игорь Лабутин" Во-первых, там есть два класса, MemoryOwner и SpanOwner.
3067.08 3075.08 "Игорь Лабутин" Те, кто пытался работать с memory-спанами, прекрасно знают, что, ну, спаны, понятно, вы объявили их локально, с ними как-то работаете, все хорошо.
3075.08 3086.64 "Игорь Лабутин" А вот с memory там сложнее, вы можете попросить memory, memory отличается от спаны тем, что вы его можете кинуть в heap, и он там будет лежать.
3086.64 3089.96 "Игорь Лабутин" Но если вы хотите получить оттуда спан, его нужно отдельно попросить.
3089.96 3097.16 "Игорь Лабутин" И что спан, что memory, даже если вы просите его какого-то за одного размера, вам дадут его как минимум такого размера, но могут дать больше.
3097.16 3106.36 "Игорь Лабутин" Ну, точнее, когда вы просите из RayPool, потом из этого получаете спан, конечно же, вам нужно его заслайсить сначала до нужного размера, если вам нужен точно нужный размер.
3106.36 3124.52 "Игорь Лабутин" Вот как раз-таки MemoryOwner занимается тем, что сам вам слайсит все как надо, возвращает нужный вам, скажем так, спан с нужными размерами, и кроме того, реализует pattern disposable, чтобы вы не заморачивались, как это все вернуть обратно через try-final, RayPool.return и так далее.
3124.52 3125.96 "Игорь Лабутин" В общем, оно само все сделает за вас.
3125.96 3130.32 "Игорь Лабутин" Если вы много работаете со спанами и с memory, посмотрите на этот класс.
3130.32 3137.84 "Игорь Лабутин" Как я говорю, может быть, напрямую использовать не обязательно, но по крайней мере, как идея кода, вам будет интересно.
3137.84 3142.08 "Игорь Лабутин" И вторая штука, которая там интересная есть, это класс ref(t).
3142.08 3161.16 "Игорь Лабутин" Если мы вспомним, как реализован спан, то спан - это, по сути, класс, точнее, это не класс, а это ref struct, то есть это специальная структура, которая должна жить только на стэке и никогда-никогда-никогда не попадать в heap, который внутри себя содержит managed pointer, то есть указатель на тот самый массив, ну и смещение в нем, плюс длина.
3161.16 3173.44 "Игорь Лабутин" Указатель этот, по сути, является в идеале, если бы его объявлять в C#, то это было бы ref field, то есть это reference на тип t, потому что элемент массива у нас типа t.
3173.44 3180.12 "Игорь Лабутин" К сожалению, спецификация C# и даже спецификация CLR, насколько я помню, не позволяет иметь ref field.
3180.12 3187.52 "Игорь Лабутин" Поэтому сейчас это сделано в рантайме с парой хаков, и есть, соответственно, класс ref(t), который ZHack'и воспроизводит уже для вас.
3187.52 3201.76 "Игорь Лабутин" То есть, если вам вдруг интересно посмотреть на то, как это реализовано и как это можно использовать у вас, если вам нужна концепция ref field, то есть какие-то managed pointers, которые вы хотите класть при этом в другие ref структуры и вот это все, то посмотрите на исходник.
3201.76 3214.64 "Игорь Лабутин" При этом, когда я эту новость нашел, буквально вот сегодня-вчера опубликовали, чтобы вы думали, пропозал для следующей версии C# о собственной реализации этих самых ref fields.
3214.64 3225.12 "Игорь Лабутин" И с одной стороны казалось бы, что там наверняка все готово, ну раз спан сделали, раз сделали специальную поддержку в рантайме, то там чуть-чуть доделать, синтексис доделать, допилить немножко компилятор и все хорошо.
3225.12 3229.64 "Игорь Лабутин" Но если бы было все так просто, C# давно бы уже имел наверное раза в три больше фич.
3229.64 3247.28 "Игорь Лабутин" Пропозал занимает, ну на моем ноутбуке это примерно экранов 15, подробнейшее в описании, как это должно работать, причем где-то два экрана занимают описание, ну так сказать, happy сценария, вот использовать надо так, а остальное это описание того, что может пойти не так.
3247.28 3254.48 "Игорь Лабутин" То есть всех случаев, когда что-то должно не давать, не разрешаться, так нельзя, и так нельзя, тут нужно компилятор отругаться, тут рантайм, тут аналайзер, тут и так далее.
3254.48 3278.56 "Игорь Лабутин" В общем, если вам интересно, как происходит дизайн таких вот фич, которые казалось бы простые, но сильно влияют на рантайм и на язык, загляните в pull request, ссылочка будет в комментариях, и там прям отличный дизайн от Джаррида Парсонса, который, соответственно, позволит вам понять, как такие фичи вообще делаются, и сколько времени нужно, чтобы просто хотя бы написать такой пропозал.
3278.56 3281.80 "Игорь Лабутин" Мне кажется, там, не знаю, я бы такой недельки две писал, не делал.
3281.80 3286.80 "Анатолий Кулаков" А еще теперь будет обсуждение, примерка, тестирование и так далее.
3286.80 3287.80 "Анатолий Кулаков" То есть это только начало.
3287.80 3304.52 "Игорь Лабутин" Да, то есть это все, тут просто исходная идея про то, что вот давайте, ну возможно он это как-то обсуждал, понятно, голосом там внутри своей группы, там, компилятора, но все равно это прям долгий-долгий-долгий процесс, ну, Dc# 10, нам еще жить и жить, так что время есть.
3304.52 3320.08 "Анатолий Кулаков" Говоря о performance, нельзя не упомянуть свеженькую статейку от Майони, которая тут прогремела во всех твиттерах, где она довольно подробно рассказала о основах .NET performance, анализа для .NET.
3320.08 3328.04 "Игорь Лабутин" Ну, статеечка, это ты так ее очень классно назвал, потому что на самом деле это такой монументальный труд, мне кажется, и он все еще дополняется и развивается.
3328.04 3342.76 "Игорь Лабутин" Это действительно большой-большой-большой обзор того, как работает .NET и в целом garbage collector в частности, и про то, как его правильно анализировать, точнее как анализировать ваши .NET приложения, если у вас кажется, что есть проблемы производительности.
3342.76 3362.20 "Игорь Лабутин" И в отличие от многих инструкций, она не начинает сразу с момента, там, берете профайлер, запускаете, что-нибудь смотрите, она как раз-таки начинает, во-первых, там есть подробнейший обзор того, как работает память и как на это влияет garbage collector, а второе, она как раз-таки говорит, сначала вообще поймите, что надо делать.
3362.20 3376.00 "Игорь Лабутин" Я очень кратенько постараюсь пробежаться по основным тезисам, но если у вас есть подозрение, что ваше .NET приложение работает как-то не так с точки зрения производительности, то загляните, почитайте, даже для общего образования это будет в частности полезно.
3376.00 3384.12 "Игорь Лабутин" Итак, во-первых, первая мысль, она довольно простая, но немногие о ней задумываются, про то, что оптимизировать это приложение можно под разные вещи.
3384.12 3387.12 "Игорь Лабутин" То есть у вас могут быть три глобальных цели.
3387.12 3398.68 "Игорь Лабутин" У вас может быть цель побороться за количество памяти, то есть если вам нужно, например, очень много копий вашей программки запихнуть на какую-нибудь машинку, то вам нужно, естественно, чтобы каждая копия жрала не очень много.
3398.68 3399.68 "Игорь Лабутин" Это первое.
3399.68 3405.52 "Игорь Лабутин" Второе, вам, может быть, надо бороться за пропускную способность, то есть количество реквестов в секунду.
3405.52 3406.92 "Игорь Лабутин" И это немножко другое.
3406.92 3414.80 "Игорь Лабутин" Тут на память можно подзабить, зато каким-то образом разрулить что-то другое, чтобы garbage collector вас не очень часто отвлекал от обработки реквестов.
3414.80 3430.28 "Игорь Лабутин" И третье, вам нужно, может быть, оптимизировать latency, то есть время задержки на ваши реквесты, потому что у вас может быть какой-нибудь слей на какой-нибудь персентиль, и, соответственно, вам нужно делать так, чтобы, опять же, garbage collector вам не сильно мешал.
3430.28 3437.80 "Игорь Лабутин" Мысль вроде как простая, но многие, как мне кажется, когда говорят про перспонс, говорят просто "У нас медленно, давай сделаем быстро".
3437.80 3440.28 "Игорь Лабутин" А что такое быстро, это непонятно.
3440.28 3444.60 "Игорь Лабутин" И вторая, простая мысль, не надо гадать, нужно измерять.
3444.60 3447.12 "Игорь Лабутин" И измерять нужно с умом.
3447.12 3452.04 "Игорь Лабутин" Во-первых, нужно измерять не только ту ключевую характеристику, ради которой вы оптимизируете.
3452.04 3459.84 "Игорь Лабутин" То есть, если вы, допустим, оптимизируете throughput, то есть количество реквестов, то измерять количество реквестов, несомненно, надо.
3459.84 3466.56 "Игорь Лабутин" Но вы по этим значениям поймете, что у вас все плохо, но у вас нет никаких других измерений, чтобы понять, почему плохо.
3466.56 3469.00 "Игорь Лабутин" Поэтому измерять надо всегда чуть больше, чем вам нужно.
3469.00 3470.00 "Игорь Лабутин" А что такое чуть?
3470.00 3471.76 "Игорь Лабутин" Ну, как раз читайте детально статью.
3471.76 3474.04 "Игорь Лабутин" Мысль две.
3474.04 3487.08 "Игорь Лабутин" Измерять нужно те области, за которыми вы следите, плюс нужно обязательно измерять влияние всех тех факторов, которые, скорее всего, вам могут эти метрики ваши как-то ухудшить.
3487.08 3496.44 "Игорь Лабутин" То есть, если вы знаете, что боретесь за memory footprint, ну, наверное, вам нужно мерить сам memory footprint, а также то, насколько часто и много вы опакетите в garbage collector.
3496.44 3501.84 "Игорь Лабутин" Если вы боретесь за throughput, наверное, вам нужно мерить garbage collector pause time, ну и так далее.
3501.84 3505.64 "Игорь Лабутин" То есть, всякие такие штуки, надо немножко понять, что мерить.
3505.64 3516.56 "Игорь Лабутин" И еще момент, тоже довольно важный, очень сильно вас должно беспокоить, вы пишете просто приложение или вы пишете библиотеку, ну или, не дай бог, дотланд фреймворксом.
3516.56 3521.20 "Игорь Лабутин" Потому что в случае с вашим приложением вы контролируете, по сути, практически все.
3521.20 3525.04 "Игорь Лабутин" Вы можете переписать алгоритмы, вы можете поменять код, вы можете сделать все, что угодно.
3525.04 3528.56 "Игорь Лабутин" А если вы пишете библиотеку, вы понятия не имеете, где она будет использоваться.
3528.56 3540.16 "Игорь Лабутин" И в идеале нужно, во-первых, ее оптимизировать достаточно качественно, во-вторых, может быть даже предоставлять несколько разных API, в зависимости от того, вам нужно удобно или быстро.
3540.16 3546.88 "Игорь Лабутин" Потому что большинству народу, наверное, нужно удобно, но есть могут быть те, которым нужно быстро, и для них тоже нужно сделать какой-то API.
3546.88 3552.68 "Игорь Лабутин" Это все было всего лишь введение, то есть это там такое развеситое, огромное введение на много-много экранов.
3552.68 3557.16 "Игорь Лабутин" Дальше идет примерно такое же описание про то, как вообще работает память, garbage collector.
3557.16 3561.60 "Игорь Лабутин" И если вы не читали книгу Конрада Кокоса, то вот здесь будет хорошая выжимка.
3561.60 3567.16 "Игорь Лабутин" Если же читали книгу Конрада, то, скорее всего, тоже полезно прочитать и как-то еще раз напомнить себе в голове.
3567.16 3581.44 "Игорь Лабутин" После того, как вы знаете, как работает у вас память, как работает garbage collector, вы знаете, что нужно мерить, вы знаете, как нужно мерить, дальше возникает вопрос, а собственно, когда начать беспокоиться, что у нас все медленно и бежать, расчехлять свои профайлеры.
3581.44 3589.08 "Игорь Лабутин" И здесь нужно смотреть, как я уже сказал, на метрики приложения, здесь нужно смотреть на метрики garbage collector.
3589.08 3597.52 "Игорь Лабутин" Но не нужно бездумно собирать все, что только можно, потому что это тоже вредит, и огромное количество цифр не означает, что у вас есть много данных и готовый ответ.
3597.52 3602.92 "Игорь Лабутин" Нужно тщательно подходить к тому, что вы собираете, в зависимости от того, что вы собираетесь оптимизировать и что вам важно.
3602.92 3609.40 "Игорь Лабутин" Читайте статью, там есть прям конкретные рекомендации, что конкретно нужно собирать про garbage collector в разных сценариях.
3609.40 3615.40 "Игорь Лабутин" Ну и последний раздел, он тоже довольно огромный, это, собственно, тулы.
3615.40 3621.92 "Игорь Лабутин" И по сути, с тулами в области перформанс-анализа, по крайней мере, если верить Маоне, сейчас дела обстоят так.
3621.92 3627.68 "Игорь Лабутин" Что на Линуксе, что на Виндуксе, нужно каким-то образом собрать данные, а потом их смотреть.
3627.68 3636.24 "Игорь Лабутин" Собирают данные разными способами, на Линуксе это LTTNG, это EventPipe новые, на Виндуксе это, конечно же, W.
3636.24 3639.80 "Игорь Лабутин" Ну а анализируется это все, конечно же, в Perfume, и где же еще?
3639.80 3643.44 "Игорь Лабутин" Пока ничего другого, собственно, помимо Perfume не сделали.
3643.44 3659.08 "Игорь Лабутин" Perfume все еще Windows-only, я спрашивал тут у главного мейн-тренера, вообще, есть ли какие-то планы сделать к Perfume какой-то другой UI, потому что там были попытки на самом деле, и там сейчас есть бранч в репозитории, которые делают JavaScript-овый UI для Perfume.
3659.08 3662.48 "Игорь Лабутин" То есть, типа, в браузере можно посмотреть, будет все то же самое.
3662.48 3686.00 "Игорь Лабутин" Но они пока такие на ранней стадии, и ответ главного мейн-тренера был про то, что нет, Perfume сейчас активно используется, никаких браузеров мы пока переходить прям сходу не будем, и там, Windows-версия, она вот та самая, не очень, может быть, удобная, но хорошо знакомая тем, кто этим пользуется, она будет жить еще долго, и это сейчас пока основной тул всей Microsoft-команды внутри.
3686.00 3687.00 "Анатолий Кулаков" Так что...
3687.00 3697.24 "Анатолий Кулаков" Хорошее место, мне кажется, для JetBrains, чтобы он ворвался со своими дебаг-тулами сюда, перформанс-профайлерами, мемори-профайлерами, и сделал нам новый кроссплатформенный красивый удобный Perfume.
3697.24 3699.24 "Игорь Лабутин" Да, это было бы вообще прекрасно.
3699.24 3713.32 "Игорь Лабутин" Хотя, конечно, получается так, что Perfume, он действительно не для всех, в том плане, что основной его драйвер это все-таки внутренняя команда, то есть, это сама Maoni, команда от DotNet Runtime, которые хотят каких-то очень low-level фич.
3713.32 3724.68 "Игорь Лабутин" То есть, тот факт, что вообще говоря, Perfume оказывается юзабелен для каких-то high-level разборок, и для использования вообще вне команды Microsoft, это на самом деле такое.
3724.68 3731.84 "Игорь Лабутин" В течение обстоятельств, ну, весьма удачно, потому что это действительно достаточно легковесный тул, который позволяет быстро сделать то, что надо, если знать, как им пользоваться.
3731.84 3739.32 "Анатолий Кулаков" Ну, с другой стороны, если бы его не было, вот представим, то элементарные бы такие проблемы, решать было бы нечем.
3739.32 3741.44 "Анатолий Кулаков" То есть, нет никакого у нас инструмента, кроме Perfume.
3741.44 3753.16 "Игорь Лабутин" Да нет, ну, DotTrace, DotCover, DotCover, это coverage, ну, DotTrace, DotMemory, они же все, в принципе, работают, у них есть коллекторы для продакшена, в том числе, которые не надо ставить.
3753.16 3757.80 "Игорь Лабутин" То есть, как-нибудь справились бы, но, конечно, неудобно.
3757.80 3762.32 "Игорь Лабутин" WinDBG, в конце концов, есть, в нем можно узнать все, как известно, ну, просто не очень удобно.
3762.32 3784.48 "Игорь Лабутин" Ну, в общем, вот, статья постоянно дополняется, Maoni, в принципе, это и лежит в ее личном GitHub, она открыта для улучшения дополнений, то есть, если вы там находите опечатки, какие-то хотите дополнения, особенно если вы знаете что-то про то, как профайлить под Linux, то пишите это все туда, присылайте pull-request, она готова их всех опровидеть.
3784.48 3802.52 "Анатолий Кулаков" А если вы вдруг почему-то не знаете, кто такая Maoni, то напомню, что это главный разработчик сейчас GC, и, наверное, один из самых главных авторов, которая с ним практически с самых первых версий, и, может быть, это один-единственный человек, который до конца понимает, как это все работает.
3802.52 3804.24 "Игорь Лабутин" И куда это все будет изменяться.
3804.24 3808.04 "Игорь Лабутин" Ну, что, поехали дальше, у нас еще есть что обсудить.
3808.04 3818.12 "Анатолий Кулаков" Да, JetBrains заанонсила интересный инструмент, я хотел про него рассказать, но тут осознал, что для начала нужно раскрыть поподробнее тему, для чего это вообще нужно.
3818.12 3819.84 "Анатолий Кулаков" Инструмент работает с Reference Assemblies.
3819.84 3822.48 "Анатолий Кулаков" Вот, а что такое Reference Assemblies?
3822.48 3833.04 "Анатолий Кулаков" Это довольно-таки не распространенная штука, мало разработчиков сталкивались с ней, но довольно мощная и активно юзается внутри Microsoft.
3833.04 3834.96 "Анатолий Кулаков" Поэтому давай остановимся поподробнее.
3834.96 3838.36 "Анатолий Кулаков" Мы об этом еще ни разу не говорили, а знать об этом стоит.
3838.36 3848.48 "Анатолий Кулаков" Итак, Reference Assemblies - это специальный тип Assembly, который содержит в себя минимум мета-информации, который нужен только для того, чтобы задекларировать некий публичный API.
3848.48 3855.60 "Анатолий Кулаков" Они включают в себя все, что нужно, что существенно для публичного API, и при этом у них нет ничего, что касается имплементации.
3855.60 3858.88 "Анатолий Кулаков" Они абсолютно не знают, как этот API был имплементирован.
3858.88 3871.44 "Анатолий Кулаков" Например, у них есть информация о типах, о приватных типах, о вложенных типах, информация об атрибутах, об ивентах, виртуальных методах, явных наследований интерфейсов и так далее.
3871.44 3874.28 "Анатолий Кулаков" Но нет информации, как я уже сказал, об имплементации.
3874.28 3878.40 "Анатолий Кулаков" Это никак не влияет на API, и поэтому они в себя это не включают.
3878.40 3883.88 "Анатолий Кулаков" Это снаружи выглядит как полноценная Assembly, но внутри абсолютно не такая.
3883.88 3887.48 "Анатолий Кулаков" И если вы попытаетесь ее загрузить, то runtime выдаст вам ошибку.
3887.48 3890.20 "Анатолий Кулаков" Обычно это Bad Image Format Exception.
3890.20 3895.00 "Анатолий Кулаков" Такие сборки можно отличить с помощью специального атрибута, который называется Reference Assembly.
3895.00 3898.16 "Анатолий Кулаков" Он находится на уровне Assembly, естественно.
3898.16 3909.36 "Анатолий Кулаков" Но несмотря на то, что runtime ее загрузить не может, в вашем приложении вы вполне можете ее загрузить, указав специальный Reflection Only Mode, и проанализировать эти типы, заголовки и ивенты.
3909.36 3912.24 "Анатолий Кулаков" Также эту сборку можно подать на вход к компилятору.
3912.24 3918.16 "Анатолий Кулаков" Соответственно, компилятор найдет все заголовочные классы и вполне сможет скомпилировать ваш проект.
3918.16 3923.56 "Игорь Лабутин" Да, здесь нужно сказать тот же момент, который, может быть, не все знают и понимают.
3923.56 3929.76 "Игорь Лабутин" Компилятору на самом деле глубоко все равно, что у вас там написано в реализации ваших методов и всем остальном.
3929.76 3949.00 "Игорь Лабутин" То есть компилятор, когда он компилирует, и вы передаете ему на вход все эти Nuget пакеты, все ваши зависимые сборки, DLL, которые могут лежать у вас даже внутри проекта и ссылаться бинарно внутри, компилятору все равно, что там внутри ему только важен public surface API.
3949.00 3950.00 "Игорь Лабутин" И все.
3950.00 3954.72 "Игорь Лабутин" Поэтому как раз именно поэтому reference assembly работает в этом случае.
3954.72 3956.72 "Анатолий Кулаков" Что это нам в итоге дает?
3956.72 3966.84 "Анатолий Кулаков" Прежде всего, это намного меньший размер этих DLL, которые позволяют уменьшить сам SDK, который нужно скачивать, и уменьшить место на диске, которое ему необходимо.
3966.84 3973.76 "Анатолий Кулаков" И таким образом мы можем сделать reference assembly для нескольких версий этого SDK.
3973.76 3979.08 "Анатолий Кулаков" Даже если они друг к другу несовместимы, мы вполне можем это сделать и не занимать много места.
3979.08 3984.80 "Анатолий Кулаков" А во-вторых, это позволяет очень сильно повысить скорость билда.
3984.80 3999.96 "Анатолий Кулаков" Если у вас в проекте очень много сборок, которые очень часто меняются, то билд, который ссылается на настоящие сборки, на полноценные, он будет ребилдиться каждый раз, как только имплементация какой-то вашей сборки поменялась.
3999.96 4003.80 "Анатолий Кулаков" Но, как правильно сказал Игорь, это абсолютно не нужно.
4003.80 4007.44 "Анатолий Кулаков" Ребилдить нужно только тогда, когда поменялась лишь public API вашей сборки.
4007.44 4009.64 "Анатолий Кулаков" И кто-то от этого public API зависит.
4009.64 4012.68 "Анатолий Кулаков" Вот reference assembly позволяет вам именно это сделать.
4012.68 4017.48 "Анатолий Кулаков" Если не менялся public API, то они не будут даже перебилдивать весь ваш большой-большой проект.
4017.48 4022.96 "Анатолий Кулаков" Типичным примером того, где используется reference assembly, это .NET Standard.
4022.96 4027.08 "Анатолий Кулаков" Сборка netstandard.dll - это контрактная сборка.
4027.08 4030.28 "Анатолий Кулаков" Она не содержит внутри себя никакой имплементации.
4030.28 4033.36 "Анатолий Кулаков" Она лишь содержит общий API для нескольких платформ.
4033.36 4036.88 "Анатолий Кулаков" И имплементация этого API на каждой платформе разная.
4036.88 4044.00 "Анатолий Кулаков" Например, для большого .NET Framework это mscore-lib.dll, а для .NET Core это systemprivate-core-lib.dll.
4044.00 4053.28 "Анатолий Кулаков" Таким образом, вы можете скомпилировать ваше приложение напротив .NET Standard и уже запускать под разными рантаймами, где имплементация уже будет своя.
4053.28 4059.28 "Анатолий Кулаков" Интересный момент, что reference assembly распространяется точно так же, как и обычные сборки через NuGet пакеты.
4059.28 4064.40 "Анатолий Кулаков" Например, вы можете найти в NuGet пакет Microsoft.NET Core App.Ref.
4064.40 4066.20 "Анатолий Кулаков" Как же нам получить reference assembly?
4066.20 4069.36 "Анатолий Кулаков" Прежде всего, их нужно сбилдить из исходного кода.
4069.36 4084.32 "Анатолий Кулаков" Это можно сделать с помощью специального таска в msbuild, или указав специальный флаг компилятору, или у Рослина есть специальные флажки, прожонглировав которыми вы вполне можете тоже сгенерить себе программно reference assembly.
4084.32 4092.96 "Анатолий Кулаков" В отличие от обычных assembly, которые находятся в папочке lib в NuGet пакета, reference assembly обычно находится в папочке ref.
4092.96 4099.60 "Анатолий Кулаков" Вот вкратце то, зачем нужны, как существуют и для чего используются reference assembly.
4099.60 4101.76 "Анатолий Кулаков" А теперь непосредственно к самой новости.
4101.76 4106.20 "Анатолий Кулаков" JetBrains выпустил тулс, который называется Refasmer.
4106.20 4111.72 "Анатолий Кулаков" Это инструмент, который позволяет вам из обычной сборки сгенерить reference assembly.
4111.72 4116.52 "Анатолий Кулаков" Его разрабатывали сотрудники JetDrain, Сергей Забадалов и Михаил Филиппов.
4116.52 4124.44 "Анатолий Кулаков" Это утилита командной строки, которая принимает на вход обычную полноценную assembly и выдает на выходе reference.
4124.44 4130.52 "Анатолий Кулаков" Вот, и интересно, что такой узкий довольно-таки казалось на первый взгляд use case заинтересовал JetBrains.
4130.52 4135.80 "Анатолий Кулаков" Поэтому нам захотелось узнать, каким же образом внутри компании это всё используется.
4135.80 4143.44 "Анатолий Кулаков" Поэтому мы пригласили к себе в гости Михаила Филиппова, разработчика из команды Rider и автора того самого Refasmer.
4143.44 4145.80 "Михаил Филиппов" Ну, не совсем автором, я осо-автором.
4145.80 4148.00 "Михаил Филиппов" Основной автор всё-таки мой коллега Сергей.
4148.00 4151.96 "Михаил Филиппов" Вот, и да, это наш новый tool.
4151.96 4156.00 "Анатолий Кулаков" Ты приложил, по крайней мере, руку и можешь отвечать за этот инструмент.
4156.00 4164.76 "Михаил Филиппов" Да, я, собственно, идеологом его выступал и, собственно, курировал разработку, готовил релиз и всякое такое.
4164.76 4165.76 "Анатолий Кулаков" Да.
4165.76 4171.00 "Анатолий Кулаков" Значит, ты точно знаешь, зачем вам эта штука понадобилась и вообще как вы её используете внутри JetBrains?
4171.00 4172.00 "Анатолий Кулаков" Для чего?
4172.00 4173.00 "Михаил Филиппов" Да, сейчас расскажу.
4173.00 4193.24 "Михаил Филиппов" Значит, первая проблема, с которой мы столкнулись, у нас, собственно, есть продукт Rider, также есть ReSharper и некоторые кусочки нашего продукта, а именно тест-трейнеры, которые запускают Unit-тесты и совместимость с Unity, должна собираться под NetFramework 3.5.
4193.24 4205.24 "Михаил Филиппов" Проблема в том, что мы хотим собирать наш плагин Unity NetCore, и NetCore, для того чтобы собирать 3.5 Framework, ему нужны 4 Reference Assembly.
4205.24 4216.96 "Михаил Филиппов" Reference Assembly, Microsoft не так давно выложила Reference Assembly для полного Framework, но, к сожалению, там отсутствует Reference Assembly для 3.5 Framework, непонятно почему, для 2.0 есть, а для 3.5 нет.
4216.96 4227.44 "Михаил Филиппов" И это проблема, потому что наши, собственно, плагины Unity разрабатывают ребята на Mac, а там у них нет возможности использовать Reference Assembly из винды.
4227.44 4245.32 "Михаил Филиппов" И, собственно, также билды у нас ходят на адентах, у них нет установленных .NET SDK, но для того, чтобы не нужно было зависеть от них, мы, собственно, хотели сделать такие, собственно, взять тот принцип, который Microsoft использовала, сделать Reference Assembly для 3.5 Framework.
4245.32 4250.20 "Михаил Филиппов" Ну, это одно из первых вещей, для чего нам понадобился, собственно, Refasper.
4250.20 4254.36 "Михаил Филиппов" Дальше я еще расскажу, какие у нас способы его применения есть.
4254.36 4264.96 "Михаил Филиппов" Но, в целом, да, мы сделали, собственно, пакет JetBrains и этот Framework Reference Assembly для 3.5, это, собственно, Refasper, построенный с помощью нашей тулы Refasper.
4264.96 4269.04 "Михаил Филиппов" А дальше, собственно, у нас возникла какая-то интересная идея.
4269.04 4285.92 "Михаил Филиппов" Есть, ну, вы все знаете, что .NETные проекты делаются MS Build-ом, и когда у вас есть проект B, который зависит от проекта A, нужно, ну, и вы там меняете что-то внутри приватного API проекта A, вам, соответственно, нужно пересобирать все.
4285.92 4294.52 "Михаил Филиппов" Мы придумали, что можно между проектами начать передавать, собственно, результат сборки в виде рефасма.
4294.52 4310.40 "Михаил Филиппов" Тогда инпуты проекта B будут уже не от рефасменной сборки, соответственно, если там еще специальным образом подшаманить CSC Task'у, то можно сделать так, что не будет запускаться сборка следующего проекта.
4310.40 4329.80 "Михаил Филиппов" Так примерно похожее делает ReSharper Build, так есть, собственно, в ReSharper такая фича, ReSharper Build, которая анализирует, что changes в сборках были только в приватных частях, не было changes в публичных API, тогда не пересобирает проекты, ну, собственно, MS Build пересобрал проекты, а ReSharper позволяет игнорировать сборку некоторых проектов.
4329.80 4333.32 "Михаил Филиппов" Ну, собственно, вот рефасмер мы для этого еще используем.
4333.32 4351.60 "Михаил Филиппов" Еще нам нужно иногда, бывает, какие-то, заюзать API-шки какого-то продукта для того, чтобы собрать для него, ну, там, не знаю, для Unity, например, да, у Unity есть их сборки, а нам нужно, чтобы собирать свой плагин, иметь возможность скомпилироваться об референсы из этих сборок.
4351.60 4386.60 "Михаил Филиппов" Мы не можем на Build-системах держать установленный Unity, поэтому можем, собственно, сделать рефасмы из таких сборок, из любых, собственно, сборок, и компилироваться об них, а в реальном продукте уже будут, собственно, имплементации от системы, в которую ставится там наш плагин, и это вообще довольно прикольная тема, если вы разрабатываете какую-то систему, вы можете предоставлять разработчикам плагинов не все ваши DLL, а просто обрезанные легкие версии, рефасмы, собственно, которые вы строите прямо на ритуал ваши готовые DLL.
4386.60 4389.44 "Михаил Филиппов" Вот, собственно, примерно так он у нас сейчас используется.
4389.44 4392.28 "Анатолий Кулаков" То есть много интересных юзкисов появляется.
4392.28 4404.40 "Михаил Филиппов" Да, у меня будет доклад на следующем dotnext, собственно, приходите, я расскажу, собственно, про этот, в том числе, как мы в билде оптимизируем скорость билда с помощью этой штуки.
4404.40 4409.00 "Анатолий Кулаков" Отлично, слушай, а скажи, у Микрософта разве нет инструментов, которые помогают делать то же самое?
4409.00 4412.04 "Анатолий Кулаков" Ну, Микрософт как-то все собирал все свои эти ассембли?
4412.04 4419.92 "Михаил Филиппов" Да, у них есть компилятор, компилятор умеет имитировать референс ассембли сам, но он умеет либо так, либо так.
4419.92 4426.44 "Михаил Филиппов" То есть нельзя по готовым сборкам, ну, насколько мы не нашли инструментов, которые позволяют по готовым сборкам построить референс ассембли.
4426.44 4428.60 "Анатолий Кулаков" То есть только из исходников, да?
4428.60 4438.48 "Михаил Филиппов" Ну, если у тебя есть исходники, да, ты можешь скомпилировать и получить реф, ну, реф ассмы, но когда у тебя нет исходников, то у тебя нет такой возможности.
4438.48 4441.48 "Анатолий Кулаков" Спасибо большое, Михаил.
4441.48 4448.54 "Анатолий Кулаков" Исходный код Wasmira доступен на GitHub, и каждый из вас может его проанализировать, скачать или может даже посоветовать какие-то pull-requests.
4448.54 4468.16 "Игорь Лабутин" Слушай, ну, на самом деле штука прикольная, мне кажется, действительно, если у вас есть гора микросервисов или там, ну, get-пакетов или еще чего-то, которые друг от друга зависят, в том числе бинарно, то, генерив такие референс-сборки, вы действительно сможете сократить время компиляции или как-то ускорить, упростить такие вещи.
4468.16 4477.56 "Игорь Лабутин" То есть, ну, узнать про это надо, и знать, как работает компилятор в этом смысле полезно, и действительно, может быть, пригодится это дело вам в ваших проектах.
4477.56 4485.92 "Анатолий Кулаков" И хорошо, что у JetBrains есть еще хороший такой опыт, который довольно практичный, прагматичный и может подсказать вам, куда это и как всунуть.
4485.92 4490.28 "Игорь Лабутин" Все, на этом, наверное, более или менее все.
4490.28 4494.32 "Игорь Лабутин" Надо заканчивать, мы уже больше часа рассказываем про новости.
4494.32 4496.76 "Игорь Лабутин" Напомним, чего у нас сегодня было?
4496.76 4498.48 "Игорь Лабутин" Или у нас есть еще что обсудить?
4498.48 4500.44 "Игорь Лабутин" Нет, на сегодня давай уже закругляться.
4500.44 4509.88 "Игорь Лабутин" Ну, давай тогда вспомним, что мы обсудили Microsoft Ignite, где никаких особых новостей для нас нет, но смотрим с нетерпением и ждем будущего.
4509.88 4519.28 "Игорь Лабутин" Обсудили, что появилось в DotNet 5 RC1, где в самом DotNet 5 не появилось почти ничего нового, зато SPNet Core и Antity Framework Core порадовали кучей новых фич.
4519.28 4529.40 "Игорь Лабутин" Поговорили про половинчатый тип, которым нельзя складывать, вычитать, разделить, но зато в нем можно эффективно хранить вещественные числа не очень высокой точности.
4529.40 4534.40 "Игорь Лабутин" Подумали, как жить теперь без нетстандарта, когда DotNet 5 теперь стандартно все.
4534.40 4546.32 "Игорь Лабутин" В разделе про тулзы довольно подробно обсудили, как создавать свои собственные DotNet тулзы, то, что называется Global Tools, и они могут быть и Local Tools тоже.
4546.32 4554.24 "Игорь Лабутин" Также, если говорить про тулзы, поговорили про ReSharper и Rider, что нам обещано в ближайшем будущем, и будем следить, что будет выполнено.
4554.24 4563.08 "Игорь Лабутин" Visual Studio тоже не дремлет и закрывает проект один за другим, соответственно, закрыли Codespaces, ждем теперь, что будет с GitHub Codespaces.
4563.08 4584.12 "Игорь Лабутин" И для любителей хардкора, high-performance и так далее, посмотрели на high-performance package, обсудили, как правильно анализировать память от автора самого ГЦМ и посмотрели на, что же такое Reference Assemblies, как с ними улучшить ваши билды и как вообще такие Reference Assemblies генерировать новыми тулзами от JetBrains.
4584.12 4598.20 "Анатолий Кулаков" И на последнем нашем розыгрыше мы убедились, что замечательными лицензиями JetBrains владеют еще не все наши слушатели, поэтому мы и решили разыграть еще 5 лицензий на любой продукт от компании JetBrains.
4598.20 4604.24 "Анатолий Кулаков" Условия простые, элементарные и, как всегда, не потребуют от вас совершенно больших усилий.
4604.24 4639.12 "Анатолий Кулаков" Итак, одну лицензию получит комментатор на YouTube к этому выпуску в нашем официальном плейлисте, одну лицензию получит тот, кто залайкает этот анонс в группе VK, в группе .NET.RU, одну лицензию получит тот, кто расшарит этот анонс из группы .NET.RU, одну лицензию получит тот, кто поделится этим анонсом из официального твиттера .NET.RU и пятую лицензию получит тот, кому понравится этот анонс в твиттере .NET.RU.
4639.12 4640.96 "Анатолий Кулаков" Вот, в принципе, и все.
4640.96 4647.56 "Анатолий Кулаков" Ищите нас в социальных сетях, ищите наш анонс, рассказывайте анонс своим друзьям, а главное слушайте
4647.56 4650.76 "Игорь Лабутин" нас. Да, на этом мы на сегодня завершаемся.
4650.76 4652.76 "Игорь Лабутин" Всем пока, с вами был Игорь Лабутин.
4652.76 4653.92 "Анатолий Кулаков" И Анатолий Кулаков.
4653.92 4654.92 "Анатолий Кулаков" До скорого.
4654.92 4655.20 "Михаил Филиппов" Пока.

