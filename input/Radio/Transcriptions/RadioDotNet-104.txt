0.00 12.64 SPEAKER_01 Приветствую, дорогие слушатели, в эфире Радио.нет и его постоянный ведущий Анатолий Кулаков.
12.64 13.64 SPEAKER_01 И Игорь Лабутин.
13.64 14.64 SPEAKER_01 Всем привет.
14.64 24.04 SPEAKER_01 Выпуск у нас сегодня практически замечательный, новогодний, и мы рады, что к этому празднику с нами присоединились наши замечательные помогаторы.
24.04 39.32 SPEAKER_01 Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Лазарев Илья, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей, Дмитрий Сорокин, Александр Ерыгин.
39.32 40.52 SPEAKER_01 Всем спасибо, кто нас поддерживает.
40.52 48.40 SPEAKER_01 Если вы захотите присоединиться к этому бравому списку, заходите на Boosty и посмотрите, как легко можно попасть в эту бодрую компанию.
48.40 71.00 SPEAKER_01 Ну что ж, я не зря назвал наш выпуск новогодний, потому что как раз таки во многих культурах принято новый год отмечать не тогда, когда что-то такое странное случилось, а именно, когда у нас заканчивается какой-то старый год или длинный день или какая-то короткая ночь, и начинается какой-то новый год.
71.00 84.86 SPEAKER_01 И я думаю, что в среде C# разработчиков смело новый год можно отнести, начало нового года можно отнести к дотнет-конфу, на котором мы как раз таки прощаемся со старым фреймворком и встречаем весело новый фреймворк.
84.86 87.00 SPEAKER_01 Как ты считаешь, достойный новый год для программиста?
87.00 88.00 SPEAKER_01 Да, именно так.
88.00 94.08 SPEAKER_01 И начиная с этого выпуска мы будем ныть, что нет превью следующего дотнет-десятого, ну когда же, когда же превью один?
94.08 95.08 SPEAKER_01 Начнем?
95.08 98.08 SPEAKER_01 А все превью, которые будут, мало фич там будет и все такое.
98.08 99.08 SPEAKER_01 Да, да, да.
99.08 100.08 SPEAKER_01 А МО вдруг знает, кто в первом превью.
100.08 124.74 SPEAKER_01 Ну я так подозреваю, что раньше февраля не ждать, насколько я помню по старой памяти, так что у нас теперь предстоит несколько месяцев аккуратного разбора всяких статей вокруг выхода действительно нового девятого дотнета, который прошел, не который прошел, который вышел, а прошла dotnet.conf, на которой и было объявлено, что все, dotnet 9 окончательно зрелижен, как собственно это и планировалось, как это было уже несколько лет подряд.
124.74 139.76 SPEAKER_01 Конференция прошла, конференция это три дня докладов, там получился в итоге ютубный плейлист, ссылочка у нас будет в шоуноутах, на примерно девяносто слишком докладов разной степени длительности и техничности.
139.76 162.00 SPEAKER_01 Надо сказать, что в этом году не так много докладов, которые про искусственный интеллект, ажур и прочие такие штуки, ну либо они искусно завуалированы по названию, непонятно, потому что чисто в названиях, мне кажется я AI в кастомленном виде на счетах типа в десяти или пятнадцати докладах, всего из девяносто с лишним, что не так много.
162.00 172.08 SPEAKER_01 А при этом… В принципе да, радует очень сильно, потому что предыдущие dotnet.conf просто кишили всякими айами, ажурами и технические доклады туда выскребсти было практически невозможно.
172.08 219.08 SPEAKER_01 Ну надо понимать, что когда я говорю технический доклад, здесь это тоже будет, скорее всего, больше такой демодоклад интро уровня на тему того, как работает та или иная кусочек зрелиженной технологии, но в том числе интересные и наверняка глубокие доклады типа JIT Optimizations от кунала или кунала, не помню, как его правильное ударение ставить, и Стивен Тауб там с перформанс импрувментами, конечно же, был, так что наверняка там можно найти хорошие думчивые технические, ну относительно глубокие доклады, насколько они могут быть глубокими в момент релиза на широкую аудиторию, потому что понятно, что основная аудитория и цель этой конференции это больше как бы показать, заинтересовать, что же там сделали в девятом дотнете.
219.08 242.88 SPEAKER_01 Ссылочки все будут, собственно, единственное, что можно еще сказать такого про девятый дотнет, что это short term support релиз, то есть это такой проходной релиз, который будет поддерживаться всего лишь 18 месяцев, то есть до десятого дотнета плюс еще полгодика, поэтому если вы на него переходите, будьте готовы переходить на десяточку через год, чтобы уже выйти на нормальном LTS релизе.
242.88 271.20 SPEAKER_01 Ну и, наверное, пойдем уже в детали, деталей много, у нас сегодня конференция большая, как бы мы не страдали целый год со словами что-то ничего нового, ничего нового, а на самом деле, когда собрали все это в единый выпуск на тему того, что же зарелизили в девятом дотнете по сравнению с восьмым, оказалось не так и мало, так что у нас времени мало, фич много, поэтому давай, не сильно откладывая долгий ящик, начнем с самого главного, конечно же, с C#.
271.20 286.20 SPEAKER_01 Да, ну нельзя сказать, что C# в этом релизе как-то яростно себя проявил, то есть каких-то много фич насобирал, нет, абсолютно большинство фич какие-то мелкие, проходные или довольно специфические, ну, в общем, сейчас мы на примере с вами разберемся.
286.20 296.40 SPEAKER_01 Итак, для C# 13, 13 версии C# у нас, вам будет необходима последняя Visual Studio и дотнет из DK9, если вы захотите на нем вдруг попрограммировать.
296.40 302.44 SPEAKER_01 Давайте посмотрим, что у нас есть, в принципе, порядок не важен, будем идти по порядку от Майкрософта.
302.44 317.04 SPEAKER_01 Прежде всего, из меня коснулись парамс коллекшна, наверняка многие из вас сталкивались с ключевым словом парамс, который позволяет в методах задавать произвольное количество аргументов, и все эти аргументы пакуются в прекрасный массивчик, который потом передается уже имплементации.
317.04 326.76 SPEAKER_01 Так вот, многих уже давно напрягало, что это именно массивчик, потому что он требует выделения памяти, ну, и прочие какие-нибудь проблемы с ним тоже случались.
326.76 340.08 SPEAKER_01 И вот, наконец, в этой версии нам завезли такую приятную особенность, что парамс сможет теперь включать в себя не только массив, но и абсолютно любой коллекционный тип, который только возможно, в частности, который реализует IEnumerable и у которого есть метод add.
340.08 344.40 SPEAKER_01 Вот если это у вас поддерживается, то вы можете засунуть этот тип в парам, даже свой собственный.
344.40 348.72 SPEAKER_01 Ну и, в частности, Span и Redundant Span, естественно, тоже поддержаны.
348.72 353.44 SPEAKER_01 Наверное, это будет самый часто используемый теперь параметр для передачи в парамах.
353.44 367.68 SPEAKER_01 Наверное, одна из самых замечательных фич, которая появилась, которая даст пинок очень интересным изменениям в будущем, это новый Lock Object, поэтому давайте же посмотрим поподробнее, что это такое.
367.68 371.16 SPEAKER_01 Прежде всего, как мы раньше брали Локи?
371.16 378.04 SPEAKER_01 Мы создавали, да, у нас была хорошая практика и плохая практика, то есть хорошая практика, как Microsoft советовала нам делать.
378.04 389.28 SPEAKER_01 Вы должны были завести Redundant приватное поле и в этом приватном поле создать просто New Object и уже на этот New Object брать Лок, на этот ресурс, при необходимости.
389.28 406.12 SPEAKER_01 Но очень часто бывает, если есть хорошая практика, то и была очень часто плохая практика, это когда Лок брался непосредственно на какой-то объект, то есть не на специально выделенный объект, а прямо на коллекцию, которую вы использовали или на какую-то сущность, которую вы используете, прямо на нее Лок брался.
406.12 412.08 SPEAKER_01 В том числе таким даже Microsoft сам грешил, то есть если сильно порыскать, можно в его коде встретить такой паттерн.
412.08 413.08 SPEAKER_01 Это вообще плохо.
413.08 425.32 SPEAKER_01 Ну и если уж на то разобраться, то дизайн API, который позволяет делать плохо, это плохой дизайн API, то есть то, что мы можем вообще на любой объект сделать Лок, это плохо.
425.32 428.88 SPEAKER_01 Это плохо еще по нескольким причинам.
428.88 435.00 SPEAKER_01 Ну, во-первых, это полностью несемантично, то есть что такое поставить Лок на какую-нибудь коллекцию.
435.00 441.92 SPEAKER_01 То есть, по сути, эта коллекция никак не лочится, мы должны просто подозревать, в уме держать, что же значит такое Лок на коллекцию.
441.92 451.36 SPEAKER_01 То есть никакой семантики здесь не прослеживается и никаким образом это не подсказывает, каким образом мы начинаем работать с параллельным кодом.
451.36 457.80 SPEAKER_01 И еще немаловажный минус такого подхода заключается в том, что мы никак не можем управлять имплементацией этого Лока.
457.80 467.16 SPEAKER_01 Допустим, мы хотим не стандартный монитор, который используется в современной конструкции Лок, а допустим мы хотим там ReadWriteLock поставить или еще какой-нибудь свой Лок собственно написать.
467.16 468.16 SPEAKER_01 Мы этого сделать не можем.
468.16 476.56 SPEAKER_01 Ну, то есть для этого нам придется сгородить какой-то сбоку костыль, который никак к Лок, именно к стейтменту никакого отношения иметь не будет.
476.56 478.48 SPEAKER_01 Это тоже не очень хорошо.
478.48 489.72 SPEAKER_01 И вот примерно, якобы, чтобы решить эти проблемы, и был введен новый класс, который у нас располагается в пространстве SystemTrading и называется этот класс Лок.
489.72 496.12 SPEAKER_01 Этот новый тип как раз таки создан для того, чтобы навести порядок в синхронизации между потоками.
496.12 497.96 SPEAKER_01 Что же у него есть?
497.96 501.72 SPEAKER_01 У него есть метод, который называется EnterScope.
501.72 511.60 SPEAKER_01 Этот метод возвращает некий скоуп, который реализует стандартный шаблон Disposable, то есть этот скоуп потом можно раздиспозить.
511.60 519.22 SPEAKER_01 Всем вам известный вообще способ, то есть вы какой-то скоуп открываете, ставите ему юзинг и в конце этот юзинг радостно диспозится.
519.22 522.20 SPEAKER_01 После дископа, естественно, скоуп уничтожается.
522.20 525.92 SPEAKER_01 То есть вся та же семантика, которую вы ожидаете увидеть от Лока.
525.92 532.72 SPEAKER_01 И изменили, естественно, ключевое слово Лок, теперь Лок стейтмент распознает, что ему передали.
532.72 541.72 SPEAKER_01 Ему передали вот этот класс SystemTrading.Loc, тогда он использует обновленный API и вызывает у него соответствующие методы.
541.72 552.88 SPEAKER_01 А если же ему передали что-либо угодно другое, то используется традиционный API, который через SystemTrading.Monitor блокирует доступ к этому ресурсу.
552.88 564.56 SPEAKER_01 Поэтому вот такой новенький интересный классик появился, в стандартную конструкцию он вошел, и Microsoft выдала рекомендации, что во всем вашем новом коде, где только возможно, переходите на этот новый тип Лок.
564.56 566.16 SPEAKER_01 То есть не надо объекты локать.
566.16 572.76 SPEAKER_01 Это странная выдумка, очень странно, что она так долго держалась в языке и вообще безумно странно, почему она поэтому появилась.
572.76 575.76 SPEAKER_01 Ну, от плохого влияния, понятно.
575.76 580.08 SPEAKER_01 А вот старый код, в принципе, тоже невозбранно переписывать.
580.08 591.48 SPEAKER_01 То есть там, где вы лочили почему-то на те филды, которые уже у вас были в вашем классе, или на конкретный выделенный филд, не суть важного, переделывайте его на новый класс Лок.
591.48 594.76 SPEAKER_01 Потому что, в принципе, все использование не поменялось.
594.76 600.96 SPEAKER_01 Если вы переделаете на новый класс, то все, что работало раньше, теоретически у вас продолжат работать сейчас.
600.96 603.56 SPEAKER_01 Никаких опасений здесь, по идее, нет.
603.56 604.56 SPEAKER_01 Такое хорошее нововведение.
604.56 605.56 SPEAKER_01 Пользуйтесь.
605.56 609.68 SPEAKER_01 Дальше что-то такое, поменьше, поменьше, помельче.
609.68 623.92 SPEAKER_01 Мы теперь можем использовать специальный оператор, крышечка, который называется FromEnd Indexer, то есть это индексер, который помогает нам индексироваться с конца коллекции.
623.92 628.24 SPEAKER_01 Вы можете написать крышечка 1, это значит, там будет минус первый элемент от конца.
628.24 632.76 SPEAKER_01 В общем, теперь этот элемент мы можем использовать в Object Initializer.
632.76 639.20 SPEAKER_01 То есть, когда вы массиво инициализируете, раньше вы могли только инициализировать его с начала до конца.
639.20 643.60 SPEAKER_01 А теперь, благодаря такой крышечке, вы теперь можете инициализировать его с конца к началу.
643.60 645.68 SPEAKER_01 Ну, наверное, кому-то не хватало.
645.68 656.24 SPEAKER_01 У нас появилось больше partial members, то есть раньше мы все знаем, что мы могли использовать partial методы, а теперь к ним еще добавились partial property и partial indexers.
656.24 661.52 SPEAKER_01 В принципе, работают они по тем же самым правилам, как и были partial методы, и ничего не изменилось.
661.52 672.24 SPEAKER_01 То есть у вас есть какая-то декларация сигнатуры, у вас есть какая-то декларация реализации, и сигнатура должна совпадать с декларацией реализации, и вы можете объявить их в разных файлах.
672.24 676.32 SPEAKER_01 Ну, безусловно, это мега полезная штука для source генераторов.
676.32 682.04 SPEAKER_01 Она для них была сделана, для них была запрошена, и в будущем будет много где использоваться.
682.04 711.04 SPEAKER_01 Resolution Priority Attribute, который мы как раз недавно общались в прошлых выпусках, тоже следует упомянуть, что это специальный атрибут, который в основном нацелен на авторов различных библиотек, и если вдруг вы в свою библиотеку добавили какой-то новый метод, который по сигнатуре практически полностью совпадает с теми, которые существуют, ну он там более производительный, более интересный, а компилятор никак не хочет его выбирать, потому что по сигнатурам какой-то метод ему нравится больше.
711.04 718.44 SPEAKER_01 В общем, с помощью вот этого атрибута вы можете сказать компилятору "товарищ, вот это самая приоритетная сигнатура, выбирай ее, если можешь".
718.44 723.40 SPEAKER_01 В общем, вот этот атрибут позволяет такие указания компилятору раздавать направо и налево.
723.40 726.32 SPEAKER_01 Подробнее в предыдущем выпуске послушайте.
726.32 739.96 SPEAKER_01 И многострадальный Field Keyword, то есть его много раз добавляли, удаляли, пытались под него подогнать новые предупреждения компилятора, которые должны были рушить сборку и так далее.
739.96 746.00 SPEAKER_01 Ну, в общем, предупреждение компилятора не вошло в релиз, а вот сам Field Keyword вошел.
746.00 771.96 SPEAKER_01 Это способ, который позволяет вам манипулировать телом свойств без объявления явного BackingField, то есть вам не нужно для того, чтобы мелкие вещи типа проверок или какого-то условного возвращения, вам не нужно для этого BackingField создавать в автопропертирах, а вы можете использовать уже ключевое слово Field, которое появилось как раз в 13 C#.
771.96 776.84 SPEAKER_01 Здесь нужно быть осторожными, потому что очень маловероятны, но возможны Breaking Changes.
776.84 783.32 SPEAKER_01 И возможно такая штука, если вдруг у вас в классе поле называется словом Field.
783.32 796.92 SPEAKER_01 Если у вас такое есть, срочно переминуйте и если вдруг у вас попадется такая ситуация, когда вы будете переходить на новый C#, то очень легко можно объяснить компилятору, что именно вы хотите.
796.92 813.60 SPEAKER_01 Например, вы можете ваше локальное поле пометить или собакофилдом, или обратиться к нему через this.field, и если вы так обратитесь, то компилятор сразу поймет, что вы именно имеете это локальное поле, а не ключевое слово, которое было введено.
813.60 830.96 SPEAKER_01 Это, наверное, самые понятные конструкции, которые были в этом анонсе, но есть еще несколько малопонятных, которые для меня это всякие AllowRefStructs, Unsave, и прочие вот эти непонятные штуки.
830.96 841.12 SPEAKER_01 И чтобы разобраться поподробнее в этих неведомых словах, я пригласил большого специалиста в этой области, поэтому у нас сегодня в студии у нас в гостях Юрий Малевич.
841.12 842.12 SPEAKER_01 Юра, привет.
842.12 843.12 SPEAKER_01 Привет.
843.12 844.64 SPEAKER_01 Добрый день, друзья.
844.64 856.84 SPEAKER_01 Ну что ж, давай для начала, перед тем, как ты поможешь нам разобраться с нововведениями, напомни, пожалуйста, что вообще такое эти RefStructs, зачем они нужны, немножко вот в эту область заведи нас.
856.84 859.20 SPEAKER_00 Да, всем привет еще раз.
859.20 871.08 SPEAKER_00 Я думаю, что RefStructs не каждый из вас писал, возможно, большинство из вас никогда не писало, и возможно, многие вообще позабыли, для чего они нужны, поэтому вкратце напомню.
871.08 895.36 SPEAKER_00 Итак, проблематика была такая, нужна была некоторая ссылка на кусок памяти внутри объекта, и RefStructs, собственно, не решают эту проблему, RefStructs нужны именно для того, чтобы ссылка могла ссылаться на память внутри другого .NET объекта, который может быть собран из сборщика мусора.
895.36 906.22 SPEAKER_00 И поэтому RefStructs, они могут существовать, эти ссылки только внутри, в том же самом контексте, в котором существует сам объект.
906.22 943.02 SPEAKER_00 Если сборщик мусора собирает объект, то ссылка на память внутри объекта становится недействительной, поэтому разработчики придумали такой механизм, который исключает, собственно, то, чтобы ссылка существовала вне контекста, поэтому они запретили хранить ссылки в управляемой куче, запретили присваивание RefStructs любым структурам и полям объектов, которые могут храниться в управляемой куче, ссылки могут храниться только в стеке.
943.02 953.26 SPEAKER_01 Расскажи, как мы без этого раньше жили, на каких практических примерах нам нужно хранить ссылку на середину объекта, что это за случаи такие?
953.26 1039.50 SPEAKER_00 Чаще всего используется хранение, мы сейчас используем обычно спэны, и спэны позволяют вырезать нам отрезки, спэн - это перевод слова "отрезок", и если нам нужно для работы с текстом вырезать кусок текста, то раньше нам приходилось полностью копировать все байтики, всю подстроку, используя обычно метод substring, мы копировали, выделяли кусок памяти, в него копировался подстрока и продолжалась с ней работа, но разработчики посчитали, что в большинстве случаев это как бы избыточно, и для работы с текстом нам нужно только чтение, и нам не нужно копировать текст для того, чтобы прочитать какую-то подстроку, и вот придумали такое решение, в котором мы читаем подстроку не из копированного текста, а из текста целиком, но для этого нужно было создать отдельную ссылку, которая ссылалась на текстовую подстроку, не изменяя целевой объект.
1039.50 1052.34 SPEAKER_01 - Ну да, тогда в принципе начинает проясняться, зачем ссылаться в центр объекта, чтобы хранить подстроку и можно было с ней проводить какие-то операции, и вот эта ссылка у нас представлена Time Spanner.
1052.34 1082.10 SPEAKER_00 - Еще кроме работы с подстроками есть такая вещь, как работа с сырыми данными, то есть байтовые данные нам пришли например в канал буфер, и раньше, чтобы преобразовать например поток байтов, поток интеджеров, нам приходилось считывать байтики, и операциями побитного с битами, с двигателем через функцию Convert, приходилось копировать, собирать интеджеры.
1082.10 1120.26 SPEAKER_00 А с помощью новых конструкций, таких как интерпретация Syllic Interpret Query, появилась возможность ссылаться на область памяти внутри байтового массива, интерпретировать ее например как интеджеры или как структуры, и работать на высоком уровне уже с байтовым массивом, как если бы это были ссылки на полноценные структуры или, скажем так, данные более высокого размера, не байты, а интеджеры, лонги, даблы и так далее.
1120.26 1128.34 SPEAKER_01 - Я тебя правильно понял, что ссылка хранит не только указатель на какую-то область памяти, но еще и тип, к которому можно эту область памяти привести?
1128.34 1133.22 SPEAKER_00 - Ссылка не хранит, а типе знает компилятор.
1133.22 1144.54 SPEAKER_00 Когда мы преобразовываем ссылку, компилятор в момент компиляции знает, на какой тип мы ссылаемся.
1144.54 1161.14 SPEAKER_00 То есть, это осуществляется декларативно, в коде мы описываем, что мы, например, хотим байтовую ссылку трактовать как ссылку, например, интеджер, и компилятор на этом уровне компиляции считает, что это интеджер.
1161.14 1167.14 SPEAKER_00 И хранит он ссылку на начальную область памяти и, собственно, размер.
1167.14 1174.30 SPEAKER_00 Например, от текущего указателя до +8 байт это у нас будет лонг.
1174.30 1175.30 SPEAKER_00 - Отлично.
1175.30 1185.70 SPEAKER_00 - Хотя там основной объект, на который ссылалась оригинальная ссылка, это ссылка на байтовый массив, и под ссылкой на байтовый массив хранятся байты.
1185.70 1186.70 SPEAKER_01 - Ну, прекрасно.
1186.70 1190.90 SPEAKER_01 Теперь вроде разобрались, зачем это нужно, как это применяется и где это юзается.
1190.90 1196.90 SPEAKER_01 А теперь расскажи, что же у нас наконец появилось в новом C# 13 в этой области и зачем это тоже нужно.
1196.90 1197.90 SPEAKER_00 - Да.
1197.90 1222.70 SPEAKER_00 Начну с того, что, вернее, это будет продолжением собственно той тематики RefStruct, так как у нас нельзя было сохранять памяти в управляемой куче данные RefStruct, структуры ссылки, я бы так их назвал, то разработчики изначально запретили наследоваться RefStruct от интерфейсов.
1222.70 1236.62 SPEAKER_00 Проблема была в том, что если мы создаем локальную переменную с типом интерфейс и присваиваем значение структуры интерфейсу, то компилятор автоматически оборачивает структуру в управляемый объект, что называется боксинг.
1236.62 1248.98 SPEAKER_00 И, собственно, при оборачивании могла произойти ситуация, что у нас где-то в управляемой куче существует ссылка, и она может жить дольше, чем ссылка на оригинальный объект.
1248.98 1266.06 SPEAKER_00 Таким образом, если при сборке мусора оригинальный объект сборщика мусора удаляется, а так как ссылка ссылается внутрь объекта, то сборщик мусора не знает, что, например, ссылка на объект в центр памяти ссылается на сам объект, он ссылку оставляет живой.
1266.06 1272.14 SPEAKER_00 И поэтому, чтобы избежать такой ситуации, разработчики изначально запретили наследоваться от интерфейсов.
1272.14 1284.98 SPEAKER_00 Но это, на самом деле, породило ряд неудобств, например, мы можем использовать функции, реализованные от интерфейсов, не только используя переменные указатели.
1284.98 1305.70 SPEAKER_00 Мы можем вызвать внутри локальной функции функцию, порожденной от интерфейса, например, в Generic методе, и компилятор в этом случае не оборачивает структуру в управляемый объект, а вызывает метод непосредственно таким, каким он реализован, может даже инлайнить его.
1305.70 1344.02 SPEAKER_00 Но так как существовал этот запрет, с RefStruct'ами нельзя, например, было использовать такие интерфейсы, как IComparable, ICodable, то есть сравнение объектов, нельзя было использовать IDisposable из DisposePattern, и поэтому разработчики логично решили, зачем нам запрещать наследоваться от интерфейсов, если мы можем просто запретить RefStruct присваивать ссылки, которые реализует интерфейс, то есть ссылка с типом, например, IDisposable.
1344.02 1362.70 SPEAKER_00 Поэтому теперь, начиная с C# 13, можно, например, наследовать в структуре RefStruct, наследоваться от IDisposable, IComparable, и использовать, вызывать в функции compare или dispose прямо в методе.
1362.70 1376.98 SPEAKER_00 И в том числе можно использовать, вызывать dispose вместе с ключевым словом using, в этом случае компилятор при выходе из зоны видимости, вызвать функцию dispose для RefStruct'а в зависимости от того, как хочет разработчик.
1376.98 1381.90 SPEAKER_00 И, собственно, я ради интереса сделал поиск в .NET Runtime.
1381.90 1400.58 SPEAKER_00 В девятой версии я нашел, правда, одну единственную структуру, помеченную как internal, которую разработчики реализовали интерфейсом, и IComparable – это один компаратор RefStruct.
1400.58 1418.58 SPEAKER_00 Собственно, я так понимаю, что большей части они реализовали для целей рантайма, но, в принципе, если какие-то продвинутые разработчики хотят с помощью оптимизации реализовать RefStruct, то они могут теперь пользоваться такой возможностью, как наследование от интерфейсов.
1418.58 1419.58 SPEAKER_00 Такое замечание.
1419.58 1427.58 SPEAKER_01 Это довольно удобно, в принципе, да, ты стандартную функциональность, с которой мы все привыкли, которую все ожидают, а реализовал он настолько в низкоуровневых структурах.
1427.58 1432.38 SPEAKER_01 В принципе, и ограничения тоже вполне приемлемы, вполне нормально с ними можно жить, это хорошая
1432.38 1433.38 SPEAKER_00 штучка.
1433.38 1439.42 SPEAKER_00 Да, потому что мы просто теперь… Компилятор запрещает боксинг, но не запрещает наследование.
1439.42 1453.94 SPEAKER_00 Еще следующим ограничением, которое было снято, это ограничение, которое не позволяло использовать RefStruct в делегатах, не просто в делегатах, а в generic делегатах.
1453.94 1490.18 SPEAKER_00 То есть, в принципе, делегат можно было передавать RefStruct как параметр, возвращать как параметр, так как делегат существует в контексте вызываемой функции, то компилятор знал область видимости RefStruct, и это позволяло… То есть, этого ограничения не было, что ссылка существует внутри области видимости, и можно передавать, например, Span в качестве параметра в вызыванную функцию, получить Span из вызванной функции и работать с ними вполне нормально.
1490.18 1496.26 SPEAKER_00 Но была проблема в том, что делегаты, generic делегаты это не поддерживали.
1496.26 1519.34 SPEAKER_00 Например, у нас есть в system целый класс делегатов, таких как Action, Func, и у них есть generic параметры, и если попытаться в #12 мы раньше использовать Span от Char как параметр этого делегата, то компилятор ругался и не позволял это сделать.
1519.34 1534.74 SPEAKER_00 И для того, чтобы решить эту проблему, например, приходилось писать собственный делегат, у которого явным образом обозначено, что он принимает RefStruct, и тогда компилятор позволял вызвать такой делегат, или, собственно, такую функцию.
1534.74 1544.02 SPEAKER_00 То же самое, например, касается generic коллекции, generic функций, не только делегатов, а, собственно, любой generic функции.
1544.02 1554.02 SPEAKER_00 В любую generic функцию нельзя было передать, инстанцировать ее с шаблонным параметром типа RefStruct.
1554.02 1579.78 SPEAKER_00 И в 13-й версии C# с помощью специального constraint allow RefStruct это ограничение снимается, и теперь в любой делегат или в любой generic функцию можно Span, как и любой другой RefStruct, передать как параметр шаблона и использовать его как для передачи параметров, так и для возврата значений из функции.
1579.78 1587.74 SPEAKER_01 Вот интересно, что впервые, наверное, за долгое время нам добавили какое-то новое ограничение на generic type.
1587.74 1592.18 SPEAKER_01 Это вот как раз ключевое слово allow RefStruct, что у нас появилось.
1592.18 1595.86 SPEAKER_01 Что-то новое, интересное в методе, которым мы можем написать where для generic метода.
1595.86 1596.86 SPEAKER_01 Да.
1596.86 1597.86 SPEAKER_00 Это хорошо.
1597.86 1614.70 SPEAKER_00 И я посмотрел в runtime, теперь все actions и func, которые раньше не позволяли, они теперь в явном виде прописаны с этим allow RefStruct constraint с ограничением.
1614.70 1623.22 SPEAKER_00 И теперь, начиная с 9 C#, actions и func можно использовать со Spans, что, на мой взгляд, тоже очень удобно.
1623.22 1631.34 SPEAKER_00 И раньше это ограничение было, скажем так, избыточным.
1631.34 1636.46 SPEAKER_00 Оно не имело такого практического смысла, и наконец его сняли.
1636.46 1640.58 SPEAKER_01 Как всегда, перестраховались, сделали намного больше ограничений, чем нужно.
1640.58 1648.18 SPEAKER_01 Намного легче их потом расслаблять, чем вместо этого было бы усложнять, потому что усложнять это уже breaking changes было, и вряд ли бы команда на это пошла.
1648.18 1652.74 SPEAKER_01 А расслаблять, пожалуйста, вот вам новое какое-то расслабление, новое ограничение.
1652.74 1655.06 SPEAKER_01 Ох, хорошая штука, тоже полезно.
1655.06 1661.18 SPEAKER_01 Давай перейдем к последней теме, что-то тут совсем нагородили, какой-то ref, unsave, async и вот это вот все.
1661.18 1662.62 SPEAKER_01 Что вот это такое?
1662.62 1682.14 SPEAKER_00 Здесь проблематика методов итераторов, которые используют yield_return, yield_break, а также асинхронных методов в том, что эти методы на самом деле не существуют целиком, как их написал разработчик.
1682.14 1687.42 SPEAKER_00 Они компилятором разбиваются на несколько подметодов, я бы их так назвал, внутренне реализованных.
1687.42 1715.62 SPEAKER_00 И состояние этих методов, внутренние локальные переменные и вызываемые параметры, они хранятся не в стеке, а в специальном классе, который генерирует компилятор, это состояние далее используется в машинном состоянии при работе с методом, когда идет возврат перечисления из функции итератора или ожидается evade.
1715.62 1740.34 SPEAKER_00 Смысл в том, что когда мы входим в функцию, мы достигаем некой ключевой точки, либо yield_return, либо evade, и в этом месте компилятор на самом деле заканчивает подметод, он возвращает вызываемой функции результат вместе с состоянием, которое сохраняется в куче.
1740.34 1757.58 SPEAKER_00 И так как состояние сохраняется в куче, то нельзя было использовать refstruct, так как refstruct сохранится в куче, и область видимости таким образом расширяется на неопределенное время, и ссылка могла стать недействительной.
1757.58 1776.18 SPEAKER_00 Но и здесь разработчики подумали, что ограничение может быть избыточной, если refstruct существует только временно между вызовами оператора yield_return или между вызовами evade, и они ослабили это ограничение.
1776.18 1792.38 SPEAKER_00 И сейчас, начиная с C# 13, можно, например, span, раньше span вообще нельзя было использовать в функциях итераторах и функциях, которые реализованы с помощью async/evade.
1792.38 1802.06 SPEAKER_00 При попытке использования компилятор запрещал нам это делать, что было очень неудобно, потому что в принципе это хорошая штука, и в некоторых ситуациях она могла быть полезна.
1802.06 1819.22 SPEAKER_00 Сейчас же, начиная с C# 13, span можно использовать в этих функциях, но можно использовать только до ключевого слова evade или yield_return, то есть только во временной области видимости.
1819.22 1833.86 SPEAKER_00 Например, мы берем строку, берем из нее span, вычитываем какие-то данные и сразу их возвращаем через yield_return или передаем, сконверсировав функцию, которая вызывает evade.
1833.86 1849.78 SPEAKER_00 И эта точка, где происходит yield_return или evade, она как бы разбивает функцию на две области видимости, и значение не должно передаваться в другую область видимости.
1849.78 1861.38 SPEAKER_00 Если мы попытаемся использовать переменную за пределами ключевого слова, за пределами области видимости, то компилятор нам не позволит выдать ошибку, скажет, что так делать нельзя.
1861.38 1872.94 SPEAKER_00 Поэтому это очередное ограничение, которое было снято и сделано для более удобного использования span, прежде всего.
1872.94 1874.94 SPEAKER_00 Надеюсь, было понятно.
1874.94 1880.74 SPEAKER_01 Да, вроде понятно, а кажется, что это тоже довольно такая редкая штука.
1880.74 1893.26 SPEAKER_01 Скажи, на твой взгляд, эти три нового введения, насколько они будут использоваться в прикладном программировании, именно не в рантайме, не в системном, не какими-то ядерщиками, а вот в каждодневном интерпрайсе, в нашем любимом программировании.
1893.26 1915.70 SPEAKER_00 Думаю, что все, кто использует span, оценят это нововведение, потому что они снимают ряд ограничений, таких, как то, что span нельзя было раньше использовать в async/evade, а мы сейчас очень активно используем async/evade для веб-сервисов и так далее.
1915.70 1933.74 SPEAKER_00 Мы не могли раньше использовать дженерики, раньше мы не могли использовать экшены, и, кстати, теперь разработчики расширили поддержку коллекций со снятыми ограничениями.
1933.74 1950.62 SPEAKER_00 Например, в concurrent dictionary появились функции, которые позволяют принимать делегаты, которые генерируют ключ и одним из параметров которых может быть ref-структура.
1950.62 1971.70 SPEAKER_00 Например, если нам нужно сгенерировать ключ, передавая в него некоторый результат, и этим результатом может быть span, то мы теперь можем передать этот span как один из параметров в concurrent dictionary, и конкурент dictionary сгенерирует ключ или значение, используя как параметр, например, span.
1971.70 1972.82 SPEAKER_00 Раньше так было делать нельзя.
1972.82 2008.74 SPEAKER_00 Если вы раньше, например, использовали span по причинам ограничений, не могли использовать async/evade или передавать в делегат, то, начиная с C# 13, это ограничение снимается и можно использовать span гораздо гибче, таким образом уменьшая количество копирований памяти, потому что раньше в C# 12, например, нужно было скопировать под строку и передать ее в качестве ключа, чтобы сгенерировать результат.
2008.74 2010.70 SPEAKER_00 Сейчас этого уже больше делать не нужно.
2010.70 2011.70 SPEAKER_01 Ну, супер.
2011.70 2016.82 SPEAKER_01 То есть все разработчики, которые пользуются span, в принципе, хорошо оценят эти нововведения.
2016.82 2023.30 SPEAKER_01 Ну и правильно ли я понимаю, что вот этим системщиком, runtime-щиком, компиляторщиком, это вообще мега необходимая вещь и без нее…
2023.30 2028.30 SPEAKER_00 Ну, конечно, фреймбек будет развиваться дальше.
2028.30 2037.14 SPEAKER_00 Мы будем получать новые более оптимизированные функции, которые внутри runtime используют меньше выделения памяти.
2037.14 2038.14 SPEAKER_00 Ну, классно.
2038.14 2049.34 SPEAKER_01 Большое спасибо, что пришел, рассказал и разъяснил, потому что тема действительно редкая, мало кто ее понимает, мало кто знает, поэтому информирование общественности — это довольно важная штука.
2049.34 2052.18 SPEAKER_00 Рад был поучаствовать, спасибо, что пригласили.
2052.18 2053.46 SPEAKER_01 Пока, до новых встреч.
2053.46 2054.78 SPEAKER_00 Спасибо, до свидания.
2054.78 2060.56 SPEAKER_01 Ну что ж, в принципе, большое спасибо, Юра прекрасно все рассказал, надеюсь, вам стало более-менее понятным.
2060.56 2088.06 SPEAKER_01 Ну и напомню, что в принципе в течение всего выпуска мы будем, наверное, кратко пробегаться по тем нововведениям, которые есть, как раз таки потому, что весь год во всех наших предыдущих выпусках мы посвящали им многие-многие часы для разборов, иногда не один раз, поэтому если вас какая-то тема зацепила, пролистайте наши предыдущие выпуски за этот год и наверняка вы найдете какие-нибудь статьи, интересные комментарии и подробный разбор каждого из этих нововведений.
2088.06 2105.30 SPEAKER_01 Окей, да, действительно, мы много чего старались отсмотреть и описать, и пойдем дальше в сторону тоже довольно такой практически полезной штуки, которую так же как и C# многие используют каждый день, программированный C#, и это библиотеки.
2105.30 2128.70 SPEAKER_01 Это довольно большой раздел, что появилось снова в библиотеках, просто потому что, ну вы же понимаете, какое количество мелких фич и багов исправляется в стандартной библиотеке, нашего дотнета, и можно, в принципе, это все описывать долго-долго-долго, но попробуем кратенько и быстро пробежаться, чтобы сильно долго не утомлять и не углубляться совсем уж в детали.
2128.70 2136.50 SPEAKER_01 Значит, идем в порядке Майкрософта, и что-то мне, я только сейчас понял, что порядок этот очень простой, он алфавитный.
2136.50 2138.30 SPEAKER_01 Пока готовился, чуть мне не пришло это в голову.
2138.30 2175.14 SPEAKER_01 Начинаем тогда, соответственно, с буквы B, это Base64 URL, у нас уже был когда-то Base64 encoding, она хорошая, она часто используется, но с ней есть большая проблема, в Base64 есть значки + и /, которые очень плохо дружат с URL, то есть когда вы кодируете какие-нибудь параметры в query-строке в URL, то + и / приходится делать, дополнительно кодировать ее, чтобы было безопасно в URL, и поэтому в Майкрософте в дотнете появился класс Base64 URL, который использует, соответственно, минусы и подчеркивания вместо них.
2175.14 2182.34 SPEAKER_01 У него есть замечательный метод encodeToString, ну и обратный, который позволяет, соответственно, вам закодировать.
2182.34 2216.98 SPEAKER_01 Байнари-форматор, мы про него точно уже говорили, байнари-форматор удален из дотнета, все API, ну они если и есть, то они будут кидать теперь исключения, и есть на Майкрософте, на сайте learnmicrosoft.com, соответственно, статья про то, что делать, если вам все-таки нужен байнари-форматор, там есть обходные пути, можно его так или иначе подключить обратно через NuGet-пакеты, есть отдельный NuGet-пакет, который позволит вам только читать, короче, если вам вдруг зачем-то он очень сильно все еще нужен, читайте инструкцию, там все написано.
2216.98 2217.98 SPEAKER_01 По коллекциям.
2217.98 2244.54 SPEAKER_01 С коллекциями все так же мы про спаны, рефы и все остальное, конечно же, не обошлись без них, появилась у словарей метод под названием getAlternateLookup, то есть если вам нужно не просто смотреть значения по ключу, но иногда вам нужно искать значения по альтернативному ключу, то у вас теперь есть возможность это сделать, ну и там, естественно, все это построено на спанах, чтобы было поменьше аллокаций для скорости.
2244.54 2253.02 SPEAKER_01 Появилась коллекция OrderedDictionary, который был в принципе в .NET и раньше он был не дженериковый, теперь он дженериковый.
2253.02 2262.54 SPEAKER_01 В PriorityQueue добавился метод remove, соответственно теперь можно через него эмулировать, по сути, обновление приоритета, удаляя какую-то запись и добавляя ее обратно с новым приоритетом.
2262.54 2271.94 SPEAKER_01 ReadOnlySet - это read-only вьюшка такая над коллекцией, то есть это не сама коллекция, это просто обертка на дне, которая кидает исключения из всех методов записи.
2271.94 2277.10 SPEAKER_01 Ну, в общем-то, по коллекциям более-менее все.
2277.10 2307.70 SPEAKER_01 Для целей всякого разного тримминга и, в общем, API-шек, которые правильно будут работать с NativeOut добавилась штука под названием TypeDescriptor, то есть вы теперь можете с помощью метода TypeDescriptor.RegisterType правильно зарегистрировать типы так, чтобы, соответственно, не runtime, а компьютер потом знал, что со всем этим делать, когда он будет триммить.
2307.70 2335.54 SPEAKER_01 По криптографии, там в основном PerformanceOptimization, чуть-чуть более удобный UI-чик, и, наверное, самое большое изменение в криптографии - это класс под названием X.509.CertificateLoader, чтобы вам не нужно было больше загружать сертификаты через создание нового инстанса класса X.509.Certificate2, если я правильно помню, который на разных операционках ведет себя чуть-чуть по-разному, плюс на некоторых он еще и темповые файлы создает, которые за собой иногда не чистят.
2335.54 2339.06 SPEAKER_01 Если его неаккуратно использовать, но, видите, по крайней мере, такое было.
2339.06 2348.26 SPEAKER_01 Теперь есть X.509.CertificateLoader, ведет себя одинаково на всех платформах, но, правда, поддерживает далеко не все сертификаты, а, по-моему, только два вида, но, правда, наиболее популярных.
2348.26 2389.74 SPEAKER_01 Для даты и времени появились новые оверлоады в классе TimeSpan, если вам зачем-то нужно было создавать, ну, допустим, не знаю, TimeSpan, который занимает 101 секунду и 832 миллисекунды, то можно было это сделать fromSeconds 101.832, но это же дабл, да, дабл у нас не очень точный, 832 это будет не совсем точно 832, возможно, а чуть-чуть больше, либо чуть-чуть меньше, теперь можно прям передать отдельно секунды и миллисекунды отдельными интеджерами, там прям интеджер в аргументах.
2389.74 2422.50 SPEAKER_01 Дальше идем по Dependency Injection, почему-то в разделе Dependency Injection, ну, впрочем, понятно почему, находятся импровменты в классе активатора, ну, точнее, активатор Utilities CreateInstance, он теперь поддерживает правильный поиск конструкторов, он теперь, оказывается, есть такой атрибут, называется ActivatorUtilitiesConstructorAttribute, и если вы пометите свой конструктор вот именно этим атрибутом, именно он будет создаваться, когда вы вызовете CreateInstance.
2422.50 2425.54 SPEAKER_01 Честно говоря, ни разу не пользовался, но ладно.
2425.54 2440.78 SPEAKER_01 В диагностике некоторые изменения вокруг OpenTelemetry добавили, разные всякие типы, и чуть более удобная опишка, DebugAssert, если кто-то другом пользуется, пишет теперь не просто, что что-то там сломалось, а прям выражение, которое было в ассерте.
2440.78 2450.30 SPEAKER_01 В LinkU, ну, в LinkU в основном всякие разные методы типа там CountBy, AggregateBy, прочие другие By, и так далее, ничего интересного.
2450.30 2467.78 SPEAKER_01 LoggingSourceGenerator живет давно, работает хорошо, и теперь, по-моему, позволяет работать еще и с Primary Конструкторами, то есть вам теперь достаточно iLogging передать прямо в Primary Конструктор, и LoggingSourceGenerator это позволяет.
2467.78 2474.54 SPEAKER_01 Так, про всякие рефстракты мы особо, наверное, не будем погружаться.
2474.54 2493.58 SPEAKER_01 SearchValues, мы про это, мне кажется, детально, выпуска 4 или 5 назад говорили, про то, что SearchValues теперь гораздо более длинные строчки поддерживает для поиска, делает это оптимально, там использует Synth, вот это все, так что будет работать быстро, хорошо и замечательно.
2493.58 2494.58 SPEAKER_01 Нетворкинг.
2494.58 2528.86 SPEAKER_01 В нетворкинге, на самом деле, довольно важные, на мой взгляд, изменения, не знаю, насколько это сильно повлияет на сам, на работоспособность и на работу непосредственно самих приложений, но теперь у нас по дефолту используется Sockets HTTP Handler, поддержанные, ну это уже такая более opt-in фича, в смысле, если вы это используете, и ServerSendEvents, можно с ними теперь нормально работать, улучшено там всякая performance вокруг TLS, улучшена работа с WebSocket, короче, всячески, как всегда, только улучшения, ни одного ухудшения, даже удивительно.
2528.86 2529.86 SPEAKER_01 Reflection.
2529.86 2564.98 SPEAKER_01 Вот, а Reflection довольно интересно, потому что Reflection, на первых, стал быстрее, мы про это говорили отдельно, во-вторых, Reflection стал позволять записывать сборки на диск, то есть до 9.net вы могли создавать Reflection сборки, но вы не могли нормально писать всё это на диск, теперь есть специальный тип, называется PersistedAssemblyBuilder, который позволяет это всё потом, всё то, что вы там наимители, сохранить на диск, а не просто в какой-нибудь ассембле, вот, контекст.
2564.98 2606.06 SPEAKER_01 Regularity тоже, блин, мы вообще про всё говорили, мне кажется, про регулярки, про то, что мы теперь можем говорить генерик, GenerateRegex на пропертях, потому что partial пропертиз поддерживается в 13 C#, и в Regex'е теперь, если вы, например, Regex используете для того, чтобы поэнумерироваться по тем частям, которые он распознал, теперь есть метод enumerateSplits, который полностью на спанах, то есть ему можно передать спан, он будет возвращать, соответственно, рейнджи, и вы через какой-нибудь там awaitForEach, вероятно, сможете совершенно замечательно всё это поэнумерировать практически без расходов памяти.
2606.06 2641.54 SPEAKER_01 System.txt.json, как обычно, вот оно то в Span.core попадает, то в библиотеке почему-то, обзавёлся нормальной полноценной поддержкой nullable annotations, про которую мы говорили странно, что я не был до этого, поддобавилась очень важная и нужная штука этого, чтобы понимали масштаб, да, обзавёлся полной поддержкой nullable annotations, а с другой стороны появилась кастомизация, каким символом, видимо, табом или пробелом, и насколько нужно сдвигать вложенные блоки при форматировании, это очень важная фича, достойное упоминания в релиз-ноутсах.
2641.54 2657.90 SPEAKER_01 Есть теперь дефолтный такой, дефолтный набор настроек под названием jsonSerializerOptions.web, туда сложены настройки, которые команда Microsoft считает достойными быть дефолтным для Span.core.
2657.90 2665.22 SPEAKER_01 Можно кастомизировать, как ваши enum'чики сериализуются, с каким именем, навесить атрибутик на соответствующий enum.
2665.22 2688.34 SPEAKER_01 Ну и ещё, если у вас есть конструктор с неопциональными параметрами, то теперь, и это единственный способ создать ваш класс, то сериализатор будет требовать наличия всех этих параметров, т.е. если в json, из которого он собирает ваш класс, какие-то параметры, какие-то поля отсутствуют, которые не позволяют создать объект, у которого в конструкторе есть обязательные параметры, то это будет ошибка при диссериализации.
2688.34 2706.18 SPEAKER_01 Со спанами, я к ним всё время возвращаюсь, потому что они появляются то там, то сям, файловая API-шка расширилась работой со спанами, т.е. теперь можно прям read-only span писать напрямую в файл, через файл.writeAllText, как мы это привыкли делать со строками.
2706.18 2709.18 SPEAKER_01 По RAMS, понятно, уже проговорили.
2709.18 2710.18 SPEAKER_01 System.guid.
2710.18 2725.90 SPEAKER_01 В гуидах, кстати, довольно важные изменения, мне казалось мы про него не сильно много рассказывали, но по-моему упоминали, что в гуидах появился новый метод, называется createVersion7.
2725.90 2740.06 SPEAKER_01 И здесь разница между… ну, гуид у вас получается такой же, System.guid, как и был, разница только в том, что он чуть-чуть другой с точки зрения внутренней структуры, внутреннего наполнения.
2740.06 2749.50 SPEAKER_01 Он на самом деле сортируемый, т.е. он не полностью случайный, но случайно, у него есть случайная часть, и у него есть часть, которая зависит от текущего времени.
2749.50 2754.46 SPEAKER_01 И за счет этого он, условно говоря, плюс-минус монотонно возрастаемый.
2754.46 2755.46 SPEAKER_01 Ну, почти.
2755.46 2769.78 SPEAKER_01 За счет рандомной части, понятно, что у него будет некоторая рандомность, но он по крайней мере хоть как-то возрастающий, и это полезно, когда вы его используете в качестве каких-нибудь ключиков в базе данных или еще чего-то, где вы ожидаете, что было бы полезно монотонное возрастание.
2769.78 2780.18 SPEAKER_01 А также у гуида появилось поле, пропертя, которое позволяет узнать версию гуида, ну потому что теперь он может быть в i4 и в i7 в Майкрософте.
2780.18 2804.90 SPEAKER_01 Так, ну, большие много всяких разных изменений, мы про них уже, по-моему, не один выпуск записали в System Numerics, туда же я отношу всякие тензоры и прочее, т.е. все, что касается работы с числами, BigInteger там немножко поменялся, Vector API добавились и поменялись, TensorType, и все API вокруг него добавился, в общем, там много чего было.
2804.90 2805.90 SPEAKER_01 Не буду углубляться.
2805.90 2828.18 SPEAKER_01 Ну и трейдинги, в трейдинге тоже мы довольно много говорили, появилась полезная API TaskWhenEach, т.е. это аналог TaskWhenAll или TaskWhenAny, который позволял раньше дождаться либо завершения всех тасков, либо завершения хотя бы какой-то таски, и непонятно было делать, что было делать с остальными.
2828.18 2858.18 SPEAKER_01 Если мы дожидаемся, например, какой-то, их надо было видимо отменять через CancellationToken как вариант, теперь есть такой метод, называется TaskWhenEach, который возвращает iosync номер, мол, от тасков, и он будет возвращать таски по мере их завершения, т.е. если вам нужно запустить несколько таскочков параллельно и дождаться их завершения, и по мере их завершения делать какую-то полезную работу, например, складывать их результаты в какое-то место, коллекционным результатам, например, то вы теперь это можете сделать через вот такой вот TaskWhenEach метод, очень полезно.
2858.18 2875.50 SPEAKER_01 Ну вот так вот голопом по Европам получилось обозрить все, что наверное изменилось в библиотеках, по крайней мере то, что было достойно включения в Release Notes, понятно, что там наверное раза в 4-5 больше еще всяких разных багов пофиксили вокруг этого, но понятно, что там совсем в баги углубляться времени особо нету.
2875.50 2885.94 SPEAKER_01 Ну, список довольно весомый опять же, если мы сравним со всеми остальными категориями, которые были изобретены Microsoft за этот год, то кажется, что в библиотеке прям там люди работали.
2885.94 2904.14 SPEAKER_01 Ну, выглядит, что да, не сказать, что там какие-то прям мегаизменения, хотя довольно приятные, то есть там Reflection, который ускорился, и вызов метода Reflection стал довольно… мы же обсуждали там что-то типа раза в 3, по-моему, в 4 быстрее, ну в таких бенчмарковых, понятно, сценариях, но тем не менее.
2904.14 2913.58 SPEAKER_01 То есть какие-то штуки, которые вы все еще ожидаете от платформы, что она будет становиться быстрее, полезнее и так далее.
2913.58 2914.58 SPEAKER_01 Так что, ну, приятно.
2914.58 2915.58 SPEAKER_01 Приятно.
2915.58 2922.50 SPEAKER_01 И, конечно же, с выпуском нового фреймворка мы не могли обойти нововведения в другом прекрасном языке.
2922.50 2923.82 SPEAKER_01 Это F# 9.
2923.82 2935.14 SPEAKER_01 В общем, в F# 9 мы не сильны, но, в принципе, мы нашли выход в предыдущих выпусках, и, как всегда, позвали знатного специалиста, это Марк Шевченко.
2935.14 2936.14 SPEAKER_01 Привет, Марк.
2936.14 2937.14 SPEAKER_01 Привет, Толя.
2937.14 2943.46 SPEAKER_01 Так, ну расскажи им, что в девятом релизе F# такого самого важного интересного у нас произошло.
2943.46 2944.46 SPEAKER_01 Хорошо.
2944.46 2952.74 SPEAKER_01 Я бы вот рассказывал структуру немного, исходя из тех достоинств и недостатков, которые в языке F# есть.
2952.74 2957.14 SPEAKER_01 Считается, в частности, что он достаточно медленный по сравнению с C#, он все-таки функциональный.
2957.14 2964.02 SPEAKER_01 Это не совсем так, и реально вот ребята пишут очень производительный код, тем не менее, есть определенная проблематика в этом плане.
2964.02 2969.14 SPEAKER_01 И здесь несколько хороших нововведений есть в девятой версии.
2969.14 2979.46 SPEAKER_01 В частности, проверка на равенство, она уже, по-моему, около 10 лет висела, значит, она приводит к боксингу примитивных этих типов, интов, флотов.
2979.46 2992.94 SPEAKER_01 Вот с этим, наконец, справились, теперь, значит, у нас вы можете искать компоненты, скажем, в массиве, в большом списке, и у вас не будет бокситься все эти объекты, которые там лежат.
2992.94 3004.94 SPEAKER_01 То есть сейчас, ну вот если массив был из 10 тысяч интов, то у вас бы боксились все эти инты, сколько там, 40 тысяч байт.
3004.94 3009.42 SPEAKER_01 А сейчас нет, сейчас как бы все выкладывается в 20 байт.
3009.42 3022.86 SPEAKER_01 То есть в этом вопросе оптимизировали, теперь память лишняя не расходуется, точно так же размеченные объединения тоже научились чуть-чуть оптимизировать.
3022.86 3026.50 SPEAKER_01 Слушай, а расскажи, для интов, в общем, интересная довольно тема.
3026.50 3027.50 SPEAKER_01 А почему так случилось?
3027.50 3030.34 SPEAKER_01 Потому что примитивные типы в C# и в дотнете уже были довольно давно.
3030.34 3063.10 SPEAKER_01 А это проверка на равенство, она как бы в самом виде компилятора, значит, для того, чтобы сравнить два инта, он все равно делает equals через это сравнение, через этот метод, а он же относится к объекту, то есть он же наследуется по сути, и поэтому каждый, ну это было так реализовано там, по крайней мере, значит, каждый инт, он боксился, передавался это в оператор equals, передавались две ссылки, они сравнивались там и вот в метод equals.
3063.10 3066.18 SPEAKER_01 Ну понятно, потому что через объект все сравнение шло.
3066.18 3073.14 SPEAKER_01 Да-да-да, и это, значит, ну понятно, была известная проблема, но все никак руки не доходили, а тут как бы дошли наконец-то.
3073.14 3079.70 SPEAKER_01 Это просто компилятор такие вещи должен, он видит, это частный случай, для него и у него есть специальные решения.
3079.70 3082.02 SPEAKER_01 И он тогда без боксинга может это все сделать.
3082.02 3084.54 SPEAKER_01 Ну отлично, да, хорошая вещь.
3084.54 3085.54 SPEAKER_01 Молодцы.
3085.54 3096.98 SPEAKER_01 Размеченные объединения, но это нет прямого аналога, скажем, в C#, но если смотреть в C или в C++, это объединение там есть такое понятие.
3096.98 3114.38 SPEAKER_01 В текущей версии же в C#, в восьмой, они не слишком плотно упаковываются, а там, значит, в новом F# научились, если, скажем, все объекты занимают по 4 байта, то есть суммарно все размеченные объединения тоже будут там 4 байта.
3114.38 3118.06 SPEAKER_01 Раньше они просто рядом иногда укладывались, рядом друг с другом.
3118.06 3122.78 SPEAKER_01 И, значит, там работа с интервалами тоже была оптимизирована.
3122.78 3134.50 SPEAKER_01 Интервалы, это вот, скажем, если у нас от 10 до 20, да, у нас или мы цикл обходим, или мы сравниваем, ну, проверка на то, что попадает число внутри этого интервала.
3134.50 3155.06 SPEAKER_01 Значит, раньше они работали только быстро, только с целыми числами и с шагом единицы, а сейчас оптимизировали код, сейчас может работать не только с целыми числами, с любыми, ну, не только с интами, а с любыми целочисленными переменами, их у нас в дотмейке много, и с любым шагом, то есть не только единицей.
3155.06 3160.18 SPEAKER_01 Тоже похоже, что нововведение такое чисто руки не доходили, да, то есть надо просто было взять и сделать.
3160.18 3161.86 SPEAKER_01 Оно очевидно, понятное.
3161.86 3180.78 SPEAKER_01 Специальные случаи, специальные кейсы как бы отрабатывали, что вот для этого случая быстрая компиляция, ну, компилятор, генерировали быстрый код, а для общих случаев был просто и номер был обычный, но сейчас это все как бы посмотрели, дошли руки, все теперь делается специфичным кодом, все гораздо быстрее работает.
3180.78 3182.78 SPEAKER_01 Ну, прям хорош такой набор оптимизаций.
3182.78 3183.78 SPEAKER_01 Да.
3183.78 3197.18 SPEAKER_01 Вторая проблема это, значит, то, что над C# работает несколько десятков человек у нас, а над F# всего несколько человек, и в C# гораздо больше как бы нововведений в команде F# приходится добивать, догонять.
3197.18 3201.68 SPEAKER_01 Многое, что уже в C# есть, в F# не было, и вот это туда доносят.
3201.68 3219.14 SPEAKER_01 Ну, в частности, одно из интересных нововведений это nullable типа, это с интервопом связано, у нас в F# в принципе nullable типа не было до этого, и это очень хорошо, потому что тогда null reference exception не должен возникать.
3219.14 3240.14 SPEAKER_01 Но проблема в том, что F# он же не отдельный язык, это часть большой экосистемы, и если у нас есть проект, в котором C# и F# вместе работают, то C# может прийти null, и этой поддержки ее в языке не было, а сейчас она есть, то есть вы можете явно пометить, что вот здесь в этом месте вам может прийти либо какой-то класс, либо null.
3240.14 3252.34 SPEAKER_01 Слушай, а расскажи, как раньше это выглядело, то есть к тебе из C# приходил null, у вас не было даже ключевого слова null, то есть ты не мог на него сравнить, проверить, как с этим можно было работать?
3252.34 3264.58 SPEAKER_01 Проверить в принципе мог, но ты не знал, что тебе надо это проверять, потому что тебе приходит класс, в F# в принципе у тебя должен приходить какой-то reference, то есть значение null не должно было приходить, ну как бы не должно.
3264.58 3275.70 SPEAKER_01 Сейчас ты можешь пометить, что вот в этом месте может прийти null, и тогда тебе в F#-коде тоже нужно будет это все проверять, и F#-компилятор будет уже варнинги тебе давать, если ты не проверил на null.
3275.70 3287.70 SPEAKER_01 Слушай, ну можно это сравнить, например, с тем, что как в C# раньше было в строке, допустим, в типе string, там могла содержаться как строчка, так и значение null, и компилятор об этом ничего не знал, то есть в F# у вас так же вот было.
3287.70 3294.34 SPEAKER_01 Если в C# мы интероп какую-нибудь делали, тебе могла прийти целая строка, мог прийти в этой строке null, и компилятор никак тебе в этом не помогал.
3294.34 3307.94 SPEAKER_01 Да-да-да, компилятор не помогал, сейчас как бы он на это дело может обращать внимание, может варнинги выдавать, если такое значение у тебя есть, и ты его не проверяешь на null где-то, то тебе компилятор выдает варнинги.
3307.94 3308.94 SPEAKER_01 Это удобно.
3308.94 3331.80 SPEAKER_01 Я правильно понимаю, что как бы F#-исты, они вот этими null-ами все равно пользоваться как бы не будут, это нужно только для интеропа с C#, а потом… Для интеропа – да, потому что в F# есть такой классический тип option, обычно мы для этого как раз его используем, то есть мы явно записываем, что у нас может не быть какого-то значения.
3331.80 3336.44 SPEAKER_01 Ага, ну хорошо, тогда вроде понятно, зачем ввели и понятно, как использовать.
3336.44 3339.16 SPEAKER_01 Да, ну это чисто для интеропа.
3339.16 3344.46 SPEAKER_01 Следующая – это у нас зона действия атрибутов, то, что называется атрибут target.
3344.46 3350.78 SPEAKER_01 Это такая история, что в C# это всегда работало, а в F# не всегда.
3350.78 3358.62 SPEAKER_01 Это когда мы можем навесить атрибут или на класс, или на метод, и мы точно указываем, что этот атрибут можно вешать только на класс, например.
3358.62 3370.58 SPEAKER_01 В F# это не все работало, и тут как бы почистили и сделали так, что теперь можно повесить атрибуты на функцию, например, на отдельную переменную, это позволяет избегать таких с очень тонко находимых ошибок.
3370.58 3385.58 SPEAKER_01 Тонкие ошибки позволяют находить, скажем, там один и тот же синтекс используют для определения, ну, то, что мы называем переменной, хотя в функциональных языках это не переменная, ну вот, и функции.
3385.58 3396.18 SPEAKER_01 Мы случайно, например, определяем функцию, забыли параметр определить и навесили атрибут, который только на функцию может быть, и тогда нам компилятор это подсветит, скажет, здесь у вас не стыковка.
3396.18 3401.86 SPEAKER_01 Слушай, а разве в F# атрибуты никаким образом там не наследовались от .NET-овских атрибутов, которые...
3401.86 3417.94 SPEAKER_01 Они наследовались, да, но там вопрос в том, что в C# там же, там эта тема, она уже прописана, реализована, то есть там, скажем, атрибут-таргетцы, они работают, а в F# они не всегда, не во всех случаях работали.
3417.94 3421.42 SPEAKER_01 Ну, ты их раньше мог там указать какие-нибудь, или вообще никакие не мог указывать?
3421.42 3435.98 SPEAKER_01 Нет, нет, ты мог указать, но просто они были, скажем, относились к классам, да, и методам, а в F# есть свои как бы, ну, там есть понятие модуля, в модуле могут быть функции.
3435.98 3443.46 SPEAKER_01 Это выглядит так, как обычные функции, то есть это не статические методы класса, вот, а в F#-коде это выглядит как функция.
3443.46 3451.34 SPEAKER_01 То есть мы не могли их описать терминами таргетов, которые есть в .NET, да, то есть здесь совсем другие языковые конструкции, которые никак не мапились на эти атрибуты?
3451.34 3462.58 SPEAKER_01 Ну, по идее-то это как раз, они в конечном итоге мапятся, но вот, значит, здесь компилятор их не учитывал в этом контексте, а учитывать-то их как раз надо, и вот они этот момент дописали.
3462.58 3463.58 SPEAKER_01 Ага, ясно.
3463.58 3483.68 SPEAKER_01 Значит, ну, немножко синтетического сахара инициализации через коллекцию, то есть то, что в C# было всегда, мы можем объявить какой-нибудь список, передать ему коллекцию, и он в C# ее инициализирует, в F# такого кода как бы не было раньше, такого способа инициализации, сейчас тоже появился.
3483.68 3493.22 SPEAKER_01 Ну, то есть мы сразу не через forEach, а как бы в фигурных скобках записываем все значения, и он их туда поместит сам, сгенерирует нужный код.
3493.22 3509.42 SPEAKER_01 Проблематика была с private/internal полями, там, где нужно было делать private, компилятор их делал internal, класс внутренний, из-за этого к ним получался доступ снаружи других проектов, если мы делали internal visible tool.
3509.42 3520.18 SPEAKER_01 То есть вот этот механизм сделали чуть более аккуратный, теперь, значит, приватные методы и переменные, они остаются приватными, то есть доступа к ним снаружи нет.
3520.18 3531.58 SPEAKER_01 Ну и немножко улучшили методы расширения, то есть это такая вещь, как бы все, что касается методов расширения, тоже немножко отстают в F# по сравнению с C#.
3531.58 3536.42 SPEAKER_01 Сейчас чуть-чуть больше, еще немного нагнали.
3536.42 3541.10 SPEAKER_01 В общем, у нас производительность, интеррупция, шарп, вот эти все вопросы закрыли.
3541.10 3566.30 SPEAKER_01 Есть несколько улучшений в языке, в библиотеке, немножко упростили работу с активными паттернами, сделали пустые вычислительные выражения, но это, скорее всего, вопрос такой, что вот люди пишут, и видишь, что есть какие-то несогласованности, то есть вот здесь можно чуть-чуть упростить, вот это, наверное, больше все синтоксический сахар, тем не менее очень приятно, то есть в конечном итоге для конечного программиста именно вот эти вещи, они такие приятные.
3566.30 3571.18 SPEAKER_01 Да, я смотрел примеры, и там прямо видно, что код довольно читабельнее и проще становится.
3571.18 3586.10 SPEAKER_01 Ну да, в частности, скажем, активные паттерны, то, что раньше они были, они должны были возвращать как раз этот опциональный тип, а сейчас он может превозвращать boolean, и это более логично для конечного программиста, который это делает.
3586.10 3599.46 SPEAKER_01 И в стандартную библиотеку добавили функции работы со случайными числами, такие интересные, то есть стандартная библиотека, она в принципе в F# всегда обгоняла C#, но тут снова очередной рывок, в C# этого нет.
3599.46 3602.34 SPEAKER_01 Есть такие функции, как типа shuffle, choose, choice, sample.
3602.34 3622.22 SPEAKER_01 Вы передаете условно туда массив или список, и можете выбрать, можете случайным образом перемешать, можете выбрать n элементов случайных, и причем он будет следить в одном случае, если вам надо, n совершенно разных элементов, а в другом случае n элементов, которые могут совпадать, для разных задач, разные решения.
3622.22 3630.30 SPEAKER_01 Тут еще надо не запутаться, потому что choice тебе, например, выдает только уникальные значения, а sample тебе выдает то же самое, что и choice, но значения могут повторяться.
3630.30 3631.30 SPEAKER_01 Да-да-да.
3631.30 3632.30 SPEAKER_01 Или наоборот.
3632.30 3641.22 SPEAKER_01 Не очень очевидные, может, из названия, но choice еще ладно, но вот sample, что делать с методом sample, без документации, мне кажется, никто не разберется.
3641.22 3650.22 SPEAKER_01 Да-да-да, ну это как бы пример данных, наверное, так нужно его интерпретировать, но да, ты прав, что название такое не очень очевидное.
3650.22 3676.10 SPEAKER_01 Ну и затем у нас довольно много улучшений в самом копиляторе, в тулингах, то есть Visual Studio немножко улучшили при работе с F#, улучшили вот этот F# Interactive, теперь директива Health позволяет, выдает помощь по объектам, по методам, сразу можно получить, посмотреть, что для чего используется.
3676.10 3689.14 SPEAKER_01 Дополнительные предупреждения, вообще, тут интересный момент, что в F#-компилятор он такой эмпатичный, то есть он помогает новичкам писать код и понимать, какая ошибка возникла.
3689.14 3709.70 SPEAKER_01 Это проблема, скажем, в C++-коде, когда вот ты ошибся в шаблонах, и у тебя сообщение компилятора — это 2000 строк кода, и ты не понимаешь, что ты просто один символ где-то пропустил, но вот такие вещи в F#-компилятор он специально разрабатывался для того, чтобы помогать, и он довольно точно позволяет вот новичку понять, что произошло.
3709.70 3727.62 SPEAKER_01 Еще больше ситуаций в этой версии учитывается, значит, еще лучше он подсказывает, в общем, в этом стороне тоже развили компилятор, а потом при ошибках тоже — это то, что называется partial recovery, это то, что нужно для тулинга.
3727.62 3735.22 SPEAKER_01 Мы набираем код, и у нас в текущий момент код может быть неправильный, вот прямо сейчас, но подсвечивать-то его надо правильно, как будто он, ну, корректный.
3735.22 3750.90 SPEAKER_01 И вот не всегда с этим можно справиться, и вот для этого как раз тоже компилятор дописывает для таких случаев неполного кода, то есть чтобы у нас не ломалась подсветка, чтобы взаимные ссылки могли работать, даже если не совсем корректный код вот сейчас прямо в редакторе.
3750.90 3758.22 SPEAKER_01 — Слушай, а расскажи про редакторы, в общем, я много у кого спрашивал с F#-пистами, они говорили, что у них любимый редактор — это Visual Studio Code.
3758.22 3766.70 SPEAKER_01 А как ты считаешь, какой сейчас самый лучший редактор для F#, если мы не ограничены какими-то платными или лицензионными оковами?
3766.70 3777.90 SPEAKER_01 — Неограничены, то, ну, мне больше всего нравится Rider, но это, наверное, очень традиционное мнение, у нас очень много F#-пистов выбирают Rider.
3777.90 3781.62 SPEAKER_01 — То есть у него там действительно поддержка лучше, да, чем у всех остальных?
3781.62 3814.74 SPEAKER_01 — Ну, да, там дело в том, что команда JetBrains, она очень сконцентрирована на этом, то есть в самом Microsoft'е такое ощущение, что Visual Studio, ну да, это как бы, да, тоже хорошо, но это ребята, которые, ну, помимо прочего, еще приносят день, когда мы там на офисе зарабатываем миллиарды, здесь еще, ну, 10 тысяч долларов зарабатываем на Visual Studio, ладно, пусть ребята развлекаются, то для JetBrains это как бы основной бизнес, и они прям вылизывают продукт, он такой, очень удобный, вот такая история.
3814.74 3815.74 SPEAKER_01 — Ну, хорошо.
3815.74 3825.42 SPEAKER_01 — В Visual Studio Code, там, да, там есть логины, и в принципе, в принципе тоже люди как бы работают, и VMAX работают, я знаю, в общем.
3825.42 3832.26 SPEAKER_01 — Не, ну погоди, ну чего ты так опускаешься, сразу после Visual Studio Code, где у нас находится Visual Studio, на каком месте?
3832.26 3833.26 SPEAKER_01 Она лучше кода, или хуже кода?
3833.26 3849.30 SPEAKER_01 — Не, она на втором, на втором, да, то есть она как бы, она очень хороша тоже, если б не было Rider, то Visual Studio, это просто, да, это тоже мастер, там, да, там очень все продумано, для разработки как раз Visual Studio тоже все есть.
3849.30 3852.94 SPEAKER_01 — И Visual Studio Code, это уже на третьем месте, да, а потом уже можно EMAX смотреть всякие?
3852.94 3874.42 SPEAKER_01 — Ну, скажем так, Visual Studio Code и EMAX, они рядом, потому что они уже пользуются этими LSP, в Visual Studio, в Rider, и там все-таки полноценные анализаторы, а в этих редакторах, это уже LSP, это внешние процессоры, которые, ну как бы даже по своим возможностям не позволяют делать все то, что позволяют делать Visual Studio и Rider.
3874.42 3878.98 SPEAKER_01 — А что такого есть в LSP, чего не может делать Visual Studio или Rider?
3878.98 3909.14 SPEAKER_01 — Не, наоборот, скорее, в LSP нет такого, что, ну, то есть LSP — это синтаксический, ну, подсветская синтаксиса, это, значит, возможно какие-то простые редакторинги, а в, ну, например, Visual Studio и в Rider у нас встроены средства анализа, он тебе подсказывает, ну, что здесь слишком сложный вход, например, вот такие вещи, он может смотреть, что здесь неиспользованная переменная, то есть он уже поток управления отслеживает, ну, такие вот вещи.
3909.14 3914.14 SPEAKER_01 — Ну да, понятно, что у них больше всяких возможностей, которые в LSP протоколе даже были не заложены никогда.
3914.14 3919.46 SPEAKER_01 — Не заложены, да, в этом проблема, но, может быть, если сам протокол будет расширять, то как бы это все тоже будет появляться.
3919.46 3924.78 SPEAKER_01 — Хорошо, есть еще что-нибудь, что мы забыли упомянуть, а ты хотел бы рассказать про новый релиз?
3924.78 3936.46 SPEAKER_01 — Ну, вот, ну, там по мелочи много, как бы, но, наверное, мы крупными кусками отхватили все, наверное, не стоит про каждое нововведение рассказывать, получится долго.
3936.46 3944.54 SPEAKER_01 — Да, наверное, да, кому интересно, советуем посмотреть статью, посмотреть официальный анонс, там много красивых примеров, вы сразу увидите, как синтаксис улучшается.
3944.54 3950.46 SPEAKER_01 — Видео в YouTube, там рассказываются все нововведения, с примерами прямо показывают.
3950.46 3960.98 SPEAKER_01 — Отлично, тогда с этим завершим, Марко, огромное тебе спасибо, что зашел, объяснил, рассказал, ну, всем успехом F#, хороших новых фич, все, пока.
3960.98 3961.98 SPEAKER_01 — Спасибо, пока.
3961.98 3985.22 SPEAKER_01 — Ну что ж, в принципе, мне нечего добавить, даже если бы я что-то и хотел, мне кажется, Марко отлично все рассказал, объяснил, поэтому вот такой еще один прекрасный язык, не забывайте о нем, может быть, кто-то что-то попробует, если вдруг еще не дошли руки, а те, кто программирует на F# 9, я думаю, словят для себя много полезных, интересных синтаксических конструкций, которые помогут в работе.
3985.22 4001.38 SPEAKER_01 — Ну, отлично, пойдем дальше по всему безбрежному, так скажем, списку нововведений, и давай затронем еще одну штуку, которую тоже, ну, может быть, не каждый день, но довольно часто все касаются, а именно SDK.
4001.38 4026.54 SPEAKER_01 То есть понятно, что когда у вас все настроено и все работает, наверное, вы не так часто лазаете в какие-то там CSS-проджи и так далее, вы пишете спокойно свой C#, но то, как работает SDK, эти фичи, которые вам предоставляют, на самом деле, довольно важны, и это часть тулинга, который в том числе сильно, ну, так скажем, любим в .NET комьюнити, да и вообще то, за что .NET в частности хвалит, за хороший тулинг.
4026.54 4092.78 SPEAKER_01 Посмотрим, что у нас Microsoft посчитала нужным включить в релиз Note 9 .NET в плане SDK и тулинга, и первый пункт — это Unit Testing, называется это, что .NET Test теперь интегрирован с MSBuild для параллельного Test Execution, то есть теперь ноды MSBuild, короче, которые выполняют параллельную сборку MSBuild могут еще, я так понимаю, что они же используются для запуска .NET теста, по дефолту ограничено все это количеством процессоров, но можно это все покрутить через параметр, можно задиземлить параллелизм, надо поставить в CSS-продже переменную test_tfms_imperial, почему tfms, я не знаю, ну ладно, tf_false, и при этом Terminal Logger, про который я чуть позже скажу, он на самом деле теперь более заточен на тест-аутпут, он теперь более красиво пишет, что там, где сейчас выполняется, и когда все закончило выполняться тоже чуть более красиво пишет, как это все выполнилось, так что Terminal Logger теперь прям, ну я видел несколько отзывов уже, что он прям приятный.
4092.78 4134.74 SPEAKER_01 Дальше, в .NET Tool'ах, которые вы, как вы знаете, можете ставить через .NET Tool Install, они на самом деле, по сути, прибиты гвоздиками были к специфичным версиям .NET, то есть вот вы поставили .NET Tool Install и в общем-то все, но теперь, когда вы при инсталляции говорите .NET Tool Install - - Allow Roll Forward, флаг такой указываете, то теперь вы можете ставить Tool'ы на более новую версию, дело в том, что далеко не все авторы успевают или могут или хотят обновлять Tool'ы до следующей версии .NET, а вы не можете поставить на новую версию .NET, а некоторые Tool'ы пока они не заапгрейдились.
4134.74 4142.38 SPEAKER_01 Вот этот флаг теперь позволяет их поставить по-любому, если вы почему-то считаете, хотите попробовать как оно будет работать.
4142.38 4156.26 SPEAKER_01 В принципе, полезно, если вы действительно пробуете новый .NET и хотите, чтобы все ваши там Tool'ы, которые вы используете, работали до того, как авторы успели их портировать.
4156.26 4161.30 SPEAKER_01 Возможно, это более интересно не для релизных, конечно, кейсов, а больше для превью-вариантов.
4161.30 4176.34 SPEAKER_01 Terminal Logger по дефолту теперь enabled, включен, в смысле, простите уже за англицизмы, без них никуда, а для всех .NET команд, которые вы выполняете в CommonLine, он теперь по сути является дефолтным.
4176.34 4204.38 SPEAKER_01 Там довольно много всяких фишечек, это всякие там clickable ссылочки, он еще считает всякие durations, то есть выводит все в цветных вариантах, и вот это вот все, можно это все, конечно, выключить с помощью --tail off, ну или поставить специальную переменную msbuild Terminal Logger в off, если вам почему-то это не надо, но говорят красиво и, в принципе, почему бы и не оставить.
4204.38 4205.38 SPEAKER_01 Полезно.
4205.38 4224.58 SPEAKER_01 В usability поменялись тоже, соответственно, когда в конце у вас выводят статистика, что там пошло не так, количество варнингов, количество фейлеров, оно теперь тоже более хорошо и качественно выводится, ошибки тоже теперь пишутся более красиво, особенно если в ошибке есть кучка ньюлайнов.
4224.58 4231.50 SPEAKER_01 Раньше они распадались на несколько ньюлайнов, и msbuild считал, что каждая строчка -- это своя собственная ошибка, и их выводил, соответственно.
4231.50 4236.58 SPEAKER_01 Иногда не то чтобы вперемешку, но они не очень приятно читались в конце вывода, теперь все пофиксили.
4236.58 4244.04 SPEAKER_01 Про NuGet Security Audits -- это следующая фича, мы тоже подробно уже рассказывали, Анатолий, я помню, прям большую статью обозревал на эту тему.
4244.04 4255.92 SPEAKER_01 В восьмом тутмете у нас появилось сам по себе аудитинг NuGet пакетов, а в девятом он по дефолту проводит этот самый аудит и для прямых зависимостей, и для транзитивных зависимостей.
4255.92 4276.76 SPEAKER_01 Для больших репозиториев ускорилось время для NuGet Dependency Resolution, потому что они практически полностью переписали резолвер, насколько я понимаю, но новый -- он теперь включен по дефолту, но если почему-то что-то пойдет не так, можно всегда переключиться на старый, то есть он стал быстрее, но, видимо, с багами, я не знаю.
4276.76 4278.84 SPEAKER_01 Но опцию переключения на старый они остались.
4278.84 4289.52 SPEAKER_01 Дальше по аналогии с нашими аналайзерами для C# кода теперь появились MSBuild Script аналайзеры, они же называются Build Checks.
4289.52 4326.36 SPEAKER_01 Сейчас их всего два, для того чтобы запустить нужно указать флаг /check при запуске MSBuild, но их два -- это два самых, наверное, распространенных штуки, которые все могут посмотреть и с ними что-то легко сделать достаточно при сборке -- это Shared Output Path, это когда у вас несколько проектов собираются в одну и ту же папку, это используется иногда для ускорения билда, но с другой стороны может приводить к несколько непредсказуемым последствиям, потому что если в разных проектах используются чуть-чуть разные версии зависимости, то какую итоговую вы получите в конце, особенно при параллельных билдах, никому неизвестно.
4326.36 4331.26 SPEAKER_01 Это DoubleWrites -- это когда по какой-то причине один и тот же файл по одним и тем же правилам почему-то перезаписывается.
4331.26 4334.08 SPEAKER_01 По идее, такого быть не должно при правильно построенном билде.
4334.08 4337.96 SPEAKER_01 Так что теперь вот эти анализаторы, возможно, появятся еще какие-то, пока нет.
4337.96 4353.38 SPEAKER_01 С Workloads появилось некоторое изменение, а именно следующее, ну вообще Workloads -- это штука, которая позволяет вам к уже установленному .NET SDK добавить какую-то функциональность.
4353.38 4376.98 SPEAKER_01 То, что раньше мы запускали там Installer Visual Studio и галочкой добавляли, а теперь я хочу еще, не знаю, программировать для Web, ставили галочку и вам там появлялся нужный кусочек и в студии, и темплейтов, и компиляторов, и еще чего-то, то в .NET, таким образом, сейчас, если вы ставите command-line, только SDK, вы можете добавлять какие-то кусочки через .NET Workload Install и так далее.
4376.98 4385.26 SPEAKER_01 И теперь есть такое понятие, называется Workload Set, то есть множество Workloads, которые вы можете так или иначе как-то контролировать вместе.
4385.26 4394.34 SPEAKER_01 Появился новый ключик .NET Workload --Info, который проверит, что там как с Installation Mode вот этим, как у вас что было поставлено.
4394.34 4402.44 SPEAKER_01 И, соответственно, через .NET Workload Config можно поконфигурировать, что, как, куда обновлять в какой-то момент.
4402.44 4413.22 SPEAKER_01 Так что объединять Workloads в сеты, ну то есть, я так понимаю, что Workloads стало много и, видимо, их теперь пора уже объединять в сеты, чтобы не надо было вначале работать над каким-нибудь новым кусочком, там, не знаю.
4413.22 4421.36 SPEAKER_01 Может, вам нравится просто .NET Workload Install, а если вам нужно там 3-4-5 Workloads, то, может быть, уже проще их объединить в сет.
4421.36 4422.36 SPEAKER_01 Поглядим.
4422.36 4437.18 SPEAKER_01 И также к Workloads добавилась History, мы про это отдельно рассказывали, есть новая команда .NET Workload History, которая показывает, ну, примерно как GetRefLog, что у вас делалось с вашими Workloadами на компе, кто ставил, кто удалял, когда, зачем, почему.
4437.18 4440.62 SPEAKER_01 В общем, полезно, чтобы понять, что произошло.
4440.62 4442.58 SPEAKER_01 И последнее — это контейнеры.
4442.58 4473.42 SPEAKER_01 Работа с контейнерами — это возможность паблишить на небезопасные репозитории, то есть, если вы зачем-то используете то, что они называют Insecure Registries, ну, например, ваш какой-нибудь локально поднятый для теста Registry, то для того, чтобы туда запушить, это теперь можно сделать, но это надо либо правильно сконфигурировать докер, либо надо использовать переменное окружение .NET Container Insecure Registries, и т.д.
4473.42 4483.02 SPEAKER_01 И второе — теперь для паблишинга мы можем какое-то количество настроек задавать через переменное окружение.
4483.02 4488.26 SPEAKER_01 Вернее, теперь мы можем это делать через знакомые нам переменные окружения с префиксом .NET.
4488.26 4497.90 SPEAKER_01 У нас почти все переменные окружения, так или иначе, влияющие на .NET, имели префикс .NET, кроме вот этих вот, которые были для контейнер-паблишинга, и они имели префикс SDK.
4497.90 4507.98 SPEAKER_01 Так вот, SDK теперь объявлен таким устаревшим, он пока еще поддерживается, но все переменные теперь в том числе поднимаются с префиксом .NET, и это то, чем надо пользоваться.
4507.98 4519.70 SPEAKER_01 Вот примерно такое в SDK, не то чтобы сильно много прямо того, что вы, наверное, встретите в каждодневной работе, но вот Terminal Logger очень рекомендую попробовать, посмотреть, как это выглядит, говорят, прямо приятно.
4519.70 4526.70 SPEAKER_01 Я пока еще, кстати, не видел, я на девятом .NET почти ничего и не загрузкал, поэтому надо будет попробовать тоже.
4526.70 4531.22 SPEAKER_01 Он же только в консольке приятный, или он в Visual Studio и вот в Output он тоже будет приятный?
4531.22 4535.18 SPEAKER_01 Потому что я в большинстве случаев вижу именно Visual Studio output.
4535.18 4538.82 SPEAKER_01 И Visual Studio output, и вроде как в консольке тоже должен быть.
4538.82 4544.58 SPEAKER_01 Не, ну в консольке я верю, там само собой всякие коды и все такое, а вот насколько Visual Studio это поддержит, это больше вопрос.
4544.58 4571.70 SPEAKER_01 Ну Visual Studio тоже, надо сказать, параллельно довольно активно развивается, там Мэтс, я так понимаю, активно взялся за всякие полезняшки и мелочевки, в виде прикольных, то что раньше он делал миллионом расширений, он теперь, судя по всему, он и был вроде же в Майкрософте, но теперь они его похоже взяли в основную команду Visual Studio, и он там фигачит в полезняшки внутрь Visual Studio, периодически проводя опросы в Твиттере, типа, а вам как, нравится, так чтобы кнопочка была такая или сякая, и по результатам тут же фигачит.
4571.70 4579.58 SPEAKER_01 До Visual Studio мы еще дойдем и пойдем по порядку, а в следующем у нас в порядке это ISP.NET, не можем же мы его пропустить?
4579.58 4584.30 SPEAKER_01 Ну куда же без ISP.NET, это, наверное, то, ради чего многие программируют в Дотнете?
4584.30 4597.98 SPEAKER_01 Да, наверняка это инструмент, которым пользуются как раз-таки каждый день, естественно, после C#, но, наверное, если мы берем фреймворки, то ISP.NET, скорее всего, завоевал себе самую большую популярность в Дотнете, и может по правду считаться самым главным фреймворком.
4597.98 4607.54 SPEAKER_01 Давайте же посмотрим, что у него такого интересного сделано, что у него интересного добавили в нашем новом Дотнете 9, и, соответственно, в ISP.NET Core 9.
4607.54 4614.86 SPEAKER_01 Прежде всего, улучшили поддержку статикассетов, то есть завели новый метод, который называется MapStaticAsset.
4614.86 4629.62 SPEAKER_01 А этот метод, который призван оптимизировать работу со статическими файлами, статическими какими-то библиотечками, статическими картинками, в общем, все то, что у вас валяется на диске и не является C#-кодом или кодом, который нужно обрабатывать.
4629.62 4638.50 SPEAKER_01 А можно просто отдать браузеру и все, ну, допустим, какие-нибудь картинки, иконки, CSS-стили, HTML-пререндеренные статические странички.
4638.50 4640.02 SPEAKER_01 Это все называется статическими ассетами.
4640.02 4650.82 SPEAKER_01 И поддерживается этот новый метод и эти новые все ресурсы во всех UI-ных фреймворках, а их ни много, ни мало, там три штуки уже насобиралось на ISP.NET.
4650.82 4656.70 SPEAKER_01 Это Blazor, Razorpages, MVC, ну и наверняка много еще других, которые уже не так актуальны.
4656.70 4671.70 SPEAKER_01 И вот этот новый метод, который UseStatic, то есть UseStaticAssets, он призван служить полным аналогом или полной заменой методу UseStaticFiles, который наверняка многие из вас встречали, создавая там свои ISP.NET-приложения.
4671.70 4674.18 SPEAKER_01 Итак, с чем же он лучше?
4674.18 4682.38 SPEAKER_01 Ну, кроме того, что он делает то же самое, что и делает UseStaticFiles, то есть там роутит на всякие статические файлы, он это делает грамотно и красиво.
4682.38 4701.38 SPEAKER_01 Самая главная его фишка в том, что во время компиляции и во время паблиша он анализирует все эти статические файлы и применяет к ним кучу разных оптимизаций, то есть собирая информацию, которая в это время есть об этих ресурсах и потом ее каким-то образом применяя.
4701.38 4709.82 SPEAKER_01 Ну, например, после того, как он собрал эту информацию, например, в билд-тайме он эти ресурсы сжимает.
4709.82 4723.62 SPEAKER_01 И более того, он сжимает быстрым сжатием, когда мы в разработке находимся или когда мы паблишим уже наши финальные бинарники в релиз, он сжимает эти ресурсы максимальным сжатием.
4723.62 4730.30 SPEAKER_01 То есть он вот такой умный, он умеет понимать, для чего он эти сжимает, для дебага просто или уже для продакшна релиза.
4730.30 4750.14 SPEAKER_01 Еще, кроме сжатия, например, он выставляет ETag, то есть он фиксирует, рассчитывает ETag для того, чтобы в ран-тайме его использовать, а это хэш-сумма какого-то конкретного файла, преобразованного в b64 и который отдается в хидерах, когда этот файл запрашивается.
4750.14 4755.74 SPEAKER_01 Нужно это для того, чтобы браузер не перекачивал тот файл, у которого уже совпадает хэш.
4755.74 4766.54 SPEAKER_01 А так как эти ассеты у нас статические, то есть по сути во время жизни приложения они никогда не меняются у нас по определению, то значит во время компиляции мы можем посчитать их хэш и никогда его не пересчитывать.
4766.54 4777.14 SPEAKER_01 И тогда браузер закэширует нам этот ресурс и не будет перезапрашивать его до тех пор, пока мы не выпустим следующий релиз уже с новым содержимым этого статического ассета, что не может не радовать.
4777.14 4799.06 SPEAKER_01 И вот эти вот всякие оптимизации, которые он еще делает, они прежде всего прекрасны для мобильных устройств, например, ну и для других ситуаций, когда у вас очень узкий канал или очень нестабильное соединение, тогда вам очень хорошо сыграет в ваших приложениях вот это и сжатие, и грамотное кэширование, и все такое.
4799.06 4807.66 SPEAKER_01 Далее добавился очень интересный темплейт, который называется .NET MyUI Blazor Hybrid and Web App Solution Template.
4807.66 4810.62 SPEAKER_01 Длинное название, но темплейт действительно прекрасен.
4810.62 4819.74 SPEAKER_01 Прекрасен он тем, что позволяет легко создать маюйное приложение, которое шарит общий код между Blazor.
4819.74 4824.62 SPEAKER_01 То есть вы можете расшарить в MyUI и в Blazor общий код.
4824.62 4834.54 SPEAKER_01 И эта связка хороша тем, что вы можете после такого затаргетить ваше приложение на множество платформ.
4834.54 4840.18 SPEAKER_01 В частности, оно будет поддерживать и Android, и iOS, и Mac, и Windows, и Web, так как там Blazor.
4840.18 4843.78 SPEAKER_01 В общем, все это можно сделать на одном темплейте.
4843.78 4845.46 SPEAKER_01 Это красота.
4845.46 4849.38 SPEAKER_01 Следующие изменения коснулись сигнала R-Hub.
4849.38 4861.18 SPEAKER_01 Теперь HUB может принимать в качестве параметра базовый класс вместо какого-то наследника, который вы обычно передавали в сигнал R-Hub.
4861.18 4865.78 SPEAKER_01 Это стало возможным благодаря полиморфной децерализации.
4865.78 4876.02 SPEAKER_01 То есть теперь HUB понимает, что если ему передался какой-то полиморфный тип, который участвует в децерализации, то он знает, как с ними работать.
4876.02 4883.86 SPEAKER_01 Естественно, вы для этого должны использовать стандартный систем текст JSON, который всю эту штуку поддерживает.
4883.86 4890.38 SPEAKER_01 Дальше еще одно нововведение сигнала R-Hub в том, что он начал поддерживать Trimming и NativeOut.
4890.38 4896.54 SPEAKER_01 Поддерживается эта облицательная связка как для сервера, так и для клиента, то есть для обоих сторон.
4896.54 4900.18 SPEAKER_01 У него сейчас есть, естественно, определенные ограничения.
4900.18 4908.74 SPEAKER_01 Ну, например, поддерживается только JSON протокол, с помощью которого общается в сервере клиент и строгие HUB, пока не поддерживает NativeOut.
4908.74 4911.78 SPEAKER_01 Но все это будет, естественно, в будущем развиваться и дополняться.
4911.78 4916.62 SPEAKER_01 Вообще, поддержка NativeOut в сигнал R довольно интереснейшая.
4916.62 4923.14 SPEAKER_01 Дальше, конечно, мы уже беседовали про эту тему подробнее.
4923.14 4928.90 SPEAKER_01 Это отказ от компонента для генерации Swagger документации.
4928.90 4936.94 SPEAKER_01 Компонента Swagger, который был левосторонний, с какие-то проблемы с автором, терки какие-то были у Microsoft и еще что-то.
4936.94 4943.34 SPEAKER_01 В общем, теперь у нас в Микрософте есть своя собственная поддержка OpenAPI спецификации, она же так же известна как Swagger.
4943.34 4949.66 SPEAKER_01 И теперь этой спецификацией, этими контрактами провязано практически все ISP на приложение.
4949.66 4961.62 SPEAKER_01 Ну, в частности, из коробки, естественно, он умеет генерить обычный OpenAPI документ, которому вы можете прицепить Swagger UI и получить тот же самый интерфейс, который и был везде.
4961.62 4969.50 SPEAKER_01 OpenAPI, естественно, поддерживается и для контроллер бейс наших хендлеров и для минимал API, с этим проблем нет никаких.
4969.50 4977.54 SPEAKER_01 Единственное, что вам нужно, это явно добавить к сервисам addOpenAPI метод и к аппликейшену mapOpenAPI метод.
4977.54 4980.26 SPEAKER_01 Непонятно, почему они это не засунули в стандартную фабрику.
4980.26 4987.50 SPEAKER_01 Ну, наверное, для того, чтобы оно не конфликтовало с той Swagger библиотекой, которую обычно всеми использовали до этого.
4987.50 4995.30 SPEAKER_01 Наверное, после того, как они ее выкорчевают отовсюду, эти штуки должны уйти в какую-нибудь дефолтную фабрику по созданию аппликейшена.
4995.30 5007.64 SPEAKER_01 Ну и так как теперь это всем контролирует Microsoft как бы вот этим OpenAPI спецификацией, то появилось множество полезных штук, раньше которых приходилось делать довольно больными костылями.
5007.64 5012.20 SPEAKER_01 Например, генерация OpenAPI во время билдтайма.
5012.20 5031.86 SPEAKER_01 Для этого есть отдельный пакет, который называется Microsoft extension api-description.server и он позволяет после подключения к вашему приложению во время компиляции создавать JSON-файлик, который складывается прямо рядом с вашим проектом, а уже по этому JSON-файлику есть куча утилит, которые способны вам творить многие разные интересные чудеса.
5031.86 5043.68 SPEAKER_01 Например, генерация HTTP-клайентов, генерация статической документации, верифицировать публичные API, что они там не поменялись или что поменялись, что сменилась версия, в общем, много полезных утилит уже есть.
5043.68 5049.28 SPEAKER_01 Поэтому хорошая штука прямо из коробки, прямо из первой же версии, что не может не радовать.
5049.28 5057.50 SPEAKER_01 На то, что в будущем появится больше и больше интересных утилит, которые целины конкретно на поддержку OpenAPI-спецификации.
5057.50 5067.60 SPEAKER_01 Естественно, это довольно гибкий механизм, поддерживается куча всяких трансформеров, делегатов, опций, настроек, которые позволяют вам ваш документ подогнать под все ваши нужды.
5067.60 5076.00 SPEAKER_01 И встроенная поддержка OpenAPI сразу же прямо из коробки получила поддержку тримминга и native auto.
5076.00 5082.72 SPEAKER_01 Мне кажется, сейчас они просто любую новую фичу, что добавляют, они обязательно подгоняют под необходимость native auto.
5082.72 5085.64 SPEAKER_01 Но это прекрасно, это хорошо, в правильную сторону движемся.
5085.64 5088.96 SPEAKER_01 Итак, что еще интересного?
5088.96 5102.12 SPEAKER_01 Гибрид кэш, тоже у нас по нему был практически целый выпуск, послушайте, посмотрите в подробности, я кратко напомню, что это некая серединка, нет, даже не серединка, а объединилка, объединилка distributed кэша и memory кэша.
5102.12 5107.48 SPEAKER_01 То есть он на себя берет управление вот этими двумя интерфейсиками и упрощает работу между ними.
5107.48 5122.24 SPEAKER_01 Ну, в частности, он на себя берет задачу сериализации, то есть вам уже не нужно думать о том, как здесь сериализовать и где сериализовать те вещи, которые у вас есть, куда их сериализовать, в память или куда-то в сеть, то есть это все оно делает сам.
5122.24 5148.00 SPEAKER_01 И плюс еще хорошую штуку завезли, то есть в этом классе сразу реализовали, это предотвращение параллельной фабрики, то есть когда вы создаете в кэше какой-то элемент, которого там еще не было, у вас этот элемент может создаваться, ну и обычно создается какой-нибудь очень тяжелой асинхронной операцией, ну иначе если бы она не была тяжелой, вряд ли бы ее застанули в кэш.
5148.00 5157.20 SPEAKER_01 И часто бывала такая ситуация, когда два параллельных потока запрашивали тот ключ, которого никогда не было и фабрика запускалась два раза и создавала тяжелый элемент два раза.
5157.20 5161.68 SPEAKER_01 В общем, от этого защита тоже есть в новом классе гибрид кэш.
5161.68 5164.84 SPEAKER_01 Тоже мелочь, она довольно приятная.
5164.84 5179.84 SPEAKER_01 Итак, нововведения еще и улучшения коснулись страницы Unhandled Exceptions, она называется Developer Exception Page, а это как раз страница, которая появляется перед разработчиком, если вдруг случилось какое-то необработанное исключение.
5179.84 5187.52 SPEAKER_01 Ну и естественно работает только в режиме девелопмента, то есть в environment, когда вы разрабатываете приложение, в релизе ее нет.
5187.52 5193.52 SPEAKER_01 И она предоставляет кучу всякой полезной информации, там стэктрейс, реквест, с какими параметрами, хидерами и так далее.
5193.52 5202.52 SPEAKER_01 В общем, ее довольно-таки основательно эту страничку переделали, улучшили, закрасивили, теперь выглядит еще более информативно, еще более читабельно, что тоже прекрасно.
5202.52 5216.00 SPEAKER_01 Улучшился Exception Handler Middleware, теперь он может настраиваться очень гибко и красиво, то есть вы можете сказать какому исключению будет соответствовать какой HTTP статус код, возникший в результате этого исключения.
5216.00 5230.32 SPEAKER_01 Раньше это тоже можно было сделать, но для этого приходилось городить какие-то некрасивые делегаты, а теперь сделан прям такой хороший методок, в котором это все настраивается чисто, семантически, приятно, читаемо, в общем, тоже полезная мелочь, но красивая, от этого не обойтись.
5230.32 5237.12 SPEAKER_01 В общем, вот такие изменения, не то чтобы много, не то чтобы большие, но как-то развивается, как-то движется.
5237.12 5253.96 SPEAKER_01 Ну да, пойдем потихонечку вглубь копать, а то мы все по верхам, да по верхам, но каждый релиз, там же говорят, что тут становится быстрее, выше, сильнее, и производительнее всех прочих языков, и для этого мы должны погрузиться в секцию рантайма.
5253.96 5256.84 SPEAKER_01 Я надеюсь, мы статью Тауба не будем пересказывать?
5256.84 5257.84 SPEAKER_01 Нет.
5257.84 5262.80 SPEAKER_01 У нас, кстати, был хороший выпуск, где была про статью Тауба, если вы хотите чисто перфоманса, вот идите туда, там прям все хорошо.
5262.80 5269.84 SPEAKER_01 Да, правда, по-моему, я там сказал, что я рассказывать ее не буду, читайте сами, но вы все равно послушайте, он, наверное, хороший.
5269.84 5270.84 SPEAKER_01 Я уже не помню.
5270.84 5272.96 SPEAKER_01 Не, ну ты там все равно как бы рассказал краткие вещи.
5272.96 5275.04 SPEAKER_01 Ну да, да, да, я ее просмотрел, все так.
5275.04 5281.72 SPEAKER_01 Тут можно запомнить просто, что с каждым релизом дотнета перфоманс всегда улучшается, увеличивается прямо по сто раз каждый раз.
5281.72 5297.68 SPEAKER_01 Да, ну так давайте посмотрим более детально, что же у нас изменилось в секции рантайма, это не всегда касается конкретно перфоманса, но может касаться всего того, что происходит под капотом того, как выполняется ваша программа.
5297.68 5357.28 SPEAKER_01 Итак, во-первых, тримминг, ну все, что касается, как Толя говорил, почти все так или иначе где-нибудь проходит вокруг да около nativeout, или в каждом кусочке дотнета есть что-то, относящееся к nativeout, и, конечно, в рантайме про него будет много, и в частности, новый атрибут называется FeatureSuiteDefinitionAttribute, а также есть FeatureGuardAttribute, это новые атрибуты, которые можно навесить на нужные вам кусочки кода, то есть на методы, на property, по-моему, которые позволяют сказать, что вот эта функциональность не нужна, грубо говоря, в момент тримминга, то есть если вы знаете, что, например, эта функциональность, скажем, генерирует код в рантайме, а в nativeout-варианте, как мы помним, у нас нет понятия генерации кода, jit.net и все такое, то в этот момент вы можете при сборке указать, что вот эти кусочки кода выпили с помощью специального фичи свитча, и триммер будет знать, что они не нужны, и их аккуратно выкинет, ну и все, что от них зависит.
5357.28 5358.28 SPEAKER_01 Дальше.
5358.28 5395.72 SPEAKER_01 Дальше у нас есть штука под названием unsafe_accessor, это, ну точнее, это атрибут, называется unsafe_accessor_attribute, который позволяет вам описать метод, который будет доступаться к, ну к мемберам ваших типов, то есть в некоторый такой аналог reflection, но поскольку reflection у нас опять же в nativeout нету, то, ну такого полноценного, да, то как раз вот эта штука, она про, вынуждает использовать именно ее, она чуть более оптимально работает, она теперь поддерживает generic параметры.
5395.72 5440.84 SPEAKER_01 Garbage collection, ну мы про него тоже уже много раз говорили, единственное и большое нововведение, это постоянно включенный режим datas, который dynamically adaptable to application size, то есть это штука, которая следит за тем, как вы используете память и адаптирует количество хипов, не как по дефолту в сервере gc у вас количество хипов равно количеству процессоров, а адаптируется динамически в зависимости от нагрузки на ваше приложение, сейчас уже я видел, да, некоторые отзывы на работу этой фичи, мол, проапгрейдили на 9.net, подождали пару-тройку часиков, пока, значит, как бы некоторая статистика накопилась, и вжух, потребление памяти упало там с полутора гигов до 800 метров, и стабильно на нем держится.
5440.84 5448.76 SPEAKER_01 Ну, как бы мелочь, а приятно, почти в два раза снизить потребление памяти на больших масштабах, на больших продуктах может быть вполне полезно.
5448.76 5489.80 SPEAKER_01 С точки зрения секьюрити и безопасности добавилась поддержка Control Flow Enforcement Technology, она включена по дефолту на виндах, она позволяет чуть более защищённо работать, так скажем, с точки зрения всяких атак на перевыполнение буфера и так далее, делается это через, скажем так, тесную кооперацию с железом, потому что это всё называется Hardware Enforced Stack Protection, то есть защита стека на уровне прямо железа, но, как и любая фича варобезопасности, она может влиять на перфоманс, и .NET может стать внезапно медленнее, но зато безопаснее.
5489.80 5498.72 SPEAKER_01 Но если вас не устраивает то, что он стал медленнее, и вы смиритесь, готовы смириться с тем, что он всё ещё станет таким же опасным, как в .NET 8, можно эту фичу отключить.
5498.72 5521.32 SPEAKER_01 В .NET Installs поменялось поведение поиска того, где же, ну сейчас, не так сформулирую, поменялось поведение поиска самого .NET, так скажем, то есть у вас разные тулы имеют возможность искать, где же находится рантайм на самом деле.
5521.32 5535.56 SPEAKER_01 И вот теперь можно указывать какие-то, условно говоря, ваши временные, возможно, с вами сами собранные инсталляции рантайма в качестве тех, которые нужно использовать.
5535.56 5542.72 SPEAKER_01 То есть вы более точно контролируете, какой рантайм-энвайрамент сейчас будет использоваться.
5542.72 5549.96 SPEAKER_01 Ну, конечно же, Performance Improvements, тут довольно большая секция, это оптимизация циклов.
5549.96 5555.64 SPEAKER_01 Там довольно много всего всякого разного, из примеров сейчас скажу.
5555.64 5592.72 SPEAKER_01 Это, например, если вы используете итерацию и итерирование в цикле, и вы пишете классический цикл for int, и от нуля до куда-то, понимая, что int выше крыши, зачем лонгом-то итерироваться вам же int, но на некоторых процессорах, это относится к армам и некоторым архитектурам, эффективнее работать с 8-байтовыми числами, нежели с 4-байтовыми, и рантайм сам поймет, что, типа, о, несмотря на то, что 8 байт больше, чем 4, но выгоднее и быстрее оперировать итерироваться будет с 8-байтовым счетчиком цикла, и, соответственно, будет быстрее.
5592.72 5625.08 SPEAKER_01 Точно так же можно сделать post-indexed addressing на ARM64, так называемый, то есть это когда вы можете доступиться к памяти по, условно говоря, указателю и смещению и одновременно заинкрементировать это самое смещение одной операцией, соответственно, тоже быстрее, короче, такие мелочи, но они в целом потихонечку-потихонечку, где-то тут там полпроцента, здесь полпроцента, в целом как раз и влияют на performance.
5625.08 5629.52 SPEAKER_01 В частности, в циклах, например, JIT научился сам разворачивать итерацию.
5629.52 5649.68 SPEAKER_01 Помните, раньше были наверняка вопросы, ну если не на собеседовании, а на всяких там докладах, периодически встречался вопрос, что будет быстрее от 0 до 100 или от 100 до 0, а до 0 итерироваться в цикле, так вот теперь JIT сам умеет развернуть, если он сможет понять, что вы просто счетчик используете для итерирования без какой-то супер логики внутри.
5649.68 5653.44 SPEAKER_01 Вопрос теперь неактуален в каком-то смысле.
5653.44 5665.84 SPEAKER_01 Inline улучшили, для JIT теперь еще меньше ограничений на то, что он может inline, соответственно, у него больше возможности что-то соптимизировать.
5665.84 5681.72 SPEAKER_01 Profile Guided Optimization тоже улучшили, проверяются теперь type-чеки, то есть type-чеки — это когда вы пишете if какой-нибудь typeof что-нибудь равно-равно тому, то пошли туда-то, а если вот таком-то, то пошли туда-то.
5681.72 5702.76 SPEAKER_01 По большому счету это в некотором смысле тоже статистика, и если вы… Profile Guided Optimization может вам сказать, а какой обычный тип там приходит, то вы такие бранчи условно говоря тоже можете более эффективно перераспределить и ходить в них более оптимальным способом, а не каждый раз дергать именно честный type-чек.
5702.76 5729.92 SPEAKER_01 ARM64 Викторизация, ARM64 Генерация более оптимального кода, более быстрые исключения, полностью убрали поддержку Windows Structured Exception Handling, стало существенно быстрее, но если вам зачем-то нужна поддержка Windows Structured Exception Handlers, вероятно это полезно в каких-нибудь interoperability сценариях, но я не могу такого сходу придумать, то можно опять же вернуть старое поведение, если его еще не надо, но новые исключения быстрее.
5729.92 5738.20 SPEAKER_01 JIT научился немножко менять порядок кода, в чем фишка JIT-а и в чем задача JIT-а.
5738.20 5758.52 SPEAKER_01 Задача JIT-а, когда он комплирует ваш метод, это сделать как можно более линейный код в каком-то смысле, потому что чем меньше бранчей, тем меньше вероятность, что будет какой-нибудь branch mispredict, и наверное это хорошая юристика, чтобы попытаться генерить код, чтобы наиболее часто выполняемый сценарий задействовал наименьшее количество бранчей.
5758.52 5780.44 SPEAKER_01 Ну вот и теперь тот код, который генерится, JIT стал умнее, он теперь более, скажем так, с большим пониманием может двигать блоки между собой, таскать с собой дату для PGO, и в итоге еще более оптимально располагать код в ваших методах.
5780.44 5809.24 SPEAKER_01 Дальше еще там пачка оптимизаций про всякий address exposure, это когда JIT более лучше понимает, в какой момент переменная больше не используется, и можно, соответственно, перестать использовать какой-нибудь регистр или место памяти под нее, перевязать под другую переменную, всякие разные hardware интенсики, а в x10 это все же не интересно, не то что не интересно, это уже совсем такие детали.
5809.24 5820.20 SPEAKER_01 Вот и, пожалуй, последнее из этого списка, это штука, которая называется Object Stack Allocation, и вот это тоже интересный момент.
5820.20 5834.72 SPEAKER_01 Это на самом деле первые шаги .NET в часть под названием "А давайте мы будем избавляться от боксинга там, где мы это можем сделать дешево", точнее, не то что дешево, а там, где мы это можем сделать.
5834.72 5891.80 SPEAKER_01 Сейчас, если .NET понимает, что, например, у вас есть какой-нибудь, вы, например, в коде напишите newInteger, ну, точнее, newInteger, в смысле newObject от единички, новый объект, в который вы положите единичку, просто, то есть забоксите, по сути, примитив, и потом в этом же методе вы его используете, и, выйдя из метода, больше вы его никуда не вернете, то есть он точно может доказать, грубо говоря, сам себе, что объект никогда не покинет метод, то не нужно лоцировать объект на heap и тратить потом ресурсы garbage collector, несмотря на то, что мы знаем, что такие короткоживущие объекты - это расплюнуть для garbage collector, garbage collector у нас заточен для уничтожения таких вот объектов в нулевом поколении, но все равно, чем меньше мы таких объектов зададим, тем лучше, и поэтому если есть возможность такие вот забокшенные объекты создавать прямо на стэке, то мы такое можем сделать.
5891.80 5902.08 SPEAKER_01 Кроме того, это позволяет немножко с инлайнингом побаловаться, и, в общем, вэльютипы поменьше свидите на хипе, что приятно.
5902.08 5909.20 SPEAKER_01 А есть ли какая-нибудь причина не выдавать это предупреждением компилятора, ну типа ты криворукий урод, иди сначала документацию почитать?
5909.20 5925.00 SPEAKER_01 На тему того, что некоторые вещи могут неявно, то есть у тебя может быть, допустим, какой-нибудь контракт, и он понимает только обжекты, ну библиотека такая, и тебе туда нужно передать, не знаю, чиселку, вот, ну что поделаешь.
5925.00 5927.32 SPEAKER_01 И тогда он через контракт это все поймет, да?
5927.32 5928.32 SPEAKER_01 Да.
5928.32 5930.68 SPEAKER_01 То есть он между вызовами нескольких методов понимает вот этот боксинг.
5930.68 5942.80 SPEAKER_01 Так а тебе даже, ну тебе даже не между вызовами, то есть смотри, у тебя, например, ну не знаю, давай представим какой-нибудь довольно простой случай, у тебя есть какая-нибудь библиотека логинга, ну сейчас таких нету, ну да, наверное, есть.
5942.80 5951.48 SPEAKER_01 Допустим, библиотека логинга, где у тебя вот эти вот параметры, после основного строчки, да, они все обжекты, ну только обжекты, допустим, не дженерики, а обжекты.
5951.48 5953.08 SPEAKER_01 Ну, да-да, в принципе, нормальная ситуация.
5953.08 5974.88 SPEAKER_01 То есть ты завел какую-нибудь локальную переменную, чиселку, и вызвал вот такое вот логирование, да, хочу записать, значение этой переменной равно там фигурной скобочке, да, и потом запятая, и вот это вот переменная, точка с запятой, потом ты с этой переменной что-то сделал, не знаю, там ее возвел в квадрат, снова записал в логин, уже значение квадрата, да, и потом вышел из метода, вот все, что делал этот метод, или даже вернул эту переменную, окей, но в виде числа.
5974.88 6009.00 SPEAKER_01 То есть у тебя оно залоцировалось на стейке как число, в нормальной жизни дальше бы оно забоксилось на heap, передалось бы в этот метод логинга, вышло бы из этого метода логинга, после чего garbage collector его может уже собирать, потому что понятно, известно, что дальше этот heap-объект не используется, JIT умеет генерить, на самом деле, информацию для garbage collector, что в этом методе, далее этой строки, этот объект уже не используется, можно собирать, если garbage collector в этот момент сработает, он в принципе соберет этот объект.
6009.00 6030.00 SPEAKER_01 Дальше ты, не знаю, возвел в квадрат, снова завел объект на heap, уже в котором содержимое квадрата, да, а на стейке лежит переменная int, которая содержит значение этого квадрата, снова передал его в метод, снова вышел из метода, больше этот объект не нужен, и ты вышел из метода, вернув нормальное со стейка, ну, обычное значение, которое там лежит и так, в value-типе.
6030.00 6038.12 SPEAKER_01 Вот такой сценарий, по идее, современный 9.tut.net должен полностью сделать так, чтобы не было аллокаций на heap.
6038.12 6041.76 SPEAKER_01 Да, понятно, тогда это круто, да, это хорошо.
6041.76 6042.76 SPEAKER_01 Вот.
6042.76 6071.44 SPEAKER_01 То есть вот именно такие мелкие, не то, что ты сознательно обернул вот boxing, это тебе, ну, на самом деле, тот же райдер или какой-нибудь там в студии, по-моему, аналайзеры есть, он тебе скажет, что тут как бы это чё-то как бы не то, и, наверное, у тебя здесь heap allocation, ну, ты как бы, хорошо, если это твой код, ты можешь поменять, а если код не твой, ты не можешь поменять, но это хороший способ попробовать в этих моментах тоже какой-то performance выжать из этих моментов и поработать чуть-чуть побыстрее.
6071.44 6083.32 SPEAKER_01 Ну, и действительно, бывают места, где на дженериках всё не напишешь, и приходится всё писать всё-таки в таком обобщенном виде, и, ну, тоже получить performance в этом месте будет нормально.
6083.32 6093.44 SPEAKER_01 Наверное, это было бы почти всё про runtime, если бы не одно но, но это то, что я уже и Анатолий несколько раз упоминали, это native auth.
6093.44 6126.36 SPEAKER_01 Native auth у нас сейчас тоже проглядывается почти во всех частях новостей, которые мы видим про .NET 9, поэтому не могли бы идти, конечно же, с вниманием native auth, и рассказать про native auth мы пригласили Андрея Порожнякова, который делал как раз-таки доклад про эту технологию на относительно недавно прошедшем .NEXT, и он наверняка, как никто другой, хорошо знает и следит, что же там происходило в .NET 9 по поводу native auth, и что нового мы получили по сравнению с прошлой, или даже, может быть, хотя бы осенней версией.
6126.36 6127.36 SPEAKER_01 Андрей, привет.
6127.36 6128.36 UNKNOWN Да, привет.
6128.36 6133.92 SPEAKER_01 Я действительно немножечко слежу за тем, что там происходит.
6133.92 6151.76 SPEAKER_01 Ну, собственно, если так вкратце рассказать, то касаемо безопасности, касаемо производительности, то в целом .NET 9 сильно сконцентрировано и на безопасности и на производительности, и не обошло это стороной native auth.
6151.76 6180.60 SPEAKER_01 Собственно говоря, у нас появился инлайнинг для локальных потоков, это что касается производительности, то есть native auth стал поддерживать инлайнинг для локальных потоков в Windows x64, в Linux x64 и в Linux ARM x64, то есть раньше чтобы получить доступ к локальным потокам в программах опубликованных для native auth, нам требовался 3-х разрядный компилятор JIT для вызова среды выполнения.
6180.60 6193.28 SPEAKER_01 То есть как бы сейчас это и требуется, то есть компилятор может устраивать эти вызовы, что называется, напрямую, и это приводит к генерации гораздо меньшего числа инструкций для доступа к данным.
6193.28 6271.36 SPEAKER_01 Ну, собственно, это коснется в основном статических членов. Ну и по безопасности тоже native auth, у нас появилась компиляция для безопасных исполняемых файлов, то есть в плане безопасности тоже чуть-чуть улучшения определенные есть. Я здесь совсем какие-то подкапотные дебри не буду залазить, можно надолго такую тему растянуть. Но вот, собственно, определенные плюсы по безопасности производительности мы получили. Ну, смотри, да, производительность, мы тут уже в секции про рантайм много говорим про производительность. Безопасность мы тоже упоминали, и понятно, что много уже релизов подряд, это все основной может быть даже лейтмотив релизов дотнета, про то, что мы еще быстрее, мы еще лучше, мы еще безопаснее, но а что есть такое, что обычный программист может просто потрогать, вообще говоря, руками. То есть производительность как бы тоже можно потрогать руками, но то, с чем он может сталкивается в какой-то плюс-минус ежедневной работе, и где native auth теперь можно поприменять как-то более на практике, что ли.
6271.36 6294.56 SPEAKER_01 Да, классный вопрос, я как раз заготовил эти темы напоследок. Есть поддержка SignalR, она появилась в 9 дотнете, то есть теперь SignalR поддерживает тримминг и поддерживает native auth. Вот примерчик можно посмотреть, нагуглить, потрогать руками, то есть, собственно говоря, у нас практически полноценная поддержка SignalR у нас появилась.
6294.56 6374.92 SPEAKER_01 И это еще не все, есть гораздо более приятная новость, что у нас появилась поддержка EF Core. Вот, это прям большая победа, я считаю. Долго висел ишью на гитхабе, то есть во время выхода, при релизных версиях 9 дотнета его уже закрыли, его уже смерзли, вот, то есть сейчас он полноценно EF Core поддерживается, и сделано это за счет, ну там никакой магии нет, сделано за счет интерцепторов, то есть у нас получается для поддержки NQ запросов, когда мы отпубликовываем приложение native auth, статический анализ определяет все запросы NQ, EF, вот, и создает интерцепторы для каждого запроса, которые уже содержат, ну, код выполнения, там, каждый перехватчик содержит стиль запрос и какой-то оптимизированный код для того, чтобы материализовывать результаты, то есть для того, чтобы объекты из базы данных превращать в те объекты, с которыми работает наш код. Вот, ну и, собственно, это, во-первых, мы, да, получили поддержку EF Core, во-вторых, это, в принципе, сокращает время запуска приложения, то есть полезно такие вещи иметь, так как компиляция запросов уже не в рантайме происходит, а в compile-time, вот, так что да, вот такие результаты, я считаю.
6374.92 6395.44 SPEAKER_01 Интересно, а слушай, не помнишь, на вскидку, там же наверняка поддержан далеко не вообще все-все-все, что EF Core позволяет, или там действительно прям просто все то, что обычно EF Core делает в рантайме, вынесли в compile-time и достаточно? Там есть какие-нибудь ограничения?
6395.44 6398.68 SPEAKER_01 Хороший вопрос, я искал, какие там есть ограничения.
6398.68 6439.44 SPEAKER_01 На самом деле, я еще прям вот капитально, высучив рукава, по локте туда не закопался, не наэкспериментировался я сейчас с EF Core, Microsoft вообще писал, что полноценная поддержка будет уже, ну, они сейчас обещают в десятом году. Вот, то есть сейчас это такая экспериментальная версия, но я не нашел ни одного подтвержденного какого-то исключения, то есть якобы все должно работать, но экспериментально. Вот, насколько это действительно так, я, положа руку на сердце, сейчас сказать не могу, но я пока не нашел каких-то исключений. Так что вот, может быть кто-нибудь найдет, напишет.
6439.44 6516.40 SPEAKER_01 Ну, наверняка появятся статьи, которые мы, конечно же, рассмотрим в подкасте и обсудим, если они будут достойны этого. В целом, понятно, есть ли еще что добавить или, наверное, это основные моменты по Native Out? Ну, это основные моменты по поводу того, что добавили, да. Наверное, могу добавить, что еще ждем. Ждем мы поддержку MVC и поддержку Blazor сервера, они пока не поддерживаются, может быть это произойдет в будущем, может быть произойдет в не очень далеком, может быть в очень далеком. Ну, в общем, пока не поддерживаются, пока никакой информации нет. Вот, так что, да, на этом, наверное, у меня все. Отлично, спасибо тебе огромное. Да, спасибо, что позвали, пока. Пока. Как сказал Андрей, как ты слышал, Native Out - это что-то, что, конечно, где-то там глубоко внутри и многого ты не видишь того, как оно работает. Ну, ты либо пользуешься этим, либо не пользуешься, но Native Out сам по себе вносит довольно много ограничений, и вот то, что Андрей важное сказал, это EF Core. У нас наконец-таки EF Core стал поддерживать Native Out и, наверное, это как раз хороший повод перейти к EF Core.
6516.40 6548.68 SPEAKER_01 Да, давайте как раз про него и проговорим. Ну, действительно, Native Out - это, наверное, самая главная новость, которая появилась в EF Core, но тут нужно еще раз предупредить и сразу сказать, что это очень экспериментальное начало, это очень экспериментальная поддержка, поэтому чтобы посмотреть - да, попробовать - да, но ни в коем случае не тащите это в продакшн. Авторы обещают к EF 10 уже наладить какой-то механизм, который уже будет не страшно потащить в продакшн. А сейчас это только начало.
6548.68 6562.72 SPEAKER_01 Ну, я вообще сам факт хочу подчеркнуть, почему это такой бигдил большой, да, и почему вообще уже есть Native Out практически во всем дотнете много лет, он уже есть в ISP и так далее, а в EF появляется только сейчас.
6562.72 6627.28 SPEAKER_01 Ну, потому что, по сути, вам нужно взять все линку запроса, которые есть в вашем приложении и перевести их в SQL. И все это сделать в дизайн тайме, то есть, по сути, не запуская ваше приложение. То есть, ваше приложение даже может не компилиться, а готовый SQL запрос уже надо сделать. Там не только SQL запросы, но еще оптимальный код для того, чтобы материализовать все результаты, которые придут к вам из вас уже базовым данных, смапить их в дотнет-объекты. Ну, то есть, кажется, что если мы говорим про какую-то историю про EPIC, который называется source-генераторы, то вот это его кульминация. То есть, кульминация, когда мы изначально начинаем source-генерировать такие сложные штуки, как, например, Entity Framework, который разбросал все свои SQL-запросы, у которого есть богатая поддержка linked-to-object, и этот linked-to-object, он там коллекционировался, собирался десятилетия, чтобы его так хорошо поддержать, включая там большой EF, как только начинался. А теперь то же самое сделать нужно, вот этот linked-to-object, только Roslyn-to-object. То есть, мы должны Roslyn-овское дерево в генераторах собрать и из него каким-то образом сгенерить SQL-запросы.
6627.28 6634.28 SPEAKER_01 Ну, то есть, это прямо, вот кажется, достойно отдельного фреймворка, которое здесь пытается рядом появиться.
6634.28 6712.62 SPEAKER_01 Поэтому тема интересная, тема классная, я думаю, в следующем году по ней новости еще появятся, поэтому будем обязательно следить. Что же еще у нас появилось в Entity Framework такого интересненького? Ну, во-первых, более продвинутая поддержка комплекс-тайпов. Теперь комплекс-тайпы можно использовать в GroupBy и также в ExecuteUpdate. В общем, два этих метода тоже научились принимать комплекс-тайпы. Еще одна интересная штучка, опять же, нужно сказать, что команда Entity Framework тоже выпускает огромное количество нововведений, большинство из них мелкие, и у них прямо всегда есть такая надпись, что типа, если вы хотите подробнее, то вот вам ссылочка, и там больше сотни всяких там коммитов на GitHub, поэтому смотрите, как хотите. Я же выбрал самые интересные, самые большие и самые полезные с практической точки вещи. И вот этот пункт, в принципе, мне кажется, очень полезный, потому что в своем коде я сталкиваюсь с ним довольно часто. Это параметризированный примитивный коллекции. О чем речь? Довольно часто к нам из базы данных нужно вытащить какую-то сущность или сущности, которая соответствует определенному условию Contains. Ну, допустим, вам передали список ролей, и говорят, достань мне всех пользователей, у которых есть вот эта роль, то есть, который из Contains список вот этих ролей.
6712.62 6757.94 SPEAKER_01 И, опять же, линку метод Contains хорошо транспилируется в SQL уже во всех провайдерах, во всех версиях. Но как он это делает? Он передает весь ваш массив с вашими константами, по сути, с этими названиями ролей, он их передает в качестве параметра в SQL, а потом к этим параметрам доступается с помощью OpenJSON. То есть, по сути, он передает их в виде JSON-массива, потом deserializует JSON и вызывает уже непосредственно SQL-оператор IN, который ищет уже в тех элементах, которые десериализовались из этого JSON. Это, в принципе, работает, но каждый, кто писал SQL ручками, сразу спросит, а зачем так сложно-то?
6757.94 6836.08 SPEAKER_01 Почему нельзя просто сделать IN и перечислить константы в виде параметра? Вообще, эта сложность обоснована тем, что все параметры Entity Framework передает через специальный синтаксис параметров для того, чтобы избежать всяких SQL-инъекций. Но если вы уверены в своих ваших параметрах, если вы их уже каким-то образом проверили, ну, допустим, если у вас там приходит массив INT, допустим, а не строк, ну, то есть те вещи, с которыми очень сложно какой-то injection сделать, то вы можете специально сказать теперь Entity Framework, что товарищ Entity Framework, у меня здесь массив констант, я точно знаю, что они хорошие, через параметры их передавать не надо, передавай их как в виде константа. И тогда код, который будет сгенерирован, будет такой, как вы написали бы это руками. WHERE IN и просто массив констант, как он есть в виде SQL. Это очень прекрасная оптимизация, она может сократить время запросов просто в разы, и это довольно часто и запросы, поэтому и полезно. К сожалению, лишь к счастью, никакого магического перехода на такую конструкцию не будет, потому что, опять же, параметры все-таки могут быть опасными, поэтому вам нужно явно сказать Entity Framework в тех местах, где вы хотите использовать это в виде констант, то есть параметры в виде констант, вы должны ему сообщить.
6836.08 6843.60 SPEAKER_01 Также появился и обратный метод, то есть там, где вы обычно передавали константы, вы можете сказать наоборот, нет, чувак, здесь вот это сделай мне в виде параметров.
6843.60 6884.20 SPEAKER_01 Это тоже может быть иногда полезно, потому что позволяет анализатору запроса подстроить оптимизированный запрос под тот шаблон, который вы передали. И иногда полезно играться вот этими параметрами, то есть иногда полезно в оптимизированный шаблон вгонять эти константы, а иногда полезно выгонять их в параметры. Все это зависит от вашего конкретного юзкейса. А если вы понимаете, что вы делаете, то обязательно поиграйтесь. Ну и естественно два этих флажка теперь можно включить на уровне всего дата контекста, то есть появилась специальная опция, которая позволяет задать поведение по умолчанию, если вы четко знаете, что в вашей программе нужны только константы, пожалуйста, можете включить это везде.
6884.20 6970.76 SPEAKER_01 Погнали дальше. Еще одно немаловажное изменение, которое в принципе может сломать ваши запросы, поэтому здесь тоже повнимательнее, это семантическое сравнивание с нулем, с null'ом, если быть честным. В чем собственно проблема? Проблема заключается в том, что нулябельная алгебра в C# и в SQL'е отличаются. То есть когда мы сравниваем null с null'ом в C# или null с объектом в C#, это не то же самое, когда мы сравниваем null'ы в SQL'е. Тем более в SQL'е это там еще настраивается в зависимости от различных анси-флажков, то есть у каждой базы, в зависимости от версии и так далее, разные дефолты могут быть. И вот эта логика отличалась. К чему это приводило? А приводило это к тому, что когда вы, например, запрашивали те же самые предикаты, но натравливали их на источник с провайдером link to object, вам вполне мог вернуться не тот результат, который вернется из интерпретации того же самого expression в базу данных. Это, например, часто могло стрельнуть в каких-нибудь тестовых кейсах, когда вы в продакшене ходите в настоящую базу, а в тестах своих ходите в какой-нибудь массив памяти. И там у вас применяется link to object к тому же самому предикату, а в базу, допустим, он транспилируется уже в непосредственную SQL. И у вас будут разные результаты на продакшене и в тестах, что вообще не должно быть, как бы не должно существовать.
6970.76 6987.68 SPEAKER_01 Но это еще не самое страшное, потому что вроде Microsoft рекомендует, если вы проверяете данные, то не мапьте их в память, а ходите к нормальному провайдеру. Но чего он не предупреждает, это в том, что как раз таки поведение может отличаться между разными провайдерами.
6987.68 7000.44 SPEAKER_01 Один и тот же предикат может по-разному выполняться в SQL-сервере, в SQLite, в PostgreSQL. И более того, эти PostgreSQL можно настроить таким образом, что в одном PostgreSQL он выполняется по одному, а в другом PostgreSQL он выполняется по-другому.
7000.44 7004.12 SPEAKER_01 В общем, тоже здесь находится большая-большая проблема.
7004.12 7039.00 SPEAKER_01 Что же произошло теперь? В новом entity framework была переделана логика сравнивания с null. И теперь она соответствует тому, как в C# это реализовано, в .NET это реализовано. Поэтому сейчас в EVE 9 и linq2object и различные SQL-провайдеры выдают консистентный результат на одном и том же предикате, что тоже предсказуемо, это прекрасно и хорошо. Так, еще одно большое нововведение, которое хотелось бы отметить, это введение concurrent миграции.
7039.00 7148.44 SPEAKER_01 Напомню, что у entity framework есть механизм миграций, который позволяет вам версионировать вашу схему данных и позволяет накатывать эти миграции с каждым новым выпуском вашего приложения. И эти миграции должны накатываться в одном единственном экземпляре. Допустим, если вы поднимаете две поды с вашим приложением, то обе эти поды не могут параллельно пойти и накатить миграцию. Иначе это может все привести к испорчиванию данных, испорчиванию схемы базы данных и, в общем случае, к непредсказуемому результату, поэтому лучше так не делать. Теперь, перед тем, как накатить миграцию, механизм миграции берет лог на базе данных, накатывает ее и лог снимает. Ну блин, как в принципе оно и должно было быть, вообще непонятно, зачем они такую глупость придумали, изначально так и не сделали. Эксклюзивный лог к базе данных опускается просто так, как миграция была накачана. Рекомендуемый все-таки способ Microsoft всегда был и остается, в принципе, несмотря на это нововведение, чтобы вы не накатывали миграцию из вашего приложения, то есть из вот этих двух поднятых под миграцию накатывать на самом деле не нужно. Что же нужно сделать? Нужно во время деплоя вашего приложения отдельным шагом накатить миграцию и потом уже отдельными шагами запускать 2, 3, 10 под вашего приложения, которые уже должны рассчитывать на новую миграцию. Из старта приложения все еще рекомендуется этого не делать. Но бывают ситуации, когда это не всегда возможно. Ну, в частности, например, когда мы говорим про Aspire. И товарищ Aspire тебе может вполне несколько под поднять, и как такого процесса деплоя в Aspire у нас не существует. У нас есть просто поднятие всех проектов в Aspire. В общем, и там этот механизм concurrent миграции может хорошо пригодиться. Ну и, конечно, я лукавлю, когда говорю, что непонятно, почему они сразу не сделали.
7148.44 7178.36 SPEAKER_01 Сразу не сделали, потому что не все провайдеры поддерживают в базе данных такой своеобразный эксклюзивный лог на базу данных. Например, SQLite. Если вы вдруг по каким-то причинам в SQLite будете делать параллельную миграцию, то там Entity Framework создат специальную табличку, которая проэмулирует некий лог. Табличку, в которой будет вставлять запись и перед миграцией будет проверять, есть ли там запись, то есть существует ли параллельная какая-то миграция, которая сейчас выполняется. С этим тоже есть сложности, баги.
7178.36 7297.48 SPEAKER_01 Поэтому если вдруг вы настолько извращенец, что хотите мигрировать SQLite параллельно, то обязательно почитайте документацию. Там есть примерчики, есть механизмы, как с этими проблемами бороться. В общем, есть еще целая сотня нововведений в Entity Framework, но я выделил самое интересное. Если вам интересны еще подробности какие-то другие, то смело обращайтесь к статье, там отлично все описано. Да, Entity Framework действительно знаменит своими довольно большими чуть-чуть логами и практически полным отсутствием статей о том, что же там за релижион, так что изучайте внимательно, пробуйте и тестируйте. А мы пойдем дальше. Мы же упоминали сегодня чуть-чуть Visual Studio, и мне кажется, мы совершенно недавно писали выпуск про то, что же было выпущено в студии 17.12, которая очередная полностью вышла, релизная и так далее. Она все еще Visual Studio 2022, версия 17.12, хотя на дворе уже 2024 год. Мне даже интересно, когда же поменяется название года. Или хотя бы даже название, которое 18.что-нибудь будет. Пока у нас только минорные версии поменяются. Пока что-то даже не планируют, кажется. Да. Но давайте быстренько, очень быстро пробежимся, что же у нас такого есть, так сказать, в версии, что будет полезно. А именно, как обычно, все это разделено на разные части. IDE часть, соответственно, всякой разной, скажем так, украшалки, интерфейс, работа с сертификатами, security и прочее. Я особо не буду углубляться, клауд тоже не буду углубляться. Десктопная разработка WinUI Support, если это кому-то интересно. Со шттп-файлами, кстати, появилась поддержка всяких разных переменных.
7297.48 7330.00 SPEAKER_01 Мы, по-моему, про это говорили уже. А также появилась поддержка Shared Environment, так называемого. То есть можно шарить некоторые перемены между Environment на шттп-файлы. Напомню, это способ в текстовых файлах хранить запросики по аналогии с каким-нибудь постманом, который позволяет вам запускать, выполнять эти самые запросы. В Дотнете, понятно, та самая поддержка в Дотнете девятого. Аудит Nuget'ов, транзитивный, который появился и в, собственно, самом Nuget-клиенте, так скажем.
7330.00 7358.88 SPEAKER_01 В секции Productivity обычно она, наряду с Debugging и Diagnostics, самая такая интересная. Это копирование ошибок из Error-листа. Понятно, что go to line anywhere. Code search можно теперь куда-нибудь задокать, как вы хотите. Можно обновлять Find Results. Вот это, кстати, интересно бывает, потому что я, например, иногда Find Results, то есть ищу что-нибудь, чтобы, например, там поправить все вхождения чего-либо.
7358.88 7369.36 SPEAKER_01 В строках, еще в чем-то. И понятно, что когда я там поправил половинку, хотелось бы увидеть какой-нибудь обновленный результат, чтобы видеть, во-первых, что там теперь нашлось поменьше вот этого всего.
7369.36 7389.84 SPEAKER_01 Это бывает полезно. Почему-то они очень много внимания уделяли горизонтальному скроллбару. Прямо про это было несколько чуть ли не статей, ну, по крайней мере, твиттер-постов точно. Но, по-моему, даже статья какая-то была про то, что как вот переделали горизонтальный скроллбар, чтобы он таки был нормально виден, нормально скроллил. У кого-то это, видимо, большая… Он теперь что, лучше скроллится или что? Более горизонтальный?
7389.84 7479.48 SPEAKER_01 Он, да. Раньше был горизонт завален, наверное, а сейчас видимо вспоминается, знаешь, вот эти вот в твиттере периодически пробегают, там конкурс на худший дизайн регулятора громкости, вот это вот все такое. Короче, нет, там проблема в том, что вот этот вот тулбарчик, ну, это не тулбарчик, как это называется, короче, область, которая внизу справа, она настолько захламляется всякими там иконками, статусами бранчей и еще какой-то фигней, что у тебя места под горизонтальный скроллбар почти не остается. Вот, и они были вынуждены как-то там все переработать, чтобы наконец-то, чтобы таки этот скроллбар был виден. Вот, видимо, очень много приложили усилий, потому что прям очень пиарили это дело. Ну, понятно, что в Copilot довольно много изменений, всякие Smart Variable Inspection, IEnumerable Visualizer, тот самый, про который мы много говорили уже давно, Better Completions, ну и вот это все. Поэтому, в общем, если пользуетесь Copilot'ом, наверное, стало лучше. В дебаггинге показываются теперь возвращаемые значения. Это на самом деле одна из, ну я не знаю, суперполезных вещей, которые очень часто помогают в дебаггинге, то есть если вы, допустим, возвращаете значение, ну, допустим, у вас есть метод, в котором написано Return вызов другого метода, который не присылается ни в какую переменную, то на самом деле посмотреть, кто вернул вот тот метод, который вы только что вызвали, когда вы нажали Return, на самом деле иногда довольно проблематично.
7479.48 7483.36 SPEAKER_01 Вот теперь будет хорошо работать это дело.
7483.36 7543.44 SPEAKER_01 Breakpoint группы, теперь можно экспортировать, не знаю, кому это может быть надо, поделиться с соседом набором Breakpoint'ов, ну, может быть. Непонятно. Так, улучшили дебаггинг Blazor в WebAssembly, добавили метр гистограмм в профайлер, но это мы тоже все это обсуждали, Memory Use Analyze по мере работы программы, то есть можно, соответственно, выбрать и сравнить, как использовалась память в разные моменты времени, ну и они потихонечку дальше полируют GIT, то есть всякие копирования GIT-линков, поддержка нескольких репозиториев для GitHub и Azure DevOps, можно там pull-requests создавать, ну, в общем, всячески, так сказать, улучшают наш опыт с работой с GIT. И, естественно, вместе с релизом, как обычно, вместе с официальным анонсом релиза версии 17.12 вышло 17.13 Preview 1. Здесь тоже уже появилось некоторое количество изменений и улучшений.
7543.44 7585.68 SPEAKER_01 В разделе Productivity можно задавать теперь в настройках умолчательную кодировку файла, почему это нельзя сделать всегда UTF-8, непонятно, ну, может быть, в каких-то регионах это полезно, что бы там, не знаю. Давай хранить все иходники по дефолту в CoI-8. Вот теперь можно такое сделать. Можно настроить, если у вас включен режим переноса слов, то можно настроить, насколько далеко будет отступ, ну, как это, красная строка, да, первой строчки. В поиске показываются последние файлы в начале, это полезно, потому что обычно вы, скорее всего, будете пытаться найти то, что вы недавно видели.
7585.68 7635.48 SPEAKER_01 GitHub Copilot добавил, на самом деле, полезную штуку, я, по крайней мере, видел это в демо-виде, и действительно прикольно, когда вы смотрите на экран Parallel Stacks, а это такой режим дебаггера, когда вы видите все стэки одновременно, когда у вас очень много потоков, на самом деле там довольно сложно найти, это студии их как-то немножко объединяет, но это все равно не всегда помогает, и вот здесь он, GitHub Copilot, анализируя стэки ваших потоков, пытается туда вписать какое-то, ну, так скажем, человеческое объяснение, что группа потоков делает, выглядит как бы прикольно на самом деле, удобнее, чем самому выискивать, ага, это, значит, там, не знаю, garbage collector thread, понятно, потому что там где-то есть какой-нибудь garbage collector, вначале это finalizer thread, ну, понятно, что это удобно.
7635.48 7659.00 SPEAKER_01 В дебаггинге появился в INumber в визуалайзере поддержка синтаксиса, то есть я напомню, что INumber в визуалайзере такая штука, где вы можете открыть ваш INumber в специальном окошечке, и потом туда дописывать поверх линкью запроса к этому INumber, они будут выполняться, то есть там что-нибудь поселить, что-нибудь пофильтровать, вот там теперь поддерживается подсветка синтаксиса.
7659.00 7670.08 SPEAKER_01 В GT можно добавлять комменты, pull request, это раньше нельзя было, прикольно, мне казалось, что это давно можно было, но нельзя.
7670.08 7679.80 SPEAKER_01 Если вы меняете тему в IDE, то ваш выбранный шрифт остается неизменным теперь, то есть тема теперь не завязана на шрифт.
7679.80 7686.76 SPEAKER_01 Это на самом деле прикольно, потому что если вы пользуетесь каким-то конкретным шрифтом, ну, полезно, чтобы он оставался ровно вашим.
7686.76 7705.12 SPEAKER_01 Ну, для Клауда понятно, .NET Aspire, там вот это все, поддержка настройки запуска докера, поддержка Docker Compose Scale option, то есть теперь можно в настройках через IDE задавать скейлинг, который задается иначе в Docker Compose параметром scale.
7705.12 7709.20 SPEAKER_01 Ну и там для Веба немножко вокруг Razor изменения UI.
7709.20 7722.40 SPEAKER_01 В общем-то все, то есть пока не то, чтобы прям что-то супер прорывное, но интересное-интересное изменение, потихонечку, первое превью, оно всегда такое, ни о чем, как мне кажется.
7722.40 7726.68 SPEAKER_01 А тут даже что-то такое, может быть, даже полезное приехало.
7726.68 7730.08 SPEAKER_01 Так что нормальненько, нормальненько, будем пользоваться.
7730.08 7737.60 SPEAKER_01 Да, мне тоже нравится, как студия всегда эволюционирует, в принципе, хорошие вещи вносит, не то чтобы семимильными шагами, но довольно удобно для работы.
7737.60 7755.08 SPEAKER_01 Ну, как я говорю, мне кажется, там основной драйвер, это MadSkillessness, который вот эту какую-то, ну, вернее как, там кажется, что основная команда пилит, скажем так, вот эти вот, видимо, дорогие, большие и сложные фичи, как то интеграция копайлота, гита, и вот этого всего.
7755.08 7763.80 SPEAKER_01 А вот всякую мелочевку, типа, тут шрифт сохранить, тут мы теперь копировать файлы можем между студиями, а вот тут, смотрите, аутпут, интересно, чуть-чуть более прикольный.
7763.80 7766.00 SPEAKER_01 Это там мэдс, кажется, фигачит чуть ли не в одиночку.
7766.00 7768.60 SPEAKER_01 Вместо экстенджеров, теперь прям в студию, и нормально.
7768.60 7774.20 SPEAKER_01 Ну, вообще приятно, знаешь, когда вот лидеры есть у какого-то направления, сразу видно, что работа кипит.
7774.20 7776.24 SPEAKER_01 Интересные мысли, интересные релизы появляются.
7776.24 7777.52 SPEAKER_01 Да, пусть даже в мелочах.
7777.52 7780.48 SPEAKER_01 На самом деле, если эти мелочи полезны, то почему нет?
7780.48 7781.48 UNKNOWN Давай дальше.
7781.48 7785.88 SPEAKER_01 Конечно, у нас все состоит из мелочей, в принципе.
7785.88 7786.88 SPEAKER_01 Проговорим про Espire.
7786.88 7794.60 SPEAKER_01 В принципе-то, Espire - это та тема, которая нам каждый год, каждый выпуск в течение года давала какие-то нововведения.
7794.60 7800.64 SPEAKER_01 И, как вы, наверное, поняли, для того, чтобы самих себя не повторять, мы придумали прекрасный хак - мы зовем гостей.
7800.64 7809.96 SPEAKER_01 И вот специально для того, чтобы разобраться в тех новинках, которые нам преподнес релиз Espire, мы пригласили большого специалиста по этой теме, Александра Гальдебаева.
7809.96 7812.00 SPEAKER_01 Александр, приветствую тебя.
7812.00 7815.64 SPEAKER_01 Всем привет, спасибо, что пригласили.
7815.64 7818.96 SPEAKER_01 Специалист я, конечно, знатный, немного самопровозглашенный.
7818.96 7831.68 SPEAKER_01 И, да, расскажу про то, что вообще нового в девятой версии Espire у нас, приуроченной к выходу нового фреймворка в целом.
7831.68 7839.04 SPEAKER_01 Смотри, ты следишь за Espire, насколько я знаю, еще до того, как он в релиз попал, в принципе, как, наверное, многие из нас.
7839.04 7848.80 SPEAKER_01 Но у тебя уже много опыта, ты делал доклады, ты понимаешь, как там внутри работает это все, ты делал какие-то красивые презентации, поэтому ты в любом случае понимаешь больше, чем многие из нас.
7848.80 7849.80 SPEAKER_01 Так что не отвертишься.
7849.80 7850.80 SPEAKER_01 Будешь специалистом.
7850.80 7851.80 SPEAKER_01 Ну что, готов?
7851.80 7860.60 SPEAKER_01 Смотри, нас прежде всего интересует, давай выберем вот три твоих самых любимых фичи, которые тебе показали самые значимые в этом релизе и самые важные.
7860.60 7861.60 SPEAKER_01 Что бы ты выделил?
7861.60 7867.52 SPEAKER_01 На самом деле, Espire сам по себе состоит из трех фич, они мне понравились в той или иной степени.
7867.52 7873.64 SPEAKER_01 Он пришел в мою жизнь, когда это было нужно и принес те самые три фичи.
7873.64 7876.44 SPEAKER_01 Это, во-первых, сама оркестрация.
7876.44 7889.56 SPEAKER_01 Espire, как мы знаем, у нас помогает упростить оркестрацию при локальной разработке, и это то, что нужно, когда делаешь кучу пэт-проектов и какие-то используешь новые технологии.
7889.56 7903.72 SPEAKER_01 Вторая фича, это, конечно, дашборд, потому что когда это все оркестрируется, хотелось бы это все нормально поотлаживать, поотслеживать, что там как с метриками, трассировками и в целом посмотреть на свои сервисы.
7903.72 7923.84 SPEAKER_01 Соответственно, дашборд, который поднимается автоматически, который автоматически шлется вся телеметрия, это оказалось тоже отличной фичей, которая очень порадовала, не нужно поднимать различные другие бекенды телеметрии ручками, все, опять же, автоматизировано.
7923.84 7958.96 SPEAKER_01 И третья фича, она также касается, конечно же, автоматизации, потому что самому делать ничего не хочется, особенно рутинную какую-то деятельность, и это интеграция, такая третья основополагающая часть Aspire, и интеграция — это, по сути, популярные сервисы и компоненты, которые, соответственно, предоставляются в виде nugget-пакетов и помогают внедрить тот же условный RADIUS, POSGRES и так далее в модели оркестрации и, соответственно, в само приложение, которое этот сервис хочет использовать, то есть тот же POSGRES и RADIUS.
7958.96 7962.60 SPEAKER_01 Мы хотим их использовать, и интеграции нам в этом помогают.
7962.60 7967.52 SPEAKER_01 Давай теперь посмотрим, а что же у нас в этих трех сферах появилось нового в девятом релизе.
7967.52 7978.48 SPEAKER_01 Да, начнем, пожалуй, с дашборда, и, соответственно, добавили в него, наверное, больше всего всяких прикольных фич.
7978.48 7985.76 SPEAKER_01 Во-первых, как я говорил, в дашборде можно было смотреть всю телеметрию и данные о сервисах, какие-то их переменные окружения.
7985.76 8012.48 SPEAKER_01 Теперь еще добавили возможность смотреть health-чеки, то есть в данные о сервисах у нас попадает какая-то детальная информация, и, соответственно, если сам health-чек говорит, что все плохо, сервис умирает, то у нас Aspire Dashboard об этом оповестит нас соответствующей иконкой у сервиса, и не нужно, опять же, больше автоматизации, не нужно нам ходить и смотреть самим все эти endpoints с health-чеками.
8012.48 8020.40 SPEAKER_01 А может он теперь, как кубер, автоматически перезагружать, перезапускать поды и все такое, если health-чеки не пришли?
8020.40 8030.12 SPEAKER_01 Это тоже у нас добавилось, не совсем автоматически, но есть возможность теперь прокликивать кнопочки и перезапускать отдельно наши сервисы.
8030.12 8052.56 SPEAKER_01 То есть если раньше был вопрос, нужно ли при изменении какого-то сервиса одного перезапускать всю инфраструктуру, если был – да, скорее всего, то сейчас мы можем изменить какой-то один сервис и перезапустить его ручками через Dashboard, и все подтянется, не нужно, если мы подняли 10 миллионов сервисов зачем-то локально, то, соответственно, не нужно все их поднимать заново.
8052.56 8053.56 SPEAKER_01 Отлично.
8053.56 8057.68 SPEAKER_01 Про Dashboard есть что еще отметить или пойдем дальше?
8057.68 8059.80 SPEAKER_01 Про Dashboard есть еще что сказать.
8059.80 8070.24 SPEAKER_01 Помимо вот этой возможности гасить, соответственно, прокликать сервисы, у нас появилась возможность также взаимодействовать с сервисами, но в более какой-то развернутой парадигме.
8070.24 8084.24 SPEAKER_01 Эта фича касается уже не только Dashboard, но протекает через все остальные области Aspire, и это возможность делать свои, соответственно, кастомные какие-то команды.
8084.24 8100.52 SPEAKER_01 То есть мы можем написать команду, какой-то хендлер, и по нажатию, условно, на кнопочку в Dashboard у нас будет ресетаться база данных или очищаться кэш в редисе или, в общем, происходить все, что мы захотим, как мы это сами реализуем, опять же.
8100.52 8104.92 SPEAKER_01 То есть специфические команды, которые привязаны к конкретному ресурсу.
8104.92 8105.92 SPEAKER_01 Да, да.
8105.92 8112.24 SPEAKER_01 Специфические команды, работает это, конечно, только при локальной разработке, то есть никуда это в манифест не пойдет.
8112.24 8113.24 SPEAKER_01 Отлично.
8113.24 8118.12 SPEAKER_01 Так, давай к другим уровням, что там еще упоминал, оркестрация, интеграция?
8118.12 8121.44 SPEAKER_01 Оркестрация, интеграция и все остальное.
8121.44 8169.04 SPEAKER_01 Да, что касается оркестрации, у нас добавили возможность сервисы делать персистентными, мы говорили только, что сервисы можно гасить по отдельности, незаметно, кнопочками в Dashboard, и также теперь есть возможность какие-то сервисы делать неубиваемыми, то есть даже когда мы остановим Aspire, все, у нас вся инфраструктура утихнет, то сервис, условно, Docker-контейнер, он останется работать и, соответственно, мы сможем остановить его только, если, условно, зайдем и остановим контейнер ручками, в Dashboard его погасим, опять же, руками через кнопочку или отключим блок питания, такой вариант тоже есть, но там не только, контейнер погасится.
8169.04 8185.44 SPEAKER_01 Я так понимаю, что это нужно для того, чтобы быстрее стартовал твое приложение, если ты там что-то поменял, то перезапускается, соответственно, только то, что могло поменяться, а если ты Rabbit никогда в жизни менять не собирался, то, в принципе, его и гасить никакого смысла нет, поэтому у тебя быстрее будет любой рестарт, любой переподъем, верно?
8185.44 8188.04 SPEAKER_01 Я думаю, именно для этого это и сделано.
8188.04 8189.56 SPEAKER_01 Так, супер, что-то еще?
8189.56 8193.44 SPEAKER_01 Я думаю, что про оркестрацию у меня все.
8193.44 8195.44 SPEAKER_01 Так, ты еще упоминал интеграции.
8195.44 8217.24 SPEAKER_01 Да, и третья фича, которая мне больше всего понравилась, третья область Aspire, это, конечно же, интеграции, которые позволяют нам заинжектить сервисы и какие-то дополнительные бенефиты по типу автоматическую подключение, автонастройку телеметрии и всего остального.
8217.24 8225.48 SPEAKER_01 И, соответственно, с Aspire 9 мы можем эти интеграции проапгрейдить еще сильнее.
8225.48 8269.12 SPEAKER_01 Как минимум, у нас появилась возможность с командами, про которые я говорил, создавать команды, и круто, когда мы можем делать их сами, но еще круче, когда мы ставим себе какую-нибудь интеграцию с Postgres, а там помимо того, что у нас инжектируется знакомое нам API взаимодействие с правильным lifetime в наш DI-контейнер, и, соответственно, устанавливается сам контейнер с тем же Postgres, у нас еще и появляются команды, которые мы можем запускать, и, соответственно, как-то более удобно взаимодействовать с Postgres, как-то очищать базу данных или проводить какие-то другие специфические действия.
8269.12 8278.20 SPEAKER_01 То есть команды для различных ресурсов, интеграции — это фича, как я уже говорил, которая простирается на несколько областей.
8278.20 8301.72 SPEAKER_01 Также была добавлена событийная модель, такое специфическое, опять же, название, и она позволяет подключаться к приложениям и ресурсам, то есть, соответственно, это можно назвать буквально ивенты, то есть, когда приложение стартует, когда маппятся его endpoints, когда оно завершает свою работу.
8301.72 8323.20 SPEAKER_01 Все эти события, их можно, грубо говоря, обрабатывать и, соответственно, запускать какой-то свой кастомный код, если кому-то это, опять же, понадобится, и мне кажется, конкретно эта фича, она хоть и относится к оркестрации, но больше подойдет именно авторам различных интеграций, можно много всего интересного, как мне кажется, напридумывать.
8323.20 8337.64 SPEAKER_01 И, опять же, смежная фича между интеграциями и оркестрацией — это возможность ожидать зависимости, то есть, если у нас условный PGAdmin зависит от Postgres, нам нужно его подождать.
8337.64 8350.20 SPEAKER_01 Раньше такой возможности в Aspire не было, ее можно было сделать самому, это было достаточно несложно за счет стандартных health-чеков, их проверки, то есть, готов ли сервис, стартанул ли он.
8350.20 8357.72 SPEAKER_01 И Fowler даже в своем GitHub делал пример, как это все простенько-быстренько реализовать.
8357.72 8379.04 SPEAKER_01 Ну и, соответственно, это все вошло в 9-ый Aspire, теперь это все вшито, у нас есть метод waitFor, с помощью которого мы в нашей модели оркестрации сможем взять и подождать нужный нам сервис, при желании указав нужные health-чеки, которые будут проверяться, соответственно, по которым будет проверяться готовность этого сервиса.
8379.04 8385.28 SPEAKER_01 Ну, звучит вроде многообещающе, в принципе, все отлично, хорошо.
8385.28 8387.24 SPEAKER_01 Так, это все нововведения, которые ты хотел отметить?
8387.24 8388.68 SPEAKER_01 Или может быть что-то еще есть?
8388.68 8405.64 SPEAKER_01 Конечно, я очень хотел рассказать, оставить на десерт, на сладкое, все, что связано с Azure, и вкратце добавили поддержку Azure Functions, Microsoft говорит, что это самая ожидаемая вообще фича, которую ждали абсолютно все.
8405.64 8416.40 SPEAKER_01 Если вы тоже ждали Azure Functions и знаете, что это такое, пользуетесь этим каждый день, то пишите комментарии, ставьте лайки, всегда хотел это сказать.
8416.40 8419.48 SPEAKER_01 Интересно, когда яндекс-фанкшн спадает, подключит.
8419.48 8428.16 SPEAKER_01 Если вдруг у вас есть минутка свободного времени и знания яндекс-фанкшнов, то сделайте экспайр и доброе дело, научите его правильным фанкшнам, а не вот это все.
8428.16 8432.84 SPEAKER_01 Ну что, Саша, огромное тебе спасибо, спасибо, что зашел, поделился своим мнением насчет релиза.
8432.84 8437.60 SPEAKER_01 Как ты считаешь, релиз достойный для того, чтобы быть девятым, или это какой-то минорный проходной был?
8437.60 8443.56 SPEAKER_01 По сравнению с остальными девятыми релизами, особенно Windows 9, я думаю, релиз более чем достойный.
8443.56 8451.20 SPEAKER_01 Ну, на то мы и порешили, значит, экспайр движется в правильном направлении, будем дальше следить и за тем, что у него интересно будет, и держать вас в курсе.
8451.20 8453.68 SPEAKER_01 Все, спасибо большое, что зашел, до новых встреч, пока.
8453.68 8455.28 SPEAKER_01 Спасибо, что пригласили.
8455.28 8466.00 SPEAKER_01 Ну что ж, о самых замечательных новинках, самых больших новинках Александр рассказал, а я бы, наверное, хотел еще несколько мелочей упомянуть, которые, мне кажется, тоже стоило бы знать нашим слушателям.
8466.00 8473.20 SPEAKER_01 Ну, во-первых, Aspire 9 поддерживает как DotNet 8, так и DotNet 9, поэтому вы его можете использовать и там, и сям.
8473.20 8486.84 SPEAKER_01 Из небольших нововведений, была улучшена поддержка дашборды в мобильных приложениях, все было переверстно, переделано, теперь для мобилок это просто сущий восторг.
8486.84 8509.84 SPEAKER_01 Дальше у нас появилась возможность разметить наши данные как сенситива информация, то есть возможность размечать данные как сенситива информация у Микрософта было довольно-таки давно, а теперь мы добились того, что дашборд аспировски понимает эту информацию и не будет вам показывать визуально на UI те вещи, которые были помечены как чувствительные.
8509.84 8521.20 SPEAKER_01 Ну, например, вы могли бы запускать контейнер с каким-нибудь паролем в командной строке или что-то с вот таким образным секретниками, в общем, все это на дашборде вы больше не увидите.
8521.20 8525.52 SPEAKER_01 Естественно, вы должны это все правильно разметить, если вдруг какие-то свои собственные ресурсы запускаете.
8525.52 8535.88 SPEAKER_01 Также на дашборде у нас теперь видны контейнерные волюмы, там можно посмотреть про них детальную информацию и посмотреть больше какой-то специфики.
8535.88 8551.52 SPEAKER_01 У нас поддерживаются health-чеки и теперь в дашборде можно эти health-чеки раскрыть и посмотреть, а что же конкретно там у нас происходит, почему именно этот сервер считается нездоровым или заболевающим.
8551.52 8554.88 SPEAKER_01 В общем, подробности у нас теперь появились на дашборде, что прекрасно.
8554.88 8565.26 SPEAKER_01 Отдельная интересная тема – это то, что теперь дашборд поддерживает OpenTelemetry канал по HTTP и корсам.
8565.26 8566.52 SPEAKER_01 Что это значит?
8566.52 8577.16 SPEAKER_01 Технически это значит, что вы можете по OpenTelemetry протоколу слать ему различную информацию через браузер, то есть из браузера.
8577.16 8588.44 SPEAKER_01 В сути, браузерное приложение, например, ваше JavaScript приложение, которое у вас работает, установив JavaScript OpenTelemetry SDK, может слать структурированные логи, трейсы и метрики.
8588.44 8608.92 SPEAKER_01 Теперь вы трейсы ваши можете не только между всеми бэк-энд-серверами и базами данных и вашими кэшами проследить, но и таким же образом проследить и даже через вашу WebUI, сколько там на WebUI это заняло времени, насколько она тормозила и когда пользователь увидел те данные, которые вы там оптимизировали с точностью данной на секунды.
8608.92 8614.56 SPEAKER_01 В общем, теперь вот этот трейс OpenTelemetry можно включить в том числе и в ваше JavaScript приложение.
8614.56 8621.80 SPEAKER_01 Ну и не только в трейс, но метрики и структурированные логи тоже полезно иметь в одном месте, в том числе и из браузера.
8621.80 8625.84 SPEAKER_01 Поэтому это тоже такая классная интересная штука.
8625.84 8630.52 SPEAKER_01 Дальше появилась общая сеть между всеми контейнерами.
8630.52 8639.32 SPEAKER_01 Теперь Aspire собирает сеть, которая называется Default Aspire Network, и в эту сеть уже связывает все контейнеры, которые есть.
8639.32 8642.68 SPEAKER_01 То есть контейнеры могут общаться между собой и при этом не выходя в хостовый нетворк.
8642.68 8654.12 SPEAKER_01 То есть у них там получается такая изоляционная сетка, где они могут общаться, если хотят, и никакой доступ к хостовой сети им не нужно.
8654.12 8665.28 SPEAKER_01 Такая возможность позволяет проще мигрировать ваши Compose проекты на Aspire, потому что как раз это подход обычный по дефолту Compose.
8665.28 8671.28 SPEAKER_01 Ну и вообще, безопаснее и удобнее такой сетью пользоваться.
8671.28 8676.64 SPEAKER_01 Ну вот такой релиз Aspire вышел, в принципе, хороший релиз, тоже много интересных новых фич.
8676.64 8681.00 SPEAKER_01 Если не пробовали, то поиграйтесь, интересная толза.
8681.00 8687.00 SPEAKER_01 Однозначно интересная, про нее много говорят, много смотрят, и там появляются всякие разные расширения.
8687.00 8703.04 SPEAKER_01 Не перестанем говорить про Aspire, будем много еще рассказывать про то, что там появляется, потому что это один из, наверное, сейчас самых, ну, не быстро растущих, но часто обсуждаемых продуктов от Microsoft, по крайней мере, в среде .NET.
8703.04 8705.76 SPEAKER_01 А мы пойдем дальше.
8705.76 8720.64 SPEAKER_01 У нас осталось не так много всего, что нужно объять, и мы давайте немножко отвлечемся, пока мы далеко не ушли на самом деле от всяких EDE-шек, поговорим еще про один комплект EDE, не EDE, плагинов, не плагинов, это Rider и Sharper.
8720.64 8737.76 SPEAKER_01 Мы про них довольно давно не говорили, но там выходили какие-то обновления, как-то я не особо следил, честно говоря, а тут вышло обновление 2024.3, которое довольно важное, и, пожалуй, оно первое такое, которое вышло одновременно, по сути, с релизом .NET.
8737.76 8760.92 SPEAKER_01 Как было раньше, когда реализовался .NET, всегда выходил какой-нибудь ближайший, грубо говоря, релиз Rider и Sharper с полной поддержкой этого .NET через какое-то время, и если вы хотели вот сразу после релиза или незадолго до релиза пользоваться, незадолго до релиза или в момент релиза пользоваться новым .NET, вам нужно было ставить какие-нибудь Early Access Preview или что-нибудь в таком духе.
8760.92 8779.80 SPEAKER_01 С этого года, ну и я надеюсь, что это будет нормальная дальше ситуация, это поменялось, и вот уже там буквально на следующий день был доступен ReSharper и Rider 2024.3 с полной поддержкой .NET 9 и C# 13, даже включая всякие превьющичи типа Field Keyword, оно все поддержано.
8779.80 8790.52 SPEAKER_01 Кроме этого, туда добавили WinForm-овый дизайнер для .NET проектов, начиная с .NET 6, по-моему, это то, что давно просили, потому что, по-моему, WinForm-овый дизайнер был только для .NET Framework проектов раньше.
8790.52 8797.32 SPEAKER_01 Теперь можно, если вы по старинке хотите писать WinForm на современном .NET, можно теперь это делать в Rider.
8797.32 8803.24 SPEAKER_01 Появилась подсветка синтаксиса в ToolTips, то есть везде где встречается код в ToolTips теперь подсвечиваются ToolTips.
8803.24 8806.80 SPEAKER_01 Можно фризить-анфризить потоки во время дебайгинга.
8806.80 8809.62 SPEAKER_01 Улучшили AI-ассистанты, говорят, довольно существенно.
8809.62 8821.00 SPEAKER_01 Remote Development в Rider наконец-таки вышел из беты и теперь плюс-минус доступен уже не как бета, так что если вам это интересно, пользуйтесь.
8821.00 8824.64 SPEAKER_01 Ну и в целом, наверное, по C#-овой части Rider все.
8824.64 8842.20 SPEAKER_01 В ReSharper все то же самое, по большому счету, кроме того что там немножко еще доработали Cleanup код, он получше стал работать, почти так же, как вот всякие эти форматирования, которые вы делаете через EDE, код Cleanup раньше чуть-чуть меньше себе позволял, теперь его можно настроить, чтобы он больше себе позволял.
8842.20 8861.76 SPEAKER_01 Ну и в декомпиляторе теперь декомпилируется в том числе Assembly Manifesto, то есть это специальная секция сборки, которая содержит в себе всякую разную информацию там о заголовках, о каких-то пропертях, вот этого всего, ну в смысле какой-то мета-информацию о сборке, она теперь тоже декомпилируется и показывается, а также поддерживается на прайме реконструктора.
8861.76 8872.60 SPEAKER_01 И, естественно, вместе с Rider и ReSharper зарелизились и все остальные тулы комплекта, то есть это .memory, .trace, .cover, .pick.
8872.60 8919.04 SPEAKER_01 В общем, там везде есть всякие разные улучшения, где-то по мелочи, где-то не очень, то есть наибольшие улучшения, пожалуй, в .memory, там вернули обратно creation stack trace и backtrace views, полезные для того, чтобы понимать, откуда вообще объекты родились и почему они до сих пор живут, это backtrace, соответственно, а также добавился новый чарт под названием icicle, это ну нечто похожее на flame chart, на flame graph, да, только он обычно всегда назывался icicle в JetBrains тулах, соответственно, которое показывает, кто кем владеет, так скажем, новый, короче, раздел, посмотрите, если полюбить .memory, должен быть более полезен для понимания того, почему у вас телевизионные объекты остались жить.
8919.04 8930.16 SPEAKER_01 Ну вот, примерно так, так что хорошо, что вторая наша IDE тоже идет в ногу и релизится теперь уже практически одновременно с самим .net, его можно сразу брать и пользоваться.
8930.16 8935.12 SPEAKER_01 Все бежим на девятый .net, сразу, в какой бы IDE вы ни были.
8935.12 8943.96 SPEAKER_01 Есть у меня подозрение, что мало фич в C# было, вот поэтому она и успела зарелизиться именно с самим релизом вместе.
8943.96 8964.00 SPEAKER_01 Это может быть, понятно, что если бы неделю назад Microsoft сказала, а вот вам, не знаю, extension everything, или там discriminated unions, ну, конечно, наверное, было бы сложно, но да, может быть, ты и прав, может быть, ты и прав, но с другой стороны, смотри, как бы нет худа без добра, в очередной раз оправдывается старая поговорка.
8964.00 8965.00 SPEAKER_01 Вот.
8965.00 8971.68 SPEAKER_01 Действительно, давай, напоследок у меня еще есть смешная тема про то, как же поживает UI на .net.
8971.68 8975.04 SPEAKER_01 Вот, точно, я же WinForms упомянул, давай, точно, WinForms.
8975.04 8977.92 SPEAKER_01 Что нового в WinForms?
8977.92 8989.68 SPEAKER_01 В WinForms, вообще, когда я всю эту статейку анализировал, читал, самое большое удивление, наверное, вызывало в том, что все это до сих пор живо.
8989.68 8993.52 SPEAKER_01 Поэтому WinForms на самом деле, в принципе, практически живее всех живых.
8993.52 9005.24 SPEAKER_01 Ну ладно, давай по порядку, давай по порядку, можешь с WinForms, можешь, давай-давай-давай, давай с самого интересного, давай, ладно, WinForms фиг с ними, они живее всех живых, давай с Maui.
9005.24 9012.12 SPEAKER_01 Мы весь год выясняли, что нового в Maui, там все еще был стабилизация и исправление ошибок, поэтому давай вот с Maui начнем.
9012.12 9013.12 SPEAKER_01 Что там?
9013.12 9014.12 SPEAKER_01 Стабилизировали?
9014.12 9015.12 SPEAKER_01 Исправили?
9015.12 9020.08 SPEAKER_01 В общем, все стабилизировали, все исправили, но я думаю, что это пока на этот релиз все стабилизировали.
9020.08 9023.52 SPEAKER_01 На следующий у них уже тоже много планов по стабилизации и исправлению.
9023.52 9024.52 SPEAKER_01 Ага, хорошо.
9024.52 9060.12 SPEAKER_01 Так, наверняка еще будут, но у Maui не то, чтобы много есть чем похвастаться, но из самых знаменательных пунктов это, прежде всего, гибрид WebView, это новый контрол, который позволяет вам не просто захостить там ваши HTML, JS, CSS контент, который там у вас есть, но и при этом настроить грамотную коммуникацию, то есть грамотное взаимодействие между JavaScript, который вы там захостили, и вашим хостовым C# проектом, то есть такая interop между JavaScript и C#, этот компонент позволяет сделать, что, наверное, во многих ситуациях будет очень полезно.
9060.12 9074.24 SPEAKER_01 Например, вы можете какое-нибудь React.js аппликейшн туда захостить и начать заставлять его работать с вашим C# кодом, и при этом, так как это Maui, вы можете получить кроссплатформенное приложение.
9074.24 9083.76 SPEAKER_01 Да, из React.js сделать нормальное кроссплатформенное приложение на Maui, которое вы сможете распространять, ну, как я уже говорил, там всякие Android, iOS, Windows, в общем, абсолютно везде.
9083.76 9088.24 SPEAKER_01 И другой интересный новый компонент появился – это TitleBar для Windows.
9088.24 9098.96 SPEAKER_01 Теперь в Windows операционной системе вы можете TitleBar использовать абсолютно по вашему усмотрению, там рисовать на нем табики, как это делают браузеры, или какие-нибудь там надписи в лампочке, выводить все в этом духе.
9098.96 9108.40 SPEAKER_01 А интересное нововведение, опять же, не прошло и 10 лет – это Binding, Compiled Bindings in Code.
9108.40 9109.40 SPEAKER_01 Что это значит?
9109.40 9110.40 SPEAKER_01 Да.
9110.40 9124.52 SPEAKER_01 Если кто-то из вас сталкивался с бандингом, то знает, что для того, чтобы привязать к контролу какое-то свойство у вашей сущности, необходимо было указать строчку, как называется то свойство, которое вы хотите привязать.
9124.52 9129.88 SPEAKER_01 В общем, все современные нормальные фреймворки уже давным-давно использовали для этого экспрессионы.
9129.88 9138.80 SPEAKER_01 То есть не строчку, как называется это свойство, а просто доступ к этому свойству через Func, с помощью экспрессионов можно было легко вычислить и достать.
9138.80 9157.04 SPEAKER_01 И наконец, в DotNet 9, наконец, метод SetBinding получил возможность в качестве параметра принимать Func, возвращаясь и тот самый экспрессион, благодаря которому мы теперь можем не строчками бандить компоненты, а уже строго типизировано с проверкой компиляции, с проверкой отладки, диагностики и так далее.
9157.04 9160.44 SPEAKER_01 В общем, вот такие нововведения мы за год получили в Маюе.
9160.44 9164.24 SPEAKER_01 Ну, что-то как-то не густо, мне кажется, нет?
9164.24 9168.24 SPEAKER_01 Ну, оправдывайся этому хотя бы, у тебя уже не чистый импровмент.
9168.24 9169.24 SPEAKER_01 Ну, да.
9169.24 9170.24 SPEAKER_01 Контролы новые появились.
9170.24 9171.24 SPEAKER_01 Хорошо, посмотрим.
9171.24 9178.72 SPEAKER_01 Я всё жду как-то больших приложений, надо, кстати, посмотреть, будет плейлист этого самого DotNet Conf, может, там таки показали какие-нибудь приложения на Мауи-то нормальные.
9178.72 9187.48 SPEAKER_01 Ну, может быть, хотя я скорее уверен, что там больше на всяких Blazer'ах покажут тебе, чем на Мауи.
9187.48 9188.48 SPEAKER_01 Или на Волонии.
9188.48 9190.32 SPEAKER_01 Или на Волонии, да.
9190.32 9191.32 SPEAKER_01 Ну, посмотрим, посмотрим.
9191.32 9192.32 SPEAKER_01 Ладно, на Мауи гляньте.
9192.32 9199.32 SPEAKER_01 А ещё, смотри, у нас же не только Мауи есть, т.е. Мауи, она позиционировалась как убийца предыдущих фреймворков.
9199.32 9202.36 SPEAKER_01 Но оказывается, что предыдущие фреймворки ещё живее самой Мауи.
9202.36 9204.64 SPEAKER_01 И одним из них является ещё DPF.
9204.64 9211.60 SPEAKER_01 И DPF у нас получил обновлённую тему, которая теперь называется Fluent-тема.
9211.60 9222.80 SPEAKER_01 И она включает более того в себя как светлую, так и тёмную тему, а также поддерживает ещё цвет операционной системы, если вдруг он там выбрал.
9222.80 9232.04 SPEAKER_01 Кроме того, у нас появилась в DPF и поддержка олиготур в UI-контроллах, что тоже неплохо, т.е. у них там рендерный движок, он тоже улучшается.
9232.04 9233.84 SPEAKER_01 Ну, и, наконец, винформы.
9233.84 9243.00 SPEAKER_01 Винформы тоже как бы живы, их и DPF убивал, и Мауи убивал, но на самом деле винформы не просто живы, а пропагандируют новые концепции.
9243.00 9246.52 SPEAKER_01 Они пропагандируют то, что формы должны стать асинхронными.
9246.52 9247.52 SPEAKER_01 Не поверишь.
9247.52 9253.00 SPEAKER_01 Но, опять же, это экспериментальная фича, поэтому осторожней, не сильно трогайтесь.
9253.00 9260.04 SPEAKER_01 И вот до винформы наконец дошло, что асинхронное взаимодействие проникает в наш современный мир со всех сторон.
9260.04 9262.34 SPEAKER_01 У нас там асинки есть, ауэйты есть, не поверишь.
9262.34 9274.20 SPEAKER_01 И формам тоже было бы неплохо вот это всё обуздать, поэтому они ввели новые методы show_async для формы, show_dialog_async, invoke_async для контролла и так далее, и так далее.
9274.20 9281.48 SPEAKER_01 В общем, когда я читал вот эту новость, что наконец-то в формах асинки появились, я, конечно же, ожидал увидеть асинхронных ивентов.
9281.48 9287.36 SPEAKER_01 Помнишь, у нас из-за чего появились вот эти void_async, вообще синтаксис void_async появился?
9287.36 9290.72 SPEAKER_01 Ага, ивенты, конечно, подписка на ивентов.
9290.72 9294.20 SPEAKER_01 Именно так, это негодяи до сих пор хотели подписку на ивентов.
9294.20 9303.14 SPEAKER_01 И вот если бы они в самом начале сделали бы асинхронные ивенты, мы бы на уровне компиляторов запретили бы делать асинквоиды и избежали бы кучу, как бы, седых волос у многих-многих разработчиков.
9303.14 9304.52 SPEAKER_01 Но они этого не сделали.
9304.52 9316.36 SPEAKER_01 Более того, даже когда они продекларировали в том, что винформы должны стать асинхронными, они тоже этого не сделали, и даже об этом не говорят, и даже про это не намекают, они просто шоу-асинки делают у разных контролов.
9316.36 9318.62 SPEAKER_01 Ну, негодяи ли, а?
9318.62 9326.06 SPEAKER_01 Ну, а как, значит, как бы, не всё сразу, нужно что-то на десятый релиз оставить, вероятно, но я не знаю.
9326.06 9335.62 SPEAKER_01 То есть, либо действительно это слишком сложно сделать, может быть, так вот сходу запихнуть туда ещё и асинхронные ивенты, я не знаю.
9335.62 9340.90 SPEAKER_01 Мне кажется, что и это-то было впихнуть не так-то просто, честно говоря, в старые винформы.
9340.90 9348.30 SPEAKER_01 Типа да, и заметь, что это самое большое нововведение из всех трёх фреймворков, и не просто контрольчик добавили, они там весь воркфлоу перелопатили у винформов.
9348.30 9364.02 SPEAKER_01 Интересно, какой должен быть внутренний заказчик, ну это же всё понятно делается не потому, что команда такая решила, захотела, а давай, наверное есть какое-то, ну я не знаю, планирование, фич, вот это всё, кто-то же это запланировал, большое, непонятно, интересно, ну ладно.
9364.02 9368.10 SPEAKER_01 Офис вроде в облаке, студия уже на ДПФ, не знаю, кто у них там большой.
9368.10 9371.58 SPEAKER_01 Вот тоже непонятно, да, мне тоже непонятно, ну ладно.
9371.58 9378.06 SPEAKER_01 Добавился к винформам тёмный режим, теперь даркмод у нас поддерживается, пусть в экспериментальном, но всё же в режиме.
9378.06 9408.22 SPEAKER_01 Ещё интересный покойничек – это системдровинг, мы его тоже закапывали много-много лет назад, но как бы на винде он продолжает использоваться, да и чё там греха таить-то, кроссплатформенной альтернативы вообще нет до сих пор, никто блин не нарисовал нормальную работу с картинками, уже не требуется там какая-то страшная матричное преобразование, а просто картинку взять, посмотреть, может быть пережать и может быть немножко сконвертить, вот нет нормальной библиотеки, всё или какие-то плюсы поганые или что-то в этом духе.
9408.22 9478.78 SPEAKER_01 Так вот, системдровинг, живее всех живых и в частности к нему добавляются GDI+ всякие эффекты, там какое-нибудь размытие, затемнение, затенение, в общем всех этих эффектов у него уже собиралась большая-большая куча, также его переписывают активно, чтобы большинство методов, которые принимали массивы, начали принимать рейдонные спаны, то есть о производительности там тоже не забывают, и переписали интероп код, в этой библиотеке нужно было очень много общаться с операционной системой и с её API, и в частности интероп код был переписан с использованием библиотеки CS_Win32, это новая поделка Микрософта, которая помогает сделать painwork, которая позволяет сделать общение C# с нативным кодом с помощью painwalk source-генератора, что тоже в принципе довольно актуальная проблема, то есть до сих пор, несмотря на обилие тулзов нормального такого source-генератора painwalk, почему-то нет, вот может быть эта библиотека кстати станет таким вот хорошим стандартом, поэтому если для вас тема актуальна, посмотрите, вроде выглядит прилично.
9478.78 9483.58 SPEAKER_01 Ну и на то, что GDI+ на ней работает, тоже доказывает, что практически хорошая вещь.
9483.58 9495.06 SPEAKER_01 Ну, в общем, как ни странно, я ожидал поменьше новостей про UI, но даже здесь что-то получилось действительно в основном за счет информации, удивительное дело, конечно.
9495.06 9509.94 SPEAKER_01 Я вообще ожидал больше, то есть намного меньше новостей про сами релизы, а вот тут, смотри, у нас уже сколько разговариваем, сколько пообеседовали, сколько обсудили, несмотря на то, что мы практически про каждый пункт уже отдельно обсуждали, все равно нашлось что-то поговорить.
9509.94 9516.58 SPEAKER_01 Все-таки релиз, несмотря на то, что он очень-очень маленький был для языка, в общем, для платформы выходит довольно неплохой, как ты считаешь?
9516.58 9533.58 SPEAKER_01 Ну, в целом, да, мне кажется, получилось неплохо, мы действительно пробежались практически только по заголовкам, и то вот уже почти два часа, мне кажется, разговаривали, по таймеру записи, понятно, что в подкасте получится поменьше, но все равно, хотя, наверное, все равно за 2 часа пока все это отредактируем, выверим и так далее.
9533.58 9553.02 SPEAKER_01 Так что, ну хорошо, еще прошел год, теперь мы, начиная со следующего выпуска, начнем ждать релиз дотнат-10, до которого будет еще год, и будем пока обозревать все статьи, которые выйдут на предмет того, как же этот дотнат-9 теперь в продакшене живет.
9553.02 9554.78 SPEAKER_01 Наверняка же будут восторженные статьи.
9554.78 9562.74 SPEAKER_01 У нас уже появилась куча статей в бэклоге про дотнат-9, поэтому я думаю, что этот релиз нам еще на пару месяцев даст плодов для обсуждения.
9562.74 9564.50 SPEAKER_01 Ну, отлично, отлично.
9564.50 9580.54 SPEAKER_01 А на сегодня, наверное, тогда стоит закругляться, мы сегодня поговорили про релиз дотнат-9, я не буду перечислять все кусочки, вот, релиз дотнат-9, студия и райдер и шерпер соответствующих версий.
9580.54 9582.46 SPEAKER_01 Наверное, на этом надо заканчивать.
9582.46 9601.06 SPEAKER_01 Да, спасибо всем, кто дослушал до конца, хороший был релиз, интересный получился выпуск, ждем ваших комментариев, ждем ваших вопросов, поправлений, неточностей, ждем от вас новых статей, которые вы бы хотели услышать в выпусках.
9601.06 9608.54 SPEAKER_01 В общем, оставляйте всякую обратную связь, а мы начинаем со следующего выпуска новый Дотнет Год, и прощаемся со старым.
9608.54 9609.54 SPEAKER_01 Так что всех с Новым Годом.
9609.54 9611.18 SPEAKER_01 Всем пока.
