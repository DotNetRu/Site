0.00 2.92 None Всем привет!
2.92 8.80 "Анатолий Кулаков" С вами Радио.нет, выпуск номер 10.
8.80 12.16 "Анатолий Кулаков" И в студии, как всегда, для вас работает Анатолий Кулаков.
12.16 13.16 "Анатолий Кулаков" И Игорь Лабутин.
13.16 14.16 "Анатолий Кулаков" Привет!
14.16 21.76 "Анатолий Кулаков" Совсем недавно прошла конференция Microsoft Build 2020 и, безусловно, нам очень сильно захотелось ее обсудить.
21.76 25.44 "Анатолий Кулаков" Показали огромное число новинок, в том числе и для разработчиков.
25.44 30.20 "Анатолий Кулаков" Естественно, мы сейчас сосредоточимся на тех вещах, которые были затронуты в плане .NET.
30.20 35.60 "Анатолий Кулаков" И пробежимся и посмотрим, что же там такого интересного происходило.
35.60 44.48 "Анатолий Кулаков" И начать нам хотелось бы с темы .NET Multiplatform App UI, или сокращенно, как его ласково называют, MAUI.
44.48 49.00 "Анатолий Кулаков" Спекуляций насчет кроссплатформного UI у нас в подкасте были уже не раз.
49.00 58.80 "Анатолий Кулаков" Помнишь, Игорь, мы обсуждали, куда Microsoft движется, какой бы фреймворк она могла выбрать, и нужен ли ей вообще UI, или она теперь будет чисто командные тулзы производить и все.
58.80 66.52 "Анатолий Кулаков" Но все-таки эволюция взяла вверх, и Microsoft решилась на то, чтобы выпустить общепризнанный, общерекомендуемый UI фреймворк.
66.52 77.44 "Анатолий Кулаков" Основой для обсуждения у нас послужила великолепная статья Скотта Хантера, где он расписывает подробности, что же такое новый микрософтовский UI.
77.44 79.68 "Анатолий Кулаков" Давайте пробежимся и посмотрим.
79.68 81.60 "Анатолий Кулаков" Итак, Multiplatform Native UI.
81.60 83.52 "Анатолий Кулаков" Насколько он Multiplatform?
83.52 85.12 "Анатолий Кулаков" Получается таки довольно сильно.
85.12 98.52 "Анатолий Кулаков" Microsoft декларирует, что можно писать UI не только для десктопов, Windows, Mac и Linux, чему теперь уже никого не удивишь, но и для мобилок, для Android, для iPhone и даже для Tizen.
98.52 103.16 "Анатолий Кулаков" И все это в одном единственном проекте с одной единственной кодовой базой.
103.16 107.28 "Анатолий Кулаков" Стало это возможным благодаря уже многолетней эволюции Xamarin.Forms.
107.28 112.96 "Анатолий Кулаков" Именно Xamarin.Forms стали подложкой, стали базой для того, чтобы построить этот UI.
112.96 118.52 "Анатолий Кулаков" И на основе Xamarin.Forms как раз таки и будет развиваться в дальнейшем судьба этого фреймворка.
118.52 134.56 "Анатолий Кулаков" Одной из интересных особенностей этого фреймворка является то, что Microsoft ввела поддержку не только MVVM, который старый, добрый, интересный, который мы все уже любим и лелеем, а еще добавила поддержку MDU, так называемую Model View Updater.
134.56 138.48 "Анатолий Кулаков" Это специальная архитектура, которая была популяризирована языком YELM.
138.48 144.56 "Анатолий Кулаков" Она была адаптирована, например, в F# уже давным-давно в проекте, который называется Fabios.
144.56 148.48 "Анатолий Кулаков" И помогает декларативно описывать динамический UI.
148.48 162.40 "Анатолий Кулаков" В частности, благодаря этой платформе, благодаря этому архитектурному подходу стало возможным сделать эмулятор, который автоматически обновляет UI, как только вы меняете код в студии.
162.40 164.56 "Анатолий Кулаков" Мы немножко упоминали об этом в прошлый раз.
164.56 167.44 "Анатолий Кулаков" То есть, выглядит это довольно-таки завораживающе.
167.44 176.96 "Анатолий Кулаков" У вас работает приложение, у вас показываются формочки, и вы заходите в код и начинаете там изменять цвет шрифта, изменять формочки, добавлять какие-то новые поля.
176.96 181.80 "Анатолий Кулаков" И все это мгновенно происходит и отображается в вашем реально работающем приложении.
181.80 185.92 "Анатолий Кулаков" Чтобы это идеально работало, этот подход для моделирования как раз и нужен.
185.92 189.24 "Игорь Лабутин" Звучит прям прикольно и здорово.
189.24 199.40 "Игорь Лабутин" Мне казалось сначала, что когда Microsoft выпустила WinForms и WPF под .NET Core, что это может быть каким-то движением в сторону кроссплатформы.
199.40 212.72 "Игорь Лабутин" Но видимо и WinForms и WPF настолько плотно зависят от Windows API, что на них решили не основываться и действительно взять Xamarin.Forms, как заранее готовый кроссплатформенный Toolkit.
212.72 217.96 "Игорь Лабутин" Вопрос, насколько оно все на ранней стадии.
217.96 224.96 "Игорь Лабутин" То есть, понятно, что анонс, понятно, что здорово, красиво и все такое прочее, но вряд ли это еще production-ready.
224.96 226.88 "Анатолий Кулаков" Да, ты совершенно прав.
226.88 231.56 "Анатолий Кулаков" Это только наработки, это только анонсы, это только декларация о намерениях.
231.56 236.96 "Анатолий Кулаков" В конце года нас ждет превью, который уже можно будет реально пощупать, реально посмотреть.
236.96 240.60 "Анатолий Кулаков" А релиз мы ожидаем вместе с .NET 6.
240.60 243.08 "Анатолий Кулаков" То есть, это даже не .NET 5.
243.08 249.76 "Анатолий Кулаков" Если вы хотите сейчас уже приобщиться к новому UI, то Microsoft рекомендует вам смотреть на Xamarin.Forms.
249.76 254.00 "Анатолий Кулаков" Они обещают, что миграция Xamarin.Forms на новый UI будет минимальной.
254.00 258.84 "Анатолий Кулаков" То есть, они полностью будут поддерживать те приложения, которые пишутся сейчас на Xamarin.
258.84 263.80 "Анатолий Кулаков" И, скорее всего, миграция будет автоматической, как это они делали в последнее время.
263.80 266.76 "Анатолий Кулаков" Вот, тема довольно-таки новая, интересная.
266.76 272.84 "Анатолий Кулаков" И я думаю, мы будем еще много-много новостей встречать на протяжении этого года, связанные с новым UI.
272.84 278.20 "Игорь Лабутин" Ну, тема-то действительно новая, но на самом же деле кроссплатформенные UI существовали и раньше.
278.20 282.04 "Игорь Лабутин" И один из их представителей - это фреймворк Avalonia.
282.04 288.84 "Игорь Лабутин" И мы позвали Никиту Цуканова, одного из разработчиков Avalonia и гуру велосипедостроения, чтобы прокомментировать этот анонс.
288.84 289.84 "Игорь Лабутин" Привет Никиту!
289.84 290.84 "Анатолий Кулаков" Привет, Игорь!
290.84 298.60 "Анатолий Кулаков" Никит, как ты, наверное, в курсе, Microsoft выбрала Xamarin.Forms как основу для их кроссплатформенного UI.
298.60 307.52 "Анатолий Кулаков" Слухи об этом уже ходили давно, о том, что Microsoft все-таки собирается выбрать какой-то кроссплатформенный UI, им нужно в этом двигаться, они там хороши в построении UI.
307.52 312.28 "Анатолий Кулаков" Вот, как ты думаешь, Xamarin.Forms как база - это был хороший выбор или плохой?
312.28 318.60 "Никита Цуканов" Я бы так сказал, что это выбор не хороший, не плохой, а на текущий момент единственный возможный.
318.60 325.76 "Никита Цуканов" Ну, просто в силу объективных причин, связанных с теми или иными характеристиками основных UI-тулкидов.
325.76 328.08 "Игорь Лабутин" А какие были альтернативы?
328.08 332.20 "Игорь Лабутин" Могли же взять просто Avalonia и использовать ее?
332.20 342.44 "Никита Цуканов" Смотрите, на самом деле существует, помимо Xamarin.Forms, несколько сейчас более-менее эксплуатируемых в продакшене UI-тулкидов.
342.44 351.68 "Никита Цуканов" Из Brody Asterix это так называемый ItaForms, который по идеологии как раз работал примерно так же, как Xamarin.Forms.
351.68 358.60 "Никита Цуканов" Он еще, по-моему, с начала десятых годов присутствует на рынке.
358.60 370.44 "Никита Цуканов" Существует так называемый UniPlatform, который пытается сделать свою реализацию Universal Windows Platform, которая будет вроде бы работать везде.
370.44 377.40 "Никита Цуканов" Есть история с так называемым QMLNet, который пытается под множество Qt сделать доступным для .NET.
377.40 378.96 "Никита Цуканов" Ну, и есть Avalonia.
378.96 386.88 "Никита Цуканов" Эти фреймворки, они, несмотря на то, что, казалось бы, решают одну и ту же задачу, решают ее на самом деле достаточно сильно по-разному.
386.88 392.92 "Никита Цуканов" И тут, что называется, есть два подхода к тому, как вообще рисовать GUI.
392.92 400.52 "Никита Цуканов" Первый подход - это просто взять какой-то нативный Toolkit и поверх него замайпить какие-то контрольчики свои.
400.52 409.92 "Никита Цуканов" И таким образом приложение получается выглядеть еще нативно, но у него очень получаются ограниченные возможности по кастомизации.
409.92 417.84 "Никита Цуканов" То есть по этому пути у нас Xamarin.Forms, по этому пути у нас идет Xamarin.Forms, по этому пути у нас идет, как ни странно, UniPlatform.
417.84 421.48 "Никита Цуканов" Какие проблемы у этого подхода?
421.48 425.52 "Никита Цуканов" Ну, как я уже сказал, большие проблемы по кастомизации.
425.52 439.24 "Никита Цуканов" От этого страдает тот же Uno, потому что они пытаются реализовать API-шку Universal Windows Platform, которая изначально рисуется непосредственно самостоятельно.
439.24 457.32 "Никита Цуканов" Когда люди используют тот же Xamarin.Forms и DataForms и пытаются сделать в своем приложении что-то, выходящее за рамки стандарта, им приходится опускаться на уровень самой платформы, и для вот этих вот конкретных участков у них теряется каст-платформенность как таковая.
457.32 462.64 "Никита Цуканов" Они все равно откатываются, потому что им приходится для каждой платформы писать свой отдельный код.
462.64 475.36 "Никита Цуканов" Второй подход, он вообще намного ближе к историческим и вообще самым платформам .NET, это когда UI Framework, он берет и рисует весь Vue самостоятельно.
475.36 480.96 "Никита Цуканов" То есть по этому принципу работает WPF, по этому принципу работает Universal Windows Platform.
480.96 494.84 "Никита Цуканов" То есть Toolkit, он берет и предоставляет возможности для полной кастомизации того, что выводится на экран, просто потому что всю композицию и всю отрисовку делает самостоятельно, у него для этого возможности есть.
494.84 501.84 "Никита Цуканов" Соответственно недостатками WPF и Universal Windows Platform по этом плане является только отсутствие каст-платформенности.
501.84 502.84 "Никита Цуканов" Вот и все.
502.84 506.28 "Никита Цуканов" В остальном это на самом деле идеальные решения для любого UI Toolkit.
506.28 534.40 "Никита Цуканов" По этому пути сейчас у нас идут Avalon, которая делает поддержку полностью своей отрисовки с возможностью полной кастомизации пиксель персик отрисовки и QMone.NET, который работает поверх подможества Qt, а Qt, оно соответственно тоже использует этот подход, они все рисуют сами, они не занимаются попытками интеграции каких-то нативных фиджетов из самой платформы.
534.40 546.00 "Никита Цуканов" Концептуально этот подход, он наверное более правильный, но на текущий момент та же Avalon, она работает только на десктопе.
546.00 564.30 "Никита Цуканов" Если мы говорим про то, чтобы делать универсальный UI Toolkit, который предоставляется для всех нужд, ну Avalon по состоянию на весну 2020 года к этому просто банально не готово.
564.30 585.48 "Никита Цуканов" То есть у нас сейчас нет нормальной поддержки мобильных платформ, у нас пока в текущей заряженной версии нет нормальной поддержки интеграции нативных фиджетов, то есть предлагать Avalon в качестве универсального Toolkit, ну, было бы наверное рановато.
585.48 613.40 "Никита Цуканов" Если мы говорим про QMone.NET, то здесь у нас идет зависимость на Qt, это достаточно большой кусок неуправляемого кода, который поддерживается вообще сторонней компанией, которая делает фокус на C++ разработку, и мы здесь получаем с одной стороны всю мочку Qt, а с другой стороны Microsoft не может делать ставку на такой продукт, который они не контролируют.
613.40 645.92 "Никита Цуканов" То есть у нас исчезают варианты, которые отрисовывают UI самостоятельно, и у нас остается только вот этот первый наш подход, и здесь у нас есть всего три варианта, и из них явно фаворитом является Xamarin.Forms, потому что он нормально работает везде, ну, кроме Linux, там он поверх GTK работает как-то, но на всех остальных платформах оно работает, то есть со всеми своими огрехами, тем не менее человек просто берет, собирает приложение, и оно выглядит везде нативно.
645.92 666.28 "Никита Цуканов" Мы не можем того же самого сказать про DataForms, мы не можем того же самого сказать про Uniplatform, особенно учитывая, что Uniplatform, как бы это сказать, пытается с запуска себя поверх электрона предлагать в качестве десктопного решения.
666.28 667.28 None Такое.
667.28 685.88 "Никита Цуканов" То есть у нас из-за этого Xamarin.Forms это единственный вменяемый кандидат для того, чтобы предоставлять его в качестве дефолтного UI Toolkit, отойдет от этого, ну, просто потому что он уже давно используется, просто потому что в нем, ну, в принципе, все нужное есть, вот.
685.88 690.44 "Никита Цуканов" То есть других вариантов, на мой взгляд, у них просто не было.
690.44 697.60 "Анатолий Кулаков" И тем более он сейчас куплен Microsoft, это отличная тема, чтобы там хорошо управлять и интегрироваться, и не опираясь на каких-то сторонних компаний.
697.60 712.00 "Никита Цуканов" Ну, да, то есть у них полная подконтрольность, и Toolkit работает действительно везде, и Toolkit действительно предоставляет те возможности, которые ему необходимы в общем виде.
712.00 714.08 "Никита Цуканов" И вариантов у них на самом деле не было.
714.08 728.88 "Анатолий Кулаков" Смотри, после того, как Microsoft объявил о том, что у него есть официальный UI, официальный кроссплатформенный UI, изменится ли что-нибудь для других фреймворков, для того же самого Universal Windows Platform, для Avalon'и?
728.88 732.92 "Анатолий Кулаков" То есть они как-то потеснятся, у них будет ли больше проблем, или наоборот?
732.92 740.92 "Никита Цуканов" Ну, смотрите, Universal Windows Platform, наверное, не изменится особо ничего, потому что Xamarin.Forms поверх него как работали, так и продолжат работать.
740.92 745.28 "Никита Цуканов" То есть это будет примерно та же самая ситуация.
745.28 777.28 "Никита Цуканов" Для Avalon'и, на мой взгляд, тоже особо ничего не изменится, потому что она существовала с Xamarin.Forms с момента начала своего существования, и за счет того, что подход принципиально другой к отрисовке UI, есть просто целые классы приложений, которые вы не можете нормально сделать на Xamarin.Forms, просто не можете, потому что они пытаются мапиться на нативный виджет, а подобные приложения требуют больше кастомизации UI, как таковой.
777.28 787.76 "Никита Цуканов" С другой стороны, есть целый класс приложений, которые проще взять и сделать на Xamarin.Forms, нежели по процессу, сделать на чем-то типа Avalon'е.
787.76 793.36 "Никита Цуканов" То есть эти два подхода, они, что называется, должны существовать между собой.
793.36 811.72 "Никита Цуканов" Из того, что изменится, ну, наверное, мы будем пытаться поверх Avalon'и сделать backend для вот этого нового UI, с тем, чтобы обновленные Xamarin.Forms могли работать поверх Avalon'и и, так сказать, сочетать в себе два подхода.
811.72 817.92 "Никита Цуканов" То есть здесь, скорее, будет какой-то курс на интеграцию, нежели на то, чтобы одно пометило другое, на мой
817.92 819.92 "Анатолий Кулаков" взгляд. Отлично.
819.92 821.20 "Анатолий Кулаков" Никит, большое тебе спасибо за комментарий.
821.20 825.32 "Анатолий Кулаков" Я напоминаю, что у нас на связи был Никита Цуканов.
825.32 828.04 "Анатолий Кулаков" Все, спасибо, Никита, пока.
828.04 841.72 "Игорь Лабутин" Кроссплатформенный UI - это хорошо и здорово, но это не единственный анонс в области UI, потому что есть еще WebUI, где проанонсировали релиз Blazor WebAssembly 3.2.0.
841.72 846.52 "Анатолий Кулаков" Да, действительно, наконец-то WebAssembly вышел, наконец-то он зарелизился.
846.52 850.88 "Анатолий Кулаков" Мы о нем много упоминали, много лелеяли, много хвалили, но теперь это релиз.
850.88 853.32 "Анатолий Кулаков" Поэтому давайте остановимся все-таки поподробнее.
853.32 859.04 "Анатолий Кулаков" Blazor версии 3.2.0, именно в него вошел релиз WebAssembly.
859.04 862.92 "Анатолий Кулаков" Все так сложно и запутанно не просто так, а сложно так.
862.92 864.20 "Анатолий Кулаков" Во-первых, что такое Blazor?
864.20 874.48 "Анатолий Кулаков" Это open-source кроссплатформенный UI-фреймворк, с помощью которого вы можете построить свое single-page приложение для ваших браузеров.
874.48 879.36 "Анатолий Кулаков" Его отличие в том, что он использует язык C# взамен JavaScript.
879.36 885.40 "Анатолий Кулаков" Он старается максимальное число действий, стратегий ваших сделать именно на C#.
885.40 899.72 "Анатолий Кулаков" Безусловно, это дает огромные преимущества, потому что у вас появляется настоящий строго типизированный язык, который поддерживается огромным числом IDE, который имеет отличный тулинг, имеет дебаггинг, у него прекрасный интеллисенс.
899.72 906.36 "Анатолий Кулаков" А также вы можете переиспользовать код и библиотеки, которыми вы пользуетесь уже на протяжении многих-многих лет.
906.36 909.96 "Анатолий Кулаков" То есть это тот же самый ваш любимый C#, ваш любимый .NET.
909.96 912.04 "Анатолий Кулаков" И это вам все приносится на UI.
912.04 914.28 "Анатолий Кулаков" И этот UI запускается в браузерах.
914.28 918.36 "Анатолий Кулаков" Без каких-либо плагинов, как это было бы, например, с сервер-лайтом или флешем.
918.36 923.24 "Анатолий Кулаков" Без какой-то либо перекомпиляции или перегенериации или еще чего-то.
923.24 924.60 "Анатолий Кулаков" Просто нормальный C#.
924.60 928.96 "Анатолий Кулаков" Основой для визуального форматирования является синтаксис Razor.
928.96 930.88 "Анатолий Кулаков" Razor с нами уже давно.
930.88 939.36 "Анатолий Кулаков" Это специальный язык разметки, который был изобретен в Микрософте для того, чтобы совмещать вместе HTML теги и C# код.
939.36 941.72 "Анатолий Кулаков" Он отличается тем, что он довольно-таки умный.
941.72 949.60 "Анатолий Кулаков" То есть в отличие от обычных темплейтов, которые работают по принципу греппа, то есть могут заменить какие-то переменные в коде и все.
949.60 951.00 "Анатолий Кулаков" Razor достаточно-таки умный.
951.00 954.68 "Анатолий Кулаков" Он знает все про синтаксисы, он знает, когда начинаются операторы C#.
954.68 958.48 "Анатолий Кулаков" Он вполне способен осознать, когда открываются теги в HTML.
958.48 962.68 "Анатолий Кулаков" И вам не нужно для этого каких-то специальных телодвижений представлять.
962.68 965.80 "Анатолий Кулаков" Blazor умеет поддерживать байдинги.
965.80 971.28 "Анатолий Кулаков" Он умеет генерировать апдейты для UI, если вдруг ваша модель поменялась.
971.28 978.36 "Анатолий Кулаков" Он умеет поддерживать полноценный нормальный MVVM и обрабатывать всякие события от пользователя, естественно.
978.36 979.80 "Анатолий Кулаков" Дальше начинаются сложности.
979.80 982.40 "Анатолий Кулаков" Blazor делится на две части.
982.40 985.84 "Анатолий Кулаков" То есть он может хоститься двумя различными путями.
985.84 988.36 "Анатолий Кулаков" Первый - это Blazor Server App.
988.36 996.48 "Анатолий Кулаков" Это компоненты, которые на самом деле отображаются у пользователя, но вся логика исполнения по-прежнему отрабатывает на сервере.
996.48 1001.28 "Анатолий Кулаков" Web-компоненты используют Realtime WebSocket для того, чтобы взаимодействовать с веб-сервером.
1001.28 1007.76 "Анатолий Кулаков" Веб-сервер просчитывает всякие изменения, модели, просчитывает изменения дома и отсылает это все UI.
1007.76 1008.76 "Анатолий Кулаков" А UI это радостно рисует.
1008.76 1016.00 "Анатолий Кулаков" Это версия Blazor, которая с сервер-сайт была у нас доступна уже с .NET Core 3.1.
1016.00 1018.28 "Анатолий Кулаков" И в принципе никого и не удивишь.
1018.28 1022.60 "Анатолий Кулаков" На билде был анонсирован то, чего в основном ждали от слова Blazor.
1022.60 1023.60 "Анатолий Кулаков" Это Blazor WebAssembly.
1023.60 1029.28 "Анатолий Кулаков" Это другой способ добиться того, чтобы C# ровно работал в браузере.
1029.28 1036.76 "Анатолий Кулаков" И этот способ заключается в том, что теперь весь .NET код исполняется прямо на client-сайде, прямо в браузере.
1036.76 1038.64 "Анатолий Кулаков" Никакого взаимодействия с сервером больше не нужно.
1038.64 1045.76 "Игорь Лабутин" Так а значит ли это, что мы тащим с собой не только .NET код, но и весь .NET Runtime?
1045.76 1047.44 "Игорь Лабутин" Это же, наверное, много?
1047.44 1048.44 "Игорь Лабутин" По сути, да.
1048.44 1062.24 "Анатолий Кулаков" То есть это означает, что при первой загрузке вашего приложения браузер скачает сначала .NET Runtime, а только после этого закачает ваши DLL, то есть настоящие DLL с ILL, и будет работать ваша программа.
1062.24 1072.32 "Анатолий Кулаков" На самом деле есть такой недостаток у этого подхода — якобы медленная скорость первоначальной загрузки и большой overhead по размеру.
1072.32 1080.04 "Анатолий Кулаков" Но на самом деле, если начать разбираться, то скорость загрузки Runtime обычно укладывается менее 1 секунды, то есть это обычно 0.8 секунд.
1080.04 1094.72 "Анатолий Кулаков" А ваше приложение, то есть все ваши пакеты, все ваши референсы и DLL обычно укладываются в 2 МБ в таком способе компиляций, потому что там еще идет сжатие, там еще идет trimming ненужных референсов и так далее.
1094.72 1101.12 "Анатолий Кулаков" То есть размер пока не идеальный, и он все время улучшается, но уже можно говорить о том, что вполне можно пренебречь.
1101.12 1105.36 "Анатолий Кулаков" Поэтому эти минусы довольно-таки несущественны по сравнению с теми плюсами, которые мы получаем.
1105.36 1109.44 "Анатолий Кулаков" А получаем мы действительно настоящий .NET взамен JavaScript.
1109.44 1114.16 "Анатолий Кулаков" И как утверждают разработчики, он должен кушать меньше памяти и работать намного быстрее.
1114.16 1122.20 "Анатолий Кулаков" К сожалению, пока у нас проверить это не получится, но свидетели рассказывают, что эти заявления вполне имеют право на существование.
1122.20 1124.72 "Анатолий Кулаков" Как я уже сказал, никаких плагинов для этого не нужно.
1124.72 1129.20 "Анатолий Кулаков" Все современные браузеры поддерживают WebAssembly на десктопах и на мобильных.
1129.20 1138.40 "Анатолий Кулаков" Точно так же, как и обычный JavaScript, под ваш .NET аппликейшен выделяется Sandbox, поэтому секьюрность в этом плане не страдает.
1138.40 1140.84 "Анатолий Кулаков" И в итоге, что же вы можете сделать?
1140.84 1151.08 "Анатолий Кулаков" Вы можете написать статический веб-сайт полностью на .NET, полностью на Razor и захостить его на любом статическом хостинге, например, GitHub Pages.
1151.08 1180.52 "Анатолий Кулаков" Но это будет не просто страничка, а вполне интерактивная вещь, которая вполне может ходить куда-нибудь в удаленную базу данных, которая торчит голым портом в интернет, которая вполне может из этой базы данных забирать какие-то данные, джоинить их с другим микросервисом, подтягивать ленту Твиттера, аутентифицировать вас по GitHub и отображать это все на вашем экране, и при этом не платить ни копейки за хостинг, потому что хостинг статических веб-сайтов обычно уже бесплатен.
1180.52 1184.64 "Анатолий Кулаков" Еще нужно обязательно помнить про такой шикарный плюс, как переиспользование кода.
1184.64 1204.48 "Анатолий Кулаков" То есть все модельки, все валидации, которые вы раньше использовали в вашем C#, они могут теперь переиспользоваться между UI и между сервер-сайтом, и вы, соответственно, можете переподключить к вашему WebAssembly сервер, взаимодействовать с вашим сервером, как и раньше, но при этом переиспользуя очень-очень много логики и очень много моделек.
1204.48 1209.12 "Анатолий Кулаков" Это все отлично поддерживает дебаггинг после релиза.
1209.12 1219.96 "Анатолий Кулаков" У нас есть много сторонних компонентов, такие известные компании как DevExpress, Telerik, Infragistics, все они уже подсуетились и выпустили шикарные фичастые контроллы, которые рендерятся под WebAssembly.
1219.96 1228.16 "Анатолий Кулаков" Еще одним интересным фишкой Blazor является то, что на его основании можно построить прогрессив веб-ап.
1228.16 1233.00 "Анатолий Кулаков" Это не сказать, что новый, но наверное для многих будет новый тип приложений.
1233.00 1234.36 "Анатолий Кулаков" Что это значит?
1234.36 1243.68 "Анатолий Кулаков" Это значит, что если ваш веб-сайт, ваше веб-приложение построено с технологией PVA, оно может запускаться как отдельное приложение.
1243.68 1249.76 "Анатолий Кулаков" То есть пользователь нажимает специальную кнопочку и говорит «хочу превратить ваш веб-сайт в прогрессив веб-аппликацию».
1249.76 1253.20 "Анатолий Кулаков" И это приложение становится похоже на десктопное.
1253.20 1266.80 "Анатолий Кулаков" То есть у него исчезают вкладки браузера, у него исчезают менюшки браузера, появляется обычное стандартное окно, например, Windows, у него появляется иконка на рабочем столе, у него появляются нотификации вашего десктопа и оно может работать в оффлайн-моде.
1266.80 1273.40 "Анатолий Кулаков" Что открывает довольно большой пласт, который, например, пытается занять электрон.
1273.40 1276.64 "Анатолий Кулаков" И как показывает время, довольно-таки успешно.
1276.64 1283.40 "Анатолий Кулаков" Очень многие приложения десктопные работают как раз-таки под таким стилем и в большинстве случаев пользователям это нравится.
1283.40 1293.00 "Анатолий Кулаков" То есть им без разницы, как это построено внутри, им главное, что это десктопное приложение, запускается по иконке и имеет доступ к их локальной файловой системе и все хорошо работает.
1293.00 1295.60 "Анатолий Кулаков" Вот дальше еще немножко сложностей.
1295.60 1301.28 "Анатолий Кулаков" У Blazer есть такая тема, как Experimental Mobile Blazer Binding.
1301.28 1303.76 "Анатолий Кулаков" Это специальные бандинги к мобильному приложению.
1303.76 1314.56 "Анатолий Кулаков" То есть вы можете использовать весь ваш опыт по сравнению Blazer приложений вместе с C# естественно, для того, чтобы сделать мобильные приложения под iOS и Android.
1314.56 1322.16 "Анатолий Кулаков" Под капотом эти UI-контролы опираются на Xamarin.Forms и в конце концов на телефончике появляются нативные UI-контрольчики.
1322.16 1331.28 "Анатолий Кулаков" Еще одно направление Blazer это интеграция с MyUI, как раз то, что мы обсуждали пунктом выше.
1331.28 1347.08 "Анатолий Кулаков" Теперь можно на Blazer написать UI, который может использовать кроссплатформенный микрософтовский UI для того, чтобы делать приложение под мобилки и десктопы и macOS и iOS и Android и Linux на основании MyUI.
1347.08 1355.76 "Анатолий Кулаков" То есть Blazer пытается проникнуть всеми возможными способами, всеми возможными путями, которые только он находит на кроссплатформенность.
1355.76 1367.84 "Анатолий Кулаков" И теперь мне кажется, что неругательным станет выражение «Fullstack.net Developer», потому что реально на дот-нете можно будет работать с полным фуллстэком и писать UI под все подряд.
1367.84 1387.40 "Игорь Лабутин" Слушай, ты прям описал очень много плюсов и все так замечательно шоколадно и плюс это вообще уже зарелижено, то есть получается, что в принципе всем этим можно пользоваться, ну кроме интеграции с не полностью существующим пока новым микросплатформенным UI и вот Experimental Blazer Mobile Bindings.
1387.40 1391.36 "Игорь Лабутин" Но в целом все готово и работает.
1391.36 1394.48 "Игорь Лабутин" Но наверняка же есть недостатки.
1394.48 1405.32 "Игорь Лабутин" Часть из них мы обсудили, то есть нам нужно тащить рантайм, это там хоть и доли секунд, но все-таки какое-то время и на медленных коннекшенах это может быть даже дольше.
1405.32 1408.24 "Игорь Лабутин" Вопрос главной недостатки.
1408.24 1412.92 "Анатолий Кулаков" Например, если мы говорим о сервер-сайт Blazer, то здесь главным недостатком является коннекшен.
1412.92 1426.64 "Анатолий Кулаков" Как я упоминал, что приложение постоянно взаимодействует с сервером на каждый чих, на любой чих, поэтому если у вас есть вероятность слабого коннекшена между пользователем, между UI и вашим сервером, то этот способ вам не подходит.
1426.64 1428.80 "Анатолий Кулаков" Обратите внимание все-таки на WebAssembly.
1428.80 1436.12 "Анатолий Кулаков" Он лишен этих недостатков, потому что с сервером практически не взаимодействует для того, чтобы как-то менять UI.
1436.12 1443.28 "Анатолий Кулаков" Дальше, если мы опустимся уже непосредственно к WebAssembly, то у нее, например, есть стандартное ограничение JavaScript.
1443.28 1445.44 "Анатолий Кулаков" То есть она запускается в сэндбоксе, как я и сказал.
1445.44 1453.00 "Анатолий Кулаков" Это хорошо для секьюрности, но обычно пользователи привыкли к богатым десктопным приложениям и хотят немножко большего.
1453.00 1457.84 "Анатолий Кулаков" Тенденция постепенно меняется, все больше API пролазят в сэндбокс и пользователи получают хороший экспириенс.
1457.84 1464.84 "Анатолий Кулаков" Но все-таки нужно учитывать, что может быть не все пользовательские сценарии, которые он привык делать на десктопном приложении, можно перенести на WebAssembly.
1464.84 1468.88 "Анатолий Кулаков" Дальше мы не можем удобно взаимодействовать с домом.
1468.88 1474.44 "Анатолий Кулаков" Мы взаимодействуем с домом из WebAssembly с помощью всяких JavaScript интеропов и всяких оберток.
1474.44 1480.68 "Анатолий Кулаков" Этих оберток становится все больше и больше, появляются новые и новые библиотеки, но все же этот минус надо иметь в виду.
1480.68 1485.16 "Анатолий Кулаков" И в принципе мы добиваемся той цели, которую сначала декларировали.
1485.16 1497.80 "Анатолий Кулаков" То есть сейчас вполне можно написать богатое веб-приложение, сингл-плейдж-аппликейшн с хорошим UI, интерактивными компонентами, анимацией и все это сделать без единой строчки JavaScript.
1497.80 1501.32 "Анатолий Кулаков" Иногда приходится это делать, я повторюсь, но все меньше и меньше.
1501.32 1505.20 "Анатолий Кулаков" И я думаю, что вскоре мы вообще забудем об этом лютом аде как JavaScript.
1505.20 1513.00 "Анатолий Кулаков" Уже на момент релиза существует огромное количество сэмплов, репозиторий, библиотек, инструментов, книги, видеокурсы, воркшопы.
1513.00 1522.68 "Анатолий Кулаков" Сейчас это очень хайповая тема и все ей занимаются, поэтому вы без труда в интернете найдете вспомогательный материал, чтобы войти в тему, чтобы ее освоить.
1522.68 1527.88 "Анатолий Кулаков" Посмотрите в наши шоу-ноты, мы приложим пару интересных блогов по этой теме.
1527.88 1532.64 "Анатолий Кулаков" Также нужно сказать, смотря на то, что это релиз WebAssembly, это все-таки не LTS.
1532.64 1536.48 "Анатолий Кулаков" LTS у нас выйдет вместе с .NET 5 позже в этом году.
1536.48 1541.80 "Анатолий Кулаков" А это просто стабильный хороший релиз, который вы уже можете использовать, уже можете править.
1541.80 1543.88 "Анатолий Кулаков" Мне кажется, что нужно постараться не нарушать контракт.
1543.88 1549.24 "Анатолий Кулаков" И поэтому можно безболезненно использовать в своих приложениях.
1549.24 1554.92 "Анатолий Кулаков" Кажется, что действительно это такая серебряная пуля, которая нам пока никаких больших минусов не несет.
1554.92 1569.32 "Анатолий Кулаков" Единственный минус, который я смог найти, подготовившись к этой теме, это то, что люди, которые использовали Blazer в продакшене, люди, которые уже знают, как с ним работать, уже набили себе шишки, по очевидным причинам они очень редки, их довольно-таки мало.
1569.32 1574.40 "Игорь Лабутин" Но мы все-таки смогли найти настоящего разработчика на Blazer, который использует его в продакшен.
1574.40 1577.00 "Игорь Лабутин" Это Роман Китар, FullStack.NET разработчик.
1577.00 1578.00 "Игорь Лабутин" Привет, Роман.
1578.00 1579.00 "Игорь Лабутин" Привет.
1579.00 1580.00 "Игорь Лабутин" Вопрос первый.
1580.00 1586.56 "Игорь Лабутин" В чем были основные проблемы, используя Blazer в продакшене, ну и вообще в разработке?
1586.56 1587.84 "Игорь Лабутин" С какими трудностями пришлось сталкиваться?
1587.84 1589.20 "Игорь Лабутин" Технология относительно новая.
1589.20 1592.28 "Игорь Лабутин" И наверняка там есть дофига граблей и подводных камней.
1592.28 1593.92 "Роман Китар" Да, их много.
1593.92 1598.08 "Роман Китар" На самом деле, одна из самых главных проблем – это маленькая документация.
1598.08 1601.92 "Роман Китар" То есть, на самом деле, мы использовали WebAssembly.
1601.92 1607.80 "Роман Китар" Я так кратце скажу, у Blazer два основных прототипа – это Blazer Server и Blazer WebAssembly.
1607.80 1614.76 "Роман Китар" И если Blazer Server уже в релизе был на момент нашего начала, то Blazer WebAssembly не был.
1614.76 1617.28 "Роман Китар" И поэтому документации было чуть меньше.
1617.28 1621.96 "Роман Китар" Это нас спасал блок Chris Saint и Stack Overflow и другие ребята.
1621.96 1623.36 "Роман Китар" Ну и плюс копания в сорсах.
1623.36 1635.76 "Роман Китар" И вторая основная трудность – из-за того, что технология новая и просто мы с ней еще не работали, иногда мы ловили какой-нибудь баг и в первый раз мы его искали достаточно долго.
1635.76 1639.96 "Роман Китар" Но после этого мы его искали, ну, больше уже не искали, грубо говоря.
1639.96 1642.52 "Роман Китар" То есть, именно из проблем использования – это новость.
1642.52 1644.72 "Роман Китар" Ну, грубо говоря, новая технология.
1644.72 1648.36 "Роман Китар" Я думаю, это примерно такие же проблемы, как и у любой новой технологии.
1648.36 1649.36 "Анатолий Кулаков" Ну да, действительно.
1649.36 1654.08 "Анатолий Кулаков" Но несмотря на то, что технология новая, звучит она очень перспективно.
1654.08 1661.24 "Анатолий Кулаков" Поэтому хотелось бы узнать, в каких ты считаешь, проектах имеет смысл ее использовать, а для каких она абсолютно не подходит.
1661.24 1664.24 "Роман Китар" Абсолютно не подходит, даже не знаю.
1664.24 1667.04 "Роман Китар" Вообще, ну, в принципе, UI.
1667.04 1669.24 "Роман Китар" Я скажу про нашу команду.
1669.24 1671.92 "Роман Китар" Мы очень быстро его начали писать на Blazer.
1671.92 1680.28 "Роман Китар" И даже ребята, которые, если я в основном, ну, мой бэкграунд в основном датнетный, есть ребята, у которых бэкграунд JavaScript.
1680.28 1687.32 "Роман Китар" Но когда мы увидели Blazer, наша скорость разработки выросла очень сильно, благодаря статической типизации, ну, и всему тому, что мы любим фишарты.
1687.32 1690.52 "Роман Китар" И наши базовые библиотеки, которые там внутри.
1690.52 1700.04 "Роман Китар" И если сравнивать именно серверы с WebAssembly, Blazer сервер проекты требует более стабильной коннекции, поскольку там используются сокеты соединения и сигнал архитехнологии.
1700.04 1705.36 "Роман Китар" А вот Blazer WebAssembly практически для всех UI-приложений, ну, ваших веб-приложений.
1705.36 1712.24 "Роман Китар" Поскольку один раз, один раз, вообще один раз выкачивается WebAssembly, она весит не очень много.
1712.24 1718.08 "Роман Китар" У нас уже продакшн-приложение есть, оно весит почти 3 мегабайта.
1718.08 1720.84 "Роман Китар" Ну, примерно то же самое, что выкачивать бандл React.
1720.84 1722.92 "Роман Китар" Поскольку у нас на проекте еще и React есть.
1722.92 1724.76 "Роман Китар" Ну, в другом приложении.
1724.76 1726.88 "Роман Китар" Мне есть вот сравнивать только с React.
1726.88 1728.60 "Роман Китар" И это примерно то же самое.
1728.60 1730.76 "Роман Китар" То есть мы выкачиваем один раз, дальше работает.
1730.76 1732.88 "Роман Китар" Это SinglePageApplication внутри.
1732.88 1740.80 "Роман Китар" Он работает, ну, наверное, даже быстрее, чем React, если у вас есть вычисления тяжелые.
1740.80 1743.92 "Роман Китар" По отрисовке мы так и не смогли понять, кто быстрее.
1743.92 1746.08 "Роман Китар" Я думаю, примерно одинаково.
1746.08 1755.04 "Роман Китар" Поэтому если у вас именно WebApplication и у вас хороший бэкграунд в дотнете, то это будет очень хорошая технология, потому что она очень быстрая для вас.
1755.04 1756.76 "Роман Китар" Именно по написанию.
1756.76 1759.76 "Роман Китар" И недавно вышел новый шаблон приложения.
1759.76 1763.20 "Роман Китар" Вы можете писать Standalone приложение на Blazor.
1763.20 1767.48 "Роман Китар" Оно как WebAssembly выкачивается, но это Standalone приложение.
1767.48 1772.16 "Роман Китар" Если нужен пример, это что-то примерно как Discord, как Teams.
1772.16 1775.72 "Роман Китар" То есть вот такого порядка приложения вы можете писать на Blazor.
1775.72 1776.72 "Игорь Лабутин" Да.
1776.72 1794.28 "Игорь Лабутин" А смотри, вот ты говоришь, что для любых, если у вас есть ваш WebUI, Webприложение, не кажется ли, что WebAssembly может рано или поздно заменить вообще JavaScript и тот же React, тот же Angular и все остальное, что построено на JavaScript?
1794.28 1797.28 "Игорь Лабутин" Все будем писать на дотнете и под WebAssembly, под Blazor.
1797.28 1801.32 "Роман Китар" Ну, лично мне к дотнет-разработчику идея кажется логичной.
1801.32 1804.16 "Роман Китар" Но у нас очень много и JavaScript-разработчиков, и остальных.
1804.16 1810.00 "Роман Китар" Эта технология, как и любая другая, у нее очень большой потенциал, поэтому часть рынка она точно займет, и не маленькую.
1810.00 1823.12 "Роман Китар" Вряд ли JavaScript именно умрет, и вряд ли он умрет очень быстро, но я думаю, что с ее выходом очень большой процент разработчиков на нее уйдет.
1823.12 1851.92 "Роман Китар" Просто благодаря ее, ну, как мы все знаем, простота она как бы сверху, под капотом там все очень хитро, но при этом, я один пример приведу, если вы работали с датой в JavaScript, у вас, наверное, рано или поздно были подводные камни, а здесь у вас date time, то здесь у вас вся библиотека Sharp в вашем распоряжении, у вас полностью переиспользование кода между API и UI.
1851.92 1863.80 "Роман Китар" Это очень удобно, просто поверьте, насколько это удобно, когда у вас вообще все в одном окне Visual Studio, вы можете на два экрана разнести, как вам удобнее.
1863.80 1868.32 "Роман Китар" У вас отличный дебаг, кстати, с последних версий.
1868.32 1886.48 "Роман Китар" У вас практически безграничное использование всех пакетов Sharp, которые у вас есть, и некоторые, ну, людям настолько понравилось, что они начали писать библиотеки компонентов для уже Blazor WebAssembly.
1886.48 1891.92 "Роман Китар" И библиотеки компонентов вы можете писать сами, там есть шаблон, и подключать их очень просто.
1891.92 1902.16 "Роман Китар" И после подключения библиотеки, как и любого NuGet пакета, у вас появляется возможность просто создавать UI компоненты созданные другим человеком, но уже оттестированные, уже хорошие.
1902.16 1910.32 "Роман Китар" Например, мы использовали Mat Blazer, библиотека, где товарищ перевоссоздал материал дизайна Google, как мог.
1910.32 1915.08 "Роман Китар" Ну, там очень большой библиотека, и отлично все сделано, и с тестами.
1915.08 1926.00 "Роман Китар" Я думаю, это будет развиваться, соответственно, компонентов будет все больше, они очень легко поставляются, просто как NuGet пакеты, и вы их очень легко подружаете в свой проект.
1926.00 1927.80 "Анатолий Кулаков" Спасибо большое, отличное дополнение.
1927.80 1930.84 "Анатолий Кулаков" Я напоминаю, что на связи с нами был Роман Китар.
1930.84 1931.84 "Анатолий Кулаков" Пока.
1931.84 1932.84 "Игорь Лабутин" Вам спасибо, до свидания.
1932.84 1946.84 "Игорь Лабутин" А мы перейдем к следующей теме, потому что UI хорошо, VBSsembly хорошо, но пишем мы на C#, и на билде анонсировали нововведения C# 9.
1946.84 1951.64 "Игорь Лабутин" Часть из них мы уже смотрели, часть из них новенькие, давайте по ним пробежимся.
1951.64 1952.92 "Анатолий Кулаков" Давай обсудим новенькие.
1952.92 1961.20 "Анатолий Кулаков" Вообще этот рис можно характеризовать как направленный на уменьшение размера читабельности и на иммьютабельность.
1961.20 1970.12 "Анатолий Кулаков" То есть C# последними релизами очень уверенно двигается в сторону иммьютабилити, и паттерн-матчинга, и такой функциональщины.
1970.12 1991.60 "Игорь Лабутин" Да, ты сказал очень забавно, что нам нужно уменьшать читабельность, то есть компактность кода - это хорошо, иммьютабилити - это хорошо, но действительно C# чем дальше, тем больше вводит различных операторов в странных местах, и код на C# более новых версий гораздо более компактен, это с одной стороны хорошо, но гораздо труднее читабельным.
1991.60 2004.20 "Игорь Лабутин" И вопрос - 9 C# будет еще менее читабельным, или все-таки нас пока ожидает поменьше новых ключевых слов, или что хуже ключевых значков?
2004.20 2006.84 "Анатолий Кулаков" К сожалению или счастью поменьше.
2006.84 2013.52 "Анатолий Кулаков" Все-таки темпы уже не настолько размашисты, не настолько сильные, как в предыдущих релизах, но все-же кое-что интересно есть.
2013.52 2017.12 "Анатолий Кулаков" Одной из самых главных тем на C# 9 является рекорды.
2017.12 2020.12 "Анатолий Кулаков" Рекорды все-таки обещают в конце концов завести.
2020.12 2023.24 "Анатолий Кулаков" Давайте поговорим о том, что же такое рекорды и зачем они нужны.
2023.24 2025.36 "Анатолий Кулаков" Рекорды - это специальный тип классов.
2025.36 2032.44 "Анатолий Кулаков" Они будут обозначаться специальным словом "data" возле декларации классов, и этот класс автоматически становится рекордом.
2032.44 2039.24 "Анатолий Кулаков" Рекорды - это иммьютабилитные классы, которые реализуют очень-очень много всякого Boulder Plate, который вам раньше приходилось писать руками.
2039.24 2048.52 "Анатолий Кулаков" Например, они реализуют equals, они реализуют getHashCode, копирующие конструкторы и много всего еще, чего мы сейчас с вами быстренько рассмотрим.
2048.52 2051.88 "Анатолий Кулаков" Тут очень важно сказать, что главное свойство рекордов - это иммьютабильность.
2051.88 2059.28 "Анатолий Кулаков" Несмотря на то, что в их декларации есть слово "класс", воспринимать их нужно как value-типы, то есть типы, которые не имеют собственной идентификации.
2059.28 2069.40 "Анатолий Кулаков" И именно по этой причине они могут себе позволить быть иммьютабильными, потому что им не нужно менять стейт, они придерживаются немножко другой парадигмы.
2069.40 2081.88 "Анатолий Кулаков" И именно поэтому внутри себя они реализуют по дефолту structure equality, то есть они сравниваются не по референсу, как по дефолту делают обычные классы, а они сравниваются по значению всех полей.
2081.88 2088.96 "Анатолий Кулаков" То есть рекорд, равный другому рекорду - это тот, у которого все поля такие же точно, как у предыдущего рекорда.
2088.96 2097.00 "Анатолий Кулаков" Чтобы это было возможным, чтобы сделать полноценные удобные рекорды, пришлось применить очень много новых интересных хаков.
2097.00 2100.48 "Анатолий Кулаков" Одним из таких хаков явились init-only property.
2100.48 2107.48 "Анатолий Кулаков" Все мы уже довольно-таки давно привыкли к тому, что когда создается класс, через фигурные скобки мы можем инициализировать его свойства.
2107.48 2115.88 "Анатолий Кулаков" То есть изменить их значение из дефолта на то, которое нам нужно именно в месте создания, очень компактным и удобным синтексисом.
2115.88 2126.12 "Анатолий Кулаков" Большим минусом этого подхода было то, что эти свойства вынуждены были реализовывать public setter, для того чтобы можно было снаружи установить это значение.
2126.12 2133.60 "Анатолий Кулаков" Но в большинстве случаев эти свойства использовались только для инициализации, а дальше по ходу дела они менялись.
2133.60 2136.12 "Анатолий Кулаков" То есть логично было бы и сделать read-only property.
2136.12 2141.12 "Анатолий Кулаков" Но сделать мы этого не могли, потому что read-only property раньше могли меняться только в конструкторе.
2141.12 2145.52 "Анатолий Кулаков" Вот именно на это было и нацелено новое улучшение Microsoft.
2145.52 2147.04 "Анатолий Кулаков" Ключевое слово init.
2147.04 2155.96 "Анатолий Кулаков" Если вы напишите его вместо set, то компилятор поймет, что вы можете инициализировать это свойство только в момент инициализации класса.
2155.96 2164.16 "Анатолий Кулаков" Момент инициализации класса теперь является конструктор или же присваивание свойств в момент создания объекта.
2164.16 2173.52 "Анатолий Кулаков" Такие инициализационные свойства могут также обновлять read-only field, что раньше мог позволить себе делать только конструктор.
2173.52 2182.40 "Анатолий Кулаков" Благодаря этому создание рекордов стало немножко проще, потому что по умолчанию все свойства рекордов генерятся именно как инициализационные.
2182.40 2186.60 "Анатолий Кулаков" Они имеют публичный getter и публичный init.
2186.60 2194.48 "Анатолий Кулаков" Другая проблема, которая возникает сразу после того, как вы начинаете использовать immutable классы, это как их все-таки менять.
2194.48 2196.68 "Анатолий Кулаков" Обычно классы все-таки хочется менять.
2196.68 2205.68 "Анатолий Кулаков" И для того, чтобы менять неизменяемые классы, была придумана так называемая техника неразрушающего изменения - non-destructive mutation.
2205.68 2206.96 "Анатолий Кулаков" Она заключается в следующем.
2206.96 2211.28 "Анатолий Кулаков" Мы берем какой-то класс immutable и копируем его.
2211.28 2214.38 "Анатолий Кулаков" Но копируем не просто так, а с проставлением новых значений.
2214.38 2223.72 "Анатолий Кулаков" Например, если мы возьмем пользователя, который сменил фамилию, то мы должны создать точно такого же пользователя за исключением поля с фамилией.
2223.72 2225.48 "Анатолий Кулаков" Поле с фамилией мы должны проставить новым.
2225.48 2227.64 "Анатолий Кулаков" Таким образом, мы получаем новую копию этого класса.
2227.64 2232.36 "Анатолий Кулаков" И эта новая копия абсолютно неотличима от прежнего класса с измененным свойством.
2232.36 2244.04 "Анатолий Кулаков" Для того, чтобы такие операции делать быстрее, для того, чтобы такие операции делать удобнее, в новый C# введено новое ключевое слово - "with" и появляется так называемый "with expression".
2244.04 2253.08 "Анатолий Кулаков" То есть вы теперь можете указать слева имя перемены, поставить "with" и справа указать список тех полей, которые вы хотите изменить при копировании.
2253.08 2254.96 "Анатолий Кулаков" Это очень удобная техника.
2254.96 2258.88 "Анатолий Кулаков" В всех функциональных языках, например, F# она применяется довольно-таки давно.
2258.88 2261.12 "Анатолий Кулаков" Отлично себя зарекомендовала.
2261.12 2266.04 "Анатолий Кулаков" Например, она же применяется в immutable коллекциях, которые используются широко в руслении.
2266.04 2268.40 "Анатолий Кулаков" И вы можете их использовать в своем коде тоже.
2268.40 2276.44 "Анатолий Кулаков" Это, наверное, самый лучший подход, когда мы говорим о concurrent программировании для того, чтобы избежать локов.
2276.44 2283.24 "Анатолий Кулаков" Под капотом на самом деле рекорды реализует также генерятор прозрачно от пользователя, копирующий конструктор.
2283.24 2287.08 "Анатолий Кулаков" Именно благодаря этому копирующему конструктору вы можете проворачивать подобные действия.
2287.08 2293.24 "Анатолий Кулаков" То есть вы можете скопировать любой рекорд и при этом пронициализировать его дополнительные свойства какими-то новыми значениями.
2293.24 2300.52 "Анатолий Кулаков" Микрософт и дальше пошла на всякие улучшения и попыталась, наверное, улучшить декларацию свойств у рекордов.
2300.52 2304.68 "Анатолий Кулаков" Здесь есть как хорошие решения, так и, на мой взгляд, очень сомнительные.
2304.68 2315.80 "Анатолий Кулаков" Например, хорошим решением, которое изначально везде декларировалось и многие, наверное, с его синтексисом знакомы, это когда вы объявляете датакласс, вы делаете ему primary конструктор.
2315.80 2323.92 "Анатолий Кулаков" То есть прямо в объявлении можно написать список свойств, которые вы хотите присвоить этому конструктору с их типами.
2323.92 2331.80 "Анатолий Кулаков" То есть открывается круглая скобка, пишите string name, string class name и все, и рекорд вам сгенерится уже с этими свойствами.
2331.80 2334.12 "Анатолий Кулаков" Вот так есть и довольно странная тема.
2334.12 2340.20 "Анатолий Кулаков" Микрософт еще сделали изменение дефолтного поведения в декларациях.
2340.20 2341.20 "Анатолий Кулаков" Что это значит?
2341.20 2349.60 "Анатолий Кулаков" Вы можете написать датакласс person, открыть фигурную скобку и написать просто string firstname точка с запятой.
2349.60 2354.36 "Анатолий Кулаков" Если бы вы написали это в обычном классе, это бы означало, что вы создали приватное поле.
2354.36 2361.12 "Анатолий Кулаков" Но если вы напишете это в скоупе рекорда, это означает, что вы создали паблик свойства.
2361.12 2371.32 "Анатолий Кулаков" И вот это, мне кажется, очень странное решение, потому что сильно-сильно вводит в заблуждение всех начинающих и даже не только начинающих разработчиков.
2371.32 2373.48 "Анатолий Кулаков" Надеюсь, что они от него все-таки откажутся.
2373.48 2384.44 "Игорь Лабутин" А еще я видел где-то вариант, что можно прямо в конструкторе описать рекорд, то есть как будто бы мы написали конструктор, и это автоматически получился рекорд.
2384.44 2387.60 "Анатолий Кулаков" Это вот, ты, наверное, говоришь про тот вариант, который я первым упомянул.
2387.60 2388.60 "Анатолий Кулаков" Это про primary конструктор.
2388.60 2389.60 "Игорь Лабутин" Ага, да.
2389.60 2391.60 "Игорь Лабутин" Значит, я не очень понял.
2391.60 2392.60 "Игорь Лабутин" Окей.
2392.60 2393.60 "Игорь Лабутин" Хорошо.
2393.60 2398.08 "Игорь Лабутин" Ну, в общем, тема такая.
2398.08 2404.12 "Игорь Лабутин" Спорная с одной стороны, с точки зрения синтаксиса, с точки зрения применения, наверное, полезная.
2404.12 2409.72 "Игорь Лабутин" И будем смотреть, работа идет активно над этой фичей.
2409.72 2415.16 "Игорь Лабутин" Поглядим, какие решения будут приняты ближе к финальному релизу.
2415.16 2417.88 "Игорь Лабутин" Пойдем дальше по C# 9.
2417.88 2420.40 "Игорь Лабутин" И следующий пункт - это...
2420.40 2424.48 "Игорь Лабутин" Сначала, когда я его увидел, я не очень понял, зачем вообще такое может быть надо.
2424.48 2426.20 "Игорь Лабутин" Называется он Top-Level Programs.
2426.20 2434.16 "Игорь Лабутин" По сути, единственное, что он дает - это возможность в ней писать волшебную конструкцию про main функцию.
2434.16 2442.96 "Игорь Лабутин" То есть, вы можете прямо написать using system и после этого тело вашего main, там, console.writeline.hello_world или что вы хотите.
2442.96 2444.92 "Игорь Лабутин" И оно будет работать, компилироваться.
2444.92 2451.64 "Игорь Лабутин" То есть, вы можете оттуда писать return, то есть, как будто бы у вас тело main, но вот оно такое, его нет.
2451.64 2457.16 "Анатолий Кулаков" То есть, теперь стало возможным написать hello_world на C# в одну строчку, вот реально в одну строчку.
2457.16 2461.52 "Анатолий Кулаков" То есть, у вас есть файлик, файл cs, и там будет написана всего одна строка.
2461.52 2465.52 "Анатолий Кулаков" System.console.writeline.hello_world.
2465.52 2466.52 "Анатолий Кулаков" Все.
2466.52 2469.56 "Анатолий Кулаков" И это достаточно, чтобы ваша программа заработала, скомпилилась и запустилась.
2469.56 2473.00 "Игорь Лабутин" Вот я, кстати, не уверен на тему "скомпилилась".
2473.00 2484.80 "Игорь Лабутин" Возможно, что-то в тулинге поменялось, но, по-моему, по крайней мере, по состоянию несколько недель назад, было, что невозможно скомпилить cs-ник без csproj.
2484.80 2495.32 "Игорь Лабутин" То есть, csproj вам пока все-таки нужен, но есть разговоры, что, скорее всего, это тоже можно поменять и сделать так, чтобы можно было сказать dotnetrun файл.cs, и все.
2495.32 2496.48 "Игорь Лабутин" И все запустится.
2496.48 2499.96 "Анатолий Кулаков" И здесь, мне кажется, C# напрямую покушается на скриптинг.
2499.96 2505.96 "Анатолий Кулаков" У нас уже есть много скриптовых фреймворков на основании C#, наверное, самый популярный из них - это скрипт cs.
2505.96 2523.96 "Анатолий Кулаков" И после того, как у нас есть использование статических классов, то есть, using static class, и после того, как у нас есть top-level programs, и после того, как у нас есть куча синтаксического сахара в виде pattern-matching, терминальных операторов и прочего, проект скрипт cs, мне кажется, уже дышит наладом.
2523.96 2526.76 "Игорь Лабутин" Да, звучит действительно так.
2526.76 2534.16 "Игорь Лабутин" Я никогда не пробовал писать скрипты на C#, мне как-то привычнее PowerShell, но действительно становится возможным, и, может быть, это проще.
2534.16 2540.28 "Игорь Лабутин" UI мы уже будем писать на своем знакомом языке, благодаря Blazor и MyUI.
2540.28 2544.44 "Игорь Лабутин" Скрипты мы будем писать на C#, все вообще будем писать на C#.
2544.44 2551.96 "Анатолий Кулаков" В top-level program обладает довольно гибким, я бы не сказал даже интерфейсом, то есть, довольно гибким функциональностью.
2551.96 2560.52 "Анатолий Кулаков" Например, если вы хотите вернуть какой-нибудь статус-код, то раньше вам нужно было у мейна поменять void на int, и после этого могли привозить за ретурном.
2560.52 2563.24 "Анатолий Кулаков" В top-level programs ничего не надо, потому что нет у вас мейна.
2563.24 2566.24 "Анатолий Кулаков" Вы просто возвращаете int, и все.
2566.24 2568.48 "Анатолий Кулаков" И C# все отлично понимает.
2568.48 2574.76 "Анатолий Кулаков" Если вы захотите, например, сделать await в своем мейне, раньше вам нужно было пойти и изменить мейн на task.
2574.76 2579.60 "Анатолий Кулаков" Теперь нет, компилятор все отлично поймет, и вы можете вполне использовать task и await, как хотите.
2579.60 2583.92 "Анатолий Кулаков" У вас даже прокинуто магическое переменное, которое называется args.
2583.92 2588.00 "Анатолий Кулаков" Вы нигде ее не увидите, но вполне можете к ней обратиться и запросить параметры командной строки.
2588.00 2591.36 "Игорь Лабутин" Ну, в общем, готово все для того, чтобы просто взять и начать писать.
2591.36 2592.36 "Игорь Лабутин" Будем пользоваться.
2592.36 2594.12 "Игорь Лабутин" По крайней мере попробуем.
2594.12 2600.64 "Игорь Лабутин" Ты упомянул pattern matching, и pattern matching у нас уже есть в C#, но его собираются улучшить.
2600.64 2604.64 "Игорь Лабутин" И туда завезли так называемые relational patterns.
2604.64 2628.60 "Игорь Лабутин" То есть, если вы хотите, например, сделать switch выражения по какой-нибудь int переменной и сказать, что в случае, если она больше 1000, то надо выполнить что-то одно, а если меньше, то другое, то теперь вы так и можете написать "больше 1000, стрелочка, и что нужно сделать?" Или "меньше", или объединить их с помощью логических операций.
2628.60 2640.04 "Игорь Лабутин" Причем логические операции, в отличие от if-стейтментов, не два амперсанды или две вертикальных черты, а прям текстом пишутся "and", "or" и "not".
2640.04 2641.56 "Игорь Лабутин" Мне кажется вообще прекрасно.
2641.56 2646.04 "Игорь Лабутин" Особенно для скриптовых языков можно вообще зашибись писать код теперь.
2646.04 2647.04 "Анатолий Кулаков" Ну да, да.
2647.04 2649.84 "Анатолий Кулаков" Но все равно мне кажется, что как-то они pattern matching не дожали.
2649.84 2658.44 "Анатолий Кулаков" Pattern matching надо делать больше и лучше, тем более там у нас на повестке дня были discrimination unions, уже появились нормальные рекорды.
2658.44 2661.80 "Анатолий Кулаков" Мне кажется, они должны все-таки к релизу улучшить это положение дел.
2661.80 2664.24 "Анатолий Кулаков" Паттерн матчингом мы должны услышать еще много новостей.
2664.24 2674.64 "Анатолий Кулаков" Очень появилась, если говорить о полезных мелочах, очень полезная вещь, которой мне очень сильно не хватало со времен, с тех пор, как я выучил TSQL.
2674.64 2677.44 "Анатолий Кулаков" Это было очень-очень давно.
2677.44 2681.64 "Анатолий Кулаков" Часто приходилось писать такую вещь, как "if" с приведением типа.
2681.64 2690.92 "Анатолий Кулаков" Например, если я хочу проверить какое-то событие, я обычно пишу "if event is user event", то тогда делаем какой-то блок.
2690.92 2695.08 "Анатолий Кулаков" И также я сталкивался с ситуациями, когда нужно было сделать отрицание.
2695.08 2710.08 "Анатолий Кулаков" То есть вы понимаете, что нужно не просто оператор неравно сюда прицепить, а нужно теперь вот этот мой event is user event взять в скобочки, пойти в начало, и там раскрыть сательный знак, что обозначало бы нот.
2710.08 2714.48 "Анатолий Кулаков" Вот, этот ситаксис был довольно-таки уродлив для такого нашего прекрасного и красивого языка C#.
2714.48 2718.36 "Анатолий Кулаков" Он выглядел ужасно, нечитабельно и писать его неудобно.
2718.36 2720.68 "Анатолий Кулаков" Наконец-то мы сможем сделать, как нормальные люди.
2720.68 2724.56 "Анатолий Кулаков" Мы можем написать event is not user event.
2724.56 2725.56 "Анатолий Кулаков" Прямо так словами.
2725.56 2728.60 "Анатолий Кулаков" И это все скомпилируется и будет работать так, как вы этого ожидаете.
2728.60 2732.20 "Анатолий Кулаков" Мелочь, но приятная штука, я хочу сказать.
2732.20 2737.44 "Игорь Лабутин" Осталось только сделать, чтобы он теперь понимал сокращение, писать не из нота isn't, там...
2737.44 2739.44 "Игорь Лабутин" Doesn't и didn't.
2739.44 2742.16 "Игорь Лабутин" Да, doesn't, didn't и еще учитывая времена.
2742.16 2743.16 "Игорь Лабутин" Will not хочу.
2743.16 2746.36 "Игорь Лабутин" Типа, что эта перемена никогда не будет таким.
2746.36 2748.36 "Игорь Лабутин" Будет, наверное, прикольно.
2748.36 2749.36 "Игорь Лабутин" Ладно, пошли дальше.
2749.36 2755.32 "Игорь Лабутин" Еще одна полезная мелочь, которая появилась, и мы ее уже обсуждали, это improve target typing.
2755.32 2761.08 "Игорь Лабутин" Теперь если в левой части выражения явно указан тип, то в правой части выражения в определенных случаях его можно не писать.
2761.08 2766.44 "Игорь Лабутин" То есть, можно теперь объявлять словари и прочие длинные типы гораздо более коротким способом.
2766.44 2776.24 "Игорь Лабутин" И кроме того, это очень полезно для операторов, например, тернарного, где две разные части выражения приводятся к разным типам.
2776.24 2786.12 "Игорь Лабутин" Если в левой части стоит тип, к которому можно привести обе части, то теперь не нужно это делать явно, это будет сделано автоматически языком.
2786.12 2787.12 "Игорь Лабутин" Это очень приятно.
2787.12 2794.28 "Игорь Лабутин" Это полезно для всяких nullable t вариантов и так далее, потому что не для всех типов есть неявные приведения.
2794.28 2806.80 "Игорь Лабутин" В общем, общее впечатление, что у C# такие, в основном всякие мелочи улучшают, и вроде какого-то большого, такого прям сильного прогресса, ну кроме рекордов, как-то
2806.80 2809.48 "Анатолий Кулаков" и не видно. Да, да, пока слабовато.
2809.48 2812.32 "Анатолий Кулаков" А у меня есть идея, почему слабовато, почему прогресс закончился.
2812.32 2818.12 "Анатолий Кулаков" Потому что ни для кого не секрет, что все последние большие релизы C# тащил фичи из F#.
2818.12 2821.48 "Анатолий Кулаков" И кажется, что он уже практически все оттуда утащил.
2821.48 2828.56 "Анатолий Кулаков" Давайте посмотрим, что же у нас F# нам предлагает интересного, красивого и новомодного, что у него еще можно утащить.
2828.56 2836.96 "Анатолий Кулаков" И на билде у нас также были анонсированы обновления в F# 5 и в тулзах к F# 5.
2836.96 2853.08 "Игорь Лабутин" Да, обновление в F# 5 звучит очень забавно, потому что сказано, что этот релиз introduces only one new language feature, то есть весь язык предлагает одну единственную новую фичу конкретно в этом превью.
2853.08 2857.60 "Игорь Лабутин" И это интероп с default interface member, который завезли в C#.
2857.60 2859.92 "Игорь Лабутин" Поэтому они, естественно, должны были их сделать.
2859.92 2864.92 "Игорь Лабутин" А все остальное - это действительно улучшение тулинга, компиляторов, ускорения.
2864.92 2870.80 "Игорь Лабутин" И, надо сказать, довольно приличные ускорения, я смотрю, но как-то все не про язык.
2870.80 2872.44 "Анатолий Кулаков" Так, что-то так нельзя.
2872.44 2876.04 "Анатолий Кулаков" Если у F# окончатся фичи, то нам не у кого их будет красть.
2876.04 2881.80 "Анатолий Кулаков" Неужели язык умирает или фантазия у авторов кончилась, или что там случилось-то с ним?
2881.80 2883.88 "Игорь Лабутин" Нет, F#, конечно же, не умирает.
2883.88 2891.16 "Игорь Лабутин" На F# есть гораздо больше проектов и живых разработчиков по сравнению, например, с тем же Blazer, который мы обсуждали выше.
2891.16 2895.60 "Игорь Лабутин" И одного из таких разработчиков мы позвали к нам - это Вагиф Абилов.
2895.60 2902.56 "Игорь Лабутин" Он последние 4 года пишет исключительно на F#, и это не просто небольшие какие-то проектики, а большой продукт для норвежского телевидения.
2902.56 2903.56 "Игорь Лабутин" Привет, Вагиф!
2903.56 2904.56 "Игорь Лабутин" Привет!
2904.56 2912.44 "Игорь Лабутин" После MS Build есть ощущение, что C# развивается очень быстро-быстро, там C# 9, всякие новые рекорды завезли и все такое.
2912.44 2918.64 "Игорь Лабутин" А в F# как-то никаких существенных изменений или анонсов не было.
2918.64 2921.52 "Игорь Лабутин" В анонсе, по-моему, вообще практически только проэкспилятор.
2921.52 2925.12 "Игорь Лабутин" Значит ли это, что F# уже как-то никуда не двигается и он идеален?
2925.12 2932.52 "Игорь Лабутин" Или в F# 5 все-таки есть какие-то нюансы и новинки интересные, на которые стоит обратить внимание?
2932.52 2948.56 "Вагиф Абилов" Судя по тому, какое количество новых функционалов было в C# 9 завезено, складывается впечатление, что все разработчики, которые работают над фичами F#, они заняты тем, чтобы поставлять в C# все новое, что там появляется.
2948.56 2969.44 "Вагиф Абилов" Но если брать непосредственно, если более серьезно, то действительно непосредственно во время билда был такой небольшой анонс по поводу нового превью 5 F#, но там было, в основном, все сводилось к быстродействию.
2969.44 2979.28 "Вагиф Абилов" Там существенно улучшено быстродействие компилятора, то где-то процентов на 35, по словам Филиппа Картера.
2979.28 2983.76 "Вагиф Абилов" Плюс в Tooling он гораздо быстрее работает.
2983.76 2990.72 "Вагиф Абилов" Там он показывал, небольшое видео записал, вот Find All в одном небольшом проекте, у него там почти в два раза время сократилось.
2990.72 3000.04 "Вагиф Абилов" Так, вот, пожалуй, предыдущий превью, который был в марте, он содержал более значимые вещи, чем то, что сейчас было анонсировано.
3000.04 3011.36 "Вагиф Абилов" Если говорить про сам язык, то, наверное, самое существенное, что там появилось, это в вычислительных выражениях, так называемые Computational Expressions.
3011.36 3018.12 "Вагиф Абилов" Там появилась новая синтетическая конструкция AND с увелицательным знаком, AND bank.
3018.12 3033.48 "Вагиф Абилов" До этого, если есть какое-то количество выражений внутри Computational Expressions, они через LET bank делались, там LET bank x = y, и так далее.
3033.48 3037.60 "Вагиф Абилов" Все это выполнялось последовательно.
3037.60 3050.00 "Вагиф Абилов" Примерно так же, как если в C# есть последовательность EVATE, в то время как, если, скажем, все эти выражения совершенно независимы, то их можно распараллелить.
3050.00 3063.24 "Вагиф Абилов" И вот сейчас в пятом шарпе будет вот эта новая синтетическая конструкция AND с увелицательным знаком, которая будет позволять совершенно распараллельно вычислять эти выражения.
3063.24 3071.52 "Вагиф Абилов" Это соответствует примерно, если брать TPL API, там есть When All.
3071.52 3074.36 "Вагиф Абилов" По эффективности это будет сопоставимо с этим.
3074.36 3076.80 "Вагиф Абилов" Среди этого это дает большие возможности.
3076.80 3095.32 "Вагиф Абилов" Что же касается каких-то других функциональных возможностей, то много говорилось о том, что в F# с появлением .NET Core преимущество, которое многие пользовали в F#, это скриптинг, такой хороший удобный скриптинг.
3095.32 3097.56 "Вагиф Абилов" В .NET Core это работал все плохо.
3097.56 3110.00 "Вагиф Абилов" Вот через FSI интерпретатор, там тяжело было, если нужно было вытащить какие-то Nuget пакеты, все это было сложно организовать.
3110.00 3113.36 "Вагиф Абилов" То есть с этим все будет сейчас работать гораздо лучше.
3113.36 3120.92 "Вагиф Абилов" То есть уже это тоже было, сколько я помню, уже в первом превью это было, сейчас во втором это дальнейшие какие-то там были улучшения.
3120.92 3129.56 "Вагиф Абилов" Вот этот вот часть, там юпитер, ноутбуки юпитера, работа со скриптами.
3129.56 3133.04 "Вагиф Абилов" Ну плюс быстродействие.
3133.04 3146.84 "Вагиф Абилов" И что касается синтаксиса, то вот это Computational Expressions, а так, пожалуй, не очень значимые вещи, как, например, просто совместимость с тем новым, что происходит сейчас в C#.
3146.84 3149.96 "Вагиф Абилов" Там, например, Default Interface, вот такие вот вещи.
3149.96 3155.00 "Вагиф Абилов" Но это, в общем-то, для работы с F# это не так принципиально важно.
3155.00 3168.56 "Вагиф Абилов" Но вообще у меня складывается ощущение, что основной упор делается сейчас на tooling F#, и на то, чтобы его распространение, возможно, было в самых разных областях.
3168.56 3181.00 "Вагиф Абилов" Вот так же, как достаточно неожиданно, как вот он сам все время говорил, что для него это просто неожиданно, когда вдруг группа людей начала пилить вот так этот фейбл, то есть F# на клиент.
3181.00 3190.12 "Вагиф Абилов" И сейчас на F# пишется, вообще говоря, с помощью фейбла профессиональную продукцию, веб-приложение.
3190.12 3201.80 "Вагиф Абилов" И это, по-моему, тоже повлияло на то, как люди, работающие с F#, с производством F#, они формулировали свои приоритеты.
3201.80 3210.36 "Вагиф Абилов" Сам вот Дон Сайм, он больше года, по-моему, около двух лет он работал в группе Замарина, его шефом был Мигель Дейказа.
3210.36 3213.48 "Вагиф Абилов" Во время этого была работа над фейблс.
3213.48 3220.76 "Вагиф Абилов" То есть, опять же, упор был именно на приложение, чтобы применять F# в самых разных областях.
3220.76 3235.00 "Вагиф Абилов" И мне кажется, это самый главный итог сейчас, последние, может быть, пары лет работы с F#, если раньше его представляли как какой-то язык для научных вычислений, финансовых вычислений.
3235.00 3240.64 "Вагиф Абилов" Это уже было не так и неправильно уже пять лет назад, но стереотип сохранялся.
3240.64 3255.16 "Вагиф Абилов" То есть сейчас можно даже говорить о том, что он потенциально более применим в более разных областях, чем C#, если говорить, например, о том, чтобы заменять им JavaScript.
3255.16 3260.88 "Вагиф Абилов" Ну, опять же, есть, конечно, WebAssembly, VASM, это другая сторона.
3260.88 3264.28 "Вагиф Абилов" Но, по крайней мере, сейчас нет никакой области, в которой F# не был бы применим.
3264.28 3266.72 "Вагиф Абилов" И мне кажется, сейчас главный упор идёт в эту сторону.
3266.72 3268.36 "Анатолий Кулаков" Да, отличный вектор развития.
3268.36 3275.12 "Анатолий Кулаков" Слушай, а вот ты хорошо упомянул, что похоже, F#-разработчики все работают над улучшениями C#.
3275.12 3285.16 "Анатолий Кулаков" У меня тоже сложилось такое впечатление, потому что C# уже очень сильно похож на F#, и скоро просто не станет фич, который им нужно будет красть.
3285.16 3296.00 "Анатолий Кулаков" Ты не наблюдаешь вокруг себя, что F#-исты возвращаются снова на C#, потому что это более популярный язык, потому что больше вакансий, а по фичам практически C# догнал F#?
3296.00 3298.52 "Вагиф Абилов" Нет, я не наблюдал.
3298.52 3303.68 "Вагиф Абилов" Такое у нас в организации, которая работает, там я наблюдал обратное.
3303.68 3310.84 "Вагиф Абилов" У нас несколько десятков разработчиков на дот-нете, и там идёт переход как раз смены баланса в сторону F#.
3310.84 3319.48 "Вагиф Абилов" В основном то, что я сейчас сталкивался, что люди, которые перешли на F#, если есть возможность продолжать на нём работать, они продолжают.
3319.48 3326.80 "Вагиф Абилов" Хотя не странно такая возможность есть, поскольку, безусловно, язык гораздо меньше распространён, плюс некоторые, может быть, меняют платформу.
3326.80 3328.92 "Вагиф Абилов" То есть я знаю F#-ист, в который мы перешли на скалу.
3328.92 3330.24 "Вагиф Абилов" Такое тоже возможно.
3330.24 3341.64 "Вагиф Абилов" Что же касается того, что появляются функциональные какие-то элементы в C#, то всё-таки это вопрос выбора парадигмы.
3341.64 3344.80 "Вагиф Абилов" Там всё-таки совершенно принципиально объектно-ориентированный парадигма.
3344.80 3354.04 "Вагиф Абилов" И, безусловно, сейчас C# гораздо стал более приятным, на нём можно писать очень компактно, очень коротко.
3354.04 3361.08 "Вагиф Абилов" И вообще той разницы чуть ли не в два раза в количестве кода между C# и F#, её больше нет.
3361.08 3369.16 "Вагиф Абилов" Но всё равно в C# это требует определённой дисциплины, выбора правильного пути из разных этих возможностей.
3369.16 3376.36 "Вагиф Абилов" Так как F# и многие функциональные языки, они дают по умолчанию получается правильно.
3376.36 3381.88 "Вагиф Абилов" Вот это, мне кажется, очень существенная причина, по которой я бы не хотел уходить с этого языка.
3381.88 3384.48 "Анатолий Кулаков" Да, Вагиф, полностью с тобой согласен.
3384.48 3385.48 "Анатолий Кулаков" Спасибо большое.
3385.48 3388.72 "Анатолий Кулаков" Я напоминаю, что на связи с нами был Вагиф Абилов.
3388.72 3389.72 "Анатолий Кулаков" Пока.
3389.72 3390.72 "Игорь Лабутин" Всего доброго.
3390.72 3409.72 "Игорь Лабутин" А мы продолжаем и переходим к менее, может быть, заметным или менее масштабным новостям, потому что в DotNet 5, который потихонечку близится к своему релизу в конце этого года, есть некоторое количество других изменений, улучшений.
3409.72 3413.24 "Игорь Лабутин" Причём большую часть из них мы уже так или иначе обсуждали.
3413.24 3436.76 "Игорь Лабутин" То есть основной фокус, похоже, что это performance, потому что в статье прям есть один большой раздел про improve performance, где есть вещи, которые мы уже обсуждали в прошлом, это улучшение регексов, улучшение производительности работы со строками и отдельная большая работа была проведена над предсказуемостью этой самой производительности.
3436.76 3461.32 "Игорь Лабутин" То есть нужно не только, чтобы DotNet-приложение в бенчмарках было хорошо и в каких-то искусственных тестах, но и чтобы в реальной жизни, в продакшене, где мы меряем далеко не средние, мы зачастую меряем различные перцентили, то вот именно в таких условиях производительность должна быть хорошей или предсказуемой.
3461.32 3483.76 "Игорь Лабутин" И это означает, что большой фокус получили такие вещи как Garbage Collection, потому что это, наверное, одна из самых главных причин, почему в приложении могут быть различные паузы, потому что если Garbage Collection останавливает целиком все приложение, естественно останавливается обработка запросов и с точки зрения клиента возрастает время ответа.
3483.76 3493.04 "Игорь Лабутин" И поэтому была проведена определенная работа над сборщиком мусора, чтобы уменьшить как раз-таки паузы Garbage Collector в определенных ситуациях.
3493.04 3504.28 "Игорь Лабутин" Кроме этого, начиная с недавних времен, у нас есть Tired JIT, который тоже, как известно, может решить, что пора перекомпилить метод.
3504.28 3518.24 "Игорь Лабутин" И сама эта перекомпиляция происходит в бэкграунде и подмена метода, она практически мгновенная, но чтобы обосновать свое решение, что какой-то метод пора перекомпилить, JIT на самом деле считает, сколько тот или иной метод вызывается.
3518.24 3522.64 "Игорь Лабутин" И вот этот вот подсчет, он естественно влияет на performance.
3522.64 3530.64 "Игорь Лабутин" Казалось бы, он очень маленький, всего-то там счетчик увеличить, но все-таки это происходит для каждого, вызова каждого метода.
3530.64 3536.00 "Игорь Лабутин" Поэтому улучшения в этом механизме, они тоже довольно сильно влияют на предсказуемость.
3536.00 3549.96 "Игорь Лабутин" И наверное самое такое заметное нововведение, которое даже получило свое собственное API, то есть вы можете им пользоваться и вам даже рекомендуется этим пользоваться, это новый heap.
3549.96 3559.48 "Игорь Лабутин" Мы давно привыкли, что у нас есть small object heap с тремя поколениями 0, 1, 2 и отдельный large object heap, куда попадают объекты больше чем 85 тысяч байт.
3559.48 3563.32 "Игорь Лабутин" Теперь у нас есть новый heap, называется pinned object heap.
3563.32 3578.76 "Игорь Лабутин" Проблема с запиненными объектами в том, что они не перемещаются в памяти и естественно, когда мы делаем дефрагментацию кучи, то их невозможно переместить и соответственно невозможно полностью кучу дефрагментировать.
3578.76 3590.28 "Игорь Лабутин" Это с одной стороны, с другой стороны, если мы говорим про large object heap, где даже если дефрагментация не делается, они все равно каким-то образом раскиданы по этой куче и возможно не дают зааллоцировать большие блоки памяти.
3590.28 3598.16 "Игорь Лабутин" Теперь у вас есть возможность сказать garbage collector, что тот массив, который вы allocated прямо сейчас, будет запинен вами.
3598.16 3610.64 "Игорь Лабутин" И тогда этот массив попадает в специальную кучу, pinned object heap, и он не будет мешаться, соответственно, в основных кучах работать garbage collector и дефрагментировать такую кучу.
3610.64 3620.52 "Игорь Лабутин" Это на самом деле хорошее улучшение, потому что по моему опыту обычно вы заранее знаете, будете вы работать с этим массивом как с запиненным, или все-таки не будете.
3620.52 3626.36 "Игорь Лабутин" И очень редко это выясняется задолго после того, как массив уже создан.
3626.36 3630.16 "Игорь Лабутин" Так что это нам тоже сильно поможет в оптимизации работы с памятью.
3630.16 3637.64 "Игорь Лабутин" Кроме этого, есть еще ряд улучшений, которые мы немножко обсуждали, однако в них тоже есть изменения.
3637.64 3656.36 "Игорь Лабутин" Мы какое-то количество выпусков назад обсуждали single file applications, то есть возможность запаковать dotnet приложение как один файл, но на тот момент это был по сути zip архив с небольшим bootstrapper, который распаковывался и запускал уже ваше полноценное приложение откуда-то там из temp фолдера или еще откуда-нибудь.
3656.36 3671.16 "Игорь Лабутин" Сейчас ведется работа над полноценным single file application, то есть это будет бандл запускаемый, в котором все dll и все остальное запаковано внутри и не распаковывается на диск, а в рантайме достается прямо из бандла и отдается запущенному приложению.
3671.16 3680.44 "Игорь Лабутин" Это вообще то, что нужно для всяких tools и прочих таких скриптоподобных приложений.
3680.44 3693.96 "Игорь Лабутин" Кроме этого, поддержку ARM64 мы уже обсуждали, улучшение работы с контейнерами мы тоже обсуждали, что ведется работа по уменьшению размера докера имиджа, чтобы дотнет фреймворк занимал поменьше.
3693.96 3700.68 "Игорь Лабутин" И, наверное, последнее, что хочется здесь сказать, это про JSON сериализацию.
3700.68 3719.76 "Игорь Лабутин" Как мы уже обсуждали, опять же, дотнет теперь имеет свой собственный встроенный платформенный сериализатор от Майкрософта, и все бы хорошо, но очевидно, что большая часть кода в мире сейчас живет на Newtonsoft JSON, скорее всего, как в наиболее популярном NuGet-пакете для JSON сериализации.
3719.76 3740.16 "Игорь Лабутин" И поэтому Майкрософт выпустила большую статью на тему того, что нужно делать, если вы хотите смигрировать с Newtonsoft JSON на новый System Text JSON с подробнейшими примерами, с разбором, какие фичи поддержаны в одном пакете и не поддержаны в другом, чем их заменять, как вообще менять код.
3740.16 3751.80 "Игорь Лабутин" Огромная длинная статья, ссылка будет в шоу-ноутах, если вы раздумываете о том, чтобы перейти на System Text JSON, то ознакомьтесь, там будет все подробно описано, и вы поймете, что и как делать.
3751.80 3761.32 "Анатолий Кулаков" Без лишней помпезности Visual Studio обновилась, вышли ее минорные версии, которые в последнее время начали выходить довольно-таки часто.
3761.32 3765.72 "Анатолий Кулаков" Игорь, там что-нибудь, кроме того, что быстрее стали воровать у ReSharper фичи появилось?
3765.72 3767.88 "Игорь Лабутин" В целом, да.
3767.88 3780.08 "Игорь Лабутин" Хотя я, признаться, иногда довольно с трудом слежу за всякими отличиями там 16.4, 5, 6, и ниже еще у каждой есть превью, в которых тоже выходят фичи.
3780.08 3797.04 "Игорь Лабутин" В целом, из того, что было объявлено в 16.6, и то, что было объявлено раньше в превью, но теперь это официально зарелизили, это улучшение в Snapshot-дебаггинге, новый тул для отладки Async-приложений, .NET Async-тул.
3797.04 3801.00 "Игорь Лабутин" К сожалению, я еще не успел его попробовать.
3801.00 3807.24 "Игорь Лабутин" Когда попробую, если будет что интересное рассказать, то мы это включим в один из следующих выпусков.
3807.24 3811.04 "Игорь Лабутин" Новые рефакторинги, QuickActions, терминал.
3811.04 3821.76 "Игорь Лабутин" То есть теперь в Visual Studio есть встроенный терминал, где можно открыть CMD, PowerShell, VSL и работать оттуда, практически как в райдере, как я понимаю.
3821.76 3824.80 "Игорь Лабутин" И различные улучшения C++ и всяких таких штук.
3824.80 3837.00 "Игорь Лабутин" Из таких интересных фич, не фич, но они все еще слегка в превью, скажем так, это .NET Core WinForms Designer.
3837.00 3845.12 "Игорь Лабутин" То есть, как мы помним, WinForms и WPF работают под .NET Core, но вот .NET Core и WinForms Designer почему-то не завезли с самого начала.
3845.12 3851.20 "Игорь Лабутин" Над ним поработали еще, сейчас он практически полнофункционален, но его нужно включать в отдельном настройках, как превью.
3851.20 3859.56 "Игорь Лабутин" И немножко улучшили интерфейс работы с Git, поудобнее стало выбирать бранчи и поудобнее понимать вообще, откуда эти бранчи берутся.
3859.56 3867.56 "Игорь Лабутин" В целом, наверное, все то, что касается 16.6 и 16.7 превью.
3867.56 3874.76 "Игорь Лабутин" Единственное, в 16.7 превью 1 появилась одна полезная фича, если вы XAML-разработчик.
3874.76 3879.00 "Игорь Лабутин" Как известно, в XAML бывает такая штука, как Binding Failures.
3879.00 3889.60 "Игорь Лабутин" То есть, если вы опечатались в названии Binding или Property, или как-то неправильно применили темплейт, у вас будут не работать, соответственно, Binding.
3889.60 3900.72 "Игорь Лабутин" Но чтобы получить какую-то информацию о том, почему он не работает и какой Binding, для этого нужно было включать специальные Binding логи, и в общем, это было не очень удобно и это было только в рантайме.
3900.72 3908.72 "Игорь Лабутин" Сейчас в версии 16.7 превью 1 появился специальный тун по поиску этих Binding Failures.
3908.72 3919.20 "Игорь Лабутин" То есть, это отдельное окошечко, которое вам прям покажет, что вот тут у вас неправильно напечатано, вот тут Binding не сработает, тут мы не найдем, почему при Binding и так далее.
3919.20 3922.92 "Игорь Лабутин" Это тоже превью фичи нужно включать через Options Environment Preview Features.
3922.92 3933.40 "Игорь Лабутин" В целом, в XAML они тоже улучшают, но такие мелочи типа цвета теперь показывают прямо в разметке правильным цветом и так далее.
3933.40 3939.20 "Игорь Лабутин" То есть, удобные мелочи, но ничего такого прям супер-серьезного пока больше не видно.
3939.20 3941.80 "Анатолий Кулаков" Хорошо, тогда пойдем дальше.
3941.80 3948.56 "Анатолий Кулаков" Также новые фичи нам декларирует новый Entity Framework Core, который выпустил 4 превью 5 версии.
3948.56 3953.32 "Игорь Лабутин" Entity Framework Core, с ним ситуация интересная.
3953.32 3961.32 "Игорь Лабутин" Все те превью, которые были на данный момент, это четвертые, они улучшают какие-то небольшие кусочки.
3961.32 3978.52 "Игорь Лабутин" То есть, из интересного в прошлом превью, например, в третьем, были фильтры, то есть, можно теперь писать в инклудах прямо внутри лямбды с Wear и прочими штуками, которые корректно сконвертируются в правильные Joyner и Wear.
3978.52 3998.08 "Игорь Лабутин" В четвертом превью появились какие-то специфические штуки для индексов и настройки баз данных, в смысле, что вы можете для конкретной колонки задать Precision, если это поддерживается вашей базой данных, типа Decimal и так далее.
3998.08 4006.60 "Игорь Лабутин" Или SQL Server Index Fill Factor, теперь все это можно задать в виде методов расширения прямо в вашем Model Builder.
4006.60 4012.36 "Игорь Лабутин" Что интереснее в Entity Framework 5.0, это их дальнейшие планы.
4012.36 4028.56 "Игорь Лабутин" Есть статья на docs.microsoft.com, где описана родмап команды Entity Framework 5.0, и там, в частности, есть очень интересная штука, которая мне понравилась и заинтересовала, это Migrations.
4028.56 4040.00 "Игорь Лабутин" Они планируют довольно серьезно переделать Migrations и вынести их из основного, так скажем, ну не потока выполнения, а из основного приложения.
4040.00 4046.88 "Игорь Лабутин" Сейчас, по крайней мере в тех проектах, где я работаю с Entity Framework, по сути, миграции накатываются в момент старта приложения.
4046.88 4056.72 "Игорь Лабутин" Можно отдельно сказать EF, UP или еще что-нибудь в таком духе, но один из способов это накатить миграцию во время старта приложения.
4056.72 4072.04 "Игорь Лабутин" Команда считает, что это не всегда удобно и они планируют сделать отдельный именно тул, даже не привязанный к EF, который будет как-то внешне накатывать миграции в момент деплоймента вашего приложения или что-то в таком духе.
4072.04 4075.32 "Игорь Лабутин" То есть, standalone тул, который будет как-то это делать.
4075.32 4088.00 "Игорь Лабутин" Это пока все в очень ранней стадии и надо следить, что будет реально происходить, но вот это, наверное, самая большая фича из их плана по изменению Entity Framework.
4088.00 4097.24 "Игорь Лабутин" Но возможно не последняя, потому что это очень далекий план и, конечно, релиз вроде как уже довольно близко, но возможно что-то еще успеет поменяться.
4097.24 4099.04 "Анатолий Кулаков" Отлично, будем следить за новостями.
4099.04 4109.00 "Анатолий Кулаков" Еще на билде было объявлено очень много всего, не касающееся дотнет разработки, потому что билд это в принципе в общем про Микрософт, про его путь, про его анонсы.
4109.00 4118.20 "Анатолий Кулаков" Там было много всякой ажуры и прочего безобразия, но были интересные новости, которые, хоть и не формат, но хотелось бы углянуть.
4118.20 4121.64 "Анатолий Кулаков" Потому что косвенно дотнет разработчикам может быть это интересно.
4121.64 4126.56 "Анатолий Кулаков" Например, вышел Windows-терминал, заредизовался версия 1.0.
4126.56 4136.12 "Анатолий Кулаков" Этот терминал известен тем, что он снял наикрутейший ролик в 3D-графике с красивыми анимациями и заполонил просто всю сеть.
4136.12 4154.24 "Анатолий Кулаков" А если же серьезно, то это наконец-то современный терминал от Микрософта, которая начала в последнее время обращать внимание на командную строку, узнала, что там есть не только примитивные цвета, что там есть еще возможность для того, чтобы делать какие-то скоростные вещи, для вывода графики.
4154.24 4161.60 "Анатолий Кулаков" И новый Windows-терминал, например, поддерживает GPU-рендеринг, то есть он рендерится полностью на GPU.
4161.60 4167.28 "Анатолий Кулаков" У него есть современный UI, который выглядит довольно-таки прилично.
4167.28 4168.28 "Анатолий Кулаков" У него есть таблики.
4168.28 4178.68 "Анатолий Кулаков" На самом деле это всего лишь терминал, то есть под ним запускается обычный привычный вам PowerShell, VSL или старый Command Prompt.
4178.68 4185.68 "Анатолий Кулаков" У него есть панели, которые вы могли бы знать, если бы общались с такой территорией, как Screen.
4185.68 4190.28 "Анатолий Кулаков" У него нативный Unicode и UTF-10 поддержка.
4190.28 4195.08 "Анатолий Кулаков" А также можно писать кастомные темы, можно очень гибко его конфигурировать.
4195.08 4200.16 "Анатолий Кулаков" Сам терминал находится в Open Source и доступен для скачивания из Microsoft Store.
4200.16 4206.28 "Анатолий Кулаков" Также Microsoft уделила внимание самой теме скачивания и анонсировала Windows Package Manager.
4206.28 4212.44 "Анатолий Кулаков" Если вы пользовались, например, Chocolaté, то уже знакомы с этой темой.
4212.44 4219.08 "Анатолий Кулаков" Тем более, если вы пользовались какими-то ринексовыми системами или MacOS, то там без Package Manager вообще никто никогда не живет.
4219.08 4221.08 "Анатолий Кулаков" Все программы, в основном, строятся только через него.
4221.08 4223.92 "Анатолий Кулаков" Никаких вот этих вам дурацких кликов в браузере.
4223.92 4230.12 "Анатолий Кулаков" .NET разработчики тоже уже давно привыкли пользоваться Nuget, который, по сути, является таким же Package Manager.
4230.12 4239.24 "Анатолий Кулаков" Теперь пользователи Windows тоже могут точно так же у себя в командной строке с помощью команды winget устанавливать поддерживаемые пакеты.
4239.24 4241.04 "Анатолий Кулаков" Сам Package Manager open-source.
4241.04 4245.64 "Анатолий Кулаков" Также стоит отметить, что отдельно существуют репозитории, куда принимаются pull-requests.
4245.64 4253.80 "Анатолий Кулаков" И в этих pull-requests вы можете декларативно описать с помощью YAML те пакеты, которые будет поддерживать этот Package Manager.
4253.80 4255.76 "Анатолий Кулаков" Под капотом он у себя ничего не хранит.
4255.76 4257.04 "Анатолий Кулаков" Например, как это делает Nuget.
4257.04 4260.72 "Анатолий Кулаков" То есть нет какого-то главного Nuget-сервера, из которого все качают.
4260.72 4265.28 "Анатолий Кулаков" Основная задача winget-а это все-таки достать манифест, в котором объявлено имя программы.
4265.28 4269.60 "Анатолий Кулаков" В этом манифесте написано, откуда ее нужно скачать и как правильно проинсталлировать систему.
4269.60 4270.68 "Анатолий Кулаков" Именно этим он занимается.
4270.68 4273.96 "Анатолий Кулаков" Он еще в превью, то есть это еще не релиз.
4273.96 4275.80 "Анатолий Кулаков" В частности, он не умеет удалять.
4275.80 4277.16 "Анатолий Кулаков" К релизу обещал научиться.
4277.16 4282.80 "Анатолий Кулаков" И к релизу еще будет много интересных разных плюшек.
4282.80 4291.16 "Анатолий Кулаков" Windows Subsystem for Linux, вторая версия, наконец-то завезла к себе настоящий Linux kernel, который написан Microsoft и будет поддерживаться Microsoft.
4291.16 4295.28 "Анатолий Кулаков" То есть это не какая-то эмуляция на уровне API, как было в первом VSL.
4295.28 4298.92 "Анатолий Кулаков" Это 100% совместимый по API kernel.
4298.92 4302.04 "Анатолий Кулаков" То есть все программы 100% будут на нем работать.
4302.04 4304.36 "Анатолий Кулаков" Также Microsoft нацелилась на интересную штуку.
4304.36 4309.56 "Анатолий Кулаков" Она хочет поддержать графические приложения со стороны Linux.
4309.56 4311.72 "Анатолий Кулаков" То есть линуксовские графические приложения.
4311.72 4321.04 "Анатолий Кулаков" Пока не очень понятно, зачем это может быть нужно, потому что та ниша, где линуксовые графические приложения есть и при этом недоступны на Windows, она довольно-таки маленькая.
4321.04 4327.76 "Анатолий Кулаков" Но если говорить о том, что Microsoft хочет с собой покрыть весь Linux, это вот такой хороший отличный плюс.
4327.76 4332.56 "Анатолий Кулаков" Многие программы под Linux достаточно удобные и переносить авторы их принципиально, например, не хотят.
4332.56 4335.88 "Анатолий Кулаков" И таких авторов тоже можно сейчас легко будет наколоть.
4335.88 4338.08 "Анатолий Кулаков" Также Microsoft запустила LearnTV.
4338.08 4351.32 "Анатолий Кулаков" Это ежедневная программа, в которой микрософтовские адвокаты и всякие темлиды и прочие разработчики делятся своим опытом, учат вас, как правильно разрабатывать, учат вас, как правильно расти, как разработчика.
4351.32 4353.28 "Анатолий Кулаков" Контент ежедневно пополняется.
4353.28 4356.92 "Анатолий Кулаков" Я думаю, будет весьма интересен для начинающих разработчиков.
4356.92 4360.28 "Анатолий Кулаков" Вообще на Build случилось очень много всяких анонсов.
4360.28 4367.00 "Анатолий Кулаков" Некоторые тулзы мы оставим, наверное, на следующий выпуск, потому что сейчас у нас уже не хватает времени, чтобы обсудить все.
4367.00 4373.16 "Анатолий Кулаков" Поэтому следите за нашими новостями, подписывайтесь на наши новые выпуски и до новых встреч.
4373.16 4379.16 "Игорь Лабутин" Прежде чем мы попрощаемся, надо сказать, что у Microsoft есть отличный каталог всех новостей Microsoft Build.
4379.16 4383.56 "Игорь Лабутин" Ссылка будет в шоу-ноутах, поэтому если вы хотите ознакомиться со всеми новостями, сходите туда.
4383.56 4388.88 "Игорь Лабутин" Они там хорошо рассортированы по темам и их можно хорошо искать и фильтровать.
4388.88 4390.96 "Игорь Лабутин" А на этом действительно все.
4390.96 4391.96 "Игорь Лабутин" Пока.
