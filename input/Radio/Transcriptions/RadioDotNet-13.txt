0.00 5.48 "Анатолий Кулаков" Всем привет, дорогие друзья.
5.48 8.96 "Анатолий Кулаков" С вами Радио.нет, выпуск номер 13.
8.96 16.36 "Анатолий Кулаков" Мы вернулись из спонтанного летнего отпуска и продолжаем просвещать вас в курсе самых интересных новостей.
16.36 19.40 "Анатолий Кулаков" В студии для вас работает Анатолий Кулаков.
19.40 21.16 "Анатолий Кулаков" И Игорь Лабутин, как обычно.
21.16 29.44 "Анатолий Кулаков" И как только я вернулся из прекрасного теплого края, меня сразу же ошарашило письмо из .net foundation.
29.44 37.40 "Анатолий Кулаков" И говорит оно, что мой аккаунт, мое членство в .net foundation под угрозой, потому что в моем гитхабе нет 2FA.
37.40 43.76 "Анатолий Кулаков" И если я не сделаю 2FA до 15 числа, то меня ни много ни мало просто-напросто выкинут из foundation.
43.76 45.40 "Анатолий Кулаков" Представляешь, какие хамы вообще.
45.40 48.16 "Игорь Лабутин" Мне кажется, мне срочно надо проверить мою почту.
48.16 52.44 "Анатолий Кулаков" Вот казалось бы, какой-то безобидный 2FA и все, и тебя лишают всех регалий.
52.44 59.16 "Анатолий Кулаков" Поэтому если вдруг кто-то еще не установил и состоит в .net foundation, то скорее ставьте себе 2FA.
59.16 63.56 "Анатолий Кулаков" А если вы еще не там, то добавляйтесь, там весело, много интересных новостей.
63.56 69.08 "Анатолий Кулаков" И право голосовать за команду, которая управляет .net foundation.
69.08 75.08 "Анатолий Кулаков" Кстати, у них недавно прошли выборы в их новый программный комитет, из которого выбрали кучу непонятного народа.
75.08 76.68 "Анатолий Кулаков" Я знаю только две фамилии.
76.68 79.40 "Анатолий Кулаков" Это Шон Вальдеморф и Билл Вагнер.
79.40 84.28 "Анатолий Кулаков" Первый это известный блогер, хотя и у него лайтовые статейки, но пишет он довольно много и интересно.
84.28 88.56 "Анатолий Кулаков" Ну, а Билл это известный разработчик C#, у которого много интересных лекций.
88.56 93.56 "Анатолий Кулаков" И мне кажется, это единственный технически продвинутый человек среди всей этой тусовки.
93.56 97.84 "Анатолий Кулаков" Поэтому будем надеяться, что .net foundation не уйдет в какие-то тартарары.
97.84 100.52 "Анатолий Кулаков" Все-таки там есть какие-то технические светлые головы.
100.52 106.24 "Анатолий Кулаков" Также в этом письме мне сообщили, что .net foundation запускает новый проект, называется Project Spotlight.
106.24 113.48 "Анатолий Кулаков" Его задача состоит в том, чтобы освещать те проекты, те github-репозитории, которые ходят сейчас в .net foundation.
113.48 115.56 "Анатолий Кулаков" И я думаю, что .net foundation занимается именно этим.
115.56 120.28 "Анатолий Кулаков" Он собирает интересные проекты, популярные проекты на github и всячески их поддерживает.
120.28 122.84 "Анатолий Кулаков" Что конкретно входит в поддержку, я понятия не имею.
122.84 126.36 "Анатолий Кулаков" Нужно расспросить, например, у Андрея, как только он к нам придет в гости.
126.36 129.48 "Анатолий Кулаков" Потому что бенчмарк .net тоже входит в этот foundation.
129.48 134.76 "Анатолий Кулаков" Но в качестве одной из поддержек наверняка это реклама.
134.76 139.28 "Анатолий Кулаков" И вот именно таким рекламным средством является Project Spotlight.
139.28 149.36 "Анатолий Кулаков" Поэтому если вам интересно знакомиться с какими-то библиотеками хорошими, качественными, протестированными, надежными, касающимися .net, скорее всего Project Spotlight вам будет очень интересен.
149.36 153.20 "Анатолий Кулаков" Если вы подпишетесь на него, вам будут регулярно сообщать новости.
153.20 157.84 "Анатолий Кулаков" Нет, даже не новости, а вам будут регулярно сообщать описание этих библиотек.
157.84 160.00 "Анатолий Кулаков" То есть, что там есть, какие там авторы.
160.00 162.16 "Анатолий Кулаков" Там выйдут интервью с авторами.
162.16 164.36 "Анатолий Кулаков" Там будет краткое описание.
164.36 167.56 "Анатолий Кулаков" В общем, что вам может понадобиться в повседневной работе.
167.56 170.64 "Анатолий Кулаков" И первый выпуск Spotlight просвещен кейку.
170.64 174.88 "Анатолий Кулаков" Это такая билд-тулзень, которая призвана заменить MS Build.
174.88 179.28 "Анатолий Кулаков" И главной ее фишкой должно быть то, что все скрипты пишутся на C#.
179.28 184.76 "Анатолий Кулаков" То есть, любой C# программист в удобной для себя среде, с удобным языком якобы сядет и будет писать.
184.76 204.60 "Анатолий Кулаков" Но реальность такова, что за все эти годы, существует он уже больше пяти лет, по-моему, они так и не смогли добиться, чтобы в C# у них появился IntelliSense, не смогли добиться нормальной подсветки синтаксиса, и у них там такой ужасный API, что никакой C# программист без бутылки с ним вообще не разберется.
204.60 208.60 "Анатолий Кулаков" Документация вся автосгенерированная плохая, плагины все глючные.
208.60 214.72 "Анатолий Кулаков" В общем, как этот инструмент является самой популярной билд-системой, ну, исключая MS Build, конечно.
214.72 218.76 "Анатолий Кулаков" Насобирал столько множества звезд и контрибьюторов, для меня до сих пор является загадкой.
218.76 225.68 "Анатолий Кулаков" Если вы смотрите на что-то, что заменяет MS Build и пишет на C#, посмотрите обязательно на Nuke.
225.68 228.24 "Анатолий Кулаков" Вот Nuke, мне кажется, это то, что нам нужно.
228.24 237.68 "Анатолий Кулаков" Я еще глубоко его не копал, но он точно лучше Cake хотя бы тем, что у него есть IntelliSense, подсветка синтаксиса, дебаг и все, что вы нажидаете от нормальной C# программы.
237.68 244.56 "Анатолий Кулаков" Еще один интересный проект, который пришел мне в письмеце того же .NET Foundation, новая страничка с .NET Meetup.
244.56 252.16 "Анатолий Кулаков" Во время пандемии все .NET Meetup перевелись в онлайн, и теперь их гораздо легче стало воспринимать с любой точки нашей планеты.
252.16 269.20 "Анатолий Кулаков" Поэтому если вы ищете каких-то митапчиков на английском языке для того, чтобы посмотреть, познакомиться с различными темами, заходите на .NET Meetup, и там вы найдете множество митапов, множество записей, множество интересного общения с англоговорящими спикерами.
269.20 285.20 "Игорь Лабутин" Ну, надо сказать, что там не только англоговорящие, то есть я как раз сейчас зашел на эту страничку, там сказано, что митапы в 66 странах, то есть я больше, чем уверен, что там есть митапы не только на английском, и всего там перечислено 366 митапов на данный момент.
285.20 287.92 "Игорь Лабутин" Среди них, кстати, есть и российские.
287.92 293.68 "Игорь Лабутин" Что странно, я не вижу там всех наших российских .NET Meetup, надо это как-то будет исправить.
293.68 295.52 "Анатолий Кулаков" Ну, может быть, не только англоговорящие.
295.52 300.76 "Анатолий Кулаков" Я просто все время натыкаюсь на анонсы, на промоушены, и там всегда англоязычные доклады.
300.76 317.24 "Анатолий Кулаков" Наверное, потому что промоутеры, они только своих, а карта там действительно всех локальных митапов, то есть во всех странах, если вы вдруг куда-то собираетесь путешествовать и захотите где-нибудь приятно провести время, то обязательно зайдите на карту митапов и посмотрите, там есть практически в каждой стране.
317.24 325.48 "Анатолий Кулаков" Вот, отвечая на твой вопрос, почему не все наши, потому что есть некоторые условия, которые вынуждены соблюдать сообщество для того, чтобы попасть на эту карту.
325.48 330.08 "Анатолий Кулаков" В частности, это вести свои митапы на митапкоме, вести свои анонсы.
330.08 339.88 "Анатолий Кулаков" И так как наше сообщество в большинстве случаев довольно ленивое и помощников им не хватает, то есть некогда вести митапы во всех социальных сетях.
339.88 343.60 "Анатолий Кулаков" Вот, поэтому они не заводят свою страничку на митапкоме.
343.60 348.64 "Анатолий Кулаков" Если вдруг у вас есть лишние руки или лишние 5 минут в месяц, то вы нам можете в этом помочь.
348.64 354.00 "Игорь Лабутин" Понял, просто было немножко странно не видеть всех наших больше десятка городов на этой карте.
354.00 360.88 "Игорь Лабутин" Ну ладно, .NET Foundation .NET Foundation, но мы все-таки в том числе и про технические штуки хотим поговорить.
360.88 371.44 "Игорь Лабутин" И конечно же за время нашего отпуска произошло много изменений в .NET 5, вышло аж 2 новых превьюшки, 7 и 8, и про них хочется немножко рассказать.
371.44 380.60 "Игорь Лабутин" Как обычно, поделим это на блоки и начнем с классического .NET, не трогая пока SPNET и все остальное.
380.60 389.60 "Игорь Лабутин" Из хайлайтов изменений в .NET 5 можно сказать, что в очередной раз допилили System Text JSON сериализацию.
389.60 394.48 "Игорь Лабутин" Она теперь умеет корректно обрабатывать циклические ссылки при десериализации.
394.48 399.96 "Игорь Лабутин" Это было, по-моему, одно из таких довольно важных отличий от Newton Soft JSON, который это умел.
399.96 406.24 "Игорь Лабутин" И второе, она умеет теперь игнорить значение по умолчанию при сериализации value types.
406.24 418.92 "Игорь Лабутин" Звучит довольно сложно, но по факту это означает, что если у вас в интовом поле в структурке лежит ноль, то можно научить сериализатор такой нолик не сериализовывать в JSON, добившись таким образом довольно-таки компактного JSON.
418.92 421.00 "Игорь Лабутин" Возможно, в каких-то случаях вам это пригодится.
421.00 422.00 "Игорь Лабутин" Garbage Collector.
422.00 428.48 "Игорь Лабутин" В целом изменений не так много, и самое главное это больше такая информационная штука.
428.48 438.04 "Игорь Лабутин" Добавилась новая IP gc.getmemoryinfo, и она возвращает структуру ковка, где написана полнейшая информация о последнем Garbage Collection, который произошел.
438.04 451.16 "Игорь Лабутин" Со всеми там показателями по всем поколениям, сколько там какой памяти оставалось, сколько заняло это CPU, сколько заняло это времени, сколько там заняли простои, сколько занял сам сборка мусора.
451.16 456.44 "Игорь Лабутин" Это может быть вам полезно, если вы это пишете у себя как-то где-то в логах, возможно, либо как-то анализировать.
456.44 462.80 "Игорь Лабутин" То есть теперь можно из самого приложения узнать больше подробностей про то, какой же Garbage Collection только что произошел.
462.80 465.40 "Игорь Лабутин" Ну или не обязательно только что, но последним.
465.40 467.36 "Анатолий Кулаков" Ну, странно это дергать как бы каждый раз.
467.36 471.96 "Анатолий Кулаков" Тебе нужно после каждого Garbage Collector дергать этот метод, чтобы записать в свою аналитику.
471.96 474.12 "Анатолий Кулаков" Хотелось бы каких-то более реактивных интерфейсов.
474.12 483.68 "Игорь Лабутин" Да, если мы хотим действительно как-то динамически влиять на то, как он живет, нам действительно хотелось бы, наверное, как-то подписаться на уведомления или еще что-то.
483.68 490.88 "Игорь Лабутин" Но по факту я думаю, что эта штука нужна для именно там периодически какой-то информирования.
490.88 500.08 "Игорь Лабутин" То есть, допустим, раз там в несколько не знаю что минут скидывать эту инфу в какой-нибудь лог или там в ту же Prometheus или еще куда-нибудь.
500.08 501.40 "Игорь Лабутин" И просто анализировать.
501.40 509.12 "Игорь Лабутин" Если вы видите, что время, допустим, проведенное в Garbage Collection потихонечку растет, то, наверное, это какой-то плохой признак.
509.12 510.44 "Игорь Лабутин" Можно на этом построить какие-нибудь алерты.
510.44 513.00 "Игорь Лабутин" То есть, я пока не вижу каких-то юзающих сценариев.
513.00 517.16 "Игорь Лабутин" Я вполне допускаю, что эту штуку Microsoft сделала в том числе для каких-то внутренних нужд.
517.16 522.64 "Игорь Лабутин" Но, тем не менее, всегда интересно узнать какую-то инфу про то, как она работает внутри.
522.64 532.88 "Игорь Лабутин" Дальше идет нововведение, с которым я, можно сказать, столкнулся лоб в лоб буквально недавно, когда писал логеры для, правда, .NET Core 3 приложения.
532.88 537.04 "Игорь Лабутин" Но, тем не менее, мне нужен был консольный логер, который бы выводил все в JSON.
537.04 543.24 "Игорь Лабутин" И как-то так сложилось, что можно, конечно, было взять Serilog, где есть автоматический синк на это дело.
543.24 548.20 "Игорь Лабутин" Но как-то сложилось, что уже была небольшой и хотелось как-то обойтись штатными способами.
548.20 553.44 "Игорь Лабутин" По факту, ну, единственная версия - это писать просто свой собственный консольный логер.
553.44 557.76 "Игорь Лабутин" Это несложно, но как-то очень затратно и зачем.
557.76 561.08 "Игорь Лабутин" Microsoft, наконец-таки, сделал консольный логер, который стандартный.
561.08 562.08 "Игорь Лабутин" Он конфигурируем.
562.08 565.80 "Игорь Лабутин" Теперь можно задать паттерны того, как это все будет выводиться в строчку.
565.80 568.84 "Игорь Лабутин" Можно сделать две строчки, как стандартно, можно в одну.
568.84 575.48 "Игорь Лабутин" И они сделали даже стандартный, так сказать, паттерн для вывода это все в JSON сразу.
575.48 581.68 "Игорь Лабутин" То есть, можно теперь из готового .NET 5 SDK получить JSON-логирование в консольку.
581.68 586.64 "Игорь Лабутин" Исходно этот ишью был открыт Джоном Скитом, который тоже очень хотел эту фичу.
586.64 587.64 "Анатолий Кулаков" Очень мило.
587.64 596.56 "Анатолий Кулаков" Я так понимаю, что в основном такой способ рекомендуется, когда ваш инструмент пакуется в докере, то есть, писать все логи просто в output на консоль.
596.56 603.96 "Анатолий Кулаков" А дальше какими-то инструментами уже докера все эти консоли собираются, агрегируются и отправляются дальше по пайплайну в какое-то логохранилище.
603.96 605.32 "Анатолий Кулаков" Поэтому не такой редкий случай.
605.32 615.72 "Игорь Лабутин" Да, потому что из докера работать с какими-то файловыми системами или делать хуже того какие-нибудь роллинг-файлы, потому что в один большой файл вы писать, конечно же, не будете.
615.72 616.72 "Игорь Лабутин" Ну, зачем?
616.72 622.04 "Игорь Лабутин" Действительно, пишите все в консоль, с другой стороны, этот output кто-то соберет, и все будет замечательно.
622.04 639.00 "Игорь Лабутин" Дальше Microsoft потихонечку расширяет методы диагностики .NET приложений и в свой новый вид диагностик на основе event пайпов, которые идут на замену ETV и являются кросс-платформенными, добавили новый кусочек, а именно подробнейшую информацию про то, как загружаются сборки.
639.00 656.08 "Игорь Лабутин" То есть теперь для того, чтобы отлаживать assembly load, вам не нужен там fusion log или еще что-то, если вы используете достаточно новый .NET пятый, то вы это сможете получить прямо вот в этих event пайпах и увидеть это в соответствующих .NET мониторах или еще кем-то.
656.08 671.96 "Игорь Лабутин" И последнее из того, что хочется захайлайтить в области tools для .NET пятого, Microsoft написали небольшую global tool, как я понимаю, это поставляется в виде global tool, который умеет писать полную информацию о вашем окружении.
671.96 686.12 "Игорь Лабутин" То есть можно было всегда сказать, конечно, .NET минус-минус версион и увидеть конкретную версию SDK, но никак нельзя было узнать, какая же там модель CPU, модель сколько памяти, битность процессора и вот это вот все.
686.12 697.44 "Игорь Лабутин" Поскольку .NET теперь кроссплатформенный и запускается на огромном количестве разного железа, то теперь есть стандартный global tool, который позволяет написать максимально возможное количество информации о вашем environment.
697.44 706.40 "Игорь Лабутин" Причем, судя по скриншотикам, он на разных платформах пишет еще разные платформорелевантные штуки, то есть на Linux он выводит информацию о c-группах и так далее.
706.40 721.96 "Игорь Лабутин" То есть то, что вы, например, видели, всякие интересные такие заголовочки после запуска benchmark.net, когда он пишет модель CPU, там что конкретно поставлено, вот теперь это можно получить и без benchmark.net, а просто запустить в стандартный .NET-тул, поставляемый в комплекте с SDK, как я понял.
721.96 731.72 "Анатолий Кулаков" О, я бы хотел такую библиотечку себе, потому что я из benchmark.net все время выдергивал вот эти строчки, как он правильно определяет платформу, процессор и так далее, для того, чтобы вставить свою программу.
731.72 734.12 "Анатолий Кулаков" Интересно, можно этот tool быть зареференсить тупо?
734.12 739.28 "Игорь Лабутин" Ну, зареференсить вряд ли, это .exe, ну хотя по идее вряд ли у него есть public IP.
739.28 748.84 "Игорь Лабутин" Интересно посмотреть, на самом деле, как она сделана, потому что если она сделана чисто на C# и она managed, это одно, а если она там дергает какие-нибудь unmanaged API, то другое.
748.84 759.40 "Игорь Лабутин" Интересно, как она вообще сделана с точки зрения как бы кросс-платформенности, и является ли она сама кросс-платформенной, или это на самом деле там три разных tool для трех операционок, называемых одинаково, и поставляемых в разным SDK.
759.40 760.76 "Игорь Лабутин" Ладно, поехали дальше.
760.76 778.80 "Игорь Лабутин" Все мы знаем про nullable annotations, nullable reference types, и как мы много раз уже обсуждали и в этом подкасте, и во многих других местах, все эти nullable annotations относительно бесполезны, если ваш код никак не проаннотирован, собственно, или если не проаннотирован SDK.
778.80 784.96 "Игорь Лабутин" Ваш код вы, конечно, можете аннотировать, но если SDK не проаннотирован, то как-то не очень хорошо живется.
784.96 810.76 "Игорь Лабутин" Так вот, команда .NET сообщила, что они достигли 94% покрытия всей public API для стандартного .NET SDK, покрытия nullable annotation, соответственно, и теперь там осталось буквально 2 или 3 namespace, если я не ошибаюсь, что-то вокруг type-конверторов, которые не проаннотированы, и то, что от них зависит.
810.76 815.52 "Игорь Лабутин" Так что теперь, получая .NET 5, вы будете получать практически полное покрытие.
815.52 822.72 "Игорь Лабутин" К сожалению, они не успели довести это дело все до 100%, но это будет продолжаться в следующих уже релизах.
822.72 824.32 "Игорь Лабутин" Почему говорю "релизах"?
824.32 830.68 "Игорь Лабутин" Потому что превью 8, который вышел, это последний превью, следующий должен быть уже релиз-кандидат.
830.68 839.88 "Игорь Лабутин" И у .NET и фича freeze, так что то, что мы видим сейчас, в принципе, вот это войдет, видимо, в финальный вариант .NET SDK.
839.88 842.48 "Игорь Лабутин" Одно нововведение в .NET 5 меня очень удивило.
842.48 844.68 "Игорь Лабутин" Толя, ты когда-нибудь с Click.one сработал?
844.68 853.20 "Анатолий Кулаков" Да, было дело на ранних этапах моей юности, очень много проблем с этой технологией, в принципе, не зря она умерла.
853.20 856.12 "Игорь Лабутин" Вот, и вот это меня тоже, так скажем, удивило.
856.12 865.56 "Игорь Лабутин" Я с ней работал и до сих пор сейчас у нас в некоторых продуктах она жива и живет, как способ распространения WPF-приложений, в нашем случае, на компы клиентов.
865.56 871.12 "Игорь Лабутин" И что удивительно, Microsoft проанонсировала, что они сделают Click.one с A5.
871.12 874.56 "Игорь Лабутин" То есть он будет доступен, он будет кросс-платформенным.
874.56 878.36 "Игорь Лабутин" Там не будет всей полноценной доступной API.
878.36 891.92 "Игорь Лабутин" Напомню, если те, кто не знает, узнают, что в Click.one с приложением можно было узнать, как это приложение было доставлено на компьютер пользователя, можно было узнать, у сервера нет ли обновлений для этого приложения и так далее.
891.92 899.12 "Игорь Лабутин" Вот это все будет недоступно, то есть будет только доступен, по крайней мере, пока в анонсе написано "автоматическое обновление при запуске" и все.
899.12 905.00 "Игорь Лабутин" Но звучит это как бы мы что-то очень глубокое и давнее раскапываем, непонятно пока зачем.
905.00 911.36 "Анатолий Кулаков" Я надеюсь, что они все-таки оставят имя, перепишут все к чертовой матери, потому что то, что было раньше, это было полностью невизабельно.
911.36 921.20 "Анатолий Кулаков" Но надо признать, что идея отличная и есть инструмент, который по-моему называется Squirrel, у которого главный девиз "мы как Click.one только работаем".
921.20 930.08 "Анатолий Кулаков" Вот, и он действительно работает, ну то есть это действительно хорошая идея, полезная вещь и она должна быть в нашей экосистеме, но только не в той реализации, в которой была много лет назад.
930.08 933.96 "Анатолий Кулаков" Поэтому давайте пожелаем успехов и хорошего начинания.
933.96 934.96 "Анатолий Кулаков" Будем следить.
934.96 943.32 "Игорь Лабутин" Да, будем следить, мне особенно интересно, потому что было не очень понятно для немногочисленных остающихся Desktop-приложений, как же их распространять.
943.32 947.12 "Игорь Лабутин" Если, да, не брать тот же самый Squirrel или еще кого-то.
947.12 951.16 "Игорь Лабутин" Погнали дальше, Totnet 5 прошлись, ASP.NET Core 5.
951.16 963.96 "Игорь Лабутин" Тут нововведений как-то они какие-то по мелочи, все довольно много всего запилили в Blazor, в VBSembly части он Target теперь Totnet 5, его стало полегче отлаживать, у него завезли какие-то очередные performance improvements.
963.96 971.28 "Игорь Лабутин" Ну в общем, если вам интересен Blazor, VBSembly, посмотрите ссылочки, которые мы приложим, там подробное описание, что же там изменилось.
971.28 986.24 "Игорь Лабутин" Дальше команда сделала штуку, которая на самом деле я думал уже давным-давно сделана, а как выяснилось, при авторизации по сертификатам ASP.NET Core всегда аккуратно все проверял, ничего не кэшировал и в общем они наконец-то добавили кэширование.
986.24 991.08 "Игорь Лабутин" Мне казалось, что при работе с сертификатами кэширование это как бы важно, потому что обычно это очень долго.
991.08 993.08 "Игорь Лабутин" Ну вот почему-то не было.
993.08 1008.00 "Игорь Лабутин" Чуть улучшили поддержку ASP.NET 2, добавили пинг-фреймы так называемые, то есть теперь кестрил автоматически умеет, его можно настроить, чтобы он автоматически посылал пинг-фреймы в заданные интервалы и поддерживал таким образом соединение, чтобы оно не разрывалось.
1008.00 1013.32 "Игорь Лабутин" Теперь тоже я не очень знаю зачем это, но наверное есть сценарии.
1013.32 1019.24 "Игорь Лабутин" Кестрилу можно сказать в какой кодировке интерпретировать значение определенных HTTP-хеддеров.
1019.24 1021.24 "Анатолий Кулаков" Неужели есть локализуемые хеддера?
1021.24 1027.56 "Игорь Лабутин" Ну может быть, не знаю, может какой-нибудь в Китае такое используется, когда там значение хеддеров и иероглифов приходит.
1027.56 1028.56 "Игорь Лабутин" Непонятно.
1028.56 1037.72 "Игорь Лабутин" Ну то есть можно кестрилу теперь рассказать, если хеддер содержит там имя такое, название хеддера, то используй там CP1251.
1037.72 1040.76 "Игорь Лабутин" Мотивация непонятна, но да, окей.
1040.76 1044.20 "Игорь Лабутин" Так, что тут еще такого интересненького у нас?
1044.20 1057.08 "Игорь Лабутин" Ну вот System Diagnostics Activity, это теперь по дефолту в V3C формате, что я так понимаю должно быть совместимо со всякими новомодными OpenTelemetry и прочими штуками.
1057.08 1059.20 "Игорь Лабутин" Например, еще чуть-чуть поговорим подальше.
1059.20 1066.60 "Игорь Лабутин" И последняя штука, про которую хочется упомянуть, это про то, что это на самом деле, как я понимаю, breaking change.
1066.60 1073.76 "Игорь Лабутин" То есть, что если раньше писалось from body в контроллере, то ISP.NET Core не считал, что этот body обязателен.
1073.76 1076.40 "Игорь Лабутин" Ну, аккуратно написал бы null и все.
1076.40 1085.80 "Игорь Лабутин" Вот, теперь дефолтное поведение, что если вы пишете from body в контроллере, то body обязателен, и ваш реквест упадет, если body отсутствует.
1085.80 1089.04 "Игорь Лабутин" Но можно в этом from body написать, что на самом деле оно опционально.
1089.04 1099.16 "Игорь Лабутин" То есть, если вы используете from body и ждете, что у вас иногда бывают пустые body, и это нормально, вот вам нужно будет поменять код при переходе на ISP.NET Core 5.
1099.16 1100.16 "Игорь Лабутин" Логично.
1100.16 1101.16 "Игорь Лабутин" Действительно.
1101.16 1104.32 "Игорь Лабутин" При переходе на ISP.NET Core 5 лучше всего менять код как-нибудь.
1104.32 1105.32 "Игорь Лабутин" Проверяйте список breaking change.
1105.32 1109.76 "Игорь Лабутин" Я на самом деле надеюсь, что Microsoft к выходу релиза сделает аккуратный список breaking change.
1109.76 1114.20 "Игорь Лабутин" У них был очень прекрасный список breaking change между двойкой и тройкой, по-моему.
1114.20 1115.64 "Игорь Лабутин" Или между единичкой и двойкой.
1115.64 1117.64 "Игорь Лабутин" Так что я надеюсь, что будет четкий список.
1117.64 1119.32 "Игорь Лабутин" Если он будет, мы про него поговорим.
1119.32 1123.16 "Анатолий Кулаков" Да мне кажется, нужно сразу выпускать анализатор, который тебе автоматически все пофиксит.
1123.16 1124.16 "Анатолий Кулаков" Зачем тебе документации?
1124.16 1125.16 "Анатолий Кулаков" Это же прошлый век.
1125.16 1127.36 "Игорь Лабутин" Действительно, нафиг документацию.
1127.36 1128.36 "Игорь Лабутин" Забыли парадокс Microsoft.com.
1128.36 1136.08 "Игорь Лабутин" Так, Entity Framework Core 5, тут тоже достаточно такие мелкие штуки.
1136.08 1137.56 "Игорь Лабутин" Ну хотя как мелкие.
1137.56 1144.52 "Игорь Лабутин" Добавили dbContextFactory и возможность пулить dbContext, видимо для каких-то оптимизаций.
1144.52 1145.52 "Игорь Лабутин" Добавили поддержку savePoint.
1145.52 1155.56 "Игорь Лабутин" Это такие, даже не транзакции, но в общем это когда можно транзакцию разбить внутри на кусочки и rollbatch только до определенного savePoint внутри.
1155.56 1170.20 "Игорь Лабутин" Я так понимаю, что это нужно для всяких сложных бизнес сценариев, когда там целиком транзакцию rollbatch очень дорого, но зато есть какой-то savePoint в серединке, до которого можно rollbatch-ить и что-нибудь другое попробовать сделать и таки завершить успешную транзакцию.
1170.20 1173.64 "Игорь Лабутин" Куча импровментов в Cosmos DB поддержки.
1173.64 1177.68 "Игорь Лабутин" Забавная фича, они называют Better Singularization.
1177.68 1182.92 "Игорь Лабутин" То есть по дефолту, или не по дефолту, поправь меня, если я не прав.
1182.92 1191.76 "Игорь Лабутин" Можно в Entity Framework настроить, что если у тебя классом называется article, то табличка в базе будет называться articles во множественном числе.
1191.76 1203.12 "Игорь Лабутин" Они теперь сделали, когда ты используешь database-first подход и скафолдишь свой проект из существующей базы, они теперь сделали умное преобразование из множественных числа в единственные.
1203.12 1207.96 "Игорь Лабутин" Поэтому если у тебя в базе встретится табличка people, то класс у тебя будет называться person.
1207.96 1216.28 "Анатолий Кулаков" Ну, надо сказать, что в старом Entity Framework такой словарик для самых частых неправильных множественных глаголов, он там был.
1216.28 1218.40 "Анатолий Кулаков" Я его даже оттуда как-то выдержал для своей собственной утилитки.
1218.40 1220.60 "Анатолий Кулаков" Это, скорее всего, нововведение только для Core.
1220.60 1227.04 "Игорь Лабутин" Да, это нововведение конкретно для F5 Core, и они говорят, что они используют для этого специальный NuGet пакетик, называемый humanizer.
1227.04 1230.20 "Анатолий Кулаков" Ух ты, это что-то из пушки по воровьям прямо.
1230.20 1238.44 "Анатолий Кулаков" Потому что humanizer - это довольно большой пакет, который имеет очень много творить хорошего для представления текста и цифры, и даты для чтения человеком.
1238.44 1243.76 "Анатолий Кулаков" Но чтобы только его для множественного единиценного числа использовали, это как-то сурово.
1243.76 1255.20 "Игорь Лабутин" Ну, может быть, они еще где-нибудь это заиспользовали, но по крайней мере именно его они подтянули для того, чтобы таблички, правильно, называть, а точнее классы.
1255.20 1268.76 "Игорь Лабутин" Дальше они могут теперь делать table per type mapping, то есть это когда у вас есть иерархия наследования в коде, и у вас каждый наследник в итоге отображается в отдельную табличку с формом key на табличку с базовым, так сказать, соответствующим классом.
1268.76 1276.88 "Игорь Лабутин" Альтернатива была бы, когда все лежат в одной табличке и есть поле дискриминант, по которому определяется, что за тип там лежит, и соответственно шарит все колонки.
1276.88 1284.44 "Игорь Лабутин" Это полезно, когда у вас иерархия очень странная, не то что странная, а каждый наследник имеет свой собственный большой набор полей, независимый от других.
1284.44 1288.16 "Игорь Лабутин" Иначе у вас получается очень широкая табличка, но наполовину пустая.
1288.16 1299.48 "Игорь Лабутин" Лучшие миграции для SQLite - это table value functions, которые теперь он умеет правильно превращать, использовать точнее, если вы пишете их использование в link_u.
1299.48 1301.44 "Игорь Лабутин" Ну, в общем, как-то так.
1301.44 1305.96 "Игорь Лабутин" По мелочи вроде бы, но они тоже потихонечку двигаются к релизу, поэтому стабилизируют.
1305.96 1312.52 "Анатолий Кулаков" Да, в ближайшее время ожидаем релиза, но так как фреймворк развиваются семимильными шагами, должны, наверное, быть новости и по студии.
1312.52 1321.12 "Игорь Лабутин" В студии действительно вышел 16.8 Preview 2, и там как-то на вид изменений не очень много.
1321.12 1327.08 "Игорь Лабутин" У меня глаз зацепился за то, что они сделали немножко хитрую поддержку git-репозиториев.
1327.08 1350.72 "Игорь Лабутин" Не секрет, что во многих, может быть я не прав про многих, но в некоторых git-репозиториях больше одного солюшена, и если вы теперь из Visual Studio будете открывать git-репозиторий, где, например, у вас много солюшенов, то он сначала откроется примерно так, как он открывается в Visual Studio Code, ну в смысле как в структурах папочек, и отдельно студия найдет там все солюшены и скажет, а что вы хотите из него открыть.
1350.72 1355.60 "Игорь Лабутин" И вот если вы выберете солюшен, то тогда, понятно, откроется, как обычно открывается.
1355.60 1361.76 "Игорь Лабутин" При этом всегда можно сказать switch view и вернуться обратно в выбор солюшенов внутри рамков этого git-репозитория.
1361.76 1363.80 "Игорь Лабутин" Вот, это одна штука.
1363.80 1364.80 "Анатолий Кулаков" Да, удобненько.
1364.80 1377.16 "Анатолий Кулаков" Я еще заметил интересное нововведение, это подхватка .NET CLI templates, то есть раньше еще с самых первых версий утилита .NET она умела создавать проекты по шаблонам.
1377.16 1385.28 "Анатолий Кулаков" Этих шаблонов было множество, и у нее еще были плагины, с помощью которых она могла доставлять еще больше шаблонов из ваших разных репозиториев.
1385.28 1388.40 "Анатолий Кулаков" А Visual Studio подставлялась со своими шаблонами.
1388.40 1396.80 "Анатолий Кулаков" Это иногда рвало голову, когда тебе говорят создай application, ты не понимал, где вы создаваете консольное приложение, это один template.
1396.80 1398.56 "Анатолий Кулаков" Visual Studio совершенно другой template.
1398.56 1402.72 "Анатолий Кулаков" И вот Visual Studio добавила поддержку всех CLI templates.
1402.72 1407.36 "Анатолий Кулаков" Теперь она умеет загружать полный список этих templates, которые вам доступны из команды строки.
1407.36 1416.76 "Анатолий Кулаков" Для этого вам нужно войти в tools, options, preview features и включить специальный флажочек, который называется show all .NET code template in the new project dialog.
1416.76 1422.32 "Анатолий Кулаков" И у вас сразу при создании нового проекта появятся все эти шаблоны.
1422.32 1433.46 "Анатолий Кулаков" Visual Studio автоматически сгенерит визарды под эти шаблоны, если вдруг в них нужно заполнить какие-то имена, например выбрать target framework или выбрать какие-то дополнительные параметры.
1433.46 1440.60 "Анатолий Кулаков" Все эти имена она красиво потаскивает из template JSON, и сопровождает ваш template пакет.
1440.60 1445.12 "Анатолий Кулаков" Также она оттуда может доставать параметры, иконки и в общем делает все красиво.
1445.12 1450.28 "Анатолий Кулаков" В общем вот такая интересная интеграция, когда из консоли мы приходим обратно в Google.
1450.28 1451.28 "Игорь Лабутин" Ну да, интересно.
1451.28 1457.72 "Игорь Лабутин" То есть я как-то вот почти не пользовался дотанать нее, я все больше как-то лежал в студии, создавая новый проект, новый проект.
1457.72 1460.24 "Игорь Лабутин" Ну теперь будет удобнее, да, выбирать.
1460.24 1466.72 "Игорь Лабутин" Хотя иногда мне пугает масштаб того, сколько там разных новых templates есть при создании нового проекта.
1466.72 1468.36 "Игорь Лабутин" Но будем разбираться.
1468.36 1476.16 "Анатолий Кулаков" Давай, недалеко уходя от .NET 5, еще есть интересная тема в .NET 5, они заинтродюсили новый способ тримминга.
1476.16 1484.20 "Анатолий Кулаков" Если вы следите за нашими подкастами, то вы знаете, что начиная с Core 3 введен тримминг-мод, который называется Assembly Trimming.
1484.20 1495.80 "Анатолий Кулаков" Это такой самый примитивный способ, который обрезает большие куски кода и помогает вашему приложению сделаться меньше, то есть результирующий размер вашего приложения будет меньше.
1495.80 1500.48 "Анатолий Кулаков" Это нормально, если вы, например, поставляете ваше приложение как один EXE-шник.
1500.48 1507.08 "Анатолий Кулаков" То есть это сейчас модно, когда ты весь фреймворк закапываешь в один EXE-шник и распространяешь только его.
1507.08 1515.68 "Анатолий Кулаков" В этот момент для вас размер начинает играть какое-то значение и тримминг призван упростить, призван обрезать этот бинарник для того, чтобы он занимал как можно меньше места.
1515.68 1520.88 "Анатолий Кулаков" В .NET 5 ввели новый тип тримминга, который называется Member Streaming.
1520.88 1529.52 "Анатолий Кулаков" Он сейчас находится в экспериментальной стадии, пока неизвестно, когда его включат по дефолту, пока по дефолту приведущий способ.
1529.52 1544.76 "Анатолий Кулаков" Member Streaming намного эффективнее, чем приведущий, то есть он анализирует уже непосредственно те классы, те члены классов, которые использует ваш код и убирает вплоть до методов, вплоть до полей и филдов, те куски, которые вам не нужны.
1544.76 1552.68 "Анатолий Кулаков" Несмотря на то, что Microsoft пытается сделать этот тримминг как можно более умным, на его пути встает очень много проблем.
1552.68 1554.92 "Анатолий Кулаков" Например, самое очевидное - это Reflection.
1554.92 1561.92 "Анатолий Кулаков" Ведь вы всегда можете любой тип, любой класс, любой мембр запросить через обычную строчку, например, GetProperty по строке.
1561.92 1570.60 "Анатолий Кулаков" И тогда анализатор, грубо говоря, не знает, используется этот мембр или не используется, или вы достаете помощь каких-то магических Reflection функций.
1570.60 1577.40 "Анатолий Кулаков" И он сейчас пытается набить свою базу вот этих Smart Analytics.
1577.40 1584.16 "Анатолий Кулаков" Он уже понимает много Reflection методов, он уже понимает строки, которые передаются в самые примитивные из них.
1584.16 1592.76 "Анатолий Кулаков" Например, такая простейшая вещь, как создание класса по его строковому типу или доставание свойства по его строковому имени, уже не вызовет у него проблем.
1592.76 1598.08 "Анатолий Кулаков" Он сумеет распознать, что этот класс и это поле используется и не будет их триммать.
1598.08 1604.28 "Анатолий Кулаков" Но существует ряд других ситуаций, которые ему могут быть не под силу.
1604.28 1614.04 "Анатолий Кулаков" Например, он может удалить код, который действительно в вашем приложении не используется, но тут у вас система плагинов и вдруг загружается некий плагин, которому этот код срочно понадобился.
1614.04 1617.72 "Анатолий Кулаков" Вот тогда эта ситуация практически неразрешима.
1617.72 1625.08 "Анатолий Кулаков" Для того, чтобы хоть как-то помочь триммеру такие ситуации убирать и распознавать, Microsoft ввел аннотации.
1625.08 1631.60 "Анатолий Кулаков" Анотации можно задавать или атрибутами, или XML-файлами и таким образом помогать нашему триммеру.
1631.60 1636.24 "Анатолий Кулаков" Разговоре о триммере нужно прежде всего понимать, что главная его задача - это уменьшить размер.
1636.24 1639.60 "Анатолий Кулаков" Но не всегда уменьшение размера - это главная цель вашего приложения.
1639.60 1646.56 "Анатолий Кулаков" Например, если вы хотите, чтобы ваше приложение стартовало быстро, в дотнете существует технология, которая называется Reddit Run.
1646.56 1655.00 "Анатолий Кулаков" То есть вы записываете немножко дополнительной информации к вашему экзешнику и благодаря этой информации ваше приложение будет быстрее стартовать.
1655.00 1659.08 "Анатолий Кулаков" Это такой своеобразный, немножко прогретый джетовый кусочек.
1659.08 1670.68 "Анатолий Кулаков" В этот момент вы должны решить, для вас важнее размер, тогда эту информацию можно триммнуть, или для вас все-таки важнее скорость запуска, и тогда ваше приложение будет немножко больше, но зато быстрее стартовать.
1670.68 1673.00 "Анатолий Кулаков" Вы как разработчик можете помочь триммеру.
1673.00 1675.28 "Анатолий Кулаков" Сделать это можно несколькими способами.
1675.28 1678.80 "Анатолий Кулаков" Самый очевидный из них - это плотное освоение генераторов.
1678.80 1682.56 "Анатолий Кулаков" Мы обсуждали генераторы в наших выпусках ранее.
1682.56 1693.88 "Анатолий Кулаков" Напомню, что это специальные анализаторы, которые при компиляции помогают вам анализировать код и на основании этих анализов сгенерировать какой-то дополнительный C# код, который уже будет использоваться в ваших программах.
1693.88 1701.32 "Анатолий Кулаков" Например, dependency injection можно таким образом полностью сгенерировать и обойтись без рефлекшена, или примитивные сервизаторы.
1701.32 1706.32 "Анатолий Кулаков" Точно так же можно сделать, чтобы сервизатор ваш не использовал никакого рефлекшена, а полностью был сгенерирован.
1706.32 1714.72 "Анатолий Кулаков" Соответственно, не использование рефлекшена для триммера - это благо, потому что используемые мембры становятся прозрачными и очевидными.
1714.72 1716.92 "Анатолий Кулаков" Нет рефлекшена - значит нет проблем с анализом.
1716.92 1720.00 "Анатолий Кулаков" И триммер в таких условиях будет жить хорошо и счастливо.
1720.00 1724.68 "Анатолий Кулаков" Еще одна интересная фишка, которая есть в дотнет 5-м - это фичи-свитчеры.
1724.68 1732.48 "Анатолий Кулаков" Мы тоже о них разговаривали, если в общем это обычные фичи-флаги, которые вы можете выделять в какие-то большие блоки функциональности.
1732.48 1737.52 "Анатолий Кулаков" Например, в дотнете уже огромное число таких свитчеров.
1737.52 1743.52 "Анатолий Кулаков" Можно выключить поддержку других культур, кроме инвариантной, например.
1743.52 1745.44 "Анатолий Кулаков" Можно выключить поддержку HTTP Activity и так далее.
1745.44 1750.52 "Анатолий Кулаков" То есть, такие огромные блоки функциональности, которые в принципе могут быть вашему приложению и совсем не нужны.
1750.52 1754.32 "Анатолий Кулаков" И триммер позволяет такие свитчеры распознавать.
1754.32 1764.84 "Анатолий Кулаков" То есть, если у вас какой-то такой большой блок отключен на момент компиляции, триммер не просто его задетектит, а он вычистит весь код, который связан с этим флагом.
1764.84 1770.76 "Анатолий Кулаков" То есть, можно выкинуть из вашего проекта всю работу с кодировками, кроме инвариантной культуры.
1770.76 1774.48 "Анатолий Кулаков" И таким образом у вас тоже, естественно, уменьшится приложение.
1774.48 1785.92 "Анатолий Кулаков" Такие фрейворки, например, как Mono, уже давным-давно активно использовали у себя триммер, потому что Mono, прежде всего, нацелен на мобильный рынок, и там размер приложений очень сильно важен.
1785.92 1791.80 "Анатолий Кулаков" Недавняя технология Microsoft, которая называется Blazor, она нацелена на веб-приложения.
1791.80 1794.80 "Анатолий Кулаков" И там размер приложений тоже стал очень-очень важен.
1794.80 1802.12 "Анатолий Кулаков" Поэтому Blazor - это одна из первых ниш, где триммер занял свое такое заслуженное место.
1802.12 1807.44 "Анатолий Кулаков" Естественно, в Blazor используется очень много такого сложного кода, который я описывал на Reflection, на динамиках и так далее.
1807.44 1822.92 "Анатолий Кулаков" И Microsoft, чтобы обойти эту проблему, вручную разметила практически все библиотеки, которые нужны для Blazor, вручную разметила аннотациями или XML файлами, что помогло им сократить размор Blazor-овских библиотек очень-очень сильно.
1822.92 1823.92 "Игорь Лабутин" Ну, хорошо.
1823.92 1833.00 "Игорь Лабутин" Слушай, а вот если я хочу у себя там что-то сделать, во-первых, я так понимаю, я могу у себя попробовать также фичи какие-то выделить.
1833.00 1848.32 "Игорь Лабутин" И если я могу как-то помочь, точнее, я должен, видимо, помочь компилятору сказать, что вот этот вот метод у меня дергается Reflection, пожалуйста, не трогай, или вот это на самом деле плагин API, его никогда не удаляй, потому что нафиг его знает, что там плагины захотят.
1848.32 1851.84 "Игорь Лабутин" Это сейчас как-то уже можно сделать или пока это внутренняя штука Microsoft?
1851.84 1857.76 "Анатолий Кулаков" Нет, в принципе, в DotNet 5, в DotNet Core нет практически никаких внутренних штук для Microsoft.
1857.76 1860.48 "Анатолий Кулаков" Все, что делает Microsoft, доступно нам точно так же.
1860.48 1868.20 "Анатолий Кулаков" То есть обычно разработчик вполне может сделать аннотации, так называемые, которые подскажут триггеру, что делать с его кодом.
1868.20 1870.64 "Анатолий Кулаков" У нас существует два способа аннотации.
1870.64 1884.00 "Анатолий Кулаков" Первый - это атрибутами, то есть есть некоторые вспомогательные атрибуты, например, DynamicallyAssemblyMember атрибут, который говорит, что какие члены этого класса будут использовать динамически с помощью Reflection, и ни в коем случае не надо их чистить.
1884.00 1893.16 "Анатолий Кулаков" Есть также, например, DynamicallyDependency атрибут, который рассказывает, какие типы загружаются динамически с помощью нашей, допустим, плагиновой системы.
1893.16 1895.16 "Анатолий Кулаков" Их тоже желательно не удалять.
1895.16 1902.20 "Анатолий Кулаков" Также есть XML-файлы, в которых вы можете проставить те же самые атрибуты или задать какие-то новые.
1902.20 1910.16 "Анатолий Кулаков" Например, вы можете пометить какие-то ассембли, куски кода класса как полностью не удаляемые, то есть чтобы триммер даже не пытался это сделать.
1910.16 1915.84 "Анатолий Кулаков" Если это код ваш, то есть вы имеете полный доступ к исходникам и хотите их модифицировать, то лучше воспользоваться атрибутами.
1915.84 1932.72 "Анатолий Кулаков" XML-файлы в основном применяются для каких-то сторонних компонентов, если у вас недоступно модификация этих сборок, или же если вы не хотите какие-то вводить дополнительные зависимости или дополнительно вымазывать код, а просто хотите рядом поставить XML-файлик с подробными аннотациями, это тоже не возбраняется.
1932.72 1950.04 "Игорь Лабутин" Ну вообще интересно, то есть в совокупности со всякими Top Level C#, возможности выпилить почти всё, потому что, например, в том же Top Level C# программе вряд ли вам нужна какая-то суровая работа с кодировками, или там тот же XATB Propagation или ещё что-то.
1950.04 1957.28 "Игорь Лабутин" И скорее всего это означает, что действительно мы можем увидеть очень маленькие консольные тулы в ближайшем будущем, написанные на дотнете.
1957.28 1958.28 "Игорь Лабутин" Это прикольно.
1958.28 1963.68 "Анатолий Кулаков" Консольные тулы, мобильные приложения, веб-приложения, имбедед-системы у нас ещё не забыты.
1963.68 1968.08 "Анатолий Кулаков" Да, очень много ниш для тех мест, где хочется именно маленького размера.
1968.08 1971.32 "Анатолий Кулаков" И соответственно, чем меньше размер, тем скорее всего будет быстрее запуск.
1971.32 1973.64 "Игорь Лабутин" Да, это прекрасно.
1973.64 1979.00 "Игорь Лабутин" Давайте ещё поговорим про одну вещь о дотнет 5, которую поменяли аж в компиляторе.
1979.00 1989.60 "Игорь Лабутин" На самом деле, что надо сказать, делается не очень часто и не всегда так прям видно, но здесь Microsoft постаралась и сделала следующую штуку.
1989.60 2003.08 "Игорь Лабутин" Вы знаете, что когда вы обычно создаёте какой-нибудь дефолтный проектик в Visual Studio, там частенько появляется пачка стандартных розлин анализаторов от Microsoft, которые проверяют какие-то базовые вещи на вашем коде.
2003.08 2013.36 "Игорь Лабутин" Начиная с дотнет 5 и с дотнет 5 SDK, они теперь будут встроены в сам SDK и таким анализом будет заниматься сам компилятор.
2013.36 2024.12 "Игорь Лабутин" И всё было бы хорошо, но если бы это всё просто включить в компилятор и сказать, что компилятор теперь на каждый такой анализ будет генерировать ошибки, то это было бы очень не backward compatible.
2024.12 2025.48 "Игорь Лабутин" Microsoft такого не любит.
2025.48 2033.24 "Игорь Лабутин" Несмотря на то, что это дотнет 5, но всё-таки он является наследником дотнет кор 3 и было бы неплохо переносить всё поаккуратнее.
2033.24 2035.40 "Игорь Лабутин" Поэтому сделали следующую штуку.
2035.40 2042.36 "Игорь Лабутин" В компиляторе теперь есть новая опция, называется Language Analysis Level и у неё есть числовое значение.
2042.36 2052.64 "Игорь Лабутин" Все значения от 0 до 4 это то же самое, как если бы вы сказали Warning Level 0, Warning Level 1 и так далее до 4 самого максимального, который сейчас есть у вас в Visual Studio.
2052.64 2055.16 "Игорь Лабутин" Отдельно вы можете поставить галочку Warnings Is There естественно.
2055.16 2059.32 "Игорь Лабутин" Так вот в дотнет 5 SDK теперь туда можно передать цифру 5.
2059.32 2062.80 "Игорь Лабутин" Очень удачно как-то совпало, что у нас 4 Warning Level и дотнет 5.
2062.80 2065.36 "Игорь Лабутин" Ну вот кто-то где-то что-то явно готовился.
2065.36 2074.20 "Игорь Лабутин" И получить новый Language Analysis прямо в SDK от компилятора без необходимости добавлять NuGet пакеты с стандартным Roslyn анализаторами.
2074.20 2076.88 "Игорь Лабутин" Никто конечно же вам не мешает добавить дополнительные.
2076.88 2080.72 "Игорь Лабутин" Этих вы можете добавлять сколько угодно, но вот стандартные вам предоставит компилятор.
2080.72 2088.80 "Игорь Лабутин" Фишка теперь заключается в том, что дефолтное значение вот этого сеттинга, оно зависит от Target Framework, для которого вы собираетесь.
2088.80 2095.76 "Игорь Лабутин" Если вы собираетесь и таргетитесь на дотнет 5, то дефолтное значение этого сеттинга будет 5.
2095.76 2102.72 "Игорь Лабутин" То есть создавая новое приложение для дотнет 5, вы автоматически получите работающие все эти анализаторы на максимальном уровне.
2102.72 2109.60 "Игорь Лабутин" Для всех остальных Target Framework дефолтное состояние 4, то есть максимальный уровень Warning, но это чисто Warning.
2109.60 2122.56 "Игорь Лабутин" Причем для любого из Target Framework вы можете это заверрайдить, то есть вы можете сказать, что приложение у меня для дотнет кор 2 или 3, но при этом я хочу Language Analysis уровня 5, то есть все анализы из дотнет 5.
2122.56 2128.08 "Игорь Лабутин" И соответственно ваш дотнет 5 SDK будет проверять ваш код на соответствие всем строгим правилам.
2128.08 2133.56 "Игорь Лабутин" Кроме того, помимо числовых величин, вы там можете использовать волшебную константу Latest.
2133.56 2138.56 "Игорь Лабутин" Это означает, что бери всегда последний, не важно какой, но самый-самый новый хочу.
2138.56 2147.76 "Игорь Лабутин" Можно использовать даже Preview, это означает, что вы будете получать еще более новые анализы, но возможно они там где-то могут как-то не совсем работать.
2147.76 2150.80 "Игорь Лабутин" Или туда можно написать None и вообще отказаться от этой услуги.
2150.80 2156.68 "Игорь Лабутин" Все это можно так же конфигурить из Project Settings в Visual Studio, там добавлено соответствующее.
2156.68 2162.40 "Игорь Лабутин" Я не помню была ли вкладочка такая, но по крайней мере она там теперь точно есть и там есть drop-down, где можно это выбрать.
2162.40 2170.92 "Игорь Лабутин" Кроме этого, Microsoft не просто, естественно, запилил фичу, что хотим новые анализы и вот, пожалуйста, они на самом деле добавили несколько полезных анализаторов.
2170.92 2181.48 "Игорь Лабутин" Один из них, наверное, может быть, как мне кажется, самый полезный, если мы говорим о кроссплатформенности, это предупреждение о том, что какой-то код будет не работать на разных платформах.
2181.48 2200.24 "Игорь Лабутин" То есть понятно, что у нас есть там .NET Standard раньше был, если мы говорим про .NET Core 3 или 2, у нас есть .NET 5, который вроде как .NET Standard 2.1 compliant, но тем не менее не каждая фишка, присутствующая в .NET Standard будет работать на всех платформах, где этот .NET Standard поддержан.
2200.24 2207.28 "Игорь Лабутин" Некоторые, как известно, кидают платформу от Support with Exception, а некоторые кидают такой Exception только при определенном сочетании аргументов.
2207.28 2217.36 "Игорь Лабутин" Так вот анализатор, он, естественно, еще учится, но потихонечку будет расширяться, он знает на каких платформах какие API будут работать, какие не будут.
2217.36 2227.44 "Игорь Лабутин" И может вам прямо в коде на момент компиляции сказать, что вы вот этот кусочек кода компилируете под МакОсь, а вот там под МакОсь вот эта API, она как бы есть, но она работать не будет, она кинет платформу от Support.
2227.44 2229.24 "Игорь Лабутин" Мне кажется, это очень полезно.
2229.24 2242.16 "Игорь Лабутин" Дальше Microsoft добавила анализатор, мне кажется, он должен быть давно в стандартном пакете, то, что не надо писать Catch Exception E и внутри Throw E, надо писать просто Throw .
2242.16 2245.24 "Игорь Лабутин" И правильно их перепрокидывать с оригинальным Stack Trace.
2245.24 2253.28 "Игорь Лабутин" Это прям стандартная ошибка, много кто наталкивался, это надо знать, наконец-то у нас есть анализатор стандартный.
2253.28 2258.16 "Игорь Лабутин" И из простых вещей они добавили, что нельзя делать, не то, что нельзя.
2258.16 2264.60 "Игорь Лабутин" Студия теперь проверяет, что вы не делаете лок на Value-тайпах, но кто же сейчас делает локи, тем более на Value-тайпах.
2264.60 2268.28 "Игорь Лабутин" Наверное, если вы делаете локи, то вы знаете, что вы делаете, но на всякий случай вас проверят.
2268.28 2278.24 "Игорь Лабутин" И в студию завезли анализатор, который проверяет, что Key Expression is always true или is always false и предлагает его соответственно выпилить вместе с условием.
2278.24 2282.44 "Игорь Лабутин" Давно есть штука в ReSharper, но теперь есть в студии.
2282.44 2290.04 "Игорь Лабутин" Все новые вот эти Warnings, их еще на самом деле довольно много, я перечислил только 4-5 основных, которые меня зацепили.
2290.04 2296.80 "Игорь Лабутин" Все эти Warnings можно сконфигурить индивидуально, либо через Editor Config, либо в коде прямо за Subway с этих прагмочеками и так далее.
2296.80 2299.88 "Игорь Лабутин" В общем, все как с обычными анализаторами, только теперь прямо с компилятора.
2299.88 2314.68 "Анатолий Кулаков" Меня очень радует интеграция Microsoft с Editor Config, вообще замечательная штука, замечательный способ для распространения общих настроек среди всей команды, и приятно, что Microsoft его не забывает, а добавляет поддержку новых фич туда же тоже.
2314.68 2316.12 "Игорь Лабутин" Да, это действительно удобно.
2316.12 2319.68 "Игорь Лабутин" Коммит, как бы, git ignore и Editor Config, два стандартных файла теперь.
2319.68 2323.44 "Игорь Лабутин" Ну, Диван, я думаю, что достаточно про DotNet 5.
2323.44 2331.60 "Игорь Лабутин" Мы обычно еще как-то делаем какие-то новости, обзор новостей про что-то вокруг ДотНета, Tools, библиотечки.
2331.60 2333.00 "Игорь Лабутин" Есть у нас что-нибудь новенькое?
2333.00 2336.12 "Анатолий Кулаков" Да, у меня как раз есть пара новостей про Tools.
2336.12 2342.68 "Анатолий Кулаков" Первое, что хотелось бы сказать, это OpenTelemetry вышел в стаду бета-тестирования, то есть на финишную прямую.
2342.68 2349.12 "Анатолий Кулаков" Релиз они ожидают примерно к ноябрю, а сейчас активно устаканивают API и отлаживают баги.
2349.12 2351.64 "Анатолий Кулаков" Прежде всего давайте рассмотрим, что это такое.
2351.64 2354.64 "Анатолий Кулаков" Обычно за ДотНет-приложением мы наблюдаем с трех точек зрения.
2354.64 2357.56 "Анатолий Кулаков" Это логирование, метрики и трейсинг.
2357.56 2368.04 "Анатолий Кулаков" Трейсинг - это такая своеобразная картина, которая показывает вам распределенные транзакции, может быть, ваших методов среди различных частей вашей системы.
2368.04 2373.64 "Анатолий Кулаков" Трейсинг можно представить как такой распределенный стектрейс между различными приложениями.
2373.64 2382.88 "Анатолий Кулаков" То есть если вы хотите знать, как ваш метод выполнялся, как ваша транзакция выполнялась среди множества ваших микросервисов, то это как раз трейсинг и показывает.
2382.88 2395.72 "Анатолий Кулаков" И OpenTelemetry - это такой проект, который объединил в себя кучу всяких IT-гигантов, протоколов, тулзов и так далее для того, чтобы выработать некий формат, единый формат такого трейсинга.
2395.72 2412.40 "Анатолий Кулаков" Благодаря единому формату мы можем объединять огромное число независимых вендеров, приложений, которые никак не связаны между собой, но они общаются на одном протоколе, и поэтому мы можем вот такую своеобразную картину выполнения вашего метода во всей вашей инфраструктуре собрать воедино.
2412.40 2420.28 "Анатолий Кулаков" И вот OpenTelemetry как раз-таки для Дотнета, он перешел в стадию бета-тестирования.
2420.28 2432.44 "Анатолий Кулаков" Нужно сказать, что у стандарта OpenTelemetry есть своя собственная спецификация, то есть каким образом называются временные промежутки, каким образом задаются параметры, в общем как это все в настоящем в протоколе написано.
2432.44 2435.40 "Анатолий Кулаков" И этому стандарту придерживается большая часть мира.
2435.40 2440.36 "Анатолий Кулаков" Но, к сожалению, у Микрософта уже было давно такое понятие как Activity API.
2440.36 2447.08 "Анатолий Кулаков" Скорее всего им никто никогда не пользовался и никто никогда про него не слышал, но задача у него была примерно такая же, схожая.
2447.08 2454.92 "Анатолий Кулаков" Отслеживать то, каким образом ваши методы ползают внутри вашего приложения или может быть даже через ремоутинг внутри других приложений.
2454.92 2459.96 "Анатолий Кулаков" И поэтому Микрософт подогнал весь стандарт OpenTelemetry под свой Activity API.
2459.96 2465.04 "Анатолий Кулаков" Естественно он расширил и сильно переписал этот Activity API, но факт остается фактом.
2465.04 2480.48 "Анатолий Кулаков" Термины очень сильно не совпадают и можно прочитать очень много статей разработчиков, каким образом они выходили из этой ситуации, как они там искали, каким образом термины однизаменительны другие, как сделать абстракции, которые есть там, а там их нет.
2480.48 2483.32 "Анатолий Кулаков" В общем, кажется, что им это более-менее удалось.
2483.32 2493.24 "Анатолий Кулаков" И сейчас официальная рекомендация это не использовать все-таки какие-то сторонние библиотеки OpenTracing или сторонние спецификации OpenTracing, а делать все через Activity API.
2493.24 2504.28 "Анатолий Кулаков" Это позволит сделать поддержку трассировок в вашем приложении без каких-то там внешних зависимостей, потому что это стандартные библиотеки, которые поставляются вместе с фреймворком.
2504.28 2510.16 "Игорь Лабутин" И правильно ли я понимаю, что это заодно позволит стандартным образом проинструментировать фреймворк?
2510.16 2517.96 "Игорь Лабутин" То есть, например, какой-нибудь HTTP-клайн, чтобы он автоматически прислал нужные штуки в нужное место, не завися от каких-то сторонних библиотек?
2517.96 2518.96 "Анатолий Кулаков" Да, да.
2518.96 2524.36 "Анатолий Кулаков" Сам .NET Framework тоже, потому что никто не будет добавлять в .NET Framework ссылку на какой-нибудь OpenTelemetry.
2524.36 2532.56 "Анатолий Кулаков" А вот ссылку на SystemDiagnostic/DiagnosticSource, который является стандартным пакетом .NET, добавить вполне себе можно.
2532.56 2537.80 "Анатолий Кулаков" И как раз в этом пакете заключается вся мощь нашего Activity API.
2537.80 2548.20 "Анатолий Кулаков" Этот пакет имеет довольно слабенький dependency, то есть ему нужен как минимум .NET Framework 4.5.2 или .NET Core 2.1.
2548.20 2554.64 "Анатолий Кулаков" Если ваш проект соответствует этим версиям или выше, то значит вы можете использовать этот Activity API.
2554.64 2570.52 "Анатолий Кулаков" Вместе с этим SDK также вышли в стадию тестирования пакеты для инструментации не только HTTP-клайна, но и ISP.NET, ISP.NET Core, SQL-клиента, Redis, gRPC-клиента и некоторых других пакетов.
2570.52 2579.56 "Анатолий Кулаков" То есть все эти способы взаимодействия вашего приложения с окружающим миром будут автоматически стучать про все ваши действия в трассировку.
2579.56 2583.92 "Анатолий Кулаков" Также есть экспортеры для стандартных визуализаторов этих трассировок.
2583.92 2585.32 "Анатолий Кулаков" Это Jagger, Zipkin.
2585.32 2590.32 "Анатолий Кулаков" И есть экспортеры для OpenTelemetry протокола, так называемого OTLP.
2590.32 2595.56 "Анатолий Кулаков" Есть экспортирование в формат Metric ProMetheus.
2595.56 2604.44 "Анатолий Кулаков" И есть куча документаций по каждому из этих форматов, по каждому из этих инструментариев, по каждому из этих экспортеров, каким образом его использовать.
2604.44 2618.08 "Анатолий Кулаков" Также довольно несложно заинструментировать свой код, чтобы он поддерживал эти Activity API и сделать вам красивую трассировку во всех ваших приложениях, даже для тех библиотек, которые не могли с этим раньше справиться или с этим раньше использовать.
2618.08 2619.08 "Игорь Лабутин" Да, прекрасно.
2619.08 2623.68 "Игорь Лабутин" Еще я видел новость, что наконец-таки у нас зарелизился ImageSharp.
2623.68 2633.36 "Игорь Лабутин" То есть, как я понимаю, история ImageSharp как библиотеки работы с изображениями началась, когда Microsoft сказал, что в .NET Core не будет никакого систем дроуинга и так далее.
2633.36 2638.80 "Игорь Лабутин" И, соответственно, 5 лет назад ребята сели и сказали, а мы напишем клевую замену.
2638.80 2641.48 "Игорь Лабутин" И вот 5 лет прошло, наконец-таки релиз 1.0.
2641.48 2655.76 "Анатолий Кулаков" Да, потому что если ты помнишь, что это вызвало бурю какого-то гнева, эмоций, негативного фидбэка, типа наши приложения умеют рисовать, им нужны что-то для работы с картинками, каким образом мы это будем делать на .NET Core, если вы там не поддержите эту библиотеку и так далее.
2655.76 2661.20 "Анатолий Кулаков" И вот в компанию Six Laboratories собралась и запилила ImageSharp.
2661.20 2663.28 "Анатолий Кулаков" Что же такое ImageSharp?
2663.28 2668.80 "Анатолий Кулаков" На сегодняшний день это, наверное, самая популярная библиотека для работы с 2D изображениями.
2668.80 2683.32 "Анатолий Кулаков" Она полностью менеджит, она кроссплатформенная, она отлично поддерживает 2D графику, она нацелена на .NET стандарт 1.3, то есть может использоваться практически где угодно.
2683.32 2694.64 "Анатолий Кулаков" И призвана для того, чтобы сделать любые манипуляции или рисовать изображение с нуля, в том числе, там, рессайзить, накладывать эффекты, накладывать какие-то фильтры и так далее.
2694.64 2699.64 "Анатолий Кулаков" Кстати, она является членом .NET Foundation, о котором мы обсуждали в начале.
2699.64 2710.52 "Анатолий Кулаков" SystemDrawing, надо сказать, что на текущий момент он уже вернулся, сейчас есть какие-то зачатки его в .NET Core, но все-таки Microsoft по-прежнему не рекомендует его использовать.
2710.52 2724.16 "Анатолий Кулаков" В официальной рекомендации на MSDN написано, что не надо это использовать, это не кроссплатформенная заглушка, она только для Windows и не будет никогда поддерживаться в SPNet и не будет никогда продерживаться кроссплатформенно.
2724.16 2730.12 "Анатолий Кулаков" Если вы хотите работать с графикой, то используйте ImageSharp нашего героя или SkiaSharp.
2730.12 2745.96 "Анатолий Кулаков" SkiaSharp - это баннинги для Skia, это тоже такая очень могучая библиотека, по-моему, от Google, но ее проблема в том, что она не менеджит, это всего лишь баннинги, по-моему, с самой библиотекой, которая на плюсах, то ли на сях, на чистых написано, то есть тоже с ней нужно повозиться для того, чтобы прикрутить.
2745.96 2762.68 "Анатолий Кулаков" А вот ImageSharp, он прекрасен, он подключается, как вы ожидали, работает довольно быстро, имеет прекрасный API, имеет богатые возможности и, наверное, сейчас является лучшей библиотекой для работы с 2D-графикой, если мы говорим про кроссплатформенность.
2762.68 2767.52 "Игорь Лабутин" Да, интересно, ну, удачно получилось, раз Microsoft сам рекомендует.
2767.52 2776.68 "Игорь Лабутин" Надеюсь, не постигнет участь других тулов и продолжат развиваться как отдельная библиотека, а не будет куплена и завязана Microsoft внутри.
2776.68 2790.92 "Анатолий Кулаков" У компании Six Labors также есть несколько интересных библиотечек, которые основаны на ImageSharp, например, ImageSharp Drawing - это система для кроссплатформенного 2D-работы с полигонами, что бы это ни значило.
2790.92 2796.60 "Анатолий Кулаков" В общем, если вы хотите как-то более продвинутой графики, вам нужны какие-то более продвинутые алгоритмы, скорее всего, эта библиотека для вас.
2796.60 2812.20 "Анатолий Кулаков" Есть ImageSharp Web - это high-performance библиотека для SPNet, это специальный middleware, который умеет делать всякую магию с картинками для ваших веб-серверов, например, автоматически проставлять watermarks для всех картинок, которые отдаются с вашего сервера.
2812.20 2819.72 "Анатолий Кулаков" И новенький проект Fonts, который нацелен на то, чтобы загружать и отрисовывать кроссплатформенно шрифты.
2819.72 2825.60 "Анатолий Кулаков" Сейчас поддерживается довольно небольшое подмножество, но проект активно развивается и тоже, наверное, что-то интересное из этого может выйти.
2825.60 2827.60 "Игорь Лабутин" Хорошо, прекрасно.
2827.60 2828.60 "Игорь Лабутин" Пойдем дальше.
2828.60 2831.60 "Игорь Лабутин" Не выпуска подкаста без новостей от JetBrains.
2831.60 2833.60 "Игорь Лабутин" ReSharper 2020.2.
2833.60 2840.60 "Анатолий Кулаков" Да, как всегда, там куча-куча страниц, что мы заимпровили, какие новые ввели анализаторы и так далее.
2840.60 2842.00 "Анатолий Кулаков" Не будем все это обсуждать.
2842.00 2845.20 "Анатолий Кулаков" Я выделил парочку моментов, которые лично для меня интересны.
2845.20 2848.60 "Анатолий Кулаков" Прежде всего, это мега-фича, которую я долго ждал.
2848.60 2851.00 "Анатолий Кулаков" Называется она "CodeCleanup on save".
2851.00 2855.60 "Анатолий Кулаков" То есть, как только ваш файл будет сохранен, будет автоматически запускаться код Cleanup.
2855.60 2857.20 "Анатолий Кулаков" И это, товарищи, гениально.
2857.20 2859.60 "Анатолий Кулаков" Это прекрасно и это должно быть во всех проектах.
2859.60 2866.40 "Анатолий Кулаков" Чтобы автоматически форматировался код, удалялись лишние пробелы, правильно расставлялись точки с запятыми, с скобочками.
2866.40 2870.00 "Анатолий Кулаков" Чтобы это все делалось за нашей спиной, и мы даже об этом не задумывались.
2870.00 2874.00 "Анатолий Кулаков" Настройки прекрасные, как мы даже не могли мечтать.
2874.00 2879.40 "Анатолий Кулаков" Можно ограничить эту функцию по расширению файликов, то есть задать какую-то маску.
2879.40 2885.00 "Анатолий Кулаков" Можно сделать так, чтобы не весь файл чистился, а только та часть файла, которая в данный момент отредактировалась.
2885.00 2889.00 "Анатолий Кулаков" Что тоже актуально, если у вас там файл очень большой, и не хочется зря мусорить в историю.
2889.00 2900.00 "Анатолий Кулаков" И единственное, чего мне для счастья не хватает от Visual Studio, и может быть даже от ReSharper, это уникальные функции, которые невозможно дождаться уже какое десятилетие.
2900.00 2903.00 "Анатолий Кулаков" Функция называется "автоматически сохранять файлик".
2903.00 2911.60 "Анатолий Кулаков" Почему-то ни один мега-мощный редактор, стоящий миллионы, и ни один JetBrains не додумался просто сделать функцию, которая автоматически сохраняет мой гребаный файлик.
2911.60 2919.00 "Анатолий Кулаков" Я как еще в 90-е по-прежнему натренировал свои пальчики на то, чтобы они каждые 5 секунд нажимали Ctrl+S или Ctrl+Shift+S.
2919.00 2929.00 "Анатолий Кулаков" Есть у Visual Studio настройка с авторе-кавером, которая может автоматически сохранять ваши файлы, но там размерность идет что-то в минутах, около 5 минут.
2929.00 2937.60 "Анатолий Кулаков" Есть какой-то плагин, который доступен к прошлой версии студии, а в этой версии автор отказался его почему-то поддерживать, или он как-то глючно работает, или несовместим.
2937.60 2942.00 "Анатолий Кулаков" То есть это какая-то огромная эпопея, казалось бы, сущая очень маленькая проблема.
2942.00 2947.00 "Анатолий Кулаков" Человек из JetBrains, мне для вас еще один мега-реквест есть.
2947.00 2953.80 "Анатолий Кулаков" Сделайте, пожалуйста, галочку, которая называется "Просто сохранять мои файлики всегда, как только я их меняю", ну или там "вайдли" где-нибудь.
2953.80 2958.00 "Анатолий Кулаков" Я уверен, это одна строчка на реализацию должна быть, не считая UI.
2958.00 2959.80 "Анатолий Кулаков" Будет вам честь и хвала.
2959.80 2962.60 "Анатолий Кулаков" Также есть обновление по ReSharper Command Line Tool зам.
2962.60 2968.20 "Анатолий Кулаков" Теперь ReSharper Command Line Tool может запускаться под .NET Core на Windows, Linux и Mac OS.
2968.20 2972.20 "Анатолий Кулаков" Также вы можете установить и запустить его с помощью .NET Core Global Tools.
2972.20 2981.40 "Анатолий Кулаков" Этот ReSharper Command Line Tool - это набор анализаторов, который вы можете запускать не только в вашем ReSharper или вашем Ryder, но и на вашем билд-сервере, что очень удобно.
2981.40 2985.40 "Анатолий Кулаков" Если вы помните наши прошлые выпуски, то там мы обсуждали GitHub Linter.
2985.40 2992.00 "Анатолий Кулаков" Это как раз та штука, в которой люди так и не смогли с полпинка завести какой-то Linter под C#.
2992.00 2996.80 "Анатолий Кулаков" То есть сейчас Linter, который просто так поставить и запустить под C#, его, грубо говоря, не существует.
2996.80 3001.40 "Анатолий Кулаков" И вот JetBrains Command Line Tool теперь ставится как Global Tool.
3001.40 3007.00 "Анатолий Кулаков" Его можно установить одной командой и запустить как раз-таки на вашем C#-сервере без всяких проблем.
3007.00 3015.20 "Анатолий Кулаков" Я надеюсь, что в GitHub Linter его кто-нибудь привяжет и мы получим, наконец, нормальный дефолтный Linter для всего GitHub.
3015.20 3020.80 "Анатолий Кулаков" Также .trace, .cover и .memory, они тоже успешно запускаются под Linux.
3020.80 3023.40 "Анатолий Кулаков" У Ryder тоже множество всяких нововведений.
3023.40 3032.40 "Анатолий Кулаков" В частности, они переписали TestRunner, о чем мы говорили в прошлых выпусках, и написали новый Localization Manager.
3032.40 3038.80 "Анатолий Кулаков" Localization Manager, ну, как Localization Manager, я посмотрел в принципе все, что должен уметь, он умеет.
3038.80 3047.50 "Анатолий Кулаков" Выделять строки, показывать все удобно, рядышком различные переводы, экспортировать, импортировать, все делается довольно в приятном интерфейсе.
3047.50 3050.40 "Анатолий Кулаков" Куча есть дополнительных hotkeys, которые помогают вам с этим справляться.
3050.40 3053.00 "Анатолий Кулаков" Ну, то есть все, что должно быть в Localization Manager.
3053.00 3059.00 "Игорь Лабутин" Ну, удобно, да, потихонечку двигаемся в UI-сторону, полная поддержка всяких таких штук.
3059.00 3061.00 "Игорь Лабутин" Почему нет?
3061.00 3066.00 "Игорь Лабутин" Теперь хочется поговорить немножко не про Toolz-овую часть, а про NuGet.
3066.00 3072.00 "Игорь Лабутин" Есть у нас такой замечательный сайти NuGet.org, где недавно запилили Advanced поиск.
3072.00 3083.80 "Игорь Лабутин" И я, когда прочитал заголовок новости, думал, ну, интересно, как бы, что ж такого можно сделать Advanced, там уже есть поиск с учетом по тегам, авторам, еще что-то, что такого можно сделать Advanced.
3083.80 3091.60 "Игорь Лабутин" И выяснилось, что они добавили такую небольшую панельку под поиском, где можно потыкать пяток галочек.
3091.60 3093.40 "Игорь Лабутин" Это вот и есть тот самый Advanced?
3093.40 3094.40 "Анатолий Кулаков" Именно так.
3094.40 3097.60 "Анатолий Кулаков" Или новость, или хохма, я так до конца тоже и не разобрался.
3097.60 3109.40 "Анатолий Кулаков" То есть весь Advanced заключается в том, что они добавили поиск по типам, теперь можно поискать только пакеты, в которых есть .NET Toolz, .NET Global Tools и .NET Local Tools, они все распространяются через NuGet.
3109.40 3112.40 "Анатолий Кулаков" То есть точно такие же NuGet пакеты, как и все остальное.
3112.40 3123.40 "Анатолий Кулаков" Теперь можно поискать только по ним, или, например, можно поискать только по темплейтам, по тем .NET темплейтам, которые как раз таки ставит консольная утилитка, или можно теперь отобразить в Visual Studio.
3123.40 3125.40 "Анатолий Кулаков" Они тоже распространяются в виде NuGet пакетов.
3125.40 3127.80 "Анатолий Кулаков" Ну, то есть вот эти два типа теперь можно поискать.
3127.80 3129.40 "Анатолий Кулаков" Еще некий тип Dependency.
3129.40 3132.40 "Анатолий Кулаков" Я не очень понял вообще, что это такое.
3132.40 3138.40 "Игорь Лабутин" Dependency - это те самые обычные NuGet пакеты, типа вот Image Sharp, это просто зависимости для приложений.
3138.40 3150.40 "Игорь Лабутин" То есть если ты не хочешь .NET Toolz и не хочешь видеть темплейты, а вот тупо ищешь как бы там, не знаю, какой-нибудь NuGet пакетик для своего приложения, выполняющего определенную задачу, вот выбираешь Dependency.
3150.40 3152.40 "Анатолий Кулаков" Все остальное типа.
3152.40 3166.40 "Анатолий Кулаков" Вот, не знаю, многие может не в курсе, но NuGet.org, он используется как storage пакетов не только для обычных пакетов, которые вы можете поставить из своего C# или F# проекта и использовать.
3166.40 3174.40 "Анатолий Кулаков" NuGet.org, он по факту превратился в такой storage произвольных контейнеров, контейнеров с чем угодно.
3174.40 3180.40 "Анатолий Кулаков" Это даже сейчас в этих пакетах находится не просто DLL или не просто Assembly или исходный код может быть.
3180.40 3184.40 "Анатолий Кулаков" Сейчас в этих пакетах находится абсолютно все, все, что вы только можете себе представить.
3184.40 3191.40 "Анатолий Кулаков" Например, раньше PowerShell использовал для хранения своих модулей тот же самый NuGet.org.
3191.40 3197.40 "Анатолий Кулаков" Сейчас он переехал на отдельный PowerShell Gallery и модули хранятся в тех же самых NuGet.org пакетах.
3197.40 3203.40 "Анатолий Кулаков" Также, если мне память не изменяет, ранние версии ReSharper использовали NuGet.org для распространения своих собственных плагинов.
3203.40 3207.40 "Анатолий Кулаков" По-моему, Choco я там видел в сборке.
3207.40 3220.40 "Анатолий Кулаков" Сейчас там точно есть плагины для Nuke, для C#, ну, то есть для множества таких инструментов, которые просто не хотят заводить какую-то свою плагину инфраструктуру, а тупо упакуют свои плагины в NuGet.org пакеты и запаблишуют это NuGet.org.
3220.40 3222.40 "Анатолий Кулаков" Вот там этого мусора очень-очень много.
3222.40 3232.40 "Анатолий Кулаков" И вот если бы NuGet каким-то образом проаннотировал и сделал бы поиск по этим типам, это было бы, наверное, гораздо больше и гораздо интереснее.
3232.40 3236.40 "Анатолий Кулаков" А то, что он собрал, ну, это какой-то позор.
3236.40 3248.40 "Игорь Лабутин" Ну, наверное, они сделали то, что могли по известным, грубо говоря, атрибутам в метаданном, и дальнейшая работа, это просто, может быть, действительно будут расширять дальше и добавлять новые типы.
3248.40 3250.40 "Игорь Лабутин" Но, да, пока это выглядит как...
3250.40 3256.40 "Игорь Лабутин" Ну, не знаю, из всего этого мне пока полезно только то, что можно поискать отдельно по удобным тулам.
3256.40 3257.40 "Игорь Лабутин" Вот это приятно.
3257.40 3258.40 "Игорь Лабутин" Да, хоть что-то.
3258.40 3261.40 "Игорь Лабутин" Ну, наверное, с тулингом всё.
3261.40 3267.40 "Игорь Лабутин" Есть ещё одна новость у нас, она не очень, можно сказать, свежая, но тем не менее хочется её затронуть.
3267.40 3269.40 "Игорь Лабутин" Это новая книжка.
3269.40 3274.40 "Игорь Лабутин" Мы периодически рассказываем про всякие вышедшие новые книжки, и тут на глаза попалась...
3274.40 3285.40 "Игорь Лабутин" Как-то она не широко рекламировалась, и я совершенно случайно на это наткнулся, но вышло третье издание книжки Framework Design Guidelines от нескольких авторов.
3285.40 3311.40 "Игорь Лабутин" Один из них это Каржиш Савалина, видимо, .NET архитектор, он долго работает в Microsoft с 1999 года и участвовал в раннем, так сказать, развитии платформы .NET, и в 2008 году вышло предыдущее, второе издание этой книжки, так что прошло 12 лет, прежде чем она переиздалась на третье издание со всеми современными штуками и особенностями .NET.
3311.40 3320.40 "Игорь Лабутин" Давным-давно, когда я только начинал работу в .NET стеке, я её читал, это был как раз-таки, наверное, 10 или 11 год, тогда она оказалась вполне современной.
3320.40 3331.40 "Игорь Лабутин" Не со всеми идеями я был согласен, и, наверное, я уже так основной контент книжки подзабыл, но третье издание выглядит, ну так, вполне многообещающе, надо будет посмотреть, что там поменяли.
3331.40 3357.40 "Игорь Лабутин" И по поводу, собственно, выхода этой книжки, этот самый Кашиштов, он на Reddit сделал такую сессию вопросов и ответов, вида "спросите меня, что хотите, я вам что-нибудь отвечу", и в частности, рассказал несколько забавных фактов из истории .NET и своего участия там, и вообще поделился, так сказать, своим видением на различные вопросы, которые волнуют современные .NET разработчики.
3357.40 3380.40 "Игорь Лабутин" Из забавных фактов, один из вопросов, который мы задали, это самый, так скажем, плохой API, который вы когда-либо задизайнили в .NET, и он сказал, что, ну, вообще говоря, я дизайнил много разных API, то есть лист от T, который мы все используем каждый день, это его работа, span от T, это в каком-то смысле тоже его работа, и самый ужасный класс, по его мнению, это класс процесс, который SystemProcess, если я правильно помню.
3380.40 3393.40 "Игорь Лабутин" И типа это внутренняя шутка команды BaseClassLibrary про то, что, ну, в общем, то, что задизайнил класс процесс, это как бы, да, это показатель того, как мне надо дизайнить API.
3393.40 3419.40 "Игорь Лабутин" И поскольку он был как раз-таки архитектором и развивал .NET, и API в частности, он входил в .NET API Review Board, то есть некоторый такой совещательный орган, так скажем, который утверждал или как-то просил поменять все новые .NET API, поэтому, собственно, работая на такой роли, он как бы и пришел к тому, что вот надо написать книжку про, а как правильно вообще дизайнить фреймворки.
3419.40 3427.40 "Игорь Лабутин" И так родилась эта книжка, она выдержала одно и второе издание, и вот тут наконец-таки он ее обновил до третьей, потому что много чего поменялось.
3427.40 3450.40 "Игорь Лабутин" И как он сам говорит, что самая большая проблема .NET API тех ранних лет и довольно долго, только за исключением последних нескольких лет, это то, что .NET API придумывался очень простым, очень выразительным, но вообще никто не заботился о том, насколько быстро будет работать с таким API, быстро в смысле перформанса конечного приложения.
3450.40 3469.40 "Игорь Лабутин" То есть абстракции это хорошо, там всякие стримы абстракции, хорошо, но все-таки там лишние локейты памяти, вот это все, оно мешает нормальной работе, и вот рекомендации API тех времен, они как-то вообще не задумывались о производительности, но к счастью, сейчас это все меняется.
3469.40 3484.40 "Игорь Лабутин" Вот, и два забавных факта, еще дополнительных которых я хотел привести, на вопрос, какие книжки вы порекомендуете почитать, если вы хотите изучить .NET, он привел довольно-таки, ну, с моей точки зрения, неожиданный для меня список.
3484.40 3486.40 "Игорь Лабутин" Как ты думаешь, первая книжка?
3486.40 3488.40 "Анатолий Кулаков" Ну, я думаю, Рифтера надо почитать.
3488.40 3492.40 "Игорь Лабутин" Согласен, CLRVRC# by Jeffrey Richter, вторая книжка.
3492.40 3495.40 "Анатолий Кулаков" Я так понимаю, это же не только про API, да?
3495.40 3499.40 "Анатолий Кулаков" Он же в общем про изучение .NET в глубину, да?
3499.40 3500.40 "Анатолий Кулаков" Есть идеи.
3500.40 3503.40 "Анатолий Кулаков" Не знаю, Сашу Гольдштейна, наверное, сурово рекомендовать?
3503.40 3506.40 "Игорь Лабутин" Саша Гольдштейна с про .NET Performance, да, книжка?
3506.40 3513.40 "Игорь Лабутин" Ну, да, это, ну вот, как ни странно, у него вторая рекомендация, это Concurrent Programming on Windows by Joe Duffy.
3513.40 3517.40 "Анатолий Кулаков" Да, тоже не очень про ленинг .NET, наверное, Concurrent от Joe Duffy.
3517.40 3528.40 "Игорь Лабутин" Да, она, по-моему, все-таки с примерами на .NET, если я помню правильно, но все-таки она как-то, ну, такая суровая книжка, хотя, конечно, в современном мире Concurrent полезно знать.
3528.40 3532.40 "Игорь Лабутин" А вот третья книжка меня очень удивила, это про .NET Benchmarking Андрея Акиньшина.
3532.40 3535.40 "Игорь Лабутин" От Андрея, быстро он популярным становится, смотри.
3535.40 3547.40 "Игорь Лабутин" Да, то есть я вообще не ожидал, что эта книжка будет рекомендована в качестве "Как поучить .NET", но, наверное, если вы ее прочитаете и поймете, то вы, наверное, крут и, наверное, вы уже, можно сказать, практически знаете .NET.
3547.40 3550.40 "Игорь Лабутин" Но Андрей молодец, написал такую полезную книжку.
3550.40 3570.40 "Игорь Лабутин" Вот, и второй факт, о котором я как-то на самом деле не думал, мы много раз в этом подкасте обсуждали такую, ну, спорную фичу как Default Interface Methods в C#, и много-много раз обсуждали, как бы, зачем она может быть полезна, есть куча статей в интернете, вообще, кто ее придумал, как бы, не приведет ли это куда-нибудь.
3570.40 3572.40 "Анатолий Кулаков" И куча ругательств, и куча споров.
3572.40 3600.40 "Игорь Лабутин" Да, а как бы Кашиштов считает, что, ну, как бы, есть ощущение, по крайней мере, он это напрямую не высказал, но, тем не менее, что одна из полезностей этой фичи, она не для конечных разработчиков, она для разработчиков framework, она позволяет легко, достаточно, добавлять, допустим, и методы, интерфейсы, которые есть во фреймворке, не ломая вообще всю совместимость обратную, за которую .NET очень борется.
3600.40 3626.40 "Игорь Лабутин" Как бы, и, в принципе, какая-то доля смысла в этом есть, то есть, это фича как бы в языке, но в основном предназначенная для самого же фреймворка, чтобы можно было подольше держать не ломающие изменения, то есть, добавить какой-нибудь там i-list новый метод, и чтобы все ваши кастомные коллекции не ломались от этого, то в дефолтную версию добавят, конечно же, реализацию какую-нибудь там, может быть, немножко медленную через существующие, опять же, другие проперти.
3626.40 3631.40 "Игорь Лабутин" Естественно, сам фреймворк подкрутит, чтобы там было быстро, ну, а вы подкрутите по мере силы необходимости, если вам нужно.
3631.40 3638.40 "Игорь Лабутин" То есть, вот в таком ключе, когда вы именно фреймворк-дизайнер, наверное, может быть, дефолтный интерфейс-метод полезен.
3638.40 3644.40 "Анатолий Кулаков" Ну, безусловно, для них это оправданно, но какой-то все равно, садочек от этого ломания устоев, устается.
3644.40 3655.40 "Игорь Лабутин" Нам нужна внутренняя версия какого-нибудь компилятора или чего-нибудь, чтобы эта фича включается только, когда он это смотрит на SDK, а не видна, когда смотрит снаружи.
3655.40 3658.40 "Игорь Лабутин" Да, ну, в общем, книжка хорошая, читайте, изучайте.
3658.40 3671.40 "Игорь Лабутин" На Амазоне я, правда, вижу всего один единственный пока отзыв, хотя книжка вышла в июле, но, наверное, она все-таки достаточно узко специализированная, поэтому вряд ли мы будем ждать слишком много отзывов в первые же месяцы, так скажем, продаж.
3671.40 3679.40 "Игорь Лабутин" Но, если вы пишете какие-то API, если вы дизайните API, если вы пишете свои собственные SDK, я рекомендую ознакомиться.
3679.40 3684.40 "Игорь Лабутин" Вряд ли автор API самого .NET посоветует вам что-то плохого.
3684.40 3687.40 "Игорь Лабутин" Тем более, что он не один автор на самом деле, их трое.
3687.40 3695.40 "Игорь Лабутин" Так что и все они из Microsoft, и все они как-то участвуют в жизни .NET на глубоком уровне, так что ценные советы наверняка.
3695.40 3699.40 "Игорь Лабутин" Ну, что, на этом у нас вроде новости пока закончились, которые мы хотели осветить.
3699.40 3710.40 "Анатолий Кулаков" Да, в принципе, еще есть много о чем поговорить, но после отдыха сильно напрягаться не хочется, поэтому давай оставим все сложные и большие статейки на потом, а сегодня давай уже закругляться.
3710.40 3711.40 "Игорь Лабутин" Давай.
3711.40 3719.40 "Игорь Лабутин" Немножко вспомним тогда, я сейчас как обычно напомню о чем мы поговорили, чтобы если вы слушаете внезапно в выпуске с конца, вы знали про что вы только что прослушали.
3719.40 3721.40 "Игорь Лабутин" Или про что вы будете потом слушать.
3721.40 3724.40 "Игорь Лабутин" Это новинки .NET Foundation.
3724.40 3729.40 "Игорь Лабутин" Срочно включаем двухфакторную авторизацию, иначе в .NET Foundation вы не попадете.
3729.40 3733.40 "Игорь Лабутин" И ищем метапы на новой карте, или может она не очень новая, но тем не менее.
3733.40 3738.40 "Игорь Лабутин" Посмотрели на два последних превьюшки .NET пятого, которые действительно последние превью.
3738.40 3740.40 "Игорь Лабутин" Дальше будут релиз кандидаты.
3740.40 3745.40 "Игорь Лабутин" Превью два Visual Studio 2019 с какими-то небольшими обновлениями.
3745.40 3748.40 "Игорь Лабутин" Новые методы App Trimming.
3748.40 3755.40 "Игорь Лабутин" Как теперь можно порезать ваш код еще мельче и выкинуть все ненужное из приложения поменьше.
3755.40 3760.40 "Игорь Лабутин" И новые анализаторы, прямо встроенные в компилятор с настраиваемым уровнем.
3760.40 3766.40 "Игорь Лабутин" И отсутствие необходимости подключать стандартные Nuget пакеты для этого.
3766.40 3768.40 "Игорь Лабутин" Также немножко поговорили про Tooling.
3768.40 3771.40 "Игорь Лабутин" Новый OpenTelemetry зарелизился, правда пока в бете.
3771.40 3781.40 "Игорь Лабутин" Релиз ImageSharp, новинки ReSharper, Rider и всех сопутствующих Tools. Ну и странный немножко, но все-таки Advanced Search на Nuget.org.
3781.40 3785.40 "Анатолий Кулаков" Да, летом разработчики не спали, а тоже выпускали свои релизы.
3785.40 3786.40 "Анатолий Кулаков" Так, на этом все.
3786.40 3794.40 "Анатолий Кулаков" Наверное, давайте, чтобы вам было не грустно нас ожидать следующий выпуск, который мы постараемся не затягивать, давайте мы еще разыграем лицензии AddBrains.
3794.40 3799.40 "Анатолий Кулаков" Условия остаются теми же самыми, но теперь мы будем разыгрывать целых шесть лицензий.
3799.40 3808.40 "Анатолий Кулаков" Давайте так, одна лицензию получит человек, который находится в списке пролайкавших этот выпуск ВКонтакте.
3808.40 3812.40 "Анатолий Кулаков" Одну лицензию получит человек, который расшарил эту запись ВКонтакте.
3812.40 3817.40 "Анатолий Кулаков" Одна лицензия уйдет тому, кто полайкал запись в Твиттере.
3817.40 3820.40 "Анатолий Кулаков" Одна лицензия уйдет тому, кто расшарил эту запись в Твиттере.
3820.40 3823.40 "Анатолий Кулаков" И две лицензии мы разыграем среди комментаторов на Ютубе.
3823.40 3828.40 "Анатолий Кулаков" Наш подкаст доступен на Ютубе, там часто попадаются полезные комментарии.
3828.40 3830.40 "Анатолий Кулаков" Вот две лицензии будут среди комментаторов.
3830.40 3839.40 "Анатолий Кулаков" Напишите нам что угодно о нашем подкасте, что нравится, что не нравится или если вы не хотите выражать собственное мнение, просто напишите откуда, из какого города, из какой страны вы нас слушаете.
3839.40 3843.40 "Анатолий Кулаков" Может быть в каких условиях, когда гуляете с собакой или когда едете на работу.
3843.40 3845.40 "Анатолий Кулаков" Нам это тоже очень интересно.
3845.40 3847.40 "Игорь Лабутин" А на этом будем завершаться.
3847.40 3848.40 "Игорь Лабутин" С вами был Игорь Лабутин.
3848.40 3849.40 "Игорь Лабутин" И Анатолий Кулаков.
3849.40 3850.40 "Анатолий Кулаков" Всем пока.
3850.40 3851.40 "Анатолий Кулаков" Пока.
3851.40 3852.40 "Анатолий Кулаков" Всем пока.
