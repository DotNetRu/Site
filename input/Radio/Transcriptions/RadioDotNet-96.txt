0.00 16.42 SPEAKER_01 Здравствуйте, уважаемые слушатели, в эфире Радио.нет и выпуск номер 96, и в студии постоянный ведущий Анатолий Кулаков.
16.42 17.42 SPEAKER_00 И Игорь Лобутин.
17.42 18.42 SPEAKER_00 Всем привет.
18.42 37.10 SPEAKER_01 А за нашей студией наши помогаторы, а именно Александр Сергей, Владислав Шевченко, Антон Гурий-Самарин, Лазарев Илья, Виктор, Руслан Артамонов, Александр Ярыгин, Сергей Бизенко, Александр Лаперлин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков, Андреев Азлеев и Бальсима Альджавахири.
37.10 42.18 SPEAKER_01 Спасибо всем, кто нас поддерживает, а также шарит, репостает и комментирует.
42.18 50.02 SPEAKER_01 Поэтому, если вдруг вы никогда не заходили к нам на YouTube, приходите, там у нас разворачиваются интересные дискуссии, некоторые даже полезные.
50.02 59.54 SPEAKER_01 В общем, часто повторяю, поправляют нас и доносят какую-то дополнительную информацию, поэтому как дополнение к выпуску вполне хороший источник.
59.54 62.38 SPEAKER_00 Ну, давай на самом деле начинать потихонечку.
62.38 68.82 SPEAKER_00 Новостей от Майкрософта у нас особо нету, ничего такого не вышло, превью пока не вышло.
68.82 74.74 SPEAKER_00 Скорее всего оно, конечно же, выйдет на следующий день после записи подкаста, но тут уж ничего не поделаешь, придётся ждать следующего выпуска.
74.74 76.78 SPEAKER_00 А пока давай пойдём в статьи.
76.78 78.94 SPEAKER_01 Зато мы можем посвятить выпуск статейчикам.
78.94 79.94 SPEAKER_01 Да.
79.94 92.98 SPEAKER_01 Не каждый раз, когда у нас много новостей, мы доходим до каких-то полезных статей, а тут вот вытащили пачку того, что вам может быть полезно в повседневной жизни, и что как раз-таки не зависит от времени, поэтому этот выпуск можно будет прислушивать вечно, и пойдём по статейчикам.
92.98 97.74 SPEAKER_00 Ну, может быть, не совсем вечно, но действительно полезные статьи у нас попались.
97.74 101.86 SPEAKER_00 И первая статья про EF Core и про миграции.
101.86 121.26 SPEAKER_00 Мы довольно много говорим про EF Core, точнее, не то чтобы много на самом деле, потому что в релиз ноутсов дотнета обычно EF Core уделяется довольно мало времени, там довольно куции какие-то, одна-две-три фичи описывается, остальное говорите, идите смотрите changelog, и поэтому довольно подробно мы про него практически никогда и не говорим.
121.26 123.18 SPEAKER_01 Мы же не пойдём смотреть changelog?
123.18 134.54 SPEAKER_00 Нет, мы не пойдём смотреть changelog, мы пойдём смотреть статью, которая довольно неплохо, обзорно описывает то, что можно и как можно работать с миграциями в EF Core.
134.54 139.42 SPEAKER_00 И давайте для начала просто сообразим и вспомним вообще, что это такое миграция и зачем нам оно надо.
139.42 182.86 SPEAKER_00 То есть понятно, что EF Core, там ORM составляет запросы, всё такое прочее, значит, облегчает маппинг ваших результатов запросов обратно в объекты, это всё здорово и полезно, но только в тот момент, когда у вас уже есть база данных, или даже когда она у вас уже есть, вам её иногда нужно менять, и можно это, конечно, делать как-то отдельно, можно руками, можно даже отдельно прям без каких-либо скриптов менять прям впроди на живую схему базы данных, в принципе, такое делали раньше, когда-то давным-давно, наверное, но это всё очень понятно ведёт к ошибкам, ведёт к тому, что у вас будут разные схемы баз данных там-сям, требует времени, в общем, дико неудобно, поэтому нужно автоматизировать.
182.86 187.98 SPEAKER_00 Автоматизируется это всё обычно с помощью концепции, которая называется миграцией.
187.98 204.26 SPEAKER_00 Это довольно общая концепция, не то чтобы она связана как-то с EF Core конкретно, то есть это просто некоторый способ записать то, как вам нужно изменить базу данных в виде некоторых скриптов, тем или иным способом.
204.26 252.94 SPEAKER_00 Есть способы, когда вы описываете то, что вы хотите получить конечный результат, дальше некоторый тул волшебным образом пытается подумать, как же привести вашу базу данных именно в такое состояние, но, к сожалению, в большинстве случаев миграции так просто без некоторого программистского раздумья автоматически изгенерить не очень получится, потому что данные, которые хранятся в базе, как правило, довольно ценные и случайно, неправильно собранные, неправильно автоматически изгенеренные миграции всё испортить не очень здорово, поэтому, как правило, всё-таки они пишутся плюс-минус руками, ну так, полуавтогенерация, сейчас про это немножко расскажу, но обязательно требуют какого-то ревью и после этого можно их уже коммитить и использовать в плюс-минус автоматизированных скриптах во время раскатки вашего приложения.
252.94 271.26 SPEAKER_00 Причём здесь Евкор, Евкор здесь при том, что Евкор предоставляет свою собственную, так сказать, модель миграции, то, как вы можете описать то, что вы хотите изменить в вашей базе данных, при том, что большинство вещей можно писать на плюс-минус понятном и знакомом C#.
271.26 327.44 SPEAKER_00 Понятно, что могут быть случаи, когда вам C# не хватит и придётся возвращаться уже к SQL, но в целом большинство вещей, не требующих каких-то суперхитрых тюнингов базы данных, справятся с обычным C#, что даёт дополнительное преимущество, что эта миграция может быть применима вообще к любой базе данных, которая поддерживается, понятное дело, Евкором, что, наверное, не то чтобы сильно полезно для продуктов, которые вы ставите куда-то на сервера, но может быть полезно, если вы это делаете в каком-нибудь коробочном продукте, который ставится в какую-нибудь организацию, например, просто так и который в таком случае в качестве полезной фичи может иметь свойство работать на, не знаю, Oracle, SQL Server, PostgreSQL, MySQL, в общем, подставьте сюда любую более-менее плюс-минус поддерживаемую базу данных, которая, например, уже есть в компании, гораздо приятнее.
327.44 348.56 SPEAKER_00 В целом, по Евкору есть довольно неплохая документация от самих Microsoft, она вся очень хорошая и понятная, но в статье дается, так скажем, необходимый минимум для понимания того, что со всем этим делать, как с этим обращаться, и поэтому мы по ней пробежимся.
348.56 351.20 SPEAKER_00 Для начала надо понять, как эти миграции создавать.
351.20 367.42 SPEAKER_00 Значит, если вы работаете с Евкором, у вас уже наверняка есть db.context, у вас есть наверняка какие-то entities, через которые вы общаетесь с базой данных, и для того, чтобы создать вашу первую миграцию, можно сделать одну простую штуку.
367.42 372.98 SPEAKER_00 Нужно позвать некоторую command line тулзу, которая вам создает эту самую миграцию.
372.98 383.88 SPEAKER_00 Способов позвать эту тулзу, на самом деле, несколько, можно использовать .NET Global Tool, там, соответственно, .NET EF и дальше, все, что связано с миграциями, либо есть PowerShell.
383.88 391.00 SPEAKER_00 Статья использует PowerShell, команды в PowerShell, это, соответственно, это addMigration, и дальше название вашей миграции.
391.00 410.92 SPEAKER_00 Как правило, первая миграция называется createDb, потому что первое, что она сделает, она, имея на руках ваше определение entities, то есть всех, по сути, табличек, колонок и там, связи между ними, с которыми работает именно ваше приложение, она создаст некоторый кусочек кода.
410.92 414.16 SPEAKER_00 На самом деле, она создает класс, который наследуется от класса migration.
414.16 417.24 SPEAKER_00 В этом классе есть два метода, up и down.
417.24 427.80 SPEAKER_00 Up — это, соответственно, когда вы будете применять эту миграцию для того, чтобы смигрировать базу данных из старой версии в новую, down, соответственно, наоборот, если вам нужно домигрейтить базу обратно.
427.80 445.36 SPEAKER_00 И в этих методах, up и down, она сгенерит некоторое тело методов, которые будут, по сути, создавать базу данных необходимую и достаточную для того, чтобы ваше entity, ваше приложение, которое работает с теми entities, обязательно в DB-контексте, могло работать.
445.36 454.84 SPEAKER_00 Понятное дело, что, возможно, там нужны какие-то дополнительные индексы, возможно, вам нужны какие-то дополнительные хранимые процедуры, view, функции, ну, все, что угодно нестандартное.
454.84 462.84 SPEAKER_00 Такие штуки придется добавлять руками, но базовый набор там таблицы и колонок она создаст и связи между ними.
462.84 488.76 SPEAKER_00 Дальше это все, конечно, хорошо и здорово, таким образом, вы можете создать первую миграцию, как правило, первая миграция более-менее адекватна, вот, исключением всяких специальных SQL вещей, либо каких-то кастомизаций, которые вы знаете, что вы будете запускаться только на Postgres, и вы хотите сразу кастомизировать создание базы именно под Postgres, дополнив его какими-то специфическими позгоревыми штуками.
488.76 492.68 SPEAKER_00 Но дальше нужно эту миграцию кастомизить, как правило.
492.68 512.32 SPEAKER_00 Вы точно так же можете говорить add migration, даже когда у вас уже есть другие миграции, и в этот момент, на самом деле, EF Core будет поднимать некоторый временный контекст базы данных, смотреть, что у вас есть сейчас в вашей базе данных, которую вы укажете connection строкой, и сравнивать это с тем, что есть в модели данных, которую вы написали в коде.
512.32 534.52 SPEAKER_00 То есть вы в коде дописываете, допустим, новое поле в какой-нибудь entity, говорите EF, там, migration, add, и имя новой миграции, и после чего EF Core сравнит базу данных с новым набором классов entity и добавит или что-то изменит в вашей схеме базы данных, добавит код, который будет изменять схему базы данных.
534.52 535.52 SPEAKER_00 В чем проблема?
535.52 538.84 SPEAKER_00 Проблема в том, что этот код может быть довольно наивен.
538.84 548.28 SPEAKER_00 То есть одно время, я не помню, сейчас поменялся это или нет, по-моему, это все-таки пофиксили, но одно время, если, например, вы переименовываете колонку в базе данных, EF Core генерил довольно простую штуку.
548.28 550.92 SPEAKER_00 Он сначала дробил колонку, потом добавлял колонку с новым именем.
550.92 563.52 SPEAKER_00 Формально миграция верная, фактически миграция ведет к потере данных, поэтому понятно, что, как правило, вы это меняли на явный вызов функции renameColumn, которая делает это без потери данных.
563.52 581.28 SPEAKER_00 Особенно, когда мы говорим про down-миграцию, т.е. когда мы говорим, что нам нужно что-нибудь откатить обратно, если вы в миграции drop-аете колонку, которая по какой-то причине вам стала не нужна, то понятно, что в down-миграции вы уже никакую колонку ниоткуда не восстановите.
581.28 594.72 SPEAKER_00 И некоторые миграции однонаправленные, либо некоторые миграции нужно смотреть, как делать, если вам действительно нужно уметь откатиться, колонку, не знаю, переименовывать во что.
594.72 607.68 SPEAKER_00 Я даже не знаю, я обычно исповедую подход, что down-миграции никогда не надо, всегда движемся только в сторону up, потому что на моей практике как-то редко были случаи, когда нужны были именно down-миграции.
607.68 610.20 SPEAKER_01 Ну действительно, они пригождаются практически никогда.
610.20 621.04 SPEAKER_00 И мне кажется, что как только они потребуются, это будет как раз тот случай, где типа drop-колонка был, и down-миграция тебе ничего не даст, всё равно восстановить колонку не получится.
621.04 622.04 SPEAKER_00 Да-да.
622.04 642.00 SPEAKER_00 Для того, чтобы кастомизировать, там есть довольно шикарный набор fluent API, т.е. вы пишете NaVi, Sharpie, но если вам нужен прям кастомный SQL, то там есть метод под названием SQL, незамысловато названый, куда передаётесь просто строчку с SQL, куда можно записать любой кастомный SQL, который вы хотите.
642.00 649.64 SPEAKER_00 Ну допустим, вы создали миграцию, вы написали набор миграции, теперь в вашем приложении есть пачка миграций.
649.64 665.20 SPEAKER_00 Это некоторый набор C# файликов или возможно рядом лежащих там SQL скриптов, которых вы заполняете внутри вот этого SQL метода, и надо, собственно, понять, а как применять-то, что со всем этим делать, как же это применять.
665.20 675.64 SPEAKER_00 Ну, первый способ, он такой довольно прямой, в лоб, я его практически не видел, чтобы он когда-либо использовался, но он есть.
675.64 684.76 SPEAKER_00 Можно сделать это, давайте не так, давайте прежде чем говорить, как это можно сделать, поговорим, когда это нужно делать, потому что может быть это более важно.
684.76 701.80 SPEAKER_00 Вот у нас есть наше приложение, вы как-то поменяли код, чтобы оно работало с, требовало каких-то новых фич от базы данных, у вас даже в коде есть миграция, которая говорит о том, как же это нужно сделать, чтобы привести базу в новое состояние, но вопрос, когда же это делать.
701.80 717.72 SPEAKER_00 Есть несколько вариантов, вариант, точнее как, вариант такой, что ваш код, скорее всего, в любом случае ждет так или иначе каких-то новых фич от базы данных, иначе зачем миграция, если код работает все еще со старой версией.
717.72 720.64 SPEAKER_00 Могут быть случаи, когда это нужно, но это большая редкость.
720.64 730.88 SPEAKER_00 Например, добавление индекса, в принципе его можно делать как угодно, от этого работа кода с точки зрения корректности не пострадает, возможно скорость где-то улучшится или ухудшится.
730.88 743.96 SPEAKER_00 Но предположим, что у нас есть изменения, которые требуют такое, так что нам нужно, чтобы новый код работал с новой схемой базы данных, желательно тогда миграцию провести перед тем, как приложение стартует.
743.96 770.96 SPEAKER_00 Это все понятно, но у нас в нашем современном мире кубернетес и прочих горизонтально масштабируемых сервисов есть проблема с тем, что довольно многие используют так называемый rolling upgrade, то есть когда вы кубернетесу говорите вот новая версия нашего контейнера, давай мы его раскатим аккуратненько, и кубернетес по очереди накатывает один код, выключает один из старых, накатывает еще один новый, выключает один из старых.
770.96 780.72 SPEAKER_00 То есть у нас есть некоторое время, когда у вас с одной стороны работает старый код, с другой стороны работает новый код, и при всем при этом миграция уже должна быть как бы проведена.
780.72 782.96 SPEAKER_00 Отсюда следует несколько важных выводов.
782.96 787.28 SPEAKER_00 Во-первых, которые не совсем связаны прямо с EFCore, они применимы к любым миграциям.
787.28 798.44 SPEAKER_00 Когда вы пишете ваши миграции, делайте так, чтобы эти миграции не нарушали работу старого кода, то есть желательно старый код, чтобы продолжала работа, добавляйте новую колонку обязательно с каким-нибудь там дефолтным значением.
798.44 808.96 SPEAKER_00 Добавляйте и там, и nullable она должна быть, добавляйте, или там убирайте колонку, нельзя убирать колонку до тех пор, пока старый код ее хоть как-то использует.
808.96 819.52 SPEAKER_00 Даже если вам очень хочется и вы знаете, что в новом коде она вам больше не нужна, придется потерпеть, сначала раскатить новый элис, который не использует колонку и уже в следующей миграции, в следующем апгрейде удалить колонку.
819.52 822.84 SPEAKER_00 Ну вот такие случаи, в общем, надо понимать и надо отслеживать.
822.84 839.32 SPEAKER_00 Тот факт, что обе версии кода могут работать, но фактически это означает, что миграция будет выполняться по сути параллельно с работающим кодом, то есть у нас работают старые коды, например, если мы в кубере, нам нужно накатить миграцию, пока они работают, а потом раскатывать нужную версию.
839.32 850.80 SPEAKER_01 Это очень похоже, например, если мы задумывались, когда мы обсуждали версионирование в API, мы тоже там советовали не делать breaking changes, не убирать те поля, которые могут юзаться каким-то внешним системами.
850.80 854.36 SPEAKER_01 А здесь вы 100% знаете, что ваше поле юзается какой-то системой.
854.36 860.60 SPEAKER_01 И в принципе вот все те же правила по постепенной миграции, про избегание breaking changes и так далее, они сюда очень хорошо ложатся.
860.60 876.68 SPEAKER_00 Все так, все так, но на самом деле при апгрейдах баз данных очень рекомендую иногда поспрашивать о ваших DBA, не настроили ли они какую-нибудь там репликацию в какое-нибудь DWH-хранилище вашей схемы, потому что выяснится, что вы проапгрейдите схему, у них сломается репликация.
876.68 915.12 SPEAKER_00 Я встречал такое как-то в одном из проектов, что как-то нужно было замутить какие-то отчетики, но те, кому нужно было, они сказали, ну есть BD, давайте админ, и вы нам это, реплицируйте просто в наше хранилище, все нормально, мы по ним сами сколько будем строить, не нагружая основную базу, ну хорошо же, хорошо, репликация ресурсов особо не жрет, ну как бы, по крайней мере не тормозит основную BD, она может запаздывать, если ресурсов не хватает, но в целом как бы основную работу приложения не тормозит, все хорошо, но мы поменяли схему и сломали отчеты, такое бывает, знайте кто вами пользуется, это тоже в каком-то смысле API может быть, хоть и не очень удобный.
915.12 938.28 SPEAKER_00 Ну вот, возвращаясь к тому, когда же запускать, есть простой способ, который вы увидите, наверное, во всех примерчиках простых на EFCore, можно в самом начале вашего приложения, до того как-то вы там начали слушать ваши контроллеры, сказать, дорогой, значит, EFCore, сделай так, чтобы мы убедились, что база данных на месте.
938.28 1031.32 SPEAKER_00 Мигрейт, что-то там, migrate_db_async, по-моему, называется, не помню, я особо не пользуюсь этим методом, поэтому точное название не помню, но в общем есть там такой метод, функция, который просто приведет в состояние, что точная база данных на месте, но вспоминаем наш предыдущий пойнт про то, что, во-первых, у вас может быть несколько инстансов приложения, и если вы в Кубере такое запустите, то каждый из подов, допустим, у вас довольно большие лимиты на тему масштабирования, и тогда в момент роллинга апгрейдов, Кубернет сможет, на самом деле, по нескольку подов за раз новые версии закидывать в запускаемые, и в таком случае все они побегут обновлять базу данных, конечно же, все эти миграции, ну, как бы, там есть вариант, как сделать такую глобальную блокировку на уровне всех миграций, чтобы только один под смог что-то обновить, но дальше возникнет вопрос, что пока он обновляет, все остальные тупо ждут, у позгрессов, у Кубернетеса есть некоторые лимиты на тайм-аут, на поднятие подов, ну, в общем, там могут возникнуть всякие разные проблемы, а миграции бывают долгие, надо сказать, очень долгие, особенно если вы там перелопачиваете всю табличку, то не знаю, индексы какие-нибудь навешиваете, это может быть очень долго, поэтому не очень хороший способ, кроме того, миграция может упасть, и тогда у вас как-то вроде это, приложение непонятно, то ли стартовать, то ли не стартовать, если не стартовать, то у вас под свалится, Кубернетес его снова попробует поднять, он снова попробует смигревать, что он там натворил в бд, ну, не очень понятно, вот.
1031.32 1050.16 SPEAKER_00 При этом такая опция очень удобна для локальной разработки, то есть вот поставить эту штуку под условия их окружения, их environment, development, в принципе, удобно, тогда вы сразу получаете каждый раз обновленную бдшку, если вы миграциями свою локальную бдшку обновляете, ну, что, в принципе, тоже рекомендуется.
1050.16 1051.16 SPEAKER_00 Вот, это один вариант.
1051.16 1071.00 SPEAKER_00 Второй вариант — это некоторый deployment script, ну, то есть у вас наверняка есть некоторая автоматическая CD-система, которая так или иначе разворачивает ваше приложение, это может быть просто какой-нибудь bash скриптик или не баш, на чем-нибудь написано, парашейль скриптик, там, это может быть Octopus, это может быть кто угодно другой, который разворачивает ваше приложение.
1071.00 1079.60 SPEAKER_00 Можно туда, до того, как вы попросили, не знаю, кубер или еще что-то, развернуть ваше приложение, впилить, соответственно, запуск некоторого deployment скрипта.
1079.60 1093.64 SPEAKER_00 Это, в принципе, неплохой вариант, мы им пользовались довольно долго в случае, когда вы живете не в Кубернетесе, а именно просто разворачиваете ваше, не знаю, приложение в одном единственном экземпляре ваш большой монолит.
1093.64 1103.20 SPEAKER_00 Вполне нормальный вариант, если что-то в базе данных не смогло прогрейдиться, ну, ваш deployment упадет, дальше приложение не пойдет разворачиваться, все нормально, пойдете фиксить.
1103.20 1109.28 SPEAKER_00 Риск в том, что если апгрейд упал в базе данных, то база данных может быть в каком-нибудь странном состоянии, так он и всегда есть.
1109.28 1120.32 SPEAKER_00 От этого риска, к сожалению, мне кажется, никак особо не избавится, кроме как предварительного тестирования на каком-нибудь хорошем бэкапе, который у вас есть, для рисковых и длинных апгрейдов.
1120.32 1139.00 SPEAKER_00 И последний вариант, если вы живете в Кубернетесе, то тогда есть, точнее, предпоследний вариант, если вы живете в Кубернетесе, то тогда у вас есть вариант сделать отдельный так называемый init-контейнер и применить еще некоторые штуки под названием jobs.
1139.00 1155.52 SPEAKER_00 Я сейчас проверю, нет, у меня нет ссылки, я потом повешу ссылочку еще, добавлю в шоу-ноуты, ссылочку на статьи Koindrelog, мы ее не рассматривали подробно, потому что она все-таки не совсем по профилю нашего подкаста, она там продолжает немножко, но в основном про диплоймент.
1155.52 1199.60 SPEAKER_00 Там есть хорошая статья, как как раз-таки диплоить Asp.core-приложение с миграциями в Кумбер с использованием jobs и init-контейнеров, то есть jobs — это некоторая сущность, коллекция подов, которая просто исполняется от начала и до конца, но, возможно, с ретраями, и дальше нужно просто сделать так, чтобы ваша миграция выполнялась как java, а каждый контейнер с помощью концепции называемой init-контейнера ждал, пока эта java закончится, и тогда у вас приложение будет спокойно ждать, это не входит во всякие вот эти вот стартовые пробы Кумбера, соответственно, оно спокойно дождется, пока java-миграция закончится, в единственном экземпляре она одна будет, и все контейнеры, которые ее ждут, спокойно запустятся.
1199.60 1204.24 SPEAKER_00 Вот, прекрасная штука, хорошо работает в окружении, когда у вас Кумбер.
1204.24 1226.12 SPEAKER_00 Вот, и есть еще один способ, он, в принципе, немножко пересекается с дипломинскриптом, потому что в дипломинскрипте вам как-то что-то надо сделать все-таки, вот, то давайте теперь поймем, а как вот нам в дипломинскрипте надо что-то запустить, давайте теперь мы плюс-минус выяснили, когда нужно запускать, точнее, какие у нас есть варианты, теперь давайте поймем как.
1226.12 1234.20 SPEAKER_00 Ну, в случае со стартапом, я уже сказал, там все просто, вызываем код и db.context.database.migrate, и все нормально, это работает.
1234.20 1237.76 SPEAKER_00 В остальных же случаях надо понять, что можно делать.
1237.76 1263.96 SPEAKER_00 Первый случай можно сделать через sql script, у вас есть некоторая либо PowerShell, либо опять же через .NET EF Tool команда, называется, если в PowerShell варианте, script.migrate, script.migration, в которой указывается, от какой миграции и до какой нужно сгенерить скрипт, можно не указывать миграции, а, главное, сгенерить скрипт вообще на все, такое с нуля до последнего состояния, ну, в общем, интервал указывайте.
1263.96 1269.28 SPEAKER_00 И он генерирует sql script, который соответствует ровно тем миграциям, которые вы выбрали.
1269.28 1282.00 SPEAKER_00 Проблема в том, что по дефолту он генерирует не идемпотентный скрипт, то есть если в скрипте написано create table, в смысле, что он понимает, что нужно создать табличку, в скрипте так и будет написано create table, без всяких условий, без всего.
1282.00 1304.44 SPEAKER_00 Это не очень здорово, потому что могут быть ситуации, когда этот скрипт будет накатываться, пытаться накатываться несколько раз из-за каких-то переповторов, лучше всегда передавать ключик idempotent, тогда он каждую миграцию будет оборачивать в некоторые условия, проверить, то есть он понимает, что если нужно создать табличку, то он делает, если табличка не создана, если добавить колонку, он будет проверять, что колонка не добавлена.
1304.44 1316.56 SPEAKER_00 Я, кстати, не знаю, какие условия он вставляет, если там вставки просто .sql, вот этого я что-то не помню, по-моему, он ничего не делает и тупо их выполняет, это ответственность разработчика, сделать так, чтобы эти вставки были идемпотентными.
1316.56 1329.60 SPEAKER_00 То есть вы того, вы можете просто генерить .sql скрипт, например, в билдтайме, положить его вместе с артефактами вашего приложения и в диплоймент скрипте его выполнить, это один вариант.
1329.60 1357.92 SPEAKER_00 Второй вариант можно, если у вас есть исходники вашего приложения, можно просто сказать dotnet.ef.update_database, по-моему, либо PowerShell.update_database вызвать, указать туда, до какой миграции нужно докатить, указать connection string и .net.ef.tool поднимет кусочек вашего приложения, поднимет db.context, поднимет connection string и накатит все эти миграции как нужно.
1357.92 1362.12 SPEAKER_00 Это способ, если у вас исходнички рядом.
1362.12 1371.68 SPEAKER_00 Ну и последний вариант, который как раз таки максимально подходит для варианта с кубером, ну впрочем для диплоймента скрипта он тоже подходит, это называется migration_bundles.
1371.68 1396.96 SPEAKER_00 Это, по сути, некоторое исполнимое приложение, которое вы создаете с помощью команды bundle_migration или dotnet.ef.bundle, оно полностью self-contained, то есть оно не требует никаких исходников, ничего-ничего-ничего, то есть это просто полностью готовое приложение, которое единственное, что нужно передать connection string и оно накатит тот набор миграций, который вы выбрали, на заданную bd с заданным connection string.
1396.96 1406.32 SPEAKER_00 Вот такой бандл уже можно упаковать в контейнер, можно упаковать тоже как артефакт вашего сборки, чтобы отдать его диплоймент скрипту и он уже накатит.
1406.32 1415.40 SPEAKER_00 Вроде как Microsoft считает, что это чуть ли не самый лучший вариант сейчас, не знаю из каких соображений, но вот я из того, что видел, они довольно активно его именно продвигали.
1415.40 1428.72 SPEAKER_00 Ну понятно, что как бы от простого command line отличается тем, что не нужно тащить исходники все, от SQL скрипта не знаю чем отличается, возможно каким-то более расширенным логированием или еще чем-то, вот.
1428.72 1438.68 SPEAKER_00 Ну а из кода db.context.db.is_migrate я подозреваю, что бандл делает ровно то же самое, но просто в более контролируемом и self-contained окружении.
1438.68 1444.48 SPEAKER_00 Вот примерно такая штука с миграциями EF Cora.
1444.48 1450.80 SPEAKER_00 Признаться, мы только на одном проекте использовали миграции EF Cora, в основном я пользовался другими тулами для миграций.
1450.80 1455.76 SPEAKER_00 Я не знаю, Только есть что добавить именно про EF миграции?
1455.76 1458.88 SPEAKER_01 Наверное нет, кроме того, что мы везде используем EF миграции.
1458.88 1462.44 SPEAKER_01 Почему-то на другие тулзы и не осмотрели, наверняка пока хватало.
1462.44 1464.00 SPEAKER_01 Что тебя на них натолкнуло?
1464.00 1473.48 SPEAKER_00 Я не помню, что нас натолкнуло, вот EF миграции мы использовали в проекте, в котором мы с нуля все это делали, в остальных, видимо, оно уже просто было и поэтому просто не переделывали.
1473.48 1475.48 SPEAKER_00 Значит, что есть из других тулов?
1475.48 1484.56 SPEAKER_00 С двумя тулами я встречался, один это Fluent Migrator, это даже не тул, они это гордо называют Migration Framework.
1484.56 1500.88 SPEAKER_00 По сути, там подход похожий на Entity Framework, то есть там тоже для миграции задаются классы, они наследуются от некоторого специального базового класса, там их несколько вариантов есть, для двухсторонних миграций как раз таки, ну с Up и Down есть односторонние, какие-то вариантики есть.
1500.88 1506.80 SPEAKER_00 И есть еще отдельный раннер, то есть это некоторый тоже класс, который позволяет эти все миграции заранить.
1506.80 1516.84 SPEAKER_00 Вы можете этот класс использовать внутри вашего приложения, либо классический подход это написать отдельную маленькую консольную тулзу, которая возьмет этот раннер и, соответственно, применит все миграции.
1516.84 1522.88 SPEAKER_00 То есть это просто набор некоторых Nuget пакетов, которые вы используете для того, чтобы накатить изменения на вашу базу.
1522.88 1533.28 SPEAKER_00 Максимально похожий на EFCore, просто другой, написан полностью на C#, в общем, если надо, можно смотреть, как он устроен внутри, он сушит на GitHub вот это все.
1533.28 1537.76 SPEAKER_00 Его мы использовали, никаких, в общем, нареканий к нему не было вообще, все прекрасно работало.
1537.76 1542.88 SPEAKER_00 Так же, собственно, и к EFCore у меня тоже особых нареканий в общем-то не было, тоже работало.
1542.88 1565.64 SPEAKER_00 Есть еще небольшая библиотечка на дотнете, это dbUp, она, по сути, предназначена просто для применения SQL скриптов, то есть если вы не хотите писать SQL скрипты или по какой-то причине не пишете апгрейд скрипты миграции на C#, а хотите их писать на SQL, то, может быть, вам и не нужна вся вот эта вот мощь и умения EFCore либо Fluent Migrator.
1565.64 1576.00 SPEAKER_00 Возможно, вам будет достаточно dbUp, это просто некая библиотечка, которая отдается набор из SQL скриптов и говорится, вот мне, пожалуйста, от C# до C# примени, ну и она их применяет.
1576.00 1586.68 SPEAKER_00 С треками, что там применено, что не применено, ну, понятно, все как положено для нормального мигратора, но вот тоже на GitHub, тоже open-source, тоже на дотнете, можно посмотреть.
1586.68 1603.92 SPEAKER_00 Дальше есть тул, которым я не пользовался, называется Grate, Grate как решетка, в смысле, G-R-A-T-E, он тупо выполняет SQL скрипты из папочки, грубо говоря, как я понял по описанию, возможно, тоже кому-то пригодится.
1603.92 1606.92 SPEAKER_00 В общем, похож на dbUp, но dbUp — это библиотечка, это тул.
1606.92 1607.92 SPEAKER_00 Вот.
1607.92 1638.52 SPEAKER_00 Ну и еще в одном проекте, несмотря на то, что он был дотнет, но и у нас использовался Liquibase, Liquibase и Flyway — это тулы, наверное, более известные в мире Java, потому что они написаны на Java, Liquibase точно, Flyway, по-моему, тоже, вот, но они в этом смысле максимально агностик для языка, в смысле, вы не можете написать на C#, конечно, миграции для них, но они там пишутся либо в SQL, либо условно в XML, и поэтому абсолютно все равно, просто, ну, вам нужна Java, да, для того, чтобы запускать эти самые миграции.
1638.52 1645.44 SPEAKER_00 Был у нас проект, где вот они тоже почему-то, видимо, исторически использовались, ну, в принципе, тоже работали прекрасно.
1645.44 1646.44 SPEAKER_00 Вот.
1646.44 1669.16 SPEAKER_00 Вот такой вот у нас сейчас обзор получился разных всяких миграций, то есть если вам хватает EF-корных миграций, просто берете и пользуйтесь, если не хватает, посмотрите в сторону Fluent Migrator, возможно, там что-то будет чуть поудобнее сделано, или вам будет чуть по, не знаю, там можно получше покастомизировать, какие миграции накатывать, какие нет.
1669.16 1681.56 SPEAKER_00 Во Fluent Migrator там была, вот я помню, мы даже пользовались одно время, развесистая система тегов, то есть можно миграции тегать, и типа, не знаю, там разным заказчикам, например, в разных окружениях накатывать разные кусочки.
1681.56 1691.76 SPEAKER_00 У нас таким образом не были миграции, которые были помечали, типа, такие сид данные для автотестов, и вот они накатывались только при указании спецтега, при накатке схемы.
1691.76 1697.40 SPEAKER_01 Ну удобно, да, действительно, когда у тебя такие какие-то сложные процессы, сложные миграции.
1697.40 1710.64 SPEAKER_00 То есть вот он этим, мне кажется, наиболее мощный в каком-то смысле, то есть EF, по-моему, такого, наверняка на EF тоже можно такое написать, понятное дело, да, никто не мешает функции up писать все, что вы хотите, но это все-таки сложнее.
1710.64 1711.64 SPEAKER_00 Такая альтернативная поддержка.
1711.64 1721.04 SPEAKER_00 Ну и остальные они такие попроще, тулы, ну, dbup и graded чисто для SQL скриптов, но, может быть, вам этого тоже будет достаточно.
1721.04 1722.04 SPEAKER_01 Такие дела.
1722.04 1730.76 SPEAKER_01 Ну в Quantity Framework раньше миграции были довольно убогие, то есть мне кажется, вот с тех пор, когда они перелезли там на core и более или менее стабилизировались, то там миграции стали довольно хорошие.
1730.76 1743.04 SPEAKER_01 Ну и опять же, вспоминая, не знаю, мои старые проекты, где мы все миграции писали чисто на SQL скриптах, которые по порядочку складывали в папочки, я до сих пор такого, ну, такого удовольствия от написания миграции не получаю.
1743.04 1748.96 SPEAKER_01 То есть надо признаться, что миграции EF, это все равно там на 80% какая-то дикая магия.
1748.96 1761.04 SPEAKER_01 Если ты раньше мог бы зайти в эти SQL скрипты и посмотреть их и проанализировать каким-то образом или даже сделать им downgrade, если ты захотел бы назад что-то вернуть, вот там все это как-то было возможно.
1761.04 1774.60 SPEAKER_01 В общем-то сейчас EF скрипты, если вы захотите посмотреть, что он там генерирует, какие там вещи делает, иногда волосы там становятся, что, как он эти миграции прокручивает.
1774.60 1780.76 SPEAKER_01 Они все, конечно, работают, все, конечно, хорошо, но это не для того, чтобы пользователь на них смотрел, не для того, чтобы им как-то ручками управлять.
1780.76 1785.04 SPEAKER_01 И это мне, конечно, всегда не очень нравится в EF миграциях.
1785.04 1798.12 SPEAKER_00 Да, именно для этого, я так понимаю, была создана в том числе вот эта вот команда script-migrate, чтобы можно было заскриптовать то, что он будет делать в нормальной понятной SQL, например, отдать DBA им, чтобы они посмотрели и хоть, ну, так сказать, одобрили.
1798.12 1803.48 SPEAKER_01 Там тоже ее нельзя назвать, что она прям хорошая, читабельная.
1803.48 1810.00 SPEAKER_01 Точно так же, как и C#-код, который у тебя генерирует стандартный генератор, они не для того, чтобы их люди читали.
1810.00 1815.08 SPEAKER_00 Ну, он хотя бы на SQL, где уже точно понятно, что будет исполняться.
1815.08 1817.12 SPEAKER_00 То есть тут как бы уже хоть что-то.
1817.12 1822.48 SPEAKER_01 Опять же, все равно такое удовольствие, как написание мануальных скриптов, вы не получите ни в одного из этих лоз.
1822.48 1827.62 SPEAKER_01 Опять же, не будете писать, как в DBA, например, просто скриптики.
1827.62 1828.62 SPEAKER_00 Ну да, да.
1828.62 1830.56 SPEAKER_00 Ну, в общем, такие дела.
1830.56 1831.56 SPEAKER_00 Давай дальше.
1831.56 1834.16 SPEAKER_01 Ну, отлично, в принципе, хорошая темка.
1834.16 1837.34 SPEAKER_01 Миграции, я думаю, нужны и всем важны.
1837.34 1838.34 SPEAKER_01 Пойдем дальше.
1838.34 1843.68 SPEAKER_01 Что еще, интересно, всем нужно и всем важно, но никто это не осознает, это шифровать ваши урлы.
1843.68 1847.64 SPEAKER_01 Вот, мы, конечно же, о таком не задумывались, а вот давайте теперь задумаемся.
1847.96 1853.72 SPEAKER_01 Все началось с того, что один из авторов начитался Энди Рахина.
1853.72 1868.00 SPEAKER_01 Это такой опасный человек, кто не знает, это автор RavenDB, наверное, самая популярная и самая единственная база данных, которая написана на C#, и у него очень много интересных концептуальных мыслей в голове рождается.
1868.00 1872.48 SPEAKER_01 Не все он их применяет именно к RavenDB, но блок у него довольно познавательный.
1872.48 1891.32 SPEAKER_01 Там много мусора, конечно, но если появляются самородки, они там многие годы живут, и вот там, не знаю, статья четырехлетней, наверное, давности, когда Энди задался вопросом, а почему мы вообще выставляем наши, допустим, идентификаторы сущностей наружу, в общем, этот вопрос все еще открыт.
1891.32 1905.00 SPEAKER_01 И вот Халид Абдухамед, он тоже знаменитый автор блогов, вот, прочитал эту статью, вдохновился и решил разобраться, а как же сделать хорошо на уровне Айспенета.
1905.00 1908.24 SPEAKER_01 И вот мы сейчас с вами все эти темки и пройдем.
1908.24 1917.04 SPEAKER_01 Почему плохо выставлять голые попоидентификаторы наружу, ну, в частности, в Урлы, например, их отдавать, и что же с этим мы можем сделать в Айспенеткой.
1917.04 1922.36 SPEAKER_01 Прежде всего, давайте разберемся, что же в этом плохого, обычно все идентификаторы выставляют, и все нормально.
1922.36 1935.52 SPEAKER_01 Ну, здесь нужно понимать, что речь в основном идет об идентификаторах, интовых, то есть многие спрашивают, зачем там использовать буйды, зачем использовать строки в виде идентификаторов, и давайте использовать наши красивые инты.
1935.52 1943.36 SPEAKER_01 Ну вот, статья, она в основном рассчитана на то, чем инты плохо выставлять наружу, но некоторые моменты, конечно, можно и гуйдам тоже натянуть.
1943.36 1947.92 SPEAKER_01 Давайте по порядочку, чем же плохо, например, интовые идентификаторы выставлять наружу.
1947.92 1955.44 SPEAKER_01 Прежде всего, есть такая атака, которая называется "Url Tempering", это, по сути, подделка Урла.
1955.44 1957.80 SPEAKER_01 И в чем она выражается?
1957.80 1980.04 SPEAKER_01 Когда вы, например, пишете типичный код, вот сервер мой, вот у меня есть ресурс users, и у этого ресурса я хочу вернуть юзера под идентификатором 1, то абсолютно всем ожидаемое поведение, что если мы идентификатор 1 поменяем на идентификатор 2, то нам вернется уже другой юзер, не с идентификатором 1, а тот, который с идентификатором 2.
1980.04 1990.24 SPEAKER_01 И, в принципе, это очень плохая ситуация, потому что здесь мы можем открыть те данные, которые не подразумевались, что нам будут доступны.
1990.24 2004.40 SPEAKER_01 Эта проблема решается в основном тем, что мы заводим некий security слой, мы заводим аутентификацию, авторизацию, и тому пользователю, которому не нужно доставать юзера 2, а только доставать юзера 1, мы ему эти данные просто напросто не вернем.
2004.40 2019.60 SPEAKER_01 Но здесь, опять же, очень большая сложность влетает в виде security, и очень часто бывает, что разработчики забывают разметить специальный контроллер или специальные методы вот такими параметрами security, или еще где-то что-то пропустить.
2019.60 2041.60 SPEAKER_01 В общем, такая ошибка, когда мы подставляем вместо идентификатора какой-то другой идентификатор, следующий идентификатор, или перебираем пачку из миллиона идентификаторов и пытаемся запросить этот ресурс, она очень частая, и, в принципе, наверное, это самая легкая атака, которую вы можете провернуть, если вдруг общаетесь с какими-то другими сервисами и видите какой-нибудь интовый идентификатор, попробуйте так поделать.
2041.60 2066.00 SPEAKER_01 В общем, я очень много открывал таких видеофайлов и всяких, даже на платных курсах, много платных курсов есть, которые вот так вот идентифицируют свои ресурсы и дают вам ссылку только к тому, что вы купили, но при этом проставляя другие идентификаторы, интовые, по порядку вы можете найти еще очень много открытых курсов, которые никаким security не спрятаны, а спрятаны только тем, что вы якобы не знаете идентификатор ресурса.
2066.00 2073.68 SPEAKER_01 В общем, на самом деле, какая бы эта атака смешная и глупая ни казалась, в сети огромное количество ресурсов, которые ей подвержены.
2073.68 2079.00 SPEAKER_01 И это один из принципов, почему плохо интовые идентификаторы выставлять наружу.
2079.00 2091.08 SPEAKER_01 Потому что вы не знаете, каким образом они попадут наружу и кто их будет использовать, и закроются ли они во всех нужных местах с помощью всяких ваших security авторизаций.
2091.08 2094.88 SPEAKER_01 Могут они закрыться, при этом хакеры могут утянуть ваши данные с помощью такого способа.
2094.88 2104.08 SPEAKER_01 И если мы вдруг идентификатор каким-то образом прячем, то это уже становится невозможным.
2104.08 2121.52 SPEAKER_01 Вторая причина, почему плохо интовые идентификаторы выставлять наружу, это потому что данные идентификаторы они могут вам раскрыть, даже не вам, а внешнему наблюдателю, могут раскрыть тонкости реализации вашей системы.
2121.52 2128.12 SPEAKER_01 Ну, например, известно, что интовые идентификаторы очень любят программисты из реалиционных баз данных.
2128.12 2135.08 SPEAKER_01 Вот именно там у них есть такое поверье, что инты - это всегда красиво, это всегда коротко, и вот давайте делать интовые идентификаторы.
2135.08 2140.48 SPEAKER_01 Если же мы возьмем документные базы данных, то там сразу были введены строки.
2140.48 2141.88 SPEAKER_01 И более популярные строки.
2141.88 2158.76 SPEAKER_01 И именно анализируя вот эти данные, можно раскрыть строение вашей внутренней системы, и также можно выяснить некие архитектурные решения, которые у вас есть, и таким образом тоже спланировать каким-то образом вектор атаки на вашу систему.
2158.76 2166.68 SPEAKER_01 Ну, вплоть до того, что даже если мы берем ГУИДы, то дефолтный алгоритм генерации ГУИДов у большинства вас разный.
2166.68 2173.04 SPEAKER_01 То есть мы легко можем отличить какой-нибудь ГУИД от mongdb, от ГУИДа, который там генерирует mssql.
2173.04 2187.08 SPEAKER_01 Также точно вспоминаем, что у нас есть sequential ГУИДы или ГУИДы, которые ни разу не sequential, у нас у ГУИДов есть разные версии, и вот в зависимости от каких-то определенных параметров мы более или менее можем уже узнать, а что там за база данных стоит.
2187.08 2201.00 SPEAKER_01 Более того, некоторые базы данных со временем переходят на новые генерации ГУИДов, но новой версией, то есть мы можем определить не только базу данных, но и даже ту версию, которая база данных там работает.
2201.00 2213.56 SPEAKER_01 Ну, например, тот же самый ravendb менял способ генерации дефолтных идентификаторов с одного формата на другой, и видя этот формат, вы точно можете сказать, что там raven и даже можете сказать от какой до какой версии.
2213.56 2230.40 SPEAKER_01 В общем, это тоже кажется, что ситуация мало, ну как бы мало опасности она в себе внесёт, но на самом деле, зная то, какая база данных там установлена, злоумышленник уже получает какой-то набор о том, о какие эксплойты можно посмотреть для того, чтобы попытаться её проатаковать.
2230.40 2235.04 SPEAKER_01 То есть это какой-то первичный анализ архитектуры очень хорошо раскрывает.
2235.04 2237.56 SPEAKER_01 Поэтому тоже опасная штука.
2237.56 2248.48 SPEAKER_01 Ну и третий аргумент, который здесь можно привести, то есть почему интовые идентификаторы опасно отдавать наружу, то это может раскрыть некие ваши бизнес-показатели, довольно критичные бизнес-показатели.
2248.48 2266.20 SPEAKER_01 Например, если мы посмотрим на идентификаторы, то их очень любят часто без дырок инкрементировать, это один из плюсов интовых идентификаторов, которые вам приводят, что там не бывает никаких дырочек, ну там кроме удалений, этим мы сейчас можем пренебречь, ну не бывает так, что у тебя там появился идентификатор 200, а потом стал идентификатор 5000.
2266.20 2277.04 SPEAKER_01 В общем, всё-таки их стараются инкрементировать по порядку, ну и базы данных нас на это подвигают, если мы сделаем автоинкрементную колоночку, то она тоже всё будет делать по порядку.
2277.04 2278.04 SPEAKER_01 Чем это плохо?
2278.04 2290.84 SPEAKER_01 Ну естественно, тем, что этот инкремент, его можно анализировать, и благодаря вот этому анализу вы легко можете отследить, какие данные у вас были, например, в начале месяца и какие данные, какой идентификатор у вас был в конце месяца.
2290.84 2308.12 SPEAKER_01 И таким образом вы вполне можете вычислить, а какое количество, например, ордеров у вас было, если это идентификатор ордера, какое количество там заказов поступило в вашу систему, какое количество продуктов может быть ваша система оформила или отослала, или какие пользователи там, сколько пользователей сделал покупок.
2308.12 2311.80 SPEAKER_01 Опираясь на эти идентификаторы, вот такие данные очень легко из системы получить.
2311.80 2320.52 SPEAKER_01 Это в большинстве случаев бизнес не хочет делиться такими показаниями, опять же, всем-всем подряд наружу, и даже об этом никто не задумывается.
2320.52 2329.44 SPEAKER_01 Но анализируя расход идентификаторов через API, злоумышленник, опять же, очень легко вот такие показатели считывает и получает.
2329.44 2330.44 SPEAKER_01 Это неплохо.
2330.44 2335.64 SPEAKER_01 Поэтому вот примерно от вот этих трех векторов мы сами и пытаемся защититься.
2335.64 2345.84 SPEAKER_01 Ну, хорошо, мы выяснили, что интовые идентификаторы - это плохо, но если они у вас уже в системе есть, то, естественно, никто их менять и переводить не будет.
2345.84 2346.84 SPEAKER_01 Что же в этом случае делать?
2346.84 2352.52 SPEAKER_01 Очень просто, прежде чем отдать интовые идентификаторы наружу, их очень полезно можно зашифровать.
2352.52 2356.88 SPEAKER_01 А когда принимаем их обратно, их полезно расшифровать и работать с ними дальше.
2356.88 2367.48 SPEAKER_01 Естественно, руками в каждом запросе шифровать и расшифровывать, это никто делать не будет, поэтому у нас есть неявные методы, в которых нам помогает ISP.NET Core.
2367.48 2370.96 SPEAKER_01 Прежде всего, давайте посмотрим, каким образом мы можем зашифровать значения.
2370.96 2373.56 SPEAKER_01 Это делается довольно просто.
2373.56 2387.12 SPEAKER_01 Для этого нам понадобится свой собственный классик, который мы пронаследуем от специального интерфейса, который называется iOutboundParameterTransformer, как несложно догадаться по названию.
2387.12 2398.40 SPEAKER_01 Интерфейс требует от нас, чтобы мы каким-то образом заэнкодили параметры, которые выдаются наружу, а энкодить мы их будем с помощью такого механизма, как Data Protection.
2398.40 2409.96 SPEAKER_01 Data Protection - это прекрасный слой, который скрывает от нас весь ужас шифрования и все знания о ключах, где они хранятся, как они ротетятся, кому принадлежат и прочее.
2409.96 2418.12 SPEAKER_01 Он выдает прекрасный API, у которого есть два метода - protect и unprotect, и все счастливы при этом.
2418.12 2419.76 SPEAKER_01 Но опять же, это пример.
2419.76 2429.32 SPEAKER_01 В данном примере используется Data Protection, который делает все операции памяти, все ключи, генерирует на лету и так далее.
2429.32 2441.52 SPEAKER_01 Если вы будете это в продакшене использовать, то, естественно, вам нужен более сложный подход, как-то ваши ключи хранятся где-то в пересистительном сторе, у них настроен понятный роллинг и так далее.
2441.52 2450.32 SPEAKER_01 Для примера нам достаточно и какой-нибудь In-Memory криптовальщика, в коем как раз и выступает данная имплементация Data Protection.
2450.32 2456.36 SPEAKER_01 Так, после того, как мы написали наш прекрасный классик с интерфейсиком, его достаточно зарегистрировать в сервисах.
2456.36 2471.16 SPEAKER_01 У нас есть прекрасный RouteOptions, у которого есть ConstraintMap, к которому мы добавляем наш класс и все, после этого все руты, которые проходят через нашу систему, подвергаются нашему шифрованию.
2471.16 2475.48 SPEAKER_01 Поэтому все, что вы выдадите наружу, все ID-шники будут зашифрованы.
2475.48 2482.40 SPEAKER_01 Естественно, это касается не того, когда вы урлы ручками форматируете, это касается каких-то системных утилит.
2482.40 2491.16 SPEAKER_01 Например, есть LinkGenerator, который позволяет вам сгенерить урлы для определенного контроллера, экшена, параметров и так далее.
2491.16 2499.44 SPEAKER_01 Если вы будете пользоваться как положено с помощью LinkGenerator, то у вас все вот эти параметры будут зашифрованы, как мы и рассчитывали.
2499.44 2513.16 SPEAKER_01 Также, если вы там используете какие-то RazorPages, и в этих RazorPages у нас там есть RouteTemplates, эти RouteTemplates, естественно, тоже подхватят наш трансформер, и все RazorPages-ссылочки тоже у вас будут за encryption, и пользователь там, естественно, ничего не увидит.
2513.16 2522.36 SPEAKER_01 Если мы используем DataProtection, то внутри у него используется серьезная, как я уже сказал, шифровальная система, там, по-моему, IS какой-то даже стоит.
2522.36 2532.96 SPEAKER_01 Минусы этого IS составляют в том, что после того, как мы маленький int зашифровали, тот же самый единичку, двоечку, из него получается огромная-огромная стакища из месива буковок.
2532.96 2539.64 SPEAKER_01 В общем, минус данного подхода в том, что урлы у вас начинают выглядеть как полная каша, полное месиво.
2539.64 2542.84 SPEAKER_01 Но посмотрим, что с этим можно сделать чуть попозже.
2542.84 2548.48 SPEAKER_01 Давайте теперь вернемся к другой части, да, то есть мы данные-то зашифровали, а как нам их обратно получать?
2548.48 2555.32 SPEAKER_01 А, ладно, обратно там нам хочется тоже int-овые единички получить вместо всего вот этого месива, которое у нас в результате IS вышло.
2555.32 2558.56 SPEAKER_01 И в этом нам поможет ISP NetCoreModelBinder.
2558.56 2563.48 SPEAKER_01 У байндера есть точно такая же система, но только на оборот.
2563.48 2570.24 SPEAKER_01 Есть специальный интерфейс, который называется IModelModelBinder, от которого мы должны пронаследовать наш вышеупомянутый классик.
2570.24 2582.40 SPEAKER_01 И у него всего лишь там навсего перекрыть один метод, который как раз-таки вычленяет нужные данные из контекста, который приходит, из HTTP-контекста, и вызывает у нашего протектора метод unprotect.
2582.40 2586.52 SPEAKER_01 То есть с помощью того же DataProtection API мы эти данные расшифровываем.
2586.52 2601.92 SPEAKER_01 После того, как мы такой интерфейс экземпляризировали, нам нужно вот этот протектор рассказать, то есть рассказать ISP Net, когда применять этот протектор, каким свойствам.
2601.92 2614.88 SPEAKER_01 Самый примитивный способ это сделать, это прямо над свойством навесить атрибут, bind property, и в этом bind property указать того байндера, через который ISP NetCore будет пропускать все реквесты.
2614.88 2627.80 SPEAKER_01 Таким образом мы можем навесить bind property на наши айдишники все, и в эти айдишники после всех наших преобразований будет записываться тот чистый красивый int, который вы и ожидали увидеть.
2627.80 2631.56 SPEAKER_01 В общем так, довольно прозрачно можно сделать и шифрование, и дешифрование.
2631.56 2641.00 SPEAKER_01 И это все сделается, естественно, на уровне ISP Net, и ваш бизнес-логика от этого никак не страдает, она продолжает работать с интами и ничего не знает о всех этих ужасах.
2641.00 2642.00 SPEAKER_01 Криптографии и секьюрити.
2642.00 2647.08 SPEAKER_01 Так, теперь давайте посмотрим, а что же у нас получилось и какие минусы, в принципе, у этого подхода есть.
2647.08 2671.28 SPEAKER_01 Ну, прежде всего, шифрование и дешифрование в данном случае, это настоящее криптографическое шифрование IS, как я уже сказал, оно требует очень много ресурсов, ресурсов процессора прежде всего, поэтому если у вас вдруг какие-то запросы очень частые, и высоконагруженный сервис, и железа мало, то тут уже стоит думать, нужно оно вам или не нужно, потому что encrypt и decrypt идет на каждый реквест.
2671.28 2675.52 SPEAKER_01 Дальше у нас получаются слишком длинные строки.
2675.52 2676.52 SPEAKER_01 Ну как слишком?
2676.52 2683.16 SPEAKER_01 С точки зрения шифрования эти строки нормальны, но если мы будем читать их глазками, то это очень некрасиво выглядит.
2683.16 2690.80 SPEAKER_01 Если у вас с этим нет проблем, вы используете какой-нибудь Razor Pages, никто ваши урлы глазками не читает, то, в принципе, наверное, можно и забить.
2690.80 2699.44 SPEAKER_01 Если же вы все-таки хотите, чтобы ваши урлы были красивыми, более-менее помещались хотя бы в строку браузера, то можно пойти на небольшой компромисс.
2699.44 2704.56 SPEAKER_01 В принципе, в то, что мы делаем, здесь security нам не так сильно важна.
2704.56 2709.72 SPEAKER_01 Нам здесь не нужно полное шифрование, здесь хватило бы какой-то базовой офускации.
2709.72 2726.08 SPEAKER_01 Даже если мы получим, сделаем какую-то базовую офускацию, то есть просто-напросто каким-нибудь шифром Цезаря сдвинем все буквки слева на все байтики или битики слева направо и так далее, не зная алгоритм офускации, довольно сложно подобрать.
2726.08 2729.08 SPEAKER_01 Опять же, довольно сложно подобрать вот этот ключ.
2729.08 2751.32 SPEAKER_01 Поэтому если у вас там не какая-то банковская тайна или финансовая информация или какие-нибудь данные о здоровье, то есть где вам реально не нужна настоящая криптография, а вы просто храните котиков и просто хотите повыпендриваться, то там можете отказаться от криптографии и взять какую-нибудь любую библиотечку по офускации коротких адресов, по офускации интов, айдишников.
2751.32 2755.72 SPEAKER_01 Их в интернете миллион, ну и у нас в выпусках тоже были хорошие обзоры таких библиотечек.
2755.72 2766.40 SPEAKER_01 Можете взять их, но только в этот момент помните, что никакой криптографии там на самом деле нет, а есть просто security by obscurity, то есть пока ваш алгоритм неизвестен, то мало шансов, что его кто-то откроет.
2766.40 2775.80 SPEAKER_01 Также мы получаем небольшой шум из-за вот этих атрибутов, как я уже сказал, что нужно на айдишник навесить специальный атрибут bind property и так далее.
2775.80 2801.48 SPEAKER_01 Но на самом деле вот навешивать атрибуты над каждое свойство не нужно, есть более элегантные хуки, которые позволяют вам там проанализировать всю модель и независимо от, то есть в зависимости от каких-то там параметров, например, если поле называется id или заканчивается на id и его тип int, то применить вот этот bind property атрибут.
2801.48 2817.32 SPEAKER_01 В общем, такие условия тоже можно написать и гораздо лучше их написать и не вымазывать модельки во все эти bind атрибуты, потому что, опять же, последняя проблема это в том, что вы можете забыть навесить такой bind атрибут, то есть навесить такие constraint и получите утечку данных, что очень-очень плохо.
2817.32 2819.08 SPEAKER_01 Лучше таких вещей еще не допускать.
2819.08 2822.68 SPEAKER_01 Если возможно что-то забыть, значит нужно это делать на другом уровне.
2822.68 2826.78 SPEAKER_01 Вот на уровне как раз hook reflection это сделать намного приятнее.
2826.78 2829.08 SPEAKER_01 Там вот 100% ничего не забудете.
2829.08 2839.12 SPEAKER_01 Если property заканчивается на id и имеет тип int, допустим, ее можно автоматически считать, что это property, которое нужно шифровать или аффуцировать и отдавать наружу.
2839.12 2842.40 SPEAKER_01 В общем, и тогда никаких вот этих проблем не будет.
2842.40 2856.92 SPEAKER_01 В общем, вот такой интересный вброс, смотрите, то есть я думаю, что очень важно каждому разработчику понимать, почему int-ы отдавать наружу это плохо, это прежде всего, это главное, что хотелось бы вынести из статьи.
2856.92 2862.92 SPEAKER_01 А то, будете ли вы там шифровать, аффуцировать или дальше как-то этим загоняться, уже зависит от вашего бизнес-кейса.
2862.92 2870.72 SPEAKER_01 Иногда бывает, на большинстве случаев, ситуации, когда бизнесу все равно показывают котиков и никому не интересно сколько котиков мы загрузили в базу.
2870.72 2880.06 SPEAKER_01 В общем, но если это не так, то смотрите, как с антами можно защититься, как их можно аффуцировать и как можно избежать хотя бы базовых проблем.
2880.06 2906.84 SPEAKER_00 Ну да, и надо еще помнить, что если как ты говоришь, как-то автоматически это делать, если у нас поле типа int, то автоматически его шифровать или еще как-то заменять на string, то дальше возникает вопрос, если вы автогенерите при этом OpenAPI-спеку из вашей модели, то надо чтобы ваш OpenAPI-генератор дружил с этой логикой и понимал, что там на самом деле надо показать string, а не int.
2906.84 2913.16 SPEAKER_00 Потому что многие просто посмотрят на модель и скажут, что вот это там int, и у вас в модельке, ну в спеке будет int.
2913.16 2944.32 SPEAKER_01 Ну опять же, скорее всего, когда ты описываешь вот эти наружные DTOшки, по которым будет генериться OpenAPI-спецификация, то наверное там лучше всего сразу сказать одичнику, что это string, и таким образом вы себя тоже немножко обезопасите, как мы уже обсуждали, как одичники выставляют наружу тему недавнешнюю, что чем меньше внешняя система знает и предполагает о вашей системе, тем лучше, поэтому string – это универсальный идентификатор, самый безопасный тип, который вы можете отдать наружу, и чтобы потребляющая страна ничего об этом не подозревала.
2944.32 2948.92 SPEAKER_00 Все так, но ModelBinder и прочее как раз к этим самым DTOшкам-то и применяются.
2948.92 2952.60 SPEAKER_00 Поэтому если делать это на автомате, то там должен быть int.
2952.60 2957.80 SPEAKER_00 Если применять логику вида int и начинается или заканчивается на id.
2957.80 2960.48 SPEAKER_01 Да, я бы только на одичнике заложился, мне кажется.
2960.48 2962.48 SPEAKER_01 На keep закладываться не стоит.
2962.48 2969.68 SPEAKER_00 Я бы явно, на самом деле, писал бы string id, и я бы руками расставлял нужные атрибуты.
2969.68 2994.16 SPEAKER_00 То есть мы такое делали, мы, правда, использовали не шифрование, мы использовали когда-то библиотечку hashids.net, сейчас там ее автор переписал, и теперь она называется sqids.net, там я немножко изменил алгоритм, но в принципе это не шифрование никаким образом, это штука, которая генерирует такие, как она называется, ютуб-подобные айдишники.
2994.16 2996.52 SPEAKER_01 Ну да, это как раз вот эти обфускаторы, про которые
2996.52 2997.52 SPEAKER_00 я говорил.
2997.52 2998.52 SPEAKER_00 Да-да-да.
2998.52 2999.52 SPEAKER_00 Это просто, наверное, пожалуй, одна.
2999.52 3005.04 SPEAKER_00 Вот hashids на момент, ну, несколько лет назад была чуть ли не одной из самых популярных, мне кажется, которая в среднем гуглилась.
3005.04 3011.84 SPEAKER_00 Сейчас автор, она уже давно не обновляется, последний комитет, там четыре года три, по-моему, назад были в нее.
3011.84 3016.60 SPEAKER_00 Вот сейчас автор сосредоточился на новой, которая sqids, которая под новый .net уже работает нормально и так далее.
3016.60 3018.76 SPEAKER_01 Я тоже боюсь представить, а что-то можно обновлять.
3018.76 3031.92 SPEAKER_00 Ну я не знаю, вот он прямо одну забросил, потом написал, что типа вот, мол, ребрендит и придумал новый алгоритм, который называется sqids, и потом пошел писать отдельную библиотечку для нее.
3031.92 3033.76 SPEAKER_01 Надо же ради интереса посмотреть.
3033.76 3034.76 SPEAKER_01 Вот да.
3034.76 3035.76 SPEAKER_01 Реализация обычная.
3035.76 3063.76 SPEAKER_00 Не, я точно знаю, что в старой версии можно было задать seed, то есть ты задавал, мог задать свой кастомный алфавит, но если ты хочешь, например, там по дефолту типа, ну понятно, английские буквы, uppercase, lowercase и цифры, причем там хитро подобрано, чтобы там не было связи, ну в смысле в алфавите не встречалось одновременно там a из-за главной и какая-нибудь там единичка и l прописная, да, чтобы у тебя в идентификатор он был человекочитаемым и легко диктуемым, грубо говоря, в смысле.
3063.76 3066.64 SPEAKER_01 Ну это тоже такое требование есть, но не всегда нужно.
3066.64 3077.52 SPEAKER_00 Ну оно не всегда нужно, да, но вот типа по дефолту, ну там были такие настройки, там можно было еще указать seed, чтобы, понятно, он был чуть более уникален, а не так, что это ты написал такое же приложение, куда и перебором все подобрал.
3077.52 3078.52 SPEAKER_00 Вот.
3078.52 3084.92 SPEAKER_00 А у этого seed указать нельзя, но зато можно указать свой shuffled алфавит типа.
3084.92 3085.92 SPEAKER_00 Вот.
3085.92 3094.40 SPEAKER_00 Короче, видимо, какая-то, наверное, мелочь, я не знаю почему, ну в общем, решил почему-то переписать, может быть это был повод переписать на новый dotnet и забить на поддержку старого, например.
3094.40 3095.40 SPEAKER_00 Тоже вариант.
3095.40 3096.40 SPEAKER_00 Ну можно, возможно.
3096.40 3100.20 SPEAKER_00 Я не смотрел, с чем он там совместим с точки зрения фреймворков.
3100.20 3113.36 SPEAKER_00 Вот, поэтому не знаю, но в общем, да, мы, в принципе, пользовались, приятно, да, когда нужно не показывать чиселки, обычно этого достаточно, в большинстве случаев, вряд ли вам нужно прямо именно шифрование-шифрование.
3113.36 3115.32 SPEAKER_01 Ну если надо, почему нет.
3115.32 3118.00 SPEAKER_01 Да, да, да, обычно так есть.
3118.00 3150.48 SPEAKER_00 Ну давай пойдем дальше, дальше у нас блок статей, в смысле, что-то несколько статей, объединенных общей темой, но именно все это от компании, которая поддерживает и развивает фреймворк, тул, не знаю, библиотеку под названием PostSharp, это штука, которая долгое время, я же не знаю, сколько лет живет и, наверное, является чуть ли не одним из основных, источников неправильное слово, из основных библиотек, которые реализуют подход аспектно-ориентированного программирования в дотнете, вот так скажем.
3150.48 3153.04 SPEAKER_01 Из источников проблем ты хотел сказать, да?
3153.04 3158.88 SPEAKER_01 Потому что все, что я знаю про PostSharp, это то, что его надо срочно выпиливать, если вы в каком-то проекте
3158.88 3159.88 SPEAKER_00 его нашли.
3159.88 3164.92 SPEAKER_00 Ну типа того, давай немножко сначала кратенько скажем, что это вообще такое, в чем была идея.
3164.92 3183.48 SPEAKER_00 Идея PostSharp была в следующем, когда-то давно, когда все это начиналось, вы не могли во время компиляции ничего делать со сходным кодом, не было еще никаких сорс-генераторов для рослин, ничего, максимум что было, это всякие T4-шаблоны или самописные кусочки MSBuild скриптов, которые вам что-то там генерили.
3183.48 3185.52 SPEAKER_00 А иногда хочется изменять код.
3185.52 3195.16 SPEAKER_00 Например, не знаю, там классический пример, который всегда приводит почему-то для аспектно-ориентированного программирования, это что мы хотим залогировать вход и выход каждой функции.
3195.16 3200.08 SPEAKER_00 И ни разу не встретил, что бы такое хотелось, но вот это такой классический пример.
3200.08 3227.24 SPEAKER_00 Значит для этого можно встроить специальный плагин по сути в MSBuild pipeline, который после того, как у вас изгенерена сборка, уже DLL собрана MSBuild, возьмет эту сборку, декомпилирует ее, разберет IL-код, найдет везде, где есть ваши методы, и в нужные места пропатчит IL-код и соберет обратно сборку согласно тому, как вы ему описали.
3227.24 3231.16 SPEAKER_00 То есть там атрибутами поверх функции, либо еще как-то.
3231.16 3239.04 SPEAKER_00 То есть некоторый патчинг вашей DLL, вашего кода, уже после его сборки на уровне IL-кода.
3239.04 3247.44 SPEAKER_00 С одной стороны это позволяет сделать огромное количество вещей, потому что в IL-коде можно сделать практически все.
3247.44 3284.84 SPEAKER_00 С другой стороны эта штука довольно сложна, она очень хрупкая, потому что она по сути, если вы хоть как-то изучали, во что превращается ваш async метод, когда это стоит машина, и большой метод с кучей свитч кейсов, это все нужно аккуратно поддерживать на уровне IL-кода, это у вас все просто, в C#, а на IL-коде это может развернуться в довольно большие простыни, разные методы, еще что-нибудь, какие-то промежуточные объекты, это все надо как-то понимать, куда все это внести, как это распознать и понять, куда что встраивать.
3284.84 3296.98 SPEAKER_00 Поэтому эта штука действительно источник проблем, потому что на уровне IL-кода можно было это все сломать, причем можно было это сломать на уровне, чтобы получалась сборка, которая при попытке загрузки говорила, что у тебя вообще-то невалидная сборка.
3296.98 3299.48 SPEAKER_00 Что-то такое мне встречалось как-то пару раз.
3299.48 3305.00 SPEAKER_00 То есть IL-код был приведен в состояние, что он, ну короче, некорректный.
3305.00 3316.64 SPEAKER_00 Компания, ну PathShark при этом довольно популярный, ну видимо потому что плюс-минус единственный, вот, наверное какие-то вещи с ним действительно делать удобно или других способов может быть нет.
3316.64 3324.72 SPEAKER_00 Если вы, например, использовали какую-нибудь там кодогенерилку или какую-нибудь стороннюю библиотеку, с которой вы ничего не можете сделать, то PathShark можно было ее хоть как-то подходить.
3324.72 3354.56 SPEAKER_00 Но жизнь не стоит на месте, Roslin двигается, дотнет меняется, и компания поняла в какой-то момент, на самом деле это было несколько лет назад, судя по статейочке, одно из, что становится все это поддерживать сложнее и сложнее, а Roslin развивается, появились сурс-генераторы, появилась возможность генерить код нормально в каком-то разумном виде в момент компиляции, причем генерить сразу C#, чтобы дальше компилятор уже сам все компилировал.
3354.56 3361.56 SPEAKER_00 Но есть одна проблема, все еще нельзя менять код.
3361.56 3367.08 SPEAKER_00 То есть вы пока Roslin с сурс-генераторами не можете изменять существующий код.
3367.08 3374.36 SPEAKER_00 То есть если у вас есть, например, задача добавить то самое логирование для всех вызываемых методов, то Roslin вы это сейчас делать не сможете.
3374.36 3378.18 SPEAKER_00 По C# можно, но по C# это все делать хрупко и ненадежно.
3378.18 3401.48 SPEAKER_00 Поэтому компания подумала, поняла, что по C# что-то как-то сложно становится поддерживать, и все свои силы кинула на новый продукт, который теперь называется Metalama, он вышел чуть больше полгода назад, но тут сейчас прошел ряд статей по поводу опенсурсности некоторых кусочков, поэтому он снова появился у нас в наших источниках новостей и мы про него рассказываем.
3401.48 3404.48 SPEAKER_00 Что же такое Metalama?
3404.48 3417.20 SPEAKER_00 Это, как они называют, очень простой и очень мощный инструмент для генерации кода и для валидации кода для C#, для метапрограммирования.
3417.20 3432.80 SPEAKER_00 У него фокус на простоту и безопасность, то есть это в отличие от PostSharp они стараются сделать так, чтобы ничего не ломалось в ваших приложениях, и они сказали, что они reimagined, то есть они перепридумали аспектно-ориентированное программирование для современного дотонета.
3432.80 3435.40 SPEAKER_00 Значит, что же такое и как это теперь выглядит?
3435.40 3462.64 SPEAKER_00 Значит, аспекты, у них есть два понятия, аспект и, ну они это называют fabrics, это не фабрики, в смысле фабрики были бы factories, это скорее fabrics, в смысле нити, ткани, ну то есть что-то такое вот связующее, видимо, эта мысль была при назывании, это все C#-классы, которые исполняются внутри компилятора или внутри IDE, пока вы редактируете код.
3462.64 3482.68 SPEAKER_00 То есть позволяют делать следующее, позволяют генерить код в compile-time, либо менять код в compile-time, позволяют, если все это работает во время IDE, верифицировать ваши исходники по всяким паттернам и правилам, ну и дальше даже позволяются какие-то фиксы и рефакторинги.
3482.68 3484.48 SPEAKER_00 Как этим всем пользоваться?
3484.48 3490.08 SPEAKER_00 Давайте сначала с простого поймем, потом попаковаемся внутри, как же это устроено и работает.
3490.08 3506.48 SPEAKER_00 Значит, есть NuGet пакет, называется metalama.framework, который вы добавляете в ваш продукт, можно добавить некоторые экстенджеры для Visual Studio и поставить, тогда там будут некоторые полезные тулзы доступны, и дальше вы создаете аспект.
3506.48 3539.16 SPEAKER_00 Ну, например, возвращаясь к нашему простому примеру с логированием, вы создаете аспект, это, по сути, класс, который будет применяться, как правило, атрибутом, в данном случае тогда вы его назовете LogAttribute по конвенции C#, который наследуется от класса OverrideMethodAspect, после чего в нем нужно заверрадить единственный метод, который называется OverrideMethod, который возвращает, вот тут я прям удивился, он возвращает nullableDynamic, прикинь, вот.
3539.16 3540.16 SPEAKER_00 Да.
3540.16 3548.76 SPEAKER_00 То есть динамик с вопросиком, прям такой, туда подойдет все что угодно, вообще, не знаю, зачем динамик с вопросиком.
3548.76 3551.60 SPEAKER_00 Типа теперь точно вообще все что угодно.
3551.60 3563.64 SPEAKER_00 Вот, и внутри у вас есть, соответственно, некоторый базовый protected property под названием meta, у которого есть пачка properties и методов, с помощью которых вы можете общаться с тем методом, который вы заверраете.
3563.64 3575.64 SPEAKER_00 То есть метод.target.method даст вам название этого метода, метод.proceed, собственно, вызовет этот метод, и если он возвращает какой-то результат, вы присваиваете его в переменную result и его возвращаете.
3575.64 3578.64 SPEAKER_00 Благодаря динамику вы можете вернуть вообще все что угодно.
3578.64 3585.68 SPEAKER_00 Я не знаю, ничего не сказано, как это будет работать с ассинк методами, вот этим всем, но как бы надо изучать.
3585.68 3587.88 SPEAKER_00 Настолько детально я туда не копался.
3587.88 3594.92 SPEAKER_00 Дальше вы этот атрибют, который, LogAttribute вы объявили, вы его применяете к нужным методам, либо вы можете сделать по-другому.
3594.92 3603.24 SPEAKER_00 Вы можете объявить новый класс, который тот самый Fabric, и внутри с помощью linkStyle сделать такую штуку.
3603.24 3640.68 SPEAKER_00 То есть вы, например, можете написать, там появляется пропертиа под названием amender, от английского amend, ну типа изменять, да, и дальше вы там делаете select, в скобочках пишите условия там на все типы, where, там где эти типы объявлены как public, из них делаете select many, там методы where, там допустим, хочу все public и при этом чтобы они были не toString, да, ну типа toString не будем блокировать, и потом добавляем, типа addAspect, и указываете ваш атрибутчик, который вы создали, и оно автоматически в compile-time все добавится, вот.
3640.68 3656.68 SPEAKER_00 Когда происходит compile-time, эта лама меняет C# код перед тем, как отдавать его собственно к компилятору на компиляцию, она меняет C# код и физически вставляет туда кусочки C#, ну вот того, что вы написали с точки зрения Console.WriteLine и так далее.
3656.68 3691.12 SPEAKER_00 То есть на самом деле, вот эти вот override метод, который динамик с вопросиком, я так понимаю, выполняться не будет именно как выполнение, то есть это по сути просто шаблон аспекта, и нужен там этот динамик просто чтобы компилятор был доволен, ну потому что это тоже же код, который он как бы пытается скомпилить, возможно, вот, а фактически получается, что ваш код меняется так, что вот эти вот кусочки, которые вы добавили там до, например, вызова .prosheet и после, они будут аккуратно вставлены в те места, которые размечены правильными атрибутами.
3691.12 3699.96 SPEAKER_00 Вот, такая вот магия, выглядит действительно немножко магически, но прикольно.
3699.96 3721.08 SPEAKER_00 Дальше вы можете сказать, что на самом деле, на самом деле, это металлама, я так все, постшарп, постшарп, постшарп не единственная штука, которая позволяет, ну делать что-то подобное, то есть во-первых, есть постшарп действительно, во-вторых, есть сам рослинг, который что-то там позволяет, и в-третьих, есть еще такая штука, тоже, может быть, слышал или даже, наверное, какой-то, или выпиливал из проектов, это Фоди.
3721.08 3725.88 SPEAKER_01 Ну да, да, Фоди, мне кажется, самый популярный, потому что он бесплатен, в отличие от этого монстра.
3725.88 3764.80 SPEAKER_00 Ну да, вот, наверное, кстати, да, ты прав, мне вот Фоди, ну Фоди, кстати, я нигде не встречал в живых проектах, даже постшарп встречал почему-то, ну да ладно, значит, и там в этой статичке есть сравнение, что можно сделать с помощью постшарпа, розлина и Фоди, значит, и несколькими киллер-фичами, собственно, этой самой металламы, это как раз-таки отладка и экспорт трансформированного кода, то есть можно скомпилировать его со специальным ключиком, когда вы увидите весь код именно C#, да, он выплюнет его в какой-нибудь OPJ output, так, чтобы вы видели, как ваш код выглядит после того, как к нему применены все ваши аспекты.
3764.80 3769.32 SPEAKER_00 Ну и там всякие разные варианты, что ещё можно с ним делать.
3769.32 3775.08 SPEAKER_00 Значит, как ты правильно сказал, Фоди бесплатный постшарп.
3775.08 3778.56 SPEAKER_00 Я не помню, что там было с лицензиями, но по-моему, там какая-то версия была платная, там была какая-то
3778.56 3783.32 SPEAKER_01 бесплатная версия, но… Не знаю, я помню, что всегда постшарп был довольно дорогой штукой.
3783.32 3785.48 SPEAKER_00 Ну может быть, может быть, не помню.
3785.48 3791.72 SPEAKER_00 С Pentalama тоже история такая, что она частично платная, частично бесплатная.
3791.72 3798.40 SPEAKER_00 Ну точнее как, у неё есть несколько эдишенов, один из них это бесплатный эдишен, полный себе, берите, пользуйтесь.
3798.40 3802.92 SPEAKER_00 У него есть ограничения, то есть вот этих вот аспектов можно сделать три штуки максимум на проект.
3802.92 3820.92 SPEAKER_00 Ну и там другие есть, самые… Не будет никакого отладки, то есть вы не сможете делать степ-ин в Generated Code, то есть вы не сможете при отладке заходить в ваши аспекты внутрь, и у вас не будет там тестинг-фреймворка для ваших аспектов.
3820.92 3823.56 SPEAKER_00 Так, у них есть аж специальный тестинг-фреймворк для аспектов.
3823.56 3830.48 SPEAKER_00 Вот, и еще есть некоторое количество ограничений, но мне кажется, самое важное – это все самые три аспекта на проект.
3830.48 3833.28 SPEAKER_00 Если уж вы хотите в аспекты ориентирования и программирования, ну наверное, трех будет мало.
3833.28 3841.00 SPEAKER_00 Ну и даже там какие-то цены, понятно, я особо сейчас не буду распространяться, потому что всё это может меняться и так далее.
3841.00 3847.16 SPEAKER_00 Давай к интересной части, как это всё построено, как это всё устроено и на основе чего это всё сделано.
3847.16 3856.76 SPEAKER_00 Сам по себе metalama-компилятор, он open-source, его можно посмотреть, его можно взять, его можно использовать, и это просто форк рослина.
3856.76 3857.76 SPEAKER_00 Форк?
3857.76 3858.76 SPEAKER_01 Да.
3858.76 3859.76 SPEAKER_01 Прямо форк?
3859.76 3860.76 SPEAKER_01 Прямо форк.
3860.76 3861.76 SPEAKER_01 И как его поддерживают-то?
3861.76 3876.60 SPEAKER_00 То есть это прямо форк, если зайти в github-репозиторий metalama-компайлер, там прямо написано forked from.net/roslin, то есть это прямо не просто копия, знаешь, как иногда делают, типа ну клонируют и коммитируют к новой репозитории, это честный прямо форк в уровне гитхаба.
3876.60 3878.64 SPEAKER_01 Ну то есть они забираются как-то поддерживать.
3878.64 3902.12 SPEAKER_00 Да-да-да, они сделали следующую штуку, значит вот этот framework, который metalama-framework, она является по сути плагином для компиляторов в compile-time, или плагином для самого основного рослина, если у нас в design-time, в design-time ты же не можешь подменить рослин, который внутри студии живет, но можно к нему заплагиниться.
3902.12 3917.16 SPEAKER_00 Внутри рослина у нас есть аналайзеры и генераторы, то есть на основе аналайзеров можно делать любые аналайзеры, на основе генераторов можно генерировать новый код, тут все хорошо, и не хватало только трансформеров, вот они добавили концепцию трансформеров.
3917.16 3941.28 SPEAKER_00 Можно посмотреть, как это сделано, вероятно они собираются это дело поддерживать в том смысле, что когда будет меняться рослин под новые версии компилятора, они будут себе обновлять из AppStream, грубо говоря, основной рослин и допиливать свою поддержку вот этих source-трансформеров под какие-то новые фичи языка, например, и так далее.
3941.28 3944.56 SPEAKER_00 То есть но базовый рослин, базовый компилятор остается базовым.
3944.56 3947.08 SPEAKER_00 Прямо вот нативный, который берется из дотнета.
3947.08 3953.40 SPEAKER_01 Ну смотри, кажется, если вот думать, а как, можно было бы по-другому сделать, но это, скорее всего, один из самых лучших вариантов.
3953.40 3998.60 SPEAKER_00 Ну, кажется, что да, то есть они сказали, что они сначала пытались сделать это, там у них есть такие небольшие размышления какие-то, ну, историю, что они сначала делали это в private форке, не зная, насколько они смогут сделать прям вот такой форк, который можно будет именно обновлять из AppStream, но, видимо, все получилось, поэтому оно в open-source, его можно, если вам нужен рослин с source-трансформерами, можно взять Metalama Compiler, у него, по-моему, нормальная лицензия, если я правильно помню, а вот Metalama Framework, собственно, статья, из-за которой мы это все добавили сюда, снова всплыло оно в новостях, его тоже за open-sourcely, то есть вот этот Metalama Framework, который, как я сказал, он там платный, вот это все, он open-sourced.
3998.60 4004.92 SPEAKER_01 А как же там ограничение в три штучки, если любой дурак может пойти себе собственный фреймворк собрать?
4004.92 4010.04 SPEAKER_00 Вот, собрать ты его не можешь, по двум причинам.
4010.04 4011.60 SPEAKER_00 Причина первая, лицензия не позволяет.
4011.60 4014.20 SPEAKER_01 Погоди, у нас параллельный импорт, как лицензия.
4014.20 4015.20 SPEAKER_01 Давай по существу.
4015.20 4017.64 SPEAKER_00 Второе, там нет ничего для сборки.
4017.64 4018.64 SPEAKER_00 Исходники C#?
4018.64 4026.84 SPEAKER_00 Ну, как они сказали, мы выложили 99%, одного процента не хватает и без него вы не соберете это в нормальный работающий
4026.84 4027.84 SPEAKER_01 вид.
4027.84 4030.12 SPEAKER_01 Ну интересно, конечно, посмотреть, а что именно там не хватает.
4030.12 4035.50 SPEAKER_01 Мне кажется, что айтузоазисты, по сравнению с ценой на настоящую металламу, этот 1% должны дописать за один
4035.50 4036.50 SPEAKER_00 вечер.
4036.50 4037.50 SPEAKER_00 Ну, возможно, возможно.
4037.50 4040.80 SPEAKER_00 Я с интересом посмотрю, во что это превратится.
4040.80 4046.32 SPEAKER_00 Пока никаких следов я поискал, ничего не видно, никаких энтузиастов не появилось.
4046.32 4067.92 SPEAKER_00 И сделали они это для двух целей, соответственно, это упрощение отладки, потому что если у вас вдруг, видимо, они научены опытом постшарпа, который там портил лейкод и вот это все, короче, упрощает отладку, то есть вам нужно посмотреть, как оно там, черт возьми, трансформирует что-то куда-то, ну вот, пожалуйста, вот исходники.
4067.92 4080.08 SPEAKER_00 Ну и какая-то общая фраза про increase trust and transparency, вот это все, но 1% мы вам не дадим, но можно купить металлама source code subscription, и тогда вам дадут остатки исходников.
4080.08 4083.56 SPEAKER_01 Ну вот кто-то один, может, купит и выложит всего старым.
4083.56 4099.16 SPEAKER_00 Ну, короче, понятно, что способы есть наверняка, да, можно и по шармам было, наверное, бесплатно пользоваться, но как бы такой вот забавный, забавная, так скажем, забавный подход к open-source, посмотрим, человек.
4099.16 4118.76 SPEAKER_01 Нужно признать, что постшарп это один из просто старейших инструментов в дотнете, которые есть, если вспоминать какие-нибудь старые фреймворки, которые выжили, ну и выкинуть оттуда все юайные компоненты, то старее постшарпа, я не знаю, фреймворка коммерческого именно, который выжил, и парадокс в том, что я реально встречал его в многих компаниях.
4118.76 4129.36 SPEAKER_01 Ну, то есть, у него, наверное, была какая-то хорошая пиар-акция когда-то на заре времен, что его затащили и купили, главное, что смешно как бы, в очень большом количестве компаний.
4129.36 4134.08 SPEAKER_01 В общем, но я не встречал ни одной компании, которая об этом не пожалела и не хотела бы его выпилить.
4134.08 4145.32 SPEAKER_00 Ну, вот посмотрим металлам, может быть, кстати, они тоже этот тренд увидели, что там, не знаю, выпиливают, и юзедж сокращается, и продавать стало сложнее, и решили переписать это все на более безопасный вариант.
4145.32 4146.32 SPEAKER_01 Ну, да.
4146.32 4152.08 SPEAKER_00 И в принципе, если даже постшарп продавался с опасным вариантом, то этот тоже, наверное, будет продаваться.
4152.08 4158.12 SPEAKER_01 Ну, наверняка, опять же, потому что аспектно-ориентированное программирование дает нам очень много интересных возможностей.
4158.12 4160.76 SPEAKER_01 Особенно если мы говорим про сложные интерпрайзы, ну а где у нас еще деньги?
4160.76 4161.96 SPEAKER_01 Ну, естественно, в сложных интерпрайзах.
4161.96 4195.84 SPEAKER_01 В общем-то, там действительно есть случаи, когда таких инструментов не хватает, и если те инструменты не будут как бы пилить иль код, который ломается с новой версии компилятора, а все делается на честных генераторах, а честные генераторы, нужно понимать, их плюс, что теперь команда постшарпа металлама не отвечает за то, чтобы их поддерживать, теперь команда Рослина отвечает, что все, что было сгенерировано, компилировалось с любой версией компилятора, то у них там просто 80% всей работы с них спадает, и поэтому они могут больше сосредоточиться на каких-нибудь интересных фичах или тех же самых маркетинговых статьях.
4195.84 4207.20 SPEAKER_00 Не, ну те самые трансформеры все-таки Рослин никак не поддерживает, поэтому с ними-то как раз все еще мучиться надо, разбирать все новинки языка, чтобы понимать, как их трансформировать.
4207.20 4215.40 SPEAKER_01 Скорее всего тебе там нужно было просто сунуться в нужную точку и всё, а все новинки языка – это тебе просто-напросто существующая Рослин-дерево приходит и разбирает как хочешь.
4215.40 4226.68 SPEAKER_00 Не, ну Рослин-дерево – это большой бонус, понятно, и понятно, почему они взяли Рослин, это просто очевидно, что еще в тот ней-то брать, учитывая, что он тебе доступен, плюс-минус.
4226.68 4232.84 SPEAKER_00 Но все равно какая-то логика понятная, с самой металламой там есть, то есть как-то все эти нужно.
4232.84 4237.60 SPEAKER_01 Ну наверняка, мне просто кажется, что здесь в миллиард раз меньше усилий, чем поддерживать постшарп.
4237.60 4238.60 SPEAKER_01 Конечно, конечно.
4238.60 4240.40 SPEAKER_01 Постшарп вот с именем их, это вообще ужас.
4240.40 4241.40 SPEAKER_01 Да.
4241.40 4246.72 SPEAKER_01 И то работал, и то люди платили, и то были в принципе счастливы, поэтому да, наверное, свои вендоры найдутся.
4246.72 4256.60 SPEAKER_01 Ну если вы вдруг использовали или до сих пор самое интересное, почему-то используете постшарп, и при этом не хотите его выпиливать, прийдите в комменты, расскажите, что у вас за юзкейсы такие-то интересные.
4256.60 4260.36 SPEAKER_00 Ну или может быть проапгрейдитесь на металламу и посмотрите, что там как.
4260.36 4261.36 SPEAKER_01 Или так, да-да.
4261.36 4282.24 SPEAKER_01 Ну и чтобы далеко не отпускать металламу, надо признаться, что у металламы главный ментейнер и главный фаундер и лид-девелопер – это товарищ Гаэль, фамилию Фрайтер.
4282.24 4286.32 SPEAKER_01 Ты помнишь, как у него фамилия произносится?
4286.32 4296.52 SPEAKER_00 Я её обычно произношу Фрэтер, но он то ли француз, то ли бельгиец, я не помню, кто он.
4296.52 4305.16 SPEAKER_00 И у них как-то фамилия не всегда правильно, в смысле легко произносится, букв много, а иногда, как скажешь, так там это.
4305.16 4308.64 SPEAKER_01 Короче, в узком круге, да, он знаменит как Гаэль.
4308.64 4315.04 SPEAKER_01 В общем, Гаэль является фаундер и лид постшарпа, и естественно металламы той же самой.
4315.04 4324.84 SPEAKER_01 И вот Гаэль тут недавно пришёл и рассказал в статьечке, а каким образом они обеспечивают качество своих продуктов, даже качество кода.
4324.84 4331.16 SPEAKER_01 Так как они много выкладывают в open-source, все себе красивые, все такие, в общем в open-source код должен быть красивым.
4331.16 4333.88 SPEAKER_01 Работать не работай, там за лицензией или что-то это дело десятое.
4333.88 4335.16 SPEAKER_01 Главное, чтобы было красиво.
4335.16 4346.64 SPEAKER_01 И вот он пришёл и рассказал, а как же они собственно обеспечивают красоту своего кода, чтобы он был весь отлаженный, проанализированный, отформатированный, что у них там, собственно, в команде происходит.
4346.64 4347.64 SPEAKER_01 Давайте же нырнём.
4347.64 4350.52 SPEAKER_01 Раз продукт мы посмотрели, давайте посмотрим теперь, как они работают.
4350.52 4359.92 SPEAKER_01 И обсудим его статичку, которая называется Codestyle for Better Productivity, т.е. что же они там такого для улучшенной производительности делают со своим стилем кода.
4359.92 4389.84 SPEAKER_01 Ну, прежде всего, когда вы начинаете новый проект, то первые шаги, на которые вы должны сделать, это сделать так, чтобы в вашей команде удобно было работать вместе, и чтобы, например, тот код, который вы пишете, он был согласованным и все в команде его хорошо понимали, все хорошо представляли, в каком виде этот код надо писать, все хорошо понимали тот Codestyle, которому он должен соответствовать.
4389.84 4395.36 SPEAKER_01 Ну и даже если они плохо это понимают, что какие-то инструменты, били их по рукам и рассказывали, как надо понимать хорошо.
4395.36 4405.52 SPEAKER_01 Это означает, что вы должны на берегу ещё договориться, желательно до первой строчки кода, пока вы напишете, договориться о кодформатинге и нейминге.
4405.52 4415.40 SPEAKER_01 Ну, кодформатинг — это пресловутые вещи, там, табы против спейсов, сколько там пустых линий, пустых строчек оставлять, где расставлять скобочки, вот это вот все.
4415.40 4422.80 SPEAKER_01 И нейминги, то есть какие суффиксы давать, какие префиксы давать, что как называть, это все относится к неймингу.
4422.80 4436.56 SPEAKER_01 А также есть банальные какие-то вещи, там, использовать var, использовать this, ну, то есть самые священные страшные коровы, из-за которых только бывают войны, вот это все относится как раз к форматингу, неймингу и то, что мы сегодня будем с вами обсуждать.
4436.56 4462.14 SPEAKER_01 Поэтому желательно эти войны сделать до того, как вы пойдете писать код, потому что если эти войны будут начинаться постепенно, когда кто-то уже что-то написал, потом кто-то несогласен, взял переформатировал, сделал pull request, тот не одобрил, в общем, эти вот распри, они могут длиться еще дольше, чем то время, которое вы потеряете перед тем, как сесть вот на берегу и это все написать.
4462.14 4469.16 SPEAKER_01 И вот команда Metalama как раз хочет поделиться с нами своим опытом, как это происходило у них и что они делали.
4469.16 4471.80 SPEAKER_01 Прежде всего, зачем все это нужно?
4471.80 4473.44 SPEAKER_01 Ну, это консистентность.
4473.44 4485.04 SPEAKER_01 Консистентность прежде всего для чтения, когда вы читаете код и знаете, что он отформатирован одинаково во всех файлах, которые бы вы не открыли, вам его удобней читать, удобней по нему навигироваться, удобней по нему понимать.
4485.04 4503.08 SPEAKER_01 И так как по выдуманной статистике разработчик проводит 80% именно читая код, а не написывая его, то мы как раз увеличиваем вот эту вот самую главную точку, на которую он тратит свое время, мы как раз увеличиваем читабельность кода.
4503.08 4513.72 SPEAKER_01 Также единообразность кода дает вам возможность проще разбираться в коде и дает вам меньше конфликтов на мерш-реквестах.
4513.72 4527.36 SPEAKER_01 Или на pull-request, когда вы заливаете свой код, то если он отформатирован и украшен правильно, то в этот момент у вас будет меньше проблем с конфликтами, которые могли внести другие разработчики.
4527.36 4541.72 SPEAKER_01 Особенно если другие разработчики взяли и нажали там кнопочку какой-нибудь отформатировать, и все, весь файл, который вы там так радостно редактировали, вот эта функция форматирования она вам выдала сразу 100-500 конфликтов.
4541.72 4545.88 SPEAKER_01 В общем, весь файл поехал, и все, и формат превратился в какую-то для вас кашу.
4545.88 4551.08 SPEAKER_01 В общем, если вы вдруг используете единый код-стайл, то такой ситуации у вас уже технически даже быть не может.
4551.08 4561.60 SPEAKER_01 Так, теперь давайте посмотрим все-таки, откуда нам брать стили и как нам дойти к этому общему соглашению.
4561.60 4578.56 SPEAKER_01 Мы все знаем прекрасно, что у каждого, каждый человек это гребаная снежинка, и у этой снежинки есть какое-то свое мнение о том, каким образом должны расставляться табы и где быть скобочки, и если мы начнем об этом спорить, то такие священные войны, они могут продолжаться до бесконечности.
4578.56 4584.28 SPEAKER_01 Но, опять же, как советует автор, лучше все-таки договориться до начала написания кода.
4584.28 4586.52 SPEAKER_01 Как нам к этим можно договориться?
4586.52 4604.16 SPEAKER_01 Ну, прежде всего, с основу автор рекомендует взять стандарт Микрософта, у Микрософта есть такая прекрасная страничка, которая называется Common Coding Conventions for C#, то есть как ни трудно догадаться, там есть какие-то базовые основы, что в C# нормальном коде в современном должно быть.
4604.16 4612.24 SPEAKER_01 И там куча, кстати, интересных рекомендаций, если вы вдруг давно не обновляли или не знали, то можно просто пройти посмотреть, статичка не очень большая.
4612.24 4627.84 SPEAKER_01 Ну, кстати, оттуда же можно подчеркнуть такий интересный факт, что конфигура wait нужно использовать всегда, что нужно использовать space вместо табов, что ширина строчки должна быть 65 символов, не больше, и так далее.
4627.84 4635.64 SPEAKER_01 Такие базовые вещи, за которых многие спорят, их можно честно ссылаться на Микрософт и эти халевары такие заканчивать.
4635.64 4640.64 SPEAKER_01 Документ хороший, но, к сожалению, он не покрывает абсолютно всего.
4640.64 4645.48 SPEAKER_01 И мне кажется, это большая недоработка Микрософта до сих пор.
4645.48 4654.48 SPEAKER_01 Если бы она выпустила какой-нибудь документ, который, не знаю, как у Python, допустим, который строго говорит, как надо форматировать, и всё, ни шагу влево, ни шагу вправо.
4654.48 4656.68 SPEAKER_01 Мне кажется, было бы намного меньше у нас проблем.
4656.68 4667.12 SPEAKER_01 В общем, но опять же, оставим какое-то место, чтобы люди могли поспорить, поэтому Микрософт какие-то основные вещи обозначила, но обозначила не всё.
4667.12 4670.96 SPEAKER_01 И вот это не всё, вот этим уже нужно договариваться.
4670.96 4684.20 SPEAKER_01 Вот конкретно для каждого проекта вырабатывать какие-то договорённости, спрашивать опыт разработчиков на тех или иных проектах, в общем, каким-то образом пытаться это свести к какому-то общему договорённости.
4684.20 4692.68 SPEAKER_01 И как только мы все договорились, пусть даже кто-то из разработчиков не согласен в итоге с этой договорённостью, каждый разработчик обязан эти договорённости соблюдать.
4692.68 4694.60 SPEAKER_01 Без всяких обсуждений и так далее.
4694.60 4700.52 SPEAKER_01 Если эта договорённость зафиксирована в команде, то всё, дальше обратного хода уже никакого нет.
4700.52 4711.52 SPEAKER_01 Также ещё нужно помнить, что в принципе вырабатывание стандартов – это интеративный процесс, если вы до всего сразу не смогли договориться или все сразу скобочки не вспомнили, то естественно вы не обязаны это делать.
4711.52 4722.64 SPEAKER_01 Как только вы начнёте разрабатывать, и у вас станет такой вопрос, в будущем, а почему эта скобочка забыта здесь, и мы её не перенесли, вот в этот момент можно опять же этот вопрос поднять и снова вернуться к нашим скобочкам.
4722.64 4727.52 SPEAKER_01 Поэтому процесс итеративный, главное договориться о каких-то базовых вещах, и всё остальное потом можно дорабатывать.
4727.52 4730.96 SPEAKER_01 Так, теперь, предположим, вы договорились, что же дальше мы будем делать?
4730.96 4736.16 SPEAKER_01 То есть каким же образом нам теперь нужно сконфигурить наши инструменты для того, чтобы они нам помогали работать?
4736.16 4749.76 SPEAKER_01 Ну, прежде всего любая уважающая себя IDE должна поддерживать файлы Editor-Config, Visual Studio, Visual Studio Code, ReSharper, ReRider, и тому, и, в общем, мне кажется, всё, что возможно поддерживать сейчас Editor-Config и хотя бы в каком-то там минимальном его наборе.
4749.76 4755.68 SPEAKER_01 Поэтому рекомендуется добавить файл Editor-Config и обязательно залить его в репозиторий.
4755.68 4761.40 SPEAKER_01 То есть это не должен быть файл, который у каждого разработчика свой, куда-то он его там положил, где-то там заинклудил, нет.
4761.40 4771.32 SPEAKER_01 Это штука, которая лежит в репозитории, и он один у всех разработчиков, и более того, он один даже на Continuous Integration систему, она его в том числе обязана учитывать.
4771.32 4781.56 SPEAKER_01 В идеале вот этот файл, он не должен оставлять какого-то места для самовольности, да, то есть чтобы вот таких нелепых снежинок у нас не появлялось.
4781.56 4789.44 SPEAKER_01 Если у нас есть какое-то правило, как должен использоваться код, то он обязан прописываться в этом файле.
4789.44 4799.68 SPEAKER_01 В частности, рекомендуется выставить warning, где только возможно, на всех возможных там форматированиях, скобочках и так далее.
4799.68 4806.84 SPEAKER_01 В Editor-Config это можно прописать как warning, да, то, что если скобочка находится не на своем месте, он вам выдает warning.
4806.84 4815.76 SPEAKER_01 И при этом рекомендуется поддерживать zero warning код, да, то есть у вас там не должно быть warning в вашем коде, естественно, за этим надо следить.
4815.76 4821.84 SPEAKER_01 Вот, еще существует такой инструмент, как ReSharper Code Formatting.
4821.84 4830.80 SPEAKER_01 Наверняка каждый из вас сталкивался с непонятными файликами, которые появляются в вашем репозитории и имеют окончание .sln.dotsettings.
4830.80 4837.12 SPEAKER_01 Вот dotsettings, это и есть те файлики, которые создает ReSharper для того, чтобы доставить какие-то там свои настройки.
4837.12 4841.68 SPEAKER_01 И это гораздо более гибкий и мощный механизм, чем Editor-Config.
4841.68 4852.44 SPEAKER_01 Но в Editor-Config есть преимущество в том, что он cross-EDE-шный, а dotsettings - это штуки чисто JetBrains, поэтому никто, кроме JetBrains их не понимает, но зато они более мощные.
4852.44 4869.92 SPEAKER_01 У JetBrains'ких tools есть такая прекрасная штука, как слоеные настройки, когда вы можете этих dotsettings наделать сколько угодно, разложить их по папочкам, заинклюдить там друг друга и, соответственно, сделать какой-то dotsettings, который шарится между всей командой.
4869.92 4877.36 SPEAKER_01 И сохранить его в отдельный файлик, и вот этот dotsettings, который шарится между всей командой, естественно, тоже должен быть в репозитории.
4877.36 4878.36 SPEAKER_01 Там ему самое место.
4878.36 4880.36 SPEAKER_01 Так, переходим дальше.
4880.36 4889.52 SPEAKER_01 Теперь мы договорились о каких-то настройках, законфигурировали, чтобы они у нас где-то хранились, как мы, собственно, будем применять форматирование.
4889.52 4899.52 SPEAKER_01 Есть такой процесс, который называется CodeCleanup, и подразумевает, что код каким-то образом чистится в соответствии с теми настройками, которые находит этот инструмент.
4899.52 4903.24 SPEAKER_01 Что здесь стоит сказать?
4903.24 4917.28 SPEAKER_01 Так как CodeCleanup обычно выполняется автоматически, то есть не хочется, чтобы человек смотрел и сравнивал, а что там, собственно, нужно закленапить, как там что-то нужно выровнять, обычно так не делается.
4917.28 4922.68 SPEAKER_01 Обычно просто запускается автоматический Cleanup, он проходится по всем файлам, и все файлы выравниваются, чтобы были все равны.
4922.68 4929.44 SPEAKER_01 Поэтому, тут встает хороший вопрос, а что включать в CodeCleanup, а что включать не стоит?
4929.44 4933.12 SPEAKER_01 То есть какие форматоры, какие фиксеры нужно включать?
4933.12 4935.52 SPEAKER_01 В общем, критерий довольно простой.
4935.52 4939.20 SPEAKER_01 Стоит включать те фиксеры, которые 100% не дадут вам ошибок.
4939.20 4945.68 SPEAKER_01 Ну, например, есть фиксер, который говорит, на каких строчках должны расставляться скобочки фигурные.
4945.68 4955.24 SPEAKER_01 Договорились вы в компании, что фигурные скобочки расставляются там каждая на своей отдельной строке, и они обязательны для любого стейтмена, ну и все, и это можно применить автоматически, никаких проблем с этим не будет.
4955.24 4960.12 SPEAKER_01 А есть код-фиксер, который, например, проставляет ReadOnly в вашем приватном поле.
4960.12 4965.80 SPEAKER_01 И этот код-фиксер может быть очень опасным, особенно если вы случайно проставите ReadOnly к какой-нибудь структурке.
4965.80 4975.64 SPEAKER_01 И это может привести к очень большим багам, и притом багам неочевидным, которые можно поймать только по утечке ресурсов, профайлером и так далее.
4975.64 4983.96 SPEAKER_01 В общем, такие фиксеры в Cleanup включать нельзя, потому что вы можете поймать очень много проблем с ними.
4983.96 4991.06 SPEAKER_01 Вот на вот эти два набора вам и стоит разделить код-Cleanup, который можно применять автоматически, и который автоматически примерять не стоит.
4991.06 4997.96 SPEAKER_01 Также, когда вы запускаете код-Cleanup, у вас должна быть 100% гарантия, что там будет все хорошо.
4997.96 5000.36 SPEAKER_01 Вот почему мы должны выбирать именно правильные фиксеры.
5000.36 5010.72 SPEAKER_01 Поэтому любой член команды должен запускать код-Cleanup без всяких там ручных галочек, без каких-нибудь там хаков, и при этом он не должен бояться, что что-то сломается.
5010.72 5015.12 SPEAKER_01 Он должен уверенно, всегда, без всяких проблем запускать свой код-Cleanup.
5015.12 5020.68 SPEAKER_01 Поэтому к настройке вот этого нужно подойти довольно таки хорошо и тщательно.
5020.68 5021.68 SPEAKER_01 Инструменты.
5021.68 5035.28 SPEAKER_01 Visual Studio, прежде всего, она поддерживает код-Cleanup, но, к сожалению, у нее нет возможности сохранить тот профиль, который вы наконфигурировали, сохранить его в виде какого-то отдельного файлика для того, чтобы закинуть Source Control.
5035.28 5038.56 SPEAKER_01 В общем, почему-то они это не сделали.
5038.56 5049.92 SPEAKER_01 А это ключевой момент, потому что те фиксеры, тот Cleanup, тот вид кода, который должен быть у вашего приложения, его должны использовать абсолютно все члены команды.
5049.92 5052.28 SPEAKER_01 Они должны использовать один и тот же профиль.
5052.28 5056.96 SPEAKER_01 Не бывает такого, что каждый настраивает, как хочет, и потом все вместе пытаются дело смешать.
5056.96 5072.80 SPEAKER_01 У JetBrains, у райдера в частности, дела намного лучше, потому что он позволяет сохранить все настройки код-Cleanup в тот самый settings-слоеный файлик, который, естественно, можно расшарить между командой и залить в репозиторий.
5072.80 5081.56 SPEAKER_01 Также райдер позволяет автоматически запускать код-Cleanup, например, перед каждым коммитом, что тоже бывает довольно удобно.
5081.56 5088.72 SPEAKER_01 Но UGL все-таки настаивает, что решение должно быть не привязано к конкретному вендору.
5088.72 5096.40 SPEAKER_01 Они пользуются и тем, и тем, но желательно, конечно, найти какое-то решение, которое бы не зависело от конкретного вендора.
5096.40 5099.44 SPEAKER_01 Тут мы, к сожалению, сейчас ничего не можем предложить.
5099.44 5106.56 SPEAKER_01 У нас есть или решение от Microsoft, или решение от JetBrains, и у каждого есть свои плюсы и минусы.
5106.56 5110.92 SPEAKER_01 Так, давайте теперь посмотрим на сам процесс, на как же собственно команде с этим совсем работать.
5110.92 5131.32 SPEAKER_01 Ну, прежде всего нужно понимать, что если вы слишком сильно затянете гайки, например, ограничите количество пробельщиков, которые у вас может в коде быть, то это приведет к тому, что при каждой проверке, при каждом комите, у вас будет очень много ошибок.
5131.32 5139.48 SPEAKER_01 То есть вам будет какой-нибудь анализатор, какой-нибудь форматор сообщать, что вот смотри, ты тут не тот пробельщик поставил, подсмотри, ты тут форматирование не так красиво сделал, как могло бы быть.
5139.48 5144.20 SPEAKER_01 И, в общем, это все вернет, ведет к деградации производительности именно разработчиков самих.
5144.20 5153.96 SPEAKER_01 А тут нужно понимать, что, в принципе, кодстайл и форматинг, они не призваны к тому, чтобы ухудшить продуктивность разработчиков.
5153.96 5155.76 SPEAKER_01 Наоборот, они хотят ее улучшить.
5155.76 5168.16 SPEAKER_01 В общем, здесь вам как раз нужно соблюсти баланс, потому что если вы сделаете слишком строгие правила, вот этого будут страдать разработчики, а если сделаете слишком слабые правила, то от этого будет страдать код.
5168.16 5169.76 SPEAKER_01 То есть у вас код уже не будет таким консистентным.
5169.76 5173.24 SPEAKER_01 И вот выбор этого баланса – это задача каждой конкретной команды.
5173.24 5178.62 SPEAKER_01 Гаэль со стороны команды может бросить несколько советов.
5178.62 5187.62 SPEAKER_01 Прежде всего, выставляйте уровень анализов, кодстайл анализов в ворнинг.
5187.62 5195.18 SPEAKER_01 Это тоже можно регламентировать, какой анализ, какой уровень вам предупреждения выдаст.
5195.18 5199.66 SPEAKER_01 Он говорит, что ворнинг – это то, что команда обязана соблюдать.
5199.66 5201.22 SPEAKER_01 То, через что переступить нельзя.
5201.22 5211.86 SPEAKER_01 Далее, убедитесь, что вы проверяете код анализ при каждом билде.
5211.86 5214.54 SPEAKER_01 То есть вы проводите код анализ при каждом билде.
5214.54 5228.34 SPEAKER_01 Для этого достаточно выставить свойство, которое называется «Enforced code style in build» в директоре buildprops, то есть это стандартная мс-билдовская настроечка, которая вам как раз будет этот анализ проводить.
5228.34 5239.82 SPEAKER_01 Еще один интересный момент, что в команде металлама позволяется допускать ворнинги на машине разработчика.
5239.82 5250.68 SPEAKER_01 На машине разработчика, пока разработчик не дописал код, и он хочет просто-напросто запустить тест или еще что-то, нет никакого смысла обламывать ему компиляцию.
5250.68 5253.30 SPEAKER_01 Поэтому ворнинги на машине разработчика вполне допустимы.
5253.30 5255.16 SPEAKER_01 С этим проблем нет никаких.
5255.16 5264.20 SPEAKER_01 Но вот на CI-системе у них выставлен флаг «Thread warnings as errors», то есть на CI-системе любой ворнинг приводит к ошибкам.
5264.20 5274.52 SPEAKER_01 Чтобы задетектировать ситуацию, когда ваш мс-билд скрипт запускается на CI-системе, есть прекрасное свойство, которое называется «Continuous integration build».
5274.52 5276.96 SPEAKER_01 Оно может иметь значение true или false.
5276.96 5288.00 SPEAKER_01 Интересное значение, то есть интересное свойство, я почему-то раньше на него внимания не обращал, я знал, что каждая система выставляет, каждая CI-система выставляет какие-то свои настройки окружения, в общем.
5288.00 5294.00 SPEAKER_01 А тут появилось такое универсальное, которое само я так понимаю анализирует все эти настройки и выводит вам в каком-то одном предсказуемой свойстве.
5294.00 5295.52 SPEAKER_01 В общем, тоже полезная штука.
5295.52 5302.24 SPEAKER_01 Далее, из советов, включите различные код-анализы.
5302.24 5307.84 SPEAKER_01 Для этого есть специальная статейка от Microsoft, которая называется «Обзор.NET Source код-анализов».
5307.84 5315.02 SPEAKER_01 Там рассказывается, какие код-анализы есть, как их включить, что они там красиво ищут, ну в общем, это стандартные вот эти розлиновские подсказы-возвращенники.
5315.02 5318.44 SPEAKER_01 Такие умные, хорошие, прям некоторые из них просто must-have.
5318.44 5321.00 SPEAKER_01 Поэтому можно не пренебрегать чистой совестью.
5321.00 5329.94 SPEAKER_01 Также Metalama Team использует StyleCop, который сейчас интегрирован прям в розлин-компайлер и является частью C#-компилятора.
5329.94 5338.88 SPEAKER_01 Так, теперь насчет того, а когда же нужно все-таки применять Clion App и как с этим поступать.
5338.88 5347.00 SPEAKER_01 В общем, Гаэль говорит, что, в принципе, погоня за тем, чтобы каждый pull-request был идеально отформатирован, она бессмысленна.
5347.00 5352.04 SPEAKER_01 И поэтому в каждом pull-request они такую проверку не вставляют.
5352.04 5358.68 SPEAKER_01 И при этом со временем у них набирается, соответственно, вот этот, грубо говоря, технический долг по форматированию.
5358.68 5362.20 SPEAKER_01 То есть у них код не всегда идеально отформатирован.
5362.20 5380.24 SPEAKER_01 И они раз в какой-то промежуток времени, то есть в их случае перед фризом майлстоуна, это происходит где-то в 6-12 недель, они запускают полный код Clion App и преобразуют всю их кодовую базу к красивому, понятному виду.
5380.24 5382.48 SPEAKER_01 Не знаю, я этого аргумента, если честно, не понял.
5382.48 5391.80 SPEAKER_01 То есть намного легче, кажется, и соответствует всем признакам того, что Гаэль говорил вначале, намного легче перед каждым pull-request заставлять форматировать код правильно.
5391.80 5399.88 SPEAKER_01 И тогда у вас в репозитории будет вливаться красивый код, в pull-requests и в merge-requests будет красивый код, и другие разработчики будут ревьюить красивый код.
5399.88 5403.04 SPEAKER_01 Никакого смысла допускать это раз в 12 недель, вообще никакого нет.
5403.04 5404.04 SPEAKER_01 Поэтому не знаю.
5404.04 5412.80 SPEAKER_01 На своей практике мы перед, то есть у нас проверка на соответствие эдитер-конфигу, она запускается на каждый билд, на каждый merge-request.
5412.80 5416.76 SPEAKER_01 То есть вы не можете в мастер залить код, который плохо отформатирован.
5416.76 5419.04 SPEAKER_01 И минусов этого подхода я не вижу.
5419.04 5434.00 SPEAKER_01 Так, следующий момент, он повторяется, что запуск клеонап-тулза должен быть полностью предсказуемый, не должен доставлять каких-то неудобств неразработчикам, не должен вводить в ступор ревьюеров, ничего.
5434.00 5438.48 SPEAKER_01 Он должен строго красиво отрабатывать и делать предсказуемые вещи.
5438.48 5444.28 SPEAKER_01 Для того, чтобы так можно было делать, нам нужен клеонап на основании каких-то настроек.
5444.28 5456.32 SPEAKER_01 У нас из инструментов, из инструментов для того, чтобы это делать, например, на Continuous Integration Server, нам нужен какой-то инструмент, который не зависит от локального и локального энвариомента разработчика.
5456.32 5465.56 SPEAKER_01 Прежде всего, это .NET-формат, это консольная утилитка, которая форматирует ваш код в зависимости от того, что написано в Editor Config.
5465.56 5479.16 SPEAKER_01 Это сейчас самая стандартная, самая полная, самая красивая из всех .NET-утилиток, которые есть, поддерживается она непосредственно Microsoft, и поэтому, как минимум, вы должны поддерживать ее.
5479.16 5485.60 SPEAKER_01 То есть как минимум она прекрасна, она хороша, и она понимает хотя бы базовые вещи Editor Config.
5485.60 5490.04 SPEAKER_01 Огромным ее минусом является то, что понимает она не все.
5490.04 5494.24 SPEAKER_01 Понимает она даже, честно сказать, мало, поэтому все с помощью нее отформатировать невозможно.
5494.24 5508.68 SPEAKER_01 На помощь приходит JetBrains, ну кроме того, что у JetBrains есть интерактивный клеонап, который может воспользоваться каждый разработчик, опять же, нас больше интересует автоматизированность системы, и есть такой прекрасный инструмент, который называется ReSharper Kleonap Command Line Tool.
5508.68 5518.36 SPEAKER_01 Это тоже консольная утилита, которая понимает .settings файлы, в которых можно сохранить намного больше настроек, и с помощью которых вы можете автоматически тоже все форматировать.
5518.36 5540.16 SPEAKER_01 И теперь, чтобы этот формат тоже был более-менее предсказуемый на каждой машине, потому что что ReSharper-овская утилита, что .NET-формат, они имеют кучу настроек, и в зависимости от того, какие настройки вы туда передадите, по каким путям найдутся файлы конфигурации, опять же, формат может отличаться.
5540.16 5549.44 SPEAKER_01 Поэтому рекомендуется сделать какой-то предсказуемый скрипт, и в этом скрипте заполнить, записать все точные параметры, с помощью которых должны запускаться эти утилиты.
5549.44 5552.32 SPEAKER_01 Может быть, даже не одна утилита, а несколько утилит.
5552.32 5561.48 SPEAKER_01 Чтобы, несмотря на то, где этот скрипт запущен, у локального разработчика или на CI-системе, он всегда стабильно выдавал один и тот же результат.
5561.48 5563.96 SPEAKER_01 Поэтому все это нужно сделать именно так.
5563.96 5584.96 SPEAKER_01 Это базовые вещи, которые просто обязаны быть в любом проекте, но если вы их вдруг здесь сделали, то если они у вас есть, то вы большой молодец, но если вы хотите пойти дальше, то можно вернуться, то есть можно уже углубиться в какие-то более интересные аспекты, которые также можно отнести к качеству кода.
5584.96 5603.80 SPEAKER_01 Ну, например, можно проверять, что если у вас есть интерфейс iFactory, то все классы, пронаследованные от этого интерфейса iFactory обязаны заканчиваться на слово "factory", или более ближе, наверное, к каждому разработчику, это все, что пронаследовано от атрибута, от системы атрибут, должно заканчиваться на слово "атрибут".
5603.80 5606.76 SPEAKER_01 То есть вот такие вещи, если вы хотите поддерживать в своем проекте.
5606.76 5625.56 SPEAKER_01 Ну или что-то более сложное, например, если у вас есть неймспейс биллинга, то в этом неймспейсе никогда не должны использоваться даблы, потому что любые там деньги мы подразумеваем, что в биллинге должны обрабатываться с помощью интов или с помощью децималов.
5625.56 5634.08 SPEAKER_01 Такие условия тоже можно писать, их можно проверять, но это уже не обойтись нам какими-то простыми средствами, которые чисто для кодформатирования придуманы.
5634.08 5636.64 SPEAKER_01 Есть более интересные, более глубокие средства.
5636.64 5639.04 SPEAKER_01 Во-первых, это архитектурные тесты.
5639.04 5648.88 SPEAKER_01 Кстати, если вам интересно поговорить про архитектурные тесты, обязательно напишите нам в комментариях, у нас лежит статьечка про них, мы давно ждем какого-нибудь хорошего повода.
5648.88 5656.20 SPEAKER_01 Ну и второй инструмент, который Каэль не мог не предложить, это металлама, который мы как раз-таки сами обсуждали.
5656.20 5664.80 SPEAKER_01 То есть с помощью аспектно-ориентированных вот этих навешанных атрибутов мы можем сделать все вот эти проверки, ну и даже больше, как Игорь упоминал в предыдущей статье.
5664.80 5681.16 SPEAKER_01 В общем, вот такое развитие, вот такие базовые инструменты, поэтому если вдруг вы нашли что-то интересное, какие-то интересные анализаторы техники, которые у вас еще не применяются, рассмотрите возможность, потому что никогда не бывает мало красивого кода, красивый код должен быть всегда много и стандартный между всей командой.
5681.16 5697.40 SPEAKER_00 Да, прикольно, ну иметь такой максимально автоматизированный способ поддерживать кодовую базу в нормальном состоянии, это самое, да, наверное, довольно сложно, чтобы его внедрить, ну потому что надо всем договориться, но зато потом жить проще.
5697.40 5698.40 SPEAKER_00 Проверено.
5698.40 5709.08 SPEAKER_01 Ну да, особенно прекрасно, когда вы начинаете его внедрять прямо в новом проекте, когда ни о чем договариваться, там ничего переписывать не надо, договариваться все равно придется, переписывать ничего не надо, это самый большой бич.
5709.08 5731.08 SPEAKER_00 С этим старым проектом, как правило, в общем, включаете анализаторы, фиксите какое-то ограниченное время, максимальное количество самых явных проблем, так скажем, и дальше потихонечку включаете, все больше и больше, потихонечку дофикшивая, инкрементно, не спеша, ну или наоборот поспешает, в зависимости от того, сколько у вас времени и команды есть.
5731.08 5732.08 SPEAKER_00 Ну чё, давай дальше.
5732.08 5733.08 SPEAKER_00 Еще, да?
5733.08 5734.08 SPEAKER_00 Еще хотите?
5734.08 5735.08 SPEAKER_00 Мало?
5735.08 5741.28 SPEAKER_00 Давай, давай, да, мы же это до 2 часов должны добить, мы же собирались писать выпуск на 1 час.
5741.28 5747.92 SPEAKER_01 Да, мы собирались записать коротенький выпуск, что получится, ну уже понятно, что получится, поэтому давай во все чашки, что что.
5747.92 5788.20 SPEAKER_01 Ладно, небольшие вбросы от Фил Хака, как бы не мог пропустить, потому что Фил Хак пишет довольно редко, не знаю, год назад у него последний раз в блокпост выходил, и в принципе, хорошую тему он поднял, он написал в своем твите следующую штуку, что это в принципе не самая великолепная аналогия, но все-таки попробуйте поразмыслить, что Aspire, ну как вы могли выпуск без Aspire сделать, правда же, Aspire, Aspire это как Nuget, только для облачных сервисов, то есть когда мы делали Nuget, наша задача была, это как можно проще затаскивать к себе различные библиотеки, различные зависимости в наших проектах.
5788.60 5838.76 SPEAKER_01 Ну и до того, как появился Nuget, слишком много это нам приносило неудобств и боли, потому что нам нужно было их как-то найти, определить, какой версии мы хотим, как-то затащить свой проект, как-то их где-то прописать, что делает сейчас Nuget автоматически, мы даже об этом не задумываемся, мы не понимаем, на какой огромный пласт сложности он нас убирает, и в наше время как раз мы сталкиваемся почти с такой же точной проблемой, у нас есть Postgres, у нас есть RabbitMQ, у нас есть всякие Kafka, всякие memcache, и все это точно такие же сервисы, которые нужны нашему приложению в качестве зависимости, и мы точно так же должны понять, откуда мы их возьмем, о какой версии, а как мы их к себе притащим, а как сконфигурируем, и в принципе те же самые задачи, но просто немножко на другом уровне перед нами стоят.
5838.76 5841.56 SPEAKER_01 Разберемся с этой мыслью.
5841.56 5842.72 SPEAKER_01 Зачем придумался Nuget?
5842.72 5858.12 SPEAKER_01 В общем, если мы почитаем там первые постулаты, зачем был нужен Nuget, то, как я уже упоминал, у нас была большой комьюнити, в котором было много библиотек, и среди этих библиотек ориентироваться было довольно-таки сложно.
5858.12 5881.56 SPEAKER_01 Неизвестно, кто был в каком состоянии, через как он распространялся, как его в конце концов было заподключить в свой проект, и где его найти, и как с этим проектом его потом таскать, эти библиотеки, в общем, все те проблемы, которые очень хорошо будут вам видны, если вы сходите в какой-нибудь язык, в котором до сих пор проблемы с такими системами контроля версий.
5881.56 5889.00 SPEAKER_01 Допустим, у C до последних времен были очень большие проблемы, а сейчас средние проблемы с этим.
5889.00 5899.48 SPEAKER_01 Ну, то есть, представляете, самый, наверное, древний из мейнстримовых языков до сих пор не обзавелся системой наподобие Nuget, системой, которая управляет его пакетами.
5899.48 5909.48 SPEAKER_01 И там люди довольно страдают, вплоть до того, что передают друг другу DLL в виде zip архивчиков и каким-то образом версионируют их по-старинке.
5909.48 5927.72 SPEAKER_01 В общем, Nuget сделал для нас огромный шаг вперед, то есть он уменьшил количество тех операций, которые нам необходимы для того, чтобы было найти пакет, установить его и вместе с проектом каким-то образом сопровождать, обновлять и так далее.
5927.72 5963.00 SPEAKER_01 И что немаловажно, Nuget все это сделал абсолютно бесшовно, то есть мы получили очень хороший опыт нового разработчика, когда он может склонировать просто репозиторий из нашего центрального хранилища, нажать F5 и у себя локально этот проект запустить, не загоняясь о том, что под капотом там происходит .NET restore, который лезет где-то, достает актуальные версии библиотек, который их куда-то подключает, как-то складывает, где-то копирует, разрешает конфликты, в общем, под капотом там творится очень много сложной магии, сложной операции.
5963.00 5969.96 SPEAKER_01 Для обычного разработчика ты склонировал, нажал F5, проект у тебя запустился и этот опыт очень дорогого стоит.
5969.96 5979.32 SPEAKER_01 И теперь если мы взглянем на наши облачные сервисы, которыми нас со всех сторон пытаются окутать, то там же происходит такая же точная ситуация.
5979.32 5986.80 SPEAKER_01 У нас есть зависимости у нашего проекта и эти зависимости обычно от каких-то других сервисов, которые есть.
5986.80 6002.56 SPEAKER_01 Уже просто так нельзя, мы не можем уже просто так взять и запустить наш проект с помощью F5, мы обязательно требуем какую-то базу данных, может быть какой-то кэш, может быть какую-то очередь, без этого наш сервис может быть не стартануть, а если в хорошем случае он и стартанет, то работать он точно не будет.
6002.56 6017.64 SPEAKER_01 И .NET expire здесь очень похож на Nuget, вот в .NET expire как раз и входит задача уменьшить количество тех шагов, которые нам нужны для того, чтобы добавить, для того, чтобы внедрить вот эти клауд сервисы, облачные сервисы в наше приложение.
6017.64 6026.40 SPEAKER_01 Но в отличие от обычных библиотек, с которыми работает Nuget, у облачных сервисов гораздо больше различных требований.
6026.40 6034.56 SPEAKER_01 Их нужно каким-то образом настроить, их нужно каким-то образом задеплойить, их нужно каким-то образом мониторить.
6034.56 6038.92 SPEAKER_01 В общем, там стоит намного больше задач, чем стояло перед Nuget.
6038.92 6047.92 SPEAKER_01 Или, допустим, если мы берем connection string, то их нужно каким-то образом пробросить между сервисами, и желательно все это сделать безопасно, чтобы никакие лишние пароли никуда не утекли.
6047.92 6054.92 SPEAKER_01 И expire как раз и позволяет это все делать, он как раз и призван нам для того, чтобы упростить все эти точки.
6054.92 6063.44 SPEAKER_01 Он знает, откуда затянуть, он знает, как настроить, он знает, как отмониторить, как вам даже это показать в красивом дашборде, и даже пытается как-то дружить с секьюрити.
6064.04 6070.68 SPEAKER_01 Поэтому он примерно эти вещи и решает, но только для веб-сервисов.
6070.68 6082.04 SPEAKER_01 В комментариях тут же набежала куча народу и сказали, что в принципе есть какое-то сходство, но вам не кажется, дорогой сударь, что это больше не про expire, а про докер?
6082.04 6114.12 SPEAKER_01 Ведь это именно докер позволяет нам хорошо упаковать сервисы, как упакуются Nuget пакеты, и именно докер позволяет вам локально это все запустить, как делается локальный дотнет рестор, и в принципе докер - это ключевая технология, которая должна ассоциироваться с Nuget, но ни разу не expire, на что в принципе Фил Хак резонно заявляет, что докер - это всего лишь навсего формат хранения, как для Nuget формат хранения - это zip.
6114.12 6115.12 SPEAKER_01 Хороши ли zip архивы?
6115.12 6116.12 SPEAKER_01 Да, хороши.
6116.12 6120.76 SPEAKER_01 Позволили ли нам в виде одного красивого файлика доставлять любые данные на клиента?
6120.76 6121.76 SPEAKER_01 Да, позволили.
6121.76 6122.76 SPEAKER_01 А упаковать локально?
6122.76 6123.76 SPEAKER_01 Да, тоже позволили.
6123.76 6125.88 SPEAKER_01 Но все-таки Nuget - это нечто большее.
6125.88 6129.36 SPEAKER_01 Так же точно и expire - это нечто большее над обычным докером.
6129.36 6141.08 SPEAKER_01 Это то, что вам как раз делает провиженинг, конфигурацию, диплоймент, какой-нибудь security management, сервис-дискавери, вот это вам все делает именно expire, и докер этого из коробки сделать не может.
6141.08 6151.52 SPEAKER_01 Поэтому у expire намного больше преимуществ для того, чтобы вот этот workflow заклонировал и запустил, сделать реальным на локальном компьютере.
6151.52 6154.08 SPEAKER_01 Больший преимуществ, чем у простого докера.
6154.08 6163.72 SPEAKER_01 У простого докера с этим будет намного больше проблем, а у expire все-таки мы можем получить тот долгожданный экспириенс, когда мы заклонировали репозиторий, нажали в пять и у нас все работает.
6163.72 6172.52 SPEAKER_01 Но теперь оно работает не просто так, не просто потому что есть какие-то зависимости, а еще он и эти зависимости к себе подтаскивает.
6172.52 6177.56 SPEAKER_01 Подтаскивает, обновляет, мигрирует, связывает друг с другом и показывает в удобном дэшбарде.
6177.56 6184.68 SPEAKER_01 И вот этот экспириенс, когда заклонировал и запустил, вот этот наброс возвращается даже в наших самых сложных приложениях, которые только можно было придумать.
6184.68 6197.36 SPEAKER_01 Вот такой интересный наброс, в общем, поэтому, может, когда вы в следующий раз будете смотреть на expire или объяснять кому-то, что такое expire, аналогия, что это nuget для облачных сервисов, будет для вас близка.
6197.36 6218.88 SPEAKER_00 Ну да, и посмотрим, куда подвинется expire, потому что у нас был в каком-то из чатиков ссылочка на отдельный сайт под названием expire-dashboard.com, где прям вообще такой супер модный сайт, супер рекламирующий этот самый expire, ну для программистов рекламирующий, понятное дело.
6218.88 6226.24 SPEAKER_00 Со всякими трейсами, там open telemetry, примеры кода на питончике, на джаве, на джава скрипте, на c-шарпе, в общем, прям это очень классно выглядит.
6226.24 6236.48 SPEAKER_01 Ну да, знатный сайт, прям, который видно, что продает отдельный продукт expire-dashboard, ну как продает, он, естественно, фришный, но заставляет задуматься, не хотите ли вы его завязать.
6236.48 6243.96 SPEAKER_00 Поэтому, да, хорошо, что… Да, то есть именно прям вот видно, что дешборд они как-то отдельно продвигают и показывают.
6243.96 6259.00 SPEAKER_00 А вторая половинка, это вот тот самый provisioning, который уже делается, если вы полноценно тащите expire в важный проект, он тогда, да, позволяет вам всё это дело запровиженить и удобно использовать.
6259.00 6264.04 SPEAKER_00 Ну и хорошо, давай мы будем потихонечку загругляться.
6264.04 6271.76 SPEAKER_00 В этот раз есть только одна новость из кратко о разном, это про .NET Eventing Framework.
6271.76 6383.80 SPEAKER_00 Если вы помните, наверное, месяца два назад, может быть три, я упоминал про то, что в гитхабе Майкрософта появилась ишью, по-моему, в рантайм, нет, наверное, не в рантайм, там, где, короче, библиотечки живут, репозитории, появилась ишью, которая называлась .NET Eventing Framework, туда набежала куча народу, про то, что ой, всё, вы сейчас убьёте, всё, значит, так сказать, стороннее open-source ПО вокруг ивентинга, то есть все какие-то мастранзиты и сервисбас больше будут не нужны, и Майкрософт напишет свой ивентинг фреймворк, причём, ну, были те, кто вот так вот с этой стороны жаловался, были те, кто говорили, наконец-то, нормальный ивентинг фреймворк от .NET, выкинем нафиг мастранзиты, сервисбасы, всё, ну, в общем, как обычно, все разделились на несколько лагерей, при том, что Майкрософт это всё говорил, да ладно вам, что вы это, мы только делаем там для Azure Functions и вебджобов, как бы узкая нишевая штука, ну, назвали, как бы, ивентинг фреймворк, ну, на самом деле это, типа, только для конкретного юзкейса, вот, но в результате там ишьи, по-моему, обсуждения идут до сих пор, не помню, сколько там, сотен комментариев уже, но смысл в том, что вот буквально недавно Майкрософт таки сказали, Фаулер, Дэвид Фаулер написал в этой ишьи, что мол, не, значит, мы комьюнити услышали, никаких, по крайней мере, в девятом .NET ивентинг фреймворка не будет и что мы будем использовать, так сказать, open design process for future version, то есть они не отказываются от идеи сделать какой-то ивентинг фреймворк, но судя по тому, что они будут использовать, так сказать, engage-ить весь open source комьюнити в то, чтобы с правильной фреймворкой дизайнить, таки, видимо, там всё-таки должен был получиться какой-то чуть более глобальный ивентинг фреймворк, чем просто для Ажура, но вот посмотрим, будет ли нас с заменой масс-транзита и энд-сервис баса, но, видимо, уже в тот на десять дней раньше.
6383.80 6402.20 SPEAKER_01 Слушай, ну обидно, обидно, я как раз из тех, кто хотел бы всё-таки получить какой-то стандарт ивентинга, потому что сейчас задолбали как бы изобретать какие-то убогие колечные консюмеры, очень не хватает, не хватает такого же вот, как мы сделали для контроллеров, какой-то стандарта, вот такого же нужно для ивентинга.
6402.20 6409.40 SPEAKER_00 Ну посмотрим, может, что и сотворят, и неплохое, и в сообществе с open-source будет даже как-то совместимо.
6409.40 6419.80 SPEAKER_00 По большому счёту же им нужно сделать что-то а-ля iLogger, то есть какой-то как бы интерфейс, им не обязательно делать реализацию в целом, а дальше все остальные подстроятся.
6419.80 6424.08 SPEAKER_00 Ты же используешь Serilog в качестве как бы подкладки под iLogger реализации?
6424.08 6434.20 SPEAKER_01 Да, да, но это, наверное, единственное, что выжило после всех контейнеров, после всех логеров, после всех тех же самых minimal API, Serilog единственный, кто выжил.
6434.20 6435.20 SPEAKER_01 Ну вот посмотрим.
6435.20 6436.20 SPEAKER_01 Поэтому не зарекайся.
6436.20 6438.08 SPEAKER_01 Ну глянем, что будет.
6438.08 6444.00 SPEAKER_01 Ну ладно, давай закругляться, вроде уложились, пусть не в 1 часик, но в 2.
6444.00 6474.16 SPEAKER_00 Ну в 2, я надеюсь, мы уложились, судя по таймеру, да, миграции в коре обсудили, параметры маршрутов в спин-энд-коре пошифровали, металаму как замена постшарпа обсудили, как писать код, чтобы было удобно и стильно, так скажем, в едином стиле тоже обсудили, подумали, может ли Aspire быть новым Nuget в каком-то смысле для клауда, ну и вендинг фреймворка не будет выделять на дотнете, может хорошо, может плохо, посмотрим.
6474.16 6476.36 SPEAKER_01 Ну или в каком-то обрезанном виде, может быть.
6476.36 6486.56 SPEAKER_00 Ну может что успеют придумать, но я думаю, что если они сказали, что типа нет, будет у нас open design процесс, я думаю, что этот open design процесс займет там месяцы, вряд ли они что-то успеют сделать, лишь бы.
6486.56 6488.20 SPEAKER_01 Ну ладно, зато нам будет много новостей.
6488.20 6489.96 SPEAKER_00 Лишь бы что-нибудь сделали, да.
6489.96 6495.44 SPEAKER_00 Ну чё, на этом всё, 96 выпуск заканчивается, всем спасибо.
6495.44 6506.06 SPEAKER_01 Всем счастливо, всем пока, заставляйте комментарии, рассказывайте друзьям, если вы хотите, чтоб в вашей чатике бросали ссылки на Aspire Dashboard, то добавляйтесь к нам на Boosty, там много всего интересного.
6506.06 6507.06 SPEAKER_01 До новых встреч, пока!
6507.06 6507.56 SPEAKER_00 Пока.
6507.56 6508.06 SPEAKER_00 Пока.
6508.06 6522.06 UNKNOWN [музыка]
