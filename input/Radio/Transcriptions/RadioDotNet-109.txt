6.34 49.50 "Анатолий Кулаков" Здравствуйте, дорогие друзья! В эфире Радио.нет выпуск номер 109. В студии его постоянный ведущий Анатолий Кулаков. И Игорь Лабутин. Всем привет! А также нам помогают наши друзья. Среди них Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артомонов, Сергей Бензенко, Лазарев Илья, Шевченко Антон, Ольга "Я люблю JS" Бондаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей, Дмитрий Сорокин, Александр Ерыгин, Егор Сычев, Гольдебаев Александр и Тимофей. Друзья, спасибо вам всем тем, кто нам помогает и поддерживает. Если вы еще этого не делаете, зайдите на Boosty и посмотрите. Может, вы уже захотите это сделать.
49.50 53.36 "Анатолий Кулаков" Так, погнали посмотрим. Микрософт у нас еще не ожил, я так понимаю, да?
53.36 70.68 "Игорь Лабутин" Микрософт немножко ожил. Оказывается, мы очень внимательно следим за новостями, там тихо и по чуть-чуть выходили всякие превьюшки Visual Studio, и тут на днях зарелизилась полноценная Visual Studio 17.13. Вот это уже неплохо, неплохо, давай.
70.68 96.28 "Игорь Лабутин" Без каких-либо, так сказать, объявлений, чего-либо, но вот зарелизилась. Короче, 17.13, там на самом деле не так много изменений прямо, но давайте по ним пробежимся. Они, как обычно, сгруппированы по нескольким разделам. Называется раздел 1 - Productivity, и первая же фича, которая там есть, это теперь вы можете настраивать в Visual Studio дефолтный энкодинг ваших файлов. Если, например, вы хотите хранить исходники в Covey8, то, наконец-таки, это можно сделать по
96.28 114.80 "Анатолий Кулаков" дефолту. Слушай, у меня как раз другая проблема была. У меня он почему-то через раз иногда сохранял VTF8, а иногда сохранял Windows 12.51. И вот, когда ты сохраняешь Windows 12.51, а с этим не очень хорошо поработают всякие GitLab и прочие такие визуальные инструменты для pull-requests, annotations, gif-ов и так далее.
114.80 119.08 "Игорь Лабутин" Ну или если коллеги берут твой код на каком-нибудь Linux-е или Mac-е.
119.08 132.84 "Анатолий Кулаков" Ну, типа, да. Знаешь, когда я прописал VTF8 в EditorConfig, до этого у меня абсолютно все файлы сохранялись в невонятной кодировке, а EditorConfig половину случаев он покрывает. Но, к сожалению, не все, почему-то не все.
132.84 137.28 "Игорь Лабутин" Я думаю, что если он видит там, типа, о, русский язык, наверное, ты хочешь в 12.51.
137.28 141.66 "Анатолий Кулаков" Ну, типа, типа, да. Не знаю. Ну, короче, теперь можно в настройках выбрать.
141.66 149.76 "Игорь Лабутин" Можно сказать encoding, это хорошо. Да. Наконец-таки, законченная эпопея с горизонтальным скроллбаром. Я напомню, мы, по-моему, один или два раза этого касались.
149.76 186.96 "Игорь Лабутин" Там смысл в том, что вот этот маленький тулбарчик внизу, который в Editor-окошке справа появлялся, он потихонечку разрастался. Я так понимаю, что там какие-то гетовые кусочки появлялись, может быть, там же появляется, по-моему, краткая сводка от всякого error analysis, ну, там, типа, количества вордингов, эрроров и прочего. В итоге там, видимо, AI еще что-нибудь добавляла, в итоге там места становилось настолько мало, что горизонтальный скроллбар, он полностью пропадал. Ну, в общем, они провели большую работу и теперь с гордостью заявляют, что скроллбар теперь точно будет виден в любой момент времени жизни и будет нормального размера. Ну, в общем. Не сдадим скроллбар. Да, хорошо.
186.96 383.84 "Игорь Лабутин" Дальше в CodeSearch допилили очередной кусочек навигации и можно переходить к недавним файлам. Мне кажется, это было еще в предыдущей версии, но, видимо, что-то допилили. В общем, ладно. Копайлот. Мы уже упоминали, что Копайлот стал доступен бесплатно в Visual Studio Code, ну, с некоторыми ограничениями, про там, 2000 completion и 50 requests. Теперь тоже самое доступно в Visual Studio. Он теперь умеет работать на нескольких файлах сразу. Добавили какие-то новые шорткаты и появились то, что называется /command-expansions. То есть, я так понимаю, прямо в исходном коде можно писать /refactor-this и он поймет, что это такое. Те, кто пользуется, посмотрите внимательно. Дебаггинг. Довольно много Microsoft пиарила свой LinkU Visualizer. То есть, это штука, которая позволяет вам в режиме отладки пописать какой-нибудь собственный LinkU над, допустим, коллекциями и вытащить, например, в дебаггере, посмотреть, там, не знаю, содержимое массиво отфильтрованное по какому-нибудь условию, там, не знаю, сортированное, сгруппированное в дикшенере, еще что-нибудь в таком духе. Это все выполняется. Теперь там появилась подсветка синтаксис. То есть, когда вы пишете это LinkU выражение, у вас там будет подсветка синтаксис. Добавили, вообще, кстати, странно написано, добавили отладку для нативного кода. Она, в общем-то, и раньше была, но, видимо, стало что-то лучше. Фича про Parallel Stacks, а также Async Stacks, они, короче, стали получше. В Parallel Stacks пишутся всякие Summary по thread'ам. То есть, там требует не просто набор стэков, а еще какая-то Summary информация по thread'ам. Ну и Async операции, которые, как известно, разматываются, на самом деле, технически могут быть даже на несколько потоков. То есть, это не совсем стэк, это такой виртуальный стэк. Он, теперь, профайлер научился это понимать, и у вас будет нормальный, красивый, асинковый стэк, если вы этим пользуетесь. Git Tooling тоже улучшился в очередной раз. Комменты к pull-request'а можно добавлять. Умеет находить проблемы в момент коммита, то есть, я так понимаю, в момент коммита запускать какие-то свои там, код cleanup и код анализис, и проверять, что вы там ничего не нарушили. И можно теперь управлять и смотреть тегами git'а. Что-то, мне кажется, это было. Ну, ладно. В IDE, в категории IDE, тоже появилась важная фича. Если вы меняете темы, то ваш фонд сохранится. То есть, вы выбрали свой какой-нибудь там, не знаю, JetBrains, Mono, ну, какой угодно, кем вы там пользуетесь, то даже если вы будете менять тему, фонд при этом сохранится, а не сбросится. Можно теперь, помимо майкрософтских аккаунтов, добавлять гитхабовские аккаунты в много, в большом количестве. То есть, можно теперь несколько гитхаб-аккаунтов добавить. Ну, и, конечно, есть кусочки для клауда. То есть, там всякие .NET Expire с Azure Functions можно теперь запускать. Они будут с помощью локального эмулятора Azure Functions работать нормально. И какие-то еще улучшения для докера добавили. Это, в целом, все про 17.13. Ну, а если быть более точным, Visual Studio 2022, версия 17.13. И, естественно, сразу с релизом этой версии вышла версия 17.14 с превью 1, где пока только стабильность и секьюрити bugfixes. То есть, там ничего такого нет, я так понимаю, что это. Пару секьюрити фичей закоммитили, вот теперь уже превью 1. Там пока никаких интересностей нету. Как будут появляться, мы постараемся
383.84 397.00 "Анатолий Кулаков" не пропустить и рассказать об этом. Ну, самая большая интрига в том, что студия до сих пор 20.22, она по-прежнему сохранилась, да? Да, и никаких, как бы, планов, что-то пока
397.00 405.80 "Игорь Лабутин" не видно, и я нигде не видел никаких обсуждений на эту тему. Надо срочно дискашен завести, ну, это же какой-то беспредел. Было бы где заводить. В Visual
405.80 542.24 "Анатолий Кулаков" Studio-то нет GitHub-репозитория. Ну, ладно, какой-то Microsoft Issue для Visual Studio-то должен быть. Как-то же о багах сообщают, там. Ну, может быть, может быть. Фидбэк там какой-то можно добавить. Ну, ладно, погнали дальше. Хотелось бы вам рассказать об ином интересном компонентике. В Dota 9 появился гибрид кэш. Наверное, многие с ним уже сталкивались, а кто не сталкивался, сейчас я вам расскажу, потому что нам удачно под руку подвернулась статья Андрея Прожнякова, который засел и раскопал для нас, рассказав, что это такое. Давайте же вместе посмотрим. Ну, прежде всего, новый классик - гибрид кэш. Это, конечно же, инструмент кэширования, как не сложно было догадаться. И прекрасен он тем, что соединяет в памяти два уже устоявшихся стандартных подхода. Ну, какие у нас подходы есть к кэшированию? Если нам нужно закэшировать что-то в памяти процесса прямо самого, есть давно уже прекрасный интерфейс, который называется iMemory Cache. И он в памяти процесса все кэширует. Обычно он используется, когда вам нужно сократить какую-нибудь задержку, например, какой-нибудь сложный ответ, не ходить за ним в базу данных, а если он там меняется довольно редко или меняется предсказуемо, просто закэшировать его в iMemory Cache, держать его там и отдавать довольно быстро и красиво. К минусам этого подхода можно отнести то, что как только ваш процесс поперезапустится, например, умрет и поднимется заново, то естественно весь iMemory Cache у него сотрется и iMemory Cache будет пустым. Но зато имплементация, поддержка и реализация как бы всего это хозяйства довольно прекрасно и легко и понятно. Второй подход - это iDistributed Cache. Это какое-то внешнее кэширование. То есть иногда бывает по сети во внешний кэш сходить намного быстрее и легче, чем, например, выполнить какой-то сложный запрос к локальной базе данных. Такое тоже сплошь и рядом встречается. И вот таких вот распределенных внешних кэшей их огромное количество. Но, наверное, самым популярным является Redis или может быть Memcached. И для как раз Redis всяких существует интерфейс iDistributed Cache. Он полезен для распределенных средств. Когда у нас век кубернетесов, все запускается в десяти нодах и все эти десять нод они могут кэшировать десять раз одной тоже, каждый в своем процессоре, каждый в своей памяти, при этом пожирая память. А вынести это все в один единственный Redis и из этого Redis с одного инстанца все тащить.
542.24 648.00 "Анатолий Кулаков" Из минусов, ну, наверное, можно ответить, что так как это поход все-таки по сети, вам нужна будет сериализация. Стандартный интерфейс работает с массивом байт, поэтому вам нужно ваш объект уметь сериализовать. И плюсом, конечно же, является в том, что когда ваш процессор перезапускается, никакой кэш не теряется, потому что его теперь держит его теперь держит нода Redis, которая, естественно, может там быть настроена Persistent или может быть просто в памяти держаться в своем кластере. Как бы тут не суть важна для нас. Для нас важно, что когда программист решает, а как бы ему кэшировать свои данные, перед ним стоит вопрос, вот что нам выбрать Memory Cache или Distributed Cache, а что если мы сначала захотим так, а потом сяк. В общем, мы программисты - люди ленивые, нам бы хотелось на этот вопрос не отвечать, нам бы хотелось просто взять и чтобы она работала. Вот именно так и делает Hybrid Cache, потому что Hybrid Cache внутри себя объединяет два этих подхода. Надо сказать, что Microsoft не изобрел как бы какое-то чудо Hybrid Cache, например. Данный подход, аналог данного класса, если так можно сказать, уже давно существовал и он довольно популярен на GitHub, там у него большая куча звездочек, называется он Fusion Cache. И он очень похож прям на Hybrid Cache, и внутренние устройства похожи, прям сигнатуры методов похожи. В общем, Fusion Cache - это вот, наверное, то, с чего копировался Hybrid Cache. И если вам вдруг не хватит по фичам Hybrid Cache, то можно посмотреть на Fusion Cache. Там фичей намного больше, умеет он намного больше, развивался намного дольше. В общем, может быть, он вам больше понадобится. Но мы сейчас поговорим о стандартном Microsoft Hybrid Cache. Из приятного Hybrid Cache у нас распространяется в виде отдельного пакета - Microsoft Extension Caching Hybrid.
648.00 653.94 "Анатолий Кулаков" И поддерживает этот пакет .NET Framework 4.7.2 и .NET Standard 2.0.
653.94 674.44 "Анатолий Кулаков" Ну, то есть, прям до любых старых приложений они мечтают дотянуться с помощью этого пакета. Все, что вам нужно - это добавить в сервисы, вызвать для сервисов метод addHybridCache, который под капотом добавит InMemory Cache, обсуждающийся ранее, а также зарегистрировать несколько серилизаторов, которые помогут вам работать, например, с удаленным кэшом.
674.44 695.00 "Анатолий Кулаков" Это серилизаторы по умолчанию есть для строки и массива байта. Все остальное, что не является строкой и массивом байта, он загоняет в System Text JSON, и после этого они являются массивом байта и строкой. Также, естественно, можно указать какие-то свои серилизаторы, если только вы знаете, как правильно серилизовать и сервизовать ваши объекты, и регистрируйте свои серилизаторы, и все в порядке.
695.00 700.00 "Анатолий Кулаков" Hybrid Cache начинает с ними нормально работать. Это все настраивается через конфиги.
700.00 765.32 "Анатолий Кулаков" По умолчанию также регистрируется дефолтная реализация абстрактного класса Hybrid Cache. Именно класс Hybrid Cache вы будете использовать в качестве зависимости в своем приложении для того, чтобы каким-то образом работать с кэшом. Сам Hybrid Cache не реализует вышеупомянутые InMemory Cache и iDistributedCache, он их внутри себя агрегирует. Поэтому, если вы мечтали просто ваш текущий код взять и переделать под новый класс, под новый Hybrid Cache, у вас ничего не получится. Вам немножко все-таки придется методы переписать. По дефолту реализуется Hybrid Cache с помощью класса Default Hybrid Cache. И если не скажем ничего другого, он использует по умолчанию кэширование в памяти, то есть наш InMemory Cache. Но, если перед этим вы где-то в вашем приложении настроили iDistributedCache, то Default Hybrid Cache по умолчанию заиспользует его тоже. То есть он понимает, когда есть у вас iDistributedCache, тогда начинает его использовать. Когда нет, то тогда работает просто DistributedCache. У этого Hybrid Cache у него есть несколько интересных фишек.
765.32 957.52 "Анатолий Кулаков" Вот, в частности, одна из фишек - это повторное использование объектов. Например, если вы дистерлизуете какой-то экземпляр, и если этот экземпляр два раза у вас сохранен, допустим, в кэше, то он не будет создаваться два раза. То есть два одинаковых объекта не создадутся. Это происходит в том случае при соблюдении двух условий. Если этот класс sealed, и если этот класс помечен специальным атрибутом, который называется ImmutableObjectTrue. Вот, если все эти условия соблюдены, и вы пытаетесь дистерлизовать два раза подобный объект, то создастся всего-навсего один экземпляр. Что довольно удобно и иногда может хорошенечко сэкономить память. Естественно, там есть куча настроек для этого гибрид кэша. Например, размер записи, который вы можете сохранить, длину ключа, срок хранения локального или распределенного ключа, надо или использовать джатти, или не надо использовать джатти. В общем, там куча всякого гибкого и интересного. Что еще можно выделить? Как вообще работать с гибрид кэшом? Вообще, в принципе, так как и с любым кэшом, например, если вы в Concurrent Dictionary любили работать, то здесь вот практически все то же самое. Есть очень хороший метод, который называется GetOrCreateAsync, который, в принципе, вы можете использовать вообще не зная об других методах. Он решает практически все, что вам нужно знать. Давайте же на его примере как раз и разберемся, что происходит внутри этого гибрид кэша, как он работает. На самом деле, предсказуемо понятно. Если вы делаете GetOrCreateAsync, то прежде всего этот метод принимает ключ, и если элемент под этим ключом не найден в кэше процесса, то есть в InMemory кэше, то начинается проверка внешнего хранилища. Если и во внешнем хранилище объект не найден, то вызывается метод создания объекта, метод получения объекта. То есть, тяжелый метод, который может асинхронно сходить в базу, еще что-то сделать и вернуть вам наконец тот самый объект. И после того, как вам его вернули, данный метод, полученный объект сохраняет в Distributed кэше и в локальном кэше тоже. Таким образом, он у вас размазывает кэш, получая плюсы обоих подходов. Если в локальном кэше есть экземпляр, то он вам очень быстро вернет. Если ваше приложение перезагрузилось и в локальном кэше его нет, но при этом он остался в Distributed кэше, то ваше приложение его загрузит из Distributed кэша и тоже как бы локально закэширует и тоже вернет. То есть, вы избавляетесь от минусов обоих этих подходов, получая только плюсы. Еще одна интересная фишка Hybrid кэша в том, что он гарантирует, что при параллельных вызовах вот этого метода getWorkRateAsync с одинаковым ключом, объект будет запрошен из источника всего-навсего один раз. Если вы сталкивались с Concurrent Dictionary, допустим, то очень частый вопрос есть на собеседованиях, что будет, если может ли у Concurrent Dictionary вот эта фабрика, которая источник объекта, быть вызвана несколько раз. Ну, правильный ответ, что может. Concurrent Dictionary не гарантирует, что создание объекта будет вызваться только один раз.
957.52 966.20 "Анатолий Кулаков" Он может быть вызван несколько раз. А Hybrid кэш как раз таки гарантирует, у него эта гарантия есть. То есть, фабрика по созданию объекта вызовется только один раз.
966.20 977.76 "Анатолий Кулаков" Остальные же вызовы будут ожидать результата. То есть, они не вернутся там с криками, что нет, я не нашла. Они узнают, что у нас сейчас фабрика находится в процессе работы, подождут, пока она сделает свой результат.
977.76 983.12 "Анатолий Кулаков" Этот результат сохранится в кэш, а потом они из кэша считают нужное значение.
983.12 1093.32 "Анатолий Кулаков" Эта техника называется Cache Stampede Protection. То есть, у нас больше вот это Cache Stampede, вот это вот, повторного создания объекта, когда нужен, то всего лишь на все только первый экземпляр или последний экземпляр, вот его больше не будет. Вот такой Protection тогда вставлен. Из других полезных методов есть метод SetAsync, который сохраняет объект просто по ключу. И еще одна из фишек, которая немножко неожиданная, это в том, что можно добавлять к записям теги. Теги - это удобный способ сгруппировать несколько записей для того, чтобы с ними, например, что-то потом сделать. Допустим, третий метод - это RemoveAsync. Он может удалять объект из кэша по ключу. В общем, но кроме как по ключу, есть метод RemoveByTagAsync, который может удалить объект, допустим, по тегу. Тоже, наверное, может быть полезно. Из интересного. Казалось бы, этот класс, эта библиотечка должна была зарелизаться вместе с .NET 9. То есть, у него там первая версия - это .NET 9 Preview, но .NET 9 уже давно зарелижен. А если вы сейчас посмотрите, например, в репозитории, то мы там можем увидеть библиотеку с версией 9.0 Preview, 9.1 Preview, 9.2 Preview. В общем, пока они почему-то держатся в превьюшках. В общем, довольно странная, интересная концепция. Интересно, что там происходит. И у нас как раз в студии чисто случайно пробегал и зашел автор данной статьи - Андрей Порожняков. Сейчас мы его и расспросим, что у нас к релизу такого готовится. Андрей, привет! Привет! Отлично у тебя статья получилась, но тут уже на дворе почти конец февраля. Статья от середины-начала января, а до сих пор релиза нет. Как ты думаешь, что они там такого готовят или что там такого припасут, что до сих пор никак не могут зарелизиться?
1093.32 1129.88 "Анатолий Кулаков" Ну, я не берусь делать точные прогнозы по датам и, собственно, каких-то точных прогнозов здесь вообще, наверное, никто не сделает. Когда оно выйдет, выйдет ли оно вообще. Но я готов просуждать на тему того, что я бы ожидал, видеть в стабильной версии, ну или что не ожидал бы. Начну, наверное, как раз со второго, то есть каких изменений я бы не ожидал видеть. Я бы не ожидал изменений состава методов, вот текущие методы, какие есть в Hybrid Cache объекте и их сигнатуры. Они не меняются, уже много версий, то есть выходят прирелизные версии, одна за другой.
1129.88 1276.64 "Анатолий Кулаков" Статья, написанная версия, она уже не финальная, но сигнатуры не меняются, то есть как будто бы вот это устаканилось. Ну и более того, там не такой уж сложный API, чтобы зачем-то менять сигнатуры, согласен. То есть это довольно простой API, он довольно в частых, ну в разных библиотеках встречается и там, как ты правильно заметил, как бы одного метода достаточно вообще, чтобы работать со всем классом. Ну, в целом, да, да. Тут, скорее всего, вот я каких-то изменений не предвижу. Вот. А какие изменения я бы ожидал? Ну, во-первых, в статье написано, что удаление по тегам пока еще не реализовано. Оно было действительно не реализовано на момент выхода статьи, сейчас оно уже реализовано в более поздних прирелизных версиях. Вот. Поэтому, ну, это точно уже войдет в релиз, то есть не будет там какого-то пустого метода, который ничего не делает. Вот. Ну и я, наверное, не удивлюсь, если в релизе изменится логика работы с тегами в целом. Может быть, она изменится, может быть, нет. Сейчас она не очевидна, может быть, для многих. Потому что, ну, приведем пример. Если вызвать метод getOrCreate и передать туда, он принимает не только ключ, но и позволяет кэшируемому объекту какие-то теги еще присвоить, хоть набор тегов. Вот. И если сейчас мы этот метод вызовем, передадим туда хоть ключ, передадим туда тег a там и тег b условно, допустим, объекта у нас не было в кэше, то есть он будет извлечен из хранилища, добавлен в кэш, ему будет присвоен ключ, теги, все хорошо. Потом мы вызываем этот же метод для этого же объекта с таким же ключом, но с другим набором тегов. Объект уже есть в кэше. И вот здесь не очень понятно, что должно с ним произойти. У него должны измениться теги или нет. Сейчас они не меняются. Вот. Но мне кажется, эта логика не очень очевидна для тех, кто будет этим пользоваться. Поэтому посмотрим. Вот. А так, да, каких-то более глобальных изменений я уже не жду. Угу. Ну вообще теги это, конечно, очень полезная такая штука, но довольно специфическая. Поэтому мне кажется, первую версию они вообще могли бы зарелизить без тегов, а потом в каком-нибудь 1.1 там уже бы навернули чего-нибудь. Ну, мне кажется, они на будущее такой задел делают, потому что они не хотят потом уже сигнатуру менять. Они сразу запихнули все, что может, в принципе, понадобиться в перспективе. А так, да, там с тегами много неочевидных моментов есть. Поэтому, наверное, пока это все не устаканится, можно и без тегов ходить.
1276.64 1287.12 "Анатолий Кулаков" Отлично. Так, большое спасибо тебе за комментарий. Все, отличная статья. Пиши еще. И спасибо за то, что записался к нам в студию. Давай, пока, до новых встреч.
1287.12 1309.20 "Анатолий Кулаков" Спасибо, спасибо. Ну вот, вот такой интересный и полезный классик, я думаю, в новых проектах, где мне приходилось раньше метаться перед выбором дистрибьютед кэша или локального кэша, и потом реализовать, несмотря на все метания, реализовать то же самое гибрид кэша ручками, я теперь буду использовать именно вот этот. Удобный и хороший классик.
1309.20 1323.12 "Игорь Лабутин" Ну, да, тем более. Хоть и альфа, альфа превью, непонятно что, но поглядим. Может быть, к релизу как студию зарелизят, скоро без всех этих сусек.
1323.12 1339.16 "Игорь Лабутин" Зарелизили в студию. Ну вот, я имею ввиду, как студию, в смысле, внезапно, не дожидаясь официального дотнет десятого, то есть, может быть, гибрид кэш, и не обязательно ждать десятого дотнета, может, раньше сделают финально.
1339.16 1343.30 "Анатолий Кулаков" Ну, будем надеяться, будем надеяться. Классик хороший, классик удобный, это нужно.
1343.30 1345.40 "Игорь Лабутин" Да, можно и превью использовать, что такого.
1345.40 1350.48 "Анатолий Кулаков" А можно и использовать вот этот заменитель, который я говорил, в принципе, тоже нормально пойдет.
1350.48 1355.00 "Игорь Лабутин" Так, погнали дальше. Дальше у нас статейка от Сергея Теплякова.
1355.00 1360.44 "Игорь Лабутин" Статья про давно нами не обсуждаемую штуку, про Sync Void.
1360.44 1367.24 "Игорь Лабутин" Сергей решил напомнить, что же такого плохого в Sync Void, и как он к этому пришел.
1367.24 1371.56 "Игорь Лабутин" Значит, почему он внезапно решил вспомнить про такую штуку?
1371.56 1374.32 "Игорь Лабутин" Видимо, потому что наткнулся на проблему в коде с ней.
1374.32 1391.32 "Игорь Лабутин" И как раз таки в статье он рассказывает, что, ну, смотрите, наверняка многие разработчики слышали, что что-то там не то с Sync Void, надо этого избегать, но мало кто помнит и может объяснить, зачем и почему, почему же такое поверье, почему надо избегать, чем Sync Void плохи.
1391.32 1393.40 "Игорь Лабутин" И когда же все-таки их нужно использовать.
1393.40 1414.24 "Игорь Лабутин" Для примера, для иллюстрации он приводит некоторую, простой кусочек кода, это Sync Void функция, которая принимает cancellation токен, ну, как положено, там, функции хорошей, и внутри делает простую штуку await task.delay от timespan 5-секундного и передает тоже токен.
1414.24 1424.88 "Игорь Лабутин" То есть, в общем, идея понятная, есть некая функция, она единственное, что сейчас делает, это просто spit 5 секунд, но можно по переданному токену, если ее канцельнуть, ну, типа, вроде как она должна канцельнуться.
1424.88 1426.88 "Игорь Лабутин" Логичный дизайн, ну, вроде логичный.
1426.88 1430.12 "Игорь Лабутин" Плюс-минус рекомендованный способ написания кода в дотнете.
1430.12 1445.44 "Игорь Лабутин" Проблема с этой функцией заключается в том, что она как бы опасна, как он пишет, it's kind of dangerous, вот, и не просто it's kind of dangerous, а your application might crash kind of dangerous.
1445.44 1450.28 "Игорь Лабутин" Ну, смысл в том, что произойдет, если ваша функция выполнится целиком?
1450.28 1463.96 "Игорь Лабутин" Ну, ничего не произойдет, собственно, она нормально выполнится, 5 секунд по спит, и на этом все закончится, но вот если вы заканцелите токен до того, как пройдут эти 5 секунд, то ваше приложение тупо крышнется целиком, полностью, совсем.
1463.96 1474.88 "Игорь Лабутин" С unhandled exception про task cancelled, про то, что вообще-то что-то там это нельзя, плохо и все такое.
1474.88 1476.88 "Игорь Лабутин" Что же происходит под капотом?
1476.88 1484.04 "Игорь Лабутин" Вот как раз на этом примере Сергей предлагает разобраться, почему так происходит, и почему же как бы считается, что Async/Void использует плохо.
1484.04 1487.88 "Игорь Лабутин" Напомним, что такое Async-функция.
1487.88 1507.68 "Игорь Лабутин" Async-функция - это синтаксический сахар-компилятор, который внутри, в момент компиляции C# кода, преобразует всю эту конструкцию в интересный класс, по сути, который является state-машиной, и каждое состояние этой машины - это, по сути, кусочек, блок вашего кода между evades.
1507.68 1514.24 "Игорь Лабутин" То есть вот все то, что если у вас один evade внутри функции, то значит у вас будет два блока кода и два состояния.
1514.24 1520.60 "Игорь Лабутин" Ну, технические состояния на самом деле больше, типа там не на чита выполняться, выполнен первый блок кода, выполнен последний блок кода.
1520.60 1523.12 "Игорь Лабутин" Если evade больше, соответственно, больше состояний.
1523.12 1542.64 "Игорь Лабутин" И разница ключевая между функцией, которая возвращает AsyncTask, или функцией, которая является Async/Void заключается в том, что какой метод внутри используется, в смысле, какой тип вот этой вот state-машинки используется для ее создания.
1542.64 1547.88 "Игорь Лабутин" Соответственно, для создания state-машинки для Async/Void используется Async/Void метод Builder.
1547.88 1551.44 "Игорь Лабутин" Если вам интересно, можно его найти в исходниках и почитать его.
1551.44 1565.64 "Игорь Лабутин" Но смысл в том, что самое главное, что в итоге получается в результате этого билдера, получается сгенерирована state-машинка, у которой есть замечательный метод под названием MoveNext, который, собственно, и ответственен за то, чтобы выполнять ваш код.
1565.64 1579.96 "Игорь Лабутин" Если вы смотрели на call stack в Async коде, и если это не какая-нибудь Visual Studio или Rider, который красиво Async call stack схлопывает в нормальные вызовы, понимая, что такое MoveNext, то вы должны были видеть этот MoveNext, который делает простую штуку.
1579.96 1610.20 "Игорь Лабутин" Он берет текущее состояние, в зависимости от текущего состояния выполняет какой-то нужный код, и если он понимает, то есть он вызывает этот код, поскольку он должен на нем evade, он делает следующую штуку. Он говорит, что если task, который вернулся, он не completed, то в этом случае мы, соответственно, регистрируем callback из этой самой state-машинки про то, что типа, мол, позови меня, когда ты закомплетишься. Ну и, собственно, все.
1610.20 1624.04 "Игорь Лабутин" Если же evader вдруг completed по какой-то причине, а, например, он может быть completed в том плане, что его заканселили, то он попробует сказать getResult.
1624.04 1632.72 "Игорь Лабутин" Ну и, соответственно, если сказать getResult на заканселенной task, то она, естественно, кинет task.canceledException.
1632.72 1648.32 "Игорь Лабутин" И все было бы хорошо, но проблема заключается в том, что это исключение даже поймается, оно все написано в try/catch, но единственное, куда оно пробросится, оно сделает builder.setException, и надо этот exception куда-то сохранить.
1648.32 1655.20 "Игорь Лабутин" Ну вот, по сути, у вас любой await, любой вызов может кинуть exception, ну и, соответственно, надо его куда-то сохранить.
1655.20 1659.44 "Игорь Лабутин" Куда же его сохранить? setException делает простую штуку.
1659.44 1684.12 "Игорь Лабутин" Она смотрит, находимся ли мы сейчас в каком-нибудь synchronization-контексте с большой долей вероятностью, если вы сейчас не занимаетесь программированием UI, ну или, как мы выясняли и много раз упоминали уже в подкастах, в тестах, хотя я не помню, кстати, в последнем XUnit они в итоге отказались от synchronization-контекста, который полностью переписанный.
1684.12 1685.48 "Анатолий Кулаков" Надо перепроверить.
1685.48 1687.48 "Игорь Лабутин" Вот я что-то не помню.
1687.48 1692.36 "Игорь Лабутин" Мы, по-моему, этого не обсуждали, когда обсуждали ревиз последнего XUnit, который долгожданный был.
1692.36 1698.68 "Игорь Лабутин" Вот я не помню, остался ли там synchronization-контекст, но в целом в среднем synchronization-контекст встречается обычно только в UI-программировании.
1698.68 1701.08 "Игорь Лабутин" В современном мире.
1701.08 1709.44 "Игорь Лабутин" Если он есть, то в него закинется, и тогда, соответственно, synchronization-контекст будет думать, что с этим exception делать.
1709.44 1712.72 "Игорь Лабутин" Но в обычной жизни он сделает простую штуку.
1712.72 1716.56 "Игорь Лабутин" Он тупо говорит, окинь, пожалуйста, exception.
1716.56 1720.80 "Игорь Лабутин" Он scheduled exception, чтобы быть выкинутым просто в thread pool'е.
1720.80 1732.60 "Игорь Лабутин" На каком-нибудь потоке он просто тупо кинет этот exception, и если у вас не зарегистрирован то, что называется legacy exception handler, ну тогда у вас будет, собственно, полный crash всего приложения.
1732.60 1749.56 "Игорь Лабутин" То есть можно в конфиге вашем, в файлике конфига, написать специальный флажочек, что надо, там use legacy exception handler, по-моему, это называется, и потом там правильно прописать, и тогда, по-моему, приложение падать не будет.
1749.56 1758.04 "Игорь Лабутин" Но современное поведение .NET заключается в том, что если такой exception, unobserved exception, что называется, кидается, то приложение завершается.
1758.04 1761.68 "Игорь Лабутин" И, собственно, здесь заключается разница между async_void и async_task.
1761.68 1771.92 "Игорь Лабутин" То есть единственная в чем здесь возникает проблема, это в том, что если у вас есть async_void, то вот этот exception, с ним ничего нельзя сделать, кроме как выкинуть.
1771.92 1784.24 "Игорь Лабутин" То есть его можно полностью игнорировать, но тогда вы уже, будьте добры, сами пишите try-catch, который все ловит и exception никуда не перекидывает, глобальный такой вокруг вашей, внутри вашей async_void функции.
1784.24 1787.64 "Игорь Лабутин" Либо его сложить некуда, и он будет выкинут и приведет к падению программы.
1787.64 1795.68 "Игорь Лабутин" А вот если бы функция была async_task, то такой exception сложился бы в task, который рождается в результате выполнения вашей функции.
1795.68 1812.36 "Игорь Лабутин" И дальше, ну, понятно, что дальше возникает вопрос, что в этом task останется exception, если вы, например, wait на этой функции не делаете, то вроде как exception по сути потерян, то есть он лежит в task, а его никто не посмотрел, не заобзервал, так скажем.
1812.36 1856.32 "Игорь Лабутин" Тут может сработать другая логика, про то, что если такой task доберется до dispose'а, а точнее до финализации, то есть если финализатор зайдет в task и увидит там необработанный exception, который не вызывали, то есть, грубо говоря, если вы в task запихнете exception, ни разу не вызовете, по-моему, то ли get_result, то ли get_exception, ну, короче, любую функцию, которая проверяет состояние task'а, то финализатор в момент, когда он доберется до финализации такого task'а, кинет task_observed_exception и тоже грохнет программу, но все-таки, как правило, мы те функции, которые возвращают async task, мы хоть как-то либо выйдем, либо проверяем их результат, либо хоть что-то происходит с ними, поэтому там task не потеряется.
1856.32 1874.32 "Игорь Лабутин" Ну и единственный кейс, когда эти async-voids могут быть полезны, это как раз-таки UI-фреймворки, но там как раз есть synchronization-контекст, который позаботится обычно о том, что все такие странные exceptions, которые вылетают из непонятных мест, все-таки как-то более-менее глобально обработать.
1874.32 1881.20 "Игорь Лабутин" Вот, такие дела, это такое напоминание про то, во что у нас разворачиваются async-методы.
1881.20 1922.44 "Игорь Лабутин" Пока, во всяком случае, напомню, что у нас есть работа какая-то в рантайме, около рантайма ведется работа над фичой под кодовым названием async2, которая пока непонятно войдет, не войдет и вообще в каком она сейчас состоянии находится, я давно за ней не следил, по поводу того, чтобы перенести всю эту магию генерации стейт-машины из C#-компилятора, то есть не генерить код на C#, который реализует разбиение на блоке async-функции и переход между состояниями, а отдать это ноутку в g2 и делать это в рантайме уже в g2, на уровне машинного кода.
1922.44 1935.64 "Игорь Лабутин" Ну, посмотрим, но я думаю, что принципиально логика не изменится, это будет всё такая же ситуация, поэтому, если вы пишете async void, дважды-трижды подумайте, надо ли вам это, хотя иногда очень хочется, да.
1935.64 1937.56 "Игорь Лабутин" Такие дела?
1937.56 1942.36 "Анатолий Кулаков" Да нет, ну слушай, я после того, как он слез с юрных приложений, мне ни разу не хотелось.
1942.36 1946.96 "Игорь Лабутин" Ну, кто-то может быть, не знаю, может почему-то хочется.
1946.96 1960.44 "Игорь Лабутин" Ну вот, типа, асинк там, пишешь там, типа, тебе начинают писать какие-нибудь вординги про то, что вот, у вас есть асинк что-нибудь, а вы его не выйдете, там вот это всё, ну, короче, начинается.
1960.44 1961.92 "Игорь Лабутин" А ты выйди.
1961.92 1968.76 "Игорь Лабутин" Вот, а ты выйдешь, а потом надо результаты выйдеть, и вот у тебя весь код в асинках, короче, неудобно.
1968.76 1970.12 "Анатолий Кулаков" Такие дела.
1970.12 1990.96 "Анатолий Кулаков" Ну, у меня, кстати, для тебя есть решение, вот как раз весь код в асинках, как правильно сделать таски, чтобы они были без async-void и так далее, всё это, на самом деле, в принципе, вопросы, которыми задаются многие годы уже многие светлые умы человечества, и кое-что они придумали, а придумали они систему эффектов.
1990.96 1995.68 "Игорь Лабутин" Мы сейчас пойдём какой-нибудь супертеоретический пейпер обсуждать?
1995.68 2003.36 "Анатолий Кулаков" Ну, как теоретический, под любым хорошим практическим примером всегда лежали теоретические расклады.
2003.36 2008.44 "Анатолий Кулаков" В общем, мы сейчас немножко познакомимся с теоретической концепцией, а потом натянем её на практику.
2008.44 2015.12 "Игорь Лабутин" Ну, давай, звучит интересно. Системы эффектов в C# я как-то их не встречал вместе.
2015.12 2019.00 "Анатолий Кулаков" Вот, давайте, наконец, познакомимся, немножко разомнём свой мозг.
2019.00 2042.24 "Анатолий Кулаков" Мы, наверное, все с вами привыкли, что в C# все мега языковые крутые фичи появляются одними из первых, там, не знаю, expressions, links, async-void, в общем, в C# богат на такие открытия, и самое, наверное, экстравагантное, ожидаемое, что мы надеемся увидеть последние несколько релизов, это Discrimination Union, но, как вы понимаете, Discrimination Union как бы есть в любом уважающемся биофункциональном языке программирования.
2042.24 2049.20 "Анатолий Кулаков" А о чём таком бы можно было помечтать, что прям вот вообще на переднем крае разработки языков программирования?
2049.20 2060.44 "Анатолий Кулаков" Вот сейчас на переднем крае разработки языков программирования лучшему человечеству экспериментирует такой штука, как система эффектов, она же алгебраические эффекты.
2060.44 2088.08 "Анатолий Кулаков" Это интересная такая специальная мощная концепция языка, с помощью которых вы можете выразить очень-очень много всего, такая довольно абстрактная абстракция, которая покрывает собой, например, и Dependency Injection, и Consolation в тасках, типа отмену, и Debug Tracing, и можно с помощью неё Continuation делать, и кэширование прозрачное для приложения незаметно делать, и сайд-эффекты творить, в общем, кучу-кучу всего.
2088.08 2103.12 "Анатолий Кулаков" Вот, поэтому давайте потихонечку попробуем разобраться, а что же такое система эффектов, как она работает, и вот, наверное, из этого мы поймём, что с помощью неё можно сделать, и какие плюсы она могла бы принести в наш язык программирования.
2103.12 2116.40 "Анатолий Кулаков" Начнём с простого примера. Допустим, у нас есть какой-то класс пользователя, и у этого класса пользователя есть метод GetName, который получает имя у этого пользователя. В качестве параметра этот метод принимает юзера.
2116.40 2128.40 "Анатолий Кулаков" У юзера есть свойство name, это свойство нулябельное, и метод всего лишь навсего берёт это свойство name, проверяет, если name, взятый им, равен null, он бросает exception.
2128.40 2134.88 "Анатолий Кулаков" Если он не null, то тогда возвращает просто из метода name, то есть обычную ненулябельную строку.
2134.88 2141.40 "Анатолий Кулаков" Вот, кажется, да, элементарный простой метод - получить имя. Что в этом методе интересного?
2141.40 2146.40 "Анатолий Кулаков" Интересно, что он бросает exception, когда, допустим, имя неизвестно, имя равно null.
2146.40 2158.40 "Анатолий Кулаков" В общем случае, программист что должен делать? Он должен где-нибудь там вверху, при вызове этого метода GetName, поставить try/catch и обработать вот этот exception. Ну, что можем делать?
2158.40 2163.40 "Анатолий Кулаков" Ну, в нашем случае мы можем просто в log вывести надпись, что имя отсутствует.
2163.40 2169.40 "Анатолий Кулаков" Вот, теперь немножко разберёмся, вспомним, как работают exceptions.
2169.40 2171.40 "Анатолий Кулаков" В общем, это очень важно для нашей концепции.
2171.40 2180.40 "Анатолий Кулаков" Смотрите, у exceptions есть довольно интересные свойства, которые, в принципе, не встречаются ни в одной конструкции языка.
2180.40 2193.40 "Анатолий Кулаков" Когда вы бросаете исключение из метода GetName, это исключение всплывает, минуя все промежуточные методы, всплывает до ближайшего try/catch.
2193.40 2198.40 "Анатолий Кулаков" И вот только в ближайшем try/catch оно каким-то образом обрабатывается.
2198.40 2212.40 "Анатолий Кулаков" Для нас очень важная концепция в том, что весь промежуточный код, то есть внутри try/catch мы с этим юзером могли отправлять ему, например, какой-то email, и только этот email будет доставать имя этого пользователя.
2212.40 2221.40 "Анатолий Кулаков" Но отправка самого email она никаким образом не узнает про то, что было выброшено исключение, если, естественно, она не поставила try/catch.
2221.40 2230.40 "Анатолий Кулаков" И вот эта информация об исключении, она просто игнорирует все эти промежуточные слои и падает в ближайший try/catch.
2230.40 2235.40 "Анатолий Кулаков" Как только мы попали в try/catch, там мы уже можем что-то сделать с нашим исключением.
2235.40 2238.40 "Анатолий Кулаков" Допустим, его залогировать и как-то обработать.
2238.40 2246.40 "Анатолий Кулаков" Но если мы берем стандартную конструкцию, мы, например, не можем вернуться обратно в тот код, который выбросил исключение.
2246.40 2264.40 "Анатолий Кулаков" Например, мы могли бы в try/catch подставить значение этого имени пользователя по дефолту, например, какой-нибудь default_user, и вернуть управление тому коду, который бросил исключение, и сказать ему, чувак, не бросай исключение, вот тебе дефолтное имя пользователя, продолжай работу с ним дальше.
2264.40 2273.40 "Анатолий Кулаков" Да, мы можем это каким-то образом симулировать, установить этому пользователю имя, потом сделать retry и снова пройти весь этот цикл, но это немножко не то.
2273.40 2278.40 "Анатолий Кулаков" Хотелось бы вернуться прямо в тот код управления, но try/catch, естественно, этого не позволяет сделать.
2278.40 2281.40 "Анатолий Кулаков" А вот алгебраические эффекты позволяют.
2281.40 2285.40 "Анатолий Кулаков" Они как раз могут проделать такие штуки.
2285.40 2293.40 "Анатолий Кулаков" Давайте немножко переделаем наш бросание исключения и try/catch блоки следующим образом.
2293.40 2301.40 "Анатолий Кулаков" Вместо throw, который бросает exception, выдумаем гипотетическое слово perform, которое будет запускать некий эффект.
2301.40 2308.40 "Анатолий Кулаков" И вместо try/catch, выдумаем конструкцию, которая называется try_handle, которая будет этот эффект обрабатывать.
2308.40 2318.40 "Анатолий Кулаков" То есть запуск эффекта, запуск обработки эффекта, вы можете сравнить примерно с throw, но не считайте, что это какое-то исключение.
2318.40 2329.40 "Анатолий Кулаков" Это просто передача управления какому-то специальному блоку, какому-то специальному try_handle, который знает, как это значение обрабатывать.
2329.40 2337.40 "Анатолий Кулаков" И в отличие от try/catch стандартного, этот блок может еще вернуть управление.
2337.40 2350.40 "Анатолий Кулаков" То есть он может обработать то исключение, которое его попросили, тот эффект, который его попросили, вычислить какой-то результат и вернуть его обратно тому методу, который вызвал этот эффект.
2350.40 2353.40 "Анатолий Кулаков" Итак, что же мы в конце концов имеем?
2353.40 2363.40 "Анатолий Кулаков" У нас есть метод perform, который запускает эффект, есть метод handle, который этот эффект обрабатывает и возвращает обратно, передавая из хендлера какое-то значение.
2363.40 2372.40 "Анатолий Кулаков" И таким образом мы получаем recoverable errors, то есть ошибки, которые могут сами себя восстанавливать.
2372.40 2387.40 "Анатолий Кулаков" Если у нас случилось какое-то exception, если случилась какая-то ошибка, мы можем где-то наверху попытаться исправить код, попытаться дать те значения, которых не хватает, попытаться что-то еще сделать и вернуть управление, продолжив выполнять программу с той же самой позиции, где она закончила.
2387.40 2394.40 "Анатолий Кулаков" Но это самый очевидный и примитивный способ использования системы эффектов.
2394.40 2398.40 "Анатолий Кулаков" Хотя бы recoverable errors на ней сделать можно.
2398.40 2401.40 "Анатолий Кулаков" Какими же еще свойствами обладает система эффектов?
2401.40 2404.40 "Анатолий Кулаков" Система эффектов, чтобы вы понимали, это примерно вот это взаимодействие.
2404.40 2416.40 "Анатолий Кулаков" То есть в каком-то блоке мы вызываем эффект, этот эффект обрабатывается где-то в другом месте, допустим в том же тройке, где-то наверху блока, и возвращается результат обратно в тот блок.
2416.40 2418.40 "Анатолий Кулаков" Немножко нелинейная такая позиция.
2418.40 2427.40 "Анатолий Кулаков" У нас это может напоминать чем-то flow на exceptions, или может быть даже оператор go to вам как-то может напомнить, который умеет возвращаться обратно.
2427.40 2429.40 "Анатолий Кулаков" Вот немножко это похоже на такую штуку.
2429.40 2436.40 "Анатолий Кулаков" Но кроме очевидных как бы минусов оператора go to, у этой системы эффектов есть еще и много плюсов.
2436.40 2443.40 "Анатолий Кулаков" Например, одним из самых главных плюсов для нас может служить в том, что система эффектов позволяет избавиться от цветных функций.
2443.40 2449.40 "Анатолий Кулаков" Я кратко напомню, что термин цветные функции используется как раз для async/await.
2449.40 2452.40 "Анатолий Кулаков" И обозначает ту проблему, о которой мы немножко упоминали ранее.
2452.40 2462.40 "Анатолий Кулаков" Когда у вас есть какой-то метод, который был совсем не асинхронный, он, допустим, вычислял какое-то рандомное имя.
2462.40 2469.40 "Анатолий Кулаков" И этот метод почему-то в процессе эволюции, в процессе рефакторинга мы решили сделать асинхронным.
2469.40 2476.40 "Анатолий Кулаков" Как только мы решили сделать его асинхронным, например, он не вычисляет уже рандомное имя, а ходит за этим рандомным именем в базу данных.
2476.40 2482.40 "Анатолий Кулаков" Как только мы решили сделать его асинхронным, мы обязаны его сигнатуру сделать асинхронной.
2482.40 2488.40 "Анатолий Кулаков" И все цепочки вызовов, которые вызывают этот метод, они теперь тоже обязаны быть асинхронными.
2488.40 2491.40 "Анатолий Кулаков" То есть, они, все эти методы, грубо говоря, покрасились.
2491.40 2494.40 "Анатолий Кулаков" Они раньше были одного цвета, а теперь стали совсем другого цвета.
2494.40 2497.40 "Анатолий Кулаков" И, казалось бы, ничего не поменялось-то.
2497.40 2499.40 "Анатолий Кулаков" Зачем? Почему? За что?
2499.40 2502.40 "Анатолий Кулаков" Мы как раньше вызывали этот метод, так и раньше хотим его вызывать.
2502.40 2513.40 "Анатолий Кулаков" Но нет, к сожалению, вот это инфицирование, инфицирование асинк-функций, оно пролетает через все наши приложения и вот таким образом инфицирует все методы.
2513.40 2522.40 "Анатолий Кулаков" Ну так вот, у системы эффектов один из интересных фишек это в том, что она позволяет не инфицировать вызывальщиков.
2522.40 2542.40 "Анатолий Кулаков" То есть, в нашем случае, если, допустим, мы захотим вызвать обработку системы эффектов, и при этом этот обработчик будет асинхронным, то тот класс, который вызывает этот эффект, он не должен становиться асинхронным.
2542.40 2545.40 "Анатолий Кулаков" Он может продолжать быть асинхронным.
2545.40 2546.40 "Анатолий Кулаков" Ничего от этого не сломается.
2546.40 2551.40 "Анатолий Кулаков" Уже в саму конструкцию системы эффектов это включено.
2551.40 2558.40 "Анатолий Кулаков" То есть, мы избавляемся от этих цветных функций, функций заражающих, все подряд, или как угодно их можно там называть.
2558.40 2564.40 "Анатолий Кулаков" Еще один минус от вот этого заражения, это в том, что у вас, по сути, начинают протекать абстракции.
2564.40 2571.40 "Анатолий Кулаков" То есть, как только у вас метод getName становится асинхронным, вы понимаете, какая у него внутри имплементация.
2571.40 2583.40 "Анатолий Кулаков" А имплементация у него внутри такая, что он, скорее всего, будет ходить к какой-нибудь AOCompletion системе, то есть к какой-нибудь файловой системе, или к базе данных, или в сеть, или еще куда-то, раз он стал асинхронным.
2583.40 2585.40 "Анатолий Кулаков" Это раскрывает уже имплементацию.
2585.40 2587.40 "Анатолий Кулаков" Та же самая штука у нас происходит в интерфейсах.
2587.40 2590.40 "Анатолий Кулаков" Мы настолько к этому привыкли, что никогда об этом даже не задумываемся.
2590.40 2601.40 "Анатолий Кулаков" Когда мы делаем в интерфейсах метод saveAsync, мы автоматически понимаем, что этот save пойдет куда-нибудь на диск, или в базу данных, или в сеть, для того, чтобы нам сохранить этот объект.
2601.40 2609.40 "Анатолий Кулаков" На самом деле, мы не должны по интерфейсу были бы догадываться, а какая у него имплементация, а как он пойдет сохранять, а что он там пойдет делать.
2609.40 2611.40 "Анатолий Кулаков" Это должен был быть просто метод save и все.
2611.40 2616.40 "Анатолий Кулаков" Хочет он внутри себя ходить куда-то в базу, пусть ходит, но сигнатура об этом ничего не должна знать.
2616.40 2622.40 "Анатолий Кулаков" К сожалению, в C# сигнатура всегда об этом знает из-за асинхронных светных функций.
2622.40 2625.40 "Анатолий Кулаков" Именно поэтому это еще и протекающая абстракция.
2625.40 2631.40 "Анатолий Кулаков" Так вот, система эффектов помогает нам избавиться от этой протекающей абстракции, что, безусловно, прекрасно.
2631.40 2643.40 "Анатолий Кулаков" Также, в отличие от, например, наших async/await, которые обязаны красить цепочку вызовов, система эффектов, как я уже говорил, она похожа на exception этим.
2643.40 2646.40 "Анатолий Кулаков" Она не красит промежуточные слои.
2646.40 2650.40 "Анатолий Кулаков" То есть промежуточные слои ничего не знают о том, что там случился какой-то эффект.
2650.40 2657.40 "Анатолий Кулаков" Об эффекте знает тот код, который вызвал эффект, и тот хендлер, который этот эффект для него обработал.
2657.40 2659.40 "Анатолий Кулаков" Все, что было посередине, без понятия.
2659.40 2669.40 "Анатолий Кулаков" Если вы хотели вычислять или доставать имя, и захотели вы теперь вычислять его из базы данных, то об этом никто не узнает, кроме хендлера, который вынужден стать асинхронным.
2669.40 2673.40 "Анатолий Кулаков" Но сам перформер, который запускает систему эффектов, он останется асинхронным.
2673.40 2676.40 "Анатолий Кулаков" И весь код, который его вызывает, останется асинхронным.
2676.40 2679.40 "Анатолий Кулаков" В общем, и это большая прелесть.
2679.40 2682.40 "Анатолий Кулаков" Так, порассуждаем немножко о чистоте функций.
2682.40 2690.40 "Анатолий Кулаков" Как вы уже, наверное, поняли, что вот эта вся система эффектов, она пришла из лабораторий по исследованию функциональных языков программирования.
2690.40 2703.40 "Анатолий Кулаков" Ну, вообще, наверное, практически все новомодные вещи, которые мы имеем сейчас в современных языках программирования, приходят вот оттуда, из функциональных языков, которые начинают там работать с математикой, какими-то абстракциями страшными и так далее.
2703.40 2706.40 "Анатолий Кулаков" И вот система эффектов - это не исключение.
2706.40 2714.40 "Анатолий Кулаков" И для примера, например, есть у нас такой интересный язык, как Haskell, где не очень поощряется неявный вызов сайд-эффектов.
2714.40 2719.40 "Анатолий Кулаков" Все сайд-эффекты должны быть там явными, специально обозначенными, обернутыми и так далее.
2719.40 2725.40 "Анатолий Кулаков" И для того, чтобы хоть как-то с этими сайд-эффектами работать, используется так называемый подход Монады.
2725.40 2735.40 "Анатолий Кулаков" Если вы пытались как-то папер читать по Монадам, то вы знаете, что это немножко такая довольно странная, не всем очевидная, не очевидно понятная концепция.
2735.40 2742.40 "Анатолий Кулаков" Например, XHRP ее еще разложить можно, наверное, вдолбить кому-то в голову можно, но все-таки не самая прямая вещь.
2742.40 2750.40 "Анатолий Кулаков" Ну так вот, как раз система эффектов позволяет вам делать практически то же самое, что и Монады, но более понятно.
2750.40 2757.40 "Анатолий Кулаков" С меньшим количеством условий, проблем, названий вот таких вот страшных и так далее.
2757.40 2768.40 "Анатолий Кулаков" В общем, мы с помощью вот этих систем эффектов можем точно так же разделить input-output операции от обычного кода.
2768.40 2772.40 "Анатолий Кулаков" Это еще одно свойство системы эффектов, она декларативна.
2772.40 2777.40 "Анатолий Кулаков" То есть все эти эффекты разделяют код на две части.
2777.40 2783.40 "Анатолий Кулаков" Одна часть отвечает, что мы будем делать, а вторая, как мы будем это делать.
2783.40 2787.40 "Анатолий Кулаков" Вот обычный код оперативный, когда мы выполняем, он отвечает, что мы будем делать.
2787.40 2793.40 "Анатолий Кулаков" Давайте представим стандартную процедуру перебора всех файлов в директории.
2793.40 2795.40 "Анатолий Кулаков" Что мы хотим сделать?
2795.40 2798.40 "Анатолий Кулаков" Во-первых, мы хотим открыть директорию, допустим, для перебора.
2798.40 2803.40 "Анатолий Кулаков" Дальше мы хотим залогировать название директории.
2803.40 2806.40 "Анатолий Кулаков" После этого мы хотим побежаться по всем файлам и обработать файл.
2806.40 2814.40 "Анатолий Кулаков" Если мы встретили директорию, мы хотим снова рекурсивно запустить наш метод обхода директории.
2814.40 2815.40 "Анатолий Кулаков" Что мы здесь имеем?
2815.40 2821.40 "Анатолий Кулаков" Здесь мы имеем несколько эффектов, которые позволяют нам как раз-таки и отгородить код.
2821.40 2822.40 "Анатолий Кулаков" Что от кода как?
2822.40 2823.40 "Анатолий Кулаков" Например, код что?
2823.40 2825.40 "Анатолий Кулаков" Открыть директорию.
2825.40 2826.40 "Анатолий Кулаков" Это можно сделать в виде эффекта.
2826.40 2830.40 "Анатолий Кулаков" То есть мы perform open directory, запускаем эффект открытия директории.
2830.40 2831.40 "Анатолий Кулаков" Зачем мы это делаем?
2831.40 2835.40 "Анатолий Кулаков" А для того, чтобы определить, а что такое открытие директории, где-то там наверху.
2835.40 2838.40 "Анатолий Кулаков" И плюс это input-output операция.
2838.40 2842.40 "Анатолий Кулаков" Мы не хотим в нашем коде вымазывать себя input-output операциями.
2842.40 2844.40 "Анатолий Кулаков" Тем более она, скорее всего, должна быть асинхронной.
2844.40 2848.40 "Анатолий Кулаков" Мы не хотим в коде не сталкиваться ни с какой сетей асинхроничной.
2848.40 2852.40 "Анатолий Кулаков" Поэтому open directory - это вполне нормальная тема для эффекта.
2852.40 2853.40 "Анатолий Кулаков" Дальше.
2853.40 2854.40 "Анатолий Кулаков" Логирование.
2854.40 2857.40 "Анатолий Кулаков" Это тоже можно сделать с помощью эффектов.
2857.40 2858.40 "Анатолий Кулаков" perform log.
2858.40 2860.40 "Анатолий Кулаков" И запускает эффект логирования.
2860.40 2861.40 "Анатолий Кулаков" Почему?
2861.40 2863.40 "Анатолий Кулаков" Потому что log обязательно куда-то пишет, в какой-то журнал.
2863.40 2865.40 "Анатолий Кулаков" Это тоже какой-то side-эффект.
2865.40 2867.40 "Анатолий Кулаков" Это уже тоже могло бы сделать функцию нечистой.
2867.40 2870.40 "Анатолий Кулаков" А благодаря эффектам функция по-прежнему остается чистой.
2870.40 2871.40 "Анатолий Кулаков" Дальше опять же.
2871.40 2873.40 "Анатолий Кулаков" Бежим по файлам, обрабатываем файл.
2873.40 2876.40 "Анатолий Кулаков" Естественно, обработчик тоже может быть каким-нибудь асинхронным.
2876.40 2879.40 "Анатолий Кулаков" Например, что-то с ним файлом копировать или что-то делать.
2879.40 2882.40 "Анатолий Кулаков" Его тоже можно сделать с помощью системы эффектов.
2882.40 2886.40 "Анатолий Кулаков" Ну и самое интересное - это запуск рекурсивно этой же функции.
2886.40 2891.40 "Анатолий Кулаков" То есть мы из функции, которая использует эффекты, можем вызвать функцию, которая использует эффекты, в том числе саму себя.
2891.40 2896.40 "Анатолий Кулаков" То есть рекурсия здесь тоже поддерживается, что довольно прекрасно.
2896.40 2905.40 "Анатолий Кулаков" Итак, как вы уже поняли, мы можем разделить логику, которая выполняется.
2905.40 2907.40 "Анатолий Кулаков" То есть чистую функцию мы можем выделить.
2907.40 2910.40 "Анатолий Кулаков" Из нее выделить абсолютно все сайд-эффекты.
2910.40 2914.40 "Анатолий Кулаков" То есть как мы будем это делать, мы можем выделить отдельно в хендлеры.
2914.40 2921.40 "Анатолий Кулаков" И с хендлерами прекрасно то, что они довольно хорошо соединяются в какие-то композитные блоки.
2921.40 2924.40 "Анатолий Кулаков" То есть вы можете соединить несколько хендлеров.
2924.40 2927.40 "Анатолий Кулаков" Допустим, вы знаете, как обработать открытие директории.
2927.40 2928.40 "Анатолий Кулаков" Это какой-то один хендлер.
2928.40 2931.40 "Анатолий Кулаков" Вы знаете, как заимплементировать логирование.
2931.40 2932.40 "Анатолий Кулаков" Это какой-то другой хендлер.
2932.40 2935.40 "Анатолий Кулаков" Потом вы их можете объединить в какой-то контекст.
2935.40 2938.40 "Анатолий Кулаков" И у вас получается контекст со всеми хендлерами.
2938.40 2941.40 "Анатолий Кулаков" И этот контекст могут использовать различные программы.
2941.40 2945.40 "Анатолий Кулаков" То есть вызывая тот или иной эффект, ваши хендлеры способны его удовлетворить.
2945.40 2953.40 "Анатолий Кулаков" Интересно то, что подставив другой контекст с хендлерами тех же самых эффектов, мы можем полностью переписать программу.
2953.40 2959.40 "Анатолий Кулаков" Ну, например, в настоящей программе мы можем запускать настоящую файловую систему.
2959.40 2961.40 "Анатолий Кулаков" Мы можем запускать настоящее логирование.
2961.40 2972.40 "Анатолий Кулаков" А вот если мы программу тестируем, мы можем в качестве хендлера для Open Directory передать обработчик, который запускает in-memory какую-нибудь систему.
2972.40 2978.40 "Анатолий Кулаков" И лог, который он нас пишет, не будет писать на диск, а будет просто выводить в дебаг-консоль какой-нибудь сообщенец.
2978.40 2990.40 "Анатолий Кулаков" В общем, таким образом мы здесь подходим к тому, что вот этот набор контекстов, системы эффектов, он позволяет нам, допустим, очень хорошо и очень элегантно тестировать код.
2990.40 3004.40 "Анатолий Кулаков" Все те моки, которые мы сейчас вынуждены создавать, вынуждены для них писать какие-то специальные интерфейсы, которые никому не нужны, кроме этих моков, вот все вот эти моки, они исчезают, если мы переходим к системе эффектов.
3004.40 3009.40 "Анатолий Кулаков" Потому что все эффекты прекрасно заменяются с помощью вот этого контекста со всеми хендлерами.
3009.40 3016.40 "Анатолий Кулаков" И в зависимости от того, какой хендлеры вы туда подставите, именно такой эффект и сработает.
3016.40 3018.40 "Анатолий Кулаков" Именно это вы и получите в своей программе.
3018.40 3023.40 "Анатолий Кулаков" Подставите настоящую FileSystem, будь настоящей, подставите мок, она сработает как на моке.
3023.40 3029.40 "Анатолий Кулаков" Таким образом, тесты получаются элегантными, красивыми и без дурацких интерфейсов.
3029.40 3031.40 "Анатолий Кулаков" Что же такое система эффектов?
3031.40 3040.40 "Анатолий Кулаков" Давайте немножко подведем краткие итоги из того, что мы с вами обсудили, какими свойствами она обладает.
3040.40 3043.40 "Анатолий Кулаков" Прежде всего, она похожа на вызов какого-то метода.
3043.40 3056.40 "Анатолий Кулаков" То есть вы вызываете в любой строчке своего кода, вызываете метод запустить систему эффектов, можете передать в этот метод аргументы, и кто-то этот метод обработает.
3056.40 3057.40 "Анатолий Кулаков" В нашем случае это хендлеры.
3057.40 3067.40 "Анатолий Кулаков" Когда хендлеры отрабатывают этот метод, они могут учесть те аргументы, которые вы передали, и естественно вернуть вам какой-то результат.
3067.40 3072.40 "Анатолий Кулаков" То есть этим система эффектов довольно похожа на обычный вызов метода C#.
3072.40 3076.40 "Анатолий Кулаков" В метод передаются аргументы, метод возвращает вам результат.
3076.40 3078.40 "Анатолий Кулаков" Тут вроде все нормально.
3078.40 3082.40 "Анатолий Кулаков" Также система эффектов похожа на бросание исключения.
3082.40 3090.40 "Анатолий Кулаков" Прежде всего, она похожа тем, что не перетеряется, никак не аффектится вот этот промежуточный слой.
3090.40 3101.40 "Анатолий Кулаков" Между тем, как вы запустили систему эффектов, и между тем блоком, который эту систему эффектов отработает, все промежуточные методы ничего не знают о том, что внутри там существовали какие-то эффекты.
3101.40 3108.40 "Анатолий Кулаков" То есть мы избавляемся от вот этих осинковых слов, которые протаскивается цепочка через все наше приложение.
3108.40 3109.40 "Анатолий Кулаков" Дальше.
3109.40 3133.40 "Анатолий Кулаков" Система эффектов похожа на волшебного маляра, который как раз избавляет нас от цветных функций, который избавляет нас от необходимости вводить каскадные изменения, как только у нас какой-то метод в глубине стал асинхронным, и мы должны каскадом прокинуть все эти изменения наверх, и избавляет нас от протекающих абстракций, которые вынуждены в сигнатуре отражать синхронность или асинхронность метода.
3133.40 3138.40 "Анатолий Кулаков" Система эффектов очень похожа на атрибуты, потому что она является декларативной.
3138.40 3150.40 "Анатолий Кулаков" То есть существуют программы, которые могут проанализировать весь ваш код, и эти программы способны узнать, какие эффекты, например, есть в той или иной функции, в том или ином методе.
3150.40 3158.40 "Анатолий Кулаков" Благодаря этому анализу, вы можете применить ту или иную логику, принять какое-то решение именно в рантайме.
3158.40 3164.40 "Анатолий Кулаков" То есть вот эта система эффектов, она является непосредственно частью сигнатуры типа.
3164.40 3169.40 "Анатолий Кулаков" И так как она декларативная, она разделяет, что вы хотите делать и как вы хотите делать.
3169.40 3180.40 "Анатолий Кулаков" Поэтому программист определяет на этапе написания, что вы хотите сделать, а уже рантайм, например, может определить, а как это сделать, как открыть директорию, как прочитать файл, как залогировать метод.
3180.40 3184.40 "Анатолий Кулаков" Это можно решить динамически в рантайме или каким-то еще другим образом.
3184.40 3188.40 "Анатолий Кулаков" Именно этим система эффектов также похожа на DI-контейнер.
3188.40 3195.40 "Анатолий Кулаков" То есть у вас есть некий контекст зависимостей, вот этих хендлеров, которые удовлетворяют любые к нему вызовы.
3195.40 3204.40 "Анатолий Кулаков" И они позволяют вам менять вот эти зависимости, в зависимости, в менять зависимости, смотря где вы находитесь.
3204.40 3207.40 "Анатолий Кулаков" Например, если вы находитесь в продакшн среде, у вас будут одни зависимости.
3207.40 3209.40 "Анатолий Кулаков" В тестах у вас будут совсем другие зависимости.
3209.40 3212.40 "Анатолий Кулаков" То есть это немножко похоже на наш DI-контейнер.
3212.40 3222.40 "Анатолий Кулаков" В DI-контейнер мы тоже можем прийти с каким-то запросом, вроде, а ну-ка разрезал ли мне какой-то классик, который умеет доставать имя пользователя.
3222.40 3224.40 "Анатолий Кулаков" И вы получите сервис.
3224.40 3229.40 "Анатолий Кулаков" Доставал-ка имен пользователя, и в этом сервисе можно попросить имя.
3229.40 3231.40 "Анатолий Кулаков" Система эффектов чем-то это напоминает.
3231.40 3238.40 "Анатолий Кулаков" То есть она смесь этого всего, что я попытался для вас как-то суммаризировать, что это такое.
3238.40 3242.40 "Анатолий Кулаков" Теперь попробуем натянуть всю эту теоретическую абстракцию на реальный мир.
3242.40 3245.40 "Анатолий Кулаков" А можно ли вообще физически такую штуку сделать?
3245.40 3247.40 "Анатолий Кулаков" Такой язык изобрести?
3247.40 3249.40 "Анатолий Кулаков" Ну, на самом деле можно.
3249.40 3257.40 "Анатолий Кулаков" Естественно, кроме каких-то специальных языков, которые позволяют вам поиграться с системой эффектов и как-то просто на нее посмотреть.
3257.40 3260.40 "Анатолий Кулаков" Эту штуку давно завезли уже в Acaml, Haskell.
3260.40 3264.40 "Анатолий Кулаков" Есть библиотеки для реализации в Scully и в F#.
3264.40 3276.40 "Анатолий Кулаков" И также есть библиотека, которая реализовала эту самую систему эффектов, по крайней мере, эту экспериментальную грубую ее поддержку для того, чтобы пощупать, посмотреть и прагматично на этот концепт взглянуть.
3276.40 3278.40 "Анатолий Кулаков" Она есть в C#.
3278.40 3281.40 "Анатолий Кулаков" Библиотека называется EFF.
3281.40 3293.40 "Анатолий Кулаков" И она прекрасна еще тем, что ее имплементация стала возможной благодаря кастомной реализации Async метод билдера.
3293.40 3300.40 "Анатолий Кулаков" То есть с C# 7 мы имеем возможность расширять асинхронные методы в C#.
3300.40 3315.40 "Анатолий Кулаков" То есть вы можете сделать свой собственный класс Task, который можно Async, который можно Await, но он при этом не будет запускаться в каком-то новом потоке или переключаться в какой-то новый thread pool, как делает стандартный Task, а делать что-то свое.
3315.40 3317.40 "Анатолий Кулаков" То есть вы можете сделать свою имплементацию Task.
3317.40 3320.40 "Анатолий Кулаков" Мы про это в одном из выпусков рассказывали.
3320.40 3325.40 "Анатолий Кулаков" Так вот, эта библиотека EFF, она вот эту фишку использует.
3325.40 3327.40 "Анатолий Кулаков" Ключевые концепции, которые у нее есть.
3327.40 3332.40 "Анатолий Кулаков" Прежде всего, она объявляет класс эффекта, который называется EFF от T.
3332.40 3337.40 "Анатолий Кулаков" Это как раз-таки класс-заменитель Task.
3337.40 3339.40 "Анатолий Кулаков" То есть класс, похожий на Task.
3339.40 3347.40 "Анатолий Кулаков" Его можно ждать, его можно запускать, и в качестве результата он возвращает результат T.
3347.40 3359.40 "Анатолий Кулаков" В общем, несмотря на то, что во всем коде этой библиотеки вы везде столкнетесь с тем, что у вас стоит Async/Await, вы должны в уме держать, что это Async/Await не Task, а это Async/Await вот этот EFF.
3359.40 3361.40 "Анатолий Кулаков" То есть это Async/Await эффектов.
3361.40 3372.40 "Анатолий Кулаков" Поэтому в данном коде не очень получается раскрыть тему того, что у нас теперь все функции перестают быть разноцветными, потому что по факту у нас все функции просто становятся асинхронными.
3372.40 3374.40 "Анатолий Кулаков" Но это не та асинхронность, про которую мы говорим.
3374.40 3377.40 "Анатолий Кулаков" Это не та асинхронность, которая как раз-таки...
3377.40 3379.40 "Анатолий Кулаков" Не те Await, правильнее сказать.
3379.40 3382.40 "Анатолий Кулаков" Не те Await и Async, которые относятся к асинхронности.
3382.40 3385.40 "Анатолий Кулаков" Это Await и Async, которые относятся к эффектам.
3385.40 3392.40 "Анатолий Кулаков" Поэтому можно считать, что весь код не асинхронный, а Async/Await, и они обозначают лишь применение эффектов.
3392.40 3394.40 "Анатолий Кулаков" Так, погнали дальше.
3394.40 3400.40 "Анатолий Кулаков" Если мы хотим сделать вот этот EFF от Int, его вполне можно сделать из любой функции.
3400.40 3410.40 "Анатолий Кулаков" Например, объявить функцию SQR от Int, которая просто-напросто возведет в квадрат передаваемый аргумент и вернет результат.
3410.40 3414.40 "Анатолий Кулаков" Эти функции также можно вызывать с помощью Await.
3414.40 3428.40 "Анатолий Кулаков" То есть вы можете перечислить, допустим, массив из Int, для каждого элемента вызвать Await SQR, то есть нашей функции, которая возвращает эффект, и сложить вполне массив Int, как обычные Int.
3428.40 3431.40 "Анатолий Кулаков" Здесь ничего такого необычного нет.
3431.40 3440.40 "Анатолий Кулаков" Необычность заключается в том, что когда вы хотите запустить вот эту всю систему эффектов, весь этот Engine, весь этот Computation, вы можете просто так его взять и запустить.
3440.40 3443.40 "Анатолий Кулаков" Для этого существует специальный метод Run.
3443.40 3457.40 "Анатолий Кулаков" Например, у нашей SQR функции можно вызвать метод Run, и в качестве аргумента ему необходимо передать Handler, то есть тот самый обработчик эффектов, который внутри ожидается.
3457.40 3464.40 "Анатолий Кулаков" И еще стоит отметить важный момент, это в том, что система эффектов является полностью отложенной.
3464.40 3476.40 "Анатолий Кулаков" То есть, допустим, если мы сделаем эффект какой-нибудь, который напечатает в консоль Hello World, потом присвоим переменной Await от этого эффекта, то ничего не произойдет.
3476.40 3481.40 "Анатолий Кулаков" Если бы это был обычный Task, то в момент вызова Await мы бы напечатали в консоль сообщение.
3481.40 3492.40 "Анатолий Кулаков" Но так как это не Task, так как это система эффектов на Task, то Await от EF ничего не сделает до тех пор, пока мы не заэволютируем весь этот Computation.
3492.40 3499.40 "Анатолий Кулаков" То есть легче всего об EF от этих Task-образных классиках думать как о декларировании делегата.
3499.40 3505.40 "Анатолий Кулаков" То есть вы только декларируете какой-то делегат, но на самом деле, когда вы вызываете в нем Await, он не исполняется.
3505.40 3509.40 "Анатолий Кулаков" Он исполнится только потом, когда вы всю эту машинерию запустите.
3509.40 3516.40 "Анатолий Кулаков" Также точно из этих EF, то есть внутри системы эффектов, вы можете запускать асинхронные Task.
3516.40 3532.40 "Анатолий Кулаков" Из этого можно сделать немножко вывод, что несмотря на то, что система эффектов якобы синхронная, из нее вы можете запустить асинхронный Task, дождаться результата с помощью стандартного Await без всяких костылей и получить результат, получить какую-то задержку.
3532.40 3535.40 "Анатолий Кулаков" Если вы вызовете Task Delay, то он подождет без всяких проблем.
3535.40 3540.40 "Анатолий Кулаков" Но при этом метод останется, грубо говоря, в пределах эффектов, то есть синхронно.
3540.40 3543.40 "Анатолий Кулаков" Давайте же посмотрим, как можно программировать на этом всем.
3543.40 3548.40 "Анатолий Кулаков" Итак, для начала, обычно вам необходимо сделать свой какой-то эффект.
3548.40 3553.40 "Анатолий Кулаков" Чтобы сделать свой эффект, вам нужно пронаследоваться от базового класса, который называется EFFECT_ATT.
3553.40 3556.40 "Анатолий Кулаков" Например, мы можем сделать DATA_TIME_NOW эффект.
3556.40 3571.40 "Анатолий Кулаков" Для этого нам необходимо объявить класс DATA_TIME_NOW_EFFECT, пронаследоваться от эффекта, который возвращает DATA_TIME от Generic, и в имплементации этого эффекта просто-напросто вернуть DATA_TIME_NOW.
3571.40 3573.40 "Анатолий Кулаков" Как мы теперь можем использовать?
3573.40 3583.40 "Анатолий Кулаков" Очень просто. Теперь мы можем сделать AWAIT от DATA_TIME_NOW эффекта, и якобы подождать его.
3583.40 3587.40 "Анатолий Кулаков" И с помощью AWAIT мы запустим этот самый эффект.
3587.40 3593.40 "Анатолий Кулаков" Теперь мы можем запустить наше приложение, например, чтобы продемонстрировать, что этот DATA_TIME эффект работает.
3593.40 3603.40 "Анатолий Кулаков" Мы можем запустить какой-то метод, который выполняет какую-то логику, и передать ему в качестве аргумента обязательный параметр, который, как я уже говорил, должен быть HANDLER.
3603.40 3605.40 "Анатолий Кулаков" Есть реализация, которая называется DEFAULT_HANDLER.
3605.40 3608.40 "Анатолий Кулаков" Например, если мы передадим ее, то наше приложение рухнет.
3608.40 3617.40 "Анатолий Кулаков" Оно рухнет с исключением, которое будет гласить, что для нашего эффекта, который DATA_TIME_NOW, мы не реализовали HANDLER.
3617.40 3622.40 "Анатолий Кулаков" То есть сам эффект лишь определяет, что нам нужно сделать, а вот HANDLER определяет, как это делать.
3622.40 3632.40 "Анатолий Кулаков" То есть наше приложение знает, что мы хотим DATA_TIME_NOW, но HANDLER, которое расскажет, как приложение должно удовлетворить этот эффект, который мы не создали.
3632.40 3634.40 "Анатолий Кулаков" Создается очень просто.
3634.40 3643.40 "Анатолий Кулаков" То есть мы должны реализовать HANDLER, пронаследоваться от специального класса EFFECT_HANDLER и перекрыть метод HANDLE, который принимает эффект Awaiter.
3643.40 3647.40 "Анатолий Кулаков" У этого эффекта Awaiter есть куча разных полезных и интересных свойств.
3647.40 3656.40 "Анатолий Кулаков" В нашем случае мы можем проверить, что у этого эффекта Awaiter есть свойство EFFECT, и это свойство EFFECT равно нашему DATA_TIME_EFFECT.
3656.40 3663.40 "Анатолий Кулаков" То есть таким образом по типам мы понимаем, что от нашего HANDLER просят удовлетворить DATA_TIME_EFFECT.
3663.40 3673.40 "Анатолий Кулаков" В качестве удовлетворитации мы можем вычислить UTC_NOW, то есть какое сейчас время, и Awaiter вызвать метод SET_RESULT.
3673.40 3678.40 "Анатолий Кулаков" То есть просто-напросто засетить результат, который мы хотим, чтобы наш вызывающий код получил.
3678.40 3680.40 "Анатолий Кулаков" Таким образом передаются аргументы.
3680.40 3685.40 "Анатолий Кулаков" Так же точно у эффекта можно забрать какие-то аргументы и вернуть ему тоже какие-то аргументы.
3685.40 3692.40 "Анатолий Кулаков" Все вот это определение прекрасно ложится в PATTERN_MATCHING.
3692.40 3698.40 "Анатолий Кулаков" То есть мы с помощью PATTERN_MATCHING проверяем, что этот эффект именно наш эффект, и возвращаем какой-то результат.
3698.40 3702.40 "Анатолий Кулаков" Заполняем результат и возвращаем его обратно в наш код.
3702.40 3704.40 "Анатолий Кулаков" И это прекрасно.
3704.40 3715.40 "Анатолий Кулаков" Теперь если мы, например, захотим запустить тесты с нашим computation, мы просто-напросто так же делаем MOC_DATA_TIME_EFFECT_HANDLER, пронаследованный от эффект-хендлера.
3715.40 3722.40 "Анатолий Кулаков" И теперь мы можем в замоканное время, например, постоянно возвращать в качестве эффекта на вызовы данного метода.
3722.40 3732.40 "Анатолий Кулаков" После того, как мы реализовали этот хендлер, мы можем еще раз запустить наше приложение, но в качестве параметра теперь передать не DEFAULT_HANDLER, а DATA_TIME_EFFECT_HANDLER нашу.
3732.40 3739.40 "Анатолий Кулаков" И приложение отлично отработает, покажет нам текущее время, которое было удовлетворено с помощью этого хендлера.
3739.40 3741.40 "Анатолий Кулаков" Естественно, эти хендлеры можно комбинировать.
3741.40 3757.40 "Анатолий Кулаков" Вы можете сделать, например, хендлер, который обрабатывает эффект вывода в консоль или считывание строчки из консоли, эффект, который удовлетворяет DATA_TIME_NOW запрос, и объединить их в один или в несколько классов.
3757.40 3768.40 "Анатолий Кулаков" И с помощью паттерн-матчинга, с помощью цепочки вызовов вы можете проверить все хендлеры и убедиться, что есть хоть какой-то хендлер, который может обработать ваш эффект, допустим.
3768.40 3772.40 "Анатолий Кулаков" И это все прекрасно композируется и соединяется.
3772.40 3776.40 "Анатолий Кулаков" Это как раз напоминает некий dependency injection.
3776.40 3786.40 "Анатолий Кулаков" То есть, когда мы получаем зависимость, вызываем ее, не зная об имплементации.
3786.40 3795.40 "Анатолий Кулаков" Но в отличие от dependency injection, когда мы реализовали пачку наших хендлеров, мы не пачкаем конструктор.
3795.40 3811.40 "Анатолий Кулаков" Если бы нам необходимо было сделать то же самое в текущем C# коде, нам бы пришлось в класс, который работает с датой и временем, передавать свой DATA_TIME_PROVIDER, у этого DATA_TIME_PROVIDER дергать метод, и тогда мы получили примерно то же самое.
3811.40 3816.40 "Анатолий Кулаков" Мы могли бы этот DATA_TIME_PROVIDER замокать где-то, где-то подставить настоящее время.
3816.40 3820.40 "Анатолий Кулаков" Именно так сейчас и делается в наших приложениях.
3820.40 3824.40 "Анатолий Кулаков" С помощью системы эффектов мы разгружаем наш конструктор.
3824.40 3827.40 "Анатолий Кулаков" Нам не нужно в конструктор ничего подставлять.
3827.40 3831.40 "Анатолий Кулаков" Нам достаточно вызвать эффект, дай мне DATA_TIME, и все.
3831.40 3836.40 "Анатолий Кулаков" И таких вызовов может быть хоть десяток, хоть два десятка, хоть сотня.
3836.40 3847.40 "Анатолий Кулаков" И при этом у нас конструктор не разрастается, как вы, наверное, все могли видеть в больших приложениях, когда конструкторы принимают по 20-30 зависимостей, для того, чтобы удовлетворить какую-то сложную логику.
3847.40 3856.40 "Анатолий Кулаков" Здесь нет, конструктор останется пустым, а через систему эффектов вызывают те самые хендлеры, которые полностью удовлетворяют все их потребности.
3856.40 3860.40 "Анатолий Кулаков" Еще один интересный пример – это Cancellation.
3860.40 3875.40 "Анатолий Кулаков" В общем, у C# часто упрекают, что вот этот Cancellation токен, который вы там получаете где-нибудь наверху в контроллере, и вы вынуждены его пробрасывать куда-нибудь в сервисы, потом из сервиса в хендлеры, из хендлера в репозиторий, или из репозитория в базу данных.
3875.40 3878.40 "Анатолий Кулаков" Вот этот Cancellation токен обязан у вас проходить по всей цепочке.
3878.40 3884.40 "Анатолий Кулаков" Он тоже некрасиво пачкает сигнатуру, потому что нарушает абстракцию.
3884.40 3894.40 "Анатолий Кулаков" У него начинает протекать абстракция, потому что мы знаем, что Cancellation токен надо передавать в операцию, которая умеет отменяться, а вдруг она не умеет отменяться, мы что-то не должны знать.
3894.40 3900.40 "Анатолий Кулаков" Это тоже один из таких штук, который пачкает сигнатуру вместе с асинковейтами.
3900.40 3906.40 "Анатолий Кулаков" Так вот, система эффектов позволяет вам убрать этот Cancellation токен в явном виде из ваших сигнатур.
3906.40 3908.40 "Анатолий Кулаков" Как она это делает? Да очень просто.
3908.40 3913.40 "Анатолий Кулаков" Она Cancellation токен сохраняет в контексте, как раз внутрь этого хендлера.
3913.40 3924.40 "Анатолий Кулаков" И любой эффект, когда вы запускаете любой эффект, он активно проверяет этот Cancellation токен.
3924.40 3929.40 "Анатолий Кулаков" Если Cancellation токен в этот момент был отменен, то просто-напросто бросается Cancelled Exception.
3929.40 3932.40 "Анатолий Кулаков" И вся цепочка разворачивается.
3932.40 3940.40 "Анатолий Кулаков" Поэтому мы можем с вами сделать Cancellation токен таким образом, что никакой код о нем знать вообще не будет.
3940.40 3943.40 "Анатолий Кулаков" Но при этом он будет при каждом вызове эффекта проверяться.
3943.40 3958.40 "Анатолий Кулаков" То есть при каждом вызове, по сути, или асинхронной операции, или input-output операции, или еще какой-то операции, которая требует создать какой-то эффект, он будет проверяться и бросаться исключение, если вдруг у нас Cancellation вдруг взведен.
3958.40 3962.40 "Анатолий Кулаков" И это элегантно и красиво решает всю вот эту проблему.
3962.40 3967.40 "Анатолий Кулаков" И вообще таких проблем, которые решаются в системе эффектов, их очень много.
3967.40 3978.40 "Анатолий Кулаков" Те же самые асинхровые таски, они полностью закрываются в системе эффектов, и их можно было бы сделать на системе эффектов, и они бы не аффектили все сигнатуры, которые у нас есть в методах.
3978.40 3988.40 "Анатолий Кулаков" И вообще, если вы захотите больше каких-то примеров, то в этой замечательной библиотеке EVE там есть классный каталог с экзамплами.
3988.40 3993.40 "Анатолий Кулаков" В частности, там реализован даже ASP.NET Core Application, который показывает, как можно приложение сделать на эффектах.
3993.40 3997.40 "Анатолий Кулаков" Кроме этого, есть примеры, например, конфигов, которые загружаются с помощью эффектов.
3997.40 4000.40 "Анатолий Кулаков" Консолька, естественно, которая реализована с эффектами.
4000.40 4002.40 "Анатолий Кулаков" Dependency Injection, как можно сделать на эффектах.
4002.40 4010.40 "Анатолий Кулаков" Как можно какой-нибудь Relay сделать или Stack Trace реализовать на эффектах прозрачно вообще для вызывающего кода, для вызывающего приложения.
4010.40 4015.40 "Анатолий Кулаков" Как можно писать Trace-логи, при этом не вымазывая весь ваш бизнес-класс в логировании.
4015.40 4020.40 "Анатолий Кулаков" В общем, все это элементарно, красиво и элегантно делается на системе эффектов.
4021.40 4023.40 "Игорь Лабутин" Мне нравится слово "элементарно".
4023.40 4026.40 "Анатолий Кулаков" Ну, как?
4026.40 4031.40 "Анатолий Кулаков" Вообще, если бы система эффектов поддерживалась на уровне языка, то это было бы еще красивее.
4031.40 4040.40 "Анатолий Кулаков" Но мы можем видеть, что даже не имея поддержки на уровне языка, просто-напросто переписав Task Builder, мы вполне можем добиться интересных вещей.
4040.40 4049.40 "Анатолий Кулаков" Вряд ли можно посоветовать кому-то тащить такое в прот, но как поиграться, как посмотреть, размять мозг на эту систему - это очень интересно.
4049.40 4057.40 "Анатолий Кулаков" Казалось бы, такая примитивная концепция - просто-напросто вызвать какой-то хендлер далеко, получить от него результат и продолжить выполняться.
4057.40 4059.40 "Анатолий Кулаков" Что здесь такого? Ничего нового.
4059.40 4078.40 "Анатолий Кулаков" Но если мы начинаем прикидывать на те элементы языка, на те элементы фреймворка, к которым мы давно привыкли - dependency injection, таски, конфиги, стектрейсы, кэши - то понимаешь, что многого этого можно было бы не делать, если в языке просто-напросто поддерживалась бы система эффектов.
4078.40 4080.40 "Анатолий Кулаков" Такая мощная интересная штука.
4080.40 4083.40 "Анатолий Кулаков" Наверное, с практической точки зрения, это всё.
4083.40 4091.40 "Анатолий Кулаков" Если вы хотите больше углубиться в теорию, как раз вышел обалденный выпуск "Подлодки" номер 404.
4091.40 4105.40 "Анатолий Кулаков" Он так и называется - "Система эффектов в языках программирования", где Виталий Брагилевский очень много рассказывает о том, что сейчас в этой теме исследуется, в каких языках она есть, как её можно применять, ну и вообще, что это такое.
4105.40 4109.40 "Анатолий Кулаков" Потому что многим сложно бы даже понять вообще, что это такое.
4109.40 4118.40 "Анатолий Кулаков" Поэтому вдобавок к тем статьям, которые мы к вам приложим, ещё можно послушать "Подлодку" и просветиться уже более глубоко в теоретической части.
4118.40 4120.40 "Игорь Лабутин" Да, я согласен, там довольно интересный выпуск.
4120.40 4129.40 "Игорь Лабутин" Причём там, да, там всякие хитрые штуки обсуждаются, в том числе о возможности там сделать такую, типа, рекурсию-нерекурсию.
4129.40 4132.40 "Игорь Лабутин" В общем, там Виталий довольно понятно рассказывает.
4132.40 4141.40 "Игорь Лабутин" И, наверное, я бы даже рекомендовал послушать этот выпуск, если вы хотите в этом поразбираться, прежде чем заглядывать в код.
4141.40 4150.40 "Игорь Лабутин" Потому что, ну, всё-таки надо сначала голову построить вокруг как-то, осознать эту концепцию немножко, а потом уже смотреть.
4150.40 4152.40 "Анатолий Кулаков" У меня как раз такой пути был.
4152.40 4157.40 "Анатолий Кулаков" Я сначала послушал Брагилевского, а потом пошёл смотреть, а как это вообще выглядит на практике.
4157.40 4162.40 "Анатолий Кулаков" И я хочу сказать, что вот его рассказов я так и не понял, что это.
4162.40 4173.40 "Анатолий Кулаков" Мне больше часа объясняли, как это хорошо, как это прекрасно, вот как это реально реализовано, как мы можем это применять, и что оно действительно умеет, я не понял, пока не разобрался с кодом.
4173.40 4183.40 "Анатолий Кулаков" Поэтому, может быть, кому-то легче пойти снизу, посмотреть на код, посмотреть, как это работает реально на практике, а потом послушать теорию, а как бы это ещё можно было развить.
4183.40 4189.40 "Игорь Лабутин" Может быть, может быть, может быть, действительно, ну, в смысле не может быть, это точно у всех разные способы восприятия.
4189.40 4207.40 "Игорь Лабутин" Мне, в принципе, после Виталия было более-менее, ну, не то чтобы понятно, я там был бы готов это объяснить каждому первому встречному, но какое-то понимание возникло, а ты вот сейчас добавил, да, какое-то практическое применение в параллели, ну, в смысле, в применении к знакомому языку, так скажем.
4207.40 4215.40 "Игорь Лабутин" Потому что на Хаскале это всё, конечно, очень здорово обсуждать, но Хаскале я особо не знаю, поэтому тяжело было бы.
4215.40 4220.40 "Анатолий Кулаков" Ну, да, и ты не сможешь, например, рассказать, каким образом, например, построить кэш на системе эффектов.
4220.40 4230.40 "Анатолий Кулаков" Вот после Виталия неясно, что, какие методы, какие классы написать, или вообще там не нужны методы и классы, потому что он не спускается на практическую такую тему.
4230.40 4241.40 "Анатолий Кулаков" А просто когда ты код посмотрел, и ты примерно понимаешь, как это работает, и Виталий набрасывает какие-то ещё применения, куда это можно было бы воткнуть, ты теперь уже понимаешь, а как ты это можешь реализовать.
4241.40 4246.40 "Анатолий Кулаков" Ты примерно знаешь, а как это работает, и поэтому знаешь, каким образом добиться того эффекта, который он рассказывает.
4246.40 4253.40 "Анатолий Кулаков" Мне кажется, будет намного интереснее смотреть, когда вы осознаете саму сигнатуру, концепцию этого подхода.
4253.40 4261.40 "Игорь Лабутин" Ладно, давай пойдём дальше, в сторону более практических, опять же, вещей, и вернёмся немножко, ну, как вернёмся, в дотнет.
4261.40 4265.40 "Игорь Лабутин" Мы только что были в дотнете, C#, асинк, метод билдер и вот это всё.
4265.40 4268.40 "Игорь Лабутин" Но теперь мы пойдём в более практическо-прикладную область.
4268.40 4274.40 "Игорь Лабутин" Наша любимая тема — dotnet.aspire, про которую мы, ну, если не каждый подкаст, то довольно часто разговариваем.
4274.40 4285.40 "Игорь Лабутин" И для dotnet.aspire, помнишь, мы с тобой обсуждали много раз, будут ли, ну, мы обсуждали, что всякие экстенджины, они лежат же в основном в репозитории самого Aspire, да?
4285.40 4291.40 "Игорь Лабутин" Мы ещё обсуждали, а какой у них там процесс контрибьюта, как бы новые экстенджины законтрибьют, вот это всё.
4291.40 4296.40 "Игорь Лабутин" И как-то что-то не было, видно никаких экстендеров, которые были сторонними.
4296.40 4298.40 "Игорь Лабутин" И тут, наконец-таки, мне такие попались.
4298.40 4303.40 "Игорь Лабутин" И внезапно, ну, не то что внезапно, на самом деле, это не очень внезапно от команды Амазона.
4303.40 4306.40 "Игорь Лабутин" Ну, а точнее, от команды AWS SDK, понятное дело.
4306.40 4312.40 "Игорь Лабутин" То есть тех, кто хочет, чтобы мы программировали дотнет-приложение, в том числе для AWS.
4312.40 4329.40 "Игорь Лабутин" И Amazon, на самом деле, довольно в этом смысле, ну, не то что передовая компания, но довольно много штук, которые появляются в хорошем SDK Амазона, в плане дотнета, чуть ли не раньше, чем они появляются в Ажуре, например, SDK.
4329.40 4331.40 "Игорь Лабутин" Или как-то так там.
4331.40 4342.40 "Игорь Лабутин" У меня было какое-то такое ощущение, что Amazon много чего, ну, довольно активно и контрибьюти, я так понимаю, в дотнет, и в том числе у себя затаскивает дотнет, и использует новые разные фичи.
4342.40 4346.40 "Игорь Лабутин" Ну, в общем, и с Aspire получилось примерно так же.
4346.40 4358.40 "Игорь Лабутин" Они, короче, сделали отдельный пакетик, который позволяет легко заинтегрировать ваше, соответственно, дотнет-приложение, которое написано с помощью Aspire, к AWS-овским ресурсам, если вы вдруг таким пользуетесь.
4358.40 4366.40 "Игорь Лабутин" А AWS довольно популярная штука, и до сих пор остается, я так понимаю, самым популярным облаком, может быть, даже среди дотнет-разработчиков.
4366.40 4367.40 "Игорь Лабутин" Чего-то его знает.
4367.40 4370.40 "Игорь Лабутин" Кстати, в среднем, по миру, она популярна.
4370.40 4375.40 "Игорь Лабутин" Насколько она в дотнет-мире популярна, не знаю, но знаю, что, естественно, клиенты есть.
4375.40 4380.40 "Игорь Лабутин" Для этого мы берем NuGet-пакет, который называется Aspire.hosting.avs.
4380.40 4386.40 "Игорь Лабутин" Надо сказать, что префикс здесь Aspire, то есть они, короче, нормально все сделали.
4386.40 4393.40 "Игорь Лабутин" Добавляем его в ваш дотнет-Aspire проект, причем именно в App Host Project, там, где вы описываете модели вашего приложения.
4393.40 4397.40 "Игорь Лабутин" Напомню, в Aspire у вас есть специальный проект, где вы описываете, кто от кого зависит.
4397.40 4405.40 "Игорь Лабутин" Помимо всех ваших основных проектов-сервисов нужен еще один, который расскажет, как их между собой собрать.
4405.40 4408.40 "Игорь Лабутин" И именно этот проект является, собственно, главным.
4408.40 4412.40 "Игорь Лабутин" Вы его запускаете, он при запуске поднимает все остальные нужные ваши кусочки приложения.
4412.40 4415.40 "Игорь Лабутин" Там контейнеры, сервисы, вот это все.
4415.40 4436.40 "Игорь Лабутин" В чем фишка этой интеграции с Aspire в том, что таким образом добавленный вот этот пакет, он мало того, что умеет правильно прописывать всякие connection-стринги, KVS-ресурсы, он еще и умеет поднять эти самые ресурсы внутри AWS CloudFormation в момент старта приложения.
4436.40 4441.40 "Игорь Лабутин" Понятно, что этот процесс не быстрый, но может быть полезный.
4441.40 4444.40 "Игорь Лабутин" Сейчас мы до этого доберемся.
4444.40 4454.40 "Игорь Лабутин" Дальше есть в Амазоне такая база данных, называется DynamoDB, которую Амазон очень любит продавать всяким пользователям, чтобы и пользовались.
4454.40 4459.40 "Игорь Лабутин" Но, как и любая клауд-база данных, она, вообще говоря, стоит денег.
4459.40 4470.40 "Игорь Лабутин" И если вы будете разрабатывать свое приложение и в качестве своего, так сказать, отладочного работ бегать в нормальную сетевую DynamoDB, вы за это будете платить деньги.
4470.40 4480.40 "Игорь Лабутин" Поэтому есть такой продукт под названием Amazon DynamoDB Local, который позволяет поднять некоторую, ну, копию, так скажем, или что-то похожее на DynamoDB локально у вас на машинке.
4480.40 4486.40 "Игорь Лабутин" И вот Aspire, этот самый Nuget, он на самом деле имеет это все интегрировано внутри себя.
4486.40 4499.40 "Игорь Лабутин" Он сам вам сконфигурит, короче, полностью OS SDK for .NET и подключит его к DynamoDB Local, и, в общем, будет у вас счастье для локального разработки, и не надо будет ходить в сеть.
4499.40 4508.40 "Игорь Лабутин" Для того, чтобы все это сделать, вы, естественно, в вашем апхост-проекте нужно не только добавить Nuget, нужно еще немножечко дописать конфигурации.
4508.40 4524.40 "Игорь Лабутин" Для этого вы в AWS-конфиге, не в AWS-конфиге, в апхост-проекте пишите что-нибудь типа builder.add-aws-sdk-config, указываете профайл, указываете регион, в котором это все будет подниматься, если вы захотите провизионить все.
4524.40 4537.40 "Игорь Лабутин" Дальше вы указываете CloudFormationTemplate, на основе которого все ваши ресурсы будут подниматься, и указываете в reference ссылку на конфиг, только что созданный.
4537.40 4549.40 "Игорь Лабутин" А дальше вы говорите, как обычно, builder.add-project, вы туда добавляете какие-нибудь там ваши frontend, backend, сервисы, и добавляете вот reference на те самые AWS-ресурсы, которые вы только что создали.
4549.40 4551.40 "Игорь Лабутин" И все, этого достаточно.
4551.40 4561.40 "Игорь Лабутин" Когда у вас запустится апхост, во-первых, AWS-овская механика внутренняя, она проверит, есть ли какие-то изменения в том шаблоне, который вы указали.
4561.40 4563.40 "Игорь Лабутин" Шаблон — это просто файлик, по сути.
4563.40 4573.40 "Игорь Лабутин" Если никаких изменений нет, и все, что соответствует этому шаблону, уже поднято, то в AWS-е ничего происходить не будет.
4573.40 4575.40 "Игорь Лабутин" Ну, в смысле, поднятие ресурсов.
4575.40 4595.40 "Игорь Лабутин" Если же есть какие-то изменения, или у вас вообще ничего еще пока не поднято, и в CloudFormation-е в указанном профайле, там с указанным конфигом в указанном регионе нет еще ничего, то, соответственно, этот шаблон применится, и за вас все поднимется.
4595.40 4603.40 "Игорь Лабутин" Естественно, просто поднять мало, потому что, как правило, это все поднимается на, по сути, рандомных адресах, каких-то случайных плюс-минус.
4603.40 4630.40 "Игорь Лабутин" И для того, чтобы знать, к каким адресам, собственно, обращаться, на основе чего собирать endpoint, этот самый CloudFormation-темплейт, в нем есть прям файлики, вы описываете некоторую коллекцию выходных параметров, и потом по их именам вы можете использовать их уже внутри AWS, ой, AWS Aspire кода, для того, чтобы сослаться в соседних проектах на эти, например, connection-стринги.
4630.40 4642.40 "Игорь Лабутин" Все это закидывается в, на самом деле, стандартную конфиг-секцию под названием AWS2.resources, ну и можно переименовать, если надо, когда вы конфигурируете это все дело.
4642.40 4650.40 "Игорь Лабутин" В примере, в статье есть пример, как это все делается, там простой примерчик, ну типа там с очередью, по-моему, каким-то одним сервисом.
4650.40 4675.40 "Игорь Лабутин" Как я сказал, если вы запустите абсолютно пустой, склонируете тестовый проект и запустите пустой, ну вот у автора статей, судя по скриншотам логов, полный стартап занимает 45 секунд, то есть это вот полный провиженинг всего в AWS, но зато повторность стартапа прям практически мгновенная, только обычный стандартный запуск дотунальных приложений, ну плюс проверка, что на самом деле в темплейте и в AWS ничего не поменялось.
4675.40 4702.40 "Игорь Лабутин" Если вы хотите использовать DynamoDB Local, то вам нужно сделать явный вызов метода AWS DynamoDB Local, то есть вам придется какой-то if-чик написать, ну и опять же, вряд ли вы будете апхост проект для Aspire использовать в продакшене, поэтому, в принципе, можно и без if-чика обойтись, даже просто филейпсить AWS DynamoDB Local, а в проде уже, понятно, вы просто конфиг строки через окружение закиньте.
4702.40 4735.40 "Игорь Лабутин" Если вы это все используете, то по дефолту интеграция, которая сейчас есть, будет хранить все данные в памяти, то есть как только вы останавливаете ваше приложение, все данные теряются, но если вам нужно это все сохранить на диске и сохранять данные в локальной DynamoDB между запусками, то вы можете передать опцию Local Storage Directory в этот метод, ну в опции, и таким образом указать локальную папочку, в которой все это складывать, тогда DynamoDB будет складывать все это локально, и данные будут переживать перед запуском вашего Aspire-приложения.
4735.40 4747.40 "Игорь Лабутин" В общем, такое дело, если вы работаете с AWS, и вы хотите пробовать или пробуете уже Aspire, или думали, над чем попробовать, вот это, может быть, интересный вариант попробовать.
4747.40 4750.40 "Игорь Лабутин" Интеграция, судя по всему, написана очень хорошо.
4750.40 4756.40 "Игорь Лабутин" По крайней мере, я видел довольно много восторженных отзывов в принципе о том, что Amazon и AWS делают в области дотнета.
4756.40 4769.40 "Игорь Лабутин" Они же там всякие, помнишь, мы обсуждали довольно давно, иммиграторы делали для этих дотнетов, каких-то переходов между версиями дотнета, в общем, много чего они делали.
4769.40 4772.40 "Анатолий Кулаков" Инструментов у них много, да, действительно.
4772.40 4786.40 "Игорь Лабутин" Поэтому, наверное, это хороший пример того, с одной стороны, как можно хорошо писать интеграции, и, в принципе, можно, я думаю, посмотреть, как она написана, если вы, например, задумаетесь о том, чтобы написать свою.
4786.40 4793.40 "Игорь Лабутин" Понятно, что у Microsoft огромное количество этих интеграций, можно смотреть и в них, но вот есть и для сторонних.
4793.40 4795.40 "Игорь Лабутин" Так что, такие дела.
4795.40 4798.40 "Игорь Лабутин" А дотнет продвигается вперед, в том числе с силами AWS.
4798.40 4800.40 "Игорь Лабутин" Это приятно.
4800.40 4809.40 "Анатолий Кулаков" Ну да, когда такое большое солидное облако тоже участвует в развитии платформы, это тоже хорошо.
4809.40 4819.40 "Анатолий Кулаков" Кстати, да, многие до сих пор не знают, что платформа развивается несколькими большими игроками, что она такая открытая, быстрая и красивая.
4819.40 4822.40 "Анатолий Кулаков" И, в принципе, наверное, про это наша следующая статья.
4822.40 4829.40 "Анатолий Кулаков" Довольно интересная статья, называется она «Почему Tracebit был написан на C#?».
4829.40 4838.40 "Анатолий Кулаков" Казалось бы, для нас, для людей, которые каждый день пишут что-то на C#, ничего такого исключительного в этом нет.
4838.40 4847.40 "Анатолий Кулаков" Но почему-то статья вызвала бурные какие-то аплодисменты, кучу обсуждений на Hacker News, на еще где-то там, в разных твиттерах и так далее.
4847.40 4860.40 "Анатолий Кулаков" Ну, потому что как раз вот эта хипстота, которая начинает выдумывать новые языки, потому что ей чего-то там почесалось, она не признает C# модным языком для стартапов тем более и не понимает о всех его преимуществах.
4860.40 4870.40 "Анатолий Кулаков" Именно поэтому, наверное, когда сел нормальный автор, нормально расписал о причинах, как бы всех это немножко взбудоражило и, может быть, немножко открыло глаза.
4870.40 4881.40 "Анатолий Кулаков" Для нас, наверное, интересно посмотреть, а что именно человек, который никогда в жизни C# в руках не держал, что именно он нашел в этой технологии и почему она ему понравилась.
4881.40 4889.40 "Анатолий Кулаков" Вот чтобы как раз оценить, что в нашей платформе такого интересного и привлекательного может быть для других разработчиков.
4889.40 4891.40 "Анатолий Кулаков" Давайте же посмотрим.
4891.40 4892.40 "Анатолий Кулаков" Итак, Tracebit.
4892.40 4894.40 "Анатолий Кулаков" В принципе, не суть важно для нас, что это.
4894.40 4900.40 "Анатолий Кулаков" Это просто какой-то security стартап, который распространяется как SaaS для бизнес-то бизнес-решений.
4900.40 4902.40 "Анатолий Кулаков" И он написан на C#.
4902.40 4903.40 "Анатолий Кулаков" Почему?
4903.40 4905.40 "Анатолий Кулаков" Дальше мнение автора.
4905.40 4913.40 "Анатолий Кулаков" Автор говорит, что в принципе, когда ты делаешь новый стартап, самое главное правило - это выбирать то, что ты уже знаешь.
4913.40 4917.40 "Анатолий Кулаков" То есть тебе нужно идти по продуктовым дорожкам, чтобы меньше ошибаться, естественно.
4917.40 4925.40 "Анатолий Кулаков" И если ты тем более знаешь, что то, что ты выберешь, работает хорошо и оно себя показало хорошо, то вот бери сразу его и вообще не сомневайся.
4925.40 4927.40 "Анатолий Кулаков" Правило разумное, правило понятное.
4927.40 4929.40 "Анатолий Кулаков" От него никуда не денешься.
4929.40 4931.40 "Анатолий Кулаков" Но автор решил деться.
4931.40 4938.40 "Анатолий Кулаков" Потому что до этого он писал большие сложные критичные системы и писал их в основном на Python и TypeScript.
4938.40 4941.40 "Анатолий Кулаков" То есть никакого опыта ни с каким другим языком у него не было.
4941.40 4945.40 "Анатолий Кулаков" Поэтому он решил поэкспериментировать.
4945.40 4960.40 "Анатолий Кулаков" В качестве проблемы его прошлых подходов он называл динамическую типизацию Python и TypeScript, проблемы с пакетами, проблемы с зависимостями и очень сложное сопровождение большой кодовой базы.
4960.40 4962.40 "Анатолий Кулаков" В этом его, наверное, сложно упрекнуть.
4962.40 4967.40 "Анатолий Кулаков" Действительно, с такими инструментами непонятно, что там вообще можно сделать.
4967.40 4972.40 "Анатолий Кулаков" И поэтому он захотел найти что-то новое, что-то другое для своего очередного стартапа.
4972.40 4974.40 "Анатолий Кулаков" Что же он искал, какие критерии он оценивал?
4974.40 4976.40 "Анатолий Кулаков" Ну, прежде всего, productivity.
4976.40 4979.40 "Анатолий Кулаков" Это результативность, эффективность работы.
4979.40 4987.40 "Анатолий Кулаков" Он говорит, что когда вы проводите какое-то время над кодом, любое это время должно быть значимо.
4987.40 4990.40 "Анатолий Кулаков" То есть вы должны сделать какую-то полезную нагрузку.
4990.40 5002.40 "Анатолий Кулаков" И в первые дни стартапа очень важно быстро проверить какую-то теорию для того, чтобы понять, ошибаетесь ли вы, или идете по правильному направлению, и быстренько свернуть в ту или иную сторону.
5002.40 5004.40 "Анатолий Кулаков" И это очень важно делать.
5004.40 5006.40 "Анатолий Кулаков" И важно, чтобы инструмент, язык вам это помогал делать.
5006.40 5023.40 "Анатолий Кулаков" И когда вы уже поняли, в какую сторону идти, очень важно теперь получить от языка выразительность, когда вы можете все ваши идеи довольно быстро и четко переносить в код, в поддерживаемый, хороший, качественный код, и реализовать ваш продукт довольно быстро, выпускать фичи быстро.
5023.40 5032.40 "Анатолий Кулаков" То есть это вот такие две противоположные стороны стартапа, которые обязаны удовлетворять новый язык или новая выбранная платформа.
5032.40 5036.40 "Анатолий Кулаков" Дальше сопровождение.
5036.40 5053.40 "Анатолий Кулаков" Необходимо, чтобы платформа давала хороший легкий рефакторинг, чтобы она могла поддерживать большой кодовую базу, чтобы там были какие-то большие бизнес-домены, с ними легко было управляться, чтобы когда было много фич в нашем великолепном стартапе, с этим всем тоже можно было как-то работать.
5053.40 5064.40 "Анатолий Кулаков" А также, когда у нас наберется очень большая команда разработчиков, чтобы они тоже могли как-то параллельно вместе изменять код, не толкаться и понимать то, что написал другой человек.
5064.40 5068.40 "Анатолий Кулаков" И поменьше времени проводить хочется с сопровождением.
5068.40 5073.40 "Анатолий Кулаков" Больше хочется писать фичи, выкатывать новые продукты, удовлетворять пользователей.
5073.40 5082.40 "Анатолий Кулаков" А вот эту бюрократию и танцы, которые требуют платформы часто на себя для их сопровождения, хотелось бы избежать как можно больше.
5082.40 5087.40 "Анатолий Кулаков" И в принципе .NET Stack всему этому прекрасно удовлетворил.
5087.40 5090.40 "Анатолий Кулаков" Его продуктивность была просто на высоте.
5090.40 5102.40 "Анатолий Кулаков" Он очень хорошо растет в том, что он дает очень много фишек, которые помогают как раз вот этой продуктивности осуществиться.
5102.40 5112.40 "Анатолий Кулаков" И плюс ко всему он стабилен, у него обратная совместимость, поэтому разработка в долгу на нем выглядит очень даже перспективно и хорошо.
5112.40 5118.40 "Анатолий Кулаков" Еще одно из требований - это открытость и бесплатность.
5118.40 5120.40 "Анатолий Кулаков" То есть он хотел open source и открытость.
5120.40 5129.40 "Анатолий Кулаков" Потому что когда вы маленький стартап, то вам очень часто необходимо посмотреть внутрь некоторых вещей, внутрь фреймворка, внутрь библиотек.
5129.40 5133.40 "Анатолий Кулаков" И это очень сильно помогает разработке, когда вы начинаете узнавать, что там внутри написано.
5133.40 5142.40 "Анатолий Кулаков" И на ранних стадиях никакого ни смысла, ни желания нет для того, чтобы потратить деньги.
5142.40 5151.40 "Анатолий Кулаков" То есть не хотелось бы тратить деньги на какие-то коммерческие библиотеки, коммерческие языки, поэтому open source и free - это одно из базовых было требований.
5151.40 5157.40 "Анатолий Кулаков" И, естественно, .NET полностью открытый, .NET полностью open source и распространяется под mid лицензии.
5157.40 5167.40 "Анатолий Кулаков" Вот этих зданий, кстати, не хватает очень многим продуктовым менеджерам, которые до сих пор продолжают выбирать какие-то уродские языки, вместо того, чтобы писать на .NET.
5167.40 5173.40 "Анатолий Кулаков" Многим в голову до сих пор все еще не дошло, что никакого Microsoft в общем-то в базе нет.
5173.40 5177.40 "Анатолий Кулаков" Это все открыто, open source и mid лицензировано.
5177.40 5180.40 "Анатолий Кулаков" Далее тоже одно из стандартных заблуждений.
5180.40 5186.40 "Анатолий Кулаков" Я неожиданно удивился и обнаружил для себя, что .NET кроссплатформенный.
5186.40 5190.40 "Анатолий Кулаков" Вот тебе, Игорь, даже видишь 2025 год.
5190.40 5192.40 "Анатолий Кулаков" .NET кроссплатформенный, и это большое удивление.
5192.40 5194.40 "Игорь Лабутин" Ну, да, да.
5194.40 5197.40 "Игорь Лабутин" Тут, кстати, немножко офф-топа.
5197.40 5209.40 "Игорь Лабутин" Дэвид Фаулер тут как-то что-то тоже на Reddit, что ли, то ли нашел статью, я обсуждение то ли сам его начал на тему того, что, мол, кому...
5209.40 5212.40 "Игорь Лабутин" А может, кстати, по следам троизбиты в каком-то смысле.
5212.40 5214.40 "Игорь Лабутин" Типа, мол, для кого .NET...
5214.40 5215.40 "Игорь Лабутин" Кто выбирает .NET?
5215.40 5217.40 "Игорь Лабутин" Ну, типа там, Enterprises, не Enterprises, в таком духе.
5217.40 5224.40 "Игорь Лабутин" И он где-то в Твиттере у себя писал, что, типа, ну, да, по ходу, как бы, основная проблема .NET-а — это старая память.
5224.40 5229.40 "Игорь Лабутин" Ну, в смысле, память поколений о том, что .NET — это Windows Only и вот это всё.
5229.40 5230.40 "Игорь Лабутин" Так что, да-да.
5230.40 5239.40 "Анатолий Кулаков" Это мне кажется, что если вспомнить историю, то он закрытый был намного уже меньше, чем сейчас открытый по времени, по продолжительности.
5239.40 5242.40 "Игорь Лабутин" Но память делает такое.
5242.40 5244.40 "Анатолий Кулаков" Это да, это да.
5244.40 5256.40 "Анатолий Кулаков" В качестве подтверждения своих слов, что всё-таки фреймворк является кроссплатформенным, он рассказывает, что у них все разработчики сидят под маками, везде плой происходит на Линуксе, и Линуксы работают под ARM-ядрами.
5256.40 5261.40 "Анатолий Кулаков" В общем, всё это прекрасно поддерживает .NET-ом без каких-то там либо проблем или условий.
5261.40 5265.40 "Анатолий Кулаков" Ещё один интересный аспект, который он выделил — это популярность.
5265.40 5273.40 "Анатолий Кулаков" Безусловно, популярность никаким образом напрямую не влияет на качество языка или качество фреймворков, но он считает это довольно важным показателем.
5273.40 5280.40 "Анатолий Кулаков" Например, потому что когда у вас маленький стартапчик начинает расти, вам необходимо очень быстро нанимать инженеров.
5280.40 5289.40 "Анатолий Кулаков" И популярность языка, популярность фреймворка говорит вам о том, насколько вы быстро сможете с рынка спылесосить инженеров и об их стоимости.
5289.40 5303.40 "Анатолий Кулаков" Также популярность косвенно влияет на распространённость всяких SDK-ов и библиотек, потому что необходимо очень много интеграций всяческих, и они нашли практически всё, что хотели для интеграции с разными сторонними сервисами.
5303.40 5306.40 "Анатолий Кулаков" Это тоже относит к популярности языка.
5306.40 5316.40 "Анатолий Кулаков" Также он говорит, что популярность в том числе описывается качественной документацией и обилием различных примеров в интернете.
5316.40 5325.40 "Анатолий Кулаков" То есть то, что он никогда не сталкивался с такой проблемой, что мы были первыми, никто до нас этого не видел, и вот мы столкнулись с какой-то проблемой и остались не один на один.
5325.40 5332.40 "Анатолий Кулаков" Нет, все проблемы, примеры прекрасно находились на Stack Overflow, на форумах, и прекрасно находилось их решение.
5332.40 5336.40 "Анатолий Кулаков" То есть это тоже плюсы популярности фреймворка.
5336.40 5340.40 "Анатолий Кулаков" Также он хотел выбрать какое-то memory safety решение.
5340.40 5350.40 "Анатолий Кулаков" Он сказал, что это вообще просто не обсуждается даже, это в нашем современном мире только идиоты будут писать на каких-то языках, где нет memory safety.
5350.40 5358.40 "Анатолий Кулаков" Это полностью необходимо, тем более у них они разрабатывают security продукты, а для security продукта это самое первое, что должно быть.
5358.40 5366.40 "Анатолий Кулаков" Более того, многие регуляторные органы требуют, чтобы какие-то продукты были написаны на memory safety языках.
5366.40 5371.40 "Анатолий Кулаков" То есть пропихнуть им какой-то продукт на сях или на плюсах вообще нереально.
5371.40 5374.40 "Анатолий Кулаков" То есть это у них прямо в декларации написано.
5374.40 5377.40 "Анатолий Кулаков" Гарбидж коллектор. Он хотел гарбидж коллектор.
5377.40 5388.40 "Анатолий Кулаков" Почему? Да потому что, говорит, мы не пишем real-time системы, мы не пишем какие-то embedded системы, мы не пишем какие-то компоненты драйверов или какие-то компоненты операционных систем.
5388.40 5393.40 "Анатолий Кулаков" Поэтому никаких проблем с ГЦ-паузами у нас нет, мы вполне можем себе их позволить.
5393.40 5414.40 "Анатолий Кулаков" И в то же самое время, приводя пример рассмотрения RASTA как альтернативы для своего языка к стартапу, он говорит, что ему не хотелось тратить время на то, чтобы удовлетворять borrow-checker, вместо этого ему хотелось писать свой продукт.
5414.40 5417.40 "Анатолий Кулаков" И поэтому RASTA сразу пошли в топку.
5417.40 5421.40 "Анатолий Кулаков" Один из еще требований - это статическая типизация.
5421.40 5430.40 "Анатолий Кулаков" Автор, я напомню, был сильно измучен Python и TypeScript, поэтому он хотел статическую типизацию и всячески ее нахваливал.
5430.40 5434.40 "Анатолий Кулаков" Действительно, как человечество дошло до такого великого прогресса.
5434.40 5440.40 "Анатолий Кулаков" Он работал и со статическими языками, и с динамическими, но все же с динамическими опыта у него было больше.
5440.40 5459.40 "Анатолий Кулаков" И поэтому даже в тех маленьких ситуациях, когда он пробовал статические языки, он вынес для себя следующие выводы, что любой overhead статических языков полностью нивелируется тем временем, которое вы потом тратите на сопровождение статического кода.
5459.40 5463.40 "Анатолий Кулаков" Какой overhead он имеет в виду?
5463.40 5465.40 "Анатолий Кулаков" Потому что вы должны указывать типы.
5465.40 5472.40 "Анатолий Кулаков" Для людей, пишущих на динамическом языке, это считается overhead, вы зря буквки тратите.
5472.40 5477.40 "Анатолий Кулаков" Он говорит, что нет, это потом окупливается в миллионы раз.
5477.40 5480.40 "Анатолий Кулаков" Поэтому статические языки - это хорошо.
5480.40 5484.40 "Анатолий Кулаков" Статическая типизация вылавливает кучу вагов еще на этапе разработки.
5484.40 5495.40 "Анатолий Кулаков" Для этого нужно писать намного меньше тестов, для этого нужно намного меньше задумываться о том, как оно у вас в рантайме может упасть.
5495.40 5506.40 "Анатолий Кулаков" Статическая типизация, безусловно, позволяет сделать код более производительным, потому что компилятор на время компиляции знает типы, может их красиво разложить по регистрам процессора.
5506.40 5509.40 "Анатолий Кулаков" В общем, все это очень сильно влияет на performance.
5509.40 5513.40 "Анатолий Кулаков" Поэтому статические типизированные программы всегда будут быстрее.
5513.40 5520.40 "Анатолий Кулаков" И статическая типизация помогает ему очень быстро вникнуть в код, и даже тот, с которым он не знаком.
5520.40 5526.40 "Анатолий Кулаков" То есть исследование кода, поиск каких-то классов, наследников и так далее.
5526.40 5533.40 "Анатолий Кулаков" В частности, он приводит, что IDE для статически типизированных языков намного более мощными.
5533.40 5540.40 "Анатолий Кулаков" Найти, например, все использования, перепрыгнуть на декларацию метода, сделать какой-то стабильный рефакторинг.
5540.40 5542.40 "Анатолий Кулаков" Все это со статическими типами.
5542.40 5546.40 "Анатолий Кулаков" И, естественно, разумеется, в миллиарды раз лучше, красивше и надежнее.
5546.40 5548.40 "Анатолий Кулаков" Стабильность.
5548.40 5551.40 "Анатолий Кулаков" Стабильность - это такой фактор, который тоже был для него очень важен.
5551.40 5557.40 "Анатолий Кулаков" И он сказал, что C# - это лучшее решение по стабильности, которое вообще можно было только себе представить.
5557.40 5561.40 "Анатолий Кулаков" Потому что здесь стабильный язык, за ним стоит стабильная компания.
5561.40 5563.40 "Анатолий Кулаков" У нее очень понятный релизный цикл.
5563.40 5569.40 "Анатолий Кулаков" То есть мажорные версии релизятся все вместе, вместе с фреймворком, с языком.
5569.40 5571.40 "Анатолий Кулаков" Они релизятся каждый год.
5571.40 5574.40 "Анатолий Кулаков" LTS поддерживается 3 года.
5574.40 5579.40 "Анатолий Кулаков" При этом каждый релиз сопровождается хорошей документацией.
5579.40 5581.40 "Анатолий Кулаков" Все тестировано вместе.
5581.40 5583.40 "Анатолий Кулаков" Оно все не разваливается.
5583.40 5589.40 "Анатолий Кулаков" Оно сохраняет бесплатную backward compatibility, обратную, что тоже немаловажно.
5589.40 5599.40 "Анатолий Кулаков" И при этом с каждым релизом он отмечает, что выпускается тонна новых фич языка, фреймворков, новых типов, какие-то интродюсятся.
5599.40 5605.40 "Анатолий Кулаков" И отдельно отметил, что performance improvements просто с каждым релизом очень крутые.
5605.40 5609.40 "Анатолий Кулаков" То есть они переходили на 3 версии уже дотнета.
5609.40 5619.40 "Анатолий Кулаков" И с каждым переходом они наблюдали просто хорошее прибавление производительности, всего лишь навсего перекомпилировав.
5619.40 5627.40 "Анатолий Кулаков" И также он отметил, что когда они переводили, это занимало в их проекте не больше недели перевод на новый фреймворк.
5627.40 5631.40 "Анатолий Кулаков" И никогда они не встречались с какими-то новыми проблемами.
5631.40 5637.40 "Анатолий Кулаков" Поэтому он отмечает, что стабильность платформы и обратная совместимость просто на высоте.
5637.40 5639.40 "Анатолий Кулаков" Batteries included.
5639.40 5641.40 "Анатолий Кулаков" То есть какие-то там батарейки нашел.
5641.40 5657.40 "Анатолий Кулаков" Под батарейками он подразумевает, что огромное количество различных библиотек, очень хорошо поддерживаемых и высочайшего качества API, фреймворков, библиотек различных, с помощью которых он как раз интегрировался или обеспечивал какую-то другую логику в своем приложении.
5657.40 5659.40 "Анатолий Кулаков" В общем, все это тоже ему понравилось.
5659.40 5665.40 "Анатолий Кулаков" Инструментарий. Отметил также огромный уровень того инструмента, который есть.
5665.40 5667.40 "Анатолий Кулаков" В частности, они используют Rider.
5667.40 5669.40 "Анатолий Кулаков" Назвал это бриллиантовое IDE.
5669.40 5673.40 "Анатолий Кулаков" И отметил, что она бесплатная для некоммерческого использования.
5673.40 5677.40 "Анатолий Кулаков" В ней есть прекрасные дебаггеры, тестеры, рефакторинги, профайлеры.
5677.40 5681.40 "Анатолий Кулаков" Короче, все, о чем только можно мечтать в хорошей, качественной, современной IDE.
5681.40 5685.40 "Анатолий Кулаков" Также куча статических анализов и даже с автоматическими фиксами.
5685.40 5687.40 "Анатолий Кулаков" Что интересно.
5687.40 5693.40 "Анатолий Кулаков" Производительность. Еще раз, что он тут в отдельный абзац выделил с дифферентами к производительности C#.
5693.40 5701.40 "Анатолий Кулаков" Опять ссылаясь на Tech Empower, на вот эти бенчмарки, на которых C# постоянно пытается какие-то первые места занять.
5701.40 5709.40 "Анатолий Кулаков" Он говорит, что это, конечно, не показательно, но смотрите, в принципе, команда C# думает, и .NET, команда .NET думает о производительности.
5709.40 5711.40 "Анатолий Кулаков" И с каждым релизом мы это видим.
5711.40 5715.40 "Анатолий Кулаков" Поэтому мне этого достаточно.
5715.40 5717.40 "Анатолий Кулаков" У нас все прекрасно с точки зрения перформанса.
5717.40 5719.40 "Анатолий Кулаков" Фичи.
5719.40 5723.40 "Анатолий Кулаков" Он отметил, что технологически стэк C# один из лучших.
5723.40 5725.40 "Анатолий Кулаков" Стэк .NET и C# - одни из лучших на рынке.
5725.40 5747.40 "Анатолий Кулаков" То есть технологически там постоянно происходят какие-то интересные революции, классные фреймворки. Он отметил LINQ, Entity Framework, теперь Dataflow, ISP.NET, даже тот же самый F#, который блещет инновациями. И, говорит, еще куча-куча всего нового, интересного, технических таких моментов. Можно порыться, покопать, и обязательно вы найдете всего интересного.
5747.40 5751.40 "Анатолий Кулаков" Результаты, что там, собственно, у него творится на данный момент.
5751.40 5755.40 "Анатолий Кулаков" На данный момент он говорит, что абсолютно счастлив, что выбрал, попробовал C#.
5755.40 5759.40 "Анатолий Кулаков" Будет его использовать и пытаться на других проектах.
5759.40 5785.40 "Анатолий Кулаков" Они сделали тысячу коммитов, больше ста тысяч строк кода написали. У них было несколько онбордингов инженеров, которые никогда в жизни не трогали C#. При этом он говорит, что очень быстро въезжали, очень легко писали, и получался довольно качественный код. То есть, люди, которые на C# никогда не программировали, въезжают в него очень хорошо. И находятся специалисты, такие на рынке, которые никогда не видели C#, тоже очень хорошо.
5785.40 5799.40 "Анатолий Кулаков" То есть, язык очень продуктивный, очень быстрый, очень приятный, и минусов, в принципе, он нам никаких не навалил. Просто вот такой вот хороший, положительный комментарий.
5799.40 5827.40 "Анатолий Кулаков" Наверное, отдельное упоминание стоит статья на Hacker News, потому что как раз он там пенял, когда он выбирал язык, он пенял на Hacker News, что там в основном используются какие-то модные молодежные языки, и такие стабильные, хорошие, качественные системы очень не распространены. И вот почему люди не знают, что вокруг них есть такие бриллианты, и пытаются использовать какие-то виллы с гороблями не по назначению.
5827.40 5831.40 "Анатолий Кулаков" Поэтому я думал, что сейчас на Hacker News его там всячески утопят.
5831.40 5845.40 "Анатолий Кулаков" Рассказывать, чувак, ты там какой-то старпер, устарелый. Но нет, если в принципе проанализировать треды Hacker News, то отзывы довольно-таки положительные. То есть латентных дотнетчиков и C#-пистов оказывается довольно-таки много.
5845.40 5857.40 "Анатолий Кулаков" Просто они не привыкли кричать об этом на каждом углу. Давайте тоже посмотрим и выделим, что в комментариях в Hacker News, то есть другие разработчики, другие инженеры, что отмечали про C#.
5857.40 5863.40 "Анатолий Кулаков" Прежде всего, стабильность экосистемы дотнета. То есть стабилен как C#, так и сам дотнет.
5863.40 5877.40 "Анатолий Кулаков" То есть люди говорят, что можно быть полностью уверенным, что код, написанный несколько лет назад, будет продолжать работать без всяких проблем. В отличие, например, от JavaScript, где там каждый день выпускаются новые библиотеки, полностью несовместимые со вчерашней версией.
5877.40 5893.40 "Анатолий Кулаков" И невозможно вообще с этим жить. А вот в C# для долгослурочных проектов это идеальный вариант. Потому что там возьми через 10 лет код, будет запускаться, работать, компилироваться без всяких проблем. Удобство работы с зависимостями.
5893.40 5903.40 "Анатолий Кулаков" Был такой пример, что после установки .NET SDK, вам достаточно выполнить .NET Run и ваше приложение само восстановит зависимость, само скомпилируется и само запустится.
5903.40 5909.40 "Анатолий Кулаков" На новой чистой машине, кроме SDK и единственной команды .NET Run, вам больше ничего не надо. Все остальное делается с помощью магии.
5909.40 5929.40 "Анатолий Кулаков" И это очень сильно контрастирует с другими языками, где начинается ад какой-то зависимости, какие-то NPM инсталлы и прочие какие-то environment конфликты. И не знаю, хорошо это или плохо, но отметили, что управление зависимостями даже лучше, чем в экосистеме Пайтона.
5929.40 5943.40 "Анатолий Кулаков" Я бы не сказал, что в Пайтоне там мега крутое управление зависимостями, конечно, но, грубо говоря, с его Янвами это вполне живущая хорошая история. Если там люди отметили, что это гораздо удобнее Янва, то, наверное, это хорошо.
5943.40 5989.40 "Анатолий Кулаков" Если сравнивать с другими технологиями, например, если сравнить C# с Java, то многие считают, что C# развивается быстрее, чем Java, в нем лаконичнее синтаксис, понятнее выразительной конструкции и писать на нем намного более удобно и приятно. Если сравнить JVM и .NET, то JVM развивается очень медленно, сильно медленнее .NET, и она менее удобна для быстрого старта новых проектов. Не знаю, как они могли JVM найти менее медленно до старта нового проекта, ну, допустим. Если сравнить C# с Rust и Go, то Rust и Go популярны среди новых проектов, но при этом отмечается, что их экосистема не настолько зрелая, не настолько развитая, IDE не настолько хороший, Tooling не настолько блестящий.
5989.40 6015.40 "Анатолий Кулаков" Если взглянуть на C# как на язык, то отмечается, что Microsoft очень активно развивает язык, несмотря на то, что, Игорь, мы тут с тобой несколько релизов плачем, что язык развивается, со стороны люди говорят, что это развитие у нас МЕГ большое. Да, ну ладно. Регулярно добавляется, да, регулярно добавляется новые возможности, улучшается производительность и, опять же, отмечается очень хорошая совместимость, что всех радует. Ну, это
6015.40 6021.40 "Игорь Лабутин" действительно так. Общий вывод. С преемственностью у нас все хорошо и в совместимости все нормально.
6021.40 6029.40 "Анатолий Кулаков" Ну, да, у Microsoft, в принципе, это прослеживается везде, там, начиная от Windows и Office и так далее, что, в принципе, они стараются.
6029.40 6033.40 "Анатолий Кулаков" За исключением, может, каких-нибудь UI-фреймворков, но мы это опустим.
6033.40 6045.40 "Анатолий Кулаков" Общие выводы. C# и .NET остаются привлекательным выбором для долгосрочных проектов, благодаря стабильности, обратной совместимости, удобству работы с зависимостями и активному развитию языка.
6045.40 6059.40 "Анатолий Кулаков" И многие разработчики считают, что все эти факторы делают C# и .NET лучшим выбором, особенно если сравнивать с Java, Go и Rust во многих сценариях, в которых сталкиваются современные стартапы.
6059.40 6065.40 "Анатолий Кулаков" То есть отмечают, что незаслуженно стартапы обходят данную платформу и экосистему.
6065.40 6079.40 "Анатолий Кулаков" Ну, вот так как-то, какие-то положительные отзывы тоже. Наверное, приятно, наверное, хорошо. Может, кто-то в следующий раз задумается, зачем тащить опять эту старомодную Java или никчемный Go в свои проекты, если можно взять хорошее, проверенное, стабильное, нормальное решение.
6079.40 6081.40 "Игорь Лабутин" Действительно.
6081.40 6083.40 "Игорь Лабутин" Ну, действительно, интересные выводы.
6083.40 6087.40 "Игорь Лабутин" Я лично довольно много, не то, что критики, а какого-то такого.
6087.40 6111.40 "Игорь Лабутин" То есть мне кажется, я не сильно видел много критики на это, но вот такого рассуждения вида, ну да, это Microsoft, там Windows, вот это все, то есть типа продукт норм, но типа нишевая штука, мы возьмем универсальный JVM или там универсальный молодежный Go, или даже Rust, и все будет хорошо. Но действительно, ниша для данного тренда все еще есть, он действительно все еще хорош.
6111.40 6127.40 "Анатолий Кулаков" Кажется, что просветительности мало, да, то есть люди до сих пор живут в каких-то заблуждениях, то есть у него нет какого-то хорошего маркетингового просвещения. Непонятно, почему. У Microsoft большой, у него еще много там всяких евангелистов, то есть почему до сих пор такие странные убеждения, не ясно.
6127.40 6129.40 "Игорь Лабутин" Непонятно, непонятно. Ну, посмотрим.
6129.40 6133.40 "Игорь Лабутин" Похоже, что Fowler как раз пытается что-то с этим сделать.
6133.40 6145.40 "Игорь Лабутин" Ну, то есть не то, что прям пытается, но по Твиттеру у него прям довольно раз или пару раз в неделю появляются такие вопросы, типа, мол, там, а что вас заставляет писать не на DotNet?
6145.40 6157.40 "Игорь Лабутин" Ну, типа, я сейчас условно формулирую, но то есть он как бы, такое ощущение, что у него сейчас фокус основной, видимо, продвинуть Aspire как можно шире, а для этого в том числе можно продвинуть куда-нибудь DotNet пошире.
6157.40 6159.40 "Игорь Лабутин" Да, хорошая тенденция.
6159.40 6167.40 "Игорь Лабутин" И он как раз пытается, такое ощущение, что понять, а что можно с этим сделать, судя по всему. Ну и
6167.40 6173.40 "Анатолий Кулаков" наши слушатели дорогие, вы тоже там старайтесь, давайте на Fowler надеюсь, а сам не плашай.
6173.40 6177.40 "Анатолий Кулаков" Объясняйте тоже вашим тупым продуктованным, на чем надо писать настоящие проекты.
6177.40 6183.40 "Анатолий Кулаков" Рассказывайте вашим нелепым друзьям, которые не знают, что C# до сих пор не кроссплатформенный и вот это вот все.
6183.40 6191.40 "Анатолий Кулаков" Рассказывайте, просвещайте, давайте статьи, давайте подкасты, приводите на доклады. Давайте бороться с этой невежественностью и мракобесием.
6191.40 6201.40 "Игорь Лабутин" Да, обязательно. Чтобы наш подкаст служил и дальше, и мы не рассказывали про какую-нибудь забытую технологию прошлого, а про современный молодежный стэк.
6201.40 6203.40 "Игорь Лабутин" Кроссплатформенный при этом.
6203.40 6205.40 "Игорь Лабутин" Итак, последнее на сегодня.
6205.40 6207.40 "Игорь Лабутин" Это кратко о разном.
6207.40 6211.40 "Игорь Лабутин" Туда у нас попала всего одна новость, причем так залетела в последний момент.
6211.40 6213.40 "Игорь Лабутин" Но новость интересная.
6213.40 6223.40 "Игорь Лабутин" Опять же на Reddit я наткнулся на статью про то, что Identity Server 4 полностью удален с GitHub.
6223.40 6243.40 "Игорь Лабутин" Проект. Напомню, что Identity Server 4 это такой по сути фреймворк, наверное, даже можно сказать, вокруг которого можно построить систему авторизации на базе, ну, точнее, соответствующую протоколам, да, OAuth 2.0, OpenID Connect и вот этого всего.
6243.40 6257.40 "Игорь Лабутин" То есть некоторый набор NuGet пакетов, который позволяет вам это все построить в интернете и замечательно это реализовать. Напомню, что Identity Server 4 была последней версией, которая была под публичной лицензией.
6257.40 6271.40 "Игорь Лабутин" Дальше это все авторы преобразовали в коммерческую компанию Duende Software и выпускают теперь свой собственный, ну, в смысле, тот же самый по сути сервер, только про обновленный под современные реалии, под современный .NET, но уже за деньги.
6271.40 6275.40 "Игорь Лабутин" Старый при этом жил на GitHub, не обновлялся никак.
6275.40 6283.40 "Игорь Лабутин" Он, насколько я помню, поддержка его прекращена вместе с поддержкой .NET 3.1, то есть, ну, это довольно давно.
6283.40 6287.40 "Игорь Лабутин" Но, тем не менее, никому не мешал и жил.
6287.40 6297.40 "Игорь Лабутин" И до, собственно, текущей недели, когда его полностью убрали с GitHub, ну, на самом деле, как оказалось, репозиторий просто превратили в private.
6297.40 6303.40 "Игорь Лабутин" Вот, но для всех остальных это выглядел как 404 на GitHub, и понятное дело, что, ну, как бы, все, нету.
6303.40 6317.40 "Игорь Лабутин" По этому поводу не то, что поднялся шум, ну, то есть, на Reddit народ пообсуждал, и в GitHub "Doing the Software" завели дискашен на тему того, вообще-то, как бы, вы что, зачем?
6317.40 6319.40 "Анатолий Кулаков" Ну, вообще интересно, да, а зачем?
6319.40 6325.40 "Анатолий Кулаков" Потому что репозиторий и так висел в Redonly, и очень многие компании, как бы, на нем делали свои продукты.
6325.40 6333.40 "Анатолий Кулаков" И очень многие компании заглядывали в исходники, искали в вышесах какие-то ответы на свои вопросы, и, в принципе, продукт жил и кушать не просил.
6333.40 6335.40 "Анатолий Кулаков" Open ID Connect не менялся уже несколько десятилетий.
6335.40 6383.40 "Игорь Лабутин" Ну, да, сам протокол, ну, там, потихонечку OAuth развивается, там пишется новая спека, я не очень помню ее текущий статус, по-моему, она все еще в драфте, но смысл в том, что там находятся какие-то, понятно, что в секьюрити могут быть уязвимости, то есть, продуктом особо никто не занимается, то есть, он наверное, плюс-минус уязвим, и понятно, что там ничего не фиксится, то есть, нужно самим это все делать. Если вы были готовы, то пожалуйста, но я так понимаю, что это и была их основная мотивация, по крайней мере, так они пишут про то, чтобы не под своим, так сказать, брендом не распространять потенциально уязвимый код, который, да, явно написано, что это никем не поддерживается, но, тем не менее, вот, мол, мы не хотим распространять, поэтому, значит, мол, убрали в private.
6383.40 6384.40 "Игорь Лабутин" Вот, после того, как...
6384.40 6390.40 "Анатолий Кулаков" И почему их это заволновало, как бы, после нескольких лет открытия своей компании и успешного бизнеса?
6390.40 6408.40 "Игорь Лабутин" Это непонятный вопрос, возможно, они как-то пытаются больше коммерциализировать, найти больше кастомеров на новый свой, ну, вот, на дуэндо свой, значит, сервер, или как он правильно называется, а может быть, из-за этого, может быть, еще из-за чего-то, может быть, руки дошли, наконец-таки, непонятно.
6408.40 6410.40 "Игорь Лабутин" В общем, короче, убрали в private.
6410.40 6422.40 "Игорь Лабутин" Появилось обсуждение на реддите, плюс в гитхабовский дискашн в дуэндо софтвер организации, завели тоже дискашн со словами, ну, как бы, ребят, вы чё?
6422.40 6432.40 "Игорь Лабутин" Оставили бы в архиве, и как бы, ну, ну, а даже если вы очень хотите удалить, так вы бы хоть предупредили, ну, и как бы, мало ли чё.
6432.40 6442.40 "Игорь Лабутин" Вот. На что в итоге, значит, они сказали, ну, ладно, да, типа, погорячились, значит, на предмет того, что прям, что мы его закрыли, но мы его открыли обратно.
6442.40 6476.40 "Игорь Лабутин" Он сейчас, его можно найти, он находится в архивном статусе, но там нет ни одного пиара, ни одного ишью, соответственно, вся история в этом смысле утрачена, и он будет всё равно опять обратно закрыт 28 февраля, то есть условно они дали там неделю-полторы на тему того, что если чё-то хотите, забирайте, делайте форки, там вот это всё, ещё, но потом мы его снова закроем точно, уже и окончательно.
6476.40 6482.40 "Игорь Лабутин" Ну, что такие дела, если вы вдруг пользуетесь идентити сервером, не забудьте сделать форк себе.
6482.40 6488.40 "Анатолий Кулаков" Ну, беспредел, беспредел вообще как-то, что это так, не дают нам даже на ридонле нашей репозитории посмотреть.
6488.40 6498.40 "Игорь Лабутин" Ну вот, посмотрим, куда история подвинется, может ещё будет какой-нибудь фоллоуап на эту тему, когда 28-го его заново закроют, поглядим, последим, может чё будет рассказать в следующем подкасте, не знаю пока.
6498.40 6502.40 "Игорь Лабутин" Может какую-то новую аргументацию найдут, увидим.
6502.40 6506.40 "Игорь Лабутин" Ну вот на этом, наверное, всё на сегодня.
6506.40 6508.40 "Игорь Лабутин" Да, да,
6508.40 6510.40 "Анатолий Кулаков" точно всё, давай завершаться.
6510.40 6546.40 "Игорь Лабутин" Давай завершаться, мы сегодня поговорили про Visual Studio 2022, новый релиз 17.13, про статью о гибридном кашировании, про Async/void вспомнили, поговорили про систему эффектов и как это можно реализовать в C#, используя наши хитрые кастомные Async метод билдеры, посмотрели на интеграцию OVS в Aspire, порадовались, что кто-то выбирает всё ещё C# в качестве языка для стартапа, и очень рад от этого, ну и Identity Server, да, если он вам нужен, бегите, клонируйте, форкайте себе.
6546.40 6550.40 "Игорь Лабутин" На этом у нас на сегодня всё.
6550.40 6558.40 "Анатолий Кулаков" Да, всё, а также бегите, ставьте нам звёздочки, лайки, шары, репосты, что вы там умеете, вот это вот всё, мы будем вам чрезвычайно признательны.
6558.40 6560.40 "Анатолий Кулаков" До новых встреч, пока.
